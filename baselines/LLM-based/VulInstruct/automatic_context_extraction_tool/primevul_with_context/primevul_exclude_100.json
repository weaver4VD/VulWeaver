[
  {
    "repository": "nbdkit",
    "cve_id": "CVE-2021-3716",
    "cwe_list": [
      "CWE-924"
    ],
    "commit_hash": "6c5faac6a37077cf2366388a80862bb00616d0d8",
    "short_hash": "6c5faac6",
    "vulnerableMethods_before": [
      {
        "filename": "protocol-handshake-newstyle.c",
        "method_name": "vulnerable_function",
        "raw_code": "negotiate_handshake_newstyle_options (void)\n{\n  GET_CONN;\n  struct nbd_new_option new_option;\n  size_t nr_options;\n  bool list_seen = false;\n  uint64_t version;\n  uint32_t option;\n  uint32_t optlen;\n  struct nbd_export_name_option_reply handshake_finish;\n  const char *optname;\n  uint64_t exportsize;\n  struct backend *b;\n\n  for (nr_options = MAX_NR_OPTIONS; nr_options > 0; --nr_options) {\n    CLEANUP_FREE char *data = NULL;\n\n    if (conn_recv_full (&new_option, sizeof new_option,\n                        \"reading option: conn->recv: %m\") == -1)\n      return -1;\n\n    version = be64toh (new_option.version);\n    if (version != NBD_NEW_VERSION) {\n      nbdkit_error (\"unknown option version %\" PRIx64\n                    \", expecting %\" PRIx64,\n                    version, NBD_NEW_VERSION);\n      return -1;\n    }\n\n    /* There is a maximum option length we will accept, regardless\n     * of the option type.\n     */\n    optlen = be32toh (new_option.optlen);\n    if (optlen > MAX_REQUEST_SIZE) {\n      nbdkit_error (\"client option data too long (%\" PRIu32 \")\", optlen);\n      return -1;\n    }\n    data = malloc (optlen + 1); /* Allowing a trailing NUL helps some uses */\n    if (data == NULL) {\n      nbdkit_error (\"malloc: %m\");\n      return -1;\n    }\n\n    option = be32toh (new_option.option);\n    optname = name_of_nbd_opt (option);\n\n    /* If the client lacks fixed newstyle support, it should only send\n     * NBD_OPT_EXPORT_NAME.\n     */\n    if (!(conn->cflags & NBD_FLAG_FIXED_NEWSTYLE) &&\n        option != NBD_OPT_EXPORT_NAME) {\n      if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID))\n        return -1;\n      continue;\n    }\n\n    /* In --tls=require / FORCEDTLS mode the only options allowed\n     * before TLS negotiation are NBD_OPT_ABORT and NBD_OPT_STARTTLS.\n     */\n    if (tls == 2 && !conn->using_tls &&\n        !(option == NBD_OPT_ABORT || option == NBD_OPT_STARTTLS)) {\n      if (send_newstyle_option_reply (option, NBD_REP_ERR_TLS_REQD))\n        return -1;\n      continue;\n    }\n\n    switch (option) {\n    case NBD_OPT_EXPORT_NAME:\n      if (conn_recv_full (data, optlen,\n                          \"read: %s: %m\", name_of_nbd_opt (option)) == -1)\n        return -1;\n      if (check_export_name (option, data, optlen, optlen) == -1)\n        return -1;\n\n      /* We have to finish the handshake by sending handshake_finish.\n       * On failure, we have to disconnect.\n       */\n      if (finish_newstyle_options (&exportsize, data, optlen) == -1)\n        return -1;\n\n      memset (&handshake_finish, 0, sizeof handshake_finish);\n      handshake_finish.exportsize = htobe64 (exportsize);\n      handshake_finish.eflags = htobe16 (conn->eflags);\n\n      if (conn->send (&handshake_finish,\n                      (conn->cflags & NBD_FLAG_NO_ZEROES)\n                      ? offsetof (struct nbd_export_name_option_reply, zeroes)\n                      : sizeof handshake_finish, 0) == -1) {\n        nbdkit_error (\"write: %s: %m\", optname);\n        return -1;\n      }\n      break;\n\n    case NBD_OPT_ABORT:\n      if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)\n        return -1;\n      debug (\"client sent %s to abort the connection\",\n             name_of_nbd_opt (option));\n      return -1;\n\n    case NBD_OPT_LIST:\n      if (optlen != 0) {\n        if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n            == -1)\n          return -1;\n        if (conn_recv_full (data, optlen,\n                            \"read: %s: %m\", name_of_nbd_opt (option)) == -1)\n          return -1;\n        continue;\n      }\n\n      if (list_seen) {\n        debug (\"newstyle negotiation: %s: export list already advertised\",\n               name_of_nbd_opt (option));\n        if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID) == -1)\n          return -1;\n        continue;\n      }\n      else {\n        /* Send back the exportname list. */\n        debug (\"newstyle negotiation: %s: advertising exports\",\n               name_of_nbd_opt (option));\n        if (send_newstyle_option_reply_exportnames (option, &nr_options) == -1)\n          return -1;\n        list_seen = true;\n      }\n      break;\n\n    case NBD_OPT_STARTTLS:\n      if (optlen != 0) {\n        if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n            == -1)\n          return -1;\n        if (conn_recv_full (data, optlen,\n                            \"read: %s: %m\", name_of_nbd_opt (option)) == -1)\n          return -1;\n        continue;\n      }\n\n      if (tls == 0) {           /* --tls=off (NOTLS mode). */\n#ifdef HAVE_GNUTLS\n#define NO_TLS_REPLY NBD_REP_ERR_POLICY\n#else\n#define NO_TLS_REPLY NBD_REP_ERR_UNSUP\n#endif\n        if (send_newstyle_option_reply (option, NO_TLS_REPLY) == -1)\n          return -1;\n      }\n      else /* --tls=on or --tls=require */ {\n        /* We can't upgrade to TLS twice on the same connection. */\n        if (conn->using_tls) {\n          if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID) == -1)\n            return -1;\n          continue;\n        }\n\n        /* We have to send the (unencrypted) reply before starting\n         * the handshake.\n         */\n        if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)\n          return -1;\n\n        /* Upgrade the connection to TLS.  Also performs access control. */\n        if (crypto_negotiate_tls (conn->sockin, conn->sockout) == -1)\n          return -1;\n        conn->using_tls = true;\n        debug (\"using TLS on this connection\");\n        /* Wipe out any cached state. */\n        conn->structured_replies = false;\n        for_each_backend (b) {\n          free (conn->default_exportname[b->i]);\n          conn->default_exportname[b->i] = NULL;\n        }\n      }\n      break;\n\n    case NBD_OPT_INFO:\n    case NBD_OPT_GO:\n      if (conn_recv_full (data, optlen, \"read: %s: %m\", optname) == -1)\n        return -1;\n\n      if (optlen < 6) { /* 32 bit export length + 16 bit nr info */\n        debug (\"newstyle negotiation: %s option length < 6\", optname);\n\n        if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n            == -1)\n          return -1;\n        continue;\n      }\n\n      {\n        uint32_t exportnamelen;\n        uint16_t nrinfos;\n        uint16_t info;\n        size_t i;\n\n        /* Validate the name length and number of INFO requests. */\n        memcpy (&exportnamelen, &data[0], 4);\n        exportnamelen = be32toh (exportnamelen);\n        if (exportnamelen > optlen-6 /* NB optlen >= 6, see above */) {\n          debug (\"newstyle negotiation: %s: export name too long\", optname);\n          if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n              == -1)\n            return -1;\n          continue;\n        }\n        memcpy (&nrinfos, &data[exportnamelen+4], 2);\n        nrinfos = be16toh (nrinfos);\n        if (optlen != 4 + exportnamelen + 2 + 2*nrinfos) {\n          debug (\"newstyle negotiation: %s: \"\n                 \"number of information requests incorrect\", optname);\n          if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n              == -1)\n            return -1;\n          continue;\n        }\n\n        /* As with NBD_OPT_EXPORT_NAME we print the export name and\n         * save it in the connection.  If an earlier\n         * NBD_OPT_SET_META_CONTEXT used an export name, it must match\n         * or else we drop the support for that context.\n         */\n        if (check_export_name (option, &data[4], exportnamelen,\n                               optlen - 6) == -1) {\n          if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n              == -1)\n            return -1;\n          continue;\n        }\n\n        /* The spec is confusing, but it is required that we send back\n         * NBD_INFO_EXPORT, even if the client did not request it!\n         * qemu client in particular does not request this, but will\n         * fail if we don't send it.  Note that if .open fails, but we\n         * succeed at .close, then we merely return an error to the\n         * client and let them try another NBD_OPT, rather than\n         * disconnecting.\n         */\n        if (finish_newstyle_options (&exportsize,\n                                     &data[4], exportnamelen) == -1) {\n          if (conn->top_context) {\n            if (backend_finalize (conn->top_context) == -1)\n              return -1;\n            backend_close (conn->top_context);\n            conn->top_context = NULL;\n          }\n          if (send_newstyle_option_reply (option, NBD_REP_ERR_UNKNOWN) == -1)\n            return -1;\n          continue;\n        }\n\n        if (send_newstyle_option_reply_info_export (option,\n                                                    NBD_REP_INFO,\n                                                    NBD_INFO_EXPORT,\n                                                    exportsize) == -1)\n          return -1;\n\n        /* For now we send NBD_INFO_NAME and NBD_INFO_DESCRIPTION if\n         * requested, and ignore all other info requests (including\n         * NBD_INFO_EXPORT if it was requested, because we replied\n         * already above).\n         */\n        for (i = 0; i < nrinfos; ++i) {\n          memcpy (&info, &data[4 + exportnamelen + 2 + i*2], 2);\n          info = be16toh (info);\n          switch (info) {\n          case NBD_INFO_EXPORT: /* ignore - reply sent above */ break;\n          case NBD_INFO_NAME:\n            {\n              const char *name = &data[4];\n              size_t namelen = exportnamelen;\n\n              if (exportnamelen == 0) {\n                name = backend_default_export (top, read_only);\n                if (!name) {\n                  debug (\"newstyle negotiation: %s: \"\n                         \"NBD_INFO_NAME: no name to send\", optname);\n                  break;\n                }\n                namelen = -1;\n              }\n              if (send_newstyle_option_reply_info_str (option,\n                                                       NBD_REP_INFO,\n                                                       NBD_INFO_NAME,\n                                                       name, namelen) == -1)\n                return -1;\n            }\n            break;\n          case NBD_INFO_DESCRIPTION:\n            {\n              const char *desc = backend_export_description (conn->top_context);\n\n              if (!desc) {\n                debug (\"newstyle negotiation: %s: \"\n                       \"NBD_INFO_DESCRIPTION: no description to send\",\n                       optname);\n                break;\n              }\n              if (send_newstyle_option_reply_info_str (option,\n                                                       NBD_REP_INFO,\n                                                       NBD_INFO_DESCRIPTION,\n                                                       desc, -1) == -1)\n                return -1;\n            }\n            break;\n          default:\n            debug (\"newstyle negotiation: %s: \"\n                   \"ignoring NBD_INFO_* request %u (%s)\",\n                   optname, (unsigned) info, name_of_nbd_info (info));\n            break;\n          }\n        }\n      }\n\n      /* Unlike NBD_OPT_EXPORT_NAME, NBD_OPT_GO sends back an ACK\n       * or ERROR packet.  If this was NBD_OPT_LIST, call .close.\n       */\n      if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)\n        return -1;\n\n      if (option == NBD_OPT_INFO) {\n        if (backend_finalize (conn->top_context) == -1)\n          return -1;\n        backend_close (conn->top_context);\n        conn->top_context = NULL;\n      }\n\n      break;\n\n    case NBD_OPT_STRUCTURED_REPLY:\n      if (optlen != 0) {\n        if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n            == -1)\n          return -1;\n        if (conn_recv_full (data, optlen,\n                            \"read: %s: %m\", name_of_nbd_opt (option)) == -1)\n          return -1;\n        continue;\n      }\n\n      debug (\"newstyle negotiation: %s: client requested structured replies\",\n             name_of_nbd_opt (option));\n\n      if (no_sr) {\n        /* Must fail with ERR_UNSUP for qemu 4.2 to remain happy;\n         * but failing with ERR_POLICY would have been nicer.\n         */\n        if (send_newstyle_option_reply (option, NBD_REP_ERR_UNSUP) == -1)\n          return -1;\n        debug (\"newstyle negotiation: %s: structured replies are disabled\",\n               name_of_nbd_opt (option));\n        break;\n      }\n\n      if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)\n        return -1;\n\n      conn->structured_replies = true;\n      break;\n\n    case NBD_OPT_LIST_META_CONTEXT:\n    case NBD_OPT_SET_META_CONTEXT:\n      {\n        uint32_t opt_index;\n        uint32_t exportnamelen;\n        uint32_t nr_queries;\n        uint32_t querylen;\n        const char *what;\n\n        if (conn_recv_full (data, optlen, \"read: %s: %m\", optname) == -1)\n          return -1;\n\n        /* Note that we support base:allocation whether or not the plugin\n         * supports can_extents.\n         */\n        if (!conn->structured_replies) {\n          if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n              == -1)\n            return -1;\n          continue;\n        }\n\n        /* Minimum length of the option payload is:\n         *   32 bit export name length followed by empty export name\n         * + 32 bit number of queries followed by no queries\n         * = 8 bytes.\n         */\n        what = \"optlen < 8\";\n        if (optlen < 8) {\n        opt_meta_invalid_option_len:\n          debug (\"newstyle negotiation: %s: invalid option length: %s\",\n                 optname, what);\n\n          if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n              == -1)\n            return -1;\n          continue;\n        }\n\n        memcpy (&exportnamelen, &data[0], 4);\n        exportnamelen = be32toh (exportnamelen);\n        what = \"validating export name\";\n        if (check_export_name (option, &data[4], exportnamelen,\n                               optlen - 8) == -1)\n          goto opt_meta_invalid_option_len;\n\n        /* Remember the export name: the NBD spec says that if the client\n         * later uses NBD_OPT_GO on a different export, then the context\n         * returned here is not usable.\n         */\n        if (option == NBD_OPT_SET_META_CONTEXT) {\n          conn->exportname_from_set_meta_context =\n            strndup (&data[4], exportnamelen);\n          if (conn->exportname_from_set_meta_context == NULL) {\n            nbdkit_error (\"malloc: %m\");\n            return -1;\n          }\n        }\n\n        opt_index = 4 + exportnamelen;\n\n        /* Read the number of queries. */\n        what = \"reading number of queries\";\n        if (opt_index+4 > optlen)\n          goto opt_meta_invalid_option_len;\n        memcpy (&nr_queries, &data[opt_index], 4);\n        nr_queries = be32toh (nr_queries);\n        opt_index += 4;\n\n        /* for LIST: nr_queries == 0 means return all meta contexts\n         * for SET: nr_queries == 0 means reset all contexts\n         */\n        debug (\"newstyle negotiation: %s: %s count: %d\", optname,\n               option == NBD_OPT_LIST_META_CONTEXT ? \"query\" : \"set\",\n               nr_queries);\n        if (option == NBD_OPT_SET_META_CONTEXT)\n          conn->meta_context_base_allocation = false;\n        if (nr_queries == 0) {\n          if (option == NBD_OPT_LIST_META_CONTEXT) {\n            if (send_newstyle_option_reply_meta_context (option,\n                                                         NBD_REP_META_CONTEXT,\n                                                         0, \"base:allocation\")\n                == -1)\n              return -1;\n          }\n\n          if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)\n            return -1;\n        }\n        else {\n          /* Read and answer each query. */\n          while (nr_queries > 0) {\n            what = \"reading query string length\";\n            if (opt_index+4 > optlen)\n              goto opt_meta_invalid_option_len;\n            memcpy (&querylen, &data[opt_index], 4);\n            querylen = be32toh (querylen);\n            opt_index += 4;\n            what = \"reading query string\";\n            if (check_string (option, &data[opt_index], querylen,\n                              optlen - opt_index, \"meta context query\") == -1)\n              goto opt_meta_invalid_option_len;\n\n            debug (\"newstyle negotiation: %s: %s %.*s\",\n                   optname,\n                   option == NBD_OPT_LIST_META_CONTEXT ? \"query\" : \"set\",\n                   (int) querylen, &data[opt_index]);\n\n            /* For LIST, \"base:\" returns all supported contexts in the\n             * base namespace.  We only support \"base:allocation\".\n             */\n            if (option == NBD_OPT_LIST_META_CONTEXT &&\n                querylen == 5 &&\n                strncmp (&data[opt_index], \"base:\", 5) == 0) {\n              if (send_newstyle_option_reply_meta_context\n                  (option, NBD_REP_META_CONTEXT,\n                   0, \"base:allocation\") == -1)\n                return -1;\n            }\n            /* \"base:allocation\" requested by name. */\n            else if (querylen == 15 &&\n                     strncmp (&data[opt_index], \"base:allocation\", 15) == 0) {\n              if (send_newstyle_option_reply_meta_context\n                  (option, NBD_REP_META_CONTEXT,\n                   option == NBD_OPT_SET_META_CONTEXT\n                   ? base_allocation_id : 0,\n                   \"base:allocation\") == -1)\n                return -1;\n              if (option == NBD_OPT_SET_META_CONTEXT)\n                conn->meta_context_base_allocation = true;\n            }\n            /* Every other query must be ignored. */\n\n            opt_index += querylen;\n            nr_queries--;\n          }\n          if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)\n            return -1;\n        }\n        debug (\"newstyle negotiation: %s: reply complete\", optname);\n      }\n      break;\n\n    default:\n      /* Unknown option. */\n      if (send_newstyle_option_reply (option, NBD_REP_ERR_UNSUP) == -1)\n        return -1;\n      if (conn_recv_full (data, optlen,\n                          \"reading unknown option data: conn->recv: %m\") == -1)\n        return -1;\n    }\n\n    /* Note, since it's not very clear from the protocol doc, that the\n     * client must send NBD_OPT_EXPORT_NAME or NBD_OPT_GO last, and\n     * that ends option negotiation.\n     */\n    if (option == NBD_OPT_EXPORT_NAME || option == NBD_OPT_GO)\n      break;\n  }\n\n  if (nr_options == 0) {\n    nbdkit_error (\"client spent too much time negotiating without selecting \"\n                  \"an export\");\n    return -1;\n  }\n\n  /* In --tls=require / FORCEDTLS mode, we must have upgraded to TLS\n   * by the time we finish option negotiation.  If not, give up.\n   */\n  if (tls == 2 && !conn->using_tls) {\n    nbdkit_error (\"non-TLS client tried to connect in --tls=require mode\");\n    return -1;\n  }\n\n  return 0;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "protocol-handshake-newstyle.c",
        "method_name": "fixed_function",
        "raw_code": "negotiate_handshake_newstyle_options (void)\n{\n  GET_CONN;\n  struct nbd_new_option new_option;\n  size_t nr_options;\n  bool list_seen = false;\n  uint64_t version;\n  uint32_t option;\n  uint32_t optlen;\n  struct nbd_export_name_option_reply handshake_finish;\n  const char *optname;\n  uint64_t exportsize;\n  struct backend *b;\n\n  for (nr_options = MAX_NR_OPTIONS; nr_options > 0; --nr_options) {\n    CLEANUP_FREE char *data = NULL;\n\n    if (conn_recv_full (&new_option, sizeof new_option,\n                        \"reading option: conn->recv: %m\") == -1)\n      return -1;\n\n    version = be64toh (new_option.version);\n    if (version != NBD_NEW_VERSION) {\n      nbdkit_error (\"unknown option version %\" PRIx64\n                    \", expecting %\" PRIx64,\n                    version, NBD_NEW_VERSION);\n      return -1;\n    }\n\n    /* There is a maximum option length we will accept, regardless\n     * of the option type.\n     */\n    optlen = be32toh (new_option.optlen);\n    if (optlen > MAX_REQUEST_SIZE) {\n      nbdkit_error (\"client option data too long (%\" PRIu32 \")\", optlen);\n      return -1;\n    }\n    data = malloc (optlen + 1); /* Allowing a trailing NUL helps some uses */\n    if (data == NULL) {\n      nbdkit_error (\"malloc: %m\");\n      return -1;\n    }\n\n    option = be32toh (new_option.option);\n    optname = name_of_nbd_opt (option);\n\n    /* If the client lacks fixed newstyle support, it should only send\n     * NBD_OPT_EXPORT_NAME.\n     */\n    if (!(conn->cflags & NBD_FLAG_FIXED_NEWSTYLE) &&\n        option != NBD_OPT_EXPORT_NAME) {\n      if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID))\n        return -1;\n      continue;\n    }\n\n    /* In --tls=require / FORCEDTLS mode the only options allowed\n     * before TLS negotiation are NBD_OPT_ABORT and NBD_OPT_STARTTLS.\n     */\n    if (tls == 2 && !conn->using_tls &&\n        !(option == NBD_OPT_ABORT || option == NBD_OPT_STARTTLS)) {\n      if (send_newstyle_option_reply (option, NBD_REP_ERR_TLS_REQD))\n        return -1;\n      continue;\n    }\n\n    switch (option) {\n    case NBD_OPT_EXPORT_NAME:\n      if (conn_recv_full (data, optlen,\n                          \"read: %s: %m\", name_of_nbd_opt (option)) == -1)\n        return -1;\n      if (check_export_name (option, data, optlen, optlen) == -1)\n        return -1;\n\n      /* We have to finish the handshake by sending handshake_finish.\n       * On failure, we have to disconnect.\n       */\n      if (finish_newstyle_options (&exportsize, data, optlen) == -1)\n        return -1;\n\n      memset (&handshake_finish, 0, sizeof handshake_finish);\n      handshake_finish.exportsize = htobe64 (exportsize);\n      handshake_finish.eflags = htobe16 (conn->eflags);\n\n      if (conn->send (&handshake_finish,\n                      (conn->cflags & NBD_FLAG_NO_ZEROES)\n                      ? offsetof (struct nbd_export_name_option_reply, zeroes)\n                      : sizeof handshake_finish, 0) == -1) {\n        nbdkit_error (\"write: %s: %m\", optname);\n        return -1;\n      }\n      break;\n\n    case NBD_OPT_ABORT:\n      if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)\n        return -1;\n      debug (\"client sent %s to abort the connection\",\n             name_of_nbd_opt (option));\n      return -1;\n\n    case NBD_OPT_LIST:\n      if (optlen != 0) {\n        if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n            == -1)\n          return -1;\n        if (conn_recv_full (data, optlen,\n                            \"read: %s: %m\", name_of_nbd_opt (option)) == -1)\n          return -1;\n        continue;\n      }\n\n      if (list_seen) {\n        debug (\"newstyle negotiation: %s: export list already advertised\",\n               name_of_nbd_opt (option));\n        if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID) == -1)\n          return -1;\n        continue;\n      }\n      else {\n        /* Send back the exportname list. */\n        debug (\"newstyle negotiation: %s: advertising exports\",\n               name_of_nbd_opt (option));\n        if (send_newstyle_option_reply_exportnames (option, &nr_options) == -1)\n          return -1;\n        list_seen = true;\n      }\n      break;\n\n    case NBD_OPT_STARTTLS:\n      if (optlen != 0) {\n        if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n            == -1)\n          return -1;\n        if (conn_recv_full (data, optlen,\n                            \"read: %s: %m\", name_of_nbd_opt (option)) == -1)\n          return -1;\n        continue;\n      }\n\n      if (tls == 0) {           /* --tls=off (NOTLS mode). */\n#ifdef HAVE_GNUTLS\n#define NO_TLS_REPLY NBD_REP_ERR_POLICY\n#else\n#define NO_TLS_REPLY NBD_REP_ERR_UNSUP\n#endif\n        if (send_newstyle_option_reply (option, NO_TLS_REPLY) == -1)\n          return -1;\n      }\n      else /* --tls=on or --tls=require */ {\n        /* We can't upgrade to TLS twice on the same connection. */\n        if (conn->using_tls) {\n          if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID) == -1)\n            return -1;\n          continue;\n        }\n\n        /* We have to send the (unencrypted) reply before starting\n         * the handshake.\n         */\n        if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)\n          return -1;\n\n        /* Upgrade the connection to TLS.  Also performs access control. */\n        if (crypto_negotiate_tls (conn->sockin, conn->sockout) == -1)\n          return -1;\n        conn->using_tls = true;\n        debug (\"using TLS on this connection\");\n        /* Wipe out any cached state. */\n        conn->structured_replies = false;\n        free (conn->exportname_from_set_meta_context);\n        conn->exportname_from_set_meta_context = NULL;\n        conn->meta_context_base_allocation = false;\n        for_each_backend (b) {\n          free (conn->default_exportname[b->i]);\n          conn->default_exportname[b->i] = NULL;\n        }\n      }\n      break;\n\n    case NBD_OPT_INFO:\n    case NBD_OPT_GO:\n      if (conn_recv_full (data, optlen, \"read: %s: %m\", optname) == -1)\n        return -1;\n\n      if (optlen < 6) { /* 32 bit export length + 16 bit nr info */\n        debug (\"newstyle negotiation: %s option length < 6\", optname);\n\n        if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n            == -1)\n          return -1;\n        continue;\n      }\n\n      {\n        uint32_t exportnamelen;\n        uint16_t nrinfos;\n        uint16_t info;\n        size_t i;\n\n        /* Validate the name length and number of INFO requests. */\n        memcpy (&exportnamelen, &data[0], 4);\n        exportnamelen = be32toh (exportnamelen);\n        if (exportnamelen > optlen-6 /* NB optlen >= 6, see above */) {\n          debug (\"newstyle negotiation: %s: export name too long\", optname);\n          if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n              == -1)\n            return -1;\n          continue;\n        }\n        memcpy (&nrinfos, &data[exportnamelen+4], 2);\n        nrinfos = be16toh (nrinfos);\n        if (optlen != 4 + exportnamelen + 2 + 2*nrinfos) {\n          debug (\"newstyle negotiation: %s: \"\n                 \"number of information requests incorrect\", optname);\n          if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n              == -1)\n            return -1;\n          continue;\n        }\n\n        /* As with NBD_OPT_EXPORT_NAME we print the export name and\n         * save it in the connection.  If an earlier\n         * NBD_OPT_SET_META_CONTEXT used an export name, it must match\n         * or else we drop the support for that context.\n         */\n        if (check_export_name (option, &data[4], exportnamelen,\n                               optlen - 6) == -1) {\n          if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n              == -1)\n            return -1;\n          continue;\n        }\n\n        /* The spec is confusing, but it is required that we send back\n         * NBD_INFO_EXPORT, even if the client did not request it!\n         * qemu client in particular does not request this, but will\n         * fail if we don't send it.  Note that if .open fails, but we\n         * succeed at .close, then we merely return an error to the\n         * client and let them try another NBD_OPT, rather than\n         * disconnecting.\n         */\n        if (finish_newstyle_options (&exportsize,\n                                     &data[4], exportnamelen) == -1) {\n          if (conn->top_context) {\n            if (backend_finalize (conn->top_context) == -1)\n              return -1;\n            backend_close (conn->top_context);\n            conn->top_context = NULL;\n          }\n          if (send_newstyle_option_reply (option, NBD_REP_ERR_UNKNOWN) == -1)\n            return -1;\n          continue;\n        }\n\n        if (send_newstyle_option_reply_info_export (option,\n                                                    NBD_REP_INFO,\n                                                    NBD_INFO_EXPORT,\n                                                    exportsize) == -1)\n          return -1;\n\n        /* For now we send NBD_INFO_NAME and NBD_INFO_DESCRIPTION if\n         * requested, and ignore all other info requests (including\n         * NBD_INFO_EXPORT if it was requested, because we replied\n         * already above).\n         */\n        for (i = 0; i < nrinfos; ++i) {\n          memcpy (&info, &data[4 + exportnamelen + 2 + i*2], 2);\n          info = be16toh (info);\n          switch (info) {\n          case NBD_INFO_EXPORT: /* ignore - reply sent above */ break;\n          case NBD_INFO_NAME:\n            {\n              const char *name = &data[4];\n              size_t namelen = exportnamelen;\n\n              if (exportnamelen == 0) {\n                name = backend_default_export (top, read_only);\n                if (!name) {\n                  debug (\"newstyle negotiation: %s: \"\n                         \"NBD_INFO_NAME: no name to send\", optname);\n                  break;\n                }\n                namelen = -1;\n              }\n              if (send_newstyle_option_reply_info_str (option,\n                                                       NBD_REP_INFO,\n                                                       NBD_INFO_NAME,\n                                                       name, namelen) == -1)\n                return -1;\n            }\n            break;\n          case NBD_INFO_DESCRIPTION:\n            {\n              const char *desc = backend_export_description (conn->top_context);\n\n              if (!desc) {\n                debug (\"newstyle negotiation: %s: \"\n                       \"NBD_INFO_DESCRIPTION: no description to send\",\n                       optname);\n                break;\n              }\n              if (send_newstyle_option_reply_info_str (option,\n                                                       NBD_REP_INFO,\n                                                       NBD_INFO_DESCRIPTION,\n                                                       desc, -1) == -1)\n                return -1;\n            }\n            break;\n          default:\n            debug (\"newstyle negotiation: %s: \"\n                   \"ignoring NBD_INFO_* request %u (%s)\",\n                   optname, (unsigned) info, name_of_nbd_info (info));\n            break;\n          }\n        }\n      }\n\n      /* Unlike NBD_OPT_EXPORT_NAME, NBD_OPT_GO sends back an ACK\n       * or ERROR packet.  If this was NBD_OPT_LIST, call .close.\n       */\n      if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)\n        return -1;\n\n      if (option == NBD_OPT_INFO) {\n        if (backend_finalize (conn->top_context) == -1)\n          return -1;\n        backend_close (conn->top_context);\n        conn->top_context = NULL;\n      }\n\n      break;\n\n    case NBD_OPT_STRUCTURED_REPLY:\n      if (optlen != 0) {\n        if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n            == -1)\n          return -1;\n        if (conn_recv_full (data, optlen,\n                            \"read: %s: %m\", name_of_nbd_opt (option)) == -1)\n          return -1;\n        continue;\n      }\n\n      debug (\"newstyle negotiation: %s: client requested structured replies\",\n             name_of_nbd_opt (option));\n\n      if (no_sr) {\n        /* Must fail with ERR_UNSUP for qemu 4.2 to remain happy;\n         * but failing with ERR_POLICY would have been nicer.\n         */\n        if (send_newstyle_option_reply (option, NBD_REP_ERR_UNSUP) == -1)\n          return -1;\n        debug (\"newstyle negotiation: %s: structured replies are disabled\",\n               name_of_nbd_opt (option));\n        break;\n      }\n\n      if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)\n        return -1;\n\n      conn->structured_replies = true;\n      break;\n\n    case NBD_OPT_LIST_META_CONTEXT:\n    case NBD_OPT_SET_META_CONTEXT:\n      {\n        uint32_t opt_index;\n        uint32_t exportnamelen;\n        uint32_t nr_queries;\n        uint32_t querylen;\n        const char *what;\n\n        if (conn_recv_full (data, optlen, \"read: %s: %m\", optname) == -1)\n          return -1;\n\n        /* Note that we support base:allocation whether or not the plugin\n         * supports can_extents.\n         */\n        if (!conn->structured_replies) {\n          if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n              == -1)\n            return -1;\n          continue;\n        }\n\n        /* Minimum length of the option payload is:\n         *   32 bit export name length followed by empty export name\n         * + 32 bit number of queries followed by no queries\n         * = 8 bytes.\n         */\n        what = \"optlen < 8\";\n        if (optlen < 8) {\n        opt_meta_invalid_option_len:\n          debug (\"newstyle negotiation: %s: invalid option length: %s\",\n                 optname, what);\n\n          if (send_newstyle_option_reply (option, NBD_REP_ERR_INVALID)\n              == -1)\n            return -1;\n          continue;\n        }\n\n        memcpy (&exportnamelen, &data[0], 4);\n        exportnamelen = be32toh (exportnamelen);\n        what = \"validating export name\";\n        if (check_export_name (option, &data[4], exportnamelen,\n                               optlen - 8) == -1)\n          goto opt_meta_invalid_option_len;\n\n        /* Remember the export name: the NBD spec says that if the client\n         * later uses NBD_OPT_GO on a different export, then the context\n         * returned here is not usable.\n         */\n        if (option == NBD_OPT_SET_META_CONTEXT) {\n          conn->exportname_from_set_meta_context =\n            strndup (&data[4], exportnamelen);\n          if (conn->exportname_from_set_meta_context == NULL) {\n            nbdkit_error (\"malloc: %m\");\n            return -1;\n          }\n        }\n\n        opt_index = 4 + exportnamelen;\n\n        /* Read the number of queries. */\n        what = \"reading number of queries\";\n        if (opt_index+4 > optlen)\n          goto opt_meta_invalid_option_len;\n        memcpy (&nr_queries, &data[opt_index], 4);\n        nr_queries = be32toh (nr_queries);\n        opt_index += 4;\n\n        /* for LIST: nr_queries == 0 means return all meta contexts\n         * for SET: nr_queries == 0 means reset all contexts\n         */\n        debug (\"newstyle negotiation: %s: %s count: %d\", optname,\n               option == NBD_OPT_LIST_META_CONTEXT ? \"query\" : \"set\",\n               nr_queries);\n        if (option == NBD_OPT_SET_META_CONTEXT)\n          conn->meta_context_base_allocation = false;\n        if (nr_queries == 0) {\n          if (option == NBD_OPT_LIST_META_CONTEXT) {\n            if (send_newstyle_option_reply_meta_context (option,\n                                                         NBD_REP_META_CONTEXT,\n                                                         0, \"base:allocation\")\n                == -1)\n              return -1;\n          }\n\n          if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)\n            return -1;\n        }\n        else {\n          /* Read and answer each query. */\n          while (nr_queries > 0) {\n            what = \"reading query string length\";\n            if (opt_index+4 > optlen)\n              goto opt_meta_invalid_option_len;\n            memcpy (&querylen, &data[opt_index], 4);\n            querylen = be32toh (querylen);\n            opt_index += 4;\n            what = \"reading query string\";\n            if (check_string (option, &data[opt_index], querylen,\n                              optlen - opt_index, \"meta context query\") == -1)\n              goto opt_meta_invalid_option_len;\n\n            debug (\"newstyle negotiation: %s: %s %.*s\",\n                   optname,\n                   option == NBD_OPT_LIST_META_CONTEXT ? \"query\" : \"set\",\n                   (int) querylen, &data[opt_index]);\n\n            /* For LIST, \"base:\" returns all supported contexts in the\n             * base namespace.  We only support \"base:allocation\".\n             */\n            if (option == NBD_OPT_LIST_META_CONTEXT &&\n                querylen == 5 &&\n                strncmp (&data[opt_index], \"base:\", 5) == 0) {\n              if (send_newstyle_option_reply_meta_context\n                  (option, NBD_REP_META_CONTEXT,\n                   0, \"base:allocation\") == -1)\n                return -1;\n            }\n            /* \"base:allocation\" requested by name. */\n            else if (querylen == 15 &&\n                     strncmp (&data[opt_index], \"base:allocation\", 15) == 0) {\n              if (send_newstyle_option_reply_meta_context\n                  (option, NBD_REP_META_CONTEXT,\n                   option == NBD_OPT_SET_META_CONTEXT\n                   ? base_allocation_id : 0,\n                   \"base:allocation\") == -1)\n                return -1;\n              if (option == NBD_OPT_SET_META_CONTEXT)\n                conn->meta_context_base_allocation = true;\n            }\n            /* Every other query must be ignored. */\n\n            opt_index += querylen;\n            nr_queries--;\n          }\n          if (send_newstyle_option_reply (option, NBD_REP_ACK) == -1)\n            return -1;\n        }\n        debug (\"newstyle negotiation: %s: reply complete\", optname);\n      }\n      break;\n\n    default:\n      /* Unknown option. */\n      if (send_newstyle_option_reply (option, NBD_REP_ERR_UNSUP) == -1)\n        return -1;\n      if (conn_recv_full (data, optlen,\n                          \"reading unknown option data: conn->recv: %m\") == -1)\n        return -1;\n    }\n\n    /* Note, since it's not very clear from the protocol doc, that the\n     * client must send NBD_OPT_EXPORT_NAME or NBD_OPT_GO last, and\n     * that ends option negotiation.\n     */\n    if (option == NBD_OPT_EXPORT_NAME || option == NBD_OPT_GO)\n      break;\n  }\n\n  if (nr_options == 0) {\n    nbdkit_error (\"client spent too much time negotiating without selecting \"\n                  \"an export\");\n    return -1;\n  }\n\n  /* In --tls=require / FORCEDTLS mode, we must have upgraded to TLS\n   * by the time we finish option negotiation.  If not, give up.\n   */\n  if (tls == 2 && !conn->using_tls) {\n    nbdkit_error (\"non-TLS client tried to connect in --tls=require mode\");\n    return -1;\n  }\n\n  return 0;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"nbd-protocol.h\"\n#include <inttypes.h>\n#include \"internal.h\"\n#include <string.h>\n#include <stdint.h>\n#include <config.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include \"byte-swapping.h\"\n#include <stdio.h>\n#include \"protostrings.h\"\n\n// Type Definitions:\n// nbd_export_name_option_reply:\nstruct nbd_export_name_option_reply {\n  uint64_t exportsize;        /* size of export */\n  uint16_t eflags;            /* per-export flags */\n  char zeroes[124];           /* optional zeroes, unless NBD_FLAG_NO_ZEROES */\n}\n\n// connection:\nstruct connection\n\n// backend:\nstruct backend {\n  /* Next filter or plugin in the chain.  This is always NULL for\n   * plugins and never NULL for filters.\n   */\n  struct backend *next;\n\n  /* A unique index used to fetch the handle from the connections\n   * object.  The plugin (last in the chain) has index 0, and the\n   * filters have index 1, 2, ... depending how \"far\" they are from\n   * the plugin.\n   */\n  size_t i;\n\n  /* The type of backend: filter or plugin. */\n  const char *type;\n\n  /* A copy of the backend name that survives a dlclose. */\n  char *name;\n\n  /* The file the backend was loaded from. */\n  char *filename;\n\n  /* The dlopen handle for the backend. */\n  void *dl;\n\n  /* Backend callbacks. All are required. */\n  void (*free) (struct backend *);\n  int (*thread_model) (struct backend *);\n  const char *(*plugin_name) (struct backend *);\n  void (*usage) (struct backend *);\n  const char *(*version) (struct backend *);\n  void (*dump_fields) (struct backend *);\n  void (*config) (struct backend *, const char *...\n\n// backend:\nstruct backend\n\n// nbd_new_option:\nstruct nbd_new_option {\n  uint64_t version;           /* NBD_NEW_VERSION */\n  uint32_t option;            /* NBD_OPT_* */\n  uint32_t optlen;            /* option data length */\n  /* option data follows */\n}\n\n// connection:\nstruct connection {\n  pthread_mutex_t request_lock;\n  pthread_mutex_t read_lock;\n  pthread_mutex_t write_lock;\n  pthread_mutex_t status_lock;\n\n  int status; /* 1 for more I/O with client, 0 for shutdown, -1 on error */\n  int status_pipe[2]; /* track status changes via poll when nworkers > 1 */\n  void *crypto_session;\n  int nworkers;\n\n  struct context *top_context;  /* The context tied to 'top'. */\n  char **default_exportname;    /* One per plugin and filter. */\n\n  uint32_t cflags;\n  uint16_t eflags;\n  bool handshake_complete;\n  bool using_tls;\n  bool structured_replies;\n  bool meta_context_base_allocation;\n\n  string_vector interns;\n  char *exportname_from_set_meta_context;\n  const char *exportname;\n\n  int sockin, sockout;\n  connection_recv_function recv;\n  connection_send_function send;\n  connection_close_function close;\n}\n\n// Called Methods (top 10):\n// NBD_FLAG_SEND_FUA from server/nbd-protocol.h:\n\n\n// nbdkit_debug from common/bitmap/test-bitmap.c:\nvoid\nnbdkit_debug (const char *fs, ...)\n{\n  /* do nothing */\n}\n\n// GET_CONN from server/internal.h:\n<empty>\n\n// NBD_FLAG_SEND_FAST_ZERO from server/nbd-protocol.h:\n\n\n// nbdkit_get_export from server/exports.c:\nNBDKIT_DLL_PUBLIC const struct nbdkit_export /* <=== nbdkit_get_export */ \nnbdkit_get_export (const struct nbdkit_exports *exps, size_t i)\n{\n  assert (i < exps->exports.size);\n  return exps->exports.ptr[i];\n}\n\n// htobe64 from server/byte-swapping.h:\n<empty>\n\n// NBD_FLAG_CAN_MULTI_CONN from server/nbd-protocol.h:\n\n\n// strndup from common/replacements/strndup.c:\nchar *\nstrndup (const char *str, size_t n)\n{\n  size_t len;\n  char *copy;\n\n  for (len = 0; len < n && str[len]; len++)\n    continue;\n\n  if (!(copy = malloc(len + 1)))\n    return NULL;\n  memcpy (copy, str, len);\n  copy[len] = '\\0';\n  return copy;\n}\n\n// check_string from server/protocol-handshake-newstyle.c:\nstatic int\ncheck_string (uint32_t option, char *buf, uint32_t len, uint32_t maxlen,\n              const char *name)\n{\n  if (len > NBD_MAX_STRING || len > maxlen) {\n    nbdkit_error (\"%s: %s too long\", name_of_nbd_opt (option), name);\n    return -1;\n  }\n  if (strnlen (buf, len) != len) {\n    nbdkit_error (\"%s: %s may not include NUL bytes\",\n                  name_of_nbd_opt (option), name);\n    return -1;\n  }\n  /* TODO: Check for valid UTF-8? */\n  return 0;\n}\n\n// backend_default_export from server/backend.c:\nconst char *\nbackend_default_export (struct backend *b, int readonly)\n{\n  GET_CONN;\n  const char *s;\n\n  controlpath_debug (\"%s: default_export readonly=%d tls=%d\",\n                     b->name, readonly, conn->using_tls);\n\n  if (conn->default_exportname[b->i] == NULL) {\n    assert (conn->top_context == NULL);\n    s = b->default_export (b, readonly, conn->using_tls);\n    /* Ignore over-length strings. XXX Also ignore non-UTF8? */\n    if (s && strnlen (s, NBD_MAX_STRING + 1) > NBD_MAX_STRING) {\n      controlpath_debug (\"%s: default_export: ignoring invalid string\",\n                         b->name);\n      s = NULL;\n    }\n    if (s) {\n      /* Best effort caching */\n      conn->default_exportname[b->i] = strdup (s);\n      if (conn->default_exportname[b->i] == NULL)\n        return s;\n    }\n  }\n  return conn->default_exportname[b->i];\n}\n"
  },
  {
    "repository": "linux",
    "cve_id": "CVE-2019-19054",
    "cwe_list": [
      "CWE-401"
    ],
    "commit_hash": "a7b2df76b42bdd026e3106cf2ba97db41345a177",
    "short_hash": "a7b2df76",
    "vulnerableMethods_before": [
      {
        "filename": "cx23888-ir.c",
        "method_name": "vulnerable_function",
        "raw_code": "int cx23888_ir_probe(struct cx23885_dev *dev)\n{\n\tstruct cx23888_ir_state *state;\n\tstruct v4l2_subdev *sd;\n\tstruct v4l2_subdev_ir_parameters default_params;\n\tint ret;\n\n\tstate = kzalloc(sizeof(struct cx23888_ir_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&state->rx_kfifo_lock);\n\tif (kfifo_alloc(&state->rx_kfifo, CX23888_IR_RX_KFIFO_SIZE, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tstate->dev = dev;\n\tsd = &state->sd;\n\n\tv4l2_subdev_init(sd, &cx23888_ir_controller_ops);\n\tv4l2_set_subdevdata(sd, state);\n\t/* FIXME - fix the formatting of dev->v4l2_dev.name and use it */\n\tsnprintf(sd->name, sizeof(sd->name), \"%s/888-ir\", dev->name);\n\tsd->grp_id = CX23885_HW_888_IR;\n\n\tret = v4l2_device_register_subdev(&dev->v4l2_dev, sd);\n\tif (ret == 0) {\n\t\t/*\n\t\t * Ensure no interrupts arrive from '888 specific conditions,\n\t\t * since we ignore them in this driver to have commonality with\n\t\t * similar IR controller cores.\n\t\t */\n\t\tcx23888_ir_write4(dev, CX23888_IR_IRQEN_REG, 0);\n\n\t\tmutex_init(&state->rx_params_lock);\n\t\tdefault_params = default_rx_params;\n\t\tv4l2_subdev_call(sd, ir, rx_s_parameters, &default_params);\n\n\t\tmutex_init(&state->tx_params_lock);\n\t\tdefault_params = default_tx_params;\n\t\tv4l2_subdev_call(sd, ir, tx_s_parameters, &default_params);\n\t} else {\n\t\tkfifo_free(&state->rx_kfifo);\n\t}\n\treturn ret;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "cx23888-ir.c",
        "method_name": "fixed_function",
        "raw_code": "int cx23888_ir_probe(struct cx23885_dev *dev)\n{\n\tstruct cx23888_ir_state *state;\n\tstruct v4l2_subdev *sd;\n\tstruct v4l2_subdev_ir_parameters default_params;\n\tint ret;\n\n\tstate = kzalloc(sizeof(struct cx23888_ir_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&state->rx_kfifo_lock);\n\tif (kfifo_alloc(&state->rx_kfifo, CX23888_IR_RX_KFIFO_SIZE,\n\t\t\tGFP_KERNEL)) {\n\t\tkfree(state);\n\t\treturn -ENOMEM;\n\t}\n\n\tstate->dev = dev;\n\tsd = &state->sd;\n\n\tv4l2_subdev_init(sd, &cx23888_ir_controller_ops);\n\tv4l2_set_subdevdata(sd, state);\n\t/* FIXME - fix the formatting of dev->v4l2_dev.name and use it */\n\tsnprintf(sd->name, sizeof(sd->name), \"%s/888-ir\", dev->name);\n\tsd->grp_id = CX23885_HW_888_IR;\n\n\tret = v4l2_device_register_subdev(&dev->v4l2_dev, sd);\n\tif (ret == 0) {\n\t\t/*\n\t\t * Ensure no interrupts arrive from '888 specific conditions,\n\t\t * since we ignore them in this driver to have commonality with\n\t\t * similar IR controller cores.\n\t\t */\n\t\tcx23888_ir_write4(dev, CX23888_IR_IRQEN_REG, 0);\n\n\t\tmutex_init(&state->rx_params_lock);\n\t\tdefault_params = default_rx_params;\n\t\tv4l2_subdev_call(sd, ir, rx_s_parameters, &default_params);\n\n\t\tmutex_init(&state->tx_params_lock);\n\t\tdefault_params = default_tx_params;\n\t\tv4l2_subdev_call(sd, ir, tx_s_parameters, &default_params);\n\t} else {\n\t\tkfifo_free(&state->rx_kfifo);\n\t}\n\treturn ret;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <media/v4l2-device.h>\n#include \"cx23885.h\"\n#include <linux/kfifo.h>\n#include \"cx23888-ir.h\"\n#include <media/rc-core.h>\n#include <linux/slab.h>\n\n// Type Definitions:\n// cx23888_ir_state:\nstruct cx23888_ir_state {\n\tstruct v4l2_subdev sd;\n\tstruct cx23885_dev *dev;\n\n\tstruct v4l2_subdev_ir_parameters rx_params;\n\tstruct mutex rx_params_lock;\n\tatomic_t rxclk_divider;\n\tatomic_t rx_invert;\n\n\tstruct kfifo rx_kfifo;\n\tspinlock_t rx_kfifo_lock;\n\n\tstruct v4l2_subdev_ir_parameters tx_params;\n\tstruct mutex tx_params_lock;\n\tatomic_t txclk_divider;\n}\n\n// v4l2_subdev_ops:\nstatic const struct v4l2_subdev_ops\n\n// v4l2_subdev:\nextern struct v4l2_subdev\n\n// v4l2_subdev_ir_parameters:\nstatic const struct v4l2_subdev_ir_parameters\n\n// cx23885_dev:\nstruct cx23885_dev {\n\tatomic_t                   refcount;\n\tstruct v4l2_device\t   v4l2_dev;\n\tstruct v4l2_ctrl_handler   ctrl_handler;\n\n\t/* pci stuff */\n\tstruct pci_dev             *pci;\n\tunsigned char              pci_rev, pci_lat;\n\tint                        pci_bus, pci_slot;\n\tu32                        __iomem *lmmio;\n\tu8                         __iomem *bmmio;\n\tint                        pci_irqmask;\n\tspinlock_t\t\t   pci_irqmask_lock; /* protects mask reg too */\n\tint                        hwrevision;\n\n\t/* This valud is board specific and is used to configure the\n\t * AV core so we see nice clean and stable video and audio. */\n\tu32                        clk_freq;\n\n\t/* I2C adapters: Master 1 & 2 (External) & Master 3 (Internal only) */\n\tstruct cx23885_i2c         i2c_bus[3];\n\n\tint                        nr;\n\tstruct mutex               lock;\n\tstruct mutex               gpio_lock;\n\n\t/* board details */\n\tunsigned int               board;\n\tchar                       name[32];\n\n\tstruct...\n\n// Called Methods (top 10):\n// cx23888_ir_write4 from drivers/media/pci/cx23885/cx23888-ir.c:\nstatic /* <=== cx23888_ir_write4 */ \ninline int cx23888_ir_write4(struct cx23885_dev *dev, u32 addr, u32 value)\n{\n\tcx_write(addr, value);\n\treturn 0;\n}\n\n// CX23885_HW_888_IR from drivers/media/pci/cx23885/cx23885.h:\n#define CX23885_HW_888_IR  (1 << 0) /* <=== drivers/media/pci/cx23885/cx23885.h:455:455:CX23885_HW_888_IR:0 */ \n\n// CX23888_IR_IRQEN_REG from drivers/media/pci/cx23885/cx23888-ir.c:\n#define CX23888_IR_IRQEN_REG\t0x170014 /* <=== drivers/media/pci/cx23885/cx23888-ir.c:70:70:CX23888_IR_IRQEN_REG:0 */ \n\n// cx_write from drivers/media/pci/cx23885/cx23885.h:\n#define cx_write(reg, value)     writel((value), dev->lmmio + ((reg)>>2)) /* <=== drivers/media/pci/cx23885/cx23885.h:496:496:cx_write:2 */ \n\n// CX23888_IR_RX_KFIFO_SIZE from drivers/media/pci/cx23885/cx23888-ir.c:\n#define CX23888_IR_RX_KFIFO_SIZE    (256 * sizeof(union cx23888_ir_fifo_rec)) /* <=== drivers/media/pci/cx23885/cx23888-ir.c:113:113:CX23888_IR_RX_KFIFO_SIZE:0 */ \n"
  },
  {
    "repository": "php-src",
    "cve_id": "CVE-2016-6296",
    "cwe_list": [
      "CWE-119"
    ],
    "commit_hash": "e6c48213c22ed50b2b987b479fcc1ac709394caa",
    "short_hash": "e6c48213",
    "vulnerableMethods_before": [
      {
        "filename": "simplestring.c",
        "method_name": "vulnerable_function",
        "raw_code": "void simplestring_addn(simplestring* target, const char* source, int add_len) {\n   if(target && source) {\n      if(!target->str) {\n         simplestring_init_str(target);\n      }\n      if(target->len + add_len + 1 > target->size) {\n         /* newsize is current length + new length */\n         int newsize = target->len + add_len + 1;\n         int incr = target->size * 2;\n\n         /* align to SIMPLESTRING_INCR increments */\n         newsize = newsize - (newsize % incr) + incr;\n         target->str = (char*)realloc(target->str, newsize);\n\n         target->size = target->str ? newsize : 0;\n      }\n\n      if(target->str) {\n         if(add_len) {\n            memcpy(target->str + target->len, source, add_len);\n         }\n         target->len += add_len;\n         target->str[target->len] = 0; /* null terminate */\n      }\n   }\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "simplestring.c",
        "method_name": "fixed_function",
        "raw_code": "void simplestring_addn(simplestring* target, const char* source, size_t add_len) {\n   size_t newsize = target->size, incr = 0;\n   if(target && source) {\n      if(!target->str) {\n         simplestring_init_str(target);\n      }\n\n      if((SIZE_MAX - add_len) < target->len || (SIZE_MAX - add_len - 1) < target->len) {\n    \t  /* check for overflows, if there's a potential overflow do nothing */\n    \t  return;\n      }\n\n      if(target->len + add_len + 1 > target->size) {\n         /* newsize is current length + new length */\n         newsize = target->len + add_len + 1;\n         incr = target->size * 2;\n\n         /* align to SIMPLESTRING_INCR increments */\n         if (incr) {\n            newsize = newsize - (newsize % incr) + incr;\n         }\n         if(newsize < (target->len + add_len + 1)) {\n        \t /* some kind of overflow happened */\n        \t return;\n         }\n         target->str = (char*)realloc(target->str, newsize);\n\n         target->size = target->str ? newsize : 0;\n      }\n\n      if(target->str) {\n         if(add_len) {\n            memcpy(target->str + target->len, source, add_len);\n         }\n         target->len += add_len;\n         target->str[target->len] = 0; /* null terminate */\n      }\n   }\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <stdlib.h>\n#include \"simplestring.h\"\n#include <string.h>\n\n// Type Definitions:\n// simplestring:\ntypedef struct _simplestring {\n   char* str;         /* string buf               */\n   int len;           /* length of string/buf     */\n   int size;          /* size of allocated buffer */\n} simplestring;\n\n// Called Methods (top 10):\n// SIMPLESTRING_INCR from ext/xmlrpc/libxmlrpc/simplestring.c:\n#define SIMPLESTRING_INCR 32 /* <=== ext/xmlrpc/libxmlrpc/simplestring.c:37:37:SIMPLESTRING_INCR:0 */ \n\n// simplestring_init_str from ext/xmlrpc/libxmlrpc/simplestring.c:\nstatic void simplestring_init_str(simplestring* string) {\n   string->str = (char*)malloc(SIMPLESTRING_INCR);\n   if(string->str) {\n      string->str[0] = 0;\n      string->len = 0;\n      string->size = SIMPLESTRING_INCR;\n   }\n   else {\n      string->size = 0;\n   }\n}\n"
  },
  {
    "repository": "linux",
    "cve_id": "CVE-2020-16166",
    "cwe_list": [
      "CWE-200"
    ],
    "commit_hash": "f227e3ec3b5cad859ad15666874405e8c1bbc1d4",
    "short_hash": "f227e3ec",
    "vulnerableMethods_before": [
      {
        "filename": "timer.c",
        "method_name": "vulnerable_function",
        "raw_code": "void update_process_times(int user_tick)\n{\n\tstruct task_struct *p = current;\n\n\t/* Note: this timer irq context must be accounted for as well. */\n\taccount_process_tick(p, user_tick);\n\trun_local_timers();\n\trcu_sched_clock_irq(user_tick);\n#ifdef CONFIG_IRQ_WORK\n\tif (in_irq())\n\t\tirq_work_tick();\n#endif\n\tscheduler_tick();\n\tif (IS_ENABLED(CONFIG_POSIX_TIMERS))\n\t\trun_posix_cpu_timers();\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "timer.c",
        "method_name": "fixed_function",
        "raw_code": "void update_process_times(int user_tick)\n{\n\tstruct task_struct *p = current;\n\n\t/* Note: this timer irq context must be accounted for as well. */\n\taccount_process_tick(p, user_tick);\n\trun_local_timers();\n\trcu_sched_clock_irq(user_tick);\n#ifdef CONFIG_IRQ_WORK\n\tif (in_irq())\n\t\tirq_work_tick();\n#endif\n\tscheduler_tick();\n\tif (IS_ENABLED(CONFIG_POSIX_TIMERS))\n\t\trun_posix_cpu_timers();\n\n\t/* The current CPU might make use of net randoms without receiving IRQs\n\t * to renew them often enough. Let's update the net_rand_state from a\n\t * non-constant value that's not affine to the number of calls to make\n\t * sure it's updated when there's some activity (we don't care in idle).\n\t */\n\tthis_cpu_add(net_rand_state.s1, rol32(jiffies, 24) + user_tick);\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <asm/io.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/thread_info.h>\n#include <linux/pid_namespace.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <trace/events/timer.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/notifier.h>\n#include <linux/interrupt.h>\n#include <linux/compat.h>\n#include <asm/div64.h>\n#include <linux/cpu.h>\n#include <asm/unistd.h>\n#include <linux/jiffies.h>\n#include <linux/random.h>\n#include <linux/tick.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched/sysctl.h>\n#include <linux/mm.h>\n#include <asm/timex.h>\n#include \"tick-internal.h\"\n#include <linux/irq_work.h>\n#include <linux/percpu.h>\n#include <linux/kallsyms.h>\n#include <linux/delay.h>\n\n// Type Definitions:\n// task_struct:\nstruct task_struct\n"
  },
  {
    "repository": "u-boot",
    "cve_id": "CVE-2022-34835",
    "cwe_list": [
      "CWE-787"
    ],
    "commit_hash": "8f8c04bf1ebbd2f72f1643e7ad9617dafa6e5409",
    "short_hash": "8f8c04bf",
    "vulnerableMethods_before": [
      {
        "filename": "i2c.c",
        "method_name": "vulnerable_function",
        "raw_code": "static int do_i2c_md(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t     char *const argv[])\n{\n\tuint\tchip;\n\tuint\taddr, length;\n\tint alen;\n\tint\tj, nbytes, linebytes;\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\n\t/* We use the last specified parameters, unless new ones are\n\t * entered.\n\t */\n\tchip   = i2c_dp_last_chip;\n\taddr   = i2c_dp_last_addr;\n\talen   = i2c_dp_last_alen;\n\tlength = i2c_dp_last_length;\n\n\tif (argc < 3)\n\t\treturn CMD_RET_USAGE;\n\n\tif ((flag & CMD_FLAG_REPEAT) == 0) {\n\t\t/*\n\t\t * New command specified.\n\t\t */\n\n\t\t/*\n\t\t * I2C chip address\n\t\t */\n\t\tchip = hextoul(argv[1], NULL);\n\n\t\t/*\n\t\t * I2C data address within the chip.  This can be 1 or\n\t\t * 2 bytes long.  Some day it might be 3 bytes long :-).\n\t\t */\n\t\taddr = hextoul(argv[2], NULL);\n\t\talen = get_alen(argv[2], DEFAULT_ADDR_LEN);\n\t\tif (alen > 3)\n\t\t\treturn CMD_RET_USAGE;\n\n\t\t/*\n\t\t * If another parameter, it is the length to display.\n\t\t * Length is the number of objects, not number of bytes.\n\t\t */\n\t\tif (argc > 3)\n\t\t\tlength = hextoul(argv[3], NULL);\n\t}\n\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n#endif\n\n\t/*\n\t * Print the lines.\n\t *\n\t * We buffer all read data, so we can make sure data is read only\n\t * once.\n\t */\n\tnbytes = length;\n\tdo {\n\t\tunsigned char\tlinebuf[DISP_LINE_LEN];\n\t\tunsigned char\t*cp;\n\n\t\tlinebytes = (nbytes > DISP_LINE_LEN) ? DISP_LINE_LEN : nbytes;\n\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tret = dm_i2c_read(dev, addr, linebuf, linebytes);\n#else\n\t\tret = i2c_read(chip, addr, alen, linebuf, linebytes);\n#endif\n\t\tif (ret)\n\t\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n\t\telse {\n\t\t\tprintf(\"%04x:\", addr);\n\t\t\tcp = linebuf;\n\t\t\tfor (j=0; j<linebytes; j++) {\n\t\t\t\tprintf(\" %02x\", *cp++);\n\t\t\t\taddr++;\n\t\t\t}\n\t\t\tputs (\"    \");\n\t\t\tcp = linebuf;\n\t\t\tfor (j=0; j<linebytes; j++) {\n\t\t\t\tif ((*cp < 0x20) || (*cp > 0x7e))\n\t\t\t\t\tputs (\".\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%c\", *cp);\n\t\t\t\tcp++;\n\t\t\t}\n\t\t\tputc ('\\n');\n\t\t}\n\t\tnbytes -= linebytes;\n\t} while (nbytes > 0);\n\n\ti2c_dp_last_chip   = chip;\n\ti2c_dp_last_addr   = addr;\n\ti2c_dp_last_alen   = alen;\n\ti2c_dp_last_length = length;\n\n\treturn 0;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "i2c.c",
        "method_name": "fixed_function",
        "raw_code": "static int do_i2c_md(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t     char *const argv[])\n{\n\tuint\tchip;\n\tuint\taddr, length;\n\tuint\talen;\n\tuint\tj, nbytes, linebytes;\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\n\t/* We use the last specified parameters, unless new ones are\n\t * entered.\n\t */\n\tchip   = i2c_dp_last_chip;\n\taddr   = i2c_dp_last_addr;\n\talen   = i2c_dp_last_alen;\n\tlength = i2c_dp_last_length;\n\n\tif (argc < 3)\n\t\treturn CMD_RET_USAGE;\n\n\tif ((flag & CMD_FLAG_REPEAT) == 0) {\n\t\t/*\n\t\t * New command specified.\n\t\t */\n\n\t\t/*\n\t\t * I2C chip address\n\t\t */\n\t\tchip = hextoul(argv[1], NULL);\n\n\t\t/*\n\t\t * I2C data address within the chip.  This can be 1 or\n\t\t * 2 bytes long.  Some day it might be 3 bytes long :-).\n\t\t */\n\t\taddr = hextoul(argv[2], NULL);\n\t\talen = get_alen(argv[2], DEFAULT_ADDR_LEN);\n\t\tif (alen > 3)\n\t\t\treturn CMD_RET_USAGE;\n\n\t\t/*\n\t\t * If another parameter, it is the length to display.\n\t\t * Length is the number of objects, not number of bytes.\n\t\t */\n\t\tif (argc > 3)\n\t\t\tlength = hextoul(argv[3], NULL);\n\t}\n\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n#endif\n\n\t/*\n\t * Print the lines.\n\t *\n\t * We buffer all read data, so we can make sure data is read only\n\t * once.\n\t */\n\tnbytes = length;\n\tdo {\n\t\tunsigned char\tlinebuf[DISP_LINE_LEN];\n\t\tunsigned char\t*cp;\n\n\t\tlinebytes = (nbytes > DISP_LINE_LEN) ? DISP_LINE_LEN : nbytes;\n\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tret = dm_i2c_read(dev, addr, linebuf, linebytes);\n#else\n\t\tret = i2c_read(chip, addr, alen, linebuf, linebytes);\n#endif\n\t\tif (ret)\n\t\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n\t\telse {\n\t\t\tprintf(\"%04x:\", addr);\n\t\t\tcp = linebuf;\n\t\t\tfor (j=0; j<linebytes; j++) {\n\t\t\t\tprintf(\" %02x\", *cp++);\n\t\t\t\taddr++;\n\t\t\t}\n\t\t\tputs (\"    \");\n\t\t\tcp = linebuf;\n\t\t\tfor (j=0; j<linebytes; j++) {\n\t\t\t\tif ((*cp < 0x20) || (*cp > 0x7e))\n\t\t\t\t\tputs (\".\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%c\", *cp);\n\t\t\t\tcp++;\n\t\t\t}\n\t\t\tputc ('\\n');\n\t\t}\n\t\tnbytes -= linebytes;\n\t} while (nbytes > 0);\n\n\ti2c_dp_last_chip   = chip;\n\ti2c_dp_last_addr   = addr;\n\ti2c_dp_last_alen   = alen;\n\ti2c_dp_last_length = length;\n\n\treturn 0;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <dm.h>\n#include <malloc.h>\n#include <asm/byteorder.h>\n#include <linux/compiler.h>\n#include <linux/delay.h>\n#include <edid.h>\n#include <console.h>\n#include <errno.h>\n#include <log.h>\n#include <bootretry.h>\n#include <cli.h>\n#include <common.h>\n#include <u-boot/crc.h>\n#include <i2c.h>\n#include <command.h>\n\n// Type Definitions:\n// uint:\ntypedef unsigned int uint;\n\n// uint:\ntypedef unsigned int\t\tuint;\n"
  },
  {
    "repository": "linux",
    "cve_id": "CVE-2022-0617",
    "cwe_list": [
      "CWE-476"
    ],
    "commit_hash": "ea8569194b43f0f01f0a84c689388542c7254a1f",
    "short_hash": "ea856919",
    "vulnerableMethods_before": [
      {
        "filename": "inode.c",
        "method_name": "vulnerable_function",
        "raw_code": "int udf_expand_file_adinicb(struct inode *inode)\n{\n\tstruct page *page;\n\tchar *kaddr;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tint err;\n\n\tWARN_ON_ONCE(!inode_is_locked(inode));\n\tif (!iinfo->i_lenAlloc) {\n\t\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT;\n\t\telse\n\t\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG;\n\t\t/* from now on we have normal address_space methods */\n\t\tinode->i_data.a_ops = &udf_aops;\n\t\tup_write(&iinfo->i_data_sem);\n\t\tmark_inode_dirty(inode);\n\t\treturn 0;\n\t}\n\t/*\n\t * Release i_data_sem so that we can lock a page - page lock ranks\n\t * above i_data_sem. i_mutex still protects us against file changes.\n\t */\n\tup_write(&iinfo->i_data_sem);\n\n\tpage = find_or_create_page(inode->i_mapping, 0, GFP_NOFS);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tif (!PageUptodate(page)) {\n\t\tkaddr = kmap_atomic(page);\n\t\tmemset(kaddr + iinfo->i_lenAlloc, 0x00,\n\t\t       PAGE_SIZE - iinfo->i_lenAlloc);\n\t\tmemcpy(kaddr, iinfo->i_data + iinfo->i_lenEAttr,\n\t\t\tiinfo->i_lenAlloc);\n\t\tflush_dcache_page(page);\n\t\tSetPageUptodate(page);\n\t\tkunmap_atomic(kaddr);\n\t}\n\tdown_write(&iinfo->i_data_sem);\n\tmemset(iinfo->i_data + iinfo->i_lenEAttr, 0x00,\n\t       iinfo->i_lenAlloc);\n\tiinfo->i_lenAlloc = 0;\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT;\n\telse\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG;\n\t/* from now on we have normal address_space methods */\n\tinode->i_data.a_ops = &udf_aops;\n\tset_page_dirty(page);\n\tunlock_page(page);\n\tup_write(&iinfo->i_data_sem);\n\terr = filemap_fdatawrite(inode->i_mapping);\n\tif (err) {\n\t\t/* Restore everything back so that we don't lose data... */\n\t\tlock_page(page);\n\t\tdown_write(&iinfo->i_data_sem);\n\t\tkaddr = kmap_atomic(page);\n\t\tmemcpy(iinfo->i_data + iinfo->i_lenEAttr, kaddr, inode->i_size);\n\t\tkunmap_atomic(kaddr);\n\t\tunlock_page(page);\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_IN_ICB;\n\t\tinode->i_data.a_ops = &udf_adinicb_aops;\n\t\tup_write(&iinfo->i_data_sem);\n\t}\n\tput_page(page);\n\tmark_inode_dirty(inode);\n\n\treturn err;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "inode.c",
        "method_name": "fixed_function",
        "raw_code": "int udf_expand_file_adinicb(struct inode *inode)\n{\n\tstruct page *page;\n\tchar *kaddr;\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\tint err;\n\n\tWARN_ON_ONCE(!inode_is_locked(inode));\n\tif (!iinfo->i_lenAlloc) {\n\t\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT;\n\t\telse\n\t\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG;\n\t\t/* from now on we have normal address_space methods */\n\t\tinode->i_data.a_ops = &udf_aops;\n\t\tup_write(&iinfo->i_data_sem);\n\t\tmark_inode_dirty(inode);\n\t\treturn 0;\n\t}\n\t/*\n\t * Release i_data_sem so that we can lock a page - page lock ranks\n\t * above i_data_sem. i_mutex still protects us against file changes.\n\t */\n\tup_write(&iinfo->i_data_sem);\n\n\tpage = find_or_create_page(inode->i_mapping, 0, GFP_NOFS);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tif (!PageUptodate(page)) {\n\t\tkaddr = kmap_atomic(page);\n\t\tmemset(kaddr + iinfo->i_lenAlloc, 0x00,\n\t\t       PAGE_SIZE - iinfo->i_lenAlloc);\n\t\tmemcpy(kaddr, iinfo->i_data + iinfo->i_lenEAttr,\n\t\t\tiinfo->i_lenAlloc);\n\t\tflush_dcache_page(page);\n\t\tSetPageUptodate(page);\n\t\tkunmap_atomic(kaddr);\n\t}\n\tdown_write(&iinfo->i_data_sem);\n\tmemset(iinfo->i_data + iinfo->i_lenEAttr, 0x00,\n\t       iinfo->i_lenAlloc);\n\tiinfo->i_lenAlloc = 0;\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_USE_SHORT_AD))\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_SHORT;\n\telse\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_LONG;\n\t/* from now on we have normal address_space methods */\n\tinode->i_data.a_ops = &udf_aops;\n\tset_page_dirty(page);\n\tunlock_page(page);\n\tup_write(&iinfo->i_data_sem);\n\terr = filemap_fdatawrite(inode->i_mapping);\n\tif (err) {\n\t\t/* Restore everything back so that we don't lose data... */\n\t\tlock_page(page);\n\t\tdown_write(&iinfo->i_data_sem);\n\t\tkaddr = kmap_atomic(page);\n\t\tmemcpy(iinfo->i_data + iinfo->i_lenEAttr, kaddr, inode->i_size);\n\t\tkunmap_atomic(kaddr);\n\t\tunlock_page(page);\n\t\tiinfo->i_alloc_type = ICBTAG_FLAG_AD_IN_ICB;\n\t\tinode->i_data.a_ops = &udf_adinicb_aops;\n\t\tiinfo->i_lenAlloc = inode->i_size;\n\t\tup_write(&iinfo->i_data_sem);\n\t}\n\tput_page(page);\n\tmark_inode_dirty(inode);\n\n\treturn err;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"udf_i.h\"\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include \"udfdecl.h\"\n#include <linux/mpage.h>\n#include <linux/module.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/uio.h>\n#include <linux/crc-itu-t.h>\n#include \"udf_sb.h\"\n#include <linux/mm.h>\n\n// Type Definitions:\n// udf_inode_info:\nstruct udf_inode_info {\n\tstruct timespec64\ti_crtime;\n\t/* Physical address of inode */\n\tstruct kernel_lb_addr\t\ti_location;\n\t__u64\t\t\ti_unique;\n\t__u32\t\t\ti_lenEAttr;\n\t__u32\t\t\ti_lenAlloc;\n\t__u64\t\t\ti_lenExtents;\n\t__u32\t\t\ti_next_alloc_block;\n\t__u32\t\t\ti_next_alloc_goal;\n\t__u32\t\t\ti_checkpoint;\n\t__u32\t\t\ti_extraPerms;\n\tunsigned\t\ti_alloc_type : 3;\n\tunsigned\t\ti_efe : 1;\t/* extendedFileEntry */\n\tunsigned\t\ti_use : 1;\t/* unallocSpaceEntry */\n\tunsigned\t\ti_strat4096 : 1;\n\tunsigned\t\ti_streamdir : 1;\n\tunsigned\t\treserved : 25;\n\t__u8\t\t\t*i_data;\n\tstruct kernel_lb_addr\ti_locStreamdir;\n\t__u64\t\t\ti_lenStreams;\n\tstruct rw_semaphore\ti_data_sem;\n\tstruct udf_ext_cache cached_extent;\n\t/* Spinlock for protecting extent cache */\n\tspinlock_t i_extent_cache_lock;\n\tstruct inode vfs_inode;\n}\n\n// page:\nstruct page\n\n// inode:\nstatic struct inode\n\n// Called Methods (top 10):\n// UDF_QUERY_FLAG from fs/udf/udf_sb.h:\nstatic inline int UDF_QUERY_FLAG(struct super_block *sb, int flag) /* <=== UDF_QUERY_FLAG */ \n{\n\treturn test_bit(flag, &UDF_SB(sb)->s_flags);\n}\n\n// ICBTAG_FLAG_AD_IN_ICB from fs/udf/ecma_167.h:\n#define ICBTAG_FLAG_AD_IN_ICB\t\t0x0003 /* <=== fs/udf/ecma_167.h:533:533:ICBTAG_FLAG_AD_IN_ICB:0 */ \n\n// UDF_FLAG_USE_SHORT_AD from fs/udf/udf_sb.h:\n#define UDF_FLAG_USE_SHORT_AD\t\t2 /* <=== fs/udf/udf_sb.h:16:16:UDF_FLAG_USE_SHORT_AD:0 */ \n\n// ICBTAG_FLAG_AD_SHORT from fs/udf/ecma_167.h:\n#define ICBTAG_FLAG_AD_SHORT\t\t0x0000 /* <=== fs/udf/ecma_167.h:530:530:ICBTAG_FLAG_AD_SHORT:0 */ \n\n// UDF_I from fs/udf/udf_i.h:\nstatic inline struct udf_inode_info *UDF_I(struct inode *inode) /* <=== UDF_I */ \n{\n\treturn container_of(inode, struct udf_inode_info, vfs_inode);\n}\n\n// ICBTAG_FLAG_AD_LONG from fs/udf/ecma_167.h:\n#define ICBTAG_FLAG_AD_LONG\t\t0x0001 /* <=== fs/udf/ecma_167.h:531:531:ICBTAG_FLAG_AD_LONG:0 */ \n\n// UDF_SB from fs/udf/udf_sb.h:\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb) /* <=== UDF_SB */ \n{\n\treturn sb->s_fs_info;\n}\n"
  },
  {
    "repository": "linux",
    "cve_id": "CVE-2022-26878",
    "cwe_list": [
      "CWE-772"
    ],
    "commit_hash": "1d0688421449718c6c5f46e458a378c9b530ba18",
    "short_hash": "1d068842",
    "vulnerableMethods_before": [
      {
        "filename": "virtio_bt.c",
        "method_name": "vulnerable_function",
        "raw_code": "static void virtbt_rx_handle(struct virtio_bluetooth *vbt, struct sk_buff *skb)\n{\n\t__u8 pkt_type;\n\n\tpkt_type = *((__u8 *) skb->data);\n\tskb_pull(skb, 1);\n\n\tswitch (pkt_type) {\n\tcase HCI_EVENT_PKT:\n\tcase HCI_ACLDATA_PKT:\n\tcase HCI_SCODATA_PKT:\n\tcase HCI_ISODATA_PKT:\n\t\thci_skb_pkt_type(skb) = pkt_type;\n\t\thci_recv_frame(vbt->hdev, skb);\n\t\tbreak;\n\t}\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "virtio_bt.c",
        "method_name": "fixed_function",
        "raw_code": "static void virtbt_rx_handle(struct virtio_bluetooth *vbt, struct sk_buff *skb)\n{\n\t__u8 pkt_type;\n\n\tpkt_type = *((__u8 *) skb->data);\n\tskb_pull(skb, 1);\n\n\tswitch (pkt_type) {\n\tcase HCI_EVENT_PKT:\n\tcase HCI_ACLDATA_PKT:\n\tcase HCI_SCODATA_PKT:\n\tcase HCI_ISODATA_PKT:\n\t\thci_skb_pkt_type(skb) = pkt_type;\n\t\thci_recv_frame(vbt->hdev, skb);\n\t\tbreak;\n\tdefault:\n\t\tkfree_skb(skb);\n\t\tbreak;\n\t}\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <linux/virtio.h>\n#include <linux/virtio_config.h>\n#include <uapi/linux/virtio_bt.h>\n#include <net/bluetooth/bluetooth.h>\n#include <linux/module.h>\n#include <net/bluetooth/hci_core.h>\n#include <linux/skbuff.h>\n#include <uapi/linux/virtio_ids.h>\n\n// Type Definitions:\n// sk_buff:\nstruct sk_buff\n"
  },
  {
    "repository": "libmobi",
    "cve_id": "CVE-2022-1987",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "612562bc1ea38f1708b044e7a079c47a05b1291d",
    "short_hash": "612562bc",
    "vulnerableMethods_before": [
      {
        "filename": "index.c",
        "method_name": "vulnerable_function",
        "raw_code": "static MOBI_RET mobi_parse_index_entry(MOBIIndx *indx, const MOBIIdxt idxt, const MOBITagx *tagx, const MOBIOrdt *ordt, MOBIBuffer *buf, const size_t curr_number) {\n    if (indx == NULL) {\n        debug_print(\"%s\", \"INDX structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    const size_t entry_offset = indx->entries_count;\n    const size_t entry_length = idxt.offsets[curr_number + 1] - idxt.offsets[curr_number];\n    mobi_buffer_setpos(buf, idxt.offsets[curr_number]);\n    size_t entry_number = curr_number + entry_offset;\n    if (entry_number >= indx->total_entries_count) {\n        debug_print(\"Entry number beyond array: %zu\\n\", entry_number);\n        return MOBI_DATA_CORRUPT;\n    }\n    /* save original record maxlen */\n    const size_t buf_maxlen = buf->maxlen;\n    if (buf->offset + entry_length >= buf_maxlen) {\n        debug_print(\"Entry length too long: %zu\\n\", entry_length);\n        return MOBI_DATA_CORRUPT;\n    }\n    buf->maxlen = buf->offset + entry_length;\n    size_t label_length = mobi_buffer_get8(buf);\n    if (label_length > entry_length) {\n        debug_print(\"Label length too long: %zu\\n\", label_length);\n        return MOBI_DATA_CORRUPT;\n    }\n    char text[INDX_LABEL_SIZEMAX];\n    /* FIXME: what is ORDT1 for? */\n    if (ordt->ordt2) {\n        label_length = mobi_getstring_ordt(ordt, buf, (unsigned char*) text, label_length);\n    } else {\n        label_length = mobi_indx_get_label((unsigned char*) text, buf, label_length, indx->ligt_entries_count);\n    }\n    indx->entries[entry_number].label = malloc(label_length + 1);\n    if (indx->entries[entry_number].label == NULL) {\n        debug_print(\"Memory allocation failed (%zu bytes)\\n\", label_length);\n        return MOBI_MALLOC_FAILED;\n    }\n    strncpy(indx->entries[entry_number].label, text, label_length + 1);\n    //debug_print(\"tag label[%zu]: %s\\n\", entry_number, indx->entries[entry_number].label);\n    unsigned char *control_bytes;\n    control_bytes = buf->data + buf->offset;\n    mobi_buffer_seek(buf, (int) tagx->control_byte_count);\n    indx->entries[entry_number].tags_count = 0;\n    indx->entries[entry_number].tags = NULL;\n    if (tagx->tags_count > 0) {\n        typedef struct {\n            uint8_t tag;\n            uint8_t tag_value_count;\n            uint32_t value_count;\n            uint32_t value_bytes;\n        } MOBIPtagx;\n        MOBIPtagx *ptagx = malloc(tagx->tags_count * sizeof(MOBIPtagx));\n        if (ptagx == NULL) {\n            debug_print(\"Memory allocation failed (%zu bytes)\\n\", tagx->tags_count * sizeof(MOBIPtagx));\n            return MOBI_MALLOC_FAILED;\n        }\n        uint32_t ptagx_count = 0;\n        size_t len;\n        size_t i = 0;\n        while (i < tagx->tags_count) {\n            if (tagx->tags[i].control_byte == 1) {\n                control_bytes++;\n                i++;\n                continue;\n            }\n            uint32_t value = control_bytes[0] & tagx->tags[i].bitmask;\n            if (value != 0) {\n                /* FIXME: is it safe to use MOBI_NOTSET? */\n                uint32_t value_count = MOBI_NOTSET;\n                uint32_t value_bytes = MOBI_NOTSET;\n                /* all bits of masked value are set */\n                if (value == tagx->tags[i].bitmask) {\n                    /* more than 1 bit set */\n                    if (mobi_bitcount(tagx->tags[i].bitmask) > 1) {\n                        /* read value bytes from entry */\n                        len = 0;\n                        value_bytes = mobi_buffer_get_varlen(buf, &len);\n                    } else {\n                        value_count = 1;\n                    }\n                } else {\n                    uint8_t mask = tagx->tags[i].bitmask;\n                    while ((mask & 1) == 0) {\n                        mask >>= 1;\n                        value >>= 1;\n                    }\n                    value_count = value;\n                }\n                ptagx[ptagx_count].tag = tagx->tags[i].tag;\n                ptagx[ptagx_count].tag_value_count = tagx->tags[i].values_count;\n                ptagx[ptagx_count].value_count = value_count;\n                ptagx[ptagx_count].value_bytes = value_bytes;\n                ptagx_count++;\n            }\n            i++;\n        }\n        indx->entries[entry_number].tags = malloc(tagx->tags_count * sizeof(MOBIIndexTag));\n        if (indx->entries[entry_number].tags == NULL) {\n            debug_print(\"Memory allocation failed (%zu bytes)\\n\", tagx->tags_count * sizeof(MOBIIndexTag));\n            free(ptagx);\n            return MOBI_MALLOC_FAILED;\n        }\n        i = 0;\n        while (i < ptagx_count) {\n            uint32_t tagvalues_count = 0;\n            /* FIXME: is it safe to use MOBI_NOTSET? */\n            /* value count is set */\n            uint32_t tagvalues[INDX_TAGVALUES_MAX];\n            if (ptagx[i].value_count != MOBI_NOTSET) {\n                size_t count = ptagx[i].value_count * ptagx[i].tag_value_count;\n                while (count-- && tagvalues_count < INDX_TAGVALUES_MAX) {\n                    len = 0;\n                    const uint32_t value_bytes = mobi_buffer_get_varlen(buf, &len);\n                    tagvalues[tagvalues_count++] = value_bytes;\n                }\n            /* value count is not set */\n            } else {\n                /* read value_bytes bytes */\n                len = 0;\n                while (len < ptagx[i].value_bytes && tagvalues_count < INDX_TAGVALUES_MAX) {\n                    const uint32_t value_bytes = mobi_buffer_get_varlen(buf, &len);\n                    tagvalues[tagvalues_count++] = value_bytes;\n                }\n            }\n            if (tagvalues_count) {\n                const size_t arr_size = tagvalues_count * sizeof(*indx->entries[entry_number].tags[i].tagvalues);\n                indx->entries[entry_number].tags[i].tagvalues = malloc(arr_size);\n                if (indx->entries[entry_number].tags[i].tagvalues == NULL) {\n                    debug_print(\"Memory allocation failed (%zu bytes)\\n\", arr_size);\n                    free(ptagx);\n                    return MOBI_MALLOC_FAILED;\n                }\n                memcpy(indx->entries[entry_number].tags[i].tagvalues, tagvalues, arr_size);\n            } else {\n                indx->entries[entry_number].tags[i].tagvalues = NULL;\n            }\n            indx->entries[entry_number].tags[i].tagid = ptagx[i].tag;\n            indx->entries[entry_number].tags[i].tagvalues_count = tagvalues_count;\n            indx->entries[entry_number].tags_count++;\n            i++;\n        }\n        free(ptagx);\n    }\n    /* restore buffer maxlen */\n    buf->maxlen = buf_maxlen;\n    return MOBI_SUCCESS;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "index.c",
        "method_name": "fixed_function",
        "raw_code": "static MOBI_RET mobi_parse_index_entry(MOBIIndx *indx, const MOBIIdxt idxt, const MOBITagx *tagx, const MOBIOrdt *ordt, MOBIBuffer *buf, const size_t curr_number) {\n    if (indx == NULL) {\n        debug_print(\"%s\", \"INDX structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    const size_t entry_offset = indx->entries_count;\n    const size_t entry_length = idxt.offsets[curr_number + 1] - idxt.offsets[curr_number];\n    mobi_buffer_setpos(buf, idxt.offsets[curr_number]);\n    size_t entry_number = curr_number + entry_offset;\n    if (entry_number >= indx->total_entries_count) {\n        debug_print(\"Entry number beyond array: %zu\\n\", entry_number);\n        return MOBI_DATA_CORRUPT;\n    }\n    /* save original record maxlen */\n    const size_t buf_maxlen = buf->maxlen;\n    if (buf->offset + entry_length >= buf_maxlen) {\n        debug_print(\"Entry length too long: %zu\\n\", entry_length);\n        return MOBI_DATA_CORRUPT;\n    }\n    buf->maxlen = buf->offset + entry_length;\n    size_t label_length = mobi_buffer_get8(buf);\n    if (label_length > entry_length) {\n        debug_print(\"Label length too long: %zu\\n\", label_length);\n        return MOBI_DATA_CORRUPT;\n    }\n    char text[INDX_LABEL_SIZEMAX + 1];\n    /* FIXME: what is ORDT1 for? */\n    if (ordt->ordt2) {\n        label_length = mobi_getstring_ordt(ordt, buf, (unsigned char*) text, label_length);\n    } else {\n        label_length = mobi_indx_get_label((unsigned char*) text, buf, label_length, indx->ligt_entries_count);\n        if (buf->error != MOBI_SUCCESS) {\n            debug_print(\"Buffer error reading label: %d\\n\", buf->error);\n            return MOBI_DATA_CORRUPT;\n        }\n    }\n    indx->entries[entry_number].label = malloc(label_length + 1);\n    if (indx->entries[entry_number].label == NULL) {\n        debug_print(\"Memory allocation failed (%zu bytes)\\n\", label_length);\n        return MOBI_MALLOC_FAILED;\n    }\n    strncpy(indx->entries[entry_number].label, text, label_length + 1);\n    //debug_print(\"tag label[%zu]: %s\\n\", entry_number, indx->entries[entry_number].label);\n    unsigned char *control_bytes;\n    control_bytes = buf->data + buf->offset;\n    mobi_buffer_seek(buf, (int) tagx->control_byte_count);\n    indx->entries[entry_number].tags_count = 0;\n    indx->entries[entry_number].tags = NULL;\n    if (tagx->tags_count > 0) {\n        typedef struct {\n            uint8_t tag;\n            uint8_t tag_value_count;\n            uint32_t value_count;\n            uint32_t value_bytes;\n        } MOBIPtagx;\n        MOBIPtagx *ptagx = malloc(tagx->tags_count * sizeof(MOBIPtagx));\n        if (ptagx == NULL) {\n            debug_print(\"Memory allocation failed (%zu bytes)\\n\", tagx->tags_count * sizeof(MOBIPtagx));\n            return MOBI_MALLOC_FAILED;\n        }\n        uint32_t ptagx_count = 0;\n        size_t len;\n        size_t i = 0;\n        while (i < tagx->tags_count) {\n            if (tagx->tags[i].control_byte == 1) {\n                control_bytes++;\n                i++;\n                continue;\n            }\n            uint32_t value = control_bytes[0] & tagx->tags[i].bitmask;\n            if (value != 0) {\n                /* FIXME: is it safe to use MOBI_NOTSET? */\n                uint32_t value_count = MOBI_NOTSET;\n                uint32_t value_bytes = MOBI_NOTSET;\n                /* all bits of masked value are set */\n                if (value == tagx->tags[i].bitmask) {\n                    /* more than 1 bit set */\n                    if (mobi_bitcount(tagx->tags[i].bitmask) > 1) {\n                        /* read value bytes from entry */\n                        len = 0;\n                        value_bytes = mobi_buffer_get_varlen(buf, &len);\n                    } else {\n                        value_count = 1;\n                    }\n                } else {\n                    uint8_t mask = tagx->tags[i].bitmask;\n                    while ((mask & 1) == 0) {\n                        mask >>= 1;\n                        value >>= 1;\n                    }\n                    value_count = value;\n                }\n                ptagx[ptagx_count].tag = tagx->tags[i].tag;\n                ptagx[ptagx_count].tag_value_count = tagx->tags[i].values_count;\n                ptagx[ptagx_count].value_count = value_count;\n                ptagx[ptagx_count].value_bytes = value_bytes;\n                ptagx_count++;\n            }\n            i++;\n        }\n        indx->entries[entry_number].tags = malloc(tagx->tags_count * sizeof(MOBIIndexTag));\n        if (indx->entries[entry_number].tags == NULL) {\n            debug_print(\"Memory allocation failed (%zu bytes)\\n\", tagx->tags_count * sizeof(MOBIIndexTag));\n            free(ptagx);\n            return MOBI_MALLOC_FAILED;\n        }\n        i = 0;\n        while (i < ptagx_count) {\n            uint32_t tagvalues_count = 0;\n            /* FIXME: is it safe to use MOBI_NOTSET? */\n            /* value count is set */\n            uint32_t tagvalues[INDX_TAGVALUES_MAX];\n            if (ptagx[i].value_count != MOBI_NOTSET) {\n                size_t count = ptagx[i].value_count * ptagx[i].tag_value_count;\n                while (count-- && tagvalues_count < INDX_TAGVALUES_MAX) {\n                    len = 0;\n                    const uint32_t value_bytes = mobi_buffer_get_varlen(buf, &len);\n                    tagvalues[tagvalues_count++] = value_bytes;\n                }\n            /* value count is not set */\n            } else {\n                /* read value_bytes bytes */\n                len = 0;\n                while (len < ptagx[i].value_bytes && tagvalues_count < INDX_TAGVALUES_MAX) {\n                    const uint32_t value_bytes = mobi_buffer_get_varlen(buf, &len);\n                    tagvalues[tagvalues_count++] = value_bytes;\n                }\n            }\n            if (tagvalues_count) {\n                const size_t arr_size = tagvalues_count * sizeof(*indx->entries[entry_number].tags[i].tagvalues);\n                indx->entries[entry_number].tags[i].tagvalues = malloc(arr_size);\n                if (indx->entries[entry_number].tags[i].tagvalues == NULL) {\n                    debug_print(\"Memory allocation failed (%zu bytes)\\n\", arr_size);\n                    free(ptagx);\n                    return MOBI_MALLOC_FAILED;\n                }\n                memcpy(indx->entries[entry_number].tags[i].tagvalues, tagvalues, arr_size);\n            } else {\n                indx->entries[entry_number].tags[i].tagvalues = NULL;\n            }\n            indx->entries[entry_number].tags[i].tagid = ptagx[i].tag;\n            indx->entries[entry_number].tags[i].tagvalues_count = tagvalues_count;\n            indx->entries[entry_number].tags_count++;\n            i++;\n        }\n        free(ptagx);\n    }\n    /* restore buffer maxlen */\n    buf->maxlen = buf_maxlen;\n    return MOBI_SUCCESS;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"index.h\"\n#include \"memory.h\"\n#include \"util.h\"\n#include \"buffer.h\"\n#include \"debug.h\"\n#include <stdlib.h>\n#include <stdint.h>\n#include <string.h>\n\n// Type Definitions:\n// MOBIBuffer:\ntypedef struct {\n    size_t offset; /**< Current offset in respect to buffer start */\n    size_t maxlen; /**< Length of the buffer data */\n    unsigned char *data; /**< Pointer to buffer data */\n    MOBI_RET error; /**< MOBI_SUCCESS = 0 if operation on buffer is successful, non-zero value on failure */\n}\n\n// MOBIIndexTag:\ntypedef struct {\n        size_t tagid; /**< Tag id */\n        size_t tagvalues_count; /**< Number of tag values */\n        uint32_t *tagvalues; /**< Array of tag values */\n    }\n\n// MOBIIdxt:\ntypedef struct {\n    uint32_t *offsets; /**< Offsets to index entries */\n    size_t offsets_count; /**< Offsets count */\n}\n\n// MOBIOrdt:\ntypedef struct {\n    uint8_t *ordt1; /**< ORDT1 offsets */\n    uint16_t *ordt2; /**< ORDT2 offsets */\n    size_t type; /**< Type (0: 16, 1: 8 bit offsets) */\n    size_t ordt1_pos; /**< Offset of ORDT1 data */\n    size_t ordt2_pos; /**< Offset of ORDT2 data */\n    size_t offsets_count; /**< Offsets count */\n}\n\n// MOBIIndx:\ntypedef struct {\n        size_t type; /**< Index type: 0 - normal, 2 - inflection */\n        size_t entries_count; /**< Index entries count */\n        MOBIEncoding encoding; /**< Index encoding */\n        size_t total_entries_count; /**< Total index entries count */\n        size_t ordt_offset; /**< ORDT offset */\n        size_t ligt_offset; /**< LIGT offset */\n        size_t ligt_entries_count; /**< LIGT index entries count */\n        size_t cncx_records_count; /**< Number of compiled NCX records */\n        MOBIPdbRecord *cncx_record; /**< Link to CNCX record */\n        MOBIIndexEntry *entries; /**< Index entries array */\n        char *orth_index_name; /**< Orth index name */\n    }\n\n// MOBITagx:\ntypedef struct {\n    TAGXTags *tags; /**< Array of tag entries */\n    size_t tags_count; /**< Number of tag entries */\n    size_t control_byte_count; /**< Number of control bytes */\n}\n\n// Called Methods (top 10):\n// mobi_ligature_to_cp1252 from src/util.c:\nuint8_t mobi_ligature_to_cp1252(const uint8_t byte1, const uint8_t byte2) { /* <=== mobi_ligature_to_cp1252 */ \n    uint8_t ligature = 0;\n    const uint8_t lig_OE = 0x8c;\n    const uint8_t lig_oe = 0x9c;\n    const uint8_t lig_AE = 0xc6;\n    const uint8_t lig_ae = 0xe6;\n    const uint8_t lig_ss = 0xdf;\n    switch (byte1) {\n        case 1:\n            if (byte2 == 0x45) { ligature = lig_OE; }\n            break;\n        case 2:\n            if (byte2 == 0x65) { ligature = lig_oe; }\n            break;\n        case 3:\n            if (byte2 == 0x45) { ligature = lig_AE; }\n            break;\n        case 4:\n            if (byte2 == 0x65) { ligature = lig_ae; }\n            break;\n        case 5:\n            if (byte2 == 0x73) { ligature = lig_ss; }\n            break;\n    }\n    return ligature;\n}\n\n// mobi_ordt_lookup from src/index.c:\nuint16_t mobi_ordt_lookup(const MOBIOrdt *ordt, const uint16_t offset) { /* <=== mobi_ordt_lookup */ \n    uint16_t utf16;\n    if (offset < ordt->offsets_count) {\n        utf16 = ordt->ordt2[offset];\n    } else {\n        utf16 = offset;\n    }\n    return utf16;\n}\n\n// mobi_ordt_getbuffer from src/index.c:\nsize_t mobi_ordt_getbuffer(const MOBIOrdt *ordt, MOBIBuffer *buf, uint16_t *offset) { /* <=== mobi_ordt_getbuffer */ \n    size_t i = 0;\n    if (ordt->type == 1) {\n        *offset = mobi_buffer_get8(buf);\n        i++;\n    } else {\n        *offset = mobi_buffer_get16(buf);\n        i += 2;\n    }\n    return i;\n}\n\n// mobi_bitcount from src/util.c:\nint mobi_bitcount(const uint8_t byte) { /* <=== mobi_bitcount */ \n    return setbits[byte];\n}\n\n// mobi_getstring_ordt from src/index.c:\nsize_t mobi_getstring_ordt(const MOBIOrdt *ordt, MOBIBuffer *buf, unsigned char *output, size_t length) { /* <=== mobi_getstring_ordt */ \n    size_t i = 0;\n    size_t output_length = 0;\n    const uint32_t bytemask = 0xbf;\n    const uint32_t bytemark = 0x80;\n    const uint32_t uni_replacement = 0xfffd;\n    const uint32_t surrogate_offset = 0x35fdc00;\n    static const uint8_t init_byte[7] = { 0x00, 0x00, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc };\n    while (i < length) {\n        uint16_t offset;\n        i += mobi_ordt_getbuffer(ordt, buf, &offset);\n        uint32_t codepoint = mobi_ordt_lookup(ordt, offset);\n        if (codepoint <= 5) {\n            size_t k = mobi_ordt_getbuffer(ordt, buf, &offset);\n            uint32_t codepoint2 = mobi_ordt_lookup(ordt, offset);\n            codepoint = mobi_ligature_to_utf16(codepoint, codepoint2);\n            if (codepoint == uni_replacement) {\n                /* rewind buffer to codepoint2 */\n                debug_print(\"Invalid ligature sequence%s\", \"\\n\");\n                mobi_buffer_seek(buf, - (int) k);\n            } else {\n                i += k;\n            }\n        }\n        /* convert UTF-16 surrogates into UTF-32 */\n        if (codepoint >= 0xd800 && codepoint <= 0xdbff) {\n            size_t k = mobi_ordt_getbuffer(ordt, buf, &offset);\n            uint32_t codepoint2 = mobi_ordt_lookup(ordt, offset);\n            if (codepoint2 >= 0xdc00 && codepoint2 <= 0xdfff) {\n                i += k;\n                codepoint = (codepoint << 10) + codepoint2 - surrogate_offset;\n            } else {\n                /* illegal unpaired high surrogate */\n                /* rewind buffer to codepoint2 */\n                debug_print(\"Invalid code point: %u\\n\", codepoint);\n                mobi_buffer_seek(buf, - (int) k);\n                codepoint = uni_replacement;\n            }\n        }\n        if ((codepoint >= 0xdc00 && codepoint <= 0xdfff) /* unpaired low surrogate */\n            || (codepoint >= 0xfdd0 && codepoint <= 0xfdef) /* invalid characters */\n            || (codepoint & 0xfffe) == 0xfffe /* reserved characters */\n            || codepoint == 0 /* remove zeroes */) {\n            codepoint = uni_replacement;\n            debug_print(\"Invalid code point: %u\\n\", codepoint);\n        }\n        /* Conversion routine based on unicode's ConvertUTF.c */\n        size_t bytes;\n        if (codepoint < 0x80) { bytes = 1; }\n        else if (codepoint < 0x800) { bytes = 2; }\n        else if (codepoint < 0x10000) { bytes = 3; }\n        else if (codepoint < 0x110000) { bytes = 4; }\n        else {\n            bytes = 3;\n            codepoint = uni_replacement;\n            debug_print(\"Invalid code point: %u\\n\", codepoint);\n        }\n        if (output_length + bytes >= INDX_LABEL_SIZEMAX) {\n            debug_print(\"%s\\n\", \"INDX label too long\");\n            break;\n        }\n        output += bytes;\n        switch (bytes) {\n            case 4: *--output = (uint8_t)((codepoint | bytemark) & bytemask); codepoint >>= 6; /* falls through */\n            case 3: *--output = (uint8_t)((codepoint | bytemark) & bytemask); codepoint >>= 6; /* falls through */\n            case 2: *--output = (uint8_t)((codepoint | bytemark) & bytemask); codepoint >>= 6; /* falls through */\n            case 1: *--output = (uint8_t)(codepoint | init_byte[bytes]);\n        }\n        output += bytes;\n        output_length += bytes;\n    }\n    *output = '\\0';\n    return output_length;\n}\n\n// mobi_buffer_get_varlen_internal from src/buffer.c:\nstatic uint32_t mobi_buffer_get_varlen_internal(MOBIBuffer *buf, size_t *len, const int direction) { /* <=== mobi_buffer_get_varlen_internal */ \n    uint32_t val = 0;\n    uint8_t byte_count = 0;\n    uint8_t byte;\n    const uint8_t stop_flag = 0x80;\n    const uint8_t mask = 0x7f;\n    uint32_t shift = 0;\n    do {\n        if (direction == 1) {\n            if (buf->offset + 1 > buf->maxlen) {\n                debug_print(\"%s\", \"End of buffer\\n\");\n                buf->error = MOBI_BUFFER_END;\n                return val;\n            }\n            byte = buf->data[buf->offset++];\n            val <<= 7;\n            val |= (byte & mask);\n        } else {\n            if (buf->offset < 1) {\n                debug_print(\"%s\", \"End of buffer\\n\");\n                buf->error = MOBI_BUFFER_END;\n                return val;\n            }\n            byte = buf->data[buf->offset--];\n            val = val | (uint32_t)(byte & mask) << shift;\n            shift += 7;\n        }        \n        (*len)++;\n        byte_count++;\n    } while (!(byte & stop_flag) && (byte_count < 4));\n    return val;\n}\n\n// mobi_buffer_seek from src/buffer.c:\nvoid mobi_buffer_seek(MOBIBuffer *buf, const int diff) { /* <=== mobi_buffer_seek */ \n    size_t adiff = (size_t) abs(diff);\n    if (diff >= 0) {\n        if (buf->offset + adiff <= buf->maxlen) {\n            buf->offset += adiff;\n            return;\n        }\n    } else {\n        if (buf->offset >= adiff) {\n            buf->offset -= adiff;\n            return;\n        }\n    }\n    buf->error = MOBI_BUFFER_END;\n    debug_print(\"%s\", \"End of buffer\\n\");\n}\n\n// mobi_indx_get_label from src/index.c:\nsize_t mobi_indx_get_label(unsigned char *output, MOBIBuffer *buf, const size_t length, const size_t has_ligatures) { /* <=== mobi_indx_get_label */ \n    if (!output) {\n        buf->error = MOBI_PARAM_ERR;\n        return 0;\n    }\n    if (buf->offset + length > buf->maxlen) {\n        debug_print(\"%s\", \"End of buffer\\n\");\n        buf->error = MOBI_BUFFER_END;\n        return 0;\n    }\n    const unsigned char replacement = 0x3f;\n    size_t output_length = 0;\n    size_t i = 0;\n    while (i < length && output_length < INDX_LABEL_SIZEMAX) {\n        unsigned char c = mobi_buffer_get8(buf);\n        i++;\n        if (c == 0) {\n            /* FIXME: is it safe to replace zeroes? */\n            debug_print(\"Invalid character: %u\\n\", c);\n            c = replacement;\n        }\n        if (c <= 5 && has_ligatures) {\n            unsigned char c2 = mobi_buffer_get8(buf);\n            c = mobi_ligature_to_cp1252(c, c2);\n            if (c == 0) {\n                debug_print(\"Invalid ligature sequence%s\", \"\\n\");\n                mobi_buffer_seek(buf, -1);\n                c = replacement;\n            } else {\n                i++;\n            }\n        }\n        *output++ = c;\n        output_length++;\n    }\n    *output = '\\0';\n    return output_length;\n}\n\n// INDX_LABEL_SIZEMAX from src/index.h:\n#define INDX_LABEL_SIZEMAX 1000 /**< Max size of index label */ /* <=== src/index.h:54:54:INDX_LABEL_SIZEMAX:0 */ \n\n// mobi_buffer_get_varlen from src/buffer.c:\nuint32_t mobi_buffer_get_varlen(MOBIBuffer *buf, size_t *len) { /* <=== mobi_buffer_get_varlen */ \n    return mobi_buffer_get_varlen_internal(buf, len, 1);\n}\n"
  },
  {
    "repository": "libexpat",
    "cve_id": "CVE-2022-25236",
    "cwe_list": [
      "CWE-668"
    ],
    "commit_hash": "a2fe525e660badd64b6c557c2b1ec26ddc07f6e4",
    "short_hash": "a2fe525e",
    "vulnerableMethods_before": [
      {
        "filename": "xmlparse.c",
        "method_name": "vulnerable_function",
        "raw_code": "addBinding(XML_Parser parser, PREFIX *prefix, const ATTRIBUTE_ID *attId,\n           const XML_Char *uri, BINDING **bindingsPtr) {\n  static const XML_Char xmlNamespace[]\n      = {ASCII_h,      ASCII_t,     ASCII_t,     ASCII_p,      ASCII_COLON,\n         ASCII_SLASH,  ASCII_SLASH, ASCII_w,     ASCII_w,      ASCII_w,\n         ASCII_PERIOD, ASCII_w,     ASCII_3,     ASCII_PERIOD, ASCII_o,\n         ASCII_r,      ASCII_g,     ASCII_SLASH, ASCII_X,      ASCII_M,\n         ASCII_L,      ASCII_SLASH, ASCII_1,     ASCII_9,      ASCII_9,\n         ASCII_8,      ASCII_SLASH, ASCII_n,     ASCII_a,      ASCII_m,\n         ASCII_e,      ASCII_s,     ASCII_p,     ASCII_a,      ASCII_c,\n         ASCII_e,      '\\0'};\n  static const int xmlLen = (int)sizeof(xmlNamespace) / sizeof(XML_Char) - 1;\n  static const XML_Char xmlnsNamespace[]\n      = {ASCII_h,     ASCII_t,      ASCII_t, ASCII_p, ASCII_COLON,  ASCII_SLASH,\n         ASCII_SLASH, ASCII_w,      ASCII_w, ASCII_w, ASCII_PERIOD, ASCII_w,\n         ASCII_3,     ASCII_PERIOD, ASCII_o, ASCII_r, ASCII_g,      ASCII_SLASH,\n         ASCII_2,     ASCII_0,      ASCII_0, ASCII_0, ASCII_SLASH,  ASCII_x,\n         ASCII_m,     ASCII_l,      ASCII_n, ASCII_s, ASCII_SLASH,  '\\0'};\n  static const int xmlnsLen\n      = (int)sizeof(xmlnsNamespace) / sizeof(XML_Char) - 1;\n\n  XML_Bool mustBeXML = XML_FALSE;\n  XML_Bool isXML = XML_TRUE;\n  XML_Bool isXMLNS = XML_TRUE;\n\n  BINDING *b;\n  int len;\n\n  /* empty URI is only valid for default namespace per XML NS 1.0 (not 1.1) */\n  if (*uri == XML_T('\\0') && prefix->name)\n    return XML_ERROR_UNDECLARING_PREFIX;\n\n  if (prefix->name && prefix->name[0] == XML_T(ASCII_x)\n      && prefix->name[1] == XML_T(ASCII_m)\n      && prefix->name[2] == XML_T(ASCII_l)) {\n    /* Not allowed to bind xmlns */\n    if (prefix->name[3] == XML_T(ASCII_n) && prefix->name[4] == XML_T(ASCII_s)\n        && prefix->name[5] == XML_T('\\0'))\n      return XML_ERROR_RESERVED_PREFIX_XMLNS;\n\n    if (prefix->name[3] == XML_T('\\0'))\n      mustBeXML = XML_TRUE;\n  }\n\n  for (len = 0; uri[len]; len++) {\n    if (isXML && (len > xmlLen || uri[len] != xmlNamespace[len]))\n      isXML = XML_FALSE;\n\n    if (! mustBeXML && isXMLNS\n        && (len > xmlnsLen || uri[len] != xmlnsNamespace[len]))\n      isXMLNS = XML_FALSE;\n  }\n  isXML = isXML && len == xmlLen;\n  isXMLNS = isXMLNS && len == xmlnsLen;\n\n  if (mustBeXML != isXML)\n    return mustBeXML ? XML_ERROR_RESERVED_PREFIX_XML\n                     : XML_ERROR_RESERVED_NAMESPACE_URI;\n\n  if (isXMLNS)\n    return XML_ERROR_RESERVED_NAMESPACE_URI;\n\n  if (parser->m_namespaceSeparator)\n    len++;\n  if (parser->m_freeBindingList) {\n    b = parser->m_freeBindingList;\n    if (len > b->uriAlloc) {\n      /* Detect and prevent integer overflow */\n      if (len > INT_MAX - EXPAND_SPARE) {\n        return XML_ERROR_NO_MEMORY;\n      }\n\n      /* Detect and prevent integer overflow.\n       * The preprocessor guard addresses the \"always false\" warning\n       * from -Wtype-limits on platforms where\n       * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n      if ((unsigned)(len + EXPAND_SPARE) > (size_t)(-1) / sizeof(XML_Char)) {\n        return XML_ERROR_NO_MEMORY;\n      }\n#endif\n\n      XML_Char *temp = (XML_Char *)REALLOC(\n          parser, b->uri, sizeof(XML_Char) * (len + EXPAND_SPARE));\n      if (temp == NULL)\n        return XML_ERROR_NO_MEMORY;\n      b->uri = temp;\n      b->uriAlloc = len + EXPAND_SPARE;\n    }\n    parser->m_freeBindingList = b->nextTagBinding;\n  } else {\n    b = (BINDING *)MALLOC(parser, sizeof(BINDING));\n    if (! b)\n      return XML_ERROR_NO_MEMORY;\n\n    /* Detect and prevent integer overflow */\n    if (len > INT_MAX - EXPAND_SPARE) {\n      return XML_ERROR_NO_MEMORY;\n    }\n    /* Detect and prevent integer overflow.\n     * The preprocessor guard addresses the \"always false\" warning\n     * from -Wtype-limits on platforms where\n     * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n    if ((unsigned)(len + EXPAND_SPARE) > (size_t)(-1) / sizeof(XML_Char)) {\n      return XML_ERROR_NO_MEMORY;\n    }\n#endif\n\n    b->uri\n        = (XML_Char *)MALLOC(parser, sizeof(XML_Char) * (len + EXPAND_SPARE));\n    if (! b->uri) {\n      FREE(parser, b);\n      return XML_ERROR_NO_MEMORY;\n    }\n    b->uriAlloc = len + EXPAND_SPARE;\n  }\n  b->uriLen = len;\n  memcpy(b->uri, uri, len * sizeof(XML_Char));\n  if (parser->m_namespaceSeparator)\n    b->uri[len - 1] = parser->m_namespaceSeparator;\n  b->prefix = prefix;\n  b->attId = attId;\n  b->prevPrefixBinding = prefix->binding;\n  /* NULL binding when default namespace undeclared */\n  if (*uri == XML_T('\\0') && prefix == &parser->m_dtd->defaultPrefix)\n    prefix->binding = NULL;\n  else\n    prefix->binding = b;\n  b->nextTagBinding = *bindingsPtr;\n  *bindingsPtr = b;\n  /* if attId == NULL then we are not starting a namespace scope */\n  if (attId && parser->m_startNamespaceDeclHandler)\n    parser->m_startNamespaceDeclHandler(parser->m_handlerArg, prefix->name,\n                                        prefix->binding ? uri : 0);\n  return XML_ERROR_NONE;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "xmlparse.c",
        "method_name": "fixed_function",
        "raw_code": "addBinding(XML_Parser parser, PREFIX *prefix, const ATTRIBUTE_ID *attId,\n           const XML_Char *uri, BINDING **bindingsPtr) {\n  static const XML_Char xmlNamespace[]\n      = {ASCII_h,      ASCII_t,     ASCII_t,     ASCII_p,      ASCII_COLON,\n         ASCII_SLASH,  ASCII_SLASH, ASCII_w,     ASCII_w,      ASCII_w,\n         ASCII_PERIOD, ASCII_w,     ASCII_3,     ASCII_PERIOD, ASCII_o,\n         ASCII_r,      ASCII_g,     ASCII_SLASH, ASCII_X,      ASCII_M,\n         ASCII_L,      ASCII_SLASH, ASCII_1,     ASCII_9,      ASCII_9,\n         ASCII_8,      ASCII_SLASH, ASCII_n,     ASCII_a,      ASCII_m,\n         ASCII_e,      ASCII_s,     ASCII_p,     ASCII_a,      ASCII_c,\n         ASCII_e,      '\\0'};\n  static const int xmlLen = (int)sizeof(xmlNamespace) / sizeof(XML_Char) - 1;\n  static const XML_Char xmlnsNamespace[]\n      = {ASCII_h,     ASCII_t,      ASCII_t, ASCII_p, ASCII_COLON,  ASCII_SLASH,\n         ASCII_SLASH, ASCII_w,      ASCII_w, ASCII_w, ASCII_PERIOD, ASCII_w,\n         ASCII_3,     ASCII_PERIOD, ASCII_o, ASCII_r, ASCII_g,      ASCII_SLASH,\n         ASCII_2,     ASCII_0,      ASCII_0, ASCII_0, ASCII_SLASH,  ASCII_x,\n         ASCII_m,     ASCII_l,      ASCII_n, ASCII_s, ASCII_SLASH,  '\\0'};\n  static const int xmlnsLen\n      = (int)sizeof(xmlnsNamespace) / sizeof(XML_Char) - 1;\n\n  XML_Bool mustBeXML = XML_FALSE;\n  XML_Bool isXML = XML_TRUE;\n  XML_Bool isXMLNS = XML_TRUE;\n\n  BINDING *b;\n  int len;\n\n  /* empty URI is only valid for default namespace per XML NS 1.0 (not 1.1) */\n  if (*uri == XML_T('\\0') && prefix->name)\n    return XML_ERROR_UNDECLARING_PREFIX;\n\n  if (prefix->name && prefix->name[0] == XML_T(ASCII_x)\n      && prefix->name[1] == XML_T(ASCII_m)\n      && prefix->name[2] == XML_T(ASCII_l)) {\n    /* Not allowed to bind xmlns */\n    if (prefix->name[3] == XML_T(ASCII_n) && prefix->name[4] == XML_T(ASCII_s)\n        && prefix->name[5] == XML_T('\\0'))\n      return XML_ERROR_RESERVED_PREFIX_XMLNS;\n\n    if (prefix->name[3] == XML_T('\\0'))\n      mustBeXML = XML_TRUE;\n  }\n\n  for (len = 0; uri[len]; len++) {\n    if (isXML && (len > xmlLen || uri[len] != xmlNamespace[len]))\n      isXML = XML_FALSE;\n\n    if (! mustBeXML && isXMLNS\n        && (len > xmlnsLen || uri[len] != xmlnsNamespace[len]))\n      isXMLNS = XML_FALSE;\n\n    // NOTE: While Expat does not validate namespace URIs against RFC 3986,\n    //       we have to at least make sure that the XML processor on top of\n    //       Expat (that is splitting tag names by namespace separator into\n    //       2- or 3-tuples (uri-local or uri-local-prefix)) cannot be confused\n    //       by an attacker putting additional namespace separator characters\n    //       into namespace declarations.  That would be ambiguous and not to\n    //       be expected.\n    if (parser->m_ns && (uri[len] == parser->m_namespaceSeparator)) {\n      return XML_ERROR_SYNTAX;\n    }\n  }\n  isXML = isXML && len == xmlLen;\n  isXMLNS = isXMLNS && len == xmlnsLen;\n\n  if (mustBeXML != isXML)\n    return mustBeXML ? XML_ERROR_RESERVED_PREFIX_XML\n                     : XML_ERROR_RESERVED_NAMESPACE_URI;\n\n  if (isXMLNS)\n    return XML_ERROR_RESERVED_NAMESPACE_URI;\n\n  if (parser->m_namespaceSeparator)\n    len++;\n  if (parser->m_freeBindingList) {\n    b = parser->m_freeBindingList;\n    if (len > b->uriAlloc) {\n      /* Detect and prevent integer overflow */\n      if (len > INT_MAX - EXPAND_SPARE) {\n        return XML_ERROR_NO_MEMORY;\n      }\n\n      /* Detect and prevent integer overflow.\n       * The preprocessor guard addresses the \"always false\" warning\n       * from -Wtype-limits on platforms where\n       * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n      if ((unsigned)(len + EXPAND_SPARE) > (size_t)(-1) / sizeof(XML_Char)) {\n        return XML_ERROR_NO_MEMORY;\n      }\n#endif\n\n      XML_Char *temp = (XML_Char *)REALLOC(\n          parser, b->uri, sizeof(XML_Char) * (len + EXPAND_SPARE));\n      if (temp == NULL)\n        return XML_ERROR_NO_MEMORY;\n      b->uri = temp;\n      b->uriAlloc = len + EXPAND_SPARE;\n    }\n    parser->m_freeBindingList = b->nextTagBinding;\n  } else {\n    b = (BINDING *)MALLOC(parser, sizeof(BINDING));\n    if (! b)\n      return XML_ERROR_NO_MEMORY;\n\n    /* Detect and prevent integer overflow */\n    if (len > INT_MAX - EXPAND_SPARE) {\n      return XML_ERROR_NO_MEMORY;\n    }\n    /* Detect and prevent integer overflow.\n     * The preprocessor guard addresses the \"always false\" warning\n     * from -Wtype-limits on platforms where\n     * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n    if ((unsigned)(len + EXPAND_SPARE) > (size_t)(-1) / sizeof(XML_Char)) {\n      return XML_ERROR_NO_MEMORY;\n    }\n#endif\n\n    b->uri\n        = (XML_Char *)MALLOC(parser, sizeof(XML_Char) * (len + EXPAND_SPARE));\n    if (! b->uri) {\n      FREE(parser, b);\n      return XML_ERROR_NO_MEMORY;\n    }\n    b->uriAlloc = len + EXPAND_SPARE;\n  }\n  b->uriLen = len;\n  memcpy(b->uri, uri, len * sizeof(XML_Char));\n  if (parser->m_namespaceSeparator)\n    b->uri[len - 1] = parser->m_namespaceSeparator;\n  b->prefix = prefix;\n  b->attId = attId;\n  b->prevPrefixBinding = prefix->binding;\n  /* NULL binding when default namespace undeclared */\n  if (*uri == XML_T('\\0') && prefix == &parser->m_dtd->defaultPrefix)\n    prefix->binding = NULL;\n  else\n    prefix->binding = b;\n  b->nextTagBinding = *bindingsPtr;\n  *bindingsPtr = b;\n  /* if attId == NULL then we are not starting a namespace scope */\n  if (attId && parser->m_startNamespaceDeclHandler)\n    parser->m_startNamespaceDeclHandler(parser->m_handlerArg, prefix->name,\n                                        prefix->binding ? uri : 0);\n  return XML_ERROR_NONE;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"ascii.h\"\n#include \"internal.h\"\n#include <stdint.h>\n#include <stdlib.h>\n#    include <unistd.h>\n#include <math.h>\n#include \"xmlrole.h\"\n#include \"expat.h\"\n#  include \"winconfig.h\"\n#  include <sys/time.h>\n#  include <errno.h>\n#    include <sys/syscall.h>\n#include <string.h>\n#    include <sys/random.h>\n#include <stdio.h>\n#  include <fcntl.h>\n#include \"xmltok.h\"\n#include <limits.h>\n#  include <bsd/stdlib.h>\n#include <expat_config.h>\n#include <assert.h>\n#include \"siphash.h\"\n#include <stddef.h>\n#  include <sys/types.h>\n#  include <unistd.h>\n\n// Type Definitions:\n// PREFIX:\ntypedef struct prefix {\n  const XML_Char *name;\n  BINDING *binding;\n} PREFIX;\n\n// XML_Parser:\ntypedef struct XML_ParserStruct *XML_Parser;\n\n// XML_Char:\ntypedef wchar_t XML_Char;\n\n// BINDING:\ntypedef struct binding {\n  struct prefix *prefix;\n  struct binding *nextTagBinding;\n  struct binding *prevPrefixBinding;\n  const struct attribute_id *attId;\n  XML_Char *uri;\n  int uriLen;\n  int uriAlloc;\n} BINDING;\n\n// ATTRIBUTE_ID:\ntypedef struct attribute_id {\n  XML_Char *name;\n  PREFIX *prefix;\n  XML_Bool maybeTokenized;\n  XML_Bool xmlns;\n} ATTRIBUTE_ID;\n\n// XML_Bool:\ntypedef unsigned char XML_Bool;\n\n// XML_Char:\ntypedef unsigned short XML_Char;\n\n// Called Methods (top 10):\n// XML_FALSE from expat/lib/expat.h:\n<empty>\n\n// FREE from expat/lib/xmlparse.c:\n<empty>\n\n// XML_T from expat/lib/xmlparse.c:\n<empty>\n\n// MALLOC from expat/lib/xmlparse.c:\n<empty>\n\n// XML_TRUE from expat/lib/expat.h:\n<empty>\n\n// EXPAND_SPARE from expat/lib/xmlparse.c:\n<empty>\n\n// REALLOC from expat/lib/xmlparse.c:\n<empty>\n"
  },
  {
    "repository": "squid",
    "cve_id": "CVE-2021-46784",
    "cwe_list": [
      "CWE-400"
    ],
    "commit_hash": "780c4ea1b4c9d2fb41f6962aa6ed73ae57f74b2b",
    "short_hash": "780c4ea1",
    "vulnerableMethods_before": [
      {
        "filename": "gopher.cc",
        "method_name": "vulnerable_function",
        "raw_code": "gopherToHTML(GopherStateData * gopherState, char *inbuf, int len)\n{\n    char *pos = inbuf;\n    char *lpos = NULL;\n    char *tline = NULL;\n    LOCAL_ARRAY(char, line, TEMP_BUF_SIZE);\n    LOCAL_ARRAY(char, tmpbuf, TEMP_BUF_SIZE);\n    char *name = NULL;\n    char *selector = NULL;\n    char *host = NULL;\n    char *port = NULL;\n    char *escaped_selector = NULL;\n    const char *icon_url = NULL;\n    char gtype;\n    StoreEntry *entry = NULL;\n\n    memset(tmpbuf, '\\0', TEMP_BUF_SIZE);\n    memset(line, '\\0', TEMP_BUF_SIZE);\n\n    entry = gopherState->entry;\n\n    if (gopherState->conversion == GopherStateData::HTML_INDEX_PAGE) {\n        char *html_url = html_quote(entry->url());\n        gopherHTMLHeader(entry, \"Gopher Index %s\", html_url);\n        storeAppendPrintf(entry,\n                          \"<p>This is a searchable Gopher index. Use the search\\n\"\n                          \"function of your browser to enter search terms.\\n\"\n                          \"<ISINDEX>\\n\");\n        gopherHTMLFooter(entry);\n        /* now let start sending stuff to client */\n        entry->flush();\n        gopherState->HTML_header_added = 1;\n\n        return;\n    }\n\n    if (gopherState->conversion == GopherStateData::HTML_CSO_PAGE) {\n        char *html_url = html_quote(entry->url());\n        gopherHTMLHeader(entry, \"CSO Search of %s\", html_url);\n        storeAppendPrintf(entry,\n                          \"<P>A CSO database usually contains a phonebook or\\n\"\n                          \"directory.  Use the search function of your browser to enter\\n\"\n                          \"search terms.</P><ISINDEX>\\n\");\n        gopherHTMLFooter(entry);\n        /* now let start sending stuff to client */\n        entry->flush();\n        gopherState->HTML_header_added = 1;\n\n        return;\n    }\n\n    String outbuf;\n\n    if (!gopherState->HTML_header_added) {\n        if (gopherState->conversion == GopherStateData::HTML_CSO_RESULT)\n            gopherHTMLHeader(entry, \"CSO Search Result\", NULL);\n        else\n            gopherHTMLHeader(entry, \"Gopher Menu\", NULL);\n\n        outbuf.append (\"<PRE>\");\n\n        gopherState->HTML_header_added = 1;\n\n        gopherState->HTML_pre = 1;\n    }\n\n    while (pos < inbuf + len) {\n        int llen;\n        int left = len - (pos - inbuf);\n        lpos = (char *)memchr(pos, '\\n', left);\n        if (lpos) {\n            ++lpos;             /* Next line is after \\n */\n            llen = lpos - pos;\n        } else {\n            llen = left;\n        }\n        if (gopherState->len + llen >= TEMP_BUF_SIZE) {\n            debugs(10, DBG_IMPORTANT, \"GopherHTML: Buffer overflow. Lost some data on URL: \" << entry->url()  );\n            llen = TEMP_BUF_SIZE - gopherState->len - 1;\n        }\n        if (!lpos) {\n            /* there is no complete line in inbuf */\n            /* copy it to temp buffer */\n            /* note: llen is adjusted above */\n            memcpy(gopherState->buf + gopherState->len, pos, llen);\n            gopherState->len += llen;\n            break;\n        }\n        if (gopherState->len != 0) {\n            /* there is something left from last tx. */\n            memcpy(line, gopherState->buf, gopherState->len);\n            memcpy(line + gopherState->len, pos, llen);\n            llen += gopherState->len;\n            gopherState->len = 0;\n        } else {\n            memcpy(line, pos, llen);\n        }\n        line[llen + 1] = '\\0';\n        /* move input to next line */\n        pos = lpos;\n\n        /* at this point. We should have one line in buffer to process */\n\n        if (*line == '.') {\n            /* skip it */\n            memset(line, '\\0', TEMP_BUF_SIZE);\n            continue;\n        }\n\n        switch (gopherState->conversion) {\n\n        case GopherStateData::HTML_INDEX_RESULT:\n\n        case GopherStateData::HTML_DIR: {\n            tline = line;\n            gtype = *tline;\n            ++tline;\n            name = tline;\n            selector = strchr(tline, TAB);\n\n            if (selector) {\n                *selector = '\\0';\n                ++selector;\n                host = strchr(selector, TAB);\n\n                if (host) {\n                    *host = '\\0';\n                    ++host;\n                    port = strchr(host, TAB);\n\n                    if (port) {\n                        char *junk;\n                        port[0] = ':';\n                        junk = strchr(host, TAB);\n\n                        if (junk)\n                            *junk++ = 0;    /* Chop port */\n                        else {\n                            junk = strchr(host, '\\r');\n\n                            if (junk)\n                                *junk++ = 0;    /* Chop port */\n                            else {\n                                junk = strchr(host, '\\n');\n\n                                if (junk)\n                                    *junk++ = 0;    /* Chop port */\n                            }\n                        }\n\n                        if ((port[1] == '0') && (!port[2]))\n                            port[0] = 0;    /* 0 means none */\n                    }\n\n                    /* escape a selector here */\n                    escaped_selector = xstrdup(rfc1738_escape_part(selector));\n\n                    switch (gtype) {\n\n                    case GOPHER_DIRECTORY:\n                        icon_url = mimeGetIconURL(\"internal-menu\");\n                        break;\n\n                    case GOPHER_HTML:\n\n                    case GOPHER_FILE:\n                        icon_url = mimeGetIconURL(\"internal-text\");\n                        break;\n\n                    case GOPHER_INDEX:\n\n                    case GOPHER_CSO:\n                        icon_url = mimeGetIconURL(\"internal-index\");\n                        break;\n\n                    case GOPHER_IMAGE:\n\n                    case GOPHER_GIF:\n\n                    case GOPHER_PLUS_IMAGE:\n                        icon_url = mimeGetIconURL(\"internal-image\");\n                        break;\n\n                    case GOPHER_SOUND:\n\n                    case GOPHER_PLUS_SOUND:\n                        icon_url = mimeGetIconURL(\"internal-sound\");\n                        break;\n\n                    case GOPHER_PLUS_MOVIE:\n                        icon_url = mimeGetIconURL(\"internal-movie\");\n                        break;\n\n                    case GOPHER_TELNET:\n\n                    case GOPHER_3270:\n                        icon_url = mimeGetIconURL(\"internal-telnet\");\n                        break;\n\n                    case GOPHER_BIN:\n\n                    case GOPHER_MACBINHEX:\n\n                    case GOPHER_DOSBIN:\n\n                    case GOPHER_UUENCODED:\n                        icon_url = mimeGetIconURL(\"internal-binary\");\n                        break;\n\n                    case GOPHER_INFO:\n                        icon_url = NULL;\n                        break;\n\n                    default:\n                        icon_url = mimeGetIconURL(\"internal-unknown\");\n                        break;\n                    }\n\n                    memset(tmpbuf, '\\0', TEMP_BUF_SIZE);\n\n                    if ((gtype == GOPHER_TELNET) || (gtype == GOPHER_3270)) {\n                        if (strlen(escaped_selector) != 0)\n                            snprintf(tmpbuf, TEMP_BUF_SIZE, \"<IMG border=\\\"0\\\" SRC=\\\"%s\\\"> <A HREF=\\\"telnet://%s@%s%s%s/\\\">%s</A>\\n\",\n                                     icon_url, escaped_selector, rfc1738_escape_part(host),\n                                     *port ? \":\" : \"\", port, html_quote(name));\n                        else\n                            snprintf(tmpbuf, TEMP_BUF_SIZE, \"<IMG border=\\\"0\\\" SRC=\\\"%s\\\"> <A HREF=\\\"telnet://%s%s%s/\\\">%s</A>\\n\",\n                                     icon_url, rfc1738_escape_part(host), *port ? \":\" : \"\",\n                                     port, html_quote(name));\n\n                    } else if (gtype == GOPHER_INFO) {\n                        snprintf(tmpbuf, TEMP_BUF_SIZE, \"\\t%s\\n\", html_quote(name));\n                    } else {\n                        if (strncmp(selector, \"GET /\", 5) == 0) {\n                            /* WWW link */\n                            snprintf(tmpbuf, TEMP_BUF_SIZE, \"<IMG border=\\\"0\\\" SRC=\\\"%s\\\"> <A HREF=\\\"http://%s/%s\\\">%s</A>\\n\",\n                                     icon_url, host, rfc1738_escape_unescaped(selector + 5), html_quote(name));\n                        } else {\n                            /* Standard link */\n                            snprintf(tmpbuf, TEMP_BUF_SIZE, \"<IMG border=\\\"0\\\" SRC=\\\"%s\\\"> <A HREF=\\\"gopher://%s/%c%s\\\">%s</A>\\n\",\n                                     icon_url, host, gtype, escaped_selector, html_quote(name));\n                        }\n                    }\n\n                    safe_free(escaped_selector);\n                    outbuf.append(tmpbuf);\n                } else {\n                    memset(line, '\\0', TEMP_BUF_SIZE);\n                    continue;\n                }\n            } else {\n                memset(line, '\\0', TEMP_BUF_SIZE);\n                continue;\n            }\n\n            break;\n            }           /* HTML_DIR, HTML_INDEX_RESULT */\n\n        case GopherStateData::HTML_CSO_RESULT: {\n            if (line[0] == '-') {\n                int code, recno;\n                char *s_code, *s_recno, *result;\n\n                s_code = strtok(line + 1, \":\\n\");\n                s_recno = strtok(NULL, \":\\n\");\n                result = strtok(NULL, \"\\n\");\n\n                if (!result)\n                    break;\n\n                code = atoi(s_code);\n\n                recno = atoi(s_recno);\n\n                if (code != 200)\n                    break;\n\n                if (gopherState->cso_recno != recno) {\n                    snprintf(tmpbuf, TEMP_BUF_SIZE, \"</PRE><HR noshade size=\\\"1px\\\"><H2>Record# %d<br><i>%s</i></H2>\\n<PRE>\", recno, html_quote(result));\n                    gopherState->cso_recno = recno;\n                } else {\n                    snprintf(tmpbuf, TEMP_BUF_SIZE, \"%s\\n\", html_quote(result));\n                }\n\n                outbuf.append(tmpbuf);\n                break;\n            } else {\n                int code;\n                char *s_code, *result;\n\n                s_code = strtok(line, \":\");\n                result = strtok(NULL, \"\\n\");\n\n                if (!result)\n                    break;\n\n                code = atoi(s_code);\n\n                switch (code) {\n\n                case 200: {\n                    /* OK */\n                    /* Do nothing here */\n                    break;\n                }\n\n                case 102:   /* Number of matches */\n\n                case 501:   /* No Match */\n\n                case 502: { /* Too Many Matches */\n                    /* Print the message the server returns */\n                    snprintf(tmpbuf, TEMP_BUF_SIZE, \"</PRE><HR noshade size=\\\"1px\\\"><H2>%s</H2>\\n<PRE>\", html_quote(result));\n                    outbuf.append(tmpbuf);\n                    break;\n                }\n\n                }\n            }\n\n            }           /* HTML_CSO_RESULT */\n\n        default:\n            break;      /* do nothing */\n\n        }           /* switch */\n\n    }               /* while loop */\n\n    if (outbuf.size() > 0) {\n        entry->append(outbuf.rawBuf(), outbuf.size());\n        /* now let start sending stuff to client */\n        entry->flush();\n    }\n\n    outbuf.clean();\n    return;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "gopher.cc",
        "method_name": "fixed_function",
        "raw_code": "gopherToHTML(GopherStateData * gopherState, char *inbuf, int len)\n{\n    char *pos = inbuf;\n    char *lpos = NULL;\n    char *tline = NULL;\n    LOCAL_ARRAY(char, line, TEMP_BUF_SIZE);\n    char *name = NULL;\n    char *selector = NULL;\n    char *host = NULL;\n    char *port = NULL;\n    char *escaped_selector = NULL;\n    const char *icon_url = NULL;\n    char gtype;\n    StoreEntry *entry = NULL;\n\n    memset(line, '\\0', TEMP_BUF_SIZE);\n\n    entry = gopherState->entry;\n\n    if (gopherState->conversion == GopherStateData::HTML_INDEX_PAGE) {\n        char *html_url = html_quote(entry->url());\n        gopherHTMLHeader(entry, \"Gopher Index %s\", html_url);\n        storeAppendPrintf(entry,\n                          \"<p>This is a searchable Gopher index. Use the search\\n\"\n                          \"function of your browser to enter search terms.\\n\"\n                          \"<ISINDEX>\\n\");\n        gopherHTMLFooter(entry);\n        /* now let start sending stuff to client */\n        entry->flush();\n        gopherState->HTML_header_added = 1;\n\n        return;\n    }\n\n    if (gopherState->conversion == GopherStateData::HTML_CSO_PAGE) {\n        char *html_url = html_quote(entry->url());\n        gopherHTMLHeader(entry, \"CSO Search of %s\", html_url);\n        storeAppendPrintf(entry,\n                          \"<P>A CSO database usually contains a phonebook or\\n\"\n                          \"directory.  Use the search function of your browser to enter\\n\"\n                          \"search terms.</P><ISINDEX>\\n\");\n        gopherHTMLFooter(entry);\n        /* now let start sending stuff to client */\n        entry->flush();\n        gopherState->HTML_header_added = 1;\n\n        return;\n    }\n\n    SBuf outbuf;\n\n    if (!gopherState->HTML_header_added) {\n        if (gopherState->conversion == GopherStateData::HTML_CSO_RESULT)\n            gopherHTMLHeader(entry, \"CSO Search Result\", NULL);\n        else\n            gopherHTMLHeader(entry, \"Gopher Menu\", NULL);\n\n        outbuf.append (\"<PRE>\");\n\n        gopherState->HTML_header_added = 1;\n\n        gopherState->HTML_pre = 1;\n    }\n\n    while (pos < inbuf + len) {\n        int llen;\n        int left = len - (pos - inbuf);\n        lpos = (char *)memchr(pos, '\\n', left);\n        if (lpos) {\n            ++lpos;             /* Next line is after \\n */\n            llen = lpos - pos;\n        } else {\n            llen = left;\n        }\n        if (gopherState->len + llen >= TEMP_BUF_SIZE) {\n            debugs(10, DBG_IMPORTANT, \"GopherHTML: Buffer overflow. Lost some data on URL: \" << entry->url()  );\n            llen = TEMP_BUF_SIZE - gopherState->len - 1;\n        }\n        if (!lpos) {\n            /* there is no complete line in inbuf */\n            /* copy it to temp buffer */\n            /* note: llen is adjusted above */\n            memcpy(gopherState->buf + gopherState->len, pos, llen);\n            gopherState->len += llen;\n            break;\n        }\n        if (gopherState->len != 0) {\n            /* there is something left from last tx. */\n            memcpy(line, gopherState->buf, gopherState->len);\n            memcpy(line + gopherState->len, pos, llen);\n            llen += gopherState->len;\n            gopherState->len = 0;\n        } else {\n            memcpy(line, pos, llen);\n        }\n        line[llen + 1] = '\\0';\n        /* move input to next line */\n        pos = lpos;\n\n        /* at this point. We should have one line in buffer to process */\n\n        if (*line == '.') {\n            /* skip it */\n            memset(line, '\\0', TEMP_BUF_SIZE);\n            continue;\n        }\n\n        switch (gopherState->conversion) {\n\n        case GopherStateData::HTML_INDEX_RESULT:\n\n        case GopherStateData::HTML_DIR: {\n            tline = line;\n            gtype = *tline;\n            ++tline;\n            name = tline;\n            selector = strchr(tline, TAB);\n\n            if (selector) {\n                *selector = '\\0';\n                ++selector;\n                host = strchr(selector, TAB);\n\n                if (host) {\n                    *host = '\\0';\n                    ++host;\n                    port = strchr(host, TAB);\n\n                    if (port) {\n                        char *junk;\n                        port[0] = ':';\n                        junk = strchr(host, TAB);\n\n                        if (junk)\n                            *junk++ = 0;    /* Chop port */\n                        else {\n                            junk = strchr(host, '\\r');\n\n                            if (junk)\n                                *junk++ = 0;    /* Chop port */\n                            else {\n                                junk = strchr(host, '\\n');\n\n                                if (junk)\n                                    *junk++ = 0;    /* Chop port */\n                            }\n                        }\n\n                        if ((port[1] == '0') && (!port[2]))\n                            port[0] = 0;    /* 0 means none */\n                    }\n\n                    /* escape a selector here */\n                    escaped_selector = xstrdup(rfc1738_escape_part(selector));\n\n                    switch (gtype) {\n\n                    case GOPHER_DIRECTORY:\n                        icon_url = mimeGetIconURL(\"internal-menu\");\n                        break;\n\n                    case GOPHER_HTML:\n\n                    case GOPHER_FILE:\n                        icon_url = mimeGetIconURL(\"internal-text\");\n                        break;\n\n                    case GOPHER_INDEX:\n\n                    case GOPHER_CSO:\n                        icon_url = mimeGetIconURL(\"internal-index\");\n                        break;\n\n                    case GOPHER_IMAGE:\n\n                    case GOPHER_GIF:\n\n                    case GOPHER_PLUS_IMAGE:\n                        icon_url = mimeGetIconURL(\"internal-image\");\n                        break;\n\n                    case GOPHER_SOUND:\n\n                    case GOPHER_PLUS_SOUND:\n                        icon_url = mimeGetIconURL(\"internal-sound\");\n                        break;\n\n                    case GOPHER_PLUS_MOVIE:\n                        icon_url = mimeGetIconURL(\"internal-movie\");\n                        break;\n\n                    case GOPHER_TELNET:\n\n                    case GOPHER_3270:\n                        icon_url = mimeGetIconURL(\"internal-telnet\");\n                        break;\n\n                    case GOPHER_BIN:\n\n                    case GOPHER_MACBINHEX:\n\n                    case GOPHER_DOSBIN:\n\n                    case GOPHER_UUENCODED:\n                        icon_url = mimeGetIconURL(\"internal-binary\");\n                        break;\n\n                    case GOPHER_INFO:\n                        icon_url = NULL;\n                        break;\n\n                    default:\n                        icon_url = mimeGetIconURL(\"internal-unknown\");\n                        break;\n                    }\n\n                    if ((gtype == GOPHER_TELNET) || (gtype == GOPHER_3270)) {\n                        if (strlen(escaped_selector) != 0)\n                            outbuf.appendf(\"<IMG border=\\\"0\\\" SRC=\\\"%s\\\"> <A HREF=\\\"telnet://%s@%s%s%s/\\\">%s</A>\\n\",\n                                           icon_url, escaped_selector, rfc1738_escape_part(host),\n                                           *port ? \":\" : \"\", port, html_quote(name));\n                        else\n                            outbuf.appendf(\"<IMG border=\\\"0\\\" SRC=\\\"%s\\\"> <A HREF=\\\"telnet://%s%s%s/\\\">%s</A>\\n\",\n                                           icon_url, rfc1738_escape_part(host), *port ? \":\" : \"\",\n                                           port, html_quote(name));\n\n                    } else if (gtype == GOPHER_INFO) {\n                        outbuf.appendf(\"\\t%s\\n\", html_quote(name));\n                    } else {\n                        if (strncmp(selector, \"GET /\", 5) == 0) {\n                            /* WWW link */\n                            outbuf.appendf(\"<IMG border=\\\"0\\\" SRC=\\\"%s\\\"> <A HREF=\\\"http://%s/%s\\\">%s</A>\\n\",\n                                           icon_url, host, rfc1738_escape_unescaped(selector + 5), html_quote(name));\n                        } else if (gtype == GOPHER_WWW) {\n                            outbuf.appendf(\"<IMG border=\\\"0\\\" SRC=\\\"%s\\\"> <A HREF=\\\"gopher://%s/%c%s\\\">%s</A>\\n\",\n                                           icon_url, rfc1738_escape_unescaped(selector), html_quote(name));\n                        } else {\n                            /* Standard link */\n                            outbuf.appendf(\"<IMG border=\\\"0\\\" SRC=\\\"%s\\\"> <A HREF=\\\"gopher://%s/%c%s\\\">%s</A>\\n\",\n                                           icon_url, host, gtype, escaped_selector, html_quote(name));\n                        }\n                    }\n\n                    safe_free(escaped_selector);\n                } else {\n                    memset(line, '\\0', TEMP_BUF_SIZE);\n                    continue;\n                }\n            } else {\n                memset(line, '\\0', TEMP_BUF_SIZE);\n                continue;\n            }\n\n            break;\n            }           /* HTML_DIR, HTML_INDEX_RESULT */\n\n        case GopherStateData::HTML_CSO_RESULT: {\n            if (line[0] == '-') {\n                int code, recno;\n                char *s_code, *s_recno, *result;\n\n                s_code = strtok(line + 1, \":\\n\");\n                s_recno = strtok(NULL, \":\\n\");\n                result = strtok(NULL, \"\\n\");\n\n                if (!result)\n                    break;\n\n                code = atoi(s_code);\n\n                recno = atoi(s_recno);\n\n                if (code != 200)\n                    break;\n\n                if (gopherState->cso_recno != recno) {\n                    outbuf.appendf(\"</PRE><HR noshade size=\\\"1px\\\"><H2>Record# %d<br><i>%s</i></H2>\\n<PRE>\", recno, html_quote(result));\n                    gopherState->cso_recno = recno;\n                } else {\n                    outbuf.appendf(\"%s\\n\", html_quote(result));\n                }\n\n                break;\n            } else {\n                int code;\n                char *s_code, *result;\n\n                s_code = strtok(line, \":\");\n                result = strtok(NULL, \"\\n\");\n\n                if (!result)\n                    break;\n\n                code = atoi(s_code);\n\n                switch (code) {\n\n                case 200: {\n                    /* OK */\n                    /* Do nothing here */\n                    break;\n                }\n\n                case 102:   /* Number of matches */\n\n                case 501:   /* No Match */\n\n                case 502: { /* Too Many Matches */\n                    /* Print the message the server returns */\n                    outbuf.appendf(\"</PRE><HR noshade size=\\\"1px\\\"><H2>%s</H2>\\n<PRE>\", html_quote(result));\n                    break;\n                }\n\n                }\n            }\n\n            }           /* HTML_CSO_RESULT */\n\n        default:\n            break;      /* do nothing */\n\n        }           /* switch */\n\n    }               /* while loop */\n\n    if (outbuf.length() > 0) {\n        entry->append(outbuf.rawContent(), outbuf.length());\n        /* now let start sending stuff to client */\n        entry->flush();\n    }\n\n    return;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"parser/Tokenizer.h\"\n#include \"fd.h\"\n#include \"comm/Write.h\"\n#include \"mime.h\"\n#include \"SquidConfig.h\"\n#include \"rfc1738.h\"\n#include \"comm/Read.h\"\n#include \"MemBuf.h\"\n#include \"MemObject.h\"\n#include \"FwdState.h\"\n#include \"SquidTime.h\"\n#include \"html_quote.h\"\n#include \"DelayPools.h\"\n#include \"squid.h\"\n#include \"HttpReply.h\"\n#include \"globals.h\"\n#include \"errorpage.h\"\n#include \"HttpRequest.h\"\n#include \"StatCounters.h\"\n#include \"Store.h\"\n#include \"comm.h\"\n#include \"tools.h\"\n\n// Type Definitions:\n// SBuf:\nclass SBuf\n{\npublic:\n    typedef MemBlob::size_type size_type;\n    typedef SBufIterator const_iterator;\n    typedef SBufReverseIterator const_reverse_iterator;\n    static const size_type npos = 0xffffffff; // max(uint32_t)\n\n    /// Maximum size of a SBuf. By design it MUST be < MAX(size_type)/2. Currently 256Mb.\n    static const size_type maxSize = 0xfffffff;\n\n    /// create an empty (zero-size) SBuf\n    SBuf();\n    SBuf(const SBuf &S);\n    SBuf(SBuf&& S) : store_(std::move(S.store_)), off_(S.off_), len_(S.len_) {\n        ++stats.moves;\n        S.store_ = nullptr; //RefCount supports nullptr, and S is about to be destructed\n        S.off_ = S.len_ = 0;\n    }\n\n    /** Constructor: import c-style string\n     *\n     * Create a new SBuf containing a COPY of the contents of the\n     * c-string\n     * \\param S the c string to be copied\n     * \\param n how many bytes to import into the SBuf. If it is npos\n     *              or unspecified, imports to end-of-cstring\n     * \\note it is the ...\n\n// SBuf:\nSBuf.SBuf:ANY()\n\n// String:\nclass String\n{\n\npublic:\n    _SQUID_INLINE_ String();\n    String(char const *);\n    String(String const &);\n    ~String();\n\n    typedef size_t size_type; //storage size intentionally unspecified\n    const static size_type npos = static_cast<size_type>(-1);\n\n    String &operator =(char const *);\n    String &operator =(String const &);\n    bool operator ==(String const &) const;\n    bool operator !=(String const &) const;\n\n    /**\n     * Retrieve a single character in the string.\n     \\param pos Position of character to retrieve.\n     */\n    _SQUID_INLINE_ char operator [](unsigned int pos) const;\n\n    /// The absolute size limit on data held in a String.\n    /// Since Strings can be nil-terminated implicitly it is best to ensure\n    /// the useful content length is strictly less than this limit.\n    static size_type SizeMaxXXX() { return SizeMax_; }\n\n    _SQUID_INLINE_ size_type size() const;\n    /// variant of size() suited to be used for printf-alikes.\n    /// throws when size() > M...\n\n// GopherStateData:\nclass GopherStateData\n{\n    CBDATA_CLASS(GopherStateData);\n\npublic:\n    GopherStateData(FwdState *aFwd) :\n        entry(aFwd->entry),\n        conversion(NORMAL),\n        HTML_header_added(0),\n        HTML_pre(0),\n        type_id(GOPHER_FILE /* '0' */),\n        cso_recno(0),\n        len(0),\n        buf(NULL),\n        fwd(aFwd)\n    {\n        *request = 0;\n        buf = (char *)memAllocate(MEM_4K_BUF);\n        entry->lock(\"gopherState\");\n        *replybuf = 0;\n    }\n    ~GopherStateData() {if(buf) swanSong();}\n\n    /* AsyncJob API emulated */\n    void deleteThis(const char *aReason);\n    void swanSong();\n\npublic:\n    StoreEntry *entry;\n    enum {\n        NORMAL,\n        HTML_DIR,\n        HTML_INDEX_RESULT,\n        HTML_CSO_RESULT,\n        HTML_INDEX_PAGE,\n        HTML_CSO_PAGE\n    } conversion;\n    int HTML_header_added;\n    int HTML_pre;\n    char type_id;\n    char request[MAX_URL];\n    int cso_recno;\n    int len;\n    char *buf;          /* pts to a 4k page */\n    Comm::ConnectionPoint...\n\n// StoreEntry:\nclass StoreEntry\n\n// StoreEntry:\nclass StoreEntry : public hash_link, public Packable\n{\n\npublic:\n    static DeferredRead::DeferrableRead DeferReader;\n    bool checkDeferRead(int fd) const;\n\n    virtual const char *getMD5Text() const;\n    StoreEntry();\n    virtual ~StoreEntry();\n\n    virtual HttpReply const *getReply() const;\n    virtual void write (StoreIOBuffer);\n\n    /** Check if the Store entry is emtpty\n     * \\retval true   Store contains 0 bytes of data.\n     * \\retval false  Store contains 1 or more bytes of data.\n     * \\retval false  Store contains negative content !!!!!!\n     */\n    virtual bool isEmpty() const {\n        assert (mem_obj);\n        return mem_obj->endOffset() == 0;\n    }\n    virtual bool isAccepting() const;\n    virtual size_t bytesWanted(Range<size_t> const aRange, bool ignoreDelayPool = false) const;\n    /// flags [truncated or too big] entry with ENTRY_BAD_LENGTH and releases it\n    void lengthWentBad(const char *reason);\n    virtual void complete();\n    virtual store_client_t storeClien...\n\n// bool:\nDelayId.bool:ANY()<const>\n\n// String:\nString.String:ANY(char*)\n\n// Called Methods (top 10):\n// RFC1738_ESCAPE_CTRLS from lib/rfc1738.h:\n\n\n// rawContent from src/sbuf/SBuf.cc:\nconst char* /* <=== SBuf.rawContent:char*()<const> */ \nSBuf::rawContent() const\n{\n    ++stats.rawAccess;\n    return buf();\n}\n\n// clear from src/sbuf/MemBlob.h:\n    void clear() { size = 0; } /* <=== MemBlob.clear:void() */ \n\n// pending from src/store_client.cc:\nbool /* <=== store_client.Callback.pending:bool()<const> */ \nstore_client::Callback::pending() const\n{\n    return callback_handler && callback_data;\n}\n\n// xassert from src/debug.cc:\nvoid /* <=== xassert */ \nxassert(const char *msg, const char *file, int line)\n{\n    debugs(0, DBG_CRITICAL, \"assertion failed: \" << file << \":\" << line << \": \\\"\" << msg << \"\\\"\");\n\n    if (!shutting_down)\n        abort();\n}\n\n// NULL from src/sbuf/compat/compat/types.h:\n\n\n// c_str from src/sbuf/SBuf.cc:\nconst char* /* <=== SBuf.c_str:char*() */ \nSBuf::c_str()\n{\n    ++stats.rawAccess;\n    /* null-terminate the current buffer, by hand-appending a \\0 at its tail but\n     * without increasing its length. May COW, the side-effect is to guarantee that\n     * the MemBlob's tail is availabe for us to use */\n    *rawSpace(1) = '\\0';\n    ++store_->size;\n    ++stats.setChar;\n    ++stats.nulTerminate;\n    return buf();\n}\n\n// PROF_start from src/profiler/Profiler.h:\n\n\n// LOCAL_ARRAY from src/leakcheck.h:\n\n\n// GetStorePrototype from src/sbuf/SBuf.cc:\nMemBlob::Pointer /* <=== SBuf.GetStorePrototype:RefCount() */ \nSBuf::GetStorePrototype()\n{\n    static MemBlob::Pointer InitialStore = new MemBlob(0);\n    return InitialStore;\n}\n"
  },
  {
    "repository": "lua",
    "cve_id": "CVE-2022-33099",
    "cwe_list": [
      "CWE-787"
    ],
    "commit_hash": "42d40581dd919fb134c07027ca1ce0844c670daf",
    "short_hash": "42d40581",
    "vulnerableMethods_before": [
      {
        "filename": "ldebug.c",
        "method_name": "vulnerable_function",
        "raw_code": "l_noret luaG_runerror (lua_State *L, const char *fmt, ...) {\n  CallInfo *ci = L->ci;\n  const char *msg;\n  va_list argp;\n  luaC_checkGC(L);  /* error message uses memory */\n  va_start(argp, fmt);\n  msg = luaO_pushvfstring(L, fmt, argp);  /* format message */\n  va_end(argp);\n  if (isLua(ci))  /* if Lua function, add source:line information */\n    luaG_addinfo(L, msg, ci_func(ci)->p->source, getcurrentline(ci));\n  luaG_errormsg(L);\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "None",
        "method_name": "fixed_function",
        "raw_code": "l_noret luaG_runerror (lua_State *L, const char *fmt, ...) {\n  CallInfo *ci = L->ci;\n  const char *msg;\n  va_list argp;\n  luaC_checkGC(L);  /* error message uses memory */\n  va_start(argp, fmt);\n  msg = luaO_pushvfstring(L, fmt, argp);  /* format message */\n  va_end(argp);\n  if (isLua(ci)) {  /* if Lua function, add source:line information */\n    luaG_addinfo(L, msg, ci_func(ci)->p->source, getcurrentline(ci));\n    setobjs2s(L, L->top - 2, L->top - 1);  /* remove 'msg' from the stack */\n    L->top--;\n  }\n  luaG_errormsg(L);\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"lstate.h\"\n#include \"lobject.h\"\n#include \"lua.h\"\n#include \"lapi.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"lcode.h\"\n#include \"lfunc.h\"\n#include \"lvm.h\"\n#include <stddef.h>\n#include <stdarg.h>\n#include \"ltm.h\"\n#include \"lprefix.h\"\n#include \"ldebug.h\"\n#include <string.h>\n#include \"ldo.h\"\n#include \"lopcodes.h\"\n\n// Type Definitions:\n// Proto:\ntypedef struct Proto {\n  CommonHeader;\n  lu_byte numparams;  /* number of fixed (named) parameters */\n  lu_byte is_vararg;\n  lu_byte maxstacksize;  /* number of registers needed by this function */\n  int sizeupvalues;  /* size of 'upvalues' */\n  int sizek;  /* size of 'k' */\n  int sizecode;\n  int sizelineinfo;\n  int sizep;  /* size of 'p' */\n  int sizelocvars;\n  int sizeabslineinfo;  /* size of 'abslineinfo' */\n  int linedefined;  /* debug information  */\n  int lastlinedefined;  /* debug information  */\n  TValue *k;  /* constants used by the function */\n  Instruction *code;  /* opcodes */\n  struct Proto **p;  /* functions defined inside the function */\n  Upvaldesc *upvalues;  /* upvalue information */\n  ls_byte *lineinfo;  /* information about source lines (debug information) */\n  AbsLineInfo *abslineinfo;  /* idem */\n  LocVar *locvars;  /* information about local variables (debug information) */\n  TString  *source;  /* used for debug information */\n  GCObject *gclist;\n} Proto;\n\n// TValue:\ntypedef struct TValue {\n  TValuefields;\n}\n\n// lua_State:\nstruct lua_State {\n  CommonHeader;\n  lu_byte status;\n  lu_byte allowhook;\n  unsigned short nci;  /* number of items in 'ci' list */\n  StkId top;  /* first free slot in the stack */\n  global_State *l_G;\n  CallInfo *ci;  /* call info for current function */\n  StkId stack_last;  /* end of stack (last element + 1) */\n  StkId stack;  /* stack base */\n  UpVal *openupval;  /* list of open upvalues in this stack */\n  StkId tbclist;  /* list of to-be-closed variables */\n  GCObject *gclist;\n  struct lua_State *twups;  /* list of threads with open upvalues */\n  struct lua_longjmp *errorJmp;  /* current error recover point */\n  CallInfo base_ci;  /* CallInfo for first level (C calling Lua) */\n  volatile lua_Hook hook;\n  ptrdiff_t errfunc;  /* current error handling function (stack index) */\n  l_uint32 nCcalls;  /* number of nested (non-yieldable | C)  calls */\n  int oldpc;  /* last pc traced */\n  int basehookcount;\n  int hookcount;\n  volatile l_signalT hookmask;\n}\n\n// TValue:\ntypedef struct TValue {\n  TValuefields;\n} TValue;\n\n// CallInfo:\ntypedef struct CallInfo {\n  StkId func;  /* function index in the stack */\n  StkId\ttop;  /* top for this function */\n  struct CallInfo *previous, *next;  /* dynamic call link */\n  union {\n    struct {  /* only for Lua functions */\n      const Instruction *savedpc;\n      volatile l_signalT trap;\n      int nextraargs;  /* # of extra arguments in vararg functions */\n    } l;\n    struct {  /* only for C functions */\n      lua_KFunction k;  /* continuation in case of yields */\n      ptrdiff_t old_errfunc;\n      lua_KContext ctx;  /* context info. in case of yields */\n    } c;\n  } u;\n  union {\n    int funcidx;  /* called-function index */\n    int nyield;  /* number of values yielded */\n    int nres;  /* number of values returned */\n    struct {  /* info about transferred values (for call/return hooks) */\n      unsigned short ftransfer;  /* offset of first value transferred */\n      unsigned short ntransfer;  /* number of values transferred */\n    } transferinfo;\n  } u2;\n  short nresults; ...\n\n// lua_State:\nstruct lua_State\n\n// Called Methods (top 10):\n// getcurrentline from ldebug.c:\nstatic int getcurrentline (CallInfo *ci) {\n  return luaG_getfuncline(ci_func(ci)->p, currentpc(ci));\n}\n\n// restorestack from ldo.h:\n\n\n// ccall from ldo.c:\n\n\n// luaC_checkGC from lgc.h:\n<empty>\n\n// tsslen from lobject.h:\n\n\n// LUA_IDSIZE from luaconf.h:\n\n\n// addstr from lobject.c:\n\n\n// luaE_resetthread from lstate.c:\n\n\n// isLua from lstate.h:\n<empty>\n\n// luaO_pushvfstring from lobject.c:\n\n"
  },
  {
    "repository": "curl",
    "cve_id": "CVE-2018-16842",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "70b1900dd13d16f2e83f571407a614541d5ac9ba",
    "short_hash": "70b1900d",
    "vulnerableMethods_before": [
      {
        "filename": "main.c",
        "method_name": "vulnerable_function",
        "raw_code": "static void warnf(struct Configurable *config, const char *fmt, ...)\n{\n  if(!(config->conf & CONF_MUTE)) {\n    va_list ap;\n    int len;\n    char *ptr;\n    char print_buffer[256];\n\n    va_start(ap, fmt);\n    va_start(ap, fmt);\n    len = vsnprintf(print_buffer, sizeof(print_buffer), fmt, ap);\n    va_end(ap);\n\n    ptr = print_buffer;\n    while(len > 0) {\n      fputs(WARN_PREFIX, config->errors);\n\n      if(len > (int)WARN_TEXTWIDTH) {\n        int cut = WARN_TEXTWIDTH-1;\n\n        while(!ISSPACE(ptr[cut]) && cut) {\n          cut--;\n        }\n\n        fwrite(ptr, cut + 1, 1, config->errors);\n        fputs(\"\\n\", config->errors);\n        ptr += cut+1; /* skip the space too */\n        len -= cut;\n      }\n      else {\n        fputs(ptr, config->errors);\n        len = 0;\n      }\n    }\n  }\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "main.c",
        "method_name": "fixed_function",
        "raw_code": "static void warnf(struct Configurable *config, const char *fmt, ...)\n{\n  if(!(config->conf & CONF_MUTE)) {\n    va_list ap;\n    int len;\n    char *ptr;\n    char print_buffer[256];\n\n    va_start(ap, fmt);\n    va_start(ap, fmt);\n    len = vsnprintf(print_buffer, sizeof(print_buffer), fmt, ap);\n    va_end(ap);\n\n    ptr = print_buffer;\n    while(len > 0) {\n      fputs(WARN_PREFIX, config->errors);\n\n      if(len > (int)WARN_TEXTWIDTH) {\n        int cut = WARN_TEXTWIDTH-1;\n\n        while(!ISSPACE(ptr[cut]) && cut) {\n          cut--;\n        }\n        if(0 == cut)\n          /* not a single cutting position was found, just cut it at the\n             max text width then! */\n          cut = WARN_TEXTWIDTH-1;\n\n        fwrite(ptr, cut + 1, 1, config->errors);\n        fputs(\"\\n\", config->errors);\n        ptr += cut+1; /* skip the space too */\n        len -= cut;\n      }\n      else {\n        fputs(ptr, config->errors);\n        len = 0;\n      }\n    }\n  }\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <iconv.h>\n#include <ctype.h>\n#include <utime.h>\n#include <dos.h>\n#include <io.h>\n#include <sys/poll.h>\n#include <errno.h>\n#include <locale.h>\n#include \"version.h\"\n#include <screen.h>\n#include \"curlutil.h\"\n#include <sys/stat.h>\n#include \"writeout.h\"\n#include <limits.h>\n#include <direct.h>\n#include <curl/curl.h>\n#include <string.h>\n#include \"setup.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/utime.h>\n#include <stdarg.h>\n#include \"curlmsg_vms.h\"\n#include \"homedir.h\"\n#include \"hugehelp.h\"\n#include \"urlglob.h\"\n#include \"writeenv.h\"\n#include <curlx.h>\n#include \"getpass.h\"\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"memdebug.h\"\n\n// Type Definitions:\n// Configurable:\nstruct Configurable {\n  bool remote_time;\n  char *random_file;\n  char *egd_file;\n  char *useragent;\n  char *cookie;     /* single line with specified cookies */\n  char *cookiejar;  /* write to this file */\n  char *cookiefile; /* read from this file */\n  bool cookiesession; /* new session? */\n  bool encoding;    /* Accept-Encoding please */\n  long authtype;    /* auth bitmask */\n  bool use_resume;\n  bool resume_from_current;\n  bool disable_epsv;\n  bool disable_eprt;\n  curl_off_t resume_from;\n  char *postfields;\n  long postfieldsize;\n  char *referer;\n  long timeout;\n  long connecttimeout;\n  long maxredirs;\n  curl_off_t max_filesize;\n  char *headerfile;\n  char *ftpport;\n  char *iface;\n  int localport;\n  int localportrange;\n  unsigned short porttouse;\n  char *range;\n  long low_speed_limit;\n  long low_speed_time;\n  bool showerror;\n  char *userpwd;\n  char *proxyuserpwd;\n  char *proxy;\n  bool proxytunnel;\n  long conf;\n  struct getout *url_list; /* point to the first node */\n  struct getout...\n\n// Configurable:\nstruct Configurable\n\n// Called Methods (top 10):\n// WARN_TEXTWIDTH from src/main.c:\n<empty>\n\n// ISSPACE from src/setup_once.h:\n<empty>\n\n// fwrite from include/curl/stdcheaders.h:\nsize_t fwrite (const void *, size_t, size_t, FILE *);\n\n// WARN_PREFIX from src/main.c:\n<empty>\n\n// CONF_MUTE from src/main.c:\n<empty>\n"
  },
  {
    "repository": "linux",
    "cve_id": "CVE-2022-3078",
    "cwe_list": [
      "CWE-476"
    ],
    "commit_hash": "e6a21a14106d9718aa4f8e115b1e474888eeba44",
    "short_hash": "e6a21a14",
    "vulnerableMethods_before": [
      {
        "filename": "vidtv_s302m.c",
        "method_name": "vulnerable_function",
        "raw_code": "*vidtv_s302m_encoder_init(struct vidtv_s302m_encoder_init_args args)\n{\n\tu32 priv_sz = sizeof(struct vidtv_s302m_ctx);\n\tstruct vidtv_s302m_ctx *ctx;\n\tstruct vidtv_encoder *e;\n\n\te = kzalloc(sizeof(*e), GFP_KERNEL);\n\tif (!e)\n\t\treturn NULL;\n\n\te->id = S302M;\n\n\tif (args.name)\n\t\te->name = kstrdup(args.name, GFP_KERNEL);\n\n\te->encoder_buf = vzalloc(VIDTV_S302M_BUF_SZ);\n\te->encoder_buf_sz = VIDTV_S302M_BUF_SZ;\n\te->encoder_buf_offset = 0;\n\n\te->sample_count = 0;\n\n\te->src_buf = (args.src_buf) ? args.src_buf : NULL;\n\te->src_buf_sz = (args.src_buf) ? args.src_buf_sz : 0;\n\te->src_buf_offset = 0;\n\n\te->is_video_encoder = false;\n\n\tctx = kzalloc(priv_sz, GFP_KERNEL);\n\tif (!ctx) {\n\t\tkfree(e);\n\t\treturn NULL;\n\t}\n\n\te->ctx = ctx;\n\tctx->last_duration = 0;\n\n\te->encode = vidtv_s302m_encode;\n\te->clear = vidtv_s302m_clear;\n\n\te->es_pid = cpu_to_be16(args.es_pid);\n\te->stream_id = cpu_to_be16(PES_PRIVATE_STREAM_1);\n\n\te->sync = args.sync;\n\te->sampling_rate_hz = S302M_SAMPLING_RATE_HZ;\n\n\te->last_sample_cb = args.last_sample_cb;\n\n\te->destroy = vidtv_s302m_encoder_destroy;\n\n\tif (args.head) {\n\t\twhile (args.head->next)\n\t\t\targs.head = args.head->next;\n\n\t\targs.head->next = e;\n\t}\n\n\te->next = NULL;\n\n\treturn e;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "vidtv_s302m.c",
        "method_name": "fixed_function",
        "raw_code": "*vidtv_s302m_encoder_init(struct vidtv_s302m_encoder_init_args args)\n{\n\tu32 priv_sz = sizeof(struct vidtv_s302m_ctx);\n\tstruct vidtv_s302m_ctx *ctx;\n\tstruct vidtv_encoder *e;\n\n\te = kzalloc(sizeof(*e), GFP_KERNEL);\n\tif (!e)\n\t\treturn NULL;\n\n\te->id = S302M;\n\n\tif (args.name)\n\t\te->name = kstrdup(args.name, GFP_KERNEL);\n\n\te->encoder_buf = vzalloc(VIDTV_S302M_BUF_SZ);\n\tif (!e->encoder_buf)\n\t\tgoto out_kfree_e;\n\n\te->encoder_buf_sz = VIDTV_S302M_BUF_SZ;\n\te->encoder_buf_offset = 0;\n\n\te->sample_count = 0;\n\n\te->src_buf = (args.src_buf) ? args.src_buf : NULL;\n\te->src_buf_sz = (args.src_buf) ? args.src_buf_sz : 0;\n\te->src_buf_offset = 0;\n\n\te->is_video_encoder = false;\n\n\tctx = kzalloc(priv_sz, GFP_KERNEL);\n\tif (!ctx)\n\t\tgoto out_kfree_buf;\n\n\te->ctx = ctx;\n\tctx->last_duration = 0;\n\n\te->encode = vidtv_s302m_encode;\n\te->clear = vidtv_s302m_clear;\n\n\te->es_pid = cpu_to_be16(args.es_pid);\n\te->stream_id = cpu_to_be16(PES_PRIVATE_STREAM_1);\n\n\te->sync = args.sync;\n\te->sampling_rate_hz = S302M_SAMPLING_RATE_HZ;\n\n\te->last_sample_cb = args.last_sample_cb;\n\n\te->destroy = vidtv_s302m_encoder_destroy;\n\n\tif (args.head) {\n\t\twhile (args.head->next)\n\t\t\targs.head = args.head->next;\n\n\t\targs.head->next = e;\n\t}\n\n\te->next = NULL;\n\n\treturn e;\n\nout_kfree_buf:\n\tkfree(e->encoder_buf);\n\nout_kfree_e:\n\tkfree(e->name);\n\tkfree(e);\n\treturn NULL;\n}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "net",
    "cve_id": "CVE-2017-5897",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "7892032cfe67f4bde6fc2ee967e45a8fbaf33756",
    "short_hash": "7892032c",
    "vulnerableMethods_before": [
      {
        "filename": "ip6_gre.c",
        "method_name": "vulnerable_function",
        "raw_code": "static void ip6gre_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\tu8 type, u8 code, int offset, __be32 info)\n{\n\tconst struct ipv6hdr *ipv6h = (const struct ipv6hdr *)skb->data;\n\t__be16 *p = (__be16 *)(skb->data + offset);\n\tint grehlen = offset + 4;\n\tstruct ip6_tnl *t;\n\t__be16 flags;\n\n\tflags = p[0];\n\tif (flags&(GRE_CSUM|GRE_KEY|GRE_SEQ|GRE_ROUTING|GRE_VERSION)) {\n\t\tif (flags&(GRE_VERSION|GRE_ROUTING))\n\t\t\treturn;\n\t\tif (flags&GRE_KEY) {\n\t\t\tgrehlen += 4;\n\t\t\tif (flags&GRE_CSUM)\n\t\t\t\tgrehlen += 4;\n\t\t}\n\t}\n\n\t/* If only 8 bytes returned, keyed message will be dropped here */\n\tif (!pskb_may_pull(skb, grehlen))\n\t\treturn;\n\tipv6h = (const struct ipv6hdr *)skb->data;\n\tp = (__be16 *)(skb->data + offset);\n\n\tt = ip6gre_tunnel_lookup(skb->dev, &ipv6h->daddr, &ipv6h->saddr,\n\t\t\t\tflags & GRE_KEY ?\n\t\t\t\t*(((__be32 *)p) + (grehlen / 4) - 1) : 0,\n\t\t\t\tp[1]);\n\tif (!t)\n\t\treturn;\n\n\tswitch (type) {\n\t\t__u32 teli;\n\t\tstruct ipv6_tlv_tnl_enc_lim *tel;\n\t\t__u32 mtu;\n\tcase ICMPV6_DEST_UNREACH:\n\t\tnet_dbg_ratelimited(\"%s: Path to destination invalid or inactive!\\n\",\n\t\t\t\t    t->parms.name);\n\t\tbreak;\n\tcase ICMPV6_TIME_EXCEED:\n\t\tif (code == ICMPV6_EXC_HOPLIMIT) {\n\t\t\tnet_dbg_ratelimited(\"%s: Too small hop limit or routing loop in tunnel!\\n\",\n\t\t\t\t\t    t->parms.name);\n\t\t}\n\t\tbreak;\n\tcase ICMPV6_PARAMPROB:\n\t\tteli = 0;\n\t\tif (code == ICMPV6_HDR_FIELD)\n\t\t\tteli = ip6_tnl_parse_tlv_enc_lim(skb, skb->data);\n\n\t\tif (teli && teli == be32_to_cpu(info) - 2) {\n\t\t\ttel = (struct ipv6_tlv_tnl_enc_lim *) &skb->data[teli];\n\t\t\tif (tel->encap_limit == 0) {\n\t\t\t\tnet_dbg_ratelimited(\"%s: Too small encapsulation limit or routing loop in tunnel!\\n\",\n\t\t\t\t\t\t    t->parms.name);\n\t\t\t}\n\t\t} else {\n\t\t\tnet_dbg_ratelimited(\"%s: Recipient unable to parse tunneled packet!\\n\",\n\t\t\t\t\t    t->parms.name);\n\t\t}\n\t\tbreak;\n\tcase ICMPV6_PKT_TOOBIG:\n\t\tmtu = be32_to_cpu(info) - offset;\n\t\tif (mtu < IPV6_MIN_MTU)\n\t\t\tmtu = IPV6_MIN_MTU;\n\t\tt->dev->mtu = mtu;\n\t\tbreak;\n\t}\n\n\tif (time_before(jiffies, t->err_time + IP6TUNNEL_ERR_TIMEO))\n\t\tt->err_count++;\n\telse\n\t\tt->err_count = 1;\n\tt->err_time = jiffies;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ip6_gre.c",
        "method_name": "fixed_function",
        "raw_code": "static void ip6gre_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\t       u8 type, u8 code, int offset, __be32 info)\n{\n\tconst struct gre_base_hdr *greh;\n\tconst struct ipv6hdr *ipv6h;\n\tint grehlen = sizeof(*greh);\n\tstruct ip6_tnl *t;\n\tint key_off = 0;\n\t__be16 flags;\n\t__be32 key;\n\n\tif (!pskb_may_pull(skb, offset + grehlen))\n\t\treturn;\n\tgreh = (const struct gre_base_hdr *)(skb->data + offset);\n\tflags = greh->flags;\n\tif (flags & (GRE_VERSION | GRE_ROUTING))\n\t\treturn;\n\tif (flags & GRE_CSUM)\n\t\tgrehlen += 4;\n\tif (flags & GRE_KEY) {\n\t\tkey_off = grehlen + offset;\n\t\tgrehlen += 4;\n\t}\n\n\tif (!pskb_may_pull(skb, offset + grehlen))\n\t\treturn;\n\tipv6h = (const struct ipv6hdr *)skb->data;\n\tgreh = (const struct gre_base_hdr *)(skb->data + offset);\n\tkey = key_off ? *(__be32 *)(skb->data + key_off) : 0;\n\n\tt = ip6gre_tunnel_lookup(skb->dev, &ipv6h->daddr, &ipv6h->saddr,\n\t\t\t\t key, greh->protocol);\n\tif (!t)\n\t\treturn;\n\n\tswitch (type) {\n\t\t__u32 teli;\n\t\tstruct ipv6_tlv_tnl_enc_lim *tel;\n\t\t__u32 mtu;\n\tcase ICMPV6_DEST_UNREACH:\n\t\tnet_dbg_ratelimited(\"%s: Path to destination invalid or inactive!\\n\",\n\t\t\t\t    t->parms.name);\n\t\tbreak;\n\tcase ICMPV6_TIME_EXCEED:\n\t\tif (code == ICMPV6_EXC_HOPLIMIT) {\n\t\t\tnet_dbg_ratelimited(\"%s: Too small hop limit or routing loop in tunnel!\\n\",\n\t\t\t\t\t    t->parms.name);\n\t\t}\n\t\tbreak;\n\tcase ICMPV6_PARAMPROB:\n\t\tteli = 0;\n\t\tif (code == ICMPV6_HDR_FIELD)\n\t\t\tteli = ip6_tnl_parse_tlv_enc_lim(skb, skb->data);\n\n\t\tif (teli && teli == be32_to_cpu(info) - 2) {\n\t\t\ttel = (struct ipv6_tlv_tnl_enc_lim *) &skb->data[teli];\n\t\t\tif (tel->encap_limit == 0) {\n\t\t\t\tnet_dbg_ratelimited(\"%s: Too small encapsulation limit or routing loop in tunnel!\\n\",\n\t\t\t\t\t\t    t->parms.name);\n\t\t\t}\n\t\t} else {\n\t\t\tnet_dbg_ratelimited(\"%s: Recipient unable to parse tunneled packet!\\n\",\n\t\t\t\t\t    t->parms.name);\n\t\t}\n\t\tbreak;\n\tcase ICMPV6_PKT_TOOBIG:\n\t\tmtu = be32_to_cpu(info) - offset;\n\t\tif (mtu < IPV6_MIN_MTU)\n\t\t\tmtu = IPV6_MIN_MTU;\n\t\tt->dev->mtu = mtu;\n\t\tbreak;\n\t}\n\n\tif (time_before(jiffies, t->err_time + IP6TUNNEL_ERR_TIMEO))\n\t\tt->err_count++;\n\telse\n\t\tt->err_count = 1;\n\tt->err_time = jiffies;\n}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "wolfMQTT",
    "cve_id": "CVE-2021-45936",
    "cwe_list": [
      "CWE-787"
    ],
    "commit_hash": "84d4b53122e0fa0280c7872350b89d5777dabbb2",
    "short_hash": "84d4b531",
    "vulnerableMethods_before": [
      {
        "filename": "mqtt_client.c",
        "method_name": "vulnerable_function",
        "raw_code": "static int MqttClient_WaitType(MqttClient *client, void *packet_obj,\n    byte wait_type, word16 wait_packet_id, int timeout_ms)\n{\n    int rc;\n    word16 packet_id;\n    MqttPacketType packet_type;\n#ifdef WOLFMQTT_MULTITHREAD\n    MqttPendResp *pendResp;\n    int readLocked;\n#endif\n    MqttMsgStat* mms_stat;\n    int waitMatchFound;\n\n    if (client == NULL || packet_obj == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* all packet type structures must have MqttMsgStat at top */\n    mms_stat = (MqttMsgStat*)packet_obj;\n\nwait_again:\n\n    /* initialize variables */\n    packet_id = 0;\n    packet_type = MQTT_PACKET_TYPE_RESERVED;\n#ifdef WOLFMQTT_MULTITHREAD\n    pendResp = NULL;\n    readLocked = 0;\n#endif\n    waitMatchFound = 0;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_WaitType: Type %s (%d), ID %d\",\n        MqttPacket_TypeDesc((MqttPacketType)wait_type),\n            wait_type, wait_packet_id);\n#endif\n\n    switch ((int)*mms_stat)\n    {\n        case MQTT_MSG_BEGIN:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock recv socket mutex */\n            rc = wm_SemLock(&client->lockRecv);\n            if (rc != 0) {\n                PRINTF(\"MqttClient_WaitType: recv lock error!\");\n                return rc;\n            }\n            readLocked = 1;\n        #endif\n\n            /* reset the packet state */\n            client->packet.stat = MQTT_PK_BEGIN;\n        }\n        FALL_THROUGH;\n\n    #ifdef WOLFMQTT_V5\n        case MQTT_MSG_AUTH:\n    #endif\n        case MQTT_MSG_WAIT:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if packet type and id have already completed */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, (MqttPacketType)wait_type, \n                    wait_packet_id, &pendResp)) {\n                    if (pendResp->packetDone) {\n                        /* pending response is already done, so return */\n                        rc = pendResp->packet_ret;\n                    #ifdef WOLFMQTT_DEBUG_CLIENT\n                        PRINTF(\"PendResp already Done %p: Rc %d\", pendResp, rc);\n                    #endif\n                        MqttClient_RespList_Remove(client, pendResp);\n                        wm_SemUnlock(&client->lockClient);\n                        wm_SemUnlock(&client->lockRecv);\n                        return rc;\n                    }\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            *mms_stat = MQTT_MSG_WAIT;\n\n            /* Wait for packet */\n            rc = MqttPacket_Read(client, client->rx_buf, client->rx_buf_len,\n                    timeout_ms);\n            /* handle failure */\n            if (rc <= 0) {\n                break;\n            }\n\n            /* capture length read */\n            client->packet.buf_len = rc;\n\n            /* Decode Packet - get type and id */\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, NULL, &packet_type, NULL, &packet_id);\n            if (rc < 0) {\n                break;\n            }\n\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"Read Packet: Len %d, Type %d, ID %d\",\n                client->packet.buf_len, packet_type, packet_id);\n        #endif\n\n            *mms_stat = MQTT_MSG_READ;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_READ:\n        case MQTT_MSG_READ_PAYLOAD:\n        {\n            MqttPacketType use_packet_type;\n            void* use_packet_obj;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            readLocked = 1; /* if in this state read is locked */\n        #endif\n\n            /* read payload state only happens for publish messages */\n            if (*mms_stat == MQTT_MSG_READ_PAYLOAD) {\n                packet_type = MQTT_PACKET_TYPE_PUBLISH;\n            }\n\n            /* Determine if we received data for this request */\n            if ((wait_type == MQTT_PACKET_TYPE_ANY ||\n                 wait_type == packet_type ||\n                 MqttIsPubRespPacket(packet_type) == MqttIsPubRespPacket(wait_type)) &&\n               (wait_packet_id == 0 || wait_packet_id == packet_id))\n            {\n                use_packet_obj = packet_obj;\n                waitMatchFound = 1;\n            }\n            else {\n                /* use generic packet object */\n                use_packet_obj = &client->msg;\n            }\n            use_packet_type = packet_type;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if we have a pending response for this packet */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, packet_type, packet_id,\n                                                               &pendResp)) {\n                    /* we found packet match this incoming read packet */\n                    pendResp->packetProcessing = 1;\n                    use_packet_obj = pendResp->packet_obj;\n                    use_packet_type = pendResp->packet_type;\n                    /* req from another thread... not a match */\n                    waitMatchFound = 0;\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            /* Perform packet handling for publish callback and QoS */\n            rc = MqttClient_HandlePacket(client, use_packet_type,\n                use_packet_obj, timeout_ms);\n\n        #ifdef WOLFMQTT_NONBLOCK\n            if (rc == MQTT_CODE_CONTINUE) {\n                /* we have received some data, so keep the recv\n                    mutex lock active and return */\n                return rc;\n            }\n        #endif\n\n            /* handle success case */\n            if (rc >= 0) {\n                rc = MQTT_CODE_SUCCESS;\n            }\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (pendResp) {\n                /* Mark pending response entry done */\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    pendResp->packetDone = 1;\n                    pendResp->packet_ret = rc;\n                #ifdef WOLFMQTT_DEBUG_CLIENT\n                    PRINTF(\"PendResp Done %p\", pendResp);\n                #endif\n                    pendResp = NULL;\n                    wm_SemUnlock(&client->lockClient);\n                }\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n            break;\n        }\n\n        case MQTT_MSG_WRITE:\n        case MQTT_MSG_WRITE_PAYLOAD:\n        default:\n        {\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_WaitType: Invalid state %d!\", *mms_stat);\n        #endif\n            rc = MQTT_CODE_ERROR_STAT;\n            break;\n        }\n    } /* switch (*mms_stat) */\n\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc != MQTT_CODE_CONTINUE)\n#endif\n    {\n        /* reset state */\n        *mms_stat = MQTT_MSG_BEGIN;\n    }\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (readLocked) {\n        wm_SemUnlock(&client->lockRecv);\n    }\n#endif\n    if (rc < 0) {\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_WaitType: Failure: %s (%d)\",\n            MqttClient_ReturnCodeToString(rc), rc);\n    #endif\n        return rc;\n    }\n\n    if (!waitMatchFound) {\n        /* if we get here, then the we are still waiting for a packet */\n        goto wait_again;\n    }\n\n    return rc;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "mqtt_client.c",
        "method_name": "fixed_function",
        "raw_code": "static int MqttClient_WaitType(MqttClient *client, void *packet_obj,\n    byte wait_type, word16 wait_packet_id, int timeout_ms)\n{\n    int rc;\n    word16 packet_id;\n    MqttPacketType packet_type;\n#ifdef WOLFMQTT_MULTITHREAD\n    MqttPendResp *pendResp;\n    int readLocked;\n#endif\n    MqttMsgStat* mms_stat;\n    int waitMatchFound;\n\n    if (client == NULL || packet_obj == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* all packet type structures must have MqttMsgStat at top */\n    mms_stat = (MqttMsgStat*)packet_obj;\n\nwait_again:\n\n    /* initialize variables */\n    packet_id = 0;\n    packet_type = MQTT_PACKET_TYPE_RESERVED;\n#ifdef WOLFMQTT_MULTITHREAD\n    pendResp = NULL;\n    readLocked = 0;\n#endif\n    waitMatchFound = 0;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_WaitType: Type %s (%d), ID %d\",\n        MqttPacket_TypeDesc((MqttPacketType)wait_type),\n            wait_type, wait_packet_id);\n#endif\n\n    switch ((int)*mms_stat)\n    {\n        case MQTT_MSG_BEGIN:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock recv socket mutex */\n            rc = wm_SemLock(&client->lockRecv);\n            if (rc != 0) {\n                PRINTF(\"MqttClient_WaitType: recv lock error!\");\n                return rc;\n            }\n            readLocked = 1;\n        #endif\n\n            /* reset the packet state */\n            client->packet.stat = MQTT_PK_BEGIN;\n        }\n        FALL_THROUGH;\n\n    #ifdef WOLFMQTT_V5\n        case MQTT_MSG_AUTH:\n    #endif\n        case MQTT_MSG_WAIT:\n        {\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if packet type and id have already completed */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, (MqttPacketType)wait_type, \n                    wait_packet_id, &pendResp)) {\n                    if (pendResp->packetDone) {\n                        /* pending response is already done, so return */\n                        rc = pendResp->packet_ret;\n                    #ifdef WOLFMQTT_DEBUG_CLIENT\n                        PRINTF(\"PendResp already Done %p: Rc %d\", pendResp, rc);\n                    #endif\n                        MqttClient_RespList_Remove(client, pendResp);\n                        wm_SemUnlock(&client->lockClient);\n                        wm_SemUnlock(&client->lockRecv);\n                        return rc;\n                    }\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            *mms_stat = MQTT_MSG_WAIT;\n\n            /* Wait for packet */\n            rc = MqttPacket_Read(client, client->rx_buf, client->rx_buf_len,\n                    timeout_ms);\n            /* handle failure */\n            if (rc <= 0) {\n                break;\n            }\n\n            /* capture length read */\n            client->packet.buf_len = rc;\n\n            /* Decode Packet - get type and id */\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, NULL, &packet_type, NULL, &packet_id);\n            if (rc < 0) {\n                break;\n            }\n\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"Read Packet: Len %d, Type %d, ID %d\",\n                client->packet.buf_len, packet_type, packet_id);\n        #endif\n\n            *mms_stat = MQTT_MSG_READ;\n        }\n        FALL_THROUGH;\n\n        case MQTT_MSG_READ:\n        case MQTT_MSG_READ_PAYLOAD:\n        {\n            MqttPacketType use_packet_type;\n            void* use_packet_obj;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            readLocked = 1; /* if in this state read is locked */\n        #endif\n\n            /* read payload state only happens for publish messages */\n            if (*mms_stat == MQTT_MSG_READ_PAYLOAD) {\n                packet_type = MQTT_PACKET_TYPE_PUBLISH;\n            }\n\n            /* Determine if we received data for this request */\n            if ((wait_type == MQTT_PACKET_TYPE_ANY ||\n                 wait_type == packet_type ||\n                 (MqttIsPubRespPacket(packet_type) &&\n                  MqttIsPubRespPacket(wait_type))) &&\n                (wait_packet_id == 0 || wait_packet_id == packet_id))\n            {\n                use_packet_obj = packet_obj;\n                waitMatchFound = 1;\n            }\n            else {\n                /* use generic packet object */\n                use_packet_obj = &client->msg;\n            }\n            use_packet_type = packet_type;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Check to see if we have a pending response for this packet */\n            pendResp = NULL;\n            rc = wm_SemLock(&client->lockClient);\n            if (rc == 0) {\n                if (MqttClient_RespList_Find(client, packet_type, packet_id,\n                                                               &pendResp)) {\n                    /* we found packet match this incoming read packet */\n                    pendResp->packetProcessing = 1;\n                    use_packet_obj = pendResp->packet_obj;\n                    use_packet_type = pendResp->packet_type;\n                    /* req from another thread... not a match */\n                    waitMatchFound = 0;\n                }\n                wm_SemUnlock(&client->lockClient);\n            }\n            else {\n                break; /* error */\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n\n            /* Perform packet handling for publish callback and QoS */\n            rc = MqttClient_HandlePacket(client, use_packet_type,\n                use_packet_obj, timeout_ms);\n\n        #ifdef WOLFMQTT_NONBLOCK\n            if (rc == MQTT_CODE_CONTINUE) {\n                /* we have received some data, so keep the recv\n                    mutex lock active and return */\n                return rc;\n            }\n        #endif\n\n            /* handle success case */\n            if (rc >= 0) {\n                rc = MQTT_CODE_SUCCESS;\n            }\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            if (pendResp) {\n                /* Mark pending response entry done */\n                if (wm_SemLock(&client->lockClient) == 0) {\n                    pendResp->packetDone = 1;\n                    pendResp->packet_ret = rc;\n                #ifdef WOLFMQTT_DEBUG_CLIENT\n                    PRINTF(\"PendResp Done %p\", pendResp);\n                #endif\n                    pendResp = NULL;\n                    wm_SemUnlock(&client->lockClient);\n                }\n            }\n        #endif /* WOLFMQTT_MULTITHREAD */\n            break;\n        }\n\n        case MQTT_MSG_WRITE:\n        case MQTT_MSG_WRITE_PAYLOAD:\n        default:\n        {\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_WaitType: Invalid state %d!\", *mms_stat);\n        #endif\n            rc = MQTT_CODE_ERROR_STAT;\n            break;\n        }\n    } /* switch (*mms_stat) */\n\n#ifdef WOLFMQTT_NONBLOCK\n    if (rc != MQTT_CODE_CONTINUE)\n#endif\n    {\n        /* reset state */\n        *mms_stat = MQTT_MSG_BEGIN;\n    }\n\n#ifdef WOLFMQTT_MULTITHREAD\n    if (readLocked) {\n        wm_SemUnlock(&client->lockRecv);\n    }\n#endif\n    if (rc < 0) {\n    #ifdef WOLFMQTT_DEBUG_CLIENT\n        PRINTF(\"MqttClient_WaitType: Failure: %s (%d)\",\n            MqttClient_ReturnCodeToString(rc), rc);\n    #endif\n        return rc;\n    }\n\n    if (!waitMatchFound) {\n        /* if we get here, then the we are still waiting for a packet */\n        goto wait_again;\n    }\n\n    return rc;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"wolfmqtt/mqtt_client.h\"\n#include <config.h>\n\n// Type Definitions:\n// byte:\ntypedef unsigned char  byte;\n\n// MqttClient:\ntypedef struct _MqttClient {\n    word32       flags; /* MqttClientFlags */\n    int          cmd_timeout_ms;\n\n    byte        *tx_buf;\n    int          tx_buf_len;\n    byte        *rx_buf;\n    int          rx_buf_len;\n\n    MqttNet     *net;   /* Pointer to network callbacks and context */\n#ifdef ENABLE_MQTT_TLS\n    MqttTls      tls;   /* WolfSSL context for TLS */\n#endif\n\n    MqttPkRead   packet;\n    MqttSk       read;\n    MqttSk       write;\n\n    MqttMsgCb    msg_cb;\n    MqttObject   msg;   /* generic incoming message used by MqttClient_WaitType */\n#ifdef WOLFMQTT_SN\n    SN_Object    msgSN;\n    SN_ClientRegisterCb reg_cb;\n    void               *reg_ctx;\n#endif\n    void*        ctx;   /* user supplied context for publish callbacks */\n\n#ifdef WOLFMQTT_V5\n    word32  packet_sz_max; /* Server property */\n    byte    max_qos;       /* Server property */\n    byte    retain_avail;  /* Server property */\n    byte    enable_eauth;  /* Enhanced authentication */\n    byte protocol_level;\n#end...\n\n// MqttPacketType:\ntypedef enum _MqttPacketType {\n    MQTT_PACKET_TYPE_RESERVED = 0,\n    MQTT_PACKET_TYPE_CONNECT = 1,\n    MQTT_PACKET_TYPE_CONNECT_ACK = 2,       /* Acknowledgment */\n    MQTT_PACKET_TYPE_PUBLISH = 3,\n    MQTT_PACKET_TYPE_PUBLISH_ACK = 4,       /* Acknowledgment */\n    MQTT_PACKET_TYPE_PUBLISH_REC = 5,       /* Received */\n    MQTT_PACKET_TYPE_PUBLISH_REL= 6,        /* Release */\n    MQTT_PACKET_TYPE_PUBLISH_COMP = 7,      /* Complete */\n    MQTT_PACKET_TYPE_SUBSCRIBE = 8,\n    MQTT_PACKET_TYPE_SUBSCRIBE_ACK = 9,     /* Acknowledgment */\n    MQTT_PACKET_TYPE_UNSUBSCRIBE = 10,\n    MQTT_PACKET_TYPE_UNSUBSCRIBE_ACK = 11,  /* Acknowledgment */\n    MQTT_PACKET_TYPE_PING_REQ = 12,         /* Request */\n    MQTT_PACKET_TYPE_PING_RESP = 13,        /* Response */\n    MQTT_PACKET_TYPE_DISCONNECT = 14,\n    MQTT_PACKET_TYPE_AUTH = 15,             /* Authentication (MQTT 5) */\n    MQTT_PACKET_TYPE_ANY = 16,\n} MqttPacketType;\n\n// MqttMsgStat:\ntypedef enum _MqttMsgStat {\n    MQTT_MSG_BEGIN = 0, /* must be zero, so memset will setup state */\n#ifdef WOLFMQTT_V5\n    MQTT_MSG_AUTH,\n#endif\n    MQTT_MSG_WAIT,\n    MQTT_MSG_WRITE,\n    MQTT_MSG_WRITE_PAYLOAD,\n    MQTT_MSG_READ,\n    MQTT_MSG_READ_PAYLOAD,\n} MqttMsgStat;\n\n// word16:\ntypedef unsigned short word16;\n\n// Called Methods (top 10):\n// MqttDecode_String from src/mqtt_packet.c:\nint MqttDecode_String(byte *buf, const char **pstr, word16 *pstr_len) /* <=== MqttDecode_String */ \n{\n    int len;\n    word16 str_len;\n    len = MqttDecode_Num(buf, &str_len);\n    buf += len;\n    if (pstr_len) {\n        *pstr_len = str_len;\n    }\n    if (pstr) {\n        *pstr = (char*)buf;\n    }\n    return len + str_len;\n}\n\n// MQTT_PACKET_MAX_LEN_BYTES from src/wolfmqtt/mqtt_packet.h:\n\n\n// MQTT_PACKET_FLAGS_GET_QOS from src/wolfmqtt/wolfmqtt/mqtt_packet.h:\n\n\n// MQTT_PACKET_LEN_ENCODE_MASK from src/wolfmqtt/mqtt_packet.h:\n\n\n// MqttSocket_ReadDo from src/mqtt_socket.c:\nstatic int MqttSocket_ReadDo(MqttClient *client, byte* buf, int buf_len, /* <=== MqttSocket_ReadDo */ \n    int timeout_ms)\n{\n    int rc;\n\n#ifdef ENABLE_MQTT_TLS\n    if (client->flags & MQTT_CLIENT_FLAG_IS_TLS) {\n        client->tls.timeout_ms = timeout_ms;\n        rc = wolfSSL_read(client->tls.ssl, (char*)buf, buf_len);\n        if (rc < 0) {\n        #ifdef WOLFMQTT_DEBUG_SOCKET\n            int error = wolfSSL_get_error(client->tls.ssl, 0);\n            if (error != WOLFSSL_ERROR_WANT_READ) {\n                PRINTF(\"MqttSocket_Read: SSL Error=%d\", error);\n            }\n        #endif\n\n            /* return code from net callback */\n            rc = client->tls.sockRc;\n        }\n    }\n    else\n#endif /* ENABLE_MQTT_TLS */\n    {\n        rc = client->net->read(client->net->context, buf, buf_len, timeout_ms);\n    }\n\n#ifdef WOLFMQTT_DEBUG_SOCKET\n    if (rc != 0 && rc != MQTT_CODE_CONTINUE) { /* hide in non-blocking case */\n        PRINTF(\"MqttSocket_Read: Len=%d, Rc=%d\", buf_len, rc);\n    }\n#endif\n\n    return rc;\n}\n\n// MqttDecode_FixedHeader from src/mqtt_packet.c:\nstatic int MqttDecode_FixedHeader(byte *rx_buf, int rx_buf_len, int *remain_len, /* <=== MqttDecode_FixedHeader */ \n    byte type, MqttQoS *p_qos, byte *p_retain, byte *p_duplicate)\n{\n    int header_len;\n    MqttPacket* header = (MqttPacket*)rx_buf;\n\n    /* Decode the length remaining */\n    header_len = MqttDecode_Vbi(header->len, (word32*)remain_len, rx_buf_len);\n    if (header_len < 0) {\n        return header_len;\n    }\n\n    /* Validate packet type */\n    if (MQTT_PACKET_TYPE_GET(header->type_flags) != type) {\n        return MQTT_CODE_ERROR_PACKET_TYPE;\n    }\n\n    /* Extract header flags */\n    if (p_qos) {\n        *p_qos = (MqttQoS)MQTT_PACKET_FLAGS_GET_QOS(header->type_flags);\n    }\n    if (p_retain) {\n        *p_retain = (MQTT_PACKET_FLAGS_GET(header->type_flags) &\n            MQTT_PACKET_FLAG_RETAIN) ? 1 : 0;\n    }\n    if (p_duplicate) {\n        *p_duplicate = (MQTT_PACKET_FLAGS_GET(header->type_flags) &\n            MQTT_PACKET_FLAG_DUPLICATE) ? 1 : 0;\n    }\n\n    header_len += sizeof(header->type_flags); /* Add size of type and flags */\n\n    (void)rx_buf_len;\n\n    return header_len;\n}\n\n// MqttDecode_Num from src/mqtt_packet.c:\nint MqttDecode_Num(byte* buf, word16 *len) /* <=== MqttDecode_Num */ \n{\n    if (len) {\n        *len = buf[0];\n        *len = (*len << 8) | buf[1];\n    }\n    return MQTT_DATA_LEN_SIZE;\n}\n\n// MqttDecode_Ping from src/mqtt_packet.c:\nint MqttDecode_Ping(byte *rx_buf, int rx_buf_len, MqttPing* ping) /* <=== MqttDecode_Ping */ \n{\n    int header_len, remain_len;\n\n    /* Validate required arguments */\n    if (rx_buf == NULL || rx_buf_len <= 0) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* Decode fixed header */\n    header_len = MqttDecode_FixedHeader(rx_buf, rx_buf_len, &remain_len,\n        MQTT_PACKET_TYPE_PING_RESP, NULL, NULL, NULL);\n    if (header_len < 0) {\n        return header_len;\n    }\n\n    if (ping) {\n        /* nothing to decode */\n    }\n\n    /* Return total length of packet */\n    return header_len + remain_len;\n}\n\n// MqttClient_HandlePacket from src/mqtt_client.c:\nstatic int MqttClient_HandlePacket(MqttClient* client, /* <=== MqttClient_HandlePacket */ \n    MqttPacketType packet_type, void *packet_obj, int timeout_ms)\n{\n    int rc = MQTT_CODE_SUCCESS;\n    MqttQoS packet_qos = MQTT_QOS_0;\n    word16 packet_id = 0;\n\n    if (client == NULL || packet_obj == NULL) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    switch (packet_type)\n    {\n        case MQTT_PACKET_TYPE_CONNECT_ACK:\n        {\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, packet_obj, &packet_type, &packet_qos,\n                &packet_id);\n            break;\n        }\n        case MQTT_PACKET_TYPE_PUBLISH:\n        {\n            MqttPublish *publish = (MqttPublish*)packet_obj;\n            MqttPacketType resp_type;\n\n            if (publish->stat == MQTT_MSG_BEGIN ||\n                publish->stat == MQTT_MSG_READ) {\n                rc = MqttClient_DecodePacket(client, client->rx_buf,\n                    client->packet.buf_len, packet_obj, &packet_type,\n                    &packet_qos, &packet_id);\n                if (rc <= 0) {\n                    return rc;\n                }\n            }\n            else {\n                /* packet ID and QoS were already established */\n                packet_id = client->msg.publish.packet_id;\n                packet_qos = client->msg.publish.qos;\n            }\n\n            rc = MqttClient_Publish_ReadPayload(client, publish, timeout_ms);\n            if (rc < 0) {\n                break;\n            }\n\n            /* Handle QoS */\n            if (packet_qos == MQTT_QOS_0) {\n                /* we are done, no QoS response */\n                break;\n            }\n\n            /* Determine packet type to write */\n            resp_type = (packet_qos == MQTT_QOS_1) ?\n                MQTT_PACKET_TYPE_PUBLISH_ACK :\n                MQTT_PACKET_TYPE_PUBLISH_REC;\n            publish->resp.packet_id = packet_id;\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock send socket mutex */\n            rc = wm_SemLock(&client->lockSend);\n            if (rc != 0) {\n                return rc;\n            }\n        #endif\n\n            /* Encode publish response */\n            rc = MqttEncode_PublishResp(client->tx_buf, client->tx_buf_len,\n                resp_type, &publish->resp);\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d,\"\n                    \" QoS %d\",\n                rc, MqttPacket_TypeDesc(resp_type), resp_type, packet_id,\n                packet_qos);\n        #endif\n            if (rc <= 0) {\n            #ifdef WOLFMQTT_MULTITHREAD\n                wm_SemUnlock(&client->lockSend);\n            #endif\n                return rc;\n            }\n            client->packet.buf_len = rc;\n\n            /* Send publish response packet */\n            rc = MqttPacket_Write(client, client->tx_buf,\n                client->packet.buf_len);\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n            break;\n        }\n        case MQTT_PACKET_TYPE_PUBLISH_ACK:\n        case MQTT_PACKET_TYPE_PUBLISH_REC:\n        case MQTT_PACKET_TYPE_PUBLISH_REL:\n        case MQTT_PACKET_TYPE_PUBLISH_COMP:\n        {\n            MqttPublishResp pubRespObj, *publish_resp = &pubRespObj;\n            XMEMSET(publish_resp, 0, sizeof(MqttPublishResp));\n\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, publish_resp, &packet_type,\n                &packet_qos, &packet_id);\n            if (rc <= 0) {\n                return rc;\n            }\n\n            /* If publish Received or Release QoS then proceed */\n            if (packet_type != MQTT_PACKET_TYPE_PUBLISH_REC &&\n                packet_type != MQTT_PACKET_TYPE_PUBLISH_REL) {\n                break;\n            }\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            /* Lock send socket mutex */\n            rc = wm_SemLock(&client->lockSend);\n            if (rc != 0) {\n                return rc;\n            }\n        #endif\n\n            /* Encode publish response */\n            publish_resp->packet_id = packet_id;\n            packet_type = (MqttPacketType)((int)packet_type+1); /* next ack */\n        #ifdef WOLFMQTT_V5\n            #ifdef WOLFMQTT_DEBUG_CLIENT\n                PRINTF(\"\\tPublish response: reason code %d, Type %s (%d),\"\n                        \" ID %d, QoS %d\",\n                        publish_resp->reason_code,\n                        MqttPacket_TypeDesc(packet_type),\n                        packet_type, packet_id, packet_qos);\n            #endif\n\n            /* return reason code to caller */\n            if (packet_obj != NULL) {\n                MqttPublishResp* caller_rsp = (MqttPublishResp*)packet_obj;\n                caller_rsp->reason_code = publish_resp->reason_code;\n            }\n\n            /* Publish QoS response needs success reason code,\n             * otherwise will cause disconnect at broker */\n            publish_resp->reason_code = MQTT_REASON_SUCCESS;\n        #endif\n\n            rc = MqttEncode_PublishResp(client->tx_buf, client->tx_buf_len,\n                packet_type, publish_resp);\n        #ifdef WOLFMQTT_DEBUG_CLIENT\n            PRINTF(\"MqttClient_EncodePacket: Len %d, Type %s (%d), ID %d,\"\n                    \" QoS %d\",\n                rc, MqttPacket_TypeDesc(packet_type), packet_type, packet_id,\n                packet_qos);\n        #endif\n            if (rc <= 0) {\n            #ifdef WOLFMQTT_MULTITHREAD\n                wm_SemUnlock(&client->lockSend);\n            #endif\n                return rc;\n            }\n            client->packet.buf_len = rc;\n\n            /* Send publish response packet */\n            rc = MqttPacket_Write(client, client->tx_buf,\n                client->packet.buf_len);\n\n        #ifdef WOLFMQTT_MULTITHREAD\n            wm_SemUnlock(&client->lockSend);\n        #endif\n            break;\n        }\n        case MQTT_PACKET_TYPE_SUBSCRIBE_ACK:\n        {\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, packet_obj, &packet_type, &packet_qos,\n                &packet_id);\n            break;\n        }\n        case MQTT_PACKET_TYPE_UNSUBSCRIBE_ACK:\n        {\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, packet_obj, &packet_type, &packet_qos,\n                &packet_id);\n            break;\n        }\n        case MQTT_PACKET_TYPE_PING_RESP:\n        {\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, packet_obj, &packet_type, &packet_qos,\n                &packet_id);\n            break;\n        }\n        case MQTT_PACKET_TYPE_AUTH:\n        {\n        #ifdef WOLFMQTT_V5\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, packet_obj, &packet_type, &packet_qos,\n                &packet_id);\n        #else\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n        #endif\n            break;\n        }\n\n        case MQTT_PACKET_TYPE_DISCONNECT:\n        {\n        #ifdef WOLFMQTT_V5\n            rc = MqttClient_DecodePacket(client, client->rx_buf,\n                client->packet.buf_len, packet_obj, &packet_type, &packet_qos,\n                &packet_id);\n        #else\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n        #endif\n            break;\n        }\n        case MQTT_PACKET_TYPE_CONNECT:\n        case MQTT_PACKET_TYPE_SUBSCRIBE:\n        case MQTT_PACKET_TYPE_UNSUBSCRIBE:\n        case MQTT_PACKET_TYPE_PING_REQ:\n        case MQTT_PACKET_TYPE_ANY:\n        case MQTT_PACKET_TYPE_RESERVED:\n        default:\n            /* these types are only sent from client and should not be sent\n             * by broker */\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n            break;\n    } /* switch (packet_type) */\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    if (rc < 0) {\n        PRINTF(\"MqttClient_HandlePacket: Rc %d, Type %s (%d), QoS %d, ID %d\",\n            rc, MqttPacket_TypeDesc(packet_type), packet_type, packet_qos,\n            packet_id);\n    }\n#endif\n\n    return rc;\n}\n\n// MqttClient_DecodePacket from src/mqtt_client.c:\nstatic int MqttClient_DecodePacket(MqttClient* client, byte* rx_buf, /* <=== MqttClient_DecodePacket */ \n    word32 rx_len, void *packet_obj, MqttPacketType* ppacket_type,\n    MqttQoS* ppacket_qos, word16* ppacket_id)\n{\n    int rc = MQTT_CODE_SUCCESS;\n    MqttPacket* header;\n    MqttPacketType packet_type;\n    MqttQoS packet_qos;\n    word16 packet_id = 0;\n#ifdef WOLFMQTT_V5\n    MqttProp* props = NULL;\n#endif\n\n    /* must have rx buffer with at least 2 byes for header */\n    if (rx_buf == NULL || rx_len < MQTT_PACKET_HEADER_MIN_SIZE) {\n        return MQTT_CODE_ERROR_BAD_ARG;\n    }\n\n    /* Decode header */\n    header = (MqttPacket*)rx_buf;\n    packet_type = (MqttPacketType)MQTT_PACKET_TYPE_GET(header->type_flags);\n    if (ppacket_type) {\n        *ppacket_type = packet_type;\n    }\n    packet_qos = (MqttQoS)MQTT_PACKET_FLAGS_GET_QOS(header->type_flags);\n    if (ppacket_qos) {\n        *ppacket_qos = packet_qos;\n    }\n\n    /* Decode packet specific data (if requested) */\n    if (ppacket_id || packet_obj) {\n        switch (packet_type) {\n        case MQTT_PACKET_TYPE_CONNECT_ACK:\n        {\n            MqttConnectAck connect_ack, *p_connect_ack = &connect_ack;\n            if (packet_obj) {\n                p_connect_ack = (MqttConnectAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_connect_ack, 0, sizeof(MqttConnectAck));\n            }\n        #ifdef WOLFMQTT_V5\n            p_connect_ack->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_ConnectAck(rx_buf, rx_len, p_connect_ack);\n        #ifdef WOLFMQTT_V5\n            if (rc >= 0) {\n                props = p_connect_ack->props;\n            }\n        #endif\n            break;\n        }\n        case MQTT_PACKET_TYPE_PUBLISH:\n        {\n            MqttPublish publish, *p_publish = &publish;\n            if (packet_obj) {\n                p_publish = (MqttPublish*)packet_obj;\n            }\n            else {\n                XMEMSET(p_publish, 0, sizeof(MqttPublish));\n            }\n        #ifdef WOLFMQTT_V5\n            p_publish->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_Publish(rx_buf, rx_len, p_publish);\n            if (rc >= 0) {\n                packet_id = p_publish->packet_id;\n            #ifdef WOLFMQTT_V5\n                props = p_publish->props;\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_PUBLISH_ACK:\n        case MQTT_PACKET_TYPE_PUBLISH_REC:\n        case MQTT_PACKET_TYPE_PUBLISH_REL:\n        case MQTT_PACKET_TYPE_PUBLISH_COMP:\n        {\n            MqttPublishResp publish_resp, *p_publish_resp = &publish_resp;\n            if (packet_obj) {\n                p_publish_resp = (MqttPublishResp*)packet_obj;\n            }\n            else {\n                XMEMSET(p_publish_resp, 0, sizeof(MqttPublishResp));\n            }\n        #ifdef WOLFMQTT_V5\n                p_publish_resp->protocol_level = client->protocol_level;\n        #endif\n                rc = MqttDecode_PublishResp(rx_buf, rx_len, packet_type,\n                p_publish_resp);\n            if (rc >= 0) {\n                packet_id = p_publish_resp->packet_id;\n            #ifdef WOLFMQTT_V5\n                props = p_publish_resp->props;\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_SUBSCRIBE_ACK:\n        {\n            MqttSubscribeAck subscribe_ack, *p_subscribe_ack = &subscribe_ack;\n            if (packet_obj) {\n                p_subscribe_ack = (MqttSubscribeAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_subscribe_ack, 0, sizeof(MqttSubscribeAck));\n            }\n        #ifdef WOLFMQTT_V5\n            p_subscribe_ack->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_SubscribeAck(rx_buf, rx_len, p_subscribe_ack);\n            if (rc >= 0) {\n                packet_id = p_subscribe_ack->packet_id;\n            #ifdef WOLFMQTT_V5\n                props = p_subscribe_ack->props;\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_UNSUBSCRIBE_ACK:\n        {\n            MqttUnsubscribeAck unsubscribe_ack,\n                               *p_unsubscribe_ack = &unsubscribe_ack;\n            if (packet_obj) {\n                p_unsubscribe_ack = (MqttUnsubscribeAck*)packet_obj;\n            }\n            else {\n                XMEMSET(p_unsubscribe_ack, 0, sizeof(MqttUnsubscribeAck));\n            }\n        #ifdef WOLFMQTT_V5\n            p_unsubscribe_ack->protocol_level = client->protocol_level;\n        #endif\n            rc = MqttDecode_UnsubscribeAck(rx_buf, rx_len, p_unsubscribe_ack);\n            if (rc >= 0) {\n                packet_id = p_unsubscribe_ack->packet_id;\n            #ifdef WOLFMQTT_V5\n                props = p_unsubscribe_ack->props;\n            #endif\n            }\n            break;\n        }\n        case MQTT_PACKET_TYPE_PING_RESP:\n        {\n            MqttPing ping, *p_ping = &ping;\n            if (packet_obj) {\n                p_ping = (MqttPing*)packet_obj;\n            }\n            else {\n                XMEMSET(p_ping, 0, sizeof(MqttPing));\n            }\n            rc = MqttDecode_Ping(rx_buf, rx_len, p_ping);\n            break;\n        }\n        case MQTT_PACKET_TYPE_AUTH:\n        {\n        #ifdef WOLFMQTT_V5\n            MqttAuth auth, *p_auth = &auth;\n            if (packet_obj) {\n                p_auth = (MqttAuth*)packet_obj;\n            }\n            else {\n                XMEMSET(p_auth, 0, sizeof(MqttAuth));\n            }\n            rc = MqttDecode_Auth(rx_buf, rx_len, p_auth);\n            if (rc >= 0) {\n                props = p_auth->props;\n            }\n        #else\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n        #endif /* WOLFMQTT_V5 */\n            break;\n        }\n        case MQTT_PACKET_TYPE_DISCONNECT:\n        {\n        #ifdef WOLFMQTT_V5\n            MqttDisconnect disc, *p_disc = &disc;\n            if (packet_obj) {\n                p_disc = (MqttDisconnect*)packet_obj;\n            }\n            else {\n                XMEMSET(p_disc, 0, sizeof(MqttDisconnect));\n            }\n            rc = MqttDecode_Disconnect(rx_buf, rx_len, p_disc);\n            if (rc >= 0) {\n                props = p_disc->props;\n            }\n        #else\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n        #endif /* WOLFMQTT_V5 */\n            break;\n        }\n        case MQTT_PACKET_TYPE_CONNECT:\n        case MQTT_PACKET_TYPE_SUBSCRIBE:\n        case MQTT_PACKET_TYPE_UNSUBSCRIBE:\n        case MQTT_PACKET_TYPE_PING_REQ:\n        case MQTT_PACKET_TYPE_ANY:\n        case MQTT_PACKET_TYPE_RESERVED:\n        default:\n            /* these type are only encoded by client */\n            rc = MQTT_CODE_ERROR_PACKET_TYPE;\n            break;\n        } /* switch (packet_type) */\n    }\n\n    if (ppacket_id) {\n        *ppacket_id = packet_id;\n    }\n\n#ifdef WOLFMQTT_V5\n    if (props) {\n    #ifdef WOLFMQTT_PROPERTY_CB\n        /* Check for properties set by the server */\n        if (packet_obj && client->property_cb) {\n            /* capture error if returned */\n            int rc_err = client->property_cb(client, props,\n                    client->property_ctx);\n            if (rc_err < 0) {\n                rc = rc_err;\n            }\n        }\n    #endif\n        /* Free the properties */\n        MqttProps_Free(props);\n    }\n#endif\n\n    (void)client;\n\n#ifdef WOLFMQTT_DEBUG_CLIENT\n    PRINTF(\"MqttClient_DecodePacket: Rc %d, Len %d, Type %s (%d), ID %d,\"\n            \" QoS %d\",\n        rc, rx_len, MqttPacket_TypeDesc(packet_type), packet_type, packet_id,\n        packet_qos);\n#endif\n\n    return rc;\n}\n"
  },
  {
    "repository": "qemu",
    "cve_id": "CVE-2021-3416",
    "cwe_list": [
      "CWE-835"
    ],
    "commit_hash": "1caff0340f49c93d535c6558a5138d20d475315c",
    "short_hash": "1caff034",
    "vulnerableMethods_before": [
      {
        "filename": "e1000.c",
        "method_name": "vulnerable_function",
        "raw_code": "e1000_send_packet(E1000State *s, const uint8_t *buf, int size)\n{\n    static const int PTCregs[6] = { PTC64, PTC127, PTC255, PTC511,\n                                    PTC1023, PTC1522 };\n\n    NetClientState *nc = qemu_get_queue(s->nic);\n    if (s->phy_reg[PHY_CTRL] & MII_CR_LOOPBACK) {\n        nc->info->receive(nc, buf, size);\n    } else {\n        qemu_send_packet(nc, buf, size);\n    }\n    inc_tx_bcast_or_mcast_count(s, buf);\n    e1000x_increase_size_stats(s->mac_reg, PTCregs, size);\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "e1000.c",
        "method_name": "fixed_function",
        "raw_code": "e1000_send_packet(E1000State *s, const uint8_t *buf, int size)\n{\n    static const int PTCregs[6] = { PTC64, PTC127, PTC255, PTC511,\n                                    PTC1023, PTC1522 };\n\n    NetClientState *nc = qemu_get_queue(s->nic);\n    if (s->phy_reg[PHY_CTRL] & MII_CR_LOOPBACK) {\n        qemu_receive_packet(nc, buf, size);\n    } else {\n        qemu_send_packet(nc, buf, size);\n    }\n    inc_tx_bcast_or_mcast_count(s, buf);\n    e1000x_increase_size_stats(s->mac_reg, PTCregs, size);\n}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "e2guardian",
    "cve_id": "CVE-2021-44273",
    "cwe_list": [
      "CWE-295"
    ],
    "commit_hash": "eae46a7e2a57103aadca903c4a24cca94dc502a2",
    "short_hash": "eae46a7e",
    "vulnerableMethods_before": [
      {
        "filename": "Socket.cpp",
        "method_name": "vulnerable_function",
        "raw_code": "int Socket::startSslClient(const std::string &certificate_path, String hostname)\n{\n    if (isssl) {\n        stopSsl();\n    }\n\n    ERR_clear_error();\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n    ctx = SSL_CTX_new(SSLv23_client_method());\n#else\n    ctx = SSL_CTX_new(TLS_client_method());\n#endif\n\n    if (ctx == NULL) {\n#ifdef NETDEBUG\n        std::cout << thread_id << \"Error ssl context is null (check that openssl has been inited)\" << std::endl;\n#endif\n        log_ssl_errors(\"Error ssl context is null for %s\", hostname.c_str());\n        return -1;\n    }\n\n    //set the timeout for the ssl session\n    if (SSL_CTX_set_timeout(ctx, 130l) < 1) {\n            SSL_CTX_free(ctx);\n            ctx = NULL;\n        return -1;\n    }\n\n    //load certs\n    ERR_clear_error();\n    if (certificate_path.length()) {\n        if (!SSL_CTX_load_verify_locations(ctx, NULL, certificate_path.c_str())) {\n#ifdef NETDEBUG\n            std::cout << thread_id << \"couldnt load certificates\" << std::endl;\n#endif\n            log_ssl_errors(\"couldnt load certificates from %s\", certificate_path.c_str());\n            //tidy up\n            SSL_CTX_free(ctx);\n            ctx = NULL;\n            return -2;\n        }\n    } else if (!SSL_CTX_set_default_verify_paths(ctx)) //use default if no certPpath given\n    {\n#ifdef NETDEBUG\n        std::cout << thread_id << \"couldnt load certificates\" << std::endl;\n#endif\n            log_ssl_errors(\"couldnt load default certificates for %s\", hostname.c_str());\n        //tidy up\n        SSL_CTX_free(ctx);\n        ctx = NULL;\n        return -2;\n    }\n\n    // add validation params\n    ERR_clear_error();\n    X509_VERIFY_PARAM *x509_param = X509_VERIFY_PARAM_new();\n    if (!x509_param) {\n        log_ssl_errors(\"couldnt add validation params for %s\", hostname.c_str());\n        //X509_VERIFY_PARAM_free(x509_param);\n            SSL_CTX_free(ctx);\n            ctx = NULL;\n        return -2;\n    }\n\n    ERR_clear_error();\n    if (!X509_VERIFY_PARAM_set_flags(x509_param, X509_V_FLAG_TRUSTED_FIRST)) {\n        log_ssl_errors(\"couldnt add validation params for %s\", hostname.c_str());\n        X509_VERIFY_PARAM_free(x509_param);\n            SSL_CTX_free(ctx);\n            ctx = NULL;\n        return -2;\n    }\n\n    ERR_clear_error();\n    if (!SSL_CTX_set1_param(ctx, x509_param)) {\n        log_ssl_errors(\"couldnt add validation params for %s\", hostname.c_str());\n        X509_VERIFY_PARAM_free(x509_param);\n            SSL_CTX_free(ctx);\n            ctx = NULL;\n        return -2;\n    }\n\n    X509_VERIFY_PARAM_free(x509_param);     // try not freeing this as SSL_CTX_free seems to be ring to free it\n\n    //hand socket over to ssl lib\n    ERR_clear_error();\n    ssl = SSL_new(ctx);\n    SSL_set_options(ssl, SSL_OP_ALL);\n    SSL_set_mode(ssl, SSL_MODE_AUTO_RETRY);\n    SSL_set_connect_state(ssl);\n\n    //fcntl(this->getFD() ,F_SETFL, O_NONBLOCK); // blocking mode used currently\n    SSL_set_fd(ssl, this->getFD());\n    SSL_set_tlsext_host_name(ssl, hostname.c_str());\n\n    //make io non blocking as select wont tell us if we can do a read without blocking\n    //BIO_set_nbio(SSL_get_rbio(ssl),1l);  // blocking mode used currently\n    //BIO_set_nbio(SSL_get_wbio(ssl),1l); // blocking mode used currently\n    ERR_clear_error();\n    int rc = SSL_connect(ssl);\n    if (rc < 0) {\n        log_ssl_errors(\"ssl_connect failed to %s\", hostname.c_str());\n#ifdef NETDEBUG\n        std::cout << thread_id << \"ssl_connect failed with error \" << SSL_get_error(ssl, rc) << std::endl;\n#endif\n        // tidy up\n        SSL_free(ssl);\n        ssl = NULL;\n        SSL_CTX_free(ctx);\n        ctx = NULL;\n        return -3;\n    }\n\n    //should be safer to do this last as nothing will ever try to use a ssl socket that isnt fully setup\n    isssl = true;\n    issslserver = false;\n    return 0;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "Socket.cpp",
        "method_name": "fixed_function",
        "raw_code": "int Socket::startSslClient(const std::string &certificate_path, String hostname)\n{\n    if (isssl) {\n        stopSsl();\n    }\n\n    ERR_clear_error();\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n    ctx = SSL_CTX_new(SSLv23_client_method());\n#else\n    ctx = SSL_CTX_new(TLS_client_method());\n#endif\n\n    if (ctx == NULL) {\n#ifdef NETDEBUG\n        std::cout << thread_id << \"Error ssl context is null (check that openssl has been inited)\" << std::endl;\n#endif\n        log_ssl_errors(\"Error ssl context is null for %s\", hostname.c_str());\n        return -1;\n    }\n\n    //set the timeout for the ssl session\n    if (SSL_CTX_set_timeout(ctx, 130l) < 1) {\n            SSL_CTX_free(ctx);\n            ctx = NULL;\n        return -1;\n    }\n\n    //load certs\n    ERR_clear_error();\n    if (certificate_path.length()) {\n        if (!SSL_CTX_load_verify_locations(ctx, NULL, certificate_path.c_str())) {\n#ifdef NETDEBUG\n            std::cout << thread_id << \"couldnt load certificates\" << std::endl;\n#endif\n            log_ssl_errors(\"couldnt load certificates from %s\", certificate_path.c_str());\n            //tidy up\n            SSL_CTX_free(ctx);\n            ctx = NULL;\n            return -2;\n        }\n    } else if (!SSL_CTX_set_default_verify_paths(ctx)) //use default if no certPpath given\n    {\n#ifdef NETDEBUG\n        std::cout << thread_id << \"couldnt load certificates\" << std::endl;\n#endif\n            log_ssl_errors(\"couldnt load default certificates for %s\", hostname.c_str());\n        //tidy up\n        SSL_CTX_free(ctx);\n        ctx = NULL;\n        return -2;\n    }\n\n    // add validation params\n    ERR_clear_error();\n    X509_VERIFY_PARAM *x509_param = X509_VERIFY_PARAM_new();\n    if (!x509_param) {\n        log_ssl_errors(\"couldnt add validation params for %s\", hostname.c_str());\n        //X509_VERIFY_PARAM_free(x509_param);\n            SSL_CTX_free(ctx);\n            ctx = NULL;\n        return -2;\n    }\n\n    ERR_clear_error();\n    if (!X509_VERIFY_PARAM_set_flags(x509_param, X509_V_FLAG_TRUSTED_FIRST)) {\n        log_ssl_errors(\"couldnt add validation params for %s\", hostname.c_str());\n        X509_VERIFY_PARAM_free(x509_param);\n            SSL_CTX_free(ctx);\n            ctx = NULL;\n        return -2;\n    }\n\n    ERR_clear_error();\n    if (!SSL_CTX_set1_param(ctx, x509_param)) {\n        log_ssl_errors(\"couldnt add validation params for %s\", hostname.c_str());\n        X509_VERIFY_PARAM_free(x509_param);\n            SSL_CTX_free(ctx);\n            ctx = NULL;\n        return -2;\n    }\n\n    X509_VERIFY_PARAM_free(x509_param);     // try not freeing this as SSL_CTX_free seems to be ring to free it\n\n    //hand socket over to ssl lib\n    ERR_clear_error();\n    ssl = SSL_new(ctx);\n    SSL_set_options(ssl, SSL_OP_ALL);\n    SSL_set_mode(ssl, SSL_MODE_AUTO_RETRY);\n    SSL_set_connect_state(ssl);\n\n    //fcntl(this->getFD() ,F_SETFL, O_NONBLOCK); // blocking mode used currently\n    SSL_set_fd(ssl, this->getFD());\n    SSL_set_tlsext_host_name(ssl, hostname.c_str());\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n#else\n  X509_VERIFY_PARAM_set1_host(SSL_get0_param(ssl),hostname.c_str(),0);\n#endif\n\n    //make io non blocking as select wont tell us if we can do a read without blocking\n    //BIO_set_nbio(SSL_get_rbio(ssl),1l);  // blocking mode used currently\n    //BIO_set_nbio(SSL_get_wbio(ssl),1l); // blocking mode used currently\n    ERR_clear_error();\n    int rc = SSL_connect(ssl);\n    if (rc < 0) {\n        log_ssl_errors(\"ssl_connect failed to %s\", hostname.c_str());\n#ifdef NETDEBUG\n        std::cout << thread_id << \"ssl_connect failed with error \" << SSL_get_error(ssl, rc) << std::endl;\n#endif\n        // tidy up\n        SSL_free(ssl);\n        ssl = NULL;\n        SSL_CTX_free(ctx);\n        ctx = NULL;\n        return -3;\n    }\n\n    //should be safer to do this last as nothing will ever try to use a ssl socket that isnt fully setup\n    isssl = true;\n    issslserver = false;\n    return 0;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"openssl/err.h\"\n#include \"openssl/ssl.h\"\n#include \"openssl/asn1.h\"\n#include <unistd.h>\n#include <netinet/tcp.h>\n#include \"openssl/x509v3.h\"\n#include <sys/time.h>\n#include <cerrno>\n#include <fcntl.h>\n#include <stdexcept>\n#include \"Socket.hpp\"\n#include \"String.hpp\"\n#include <csignal>\n#include <syslog.h>\n#include \"e2config.h\"\n#include \"CertificateAuthority.hpp\"\n#include <pwd.h>\n#include <string.h>\n"
  },
  {
    "repository": "tensorflow",
    "cve_id": "CVE-2022-23589",
    "cwe_list": [
      "CWE-476"
    ],
    "commit_hash": "0a365c029e437be0349c31f8d4c9926b69fa3fa1",
    "short_hash": "0a365c02",
    "vulnerableMethods_before": [
      {
        "filename": "constant_folding.cc",
        "method_name": "vulnerable_function",
        "raw_code": "bool ConstantFolding::MulConvPushDown(GraphDef* optimized_graph, NodeDef* node,\n                                      const GraphProperties& properties) {\n  // Push down multiplication on ConvND.\n  //                       *                  ConvND\n  //                     /   \\                /    \\\n  //                 ConvND  C2    -- >      X      *\n  //                  / \\                          / \\\n  //                 X  C1                       C1  C2\n  //\n  // where C1 and C2 are constants and X is non-constant.\n  //\n  // TODO(rmlarsen): Use PrepareConstantPushDown() to simplify this code.\n\n  if (!IsAnyMul(*node) || NumNonControlInputs(*node) != 2) return false;\n\n  NodeDef* mul_left_child = node_map_->GetNode(node->input(0));\n  NodeDef* mul_right_child = node_map_->GetNode(node->input(1));\n  // One child must be constant, and the second must be Conv op.\n  const bool left_child_is_constant = IsReallyConstant(*mul_left_child);\n  const bool right_child_is_constant = IsReallyConstant(*mul_right_child);\n  if (!left_child_is_constant && !right_child_is_constant) {\n    return false;\n  }\n  NodeDef* conv_node =\n      left_child_is_constant ? mul_right_child : mul_left_child;\n  if (!IsConv2D(*conv_node) && !IsConv3D(*conv_node)) {\n    return false;\n  }\n  if (node->device() != mul_left_child->device() ||\n      node->device() != mul_right_child->device()) {\n    return false;\n  }\n\n  // Make sure that it is safe to change the value of the convolution\n  // output.\n  if (conv_node->input_size() < 2 ||\n      NumNonControlOutputs(*conv_node, *node_map_) > 1 ||\n      nodes_to_preserve_.find(conv_node->name()) != nodes_to_preserve_.end()) {\n    return false;\n  }\n\n  // Identify the nodes to swap.\n  NodeDef* conv_left_child = node_map_->GetNode(conv_node->input(0));\n  NodeDef* conv_right_child = node_map_->GetNode(conv_node->input(1));\n  const bool conv_left_is_constant = IsReallyConstant(*conv_left_child);\n  const bool conv_right_is_constant = IsReallyConstant(*conv_right_child);\n  if (!conv_left_is_constant && !conv_right_is_constant) {\n    // At least one of the convolution inputs should be constant.\n    return false;\n  }\n  if (conv_left_is_constant && conv_right_is_constant) {\n    // Leverage regular constant folding to handle this.\n    return false;\n  }\n  const auto& mul_props = properties.GetOutputProperties(node->name());\n  const auto& conv_props = properties.GetOutputProperties(conv_node->name());\n  if (mul_props.empty() || conv_props.empty()) {\n    return false;\n  }\n  const auto& mul_shape = mul_props[0].shape();\n  const auto& conv_shape = conv_props[0].shape();\n  if (!ShapesSymbolicallyEqual(mul_shape, conv_shape)) {\n    return false;\n  }\n\n  const auto& input_props = properties.GetInputProperties(conv_node->name());\n  if (input_props.size() < 2) {\n    return false;\n  }\n  const auto& filter_shape = input_props[1].shape();\n\n  NodeDef* const_node =\n      left_child_is_constant ? mul_left_child : mul_right_child;\n  const auto& const_props = properties.GetOutputProperties(const_node->name());\n  if (const_props.empty()) {\n    return false;\n  }\n  const auto& const_shape = const_props[0].shape();\n  if (!IsValidConstShapeForMulConvPushDown(\n          conv_node->attr().at(\"data_format\").s(), filter_shape, const_shape)) {\n    return false;\n  }\n\n  string mul_new_name = AddPrefixToNodeName(\"merged_input\", conv_node->name());\n  if (node_map_->NodeExists(mul_new_name)) {\n    return false;\n  }\n  // Make sure we don't introduce loops in the graph by removing control\n  // dependencies from the conv2d node to c2.\n  string conv_const_input =\n      conv_left_is_constant ? conv_node->input(0) : conv_node->input(1);\n  if (MaybeRemoveControlInput(conv_node->name(), const_node, optimized_graph,\n                              node_map_.get())) {\n    // Add a control dep from c1 to c2 to ensure c2 is in the right frame\n    MaybeAddControlInput(conv_const_input, const_node, optimized_graph,\n                         node_map_.get());\n  }\n\n  conv_node->set_name(node->name());\n  node->set_name(mul_new_name);\n  if (conv_left_is_constant) {\n    node_map_->UpdateInput(conv_node->name(), node->input(0), mul_new_name);\n    conv_node->set_input(0, mul_new_name);\n  } else {\n    node_map_->UpdateInput(conv_node->name(), node->input(1), mul_new_name);\n    conv_node->set_input(1, mul_new_name);\n  }\n  NodeDef* conv_const_node =\n      conv_left_is_constant ? conv_left_child : conv_right_child;\n  if (left_child_is_constant) {\n    node->set_input(1, conv_const_node->name());\n  } else {\n    node->set_input(0, conv_const_node->name());\n  }\n  node_map_->AddNode(mul_new_name, node);\n\n  return true;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "constant_folding.cc",
        "method_name": "fixed_function",
        "raw_code": "bool ConstantFolding::MulConvPushDown(GraphDef* optimized_graph, NodeDef* node,\n                                      const GraphProperties& properties) {\n  // Push down multiplication on ConvND.\n  //                       *                  ConvND\n  //                     /   \\                /    \\\n  //                 ConvND  C2    -- >      X      *\n  //                  / \\                          / \\\n  //                 X  C1                       C1  C2\n  //\n  // where C1 and C2 are constants and X is non-constant.\n  //\n  // TODO(rmlarsen): Use PrepareConstantPushDown() to simplify this code.\n\n  if (!IsAnyMul(*node) || NumNonControlInputs(*node) != 2) return false;\n\n  NodeDef* mul_left_child = node_map_->GetNode(node->input(0));\n  NodeDef* mul_right_child = node_map_->GetNode(node->input(1));\n  if (mul_left_child == nullptr || mul_right_child == nullptr) {\n    return false;\n  }\n  // One child must be constant, and the second must be Conv op.\n  const bool left_child_is_constant = IsReallyConstant(*mul_left_child);\n  const bool right_child_is_constant = IsReallyConstant(*mul_right_child);\n  if (!left_child_is_constant && !right_child_is_constant) {\n    return false;\n  }\n  NodeDef* conv_node =\n      left_child_is_constant ? mul_right_child : mul_left_child;\n  if (!IsConv2D(*conv_node) && !IsConv3D(*conv_node)) {\n    return false;\n  }\n  if (node->device() != mul_left_child->device() ||\n      node->device() != mul_right_child->device()) {\n    return false;\n  }\n\n  // Make sure that it is safe to change the value of the convolution\n  // output.\n  if (conv_node->input_size() < 2 ||\n      NumNonControlOutputs(*conv_node, *node_map_) > 1 ||\n      nodes_to_preserve_.find(conv_node->name()) != nodes_to_preserve_.end()) {\n    return false;\n  }\n\n  // Identify the nodes to swap.\n  NodeDef* conv_left_child = node_map_->GetNode(conv_node->input(0));\n  NodeDef* conv_right_child = node_map_->GetNode(conv_node->input(1));\n  const bool conv_left_is_constant = IsReallyConstant(*conv_left_child);\n  const bool conv_right_is_constant = IsReallyConstant(*conv_right_child);\n  if (!conv_left_is_constant && !conv_right_is_constant) {\n    // At least one of the convolution inputs should be constant.\n    return false;\n  }\n  if (conv_left_is_constant && conv_right_is_constant) {\n    // Leverage regular constant folding to handle this.\n    return false;\n  }\n  const auto& mul_props = properties.GetOutputProperties(node->name());\n  const auto& conv_props = properties.GetOutputProperties(conv_node->name());\n  if (mul_props.empty() || conv_props.empty()) {\n    return false;\n  }\n  const auto& mul_shape = mul_props[0].shape();\n  const auto& conv_shape = conv_props[0].shape();\n  if (!ShapesSymbolicallyEqual(mul_shape, conv_shape)) {\n    return false;\n  }\n\n  const auto& input_props = properties.GetInputProperties(conv_node->name());\n  if (input_props.size() < 2) {\n    return false;\n  }\n  const auto& filter_shape = input_props[1].shape();\n\n  NodeDef* const_node =\n      left_child_is_constant ? mul_left_child : mul_right_child;\n  const auto& const_props = properties.GetOutputProperties(const_node->name());\n  if (const_props.empty()) {\n    return false;\n  }\n  const auto& const_shape = const_props[0].shape();\n  if (!IsValidConstShapeForMulConvPushDown(\n          conv_node->attr().at(\"data_format\").s(), filter_shape, const_shape)) {\n    return false;\n  }\n\n  string mul_new_name = AddPrefixToNodeName(\"merged_input\", conv_node->name());\n  if (node_map_->NodeExists(mul_new_name)) {\n    return false;\n  }\n  // Make sure we don't introduce loops in the graph by removing control\n  // dependencies from the conv2d node to c2.\n  string conv_const_input =\n      conv_left_is_constant ? conv_node->input(0) : conv_node->input(1);\n  if (MaybeRemoveControlInput(conv_node->name(), const_node, optimized_graph,\n                              node_map_.get())) {\n    // Add a control dep from c1 to c2 to ensure c2 is in the right frame\n    MaybeAddControlInput(conv_const_input, const_node, optimized_graph,\n                         node_map_.get());\n  }\n\n  conv_node->set_name(node->name());\n  node->set_name(mul_new_name);\n  if (conv_left_is_constant) {\n    node_map_->UpdateInput(conv_node->name(), node->input(0), mul_new_name);\n    conv_node->set_input(0, mul_new_name);\n  } else {\n    node_map_->UpdateInput(conv_node->name(), node->input(1), mul_new_name);\n    conv_node->set_input(1, mul_new_name);\n  }\n  NodeDef* conv_const_node =\n      conv_left_is_constant ? conv_left_child : conv_right_child;\n  if (left_child_is_constant) {\n    node->set_input(1, conv_const_node->name());\n  } else {\n    node->set_input(0, conv_const_node->name());\n  }\n  node_map_->AddNode(mul_new_name, node);\n\n  return true;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <cmath>\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/framework/allocator.h\"\n#include \"tensorflow/core/grappler/utils/symbolic_shapes.h\"\n#include \"tensorflow/core/grappler/op_types.h\"\n#include \"tensorflow/core/lib/gtl/inlined_vector.h\"\n#include \"tensorflow/core/grappler/optimizers/evaluation_utils.h\"\n#include \"tensorflow/core/lib/core/stringpiece.h\"\n#include \"tensorflow/core/lib/strings/numbers.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/framework/op.h\"\n#include \"tensorflow/core/framework/tensor_shape.pb.h\"\n#include \"tensorflow/core/platform/setround.h\"\n#include \"tensorflow/core/grappler/grappler_item.h\"\n#include \"tensorflow/core/platform/cpu_info.h\"\n#include \"absl/strings/substitute.h\"\n#include \"tensorflow/core/grappler/costs/graph_properties.h\"\n#include \"tensorflow/core/platform/tensor_coding.h\"\n#include \"tensorflow/core/framework/attr_value.pb.h\"\n#include \"tensorflow/core/util/bcast.h\"\n#include \"tensorflow/core/public/version.h\"\n#include \"tensorflow/core/framework/op_def.pb.h\"\n#include \"tensorflow/core/util/saved_tensor_slice_util.h\"\n#include \"tensorflow/core/platform/denormal.h\"\n#include \"tensorflow/core/grappler/utils.h\"\n#include \"tensorflow/core/framework/versions.pb.h\"\n#include \"tensorflow/core/framework/types.pb.h\"\n#include \"tensorflow/core/framework/node_def.pb.h\"\n#include \"tensorflow/core/platform/env.h\"\n#include \"tensorflow/core/framework/tensor.pb.h\"\n#include \"tensorflow/core/grappler/clusters/cluster.h\"\n#include \"tensorflow/core/framework/tensor_util.h\"\n#include \"tensorflow/core/lib/gtl/cleanup.h\"\n#include \"tensorflow/core/framework/function.pb.h\"\n#include \"tensorflow/core/lib/strings/strcat.h\"\n#include \"absl/strings/string_view.h\"\n#include \"tensorflow/core/grappler/optimizers/constant_folding.h\"\n\n// Type Definitions:\n// GraphDef:\nclass GraphDef\n\n// ConstantFolding:\ntensorflow.grappler.ConstantFolding.ConstantFolding:ANY(RewriterConfig.Toggle,tensorflow.DeviceBase*,bool,bool)\n\n// NodeDef:\nclass NodeDef\n\n// ConstantFolding:\nclass ConstantFolding : public GraphOptimizer {\n public:\n  // The size limit will only be considered if the newly created node is greater\n  // than original_size (optional).\n  static Status CreateNodeDef(const string& name, const TensorValue& tensor,\n                              NodeDef* node, size_t original_size = 0);\n  static string AddControlDependency(const string& input_name, GraphDef* graph,\n                                     NodeMap* node_map);\n\n  explicit ConstantFolding(DeviceBase* cpu_device,\n                           bool disable_compressed_tensor_optimization = false,\n                           bool fold_quantization_emulation = true);\n  ConstantFolding(RewriterConfig::Toggle opt_level, DeviceBase* cpu_device,\n                  bool disable_compressed_tensor_optimization = false,\n                  bool fold_quantization_emulation = true);\n\n  ~ConstantFolding() override {}\n\n  string name() const override { return \"constant_folding\"; };\n\n  bool UsesFunctionLibrary() c...\n"
  },
  {
    "repository": "pjproject",
    "cve_id": "CVE-2021-43845",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "f74c1fc22b760d2a24369aa72c74c4a9ab985859",
    "short_hash": "f74c1fc2",
    "vulnerableMethods_before": [
      {
        "filename": "rtcp_xr.c",
        "method_name": "vulnerable_function",
        "raw_code": "void pjmedia_rtcp_xr_rx_rtcp_xr( pjmedia_rtcp_xr_session *sess,\n\t\t\t\t const void *pkt,\n\t\t\t\t pj_size_t size)\n{\n    const pjmedia_rtcp_xr_pkt\t      *rtcp_xr = (pjmedia_rtcp_xr_pkt*) pkt;\n    const pjmedia_rtcp_xr_rb_rr_time  *rb_rr_time = NULL;\n    const pjmedia_rtcp_xr_rb_dlrr     *rb_dlrr = NULL;\n    const pjmedia_rtcp_xr_rb_stats    *rb_stats = NULL;\n    const pjmedia_rtcp_xr_rb_voip_mtc *rb_voip_mtc = NULL;\n    const pjmedia_rtcp_xr_rb_header   *rb_hdr = (pjmedia_rtcp_xr_rb_header*) \n\t\t\t\t\t\trtcp_xr->buf;\n    unsigned pkt_len, rb_len;\n\n    if (rtcp_xr->common.pt != RTCP_XR)\n\treturn;\n\n    pkt_len = pj_ntohs((pj_uint16_t)rtcp_xr->common.length);\n\n    if ((pkt_len + 1) > (size / 4))\n\treturn;\n\n    /* Parse report rpt_types */\n    while ((pj_int32_t*)rb_hdr < (pj_int32_t*)pkt + pkt_len)\n    {\t\n\trb_len = pj_ntohs((pj_uint16_t)rb_hdr->length);\n\n\t/* Just skip any block with length == 0 (no report content) */\n\tif (rb_len) {\n\t    switch (rb_hdr->bt) {\n\t\tcase BT_RR_TIME:\n\t\t    rb_rr_time = (pjmedia_rtcp_xr_rb_rr_time*) rb_hdr;\n\t\t    break;\n\t\tcase BT_DLRR:\n\t\t    rb_dlrr = (pjmedia_rtcp_xr_rb_dlrr*) rb_hdr;\n\t\t    break;\n\t\tcase BT_STATS:\n\t\t    rb_stats = (pjmedia_rtcp_xr_rb_stats*) rb_hdr;\n\t\t    break;\n\t\tcase BT_VOIP_METRICS:\n\t\t    rb_voip_mtc = (pjmedia_rtcp_xr_rb_voip_mtc*) rb_hdr;\n\t\t    break;\n\t\tdefault:\n\t\t    break;\n\t    }\n\t}\n\trb_hdr = (pjmedia_rtcp_xr_rb_header*)\n\t\t ((pj_int32_t*)rb_hdr + rb_len + 1);\n    }\n\n    /* Receiving RR Time */\n    if (rb_rr_time) {\n\t/* Save LRR from NTP timestamp of the RR time block report */\n\tsess->rx_lrr = ((pj_ntohl(rb_rr_time->ntp_sec) & 0x0000FFFF) << 16) | \n\t\t       ((pj_ntohl(rb_rr_time->ntp_frac) >> 16) & 0xFFFF);\n\n\t/* Calculate RR arrival time for DLRR */\n\tpj_get_timestamp(&sess->rx_lrr_time);\n\n\tTRACE_((sess->name, \"Rx RTCP SR: ntp_ts=%p\", sess->rx_lrr,\n\t       (pj_uint32_t)(sess->rx_lrr_time.u64*65536/\n\t\t\t     sess->rtcp_session->ts_freq.u64)));\n    }\n\n    /* Receiving DLRR */\n    if (rb_dlrr) {\n\tpj_uint32_t lrr, now, dlrr;\n\tpj_uint64_t eedelay;\n\tpjmedia_rtcp_ntp_rec ntp;\n\n\t/* LRR is the middle 32bit of NTP. It has 1/65536 second \n\t * resolution \n\t */\n\tlrr = pj_ntohl(rb_dlrr->item.lrr);\n\n\t/* DLRR is delay since LRR, also in 1/65536 resolution */\n\tdlrr = pj_ntohl(rb_dlrr->item.dlrr);\n\n\t/* Get current time, and convert to 1/65536 resolution */\n\tpjmedia_rtcp_get_ntp_time(sess->rtcp_session, &ntp);\n\tnow = ((ntp.hi & 0xFFFF) << 16) + (ntp.lo >> 16);\n\n\t/* End-to-end delay is (now-lrr-dlrr) */\n\teedelay = now - lrr - dlrr;\n\n\t/* Convert end to end delay to usec (keeping the calculation in\n         * 64bit space)::\n\t *   sess->ee_delay = (eedelay * 1000) / 65536;\n\t */\n\tif (eedelay < 4294) {\n\t    eedelay = (eedelay * 1000000) >> 16;\n\t} else {\n\t    eedelay = (eedelay * 1000) >> 16;\n\t    eedelay *= 1000;\n\t}\n\n\tTRACE_((sess->name, \"Rx RTCP XR DLRR: lrr=%p, dlrr=%p (%d:%03dms), \"\n\t\t\t   \"now=%p, rtt=%p\",\n\t\tlrr, dlrr, dlrr/65536, (dlrr%65536)*1000/65536,\n\t\tnow, (pj_uint32_t)eedelay));\n\t\n\t/* Only save calculation if \"now\" is greater than lrr, or\n\t * otherwise rtt will be invalid \n\t */\n\tif (now-dlrr >= lrr) {\n\t    unsigned rtt = (pj_uint32_t)eedelay;\n\t    \n\t    /* Check that eedelay value really makes sense. \n\t     * We allow up to 30 seconds RTT!\n\t     */\n\t    if (eedelay <= 30 * 1000 * 1000UL) {\n\t\t/* \"Normalize\" rtt value that is exceptionally high.\n\t\t * For such values, \"normalize\" the rtt to be three times\n\t\t * the average value.\n\t\t */\n\t\tif (rtt>((unsigned)sess->stat.rtt.mean*3) && sess->stat.rtt.n!=0)\n\t\t{\n\t\t    unsigned orig_rtt = rtt;\n\t\t    rtt = (unsigned)sess->stat.rtt.mean*3;\n\t\t    PJ_LOG(5,(sess->name, \n\t\t\t      \"RTT value %d usec is normalized to %d usec\",\n\t\t\t      orig_rtt, rtt));\n\t\t}\n    \t\n\t\tTRACE_((sess->name, \"RTCP RTT is set to %d usec\", rtt));\n\t\tpj_math_stat_update(&sess->stat.rtt, rtt);\n\t    }\n\t} else {\n\t    PJ_LOG(5, (sess->name, \"Internal RTCP NTP clock skew detected: \"\n\t\t\t\t   \"lrr=%p, now=%p, dlrr=%p (%d:%03dms), \"\n\t\t\t\t   \"diff=%d\",\n\t\t\t\t   lrr, now, dlrr, dlrr/65536,\n\t\t\t\t   (dlrr%65536)*1000/65536,\n\t\t\t\t   dlrr-(now-lrr)));\n\t}\n    }\n\n    /* Receiving Statistics Summary */\n    if (rb_stats) {\n\tpj_uint8_t flags = rb_stats->header.specific;\n\n\tpj_bzero(&sess->stat.tx.stat_sum, sizeof(sess->stat.tx.stat_sum));\n\n\t/* Range of packets sequence reported in this blocks */\n\tsess->stat.tx.stat_sum.begin_seq = pj_ntohs(rb_stats->begin_seq);\n\tsess->stat.tx.stat_sum.end_seq   = pj_ntohs(rb_stats->end_seq);\n\n\t/* Get flags of valid fields */\n\tsess->stat.tx.stat_sum.l = (flags & (1 << 7)) != 0;\n\tsess->stat.tx.stat_sum.d = (flags & (1 << 6)) != 0;\n\tsess->stat.tx.stat_sum.j = (flags & (1 << 5)) != 0;\n\tsess->stat.tx.stat_sum.t = (flags & (3 << 3)) != 0;\n\n\t/* Fetch the reports info */\n\tif (sess->stat.tx.stat_sum.l) {\n\t    sess->stat.tx.stat_sum.lost = pj_ntohl(rb_stats->lost);\n\t}\n\n\tif (sess->stat.tx.stat_sum.d) {\n\t    sess->stat.tx.stat_sum.dup = pj_ntohl(rb_stats->dup);\n\t}\n\n\tif (sess->stat.tx.stat_sum.j) {\n\t    sess->stat.tx.stat_sum.jitter.min = pj_ntohl(rb_stats->jitter_min);\n\t    sess->stat.tx.stat_sum.jitter.max = pj_ntohl(rb_stats->jitter_max);\n\t    sess->stat.tx.stat_sum.jitter.mean= pj_ntohl(rb_stats->jitter_mean);\n\t    pj_math_stat_set_stddev(&sess->stat.tx.stat_sum.jitter, \n\t\t\t\t    pj_ntohl(rb_stats->jitter_dev));\n\t}\n\n\tif (sess->stat.tx.stat_sum.t) {\n\t    sess->stat.tx.stat_sum.toh.min = rb_stats->toh_min;\n\t    sess->stat.tx.stat_sum.toh.max = rb_stats->toh_max;\n\t    sess->stat.tx.stat_sum.toh.mean= rb_stats->toh_mean;\n\t    pj_math_stat_set_stddev(&sess->stat.tx.stat_sum.toh, \n\t\t\t\t    pj_ntohl(rb_stats->toh_dev));\n\t}\n\n\tpj_gettimeofday(&sess->stat.tx.stat_sum.update);\n    }\n\n    /* Receiving VoIP Metrics */\n    if (rb_voip_mtc) {\n\tsess->stat.tx.voip_mtc.loss_rate = rb_voip_mtc->loss_rate;\n\tsess->stat.tx.voip_mtc.discard_rate = rb_voip_mtc->discard_rate;\n\tsess->stat.tx.voip_mtc.burst_den = rb_voip_mtc->burst_den;\n\tsess->stat.tx.voip_mtc.gap_den = rb_voip_mtc->gap_den;\n\tsess->stat.tx.voip_mtc.burst_dur = pj_ntohs(rb_voip_mtc->burst_dur);\n\tsess->stat.tx.voip_mtc.gap_dur = pj_ntohs(rb_voip_mtc->gap_dur);\n\tsess->stat.tx.voip_mtc.rnd_trip_delay = \n\t\t\t\t\tpj_ntohs(rb_voip_mtc->rnd_trip_delay);\n\tsess->stat.tx.voip_mtc.end_sys_delay = \n\t\t\t\t\tpj_ntohs(rb_voip_mtc->end_sys_delay);\n\t/* signal & noise level encoded in two's complement form */\n\tsess->stat.tx.voip_mtc.signal_lvl = (pj_int8_t)\n\t\t\t\t    ((rb_voip_mtc->signal_lvl > 127)?\n\t\t\t\t     ((int)rb_voip_mtc->signal_lvl - 256) : \n\t\t\t\t     rb_voip_mtc->signal_lvl);\n\tsess->stat.tx.voip_mtc.noise_lvl  = (pj_int8_t)\n\t\t\t\t    ((rb_voip_mtc->noise_lvl > 127)?\n\t\t\t\t     ((int)rb_voip_mtc->noise_lvl - 256) : \n\t\t\t\t     rb_voip_mtc->noise_lvl);\n\tsess->stat.tx.voip_mtc.rerl = rb_voip_mtc->rerl;\n\tsess->stat.tx.voip_mtc.gmin = rb_voip_mtc->gmin;\n\tsess->stat.tx.voip_mtc.r_factor = rb_voip_mtc->r_factor;\n\tsess->stat.tx.voip_mtc.ext_r_factor = rb_voip_mtc->ext_r_factor;\n\tsess->stat.tx.voip_mtc.mos_lq = rb_voip_mtc->mos_lq;\n\tsess->stat.tx.voip_mtc.mos_cq = rb_voip_mtc->mos_cq;\n\tsess->stat.tx.voip_mtc.rx_config = rb_voip_mtc->rx_config;\n\tsess->stat.tx.voip_mtc.jb_nom = pj_ntohs(rb_voip_mtc->jb_nom);\n\tsess->stat.tx.voip_mtc.jb_max = pj_ntohs(rb_voip_mtc->jb_max);\n\tsess->stat.tx.voip_mtc.jb_abs_max = pj_ntohs(rb_voip_mtc->jb_abs_max);\n\n\tpj_gettimeofday(&sess->stat.tx.voip_mtc.update);\n    }\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "rtcp_xr.c",
        "method_name": "fixed_function",
        "raw_code": "void pjmedia_rtcp_xr_rx_rtcp_xr( pjmedia_rtcp_xr_session *sess,\n\t\t\t\t const void *pkt,\n\t\t\t\t pj_size_t size)\n{\n    const pjmedia_rtcp_xr_pkt\t      *rtcp_xr = (pjmedia_rtcp_xr_pkt*) pkt;\n    const pjmedia_rtcp_xr_rb_rr_time  *rb_rr_time = NULL;\n    const pjmedia_rtcp_xr_rb_dlrr     *rb_dlrr = NULL;\n    const pjmedia_rtcp_xr_rb_stats    *rb_stats = NULL;\n    const pjmedia_rtcp_xr_rb_voip_mtc *rb_voip_mtc = NULL;\n    const pjmedia_rtcp_xr_rb_header   *rb_hdr = (pjmedia_rtcp_xr_rb_header*) \n\t\t\t\t\t\trtcp_xr->buf;\n    unsigned pkt_len, rb_len;\n\n    if (rtcp_xr->common.pt != RTCP_XR)\n\treturn;\n\n    pkt_len = pj_ntohs((pj_uint16_t)rtcp_xr->common.length);\n\n    if ((pkt_len + 1) > (size / 4))\n\treturn;\n\n    /* Parse report rpt_types */\n    while ((pj_int32_t*)rb_hdr < (pj_int32_t*)pkt + pkt_len)\n    {\t\n\trb_len = pj_ntohs((pj_uint16_t)rb_hdr->length);\n\n\t/* Just skip any block with length == 0 (no report content) */\n\tif (rb_len) {\n\t    switch (rb_hdr->bt) {\n\t\tcase BT_RR_TIME:\n\t\t    if ((char*)rb_hdr + sizeof(*rb_rr_time) <=\n\t\t\t(char*)pkt + size) \n\t\t    {\n\t\t\trb_rr_time = (pjmedia_rtcp_xr_rb_rr_time*)rb_hdr;\n\t\t    }\n\t\t    break;\n\t\tcase BT_DLRR:\n\t\t    if ((char*)rb_hdr + sizeof(*rb_dlrr) <=\n\t\t\t(char*)pkt + size)\n\t\t    {\n\t\t\trb_dlrr = (pjmedia_rtcp_xr_rb_dlrr*)rb_hdr;\n\t\t    }\n\t\t    break;\n\t\tcase BT_STATS:\n\t\t    if ((char*)rb_hdr + sizeof(*rb_stats) <=\n\t\t\t(char*)pkt + size)\n\t\t    {\n\t\t\trb_stats = (pjmedia_rtcp_xr_rb_stats*)rb_hdr;\n\t\t    }\n\t\t    break;\n\t\tcase BT_VOIP_METRICS:\n\t\t    if ((char*)rb_hdr + sizeof(*rb_voip_mtc) <=\n\t\t\t(char*)pkt + size)\n\t\t    {\n\t\t\trb_voip_mtc = (pjmedia_rtcp_xr_rb_voip_mtc*)rb_hdr;\n\t\t    }\n\t\t    break;\n\t\tdefault:\n\t\t    break;\n\t    }\n\t}\n\trb_hdr = (pjmedia_rtcp_xr_rb_header*)\n\t\t ((pj_int32_t*)rb_hdr + rb_len + 1);\n    }\n\n    /* Receiving RR Time */\n    if (rb_rr_time) {\n\t/* Save LRR from NTP timestamp of the RR time block report */\n\tsess->rx_lrr = ((pj_ntohl(rb_rr_time->ntp_sec) & 0x0000FFFF) << 16) | \n\t\t       ((pj_ntohl(rb_rr_time->ntp_frac) >> 16) & 0xFFFF);\n\n\t/* Calculate RR arrival time for DLRR */\n\tpj_get_timestamp(&sess->rx_lrr_time);\n\n\tTRACE_((sess->name, \"Rx RTCP SR: ntp_ts=%p\", sess->rx_lrr,\n\t       (pj_uint32_t)(sess->rx_lrr_time.u64*65536/\n\t\t\t     sess->rtcp_session->ts_freq.u64)));\n    }\n\n    /* Receiving DLRR */\n    if (rb_dlrr) {\n\tpj_uint32_t lrr, now, dlrr;\n\tpj_uint64_t eedelay;\n\tpjmedia_rtcp_ntp_rec ntp;\n\n\t/* LRR is the middle 32bit of NTP. It has 1/65536 second \n\t * resolution \n\t */\n\tlrr = pj_ntohl(rb_dlrr->item.lrr);\n\n\t/* DLRR is delay since LRR, also in 1/65536 resolution */\n\tdlrr = pj_ntohl(rb_dlrr->item.dlrr);\n\n\t/* Get current time, and convert to 1/65536 resolution */\n\tpjmedia_rtcp_get_ntp_time(sess->rtcp_session, &ntp);\n\tnow = ((ntp.hi & 0xFFFF) << 16) + (ntp.lo >> 16);\n\n\t/* End-to-end delay is (now-lrr-dlrr) */\n\teedelay = now - lrr - dlrr;\n\n\t/* Convert end to end delay to usec (keeping the calculation in\n         * 64bit space)::\n\t *   sess->ee_delay = (eedelay * 1000) / 65536;\n\t */\n\tif (eedelay < 4294) {\n\t    eedelay = (eedelay * 1000000) >> 16;\n\t} else {\n\t    eedelay = (eedelay * 1000) >> 16;\n\t    eedelay *= 1000;\n\t}\n\n\tTRACE_((sess->name, \"Rx RTCP XR DLRR: lrr=%p, dlrr=%p (%d:%03dms), \"\n\t\t\t   \"now=%p, rtt=%p\",\n\t\tlrr, dlrr, dlrr/65536, (dlrr%65536)*1000/65536,\n\t\tnow, (pj_uint32_t)eedelay));\n\t\n\t/* Only save calculation if \"now\" is greater than lrr, or\n\t * otherwise rtt will be invalid \n\t */\n\tif (now-dlrr >= lrr) {\n\t    unsigned rtt = (pj_uint32_t)eedelay;\n\t    \n\t    /* Check that eedelay value really makes sense. \n\t     * We allow up to 30 seconds RTT!\n\t     */\n\t    if (eedelay <= 30 * 1000 * 1000UL) {\n\t\t/* \"Normalize\" rtt value that is exceptionally high.\n\t\t * For such values, \"normalize\" the rtt to be three times\n\t\t * the average value.\n\t\t */\n\t\tif (rtt>((unsigned)sess->stat.rtt.mean*3) && sess->stat.rtt.n!=0)\n\t\t{\n\t\t    unsigned orig_rtt = rtt;\n\t\t    rtt = (unsigned)sess->stat.rtt.mean*3;\n\t\t    PJ_LOG(5,(sess->name, \n\t\t\t      \"RTT value %d usec is normalized to %d usec\",\n\t\t\t      orig_rtt, rtt));\n\t\t}\n    \t\n\t\tTRACE_((sess->name, \"RTCP RTT is set to %d usec\", rtt));\n\t\tpj_math_stat_update(&sess->stat.rtt, rtt);\n\t    }\n\t} else {\n\t    PJ_LOG(5, (sess->name, \"Internal RTCP NTP clock skew detected: \"\n\t\t\t\t   \"lrr=%p, now=%p, dlrr=%p (%d:%03dms), \"\n\t\t\t\t   \"diff=%d\",\n\t\t\t\t   lrr, now, dlrr, dlrr/65536,\n\t\t\t\t   (dlrr%65536)*1000/65536,\n\t\t\t\t   dlrr-(now-lrr)));\n\t}\n    }\n\n    /* Receiving Statistics Summary */\n    if (rb_stats) {\n\tpj_uint8_t flags = rb_stats->header.specific;\n\n\tpj_bzero(&sess->stat.tx.stat_sum, sizeof(sess->stat.tx.stat_sum));\n\n\t/* Range of packets sequence reported in this blocks */\n\tsess->stat.tx.stat_sum.begin_seq = pj_ntohs(rb_stats->begin_seq);\n\tsess->stat.tx.stat_sum.end_seq   = pj_ntohs(rb_stats->end_seq);\n\n\t/* Get flags of valid fields */\n\tsess->stat.tx.stat_sum.l = (flags & (1 << 7)) != 0;\n\tsess->stat.tx.stat_sum.d = (flags & (1 << 6)) != 0;\n\tsess->stat.tx.stat_sum.j = (flags & (1 << 5)) != 0;\n\tsess->stat.tx.stat_sum.t = (flags & (3 << 3)) != 0;\n\n\t/* Fetch the reports info */\n\tif (sess->stat.tx.stat_sum.l) {\n\t    sess->stat.tx.stat_sum.lost = pj_ntohl(rb_stats->lost);\n\t}\n\n\tif (sess->stat.tx.stat_sum.d) {\n\t    sess->stat.tx.stat_sum.dup = pj_ntohl(rb_stats->dup);\n\t}\n\n\tif (sess->stat.tx.stat_sum.j) {\n\t    sess->stat.tx.stat_sum.jitter.min = pj_ntohl(rb_stats->jitter_min);\n\t    sess->stat.tx.stat_sum.jitter.max = pj_ntohl(rb_stats->jitter_max);\n\t    sess->stat.tx.stat_sum.jitter.mean= pj_ntohl(rb_stats->jitter_mean);\n\t    pj_math_stat_set_stddev(&sess->stat.tx.stat_sum.jitter, \n\t\t\t\t    pj_ntohl(rb_stats->jitter_dev));\n\t}\n\n\tif (sess->stat.tx.stat_sum.t) {\n\t    sess->stat.tx.stat_sum.toh.min = rb_stats->toh_min;\n\t    sess->stat.tx.stat_sum.toh.max = rb_stats->toh_max;\n\t    sess->stat.tx.stat_sum.toh.mean= rb_stats->toh_mean;\n\t    pj_math_stat_set_stddev(&sess->stat.tx.stat_sum.toh, \n\t\t\t\t    pj_ntohl(rb_stats->toh_dev));\n\t}\n\n\tpj_gettimeofday(&sess->stat.tx.stat_sum.update);\n    }\n\n    /* Receiving VoIP Metrics */\n    if (rb_voip_mtc) {\n\tsess->stat.tx.voip_mtc.loss_rate = rb_voip_mtc->loss_rate;\n\tsess->stat.tx.voip_mtc.discard_rate = rb_voip_mtc->discard_rate;\n\tsess->stat.tx.voip_mtc.burst_den = rb_voip_mtc->burst_den;\n\tsess->stat.tx.voip_mtc.gap_den = rb_voip_mtc->gap_den;\n\tsess->stat.tx.voip_mtc.burst_dur = pj_ntohs(rb_voip_mtc->burst_dur);\n\tsess->stat.tx.voip_mtc.gap_dur = pj_ntohs(rb_voip_mtc->gap_dur);\n\tsess->stat.tx.voip_mtc.rnd_trip_delay = \n\t\t\t\t\tpj_ntohs(rb_voip_mtc->rnd_trip_delay);\n\tsess->stat.tx.voip_mtc.end_sys_delay = \n\t\t\t\t\tpj_ntohs(rb_voip_mtc->end_sys_delay);\n\t/* signal & noise level encoded in two's complement form */\n\tsess->stat.tx.voip_mtc.signal_lvl = (pj_int8_t)\n\t\t\t\t    ((rb_voip_mtc->signal_lvl > 127)?\n\t\t\t\t     ((int)rb_voip_mtc->signal_lvl - 256) : \n\t\t\t\t     rb_voip_mtc->signal_lvl);\n\tsess->stat.tx.voip_mtc.noise_lvl  = (pj_int8_t)\n\t\t\t\t    ((rb_voip_mtc->noise_lvl > 127)?\n\t\t\t\t     ((int)rb_voip_mtc->noise_lvl - 256) : \n\t\t\t\t     rb_voip_mtc->noise_lvl);\n\tsess->stat.tx.voip_mtc.rerl = rb_voip_mtc->rerl;\n\tsess->stat.tx.voip_mtc.gmin = rb_voip_mtc->gmin;\n\tsess->stat.tx.voip_mtc.r_factor = rb_voip_mtc->r_factor;\n\tsess->stat.tx.voip_mtc.ext_r_factor = rb_voip_mtc->ext_r_factor;\n\tsess->stat.tx.voip_mtc.mos_lq = rb_voip_mtc->mos_lq;\n\tsess->stat.tx.voip_mtc.mos_cq = rb_voip_mtc->mos_cq;\n\tsess->stat.tx.voip_mtc.rx_config = rb_voip_mtc->rx_config;\n\tsess->stat.tx.voip_mtc.jb_nom = pj_ntohs(rb_voip_mtc->jb_nom);\n\tsess->stat.tx.voip_mtc.jb_max = pj_ntohs(rb_voip_mtc->jb_max);\n\tsess->stat.tx.voip_mtc.jb_abs_max = pj_ntohs(rb_voip_mtc->jb_abs_max);\n\n\tpj_gettimeofday(&sess->stat.tx.voip_mtc.update);\n    }\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <pjmedia/errno.h>\n#include <pjmedia/rtcp.h>\n#include <pj/assert.h>\n#include <pj/os.h>\n#include <pj/string.h>\n#include <pjmedia/rtcp_xr.h>\n#include <pj/sock.h>\n#include <pj/log.h>\n"
  },
  {
    "repository": "linux",
    "cve_id": "CVE-2022-26490",
    "cwe_list": [
      "CWE-120"
    ],
    "commit_hash": "4fbcc1a4cb20fe26ad0225679c536c80f1648221",
    "short_hash": "4fbcc1a4",
    "vulnerableMethods_before": [
      {
        "filename": "se.c",
        "method_name": "vulnerable_function",
        "raw_code": "int st21nfca_connectivity_event_received(struct nfc_hci_dev *hdev, u8 host,\n\t\t\t\tu8 event, struct sk_buff *skb)\n{\n\tint r = 0;\n\tstruct device *dev = &hdev->ndev->dev;\n\tstruct nfc_evt_transaction *transaction;\n\n\tpr_debug(\"connectivity gate event: %x\\n\", event);\n\n\tswitch (event) {\n\tcase ST21NFCA_EVT_CONNECTIVITY:\n\t\tr = nfc_se_connectivity(hdev->ndev, host);\n\tbreak;\n\tcase ST21NFCA_EVT_TRANSACTION:\n\t\t/*\n\t\t * According to specification etsi 102 622\n\t\t * 11.2.2.4 EVT_TRANSACTION Table 52\n\t\t * Description\tTag\tLength\n\t\t * AID\t\t81\t5 to 16\n\t\t * PARAMETERS\t82\t0 to 255\n\t\t */\n\t\tif (skb->len < NFC_MIN_AID_LENGTH + 2 &&\n\t\t    skb->data[0] != NFC_EVT_TRANSACTION_AID_TAG)\n\t\t\treturn -EPROTO;\n\n\t\ttransaction = devm_kzalloc(dev, skb->len - 2, GFP_KERNEL);\n\t\tif (!transaction)\n\t\t\treturn -ENOMEM;\n\n\t\ttransaction->aid_len = skb->data[1];\n\t\tmemcpy(transaction->aid, &skb->data[2],\n\t\t       transaction->aid_len);\n\n\t\t/* Check next byte is PARAMETERS tag (82) */\n\t\tif (skb->data[transaction->aid_len + 2] !=\n\t\t    NFC_EVT_TRANSACTION_PARAMS_TAG)\n\t\t\treturn -EPROTO;\n\n\t\ttransaction->params_len = skb->data[transaction->aid_len + 3];\n\t\tmemcpy(transaction->params, skb->data +\n\t\t       transaction->aid_len + 4, transaction->params_len);\n\n\t\tr = nfc_se_transaction(hdev->ndev, host, transaction);\n\tbreak;\n\tdefault:\n\t\tnfc_err(&hdev->ndev->dev, \"Unexpected event on connectivity gate\\n\");\n\t\treturn 1;\n\t}\n\tkfree_skb(skb);\n\treturn r;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "se.c",
        "method_name": "fixed_function",
        "raw_code": "int st21nfca_connectivity_event_received(struct nfc_hci_dev *hdev, u8 host,\n\t\t\t\tu8 event, struct sk_buff *skb)\n{\n\tint r = 0;\n\tstruct device *dev = &hdev->ndev->dev;\n\tstruct nfc_evt_transaction *transaction;\n\n\tpr_debug(\"connectivity gate event: %x\\n\", event);\n\n\tswitch (event) {\n\tcase ST21NFCA_EVT_CONNECTIVITY:\n\t\tr = nfc_se_connectivity(hdev->ndev, host);\n\tbreak;\n\tcase ST21NFCA_EVT_TRANSACTION:\n\t\t/*\n\t\t * According to specification etsi 102 622\n\t\t * 11.2.2.4 EVT_TRANSACTION Table 52\n\t\t * Description\tTag\tLength\n\t\t * AID\t\t81\t5 to 16\n\t\t * PARAMETERS\t82\t0 to 255\n\t\t */\n\t\tif (skb->len < NFC_MIN_AID_LENGTH + 2 &&\n\t\t    skb->data[0] != NFC_EVT_TRANSACTION_AID_TAG)\n\t\t\treturn -EPROTO;\n\n\t\ttransaction = devm_kzalloc(dev, skb->len - 2, GFP_KERNEL);\n\t\tif (!transaction)\n\t\t\treturn -ENOMEM;\n\n\t\ttransaction->aid_len = skb->data[1];\n\n\t\t/* Checking if the length of the AID is valid */\n\t\tif (transaction->aid_len > sizeof(transaction->aid))\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(transaction->aid, &skb->data[2],\n\t\t       transaction->aid_len);\n\n\t\t/* Check next byte is PARAMETERS tag (82) */\n\t\tif (skb->data[transaction->aid_len + 2] !=\n\t\t    NFC_EVT_TRANSACTION_PARAMS_TAG)\n\t\t\treturn -EPROTO;\n\n\t\ttransaction->params_len = skb->data[transaction->aid_len + 3];\n\n\t\t/* Total size is allocated (skb->len - 2) minus fixed array members */\n\t\tif (transaction->params_len > ((skb->len - 2) - sizeof(struct nfc_evt_transaction)))\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(transaction->params, skb->data +\n\t\t       transaction->aid_len + 4, transaction->params_len);\n\n\t\tr = nfc_se_transaction(hdev->ndev, host, transaction);\n\tbreak;\n\tdefault:\n\t\tnfc_err(&hdev->ndev->dev, \"Unexpected event on connectivity gate\\n\");\n\t\treturn 1;\n\t}\n\tkfree_skb(skb);\n\treturn r;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <net/nfc/hci.h>\n#include \"st21nfca.h\"\n\n// Type Definitions:\n// nfc_hci_dev:\nstruct nfc_hci_dev\n\n// sk_buff:\nstruct sk_buff\n"
  },
  {
    "repository": "linux",
    "cve_id": "CVE-2021-43267",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "fa40d9734a57bcbfa79a280189799f76c88f7bb0",
    "short_hash": "fa40d973",
    "vulnerableMethods_before": [
      {
        "filename": "crypto.c",
        "method_name": "vulnerable_function",
        "raw_code": "static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)\n{\n\tstruct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;\n\tstruct tipc_aead_key *skey = NULL;\n\tu16 key_gen = msg_key_gen(hdr);\n\tu16 size = msg_data_sz(hdr);\n\tu8 *data = msg_data(hdr);\n\n\tspin_lock(&rx->lock);\n\tif (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {\n\t\tpr_err(\"%s: key existed <%p>, gen %d vs %d\\n\", rx->name,\n\t\t       rx->skey, key_gen, rx->key_gen);\n\t\tgoto exit;\n\t}\n\n\t/* Allocate memory for the key */\n\tskey = kmalloc(size, GFP_ATOMIC);\n\tif (unlikely(!skey)) {\n\t\tpr_err(\"%s: unable to allocate memory for skey\\n\", rx->name);\n\t\tgoto exit;\n\t}\n\n\t/* Copy key from msg data */\n\tskey->keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));\n\tmemcpy(skey->alg_name, data, TIPC_AEAD_ALG_NAME);\n\tmemcpy(skey->key, data + TIPC_AEAD_ALG_NAME + sizeof(__be32),\n\t       skey->keylen);\n\n\t/* Sanity check */\n\tif (unlikely(size != tipc_aead_key_size(skey))) {\n\t\tkfree(skey);\n\t\tskey = NULL;\n\t\tgoto exit;\n\t}\n\n\trx->key_gen = key_gen;\n\trx->skey_mode = msg_key_mode(hdr);\n\trx->skey = skey;\n\trx->nokey = 0;\n\tmb(); /* for nokey flag */\n\nexit:\n\tspin_unlock(&rx->lock);\n\n\t/* Schedule the key attaching on this crypto */\n\tif (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))\n\t\treturn true;\n\n\treturn false;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "crypto.c",
        "method_name": "fixed_function",
        "raw_code": "static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)\n{\n\tstruct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;\n\tstruct tipc_aead_key *skey = NULL;\n\tu16 key_gen = msg_key_gen(hdr);\n\tu16 size = msg_data_sz(hdr);\n\tu8 *data = msg_data(hdr);\n\tunsigned int keylen;\n\n\t/* Verify whether the size can exist in the packet */\n\tif (unlikely(size < sizeof(struct tipc_aead_key) + TIPC_AEAD_KEYLEN_MIN)) {\n\t\tpr_debug(\"%s: message data size is too small\\n\", rx->name);\n\t\tgoto exit;\n\t}\n\n\tkeylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));\n\n\t/* Verify the supplied size values */\n\tif (unlikely(size != keylen + sizeof(struct tipc_aead_key) ||\n\t\t     keylen > TIPC_AEAD_KEY_SIZE_MAX)) {\n\t\tpr_debug(\"%s: invalid MSG_CRYPTO key size\\n\", rx->name);\n\t\tgoto exit;\n\t}\n\n\tspin_lock(&rx->lock);\n\tif (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {\n\t\tpr_err(\"%s: key existed <%p>, gen %d vs %d\\n\", rx->name,\n\t\t       rx->skey, key_gen, rx->key_gen);\n\t\tgoto exit_unlock;\n\t}\n\n\t/* Allocate memory for the key */\n\tskey = kmalloc(size, GFP_ATOMIC);\n\tif (unlikely(!skey)) {\n\t\tpr_err(\"%s: unable to allocate memory for skey\\n\", rx->name);\n\t\tgoto exit_unlock;\n\t}\n\n\t/* Copy key from msg data */\n\tskey->keylen = keylen;\n\tmemcpy(skey->alg_name, data, TIPC_AEAD_ALG_NAME);\n\tmemcpy(skey->key, data + TIPC_AEAD_ALG_NAME + sizeof(__be32),\n\t       skey->keylen);\n\n\trx->key_gen = key_gen;\n\trx->skey_mode = msg_key_mode(hdr);\n\trx->skey = skey;\n\trx->nokey = 0;\n\tmb(); /* for nokey flag */\n\nexit_unlock:\n\tspin_unlock(&rx->lock);\n\nexit:\n\t/* Schedule the key attaching on this crypto */\n\tif (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))\n\t\treturn true;\n\n\treturn false;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <crypto/rng.h>\n#include \"msg.h\"\n#include \"crypto.h\"\n#include <crypto/aes.h>\n#include <crypto/aead.h>\n#include \"bcast.h\"\n\n// Type Definitions:\n// tipc_msg:\nstruct tipc_msg\n\n// tipc_crypto:\nstruct tipc_crypto\n\n// tipc_msg:\nstruct tipc_msg {\n\t__be32 hdr[15];\n}\n\n// tipc_aead_key:\nstruct tipc_aead_key\n\n// __be32:\ntypedef __u32 __bitwise __be32;\n\n// tipc_crypto:\nstruct tipc_crypto {\n\tstruct net *net;\n\tstruct tipc_node *node;\n\tstruct tipc_aead __rcu *aead[KEY_MAX + 1];\n\tatomic_t peer_rx_active;\n\tu16 key_gen;\n\tstruct tipc_key key;\n\tu8 skey_mode;\n\tstruct tipc_aead_key *skey;\n\tstruct workqueue_struct *wq;\n\tstruct delayed_work work;\n#define KEY_DISTR_SCHED\t\t1\n#define KEY_DISTR_COMPL\t\t2\n\tatomic_t key_distr;\n\tu32 rekeying_intv;\n\n\tstruct tipc_crypto_stats __percpu *stats;\n\tchar name[48];\n\n\tatomic64_t sndnxt ____cacheline_aligned;\n\tunsigned long timer1;\n\tunsigned long timer2;\n\tunion {\n\t\tstruct {\n\t\t\tu8 working:1;\n\t\t\tu8 key_master:1;\n\t\t\tu8 legacy_user:1;\n\t\t\tu8 nokey: 1;\n\t\t};\n\t\tu8 flags;\n\t};\n\tspinlock_t lock; /* crypto lock */\n\n}\n\n// Called Methods (top 10):\n// memcpy from crypto/aegis128-neon-inner.c:\nvoid *memcpy(void *dest, const void *src, size_t n); /* <=== memcpy */ \n\n// msg_bits from net/tipc/msg.h:\nstatic inline u32 msg_bits(struct tipc_msg *m, u32 w, u32 pos, u32 mask) /* <=== msg_bits */ \n{\n\treturn (msg_word(m, w) >> pos) & mask;\n}\n\n// msg_size from net/tipc/msg.h:\nstatic inline u32 msg_size(struct tipc_msg *m) /* <=== msg_size */ \n{\n\treturn msg_bits(m, 0, 0, 0x1ffff);\n}\n\n// msg_key_gen from net/tipc/crypto.h:\nstatic inline u32 msg_key_gen(struct tipc_msg *m) /* <=== msg_key_gen */ \n{\n\treturn msg_bits(m, 4, 16, 0xffff);\n}\n\n// msg_hdr_sz from net/tipc/msg.h:\nstatic inline u32 msg_hdr_sz(struct tipc_msg *m) /* <=== msg_hdr_sz */ \n{\n\treturn msg_bits(m, 0, 21, 0xf) << 2;\n}\n\n// msg_key_mode from net/tipc/crypto.h:\nstatic inline u32 msg_key_mode(struct tipc_msg *m) /* <=== msg_key_mode */ \n{\n\treturn msg_bits(m, 4, 0, 0xf);\n}\n\n// msg_data from net/tipc/msg.h:\nstatic inline unchar *msg_data(struct tipc_msg *m) /* <=== msg_data */ \n{\n\treturn ((unchar *)m) + msg_hdr_sz(m);\n}\n\n// msg_data_sz from net/tipc/msg.h:\nstatic inline u32 msg_data_sz(struct tipc_msg *m) /* <=== msg_data_sz */ \n{\n\treturn msg_size(m) - msg_hdr_sz(m);\n}\n"
  },
  {
    "repository": "libtpms",
    "cve_id": "CVE-2021-3746",
    "cwe_list": [
      "CWE-119"
    ],
    "commit_hash": "ea62fd9679f8c6fc5e79471b33cfbd8227bfed72",
    "short_hash": "ea62fd96",
    "vulnerableMethods_before": [
      {
        "filename": "Object.c",
        "method_name": "vulnerable_function",
        "raw_code": "FindEmptyObjectSlot(\n\t\t    TPMI_DH_OBJECT  *handle         // OUT: (optional)\n\t\t    )\n{\n    UINT32               i;\n    OBJECT              *object;\n    for(i = 0; i < MAX_LOADED_OBJECTS; i++)\n\t{\n\t    object = &s_objects[i];\n\t    if(object->attributes.occupied == CLEAR)\n\t\t{\n\t\t    if(handle)\n\t\t\t*handle = i + TRANSIENT_FIRST;\n\t\t    // Initialize the object attributes\n\t\t    MemorySet(&object->attributes, 0, sizeof(OBJECT_ATTRIBUTES));\n\t\t    return object;\n\t\t}\n\t}\n    return NULL;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "Object.c",
        "method_name": "fixed_function",
        "raw_code": "FindEmptyObjectSlot(\n\t\t    TPMI_DH_OBJECT  *handle         // OUT: (optional)\n\t\t    )\n{\n    UINT32               i;\n    OBJECT              *object;\n    for(i = 0; i < MAX_LOADED_OBJECTS; i++)\n\t{\n\t    object = &s_objects[i];\n\t    if(object->attributes.occupied == CLEAR)\n\t\t{\n\t\t    if(handle)\n\t\t\t*handle = i + TRANSIENT_FIRST;\n\t\t    // Initialize the object attributes\n\t\t    // MemorySet(&object->attributes, 0, sizeof(OBJECT_ATTRIBUTES));\n\t\t    MemorySet(object, 0, sizeof(*object)); // libtpms added: Initialize the whole object\n\t\t    return object;\n\t\t}\n\t}\n    return NULL;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"Tpm.h\"\n\n// Type Definitions:\n// UINT32:\ntypedef  uint32_t           UINT32;\n\n// OBJECT_ATTRIBUTES:\ntypedef struct\n{\n#if LITTLE_ENDIAN_TPM == YES                          /* libtpms added */\n    unsigned            publicOnly : 1;     //0) SET if only the public portion of\n    //   an object is loaded\n    unsigned            epsHierarchy : 1;   //1) SET if the object belongs to EPS\n    //   Hierarchy\n    unsigned            ppsHierarchy : 1;   //2) SET if the object belongs to PPS\n    //   Hierarchy\n    unsigned            spsHierarchy : 1;   //3) SET f the object belongs to SPS\n    //   Hierarchy\n    unsigned            evict : 1;          //4) SET if the object is a platform or\n    //   owner evict object.  Platform-\n    //   evict object belongs to PPS\n    //   hierarchy, owner-evict object\n    //   belongs to SPS or EPS hierarchy.\n    //   This bit is also used to mark a\n    //   completed sequence object so it\n    //   will be flush when the\n    //   SequenceComplete command succeeds.\n    unsigned            primary : 1;        //5) SET for a primary object\n    unsigned      ...\n\n// OBJECT:\ntypedef struct OBJECT\n{\n    // The attributes field is required to be first followed by the publicArea.\n    // This allows the overlay of the object structure and a sequence structure\n    OBJECT_ATTRIBUTES   attributes;         // object attributes\n    TPMT_PUBLIC         publicArea;         // public area of an object\n    TPMT_SENSITIVE      sensitive;          // sensitive area of an object\n#if ALG_RSA\n    privateExponent_t   privateExponent;    // Additional field for the private\n#endif\n    TPM2B_NAME          qualifiedName;      // object qualified name\n    TPMI_DH_OBJECT      evictHandle;        // if the object is an evict object,\n    // the original handle is kept here.\n    // The 'working' handle will be the\n    // handle of an object slot.\n    TPM2B_NAME          name;               // Name of the object name. Kept here\n    // to avoid repeatedly computing it.\n\n    // libtpms added: OBJECT lies in NVRAM; to avoid that it needs different number\n    // of bytes on 32 bit and ...\n\n// Called Methods (top 10):\n// CLEAR from src/tpm2/Implementation.h:\n<empty>\n\n// MAX_LOADED_OBJECTS from src/tpm2/Implementation.h:\n<empty>\n\n// MemorySet from src/tpm2/Memory.c:\nvoid\nMemorySet(\n\t  void            *dest,\n\t  int              value,\n\t  size_t           size\n\t  )\n{\n    memset(dest, value, size);\n}\n"
  },
  {
    "repository": "tensorflow",
    "cve_id": "CVE-2022-23558",
    "cwe_list": [
      "CWE-190"
    ],
    "commit_hash": "a1e1511dde36b3f8aa27a6ec630838e7ea40e091",
    "short_hash": "a1e1511d",
    "vulnerableMethods_before": [
      {
        "filename": "common.c",
        "method_name": "vulnerable_function",
        "raw_code": "TfLiteIntArray* TfLiteIntArrayCreate(int size) {\n  int alloc_size = TfLiteIntArrayGetSizeInBytes(size);\n  if (alloc_size <= 0) return NULL;\n  TfLiteIntArray* ret = (TfLiteIntArray*)malloc(alloc_size);\n  if (!ret) return ret;\n  ret->size = size;\n  return ret;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "common.c",
        "method_name": "fixed_function",
        "raw_code": "TfLiteIntArray* TfLiteIntArrayCreate(int size) {\n  size_t alloc_size = TfLiteIntArrayGetSizeInBytes(size);\n  if (alloc_size <= 0) return NULL;\n  TfLiteIntArray* ret = (TfLiteIntArray*)malloc(alloc_size);\n  if (!ret) return ret;\n  ret->size = size;\n  return ret;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"tensorflow/lite/c/common.h\"\n#include <stdlib.h>\n#include \"tensorflow/lite/c/c_api_types.h\"\n#include <string.h>\n\n// Type Definitions:\n// TfLiteIntArray:\ntypedef struct TfLiteIntArray {\n  int size;\n\n#if defined(_MSC_VER)\n  // Context for why this is needed is in http://b/189926408#comment21\n  int data[1];\n#elif (!defined(__clang__) && defined(__GNUC__) && __GNUC__ == 6 && \\\n       __GNUC_MINOR__ >= 1) ||                                      \\\n    defined(HEXAGON) ||                                             \\\n    (defined(__clang__) && __clang_major__ == 7 && __clang_minor__ == 1)\n  // gcc 6.1+ have a bug where flexible members aren't properly handled\n  // https://github.com/google/re2/commit/b94b7cd42e9f02673cd748c1ac1d16db4052514c\n  int data[0];\n#else\n  int data[];\n#endif\n}\n\n// TfLiteIntArray:\ntypedef struct TfLiteIntArray {\n  int size;\n\n#if defined(_MSC_VER)\n  // Context for why this is needed is in http://b/189926408#comment21\n  int data[1];\n#elif (!defined(__clang__) && defined(__GNUC__) && __GNUC__ == 6 && \\\n       __GNUC_MINOR__ >= 1) ||                                      \\\n    defined(HEXAGON) ||                                             \\\n    (defined(__clang__) && __clang_major__ == 7 && __clang_minor__ == 1)\n  // gcc 6.1+ have a bug where flexible members aren't properly handled\n  // https://github.com/google/re2/commit/b94b7cd42e9f02673cd748c1ac1d16db4052514c\n  int data[0];\n#else\n  int data[];\n#endif\n} TfLiteIntArray;\n\n// Called Methods (top 10):\n// TfLiteIntArrayGetSizeInBytes from tensorflow/lite/c/common.c:\n\n"
  },
  {
    "repository": "frr",
    "cve_id": "CVE-2022-37032",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "ff6db1027f8f36df657ff2e5ea167773752537ed",
    "short_hash": "ff6db102",
    "vulnerableMethods_before": [
      {
        "filename": "bgp_packet.c",
        "method_name": "vulnerable_function",
        "raw_code": "static int bgp_capability_msg_parse(struct peer *peer, uint8_t *pnt,\n\t\t\t\t    bgp_size_t length)\n{\n\tuint8_t *end;\n\tstruct capability_mp_data mpc;\n\tstruct capability_header *hdr;\n\tuint8_t action;\n\tiana_afi_t pkt_afi;\n\tafi_t afi;\n\tiana_safi_t pkt_safi;\n\tsafi_t safi;\n\n\tend = pnt + length;\n\n\twhile (pnt < end) {\n\t\t/* We need at least action, capability code and capability\n\t\t * length. */\n\t\tif (pnt + 3 > end) {\n\t\t\tzlog_info(\"%s Capability length error\", peer->host);\n\t\t\tbgp_notify_send(peer, BGP_NOTIFY_CEASE,\n\t\t\t\t\tBGP_NOTIFY_SUBCODE_UNSPECIFIC);\n\t\t\treturn BGP_Stop;\n\t\t}\n\t\taction = *pnt;\n\t\thdr = (struct capability_header *)(pnt + 1);\n\n\t\t/* Action value check.  */\n\t\tif (action != CAPABILITY_ACTION_SET\n\t\t    && action != CAPABILITY_ACTION_UNSET) {\n\t\t\tzlog_info(\"%s Capability Action Value error %d\",\n\t\t\t\t  peer->host, action);\n\t\t\tbgp_notify_send(peer, BGP_NOTIFY_CEASE,\n\t\t\t\t\tBGP_NOTIFY_SUBCODE_UNSPECIFIC);\n\t\t\treturn BGP_Stop;\n\t\t}\n\n\t\tif (bgp_debug_neighbor_events(peer))\n\t\t\tzlog_debug(\n\t\t\t\t\"%s CAPABILITY has action: %d, code: %u, length %u\",\n\t\t\t\tpeer->host, action, hdr->code, hdr->length);\n\n\t\t/* Capability length check. */\n\t\tif ((pnt + hdr->length + 3) > end) {\n\t\t\tzlog_info(\"%s Capability length error\", peer->host);\n\t\t\tbgp_notify_send(peer, BGP_NOTIFY_CEASE,\n\t\t\t\t\tBGP_NOTIFY_SUBCODE_UNSPECIFIC);\n\t\t\treturn BGP_Stop;\n\t\t}\n\n\t\t/* Fetch structure to the byte stream. */\n\t\tmemcpy(&mpc, pnt + 3, sizeof(struct capability_mp_data));\n\t\tpnt += hdr->length + 3;\n\n\t\t/* We know MP Capability Code. */\n\t\tif (hdr->code == CAPABILITY_CODE_MP) {\n\t\t\tpkt_afi = ntohs(mpc.afi);\n\t\t\tpkt_safi = mpc.safi;\n\n\t\t\t/* Ignore capability when override-capability is set. */\n\t\t\tif (CHECK_FLAG(peer->flags,\n\t\t\t\t       PEER_FLAG_OVERRIDE_CAPABILITY))\n\t\t\t\tcontinue;\n\n\t\t\t/* Convert AFI, SAFI to internal values. */\n\t\t\tif (bgp_map_afi_safi_iana2int(pkt_afi, pkt_safi, &afi,\n\t\t\t\t\t\t      &safi)) {\n\t\t\t\tif (bgp_debug_neighbor_events(peer))\n\t\t\t\t\tzlog_debug(\n\t\t\t\t\t\t\"%s Dynamic Capability MP_EXT afi/safi invalid (%s/%s)\",\n\t\t\t\t\t\tpeer->host,\n\t\t\t\t\t\tiana_afi2str(pkt_afi),\n\t\t\t\t\t\tiana_safi2str(pkt_safi));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Address family check.  */\n\t\t\tif (bgp_debug_neighbor_events(peer))\n\t\t\t\tzlog_debug(\n\t\t\t\t\t\"%s CAPABILITY has %s MP_EXT CAP for afi/safi: %s/%s\",\n\t\t\t\t\tpeer->host,\n\t\t\t\t\taction == CAPABILITY_ACTION_SET\n\t\t\t\t\t\t? \"Advertising\"\n\t\t\t\t\t\t: \"Removing\",\n\t\t\t\t\tiana_afi2str(pkt_afi),\n\t\t\t\t\tiana_safi2str(pkt_safi));\n\n\t\t\tif (action == CAPABILITY_ACTION_SET) {\n\t\t\t\tpeer->afc_recv[afi][safi] = 1;\n\t\t\t\tif (peer->afc[afi][safi]) {\n\t\t\t\t\tpeer->afc_nego[afi][safi] = 1;\n\t\t\t\t\tbgp_announce_route(peer, afi, safi,\n\t\t\t\t\t\t\t   false);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpeer->afc_recv[afi][safi] = 0;\n\t\t\t\tpeer->afc_nego[afi][safi] = 0;\n\n\t\t\t\tif (peer_active_nego(peer))\n\t\t\t\t\tbgp_clear_route(peer, afi, safi);\n\t\t\t\telse\n\t\t\t\t\treturn BGP_Stop;\n\t\t\t}\n\t\t} else {\n\t\t\tflog_warn(\n\t\t\t\tEC_BGP_UNRECOGNIZED_CAPABILITY,\n\t\t\t\t\"%s unrecognized capability code: %d - ignored\",\n\t\t\t\tpeer->host, hdr->code);\n\t\t}\n\t}\n\n\t/* No FSM action necessary */\n\treturn BGP_PACKET_NOOP;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "bgp_packet.c",
        "method_name": "fixed_function",
        "raw_code": "static int bgp_capability_msg_parse(struct peer *peer, uint8_t *pnt,\n\t\t\t\t    bgp_size_t length)\n{\n\tuint8_t *end;\n\tstruct capability_mp_data mpc;\n\tstruct capability_header *hdr;\n\tuint8_t action;\n\tiana_afi_t pkt_afi;\n\tafi_t afi;\n\tiana_safi_t pkt_safi;\n\tsafi_t safi;\n\n\tend = pnt + length;\n\n\twhile (pnt < end) {\n\t\t/* We need at least action, capability code and capability\n\t\t * length. */\n\t\tif (pnt + 3 > end) {\n\t\t\tzlog_info(\"%s Capability length error\", peer->host);\n\t\t\tbgp_notify_send(peer, BGP_NOTIFY_CEASE,\n\t\t\t\t\tBGP_NOTIFY_SUBCODE_UNSPECIFIC);\n\t\t\treturn BGP_Stop;\n\t\t}\n\t\taction = *pnt;\n\t\thdr = (struct capability_header *)(pnt + 1);\n\n\t\t/* Action value check.  */\n\t\tif (action != CAPABILITY_ACTION_SET\n\t\t    && action != CAPABILITY_ACTION_UNSET) {\n\t\t\tzlog_info(\"%s Capability Action Value error %d\",\n\t\t\t\t  peer->host, action);\n\t\t\tbgp_notify_send(peer, BGP_NOTIFY_CEASE,\n\t\t\t\t\tBGP_NOTIFY_SUBCODE_UNSPECIFIC);\n\t\t\treturn BGP_Stop;\n\t\t}\n\n\t\tif (bgp_debug_neighbor_events(peer))\n\t\t\tzlog_debug(\n\t\t\t\t\"%s CAPABILITY has action: %d, code: %u, length %u\",\n\t\t\t\tpeer->host, action, hdr->code, hdr->length);\n\n\t\tif (hdr->length < sizeof(struct capability_mp_data)) {\n\t\t\tzlog_info(\n\t\t\t\t\"%pBP Capability structure is not properly filled out, expected at least %zu bytes but header length specified is %d\",\n\t\t\t\tpeer, sizeof(struct capability_mp_data),\n\t\t\t\thdr->length);\n\t\t\treturn BGP_Stop;\n\t\t}\n\n\t\t/* Capability length check. */\n\t\tif ((pnt + hdr->length + 3) > end) {\n\t\t\tzlog_info(\"%s Capability length error\", peer->host);\n\t\t\tbgp_notify_send(peer, BGP_NOTIFY_CEASE,\n\t\t\t\t\tBGP_NOTIFY_SUBCODE_UNSPECIFIC);\n\t\t\treturn BGP_Stop;\n\t\t}\n\n\t\t/* Fetch structure to the byte stream. */\n\t\tmemcpy(&mpc, pnt + 3, sizeof(struct capability_mp_data));\n\t\tpnt += hdr->length + 3;\n\n\t\t/* We know MP Capability Code. */\n\t\tif (hdr->code == CAPABILITY_CODE_MP) {\n\t\t\tpkt_afi = ntohs(mpc.afi);\n\t\t\tpkt_safi = mpc.safi;\n\n\t\t\t/* Ignore capability when override-capability is set. */\n\t\t\tif (CHECK_FLAG(peer->flags,\n\t\t\t\t       PEER_FLAG_OVERRIDE_CAPABILITY))\n\t\t\t\tcontinue;\n\n\t\t\t/* Convert AFI, SAFI to internal values. */\n\t\t\tif (bgp_map_afi_safi_iana2int(pkt_afi, pkt_safi, &afi,\n\t\t\t\t\t\t      &safi)) {\n\t\t\t\tif (bgp_debug_neighbor_events(peer))\n\t\t\t\t\tzlog_debug(\n\t\t\t\t\t\t\"%s Dynamic Capability MP_EXT afi/safi invalid (%s/%s)\",\n\t\t\t\t\t\tpeer->host,\n\t\t\t\t\t\tiana_afi2str(pkt_afi),\n\t\t\t\t\t\tiana_safi2str(pkt_safi));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Address family check.  */\n\t\t\tif (bgp_debug_neighbor_events(peer))\n\t\t\t\tzlog_debug(\n\t\t\t\t\t\"%s CAPABILITY has %s MP_EXT CAP for afi/safi: %s/%s\",\n\t\t\t\t\tpeer->host,\n\t\t\t\t\taction == CAPABILITY_ACTION_SET\n\t\t\t\t\t\t? \"Advertising\"\n\t\t\t\t\t\t: \"Removing\",\n\t\t\t\t\tiana_afi2str(pkt_afi),\n\t\t\t\t\tiana_safi2str(pkt_safi));\n\n\t\t\tif (action == CAPABILITY_ACTION_SET) {\n\t\t\t\tpeer->afc_recv[afi][safi] = 1;\n\t\t\t\tif (peer->afc[afi][safi]) {\n\t\t\t\t\tpeer->afc_nego[afi][safi] = 1;\n\t\t\t\t\tbgp_announce_route(peer, afi, safi,\n\t\t\t\t\t\t\t   false);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpeer->afc_recv[afi][safi] = 0;\n\t\t\t\tpeer->afc_nego[afi][safi] = 0;\n\n\t\t\t\tif (peer_active_nego(peer))\n\t\t\t\t\tbgp_clear_route(peer, afi, safi);\n\t\t\t\telse\n\t\t\t\t\treturn BGP_Stop;\n\t\t\t}\n\t\t} else {\n\t\t\tflog_warn(\n\t\t\t\tEC_BGP_UNRECOGNIZED_CAPABILITY,\n\t\t\t\t\"%s unrecognized capability code: %d - ignored\",\n\t\t\t\tpeer->host, hdr->code);\n\t\t}\n\t}\n\n\t/* No FSM action necessary */\n\treturn BGP_PACKET_NOOP;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"filter.h\"\n#include \"bgpd/bgp_open.h\"\n#include \"bgpd/bgp_flowspec.h\"\n#include \"bgpd/bgp_fsm.h\"\n#include \"thread.h\"\n#include \"bgpd/bgp_mplsvpn.h\"\n#include \"sockopt.h\"\n#include \"bgpd/bgp_bmp.h\"\n#include \"bgpd/bgp_aspath.h\"\n#include \"bgpd/bgp_trace.h\"\n#include \"bgpd/bgp_errors.h\"\n#include \"bgpd/bgp_updgrp.h\"\n#include \"bgpd/bgpd.h\"\n#include \"memory.h\"\n#include \"lib_errors.h\"\n#include \"bgpd/bgp_debug.h\"\n#include \"prefix.h\"\n#include \"bgpd/bgp_network.h\"\n#include \"bgpd/bgp_vty.h\"\n#include \"linklist.h\"\n#include \"bgpd/bgp_advertise.h\"\n#include \"bgpd/bgp_attr.h\"\n#include \"bgpd/bgp_keepalives.h\"\n#include \"bgpd/bgp_community.h\"\n#include <zebra.h>\n#include \"bgpd/bgp_packet.h\"\n#include \"queue.h\"\n#include \"stream.h\"\n#include \"bgpd/bgp_table.h\"\n#include \"bgpd/bgp_lcommunity.h\"\n#include \"sockunion.h\"\n#include \"bgpd/bgp_evpn.h\"\n#include \"command.h\"\n#include \"bgpd/bgp_ecommunity.h\"\n#include \"log.h\"\n#include \"bgpd/bgp_label.h\"\n#include \"bgpd/bgp_io.h\"\n#include \"bgpd/bgp_route.h\"\n#include \"network.h\"\n#include <sys/time.h>\n#include \"bgpd/bgp_dump.h\"\n#include \"plist.h\"\n\n// Type Definitions:\n// iana_afi_t:\ntypedef enum {\n\tIANA_AFI_RESERVED = 0,\n\tIANA_AFI_IPV4 = 1,\n\tIANA_AFI_IPV6 = 2,\n\tIANA_AFI_L2VPN = 25,\n}\n\n// capability_header:\nstruct capability_header {\n\tuint8_t code;\n\tuint8_t length;\n}\n\n// peer:\nstruct peer {\n\t/* BGP structure.  */\n\tstruct bgp *bgp;\n\n\t/* reference count, primarily to allow bgp_process'ing of route_node's\n\t * to be done after a struct peer is deleted.\n\t *\n\t * named 'lock' for hysterical reasons within Quagga.\n\t */\n\tint lock;\n\n\t/* BGP peer group.  */\n\tstruct peer_group *group;\n\tuint64_t version[AFI_MAX][SAFI_MAX];\n\n\t/* BGP peer_af structures, per configured AF on this peer */\n\tstruct peer_af *peer_af_array[BGP_AF_MAX];\n\n\t/* Peer's remote AS number. */\n\tint as_type;\n\tas_t as;\n\n\t/* Peer's local AS number. */\n\tas_t local_as;\n\n\tenum bgp_peer_sort sort;\n\n\t/* Peer's Change local AS number. */\n\tas_t change_local_as;\n\n\t/* Remote router ID. */\n\tstruct in_addr remote_id;\n\n\t/* Local router ID. */\n\tstruct in_addr local_id;\n\n\t/* Packet receive and send buffer. */\n\tpthread_mutex_t io_mtx;   // guards ibuf, obuf\n\tstruct stream_fifo *ibuf; // packets waiting to be processed\n\tstruct stream_fifo *obuf; // packets waiting to be written\n\n\t/* used as a block to deposit raw wire d...\n\n// xref_logmsg:\nconst struct xref_logmsg\n\n// iana_safi_t:\ntypedef enum {\n\tIANA_SAFI_RESERVED = 0,\n\tIANA_SAFI_UNICAST = 1,\n\tIANA_SAFI_MULTICAST = 2,\n\tIANA_SAFI_LABELED_UNICAST = 4,\n\tIANA_SAFI_ENCAP = 7,\n\tIANA_SAFI_EVPN = 70,\n\tIANA_SAFI_MPLS_VPN = 128,\n\tIANA_SAFI_FLOWSPEC = 133\n}\n\n// bgp_size_t:\ntypedef uint16_t bgp_size_t;\n\n// xref:\nstruct xref {\n\t/* this may be NULL, depending on the type of the xref.\n\t * if it is NULL, the xref has no unique ID and cannot be accessed\n\t * through that mechanism.\n\t */\n\tstruct xrefdata *xrefdata;\n\n\t/* type isn't generally needed at runtime */\n\tenum xref_type type;\n\n\t/* code location */\n\tint line;\n\tconst char *file;\n\tconst char *func;\n\n\t/* -- 32 bytes (on 64bit) -- */\n\n\t/* type-specific bits appended by embedding this struct */\n}\n\n// xref:\nstatic const xref\n\n// peer:\nstruct peer\n\n// xrefdata_logmsg:\nstruct xrefdata_logmsg {\n\tstruct xrefdata xrefdata;\n\n\tuint8_t fl_print_bt;\n}\n\n// afi_t:\ntypedef enum {\n\tAFI_UNSPEC = 0,\n\tAFI_IP = 1,\n\tAFI_IP6 = 2,\n\tAFI_L2VPN = 3,\n\tAFI_MAX = 4\n}\n\n// safi_t:\ntypedef enum {\n\tSAFI_UNSPEC = 0,\n\tSAFI_UNICAST = 1,\n\tSAFI_MULTICAST = 2,\n\tSAFI_MPLS_VPN = 3,\n\tSAFI_ENCAP = 4,\n\tSAFI_EVPN = 5,\n\tSAFI_LABELED_UNICAST = 6,\n\tSAFI_FLOWSPEC = 7,\n\tSAFI_MAX = 8\n}\n\n// xref_logmsg:\nstruct xref_logmsg {\n\tstruct xref xref;\n\n\tconst char *fmtstring;\n\tuint32_t priority;\n\tuint32_t ec;\n\tconst char *args;\n}\n\n// capability_mp_data:\nstruct capability_mp_data {\n\tuint16_t afi; /* iana_afi_t */\n\tuint8_t reserved;\n\tuint8_t safi; /* iana_safi_t */\n}\n\n// Called Methods (top 10):\n// bgp_map_afi_safi_iana2int from bgpd/bgpd.c:\nint bgp_map_afi_safi_iana2int(iana_afi_t pkt_afi, iana_safi_t pkt_safi,\n\t\t\t      afi_t *afi, safi_t *safi)\n{\n\t/* Map from IANA values to internal values, return error if\n\t * values are unrecognized.\n\t */\n\t*afi = afi_iana2int(pkt_afi);\n\t*safi = safi_iana2int(pkt_safi);\n\tif (*afi == AFI_MAX || *safi == SAFI_MAX)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n// BGP_NOTIFY_SUBCODE_UNSPECIFIC from bgpd/bgpd/bgpd.h:\n<empty>\n\n// CHECK_FLAG from bgpd/zebra.h:\n<empty>\n\n// zlog_ref from lib/zlog.h:\nPRINTFRR(2, 3)\nstatic inline void zlog_ref(const struct xref_logmsg *xref,\n\t\t\t    const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tvzlogx(xref, xref->priority, fmt, ap);\n\tva_end(ap);\n}\n\n// BGP_PACKET_NOOP from bgpd/bgp_packet.c:\n<empty>\n\n// zlog_info from bgpd/lib/lib/zlog.h:\n<empty>\n\n// CAPABILITY_CODE_MP from bgpd/bgpd/bgp_open.h:\n<empty>\n\n// iana_afi2str from lib/iana_afi.h:\nstatic inline const char *iana_afi2str(iana_afi_t afi)\n{\n\treturn afi2str(afi_iana2int(afi));\n}\n\n// zlog_debug from bgpd/lib/lib/zlog.h:\n<empty>\n\n// bgp_notify_send from bgpd/bgp_packet.c:\nvoid bgp_notify_send(struct peer *peer, uint8_t code, uint8_t sub_code)\n{\n\tbgp_notify_send_with_data(peer, code, sub_code, NULL, 0);\n}\n"
  },
  {
    "repository": "pjproject",
    "cve_id": "CVE-2022-24786",
    "cwe_list": [
      "CWE-200"
    ],
    "commit_hash": "11559e49e65bdf00922ad5ae28913ec6a198d508",
    "short_hash": "11559e49",
    "vulnerableMethods_before": [
      {
        "filename": "rtcp_fb.c",
        "method_name": "vulnerable_function",
        "raw_code": "PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_rpsi(\n\t\t\t\t\tconst void *buf,\n\t\t\t\t\tpj_size_t length,\n\t\t\t\t\tpjmedia_rtcp_fb_rpsi *rpsi)\n{\n    pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;\n    pj_uint8_t *p;\n    pj_uint8_t padlen;\n    pj_size_t rpsi_len;\n\n    PJ_ASSERT_RETURN(buf && rpsi, PJ_EINVAL);\n    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_common), PJ_ETOOSMALL);\n\n    /* RPSI uses pt==RTCP_PSFB and FMT==3 */\n    if (hdr->pt != RTCP_PSFB || hdr->count != 3)\n\treturn PJ_ENOTFOUND;\n\n    rpsi_len = (pj_ntohs((pj_uint16_t)hdr->length)-2) * 4;\n    if (length < rpsi_len + 12)\n\treturn PJ_ETOOSMALL;\n\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    padlen = *p++;\n    rpsi->pt = (*p++ & 0x7F);\n    rpsi->rpsi_bit_len = rpsi_len*8 - 16 - padlen;\n    pj_strset(&rpsi->rpsi, (char*)p, (rpsi->rpsi_bit_len + 7)/8);\n\n    return PJ_SUCCESS;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "rtcp_fb.c",
        "method_name": "fixed_function",
        "raw_code": "PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_rpsi(\n\t\t\t\t\tconst void *buf,\n\t\t\t\t\tpj_size_t length,\n\t\t\t\t\tpjmedia_rtcp_fb_rpsi *rpsi)\n{\n    pjmedia_rtcp_fb_common *hdr = (pjmedia_rtcp_fb_common*) buf;\n    pj_uint8_t *p;\n    pj_uint8_t padlen;\n    pj_size_t rpsi_len;\n\n    PJ_ASSERT_RETURN(buf && rpsi, PJ_EINVAL);\n    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_fb_common), PJ_ETOOSMALL);\n\n    /* RPSI uses pt==RTCP_PSFB and FMT==3 */\n    if (hdr->rtcp_common.pt != RTCP_PSFB || hdr->rtcp_common.count != 3)\n\treturn PJ_ENOTFOUND;\n\n    if (hdr->rtcp_common.length < 3) {    \n        PJ_PERROR(3, (THIS_FILE, PJ_ETOOSMALL,\n                      \"Failed parsing FB RPSI, invalid header length\"));\n\treturn PJ_ETOOSMALL;\n    }\n\n    rpsi_len = (pj_ntohs((pj_uint16_t)hdr->rtcp_common.length)-2) * 4;\n    if (length < rpsi_len + 12)\n\treturn PJ_ETOOSMALL;\n\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    padlen = *p++;\n\n    if (padlen >= 32) {\n        PJ_PERROR(3, (THIS_FILE, PJ_ETOOBIG,\n                      \"Failed parsing FB RPSI, invalid RPSI padding len\"));\n\treturn PJ_ETOOBIG;\n    }\n\n    if ((rpsi_len * 8) < (unsigned)(16 + padlen)) {\n        PJ_PERROR(3, (THIS_FILE, PJ_ETOOSMALL,\n                      \"Failed parsing FB RPSI, invalid RPSI bit len\"));\n\treturn PJ_ETOOSMALL;\n    }\n\n    rpsi->pt = (*p++ & 0x7F);\n    rpsi->rpsi_bit_len = rpsi_len*8 - 16 - padlen;\n    pj_strset(&rpsi->rpsi, (char*)p, (rpsi->rpsi_bit_len + 7)/8);\n\n    return PJ_SUCCESS;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <pj/assert.h>\n#include <pjmedia/codec.h>\n#include <pjmedia/vid_codec.h>\n#include <pjmedia/endpoint.h>\n#include <pj/sock.h>\n#include <pj/os.h>\n#include <pjmedia/errno.h>\n#include <pj/log.h>\n#include <pj/string.h>\n#include <pjmedia/rtcp_fb.h>\n"
  },
  {
    "repository": "dpdk",
    "cve_id": "CVE-2022-0669",
    "cwe_list": [
      "CWE-703"
    ],
    "commit_hash": "af74f7db384ed149fe42b21dbd7975f8a54ef227",
    "short_hash": "af74f7db",
    "vulnerableMethods_before": [
      {
        "filename": "vhost_user.c",
        "method_name": "vulnerable_function",
        "raw_code": "vhost_user_get_inflight_fd(struct virtio_net **pdev,\n\t\t\t   struct vhu_msg_context *ctx,\n\t\t\t   int main_fd __rte_unused)\n{\n\tstruct rte_vhost_inflight_info_packed *inflight_packed;\n\tuint64_t pervq_inflight_size, mmap_size;\n\tuint16_t num_queues, queue_size;\n\tstruct virtio_net *dev = *pdev;\n\tint fd, i, j;\n\tint numa_node = SOCKET_ID_ANY;\n\tvoid *addr;\n\n\tif (ctx->msg.size != sizeof(ctx->msg.payload.inflight)) {\n\t\tVHOST_LOG_CONFIG(ERR, \"(%s) invalid get_inflight_fd message size is %d\\n\",\n\t\t\tdev->ifname, ctx->msg.size);\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t}\n\n\t/*\n\t * If VQ 0 has already been allocated, try to allocate on the same\n\t * NUMA node. It can be reallocated later in numa_realloc().\n\t */\n\tif (dev->nr_vring > 0)\n\t\tnuma_node = dev->virtqueue[0]->numa_node;\n\n\tif (dev->inflight_info == NULL) {\n\t\tdev->inflight_info = rte_zmalloc_socket(\"inflight_info\",\n\t\t\t\tsizeof(struct inflight_mem_info), 0, numa_node);\n\t\tif (!dev->inflight_info) {\n\t\t\tVHOST_LOG_CONFIG(ERR, \"(%s) failed to alloc dev inflight area\\n\",\n\t\t\t\t\tdev->ifname);\n\t\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t\t}\n\t\tdev->inflight_info->fd = -1;\n\t}\n\n\tnum_queues = ctx->msg.payload.inflight.num_queues;\n\tqueue_size = ctx->msg.payload.inflight.queue_size;\n\n\tVHOST_LOG_CONFIG(INFO, \"(%s) get_inflight_fd num_queues: %u\\n\",\n\t\tdev->ifname, ctx->msg.payload.inflight.num_queues);\n\tVHOST_LOG_CONFIG(INFO, \"(%s) get_inflight_fd queue_size: %u\\n\",\n\t\tdev->ifname, ctx->msg.payload.inflight.queue_size);\n\n\tif (vq_is_packed(dev))\n\t\tpervq_inflight_size = get_pervq_shm_size_packed(queue_size);\n\telse\n\t\tpervq_inflight_size = get_pervq_shm_size_split(queue_size);\n\n\tmmap_size = num_queues * pervq_inflight_size;\n\taddr = inflight_mem_alloc(dev, \"vhost-inflight\", mmap_size, &fd);\n\tif (!addr) {\n\t\tVHOST_LOG_CONFIG(ERR, \"(%s) failed to alloc vhost inflight area\\n\", dev->ifname);\n\t\t\tctx->msg.payload.inflight.mmap_size = 0;\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t}\n\tmemset(addr, 0, mmap_size);\n\n\tif (dev->inflight_info->addr) {\n\t\tmunmap(dev->inflight_info->addr, dev->inflight_info->size);\n\t\tdev->inflight_info->addr = NULL;\n\t}\n\n\tif (dev->inflight_info->fd >= 0) {\n\t\tclose(dev->inflight_info->fd);\n\t\tdev->inflight_info->fd = -1;\n\t}\n\n\tdev->inflight_info->addr = addr;\n\tdev->inflight_info->size = ctx->msg.payload.inflight.mmap_size = mmap_size;\n\tdev->inflight_info->fd = ctx->fds[0] = fd;\n\tctx->msg.payload.inflight.mmap_offset = 0;\n\tctx->fd_num = 1;\n\n\tif (vq_is_packed(dev)) {\n\t\tfor (i = 0; i < num_queues; i++) {\n\t\t\tinflight_packed =\n\t\t\t\t(struct rte_vhost_inflight_info_packed *)addr;\n\t\t\tinflight_packed->used_wrap_counter = 1;\n\t\t\tinflight_packed->old_used_wrap_counter = 1;\n\t\t\tfor (j = 0; j < queue_size; j++)\n\t\t\t\tinflight_packed->desc[j].next = j + 1;\n\t\t\taddr = (void *)((char *)addr + pervq_inflight_size);\n\t\t}\n\t}\n\n\tVHOST_LOG_CONFIG(INFO, \"(%s) send inflight mmap_size: %\"PRIu64\"\\n\",\n\t\t\tdev->ifname, ctx->msg.payload.inflight.mmap_size);\n\tVHOST_LOG_CONFIG(INFO, \"(%s) send inflight mmap_offset: %\"PRIu64\"\\n\",\n\t\t\tdev->ifname, ctx->msg.payload.inflight.mmap_offset);\n\tVHOST_LOG_CONFIG(INFO, \"(%s) send inflight fd: %d\\n\", dev->ifname, ctx->fds[0]);\n\n\treturn RTE_VHOST_MSG_RESULT_REPLY;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "vhost_user.c",
        "method_name": "fixed_function",
        "raw_code": "vhost_user_get_inflight_fd(struct virtio_net **pdev,\n\t\t\t   struct vhu_msg_context *ctx,\n\t\t\t   int main_fd __rte_unused)\n{\n\tstruct rte_vhost_inflight_info_packed *inflight_packed;\n\tuint64_t pervq_inflight_size, mmap_size;\n\tuint16_t num_queues, queue_size;\n\tstruct virtio_net *dev = *pdev;\n\tint fd, i, j;\n\tint numa_node = SOCKET_ID_ANY;\n\tvoid *addr;\n\n\tif (validate_msg_fds(dev, ctx, 0) != 0)\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\n\tif (ctx->msg.size != sizeof(ctx->msg.payload.inflight)) {\n\t\tVHOST_LOG_CONFIG(ERR, \"(%s) invalid get_inflight_fd message size is %d\\n\",\n\t\t\tdev->ifname, ctx->msg.size);\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t}\n\n\t/*\n\t * If VQ 0 has already been allocated, try to allocate on the same\n\t * NUMA node. It can be reallocated later in numa_realloc().\n\t */\n\tif (dev->nr_vring > 0)\n\t\tnuma_node = dev->virtqueue[0]->numa_node;\n\n\tif (dev->inflight_info == NULL) {\n\t\tdev->inflight_info = rte_zmalloc_socket(\"inflight_info\",\n\t\t\t\tsizeof(struct inflight_mem_info), 0, numa_node);\n\t\tif (!dev->inflight_info) {\n\t\t\tVHOST_LOG_CONFIG(ERR, \"(%s) failed to alloc dev inflight area\\n\",\n\t\t\t\t\tdev->ifname);\n\t\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t\t}\n\t\tdev->inflight_info->fd = -1;\n\t}\n\n\tnum_queues = ctx->msg.payload.inflight.num_queues;\n\tqueue_size = ctx->msg.payload.inflight.queue_size;\n\n\tVHOST_LOG_CONFIG(INFO, \"(%s) get_inflight_fd num_queues: %u\\n\",\n\t\tdev->ifname, ctx->msg.payload.inflight.num_queues);\n\tVHOST_LOG_CONFIG(INFO, \"(%s) get_inflight_fd queue_size: %u\\n\",\n\t\tdev->ifname, ctx->msg.payload.inflight.queue_size);\n\n\tif (vq_is_packed(dev))\n\t\tpervq_inflight_size = get_pervq_shm_size_packed(queue_size);\n\telse\n\t\tpervq_inflight_size = get_pervq_shm_size_split(queue_size);\n\n\tmmap_size = num_queues * pervq_inflight_size;\n\taddr = inflight_mem_alloc(dev, \"vhost-inflight\", mmap_size, &fd);\n\tif (!addr) {\n\t\tVHOST_LOG_CONFIG(ERR, \"(%s) failed to alloc vhost inflight area\\n\", dev->ifname);\n\t\t\tctx->msg.payload.inflight.mmap_size = 0;\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t}\n\tmemset(addr, 0, mmap_size);\n\n\tif (dev->inflight_info->addr) {\n\t\tmunmap(dev->inflight_info->addr, dev->inflight_info->size);\n\t\tdev->inflight_info->addr = NULL;\n\t}\n\n\tif (dev->inflight_info->fd >= 0) {\n\t\tclose(dev->inflight_info->fd);\n\t\tdev->inflight_info->fd = -1;\n\t}\n\n\tdev->inflight_info->addr = addr;\n\tdev->inflight_info->size = ctx->msg.payload.inflight.mmap_size = mmap_size;\n\tdev->inflight_info->fd = ctx->fds[0] = fd;\n\tctx->msg.payload.inflight.mmap_offset = 0;\n\tctx->fd_num = 1;\n\n\tif (vq_is_packed(dev)) {\n\t\tfor (i = 0; i < num_queues; i++) {\n\t\t\tinflight_packed =\n\t\t\t\t(struct rte_vhost_inflight_info_packed *)addr;\n\t\t\tinflight_packed->used_wrap_counter = 1;\n\t\t\tinflight_packed->old_used_wrap_counter = 1;\n\t\t\tfor (j = 0; j < queue_size; j++)\n\t\t\t\tinflight_packed->desc[j].next = j + 1;\n\t\t\taddr = (void *)((char *)addr + pervq_inflight_size);\n\t\t}\n\t}\n\n\tVHOST_LOG_CONFIG(INFO, \"(%s) send inflight mmap_size: %\"PRIu64\"\\n\",\n\t\t\tdev->ifname, ctx->msg.payload.inflight.mmap_size);\n\tVHOST_LOG_CONFIG(INFO, \"(%s) send inflight mmap_offset: %\"PRIu64\"\\n\",\n\t\t\tdev->ifname, ctx->msg.payload.inflight.mmap_offset);\n\tVHOST_LOG_CONFIG(INFO, \"(%s) send inflight fd: %d\\n\", dev->ifname, ctx->fds[0]);\n\n\treturn RTE_VHOST_MSG_RESULT_REPLY;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <numaif.h>\n#include \"vhost.h\"\n#include <linux/userfaultfd.h>\n#include <sys/stat.h>\n#include <rte_vfio.h>\n#include \"iotlb.h\"\n#include <string.h>\n#include <rte_errno.h>\n#include <stdio.h>\n#include <rte_common.h>\n#include <linux/memfd.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/ioctl.h>\n#include <stdint.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include <rte_log.h>\n#include <rte_malloc.h>\n#include <sys/syscall.h>\n#include \"vhost_user.h\"\n"
  },
  {
    "repository": "php-src",
    "cve_id": "CVE-2016-7132",
    "cwe_list": [
      "CWE-476"
    ],
    "commit_hash": "0c8a2a2cd1056b7dc403eacb5d2c0eec6ce47c6f",
    "short_hash": "0c8a2a2c",
    "vulnerableMethods_before": [
      {
        "filename": "wddx.c",
        "method_name": "vulnerable_function",
        "raw_code": " */\nstatic void php_wddx_pop_element(void *user_data, const XML_Char *name)\n{\n\tst_entry \t\t\t*ent1, *ent2;\n\twddx_stack \t\t\t*stack = (wddx_stack *)user_data;\n\tHashTable \t\t\t*target_hash;\n\tzend_class_entry \t*pce;\n\tzval\t\t\t\tobj;\n\n/* OBJECTS_FIXME */\n\tif (stack->top == 0) {\n\t\treturn;\n\t}\n\n\tif (!strcmp((char *)name, EL_STRING) || !strcmp((char *)name, EL_NUMBER) ||\n\t\t!strcmp((char *)name, EL_BOOLEAN) || !strcmp((char *)name, EL_NULL) ||\n\t  \t!strcmp((char *)name, EL_ARRAY) || !strcmp((char *)name, EL_STRUCT) ||\n\t\t!strcmp((char *)name, EL_RECORDSET) || !strcmp((char *)name, EL_BINARY) ||\n\t\t!strcmp((char *)name, EL_DATETIME)) {\n\t\twddx_stack_top(stack, (void**)&ent1);\n\n\t\tif (Z_TYPE(ent1->data) == IS_UNDEF) {\n\t\t\tif (stack->top > 1) {\n\t\t\t\tstack->top--;\n\t\t\t} else {\n\t\t\t\tstack->done = 1;\n\t\t\t}\n\t\t\tefree(ent1);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!strcmp((char *)name, EL_BINARY)) {\n\t\t\tzend_string *new_str = php_base64_decode(\n\t\t\t\t(unsigned char *)Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));\n\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\tZVAL_STR(&ent1->data, new_str);\n\t\t}\n\n\t\t/* Call __wakeup() method on the object. */\n\t\tif (Z_TYPE(ent1->data) == IS_OBJECT) {\n\t\t\tzval fname, retval;\n\n\t\t\tZVAL_STRING(&fname, \"__wakeup\");\n\n\t\t\tcall_user_function_ex(NULL, &ent1->data, &fname, &retval, 0, 0, 0, NULL);\n\n\t\t\tzval_ptr_dtor(&fname);\n\t\t\tzval_ptr_dtor(&retval);\n\t\t}\n\n\t\tif (stack->top > 1) {\n\t\t\tstack->top--;\n\t\t\twddx_stack_top(stack, (void**)&ent2);\n\n\t\t\t/* if non-existent field */\n\t\t\tif (ent2->type == ST_FIELD && Z_ISUNDEF(ent2->data)) {\n\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\tefree(ent1);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (Z_TYPE(ent2->data) == IS_ARRAY || Z_TYPE(ent2->data) == IS_OBJECT) {\n\t\t\t\ttarget_hash = HASH_OF(&ent2->data);\n\n\t\t\t\tif (ent1->varname) {\n\t\t\t\t\tif (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) &&\n\t\t\t\t\t\tZ_TYPE(ent1->data) == IS_STRING && Z_STRLEN(ent1->data) &&\n\t\t\t\t\t\tent2->type == ST_STRUCT && Z_TYPE(ent2->data) == IS_ARRAY) {\n\t\t\t\t\t\tzend_bool incomplete_class = 0;\n\n\t\t\t\t\t\tzend_str_tolower(Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));\n\t\t\t\t\t\tzend_string_forget_hash_val(Z_STR(ent1->data));\n\t\t\t\t\t\tif ((pce = zend_hash_find_ptr(EG(class_table), Z_STR(ent1->data))) == NULL) {\n\t\t\t\t\t\t\tincomplete_class = 1;\n\t\t\t\t\t\t\tpce = PHP_IC_ENTRY;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Initialize target object */\n\t\t\t\t\t\tobject_init_ex(&obj, pce);\n\n\t\t\t\t\t\t/* Merge current hashtable with object's default properties */\n\t\t\t\t\t\tzend_hash_merge(Z_OBJPROP(obj),\n\t\t\t\t\t\t\t\t\t\tZ_ARRVAL(ent2->data),\n\t\t\t\t\t\t\t\t\t\tzval_add_ref, 0);\n\n\t\t\t\t\t\tif (incomplete_class) {\n\t\t\t\t\t\t\tphp_store_class_name(&obj, Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Clean up old array entry */\n\t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n\n\t\t\t\t\t\t/* Set stack entry to point to the newly created object */\n\t\t\t\t\t\tZVAL_COPY_VALUE(&ent2->data, &obj);\n\n\t\t\t\t\t\t/* Clean up class name var entry */\n\t\t\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\t\t} else if (Z_TYPE(ent2->data) == IS_OBJECT) {\n\t\t\t\t\t\tzend_class_entry *old_scope = EG(scope);\n\n\t\t\t\t\t\tEG(scope) = Z_OBJCE(ent2->data);\n\t\t\t\t\t\tadd_property_zval(&ent2->data, ent1->varname, &ent1->data);\n\t\t\t\t\t\tif Z_REFCOUNTED(ent1->data) Z_DELREF(ent1->data);\n\t\t\t\t\t\tEG(scope) = old_scope;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tzend_symtable_str_update(target_hash, ent1->varname, strlen(ent1->varname), &ent1->data);\n\t\t\t\t\t}\n\t\t\t\t\tefree(ent1->varname);\n\t\t\t\t} else\t{\n\t\t\t\t\tzend_hash_next_index_insert(target_hash, &ent1->data);\n\t\t\t\t}\n\t\t\t}\n\t\t\tefree(ent1);\n\t\t} else {\n\t\t\tstack->done = 1;\n\t\t}\n\t} else if (!strcmp((char *)name, EL_VAR) && stack->varname) {\n\t\tefree(stack->varname);\n\t\tstack->varname = NULL;\n\t} else if (!strcmp((char *)name, EL_FIELD)) {\n\t\tst_entry *ent;\n\t\twddx_stack_top(stack, (void **)&ent);\n\t\tefree(ent);\n\t\tstack->top--;\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "wddx.c",
        "method_name": "fixed_function",
        "raw_code": " */\nstatic void php_wddx_pop_element(void *user_data, const XML_Char *name)\n{\n\tst_entry \t\t\t*ent1, *ent2;\n\twddx_stack \t\t\t*stack = (wddx_stack *)user_data;\n\tHashTable \t\t\t*target_hash;\n\tzend_class_entry \t*pce;\n\tzval\t\t\t\tobj;\n\n/* OBJECTS_FIXME */\n\tif (stack->top == 0) {\n\t\treturn;\n\t}\n\n\tif (!strcmp((char *)name, EL_STRING) || !strcmp((char *)name, EL_NUMBER) ||\n\t\t!strcmp((char *)name, EL_BOOLEAN) || !strcmp((char *)name, EL_NULL) ||\n\t  \t!strcmp((char *)name, EL_ARRAY) || !strcmp((char *)name, EL_STRUCT) ||\n\t\t!strcmp((char *)name, EL_RECORDSET) || !strcmp((char *)name, EL_BINARY) ||\n\t\t!strcmp((char *)name, EL_DATETIME)) {\n\t\twddx_stack_top(stack, (void**)&ent1);\n\n\t\tif (Z_TYPE(ent1->data) == IS_UNDEF) {\n\t\t\tif (stack->top > 1) {\n\t\t\t\tstack->top--;\n\t\t\t\tefree(ent1);\n\t\t\t} else {\n\t\t\t\tstack->done = 1;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (!strcmp((char *)name, EL_BINARY)) {\n\t\t\tzend_string *new_str = php_base64_decode(\n\t\t\t\t(unsigned char *)Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));\n\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\tZVAL_STR(&ent1->data, new_str);\n\t\t}\n\n\t\t/* Call __wakeup() method on the object. */\n\t\tif (Z_TYPE(ent1->data) == IS_OBJECT) {\n\t\t\tzval fname, retval;\n\n\t\t\tZVAL_STRING(&fname, \"__wakeup\");\n\n\t\t\tcall_user_function_ex(NULL, &ent1->data, &fname, &retval, 0, 0, 0, NULL);\n\n\t\t\tzval_ptr_dtor(&fname);\n\t\t\tzval_ptr_dtor(&retval);\n\t\t}\n\n\t\tif (stack->top > 1) {\n\t\t\tstack->top--;\n\t\t\twddx_stack_top(stack, (void**)&ent2);\n\n\t\t\t/* if non-existent field */\n\t\t\tif (ent2->type == ST_FIELD && Z_ISUNDEF(ent2->data)) {\n\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\tefree(ent1);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (Z_TYPE(ent2->data) == IS_ARRAY || Z_TYPE(ent2->data) == IS_OBJECT) {\n\t\t\t\ttarget_hash = HASH_OF(&ent2->data);\n\n\t\t\t\tif (ent1->varname) {\n\t\t\t\t\tif (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) &&\n\t\t\t\t\t\tZ_TYPE(ent1->data) == IS_STRING && Z_STRLEN(ent1->data) &&\n\t\t\t\t\t\tent2->type == ST_STRUCT && Z_TYPE(ent2->data) == IS_ARRAY) {\n\t\t\t\t\t\tzend_bool incomplete_class = 0;\n\n\t\t\t\t\t\tzend_str_tolower(Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));\n\t\t\t\t\t\tzend_string_forget_hash_val(Z_STR(ent1->data));\n\t\t\t\t\t\tif ((pce = zend_hash_find_ptr(EG(class_table), Z_STR(ent1->data))) == NULL) {\n\t\t\t\t\t\t\tincomplete_class = 1;\n\t\t\t\t\t\t\tpce = PHP_IC_ENTRY;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Initialize target object */\n\t\t\t\t\t\tobject_init_ex(&obj, pce);\n\n\t\t\t\t\t\t/* Merge current hashtable with object's default properties */\n\t\t\t\t\t\tzend_hash_merge(Z_OBJPROP(obj),\n\t\t\t\t\t\t\t\t\t\tZ_ARRVAL(ent2->data),\n\t\t\t\t\t\t\t\t\t\tzval_add_ref, 0);\n\n\t\t\t\t\t\tif (incomplete_class) {\n\t\t\t\t\t\t\tphp_store_class_name(&obj, Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Clean up old array entry */\n\t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n\n\t\t\t\t\t\t/* Set stack entry to point to the newly created object */\n\t\t\t\t\t\tZVAL_COPY_VALUE(&ent2->data, &obj);\n\n\t\t\t\t\t\t/* Clean up class name var entry */\n\t\t\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\t\t} else if (Z_TYPE(ent2->data) == IS_OBJECT) {\n\t\t\t\t\t\tzend_class_entry *old_scope = EG(scope);\n\n\t\t\t\t\t\tEG(scope) = Z_OBJCE(ent2->data);\n\t\t\t\t\t\tadd_property_zval(&ent2->data, ent1->varname, &ent1->data);\n\t\t\t\t\t\tif Z_REFCOUNTED(ent1->data) Z_DELREF(ent1->data);\n\t\t\t\t\t\tEG(scope) = old_scope;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tzend_symtable_str_update(target_hash, ent1->varname, strlen(ent1->varname), &ent1->data);\n\t\t\t\t\t}\n\t\t\t\t\tefree(ent1->varname);\n\t\t\t\t} else\t{\n\t\t\t\t\tzend_hash_next_index_insert(target_hash, &ent1->data);\n\t\t\t\t}\n\t\t\t}\n\t\t\tefree(ent1);\n\t\t} else {\n\t\t\tstack->done = 1;\n\t\t}\n\t} else if (!strcmp((char *)name, EL_VAR) && stack->varname) {\n\t\tefree(stack->varname);\n\t\tstack->varname = NULL;\n\t} else if (!strcmp((char *)name, EL_FIELD)) {\n\t\tst_entry *ent;\n\t\twddx_stack_top(stack, (void **)&ent);\n\t\tefree(ent);\n\t\tstack->top--;\n\t}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"config.h\"\n#include \"zend_smart_str.h\"\n#include \"ext/standard/info.h\"\n#include \"zend_globals.h\"\n#include \"ext/standard/base64.h\"\n#include \"ext/standard/php_incomplete_class.h\"\n#include \"ext/standard/php_string.h\"\n#include \"php.h\"\n#include \"php_wddx_api.h\"\n#include \"ext/xml/expat_compat.h\"\n#include \"ext/xml/php_xml.h\"\n#include \"ext/standard/html.h\"\n#include \"ext/session/php_session.h\"\n#include \"ext/date/php_date.h\"\n#include \"php_wddx.h\"\n"
  },
  {
    "repository": "Singular",
    "cve_id": "CVE-2022-40299",
    "cwe_list": [
      "CWE-269"
    ],
    "commit_hash": "5f28fbf066626fa9c4a8f0e6408c0bb362fb386c",
    "short_hash": "5f28fbf0",
    "vulnerableMethods_before": [
      {
        "filename": "None",
        "method_name": "vulnerable_function",
        "raw_code": "void sdb_edit(procinfo *pi)\n{\n  char * filename = omStrDup(\"/tmp/sd000000\");\n  sprintf(filename+7,\"%d\",getpid());\n  FILE *fp=fopen(filename,\"w\");\n  if (fp==NULL)\n  {\n    Print(\"cannot open %s\\n\",filename);\n    omFree(filename);\n    return;\n  }\n  if (pi->language!= LANG_SINGULAR)\n  {\n    Print(\"cannot edit type %d\\n\",pi->language);\n    fclose(fp);\n    fp=NULL;\n  }\n  else\n  {\n    const char *editor=getenv(\"EDITOR\");\n    if (editor==NULL)\n      editor=getenv(\"VISUAL\");\n    if (editor==NULL)\n      editor=\"vi\";\n    editor=omStrDup(editor);\n\n    if (pi->data.s.body==NULL)\n    {\n      iiGetLibProcBuffer(pi);\n      if (pi->data.s.body==NULL)\n      {\n        PrintS(\"cannot get the procedure body\\n\");\n        fclose(fp);\n        si_unlink(filename);\n        omFree(filename);\n        return;\n      }\n    }\n\n    fwrite(pi->data.s.body,1,strlen(pi->data.s.body),fp);\n    fclose(fp);\n\n    int pid=fork();\n    if (pid!=0)\n    {\n      si_wait(&pid);\n    }\n    else if(pid==0)\n    {\n      if (strchr(editor,' ')==NULL)\n      {\n        execlp(editor,editor,filename,NULL);\n        Print(\"cannot exec %s\\n\",editor);\n      }\n      else\n      {\n        char *p=(char *)omAlloc(strlen(editor)+strlen(filename)+2);\n        sprintf(p,\"%s %s\",editor,filename);\n        system(p);\n      }\n      exit(0);\n    }\n    else\n    {\n      PrintS(\"cannot fork\\n\");\n    }\n\n    fp=fopen(filename,\"r\");\n    if (fp==NULL)\n    {\n      Print(\"cannot read from %s\\n\",filename);\n    }\n    else\n    {\n      fseek(fp,0L,SEEK_END);\n      long len=ftell(fp);\n      fseek(fp,0L,SEEK_SET);\n\n      omFree((ADDRESS)pi->data.s.body);\n      pi->data.s.body=(char *)omAlloc((int)len+1);\n      myfread( pi->data.s.body, len, 1, fp);\n      pi->data.s.body[len]='\\0';\n      fclose(fp);\n    }\n  }\n  si_unlink(filename);\n  omFree(filename);\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "None",
        "method_name": "fixed_function",
        "raw_code": "void sdb_edit(procinfo *pi)\n{\n  char * filename = omStrDup(\"/tmp/sdXXXXXX\");\n  int f=mkstemp(filename);\n  if (f==-1)\n  {\n    Print(\"cannot open %s\\n\",filename);\n    omFree(filename);\n    return;\n  }\n  if (pi->language!= LANG_SINGULAR)\n  {\n    Print(\"cannot edit type %d\\n\",pi->language);\n    close(f);\n    f=NULL;\n  }\n  else\n  {\n    const char *editor=getenv(\"EDITOR\");\n    if (editor==NULL)\n      editor=getenv(\"VISUAL\");\n    if (editor==NULL)\n      editor=\"vi\";\n    editor=omStrDup(editor);\n\n    if (pi->data.s.body==NULL)\n    {\n      iiGetLibProcBuffer(pi);\n      if (pi->data.s.body==NULL)\n      {\n        PrintS(\"cannot get the procedure body\\n\");\n        close(f);\n        si_unlink(filename);\n        omFree(filename);\n        return;\n      }\n    }\n\n    write(f,pi->data.s.body,strlen(pi->data.s.body));\n    close(f);\n\n    int pid=fork();\n    if (pid!=0)\n    {\n      si_wait(&pid);\n    }\n    else if(pid==0)\n    {\n      if (strchr(editor,' ')==NULL)\n      {\n        execlp(editor,editor,filename,NULL);\n        Print(\"cannot exec %s\\n\",editor);\n      }\n      else\n      {\n        char *p=(char *)omAlloc(strlen(editor)+strlen(filename)+2);\n        sprintf(p,\"%s %s\",editor,filename);\n        system(p);\n      }\n      exit(0);\n    }\n    else\n    {\n      PrintS(\"cannot fork\\n\");\n    }\n\n    FILE* fp=fopen(filename,\"r\");\n    if (fp==NULL)\n    {\n      Print(\"cannot read from %s\\n\",filename);\n    }\n    else\n    {\n      fseek(fp,0L,SEEK_END);\n      long len=ftell(fp);\n      fseek(fp,0L,SEEK_SET);\n\n      omFree((ADDRESS)pi->data.s.body);\n      pi->data.s.body=(char *)omAlloc((int)len+1);\n      myfread( pi->data.s.body, len, 1, fp);\n      pi->data.s.body[len]='\\0';\n      fclose(fp);\n    }\n  }\n  si_unlink(filename);\n  omFree(filename);\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <unistd.h>\n#include \"Singular/ipid.h\"\n#include <sys/wait.h>\n#include \"reporter/si_signals.h\"\n#include \"Singular/tok.h\"\n#include \"kernel/oswrapper/feread.h\"\n#include \"Singular/sdb.h\"\n#include \"misc/options.h\"\n#include \"Singular/ipshell.h\"\n#include \"Singular/fevoices.h\"\n#include \"kernel/mod2.h\"\n#include \"omalloc/omalloc.h\"\n\n// Type Definitions:\n// int:\nBigInt.int:int()\n\n// procinfo:\nclass procinfo\n{\npublic:\n  char          *libname;\n  char          *procname;\n  package       pack;\n  language_defs language;\n  short         ref;\n  char          is_static;        // if set, proc not accessible for user\n  char          trace_flag;\n  procinfodata  data;\n}\n\n// int:\nRational.int:int()\n\n// Called Methods (top 10):\n// NULL from Singular/kernel/misc/auxiliary.h:\n<empty>\n\n// SEEK_END from Singular/kernel/mod2.h:\n<empty>\n\n// SI_PROT_O from libpolys/reporter/reporter/reporter.h:\n\n\n// assume from Singular/Singular/Singular/Singular/kernel/kernel/polys/monomials/coeffs/reporter/reporter.h:\n\n\n// omFree from libpolys/reporter/omalloc/omalloc/xalloc.h:\n\n\n// omAlloc from Singular/Singular/Singular/Singular/omalloc/omalloc/xalloc.h:\n\n\n// omAlloc from Singular/omalloc/omalloc/xalloc.h:\n<empty>\n\n// omAlloc from libpolys/reporter/omalloc/omalloc/xalloc.h:\n\n\n// PrintS from libpolys/reporter/reporter.cc:\nvoid PrintS(const char *s)\n{\n  if (sprint != NULL)\n  {\n    SPrintS(s);\n    return;\n  }\n  else if (feOut) /* do not print when option --no-out was given */\n  {\n\n    if (PrintS_callback!=NULL)\n    {\n      PrintS_callback(s);\n    }\n    else\n    {\n      fwrite(s,1,strlen(s),stdout);\n      fflush(stdout);\n      if (feProt&SI_PROT_O)\n      {\n        fwrite(s,1,strlen(s),feProtFile);\n      }\n    }\n  }\n}\n\n// dErrorBreak from libpolys/reporter/dError.cc:\nvoid dErrorBreak() /* <=== dErrorBreak */ \n{}\n"
  },
  {
    "repository": "ImageMagick",
    "cve_id": "CVE-2022-28463",
    "cwe_list": [
      "CWE-787"
    ],
    "commit_hash": "ca3654ebf7a439dc736f56f083c9aa98e4464b7f",
    "short_hash": "ca3654eb",
    "vulnerableMethods_before": [
      {
        "filename": "cin.c",
        "method_name": "vulnerable_function",
        "raw_code": "static Image *ReadCINImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define MonoColorType  1\n#define RGBColorType  3\n\n  char\n    property[MagickPathExtent];\n\n  CINInfo\n    cin;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  ssize_t\n    i;\n\n  Quantum\n    *q;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    magick[4],\n    *pixels;\n\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    File information.\n  */\n  offset=0;\n  count=ReadBlob(image,4,magick);\n  offset+=count;\n  if ((count != 4) ||\n      ((LocaleNCompare((char *) magick,\"\\200\\052\\137\\327\",4) != 0)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  memset(&cin,0,sizeof(cin));\n  image->endian=(magick[0] == 0x80) && (magick[1] == 0x2a) &&\n    (magick[2] == 0x5f) && (magick[3] == 0xd7) ? MSBEndian : LSBEndian;\n  cin.file.image_offset=ReadBlobLong(image);\n  offset+=4;\n  cin.file.generic_length=ReadBlobLong(image);\n  offset+=4;\n  cin.file.industry_length=ReadBlobLong(image);\n  offset+=4;\n  cin.file.user_length=ReadBlobLong(image);\n  offset+=4;\n  cin.file.file_size=ReadBlobLong(image);\n  offset+=4;\n  offset+=ReadBlob(image,sizeof(cin.file.version),(unsigned char *)\n    cin.file.version);\n  (void) CopyMagickString(property,cin.file.version,sizeof(cin.file.version));\n  (void) SetImageProperty(image,\"dpx:file.version\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.file.filename),(unsigned char *)\n    cin.file.filename);\n  (void) CopyMagickString(property,cin.file.filename,sizeof(cin.file.filename));\n  (void) SetImageProperty(image,\"dpx:file.filename\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.file.create_date),(unsigned char *)\n    cin.file.create_date);\n  (void) CopyMagickString(property,cin.file.create_date,\n    sizeof(cin.file.create_date));\n  (void) SetImageProperty(image,\"dpx:file.create_date\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.file.create_time),(unsigned char *)\n    cin.file.create_time);\n  (void) CopyMagickString(property,cin.file.create_time,\n    sizeof(cin.file.create_time));\n  (void) SetImageProperty(image,\"dpx:file.create_time\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.file.reserve),(unsigned char *)\n    cin.file.reserve);\n  /*\n    Image information.\n  */\n  cin.image.orientation=(unsigned char) ReadBlobByte(image);\n  offset++;\n  if (cin.image.orientation != (unsigned char) (~0))\n    (void) FormatImageProperty(image,\"dpx:image.orientation\",\"%d\",\n      cin.image.orientation);\n  switch (cin.image.orientation)\n  {\n    default:\n    case 0: image->orientation=TopLeftOrientation; break;\n    case 1: image->orientation=TopRightOrientation; break;\n    case 2: image->orientation=BottomLeftOrientation; break;\n    case 3: image->orientation=BottomRightOrientation; break;\n    case 4: image->orientation=LeftTopOrientation; break;\n    case 5: image->orientation=RightTopOrientation; break;\n    case 6: image->orientation=LeftBottomOrientation; break;\n    case 7: image->orientation=RightBottomOrientation; break;\n  }\n  cin.image.number_channels=(unsigned char) ReadBlobByte(image);\n  offset++;\n  offset+=ReadBlob(image,sizeof(cin.image.reserve1),(unsigned char *)\n    cin.image.reserve1);\n  for (i=0; i < 8; i++)\n  {\n    cin.image.channel[i].designator[0]=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].designator[1]=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].bits_per_pixel=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].reserve=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].pixels_per_line=ReadBlobLong(image);\n    offset+=4;\n    cin.image.channel[i].lines_per_image=ReadBlobLong(image);\n    offset+=4;\n    cin.image.channel[i].min_data=ReadBlobFloat(image);\n    offset+=4;\n    cin.image.channel[i].min_quantity=ReadBlobFloat(image);\n    offset+=4;\n    cin.image.channel[i].max_data=ReadBlobFloat(image);\n    offset+=4;\n    cin.image.channel[i].max_quantity=ReadBlobFloat(image);\n    offset+=4;\n  }\n  cin.image.white_point[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.white_point[0]) != MagickFalse)\n    image->chromaticity.white_point.x=cin.image.white_point[0];\n  cin.image.white_point[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.white_point[1]) != MagickFalse)\n    image->chromaticity.white_point.y=cin.image.white_point[1];\n  cin.image.red_primary_chromaticity[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.red_primary_chromaticity[0]) != MagickFalse)\n    image->chromaticity.red_primary.x=cin.image.red_primary_chromaticity[0];\n  cin.image.red_primary_chromaticity[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.red_primary_chromaticity[1]) != MagickFalse)\n    image->chromaticity.red_primary.y=cin.image.red_primary_chromaticity[1];\n  cin.image.green_primary_chromaticity[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.green_primary_chromaticity[0]) != MagickFalse)\n    image->chromaticity.red_primary.x=cin.image.green_primary_chromaticity[0];\n  cin.image.green_primary_chromaticity[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.green_primary_chromaticity[1]) != MagickFalse)\n    image->chromaticity.green_primary.y=cin.image.green_primary_chromaticity[1];\n  cin.image.blue_primary_chromaticity[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.blue_primary_chromaticity[0]) != MagickFalse)\n    image->chromaticity.blue_primary.x=cin.image.blue_primary_chromaticity[0];\n  cin.image.blue_primary_chromaticity[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.blue_primary_chromaticity[1]) != MagickFalse)\n    image->chromaticity.blue_primary.y=cin.image.blue_primary_chromaticity[1];\n  offset+=ReadBlob(image,sizeof(cin.image.label),(unsigned char *)\n    cin.image.label);\n  (void) CopyMagickString(property,cin.image.label,sizeof(cin.image.label));\n  (void) SetImageProperty(image,\"dpx:image.label\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.image.reserve),(unsigned char *)\n    cin.image.reserve);\n  /*\n    Image data format information.\n  */\n  cin.data_format.interleave=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.packing=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.sign=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.sense=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.line_pad=ReadBlobLong(image);\n  offset+=4;\n  cin.data_format.channel_pad=ReadBlobLong(image);\n  offset+=4;\n  offset+=ReadBlob(image,sizeof(cin.data_format.reserve),(unsigned char *)\n    cin.data_format.reserve);\n  /*\n    Image origination information.\n  */\n  cin.origination.x_offset=ReadBlobSignedLong(image);\n  offset+=4;\n  if ((size_t) cin.origination.x_offset != ~0UL)\n    (void) FormatImageProperty(image,\"dpx:origination.x_offset\",\"%.20g\",\n      (double) cin.origination.x_offset);\n  cin.origination.y_offset=(ssize_t) ReadBlobLong(image);\n  offset+=4;\n  if ((size_t) cin.origination.y_offset != ~0UL)\n    (void) FormatImageProperty(image,\"dpx:origination.y_offset\",\"%.20g\",\n      (double) cin.origination.y_offset);\n  offset+=ReadBlob(image,sizeof(cin.origination.filename),(unsigned char *)\n    cin.origination.filename);\n  (void) CopyMagickString(property,cin.origination.filename,\n    sizeof(cin.origination.filename));\n  (void) SetImageProperty(image,\"dpx:origination.filename\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.origination.create_date),(unsigned char *)\n    cin.origination.create_date);\n  (void) CopyMagickString(property,cin.origination.create_date,\n    sizeof(cin.origination.create_date));\n  (void) SetImageProperty(image,\"dpx:origination.create_date\",property,\n    exception);\n  offset+=ReadBlob(image,sizeof(cin.origination.create_time),(unsigned char *)\n    cin.origination.create_time);\n  (void) CopyMagickString(property,cin.origination.create_time,\n    sizeof(cin.origination.create_time));\n  (void) SetImageProperty(image,\"dpx:origination.create_time\",property,\n    exception);\n  offset+=ReadBlob(image,sizeof(cin.origination.device),(unsigned char *)\n    cin.origination.device);\n  (void) CopyMagickString(property,cin.origination.device,\n    sizeof(cin.origination.device));\n  (void) SetImageProperty(image,\"dpx:origination.device\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.origination.model),(unsigned char *)\n    cin.origination.model);\n  (void) CopyMagickString(property,cin.origination.model,\n    sizeof(cin.origination.model));\n  (void) SetImageProperty(image,\"dpx:origination.model\",property,exception);\n  (void) memset(cin.origination.serial,0, \n    sizeof(cin.origination.serial));\n  offset+=ReadBlob(image,sizeof(cin.origination.serial),(unsigned char *)\n    cin.origination.serial);\n  (void) CopyMagickString(property,cin.origination.serial,\n    sizeof(cin.origination.serial));\n  (void) SetImageProperty(image,\"dpx:origination.serial\",property,exception);\n  cin.origination.x_pitch=ReadBlobFloat(image);\n  offset+=4;\n  cin.origination.y_pitch=ReadBlobFloat(image);\n  offset+=4;\n  cin.origination.gamma=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.origination.gamma) != MagickFalse)\n    image->gamma=cin.origination.gamma;\n  offset+=ReadBlob(image,sizeof(cin.origination.reserve),(unsigned char *)\n    cin.origination.reserve);\n  if ((cin.file.image_offset > 2048) && (cin.file.user_length != 0))\n    {\n      int\n        c;\n\n      /*\n        Image film information.\n      */\n      cin.film.id=ReadBlobByte(image);\n      offset++;\n      c=cin.film.id;\n      if (c != ~0)\n        (void) FormatImageProperty(image,\"dpx:film.id\",\"%d\",cin.film.id);\n      cin.film.type=ReadBlobByte(image);\n      offset++;\n      c=cin.film.type;\n      if (c != ~0)\n        (void) FormatImageProperty(image,\"dpx:film.type\",\"%d\",cin.film.type);\n      cin.film.offset=ReadBlobByte(image);\n      offset++;\n      c=cin.film.offset;\n      if (c != ~0)\n        (void) FormatImageProperty(image,\"dpx:film.offset\",\"%d\",\n          cin.film.offset);\n      cin.film.reserve1=ReadBlobByte(image);\n      offset++;\n      cin.film.prefix=ReadBlobLong(image);\n      offset+=4;\n      if (cin.film.prefix != ~0UL)\n        (void) FormatImageProperty(image,\"dpx:film.prefix\",\"%.20g\",(double)\n          cin.film.prefix);\n      cin.film.count=ReadBlobLong(image);\n      offset+=4;\n      offset+=ReadBlob(image,sizeof(cin.film.format),(unsigned char *)\n        cin.film.format);\n      (void) CopyMagickString(property,cin.film.format,sizeof(cin.film.format));\n      (void) SetImageProperty(image,\"dpx:film.format\",property,exception);\n      cin.film.frame_position=ReadBlobLong(image);\n      offset+=4;\n      if (cin.film.frame_position != ~0UL)\n        (void) FormatImageProperty(image,\"dpx:film.frame_position\",\"%.20g\",\n          (double) cin.film.frame_position);\n      cin.film.frame_rate=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(cin.film.frame_rate) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:film.frame_rate\",\"%g\",\n          cin.film.frame_rate);\n      offset+=ReadBlob(image,sizeof(cin.film.frame_id),(unsigned char *)\n        cin.film.frame_id);\n      (void) CopyMagickString(property,cin.film.frame_id,\n        sizeof(cin.film.frame_id));\n      (void) SetImageProperty(image,\"dpx:film.frame_id\",property,exception);\n      offset+=ReadBlob(image,sizeof(cin.film.slate_info),(unsigned char *)\n        cin.film.slate_info);\n      (void) CopyMagickString(property,cin.film.slate_info,\n        sizeof(cin.film.slate_info));\n      (void) SetImageProperty(image,\"dpx:film.slate_info\",property,exception);\n      offset+=ReadBlob(image,sizeof(cin.film.reserve),(unsigned char *)\n        cin.film.reserve);\n    }\n  if ((cin.file.image_offset > 2048) && (cin.file.user_length != 0))\n    {\n      StringInfo\n        *profile;\n\n      /*\n        User defined data.\n      */\n      if (cin.file.user_length > GetBlobSize(image))\n        ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n      profile=BlobToStringInfo((const unsigned char *) NULL,\n        cin.file.user_length);\n      if (profile == (StringInfo *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      offset+=ReadBlob(image,GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n      (void) SetImageProfile(image,\"dpx:user.data\",profile,exception);\n      profile=DestroyStringInfo(profile);\n    }\n  image->depth=cin.image.channel[0].bits_per_pixel;\n  image->columns=cin.image.channel[0].pixels_per_line;\n  image->rows=cin.image.channel[0].lines_per_image;\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(image);\n    }\n  if (((MagickSizeType) image->columns*image->rows/8) > GetBlobSize(image))\n    ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n  for ( ; offset < (MagickOffsetType) cin.file.image_offset; offset++)\n  {\n    int\n      c;\n\n    c=ReadBlobByte(image);\n    if (c == EOF)\n      break;\n  }\n  if (offset < (MagickOffsetType) cin.file.image_offset)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  (void) SetImageBackgroundColor(image,exception);\n  /*\n    Convert CIN raster image to pixel packets.\n  */\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  SetQuantumQuantum(quantum_info,32);\n  SetQuantumPack(quantum_info,MagickFalse);\n  quantum_type=RGBQuantum;\n  length=GetBytesPerRow(image->columns,3,image->depth,MagickTrue);\n  if (cin.image.number_channels == 1)\n    {\n      quantum_type=GrayQuantum;\n      length=GetBytesPerRow(image->columns,1,image->depth,MagickTrue);\n    }\n  status=SetQuantumPad(image,quantum_info,0);\n  pixels=GetQuantumPixels(quantum_info);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    const void\n      *stream;\n\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    stream=ReadBlobStream(image,length,pixels,&count);\n    if ((size_t) count != length)\n      break;\n    (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n      quantum_type,(unsigned char *) stream,exception);\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  SetQuantumImageType(image,quantum_type);\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  SetImageColorspace(image,LogColorspace,exception);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "cin.c",
        "method_name": "fixed_function",
        "raw_code": "static Image *ReadCINImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define MonoColorType  1\n#define RGBColorType  3\n\n  char\n    property[MagickPathExtent];\n\n  CINInfo\n    cin;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  ssize_t\n    i;\n\n  Quantum\n    *q;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    magick[4],\n    *pixels;\n\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    File information.\n  */\n  offset=0;\n  count=ReadBlob(image,4,magick);\n  offset+=count;\n  if ((count != 4) ||\n      ((LocaleNCompare((char *) magick,\"\\200\\052\\137\\327\",4) != 0)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  memset(&cin,0,sizeof(cin));\n  image->endian=(magick[0] == 0x80) && (magick[1] == 0x2a) &&\n    (magick[2] == 0x5f) && (magick[3] == 0xd7) ? MSBEndian : LSBEndian;\n  cin.file.image_offset=ReadBlobLong(image);\n  if (cin.file.image_offset < 712)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  offset+=4;\n  cin.file.generic_length=ReadBlobLong(image);\n  offset+=4;\n  cin.file.industry_length=ReadBlobLong(image);\n  offset+=4;\n  cin.file.user_length=ReadBlobLong(image);\n  offset+=4;\n  cin.file.file_size=ReadBlobLong(image);\n  offset+=4;\n  offset+=ReadBlob(image,sizeof(cin.file.version),(unsigned char *)\n    cin.file.version);\n  (void) CopyMagickString(property,cin.file.version,sizeof(cin.file.version));\n  (void) SetImageProperty(image,\"dpx:file.version\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.file.filename),(unsigned char *)\n    cin.file.filename);\n  (void) CopyMagickString(property,cin.file.filename,sizeof(cin.file.filename));\n  (void) SetImageProperty(image,\"dpx:file.filename\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.file.create_date),(unsigned char *)\n    cin.file.create_date);\n  (void) CopyMagickString(property,cin.file.create_date,\n    sizeof(cin.file.create_date));\n  (void) SetImageProperty(image,\"dpx:file.create_date\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.file.create_time),(unsigned char *)\n    cin.file.create_time);\n  (void) CopyMagickString(property,cin.file.create_time,\n    sizeof(cin.file.create_time));\n  (void) SetImageProperty(image,\"dpx:file.create_time\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.file.reserve),(unsigned char *)\n    cin.file.reserve);\n  /*\n    Image information.\n  */\n  cin.image.orientation=(unsigned char) ReadBlobByte(image);\n  offset++;\n  if (cin.image.orientation != (unsigned char) (~0))\n    (void) FormatImageProperty(image,\"dpx:image.orientation\",\"%d\",\n      cin.image.orientation);\n  switch (cin.image.orientation)\n  {\n    default:\n    case 0: image->orientation=TopLeftOrientation; break;\n    case 1: image->orientation=TopRightOrientation; break;\n    case 2: image->orientation=BottomLeftOrientation; break;\n    case 3: image->orientation=BottomRightOrientation; break;\n    case 4: image->orientation=LeftTopOrientation; break;\n    case 5: image->orientation=RightTopOrientation; break;\n    case 6: image->orientation=LeftBottomOrientation; break;\n    case 7: image->orientation=RightBottomOrientation; break;\n  }\n  cin.image.number_channels=(unsigned char) ReadBlobByte(image);\n  offset++;\n  offset+=ReadBlob(image,sizeof(cin.image.reserve1),(unsigned char *)\n    cin.image.reserve1);\n  for (i=0; i < 8; i++)\n  {\n    cin.image.channel[i].designator[0]=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].designator[1]=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].bits_per_pixel=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].reserve=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].pixels_per_line=ReadBlobLong(image);\n    offset+=4;\n    cin.image.channel[i].lines_per_image=ReadBlobLong(image);\n    offset+=4;\n    cin.image.channel[i].min_data=ReadBlobFloat(image);\n    offset+=4;\n    cin.image.channel[i].min_quantity=ReadBlobFloat(image);\n    offset+=4;\n    cin.image.channel[i].max_data=ReadBlobFloat(image);\n    offset+=4;\n    cin.image.channel[i].max_quantity=ReadBlobFloat(image);\n    offset+=4;\n  }\n  cin.image.white_point[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.white_point[0]) != MagickFalse)\n    image->chromaticity.white_point.x=cin.image.white_point[0];\n  cin.image.white_point[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.white_point[1]) != MagickFalse)\n    image->chromaticity.white_point.y=cin.image.white_point[1];\n  cin.image.red_primary_chromaticity[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.red_primary_chromaticity[0]) != MagickFalse)\n    image->chromaticity.red_primary.x=cin.image.red_primary_chromaticity[0];\n  cin.image.red_primary_chromaticity[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.red_primary_chromaticity[1]) != MagickFalse)\n    image->chromaticity.red_primary.y=cin.image.red_primary_chromaticity[1];\n  cin.image.green_primary_chromaticity[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.green_primary_chromaticity[0]) != MagickFalse)\n    image->chromaticity.red_primary.x=cin.image.green_primary_chromaticity[0];\n  cin.image.green_primary_chromaticity[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.green_primary_chromaticity[1]) != MagickFalse)\n    image->chromaticity.green_primary.y=cin.image.green_primary_chromaticity[1];\n  cin.image.blue_primary_chromaticity[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.blue_primary_chromaticity[0]) != MagickFalse)\n    image->chromaticity.blue_primary.x=cin.image.blue_primary_chromaticity[0];\n  cin.image.blue_primary_chromaticity[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.blue_primary_chromaticity[1]) != MagickFalse)\n    image->chromaticity.blue_primary.y=cin.image.blue_primary_chromaticity[1];\n  offset+=ReadBlob(image,sizeof(cin.image.label),(unsigned char *)\n    cin.image.label);\n  (void) CopyMagickString(property,cin.image.label,sizeof(cin.image.label));\n  (void) SetImageProperty(image,\"dpx:image.label\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.image.reserve),(unsigned char *)\n    cin.image.reserve);\n  /*\n    Image data format information.\n  */\n  cin.data_format.interleave=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.packing=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.sign=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.sense=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.line_pad=ReadBlobLong(image);\n  offset+=4;\n  cin.data_format.channel_pad=ReadBlobLong(image);\n  offset+=4;\n  offset+=ReadBlob(image,sizeof(cin.data_format.reserve),(unsigned char *)\n    cin.data_format.reserve);\n  /*\n    Image origination information.\n  */\n  cin.origination.x_offset=ReadBlobSignedLong(image);\n  offset+=4;\n  if ((size_t) cin.origination.x_offset != ~0UL)\n    (void) FormatImageProperty(image,\"dpx:origination.x_offset\",\"%.20g\",\n      (double) cin.origination.x_offset);\n  cin.origination.y_offset=(ssize_t) ReadBlobLong(image);\n  offset+=4;\n  if ((size_t) cin.origination.y_offset != ~0UL)\n    (void) FormatImageProperty(image,\"dpx:origination.y_offset\",\"%.20g\",\n      (double) cin.origination.y_offset);\n  offset+=ReadBlob(image,sizeof(cin.origination.filename),(unsigned char *)\n    cin.origination.filename);\n  (void) CopyMagickString(property,cin.origination.filename,\n    sizeof(cin.origination.filename));\n  (void) SetImageProperty(image,\"dpx:origination.filename\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.origination.create_date),(unsigned char *)\n    cin.origination.create_date);\n  (void) CopyMagickString(property,cin.origination.create_date,\n    sizeof(cin.origination.create_date));\n  (void) SetImageProperty(image,\"dpx:origination.create_date\",property,\n    exception);\n  offset+=ReadBlob(image,sizeof(cin.origination.create_time),(unsigned char *)\n    cin.origination.create_time);\n  (void) CopyMagickString(property,cin.origination.create_time,\n    sizeof(cin.origination.create_time));\n  (void) SetImageProperty(image,\"dpx:origination.create_time\",property,\n    exception);\n  offset+=ReadBlob(image,sizeof(cin.origination.device),(unsigned char *)\n    cin.origination.device);\n  (void) CopyMagickString(property,cin.origination.device,\n    sizeof(cin.origination.device));\n  (void) SetImageProperty(image,\"dpx:origination.device\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.origination.model),(unsigned char *)\n    cin.origination.model);\n  (void) CopyMagickString(property,cin.origination.model,\n    sizeof(cin.origination.model));\n  (void) SetImageProperty(image,\"dpx:origination.model\",property,exception);\n  (void) memset(cin.origination.serial,0, \n    sizeof(cin.origination.serial));\n  offset+=ReadBlob(image,sizeof(cin.origination.serial),(unsigned char *)\n    cin.origination.serial);\n  (void) CopyMagickString(property,cin.origination.serial,\n    sizeof(cin.origination.serial));\n  (void) SetImageProperty(image,\"dpx:origination.serial\",property,exception);\n  cin.origination.x_pitch=ReadBlobFloat(image);\n  offset+=4;\n  cin.origination.y_pitch=ReadBlobFloat(image);\n  offset+=4;\n  cin.origination.gamma=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.origination.gamma) != MagickFalse)\n    image->gamma=cin.origination.gamma;\n  offset+=ReadBlob(image,sizeof(cin.origination.reserve),(unsigned char *)\n    cin.origination.reserve);\n  if ((cin.file.image_offset > 2048) && (cin.file.user_length != 0))\n    {\n      int\n        c;\n\n      /*\n        Image film information.\n      */\n      cin.film.id=ReadBlobByte(image);\n      offset++;\n      c=cin.film.id;\n      if (c != ~0)\n        (void) FormatImageProperty(image,\"dpx:film.id\",\"%d\",cin.film.id);\n      cin.film.type=ReadBlobByte(image);\n      offset++;\n      c=cin.film.type;\n      if (c != ~0)\n        (void) FormatImageProperty(image,\"dpx:film.type\",\"%d\",cin.film.type);\n      cin.film.offset=ReadBlobByte(image);\n      offset++;\n      c=cin.film.offset;\n      if (c != ~0)\n        (void) FormatImageProperty(image,\"dpx:film.offset\",\"%d\",\n          cin.film.offset);\n      cin.film.reserve1=ReadBlobByte(image);\n      offset++;\n      cin.film.prefix=ReadBlobLong(image);\n      offset+=4;\n      if (cin.film.prefix != ~0UL)\n        (void) FormatImageProperty(image,\"dpx:film.prefix\",\"%.20g\",(double)\n          cin.film.prefix);\n      cin.film.count=ReadBlobLong(image);\n      offset+=4;\n      offset+=ReadBlob(image,sizeof(cin.film.format),(unsigned char *)\n        cin.film.format);\n      (void) CopyMagickString(property,cin.film.format,sizeof(cin.film.format));\n      (void) SetImageProperty(image,\"dpx:film.format\",property,exception);\n      cin.film.frame_position=ReadBlobLong(image);\n      offset+=4;\n      if (cin.film.frame_position != ~0UL)\n        (void) FormatImageProperty(image,\"dpx:film.frame_position\",\"%.20g\",\n          (double) cin.film.frame_position);\n      cin.film.frame_rate=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(cin.film.frame_rate) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:film.frame_rate\",\"%g\",\n          cin.film.frame_rate);\n      offset+=ReadBlob(image,sizeof(cin.film.frame_id),(unsigned char *)\n        cin.film.frame_id);\n      (void) CopyMagickString(property,cin.film.frame_id,\n        sizeof(cin.film.frame_id));\n      (void) SetImageProperty(image,\"dpx:film.frame_id\",property,exception);\n      offset+=ReadBlob(image,sizeof(cin.film.slate_info),(unsigned char *)\n        cin.film.slate_info);\n      (void) CopyMagickString(property,cin.film.slate_info,\n        sizeof(cin.film.slate_info));\n      (void) SetImageProperty(image,\"dpx:film.slate_info\",property,exception);\n      offset+=ReadBlob(image,sizeof(cin.film.reserve),(unsigned char *)\n        cin.film.reserve);\n    }\n  if ((cin.file.image_offset > 2048) && (cin.file.user_length != 0))\n    {\n      StringInfo\n        *profile;\n\n      /*\n        User defined data.\n      */\n      if (cin.file.user_length > GetBlobSize(image))\n        ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n      profile=BlobToStringInfo((const unsigned char *) NULL,\n        cin.file.user_length);\n      if (profile == (StringInfo *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      offset+=ReadBlob(image,GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n      (void) SetImageProfile(image,\"dpx:user.data\",profile,exception);\n      profile=DestroyStringInfo(profile);\n    }\n  image->depth=cin.image.channel[0].bits_per_pixel;\n  image->columns=cin.image.channel[0].pixels_per_line;\n  image->rows=cin.image.channel[0].lines_per_image;\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(image);\n    }\n  if (((MagickSizeType) image->columns*image->rows/8) > GetBlobSize(image))\n    ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n  for ( ; offset < (MagickOffsetType) cin.file.image_offset; offset++)\n  {\n    int\n      c;\n\n    c=ReadBlobByte(image);\n    if (c == EOF)\n      break;\n  }\n  if (offset < (MagickOffsetType) cin.file.image_offset)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  (void) SetImageBackgroundColor(image,exception);\n  /*\n    Convert CIN raster image to pixel packets.\n  */\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  SetQuantumQuantum(quantum_info,32);\n  SetQuantumPack(quantum_info,MagickFalse);\n  quantum_type=RGBQuantum;\n  length=GetBytesPerRow(image->columns,3,image->depth,MagickTrue);\n  if (cin.image.number_channels == 1)\n    {\n      quantum_type=GrayQuantum;\n      length=GetBytesPerRow(image->columns,1,image->depth,MagickTrue);\n    }\n  status=SetQuantumPad(image,quantum_info,0);\n  pixels=GetQuantumPixels(quantum_info);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    const void\n      *stream;\n\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    stream=ReadBlobStream(image,length,pixels,&count);\n    if ((size_t) count != length)\n      break;\n    (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n      quantum_type,(unsigned char *) stream,exception);\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  SetQuantumImageType(image,quantum_type);\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  SetImageColorspace(image,LogColorspace,exception);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/timer-private.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/property.h\"\n\n// Type Definitions:\n// Quantum:\ntypedef MagickDoubleType Quantum;\n\n// ImageInfo:\ntypedef struct _ImageInfo ImageInfo;\n\n// MagickBooleanType:\ntypedef enum\n{\n  MagickFalse = 0,\n  MagickTrue = 1\n}\n\n// Image:\nclass MagickPPExport Image\n  {\n  public:\n\n    // Default constructor\n    Image(void);\n\n    // Construct Image from in-memory BLOB\n    Image(const Blob &blob_);\n\n    // Construct Image of specified size from in-memory BLOB\n    Image(const Blob &blob_,const Geometry &size_);\n\n    // Construct Image of specified size and depth from in-memory BLOB\n    Image(const Blob &blob_,const Geometry &size_,const size_t depth_);\n\n    // Construct Image of specified size, depth, and format from\n    // in-memory BLOB\n    Image(const Blob &blob_,const Geometry &size_,const size_t depth_,\n      const std::string &magick_);\n\n    // Construct Image of specified size, and format from in-memory BLOB\n    Image(const Blob &blob_,const Geometry &size_,const std::string &magick_);\n\n    // Construct a blank image canvas of specified size and color\n    Image(const Geometry &size_,const Color &color_);\n\n    // Copy constructor\n    Image(const Image &image_);\n\n    // Copy constructor to copy part of the image\n   ...\n\n// StringInfo:\ntypedef struct _StringInfo\n{\n  char\n    *path;\n\n  unsigned char\n    *datum;\n\n  size_t\n    length,\n    signature;\n\n  char\n    *name;\n} StringInfo;\n\n// ExceptionInfo:\ntypedef struct _ExceptionInfo ExceptionInfo;\n\n// Image:\nMagick.Image.Image:ANY(void)\n\n// CINInfo:\ntypedef struct CINInfo\n{\n  CINFileInfo\n    file;\n\n  CINImageInfo\n    image;\n\n  CINDataFormatInfo\n    data_format;\n\n  CINOriginationInfo\n    origination;\n\n  CINFilmInfo\n    film;\n\n  CINUserInfo\n    user;\n}\n\n// QuantumInfo:\ntypedef struct _QuantumInfo\n  QuantumInfo;\n\n// MagickOffsetType:\ntypedef long long MagickOffsetType;\n\n// _StringInfo:\ntypedef struct _StringInfo\n{\n  char\n    *path;\n\n  unsigned char\n    *datum;\n\n  size_t\n    length,\n    signature;\n\n  char\n    *name;\n}\n\n// _Image:\nstruct _Image\n{\n  ClassType\n    storage_class;\n\n  ColorspaceType\n    colorspace;         /* colorspace of image data */\n\n  CompressionType\n    compression;        /* compression of image when read/write */\n\n  size_t\n    quality;            /* compression quality setting, meaning varies */\n\n  OrientationType\n    orientation;        /* photo orientation of image */\n\n  MagickBooleanType\n    taint;              /* has image been modified since reading */\n\n  size_t\n    columns,            /* physical size of image */\n    rows,\n    depth,              /* depth of image on read/write */\n    colors;             /* Size of color table, or actual color count */\n                        /* Only valid if image is not DirectClass */\n\n  PixelInfo\n    *colormap,\n    alpha_color,        /* deprecated */\n    background_color,   /* current background color attribute */\n    border_color,       /* current bordercolor attribute */\n    transparent_color;  /* color for 'transparent' color index in GIF */\n\n...\n\n// QuantumType:\ntypedef enum\n{\n  UndefinedQuantum,\n  AlphaQuantum,\n  BGRAQuantum,\n  BGROQuantum,\n  BGRQuantum,\n  BlackQuantum,\n  BlueQuantum,\n  CbYCrAQuantum,\n  CbYCrQuantum,\n  CbYCrYQuantum,\n  CMYKAQuantum,\n  CMYKOQuantum,\n  CMYKQuantum,\n  CyanQuantum,\n  GrayAlphaQuantum,\n  GrayQuantum,\n  GreenQuantum,\n  IndexAlphaQuantum,\n  IndexQuantum,\n  MagentaQuantum,\n  OpacityQuantum,\n  RedQuantum,\n  RGBAQuantum,\n  RGBOQuantum,\n  RGBPadQuantum,\n  RGBQuantum,\n  YellowQuantum\n}\n\n// CINInfo:\ntypedef struct CINInfo\n{\n  CINFileInfo\n    file;\n\n  CINImageInfo\n    image;\n\n  CINDataFormatInfo\n    data_format;\n\n  CINOriginationInfo\n    origination;\n\n  CINFilmInfo\n    film;\n\n  CINUserInfo\n    user;\n} CINInfo;\n\n// _QuantumInfo:\nstruct _QuantumInfo\n{\n  size_t\n    depth,\n    quantum;\n\n  QuantumFormatType\n    format;\n\n  double\n    minimum,\n    maximum,\n    scale;\n\n  size_t\n    pad;\n\n  MagickBooleanType\n    min_is_white,\n    pack;\n\n  QuantumAlphaType\n    alpha_type;\n\n  size_t\n    number_threads;\n\n  MemoryInfo\n    **pixels;\n\n  size_t\n    extent;\n\n  EndianType\n    endian;\n\n  QuantumState\n    state;\n\n  SemaphoreInfo\n    *semaphore;\n\n  size_t\n    signature;\n}\n\n// Called Methods (top 10):\n// GetStringInfoDatum from MagickCore/string.c:\nunsigned char *GetStringInfoDatum(const StringInfo *string_info)\n{\n  assert(string_info != (StringInfo *) NULL);\n  assert(string_info->signature == MagickCoreSignature);\n  return(string_info->datum);\n}\n\n// GetStringInfoLength from MagickCore/string.c:\nsize_t GetStringInfoLength(const StringInfo *string_info)\n{\n  assert(string_info != (StringInfo *) NULL);\n  assert(string_info->signature == MagickCoreSignature);\n  return(string_info->length);\n}\n\n// BlobToStringInfo from MagickCore/string.c:\nStringInfo *BlobToStringInfo(const void *blob,const size_t length)\n{\n  StringInfo\n    *string_info;\n\n  if (~length < MagickPathExtent)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  string_info=AcquireStringInfoContainer();\n  string_info->length=length;\n  string_info->datum=(unsigned char *) AcquireQuantumMemory(length+\n    MagickPathExtent,sizeof(*string_info->datum));\n  if (string_info->datum == (unsigned char *) NULL)\n    {\n      string_info=DestroyStringInfo(string_info);\n      return((StringInfo *) NULL);\n    }\n  if (blob != (const void *) NULL)\n    (void) memcpy(string_info->datum,blob,length);\n  else\n    (void) memset(string_info->datum,0,length*sizeof(*string_info->datum));\n  (void) memset(string_info->datum+length,0,MagickPathExtent*\n    sizeof(*string_info->datum));\n  return(string_info);\n}\n\n// ImportQuantumPixels from MagickCore/quantum-import.c:\nsize_t ImportQuantumPixels(const Image *image,\n  CacheView *image_view,QuantumInfo *quantum_info,\n  const QuantumType quantum_type,const unsigned char *magick_restrict pixels,\n  ExceptionInfo *exception)\n{\n  MagickSizeType\n    number_pixels;\n\n  const unsigned char\n    *magick_restrict p;\n\n  ssize_t\n    x;\n\n  Quantum\n    *magick_restrict q;\n\n  size_t\n    extent;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  if (pixels == (const unsigned char *) NULL)\n    pixels=(const unsigned char *) GetQuantumPixels(quantum_info);\n  x=0;\n  p=pixels;\n  if (image_view == (CacheView *) NULL)\n    {\n      number_pixels=GetImageExtent(image);\n      q=GetAuthenticPixelQueue(image);\n    }\n  else\n    {\n      number_pixels=GetCacheViewExtent(image_vie...\n\n// QueueAuthenticPixels from MagickCore/cache.c:\nQuantum *QueueAuthenticPixels(Image *image,const ssize_t x,\n  const ssize_t y,const size_t columns,const size_t rows,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  Quantum\n    *magick_restrict pixels;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->methods.queue_authentic_pixels_handler !=\n      (QueueAuthenticPixelsHandler) NULL)\n    {\n      pixels=cache_info->methods.queue_authentic_pixels_handler(image,x,y,\n        columns,rows,exception);\n      return(pixels);\n    }\n  assert(id < (int) cache_info->number_threads);\n  pixels=QueueAuthenticPixelCacheNexus(image,x,y,columns,rows,MagickFalse,\n    cache_info->nexus_info[id],exception);\n  return(pixels);\n}\n\n// MagickCoreSignature from coders/MagickCore/MagickCore/method-attribute.h:\n<empty>\n\n// AcquireImage from MagickCore/image.c:\nImage *AcquireImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  const char\n    *option;\n\n  Image\n    *image;\n\n  MagickStatusType\n    flags;\n\n  /*\n    Allocate image structure.\n  */\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  image=(Image *) AcquireCriticalMemory(sizeof(*image));\n  (void) memset(image,0,sizeof(*image));\n  /*\n    Initialize Image structure.\n  */\n  (void) CopyMagickString(image->magick,\"MIFF\",MagickPathExtent);\n  image->storage_class=DirectClass;\n  image->depth=MAGICKCORE_QUANTUM_DEPTH;\n  image->colorspace=sRGBColorspace;\n  image->rendering_intent=PerceptualIntent;\n  image->gamma=1.000f/2.200f;\n  image->chromaticity.red_primary.x=0.6400f;\n  image->chromaticity.red_primary.y=0.3300f;\n  image->chromaticity.red_primary.z=0.0300f;\n  image->chromaticity.green_primary.x=0.3000f;\n  image->chromaticity.green_primary.y=0.6000f;\n  image->chromaticity.green_primary.z=0.1000f;\n  image->chromaticity.blue_primary.x=0.1500f;\n  image->chromaticity.b...\n\n// GetBlobSize from MagickCore/blob.c:\nMagickSizeType GetBlobSize(const Image *image)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  MagickSizeType\n    extent;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(image->blob != (BlobInfo *) NULL);\n  blob_info=image->blob;\n  extent=0;\n  switch (blob_info->type)\n  {\n    case UndefinedStream:\n    case StandardStream:\n    {\n      extent=blob_info->size;\n      break;\n    }\n    case FileStream:\n    {\n      int\n        file_descriptor;\n\n      extent=(MagickSizeType) blob_info->properties.st_size;\n      if (extent == 0)\n        extent=blob_info->size;\n      file_descriptor=fileno(blob_info->file_info.file);\n      if (file_descriptor == -1)\n        break;\n      if (fstat(file_descriptor,&blob_info->properties) == 0)\n        extent=(MagickSizeType) blob_info->properties.st_size;\n      break;\n    }\n    case PipeStream:\n    {\n  ...\n\n// GetFirstImageInList from MagickCore/list.c:\nImage *GetFirstImageInList(const Image *images)\n{\n  const Image\n    *p;\n\n  if (images == (Image *) NULL)\n    return((Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  for (p=images; p->previous != (Image *) NULL; p=p->previous) ;\n  return((Image *) p);\n}\n\n// SetImageBackgroundColor from MagickCore/image.c:\nMagickBooleanType SetImageBackgroundColor(Image *image,\n  ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  PixelInfo\n    background;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickCoreSignature);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  if ((image->background_color.alpha_trait != UndefinedPixelTrait) &&\n      (image->alpha_trait == UndefinedPixelTrait))\n    (void) SetImageAlphaChannel(image,OnAlphaChannel,exception);\n  ConformPixelInfo(image,&image->background_color,&background,exception);\n  /*\n    Set image background color.\n  */\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    Quantum\n      *magick_restrict q;\n\n    ssize_t\n      x;\n\n    if (status == MagickFalse)\n...\n"
  },
  {
    "repository": "vim",
    "cve_id": "CVE-2022-2126",
    "cwe_list": [
      "CWE-787"
    ],
    "commit_hash": "156d3911952d73b03d7420dc3540215247db0fe8",
    "short_hash": "156d3911",
    "vulnerableMethods_before": [
      {
        "filename": "spellsuggest.c",
        "method_name": "vulnerable_function",
        "raw_code": "suggest_trie_walk(\n    suginfo_T\t*su,\n    langp_T\t*lp,\n    char_u\t*fword,\n    int\t\tsoundfold)\n{\n    char_u\ttword[MAXWLEN];\t    // good word collected so far\n    trystate_T\tstack[MAXWLEN];\n    char_u\tpreword[MAXWLEN * 3]; // word found with proper case;\n\t\t\t\t      // concatenation of prefix compound\n\t\t\t\t      // words and split word.  NUL terminated\n\t\t\t\t      // when going deeper but not when coming\n\t\t\t\t      // back.\n    char_u\tcompflags[MAXWLEN];\t// compound flags, one for each word\n    trystate_T\t*sp;\n    int\t\tnewscore;\n    int\t\tscore;\n    char_u\t*byts, *fbyts, *pbyts;\n    idx_T\t*idxs, *fidxs, *pidxs;\n    int\t\tdepth;\n    int\t\tc, c2, c3;\n    int\t\tn = 0;\n    int\t\tflags;\n    garray_T\t*gap;\n    idx_T\tarridx;\n    int\t\tlen;\n    char_u\t*p;\n    fromto_T\t*ftp;\n    int\t\tfl = 0, tl;\n    int\t\trepextra = 0;\t    // extra bytes in fword[] from REP item\n    slang_T\t*slang = lp->lp_slang;\n    int\t\tfword_ends;\n    int\t\tgoodword_ends;\n#ifdef DEBUG_TRIEWALK\n    // Stores the name of the change made at each level.\n    char_u\tchangename[MAXWLEN][80];\n#endif\n    int\t\tbreakcheckcount = 1000;\n#ifdef FEAT_RELTIME\n    proftime_T\ttime_limit;\n#endif\n    int\t\tcompound_ok;\n\n    // Go through the whole case-fold tree, try changes at each node.\n    // \"tword[]\" contains the word collected from nodes in the tree.\n    // \"fword[]\" the word we are trying to match with (initially the bad\n    // word).\n    depth = 0;\n    sp = &stack[0];\n    CLEAR_POINTER(sp);\n    sp->ts_curi = 1;\n\n    if (soundfold)\n    {\n\t// Going through the soundfold tree.\n\tbyts = fbyts = slang->sl_sbyts;\n\tidxs = fidxs = slang->sl_sidxs;\n\tpbyts = NULL;\n\tpidxs = NULL;\n\tsp->ts_prefixdepth = PFD_NOPREFIX;\n\tsp->ts_state = STATE_START;\n    }\n    else\n    {\n\t// When there are postponed prefixes we need to use these first.  At\n\t// the end of the prefix we continue in the case-fold tree.\n\tfbyts = slang->sl_fbyts;\n\tfidxs = slang->sl_fidxs;\n\tpbyts = slang->sl_pbyts;\n\tpidxs = slang->sl_pidxs;\n\tif (pbyts != NULL)\n\t{\n\t    byts = pbyts;\n\t    idxs = pidxs;\n\t    sp->ts_prefixdepth = PFD_PREFIXTREE;\n\t    sp->ts_state = STATE_NOPREFIX;\t// try without prefix first\n\t}\n\telse\n\t{\n\t    byts = fbyts;\n\t    idxs = fidxs;\n\t    sp->ts_prefixdepth = PFD_NOPREFIX;\n\t    sp->ts_state = STATE_START;\n\t}\n    }\n#ifdef FEAT_RELTIME\n    // The loop may take an indefinite amount of time. Break out after some\n    // time.\n    if (spell_suggest_timeout > 0)\n\tprofile_setlimit(spell_suggest_timeout, &time_limit);\n#endif\n\n    // Loop to find all suggestions.  At each round we either:\n    // - For the current state try one operation, advance \"ts_curi\",\n    //   increase \"depth\".\n    // - When a state is done go to the next, set \"ts_state\".\n    // - When all states are tried decrease \"depth\".\n    while (depth >= 0 && !got_int)\n    {\n\tsp = &stack[depth];\n\tswitch (sp->ts_state)\n\t{\n\tcase STATE_START:\n\tcase STATE_NOPREFIX:\n\t    // Start of node: Deal with NUL bytes, which means\n\t    // tword[] may end here.\n\t    arridx = sp->ts_arridx;\t    // current node in the tree\n\t    len = byts[arridx];\t\t    // bytes in this node\n\t    arridx += sp->ts_curi;\t    // index of current byte\n\n\t    if (sp->ts_prefixdepth == PFD_PREFIXTREE)\n\t    {\n\t\t// Skip over the NUL bytes, we use them later.\n\t\tfor (n = 0; n < len && byts[arridx + n] == 0; ++n)\n\t\t    ;\n\t\tsp->ts_curi += n;\n\n\t\t// Always past NUL bytes now.\n\t\tn = (int)sp->ts_state;\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_ENDNUL;\n\t\tsp->ts_save_badflags = su->su_badflags;\n\n\t\t// At end of a prefix or at start of prefixtree: check for\n\t\t// following word.\n\t\tif (depth < MAXWLEN - 1\n\t\t\t    && (byts[arridx] == 0 || n == (int)STATE_NOPREFIX))\n\t\t{\n\t\t    // Set su->su_badflags to the caps type at this position.\n\t\t    // Use the caps type until here for the prefix itself.\n\t\t    if (has_mbyte)\n\t\t\tn = nofold_len(fword, sp->ts_fidx, su->su_badptr);\n\t\t    else\n\t\t\tn = sp->ts_fidx;\n\t\t    flags = badword_captype(su->su_badptr, su->su_badptr + n);\n\t\t    su->su_badflags = badword_captype(su->su_badptr + n,\n\t\t\t\t\t       su->su_badptr + su->su_badlen);\n#ifdef DEBUG_TRIEWALK\n\t\t    sprintf(changename[depth], \"prefix\");\n#endif\n\t\t    go_deeper(stack, depth, 0);\n\t\t    ++depth;\n\t\t    sp = &stack[depth];\n\t\t    sp->ts_prefixdepth = depth - 1;\n\t\t    byts = fbyts;\n\t\t    idxs = fidxs;\n\t\t    sp->ts_arridx = 0;\n\n\t\t    // Move the prefix to preword[] with the right case\n\t\t    // and make find_keepcap_word() works.\n\t\t    tword[sp->ts_twordlen] = NUL;\n\t\t    make_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t  preword + sp->ts_prewordlen, flags);\n\t\t    sp->ts_prewordlen = (char_u)STRLEN(preword);\n\t\t    sp->ts_splitoff = sp->ts_twordlen;\n\t\t}\n\t\tbreak;\n\t    }\n\n\t    if (sp->ts_curi > len || byts[arridx] != 0)\n\t    {\n\t\t// Past bytes in node and/or past NUL bytes.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_ENDNUL;\n\t\tsp->ts_save_badflags = su->su_badflags;\n\t\tbreak;\n\t    }\n\n\t    // End of word in tree.\n\t    ++sp->ts_curi;\t\t// eat one NUL byte\n\n\t    flags = (int)idxs[arridx];\n\n\t    // Skip words with the NOSUGGEST flag.\n\t    if (flags & WF_NOSUGGEST)\n\t\tbreak;\n\n\t    fword_ends = (fword[sp->ts_fidx] == NUL\n\t\t\t   || (soundfold\n\t\t\t       ? VIM_ISWHITE(fword[sp->ts_fidx])\n\t\t\t       : !spell_iswordp(fword + sp->ts_fidx, curwin)));\n\t    tword[sp->ts_twordlen] = NUL;\n\n\t    if (sp->ts_prefixdepth <= PFD_NOTSPECIAL\n\t\t\t\t\t&& (sp->ts_flags & TSF_PREFIXOK) == 0\n\t\t\t\t\t&& pbyts != NULL)\n\t    {\n\t\t// There was a prefix before the word.  Check that the prefix\n\t\t// can be used with this word.\n\t\t// Count the length of the NULs in the prefix.  If there are\n\t\t// none this must be the first try without a prefix.\n\t\tn = stack[sp->ts_prefixdepth].ts_arridx;\n\t\tlen = pbyts[n++];\n\t\tfor (c = 0; c < len && pbyts[n + c] == 0; ++c)\n\t\t    ;\n\t\tif (c > 0)\n\t\t{\n\t\t    c = valid_word_prefix(c, n, flags,\n\t\t\t\t       tword + sp->ts_splitoff, slang, FALSE);\n\t\t    if (c == 0)\n\t\t\tbreak;\n\n\t\t    // Use the WF_RARE flag for a rare prefix.\n\t\t    if (c & WF_RAREPFX)\n\t\t\tflags |= WF_RARE;\n\n\t\t    // Tricky: when checking for both prefix and compounding\n\t\t    // we run into the prefix flag first.\n\t\t    // Remember that it's OK, so that we accept the prefix\n\t\t    // when arriving at a compound flag.\n\t\t    sp->ts_flags |= TSF_PREFIXOK;\n\t\t}\n\t    }\n\n\t    // Check NEEDCOMPOUND: can't use word without compounding.  Do try\n\t    // appending another compound word below.\n\t    if (sp->ts_complen == sp->ts_compsplit && fword_ends\n\t\t\t\t\t\t     && (flags & WF_NEEDCOMP))\n\t\tgoodword_ends = FALSE;\n\t    else\n\t\tgoodword_ends = TRUE;\n\n\t    p = NULL;\n\t    compound_ok = TRUE;\n\t    if (sp->ts_complen > sp->ts_compsplit)\n\t    {\n\t\tif (slang->sl_nobreak)\n\t\t{\n\t\t    // There was a word before this word.  When there was no\n\t\t    // change in this word (it was correct) add the first word\n\t\t    // as a suggestion.  If this word was corrected too, we\n\t\t    // need to check if a correct word follows.\n\t\t    if (sp->ts_fidx - sp->ts_splitfidx\n\t\t\t\t\t  == sp->ts_twordlen - sp->ts_splitoff\n\t\t\t    && STRNCMP(fword + sp->ts_splitfidx,\n\t\t\t\t\ttword + sp->ts_splitoff,\n\t\t\t\t\t sp->ts_fidx - sp->ts_splitfidx) == 0)\n\t\t    {\n\t\t\tpreword[sp->ts_prewordlen] = NUL;\n\t\t\tnewscore = score_wordcount_adj(slang, sp->ts_score,\n\t\t\t\t\t\t preword + sp->ts_prewordlen,\n\t\t\t\t\t\t sp->ts_prewordlen > 0);\n\t\t\t// Add the suggestion if the score isn't too bad.\n\t\t\tif (newscore <= su->su_maxscore)\n\t\t\t    add_suggestion(su, &su->su_ga, preword,\n\t\t\t\t    sp->ts_splitfidx - repextra,\n\t\t\t\t    newscore, 0, FALSE,\n\t\t\t\t    lp->lp_sallang, FALSE);\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    // There was a compound word before this word.  If this\n\t\t    // word does not support compounding then give up\n\t\t    // (splitting is tried for the word without compound\n\t\t    // flag).\n\t\t    if (((unsigned)flags >> 24) == 0\n\t\t\t    || sp->ts_twordlen - sp->ts_splitoff\n\t\t\t\t\t\t       < slang->sl_compminlen)\n\t\t\tbreak;\n\t\t    // For multi-byte chars check character length against\n\t\t    // COMPOUNDMIN.\n\t\t    if (has_mbyte\n\t\t\t    && slang->sl_compminlen > 0\n\t\t\t    && mb_charlen(tword + sp->ts_splitoff)\n\t\t\t\t\t\t       < slang->sl_compminlen)\n\t\t\tbreak;\n\n\t\t    compflags[sp->ts_complen] = ((unsigned)flags >> 24);\n\t\t    compflags[sp->ts_complen + 1] = NUL;\n\t\t    vim_strncpy(preword + sp->ts_prewordlen,\n\t\t\t    tword + sp->ts_splitoff,\n\t\t\t    sp->ts_twordlen - sp->ts_splitoff);\n\n\t\t    // Verify CHECKCOMPOUNDPATTERN  rules.\n\t\t    if (match_checkcompoundpattern(preword,  sp->ts_prewordlen,\n\t\t\t\t\t\t\t  &slang->sl_comppat))\n\t\t\tcompound_ok = FALSE;\n\n\t\t    if (compound_ok)\n\t\t    {\n\t\t\tp = preword;\n\t\t\twhile (*skiptowhite(p) != NUL)\n\t\t\t    p = skipwhite(skiptowhite(p));\n\t\t\tif (fword_ends && !can_compound(slang, p,\n\t\t\t\t\t\tcompflags + sp->ts_compsplit))\n\t\t\t    // Compound is not allowed.  But it may still be\n\t\t\t    // possible if we add another (short) word.\n\t\t\t    compound_ok = FALSE;\n\t\t    }\n\n\t\t    // Get pointer to last char of previous word.\n\t\t    p = preword + sp->ts_prewordlen;\n\t\t    MB_PTR_BACK(preword, p);\n\t\t}\n\t    }\n\n\t    // Form the word with proper case in preword.\n\t    // If there is a word from a previous split, append.\n\t    // For the soundfold tree don't change the case, simply append.\n\t    if (soundfold)\n\t\tSTRCPY(preword + sp->ts_prewordlen, tword + sp->ts_splitoff);\n\t    else if (flags & WF_KEEPCAP)\n\t\t// Must find the word in the keep-case tree.\n\t\tfind_keepcap_word(slang, tword + sp->ts_splitoff,\n\t\t\t\t\t\t preword + sp->ts_prewordlen);\n\t    else\n\t    {\n\t\t// Include badflags: If the badword is onecap or allcap\n\t\t// use that for the goodword too.  But if the badword is\n\t\t// allcap and it's only one char long use onecap.\n\t\tc = su->su_badflags;\n\t\tif ((c & WF_ALLCAP)\n\t\t\t&& su->su_badlen == (*mb_ptr2len)(su->su_badptr))\n\t\t    c = WF_ONECAP;\n\t\tc |= flags;\n\n\t\t// When appending a compound word after a word character don't\n\t\t// use Onecap.\n\t\tif (p != NULL && spell_iswordp_nmw(p, curwin))\n\t\t    c &= ~WF_ONECAP;\n\t\tmake_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t      preword + sp->ts_prewordlen, c);\n\t    }\n\n\t    if (!soundfold)\n\t    {\n\t\t// Don't use a banned word.  It may appear again as a good\n\t\t// word, thus remember it.\n\t\tif (flags & WF_BANNED)\n\t\t{\n\t\t    add_banned(su, preword + sp->ts_prewordlen);\n\t\t    break;\n\t\t}\n\t\tif ((sp->ts_complen == sp->ts_compsplit\n\t\t\t    && WAS_BANNED(su, preword + sp->ts_prewordlen))\n\t\t\t\t\t\t   || WAS_BANNED(su, preword))\n\t\t{\n\t\t    if (slang->sl_compprog == NULL)\n\t\t\tbreak;\n\t\t    // the word so far was banned but we may try compounding\n\t\t    goodword_ends = FALSE;\n\t\t}\n\t    }\n\n\t    newscore = 0;\n\t    if (!soundfold)\t// soundfold words don't have flags\n\t    {\n\t\tif ((flags & WF_REGION)\n\t\t\t    && (((unsigned)flags >> 16) & lp->lp_region) == 0)\n\t\t    newscore += SCORE_REGION;\n\t\tif (flags & WF_RARE)\n\t\t    newscore += SCORE_RARE;\n\n\t\tif (!spell_valid_case(su->su_badflags,\n\t\t\t\t  captype(preword + sp->ts_prewordlen, NULL)))\n\t\t    newscore += SCORE_ICASE;\n\t    }\n\n\t    // TODO: how about splitting in the soundfold tree?\n\t    if (fword_ends\n\t\t    && goodword_ends\n\t\t    && sp->ts_fidx >= sp->ts_fidxtry\n\t\t    && compound_ok)\n\t    {\n\t\t// The badword also ends: add suggestions.\n#ifdef DEBUG_TRIEWALK\n\t\tif (soundfold && STRCMP(preword, \"smwrd\") == 0)\n\t\t{\n\t\t    int\t    j;\n\n\t\t    // print the stack of changes that brought us here\n\t\t    smsg(\"------ %s -------\", fword);\n\t\t    for (j = 0; j < depth; ++j)\n\t\t\tsmsg(\"%s\", changename[j]);\n\t\t}\n#endif\n\t\tif (soundfold)\n\t\t{\n\t\t    // For soundfolded words we need to find the original\n\t\t    // words, the edit distance and then add them.\n\t\t    add_sound_suggest(su, preword, sp->ts_score, lp);\n\t\t}\n\t\telse if (sp->ts_fidx > 0)\n\t\t{\n\t\t    // Give a penalty when changing non-word char to word\n\t\t    // char, e.g., \"thes,\" -> \"these\".\n\t\t    p = fword + sp->ts_fidx;\n\t\t    MB_PTR_BACK(fword, p);\n\t\t    if (!spell_iswordp(p, curwin) && *preword != NUL)\n\t\t    {\n\t\t\tp = preword + STRLEN(preword);\n\t\t\tMB_PTR_BACK(preword, p);\n\t\t\tif (spell_iswordp(p, curwin))\n\t\t\t    newscore += SCORE_NONWORD;\n\t\t    }\n\n\t\t    // Give a bonus to words seen before.\n\t\t    score = score_wordcount_adj(slang,\n\t\t\t\t\t\tsp->ts_score + newscore,\n\t\t\t\t\t\tpreword + sp->ts_prewordlen,\n\t\t\t\t\t\tsp->ts_prewordlen > 0);\n\n\t\t    // Add the suggestion if the score isn't too bad.\n\t\t    if (score <= su->su_maxscore)\n\t\t    {\n\t\t\tadd_suggestion(su, &su->su_ga, preword,\n\t\t\t\t    sp->ts_fidx - repextra,\n\t\t\t\t    score, 0, FALSE, lp->lp_sallang, FALSE);\n\n\t\t\tif (su->su_badflags & WF_MIXCAP)\n\t\t\t{\n\t\t\t    // We really don't know if the word should be\n\t\t\t    // upper or lower case, add both.\n\t\t\t    c = captype(preword, NULL);\n\t\t\t    if (c == 0 || c == WF_ALLCAP)\n\t\t\t    {\n\t\t\t\tmake_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t      preword + sp->ts_prewordlen,\n\t\t\t\t\t\t      c == 0 ? WF_ALLCAP : 0);\n\n\t\t\t\tadd_suggestion(su, &su->su_ga, preword,\n\t\t\t\t\tsp->ts_fidx - repextra,\n\t\t\t\t\tscore + SCORE_ICASE, 0, FALSE,\n\t\t\t\t\tlp->lp_sallang, FALSE);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t    // Try word split and/or compounding.\n\t    if ((sp->ts_fidx >= sp->ts_fidxtry || fword_ends)\n\t\t    // Don't split halfway a character.\n\t\t    && (!has_mbyte || sp->ts_tcharlen == 0))\n\t    {\n\t\tint\ttry_compound;\n\t\tint\ttry_split;\n\n\t\t// If past the end of the bad word don't try a split.\n\t\t// Otherwise try changing the next word.  E.g., find\n\t\t// suggestions for \"the the\" where the second \"the\" is\n\t\t// different.  It's done like a split.\n\t\t// TODO: word split for soundfold words\n\t\ttry_split = (sp->ts_fidx - repextra < su->su_badlen)\n\t\t\t\t\t\t\t\t&& !soundfold;\n\n\t\t// Get here in several situations:\n\t\t// 1. The word in the tree ends:\n\t\t//    If the word allows compounding try that.  Otherwise try\n\t\t//    a split by inserting a space.  For both check that a\n\t\t//    valid words starts at fword[sp->ts_fidx].\n\t\t//    For NOBREAK do like compounding to be able to check if\n\t\t//    the next word is valid.\n\t\t// 2. The badword does end, but it was due to a change (e.g.,\n\t\t//    a swap).  No need to split, but do check that the\n\t\t//    following word is valid.\n\t\t// 3. The badword and the word in the tree end.  It may still\n\t\t//    be possible to compound another (short) word.\n\t\ttry_compound = FALSE;\n\t\tif (!soundfold\n\t\t\t&& !slang->sl_nocompoundsugs\n\t\t\t&& slang->sl_compprog != NULL\n\t\t\t&& ((unsigned)flags >> 24) != 0\n\t\t\t&& sp->ts_twordlen - sp->ts_splitoff\n\t\t\t\t\t\t       >= slang->sl_compminlen\n\t\t\t&& (!has_mbyte\n\t\t\t    || slang->sl_compminlen == 0\n\t\t\t    || mb_charlen(tword + sp->ts_splitoff)\n\t\t\t\t\t\t      >= slang->sl_compminlen)\n\t\t\t&& (slang->sl_compsylmax < MAXWLEN\n\t\t\t    || sp->ts_complen + 1 - sp->ts_compsplit\n\t\t\t\t\t\t\t  < slang->sl_compmax)\n\t\t\t&& (can_be_compound(sp, slang,\n\t\t\t\t\t compflags, ((unsigned)flags >> 24))))\n\n\t\t{\n\t\t    try_compound = TRUE;\n\t\t    compflags[sp->ts_complen] = ((unsigned)flags >> 24);\n\t\t    compflags[sp->ts_complen + 1] = NUL;\n\t\t}\n\n\t\t// For NOBREAK we never try splitting, it won't make any word\n\t\t// valid.\n\t\tif (slang->sl_nobreak && !slang->sl_nocompoundsugs)\n\t\t    try_compound = TRUE;\n\n\t\t// If we could add a compound word, and it's also possible to\n\t\t// split at this point, do the split first and set\n\t\t// TSF_DIDSPLIT to avoid doing it again.\n\t\telse if (!fword_ends\n\t\t\t&& try_compound\n\t\t\t&& (sp->ts_flags & TSF_DIDSPLIT) == 0)\n\t\t{\n\t\t    try_compound = FALSE;\n\t\t    sp->ts_flags |= TSF_DIDSPLIT;\n\t\t    --sp->ts_curi;\t    // do the same NUL again\n\t\t    compflags[sp->ts_complen] = NUL;\n\t\t}\n\t\telse\n\t\t    sp->ts_flags &= ~TSF_DIDSPLIT;\n\n\t\tif (try_split || try_compound)\n\t\t{\n\t\t    if (!try_compound && (!fword_ends || !goodword_ends))\n\t\t    {\n\t\t\t// If we're going to split need to check that the\n\t\t\t// words so far are valid for compounding.  If there\n\t\t\t// is only one word it must not have the NEEDCOMPOUND\n\t\t\t// flag.\n\t\t\tif (sp->ts_complen == sp->ts_compsplit\n\t\t\t\t\t\t     && (flags & WF_NEEDCOMP))\n\t\t\t    break;\n\t\t\tp = preword;\n\t\t\twhile (*skiptowhite(p) != NUL)\n\t\t\t    p = skipwhite(skiptowhite(p));\n\t\t\tif (sp->ts_complen > sp->ts_compsplit\n\t\t\t\t&& !can_compound(slang, p,\n\t\t\t\t\t\tcompflags + sp->ts_compsplit))\n\t\t\t    break;\n\n\t\t\tif (slang->sl_nosplitsugs)\n\t\t\t    newscore += SCORE_SPLIT_NO;\n\t\t\telse\n\t\t\t    newscore += SCORE_SPLIT;\n\n\t\t\t// Give a bonus to words seen before.\n\t\t\tnewscore = score_wordcount_adj(slang, newscore,\n\t\t\t\t\t   preword + sp->ts_prewordlen, TRUE);\n\t\t    }\n\n\t\t    if (TRY_DEEPER(su, stack, depth, newscore))\n\t\t    {\n\t\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\t\tif (!try_compound && !fword_ends)\n\t\t\t    sprintf(changename[depth], \"%.*s-%s: split\",\n\t\t\t\t sp->ts_twordlen, tword, fword + sp->ts_fidx);\n\t\t\telse\n\t\t\t    sprintf(changename[depth], \"%.*s-%s: compound\",\n\t\t\t\t sp->ts_twordlen, tword, fword + sp->ts_fidx);\n#endif\n\t\t\t// Save things to be restored at STATE_SPLITUNDO.\n\t\t\tsp->ts_save_badflags = su->su_badflags;\n\t\t\tPROF_STORE(sp->ts_state)\n\t\t\tsp->ts_state = STATE_SPLITUNDO;\n\n\t\t\t++depth;\n\t\t\tsp = &stack[depth];\n\n\t\t\t// Append a space to preword when splitting.\n\t\t\tif (!try_compound && !fword_ends)\n\t\t\t    STRCAT(preword, \" \");\n\t\t\tsp->ts_prewordlen = (char_u)STRLEN(preword);\n\t\t\tsp->ts_splitoff = sp->ts_twordlen;\n\t\t\tsp->ts_splitfidx = sp->ts_fidx;\n\n\t\t\t// If the badword has a non-word character at this\n\t\t\t// position skip it.  That means replacing the\n\t\t\t// non-word character with a space.  Always skip a\n\t\t\t// character when the word ends.  But only when the\n\t\t\t// good word can end.\n\t\t\tif (((!try_compound && !spell_iswordp_nmw(fword\n\t\t\t\t\t\t\t       + sp->ts_fidx,\n\t\t\t\t\t\t\t       curwin))\n\t\t\t\t    || fword_ends)\n\t\t\t\t&& fword[sp->ts_fidx] != NUL\n\t\t\t\t&& goodword_ends)\n\t\t\t{\n\t\t\t    int\t    l;\n\n\t\t\t    l = mb_ptr2len(fword + sp->ts_fidx);\n\t\t\t    if (fword_ends)\n\t\t\t    {\n\t\t\t\t// Copy the skipped character to preword.\n\t\t\t\tmch_memmove(preword + sp->ts_prewordlen,\n\t\t\t\t\t\t      fword + sp->ts_fidx, l);\n\t\t\t\tsp->ts_prewordlen += l;\n\t\t\t\tpreword[sp->ts_prewordlen] = NUL;\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tsp->ts_score -= SCORE_SPLIT - SCORE_SUBST;\n\t\t\t    sp->ts_fidx += l;\n\t\t\t}\n\n\t\t\t// When compounding include compound flag in\n\t\t\t// compflags[] (already set above).  When splitting we\n\t\t\t// may start compounding over again.\n\t\t\tif (try_compound)\n\t\t\t    ++sp->ts_complen;\n\t\t\telse\n\t\t\t    sp->ts_compsplit = sp->ts_complen;\n\t\t\tsp->ts_prefixdepth = PFD_NOPREFIX;\n\n\t\t\t// set su->su_badflags to the caps type at this\n\t\t\t// position\n\t\t\tif (has_mbyte)\n\t\t\t    n = nofold_len(fword, sp->ts_fidx, su->su_badptr);\n\t\t\telse\n\t\t\t    n = sp->ts_fidx;\n\t\t\tsu->su_badflags = badword_captype(su->su_badptr + n,\n\t\t\t\t\t       su->su_badptr + su->su_badlen);\n\n\t\t\t// Restart at top of the tree.\n\t\t\tsp->ts_arridx = 0;\n\n\t\t\t// If there are postponed prefixes, try these too.\n\t\t\tif (pbyts != NULL)\n\t\t\t{\n\t\t\t    byts = pbyts;\n\t\t\t    idxs = pidxs;\n\t\t\t    sp->ts_prefixdepth = PFD_PREFIXTREE;\n\t\t\t    PROF_STORE(sp->ts_state)\n\t\t\t    sp->ts_state = STATE_NOPREFIX;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\n\tcase STATE_SPLITUNDO:\n\t    // Undo the changes done for word split or compound word.\n\t    su->su_badflags = sp->ts_save_badflags;\n\n\t    // Continue looking for NUL bytes.\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_START;\n\n\t    // In case we went into the prefix tree.\n\t    byts = fbyts;\n\t    idxs = fidxs;\n\t    break;\n\n\tcase STATE_ENDNUL:\n\t    // Past the NUL bytes in the node.\n\t    su->su_badflags = sp->ts_save_badflags;\n\t    if (fword[sp->ts_fidx] == NUL && sp->ts_tcharlen == 0)\n\t    {\n\t\t// The badword ends, can't use STATE_PLAIN.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_DEL;\n\t\tbreak;\n\t    }\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_PLAIN;\n\t    // FALLTHROUGH\n\n\tcase STATE_PLAIN:\n\t    // Go over all possible bytes at this node, add each to tword[]\n\t    // and use child node.  \"ts_curi\" is the index.\n\t    arridx = sp->ts_arridx;\n\t    if (sp->ts_curi > byts[arridx])\n\t    {\n\t\t// Done all bytes at this node, do next state.  When still at\n\t\t// already changed bytes skip the other tricks.\n\t\tPROF_STORE(sp->ts_state)\n\t\tif (sp->ts_fidx >= sp->ts_fidxtry)\n\t\t    sp->ts_state = STATE_DEL;\n\t\telse\n\t\t    sp->ts_state = STATE_FINAL;\n\t    }\n\t    else\n\t    {\n\t\tarridx += sp->ts_curi++;\n\t\tc = byts[arridx];\n\n\t\t// Normal byte, go one level deeper.  If it's not equal to the\n\t\t// byte in the bad word adjust the score.  But don't even try\n\t\t// when the byte was already changed.  And don't try when we\n\t\t// just deleted this byte, accepting it is always cheaper than\n\t\t// delete + substitute.\n\t\tif (c == fword[sp->ts_fidx]\n\t\t\t|| (sp->ts_tcharlen > 0 && sp->ts_isdiff != DIFF_NONE))\n\t\t    newscore = 0;\n\t\telse\n\t\t    newscore = SCORE_SUBST;\n\t\tif ((newscore == 0\n\t\t\t    || (sp->ts_fidx >= sp->ts_fidxtry\n\t\t\t\t&& ((sp->ts_flags & TSF_DIDDEL) == 0\n\t\t\t\t    || c != fword[sp->ts_delidx])))\n\t\t\t&& TRY_DEEPER(su, stack, depth, newscore))\n\t\t{\n\t\t    go_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\t    if (newscore > 0)\n\t\t\tsprintf(changename[depth], \"%.*s-%s: subst %c to %c\",\n\t\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t\tfword[sp->ts_fidx], c);\n\t\t    else\n\t\t\tsprintf(changename[depth], \"%.*s-%s: accept %c\",\n\t\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t\tfword[sp->ts_fidx]);\n#endif\n\t\t    ++depth;\n\t\t    sp = &stack[depth];\n\t\t    if (fword[sp->ts_fidx] != NUL)\n\t\t\t++sp->ts_fidx;\n\t\t    tword[sp->ts_twordlen++] = c;\n\t\t    sp->ts_arridx = idxs[arridx];\n\t\t    if (newscore == SCORE_SUBST)\n\t\t\tsp->ts_isdiff = DIFF_YES;\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\t// Multi-byte characters are a bit complicated to\n\t\t\t// handle: They differ when any of the bytes differ\n\t\t\t// and then their length may also differ.\n\t\t\tif (sp->ts_tcharlen == 0)\n\t\t\t{\n\t\t\t    // First byte.\n\t\t\t    sp->ts_tcharidx = 0;\n\t\t\t    sp->ts_tcharlen = MB_BYTE2LEN(c);\n\t\t\t    sp->ts_fcharstart = sp->ts_fidx - 1;\n\t\t\t    sp->ts_isdiff = (newscore != 0)\n\t\t\t\t\t\t       ? DIFF_YES : DIFF_NONE;\n\t\t\t}\n\t\t\telse if (sp->ts_isdiff == DIFF_INSERT)\n\t\t\t    // When inserting trail bytes don't advance in the\n\t\t\t    // bad word.\n\t\t\t    --sp->ts_fidx;\n\t\t\tif (++sp->ts_tcharidx == sp->ts_tcharlen)\n\t\t\t{\n\t\t\t    // Last byte of character.\n\t\t\t    if (sp->ts_isdiff == DIFF_YES)\n\t\t\t    {\n\t\t\t\t// Correct ts_fidx for the byte length of the\n\t\t\t\t// character (we didn't check that before).\n\t\t\t\tsp->ts_fidx = sp->ts_fcharstart\n\t\t\t\t\t    + mb_ptr2len(\n\t\t\t\t\t\t    fword + sp->ts_fcharstart);\n\t\t\t\t// For changing a composing character adjust\n\t\t\t\t// the score from SCORE_SUBST to\n\t\t\t\t// SCORE_SUBCOMP.\n\t\t\t\tif (enc_utf8\n\t\t\t\t\t&& utf_iscomposing(\n\t\t\t\t\t    utf_ptr2char(tword\n\t\t\t\t\t\t+ sp->ts_twordlen\n\t\t\t\t\t\t\t   - sp->ts_tcharlen))\n\t\t\t\t\t&& utf_iscomposing(\n\t\t\t\t\t    utf_ptr2char(fword\n\t\t\t\t\t\t\t+ sp->ts_fcharstart)))\n\t\t\t\t    sp->ts_score -=\n\t\t\t\t\t\t  SCORE_SUBST - SCORE_SUBCOMP;\n\n\t\t\t\t// For a similar character adjust score from\n\t\t\t\t// SCORE_SUBST to SCORE_SIMILAR.\n\t\t\t\telse if (!soundfold\n\t\t\t\t\t&& slang->sl_has_map\n\t\t\t\t\t&& similar_chars(slang,\n\t\t\t\t\t    mb_ptr2char(tword\n\t\t\t\t\t\t+ sp->ts_twordlen\n\t\t\t\t\t\t\t   - sp->ts_tcharlen),\n\t\t\t\t\t    mb_ptr2char(fword\n\t\t\t\t\t\t\t+ sp->ts_fcharstart)))\n\t\t\t\t    sp->ts_score -=\n\t\t\t\t\t\t  SCORE_SUBST - SCORE_SIMILAR;\n\t\t\t    }\n\t\t\t    else if (sp->ts_isdiff == DIFF_INSERT\n\t\t\t\t\t && sp->ts_twordlen > sp->ts_tcharlen)\n\t\t\t    {\n\t\t\t\tp = tword + sp->ts_twordlen - sp->ts_tcharlen;\n\t\t\t\tc = mb_ptr2char(p);\n\t\t\t\tif (enc_utf8 && utf_iscomposing(c))\n\t\t\t\t{\n\t\t\t\t    // Inserting a composing char doesn't\n\t\t\t\t    // count that much.\n\t\t\t\t    sp->ts_score -= SCORE_INS - SCORE_INSCOMP;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    // If the previous character was the same,\n\t\t\t\t    // thus doubling a character, give a bonus\n\t\t\t\t    // to the score.  Also for the soundfold\n\t\t\t\t    // tree (might seem illogical but does\n\t\t\t\t    // give better scores).\n\t\t\t\t    MB_PTR_BACK(tword, p);\n\t\t\t\t    if (c == mb_ptr2char(p))\n\t\t\t\t\tsp->ts_score -= SCORE_INS\n\t\t\t\t\t\t\t       - SCORE_INSDUP;\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t    // Starting a new char, reset the length.\n\t\t\t    sp->ts_tcharlen = 0;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// If we found a similar char adjust the score.\n\t\t\t// We do this after calling go_deeper() because\n\t\t\t// it's slow.\n\t\t\tif (newscore != 0\n\t\t\t\t&& !soundfold\n\t\t\t\t&& slang->sl_has_map\n\t\t\t\t&& similar_chars(slang,\n\t\t\t\t\t\t   c, fword[sp->ts_fidx - 1]))\n\t\t\t    sp->ts_score -= SCORE_SUBST - SCORE_SIMILAR;\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\n\tcase STATE_DEL:\n\t    // When past the first byte of a multi-byte char don't try\n\t    // delete/insert/swap a character.\n\t    if (has_mbyte && sp->ts_tcharlen > 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\t    // Try skipping one character in the bad word (delete it).\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_INS_PREP;\n\t    sp->ts_curi = 1;\n\t    if (soundfold && sp->ts_fidx == 0 && fword[sp->ts_fidx] == '*')\n\t\t// Deleting a vowel at the start of a word counts less, see\n\t\t// soundalike_score().\n\t\tnewscore = 2 * SCORE_DEL / 3;\n\t    else\n\t\tnewscore = SCORE_DEL;\n\t    if (fword[sp->ts_fidx] != NUL\n\t\t\t\t    && TRY_DEEPER(su, stack, depth, newscore))\n\t    {\n\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: delete %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tfword[sp->ts_fidx]);\n#endif\n\t\t++depth;\n\n\t\t// Remember what character we deleted, so that we can avoid\n\t\t// inserting it again.\n\t\tstack[depth].ts_flags |= TSF_DIDDEL;\n\t\tstack[depth].ts_delidx = sp->ts_fidx;\n\n\t\t// Advance over the character in fword[].  Give a bonus to the\n\t\t// score if the same character is following \"nn\" -> \"n\".  It's\n\t\t// a bit illogical for soundfold tree but it does give better\n\t\t// results.\n\t\tif (has_mbyte)\n\t\t{\n\t\t    c = mb_ptr2char(fword + sp->ts_fidx);\n\t\t    stack[depth].ts_fidx += mb_ptr2len(fword + sp->ts_fidx);\n\t\t    if (enc_utf8 && utf_iscomposing(c))\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELCOMP;\n\t\t    else if (c == mb_ptr2char(fword + stack[depth].ts_fidx))\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++stack[depth].ts_fidx;\n\t\t    if (fword[sp->ts_fidx] == fword[sp->ts_fidx + 1])\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;\n\t\t}\n\t\tbreak;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase STATE_INS_PREP:\n\t    if (sp->ts_flags & TSF_DIDDEL)\n\t    {\n\t\t// If we just deleted a byte then inserting won't make sense,\n\t\t// a substitute is always cheaper.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP;\n\t\tbreak;\n\t    }\n\n\t    // skip over NUL bytes\n\t    n = sp->ts_arridx;\n\t    for (;;)\n\t    {\n\t\tif (sp->ts_curi > byts[n])\n\t\t{\n\t\t    // Only NUL bytes at this node, go to next state.\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_SWAP;\n\t\t    break;\n\t\t}\n\t\tif (byts[n + sp->ts_curi] != NUL)\n\t\t{\n\t\t    // Found a byte to insert.\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_INS;\n\t\t    break;\n\t\t}\n\t\t++sp->ts_curi;\n\t    }\n\t    break;\n\n\t    // FALLTHROUGH\n\n\tcase STATE_INS:\n\t    // Insert one byte.  Repeat this for each possible byte at this\n\t    // node.\n\t    n = sp->ts_arridx;\n\t    if (sp->ts_curi > byts[n])\n\t    {\n\t\t// Done all bytes at this node, go to next state.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP;\n\t\tbreak;\n\t    }\n\n\t    // Do one more byte at this node, but:\n\t    // - Skip NUL bytes.\n\t    // - Skip the byte if it's equal to the byte in the word,\n\t    //   accepting that byte is always better.\n\t    n += sp->ts_curi++;\n\t    c = byts[n];\n\t    if (soundfold && sp->ts_twordlen == 0 && c == '*')\n\t\t// Inserting a vowel at the start of a word counts less,\n\t\t// see soundalike_score().\n\t\tnewscore = 2 * SCORE_INS / 3;\n\t    else\n\t\tnewscore = SCORE_INS;\n\t    if (c != fword[sp->ts_fidx]\n\t\t\t\t    && TRY_DEEPER(su, stack, depth, newscore))\n\t    {\n\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: insert %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc);\n#endif\n\t\t++depth;\n\t\tsp = &stack[depth];\n\t\ttword[sp->ts_twordlen++] = c;\n\t\tsp->ts_arridx = idxs[n];\n\t\tif (has_mbyte)\n\t\t{\n\t\t    fl = MB_BYTE2LEN(c);\n\t\t    if (fl > 1)\n\t\t    {\n\t\t\t// There are following bytes for the same character.\n\t\t\t// We must find all bytes before trying\n\t\t\t// delete/insert/swap/etc.\n\t\t\tsp->ts_tcharlen = fl;\n\t\t\tsp->ts_tcharidx = 1;\n\t\t\tsp->ts_isdiff = DIFF_INSERT;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    fl = 1;\n\t\tif (fl == 1)\n\t\t{\n\t\t    // If the previous character was the same, thus doubling a\n\t\t    // character, give a bonus to the score.  Also for\n\t\t    // soundfold words (illogical but does give a better\n\t\t    // score).\n\t\t    if (sp->ts_twordlen >= 2\n\t\t\t\t\t   && tword[sp->ts_twordlen - 2] == c)\n\t\t\tsp->ts_score -= SCORE_INS - SCORE_INSDUP;\n\t\t}\n\t    }\n\t    break;\n\n\tcase STATE_SWAP:\n\t    // Swap two bytes in the bad word: \"12\" -> \"21\".\n\t    // We change \"fword\" here, it's changed back afterwards at\n\t    // STATE_UNSWAP.\n\t    p = fword + sp->ts_fidx;\n\t    c = *p;\n\t    if (c == NUL)\n\t    {\n\t\t// End of word, can't swap or replace.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\n\t    // Don't swap if the first character is not a word character.\n\t    // SWAP3 etc. also don't make sense then.\n\t    if (!soundfold && !spell_iswordp(p, curwin))\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\n\t    if (has_mbyte)\n\t    {\n\t\tn = MB_CPTR2LEN(p);\n\t\tc = mb_ptr2char(p);\n\t\tif (p[n] == NUL)\n\t\t    c2 = NUL;\n\t\telse if (!soundfold && !spell_iswordp(p + n, curwin))\n\t\t    c2 = c; // don't swap non-word char\n\t\telse\n\t\t    c2 = mb_ptr2char(p + n);\n\t    }\n\t    else\n\t    {\n\t\tif (p[1] == NUL)\n\t\t    c2 = NUL;\n\t\telse if (!soundfold && !spell_iswordp(p + 1, curwin))\n\t\t    c2 = c; // don't swap non-word char\n\t\telse\n\t\t    c2 = p[1];\n\t    }\n\n\t    // When the second character is NUL we can't swap.\n\t    if (c2 == NUL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\n\t    // When characters are identical, swap won't do anything.\n\t    // Also get here if the second char is not a word character.\n\t    if (c == c2)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP3;\n\t\tbreak;\n\t    }\n\t    if (c2 != NUL && TRY_DEEPER(su, stack, depth, SCORE_SWAP))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: swap %c and %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc, c2);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNSWAP;\n\t\t++depth;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    fl = mb_char2len(c2);\n\t\t    mch_memmove(p, p + n, fl);\n\t\t    mb_char2bytes(c, p + fl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[0] = c2;\n\t\t    p[1] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 2;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// If this swap doesn't work then SWAP3 won't either.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNSWAP:\n\t    // Undo the STATE_SWAP swap: \"21\" -> \"12\".\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tc = mb_ptr2char(p + n);\n\t\tmch_memmove(p + mb_ptr2len(p + n), p, n);\n\t\tmb_char2bytes(c, p);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[1];\n\t\tp[1] = c;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase STATE_SWAP3:\n\t    // Swap two bytes, skipping one: \"123\" -> \"321\".  We change\n\t    // \"fword\" here, it's changed back afterwards at STATE_UNSWAP3.\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = MB_CPTR2LEN(p);\n\t\tc = mb_ptr2char(p);\n\t\tfl = MB_CPTR2LEN(p + n);\n\t\tc2 = mb_ptr2char(p + n);\n\t\tif (!soundfold && !spell_iswordp(p + n + fl, curwin))\n\t\t    c3 = c;\t// don't swap non-word char\n\t\telse\n\t\t    c3 = mb_ptr2char(p + n + fl);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\tc2 = p[1];\n\t\tif (!soundfold && !spell_iswordp(p + 2, curwin))\n\t\t    c3 = c;\t// don't swap non-word char\n\t\telse\n\t\t    c3 = p[2];\n\t    }\n\n\t    // When characters are identical: \"121\" then SWAP3 result is\n\t    // identical, ROT3L result is same as SWAP: \"211\", ROT3L result is\n\t    // same as SWAP on next char: \"112\".  Thus skip all swapping.\n\t    // Also skip when c3 is NUL.\n\t    // Also get here when the third character is not a word character.\n\t    // Second character may any char: \"a.b\" -> \"b.a\"\n\t    if (c == c3 || c3 == NUL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: swap3 %c and %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc, c3);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNSWAP3;\n\t\t++depth;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    tl = mb_char2len(c3);\n\t\t    mch_memmove(p, p + n + fl, tl);\n\t\t    mb_char2bytes(c2, p + tl);\n\t\t    mb_char2bytes(c, p + fl + tl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl + tl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[0] = p[2];\n\t\t    p[2] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNSWAP3:\n\t    // Undo STATE_SWAP3: \"321\" -> \"123\"\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tc2 = mb_ptr2char(p + n);\n\t\tfl = mb_ptr2len(p + n);\n\t\tc = mb_ptr2char(p + n + fl);\n\t\ttl = mb_ptr2len(p + n + fl);\n\t\tmch_memmove(p + fl + tl, p, n);\n\t\tmb_char2bytes(c, p);\n\t\tmb_char2bytes(c2, p + tl);\n\t\tp = p + tl;\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[2];\n\t\tp[2] = c;\n\t\t++p;\n\t    }\n\n\t    if (!soundfold && !spell_iswordp(p, curwin))\n\t    {\n\t\t// Middle char is not a word char, skip the rotate.  First and\n\t\t// third char were already checked at swap and swap3.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\n\t    // Rotate three characters left: \"123\" -> \"231\".  We change\n\t    // \"fword\" here, it's changed back afterwards at STATE_UNROT3L.\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tp = fword + sp->ts_fidx;\n\t\tsprintf(changename[depth], \"%.*s-%s: rotate left %c%c%c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tp[0], p[1], p[2]);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNROT3L;\n\t\t++depth;\n\t\tp = fword + sp->ts_fidx;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    n = MB_CPTR2LEN(p);\n\t\t    c = mb_ptr2char(p);\n\t\t    fl = MB_CPTR2LEN(p + n);\n\t\t    fl += MB_CPTR2LEN(p + n + fl);\n\t\t    mch_memmove(p, p + n, fl);\n\t\t    mb_char2bytes(c, p + fl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = *p;\n\t\t    *p = p[1];\n\t\t    p[1] = p[2];\n\t\t    p[2] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNROT3L:\n\t    // Undo ROT3L: \"231\" -> \"123\"\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tn += mb_ptr2len(p + n);\n\t\tc = mb_ptr2char(p + n);\n\t\ttl = mb_ptr2len(p + n);\n\t\tmch_memmove(p + tl, p, n);\n\t\tmb_char2bytes(c, p);\n\t    }\n\t    else\n\t    {\n\t\tc = p[2];\n\t\tp[2] = p[1];\n\t\tp[1] = *p;\n\t\t*p = c;\n\t    }\n\n\t    // Rotate three bytes right: \"123\" -> \"312\".  We change \"fword\"\n\t    // here, it's changed back afterwards at STATE_UNROT3R.\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tp = fword + sp->ts_fidx;\n\t\tsprintf(changename[depth], \"%.*s-%s: rotate right %c%c%c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tp[0], p[1], p[2]);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNROT3R;\n\t\t++depth;\n\t\tp = fword + sp->ts_fidx;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    n = MB_CPTR2LEN(p);\n\t\t    n += MB_CPTR2LEN(p + n);\n\t\t    c = mb_ptr2char(p + n);\n\t\t    tl = MB_CPTR2LEN(p + n);\n\t\t    mch_memmove(p + tl, p, n);\n\t\t    mb_char2bytes(c, p);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + tl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = p[2];\n\t\t    p[2] = p[1];\n\t\t    p[1] = *p;\n\t\t    *p = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNROT3R:\n\t    // Undo ROT3R: \"312\" -> \"123\"\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tc = mb_ptr2char(p);\n\t\ttl = mb_ptr2len(p);\n\t\tn = mb_ptr2len(p + tl);\n\t\tn += mb_ptr2len(p + tl + n);\n\t\tmch_memmove(p, p + tl, n);\n\t\tmb_char2bytes(c, p + n);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[1];\n\t\tp[1] = p[2];\n\t\tp[2] = c;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase STATE_REP_INI:\n\t    // Check if matching with REP items from the .aff file would work.\n\t    // Quickly skip if:\n\t    // - there are no REP items and we are not in the soundfold trie\n\t    // - the score is going to be too high anyway\n\t    // - already applied a REP item or swapped here\n\t    if ((lp->lp_replang == NULL && !soundfold)\n\t\t    || sp->ts_score + SCORE_REP >= su->su_maxscore\n\t\t    || sp->ts_fidx < sp->ts_fidxtry)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\n\t    // Use the first byte to quickly find the first entry that may\n\t    // match.  If the index is -1 there is none.\n\t    if (soundfold)\n\t\tsp->ts_curi = slang->sl_repsal_first[fword[sp->ts_fidx]];\n\t    else\n\t\tsp->ts_curi = lp->lp_replang->sl_rep_first[fword[sp->ts_fidx]];\n\n\t    if (sp->ts_curi < 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_REP;\n\t    // FALLTHROUGH\n\n\tcase STATE_REP:\n\t    // Try matching with REP items from the .aff file.  For each match\n\t    // replace the characters and check if the resulting word is\n\t    // valid.\n\t    p = fword + sp->ts_fidx;\n\n\t    if (soundfold)\n\t\tgap = &slang->sl_repsal;\n\t    else\n\t\tgap = &lp->lp_replang->sl_rep;\n\t    while (sp->ts_curi < gap->ga_len)\n\t    {\n\t\tftp = (fromto_T *)gap->ga_data + sp->ts_curi++;\n\t\tif (*ftp->ft_from != *p)\n\t\t{\n\t\t    // past possible matching entries\n\t\t    sp->ts_curi = gap->ga_len;\n\t\t    break;\n\t\t}\n\t\tif (STRNCMP(ftp->ft_from, p, STRLEN(ftp->ft_from)) == 0\n\t\t\t&& TRY_DEEPER(su, stack, depth, SCORE_REP))\n\t\t{\n\t\t    go_deeper(stack, depth, SCORE_REP);\n#ifdef DEBUG_TRIEWALK\n\t\t    sprintf(changename[depth], \"%.*s-%s: replace %s with %s\",\n\t\t\t    sp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t    ftp->ft_from, ftp->ft_to);\n#endif\n\t\t    // Need to undo this afterwards.\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_REP_UNDO;\n\n\t\t    // Change the \"from\" to the \"to\" string.\n\t\t    ++depth;\n\t\t    fl = (int)STRLEN(ftp->ft_from);\n\t\t    tl = (int)STRLEN(ftp->ft_to);\n\t\t    if (fl != tl)\n\t\t    {\n\t\t\tSTRMOVE(p + tl, p + fl);\n\t\t\trepextra += tl - fl;\n\t\t    }\n\t\t    mch_memmove(p, ftp->ft_to, tl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + tl;\n\t\t    stack[depth].ts_tcharlen = 0;\n\t\t    break;\n\t\t}\n\t    }\n\n\t    if (sp->ts_curi >= gap->ga_len && sp->ts_state == STATE_REP)\n\t    {\n\t\t// No (more) matches.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t    }\n\n\t    break;\n\n\tcase STATE_REP_UNDO:\n\t    // Undo a REP replacement and continue with the next one.\n\t    if (soundfold)\n\t\tgap = &slang->sl_repsal;\n\t    else\n\t\tgap = &lp->lp_replang->sl_rep;\n\t    ftp = (fromto_T *)gap->ga_data + sp->ts_curi - 1;\n\t    fl = (int)STRLEN(ftp->ft_from);\n\t    tl = (int)STRLEN(ftp->ft_to);\n\t    p = fword + sp->ts_fidx;\n\t    if (fl != tl)\n\t    {\n\t\tSTRMOVE(p + fl, p + tl);\n\t\trepextra -= tl - fl;\n\t    }\n\t    mch_memmove(p, ftp->ft_from, fl);\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_REP;\n\t    break;\n\n\tdefault:\n\t    // Did all possible states at this level, go up one level.\n\t    --depth;\n\n\t    if (depth >= 0 && stack[depth].ts_prefixdepth == PFD_PREFIXTREE)\n\t    {\n\t\t// Continue in or go back to the prefix tree.\n\t\tbyts = pbyts;\n\t\tidxs = pidxs;\n\t    }\n\n\t    // Don't check for CTRL-C too often, it takes time.\n\t    if (--breakcheckcount == 0)\n\t    {\n\t\tui_breakcheck();\n\t\tbreakcheckcount = 1000;\n#ifdef FEAT_RELTIME\n\t\tif (spell_suggest_timeout > 0\n\t\t\t\t\t  && profile_passed_limit(&time_limit))\n\t\t    got_int = TRUE;\n#endif\n\t    }\n\t}\n    }\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "spellsuggest.c",
        "method_name": "fixed_function",
        "raw_code": "suggest_trie_walk(\n    suginfo_T\t*su,\n    langp_T\t*lp,\n    char_u\t*fword,\n    int\t\tsoundfold)\n{\n    char_u\ttword[MAXWLEN];\t    // good word collected so far\n    trystate_T\tstack[MAXWLEN];\n    char_u\tpreword[MAXWLEN * 3]; // word found with proper case;\n\t\t\t\t      // concatenation of prefix compound\n\t\t\t\t      // words and split word.  NUL terminated\n\t\t\t\t      // when going deeper but not when coming\n\t\t\t\t      // back.\n    char_u\tcompflags[MAXWLEN];\t// compound flags, one for each word\n    trystate_T\t*sp;\n    int\t\tnewscore;\n    int\t\tscore;\n    char_u\t*byts, *fbyts, *pbyts;\n    idx_T\t*idxs, *fidxs, *pidxs;\n    int\t\tdepth;\n    int\t\tc, c2, c3;\n    int\t\tn = 0;\n    int\t\tflags;\n    garray_T\t*gap;\n    idx_T\tarridx;\n    int\t\tlen;\n    char_u\t*p;\n    fromto_T\t*ftp;\n    int\t\tfl = 0, tl;\n    int\t\trepextra = 0;\t    // extra bytes in fword[] from REP item\n    slang_T\t*slang = lp->lp_slang;\n    int\t\tfword_ends;\n    int\t\tgoodword_ends;\n#ifdef DEBUG_TRIEWALK\n    // Stores the name of the change made at each level.\n    char_u\tchangename[MAXWLEN][80];\n#endif\n    int\t\tbreakcheckcount = 1000;\n#ifdef FEAT_RELTIME\n    proftime_T\ttime_limit;\n#endif\n    int\t\tcompound_ok;\n\n    // Go through the whole case-fold tree, try changes at each node.\n    // \"tword[]\" contains the word collected from nodes in the tree.\n    // \"fword[]\" the word we are trying to match with (initially the bad\n    // word).\n    depth = 0;\n    sp = &stack[0];\n    CLEAR_POINTER(sp);\n    sp->ts_curi = 1;\n\n    if (soundfold)\n    {\n\t// Going through the soundfold tree.\n\tbyts = fbyts = slang->sl_sbyts;\n\tidxs = fidxs = slang->sl_sidxs;\n\tpbyts = NULL;\n\tpidxs = NULL;\n\tsp->ts_prefixdepth = PFD_NOPREFIX;\n\tsp->ts_state = STATE_START;\n    }\n    else\n    {\n\t// When there are postponed prefixes we need to use these first.  At\n\t// the end of the prefix we continue in the case-fold tree.\n\tfbyts = slang->sl_fbyts;\n\tfidxs = slang->sl_fidxs;\n\tpbyts = slang->sl_pbyts;\n\tpidxs = slang->sl_pidxs;\n\tif (pbyts != NULL)\n\t{\n\t    byts = pbyts;\n\t    idxs = pidxs;\n\t    sp->ts_prefixdepth = PFD_PREFIXTREE;\n\t    sp->ts_state = STATE_NOPREFIX;\t// try without prefix first\n\t}\n\telse\n\t{\n\t    byts = fbyts;\n\t    idxs = fidxs;\n\t    sp->ts_prefixdepth = PFD_NOPREFIX;\n\t    sp->ts_state = STATE_START;\n\t}\n    }\n#ifdef FEAT_RELTIME\n    // The loop may take an indefinite amount of time. Break out after some\n    // time.\n    if (spell_suggest_timeout > 0)\n\tprofile_setlimit(spell_suggest_timeout, &time_limit);\n#endif\n\n    // Loop to find all suggestions.  At each round we either:\n    // - For the current state try one operation, advance \"ts_curi\",\n    //   increase \"depth\".\n    // - When a state is done go to the next, set \"ts_state\".\n    // - When all states are tried decrease \"depth\".\n    while (depth >= 0 && !got_int)\n    {\n\tsp = &stack[depth];\n\tswitch (sp->ts_state)\n\t{\n\tcase STATE_START:\n\tcase STATE_NOPREFIX:\n\t    // Start of node: Deal with NUL bytes, which means\n\t    // tword[] may end here.\n\t    arridx = sp->ts_arridx;\t    // current node in the tree\n\t    len = byts[arridx];\t\t    // bytes in this node\n\t    arridx += sp->ts_curi;\t    // index of current byte\n\n\t    if (sp->ts_prefixdepth == PFD_PREFIXTREE)\n\t    {\n\t\t// Skip over the NUL bytes, we use them later.\n\t\tfor (n = 0; n < len && byts[arridx + n] == 0; ++n)\n\t\t    ;\n\t\tsp->ts_curi += n;\n\n\t\t// Always past NUL bytes now.\n\t\tn = (int)sp->ts_state;\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_ENDNUL;\n\t\tsp->ts_save_badflags = su->su_badflags;\n\n\t\t// At end of a prefix or at start of prefixtree: check for\n\t\t// following word.\n\t\tif (depth < MAXWLEN - 1\n\t\t\t    && (byts[arridx] == 0 || n == (int)STATE_NOPREFIX))\n\t\t{\n\t\t    // Set su->su_badflags to the caps type at this position.\n\t\t    // Use the caps type until here for the prefix itself.\n\t\t    if (has_mbyte)\n\t\t\tn = nofold_len(fword, sp->ts_fidx, su->su_badptr);\n\t\t    else\n\t\t\tn = sp->ts_fidx;\n\t\t    flags = badword_captype(su->su_badptr, su->su_badptr + n);\n\t\t    su->su_badflags = badword_captype(su->su_badptr + n,\n\t\t\t\t\t       su->su_badptr + su->su_badlen);\n#ifdef DEBUG_TRIEWALK\n\t\t    sprintf(changename[depth], \"prefix\");\n#endif\n\t\t    go_deeper(stack, depth, 0);\n\t\t    ++depth;\n\t\t    sp = &stack[depth];\n\t\t    sp->ts_prefixdepth = depth - 1;\n\t\t    byts = fbyts;\n\t\t    idxs = fidxs;\n\t\t    sp->ts_arridx = 0;\n\n\t\t    // Move the prefix to preword[] with the right case\n\t\t    // and make find_keepcap_word() works.\n\t\t    tword[sp->ts_twordlen] = NUL;\n\t\t    make_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t  preword + sp->ts_prewordlen, flags);\n\t\t    sp->ts_prewordlen = (char_u)STRLEN(preword);\n\t\t    sp->ts_splitoff = sp->ts_twordlen;\n\t\t}\n\t\tbreak;\n\t    }\n\n\t    if (sp->ts_curi > len || byts[arridx] != 0)\n\t    {\n\t\t// Past bytes in node and/or past NUL bytes.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_ENDNUL;\n\t\tsp->ts_save_badflags = su->su_badflags;\n\t\tbreak;\n\t    }\n\n\t    // End of word in tree.\n\t    ++sp->ts_curi;\t\t// eat one NUL byte\n\n\t    flags = (int)idxs[arridx];\n\n\t    // Skip words with the NOSUGGEST flag.\n\t    if (flags & WF_NOSUGGEST)\n\t\tbreak;\n\n\t    fword_ends = (fword[sp->ts_fidx] == NUL\n\t\t\t   || (soundfold\n\t\t\t       ? VIM_ISWHITE(fword[sp->ts_fidx])\n\t\t\t       : !spell_iswordp(fword + sp->ts_fidx, curwin)));\n\t    tword[sp->ts_twordlen] = NUL;\n\n\t    if (sp->ts_prefixdepth <= PFD_NOTSPECIAL\n\t\t\t\t\t&& (sp->ts_flags & TSF_PREFIXOK) == 0\n\t\t\t\t\t&& pbyts != NULL)\n\t    {\n\t\t// There was a prefix before the word.  Check that the prefix\n\t\t// can be used with this word.\n\t\t// Count the length of the NULs in the prefix.  If there are\n\t\t// none this must be the first try without a prefix.\n\t\tn = stack[sp->ts_prefixdepth].ts_arridx;\n\t\tlen = pbyts[n++];\n\t\tfor (c = 0; c < len && pbyts[n + c] == 0; ++c)\n\t\t    ;\n\t\tif (c > 0)\n\t\t{\n\t\t    c = valid_word_prefix(c, n, flags,\n\t\t\t\t       tword + sp->ts_splitoff, slang, FALSE);\n\t\t    if (c == 0)\n\t\t\tbreak;\n\n\t\t    // Use the WF_RARE flag for a rare prefix.\n\t\t    if (c & WF_RAREPFX)\n\t\t\tflags |= WF_RARE;\n\n\t\t    // Tricky: when checking for both prefix and compounding\n\t\t    // we run into the prefix flag first.\n\t\t    // Remember that it's OK, so that we accept the prefix\n\t\t    // when arriving at a compound flag.\n\t\t    sp->ts_flags |= TSF_PREFIXOK;\n\t\t}\n\t    }\n\n\t    // Check NEEDCOMPOUND: can't use word without compounding.  Do try\n\t    // appending another compound word below.\n\t    if (sp->ts_complen == sp->ts_compsplit && fword_ends\n\t\t\t\t\t\t     && (flags & WF_NEEDCOMP))\n\t\tgoodword_ends = FALSE;\n\t    else\n\t\tgoodword_ends = TRUE;\n\n\t    p = NULL;\n\t    compound_ok = TRUE;\n\t    if (sp->ts_complen > sp->ts_compsplit)\n\t    {\n\t\tif (slang->sl_nobreak)\n\t\t{\n\t\t    // There was a word before this word.  When there was no\n\t\t    // change in this word (it was correct) add the first word\n\t\t    // as a suggestion.  If this word was corrected too, we\n\t\t    // need to check if a correct word follows.\n\t\t    if (sp->ts_fidx - sp->ts_splitfidx\n\t\t\t\t\t  == sp->ts_twordlen - sp->ts_splitoff\n\t\t\t    && STRNCMP(fword + sp->ts_splitfidx,\n\t\t\t\t\ttword + sp->ts_splitoff,\n\t\t\t\t\t sp->ts_fidx - sp->ts_splitfidx) == 0)\n\t\t    {\n\t\t\tpreword[sp->ts_prewordlen] = NUL;\n\t\t\tnewscore = score_wordcount_adj(slang, sp->ts_score,\n\t\t\t\t\t\t preword + sp->ts_prewordlen,\n\t\t\t\t\t\t sp->ts_prewordlen > 0);\n\t\t\t// Add the suggestion if the score isn't too bad.\n\t\t\tif (newscore <= su->su_maxscore)\n\t\t\t    add_suggestion(su, &su->su_ga, preword,\n\t\t\t\t    sp->ts_splitfidx - repextra,\n\t\t\t\t    newscore, 0, FALSE,\n\t\t\t\t    lp->lp_sallang, FALSE);\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    // There was a compound word before this word.  If this\n\t\t    // word does not support compounding then give up\n\t\t    // (splitting is tried for the word without compound\n\t\t    // flag).\n\t\t    if (((unsigned)flags >> 24) == 0\n\t\t\t    || sp->ts_twordlen - sp->ts_splitoff\n\t\t\t\t\t\t       < slang->sl_compminlen)\n\t\t\tbreak;\n\t\t    // For multi-byte chars check character length against\n\t\t    // COMPOUNDMIN.\n\t\t    if (has_mbyte\n\t\t\t    && slang->sl_compminlen > 0\n\t\t\t    && mb_charlen(tword + sp->ts_splitoff)\n\t\t\t\t\t\t       < slang->sl_compminlen)\n\t\t\tbreak;\n\n\t\t    compflags[sp->ts_complen] = ((unsigned)flags >> 24);\n\t\t    compflags[sp->ts_complen + 1] = NUL;\n\t\t    vim_strncpy(preword + sp->ts_prewordlen,\n\t\t\t    tword + sp->ts_splitoff,\n\t\t\t    sp->ts_twordlen - sp->ts_splitoff);\n\n\t\t    // Verify CHECKCOMPOUNDPATTERN  rules.\n\t\t    if (match_checkcompoundpattern(preword,  sp->ts_prewordlen,\n\t\t\t\t\t\t\t  &slang->sl_comppat))\n\t\t\tcompound_ok = FALSE;\n\n\t\t    if (compound_ok)\n\t\t    {\n\t\t\tp = preword;\n\t\t\twhile (*skiptowhite(p) != NUL)\n\t\t\t    p = skipwhite(skiptowhite(p));\n\t\t\tif (fword_ends && !can_compound(slang, p,\n\t\t\t\t\t\tcompflags + sp->ts_compsplit))\n\t\t\t    // Compound is not allowed.  But it may still be\n\t\t\t    // possible if we add another (short) word.\n\t\t\t    compound_ok = FALSE;\n\t\t    }\n\n\t\t    // Get pointer to last char of previous word.\n\t\t    p = preword + sp->ts_prewordlen;\n\t\t    MB_PTR_BACK(preword, p);\n\t\t}\n\t    }\n\n\t    // Form the word with proper case in preword.\n\t    // If there is a word from a previous split, append.\n\t    // For the soundfold tree don't change the case, simply append.\n\t    if (soundfold)\n\t\tSTRCPY(preword + sp->ts_prewordlen, tword + sp->ts_splitoff);\n\t    else if (flags & WF_KEEPCAP)\n\t\t// Must find the word in the keep-case tree.\n\t\tfind_keepcap_word(slang, tword + sp->ts_splitoff,\n\t\t\t\t\t\t preword + sp->ts_prewordlen);\n\t    else\n\t    {\n\t\t// Include badflags: If the badword is onecap or allcap\n\t\t// use that for the goodword too.  But if the badword is\n\t\t// allcap and it's only one char long use onecap.\n\t\tc = su->su_badflags;\n\t\tif ((c & WF_ALLCAP)\n\t\t\t&& su->su_badlen == (*mb_ptr2len)(su->su_badptr))\n\t\t    c = WF_ONECAP;\n\t\tc |= flags;\n\n\t\t// When appending a compound word after a word character don't\n\t\t// use Onecap.\n\t\tif (p != NULL && spell_iswordp_nmw(p, curwin))\n\t\t    c &= ~WF_ONECAP;\n\t\tmake_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t      preword + sp->ts_prewordlen, c);\n\t    }\n\n\t    if (!soundfold)\n\t    {\n\t\t// Don't use a banned word.  It may appear again as a good\n\t\t// word, thus remember it.\n\t\tif (flags & WF_BANNED)\n\t\t{\n\t\t    add_banned(su, preword + sp->ts_prewordlen);\n\t\t    break;\n\t\t}\n\t\tif ((sp->ts_complen == sp->ts_compsplit\n\t\t\t    && WAS_BANNED(su, preword + sp->ts_prewordlen))\n\t\t\t\t\t\t   || WAS_BANNED(su, preword))\n\t\t{\n\t\t    if (slang->sl_compprog == NULL)\n\t\t\tbreak;\n\t\t    // the word so far was banned but we may try compounding\n\t\t    goodword_ends = FALSE;\n\t\t}\n\t    }\n\n\t    newscore = 0;\n\t    if (!soundfold)\t// soundfold words don't have flags\n\t    {\n\t\tif ((flags & WF_REGION)\n\t\t\t    && (((unsigned)flags >> 16) & lp->lp_region) == 0)\n\t\t    newscore += SCORE_REGION;\n\t\tif (flags & WF_RARE)\n\t\t    newscore += SCORE_RARE;\n\n\t\tif (!spell_valid_case(su->su_badflags,\n\t\t\t\t  captype(preword + sp->ts_prewordlen, NULL)))\n\t\t    newscore += SCORE_ICASE;\n\t    }\n\n\t    // TODO: how about splitting in the soundfold tree?\n\t    if (fword_ends\n\t\t    && goodword_ends\n\t\t    && sp->ts_fidx >= sp->ts_fidxtry\n\t\t    && compound_ok)\n\t    {\n\t\t// The badword also ends: add suggestions.\n#ifdef DEBUG_TRIEWALK\n\t\tif (soundfold && STRCMP(preword, \"smwrd\") == 0)\n\t\t{\n\t\t    int\t    j;\n\n\t\t    // print the stack of changes that brought us here\n\t\t    smsg(\"------ %s -------\", fword);\n\t\t    for (j = 0; j < depth; ++j)\n\t\t\tsmsg(\"%s\", changename[j]);\n\t\t}\n#endif\n\t\tif (soundfold)\n\t\t{\n\t\t    // For soundfolded words we need to find the original\n\t\t    // words, the edit distance and then add them.\n\t\t    add_sound_suggest(su, preword, sp->ts_score, lp);\n\t\t}\n\t\telse if (sp->ts_fidx > 0)\n\t\t{\n\t\t    // Give a penalty when changing non-word char to word\n\t\t    // char, e.g., \"thes,\" -> \"these\".\n\t\t    p = fword + sp->ts_fidx;\n\t\t    MB_PTR_BACK(fword, p);\n\t\t    if (!spell_iswordp(p, curwin) && *preword != NUL)\n\t\t    {\n\t\t\tp = preword + STRLEN(preword);\n\t\t\tMB_PTR_BACK(preword, p);\n\t\t\tif (spell_iswordp(p, curwin))\n\t\t\t    newscore += SCORE_NONWORD;\n\t\t    }\n\n\t\t    // Give a bonus to words seen before.\n\t\t    score = score_wordcount_adj(slang,\n\t\t\t\t\t\tsp->ts_score + newscore,\n\t\t\t\t\t\tpreword + sp->ts_prewordlen,\n\t\t\t\t\t\tsp->ts_prewordlen > 0);\n\n\t\t    // Add the suggestion if the score isn't too bad.\n\t\t    if (score <= su->su_maxscore)\n\t\t    {\n\t\t\tadd_suggestion(su, &su->su_ga, preword,\n\t\t\t\t    sp->ts_fidx - repextra,\n\t\t\t\t    score, 0, FALSE, lp->lp_sallang, FALSE);\n\n\t\t\tif (su->su_badflags & WF_MIXCAP)\n\t\t\t{\n\t\t\t    // We really don't know if the word should be\n\t\t\t    // upper or lower case, add both.\n\t\t\t    c = captype(preword, NULL);\n\t\t\t    if (c == 0 || c == WF_ALLCAP)\n\t\t\t    {\n\t\t\t\tmake_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t      preword + sp->ts_prewordlen,\n\t\t\t\t\t\t      c == 0 ? WF_ALLCAP : 0);\n\n\t\t\t\tadd_suggestion(su, &su->su_ga, preword,\n\t\t\t\t\tsp->ts_fidx - repextra,\n\t\t\t\t\tscore + SCORE_ICASE, 0, FALSE,\n\t\t\t\t\tlp->lp_sallang, FALSE);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t    // Try word split and/or compounding.\n\t    if ((sp->ts_fidx >= sp->ts_fidxtry || fword_ends)\n\t\t    // Don't split halfway a character.\n\t\t    && (!has_mbyte || sp->ts_tcharlen == 0))\n\t    {\n\t\tint\ttry_compound;\n\t\tint\ttry_split;\n\n\t\t// If past the end of the bad word don't try a split.\n\t\t// Otherwise try changing the next word.  E.g., find\n\t\t// suggestions for \"the the\" where the second \"the\" is\n\t\t// different.  It's done like a split.\n\t\t// TODO: word split for soundfold words\n\t\ttry_split = (sp->ts_fidx - repextra < su->su_badlen)\n\t\t\t\t\t\t\t\t&& !soundfold;\n\n\t\t// Get here in several situations:\n\t\t// 1. The word in the tree ends:\n\t\t//    If the word allows compounding try that.  Otherwise try\n\t\t//    a split by inserting a space.  For both check that a\n\t\t//    valid words starts at fword[sp->ts_fidx].\n\t\t//    For NOBREAK do like compounding to be able to check if\n\t\t//    the next word is valid.\n\t\t// 2. The badword does end, but it was due to a change (e.g.,\n\t\t//    a swap).  No need to split, but do check that the\n\t\t//    following word is valid.\n\t\t// 3. The badword and the word in the tree end.  It may still\n\t\t//    be possible to compound another (short) word.\n\t\ttry_compound = FALSE;\n\t\tif (!soundfold\n\t\t\t&& !slang->sl_nocompoundsugs\n\t\t\t&& slang->sl_compprog != NULL\n\t\t\t&& ((unsigned)flags >> 24) != 0\n\t\t\t&& sp->ts_twordlen - sp->ts_splitoff\n\t\t\t\t\t\t       >= slang->sl_compminlen\n\t\t\t&& (!has_mbyte\n\t\t\t    || slang->sl_compminlen == 0\n\t\t\t    || mb_charlen(tword + sp->ts_splitoff)\n\t\t\t\t\t\t      >= slang->sl_compminlen)\n\t\t\t&& (slang->sl_compsylmax < MAXWLEN\n\t\t\t    || sp->ts_complen + 1 - sp->ts_compsplit\n\t\t\t\t\t\t\t  < slang->sl_compmax)\n\t\t\t&& (can_be_compound(sp, slang,\n\t\t\t\t\t compflags, ((unsigned)flags >> 24))))\n\n\t\t{\n\t\t    try_compound = TRUE;\n\t\t    compflags[sp->ts_complen] = ((unsigned)flags >> 24);\n\t\t    compflags[sp->ts_complen + 1] = NUL;\n\t\t}\n\n\t\t// For NOBREAK we never try splitting, it won't make any word\n\t\t// valid.\n\t\tif (slang->sl_nobreak && !slang->sl_nocompoundsugs)\n\t\t    try_compound = TRUE;\n\n\t\t// If we could add a compound word, and it's also possible to\n\t\t// split at this point, do the split first and set\n\t\t// TSF_DIDSPLIT to avoid doing it again.\n\t\telse if (!fword_ends\n\t\t\t&& try_compound\n\t\t\t&& (sp->ts_flags & TSF_DIDSPLIT) == 0)\n\t\t{\n\t\t    try_compound = FALSE;\n\t\t    sp->ts_flags |= TSF_DIDSPLIT;\n\t\t    --sp->ts_curi;\t    // do the same NUL again\n\t\t    compflags[sp->ts_complen] = NUL;\n\t\t}\n\t\telse\n\t\t    sp->ts_flags &= ~TSF_DIDSPLIT;\n\n\t\tif (try_split || try_compound)\n\t\t{\n\t\t    if (!try_compound && (!fword_ends || !goodword_ends))\n\t\t    {\n\t\t\t// If we're going to split need to check that the\n\t\t\t// words so far are valid for compounding.  If there\n\t\t\t// is only one word it must not have the NEEDCOMPOUND\n\t\t\t// flag.\n\t\t\tif (sp->ts_complen == sp->ts_compsplit\n\t\t\t\t\t\t     && (flags & WF_NEEDCOMP))\n\t\t\t    break;\n\t\t\tp = preword;\n\t\t\twhile (*skiptowhite(p) != NUL)\n\t\t\t    p = skipwhite(skiptowhite(p));\n\t\t\tif (sp->ts_complen > sp->ts_compsplit\n\t\t\t\t&& !can_compound(slang, p,\n\t\t\t\t\t\tcompflags + sp->ts_compsplit))\n\t\t\t    break;\n\n\t\t\tif (slang->sl_nosplitsugs)\n\t\t\t    newscore += SCORE_SPLIT_NO;\n\t\t\telse\n\t\t\t    newscore += SCORE_SPLIT;\n\n\t\t\t// Give a bonus to words seen before.\n\t\t\tnewscore = score_wordcount_adj(slang, newscore,\n\t\t\t\t\t   preword + sp->ts_prewordlen, TRUE);\n\t\t    }\n\n\t\t    if (TRY_DEEPER(su, stack, depth, newscore))\n\t\t    {\n\t\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\t\tif (!try_compound && !fword_ends)\n\t\t\t    sprintf(changename[depth], \"%.*s-%s: split\",\n\t\t\t\t sp->ts_twordlen, tword, fword + sp->ts_fidx);\n\t\t\telse\n\t\t\t    sprintf(changename[depth], \"%.*s-%s: compound\",\n\t\t\t\t sp->ts_twordlen, tword, fword + sp->ts_fidx);\n#endif\n\t\t\t// Save things to be restored at STATE_SPLITUNDO.\n\t\t\tsp->ts_save_badflags = su->su_badflags;\n\t\t\tPROF_STORE(sp->ts_state)\n\t\t\tsp->ts_state = STATE_SPLITUNDO;\n\n\t\t\t++depth;\n\t\t\tsp = &stack[depth];\n\n\t\t\t// Append a space to preword when splitting.\n\t\t\tif (!try_compound && !fword_ends)\n\t\t\t    STRCAT(preword, \" \");\n\t\t\tsp->ts_prewordlen = (char_u)STRLEN(preword);\n\t\t\tsp->ts_splitoff = sp->ts_twordlen;\n\t\t\tsp->ts_splitfidx = sp->ts_fidx;\n\n\t\t\t// If the badword has a non-word character at this\n\t\t\t// position skip it.  That means replacing the\n\t\t\t// non-word character with a space.  Always skip a\n\t\t\t// character when the word ends.  But only when the\n\t\t\t// good word can end.\n\t\t\tif (((!try_compound && !spell_iswordp_nmw(fword\n\t\t\t\t\t\t\t       + sp->ts_fidx,\n\t\t\t\t\t\t\t       curwin))\n\t\t\t\t    || fword_ends)\n\t\t\t\t&& fword[sp->ts_fidx] != NUL\n\t\t\t\t&& goodword_ends)\n\t\t\t{\n\t\t\t    int\t    l;\n\n\t\t\t    l = mb_ptr2len(fword + sp->ts_fidx);\n\t\t\t    if (fword_ends)\n\t\t\t    {\n\t\t\t\t// Copy the skipped character to preword.\n\t\t\t\tmch_memmove(preword + sp->ts_prewordlen,\n\t\t\t\t\t\t      fword + sp->ts_fidx, l);\n\t\t\t\tsp->ts_prewordlen += l;\n\t\t\t\tpreword[sp->ts_prewordlen] = NUL;\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tsp->ts_score -= SCORE_SPLIT - SCORE_SUBST;\n\t\t\t    sp->ts_fidx += l;\n\t\t\t}\n\n\t\t\t// When compounding include compound flag in\n\t\t\t// compflags[] (already set above).  When splitting we\n\t\t\t// may start compounding over again.\n\t\t\tif (try_compound)\n\t\t\t    ++sp->ts_complen;\n\t\t\telse\n\t\t\t    sp->ts_compsplit = sp->ts_complen;\n\t\t\tsp->ts_prefixdepth = PFD_NOPREFIX;\n\n\t\t\t// set su->su_badflags to the caps type at this\n\t\t\t// position\n\t\t\tif (has_mbyte)\n\t\t\t    n = nofold_len(fword, sp->ts_fidx, su->su_badptr);\n\t\t\telse\n\t\t\t    n = sp->ts_fidx;\n\t\t\tsu->su_badflags = badword_captype(su->su_badptr + n,\n\t\t\t\t\t       su->su_badptr + su->su_badlen);\n\n\t\t\t// Restart at top of the tree.\n\t\t\tsp->ts_arridx = 0;\n\n\t\t\t// If there are postponed prefixes, try these too.\n\t\t\tif (pbyts != NULL)\n\t\t\t{\n\t\t\t    byts = pbyts;\n\t\t\t    idxs = pidxs;\n\t\t\t    sp->ts_prefixdepth = PFD_PREFIXTREE;\n\t\t\t    PROF_STORE(sp->ts_state)\n\t\t\t    sp->ts_state = STATE_NOPREFIX;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\n\tcase STATE_SPLITUNDO:\n\t    // Undo the changes done for word split or compound word.\n\t    su->su_badflags = sp->ts_save_badflags;\n\n\t    // Continue looking for NUL bytes.\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_START;\n\n\t    // In case we went into the prefix tree.\n\t    byts = fbyts;\n\t    idxs = fidxs;\n\t    break;\n\n\tcase STATE_ENDNUL:\n\t    // Past the NUL bytes in the node.\n\t    su->su_badflags = sp->ts_save_badflags;\n\t    if (fword[sp->ts_fidx] == NUL && sp->ts_tcharlen == 0)\n\t    {\n\t\t// The badword ends, can't use STATE_PLAIN.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_DEL;\n\t\tbreak;\n\t    }\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_PLAIN;\n\t    // FALLTHROUGH\n\n\tcase STATE_PLAIN:\n\t    // Go over all possible bytes at this node, add each to tword[]\n\t    // and use child node.  \"ts_curi\" is the index.\n\t    arridx = sp->ts_arridx;\n\t    if (sp->ts_curi > byts[arridx])\n\t    {\n\t\t// Done all bytes at this node, do next state.  When still at\n\t\t// already changed bytes skip the other tricks.\n\t\tPROF_STORE(sp->ts_state)\n\t\tif (sp->ts_fidx >= sp->ts_fidxtry)\n\t\t    sp->ts_state = STATE_DEL;\n\t\telse\n\t\t    sp->ts_state = STATE_FINAL;\n\t    }\n\t    else\n\t    {\n\t\tarridx += sp->ts_curi++;\n\t\tc = byts[arridx];\n\n\t\t// Normal byte, go one level deeper.  If it's not equal to the\n\t\t// byte in the bad word adjust the score.  But don't even try\n\t\t// when the byte was already changed.  And don't try when we\n\t\t// just deleted this byte, accepting it is always cheaper than\n\t\t// delete + substitute.\n\t\tif (c == fword[sp->ts_fidx]\n\t\t\t|| (sp->ts_tcharlen > 0 && sp->ts_isdiff != DIFF_NONE))\n\t\t    newscore = 0;\n\t\telse\n\t\t    newscore = SCORE_SUBST;\n\t\tif ((newscore == 0\n\t\t\t    || (sp->ts_fidx >= sp->ts_fidxtry\n\t\t\t\t&& ((sp->ts_flags & TSF_DIDDEL) == 0\n\t\t\t\t    || c != fword[sp->ts_delidx])))\n\t\t\t&& TRY_DEEPER(su, stack, depth, newscore))\n\t\t{\n\t\t    go_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\t    if (newscore > 0)\n\t\t\tsprintf(changename[depth], \"%.*s-%s: subst %c to %c\",\n\t\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t\tfword[sp->ts_fidx], c);\n\t\t    else\n\t\t\tsprintf(changename[depth], \"%.*s-%s: accept %c\",\n\t\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t\tfword[sp->ts_fidx]);\n#endif\n\t\t    ++depth;\n\t\t    sp = &stack[depth];\n\t\t    if (fword[sp->ts_fidx] != NUL)\n\t\t\t++sp->ts_fidx;\n\t\t    tword[sp->ts_twordlen++] = c;\n\t\t    sp->ts_arridx = idxs[arridx];\n\t\t    if (newscore == SCORE_SUBST)\n\t\t\tsp->ts_isdiff = DIFF_YES;\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\t// Multi-byte characters are a bit complicated to\n\t\t\t// handle: They differ when any of the bytes differ\n\t\t\t// and then their length may also differ.\n\t\t\tif (sp->ts_tcharlen == 0)\n\t\t\t{\n\t\t\t    // First byte.\n\t\t\t    sp->ts_tcharidx = 0;\n\t\t\t    sp->ts_tcharlen = MB_BYTE2LEN(c);\n\t\t\t    sp->ts_fcharstart = sp->ts_fidx - 1;\n\t\t\t    sp->ts_isdiff = (newscore != 0)\n\t\t\t\t\t\t       ? DIFF_YES : DIFF_NONE;\n\t\t\t}\n\t\t\telse if (sp->ts_isdiff == DIFF_INSERT\n\t\t\t\t\t\t\t    && sp->ts_fidx > 0)\n\t\t\t    // When inserting trail bytes don't advance in the\n\t\t\t    // bad word.\n\t\t\t    --sp->ts_fidx;\n\t\t\tif (++sp->ts_tcharidx == sp->ts_tcharlen)\n\t\t\t{\n\t\t\t    // Last byte of character.\n\t\t\t    if (sp->ts_isdiff == DIFF_YES)\n\t\t\t    {\n\t\t\t\t// Correct ts_fidx for the byte length of the\n\t\t\t\t// character (we didn't check that before).\n\t\t\t\tsp->ts_fidx = sp->ts_fcharstart\n\t\t\t\t\t    + mb_ptr2len(\n\t\t\t\t\t\t    fword + sp->ts_fcharstart);\n\t\t\t\t// For changing a composing character adjust\n\t\t\t\t// the score from SCORE_SUBST to\n\t\t\t\t// SCORE_SUBCOMP.\n\t\t\t\tif (enc_utf8\n\t\t\t\t\t&& utf_iscomposing(\n\t\t\t\t\t    utf_ptr2char(tword\n\t\t\t\t\t\t+ sp->ts_twordlen\n\t\t\t\t\t\t\t   - sp->ts_tcharlen))\n\t\t\t\t\t&& utf_iscomposing(\n\t\t\t\t\t    utf_ptr2char(fword\n\t\t\t\t\t\t\t+ sp->ts_fcharstart)))\n\t\t\t\t    sp->ts_score -=\n\t\t\t\t\t\t  SCORE_SUBST - SCORE_SUBCOMP;\n\n\t\t\t\t// For a similar character adjust score from\n\t\t\t\t// SCORE_SUBST to SCORE_SIMILAR.\n\t\t\t\telse if (!soundfold\n\t\t\t\t\t&& slang->sl_has_map\n\t\t\t\t\t&& similar_chars(slang,\n\t\t\t\t\t    mb_ptr2char(tword\n\t\t\t\t\t\t+ sp->ts_twordlen\n\t\t\t\t\t\t\t   - sp->ts_tcharlen),\n\t\t\t\t\t    mb_ptr2char(fword\n\t\t\t\t\t\t\t+ sp->ts_fcharstart)))\n\t\t\t\t    sp->ts_score -=\n\t\t\t\t\t\t  SCORE_SUBST - SCORE_SIMILAR;\n\t\t\t    }\n\t\t\t    else if (sp->ts_isdiff == DIFF_INSERT\n\t\t\t\t\t && sp->ts_twordlen > sp->ts_tcharlen)\n\t\t\t    {\n\t\t\t\tp = tword + sp->ts_twordlen - sp->ts_tcharlen;\n\t\t\t\tc = mb_ptr2char(p);\n\t\t\t\tif (enc_utf8 && utf_iscomposing(c))\n\t\t\t\t{\n\t\t\t\t    // Inserting a composing char doesn't\n\t\t\t\t    // count that much.\n\t\t\t\t    sp->ts_score -= SCORE_INS - SCORE_INSCOMP;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    // If the previous character was the same,\n\t\t\t\t    // thus doubling a character, give a bonus\n\t\t\t\t    // to the score.  Also for the soundfold\n\t\t\t\t    // tree (might seem illogical but does\n\t\t\t\t    // give better scores).\n\t\t\t\t    MB_PTR_BACK(tword, p);\n\t\t\t\t    if (c == mb_ptr2char(p))\n\t\t\t\t\tsp->ts_score -= SCORE_INS\n\t\t\t\t\t\t\t       - SCORE_INSDUP;\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t    // Starting a new char, reset the length.\n\t\t\t    sp->ts_tcharlen = 0;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// If we found a similar char adjust the score.\n\t\t\t// We do this after calling go_deeper() because\n\t\t\t// it's slow.\n\t\t\tif (newscore != 0\n\t\t\t\t&& !soundfold\n\t\t\t\t&& slang->sl_has_map\n\t\t\t\t&& similar_chars(slang,\n\t\t\t\t\t\t   c, fword[sp->ts_fidx - 1]))\n\t\t\t    sp->ts_score -= SCORE_SUBST - SCORE_SIMILAR;\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\n\tcase STATE_DEL:\n\t    // When past the first byte of a multi-byte char don't try\n\t    // delete/insert/swap a character.\n\t    if (has_mbyte && sp->ts_tcharlen > 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\t    // Try skipping one character in the bad word (delete it).\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_INS_PREP;\n\t    sp->ts_curi = 1;\n\t    if (soundfold && sp->ts_fidx == 0 && fword[sp->ts_fidx] == '*')\n\t\t// Deleting a vowel at the start of a word counts less, see\n\t\t// soundalike_score().\n\t\tnewscore = 2 * SCORE_DEL / 3;\n\t    else\n\t\tnewscore = SCORE_DEL;\n\t    if (fword[sp->ts_fidx] != NUL\n\t\t\t\t    && TRY_DEEPER(su, stack, depth, newscore))\n\t    {\n\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: delete %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tfword[sp->ts_fidx]);\n#endif\n\t\t++depth;\n\n\t\t// Remember what character we deleted, so that we can avoid\n\t\t// inserting it again.\n\t\tstack[depth].ts_flags |= TSF_DIDDEL;\n\t\tstack[depth].ts_delidx = sp->ts_fidx;\n\n\t\t// Advance over the character in fword[].  Give a bonus to the\n\t\t// score if the same character is following \"nn\" -> \"n\".  It's\n\t\t// a bit illogical for soundfold tree but it does give better\n\t\t// results.\n\t\tif (has_mbyte)\n\t\t{\n\t\t    c = mb_ptr2char(fword + sp->ts_fidx);\n\t\t    stack[depth].ts_fidx += mb_ptr2len(fword + sp->ts_fidx);\n\t\t    if (enc_utf8 && utf_iscomposing(c))\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELCOMP;\n\t\t    else if (c == mb_ptr2char(fword + stack[depth].ts_fidx))\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++stack[depth].ts_fidx;\n\t\t    if (fword[sp->ts_fidx] == fword[sp->ts_fidx + 1])\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;\n\t\t}\n\t\tbreak;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase STATE_INS_PREP:\n\t    if (sp->ts_flags & TSF_DIDDEL)\n\t    {\n\t\t// If we just deleted a byte then inserting won't make sense,\n\t\t// a substitute is always cheaper.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP;\n\t\tbreak;\n\t    }\n\n\t    // skip over NUL bytes\n\t    n = sp->ts_arridx;\n\t    for (;;)\n\t    {\n\t\tif (sp->ts_curi > byts[n])\n\t\t{\n\t\t    // Only NUL bytes at this node, go to next state.\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_SWAP;\n\t\t    break;\n\t\t}\n\t\tif (byts[n + sp->ts_curi] != NUL)\n\t\t{\n\t\t    // Found a byte to insert.\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_INS;\n\t\t    break;\n\t\t}\n\t\t++sp->ts_curi;\n\t    }\n\t    break;\n\n\t    // FALLTHROUGH\n\n\tcase STATE_INS:\n\t    // Insert one byte.  Repeat this for each possible byte at this\n\t    // node.\n\t    n = sp->ts_arridx;\n\t    if (sp->ts_curi > byts[n])\n\t    {\n\t\t// Done all bytes at this node, go to next state.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP;\n\t\tbreak;\n\t    }\n\n\t    // Do one more byte at this node, but:\n\t    // - Skip NUL bytes.\n\t    // - Skip the byte if it's equal to the byte in the word,\n\t    //   accepting that byte is always better.\n\t    n += sp->ts_curi++;\n\t    c = byts[n];\n\t    if (soundfold && sp->ts_twordlen == 0 && c == '*')\n\t\t// Inserting a vowel at the start of a word counts less,\n\t\t// see soundalike_score().\n\t\tnewscore = 2 * SCORE_INS / 3;\n\t    else\n\t\tnewscore = SCORE_INS;\n\t    if (c != fword[sp->ts_fidx]\n\t\t\t\t    && TRY_DEEPER(su, stack, depth, newscore))\n\t    {\n\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: insert %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc);\n#endif\n\t\t++depth;\n\t\tsp = &stack[depth];\n\t\ttword[sp->ts_twordlen++] = c;\n\t\tsp->ts_arridx = idxs[n];\n\t\tif (has_mbyte)\n\t\t{\n\t\t    fl = MB_BYTE2LEN(c);\n\t\t    if (fl > 1)\n\t\t    {\n\t\t\t// There are following bytes for the same character.\n\t\t\t// We must find all bytes before trying\n\t\t\t// delete/insert/swap/etc.\n\t\t\tsp->ts_tcharlen = fl;\n\t\t\tsp->ts_tcharidx = 1;\n\t\t\tsp->ts_isdiff = DIFF_INSERT;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    fl = 1;\n\t\tif (fl == 1)\n\t\t{\n\t\t    // If the previous character was the same, thus doubling a\n\t\t    // character, give a bonus to the score.  Also for\n\t\t    // soundfold words (illogical but does give a better\n\t\t    // score).\n\t\t    if (sp->ts_twordlen >= 2\n\t\t\t\t\t   && tword[sp->ts_twordlen - 2] == c)\n\t\t\tsp->ts_score -= SCORE_INS - SCORE_INSDUP;\n\t\t}\n\t    }\n\t    break;\n\n\tcase STATE_SWAP:\n\t    // Swap two bytes in the bad word: \"12\" -> \"21\".\n\t    // We change \"fword\" here, it's changed back afterwards at\n\t    // STATE_UNSWAP.\n\t    p = fword + sp->ts_fidx;\n\t    c = *p;\n\t    if (c == NUL)\n\t    {\n\t\t// End of word, can't swap or replace.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\n\t    // Don't swap if the first character is not a word character.\n\t    // SWAP3 etc. also don't make sense then.\n\t    if (!soundfold && !spell_iswordp(p, curwin))\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\n\t    if (has_mbyte)\n\t    {\n\t\tn = MB_CPTR2LEN(p);\n\t\tc = mb_ptr2char(p);\n\t\tif (p[n] == NUL)\n\t\t    c2 = NUL;\n\t\telse if (!soundfold && !spell_iswordp(p + n, curwin))\n\t\t    c2 = c; // don't swap non-word char\n\t\telse\n\t\t    c2 = mb_ptr2char(p + n);\n\t    }\n\t    else\n\t    {\n\t\tif (p[1] == NUL)\n\t\t    c2 = NUL;\n\t\telse if (!soundfold && !spell_iswordp(p + 1, curwin))\n\t\t    c2 = c; // don't swap non-word char\n\t\telse\n\t\t    c2 = p[1];\n\t    }\n\n\t    // When the second character is NUL we can't swap.\n\t    if (c2 == NUL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\n\t    // When characters are identical, swap won't do anything.\n\t    // Also get here if the second char is not a word character.\n\t    if (c == c2)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP3;\n\t\tbreak;\n\t    }\n\t    if (c2 != NUL && TRY_DEEPER(su, stack, depth, SCORE_SWAP))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: swap %c and %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc, c2);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNSWAP;\n\t\t++depth;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    fl = mb_char2len(c2);\n\t\t    mch_memmove(p, p + n, fl);\n\t\t    mb_char2bytes(c, p + fl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[0] = c2;\n\t\t    p[1] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 2;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// If this swap doesn't work then SWAP3 won't either.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNSWAP:\n\t    // Undo the STATE_SWAP swap: \"21\" -> \"12\".\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tc = mb_ptr2char(p + n);\n\t\tmch_memmove(p + mb_ptr2len(p + n), p, n);\n\t\tmb_char2bytes(c, p);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[1];\n\t\tp[1] = c;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase STATE_SWAP3:\n\t    // Swap two bytes, skipping one: \"123\" -> \"321\".  We change\n\t    // \"fword\" here, it's changed back afterwards at STATE_UNSWAP3.\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = MB_CPTR2LEN(p);\n\t\tc = mb_ptr2char(p);\n\t\tfl = MB_CPTR2LEN(p + n);\n\t\tc2 = mb_ptr2char(p + n);\n\t\tif (!soundfold && !spell_iswordp(p + n + fl, curwin))\n\t\t    c3 = c;\t// don't swap non-word char\n\t\telse\n\t\t    c3 = mb_ptr2char(p + n + fl);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\tc2 = p[1];\n\t\tif (!soundfold && !spell_iswordp(p + 2, curwin))\n\t\t    c3 = c;\t// don't swap non-word char\n\t\telse\n\t\t    c3 = p[2];\n\t    }\n\n\t    // When characters are identical: \"121\" then SWAP3 result is\n\t    // identical, ROT3L result is same as SWAP: \"211\", ROT3L result is\n\t    // same as SWAP on next char: \"112\".  Thus skip all swapping.\n\t    // Also skip when c3 is NUL.\n\t    // Also get here when the third character is not a word character.\n\t    // Second character may any char: \"a.b\" -> \"b.a\"\n\t    if (c == c3 || c3 == NUL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: swap3 %c and %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc, c3);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNSWAP3;\n\t\t++depth;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    tl = mb_char2len(c3);\n\t\t    mch_memmove(p, p + n + fl, tl);\n\t\t    mb_char2bytes(c2, p + tl);\n\t\t    mb_char2bytes(c, p + fl + tl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl + tl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[0] = p[2];\n\t\t    p[2] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNSWAP3:\n\t    // Undo STATE_SWAP3: \"321\" -> \"123\"\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tc2 = mb_ptr2char(p + n);\n\t\tfl = mb_ptr2len(p + n);\n\t\tc = mb_ptr2char(p + n + fl);\n\t\ttl = mb_ptr2len(p + n + fl);\n\t\tmch_memmove(p + fl + tl, p, n);\n\t\tmb_char2bytes(c, p);\n\t\tmb_char2bytes(c2, p + tl);\n\t\tp = p + tl;\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[2];\n\t\tp[2] = c;\n\t\t++p;\n\t    }\n\n\t    if (!soundfold && !spell_iswordp(p, curwin))\n\t    {\n\t\t// Middle char is not a word char, skip the rotate.  First and\n\t\t// third char were already checked at swap and swap3.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\n\t    // Rotate three characters left: \"123\" -> \"231\".  We change\n\t    // \"fword\" here, it's changed back afterwards at STATE_UNROT3L.\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tp = fword + sp->ts_fidx;\n\t\tsprintf(changename[depth], \"%.*s-%s: rotate left %c%c%c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tp[0], p[1], p[2]);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNROT3L;\n\t\t++depth;\n\t\tp = fword + sp->ts_fidx;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    n = MB_CPTR2LEN(p);\n\t\t    c = mb_ptr2char(p);\n\t\t    fl = MB_CPTR2LEN(p + n);\n\t\t    fl += MB_CPTR2LEN(p + n + fl);\n\t\t    mch_memmove(p, p + n, fl);\n\t\t    mb_char2bytes(c, p + fl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = *p;\n\t\t    *p = p[1];\n\t\t    p[1] = p[2];\n\t\t    p[2] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNROT3L:\n\t    // Undo ROT3L: \"231\" -> \"123\"\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tn += mb_ptr2len(p + n);\n\t\tc = mb_ptr2char(p + n);\n\t\ttl = mb_ptr2len(p + n);\n\t\tmch_memmove(p + tl, p, n);\n\t\tmb_char2bytes(c, p);\n\t    }\n\t    else\n\t    {\n\t\tc = p[2];\n\t\tp[2] = p[1];\n\t\tp[1] = *p;\n\t\t*p = c;\n\t    }\n\n\t    // Rotate three bytes right: \"123\" -> \"312\".  We change \"fword\"\n\t    // here, it's changed back afterwards at STATE_UNROT3R.\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tp = fword + sp->ts_fidx;\n\t\tsprintf(changename[depth], \"%.*s-%s: rotate right %c%c%c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tp[0], p[1], p[2]);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNROT3R;\n\t\t++depth;\n\t\tp = fword + sp->ts_fidx;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    n = MB_CPTR2LEN(p);\n\t\t    n += MB_CPTR2LEN(p + n);\n\t\t    c = mb_ptr2char(p + n);\n\t\t    tl = MB_CPTR2LEN(p + n);\n\t\t    mch_memmove(p + tl, p, n);\n\t\t    mb_char2bytes(c, p);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + tl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = p[2];\n\t\t    p[2] = p[1];\n\t\t    p[1] = *p;\n\t\t    *p = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNROT3R:\n\t    // Undo ROT3R: \"312\" -> \"123\"\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tc = mb_ptr2char(p);\n\t\ttl = mb_ptr2len(p);\n\t\tn = mb_ptr2len(p + tl);\n\t\tn += mb_ptr2len(p + tl + n);\n\t\tmch_memmove(p, p + tl, n);\n\t\tmb_char2bytes(c, p + n);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[1];\n\t\tp[1] = p[2];\n\t\tp[2] = c;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase STATE_REP_INI:\n\t    // Check if matching with REP items from the .aff file would work.\n\t    // Quickly skip if:\n\t    // - there are no REP items and we are not in the soundfold trie\n\t    // - the score is going to be too high anyway\n\t    // - already applied a REP item or swapped here\n\t    if ((lp->lp_replang == NULL && !soundfold)\n\t\t    || sp->ts_score + SCORE_REP >= su->su_maxscore\n\t\t    || sp->ts_fidx < sp->ts_fidxtry)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\n\t    // Use the first byte to quickly find the first entry that may\n\t    // match.  If the index is -1 there is none.\n\t    if (soundfold)\n\t\tsp->ts_curi = slang->sl_repsal_first[fword[sp->ts_fidx]];\n\t    else\n\t\tsp->ts_curi = lp->lp_replang->sl_rep_first[fword[sp->ts_fidx]];\n\n\t    if (sp->ts_curi < 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_REP;\n\t    // FALLTHROUGH\n\n\tcase STATE_REP:\n\t    // Try matching with REP items from the .aff file.  For each match\n\t    // replace the characters and check if the resulting word is\n\t    // valid.\n\t    p = fword + sp->ts_fidx;\n\n\t    if (soundfold)\n\t\tgap = &slang->sl_repsal;\n\t    else\n\t\tgap = &lp->lp_replang->sl_rep;\n\t    while (sp->ts_curi < gap->ga_len)\n\t    {\n\t\tftp = (fromto_T *)gap->ga_data + sp->ts_curi++;\n\t\tif (*ftp->ft_from != *p)\n\t\t{\n\t\t    // past possible matching entries\n\t\t    sp->ts_curi = gap->ga_len;\n\t\t    break;\n\t\t}\n\t\tif (STRNCMP(ftp->ft_from, p, STRLEN(ftp->ft_from)) == 0\n\t\t\t&& TRY_DEEPER(su, stack, depth, SCORE_REP))\n\t\t{\n\t\t    go_deeper(stack, depth, SCORE_REP);\n#ifdef DEBUG_TRIEWALK\n\t\t    sprintf(changename[depth], \"%.*s-%s: replace %s with %s\",\n\t\t\t    sp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t    ftp->ft_from, ftp->ft_to);\n#endif\n\t\t    // Need to undo this afterwards.\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_REP_UNDO;\n\n\t\t    // Change the \"from\" to the \"to\" string.\n\t\t    ++depth;\n\t\t    fl = (int)STRLEN(ftp->ft_from);\n\t\t    tl = (int)STRLEN(ftp->ft_to);\n\t\t    if (fl != tl)\n\t\t    {\n\t\t\tSTRMOVE(p + tl, p + fl);\n\t\t\trepextra += tl - fl;\n\t\t    }\n\t\t    mch_memmove(p, ftp->ft_to, tl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + tl;\n\t\t    stack[depth].ts_tcharlen = 0;\n\t\t    break;\n\t\t}\n\t    }\n\n\t    if (sp->ts_curi >= gap->ga_len && sp->ts_state == STATE_REP)\n\t    {\n\t\t// No (more) matches.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t    }\n\n\t    break;\n\n\tcase STATE_REP_UNDO:\n\t    // Undo a REP replacement and continue with the next one.\n\t    if (soundfold)\n\t\tgap = &slang->sl_repsal;\n\t    else\n\t\tgap = &lp->lp_replang->sl_rep;\n\t    ftp = (fromto_T *)gap->ga_data + sp->ts_curi - 1;\n\t    fl = (int)STRLEN(ftp->ft_from);\n\t    tl = (int)STRLEN(ftp->ft_to);\n\t    p = fword + sp->ts_fidx;\n\t    if (fl != tl)\n\t    {\n\t\tSTRMOVE(p + fl, p + tl);\n\t\trepextra -= tl - fl;\n\t    }\n\t    mch_memmove(p, ftp->ft_from, fl);\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_REP;\n\t    break;\n\n\tdefault:\n\t    // Did all possible states at this level, go up one level.\n\t    --depth;\n\n\t    if (depth >= 0 && stack[depth].ts_prefixdepth == PFD_PREFIXTREE)\n\t    {\n\t\t// Continue in or go back to the prefix tree.\n\t\tbyts = pbyts;\n\t\tidxs = pidxs;\n\t    }\n\n\t    // Don't check for CTRL-C too often, it takes time.\n\t    if (--breakcheckcount == 0)\n\t    {\n\t\tui_breakcheck();\n\t\tbreakcheckcount = 1000;\n#ifdef FEAT_RELTIME\n\t\tif (spell_suggest_timeout > 0\n\t\t\t\t\t  && profile_passed_limit(&time_limit))\n\t\t    got_int = TRUE;\n#endif\n\t    }\n\t}\n    }\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"vim.h\"\n\n// Type Definitions:\n// fromto_T:\ntypedef struct fromto_S\n{\n    char_u\t*ft_from;\n    char_u\t*ft_to;\n} fromto_T;\n\n// trystate_T:\ntypedef struct trystate_S\n{\n    state_T\tts_state;\t// state at this level, STATE_\n    int\t\tts_score;\t// score\n    idx_T\tts_arridx;\t// index in tree array, start of node\n    short\tts_curi;\t// index in list of child nodes\n    char_u\tts_fidx;\t// index in fword[], case-folded bad word\n    char_u\tts_fidxtry;\t// ts_fidx at which bytes may be changed\n    char_u\tts_twordlen;\t// valid length of tword[]\n    char_u\tts_prefixdepth;\t// stack depth for end of prefix or\n\t\t\t\t// PFD_PREFIXTREE or PFD_NOPREFIX\n    char_u\tts_flags;\t// TSF_ flags\n    char_u\tts_tcharlen;\t// number of bytes in tword character\n    char_u\tts_tcharidx;\t// current byte index in tword character\n    char_u\tts_isdiff;\t// DIFF_ values\n    char_u\tts_fcharstart;\t// index in fword where badword char started\n    char_u\tts_prewordlen;\t// length of word in \"preword[]\"\n    char_u\tts_splitoff;\t// index in \"tword\" after last split\n    char_u\tts_splitfidx;\t// \"ts_fidx\" at word split\n    char_u\tts_complen;\t// nr of compound words used\n    c...\n\n// slang_T:\ntypedef struct slang_S slang_T;\n\n// suginfo_T:\ntypedef struct suginfo_S\n{\n    garray_T\tsu_ga;\t\t    // suggestions, contains \"suggest_T\"\n    int\t\tsu_maxcount;\t    // max. number of suggestions displayed\n    int\t\tsu_maxscore;\t    // maximum score for adding to su_ga\n    int\t\tsu_sfmaxscore;\t    // idem, for when doing soundfold words\n    garray_T\tsu_sga;\t\t    // like su_ga, sound-folded scoring\n    char_u\t*su_badptr;\t    // start of bad word in line\n    int\t\tsu_badlen;\t    // length of detected bad word in line\n    int\t\tsu_badflags;\t    // caps flags for bad word\n    char_u\tsu_badword[MAXWLEN]; // bad word truncated at su_badlen\n    char_u\tsu_fbadword[MAXWLEN]; // su_badword case-folded\n    char_u\tsu_sal_badword[MAXWLEN]; // su_badword soundfolded\n    hashtab_T\tsu_banned;\t    // table with banned words\n    slang_T\t*su_sallang;\t    // default language for sound folding\n} suginfo_T;\n\n// langp_T:\ntypedef struct langp_S\n{\n    slang_T\t*lp_slang;\t// info for this language\n    slang_T\t*lp_sallang;\t// language used for sound folding or NULL\n    slang_T\t*lp_replang;\t// language used for REP items or NULL\n    int\t\tlp_region;\t// bitmask for region or REGION_ALL\n} langp_T;\n\n// garray_T:\ntypedef struct growarray\n{\n    int\t    ga_len;\t\t    // current number of items used\n    int\t    ga_maxlen;\t\t    // maximum number of items possible\n    int\t    ga_itemsize;\t    // sizeof(item)\n    int\t    ga_growsize;\t    // number of items to grow each time\n    void    *ga_data;\t\t    // pointer to the first item\n} garray_T;\n\n// char_u:\ntypedef unsigned char\tchar_u;\n\n// idx_T:\ntypedef int idx_T;\n\n// Called Methods (top 10):\n// SCORE_SUBCOMP from src/spellsuggest.c:\n#define SCORE_SUBCOMP\t33\t// substitute a composing character /* <=== src/spellsuggest.c:95:95:SCORE_SUBCOMP:0 */ \n\n// vim_strnsave from src/strings.c:\n    char_u * /* <=== vim_strnsave */ \nvim_strnsave(char_u *string, size_t len)\n{\n    char_u\t*p;\n\n    p = alloc(len + 1);\n    if (p != NULL)\n    {\n\tSTRNCPY(p, string, len);\n\tp[len] = NUL;\n    }\n    return p;\n}\n\n// mb_ptr2char_adv from src/mbyte.c:\n    int /* <=== mb_ptr2char_adv */ \nmb_ptr2char_adv(char_u **pp)\n{\n    int\t\tc;\n\n    c = (*mb_ptr2char)(*pp);\n    *pp += (*mb_ptr2len)(*pp);\n    return c;\n}\n\n// STRMOVE from src/vim.h:\n#define STRMOVE(d, s)\t    mch_memmove((d), (s), STRLEN(s) + 1) /* <=== src/vim.h:1679:1679:STRMOVE:2 */ \n\n// SCORE_LIMITMAX from src/spellsuggest.c:\n#define SCORE_LIMITMAX\t350\t\t// for spell_edit_score_limit() /* <=== src/spellsuggest.c:123:123:SCORE_LIMITMAX:0 */ \n\n// WF_NOSUGGEST from src/spell.h:\n#define WF_NOSUGGEST 0x0400\t// word not to be suggested /* <=== src/spell.h:160:160:WF_NOSUGGEST:0 */ \n\n// hash_add_item from src/hashtab.c:\n    int /* <=== hash_add_item */ \nhash_add_item(\n    hashtab_T\t*ht,\n    hashitem_T\t*hi,\n    char_u\t*key,\n    hash_T\thash)\n{\n    // If resizing failed before and it fails again we can't add an item.\n    if (ht->ht_error && hash_may_resize(ht, 0) == FAIL)\n\treturn FAIL;\n\n    ++ht->ht_used;\n    ++ht->ht_changed;\n    if (hi->hi_key == NULL)\n\t++ht->ht_filled;\n    hi->hi_key = key;\n    hi->hi_hash = hash;\n\n    // When the space gets low may resize the array.\n    return hash_may_resize(ht, 0);\n}\n\n// WF_RAREPFX from src/spell.h:\n#define WF_RAREPFX  (WFP_RARE << 24)\t// rare postponed prefix /* <=== src/spell.h:174:174:WF_RAREPFX:0 */ \n\n// ui_breakcheck from src/ui.c:\n    void /* <=== ui_breakcheck */ \nui_breakcheck(void)\n{\n    ui_breakcheck_force(FALSE);\n}\n\n// FALSE from src/vim.h:\n# define FALSE\t0\t    // note: this is an int, not a long! /* <=== src/vim.h:1481:1481:FALSE:0 */ \n"
  },
  {
    "repository": "linux",
    "cve_id": "CVE-2022-29968",
    "cwe_list": [
      "CWE-94"
    ],
    "commit_hash": "32452a3eb8b64e01e2be717f518c0be046975b9d",
    "short_hash": "32452a3e",
    "vulnerableMethods_before": [
      {
        "filename": "io_uring.c",
        "method_name": "vulnerable_function",
        "raw_code": "static int io_rw_init_file(struct io_kiocb *req, fmode_t mode)\n{\n\tstruct kiocb *kiocb = &req->rw.kiocb;\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct file *file = req->file;\n\tint ret;\n\n\tif (unlikely(!file || !(file->f_mode & mode)))\n\t\treturn -EBADF;\n\n\tif (!io_req_ffs_set(req))\n\t\treq->flags |= io_file_get_flags(file) << REQ_F_SUPPORT_NOWAIT_BIT;\n\n\tkiocb->ki_flags = iocb_flags(file);\n\tret = kiocb_set_rw_flags(kiocb, req->rw.flags);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\t/*\n\t * If the file is marked O_NONBLOCK, still allow retry for it if it\n\t * supports async. Otherwise it's impossible to use O_NONBLOCK files\n\t * reliably. If not, or it IOCB_NOWAIT is set, don't retry.\n\t */\n\tif ((kiocb->ki_flags & IOCB_NOWAIT) ||\n\t    ((file->f_flags & O_NONBLOCK) && !io_file_supports_nowait(req)))\n\t\treq->flags |= REQ_F_NOWAIT;\n\n\tif (ctx->flags & IORING_SETUP_IOPOLL) {\n\t\tif (!(kiocb->ki_flags & IOCB_DIRECT) || !file->f_op->iopoll)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tkiocb->ki_flags |= IOCB_HIPRI | IOCB_ALLOC_CACHE;\n\t\tkiocb->ki_complete = io_complete_rw_iopoll;\n\t\treq->iopoll_completed = 0;\n\t} else {\n\t\tif (kiocb->ki_flags & IOCB_HIPRI)\n\t\t\treturn -EINVAL;\n\t\tkiocb->ki_complete = io_complete_rw;\n\t}\n\n\treturn 0;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "io_uring.c",
        "method_name": "fixed_function",
        "raw_code": "static int io_rw_init_file(struct io_kiocb *req, fmode_t mode)\n{\n\tstruct kiocb *kiocb = &req->rw.kiocb;\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct file *file = req->file;\n\tint ret;\n\n\tif (unlikely(!file || !(file->f_mode & mode)))\n\t\treturn -EBADF;\n\n\tif (!io_req_ffs_set(req))\n\t\treq->flags |= io_file_get_flags(file) << REQ_F_SUPPORT_NOWAIT_BIT;\n\n\tkiocb->ki_flags = iocb_flags(file);\n\tret = kiocb_set_rw_flags(kiocb, req->rw.flags);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\t/*\n\t * If the file is marked O_NONBLOCK, still allow retry for it if it\n\t * supports async. Otherwise it's impossible to use O_NONBLOCK files\n\t * reliably. If not, or it IOCB_NOWAIT is set, don't retry.\n\t */\n\tif ((kiocb->ki_flags & IOCB_NOWAIT) ||\n\t    ((file->f_flags & O_NONBLOCK) && !io_file_supports_nowait(req)))\n\t\treq->flags |= REQ_F_NOWAIT;\n\n\tif (ctx->flags & IORING_SETUP_IOPOLL) {\n\t\tif (!(kiocb->ki_flags & IOCB_DIRECT) || !file->f_op->iopoll)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tkiocb->private = NULL;\n\t\tkiocb->ki_flags |= IOCB_HIPRI | IOCB_ALLOC_CACHE;\n\t\tkiocb->ki_complete = io_complete_rw_iopoll;\n\t\treq->iopoll_completed = 0;\n\t} else {\n\t\tif (kiocb->ki_flags & IOCB_HIPRI)\n\t\t\treturn -EINVAL;\n\t\tkiocb->ki_complete = io_complete_rw;\n\t}\n\n\treturn 0;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"io-wq.h\"\n#include <net/scm.h>\n#include <linux/nospec.h>\n#include <linux/fsnotify.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/anon_inodes.h>\n#include <linux/highmem.h>\n#include <linux/sched/mm.h>\n#include <linux/splice.h>\n#include <linux/bits.h>\n#include <linux/init.h>\n#include <linux/uaccess.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/signal.h>\n#include <linux/blk-mq.h>\n#include <linux/uio.h>\n#include <linux/compat.h>\n#include <linux/eventpoll.h>\n#include <linux/task_work.h>\n#include <linux/security.h>\n#include <linux/audit.h>\n#include <net/sock.h>\n#include <linux/sizes.h>\n#include <linux/mm.h>\n#include <linux/io_uring.h>\n#include <trace/events/io_uring.h>\n#include <net/compat.h>\n#include <linux/refcount.h>\n#include <uapi/linux/io_uring.h>\n#include <linux/file.h>\n#include <linux/net.h>\n#include <linux/namei.h>\n#include <linux/bvec.h>\n#include <linux/fadvise.h>\n#include <linux/percpu.h>\n#include <linux/slab.h>\n#include <net/af_unix.h>\n#include <linux/fdtable.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include \"internal.h\"\n\n// Type Definitions:\n// io_kiocb:\nstruct io_kiocb\n\n// file:\nstruct file\n\n// io_ring_ctx:\nstruct io_ring_ctx\n\n// kiocb:\nstruct kiocb\n\n// Called Methods (top 10):\n// __io_file_supports_nowait from fs/io_uring.c:\nstatic bool __io_file_supports_nowait(struct file *file, umode_t mode) /* <=== __io_file_supports_nowait */ \n{\n\tif (S_ISBLK(mode)) {\n\t\tif (IS_ENABLED(CONFIG_BLOCK) &&\n\t\t    io_bdev_nowait(I_BDEV(file->f_mapping->host)))\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tif (S_ISSOCK(mode))\n\t\treturn true;\n\tif (S_ISREG(mode)) {\n\t\tif (IS_ENABLED(CONFIG_BLOCK) &&\n\t\t    io_bdev_nowait(file->f_inode->i_sb->s_bdev) &&\n\t\t    file->f_op != &io_uring_fops)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\t/* any ->read/write should understand O_NONBLOCK */\n\tif (file->f_flags & O_NONBLOCK)\n\t\treturn true;\n\treturn file->f_mode & FMODE_NOWAIT;\n}\n\n// FFS_ISREG from fs/io_uring.c:\n#define FFS_ISREG\t\t0x2UL /* <=== fs/io_uring.c:1603:1603:FFS_ISREG:0 */ \n\n// io_file_get_flags from fs/io_uring.c:\nstatic unsigned int io_file_get_flags(struct file *file) /* <=== io_file_get_flags */ \n{\n\tumode_t mode = file_inode(file)->i_mode;\n\tunsigned int res = 0;\n\n\tif (S_ISREG(mode))\n\t\tres |= FFS_ISREG;\n\tif (__io_file_supports_nowait(file, mode))\n\t\tres |= FFS_NOWAIT;\n\treturn res;\n}\n\n// io_req_ffs_set from fs/io_uring.c:\nstatic inline bool io_req_ffs_set(struct io_kiocb *req) /* <=== io_req_ffs_set */ \n{\n\treturn req->flags & REQ_F_FIXED_FILE;\n}\n\n// io_file_supports_nowait from fs/io_uring.c:\nstatic inline bool io_file_supports_nowait(struct io_kiocb *req) /* <=== io_file_supports_nowait */ \n{\n\treturn req->flags & REQ_F_SUPPORT_NOWAIT;\n}\n\n// io_bdev_nowait from fs/io_uring.c:\nstatic bool io_bdev_nowait(struct block_device *bdev) /* <=== io_bdev_nowait */ \n{\n\treturn !bdev || blk_queue_nowait(bdev_get_queue(bdev));\n}\n\n// FFS_NOWAIT from fs/io_uring.c:\n#define FFS_NOWAIT\t\t0x1UL /* <=== fs/io_uring.c:1602:1602:FFS_NOWAIT:0 */ \n"
  },
  {
    "repository": "cifs-utils",
    "cve_id": "CVE-2011-1678",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "f6eae44a3d05b6515a59651e6bed8b6dde689aec",
    "short_hash": "f6eae44a",
    "vulnerableMethods_before": [
      {
        "filename": "mount.cifs.c",
        "method_name": "vulnerable_function",
        "raw_code": "add_mtab(char *devname, char *mountpoint, unsigned long flags, const char *fstype)\n{\n\tint rc = 0;\n\tuid_t uid;\n\tchar *mount_user = NULL;\n\tstruct mntent mountent;\n\tFILE *pmntfile;\n\tsigset_t mask, oldmask;\n\n\tuid = getuid();\n\tif (uid != 0)\n\t\tmount_user = getusername(uid);\n\n\t/*\n\t * Set the real uid to the effective uid. This prevents unprivileged\n\t * users from sending signals to this process, though ^c on controlling\n\t * terminal should still work.\n\t */\n\trc = setreuid(geteuid(), -1);\n\tif (rc != 0) {\n\t\tfprintf(stderr, \"Unable to set real uid to effective uid: %s\\n\",\n\t\t\t\tstrerror(errno));\n\t\treturn EX_FILEIO;\n\t}\n\n\trc = sigfillset(&mask);\n\tif (rc) {\n\t\tfprintf(stderr, \"Unable to set filled signal mask\\n\");\n\t\treturn EX_FILEIO;\n\t}\n\n\trc = sigprocmask(SIG_SETMASK, &mask, &oldmask);\n\tif (rc) {\n\t\tfprintf(stderr, \"Unable to make process ignore signals\\n\");\n\t\treturn EX_FILEIO;\n\t}\n\n\trc = toggle_dac_capability(1, 1);\n\tif (rc)\n\t\treturn EX_FILEIO;\n\n\tatexit(unlock_mtab);\n\trc = lock_mtab();\n\tif (rc) {\n\t\tfprintf(stderr, \"cannot lock mtab\");\n\t\trc = EX_FILEIO;\n\t\tgoto add_mtab_exit;\n\t}\n\n\tpmntfile = setmntent(MOUNTED, \"a+\");\n\tif (!pmntfile) {\n\t\tfprintf(stderr, \"could not update mount table\\n\");\n\t\tunlock_mtab();\n\t\trc = EX_FILEIO;\n\t\tgoto add_mtab_exit;\n\t}\n\n\tmountent.mnt_fsname = devname;\n\tmountent.mnt_dir = mountpoint;\n\tmountent.mnt_type = (char *)(void *)fstype;\n\tmountent.mnt_opts = (char *)calloc(MTAB_OPTIONS_LEN, 1);\n\tif (mountent.mnt_opts) {\n\t\tif (flags & MS_RDONLY)\n\t\t\tstrlcat(mountent.mnt_opts, \"ro\", MTAB_OPTIONS_LEN);\n\t\telse\n\t\t\tstrlcat(mountent.mnt_opts, \"rw\", MTAB_OPTIONS_LEN);\n\n\t\tif (flags & MS_MANDLOCK)\n\t\t\tstrlcat(mountent.mnt_opts, \",mand\", MTAB_OPTIONS_LEN);\n\t\tif (flags & MS_NOEXEC)\n\t\t\tstrlcat(mountent.mnt_opts, \",noexec\", MTAB_OPTIONS_LEN);\n\t\tif (flags & MS_NOSUID)\n\t\t\tstrlcat(mountent.mnt_opts, \",nosuid\", MTAB_OPTIONS_LEN);\n\t\tif (flags & MS_NODEV)\n\t\t\tstrlcat(mountent.mnt_opts, \",nodev\", MTAB_OPTIONS_LEN);\n\t\tif (flags & MS_SYNCHRONOUS)\n\t\t\tstrlcat(mountent.mnt_opts, \",sync\", MTAB_OPTIONS_LEN);\n\t\tif (mount_user) {\n\t\t\tstrlcat(mountent.mnt_opts, \",user=\", MTAB_OPTIONS_LEN);\n\t\t\tstrlcat(mountent.mnt_opts, mount_user,\n\t\t\t\tMTAB_OPTIONS_LEN);\n\t\t}\n\t}\n\tmountent.mnt_freq = 0;\n\tmountent.mnt_passno = 0;\n\trc = addmntent(pmntfile, &mountent);\n\tif (rc) {\n\t\tfprintf(stderr, \"unable to add mount entry to mtab\\n\");\n\t\trc = EX_FILEIO;\n\t}\n\tendmntent(pmntfile);\n\tunlock_mtab();\n\tSAFE_FREE(mountent.mnt_opts);\nadd_mtab_exit:\n\ttoggle_dac_capability(1, 0);\n\tsigprocmask(SIG_SETMASK, &oldmask, NULL);\n\n\treturn rc;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "mount.cifs.c",
        "method_name": "fixed_function",
        "raw_code": "add_mtab(char *devname, char *mountpoint, unsigned long flags, const char *fstype)\n{\n\tint rc = 0, tmprc, fd;\n\tuid_t uid;\n\tchar *mount_user = NULL;\n\tstruct mntent mountent;\n\tstruct stat statbuf;\n\tFILE *pmntfile;\n\tsigset_t mask, oldmask;\n\n\tuid = getuid();\n\tif (uid != 0)\n\t\tmount_user = getusername(uid);\n\n\t/*\n\t * Set the real uid to the effective uid. This prevents unprivileged\n\t * users from sending signals to this process, though ^c on controlling\n\t * terminal should still work.\n\t */\n\trc = setreuid(geteuid(), -1);\n\tif (rc != 0) {\n\t\tfprintf(stderr, \"Unable to set real uid to effective uid: %s\\n\",\n\t\t\t\tstrerror(errno));\n\t\treturn EX_FILEIO;\n\t}\n\n\trc = sigfillset(&mask);\n\tif (rc) {\n\t\tfprintf(stderr, \"Unable to set filled signal mask\\n\");\n\t\treturn EX_FILEIO;\n\t}\n\n\trc = sigprocmask(SIG_SETMASK, &mask, &oldmask);\n\tif (rc) {\n\t\tfprintf(stderr, \"Unable to make process ignore signals\\n\");\n\t\treturn EX_FILEIO;\n\t}\n\n\trc = toggle_dac_capability(1, 1);\n\tif (rc)\n\t\treturn EX_FILEIO;\n\n\tatexit(unlock_mtab);\n\trc = lock_mtab();\n\tif (rc) {\n\t\tfprintf(stderr, \"cannot lock mtab\");\n\t\trc = EX_FILEIO;\n\t\tgoto add_mtab_exit;\n\t}\n\n\tpmntfile = setmntent(MOUNTED, \"a+\");\n\tif (!pmntfile) {\n\t\tfprintf(stderr, \"could not update mount table\\n\");\n\t\tunlock_mtab();\n\t\trc = EX_FILEIO;\n\t\tgoto add_mtab_exit;\n\t}\n\n\tfd = fileno(pmntfile);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"mntent does not appear to be valid\\n\");\n\t\tunlock_mtab();\n\t\trc = EX_FILEIO;\n\t\tgoto add_mtab_exit;\n\t}\n\n\trc = fstat(fd, &statbuf);\n\tif (rc != 0) {\n\t\tfprintf(stderr, \"unable to fstat open mtab\\n\");\n\t\tendmntent(pmntfile);\n\t\tunlock_mtab();\n\t\trc = EX_FILEIO;\n\t\tgoto add_mtab_exit;\n\t}\n\n\tmountent.mnt_fsname = devname;\n\tmountent.mnt_dir = mountpoint;\n\tmountent.mnt_type = (char *)(void *)fstype;\n\tmountent.mnt_opts = (char *)calloc(MTAB_OPTIONS_LEN, 1);\n\tif (mountent.mnt_opts) {\n\t\tif (flags & MS_RDONLY)\n\t\t\tstrlcat(mountent.mnt_opts, \"ro\", MTAB_OPTIONS_LEN);\n\t\telse\n\t\t\tstrlcat(mountent.mnt_opts, \"rw\", MTAB_OPTIONS_LEN);\n\n\t\tif (flags & MS_MANDLOCK)\n\t\t\tstrlcat(mountent.mnt_opts, \",mand\", MTAB_OPTIONS_LEN);\n\t\tif (flags & MS_NOEXEC)\n\t\t\tstrlcat(mountent.mnt_opts, \",noexec\", MTAB_OPTIONS_LEN);\n\t\tif (flags & MS_NOSUID)\n\t\t\tstrlcat(mountent.mnt_opts, \",nosuid\", MTAB_OPTIONS_LEN);\n\t\tif (flags & MS_NODEV)\n\t\t\tstrlcat(mountent.mnt_opts, \",nodev\", MTAB_OPTIONS_LEN);\n\t\tif (flags & MS_SYNCHRONOUS)\n\t\t\tstrlcat(mountent.mnt_opts, \",sync\", MTAB_OPTIONS_LEN);\n\t\tif (mount_user) {\n\t\t\tstrlcat(mountent.mnt_opts, \",user=\", MTAB_OPTIONS_LEN);\n\t\t\tstrlcat(mountent.mnt_opts, mount_user,\n\t\t\t\tMTAB_OPTIONS_LEN);\n\t\t}\n\t}\n\tmountent.mnt_freq = 0;\n\tmountent.mnt_passno = 0;\n\trc = addmntent(pmntfile, &mountent);\n\tif (rc) {\n\t\tfprintf(stderr, \"unable to add mount entry to mtab\\n\");\n\t\tftruncate(fd, statbuf.st_size);\n\t\trc = EX_FILEIO;\n\t}\n\ttmprc = my_endmntent(pmntfile, statbuf.st_size);\n\tif (tmprc) {\n\t\tfprintf(stderr, \"error %d detected on close of mtab\\n\", tmprc);\n\t\trc = EX_FILEIO;\n\t}\n\tunlock_mtab();\n\tSAFE_FREE(mountent.mnt_opts);\nadd_mtab_exit:\n\ttoggle_dac_capability(1, 0);\n\tsigprocmask(SIG_SETMASK, &oldmask, NULL);\n\n\treturn rc;\n}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "clamav-devel",
    "cve_id": "CVE-2010-1311",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "224fee54dd6cd8933d7007331ec2bfca0398d4b4",
    "short_hash": "224fee54",
    "vulnerableMethods_before": [
      {
        "filename": "mspack.c",
        "method_name": "vulnerable_function",
        "raw_code": "int qtm_decompress(struct qtm_stream *qtm, off_t out_bytes) {\n  unsigned int frame_start, frame_end, window_posn, match_offset, range;\n  unsigned char *window, *i_ptr, *i_end, *runsrc, *rundest;\n  int i, j, selector, extra, sym, match_length, ret;\n  unsigned short H, L, C, symf;\n\n  register unsigned int bit_buffer;\n  register unsigned char bits_left;\n  unsigned char bits_needed, bit_run;\n\n  /* easy answers */\n  if (!qtm || (out_bytes < 0)) return CL_ENULLARG;\n  if (qtm->error) return qtm->error;\n\n  /* flush out any stored-up bytes before we begin */\n  i = qtm->o_end - qtm->o_ptr;\n  if ((off_t) i > out_bytes) i = (int) out_bytes;\n  if (i) {\n    if (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {\n      return qtm->error = ret;\n    }\n    qtm->o_ptr  += i;\n    out_bytes   -= i;\n  }\n  if (out_bytes == 0) return CL_SUCCESS;\n\n  /* restore local state */\n  QTM_RESTORE_BITS;\n  window = qtm->window;\n  window_posn = qtm->window_posn;\n  frame_start = qtm->frame_start;\n  H = qtm->H;\n  L = qtm->L;\n  C = qtm->C;\n\n  /* while we do not have enough decoded bytes in reserve: */\n  while ((qtm->o_end - qtm->o_ptr) < out_bytes) {\n\n    /* read header if necessary. Initialises H, L and C */\n    if (!qtm->header_read) {\n      H = 0xFFFF; L = 0; QTM_READ_BITS(C, 16);\n      qtm->header_read = 1;\n    }\n\n    /* decode more, at most up to to frame boundary */\n    frame_end = window_posn + (out_bytes - (qtm->o_end - qtm->o_ptr));\n    if ((frame_start + QTM_FRAME_SIZE) < frame_end) {\n      frame_end = frame_start + QTM_FRAME_SIZE;\n    }\n\n    while (window_posn < frame_end) {\n      QTM_GET_SYMBOL(qtm->model7, selector);\n      if (selector < 4) {\n\tstruct qtm_model *mdl = (selector == 0) ? &qtm->model0 :\n\t                        ((selector == 1) ? &qtm->model1 :\n\t\t\t\t((selector == 2) ? &qtm->model2 :\n                                                   &qtm->model3));\n\tQTM_GET_SYMBOL((*mdl), sym);\n\twindow[window_posn++] = sym;\n      }\n      else {\n\tswitch (selector) {\n\tcase 4: /* selector 4 = fixed length match (3 bytes) */\n\t  QTM_GET_SYMBOL(qtm->model4, sym);\n\t  QTM_READ_BITS(extra, qtm->extra_bits[sym]);\n\t  match_offset = qtm->position_base[sym] + extra + 1;\n\t  match_length = 3;\n\t  break;\n\n\tcase 5: /* selector 5 = fixed length match (4 bytes) */\n\t  QTM_GET_SYMBOL(qtm->model5, sym);\n\t  QTM_READ_BITS(extra, qtm->extra_bits[sym]);\n\t  match_offset = qtm->position_base[sym] + extra + 1;\n\t  match_length = 4;\n\t  break;\n\n\tcase 6: /* selector 6 = variable length match */\n\t  QTM_GET_SYMBOL(qtm->model6len, sym);\n\t  QTM_READ_BITS(extra, qtm->length_extra[sym]);\n\t  match_length = qtm->length_base[sym] + extra + 5;\n\n\t  QTM_GET_SYMBOL(qtm->model6, sym);\n\t  QTM_READ_BITS(extra, qtm->extra_bits[sym]);\n\t  match_offset = qtm->position_base[sym] + extra + 1;\n\t  break;\n\n\tdefault:\n\t  /* should be impossible, model7 can only return 0-6 */\n\t  return qtm->error = CL_EFORMAT;\n\t}\n\n\trundest = &window[window_posn];\n\ti = match_length;\n\t/* does match offset wrap the window? */\n\tif (match_offset > window_posn) {\n\t  /* j = length from match offset to end of window */\n\t  j = match_offset - window_posn;\n\t  if (j > (int) qtm->window_size) {\n\t    cli_dbgmsg(\"qtm_decompress: match offset beyond window boundaries\\n\");\n\t    return qtm->error = CL_EFORMAT;\n\t  }\n\t  runsrc = &window[qtm->window_size - j];\n\t  if (j < i) {\n\t    /* if match goes over the window edge, do two copy runs */\n\t    i -= j; while (j-- > 0) *rundest++ = *runsrc++;\n\t    runsrc = window;\n\t  }\n\t  while (i-- > 0) *rundest++ = *runsrc++;\n\t}\n\telse {\n\t  runsrc = rundest - match_offset;\n\t  if(i > (int) (qtm->window_size - window_posn))\n\t    i = qtm->window_size - window_posn;\n\t  while (i-- > 0) *rundest++ = *runsrc++;\n\t}\n\twindow_posn += match_length;\n      }\n    } /* while (window_posn < frame_end) */\n\n    qtm->o_end = &window[window_posn];\n\n    /* another frame completed? */\n    if ((window_posn - frame_start) >= QTM_FRAME_SIZE) {\n      if ((window_posn - frame_start) != QTM_FRAME_SIZE) {\n\tcli_dbgmsg(\"qtm_decompress: overshot frame alignment\\n\");\n\treturn qtm->error = CL_EFORMAT;\n      }\n\n      /* re-align input */\n      if (bits_left & 7) QTM_REMOVE_BITS(bits_left & 7);\n      do { QTM_READ_BITS(i, 8); } while (i != 0xFF);\n      qtm->header_read = 0;\n\n      /* window wrap? */\n      if (window_posn == qtm->window_size) {\n\t/* flush all currently stored data */\n\ti = (qtm->o_end - qtm->o_ptr);\n\tif (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {\n\t  return qtm->error = ret;\n\t}\n\tout_bytes -= i;\n\tqtm->o_ptr = &window[0];\n\tqtm->o_end = &window[0];\n\twindow_posn = 0;\n      }\n\n      frame_start = window_posn;\n    }\n\n  } /* while (more bytes needed) */\n\n  if (out_bytes) {\n    i = (int) out_bytes;\n    if (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {\n      return qtm->error = ret;\n    }\n    qtm->o_ptr += i;\n  }\n\n  /* store local state */\n  QTM_STORE_BITS;\n  qtm->window_posn = window_posn;\n  qtm->frame_start = frame_start;\n  qtm->H = H;\n  qtm->L = L;\n  qtm->C = C;\n\n  return CL_SUCCESS;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "mspack.c",
        "method_name": "fixed_function",
        "raw_code": "int qtm_decompress(struct qtm_stream *qtm, off_t out_bytes) {\n  unsigned int frame_start, frame_end, window_posn, match_offset, range;\n  unsigned char *window, *i_ptr, *i_end, *runsrc, *rundest;\n  int i, j, selector, extra, sym, match_length, ret;\n  unsigned short H, L, C, symf;\n\n  register unsigned int bit_buffer;\n  register unsigned char bits_left;\n  unsigned char bits_needed, bit_run;\n\n  /* easy answers */\n  if (!qtm || (out_bytes < 0)) return CL_ENULLARG;\n  if (qtm->error) return qtm->error;\n\n  /* flush out any stored-up bytes before we begin */\n  i = qtm->o_end - qtm->o_ptr;\n  if ((off_t) i > out_bytes) i = (int) out_bytes;\n  if (i) {\n    if (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {\n      return qtm->error = ret;\n    }\n    qtm->o_ptr  += i;\n    out_bytes   -= i;\n  }\n  if (out_bytes == 0) return CL_SUCCESS;\n\n  /* restore local state */\n  QTM_RESTORE_BITS;\n  window = qtm->window;\n  window_posn = qtm->window_posn;\n  frame_start = qtm->frame_start;\n  H = qtm->H;\n  L = qtm->L;\n  C = qtm->C;\n\n  /* while we do not have enough decoded bytes in reserve: */\n  while ((qtm->o_end - qtm->o_ptr) < out_bytes) {\n\n    /* read header if necessary. Initialises H, L and C */\n    if (!qtm->header_read) {\n      H = 0xFFFF; L = 0; QTM_READ_BITS(C, 16);\n      qtm->header_read = 1;\n    }\n\n    /* decode more, at most up to to frame boundary */\n    frame_end = window_posn + (out_bytes - (qtm->o_end - qtm->o_ptr));\n    if ((frame_start + QTM_FRAME_SIZE) < frame_end) {\n      frame_end = frame_start + QTM_FRAME_SIZE;\n    }\n\n    while (window_posn < frame_end) {\n      QTM_GET_SYMBOL(qtm->model7, selector);\n      if (selector < 4) {\n\tstruct qtm_model *mdl = (selector == 0) ? &qtm->model0 :\n\t                        ((selector == 1) ? &qtm->model1 :\n\t\t\t\t((selector == 2) ? &qtm->model2 :\n                                                   &qtm->model3));\n\tQTM_GET_SYMBOL((*mdl), sym);\n\twindow[window_posn++] = sym;\n      }\n      else {\n\tswitch (selector) {\n\tcase 4: /* selector 4 = fixed length match (3 bytes) */\n\t  QTM_GET_SYMBOL(qtm->model4, sym);\n\t  QTM_READ_BITS(extra, qtm->extra_bits[sym]);\n\t  match_offset = qtm->position_base[sym] + extra + 1;\n\t  match_length = 3;\n\t  break;\n\n\tcase 5: /* selector 5 = fixed length match (4 bytes) */\n\t  QTM_GET_SYMBOL(qtm->model5, sym);\n\t  QTM_READ_BITS(extra, qtm->extra_bits[sym]);\n\t  match_offset = qtm->position_base[sym] + extra + 1;\n\t  match_length = 4;\n\t  break;\n\n\tcase 6: /* selector 6 = variable length match */\n\t  QTM_GET_SYMBOL(qtm->model6len, sym);\n\t  QTM_READ_BITS(extra, qtm->length_extra[sym]);\n\t  match_length = qtm->length_base[sym] + extra + 5;\n\n\t  QTM_GET_SYMBOL(qtm->model6, sym);\n\t  QTM_READ_BITS(extra, qtm->extra_bits[sym]);\n\t  match_offset = qtm->position_base[sym] + extra + 1;\n\t  break;\n\n\tdefault:\n\t  /* should be impossible, model7 can only return 0-6 */\n\t  return qtm->error = CL_EFORMAT;\n\t}\n\n\tif (window_posn + match_length > qtm->window_size) {\n\t  cli_dbgmsg(\"qtm_decompress: match ran over window wrap\\n\");\n\t  return qtm->error = CL_EFORMAT;\n\t}\n\n\trundest = &window[window_posn];\n\ti = match_length;\n\t/* does match offset wrap the window? */\n\tif (match_offset > window_posn) {\n\t  /* j = length from match offset to end of window */\n\t  j = match_offset - window_posn;\n\t  if (j > (int) qtm->window_size) {\n\t    cli_dbgmsg(\"qtm_decompress: match offset beyond window boundaries\\n\");\n\t    return qtm->error = CL_EFORMAT;\n\t  }\n\t  runsrc = &window[qtm->window_size - j];\n\t  if (j < i) {\n\t    /* if match goes over the window edge, do two copy runs */\n\t    i -= j; while (j-- > 0) *rundest++ = *runsrc++;\n\t    runsrc = window;\n\t  }\n\t  while (i-- > 0) *rundest++ = *runsrc++;\n\t}\n\telse {\n\t  runsrc = rundest - match_offset;\n\t  if(i > (int) (qtm->window_size - window_posn))\n\t    i = qtm->window_size - window_posn;\n\t  while (i-- > 0) *rundest++ = *runsrc++;\n\t}\n\twindow_posn += match_length;\n      }\n    } /* while (window_posn < frame_end) */\n\n    qtm->o_end = &window[window_posn];\n\n    /* another frame completed? */\n    if ((window_posn - frame_start) >= QTM_FRAME_SIZE) {\n      if ((window_posn - frame_start) != QTM_FRAME_SIZE) {\n\tcli_dbgmsg(\"qtm_decompress: overshot frame alignment\\n\");\n\treturn qtm->error = CL_EFORMAT;\n      }\n\n      /* re-align input */\n      if (bits_left & 7) QTM_REMOVE_BITS(bits_left & 7);\n      do { QTM_READ_BITS(i, 8); } while (i != 0xFF);\n      qtm->header_read = 0;\n\n      /* window wrap? */\n      if (window_posn == qtm->window_size) {\n\t/* flush all currently stored data */\n\ti = (qtm->o_end - qtm->o_ptr);\n\tif (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {\n\t  return qtm->error = ret;\n\t}\n\tout_bytes -= i;\n\tqtm->o_ptr = &window[0];\n\tqtm->o_end = &window[0];\n\twindow_posn = 0;\n      }\n\n      frame_start = window_posn;\n    }\n\n  } /* while (more bytes needed) */\n\n  if (out_bytes) {\n    i = (int) out_bytes;\n    if (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {\n      return qtm->error = ret;\n    }\n    qtm->o_ptr += i;\n  }\n\n  /* store local state */\n  QTM_STORE_BITS;\n  qtm->window_posn = window_posn;\n  qtm->frame_start = frame_start;\n  qtm->H = H;\n  qtm->L = L;\n  qtm->C = C;\n\n  return CL_SUCCESS;\n}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "JUCE",
    "cve_id": "CVE-2021-23521",
    "cwe_list": [
      "CWE-59"
    ],
    "commit_hash": "2e874e80cba0152201aff6a4d0dc407997d10a7f",
    "short_hash": "2e874e80",
    "vulnerableMethods_before": [
      {
        "filename": "None",
        "method_name": "vulnerable_function",
        "raw_code": "Result ZipFile::uncompressEntry (int index, const File& targetDirectory, bool shouldOverwriteFiles)\r\n{\r\n    auto* zei = entries.getUnchecked (index);\r\n\r\n   #if JUCE_WINDOWS\r\n    auto entryPath = zei->entry.filename;\r\n   #else\r\n    auto entryPath = zei->entry.filename.replaceCharacter ('\\\\', '/');\r\n   #endif\r\n\r\n    if (entryPath.isEmpty())\r\n        return Result::ok();\r\n\r\n    auto targetFile = targetDirectory.getChildFile (entryPath);\r\n\r\n    if (entryPath.endsWithChar ('/') || entryPath.endsWithChar ('\\\\'))\r\n        return targetFile.createDirectory(); // (entry is a directory, not a file)\r\n\r\n    std::unique_ptr<InputStream> in (createStreamForEntry (index));\r\n\r\n    if (in == nullptr)\r\n        return Result::fail (\"Failed to open the zip file for reading\");\r\n\r\n    if (targetFile.exists())\r\n    {\r\n        if (! shouldOverwriteFiles)\r\n            return Result::ok();\r\n\r\n        if (! targetFile.deleteFile())\r\n            return Result::fail (\"Failed to write to target file: \" + targetFile.getFullPathName());\r\n    }\r\n\r\n    if (! targetFile.getParentDirectory().createDirectory())\r\n        return Result::fail (\"Failed to create target folder: \" + targetFile.getParentDirectory().getFullPathName());\r\n\r\n    if (zei->entry.isSymbolicLink)\r\n    {\r\n        String originalFilePath (in->readEntireStreamAsString()\r\n                                    .replaceCharacter (L'/', File::getSeparatorChar()));\r\n\r\n        if (! File::createSymbolicLink (targetFile, originalFilePath, true))\r\n            return Result::fail (\"Failed to create symbolic link: \" + originalFilePath);\r\n    }\r\n    else\r\n    {\r\n        FileOutputStream out (targetFile);\r\n\r\n        if (out.failedToOpen())\r\n            return Result::fail (\"Failed to write to target file: \" + targetFile.getFullPathName());\r\n\r\n        out << *in;\r\n    }\r\n\r\n    targetFile.setCreationTime (zei->entry.fileTime);\r\n    targetFile.setLastModificationTime (zei->entry.fileTime);\r\n    targetFile.setLastAccessTime (zei->entry.fileTime);\r\n\r\n    return Result::ok();\r\n}\r",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "None",
        "method_name": "fixed_function",
        "raw_code": "Result ZipFile::uncompressEntry (int index, const File& targetDirectory, OverwriteFiles overwriteFiles, FollowSymlinks followSymlinks)\r\n{\r\n    auto* zei = entries.getUnchecked (index);\r\n\r\n   #if JUCE_WINDOWS\r\n    auto entryPath = zei->entry.filename;\r\n   #else\r\n    auto entryPath = zei->entry.filename.replaceCharacter ('\\\\', '/');\r\n   #endif\r\n\r\n    if (entryPath.isEmpty())\r\n        return Result::ok();\r\n\r\n    auto targetFile = targetDirectory.getChildFile (entryPath);\r\n\r\n    if (! targetFile.isAChildOf (targetDirectory))\r\n        return Result::fail (\"Entry \" + entryPath + \" is outside the target directory\");\r\n\r\n    if (entryPath.endsWithChar ('/') || entryPath.endsWithChar ('\\\\'))\r\n        return targetFile.createDirectory(); // (entry is a directory, not a file)\r\n\r\n    std::unique_ptr<InputStream> in (createStreamForEntry (index));\r\n\r\n    if (in == nullptr)\r\n        return Result::fail (\"Failed to open the zip file for reading\");\r\n\r\n    if (targetFile.exists())\r\n    {\r\n        if (overwriteFiles == OverwriteFiles::no)\r\n            return Result::ok();\r\n\r\n        if (! targetFile.deleteFile())\r\n            return Result::fail (\"Failed to write to target file: \" + targetFile.getFullPathName());\r\n    }\r\n\r\n    if (followSymlinks == FollowSymlinks::no && hasSymbolicPart (targetDirectory, targetFile.getParentDirectory()))\r\n        return Result::fail (\"Parent directory leads through symlink for target file: \" + targetFile.getFullPathName());\r\n\r\n    if (! targetFile.getParentDirectory().createDirectory())\r\n        return Result::fail (\"Failed to create target folder: \" + targetFile.getParentDirectory().getFullPathName());\r\n\r\n    if (zei->entry.isSymbolicLink)\r\n    {\r\n        String originalFilePath (in->readEntireStreamAsString()\r\n                                    .replaceCharacter (L'/', File::getSeparatorChar()));\r\n\r\n        if (! File::createSymbolicLink (targetFile, originalFilePath, true))\r\n            return Result::fail (\"Failed to create symbolic link: \" + originalFilePath);\r\n    }\r\n    else\r\n    {\r\n        FileOutputStream out (targetFile);\r\n\r\n        if (out.failedToOpen())\r\n            return Result::fail (\"Failed to write to target file: \" + targetFile.getFullPathName());\r\n\r\n        out << *in;\r\n    }\r\n\r\n    targetFile.setCreationTime (zei->entry.fileTime);\r\n    targetFile.setLastModificationTime (zei->entry.fileTime);\r\n    targetFile.setLastAccessTime (zei->entry.fileTime);\r\n\r\n    return Result::ok();\r\n}\r",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "FFmpeg",
    "cve_id": "CVE-2021-38171",
    "cwe_list": [
      "CWE-252"
    ],
    "commit_hash": "9ffa49496d1aae4cbbb387aac28a9e061a6ab0a6",
    "short_hash": "9ffa4949",
    "vulnerableMethods_before": [
      {
        "filename": "None",
        "method_name": "vulnerable_function",
        "raw_code": "static int adts_decode_extradata(AVFormatContext *s, ADTSContext *adts, const uint8_t *buf, int size)\n{\n    GetBitContext gb;\n    PutBitContext pb;\n    MPEG4AudioConfig m4ac;\n    int off;\n\n    init_get_bits(&gb, buf, size * 8);\n    off = avpriv_mpeg4audio_get_config2(&m4ac, buf, size, 1, s);\n    if (off < 0)\n        return off;\n    skip_bits_long(&gb, off);\n    adts->objecttype        = m4ac.object_type - 1;\n    adts->sample_rate_index = m4ac.sampling_index;\n    adts->channel_conf      = m4ac.chan_config;\n\n    if (adts->objecttype > 3U) {\n        av_log(s, AV_LOG_ERROR, \"MPEG-4 AOT %d is not allowed in ADTS\\n\", adts->objecttype+1);\n        return AVERROR_INVALIDDATA;\n    }\n    if (adts->sample_rate_index == 15) {\n        av_log(s, AV_LOG_ERROR, \"Escape sample rate index illegal in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (get_bits(&gb, 1)) {\n        av_log(s, AV_LOG_ERROR, \"960/120 MDCT window is not allowed in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (get_bits(&gb, 1)) {\n        av_log(s, AV_LOG_ERROR, \"Scalable configurations are not allowed in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (get_bits(&gb, 1)) {\n        av_log(s, AV_LOG_ERROR, \"Extension flag is not allowed in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (!adts->channel_conf) {\n        init_put_bits(&pb, adts->pce_data, MAX_PCE_SIZE);\n\n        put_bits(&pb, 3, 5); //ID_PCE\n        adts->pce_size = (ff_copy_pce_data(&pb, &gb) + 3) / 8;\n        flush_put_bits(&pb);\n    }\n\n    adts->write_adts = 1;\n\n    return 0;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "None",
        "method_name": "fixed_function",
        "raw_code": "static int adts_decode_extradata(AVFormatContext *s, ADTSContext *adts, const uint8_t *buf, int size)\n{\n    GetBitContext gb;\n    PutBitContext pb;\n    MPEG4AudioConfig m4ac;\n    int off, ret;\n\n    ret = init_get_bits8(&gb, buf, size);\n    if (ret < 0)\n        return ret;\n    off = avpriv_mpeg4audio_get_config2(&m4ac, buf, size, 1, s);\n    if (off < 0)\n        return off;\n    skip_bits_long(&gb, off);\n    adts->objecttype        = m4ac.object_type - 1;\n    adts->sample_rate_index = m4ac.sampling_index;\n    adts->channel_conf      = m4ac.chan_config;\n\n    if (adts->objecttype > 3U) {\n        av_log(s, AV_LOG_ERROR, \"MPEG-4 AOT %d is not allowed in ADTS\\n\", adts->objecttype+1);\n        return AVERROR_INVALIDDATA;\n    }\n    if (adts->sample_rate_index == 15) {\n        av_log(s, AV_LOG_ERROR, \"Escape sample rate index illegal in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (get_bits(&gb, 1)) {\n        av_log(s, AV_LOG_ERROR, \"960/120 MDCT window is not allowed in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (get_bits(&gb, 1)) {\n        av_log(s, AV_LOG_ERROR, \"Scalable configurations are not allowed in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (get_bits(&gb, 1)) {\n        av_log(s, AV_LOG_ERROR, \"Extension flag is not allowed in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (!adts->channel_conf) {\n        init_put_bits(&pb, adts->pce_data, MAX_PCE_SIZE);\n\n        put_bits(&pb, 3, 5); //ID_PCE\n        adts->pce_size = (ff_copy_pce_data(&pb, &gb) + 3) / 8;\n        flush_put_bits(&pb);\n    }\n\n    adts->write_adts = 1;\n\n    return 0;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"libavutil/opt.h\"\n#include \"apetag.h\"\n#include \"libavcodec/put_bits.h\"\n#include \"libavcodec/codec_par.h\"\n#include \"avformat.h\"\n#include \"libavcodec/get_bits.h\"\n#include \"id3v2.h\"\n#include \"libavcodec/packet.h\"\n#include \"libavcodec/codec_id.h\"\n#include \"libavcodec/mpeg4audio.h\"\n\n// Type Definitions:\n// AVFormatContext:\ntypedef struct AVFormatContext {\n    /**\n     * A class for logging and @ref avoptions. Set by avformat_alloc_context().\n     * Exports (de)muxer private options if they exist.\n     */\n    const AVClass *av_class;\n\n    /**\n     * The input container format.\n     *\n     * Demuxing only, set by avformat_open_input().\n     */\n    const struct AVInputFormat *iformat;\n\n    /**\n     * The output container format.\n     *\n     * Muxing only, must be set by the caller before avformat_write_header().\n     */\n    const struct AVOutputFormat *oformat;\n\n    /**\n     * Format private data. This is an AVOptions-enabled struct\n     * if and only if iformat/oformat.priv_class is not NULL.\n     *\n     * - muxing: set by avformat_write_header()\n     * - demuxing: set by avformat_open_input()\n     */\n    void *priv_data;\n\n    /**\n     * I/O context.\n     *\n     * - demuxing: either set by the user before avformat_open_input() (then\n     *             the user must close it manually) or set by avformat_...\n\n// ADTSContext:\ntypedef struct ADTSContext {\n    AVClass *class;\n    int write_adts;\n    int objecttype;\n    int sample_rate_index;\n    int channel_conf;\n    int pce_size;\n    int apetag;\n    int id3v2tag;\n    int mpeg_id;\n    uint8_t pce_data[MAX_PCE_SIZE];\n} ADTSContext;\n"
  },
  {
    "repository": "tensorflow",
    "cve_id": "CVE-2021-41206",
    "cwe_list": [
      "CWE-354"
    ],
    "commit_hash": "e7f497570abb6b4ae5af4970620cd880e4c0c904",
    "short_hash": "e7f49757",
    "vulnerableMethods_before": [
      {
        "filename": "conv_ops.cc",
        "method_name": "vulnerable_function",
        "raw_code": "  void operator()(OpKernelContext* ctx, const Tensor& input,\n                  const Tensor& filter, int row_stride, int col_stride,\n                  int row_dilation, int col_dilation, const Padding& padding,\n                  const std::vector<int64_t>& explicit_paddings, Tensor* output,\n                  TensorFormat data_format) {\n    DCHECK(data_format == FORMAT_NHWC)\n        << \"Grouped conv implementation only \"\n           \"supports NHWC tensor format for now.\";\n\n    const int64_t in_depth = input.dim_size(3);\n    const int64_t patch_depth = filter.dim_size(2);\n    const int64_t num_groups = in_depth / patch_depth;\n\n    // Shuffle input/filter tensors to have group as a leading dimension.\n    std::array<int64_t, 5> shuffle({3, 0, 1, 2, 4});\n\n    // Compute pre shuffle dimemnsions.\n    auto pre_shuffle = [&](const Tensor& tensor) -> std::array<int64, 5> {\n      return {tensor.dim_size(0), tensor.dim_size(1), tensor.dim_size(2),\n              num_groups, tensor.dim_size(3) / num_groups};\n    };\n\n    // Compute post shuffle dimemnsions.\n    auto post_shuffle = [&](const Tensor& tensor) -> std::array<int64, 5> {\n      return {num_groups, tensor.dim_size(0), tensor.dim_size(1),\n              tensor.dim_size(2), tensor.dim_size(3) / num_groups};\n    };\n\n    auto& device = ctx->eigen_device<CPUDevice>();\n\n    absl::BlockingCounter shuffles_completed(2);\n    auto on_shuffled = [&]() { shuffles_completed.DecrementCount(); };\n\n    // Shuffle input into temporary tensor.\n    Tensor input_shuffled(input.dtype(), TensorShape(post_shuffle(input)));\n    input_shuffled.tensor<T, 5>().device(device, on_shuffled) =\n        input.shaped<T, 5>(pre_shuffle(input)).shuffle(shuffle);\n\n    // Shuffle filter into temporary tensor.\n    Tensor filter_shuffled(filter.dtype(), TensorShape(post_shuffle(filter)));\n    filter_shuffled.tensor<T, 5>().device(device, on_shuffled) =\n        filter.shaped<T, 5>(pre_shuffle(filter)).shuffle(shuffle);\n\n    // Wait for the completion of input/filter shuffles.\n    shuffles_completed.Wait();\n\n    // Write group convolution results into temporary output tensor.\n    Tensor output_shuffled(output->dtype(), TensorShape(post_shuffle(*output)));\n\n    for (int64_t i = 0; i < num_groups; ++i) {\n      // TODO(ezhulenev): Run this loop using `parallelFor` (regular parallelFor\n      // will lead to deadlock, SpatialConvolution has to use async Eigen\n      // assignment). This requires small changes to Eigen to support async\n      // exeuction for tensor chipping operation.\n\n      // TODO(ezhulenev): Grouped convolution should also support 1x1 filter\n      // optimization.\n\n      auto input_slice = input_shuffled.tensor<T, 5>().template chip<0>(i);\n      auto filter_slice = filter_shuffled.tensor<T, 5>().template chip<0>(i);\n      auto output_slice = output_shuffled.tensor<T, 5>().template chip<0>(i);\n\n      if (padding == EXPLICIT) {\n        functor::SpatialConvolution<CPUDevice, T>()(\n            ctx->eigen_device<CPUDevice>(), output_slice, input_slice,\n            filter_slice, row_stride, col_stride, row_dilation, col_dilation,\n            static_cast<int>(explicit_paddings[2]),\n            static_cast<int>(explicit_paddings[3]),\n            static_cast<int>(explicit_paddings[4]),\n            static_cast<int>(explicit_paddings[5]));\n      } else {\n        functor::SpatialConvolution<CPUDevice, T>()(\n            ctx->eigen_device<CPUDevice>(), output_slice, input_slice,\n            filter_slice, row_stride, col_stride, row_dilation, col_dilation,\n            BrainPadding2EigenPadding(padding));\n      }\n    }\n\n    // Shuffle temporary output back into pre-shuffled shape.\n    std::array<int64_t, 5> rev_shuffle({1, 2, 3, 0, 4});\n    output->shaped<T, 5>(pre_shuffle(*output)).device(device) =\n        output_shuffled.tensor<T, 5>().shuffle(rev_shuffle);\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "conv_ops.cc",
        "method_name": "fixed_function",
        "raw_code": "  void operator()(OpKernelContext* ctx, const Tensor& input,\n                  const Tensor& filter, int row_stride, int col_stride,\n                  int row_dilation, int col_dilation, const Padding& padding,\n                  const std::vector<int64_t>& explicit_paddings, Tensor* output,\n                  TensorFormat data_format) {\n    DCHECK(data_format == FORMAT_NHWC)\n        << \"Grouped conv implementation only \"\n           \"supports NHWC tensor format for now.\";\n\n    const int64_t in_depth = input.dim_size(3);\n    const int64_t patch_depth = filter.dim_size(2);\n    const int64_t num_groups = in_depth / patch_depth;\n\n    // Shuffle input/filter tensors to have group as a leading dimension.\n    std::array<int64_t, 5> shuffle({3, 0, 1, 2, 4});\n\n    // Compute pre shuffle dimemnsions.\n    auto pre_shuffle = [&](const Tensor& tensor) -> std::array<int64, 5> {\n      return {tensor.dim_size(0), tensor.dim_size(1), tensor.dim_size(2),\n              num_groups, tensor.dim_size(3) / num_groups};\n    };\n\n    // Compute post shuffle dimemnsions.\n    auto post_shuffle = [&](const Tensor& tensor) -> std::array<int64, 5> {\n      return {num_groups, tensor.dim_size(0), tensor.dim_size(1),\n              tensor.dim_size(2), tensor.dim_size(3) / num_groups};\n    };\n\n    auto& device = ctx->eigen_device<CPUDevice>();\n\n    absl::BlockingCounter shuffles_completed(2);\n    auto on_shuffled = [&]() { shuffles_completed.DecrementCount(); };\n\n    // Shuffle input into temporary tensor.\n    Tensor input_shuffled;\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_temp(input.dtype(), TensorShape(post_shuffle(input)),\n                                &input_shuffled));\n    input_shuffled.tensor<T, 5>().device(device, on_shuffled) =\n        input.shaped<T, 5>(pre_shuffle(input)).shuffle(shuffle);\n\n    // Shuffle filter into temporary tensor.\n    Tensor filter_shuffled;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(filter.dtype(),\n                                           TensorShape(post_shuffle(filter)),\n                                           &filter_shuffled));\n    filter_shuffled.tensor<T, 5>().device(device, on_shuffled) =\n        filter.shaped<T, 5>(pre_shuffle(filter)).shuffle(shuffle);\n\n    // Wait for the completion of input/filter shuffles.\n    shuffles_completed.Wait();\n\n    // Write group convolution results into temporary output tensor.\n    Tensor output_shuffled;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(output->dtype(),\n                                           TensorShape(post_shuffle(*output)),\n                                           &output_shuffled));\n\n    for (int64_t i = 0; i < num_groups; ++i) {\n      // TODO(ezhulenev): Run this loop using `parallelFor` (regular parallelFor\n      // will lead to deadlock, SpatialConvolution has to use async Eigen\n      // assignment). This requires small changes to Eigen to support async\n      // exeuction for tensor chipping operation.\n\n      // TODO(ezhulenev): Grouped convolution should also support 1x1 filter\n      // optimization.\n\n      auto input_slice = input_shuffled.tensor<T, 5>().template chip<0>(i);\n      auto filter_slice = filter_shuffled.tensor<T, 5>().template chip<0>(i);\n      auto output_slice = output_shuffled.tensor<T, 5>().template chip<0>(i);\n\n      if (padding == EXPLICIT) {\n        functor::SpatialConvolution<CPUDevice, T>()(\n            ctx->eigen_device<CPUDevice>(), output_slice, input_slice,\n            filter_slice, row_stride, col_stride, row_dilation, col_dilation,\n            static_cast<int>(explicit_paddings[2]),\n            static_cast<int>(explicit_paddings[3]),\n            static_cast<int>(explicit_paddings[4]),\n            static_cast<int>(explicit_paddings[5]));\n      } else {\n        functor::SpatialConvolution<CPUDevice, T>()(\n            ctx->eigen_device<CPUDevice>(), output_slice, input_slice,\n            filter_slice, row_stride, col_stride, row_dilation, col_dilation,\n            BrainPadding2EigenPadding(padding));\n      }\n    }\n\n    // Shuffle temporary output back into pre-shuffled shape.\n    std::array<int64_t, 5> rev_shuffle({1, 2, 3, 0, 4});\n    output->shaped<T, 5>(pre_shuffle(*output)).device(device) =\n        output_shuffled.tensor<T, 5>().shuffle(rev_shuffle);\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "squirrel",
    "cve_id": "CVE-2022-30292",
    "cwe_list": [
      "CWE-703"
    ],
    "commit_hash": "a6413aa690e0bdfef648c68693349a7b878fe60d",
    "short_hash": "a6413aa6",
    "vulnerableMethods_before": [
      {
        "filename": "sqbaselib.cpp",
        "method_name": "vulnerable_function",
        "raw_code": "static SQInteger thread_call(HSQUIRRELVM v)\n{\n    SQObjectPtr o = stack_get(v,1);\n    if(sq_type(o) == OT_THREAD) {\n        SQInteger nparams = sq_gettop(v);\n        _thread(o)->Push(_thread(o)->_roottable);\n        for(SQInteger i = 2; i<(nparams+1); i++)\n            sq_move(_thread(o),v,i);\n        if(SQ_SUCCEEDED(sq_call(_thread(o),nparams,SQTrue,SQTrue))) {\n            sq_move(v,_thread(o),-1);\n            sq_pop(_thread(o),1);\n            return 1;\n        }\n        v->_lasterror = _thread(o)->_lasterror;\n        return SQ_ERROR;\n    }\n    return sq_throwerror(v,_SC(\"wrong parameter\"));\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "sqbaselib.cpp",
        "method_name": "fixed_function",
        "raw_code": "static SQInteger thread_call(HSQUIRRELVM v)\n{\n    SQObjectPtr o = stack_get(v,1);\n    if(sq_type(o) == OT_THREAD) {\n        SQInteger nparams = sq_gettop(v);\n        sq_reservestack(_thread(o), nparams + 3);\n        _thread(o)->Push(_thread(o)->_roottable);\n        for(SQInteger i = 2; i<(nparams+1); i++)\n            sq_move(_thread(o),v,i);\n        if(SQ_SUCCEEDED(sq_call(_thread(o),nparams,SQTrue,SQTrue))) {\n            sq_move(v,_thread(o),-1);\n            sq_pop(_thread(o),1);\n            return 1;\n        }\n        v->_lasterror = _thread(o)->_lasterror;\n        return SQ_ERROR;\n    }\n    return sq_throwerror(v,_SC(\"wrong parameter\"));\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"sqvm.h\"\n#include \"sqclosure.h\"\n#include <stdlib.h>\n#include <ctype.h>\n#include \"sqclass.h\"\n#include \"sqarray.h\"\n#include \"sqtable.h\"\n#include \"sqstring.h\"\n#include <stdarg.h>\n#include \"sqfuncproto.h\"\n#include \"sqpcheader.h\"\n\n// Type Definitions:\n// HSQUIRRELVM:\ntypedef struct SQVM* HSQUIRRELVM;\n\n// SQInteger:\ntypedef __int64 SQInteger;\n\n// SQInteger:\ntypedef long long SQInteger;\n\n// SQObjectPtr:\nstruct SQObjectPtr : public SQObject\n{\n    SQObjectPtr()\n    {\n        SQ_OBJECT_RAWINIT()\n        _type=OT_NULL;\n        _unVal.pUserPointer=NULL;\n    }\n    SQObjectPtr(const SQObjectPtr &o)\n    {\n        _type = o._type;\n        _unVal = o._unVal;\n        __AddRef(_type,_unVal);\n    }\n    SQObjectPtr(const SQObject &o)\n    {\n        _type = o._type;\n        _unVal = o._unVal;\n        __AddRef(_type,_unVal);\n    }\n    _REF_TYPE_DECL(OT_TABLE,SQTable,pTable)\n    _REF_TYPE_DECL(OT_CLASS,SQClass,pClass)\n    _REF_TYPE_DECL(OT_INSTANCE,SQInstance,pInstance)\n    _REF_TYPE_DECL(OT_ARRAY,SQArray,pArray)\n    _REF_TYPE_DECL(OT_CLOSURE,SQClosure,pClosure)\n    _REF_TYPE_DECL(OT_NATIVECLOSURE,SQNativeClosure,pNativeClosure)\n    _REF_TYPE_DECL(OT_OUTER,SQOuter,pOuter)\n    _REF_TYPE_DECL(OT_GENERATOR,SQGenerator,pGenerator)\n    _REF_TYPE_DECL(OT_STRING,SQString,pString)\n    _REF_TYPE_DECL(OT_USERDATA,SQUserData,pUserData)\n    _REF_TYPE_DECL(OT_WEAKREF,SQWeakRef,pWeakRef)\n    _REF_TYPE_DECL(OT_THR...\n\n// Called Methods (top 10):\n// _thread from squirrel/sqobject.h:\n<empty>\n"
  },
  {
    "repository": "tensorflow",
    "cve_id": "CVE-2022-23568",
    "cwe_list": [
      "CWE-190"
    ],
    "commit_hash": "a68f68061e263a88321c104a6c911fe5598050a8",
    "short_hash": "a68f6806",
    "vulnerableMethods_before": [
      {
        "filename": "sparse_tensors_map_ops.cc",
        "method_name": "vulnerable_function",
        "raw_code": "  void Compute(OpKernelContext* context) override {\n    const Tensor* input_indices;\n    const Tensor* input_values;\n    const Tensor* input_shape;\n    SparseTensorsMap* map;\n\n    OP_REQUIRES_OK(context, context->input(\"sparse_indices\", &input_indices));\n    OP_REQUIRES_OK(context, context->input(\"sparse_values\", &input_values));\n    OP_REQUIRES_OK(context, context->input(\"sparse_shape\", &input_shape));\n    OP_REQUIRES_OK(context, GetMap(context, true /* is_writing */, &map));\n\n    OP_REQUIRES(context, TensorShapeUtils::IsMatrix(input_indices->shape()),\n                errors::InvalidArgument(\n                    \"Input indices should be a matrix but received shape \",\n                    input_indices->shape().DebugString()));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_values->shape()),\n                errors::InvalidArgument(\n                    \"Input values should be a vector but received shape \",\n                    input_values->shape().DebugString()));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_shape->shape()),\n                errors::InvalidArgument(\n                    \"Input shape should be a vector but received shape \",\n                    input_shape->shape().DebugString()));\n    OP_REQUIRES(\n        context,\n        input_values->shape().dim_size(0) == input_indices->shape().dim_size(0),\n        errors::InvalidArgument(\n            \"Number of values must match first dimension of indices. \", \"Got \",\n            input_values->shape().dim_size(0),\n            \" values, indices shape: \", input_indices->shape().DebugString()));\n    OP_REQUIRES(\n        context,\n        input_shape->shape().dim_size(0) == input_indices->shape().dim_size(1),\n        errors::InvalidArgument(\n            \"Number of dimensions must match second dimension of indices. \",\n            \"Got \", input_shape->shape().dim_size(0),\n            \" dimensions, indices shape: \",\n            input_indices->shape().DebugString()));\n\n    int rank = input_shape->NumElements();\n\n    OP_REQUIRES(\n        context, rank > 1,\n        errors::InvalidArgument(\n            \"Rank of input SparseTensor should be > 1, but saw rank: \", rank));\n\n    auto input_shape_vec = input_shape->vec<int64_t>();\n    int new_num_elements = 1;\n    bool overflow_ocurred = false;\n    for (int i = 0; i < input_shape_vec.size(); i++) {\n      new_num_elements =\n          MultiplyWithoutOverflow(new_num_elements, input_shape_vec(i));\n      if (new_num_elements < 0) {\n        overflow_ocurred = true;\n        break;\n      }\n    }\n\n    OP_REQUIRES(\n        context, !overflow_ocurred,\n        errors::Internal(\"Encountered overflow from large input shape.\"));\n\n    TensorShape tensor_input_shape(input_shape_vec);\n    gtl::InlinedVector<int64_t, 8> std_order(rank);\n    std::iota(std_order.begin(), std_order.end(), 0);\n    SparseTensor input_st;\n    OP_REQUIRES_OK(context, SparseTensor::Create(*input_indices, *input_values,\n                                                 tensor_input_shape, std_order,\n                                                 &input_st));\n\n    const int64_t N = input_shape_vec(0);\n\n    Tensor sparse_handles(DT_INT64, TensorShape({N}));\n    auto sparse_handles_t = sparse_handles.vec<int64_t>();\n\n    OP_REQUIRES_OK(context, input_st.IndicesValid());\n\n    // We can generate the output shape proto string now, for all\n    // minibatch entries.\n    TensorShape output_shape;\n    OP_REQUIRES_OK(context, TensorShapeUtils::MakeShape(\n                                input_shape_vec.data() + 1,\n                                input_shape->NumElements() - 1, &output_shape));\n\n    // Get groups by minibatch dimension\n    std::unordered_set<int64_t> visited;\n    sparse::GroupIterable minibatch = input_st.group({0});\n    for (const auto& subset : minibatch) {\n      const int64_t b = subset.group()[0];\n      visited.insert(b);\n      OP_REQUIRES(\n          context, b > -1 && b < N,\n          errors::InvalidArgument(\n              \"Received unexpected column 0 value in input SparseTensor: \", b,\n              \" < 0 or >= N (= \", N, \")\"));\n\n      const auto indices = subset.indices();\n      const auto values = subset.values<T>();\n      const int64_t num_entries = values.size();\n\n      Tensor output_indices = Tensor(DT_INT64, {num_entries, rank - 1});\n      Tensor output_values = Tensor(DataTypeToEnum<T>::value, {num_entries});\n\n      auto output_indices_t = output_indices.matrix<int64_t>();\n      auto output_values_t = output_values.vec<T>();\n\n      for (int i = 0; i < num_entries; ++i) {\n        for (int d = 1; d < rank; ++d) {\n          output_indices_t(i, d - 1) = indices(i, d);\n        }\n        output_values_t(i) = values(i);\n      }\n\n      SparseTensor st_i;\n      OP_REQUIRES_OK(context,\n                     SparseTensor::Create(output_indices, output_values,\n                                          output_shape, &st_i));\n      int64_t handle;\n      OP_REQUIRES_OK(context, map->AddSparseTensor(context, st_i, &handle));\n      sparse_handles_t(b) = handle;\n    }\n\n    // Fill in any gaps; we must provide an empty ST for batch entries\n    // the grouper didn't find.\n    if (visited.size() < N) {\n      Tensor empty_indices(DT_INT64, {0, rank - 1});\n      Tensor empty_values(DataTypeToEnum<T>::value, {0});\n      SparseTensor empty_st;\n      OP_REQUIRES_OK(context, SparseTensor::Create(empty_indices, empty_values,\n                                                   output_shape, &empty_st));\n\n      for (int64_t b = 0; b < N; ++b) {\n        // We skipped this batch entry.\n        if (visited.find(b) == visited.end()) {\n          int64_t handle;\n          OP_REQUIRES_OK(context,\n                         map->AddSparseTensor(context, empty_st, &handle));\n          sparse_handles_t(b) = handle;\n        }\n      }\n    }\n\n    context->set_output(0, sparse_handles);\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "sparse_tensors_map_ops.cc",
        "method_name": "fixed_function",
        "raw_code": "  void Compute(OpKernelContext* context) override {\n    const Tensor* input_indices;\n    const Tensor* input_values;\n    const Tensor* input_shape;\n    SparseTensorsMap* map;\n\n    OP_REQUIRES_OK(context, context->input(\"sparse_indices\", &input_indices));\n    OP_REQUIRES_OK(context, context->input(\"sparse_values\", &input_values));\n    OP_REQUIRES_OK(context, context->input(\"sparse_shape\", &input_shape));\n    OP_REQUIRES_OK(context, GetMap(context, true /* is_writing */, &map));\n\n    OP_REQUIRES(context, TensorShapeUtils::IsMatrix(input_indices->shape()),\n                errors::InvalidArgument(\n                    \"Input indices should be a matrix but received shape \",\n                    input_indices->shape().DebugString()));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_values->shape()),\n                errors::InvalidArgument(\n                    \"Input values should be a vector but received shape \",\n                    input_values->shape().DebugString()));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_shape->shape()),\n                errors::InvalidArgument(\n                    \"Input shape should be a vector but received shape \",\n                    input_shape->shape().DebugString()));\n    OP_REQUIRES(\n        context,\n        input_values->shape().dim_size(0) == input_indices->shape().dim_size(0),\n        errors::InvalidArgument(\n            \"Number of values must match first dimension of indices. \", \"Got \",\n            input_values->shape().dim_size(0),\n            \" values, indices shape: \", input_indices->shape().DebugString()));\n    OP_REQUIRES(\n        context,\n        input_shape->shape().dim_size(0) == input_indices->shape().dim_size(1),\n        errors::InvalidArgument(\n            \"Number of dimensions must match second dimension of indices. \",\n            \"Got \", input_shape->shape().dim_size(0),\n            \" dimensions, indices shape: \",\n            input_indices->shape().DebugString()));\n\n    int rank = input_shape->NumElements();\n\n    OP_REQUIRES(\n        context, rank > 1,\n        errors::InvalidArgument(\n            \"Rank of input SparseTensor should be > 1, but saw rank: \", rank));\n\n    auto input_shape_vec = input_shape->vec<int64_t>();\n\n    TensorShape tensor_input_shape;\n    OP_REQUIRES_OK(context, TensorShape::BuildTensorShape(input_shape_vec,\n                                                          &tensor_input_shape));\n    gtl::InlinedVector<int64_t, 8> std_order(rank);\n    std::iota(std_order.begin(), std_order.end(), 0);\n    SparseTensor input_st;\n    OP_REQUIRES_OK(context, SparseTensor::Create(*input_indices, *input_values,\n                                                 tensor_input_shape, std_order,\n                                                 &input_st));\n\n    const int64_t N = input_shape_vec(0);\n\n    Tensor sparse_handles(DT_INT64, TensorShape({N}));\n    auto sparse_handles_t = sparse_handles.vec<int64_t>();\n\n    OP_REQUIRES_OK(context, input_st.IndicesValid());\n\n    // We can generate the output shape proto string now, for all\n    // minibatch entries.\n    TensorShape output_shape;\n    OP_REQUIRES_OK(context, TensorShapeUtils::MakeShape(\n                                input_shape_vec.data() + 1,\n                                input_shape->NumElements() - 1, &output_shape));\n\n    // Get groups by minibatch dimension\n    std::unordered_set<int64_t> visited;\n    sparse::GroupIterable minibatch = input_st.group({0});\n    for (const auto& subset : minibatch) {\n      const int64_t b = subset.group()[0];\n      visited.insert(b);\n      OP_REQUIRES(\n          context, b > -1 && b < N,\n          errors::InvalidArgument(\n              \"Received unexpected column 0 value in input SparseTensor: \", b,\n              \" < 0 or >= N (= \", N, \")\"));\n\n      const auto indices = subset.indices();\n      const auto values = subset.values<T>();\n      const int64_t num_entries = values.size();\n\n      Tensor output_indices = Tensor(DT_INT64, {num_entries, rank - 1});\n      Tensor output_values = Tensor(DataTypeToEnum<T>::value, {num_entries});\n\n      auto output_indices_t = output_indices.matrix<int64_t>();\n      auto output_values_t = output_values.vec<T>();\n\n      for (int i = 0; i < num_entries; ++i) {\n        for (int d = 1; d < rank; ++d) {\n          output_indices_t(i, d - 1) = indices(i, d);\n        }\n        output_values_t(i) = values(i);\n      }\n\n      SparseTensor st_i;\n      OP_REQUIRES_OK(context,\n                     SparseTensor::Create(output_indices, output_values,\n                                          output_shape, &st_i));\n      int64_t handle;\n      OP_REQUIRES_OK(context, map->AddSparseTensor(context, st_i, &handle));\n      sparse_handles_t(b) = handle;\n    }\n\n    // Fill in any gaps; we must provide an empty ST for batch entries\n    // the grouper didn't find.\n    if (visited.size() < N) {\n      Tensor empty_indices(DT_INT64, {0, rank - 1});\n      Tensor empty_values(DataTypeToEnum<T>::value, {0});\n      SparseTensor empty_st;\n      OP_REQUIRES_OK(context, SparseTensor::Create(empty_indices, empty_values,\n                                                   output_shape, &empty_st));\n\n      for (int64_t b = 0; b < N; ++b) {\n        // We skipped this batch entry.\n        if (visited.find(b) == visited.end()) {\n          int64_t handle;\n          OP_REQUIRES_OK(context,\n                         map->AddSparseTensor(context, empty_st, &handle));\n          sparse_handles_t(b) = handle;\n        }\n      }\n    }\n\n    context->set_output(0, sparse_handles);\n  }",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <algorithm>\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/resource_mgr.h\"\n#include <utility>\n#include \"tensorflow/core/lib/gtl/inlined_vector.h\"\n#include \"tensorflow/core/util/overflow.h\"\n#include <numeric>\n#include \"tensorflow/core/framework/types.h\"\n#include <vector>\n#include <unordered_map>\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/tensor_util.h\"\n#include \"tensorflow/core/util/sparse/sparse_tensor.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n\n// Type Definitions:\n// Status:\nusing Status = ::tensorflow::Status;\n\n// Tensor:\ntypedef Eigen::TensorMap<\n      Eigen::Tensor<T, NDIMS, Eigen::RowMajor, Eigen::DenseIndex>,\n      Eigen::Aligned>\n      Tensor;\n\n// DataTypeToEnum:\nstruct DataTypeToEnum<unsigned long> {\n  static DataType v() { return value; }\n  static DataType ref() { return MakeRefType(value); }\n  static constexpr DataType value =\n      sizeof(unsigned long) == 4 ? DT_UINT32 : DT_UINT64;\n}\n\n// Status:\nclass Status {\n public:\n  // Create a success status\n  Status() : status_(TF_NewStatus()) {}\n\n  // Return the status code\n  TF_Code code() const;\n\n  // Returns the error message in Status.\n  std::string message() const;\n\n  // Returns the error message in Status.\n  bool ok() const;\n\n  // Record <code, msg> in Status. Any previous information is lost.\n  // A common use is to clear a status: SetStatus(TF_OK, \"\");\n  void SetStatus(TF_Code code, const std::string& msg);\n\n  // Status is movable, but not copyable.\n  Status(Status&&) = default;\n  Status& operator=(Status&&) = default;\n\n private:\n  friend class RuntimeBuilder;\n  friend class Runtime;\n  friend class SavedModelAPI;\n  friend class TensorHandle;\n\n  // Wraps a TF_Status*, and takes ownership of it.\n  explicit Status(TF_Status* status) : status_(status) {}\n\n  // Status is not copyable\n  Status(const Status&) = delete;\n  Status& operator=(const Status&) = delete;\n\n  // Returns the TF_Status that this object wraps. This object\n  // ...\n\n// Tensor:\nclass Tensor {\n public:\n  using DeleterCallback = std::function<void(void*, size_t)>;\n\n  // Constructs a Tensor from user provided buffer.\n  //\n  // Params:\n  //  dtype - The dtype of the tensor's data.\n  //  shape - A shape vector, where each element corresponds to the size of\n  //          the tensor's corresponding dimension.\n  //  data - Pointer to a buffer of memory to construct a Tensor out of.\n  //  len - The length (in bytes) of `data`\n  //  deleter - A std::function to be called when the Tensor no longer needs the\n  //            memory in `data`. This can be used to free `data`, or\n  //            perhaps decrement a refcount associated with `data`, etc.\n  //  status - Set to OK on success and an error on failure.\n  // Returns:\n  // If an error occurred, status->ok() will be false, and the returned\n  // Tensor must not be used.\n  // TODO(bmzhao): Add Runtime as an argument to this function so we can swap to\n  // a TFRT backed tensor.\n  // TODO(bmzhao): Add benchmarks on ov...\n\n// iterator:\nclass iterator {\n   public:\n    typedef ssize_t difference_type;\n    typedef T value_type;\n    typedef const T* pointer;\n    typedef const T& reference;\n    typedef ::std::forward_iterator_tag iterator_category;\n\n    explicit iterator(uintptr_t rep)\n        : bigrep_(false), single_(reinterpret_cast<T>(rep)) {}\n    explicit iterator(typename BigRep::iterator iter)\n        : bigrep_(true), single_(nullptr), iter_(iter) {}\n\n    iterator& operator++() {\n      if (bigrep_) {\n        ++iter_;\n      } else {\n        DCHECK(single_ != nullptr);\n        single_ = nullptr;\n      }\n      return *this;\n    }\n    // maybe post-increment?\n\n    bool operator==(const iterator& other) const {\n      if (bigrep_) {\n        return iter_ == other.iter_;\n      } else {\n        return single_ == other.single_;\n      }\n    }\n    bool operator!=(const iterator& other) const { return !(*this == other); }\n\n    const T& operator*() const {\n      if (bigrep_) {\n        return *iter_;\n      } else {\n        DCH...\n\n// OpKernelContext:\nclass OpKernelContext {\n public:\n  // The first element of a WrappedAllocator is a \"base\" Allocator and\n  // the second element is that Allocator wrapped by a\n  // TrackingAllocator\n  typedef std::pair<Allocator*, TrackingAllocator*> WrappedAllocator;\n\n  // TODO(zhifengc): Do some cleanup of Params.\n  // The Params struct is passed in to initialize an OpKernelContext,\n  // and must outlive the OpKernelContext.\n  struct Params {\n    ~Params() { delete eigen_gpu_device; }\n\n    // The step being executed.\n    int64_t step_id = 0;\n\n    // Timestamp for the start of graph execution. Used for latency metrics.\n    int64_t start_time_usecs = 0;\n\n    // The deadline for the session to complete by. Empty if unspecified.\n    absl::optional<absl::Time> deadline;\n\n    // The op kernel being computed.\n    OpKernel* op_kernel = nullptr;\n\n    // The device on which the kernel is running.\n    DeviceBase* device = nullptr;\n\n    // The Eigen GPU device wrapper, which may include a per-op\n    // wrappe...\n\n// GroupIterable:\nclass GroupIterable {\n public:\n  typedef gtl::ArraySlice<int64_t> VarDimArray;\n\n  GroupIterable(Tensor ix, Tensor vals, int dims, const VarDimArray& group_dims)\n      : ix_(ix),\n        ix_matrix_(ix_.matrix<int64_t>()),\n        vals_(vals),\n        dims_(dims),\n        group_dims_(group_dims.begin(), group_dims.end()) {}\n\n  class IteratorStep;\n\n  IteratorStep begin() { return IteratorStep(this, 0); }\n  IteratorStep at(int64_t loc) {\n    CHECK(loc >= 0 && loc <= ix_.dim_size(0))\n        << \"loc provided must lie between 0 and \" << ix_.dim_size(0);\n    return IteratorStep(this, loc);\n  }\n  IteratorStep end() { return IteratorStep(this, ix_.dim_size(0)); }\n\n  template <typename TIX>\n  inline bool GroupMatches(const TIX& ix, int64_t loc_a, int64_t loc_b) const {\n    for (int d : group_dims_) {\n      if (ix(loc_a, d) != ix(loc_b, d)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  class IteratorStep {\n   public:\n    IteratorStep(GroupIterable* iter, int64_t loc)\n        : ...\n\n// SparseTensorsMap:\nclass SparseTensorsMap : public ResourceBase {\n public:\n  explicit SparseTensorsMap(const string& name) : name_(name), counter_(0) {}\n\n  string DebugString() const override { return \"A SparseTensorsMap\"; }\n\n  typedef struct {\n    Tensor indices;\n    Tensor values;\n    gtl::InlinedVector<int64_t, 8> shape;\n  } PersistentSparseTensor;\n\n  Status AddSparseTensor(OpKernelContext* ctx, const SparseTensor& sp,\n                         int64_t* handle) {\n    Tensor ix;\n    TF_RETURN_IF_ERROR(\n        ctx->allocate_temp(sp.indices().dtype(), sp.indices().shape(), &ix));\n    ix = sp.indices();\n\n    Tensor values;\n    TF_RETURN_IF_ERROR(ctx->allocate_temp(sp.indices().dtype(),\n                                          sp.indices().shape(), &values));\n    values = sp.values();\n    {\n      mutex_lock l(mu_);\n      int64_t unique_st_handle = counter_++;  // increment is guarded on purpose\n      sp_tensors_[unique_st_handle] = PersistentSparseTensor{\n          ix, values,\n          gtl::InlinedVec...\n\n// OpKernelContext:\ntensorflow.OpKernelContext.OpKernelContext:ANY(tensorflow.OpKernelContext.Params*)\n\n// SparseTensor:\nclass SparseTensor {\n public:\n  typedef typename gtl::ArraySlice<int64_t> VarDimArray;\n  typedef typename gtl::InlinedVector<int64_t, 8> ShapeArray;\n\n  static Status Create(Tensor ix, Tensor vals, const VarDimArray shape,\n                       const VarDimArray order, SparseTensor* result);\n\n  static Status Create(Tensor ix, Tensor vals, const TensorShape& shape,\n                       SparseTensor* result);\n\n  static Status Create(Tensor ix, Tensor vals, const VarDimArray shape,\n                       SparseTensor* result);\n\n  static Status Create(Tensor ix, Tensor vals, const TensorShape& shape,\n                       const VarDimArray order, SparseTensor* result);\n\n  SparseTensor() : dims_(0) {}\n\n  ABSL_DEPRECATED(\"Use Create() functions instead of constructors directly.\")\n  SparseTensor(Tensor ix, Tensor vals, const TensorShape& shape)\n      : SparseTensor(std::move(ix), std::move(vals), TensorShapeToVector(shape),\n                     UndefinedOrder(TensorShapeToVector(shape))...\n\n// TensorShape:\nclass TensorShape : public TensorShapeBase<TensorShape> {\n public:\n  using TensorShapeBase<TensorShape>::TensorShapeBase;\n\n  // These factory methods should be used instead of the constructors that take\n  // an array of sizes if calling code cannot validate that the sizes specify a\n  // valid `TensorShape`.\n  // The value in `*out` is valid iff the returned value is `Status::OK`.\n  static Status BuildTensorShape(gtl::ArraySlice<int64_t> dim_sizes,\n                                 TensorShape* out) {\n    return BuildTensorShapeBase(dim_sizes, out);\n  }\n  static Status BuildTensorShape(std::initializer_list<int64_t> dim_sizes,\n                                 TensorShape* out) {\n    return BuildTensorShape(gtl::ArraySlice<int64_t>(dim_sizes), out);\n  }\n  static Status BuildTensorShape(const TensorShapeProto& proto,\n                                 TensorShape* out) {\n    return BuildTensorShapeBase(proto, out);\n  }\n\n  /// Allow a TensorShape to be used as a PartialTensorShape without ...\n\n// Called Methods (top 10):\n// OP_REQUIRES from tensorflow/core/kernels/tensorflow/core/framework/tensorflow/core/framework/op_requires.h:\n\n\n// AsAsync from tensorflow/core/framework/op_kernel.h:\n  virtual AsyncOpKernel* AsAsync() { return nullptr; } /* <=== tensorflow.OpKernel.AsAsync:tensorflow.AsyncOpKernel*() */ \n\n// IsVector from tensorflow/core/framework/tensor_shape.h:\n  static bool IsVector(const TensorShape& shape) { return shape.dims() == 1; } /* <=== tensorflow.TensorShapeUtils.IsVector:bool(tensorflow.TensorShape&) */ \n\n// group from tensorflow/core/util/sparse/group_iterator.h:\n  std::vector<int64_t> group() const; /* <=== tensorflow.sparse.Group.group:ANY()<const> */ \n\n// OP_REQUIRES_OK from tensorflow/core/kernels/tensorflow/core/framework/tensorflow/core/framework/op_requires.h:\n\n\n// Create from tensorflow/core/util/sparse/sparse_tensor.h:\n  static Status Create(Tensor ix, Tensor vals, const TensorShape& shape, /* <=== tensorflow.sparse.SparseTensor.Create:ANY(tensorflow.Tensor,tensorflow.Tensor,tensorflow.TensorShape&,tensorflow.sparse.SparseTensor*) */ \n                       SparseTensor* result);\n\n// IsMatrix from tensorflow/core/framework/tensor_shape.h:\n  static bool IsMatrix(const TensorShape& shape) { return shape.dims() == 2; } /* <=== tensorflow.TensorShapeUtils.IsMatrix:bool(tensorflow.TensorShape&) */ \n\n// indices from tensorflow/core/util/sparse/group_iterator.h:\n  TTypes<int64_t>::UnalignedConstMatrix indices() const; /* <=== tensorflow.sparse.Group.indices:ANY()<const> */ \n\n// shape from tensorflow/core/framework/tensor.h:\n  const TensorShape& shape() const { return shape_; } /* <=== tensorflow.Tensor.shape:tensorflow.TensorShape&()<const> */ \n\n// CheckNotInComputeAsync from tensorflow/core/framework/op_kernel.cc:\nvoid CheckNotInComputeAsync(OpKernelContext* ctx, /* <=== tensorflow.CheckNotInComputeAsync:void(tensorflow.OpKernelContext*,char*) */ \n                            const char* correct_macro_name) {\n  CHECK_EQ(nullptr, ctx->params_->op_kernel->AsAsync())\n      << \"Use \" << correct_macro_name << \" in AsyncOpKernel implementations.\";\n}\n"
  },
  {
    "repository": "php-src",
    "cve_id": "CVE-2009-0689",
    "cwe_list": [
      "CWE-119"
    ],
    "commit_hash": "37da90248deb2188e8ee50e4753ad6340679b425",
    "short_hash": "37da9024",
    "vulnerableMethods_before": [
      {
        "filename": "zend_strtod.c",
        "method_name": "vulnerable_function",
        "raw_code": "static Bigint * Balloc(int k)\n{\n\tint x;\n\tBigint *rv;\n\n\t_THREAD_PRIVATE_MUTEX_LOCK(dtoa_mutex);\n\tif ((rv = freelist[k])) {\n\t\tfreelist[k] = rv->next;\n\t} else {\n\t\tx = 1 << k;\n\t\trv = (Bigint *)MALLOC(sizeof(Bigint) + (x-1)*sizeof(Long));\n\t\trv->k = k;\n\t\trv->maxwds = x;\n\t}\n\t_THREAD_PRIVATE_MUTEX_UNLOCK(dtoa_mutex);\n\trv->sign = rv->wds = 0;\n\treturn rv;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "zend_strtod.c",
        "method_name": "fixed_function",
        "raw_code": "static Bigint * Balloc(int k)\n{\n\tint x;\n\tBigint *rv;\n\n\tif (k > Kmax) {\n\t\tzend_error(E_ERROR, \"Balloc() allocation exceeds list boundary\");\n\t}\n\n\t_THREAD_PRIVATE_MUTEX_LOCK(dtoa_mutex);\n\tif ((rv = freelist[k])) {\n\t\tfreelist[k] = rv->next;\n\t} else {\n\t\tx = 1 << k;\n\t\trv = (Bigint *)MALLOC(sizeof(Bigint) + (x-1)*sizeof(Long));\n\t\tif (!rv) {\n\t\t\t_THREAD_PRIVATE_MUTEX_UNLOCK(dtoa_mutex);\n\t\t\tzend_error(E_ERROR, \"Balloc() failed to allocate memory\");\n\t\t}\n\t\trv->k = k;\n\t\trv->maxwds = x;\n\t}\n\t_THREAD_PRIVATE_MUTEX_UNLOCK(dtoa_mutex);\n\trv->sign = rv->wds = 0;\n\treturn rv;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"errno.h\"\n#include \"locale.h\"\n#include <math.h>\n#include \"stdlib.h\"\n#include <stdint.h>\n#include \"malloc.h\"\n#include \"memory.h\"\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <TSRM.h>\n#include \"string.h\"\n#include <ctype.h>\n#include <stdarg.h>\n#include <inttypes.h>\n#include \"float.h\"\n#include <locale.h>\n#include <string.h>\n#include <sys/types.h>\n#include \"ctype.h\"\n#include \"math.h\"\n#include <zend_strtod.h>\n\n// Type Definitions:\n// Bigint:\nstruct Bigint {\n\tstruct Bigint *next;\n\tint k, maxwds, sign, wds;\n\tULong x[1];\n}\n\n// int32_t:\ntypedef long int int32_t;\n\n// Called Methods (top 10):\n// va_end from ext/exif/exif.c:\n\tva_end(args); /* <=== va_end */ \n\n// E_WARNING from Zend/zend_errors.h:\n#define E_WARNING\t\t\t(1<<1L) /* <=== Zend/zend_errors.h:26:26:E_WARNING:0 */ \n\n// E_USER_NOTICE from Zend/zend_errors.h:\n#define E_USER_NOTICE\t\t(1<<10L) /* <=== Zend/zend_errors.h:35:35:E_USER_NOTICE:0 */ \n\n// safe_free_zval_ptr_rel from Zend/zend_execute.h:\nstatic inline void safe_free_zval_ptr_rel(zval *p ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC) /* <=== safe_free_zval_ptr_rel */ \n{\n\tTSRMLS_FETCH();\n\n\tif (p!=EG(uninitialized_zval_ptr)) {\n\t\tFREE_ZVAL_REL(p);\n\t}\n}\n\n// zend_is_compiling from Zend/zend_compile.c:\nZEND_API zend_bool zend_is_compiling(TSRMLS_D) /* <=== zend_is_compiling */ \n{\n\treturn CG(in_compilation);\n}\n\n// IS_LONG from Zend/zend.h:\n#define IS_LONG\t\t1 /* <=== Zend/zend.h:414:414:IS_LONG:0 */ \n\n// efree from Zend/zend_alloc.h:\n#define efree(ptr)\t\t\t\t\t\t\t_efree((ptr) ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC) /* <=== Zend/zend_alloc.h:58:58:efree:1 */ \n\n// Z_LVAL_P from Zend/zend_operators.h:\n#define Z_LVAL_P(zval_p)\t\tZ_LVAL(*zval_p) /* <=== Zend/zend_operators.h:391:391:Z_LVAL_P:1 */ \n\n// ALLOC_INIT_ZVAL from Zend/zend.h:\n#define ALLOC_INIT_ZVAL(zp)\t\t\t\t\t\t\\ /* <=== Zend/zend.h:570:572:ALLOC_INIT_ZVAL:1 */ \n\tALLOC_ZVAL(zp);\t\t\\\n\tINIT_ZVAL(*zp);\n\n// _zend_mm_free_int from Zend/zend_alloc.c:\nstatic void _zend_mm_free_int(zend_mm_heap *heap, void *p ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC) /* <=== _zend_mm_free_int */ \n{\n\tzend_mm_block *mm_block;\n\tzend_mm_block *prev_block, *next_block;\n\tsize_t size;\n\n\tif (!ZEND_MM_VALID_PTR(p)) {\n\t\treturn;\n\t}\n\n\tmm_block = ZEND_MM_HEADER_OF(p);\n\tsize = ZEND_MM_BLOCK_SIZE(mm_block);\n\tZEND_MM_CHECK_PROTECTION(mm_block);\n\n#if ZEND_DEBUG || ZEND_MM_HEAP_PROTECTION\n\tmemset(ZEND_MM_DATA_OF(mm_block), 0x5a, mm_block->debug.size);\n#endif\n\n#if ZEND_MM_CACHE\n\tif (ZEND_MM_SMALL_SIZE(size) && heap->cached < ZEND_MM_CACHE_SIZE) {\n\t\tsize_t index = ZEND_MM_BUCKET_INDEX(size);\n\t\tzend_mm_free_block **cache = &heap->cache[index];\n\n\t\t((zend_mm_free_block*)mm_block)->prev_free_block = *cache;\n\t\t*cache = (zend_mm_free_block*)mm_block;\n\t\theap->cached += size;\n\t\tZEND_MM_SET_MAGIC(mm_block, MEM_BLOCK_CACHED);\n\t\treturn;\n\t}\n#endif\n\n\tHANDLE_BLOCK_INTERRUPTIONS();\n\n\theap->size -= size;\n\n\tif (ZEND_MM_PREV_BLOCK_IS_FREE(mm_block)) {\n\t\tnext_block = ZEND_MM_NEXT_BLOCK(mm_block);\n\t\tif (ZEND_MM_IS_FREE_BLOCK(next_block)) {\n\t\t    /* merge with previous and next block */\n\t\t\tzend_mm_remove_from_free_list(heap, (zend_mm_free_block *) next_block);\n\t\t\tprev_block=ZEND_MM_PREV_BLOCK(mm_block);\n\t\t\tif (ZEND_MM_SMALL_SIZE(ZEND_MM_FREE_BLOCK_SIZE(prev_block))) {\n\t\t\t\tzend_mm_remove_from_free_list(heap, (zend_mm_free_block *) prev_block);\n\t\t\t\tsize += ZEND_MM_FREE_BLOCK_SIZE(prev_block) + ZEND_MM_FREE_BLOCK_SIZE(next_block);\n\t\t\t\tmm_block = prev_block;\n\t\t\t} else {\n\t\t\t\tZEND_MM_BLOCK(prev_block, ZEND_MM_FREE_BLOCK, size + ZEND_MM_FREE_BLOCK_SIZE(prev_block) + ZEND_MM_FREE_BLOCK_SIZE(next_block));\n\t\t\t\tif (ZEND_MM_IS_FIRST_BLOCK(prev_block) &&\n\t\t\t\t    ZEND_MM_IS_GUARD_BLOCK(ZEND_MM_NEXT_BLOCK(prev_block))) {\n\t\t\t\t\tmm_block = prev_block;\n\t\t\t\t\tzend_mm_remove_from_free_list(heap, (zend_mm_free_block *) mm_block);\n\t\t\t\t\tgoto free_segment;\n\t\t\t\t}\n\t\t\t\tHANDLE_UNBLOCK_INTERRUPTIONS();\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t    /* merge with previous block */\n\t\t\tprev_block=ZEND_MM_PREV_BLOCK(mm_block);\n\t\t\tif (ZEND_MM_SMALL_SIZE(ZEND_MM_FREE_BLOCK_SIZE(prev_block))) {\n\t\t\t\tsize += ZEND_MM_FREE_BLOCK_SIZE(prev_block);\n\t\t\t\tzend_mm_remove_from_free_list(heap, (zend_mm_free_block *) prev_block);\n\t\t\t\tmm_block = prev_block;\n\t\t   \t} else {\n\t\t\t\tZEND_MM_BLOCK(prev_block, ZEND_MM_FREE_BLOCK, size + ZEND_MM_FREE_BLOCK_SIZE(prev_block));\n\t\t\t\tif (ZEND_MM_IS_FIRST_BLOCK(prev_block) &&\n\t\t\t\t    ZEND_MM_IS_GUARD_BLOCK(ZEND_MM_NEXT_BLOCK(prev_block))) {\n\t\t\t\t\tmm_block = prev_block;\n\t\t\t\t\tzend_mm_remove_from_free_list(heap, (zend_mm_free_block *) mm_block);\n\t\t\t\t\tgoto free_segment;\n\t\t\t\t}\n\t\t\t\tHANDLE_UNBLOCK_INTERRUPTIONS();\n\t\t\t\treturn;\n\t\t   \t}\n\t\t}\n\t} else {\n\t\tnext_block = ZEND_MM_NEXT_BLOCK(mm_block);\n\t\tif (ZEND_MM_IS_FREE_BLOCK(next_block)) {\n\t\t\t/* merge with the next block */\n\t\t\tzend_mm_remove_from_free_list(heap, (zend_mm_free_block *) next_block);\n\t\t\tsize += ZEND_MM_FREE_BLOCK_SIZE(next_block);\n\t\t}\n\t}\n\tZEND_MM_BLOCK(mm_block, ZEND_MM_FREE_BLOCK, size);\n\tif (ZEND_MM_IS_FIRST_BLOCK(mm_block) &&\n\t    ZEND_MM_IS_GUARD_BLOCK(ZEND_MM_NEXT_BLOCK(mm_block))) {\nfree_segment:\n\t\tzend_mm_del_segment(heap, (zend_mm_segment *) ((char *)mm_block - ZEND_MM_ALIGNED_SEGMENT_SIZE));\n\t} else {\n\t\tzend_mm_add_to_free_list(heap, (zend_mm_free_block *) mm_block);\n\t}\n\tHANDLE_UNBLOCK_INTERRUPTIONS();\n}\n"
  },
  {
    "repository": "FreeRTOS-Kernel",
    "cve_id": "CVE-2021-31571",
    "cwe_list": [
      "CWE-200"
    ],
    "commit_hash": "47338393f1f79558f6144213409f09f81d7c4837",
    "short_hash": "47338393",
    "vulnerableMethods_before": [
      {
        "filename": "queue.c",
        "method_name": "vulnerable_function",
        "raw_code": "    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,\r\n                                       const UBaseType_t uxItemSize,\r\n                                       const uint8_t ucQueueType )\r\n    {\r\n        Queue_t * pxNewQueue;\r\n        size_t xQueueSizeInBytes;\r\n        uint8_t * pucQueueStorage;\r\n\r\n        configASSERT( uxQueueLength > ( UBaseType_t ) 0 );\r\n\r\n        /* Allocate enough space to hold the maximum number of items that\r\n         * can be in the queue at any time.  It is valid for uxItemSize to be\r\n         * zero in the case the queue is used as a semaphore. */\r\n        xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */\r\n\r\n        /* Check for multiplication overflow. */\r\n        configASSERT( ( uxItemSize == 0 ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) ) );\r\n\r\n        /* Allocate the queue and storage area.  Justification for MISRA\r\n         * deviation as follows:  pvPortMalloc() always ensures returned memory\r\n         * blocks are aligned per the requirements of the MCU stack.  In this case\r\n         * pvPortMalloc() must return a pointer that is guaranteed to meet the\r\n         * alignment requirements of the Queue_t structure - which in this case\r\n         * is an int8_t *.  Therefore, whenever the stack alignment requirements\r\n         * are greater than or equal to the pointer to char requirements the cast\r\n         * is safe.  In other cases alignment requirements are not strict (one or\r\n         * two bytes). */\r\n        pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */\r\n\r\n        if( pxNewQueue != NULL )\r\n        {\r\n            /* Jump past the queue structure to find the location of the queue\r\n             * storage area. */\r\n            pucQueueStorage = ( uint8_t * ) pxNewQueue;\r\n            pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */\r\n\r\n            #if ( configSUPPORT_STATIC_ALLOCATION == 1 )\r\n                {\r\n                    /* Queues can be created either statically or dynamically, so\r\n                     * note this task was created dynamically in case it is later\r\n                     * deleted. */\r\n                    pxNewQueue->ucStaticallyAllocated = pdFALSE;\r\n                }\r\n            #endif /* configSUPPORT_STATIC_ALLOCATION */\r\n\r\n            prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );\r\n        }\r\n        else\r\n        {\r\n            traceQUEUE_CREATE_FAILED( ucQueueType );\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n\r\n        return pxNewQueue;\r\n    }\r",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "queue.c",
        "method_name": "fixed_function",
        "raw_code": "    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,\r\n                                       const UBaseType_t uxItemSize,\r\n                                       const uint8_t ucQueueType )\r\n    {\r\n        Queue_t * pxNewQueue;\r\n        size_t xQueueSizeInBytes;\r\n        uint8_t * pucQueueStorage;\r\n\r\n        configASSERT( uxQueueLength > ( UBaseType_t ) 0 );\r\n\r\n        /* Allocate enough space to hold the maximum number of items that\r\n         * can be in the queue at any time.  It is valid for uxItemSize to be\r\n         * zero in the case the queue is used as a semaphore. */\r\n        xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */\r\n\r\n        /* Check for multiplication overflow. */\r\n        configASSERT( ( uxItemSize == 0 ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) ) );\r\n\r\n        /* Check for addition overflow. */\r\n        configASSERT( ( sizeof( Queue_t ) + xQueueSizeInBytes ) >  xQueueSizeInBytes );\r\n\r\n        /* Allocate the queue and storage area.  Justification for MISRA\r\n         * deviation as follows:  pvPortMalloc() always ensures returned memory\r\n         * blocks are aligned per the requirements of the MCU stack.  In this case\r\n         * pvPortMalloc() must return a pointer that is guaranteed to meet the\r\n         * alignment requirements of the Queue_t structure - which in this case\r\n         * is an int8_t *.  Therefore, whenever the stack alignment requirements\r\n         * are greater than or equal to the pointer to char requirements the cast\r\n         * is safe.  In other cases alignment requirements are not strict (one or\r\n         * two bytes). */\r\n        pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */\r\n\r\n        if( pxNewQueue != NULL )\r\n        {\r\n            /* Jump past the queue structure to find the location of the queue\r\n             * storage area. */\r\n            pucQueueStorage = ( uint8_t * ) pxNewQueue;\r\n            pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */\r\n\r\n            #if ( configSUPPORT_STATIC_ALLOCATION == 1 )\r\n                {\r\n                    /* Queues can be created either statically or dynamically, so\r\n                     * note this task was created dynamically in case it is later\r\n                     * deleted. */\r\n                    pxNewQueue->ucStaticallyAllocated = pdFALSE;\r\n                }\r\n            #endif /* configSUPPORT_STATIC_ALLOCATION */\r\n\r\n            prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );\r\n        }\r\n        else\r\n        {\r\n            traceQUEUE_CREATE_FAILED( ucQueueType );\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n\r\n        return pxNewQueue;\r\n    }\r",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <stdlib.h>\n#include \"FreeRTOS.h\"\n#include \"croutine.h\"\n#include \"queue.h\"\n#include \"task.h\"\n#include <string.h>\n"
  },
  {
    "repository": "cyrus-imapd",
    "cve_id": "CVE-2021-32056",
    "cwe_list": [
      "CWE-732"
    ],
    "commit_hash": "621f9e41465b521399f691c241181300fab55995",
    "short_hash": "621f9e41",
    "vulnerableMethods_before": [
      {
        "filename": "annotate.c",
        "method_name": "vulnerable_function",
        "raw_code": "static int write_entry(struct mailbox *mailbox,\n                       unsigned int uid,\n                       const char *entry,\n                       const char *userid,\n                       const struct buf *value,\n                       int ignorequota,\n                       int silent,\n                       const struct annotate_metadata *mdata,\n                       int maywrite)\n\n{\n    char key[MAX_MAILBOX_PATH+1];\n    int keylen, r;\n    annotate_db_t *d = NULL;\n    struct buf oldval = BUF_INITIALIZER;\n    const char *mboxname = mailbox ? mailbox->name : \"\";\n    modseq_t modseq = mdata ? mdata->modseq : 0;\n\n    r = _annotate_getdb(mboxname, uid, CYRUSDB_CREATE, &d);\n    if (r)\n        return r;\n\n    /* must be in a transaction to modify the db */\n    annotate_begin(d);\n\n    keylen = make_key(mboxname, uid, entry, userid, key, sizeof(key));\n\n    if (mailbox) {\n        struct annotate_metadata oldmdata;\n        r = read_old_value(d, key, keylen, &oldval, &oldmdata);\n        if (r) goto out;\n\n        /* if the value is identical, don't touch the mailbox */\n        if (oldval.len == value->len && (!value->len || !memcmp(oldval.s, value->s, value->len)))\n            goto out;\n\n        if (!ignorequota) {\n            quota_t qdiffs[QUOTA_NUMRESOURCES] = QUOTA_DIFFS_DONTCARE_INITIALIZER;\n            qdiffs[QUOTA_ANNOTSTORAGE] = value->len - (quota_t)oldval.len;\n            r = mailbox_quota_check(mailbox, qdiffs);\n            if (r) goto out;\n        }\n\n        if (!maywrite) {\n            r = IMAP_PERMISSION_DENIED;\n            if (r) goto out;\n        }\n\n        /* do the annot-changed here before altering the DB */\n        mailbox_annot_changed(mailbox, uid, entry, userid, &oldval, value, silent);\n\n        /* grab the message annotation modseq, if not overridden */\n        if (uid && !mdata) {\n            modseq = mailbox->i.highestmodseq;\n        }\n    }\n\n    /* zero length annotation is deletion.\n     * keep tombstones for message annotations */\n    if (!value->len && !uid) {\n\n#if DEBUG\n        syslog(LOG_ERR, \"write_entry: deleting key %s from %s\",\n                key_as_string(d, key, keylen), d->filename);\n#endif\n\n        do {\n            r = cyrusdb_delete(d->db, key, keylen, tid(d), /*force*/1);\n        } while (r == CYRUSDB_AGAIN);\n    }\n    else {\n        struct buf data = BUF_INITIALIZER;\n        unsigned char flags = 0;\n        if (!value->len || value->s == NULL) {\n            flags |= ANNOTATE_FLAG_DELETED;\n        }\n        else {\n            // this is only here to allow cleanup of invalid values in the past...\n            // the calling of this API with a NULL \"userid\" is bogus, because that's\n            // supposed to be reserved for the make_key of prefixes - but there has\n            // been API abuse in the past, so some of these are in the wild.  *sigh*.\n            // Don't allow new ones to be written\n            if (!userid) goto out;\n        }\n        make_entry(&data, value, modseq, flags);\n\n#if DEBUG\n        syslog(LOG_ERR, \"write_entry: storing key %s (value: %s) to %s (modseq=\" MODSEQ_FMT \")\",\n                key_as_string(d, key, keylen), value->s, d->filename, modseq);\n#endif\n\n        do {\n            r = cyrusdb_store(d->db, key, keylen, data.s, data.len, tid(d));\n        } while (r == CYRUSDB_AGAIN);\n        buf_free(&data);\n    }\n\n    if (!mailbox)\n        sync_log_annotation(\"\");\n\nout:\n    annotate_putdb(&d);\n    buf_free(&oldval);\n\n    return r;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "annotate.c",
        "method_name": "fixed_function",
        "raw_code": "static int write_entry(struct mailbox *mailbox,\n                       unsigned int uid,\n                       const char *entry,\n                       const char *userid,\n                       const struct buf *value,\n                       int ignorequota,\n                       int silent,\n                       const struct annotate_metadata *mdata,\n                       int maywrite)\n\n{\n    char key[MAX_MAILBOX_PATH+1];\n    int keylen, r;\n    annotate_db_t *d = NULL;\n    struct buf oldval = BUF_INITIALIZER;\n    const char *mboxname = mailbox ? mailbox->name : \"\";\n    modseq_t modseq = mdata ? mdata->modseq : 0;\n\n    r = _annotate_getdb(mboxname, uid, CYRUSDB_CREATE, &d);\n    if (r)\n        return r;\n\n    /* must be in a transaction to modify the db */\n    annotate_begin(d);\n\n    keylen = make_key(mboxname, uid, entry, userid, key, sizeof(key));\n\n    struct annotate_metadata oldmdata;\n    r = read_old_value(d, key, keylen, &oldval, &oldmdata);\n    if (r) goto out;\n\n    /* if the value is identical, don't touch the mailbox */\n    if (oldval.len == value->len && (!value->len || !memcmp(oldval.s, value->s, value->len)))\n        goto out;\n\n    if (!maywrite) {\n        r = IMAP_PERMISSION_DENIED;\n        if (r) goto out;\n    }\n\n    if (mailbox) {\n        if (!ignorequota) {\n            quota_t qdiffs[QUOTA_NUMRESOURCES] = QUOTA_DIFFS_DONTCARE_INITIALIZER;\n            qdiffs[QUOTA_ANNOTSTORAGE] = value->len - (quota_t)oldval.len;\n            r = mailbox_quota_check(mailbox, qdiffs);\n            if (r) goto out;\n        }\n\n        /* do the annot-changed here before altering the DB */\n        mailbox_annot_changed(mailbox, uid, entry, userid, &oldval, value, silent);\n\n        /* grab the message annotation modseq, if not overridden */\n        if (uid && !mdata) {\n            modseq = mailbox->i.highestmodseq;\n        }\n    }\n\n    /* zero length annotation is deletion.\n     * keep tombstones for message annotations */\n    if (!value->len && !uid) {\n\n#if DEBUG\n        syslog(LOG_ERR, \"write_entry: deleting key %s from %s\",\n                key_as_string(d, key, keylen), d->filename);\n#endif\n\n        do {\n            r = cyrusdb_delete(d->db, key, keylen, tid(d), /*force*/1);\n        } while (r == CYRUSDB_AGAIN);\n    }\n    else {\n        struct buf data = BUF_INITIALIZER;\n        unsigned char flags = 0;\n        if (!value->len || value->s == NULL) {\n            flags |= ANNOTATE_FLAG_DELETED;\n        }\n        else {\n            // this is only here to allow cleanup of invalid values in the past...\n            // the calling of this API with a NULL \"userid\" is bogus, because that's\n            // supposed to be reserved for the make_key of prefixes - but there has\n            // been API abuse in the past, so some of these are in the wild.  *sigh*.\n            // Don't allow new ones to be written\n            if (!userid) goto out;\n        }\n        make_entry(&data, value, modseq, flags);\n\n#if DEBUG\n        syslog(LOG_ERR, \"write_entry: storing key %s (value: %s) to %s (modseq=\" MODSEQ_FMT \")\",\n                key_as_string(d, key, keylen), value->s, d->filename, modseq);\n#endif\n\n        do {\n            r = cyrusdb_store(d->db, key, keylen, data.s, data.len, tid(d));\n        } while (r == CYRUSDB_AGAIN);\n        buf_free(&data);\n    }\n\n    if (!mailbox)\n        sync_log_annotation(\"\");\n\nout:\n    annotate_putdb(&d);\n    buf_free(&oldval);\n\n    return r;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"mboxlist.h\"\n#include \"cyrusdb.h\"\n#include <sys/uio.h>\n#include \"ptrarray.h\"\n#include <string.h>\n#include \"global.h\"\n#include \"annotate.h\"\n#include <config.h>\n#include \"xstrlcpy.h\"\n#include \"glob.h\"\n#include <sysexits.h>\n#include \"partlist.h\"\n#include <sys/types.h>\n#include <stdio.h>\n#include \"quota.h\"\n# include <stdint.h>\n#include \"xmalloc.h\"\n#include \"sync_log.h\"\n#include \"times.h\"\n#include \"acl.h\"\n#include \"imapd.h\"\n#include <errno.h>\n#include \"xstrlcat.h\"\n#include \"imap/imap_err.h\"\n#include \"assert.h\"\n#include <ctype.h>\n#include \"hash.h\"\n#include <fcntl.h>\n#include <unistd.h>\n# include <inttypes.h>\n#include <sys/stat.h>\n#include \"util.h\"\n#include <syslog.h>\n#include <stdlib.h>\n#include \"tok.h\"\n\n// Type Definitions:\n// annotate_db_t:\ntypedef struct annotate_db annotate_db_t;\n\n// mailbox:\nstruct mailbox {\n    int index_fd;\n    int header_fd;\n\n    ptrarray_t caches;\n    const char *index_base;\n    size_t index_len;   /* mapped size */\n\n    int index_locktype; /* 0 = none, 1 = shared, 2 = exclusive */\n    int is_readonly; /* true = open index and cache files readonly */\n\n    ino_t header_file_ino;\n    bit32 header_file_crc;\n\n    time_t index_mtime;\n    ino_t index_ino;\n    size_t index_size;\n\n    /* Information in mailbox list */\n    char *name;\n    uint32_t mbtype;\n    char *part;\n    char *acl;\n    modseq_t foldermodseq;\n\n    struct index_header i;\n\n    /* Information in header */\n    char *uniqueid;\n    char *quotaroot;\n    char *flagname[MAX_USER_FLAGS];\n\n    struct timeval starttime;\n\n    /* annotations */\n    struct annotate_state *annot_state;\n\n    /* conversations */\n    struct conversations_state *local_cstate;\n\n#ifdef WITH_DAV\n    struct caldav_db *local_caldav;\n    struct carddav_db *local_carddav;\n    struct webdav_db *local_webdav;\n#endif\n\n    /* change ma...\n\n// mailbox:\nstruct mailbox\n\n// buf:\nstruct buf {\n    char *s;\n    size_t len;\n    size_t alloc;\n    unsigned flags;\n}\n\n// modseq_t:\ntypedef unsigned long long int modseq_t;\n\n// buf:\nstruct buf\n\n// annotate_metadata:\nstruct annotate_metadata\n{\n    modseq_t modseq;\n    unsigned char flags; /* read-only */\n}\n\n// Called Methods (top 10):\n// xstrdup from lib/xmalloc.c:\nEXPORTED char *xstrdup(const char* str) /* <=== xstrdup */ \n{\n    char *p = xmalloc(strlen(str)+1);\n    strcpy(p, str);\n    return p;\n}\n\n// mailbox_quota_check from imap/mailbox.h:\n<empty>\n\n// buf_append from lib/util.c:\nEXPORTED void buf_append(struct buf *dst, const struct buf *src) /* <=== buf_append */ \n{\n    buf_appendmap(dst, src->s, src->len);\n}\n\n// mailbox_get_usage from imap/mailbox.c:\nEXPORTED void mailbox_get_usage(struct mailbox *mailbox, /* <=== mailbox_get_usage */ \n                        quota_t usage[QUOTA_NUMRESOURCES])\n{\n    int res;\n\n    for (res = 0; res < QUOTA_NUMRESOURCES; res++) {\n        usage[res] = 0;\n    }\n\n    if (!(mailbox->i.options & OPT_MAILBOX_DELETED)) {\n        usage[QUOTA_STORAGE] = mailbox->i.quota_mailbox_used;\n        usage[QUOTA_MESSAGE] = mailbox->i.exists;\n        usage[QUOTA_ANNOTSTORAGE] = mailbox->i.quota_annot_used;\n        usage[QUOTA_NUMFOLDERS] = 1;\n    }\n    /* else: mailbox is being deleted, thus its new usage is 0 */\n}\n\n// assert from imap/assert.h:\n\n\n// _htonll from lib/byteorder64.c:\nEXPORTED unsigned long long _htonll(unsigned long long x) /* <=== _htonll */ \n{\n    union byteswap_64_u u1;\n    union byteswap_64_u u2;\n\n    u1.a = x;\n\n    u2.b[0] = htonl(u1.b[1]);\n    u2.b[1] = htonl(u1.b[0]);\n\n    return u2.a;\n}\n\n// mailbox_find_index_record from imap/mailbox.c:\nEXPORTED int mailbox_find_index_record(struct mailbox *mailbox, uint32_t uid, /* <=== mailbox_find_index_record */ \n                                       struct index_record *record)\n{\n    uint32_t recno = mailbox_finduid(mailbox, uid);\n    /* no records? */\n    if (!recno) return IMAP_NOTFOUND;\n\n    int r = mailbox_read_index_record(mailbox, recno, record);\n    /* failed read? */\n    if (r) return r;\n\n    /* wasn't the actual record? */\n    if (record->uid != uid) return IMAP_NOTFOUND;\n\n    return 0;\n}\n\n// crc_annot from imap/mailbox.c:\nstatic uint32_t crc_annot(unsigned int uid, const char *entry, /* <=== crc_annot */ \n                          const char *userid, const struct buf *value)\n{\n    struct buf buf = BUF_INITIALIZER;\n    uint32_t res = 0;\n\n    // ignore everything with a NULL userid, it's bogus!\n    if (!userid) return 0;\n\n    buf_printf(&buf, \"%u %s %s \", uid, entry, userid);\n    buf_append(&buf, value);\n    res = crc32_buf(&buf);\n    buf_free(&buf);\n\n    return res;\n}\n\n// mboxlist_entry_free from imap/mboxlist.c:\nEXPORTED void mboxlist_entry_free(mbentry_t **mbentryptr) /* <=== mboxlist_entry_free */ \n{\n    mbentry_t *mbentry = *mbentryptr;\n\n    /* idempotent */\n    if (!mbentry) return;\n\n    free(mbentry->name);\n    free(mbentry->ext_name);\n\n    free(mbentry->partition);\n    free(mbentry->server);\n    free(mbentry->acl);\n    free(mbentry->uniqueid);\n\n    free(mbentry->legacy_specialuse);\n\n    free(mbentry);\n\n    *mbentryptr = NULL;\n}\n\n// quota_check_useds from imap/quota_db.c:\nint quota_check_useds(const char *quotaroot,\n                      const quota_t diff[QUOTA_NUMRESOURCES])\n{\n    int r = 0;\n    struct quota q;\n    int res;\n\n    init_internal();\n\n    /*\n     * We are always allowed to *reduce* usage even if it doesn't get us\n     * below the quota.  As a side effect this allows our caller to pass\n     * delta = -1 meaning \"don't care about quota checks\".\n     */\n    for (res = 0 ; res < QUOTA_NUMRESOURCES ; res++) {\n        if (diff[res] >= 0)\n            break;\n    }\n    if (res == QUOTA_NUMRESOURCES)\n        return 0;           /* all negative */\n\n    quota_init(&q, quotaroot);\n    r = quota_read(&q, NULL, /*wrlock*/0);\n\n    if (r == IMAP_QUOTAROOT_NONEXISTENT) {\n        r = 0;\n        goto done;\n    }\n    if (r) goto done;\n\n    for (res = 0 ; res < QUOTA_NUMRESOURCES ; res++) {\n        r = quota_check(&q, res, diff[res]);\n        if (r) goto done;\n    }\n\ndone:\n    quota_free(&q);\n    return r;\n}\n"
  },
  {
    "repository": "net",
    "cve_id": "CVE-2021-43975",
    "cwe_list": [
      "CWE-787"
    ],
    "commit_hash": "b922f622592af76b57cbc566eaeccda0b31a3496",
    "short_hash": "b922f622",
    "vulnerableMethods_before": [
      {
        "filename": "hw_atl_utils.c",
        "method_name": "vulnerable_function",
        "raw_code": "int hw_atl_utils_fw_rpc_wait(struct aq_hw_s *self,\n\t\t\t     struct hw_atl_utils_fw_rpc **rpc)\n{\n\tstruct aq_hw_atl_utils_fw_rpc_tid_s sw;\n\tstruct aq_hw_atl_utils_fw_rpc_tid_s fw;\n\tint err = 0;\n\n\tdo {\n\t\tsw.val = aq_hw_read_reg(self, HW_ATL_RPC_CONTROL_ADR);\n\n\t\tself->rpc_tid = sw.tid;\n\n\t\terr = readx_poll_timeout_atomic(hw_atl_utils_rpc_state_get,\n\t\t\t\t\t\tself, fw.val,\n\t\t\t\t\t\tsw.tid == fw.tid,\n\t\t\t\t\t\t1000U, 100000U);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\n\t\terr = aq_hw_err_from_flags(self);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\n\t\tif (fw.len == 0xFFFFU) {\n\t\t\terr = hw_atl_utils_fw_rpc_call(self, sw.len);\n\t\t\tif (err < 0)\n\t\t\t\tgoto err_exit;\n\t\t}\n\t} while (sw.tid != fw.tid || 0xFFFFU == fw.len);\n\n\tif (rpc) {\n\t\tif (fw.len) {\n\t\t\terr =\n\t\t\thw_atl_utils_fw_downld_dwords(self,\n\t\t\t\t\t\t      self->rpc_addr,\n\t\t\t\t\t\t      (u32 *)(void *)\n\t\t\t\t\t\t      &self->rpc,\n\t\t\t\t\t\t      (fw.len + sizeof(u32) -\n\t\t\t\t\t\t       sizeof(u8)) /\n\t\t\t\t\t\t      sizeof(u32));\n\t\t\tif (err < 0)\n\t\t\t\tgoto err_exit;\n\t\t}\n\n\t\t*rpc = &self->rpc;\n\t}\n\nerr_exit:\n\treturn err;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "hw_atl_utils.c",
        "method_name": "fixed_function",
        "raw_code": "int hw_atl_utils_fw_rpc_wait(struct aq_hw_s *self,\n\t\t\t     struct hw_atl_utils_fw_rpc **rpc)\n{\n\tstruct aq_hw_atl_utils_fw_rpc_tid_s sw;\n\tstruct aq_hw_atl_utils_fw_rpc_tid_s fw;\n\tint err = 0;\n\n\tdo {\n\t\tsw.val = aq_hw_read_reg(self, HW_ATL_RPC_CONTROL_ADR);\n\n\t\tself->rpc_tid = sw.tid;\n\n\t\terr = readx_poll_timeout_atomic(hw_atl_utils_rpc_state_get,\n\t\t\t\t\t\tself, fw.val,\n\t\t\t\t\t\tsw.tid == fw.tid,\n\t\t\t\t\t\t1000U, 100000U);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\n\t\terr = aq_hw_err_from_flags(self);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\n\t\tif (fw.len == 0xFFFFU) {\n\t\t\tif (sw.len > sizeof(self->rpc)) {\n\t\t\t\tprintk(KERN_INFO \"Invalid sw len: %x\\n\", sw.len);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\t\t\terr = hw_atl_utils_fw_rpc_call(self, sw.len);\n\t\t\tif (err < 0)\n\t\t\t\tgoto err_exit;\n\t\t}\n\t} while (sw.tid != fw.tid || 0xFFFFU == fw.len);\n\n\tif (rpc) {\n\t\tif (fw.len) {\n\t\t\tif (fw.len > sizeof(self->rpc)) {\n\t\t\t\tprintk(KERN_INFO \"Invalid fw len: %x\\n\", fw.len);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\t\t\terr =\n\t\t\thw_atl_utils_fw_downld_dwords(self,\n\t\t\t\t\t\t      self->rpc_addr,\n\t\t\t\t\t\t      (u32 *)(void *)\n\t\t\t\t\t\t      &self->rpc,\n\t\t\t\t\t\t      (fw.len + sizeof(u32) -\n\t\t\t\t\t\t       sizeof(u8)) /\n\t\t\t\t\t\t      sizeof(u32));\n\t\t\tif (err < 0)\n\t\t\t\tgoto err_exit;\n\t\t}\n\n\t\t*rpc = &self->rpc;\n\t}\n\nerr_exit:\n\treturn err;\n}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "openssl",
    "cve_id": "CVE-2020-1971",
    "cwe_list": [
      "CWE-476"
    ],
    "commit_hash": "97ab3c4b538840037812c8d9164d09a1f4bf11a1",
    "short_hash": "97ab3c4b",
    "vulnerableMethods_before": [
      {
        "filename": "None",
        "method_name": "vulnerable_function",
        "raw_code": "int setup_tests(void)\n{\n    ADD_ALL_TESTS(call_run_cert, OSSL_NELEM(name_fns));\n    return 1;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "None",
        "method_name": "fixed_function",
        "raw_code": "int setup_tests(void)\n{\n    ADD_ALL_TESTS(call_run_cert, OSSL_NELEM(name_fns));\n    ADD_TEST(test_GENERAL_NAME_cmp);\n    return 1;\n}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "openldap",
    "cve_id": "CVE-2021-27212",
    "cwe_list": [
      "CWE-617"
    ],
    "commit_hash": "3539fc33212b528c56b716584f2c2994af7c30b0",
    "short_hash": "3539fc33",
    "vulnerableMethods_before": [
      {
        "filename": "schema_init.c",
        "method_name": "vulnerable_function",
        "raw_code": "issuerAndThisUpdateCheck(\n\tstruct berval *in,\n\tstruct berval *is,\n\tstruct berval *tu,\n\tvoid *ctx )\n{\n\tint numdquotes = 0;\n\tstruct berval x = *in;\n\tstruct berval ni = BER_BVNULL;\n\t/* Parse GSER format */ \n\tenum {\n\t\tHAVE_NONE = 0x0,\n\t\tHAVE_ISSUER = 0x1,\n\t\tHAVE_THISUPDATE = 0x2,\n\t\tHAVE_ALL = ( HAVE_ISSUER | HAVE_THISUPDATE )\n\t} have = HAVE_NONE;\n\n\n\tif ( in->bv_len < STRLENOF( \"{issuer \\\"\\\",thisUpdate \\\"YYMMDDhhmmssZ\\\"}\" ) ) return LDAP_INVALID_SYNTAX;\n\n\tif ( in->bv_val[0] != '{' || in->bv_val[in->bv_len-1] != '}' ) {\n\t\treturn LDAP_INVALID_SYNTAX;\n\t}\n\n\tx.bv_val++;\n\tx.bv_len -= STRLENOF(\"{}\");\n\n\tdo {\n\t\t/* eat leading spaces */\n\t\tfor ( ; (x.bv_val[0] == ' ') && x.bv_len; x.bv_val++, x.bv_len-- ) {\n\t\t\t/* empty */;\n\t\t}\n\n\t\t/* should be at issuer or thisUpdate */\n\t\tif ( strncasecmp( x.bv_val, \"issuer\", STRLENOF(\"issuer\") ) == 0 ) {\n\t\t\tif ( have & HAVE_ISSUER ) return LDAP_INVALID_SYNTAX;\n\n\t\t\t/* parse issuer */\n\t\t\tx.bv_val += STRLENOF(\"issuer\");\n\t\t\tx.bv_len -= STRLENOF(\"issuer\");\n\n\t\t\tif ( x.bv_val[0] != ' ' ) return LDAP_INVALID_SYNTAX;\n\t\t\tx.bv_val++;\n\t\t\tx.bv_len--;\n\n\t\t\t/* eat leading spaces */\n\t\t\tfor ( ; (x.bv_val[0] == ' ') && x.bv_len; x.bv_val++, x.bv_len-- ) {\n\t\t\t\t/* empty */;\n\t\t\t}\n\n\t\t\t/* For backward compatibility, this part is optional */\n\t\t\tif ( strncasecmp( x.bv_val, \"rdnSequence:\", STRLENOF(\"rdnSequence:\") ) != 0 ) {\n\t\t\t\treturn LDAP_INVALID_SYNTAX;\n\t\t\t}\n\t\t\tx.bv_val += STRLENOF(\"rdnSequence:\");\n\t\t\tx.bv_len -= STRLENOF(\"rdnSequence:\");\n\n\t\t\tif ( x.bv_val[0] != '\"' ) return LDAP_INVALID_SYNTAX;\n\t\t\tx.bv_val++;\n\t\t\tx.bv_len--;\n\n\t\t\tis->bv_val = x.bv_val;\n\t\t\tis->bv_len = 0;\n\n\t\t\tfor ( ; is->bv_len < x.bv_len; ) {\n\t\t\t\tif ( is->bv_val[is->bv_len] != '\"' ) {\n\t\t\t\t\tis->bv_len++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ( is->bv_val[is->bv_len+1] == '\"' ) {\n\t\t\t\t\t/* double dquote */\n\t\t\t\t\tnumdquotes++;\n\t\t\t\t\tis->bv_len += 2;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx.bv_val += is->bv_len + 1;\n\t\t\tx.bv_len -= is->bv_len + 1;\n\n\t\t\thave |= HAVE_ISSUER;\n\n\t\t} else if ( strncasecmp( x.bv_val, \"thisUpdate\", STRLENOF(\"thisUpdate\") ) == 0 )\n\t\t{\n\t\t\tif ( have & HAVE_THISUPDATE ) return LDAP_INVALID_SYNTAX;\n\n\t\t\t/* parse thisUpdate */\n\t\t\tx.bv_val += STRLENOF(\"thisUpdate\");\n\t\t\tx.bv_len -= STRLENOF(\"thisUpdate\");\n\n\t\t\tif ( x.bv_val[0] != ' ' ) return LDAP_INVALID_SYNTAX;\n\t\t\tx.bv_val++;\n\t\t\tx.bv_len--;\n\n\t\t\t/* eat leading spaces */\n\t\t\tfor ( ; (x.bv_val[0] == ' ') && x.bv_len; x.bv_val++, x.bv_len-- ) {\n\t\t\t\t/* empty */;\n\t\t\t}\n\n\t\t\tif ( !x.bv_len || x.bv_val[0] != '\"' ) return LDAP_INVALID_SYNTAX;\n\t\t\tx.bv_val++;\n\t\t\tx.bv_len--;\n\n\t\t\ttu->bv_val = x.bv_val;\n\t\t\ttu->bv_len = 0;\n\n\t\t\tfor ( ; tu->bv_len < x.bv_len; tu->bv_len++ ) {\n\t\t\t\tif ( tu->bv_val[tu->bv_len] == '\"' ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tx.bv_val += tu->bv_len + 1;\n\t\t\tx.bv_len -= tu->bv_len + 1;\n\n\t\t\thave |= HAVE_THISUPDATE;\n\n\t\t} else {\n\t\t\treturn LDAP_INVALID_SYNTAX;\n\t\t}\n\n\t\t/* eat leading spaces */\n\t\tfor ( ; (x.bv_val[0] == ' ') && x.bv_len; x.bv_val++, x.bv_len-- ) {\n\t\t\t/* empty */;\n\t\t}\n\n\t\tif ( have == HAVE_ALL ) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif ( x.bv_val[0] != ',' ) {\n\t\t\treturn LDAP_INVALID_SYNTAX;\n\t\t}\n\n\t\tx.bv_val++;\n\t\tx.bv_len--;\n\t} while ( 1 );\n\n\t/* should have no characters left... */\n\tif ( x.bv_len ) return LDAP_INVALID_SYNTAX;\n\n\tif ( numdquotes == 0 ) {\n\t\tber_dupbv_x( &ni, is, ctx );\n\n\t} else {\n\t\tber_len_t src, dst;\n\n\t\tni.bv_len = is->bv_len - numdquotes;\n\t\tni.bv_val = slap_sl_malloc( ni.bv_len + 1, ctx );\n\t\tfor ( src = 0, dst = 0; src < is->bv_len; src++, dst++ ) {\n\t\t\tif ( is->bv_val[src] == '\"' ) {\n\t\t\t\tsrc++;\n\t\t\t}\n\t\t\tni.bv_val[dst] = is->bv_val[src];\n\t\t}\n\t\tni.bv_val[dst] = '\\0';\n\t}\n\t\t\n\t*is = ni;\n\n\treturn 0;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "schema_init.c",
        "method_name": "fixed_function",
        "raw_code": "issuerAndThisUpdateCheck(\n\tstruct berval *in,\n\tstruct berval *is,\n\tstruct berval *tu,\n\tvoid *ctx )\n{\n\tint numdquotes = 0;\n\tstruct berval x = *in;\n\tstruct berval ni = BER_BVNULL;\n\t/* Parse GSER format */ \n\tenum {\n\t\tHAVE_NONE = 0x0,\n\t\tHAVE_ISSUER = 0x1,\n\t\tHAVE_THISUPDATE = 0x2,\n\t\tHAVE_ALL = ( HAVE_ISSUER | HAVE_THISUPDATE )\n\t} have = HAVE_NONE;\n\n\n\tif ( in->bv_len < STRLENOF( \"{issuer \\\"\\\",thisUpdate \\\"YYMMDDhhmmssZ\\\"}\" ) ) return LDAP_INVALID_SYNTAX;\n\n\tif ( in->bv_val[0] != '{' || in->bv_val[in->bv_len-1] != '}' ) {\n\t\treturn LDAP_INVALID_SYNTAX;\n\t}\n\n\tx.bv_val++;\n\tx.bv_len -= STRLENOF(\"{}\");\n\n\tdo {\n\t\t/* eat leading spaces */\n\t\tfor ( ; (x.bv_val[0] == ' ') && x.bv_len; x.bv_val++, x.bv_len-- ) {\n\t\t\t/* empty */;\n\t\t}\n\n\t\t/* should be at issuer or thisUpdate */\n\t\tif ( strncasecmp( x.bv_val, \"issuer\", STRLENOF(\"issuer\") ) == 0 ) {\n\t\t\tif ( have & HAVE_ISSUER ) return LDAP_INVALID_SYNTAX;\n\n\t\t\t/* parse issuer */\n\t\t\tx.bv_val += STRLENOF(\"issuer\");\n\t\t\tx.bv_len -= STRLENOF(\"issuer\");\n\n\t\t\tif ( x.bv_val[0] != ' ' ) return LDAP_INVALID_SYNTAX;\n\t\t\tx.bv_val++;\n\t\t\tx.bv_len--;\n\n\t\t\t/* eat leading spaces */\n\t\t\tfor ( ; (x.bv_val[0] == ' ') && x.bv_len; x.bv_val++, x.bv_len-- ) {\n\t\t\t\t/* empty */;\n\t\t\t}\n\n\t\t\t/* For backward compatibility, this part is optional */\n\t\t\tif ( strncasecmp( x.bv_val, \"rdnSequence:\", STRLENOF(\"rdnSequence:\") ) != 0 ) {\n\t\t\t\treturn LDAP_INVALID_SYNTAX;\n\t\t\t}\n\t\t\tx.bv_val += STRLENOF(\"rdnSequence:\");\n\t\t\tx.bv_len -= STRLENOF(\"rdnSequence:\");\n\n\t\t\tif ( x.bv_val[0] != '\"' ) return LDAP_INVALID_SYNTAX;\n\t\t\tx.bv_val++;\n\t\t\tx.bv_len--;\n\n\t\t\tis->bv_val = x.bv_val;\n\t\t\tis->bv_len = 0;\n\n\t\t\tfor ( ; is->bv_len < x.bv_len; ) {\n\t\t\t\tif ( is->bv_val[is->bv_len] != '\"' ) {\n\t\t\t\t\tis->bv_len++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ( is->bv_val[is->bv_len+1] == '\"' ) {\n\t\t\t\t\t/* double dquote */\n\t\t\t\t\tnumdquotes++;\n\t\t\t\t\tis->bv_len += 2;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx.bv_val += is->bv_len + 1;\n\t\t\tx.bv_len -= is->bv_len + 1;\n\n\t\t\thave |= HAVE_ISSUER;\n\n\t\t} else if ( strncasecmp( x.bv_val, \"thisUpdate\", STRLENOF(\"thisUpdate\") ) == 0 )\n\t\t{\n\t\t\tif ( have & HAVE_THISUPDATE ) return LDAP_INVALID_SYNTAX;\n\n\t\t\t/* parse thisUpdate */\n\t\t\tx.bv_val += STRLENOF(\"thisUpdate\");\n\t\t\tx.bv_len -= STRLENOF(\"thisUpdate\");\n\n\t\t\tif ( x.bv_val[0] != ' ' ) return LDAP_INVALID_SYNTAX;\n\t\t\tx.bv_val++;\n\t\t\tx.bv_len--;\n\n\t\t\t/* eat leading spaces */\n\t\t\tfor ( ; (x.bv_val[0] == ' ') && x.bv_len; x.bv_val++, x.bv_len-- ) {\n\t\t\t\t/* empty */;\n\t\t\t}\n\n\t\t\tif ( !x.bv_len || x.bv_val[0] != '\"' ) return LDAP_INVALID_SYNTAX;\n\t\t\tx.bv_val++;\n\t\t\tx.bv_len--;\n\n\t\t\ttu->bv_val = x.bv_val;\n\t\t\ttu->bv_len = 0;\n\n\t\t\tfor ( ; tu->bv_len < x.bv_len; tu->bv_len++ ) {\n\t\t\t\tif ( tu->bv_val[tu->bv_len] == '\"' ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( tu->bv_len < STRLENOF(\"YYYYmmddHHmmssZ\") ) return LDAP_INVALID_SYNTAX;\n\n\t\t\tx.bv_val += tu->bv_len + 1;\n\t\t\tx.bv_len -= tu->bv_len + 1;\n\n\t\t\thave |= HAVE_THISUPDATE;\n\n\t\t} else {\n\t\t\treturn LDAP_INVALID_SYNTAX;\n\t\t}\n\n\t\t/* eat leading spaces */\n\t\tfor ( ; (x.bv_val[0] == ' ') && x.bv_len; x.bv_val++, x.bv_len-- ) {\n\t\t\t/* empty */;\n\t\t}\n\n\t\tif ( have == HAVE_ALL ) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif ( x.bv_val[0] != ',' ) {\n\t\t\treturn LDAP_INVALID_SYNTAX;\n\t\t}\n\n\t\tx.bv_val++;\n\t\tx.bv_len--;\n\t} while ( 1 );\n\n\t/* should have no characters left... */\n\tif ( x.bv_len ) return LDAP_INVALID_SYNTAX;\n\n\tif ( numdquotes == 0 ) {\n\t\tber_dupbv_x( &ni, is, ctx );\n\n\t} else {\n\t\tber_len_t src, dst;\n\n\t\tni.bv_len = is->bv_len - numdquotes;\n\t\tni.bv_val = slap_sl_malloc( ni.bv_len + 1, ctx );\n\t\tfor ( src = 0, dst = 0; src < is->bv_len; src++, dst++ ) {\n\t\t\tif ( is->bv_val[src] == '\"' ) {\n\t\t\t\tsrc++;\n\t\t\t}\n\t\t\tni.bv_val[dst] = is->bv_val[src];\n\t\t}\n\t\tni.bv_val[dst] = '\\0';\n\t}\n\t\t\n\t*is = ni;\n\n\treturn 0;\n}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "tensorflow",
    "cve_id": "CVE-2022-23584",
    "cwe_list": [
      "CWE-416"
    ],
    "commit_hash": "e746adbfcfee15e9cfdb391ff746c765b99bdf9b",
    "short_hash": "e746adbf",
    "vulnerableMethods_before": [
      {
        "filename": "decode_image_op.cc",
        "method_name": "vulnerable_function",
        "raw_code": "  void DecodePngV2(OpKernelContext* context, StringPiece input) {\n    int channel_bits = (data_type_ == DataType::DT_UINT8) ? 8 : 16;\n    png::DecodeContext decode;\n    OP_REQUIRES(\n        context, png::CommonInitDecode(input, channels_, channel_bits, &decode),\n        errors::InvalidArgument(\"Invalid PNG. Failed to initialize decoder.\"));\n\n    // Verify that width and height are not too large:\n    // - verify width and height don't overflow int.\n    // - width can later be multiplied by channels_ and sizeof(uint16), so\n    //   verify single dimension is not too large.\n    // - verify when width and height are multiplied together, there are a few\n    //   bits to spare as well.\n    const int width = static_cast<int>(decode.width);\n    const int height = static_cast<int>(decode.height);\n    const int64_t total_size =\n        static_cast<int64_t>(width) * static_cast<int64_t>(height);\n    if (width != static_cast<int64_t>(decode.width) || width <= 0 ||\n        width >= (1LL << 27) || height != static_cast<int64_t>(decode.height) ||\n        height <= 0 || height >= (1LL << 27) || total_size >= (1LL << 29)) {\n      png::CommonFreeDecode(&decode);\n      OP_REQUIRES(context, false,\n                  errors::InvalidArgument(\"PNG size too large for int: \",\n                                          decode.width, \" by \", decode.height));\n    }\n\n    Tensor* output = nullptr;\n    Status status;\n    // By the existing API, we support decoding PNG with `DecodeGif` op.\n    // We need to make sure to return 4-D shapes when using `DecodeGif`.\n    if (op_type_ == \"DecodeGif\") {\n      status = context->allocate_output(\n          0, TensorShape({1, height, width, decode.channels}), &output);\n    } else {\n      status = context->allocate_output(\n          0, TensorShape({height, width, decode.channels}), &output);\n    }\n\n    if (op_type_ == \"DecodeBmp\") {\n      // TODO(b/171060723): Only DecodeBmp as op_type_ is not acceptable here\n      // because currently `decode_(jpeg|png|gif)` ops can decode any one of\n      // jpeg, png or gif but not bmp. Similarly, `decode_bmp` cannot decode\n      // anything but bmp formats. This behavior needs to be revisited. For more\n      // details, please refer to the bug.\n      OP_REQUIRES(context, false,\n                  errors::InvalidArgument(\n                      \"Trying to decode PNG format using DecodeBmp op. Use \"\n                      \"`decode_png` or `decode_image` instead.\"));\n    } else if (op_type_ == \"DecodeAndCropJpeg\") {\n      OP_REQUIRES(context, false,\n                  errors::InvalidArgument(\n                      \"DecodeAndCropJpeg operation can run on JPEG only, but \"\n                      \"detected PNG.\"));\n    }\n\n    if (!status.ok()) png::CommonFreeDecode(&decode);\n    OP_REQUIRES_OK(context, status);\n\n    if (data_type_ == DataType::DT_UINT8) {\n      OP_REQUIRES(\n          context,\n          png::CommonFinishDecode(\n              reinterpret_cast<png_bytep>(output->flat<uint8>().data()),\n              decode.channels * width * sizeof(uint8), &decode),\n          errors::InvalidArgument(\"Invalid PNG data, size \", input.size()));\n    } else if (data_type_ == DataType::DT_UINT16) {\n      OP_REQUIRES(\n          context,\n          png::CommonFinishDecode(\n              reinterpret_cast<png_bytep>(output->flat<uint16>().data()),\n              decode.channels * width * sizeof(uint16), &decode),\n          errors::InvalidArgument(\"Invalid PNG data, size \", input.size()));\n    } else if (data_type_ == DataType::DT_FLOAT) {\n      // `png::CommonFinishDecode` does not support `float`. First allocate\n      // uint16 buffer for the image and decode in uint16 (lossless). Wrap the\n      // buffer in `unique_ptr` so that we don't forget to delete the buffer.\n      std::unique_ptr<uint16[]> buffer(\n          new uint16[height * width * decode.channels]);\n      OP_REQUIRES(\n          context,\n          png::CommonFinishDecode(reinterpret_cast<png_bytep>(buffer.get()),\n                                  decode.channels * width * sizeof(uint16),\n                                  &decode),\n          errors::InvalidArgument(\"Invalid PNG data, size \", input.size()));\n\n      // Convert uint16 image data to desired data type.\n      // Use eigen threadpooling to speed up the copy operation.\n      const auto& device = context->eigen_device<Eigen::ThreadPoolDevice>();\n      TTypes<uint16, 3>::UnalignedConstTensor buf(buffer.get(), height, width,\n                                                  decode.channels);\n      float scale = 1. / std::numeric_limits<uint16>::max();\n      // Fill output tensor with desired dtype.\n      output->tensor<float, 3>().device(device) = buf.cast<float>() * scale;\n    }\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "decode_image_op.cc",
        "method_name": "fixed_function",
        "raw_code": "  void DecodePngV2(OpKernelContext* context, StringPiece input) {\n    int channel_bits = (data_type_ == DataType::DT_UINT8) ? 8 : 16;\n    png::DecodeContext decode;\n    OP_REQUIRES(\n        context, png::CommonInitDecode(input, channels_, channel_bits, &decode),\n        errors::InvalidArgument(\"Invalid PNG. Failed to initialize decoder.\"));\n\n    // Verify that width and height are not too large:\n    // - verify width and height don't overflow int.\n    // - width can later be multiplied by channels_ and sizeof(uint16), so\n    //   verify single dimension is not too large.\n    // - verify when width and height are multiplied together, there are a few\n    //   bits to spare as well.\n    const int width = static_cast<int>(decode.width);\n    const int height = static_cast<int>(decode.height);\n    const int64_t total_size =\n        static_cast<int64_t>(width) * static_cast<int64_t>(height);\n    if (width != static_cast<int64_t>(decode.width) || width <= 0 ||\n        width >= (1LL << 27) || height != static_cast<int64_t>(decode.height) ||\n        height <= 0 || height >= (1LL << 27) || total_size >= (1LL << 29)) {\n      OP_REQUIRES(context, false,\n                  errors::InvalidArgument(\"PNG size too large for int: \",\n                                          decode.width, \" by \", decode.height));\n    }\n\n    Tensor* output = nullptr;\n    Status status;\n    // By the existing API, we support decoding PNG with `DecodeGif` op.\n    // We need to make sure to return 4-D shapes when using `DecodeGif`.\n    if (op_type_ == \"DecodeGif\") {\n      status = context->allocate_output(\n          0, TensorShape({1, height, width, decode.channels}), &output);\n    } else {\n      status = context->allocate_output(\n          0, TensorShape({height, width, decode.channels}), &output);\n    }\n\n    if (op_type_ == \"DecodeBmp\") {\n      // TODO(b/171060723): Only DecodeBmp as op_type_ is not acceptable here\n      // because currently `decode_(jpeg|png|gif)` ops can decode any one of\n      // jpeg, png or gif but not bmp. Similarly, `decode_bmp` cannot decode\n      // anything but bmp formats. This behavior needs to be revisited. For more\n      // details, please refer to the bug.\n      OP_REQUIRES(context, false,\n                  errors::InvalidArgument(\n                      \"Trying to decode PNG format using DecodeBmp op. Use \"\n                      \"`decode_png` or `decode_image` instead.\"));\n    } else if (op_type_ == \"DecodeAndCropJpeg\") {\n      OP_REQUIRES(context, false,\n                  errors::InvalidArgument(\n                      \"DecodeAndCropJpeg operation can run on JPEG only, but \"\n                      \"detected PNG.\"));\n    }\n\n    if (!status.ok()) png::CommonFreeDecode(&decode);\n    OP_REQUIRES_OK(context, status);\n\n    if (data_type_ == DataType::DT_UINT8) {\n      OP_REQUIRES(\n          context,\n          png::CommonFinishDecode(\n              reinterpret_cast<png_bytep>(output->flat<uint8>().data()),\n              decode.channels * width * sizeof(uint8), &decode),\n          errors::InvalidArgument(\"Invalid PNG data, size \", input.size()));\n    } else if (data_type_ == DataType::DT_UINT16) {\n      OP_REQUIRES(\n          context,\n          png::CommonFinishDecode(\n              reinterpret_cast<png_bytep>(output->flat<uint16>().data()),\n              decode.channels * width * sizeof(uint16), &decode),\n          errors::InvalidArgument(\"Invalid PNG data, size \", input.size()));\n    } else if (data_type_ == DataType::DT_FLOAT) {\n      // `png::CommonFinishDecode` does not support `float`. First allocate\n      // uint16 buffer for the image and decode in uint16 (lossless). Wrap the\n      // buffer in `unique_ptr` so that we don't forget to delete the buffer.\n      std::unique_ptr<uint16[]> buffer(\n          new uint16[height * width * decode.channels]);\n      OP_REQUIRES(\n          context,\n          png::CommonFinishDecode(reinterpret_cast<png_bytep>(buffer.get()),\n                                  decode.channels * width * sizeof(uint16),\n                                  &decode),\n          errors::InvalidArgument(\"Invalid PNG data, size \", input.size()));\n\n      // Convert uint16 image data to desired data type.\n      // Use eigen threadpooling to speed up the copy operation.\n      const auto& device = context->eigen_device<Eigen::ThreadPoolDevice>();\n      TTypes<uint16, 3>::UnalignedConstTensor buf(buffer.get(), height, width,\n                                                  decode.channels);\n      float scale = 1. / std::numeric_limits<uint16>::max();\n      // Fill output tensor with desired dtype.\n      output->tensor<float, 3>().device(device) = buf.cast<float>() * scale;\n    }\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "tensorflow",
    "cve_id": "CVE-2021-37690",
    "cwe_list": [
      "CWE-369"
    ],
    "commit_hash": "ee119d4a498979525046fba1c3dd3f13a039fbb1",
    "short_hash": "ee119d4a",
    "vulnerableMethods_before": [
      {
        "filename": "None",
        "method_name": "vulnerable_function",
        "raw_code": "Status ShapeRefiner::InferShapesForFunctionSubNode(\n    const Node* node, InferenceContext* outer_context) {\n  TF_RETURN_IF_ERROR(AddNodeInternal(node, outer_context));\n  InferenceContext* node_context = CHECK_NOTNULL(GetContext(node));\n\n  if (StringPiece(node->type_string()) == kArgOp) {\n    // Handle special node: function input.\n    // Shapes for these nodes are provided in the outer inference\n    // context.\n\n    int index;\n    TF_RETURN_IF_ERROR(GetNodeAttr(AttrSlice(node->def()), \"index\", &index));\n\n    if (index < 0 || outer_context->num_inputs() <= index) {\n      return errors::Internal(\n          \"Function instantiation included invalid input index: \", index,\n          \" not in [0, \", outer_context->num_inputs(), \").\");\n    }\n\n    // TODO(b/134547156): TEMPORARY WORKAROUND. If input shape handle is not set\n    // in outer context, set _Arg node output shape to unknown.\n    if (outer_context->input(index).SameHandle(ShapeHandle())) {\n      VLOG(1) << \"Function instantiation has undefined input shape at \"\n              << \"index: \" << index << \" in the outer inference context.\";\n      node_context->set_output(0, node_context->UnknownShape());\n    } else {\n      node_context->set_output(0, outer_context->input(index));\n    }\n\n    auto* resource = outer_context->input_handle_shapes_and_types(index);\n    if (resource) {\n      node_context->set_output_handle_shapes_and_types(0, *resource);\n    }\n  } else if (StringPiece(node->type_string()) == kRetvalOp) {\n    // Handle special node: function output.\n    // Shapes inferred for these nodes go into the outer inference\n    // context.\n\n    int index;\n    TF_RETURN_IF_ERROR(GetNodeAttr(AttrSlice(node->def()), \"index\", &index));\n\n    if (index < 0 || outer_context->num_outputs() <= index) {\n      return errors::Internal(\n          \"Function instantiation included invalid output index: \", index,\n          \" not in [0, \", outer_context->num_outputs(), \").\");\n    }\n\n    // outer_context outlives node_context, therefore we need to create\n    // a new shape handle owned by outer_context instead.\n    ShapeHandle handle;\n    TensorShapeProto proto;\n    node_context->ShapeHandleToProto(node_context->input(0), &proto);\n    TF_RETURN_IF_ERROR(outer_context->MakeShapeFromShapeProto(proto, &handle));\n    outer_context->set_output(index, handle);\n\n    auto* resource = node_context->input_handle_shapes_and_types(0);\n    if (resource) {\n      outer_context->set_output_handle_shapes_and_types(index, *resource);\n    }\n  }\n\n  return Status::OK();\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "None",
        "method_name": "fixed_function",
        "raw_code": "Status ShapeRefiner::InferShapesForFunctionSubNode(\n    const Node* node, InferenceContext* outer_context) {\n  TF_RETURN_IF_ERROR(AddNodeInternal(node, outer_context));\n  InferenceContext* node_context = CHECK_NOTNULL(GetContext(node));\n\n  if (StringPiece(node->type_string()) == kArgOp) {\n    // Handle special node: function input.\n    // Shapes for these nodes are provided in the outer inference\n    // context.\n\n    int index;\n    TF_RETURN_IF_ERROR(GetNodeAttr(AttrSlice(node->def()), \"index\", &index));\n\n    if (index < 0 || outer_context->num_inputs() <= index) {\n      return errors::Internal(\n          \"Function instantiation included invalid input index: \", index,\n          \" not in [0, \", outer_context->num_inputs(), \").\");\n    }\n\n    // TODO(b/134547156): TEMPORARY WORKAROUND. If input shape handle is not set\n    // in outer context, set _Arg node output shape to unknown.\n    if (outer_context->input(index).SameHandle(ShapeHandle())) {\n      VLOG(1) << \"Function instantiation has undefined input shape at \"\n              << \"index: \" << index << \" in the outer inference context.\";\n      node_context->set_output(0, node_context->UnknownShape());\n    } else {\n      node_context->set_output(0, outer_context->input(index));\n    }\n\n    auto* resource = outer_context->input_handle_shapes_and_types(index);\n    if (resource) {\n      node_context->set_output_handle_shapes_and_types(0, *resource);\n    }\n  } else if (StringPiece(node->type_string()) == kRetvalOp) {\n    // Handle special node: function output.\n    // Shapes inferred for these nodes go into the outer inference\n    // context.\n\n    int index;\n    TF_RETURN_IF_ERROR(GetNodeAttr(AttrSlice(node->def()), \"index\", &index));\n\n    if (index < 0 || outer_context->num_outputs() <= index) {\n      return errors::Internal(\n          \"Function instantiation included invalid output index: \", index,\n          \" not in [0, \", outer_context->num_outputs(), \").\");\n    }\n\n    // outer_context outlives node_context, therefore we need to create\n    // a new shape handle owned by outer_context instead.\n    ShapeHandle handle;\n    TensorShapeProto proto;\n    node_context->ShapeHandleToProto(node_context->input(0), &proto);\n    TF_RETURN_IF_ERROR(outer_context->MakeShapeFromShapeProto(proto, &handle));\n    outer_context->set_output(index, handle);\n\n    const std::vector<ShapeAndType>* resource =\n        node_context->input_handle_shapes_and_types(0);\n    if (resource) {\n      // `ShapesAndType`s contain `ShapeHandle`s.  These `ShapeHandle`s point\n      // to `Shape`s that are owned by a different inference context too.  We\n      // need to copy them to the outer context to prevent them from being\n      // destroyed before they are used.\n      std::vector<ShapeAndType> copied_shapes_and_types;\n      for (auto& shape_and_type : *resource) {\n        ShapeHandle handle;\n        TensorShapeProto proto;\n        node_context->ShapeHandleToProto(shape_and_type.shape, &proto);\n        TF_RETURN_IF_ERROR(\n            outer_context->MakeShapeFromShapeProto(proto, &handle));\n        copied_shapes_and_types.push_back(\n            ShapeAndType(handle, shape_and_type.dtype, shape_and_type.type));\n      }\n\n      outer_context->set_output_handle_shapes_and_types(\n          index, copied_shapes_and_types);\n    }\n  }\n\n  return Status::OK();\n}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "ghostpdl",
    "cve_id": "CVE-2020-16287",
    "cwe_list": [
      "CWE-787"
    ],
    "commit_hash": "450da26a76286a8342ec0864b3d113856709f8f6",
    "short_hash": "450da26a",
    "vulnerableMethods_before": [
      {
        "filename": "gdevlprn.c",
        "method_name": "vulnerable_function",
        "raw_code": "lprn_is_black(gx_device_printer * pdev, int r, int h, int bx)\n{\n    gx_device_lprn *const lprn = (gx_device_lprn *) pdev;\n\n    int bh = lprn->nBh;\n    int bpl = gdev_mem_bytes_per_scan_line(pdev);\n    int x, y, y0;\n    byte *p;\n    int maxY = lprn->BlockLine / lprn->nBh * lprn->nBh;\n\n    y0 = (r + h - bh) % maxY;\n    for (y = 0; y < bh; y++) {\n        p = &lprn->ImageBuf[(y0 + y) * bpl + bx * lprn->nBw];\n        for (x = 0; x < lprn->nBw; x++)\n            if (p[x] != 0)\n                return 1;\n    }\n    return 0;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "gdevlprn.c",
        "method_name": "fixed_function",
        "raw_code": "lprn_is_black(gx_device_printer * pdev, int r, int h, int bx)\n{\n    gx_device_lprn *const lprn = (gx_device_lprn *) pdev;\n\n    int bh = lprn->nBh;\n    int bpl = gdev_mem_bytes_per_scan_line(pdev);\n    int x, y, y0;\n    byte *p;\n    int maxY = lprn->BlockLine / lprn->nBh * lprn->nBh;\n\n    y0 = (r + h - bh) % maxY;\n    for (y = 0; y < bh; y++) {\n        p = &lprn->ImageBuf[(y0 + y) * bpl + bx * lprn->nBw];\n        for (x = 0; x < lprn->nBw; x++) {\n            /* bpl isn't necessarily a multiple of lprn->nBw, so\n            we need to explicitly stop after the last byte in this\n            line to avoid accessing either the next line's data or\n            going off the end of our buffer completely. This avoids\n            https://bugs.ghostscript.com/show_bug.cgi?id=701785. */\n            if (bx * lprn->nBw + x >= bpl)  break;\n            if (p[x] != 0)\n                return 1;\n        }\n    }\n    return 0;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"gdevlprn.h\"\n\n// Type Definitions:\n// gx_device_lprn:\ntypedef struct gx_device_lprn_s gx_device_lprn;\n"
  },
  {
    "repository": "gimp",
    "cve_id": "CVE-2017-17784",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "c57f9dcf1934a9ab0cd67650f2dea18cb0902270",
    "short_hash": "c57f9dcf",
    "vulnerableMethods_before": [
      {
        "filename": "file-gbr.c",
        "method_name": "vulnerable_function",
        "raw_code": "load_image (const gchar  *filename,\n            GError      **error)\n{\n  gchar             *name;\n  gint               fd;\n  BrushHeader        bh;\n  guchar            *brush_buf = NULL;\n  gint32             image_ID;\n  gint32             layer_ID;\n  GimpParasite      *parasite;\n  GimpDrawable      *drawable;\n  GimpPixelRgn       pixel_rgn;\n  gint               bn_size;\n  GimpImageBaseType  base_type;\n  GimpImageType      image_type;\n  gsize              size;\n\n  fd = g_open (filename, O_RDONLY | _O_BINARY, 0);\n\n  if (fd == -1)\n    {\n      g_set_error (error, G_FILE_ERROR, g_file_error_from_errno (errno),\n                   _(\"Could not open '%s' for reading: %s\"),\n                   gimp_filename_to_utf8 (filename), g_strerror (errno));\n      return -1;\n    }\n\n  gimp_progress_init_printf (_(\"Opening '%s'\"),\n                             gimp_filename_to_utf8 (filename));\n\n  if (read (fd, &bh, sizeof (BrushHeader)) != sizeof (BrushHeader))\n    {\n      close (fd);\n      return -1;\n    }\n\n  /*  rearrange the bytes in each unsigned int  */\n  bh.header_size  = g_ntohl (bh.header_size);\n  bh.version      = g_ntohl (bh.version);\n  bh.width        = g_ntohl (bh.width);\n  bh.height       = g_ntohl (bh.height);\n  bh.bytes        = g_ntohl (bh.bytes);\n  bh.magic_number = g_ntohl (bh.magic_number);\n  bh.spacing      = g_ntohl (bh.spacing);\n\n  /* Sanitize values */\n  if ((bh.width == 0) || (bh.width > GIMP_MAX_IMAGE_SIZE) ||\n      (bh.height == 0) || (bh.height > GIMP_MAX_IMAGE_SIZE) ||\n      ((bh.bytes != 1) && (bh.bytes != 2) && (bh.bytes != 4) &&\n       (bh.bytes != 18)) ||\n      (G_MAXSIZE / bh.width / bh.height / bh.bytes < 1))\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"Invalid header data in '%s': width=%lu, height=%lu, \"\n                     \"bytes=%lu\"), gimp_filename_to_utf8 (filename),\n                   (unsigned long int)bh.width, (unsigned long int)bh.height,\n                   (unsigned long int)bh.bytes);\n      return -1;\n    }\n\n  switch (bh.version)\n    {\n    case 1:\n      /* Version 1 didn't have a magic number and had no spacing  */\n      bh.spacing = 25;\n      /* And we need to rewind the handle, 4 due spacing and 4 due magic */\n      lseek (fd, -8, SEEK_CUR);\n      bh.header_size += 8;\n      break;\n\n    case 3: /*  cinepaint brush  */\n      if (bh.bytes == 18 /* FLOAT16_GRAY_GIMAGE */)\n        {\n          bh.bytes = 2;\n        }\n      else\n        {\n          g_message (_(\"Unsupported brush format\"));\n          close (fd);\n          return -1;\n        }\n      /*  fallthrough  */\n\n    case 2:\n      if (bh.magic_number == GBRUSH_MAGIC &&\n          bh.header_size  >  sizeof (BrushHeader))\n        break;\n\n    default:\n      g_message (_(\"Unsupported brush format\"));\n      close (fd);\n      return -1;\n    }\n\n  if ((bn_size = (bh.header_size - sizeof (BrushHeader))) > 0)\n    {\n      gchar *temp = g_new (gchar, bn_size);\n\n      if ((read (fd, temp, bn_size)) < bn_size)\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"Error in GIMP brush file '%s'\"),\n                       gimp_filename_to_utf8 (filename));\n          close (fd);\n          g_free (temp);\n          return -1;\n        }\n\n      name = gimp_any_to_utf8 (temp, -1,\n                               _(\"Invalid UTF-8 string in brush file '%s'.\"),\n                               gimp_filename_to_utf8 (filename));\n      g_free (temp);\n    }\n  else\n    {\n      name = g_strdup (_(\"Unnamed\"));\n    }\n\n  /* Now there's just raw data left. */\n\n  size = bh.width * bh.height * bh.bytes;\n  brush_buf = g_malloc (size);\n\n  if (read (fd, brush_buf, size) != size)\n    {\n      close (fd);\n      g_free (brush_buf);\n      g_free (name);\n      return -1;\n    }\n\n  switch (bh.bytes)\n    {\n    case 1:\n      {\n        PatternHeader ph;\n\n        /*  For backwards-compatibility, check if a pattern follows.\n            The obsolete .gpb format did it this way.  */\n\n        if (read (fd, &ph, sizeof (PatternHeader)) == sizeof(PatternHeader))\n          {\n            /*  rearrange the bytes in each unsigned int  */\n            ph.header_size  = g_ntohl (ph.header_size);\n            ph.version      = g_ntohl (ph.version);\n            ph.width        = g_ntohl (ph.width);\n            ph.height       = g_ntohl (ph.height);\n            ph.bytes        = g_ntohl (ph.bytes);\n            ph.magic_number = g_ntohl (ph.magic_number);\n\n            if (ph.magic_number == GPATTERN_MAGIC        &&\n                ph.version      == 1                     &&\n                ph.header_size  > sizeof (PatternHeader) &&\n                ph.bytes        == 3                     &&\n                ph.width        == bh.width              &&\n                ph.height       == bh.height             &&\n                lseek (fd, ph.header_size - sizeof (PatternHeader),\n                       SEEK_CUR) > 0)\n              {\n                guchar *plain_brush = brush_buf;\n                gint    i;\n\n                bh.bytes = 4;\n                brush_buf = g_malloc (4 * bh.width * bh.height);\n\n                for (i = 0; i < ph.width * ph.height; i++)\n                  {\n                    if (read (fd, brush_buf + i * 4, 3) != 3)\n                      {\n                        close (fd);\n                        g_free (name);\n                        g_free (plain_brush);\n                        g_free (brush_buf);\n                        return -1;\n                      }\n                    brush_buf[i * 4 + 3] = plain_brush[i];\n                  }\n                g_free (plain_brush);\n              }\n          }\n      }\n      break;\n\n    case 2:\n      {\n        guint16 *buf = (guint16 *) brush_buf;\n        gint     i;\n\n        for (i = 0; i < bh.width * bh.height; i++, buf++)\n          {\n            union\n            {\n              guint16 u[2];\n              gfloat  f;\n            } short_float;\n\n#if G_BYTE_ORDER == G_LITTLE_ENDIAN\n            short_float.u[0] = 0;\n            short_float.u[1] = GUINT16_FROM_BE (*buf);\n#else\n            short_float.u[0] = GUINT16_FROM_BE (*buf);\n            short_float.u[1] = 0;\n#endif\n\n            brush_buf[i] = (guchar) (short_float.f * 255.0 + 0.5);\n          }\n\n        bh.bytes = 1;\n      }\n      break;\n\n    default:\n      break;\n    }\n\n  /*\n   * Create a new image of the proper size and\n   * associate the filename with it.\n   */\n\n  switch (bh.bytes)\n    {\n    case 1:\n      base_type = GIMP_GRAY;\n      image_type = GIMP_GRAY_IMAGE;\n      break;\n\n    case 4:\n      base_type = GIMP_RGB;\n      image_type = GIMP_RGBA_IMAGE;\n      break;\n\n    default:\n      g_message (\"Unsupported brush depth: %d\\n\"\n                 \"GIMP Brushes must be GRAY or RGBA\\n\",\n                 bh.bytes);\n      g_free (name);\n      return -1;\n    }\n\n  image_ID = gimp_image_new (bh.width, bh.height, base_type);\n  gimp_image_set_filename (image_ID, filename);\n\n  parasite = gimp_parasite_new (\"gimp-brush-name\",\n                                GIMP_PARASITE_PERSISTENT,\n                                strlen (name) + 1, name);\n  gimp_image_attach_parasite (image_ID, parasite);\n  gimp_parasite_free (parasite);\n\n  layer_ID = gimp_layer_new (image_ID, name, bh.width, bh.height,\n                             image_type, 100, GIMP_NORMAL_MODE);\n  gimp_image_insert_layer (image_ID, layer_ID, -1, 0);\n\n  g_free (name);\n\n  drawable = gimp_drawable_get (layer_ID);\n  gimp_pixel_rgn_init (&pixel_rgn, drawable,\n                       0, 0, drawable->width, drawable->height,\n                       TRUE, FALSE);\n\n  gimp_pixel_rgn_set_rect (&pixel_rgn, brush_buf,\n                           0, 0, bh.width, bh.height);\n  g_free (brush_buf);\n\n  if (image_type == GIMP_GRAY_IMAGE)\n    gimp_invert (layer_ID);\n\n  close (fd);\n\n  gimp_drawable_flush (drawable);\n  gimp_progress_update (1.0);\n\n  return image_ID;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "file-gbr.c",
        "method_name": "fixed_function",
        "raw_code": "load_image (const gchar  *filename,\n            GError      **error)\n{\n  gchar             *name;\n  gint               fd;\n  BrushHeader        bh;\n  guchar            *brush_buf = NULL;\n  gint32             image_ID;\n  gint32             layer_ID;\n  GimpParasite      *parasite;\n  GimpDrawable      *drawable;\n  GimpPixelRgn       pixel_rgn;\n  gint               bn_size;\n  GimpImageBaseType  base_type;\n  GimpImageType      image_type;\n  gsize              size;\n\n  fd = g_open (filename, O_RDONLY | _O_BINARY, 0);\n\n  if (fd == -1)\n    {\n      g_set_error (error, G_FILE_ERROR, g_file_error_from_errno (errno),\n                   _(\"Could not open '%s' for reading: %s\"),\n                   gimp_filename_to_utf8 (filename), g_strerror (errno));\n      return -1;\n    }\n\n  gimp_progress_init_printf (_(\"Opening '%s'\"),\n                             gimp_filename_to_utf8 (filename));\n\n  if (read (fd, &bh, sizeof (BrushHeader)) != sizeof (BrushHeader))\n    {\n      close (fd);\n      return -1;\n    }\n\n  /*  rearrange the bytes in each unsigned int  */\n  bh.header_size  = g_ntohl (bh.header_size);\n  bh.version      = g_ntohl (bh.version);\n  bh.width        = g_ntohl (bh.width);\n  bh.height       = g_ntohl (bh.height);\n  bh.bytes        = g_ntohl (bh.bytes);\n  bh.magic_number = g_ntohl (bh.magic_number);\n  bh.spacing      = g_ntohl (bh.spacing);\n\n  /* Sanitize values */\n  if ((bh.width == 0) || (bh.width > GIMP_MAX_IMAGE_SIZE) ||\n      (bh.height == 0) || (bh.height > GIMP_MAX_IMAGE_SIZE) ||\n      ((bh.bytes != 1) && (bh.bytes != 2) && (bh.bytes != 4) &&\n       (bh.bytes != 18)) ||\n      (G_MAXSIZE / bh.width / bh.height / bh.bytes < 1))\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"Invalid header data in '%s': width=%lu, height=%lu, \"\n                     \"bytes=%lu\"), gimp_filename_to_utf8 (filename),\n                   (unsigned long int)bh.width, (unsigned long int)bh.height,\n                   (unsigned long int)bh.bytes);\n      return -1;\n    }\n\n  switch (bh.version)\n    {\n    case 1:\n      /* Version 1 didn't have a magic number and had no spacing  */\n      bh.spacing = 25;\n      /* And we need to rewind the handle, 4 due spacing and 4 due magic */\n      lseek (fd, -8, SEEK_CUR);\n      bh.header_size += 8;\n      break;\n\n    case 3: /*  cinepaint brush  */\n      if (bh.bytes == 18 /* FLOAT16_GRAY_GIMAGE */)\n        {\n          bh.bytes = 2;\n        }\n      else\n        {\n          g_message (_(\"Unsupported brush format\"));\n          close (fd);\n          return -1;\n        }\n      /*  fallthrough  */\n\n    case 2:\n      if (bh.magic_number == GBRUSH_MAGIC &&\n          bh.header_size  >  sizeof (BrushHeader))\n        break;\n\n    default:\n      g_message (_(\"Unsupported brush format\"));\n      close (fd);\n      return -1;\n    }\n\n  if ((bn_size = (bh.header_size - sizeof (BrushHeader))) > 0)\n    {\n      gchar *temp = g_new (gchar, bn_size);\n\n      if ((read (fd, temp, bn_size)) < bn_size ||\n          temp[bn_size - 1] != '\\0')\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"Error in GIMP brush file '%s'\"),\n                       gimp_filename_to_utf8 (filename));\n          close (fd);\n          g_free (temp);\n          return -1;\n        }\n\n      name = gimp_any_to_utf8 (temp, -1,\n                               _(\"Invalid UTF-8 string in brush file '%s'.\"),\n                               gimp_filename_to_utf8 (filename));\n      g_free (temp);\n    }\n  else\n    {\n      name = g_strdup (_(\"Unnamed\"));\n    }\n\n  /* Now there's just raw data left. */\n\n  size = bh.width * bh.height * bh.bytes;\n  brush_buf = g_malloc (size);\n\n  if (read (fd, brush_buf, size) != size)\n    {\n      close (fd);\n      g_free (brush_buf);\n      g_free (name);\n      return -1;\n    }\n\n  switch (bh.bytes)\n    {\n    case 1:\n      {\n        PatternHeader ph;\n\n        /*  For backwards-compatibility, check if a pattern follows.\n            The obsolete .gpb format did it this way.  */\n\n        if (read (fd, &ph, sizeof (PatternHeader)) == sizeof(PatternHeader))\n          {\n            /*  rearrange the bytes in each unsigned int  */\n            ph.header_size  = g_ntohl (ph.header_size);\n            ph.version      = g_ntohl (ph.version);\n            ph.width        = g_ntohl (ph.width);\n            ph.height       = g_ntohl (ph.height);\n            ph.bytes        = g_ntohl (ph.bytes);\n            ph.magic_number = g_ntohl (ph.magic_number);\n\n            if (ph.magic_number == GPATTERN_MAGIC        &&\n                ph.version      == 1                     &&\n                ph.header_size  > sizeof (PatternHeader) &&\n                ph.bytes        == 3                     &&\n                ph.width        == bh.width              &&\n                ph.height       == bh.height             &&\n                lseek (fd, ph.header_size - sizeof (PatternHeader),\n                       SEEK_CUR) > 0)\n              {\n                guchar *plain_brush = brush_buf;\n                gint    i;\n\n                bh.bytes = 4;\n                brush_buf = g_malloc (4 * bh.width * bh.height);\n\n                for (i = 0; i < ph.width * ph.height; i++)\n                  {\n                    if (read (fd, brush_buf + i * 4, 3) != 3)\n                      {\n                        close (fd);\n                        g_free (name);\n                        g_free (plain_brush);\n                        g_free (brush_buf);\n                        return -1;\n                      }\n                    brush_buf[i * 4 + 3] = plain_brush[i];\n                  }\n                g_free (plain_brush);\n              }\n          }\n      }\n      break;\n\n    case 2:\n      {\n        guint16 *buf = (guint16 *) brush_buf;\n        gint     i;\n\n        for (i = 0; i < bh.width * bh.height; i++, buf++)\n          {\n            union\n            {\n              guint16 u[2];\n              gfloat  f;\n            } short_float;\n\n#if G_BYTE_ORDER == G_LITTLE_ENDIAN\n            short_float.u[0] = 0;\n            short_float.u[1] = GUINT16_FROM_BE (*buf);\n#else\n            short_float.u[0] = GUINT16_FROM_BE (*buf);\n            short_float.u[1] = 0;\n#endif\n\n            brush_buf[i] = (guchar) (short_float.f * 255.0 + 0.5);\n          }\n\n        bh.bytes = 1;\n      }\n      break;\n\n    default:\n      break;\n    }\n\n  /*\n   * Create a new image of the proper size and\n   * associate the filename with it.\n   */\n\n  switch (bh.bytes)\n    {\n    case 1:\n      base_type = GIMP_GRAY;\n      image_type = GIMP_GRAY_IMAGE;\n      break;\n\n    case 4:\n      base_type = GIMP_RGB;\n      image_type = GIMP_RGBA_IMAGE;\n      break;\n\n    default:\n      g_message (\"Unsupported brush depth: %d\\n\"\n                 \"GIMP Brushes must be GRAY or RGBA\\n\",\n                 bh.bytes);\n      g_free (name);\n      return -1;\n    }\n\n  image_ID = gimp_image_new (bh.width, bh.height, base_type);\n  gimp_image_set_filename (image_ID, filename);\n\n  parasite = gimp_parasite_new (\"gimp-brush-name\",\n                                GIMP_PARASITE_PERSISTENT,\n                                strlen (name) + 1, name);\n  gimp_image_attach_parasite (image_ID, parasite);\n  gimp_parasite_free (parasite);\n\n  layer_ID = gimp_layer_new (image_ID, name, bh.width, bh.height,\n                             image_type, 100, GIMP_NORMAL_MODE);\n  gimp_image_insert_layer (image_ID, layer_ID, -1, 0);\n\n  g_free (name);\n\n  drawable = gimp_drawable_get (layer_ID);\n  gimp_pixel_rgn_init (&pixel_rgn, drawable,\n                       0, 0, drawable->width, drawable->height,\n                       TRUE, FALSE);\n\n  gimp_pixel_rgn_set_rect (&pixel_rgn, brush_buf,\n                           0, 0, bh.width, bh.height);\n  g_free (brush_buf);\n\n  if (image_type == GIMP_GRAY_IMAGE)\n    gimp_invert (layer_ID);\n\n  close (fd);\n\n  gimp_drawable_flush (drawable);\n  gimp_progress_update (1.0);\n\n  return image_ID;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <glib/gstdio.h>\n#include <fcntl.h>\n#include <libgimp/gimp.h>\n#include <libgimp/gimpui.h>\n#include <string.h>\n#include <glib.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"app/core/gimppattern-header.h\"\n#include \"libgimp/stdplugins-intl.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"config.h\"\n#include <io.h>\n#include \"app/core/gimpbrush-header.h\"\n\n// Called Methods (top 10):\n// _O_BINARY from plug-ins/common/file-gbr.c:\n<empty>\n"
  },
  {
    "repository": "libvncserver",
    "cve_id": "CVE-2018-20020",
    "cwe_list": [
      "CWE-787"
    ],
    "commit_hash": "7b1ef0ffc4815cab9a96c7278394152bdc89dc4d",
    "short_hash": "7b1ef0ff",
    "vulnerableMethods_before": [
      {
        "filename": "corre.c",
        "method_name": "vulnerable_function",
        "raw_code": "HandleCoRREBPP (rfbClient* client, int rx, int ry, int rw, int rh)\n{\n    rfbRREHeader hdr;\n    int i;\n    CARDBPP pix;\n    uint8_t *ptr;\n    int x, y, w, h;\n\n    if (!ReadFromRFBServer(client, (char *)&hdr, sz_rfbRREHeader))\n\treturn FALSE;\n\n    hdr.nSubrects = rfbClientSwap32IfLE(hdr.nSubrects);\n\n    if (!ReadFromRFBServer(client, (char *)&pix, sizeof(pix)))\n\treturn FALSE;\n\n    client->GotFillRect(client, rx, ry, rw, rh, pix);\n\n    if (hdr.nSubrects * (4 + (BPP / 8)) > RFB_BUFFER_SIZE || !ReadFromRFBServer(client, client->buffer, hdr.nSubrects * (4 + (BPP / 8))))\n\treturn FALSE;\n\n    ptr = (uint8_t *)client->buffer;\n\n    for (i = 0; i < hdr.nSubrects; i++) {\n\tpix = *(CARDBPP *)ptr;\n\tptr += BPP/8;\n\tx = *ptr++;\n\ty = *ptr++;\n\tw = *ptr++;\n\th = *ptr++;\n\n\tclient->GotFillRect(client, rx+x, ry+y, w, h, pix);\n    }\n\n    return TRUE;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "corre.c",
        "method_name": "fixed_function",
        "raw_code": "HandleCoRREBPP (rfbClient* client, int rx, int ry, int rw, int rh)\n{\n    rfbRREHeader hdr;\n    int i;\n    CARDBPP pix;\n    uint8_t *ptr;\n    int x, y, w, h;\n\n    if (!ReadFromRFBServer(client, (char *)&hdr, sz_rfbRREHeader))\n\treturn FALSE;\n\n    hdr.nSubrects = rfbClientSwap32IfLE(hdr.nSubrects);\n\n    if (!ReadFromRFBServer(client, (char *)&pix, sizeof(pix)))\n\treturn FALSE;\n\n    client->GotFillRect(client, rx, ry, rw, rh, pix);\n\n    if (hdr.nSubrects > RFB_BUFFER_SIZE / (4 + (BPP / 8)) || !ReadFromRFBServer(client, client->buffer, hdr.nSubrects * (4 + (BPP / 8))))\n\treturn FALSE;\n\n    ptr = (uint8_t *)client->buffer;\n\n    for (i = 0; i < hdr.nSubrects; i++) {\n\tpix = *(CARDBPP *)ptr;\n\tptr += BPP/8;\n\tx = *ptr++;\n\ty = *ptr++;\n\tw = *ptr++;\n\th = *ptr++;\n\n\tclient->GotFillRect(client, rx+x, ry+y, w, h, pix);\n    }\n\n    return TRUE;\n}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "vim",
    "cve_id": "CVE-2022-2580",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "1e56bda9048a9625bce6e660938c834c5c15b07d",
    "short_hash": "1e56bda9",
    "vulnerableMethods_before": [
      {
        "filename": "typval.c",
        "method_name": "vulnerable_function",
        "raw_code": "eval_string(char_u **arg, typval_T *rettv, int evaluate, int interpolate)\n{\n    char_u\t*p;\n    char_u\t*end;\n    int\t\textra = interpolate ? 1 : 0;\n    int\t\toff = interpolate ? 0 : 1;\n    int\t\tlen;\n\n    // Find the end of the string, skipping backslashed characters.\n    for (p = *arg + off; *p != NUL && *p != '\"'; MB_PTR_ADV(p))\n    {\n\tif (*p == '\\\\' && p[1] != NUL)\n\t{\n\t    ++p;\n\t    // A \"\\<x>\" form occupies at least 4 characters, and produces up\n\t    // to 9 characters (6 for the char and 3 for a modifier):\n\t    // reserve space for 5 extra.\n\t    if (*p == '<')\n\t\textra += 5;\n\t}\n\telse if (interpolate && (*p == '{' || *p == '}'))\n\t{\n\t    if (*p == '{' && p[1] != '{') // start of expression\n\t\tbreak;\n\t    ++p;\n\t    if (p[-1] == '}' && *p != '}') // single '}' is an error\n\t    {\n\t\tsemsg(_(e_stray_closing_curly_str), *arg);\n\t\treturn FAIL;\n\t    }\n\t    --extra;  // \"{{\" becomes \"{\", \"}}\" becomes \"}\"\n\t}\n    }\n\n    if (*p != '\"' && !(interpolate && *p == '{'))\n    {\n\tsemsg(_(e_missing_double_quote_str), *arg);\n\treturn FAIL;\n    }\n\n    // If only parsing, set *arg and return here\n    if (!evaluate)\n    {\n\t*arg = p + off;\n\treturn OK;\n    }\n\n    // Copy the string into allocated memory, handling backslashed\n    // characters.\n    rettv->v_type = VAR_STRING;\n    len = (int)(p - *arg + extra);\n    rettv->vval.v_string = alloc(len);\n    if (rettv->vval.v_string == NULL)\n\treturn FAIL;\n    end = rettv->vval.v_string;\n\n    for (p = *arg + off; *p != NUL && *p != '\"'; )\n    {\n\tif (*p == '\\\\')\n\t{\n\t    switch (*++p)\n\t    {\n\t\tcase 'b': *end++ = BS; ++p; break;\n\t\tcase 'e': *end++ = ESC; ++p; break;\n\t\tcase 'f': *end++ = FF; ++p; break;\n\t\tcase 'n': *end++ = NL; ++p; break;\n\t\tcase 'r': *end++ = CAR; ++p; break;\n\t\tcase 't': *end++ = TAB; ++p; break;\n\n\t\tcase 'X': // hex: \"\\x1\", \"\\x12\"\n\t\tcase 'x':\n\t\tcase 'u': // Unicode: \"\\u0023\"\n\t\tcase 'U':\n\t\t\t  if (vim_isxdigit(p[1]))\n\t\t\t  {\n\t\t\t      int\tn, nr;\n\t\t\t      int\tc = toupper(*p);\n\n\t\t\t      if (c == 'X')\n\t\t\t\t  n = 2;\n\t\t\t      else if (*p == 'u')\n\t\t\t\t  n = 4;\n\t\t\t      else\n\t\t\t\t  n = 8;\n\t\t\t      nr = 0;\n\t\t\t      while (--n >= 0 && vim_isxdigit(p[1]))\n\t\t\t      {\n\t\t\t\t  ++p;\n\t\t\t\t  nr = (nr << 4) + hex2nr(*p);\n\t\t\t      }\n\t\t\t      ++p;\n\t\t\t      // For \"\\u\" store the number according to\n\t\t\t      // 'encoding'.\n\t\t\t      if (c != 'X')\n\t\t\t\t  end += (*mb_char2bytes)(nr, end);\n\t\t\t      else\n\t\t\t\t  *end++ = nr;\n\t\t\t  }\n\t\t\t  break;\n\n\t\t\t  // octal: \"\\1\", \"\\12\", \"\\123\"\n\t\tcase '0':\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '4':\n\t\tcase '5':\n\t\tcase '6':\n\t\tcase '7': *end = *p++ - '0';\n\t\t\t  if (*p >= '0' && *p <= '7')\n\t\t\t  {\n\t\t\t      *end = (*end << 3) + *p++ - '0';\n\t\t\t      if (*p >= '0' && *p <= '7')\n\t\t\t\t  *end = (*end << 3) + *p++ - '0';\n\t\t\t  }\n\t\t\t  ++end;\n\t\t\t  break;\n\n\t\t\t  // Special key, e.g.: \"\\<C-W>\"\n\t\tcase '<':\n\t\t\t  {\n\t\t\t      int flags = FSK_KEYCODE | FSK_IN_STRING;\n\n\t\t\t      if (p[1] != '*')\n\t\t\t\t  flags |= FSK_SIMPLIFY;\n\t\t\t      extra = trans_special(&p, end, flags, FALSE, NULL);\n\t\t\t      if (extra != 0)\n\t\t\t      {\n\t\t\t\t  end += extra;\n\t\t\t\t  if (end >= rettv->vval.v_string + len)\n\t\t\t\t      iemsg(\"eval_string() used more space than allocated\");\n\t\t\t\t  break;\n\t\t\t      }\n\t\t\t  }\n\t\t\t  // FALLTHROUGH\n\n\t\tdefault: MB_COPY_CHAR(p, end);\n\t\t\t  break;\n\t    }\n\t}\n\telse\n\t{\n\t    if (interpolate && (*p == '{' || *p == '}'))\n\t    {\n\t\tif (*p == '{' && p[1] != '{') // start of expression\n\t\t    break;\n\t\t++p;  // reduce \"{{\" to \"{\" and \"}}\" to \"}\"\n\t    }\n\t    MB_COPY_CHAR(p, end);\n\t}\n    }\n    *end = NUL;\n    if (*p == '\"' && !interpolate)\n\t++p;\n    *arg = p;\n\n    return OK;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "typval.c",
        "method_name": "fixed_function",
        "raw_code": "eval_string(char_u **arg, typval_T *rettv, int evaluate, int interpolate)\n{\n    char_u\t*p;\n    char_u\t*end;\n    int\t\textra = interpolate ? 1 : 0;\n    int\t\toff = interpolate ? 0 : 1;\n    int\t\tlen;\n\n    // Find the end of the string, skipping backslashed characters.\n    for (p = *arg + off; *p != NUL && *p != '\"'; MB_PTR_ADV(p))\n    {\n\tif (*p == '\\\\' && p[1] != NUL)\n\t{\n\t    ++p;\n\t    // A \"\\<x>\" form occupies at least 4 characters, and produces up\n\t    // to 9 characters (6 for the char and 3 for a modifier):\n\t    // reserve space for 5 extra.\n\t    if (*p == '<')\n\t    {\n\t\tint\t\tmodifiers = 0;\n\t\tint\t\tflags = FSK_KEYCODE | FSK_IN_STRING;\n\n\t\textra += 5;\n\n\t\t// Skip to the '>' to avoid using '{' inside for string\n\t\t// interpolation.\n\t\tif (p[1] != '*')\n\t\t    flags |= FSK_SIMPLIFY;\n\t\tif (find_special_key(&p, &modifiers, flags, NULL) != 0)\n\t\t    --p;  // leave \"p\" on the \">\"\n\t    }\n\t}\n\telse if (interpolate && (*p == '{' || *p == '}'))\n\t{\n\t    if (*p == '{' && p[1] != '{') // start of expression\n\t\tbreak;\n\t    ++p;\n\t    if (p[-1] == '}' && *p != '}') // single '}' is an error\n\t    {\n\t\tsemsg(_(e_stray_closing_curly_str), *arg);\n\t\treturn FAIL;\n\t    }\n\t    --extra;  // \"{{\" becomes \"{\", \"}}\" becomes \"}\"\n\t}\n    }\n\n    if (*p != '\"' && !(interpolate && *p == '{'))\n    {\n\tsemsg(_(e_missing_double_quote_str), *arg);\n\treturn FAIL;\n    }\n\n    // If only parsing, set *arg and return here\n    if (!evaluate)\n    {\n\t*arg = p + off;\n\treturn OK;\n    }\n\n    // Copy the string into allocated memory, handling backslashed\n    // characters.\n    rettv->v_type = VAR_STRING;\n    len = (int)(p - *arg + extra);\n    rettv->vval.v_string = alloc(len);\n    if (rettv->vval.v_string == NULL)\n\treturn FAIL;\n    end = rettv->vval.v_string;\n\n    for (p = *arg + off; *p != NUL && *p != '\"'; )\n    {\n\tif (*p == '\\\\')\n\t{\n\t    switch (*++p)\n\t    {\n\t\tcase 'b': *end++ = BS; ++p; break;\n\t\tcase 'e': *end++ = ESC; ++p; break;\n\t\tcase 'f': *end++ = FF; ++p; break;\n\t\tcase 'n': *end++ = NL; ++p; break;\n\t\tcase 'r': *end++ = CAR; ++p; break;\n\t\tcase 't': *end++ = TAB; ++p; break;\n\n\t\tcase 'X': // hex: \"\\x1\", \"\\x12\"\n\t\tcase 'x':\n\t\tcase 'u': // Unicode: \"\\u0023\"\n\t\tcase 'U':\n\t\t\t  if (vim_isxdigit(p[1]))\n\t\t\t  {\n\t\t\t      int\tn, nr;\n\t\t\t      int\tc = toupper(*p);\n\n\t\t\t      if (c == 'X')\n\t\t\t\t  n = 2;\n\t\t\t      else if (*p == 'u')\n\t\t\t\t  n = 4;\n\t\t\t      else\n\t\t\t\t  n = 8;\n\t\t\t      nr = 0;\n\t\t\t      while (--n >= 0 && vim_isxdigit(p[1]))\n\t\t\t      {\n\t\t\t\t  ++p;\n\t\t\t\t  nr = (nr << 4) + hex2nr(*p);\n\t\t\t      }\n\t\t\t      ++p;\n\t\t\t      // For \"\\u\" store the number according to\n\t\t\t      // 'encoding'.\n\t\t\t      if (c != 'X')\n\t\t\t\t  end += (*mb_char2bytes)(nr, end);\n\t\t\t      else\n\t\t\t\t  *end++ = nr;\n\t\t\t  }\n\t\t\t  break;\n\n\t\t\t  // octal: \"\\1\", \"\\12\", \"\\123\"\n\t\tcase '0':\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '4':\n\t\tcase '5':\n\t\tcase '6':\n\t\tcase '7': *end = *p++ - '0';\n\t\t\t  if (*p >= '0' && *p <= '7')\n\t\t\t  {\n\t\t\t      *end = (*end << 3) + *p++ - '0';\n\t\t\t      if (*p >= '0' && *p <= '7')\n\t\t\t\t  *end = (*end << 3) + *p++ - '0';\n\t\t\t  }\n\t\t\t  ++end;\n\t\t\t  break;\n\n\t\t\t  // Special key, e.g.: \"\\<C-W>\"\n\t\tcase '<':\n\t\t\t  {\n\t\t\t      int flags = FSK_KEYCODE | FSK_IN_STRING;\n\n\t\t\t      if (p[1] != '*')\n\t\t\t\t  flags |= FSK_SIMPLIFY;\n\t\t\t      extra = trans_special(&p, end, flags, FALSE, NULL);\n\t\t\t      if (extra != 0)\n\t\t\t      {\n\t\t\t\t  end += extra;\n\t\t\t\t  if (end >= rettv->vval.v_string + len)\n\t\t\t\t      iemsg(\"eval_string() used more space than allocated\");\n\t\t\t\t  break;\n\t\t\t      }\n\t\t\t  }\n\t\t\t  // FALLTHROUGH\n\n\t\tdefault: MB_COPY_CHAR(p, end);\n\t\t\t  break;\n\t    }\n\t}\n\telse\n\t{\n\t    if (interpolate && (*p == '{' || *p == '}'))\n\t    {\n\t\tif (*p == '{' && p[1] != '{') // start of expression\n\t\t    break;\n\t\t++p;  // reduce \"{{\" to \"{\" and \"}}\" to \"}\"\n\t    }\n\t    MB_COPY_CHAR(p, end);\n\t}\n    }\n    *end = NUL;\n    if (*p == '\"' && !interpolate)\n\t++p;\n    *arg = p;\n\n    return OK;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"vim.h\"\n\n// Type Definitions:\n// char_u:\ntypedef unsigned char\tchar_u;\n\n// typval_T:\ntypedef struct\n{\n    vartype_T\tv_type;\n    char\tv_lock;\t    // see below: VAR_LOCKED, VAR_FIXED\n    union\n    {\n\tvarnumber_T\tv_number;\t// number value\n#ifdef FEAT_FLOAT\n\tfloat_T\t\tv_float;\t// floating number value\n#endif\n\tchar_u\t\t*v_string;\t// string value (can be NULL!)\n\tlist_T\t\t*v_list;\t// list value (can be NULL!)\n\tdict_T\t\t*v_dict;\t// dict value (can be NULL!)\n\tpartial_T\t*v_partial;\t// closure: function with args\n#ifdef FEAT_JOB_CHANNEL\n\tjob_T\t\t*v_job;\t\t// job value (can be NULL!)\n\tchannel_T\t*v_channel;\t// channel value (can be NULL!)\n#endif\n\tblob_T\t\t*v_blob;\t// blob value (can be NULL!)\n\tinstr_T\t\t*v_instr;\t// instructions to execute\n    }\t\tvval;\n}\n\n// Called Methods (top 10):\n// trans_special from src/misc2.c:\nint\ntrans_special(\n    char_u\t**srcp,\n    char_u\t*dst,\n    int\t\tflags,\t\t// FSK_ values\n    int\t\tescape_ks,\t// escape K_SPECIAL bytes in the character\n    int\t\t*did_simplify)  // FSK_SIMPLIFY and found <C-H> or <A-x>\n{\n    int\t\tmodifiers = 0;\n    int\t\tkey;\n\n    key = find_special_key(srcp, &modifiers, flags, did_simplify);\n    if (key == 0)\n\treturn 0;\n\n    return special_to_buf(key, modifiers, escape_ks, dst);\n}\n\n// MB_PTR_ADV from src/macros.h:\n<empty>\n\n// alloc from src/alloc.c:\nvoid *\nalloc(size_t size)\n{\n    return lalloc(size, TRUE);\n}\n\n// CAR from src/ascii.h:\n<empty>\n\n// MB_COPY_CHAR from src/macros.h:\n<empty>\n\n// mb_copy_char from src/mbyte.c:\nvoid\nmb_copy_char(char_u **fp, char_u **tp)\n{\n    int\t    l = (*mb_ptr2len)(*fp);\n\n    mch_memmove(*tp, *fp, (size_t)l);\n    *tp += l;\n    *fp += l;\n}\n\n// semsg from src/message.c:\nint\nsemsg(const char *s, ...)\n{\n    // Skip this if not giving error messages at the moment.\n    if (!emsg_not_now())\n    {\n\tif (IObuff == NULL)\n\t{\n\t    // Very early in initialisation and already something wrong, just\n\t    // give the raw message so the user at least gets a hint.\n\t    return emsg_core((char_u *)s);\n\t}\n\telse\n\t{\n\t    va_list ap;\n\n\t    va_start(ap, s);\n\t    vim_vsnprintf((char *)IObuff, IOSIZE, s, ap);\n\t    va_end(ap);\n\t    return emsg_core(IObuff);\n\t}\n    }\n    return TRUE;\t\t// no error messages at the moment\n}\n\n// ESC from src/ascii.h:\n<empty>\n\n// iemsg from src/message.c:\nvoid\niemsg(char *s)\n{\n    if (!emsg_not_now())\n    {\n\temsg_core((char_u *)s);\n#if defined(ABORT_ON_INTERNAL_ERROR) && defined(FEAT_EVAL)\n\tset_vim_var_string(VV_ERRMSG, (char_u *)s, -1);\n\tabort();\n#endif\n    }\n}\n\n// FALSE from src/vim.h:\n<empty>\n"
  },
  {
    "repository": "ncurses",
    "cve_id": "CVE-2021-39537",
    "cwe_list": [
      "CWE-787"
    ],
    "commit_hash": "790a85dbd4a81d5f5d8dd02a44d84f01512ef443",
    "short_hash": "790a85db",
    "vulnerableMethods_before": [
      {
        "filename": "None",
        "method_name": "vulnerable_function",
        "raw_code": "cvtchar(register const char *sp)\n/* convert a character to a terminfo push */\n{\n    unsigned char c = 0;\n    int len;\n\n    switch (*sp) {\n    case '\\\\':\n\tswitch (*++sp) {\n\tcase '\\'':\n\tcase '$':\n\tcase '\\\\':\n\tcase '%':\n\t    c = UChar(*sp);\n\t    len = 2;\n\t    break;\n\tcase '\\0':\n\t    c = '\\\\';\n\t    len = 1;\n\t    break;\n\tcase '0':\n\tcase '1':\n\tcase '2':\n\tcase '3':\n\t    len = 1;\n\t    while (isdigit(UChar(*sp))) {\n\t\tc = UChar(8 * c + (*sp++ - '0'));\n\t\tlen++;\n\t    }\n\t    break;\n\tdefault:\n\t    c = UChar(*sp);\n\t    len = (c != '\\0') ? 2 : 1;\n\t    break;\n\t}\n\tbreak;\n    case '^':\n\tc = UChar(*++sp);\n\tif (c == '?')\n\t    c = 127;\n\telse\n\t    c &= 0x1f;\n\tlen = 2;\n\tbreak;\n    default:\n\tc = UChar(*sp);\n\tlen = (c != '\\0') ? 1 : 0;\n    }\n    if (isgraph(c) && c != ',' && c != '\\'' && c != '\\\\' && c != ':') {\n\tdp = save_string(dp, \"%\\'\");\n\tdp = save_char(dp, c);\n\tdp = save_char(dp, '\\'');\n    } else if (c != '\\0') {\n\tdp = save_string(dp, \"%{\");\n\tif (c > 99)\n\t    dp = save_char(dp, c / 100 + '0');\n\tif (c > 9)\n\t    dp = save_char(dp, ((int) (c / 10)) % 10 + '0');\n\tdp = save_char(dp, c % 10 + '0');\n\tdp = save_char(dp, '}');\n    }\n    return len;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "None",
        "method_name": "fixed_function",
        "raw_code": "cvtchar(register const char *sp)\n/* convert a character to a terminfo push */\n{\n    unsigned char c = 0;\n    int len;\n\n    switch (*sp) {\n    case '\\\\':\n\tswitch (*++sp) {\n\tcase '\\'':\n\tcase '$':\n\tcase '\\\\':\n\tcase '%':\n\t    c = UChar(*sp);\n\t    len = 2;\n\t    break;\n\tcase '\\0':\n\t    c = '\\\\';\n\t    len = 1;\n\t    break;\n\tcase '0':\n\tcase '1':\n\tcase '2':\n\tcase '3':\n\t    len = 1;\n\t    while (isdigit(UChar(*sp))) {\n\t\tc = UChar(8 * c + (*sp++ - '0'));\n\t\tlen++;\n\t    }\n\t    break;\n\tdefault:\n\t    c = UChar(*sp);\n\t    len = (c != '\\0') ? 2 : 1;\n\t    break;\n\t}\n\tbreak;\n    case '^':\n\tlen = 2;\n\tc = UChar(*++sp);\n\tif (c == '?') {\n\t    c = 127;\n\t} else if (c == '\\0') {\n\t    len = 1;\n\t} else {\n\t    c &= 0x1f;\n\t}\n\tbreak;\n    default:\n\tc = UChar(*sp);\n\tlen = (c != '\\0') ? 1 : 0;\n    }\n    if (isgraph(c) && c != ',' && c != '\\'' && c != '\\\\' && c != ':') {\n\tdp = save_string(dp, \"%\\'\");\n\tdp = save_char(dp, c);\n\tdp = save_char(dp, '\\'');\n    } else if (c != '\\0') {\n\tdp = save_string(dp, \"%{\");\n\tif (c > 99)\n\t    dp = save_char(dp, c / 100 + '0');\n\tif (c > 9)\n\t    dp = save_char(dp, ((int) (c / 10)) % 10 + '0');\n\tdp = save_char(dp, c % 10 + '0');\n\tdp = save_char(dp, '}');\n    }\n    return len;\n}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "linux",
    "cve_id": "CVE-2022-1195",
    "cwe_list": [
      "CWE-416"
    ],
    "commit_hash": "b2f37aead1b82a770c48b5d583f35ec22aabb61e",
    "short_hash": "b2f37aea",
    "vulnerableMethods_before": [
      {
        "filename": "mkiss.c",
        "method_name": "vulnerable_function",
        "raw_code": "static void mkiss_close(struct tty_struct *tty)\n{\n\tstruct mkiss *ax;\n\n\twrite_lock_irq(&disc_data_lock);\n\tax = tty->disc_data;\n\ttty->disc_data = NULL;\n\twrite_unlock_irq(&disc_data_lock);\n\n\tif (!ax)\n\t\treturn;\n\n\t/*\n\t * We have now ensured that nobody can start using ap from now on, but\n\t * we have to wait for all existing users to finish.\n\t */\n\tif (!refcount_dec_and_test(&ax->refcnt))\n\t\twait_for_completion(&ax->dead);\n\t/*\n\t * Halt the transmit queue so that a new transmit cannot scribble\n\t * on our buffers\n\t */\n\tnetif_stop_queue(ax->dev);\n\n\tax->tty = NULL;\n\n\tunregister_netdev(ax->dev);\n\n\t/* Free all AX25 frame buffers after unreg. */\n\tkfree(ax->rbuff);\n\tkfree(ax->xbuff);\n\n\tfree_netdev(ax->dev);\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "mkiss.c",
        "method_name": "fixed_function",
        "raw_code": "static void mkiss_close(struct tty_struct *tty)\n{\n\tstruct mkiss *ax;\n\n\twrite_lock_irq(&disc_data_lock);\n\tax = tty->disc_data;\n\ttty->disc_data = NULL;\n\twrite_unlock_irq(&disc_data_lock);\n\n\tif (!ax)\n\t\treturn;\n\n\t/*\n\t * We have now ensured that nobody can start using ap from now on, but\n\t * we have to wait for all existing users to finish.\n\t */\n\tif (!refcount_dec_and_test(&ax->refcnt))\n\t\twait_for_completion(&ax->dead);\n\t/*\n\t * Halt the transmit queue so that a new transmit cannot scribble\n\t * on our buffers\n\t */\n\tnetif_stop_queue(ax->dev);\n\n\tunregister_netdev(ax->dev);\n\n\t/* Free all AX25 frame buffers after unreg. */\n\tkfree(ax->rbuff);\n\tkfree(ax->xbuff);\n\n\tax->tty = NULL;\n\n\tfree_netdev(ax->dev);\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <linux/errno.h>\n#include <linux/jiffies.h>\n#include <linux/interrupt.h>\n#include <linux/uaccess.h>\n#include <linux/in.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/rtnetlink.h>\n#include <linux/inet.h>\n#include <linux/skbuff.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/tty.h>\n#include <linux/netdevice.h>\n#include <linux/refcount.h>\n#include <linux/string.h>\n#include <linux/bitops.h>\n#include <linux/crc16.h>\n#include <net/ax25.h>\n#include <linux/major.h>\n#include <linux/etherdevice.h>\n#include <linux/if_arp.h>\n\n// Type Definitions:\n// tty_struct:\nstruct tty_struct\n\n// mkiss:\nstruct mkiss {\n\tstruct tty_struct\t*tty;\t/* ptr to TTY structure\t\t*/\n\tstruct net_device\t*dev;\t/* easy for intr handling\t*/\n\n\t/* These are pointers to the malloc()ed frame buffers. */\n\tspinlock_t\t\tbuflock;/* lock for rbuf and xbuf */\n\tunsigned char\t\t*rbuff;\t/* receiver buffer\t\t*/\n\tint\t\t\trcount;\t/* received chars counter       */\n\tunsigned char\t\t*xbuff;\t/* transmitter buffer\t\t*/\n\tunsigned char\t\t*xhead;\t/* pointer to next byte to XMIT */\n\tint\t\t\txleft;\t/* bytes left in XMIT queue     */\n\n\t/* Detailed SLIP statistics. */\n\tint\t\tmtu;\t\t/* Our mtu (to spot changes!)   */\n\tint\t\tbuffsize;\t/* Max buffers sizes            */\n\n\tunsigned long\tflags;\t\t/* Flag values/ mode etc\t*/\n\t\t\t\t\t/* long req'd: used by set_bit --RR */\n#define AXF_INUSE\t0\t\t/* Channel in use               */\n#define AXF_ESCAPE\t1               /* ESC received                 */\n#define AXF_ERROR\t2               /* Parity, etc. error           */\n#define AXF_KEEPTEST\t3\t\t/* Keepalive test flag\t\t*/\n#define AXF_OUTWAIT\t4\t\t/* is outpack...\n"
  },
  {
    "repository": "tensorflow",
    "cve_id": "CVE-2021-41204",
    "cwe_list": [
      "CWE-824"
    ],
    "commit_hash": "7731e8dfbe4a56773be5dc94d631611211156659",
    "short_hash": "7731e8df",
    "vulnerableMethods_before": [
      {
        "filename": "constant_folding.cc",
        "method_name": "vulnerable_function",
        "raw_code": "bool IsConstantFoldable(\n    const Node* n,\n    const std::unordered_map<string, std::vector<PartialTensorShape>>*\n        shape_map,\n    const std::function<bool(const Node*)>& consider,\n    int64_t max_constant_size_in_bytes,\n    std::unordered_map<const Node*, std::vector<Tensor>>*\n        shape_replacement_map) {\n  if (n->IsConstant()) {\n    return true;\n  }\n  if (MaybeReplaceShapeOp(n, shape_map, shape_replacement_map)) {\n    return true;\n  }\n  if (n->op_def().is_stateful()) {\n    return false;\n  }\n  if (consider && !consider(n)) {\n    return false;\n  }\n  if (shape_map != nullptr) {\n    // We can skip the node if an output is known to be oversized.\n    auto shape_it = shape_map->find(n->name());\n    if (shape_it != shape_map->end()) {\n      for (int64_t i = 0; i < shape_it->second.size(); ++i) {\n        const auto& out_shape = shape_it->second[i];\n        if (out_shape.IsFullyDefined() &&\n            out_shape.num_elements() * DataTypeSize(n->output_type(i)) >\n                max_constant_size_in_bytes) {\n          return false;\n        }\n      }\n    }\n  }\n  if (n->IsControlFlow() || n->IsSend() || n->IsRecv()) {\n    return false;\n  }\n  // TODO(yuanbyu): For now disable these session handle operations.\n  if (n->IsGetSessionHandle() || n->IsGetSessionTensor() ||\n      n->IsDeleteSessionTensor()) {\n    return false;\n  }\n  if (n->IsSource()) {\n    return false;\n  }\n  if (n->IsSink()) {\n    return false;\n  }\n  if (n->IsFakeParam()) {\n    return false;\n  }\n  // Since constant-folding runs on the CPU, do not attempt to constant-fold\n  // operators that have no CPU kernel. Also implies that we will not\n  // constant-fold functions.\n  // TODO(phawkins): allow constant-folding for functions; functions may\n  // be arbitrarily expensive to execute.\n  if (!KernelDefAvailable(DeviceType(DEVICE_CPU), n->def())) {\n    return false;\n  }\n  // Do not constant fold nodes which will be allocated by ScopedAllocator.\n  // This is because the constant-folding graph will not contain the\n  // `_ScopedAllocator` node, and that is necessary to be able to run a node\n  // that will use this allocator.\n  if (n->attrs().Find(kScopedAllocatorAttrName) != nullptr) {\n    VLOG(2) << \"Skip node [\" << n->DebugString()\n            << \"] for constant folding due to scoped allocator\";\n    return false;\n  }\n  return true;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "constant_folding.cc",
        "method_name": "fixed_function",
        "raw_code": "bool IsConstantFoldable(\n    const Node* n,\n    const std::unordered_map<string, std::vector<PartialTensorShape>>*\n        shape_map,\n    const std::function<bool(const Node*)>& consider,\n    int64_t max_constant_size_in_bytes,\n    std::unordered_map<const Node*, std::vector<Tensor>>*\n        shape_replacement_map) {\n  if (n->IsConstant()) {\n    // Skip constant folding resources as they cannot be deep copied.\n    return n->output_type(0) != DT_RESOURCE;\n  }\n  if (MaybeReplaceShapeOp(n, shape_map, shape_replacement_map)) {\n    return true;\n  }\n  if (n->op_def().is_stateful()) {\n    return false;\n  }\n  if (consider && !consider(n)) {\n    return false;\n  }\n  if (shape_map != nullptr) {\n    // We can skip the node if an output is known to be oversized.\n    auto shape_it = shape_map->find(n->name());\n    if (shape_it != shape_map->end()) {\n      for (int64_t i = 0; i < shape_it->second.size(); ++i) {\n        const auto& out_shape = shape_it->second[i];\n        if (out_shape.IsFullyDefined() &&\n            out_shape.num_elements() * DataTypeSize(n->output_type(i)) >\n                max_constant_size_in_bytes) {\n          return false;\n        }\n      }\n    }\n  }\n  if (n->IsControlFlow() || n->IsSend() || n->IsRecv()) {\n    return false;\n  }\n  // TODO(yuanbyu): For now disable these session handle operations.\n  if (n->IsGetSessionHandle() || n->IsGetSessionTensor() ||\n      n->IsDeleteSessionTensor()) {\n    return false;\n  }\n  if (n->IsSource()) {\n    return false;\n  }\n  if (n->IsSink()) {\n    return false;\n  }\n  if (n->IsFakeParam()) {\n    return false;\n  }\n  // Since constant-folding runs on the CPU, do not attempt to constant-fold\n  // operators that have no CPU kernel. Also implies that we will not\n  // constant-fold functions.\n  // TODO(phawkins): allow constant-folding for functions; functions may\n  // be arbitrarily expensive to execute.\n  if (!KernelDefAvailable(DeviceType(DEVICE_CPU), n->def())) {\n    return false;\n  }\n  // Do not constant fold nodes which will be allocated by ScopedAllocator.\n  // This is because the constant-folding graph will not contain the\n  // `_ScopedAllocator` node, and that is necessary to be able to run a node\n  // that will use this allocator.\n  if (n->attrs().Find(kScopedAllocatorAttrName) != nullptr) {\n    VLOG(2) << \"Skip node [\" << n->DebugString()\n            << \"] for constant folding due to scoped allocator\";\n    return false;\n  }\n  return true;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <unordered_map>\n#include <algorithm>\n#include \"tensorflow/core/lib/strings/strcat.h\"\n#include \"tensorflow/core/common_runtime/function_utils.h\"\n#include \"tensorflow/core/common_runtime/device_factory.h\"\n#include <atomic>\n#include \"tensorflow/core/common_runtime/rendezvous_mgr.h\"\n#include \"tensorflow/core/lib/core/threadpool.h\"\n#include \"tensorflow/core/framework/types.pb.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/graph/algorithm.h\"\n#include \"tensorflow/core/platform/setround.h\"\n#include \"tensorflow/core/common_runtime/executor.h\"\n#include \"tensorflow/core/common_runtime/memory_types.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include <set>\n#include \"tensorflow/core/graph/node_builder.h\"\n#include \"tensorflow/core/graph/subgraph.h\"\n#include \"tensorflow/core/framework/log_memory.h\"\n#include \"tensorflow/core/common_runtime/constant_folding.h\"\n#include <vector>\n#include \"tensorflow/core/common_runtime/graph_runner.h\"\n#include \"tensorflow/core/public/session_options.h\"\n#include \"tensorflow/core/lib/gtl/flatset.h\"\n#include \"tensorflow/core/lib/gtl/cleanup.h\"\n#include \"tensorflow/core/platform/denormal.h\"\n\n// Type Definitions:\n// Node:\nclass Node {\n public:\n  // Arguments for `Node` constructor.\n  struct Args {\n    int64_t id;\n    string name;\n    std::shared_ptr<Node> output;\n  };\n\n  using Factory = std::function<std::shared_ptr<Node>(Args)>;\n  using NodeVector = std::vector<std::shared_ptr<Node>>;\n  using NodePairList =\n      std::list<std::pair<std::shared_ptr<Node>, std::shared_ptr<Node>>>;\n  using ModelParameters =\n      std::vector<std::pair<string, std::shared_ptr<Parameter>>>;\n  using NodeValues = absl::flat_hash_map<string, double>;\n  using ParameterGradients =\n      absl::flat_hash_map<std::pair<string, string>, double>;\n\n  explicit Node(Args args)\n      : id_(args.id),\n        name_(std::move(args.name)),\n        autotune_(true),\n        buffered_bytes_(0),\n        buffered_elements_(0),\n        bytes_consumed_(0),\n        bytes_produced_(0),\n        num_elements_(0),\n        processing_time_(0),\n        record_metrics_(true),\n        metrics_(name_),\n        output_(args.output.get()) {}\n\n  virtual ~No...\n\n// Node:\nclass Node\n"
  },
  {
    "repository": "njs",
    "cve_id": "CVE-2022-29379",
    "cwe_list": [
      "CWE-787"
    ],
    "commit_hash": "ab1702c7af9959366a5ddc4a75b4357d4e9ebdc1",
    "short_hash": "ab1702c7",
    "vulnerableMethods_before": [
      {
        "filename": "njs_module.c",
        "method_name": "vulnerable_function",
        "raw_code": "njs_module_path(njs_vm_t *vm, const njs_str_t *dir, njs_module_info_t *info)\n{\n    char        *p;\n    size_t      length;\n    njs_bool_t  trail;\n    char        src[NJS_MAX_PATH + 1];\n\n    trail = 0;\n    length = info->name.length;\n\n    if (dir != NULL) {\n        length = dir->length;\n\n        if (length == 0) {\n            return NJS_DECLINED;\n        }\n\n        trail = (dir->start[dir->length - 1] != '/');\n\n        if (trail) {\n            length++;\n        }\n    }\n\n    if (njs_slow_path(length > NJS_MAX_PATH)) {\n        return NJS_ERROR;\n    }\n\n    p = &src[0];\n\n    if (dir != NULL) {\n        p = (char *) njs_cpymem(p, dir->start, dir->length);\n\n        if (trail) {\n            *p++ = '/';\n        }\n    }\n\n    p = (char *) njs_cpymem(p, info->name.start, info->name.length);\n    *p = '\\0';\n\n    p = realpath(&src[0], &info->path[0]);\n    if (p == NULL) {\n        return NJS_DECLINED;\n    }\n\n    info->fd = open(&info->path[0], O_RDONLY);\n    if (info->fd < 0) {\n        return NJS_DECLINED;\n    }\n\n\n    info->file.start = (u_char *) &info->path[0];\n    info->file.length = njs_strlen(info->file.start);\n\n    return NJS_OK;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "njs_module.c",
        "method_name": "fixed_function",
        "raw_code": "njs_module_path(njs_vm_t *vm, const njs_str_t *dir, njs_module_info_t *info)\n{\n    char        *p;\n    size_t      length;\n    njs_bool_t  trail;\n    char        src[NJS_MAX_PATH + 1];\n\n    trail = 0;\n    length = info->name.length;\n\n    if (dir != NULL) {\n        length += dir->length;\n\n        if (length == 0) {\n            return NJS_DECLINED;\n        }\n\n        trail = (dir->start[dir->length - 1] != '/');\n\n        if (trail) {\n            length++;\n        }\n    }\n\n    if (njs_slow_path(length > NJS_MAX_PATH)) {\n        return NJS_ERROR;\n    }\n\n    p = &src[0];\n\n    if (dir != NULL) {\n        p = (char *) njs_cpymem(p, dir->start, dir->length);\n\n        if (trail) {\n            *p++ = '/';\n        }\n    }\n\n    p = (char *) njs_cpymem(p, info->name.start, info->name.length);\n    *p = '\\0';\n\n    p = realpath(&src[0], &info->path[0]);\n    if (p == NULL) {\n        return NJS_DECLINED;\n    }\n\n    info->fd = open(&info->path[0], O_RDONLY);\n    if (info->fd < 0) {\n        return NJS_DECLINED;\n    }\n\n\n    info->file.start = (u_char *) &info->path[0];\n    info->file.length = njs_strlen(info->file.start);\n\n    return NJS_OK;\n}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "linux",
    "cve_id": "CVE-2022-3170",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "5934d9a0383619c14df91af8fd76261dc3de2f5f",
    "short_hash": "5934d9a0",
    "vulnerableMethods_before": [
      {
        "filename": "control.c",
        "method_name": "vulnerable_function",
        "raw_code": "static unsigned long get_ctl_id_hash(const struct snd_ctl_elem_id *id)\n{\n\tint i;\n\tunsigned long h;\n\n\th = id->iface;\n\th = MULTIPLIER * h + id->device;\n\th = MULTIPLIER * h + id->subdevice;\n\tfor (i = 0; id->name[i] && i < SNDRV_CTL_ELEM_ID_NAME_MAXLEN; i++)\n\t\th = MULTIPLIER * h + id->name[i];\n\th = MULTIPLIER * h + id->index;\n\th &= LONG_MAX;\n\treturn h;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "control.c",
        "method_name": "fixed_function",
        "raw_code": "static unsigned long get_ctl_id_hash(const struct snd_ctl_elem_id *id)\n{\n\tint i;\n\tunsigned long h;\n\n\th = id->iface;\n\th = MULTIPLIER * h + id->device;\n\th = MULTIPLIER * h + id->subdevice;\n\tfor (i = 0; i < SNDRV_CTL_ELEM_ID_NAME_MAXLEN && id->name[i]; i++)\n\t\th = MULTIPLIER * h + id->name[i];\n\th = MULTIPLIER * h + id->index;\n\th &= LONG_MAX;\n\treturn h;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <sound/info.h>\n#include <linux/math64.h>\n#include <linux/moduleparam.h>\n#include <linux/slab.h>\n#include \"control_compat.c\"\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <sound/control.h>\n#include <linux/interrupt.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/threads.h>\n#include <sound/core.h>\n#include <sound/minors.h>\n"
  },
  {
    "repository": "pcre2",
    "cve_id": "CVE-2022-1586",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "d4fa336fbcc388f89095b184ba6d99422cfc676c",
    "short_hash": "d4fa336f",
    "vulnerableMethods_before": [
      {
        "filename": "pcre2_jit_compile.c",
        "method_name": "vulnerable_function",
        "raw_code": "static void compile_xclass_matchingpath(compiler_common *common, PCRE2_SPTR cc, jump_list **backtracks)\n{\nDEFINE_COMPILER;\njump_list *found = NULL;\njump_list **list = (cc[0] & XCL_NOT) == 0 ? &found : backtracks;\nsljit_uw c, charoffset, max = 256, min = READ_CHAR_MAX;\nstruct sljit_jump *jump = NULL;\nPCRE2_SPTR ccbegin;\nint compares, invertcmp, numberofcmps;\n#if defined SUPPORT_UNICODE && (PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16)\nBOOL utf = common->utf;\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == [8|16] */\n\n#ifdef SUPPORT_UNICODE\nsljit_u32 unicode_status = 0;\nint typereg = TMP1;\nconst sljit_u32 *other_cases;\nsljit_uw typeoffset;\n#endif /* SUPPORT_UNICODE */\n\n/* Scanning the necessary info. */\ncc++;\nccbegin = cc;\ncompares = 0;\n\nif (cc[-1] & XCL_MAP)\n  {\n  min = 0;\n  cc += 32 / sizeof(PCRE2_UCHAR);\n  }\n\nwhile (*cc != XCL_END)\n  {\n  compares++;\n  if (*cc == XCL_SINGLE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n    if (c > max) max = c;\n    if (c < min) min = c;\n#ifdef SUPPORT_UNICODE\n    unicode_status |= XCLASS_SAVE_CHAR;\n#endif /* SUPPORT_UNICODE */\n    }\n  else if (*cc == XCL_RANGE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n    if (c < min) min = c;\n    GETCHARINCTEST(c, cc);\n    if (c > max) max = c;\n#ifdef SUPPORT_UNICODE\n    unicode_status |= XCLASS_SAVE_CHAR;\n#endif /* SUPPORT_UNICODE */\n    }\n#ifdef SUPPORT_UNICODE\n  else\n    {\n    SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n    cc++;\n    if (*cc == PT_CLIST && *cc == XCL_PROP)\n      {\n      other_cases = PRIV(ucd_caseless_sets) + cc[1];\n      while (*other_cases != NOTACHAR)\n        {\n        if (*other_cases > max) max = *other_cases;\n        if (*other_cases < min) min = *other_cases;\n        other_cases++;\n        }\n      }\n    else\n      {\n      max = READ_CHAR_MAX;\n      min = 0;\n      }\n\n    switch(*cc)\n      {\n      case PT_ANY:\n      /* Any either accepts everything or ignored. */\n      if (cc[-1] == XCL_PROP)\n        {\n        compile_char1_matchingpath(common, OP_ALLANY, cc, backtracks, FALSE);\n        if (list == backtracks)\n          add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n        return;\n        }\n      break;\n\n      case PT_LAMP:\n      case PT_GC:\n      case PT_PC:\n      case PT_ALNUM:\n      unicode_status |= XCLASS_HAS_TYPE;\n      break;\n\n      case PT_SCX:\n      unicode_status |= XCLASS_HAS_SCRIPT_EXTENSION;\n      if (cc[-1] == XCL_NOTPROP)\n        {\n        unicode_status |= XCLASS_SCRIPT_EXTENSION_NOTPROP;\n        break;\n        }\n      compares++;\n      /* Fall through */ \n\n      case PT_SC:\n      unicode_status |= XCLASS_HAS_SCRIPT;\n      break;\n\n      case PT_SPACE:\n      case PT_PXSPACE:\n      case PT_WORD:\n      case PT_PXGRAPH:\n      case PT_PXPRINT:\n      case PT_PXPUNCT:\n      unicode_status |= XCLASS_SAVE_CHAR | XCLASS_HAS_TYPE;\n      break;\n\n      case PT_CLIST:\n      case PT_UCNC:\n      unicode_status |= XCLASS_SAVE_CHAR;\n      break;\n\n      case PT_BOOL:\n      unicode_status |= XCLASS_HAS_BOOL;\n      break;\n\n      case PT_BIDICL:\n      unicode_status |= XCLASS_HAS_BIDICL;\n      break;\n\n      default:\n      SLJIT_UNREACHABLE();\n      break;\n      }\n    cc += 2;\n    }\n#endif /* SUPPORT_UNICODE */\n  }\nSLJIT_ASSERT(compares > 0);\n\n/* We are not necessary in utf mode even in 8 bit mode. */\ncc = ccbegin;\nif ((cc[-1] & XCL_NOT) != 0)\n  read_char(common, min, max, backtracks, READ_CHAR_UPDATE_STR_PTR);\nelse\n  {\n#ifdef SUPPORT_UNICODE\n  read_char(common, min, max, (unicode_status & XCLASS_NEEDS_UCD) ? backtracks : NULL, 0);\n#else /* !SUPPORT_UNICODE */\n  read_char(common, min, max, NULL, 0);\n#endif /* SUPPORT_UNICODE */\n  }\n\nif ((cc[-1] & XCL_HASPROP) == 0)\n  {\n  if ((cc[-1] & XCL_MAP) != 0)\n    {\n    jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n    if (!optimize_class(common, (const sljit_u8 *)cc, (((const sljit_u8 *)cc)[31] & 0x80) != 0, TRUE, &found))\n      {\n      OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);\n      OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 3);\n      OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)cc);\n      OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);\n      OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP2, 0);\n      add_jump(compiler, &found, JUMP(SLJIT_NOT_ZERO));\n      }\n\n    add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n    JUMPHERE(jump);\n\n    cc += 32 / sizeof(PCRE2_UCHAR);\n    }\n  else\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, min);\n    add_jump(compiler, (cc[-1] & XCL_NOT) == 0 ? backtracks : &found, CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, max - min));\n    }\n  }\nelse if ((cc[-1] & XCL_MAP) != 0)\n  {\n  OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);\n#ifdef SUPPORT_UNICODE\n  unicode_status |= XCLASS_CHAR_SAVED;\n#endif /* SUPPORT_UNICODE */\n  if (!optimize_class(common, (const sljit_u8 *)cc, FALSE, TRUE, list))\n    {\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    jump = NULL;\n    if (common->utf)\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n      jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n\n    OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);\n    OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 3);\n    OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)cc);\n    OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);\n    OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP2, 0);\n    add_jump(compiler, list, JUMP(SLJIT_NOT_ZERO));\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    if (common->utf)\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n      JUMPHERE(jump);\n    }\n\n  OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);\n  cc += 32 / sizeof(PCRE2_UCHAR);\n  }\n\n#ifdef SUPPORT_UNICODE\nif (unicode_status & XCLASS_NEEDS_UCD)\n  {\n  if ((unicode_status & (XCLASS_SAVE_CHAR | XCLASS_CHAR_SAVED)) == XCLASS_SAVE_CHAR)\n    OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);\n\n#if PCRE2_CODE_UNIT_WIDTH == 32\n  if (!common->utf)\n    {\n    jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, MAX_UTF_CODE_POINT + 1);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, UNASSIGNED_UTF_CHAR);\n    JUMPHERE(jump);\n    }\n#endif /* PCRE2_CODE_UNIT_WIDTH == 32 */\n\n  OP2(SLJIT_LSHR, TMP2, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 1);\n  OP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_stage1));\n  OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_MASK);\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, (sljit_sw)PRIV(ucd_stage2));\n  OP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM2(TMP2, TMP1), 1);\n  OP2(SLJIT_SHL, TMP1, 0, TMP2, 0, SLJIT_IMM, 3);\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 2);\n  OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);\n\n  ccbegin = cc;\n\n  if (unicode_status & XCLASS_HAS_BIDICL)\n    {\n    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, scriptx_bidiclass));\n    OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BIDICLASS_SHIFT);\n\n    while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n        if (*cc == PT_BIDICL)\n          {\n          compares--;\n          invertcmp = (compares == 0 && list != backtracks);\n          if (cc[-1] == XCL_NOTPROP)\n            invertcmp ^= 0x1;\n          jump = CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (int)cc[1]);\n          add_jump(compiler, compares > 0 ? list : backtracks, jump);\n          }\n        cc += 2;\n        }\n      }\n\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_HAS_BOOL)\n    {\n    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, bprops));\n    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BPROPS_MASK);\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 2);\n\n    while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n        if (*cc == PT_BOOL)\n          {\n          compares--;\n          invertcmp = (compares == 0 && list != backtracks);\n          if (cc[-1] == XCL_NOTPROP)\n            invertcmp ^= 0x1;\n\n          OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP1), (sljit_sw)(PRIV(ucd_boolprop_sets) + (cc[1] >> 5)), SLJIT_IMM, (sljit_sw)1 << (cc[1] & 0x1f));\n          add_jump(compiler, compares > 0 ? list : backtracks, JUMP(SLJIT_NOT_ZERO ^ invertcmp));\n          }\n        cc += 2;\n        }\n      }\n\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_HAS_SCRIPT)\n    {\n    OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, script));\n\n    while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n        switch (*cc)\n          {\n          case PT_SCX:\n          if (cc[-1] == XCL_NOTPROP)\n            break;\n          /* Fall through */ \n\n          case PT_SC:\n          compares--;\n          invertcmp = (compares == 0 && list != backtracks);\n          if (cc[-1] == XCL_NOTPROP)\n            invertcmp ^= 0x1;\n\n          add_jump(compiler, compares > 0 ? list : backtracks, CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (int)cc[1]));\n          }\n        cc += 2;\n        }\n      }\n\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_HAS_SCRIPT_EXTENSION)\n    {\n    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, scriptx_bidiclass));\n    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_SCRIPTX_MASK);\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 2);\n\n    if (unicode_status & XCLASS_SCRIPT_EXTENSION_NOTPROP)\n      {\n      if (unicode_status & XCLASS_HAS_TYPE)\n        {\n        if (unicode_status & XCLASS_SAVE_CHAR)\n          {\n          OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS0, TMP2, 0);\n          unicode_status |= XCLASS_SCRIPT_EXTENSION_RESTORE_LOCALS0;\n          }\n        else\n          {\n          OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP2, 0);\n          unicode_status |= XCLASS_SCRIPT_EXTENSION_RESTORE_RETURN_ADDR;\n          }\n        }\n      OP1(SLJIT_MOV_U8, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, script));\n      }\n\n    while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n        if (*cc == PT_SCX)\n          {\n          compares--;\n          invertcmp = (compares == 0 && list != backtracks);\n\n          jump = NULL;\n          if (cc[-1] == XCL_NOTPROP)\n            {\n            jump = CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, (int)cc[1]);\n            if (invertcmp)\n              {\n              add_jump(compiler, backtracks, jump);\n              jump = NULL;\n              }\n            invertcmp ^= 0x1;\n            }\n\n          OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP1), (sljit_sw)(PRIV(ucd_script_sets) + (cc[1] >> 5)), SLJIT_IMM, (sljit_sw)1 << (cc[1] & 0x1f));\n          add_jump(compiler, compares > 0 ? list : backtracks, JUMP(SLJIT_NOT_ZERO ^ invertcmp));\n\n          if (jump != NULL)\n            JUMPHERE(jump);\n          }\n        cc += 2;\n        }\n      }\n\n    if (unicode_status & XCLASS_SCRIPT_EXTENSION_RESTORE_LOCALS0)\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n    else if (unicode_status & XCLASS_SCRIPT_EXTENSION_RESTORE_RETURN_ADDR)\n      OP1(SLJIT_MOV, TMP2, 0, RETURN_ADDR, 0);\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_SAVE_CHAR)\n    OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);\n\n  if (unicode_status & XCLASS_HAS_TYPE)\n    {\n    if (unicode_status & XCLASS_SAVE_CHAR)\n      typereg = RETURN_ADDR;\n\n    OP1(SLJIT_MOV_U8, typereg, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, chartype));\n    }\n  }\n#endif /* SUPPORT_UNICODE */\n\n/* Generating code. */\ncharoffset = 0;\nnumberofcmps = 0;\n#ifdef SUPPORT_UNICODE\ntypeoffset = 0;\n#endif /* SUPPORT_UNICODE */\n\nwhile (*cc != XCL_END)\n  {\n  compares--;\n  invertcmp = (compares == 0 && list != backtracks);\n  jump = NULL;\n\n  if (*cc == XCL_SINGLE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n\n    if (numberofcmps < 3 && (*cc == XCL_SINGLE || *cc == XCL_RANGE))\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(numberofcmps == 0 ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n      numberofcmps++;\n      }\n    else if (numberofcmps > 0)\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      numberofcmps = 0;\n      }\n    else\n      {\n      jump = CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      numberofcmps = 0;\n      }\n    }\n  else if (*cc == XCL_RANGE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n    SET_CHAR_OFFSET(c);\n    GETCHARINCTEST(c, cc);\n\n    if (numberofcmps < 3 && (*cc == XCL_SINGLE || *cc == XCL_RANGE))\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(numberofcmps == 0 ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n      numberofcmps++;\n      }\n    else if (numberofcmps > 0)\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      numberofcmps = 0;\n      }\n    else\n      {\n      jump = CMP(SLJIT_LESS_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      numberofcmps = 0;\n      }\n    }\n#ifdef SUPPORT_UNICODE\n  else\n    {\n    SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n    if (*cc == XCL_NOTPROP)\n      invertcmp ^= 0x1;\n    cc++;\n    switch(*cc)\n      {\n      case PT_ANY:\n      if (!invertcmp)\n        jump = JUMP(SLJIT_JUMP);\n      break;\n\n      case PT_LAMP:\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Lu - typeoffset);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Ll - typeoffset);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Lt - typeoffset);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_GC:\n      c = PRIV(ucp_typerange)[(int)cc[1] * 2];\n      SET_TYPE_OFFSET(c);\n      jump = CMP(SLJIT_LESS_EQUAL ^ invertcmp, typereg, 0, SLJIT_IMM, PRIV(ucp_typerange)[(int)cc[1] * 2 + 1] - c);\n      break;\n\n      case PT_PC:\n      jump = CMP(SLJIT_EQUAL ^ invertcmp, typereg, 0, SLJIT_IMM, (int)cc[1] - typeoffset);\n      break;\n\n      case PT_SC:\n      case PT_SCX:\n      case PT_BOOL:\n      case PT_BIDICL:\n      compares++;\n      /* Do nothing. */\n      break;\n\n      case PT_SPACE:\n      case PT_PXSPACE:\n      SET_CHAR_OFFSET(9);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0xd - 0x9);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x85 - 0x9);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x180e - 0x9);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      SET_TYPE_OFFSET(ucp_Zl);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Zs - ucp_Zl);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_WORD:\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_UNDERSCORE - charoffset));\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n      /* Fall through. */\n\n      case PT_ALNUM:\n      SET_TYPE_OFFSET(ucp_Ll);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Lu - ucp_Ll);\n      OP_FLAGS((*cc == PT_ALNUM) ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n      SET_TYPE_OFFSET(ucp_Nd);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_No - ucp_Nd);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_CLIST:\n      other_cases = PRIV(ucd_caseless_sets) + cc[1];\n\n      /* At least three characters are required.\n         Otherwise this case would be handled by the normal code path. */\n      SLJIT_ASSERT(other_cases[0] != NOTACHAR && other_cases[1] != NOTACHAR && other_cases[2] != NOTACHAR);\n      SLJIT_ASSERT(other_cases[0] < other_cases[1] && other_cases[1] < other_cases[2]);\n\n      /* Optimizing character pairs, if their difference is power of 2. */\n      if (is_powerof2(other_cases[1] ^ other_cases[0]))\n        {\n        if (charoffset == 0)\n          OP2(SLJIT_OR, TMP2, 0, TMP1, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);\n        else\n          {\n          OP2(SLJIT_ADD, TMP2, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)charoffset);\n          OP2(SLJIT_OR, TMP2, 0, TMP2, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);\n          }\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, other_cases[1]);\n        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n        other_cases += 2;\n        }\n      else if (is_powerof2(other_cases[2] ^ other_cases[1]))\n        {\n        if (charoffset == 0)\n          OP2(SLJIT_OR, TMP2, 0, TMP1, 0, SLJIT_IMM, other_cases[2] ^ other_cases[1]);\n        else\n          {\n          OP2(SLJIT_ADD, TMP2, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)charoffset);\n          OP2(SLJIT_OR, TMP2, 0, TMP2, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);\n          }\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, other_cases[2]);\n        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(other_cases[0] - charoffset));\n        OP_FLAGS(SLJIT_OR | ((other_cases[3] == NOTACHAR) ? SLJIT_SET_Z : 0), TMP2, 0, SLJIT_EQUAL);\n\n        other_cases += 3;\n        }\n      else\n        {\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(*other_cases++ - charoffset));\n        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n        }\n\n      while (*other_cases != NOTACHAR)\n        {\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(*other_cases++ - charoffset));\n        OP_FLAGS(SLJIT_OR | ((*other_cases == NOTACHAR) ? SLJIT_SET_Z : 0), TMP2, 0, SLJIT_EQUAL);\n        }\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_UCNC:\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_DOLLAR_SIGN - charoffset));\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_COMMERCIAL_AT - charoffset));\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_GRAVE_ACCENT - charoffset));\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      SET_CHAR_OFFSET(0xa0);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw)(0xd7ff - charoffset));\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n      SET_CHAR_OFFSET(0);\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xe000 - 0);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_GREATER_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_PXGRAPH:\n      /* C and Z groups are the farthest two groups. */\n      SET_TYPE_OFFSET(ucp_Ll);\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER, typereg, 0, SLJIT_IMM, ucp_So - ucp_Ll);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_GREATER);\n\n      jump = CMP(SLJIT_NOT_EQUAL, typereg, 0, SLJIT_IMM, ucp_Cf - ucp_Ll);\n\n      /* In case of ucp_Cf, we overwrite the result. */\n      SET_CHAR_OFFSET(0x2066);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x2069 - 0x2066);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x061c - 0x2066);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x180e - 0x2066);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      JUMPHERE(jump);\n      jump = CMP(SLJIT_ZERO ^ invertcmp, TMP2, 0, SLJIT_IMM, 0);\n      break;\n\n      case PT_PXPRINT:\n      /* C and Z groups are the farthest two groups. */\n      SET_TYPE_OFFSET(ucp_Ll);\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER, typereg, 0, SLJIT_IMM, ucp_So - ucp_Ll);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_GREATER);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Zs - ucp_Ll);\n      OP_FLAGS(SLJIT_AND, TMP2, 0, SLJIT_NOT_EQUAL);\n\n      jump = CMP(SLJIT_NOT_EQUAL, typereg, 0, SLJIT_IMM, ucp_Cf - ucp_Ll);\n\n      /* In case of ucp_Cf, we overwrite the result. */\n      SET_CHAR_OFFSET(0x2066);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x2069 - 0x2066);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x061c - 0x2066);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      JUMPHERE(jump);\n      jump = CMP(SLJIT_ZERO ^ invertcmp, TMP2, 0, SLJIT_IMM, 0);\n      break;\n\n      case PT_PXPUNCT:\n      SET_TYPE_OFFSET(ucp_Sc);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_So - ucp_Sc);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      SET_CHAR_OFFSET(0);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x7f);\n      OP_FLAGS(SLJIT_AND, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      SET_TYPE_OFFSET(ucp_Pc);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Ps - ucp_Pc);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      default:\n      SLJIT_UNREACHABLE();\n      break;\n      }\n    cc += 2;\n    }\n#endif /* SUPPORT_UNICODE */\n\n  if (jump != NULL)\n    add_jump(compiler, compares > 0 ? list : backtracks, jump);\n  }\n\nif (found != NULL)\n  set_jumps(found, LABEL());\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "pcre2_jit_compile.c",
        "method_name": "fixed_function",
        "raw_code": "static void compile_xclass_matchingpath(compiler_common *common, PCRE2_SPTR cc, jump_list **backtracks)\n{\nDEFINE_COMPILER;\njump_list *found = NULL;\njump_list **list = (cc[0] & XCL_NOT) == 0 ? &found : backtracks;\nsljit_uw c, charoffset, max = 256, min = READ_CHAR_MAX;\nstruct sljit_jump *jump = NULL;\nPCRE2_SPTR ccbegin;\nint compares, invertcmp, numberofcmps;\n#if defined SUPPORT_UNICODE && (PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16)\nBOOL utf = common->utf;\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == [8|16] */\n\n#ifdef SUPPORT_UNICODE\nsljit_u32 unicode_status = 0;\nint typereg = TMP1;\nconst sljit_u32 *other_cases;\nsljit_uw typeoffset;\n#endif /* SUPPORT_UNICODE */\n\n/* Scanning the necessary info. */\ncc++;\nccbegin = cc;\ncompares = 0;\n\nif (cc[-1] & XCL_MAP)\n  {\n  min = 0;\n  cc += 32 / sizeof(PCRE2_UCHAR);\n  }\n\nwhile (*cc != XCL_END)\n  {\n  compares++;\n  if (*cc == XCL_SINGLE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n    if (c > max) max = c;\n    if (c < min) min = c;\n#ifdef SUPPORT_UNICODE\n    unicode_status |= XCLASS_SAVE_CHAR;\n#endif /* SUPPORT_UNICODE */\n    }\n  else if (*cc == XCL_RANGE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n    if (c < min) min = c;\n    GETCHARINCTEST(c, cc);\n    if (c > max) max = c;\n#ifdef SUPPORT_UNICODE\n    unicode_status |= XCLASS_SAVE_CHAR;\n#endif /* SUPPORT_UNICODE */\n    }\n#ifdef SUPPORT_UNICODE\n  else\n    {\n    SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n    cc++;\n    if (*cc == PT_CLIST && cc[-1] == XCL_PROP)\n      {\n      other_cases = PRIV(ucd_caseless_sets) + cc[1];\n      while (*other_cases != NOTACHAR)\n        {\n        if (*other_cases > max) max = *other_cases;\n        if (*other_cases < min) min = *other_cases;\n        other_cases++;\n        }\n      }\n    else\n      {\n      max = READ_CHAR_MAX;\n      min = 0;\n      }\n\n    switch(*cc)\n      {\n      case PT_ANY:\n      /* Any either accepts everything or ignored. */\n      if (cc[-1] == XCL_PROP)\n        {\n        compile_char1_matchingpath(common, OP_ALLANY, cc, backtracks, FALSE);\n        if (list == backtracks)\n          add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n        return;\n        }\n      break;\n\n      case PT_LAMP:\n      case PT_GC:\n      case PT_PC:\n      case PT_ALNUM:\n      unicode_status |= XCLASS_HAS_TYPE;\n      break;\n\n      case PT_SCX:\n      unicode_status |= XCLASS_HAS_SCRIPT_EXTENSION;\n      if (cc[-1] == XCL_NOTPROP)\n        {\n        unicode_status |= XCLASS_SCRIPT_EXTENSION_NOTPROP;\n        break;\n        }\n      compares++;\n      /* Fall through */ \n\n      case PT_SC:\n      unicode_status |= XCLASS_HAS_SCRIPT;\n      break;\n\n      case PT_SPACE:\n      case PT_PXSPACE:\n      case PT_WORD:\n      case PT_PXGRAPH:\n      case PT_PXPRINT:\n      case PT_PXPUNCT:\n      unicode_status |= XCLASS_SAVE_CHAR | XCLASS_HAS_TYPE;\n      break;\n\n      case PT_CLIST:\n      case PT_UCNC:\n      unicode_status |= XCLASS_SAVE_CHAR;\n      break;\n\n      case PT_BOOL:\n      unicode_status |= XCLASS_HAS_BOOL;\n      break;\n\n      case PT_BIDICL:\n      unicode_status |= XCLASS_HAS_BIDICL;\n      break;\n\n      default:\n      SLJIT_UNREACHABLE();\n      break;\n      }\n    cc += 2;\n    }\n#endif /* SUPPORT_UNICODE */\n  }\nSLJIT_ASSERT(compares > 0);\n\n/* We are not necessary in utf mode even in 8 bit mode. */\ncc = ccbegin;\nif ((cc[-1] & XCL_NOT) != 0)\n  read_char(common, min, max, backtracks, READ_CHAR_UPDATE_STR_PTR);\nelse\n  {\n#ifdef SUPPORT_UNICODE\n  read_char(common, min, max, (unicode_status & XCLASS_NEEDS_UCD) ? backtracks : NULL, 0);\n#else /* !SUPPORT_UNICODE */\n  read_char(common, min, max, NULL, 0);\n#endif /* SUPPORT_UNICODE */\n  }\n\nif ((cc[-1] & XCL_HASPROP) == 0)\n  {\n  if ((cc[-1] & XCL_MAP) != 0)\n    {\n    jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n    if (!optimize_class(common, (const sljit_u8 *)cc, (((const sljit_u8 *)cc)[31] & 0x80) != 0, TRUE, &found))\n      {\n      OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);\n      OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 3);\n      OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)cc);\n      OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);\n      OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP2, 0);\n      add_jump(compiler, &found, JUMP(SLJIT_NOT_ZERO));\n      }\n\n    add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n    JUMPHERE(jump);\n\n    cc += 32 / sizeof(PCRE2_UCHAR);\n    }\n  else\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, min);\n    add_jump(compiler, (cc[-1] & XCL_NOT) == 0 ? backtracks : &found, CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, max - min));\n    }\n  }\nelse if ((cc[-1] & XCL_MAP) != 0)\n  {\n  OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);\n#ifdef SUPPORT_UNICODE\n  unicode_status |= XCLASS_CHAR_SAVED;\n#endif /* SUPPORT_UNICODE */\n  if (!optimize_class(common, (const sljit_u8 *)cc, FALSE, TRUE, list))\n    {\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    jump = NULL;\n    if (common->utf)\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n      jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n\n    OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);\n    OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 3);\n    OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)cc);\n    OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);\n    OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP2, 0);\n    add_jump(compiler, list, JUMP(SLJIT_NOT_ZERO));\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    if (common->utf)\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n      JUMPHERE(jump);\n    }\n\n  OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);\n  cc += 32 / sizeof(PCRE2_UCHAR);\n  }\n\n#ifdef SUPPORT_UNICODE\nif (unicode_status & XCLASS_NEEDS_UCD)\n  {\n  if ((unicode_status & (XCLASS_SAVE_CHAR | XCLASS_CHAR_SAVED)) == XCLASS_SAVE_CHAR)\n    OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);\n\n#if PCRE2_CODE_UNIT_WIDTH == 32\n  if (!common->utf)\n    {\n    jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, MAX_UTF_CODE_POINT + 1);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, UNASSIGNED_UTF_CHAR);\n    JUMPHERE(jump);\n    }\n#endif /* PCRE2_CODE_UNIT_WIDTH == 32 */\n\n  OP2(SLJIT_LSHR, TMP2, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 1);\n  OP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_stage1));\n  OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_MASK);\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, (sljit_sw)PRIV(ucd_stage2));\n  OP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM2(TMP2, TMP1), 1);\n  OP2(SLJIT_SHL, TMP1, 0, TMP2, 0, SLJIT_IMM, 3);\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 2);\n  OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);\n\n  ccbegin = cc;\n\n  if (unicode_status & XCLASS_HAS_BIDICL)\n    {\n    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, scriptx_bidiclass));\n    OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BIDICLASS_SHIFT);\n\n    while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n        if (*cc == PT_BIDICL)\n          {\n          compares--;\n          invertcmp = (compares == 0 && list != backtracks);\n          if (cc[-1] == XCL_NOTPROP)\n            invertcmp ^= 0x1;\n          jump = CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (int)cc[1]);\n          add_jump(compiler, compares > 0 ? list : backtracks, jump);\n          }\n        cc += 2;\n        }\n      }\n\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_HAS_BOOL)\n    {\n    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, bprops));\n    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BPROPS_MASK);\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 2);\n\n    while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n        if (*cc == PT_BOOL)\n          {\n          compares--;\n          invertcmp = (compares == 0 && list != backtracks);\n          if (cc[-1] == XCL_NOTPROP)\n            invertcmp ^= 0x1;\n\n          OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP1), (sljit_sw)(PRIV(ucd_boolprop_sets) + (cc[1] >> 5)), SLJIT_IMM, (sljit_sw)1 << (cc[1] & 0x1f));\n          add_jump(compiler, compares > 0 ? list : backtracks, JUMP(SLJIT_NOT_ZERO ^ invertcmp));\n          }\n        cc += 2;\n        }\n      }\n\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_HAS_SCRIPT)\n    {\n    OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, script));\n\n    while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n        switch (*cc)\n          {\n          case PT_SCX:\n          if (cc[-1] == XCL_NOTPROP)\n            break;\n          /* Fall through */ \n\n          case PT_SC:\n          compares--;\n          invertcmp = (compares == 0 && list != backtracks);\n          if (cc[-1] == XCL_NOTPROP)\n            invertcmp ^= 0x1;\n\n          add_jump(compiler, compares > 0 ? list : backtracks, CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (int)cc[1]));\n          }\n        cc += 2;\n        }\n      }\n\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_HAS_SCRIPT_EXTENSION)\n    {\n    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, scriptx_bidiclass));\n    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_SCRIPTX_MASK);\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 2);\n\n    if (unicode_status & XCLASS_SCRIPT_EXTENSION_NOTPROP)\n      {\n      if (unicode_status & XCLASS_HAS_TYPE)\n        {\n        if (unicode_status & XCLASS_SAVE_CHAR)\n          {\n          OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS0, TMP2, 0);\n          unicode_status |= XCLASS_SCRIPT_EXTENSION_RESTORE_LOCALS0;\n          }\n        else\n          {\n          OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP2, 0);\n          unicode_status |= XCLASS_SCRIPT_EXTENSION_RESTORE_RETURN_ADDR;\n          }\n        }\n      OP1(SLJIT_MOV_U8, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, script));\n      }\n\n    while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n        if (*cc == PT_SCX)\n          {\n          compares--;\n          invertcmp = (compares == 0 && list != backtracks);\n\n          jump = NULL;\n          if (cc[-1] == XCL_NOTPROP)\n            {\n            jump = CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, (int)cc[1]);\n            if (invertcmp)\n              {\n              add_jump(compiler, backtracks, jump);\n              jump = NULL;\n              }\n            invertcmp ^= 0x1;\n            }\n\n          OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP1), (sljit_sw)(PRIV(ucd_script_sets) + (cc[1] >> 5)), SLJIT_IMM, (sljit_sw)1 << (cc[1] & 0x1f));\n          add_jump(compiler, compares > 0 ? list : backtracks, JUMP(SLJIT_NOT_ZERO ^ invertcmp));\n\n          if (jump != NULL)\n            JUMPHERE(jump);\n          }\n        cc += 2;\n        }\n      }\n\n    if (unicode_status & XCLASS_SCRIPT_EXTENSION_RESTORE_LOCALS0)\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n    else if (unicode_status & XCLASS_SCRIPT_EXTENSION_RESTORE_RETURN_ADDR)\n      OP1(SLJIT_MOV, TMP2, 0, RETURN_ADDR, 0);\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_SAVE_CHAR)\n    OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);\n\n  if (unicode_status & XCLASS_HAS_TYPE)\n    {\n    if (unicode_status & XCLASS_SAVE_CHAR)\n      typereg = RETURN_ADDR;\n\n    OP1(SLJIT_MOV_U8, typereg, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, chartype));\n    }\n  }\n#endif /* SUPPORT_UNICODE */\n\n/* Generating code. */\ncharoffset = 0;\nnumberofcmps = 0;\n#ifdef SUPPORT_UNICODE\ntypeoffset = 0;\n#endif /* SUPPORT_UNICODE */\n\nwhile (*cc != XCL_END)\n  {\n  compares--;\n  invertcmp = (compares == 0 && list != backtracks);\n  jump = NULL;\n\n  if (*cc == XCL_SINGLE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n\n    if (numberofcmps < 3 && (*cc == XCL_SINGLE || *cc == XCL_RANGE))\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(numberofcmps == 0 ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n      numberofcmps++;\n      }\n    else if (numberofcmps > 0)\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      numberofcmps = 0;\n      }\n    else\n      {\n      jump = CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      numberofcmps = 0;\n      }\n    }\n  else if (*cc == XCL_RANGE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n    SET_CHAR_OFFSET(c);\n    GETCHARINCTEST(c, cc);\n\n    if (numberofcmps < 3 && (*cc == XCL_SINGLE || *cc == XCL_RANGE))\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(numberofcmps == 0 ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n      numberofcmps++;\n      }\n    else if (numberofcmps > 0)\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      numberofcmps = 0;\n      }\n    else\n      {\n      jump = CMP(SLJIT_LESS_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      numberofcmps = 0;\n      }\n    }\n#ifdef SUPPORT_UNICODE\n  else\n    {\n    SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n    if (*cc == XCL_NOTPROP)\n      invertcmp ^= 0x1;\n    cc++;\n    switch(*cc)\n      {\n      case PT_ANY:\n      if (!invertcmp)\n        jump = JUMP(SLJIT_JUMP);\n      break;\n\n      case PT_LAMP:\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Lu - typeoffset);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Ll - typeoffset);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Lt - typeoffset);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_GC:\n      c = PRIV(ucp_typerange)[(int)cc[1] * 2];\n      SET_TYPE_OFFSET(c);\n      jump = CMP(SLJIT_LESS_EQUAL ^ invertcmp, typereg, 0, SLJIT_IMM, PRIV(ucp_typerange)[(int)cc[1] * 2 + 1] - c);\n      break;\n\n      case PT_PC:\n      jump = CMP(SLJIT_EQUAL ^ invertcmp, typereg, 0, SLJIT_IMM, (int)cc[1] - typeoffset);\n      break;\n\n      case PT_SC:\n      case PT_SCX:\n      case PT_BOOL:\n      case PT_BIDICL:\n      compares++;\n      /* Do nothing. */\n      break;\n\n      case PT_SPACE:\n      case PT_PXSPACE:\n      SET_CHAR_OFFSET(9);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0xd - 0x9);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x85 - 0x9);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x180e - 0x9);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      SET_TYPE_OFFSET(ucp_Zl);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Zs - ucp_Zl);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_WORD:\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_UNDERSCORE - charoffset));\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n      /* Fall through. */\n\n      case PT_ALNUM:\n      SET_TYPE_OFFSET(ucp_Ll);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Lu - ucp_Ll);\n      OP_FLAGS((*cc == PT_ALNUM) ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n      SET_TYPE_OFFSET(ucp_Nd);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_No - ucp_Nd);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_CLIST:\n      other_cases = PRIV(ucd_caseless_sets) + cc[1];\n\n      /* At least three characters are required.\n         Otherwise this case would be handled by the normal code path. */\n      SLJIT_ASSERT(other_cases[0] != NOTACHAR && other_cases[1] != NOTACHAR && other_cases[2] != NOTACHAR);\n      SLJIT_ASSERT(other_cases[0] < other_cases[1] && other_cases[1] < other_cases[2]);\n\n      /* Optimizing character pairs, if their difference is power of 2. */\n      if (is_powerof2(other_cases[1] ^ other_cases[0]))\n        {\n        if (charoffset == 0)\n          OP2(SLJIT_OR, TMP2, 0, TMP1, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);\n        else\n          {\n          OP2(SLJIT_ADD, TMP2, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)charoffset);\n          OP2(SLJIT_OR, TMP2, 0, TMP2, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);\n          }\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, other_cases[1]);\n        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n        other_cases += 2;\n        }\n      else if (is_powerof2(other_cases[2] ^ other_cases[1]))\n        {\n        if (charoffset == 0)\n          OP2(SLJIT_OR, TMP2, 0, TMP1, 0, SLJIT_IMM, other_cases[2] ^ other_cases[1]);\n        else\n          {\n          OP2(SLJIT_ADD, TMP2, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)charoffset);\n          OP2(SLJIT_OR, TMP2, 0, TMP2, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);\n          }\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, other_cases[2]);\n        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(other_cases[0] - charoffset));\n        OP_FLAGS(SLJIT_OR | ((other_cases[3] == NOTACHAR) ? SLJIT_SET_Z : 0), TMP2, 0, SLJIT_EQUAL);\n\n        other_cases += 3;\n        }\n      else\n        {\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(*other_cases++ - charoffset));\n        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n        }\n\n      while (*other_cases != NOTACHAR)\n        {\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(*other_cases++ - charoffset));\n        OP_FLAGS(SLJIT_OR | ((*other_cases == NOTACHAR) ? SLJIT_SET_Z : 0), TMP2, 0, SLJIT_EQUAL);\n        }\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_UCNC:\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_DOLLAR_SIGN - charoffset));\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_COMMERCIAL_AT - charoffset));\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_GRAVE_ACCENT - charoffset));\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      SET_CHAR_OFFSET(0xa0);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw)(0xd7ff - charoffset));\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n      SET_CHAR_OFFSET(0);\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xe000 - 0);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_GREATER_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_PXGRAPH:\n      /* C and Z groups are the farthest two groups. */\n      SET_TYPE_OFFSET(ucp_Ll);\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER, typereg, 0, SLJIT_IMM, ucp_So - ucp_Ll);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_GREATER);\n\n      jump = CMP(SLJIT_NOT_EQUAL, typereg, 0, SLJIT_IMM, ucp_Cf - ucp_Ll);\n\n      /* In case of ucp_Cf, we overwrite the result. */\n      SET_CHAR_OFFSET(0x2066);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x2069 - 0x2066);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x061c - 0x2066);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x180e - 0x2066);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      JUMPHERE(jump);\n      jump = CMP(SLJIT_ZERO ^ invertcmp, TMP2, 0, SLJIT_IMM, 0);\n      break;\n\n      case PT_PXPRINT:\n      /* C and Z groups are the farthest two groups. */\n      SET_TYPE_OFFSET(ucp_Ll);\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER, typereg, 0, SLJIT_IMM, ucp_So - ucp_Ll);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_GREATER);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Zs - ucp_Ll);\n      OP_FLAGS(SLJIT_AND, TMP2, 0, SLJIT_NOT_EQUAL);\n\n      jump = CMP(SLJIT_NOT_EQUAL, typereg, 0, SLJIT_IMM, ucp_Cf - ucp_Ll);\n\n      /* In case of ucp_Cf, we overwrite the result. */\n      SET_CHAR_OFFSET(0x2066);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x2069 - 0x2066);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x061c - 0x2066);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      JUMPHERE(jump);\n      jump = CMP(SLJIT_ZERO ^ invertcmp, TMP2, 0, SLJIT_IMM, 0);\n      break;\n\n      case PT_PXPUNCT:\n      SET_TYPE_OFFSET(ucp_Sc);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_So - ucp_Sc);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      SET_CHAR_OFFSET(0);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x7f);\n      OP_FLAGS(SLJIT_AND, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      SET_TYPE_OFFSET(ucp_Pc);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Ps - ucp_Pc);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      default:\n      SLJIT_UNREACHABLE();\n      break;\n      }\n    cc += 2;\n    }\n#endif /* SUPPORT_UNICODE */\n\n  if (jump != NULL)\n    add_jump(compiler, compares > 0 ? list : backtracks, jump);\n  }\n\nif (found != NULL)\n  set_jumps(found, LABEL());\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"pcre2_jit_misc.c\"\n#include \"pcre2_jit_simd_inc.h\"\n#include \"pcre2_jit_match.c\"\n#include \"sljit/sljitLir.c\"\n#include \"pcre2_internal.h\"\n#include \"config.h\"\n"
  },
  {
    "repository": "linux",
    "cve_id": "CVE-2019-19069",
    "cwe_list": [
      "CWE-401"
    ],
    "commit_hash": "fc739a058d99c9297ef6bfd923b809d85855b9a9",
    "short_hash": "fc739a05",
    "vulnerableMethods_before": [
      {
        "filename": "fastrpc.c",
        "method_name": "vulnerable_function",
        "raw_code": "static int fastrpc_dma_buf_attach(struct dma_buf *dmabuf,\n\t\t\t\t  struct dma_buf_attachment *attachment)\n{\n\tstruct fastrpc_dma_buf_attachment *a;\n\tstruct fastrpc_buf *buffer = dmabuf->priv;\n\tint ret;\n\n\ta = kzalloc(sizeof(*a), GFP_KERNEL);\n\tif (!a)\n\t\treturn -ENOMEM;\n\n\tret = dma_get_sgtable(buffer->dev, &a->sgt, buffer->virt,\n\t\t\t      FASTRPC_PHYS(buffer->phys), buffer->size);\n\tif (ret < 0) {\n\t\tdev_err(buffer->dev, \"failed to get scatterlist from DMA API\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ta->dev = attachment->dev;\n\tINIT_LIST_HEAD(&a->node);\n\tattachment->priv = a;\n\n\tmutex_lock(&buffer->lock);\n\tlist_add(&a->node, &buffer->attachments);\n\tmutex_unlock(&buffer->lock);\n\n\treturn 0;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "fastrpc.c",
        "method_name": "fixed_function",
        "raw_code": "static int fastrpc_dma_buf_attach(struct dma_buf *dmabuf,\n\t\t\t\t  struct dma_buf_attachment *attachment)\n{\n\tstruct fastrpc_dma_buf_attachment *a;\n\tstruct fastrpc_buf *buffer = dmabuf->priv;\n\tint ret;\n\n\ta = kzalloc(sizeof(*a), GFP_KERNEL);\n\tif (!a)\n\t\treturn -ENOMEM;\n\n\tret = dma_get_sgtable(buffer->dev, &a->sgt, buffer->virt,\n\t\t\t      FASTRPC_PHYS(buffer->phys), buffer->size);\n\tif (ret < 0) {\n\t\tdev_err(buffer->dev, \"failed to get scatterlist from DMA API\\n\");\n\t\tkfree(a);\n\t\treturn -EINVAL;\n\t}\n\n\ta->dev = attachment->dev;\n\tINIT_LIST_HEAD(&a->node);\n\tattachment->priv = a;\n\n\tmutex_lock(&buffer->lock);\n\tlist_add(&a->node, &buffer->attachments);\n\tmutex_unlock(&buffer->lock);\n\n\treturn 0;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <linux/module.h>\n#include <linux/miscdevice.h>\n#include <linux/list.h>\n#include <linux/rpmsg.h>\n#include <linux/device.h>\n#include <linux/completion.h>\n#include <linux/of_address.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/dma-buf.h>\n#include <linux/of.h>\n#include <uapi/misc/fastrpc.h>\n#include <linux/idr.h>\n#include <linux/of_platform.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n\n// Type Definitions:\n// dma_buf:\nstruct dma_buf\n\n// fastrpc_buf:\nstruct fastrpc_buf {\n\tstruct fastrpc_user *fl;\n\tstruct dma_buf *dmabuf;\n\tstruct device *dev;\n\tvoid *virt;\n\tu64 phys;\n\tu64 size;\n\t/* Lock for dma buf attachments */\n\tstruct mutex lock;\n\tstruct list_head attachments;\n}\n\n// fastrpc_dma_buf_attachment:\nstruct fastrpc_dma_buf_attachment {\n\tstruct device *dev;\n\tstruct sg_table sgt;\n\tstruct list_head node;\n}\n\n// Called Methods (top 10):\n// FASTRPC_PHYS from drivers/misc/fastrpc.c:\n#define FASTRPC_PHYS(p)\t((p) & 0xffffffff) /* <=== drivers/misc/fastrpc.c:31:31:FASTRPC_PHYS:1 */ \n"
  },
  {
    "repository": "gzip",
    "cve_id": "CVE-2010-0001",
    "cwe_list": [
      "CWE-189"
    ],
    "commit_hash": "a3db5806d012082b9e25cc36d09f19cd736a468f",
    "short_hash": "a3db5806",
    "vulnerableMethods_before": [
      {
        "filename": "None",
        "method_name": "vulnerable_function",
        "raw_code": "int unlzw(in, out)\n    int in, out;    /* input and output file descriptors */\n{\n    REG2   char_type  *stackp;\n    REG3   code_int   code;\n    REG4   int        finchar;\n    REG5   code_int   oldcode;\n    REG6   code_int   incode;\n    REG7   long       inbits;\n    REG8   long       posbits;\n    REG9   int        outpos;\n/*  REG10  int        insize; (global) */\n    REG11  unsigned   bitmask;\n    REG12  code_int   free_ent;\n    REG13  code_int   maxcode;\n    REG14  code_int   maxmaxcode;\n    REG15  int        n_bits;\n    REG16  int        rsize;\n\n#ifdef MAXSEG_64K\n    tab_prefix[0] = tab_prefix0;\n    tab_prefix[1] = tab_prefix1;\n#endif\n    maxbits = get_byte();\n    block_mode = maxbits & BLOCK_MODE;\n    if ((maxbits & LZW_RESERVED) != 0) {\n\tWARN((stderr, \"\\n%s: %s: warning, unknown flags 0x%x\\n\",\n\t      program_name, ifname, maxbits & LZW_RESERVED));\n    }\n    maxbits &= BIT_MASK;\n    maxmaxcode = MAXCODE(maxbits);\n\n    if (maxbits > BITS) {\n\tfprintf(stderr,\n\t\t\"\\n%s: %s: compressed with %d bits, can only handle %d bits\\n\",\n\t\tprogram_name, ifname, maxbits, BITS);\n\texit_code = ERROR;\n\treturn ERROR;\n    }\n    rsize = insize;\n    maxcode = MAXCODE(n_bits = INIT_BITS)-1;\n    bitmask = (1<<n_bits)-1;\n    oldcode = -1;\n    finchar = 0;\n    outpos = 0;\n    posbits = inptr<<3;\n\n    free_ent = ((block_mode) ? FIRST : 256);\n\n    clear_tab_prefixof(); /* Initialize the first 256 entries in the table. */\n\n    for (code = 255 ; code >= 0 ; --code) {\n\ttab_suffixof(code) = (char_type)code;\n    }\n    do {\n\tREG1 int i;\n\tint  e;\n\tint  o;\n\n    resetbuf:\n\te = insize-(o = (posbits>>3));\n\n\tfor (i = 0 ; i < e ; ++i) {\n\t    inbuf[i] = inbuf[i+o];\n\t}\n\tinsize = e;\n\tposbits = 0;\n\n\tif (insize < INBUF_EXTRA) {\n\t    rsize = read_buffer (in, (char *) inbuf + insize, INBUFSIZ);\n\t    if (rsize == -1) {\n\t\tread_error();\n\t    }\n\t    insize += rsize;\n\t    bytes_in += (off_t)rsize;\n\t}\n\tinbits = ((rsize != 0) ? ((long)insize - insize%n_bits)<<3 :\n\t\t  ((long)insize<<3)-(n_bits-1));\n\n\twhile (inbits > posbits) {\n\t    if (free_ent > maxcode) {\n\t\tposbits = ((posbits-1) +\n\t\t\t   ((n_bits<<3)-(posbits-1+(n_bits<<3))%(n_bits<<3)));\n\t\t++n_bits;\n\t\tif (n_bits == maxbits) {\n\t\t    maxcode = maxmaxcode;\n\t\t} else {\n\t\t    maxcode = MAXCODE(n_bits)-1;\n\t\t}\n\t\tbitmask = (1<<n_bits)-1;\n\t\tgoto resetbuf;\n\t    }\n\t    input(inbuf,posbits,code,n_bits,bitmask);\n\t    Tracev((stderr, \"%d \", code));\n\n\t    if (oldcode == -1) {\n\t\tif (256 <= code)\n\t\t  gzip_error (\"corrupt input.\");\n\t\toutbuf[outpos++] = (char_type)(finchar = (int)(oldcode=code));\n\t\tcontinue;\n\t    }\n\t    if (code == CLEAR && block_mode) {\n\t\tclear_tab_prefixof();\n\t\tfree_ent = FIRST - 1;\n\t\tposbits = ((posbits-1) +\n\t\t\t   ((n_bits<<3)-(posbits-1+(n_bits<<3))%(n_bits<<3)));\n\t\tmaxcode = MAXCODE(n_bits = INIT_BITS)-1;\n\t\tbitmask = (1<<n_bits)-1;\n\t\tgoto resetbuf;\n\t    }\n\t    incode = code;\n\t    stackp = de_stack;\n\n\t    if (code >= free_ent) { /* Special case for KwKwK string. */\n\t\tif (code > free_ent) {\n#ifdef DEBUG\n\t\t    char_type *p;\n\n\t\t    posbits -= n_bits;\n\t\t    p = &inbuf[posbits>>3];\n\t\t    fprintf(stderr,\n\t\t\t    \"code:%ld free_ent:%ld n_bits:%d insize:%u\\n\",\n\t\t\t    code, free_ent, n_bits, insize);\n\t\t    fprintf(stderr,\n\t\t\t    \"posbits:%ld inbuf:%02X %02X %02X %02X %02X\\n\",\n\t\t\t    posbits, p[-1],p[0],p[1],p[2],p[3]);\n#endif\n\t\t    if (!test && outpos > 0) {\n\t\t\twrite_buf(out, (char*)outbuf, outpos);\n\t\t\tbytes_out += (off_t)outpos;\n\t\t    }\n\t\t    gzip_error (to_stdout\n\t\t\t\t? \"corrupt input.\"\n\t\t\t\t: \"corrupt input. Use zcat to recover some data.\");\n\t\t}\n\t\t*--stackp = (char_type)finchar;\n\t\tcode = oldcode;\n\t    }\n\n\t    while ((cmp_code_int)code >= (cmp_code_int)256) {\n\t\t/* Generate output characters in reverse order */\n\t\t*--stackp = tab_suffixof(code);\n\t\tcode = tab_prefixof(code);\n\t    }\n\t    *--stackp =\t(char_type)(finchar = tab_suffixof(code));\n\n\t    /* And put them out in forward order */\n\t    {\n\t\tREG1 int\ti;\n\n\t\tif (outpos+(i = (de_stack-stackp)) >= OUTBUFSIZ) {\n\t\t    do {\n\t\t\tif (i > OUTBUFSIZ-outpos) i = OUTBUFSIZ-outpos;\n\n\t\t\tif (i > 0) {\n\t\t\t    memcpy(outbuf+outpos, stackp, i);\n\t\t\t    outpos += i;\n\t\t\t}\n\t\t\tif (outpos >= OUTBUFSIZ) {\n\t\t\t    if (!test) {\n\t\t\t\twrite_buf(out, (char*)outbuf, outpos);\n\t\t\t\tbytes_out += (off_t)outpos;\n\t\t\t    }\n\t\t\t    outpos = 0;\n\t\t\t}\n\t\t\tstackp+= i;\n\t\t    } while ((i = (de_stack-stackp)) > 0);\n\t\t} else {\n\t\t    memcpy(outbuf+outpos, stackp, i);\n\t\t    outpos += i;\n\t\t}\n\t    }\n\n\t    if ((code = free_ent) < maxmaxcode) { /* Generate the new entry. */\n\n\t\ttab_prefixof(code) = (unsigned short)oldcode;\n\t\ttab_suffixof(code) = (char_type)finchar;\n\t\tfree_ent = code+1;\n\t    }\n\t    oldcode = incode;\t/* Remember previous code.\t*/\n\t}\n    } while (rsize != 0);\n\n    if (!test && outpos > 0) {\n\twrite_buf(out, (char*)outbuf, outpos);\n\tbytes_out += (off_t)outpos;\n    }\n    return OK;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "None",
        "method_name": "fixed_function",
        "raw_code": "int unlzw(in, out)\n    int in, out;    /* input and output file descriptors */\n{\n    REG2   char_type  *stackp;\n    REG3   code_int   code;\n    REG4   int        finchar;\n    REG5   code_int   oldcode;\n    REG6   code_int   incode;\n    REG7   long       inbits;\n    REG8   long       posbits;\n    REG9   int        outpos;\n/*  REG10  int        insize; (global) */\n    REG11  unsigned   bitmask;\n    REG12  code_int   free_ent;\n    REG13  code_int   maxcode;\n    REG14  code_int   maxmaxcode;\n    REG15  int        n_bits;\n    REG16  int        rsize;\n\n#ifdef MAXSEG_64K\n    tab_prefix[0] = tab_prefix0;\n    tab_prefix[1] = tab_prefix1;\n#endif\n    maxbits = get_byte();\n    block_mode = maxbits & BLOCK_MODE;\n    if ((maxbits & LZW_RESERVED) != 0) {\n\tWARN((stderr, \"\\n%s: %s: warning, unknown flags 0x%x\\n\",\n\t      program_name, ifname, maxbits & LZW_RESERVED));\n    }\n    maxbits &= BIT_MASK;\n    maxmaxcode = MAXCODE(maxbits);\n\n    if (maxbits > BITS) {\n\tfprintf(stderr,\n\t\t\"\\n%s: %s: compressed with %d bits, can only handle %d bits\\n\",\n\t\tprogram_name, ifname, maxbits, BITS);\n\texit_code = ERROR;\n\treturn ERROR;\n    }\n    rsize = insize;\n    maxcode = MAXCODE(n_bits = INIT_BITS)-1;\n    bitmask = (1<<n_bits)-1;\n    oldcode = -1;\n    finchar = 0;\n    outpos = 0;\n    posbits = inptr<<3;\n\n    free_ent = ((block_mode) ? FIRST : 256);\n\n    clear_tab_prefixof(); /* Initialize the first 256 entries in the table. */\n\n    for (code = 255 ; code >= 0 ; --code) {\n\ttab_suffixof(code) = (char_type)code;\n    }\n    do {\n\tREG1 int i;\n\tint  e;\n\tint  o;\n\n    resetbuf:\n\to = posbits >> 3;\n\te = o <= insize ? insize - o : 0;\n\n\tfor (i = 0 ; i < e ; ++i) {\n\t    inbuf[i] = inbuf[i+o];\n\t}\n\tinsize = e;\n\tposbits = 0;\n\n\tif (insize < INBUF_EXTRA) {\n\t    rsize = read_buffer (in, (char *) inbuf + insize, INBUFSIZ);\n\t    if (rsize == -1) {\n\t\tread_error();\n\t    }\n\t    insize += rsize;\n\t    bytes_in += (off_t)rsize;\n\t}\n\tinbits = ((rsize != 0) ? ((long)insize - insize%n_bits)<<3 :\n\t\t  ((long)insize<<3)-(n_bits-1));\n\n\twhile (inbits > posbits) {\n\t    if (free_ent > maxcode) {\n\t\tposbits = ((posbits-1) +\n\t\t\t   ((n_bits<<3)-(posbits-1+(n_bits<<3))%(n_bits<<3)));\n\t\t++n_bits;\n\t\tif (n_bits == maxbits) {\n\t\t    maxcode = maxmaxcode;\n\t\t} else {\n\t\t    maxcode = MAXCODE(n_bits)-1;\n\t\t}\n\t\tbitmask = (1<<n_bits)-1;\n\t\tgoto resetbuf;\n\t    }\n\t    input(inbuf,posbits,code,n_bits,bitmask);\n\t    Tracev((stderr, \"%d \", code));\n\n\t    if (oldcode == -1) {\n\t\tif (256 <= code)\n\t\t  gzip_error (\"corrupt input.\");\n\t\toutbuf[outpos++] = (char_type)(finchar = (int)(oldcode=code));\n\t\tcontinue;\n\t    }\n\t    if (code == CLEAR && block_mode) {\n\t\tclear_tab_prefixof();\n\t\tfree_ent = FIRST - 1;\n\t\tposbits = ((posbits-1) +\n\t\t\t   ((n_bits<<3)-(posbits-1+(n_bits<<3))%(n_bits<<3)));\n\t\tmaxcode = MAXCODE(n_bits = INIT_BITS)-1;\n\t\tbitmask = (1<<n_bits)-1;\n\t\tgoto resetbuf;\n\t    }\n\t    incode = code;\n\t    stackp = de_stack;\n\n\t    if (code >= free_ent) { /* Special case for KwKwK string. */\n\t\tif (code > free_ent) {\n#ifdef DEBUG\n\t\t    char_type *p;\n\n\t\t    posbits -= n_bits;\n\t\t    p = &inbuf[posbits>>3];\n\t\t    fprintf(stderr,\n\t\t\t    \"code:%ld free_ent:%ld n_bits:%d insize:%u\\n\",\n\t\t\t    code, free_ent, n_bits, insize);\n\t\t    fprintf(stderr,\n\t\t\t    \"posbits:%ld inbuf:%02X %02X %02X %02X %02X\\n\",\n\t\t\t    posbits, p[-1],p[0],p[1],p[2],p[3]);\n#endif\n\t\t    if (!test && outpos > 0) {\n\t\t\twrite_buf(out, (char*)outbuf, outpos);\n\t\t\tbytes_out += (off_t)outpos;\n\t\t    }\n\t\t    gzip_error (to_stdout\n\t\t\t\t? \"corrupt input.\"\n\t\t\t\t: \"corrupt input. Use zcat to recover some data.\");\n\t\t}\n\t\t*--stackp = (char_type)finchar;\n\t\tcode = oldcode;\n\t    }\n\n\t    while ((cmp_code_int)code >= (cmp_code_int)256) {\n\t\t/* Generate output characters in reverse order */\n\t\t*--stackp = tab_suffixof(code);\n\t\tcode = tab_prefixof(code);\n\t    }\n\t    *--stackp =\t(char_type)(finchar = tab_suffixof(code));\n\n\t    /* And put them out in forward order */\n\t    {\n\t\tREG1 int\ti;\n\n\t\tif (outpos+(i = (de_stack-stackp)) >= OUTBUFSIZ) {\n\t\t    do {\n\t\t\tif (i > OUTBUFSIZ-outpos) i = OUTBUFSIZ-outpos;\n\n\t\t\tif (i > 0) {\n\t\t\t    memcpy(outbuf+outpos, stackp, i);\n\t\t\t    outpos += i;\n\t\t\t}\n\t\t\tif (outpos >= OUTBUFSIZ) {\n\t\t\t    if (!test) {\n\t\t\t\twrite_buf(out, (char*)outbuf, outpos);\n\t\t\t\tbytes_out += (off_t)outpos;\n\t\t\t    }\n\t\t\t    outpos = 0;\n\t\t\t}\n\t\t\tstackp+= i;\n\t\t    } while ((i = (de_stack-stackp)) > 0);\n\t\t} else {\n\t\t    memcpy(outbuf+outpos, stackp, i);\n\t\t    outpos += i;\n\t\t}\n\t    }\n\n\t    if ((code = free_ent) < maxmaxcode) { /* Generate the new entry. */\n\n\t\ttab_prefixof(code) = (unsigned short)oldcode;\n\t\ttab_suffixof(code) = (char_type)finchar;\n\t\tfree_ent = code+1;\n\t    }\n\t    oldcode = incode;\t/* Remember previous code.\t*/\n\t}\n    } while (rsize != 0);\n\n    if (!test && outpos > 0) {\n\twrite_buf(out, (char*)outbuf, outpos);\n\tbytes_out += (off_t)outpos;\n    }\n    return OK;\n}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "php-src",
    "cve_id": "CVE-2016-6207",
    "cwe_list": [
      "CWE-119"
    ],
    "commit_hash": "8fa9d1ce28f3a894b104979df30d0b65e0f21107",
    "short_hash": "8fa9d1ce",
    "vulnerableMethods_before": [
      {
        "filename": "gd_interpolation.c",
        "method_name": "vulnerable_function",
        "raw_code": "static inline LineContribType * _gdContributionsAlloc(unsigned int line_length, unsigned int windows_size)\n{\n\tunsigned int u = 0;\n\tLineContribType *res;\n\tint overflow_error = 0;\n\n\tres = (LineContribType *) gdMalloc(sizeof(LineContribType));\n\tif (!res) {\n\t\treturn NULL;\n\t}\n\tres->WindowSize = windows_size;\n\tres->LineLength = line_length;\n\tif (overflow2(line_length, sizeof(ContributionType))) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tres->ContribRow = (ContributionType *) gdMalloc(line_length * sizeof(ContributionType));\n\tif (res->ContribRow == NULL) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tfor (u = 0 ; u < line_length ; u++) {\n\t\tif (overflow2(windows_size, sizeof(double))) {\n\t\t\toverflow_error = 1;\n\t\t} else {\n\t\t\tres->ContribRow[u].Weights = (double *) gdMalloc(windows_size * sizeof(double));\n\t\t}\n\t\tif (overflow_error == 1 || res->ContribRow[u].Weights == NULL) {\n\t\t\tu--;\n\t\t\twhile (u >= 0) {\n\t\t\t\tgdFree(res->ContribRow[u].Weights);\n\t\t\t\tu--;\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn res;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "gd_interpolation.c",
        "method_name": "fixed_function",
        "raw_code": "static inline LineContribType * _gdContributionsAlloc(unsigned int line_length, unsigned int windows_size)\n{\n\tunsigned int u = 0;\n\tLineContribType *res;\n\tint overflow_error = 0;\n\n\tres = (LineContribType *) gdMalloc(sizeof(LineContribType));\n\tif (!res) {\n\t\treturn NULL;\n\t}\n\tres->WindowSize = windows_size;\n\tres->LineLength = line_length;\n\tif (overflow2(line_length, sizeof(ContributionType))) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tres->ContribRow = (ContributionType *) gdMalloc(line_length * sizeof(ContributionType));\n\tif (res->ContribRow == NULL) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tfor (u = 0 ; u < line_length ; u++) {\n\t\tif (overflow2(windows_size, sizeof(double))) {\n\t\t\toverflow_error = 1;\n\t\t} else {\n\t\t\tres->ContribRow[u].Weights = (double *) gdMalloc(windows_size * sizeof(double));\n\t\t}\n\t\tif (overflow_error == 1 || res->ContribRow[u].Weights == NULL) {\n\t\t\tunsigned int i;\n\t\t\tu--;\n\t\t\tfor (i=0;i<=u;i++) {\n\t\t\t\tgdFree(res->ContribRow[i].Weights);\n\t\t\t}\n\t\t\tgdFree(res);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn res;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <stdio.h>\n# include <emmintrin.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"gdhelpers.h\"\n#include <math.h>\n#include <gd.h>\n\n// Type Definitions:\n// LineContribType:\ntypedef struct\n{\n   ContributionType *ContribRow; /* Row (or column) of contribution weights */\n   unsigned int WindowSize,      /* Filter window size (of affecting source pixels) */\n\t\t\t\tLineLength;      /* Length of line (no. or rows / cols) */\n}\n\n// Called Methods (top 10):\n// ZEND_MM_BLOCK from Zend/zend_alloc.c:\n#define ZEND_MM_BLOCK(b, type, size)\tdo { \\ /* <=== Zend/zend_alloc.c:502:507:ZEND_MM_BLOCK:3 */ \n\t\t\t\t\t\t\t\t\t\t\tsize_t _size = (size); \\\n\t\t\t\t\t\t\t\t\t\t\t(b)->info._size = (type) | _size; \\\n\t\t\t\t\t\t\t\t\t\t\tZEND_MM_BLOCK_AT(b, _size)->info._prev = (type) | _size; \\\n\t\t\t\t\t\t\t\t\t\t\tZEND_MM_SET_COOKIE(b); \\\n\t\t\t\t\t\t\t\t\t\t} while (0);\n\n// HANDLE_UNBLOCK_INTERRUPTIONS from Zend/zend.h:\n#define HANDLE_UNBLOCK_INTERRUPTIONS()\t\tif (zend_unblock_interruptions) { zend_unblock_interruptions(); } /* <=== Zend/zend.h:727:727:HANDLE_UNBLOCK_INTERRUPTIONS:0 */ \n\n// ZEND_MM_PREV_BLOCK from Zend/zend_alloc.c:\n#define ZEND_MM_PREV_BLOCK(b)\t\t\tZEND_MM_BLOCK_AT(b, -(ssize_t)((b)->info._prev & ~ZEND_MM_TYPE_MASK)) /* <=== Zend/zend_alloc.c:518:518:ZEND_MM_PREV_BLOCK:1 */ \n\n// ZEND_MM_BLOCK_AT from Zend/zend_alloc.c:\n#define ZEND_MM_BLOCK_AT(blk, offset)\t((zend_mm_block *) (((char *) (blk))+(offset))) /* <=== Zend/zend_alloc.c:546:546:ZEND_MM_BLOCK_AT:2 */ \n\n// _efree from Zend/zend_alloc.c:\nvoid _efree(void *ptr ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC)\n{\n\tTSRMLS_FETCH();\n\n\tif (UNEXPECTED(!AG(mm_heap)->use_zend_alloc)) {\n\t\tAG(mm_heap)->_free(ptr);\n\t\treturn;\n\t}\n\t_zend_mm_free_int(AG(mm_heap), ptr ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);\n}\n\n// ZEND_MM_IS_GUARD_BLOCK from Zend/zend_alloc.c:\n#define ZEND_MM_IS_GUARD_BLOCK(b)\t\t(((b)->info._size & ZEND_MM_TYPE_MASK) == ZEND_MM_GUARD_BLOCK) /* <=== Zend/zend_alloc.c:515:515:ZEND_MM_IS_GUARD_BLOCK:1 */ \n\n// INT_MAX from ext/gd/php.h:\n\n\n// E_WARNING from ext/gd/zend_errors.h:\n\n\n// ZEND_MM_HEADER_OF from Zend/zend_alloc.c:\n#define ZEND_MM_HEADER_OF(blk)\t\t\tZEND_MM_BLOCK_AT(blk, -(int)ZEND_MM_ALIGNED_HEADER_SIZE) /* <=== Zend/zend_alloc.c:548:548:ZEND_MM_HEADER_OF:1 */ \n\n// zend_mm_add_to_free_list from Zend/zend_alloc.c:\nstatic inline void zend_mm_add_to_free_list(zend_mm_heap *heap, zend_mm_free_block *mm_block) /* <=== zend_mm_add_to_free_list */ \n{\n\tsize_t size;\n\tsize_t index;\n\n\tZEND_MM_SET_MAGIC(mm_block, MEM_BLOCK_FREED);\n\n\tsize = ZEND_MM_FREE_BLOCK_SIZE(mm_block);\n\tif (EXPECTED(!ZEND_MM_SMALL_SIZE(size))) {\n\t\tzend_mm_free_block **p;\n\n\t\tindex = ZEND_MM_LARGE_BUCKET_INDEX(size);\n\t\tp = &heap->large_free_buckets[index];\n\t\tmm_block->child[0] = mm_block->child[1] = NULL;\n\t\tif (!*p) {\n\t\t\t*p = mm_block;\n\t\t\tmm_block->parent = p;\n\t\t\tmm_block->prev_free_block = mm_block->next_free_block = mm_block;\n\t\t\theap->large_free_bitmap |= (ZEND_MM_LONG_CONST(1) << index);\n\t\t} else {\n\t\t\tsize_t m;\n\n\t\t\tfor (m = size << (ZEND_MM_NUM_BUCKETS - index); ; m <<= 1) {\n\t\t\t\tzend_mm_free_block *prev = *p;\n\n\t\t\t\tif (ZEND_MM_FREE_BLOCK_SIZE(prev) != size) {\n\t\t\t\t\tp = &prev->child[(m >> (ZEND_MM_NUM_BUCKETS-1)) & 1];\n\t\t\t\t\tif (!*p) {\n\t\t\t\t\t\t*p = mm_block;\n\t\t\t\t\t\tmm_block->parent = p;\n\t\t\t\t\t\tmm_block->prev_free_block = mm_block->next_free_block = mm_block;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tzend_mm_free_block *next = prev->next_free_block;\n\n\t\t\t\t\tprev->next_free_block = next->prev_free_block = mm_block;\n\t\t\t\t\tmm_block->next_free_block = next;\n\t\t\t\t\tmm_block->prev_free_block = prev;\n\t\t\t\t\tmm_block->parent = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tzend_mm_free_block *prev, *next;\n\n\t\tindex = ZEND_MM_BUCKET_INDEX(size);\n\n\t\tprev = ZEND_MM_SMALL_FREE_BUCKET(heap, index);\n\t\tif (prev->prev_free_block == prev) {\n\t\t\theap->free_bitmap |= (ZEND_MM_LONG_CONST(1) << index);\n\t\t}\n\t\tnext = prev->next_free_block;\n\n\t\tmm_block->prev_free_block = prev;\n\t\tmm_block->next_free_block = next;\n\t\tprev->next_free_block = next->prev_free_block = mm_block;\n\t}\n}\n"
  },
  {
    "repository": "linux",
    "cve_id": "CVE-2022-1508",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "89c2b3b74918200e46699338d7bcc19b1ea12110",
    "short_hash": "89c2b3b7",
    "vulnerableMethods_before": [
      {
        "filename": "io_uring.c",
        "method_name": "vulnerable_function",
        "raw_code": "static int io_read(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct iovec inline_vecs[UIO_FASTIOV], *iovec = inline_vecs;\n\tstruct kiocb *kiocb = &req->rw.kiocb;\n\tstruct iov_iter __iter, *iter = &__iter;\n\tstruct io_async_rw *rw = req->async_data;\n\tssize_t io_size, ret, ret2;\n\tbool force_nonblock = issue_flags & IO_URING_F_NONBLOCK;\n\n\tif (rw) {\n\t\titer = &rw->iter;\n\t\tiovec = NULL;\n\t} else {\n\t\tret = io_import_iovec(READ, req, &iovec, iter, !force_nonblock);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tio_size = iov_iter_count(iter);\n\treq->result = io_size;\n\n\t/* Ensure we clear previously set non-block flag */\n\tif (!force_nonblock)\n\t\tkiocb->ki_flags &= ~IOCB_NOWAIT;\n\telse\n\t\tkiocb->ki_flags |= IOCB_NOWAIT;\n\n\t/* If the file doesn't support async, just async punt */\n\tif (force_nonblock && !io_file_supports_async(req, READ)) {\n\t\tret = io_setup_async_rw(req, iovec, inline_vecs, iter, true);\n\t\treturn ret ?: -EAGAIN;\n\t}\n\n\tret = rw_verify_area(READ, req->file, io_kiocb_ppos(kiocb), io_size);\n\tif (unlikely(ret)) {\n\t\tkfree(iovec);\n\t\treturn ret;\n\t}\n\n\tret = io_iter_do_read(req, iter);\n\n\tif (ret == -EAGAIN || (req->flags & REQ_F_REISSUE)) {\n\t\treq->flags &= ~REQ_F_REISSUE;\n\t\t/* IOPOLL retry should happen for io-wq threads */\n\t\tif (!force_nonblock && !(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\t\tgoto done;\n\t\t/* no retry on NONBLOCK nor RWF_NOWAIT */\n\t\tif (req->flags & REQ_F_NOWAIT)\n\t\t\tgoto done;\n\t\t/* some cases will consume bytes even on error returns */\n\t\tiov_iter_revert(iter, io_size - iov_iter_count(iter));\n\t\tret = 0;\n\t} else if (ret == -EIOCBQUEUED) {\n\t\tgoto out_free;\n\t} else if (ret <= 0 || ret == io_size || !force_nonblock ||\n\t\t   (req->flags & REQ_F_NOWAIT) || !(req->flags & REQ_F_ISREG)) {\n\t\t/* read all, failed, already did sync or don't want to retry */\n\t\tgoto done;\n\t}\n\n\tret2 = io_setup_async_rw(req, iovec, inline_vecs, iter, true);\n\tif (ret2)\n\t\treturn ret2;\n\n\tiovec = NULL;\n\trw = req->async_data;\n\t/* now use our persistent iterator, if we aren't already */\n\titer = &rw->iter;\n\n\tdo {\n\t\tio_size -= ret;\n\t\trw->bytes_done += ret;\n\t\t/* if we can retry, do so with the callbacks armed */\n\t\tif (!io_rw_should_retry(req)) {\n\t\t\tkiocb->ki_flags &= ~IOCB_WAITQ;\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\t/*\n\t\t * Now retry read with the IOCB_WAITQ parts set in the iocb. If\n\t\t * we get -EIOCBQUEUED, then we'll get a notification when the\n\t\t * desired page gets unlocked. We can also get a partial read\n\t\t * here, and if we do, then just retry at the new offset.\n\t\t */\n\t\tret = io_iter_do_read(req, iter);\n\t\tif (ret == -EIOCBQUEUED)\n\t\t\treturn 0;\n\t\t/* we got some bytes, but not all. retry. */\n\t\tkiocb->ki_flags &= ~IOCB_WAITQ;\n\t} while (ret > 0 && ret < io_size);\ndone:\n\tkiocb_done(kiocb, ret, issue_flags);\nout_free:\n\t/* it's faster to check here then delegate to kfree */\n\tif (iovec)\n\t\tkfree(iovec);\n\treturn 0;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "io_uring.c",
        "method_name": "fixed_function",
        "raw_code": "static int io_read(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct iovec inline_vecs[UIO_FASTIOV], *iovec = inline_vecs;\n\tstruct kiocb *kiocb = &req->rw.kiocb;\n\tstruct iov_iter __iter, *iter = &__iter;\n\tstruct io_async_rw *rw = req->async_data;\n\tssize_t io_size, ret, ret2;\n\tbool force_nonblock = issue_flags & IO_URING_F_NONBLOCK;\n\n\tif (rw) {\n\t\titer = &rw->iter;\n\t\tiovec = NULL;\n\t} else {\n\t\tret = io_import_iovec(READ, req, &iovec, iter, !force_nonblock);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tio_size = iov_iter_count(iter);\n\treq->result = io_size;\n\n\t/* Ensure we clear previously set non-block flag */\n\tif (!force_nonblock)\n\t\tkiocb->ki_flags &= ~IOCB_NOWAIT;\n\telse\n\t\tkiocb->ki_flags |= IOCB_NOWAIT;\n\n\t/* If the file doesn't support async, just async punt */\n\tif (force_nonblock && !io_file_supports_async(req, READ)) {\n\t\tret = io_setup_async_rw(req, iovec, inline_vecs, iter, true);\n\t\treturn ret ?: -EAGAIN;\n\t}\n\n\tret = rw_verify_area(READ, req->file, io_kiocb_ppos(kiocb), io_size);\n\tif (unlikely(ret)) {\n\t\tkfree(iovec);\n\t\treturn ret;\n\t}\n\n\tret = io_iter_do_read(req, iter);\n\n\tif (ret == -EAGAIN || (req->flags & REQ_F_REISSUE)) {\n\t\treq->flags &= ~REQ_F_REISSUE;\n\t\t/* IOPOLL retry should happen for io-wq threads */\n\t\tif (!force_nonblock && !(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\t\tgoto done;\n\t\t/* no retry on NONBLOCK nor RWF_NOWAIT */\n\t\tif (req->flags & REQ_F_NOWAIT)\n\t\t\tgoto done;\n\t\t/* some cases will consume bytes even on error returns */\n\t\tiov_iter_reexpand(iter, iter->count + iter->truncated);\n\t\tiov_iter_revert(iter, io_size - iov_iter_count(iter));\n\t\tret = 0;\n\t} else if (ret == -EIOCBQUEUED) {\n\t\tgoto out_free;\n\t} else if (ret <= 0 || ret == io_size || !force_nonblock ||\n\t\t   (req->flags & REQ_F_NOWAIT) || !(req->flags & REQ_F_ISREG)) {\n\t\t/* read all, failed, already did sync or don't want to retry */\n\t\tgoto done;\n\t}\n\n\tret2 = io_setup_async_rw(req, iovec, inline_vecs, iter, true);\n\tif (ret2)\n\t\treturn ret2;\n\n\tiovec = NULL;\n\trw = req->async_data;\n\t/* now use our persistent iterator, if we aren't already */\n\titer = &rw->iter;\n\n\tdo {\n\t\tio_size -= ret;\n\t\trw->bytes_done += ret;\n\t\t/* if we can retry, do so with the callbacks armed */\n\t\tif (!io_rw_should_retry(req)) {\n\t\t\tkiocb->ki_flags &= ~IOCB_WAITQ;\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\t/*\n\t\t * Now retry read with the IOCB_WAITQ parts set in the iocb. If\n\t\t * we get -EIOCBQUEUED, then we'll get a notification when the\n\t\t * desired page gets unlocked. We can also get a partial read\n\t\t * here, and if we do, then just retry at the new offset.\n\t\t */\n\t\tret = io_iter_do_read(req, iter);\n\t\tif (ret == -EIOCBQUEUED)\n\t\t\treturn 0;\n\t\t/* we got some bytes, but not all. retry. */\n\t\tkiocb->ki_flags &= ~IOCB_WAITQ;\n\t} while (ret > 0 && ret < io_size);\ndone:\n\tkiocb_done(kiocb, ret, issue_flags);\nout_free:\n\t/* it's faster to check here then delegate to kfree */\n\tif (iovec)\n\t\tkfree(iovec);\n\treturn 0;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <linux/hugetlb.h>\n#include <linux/splice.h>\n#include <trace/events/io_uring.h>\n#include <linux/net.h>\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/nospec.h>\n#include <uapi/linux/io_uring.h>\n#include <linux/bvec.h>\n#include <linux/blkdev.h>\n#include <net/af_unix.h>\n#include <linux/fadvise.h>\n#include <linux/init.h>\n#include <linux/mman.h>\n#include <linux/sched/mm.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/eventpoll.h>\n#include <linux/io_uring.h>\n#include \"io-wq.h\"\n#include <linux/percpu.h>\n#include <linux/sizes.h>\n#include <linux/kernel.h>\n#include <linux/fdtable.h>\n#include <linux/bits.h>\n#include <linux/mm.h>\n#include <linux/fsnotify.h>\n#include <linux/namei.h>\n#include \"internal.h\"\n#include <linux/uio.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/task_work.h>\n#include <linux/file.h>\n#include <linux/refcount.h>\n#include <linux/pagemap.h>\n#include <linux/errno.h>\n#include <net/scm.h>\n#include <linux/syscalls.h>\n#include <net/compat.h>\n#include <net/sock.h>\n#include <linux/fs.h>\n\n// Type Definitions:\n// kiocb:\nstruct kiocb\n\n// iovec:\nstruct iovec\n\n// io_kiocb:\nstruct io_kiocb\n\n// iov_iter:\nstruct iov_iter\n\n// iovec:\nconst struct iovec\n\n// io_kiocb:\nstruct io_kiocb {\n\tunion {\n\t\tstruct file\t\t*file;\n\t\tstruct io_rw\t\trw;\n\t\tstruct io_poll_iocb\tpoll;\n\t\tstruct io_poll_update\tpoll_update;\n\t\tstruct io_accept\taccept;\n\t\tstruct io_sync\t\tsync;\n\t\tstruct io_cancel\tcancel;\n\t\tstruct io_timeout\ttimeout;\n\t\tstruct io_timeout_rem\ttimeout_rem;\n\t\tstruct io_connect\tconnect;\n\t\tstruct io_sr_msg\tsr_msg;\n\t\tstruct io_open\t\topen;\n\t\tstruct io_close\t\tclose;\n\t\tstruct io_rsrc_update\trsrc_update;\n\t\tstruct io_fadvise\tfadvise;\n\t\tstruct io_madvise\tmadvise;\n\t\tstruct io_epoll\t\tepoll;\n\t\tstruct io_splice\tsplice;\n\t\tstruct io_provide_buf\tpbuf;\n\t\tstruct io_statx\t\tstatx;\n\t\tstruct io_shutdown\tshutdown;\n\t\tstruct io_rename\trename;\n\t\tstruct io_unlink\tunlink;\n\t\t/* use only after cleaning per-op data, see io_clean_op() */\n\t\tstruct io_completion\tcompl;\n\t};\n\n\t/* opcode allocated if it needs to store data for async defer */\n\tvoid\t\t\t\t*async_data;\n\tu8\t\t\t\topcode;\n\t/* polled IO has completed */\n\tu8\t\t\t\tiopoll_completed;\n\n\tu16\t\t\t\tbuf_index;\n\tu32\t\t\t\tresult;\n\n\tstruct io_ring_ctx\t\t*ctx;\n\tun...\n\n// io_async_rw:\nstruct io_async_rw {\n\tstruct iovec\t\t\tfast_iov[UIO_FASTIOV];\n\tconst struct iovec\t\t*free_iovec;\n\tstruct iov_iter\t\t\titer;\n\tsize_t\t\t\t\tbytes_done;\n\tstruct wait_page_queue\t\twpq;\n}\n\n// Called Methods (top 10):\n// io_req_complete_state from fs/io_uring.c:\nstatic void io_req_complete_state(struct io_kiocb *req, long res, /* <=== io_req_complete_state */ \n\t\t\t\t  unsigned int cflags)\n{\n\tif (io_req_needs_clean(req))\n\t\tio_clean_op(req);\n\treq->result = res;\n\treq->compl.cflags = cflags;\n\treq->flags |= REQ_F_COMPLETE_INLINE;\n}\n\n// rw_verify_area from fs/read_write.c:\nint rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count) /* <=== rw_verify_area */ \n{\n\tstruct inode *inode;\n\tint retval = -EINVAL;\n\n\tinode = file_inode(file);\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn retval;\n\n\t/*\n\t * ranged mandatory locking does not apply to streams - it makes sense\n\t * only for files where position has a meaning.\n\t */\n\tif (ppos) {\n\t\tloff_t pos = *ppos;\n\n\t\tif (unlikely(pos < 0)) {\n\t\t\tif (!unsigned_offsets(file))\n\t\t\t\treturn retval;\n\t\t\tif (count >= -pos) /* both values are in 0..LLONG_MAX */\n\t\t\t\treturn -EOVERFLOW;\n\t\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\t\tif (!unsigned_offsets(file))\n\t\t\t\treturn retval;\n\t\t}\n\n\t\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\t\tretval = locks_mandatory_area(inode, file, pos, pos + count - 1,\n\t\t\t\t\tread_write == READ ? F_RDLCK : F_WRLCK);\n\t\t\tif (retval < 0)\n\t\t\t\treturn retval;\n\t\t}\n\t}\n\n\treturn security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n}\n\n// io_alloc_async_data from fs/io_uring.c:\nstatic inline int io_alloc_async_data(struct io_kiocb *req) /* <=== io_alloc_async_data */ \n{\n\tWARN_ON_ONCE(!io_op_defs[req->opcode].async_size);\n\treq->async_data = kmalloc(io_op_defs[req->opcode].async_size, GFP_KERNEL);\n\treturn req->async_data == NULL;\n}\n\n// io_req_map_rw from fs/io_uring.c:\nstatic void io_req_map_rw(struct io_kiocb *req, const struct iovec *iovec, /* <=== io_req_map_rw */ \n\t\t\t  const struct iovec *fast_iov, struct iov_iter *iter)\n{\n\tstruct io_async_rw *rw = req->async_data;\n\n\tmemcpy(&rw->iter, iter, sizeof(*iter));\n\trw->free_iovec = iovec;\n\trw->bytes_done = 0;\n\t/* can only be fixed buffers, no need to do anything */\n\tif (iov_iter_is_bvec(iter))\n\t\treturn;\n\tif (!iovec) {\n\t\tunsigned iov_off = 0;\n\n\t\trw->iter.iov = rw->fast_iov;\n\t\tif (iter->iov != fast_iov) {\n\t\t\tiov_off = iter->iov - fast_iov;\n\t\t\trw->iter.iov += iov_off;\n\t\t}\n\t\tif (rw->fast_iov != fast_iov)\n\t\t\tmemcpy(rw->fast_iov + iov_off, fast_iov + iov_off,\n\t\t\t       sizeof(struct iovec) * iter->nr_segs);\n\t} else {\n\t\treq->flags |= REQ_F_NEED_CLEANUP;\n\t}\n}\n\n// io_put_rw_kbuf from fs/io_uring.c:\nstatic inline unsigned int io_put_rw_kbuf(struct io_kiocb *req) /* <=== io_put_rw_kbuf */ \n{\n\tstruct io_buffer *kbuf;\n\n\tkbuf = (struct io_buffer *) (unsigned long) req->rw.addr;\n\treturn io_put_kbuf(req, kbuf);\n}\n\n// io_iter_do_read from fs/io_uring.c:\nstatic inline int io_iter_do_read(struct io_kiocb *req, struct iov_iter *iter) /* <=== io_iter_do_read */ \n{\n\tif (req->file->f_op->read_iter)\n\t\treturn call_read_iter(req->file, &req->rw.kiocb, iter);\n\telse if (req->file->f_op->read)\n\t\treturn loop_rw_iter(READ, req, iter);\n\telse\n\t\treturn -EINVAL;\n}\n\n// loop_rw_iter from fs/io_uring.c:\nstatic ssize_t loop_rw_iter(int rw, struct io_kiocb *req, struct iov_iter *iter) /* <=== loop_rw_iter */ \n{\n\tstruct kiocb *kiocb = &req->rw.kiocb;\n\tstruct file *file = req->file;\n\tssize_t ret = 0;\n\n\t/*\n\t * Don't support polled IO through this interface, and we can't\n\t * support non-blocking either. For the latter, this just causes\n\t * the kiocb to be handled from an async context.\n\t */\n\tif (kiocb->ki_flags & IOCB_HIPRI)\n\t\treturn -EOPNOTSUPP;\n\tif (kiocb->ki_flags & IOCB_NOWAIT)\n\t\treturn -EAGAIN;\n\n\twhile (iov_iter_count(iter)) {\n\t\tstruct iovec iovec;\n\t\tssize_t nr;\n\n\t\tif (!iov_iter_is_bvec(iter)) {\n\t\t\tiovec = iov_iter_iovec(iter);\n\t\t} else {\n\t\t\tiovec.iov_base = u64_to_user_ptr(req->rw.addr);\n\t\t\tiovec.iov_len = req->rw.len;\n\t\t}\n\n\t\tif (rw == READ) {\n\t\t\tnr = file->f_op->read(file, iovec.iov_base,\n\t\t\t\t\t      iovec.iov_len, io_kiocb_ppos(kiocb));\n\t\t} else {\n\t\t\tnr = file->f_op->write(file, iovec.iov_base,\n\t\t\t\t\t       iovec.iov_len, io_kiocb_ppos(kiocb));\n\t\t}\n\n\t\tif (nr < 0) {\n\t\t\tif (!ret)\n\t\t\t\tret = nr;\n\t\t\tbreak;\n\t\t}\n\t\tret += nr;\n\t\tif (nr != iovec.iov_len)\n\t\t\tbreak;\n\t\treq->rw.len -= nr;\n\t\treq->rw.addr += nr;\n\t\tiov_iter_advance(iter, nr);\n\t}\n\n\treturn ret;\n}\n\n// io_prep_async_link from fs/io_uring.c:\nstatic void io_prep_async_link(struct io_kiocb *req) /* <=== io_prep_async_link */ \n{\n\tstruct io_kiocb *cur;\n\n\tio_for_each_link(cur, req)\n\t\tio_prep_async_work(cur);\n}\n\n// io_queue_async_work from fs/io_uring.c:\nstatic void io_queue_async_work(struct io_kiocb *req) /* <=== io_queue_async_work */ \n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct io_kiocb *link = io_prep_linked_timeout(req);\n\tstruct io_uring_task *tctx = req->task->io_uring;\n\n\tBUG_ON(!tctx);\n\tBUG_ON(!tctx->io_wq);\n\n\t/* init ->work of the whole link before punting */\n\tio_prep_async_link(req);\n\ttrace_io_uring_queue_async_work(ctx, io_wq_is_hashed(&req->work), req,\n\t\t\t\t\t&req->work, req->flags);\n\tio_wq_enqueue(tctx->io_wq, &req->work);\n\tif (link)\n\t\tio_queue_linked_timeout(link);\n}\n\n// __io_iov_buffer_select from fs/io_uring.c:\nstatic ssize_t __io_iov_buffer_select(struct io_kiocb *req, struct iovec *iov, /* <=== __io_iov_buffer_select */ \n\t\t\t\t      bool needs_lock)\n{\n\tstruct iovec __user *uiov = u64_to_user_ptr(req->rw.addr);\n\tvoid __user *buf;\n\tssize_t len;\n\n\tif (copy_from_user(iov, uiov, sizeof(*uiov)))\n\t\treturn -EFAULT;\n\n\tlen = iov[0].iov_len;\n\tif (len < 0)\n\t\treturn -EINVAL;\n\tbuf = io_rw_buffer_select(req, &len, needs_lock);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\tiov[0].iov_base = buf;\n\tiov[0].iov_len = len;\n\treturn 0;\n}\n"
  },
  {
    "repository": "mruby",
    "cve_id": "CVE-2022-1276",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "c8c083cb750606b2da81582cd8e43b442bb143e6",
    "short_hash": "c8c083cb",
    "vulnerableMethods_before": [
      {
        "filename": "codegen.c",
        "method_name": "vulnerable_function",
        "raw_code": "gen_assignment(codegen_scope *s, node *tree, node *rhs, int sp, int val)\n{\n  int idx;\n  int type = nint(tree->car);\n\n  switch (type) {\n  case NODE_GVAR:\n  case NODE_ARG:\n  case NODE_LVAR:\n  case NODE_IVAR:\n  case NODE_CVAR:\n  case NODE_CONST:\n  case NODE_NIL:\n  case NODE_MASGN:\n    if (rhs) {\n      codegen(s, rhs, VAL);\n      pop();\n      sp = cursp();\n    }\n    break;\n\n  case NODE_COLON2:\n  case NODE_CALL:\n  case NODE_SCALL:\n    /* keep evaluation order */\n    break;\n\n  case NODE_NVAR:\n    codegen_error(s, \"Can't assign to numbered parameter\");\n    break;\n\n  default:\n    codegen_error(s, \"unknown lhs\");\n    break;\n  }\n\n  tree = tree->cdr;\n  switch (type) {\n  case NODE_GVAR:\n    gen_setxv(s, OP_SETGV, sp, nsym(tree), val);\n    break;\n  case NODE_ARG:\n  case NODE_LVAR:\n    idx = lv_idx(s, nsym(tree));\n    if (idx > 0) {\n      if (idx != sp) {\n        gen_move(s, idx, sp, val);\n      }\n      break;\n    }\n    else {                      /* upvar */\n      gen_setupvar(s, sp, nsym(tree));\n    }\n    break;\n  case NODE_IVAR:\n    gen_setxv(s, OP_SETIV, sp, nsym(tree), val);\n    break;\n  case NODE_CVAR:\n    gen_setxv(s, OP_SETCV, sp, nsym(tree), val);\n    break;\n  case NODE_CONST:\n    gen_setxv(s, OP_SETCONST, sp, nsym(tree), val);\n    break;\n  case NODE_COLON2:\n    if (sp) {\n      gen_move(s, cursp(), sp, 0);\n    }\n    sp = cursp();\n    push();\n    codegen(s, tree->car, VAL);\n    if (rhs) {\n      codegen(s, rhs, VAL); pop();\n      gen_move(s, sp, cursp(), 0);\n    }\n    pop_n(2);\n    idx = new_sym(s, nsym(tree->cdr));\n    genop_2(s, OP_SETMCNST, sp, idx);\n    break;\n\n  case NODE_CALL:\n  case NODE_SCALL:\n    {\n      int noself = 0, safe = (type == NODE_SCALL), skip = 0, top, call, n = 0;\n      mrb_sym mid = nsym(tree->cdr->car);\n\n      top = cursp();\n      if (val || sp == cursp()) {\n        push();                   /* room for retval */\n      }\n      call = cursp();\n      if (!tree->car) {\n        noself = 1;\n        push();\n      }\n      else {\n        codegen(s, tree->car, VAL); /* receiver */\n      }\n      if (safe) {\n        int recv = cursp()-1;\n        gen_move(s, cursp(), recv, 1);\n        skip = genjmp2_0(s, OP_JMPNIL, cursp(), val);\n      }\n      tree = tree->cdr->cdr->car;\n      if (tree) {\n        if (tree->car) {            /* positional arguments */\n          n = gen_values(s, tree->car, VAL, (tree->cdr->car)?13:14);\n          if (n < 0) {              /* variable length */\n            n = 15;\n            push();\n          }\n        }\n        if (tree->cdr->car) {       /* keyword arguments */\n          if (n == 14) {\n            pop_n(n);\n            genop_2(s, OP_ARRAY, cursp(), n);\n            push();\n            n = 15;\n          }\n          gen_hash(s, tree->cdr->car->cdr, VAL, 0);\n          if (n < 14) {\n            n++;\n          }\n          else {\n            pop_n(2);\n            genop_2(s, OP_ARYPUSH, cursp(), 1);\n          }\n          push();\n        }\n      }\n      if (rhs) {\n        codegen(s, rhs, VAL);\n        pop();\n      }\n      else {\n        gen_move(s, cursp(), sp, 0);\n      }\n      if (val) {\n        gen_move(s, top, cursp(), 1);\n      }\n      if (n < 15) {\n        n++;\n        if (n == 15) {\n          pop_n(14);\n          genop_2(s, OP_ARRAY, cursp(), 15);\n        }\n      }\n      else {\n        pop();\n        genop_2(s, OP_ARYPUSH, cursp(), 1);\n      }\n      s->sp = call;\n      if (mid == MRB_OPSYM_2(s->mrb, aref) && n == 2) {\n        genop_1(s, OP_SETIDX, cursp());\n      }\n      else {\n        genop_3(s, noself ? OP_SSEND : OP_SEND, cursp(), new_sym(s, attrsym(s, mid)), n);\n      }\n      if (safe) {\n        dispatch(s, skip);\n      }\n      s->sp = top;\n    }\n    break;\n\n  case NODE_MASGN:\n    gen_massignment(s, tree->car, sp, val);\n    break;\n\n  /* splat without assignment */\n  case NODE_NIL:\n    break;\n\n  default:\n    codegen_error(s, \"unknown lhs\");\n    break;\n  }\n  if (val) push();\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "codegen.c",
        "method_name": "fixed_function",
        "raw_code": "gen_assignment(codegen_scope *s, node *tree, node *rhs, int sp, int val)\n{\n  int idx;\n  int type = nint(tree->car);\n\n  switch (type) {\n  case NODE_GVAR:\n  case NODE_ARG:\n  case NODE_LVAR:\n  case NODE_IVAR:\n  case NODE_CVAR:\n  case NODE_CONST:\n  case NODE_NIL:\n  case NODE_MASGN:\n    if (rhs) {\n      codegen(s, rhs, VAL);\n      pop();\n      sp = cursp();\n    }\n    break;\n\n  case NODE_COLON2:\n  case NODE_CALL:\n  case NODE_SCALL:\n    /* keep evaluation order */\n    break;\n\n  case NODE_NVAR:\n    codegen_error(s, \"Can't assign to numbered parameter\");\n    break;\n\n  default:\n    codegen_error(s, \"unknown lhs\");\n    break;\n  }\n\n  tree = tree->cdr;\n  switch (type) {\n  case NODE_GVAR:\n    gen_setxv(s, OP_SETGV, sp, nsym(tree), val);\n    break;\n  case NODE_ARG:\n  case NODE_LVAR:\n    idx = lv_idx(s, nsym(tree));\n    if (idx > 0) {\n      if (idx != sp) {\n        gen_move(s, idx, sp, val);\n      }\n      break;\n    }\n    else {                      /* upvar */\n      gen_setupvar(s, sp, nsym(tree));\n    }\n    break;\n  case NODE_IVAR:\n    gen_setxv(s, OP_SETIV, sp, nsym(tree), val);\n    break;\n  case NODE_CVAR:\n    gen_setxv(s, OP_SETCV, sp, nsym(tree), val);\n    break;\n  case NODE_CONST:\n    gen_setxv(s, OP_SETCONST, sp, nsym(tree), val);\n    break;\n  case NODE_COLON2:\n    if (sp) {\n      gen_move(s, cursp(), sp, 0);\n    }\n    sp = cursp();\n    push();\n    codegen(s, tree->car, VAL);\n    if (rhs) {\n      codegen(s, rhs, VAL); pop();\n      gen_move(s, sp, cursp(), 0);\n    }\n    pop_n(2);\n    idx = new_sym(s, nsym(tree->cdr));\n    genop_2(s, OP_SETMCNST, sp, idx);\n    break;\n\n  case NODE_CALL:\n  case NODE_SCALL:\n    {\n      int noself = 0, safe = (type == NODE_SCALL), skip = 0, top, call, n = 0;\n      mrb_sym mid = nsym(tree->cdr->car);\n\n      top = cursp();\n      if (val || sp == cursp()) {\n        push();                   /* room for retval */\n      }\n      call = cursp();\n      if (!tree->car) {\n        noself = 1;\n        push();\n      }\n      else {\n        codegen(s, tree->car, VAL); /* receiver */\n      }\n      if (safe) {\n        int recv = cursp()-1;\n        gen_move(s, cursp(), recv, 1);\n        skip = genjmp2_0(s, OP_JMPNIL, cursp(), val);\n      }\n      tree = tree->cdr->cdr->car;\n      if (tree) {\n        if (tree->car) {            /* positional arguments */\n          n = gen_values(s, tree->car, VAL, (tree->cdr->car)?13:14);\n          if (n < 0) {              /* variable length */\n            n = 15;\n            push();\n          }\n        }\n        if (tree->cdr->car) {       /* keyword arguments */\n          if (n == 13 || n == 14) {\n            pop_n(n);\n            genop_2(s, OP_ARRAY, cursp(), n);\n            push();\n            n = 15;\n          }\n          gen_hash(s, tree->cdr->car->cdr, VAL, 0);\n          if (n < 14) {\n            n++;\n          }\n          else {\n            pop_n(2);\n            genop_2(s, OP_ARYPUSH, cursp(), 1);\n          }\n          push();\n        }\n      }\n      if (rhs) {\n        codegen(s, rhs, VAL);\n        pop();\n      }\n      else {\n        gen_move(s, cursp(), sp, 0);\n      }\n      if (val) {\n        gen_move(s, top, cursp(), 1);\n      }\n      if (n < 15) {\n        n++;\n        if (n == 15) {\n          pop_n(14);\n          genop_2(s, OP_ARRAY, cursp(), 15);\n        }\n      }\n      else {\n        pop();\n        genop_2(s, OP_ARYPUSH, cursp(), 1);\n      }\n      s->sp = call;\n      if (mid == MRB_OPSYM_2(s->mrb, aref) && n == 2) {\n        genop_1(s, OP_SETIDX, cursp());\n      }\n      else {\n        genop_3(s, noself ? OP_SSEND : OP_SEND, cursp(), new_sym(s, attrsym(s, mid)), n);\n      }\n      if (safe) {\n        dispatch(s, skip);\n      }\n      s->sp = top;\n    }\n    break;\n\n  case NODE_MASGN:\n    gen_massignment(s, tree->car, sp, val);\n    break;\n\n  /* splat without assignment */\n  case NODE_NIL:\n    break;\n\n  default:\n    codegen_error(s, \"unknown lhs\");\n    break;\n  }\n  if (val) push();\n}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "tensorflow",
    "cve_id": "CVE-2022-21734",
    "cwe_list": [
      "CWE-843"
    ],
    "commit_hash": "f57315566d7094f322b784947093406c2aea0d7d",
    "short_hash": "f5731556",
    "vulnerableMethods_before": [
      {
        "filename": "map_stage_op.cc",
        "method_name": "vulnerable_function",
        "raw_code": "  void Compute(OpKernelContext* ctx) override {\n    StagingMap<Ordered>* map = nullptr;\n    OP_REQUIRES_OK(ctx, GetStagingMap(ctx, def(), &map));\n    core::ScopedUnref scope(map);\n    typename StagingMap<Ordered>::OptionalTuple tuple;\n\n    const Tensor* key_tensor;\n    const Tensor* indices_tensor;\n    OpInputList values_tensor;\n\n    OP_REQUIRES_OK(ctx, ctx->input(\"key\", &key_tensor));\n    OP_REQUIRES_OK(ctx, ctx->input(\"indices\", &indices_tensor));\n    OP_REQUIRES_OK(ctx, ctx->input_list(\"values\", &values_tensor));\n    OP_REQUIRES(ctx, key_tensor->NumElements() > 0,\n                errors::InvalidArgument(\"key must not be empty\"));\n\n    // Create copy for insertion into Staging Area\n    Tensor key(*key_tensor);\n\n    // Create the tuple to store\n    for (std::size_t i = 0; i < values_tensor.size(); ++i) {\n      tuple.push_back(values_tensor[i]);\n    }\n\n    // Store the tuple in the map\n    OP_REQUIRES_OK(ctx, map->put(&key, indices_tensor, &tuple));\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "map_stage_op.cc",
        "method_name": "fixed_function",
        "raw_code": "  void Compute(OpKernelContext* ctx) override {\n    StagingMap<Ordered>* map = nullptr;\n    OP_REQUIRES_OK(ctx, GetStagingMap(ctx, def(), &map));\n    core::ScopedUnref scope(map);\n    typename StagingMap<Ordered>::OptionalTuple tuple;\n\n    const Tensor* key_tensor;\n    const Tensor* indices_tensor;\n    OpInputList values_tensor;\n\n    OP_REQUIRES_OK(ctx, ctx->input(\"key\", &key_tensor));\n    OP_REQUIRES_OK(ctx, ctx->input(\"indices\", &indices_tensor));\n    OP_REQUIRES_OK(ctx, ctx->input_list(\"values\", &values_tensor));\n    OP_REQUIRES(ctx, key_tensor->NumElements() > 0,\n                errors::InvalidArgument(\"key must not be empty\"));\n\n    OP_REQUIRES(ctx, key_tensor->NumElements() == 1,\n                errors::InvalidArgument(\n                    \"key must be an int64 scalar, got tensor with shape: \",\n                    key_tensor->shape()));\n\n    // Create copy for insertion into Staging Area\n    Tensor key(*key_tensor);\n\n    // Create the tuple to store\n    for (std::size_t i = 0; i < values_tensor.size(); ++i) {\n      tuple.push_back(values_tensor[i]);\n    }\n\n    // Store the tuple in the map\n    OP_REQUIRES_OK(ctx, map->put(&key, indices_tensor, &tuple));\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "puma",
    "cve_id": "CVE-2021-41136",
    "cwe_list": [
      "CWE-444"
    ],
    "commit_hash": "acdc3ae571dfae0e045cf09a295280127db65c7f",
    "short_hash": "acdc3ae5",
    "vulnerableMethods_before": [
      {
        "filename": "http11_parser.c",
        "method_name": "vulnerable_function",
        "raw_code": "size_t puma_parser_execute(puma_parser *parser, const char *buffer, size_t len, size_t off)  {\n  const char *p, *pe;\n  int cs = parser->cs;\n\n  assert(off <= len && \"offset past end of buffer\");\n\n  p = buffer+off;\n  pe = buffer+len;\n\n  /* assert(*pe == '\\0' && \"pointer does not end on NUL\"); */\n  assert((size_t) (pe - p) == len - off && \"pointers aren't same distance\");\n\n  \n#line 87 \"ext/puma_http11/http11_parser.c\"\n\t{\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tswitch ( cs )\n\t{\ncase 1:\n\tswitch( (*p) ) {\n\t\tcase 36: goto tr0;\n\t\tcase 95: goto tr0;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto tr0;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto tr0;\n\t} else\n\t\tgoto tr0;\n\tgoto st0;\nst0:\ncs = 0;\n\tgoto _out;\ntr0:\n#line 37 \"ext/puma_http11/http11_parser.rl\"\n\t{ MARK(mark, p); }\n\tgoto st2;\nst2:\n\tif ( ++p == pe )\n\t\tgoto _test_eof2;\ncase 2:\n#line 118 \"ext/puma_http11/http11_parser.c\"\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st27;\n\t\tcase 95: goto st27;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st27;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st27;\n\t} else\n\t\tgoto st27;\n\tgoto st0;\ntr2:\n#line 50 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->request_method(parser, PTR_TO(mark), LEN(mark, p));\n  }\n\tgoto st3;\nst3:\n\tif ( ++p == pe )\n\t\tgoto _test_eof3;\ncase 3:\n#line 143 \"ext/puma_http11/http11_parser.c\"\n\tswitch( (*p) ) {\n\t\tcase 42: goto tr4;\n\t\tcase 43: goto tr5;\n\t\tcase 47: goto tr6;\n\t\tcase 58: goto tr7;\n\t}\n\tif ( (*p) < 65 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 57 )\n\t\t\tgoto tr5;\n\t} else if ( (*p) > 90 ) {\n\t\tif ( 97 <= (*p) && (*p) <= 122 )\n\t\t\tgoto tr5;\n\t} else\n\t\tgoto tr5;\n\tgoto st0;\ntr4:\n#line 37 \"ext/puma_http11/http11_parser.rl\"\n\t{ MARK(mark, p); }\n\tgoto st4;\nst4:\n\tif ( ++p == pe )\n\t\tgoto _test_eof4;\ncase 4:\n#line 167 \"ext/puma_http11/http11_parser.c\"\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr8;\n\t\tcase 35: goto tr9;\n\t}\n\tgoto st0;\ntr8:\n#line 53 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->request_uri(parser, PTR_TO(mark), LEN(mark, p));\n  }\n\tgoto st5;\ntr31:\n#line 37 \"ext/puma_http11/http11_parser.rl\"\n\t{ MARK(mark, p); }\n#line 56 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->fragment(parser, PTR_TO(mark), LEN(mark, p));\n  }\n\tgoto st5;\ntr33:\n#line 56 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->fragment(parser, PTR_TO(mark), LEN(mark, p));\n  }\n\tgoto st5;\ntr37:\n#line 69 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->request_path(parser, PTR_TO(mark), LEN(mark,p));\n  }\n#line 53 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->request_uri(parser, PTR_TO(mark), LEN(mark, p));\n  }\n\tgoto st5;\ntr41:\n#line 60 \"ext/puma_http11/http11_parser.rl\"\n\t{ MARK(query_start, p); }\n#line 61 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->query_string(parser, PTR_TO(query_start), LEN(query_start, p));\n  }\n#line 53 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->request_uri(parser, PTR_TO(mark), LEN(mark, p));\n  }\n\tgoto st5;\ntr44:\n#line 61 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->query_string(parser, PTR_TO(query_start), LEN(query_start, p));\n  }\n#line 53 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->request_uri(parser, PTR_TO(mark), LEN(mark, p));\n  }\n\tgoto st5;\nst5:\n\tif ( ++p == pe )\n\t\tgoto _test_eof5;\ncase 5:\n#line 229 \"ext/puma_http11/http11_parser.c\"\n\tif ( (*p) == 72 )\n\t\tgoto tr10;\n\tgoto st0;\ntr10:\n#line 37 \"ext/puma_http11/http11_parser.rl\"\n\t{ MARK(mark, p); }\n\tgoto st6;\nst6:\n\tif ( ++p == pe )\n\t\tgoto _test_eof6;\ncase 6:\n#line 241 \"ext/puma_http11/http11_parser.c\"\n\tif ( (*p) == 84 )\n\t\tgoto st7;\n\tgoto st0;\nst7:\n\tif ( ++p == pe )\n\t\tgoto _test_eof7;\ncase 7:\n\tif ( (*p) == 84 )\n\t\tgoto st8;\n\tgoto st0;\nst8:\n\tif ( ++p == pe )\n\t\tgoto _test_eof8;\ncase 8:\n\tif ( (*p) == 80 )\n\t\tgoto st9;\n\tgoto st0;\nst9:\n\tif ( ++p == pe )\n\t\tgoto _test_eof9;\ncase 9:\n\tif ( (*p) == 47 )\n\t\tgoto st10;\n\tgoto st0;\nst10:\n\tif ( ++p == pe )\n\t\tgoto _test_eof10;\ncase 10:\n\tif ( 48 <= (*p) && (*p) <= 57 )\n\t\tgoto st11;\n\tgoto st0;\nst11:\n\tif ( ++p == pe )\n\t\tgoto _test_eof11;\ncase 11:\n\tif ( (*p) == 46 )\n\t\tgoto st12;\n\tif ( 48 <= (*p) && (*p) <= 57 )\n\t\tgoto st11;\n\tgoto st0;\nst12:\n\tif ( ++p == pe )\n\t\tgoto _test_eof12;\ncase 12:\n\tif ( 48 <= (*p) && (*p) <= 57 )\n\t\tgoto st13;\n\tgoto st0;\nst13:\n\tif ( ++p == pe )\n\t\tgoto _test_eof13;\ncase 13:\n\tif ( (*p) == 13 )\n\t\tgoto tr18;\n\tif ( 48 <= (*p) && (*p) <= 57 )\n\t\tgoto st13;\n\tgoto st0;\ntr18:\n#line 65 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->http_version(parser, PTR_TO(mark), LEN(mark, p));\n  }\n\tgoto st14;\ntr26:\n#line 46 \"ext/puma_http11/http11_parser.rl\"\n\t{ MARK(mark, p); }\n#line 47 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->http_field(parser, PTR_TO(field_start), parser->field_len, PTR_TO(mark), LEN(mark, p));\n  }\n\tgoto st14;\ntr29:\n#line 47 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->http_field(parser, PTR_TO(field_start), parser->field_len, PTR_TO(mark), LEN(mark, p));\n  }\n\tgoto st14;\nst14:\n\tif ( ++p == pe )\n\t\tgoto _test_eof14;\ncase 14:\n#line 322 \"ext/puma_http11/http11_parser.c\"\n\tif ( (*p) == 10 )\n\t\tgoto st15;\n\tgoto st0;\nst15:\n\tif ( ++p == pe )\n\t\tgoto _test_eof15;\ncase 15:\n\tswitch( (*p) ) {\n\t\tcase 13: goto st16;\n\t\tcase 33: goto tr21;\n\t\tcase 124: goto tr21;\n\t\tcase 126: goto tr21;\n\t}\n\tif ( (*p) < 45 ) {\n\t\tif ( (*p) > 39 ) {\n\t\t\tif ( 42 <= (*p) && (*p) <= 43 )\n\t\t\t\tgoto tr21;\n\t\t} else if ( (*p) >= 35 )\n\t\t\tgoto tr21;\n\t} else if ( (*p) > 46 ) {\n\t\tif ( (*p) < 65 ) {\n\t\t\tif ( 48 <= (*p) && (*p) <= 57 )\n\t\t\t\tgoto tr21;\n\t\t} else if ( (*p) > 90 ) {\n\t\t\tif ( 94 <= (*p) && (*p) <= 122 )\n\t\t\t\tgoto tr21;\n\t\t} else\n\t\t\tgoto tr21;\n\t} else\n\t\tgoto tr21;\n\tgoto st0;\nst16:\n\tif ( ++p == pe )\n\t\tgoto _test_eof16;\ncase 16:\n\tif ( (*p) == 10 )\n\t\tgoto tr22;\n\tgoto st0;\ntr22:\n#line 73 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->body_start = p - buffer + 1;\n    parser->header_done(parser, p + 1, pe - p - 1);\n    {p++; cs = 46; goto _out;}\n  }\n\tgoto st46;\nst46:\n\tif ( ++p == pe )\n\t\tgoto _test_eof46;\ncase 46:\n#line 373 \"ext/puma_http11/http11_parser.c\"\n\tgoto st0;\ntr21:\n#line 40 \"ext/puma_http11/http11_parser.rl\"\n\t{ MARK(field_start, p); }\n#line 41 \"ext/puma_http11/http11_parser.rl\"\n\t{ snake_upcase_char((char *)p); }\n\tgoto st17;\ntr23:\n#line 41 \"ext/puma_http11/http11_parser.rl\"\n\t{ snake_upcase_char((char *)p); }\n\tgoto st17;\nst17:\n\tif ( ++p == pe )\n\t\tgoto _test_eof17;\ncase 17:\n#line 389 \"ext/puma_http11/http11_parser.c\"\n\tswitch( (*p) ) {\n\t\tcase 33: goto tr23;\n\t\tcase 58: goto tr24;\n\t\tcase 124: goto tr23;\n\t\tcase 126: goto tr23;\n\t}\n\tif ( (*p) < 45 ) {\n\t\tif ( (*p) > 39 ) {\n\t\t\tif ( 42 <= (*p) && (*p) <= 43 )\n\t\t\t\tgoto tr23;\n\t\t} else if ( (*p) >= 35 )\n\t\t\tgoto tr23;\n\t} else if ( (*p) > 46 ) {\n\t\tif ( (*p) < 65 ) {\n\t\t\tif ( 48 <= (*p) && (*p) <= 57 )\n\t\t\t\tgoto tr23;\n\t\t} else if ( (*p) > 90 ) {\n\t\t\tif ( 94 <= (*p) && (*p) <= 122 )\n\t\t\t\tgoto tr23;\n\t\t} else\n\t\t\tgoto tr23;\n\t} else\n\t\tgoto tr23;\n\tgoto st0;\ntr24:\n#line 42 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->field_len = LEN(field_start, p);\n  }\n\tgoto st18;\ntr27:\n#line 46 \"ext/puma_http11/http11_parser.rl\"\n\t{ MARK(mark, p); }\n\tgoto st18;\nst18:\n\tif ( ++p == pe )\n\t\tgoto _test_eof18;\ncase 18:\n#line 428 \"ext/puma_http11/http11_parser.c\"\n\tswitch( (*p) ) {\n\t\tcase 13: goto tr26;\n\t\tcase 32: goto tr27;\n\t}\n\tgoto tr25;\ntr25:\n#line 46 \"ext/puma_http11/http11_parser.rl\"\n\t{ MARK(mark, p); }\n\tgoto st19;\nst19:\n\tif ( ++p == pe )\n\t\tgoto _test_eof19;\ncase 19:\n#line 442 \"ext/puma_http11/http11_parser.c\"\n\tif ( (*p) == 13 )\n\t\tgoto tr29;\n\tgoto st19;\ntr9:\n#line 53 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->request_uri(parser, PTR_TO(mark), LEN(mark, p));\n  }\n\tgoto st20;\ntr38:\n#line 69 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->request_path(parser, PTR_TO(mark), LEN(mark,p));\n  }\n#line 53 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->request_uri(parser, PTR_TO(mark), LEN(mark, p));\n  }\n\tgoto st20;\ntr42:\n#line 60 \"ext/puma_http11/http11_parser.rl\"\n\t{ MARK(query_start, p); }\n#line 61 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->query_string(parser, PTR_TO(query_start), LEN(query_start, p));\n  }\n#line 53 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->request_uri(parser, PTR_TO(mark), LEN(mark, p));\n  }\n\tgoto st20;\ntr45:\n#line 61 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->query_string(parser, PTR_TO(query_start), LEN(query_start, p));\n  }\n#line 53 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->request_uri(parser, PTR_TO(mark), LEN(mark, p));\n  }\n\tgoto st20;\nst20:\n\tif ( ++p == pe )\n\t\tgoto _test_eof20;\ncase 20:\n#line 488 \"ext/puma_http11/http11_parser.c\"\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr31;\n\t\tcase 60: goto st0;\n\t\tcase 62: goto st0;\n\t\tcase 127: goto st0;\n\t}\n\tif ( (*p) > 31 ) {\n\t\tif ( 34 <= (*p) && (*p) <= 35 )\n\t\t\tgoto st0;\n\t} else if ( (*p) >= 0 )\n\t\tgoto st0;\n\tgoto tr30;\ntr30:\n#line 37 \"ext/puma_http11/http11_parser.rl\"\n\t{ MARK(mark, p); }\n\tgoto st21;\nst21:\n\tif ( ++p == pe )\n\t\tgoto _test_eof21;\ncase 21:\n#line 509 \"ext/puma_http11/http11_parser.c\"\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr33;\n\t\tcase 60: goto st0;\n\t\tcase 62: goto st0;\n\t\tcase 127: goto st0;\n\t}\n\tif ( (*p) > 31 ) {\n\t\tif ( 34 <= (*p) && (*p) <= 35 )\n\t\t\tgoto st0;\n\t} else if ( (*p) >= 0 )\n\t\tgoto st0;\n\tgoto st21;\ntr5:\n#line 37 \"ext/puma_http11/http11_parser.rl\"\n\t{ MARK(mark, p); }\n\tgoto st22;\nst22:\n\tif ( ++p == pe )\n\t\tgoto _test_eof22;\ncase 22:\n#line 530 \"ext/puma_http11/http11_parser.c\"\n\tswitch( (*p) ) {\n\t\tcase 43: goto st22;\n\t\tcase 58: goto st23;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st22;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( (*p) > 90 ) {\n\t\t\tif ( 97 <= (*p) && (*p) <= 122 )\n\t\t\t\tgoto st22;\n\t\t} else if ( (*p) >= 65 )\n\t\t\tgoto st22;\n\t} else\n\t\tgoto st22;\n\tgoto st0;\ntr7:\n#line 37 \"ext/puma_http11/http11_parser.rl\"\n\t{ MARK(mark, p); }\n\tgoto st23;\nst23:\n\tif ( ++p == pe )\n\t\tgoto _test_eof23;\ncase 23:\n#line 555 \"ext/puma_http11/http11_parser.c\"\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr8;\n\t\tcase 34: goto st0;\n\t\tcase 35: goto tr9;\n\t\tcase 60: goto st0;\n\t\tcase 62: goto st0;\n\t\tcase 127: goto st0;\n\t}\n\tif ( 0 <= (*p) && (*p) <= 31 )\n\t\tgoto st0;\n\tgoto st23;\ntr6:\n#line 37 \"ext/puma_http11/http11_parser.rl\"\n\t{ MARK(mark, p); }\n\tgoto st24;\nst24:\n\tif ( ++p == pe )\n\t\tgoto _test_eof24;\ncase 24:\n#line 575 \"ext/puma_http11/http11_parser.c\"\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr37;\n\t\tcase 34: goto st0;\n\t\tcase 35: goto tr38;\n\t\tcase 60: goto st0;\n\t\tcase 62: goto st0;\n\t\tcase 63: goto tr39;\n\t\tcase 127: goto st0;\n\t}\n\tif ( 0 <= (*p) && (*p) <= 31 )\n\t\tgoto st0;\n\tgoto st24;\ntr39:\n#line 69 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->request_path(parser, PTR_TO(mark), LEN(mark,p));\n  }\n\tgoto st25;\nst25:\n\tif ( ++p == pe )\n\t\tgoto _test_eof25;\ncase 25:\n#line 598 \"ext/puma_http11/http11_parser.c\"\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr41;\n\t\tcase 34: goto st0;\n\t\tcase 35: goto tr42;\n\t\tcase 60: goto st0;\n\t\tcase 62: goto st0;\n\t\tcase 127: goto st0;\n\t}\n\tif ( 0 <= (*p) && (*p) <= 31 )\n\t\tgoto st0;\n\tgoto tr40;\ntr40:\n#line 60 \"ext/puma_http11/http11_parser.rl\"\n\t{ MARK(query_start, p); }\n\tgoto st26;\nst26:\n\tif ( ++p == pe )\n\t\tgoto _test_eof26;\ncase 26:\n#line 618 \"ext/puma_http11/http11_parser.c\"\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr44;\n\t\tcase 34: goto st0;\n\t\tcase 35: goto tr45;\n\t\tcase 60: goto st0;\n\t\tcase 62: goto st0;\n\t\tcase 127: goto st0;\n\t}\n\tif ( 0 <= (*p) && (*p) <= 31 )\n\t\tgoto st0;\n\tgoto st26;\nst27:\n\tif ( ++p == pe )\n\t\tgoto _test_eof27;\ncase 27:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st28;\n\t\tcase 95: goto st28;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st28;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st28;\n\t} else\n\t\tgoto st28;\n\tgoto st0;\nst28:\n\tif ( ++p == pe )\n\t\tgoto _test_eof28;\ncase 28:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st29;\n\t\tcase 95: goto st29;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st29;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st29;\n\t} else\n\t\tgoto st29;\n\tgoto st0;\nst29:\n\tif ( ++p == pe )\n\t\tgoto _test_eof29;\ncase 29:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st30;\n\t\tcase 95: goto st30;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st30;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st30;\n\t} else\n\t\tgoto st30;\n\tgoto st0;\nst30:\n\tif ( ++p == pe )\n\t\tgoto _test_eof30;\ncase 30:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st31;\n\t\tcase 95: goto st31;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st31;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st31;\n\t} else\n\t\tgoto st31;\n\tgoto st0;\nst31:\n\tif ( ++p == pe )\n\t\tgoto _test_eof31;\ncase 31:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st32;\n\t\tcase 95: goto st32;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st32;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st32;\n\t} else\n\t\tgoto st32;\n\tgoto st0;\nst32:\n\tif ( ++p == pe )\n\t\tgoto _test_eof32;\ncase 32:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st33;\n\t\tcase 95: goto st33;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st33;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st33;\n\t} else\n\t\tgoto st33;\n\tgoto st0;\nst33:\n\tif ( ++p == pe )\n\t\tgoto _test_eof33;\ncase 33:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st34;\n\t\tcase 95: goto st34;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st34;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st34;\n\t} else\n\t\tgoto st34;\n\tgoto st0;\nst34:\n\tif ( ++p == pe )\n\t\tgoto _test_eof34;\ncase 34:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st35;\n\t\tcase 95: goto st35;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st35;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st35;\n\t} else\n\t\tgoto st35;\n\tgoto st0;\nst35:\n\tif ( ++p == pe )\n\t\tgoto _test_eof35;\ncase 35:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st36;\n\t\tcase 95: goto st36;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st36;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st36;\n\t} else\n\t\tgoto st36;\n\tgoto st0;\nst36:\n\tif ( ++p == pe )\n\t\tgoto _test_eof36;\ncase 36:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st37;\n\t\tcase 95: goto st37;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st37;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st37;\n\t} else\n\t\tgoto st37;\n\tgoto st0;\nst37:\n\tif ( ++p == pe )\n\t\tgoto _test_eof37;\ncase 37:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st38;\n\t\tcase 95: goto st38;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st38;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st38;\n\t} else\n\t\tgoto st38;\n\tgoto st0;\nst38:\n\tif ( ++p == pe )\n\t\tgoto _test_eof38;\ncase 38:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st39;\n\t\tcase 95: goto st39;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st39;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st39;\n\t} else\n\t\tgoto st39;\n\tgoto st0;\nst39:\n\tif ( ++p == pe )\n\t\tgoto _test_eof39;\ncase 39:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st40;\n\t\tcase 95: goto st40;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st40;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st40;\n\t} else\n\t\tgoto st40;\n\tgoto st0;\nst40:\n\tif ( ++p == pe )\n\t\tgoto _test_eof40;\ncase 40:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st41;\n\t\tcase 95: goto st41;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st41;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st41;\n\t} else\n\t\tgoto st41;\n\tgoto st0;\nst41:\n\tif ( ++p == pe )\n\t\tgoto _test_eof41;\ncase 41:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st42;\n\t\tcase 95: goto st42;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st42;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st42;\n\t} else\n\t\tgoto st42;\n\tgoto st0;\nst42:\n\tif ( ++p == pe )\n\t\tgoto _test_eof42;\ncase 42:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st43;\n\t\tcase 95: goto st43;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st43;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st43;\n\t} else\n\t\tgoto st43;\n\tgoto st0;\nst43:\n\tif ( ++p == pe )\n\t\tgoto _test_eof43;\ncase 43:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st44;\n\t\tcase 95: goto st44;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st44;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st44;\n\t} else\n\t\tgoto st44;\n\tgoto st0;\nst44:\n\tif ( ++p == pe )\n\t\tgoto _test_eof44;\ncase 44:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st45;\n\t\tcase 95: goto st45;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st45;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st45;\n\t} else\n\t\tgoto st45;\n\tgoto st0;\nst45:\n\tif ( ++p == pe )\n\t\tgoto _test_eof45;\ncase 45:\n\tif ( (*p) == 32 )\n\t\tgoto tr2;\n\tgoto st0;\n\t}\n\t_test_eof2: cs = 2; goto _test_eof; \n\t_test_eof3: cs = 3; goto _test_eof; \n\t_test_eof4: cs = 4; goto _test_eof; \n\t_test_eof5: cs = 5; goto _test_eof; \n\t_test_eof6: cs = 6; goto _test_eof; \n\t_test_eof7: cs = 7; goto _test_eof; \n\t_test_eof8: cs = 8; goto _test_eof; \n\t_test_eof9: cs = 9; goto _test_eof; \n\t_test_eof10: cs = 10; goto _test_eof; \n\t_test_eof11: cs = 11; goto _test_eof; \n\t_test_eof12: cs = 12; goto _test_eof; \n\t_test_eof13: cs = 13; goto _test_eof; \n\t_test_eof14: cs = 14; goto _test_eof; \n\t_test_eof15: cs = 15; goto _test_eof; \n\t_test_eof16: cs = 16; goto _test_eof; \n\t_test_eof46: cs = 46; goto _test_eof; \n\t_test_eof17: cs = 17; goto _test_eof; \n\t_test_eof18: cs = 18; goto _test_eof; \n\t_test_eof19: cs = 19; goto _test_eof; \n\t_test_eof20: cs = 20; goto _test_eof; \n\t_test_eof21: cs = 21; goto _test_eof; \n\t_test_eof22: cs = 22; goto _test_eof; \n\t_test_eof23: cs = 23; goto _test_eof; \n\t_test_eof24: cs = 24; goto _test_eof; \n\t_test_eof25: cs = 25; goto _test_eof; \n\t_test_eof26: cs = 26; goto _test_eof; \n\t_test_eof27: cs = 27; goto _test_eof; \n\t_test_eof28: cs = 28; goto _test_eof; \n\t_test_eof29: cs = 29; goto _test_eof; \n\t_test_eof30: cs = 30; goto _test_eof; \n\t_test_eof31: cs = 31; goto _test_eof; \n\t_test_eof32: cs = 32; goto _test_eof; \n\t_test_eof33: cs = 33; goto _test_eof; \n\t_test_eof34: cs = 34; goto _test_eof; \n\t_test_eof35: cs = 35; goto _test_eof; \n\t_test_eof36: cs = 36; goto _test_eof; \n\t_test_eof37: cs = 37; goto _test_eof; \n\t_test_eof38: cs = 38; goto _test_eof; \n\t_test_eof39: cs = 39; goto _test_eof; \n\t_test_eof40: cs = 40; goto _test_eof; \n\t_test_eof41: cs = 41; goto _test_eof; \n\t_test_eof42: cs = 42; goto _test_eof; \n\t_test_eof43: cs = 43; goto _test_eof; \n\t_test_eof44: cs = 44; goto _test_eof; \n\t_test_eof45: cs = 45; goto _test_eof; \n\n\t_test_eof: {}\n\t_out: {}\n\t}\n\n#line 117 \"ext/puma_http11/http11_parser.rl\"\n\n  if (!puma_parser_has_error(parser))\n    parser->cs = cs;\n  parser->nread += p - (buffer + off);\n\n  assert(p <= pe && \"buffer overflow after parsing execute\");\n  assert(parser->nread <= len && \"nread longer than length\");\n  assert(parser->body_start <= len && \"body starts after buffer end\");\n  assert(parser->mark < len && \"mark is after buffer end\");\n  assert(parser->field_len <= len && \"field has length longer than whole buffer\");\n  assert(parser->field_start < len && \"field starts after buffer end\");\n\n  return(parser->nread);\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "http11_parser.c",
        "method_name": "fixed_function",
        "raw_code": "size_t puma_parser_execute(puma_parser *parser, const char *buffer, size_t len, size_t off)  {\n  const char *p, *pe;\n  int cs = parser->cs;\n\n  assert(off <= len && \"offset past end of buffer\");\n\n  p = buffer+off;\n  pe = buffer+len;\n\n  /* assert(*pe == '\\0' && \"pointer does not end on NUL\"); */\n  assert((size_t) (pe - p) == len - off && \"pointers aren't same distance\");\n\n  \n#line 87 \"ext/puma_http11/http11_parser.c\"\n\t{\n\tif ( p == pe )\n\t\tgoto _test_eof;\n\tswitch ( cs )\n\t{\ncase 1:\n\tswitch( (*p) ) {\n\t\tcase 36: goto tr0;\n\t\tcase 95: goto tr0;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto tr0;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto tr0;\n\t} else\n\t\tgoto tr0;\n\tgoto st0;\nst0:\ncs = 0;\n\tgoto _out;\ntr0:\n#line 37 \"ext/puma_http11/http11_parser.rl\"\n\t{ MARK(mark, p); }\n\tgoto st2;\nst2:\n\tif ( ++p == pe )\n\t\tgoto _test_eof2;\ncase 2:\n#line 118 \"ext/puma_http11/http11_parser.c\"\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st27;\n\t\tcase 95: goto st27;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st27;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st27;\n\t} else\n\t\tgoto st27;\n\tgoto st0;\ntr2:\n#line 50 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->request_method(parser, PTR_TO(mark), LEN(mark, p));\n  }\n\tgoto st3;\nst3:\n\tif ( ++p == pe )\n\t\tgoto _test_eof3;\ncase 3:\n#line 143 \"ext/puma_http11/http11_parser.c\"\n\tswitch( (*p) ) {\n\t\tcase 42: goto tr4;\n\t\tcase 43: goto tr5;\n\t\tcase 47: goto tr6;\n\t\tcase 58: goto tr7;\n\t}\n\tif ( (*p) < 65 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 57 )\n\t\t\tgoto tr5;\n\t} else if ( (*p) > 90 ) {\n\t\tif ( 97 <= (*p) && (*p) <= 122 )\n\t\t\tgoto tr5;\n\t} else\n\t\tgoto tr5;\n\tgoto st0;\ntr4:\n#line 37 \"ext/puma_http11/http11_parser.rl\"\n\t{ MARK(mark, p); }\n\tgoto st4;\nst4:\n\tif ( ++p == pe )\n\t\tgoto _test_eof4;\ncase 4:\n#line 167 \"ext/puma_http11/http11_parser.c\"\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr8;\n\t\tcase 35: goto tr9;\n\t}\n\tgoto st0;\ntr8:\n#line 53 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->request_uri(parser, PTR_TO(mark), LEN(mark, p));\n  }\n\tgoto st5;\ntr31:\n#line 37 \"ext/puma_http11/http11_parser.rl\"\n\t{ MARK(mark, p); }\n#line 56 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->fragment(parser, PTR_TO(mark), LEN(mark, p));\n  }\n\tgoto st5;\ntr33:\n#line 56 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->fragment(parser, PTR_TO(mark), LEN(mark, p));\n  }\n\tgoto st5;\ntr37:\n#line 69 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->request_path(parser, PTR_TO(mark), LEN(mark,p));\n  }\n#line 53 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->request_uri(parser, PTR_TO(mark), LEN(mark, p));\n  }\n\tgoto st5;\ntr41:\n#line 60 \"ext/puma_http11/http11_parser.rl\"\n\t{ MARK(query_start, p); }\n#line 61 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->query_string(parser, PTR_TO(query_start), LEN(query_start, p));\n  }\n#line 53 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->request_uri(parser, PTR_TO(mark), LEN(mark, p));\n  }\n\tgoto st5;\ntr44:\n#line 61 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->query_string(parser, PTR_TO(query_start), LEN(query_start, p));\n  }\n#line 53 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->request_uri(parser, PTR_TO(mark), LEN(mark, p));\n  }\n\tgoto st5;\nst5:\n\tif ( ++p == pe )\n\t\tgoto _test_eof5;\ncase 5:\n#line 229 \"ext/puma_http11/http11_parser.c\"\n\tif ( (*p) == 72 )\n\t\tgoto tr10;\n\tgoto st0;\ntr10:\n#line 37 \"ext/puma_http11/http11_parser.rl\"\n\t{ MARK(mark, p); }\n\tgoto st6;\nst6:\n\tif ( ++p == pe )\n\t\tgoto _test_eof6;\ncase 6:\n#line 241 \"ext/puma_http11/http11_parser.c\"\n\tif ( (*p) == 84 )\n\t\tgoto st7;\n\tgoto st0;\nst7:\n\tif ( ++p == pe )\n\t\tgoto _test_eof7;\ncase 7:\n\tif ( (*p) == 84 )\n\t\tgoto st8;\n\tgoto st0;\nst8:\n\tif ( ++p == pe )\n\t\tgoto _test_eof8;\ncase 8:\n\tif ( (*p) == 80 )\n\t\tgoto st9;\n\tgoto st0;\nst9:\n\tif ( ++p == pe )\n\t\tgoto _test_eof9;\ncase 9:\n\tif ( (*p) == 47 )\n\t\tgoto st10;\n\tgoto st0;\nst10:\n\tif ( ++p == pe )\n\t\tgoto _test_eof10;\ncase 10:\n\tif ( 48 <= (*p) && (*p) <= 57 )\n\t\tgoto st11;\n\tgoto st0;\nst11:\n\tif ( ++p == pe )\n\t\tgoto _test_eof11;\ncase 11:\n\tif ( (*p) == 46 )\n\t\tgoto st12;\n\tif ( 48 <= (*p) && (*p) <= 57 )\n\t\tgoto st11;\n\tgoto st0;\nst12:\n\tif ( ++p == pe )\n\t\tgoto _test_eof12;\ncase 12:\n\tif ( 48 <= (*p) && (*p) <= 57 )\n\t\tgoto st13;\n\tgoto st0;\nst13:\n\tif ( ++p == pe )\n\t\tgoto _test_eof13;\ncase 13:\n\tif ( (*p) == 13 )\n\t\tgoto tr18;\n\tif ( 48 <= (*p) && (*p) <= 57 )\n\t\tgoto st13;\n\tgoto st0;\ntr18:\n#line 65 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->http_version(parser, PTR_TO(mark), LEN(mark, p));\n  }\n\tgoto st14;\ntr26:\n#line 46 \"ext/puma_http11/http11_parser.rl\"\n\t{ MARK(mark, p); }\n#line 47 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->http_field(parser, PTR_TO(field_start), parser->field_len, PTR_TO(mark), LEN(mark, p));\n  }\n\tgoto st14;\ntr29:\n#line 47 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->http_field(parser, PTR_TO(field_start), parser->field_len, PTR_TO(mark), LEN(mark, p));\n  }\n\tgoto st14;\nst14:\n\tif ( ++p == pe )\n\t\tgoto _test_eof14;\ncase 14:\n#line 322 \"ext/puma_http11/http11_parser.c\"\n\tif ( (*p) == 10 )\n\t\tgoto st15;\n\tgoto st0;\nst15:\n\tif ( ++p == pe )\n\t\tgoto _test_eof15;\ncase 15:\n\tswitch( (*p) ) {\n\t\tcase 13: goto st16;\n\t\tcase 33: goto tr21;\n\t\tcase 124: goto tr21;\n\t\tcase 126: goto tr21;\n\t}\n\tif ( (*p) < 45 ) {\n\t\tif ( (*p) > 39 ) {\n\t\t\tif ( 42 <= (*p) && (*p) <= 43 )\n\t\t\t\tgoto tr21;\n\t\t} else if ( (*p) >= 35 )\n\t\t\tgoto tr21;\n\t} else if ( (*p) > 46 ) {\n\t\tif ( (*p) < 65 ) {\n\t\t\tif ( 48 <= (*p) && (*p) <= 57 )\n\t\t\t\tgoto tr21;\n\t\t} else if ( (*p) > 90 ) {\n\t\t\tif ( 94 <= (*p) && (*p) <= 122 )\n\t\t\t\tgoto tr21;\n\t\t} else\n\t\t\tgoto tr21;\n\t} else\n\t\tgoto tr21;\n\tgoto st0;\nst16:\n\tif ( ++p == pe )\n\t\tgoto _test_eof16;\ncase 16:\n\tif ( (*p) == 10 )\n\t\tgoto tr22;\n\tgoto st0;\ntr22:\n#line 73 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->body_start = p - buffer + 1;\n    parser->header_done(parser, p + 1, pe - p - 1);\n    {p++; cs = 46; goto _out;}\n  }\n\tgoto st46;\nst46:\n\tif ( ++p == pe )\n\t\tgoto _test_eof46;\ncase 46:\n#line 373 \"ext/puma_http11/http11_parser.c\"\n\tgoto st0;\ntr21:\n#line 40 \"ext/puma_http11/http11_parser.rl\"\n\t{ MARK(field_start, p); }\n#line 41 \"ext/puma_http11/http11_parser.rl\"\n\t{ snake_upcase_char((char *)p); }\n\tgoto st17;\ntr23:\n#line 41 \"ext/puma_http11/http11_parser.rl\"\n\t{ snake_upcase_char((char *)p); }\n\tgoto st17;\nst17:\n\tif ( ++p == pe )\n\t\tgoto _test_eof17;\ncase 17:\n#line 389 \"ext/puma_http11/http11_parser.c\"\n\tswitch( (*p) ) {\n\t\tcase 33: goto tr23;\n\t\tcase 58: goto tr24;\n\t\tcase 124: goto tr23;\n\t\tcase 126: goto tr23;\n\t}\n\tif ( (*p) < 45 ) {\n\t\tif ( (*p) > 39 ) {\n\t\t\tif ( 42 <= (*p) && (*p) <= 43 )\n\t\t\t\tgoto tr23;\n\t\t} else if ( (*p) >= 35 )\n\t\t\tgoto tr23;\n\t} else if ( (*p) > 46 ) {\n\t\tif ( (*p) < 65 ) {\n\t\t\tif ( 48 <= (*p) && (*p) <= 57 )\n\t\t\t\tgoto tr23;\n\t\t} else if ( (*p) > 90 ) {\n\t\t\tif ( 94 <= (*p) && (*p) <= 122 )\n\t\t\t\tgoto tr23;\n\t\t} else\n\t\t\tgoto tr23;\n\t} else\n\t\tgoto tr23;\n\tgoto st0;\ntr24:\n#line 42 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->field_len = LEN(field_start, p);\n  }\n\tgoto st18;\ntr27:\n#line 46 \"ext/puma_http11/http11_parser.rl\"\n\t{ MARK(mark, p); }\n\tgoto st18;\nst18:\n\tif ( ++p == pe )\n\t\tgoto _test_eof18;\ncase 18:\n#line 428 \"ext/puma_http11/http11_parser.c\"\n\tswitch( (*p) ) {\n\t\tcase 9: goto tr25;\n\t\tcase 13: goto tr26;\n\t\tcase 32: goto tr27;\n\t}\n\tif ( 33 <= (*p) && (*p) <= 126 )\n\t\tgoto tr25;\n\tgoto st0;\ntr25:\n#line 46 \"ext/puma_http11/http11_parser.rl\"\n\t{ MARK(mark, p); }\n\tgoto st19;\nst19:\n\tif ( ++p == pe )\n\t\tgoto _test_eof19;\ncase 19:\n#line 445 \"ext/puma_http11/http11_parser.c\"\n\tswitch( (*p) ) {\n\t\tcase 9: goto st19;\n\t\tcase 13: goto tr29;\n\t}\n\tif ( 32 <= (*p) && (*p) <= 126 )\n\t\tgoto st19;\n\tgoto st0;\ntr9:\n#line 53 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->request_uri(parser, PTR_TO(mark), LEN(mark, p));\n  }\n\tgoto st20;\ntr38:\n#line 69 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->request_path(parser, PTR_TO(mark), LEN(mark,p));\n  }\n#line 53 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->request_uri(parser, PTR_TO(mark), LEN(mark, p));\n  }\n\tgoto st20;\ntr42:\n#line 60 \"ext/puma_http11/http11_parser.rl\"\n\t{ MARK(query_start, p); }\n#line 61 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->query_string(parser, PTR_TO(query_start), LEN(query_start, p));\n  }\n#line 53 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->request_uri(parser, PTR_TO(mark), LEN(mark, p));\n  }\n\tgoto st20;\ntr45:\n#line 61 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->query_string(parser, PTR_TO(query_start), LEN(query_start, p));\n  }\n#line 53 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->request_uri(parser, PTR_TO(mark), LEN(mark, p));\n  }\n\tgoto st20;\nst20:\n\tif ( ++p == pe )\n\t\tgoto _test_eof20;\ncase 20:\n#line 495 \"ext/puma_http11/http11_parser.c\"\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr31;\n\t\tcase 60: goto st0;\n\t\tcase 62: goto st0;\n\t\tcase 127: goto st0;\n\t}\n\tif ( (*p) > 31 ) {\n\t\tif ( 34 <= (*p) && (*p) <= 35 )\n\t\t\tgoto st0;\n\t} else if ( (*p) >= 0 )\n\t\tgoto st0;\n\tgoto tr30;\ntr30:\n#line 37 \"ext/puma_http11/http11_parser.rl\"\n\t{ MARK(mark, p); }\n\tgoto st21;\nst21:\n\tif ( ++p == pe )\n\t\tgoto _test_eof21;\ncase 21:\n#line 516 \"ext/puma_http11/http11_parser.c\"\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr33;\n\t\tcase 60: goto st0;\n\t\tcase 62: goto st0;\n\t\tcase 127: goto st0;\n\t}\n\tif ( (*p) > 31 ) {\n\t\tif ( 34 <= (*p) && (*p) <= 35 )\n\t\t\tgoto st0;\n\t} else if ( (*p) >= 0 )\n\t\tgoto st0;\n\tgoto st21;\ntr5:\n#line 37 \"ext/puma_http11/http11_parser.rl\"\n\t{ MARK(mark, p); }\n\tgoto st22;\nst22:\n\tif ( ++p == pe )\n\t\tgoto _test_eof22;\ncase 22:\n#line 537 \"ext/puma_http11/http11_parser.c\"\n\tswitch( (*p) ) {\n\t\tcase 43: goto st22;\n\t\tcase 58: goto st23;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st22;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( (*p) > 90 ) {\n\t\t\tif ( 97 <= (*p) && (*p) <= 122 )\n\t\t\t\tgoto st22;\n\t\t} else if ( (*p) >= 65 )\n\t\t\tgoto st22;\n\t} else\n\t\tgoto st22;\n\tgoto st0;\ntr7:\n#line 37 \"ext/puma_http11/http11_parser.rl\"\n\t{ MARK(mark, p); }\n\tgoto st23;\nst23:\n\tif ( ++p == pe )\n\t\tgoto _test_eof23;\ncase 23:\n#line 562 \"ext/puma_http11/http11_parser.c\"\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr8;\n\t\tcase 34: goto st0;\n\t\tcase 35: goto tr9;\n\t\tcase 60: goto st0;\n\t\tcase 62: goto st0;\n\t\tcase 127: goto st0;\n\t}\n\tif ( 0 <= (*p) && (*p) <= 31 )\n\t\tgoto st0;\n\tgoto st23;\ntr6:\n#line 37 \"ext/puma_http11/http11_parser.rl\"\n\t{ MARK(mark, p); }\n\tgoto st24;\nst24:\n\tif ( ++p == pe )\n\t\tgoto _test_eof24;\ncase 24:\n#line 582 \"ext/puma_http11/http11_parser.c\"\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr37;\n\t\tcase 34: goto st0;\n\t\tcase 35: goto tr38;\n\t\tcase 60: goto st0;\n\t\tcase 62: goto st0;\n\t\tcase 63: goto tr39;\n\t\tcase 127: goto st0;\n\t}\n\tif ( 0 <= (*p) && (*p) <= 31 )\n\t\tgoto st0;\n\tgoto st24;\ntr39:\n#line 69 \"ext/puma_http11/http11_parser.rl\"\n\t{\n    parser->request_path(parser, PTR_TO(mark), LEN(mark,p));\n  }\n\tgoto st25;\nst25:\n\tif ( ++p == pe )\n\t\tgoto _test_eof25;\ncase 25:\n#line 605 \"ext/puma_http11/http11_parser.c\"\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr41;\n\t\tcase 34: goto st0;\n\t\tcase 35: goto tr42;\n\t\tcase 60: goto st0;\n\t\tcase 62: goto st0;\n\t\tcase 127: goto st0;\n\t}\n\tif ( 0 <= (*p) && (*p) <= 31 )\n\t\tgoto st0;\n\tgoto tr40;\ntr40:\n#line 60 \"ext/puma_http11/http11_parser.rl\"\n\t{ MARK(query_start, p); }\n\tgoto st26;\nst26:\n\tif ( ++p == pe )\n\t\tgoto _test_eof26;\ncase 26:\n#line 625 \"ext/puma_http11/http11_parser.c\"\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr44;\n\t\tcase 34: goto st0;\n\t\tcase 35: goto tr45;\n\t\tcase 60: goto st0;\n\t\tcase 62: goto st0;\n\t\tcase 127: goto st0;\n\t}\n\tif ( 0 <= (*p) && (*p) <= 31 )\n\t\tgoto st0;\n\tgoto st26;\nst27:\n\tif ( ++p == pe )\n\t\tgoto _test_eof27;\ncase 27:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st28;\n\t\tcase 95: goto st28;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st28;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st28;\n\t} else\n\t\tgoto st28;\n\tgoto st0;\nst28:\n\tif ( ++p == pe )\n\t\tgoto _test_eof28;\ncase 28:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st29;\n\t\tcase 95: goto st29;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st29;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st29;\n\t} else\n\t\tgoto st29;\n\tgoto st0;\nst29:\n\tif ( ++p == pe )\n\t\tgoto _test_eof29;\ncase 29:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st30;\n\t\tcase 95: goto st30;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st30;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st30;\n\t} else\n\t\tgoto st30;\n\tgoto st0;\nst30:\n\tif ( ++p == pe )\n\t\tgoto _test_eof30;\ncase 30:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st31;\n\t\tcase 95: goto st31;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st31;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st31;\n\t} else\n\t\tgoto st31;\n\tgoto st0;\nst31:\n\tif ( ++p == pe )\n\t\tgoto _test_eof31;\ncase 31:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st32;\n\t\tcase 95: goto st32;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st32;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st32;\n\t} else\n\t\tgoto st32;\n\tgoto st0;\nst32:\n\tif ( ++p == pe )\n\t\tgoto _test_eof32;\ncase 32:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st33;\n\t\tcase 95: goto st33;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st33;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st33;\n\t} else\n\t\tgoto st33;\n\tgoto st0;\nst33:\n\tif ( ++p == pe )\n\t\tgoto _test_eof33;\ncase 33:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st34;\n\t\tcase 95: goto st34;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st34;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st34;\n\t} else\n\t\tgoto st34;\n\tgoto st0;\nst34:\n\tif ( ++p == pe )\n\t\tgoto _test_eof34;\ncase 34:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st35;\n\t\tcase 95: goto st35;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st35;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st35;\n\t} else\n\t\tgoto st35;\n\tgoto st0;\nst35:\n\tif ( ++p == pe )\n\t\tgoto _test_eof35;\ncase 35:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st36;\n\t\tcase 95: goto st36;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st36;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st36;\n\t} else\n\t\tgoto st36;\n\tgoto st0;\nst36:\n\tif ( ++p == pe )\n\t\tgoto _test_eof36;\ncase 36:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st37;\n\t\tcase 95: goto st37;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st37;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st37;\n\t} else\n\t\tgoto st37;\n\tgoto st0;\nst37:\n\tif ( ++p == pe )\n\t\tgoto _test_eof37;\ncase 37:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st38;\n\t\tcase 95: goto st38;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st38;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st38;\n\t} else\n\t\tgoto st38;\n\tgoto st0;\nst38:\n\tif ( ++p == pe )\n\t\tgoto _test_eof38;\ncase 38:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st39;\n\t\tcase 95: goto st39;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st39;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st39;\n\t} else\n\t\tgoto st39;\n\tgoto st0;\nst39:\n\tif ( ++p == pe )\n\t\tgoto _test_eof39;\ncase 39:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st40;\n\t\tcase 95: goto st40;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st40;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st40;\n\t} else\n\t\tgoto st40;\n\tgoto st0;\nst40:\n\tif ( ++p == pe )\n\t\tgoto _test_eof40;\ncase 40:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st41;\n\t\tcase 95: goto st41;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st41;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st41;\n\t} else\n\t\tgoto st41;\n\tgoto st0;\nst41:\n\tif ( ++p == pe )\n\t\tgoto _test_eof41;\ncase 41:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st42;\n\t\tcase 95: goto st42;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st42;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st42;\n\t} else\n\t\tgoto st42;\n\tgoto st0;\nst42:\n\tif ( ++p == pe )\n\t\tgoto _test_eof42;\ncase 42:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st43;\n\t\tcase 95: goto st43;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st43;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st43;\n\t} else\n\t\tgoto st43;\n\tgoto st0;\nst43:\n\tif ( ++p == pe )\n\t\tgoto _test_eof43;\ncase 43:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st44;\n\t\tcase 95: goto st44;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st44;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st44;\n\t} else\n\t\tgoto st44;\n\tgoto st0;\nst44:\n\tif ( ++p == pe )\n\t\tgoto _test_eof44;\ncase 44:\n\tswitch( (*p) ) {\n\t\tcase 32: goto tr2;\n\t\tcase 36: goto st45;\n\t\tcase 95: goto st45;\n\t}\n\tif ( (*p) < 48 ) {\n\t\tif ( 45 <= (*p) && (*p) <= 46 )\n\t\t\tgoto st45;\n\t} else if ( (*p) > 57 ) {\n\t\tif ( 65 <= (*p) && (*p) <= 90 )\n\t\t\tgoto st45;\n\t} else\n\t\tgoto st45;\n\tgoto st0;\nst45:\n\tif ( ++p == pe )\n\t\tgoto _test_eof45;\ncase 45:\n\tif ( (*p) == 32 )\n\t\tgoto tr2;\n\tgoto st0;\n\t}\n\t_test_eof2: cs = 2; goto _test_eof; \n\t_test_eof3: cs = 3; goto _test_eof; \n\t_test_eof4: cs = 4; goto _test_eof; \n\t_test_eof5: cs = 5; goto _test_eof; \n\t_test_eof6: cs = 6; goto _test_eof; \n\t_test_eof7: cs = 7; goto _test_eof; \n\t_test_eof8: cs = 8; goto _test_eof; \n\t_test_eof9: cs = 9; goto _test_eof; \n\t_test_eof10: cs = 10; goto _test_eof; \n\t_test_eof11: cs = 11; goto _test_eof; \n\t_test_eof12: cs = 12; goto _test_eof; \n\t_test_eof13: cs = 13; goto _test_eof; \n\t_test_eof14: cs = 14; goto _test_eof; \n\t_test_eof15: cs = 15; goto _test_eof; \n\t_test_eof16: cs = 16; goto _test_eof; \n\t_test_eof46: cs = 46; goto _test_eof; \n\t_test_eof17: cs = 17; goto _test_eof; \n\t_test_eof18: cs = 18; goto _test_eof; \n\t_test_eof19: cs = 19; goto _test_eof; \n\t_test_eof20: cs = 20; goto _test_eof; \n\t_test_eof21: cs = 21; goto _test_eof; \n\t_test_eof22: cs = 22; goto _test_eof; \n\t_test_eof23: cs = 23; goto _test_eof; \n\t_test_eof24: cs = 24; goto _test_eof; \n\t_test_eof25: cs = 25; goto _test_eof; \n\t_test_eof26: cs = 26; goto _test_eof; \n\t_test_eof27: cs = 27; goto _test_eof; \n\t_test_eof28: cs = 28; goto _test_eof; \n\t_test_eof29: cs = 29; goto _test_eof; \n\t_test_eof30: cs = 30; goto _test_eof; \n\t_test_eof31: cs = 31; goto _test_eof; \n\t_test_eof32: cs = 32; goto _test_eof; \n\t_test_eof33: cs = 33; goto _test_eof; \n\t_test_eof34: cs = 34; goto _test_eof; \n\t_test_eof35: cs = 35; goto _test_eof; \n\t_test_eof36: cs = 36; goto _test_eof; \n\t_test_eof37: cs = 37; goto _test_eof; \n\t_test_eof38: cs = 38; goto _test_eof; \n\t_test_eof39: cs = 39; goto _test_eof; \n\t_test_eof40: cs = 40; goto _test_eof; \n\t_test_eof41: cs = 41; goto _test_eof; \n\t_test_eof42: cs = 42; goto _test_eof; \n\t_test_eof43: cs = 43; goto _test_eof; \n\t_test_eof44: cs = 44; goto _test_eof; \n\t_test_eof45: cs = 45; goto _test_eof; \n\n\t_test_eof: {}\n\t_out: {}\n\t}\n\n#line 117 \"ext/puma_http11/http11_parser.rl\"\n\n  if (!puma_parser_has_error(parser))\n    parser->cs = cs;\n  parser->nread += p - (buffer + off);\n\n  assert(p <= pe && \"buffer overflow after parsing execute\");\n  assert(parser->nread <= len && \"nread longer than length\");\n  assert(parser->body_start <= len && \"body starts after buffer end\");\n  assert(parser->mark < len && \"mark is after buffer end\");\n  assert(parser->field_len <= len && \"field has length longer than whole buffer\");\n  assert(parser->field_start < len && \"field starts after buffer end\");\n\n  return(parser->nread);\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <ctype.h>\n#include \"http11_parser.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <string.h>\n\n// Type Definitions:\n// puma_parser:\ntypedef struct puma_parser {\n  int cs;\n  int content_len;\n  size_t body_start;\n  size_t nread;\n  size_t mark;\n  size_t field_start;\n  size_t field_len;\n  size_t query_start;\n\n  VALUE request;\n  VALUE body;\n\n  field_cb http_field;\n  element_cb request_method;\n  element_cb request_uri;\n  element_cb fragment;\n  element_cb request_path;\n  element_cb query_string;\n  element_cb http_version;\n  element_cb header_done;\n\n  char buf[BUFFER_LEN];\n  \n} puma_parser;\n\n// puma_parser:\ntypedef struct puma_parser {\n  int cs;\n  int content_len;\n  size_t body_start;\n  size_t nread;\n  size_t mark;\n  size_t field_start;\n  size_t field_len;\n  size_t query_start;\n\n  VALUE request;\n  VALUE body;\n\n  field_cb http_field;\n  element_cb request_method;\n  element_cb request_uri;\n  element_cb fragment;\n  element_cb request_path;\n  element_cb query_string;\n  element_cb http_version;\n  element_cb header_done;\n\n  char buf[BUFFER_LEN];\n  \n}\n\n// Called Methods (top 10):\n// snake_upcase_char from ext/puma_http11/http11_parser.c:\nstatic void snake_upcase_char(char *c) /* <=== snake_upcase_char */ \n{\n    if (*c >= 'a' && *c <= 'z')\n      *c &= ~0x20;\n    else if (*c == '_')\n      *c = ',';\n    else if (*c == '-')\n      *c = '_';\n}\n\n// PTR_TO from ext/puma_http11/http11_parser.c:\n#define PTR_TO(F) (buffer + parser->F) /* <=== ext/puma_http11/http11_parser.c:31:31:PTR_TO:1 */ \n\n// LEN from ext/puma_http11/http11_parser.c:\n#define LEN(AT, FPC) (FPC - buffer - parser->AT) /* <=== ext/puma_http11/http11_parser.c:29:29:LEN:2 */ \n\n// puma_parser_has_error from ext/puma_http11/http11_parser.c:\nint puma_parser_has_error(puma_parser *parser) { /* <=== puma_parser_has_error */ \n  return parser->cs == puma_parser_error;\n}\n\n// MARK from ext/puma_http11/http11_parser.c:\n#define MARK(M,FPC) (parser->M = (FPC) - buffer) /* <=== ext/puma_http11/http11_parser.c:30:30:MARK:2 */ \n"
  },
  {
    "repository": "tensorflow",
    "cve_id": "CVE-2021-41203",
    "cwe_list": [
      "CWE-345"
    ],
    "commit_hash": "368af875869a204b4ac552b9ddda59f6a46a56ec",
    "short_hash": "368af875",
    "vulnerableMethods_before": [
      {
        "filename": "tensor_slice_reader.h",
        "method_name": "vulnerable_function",
        "raw_code": "bool TensorSliceReader::CopySliceData(const string& name,\n                                      const TensorSlice& slice, T* data) const {\n  std::vector<std::pair<TensorSlice, string>> details;\n  const TensorSliceSet* tss;\n  {\n    mutex_lock l(mu_);\n    tss = FindTensorSlice(name, slice, &details);\n    if (!tss && !all_shards_loaded_) {\n      VLOG(1) << \"Did not find slice in preferred shard, loading all shards.\"\n              << name << \": \" << slice.DebugString();\n      LoadAllShards();\n      tss = FindTensorSlice(name, slice, &details);\n    }\n    if (!tss) {\n      // No such tensor\n      return false;\n    }\n  }\n  // We have the data -- copy it over.\n  string value;\n  for (const auto& x : details) {\n    const TensorSlice& slice_s = x.first;\n    const string& fname = x.second;\n    int idx = gtl::FindWithDefault(fname_to_index_, fname, -1);\n    CHECK_GE(idx, 0) << \"Failed to find the index for filename \" << fname;\n    // We read a record in the corresponding sstable\n    const string key = EncodeTensorNameSlice(name, slice_s);\n    if (!sss_[idx]->Get(key, &value)) {\n      VLOG(1) << \"Failed to seek to the record for tensor \" << name\n              << \", slice \" << slice_s.DebugString()\n              << \": computed key = \" << key;\n      return false;\n    }\n    SavedTensorSlices sts;\n    if (!ParseProtoUnlimited(&sts, value)) {\n      VLOG(1) << \"Failed to parse the record for tensor \" << name << \", slice \"\n              << slice_s.DebugString() << \": computed key = \" << key;\n      return false;\n    }\n    CopyDataFromTensorSliceToTensorSlice(\n        tss->shape(), slice_s, slice,\n        checkpoint::TensorProtoData<T>(sts.data().data()), data);\n  }\n  return true;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "tensor_slice_reader.h",
        "method_name": "fixed_function",
        "raw_code": "bool TensorSliceReader::CopySliceData(const string& name,\n                                      const TensorSlice& slice, T* data) const {\n  std::vector<std::pair<TensorSlice, string>> details;\n  const TensorSliceSet* tss;\n  {\n    mutex_lock l(mu_);\n    tss = FindTensorSlice(name, slice, &details);\n    if (!tss && !all_shards_loaded_) {\n      VLOG(1) << \"Did not find slice in preferred shard, loading all shards.\"\n              << name << \": \" << slice.DebugString();\n      LoadAllShards();\n      tss = FindTensorSlice(name, slice, &details);\n    }\n    if (!tss) {\n      // No such tensor\n      return false;\n    }\n  }\n  // We have the data -- copy it over.\n  string value;\n  for (const auto& x : details) {\n    const TensorSlice& slice_s = x.first;\n    const string& fname = x.second;\n    int idx = gtl::FindWithDefault(fname_to_index_, fname, -1);\n    CHECK_GE(idx, 0) << \"Failed to find the index for filename \" << fname;\n    // We read a record in the corresponding sstable\n    const string key = EncodeTensorNameSlice(name, slice_s);\n    if (!sss_[idx]->Get(key, &value)) {\n      VLOG(1) << \"Failed to seek to the record for tensor \" << name\n              << \", slice \" << slice_s.DebugString()\n              << \": computed key = \" << key;\n      return false;\n    }\n    SavedTensorSlices sts;\n    if (!ParseProtoUnlimited(&sts, value)) {\n      VLOG(1) << \"Failed to parse the record for tensor \" << name << \", slice \"\n              << slice_s.DebugString() << \": computed key = \" << key;\n      return false;\n    }\n    // Ensure the TensorSlice contains the expected amount of data.\n    TensorShape shp_s;\n    Status s = slice_s.SliceTensorShape(tss->shape(), &shp_s);\n    if (!s.ok()) {\n      VLOG(1) << \"Failed to slice tensor \" << name << \", slice \"\n              << slice_s.DebugString() << \": \" << s;\n      return false;\n    }\n    if (checkpoint::TensorProtoDataSize<T>(sts.data().data()) !=\n        shp_s.num_elements()) {\n      VLOG(1) << \"Tensor \" << name << \", slice \" << slice_s.DebugString()\n              << \" had an unexpected amount of data: expected = \"\n              << shp_s.num_elements() << \", got = \"\n              << checkpoint::TensorProtoDataSize<T>(sts.data().data());\n      return false;\n    }\n    CopyDataFromTensorSliceToTensorSlice(\n        tss->shape(), slice_s, slice,\n        checkpoint::TensorProtoData<T>(sts.data().data()), data);\n  }\n  return true;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"tensorflow/core/platform/types.h\"\n#include \"tensorflow/core/platform/macros.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include <unordered_map>\n#include \"tensorflow/core/util/tensor_slice_util.h\"\n#include \"tensorflow/core/util/saved_tensor_slice.pb.h\"\n#include \"tensorflow/core/framework/types.pb.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/lib/core/stringpiece.h\"\n#include \"tensorflow/core/lib/gtl/map_util.h\"\n#include \"tensorflow/core/util/tensor_slice_set.h\"\n#include \"tensorflow/core/lib/core/status.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_slice.h\"\n#include \"tensorflow/core/platform/mutex.h\"\n#include \"tensorflow/core/util/saved_tensor_slice_util.h\"\n#include \"tensorflow/core/platform/protobuf.h\"\n#include <vector>\n"
  },
  {
    "repository": "FreeRDP",
    "cve_id": "CVE-2020-11038",
    "cwe_list": [
      "CWE-190"
    ],
    "commit_hash": "06c32f170093a6ecde93e3bc07fed6a706bfbeb3",
    "short_hash": "06c32f17",
    "vulnerableMethods_before": [
      {
        "filename": "video_main.c",
        "method_name": "vulnerable_function",
        "raw_code": "static PresentationContext* PresentationContext_new(VideoClientContext* video, BYTE PresentationId,\n                                                    UINT32 x, UINT32 y, UINT32 width, UINT32 height)\n{\n\tVideoClientContextPriv* priv = video->priv;\n\tPresentationContext* ret = calloc(1, sizeof(*ret));\n\tif (!ret)\n\t\treturn NULL;\n\n\tret->video = video;\n\tret->PresentationId = PresentationId;\n\n\tret->h264 = h264_context_new(FALSE);\n\tif (!ret->h264)\n\t{\n\t\tWLog_ERR(TAG, \"unable to create a h264 context\");\n\t\tgoto error_h264;\n\t}\n\th264_context_reset(ret->h264, width, height);\n\n\tret->currentSample = Stream_New(NULL, 4096);\n\tif (!ret->currentSample)\n\t{\n\t\tWLog_ERR(TAG, \"unable to create current packet stream\");\n\t\tgoto error_currentSample;\n\t}\n\n\tret->surfaceData = BufferPool_Take(priv->surfacePool, width * height * 4);\n\tif (!ret->surfaceData)\n\t{\n\t\tWLog_ERR(TAG, \"unable to allocate surfaceData\");\n\t\tgoto error_surfaceData;\n\t}\n\n\tret->surface = video->createSurface(video, ret->surfaceData, x, y, width, height);\n\tif (!ret->surface)\n\t{\n\t\tWLog_ERR(TAG, \"unable to create surface\");\n\t\tgoto error_surface;\n\t}\n\n\tret->yuv = yuv_context_new(FALSE);\n\tif (!ret->yuv)\n\t{\n\t\tWLog_ERR(TAG, \"unable to create YUV decoder\");\n\t\tgoto error_yuv;\n\t}\n\n\tyuv_context_reset(ret->yuv, width, height);\n\tret->refCounter = 1;\n\treturn ret;\n\nerror_yuv:\n\tvideo->deleteSurface(video, ret->surface);\nerror_surface:\n\tBufferPool_Return(priv->surfacePool, ret->surfaceData);\nerror_surfaceData:\n\tStream_Free(ret->currentSample, TRUE);\nerror_currentSample:\n\th264_context_free(ret->h264);\nerror_h264:\n\tfree(ret);\n\treturn NULL;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "video_main.c",
        "method_name": "fixed_function",
        "raw_code": "static PresentationContext* PresentationContext_new(VideoClientContext* video, BYTE PresentationId,\n                                                    UINT32 x, UINT32 y, UINT32 width, UINT32 height)\n{\n\tsize_t s;\n\tVideoClientContextPriv* priv = video->priv;\n\tPresentationContext* ret;\n\ts = width * height * 4ULL;\n\tif (s > INT32_MAX)\n\t\treturn NULL;\n\n\tret = calloc(1, sizeof(*ret));\n\tif (!ret)\n\t\treturn NULL;\n\n\tret->video = video;\n\tret->PresentationId = PresentationId;\n\n\tret->h264 = h264_context_new(FALSE);\n\tif (!ret->h264)\n\t{\n\t\tWLog_ERR(TAG, \"unable to create a h264 context\");\n\t\tgoto error_h264;\n\t}\n\th264_context_reset(ret->h264, width, height);\n\n\tret->currentSample = Stream_New(NULL, 4096);\n\tif (!ret->currentSample)\n\t{\n\t\tWLog_ERR(TAG, \"unable to create current packet stream\");\n\t\tgoto error_currentSample;\n\t}\n\n\tret->surfaceData = BufferPool_Take(priv->surfacePool, s);\n\tif (!ret->surfaceData)\n\t{\n\t\tWLog_ERR(TAG, \"unable to allocate surfaceData\");\n\t\tgoto error_surfaceData;\n\t}\n\n\tret->surface = video->createSurface(video, ret->surfaceData, x, y, width, height);\n\tif (!ret->surface)\n\t{\n\t\tWLog_ERR(TAG, \"unable to create surface\");\n\t\tgoto error_surface;\n\t}\n\n\tret->yuv = yuv_context_new(FALSE);\n\tif (!ret->yuv)\n\t{\n\t\tWLog_ERR(TAG, \"unable to create YUV decoder\");\n\t\tgoto error_yuv;\n\t}\n\n\tyuv_context_reset(ret->yuv, width, height);\n\tret->refCounter = 1;\n\treturn ret;\n\nerror_yuv:\n\tvideo->deleteSurface(video, ret->surface);\nerror_surface:\n\tBufferPool_Return(priv->surfacePool, ret->surfaceData);\nerror_surfaceData:\n\tStream_Free(ret->currentSample, TRUE);\nerror_currentSample:\n\th264_context_free(ret->h264);\nerror_h264:\n\tfree(ret);\n\treturn NULL;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <winpr/interlocked.h>\n#include <freerdp/client/geometry.h>\n#include <winpr/print.h>\n#include <winpr/sysinfo.h>\n#include <freerdp/codec/h264.h>\n#include <winpr/stream.h>\n#include <freerdp/channels/log.h>\n#include <freerdp/addin.h>\n#include \"config.h\"\n#include <freerdp/client/video.h>\n#include <freerdp/codec/yuv.h>\n#include <stdlib.h>\n#include <winpr/collections.h>\n#include <freerdp/primitives.h>\n#include <winpr/synch.h>\n#include <winpr/cmdline.h>\n#include \"video_main.h\"\n#include <stdio.h>\n#include <winpr/crt.h>\n#include <string.h>\n\n// Type Definitions:\n// VideoClientContextPriv:\ntypedef struct _VideoClientContextPriv VideoClientContextPriv;\n\n// VideoClientContext:\ntypedef struct _VideoClientContext VideoClientContext;\n\n// PresentationContext:\ntypedef struct _PresentationContext PresentationContext;\n\n// BYTE:\ntypedef unsigned char BYTE;\n\n// Called Methods (top 10):\n// GetSystemInfo from winpr/libwinpr/sysinfo/sysinfo.c:\nvoid GetSystemInfo(LPSYSTEM_INFO lpSystemInfo) /* <=== GetSystemInfo */ \n{\n\tlpSystemInfo->wProcessorArchitecture = GetProcessorArchitecture();\n\tlpSystemInfo->wReserved = 0;\n\tlpSystemInfo->dwPageSize = GetSystemPageSize();\n\tlpSystemInfo->lpMinimumApplicationAddress = NULL;\n\tlpSystemInfo->lpMaximumApplicationAddress = NULL;\n\tlpSystemInfo->dwActiveProcessorMask = 0;\n\tlpSystemInfo->dwNumberOfProcessors = GetNumberOfProcessors();\n\tlpSystemInfo->dwProcessorType = 0;\n\tlpSystemInfo->dwAllocationGranularity = 0;\n\tlpSystemInfo->wProcessorLevel = 0;\n\tlpSystemInfo->wProcessorRevision = 0;\n}\n\n// TAG from channels/video/client/video_main.c:\n#define TAG CHANNELS_TAG(\"video\") /* <=== channels/video/client/video_main.c:45:45:TAG:0 */ \n\n// BufferPool_ShiftUsed from winpr/libwinpr/utils/collections/BufferPool.c:\nstatic BOOL BufferPool_ShiftUsed(wBufferPool* pool, int index, int count) /* <=== BufferPool_ShiftUsed */ \n{\n\tif (count > 0)\n\t{\n\t\tif (pool->uSize + count > pool->uCapacity)\n\t\t{\n\t\t\tint newUCapacity = pool->uCapacity * 2;\n\t\t\twBufferPoolItem* newUArray =\n\t\t\t    (wBufferPoolItem*)realloc(pool->uArray, sizeof(wBufferPoolItem) * newUCapacity);\n\t\t\tif (!newUArray)\n\t\t\t\treturn FALSE;\n\t\t\tpool->uCapacity = newUCapacity;\n\t\t\tpool->uArray = newUArray;\n\t\t}\n\n\t\tMoveMemory(&pool->uArray[index + count], &pool->uArray[index],\n\t\t           (pool->uSize - index) * sizeof(wBufferPoolItem));\n\t\tpool->uSize += count;\n\t}\n\telse if (count < 0)\n\t{\n\t\tMoveMemory(&pool->uArray[index], &pool->uArray[index - count],\n\t\t           (pool->uSize - index) * sizeof(wBufferPoolItem));\n\t\tpool->uSize += count;\n\t}\n\treturn TRUE;\n}\n\n// WINPR_ALIGNED_MEM_SIGNATURE from winpr/libwinpr/crt/alignment.c:\n#define WINPR_ALIGNED_MEM_SIGNATURE 0x0BA0BAB /* <=== winpr/libwinpr/crt/alignment.c:33:33:WINPR_ALIGNED_MEM_SIGNATURE:0 */ \n\n// GetNativeSystemInfo from winpr/libwinpr/sysinfo/sysinfo.c:\nvoid GetNativeSystemInfo(LPSYSTEM_INFO lpSystemInfo) /* <=== GetNativeSystemInfo */ \n{\n\tGetSystemInfo(lpSystemInfo);\n}\n\n// GetCurrentThreadId from winpr/libwinpr/thread/thread.c:\nDWORD GetCurrentThreadId(VOID) /* <=== GetCurrentThreadId */ \n{\n\tpthread_t tid;\n\ttid = pthread_self();\n\t/* Since pthread_t can be 64-bits on some systems, take just the    */\n\t/* lower 32-bits of it for the thread ID returned by this function. */\n\treturn (DWORD)tid & 0xffffffffUL;\n}\n\n// TAG from libfreerdp/codec/h264.c:\n#define TAG FREERDP_TAG(\"codec\") /* <=== libfreerdp/codec/h264.c:37:37:TAG:0 */ \n\n// BufferPool_Return from winpr/libwinpr/utils/collections/BufferPool.c:\nBOOL BufferPool_Return(wBufferPool* pool, void* buffer) /* <=== BufferPool_Return */ \n{\n\tint size = 0;\n\tint index = 0;\n\tBOOL found = FALSE;\n\n\tif (pool->synchronized)\n\t\tEnterCriticalSection(&pool->lock);\n\n\tif (pool->fixedSize)\n\t{\n\t\t/* fixed size buffers */\n\n\t\tif ((pool->size + 1) >= pool->capacity)\n\t\t{\n\t\t\tint newCapacity = pool->capacity * 2;\n\t\t\tvoid** newArray = (void**)realloc(pool->array, sizeof(void*) * newCapacity);\n\t\t\tif (!newArray)\n\t\t\t\tgoto out_error;\n\n\t\t\tpool->capacity = newCapacity;\n\t\t\tpool->array = newArray;\n\t\t}\n\n\t\tpool->array[(pool->size)++] = buffer;\n\t}\n\telse\n\t{\n\t\t/* variable size buffers */\n\n\t\tfor (index = 0; index < pool->uSize; index++)\n\t\t{\n\t\t\tif (pool->uArray[index].buffer == buffer)\n\t\t\t{\n\t\t\t\tfound = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (found)\n\t\t{\n\t\t\tsize = pool->uArray[index].size;\n\t\t\tif (!BufferPool_ShiftUsed(pool, index, -1))\n\t\t\t\tgoto out_error;\n\t\t}\n\n\t\tif (size)\n\t\t{\n\t\t\tif ((pool->aSize + 1) >= pool->aCapacity)\n\t\t\t{\n\t\t\t\tint newCapacity = pool->aCapacity * 2;\n\t\t\t\twBufferPoolItem* newArray =\n\t\t\t\t    (wBufferPoolItem*)realloc(pool->aArray, sizeof(wBufferPoolItem) * newCapacity);\n\t\t\t\tif (!newArray)\n\t\t\t\t\tgoto out_error;\n\n\t\t\t\tpool->aCapacity = newCapacity;\n\t\t\t\tpool->aArray = newArray;\n\t\t\t}\n\n\t\t\tpool->aArray[pool->aSize].buffer = buffer;\n\t\t\tpool->aArray[pool->aSize].size = size;\n\t\t\t(pool->aSize)++;\n\t\t}\n\t}\n\n\tif (pool->synchronized)\n\t\tLeaveCriticalSection(&pool->lock);\n\treturn TRUE;\n\nout_error:\n\tif (pool->synchronized)\n\t\tLeaveCriticalSection(&pool->lock);\n\treturn FALSE;\n}\n\n// LeaveCriticalSection from winpr/libwinpr/synch/critical.c:\nVOID LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection) /* <=== LeaveCriticalSection */ \n{\n\t/* Decrement RecursionCount and check if this is the last LeaveCriticalSection call ...*/\n\tif (--lpCriticalSection->RecursionCount < 1)\n\t{\n\t\t/* Last recursion, clear owner, unlock and if there are other waiting threads ... */\n\t\tlpCriticalSection->OwningThread = NULL;\n\n\t\tif (InterlockedDecrement(&lpCriticalSection->LockCount) >= 0)\n\t\t{\n\t\t\t/* ...signal the semaphore to unblock the next waiting thread */\n\t\t\t_UnWaitCriticalSection(lpCriticalSection);\n\t\t}\n\t}\n\telse\n\t{\n\t\tInterlockedDecrement(&lpCriticalSection->LockCount);\n\t}\n}\n\n// yuv_context_new from libfreerdp/codec/yuv.c:\nYUV_CONTEXT* yuv_context_new(BOOL encoder) /* <=== yuv_context_new */ \n{\n\tSYSTEM_INFO sysInfos;\n\tYUV_CONTEXT* ret = calloc(1, sizeof(*ret));\n\tif (!ret)\n\t\treturn NULL;\n\n\t/** do it here to avoid a race condition between threads */\n\tprimitives_get();\n\n\tGetNativeSystemInfo(&sysInfos);\n\tret->useThreads = (sysInfos.dwNumberOfProcessors > 1);\n\tif (ret->useThreads)\n\t{\n\t\tret->nthreads = sysInfos.dwNumberOfProcessors;\n\t\tret->threadPool = CreateThreadpool(NULL);\n\t\tif (!ret->threadPool)\n\t\t{\n\t\t\tgoto error_threadpool;\n\t\t}\n\n\t\tInitializeThreadpoolEnvironment(&ret->ThreadPoolEnv);\n\t\tSetThreadpoolCallbackPool(&ret->ThreadPoolEnv, ret->threadPool);\n\t}\n\telse\n\t{\n\t\tret->nthreads = 1;\n\t}\n\n\treturn ret;\n\nerror_threadpool:\n\tfree(ret);\n\treturn NULL;\n}\n"
  },
  {
    "repository": "squashfs-tools",
    "cve_id": "CVE-2021-41072",
    "cwe_list": [
      "CWE-200"
    ],
    "commit_hash": "e0485802ec72996c20026da320650d8362f555bd",
    "short_hash": "e0485802",
    "vulnerableMethods_before": [
      {
        "filename": "None",
        "method_name": "vulnerable_function",
        "raw_code": "static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,\n\tstruct inode **i)\n{\n\tstruct squashfs_dir_header dirh;\n\tchar buffer[sizeof(struct squashfs_dir_entry) + SQUASHFS_NAME_LEN + 1]\n\t\t__attribute__((aligned));\n\tstruct squashfs_dir_entry *dire = (struct squashfs_dir_entry *) buffer;\n\tlong long start;\n\tint bytes = 0, dir_count, size, res;\n\tstruct dir_ent *ent, *cur_ent = NULL;\n\tstruct dir *dir;\n\n\tTRACE(\"squashfs_opendir: inode start block %d, offset %d\\n\",\n\t\tblock_start, offset);\n\n\t*i = read_inode(block_start, offset);\n\n\tdir = malloc(sizeof(struct dir));\n\tif(dir == NULL)\n\t\tMEM_ERROR();\n\n\tdir->dir_count = 0;\n\tdir->cur_entry = NULL;\n\tdir->mode = (*i)->mode;\n\tdir->uid = (*i)->uid;\n\tdir->guid = (*i)->gid;\n\tdir->mtime = (*i)->time;\n\tdir->xattr = (*i)->xattr;\n\tdir->dirs = NULL;\n\n\tif ((*i)->data == 3)\n\t\t/*\n\t\t * if the directory is empty, skip the unnecessary\n\t\t * lookup_entry, this fixes the corner case with\n\t\t * completely empty filesystems where lookup_entry correctly\n\t\t * returning -1 is incorrectly treated as an error\n\t\t */\n\t\treturn dir;\n\n\tstart = sBlk.s.directory_table_start + (*i)->start;\n\toffset = (*i)->offset;\n\tsize = (*i)->data + bytes - 3;\n\n\twhile(bytes < size) {\t\t\t\n\t\tres = read_directory_data(&dirh, &start, &offset, sizeof(dirh));\n\t\tif(res == FALSE)\n\t\t\tgoto corrupted;\n\n\t\tSQUASHFS_INSWAP_DIR_HEADER(&dirh);\n\t\n\t\tdir_count = dirh.count + 1;\n\t\tTRACE(\"squashfs_opendir: Read directory header @ byte position \"\n\t\t\t\"%d, %d directory entries\\n\", bytes, dir_count);\n\t\tbytes += sizeof(dirh);\n\n\t\t/* dir_count should never be larger than SQUASHFS_DIR_COUNT */\n\t\tif(dir_count > SQUASHFS_DIR_COUNT) {\n\t\t\tERROR(\"File system corrupted: too many entries in directory\\n\");\n\t\t\tgoto corrupted;\n\t\t}\n\n\t\twhile(dir_count--) {\n\t\t\tres = read_directory_data(dire, &start, &offset, sizeof(*dire));\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tSQUASHFS_INSWAP_DIR_ENTRY(dire);\n\n\t\t\tbytes += sizeof(*dire);\n\n\t\t\t/* size should never be SQUASHFS_NAME_LEN or larger */\n\t\t\tif(dire->size >= SQUASHFS_NAME_LEN) {\n\t\t\t\tERROR(\"File system corrupted: filename too long\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tres = read_directory_data(dire->name, &start, &offset,\n\t\t\t\t\t\t\t\tdire->size + 1);\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tdire->name[dire->size + 1] = '\\0';\n\n\t\t\t/* check name for invalid characters (i.e /, ., ..) */\n\t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {\n\t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n\t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n\t\t\t\tdirh.start_block, dire->offset, dire->type);\n\n\t\t\tent = malloc(sizeof(struct dir_ent));\n\t\t\tif(ent == NULL)\n\t\t\t\tMEM_ERROR();\n\n\t\t\tent->name = strdup(dire->name);\n\t\t\tent->start_block = dirh.start_block;\n\t\t\tent->offset = dire->offset;\n\t\t\tent->type = dire->type;\n\t\t\tent->next = NULL;\n\t\t\tif(cur_ent == NULL)\n\t\t\t\tdir->dirs = ent;\n\t\t\telse\n\t\t\t\tcur_ent->next = ent;\n\t\t\tcur_ent = ent;\n\t\t\tdir->dir_count ++;\n\t\t\tbytes += dire->size + 1;\n\t\t}\n\t}\n\n\treturn dir;\n\ncorrupted:\n\tsquashfs_closedir(dir);\n\treturn NULL;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "None",
        "method_name": "fixed_function",
        "raw_code": "static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,\n\tstruct inode **i)\n{\n\tstruct squashfs_dir_header dirh;\n\tchar buffer[sizeof(struct squashfs_dir_entry) + SQUASHFS_NAME_LEN + 1]\n\t\t__attribute__((aligned));\n\tstruct squashfs_dir_entry *dire = (struct squashfs_dir_entry *) buffer;\n\tlong long start;\n\tint bytes = 0, dir_count, size, res;\n\tstruct dir_ent *ent, *cur_ent = NULL;\n\tstruct dir *dir;\n\n\tTRACE(\"squashfs_opendir: inode start block %d, offset %d\\n\",\n\t\tblock_start, offset);\n\n\t*i = read_inode(block_start, offset);\n\n\tdir = malloc(sizeof(struct dir));\n\tif(dir == NULL)\n\t\tMEM_ERROR();\n\n\tdir->dir_count = 0;\n\tdir->cur_entry = NULL;\n\tdir->mode = (*i)->mode;\n\tdir->uid = (*i)->uid;\n\tdir->guid = (*i)->gid;\n\tdir->mtime = (*i)->time;\n\tdir->xattr = (*i)->xattr;\n\tdir->dirs = NULL;\n\n\tif ((*i)->data == 3)\n\t\t/*\n\t\t * if the directory is empty, skip the unnecessary\n\t\t * lookup_entry, this fixes the corner case with\n\t\t * completely empty filesystems where lookup_entry correctly\n\t\t * returning -1 is incorrectly treated as an error\n\t\t */\n\t\treturn dir;\n\n\tstart = sBlk.s.directory_table_start + (*i)->start;\n\toffset = (*i)->offset;\n\tsize = (*i)->data + bytes - 3;\n\n\twhile(bytes < size) {\t\t\t\n\t\tres = read_directory_data(&dirh, &start, &offset, sizeof(dirh));\n\t\tif(res == FALSE)\n\t\t\tgoto corrupted;\n\n\t\tSQUASHFS_INSWAP_DIR_HEADER(&dirh);\n\t\n\t\tdir_count = dirh.count + 1;\n\t\tTRACE(\"squashfs_opendir: Read directory header @ byte position \"\n\t\t\t\"%d, %d directory entries\\n\", bytes, dir_count);\n\t\tbytes += sizeof(dirh);\n\n\t\t/* dir_count should never be larger than SQUASHFS_DIR_COUNT */\n\t\tif(dir_count > SQUASHFS_DIR_COUNT) {\n\t\t\tERROR(\"File system corrupted: too many entries in directory\\n\");\n\t\t\tgoto corrupted;\n\t\t}\n\n\t\twhile(dir_count--) {\n\t\t\tres = read_directory_data(dire, &start, &offset, sizeof(*dire));\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tSQUASHFS_INSWAP_DIR_ENTRY(dire);\n\n\t\t\tbytes += sizeof(*dire);\n\n\t\t\t/* size should never be SQUASHFS_NAME_LEN or larger */\n\t\t\tif(dire->size >= SQUASHFS_NAME_LEN) {\n\t\t\t\tERROR(\"File system corrupted: filename too long\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tres = read_directory_data(dire->name, &start, &offset,\n\t\t\t\t\t\t\t\tdire->size + 1);\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tdire->name[dire->size + 1] = '\\0';\n\n\t\t\t/* check name for invalid characters (i.e /, ., ..) */\n\t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {\n\t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n\t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n\t\t\t\tdirh.start_block, dire->offset, dire->type);\n\n\t\t\tent = malloc(sizeof(struct dir_ent));\n\t\t\tif(ent == NULL)\n\t\t\t\tMEM_ERROR();\n\n\t\t\tent->name = strdup(dire->name);\n\t\t\tent->start_block = dirh.start_block;\n\t\t\tent->offset = dire->offset;\n\t\t\tent->type = dire->type;\n\t\t\tent->next = NULL;\n\t\t\tif(cur_ent == NULL)\n\t\t\t\tdir->dirs = ent;\n\t\t\telse\n\t\t\t\tcur_ent->next = ent;\n\t\t\tcur_ent = ent;\n\t\t\tdir->dir_count ++;\n\t\t\tbytes += dire->size + 1;\n\t\t}\n\t}\n\n\t/* check directory for duplicate names and sorting */\n\tif(check_directory(dir) == FALSE) {\n\t\tERROR(\"File system corrupted: directory has duplicate names or is unsorted\\n\");\n\t\tgoto corrupted;\n\t}\n\n\treturn dir;\n\ncorrupted:\n\tsquashfs_closedir(dir);\n\treturn NULL;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"unsquashfs.h\"\n#include \"compressor.h\"\n#include \"squashfs_compat.h\"\n\n// Type Definitions:\n// dir:\nstruct dir {\n\tint\t\tdir_count;\n\tunsigned int\tmode;\n\tuid_t\t\tuid;\n\tgid_t\t\tguid;\n\tunsigned int\tmtime;\n\tunsigned int\txattr;\n\tstruct dir_ent\t*dirs;\n\tstruct dir_ent\t*cur_entry;\n}\n\n// dir:\nstruct dir\n\n// inode:\nstatic struct inode\n\n// squashfs_dir_header_2:\nstruct squashfs_dir_header_2 {\n\tunsigned int\t\tcount:8;\n\tunsigned int\t\tstart_block:24;\n} __attribute__ ((packed))\n\n// dir_ent:\nstatic struct dir_ent\n\n// squashfs_dir_entry_2:\nstruct squashfs_dir_entry_2 {\n\tunsigned int\t\toffset:13;\n\tunsigned int\t\ttype:3;\n\tunsigned int\t\tsize:8;\n\tchar\t\t\tname[0];\n} __attribute__ ((packed))\n\n// Called Methods (top 10):\n// MEM_ERROR from squashfs-tools/unsquashfs_error.h:\n\n\n// SQUASHFS_CHRDEV_TYPE from squashfs-tools/squashfs_fs.h:\n\n\n// read_inode from squashfs-tools/unsquash-1.c:\nstatic struct inode *read_inode(unsigned int start_block, unsigned int offset)\n{\n\tstatic union squashfs_inode_header_1 header;\n\tlong long start = sBlk.s.inode_table_start + start_block;\n\tlong long st = start;\n\tunsigned int off = offset;\n\tstatic struct inode i;\n\tint res;\n\n\tTRACE(\"read_inode: reading inode [%d:%d]\\n\", start_block,  offset);\n\n\tif(swap) {\n\t\tsquashfs_base_inode_header_1 sinode;\n\t\tres = read_inode_data(&sinode, &st, &off, sizeof(sinode));\n\t\tif(res)\n\t\t\tSQUASHFS_SWAP_BASE_INODE_HEADER_1(&header.base, &sinode,\n\t\t\t\tsizeof(squashfs_base_inode_header_1));\n\t} else\n\t\tres = read_inode_data(&header.base, &st, &off, sizeof(header.base));\n\n\tif(res == FALSE)\n\t\tEXIT_UNSQUASH(\"read_inode: failed to read inode %lld:%d\\n\", st, off);\n\n\ti.uid = (uid_t) uid_table[(header.base.inode_type - 1) /\n\t\tSQUASHFS_TYPES * 16 + header.base.uid];\n\tif(header.base.inode_type == SQUASHFS_IPC_TYPE) {\n\t\tsquashfs_ipc_inode_header_1 *inodep = &header.ipc;\n\n\t\tif(swap) {\n\t\t\tsquashfs_ipc_inode_header_1 sinodep;\n\t...\n\n// FALSE from squashfs-tools/progressbar.c:\n\n\n// SQUASHFS_DIR_TYPE from squashfs-tools/squashfs_fs.h:\n\n\n// read_metadata from squashfs-tools/unsquashfs.c:\n\n\n// SQUASHFS_INVALID_XATTR from squashfs-tools/squashfs_fs.h:\n\n\n// SQUASHFS_NAME_LEN from squashfs-tools/squashfs_fs.h:\n<empty>\n\n// SQUASHFS_TYPES from squashfs-tools/squashfs_compat.h:\n\n\n// TRUE from squashfs-tools/unsquashfs.h:\n\n"
  },
  {
    "repository": "tensorflow",
    "cve_id": "CVE-2022-21731",
    "cwe_list": [
      "CWE-843"
    ],
    "commit_hash": "08d7b00c0a5a20926363849f611729f53f3ec022",
    "short_hash": "08d7b00c",
    "vulnerableMethods_before": [
      {
        "filename": "common_shape_fns.cc",
        "method_name": "vulnerable_function",
        "raw_code": "Status ConcatShapeHelper(InferenceContext* c, int start_value_index,\n                         int end_value_index, int dim_index) {\n  ShapeHandle unused;\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(dim_index), 0, &unused));\n  const Tensor* concat_dim_t = c->input_tensor(dim_index);\n  if (concat_dim_t == nullptr) {\n    // Return an unknown shape with same rank as inputs, or an unknown rank\n    // if no input's rank is known.\n\n    // Find rank.\n    int32_t rank = InferenceContext::kUnknownRank;\n    for (int i = start_value_index; i < end_value_index; ++i) {\n      if (rank == InferenceContext::kUnknownRank) rank = c->Rank(c->input(i));\n      if (rank != InferenceContext::kUnknownRank) {\n        break;\n      }\n    }\n    if (rank == InferenceContext::kUnknownRank) {\n      c->set_output(0, c->UnknownShape());\n      return Status::OK();\n    } else if (rank == 0) {\n      return errors::InvalidArgument(\n          \"Can't concatenate scalars (use tf.stack instead)\");\n    } else {\n      for (int i = start_value_index; i < end_value_index; ++i) {\n        // Check that all the inputs are of the correct rank.\n        TF_RETURN_IF_ERROR(c->WithRank(c->input(i), rank, &unused));\n      }\n    }\n    // Build result of <rank> different unknown dims.\n    std::vector<DimensionHandle> dims;\n    dims.reserve(rank);\n    for (int i = 0; i < rank; ++i) dims.push_back(c->UnknownDim());\n    c->set_output(0, c->MakeShape(dims));\n    return Status::OK();\n  }\n\n  // Merge all the non-concat dims, and sum the concat dim to make an output\n  // shape.\n  int64_t concat_dim;\n  if (concat_dim_t->dtype() == DT_INT32) {\n    concat_dim = static_cast<int64_t>(concat_dim_t->flat<int32>()(0));\n  } else {\n    concat_dim = concat_dim_t->flat<int64_t>()(0);\n  }\n\n  // Minimum required number of dimensions.\n  const int min_rank = concat_dim < 0 ? -concat_dim : concat_dim + 1;\n\n  ShapeHandle output_before;\n  ShapeHandle output_after;\n\n  ShapeHandle input = c->input(end_value_index - 1);\n  TF_RETURN_IF_ERROR(c->WithRankAtLeast(input, min_rank, &input));\n  TF_RETURN_IF_ERROR(c->Subshape(input, 0, concat_dim, &output_before));\n  DimensionHandle output_middle = c->Dim(input, concat_dim);\n  if (concat_dim == -1) {\n    output_after = c->Scalar();  // no dimensions.\n  } else {\n    TF_RETURN_IF_ERROR(c->Subshape(input, concat_dim + 1, &output_after));\n  }\n\n  for (int i = end_value_index - 2; i >= start_value_index; --i) {\n    ShapeHandle before;\n    ShapeHandle after;\n    input = c->input(i);\n    TF_RETURN_IF_ERROR(c->WithRankAtLeast(input, min_rank, &input));\n    TF_RETURN_IF_ERROR(c->Subshape(input, 0, concat_dim, &before));\n    DimensionHandle middle = c->Dim(input, concat_dim);\n    if (concat_dim == -1) {\n      after = c->Scalar();\n    } else {\n      TF_RETURN_IF_ERROR(c->Subshape(input, concat_dim + 1, &after));\n    }\n\n    TF_RETURN_IF_ERROR(c->Merge(before, output_before, &output_before));\n    TF_RETURN_IF_ERROR(c->Add(output_middle, middle, &output_middle));\n    TF_RETURN_IF_ERROR(c->Merge(after, output_after, &output_after));\n  }\n\n  ShapeHandle s;\n  TF_RETURN_IF_ERROR(\n      c->Concatenate(output_before, c->Vector(output_middle), &s));\n  TF_RETURN_IF_ERROR(c->Concatenate(s, output_after, &s));\n  c->set_output(0, s);\n  return Status::OK();\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "common_shape_fns.cc",
        "method_name": "fixed_function",
        "raw_code": "Status ConcatShapeHelper(InferenceContext* c, int start_value_index,\n                         int end_value_index, int dim_index) {\n  ShapeHandle unused;\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(dim_index), 0, &unused));\n  const Tensor* concat_dim_t = c->input_tensor(dim_index);\n  if (concat_dim_t == nullptr) {\n    // Return an unknown shape with same rank as inputs, or an unknown rank\n    // if no input's rank is known.\n\n    // Find rank.\n    int32_t rank = InferenceContext::kUnknownRank;\n    for (int i = start_value_index; i < end_value_index; ++i) {\n      if (rank == InferenceContext::kUnknownRank) rank = c->Rank(c->input(i));\n      if (rank != InferenceContext::kUnknownRank) {\n        break;\n      }\n    }\n    if (rank == InferenceContext::kUnknownRank) {\n      c->set_output(0, c->UnknownShape());\n      return Status::OK();\n    } else if (rank == 0) {\n      return errors::InvalidArgument(\n          \"Can't concatenate scalars (use tf.stack instead)\");\n    } else {\n      for (int i = start_value_index; i < end_value_index; ++i) {\n        // Check that all the inputs are of the correct rank.\n        TF_RETURN_IF_ERROR(c->WithRank(c->input(i), rank, &unused));\n      }\n    }\n    // Build result of <rank> different unknown dims.\n    std::vector<DimensionHandle> dims;\n    dims.reserve(rank);\n    for (int i = 0; i < rank; ++i) dims.push_back(c->UnknownDim());\n    c->set_output(0, c->MakeShape(dims));\n    return Status::OK();\n  }\n\n  // Merge all the non-concat dims, and sum the concat dim to make an output\n  // shape.\n  int64_t concat_dim;\n  if (concat_dim_t->dtype() == DT_INT32) {\n    concat_dim = static_cast<int64_t>(concat_dim_t->flat<int32>()(0));\n  } else {\n    concat_dim = concat_dim_t->flat<int64_t>()(0);\n  }\n\n  // Minimum required number of dimensions.\n  const int64 min_rank = concat_dim < 0 ? -concat_dim : concat_dim + 1;\n\n  ShapeHandle output_before;\n  ShapeHandle output_after;\n\n  ShapeHandle input = c->input(end_value_index - 1);\n  TF_RETURN_IF_ERROR(c->WithRankAtLeast(input, min_rank, &input));\n  TF_RETURN_IF_ERROR(c->Subshape(input, 0, concat_dim, &output_before));\n  DimensionHandle output_middle = c->Dim(input, concat_dim);\n  if (concat_dim == -1) {\n    output_after = c->Scalar();  // no dimensions.\n  } else {\n    TF_RETURN_IF_ERROR(c->Subshape(input, concat_dim + 1, &output_after));\n  }\n\n  for (int i = end_value_index - 2; i >= start_value_index; --i) {\n    ShapeHandle before;\n    ShapeHandle after;\n    input = c->input(i);\n    TF_RETURN_IF_ERROR(c->WithRankAtLeast(input, min_rank, &input));\n    TF_RETURN_IF_ERROR(c->Subshape(input, 0, concat_dim, &before));\n    DimensionHandle middle = c->Dim(input, concat_dim);\n    if (concat_dim == -1) {\n      after = c->Scalar();\n    } else {\n      TF_RETURN_IF_ERROR(c->Subshape(input, concat_dim + 1, &after));\n    }\n\n    TF_RETURN_IF_ERROR(c->Merge(before, output_before, &output_before));\n    TF_RETURN_IF_ERROR(c->Add(output_middle, middle, &output_middle));\n    TF_RETURN_IF_ERROR(c->Merge(after, output_after, &output_after));\n  }\n\n  ShapeHandle s;\n  TF_RETURN_IF_ERROR(\n      c->Concatenate(output_before, c->Vector(output_middle), &s));\n  TF_RETURN_IF_ERROR(c->Concatenate(s, output_after, &s));\n  c->set_output(0, s);\n  return Status::OK();\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"absl/container/flat_hash_map.h\"\n#include \"absl/container/flat_hash_set.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"absl/strings/str_split.h\"\n#include \"absl/strings/match.h\"\n#include \"tensorflow/core/framework/common_shape_fns.h\"\n#include \"tensorflow/core/lib/gtl/inlined_vector.h\"\n#include \"tensorflow/core/framework/shape_inference.h\"\n#include \"tensorflow/core/util/einsum_op_util.h\"\n#include \"absl/strings/string_view.h\"\n#include \"tensorflow/core/framework/attr_value.pb.h\"\n\n// Type Definitions:\n// InferenceContext:\nInferenceContext.InferenceContext:ANY(int,AttrSlice&,OpDef&,std.vector&,std.vector&,std.vector&,std.vector&)\n\n// int64:\ntypedef ::std::int64_t int64;\n\n// Tensor:\ntensorflow.TensorHandle.Tensor:tensorflow.Status(tensorflow.Tensor**)<const>\n\n// Status:\nclass Status\n\n// Status:\nclass Status {\n public:\n  /// Create a success status.\n  Status() {}\n\n  /// \\brief Create a status with the specified error code and msg as a\n  /// human-readable string containing more detailed information.\n  Status(tensorflow::error::Code code, tensorflow::StringPiece msg)\n      : Status(code, msg, {}) {}\n\n  /// \\brief Create a status with the specified error code, msg, and stack trace\n  /// as a human-readable string containing more detailed information.\n#ifndef SWIG\n  Status(tensorflow::error::Code code, tensorflow::StringPiece msg,\n         std::vector<StackFrame>&& stack_trace);\n#endif\n\n  /// Copy the specified status.\n  Status(const Status& s);\n  Status& operator=(const Status& s);\n#ifndef SWIG\n  Status(Status&& s) noexcept;\n  Status& operator=(Status&& s) noexcept;\n#endif  // SWIG\n\n  static Status OK() { return Status(); }\n\n  /// Returns true iff the status indicates success.\n  bool ok() const { return (state_ == nullptr); }\n\n  tensorflow::error::Code code() const {\n    retu...\n\n// Called Methods (top 10):\n// TF_RETURN_IF_ERROR from tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/common_runtime/eager/tensorflow/core/framework/tensorflow/core/platform/errors.h:\n\n\n// OK from tensorflow/core/platform/status.h:\n  static Status OK() { return Status(); } /* <=== tensorflow.Status.OK:tensorflow.Status() */ \n\n// ok from tensorflow/core/platform/status.h:\n  bool ok() const { return (state_ == nullptr); } /* <=== tensorflow.Status.ok:bool()<const> */ \n"
  },
  {
    "repository": "glewlwyd",
    "cve_id": "CVE-2021-45379",
    "cwe_list": [
      "CWE-287"
    ],
    "commit_hash": "125281f1c0d4b6a8b49f7e55a757205a2ef01fbe",
    "short_hash": "125281f1",
    "vulnerableMethods_before": [
      {
        "filename": "webservice.c",
        "method_name": "vulnerable_function",
        "raw_code": "int callback_glewlwyd_user_auth (const struct _u_request * request, struct _u_response * response, void * user_data) {\n  struct config_elements * config = (struct config_elements *)user_data;\n  json_t * j_param = ulfius_get_json_body_request(request, NULL), * j_result = NULL;\n  const char * ip_source = get_ip_source(request);\n  char * issued_for = get_client_hostname(request);\n  char * session_uid, expires[129];\n  time_t now;\n  struct tm ts;\n  \n  time(&now);\n  now += GLEWLWYD_DEFAULT_SESSION_EXPIRATION_COOKIE;\n  gmtime_r(&now, &ts);\n  strftime(expires, 128, \"%a, %d %b %Y %T %Z\", &ts);\n  if (j_param != NULL) {\n    if (json_string_length(json_object_get(j_param, \"username\"))) {\n      if (json_object_get(j_param, \"scheme_type\") == NULL || 0 == o_strcmp(json_string_value(json_object_get(j_param, \"scheme_type\")), \"password\")) {\n        if (json_string_length(json_object_get(j_param, \"password\"))) {\n          j_result = auth_check_user_credentials(config, json_string_value(json_object_get(j_param, \"username\")), json_string_value(json_object_get(j_param, \"password\")));\n          if (check_result_value(j_result, G_OK)) {\n            if ((session_uid = get_session_id(config, request)) == NULL) {\n              session_uid = generate_session_id();\n            }\n            if (user_session_update(config, session_uid, u_map_get_case(request->map_header, \"user-agent\"), issued_for, json_string_value(json_object_get(j_param, \"username\")), NULL, 1) != G_OK) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error user_session_update (1)\");\n              response->status = 500;\n            } else {\n              ulfius_add_cookie_to_response(response, config->session_key, session_uid, expires, 0, config->cookie_domain, \"/\", config->cookie_secure, 0);\n              y_log_message(Y_LOG_LEVEL_INFO, \"Event - User '%s' authenticated with password\", json_string_value(json_object_get(j_param, \"username\")));\n            }\n            o_free(session_uid);\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_VALID, 1, NULL);\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_VALID_SCHEME, 1, \"scheme_type\", \"password\", NULL);\n          } else {\n            if (check_result_value(j_result, G_ERROR_UNAUTHORIZED)) {\n              y_log_message(Y_LOG_LEVEL_WARNING, \"Security - Authorization invalid for username %s at IP Address %s\", json_string_value(json_object_get(j_param, \"username\")), ip_source);\n            }\n            if ((session_uid = get_session_id(config, request)) != NULL && user_session_update(config, session_uid, u_map_get_case(request->map_header, \"user-agent\"), issued_for, json_string_value(json_object_get(j_param, \"username\")), NULL, 1) != G_OK) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error user_session_update (2)\");\n            }\n            o_free(session_uid);\n            response->status = 401;\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_INVALID, 1, NULL);\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_INVALID_SCHEME, 1, \"scheme_type\", \"password\", NULL);\n          }\n          json_decref(j_result);\n        } else if (json_object_get(j_param, \"password\") != NULL && !json_is_string(json_object_get(j_param, \"password\"))) {\n          ulfius_set_string_body_response(response, 400, \"password must be a string\");\n        } else {\n          session_uid = get_session_id(config, request);\n          j_result = get_users_for_session(config, session_uid);\n          if (check_result_value(j_result, G_OK)) {\n            // Refresh username to set as default\n            if (user_session_update(config, u_map_get(request->map_cookie, config->session_key), u_map_get_case(request->map_header, \"user-agent\"), issued_for, json_string_value(json_object_get(j_param, \"username\")), NULL, 0) != G_OK) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error user_session_update (3)\");\n              response->status = 500;\n            } else {\n              ulfius_add_cookie_to_response(response, config->session_key, session_uid, expires, 0, config->cookie_domain, \"/\", config->cookie_secure, 0);\n            }\n          } else if (check_result_value(j_result, G_ERROR_NOT_FOUND)) {\n            response->status = 401;\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error get_users_for_session\");\n            response->status = 500;\n          }\n          o_free(session_uid);\n          json_decref(j_result);\n        }\n      } else {\n        if (json_string_length(json_object_get(j_param, \"scheme_type\")) && json_string_length(json_object_get(j_param, \"scheme_name\")) && json_is_object(json_object_get(j_param, \"value\"))) {\n          j_result = auth_check_user_scheme(config, json_string_value(json_object_get(j_param, \"scheme_type\")), json_string_value(json_object_get(j_param, \"scheme_name\")), json_string_value(json_object_get(j_param, \"username\")), json_object_get(j_param, \"value\"), request);\n          if (check_result_value(j_result, G_ERROR_PARAM)) {\n            ulfius_set_string_body_response(response, 400, \"bad scheme response\");\n          } else if (check_result_value(j_result, G_ERROR_UNAUTHORIZED)) {\n            y_log_message(Y_LOG_LEVEL_WARNING, \"Security - Authorization invalid for username %s at IP Address %s\", json_string_value(json_object_get(j_param, \"username\")), ip_source);\n            response->status = 401;\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_INVALID, 1, NULL);\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_INVALID_SCHEME, 1, \"scheme_type\", json_string_value(json_object_get(j_param, \"scheme_type\")), \"scheme_name\", json_string_value(json_object_get(j_param, \"scheme_name\")), NULL);\n          } else if (check_result_value(j_result, G_ERROR_NOT_FOUND)) {\n            response->status = 404;\n          } else if (check_result_value(j_result, G_OK)) {\n            if ((session_uid = get_session_id(config, request)) == NULL) {\n              session_uid = generate_session_id();\n            }\n            if (user_session_update(config, session_uid, u_map_get_case(request->map_header, \"user-agent\"), issued_for, json_string_value(json_object_get(j_param, \"username\")), json_string_value(json_object_get(j_param, \"scheme_name\")), 1) != G_OK) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error user_session_update (4)\");\n              response->status = 500;\n            } else {\n              ulfius_add_cookie_to_response(response, config->session_key, session_uid, expires, 0, config->cookie_domain, \"/\", config->cookie_secure, 0);\n              y_log_message(Y_LOG_LEVEL_INFO, \"Event - User '%s' authenticated with scheme '%s/%s'\", json_string_value(json_object_get(j_param, \"username\")), json_string_value(json_object_get(j_param, \"scheme_type\")), json_string_value(json_object_get(j_param, \"scheme_name\")));\n            }\n            o_free(session_uid);\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_VALID, 1, NULL);\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_VALID_SCHEME, 1, \"scheme_type\", json_string_value(json_object_get(j_param, \"scheme_type\")), \"scheme_name\", json_string_value(json_object_get(j_param, \"scheme_name\")), NULL);\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error auth_check_user_scheme\");\n            response->status = 500;\n          }\n          json_decref(j_result);\n        } else {\n          ulfius_set_string_body_response(response, 400, \"scheme_type, scheme_name and value are mandatory\");\n        }\n      }\n    } else {\n      if (json_string_length(json_object_get(j_param, \"scheme_type\")) && json_string_length(json_object_get(j_param, \"scheme_name\")) && json_is_object(json_object_get(j_param, \"value\"))) {\n        j_result = auth_check_identify_scheme(config, json_string_value(json_object_get(j_param, \"scheme_type\")), json_string_value(json_object_get(j_param, \"scheme_name\")), json_object_get(j_param, \"value\"), request);\n        if (check_result_value(j_result, G_ERROR_PARAM)) {\n          ulfius_set_string_body_response(response, 400, \"bad scheme response\");\n        } else if (check_result_value(j_result, G_ERROR_UNAUTHORIZED)) {\n          y_log_message(Y_LOG_LEVEL_WARNING, \"Security - Authorization invalid for username <UNKNOWN> at IP Address %s\", ip_source);\n          response->status = 401;\n        } else if (check_result_value(j_result, G_ERROR_NOT_FOUND)) {\n          response->status = 404;\n        } else if (check_result_value(j_result, G_OK)) {\n          if ((session_uid = get_session_id(config, request)) == NULL) {\n            session_uid = generate_session_id();\n          }\n          if (user_session_update(config, session_uid, u_map_get_case(request->map_header, \"user-agent\"), issued_for, json_string_value(json_object_get(j_result, \"username\")), json_string_value(json_object_get(j_param, \"scheme_name\")), 1) != G_OK) {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error user_session_update (4)\");\n            response->status = 500;\n          } else {\n            ulfius_add_cookie_to_response(response, config->session_key, session_uid, expires, 0, config->cookie_domain, \"/\", config->cookie_secure, 0);\n            y_log_message(Y_LOG_LEVEL_INFO, \"Event - User '%s' authenticated with scheme '%s/%s'\", json_string_value(json_object_get(j_result, \"username\")), json_string_value(json_object_get(j_param, \"scheme_type\")), json_string_value(json_object_get(j_param, \"scheme_name\")));\n          }\n          o_free(session_uid);\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error auth_check_user_scheme\");\n          response->status = 500;\n        }\n        json_decref(j_result);\n      } else {\n        ulfius_set_string_body_response(response, 400, \"username is mandatory\");\n      }\n    }\n  } else {\n    ulfius_set_string_body_response(response, 400, \"Input parameters must be in JSON format\");\n  }\n  json_decref(j_param);\n  o_free(issued_for);\n\n  return U_CALLBACK_CONTINUE;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "webservice.c",
        "method_name": "fixed_function",
        "raw_code": "int callback_glewlwyd_user_auth (const struct _u_request * request, struct _u_response * response, void * user_data) {\n  struct config_elements * config = (struct config_elements *)user_data;\n  json_t * j_param = ulfius_get_json_body_request(request, NULL), * j_result = NULL;\n  const char * ip_source = get_ip_source(request);\n  char * issued_for = get_client_hostname(request);\n  char * session_uid, expires[129];\n  time_t now;\n  struct tm ts;\n  \n  time(&now);\n  now += GLEWLWYD_DEFAULT_SESSION_EXPIRATION_COOKIE;\n  gmtime_r(&now, &ts);\n  strftime(expires, 128, \"%a, %d %b %Y %T %Z\", &ts);\n  if (j_param != NULL) {\n    if (json_string_length(json_object_get(j_param, \"username\"))) {\n      if (json_object_get(j_param, \"scheme_type\") == NULL || 0 == o_strcmp(json_string_value(json_object_get(j_param, \"scheme_type\")), \"password\")) {\n        if (json_string_length(json_object_get(j_param, \"password\"))) {\n          j_result = auth_check_user_credentials(config, json_string_value(json_object_get(j_param, \"username\")), json_string_value(json_object_get(j_param, \"password\")));\n          if (check_result_value(j_result, G_OK)) {\n            if ((session_uid = get_session_id(config, request)) == NULL) {\n              session_uid = generate_session_id();\n            }\n            if (user_session_update(config, session_uid, u_map_get_case(request->map_header, \"user-agent\"), issued_for, json_string_value(json_object_get(j_param, \"username\")), NULL, 1) != G_OK) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error user_session_update (1)\");\n              response->status = 500;\n            } else {\n              ulfius_add_cookie_to_response(response, config->session_key, session_uid, expires, 0, config->cookie_domain, \"/\", config->cookie_secure, 0);\n              y_log_message(Y_LOG_LEVEL_INFO, \"Event - User '%s' authenticated with password\", json_string_value(json_object_get(j_param, \"username\")));\n            }\n            o_free(session_uid);\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_VALID, 1, NULL);\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_VALID_SCHEME, 1, \"scheme_type\", \"password\", NULL);\n          } else {\n            if (check_result_value(j_result, G_ERROR_UNAUTHORIZED)) {\n              y_log_message(Y_LOG_LEVEL_WARNING, \"Security - Authorization invalid for username %s at IP Address %s\", json_string_value(json_object_get(j_param, \"username\")), ip_source);\n            }\n            response->status = 401;\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_INVALID, 1, NULL);\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_INVALID_SCHEME, 1, \"scheme_type\", \"password\", NULL);\n          }\n          json_decref(j_result);\n        } else if (json_object_get(j_param, \"password\") != NULL && !json_is_string(json_object_get(j_param, \"password\"))) {\n          ulfius_set_string_body_response(response, 400, \"password must be a string\");\n        } else {\n          session_uid = get_session_id(config, request);\n          j_result = get_users_for_session(config, session_uid);\n          if (check_result_value(j_result, G_OK)) {\n            // Refresh username to set as default\n            if (user_session_update(config, u_map_get(request->map_cookie, config->session_key), u_map_get_case(request->map_header, \"user-agent\"), issued_for, json_string_value(json_object_get(j_param, \"username\")), NULL, 0) != G_OK) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error user_session_update (3)\");\n              response->status = 500;\n            } else {\n              ulfius_add_cookie_to_response(response, config->session_key, session_uid, expires, 0, config->cookie_domain, \"/\", config->cookie_secure, 0);\n            }\n          } else if (check_result_value(j_result, G_ERROR_NOT_FOUND)) {\n            response->status = 401;\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error get_users_for_session\");\n            response->status = 500;\n          }\n          o_free(session_uid);\n          json_decref(j_result);\n        }\n      } else {\n        if (json_string_length(json_object_get(j_param, \"scheme_type\")) && json_string_length(json_object_get(j_param, \"scheme_name\")) && json_is_object(json_object_get(j_param, \"value\"))) {\n          j_result = auth_check_user_scheme(config, json_string_value(json_object_get(j_param, \"scheme_type\")), json_string_value(json_object_get(j_param, \"scheme_name\")), json_string_value(json_object_get(j_param, \"username\")), json_object_get(j_param, \"value\"), request);\n          if (check_result_value(j_result, G_ERROR_PARAM)) {\n            ulfius_set_string_body_response(response, 400, \"bad scheme response\");\n          } else if (check_result_value(j_result, G_ERROR_UNAUTHORIZED)) {\n            y_log_message(Y_LOG_LEVEL_WARNING, \"Security - Authorization invalid for username %s at IP Address %s\", json_string_value(json_object_get(j_param, \"username\")), ip_source);\n            response->status = 401;\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_INVALID, 1, NULL);\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_INVALID_SCHEME, 1, \"scheme_type\", json_string_value(json_object_get(j_param, \"scheme_type\")), \"scheme_name\", json_string_value(json_object_get(j_param, \"scheme_name\")), NULL);\n          } else if (check_result_value(j_result, G_ERROR_NOT_FOUND)) {\n            response->status = 404;\n          } else if (check_result_value(j_result, G_OK)) {\n            if ((session_uid = get_session_id(config, request)) == NULL) {\n              session_uid = generate_session_id();\n            }\n            if (user_session_update(config, session_uid, u_map_get_case(request->map_header, \"user-agent\"), issued_for, json_string_value(json_object_get(j_param, \"username\")), json_string_value(json_object_get(j_param, \"scheme_name\")), 1) != G_OK) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error user_session_update (4)\");\n              response->status = 500;\n            } else {\n              ulfius_add_cookie_to_response(response, config->session_key, session_uid, expires, 0, config->cookie_domain, \"/\", config->cookie_secure, 0);\n              y_log_message(Y_LOG_LEVEL_INFO, \"Event - User '%s' authenticated with scheme '%s/%s'\", json_string_value(json_object_get(j_param, \"username\")), json_string_value(json_object_get(j_param, \"scheme_type\")), json_string_value(json_object_get(j_param, \"scheme_name\")));\n            }\n            o_free(session_uid);\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_VALID, 1, NULL);\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_VALID_SCHEME, 1, \"scheme_type\", json_string_value(json_object_get(j_param, \"scheme_type\")), \"scheme_name\", json_string_value(json_object_get(j_param, \"scheme_name\")), NULL);\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error auth_check_user_scheme\");\n            response->status = 500;\n          }\n          json_decref(j_result);\n        } else {\n          ulfius_set_string_body_response(response, 400, \"scheme_type, scheme_name and value are mandatory\");\n        }\n      }\n    } else {\n      if (json_string_length(json_object_get(j_param, \"scheme_type\")) && json_string_length(json_object_get(j_param, \"scheme_name\")) && json_is_object(json_object_get(j_param, \"value\"))) {\n        j_result = auth_check_identify_scheme(config, json_string_value(json_object_get(j_param, \"scheme_type\")), json_string_value(json_object_get(j_param, \"scheme_name\")), json_object_get(j_param, \"value\"), request);\n        if (check_result_value(j_result, G_ERROR_PARAM)) {\n          ulfius_set_string_body_response(response, 400, \"bad scheme response\");\n        } else if (check_result_value(j_result, G_ERROR_UNAUTHORIZED)) {\n          y_log_message(Y_LOG_LEVEL_WARNING, \"Security - Authorization invalid for username <UNKNOWN> at IP Address %s\", ip_source);\n          response->status = 401;\n        } else if (check_result_value(j_result, G_ERROR_NOT_FOUND)) {\n          response->status = 404;\n        } else if (check_result_value(j_result, G_OK)) {\n          if ((session_uid = get_session_id(config, request)) == NULL) {\n            session_uid = generate_session_id();\n          }\n          if (user_session_update(config, session_uid, u_map_get_case(request->map_header, \"user-agent\"), issued_for, json_string_value(json_object_get(j_result, \"username\")), json_string_value(json_object_get(j_param, \"scheme_name\")), 1) != G_OK) {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error user_session_update (4)\");\n            response->status = 500;\n          } else {\n            ulfius_add_cookie_to_response(response, config->session_key, session_uid, expires, 0, config->cookie_domain, \"/\", config->cookie_secure, 0);\n            y_log_message(Y_LOG_LEVEL_INFO, \"Event - User '%s' authenticated with scheme '%s/%s'\", json_string_value(json_object_get(j_result, \"username\")), json_string_value(json_object_get(j_param, \"scheme_type\")), json_string_value(json_object_get(j_param, \"scheme_name\")));\n          }\n          o_free(session_uid);\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error auth_check_user_scheme\");\n          response->status = 500;\n        }\n        json_decref(j_result);\n      } else {\n        ulfius_set_string_body_response(response, 400, \"username is mandatory\");\n      }\n    }\n  } else {\n    ulfius_set_string_body_response(response, 400, \"Input parameters must be in JSON format\");\n  }\n  json_decref(j_param);\n  o_free(issued_for);\n\n  return U_CALLBACK_CONTINUE;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"glewlwyd.h\"\n#include <string.h>\n\n// Type Definitions:\n// config_elements:\nstruct config_elements\n\n// config_elements:\nstruct config_elements {\n  char *                                         config_file;\n  unsigned int                                   port;\n  char *                                         bind_address;\n  char *                                         bind_address_metrics;\n  char *                                         external_url;\n  char *                                         api_prefix;\n  char *                                         cookie_domain;\n  unsigned int                                   cookie_secure;\n  unsigned short                                 log_mode_args;\n  unsigned short                                 log_level_args;\n  unsigned long                                  log_mode;\n  unsigned long                                  log_level;\n  char *                                         log_file;\n  struct _u_compressed_inmemory_website_config * static_file_config;\n  char *                                         admin_scope;\n  char *                       ...\n\n// Called Methods (top 10):\n// glewlwyd_metrics_build_label from src/metrics.c:\nchar * glewlwyd_metrics_build_label(va_list vl_label) { /* <=== glewlwyd_metrics_build_label */ \n  const char * label_arg;\n  char * label = NULL;\n  int flag = 0;\n\n  for (label_arg = va_arg(vl_label, const char *); label_arg != NULL; label_arg = va_arg(vl_label, const char *)) {\n    if (!flag) {\n      if (label == NULL) {\n        label = msprintf(\"%s=\", label_arg);\n      } else {\n        label = mstrcatf(label, \", %s=\", label_arg);\n      }\n    } else {\n      label = mstrcatf(label, \"\\\"%s\\\"\", label_arg);\n    }\n    flag = !flag;\n  }\n  return label;\n}\n\n// check_result_value from docs/resources/ulfius/glewlwyd_resource.c:\nstatic int check_result_value(json_t * result, const int value) { /* <=== check_result_value */ \n  return (result != NULL && \n          json_is_object(result) && \n          json_object_get(result, \"result\") != NULL && \n          json_is_integer(json_object_get(result, \"result\")) && \n          json_integer_value(json_object_get(result, \"result\")) == value);\n}\n\n// auth_check_user_credentials from src/user.c:\njson_t * auth_check_user_credentials(struct config_elements * config, const char * username, const char * password) { /* <=== auth_check_user_credentials */ \n  int res;\n  json_t * j_return = NULL, * j_module_list = get_user_module_list(config), * j_module, * j_user;\n  struct _user_module_instance * user_module;\n  size_t index;\n  \n  if (check_result_value(j_module_list, G_OK)) {\n    json_array_foreach(json_object_get(j_module_list, \"module\"), index, j_module) {\n      if (j_return == NULL) {\n        user_module = get_user_module_instance(config, json_string_value(json_object_get(j_module, \"name\")));\n        if (user_module != NULL) {\n          if (user_module->enabled) {\n            j_user = user_module->module->user_module_get(config->config_m, username, user_module->cls);\n            if (check_result_value(j_user, G_OK) && json_object_get(json_object_get(j_user, \"user\"), \"enabled\") == json_true()) {\n              res = user_module->module->user_module_check_password(config->config_m, username, password, user_module->cls);\n              if (res == G_OK) {\n                j_return = json_pack(\"{si}\", \"result\", G_OK);\n              } else if (res == G_ERROR_UNAUTHORIZED) {\n                j_return = json_pack(\"{si}\", \"result\", G_ERROR_UNAUTHORIZED);\n              } else if (res != G_ERROR_NOT_FOUND) {\n                y_log_message(Y_LOG_LEVEL_ERROR, \"auth_check_user_credentials - Error, user_module_check_password for module '%s', skip\", user_module->name);\n              }\n            } else if (!check_result_value(j_user, G_ERROR_NOT_FOUND)) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"auth_check_user_credentials - Error, user_module_get for module '%s', skip\", user_module->name);\n            }\n            json_decref(j_user);\n          }\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"auth_check_user_credentials - Error, user_module_instance %s is NULL\", json_string_value(json_object_get(j_module, \"name\")));\n        }\n      }\n    }\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"auth_check_user_credentials - Error get_user_module_list\");\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n  }\n  if (j_return == NULL) {\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR_UNAUTHORIZED);\n  }\n  json_decref(j_module_list);\n  return j_return;\n}\n\n// generate_digest from src/misc.c:\nint generate_digest(digest_algorithm digest, const char * data, int use_salt, char * out_digest) { /* <=== generate_digest */ \n  unsigned int res = 0;\n  int alg, dig_res;\n  gnutls_datum_t key_data;\n  char * intermediate = NULL, salt[GLEWLWYD_DEFAULT_SALT_LENGTH + 1] = {0};\n  unsigned char encoded_key[128 + GLEWLWYD_DEFAULT_SALT_LENGTH + 1] = {0};\n  size_t encoded_key_size = (128 + GLEWLWYD_DEFAULT_SALT_LENGTH), encoded_key_size_base64;\n\n  if (data != NULL && out_digest != NULL) {\n    switch (digest) {\n      case digest_SHA1:\n        alg = GNUTLS_DIG_SHA1;\n        break;\n      case digest_SHA224:\n        alg = GNUTLS_DIG_SHA224;\n        break;\n      case digest_SHA256:\n        alg = GNUTLS_DIG_SHA256;\n        break;\n      case digest_SHA384:\n        alg = GNUTLS_DIG_SHA384;\n        break;\n      case digest_SHA512:\n        alg = GNUTLS_DIG_SHA512;\n        break;\n      case digest_MD5:\n        alg = GNUTLS_DIG_MD5;\n        break;\n      default:\n        alg = GNUTLS_DIG_UNKNOWN;\n        break;\n    }\n    \n    if(alg != GNUTLS_DIG_UNKNOWN) {\n      if (o_strlen(data) > 0) {\n        if (use_salt) {\n          rand_string_nonce(salt, GLEWLWYD_DEFAULT_SALT_LENGTH);\n          intermediate = msprintf(\"%s%s\", data, salt);\n        } else {\n          intermediate = o_strdup(data);\n        }\n        key_data.data = (unsigned char*)intermediate;\n        key_data.size = o_strlen(intermediate);\n        if (key_data.data != NULL && (dig_res = gnutls_fingerprint(alg, &key_data, encoded_key, &encoded_key_size)) == GNUTLS_E_SUCCESS) {\n          if (use_salt) {\n            memcpy(encoded_key+encoded_key_size, salt, GLEWLWYD_DEFAULT_SALT_LENGTH);\n            encoded_key_size += GLEWLWYD_DEFAULT_SALT_LENGTH;\n          }\n          if (o_base64_encode(encoded_key, encoded_key_size, (unsigned char *)out_digest, &encoded_key_size_base64)) {\n            res = 1;\n          } else{\n            res = 0;\n          }\n        } else {\n          res = 0;\n        }\n        o_free(intermediate);\n      } else {\n        // No data, then out_digest becomes an empty string\n        out_digest[0] = '\\0';\n        res = 1;\n      }\n    } else {\n      res = 0;\n    }\n  } else {\n    res = 0;\n  }\n  return res;\n}\n\n// get_user_module_instance from src/glewlwyd.c:\nstruct _user_module_instance * get_user_module_instance(struct config_elements * config, const char * name) { /* <=== get_user_module_instance */ \n  size_t i;\n  struct _user_module_instance * cur_instance;\n\n  for (i=0; i<pointer_list_size(config->user_module_instance_list); i++) {\n    cur_instance = (struct _user_module_instance *)pointer_list_get_at(config->user_module_instance_list, i);\n    if (cur_instance != NULL && 0 == o_strcmp(cur_instance->name, name)) {\n      return cur_instance;\n    }\n  }\n  return NULL;\n}\n\n// get_session_for_username from src/session.c:\njson_t * get_session_for_username(struct config_elements * config, const char * session_uid, const char * username) { /* <=== get_session_for_username */ \n  json_t * j_query, * j_result, * j_return, * j_session_scheme;\n  int res;\n  char * expire_clause;\n  char * session_uid_hash = generate_hash(config->hash_algorithm, session_uid);\n\n  if (config->conn->type==HOEL_DB_TYPE_MARIADB) {\n    expire_clause = o_strdup(\"> NOW()\");\n  } else if (config->conn->type==HOEL_DB_TYPE_PGSQL) {\n    expire_clause = o_strdup(\"> NOW()\");\n  } else { // HOEL_DB_TYPE_SQLITE\n    expire_clause = o_strdup(\"> (strftime('%s','now'))\");\n  }\n  if (session_uid_hash != NULL) {\n    j_query = json_pack(\"{sss[ss]s{sssssis{ssss}}}\",\n                        \"table\",\n                        GLEWLWYD_TABLE_USER_SESSION,\n                        \"columns\",\n                          \"gus_id\",\n                          SWITCH_DB_TYPE(config->conn->type, \"UNIX_TIMESTAMP(gus_expiration) AS expiration\", \"gus_expiration AS expiration\", \"EXTRACT(EPOCH FROM gus_expiration)::integer AS expiration\"),\n                        \"where\",\n                          \"gus_session_hash\",\n                          session_uid_hash,\n                          \"gus_username\",\n                          username,\n                          \"gus_enabled\",\n                          1,\n                          \"gus_expiration\",\n                            \"operator\",\n                            \"raw\",\n                            \"value\",\n                            expire_clause);\n    o_free(expire_clause);\n    res = h_select(config->conn, j_query, &j_result, NULL);\n    json_decref(j_query);\n    if (res == H_OK) {\n      if (json_array_size(j_result) > 0) {\n        j_session_scheme = get_session_scheme(config, json_integer_value(json_object_get(json_array_get(j_result, 0), \"gus_id\")));\n        if (check_result_value(j_session_scheme, G_OK)) {\n          j_return = json_pack(\"{sis{sssOsOsI}}\", \n                                \"result\", \n                                G_OK, \n                                \"session\", \n                                  \"username\", \n                                  username, \n                                  \"expiration\", \n                                  json_object_get(json_array_get(j_result, 0), \"expiration\"),\n                                  \"scheme\",\n                                  json_object_get(j_session_scheme, \"scheme\"),\n                                  \"gus_id\",\n                                  json_integer_value(json_object_get(json_array_get(j_result, 0), \"gus_id\")));\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"get_session_for_username - Error get_session_scheme\");\n          j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n        }\n        json_decref(j_session_scheme);\n      } else {\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR_NOT_FOUND);\n      }\n      json_decref(j_result);\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"get_session_for_username - Error executing j_query\");\n      glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_DATABSE_ERROR, 1, NULL);\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR_DB);\n    }\n    o_free(session_uid_hash);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"get_session_for_username - Error generate_hash\");\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n  }\n  return j_return;\n}\n\n// G_ERROR_DB from src/glewlwyd-common.h:\n#define G_ERROR_DB           4 /* <=== src/glewlwyd-common.h:57:57:G_ERROR_DB:0 */ \n\n// get_client_hostname from src/misc.c:\nchar * get_client_hostname(const struct _u_request * request) { /* <=== get_client_hostname */ \n  const char * ip_source = get_ip_source(request);\n  struct addrinfo hints;\n  struct addrinfo * lookup = NULL;\n  char * hostname = NULL;\n  \n  memset(&hints, 0, sizeof(struct addrinfo));\n  hints.ai_family = AF_UNSPEC;\n  hints.ai_flags = AI_CANONNAME;\n  hints.ai_canonname = NULL;\n  if (ip_source != NULL) {\n    hostname = o_strdup(ip_source);\n    if (!getaddrinfo(ip_source, NULL, &hints, &lookup)) {\n      if (o_strlen(lookup->ai_canonname)) {\n        hostname = mstrcatf(hostname, \" - %s\", lookup->ai_canonname);\n      }\n      freeaddrinfo(lookup);\n      lookup = NULL;\n    }\n  }\n  \n  return hostname;\n}\n\n// GLWD_METRICS_DATABSE_ERROR from src/glewlwyd-common.h:\n#define GLWD_METRICS_DATABSE_ERROR            \"glewlwyd_database_error\" /* <=== src/glewlwyd-common.h:312:312:GLWD_METRICS_DATABSE_ERROR:0 */ \n\n// GLEWLWYD_TABLE_USER_MODULE_INSTANCE from src/glewlwyd.h:\n#define GLEWLWYD_TABLE_USER_MODULE_INSTANCE                    \"g_user_module_instance\" /* <=== src/glewlwyd.h:84:84:GLEWLWYD_TABLE_USER_MODULE_INSTANCE:0 */ \n"
  },
  {
    "repository": "vim",
    "cve_id": "CVE-2022-2845",
    "cwe_list": [
      "CWE-787"
    ],
    "commit_hash": "e98c88c44c308edaea5994b8ad4363e65030968c",
    "short_hash": "e98c88c4",
    "vulnerableMethods_before": [
      {
        "filename": "edit.c",
        "method_name": "vulnerable_function",
        "raw_code": "display_dollar(colnr_T col)\n{\n    colnr_T save_col;\n\n    if (!redrawing())\n\treturn;\n\n    cursor_off();\n    save_col = curwin->w_cursor.col;\n    curwin->w_cursor.col = col;\n    if (has_mbyte)\n    {\n\tchar_u *p;\n\n\t// If on the last byte of a multi-byte move to the first byte.\n\tp = ml_get_curline();\n\tcurwin->w_cursor.col -= (*mb_head_off)(p, p + col);\n    }\n    curs_columns(FALSE);\t    // recompute w_wrow and w_wcol\n    if (curwin->w_wcol < curwin->w_width)\n    {\n\tedit_putchar('$', FALSE);\n\tdollar_vcol = curwin->w_virtcol;\n    }\n    curwin->w_cursor.col = save_col;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "edit.c",
        "method_name": "fixed_function",
        "raw_code": "display_dollar(colnr_T col_arg)\n{\n    colnr_T col = col_arg < 0 ? 0 : col_arg;\n    colnr_T save_col;\n\n    if (!redrawing())\n\treturn;\n\n    cursor_off();\n    save_col = curwin->w_cursor.col;\n    curwin->w_cursor.col = col;\n    if (has_mbyte)\n    {\n\tchar_u *p;\n\n\t// If on the last byte of a multi-byte move to the first byte.\n\tp = ml_get_curline();\n\tcurwin->w_cursor.col -= (*mb_head_off)(p, p + col);\n    }\n    curs_columns(FALSE);\t    // recompute w_wrow and w_wcol\n    if (curwin->w_wcol < curwin->w_width)\n    {\n\tedit_putchar('$', FALSE);\n\tdollar_vcol = curwin->w_virtcol;\n    }\n    curwin->w_cursor.col = save_col;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"vim.h\"\n\n// Type Definitions:\n// colnr_T:\ntypedef int\tcolnr_T;\n\n// colnr_T:\ntypedef int\t\tcolnr_T;\n\n// char_u:\ntypedef unsigned char\tchar_u;\n"
  },
  {
    "repository": "linux",
    "cve_id": "CVE-2022-3077",
    "cwe_list": [
      "CWE-703"
    ],
    "commit_hash": "690b2549b19563ec5ad53e5c82f6a944d910086e",
    "short_hash": "690b2549",
    "vulnerableMethods_before": [
      {
        "filename": "i2c-ismt.c",
        "method_name": "vulnerable_function",
        "raw_code": "static int ismt_access(struct i2c_adapter *adap, u16 addr,\n\t\t       unsigned short flags, char read_write, u8 command,\n\t\t       int size, union i2c_smbus_data *data)\n{\n\tint ret;\n\tunsigned long time_left;\n\tdma_addr_t dma_addr = 0; /* address of the data buffer */\n\tu8 dma_size = 0;\n\tenum dma_data_direction dma_direction = 0;\n\tstruct ismt_desc *desc;\n\tstruct ismt_priv *priv = i2c_get_adapdata(adap);\n\tstruct device *dev = &priv->pci_dev->dev;\n\tu8 *dma_buffer = PTR_ALIGN(&priv->buffer[0], 16);\n\n\tdesc = &priv->hw[priv->head];\n\n\t/* Initialize the DMA buffer */\n\tmemset(priv->buffer, 0, sizeof(priv->buffer));\n\n\t/* Initialize the descriptor */\n\tmemset(desc, 0, sizeof(struct ismt_desc));\n\tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, read_write);\n\n\t/* Always clear the log entries */\n\tmemset(priv->log, 0, ISMT_LOG_ENTRIES * sizeof(u32));\n\n\t/* Initialize common control bits */\n\tif (likely(pci_dev_msi_enabled(priv->pci_dev)))\n\t\tdesc->control = ISMT_DESC_INT | ISMT_DESC_FAIR;\n\telse\n\t\tdesc->control = ISMT_DESC_FAIR;\n\n\tif ((flags & I2C_CLIENT_PEC) && (size != I2C_SMBUS_QUICK)\n\t    && (size != I2C_SMBUS_I2C_BLOCK_DATA))\n\t\tdesc->control |= ISMT_DESC_PEC;\n\n\tswitch (size) {\n\tcase I2C_SMBUS_QUICK:\n\t\tdev_dbg(dev, \"I2C_SMBUS_QUICK\\n\");\n\t\tbreak;\n\n\tcase I2C_SMBUS_BYTE:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t/*\n\t\t\t * Send Byte\n\t\t\t * The command field contains the write data\n\t\t\t */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE:  WRITE\\n\");\n\t\t\tdesc->control |= ISMT_DESC_CWRL;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t} else {\n\t\t\t/* Receive Byte */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE:  READ\\n\");\n\t\t\tdma_size = 1;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t\tdesc->rd_len = 1;\n\t\t}\n\t\tbreak;\n\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t/*\n\t\t\t * Write Byte\n\t\t\t * Command plus 1 data byte\n\t\t\t */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE_DATA:  WRITE\\n\");\n\t\t\tdesc->wr_len_cmd = 2;\n\t\t\tdma_size = 2;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdma_buffer[0] = command;\n\t\t\tdma_buffer[1] = data->byte;\n\t\t} else {\n\t\t\t/* Read Byte */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE_DATA:  READ\\n\");\n\t\t\tdesc->control |= ISMT_DESC_CWRL;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->rd_len = 1;\n\t\t\tdma_size = 1;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t}\n\t\tbreak;\n\n\tcase I2C_SMBUS_WORD_DATA:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t/* Write Word */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_WORD_DATA:  WRITE\\n\");\n\t\t\tdesc->wr_len_cmd = 3;\n\t\t\tdma_size = 3;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdma_buffer[0] = command;\n\t\t\tdma_buffer[1] = data->word & 0xff;\n\t\t\tdma_buffer[2] = data->word >> 8;\n\t\t} else {\n\t\t\t/* Read Word */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_WORD_DATA:  READ\\n\");\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->control |= ISMT_DESC_CWRL;\n\t\t\tdesc->rd_len = 2;\n\t\t\tdma_size = 2;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t}\n\t\tbreak;\n\n\tcase I2C_SMBUS_PROC_CALL:\n\t\tdev_dbg(dev, \"I2C_SMBUS_PROC_CALL\\n\");\n\t\tdesc->wr_len_cmd = 3;\n\t\tdesc->rd_len = 2;\n\t\tdma_size = 3;\n\t\tdma_direction = DMA_BIDIRECTIONAL;\n\t\tdma_buffer[0] = command;\n\t\tdma_buffer[1] = data->word & 0xff;\n\t\tdma_buffer[2] = data->word >> 8;\n\t\tbreak;\n\n\tcase I2C_SMBUS_BLOCK_DATA:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t/* Block Write */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_DATA:  WRITE\\n\");\n\t\t\tdma_size = data->block[0] + 1;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdesc->wr_len_cmd = dma_size;\n\t\t\tdesc->control |= ISMT_DESC_BLK;\n\t\t\tdma_buffer[0] = command;\n\t\t\tmemcpy(&dma_buffer[1], &data->block[1], dma_size - 1);\n\t\t} else {\n\t\t\t/* Block Read */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_DATA:  READ\\n\");\n\t\t\tdma_size = I2C_SMBUS_BLOCK_MAX;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t\tdesc->rd_len = dma_size;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->control |= (ISMT_DESC_BLK | ISMT_DESC_CWRL);\n\t\t}\n\t\tbreak;\n\n\tcase I2C_SMBUS_BLOCK_PROC_CALL:\n\t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_PROC_CALL\\n\");\n\t\tdma_size = I2C_SMBUS_BLOCK_MAX;\n\t\tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, 1);\n\t\tdesc->wr_len_cmd = data->block[0] + 1;\n\t\tdesc->rd_len = dma_size;\n\t\tdesc->control |= ISMT_DESC_BLK;\n\t\tdma_direction = DMA_BIDIRECTIONAL;\n\t\tdma_buffer[0] = command;\n\t\tmemcpy(&dma_buffer[1], &data->block[1], data->block[0]);\n\t\tbreak;\n\n\tcase I2C_SMBUS_I2C_BLOCK_DATA:\n\t\t/* Make sure the length is valid */\n\t\tif (data->block[0] < 1)\n\t\t\tdata->block[0] = 1;\n\n\t\tif (data->block[0] > I2C_SMBUS_BLOCK_MAX)\n\t\t\tdata->block[0] = I2C_SMBUS_BLOCK_MAX;\n\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t/* i2c Block Write */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_I2C_BLOCK_DATA:  WRITE\\n\");\n\t\t\tdma_size = data->block[0] + 1;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdesc->wr_len_cmd = dma_size;\n\t\t\tdesc->control |= ISMT_DESC_I2C;\n\t\t\tdma_buffer[0] = command;\n\t\t\tmemcpy(&dma_buffer[1], &data->block[1], dma_size - 1);\n\t\t} else {\n\t\t\t/* i2c Block Read */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_I2C_BLOCK_DATA:  READ\\n\");\n\t\t\tdma_size = data->block[0];\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t\tdesc->rd_len = dma_size;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->control |= (ISMT_DESC_I2C | ISMT_DESC_CWRL);\n\t\t\t/*\n\t\t\t * Per the \"Table 15-15. I2C Commands\",\n\t\t\t * in the External Design Specification (EDS),\n\t\t\t * (Document Number: 508084, Revision: 2.0),\n\t\t\t * the _rw bit must be 0\n\t\t\t */\n\t\t\tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, 0);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Unsupported transaction %d\\n\",\n\t\t\tsize);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t/* map the data buffer */\n\tif (dma_size != 0) {\n\t\tdev_dbg(dev, \" dev=%p\\n\", dev);\n\t\tdev_dbg(dev, \" data=%p\\n\", data);\n\t\tdev_dbg(dev, \" dma_buffer=%p\\n\", dma_buffer);\n\t\tdev_dbg(dev, \" dma_size=%d\\n\", dma_size);\n\t\tdev_dbg(dev, \" dma_direction=%d\\n\", dma_direction);\n\n\t\tdma_addr = dma_map_single(dev,\n\t\t\t\t      dma_buffer,\n\t\t\t\t      dma_size,\n\t\t\t\t      dma_direction);\n\n\t\tif (dma_mapping_error(dev, dma_addr)) {\n\t\t\tdev_err(dev, \"Error in mapping dma buffer %p\\n\",\n\t\t\t\tdma_buffer);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tdev_dbg(dev, \" dma_addr = %pad\\n\", &dma_addr);\n\n\t\tdesc->dptr_low = lower_32_bits(dma_addr);\n\t\tdesc->dptr_high = upper_32_bits(dma_addr);\n\t}\n\n\treinit_completion(&priv->cmp);\n\n\t/* Add the descriptor */\n\tismt_submit_desc(priv);\n\n\t/* Now we wait for interrupt completion, 1s */\n\ttime_left = wait_for_completion_timeout(&priv->cmp, HZ*1);\n\n\t/* unmap the data buffer */\n\tif (dma_size != 0)\n\t\tdma_unmap_single(dev, dma_addr, dma_size, dma_direction);\n\n\tif (unlikely(!time_left)) {\n\t\tdev_err(dev, \"completion wait timed out\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\t/* do any post processing of the descriptor here */\n\tret = ismt_process_desc(desc, data, priv, size, read_write);\n\nout:\n\t/* Update the ring pointer */\n\tpriv->head++;\n\tpriv->head %= ISMT_DESC_ENTRIES;\n\n\treturn ret;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "i2c-ismt.c",
        "method_name": "fixed_function",
        "raw_code": "static int ismt_access(struct i2c_adapter *adap, u16 addr,\n\t\t       unsigned short flags, char read_write, u8 command,\n\t\t       int size, union i2c_smbus_data *data)\n{\n\tint ret;\n\tunsigned long time_left;\n\tdma_addr_t dma_addr = 0; /* address of the data buffer */\n\tu8 dma_size = 0;\n\tenum dma_data_direction dma_direction = 0;\n\tstruct ismt_desc *desc;\n\tstruct ismt_priv *priv = i2c_get_adapdata(adap);\n\tstruct device *dev = &priv->pci_dev->dev;\n\tu8 *dma_buffer = PTR_ALIGN(&priv->buffer[0], 16);\n\n\tdesc = &priv->hw[priv->head];\n\n\t/* Initialize the DMA buffer */\n\tmemset(priv->buffer, 0, sizeof(priv->buffer));\n\n\t/* Initialize the descriptor */\n\tmemset(desc, 0, sizeof(struct ismt_desc));\n\tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, read_write);\n\n\t/* Always clear the log entries */\n\tmemset(priv->log, 0, ISMT_LOG_ENTRIES * sizeof(u32));\n\n\t/* Initialize common control bits */\n\tif (likely(pci_dev_msi_enabled(priv->pci_dev)))\n\t\tdesc->control = ISMT_DESC_INT | ISMT_DESC_FAIR;\n\telse\n\t\tdesc->control = ISMT_DESC_FAIR;\n\n\tif ((flags & I2C_CLIENT_PEC) && (size != I2C_SMBUS_QUICK)\n\t    && (size != I2C_SMBUS_I2C_BLOCK_DATA))\n\t\tdesc->control |= ISMT_DESC_PEC;\n\n\tswitch (size) {\n\tcase I2C_SMBUS_QUICK:\n\t\tdev_dbg(dev, \"I2C_SMBUS_QUICK\\n\");\n\t\tbreak;\n\n\tcase I2C_SMBUS_BYTE:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t/*\n\t\t\t * Send Byte\n\t\t\t * The command field contains the write data\n\t\t\t */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE:  WRITE\\n\");\n\t\t\tdesc->control |= ISMT_DESC_CWRL;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t} else {\n\t\t\t/* Receive Byte */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE:  READ\\n\");\n\t\t\tdma_size = 1;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t\tdesc->rd_len = 1;\n\t\t}\n\t\tbreak;\n\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t/*\n\t\t\t * Write Byte\n\t\t\t * Command plus 1 data byte\n\t\t\t */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE_DATA:  WRITE\\n\");\n\t\t\tdesc->wr_len_cmd = 2;\n\t\t\tdma_size = 2;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdma_buffer[0] = command;\n\t\t\tdma_buffer[1] = data->byte;\n\t\t} else {\n\t\t\t/* Read Byte */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE_DATA:  READ\\n\");\n\t\t\tdesc->control |= ISMT_DESC_CWRL;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->rd_len = 1;\n\t\t\tdma_size = 1;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t}\n\t\tbreak;\n\n\tcase I2C_SMBUS_WORD_DATA:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t/* Write Word */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_WORD_DATA:  WRITE\\n\");\n\t\t\tdesc->wr_len_cmd = 3;\n\t\t\tdma_size = 3;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdma_buffer[0] = command;\n\t\t\tdma_buffer[1] = data->word & 0xff;\n\t\t\tdma_buffer[2] = data->word >> 8;\n\t\t} else {\n\t\t\t/* Read Word */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_WORD_DATA:  READ\\n\");\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->control |= ISMT_DESC_CWRL;\n\t\t\tdesc->rd_len = 2;\n\t\t\tdma_size = 2;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t}\n\t\tbreak;\n\n\tcase I2C_SMBUS_PROC_CALL:\n\t\tdev_dbg(dev, \"I2C_SMBUS_PROC_CALL\\n\");\n\t\tdesc->wr_len_cmd = 3;\n\t\tdesc->rd_len = 2;\n\t\tdma_size = 3;\n\t\tdma_direction = DMA_BIDIRECTIONAL;\n\t\tdma_buffer[0] = command;\n\t\tdma_buffer[1] = data->word & 0xff;\n\t\tdma_buffer[2] = data->word >> 8;\n\t\tbreak;\n\n\tcase I2C_SMBUS_BLOCK_DATA:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t/* Block Write */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_DATA:  WRITE\\n\");\n\t\t\tdma_size = data->block[0] + 1;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdesc->wr_len_cmd = dma_size;\n\t\t\tdesc->control |= ISMT_DESC_BLK;\n\t\t\tdma_buffer[0] = command;\n\t\t\tmemcpy(&dma_buffer[1], &data->block[1], dma_size - 1);\n\t\t} else {\n\t\t\t/* Block Read */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_DATA:  READ\\n\");\n\t\t\tdma_size = I2C_SMBUS_BLOCK_MAX;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t\tdesc->rd_len = dma_size;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->control |= (ISMT_DESC_BLK | ISMT_DESC_CWRL);\n\t\t}\n\t\tbreak;\n\n\tcase I2C_SMBUS_BLOCK_PROC_CALL:\n\t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_PROC_CALL\\n\");\n\t\tif (data->block[0] > I2C_SMBUS_BLOCK_MAX)\n\t\t\treturn -EINVAL;\n\n\t\tdma_size = I2C_SMBUS_BLOCK_MAX;\n\t\tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, 1);\n\t\tdesc->wr_len_cmd = data->block[0] + 1;\n\t\tdesc->rd_len = dma_size;\n\t\tdesc->control |= ISMT_DESC_BLK;\n\t\tdma_direction = DMA_BIDIRECTIONAL;\n\t\tdma_buffer[0] = command;\n\t\tmemcpy(&dma_buffer[1], &data->block[1], data->block[0]);\n\t\tbreak;\n\n\tcase I2C_SMBUS_I2C_BLOCK_DATA:\n\t\t/* Make sure the length is valid */\n\t\tif (data->block[0] < 1)\n\t\t\tdata->block[0] = 1;\n\n\t\tif (data->block[0] > I2C_SMBUS_BLOCK_MAX)\n\t\t\tdata->block[0] = I2C_SMBUS_BLOCK_MAX;\n\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\t/* i2c Block Write */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_I2C_BLOCK_DATA:  WRITE\\n\");\n\t\t\tdma_size = data->block[0] + 1;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdesc->wr_len_cmd = dma_size;\n\t\t\tdesc->control |= ISMT_DESC_I2C;\n\t\t\tdma_buffer[0] = command;\n\t\t\tmemcpy(&dma_buffer[1], &data->block[1], dma_size - 1);\n\t\t} else {\n\t\t\t/* i2c Block Read */\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_I2C_BLOCK_DATA:  READ\\n\");\n\t\t\tdma_size = data->block[0];\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t\tdesc->rd_len = dma_size;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->control |= (ISMT_DESC_I2C | ISMT_DESC_CWRL);\n\t\t\t/*\n\t\t\t * Per the \"Table 15-15. I2C Commands\",\n\t\t\t * in the External Design Specification (EDS),\n\t\t\t * (Document Number: 508084, Revision: 2.0),\n\t\t\t * the _rw bit must be 0\n\t\t\t */\n\t\t\tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, 0);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Unsupported transaction %d\\n\",\n\t\t\tsize);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t/* map the data buffer */\n\tif (dma_size != 0) {\n\t\tdev_dbg(dev, \" dev=%p\\n\", dev);\n\t\tdev_dbg(dev, \" data=%p\\n\", data);\n\t\tdev_dbg(dev, \" dma_buffer=%p\\n\", dma_buffer);\n\t\tdev_dbg(dev, \" dma_size=%d\\n\", dma_size);\n\t\tdev_dbg(dev, \" dma_direction=%d\\n\", dma_direction);\n\n\t\tdma_addr = dma_map_single(dev,\n\t\t\t\t      dma_buffer,\n\t\t\t\t      dma_size,\n\t\t\t\t      dma_direction);\n\n\t\tif (dma_mapping_error(dev, dma_addr)) {\n\t\t\tdev_err(dev, \"Error in mapping dma buffer %p\\n\",\n\t\t\t\tdma_buffer);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tdev_dbg(dev, \" dma_addr = %pad\\n\", &dma_addr);\n\n\t\tdesc->dptr_low = lower_32_bits(dma_addr);\n\t\tdesc->dptr_high = upper_32_bits(dma_addr);\n\t}\n\n\treinit_completion(&priv->cmp);\n\n\t/* Add the descriptor */\n\tismt_submit_desc(priv);\n\n\t/* Now we wait for interrupt completion, 1s */\n\ttime_left = wait_for_completion_timeout(&priv->cmp, HZ*1);\n\n\t/* unmap the data buffer */\n\tif (dma_size != 0)\n\t\tdma_unmap_single(dev, dma_addr, dma_size, dma_direction);\n\n\tif (unlikely(!time_left)) {\n\t\tdev_err(dev, \"completion wait timed out\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\t/* do any post processing of the descriptor here */\n\tret = ismt_process_desc(desc, data, priv, size, read_write);\n\nout:\n\t/* Update the ring pointer */\n\tpriv->head++;\n\tpriv->head %= ISMT_DESC_ENTRIES;\n\n\treturn ret;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/completion.h>\n#include <linux/stddef.h>\n#include <linux/interrupt.h>\n#include <linux/io-64-nonatomic-lo-hi.h>\n#include <linux/kernel.h>\n#include <linux/acpi.h>\n#include <linux/dma-mapping.h>\n#include <linux/i2c.h>\n\n// Type Definitions:\n// device:\nstatic struct device\n\n// ismt_priv:\nstruct ismt_priv {\n\tstruct i2c_adapter adapter;\n\tvoid __iomem *smba;\t\t\t/* PCI BAR */\n\tstruct pci_dev *pci_dev;\n\tstruct ismt_desc *hw;\t\t\t/* descriptor virt base addr */\n\tdma_addr_t io_rng_dma;\t\t\t/* descriptor HW base addr */\n\tu8 head;\t\t\t\t/* ring buffer head pointer */\n\tstruct completion cmp;\t\t\t/* interrupt completion */\n\tu8 buffer[I2C_SMBUS_BLOCK_MAX + 16];\t/* temp R/W data buffer */\n\tdma_addr_t log_dma;\n\tu32 *log;\n}\n\n// ismt_desc:\nstruct ismt_desc {\n\tu8 tgtaddr_rw;\t/* target address & r/w bit */\n\tu8 wr_len_cmd;\t/* write length in bytes or a command */\n\tu8 rd_len;\t/* read length */\n\tu8 control;\t/* control bits */\n\tu8 status;\t/* status bits */\n\tu8 retry;\t/* collision retry and retry count */\n\tu8 rxbytes;\t/* received bytes */\n\tu8 txbytes;\t/* transmitted bytes */\n\tu32 dptr_low;\t/* lower 32 bit of the data pointer */\n\tu32 dptr_high;\t/* upper 32 bit of the data pointer */\n}\n\n// dma_data_direction:\nenum dma_data_direction\n\n// Called Methods (top 10):\n// ISMT_MSTR_RPOLICY from drivers/i2c/busses/i2c-ismt.c:\n#define ISMT_MSTR_RPOLICY\t0x114\t/* Retry Policy */ /* <=== drivers/i2c/busses/i2c-ismt.c:121:121:ISMT_MSTR_RPOLICY:0 */ \n\n// ISMT_GR_ERRSTS from drivers/i2c/busses/i2c-ismt.c:\n#define ISMT_GR_ERRSTS\t\t0x018\t/* Error Status */ /* <=== drivers/i2c/busses/i2c-ismt.c:113:113:ISMT_GR_ERRSTS:0 */ \n\n// ISMT_MCTRL_FMHP from drivers/i2c/busses/i2c-ismt.c:\n#define ISMT_MCTRL_FMHP\t0x00ff0000\t/* Firmware Master Head Ptr (FMHP) */ /* <=== drivers/i2c/busses/i2c-ismt.c:134:134:ISMT_MCTRL_FMHP:0 */ \n\n// ISMT_MSTR_MSTS from drivers/i2c/busses/i2c-ismt.c:\n#define ISMT_MSTR_MSTS\t\t0x10c\t/* Master Status */ /* <=== drivers/i2c/busses/i2c-ismt.c:119:119:ISMT_MSTR_MSTS:0 */ \n\n// ISMT_DESC_CRC from drivers/i2c/busses/i2c-ismt.c:\n#define ISMT_DESC_CRC\t0x10\t/* CRC Error */ /* <=== drivers/i2c/busses/i2c-ismt.c:100:100:ISMT_DESC_CRC:0 */ \n\n// ISMT_SPGT from drivers/i2c/busses/i2c-ismt.c:\n#define ISMT_SPGT\t0x300\t/* SMBus PHY Global Timing */ /* <=== drivers/i2c/busses/i2c-ismt.c:124:124:ISMT_SPGT:0 */ \n\n// ismt_process_desc from drivers/i2c/busses/i2c-ismt.c:\nstatic int ismt_process_desc(const struct ismt_desc *desc, /* <=== ismt_process_desc */ \n\t\t\t     union i2c_smbus_data *data,\n\t\t\t     struct ismt_priv *priv, int size,\n\t\t\t     char read_write)\n{\n\tu8 *dma_buffer = PTR_ALIGN(&priv->buffer[0], 16);\n\n\tdev_dbg(&priv->pci_dev->dev, \"Processing completed descriptor\\n\");\n\t__ismt_desc_dump(&priv->pci_dev->dev, desc);\n\tismt_gen_reg_dump(priv);\n\tismt_mstr_reg_dump(priv);\n\n\tif (desc->status & ISMT_DESC_SCS) {\n\t\tif (read_write == I2C_SMBUS_WRITE &&\n\t\t    size != I2C_SMBUS_PROC_CALL &&\n\t\t    size != I2C_SMBUS_BLOCK_PROC_CALL)\n\t\t\treturn 0;\n\n\t\tswitch (size) {\n\t\tcase I2C_SMBUS_BYTE:\n\t\tcase I2C_SMBUS_BYTE_DATA:\n\t\t\tdata->byte = dma_buffer[0];\n\t\t\tbreak;\n\t\tcase I2C_SMBUS_WORD_DATA:\n\t\tcase I2C_SMBUS_PROC_CALL:\n\t\t\tdata->word = dma_buffer[0] | (dma_buffer[1] << 8);\n\t\t\tbreak;\n\t\tcase I2C_SMBUS_BLOCK_DATA:\n\t\tcase I2C_SMBUS_BLOCK_PROC_CALL:\n\t\t\tif (desc->rxbytes != dma_buffer[0] + 1)\n\t\t\t\treturn -EMSGSIZE;\n\n\t\t\tmemcpy(data->block, dma_buffer, desc->rxbytes);\n\t\t\tbreak;\n\t\tcase I2C_SMBUS_I2C_BLOCK_DATA:\n\t\t\tmemcpy(&data->block[1], dma_buffer, desc->rxbytes);\n\t\t\tdata->block[0] = desc->rxbytes;\n\t\t\tbreak;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (likely(desc->status & ISMT_DESC_NAK))\n\t\treturn -ENXIO;\n\n\tif (desc->status & ISMT_DESC_CRC)\n\t\treturn -EBADMSG;\n\n\tif (desc->status & ISMT_DESC_COL)\n\t\treturn -EAGAIN;\n\n\tif (desc->status & ISMT_DESC_LPR)\n\t\treturn -EPROTO;\n\n\tif (desc->status & (ISMT_DESC_DLTO | ISMT_DESC_CLTO))\n\t\treturn -ETIMEDOUT;\n\n\treturn -EIO;\n}\n\n// ISMT_DESC_SCS from drivers/i2c/busses/i2c-ismt.c:\n#define ISMT_DESC_SCS\t0x01\t/* Success */ /* <=== drivers/i2c/busses/i2c-ismt.c:97:97:ISMT_DESC_SCS:0 */ \n\n// ISMT_DESC_COL from drivers/i2c/busses/i2c-ismt.c:\n#define ISMT_DESC_COL\t0x40\t/* Collisions */ /* <=== drivers/i2c/busses/i2c-ismt.c:102:102:ISMT_DESC_COL:0 */ \n\n// ismt_submit_desc from drivers/i2c/busses/i2c-ismt.c:\nstatic void ismt_submit_desc(struct ismt_priv *priv) /* <=== ismt_submit_desc */ \n{\n\tuint fmhp;\n\tuint val;\n\n\tismt_desc_dump(priv);\n\tismt_gen_reg_dump(priv);\n\tismt_mstr_reg_dump(priv);\n\n\t/* Set the FMHP (Firmware Master Head Pointer)*/\n\tfmhp = ((priv->head + 1) % ISMT_DESC_ENTRIES) << 16;\n\tval = readl(priv->smba + ISMT_MSTR_MCTRL);\n\twritel((val & ~ISMT_MCTRL_FMHP) | fmhp,\n\t       priv->smba + ISMT_MSTR_MCTRL);\n\n\t/* Set the start bit */\n\tval = readl(priv->smba + ISMT_MSTR_MCTRL);\n\twritel(val | ISMT_MCTRL_SS,\n\t       priv->smba + ISMT_MSTR_MCTRL);\n}\n"
  },
  {
    "repository": "vim",
    "cve_id": "CVE-2021-3968",
    "cwe_list": [
      "CWE-122"
    ],
    "commit_hash": "a062006b9de0b2947ab5fb376c6e67ef92a8cd69",
    "short_hash": "a062006b",
    "vulnerableMethods_before": [
      {
        "filename": "None",
        "method_name": "vulnerable_function",
        "raw_code": "n_start_visual_mode(int c)\n{\n#ifdef FEAT_CONCEAL\n    int cursor_line_was_concealed = curwin->w_p_cole > 0\n\t\t\t\t\t\t&& conceal_cursor_line(curwin);\n#endif\n\n    VIsual_mode = c;\n    VIsual_active = TRUE;\n    VIsual_reselect = TRUE;\n    trigger_modechanged();\n\n    // Corner case: the 0 position in a tab may change when going into\n    // virtualedit.  Recalculate curwin->w_cursor to avoid bad highlighting.\n    if (c == Ctrl_V && (get_ve_flags() & VE_BLOCK) && gchar_cursor() == TAB)\n    {\n\tvalidate_virtcol();\n\tcoladvance(curwin->w_virtcol);\n    }\n    VIsual = curwin->w_cursor;\n\n#ifdef FEAT_FOLDING\n    foldAdjustVisual();\n#endif\n\n    setmouse();\n#ifdef FEAT_CONCEAL\n    // Check if redraw is needed after changing the state.\n    conceal_check_cursor_line(cursor_line_was_concealed);\n#endif\n\n    if (p_smd && msg_silent == 0)\n\tredraw_cmdline = TRUE;\t// show visual mode later\n#ifdef FEAT_CLIPBOARD\n    // Make sure the clipboard gets updated.  Needed because start and\n    // end may still be the same, and the selection needs to be owned\n    clip_star.vmode = NUL;\n#endif\n\n    // Only need to redraw this line, unless still need to redraw an old\n    // Visual area (when 'lazyredraw' is set).\n    if (curwin->w_redr_type < INVERTED)\n    {\n\tcurwin->w_old_cursor_lnum = curwin->w_cursor.lnum;\n\tcurwin->w_old_visual_lnum = curwin->w_cursor.lnum;\n    }\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "None",
        "method_name": "fixed_function",
        "raw_code": "n_start_visual_mode(int c)\n{\n#ifdef FEAT_CONCEAL\n    int cursor_line_was_concealed = curwin->w_p_cole > 0\n\t\t\t\t\t\t&& conceal_cursor_line(curwin);\n#endif\n\n    VIsual_mode = c;\n    VIsual_active = TRUE;\n    VIsual_reselect = TRUE;\n\n    // Corner case: the 0 position in a tab may change when going into\n    // virtualedit.  Recalculate curwin->w_cursor to avoid bad highlighting.\n    if (c == Ctrl_V && (get_ve_flags() & VE_BLOCK) && gchar_cursor() == TAB)\n    {\n\tvalidate_virtcol();\n\tcoladvance(curwin->w_virtcol);\n    }\n    VIsual = curwin->w_cursor;\n\n#ifdef FEAT_FOLDING\n    foldAdjustVisual();\n#endif\n\n    trigger_modechanged();\n    setmouse();\n#ifdef FEAT_CONCEAL\n    // Check if redraw is needed after changing the state.\n    conceal_check_cursor_line(cursor_line_was_concealed);\n#endif\n\n    if (p_smd && msg_silent == 0)\n\tredraw_cmdline = TRUE;\t// show visual mode later\n#ifdef FEAT_CLIPBOARD\n    // Make sure the clipboard gets updated.  Needed because start and\n    // end may still be the same, and the selection needs to be owned\n    clip_star.vmode = NUL;\n#endif\n\n    // Only need to redraw this line, unless still need to redraw an old\n    // Visual area (when 'lazyredraw' is set).\n    if (curwin->w_redr_type < INVERTED)\n    {\n\tcurwin->w_old_cursor_lnum = curwin->w_cursor.lnum;\n\tcurwin->w_old_visual_lnum = curwin->w_cursor.lnum;\n    }\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"vim.h\"\n\n// Called Methods (top 10):\n// EXMODE_NORMAL from src/vim.h:\n#define EXMODE_NORMAL\t\t1 /* <=== src/vim.h:806:806:EXMODE_NORMAL:0 */ \n\n// dict_add_string_len from src/dict.c:\n    int /* <=== dict_add_string_len */ \ndict_add_string_len(dict_T *d, char *key, char_u *str, int len)\n{\n    dictitem_T\t*item;\n    char_u\t*val = NULL;\n\n    item = dictitem_alloc((char_u *)key);\n    if (item == NULL)\n\treturn FAIL;\n    item->di_tv.v_type = VAR_STRING;\n    if (str != NULL)\n    {\n\tif (len == -1)\n\t    val = vim_strsave(str);\n\telse\n\t    val = vim_strnsave(str, len);\n    }\n    item->di_tv.vval.v_string = val;\n    if (dict_add(d, item) == FAIL)\n    {\n\tdictitem_free(item);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n// apply_autocmds_group from src/autocmd.c:\n    static int /* <=== apply_autocmds_group */ \napply_autocmds_group(\n    event_T\tevent,\n    char_u\t*fname,\t     // NULL or empty means use actual file name\n    char_u\t*fname_io,   // fname to use for <afile> on cmdline, NULL means\n\t\t\t     // use fname\n    int\t\tforce,\t     // when TRUE, ignore autocmd_busy\n    int\t\tgroup,\t     // group ID, or AUGROUP_ALL\n    buf_T\t*buf,\t     // buffer for <abuf>\n    exarg_T\t*eap UNUSED) // command arguments\n{\n    char_u\t*sfname = NULL;\t// short file name\n    char_u\t*tail;\n    int\t\tsave_changed;\n    buf_T\t*old_curbuf;\n    int\t\tretval = FALSE;\n    char_u\t*save_autocmd_fname;\n    int\t\tsave_autocmd_fname_full;\n    int\t\tsave_autocmd_bufnr;\n    char_u\t*save_autocmd_match;\n    int\t\tsave_autocmd_busy;\n    int\t\tsave_autocmd_nested;\n    static int\tnesting = 0;\n    AutoPatCmd\tpatcmd;\n    AutoPat\t*ap;\n    sctx_T\tsave_current_sctx;\n#ifdef FEAT_EVAL\n    funccal_entry_T funccal_entry;\n    char_u\t*save_cmdarg;\n    long\tsave_cmdbang;\n#endif\n    static int\tfilechangeshell_busy = FALSE;\n#ifdef FEAT_PROFILE\n    proftime_T\twait_time;\n#endif\n    int\t\tdid_save_redobuff = FALSE;\n    save_redo_T\tsave_redo;\n    int\t\tsave_KeyTyped = KeyTyped;\n    ESTACK_CHECK_DECLARATION\n\n    /*\n     * Quickly return if there are no autocommands for this event or\n     * autocommands are blocked.\n     */\n    if (event == NUM_EVENTS || first_autopat[(int)event] == NULL\n\t    || autocmd_blocked > 0)\n\tgoto BYPASS_AU;\n\n    /*\n     * When autocommands are busy, new autocommands are only executed when\n     * explicitly enabled with the \"nested\" flag.\n     */\n    if (autocmd_busy && !(force || autocmd_nested))\n\tgoto BYPASS_AU;\n\n#ifdef FEAT_EVAL\n    /*\n     * Quickly return when immediately aborting on error, or when an interrupt\n     * occurred or an exception was thrown but not caught.\n     */\n    if (aborting())\n\tgoto BYPASS_AU;\n#endif\n\n    /*\n     * FileChangedShell never nests, because it can create an endless loop.\n     */\n    if (filechangeshell_busy && (event == EVENT_FILECHANGEDSHELL\n\t\t\t\t      || event == EVENT_FILECHANGEDSHELLPOST))\n\tgoto BYPASS_AU;\n\n    /*\n     * Ignore events in 'eventignore'.\n     */\n    if (event_ignored(event))\n\tgoto BYPASS_AU;\n\n    /*\n     * Allow nesting of autocommands, but restrict the depth, because it's\n     * possible to create an endless loop.\n     */\n    if (nesting == 10)\n    {\n\temsg(_(\"E218: autocommand nesting too deep\"));\n\tgoto BYPASS_AU;\n    }\n\n    /*\n     * Check if these autocommands are disabled.  Used when doing \":all\" or\n     * \":ball\".\n     */\n    if (       (autocmd_no_enter\n\t\t&& (event == EVENT_WINENTER || event == EVENT_BUFENTER))\n\t    || (autocmd_no_leave\n\t\t&& (event == EVENT_WINLEAVE || event == EVENT_BUFLEAVE)))\n\tgoto BYPASS_AU;\n\n    /*\n     * Save the autocmd_* variables and info about the current buffer.\n     */\n    save_autocmd_fname = autocmd_fname;\n    save_autocmd_fname_full = autocmd_fname_full;\n    save_autocmd_bufnr = autocmd_bufnr;\n    save_autocmd_match = autocmd_match;\n    save_autocmd_busy = autocmd_busy;\n    save_autocmd_nested = autocmd_nested;\n    save_changed = curbuf->b_changed;\n    old_curbuf = curbuf;\n\n    /*\n     * Set the file name to be used for <afile>.\n     * Make a copy to avoid that changing a buffer name or directory makes it\n     * invalid.\n     */\n    if (fname_io == NULL)\n    {\n\tif (event == EVENT_COLORSCHEME || event == EVENT_COLORSCHEMEPRE\n\t\t\t\t\t\t   || event == EVENT_OPTIONSET\n\t\t\t\t\t\t   || event == EVENT_MODECHANGED)\n\t    autocmd_fname = NULL;\n\telse if (fname != NULL && !ends_excmd(*fname))\n\t    autocmd_fname = fname;\n\telse if (buf != NULL)\n\t    autocmd_fname = buf->b_ffname;\n\telse\n\t    autocmd_fname = NULL;\n    }\n    else\n\tautocmd_fname = fname_io;\n    if (autocmd_fname != NULL)\n\tautocmd_fname = vim_strsave(autocmd_fname);\n    autocmd_fname_full = FALSE; // call FullName_save() later\n\n    /*\n     * Set the buffer number to be used for <abuf>.\n     */\n    if (buf == NULL)\n\tautocmd_bufnr = 0;\n    else\n\tautocmd_bufnr = buf->b_fnum;\n\n    /*\n     * When the file name is NULL or empty, use the file name of buffer \"buf\".\n     * Always use the full path of the file name to match with, in case\n     * \"allow_dirs\" is set.\n     */\n    if (fname == NULL || *fname == NUL)\n    {\n\tif (buf == NULL)\n\t    fname = NULL;\n\telse\n\t{\n#ifdef FEAT_SYN_HL\n\t    if (event == EVENT_SYNTAX)\n\t\tfname = buf->b_p_syn;\n\t    else\n#endif\n\t\tif (event == EVENT_FILETYPE)\n\t\t    fname = buf->b_p_ft;\n\t\telse\n\t\t{\n\t\t    if (buf->b_sfname != NULL)\n\t\t\tsfname = vim_strsave(buf->b_sfname);\n\t\t    fname = buf->b_ffname;\n\t\t}\n\t}\n\tif (fname == NULL)\n\t    fname = (char_u *)\"\";\n\tfname = vim_strsave(fname);\t// make a copy, so we can change it\n    }\n    else\n    {\n\tsfname = vim_strsave(fname);\n\t// Don't try expanding FileType, Syntax, FuncUndefined, WindowID,\n\t// ColorScheme, QuickFixCmd* or DirChanged\n\tif (event == EVENT_FILETYPE\n\t\t|| event == EVENT_SYNTAX\n\t\t|| event == EVENT_CMDLINECHANGED\n\t\t|| event == EVENT_CMDLINEENTER\n\t\t|| event == EVENT_CMDLINELEAVE\n\t\t|| event == EVENT_CMDWINENTER\n\t\t|| event == EVENT_CMDWINLEAVE\n\t\t|| event == EVENT_CMDUNDEFINED\n\t\t|| event == EVENT_FUNCUNDEFINED\n\t\t|| event == EVENT_REMOTEREPLY\n\t\t|| event == EVENT_SPELLFILEMISSING\n\t\t|| event == EVENT_QUICKFIXCMDPRE\n\t\t|| event == EVENT_COLORSCHEME\n\t\t|| event == EVENT_COLORSCHEMEPRE\n\t\t|| event == EVENT_OPTIONSET\n\t\t|| event == EVENT_QUICKFIXCMDPOST\n\t\t|| event == EVENT_DIRCHANGED\n\t\t|| event == EVENT_MODECHANGED\n\t\t|| event == EVENT_WINCLOSED)\n\t{\n\t    fname = vim_strsave(fname);\n\t    autocmd_fname_full = TRUE; // don't expand it later\n\t}\n\telse\n\t    fname = FullName_save(fname, FALSE);\n    }\n    if (fname == NULL)\t    // out of memory\n    {\n\tvim_free(sfname);\n\tretval = FALSE;\n\tgoto BYPASS_AU;\n    }\n\n#ifdef BACKSLASH_IN_FILENAME\n    /*\n     * Replace all backslashes with forward slashes.  This makes the\n     * autocommand patterns portable between Unix and MS-DOS.\n     */\n    if (sfname != NULL)\n\tforward_slash(sfname);\n    forward_slash(fname);\n#endif\n\n#ifdef VMS\n    // remove version for correct match\n    if (sfname != NULL)\n\tvms_remove_version(sfname);\n    vms_remove_version(fname);\n#endif\n\n    /*\n     * Set the name to be used for <amatch>.\n     */\n    autocmd_match = fname;\n\n\n    // Don't redraw while doing autocommands.\n    ++RedrawingDisabled;\n\n    // name and lnum are filled in later\n    estack_push(ETYPE_AUCMD, NULL, 0);\n    ESTACK_CHECK_SETUP\n\n    save_current_sctx = current_sctx;\n\n#ifdef FEAT_EVAL\n# ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n\tprof_child_enter(&wait_time); // doesn't count for the caller itself\n# endif\n\n    // Don't use local function variables, if called from a function.\n    save_funccal(&funccal_entry);\n#endif\n\n    /*\n     * When starting to execute autocommands, save the search patterns.\n     */\n    if (!autocmd_busy)\n    {\n\tsave_search_patterns();\n\tif (!ins_compl_active())\n\t{\n\t    saveRedobuff(&save_redo);\n\t    did_save_redobuff = TRUE;\n\t}\n\tdid_filetype = keep_filetype;\n    }\n\n    /*\n     * Note that we are applying autocmds.  Some commands need to know.\n     */\n    autocmd_busy = TRUE;\n    filechangeshell_busy = (event == EVENT_FILECHANGEDSHELL);\n    ++nesting;\t\t// see matching decrement below\n\n    // Remember that FileType was triggered.  Used for did_filetype().\n    if (event == EVENT_FILETYPE)\n\tdid_filetype = TRUE;\n\n    tail = gettail(fname);\n\n    // Find first autocommand that matches\n    patcmd.curpat = first_autopat[(int)event];\n    patcmd.nextcmd = NULL;\n    patcmd.group = group;\n    patcmd.fname = fname;\n    patcmd.sfname = sfname;\n    patcmd.tail = tail;\n    patcmd.event = event;\n    patcmd.arg_bufnr = autocmd_bufnr;\n    patcmd.next = NULL;\n    auto_next_pat(&patcmd, FALSE);\n\n    // found one, start executing the autocommands\n    if (patcmd.curpat != NULL)\n    {\n\t// add to active_apc_list\n\tpatcmd.next = active_apc_list;\n\tactive_apc_list = &patcmd;\n\n#ifdef FEAT_EVAL\n\t// set v:cmdarg (only when there is a matching pattern)\n\tsave_cmdbang = (long)get_vim_var_nr(VV_CMDBANG);\n\tif (eap != NULL)\n\t{\n\t    save_cmdarg = set_cmdarg(eap, NULL);\n\t    set_vim_var_nr(VV_CMDBANG, (long)eap->forceit);\n\t}\n\telse\n\t    save_cmdarg = NULL;\t// avoid gcc warning\n#endif\n\tretval = TRUE;\n\t// mark the last pattern, to avoid an endless loop when more patterns\n\t// are added when executing autocommands\n\tfor (ap = patcmd.curpat; ap->next != NULL; ap = ap->next)\n\t    ap->last = FALSE;\n\tap->last = TRUE;\n\n\tif (nesting == 1)\n\t    // make sure cursor and topline are valid\n\t    check_lnums(TRUE);\n\n\tdo_cmdline(NULL, getnextac, (void *)&patcmd,\n\t\t\t\t     DOCMD_NOWAIT|DOCMD_VERBOSE|DOCMD_REPEAT);\n\n\tif (nesting == 1)\n\t    // restore cursor and topline, unless they were changed\n\t    reset_lnums();\n\n#ifdef FEAT_EVAL\n\tif (eap != NULL)\n\t{\n\t    (void)set_cmdarg(NULL, save_cmdarg);\n\t    set_vim_var_nr(VV_CMDBANG, save_cmdbang);\n\t}\n#endif\n\t// delete from active_apc_list\n\tif (active_apc_list == &patcmd)\t    // just in case\n\t    active_apc_list = patcmd.next;\n    }\n\n    --RedrawingDisabled;\n    autocmd_busy = save_autocmd_busy;\n    filechangeshell_busy = FALSE;\n    autocmd_nested = save_autocmd_nested;\n    vim_free(SOURCING_NAME);\n    ESTACK_CHECK_NOW\n    estack_pop();\n    vim_free(autocmd_fname);\n    autocmd_fname = save_autocmd_fname;\n    autocmd_fname_full = save_autocmd_fname_full;\n    autocmd_bufnr = save_autocmd_bufnr;\n    autocmd_match = save_autocmd_match;\n    current_sctx = save_current_sctx;\n#ifdef FEAT_EVAL\n    restore_funccal();\n# ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n\tprof_child_exit(&wait_time);\n# endif\n#endif\n    KeyTyped = save_KeyTyped;\n    vim_free(fname);\n    vim_free(sfname);\n    --nesting;\t\t// see matching increment above\n\n    /*\n     * When stopping to execute autocommands, restore the search patterns and\n     * the redo buffer.  Free any buffers in the au_pending_free_buf list and\n     * free any windows in the au_pending_free_win list.\n     */\n    if (!autocmd_busy)\n    {\n\trestore_search_patterns();\n\tif (did_save_redobuff)\n\t    restoreRedobuff(&save_redo);\n\tdid_filetype = FALSE;\n\twhile (au_pending_free_buf != NULL)\n\t{\n\t    buf_T *b = au_pending_free_buf->b_next;\n\n\t    vim_free(au_pending_free_buf);\n\t    au_pending_free_buf = b;\n\t}\n\twhile (au_pending_free_win != NULL)\n\t{\n\t    win_T *w = au_pending_free_win->w_next;\n\n\t    vim_free(au_pending_free_win);\n\t    au_pending_free_win = w;\n\t}\n    }\n\n    /*\n     * Some events don't set or reset the Changed flag.\n     * Check if still in the same buffer!\n     */\n    if (curbuf == old_curbuf\n\t    && (event == EVENT_BUFREADPOST\n\t\t|| event == EVENT_BUFWRITEPOST\n\t\t|| event == EVENT_FILEAPPENDPOST\n\t\t|| event == EVENT_VIMLEAVE\n\t\t|| event == EVENT_VIMLEAVEPRE))\n    {\n#ifdef FEAT_TITLE\n\tif (curbuf->b_changed != save_changed)\n\t    need_maketitle = TRUE;\n#endif\n\tcurbuf->b_changed = save_changed;\n    }\n\n    au_cleanup();\t// may really delete removed patterns/commands now\n\nBYPASS_AU:\n    // When wiping out a buffer make sure all its buffer-local autocommands\n    // are deleted.\n    if (event == EVENT_BUFWIPEOUT && buf != NULL)\n\taubuflocal_remove(buf);\n\n    if (retval == OK && event == EVENT_FILETYPE)\n\tau_did_filetype = TRUE;\n\n    return retval;\n}\n\n// dict_add_string from src/dict.c:\n    int /* <=== dict_add_string */ \ndict_add_string(dict_T *d, char *key, char_u *str)\n{\n    return dict_add_string_len(d, key, str, -1);\n}\n\n// trigger_modechanged from src/misc1.c:\nvoid\ntrigger_modechanged()\n{\n#ifdef FEAT_EVAL\n    dict_T\t    *v_event;\n    typval_T\t    rettv;\n    typval_T\t    tv[2];\n    char_u\t    *pat_pre;\n    char_u\t    *pat;\n    save_v_event_T  save_v_event;\n\n    if (!has_modechanged())\n\treturn;\n\n    tv[0].v_type = VAR_NUMBER;\n    tv[0].vval.v_number = 1;\t    // get full mode\n    tv[1].v_type = VAR_UNKNOWN;\n    f_mode(tv, &rettv);\n    if (STRCMP(rettv.vval.v_string, last_mode) == 0)\n    {\n\tvim_free(rettv.vval.v_string);\n\treturn;\n    }\n\n    v_event = get_v_event(&save_v_event);\n    (void)dict_add_string(v_event, \"new_mode\", rettv.vval.v_string);\n    (void)dict_add_string(v_event, \"old_mode\", last_mode);\n    dict_set_items_ro(v_event);\n\n    // concatenate modes in format \"old_mode:new_mode\"\n    pat_pre = concat_str(last_mode, (char_u*)\":\");\n    pat = concat_str(pat_pre, rettv.vval.v_string);\n    vim_free(pat_pre);\n\n    apply_autocmds(EVENT_MODECHANGED, pat, NULL, FALSE, curbuf);\n    STRCPY(last_mode, rettv.vval.v_string);\n\n    vim_free(pat);\n ...\n\n// HITRETURN from src/vim.h:\n#define HITRETURN\t(0x200 + NORMAL) // waiting for return or command /* <=== src/vim.h:697:697:HITRETURN:0 */ \n\n// STRCMP from src/vim.h:\n#define STRCMP(d, s)\t    strcmp((char *)(d), (char *)(s)) /* <=== src/vim.h:1628:1628:STRCMP:2 */ \n\n// FALSE from src/vim.h:\n# define FALSE\t0\t    // note: this is an int, not a long! /* <=== src/vim.h:1464:1464:FALSE:0 */ \n\n// has_modechanged from src/autocmd.c:\n    int /* <=== has_modechanged */ \nhas_modechanged(void)\n{\n    return (first_autopat[(int)EVENT_MODECHANGED] != NULL);\n}\n\n// TRUE from src/vim.h:\n# define TRUE\t1 /* <=== src/vim.h:1465:1465:TRUE:0 */ \n"
  },
  {
    "repository": "linux",
    "cve_id": "CVE-2021-3732",
    "cwe_list": [
      "CWE-200"
    ],
    "commit_hash": "427215d85e8d1476da1a86b8d67aceb485eb3631",
    "short_hash": "427215d8",
    "vulnerableMethods_before": [
      {
        "filename": "namespace.c",
        "method_name": "vulnerable_function",
        "raw_code": "struct vfsmount *clone_private_mount(const struct path *path)\n{\n\tstruct mount *old_mnt = real_mount(path->mnt);\n\tstruct mount *new_mnt;\n\n\tif (IS_MNT_UNBINDABLE(old_mnt))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tnew_mnt = clone_mnt(old_mnt, path->dentry, CL_PRIVATE);\n\tif (IS_ERR(new_mnt))\n\t\treturn ERR_CAST(new_mnt);\n\n\t/* Longterm mount to be removed by kern_unmount*() */\n\tnew_mnt->mnt_ns = MNT_NS_INTERNAL;\n\n\treturn &new_mnt->mnt;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "namespace.c",
        "method_name": "fixed_function",
        "raw_code": "struct vfsmount *clone_private_mount(const struct path *path)\n{\n\tstruct mount *old_mnt = real_mount(path->mnt);\n\tstruct mount *new_mnt;\n\n\tdown_read(&namespace_sem);\n\tif (IS_MNT_UNBINDABLE(old_mnt))\n\t\tgoto invalid;\n\n\tif (!check_mnt(old_mnt))\n\t\tgoto invalid;\n\n\tif (has_locked_children(old_mnt, path->dentry))\n\t\tgoto invalid;\n\n\tnew_mnt = clone_mnt(old_mnt, path->dentry, CL_PRIVATE);\n\tup_read(&namespace_sem);\n\n\tif (IS_ERR(new_mnt))\n\t\treturn ERR_CAST(new_mnt);\n\n\t/* Longterm mount to be removed by kern_unmount*() */\n\tnew_mnt->mnt_ns = MNT_NS_INTERNAL;\n\n\treturn &new_mnt->mnt;\n\ninvalid:\n\tup_read(&namespace_sem);\n\treturn ERR_PTR(-EINVAL);\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <linux/module.h>\n#include <linux/mnt_namespace.h>\n#include <linux/fsnotify.h>\n#include \"nfs.h\"\n#include <linux/capability.h>\n#include <uapi/linux/mount.h>\n#include <linux/export.h>\n#include <linux/fs_struct.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/init.h>\n#include <linux/cred.h>\n#include <linux/uaccess.h>\n#include <linux/vfs.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/task_work.h>\n#include <linux/proc_fs.h>\n#include <linux/fs_context.h>\n#include <linux/shmem_fs.h>\n#include \"pnode.h\"\n#include <linux/gfp.h>\n#include <linux/mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/idr.h>\n#include <linux/file.h>\n#include <linux/user_namespace.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/memblock.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched/task.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include \"internal.h\"\n\n// Type Definitions:\n// dentry:\ntypedef struct dentry\n\n// mount:\nstruct mount {\n\tstruct hlist_node mnt_hash;\n\tstruct mount *mnt_parent;\n\tstruct dentry *mnt_mountpoint;\n\tstruct vfsmount mnt;\n\tunion {\n\t\tstruct rcu_head mnt_rcu;\n\t\tstruct llist_node mnt_llist;\n\t};\n#ifdef CONFIG_SMP\n\tstruct mnt_pcp __percpu *mnt_pcp;\n#else\n\tint mnt_count;\n\tint mnt_writers;\n#endif\n\tstruct list_head mnt_mounts;\t/* list of children, anchored here */\n\tstruct list_head mnt_child;\t/* and going through their mnt_child */\n\tstruct list_head mnt_instance;\t/* mount instance on sb->s_mounts */\n\tconst char *mnt_devname;\t/* Name of device e.g. /dev/dsk/hda1 */\n\tstruct list_head mnt_list;\n\tstruct list_head mnt_expire;\t/* link in fs-specific expiry list */\n\tstruct list_head mnt_share;\t/* circular list of shared mounts */\n\tstruct list_head mnt_slave_list;/* list of slave mounts */\n\tstruct list_head mnt_slave;\t/* slave list entry */\n\tstruct mount *mnt_master;\t/* slave is on master->mnt_slave_list */\n\tstruct mnt_namespace *mnt_ns;\t/* containing namespace */\n\tstruct mountpoint *mnt_mp;\t/...\n\n// dentry:\nstatic struct dentry\n\n// mount:\nstatic struct mount\n\n// vfsmount:\nstatic struct vfsmount\n\n// path:\nstruct path\n\n// Called Methods (top 10):\n// IS_MNT_UNBINDABLE from fs/pnode.h:\n#define IS_MNT_UNBINDABLE(m) ((m)->mnt.mnt_flags & MNT_UNBINDABLE) /* <=== fs/pnode.h:17:17:IS_MNT_UNBINDABLE:1 */ \n\n// CL_EXPIRE from fs/pnode.h:\n#define CL_EXPIRE    \t\t0x01 /* <=== fs/pnode.h:23:23:CL_EXPIRE:0 */ \n\n// unlock_mount_hash from fs/namespace.c:\nstatic inline void unlock_mount_hash(void) /* <=== unlock_mount_hash */ \n{\n\twrite_sequnlock(&mount_lock);\n}\n\n// CL_SLAVE from fs/pnode.h:\n#define CL_SLAVE     \t\t0x02 /* <=== fs/pnode.h:24:24:CL_SLAVE:0 */ \n\n// has_locked_children from fs/namespace.c:\nstatic bool has_locked_children(struct mount *mnt, struct dentry *dentry) /* <=== has_locked_children */ \n{\n\tstruct mount *child;\n\n\tlist_for_each_entry(child, &mnt->mnt_mounts, mnt_child) {\n\t\tif (!is_subdir(child->mnt_mountpoint, dentry))\n\t\t\tcontinue;\n\n\t\tif (child->mnt.mnt_flags & MNT_LOCKED)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n// IS_MNT_SHARED from fs/pnode.h:\n#define IS_MNT_SHARED(m) ((m)->mnt.mnt_flags & MNT_SHARED) /* <=== fs/pnode.h:13:13:IS_MNT_SHARED:1 */ \n\n// IS_MNT_SLAVE from fs/pnode.h:\n#define IS_MNT_SLAVE(m) ((m)->mnt_master) /* <=== fs/pnode.h:14:14:IS_MNT_SLAVE:1 */ \n\n// set_mnt_shared from fs/pnode.h:\nstatic inline void set_mnt_shared(struct mount *mnt) /* <=== set_mnt_shared */ \n{\n\tmnt->mnt.mnt_flags &= ~MNT_SHARED_MASK;\n\tmnt->mnt.mnt_flags |= MNT_SHARED;\n}\n\n// mnt_alloc_group_id from fs/namespace.c:\nstatic int mnt_alloc_group_id(struct mount *mnt) /* <=== mnt_alloc_group_id */ \n{\n\tint res = ida_alloc_min(&mnt_group_ida, 1, GFP_KERNEL);\n\n\tif (res < 0)\n\t\treturn res;\n\tmnt->mnt_group_id = res;\n\treturn 0;\n}\n\n// free_vfsmnt from fs/namespace.c:\nstatic void free_vfsmnt(struct mount *mnt) /* <=== free_vfsmnt */ \n{\n\tstruct user_namespace *mnt_userns;\n\n\tmnt_userns = mnt_user_ns(&mnt->mnt);\n\tif (mnt_userns != &init_user_ns)\n\t\tput_user_ns(mnt_userns);\n\tkfree_const(mnt->mnt_devname);\n#ifdef CONFIG_SMP\n\tfree_percpu(mnt->mnt_pcp);\n#endif\n\tkmem_cache_free(mnt_cache, mnt);\n}\n"
  },
  {
    "repository": "linux",
    "cve_id": "CVE-2021-28972",
    "cwe_list": [
      "CWE-120"
    ],
    "commit_hash": "cc7a0bb058b85ea03db87169c60c7cfdd5d34678",
    "short_hash": "cc7a0bb0",
    "vulnerableMethods_before": [
      {
        "filename": "rpadlpar_sysfs.c",
        "method_name": "vulnerable_function",
        "raw_code": "static ssize_t add_slot_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t      const char *buf, size_t nbytes)\n{\n\tchar drc_name[MAX_DRC_NAME_LEN];\n\tchar *end;\n\tint rc;\n\n\tif (nbytes >= MAX_DRC_NAME_LEN)\n\t\treturn 0;\n\n\tmemcpy(drc_name, buf, nbytes);\n\n\tend = strchr(drc_name, '\\n');\n\tif (!end)\n\t\tend = &drc_name[nbytes];\n\t*end = '\\0';\n\n\trc = dlpar_add_slot(drc_name);\n\tif (rc)\n\t\treturn rc;\n\n\treturn nbytes;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "rpadlpar_sysfs.c",
        "method_name": "fixed_function",
        "raw_code": "static ssize_t add_slot_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t      const char *buf, size_t nbytes)\n{\n\tchar drc_name[MAX_DRC_NAME_LEN];\n\tchar *end;\n\tint rc;\n\n\tif (nbytes >= MAX_DRC_NAME_LEN)\n\t\treturn 0;\n\n\tstrscpy(drc_name, buf, nbytes + 1);\n\n\tend = strchr(drc_name, '\\n');\n\tif (end)\n\t\t*end = '\\0';\n\n\trc = dlpar_add_slot(drc_name);\n\tif (rc)\n\t\treturn rc;\n\n\treturn nbytes;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <linux/string.h>\n#include <linux/pci_hotplug.h>\n#include \"rpadlpar.h\"\n#include <linux/kobject.h>\n#include \"../pci.h\"\n#include <linux/pci.h>\n#include \"rpaphp.h\"\n\n// Called Methods (top 10):\n// rpaphp_deregister_slot from drivers/pci/hotplug/rpaphp_slot.c:\n\n\n// dlpar_add_slot from drivers/pci/hotplug/rpadlpar_core.c:\n\n\n// NODE_TYPE_PHB from drivers/pci/hotplug/rpadlpar_core.c:\n\n\n// dlpar_add_vio_slot from drivers/pci/hotplug/rpadlpar_core.c:\n\n\n// rpaphp_add_slot from drivers/pci/hotplug/rpaphp_core.c:\n\n\n// dlpar_pci_add_bus from drivers/pci/hotplug/rpadlpar_core.c:\n\n\n// find_php_slot_pci_node from drivers/pci/hotplug/rpadlpar_core.c:\n\n\n// dlpar_remove_pci_slot from drivers/pci/hotplug/rpadlpar_core.c:\n\n\n// NODE_TYPE_VIO from drivers/pci/hotplug/rpadlpar_core.c:\n\n\n// dlpar_find_new_dev from drivers/pci/hotplug/rpadlpar_core.c:\n\n"
  },
  {
    "repository": "ovs",
    "cve_id": "CVE-2021-3905",
    "cwe_list": [
      "CWE-401"
    ],
    "commit_hash": "803ed12e31b0377c37d7aa8c94b3b92f2081e349",
    "short_hash": "803ed12e",
    "vulnerableMethods_before": [
      {
        "filename": "ipf.c",
        "method_name": "vulnerable_function",
        "raw_code": "ipf_extract_frags_from_batch(struct ipf *ipf, struct dp_packet_batch *pb,\n                             ovs_be16 dl_type, uint16_t zone, long long now,\n                             uint32_t hash_basis)\n{\n    const size_t pb_cnt = dp_packet_batch_size(pb);\n    int pb_idx; /* Index in a packet batch. */\n    struct dp_packet *pkt;\n\n    DP_PACKET_BATCH_REFILL_FOR_EACH (pb_idx, pb_cnt, pkt, pb) {\n        if (OVS_UNLIKELY((dl_type == htons(ETH_TYPE_IP) &&\n                          ipf_is_valid_v4_frag(ipf, pkt))\n                          ||\n                          (dl_type == htons(ETH_TYPE_IPV6) &&\n                          ipf_is_valid_v6_frag(ipf, pkt)))) {\n\n            ovs_mutex_lock(&ipf->ipf_lock);\n            if (!ipf_handle_frag(ipf, pkt, dl_type, zone, now, hash_basis)) {\n                dp_packet_batch_refill(pb, pkt, pb_idx);\n            }\n            ovs_mutex_unlock(&ipf->ipf_lock);\n        } else {\n            dp_packet_batch_refill(pb, pkt, pb_idx);\n        }\n    }\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ipf.c",
        "method_name": "fixed_function",
        "raw_code": "ipf_extract_frags_from_batch(struct ipf *ipf, struct dp_packet_batch *pb,\n                             ovs_be16 dl_type, uint16_t zone, long long now,\n                             uint32_t hash_basis)\n{\n    const size_t pb_cnt = dp_packet_batch_size(pb);\n    int pb_idx; /* Index in a packet batch. */\n    struct dp_packet *pkt;\n\n    DP_PACKET_BATCH_REFILL_FOR_EACH (pb_idx, pb_cnt, pkt, pb) {\n        if (OVS_UNLIKELY((dl_type == htons(ETH_TYPE_IP) &&\n                          ipf_is_valid_v4_frag(ipf, pkt))\n                          ||\n                          (dl_type == htons(ETH_TYPE_IPV6) &&\n                          ipf_is_valid_v6_frag(ipf, pkt)))) {\n\n            ovs_mutex_lock(&ipf->ipf_lock);\n            if (!ipf_handle_frag(ipf, pkt, dl_type, zone, now, hash_basis)) {\n                dp_packet_batch_refill(pb, pkt, pb_idx);\n            } else {\n                dp_packet_delete(pkt);\n            }\n            ovs_mutex_unlock(&ipf->ipf_lock);\n        } else {\n            dp_packet_batch_refill(pb, pkt, pb_idx);\n        }\n    }\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"ipf.h\"\n#include \"openvswitch/poll-loop.h\"\n#include <ctype.h>\n#include <netinet/ip6.h>\n#include <netinet/in.h>\n#include \"openvswitch/vlog.h\"\n#include \"coverage.h\"\n#include <sys/types.h>\n#include <config.h>\n#include <errno.h>\n#include <netinet/icmp6.h>\n#include \"ovs-atomic.h\"\n#include \"util.h\"\n#include <string.h>\n#include \"packets.h\"\n#include \"latch.h\"\n#include \"openvswitch/hmap.h\"\n#include \"csum.h\"\n\n// Type Definitions:\n// dp_packet_batch:\nstruct dp_packet_batch\n\n// dp_packet:\nstruct dp_packet\n\n// ovs_be16:\ntypedef unsigned short uint16, uint16_t, ovs_be16, u16;\n\n// uint32_t:\ntypedef unsigned int uint32, uint32_t, ovs_be32, u32;\n\n// uint16_t:\ntypedef unsigned short uint16, uint16_t, ovs_be16, u16;\n\n// ipf:\nstruct ipf {\n    /* The clean thread is used to clean up fragments in the 'ipf'\n     * module if packet batches are not longer be sent through its user. */\n    pthread_t ipf_clean_thread;\n    struct latch ipf_clean_thread_exit;\n\n    int max_v4_frag_list_size;\n\n    struct ovs_mutex ipf_lock; /* Protects all of the following. */\n    /* These contain 'struct ipf_list's. */\n    struct hmap frag_lists OVS_GUARDED;\n    struct ovs_list frag_exp_list OVS_GUARDED;\n    struct ovs_list frag_complete_list OVS_GUARDED;\n    /* Contains 'struct reassembled_pkt's. */\n    struct ovs_list reassembled_pkt_list OVS_GUARDED;\n\n    /* Used to allow disabling fragmentation reassembly. */\n    atomic_bool ifp_v4_enabled;\n    atomic_bool ifp_v6_enabled;\n\n    /* Will be clamped above 400 bytes; the value chosen should handle\n     * alg control packets of interest that use string encoding of mutable\n     * IP fields; meaning, the control packets should not be fragmented. */\n    atomic_uint min_v4_frag_size;\n   ...\n\n// dp_packet:\nstruct dp_packet {\n#ifdef DPDK_NETDEV\n    struct rte_mbuf mbuf;       /* DPDK mbuf */\n#else\n    void *base_;                /* First byte of allocated space. */\n    uint16_t allocated_;        /* Number of bytes allocated. */\n    uint16_t data_ofs;          /* First byte actually in use. */\n    uint32_t size_;             /* Number of bytes in use. */\n    uint32_t ol_flags;          /* Offloading flags. */\n    uint32_t rss_hash;          /* Packet hash. */\n    uint32_t flow_mark;         /* Packet flow mark. */\n#endif\n    enum dp_packet_source source;  /* Source of memory allocated as 'base'. */\n\n    /* All the following elements of this struct are copied in a single call\n     * of memcpy in dp_packet_clone_with_headroom. */\n    uint16_t l2_pad_size;          /* Detected l2 padding size.\n                                    * Padding is non-pullable. */\n    uint16_t l2_5_ofs;             /* MPLS label stack offset, or UINT16_MAX */\n    uint16_t l3_ofs;               /* Network-level ...\n\n// Called Methods (top 10):\n// ipf_is_valid_v4_frag from lib/ipf.c:\nstatic bool\nipf_is_valid_v4_frag(struct ipf *ipf, struct dp_packet *pkt)\n{\n    if (OVS_UNLIKELY(dp_packet_ip_checksum_bad(pkt))) {\n        COVERAGE_INC(ipf_l3csum_err);\n        goto invalid_pkt;\n    }\n\n    const struct eth_header *l2 = dp_packet_eth(pkt);\n    const struct ip_header *l3 = dp_packet_l3(pkt);\n\n    if (OVS_UNLIKELY(!l2 || !l3)) {\n        goto invalid_pkt;\n    }\n\n    size_t l3_size = dp_packet_l3_size(pkt);\n    if (OVS_UNLIKELY(l3_size < IP_HEADER_LEN)) {\n        goto invalid_pkt;\n    }\n\n    if (!IP_IS_FRAGMENT(l3->ip_frag_off)) {\n        return false;\n    }\n\n    uint16_t ip_tot_len = ntohs(l3->ip_tot_len);\n    if (OVS_UNLIKELY(ip_tot_len != l3_size)) {\n        goto invalid_pkt;\n    }\n\n    size_t ip_hdr_len = IP_IHL(l3->ip_ihl_ver) * 4;\n    if (OVS_UNLIKELY(ip_hdr_len < IP_HEADER_LEN)) {\n        goto invalid_pkt;\n    }\n    if (OVS_UNLIKELY(l3_size < ip_hdr_len)) {\n        goto invalid_pkt;\n    }\n\n    if (OVS_UNLIKELY(!dp_packet_ip_checksum_valid(pkt)\n                    ...\n\n// OVS_UNLIKELY from lib/openvswitch/compiler.h:\n<empty>\n\n// ipf_is_valid_v6_frag from lib/ipf.c:\nstatic bool\nipf_is_valid_v6_frag(struct ipf *ipf, struct dp_packet *pkt)\n{\n    const struct eth_header *l2 = dp_packet_eth(pkt);\n    const struct  ovs_16aligned_ip6_hdr *l3 = dp_packet_l3(pkt);\n    const char *l4 = dp_packet_l4(pkt);\n\n    if (OVS_UNLIKELY(!l2 || !l3 || !l4)) {\n        goto invalid_pkt;\n    }\n\n    size_t l3_size = dp_packet_l3_size(pkt);\n    size_t l3_hdr_size = sizeof *l3;\n\n    if (OVS_UNLIKELY(l3_size < l3_hdr_size)) {\n        goto invalid_pkt;\n    }\n\n    uint8_t nw_frag = 0;\n    uint8_t nw_proto = l3->ip6_nxt;\n    const void *data = l3 + 1;\n    size_t datasize = l3_size - l3_hdr_size;\n    const struct ovs_16aligned_ip6_frag *frag_hdr = NULL;\n    if (!parse_ipv6_ext_hdrs(&data, &datasize, &nw_proto, &nw_frag,\n                             &frag_hdr) || !nw_frag || !frag_hdr) {\n        return false;\n    }\n\n    int pl = ntohs(l3->ip6_plen);\n    if (OVS_UNLIKELY(pl + l3_hdr_size != l3_size)) {\n        goto invalid_pkt;\n    }\n\n    ovs_be16 ip6f_offlg = frag_hdr->ip6f_of...\n\n// dp_packet_batch_size from lib/dp-packet.h:\nstatic inline size_t\ndp_packet_batch_size(const struct dp_packet_batch *batch)\n{\n    return batch->count;\n}\n\n// ipf_handle_frag from lib/ipf.c:\nstatic bool\nipf_handle_frag(struct ipf *ipf, struct dp_packet *pkt, ovs_be16 dl_type,\n                uint16_t zone, long long now, uint32_t hash_basis)\n    OVS_REQUIRES(ipf->ipf_lock)\n{\n    struct ipf_list_key key;\n    /* Initialize 4 variables for some versions of GCC. */\n    uint16_t start_data_byte = 0;\n    uint16_t end_data_byte = 0;\n    bool ff = false;\n    bool lf = false;\n    bool v6 = dl_type == htons(ETH_TYPE_IPV6);\n\n    if (v6 && ipf_get_v6_enabled(ipf)) {\n        ipf_v6_key_extract(pkt, dl_type, zone, &key, &start_data_byte,\n                           &end_data_byte, &ff, &lf);\n    } else if (!v6 && ipf_get_v4_enabled(ipf)) {\n        ipf_v4_key_extract(pkt, dl_type, zone, &key, &start_data_byte,\n                           &end_data_byte, &ff, &lf);\n    } else {\n        return false;\n    }\n\n    unsigned int nfrag_max;\n    atomic_read_relaxed(&ipf->nfrag_max, &nfrag_max);\n    if (atomic_count_get(&ipf->nfrag) >= nfrag_max) {\n        return false;\n    }\n\n    uint32_t hash =...\n\n// ovs_mutex_lock from lib/openvswitch/thread.h:\n<empty>\n\n// dp_packet_delete from lib/dp-packet.h:\nstatic inline void\ndp_packet_delete(struct dp_packet *b)\n{\n    if (b) {\n        if (b->source == DPBUF_DPDK) {\n            /* If this dp_packet was allocated by DPDK it must have been\n             * created as a dp_packet */\n            free_dpdk_buf((struct dp_packet*) b);\n            return;\n        }\n\n        if (b->source == DPBUF_AFXDP) {\n            free_afxdp_buf(b);\n            return;\n        }\n\n        dp_packet_uninit(b);\n        free(b);\n    }\n}\n\n// htons from include/sparse/netinet/in.h:\nstatic inline ovs_be16 htons(uint16_t x)\n{\n    return (OVS_FORCE ovs_be16) x;\n}\n"
  },
  {
    "repository": "deark",
    "cve_id": "CVE-2021-28856",
    "cwe_list": [
      "CWE-369"
    ],
    "commit_hash": "62acb7753b0e3c0d3ab3c15057b0a65222313334",
    "short_hash": "62acb775",
    "vulnerableMethods_before": [
      {
        "filename": "fmtutil.c",
        "method_name": "vulnerable_function",
        "raw_code": "void fmtutil_macbitmap_read_pixmap_only_fields(deark *c, dbuf *f, struct fmtutil_macbitmap_info *bi,\n\ti64 pos)\n{\n\ti64 pixmap_version;\n\ti64 pack_size;\n\ti64 plane_bytes;\n\ti64 n;\n\n\tde_dbg(c, \"additional PixMap header fields, at %d\", (int)pos);\n\tde_dbg_indent(c, 1);\n\n\tpixmap_version = dbuf_getu16be(f, pos+0);\n\tde_dbg(c, \"pixmap version: %d\", (int)pixmap_version);\n\n\tbi->packing_type = dbuf_getu16be(f, pos+2);\n\tde_dbg(c, \"packing type: %d\", (int)bi->packing_type);\n\n\tpack_size = dbuf_getu32be(f, pos+4);\n\tde_dbg(c, \"pixel data length: %d\", (int)pack_size);\n\n\tbi->hdpi = pict_read_fixed(f, pos+8);\n\tbi->vdpi = pict_read_fixed(f, pos+12);\n\tde_dbg(c, \"dpi: %.2f\"DE_CHAR_TIMES\"%.2f\", bi->hdpi, bi->vdpi);\n\n\tbi->pixeltype = dbuf_getu16be(f, pos+16);\n\tbi->pixelsize = dbuf_getu16be(f, pos+18);\n\tbi->cmpcount = dbuf_getu16be(f, pos+20);\n\tbi->cmpsize = dbuf_getu16be(f, pos+22);\n\tde_dbg(c, \"pixel type=%d, bits/pixel=%d, components/pixel=%d, bits/comp=%d\",\n\t\t(int)bi->pixeltype, (int)bi->pixelsize, (int)bi->cmpcount, (int)bi->cmpsize);\n\n\tbi->pdwidth = (bi->rowbytes*8)/bi->pixelsize;\n\tif(bi->pdwidth < bi->npwidth) {\n\t\tbi->pdwidth = bi->npwidth;\n\t}\n\n\tplane_bytes = dbuf_getu32be(f, pos+24);\n\tde_dbg(c, \"plane bytes: %d\", (int)plane_bytes);\n\n\tbi->pmTable = (u32)dbuf_getu32be(f, pos+28);\n\tde_dbg(c, \"pmTable: 0x%08x\", (unsigned int)bi->pmTable);\n\n\tn = dbuf_getu32be(f, pos+32);\n\tde_dbg(c, \"pmReserved: 0x%08x\", (unsigned int)n);\n\n\tde_dbg_indent(c, -1);\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "fmtutil.c",
        "method_name": "fixed_function",
        "raw_code": "void fmtutil_macbitmap_read_pixmap_only_fields(deark *c, dbuf *f, struct fmtutil_macbitmap_info *bi,\n\ti64 pos)\n{\n\ti64 pixmap_version;\n\ti64 pack_size;\n\ti64 plane_bytes;\n\ti64 n;\n\n\tde_dbg(c, \"additional PixMap header fields, at %d\", (int)pos);\n\tde_dbg_indent(c, 1);\n\n\tpixmap_version = dbuf_getu16be(f, pos+0);\n\tde_dbg(c, \"pixmap version: %d\", (int)pixmap_version);\n\n\tbi->packing_type = dbuf_getu16be(f, pos+2);\n\tde_dbg(c, \"packing type: %d\", (int)bi->packing_type);\n\n\tpack_size = dbuf_getu32be(f, pos+4);\n\tde_dbg(c, \"pixel data length: %d\", (int)pack_size);\n\n\tbi->hdpi = pict_read_fixed(f, pos+8);\n\tbi->vdpi = pict_read_fixed(f, pos+12);\n\tde_dbg(c, \"dpi: %.2f\"DE_CHAR_TIMES\"%.2f\", bi->hdpi, bi->vdpi);\n\n\tbi->pixeltype = dbuf_getu16be(f, pos+16);\n\tbi->pixelsize = dbuf_getu16be(f, pos+18);\n\tbi->cmpcount = dbuf_getu16be(f, pos+20);\n\tbi->cmpsize = dbuf_getu16be(f, pos+22);\n\tde_dbg(c, \"pixel type=%d, bits/pixel=%d, components/pixel=%d, bits/comp=%d\",\n\t\t(int)bi->pixeltype, (int)bi->pixelsize, (int)bi->cmpcount, (int)bi->cmpsize);\n\n\tif(bi->pixelsize>0) {\n\t\tbi->pdwidth = (bi->rowbytes*8)/bi->pixelsize;\n\t}\n\tif(bi->pdwidth < bi->npwidth) {\n\t\tbi->pdwidth = bi->npwidth;\n\t}\n\n\tplane_bytes = dbuf_getu32be(f, pos+24);\n\tde_dbg(c, \"plane bytes: %d\", (int)plane_bytes);\n\n\tbi->pmTable = (u32)dbuf_getu32be(f, pos+28);\n\tde_dbg(c, \"pmTable: 0x%08x\", (unsigned int)bi->pmTable);\n\n\tn = dbuf_getu32be(f, pos+32);\n\tde_dbg(c, \"pmReserved: 0x%08x\", (unsigned int)n);\n\n\tde_dbg_indent(c, -1);\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"deark-config.h\"\n#include \"deark-private.h\"\n#include \"deark-fmtutil.h\"\n\n// Type Definitions:\n// dbuf:\ntypedef struct dbuf_struct dbuf;\n\n// fmtutil_macbitmap_info:\nstruct fmtutil_macbitmap_info {\n\ti64 rowbytes; // The rowBytes field\n\ti64 rowspan; // Actual number of bytes/row\n\ti64 npwidth, pdwidth, height;\n\tint is_uncompressed;\n\ti64 packing_type;\n\ti64 pixeltype, pixelsize;\n\ti64 cmpcount, cmpsize;\n\tdouble hdpi, vdpi;\n\tu32 pmTable;\n\tint pixmap_flag;\n\tint has_colortable; // Does the file contain a colortable for this bitmap?\n\tint uses_pal; // Are we using the palette below?\n\ti64 num_pal_entries;\n\tde_color pal[256];\n}\n\n// Called Methods (top 10):\n// de_internal_err_fatal from src/deark-util.c:\nvoid de_internal_err_fatal(deark *c, const char *fmt, ...) /* <=== de_internal_err_fatal */ \n{\n\tva_list ap;\n\n\tde_puts(c, DE_MSGTYPE_ERROR, \"Internal error: \");\n\tva_start(ap, fmt);\n\tde_vprintf(c, DE_MSGTYPE_ERROR, fmt, ap);\n\tva_end(ap);\n\tde_puts(c, DE_MSGTYPE_ERROR, \"\\n\");\n\tde_fatalerror(c);\n}\n\n// dbuf_getu32be from src/deark-dbuf.c:\ni64 dbuf_getu32be(dbuf *f, i64 pos) /* <=== dbuf_getu32be */ \n{\n\tu8 m[4];\n\tdbuf_read(f, m, pos, 4);\n\treturn de_getu32be_direct(m);\n}\n\n// de_zeromem from src/deark-private.h:\n#define de_zeromem(a,b) memset((a),0,(b)) /* <=== src/deark-private.h:469:469:de_zeromem:2 */ \n\n// de_fseek from src/deark-unix.c:\nint de_fseek(FILE *fp, i64 offs, int whence) /* <=== de_fseek */ \n{\n\tint ret;\n\n#if DE_USE_FSEEKO\n\tret = fseeko(fp, (off_t)offs, whence);\n#else\n\tret = fseek(fp, (long)offs, whence);\n#endif\n\treturn ret;\n}\n\n// pict_read_fixed from src/fmtutil.c:\nstatic double pict_read_fixed(dbuf *f, i64 pos) /* <=== pict_read_fixed<duplicate>0 */ \n{\n\ti64 n;\n\n\t// I think QuickDraw's \"Fixed point\" numbers are signed, but I don't know\n\t// how negative numbers are handled.\n\tn = dbuf_geti32be(f, pos);\n\treturn ((double)n)/65536.0;\n}\n\n// dbuf_geti32be from src/deark-dbuf.c:\ni64 dbuf_geti32be(dbuf *f, i64 pos) /* <=== dbuf_geti32be */ \n{\n\ti64 n;\n\tn = dbuf_getu32be(f, pos);\n\treturn (i64)(i32)(u32)n;\n}\n\n// de_getu16be_direct from src/deark-dbuf.c:\ni64 de_getu16be_direct(const u8 *m) /* <=== de_getu16be_direct */ \n{\n\treturn (i64)(((u32)m[1]) | (((u32)m[0])<<8));\n}\n\n// de_memcpy from src/deark-private.h:\n#define de_memcpy   memcpy /* <=== src/deark-private.h:466:466:de_memcpy:0 */ \n\n// i64 from src/deark.h:\n#define i64 int64_t /* <=== src/deark.h:61:61:i64:0 */ \n\n// u8 from src/deark.h:\n#define u8 unsigned char /* <=== src/deark.h:67:67:u8:0 */ \n"
  },
  {
    "repository": "oniguruma",
    "cve_id": "CVE-2019-19246",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "4d461376bd85e7994835677b2ff453a43c49cd28",
    "short_hash": "4d461376",
    "vulnerableMethods_before": [
      {
        "filename": "regcomp.c",
        "method_name": "vulnerable_function",
        "raw_code": "expand_case_fold_string(Node* node, regex_t* reg)\n{\n#define THRESHOLD_CASE_FOLD_ALT_FOR_EXPANSION  8\n\n  int r, n, len, alt_num;\n  UChar *start, *end, *p;\n  Node *top_root, *root, *snode, *prev_node;\n  OnigCaseFoldCodeItem items[ONIGENC_GET_CASE_FOLD_CODES_MAX_NUM];\n  StrNode* sn = STR_(node);\n\n  if (NODE_STRING_IS_AMBIG(node)) return 0;\n\n  start = sn->s;\n  end   = sn->end;\n  if (start >= end) return 0;\n\n  r = 0;\n  top_root = root = prev_node = snode = NULL_NODE;\n  alt_num = 1;\n  p = start;\n  while (p < end) {\n    n = ONIGENC_GET_CASE_FOLD_CODES_BY_STR(reg->enc, reg->case_fold_flag, p, end,\n                                           items);\n    if (n < 0) {\n      r = n;\n      goto err;\n    }\n\n    len = enclen(reg->enc, p);\n\n    if (n == 0) {\n      if (IS_NULL(snode)) {\n        if (IS_NULL(root) && IS_NOT_NULL(prev_node)) {\n          top_root = root = onig_node_list_add(NULL_NODE, prev_node);\n          if (IS_NULL(root)) {\n            onig_node_free(prev_node);\n            goto mem_err;\n          }\n        }\n\n        prev_node = snode = onig_node_new_str(NULL, NULL);\n        if (IS_NULL(snode)) goto mem_err;\n        if (IS_NOT_NULL(root)) {\n          if (IS_NULL(onig_node_list_add(root, snode))) {\n            onig_node_free(snode);\n            goto mem_err;\n          }\n        }\n      }\n\n      r = onig_node_str_cat(snode, p, p + len);\n      if (r != 0) goto err;\n    }\n    else {\n      alt_num *= (n + 1);\n      if (alt_num > THRESHOLD_CASE_FOLD_ALT_FOR_EXPANSION) break;\n\n      if (IS_NULL(root) && IS_NOT_NULL(prev_node)) {\n        top_root = root = onig_node_list_add(NULL_NODE, prev_node);\n        if (IS_NULL(root)) {\n          onig_node_free(prev_node);\n          goto mem_err;\n        }\n      }\n\n      r = expand_case_fold_string_alt(n, items, p, len, end, reg, &prev_node);\n      if (r < 0) goto mem_err;\n      if (r == 1) {\n        if (IS_NULL(root)) {\n          top_root = prev_node;\n        }\n        else {\n          if (IS_NULL(onig_node_list_add(root, prev_node))) {\n            onig_node_free(prev_node);\n            goto mem_err;\n          }\n        }\n\n        root = NODE_CAR(prev_node);\n      }\n      else { /* r == 0 */\n        if (IS_NOT_NULL(root)) {\n          if (IS_NULL(onig_node_list_add(root, prev_node))) {\n            onig_node_free(prev_node);\n            goto mem_err;\n          }\n        }\n      }\n\n      snode = NULL_NODE;\n    }\n\n    p += len;\n  }\n\n  if (p < end) {\n    Node *srem;\n\n    r = expand_case_fold_make_rem_string(&srem, p, end, reg);\n    if (r != 0) goto mem_err;\n\n    if (IS_NOT_NULL(prev_node) && IS_NULL(root)) {\n      top_root = root = onig_node_list_add(NULL_NODE, prev_node);\n      if (IS_NULL(root)) {\n        onig_node_free(srem);\n        onig_node_free(prev_node);\n        goto mem_err;\n      }\n    }\n\n    if (IS_NULL(root)) {\n      prev_node = srem;\n    }\n    else {\n      if (IS_NULL(onig_node_list_add(root, srem))) {\n        onig_node_free(srem);\n        goto mem_err;\n      }\n    }\n  }\n\n  /* ending */\n  top_root = (IS_NOT_NULL(top_root) ? top_root : prev_node);\n  swap_node(node, top_root);\n  onig_node_free(top_root);\n  return 0;\n\n mem_err:\n  r = ONIGERR_MEMORY;\n\n err:\n  onig_node_free(top_root);\n  return r;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "regcomp.c",
        "method_name": "fixed_function",
        "raw_code": "expand_case_fold_string(Node* node, regex_t* reg)\n{\n#define THRESHOLD_CASE_FOLD_ALT_FOR_EXPANSION  8\n\n  int r, n, len, alt_num;\n  int is_ambig, fold_len;\n  UChar *start, *end, *p;\n  UChar* foldp;\n  Node *top_root, *root, *snode, *prev_node;\n  OnigCaseFoldCodeItem items[ONIGENC_GET_CASE_FOLD_CODES_MAX_NUM];\n  UChar buf[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n  StrNode* sn = STR_(node);\n\n  if (NODE_STRING_IS_AMBIG(node)) return 0;\n\n  start = sn->s;\n  end   = sn->end;\n  if (start >= end) return 0;\n\n  r = 0;\n  top_root = root = prev_node = snode = NULL_NODE;\n  alt_num = 1;\n  p = start;\n  while (p < end) {\n    n = ONIGENC_GET_CASE_FOLD_CODES_BY_STR(reg->enc, reg->case_fold_flag,\n                                           p, end, items);\n    if (n < 0) {\n      r = n;\n      goto err;\n    }\n\n    len = enclen(reg->enc, p);\n\n    if (n == 0 || IS_NOT_NULL(snode) ||\n        is_good_case_fold_items_for_search(reg->enc, len, n, items)) {\n      if (IS_NULL(snode)) {\n        if (IS_NULL(root) && IS_NOT_NULL(prev_node)) {\n          top_root = root = onig_node_list_add(NULL_NODE, prev_node);\n          if (IS_NULL(root)) {\n            onig_node_free(prev_node);\n            goto mem_err;\n          }\n        }\n\n        prev_node = snode = onig_node_new_str(NULL, NULL);\n        if (IS_NULL(snode)) goto mem_err;\n        if (IS_NOT_NULL(root)) {\n          if (IS_NULL(onig_node_list_add(root, snode))) {\n            onig_node_free(snode);\n            goto mem_err;\n          }\n        }\n\n        is_ambig = -1; /* -1: new */\n      }\n      else {\n        is_ambig = NODE_STRING_IS_AMBIG(snode);\n      }\n\n      if (n != 0) {\n        foldp = p;\n        fold_len = ONIGENC_MBC_CASE_FOLD(reg->enc, reg->case_fold_flag,\n                                         &foldp, end, buf);\n        foldp = buf;\n      }\n      else {\n        foldp = p; fold_len = len;\n      }\n\n      if ((n != 0 && is_ambig == 0) || (n == 0 && is_ambig > 0)) {\n        if (IS_NULL(root) /* && IS_NOT_NULL(prev_node) */) {\n          top_root = root = onig_node_list_add(NULL_NODE, prev_node);\n          if (IS_NULL(root)) {\n            onig_node_free(prev_node);\n            goto mem_err;\n          }\n        }\n\n        prev_node = snode = onig_node_new_str(foldp, foldp + fold_len);\n        if (IS_NULL(snode)) goto mem_err;\n        if (IS_NULL(onig_node_list_add(root, snode))) {\n          onig_node_free(snode);\n          goto mem_err;\n        }\n      }\n      else {\n        r = onig_node_str_cat(snode, foldp, foldp + fold_len);\n        if (r != 0) goto err;\n      }\n\n      if (n != 0) NODE_STRING_SET_AMBIG(snode);\n    }\n    else {\n      alt_num *= (n + 1);\n      if (alt_num > THRESHOLD_CASE_FOLD_ALT_FOR_EXPANSION) break;\n\n      if (IS_NULL(root) && IS_NOT_NULL(prev_node)) {\n        top_root = root = onig_node_list_add(NULL_NODE, prev_node);\n        if (IS_NULL(root)) {\n          onig_node_free(prev_node);\n          goto mem_err;\n        }\n      }\n\n      r = expand_case_fold_string_alt(n, items, p, len, end, reg, &prev_node);\n      if (r < 0) goto mem_err;\n      if (r == 1) {\n        if (IS_NULL(root)) {\n          top_root = prev_node;\n        }\n        else {\n          if (IS_NULL(onig_node_list_add(root, prev_node))) {\n            onig_node_free(prev_node);\n            goto mem_err;\n          }\n        }\n\n        root = NODE_CAR(prev_node);\n      }\n      else { /* r == 0 */\n        if (IS_NOT_NULL(root)) {\n          if (IS_NULL(onig_node_list_add(root, prev_node))) {\n            onig_node_free(prev_node);\n            goto mem_err;\n          }\n        }\n      }\n\n      snode = NULL_NODE;\n    }\n\n    p += len;\n  }\n\n  if (p < end) {\n    Node *srem;\n\n    r = expand_case_fold_make_rem_string(&srem, p, end, reg);\n    if (r != 0) goto mem_err;\n\n    if (IS_NOT_NULL(prev_node) && IS_NULL(root)) {\n      top_root = root = onig_node_list_add(NULL_NODE, prev_node);\n      if (IS_NULL(root)) {\n        onig_node_free(srem);\n        onig_node_free(prev_node);\n        goto mem_err;\n      }\n    }\n\n    if (IS_NULL(root)) {\n      prev_node = srem;\n    }\n    else {\n      if (IS_NULL(onig_node_list_add(root, srem))) {\n        onig_node_free(srem);\n        goto mem_err;\n      }\n    }\n  }\n\n  /* ending */\n  top_root = (IS_NOT_NULL(top_root) ? top_root : prev_node);\n  swap_node(node, top_root);\n  onig_node_free(top_root);\n  return 0;\n\n mem_err:\n  r = ONIGERR_MEMORY;\n\n err:\n  onig_node_free(top_root);\n  return r;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"regparse.h\"\n\n// Type Definitions:\n// OnigEncoding:\ntypedef OnigEncodingType* OnigEncoding;\n\n// OnigCaseFoldCodeItem:\ntypedef struct {\n  int byte_len;  /* argument(original) character(s) byte length */\n  int code_len;  /* number of code */\n  OnigCodePoint code[ONIGENC_MAX_COMP_CASE_FOLD_CODE_LEN];\n}\n\n// Node:\ntypedef struct _Node {\n  union {\n    struct {\n      NodeType node_type;\n      int status;\n      struct _Node* body;\n    } base;\n\n    StrNode       str;\n    CClassNode    cclass;\n    QuantNode     quant;\n    EnclosureNode enclosure;\n    BackRefNode   backref;\n    AnchorNode    anchor;\n    ConsAltNode   cons;\n    CtypeNode     ctype;\n#ifdef USE_CALL\n    CallNode      call;\n#endif\n    GimmickNode   gimmick;\n  } u;\n} Node;\n\n// OnigUChar:\ntypedef unsigned char  OnigUChar;\n\n// StrNode:\ntypedef struct {\n  NodeType node_type;\n  int status;\n\n  UChar* s;\n  UChar* end;\n  unsigned int flag;\n  int    capa;    /* (allocated size - 1) or 0: use buf[] */\n  UChar  buf[NODE_STRING_BUF_SIZE];\n}\n\n// _Node:\nstruct _Node\n\n// _Node:\ntypedef struct _Node {\n  union {\n    struct {\n      NodeType node_type;\n      int status;\n      struct _Node* body;\n    } base;\n\n    StrNode       str;\n    CClassNode    cclass;\n    QuantNode     quant;\n    EnclosureNode enclosure;\n    BackRefNode   backref;\n    AnchorNode    anchor;\n    ConsAltNode   cons;\n    CtypeNode     ctype;\n#ifdef USE_CALL\n    CallNode      call;\n#endif\n    GimmickNode   gimmick;\n  } u;\n}\n\n// regex_t:\ntypedef struct {\n  void*   onig;          /* Oniguruma regex_t*  */\n  size_t  re_nsub;\n  int     comp_options;\n}\n\n// Called Methods (top 10):\n// NODE_TYPE from src/regparse.h:\n#define NODE_TYPE(node)             ((node)->u.base.node_type) /* <=== src/regparse.h:79:79:NODE_TYPE:1 */ \n\n// is_good_case_fold_items_for_search from src/regcomp.c:\nstatic int /* <=== is_good_case_fold_items_for_search */ \nis_good_case_fold_items_for_search(OnigEncoding enc, int slen,\n                                   int n, OnigCaseFoldCodeItem items[])\n{\n  int i, len;\n  UChar buf[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n\n  for (i = 0; i < n; i++) {\n    OnigCaseFoldCodeItem* item = items + i;\n\n    if (item->code_len != 1)    return 0;\n    if (item->byte_len != slen) return 0;\n    len = ONIGENC_CODE_TO_MBC(enc, item->code[0], buf);\n    if (len != slen) return 0;\n  }\n\n  return 1;\n}\n\n// enclen from src/regenc.h:\n#define enclen(enc,p)          ONIGENC_MBC_ENC_LEN(enc,p) /* <=== src/regenc.h:78:78:enclen:2 */ \n\n// onig_node_new_str from src/regparse.c:\nextern Node* /* <=== onig_node_new_str */ \nonig_node_new_str(const UChar* s, const UChar* end)\n{\n  return node_new_str(s, end);\n}\n\n// ONIGENC_MBC_CASE_FOLD_MAXLEN from src/oniguruma.h:\n#define ONIGENC_MBC_CASE_FOLD_MAXLEN    18 /* <=== src/oniguruma.h:217:217:ONIGENC_MBC_CASE_FOLD_MAXLEN:0 */ \n\n// ENCLOSURE_ from src/regparse.h:\n#define ENCLOSURE_(node)   (&((node)->u.enclosure)) /* <=== src/regparse.h:87:87:ENCLOSURE_:1 */ \n\n// ONIGENC_GET_CASE_FOLD_CODES_MAX_NUM from src/oniguruma.h:\n#define ONIGENC_GET_CASE_FOLD_CODES_MAX_NUM      13 /* <=== src/oniguruma.h:96:96:ONIGENC_GET_CASE_FOLD_CODES_MAX_NUM:0 */ \n\n// bbuf_free from src/regparse.c:\nstatic void /* <=== bbuf_free */ \nbbuf_free(BBuf* bbuf)\n{\n  if (IS_NOT_NULL(bbuf)) {\n    if (IS_NOT_NULL(bbuf->p)) xfree(bbuf->p);\n    xfree(bbuf);\n  }\n}\n\n// ONIGENC_MBC_CASE_FOLD_MAXLEN from src/oniguruma.h:\n#define ONIGENC_MBC_CASE_FOLD_MAXLEN    18 /* <=== src/oniguruma.h:217:217:ONIGENC_MBC_CASE_FOLD_MAXLEN:0 */ \n\n// node_new from src/regparse.c:\nstatic Node* /* <=== node_new */ \nnode_new(void)\n{\n  Node* node;\n\n  node = (Node* )xmalloc(sizeof(Node));\n  xmemset(node, 0, sizeof(*node));\n\n#ifdef DEBUG_NODE_FREE\n  fprintf(stderr, \"node_new: %p\\n\", node);\n#endif\n  return node;\n}\n"
  },
  {
    "repository": "gpac",
    "cve_id": "CVE-2021-40575",
    "cwe_list": [
      "CWE-476"
    ],
    "commit_hash": "5f2c2a16d30229b6241f02fa28e3d6b810d64858",
    "short_hash": "5f2c2a16",
    "vulnerableMethods_before": [
      {
        "filename": "reframe_mpgvid.c",
        "method_name": "vulnerable_function",
        "raw_code": "GF_Err mpgviddmx_process(GF_Filter *filter)\n{\n\tGF_MPGVidDmxCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck, *dst_pck;\n\tu64 byte_offset;\n\ts64 vosh_start = -1;\n\ts64 vosh_end = -1;\n\tGF_Err e;\n\tchar *data;\n\tu8 *start;\n\tu32 pck_size;\n\ts32 remain;\n\n\t//always reparse duration\n\tif (!ctx->duration.num)\n\t\tmpgviddmx_check_dur(filter, ctx);\n\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!pck) {\n\t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_TRUE);\n\t\t\tif (ctx->opid)\n\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\tctx->src_pck = NULL;\n\t\t\treturn GF_EOS;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tdata = (char *) gf_filter_pck_get_data(pck, &pck_size);\n\tbyte_offset = gf_filter_pck_get_byte_offset(pck);\n\n\tstart = data;\n\tremain = pck_size;\n\n\t//input pid sets some timescale - we flushed pending data , update cts\n\tif (!ctx->resume_from && ctx->timescale) {\n\t\tu64 ts = gf_filter_pck_get_cts(pck);\n\t\tif (ts != GF_FILTER_NO_TS) {\n\t\t\tif (!ctx->cts || !ctx->recompute_cts)\n\t\t\t\tctx->cts = ts;\n\t\t}\n\t\tts = gf_filter_pck_get_dts(pck);\n\t\tif (ts != GF_FILTER_NO_TS) {\n\t\t\tif (!ctx->dts || !ctx->recompute_cts)\n\t\t\t\tctx->dts = ts;\n\n\t\t\tif (!ctx->prev_dts) ctx->prev_dts = ts;\n\t\t\telse if (ctx->prev_dts != ts) {\n\t\t\t\tu64 diff = ts;\n\t\t\t\tdiff -= ctx->prev_dts;\n\t\t\t\tif (!ctx->cur_fps.den) ctx->cur_fps.den = (u32) diff;\n\t\t\t\telse if (ctx->cur_fps.den > diff)\n\t\t\t\t\tctx->cur_fps.den = (u32) diff;\n\t\t\t}\n\t\t}\n\t\tgf_filter_pck_get_framing(pck, &ctx->input_is_au_start, &ctx->input_is_au_end);\n\t\t//this will force CTS recomput of each frame\n\t\tif (ctx->recompute_cts) ctx->input_is_au_start = GF_FALSE;\n\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\tctx->src_pck = pck;\n\t\tgf_filter_pck_ref_props(&ctx->src_pck);\n\t}\n\n\t//we stored some data to find the complete vosh, aggregate this packet with current one\n\tif (!ctx->resume_from && ctx->hdr_store_size) {\n\t\tif (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size) {\n\t\t\tctx->hdr_store_alloc = ctx->hdr_store_size + pck_size;\n\t\t\tctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);\n\t\t}\n\t\tmemcpy(ctx->hdr_store + ctx->hdr_store_size, data, sizeof(char)*pck_size);\n\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\tif (byte_offset >= ctx->hdr_store_size)\n\t\t\t\tbyte_offset -= ctx->hdr_store_size;\n\t\t\telse\n\t\t\t\tbyte_offset = GF_FILTER_NO_BO;\n\t\t}\n\t\tctx->hdr_store_size += pck_size;\n\t\tstart = data = ctx->hdr_store;\n\t\tremain = pck_size = ctx->hdr_store_size;\n\t}\n\n\tif (ctx->resume_from) {\n\t\tif (gf_filter_pid_would_block(ctx->opid))\n\t\t\treturn GF_OK;\n\n\t\t//resume from data copied internally\n\t\tif (ctx->hdr_store_size) {\n\t\t\tassert(ctx->resume_from <= ctx->hdr_store_size);\n\t\t\tstart = data = ctx->hdr_store + ctx->resume_from;\n\t\t\tremain = pck_size = ctx->hdr_store_size - ctx->resume_from;\n\t\t} else {\n\t\t\tassert(remain >= (s32) ctx->resume_from);\n\t\t\tstart += ctx->resume_from;\n\t\t\tremain -= ctx->resume_from;\n\t\t}\n\t\tctx->resume_from = 0;\n\t}\n\n\tif (!ctx->bs) {\n\t\tctx->bs = gf_bs_new(start, remain, GF_BITSTREAM_READ);\n\t} else {\n\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t}\n\tif (!ctx->vparser) {\n\t\tctx->vparser = gf_m4v_parser_bs_new(ctx->bs, ctx->is_mpg12);\n\t}\n\n\n\twhile (remain) {\n\t\tBool full_frame;\n\t\tu8 *pck_data;\n\t\ts32 current;\n\t\tu8 sc_type, forced_sc_type=0;\n\t\tBool sc_type_forced = GF_FALSE;\n\t\tBool skip_pck = GF_FALSE;\n\t\tu8 ftype;\n\t\tu32 tinc;\n\t\tu64 size=0;\n\t\tu64 fstart;\n\t\tBool is_coded;\n\t\tu32 bytes_from_store = 0;\n\t\tu32 hdr_offset = 0;\n\t\tBool copy_last_bytes = GF_FALSE;\n\n\t\t//not enough bytes to parse start code\n\t\tif (remain<5) {\n\t\t\tmemcpy(ctx->hdr_store, start, remain);\n\t\t\tctx->bytes_in_header = remain;\n\t\t\tbreak;\n\t\t}\n\t\tcurrent = -1;\n\n\t\t//we have some potential bytes of a start code in the store, copy some more bytes and check if valid start code.\n\t\t//if not, dispatch these bytes as continuation of the data\n\t\tif (ctx->bytes_in_header) {\n\n\t\t\tmemcpy(ctx->hdr_store + ctx->bytes_in_header, start, 8 - ctx->bytes_in_header);\n\t\t\tcurrent = mpgviddmx_next_start_code(ctx->hdr_store, 8);\n\n\t\t\t//no start code in stored buffer\n\t\t\tif ((current<0) || (current >= (s32) ctx->bytes_in_header) )  {\n\t\t\t\tif (ctx->opid) {\n\t\t\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->bytes_in_header, &pck_data);\n\t\t\t\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\t\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t\t\t\tgf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);\n\t\t\t\t\tgf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);\n\t\t\t\t\tmemcpy(pck_data, ctx->hdr_store, ctx->bytes_in_header);\n\t\t\t\t\tgf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);\n\n\t\t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset - ctx->bytes_in_header);\n\t\t\t\t\t}\n\n\t\t\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\t\t\t\t}\n\n\t\t\t\tif (current<0) current = -1;\n\t\t\t\telse current -= ctx->bytes_in_header;\n\t\t\t\tctx->bytes_in_header = 0;\n\t\t\t} else {\n\t\t\t\t//we have a valid start code, check which byte in our store or in the packet payload is the start code type\n\t\t\t\t//and remember its location to reinit the parser from there\n\t\t\t\thdr_offset = 4 - ctx->bytes_in_header + current;\n\t\t\t\t//bytes still to dispatch\n\t\t\t\tbytes_from_store = ctx->bytes_in_header;\n\t\t\t\tctx->bytes_in_header = 0;\n\t\t\t\tif (!hdr_offset) {\n\t\t\t\t\tforced_sc_type = ctx->hdr_store[current+3];\n\t\t\t\t} else {\n\t\t\t\t\tforced_sc_type = start[hdr_offset-1];\n\t\t\t\t}\n\t\t\t\tsc_type_forced = GF_TRUE;\n\t\t\t}\n\t\t}\n\t\t//no starcode in store, look for startcode in packet\n\t\tif (current == -1) {\n\t\t\t//locate next start code\n\t\t\tcurrent = mpgviddmx_next_start_code(start, remain);\n\t\t\t//no start code, dispatch the block\n\t\t\tif (current<0) {\n\t\t\t\tu8 b3, b2, b1;\n\t\t\t\tif (! ctx->frame_started) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[MPGVid] no start code in block and no frame started, discarding data\\n\" ));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsize = remain;\n\t\t\t\tb3 = start[remain-3];\n\t\t\t\tb2 = start[remain-2];\n\t\t\t\tb1 = start[remain-1];\n\t\t\t\t//we may have a startcode at the end of the packet, store it and don't dispatch the last 3 bytes !\n\t\t\t\tif (!b1 || !b2 || !b3) {\n\t\t\t\t\tcopy_last_bytes = GF_TRUE;\n\t\t\t\t\tassert(size >= 3);\n\t\t\t\t\tsize -= 3;\n\t\t\t\t\tctx->bytes_in_header = 3;\n\t\t\t\t}\n\n\t\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data);\n\t\t\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t\t\tmemcpy(pck_data, start, (size_t) size);\n\t\t\t\tgf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);\n\t\t\t\tgf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);\n\t\t\t\tgf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);\n\n\t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset);\n\t\t\t\t}\n\n\t\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\t\t\t\tif (copy_last_bytes) {\n\t\t\t\t\tmemcpy(ctx->hdr_store, start+remain-3, 3);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tassert(current>=0);\n\n\t\t//if we are in the middle of parsing the vosh, skip over bytes remaining from previous obj not parsed\n\t\tif ((vosh_start>=0) && current) {\n\t\t\tassert(remain>=current);\n\t\t\tstart += current;\n\t\t\tremain -= current;\n\t\t\tcurrent = 0;\n\t\t}\n\t\t//also skip if no output pid\n\t\tif (!ctx->opid && current) {\n\t\t\tassert(remain>=current);\n\t\t\tstart += current;\n\t\t\tremain -= current;\n\t\t\tcurrent = 0;\n\t\t}\n\t\t//dispatch remaining bytes\n\t\tif (current>0) {\n\t\t\t//flush remaining\n\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, current, &pck_data);\n\t\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t\tgf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);\n\t\t\tgf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);\n\t\t\tgf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_TRUE);\n\t\t\t//bytes were partly in store, partly in packet\n\t\t\tif (bytes_from_store) {\n\t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset - bytes_from_store);\n\t\t\t\t}\n\t\t\t\tassert(bytes_from_store>=(u32) current);\n\t\t\t\tbytes_from_store -= current;\n\t\t\t\tmemcpy(pck_data, ctx->hdr_store, current);\n\t\t\t} else {\n\t\t\t\t//bytes were only in packet\n\t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset);\n\t\t\t\t}\n\t\t\t\tmemcpy(pck_data, start, current);\n\t\t\t\tassert(remain>=current);\n\t\t\t\tstart += current;\n\t\t\t\tremain -= current;\n\t\t\t\tcurrent = 0;\n\t\t\t}\n\t\t\tgf_filter_pck_set_carousel_version(dst_pck, 1);\n\n\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\t\t}\n\n\t\t//parse headers\n\n\t\t//we have a start code loaded, eg the data packet does not have a full start code at the beginning\n\t\tif (sc_type_forced) {\n\t\t\tgf_bs_reassign_buffer(ctx->bs, start + hdr_offset, remain - hdr_offset);\n\t\t\tsc_type = forced_sc_type;\n\t\t} else {\n\t\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t\t\tgf_bs_read_int(ctx->bs, 24);\n\t\t\tsc_type = gf_bs_read_int(ctx->bs, 8);\n\t\t}\n\n\t\tif (ctx->is_mpg12) {\n\t\t\tswitch (sc_type) {\n\t\t\tcase M2V_SEQ_START_CODE:\n\t\t\tcase M2V_EXT_START_CODE:\n\t\t\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t\t\t\te = gf_m4v_parse_config(ctx->vparser, &ctx->dsi);\n\t\t\t\t//not enough data, accumulate until we can parse the full header\n\t\t\t\tif (e==GF_EOS) {\n\t\t\t\t\tif (vosh_start<0) vosh_start = 0;\n\t\t\t\t\tif (data == ctx->hdr_store) {\n\t\t\t\t\t\tmemmove(ctx->hdr_store, start, remain);\n\t\t\t\t\t\tctx->hdr_store_size = remain;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {\n\t\t\t\t\t\t\tctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - vosh_start);\n\t\t\t\t\t\t\tctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );\n\t\t\t\t\t\tctx->hdr_store_size += pck_size - (u32) vosh_start;\n\t\t\t\t\t}\n\t\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t} else if (e != GF_OK) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MPGVid] Failed to parse VOS header: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\t} else {\n\t\t\t\t\tmpgviddmx_check_pid(filter, ctx, 0, NULL);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase M2V_PIC_START_CODE:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t} else {\n\t\t\tu8 PL;\n\t\t\tswitch (sc_type) {\n\t\t\tcase M4V_VOS_START_CODE:\n\t\t\t\tctx->dsi.VideoPL = (u8) gf_bs_read_u8(ctx->bs);\n\t\t\t\tvosh_start = start - (u8 *)data;\n\t\t\t\tskip_pck = GF_TRUE;\n\t\t\t\tassert(remain>=5);\n\t\t\t\tstart += 5;\n\t\t\t\tremain -= 5;\n\t\t\t\tbreak;\n\t\t\tcase M4V_VOL_START_CODE:\n\t\t\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t\t\t\tPL = ctx->dsi.VideoPL;\n\t\t\t\te = gf_m4v_parse_config(ctx->vparser, &ctx->dsi);\n\t\t\t\tctx->dsi.VideoPL = PL;\n\t\t\t\t//not enough data, accumulate until we can parse the full header\n\t\t\t\tif (e==GF_EOS) {\n\t\t\t\t\tif (vosh_start<0) vosh_start = 0;\n\t\t\t\t\tif (data == ctx->hdr_store) {\n\t\t\t\t\t\tmemmove(ctx->hdr_store, start, remain);\n\t\t\t\t\t\tctx->hdr_store_size = remain;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {\n\t\t\t\t\t\t\tctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - (u32) vosh_start);\n\t\t\t\t\t\t\tctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );\n\t\t\t\t\t\tctx->hdr_store_size += pck_size - (u32) vosh_start;\n\t\t\t\t\t}\n\t\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t} else if (e != GF_OK) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MPGVid] Failed to parse VOS header: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\t} else {\n\t\t\t\t\tu32 obj_size = (u32) gf_m4v_get_object_start(ctx->vparser);\n\t\t\t\t\tif (vosh_start<0) vosh_start = 0;\n\t\t\t\t\tvosh_end = start - (u8 *)data + obj_size;\n\t\t\t\t\tvosh_end -= vosh_start;\n\t\t\t\t\tmpgviddmx_check_pid(filter, ctx,(u32)  vosh_end, data+vosh_start);\n\t\t\t\t\tskip_pck = GF_TRUE;\n\t\t\t\t\tassert(remain>=(s32) obj_size);\n\t\t\t\t\tstart += obj_size;\n\t\t\t\t\tremain -= obj_size;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase M4V_VOP_START_CODE:\n\t\t\tcase M4V_GOV_START_CODE:\n\t\t\t\tbreak;\n\n\t\t\tcase M4V_VO_START_CODE:\n\t\t\tcase M4V_VISOBJ_START_CODE:\n\t\t\tdefault:\n\t\t\t\tif (vosh_start>=0) {\n\t\t\t\t\tskip_pck = GF_TRUE;\n\t\t\t\t\tassert(remain>=4);\n\t\t\t\t\tstart += 4;\n\t\t\t\t\tremain -= 4;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (skip_pck) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!ctx->opid) {\n\t\t\tassert(remain>=4);\n\t\t\tstart += 4;\n\t\t\tremain -= 4;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->resume_from = (u32) ((char *)start -  (char *)data);\n\t\t\treturn GF_OK;\n\t\t}\n\t\t//at this point, we no longer reaggregate packets\n\t\tctx->hdr_store_size = 0;\n\n\t\tif (ctx->in_seek) {\n\t\t\tu64 nb_frames_at_seek = (u64) (ctx->start_range * ctx->cur_fps.num);\n\t\t\tif (ctx->cts + ctx->cur_fps.den >= nb_frames_at_seek) {\n\t\t\t\t//u32 samples_to_discard = (ctx->cts + ctx->dts_inc) - nb_samples_at_seek;\n\t\t\t\tctx->in_seek = GF_FALSE;\n\t\t\t}\n\t\t}\n\t\t//may happen that after all our checks, only 4 bytes are left, continue to store these 4 bytes\n\t\tif (remain<5)\n\t\t\tcontinue;\n\n\t\t//good to go\n\t\tgf_m4v_parser_reset(ctx->vparser, sc_type_forced ? forced_sc_type + 1 : 0);\n\t\tsize = 0;\n\t\te = gf_m4v_parse_frame(ctx->vparser, &ctx->dsi, &ftype, &tinc, &size, &fstart, &is_coded);\n\t\t//true if we strip VO and VISOBJ assert(!fstart);\n\n\t\t//we skipped bytes already in store + end of start code present in packet, so the size of the first object\n\t\t//needs adjustement\n\t\tif (bytes_from_store) {\n\t\t\tsize += bytes_from_store + hdr_offset;\n\t\t}\n\n\t\tif ((e == GF_EOS) && !ctx->input_is_au_end) {\n\t\t\tu8 b3 = start[remain-3];\n\t\t\tu8 b2 = start[remain-2];\n\t\t\tu8 b1 = start[remain-1];\n\n\t\t\t//we may have a startcode at the end of the packet, store it and don't dispatch the last 3 bytes !\n\t\t\tif (!b1 || !b2 || !b3) {\n\t\t\t\tcopy_last_bytes = GF_TRUE;\n\t\t\t\tassert(size >= 3);\n\t\t\t\tsize -= 3;\n\t\t\t\tctx->bytes_in_header = 3;\n\t\t\t}\n\t\t\tfull_frame = GF_FALSE;\n\t\t} else {\n\t\t\tfull_frame = GF_TRUE;\n\t\t}\n\n\t\tif (!is_coded) {\n\t\t\t/*if prev is B and we're parsing a packed bitstream discard n-vop*/\n\t\t\tif (ctx->forced_packed && ctx->b_frames) {\n\t\t\t\tctx->is_packed = GF_TRUE;\n\t\t\t\tassert(remain>=size);\n\t\t\t\tstart += size;\n\t\t\t\tremain -= (s32) size;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*policy is to import at variable frame rate, skip*/\n\t\t\tif (ctx->vfr) {\n\t\t\t\tctx->is_vfr = GF_TRUE;\n\t\t\t\tmpgviddmx_update_time(ctx);\n\t\t\t\tassert(remain>=size);\n\t\t\t\tstart += size;\n\t\t\t\tremain -= (s32) size;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*policy is to keep non coded frame (constant frame rate), add*/\n\t\t}\n\n\t\tif (ftype==2) {\n\t\t\t//count number of B-frames since last ref\n\t\t\tctx->b_frames++;\n\t\t\tctx->nb_b++;\n\t\t} else {\n\t\t\t//flush all pending packets\n\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_FALSE);\n\t\t\t//remeber the CTS of the last ref\n\t\t\tctx->last_ref_cts = ctx->cts;\n\t\t\tif (ctx->max_b < ctx->b_frames) ctx->max_b = ctx->b_frames;\n\t\t\t\n\t\t\tctx->b_frames = 0;\n\t\t\tif (ftype)\n\t\t\t\tctx->nb_p++;\n\t\t\telse\n\t\t\t\tctx->nb_i++;\n\t\t}\n\t\tctx->nb_frames++;\n\n\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data);\n\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t//bytes come from both our store and the data packet\n\t\tif (bytes_from_store) {\n\t\t\tmemcpy(pck_data, ctx->hdr_store+current, bytes_from_store);\n\t\t\tassert(size >= bytes_from_store);\n\t\t\tsize -= bytes_from_store;\n\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset - bytes_from_store);\n\t\t\t}\n\t\t\tmemcpy(pck_data + bytes_from_store, start, (size_t) size);\n\t\t} else {\n\t\t\t//bytes only come the data packet\n\t\t\tmemcpy(pck_data, start, (size_t) size);\n\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset + start - (u8 *) data);\n\t\t\t}\n\t\t}\n\t\tassert(pck_data[0] == 0);\n\t\tassert(pck_data[1] == 0);\n\t\tassert(pck_data[2] == 0x01);\n\n\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, (full_frame || ctx->input_is_au_end) ? GF_TRUE : GF_FALSE);\n\t\tgf_filter_pck_set_cts(dst_pck, ctx->cts);\n\t\tgf_filter_pck_set_dts(dst_pck, ctx->dts);\n\t\tif (ctx->input_is_au_start) {\n\t\t\tctx->input_is_au_start = GF_FALSE;\n\t\t} else {\n\t\t\t//we use the carousel flag temporarly to indicate the cts must be recomputed\n\t\t\tgf_filter_pck_set_carousel_version(dst_pck, 1);\n\t\t}\n\t\tgf_filter_pck_set_sap(dst_pck, ftype ? GF_FILTER_SAP_NONE : GF_FILTER_SAP_1);\n\t\tgf_filter_pck_set_duration(dst_pck, ctx->cur_fps.den);\n\t\tif (ctx->in_seek) gf_filter_pck_set_seek_flag(dst_pck, GF_TRUE);\n\t\tctx->frame_started = GF_TRUE;\n\n\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\n\t\tmpgviddmx_update_time(ctx);\n\n\t\tif (!full_frame) {\n\t\t\tif (copy_last_bytes) {\n\t\t\t\tmemcpy(ctx->hdr_store, start+remain-3, 3);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tassert(remain>=size);\n\t\tstart += size;\n\t\tremain -= (s32) size;\n\t}\n\tgf_filter_pid_drop_packet(ctx->ipid);\n\n\treturn GF_OK;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "None",
        "method_name": "fixed_function",
        "raw_code": "GF_Err mpgviddmx_process(GF_Filter *filter)\n{\n\tGF_MPGVidDmxCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck, *dst_pck;\n\tu64 byte_offset;\n\ts64 vosh_start = -1;\n\ts64 vosh_end = -1;\n\tGF_Err e;\n\tchar *data;\n\tu8 *start;\n\tu32 pck_size;\n\ts32 remain;\n\n\t//always reparse duration\n\tif (!ctx->duration.num)\n\t\tmpgviddmx_check_dur(filter, ctx);\n\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!pck) {\n\t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_TRUE);\n\t\t\tif (ctx->opid)\n\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\tctx->src_pck = NULL;\n\t\t\treturn GF_EOS;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tdata = (char *) gf_filter_pck_get_data(pck, &pck_size);\n\tbyte_offset = gf_filter_pck_get_byte_offset(pck);\n\n\tstart = data;\n\tremain = pck_size;\n\n\t//input pid sets some timescale - we flushed pending data , update cts\n\tif (!ctx->resume_from && ctx->timescale) {\n\t\tu64 ts = gf_filter_pck_get_cts(pck);\n\t\tif (ts != GF_FILTER_NO_TS) {\n\t\t\tif (!ctx->cts || !ctx->recompute_cts)\n\t\t\t\tctx->cts = ts;\n\t\t}\n\t\tts = gf_filter_pck_get_dts(pck);\n\t\tif (ts != GF_FILTER_NO_TS) {\n\t\t\tif (!ctx->dts || !ctx->recompute_cts)\n\t\t\t\tctx->dts = ts;\n\n\t\t\tif (!ctx->prev_dts) ctx->prev_dts = ts;\n\t\t\telse if (ctx->prev_dts != ts) {\n\t\t\t\tu64 diff = ts;\n\t\t\t\tdiff -= ctx->prev_dts;\n\t\t\t\tif (!ctx->cur_fps.den) ctx->cur_fps.den = (u32) diff;\n\t\t\t\telse if (ctx->cur_fps.den > diff)\n\t\t\t\t\tctx->cur_fps.den = (u32) diff;\n\t\t\t}\n\t\t}\n\t\tgf_filter_pck_get_framing(pck, &ctx->input_is_au_start, &ctx->input_is_au_end);\n\t\t//this will force CTS recomput of each frame\n\t\tif (ctx->recompute_cts) ctx->input_is_au_start = GF_FALSE;\n\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\tctx->src_pck = pck;\n\t\tgf_filter_pck_ref_props(&ctx->src_pck);\n\t}\n\n\t//we stored some data to find the complete vosh, aggregate this packet with current one\n\tif (!ctx->resume_from && ctx->hdr_store_size) {\n\t\tif (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size) {\n\t\t\tctx->hdr_store_alloc = ctx->hdr_store_size + pck_size;\n\t\t\tctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);\n\t\t}\n\t\tmemcpy(ctx->hdr_store + ctx->hdr_store_size, data, sizeof(char)*pck_size);\n\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\tif (byte_offset >= ctx->hdr_store_size)\n\t\t\t\tbyte_offset -= ctx->hdr_store_size;\n\t\t\telse\n\t\t\t\tbyte_offset = GF_FILTER_NO_BO;\n\t\t}\n\t\tctx->hdr_store_size += pck_size;\n\t\tstart = data = ctx->hdr_store;\n\t\tremain = pck_size = ctx->hdr_store_size;\n\t}\n\n\tif (ctx->resume_from) {\n\t\tif (gf_filter_pid_would_block(ctx->opid))\n\t\t\treturn GF_OK;\n\n\t\t//resume from data copied internally\n\t\tif (ctx->hdr_store_size) {\n\t\t\tassert(ctx->resume_from <= ctx->hdr_store_size);\n\t\t\tstart = data = ctx->hdr_store + ctx->resume_from;\n\t\t\tremain = pck_size = ctx->hdr_store_size - ctx->resume_from;\n\t\t} else {\n\t\t\tassert(remain >= (s32) ctx->resume_from);\n\t\t\tstart += ctx->resume_from;\n\t\t\tremain -= ctx->resume_from;\n\t\t}\n\t\tctx->resume_from = 0;\n\t}\n\n\tif (!ctx->bs) {\n\t\tctx->bs = gf_bs_new(start, remain, GF_BITSTREAM_READ);\n\t} else {\n\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t}\n\tif (!ctx->vparser) {\n\t\tctx->vparser = gf_m4v_parser_bs_new(ctx->bs, ctx->is_mpg12);\n\t}\n\n\n\twhile (remain) {\n\t\tBool full_frame;\n\t\tu8 *pck_data;\n\t\ts32 current;\n\t\tu8 sc_type, forced_sc_type=0;\n\t\tBool sc_type_forced = GF_FALSE;\n\t\tBool skip_pck = GF_FALSE;\n\t\tu8 ftype;\n\t\tu32 tinc;\n\t\tu64 size=0;\n\t\tu64 fstart;\n\t\tBool is_coded;\n\t\tu32 bytes_from_store = 0;\n\t\tu32 hdr_offset = 0;\n\t\tBool copy_last_bytes = GF_FALSE;\n\n\t\t//not enough bytes to parse start code\n\t\tif (remain<5) {\n\t\t\tmemcpy(ctx->hdr_store, start, remain);\n\t\t\tctx->bytes_in_header = remain;\n\t\t\tbreak;\n\t\t}\n\t\tcurrent = -1;\n\n\t\t//we have some potential bytes of a start code in the store, copy some more bytes and check if valid start code.\n\t\t//if not, dispatch these bytes as continuation of the data\n\t\tif (ctx->bytes_in_header) {\n\n\t\t\tmemcpy(ctx->hdr_store + ctx->bytes_in_header, start, 8 - ctx->bytes_in_header);\n\t\t\tcurrent = mpgviddmx_next_start_code(ctx->hdr_store, 8);\n\n\t\t\t//no start code in stored buffer\n\t\t\tif ((current<0) || (current >= (s32) ctx->bytes_in_header) )  {\n\t\t\t\tif (ctx->opid) {\n\t\t\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->bytes_in_header, &pck_data);\n\t\t\t\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\t\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t\t\t\tgf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);\n\t\t\t\t\tgf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);\n\t\t\t\t\tmemcpy(pck_data, ctx->hdr_store, ctx->bytes_in_header);\n\t\t\t\t\tgf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);\n\n\t\t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset - ctx->bytes_in_header);\n\t\t\t\t\t}\n\n\t\t\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\t\t\t\t}\n\n\t\t\t\tif (current<0) current = -1;\n\t\t\t\telse current -= ctx->bytes_in_header;\n\t\t\t\tctx->bytes_in_header = 0;\n\t\t\t} else {\n\t\t\t\t//we have a valid start code, check which byte in our store or in the packet payload is the start code type\n\t\t\t\t//and remember its location to reinit the parser from there\n\t\t\t\thdr_offset = 4 - ctx->bytes_in_header + current;\n\t\t\t\t//bytes still to dispatch\n\t\t\t\tbytes_from_store = ctx->bytes_in_header;\n\t\t\t\tctx->bytes_in_header = 0;\n\t\t\t\tif (!hdr_offset) {\n\t\t\t\t\tforced_sc_type = ctx->hdr_store[current+3];\n\t\t\t\t} else {\n\t\t\t\t\tforced_sc_type = start[hdr_offset-1];\n\t\t\t\t}\n\t\t\t\tsc_type_forced = GF_TRUE;\n\t\t\t}\n\t\t}\n\t\t//no starcode in store, look for startcode in packet\n\t\tif (current == -1) {\n\t\t\t//locate next start code\n\t\t\tcurrent = mpgviddmx_next_start_code(start, remain);\n\t\t\t//no start code, dispatch the block\n\t\t\tif (current<0) {\n\t\t\t\tu8 b3, b2, b1;\n\t\t\t\tif (! ctx->frame_started) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[MPGVid] no start code in block and no frame started, discarding data\\n\" ));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsize = remain;\n\t\t\t\tb3 = start[remain-3];\n\t\t\t\tb2 = start[remain-2];\n\t\t\t\tb1 = start[remain-1];\n\t\t\t\t//we may have a startcode at the end of the packet, store it and don't dispatch the last 3 bytes !\n\t\t\t\tif (!b1 || !b2 || !b3) {\n\t\t\t\t\tcopy_last_bytes = GF_TRUE;\n\t\t\t\t\tassert(size >= 3);\n\t\t\t\t\tsize -= 3;\n\t\t\t\t\tctx->bytes_in_header = 3;\n\t\t\t\t}\n\n\t\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data);\n\t\t\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t\t\tmemcpy(pck_data, start, (size_t) size);\n\t\t\t\tgf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE);\n\t\t\t\tgf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);\n\t\t\t\tgf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);\n\n\t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset);\n\t\t\t\t}\n\n\t\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\t\t\t\tif (copy_last_bytes) {\n\t\t\t\t\tmemcpy(ctx->hdr_store, start+remain-3, 3);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tassert(current>=0);\n\n\t\t//if we are in the middle of parsing the vosh, skip over bytes remaining from previous obj not parsed\n\t\tif ((vosh_start>=0) && current) {\n\t\t\tassert(remain>=current);\n\t\t\tstart += current;\n\t\t\tremain -= current;\n\t\t\tcurrent = 0;\n\t\t}\n\t\t//also skip if no output pid\n\t\tif (!ctx->opid && current) {\n\t\t\tassert(remain>=current);\n\t\t\tstart += current;\n\t\t\tremain -= current;\n\t\t\tcurrent = 0;\n\t\t}\n\t\t//dispatch remaining bytes\n\t\tif (current>0) {\n\t\t\t//flush remaining\n\t\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, current, &pck_data);\n\t\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t\tgf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS);\n\t\t\tgf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS);\n\t\t\tgf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_TRUE);\n\t\t\t//bytes were partly in store, partly in packet\n\t\t\tif (bytes_from_store) {\n\t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset - bytes_from_store);\n\t\t\t\t}\n\t\t\t\tassert(bytes_from_store>=(u32) current);\n\t\t\t\tbytes_from_store -= current;\n\t\t\t\tmemcpy(pck_data, ctx->hdr_store, current);\n\t\t\t} else {\n\t\t\t\t//bytes were only in packet\n\t\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset);\n\t\t\t\t}\n\t\t\t\tmemcpy(pck_data, start, current);\n\t\t\t\tassert(remain>=current);\n\t\t\t\tstart += current;\n\t\t\t\tremain -= current;\n\t\t\t\tcurrent = 0;\n\t\t\t}\n\t\t\tgf_filter_pck_set_carousel_version(dst_pck, 1);\n\n\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\t\t}\n\n\t\t//not enough bytes to parse start code\n\t\tif (remain<5) {\n\t\t\tmemcpy(ctx->hdr_store, start, remain);\n\t\t\tctx->bytes_in_header = remain;\n\t\t\tbreak;\n\t\t}\n\n\t\t//parse headers\n\t\t//we have a start code loaded, eg the data packet does not have a full start code at the beginning\n\t\tif (sc_type_forced) {\n\t\t\tgf_bs_reassign_buffer(ctx->bs, start + hdr_offset, remain - hdr_offset);\n\t\t\tsc_type = forced_sc_type;\n\t\t} else {\n\t\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t\t\tgf_bs_read_int(ctx->bs, 24);\n\t\t\tsc_type = gf_bs_read_int(ctx->bs, 8);\n\t\t}\n\n\t\tif (ctx->is_mpg12) {\n\t\t\tswitch (sc_type) {\n\t\t\tcase M2V_SEQ_START_CODE:\n\t\t\tcase M2V_EXT_START_CODE:\n\t\t\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t\t\t\te = gf_m4v_parse_config(ctx->vparser, &ctx->dsi);\n\t\t\t\t//not enough data, accumulate until we can parse the full header\n\t\t\t\tif (e==GF_EOS) {\n\t\t\t\t\tif (vosh_start<0) vosh_start = 0;\n\t\t\t\t\tif (data == ctx->hdr_store) {\n\t\t\t\t\t\tmemmove(ctx->hdr_store, start, remain);\n\t\t\t\t\t\tctx->hdr_store_size = remain;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {\n\t\t\t\t\t\t\tctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - vosh_start);\n\t\t\t\t\t\t\tctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );\n\t\t\t\t\t\tctx->hdr_store_size += pck_size - (u32) vosh_start;\n\t\t\t\t\t}\n\t\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t} else if (e != GF_OK) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MPGVid] Failed to parse VOS header: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\t} else {\n\t\t\t\t\tmpgviddmx_check_pid(filter, ctx, 0, NULL);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase M2V_PIC_START_CODE:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t} else {\n\t\t\tu8 PL;\n\t\t\tswitch (sc_type) {\n\t\t\tcase M4V_VOS_START_CODE:\n\t\t\t\tctx->dsi.VideoPL = (u8) gf_bs_read_u8(ctx->bs);\n\t\t\t\tvosh_start = start - (u8 *)data;\n\t\t\t\tskip_pck = GF_TRUE;\n\t\t\t\tassert(remain>=5);\n\t\t\t\tstart += 5;\n\t\t\t\tremain -= 5;\n\t\t\t\tbreak;\n\t\t\tcase M4V_VOL_START_CODE:\n\t\t\t\tgf_bs_reassign_buffer(ctx->bs, start, remain);\n\t\t\t\tPL = ctx->dsi.VideoPL;\n\t\t\t\te = gf_m4v_parse_config(ctx->vparser, &ctx->dsi);\n\t\t\t\tctx->dsi.VideoPL = PL;\n\t\t\t\t//not enough data, accumulate until we can parse the full header\n\t\t\t\tif (e==GF_EOS) {\n\t\t\t\t\tif (vosh_start<0) vosh_start = 0;\n\t\t\t\t\tif (data == ctx->hdr_store) {\n\t\t\t\t\t\tmemmove(ctx->hdr_store, start, remain);\n\t\t\t\t\t\tctx->hdr_store_size = remain;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) {\n\t\t\t\t\t\t\tctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - (u32) vosh_start);\n\t\t\t\t\t\t\tctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemcpy(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) );\n\t\t\t\t\t\tctx->hdr_store_size += pck_size - (u32) vosh_start;\n\t\t\t\t\t}\n\t\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t} else if (e != GF_OK) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[MPGVid] Failed to parse VOS header: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\t} else {\n\t\t\t\t\tu32 obj_size = (u32) gf_m4v_get_object_start(ctx->vparser);\n\t\t\t\t\tif (vosh_start<0) vosh_start = 0;\n\t\t\t\t\tvosh_end = start - (u8 *)data + obj_size;\n\t\t\t\t\tvosh_end -= vosh_start;\n\t\t\t\t\tmpgviddmx_check_pid(filter, ctx,(u32)  vosh_end, data+vosh_start);\n\t\t\t\t\tskip_pck = GF_TRUE;\n\t\t\t\t\tassert(remain>=(s32) obj_size);\n\t\t\t\t\tstart += obj_size;\n\t\t\t\t\tremain -= obj_size;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase M4V_VOP_START_CODE:\n\t\t\tcase M4V_GOV_START_CODE:\n\t\t\t\tbreak;\n\n\t\t\tcase M4V_VO_START_CODE:\n\t\t\tcase M4V_VISOBJ_START_CODE:\n\t\t\tdefault:\n\t\t\t\tif (vosh_start>=0) {\n\t\t\t\t\tskip_pck = GF_TRUE;\n\t\t\t\t\tassert(remain>=4);\n\t\t\t\t\tstart += 4;\n\t\t\t\t\tremain -= 4;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (skip_pck) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!ctx->opid) {\n\t\t\tassert(remain>=4);\n\t\t\tstart += 4;\n\t\t\tremain -= 4;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->resume_from = (u32) ((char *)start -  (char *)data);\n\t\t\treturn GF_OK;\n\t\t}\n\t\t//at this point, we no longer reaggregate packets\n\t\tctx->hdr_store_size = 0;\n\n\t\tif (ctx->in_seek) {\n\t\t\tu64 nb_frames_at_seek = (u64) (ctx->start_range * ctx->cur_fps.num);\n\t\t\tif (ctx->cts + ctx->cur_fps.den >= nb_frames_at_seek) {\n\t\t\t\t//u32 samples_to_discard = (ctx->cts + ctx->dts_inc) - nb_samples_at_seek;\n\t\t\t\tctx->in_seek = GF_FALSE;\n\t\t\t}\n\t\t}\n\t\t//may happen that after all our checks, only 4 bytes are left, continue to store these 4 bytes\n\t\tif (remain<5)\n\t\t\tcontinue;\n\n\t\t//good to go\n\t\tgf_m4v_parser_reset(ctx->vparser, sc_type_forced ? forced_sc_type + 1 : 0);\n\t\tsize = 0;\n\t\te = gf_m4v_parse_frame(ctx->vparser, &ctx->dsi, &ftype, &tinc, &size, &fstart, &is_coded);\n\t\t//true if we strip VO and VISOBJ assert(!fstart);\n\n\t\t//we skipped bytes already in store + end of start code present in packet, so the size of the first object\n\t\t//needs adjustement\n\t\tif (bytes_from_store) {\n\t\t\tsize += bytes_from_store + hdr_offset;\n\t\t}\n\n\t\tif ((e == GF_EOS) && !ctx->input_is_au_end) {\n\t\t\tu8 b3 = start[remain-3];\n\t\t\tu8 b2 = start[remain-2];\n\t\t\tu8 b1 = start[remain-1];\n\n\t\t\t//we may have a startcode at the end of the packet, store it and don't dispatch the last 3 bytes !\n\t\t\tif (!b1 || !b2 || !b3) {\n\t\t\t\tcopy_last_bytes = GF_TRUE;\n\t\t\t\tassert(size >= 3);\n\t\t\t\tsize -= 3;\n\t\t\t\tctx->bytes_in_header = 3;\n\t\t\t}\n\t\t\tfull_frame = GF_FALSE;\n\t\t} else {\n\t\t\tfull_frame = GF_TRUE;\n\t\t}\n\n\t\tif (!is_coded) {\n\t\t\t/*if prev is B and we're parsing a packed bitstream discard n-vop*/\n\t\t\tif (ctx->forced_packed && ctx->b_frames) {\n\t\t\t\tctx->is_packed = GF_TRUE;\n\t\t\t\tassert(remain>=size);\n\t\t\t\tstart += size;\n\t\t\t\tremain -= (s32) size;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*policy is to import at variable frame rate, skip*/\n\t\t\tif (ctx->vfr) {\n\t\t\t\tctx->is_vfr = GF_TRUE;\n\t\t\t\tmpgviddmx_update_time(ctx);\n\t\t\t\tassert(remain>=size);\n\t\t\t\tstart += size;\n\t\t\t\tremain -= (s32) size;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*policy is to keep non coded frame (constant frame rate), add*/\n\t\t}\n\n\t\tif (ftype==2) {\n\t\t\t//count number of B-frames since last ref\n\t\t\tctx->b_frames++;\n\t\t\tctx->nb_b++;\n\t\t} else {\n\t\t\t//flush all pending packets\n\t\t\tmpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_FALSE);\n\t\t\t//remeber the CTS of the last ref\n\t\t\tctx->last_ref_cts = ctx->cts;\n\t\t\tif (ctx->max_b < ctx->b_frames) ctx->max_b = ctx->b_frames;\n\t\t\t\n\t\t\tctx->b_frames = 0;\n\t\t\tif (ftype)\n\t\t\t\tctx->nb_p++;\n\t\t\telse\n\t\t\t\tctx->nb_i++;\n\t\t}\n\t\tctx->nb_frames++;\n\n\t\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data);\n\t\tif (!dst_pck) return GF_OUT_OF_MEM;\n\n\t\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);\n\t\t//bytes come from both our store and the data packet\n\t\tif (bytes_from_store) {\n\t\t\tmemcpy(pck_data, ctx->hdr_store+current, bytes_from_store);\n\t\t\tassert(size >= bytes_from_store);\n\t\t\tsize -= bytes_from_store;\n\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset - bytes_from_store);\n\t\t\t}\n\t\t\tmemcpy(pck_data + bytes_from_store, start, (size_t) size);\n\t\t} else {\n\t\t\t//bytes only come the data packet\n\t\t\tmemcpy(pck_data, start, (size_t) size);\n\t\t\tif (byte_offset != GF_FILTER_NO_BO) {\n\t\t\t\tgf_filter_pck_set_byte_offset(dst_pck, byte_offset + start - (u8 *) data);\n\t\t\t}\n\t\t}\n\t\tassert(pck_data[0] == 0);\n\t\tassert(pck_data[1] == 0);\n\t\tassert(pck_data[2] == 0x01);\n\n\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, (full_frame || ctx->input_is_au_end) ? GF_TRUE : GF_FALSE);\n\t\tgf_filter_pck_set_cts(dst_pck, ctx->cts);\n\t\tgf_filter_pck_set_dts(dst_pck, ctx->dts);\n\t\tif (ctx->input_is_au_start) {\n\t\t\tctx->input_is_au_start = GF_FALSE;\n\t\t} else {\n\t\t\t//we use the carousel flag temporarly to indicate the cts must be recomputed\n\t\t\tgf_filter_pck_set_carousel_version(dst_pck, 1);\n\t\t}\n\t\tgf_filter_pck_set_sap(dst_pck, ftype ? GF_FILTER_SAP_NONE : GF_FILTER_SAP_1);\n\t\tgf_filter_pck_set_duration(dst_pck, ctx->cur_fps.den);\n\t\tif (ctx->in_seek) gf_filter_pck_set_seek_flag(dst_pck, GF_TRUE);\n\t\tctx->frame_started = GF_TRUE;\n\n\t\tmpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE);\n\n\t\tmpgviddmx_update_time(ctx);\n\n\t\tif (!full_frame) {\n\t\t\tif (copy_last_bytes) {\n\t\t\t\tmemcpy(ctx->hdr_store, start+remain-3, 3);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tassert(remain>=size);\n\t\tstart += size;\n\t\tremain -= (s32) size;\n\t}\n\tgf_filter_pid_drop_packet(ctx->ipid);\n\n\treturn GF_OK;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <gpac/filters.h>\n#include <gpac/internal/media_dev.h>\n#include <gpac/avparse.h>\n#include <gpac/constants.h>\n"
  },
  {
    "repository": "linux",
    "cve_id": "CVE-2022-3239",
    "cwe_list": [
      "CWE-416"
    ],
    "commit_hash": "c08eadca1bdfa099e20a32f8fa4b52b2f672236d",
    "short_hash": "c08eadca",
    "vulnerableMethods_before": [
      {
        "filename": "em28xx-cards.c",
        "method_name": "vulnerable_function",
        "raw_code": "static int em28xx_usb_probe(struct usb_interface *intf,\n\t\t\t    const struct usb_device_id *id)\n{\n\tstruct usb_device *udev;\n\tstruct em28xx *dev = NULL;\n\tint retval;\n\tbool has_vendor_audio = false, has_video = false, has_dvb = false;\n\tint i, nr, try_bulk;\n\tconst int ifnum = intf->altsetting[0].desc.bInterfaceNumber;\n\tchar *speed;\n\n\tudev = usb_get_dev(interface_to_usbdev(intf));\n\n\t/* Check to see next free device and mark as used */\n\tdo {\n\t\tnr = find_first_zero_bit(em28xx_devused, EM28XX_MAXBOARDS);\n\t\tif (nr >= EM28XX_MAXBOARDS) {\n\t\t\t/* No free device slots */\n\t\t\tdev_err(&intf->dev,\n\t\t\t\t\"Driver supports up to %i em28xx boards.\\n\",\n\t\t\t       EM28XX_MAXBOARDS);\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto err_no_slot;\n\t\t}\n\t} while (test_and_set_bit(nr, em28xx_devused));\n\n\t/* Don't register audio interfaces */\n\tif (intf->altsetting[0].desc.bInterfaceClass == USB_CLASS_AUDIO) {\n\t\tdev_info(&intf->dev,\n\t\t\t\"audio device (%04x:%04x): interface %i, class %i\\n\",\n\t\t\tle16_to_cpu(udev->descriptor.idVendor),\n\t\t\tle16_to_cpu(udev->descriptor.idProduct),\n\t\t\tifnum,\n\t\t\tintf->altsetting[0].desc.bInterfaceClass);\n\n\t\tretval = -ENODEV;\n\t\tgoto err;\n\t}\n\n\t/* allocate memory for our device state and initialize it */\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev) {\n\t\tretval = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t/* compute alternate max packet sizes */\n\tdev->alt_max_pkt_size_isoc = kcalloc(intf->num_altsetting,\n\t\t\t\t\t     sizeof(dev->alt_max_pkt_size_isoc[0]),\n\t\t\t\t\t     GFP_KERNEL);\n\tif (!dev->alt_max_pkt_size_isoc) {\n\t\tkfree(dev);\n\t\tretval = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t/* Get endpoints */\n\tfor (i = 0; i < intf->num_altsetting; i++) {\n\t\tint ep;\n\n\t\tfor (ep = 0;\n\t\t     ep < intf->altsetting[i].desc.bNumEndpoints;\n\t\t     ep++)\n\t\t\tem28xx_check_usb_descriptor(dev, udev, intf,\n\t\t\t\t\t\t    i, ep,\n\t\t\t\t\t\t    &has_vendor_audio,\n\t\t\t\t\t\t    &has_video,\n\t\t\t\t\t\t    &has_dvb);\n\t}\n\n\tif (!(has_vendor_audio || has_video || has_dvb)) {\n\t\tretval = -ENODEV;\n\t\tgoto err_free;\n\t}\n\n\tswitch (udev->speed) {\n\tcase USB_SPEED_LOW:\n\t\tspeed = \"1.5\";\n\t\tbreak;\n\tcase USB_SPEED_UNKNOWN:\n\tcase USB_SPEED_FULL:\n\t\tspeed = \"12\";\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\n\t\tspeed = \"480\";\n\t\tbreak;\n\tdefault:\n\t\tspeed = \"unknown\";\n\t}\n\n\tdev_info(&intf->dev,\n\t\t\"New device %s %s @ %s Mbps (%04x:%04x, interface %d, class %d)\\n\",\n\t\tudev->manufacturer ? udev->manufacturer : \"\",\n\t\tudev->product ? udev->product : \"\",\n\t\tspeed,\n\t\tle16_to_cpu(udev->descriptor.idVendor),\n\t\tle16_to_cpu(udev->descriptor.idProduct),\n\t\tifnum,\n\t\tintf->altsetting->desc.bInterfaceNumber);\n\n\t/*\n\t * Make sure we have 480 Mbps of bandwidth, otherwise things like\n\t * video stream wouldn't likely work, since 12 Mbps is generally\n\t * not enough even for most Digital TV streams.\n\t */\n\tif (udev->speed != USB_SPEED_HIGH && disable_usb_speed_check == 0) {\n\t\tdev_err(&intf->dev, \"Device initialization failed.\\n\");\n\t\tdev_err(&intf->dev,\n\t\t\t\"Device must be connected to a high-speed USB 2.0 port.\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto err_free;\n\t}\n\n\tdev->devno = nr;\n\tdev->model = id->driver_info;\n\tdev->alt   = -1;\n\tdev->is_audio_only = has_vendor_audio && !(has_video || has_dvb);\n\tdev->has_video = has_video;\n\tdev->ifnum = ifnum;\n\n\tdev->ts = PRIMARY_TS;\n\tsnprintf(dev->name, 28, \"em28xx\");\n\tdev->dev_next = NULL;\n\n\tif (has_vendor_audio) {\n\t\tdev_info(&intf->dev,\n\t\t\t\"Audio interface %i found (Vendor Class)\\n\", ifnum);\n\t\tdev->usb_audio_type = EM28XX_USB_AUDIO_VENDOR;\n\t}\n\t/* Checks if audio is provided by a USB Audio Class intf */\n\tfor (i = 0; i < udev->config->desc.bNumInterfaces; i++) {\n\t\tstruct usb_interface *uif = udev->config->interface[i];\n\n\t\tif (uif->altsetting[0].desc.bInterfaceClass == USB_CLASS_AUDIO) {\n\t\t\tif (has_vendor_audio)\n\t\t\t\tdev_err(&intf->dev,\n\t\t\t\t\t\"em28xx: device seems to have vendor AND usb audio class interfaces !\\n\"\n\t\t\t\t\t\"\\t\\tThe vendor interface will be ignored. Please contact the developers <linux-media@vger.kernel.org>\\n\");\n\t\t\tdev->usb_audio_type = EM28XX_USB_AUDIO_CLASS;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (has_video)\n\t\tdev_info(&intf->dev, \"Video interface %i found:%s%s\\n\",\n\t\t\tifnum,\n\t\t\tdev->analog_ep_bulk ? \" bulk\" : \"\",\n\t\t\tdev->analog_ep_isoc ? \" isoc\" : \"\");\n\tif (has_dvb)\n\t\tdev_info(&intf->dev, \"DVB interface %i found:%s%s\\n\",\n\t\t\tifnum,\n\t\t\tdev->dvb_ep_bulk ? \" bulk\" : \"\",\n\t\t\tdev->dvb_ep_isoc ? \" isoc\" : \"\");\n\n\tdev->num_alt = intf->num_altsetting;\n\n\tif ((unsigned int)card[nr] < em28xx_bcount)\n\t\tdev->model = card[nr];\n\n\t/* save our data pointer in this intf device */\n\tusb_set_intfdata(intf, dev);\n\n\t/* allocate device struct and check if the device is a webcam */\n\tmutex_init(&dev->lock);\n\tretval = em28xx_init_dev(dev, udev, intf, nr);\n\tif (retval)\n\t\tgoto err_free;\n\n\tif (usb_xfer_mode < 0) {\n\t\tif (dev->is_webcam)\n\t\t\ttry_bulk = 1;\n\t\telse\n\t\t\ttry_bulk = 0;\n\t} else {\n\t\ttry_bulk = usb_xfer_mode > 0;\n\t}\n\n\t/* Disable V4L2 if the device doesn't have a decoder or image sensor */\n\tif (has_video &&\n\t    dev->board.decoder == EM28XX_NODECODER &&\n\t    dev->em28xx_sensor == EM28XX_NOSENSOR) {\n\t\tdev_err(&intf->dev,\n\t\t\t\"Currently, V4L2 is not supported on this model\\n\");\n\t\thas_video = false;\n\t\tdev->has_video = false;\n\t}\n\n\tif (dev->board.has_dual_ts &&\n\t    (dev->tuner_type != TUNER_ABSENT || INPUT(0)->type)) {\n\t\t/*\n\t\t * The logic with sets alternate is not ready for dual-tuners\n\t\t * which analog modes.\n\t\t */\n\t\tdev_err(&intf->dev,\n\t\t\t\"We currently don't support analog TV or stream capture on dual tuners.\\n\");\n\t\thas_video = false;\n\t}\n\n\t/* Select USB transfer types to use */\n\tif (has_video) {\n\t\tif (!dev->analog_ep_isoc || (try_bulk && dev->analog_ep_bulk))\n\t\t\tdev->analog_xfer_bulk = 1;\n\t\tdev_info(&intf->dev, \"analog set to %s mode.\\n\",\n\t\t\tdev->analog_xfer_bulk ? \"bulk\" : \"isoc\");\n\t}\n\tif (has_dvb) {\n\t\tif (!dev->dvb_ep_isoc || (try_bulk && dev->dvb_ep_bulk))\n\t\t\tdev->dvb_xfer_bulk = 1;\n\t\tdev_info(&intf->dev, \"dvb set to %s mode.\\n\",\n\t\t\tdev->dvb_xfer_bulk ? \"bulk\" : \"isoc\");\n\t}\n\n\tif (dev->board.has_dual_ts && em28xx_duplicate_dev(dev) == 0) {\n\t\tdev->dev_next->ts = SECONDARY_TS;\n\t\tdev->dev_next->alt   = -1;\n\t\tdev->dev_next->is_audio_only = has_vendor_audio &&\n\t\t\t\t\t\t!(has_video || has_dvb);\n\t\tdev->dev_next->has_video = false;\n\t\tdev->dev_next->ifnum = ifnum;\n\t\tdev->dev_next->model = id->driver_info;\n\n\t\tmutex_init(&dev->dev_next->lock);\n\t\tretval = em28xx_init_dev(dev->dev_next, udev, intf,\n\t\t\t\t\t dev->dev_next->devno);\n\t\tif (retval)\n\t\t\tgoto err_free;\n\n\t\tdev->dev_next->board.ir_codes = NULL; /* No IR for 2nd tuner */\n\t\tdev->dev_next->board.has_ir_i2c = 0; /* No IR for 2nd tuner */\n\n\t\tif (usb_xfer_mode < 0) {\n\t\t\tif (dev->dev_next->is_webcam)\n\t\t\t\ttry_bulk = 1;\n\t\t\telse\n\t\t\t\ttry_bulk = 0;\n\t\t} else {\n\t\t\ttry_bulk = usb_xfer_mode > 0;\n\t\t}\n\n\t\t/* Select USB transfer types to use */\n\t\tif (has_dvb) {\n\t\t\tif (!dev->dvb_ep_isoc_ts2 ||\n\t\t\t    (try_bulk && dev->dvb_ep_bulk_ts2))\n\t\t\t\tdev->dev_next->dvb_xfer_bulk = 1;\n\t\t\tdev_info(&dev->intf->dev, \"dvb ts2 set to %s mode.\\n\",\n\t\t\t\t dev->dev_next->dvb_xfer_bulk ? \"bulk\" : \"isoc\");\n\t\t}\n\n\t\tdev->dev_next->dvb_ep_isoc = dev->dvb_ep_isoc_ts2;\n\t\tdev->dev_next->dvb_ep_bulk = dev->dvb_ep_bulk_ts2;\n\t\tdev->dev_next->dvb_max_pkt_size_isoc = dev->dvb_max_pkt_size_isoc_ts2;\n\t\tdev->dev_next->dvb_alt_isoc = dev->dvb_alt_isoc;\n\n\t\t/* Configure hardware to support TS2*/\n\t\tif (dev->dvb_xfer_bulk) {\n\t\t\t/* The ep4 and ep5 are configured for BULK */\n\t\t\tem28xx_write_reg(dev, 0x0b, 0x96);\n\t\t\tmdelay(100);\n\t\t\tem28xx_write_reg(dev, 0x0b, 0x80);\n\t\t\tmdelay(100);\n\t\t} else {\n\t\t\t/* The ep4 and ep5 are configured for ISO */\n\t\t\tem28xx_write_reg(dev, 0x0b, 0x96);\n\t\t\tmdelay(100);\n\t\t\tem28xx_write_reg(dev, 0x0b, 0x82);\n\t\t\tmdelay(100);\n\t\t}\n\n\t\tkref_init(&dev->dev_next->ref);\n\t}\n\n\tkref_init(&dev->ref);\n\n\trequest_modules(dev);\n\n\t/*\n\t * Do it at the end, to reduce dynamic configuration changes during\n\t * the device init. Yet, as request_modules() can be async, the\n\t * topology will likely change after the load of the em28xx subdrivers.\n\t */\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tretval = media_device_register(dev->media_dev);\n#endif\n\n\treturn 0;\n\nerr_free:\n\tkfree(dev->alt_max_pkt_size_isoc);\n\tkfree(dev);\n\nerr:\n\tclear_bit(nr, em28xx_devused);\n\nerr_no_slot:\n\tusb_put_dev(udev);\n\treturn retval;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "em28xx-cards.c",
        "method_name": "fixed_function",
        "raw_code": "static int em28xx_usb_probe(struct usb_interface *intf,\n\t\t\t    const struct usb_device_id *id)\n{\n\tstruct usb_device *udev;\n\tstruct em28xx *dev = NULL;\n\tint retval;\n\tbool has_vendor_audio = false, has_video = false, has_dvb = false;\n\tint i, nr, try_bulk;\n\tconst int ifnum = intf->altsetting[0].desc.bInterfaceNumber;\n\tchar *speed;\n\n\tudev = usb_get_dev(interface_to_usbdev(intf));\n\n\t/* Check to see next free device and mark as used */\n\tdo {\n\t\tnr = find_first_zero_bit(em28xx_devused, EM28XX_MAXBOARDS);\n\t\tif (nr >= EM28XX_MAXBOARDS) {\n\t\t\t/* No free device slots */\n\t\t\tdev_err(&intf->dev,\n\t\t\t\t\"Driver supports up to %i em28xx boards.\\n\",\n\t\t\t       EM28XX_MAXBOARDS);\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto err_no_slot;\n\t\t}\n\t} while (test_and_set_bit(nr, em28xx_devused));\n\n\t/* Don't register audio interfaces */\n\tif (intf->altsetting[0].desc.bInterfaceClass == USB_CLASS_AUDIO) {\n\t\tdev_info(&intf->dev,\n\t\t\t\"audio device (%04x:%04x): interface %i, class %i\\n\",\n\t\t\tle16_to_cpu(udev->descriptor.idVendor),\n\t\t\tle16_to_cpu(udev->descriptor.idProduct),\n\t\t\tifnum,\n\t\t\tintf->altsetting[0].desc.bInterfaceClass);\n\n\t\tretval = -ENODEV;\n\t\tgoto err;\n\t}\n\n\t/* allocate memory for our device state and initialize it */\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev) {\n\t\tretval = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t/* compute alternate max packet sizes */\n\tdev->alt_max_pkt_size_isoc = kcalloc(intf->num_altsetting,\n\t\t\t\t\t     sizeof(dev->alt_max_pkt_size_isoc[0]),\n\t\t\t\t\t     GFP_KERNEL);\n\tif (!dev->alt_max_pkt_size_isoc) {\n\t\tkfree(dev);\n\t\tretval = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t/* Get endpoints */\n\tfor (i = 0; i < intf->num_altsetting; i++) {\n\t\tint ep;\n\n\t\tfor (ep = 0;\n\t\t     ep < intf->altsetting[i].desc.bNumEndpoints;\n\t\t     ep++)\n\t\t\tem28xx_check_usb_descriptor(dev, udev, intf,\n\t\t\t\t\t\t    i, ep,\n\t\t\t\t\t\t    &has_vendor_audio,\n\t\t\t\t\t\t    &has_video,\n\t\t\t\t\t\t    &has_dvb);\n\t}\n\n\tif (!(has_vendor_audio || has_video || has_dvb)) {\n\t\tretval = -ENODEV;\n\t\tgoto err_free;\n\t}\n\n\tswitch (udev->speed) {\n\tcase USB_SPEED_LOW:\n\t\tspeed = \"1.5\";\n\t\tbreak;\n\tcase USB_SPEED_UNKNOWN:\n\tcase USB_SPEED_FULL:\n\t\tspeed = \"12\";\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\n\t\tspeed = \"480\";\n\t\tbreak;\n\tdefault:\n\t\tspeed = \"unknown\";\n\t}\n\n\tdev_info(&intf->dev,\n\t\t\"New device %s %s @ %s Mbps (%04x:%04x, interface %d, class %d)\\n\",\n\t\tudev->manufacturer ? udev->manufacturer : \"\",\n\t\tudev->product ? udev->product : \"\",\n\t\tspeed,\n\t\tle16_to_cpu(udev->descriptor.idVendor),\n\t\tle16_to_cpu(udev->descriptor.idProduct),\n\t\tifnum,\n\t\tintf->altsetting->desc.bInterfaceNumber);\n\n\t/*\n\t * Make sure we have 480 Mbps of bandwidth, otherwise things like\n\t * video stream wouldn't likely work, since 12 Mbps is generally\n\t * not enough even for most Digital TV streams.\n\t */\n\tif (udev->speed != USB_SPEED_HIGH && disable_usb_speed_check == 0) {\n\t\tdev_err(&intf->dev, \"Device initialization failed.\\n\");\n\t\tdev_err(&intf->dev,\n\t\t\t\"Device must be connected to a high-speed USB 2.0 port.\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto err_free;\n\t}\n\n\tkref_init(&dev->ref);\n\n\tdev->devno = nr;\n\tdev->model = id->driver_info;\n\tdev->alt   = -1;\n\tdev->is_audio_only = has_vendor_audio && !(has_video || has_dvb);\n\tdev->has_video = has_video;\n\tdev->ifnum = ifnum;\n\n\tdev->ts = PRIMARY_TS;\n\tsnprintf(dev->name, 28, \"em28xx\");\n\tdev->dev_next = NULL;\n\n\tif (has_vendor_audio) {\n\t\tdev_info(&intf->dev,\n\t\t\t\"Audio interface %i found (Vendor Class)\\n\", ifnum);\n\t\tdev->usb_audio_type = EM28XX_USB_AUDIO_VENDOR;\n\t}\n\t/* Checks if audio is provided by a USB Audio Class intf */\n\tfor (i = 0; i < udev->config->desc.bNumInterfaces; i++) {\n\t\tstruct usb_interface *uif = udev->config->interface[i];\n\n\t\tif (uif->altsetting[0].desc.bInterfaceClass == USB_CLASS_AUDIO) {\n\t\t\tif (has_vendor_audio)\n\t\t\t\tdev_err(&intf->dev,\n\t\t\t\t\t\"em28xx: device seems to have vendor AND usb audio class interfaces !\\n\"\n\t\t\t\t\t\"\\t\\tThe vendor interface will be ignored. Please contact the developers <linux-media@vger.kernel.org>\\n\");\n\t\t\tdev->usb_audio_type = EM28XX_USB_AUDIO_CLASS;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (has_video)\n\t\tdev_info(&intf->dev, \"Video interface %i found:%s%s\\n\",\n\t\t\tifnum,\n\t\t\tdev->analog_ep_bulk ? \" bulk\" : \"\",\n\t\t\tdev->analog_ep_isoc ? \" isoc\" : \"\");\n\tif (has_dvb)\n\t\tdev_info(&intf->dev, \"DVB interface %i found:%s%s\\n\",\n\t\t\tifnum,\n\t\t\tdev->dvb_ep_bulk ? \" bulk\" : \"\",\n\t\t\tdev->dvb_ep_isoc ? \" isoc\" : \"\");\n\n\tdev->num_alt = intf->num_altsetting;\n\n\tif ((unsigned int)card[nr] < em28xx_bcount)\n\t\tdev->model = card[nr];\n\n\t/* save our data pointer in this intf device */\n\tusb_set_intfdata(intf, dev);\n\n\t/* allocate device struct and check if the device is a webcam */\n\tmutex_init(&dev->lock);\n\tretval = em28xx_init_dev(dev, udev, intf, nr);\n\tif (retval)\n\t\tgoto err_free;\n\n\tif (usb_xfer_mode < 0) {\n\t\tif (dev->is_webcam)\n\t\t\ttry_bulk = 1;\n\t\telse\n\t\t\ttry_bulk = 0;\n\t} else {\n\t\ttry_bulk = usb_xfer_mode > 0;\n\t}\n\n\t/* Disable V4L2 if the device doesn't have a decoder or image sensor */\n\tif (has_video &&\n\t    dev->board.decoder == EM28XX_NODECODER &&\n\t    dev->em28xx_sensor == EM28XX_NOSENSOR) {\n\t\tdev_err(&intf->dev,\n\t\t\t\"Currently, V4L2 is not supported on this model\\n\");\n\t\thas_video = false;\n\t\tdev->has_video = false;\n\t}\n\n\tif (dev->board.has_dual_ts &&\n\t    (dev->tuner_type != TUNER_ABSENT || INPUT(0)->type)) {\n\t\t/*\n\t\t * The logic with sets alternate is not ready for dual-tuners\n\t\t * which analog modes.\n\t\t */\n\t\tdev_err(&intf->dev,\n\t\t\t\"We currently don't support analog TV or stream capture on dual tuners.\\n\");\n\t\thas_video = false;\n\t}\n\n\t/* Select USB transfer types to use */\n\tif (has_video) {\n\t\tif (!dev->analog_ep_isoc || (try_bulk && dev->analog_ep_bulk))\n\t\t\tdev->analog_xfer_bulk = 1;\n\t\tdev_info(&intf->dev, \"analog set to %s mode.\\n\",\n\t\t\tdev->analog_xfer_bulk ? \"bulk\" : \"isoc\");\n\t}\n\tif (has_dvb) {\n\t\tif (!dev->dvb_ep_isoc || (try_bulk && dev->dvb_ep_bulk))\n\t\t\tdev->dvb_xfer_bulk = 1;\n\t\tdev_info(&intf->dev, \"dvb set to %s mode.\\n\",\n\t\t\tdev->dvb_xfer_bulk ? \"bulk\" : \"isoc\");\n\t}\n\n\tif (dev->board.has_dual_ts && em28xx_duplicate_dev(dev) == 0) {\n\t\tkref_init(&dev->dev_next->ref);\n\n\t\tdev->dev_next->ts = SECONDARY_TS;\n\t\tdev->dev_next->alt   = -1;\n\t\tdev->dev_next->is_audio_only = has_vendor_audio &&\n\t\t\t\t\t\t!(has_video || has_dvb);\n\t\tdev->dev_next->has_video = false;\n\t\tdev->dev_next->ifnum = ifnum;\n\t\tdev->dev_next->model = id->driver_info;\n\n\t\tmutex_init(&dev->dev_next->lock);\n\t\tretval = em28xx_init_dev(dev->dev_next, udev, intf,\n\t\t\t\t\t dev->dev_next->devno);\n\t\tif (retval)\n\t\t\tgoto err_free;\n\n\t\tdev->dev_next->board.ir_codes = NULL; /* No IR for 2nd tuner */\n\t\tdev->dev_next->board.has_ir_i2c = 0; /* No IR for 2nd tuner */\n\n\t\tif (usb_xfer_mode < 0) {\n\t\t\tif (dev->dev_next->is_webcam)\n\t\t\t\ttry_bulk = 1;\n\t\t\telse\n\t\t\t\ttry_bulk = 0;\n\t\t} else {\n\t\t\ttry_bulk = usb_xfer_mode > 0;\n\t\t}\n\n\t\t/* Select USB transfer types to use */\n\t\tif (has_dvb) {\n\t\t\tif (!dev->dvb_ep_isoc_ts2 ||\n\t\t\t    (try_bulk && dev->dvb_ep_bulk_ts2))\n\t\t\t\tdev->dev_next->dvb_xfer_bulk = 1;\n\t\t\tdev_info(&dev->intf->dev, \"dvb ts2 set to %s mode.\\n\",\n\t\t\t\t dev->dev_next->dvb_xfer_bulk ? \"bulk\" : \"isoc\");\n\t\t}\n\n\t\tdev->dev_next->dvb_ep_isoc = dev->dvb_ep_isoc_ts2;\n\t\tdev->dev_next->dvb_ep_bulk = dev->dvb_ep_bulk_ts2;\n\t\tdev->dev_next->dvb_max_pkt_size_isoc = dev->dvb_max_pkt_size_isoc_ts2;\n\t\tdev->dev_next->dvb_alt_isoc = dev->dvb_alt_isoc;\n\n\t\t/* Configure hardware to support TS2*/\n\t\tif (dev->dvb_xfer_bulk) {\n\t\t\t/* The ep4 and ep5 are configured for BULK */\n\t\t\tem28xx_write_reg(dev, 0x0b, 0x96);\n\t\t\tmdelay(100);\n\t\t\tem28xx_write_reg(dev, 0x0b, 0x80);\n\t\t\tmdelay(100);\n\t\t} else {\n\t\t\t/* The ep4 and ep5 are configured for ISO */\n\t\t\tem28xx_write_reg(dev, 0x0b, 0x96);\n\t\t\tmdelay(100);\n\t\t\tem28xx_write_reg(dev, 0x0b, 0x82);\n\t\t\tmdelay(100);\n\t\t}\n\t}\n\n\trequest_modules(dev);\n\n\t/*\n\t * Do it at the end, to reduce dynamic configuration changes during\n\t * the device init. Yet, as request_modules() can be async, the\n\t * topology will likely change after the load of the em28xx subdrivers.\n\t */\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tretval = media_device_register(dev->media_dev);\n#endif\n\n\treturn 0;\n\nerr_free:\n\tkfree(dev->alt_max_pkt_size_isoc);\n\tkfree(dev);\n\nerr:\n\tclear_bit(nr, em28xx_devused);\n\nerr_no_slot:\n\tusb_put_dev(udev);\n\treturn retval;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <media/v4l2-common.h>\n#include <media/tuner.h>\n#include <sound/ac97_codec.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include \"em28xx.h\"\n#include <media/i2c/saa7115.h>\n#include <linux/usb.h>\n#include <dt-bindings/media/tvp5150.h>\n#include <linux/module.h>\n#include <media/drv-intf/msp3400.h>\n#include <media/i2c/tvaudio.h>\n#include <media/tveeprom.h>\n#include <linux/delay.h>\n\n// Type Definitions:\n// usb_interface:\nstruct usb_interface\n\n// em28xx_board:\nstruct em28xx_board {\n\tchar *name;\n\tint vchannels;\n\tint tuner_type;\n\tint tuner_addr;\n\tunsigned int def_i2c_bus;\t/* Default I2C bus */\n\n\t/* i2c flags */\n\tunsigned int tda9887_conf;\n\n\t/* GPIO sequences */\n\tconst struct em28xx_reg_seq *dvb_gpio;\n\tconst struct em28xx_reg_seq *suspend_gpio;\n\tconst struct em28xx_reg_seq *tuner_gpio;\n\tconst struct em28xx_reg_seq *mute_gpio;\n\n\tunsigned int is_em2800:1;\n\tunsigned int has_msp34xx:1;\n\tunsigned int mts_firmware:1;\n\tunsigned int max_range_640_480:1;\n\tunsigned int has_dvb:1;\n\tunsigned int has_dual_ts:1;\n\tunsigned int is_webcam:1;\n\tunsigned int valid:1;\n\tunsigned int has_ir_i2c:1;\n\n\tunsigned char xclk, i2c_speed;\n\tunsigned char radio_addr;\n\tunsigned short tvaudio_addr;\n\n\tenum em28xx_decoder decoder;\n\tenum em28xx_adecoder adecoder;\n\n\tstruct em28xx_input       input[MAX_EM28XX_INPUT];\n\tstruct em28xx_input\t  radio;\n\tchar\t\t\t  *ir_codes;\n\n\t/* LEDs that need to be controlled explicitly */\n\tstruct em28xx_led\t  *leds;\n\n\t/* Buttons */\n\tconst struct em28xx_...\n\n// usb_device_id:\nstatic const struct usb_device_id\n\n// em28xx:\nstruct em28xx\n\n// em28xx_input:\nstruct em28xx_input {\n\tenum enum28xx_itype type;\n\tunsigned int vmux;\n\tenum em28xx_amux amux;\n\tenum em28xx_aout aout;\n\tconst struct em28xx_reg_seq *gpio;\n}\n\n// usb_device:\nstruct usb_device\n\n// em28xx:\nstruct em28xx {\n\tstruct kref ref;\n\n\t// Sub-module data\n\tstruct em28xx_v4l2 *v4l2;\n\tstruct em28xx_dvb *dvb;\n\tstruct em28xx_audio adev;\n\tstruct em28xx_IR *ir;\n\n\t// generic device properties\n\tint model;\t\t// index in the device_data struct\n\tint devno;\t\t// marks the number of this device\n\tenum em28xx_chip_id chip_id;\n\n\tunsigned int is_em25xx:1;\t// em25xx/em276x/7x/8x family bridge\n\tunsigned int disconnected:1;\t// device has been disconnected\n\tunsigned int has_video:1;\n\tunsigned int is_audio_only:1;\n\tunsigned int is_webcam:1;\n\tunsigned int has_msp34xx:1;\n\tunsigned int i2c_speed:2;\n\tenum em28xx_int_audio_type int_audio_type;\n\tenum em28xx_usb_audio_type usb_audio_type;\n\tunsigned char name[32];\n\n\tstruct em28xx_board board;\n\n\tenum em28xx_sensor em28xx_sensor;\t// camera specific\n\n\t// Some older em28xx chips needs a waiting time after writing\n\tunsigned int wait_after_write;\n\n\tstruct list_head\tdevlist;\n\n\tu32 i2s_speed;\t\t// I2S speed for audio digital stream\n\n\tstruct em28xx_audio_mode audio_mode;...\n\n// Called Methods (top 10):\n// em28xx_set_model from drivers/media/usb/em28xx/em28xx-cards.c:\nstatic inline void em28xx_set_model(struct em28xx *dev) /* <=== em28xx_set_model */ \n{\n\tdev->board = em28xx_boards[dev->model];\n\tdev->has_msp34xx = dev->board.has_msp34xx;\n\tdev->is_webcam = dev->board.is_webcam;\n\n\tem28xx_set_xclk_i2c_speed(dev);\n\n\t/* Should be initialized early, for I2C to work */\n\tdev->def_i2c_bus = dev->board.def_i2c_bus;\n}\n\n// EM28XX_R06_I2C_CLK from drivers/media/usb/em28xx/em28xx-reg.h:\n#define EM28XX_R06_I2C_CLK\t0x06 /* <=== drivers/media/usb/em28xx/em28xx-reg.h:63:63:EM28XX_R06_I2C_CLK:0 */ \n\n// EM2820_BOARD_IODATA_GVMVP_SZ from drivers/media/usb/em28xx/em28xx.h:\n#define EM2820_BOARD_IODATA_GVMVP_SZ\t\t  65 /* <=== drivers/media/usb/em28xx/em28xx.h:114:114:EM2820_BOARD_IODATA_GVMVP_SZ:0 */ \n\n// INPUT from drivers/media/usb/em28xx/em28xx.h:\n#define INPUT(nr) (&em28xx_boards[dev->model].input[nr]) /* <=== drivers/media/usb/em28xx/em28xx.h:431:431:INPUT:1 */ \n\n// EM28XX_R0A_CHIPID from drivers/media/usb/em28xx/em28xx-reg.h:\n#define EM28XX_R0A_CHIPID\t0x0a /* <=== drivers/media/usb/em28xx/em28xx-reg.h:76:76:EM28XX_R0A_CHIPID:0 */ \n\n// em28xx_media_device_init from drivers/media/usb/em28xx/em28xx-cards.c:\nstatic int em28xx_media_device_init(struct em28xx *dev, /* <=== em28xx_media_device_init */ \n\t\t\t\t    struct usb_device *udev)\n{\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tstruct media_device *mdev;\n\n\tmdev = kzalloc(sizeof(*mdev), GFP_KERNEL);\n\tif (!mdev)\n\t\treturn -ENOMEM;\n\n\tif (udev->product)\n\t\tmedia_device_usb_init(mdev, udev, udev->product);\n\telse if (udev->manufacturer)\n\t\tmedia_device_usb_init(mdev, udev, udev->manufacturer);\n\telse\n\t\tmedia_device_usb_init(mdev, udev, dev_name(&dev->intf->dev));\n\n\tdev->media_dev = mdev;\n#endif\n\treturn 0;\n}\n\n// EM28XX_CHIPCFG_AUDIOMASK from drivers/media/usb/em28xx/em28xx-reg.h:\n#define EM28XX_CHIPCFG_AUDIOMASK\t\t0x30 /* <=== drivers/media/usb/em28xx/em28xx-reg.h:41:41:EM28XX_CHIPCFG_AUDIOMASK:0 */ \n\n// EM2860_BOARD_EASYCAP from drivers/media/usb/em28xx/em28xx.h:\n#define EM2860_BOARD_EASYCAP\t\t\t  64 /* <=== drivers/media/usb/em28xx/em28xx.h:113:113:EM2860_BOARD_EASYCAP:0 */ \n\n// em28xx_i2c_register from drivers/media/usb/em28xx/em28xx-i2c.c:\nint em28xx_i2c_register(struct em28xx *dev, unsigned int bus, /* <=== em28xx_i2c_register */ \n\t\t\tenum em28xx_i2c_algo_type algo_type)\n{\n\tint retval;\n\n\tif (WARN_ON(!dev->em28xx_write_regs || !dev->em28xx_read_reg ||\n\t\t    !dev->em28xx_write_regs_req || !dev->em28xx_read_reg_req))\n\t\treturn -ENODEV;\n\n\tif (bus >= NUM_I2C_BUSES)\n\t\treturn -ENODEV;\n\n\tdev->i2c_adap[bus] = em28xx_adap_template;\n\tdev->i2c_adap[bus].dev.parent = &dev->intf->dev;\n\tstrscpy(dev->i2c_adap[bus].name, dev_name(&dev->intf->dev),\n\t\tsizeof(dev->i2c_adap[bus].name));\n\n\tdev->i2c_bus[bus].bus = bus;\n\tdev->i2c_bus[bus].algo_type = algo_type;\n\tdev->i2c_bus[bus].dev = dev;\n\tdev->i2c_adap[bus].algo_data = &dev->i2c_bus[bus];\n\n\tretval = i2c_add_adapter(&dev->i2c_adap[bus]);\n\tif (retval < 0) {\n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"%s: i2c_add_adapter failed! retval [%d]\\n\",\n\t\t\t__func__, retval);\n\t\treturn retval;\n\t}\n\n\tdev->i2c_client[bus] = em28xx_client_template;\n\tdev->i2c_client[bus].adapter = &dev->i2c_adap[bus];\n\n\t/* Up to now, all eeproms are at bus 0 */\n\tif (!bus) {\n\t\tretval = em28xx_i2c_eeprom(dev, bus,\n\t\t\t\t\t   &dev->eedata, &dev->eedata_len);\n\t\tif (retval < 0 && retval != -ENODEV) {\n\t\t\tdev_err(&dev->intf->dev,\n\t\t\t\t\"%s: em28xx_i2_eeprom failed! retval [%d]\\n\",\n\t\t\t\t__func__, retval);\n\t\t}\n\t}\n\n\tif (i2c_scan)\n\t\tem28xx_do_i2c_scan(dev, bus);\n\n\treturn 0;\n}\n\n// EM28XX_BOARD_NOT_VALIDATED from drivers/media/usb/em28xx/em28xx.h:\n#define EM28XX_BOARD_NOT_VALIDATED 1 /* <=== drivers/media/usb/em28xx/em28xx.h:165:165:EM28XX_BOARD_NOT_VALIDATED:0 */ \n"
  },
  {
    "repository": "tensorflow",
    "cve_id": "CVE-2021-41210",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "701cfaca222a82afbeeb17496bd718baa65a67d2",
    "short_hash": "701cfaca",
    "vulnerableMethods_before": [
      {
        "filename": "count_ops.cc",
        "method_name": "vulnerable_function",
        "raw_code": "Status SparseCountSparseOutputShapeFn(InferenceContext *c) {\n  auto rank = c->Dim(c->input(0), 1);\n  auto nvals = c->UnknownDim();\n  c->set_output(0, c->Matrix(nvals, rank));  // out.indices\n  c->set_output(1, c->Vector(nvals));        // out.values\n  c->set_output(2, c->Vector(rank));         // out.dense_shape\n  return Status::OK();\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "count_ops.cc",
        "method_name": "fixed_function",
        "raw_code": "Status SparseCountSparseOutputShapeFn(InferenceContext *c) {\n  ShapeHandle unused;\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &unused));\n  auto rank = c->Dim(c->input(0), 1);\n  auto nvals = c->UnknownDim();\n  c->set_output(0, c->Matrix(nvals, rank));  // out.indices\n  c->set_output(1, c->Vector(nvals));        // out.values\n  c->set_output(2, c->Vector(rank));         // out.dense_shape\n  return Status::OK();\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"tensorflow/core/framework/shape_inference.h\"\n#include \"tensorflow/core/framework/common_shape_fns.h\"\n#include \"tensorflow/core/framework/op.h\"\n\n// Type Definitions:\n// DimensionHandle:\nclass DimensionHandle {\n public:\n  DimensionHandle() {}\n  bool SameHandle(DimensionHandle d) const { return ptr_ == d.ptr_; }\n  std::size_t Handle() const { return reinterpret_cast<std::size_t>(ptr_); }\n\n private:\n  DimensionHandle(const Dimension* dim) { ptr_ = dim; }\n\n  const Dimension* operator->() const { return ptr_; }\n  bool IsSet() const { return ptr_ != nullptr; }\n\n  const Dimension* ptr_ = nullptr;\n\n  friend struct DimensionOrConstant;\n  friend class InferenceContext;\n  friend class ShapeInferenceTest;\n  friend class ShapeInferenceTestutil;\n  friend class ::tensorflow::grappler::GraphProperties;\n  friend class ::tensorflow::grappler::SymbolicShapeManager;\n\n  // Intentionally copyable.\n}\n\n// Status:\nclass Status\n\n// Status:\nclass Status {\n public:\n  /// Create a success status.\n  Status() {}\n\n  /// \\brief Create a status with the specified error code and msg as a\n  /// human-readable string containing more detailed information.\n  Status(tensorflow::error::Code code, tensorflow::StringPiece msg)\n      : Status(code, msg, {}) {}\n\n  /// \\brief Create a status with the specified error code, msg, and stack trace\n  /// as a human-readable string containing more detailed information.\n#ifndef SWIG\n  Status(tensorflow::error::Code code, tensorflow::StringPiece msg,\n         std::vector<StackFrame>&& stack_trace);\n#endif\n\n  /// Copy the specified status.\n  Status(const Status& s);\n  Status& operator=(const Status& s);\n#ifndef SWIG\n  Status(Status&& s) noexcept;\n  Status& operator=(Status&& s) noexcept;\n#endif  // SWIG\n\n  static Status OK() { return Status(); }\n\n  /// Returns true iff the status indicates success.\n  bool ok() const { return (state_ == nullptr); }\n\n  tensorflow::error::Code code() const {\n    retu...\n\n// InferenceContext:\nInferenceContext.InferenceContext:ANY(int,AttrSlice&,OpDef&,std.vector&,std.vector&,std.vector&,std.vector&)\n\n// InferenceContext:\nclass InferenceContext {\n public:\n  static constexpr int64_t kUnknownDim = -1;\n  static constexpr int32_t kUnknownRank = -1;\n\n  // <input_tensors> is NULL-padded to be the same size as <input_shapes>.\n  //\n  // Elements of <input_tensors_as_shapes> are used for when a shape function\n  // makes a call to MakeShapeFromShapeTensor; in particular, when the\n  // input_tensors[i] is nullptr but the shape represented by it is partially\n  // known from analysis of the graph.\n  // <input_tensors_as_shapes> can have fewer elements than <input_shapes>.\n  // Values of <input_tensors_as_shapes> do not need to outlive the context.\n  InferenceContext(int graph_def_version, const AttrSlice& attrs,\n                   const OpDef& op_def,\n                   const std::vector<ShapeHandle>& input_shapes,\n                   const std::vector<const Tensor*>& input_tensors,\n                   const std::vector<ShapeHandle>& input_tensors_as_shapes,\n                   std::vector<std::unique_ptr<std::vecto...\n\n// ShapeHandle:\nclass ShapeHandle {\n public:\n  ShapeHandle() {}\n  bool SameHandle(ShapeHandle s) const { return ptr_ == s.ptr_; }\n  std::size_t Handle() const { return reinterpret_cast<std::size_t>(ptr_); }\n\n private:\n  ShapeHandle(const Shape* shape) { ptr_ = shape; }\n  const Shape* operator->() const { return ptr_; }\n  bool IsSet() const { return ptr_ != nullptr; }\n\n  const Shape* ptr_ = nullptr;\n\n  friend class InferenceContext;\n  friend class ShapeInferenceTest;\n  friend class ShapeInferenceTestutil;\n  friend class ::tensorflow::grappler::SymbolicShapeManager;\n\n  // Intentionally copyable.\n}\n\n// Called Methods (top 10):\n// set_output from tensorflow/core/framework/shape_inference.h:\n  void set_output(int idx, ShapeHandle shape) { outputs_.at(idx) = shape; } /* <=== tensorflow.shape_inference.InferenceContext.set_output:void(int,tensorflow.shape_inference.ShapeHandle) */ \n\n// OK from tensorflow/core/platform/status.h:\n  static Status OK() { return Status(); } /* <=== tensorflow.Status.OK:tensorflow.Status() */ \n\n// MakeDim from tensorflow/core/framework/shape_inference.h:\n  inline DimensionHandle MakeDim(DimensionOrConstant d) { /* <=== tensorflow.shape_inference.InferenceContext.MakeDim:tensorflow.shape_inference.DimensionHandle(tensorflow.shape_inference.DimensionOrConstant) */ \n    return shape_manager_.MakeDim(d);\n  }\n\n// ok from tensorflow/core/platform/status.h:\n  bool ok() const { return (state_ == nullptr); } /* <=== tensorflow.Status.ok:bool()<const> */ \n\n// Vector from tensorflow/core/framework/shape_inference.h:\n  ShapeHandle Vector(DimensionOrConstant dim); /* <=== tensorflow.shape_inference.InferenceContext.Vector:tensorflow.shape_inference.ShapeHandle(tensorflow.shape_inference.DimensionOrConstant) */ \n\n// TF_RETURN_IF_ERROR from tensorflow/core/ops/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/common_runtime/eager/tensorflow/core/framework/tensorflow/core/platform/errors.h:\n\n\n// UnknownDim from tensorflow/core/framework/shape_inference.h:\n  inline DimensionHandle UnknownDim() { return MakeDim(kUnknownDim); } /* <=== tensorflow.shape_inference.InferenceContext.UnknownDim:tensorflow.shape_inference.DimensionHandle() */ \n\n// IsSet from tensorflow/core/framework/shape_inference.h:\n  bool IsSet() const { return ptr_ != nullptr; } /* <=== tensorflow.shape_inference.DimensionHandle.IsSet:bool()<const> */ \n"
  },
  {
    "repository": "vim",
    "cve_id": "CVE-2022-1620",
    "cwe_list": [
      "CWE-476"
    ],
    "commit_hash": "8e4b76da1d7e987d43ca960dfbc372d1c617466f",
    "short_hash": "8e4b76da",
    "vulnerableMethods_before": [
      {
        "filename": "buffer.c",
        "method_name": "vulnerable_function",
        "raw_code": "fname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n\n    if (name != NULL)\n    {\n\t// Ignore case when 'fileignorecase' or the argument is set.\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse\n\t{\n\t    // Replace $(HOME) with '~' and try matching again.\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n\n    return match;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "buffer.c",
        "method_name": "fixed_function",
        "raw_code": "fname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n\n    if (name != NULL)\n    {\n\t// Ignore case when 'fileignorecase' or the argument is set.\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse if (rmp->regprog != NULL)\n\t{\n\t    // Replace $(HOME) with '~' and try matching again.\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n\n    return match;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"version.h\"\n#include \"vim.h\"\n\n// Type Definitions:\n// regmatch_T:\ntypedef struct\n{\n    regprog_T\t\t*regprog;\n    char_u\t\t*startp[NSUBEXP];\n    char_u\t\t*endp[NSUBEXP];\n    int\t\t\trm_ic;\n}\n\n// char_u:\ntypedef unsigned char\tchar_u;\n\n// Called Methods (top 10):\n// report_re_switch from src/regexp.c:\n    static void /* <=== report_re_switch */ \nreport_re_switch(char_u *pat)\n{\n    if (p_verbose > 0)\n    {\n\tverbose_enter();\n\tmsg_puts(_(\"Switching to backtracking RE engine for pattern: \"));\n\tmsg_puts((char *)pat);\n\tverbose_leave();\n    }\n}\n\n// vim_strsave from src/strings.c:\n    char_u * /* <=== vim_strsave */ \nvim_strsave(char_u *string)\n{\n    char_u\t*p;\n    size_t\tlen;\n\n    len = STRLEN(string) + 1;\n    p = alloc(len);\n    if (p != NULL)\n\tmch_memmove(p, string, len);\n    return p;\n}\n\n// _ from src/vim.h:\n# define _(x) ((char *)(x)) /* <=== src/vim.h:564:564:_:1 */ \n\n// vim_regexec from src/regexp.c:\n    int /* <=== vim_regexec */ \nvim_regexec(regmatch_T *rmp, char_u *line, colnr_T col)\n{\n    return vim_regexec_string(rmp, line, col, FALSE);\n}\n\n// vim_regcomp from src/regexp.c:\n    regprog_T * /* <=== vim_regcomp */ \nvim_regcomp(char_u *expr_arg, int re_flags)\n{\n    regprog_T   *prog = NULL;\n    char_u\t*expr = expr_arg;\n    int\t\tcalled_emsg_before;\n\n    regexp_engine = p_re;\n\n    // Check for prefix \"\\%#=\", that sets the regexp engine\n    if (STRNCMP(expr, \"\\\\%#=\", 4) == 0)\n    {\n\tint newengine = expr[4] - '0';\n\n\tif (newengine == AUTOMATIC_ENGINE\n\t    || newengine == BACKTRACKING_ENGINE\n\t    || newengine == NFA_ENGINE)\n\t{\n\t    regexp_engine = expr[4] - '0';\n\t    expr += 5;\n#ifdef DEBUG\n\t    smsg(\"New regexp mode selected (%d): %s\",\n\t\t\t\t\t   regexp_engine, regname[newengine]);\n#endif\n\t}\n\telse\n\t{\n\t    emsg(_(e_percent_hash_can_only_be_followed_by_zero_one_two_automatic_engine_will_be_used));\n\t    regexp_engine = AUTOMATIC_ENGINE;\n\t}\n    }\n#ifdef DEBUG\n    bt_regengine.expr = expr;\n    nfa_regengine.expr = expr;\n#endif\n    // reg_iswordc() uses rex.reg_buf\n    rex.reg_buf = curbuf;\n\n    /*\n     * First try the NFA engine, unless backtracking was requested.\n     */\n    called_emsg_before = called_emsg;\n    if (regexp_engine != BACKTRACKING_ENGINE)\n\tprog = nfa_regengine.regcomp(expr,\n\t\tre_flags + (regexp_engine == AUTOMATIC_ENGINE ? RE_AUTO : 0));\n    else\n\tprog = bt_regengine.regcomp(expr, re_flags);\n\n    // Check for error compiling regexp with initial engine.\n    if (prog == NULL)\n    {\n#ifdef BT_REGEXP_DEBUG_LOG\n\tif (regexp_engine == BACKTRACKING_ENGINE)   // debugging log for BT engine\n\t{\n\t    FILE *f;\n\t    f = fopen(BT_REGEXP_DEBUG_LOG_NAME, \"a\");\n\t    if (f)\n\t    {\n\t\tfprintf(f, \"Syntax error in \\\"%s\\\"\\n\", expr);\n\t\tfclose(f);\n\t    }\n\t    else\n\t\tsemsg(\"(NFA) Could not open \\\"%s\\\" to write !!!\",\n\t\t\tBT_REGEXP_DEBUG_LOG_NAME);\n\t}\n#endif\n\t/*\n\t * If the NFA engine failed, try the backtracking engine.\n\t * The NFA engine also fails for patterns that it can't handle well\n\t * but are still valid patterns, thus a retry should work.\n\t * But don't try if an error message was given.\n\t */\n\tif (regexp_engine == AUTOMATIC_ENGINE\n\t\t\t\t\t  && called_emsg == called_emsg_before)\n\t{\n\t    regexp_engine = BACKTRACKING_ENGINE;\n#ifdef FEAT_EVAL\n\t    report_re_switch(expr);\n#endif\n\t    prog = bt_regengine.regcomp(expr, re_flags);\n\t}\n    }\n\n    if (prog != NULL)\n    {\n\t// Store the info needed to call regcomp() again when the engine turns\n\t// out to be very slow when executing it.\n\tprog->re_engine = regexp_engine;\n\tprog->re_flags  = re_flags;\n    }\n\n    return prog;\n}\n\n// modify_fname from src/filepath.c:\n    int /* <=== modify_fname */ \nmodify_fname(\n    char_u\t*src,\t\t// string with modifiers\n    int\t\ttilde_file,\t// \"~\" is a file name, not $HOME\n    int\t\t*usedlen,\t// characters after src that are used\n    char_u\t**fnamep,\t// file name so far\n    char_u\t**bufp,\t\t// buffer for allocated file name or NULL\n    int\t\t*fnamelen)\t// length of fnamep\n{\n    int\t\tvalid = 0;\n    char_u\t*tail;\n    char_u\t*s, *p, *pbuf;\n    char_u\tdirname[MAXPATHL];\n    int\t\tc;\n    int\t\thas_fullname = 0;\n    int\t\thas_homerelative = 0;\n#ifdef MSWIN\n    char_u\t*fname_start = *fnamep;\n    int\t\thas_shortname = 0;\n#endif\n\nrepeat:\n    // \":p\" - full path/file_name\n    if (src[*usedlen] == ':' && src[*usedlen + 1] == 'p')\n    {\n\thas_fullname = 1;\n\n\tvalid |= VALID_PATH;\n\t*usedlen += 2;\n\n\t// Expand \"~/path\" for all systems and \"~user/path\" for Unix and VMS\n\tif ((*fnamep)[0] == '~'\n#if !defined(UNIX) && !(defined(VMS) && defined(USER_HOME))\n\t\t&& ((*fnamep)[1] == '/'\n# ifdef BACKSLASH_IN_FILENAME\n\t\t    || (*fnamep)[1] == '\\\\'\n# endif\n\t\t    || (*fnamep)[1] == NUL)\n#endif\n\t\t&& !(tilde_file && (*fnamep)[1] == NUL)\n\t   )\n\t{\n\t    *fnamep = expand_env_save(*fnamep);\n\t    vim_free(*bufp);\t// free any allocated file name\n\t    *bufp = *fnamep;\n\t    if (*fnamep == NULL)\n\t\treturn -1;\n\t}\n\n\t// When \"/.\" or \"/..\" is used: force expansion to get rid of it.\n\tfor (p = *fnamep; *p != NUL; MB_PTR_ADV(p))\n\t{\n\t    if (vim_ispathsep(*p)\n\t\t    && p[1] == '.'\n\t\t    && (p[2] == NUL\n\t\t\t|| vim_ispathsep(p[2])\n\t\t\t|| (p[2] == '.'\n\t\t\t    && (p[3] == NUL || vim_ispathsep(p[3])))))\n\t\tbreak;\n\t}\n\n\t// FullName_save() is slow, don't use it when not needed.\n\tif (*p != NUL || !vim_isAbsName(*fnamep))\n\t{\n\t    *fnamep = FullName_save(*fnamep, *p != NUL);\n\t    vim_free(*bufp);\t// free any allocated file name\n\t    *bufp = *fnamep;\n\t    if (*fnamep == NULL)\n\t\treturn -1;\n\t}\n\n#ifdef MSWIN\n# if _WIN32_WINNT >= 0x0500\n\tif (vim_strchr(*fnamep, '~') != NULL)\n\t{\n\t    // Expand 8.3 filename to full path.  Needed to make sure the same\n\t    // file does not have two different names.\n\t    // Note: problem does not occur if _WIN32_WINNT < 0x0500.\n\t    WCHAR *wfname = enc_to_utf16(*fnamep, NULL);\n\t    WCHAR buf[_MAX_PATH];\n\n\t    if (wfname != NULL)\n\t    {\n\t\tif (GetLongPathNameW(wfname, buf, _MAX_PATH))\n\t\t{\n\t\t    char_u *q = utf16_to_enc(buf, NULL);\n\n\t\t    if (q != NULL)\n\t\t    {\n\t\t\tvim_free(*bufp);    // free any allocated file name\n\t\t\t*bufp = *fnamep = q;\n\t\t    }\n\t\t}\n\t\tvim_free(wfname);\n\t    }\n\t}\n# endif\n#endif\n\t// Append a path separator to a directory.\n\tif (mch_isdir(*fnamep))\n\t{\n\t    // Make room for one or two extra characters.\n\t    *fnamep = vim_strnsave(*fnamep, STRLEN(*fnamep) + 2);\n\t    vim_free(*bufp);\t// free any allocated file name\n\t    *bufp = *fnamep;\n\t    if (*fnamep == NULL)\n\t\treturn -1;\n\t    add_pathsep(*fnamep);\n\t}\n    }\n\n    // \":.\" - path relative to the current directory\n    // \":~\" - path relative to the home directory\n    // \":8\" - shortname path - postponed till after\n    while (src[*usedlen] == ':'\n\t\t  && ((c = src[*usedlen + 1]) == '.' || c == '~' || c == '8'))\n    {\n\t*usedlen += 2;\n\tif (c == '8')\n\t{\n#ifdef MSWIN\n\t    has_shortname = 1; // Postpone this.\n#endif\n\t    continue;\n\t}\n\tpbuf = NULL;\n\t// Need full path first (use expand_env() to remove a \"~/\")\n\tif (!has_fullname && !has_homerelative)\n\t{\n\t    if (**fnamep == '~')\n\t\tp = pbuf = expand_env_save(*fnamep);\n\t    else\n\t\tp = pbuf = FullName_save(*fnamep, FALSE);\n\t}\n\telse\n\t    p = *fnamep;\n\n\thas_fullname = 0;\n\n\tif (p != NULL)\n\t{\n\t    if (c == '.')\n\t    {\n\t\tsize_t\tnamelen;\n\n\t\tmch_dirname(dirname, MAXPATHL);\n\t\tif (has_homerelative)\n\t\t{\n\t\t    s = vim_strsave(dirname);\n\t\t    if (s != NULL)\n\t\t    {\n\t\t\thome_replace(NULL, s, dirname, MAXPATHL, TRUE);\n\t\t\tvim_free(s);\n\t\t    }\n\t\t}\n\t\tnamelen = STRLEN(dirname);\n\n\t\t// Do not call shorten_fname() here since it removes the prefix\n\t\t// even though the path does not have a prefix.\n\t\tif (fnamencmp(p, dirname, namelen) == 0)\n\t\t{\n\t\t    p += namelen;\n\t\t    if (vim_ispathsep(*p))\n\t\t    {\n\t\t\twhile (*p && vim_ispathsep(*p))\n\t\t\t    ++p;\n\t\t\t*fnamep = p;\n\t\t\tif (pbuf != NULL)\n\t\t\t{\n\t\t\t    // free any allocated file name\n\t\t\t    vim_free(*bufp);\n\t\t\t    *bufp = pbuf;\n\t\t\t    pbuf = NULL;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\thome_replace(NULL, p, dirname, MAXPATHL, TRUE);\n\t\t// Only replace it when it starts with '~'\n\t\tif (*dirname == '~')\n\t\t{\n\t\t    s = vim_strsave(dirname);\n\t\t    if (s != NULL)\n\t\t    {\n\t\t\t*fnamep = s;\n\t\t\tvim_free(*bufp);\n\t\t\t*bufp = s;\n\t\t\thas_homerelative = TRUE;\n\t\t    }\n\t\t}\n\t    }\n\t    vim_free(pbuf);\n\t}\n    }\n\n    tail = gettail(*fnamep);\n    *fnamelen = (int)STRLEN(*fnamep);\n\n    // \":h\" - head, remove \"/file_name\", can be repeated\n    // Don't remove the first \"/\" or \"c:\\\"\n    while (src[*usedlen] == ':' && src[*usedlen + 1] == 'h')\n    {\n\tvalid |= VALID_HEAD;\n\t*usedlen += 2;\n\ts = get_past_head(*fnamep);\n\twhile (tail > s && after_pathsep(s, tail))\n\t    MB_PTR_BACK(*fnamep, tail);\n\t*fnamelen = (int)(tail - *fnamep);\n#ifdef VMS\n\tif (*fnamelen > 0)\n\t    *fnamelen += 1; // the path separator is part of the path\n#endif\n\tif (*fnamelen == 0)\n\t{\n\t    // Result is empty.  Turn it into \".\" to make \":cd %:h\" work.\n\t    p = vim_strsave((char_u *)\".\");\n\t    if (p == NULL)\n\t\treturn -1;\n\t    vim_free(*bufp);\n\t    *bufp = *fnamep = tail = p;\n\t    *fnamelen = 1;\n\t}\n\telse\n\t{\n\t    while (tail > s && !after_pathsep(s, tail))\n\t\tMB_PTR_BACK(*fnamep, tail);\n\t}\n    }\n\n    // \":8\" - shortname\n    if (src[*usedlen] == ':' && src[*usedlen + 1] == '8')\n    {\n\t*usedlen += 2;\n#ifdef MSWIN\n\thas_shortname = 1;\n#endif\n    }\n\n#ifdef MSWIN\n    /*\n     * Handle \":8\" after we have done 'heads' and before we do 'tails'.\n     */\n    if (has_shortname)\n    {\n\t// Copy the string if it is shortened by :h and when it wasn't copied\n\t// yet, because we are going to change it in place.  Avoids changing\n\t// the buffer name for \"%:8\".\n\tif (*fnamelen < (int)STRLEN(*fnamep) || *fnamep == fname_start)\n\t{\n\t    p = vim_strnsave(*fnamep, *fnamelen);\n\t    if (p == NULL)\n\t\treturn -1;\n\t    vim_free(*bufp);\n\t    *bufp = *fnamep = p;\n\t}\n\n\t// Split into two implementations - makes it easier.  First is where\n\t// there isn't a full name already, second is where there is.\n\tif (!has_fullname && !vim_isAbsName(*fnamep))\n\t{\n\t    if (shortpath_for_partial(fnamep, bufp, fnamelen) == FAIL)\n\t\treturn -1;\n\t}\n\telse\n\t{\n\t    int\t\tl = *fnamelen;\n\n\t    // Simple case, already have the full-name.\n\t    // Nearly always shorter, so try first time.\n\t    if (get_short_pathname(fnamep, bufp, &l) == FAIL)\n\t\treturn -1;\n\n\t    if (l == 0)\n\t    {\n\t\t// Couldn't find the filename, search the paths.\n\t\tl = *fnamelen;\n\t\tif (shortpath_for_invalid_fname(fnamep, bufp, &l) == FAIL)\n\t\t    return -1;\n\t    }\n\t    *fnamelen = l;\n\t}\n    }\n#endif // MSWIN\n\n    // \":t\" - tail, just the basename\n    if (src[*usedlen] == ':' && src[*usedlen + 1] == 't')\n    {\n\t*usedlen += 2;\n\t*fnamelen -= (int)(tail - *fnamep);\n\t*fnamep = tail;\n    }\n\n    // \":e\" - extension, can be repeated\n    // \":r\" - root, without extension, can be repeated\n    while (src[*usedlen] == ':'\n\t    && (src[*usedlen + 1] == 'e' || src[*usedlen + 1] == 'r'))\n    {\n\t// find a '.' in the tail:\n\t// - for second :e: before the current fname\n\t// - otherwise: The last '.'\n\tif (src[*usedlen + 1] == 'e' && *fnamep > tail)\n\t    s = *fnamep - 2;\n\telse\n\t    s = *fnamep + *fnamelen - 1;\n\tfor ( ; s > tail; --s)\n\t    if (s[0] == '.')\n\t\tbreak;\n\tif (src[*usedlen + 1] == 'e')\t\t// :e\n\t{\n\t    if (s > tail)\n\t    {\n\t\t*fnamelen += (int)(*fnamep - (s + 1));\n\t\t*fnamep = s + 1;\n#ifdef VMS\n\t\t// cut version from the extension\n\t\ts = *fnamep + *fnamelen - 1;\n\t\tfor ( ; s > *fnamep; --s)\n\t\t    if (s[0] == ';')\n\t\t\tbreak;\n\t\tif (s > *fnamep)\n\t\t    *fnamelen = s - *fnamep;\n#endif\n\t    }\n\t    else if (*fnamep <= tail)\n\t\t*fnamelen = 0;\n\t}\n\telse\t\t\t\t// :r\n\t{\n\t    char_u *limit = *fnamep;\n\n\t    if (limit < tail)\n\t\tlimit = tail;\n\t    if (s > limit)\t// remove one extension\n\t\t*fnamelen = (int)(s - *fnamep);\n\t}\n\t*usedlen += 2;\n    }\n\n    // \":s?pat?foo?\" - substitute\n    // \":gs?pat?foo?\" - global substitute\n    if (src[*usedlen] == ':'\n\t    && (src[*usedlen + 1] == 's'\n\t\t|| (src[*usedlen + 1] == 'g' && src[*usedlen + 2] == 's')))\n    {\n\tchar_u\t    *str;\n\tchar_u\t    *pat;\n\tchar_u\t    *sub;\n\tint\t    sep;\n\tchar_u\t    *flags;\n\tint\t    didit = FALSE;\n\n\tflags = (char_u *)\"\";\n\ts = src + *usedlen + 2;\n\tif (src[*usedlen + 1] == 'g')\n\t{\n\t    flags = (char_u *)\"g\";\n\t    ++s;\n\t}\n\n\tsep = *s++;\n\tif (sep)\n\t{\n\t    // find end of pattern\n\t    p = vim_strchr(s, sep);\n\t    if (p != NULL)\n\t    {\n\t\tpat = vim_strnsave(s, p - s);\n\t\tif (pat != NULL)\n\t\t{\n\t\t    s = p + 1;\n\t\t    // find end of substitution\n\t\t    p = vim_strchr(s, sep);\n\t\t    if (p != NULL)\n\t\t    {\n\t\t\tsub = vim_strnsave(s, p - s);\n\t\t\tstr = vim_strnsave(*fnamep, *fnamelen);\n\t\t\tif (sub != NULL && str != NULL)\n\t\t\t{\n\t\t\t    *usedlen = (int)(p + 1 - src);\n\t\t\t    s = do_string_sub(str, pat, sub, NULL, flags);\n\t\t\t    if (s != NULL)\n\t\t\t    {\n\t\t\t\t*fnamep = s;\n\t\t\t\t*fnamelen = (int)STRLEN(s);\n\t\t\t\tvim_free(*bufp);\n\t\t\t\t*bufp = s;\n\t\t\t\tdidit = TRUE;\n\t\t\t    }\n\t\t\t}\n\t\t\tvim_free(sub);\n\t\t\tvim_free(str);\n\t\t    }\n\t\t    vim_free(pat);\n\t\t}\n\t    }\n\t    // after using \":s\", repeat all the modifiers\n\t    if (didit)\n\t\tgoto repeat;\n\t}\n    }\n\n    if (src[*usedlen] == ':' && src[*usedlen + 1] == 'S')\n    {\n\t// vim_strsave_shellescape() needs a NUL terminated string.\n\tc = (*fnamep)[*fnamelen];\n\tif (c != NUL)\n\t    (*fnamep)[*fnamelen] = NUL;\n\tp = vim_strsave_shellescape(*fnamep, FALSE, FALSE);\n\tif (c != NUL)\n\t    (*fnamep)[*fnamelen] = c;\n\tif (p == NULL)\n\t    return -1;\n\tvim_free(*bufp);\n\t*bufp = *fnamep = p;\n\t*fnamelen = (int)STRLEN(p);\n\t*usedlen += 2;\n    }\n\n    return valid;\n}\n\n// FALSE from src/vim.h:\n# define FALSE\t0\t    // note: this is an int, not a long! /* <=== src/vim.h:1472:1472:FALSE:0 */ \n\n// vim_regexec_string from src/regexp.c:\n    static int /* <=== vim_regexec_string */ \nvim_regexec_string(\n    regmatch_T\t*rmp,\n    char_u\t*line,  // string to match against\n    colnr_T\tcol,    // column to start looking for match\n    int\t\tnl)\n{\n    int\t\tresult;\n    regexec_T\trex_save;\n    int\t\trex_in_use_save = rex_in_use;\n\n    // Cannot use the same prog recursively, it contains state.\n    if (rmp->regprog->re_in_use)\n    {\n\temsg(_(e_cannot_use_pattern_recursively));\n\treturn FALSE;\n    }\n    rmp->regprog->re_in_use = TRUE;\n\n    if (rex_in_use)\n\t// Being called recursively, save the state.\n\trex_save = rex;\n    rex_in_use = TRUE;\n\n    rex.reg_startp = NULL;\n    rex.reg_endp = NULL;\n    rex.reg_startpos = NULL;\n    rex.reg_endpos = NULL;\n\n    result = rmp->regprog->engine->regexec_nl(rmp, line, col, nl);\n    rmp->regprog->re_in_use = FALSE;\n\n    // NFA engine aborted because it's very slow.\n    if (rmp->regprog->re_engine == AUTOMATIC_ENGINE\n\t\t\t\t\t       && result == NFA_TOO_EXPENSIVE)\n    {\n\tint    save_p_re = p_re;\n\tint    re_flags = rmp->regprog->re_flags;\n\tchar_u *pat = vim_strsave(((nfa_regprog_T *)rmp->regprog)->pattern);\n\n\tp_re = BACKTRACKING_ENGINE;\n\tvim_regfree(rmp->regprog);\n\tif (pat != NULL)\n\t{\n#ifdef FEAT_EVAL\n\t    report_re_switch(pat);\n#endif\n\t    rmp->regprog = vim_regcomp(pat, re_flags);\n\t    if (rmp->regprog != NULL)\n\t    {\n\t\trmp->regprog->re_in_use = TRUE;\n\t\tresult = rmp->regprog->engine->regexec_nl(rmp, line, col, nl);\n\t\trmp->regprog->re_in_use = FALSE;\n\t    }\n\t    vim_free(pat);\n\t}\n\n\tp_re = save_p_re;\n    }\n\n    rex_in_use = rex_in_use_save;\n    if (rex_in_use)\n\trex = rex_save;\n\n    return result > 0;\n}\n\n// gettail from src/filepath.c:\n    char_u * /* <=== gettail */ \ngettail(char_u *fname)\n{\n    char_u  *p1, *p2;\n\n    if (fname == NULL)\n\treturn (char_u *)\"\";\n    for (p1 = p2 = get_past_head(fname); *p2; )\t// find last part of path\n    {\n\tif (vim_ispathsep_nocolon(*p2))\n\t    p1 = p2 + 1;\n\tMB_PTR_ADV(p2);\n    }\n    return p1;\n}\n\n// skipwhite from src/charset.c:\n    char_u * /* <=== skipwhite */ \nskipwhite(char_u *q)\n{\n    char_u\t*p = q;\n\n    while (VIM_ISWHITE(*p))\n\t++p;\n    return p;\n}\n"
  },
  {
    "repository": "gpac",
    "cve_id": "CVE-2022-2453",
    "cwe_list": [
      "CWE-416"
    ],
    "commit_hash": "dc7de8d3d604426c7a6e628d90cb9fb88e7b4c2c",
    "short_hash": "dc7de8d3",
    "vulnerableMethods_before": [
      {
        "filename": "field_decode.c",
        "method_name": "vulnerable_function",
        "raw_code": "GF_Err BD_DecMFFieldVec(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node, GF_FieldInfo *field, Bool is_mem_com)\n{\n\tGF_Err e;\n\tu32 NbBits, nbFields;\n\tu32 i;\n\tGF_ChildNodeItem *last;\n\tu8 qp_local, qp_on, initial_qp;\n\tGF_FieldInfo sffield;\n\n\tmemset(&sffield, 0, sizeof(GF_FieldInfo));\n\tsffield.fieldIndex = field->fieldIndex;\n\tsffield.fieldType = gf_sg_vrml_get_sf_type(field->fieldType);\n\tsffield.NDTtype = field->NDTtype;\n\tsffield.name = field->name;\n\n\tinitial_qp = qp_local = qp_on = 0;\n\n\t//vector description - alloc the MF size before\n\tNbBits = gf_bs_read_int(bs, 5);\n\tnbFields = gf_bs_read_int(bs, NbBits);\n\n\tif (codec->ActiveQP) {\n\t\tinitial_qp = 1;\n\t\t/*this is for QP 14*/\n\t\tgf_bifs_dec_qp14_set_length(codec, nbFields);\n\t}\n\n\tif (field->fieldType != GF_SG_VRML_MFNODE) {\n\t\te = gf_sg_vrml_mf_alloc(field->far_ptr, field->fieldType, nbFields);\n\t\tif (e) return e;\n\n\t\tfor (i=0; i<nbFields; i++) {\n\t\t\te = gf_sg_vrml_mf_get_item(field->far_ptr, field->fieldType, & sffield.far_ptr, i);\n\t\t\tif (e) return e;\n\t\t\te = gf_bifs_dec_sf_field(codec, bs, node, &sffield, GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\t} else {\n\t\tlast = NULL;\n\t\tfor (i=0; i<nbFields; i++) {\n\t\t\tGF_Node *new_node = gf_bifs_dec_node(codec, bs, field->NDTtype);\n\t\t\tif (new_node) {\n\t\t\t\te = gf_node_register(new_node, is_mem_com ? NULL : node);\n\t\t\t\tif (e) return e;\n\n\t\t\t\tif (node) {\n\t\t\t\t\t/*special case for QP, register as the current QP*/\n\t\t\t\t\tif (gf_node_get_tag(new_node) == TAG_MPEG4_QuantizationParameter) {\n\t\t\t\t\t\tqp_local = ((M_QuantizationParameter *)new_node)->isLocal;\n\t\t\t\t\t\t/*we have a QP in the same scope, remove previous\n\t\t\t\t\t\tNB: we assume this is the right behavior, the spec doesn't say\n\t\t\t\t\t\twhether QP is cumulative or not*/\n\t\t\t\t\t\tif (qp_on) gf_bifs_dec_qp_remove(codec, GF_FALSE);\n\n\t\t\t\t\t\te = gf_bifs_dec_qp_set(codec, new_node);\n\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t\tqp_on = 1;\n\t\t\t\t\t\tif (qp_local) qp_local = 2;\n\t\t\t\t\t\tif (codec->force_keep_qp) {\n\t\t\t\t\t\t\te = gf_node_list_add_child_last(field->far_ptr, new_node, &last);\n\t\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_node_register(new_node, NULL);\n\t\t\t\t\t\t\tgf_node_unregister(new_node, node);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\te = gf_node_list_add_child_last(field->far_ptr, new_node, &last);\n\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*proto coding*/\n\t\t\t\telse if (codec->pCurrentProto) {\n\t\t\t\t\t/*TO DO: what happens if this is a QP node on the interface ?*/\n\t\t\t\t\te = gf_node_list_add_child_last( (GF_ChildNodeItem **)field->far_ptr, new_node, &last);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn codec->LastError ? codec->LastError : GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t}\n\t\t}\n\t\t/*according to the spec, the QP applies to the current node itself, not just children.\n\t\tIf IsLocal is TRUE remove the node*/\n\t\tif (qp_on && qp_local) {\n\t\t\tif (qp_local == 2) {\n//\t\t\t\tqp_local = 1;\n\t\t\t} else {\n\t\t\t\t//ask to get rid of QP and reactivate if we had a QP when entering the node\n\t\t\t\tgf_bifs_dec_qp_remove(codec, initial_qp);\n//\t\t\t\tqp_local = 0;\n\t\t\t}\n\t\t}\n\t}\n\t/*finally delete the QP if any (local or not) as we get out of this node*/\n\tif (qp_on) gf_bifs_dec_qp_remove(codec, GF_TRUE);\n\treturn GF_OK;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "field_decode.c",
        "method_name": "fixed_function",
        "raw_code": "GF_Err BD_DecMFFieldVec(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node, GF_FieldInfo *field, Bool is_mem_com)\n{\n\tGF_Err e;\n\tu32 NbBits, nbFields;\n\tu32 i;\n\tGF_ChildNodeItem *last;\n\tu8 qp_local, qp_on, initial_qp;\n\tGF_FieldInfo sffield;\n\n\tmemset(&sffield, 0, sizeof(GF_FieldInfo));\n\tsffield.fieldIndex = field->fieldIndex;\n\tsffield.fieldType = gf_sg_vrml_get_sf_type(field->fieldType);\n\tsffield.NDTtype = field->NDTtype;\n\tsffield.name = field->name;\n\n\tinitial_qp = qp_local = qp_on = 0;\n\n\t//vector description - alloc the MF size before\n\tNbBits = gf_bs_read_int(bs, 5);\n\tnbFields = gf_bs_read_int(bs, NbBits);\n\n\tif (codec->ActiveQP) {\n\t\tinitial_qp = 1;\n\t\t/*this is for QP 14*/\n\t\tgf_bifs_dec_qp14_set_length(codec, nbFields);\n\t}\n\n\tif (field->fieldType != GF_SG_VRML_MFNODE) {\n\t\te = gf_sg_vrml_mf_alloc(field->far_ptr, field->fieldType, nbFields);\n\t\tif (e) return e;\n\n\t\tfor (i=0; i<nbFields; i++) {\n\t\t\te = gf_sg_vrml_mf_get_item(field->far_ptr, field->fieldType, & sffield.far_ptr, i);\n\t\t\tif (e) return e;\n\t\t\te = gf_bifs_dec_sf_field(codec, bs, node, &sffield, GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\te = GF_OK;\n\tlast = NULL;\n\tfor (i=0; i<nbFields; i++) {\n\t\tGF_Node *new_node = gf_bifs_dec_node(codec, bs, field->NDTtype);\n\t\tif (new_node) {\n\t\t\te = gf_node_register(new_node, is_mem_com ? NULL : node);\n\t\t\tif (e) goto exit;\n\n\t\t\tif (node) {\n\t\t\t\t/*special case for QP, register as the current QP*/\n\t\t\t\tif (gf_node_get_tag(new_node) == TAG_MPEG4_QuantizationParameter) {\n\t\t\t\t\tqp_local = ((M_QuantizationParameter *)new_node)->isLocal;\n\t\t\t\t\t/*we have a QP in the same scope, remove previous\n\t\t\t\t\tNB: we assume this is the right behavior, the spec doesn't say\n\t\t\t\t\twhether QP is cumulative or not*/\n\t\t\t\t\tif (qp_on) gf_bifs_dec_qp_remove(codec, GF_FALSE);\n\n\t\t\t\t\te = gf_bifs_dec_qp_set(codec, new_node);\n\t\t\t\t\tif (e) goto exit;\n\t\t\t\t\tqp_on = 1;\n\t\t\t\t\tif (qp_local) qp_local = 2;\n\t\t\t\t\tif (codec->force_keep_qp) {\n\t\t\t\t\t\te = gf_node_list_add_child_last(field->far_ptr, new_node, &last);\n\t\t\t\t\t\tif (e) goto exit;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_node_register(new_node, NULL);\n\t\t\t\t\t\tgf_node_unregister(new_node, node);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\te = gf_node_list_add_child_last(field->far_ptr, new_node, &last);\n\t\t\t\t\tif (e) goto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*proto coding*/\n\t\t\telse if (codec->pCurrentProto) {\n\t\t\t\t/*TO DO: what happens if this is a QP node on the interface ?*/\n\t\t\t\te = gf_node_list_add_child_last( (GF_ChildNodeItem **)field->far_ptr, new_node, &last);\n\t\t\t\tif (e)goto exit;\n\t\t\t}\n\t\t} else {\n\t\t\te = codec->LastError ? codec->LastError : GF_NON_COMPLIANT_BITSTREAM;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\nexit:\n\n\t/*according to the spec, the QP applies to the current node itself, not just children.\n\tIf IsLocal is TRUE remove the node*/\n\tif (qp_on && qp_local) {\n\t\tif (qp_local == 2) {\n//\t\t\t\tqp_local = 1;\n\t\t} else {\n\t\t\t//ask to get rid of QP and reactivate if we had a QP when entering the node\n\t\t\tgf_bifs_dec_qp_remove(codec, initial_qp);\n//\t\t\t\tqp_local = 0;\n\t\t}\n\t}\n\n\t/*finally delete the QP if any (local or not) as we get out of this node*/\n\tif (qp_on) gf_bifs_dec_qp_remove(codec, GF_TRUE);\n\treturn e;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"quant.h\"\n#include <gpac/internal/bifs_dev.h>\n#include <gpac/scene_manager.h>\n#include \"script.h\"\n\n// Type Definitions:\n// GF_Node:\ntypedef struct _base_node\n{\n\tBASE_NODE\n} GF_Node;\n\n// u8:\ntypedef unsigned char u8;\n\n// Bool:\ntypedef enum {\n\tGF_FALSE = 0,\n\tGF_TRUE\n}\n\n// GF_ChildNodeItem:\ntypedef struct _child_node\n{\n\tstruct _child_node *next;\n\tGF_Node *node;\n} GF_ChildNodeItem;\n\n// u32:\ntypedef unsigned int u32;\n\n// GF_Err:\ntypedef enum\n{\n\t/*!Message from any scripting engine used in the presentation (ECMAScript, MPEG-J, ...) (Info).*/\n\tGF_SCRIPT_INFO                                          = 3,\n\t/*!Indicates a send packet is not dispatched due to pending connections.*/\n\tGF_PENDING_PACKET\t\t\t\t\t= 2,\n\t/*!Indicates the end of a stream or of a file (Info).*/\n\tGF_EOS\t\t\t\t\t\t\t\t= 1,\n\t/*!\n\t\\n\\n\n\t*/\n\t/*!Operation success (no error).*/\n\tGF_OK\t\t\t\t\t\t\t\t= 0,\n\t/*!\\n*/\n\t/*!One of the input parameter is not correct or cannot be used in the current operating mode of the framework.*/\n\tGF_BAD_PARAM\t\t\t\t\t\t\t= -1,\n\t/*! Memory allocation failure.*/\n\tGF_OUT_OF_MEM\t\t\t\t\t\t\t= -2,\n\t/*! Input/Output failure (disk access, system call failures)*/\n\tGF_IO_ERR\t\t\t\t\t\t\t\t= -3,\n\t/*! The desired feature or operation is not supported by the framework*/\n\tGF_NOT_SUPPORTED\t\t\t\t\t\t= -4,\n\t/*! Input data has been corrupted*/\n\tGF_CORRUPTED_DATA\t\t\t\t\t\t= -5,\n\t/*! A modification was attempted on a scene node which could not be found*/\n\tGF_SG_UNKNOWN_NODE\t\t\t\t\t\t...\n\n// GF_FieldInfo:\ntypedef struct\n{\n\t/*! 0-based index of the field in the node*/\n\tu32 fieldIndex;\n\t/*! field type - VRML/MPEG4 types are listed in scenegraph_vrml.h*/\n\tu32 fieldType;\n\t/*! far ptr to the field (eg GF_Node **, GF_List**, MFInt32 *, ...)*/\n\tvoid *far_ptr;\n\t/*! field name*/\n\tconst char *name;\n\t/*! NDT type in case of SF/MFNode field - cf BIFS specific tools*/\n\tu32 NDTtype;\n\t/*! event type*/\n\tu32 eventType;\n\t/*! eventin handler if any*/\n\tvoid (*on_event_in)(GF_Node *pNode, GF_Route *from_route);\n}\n\n// GF_BifsDecoder:\ntypedef struct __tag_bifs_dec GF_BifsDecoder;\n\n// GF_BitStream:\ntypedef struct __tag_bitstream GF_BitStream;\n\n// Called Methods (top 10):\n// NDT_V4_GetNumBits from src/bifs/bifs_node_tables.c:\nu32 NDT_V4_GetNumBits(u32 NDT_Tag) /* <=== NDT_V4_GetNumBits */ \n{\n\tswitch (NDT_Tag) {\n\tcase NDT_SFWorldNode:\n\t\treturn SFWorldNode_V4_NUMBITS;\n\tcase NDT_SF3DNode:\n\t\treturn SF3DNode_V4_NUMBITS;\n\tcase NDT_SF2DNode:\n\t\treturn SF2DNode_V4_NUMBITS;\n\tcase NDT_SFTextureNode:\n\t\treturn SFTextureNode_V4_NUMBITS;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n// gf_bifs_dec_qp_remove from src/bifs/unquantize.c:\nGF_Err gf_bifs_dec_qp_remove(GF_BifsDecoder *codec, Bool ActivatePrev) /* <=== gf_bifs_dec_qp_remove */ \n{\n\tif (!codec->force_keep_qp && codec->ActiveQP && ((GF_Node*)codec->ActiveQP != codec->scenegraph->global_qp) ) {\n\t\tgf_node_unregister((GF_Node *) codec->ActiveQP, NULL);\n\t}\n\tcodec->ActiveQP = NULL;\n\tif (!ActivatePrev) return GF_OK;\n\n\tif (gf_list_count(codec->QPs)) {\n\t\tcodec->ActiveQP = (M_QuantizationParameter*)gf_list_get(codec->QPs, 0);\n\t\tgf_list_rem(codec->QPs, 0);\n\t} else if (codec->scenegraph->global_qp) {\n\t\tcodec->ActiveQP = (M_QuantizationParameter *)codec->scenegraph->global_qp;\n\t}\n\treturn GF_OK;\n}\n\n// gf_bifs_dec_qp14_enter from src/bifs/unquantize.c:\nvoid gf_bifs_dec_qp14_enter(GF_BifsDecoder * codec, Bool Enter) /* <=== gf_bifs_dec_qp14_enter */ \n{\n\tif (!codec->ActiveQP) return;\n\tif (Enter) codec->storing_coord = GF_TRUE;\n\telse {\n\t\tif (codec->storing_coord) codec->coord_stored = GF_TRUE;\n\t\tcodec->storing_coord = GF_FALSE;\n\t}\n}\n\n// BD_OffsetSFTime from src/bifs/field_decode.c:\nvoid BD_OffsetSFTime(GF_BifsDecoder * codec, Double *time) /* <=== BD_OffsetSFTime */ \n{\n\tif ((!codec->is_com_dec && codec->pCurrentProto) || codec->dec_memory_mode) return;\n\t*time += codec->cts_offset;\n}\n\n// gf_strdup from src/utils/alloc.c:\nchar *gf_strdup(const char *str) /* <=== gf_strdup */ \n{\n\tSTRDUP(str);\n}\n\n// FREE from src/utils/alloc.c:\n#define FREE\tfree /* <=== src/utils/alloc.c:124:124:FREE:0 */ \n\n// gf_get_bit_size from src/utils/math.c:\nu32 gf_get_bit_size(u32 MaxVal) /* <=== gf_get_bit_size */ \n{\n\tu32 k=0;\n\twhile (MaxVal > (((u32)1<<k)-1) ) {\n\t\tif (k==31) {\n\t\t\treturn 32;\n\t\t}\n\t\tk+=1;\n\t}\n\treturn k;\n}\n\n// gf_node_set_callback_function from src/scenegraph/base_scenegraph.c:\nGF_Err gf_node_set_callback_function(GF_Node *p, void (*TraverseNode)(GF_Node *node, void *render_stack, Bool is_destroy) ) /* <=== gf_node_set_callback_function */ \n{\n\tassert(p);\n\tp->sgprivate->UserCallback = TraverseNode;\n\treturn GF_OK;\n}\n\n// NDT_V8_GetNodeTag from src/bifs/bifs_node_tables.c:\nu32 NDT_V8_GetNodeTag(u32 Context_NDT_Tag, u32 NodeType) /* <=== NDT_V8_GetNodeTag */ \n{\n\tif (!NodeType) return 0;\n\t/* adjust according to the table version */\n\t/* v8: 0 reserved for extensions */\n\tNodeType -= 1;\n\tswitch (Context_NDT_Tag) {\n\tcase NDT_SFWorldNode:\n\t\tif (NodeType >= SFWorldNode_V8_Count) return 0;\n\t\treturn SFWorldNode_V8_TypeToTag[NodeType];\n\tcase NDT_SF3DNode:\n\t\tif (NodeType >= SF3DNode_V8_Count) return 0;\n\t\treturn SF3DNode_V8_TypeToTag[NodeType];\n\tcase NDT_SF2DNode:\n\t\tif (NodeType >= SF2DNode_V8_Count) return 0;\n\t\treturn SF2DNode_V8_TypeToTag[NodeType];\n\tcase NDT_SFMusicScoreNode:\n\t\tif (NodeType >= SFMusicScoreNode_V8_Count) return 0;\n\t\treturn SFMusicScoreNode_V8_TypeToTag[NodeType];\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n// gf_bifs_dec_qp14_set_length from src/bifs/unquantize.c:\nvoid gf_bifs_dec_qp14_set_length(GF_BifsDecoder * codec, u32 NbElements) /* <=== gf_bifs_dec_qp14_set_length */ \n{\n\tif (!codec->ActiveQP || !codec->storing_coord || codec->coord_stored) return;\n\tcodec->NumCoord = NbElements;\n}\n"
  },
  {
    "repository": "gpac",
    "cve_id": "CVE-2021-4043",
    "cwe_list": [
      "CWE-476"
    ],
    "commit_hash": "64a2e1b799352ac7d7aad1989bc06e7b0f2b01db",
    "short_hash": "64a2e1b7",
    "vulnerableMethods_before": [
      {
        "filename": "box_code_base.c",
        "method_name": "vulnerable_function",
        "raw_code": "\nvoid gitn_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\tif (ptr == NULL) return;\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tif (ptr->entries[i].name) gf_free(ptr->entries[i].name);\n\t}\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "box_code_base.c",
        "method_name": "fixed_function",
        "raw_code": "\nvoid gitn_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->entries) {\n\t\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\t\tif (ptr->entries[i].name) gf_free(ptr->entries[i].name);\n\t\t}\n\t\tgf_free(ptr->entries);\n\t}\n\tgf_free(ptr);",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <gpac/internal/isomedia_dev.h>\n\n// Type Definitions:\n// GF_Box:\ntypedef struct\n{\n\tGF_ISOM_BOX\n}\n\n// u32:\ntypedef unsigned int u32;\n\n// GroupIdToNameBox:\ntypedef struct\n{\n\tGF_ISOM_FULL_BOX\n\tu16 nb_entries;\n\tGroupIdNameEntry *entries;\n}\n\n// Called Methods (top 10):\n// FREE from src/utils/alloc.c:\n#define FREE\tfree /* <=== src/utils/alloc.c:124:124:FREE:0 */ \n\n// gf_free from src/utils/alloc.c:\nvoid gf_free(void *ptr) /* <=== gf_free */ \n{\n\tFREE(ptr);\n}\n"
  },
  {
    "repository": "furnace",
    "cve_id": "CVE-2022-1289",
    "cwe_list": [
      "CWE-703"
    ],
    "commit_hash": "0eb02422d5161767e9983bdaa5c429762d3477ce",
    "short_hash": "0eb02422",
    "vulnerableMethods_before": [
      {
        "filename": "pattern.cpp",
        "method_name": "vulnerable_function",
        "raw_code": "inline void FurnaceGUI::patternRow(int i, bool isPlaying, float lineHeight, int chans, int ord, const DivPattern** patCache) {\n  static char id[32];\n  bool selectedRow=(i>=sel1.y && i<=sel2.y);\n  ImGui::TableNextRow(0,lineHeight);\n  ImGui::TableNextColumn();\n  float cursorPosY=ImGui::GetCursorPos().y-ImGui::GetScrollY();\n  // check if the row is visible\n  if (cursorPosY<-lineHeight || cursorPosY>ImGui::GetWindowSize().y) {\n    return;\n  }\n  // check if we are in range\n  if (ord<0 || ord>=e->song.ordersLen) {\n    return;\n  }\n  if (i<0 || i>=e->song.patLen) {\n    return;\n  }\n  bool isPushing=false;\n  ImVec4 activeColor=uiColors[GUI_COLOR_PATTERN_ACTIVE];\n  ImVec4 inactiveColor=uiColors[GUI_COLOR_PATTERN_INACTIVE];\n  ImVec4 rowIndexColor=uiColors[GUI_COLOR_PATTERN_ROW_INDEX];\n  if (e->song.hilightB>0 && !(i%e->song.hilightB)) {\n    activeColor=uiColors[GUI_COLOR_PATTERN_ACTIVE_HI2];\n    inactiveColor=uiColors[GUI_COLOR_PATTERN_INACTIVE_HI2];\n    rowIndexColor=uiColors[GUI_COLOR_PATTERN_ROW_INDEX_HI2];\n  } else if (e->song.hilightA>0 && !(i%e->song.hilightA)) {\n    activeColor=uiColors[GUI_COLOR_PATTERN_ACTIVE_HI1];\n    inactiveColor=uiColors[GUI_COLOR_PATTERN_INACTIVE_HI1];\n    rowIndexColor=uiColors[GUI_COLOR_PATTERN_ROW_INDEX_HI1];\n  }\n  // check overflow highlight\n  if (settings.overflowHighlight) {\n    if (edit && cursor.y==i) {\n      ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_EDITING]));\n    } else if (isPlaying && oldRow==i) {\n      ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_PLAY_HEAD]));\n    } else if (e->song.hilightB>0 && !(i%e->song.hilightB)) {\n      ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_2]));\n    } else if (e->song.hilightA>0 && !(i%e->song.hilightA)) {\n      ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_1]));\n    }\n  } else {\n    isPushing=true;\n    if (edit && cursor.y==i) {\n      ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_EDITING]));\n    } else if (isPlaying && oldRow==i) {\n      ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_PLAY_HEAD]));\n    } else if (e->song.hilightB>0 && !(i%e->song.hilightB)) {\n      ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_2]));\n    } else if (e->song.hilightA>0 && !(i%e->song.hilightA)) {\n      ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_1]));\n    } else {\n      isPushing=false;\n    }\n  }\n  // row number\n  if (settings.patRowsBase==1) {\n    ImGui::TextColored(rowIndexColor,\" %.2X \",i);\n  } else {\n    ImGui::TextColored(rowIndexColor,\"%3d \",i);\n  }\n  // for each column\n  for (int j=0; j<chans; j++) {\n    // check if channel is not hidden\n    if (!e->song.chanShow[j]) {\n      patChanX[j]=ImGui::GetCursorPosX();\n      continue;\n    }\n    int chanVolMax=e->getMaxVolumeChan(j);\n    if (chanVolMax<1) chanVolMax=1;\n    const DivPattern* pat=patCache[j];\n    ImGui::TableNextColumn();\n    patChanX[j]=ImGui::GetCursorPosX();\n\n    // selection highlight flags\n    int sel1XSum=sel1.xCoarse*32+sel1.xFine;\n    int sel2XSum=sel2.xCoarse*32+sel2.xFine;\n    int j32=j*32;\n    bool selectedNote=selectedRow && (j32>=sel1XSum && j32<=sel2XSum);\n    bool selectedIns=selectedRow && (j32+1>=sel1XSum && j32+1<=sel2XSum);\n    bool selectedVol=selectedRow && (j32+2>=sel1XSum && j32+2<=sel2XSum);\n    bool cursorNote=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==0);\n    bool cursorIns=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==1);\n    bool cursorVol=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==2);\n\n    // note\n    sprintf(id,\"%s##PN_%d_%d\",noteName(pat->data[i][0],pat->data[i][1]),i,j);\n    if (pat->data[i][0]==0 && pat->data[i][1]==0) {\n      ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n    } else {\n      ImGui::PushStyleColor(ImGuiCol_Text,activeColor);\n    }\n    if (cursorNote) {\n      ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);\n      ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n      ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n      ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,threeChars);\n      demandX=ImGui::GetCursorPosX();\n      ImGui::PopStyleColor(3);\n    } else {\n      if (selectedNote) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n      ImGui::Selectable(id,isPushing || selectedNote,ImGuiSelectableFlags_NoPadWithHalfSpacing,threeChars);\n      if (selectedNote) ImGui::PopStyleColor();\n    }\n    if (ImGui::IsItemClicked()) {\n      startSelection(j,0,i);\n    }\n    if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n      updateSelection(j,0,i);\n    }\n    ImGui::PopStyleColor();\n\n    // the following is only visible when the channel is not collapsed\n    if (!e->song.chanCollapse[j]) {\n      // instrument\n      if (pat->data[i][2]==-1) {\n        ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n        sprintf(id,\"..##PI_%d_%d\",i,j);\n      } else {\n        if (pat->data[i][2]<0 || pat->data[i][2]>=e->song.insLen) {\n          ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_INS_ERROR]);\n        } else {\n          DivInstrumentType t=e->song.ins[pat->data[i][2]]->type;\n          if (t!=DIV_INS_AMIGA && t!=e->getPreferInsType(j)) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_INS_WARN]);\n          } else {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_INS]);\n          }\n        }\n        sprintf(id,\"%.2X##PI_%d_%d\",pat->data[i][2],i,j);\n      }\n      ImGui::SameLine(0.0f,0.0f);\n      if (cursorIns) {\n        ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);\n        ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n        ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n        ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n        demandX=ImGui::GetCursorPosX();\n        ImGui::PopStyleColor(3);\n      } else {\n        if (selectedIns) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n        ImGui::Selectable(id,isPushing || selectedIns,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n        if (selectedIns) ImGui::PopStyleColor();\n      }\n      if (ImGui::IsItemClicked()) {\n        startSelection(j,1,i);\n      }\n      if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n        updateSelection(j,1,i);\n      }\n      ImGui::PopStyleColor();\n\n      // volume\n      if (pat->data[i][3]==-1) {\n        sprintf(id,\"..##PV_%d_%d\",i,j);\n        ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n      } else {\n        int volColor=(pat->data[i][3]*127)/chanVolMax;\n        if (volColor>127) volColor=127;\n        if (volColor<0) volColor=0;\n        sprintf(id,\"%.2X##PV_%d_%d\",pat->data[i][3],i,j);\n        ImGui::PushStyleColor(ImGuiCol_Text,volColors[volColor]);\n      }\n      ImGui::SameLine(0.0f,0.0f);\n      if (cursorVol) {\n        ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);\n        ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n        ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n        ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n        demandX=ImGui::GetCursorPosX();\n        ImGui::PopStyleColor(3);\n      } else {\n        if (selectedVol) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n        ImGui::Selectable(id,isPushing || selectedVol,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n        if (selectedVol) ImGui::PopStyleColor();\n      }\n      if (ImGui::IsItemClicked()) {\n        startSelection(j,2,i);\n      }\n      if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n        updateSelection(j,2,i);\n      }\n      ImGui::PopStyleColor();\n\n      // effects\n      for (int k=0; k<e->song.pat[j].effectRows; k++) {\n        int index=4+(k<<1);\n        bool selectedEffect=selectedRow && (j32+index-1>=sel1XSum && j32+index-1<=sel2XSum);\n        bool selectedEffectVal=selectedRow && (j32+index>=sel1XSum && j32+index<=sel2XSum);\n        bool cursorEffect=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==index-1);\n        bool cursorEffectVal=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==index);\n        \n        // effect\n        if (pat->data[i][index]==-1) {\n          sprintf(id,\"..##PE%d_%d_%d\",k,i,j);\n          ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n        } else {\n          sprintf(id,\"%.2X##PE%d_%d_%d\",pat->data[i][index],k,i,j);\n          if (pat->data[i][index]<0x10) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[fxColors[pat->data[i][index]]]);\n          } else if (pat->data[i][index]<0x20) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);\n          } else if (pat->data[i][index]<0x30) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_SECONDARY]);\n          } else if (pat->data[i][index]<0x48) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);\n          } else if (pat->data[i][index]<0x90) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n          } else if (pat->data[i][index]<0xa0) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_MISC]);\n          } else if (pat->data[i][index]<0xc0) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n          } else if (pat->data[i][index]<0xd0) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SPEED]);\n          } else if (pat->data[i][index]<0xe0) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n          } else {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[extFxColors[pat->data[i][index]-0xe0]]);\n          }\n        }\n        ImGui::SameLine(0.0f,0.0f);\n        if (cursorEffect) {\n          ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);  \n          ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n          ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n          ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n          demandX=ImGui::GetCursorPosX();\n          ImGui::PopStyleColor(3);\n        } else {\n          if (selectedEffect) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n          ImGui::Selectable(id,isPushing || selectedEffect,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n          if (selectedEffect) ImGui::PopStyleColor();\n        }\n        if (ImGui::IsItemClicked()) {\n          startSelection(j,index-1,i);\n        }\n        if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n          updateSelection(j,index-1,i);\n        }\n\n        // effect value\n        if (pat->data[i][index+1]==-1) {\n          sprintf(id,\"..##PF%d_%d_%d\",k,i,j);\n        } else {\n          sprintf(id,\"%.2X##PF%d_%d_%d\",pat->data[i][index+1],k,i,j);\n        }\n        ImGui::SameLine(0.0f,0.0f);\n        if (cursorEffectVal) {\n          ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);  \n          ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n          ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n          ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n          demandX=ImGui::GetCursorPosX();\n          ImGui::PopStyleColor(3);\n        } else {\n          if (selectedEffectVal) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n          ImGui::Selectable(id,isPushing || selectedEffectVal,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n          if (selectedEffectVal) ImGui::PopStyleColor();\n        }\n        if (ImGui::IsItemClicked()) {\n          startSelection(j,index,i);\n        }\n        if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n          updateSelection(j,index,i);\n        }\n        ImGui::PopStyleColor();\n      }\n    }\n  }\n  if (isPushing) {\n    ImGui::PopStyleColor();\n  }\n  ImGui::TableNextColumn();\n  patChanX[chans]=ImGui::GetCursorPosX();\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "pattern.cpp",
        "method_name": "fixed_function",
        "raw_code": "inline void FurnaceGUI::patternRow(int i, bool isPlaying, float lineHeight, int chans, int ord, const DivPattern** patCache) {\n  static char id[32];\n  bool selectedRow=(i>=sel1.y && i<=sel2.y);\n  ImGui::TableNextRow(0,lineHeight);\n  ImGui::TableNextColumn();\n  float cursorPosY=ImGui::GetCursorPos().y-ImGui::GetScrollY();\n  // check if the row is visible\n  if (cursorPosY<-lineHeight || cursorPosY>ImGui::GetWindowSize().y) {\n    return;\n  }\n  // check if we are in range\n  if (ord<0 || ord>=e->song.ordersLen) {\n    return;\n  }\n  if (i<0 || i>=e->song.patLen) {\n    return;\n  }\n  bool isPushing=false;\n  ImVec4 activeColor=uiColors[GUI_COLOR_PATTERN_ACTIVE];\n  ImVec4 inactiveColor=uiColors[GUI_COLOR_PATTERN_INACTIVE];\n  ImVec4 rowIndexColor=uiColors[GUI_COLOR_PATTERN_ROW_INDEX];\n  if (e->song.hilightB>0 && !(i%e->song.hilightB)) {\n    activeColor=uiColors[GUI_COLOR_PATTERN_ACTIVE_HI2];\n    inactiveColor=uiColors[GUI_COLOR_PATTERN_INACTIVE_HI2];\n    rowIndexColor=uiColors[GUI_COLOR_PATTERN_ROW_INDEX_HI2];\n  } else if (e->song.hilightA>0 && !(i%e->song.hilightA)) {\n    activeColor=uiColors[GUI_COLOR_PATTERN_ACTIVE_HI1];\n    inactiveColor=uiColors[GUI_COLOR_PATTERN_INACTIVE_HI1];\n    rowIndexColor=uiColors[GUI_COLOR_PATTERN_ROW_INDEX_HI1];\n  }\n  // check overflow highlight\n  if (settings.overflowHighlight) {\n    if (edit && cursor.y==i) {\n      ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_EDITING]));\n    } else if (isPlaying && oldRow==i) {\n      ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_PLAY_HEAD]));\n    } else if (e->song.hilightB>0 && !(i%e->song.hilightB)) {\n      ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_2]));\n    } else if (e->song.hilightA>0 && !(i%e->song.hilightA)) {\n      ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_1]));\n    }\n  } else {\n    isPushing=true;\n    if (edit && cursor.y==i) {\n      ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_EDITING]));\n    } else if (isPlaying && oldRow==i) {\n      ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_PLAY_HEAD]));\n    } else if (e->song.hilightB>0 && !(i%e->song.hilightB)) {\n      ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_2]));\n    } else if (e->song.hilightA>0 && !(i%e->song.hilightA)) {\n      ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_1]));\n    } else {\n      isPushing=false;\n    }\n  }\n  // row number\n  if (settings.patRowsBase==1) {\n    ImGui::TextColored(rowIndexColor,\" %.2X \",i);\n  } else {\n    ImGui::TextColored(rowIndexColor,\"%3d \",i);\n  }\n  // for each column\n  for (int j=0; j<chans; j++) {\n    // check if channel is not hidden\n    if (!e->song.chanShow[j]) {\n      patChanX[j]=ImGui::GetCursorPosX();\n      continue;\n    }\n    int chanVolMax=e->getMaxVolumeChan(j);\n    if (chanVolMax<1) chanVolMax=1;\n    const DivPattern* pat=patCache[j];\n    ImGui::TableNextColumn();\n    patChanX[j]=ImGui::GetCursorPosX();\n\n    // selection highlight flags\n    int sel1XSum=sel1.xCoarse*32+sel1.xFine;\n    int sel2XSum=sel2.xCoarse*32+sel2.xFine;\n    int j32=j*32;\n    bool selectedNote=selectedRow && (j32>=sel1XSum && j32<=sel2XSum);\n    bool selectedIns=selectedRow && (j32+1>=sel1XSum && j32+1<=sel2XSum);\n    bool selectedVol=selectedRow && (j32+2>=sel1XSum && j32+2<=sel2XSum);\n    bool cursorNote=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==0);\n    bool cursorIns=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==1);\n    bool cursorVol=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==2);\n\n    // note\n    sprintf(id,\"%s##PN_%d_%d\",noteName(pat->data[i][0],pat->data[i][1]),i,j);\n    if (pat->data[i][0]==0 && pat->data[i][1]==0) {\n      ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n    } else {\n      ImGui::PushStyleColor(ImGuiCol_Text,activeColor);\n    }\n    if (cursorNote) {\n      ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);\n      ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n      ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n      ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,threeChars);\n      demandX=ImGui::GetCursorPosX();\n      ImGui::PopStyleColor(3);\n    } else {\n      if (selectedNote) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n      ImGui::Selectable(id,isPushing || selectedNote,ImGuiSelectableFlags_NoPadWithHalfSpacing,threeChars);\n      if (selectedNote) ImGui::PopStyleColor();\n    }\n    if (ImGui::IsItemClicked()) {\n      startSelection(j,0,i);\n    }\n    if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n      updateSelection(j,0,i);\n    }\n    ImGui::PopStyleColor();\n\n    // the following is only visible when the channel is not collapsed\n    if (!e->song.chanCollapse[j]) {\n      // instrument\n      if (pat->data[i][2]==-1) {\n        ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n        sprintf(id,\"..##PI_%d_%d\",i,j);\n      } else {\n        if (pat->data[i][2]<0 || pat->data[i][2]>=e->song.insLen) {\n          ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_INS_ERROR]);\n        } else {\n          DivInstrumentType t=e->song.ins[pat->data[i][2]]->type;\n          if (t!=DIV_INS_AMIGA && t!=e->getPreferInsType(j)) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_INS_WARN]);\n          } else {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_INS]);\n          }\n        }\n        sprintf(id,\"%.2X##PI_%d_%d\",pat->data[i][2],i,j);\n      }\n      ImGui::SameLine(0.0f,0.0f);\n      if (cursorIns) {\n        ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);\n        ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n        ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n        ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n        demandX=ImGui::GetCursorPosX();\n        ImGui::PopStyleColor(3);\n      } else {\n        if (selectedIns) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n        ImGui::Selectable(id,isPushing || selectedIns,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n        if (selectedIns) ImGui::PopStyleColor();\n      }\n      if (ImGui::IsItemClicked()) {\n        startSelection(j,1,i);\n      }\n      if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n        updateSelection(j,1,i);\n      }\n      ImGui::PopStyleColor();\n\n      // volume\n      if (pat->data[i][3]==-1) {\n        sprintf(id,\"..##PV_%d_%d\",i,j);\n        ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n      } else {\n        int volColor=(pat->data[i][3]*127)/chanVolMax;\n        if (volColor>127) volColor=127;\n        if (volColor<0) volColor=0;\n        sprintf(id,\"%.2X##PV_%d_%d\",pat->data[i][3],i,j);\n        ImGui::PushStyleColor(ImGuiCol_Text,volColors[volColor]);\n      }\n      ImGui::SameLine(0.0f,0.0f);\n      if (cursorVol) {\n        ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);\n        ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n        ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n        ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n        demandX=ImGui::GetCursorPosX();\n        ImGui::PopStyleColor(3);\n      } else {\n        if (selectedVol) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n        ImGui::Selectable(id,isPushing || selectedVol,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n        if (selectedVol) ImGui::PopStyleColor();\n      }\n      if (ImGui::IsItemClicked()) {\n        startSelection(j,2,i);\n      }\n      if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n        updateSelection(j,2,i);\n      }\n      ImGui::PopStyleColor();\n\n      // effects\n      for (int k=0; k<e->song.pat[j].effectRows; k++) {\n        int index=4+(k<<1);\n        bool selectedEffect=selectedRow && (j32+index-1>=sel1XSum && j32+index-1<=sel2XSum);\n        bool selectedEffectVal=selectedRow && (j32+index>=sel1XSum && j32+index<=sel2XSum);\n        bool cursorEffect=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==index-1);\n        bool cursorEffectVal=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==index);\n        \n        // effect\n        if (pat->data[i][index]==-1) {\n          sprintf(id,\"..##PE%d_%d_%d\",k,i,j);\n          ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n        } else {\n          if (pat->data[i][index]>0xff) {\n            sprintf(id,\"??##PE%d_%d_%d\",k,i,j);\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n          } else {\n            const unsigned char data=pat->data[i][index];\n            sprintf(id,\"%.2X##PE%d_%d_%d\",data,k,i,j);\n            if (data<0x10) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[fxColors[data]]);\n            } else if (data<0x20) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);\n            } else if (data<0x30) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_SECONDARY]);\n            } else if (data<0x48) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);\n            } else if (data<0x90) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n            } else if (data<0xa0) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_MISC]);\n            } else if (data<0xc0) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n            } else if (data<0xd0) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SPEED]);\n            } else if (data<0xe0) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n            } else {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[extFxColors[data-0xe0]]);\n            }\n          }\n        }\n        ImGui::SameLine(0.0f,0.0f);\n        if (cursorEffect) {\n          ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);  \n          ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n          ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n          ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n          demandX=ImGui::GetCursorPosX();\n          ImGui::PopStyleColor(3);\n        } else {\n          if (selectedEffect) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n          ImGui::Selectable(id,isPushing || selectedEffect,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n          if (selectedEffect) ImGui::PopStyleColor();\n        }\n        if (ImGui::IsItemClicked()) {\n          startSelection(j,index-1,i);\n        }\n        if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n          updateSelection(j,index-1,i);\n        }\n\n        // effect value\n        if (pat->data[i][index+1]==-1) {\n          sprintf(id,\"..##PF%d_%d_%d\",k,i,j);\n        } else {\n          sprintf(id,\"%.2X##PF%d_%d_%d\",pat->data[i][index+1],k,i,j);\n        }\n        ImGui::SameLine(0.0f,0.0f);\n        if (cursorEffectVal) {\n          ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);  \n          ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n          ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n          ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n          demandX=ImGui::GetCursorPosX();\n          ImGui::PopStyleColor(3);\n        } else {\n          if (selectedEffectVal) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n          ImGui::Selectable(id,isPushing || selectedEffectVal,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n          if (selectedEffectVal) ImGui::PopStyleColor();\n        }\n        if (ImGui::IsItemClicked()) {\n          startSelection(j,index,i);\n        }\n        if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n          updateSelection(j,index,i);\n        }\n        ImGui::PopStyleColor();\n      }\n    }\n  }\n  if (isPushing) {\n    ImGui::PopStyleColor();\n  }\n  ImGui::TableNextColumn();\n  patChanX[chans]=ImGui::GetCursorPosX();\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"IconsFontAwesome4.h\"\n#include \"misc/cpp/imgui_stdlib.h\"\n#include \"../ta-log.h\"\n#include \"gui.h\"\n#include <fmt/printf.h>\n#include \"guiConst.h\"\n#include \"imgui_internal.h\"\n\n// Type Definitions:\n// FurnaceGUI:\nFurnaceGUI.FurnaceGUI:ANY()\n\n// DivPattern:\nstruct DivPattern {\n  String name;\n  short data[256][32];\n\n  /**\n   * copy this pattern to another.\n   * @param dest the destination pattern.\n   */\n  void copyOn(DivPattern* dest);\n\n  /**\n   * don't use yet!\n   * @param len the pattern length\n   * @param fxRows number of effect ...columns\n   * @return a SafeReader.\n   */\n  SafeReader* compile(int len=256, int fxRows=1);\n  DivPattern();\n}\n\n// DivPattern:\nDivPattern.DivPattern:ANY()\n\n// FurnaceGUI:\nclass FurnaceGUI {\n  DivEngine* e;\n\n  SDL_Window* sdlWin;\n  SDL_Renderer* sdlRend;\n\n  SDL_Texture* sampleTex;\n  int sampleTexW, sampleTexH;\n  bool updateSampleTex;\n\n  String workingDir, fileName, clipboard, warnString, errorString, lastError, curFileName, nextFile;\n  String workingDirSong, workingDirIns, workingDirWave, workingDirSample, workingDirAudioExport, workingDirVGMExport, workingDirFont, workingDirColors, workingDirKeybinds, workingDirLayout;\n  String mmlString[13];\n  String mmlStringW;\n\n  bool quit, warnQuit, willCommit, edit, modified, displayError, displayExporting, vgmExportLoop;\n  bool displayNew;\n  bool willExport[32];\n  int vgmExportVersion;\n\n  FurnaceGUIFileDialogs curFileDialog;\n  FurnaceGUIWarnings warnAction;\n\n  FurnaceGUIFileDialog* fileDialog;\n\n  int scrW, scrH;\n\n  double dpiScale;\n\n  double aboutScroll, aboutSin;\n  float aboutHue;\n\n  double backupTimer;\n  std::future<bool> backupTask;\n  std::mutex backupLock;\n  String backupPath;\n\n  std::mutex midiLock;\n  std:...\n"
  },
  {
    "repository": "vim",
    "cve_id": "CVE-2022-0943",
    "cwe_list": [
      "CWE-787"
    ],
    "commit_hash": "5c68617d395f9d7b824f68475b24ce3e38d653a3",
    "short_hash": "5c68617d",
    "vulnerableMethods_before": [
      {
        "filename": "spellsuggest.c",
        "method_name": "vulnerable_function",
        "raw_code": "spell_suggest(int count)\n{\n    char_u\t*line;\n    pos_T\tprev_cursor = curwin->w_cursor;\n    char_u\twcopy[MAXWLEN + 2];\n    char_u\t*p;\n    int\t\ti;\n    int\t\tc;\n    suginfo_T\tsug;\n    suggest_T\t*stp;\n    int\t\tmouse_used;\n    int\t\tneed_cap;\n    int\t\tlimit;\n    int\t\tselected = count;\n    int\t\tbadlen = 0;\n    int\t\tmsg_scroll_save = msg_scroll;\n    int\t\two_spell_save = curwin->w_p_spell;\n\n    if (!curwin->w_p_spell)\n    {\n\tdid_set_spelllang(curwin);\n\tcurwin->w_p_spell = TRUE;\n    }\n\n    if (*curwin->w_s->b_p_spl == NUL)\n    {\n\temsg(_(e_spell_checking_is_not_possible));\n\treturn;\n    }\n\n    if (VIsual_active)\n    {\n\t// Use the Visually selected text as the bad word.  But reject\n\t// a multi-line selection.\n\tif (curwin->w_cursor.lnum != VIsual.lnum)\n\t{\n\t    vim_beep(BO_SPELL);\n\t    return;\n\t}\n\tbadlen = (int)curwin->w_cursor.col - (int)VIsual.col;\n\tif (badlen < 0)\n\t    badlen = -badlen;\n\telse\n\t    curwin->w_cursor.col = VIsual.col;\n\t++badlen;\n\tend_visual_mode();\n    }\n    // Find the start of the badly spelled word.\n    else if (spell_move_to(curwin, FORWARD, TRUE, TRUE, NULL) == 0\n\t    || curwin->w_cursor.col > prev_cursor.col)\n    {\n\t// No bad word or it starts after the cursor: use the word under the\n\t// cursor.\n\tcurwin->w_cursor = prev_cursor;\n\tline = ml_get_curline();\n\tp = line + curwin->w_cursor.col;\n\t// Backup to before start of word.\n\twhile (p > line && spell_iswordp_nmw(p, curwin))\n\t    MB_PTR_BACK(line, p);\n\t// Forward to start of word.\n\twhile (*p != NUL && !spell_iswordp_nmw(p, curwin))\n\t    MB_PTR_ADV(p);\n\n\tif (!spell_iswordp_nmw(p, curwin))\t\t// No word found.\n\t{\n\t    beep_flush();\n\t    return;\n\t}\n\tcurwin->w_cursor.col = (colnr_T)(p - line);\n    }\n\n    // Get the word and its length.\n\n    // Figure out if the word should be capitalised.\n    need_cap = check_need_cap(curwin->w_cursor.lnum, curwin->w_cursor.col);\n\n    // Make a copy of current line since autocommands may free the line.\n    line = vim_strsave(ml_get_curline());\n    if (line == NULL)\n\tgoto skip;\n\n    // Get the list of suggestions.  Limit to 'lines' - 2 or the number in\n    // 'spellsuggest', whatever is smaller.\n    if (sps_limit > (int)Rows - 2)\n\tlimit = (int)Rows - 2;\n    else\n\tlimit = sps_limit;\n    spell_find_suggest(line + curwin->w_cursor.col, badlen, &sug, limit,\n\t\t\t\t\t\t\tTRUE, need_cap, TRUE);\n\n    if (sug.su_ga.ga_len == 0)\n\tmsg(_(\"Sorry, no suggestions\"));\n    else if (count > 0)\n    {\n\tif (count > sug.su_ga.ga_len)\n\t    smsg(_(\"Sorry, only %ld suggestions\"), (long)sug.su_ga.ga_len);\n    }\n    else\n    {\n#ifdef FEAT_RIGHTLEFT\n\t// When 'rightleft' is set the list is drawn right-left.\n\tcmdmsg_rl = curwin->w_p_rl;\n\tif (cmdmsg_rl)\n\t    msg_col = Columns - 1;\n#endif\n\n\t// List the suggestions.\n\tmsg_start();\n\tmsg_row = Rows - 1;\t// for when 'cmdheight' > 1\n\tlines_left = Rows;\t// avoid more prompt\n\tvim_snprintf((char *)IObuff, IOSIZE, _(\"Change \\\"%.*s\\\" to:\"),\n\t\t\t\t\t\tsug.su_badlen, sug.su_badptr);\n#ifdef FEAT_RIGHTLEFT\n\tif (cmdmsg_rl && STRNCMP(IObuff, \"Change\", 6) == 0)\n\t{\n\t    // And now the rabbit from the high hat: Avoid showing the\n\t    // untranslated message rightleft.\n\t    vim_snprintf((char *)IObuff, IOSIZE, \":ot \\\"%.*s\\\" egnahC\",\n\t\t\t\t\t\tsug.su_badlen, sug.su_badptr);\n\t}\n#endif\n\tmsg_puts((char *)IObuff);\n\tmsg_clr_eos();\n\tmsg_putchar('\\n');\n\n\tmsg_scroll = TRUE;\n\tfor (i = 0; i < sug.su_ga.ga_len; ++i)\n\t{\n\t    stp = &SUG(sug.su_ga, i);\n\n\t    // The suggested word may replace only part of the bad word, add\n\t    // the not replaced part.\n\t    vim_strncpy(wcopy, stp->st_word, MAXWLEN);\n\t    if (sug.su_badlen > stp->st_orglen)\n\t\tvim_strncpy(wcopy + stp->st_wordlen,\n\t\t\t\t\t       sug.su_badptr + stp->st_orglen,\n\t\t\t\t\t      sug.su_badlen - stp->st_orglen);\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"%2d\", i + 1);\n#ifdef FEAT_RIGHTLEFT\n\t    if (cmdmsg_rl)\n\t\trl_mirror(IObuff);\n#endif\n\t    msg_puts((char *)IObuff);\n\n\t    vim_snprintf((char *)IObuff, IOSIZE, \" \\\"%s\\\"\", wcopy);\n\t    msg_puts((char *)IObuff);\n\n\t    // The word may replace more than \"su_badlen\".\n\t    if (sug.su_badlen < stp->st_orglen)\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, _(\" < \\\"%.*s\\\"\"),\n\t\t\t\t\t       stp->st_orglen, sug.su_badptr);\n\t\tmsg_puts((char *)IObuff);\n\t    }\n\n\t    if (p_verbose > 0)\n\t    {\n\t\t// Add the score.\n\t\tif (sps_flags & (SPS_DOUBLE | SPS_BEST))\n\t\t    vim_snprintf((char *)IObuff, IOSIZE, \" (%s%d - %d)\",\n\t\t\tstp->st_salscore ? \"s \" : \"\",\n\t\t\tstp->st_score, stp->st_altscore);\n\t\telse\n\t\t    vim_snprintf((char *)IObuff, IOSIZE, \" (%d)\",\n\t\t\t    stp->st_score);\n#ifdef FEAT_RIGHTLEFT\n\t\tif (cmdmsg_rl)\n\t\t    // Mirror the numbers, but keep the leading space.\n\t\t    rl_mirror(IObuff + 1);\n#endif\n\t\tmsg_advance(30);\n\t\tmsg_puts((char *)IObuff);\n\t    }\n\t    msg_putchar('\\n');\n\t}\n\n#ifdef FEAT_RIGHTLEFT\n\tcmdmsg_rl = FALSE;\n\tmsg_col = 0;\n#endif\n\t// Ask for choice.\n\tselected = prompt_for_number(&mouse_used);\n\tif (mouse_used)\n\t    selected -= lines_left;\n\tlines_left = Rows;\t\t// avoid more prompt\n\t// don't delay for 'smd' in normal_cmd()\n\tmsg_scroll = msg_scroll_save;\n    }\n\n    if (selected > 0 && selected <= sug.su_ga.ga_len && u_save_cursor() == OK)\n    {\n\t// Save the from and to text for :spellrepall.\n\tVIM_CLEAR(repl_from);\n\tVIM_CLEAR(repl_to);\n\n\tstp = &SUG(sug.su_ga, selected - 1);\n\tif (sug.su_badlen > stp->st_orglen)\n\t{\n\t    // Replacing less than \"su_badlen\", append the remainder to\n\t    // repl_to.\n\t    repl_from = vim_strnsave(sug.su_badptr, sug.su_badlen);\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"%s%.*s\", stp->st_word,\n\t\t    sug.su_badlen - stp->st_orglen,\n\t\t\t\t\t      sug.su_badptr + stp->st_orglen);\n\t    repl_to = vim_strsave(IObuff);\n\t}\n\telse\n\t{\n\t    // Replacing su_badlen or more, use the whole word.\n\t    repl_from = vim_strnsave(sug.su_badptr, stp->st_orglen);\n\t    repl_to = vim_strsave(stp->st_word);\n\t}\n\n\t// Replace the word.\n\tp = alloc(STRLEN(line) - stp->st_orglen + stp->st_wordlen + 1);\n\tif (p != NULL)\n\t{\n\t    c = (int)(sug.su_badptr - line);\n\t    mch_memmove(p, line, c);\n\t    STRCPY(p + c, stp->st_word);\n\t    STRCAT(p, sug.su_badptr + stp->st_orglen);\n\n\t    // For redo we use a change-word command.\n\t    ResetRedobuff();\n\t    AppendToRedobuff((char_u *)\"ciw\");\n\t    AppendToRedobuffLit(p + c,\n\t\t\t    stp->st_wordlen + sug.su_badlen - stp->st_orglen);\n\t    AppendCharToRedobuff(ESC);\n\n\t    // \"p\" may be freed here\n\t    ml_replace(curwin->w_cursor.lnum, p, FALSE);\n\t    curwin->w_cursor.col = c;\n\n\t    changed_bytes(curwin->w_cursor.lnum, c);\n\t}\n    }\n    else\n\tcurwin->w_cursor = prev_cursor;\n\n    spell_find_cleanup(&sug);\nskip:\n    vim_free(line);\n    curwin->w_p_spell = wo_spell_save;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "spellsuggest.c",
        "method_name": "fixed_function",
        "raw_code": "spell_suggest(int count)\n{\n    char_u\t*line;\n    pos_T\tprev_cursor = curwin->w_cursor;\n    char_u\twcopy[MAXWLEN + 2];\n    char_u\t*p;\n    int\t\ti;\n    int\t\tc;\n    suginfo_T\tsug;\n    suggest_T\t*stp;\n    int\t\tmouse_used;\n    int\t\tneed_cap;\n    int\t\tlimit;\n    int\t\tselected = count;\n    int\t\tbadlen = 0;\n    int\t\tmsg_scroll_save = msg_scroll;\n    int\t\two_spell_save = curwin->w_p_spell;\n\n    if (!curwin->w_p_spell)\n    {\n\tdid_set_spelllang(curwin);\n\tcurwin->w_p_spell = TRUE;\n    }\n\n    if (*curwin->w_s->b_p_spl == NUL)\n    {\n\temsg(_(e_spell_checking_is_not_possible));\n\treturn;\n    }\n\n    if (VIsual_active)\n    {\n\t// Use the Visually selected text as the bad word.  But reject\n\t// a multi-line selection.\n\tif (curwin->w_cursor.lnum != VIsual.lnum)\n\t{\n\t    vim_beep(BO_SPELL);\n\t    return;\n\t}\n\tbadlen = (int)curwin->w_cursor.col - (int)VIsual.col;\n\tif (badlen < 0)\n\t    badlen = -badlen;\n\telse\n\t    curwin->w_cursor.col = VIsual.col;\n\t++badlen;\n\tend_visual_mode();\n\t// make sure we don't include the NUL at the end of the line\n\tline = ml_get_curline();\n\tif (badlen > STRLEN(line) - curwin->w_cursor.col)\n\t    badlen = STRLEN(line) - curwin->w_cursor.col;\n    }\n    // Find the start of the badly spelled word.\n    else if (spell_move_to(curwin, FORWARD, TRUE, TRUE, NULL) == 0\n\t    || curwin->w_cursor.col > prev_cursor.col)\n    {\n\t// No bad word or it starts after the cursor: use the word under the\n\t// cursor.\n\tcurwin->w_cursor = prev_cursor;\n\tline = ml_get_curline();\n\tp = line + curwin->w_cursor.col;\n\t// Backup to before start of word.\n\twhile (p > line && spell_iswordp_nmw(p, curwin))\n\t    MB_PTR_BACK(line, p);\n\t// Forward to start of word.\n\twhile (*p != NUL && !spell_iswordp_nmw(p, curwin))\n\t    MB_PTR_ADV(p);\n\n\tif (!spell_iswordp_nmw(p, curwin))\t\t// No word found.\n\t{\n\t    beep_flush();\n\t    return;\n\t}\n\tcurwin->w_cursor.col = (colnr_T)(p - line);\n    }\n\n    // Get the word and its length.\n\n    // Figure out if the word should be capitalised.\n    need_cap = check_need_cap(curwin->w_cursor.lnum, curwin->w_cursor.col);\n\n    // Make a copy of current line since autocommands may free the line.\n    line = vim_strsave(ml_get_curline());\n    if (line == NULL)\n\tgoto skip;\n\n    // Get the list of suggestions.  Limit to 'lines' - 2 or the number in\n    // 'spellsuggest', whatever is smaller.\n    if (sps_limit > (int)Rows - 2)\n\tlimit = (int)Rows - 2;\n    else\n\tlimit = sps_limit;\n    spell_find_suggest(line + curwin->w_cursor.col, badlen, &sug, limit,\n\t\t\t\t\t\t\tTRUE, need_cap, TRUE);\n\n    if (sug.su_ga.ga_len == 0)\n\tmsg(_(\"Sorry, no suggestions\"));\n    else if (count > 0)\n    {\n\tif (count > sug.su_ga.ga_len)\n\t    smsg(_(\"Sorry, only %ld suggestions\"), (long)sug.su_ga.ga_len);\n    }\n    else\n    {\n#ifdef FEAT_RIGHTLEFT\n\t// When 'rightleft' is set the list is drawn right-left.\n\tcmdmsg_rl = curwin->w_p_rl;\n\tif (cmdmsg_rl)\n\t    msg_col = Columns - 1;\n#endif\n\n\t// List the suggestions.\n\tmsg_start();\n\tmsg_row = Rows - 1;\t// for when 'cmdheight' > 1\n\tlines_left = Rows;\t// avoid more prompt\n\tvim_snprintf((char *)IObuff, IOSIZE, _(\"Change \\\"%.*s\\\" to:\"),\n\t\t\t\t\t\tsug.su_badlen, sug.su_badptr);\n#ifdef FEAT_RIGHTLEFT\n\tif (cmdmsg_rl && STRNCMP(IObuff, \"Change\", 6) == 0)\n\t{\n\t    // And now the rabbit from the high hat: Avoid showing the\n\t    // untranslated message rightleft.\n\t    vim_snprintf((char *)IObuff, IOSIZE, \":ot \\\"%.*s\\\" egnahC\",\n\t\t\t\t\t\tsug.su_badlen, sug.su_badptr);\n\t}\n#endif\n\tmsg_puts((char *)IObuff);\n\tmsg_clr_eos();\n\tmsg_putchar('\\n');\n\n\tmsg_scroll = TRUE;\n\tfor (i = 0; i < sug.su_ga.ga_len; ++i)\n\t{\n\t    stp = &SUG(sug.su_ga, i);\n\n\t    // The suggested word may replace only part of the bad word, add\n\t    // the not replaced part.\n\t    vim_strncpy(wcopy, stp->st_word, MAXWLEN);\n\t    if (sug.su_badlen > stp->st_orglen)\n\t\tvim_strncpy(wcopy + stp->st_wordlen,\n\t\t\t\t\t       sug.su_badptr + stp->st_orglen,\n\t\t\t\t\t      sug.su_badlen - stp->st_orglen);\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"%2d\", i + 1);\n#ifdef FEAT_RIGHTLEFT\n\t    if (cmdmsg_rl)\n\t\trl_mirror(IObuff);\n#endif\n\t    msg_puts((char *)IObuff);\n\n\t    vim_snprintf((char *)IObuff, IOSIZE, \" \\\"%s\\\"\", wcopy);\n\t    msg_puts((char *)IObuff);\n\n\t    // The word may replace more than \"su_badlen\".\n\t    if (sug.su_badlen < stp->st_orglen)\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, _(\" < \\\"%.*s\\\"\"),\n\t\t\t\t\t       stp->st_orglen, sug.su_badptr);\n\t\tmsg_puts((char *)IObuff);\n\t    }\n\n\t    if (p_verbose > 0)\n\t    {\n\t\t// Add the score.\n\t\tif (sps_flags & (SPS_DOUBLE | SPS_BEST))\n\t\t    vim_snprintf((char *)IObuff, IOSIZE, \" (%s%d - %d)\",\n\t\t\tstp->st_salscore ? \"s \" : \"\",\n\t\t\tstp->st_score, stp->st_altscore);\n\t\telse\n\t\t    vim_snprintf((char *)IObuff, IOSIZE, \" (%d)\",\n\t\t\t    stp->st_score);\n#ifdef FEAT_RIGHTLEFT\n\t\tif (cmdmsg_rl)\n\t\t    // Mirror the numbers, but keep the leading space.\n\t\t    rl_mirror(IObuff + 1);\n#endif\n\t\tmsg_advance(30);\n\t\tmsg_puts((char *)IObuff);\n\t    }\n\t    msg_putchar('\\n');\n\t}\n\n#ifdef FEAT_RIGHTLEFT\n\tcmdmsg_rl = FALSE;\n\tmsg_col = 0;\n#endif\n\t// Ask for choice.\n\tselected = prompt_for_number(&mouse_used);\n\tif (mouse_used)\n\t    selected -= lines_left;\n\tlines_left = Rows;\t\t// avoid more prompt\n\t// don't delay for 'smd' in normal_cmd()\n\tmsg_scroll = msg_scroll_save;\n    }\n\n    if (selected > 0 && selected <= sug.su_ga.ga_len && u_save_cursor() == OK)\n    {\n\t// Save the from and to text for :spellrepall.\n\tVIM_CLEAR(repl_from);\n\tVIM_CLEAR(repl_to);\n\n\tstp = &SUG(sug.su_ga, selected - 1);\n\tif (sug.su_badlen > stp->st_orglen)\n\t{\n\t    // Replacing less than \"su_badlen\", append the remainder to\n\t    // repl_to.\n\t    repl_from = vim_strnsave(sug.su_badptr, sug.su_badlen);\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"%s%.*s\", stp->st_word,\n\t\t    sug.su_badlen - stp->st_orglen,\n\t\t\t\t\t      sug.su_badptr + stp->st_orglen);\n\t    repl_to = vim_strsave(IObuff);\n\t}\n\telse\n\t{\n\t    // Replacing su_badlen or more, use the whole word.\n\t    repl_from = vim_strnsave(sug.su_badptr, stp->st_orglen);\n\t    repl_to = vim_strsave(stp->st_word);\n\t}\n\n\t// Replace the word.\n\tp = alloc(STRLEN(line) - stp->st_orglen + stp->st_wordlen + 1);\n\tif (p != NULL)\n\t{\n\t    c = (int)(sug.su_badptr - line);\n\t    mch_memmove(p, line, c);\n\t    STRCPY(p + c, stp->st_word);\n\t    STRCAT(p, sug.su_badptr + stp->st_orglen);\n\n\t    // For redo we use a change-word command.\n\t    ResetRedobuff();\n\t    AppendToRedobuff((char_u *)\"ciw\");\n\t    AppendToRedobuffLit(p + c,\n\t\t\t    stp->st_wordlen + sug.su_badlen - stp->st_orglen);\n\t    AppendCharToRedobuff(ESC);\n\n\t    // \"p\" may be freed here\n\t    ml_replace(curwin->w_cursor.lnum, p, FALSE);\n\t    curwin->w_cursor.col = c;\n\n\t    changed_bytes(curwin->w_cursor.lnum, c);\n\t}\n    }\n    else\n\tcurwin->w_cursor = prev_cursor;\n\n    spell_find_cleanup(&sug);\nskip:\n    vim_free(line);\n    curwin->w_p_spell = wo_spell_save;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"vim.h\"\n\n// Type Definitions:\n// suggest_T:\ntypedef struct suggest_S\n{\n    char_u\t*st_word;\t// suggested word, allocated string\n    int\t\tst_wordlen;\t// STRLEN(st_word)\n    int\t\tst_orglen;\t// length of replaced text\n    int\t\tst_score;\t// lower is better\n    int\t\tst_altscore;\t// used when st_score compares equal\n    int\t\tst_salscore;\t// st_score is for soundalike\n    int\t\tst_had_bonus;\t// bonus already included in score\n    slang_T\t*st_slang;\t// language used for sound folding\n} suggest_T;\n\n// char_u:\ntypedef unsigned char\tchar_u;\n\n// pos_T:\ntypedef struct\n{\n    linenr_T\tlnum;\t// line number\n    colnr_T\tcol;\t// column number\n    colnr_T\tcoladd; // extra virtual column\n}\n\n// suginfo_T:\ntypedef struct suginfo_S\n{\n    garray_T\tsu_ga;\t\t    // suggestions, contains \"suggest_T\"\n    int\t\tsu_maxcount;\t    // max. number of suggestions displayed\n    int\t\tsu_maxscore;\t    // maximum score for adding to su_ga\n    int\t\tsu_sfmaxscore;\t    // idem, for when doing soundfold words\n    garray_T\tsu_sga;\t\t    // like su_ga, sound-folded scoring\n    char_u\t*su_badptr;\t    // start of bad word in line\n    int\t\tsu_badlen;\t    // length of detected bad word in line\n    int\t\tsu_badflags;\t    // caps flags for bad word\n    char_u\tsu_badword[MAXWLEN]; // bad word truncated at su_badlen\n    char_u\tsu_fbadword[MAXWLEN]; // su_badword case-folded\n    char_u\tsu_sal_badword[MAXWLEN]; // su_badword soundfolded\n    hashtab_T\tsu_banned;\t    // table with banned words\n    slang_T\t*su_sallang;\t    // default language for sound folding\n} suginfo_T;\n\n// Called Methods (top 10):\n// ga_clear from src/alloc.c:\n    void /* <=== ga_clear */ \nga_clear(garray_T *gap)\n{\n    vim_free(gap->ga_data);\n    ga_init(gap);\n}\n\n// JUMPLISTSIZE from src/structs.h:\n#define JUMPLISTSIZE\t100\t\t// max. # of marks in jump list /* <=== src/structs.h:141:141:JUMPLISTSIZE:0 */ \n\n// SCORE_SFMAX3 from src/spellsuggest.c:\n#define SCORE_SFMAX3\t400\t// maximum score for third try /* <=== src/spellsuggest.c:119:119:SCORE_SFMAX3:0 */ \n\n// eval_spell_expr from src/evalvars.c:\n    list_T * /* <=== eval_spell_expr */ \neval_spell_expr(char_u *badword, char_u *expr)\n{\n    typval_T\tsave_val;\n    typval_T\trettv;\n    list_T\t*list = NULL;\n    char_u\t*p = skipwhite(expr);\n    sctx_T\tsaved_sctx = current_sctx;\n    sctx_T\t*ctx;\n\n    // Set \"v:val\" to the bad word.\n    prepare_vimvar(VV_VAL, &save_val);\n    set_vim_var_string(VV_VAL, badword, -1);\n    if (p_verbose == 0)\n\t++emsg_off;\n    ctx = get_option_sctx(\"spellsuggest\");\n    if (ctx != NULL)\n\tcurrent_sctx = *ctx;\n\n    if (eval1(&p, &rettv, &EVALARG_EVALUATE) == OK)\n    {\n\tif (rettv.v_type != VAR_LIST)\n\t    clear_tv(&rettv);\n\telse\n\t    list = rettv.vval.v_list;\n    }\n\n    if (p_verbose == 0)\n\t--emsg_off;\n    clear_tv(get_vim_var_tv(VV_VAL));\n    restore_vimvar(VV_VAL, &save_val);\n    current_sctx = saved_sctx;\n\n    return list;\n}\n\n// siemsg from src/message.c:\n    void /* <=== siemsg */ \nsiemsg(const char *s, ...)\n{\n    if (!emsg_not_now())\n    {\n\tif (IObuff == NULL)\n\t{\n\t    // Very early in initialisation and already something wrong, just\n\t    // give the raw message so the user at least gets a hint.\n\t    emsg_core((char_u *)s);\n\t}\n\telse\n\t{\n\t    va_list ap;\n\n\t    va_start(ap, s);\n\t    vim_vsnprintf((char *)IObuff, IOSIZE, s, ap);\n\t    va_end(ap);\n\t    emsg_core(IObuff);\n\t}\n    }\n# ifdef ABORT_ON_INTERNAL_ERROR\n    abort();\n# endif\n}\n\n// spell_suggest_expr from src/spellsuggest.c:\n    static void /* <=== spell_suggest_expr */ \nspell_suggest_expr(suginfo_T *su, char_u *expr)\n{\n    list_T\t*list;\n    listitem_T\t*li;\n    int\t\tscore;\n    char_u\t*p;\n\n    // The work is split up in a few parts to avoid having to export\n    // suginfo_T.\n    // First evaluate the expression and get the resulting list.\n    list = eval_spell_expr(su->su_badword, expr);\n    if (list != NULL)\n    {\n\t// Loop over the items in the list.\n\tFOR_ALL_LIST_ITEMS(list, li)\n\t    if (li->li_tv.v_type == VAR_LIST)\n\t    {\n\t\t// Get the word and the score from the items.\n\t\tscore = get_spellword(li->li_tv.vval.v_list, &p);\n\t\tif (score >= 0 && score <= su->su_maxscore)\n\t\t    add_suggestion(su, &su->su_ga, p, su->su_badlen,\n\t\t\t\t       score, 0, TRUE, su->su_sallang, FALSE);\n\t    }\n\tlist_unref(list);\n    }\n\n    // Remove bogus suggestions, sort and truncate at \"maxcount\".\n    check_suggestions(su, &su->su_ga);\n    (void)cleanup_suggestions(&su->su_ga, su->su_maxscore, su->su_maxcount);\n}\n\n// set_topline from src/move.c:\n    void /* <=== set_topline */ \nset_topline(win_T *wp, linenr_T lnum)\n{\n#ifdef FEAT_DIFF\n    linenr_T prev_topline = wp->w_topline;\n#endif\n\n#ifdef FEAT_FOLDING\n    // go to first of folded lines\n    (void)hasFoldingWin(wp, lnum, &lnum, NULL, TRUE, NULL);\n#endif\n    // Approximate the value of w_botline\n    wp->w_botline += lnum - wp->w_topline;\n    if (wp->w_botline > wp->w_buffer->b_ml.ml_line_count + 1)\n\twp->w_botline = wp->w_buffer->b_ml.ml_line_count + 1;\n    wp->w_topline = lnum;\n    wp->w_topline_was_set = TRUE;\n#ifdef FEAT_DIFF\n    if (lnum != prev_topline)\n\t// Keep the filler lines when the topline didn't change.\n\twp->w_topfill = 0;\n#endif\n    wp->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE|VALID_TOPLINE);\n    // Don't set VALID_TOPLINE here, 'scrolloff' needs to be checked.\n    redraw_later(VALID);\n}\n\n// utf_tolower from src/mbyte.c:\n    int /* <=== utf_tolower */ \nutf_tolower(int a)\n{\n    // If 'casemap' contains \"keepascii\" use ASCII style tolower().\n    if (a < 128 && (cmp_flags & CMP_KEEPASCII))\n\treturn TOLOWER_ASC(a);\n\n#if defined(HAVE_TOWLOWER) && defined(__STDC_ISO_10646__)\n    // If towlower() is available and handles Unicode, use it.\n    if (!(cmp_flags & CMP_INTERNAL))\n\treturn towlower(a);\n#endif\n\n    // For characters below 128 use locale sensitive tolower().\n    if (a < 128)\n\treturn TOLOWER_LOC(a);\n\n    // For any other characters use the above mapping table.\n    return utf_convert(a, toLower, (int)sizeof(toLower));\n}\n\n// ResetRedobuff from src/getchar.c:\nvoid\nResetRedobuff(void)\n{\n    if (!block_redo)\n    {\n\tfree_buff(&old_redobuff);\n\told_redobuff = redobuff;\n\tredobuff.bh_first.b_next = NULL;\n    }\n}\n\n// spell_soundfold_wsal from src/spell.c:\n    static void /* <=== spell_soundfold_wsal */ \nspell_soundfold_wsal(slang_T *slang, char_u *inword, char_u *res)\n{\n    salitem_T\t*smp = (salitem_T *)slang->sl_sal.ga_data;\n    int\t\tword[MAXWLEN];\n    int\t\twres[MAXWLEN];\n    int\t\tl;\n    char_u\t*s;\n    int\t\t*ws;\n    char_u\t*t;\n    int\t\t*pf;\n    int\t\ti, j, z;\n    int\t\treslen;\n    int\t\tn, k = 0;\n    int\t\tz0;\n    int\t\tk0;\n    int\t\tn0;\n    int\t\tc;\n    int\t\tpri;\n    int\t\tp0 = -333;\n    int\t\tc0;\n    int\t\tdid_white = FALSE;\n    int\t\twordlen;\n\n\n    /*\n     * Convert the multi-byte string to a wide-character string.\n     * Remove accents, if wanted.  We actually remove all non-word characters.\n     * But keep white space.\n     */\n    wordlen = 0;\n    for (s = inword; *s != NUL; )\n    {\n\tt = s;\n\tc = mb_cptr2char_adv(&s);\n\tif (slang->sl_rem_accents)\n\t{\n\t    if (enc_utf8 ? utf_class(c) == 0 : VIM_ISWHITE(c))\n\t    {\n\t\tif (did_white)\n\t\t    continue;\n\t\tc = ' ';\n\t\tdid_white = TRUE;\n\t    }\n\t    else\n\t    {\n\t\tdid_white = FALSE;\n\t\tif (!spell_iswordp_nmw(t, curwin))\n\t\t    continue;\n\t    }\n\t}\n\tword[wordlen++] = c;\n    }\n    word[wordlen] = NUL;\n\n    /*\n     * This algorithm comes from Aspell phonet.cpp.\n     * Converted from C++ to C.  Added support for multi-byte chars.\n     * Changed to keep spaces.\n     */\n    i = reslen = z = 0;\n    while ((c = word[i]) != NUL)\n    {\n\t// Start with the first rule that has the character in the word.\n\tn = slang->sl_sal_first[c & 0xff];\n\tz0 = 0;\n\n\tif (n >= 0)\n\t{\n\t    // Check all rules for the same index byte.\n\t    // If c is 0x300 need extra check for the end of the array, as\n\t    // (c & 0xff) is NUL.\n\t    for (; ((ws = smp[n].sm_lead_w)[0] & 0xff) == (c & 0xff)\n\t\t\t\t\t\t\t && ws[0] != NUL; ++n)\n\t    {\n\t\t// Quickly skip entries that don't match the word.  Most\n\t\t// entries are less than three chars, optimize for that.\n\t\tif (c != ws[0])\n\t\t    continue;\n\t\tk = smp[n].sm_leadlen;\n\t\tif (k > 1)\n\t\t{\n\t\t    if (word[i + 1] != ws[1])\n\t\t\tcontinue;\n\t\t    if (k > 2)\n\t\t    {\n\t\t\tfor (j = 2; j < k; ++j)\n\t\t\t    if (word[i + j] != ws[j])\n\t\t\t\tbreak;\n\t\t\tif (j < k)\n\t\t\t    continue;\n\t\t    }\n\t\t}\n\n\t\tif ((pf = smp[n].sm_oneof_w) != NULL)\n\t\t{\n\t\t    // Check for match with one of the chars in \"sm_oneof\".\n\t\t    while (*pf != NUL && *pf != word[i + k])\n\t\t\t++pf;\n\t\t    if (*pf == NUL)\n\t\t\tcontinue;\n\t\t    ++k;\n\t\t}\n\t\ts = smp[n].sm_rules;\n\t\tpri = 5;    // default priority\n\n\t\tp0 = *s;\n\t\tk0 = k;\n\t\twhile (*s == '-' && k > 1)\n\t\t{\n\t\t    k--;\n\t\t    s++;\n\t\t}\n\t\tif (*s == '<')\n\t\t    s++;\n\t\tif (VIM_ISDIGIT(*s))\n\t\t{\n\t\t    // determine priority\n\t\t    pri = *s - '0';\n\t\t    s++;\n\t\t}\n\t\tif (*s == '^' && *(s + 1) == '^')\n\t\t    s++;\n\n\t\tif (*s == NUL\n\t\t\t|| (*s == '^'\n\t\t\t    && (i == 0 || !(word[i - 1] == ' '\n\t\t\t\t    || spell_iswordp_w(word + i - 1, curwin)))\n\t\t\t    && (*(s + 1) != '$'\n\t\t\t\t|| (!spell_iswordp_w(word + i + k0, curwin))))\n\t\t\t|| (*s == '$' && i > 0\n\t\t\t    && spell_iswordp_w(word + i - 1, curwin)\n\t\t\t    && (!spell_iswordp_w(word + i + k0, curwin))))\n\t\t{\n\t\t    // search for followup rules, if:\n\t\t    // followup and k > 1  and  NO '-' in searchstring\n\t\t    c0 = word[i + k - 1];\n\t\t    n0 = slang->sl_sal_first[c0 & 0xff];\n\n\t\t    if (slang->sl_followup && k > 1 && n0 >= 0\n\t\t\t\t\t   && p0 != '-' && word[i + k] != NUL)\n\t\t    {\n\t\t\t// Test follow-up rule for \"word[i + k]\"; loop over\n\t\t\t// all entries with the same index byte.\n\t\t\tfor ( ; ((ws = smp[n0].sm_lead_w)[0] & 0xff)\n\t\t\t\t\t\t\t == (c0 & 0xff); ++n0)\n\t\t\t{\n\t\t\t    // Quickly skip entries that don't match the word.\n\t\t\t    if (c0 != ws[0])\n\t\t\t\tcontinue;\n\t\t\t    k0 = smp[n0].sm_leadlen;\n\t\t\t    if (k0 > 1)\n\t\t\t    {\n\t\t\t\tif (word[i + k] != ws[1])\n\t\t\t\t    continue;\n\t\t\t\tif (k0 > 2)\n\t\t\t\t{\n\t\t\t\t    pf = word + i + k + 1;\n\t\t\t\t    for (j = 2; j < k0; ++j)\n\t\t\t\t\tif (*pf++ != ws[j])\n\t\t\t\t\t    break;\n\t\t\t\t    if (j < k0)\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    k0 += k - 1;\n\n\t\t\t    if ((pf = smp[n0].sm_oneof_w) != NULL)\n\t\t\t    {\n\t\t\t\t// Check for match with one of the chars in\n\t\t\t\t// \"sm_oneof\".\n\t\t\t\twhile (*pf != NUL && *pf != word[i + k0])\n\t\t\t\t    ++pf;\n\t\t\t\tif (*pf == NUL)\n\t\t\t\t    continue;\n\t\t\t\t++k0;\n\t\t\t    }\n\n\t\t\t    p0 = 5;\n\t\t\t    s = smp[n0].sm_rules;\n\t\t\t    while (*s == '-')\n\t\t\t    {\n\t\t\t\t// \"k0\" gets NOT reduced because\n\t\t\t\t// \"if (k0 == k)\"\n\t\t\t\ts++;\n\t\t\t    }\n\t\t\t    if (*s == '<')\n\t\t\t\ts++;\n\t\t\t    if (VIM_ISDIGIT(*s))\n\t\t\t    {\n\t\t\t\tp0 = *s - '0';\n\t\t\t\ts++;\n\t\t\t    }\n\n\t\t\t    if (*s == NUL\n\t\t\t\t    // *s == '^' cuts\n\t\t\t\t    || (*s == '$'\n\t\t\t\t\t && !spell_iswordp_w(word + i + k0,\n\t\t\t\t\t\t\t\t     curwin)))\n\t\t\t    {\n\t\t\t\tif (k0 == k)\n\t\t\t\t    // this is just a piece of the string\n\t\t\t\t    continue;\n\n\t\t\t\tif (p0 < pri)\n\t\t\t\t    // priority too low\n\t\t\t\t    continue;\n\t\t\t\t// rule fits; stop search\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\n\t\t\tif (p0 >= pri && (smp[n0].sm_lead_w[0] & 0xff)\n\t\t\t\t\t\t\t       == (c0 & 0xff))\n\t\t\t    continue;\n\t\t    }\n\n\t\t    // replace string\n\t\t    ws = smp[n].sm_to_w;\n\t\t    s = smp[n].sm_rules;\n\t\t    p0 = (vim_strchr(s, '<') != NULL) ? 1 : 0;\n\t\t    if (p0 == 1 && z == 0)\n\t\t    {\n\t\t\t// rule with '<' is used\n\t\t\tif (reslen > 0 && ws != NULL && *ws != NUL\n\t\t\t\t&& (wres[reslen - 1] == c\n\t\t\t\t\t\t    || wres[reslen - 1] == *ws))\n\t\t\t    reslen--;\n\t\t\tz0 = 1;\n\t\t\tz = 1;\n\t\t\tk0 = 0;\n\t\t\tif (ws != NULL)\n\t\t\t    while (*ws != NUL && word[i + k0] != NUL)\n\t\t\t    {\n\t\t\t\tword[i + k0] = *ws;\n\t\t\t\tk0++;\n\t\t\t\tws++;\n\t\t\t    }\n\t\t\tif (k > k0)\n\t\t\t    mch_memmove(word + i + k0, word + i + k,\n\t\t\t\t    sizeof(int) * (wordlen - (i + k) + 1));\n\n\t\t\t// new \"actual letter\"\n\t\t\tc = word[i];\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// no '<' rule used\n\t\t\ti += k - 1;\n\t\t\tz = 0;\n\t\t\tif (ws != NULL)\n\t\t\t    while (*ws != NUL && ws[1] != NUL\n\t\t\t\t\t\t\t  && reslen < MAXWLEN)\n\t\t\t    {\n\t\t\t\tif (reslen == 0 || wres[reslen - 1] != *ws)\n\t\t\t\t    wres[reslen++] = *ws;\n\t\t\t\tws++;\n\t\t\t    }\n\t\t\t// new \"actual letter\"\n\t\t\tif (ws == NULL)\n\t\t\t    c = NUL;\n\t\t\telse\n\t\t\t    c = *ws;\n\t\t\tif (strstr((char *)s, \"^^\") != NULL)\n\t\t\t{\n\t\t\t    if (c != NUL)\n\t\t\t\twres[reslen++] = c;\n\t\t\t    mch_memmove(word, word + i + 1,\n\t\t\t\t       sizeof(int) * (wordlen - (i + 1) + 1));\n\t\t\t    i = 0;\n\t\t\t    z0 = 1;\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\telse if (VIM_ISWHITE(c))\n\t{\n\t    c = ' ';\n\t    k = 1;\n\t}\n\n\tif (z0 == 0)\n\t{\n\t    if (k && !p0 && reslen < MAXWLEN && c != NUL\n\t\t    && (!slang->sl_collapse || reslen == 0\n\t\t\t\t\t\t     || wres[reslen - 1] != c))\n\t\t// condense only double letters\n\t\twres[reslen++] = c;\n\n\t    i++;\n\t    z = 0;\n\t    k = 0;\n\t}\n    }\n\n    // Convert wide characters in \"wres\" to a multi-byte string in \"res\".\n    l = 0;\n    for (n = 0; n < reslen; ++n)\n    {\n\tl += mb_char2bytes(wres[n], res + l);\n\tif (l + MB_MAXBYTES > MAXWLEN)\n\t    break;\n    }\n    res[l] = NUL;\n}\n"
  },
  {
    "repository": "jasper",
    "cve_id": "CVE-2020-27828",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "4cd52b5daac62b00a0a328451544807ddecf775f",
    "short_hash": "4cd52b5d",
    "vulnerableMethods_before": [
      {
        "filename": "jpc_enc.c",
        "method_name": "vulnerable_function",
        "raw_code": "static jpc_enc_cp_t *cp_create(const char *optstr, jas_image_t *image)\n{\n\tjpc_enc_cp_t *cp;\n\tjas_tvparser_t *tvp;\n\tint ret;\n\tint numilyrrates;\n\tdouble *ilyrrates;\n\tint i;\n\tint tagid;\n\tjpc_enc_tcp_t *tcp;\n\tjpc_enc_tccp_t *tccp;\n\tjpc_enc_ccp_t *ccp;\n\tuint_fast16_t rlvlno;\n\tuint_fast16_t prcwidthexpn;\n\tuint_fast16_t prcheightexpn;\n\tbool enablemct;\n\tuint_fast32_t jp2overhead;\n\tuint_fast16_t lyrno;\n\tuint_fast32_t hsteplcm;\n\tuint_fast32_t vsteplcm;\n\tbool mctvalid;\n\n\ttvp = 0;\n\tcp = 0;\n\tilyrrates = 0;\n\tnumilyrrates = 0;\n\n\tif (!(cp = jas_malloc(sizeof(jpc_enc_cp_t)))) {\n\t\tgoto error;\n\t}\n\n\tprcwidthexpn = 15;\n\tprcheightexpn = 15;\n\tenablemct = true;\n\tjp2overhead = 0;\n\n\tcp->ccps = 0;\n\tcp->debug = 0;\n\tcp->imgareatlx = UINT_FAST32_MAX;\n\tcp->imgareatly = UINT_FAST32_MAX;\n\tcp->refgrdwidth = 0;\n\tcp->refgrdheight = 0;\n\tcp->tilegrdoffx = UINT_FAST32_MAX;\n\tcp->tilegrdoffy = UINT_FAST32_MAX;\n\tcp->tilewidth = 0;\n\tcp->tileheight = 0;\n\tcp->numcmpts = jas_image_numcmpts(image);\n\n\thsteplcm = 1;\n\tvsteplcm = 1;\n\tfor (unsigned cmptno = 0; cmptno < jas_image_numcmpts(image); ++cmptno) {\n\t\tif (jas_image_cmptbrx(image, cmptno) + jas_image_cmpthstep(image, cmptno) <=\n\t\t  jas_image_brx(image) || jas_image_cmptbry(image, cmptno) +\n\t\t  jas_image_cmptvstep(image, cmptno) <= jas_image_bry(image)) {\n\t\t\tjas_eprintf(\"unsupported image type\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\t/* Note: We ought to be calculating the LCMs here.  Fix some day. */\n\t\thsteplcm *= jas_image_cmpthstep(image, cmptno);\n\t\tvsteplcm *= jas_image_cmptvstep(image, cmptno);\n\t}\n\n\tif (!(cp->ccps = jas_alloc2(cp->numcmpts, sizeof(jpc_enc_ccp_t)))) {\n\t\tgoto error;\n\t}\n\tunsigned cmptno;\n\tfor (cmptno = 0, ccp = cp->ccps; cmptno < cp->numcmpts; ++cmptno,\n\t  ++ccp) {\n\t\tccp->sampgrdstepx = jas_image_cmpthstep(image, cmptno);\n\t\tccp->sampgrdstepy = jas_image_cmptvstep(image, cmptno);\n\t\t/* XXX - this isn't quite correct for more general image */\n\t\tccp->sampgrdsubstepx = 0;\n\t\tccp->sampgrdsubstepx = 0;\n\t\tccp->prec = jas_image_cmptprec(image, cmptno);\n\t\tccp->sgnd = jas_image_cmptsgnd(image, cmptno);\n\t\tccp->numstepsizes = 0;\n\t\tmemset(ccp->stepsizes, 0, sizeof(ccp->stepsizes));\n\t}\n\n\tcp->rawsize = jas_image_rawsize(image);\n\tif (cp->rawsize == 0) {\n\t\t/* prevent division by zero in cp_create() */\n\t\tgoto error;\n\t}\n\tcp->totalsize = UINT_FAST32_MAX;\n\n\ttcp = &cp->tcp;\n\ttcp->csty = 0;\n\ttcp->intmode = true;\n\ttcp->prg = JPC_COD_LRCPPRG;\n\ttcp->numlyrs = 1;\n\ttcp->ilyrrates = 0;\n\n\ttccp = &cp->tccp;\n\ttccp->csty = 0;\n\ttccp->maxrlvls = 6;\n\ttccp->cblkwidthexpn = 6;\n\ttccp->cblkheightexpn = 6;\n\ttccp->cblksty = 0;\n\ttccp->numgbits = 2;\n\n\tif (!(tvp = jas_tvparser_create(optstr ? optstr : \"\"))) {\n\t\tgoto error;\n\t}\n\n\twhile (!(ret = jas_tvparser_next(tvp))) {\n\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(encopts,\n\t\t  jas_tvparser_gettag(tvp)))->id) {\n\t\tcase OPT_DEBUG:\n\t\t\tcp->debug = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_IMGAREAOFFX:\n\t\t\tcp->imgareatlx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_IMGAREAOFFY:\n\t\t\tcp->imgareatly = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEGRDOFFX:\n\t\t\tcp->tilegrdoffx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEGRDOFFY:\n\t\t\tcp->tilegrdoffy = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEWIDTH:\n\t\t\tcp->tilewidth = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEHEIGHT:\n\t\t\tcp->tileheight = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_PRCWIDTH:\n\t\t\tprcwidthexpn = jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_PRCHEIGHT:\n\t\t\tprcheightexpn = jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_CBLKWIDTH:\n\t\t\ttccp->cblkwidthexpn =\n\t\t\t  jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_CBLKHEIGHT:\n\t\t\ttccp->cblkheightexpn =\n\t\t\t  jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_MODE:\n\t\t\tif ((tagid = jas_taginfo_nonull(jas_taginfos_lookup(modetab,\n\t\t\t  jas_tvparser_getval(tvp)))->id) < 0) {\n\t\t\t\tjas_eprintf(\"ignoring invalid mode %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t} else {\n\t\t\t\ttcp->intmode = (tagid == MODE_INT);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_PRG:\n\t\t\tif ((tagid = jas_taginfo_nonull(jas_taginfos_lookup(prgordtab,\n\t\t\t  jas_tvparser_getval(tvp)))->id) < 0) {\n\t\t\t\tjas_eprintf(\"ignoring invalid progression order %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t} else {\n\t\t\t\ttcp->prg = tagid;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_NOMCT:\n\t\t\tenablemct = false;\n\t\t\tbreak;\n\t\tcase OPT_MAXRLVLS:\n\t\t\ttccp->maxrlvls = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_SOP:\n\t\t\tcp->tcp.csty |= JPC_COD_SOP;\n\t\t\tbreak;\n\t\tcase OPT_EPH:\n\t\t\tcp->tcp.csty |= JPC_COD_EPH;\n\t\t\tbreak;\n\t\tcase OPT_LAZY:\n\t\t\ttccp->cblksty |= JPC_COX_LAZY;\n\t\t\tbreak;\n\t\tcase OPT_TERMALL:\n\t\t\ttccp->cblksty |= JPC_COX_TERMALL;\n\t\t\tbreak;\n\t\tcase OPT_SEGSYM:\n\t\t\ttccp->cblksty |= JPC_COX_SEGSYM;\n\t\t\tbreak;\n\t\tcase OPT_VCAUSAL:\n\t\t\ttccp->cblksty |= JPC_COX_VSC;\n\t\t\tbreak;\n\t\tcase OPT_RESET:\n\t\t\ttccp->cblksty |= JPC_COX_RESET;\n\t\t\tbreak;\n\t\tcase OPT_PTERM:\n\t\t\ttccp->cblksty |= JPC_COX_PTERM;\n\t\t\tbreak;\n\t\tcase OPT_NUMGBITS:\n\t\t\tcp->tccp.numgbits = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_RATE:\n\t\t\tif (ratestrtosize(jas_tvparser_getval(tvp), cp->rawsize,\n\t\t\t  &cp->totalsize)) {\n\t\t\t\tjas_eprintf(\"ignoring bad rate specifier %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_ILYRRATES:\n\t\t\tif (jpc_atoaf(jas_tvparser_getval(tvp), &numilyrrates,\n\t\t\t  &ilyrrates)) {\n\t\t\t\tjas_eprintf(\"warning: invalid intermediate layer rates specifier ignored (%s)\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase OPT_JP2OVERHEAD:\n\t\t\tjp2overhead = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tjas_eprintf(\"warning: ignoring invalid option %s\\n\",\n\t\t\t jas_tvparser_gettag(tvp));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tjas_tvparser_destroy(tvp);\n\ttvp = 0;\n\n\tif (cp->totalsize != UINT_FAST32_MAX) {\n\t\tcp->totalsize = (cp->totalsize > jp2overhead) ?\n\t\t  (cp->totalsize - jp2overhead) : 0;\n\t}\n\n\tif (cp->imgareatlx == UINT_FAST32_MAX) {\n\t\tcp->imgareatlx = 0;\n\t} else {\n\t\tif (hsteplcm != 1) {\n\t\t\tjas_eprintf(\"warning: overriding imgareatlx value\\n\");\n\t\t}\n\t\tcp->imgareatlx *= hsteplcm;\n\t}\n\tif (cp->imgareatly == UINT_FAST32_MAX) {\n\t\tcp->imgareatly = 0;\n\t} else {\n\t\tif (vsteplcm != 1) {\n\t\t\tjas_eprintf(\"warning: overriding imgareatly value\\n\");\n\t\t}\n\t\tcp->imgareatly *= vsteplcm;\n\t}\n\tcp->refgrdwidth = cp->imgareatlx + jas_image_width(image);\n\tcp->refgrdheight = cp->imgareatly + jas_image_height(image);\n\tif (cp->tilegrdoffx == UINT_FAST32_MAX) {\n\t\tcp->tilegrdoffx = cp->imgareatlx;\n\t}\n\tif (cp->tilegrdoffy == UINT_FAST32_MAX) {\n\t\tcp->tilegrdoffy = cp->imgareatly;\n\t}\n\tif (!cp->tilewidth) {\n\t\tcp->tilewidth = cp->refgrdwidth - cp->tilegrdoffx;\n\t}\n\tif (!cp->tileheight) {\n\t\tcp->tileheight = cp->refgrdheight - cp->tilegrdoffy;\n\t}\n\n\tif (cp->numcmpts == 3) {\n\t\tmctvalid = true;\n\t\tfor (cmptno = 0; cmptno < jas_image_numcmpts(image); ++cmptno) {\n\t\t\tif (jas_image_cmptprec(image, cmptno) != jas_image_cmptprec(image, 0) ||\n\t\t\t  jas_image_cmptsgnd(image, cmptno) != jas_image_cmptsgnd(image, 0) ||\n\t\t\t  jas_image_cmptwidth(image, cmptno) != jas_image_cmptwidth(image, 0) ||\n\t\t\t  jas_image_cmptheight(image, cmptno) != jas_image_cmptheight(image, 0)) {\n\t\t\t\tmctvalid = false;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tmctvalid = false;\n\t}\n\tif (mctvalid && enablemct && jas_clrspc_fam(jas_image_clrspc(image)) != JAS_CLRSPC_FAM_RGB) {\n\t\tjas_eprintf(\"warning: color space apparently not RGB\\n\");\n\t}\n\tif (mctvalid && enablemct && jas_clrspc_fam(jas_image_clrspc(image)) == JAS_CLRSPC_FAM_RGB) {\n\t\ttcp->mctid = (tcp->intmode) ? (JPC_MCT_RCT) : (JPC_MCT_ICT);\n\t} else {\n\t\ttcp->mctid = JPC_MCT_NONE;\n\t}\n\ttccp->qmfbid = (tcp->intmode) ? (JPC_COX_RFT) : (JPC_COX_INS);\n\n\tfor (rlvlno = 0; rlvlno < tccp->maxrlvls; ++rlvlno) {\n\t\ttccp->prcwidthexpns[rlvlno] = prcwidthexpn;\n\t\ttccp->prcheightexpns[rlvlno] = prcheightexpn;\n\t}\n\tif (prcwidthexpn != 15 || prcheightexpn != 15) {\n\t\ttccp->csty |= JPC_COX_PRT;\n\t}\n\n\t/* Ensure that the tile width and height is valid. */\n\tif (!cp->tilewidth) {\n\t\tjas_eprintf(\"invalid tile width %lu\\n\", (unsigned long)\n\t\t  cp->tilewidth);\n\t\tgoto error;\n\t}\n\tif (!cp->tileheight) {\n\t\tjas_eprintf(\"invalid tile height %lu\\n\", (unsigned long)\n\t\t  cp->tileheight);\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the tile grid offset is valid. */\n\tif (cp->tilegrdoffx > cp->imgareatlx ||\n\t  cp->tilegrdoffy > cp->imgareatly ||\n\t  cp->tilegrdoffx + cp->tilewidth < cp->imgareatlx ||\n\t  cp->tilegrdoffy + cp->tileheight < cp->imgareatly) {\n\t\tjas_eprintf(\"invalid tile grid offset (%lu, %lu)\\n\",\n\t\t  (unsigned long) cp->tilegrdoffx, (unsigned long)\n\t\t  cp->tilegrdoffy);\n\t\tgoto error;\n\t}\n\n\tcp->numhtiles = JPC_CEILDIV(cp->refgrdwidth - cp->tilegrdoffx,\n\t  cp->tilewidth);\n\tcp->numvtiles = JPC_CEILDIV(cp->refgrdheight - cp->tilegrdoffy,\n\t  cp->tileheight);\n\tcp->numtiles = cp->numhtiles * cp->numvtiles;\n\n\tif (ilyrrates && numilyrrates > 0) {\n\t\ttcp->numlyrs = numilyrrates + 1;\n\t\tif (!(tcp->ilyrrates = jas_alloc2((tcp->numlyrs - 1),\n\t\t  sizeof(jpc_fix_t)))) {\n\t\t\tgoto error;\n\t\t}\n\t\tfor (i = 0; i < JAS_CAST(int, tcp->numlyrs - 1); ++i) {\n\t\t\ttcp->ilyrrates[i] = jpc_dbltofix(ilyrrates[i]);\n\t\t}\n\t}\n\n\t/* Ensure that the integer mode is used in the case of lossless\n\t  coding. */\n\tif (cp->totalsize == UINT_FAST32_MAX && (!cp->tcp.intmode)) {\n\t\tjas_eprintf(\"cannot use real mode for lossless coding\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the precinct width is valid. */\n\tif (prcwidthexpn > 15) {\n\t\tjas_eprintf(\"invalid precinct width\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the precinct height is valid. */\n\tif (prcheightexpn > 15) {\n\t\tjas_eprintf(\"invalid precinct height\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the code block width is valid. */\n\tif (cp->tccp.cblkwidthexpn < 2 || cp->tccp.cblkwidthexpn > 12) {\n\t\tjas_eprintf(\"invalid code block width %d\\n\",\n\t\t  JPC_POW2(cp->tccp.cblkwidthexpn));\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the code block height is valid. */\n\tif (cp->tccp.cblkheightexpn < 2 || cp->tccp.cblkheightexpn > 12) {\n\t\tjas_eprintf(\"invalid code block height %d\\n\",\n\t\t  JPC_POW2(cp->tccp.cblkheightexpn));\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the code block size is not too large. */\n\tif (cp->tccp.cblkwidthexpn + cp->tccp.cblkheightexpn > 12) {\n\t\tjas_eprintf(\"code block size too large\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the number of layers is valid. */\n\tif (cp->tcp.numlyrs > 16384) {\n\t\tjas_eprintf(\"too many layers\\n\");\n\t\tgoto error;\n\t}\n\n\t/* There must be at least one resolution level. */\n\tif (cp->tccp.maxrlvls < 1) {\n\t\tjas_eprintf(\"must be at least one resolution level\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the number of guard bits is valid. */\n\tif (cp->tccp.numgbits > 8) {\n\t\tjas_eprintf(\"invalid number of guard bits\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the rate is within the legal range. */\n\tif (cp->totalsize != UINT_FAST32_MAX && cp->totalsize > cp->rawsize) {\n\t\tjas_eprintf(\"warning: specified rate is unreasonably large (%lu > %lu)\\n\", (unsigned long) cp->totalsize, (unsigned long) cp->rawsize);\n\t}\n\n\t/* Ensure that the intermediate layer rates are valid. */\n\tif (tcp->numlyrs > 1) {\n\t\t/* The intermediate layers rates must increase monotonically. */\n\t\tfor (lyrno = 0; lyrno + 2 < tcp->numlyrs; ++lyrno) {\n\t\t\tif (tcp->ilyrrates[lyrno] >= tcp->ilyrrates[lyrno + 1]) {\n\t\t\t\tjas_eprintf(\"intermediate layer rates must increase monotonically\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\t/* The intermediate layer rates must be less than the overall rate. */\n\t\tif (cp->totalsize != UINT_FAST32_MAX) {\n\t\t\tfor (lyrno = 0; lyrno < tcp->numlyrs - 1; ++lyrno) {\n\t\t\t\tif (jpc_fixtodbl(tcp->ilyrrates[lyrno]) > ((double) cp->totalsize)\n\t\t\t\t  / cp->rawsize) {\n\t\t\t\t\tjas_eprintf(\"warning: intermediate layer rates must be less than overall rate\\n\");\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ilyrrates) {\n\t\tjas_free(ilyrrates);\n\t}\n\n\treturn cp;\n\nerror:\n\n\tif (ilyrrates) {\n\t\tjas_free(ilyrrates);\n\t}\n\tif (tvp) {\n\t\tjas_tvparser_destroy(tvp);\n\t}\n\tif (cp) {\n\t\tjpc_enc_cp_destroy(cp);\n\t}\n\treturn 0;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "jpc_enc.c",
        "method_name": "fixed_function",
        "raw_code": "static jpc_enc_cp_t *cp_create(const char *optstr, jas_image_t *image)\n{\n\tjpc_enc_cp_t *cp;\n\tjas_tvparser_t *tvp;\n\tint ret;\n\tint numilyrrates;\n\tdouble *ilyrrates;\n\tint i;\n\tint tagid;\n\tjpc_enc_tcp_t *tcp;\n\tjpc_enc_tccp_t *tccp;\n\tjpc_enc_ccp_t *ccp;\n\tuint_fast16_t rlvlno;\n\tuint_fast16_t prcwidthexpn;\n\tuint_fast16_t prcheightexpn;\n\tbool enablemct;\n\tuint_fast32_t jp2overhead;\n\tuint_fast16_t lyrno;\n\tuint_fast32_t hsteplcm;\n\tuint_fast32_t vsteplcm;\n\tbool mctvalid;\n\n\ttvp = 0;\n\tcp = 0;\n\tilyrrates = 0;\n\tnumilyrrates = 0;\n\n\tif (!(cp = jas_malloc(sizeof(jpc_enc_cp_t)))) {\n\t\tgoto error;\n\t}\n\n\tprcwidthexpn = 15;\n\tprcheightexpn = 15;\n\tenablemct = true;\n\tjp2overhead = 0;\n\n\tcp->ccps = 0;\n\tcp->debug = 0;\n\tcp->imgareatlx = UINT_FAST32_MAX;\n\tcp->imgareatly = UINT_FAST32_MAX;\n\tcp->refgrdwidth = 0;\n\tcp->refgrdheight = 0;\n\tcp->tilegrdoffx = UINT_FAST32_MAX;\n\tcp->tilegrdoffy = UINT_FAST32_MAX;\n\tcp->tilewidth = 0;\n\tcp->tileheight = 0;\n\tcp->numcmpts = jas_image_numcmpts(image);\n\n\thsteplcm = 1;\n\tvsteplcm = 1;\n\tfor (unsigned cmptno = 0; cmptno < jas_image_numcmpts(image); ++cmptno) {\n\t\tif (jas_image_cmptbrx(image, cmptno) + jas_image_cmpthstep(image, cmptno) <=\n\t\t  jas_image_brx(image) || jas_image_cmptbry(image, cmptno) +\n\t\t  jas_image_cmptvstep(image, cmptno) <= jas_image_bry(image)) {\n\t\t\tjas_eprintf(\"unsupported image type\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\t/* Note: We ought to be calculating the LCMs here.  Fix some day. */\n\t\thsteplcm *= jas_image_cmpthstep(image, cmptno);\n\t\tvsteplcm *= jas_image_cmptvstep(image, cmptno);\n\t}\n\n\tif (!(cp->ccps = jas_alloc2(cp->numcmpts, sizeof(jpc_enc_ccp_t)))) {\n\t\tgoto error;\n\t}\n\tunsigned cmptno;\n\tfor (cmptno = 0, ccp = cp->ccps; cmptno < cp->numcmpts; ++cmptno,\n\t  ++ccp) {\n\t\tccp->sampgrdstepx = jas_image_cmpthstep(image, cmptno);\n\t\tccp->sampgrdstepy = jas_image_cmptvstep(image, cmptno);\n\t\t/* XXX - this isn't quite correct for more general image */\n\t\tccp->sampgrdsubstepx = 0;\n\t\tccp->sampgrdsubstepx = 0;\n\t\tccp->prec = jas_image_cmptprec(image, cmptno);\n\t\tccp->sgnd = jas_image_cmptsgnd(image, cmptno);\n\t\tccp->numstepsizes = 0;\n\t\tmemset(ccp->stepsizes, 0, sizeof(ccp->stepsizes));\n\t}\n\n\tcp->rawsize = jas_image_rawsize(image);\n\tif (cp->rawsize == 0) {\n\t\t/* prevent division by zero in cp_create() */\n\t\tgoto error;\n\t}\n\tcp->totalsize = UINT_FAST32_MAX;\n\n\ttcp = &cp->tcp;\n\ttcp->csty = 0;\n\ttcp->intmode = true;\n\ttcp->prg = JPC_COD_LRCPPRG;\n\ttcp->numlyrs = 1;\n\ttcp->ilyrrates = 0;\n\n\ttccp = &cp->tccp;\n\ttccp->csty = 0;\n\ttccp->maxrlvls = 6;\n\ttccp->cblkwidthexpn = 6;\n\ttccp->cblkheightexpn = 6;\n\ttccp->cblksty = 0;\n\ttccp->numgbits = 2;\n\n\tif (!(tvp = jas_tvparser_create(optstr ? optstr : \"\"))) {\n\t\tgoto error;\n\t}\n\n\twhile (!(ret = jas_tvparser_next(tvp))) {\n\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(encopts,\n\t\t  jas_tvparser_gettag(tvp)))->id) {\n\t\tcase OPT_DEBUG:\n\t\t\tcp->debug = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_IMGAREAOFFX:\n\t\t\tcp->imgareatlx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_IMGAREAOFFY:\n\t\t\tcp->imgareatly = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEGRDOFFX:\n\t\t\tcp->tilegrdoffx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEGRDOFFY:\n\t\t\tcp->tilegrdoffy = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEWIDTH:\n\t\t\tcp->tilewidth = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEHEIGHT:\n\t\t\tcp->tileheight = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_PRCWIDTH:\n\t\t\tprcwidthexpn = jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_PRCHEIGHT:\n\t\t\tprcheightexpn = jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_CBLKWIDTH:\n\t\t\ttccp->cblkwidthexpn =\n\t\t\t  jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_CBLKHEIGHT:\n\t\t\ttccp->cblkheightexpn =\n\t\t\t  jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_MODE:\n\t\t\tif ((tagid = jas_taginfo_nonull(jas_taginfos_lookup(modetab,\n\t\t\t  jas_tvparser_getval(tvp)))->id) < 0) {\n\t\t\t\tjas_eprintf(\"ignoring invalid mode %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t} else {\n\t\t\t\ttcp->intmode = (tagid == MODE_INT);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_PRG:\n\t\t\tif ((tagid = jas_taginfo_nonull(jas_taginfos_lookup(prgordtab,\n\t\t\t  jas_tvparser_getval(tvp)))->id) < 0) {\n\t\t\t\tjas_eprintf(\"ignoring invalid progression order %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t} else {\n\t\t\t\ttcp->prg = tagid;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_NOMCT:\n\t\t\tenablemct = false;\n\t\t\tbreak;\n\t\tcase OPT_MAXRLVLS:\n\t\t\ttccp->maxrlvls = atoi(jas_tvparser_getval(tvp));\n\t\t\tif(tccp->maxrlvls > JPC_MAXRLVLS) {\n\t\t\t\tjas_eprintf(\"invalid number of resolution levels upper than %d\\n\",JPC_MAXRLVLS);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_SOP:\n\t\t\tcp->tcp.csty |= JPC_COD_SOP;\n\t\t\tbreak;\n\t\tcase OPT_EPH:\n\t\t\tcp->tcp.csty |= JPC_COD_EPH;\n\t\t\tbreak;\n\t\tcase OPT_LAZY:\n\t\t\ttccp->cblksty |= JPC_COX_LAZY;\n\t\t\tbreak;\n\t\tcase OPT_TERMALL:\n\t\t\ttccp->cblksty |= JPC_COX_TERMALL;\n\t\t\tbreak;\n\t\tcase OPT_SEGSYM:\n\t\t\ttccp->cblksty |= JPC_COX_SEGSYM;\n\t\t\tbreak;\n\t\tcase OPT_VCAUSAL:\n\t\t\ttccp->cblksty |= JPC_COX_VSC;\n\t\t\tbreak;\n\t\tcase OPT_RESET:\n\t\t\ttccp->cblksty |= JPC_COX_RESET;\n\t\t\tbreak;\n\t\tcase OPT_PTERM:\n\t\t\ttccp->cblksty |= JPC_COX_PTERM;\n\t\t\tbreak;\n\t\tcase OPT_NUMGBITS:\n\t\t\tcp->tccp.numgbits = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_RATE:\n\t\t\tif (ratestrtosize(jas_tvparser_getval(tvp), cp->rawsize,\n\t\t\t  &cp->totalsize)) {\n\t\t\t\tjas_eprintf(\"ignoring bad rate specifier %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_ILYRRATES:\n\t\t\tif (jpc_atoaf(jas_tvparser_getval(tvp), &numilyrrates,\n\t\t\t  &ilyrrates)) {\n\t\t\t\tjas_eprintf(\"warning: invalid intermediate layer rates specifier ignored (%s)\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase OPT_JP2OVERHEAD:\n\t\t\tjp2overhead = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tjas_eprintf(\"warning: ignoring invalid option %s\\n\",\n\t\t\t jas_tvparser_gettag(tvp));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tjas_tvparser_destroy(tvp);\n\ttvp = 0;\n\n\tif (cp->totalsize != UINT_FAST32_MAX) {\n\t\tcp->totalsize = (cp->totalsize > jp2overhead) ?\n\t\t  (cp->totalsize - jp2overhead) : 0;\n\t}\n\n\tif (cp->imgareatlx == UINT_FAST32_MAX) {\n\t\tcp->imgareatlx = 0;\n\t} else {\n\t\tif (hsteplcm != 1) {\n\t\t\tjas_eprintf(\"warning: overriding imgareatlx value\\n\");\n\t\t}\n\t\tcp->imgareatlx *= hsteplcm;\n\t}\n\tif (cp->imgareatly == UINT_FAST32_MAX) {\n\t\tcp->imgareatly = 0;\n\t} else {\n\t\tif (vsteplcm != 1) {\n\t\t\tjas_eprintf(\"warning: overriding imgareatly value\\n\");\n\t\t}\n\t\tcp->imgareatly *= vsteplcm;\n\t}\n\tcp->refgrdwidth = cp->imgareatlx + jas_image_width(image);\n\tcp->refgrdheight = cp->imgareatly + jas_image_height(image);\n\tif (cp->tilegrdoffx == UINT_FAST32_MAX) {\n\t\tcp->tilegrdoffx = cp->imgareatlx;\n\t}\n\tif (cp->tilegrdoffy == UINT_FAST32_MAX) {\n\t\tcp->tilegrdoffy = cp->imgareatly;\n\t}\n\tif (!cp->tilewidth) {\n\t\tcp->tilewidth = cp->refgrdwidth - cp->tilegrdoffx;\n\t}\n\tif (!cp->tileheight) {\n\t\tcp->tileheight = cp->refgrdheight - cp->tilegrdoffy;\n\t}\n\n\tif (cp->numcmpts == 3) {\n\t\tmctvalid = true;\n\t\tfor (cmptno = 0; cmptno < jas_image_numcmpts(image); ++cmptno) {\n\t\t\tif (jas_image_cmptprec(image, cmptno) != jas_image_cmptprec(image, 0) ||\n\t\t\t  jas_image_cmptsgnd(image, cmptno) != jas_image_cmptsgnd(image, 0) ||\n\t\t\t  jas_image_cmptwidth(image, cmptno) != jas_image_cmptwidth(image, 0) ||\n\t\t\t  jas_image_cmptheight(image, cmptno) != jas_image_cmptheight(image, 0)) {\n\t\t\t\tmctvalid = false;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tmctvalid = false;\n\t}\n\tif (mctvalid && enablemct && jas_clrspc_fam(jas_image_clrspc(image)) != JAS_CLRSPC_FAM_RGB) {\n\t\tjas_eprintf(\"warning: color space apparently not RGB\\n\");\n\t}\n\tif (mctvalid && enablemct && jas_clrspc_fam(jas_image_clrspc(image)) == JAS_CLRSPC_FAM_RGB) {\n\t\ttcp->mctid = (tcp->intmode) ? (JPC_MCT_RCT) : (JPC_MCT_ICT);\n\t} else {\n\t\ttcp->mctid = JPC_MCT_NONE;\n\t}\n\ttccp->qmfbid = (tcp->intmode) ? (JPC_COX_RFT) : (JPC_COX_INS);\n\n\tfor (rlvlno = 0; rlvlno < tccp->maxrlvls; ++rlvlno) {\n\t\ttccp->prcwidthexpns[rlvlno] = prcwidthexpn;\n\t\ttccp->prcheightexpns[rlvlno] = prcheightexpn;\n\t}\n\tif (prcwidthexpn != 15 || prcheightexpn != 15) {\n\t\ttccp->csty |= JPC_COX_PRT;\n\t}\n\n\t/* Ensure that the tile width and height is valid. */\n\tif (!cp->tilewidth) {\n\t\tjas_eprintf(\"invalid tile width %lu\\n\", (unsigned long)\n\t\t  cp->tilewidth);\n\t\tgoto error;\n\t}\n\tif (!cp->tileheight) {\n\t\tjas_eprintf(\"invalid tile height %lu\\n\", (unsigned long)\n\t\t  cp->tileheight);\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the tile grid offset is valid. */\n\tif (cp->tilegrdoffx > cp->imgareatlx ||\n\t  cp->tilegrdoffy > cp->imgareatly ||\n\t  cp->tilegrdoffx + cp->tilewidth < cp->imgareatlx ||\n\t  cp->tilegrdoffy + cp->tileheight < cp->imgareatly) {\n\t\tjas_eprintf(\"invalid tile grid offset (%lu, %lu)\\n\",\n\t\t  (unsigned long) cp->tilegrdoffx, (unsigned long)\n\t\t  cp->tilegrdoffy);\n\t\tgoto error;\n\t}\n\n\tcp->numhtiles = JPC_CEILDIV(cp->refgrdwidth - cp->tilegrdoffx,\n\t  cp->tilewidth);\n\tcp->numvtiles = JPC_CEILDIV(cp->refgrdheight - cp->tilegrdoffy,\n\t  cp->tileheight);\n\tcp->numtiles = cp->numhtiles * cp->numvtiles;\n\n\tif (ilyrrates && numilyrrates > 0) {\n\t\ttcp->numlyrs = numilyrrates + 1;\n\t\tif (!(tcp->ilyrrates = jas_alloc2((tcp->numlyrs - 1),\n\t\t  sizeof(jpc_fix_t)))) {\n\t\t\tgoto error;\n\t\t}\n\t\tfor (i = 0; i < JAS_CAST(int, tcp->numlyrs - 1); ++i) {\n\t\t\ttcp->ilyrrates[i] = jpc_dbltofix(ilyrrates[i]);\n\t\t}\n\t}\n\n\t/* Ensure that the integer mode is used in the case of lossless\n\t  coding. */\n\tif (cp->totalsize == UINT_FAST32_MAX && (!cp->tcp.intmode)) {\n\t\tjas_eprintf(\"cannot use real mode for lossless coding\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the precinct width is valid. */\n\tif (prcwidthexpn > 15) {\n\t\tjas_eprintf(\"invalid precinct width\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the precinct height is valid. */\n\tif (prcheightexpn > 15) {\n\t\tjas_eprintf(\"invalid precinct height\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the code block width is valid. */\n\tif (cp->tccp.cblkwidthexpn < 2 || cp->tccp.cblkwidthexpn > 12) {\n\t\tjas_eprintf(\"invalid code block width %d\\n\",\n\t\t  JPC_POW2(cp->tccp.cblkwidthexpn));\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the code block height is valid. */\n\tif (cp->tccp.cblkheightexpn < 2 || cp->tccp.cblkheightexpn > 12) {\n\t\tjas_eprintf(\"invalid code block height %d\\n\",\n\t\t  JPC_POW2(cp->tccp.cblkheightexpn));\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the code block size is not too large. */\n\tif (cp->tccp.cblkwidthexpn + cp->tccp.cblkheightexpn > 12) {\n\t\tjas_eprintf(\"code block size too large\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the number of layers is valid. */\n\tif (cp->tcp.numlyrs > 16384) {\n\t\tjas_eprintf(\"too many layers\\n\");\n\t\tgoto error;\n\t}\n\n\t/* There must be at least one resolution level. */\n\tif (cp->tccp.maxrlvls < 1) {\n\t\tjas_eprintf(\"must be at least one resolution level\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the number of guard bits is valid. */\n\tif (cp->tccp.numgbits > 8) {\n\t\tjas_eprintf(\"invalid number of guard bits\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the rate is within the legal range. */\n\tif (cp->totalsize != UINT_FAST32_MAX && cp->totalsize > cp->rawsize) {\n\t\tjas_eprintf(\"warning: specified rate is unreasonably large (%lu > %lu)\\n\", (unsigned long) cp->totalsize, (unsigned long) cp->rawsize);\n\t}\n\n\t/* Ensure that the intermediate layer rates are valid. */\n\tif (tcp->numlyrs > 1) {\n\t\t/* The intermediate layers rates must increase monotonically. */\n\t\tfor (lyrno = 0; lyrno + 2 < tcp->numlyrs; ++lyrno) {\n\t\t\tif (tcp->ilyrrates[lyrno] >= tcp->ilyrrates[lyrno + 1]) {\n\t\t\t\tjas_eprintf(\"intermediate layer rates must increase monotonically\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\t/* The intermediate layer rates must be less than the overall rate. */\n\t\tif (cp->totalsize != UINT_FAST32_MAX) {\n\t\t\tfor (lyrno = 0; lyrno < tcp->numlyrs - 1; ++lyrno) {\n\t\t\t\tif (jpc_fixtodbl(tcp->ilyrrates[lyrno]) > ((double) cp->totalsize)\n\t\t\t\t  / cp->rawsize) {\n\t\t\t\t\tjas_eprintf(\"warning: intermediate layer rates must be less than overall rate\\n\");\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ilyrrates) {\n\t\tjas_free(ilyrrates);\n\t}\n\n\treturn cp;\n\nerror:\n\n\tif (ilyrrates) {\n\t\tjas_free(ilyrrates);\n\t}\n\tif (tvp) {\n\t\tjas_tvparser_destroy(tvp);\n\t}\n\tif (cp) {\n\t\tjpc_enc_cp_destroy(cp);\n\t}\n\treturn 0;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"jpc_enc.h\"\n#include \"jasper/jas_malloc.h\"\n#include \"jpc_flt.h\"\n#include <float.h>\n#include \"jasper/jas_debug.h\"\n#include \"jpc_tagtree.h\"\n#include \"jpc_fix.h\"\n#include <stdlib.h>\n#include \"jasper/jas_image.h\"\n#include \"jasper/jas_tvp.h\"\n#include \"jpc_tsfb.h\"\n#include \"jpc_math.h\"\n#include \"jpc_t1cod.h\"\n#include \"jasper/jas_math.h\"\n#include <string.h>\n#include \"jasper/jas_version.h\"\n#include <stdio.h>\n#include \"jpc_t2enc.h\"\n#include \"jpc_mct.h\"\n#include \"jpc_t1enc.h\"\n#include <assert.h>\n#include \"jasper/jas_types.h\"\n#include \"jpc_cs.h\"\n#include \"jpc_util.h\"\n#include <math.h>\n#include \"jasper/jas_string.h\"\n\n// Type Definitions:\n// jpc_enc_ccp_t:\ntypedef struct {\n\n\t/* The horizontal sampling period. */\n\tuint_fast8_t sampgrdstepx;\n\n\t/* The vertical sampling period. */\n\tuint_fast8_t sampgrdstepy;\n\n\t/* The sample alignment horizontal offset. */\n\tuint_fast8_t sampgrdsubstepx;\n\n\t/* The sample alignment vertical offset. */\n\tuint_fast8_t sampgrdsubstepy;\n\n\t/* The precision of the samples. */\n\tuint_fast8_t prec;\n\n\t/* The signedness of the samples. */\n\tbool sgnd;\n\n\t/* The number of step sizes. */\n\tuint_fast16_t numstepsizes;\n\n\t/* The quantizer step sizes. */\n\tuint_fast16_t stepsizes[JPC_MAXBANDS];\n\n}\n\n// jas_taginfo_t:\ntypedef struct {\n\n\tint id;\n\t/* The ID for the tag. */\n\n\tconst char *name;\n\t/* The name of the tag. */\n\n}\n\n// jas_tvparser_t:\ntypedef struct {\n\n\tchar *buf;\n\t/* The parsing buffer. */\n\n\tchar *tag;\n\t/* The current tag name. */\n\n\tconst char *val;\n\t/* The current value. */\n\n\tchar *pos;\n\t/* The current position in the parsing buffer. */\n\n}\n\n// jas_image_t:\ntypedef struct {\n\n\tjas_image_coord_t tlx_;\n\t/* The x-coordinate of the top-left corner of the image bounding box. */\n\n\tjas_image_coord_t tly_;\n\t/* The y-coordinate of the top-left corner of the image bounding box. */\n\n\tjas_image_coord_t brx_;\n\t/* The x-coordinate of the bottom-right corner of the image bounding\n\t  box (plus one). */\n\n\tjas_image_coord_t bry_;\n\t/* The y-coordinate of the bottom-right corner of the image bounding\n\t  box (plus one). */\n\n\tunsigned numcmpts_;\n\t/* The number of components. */\n\n\tunsigned maxcmpts_;\n\t/* The maximum number of components that this image can have (i.e., the\n\t  allocated size of the components array). */\n\n\tjas_image_cmpt_t **cmpts_;\n\t/* Per-component information. */\n\n\tjas_clrspc_t clrspc_;\n\n\tjas_cmprof_t *cmprof_;\n\n//\tbool inmem_;\n\n}\n\n// jpc_enc_cp_t:\ntypedef struct {\n\n\t/* The debug level. */\n\tint debug;\n\n\t/* The horizontal offset from the origin of the reference grid to the\n\t  left edge of the image area. */\n\tuint_fast32_t imgareatlx;\n\n\t/* The vertical offset from the origin of the reference grid to the\n\t  top edge of the image area. */\n\tuint_fast32_t imgareatly;\n\n\t/* The horizontal offset from the origin of the reference grid to the\n\t  right edge of the image area (plus one). */\n\tuint_fast32_t refgrdwidth;\n\n\t/* The vertical offset from the origin of the reference grid to the\n\t  bottom edge of the image area (plus one). */\n\tuint_fast32_t refgrdheight;\n\n\t/* The horizontal offset from the origin of the tile grid to the\n\t  origin of the reference grid. */\n\tuint_fast32_t tilegrdoffx;\n\n\t/* The vertical offset from the origin of the tile grid to the\n\t  origin of the reference grid. */\n\tuint_fast32_t tilegrdoffy;\n\n\t/* The nominal tile width in units of the image reference grid. */\n\tuint_fast32_t tilewidth;\n\n\t/* The nominal tile height ...\n\n// jpc_fix_t:\ntypedef int_least32_t jpc_fix_t;\n\n// jpc_enc_tcp_t:\ntypedef struct {\n\n\t/* The coding mode. */\n\tbool intmode;\n\n\t/* The coding style (i.e., SOP, EPH). */\n\tuint_fast8_t csty;\n\n\t/* The progression order. */\n\tuint_fast8_t prg;\n\n\t/* The multicomponent transform. */\n\tuint_fast8_t mctid;\n\n\t/* The number of layers. */\n\tuint_fast16_t numlyrs;\n\n\t/* The normalized bit rates associated with the various\n\t  intermediate layers. */\n\tjpc_fix_t *ilyrrates;\n\n}\n\n// jpc_enc_tccp_t:\ntypedef struct {\n\n\t/* The coding style (i.e., explicit precinct sizes). */\n\tuint_fast8_t csty;\n\n\t/* The maximum number of resolution levels allowed. */\n\tuint_fast8_t maxrlvls;\n\n\t/* The exponent for the nominal code block width. */\n\tuint_fast16_t cblkwidthexpn;\n\n\t/* The exponent for the nominal code block height. */\n\tuint_fast16_t cblkheightexpn;\n\n\t/* The code block style parameters (e.g., lazy, terminate all,\n\t  segmentation symbols, causal, reset probability models). */\n\tuint_fast8_t cblksty;\n\n\t/* The QMFB. */\n\tuint_fast8_t qmfbid;\n\n\t/* The precinct width values. */\n\tuint_fast16_t prcwidthexpns[JPC_MAXRLVLS];\n\n\t/* The precinct height values. */\n\tuint_fast16_t prcheightexpns[JPC_MAXRLVLS];\n\n\t/* The number of guard bits. */\n\tuint_fast8_t numgbits;\n\n}\n\n// Called Methods (top 10):\n// jas_image_cmptbry from src/libjasper/jpc/jasper/jas_image.h:\n<empty>\n\n// jas_image_brx from src/libjasper/jpc/jasper/jas_image.h:\n<empty>\n\n// JPC_COX_INS from src/libjasper/jpc/jpc_cs.h:\n<empty>\n\n// JPC_POW2 from src/libjasper/jpc/jpc_enc.c:\n<empty>\n\n// jpc_fixtodbl from src/libjasper/jpc/jpc_fix.h:\nstatic inline double jpc_fixtodbl(jpc_fix_t x)\n{\n\treturn JAS_FIXTODBL(jpc_fix_t, JPC_FIX_FRACBITS, x);\n}\n\n// jas_tvparser_getval from src/libjasper/base/jas_tvp.c:\nconst char *jas_tvparser_getval(const jas_tvparser_t *tvp)\n{\n\treturn tvp->val;\n}\n\n// jas_image_height from src/libjasper/jpc/jasper/jas_image.h:\n<empty>\n\n// JPC_MAXRLVLS from src/libjasper/jpc/jpc_cs.h:\n<empty>\n\n// jas_image_bry from src/libjasper/jpc/jasper/jas_image.h:\n<empty>\n\n// JPC_COX_TERMALL from src/libjasper/jpc/jpc_cs.h:\n<empty>\n"
  },
  {
    "repository": "linux",
    "cve_id": "CVE-2019-19071",
    "cwe_list": [
      "CWE-401"
    ],
    "commit_hash": "d563131ef23cbc756026f839a82598c8445bc45f",
    "short_hash": "d563131e",
    "vulnerableMethods_before": [
      {
        "filename": "rsi_91x_mgmt.c",
        "method_name": "vulnerable_function",
        "raw_code": "static int rsi_send_beacon(struct rsi_common *common)\n{\n\tstruct sk_buff *skb = NULL;\n\tu8 dword_align_bytes = 0;\n\n\tskb = dev_alloc_skb(MAX_MGMT_PKT_SIZE);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tmemset(skb->data, 0, MAX_MGMT_PKT_SIZE);\n\n\tdword_align_bytes = ((unsigned long)skb->data & 0x3f);\n\tif (dword_align_bytes)\n\t\tskb_pull(skb, (64 - dword_align_bytes));\n\tif (rsi_prepare_beacon(common, skb)) {\n\t\trsi_dbg(ERR_ZONE, \"Failed to prepare beacon\\n\");\n\t\treturn -EINVAL;\n\t}\n\tskb_queue_tail(&common->tx_queue[MGMT_BEACON_Q], skb);\n\trsi_set_event(&common->tx_thread.event);\n\trsi_dbg(DATA_TX_ZONE, \"%s: Added to beacon queue\\n\", __func__);\n\n\treturn 0;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "rsi_91x_mgmt.c",
        "method_name": "fixed_function",
        "raw_code": "static int rsi_send_beacon(struct rsi_common *common)\n{\n\tstruct sk_buff *skb = NULL;\n\tu8 dword_align_bytes = 0;\n\n\tskb = dev_alloc_skb(MAX_MGMT_PKT_SIZE);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tmemset(skb->data, 0, MAX_MGMT_PKT_SIZE);\n\n\tdword_align_bytes = ((unsigned long)skb->data & 0x3f);\n\tif (dword_align_bytes)\n\t\tskb_pull(skb, (64 - dword_align_bytes));\n\tif (rsi_prepare_beacon(common, skb)) {\n\t\trsi_dbg(ERR_ZONE, \"Failed to prepare beacon\\n\");\n\t\tdev_kfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\tskb_queue_tail(&common->tx_queue[MGMT_BEACON_Q], skb);\n\trsi_set_event(&common->tx_thread.event);\n\trsi_dbg(DATA_TX_ZONE, \"%s: Added to beacon queue\\n\", __func__);\n\n\treturn 0;\n}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "ImageMagick",
    "cve_id": "CVE-2017-13139",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "d072ed6aff835c174e856ce3a428163c0da9e8f4",
    "short_hash": "d072ed6a",
    "vulnerableMethods_before": [
      {
        "filename": "png.c",
        "method_name": "vulnerable_function",
        "raw_code": "static Image *ReadOneMNGImage(MngInfo* mng_info, const ImageInfo *image_info,\n     ExceptionInfo *exception)\n{\n  char\n    page_geometry[MagickPathExtent];\n\n  Image\n    *image;\n\n  MagickBooleanType\n    logging;\n\n  volatile int\n    first_mng_object,\n    object_id,\n    term_chunk_found,\n    skip_to_iend;\n\n  volatile ssize_t\n    image_count=0;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  MngBox\n    default_fb,\n    fb,\n    previous_fb;\n\n#if defined(MNG_INSERT_LAYERS)\n  PixelInfo\n    mng_background_color;\n#endif\n\n  register unsigned char\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    count;\n\n  ssize_t\n    loop_level;\n\n  volatile short\n    skipping_loop;\n\n#if defined(MNG_INSERT_LAYERS)\n  unsigned int\n    mandatory_back=0;\n#endif\n\n  volatile unsigned int\n#ifdef MNG_OBJECT_BUFFERS\n    mng_background_object=0,\n#endif\n    mng_type=0;   /* 0: PNG or JNG; 1: MNG; 2: MNG-LC; 3: MNG-VLC */\n\n  size_t\n    default_frame_timeout,\n    frame_timeout,\n#if defined(MNG_INSERT_LAYERS)\n    image_height,\n    image_width,\n#endif\n    length;\n\n  /* These delays are all measured in image ticks_per_second,\n   * not in MNG ticks_per_second\n   */\n  volatile size_t\n    default_frame_delay,\n    final_delay,\n    final_image_delay,\n    frame_delay,\n#if defined(MNG_INSERT_LAYERS)\n    insert_layers,\n#endif\n    mng_iterations=1,\n    simplicity=0,\n    subframe_height=0,\n    subframe_width=0;\n\n  previous_fb.top=0;\n  previous_fb.bottom=0;\n  previous_fb.left=0;\n  previous_fb.right=0;\n  default_fb.top=0;\n  default_fb.bottom=0;\n  default_fb.left=0;\n  default_fb.right=0;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter ReadOneMNGImage()\");\n\n  image=mng_info->image;\n\n  if (LocaleCompare(image_info->magick,\"MNG\") == 0)\n    {\n      char\n        magic_number[MagickPathExtent];\n\n      /* Verify MNG signature.  */\n      count=(size_t) ReadBlob(image,8,(unsigned char *) magic_number);\n      if (memcmp(magic_number,\"\\212MNG\\r\\n\\032\\n\",8) != 0)\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n      /* Initialize some nonzero members of the MngInfo structure.  */\n      for (i=0; i < MNG_MAX_OBJECTS; i++)\n      {\n        mng_info->object_clip[i].right=(ssize_t) PNG_UINT_31_MAX;\n        mng_info->object_clip[i].bottom=(ssize_t) PNG_UINT_31_MAX;\n      }\n      mng_info->exists[0]=MagickTrue;\n    }\n\n  skipping_loop=(-1);\n  first_mng_object=MagickTrue;\n  mng_type=0;\n#if defined(MNG_INSERT_LAYERS)\n  insert_layers=MagickFalse; /* should be False during convert or mogrify */\n#endif\n  default_frame_delay=0;\n  default_frame_timeout=0;\n  frame_delay=0;\n  final_delay=1;\n  mng_info->ticks_per_second=1UL*image->ticks_per_second;\n  object_id=0;\n  skip_to_iend=MagickFalse;\n  term_chunk_found=MagickFalse;\n  mng_info->framing_mode=1;\n#if defined(MNG_INSERT_LAYERS)\n  mandatory_back=MagickFalse;\n#endif\n#if defined(MNG_INSERT_LAYERS)\n  mng_background_color=image->background_color;\n#endif\n  default_fb=mng_info->frame;\n  previous_fb=mng_info->frame;\n  do\n  {\n    char\n      type[MagickPathExtent];\n\n    if (LocaleCompare(image_info->magick,\"MNG\") == 0)\n      {\n        unsigned char\n          *chunk;\n\n        /*\n          Read a new chunk.\n        */\n        type[0]='\\0';\n        (void) ConcatenateMagickString(type,\"errr\",MagickPathExtent);\n        length=ReadBlobMSBLong(image);\n        count=(size_t) ReadBlob(image,4,(unsigned char *) type);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"  Reading MNG chunk type %c%c%c%c, length: %.20g\",\n           type[0],type[1],type[2],type[3],(double) length);\n\n        if (length > PNG_UINT_31_MAX)\n          {\n            status=MagickFalse;\n            break;\n          }\n\n        if (count == 0)\n          ThrowReaderException(CorruptImageError,\"CorruptImage\");\n\n        p=NULL;\n        chunk=(unsigned char *) NULL;\n\n        if (length != 0)\n          {\n            if (length > GetBlobSize(image))\n              ThrowReaderException(CorruptImageError,\n                \"InsufficientImageDataInFile\");\n            chunk=(unsigned char *) AcquireQuantumMemory(length+\n             MagickPathExtent,sizeof(*chunk));\n\n            if (chunk == (unsigned char *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n            for (i=0; i < (ssize_t) length; i++)\n            {\n              int\n                c;\n\n              c=ReadBlobByte(image);\n              if (c == EOF)\n                break;\n              chunk[i]=(unsigned char) c;\n            }\n\n            p=chunk;\n          }\n\n        (void) ReadBlobMSBLong(image);  /* read crc word */\n\n#if !defined(JNG_SUPPORTED)\n        if (memcmp(type,mng_JHDR,4) == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info->jhdr_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"JNGCompressNotSupported\",\"`%s'\",image->filename);\n\n            mng_info->jhdr_warning++;\n          }\n#endif\n        if (memcmp(type,mng_DHDR,4) == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info->dhdr_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"DeltaPNGNotSupported\",\"`%s'\",image->filename);\n\n            mng_info->dhdr_warning++;\n          }\n        if (memcmp(type,mng_MEND,4) == 0)\n          break;\n\n        if (skip_to_iend)\n          {\n            if (memcmp(type,mng_IEND,4) == 0)\n              skip_to_iend=MagickFalse;\n\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Skip to IEND.\");\n\n            continue;\n          }\n\n        if (memcmp(type,mng_MHDR,4) == 0)\n          {\n            if (length != 28)\n              {\n                chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                ThrowReaderException(CorruptImageError,\"CorruptImage\");\n              }\n\n            mng_info->mng_width=(size_t) ((p[0] << 24) | (p[1] << 16) |\n                (p[2] << 8) | p[3]);\n\n            mng_info->mng_height=(size_t) ((p[4] << 24) | (p[5] << 16) |\n                (p[6] << 8) | p[7]);\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  MNG width: %.20g\",(double) mng_info->mng_width);\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  MNG height: %.20g\",(double) mng_info->mng_height);\n              }\n\n            p+=8;\n            mng_info->ticks_per_second=(size_t) mng_get_long(p);\n\n            if (mng_info->ticks_per_second == 0)\n              default_frame_delay=0;\n\n            else\n              default_frame_delay=1UL*image->ticks_per_second/\n                mng_info->ticks_per_second;\n\n            frame_delay=default_frame_delay;\n            simplicity=0;\n\n            p+=16;\n            simplicity=(size_t) mng_get_long(p);\n\n            mng_type=1;    /* Full MNG */\n\n            if ((simplicity != 0) && ((simplicity | 11) == 11))\n              mng_type=2; /* LC */\n\n            if ((simplicity != 0) && ((simplicity | 9) == 9))\n              mng_type=3; /* VLC */\n\n#if defined(MNG_INSERT_LAYERS)\n            if (mng_type != 3)\n              insert_layers=MagickTrue;\n#endif\n            if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n              {\n                /* Allocate next image structure.  */\n                AcquireNextImage(image_info,image,exception);\n\n                if (GetNextImageInList(image) == (Image *) NULL)\n                  return((Image *) NULL);\n\n                image=SyncNextImageInList(image);\n                mng_info->image=image;\n              }\n\n            if ((mng_info->mng_width > 65535L) ||\n                (mng_info->mng_height > 65535L))\n              {\n                chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                ThrowReaderException(ImageError,\"WidthOrHeightExceedsLimit\");\n              }\n\n            (void) FormatLocaleString(page_geometry,MagickPathExtent,\n              \"%.20gx%.20g+0+0\",(double) mng_info->mng_width,(double)\n              mng_info->mng_height);\n\n            mng_info->frame.left=0;\n            mng_info->frame.right=(ssize_t) mng_info->mng_width;\n            mng_info->frame.top=0;\n            mng_info->frame.bottom=(ssize_t) mng_info->mng_height;\n            mng_info->clip=default_fb=previous_fb=mng_info->frame;\n\n            for (i=0; i < MNG_MAX_OBJECTS; i++)\n              mng_info->object_clip[i]=mng_info->frame;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_TERM,4) == 0)\n          {\n            int\n              repeat=0;\n\n            if (length != 0)\n              repeat=p[0];\n\n            if (repeat == 3)\n              {\n                final_delay=(png_uint_32) mng_get_long(&p[2]);\n                mng_iterations=(png_uint_32) mng_get_long(&p[6]);\n\n                if (mng_iterations == PNG_UINT_31_MAX)\n                  mng_iterations=0;\n\n                image->iterations=mng_iterations;\n                term_chunk_found=MagickTrue;\n              }\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    repeat=%d,  final_delay=%.20g,  iterations=%.20g\",\n                  repeat,(double) final_delay, (double) image->iterations);\n              }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_DEFI,4) == 0)\n          {\n            if (mng_type == 3)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"DEFI chunk found in MNG-VLC datastream\",\"`%s'\",\n                image->filename);\n\n            if (length < 2)\n              {\n                if (chunk)\n                  chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                ThrowReaderException(CorruptImageError,\"CorruptImage\");\n              }\n\n            object_id=(p[0] << 8) | p[1];\n\n            if (mng_type == 2 && object_id != 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"Nonzero object_id in MNG-LC datastream\",\"`%s'\",\n                image->filename);\n\n            if (object_id > MNG_MAX_OBJECTS)\n              {\n                /*\n                  Instead of using a warning we should allocate a larger\n                  MngInfo structure and continue.\n                */\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  CoderError,\"object id too large\",\"`%s'\",image->filename);\n                object_id=MNG_MAX_OBJECTS;\n              }\n\n            if (mng_info->exists[object_id])\n              if (mng_info->frozen[object_id])\n                {\n                  chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                  (void) ThrowMagickException(exception,\n                    GetMagickModule(),CoderError,\n                    \"DEFI cannot redefine a frozen MNG object\",\"`%s'\",\n                    image->filename);\n                  continue;\n                }\n\n            mng_info->exists[object_id]=MagickTrue;\n\n            if (length > 2)\n              mng_info->invisible[object_id]=p[2];\n\n            /*\n              Extract object offset info.\n            */\n            if (length > 11)\n              {\n                mng_info->x_off[object_id]=(ssize_t) ((p[4] << 24) |\n                    (p[5] << 16) | (p[6] << 8) | p[7]);\n\n                mng_info->y_off[object_id]=(ssize_t) ((p[8] << 24) |\n                    (p[9] << 16) | (p[10] << 8) | p[11]);\n\n                if (logging != MagickFalse)\n                  {\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"  x_off[%d]: %.20g,  y_off[%d]: %.20g\",\n                      object_id,(double) mng_info->x_off[object_id],\n                      object_id,(double) mng_info->y_off[object_id]);\n                  }\n              }\n\n            /*\n              Extract object clipping info.\n            */\n            if (length > 27)\n              mng_info->object_clip[object_id]=mng_read_box(mng_info->frame,0,\n                &p[12]);\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_bKGD,4) == 0)\n          {\n            mng_info->have_global_bkgd=MagickFalse;\n\n            if (length > 5)\n              {\n                mng_info->mng_global_bkgd.red=\n                  ScaleShortToQuantum((unsigned short) ((p[0] << 8) | p[1]));\n\n                mng_info->mng_global_bkgd.green=\n                  ScaleShortToQuantum((unsigned short) ((p[2] << 8) | p[3]));\n\n                mng_info->mng_global_bkgd.blue=\n                  ScaleShortToQuantum((unsigned short) ((p[4] << 8) | p[5]));\n\n                mng_info->have_global_bkgd=MagickTrue;\n              }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_BACK,4) == 0)\n          {\n#if defined(MNG_INSERT_LAYERS)\n            if (length > 6)\n              mandatory_back=p[6];\n\n            else\n              mandatory_back=0;\n\n            if (mandatory_back && length > 5)\n              {\n                mng_background_color.red=\n                    ScaleShortToQuantum((unsigned short) ((p[0] << 8) | p[1]));\n\n                mng_background_color.green=\n                    ScaleShortToQuantum((unsigned short) ((p[2] << 8) | p[3]));\n\n                mng_background_color.blue=\n                    ScaleShortToQuantum((unsigned short) ((p[4] << 8) | p[5]));\n\n                mng_background_color.alpha=OpaqueAlpha;\n              }\n\n#ifdef MNG_OBJECT_BUFFERS\n            if (length > 8)\n              mng_background_object=(p[7] << 8) | p[8];\n#endif\n#endif\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_PLTE,4) == 0)\n          {\n            /* Read global PLTE.  */\n\n            if (length && (length < 769))\n              {\n                if (mng_info->global_plte == (png_colorp) NULL)\n                  mng_info->global_plte=(png_colorp) AcquireQuantumMemory(256,\n                    sizeof(*mng_info->global_plte));\n\n                for (i=0; i < (ssize_t) (length/3); i++)\n                {\n                  mng_info->global_plte[i].red=p[3*i];\n                  mng_info->global_plte[i].green=p[3*i+1];\n                  mng_info->global_plte[i].blue=p[3*i+2];\n                }\n\n                mng_info->global_plte_length=(unsigned int) (length/3);\n              }\n#ifdef MNG_LOOSE\n            for ( ; i < 256; i++)\n            {\n              mng_info->global_plte[i].red=i;\n              mng_info->global_plte[i].green=i;\n              mng_info->global_plte[i].blue=i;\n            }\n\n            if (length != 0)\n              mng_info->global_plte_length=256;\n#endif\n            else\n              mng_info->global_plte_length=0;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_tRNS,4) == 0)\n          {\n            /* read global tRNS */\n\n            if (length > 0 && length < 257)\n              for (i=0; i < (ssize_t) length; i++)\n                mng_info->global_trns[i]=p[i];\n\n#ifdef MNG_LOOSE\n            for ( ; i < 256; i++)\n              mng_info->global_trns[i]=255;\n#endif\n            mng_info->global_trns_length=(unsigned int) length;\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_gAMA,4) == 0)\n          {\n            if (length == 4)\n              {\n                ssize_t\n                  igamma;\n\n                igamma=mng_get_long(p);\n                mng_info->global_gamma=((float) igamma)*0.00001;\n                mng_info->have_global_gama=MagickTrue;\n              }\n\n            else\n              mng_info->have_global_gama=MagickFalse;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_cHRM,4) == 0)\n          {\n            /* Read global cHRM */\n\n            if (length == 32)\n              {\n                mng_info->global_chrm.white_point.x=0.00001*mng_get_long(p);\n                mng_info->global_chrm.white_point.y=0.00001*mng_get_long(&p[4]);\n                mng_info->global_chrm.red_primary.x=0.00001*mng_get_long(&p[8]);\n                mng_info->global_chrm.red_primary.y=0.00001*\n                  mng_get_long(&p[12]);\n                mng_info->global_chrm.green_primary.x=0.00001*\n                  mng_get_long(&p[16]);\n                mng_info->global_chrm.green_primary.y=0.00001*\n                  mng_get_long(&p[20]);\n                mng_info->global_chrm.blue_primary.x=0.00001*\n                  mng_get_long(&p[24]);\n                mng_info->global_chrm.blue_primary.y=0.00001*\n                  mng_get_long(&p[28]);\n                mng_info->have_global_chrm=MagickTrue;\n              }\n            else\n              mng_info->have_global_chrm=MagickFalse;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_sRGB,4) == 0)\n          {\n            /*\n              Read global sRGB.\n            */\n            if (length != 0)\n              {\n                mng_info->global_srgb_intent=\n                  Magick_RenderingIntent_from_PNG_RenderingIntent(p[0]);\n                mng_info->have_global_srgb=MagickTrue;\n              }\n            else\n              mng_info->have_global_srgb=MagickFalse;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_iCCP,4) == 0)\n          {\n            /* To do: */\n\n            /*\n              Read global iCCP.\n            */\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n\n        if (memcmp(type,mng_FRAM,4) == 0)\n          {\n            if (mng_type == 3)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"FRAM chunk found in MNG-VLC datastream\",\"`%s'\",\n                image->filename);\n\n            if ((mng_info->framing_mode == 2) || (mng_info->framing_mode == 4))\n              image->delay=frame_delay;\n\n            frame_delay=default_frame_delay;\n            frame_timeout=default_frame_timeout;\n            fb=default_fb;\n\n            if (length != 0)\n              if (p[0])\n                mng_info->framing_mode=p[0];\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Framing_mode=%d\",mng_info->framing_mode);\n\n            if (length > 6)\n              {\n                /* Note the delay and frame clipping boundaries.  */\n\n                p++; /* framing mode */\n\n                while (*p && ((p-chunk) < (ssize_t) length))\n                  p++;  /* frame name */\n\n                p++;  /* frame name terminator */\n\n                if ((p-chunk) < (ssize_t) (length-4))\n                  {\n                    int\n                      change_delay,\n                      change_timeout,\n                      change_clipping;\n\n                    change_delay=(*p++);\n                    change_timeout=(*p++);\n                    change_clipping=(*p++);\n                    p++; /* change_sync */\n\n                    if (change_delay)\n                      {\n                        frame_delay=1UL*image->ticks_per_second*\n                          mng_get_long(p);\n\n                        if (mng_info->ticks_per_second != 0)\n                          frame_delay/=mng_info->ticks_per_second;\n\n                        else\n                          frame_delay=PNG_UINT_31_MAX;\n\n                        if (change_delay == 2)\n                          default_frame_delay=frame_delay;\n\n                        p+=4;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"    Framing_delay=%.20g\",(double) frame_delay);\n                      }\n\n                    if (change_timeout)\n                      {\n                        frame_timeout=1UL*image->ticks_per_second*\n                          mng_get_long(p);\n\n                        if (mng_info->ticks_per_second != 0)\n                          frame_timeout/=mng_info->ticks_per_second;\n\n                        else\n                          frame_timeout=PNG_UINT_31_MAX;\n\n                        if (change_timeout == 2)\n                          default_frame_timeout=frame_timeout;\n\n                        p+=4;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"    Framing_timeout=%.20g\",(double) frame_timeout);\n                      }\n\n                    if (change_clipping)\n                      {\n                        fb=mng_read_box(previous_fb,(char) p[0],&p[1]);\n                        p+=17;\n                        previous_fb=fb;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"    Frame_clip: L=%.20g R=%.20g T=%.20g B=%.20g\",\n                            (double) fb.left,(double) fb.right,(double) fb.top,\n                            (double) fb.bottom);\n\n                        if (change_clipping == 2)\n                          default_fb=fb;\n                      }\n                  }\n              }\n            mng_info->clip=fb;\n            mng_info->clip=mng_minimum_box(fb,mng_info->frame);\n\n            subframe_width=(size_t) (mng_info->clip.right\n               -mng_info->clip.left);\n\n            subframe_height=(size_t) (mng_info->clip.bottom\n               -mng_info->clip.top);\n            /*\n              Insert a background layer behind the frame if framing_mode is 4.\n            */\n#if defined(MNG_INSERT_LAYERS)\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"   subframe_width=%.20g, subframe_height=%.20g\",(double)\n                subframe_width,(double) subframe_height);\n\n            if (insert_layers && (mng_info->framing_mode == 4) &&\n                (subframe_width) && (subframe_height))\n              {\n                /* Allocate next image structure.  */\n                if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n                  {\n                    AcquireNextImage(image_info,image,exception);\n\n                    if (GetNextImageInList(image) == (Image *) NULL)\n                      return(DestroyImageList(image));\n\n                    image=SyncNextImageInList(image);\n                  }\n\n                mng_info->image=image;\n\n                if (term_chunk_found)\n                  {\n                    image->start_loop=MagickTrue;\n                    image->iterations=mng_iterations;\n                    term_chunk_found=MagickFalse;\n                  }\n\n                else\n                    image->start_loop=MagickFalse;\n\n                image->columns=subframe_width;\n                image->rows=subframe_height;\n                image->page.width=subframe_width;\n                image->page.height=subframe_height;\n                image->page.x=mng_info->clip.left;\n                image->page.y=mng_info->clip.top;\n                image->background_color=mng_background_color;\n                image->alpha_trait=UndefinedPixelTrait;\n                image->delay=0;\n                (void) SetImageBackgroundColor(image,exception);\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Insert backgd layer, L=%.20g, R=%.20g T=%.20g, B=%.20g\",\n                    (double) mng_info->clip.left,\n                    (double) mng_info->clip.right,\n                    (double) mng_info->clip.top,\n                    (double) mng_info->clip.bottom);\n              }\n#endif\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_CLIP,4) == 0)\n          {\n            unsigned int\n              first_object,\n              last_object;\n\n            /*\n              Read CLIP.\n            */\n            if (length > 3)\n              {\n                first_object=(p[0] << 8) | p[1];\n                last_object=(p[2] << 8) | p[3];\n                p+=4;\n\n                for (i=(int) first_object; i <= (int) last_object; i++)\n                {\n                  if (mng_info->exists[i] && !mng_info->frozen[i])\n                    {\n                      MngBox\n                        box;\n\n                      box=mng_info->object_clip[i];\n                      if ((p-chunk) < (ssize_t) (length-17))\n                        mng_info->object_clip[i]=\n                           mng_read_box(box,(char) p[0],&p[1]);\n                    }\n                }\n\n              }\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_SAVE,4) == 0)\n          {\n            for (i=1; i < MNG_MAX_OBJECTS; i++)\n              if (mng_info->exists[i])\n                {\n                 mng_info->frozen[i]=MagickTrue;\n#ifdef MNG_OBJECT_BUFFERS\n                 if (mng_info->ob[i] != (MngBuffer *) NULL)\n                    mng_info->ob[i]->frozen=MagickTrue;\n#endif\n                }\n\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n\n        if ((memcmp(type,mng_DISC,4) == 0) || (memcmp(type,mng_SEEK,4) == 0))\n          {\n            /* Read DISC or SEEK.  */\n\n            if ((length == 0) || !memcmp(type,mng_SEEK,4))\n              {\n                for (i=1; i < MNG_MAX_OBJECTS; i++)\n                  MngInfoDiscardObject(mng_info,i);\n              }\n\n            else\n              {\n                register ssize_t\n                  j;\n\n                for (j=1; j < (ssize_t) length; j+=2)\n                {\n                  i=p[j-1] << 8 | p[j];\n                  MngInfoDiscardObject(mng_info,i);\n                }\n              }\n\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n\n        if (memcmp(type,mng_MOVE,4) == 0)\n          {\n            size_t\n              first_object,\n              last_object;\n\n            /* read MOVE */\n\n            if (length > 3)\n            {\n              first_object=(p[0] << 8) | p[1];\n              last_object=(p[2] << 8) | p[3];\n              p+=4;\n\n              for (i=(ssize_t) first_object; i <= (ssize_t) last_object; i++)\n              {\n                if ((i < 0) || (i >= MNG_MAX_OBJECTS))\n                  continue;\n\n                if (mng_info->exists[i] && !mng_info->frozen[i] &&\n                    (p-chunk) < (ssize_t) (length-8))\n                  {\n                    MngPair\n                      new_pair;\n\n                    MngPair\n                      old_pair;\n\n                    old_pair.a=mng_info->x_off[i];\n                    old_pair.b=mng_info->y_off[i];\n                    new_pair=mng_read_pair(old_pair,(int) p[0],&p[1]);\n                    mng_info->x_off[i]=new_pair.a;\n                    mng_info->y_off[i]=new_pair.b;\n                  }\n              }\n            }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_LOOP,4) == 0)\n          {\n            ssize_t loop_iters=1;\n            if (length > 4)\n              {\n                loop_level=chunk[0];\n                mng_info->loop_active[loop_level]=1;  /* mark loop active */\n\n                /* Record starting point.  */\n                loop_iters=mng_get_long(&chunk[1]);\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  LOOP level %.20g has %.20g iterations \",\n                    (double) loop_level, (double) loop_iters);\n\n                if (loop_iters == 0)\n                  skipping_loop=loop_level;\n\n                else\n                  {\n                    mng_info->loop_jump[loop_level]=TellBlob(image);\n                    mng_info->loop_count[loop_level]=loop_iters;\n                  }\n\n                mng_info->loop_iteration[loop_level]=0;\n              }\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_ENDL,4) == 0)\n          {\n            if (length > 0)\n              {\n                loop_level=chunk[0];\n\n                if (skipping_loop > 0)\n                  {\n                    if (skipping_loop == loop_level)\n                      {\n                        /*\n                          Found end of zero-iteration loop.\n                        */\n                        skipping_loop=(-1);\n                        mng_info->loop_active[loop_level]=0;\n                      }\n                  }\n\n                else\n                  {\n                    if (mng_info->loop_active[loop_level] == 1)\n                      {\n                        mng_info->loop_count[loop_level]--;\n                        mng_info->loop_iteration[loop_level]++;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  ENDL: LOOP level %.20g has %.20g remaining iters\",\n                            (double) loop_level,(double)\n                            mng_info->loop_count[loop_level]);\n\n                        if (mng_info->loop_count[loop_level] != 0)\n                          {\n                            offset=\n                              SeekBlob(image,mng_info->loop_jump[loop_level],\n                              SEEK_SET);\n\n                            if (offset < 0)\n                              {\n                                chunk=(unsigned char *) RelinquishMagickMemory(\n                                  chunk);\n                                ThrowReaderException(CorruptImageError,\n                                  \"ImproperImageHeader\");\n                              }\n                          }\n\n                        else\n                          {\n                            short\n                              last_level;\n\n                            /*\n                              Finished loop.\n                            */\n                            mng_info->loop_active[loop_level]=0;\n                            last_level=(-1);\n                            for (i=0; i < loop_level; i++)\n                              if (mng_info->loop_active[i] == 1)\n                                last_level=(short) i;\n                            loop_level=last_level;\n                          }\n                      }\n                  }\n              }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_CLON,4) == 0)\n          {\n            if (mng_info->clon_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"CLON is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->clon_warning++;\n          }\n\n        if (memcmp(type,mng_MAGN,4) == 0)\n          {\n            png_uint_16\n              magn_first,\n              magn_last,\n              magn_mb,\n              magn_ml,\n              magn_mr,\n              magn_mt,\n              magn_mx,\n              magn_my,\n              magn_methx,\n              magn_methy;\n\n            if (length > 1)\n              magn_first=(p[0] << 8) | p[1];\n\n            else\n              magn_first=0;\n\n            if (length > 3)\n              magn_last=(p[2] << 8) | p[3];\n\n            else\n              magn_last=magn_first;\n#ifndef MNG_OBJECT_BUFFERS\n            if (magn_first || magn_last)\n              if (mng_info->magn_warning == 0)\n                {\n                  (void) ThrowMagickException(exception,\n                     GetMagickModule(),CoderError,\n                     \"MAGN is not implemented yet for nonzero objects\",\n                     \"`%s'\",image->filename);\n\n                   mng_info->magn_warning++;\n                }\n#endif\n            if (length > 4)\n              magn_methx=p[4];\n\n            else\n              magn_methx=0;\n\n            if (length > 6)\n              magn_mx=(p[5] << 8) | p[6];\n\n            else\n              magn_mx=1;\n\n            if (magn_mx == 0)\n              magn_mx=1;\n\n            if (length > 8)\n              magn_my=(p[7] << 8) | p[8];\n\n            else\n              magn_my=magn_mx;\n\n            if (magn_my == 0)\n              magn_my=1;\n\n            if (length > 10)\n              magn_ml=(p[9] << 8) | p[10];\n\n            else\n              magn_ml=magn_mx;\n\n            if (magn_ml == 0)\n              magn_ml=1;\n\n            if (length > 12)\n              magn_mr=(p[11] << 8) | p[12];\n\n            else\n              magn_mr=magn_mx;\n\n            if (magn_mr == 0)\n              magn_mr=1;\n\n            if (length > 14)\n              magn_mt=(p[13] << 8) | p[14];\n\n            else\n              magn_mt=magn_my;\n\n            if (magn_mt == 0)\n              magn_mt=1;\n\n            if (length > 16)\n              magn_mb=(p[15] << 8) | p[16];\n\n            else\n              magn_mb=magn_my;\n\n            if (magn_mb == 0)\n              magn_mb=1;\n\n            if (length > 17)\n              magn_methy=p[17];\n\n            else\n              magn_methy=magn_methx;\n\n\n            if (magn_methx > 5 || magn_methy > 5)\n              if (mng_info->magn_warning == 0)\n                {\n                  (void) ThrowMagickException(exception,\n                     GetMagickModule(),CoderError,\n                     \"Unknown MAGN method in MNG datastream\",\"`%s'\",\n                     image->filename);\n\n                   mng_info->magn_warning++;\n                }\n#ifdef MNG_OBJECT_BUFFERS\n          /* Magnify existing objects in the range magn_first to magn_last */\n#endif\n            if (magn_first == 0 || magn_last == 0)\n              {\n                /* Save the magnification factors for object 0 */\n                mng_info->magn_mb=magn_mb;\n                mng_info->magn_ml=magn_ml;\n                mng_info->magn_mr=magn_mr;\n                mng_info->magn_mt=magn_mt;\n                mng_info->magn_mx=magn_mx;\n                mng_info->magn_my=magn_my;\n                mng_info->magn_methx=magn_methx;\n                mng_info->magn_methy=magn_methy;\n              }\n          }\n\n        if (memcmp(type,mng_PAST,4) == 0)\n          {\n            if (mng_info->past_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"PAST is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->past_warning++;\n          }\n\n        if (memcmp(type,mng_SHOW,4) == 0)\n          {\n            if (mng_info->show_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"SHOW is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->show_warning++;\n          }\n\n        if (memcmp(type,mng_sBIT,4) == 0)\n          {\n            if (length < 4)\n              mng_info->have_global_sbit=MagickFalse;\n\n            else\n              {\n                mng_info->global_sbit.gray=p[0];\n                mng_info->global_sbit.red=p[0];\n                mng_info->global_sbit.green=p[1];\n                mng_info->global_sbit.blue=p[2];\n                mng_info->global_sbit.alpha=p[3];\n                mng_info->have_global_sbit=MagickTrue;\n             }\n          }\n        if (memcmp(type,mng_pHYs,4) == 0)\n          {\n            if (length > 8)\n              {\n                mng_info->global_x_pixels_per_unit=\n                    (size_t) mng_get_long(p);\n                mng_info->global_y_pixels_per_unit=\n                    (size_t) mng_get_long(&p[4]);\n                mng_info->global_phys_unit_type=p[8];\n                mng_info->have_global_phys=MagickTrue;\n              }\n\n            else\n              mng_info->have_global_phys=MagickFalse;\n          }\n        if (memcmp(type,mng_pHYg,4) == 0)\n          {\n            if (mng_info->phyg_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"pHYg is not implemented.\",\"`%s'\",image->filename);\n\n            mng_info->phyg_warning++;\n          }\n        if (memcmp(type,mng_BASI,4) == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info->basi_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"BASI is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->basi_warning++;\n#ifdef MNG_BASI_SUPPORTED\n            basi_width=(size_t) ((p[0] << 24) | (p[1] << 16) |\n               (p[2] << 8) | p[3]);\n            basi_height=(size_t) ((p[4] << 24) | (p[5] << 16) |\n               (p[6] << 8) | p[7]);\n            basi_color_type=p[8];\n            basi_compression_method=p[9];\n            basi_filter_type=p[10];\n            basi_interlace_method=p[11];\n            if (length > 11)\n              basi_red=(p[12] << 8) & p[13];\n\n            else\n              basi_red=0;\n\n            if (length > 13)\n              basi_green=(p[14] << 8) & p[15];\n\n            else\n              basi_green=0;\n\n            if (length > 15)\n              basi_blue=(p[16] << 8) & p[17];\n\n            else\n              basi_blue=0;\n\n            if (length > 17)\n              basi_alpha=(p[18] << 8) & p[19];\n\n            else\n              {\n                if (basi_sample_depth == 16)\n                  basi_alpha=65535L;\n                else\n                  basi_alpha=255;\n              }\n\n            if (length > 19)\n              basi_viewable=p[20];\n\n            else\n              basi_viewable=0;\n\n#endif\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_IHDR,4)\n#if defined(JNG_SUPPORTED)\n            && memcmp(type,mng_JHDR,4)\n#endif\n            )\n          {\n            /* Not an IHDR or JHDR chunk */\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n/* Process IHDR */\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Processing %c%c%c%c chunk\",type[0],type[1],type[2],type[3]);\n\n        mng_info->exists[object_id]=MagickTrue;\n        mng_info->viewable[object_id]=MagickTrue;\n\n        if (mng_info->invisible[object_id])\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Skipping invisible object\");\n\n            skip_to_iend=MagickTrue;\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n#if defined(MNG_INSERT_LAYERS)\n        if (length < 8)\n          {\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          }\n\n        image_width=(size_t) mng_get_long(p);\n        image_height=(size_t) mng_get_long(&p[4]);\n#endif\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        /*\n          Insert a transparent background layer behind the entire animation\n          if it is not full screen.\n        */\n#if defined(MNG_INSERT_LAYERS)\n        if (insert_layers && mng_type && first_mng_object)\n          {\n            if ((mng_info->clip.left > 0) || (mng_info->clip.top > 0) ||\n                (image_width < mng_info->mng_width) ||\n                (mng_info->clip.right < (ssize_t) mng_info->mng_width) ||\n                (image_height < mng_info->mng_height) ||\n                (mng_info->clip.bottom < (ssize_t) mng_info->mng_height))\n              {\n                if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n                  {\n                    /*\n                      Allocate next image structure.\n                    */\n                    AcquireNextImage(image_info,image,exception);\n\n                    if (GetNextImageInList(image) == (Image *) NULL)\n                      return(DestroyImageList(image));\n\n                    image=SyncNextImageInList(image);\n                  }\n                mng_info->image=image;\n\n                if (term_chunk_found)\n                  {\n                    image->start_loop=MagickTrue;\n                    image->iterations=mng_iterations;\n                    term_chunk_found=MagickFalse;\n                  }\n\n                else\n                    image->start_loop=MagickFalse;\n\n                /* Make a background rectangle.  */\n\n                image->delay=0;\n                image->columns=mng_info->mng_width;\n                image->rows=mng_info->mng_height;\n                image->page.width=mng_info->mng_width;\n                image->page.height=mng_info->mng_height;\n                image->page.x=0;\n                image->page.y=0;\n                image->background_color=mng_background_color;\n                (void) SetImageBackgroundColor(image,exception);\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Inserted transparent background layer, W=%.20g, H=%.20g\",\n                    (double) mng_info->mng_width,(double) mng_info->mng_height);\n              }\n          }\n        /*\n          Insert a background layer behind the upcoming image if\n          framing_mode is 3, and we haven't already inserted one.\n        */\n        if (insert_layers && (mng_info->framing_mode == 3) &&\n                (subframe_width) && (subframe_height) && (simplicity == 0 ||\n                (simplicity & 0x08)))\n          {\n            if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n            {\n              /*\n                Allocate next image structure.\n              */\n              AcquireNextImage(image_info,image,exception);\n\n              if (GetNextImageInList(image) == (Image *) NULL)\n                return(DestroyImageList(image));\n\n              image=SyncNextImageInList(image);\n            }\n\n            mng_info->image=image;\n\n            if (term_chunk_found)\n              {\n                image->start_loop=MagickTrue;\n                image->iterations=mng_iterations;\n                term_chunk_found=MagickFalse;\n              }\n\n            else\n                image->start_loop=MagickFalse;\n\n            image->delay=0;\n            image->columns=subframe_width;\n            image->rows=subframe_height;\n            image->page.width=subframe_width;\n            image->page.height=subframe_height;\n            image->page.x=mng_info->clip.left;\n            image->page.y=mng_info->clip.top;\n            image->background_color=mng_background_color;\n            image->alpha_trait=UndefinedPixelTrait;\n            (void) SetImageBackgroundColor(image,exception);\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Insert background layer, L=%.20g, R=%.20g T=%.20g, B=%.20g\",\n                (double) mng_info->clip.left,(double) mng_info->clip.right,\n                (double) mng_info->clip.top,(double) mng_info->clip.bottom);\n          }\n#endif /* MNG_INSERT_LAYERS */\n        first_mng_object=MagickFalse;\n\n        if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n          {\n            /*\n              Allocate next image structure.\n            */\n            AcquireNextImage(image_info,image,exception);\n\n            if (GetNextImageInList(image) == (Image *) NULL)\n              return(DestroyImageList(image));\n\n            image=SyncNextImageInList(image);\n          }\n        mng_info->image=image;\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n\n        if (status == MagickFalse)\n          break;\n\n        if (term_chunk_found)\n          {\n            image->start_loop=MagickTrue;\n            term_chunk_found=MagickFalse;\n          }\n\n        else\n            image->start_loop=MagickFalse;\n\n        if (mng_info->framing_mode == 1 || mng_info->framing_mode == 3)\n          {\n            image->delay=frame_delay;\n            frame_delay=default_frame_delay;\n          }\n\n        else\n          image->delay=0;\n\n        image->page.width=mng_info->mng_width;\n        image->page.height=mng_info->mng_height;\n        image->page.x=mng_info->x_off[object_id];\n        image->page.y=mng_info->y_off[object_id];\n        image->iterations=mng_iterations;\n\n        /*\n          Seek back to the beginning of the IHDR or JHDR chunk's length field.\n        */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Seeking back to beginning of %c%c%c%c chunk\",type[0],type[1],\n            type[2],type[3]);\n\n        offset=SeekBlob(image,-((ssize_t) length+12),SEEK_CUR);\n\n        if (offset < 0)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n\n    mng_info->image=image;\n    mng_info->mng_type=mng_type;\n    mng_info->object_id=object_id;\n\n    if (memcmp(type,mng_IHDR,4) == 0)\n      image=ReadOnePNGImage(mng_info,image_info,exception);\n\n#if defined(JNG_SUPPORTED)\n    else\n      image=ReadOneJNGImage(mng_info,image_info,exception);\n#endif\n\n    if (image == (Image *) NULL)\n      {\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"exit ReadJNGImage() with error\");\n\n        return((Image *) NULL);\n      }\n\n    if (image->columns == 0 || image->rows == 0)\n      {\n        (void) CloseBlob(image);\n        return(DestroyImageList(image));\n      }\n\n    mng_info->image=image;\n\n    if (mng_type)\n      {\n        MngBox\n          crop_box;\n\n        if (mng_info->magn_methx || mng_info->magn_methy)\n          {\n            png_uint_32\n               magnified_height,\n               magnified_width;\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Processing MNG MAGN chunk\");\n\n            if (mng_info->magn_methx == 1)\n              {\n                magnified_width=mng_info->magn_ml;\n\n                if (image->columns > 1)\n                   magnified_width += mng_info->magn_mr;\n\n                if (image->columns > 2)\n                   magnified_width += (png_uint_32)\n                      ((image->columns-2)*(mng_info->magn_mx));\n              }\n\n            else\n              {\n                magnified_width=(png_uint_32) image->columns;\n\n                if (image->columns > 1)\n                   magnified_width += mng_info->magn_ml-1;\n\n                if (image->columns > 2)\n                   magnified_width += mng_info->magn_mr-1;\n\n                if (image->columns > 3)\n                   magnified_width += (png_uint_32)\n                      ((image->columns-3)*(mng_info->magn_mx-1));\n              }\n\n            if (mng_info->magn_methy == 1)\n              {\n                magnified_height=mng_info->magn_mt;\n\n                if (image->rows > 1)\n                   magnified_height += mng_info->magn_mb;\n\n                if (image->rows > 2)\n                   magnified_height += (png_uint_32)\n                      ((image->rows-2)*(mng_info->magn_my));\n              }\n\n            else\n              {\n                magnified_height=(png_uint_32) image->rows;\n\n                if (image->rows > 1)\n                   magnified_height += mng_info->magn_mt-1;\n\n                if (image->rows > 2)\n                   magnified_height += mng_info->magn_mb-1;\n\n                if (image->rows > 3)\n                   magnified_height += (png_uint_32)\n                      ((image->rows-3)*(mng_info->magn_my-1));\n              }\n\n            if (magnified_height > image->rows ||\n                magnified_width > image->columns)\n              {\n                Image\n                  *large_image;\n\n                int\n                  yy;\n\n                Quantum\n                  *next,\n                  *prev;\n\n                png_uint_16\n                  magn_methx,\n                  magn_methy;\n\n                ssize_t\n                  m,\n                  y;\n\n                register Quantum\n                  *n,\n                  *q;\n\n                register ssize_t\n                  x;\n\n                /* Allocate next image structure.  */\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Allocate magnified image\");\n\n                AcquireNextImage(image_info,image,exception);\n\n                if (GetNextImageInList(image) == (Image *) NULL)\n                  return(DestroyImageList(image));\n\n                large_image=SyncNextImageInList(image);\n\n                large_image->columns=magnified_width;\n                large_image->rows=magnified_height;\n\n                magn_methx=mng_info->magn_methx;\n                magn_methy=mng_info->magn_methy;\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n#define QM unsigned short\n                if (magn_methx != 1 || magn_methy != 1)\n                  {\n                  /*\n                     Scale pixels to unsigned shorts to prevent\n                     overflow of intermediate values of interpolations\n                  */\n                     for (y=0; y < (ssize_t) image->rows; y++)\n                     {\n                       q=GetAuthenticPixels(image,0,y,image->columns,1,\n                          exception);\n\n                       for (x=(ssize_t) image->columns-1; x >= 0; x--)\n                       {\n                          SetPixelRed(image,ScaleQuantumToShort(\n                            GetPixelRed(image,q)),q);\n                          SetPixelGreen(image,ScaleQuantumToShort(\n                            GetPixelGreen(image,q)),q);\n                          SetPixelBlue(image,ScaleQuantumToShort(\n                            GetPixelBlue(image,q)),q);\n                          SetPixelAlpha(image,ScaleQuantumToShort(\n                            GetPixelAlpha(image,q)),q);\n                          q+=GetPixelChannels(image);\n                       }\n\n                       if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                         break;\n                     }\n                  }\n#else\n#define QM Quantum\n#endif\n\n                if (image->alpha_trait != UndefinedPixelTrait)\n                   (void) SetImageBackgroundColor(large_image,exception);\n\n                else\n                  {\n                    large_image->background_color.alpha=OpaqueAlpha;\n                    (void) SetImageBackgroundColor(large_image,exception);\n\n                    if (magn_methx == 4)\n                      magn_methx=2;\n\n                    if (magn_methx == 5)\n                      magn_methx=3;\n\n                    if (magn_methy == 4)\n                      magn_methy=2;\n\n                    if (magn_methy == 5)\n                      magn_methy=3;\n                  }\n\n                /* magnify the rows into the right side of the large image */\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Magnify the rows to %.20g\",\n                    (double) large_image->rows);\n                m=(ssize_t) mng_info->magn_mt;\n                yy=0;\n                length=(size_t) GetPixelChannels(image)*image->columns;\n                next=(Quantum *) AcquireQuantumMemory(length,sizeof(*next));\n                prev=(Quantum *) AcquireQuantumMemory(length,sizeof(*prev));\n\n                if ((prev == (Quantum *) NULL) ||\n                    (next == (Quantum *) NULL))\n                  {\n                     image=DestroyImageList(image);\n                     ThrowReaderException(ResourceLimitError,\n                       \"MemoryAllocationFailed\");\n                  }\n\n                n=GetAuthenticPixels(image,0,0,image->columns,1,exception);\n                (void) CopyMagickMemory(next,n,length);\n\n                for (y=0; y < (ssize_t) image->rows; y++)\n                {\n                  if (y == 0)\n                    m=(ssize_t) mng_info->magn_mt;\n\n                  else if (magn_methy > 1 && y == (ssize_t) image->rows-2)\n                    m=(ssize_t) mng_info->magn_mb;\n\n                  else if (magn_methy <= 1 && y == (ssize_t) image->rows-1)\n                    m=(ssize_t) mng_info->magn_mb;\n\n                  else if (magn_methy > 1 && y == (ssize_t) image->rows-1)\n                    m=1;\n\n                  else\n                    m=(ssize_t) mng_info->magn_my;\n\n                  n=prev;\n                  prev=next;\n                  next=n;\n\n                  if (y < (ssize_t) image->rows-1)\n                    {\n                      n=GetAuthenticPixels(image,0,y+1,image->columns,1,\n                          exception);\n                      (void) CopyMagickMemory(next,n,length);\n                    }\n\n                  for (i=0; i < m; i++, yy++)\n                  {\n                    register Quantum\n                      *pixels;\n\n                    assert(yy < (ssize_t) large_image->rows);\n                    pixels=prev;\n                    n=next;\n                    q=GetAuthenticPixels(large_image,0,yy,large_image->columns,\n                      1,exception);\n                    q+=(large_image->columns-image->columns)*\n                      GetPixelChannels(large_image);\n\n                    for (x=(ssize_t) image->columns-1; x >= 0; x--)\n                    {\n                      /* To do: get color as function of indexes[x] */\n                      /*\n                      if (image->storage_class == PseudoClass)\n                        {\n                        }\n                      */\n\n                      if (magn_methy <= 1)\n                        {\n                          /* replicate previous */\n                          SetPixelRed(large_image,GetPixelRed(image,pixels),q);\n                          SetPixelGreen(large_image,GetPixelGreen(image,\n                             pixels),q);\n                          SetPixelBlue(large_image,GetPixelBlue(image,\n                             pixels),q);\n                          SetPixelAlpha(large_image,GetPixelAlpha(image,\n                             pixels),q);\n                        }\n\n                      else if (magn_methy == 2 || magn_methy == 4)\n                        {\n                          if (i == 0)\n                            {\n                              SetPixelRed(large_image,GetPixelRed(image,\n                                 pixels),q);\n                              SetPixelGreen(large_image,GetPixelGreen(image,\n                                 pixels),q);\n                              SetPixelBlue(large_image,GetPixelBlue(image,\n                                 pixels),q);\n                              SetPixelAlpha(large_image,GetPixelAlpha(image,\n                                 pixels),q);\n                            }\n\n                          else\n                            {\n                              /* Interpolate */\n                              SetPixelRed(large_image,((QM) (((ssize_t)\n                                 (2*i*(GetPixelRed(image,n)\n                                 -GetPixelRed(image,pixels)+m))/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelRed(image,pixels)))),q);\n                              SetPixelGreen(large_image,((QM) (((ssize_t)\n                                 (2*i*(GetPixelGreen(image,n)\n                                 -GetPixelGreen(image,pixels)+m))/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelGreen(image,pixels)))),q);\n                              SetPixelBlue(large_image,((QM) (((ssize_t)\n                                 (2*i*(GetPixelBlue(image,n)\n                                 -GetPixelBlue(image,pixels)+m))/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelBlue(image,pixels)))),q);\n\n                              if (image->alpha_trait != UndefinedPixelTrait)\n                                 SetPixelAlpha(large_image, ((QM) (((ssize_t)\n                                    (2*i*(GetPixelAlpha(image,n)\n                                    -GetPixelAlpha(image,pixels)+m))\n                                    /((ssize_t) (m*2))+\n                                   GetPixelAlpha(image,pixels)))),q);\n                            }\n\n                          if (magn_methy == 4)\n                            {\n                              /* Replicate nearest */\n                              if (i <= ((m+1) << 1))\n                                 SetPixelAlpha(large_image,GetPixelAlpha(image,\n                                    pixels),q);\n                              else\n                                 SetPixelAlpha(large_image,GetPixelAlpha(image,\n                                    n),q);\n                            }\n                        }\n\n                      else /* if (magn_methy == 3 || magn_methy == 5) */\n                        {\n                          /* Replicate nearest */\n                          if (i <= ((m+1) << 1))\n                          {\n                             SetPixelRed(large_image,GetPixelRed(image,\n                                    pixels),q);\n                             SetPixelGreen(large_image,GetPixelGreen(image,\n                                    pixels),q);\n                             SetPixelBlue(large_image,GetPixelBlue(image,\n                                    pixels),q);\n                             SetPixelAlpha(large_image,GetPixelAlpha(image,\n                                    pixels),q);\n                          }\n\n                          else\n                          {\n                             SetPixelRed(large_image,GetPixelRed(image,n),q);\n                             SetPixelGreen(large_image,GetPixelGreen(image,n),\n                                    q);\n                             SetPixelBlue(large_image,GetPixelBlue(image,n),\n                                    q);\n                             SetPixelAlpha(large_image,GetPixelAlpha(image,n),\n                                    q);\n                          }\n\n                          if (magn_methy == 5)\n                            {\n                              SetPixelAlpha(large_image,(QM) (((ssize_t) (2*i*\n                                 (GetPixelAlpha(image,n)\n                                 -GetPixelAlpha(image,pixels))\n                                 +m))/((ssize_t) (m*2))\n                                 +GetPixelAlpha(image,pixels)),q);\n                            }\n                        }\n                      n+=GetPixelChannels(image);\n                      q+=GetPixelChannels(large_image);\n                      pixels+=GetPixelChannels(image);\n                    } /* x */\n\n                    if (SyncAuthenticPixels(large_image,exception) == 0)\n                      break;\n\n                  } /* i */\n                } /* y */\n\n                prev=(Quantum *) RelinquishMagickMemory(prev);\n                next=(Quantum *) RelinquishMagickMemory(next);\n\n                length=image->columns;\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Delete original image\");\n\n                DeleteImageFromList(&image);\n\n                image=large_image;\n\n                mng_info->image=image;\n\n                /* magnify the columns */\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Magnify the columns to %.20g\",\n                    (double) image->columns);\n\n                for (y=0; y < (ssize_t) image->rows; y++)\n                {\n                  register Quantum\n                    *pixels;\n\n                  q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n                  pixels=q+(image->columns-length)*GetPixelChannels(image);\n                  n=pixels+GetPixelChannels(image);\n\n                  for (x=(ssize_t) (image->columns-length);\n                    x < (ssize_t) image->columns; x++)\n                  {\n                    /* To do: Rewrite using Get/Set***PixelChannel() */\n\n                    if (x == (ssize_t) (image->columns-length))\n                      m=(ssize_t) mng_info->magn_ml;\n\n                    else if (magn_methx > 1 && x == (ssize_t) image->columns-2)\n                      m=(ssize_t) mng_info->magn_mr;\n\n                    else if (magn_methx <= 1 &&\n                        x == (ssize_t) image->columns-1)\n                      m=(ssize_t) mng_info->magn_mr;\n\n                    else if (magn_methx > 1 && x == (ssize_t) image->columns-1)\n                      m=1;\n\n                    else\n                      m=(ssize_t) mng_info->magn_mx;\n\n                    for (i=0; i < m; i++)\n                    {\n                      if (magn_methx <= 1)\n                        {\n                          /* replicate previous */\n                          SetPixelRed(image,GetPixelRed(image,pixels),q);\n                          SetPixelGreen(image,GetPixelGreen(image,pixels),q);\n                          SetPixelBlue(image,GetPixelBlue(image,pixels),q);\n                          SetPixelAlpha(image,GetPixelAlpha(image,pixels),q);\n                        }\n\n                      else if (magn_methx == 2 || magn_methx == 4)\n                        {\n                          if (i == 0)\n                          {\n                            SetPixelRed(image,GetPixelRed(image,pixels),q);\n                            SetPixelGreen(image,GetPixelGreen(image,pixels),q);\n                            SetPixelBlue(image,GetPixelBlue(image,pixels),q);\n                            SetPixelAlpha(image,GetPixelAlpha(image,pixels),q);\n                          }\n\n                          /* To do: Rewrite using Get/Set***PixelChannel() */\n                          else\n                            {\n                              /* Interpolate */\n                              SetPixelRed(image,(QM) ((2*i*(\n                                 GetPixelRed(image,n)\n                                 -GetPixelRed(image,pixels))+m)\n                                 /((ssize_t) (m*2))+\n                                 GetPixelRed(image,pixels)),q);\n\n                              SetPixelGreen(image,(QM) ((2*i*(\n                                 GetPixelGreen(image,n)\n                                 -GetPixelGreen(image,pixels))+m)\n                                 /((ssize_t) (m*2))+\n                                 GetPixelGreen(image,pixels)),q);\n\n                              SetPixelBlue(image,(QM) ((2*i*(\n                                 GetPixelBlue(image,n)\n                                 -GetPixelBlue(image,pixels))+m)\n                                 /((ssize_t) (m*2))+\n                                 GetPixelBlue(image,pixels)),q);\n                              if (image->alpha_trait != UndefinedPixelTrait)\n                                 SetPixelAlpha(image,(QM) ((2*i*(\n                                   GetPixelAlpha(image,n)\n                                   -GetPixelAlpha(image,pixels))+m)\n                                   /((ssize_t) (m*2))+\n                                   GetPixelAlpha(image,pixels)),q);\n                            }\n\n                          if (magn_methx == 4)\n                            {\n                              /* Replicate nearest */\n                              if (i <= ((m+1) << 1))\n                              {\n                                 SetPixelAlpha(image,\n                                   GetPixelAlpha(image,pixels)+0,q);\n                              }\n                              else\n                              {\n                                 SetPixelAlpha(image,\n                                   GetPixelAlpha(image,n)+0,q);\n                              }\n                            }\n                        }\n\n                      else /* if (magn_methx == 3 || magn_methx == 5) */\n                        {\n                          /* Replicate nearest */\n                          if (i <= ((m+1) << 1))\n                          {\n                             SetPixelRed(image,GetPixelRed(image,pixels),q);\n                             SetPixelGreen(image,GetPixelGreen(image,\n                                 pixels),q);\n                             SetPixelBlue(image,GetPixelBlue(image,pixels),q);\n                             SetPixelAlpha(image,GetPixelAlpha(image,\n                                 pixels),q);\n                          }\n\n                          else\n                          {\n                             SetPixelRed(image,GetPixelRed(image,n),q);\n                             SetPixelGreen(image,GetPixelGreen(image,n),q);\n                             SetPixelBlue(image,GetPixelBlue(image,n),q);\n                             SetPixelAlpha(image,GetPixelAlpha(image,n),q);\n                          }\n\n                          if (magn_methx == 5)\n                            {\n                              /* Interpolate */\n                              SetPixelAlpha(image,\n                                 (QM) ((2*i*( GetPixelAlpha(image,n)\n                                 -GetPixelAlpha(image,pixels))+m)/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelAlpha(image,pixels)),q);\n                            }\n                        }\n                      q+=GetPixelChannels(image);\n                    }\n                    n+=GetPixelChannels(image);\n                  }\n\n                  if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                    break;\n                }\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n              if (magn_methx != 1 || magn_methy != 1)\n                {\n                /*\n                   Rescale pixels to Quantum\n                */\n                   for (y=0; y < (ssize_t) image->rows; y++)\n                   {\n                     q=GetAuthenticPixels(image,0,y,image->columns,1,\n                       exception);\n\n                     for (x=(ssize_t) image->columns-1; x >= 0; x--)\n                     {\n                        SetPixelRed(image,ScaleShortToQuantum(\n                          GetPixelRed(image,q)),q);\n                        SetPixelGreen(image,ScaleShortToQuantum(\n                          GetPixelGreen(image,q)),q);\n                        SetPixelBlue(image,ScaleShortToQuantum(\n                          GetPixelBlue(image,q)),q);\n                        SetPixelAlpha(image,ScaleShortToQuantum(\n                          GetPixelAlpha(image,q)),q);\n                        q+=GetPixelChannels(image);\n                     }\n\n                     if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                       break;\n                   }\n                }\n#endif\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Finished MAGN processing\");\n              }\n          }\n\n        /*\n          Crop_box is with respect to the upper left corner of the MNG.\n        */\n        crop_box.left=mng_info->image_box.left+mng_info->x_off[object_id];\n        crop_box.right=mng_info->image_box.right+mng_info->x_off[object_id];\n        crop_box.top=mng_info->image_box.top+mng_info->y_off[object_id];\n        crop_box.bottom=mng_info->image_box.bottom+mng_info->y_off[object_id];\n        crop_box=mng_minimum_box(crop_box,mng_info->clip);\n        crop_box=mng_minimum_box(crop_box,mng_info->frame);\n        crop_box=mng_minimum_box(crop_box,mng_info->object_clip[object_id]);\n        if ((crop_box.left != (mng_info->image_box.left\n            +mng_info->x_off[object_id])) ||\n            (crop_box.right != (mng_info->image_box.right\n            +mng_info->x_off[object_id])) ||\n            (crop_box.top != (mng_info->image_box.top\n            +mng_info->y_off[object_id])) ||\n            (crop_box.bottom != (mng_info->image_box.bottom\n            +mng_info->y_off[object_id])))\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Crop the PNG image\");\n\n            if ((crop_box.left < crop_box.right) &&\n                (crop_box.top < crop_box.bottom))\n              {\n                Image\n                  *im;\n\n                RectangleInfo\n                  crop_info;\n\n                /*\n                  Crop_info is with respect to the upper left corner of\n                  the image.\n                */\n                crop_info.x=(crop_box.left-mng_info->x_off[object_id]);\n                crop_info.y=(crop_box.top-mng_info->y_off[object_id]);\n                crop_info.width=(size_t) (crop_box.right-crop_box.left);\n                crop_info.height=(size_t) (crop_box.bottom-crop_box.top);\n                image->page.width=image->columns;\n                image->page.height=image->rows;\n                image->page.x=0;\n                image->page.y=0;\n                im=CropImage(image,&crop_info,exception);\n\n                if (im != (Image *) NULL)\n                  {\n                    image->columns=im->columns;\n                    image->rows=im->rows;\n                    im=DestroyImage(im);\n                    image->page.width=image->columns;\n                    image->page.height=image->rows;\n                    image->page.x=crop_box.left;\n                    image->page.y=crop_box.top;\n                  }\n              }\n\n            else\n              {\n                /*\n                  No pixels in crop area.  The MNG spec still requires\n                  a layer, though, so make a single transparent pixel in\n                  the top left corner.\n                */\n                image->columns=1;\n                image->rows=1;\n                image->colors=2;\n                (void) SetImageBackgroundColor(image,exception);\n                image->page.width=1;\n                image->page.height=1;\n                image->page.x=0;\n                image->page.y=0;\n              }\n          }\n#ifndef PNG_READ_EMPTY_PLTE_SUPPORTED\n        image=mng_info->image;\n#endif\n      }\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n      /* PNG does not handle depths greater than 16 so reduce it even\n       * if lossy.\n       */\n      if (image->depth > 16)\n         image->depth=16;\n#endif\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 8)\n      if (image->depth > 8)\n        {\n          /* To do: fill low byte properly */\n          image->depth=16;\n        }\n\n      if (LosslessReduceDepthOK(image,exception) != MagickFalse)\n         image->depth = 8;\n#endif\n\n      if (image_info->number_scenes != 0)\n        {\n          if (mng_info->scenes_found >\n             (ssize_t) (image_info->first_scene+image_info->number_scenes))\n            break;\n        }\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Finished reading image datastream.\");\n\n  } while (LocaleCompare(image_info->magick,\"MNG\") == 0);\n\n  (void) CloseBlob(image);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Finished reading all image datastreams.\");\n\n#if defined(MNG_INSERT_LAYERS)\n  if (insert_layers && !mng_info->image_found && (mng_info->mng_width) &&\n       (mng_info->mng_height))\n    {\n      /*\n        Insert a background layer if nothing else was found.\n      */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  No images found.  Inserting a background layer.\");\n\n      if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n        {\n          /*\n            Allocate next image structure.\n          */\n          AcquireNextImage(image_info,image,exception);\n          if (GetNextImageInList(image) == (Image *) NULL)\n            {\n              if (logging != MagickFalse)\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Allocation failed, returning NULL.\");\n\n              return(DestroyImageList(image));;\n            }\n          image=SyncNextImageInList(image);\n        }\n      image->columns=mng_info->mng_width;\n      image->rows=mng_info->mng_height;\n      image->page.width=mng_info->mng_width;\n      image->page.height=mng_info->mng_height;\n      image->page.x=0;\n      image->page.y=0;\n      image->background_color=mng_background_color;\n      image->alpha_trait=UndefinedPixelTrait;\n\n      if (image_info->ping == MagickFalse)\n        (void) SetImageBackgroundColor(image,exception);\n\n      mng_info->image_found++;\n    }\n#endif\n  image->iterations=mng_iterations;\n\n  if (mng_iterations == 1)\n    image->start_loop=MagickTrue;\n\n  while (GetPreviousImageInList(image) != (Image *) NULL)\n  {\n    image_count++;\n    if (image_count > 10*mng_info->image_found)\n      {\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  No beginning\");\n\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CoderError,\"Linked list is corrupted, beginning of list not found\",\n          \"`%s'\",image_info->filename);\n\n        return(DestroyImageList(image));\n      }\n\n    image=GetPreviousImageInList(image);\n\n    if (GetNextImageInList(image) == (Image *) NULL)\n      {\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Corrupt list\");\n\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CoderError,\"Linked list is corrupted; next_image is NULL\",\"`%s'\",\n          image_info->filename);\n      }\n  }\n\n  if (mng_info->ticks_per_second && mng_info->image_found > 1 &&\n             GetNextImageInList(image) ==\n     (Image *) NULL)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  First image null\");\n\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        CoderError,\"image->next for first image is NULL but shouldn't be.\",\n        \"`%s'\",image_info->filename);\n    }\n\n  if (mng_info->image_found == 0)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  No visible images found.\");\n\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        CoderError,\"No visible images in file\",\"`%s'\",image_info->filename);\n\n      return(DestroyImageList(image));\n    }\n\n  if (mng_info->ticks_per_second)\n    final_delay=1UL*MagickMax(image->ticks_per_second,1L)*\n            final_delay/mng_info->ticks_per_second;\n\n  else\n    image->start_loop=MagickTrue;\n\n  /* Find final nonzero image delay */\n  final_image_delay=0;\n\n  while (GetNextImageInList(image) != (Image *) NULL)\n    {\n      if (image->delay)\n        final_image_delay=image->delay;\n\n      image=GetNextImageInList(image);\n    }\n\n  if (final_delay < final_image_delay)\n    final_delay=final_image_delay;\n\n  image->delay=final_delay;\n\n  if (logging != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  image->delay=%.20g, final_delay=%.20g\",(double) image->delay,\n        (double) final_delay);\n\n  if (logging != MagickFalse)\n    {\n      int\n        scene;\n\n      scene=0;\n      image=GetFirstImageInList(image);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Before coalesce:\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    scene 0 delay=%.20g\",(double) image->delay);\n\n      while (GetNextImageInList(image) != (Image *) NULL)\n      {\n        image=GetNextImageInList(image);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    scene %.20g delay=%.20g\",(double) scene++,\n          (double) image->delay);\n      }\n    }\n\n  image=GetFirstImageInList(image);\n#ifdef MNG_COALESCE_LAYERS\n  if (insert_layers)\n    {\n      Image\n        *next_image,\n        *next;\n\n      size_t\n        scene;\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Coalesce Images\");\n\n      scene=image->scene;\n      next_image=CoalesceImages(image,exception);\n\n      if (next_image == (Image *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n      image=DestroyImageList(image);\n      image=next_image;\n\n      for (next=image; next != (Image *) NULL; next=next_image)\n      {\n         next->page.width=mng_info->mng_width;\n         next->page.height=mng_info->mng_height;\n         next->page.x=0;\n         next->page.y=0;\n         next->scene=scene++;\n         next_image=GetNextImageInList(next);\n\n         if (next_image == (Image *) NULL)\n           break;\n\n         if (next->delay == 0)\n           {\n             scene--;\n             next_image->previous=GetPreviousImageInList(next);\n             if (GetPreviousImageInList(next) == (Image *) NULL)\n               image=next_image;\n             else\n               next->previous->next=next_image;\n             next=DestroyImage(next);\n           }\n      }\n    }\n#endif\n\n  while (GetNextImageInList(image) != (Image *) NULL)\n      image=GetNextImageInList(image);\n\n  image->dispose=BackgroundDispose;\n\n  if (logging != MagickFalse)\n    {\n      int\n        scene;\n\n      scene=0;\n      image=GetFirstImageInList(image);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  After coalesce:\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    scene 0 delay=%.20g dispose=%.20g\",(double) image->delay,\n        (double) image->dispose);\n\n      while (GetNextImageInList(image) != (Image *) NULL)\n      {\n        image=GetNextImageInList(image);\n\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    scene %.20g delay=%.20g dispose=%.20g\",(double) scene++,\n          (double) image->delay,(double) image->dispose);\n      }\n   }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit ReadOneMNGImage();\");\n\n  return(image);\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "png.c",
        "method_name": "fixed_function",
        "raw_code": "static Image *ReadOneMNGImage(MngInfo* mng_info, const ImageInfo *image_info,\n     ExceptionInfo *exception)\n{\n  char\n    page_geometry[MagickPathExtent];\n\n  Image\n    *image;\n\n  MagickBooleanType\n    logging;\n\n  volatile int\n    first_mng_object,\n    object_id,\n    term_chunk_found,\n    skip_to_iend;\n\n  volatile ssize_t\n    image_count=0;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  MngBox\n    default_fb,\n    fb,\n    previous_fb;\n\n#if defined(MNG_INSERT_LAYERS)\n  PixelInfo\n    mng_background_color;\n#endif\n\n  register unsigned char\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    count;\n\n  ssize_t\n    loop_level;\n\n  volatile short\n    skipping_loop;\n\n#if defined(MNG_INSERT_LAYERS)\n  unsigned int\n    mandatory_back=0;\n#endif\n\n  volatile unsigned int\n#ifdef MNG_OBJECT_BUFFERS\n    mng_background_object=0,\n#endif\n    mng_type=0;   /* 0: PNG or JNG; 1: MNG; 2: MNG-LC; 3: MNG-VLC */\n\n  size_t\n    default_frame_timeout,\n    frame_timeout,\n#if defined(MNG_INSERT_LAYERS)\n    image_height,\n    image_width,\n#endif\n    length;\n\n  /* These delays are all measured in image ticks_per_second,\n   * not in MNG ticks_per_second\n   */\n  volatile size_t\n    default_frame_delay,\n    final_delay,\n    final_image_delay,\n    frame_delay,\n#if defined(MNG_INSERT_LAYERS)\n    insert_layers,\n#endif\n    mng_iterations=1,\n    simplicity=0,\n    subframe_height=0,\n    subframe_width=0;\n\n  previous_fb.top=0;\n  previous_fb.bottom=0;\n  previous_fb.left=0;\n  previous_fb.right=0;\n  default_fb.top=0;\n  default_fb.bottom=0;\n  default_fb.left=0;\n  default_fb.right=0;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter ReadOneMNGImage()\");\n\n  image=mng_info->image;\n\n  if (LocaleCompare(image_info->magick,\"MNG\") == 0)\n    {\n      char\n        magic_number[MagickPathExtent];\n\n      /* Verify MNG signature.  */\n      count=(size_t) ReadBlob(image,8,(unsigned char *) magic_number);\n      if (memcmp(magic_number,\"\\212MNG\\r\\n\\032\\n\",8) != 0)\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n      /* Initialize some nonzero members of the MngInfo structure.  */\n      for (i=0; i < MNG_MAX_OBJECTS; i++)\n      {\n        mng_info->object_clip[i].right=(ssize_t) PNG_UINT_31_MAX;\n        mng_info->object_clip[i].bottom=(ssize_t) PNG_UINT_31_MAX;\n      }\n      mng_info->exists[0]=MagickTrue;\n    }\n\n  skipping_loop=(-1);\n  first_mng_object=MagickTrue;\n  mng_type=0;\n#if defined(MNG_INSERT_LAYERS)\n  insert_layers=MagickFalse; /* should be False during convert or mogrify */\n#endif\n  default_frame_delay=0;\n  default_frame_timeout=0;\n  frame_delay=0;\n  final_delay=1;\n  mng_info->ticks_per_second=1UL*image->ticks_per_second;\n  object_id=0;\n  skip_to_iend=MagickFalse;\n  term_chunk_found=MagickFalse;\n  mng_info->framing_mode=1;\n#if defined(MNG_INSERT_LAYERS)\n  mandatory_back=MagickFalse;\n#endif\n#if defined(MNG_INSERT_LAYERS)\n  mng_background_color=image->background_color;\n#endif\n  default_fb=mng_info->frame;\n  previous_fb=mng_info->frame;\n  do\n  {\n    char\n      type[MagickPathExtent];\n\n    if (LocaleCompare(image_info->magick,\"MNG\") == 0)\n      {\n        unsigned char\n          *chunk;\n\n        /*\n          Read a new chunk.\n        */\n        type[0]='\\0';\n        (void) ConcatenateMagickString(type,\"errr\",MagickPathExtent);\n        length=ReadBlobMSBLong(image);\n        count=(size_t) ReadBlob(image,4,(unsigned char *) type);\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"  Reading MNG chunk type %c%c%c%c, length: %.20g\",\n           type[0],type[1],type[2],type[3],(double) length);\n\n        if (length > PNG_UINT_31_MAX)\n          {\n            status=MagickFalse;\n            break;\n          }\n\n        if (count == 0)\n          ThrowReaderException(CorruptImageError,\"CorruptImage\");\n\n        p=NULL;\n        chunk=(unsigned char *) NULL;\n\n        if (length != 0)\n          {\n            if (length > GetBlobSize(image))\n              ThrowReaderException(CorruptImageError,\n                \"InsufficientImageDataInFile\");\n            chunk=(unsigned char *) AcquireQuantumMemory(length+\n             MagickPathExtent,sizeof(*chunk));\n\n            if (chunk == (unsigned char *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n            for (i=0; i < (ssize_t) length; i++)\n            {\n              int\n                c;\n\n              c=ReadBlobByte(image);\n              if (c == EOF)\n                break;\n              chunk[i]=(unsigned char) c;\n            }\n\n            p=chunk;\n          }\n\n        (void) ReadBlobMSBLong(image);  /* read crc word */\n\n#if !defined(JNG_SUPPORTED)\n        if (memcmp(type,mng_JHDR,4) == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info->jhdr_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"JNGCompressNotSupported\",\"`%s'\",image->filename);\n\n            mng_info->jhdr_warning++;\n          }\n#endif\n        if (memcmp(type,mng_DHDR,4) == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info->dhdr_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"DeltaPNGNotSupported\",\"`%s'\",image->filename);\n\n            mng_info->dhdr_warning++;\n          }\n        if (memcmp(type,mng_MEND,4) == 0)\n          break;\n\n        if (skip_to_iend)\n          {\n            if (memcmp(type,mng_IEND,4) == 0)\n              skip_to_iend=MagickFalse;\n\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Skip to IEND.\");\n\n            continue;\n          }\n\n        if (memcmp(type,mng_MHDR,4) == 0)\n          {\n            if (length != 28)\n              {\n                chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                ThrowReaderException(CorruptImageError,\"CorruptImage\");\n              }\n\n            mng_info->mng_width=(size_t) ((p[0] << 24) | (p[1] << 16) |\n                (p[2] << 8) | p[3]);\n\n            mng_info->mng_height=(size_t) ((p[4] << 24) | (p[5] << 16) |\n                (p[6] << 8) | p[7]);\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  MNG width: %.20g\",(double) mng_info->mng_width);\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  MNG height: %.20g\",(double) mng_info->mng_height);\n              }\n\n            p+=8;\n            mng_info->ticks_per_second=(size_t) mng_get_long(p);\n\n            if (mng_info->ticks_per_second == 0)\n              default_frame_delay=0;\n\n            else\n              default_frame_delay=1UL*image->ticks_per_second/\n                mng_info->ticks_per_second;\n\n            frame_delay=default_frame_delay;\n            simplicity=0;\n\n            p+=16;\n            simplicity=(size_t) mng_get_long(p);\n\n            mng_type=1;    /* Full MNG */\n\n            if ((simplicity != 0) && ((simplicity | 11) == 11))\n              mng_type=2; /* LC */\n\n            if ((simplicity != 0) && ((simplicity | 9) == 9))\n              mng_type=3; /* VLC */\n\n#if defined(MNG_INSERT_LAYERS)\n            if (mng_type != 3)\n              insert_layers=MagickTrue;\n#endif\n            if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n              {\n                /* Allocate next image structure.  */\n                AcquireNextImage(image_info,image,exception);\n\n                if (GetNextImageInList(image) == (Image *) NULL)\n                  return((Image *) NULL);\n\n                image=SyncNextImageInList(image);\n                mng_info->image=image;\n              }\n\n            if ((mng_info->mng_width > 65535L) ||\n                (mng_info->mng_height > 65535L))\n              {\n                chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                ThrowReaderException(ImageError,\"WidthOrHeightExceedsLimit\");\n              }\n\n            (void) FormatLocaleString(page_geometry,MagickPathExtent,\n              \"%.20gx%.20g+0+0\",(double) mng_info->mng_width,(double)\n              mng_info->mng_height);\n\n            mng_info->frame.left=0;\n            mng_info->frame.right=(ssize_t) mng_info->mng_width;\n            mng_info->frame.top=0;\n            mng_info->frame.bottom=(ssize_t) mng_info->mng_height;\n            mng_info->clip=default_fb=previous_fb=mng_info->frame;\n\n            for (i=0; i < MNG_MAX_OBJECTS; i++)\n              mng_info->object_clip[i]=mng_info->frame;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_TERM,4) == 0)\n          {\n            int\n              repeat=0;\n\n            if (length != 0)\n              repeat=p[0];\n\n            if (repeat == 3)\n              {\n                final_delay=(png_uint_32) mng_get_long(&p[2]);\n                mng_iterations=(png_uint_32) mng_get_long(&p[6]);\n\n                if (mng_iterations == PNG_UINT_31_MAX)\n                  mng_iterations=0;\n\n                image->iterations=mng_iterations;\n                term_chunk_found=MagickTrue;\n              }\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    repeat=%d,  final_delay=%.20g,  iterations=%.20g\",\n                  repeat,(double) final_delay, (double) image->iterations);\n              }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_DEFI,4) == 0)\n          {\n            if (mng_type == 3)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"DEFI chunk found in MNG-VLC datastream\",\"`%s'\",\n                image->filename);\n\n            if (length < 2)\n              {\n                if (chunk)\n                  chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                ThrowReaderException(CorruptImageError,\"CorruptImage\");\n              }\n\n            object_id=(p[0] << 8) | p[1];\n\n            if (mng_type == 2 && object_id != 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"Nonzero object_id in MNG-LC datastream\",\"`%s'\",\n                image->filename);\n\n            if (object_id > MNG_MAX_OBJECTS)\n              {\n                /*\n                  Instead of using a warning we should allocate a larger\n                  MngInfo structure and continue.\n                */\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  CoderError,\"object id too large\",\"`%s'\",image->filename);\n                object_id=MNG_MAX_OBJECTS;\n              }\n\n            if (mng_info->exists[object_id])\n              if (mng_info->frozen[object_id])\n                {\n                  chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                  (void) ThrowMagickException(exception,\n                    GetMagickModule(),CoderError,\n                    \"DEFI cannot redefine a frozen MNG object\",\"`%s'\",\n                    image->filename);\n                  continue;\n                }\n\n            mng_info->exists[object_id]=MagickTrue;\n\n            if (length > 2)\n              mng_info->invisible[object_id]=p[2];\n\n            /*\n              Extract object offset info.\n            */\n            if (length > 11)\n              {\n                mng_info->x_off[object_id]=(ssize_t) ((p[4] << 24) |\n                    (p[5] << 16) | (p[6] << 8) | p[7]);\n\n                mng_info->y_off[object_id]=(ssize_t) ((p[8] << 24) |\n                    (p[9] << 16) | (p[10] << 8) | p[11]);\n\n                if (logging != MagickFalse)\n                  {\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"  x_off[%d]: %.20g,  y_off[%d]: %.20g\",\n                      object_id,(double) mng_info->x_off[object_id],\n                      object_id,(double) mng_info->y_off[object_id]);\n                  }\n              }\n\n            /*\n              Extract object clipping info.\n            */\n            if (length > 27)\n              mng_info->object_clip[object_id]=mng_read_box(mng_info->frame,0,\n                &p[12]);\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_bKGD,4) == 0)\n          {\n            mng_info->have_global_bkgd=MagickFalse;\n\n            if (length > 5)\n              {\n                mng_info->mng_global_bkgd.red=\n                  ScaleShortToQuantum((unsigned short) ((p[0] << 8) | p[1]));\n\n                mng_info->mng_global_bkgd.green=\n                  ScaleShortToQuantum((unsigned short) ((p[2] << 8) | p[3]));\n\n                mng_info->mng_global_bkgd.blue=\n                  ScaleShortToQuantum((unsigned short) ((p[4] << 8) | p[5]));\n\n                mng_info->have_global_bkgd=MagickTrue;\n              }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_BACK,4) == 0)\n          {\n#if defined(MNG_INSERT_LAYERS)\n            if (length > 6)\n              mandatory_back=p[6];\n\n            else\n              mandatory_back=0;\n\n            if (mandatory_back && length > 5)\n              {\n                mng_background_color.red=\n                    ScaleShortToQuantum((unsigned short) ((p[0] << 8) | p[1]));\n\n                mng_background_color.green=\n                    ScaleShortToQuantum((unsigned short) ((p[2] << 8) | p[3]));\n\n                mng_background_color.blue=\n                    ScaleShortToQuantum((unsigned short) ((p[4] << 8) | p[5]));\n\n                mng_background_color.alpha=OpaqueAlpha;\n              }\n\n#ifdef MNG_OBJECT_BUFFERS\n            if (length > 8)\n              mng_background_object=(p[7] << 8) | p[8];\n#endif\n#endif\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_PLTE,4) == 0)\n          {\n            /* Read global PLTE.  */\n\n            if (length && (length < 769))\n              {\n                if (mng_info->global_plte == (png_colorp) NULL)\n                  mng_info->global_plte=(png_colorp) AcquireQuantumMemory(256,\n                    sizeof(*mng_info->global_plte));\n\n                for (i=0; i < (ssize_t) (length/3); i++)\n                {\n                  mng_info->global_plte[i].red=p[3*i];\n                  mng_info->global_plte[i].green=p[3*i+1];\n                  mng_info->global_plte[i].blue=p[3*i+2];\n                }\n\n                mng_info->global_plte_length=(unsigned int) (length/3);\n              }\n#ifdef MNG_LOOSE\n            for ( ; i < 256; i++)\n            {\n              mng_info->global_plte[i].red=i;\n              mng_info->global_plte[i].green=i;\n              mng_info->global_plte[i].blue=i;\n            }\n\n            if (length != 0)\n              mng_info->global_plte_length=256;\n#endif\n            else\n              mng_info->global_plte_length=0;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_tRNS,4) == 0)\n          {\n            /* read global tRNS */\n\n            if (length > 0 && length < 257)\n              for (i=0; i < (ssize_t) length; i++)\n                mng_info->global_trns[i]=p[i];\n\n#ifdef MNG_LOOSE\n            for ( ; i < 256; i++)\n              mng_info->global_trns[i]=255;\n#endif\n            mng_info->global_trns_length=(unsigned int) length;\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n        if (memcmp(type,mng_gAMA,4) == 0)\n          {\n            if (length == 4)\n              {\n                ssize_t\n                  igamma;\n\n                igamma=mng_get_long(p);\n                mng_info->global_gamma=((float) igamma)*0.00001;\n                mng_info->have_global_gama=MagickTrue;\n              }\n\n            else\n              mng_info->have_global_gama=MagickFalse;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_cHRM,4) == 0)\n          {\n            /* Read global cHRM */\n\n            if (length == 32)\n              {\n                mng_info->global_chrm.white_point.x=0.00001*mng_get_long(p);\n                mng_info->global_chrm.white_point.y=0.00001*mng_get_long(&p[4]);\n                mng_info->global_chrm.red_primary.x=0.00001*mng_get_long(&p[8]);\n                mng_info->global_chrm.red_primary.y=0.00001*\n                  mng_get_long(&p[12]);\n                mng_info->global_chrm.green_primary.x=0.00001*\n                  mng_get_long(&p[16]);\n                mng_info->global_chrm.green_primary.y=0.00001*\n                  mng_get_long(&p[20]);\n                mng_info->global_chrm.blue_primary.x=0.00001*\n                  mng_get_long(&p[24]);\n                mng_info->global_chrm.blue_primary.y=0.00001*\n                  mng_get_long(&p[28]);\n                mng_info->have_global_chrm=MagickTrue;\n              }\n            else\n              mng_info->have_global_chrm=MagickFalse;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_sRGB,4) == 0)\n          {\n            /*\n              Read global sRGB.\n            */\n            if (length != 0)\n              {\n                mng_info->global_srgb_intent=\n                  Magick_RenderingIntent_from_PNG_RenderingIntent(p[0]);\n                mng_info->have_global_srgb=MagickTrue;\n              }\n            else\n              mng_info->have_global_srgb=MagickFalse;\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_iCCP,4) == 0)\n          {\n            /* To do: */\n\n            /*\n              Read global iCCP.\n            */\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n\n        if (memcmp(type,mng_FRAM,4) == 0)\n          {\n            if (mng_type == 3)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"FRAM chunk found in MNG-VLC datastream\",\"`%s'\",\n                image->filename);\n\n            if ((mng_info->framing_mode == 2) || (mng_info->framing_mode == 4))\n              image->delay=frame_delay;\n\n            frame_delay=default_frame_delay;\n            frame_timeout=default_frame_timeout;\n            fb=default_fb;\n\n            if (length != 0)\n              if (p[0])\n                mng_info->framing_mode=p[0];\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Framing_mode=%d\",mng_info->framing_mode);\n\n            if (length > 6)\n              {\n                /* Note the delay and frame clipping boundaries.  */\n\n                p++; /* framing mode */\n\n                while (*p && ((p-chunk) < (ssize_t) length))\n                  p++;  /* frame name */\n\n                p++;  /* frame name terminator */\n\n                if ((p-chunk) < (ssize_t) (length-4))\n                  {\n                    int\n                      change_delay,\n                      change_timeout,\n                      change_clipping;\n\n                    change_delay=(*p++);\n                    change_timeout=(*p++);\n                    change_clipping=(*p++);\n                    p++; /* change_sync */\n\n                    if (change_delay)\n                      {\n                        frame_delay=1UL*image->ticks_per_second*\n                          mng_get_long(p);\n\n                        if (mng_info->ticks_per_second != 0)\n                          frame_delay/=mng_info->ticks_per_second;\n\n                        else\n                          frame_delay=PNG_UINT_31_MAX;\n\n                        if (change_delay == 2)\n                          default_frame_delay=frame_delay;\n\n                        p+=4;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"    Framing_delay=%.20g\",(double) frame_delay);\n                      }\n\n                    if (change_timeout)\n                      {\n                        frame_timeout=1UL*image->ticks_per_second*\n                          mng_get_long(p);\n\n                        if (mng_info->ticks_per_second != 0)\n                          frame_timeout/=mng_info->ticks_per_second;\n\n                        else\n                          frame_timeout=PNG_UINT_31_MAX;\n\n                        if (change_timeout == 2)\n                          default_frame_timeout=frame_timeout;\n\n                        p+=4;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"    Framing_timeout=%.20g\",(double) frame_timeout);\n                      }\n\n                    if (change_clipping)\n                      {\n                        fb=mng_read_box(previous_fb,(char) p[0],&p[1]);\n                        p+=17;\n                        previous_fb=fb;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                            \"    Frame_clip: L=%.20g R=%.20g T=%.20g B=%.20g\",\n                            (double) fb.left,(double) fb.right,(double) fb.top,\n                            (double) fb.bottom);\n\n                        if (change_clipping == 2)\n                          default_fb=fb;\n                      }\n                  }\n              }\n            mng_info->clip=fb;\n            mng_info->clip=mng_minimum_box(fb,mng_info->frame);\n\n            subframe_width=(size_t) (mng_info->clip.right\n               -mng_info->clip.left);\n\n            subframe_height=(size_t) (mng_info->clip.bottom\n               -mng_info->clip.top);\n            /*\n              Insert a background layer behind the frame if framing_mode is 4.\n            */\n#if defined(MNG_INSERT_LAYERS)\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"   subframe_width=%.20g, subframe_height=%.20g\",(double)\n                subframe_width,(double) subframe_height);\n\n            if (insert_layers && (mng_info->framing_mode == 4) &&\n                (subframe_width) && (subframe_height))\n              {\n                /* Allocate next image structure.  */\n                if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n                  {\n                    AcquireNextImage(image_info,image,exception);\n\n                    if (GetNextImageInList(image) == (Image *) NULL)\n                      return(DestroyImageList(image));\n\n                    image=SyncNextImageInList(image);\n                  }\n\n                mng_info->image=image;\n\n                if (term_chunk_found)\n                  {\n                    image->start_loop=MagickTrue;\n                    image->iterations=mng_iterations;\n                    term_chunk_found=MagickFalse;\n                  }\n\n                else\n                    image->start_loop=MagickFalse;\n\n                image->columns=subframe_width;\n                image->rows=subframe_height;\n                image->page.width=subframe_width;\n                image->page.height=subframe_height;\n                image->page.x=mng_info->clip.left;\n                image->page.y=mng_info->clip.top;\n                image->background_color=mng_background_color;\n                image->alpha_trait=UndefinedPixelTrait;\n                image->delay=0;\n                (void) SetImageBackgroundColor(image,exception);\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Insert backgd layer, L=%.20g, R=%.20g T=%.20g, B=%.20g\",\n                    (double) mng_info->clip.left,\n                    (double) mng_info->clip.right,\n                    (double) mng_info->clip.top,\n                    (double) mng_info->clip.bottom);\n              }\n#endif\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_CLIP,4) == 0)\n          {\n            unsigned int\n              first_object,\n              last_object;\n\n            /*\n              Read CLIP.\n            */\n            if (length > 3)\n              {\n                first_object=(p[0] << 8) | p[1];\n                last_object=(p[2] << 8) | p[3];\n                p+=4;\n\n                for (i=(int) first_object; i <= (int) last_object; i++)\n                {\n                  if ((i < 0) || (i >= MNG_MAX_OBJECTS))\n                    continue;\n\n                  if (mng_info->exists[i] && !mng_info->frozen[i])\n                    {\n                      MngBox\n                        box;\n\n                      box=mng_info->object_clip[i];\n                      if ((p-chunk) < (ssize_t) (length-17))\n                        mng_info->object_clip[i]=\n                           mng_read_box(box,(char) p[0],&p[1]);\n                    }\n                }\n\n              }\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_SAVE,4) == 0)\n          {\n            for (i=1; i < MNG_MAX_OBJECTS; i++)\n              if (mng_info->exists[i])\n                {\n                 mng_info->frozen[i]=MagickTrue;\n#ifdef MNG_OBJECT_BUFFERS\n                 if (mng_info->ob[i] != (MngBuffer *) NULL)\n                    mng_info->ob[i]->frozen=MagickTrue;\n#endif\n                }\n\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n\n        if ((memcmp(type,mng_DISC,4) == 0) || (memcmp(type,mng_SEEK,4) == 0))\n          {\n            /* Read DISC or SEEK.  */\n\n            if ((length == 0) || !memcmp(type,mng_SEEK,4))\n              {\n                for (i=1; i < MNG_MAX_OBJECTS; i++)\n                  MngInfoDiscardObject(mng_info,i);\n              }\n\n            else\n              {\n                register ssize_t\n                  j;\n\n                for (j=1; j < (ssize_t) length; j+=2)\n                {\n                  i=p[j-1] << 8 | p[j];\n                  MngInfoDiscardObject(mng_info,i);\n                }\n              }\n\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n\n        if (memcmp(type,mng_MOVE,4) == 0)\n          {\n            size_t\n              first_object,\n              last_object;\n\n            /* read MOVE */\n\n            if (length > 3)\n            {\n              first_object=(p[0] << 8) | p[1];\n              last_object=(p[2] << 8) | p[3];\n              p+=4;\n\n              for (i=(ssize_t) first_object; i <= (ssize_t) last_object; i++)\n              {\n                if ((i < 0) || (i >= MNG_MAX_OBJECTS))\n                  continue;\n\n                if (mng_info->exists[i] && !mng_info->frozen[i] &&\n                    (p-chunk) < (ssize_t) (length-8))\n                  {\n                    MngPair\n                      new_pair;\n\n                    MngPair\n                      old_pair;\n\n                    old_pair.a=mng_info->x_off[i];\n                    old_pair.b=mng_info->y_off[i];\n                    new_pair=mng_read_pair(old_pair,(int) p[0],&p[1]);\n                    mng_info->x_off[i]=new_pair.a;\n                    mng_info->y_off[i]=new_pair.b;\n                  }\n              }\n            }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_LOOP,4) == 0)\n          {\n            ssize_t loop_iters=1;\n            if (length > 4)\n              {\n                loop_level=chunk[0];\n                mng_info->loop_active[loop_level]=1;  /* mark loop active */\n\n                /* Record starting point.  */\n                loop_iters=mng_get_long(&chunk[1]);\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  LOOP level %.20g has %.20g iterations \",\n                    (double) loop_level, (double) loop_iters);\n\n                if (loop_iters == 0)\n                  skipping_loop=loop_level;\n\n                else\n                  {\n                    mng_info->loop_jump[loop_level]=TellBlob(image);\n                    mng_info->loop_count[loop_level]=loop_iters;\n                  }\n\n                mng_info->loop_iteration[loop_level]=0;\n              }\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_ENDL,4) == 0)\n          {\n            if (length > 0)\n              {\n                loop_level=chunk[0];\n\n                if (skipping_loop > 0)\n                  {\n                    if (skipping_loop == loop_level)\n                      {\n                        /*\n                          Found end of zero-iteration loop.\n                        */\n                        skipping_loop=(-1);\n                        mng_info->loop_active[loop_level]=0;\n                      }\n                  }\n\n                else\n                  {\n                    if (mng_info->loop_active[loop_level] == 1)\n                      {\n                        mng_info->loop_count[loop_level]--;\n                        mng_info->loop_iteration[loop_level]++;\n\n                        if (logging != MagickFalse)\n                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  ENDL: LOOP level %.20g has %.20g remaining iters\",\n                            (double) loop_level,(double)\n                            mng_info->loop_count[loop_level]);\n\n                        if (mng_info->loop_count[loop_level] != 0)\n                          {\n                            offset=\n                              SeekBlob(image,mng_info->loop_jump[loop_level],\n                              SEEK_SET);\n\n                            if (offset < 0)\n                              {\n                                chunk=(unsigned char *) RelinquishMagickMemory(\n                                  chunk);\n                                ThrowReaderException(CorruptImageError,\n                                  \"ImproperImageHeader\");\n                              }\n                          }\n\n                        else\n                          {\n                            short\n                              last_level;\n\n                            /*\n                              Finished loop.\n                            */\n                            mng_info->loop_active[loop_level]=0;\n                            last_level=(-1);\n                            for (i=0; i < loop_level; i++)\n                              if (mng_info->loop_active[i] == 1)\n                                last_level=(short) i;\n                            loop_level=last_level;\n                          }\n                      }\n                  }\n              }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_CLON,4) == 0)\n          {\n            if (mng_info->clon_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"CLON is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->clon_warning++;\n          }\n\n        if (memcmp(type,mng_MAGN,4) == 0)\n          {\n            png_uint_16\n              magn_first,\n              magn_last,\n              magn_mb,\n              magn_ml,\n              magn_mr,\n              magn_mt,\n              magn_mx,\n              magn_my,\n              magn_methx,\n              magn_methy;\n\n            if (length > 1)\n              magn_first=(p[0] << 8) | p[1];\n\n            else\n              magn_first=0;\n\n            if (length > 3)\n              magn_last=(p[2] << 8) | p[3];\n\n            else\n              magn_last=magn_first;\n#ifndef MNG_OBJECT_BUFFERS\n            if (magn_first || magn_last)\n              if (mng_info->magn_warning == 0)\n                {\n                  (void) ThrowMagickException(exception,\n                     GetMagickModule(),CoderError,\n                     \"MAGN is not implemented yet for nonzero objects\",\n                     \"`%s'\",image->filename);\n\n                   mng_info->magn_warning++;\n                }\n#endif\n            if (length > 4)\n              magn_methx=p[4];\n\n            else\n              magn_methx=0;\n\n            if (length > 6)\n              magn_mx=(p[5] << 8) | p[6];\n\n            else\n              magn_mx=1;\n\n            if (magn_mx == 0)\n              magn_mx=1;\n\n            if (length > 8)\n              magn_my=(p[7] << 8) | p[8];\n\n            else\n              magn_my=magn_mx;\n\n            if (magn_my == 0)\n              magn_my=1;\n\n            if (length > 10)\n              magn_ml=(p[9] << 8) | p[10];\n\n            else\n              magn_ml=magn_mx;\n\n            if (magn_ml == 0)\n              magn_ml=1;\n\n            if (length > 12)\n              magn_mr=(p[11] << 8) | p[12];\n\n            else\n              magn_mr=magn_mx;\n\n            if (magn_mr == 0)\n              magn_mr=1;\n\n            if (length > 14)\n              magn_mt=(p[13] << 8) | p[14];\n\n            else\n              magn_mt=magn_my;\n\n            if (magn_mt == 0)\n              magn_mt=1;\n\n            if (length > 16)\n              magn_mb=(p[15] << 8) | p[16];\n\n            else\n              magn_mb=magn_my;\n\n            if (magn_mb == 0)\n              magn_mb=1;\n\n            if (length > 17)\n              magn_methy=p[17];\n\n            else\n              magn_methy=magn_methx;\n\n\n            if (magn_methx > 5 || magn_methy > 5)\n              if (mng_info->magn_warning == 0)\n                {\n                  (void) ThrowMagickException(exception,\n                     GetMagickModule(),CoderError,\n                     \"Unknown MAGN method in MNG datastream\",\"`%s'\",\n                     image->filename);\n\n                   mng_info->magn_warning++;\n                }\n#ifdef MNG_OBJECT_BUFFERS\n          /* Magnify existing objects in the range magn_first to magn_last */\n#endif\n            if (magn_first == 0 || magn_last == 0)\n              {\n                /* Save the magnification factors for object 0 */\n                mng_info->magn_mb=magn_mb;\n                mng_info->magn_ml=magn_ml;\n                mng_info->magn_mr=magn_mr;\n                mng_info->magn_mt=magn_mt;\n                mng_info->magn_mx=magn_mx;\n                mng_info->magn_my=magn_my;\n                mng_info->magn_methx=magn_methx;\n                mng_info->magn_methy=magn_methy;\n              }\n          }\n\n        if (memcmp(type,mng_PAST,4) == 0)\n          {\n            if (mng_info->past_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"PAST is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->past_warning++;\n          }\n\n        if (memcmp(type,mng_SHOW,4) == 0)\n          {\n            if (mng_info->show_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"SHOW is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->show_warning++;\n          }\n\n        if (memcmp(type,mng_sBIT,4) == 0)\n          {\n            if (length < 4)\n              mng_info->have_global_sbit=MagickFalse;\n\n            else\n              {\n                mng_info->global_sbit.gray=p[0];\n                mng_info->global_sbit.red=p[0];\n                mng_info->global_sbit.green=p[1];\n                mng_info->global_sbit.blue=p[2];\n                mng_info->global_sbit.alpha=p[3];\n                mng_info->have_global_sbit=MagickTrue;\n             }\n          }\n        if (memcmp(type,mng_pHYs,4) == 0)\n          {\n            if (length > 8)\n              {\n                mng_info->global_x_pixels_per_unit=\n                    (size_t) mng_get_long(p);\n                mng_info->global_y_pixels_per_unit=\n                    (size_t) mng_get_long(&p[4]);\n                mng_info->global_phys_unit_type=p[8];\n                mng_info->have_global_phys=MagickTrue;\n              }\n\n            else\n              mng_info->have_global_phys=MagickFalse;\n          }\n        if (memcmp(type,mng_pHYg,4) == 0)\n          {\n            if (mng_info->phyg_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"pHYg is not implemented.\",\"`%s'\",image->filename);\n\n            mng_info->phyg_warning++;\n          }\n        if (memcmp(type,mng_BASI,4) == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info->basi_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"BASI is not implemented yet\",\"`%s'\",\n                image->filename);\n\n            mng_info->basi_warning++;\n#ifdef MNG_BASI_SUPPORTED\n            basi_width=(size_t) ((p[0] << 24) | (p[1] << 16) |\n               (p[2] << 8) | p[3]);\n            basi_height=(size_t) ((p[4] << 24) | (p[5] << 16) |\n               (p[6] << 8) | p[7]);\n            basi_color_type=p[8];\n            basi_compression_method=p[9];\n            basi_filter_type=p[10];\n            basi_interlace_method=p[11];\n            if (length > 11)\n              basi_red=(p[12] << 8) & p[13];\n\n            else\n              basi_red=0;\n\n            if (length > 13)\n              basi_green=(p[14] << 8) & p[15];\n\n            else\n              basi_green=0;\n\n            if (length > 15)\n              basi_blue=(p[16] << 8) & p[17];\n\n            else\n              basi_blue=0;\n\n            if (length > 17)\n              basi_alpha=(p[18] << 8) & p[19];\n\n            else\n              {\n                if (basi_sample_depth == 16)\n                  basi_alpha=65535L;\n                else\n                  basi_alpha=255;\n              }\n\n            if (length > 19)\n              basi_viewable=p[20];\n\n            else\n              basi_viewable=0;\n\n#endif\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n        if (memcmp(type,mng_IHDR,4)\n#if defined(JNG_SUPPORTED)\n            && memcmp(type,mng_JHDR,4)\n#endif\n            )\n          {\n            /* Not an IHDR or JHDR chunk */\n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n/* Process IHDR */\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Processing %c%c%c%c chunk\",type[0],type[1],type[2],type[3]);\n\n        mng_info->exists[object_id]=MagickTrue;\n        mng_info->viewable[object_id]=MagickTrue;\n\n        if (mng_info->invisible[object_id])\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Skipping invisible object\");\n\n            skip_to_iend=MagickTrue;\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n#if defined(MNG_INSERT_LAYERS)\n        if (length < 8)\n          {\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          }\n\n        image_width=(size_t) mng_get_long(p);\n        image_height=(size_t) mng_get_long(&p[4]);\n#endif\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        /*\n          Insert a transparent background layer behind the entire animation\n          if it is not full screen.\n        */\n#if defined(MNG_INSERT_LAYERS)\n        if (insert_layers && mng_type && first_mng_object)\n          {\n            if ((mng_info->clip.left > 0) || (mng_info->clip.top > 0) ||\n                (image_width < mng_info->mng_width) ||\n                (mng_info->clip.right < (ssize_t) mng_info->mng_width) ||\n                (image_height < mng_info->mng_height) ||\n                (mng_info->clip.bottom < (ssize_t) mng_info->mng_height))\n              {\n                if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n                  {\n                    /*\n                      Allocate next image structure.\n                    */\n                    AcquireNextImage(image_info,image,exception);\n\n                    if (GetNextImageInList(image) == (Image *) NULL)\n                      return(DestroyImageList(image));\n\n                    image=SyncNextImageInList(image);\n                  }\n                mng_info->image=image;\n\n                if (term_chunk_found)\n                  {\n                    image->start_loop=MagickTrue;\n                    image->iterations=mng_iterations;\n                    term_chunk_found=MagickFalse;\n                  }\n\n                else\n                    image->start_loop=MagickFalse;\n\n                /* Make a background rectangle.  */\n\n                image->delay=0;\n                image->columns=mng_info->mng_width;\n                image->rows=mng_info->mng_height;\n                image->page.width=mng_info->mng_width;\n                image->page.height=mng_info->mng_height;\n                image->page.x=0;\n                image->page.y=0;\n                image->background_color=mng_background_color;\n                (void) SetImageBackgroundColor(image,exception);\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Inserted transparent background layer, W=%.20g, H=%.20g\",\n                    (double) mng_info->mng_width,(double) mng_info->mng_height);\n              }\n          }\n        /*\n          Insert a background layer behind the upcoming image if\n          framing_mode is 3, and we haven't already inserted one.\n        */\n        if (insert_layers && (mng_info->framing_mode == 3) &&\n                (subframe_width) && (subframe_height) && (simplicity == 0 ||\n                (simplicity & 0x08)))\n          {\n            if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n            {\n              /*\n                Allocate next image structure.\n              */\n              AcquireNextImage(image_info,image,exception);\n\n              if (GetNextImageInList(image) == (Image *) NULL)\n                return(DestroyImageList(image));\n\n              image=SyncNextImageInList(image);\n            }\n\n            mng_info->image=image;\n\n            if (term_chunk_found)\n              {\n                image->start_loop=MagickTrue;\n                image->iterations=mng_iterations;\n                term_chunk_found=MagickFalse;\n              }\n\n            else\n                image->start_loop=MagickFalse;\n\n            image->delay=0;\n            image->columns=subframe_width;\n            image->rows=subframe_height;\n            image->page.width=subframe_width;\n            image->page.height=subframe_height;\n            image->page.x=mng_info->clip.left;\n            image->page.y=mng_info->clip.top;\n            image->background_color=mng_background_color;\n            image->alpha_trait=UndefinedPixelTrait;\n            (void) SetImageBackgroundColor(image,exception);\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Insert background layer, L=%.20g, R=%.20g T=%.20g, B=%.20g\",\n                (double) mng_info->clip.left,(double) mng_info->clip.right,\n                (double) mng_info->clip.top,(double) mng_info->clip.bottom);\n          }\n#endif /* MNG_INSERT_LAYERS */\n        first_mng_object=MagickFalse;\n\n        if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n          {\n            /*\n              Allocate next image structure.\n            */\n            AcquireNextImage(image_info,image,exception);\n\n            if (GetNextImageInList(image) == (Image *) NULL)\n              return(DestroyImageList(image));\n\n            image=SyncNextImageInList(image);\n          }\n        mng_info->image=image;\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n\n        if (status == MagickFalse)\n          break;\n\n        if (term_chunk_found)\n          {\n            image->start_loop=MagickTrue;\n            term_chunk_found=MagickFalse;\n          }\n\n        else\n            image->start_loop=MagickFalse;\n\n        if (mng_info->framing_mode == 1 || mng_info->framing_mode == 3)\n          {\n            image->delay=frame_delay;\n            frame_delay=default_frame_delay;\n          }\n\n        else\n          image->delay=0;\n\n        image->page.width=mng_info->mng_width;\n        image->page.height=mng_info->mng_height;\n        image->page.x=mng_info->x_off[object_id];\n        image->page.y=mng_info->y_off[object_id];\n        image->iterations=mng_iterations;\n\n        /*\n          Seek back to the beginning of the IHDR or JHDR chunk's length field.\n        */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Seeking back to beginning of %c%c%c%c chunk\",type[0],type[1],\n            type[2],type[3]);\n\n        offset=SeekBlob(image,-((ssize_t) length+12),SEEK_CUR);\n\n        if (offset < 0)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n\n    mng_info->image=image;\n    mng_info->mng_type=mng_type;\n    mng_info->object_id=object_id;\n\n    if (memcmp(type,mng_IHDR,4) == 0)\n      image=ReadOnePNGImage(mng_info,image_info,exception);\n\n#if defined(JNG_SUPPORTED)\n    else\n      image=ReadOneJNGImage(mng_info,image_info,exception);\n#endif\n\n    if (image == (Image *) NULL)\n      {\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"exit ReadJNGImage() with error\");\n\n        return((Image *) NULL);\n      }\n\n    if (image->columns == 0 || image->rows == 0)\n      {\n        (void) CloseBlob(image);\n        return(DestroyImageList(image));\n      }\n\n    mng_info->image=image;\n\n    if (mng_type)\n      {\n        MngBox\n          crop_box;\n\n        if (mng_info->magn_methx || mng_info->magn_methy)\n          {\n            png_uint_32\n               magnified_height,\n               magnified_width;\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Processing MNG MAGN chunk\");\n\n            if (mng_info->magn_methx == 1)\n              {\n                magnified_width=mng_info->magn_ml;\n\n                if (image->columns > 1)\n                   magnified_width += mng_info->magn_mr;\n\n                if (image->columns > 2)\n                   magnified_width += (png_uint_32)\n                      ((image->columns-2)*(mng_info->magn_mx));\n              }\n\n            else\n              {\n                magnified_width=(png_uint_32) image->columns;\n\n                if (image->columns > 1)\n                   magnified_width += mng_info->magn_ml-1;\n\n                if (image->columns > 2)\n                   magnified_width += mng_info->magn_mr-1;\n\n                if (image->columns > 3)\n                   magnified_width += (png_uint_32)\n                      ((image->columns-3)*(mng_info->magn_mx-1));\n              }\n\n            if (mng_info->magn_methy == 1)\n              {\n                magnified_height=mng_info->magn_mt;\n\n                if (image->rows > 1)\n                   magnified_height += mng_info->magn_mb;\n\n                if (image->rows > 2)\n                   magnified_height += (png_uint_32)\n                      ((image->rows-2)*(mng_info->magn_my));\n              }\n\n            else\n              {\n                magnified_height=(png_uint_32) image->rows;\n\n                if (image->rows > 1)\n                   magnified_height += mng_info->magn_mt-1;\n\n                if (image->rows > 2)\n                   magnified_height += mng_info->magn_mb-1;\n\n                if (image->rows > 3)\n                   magnified_height += (png_uint_32)\n                      ((image->rows-3)*(mng_info->magn_my-1));\n              }\n\n            if (magnified_height > image->rows ||\n                magnified_width > image->columns)\n              {\n                Image\n                  *large_image;\n\n                int\n                  yy;\n\n                Quantum\n                  *next,\n                  *prev;\n\n                png_uint_16\n                  magn_methx,\n                  magn_methy;\n\n                ssize_t\n                  m,\n                  y;\n\n                register Quantum\n                  *n,\n                  *q;\n\n                register ssize_t\n                  x;\n\n                /* Allocate next image structure.  */\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Allocate magnified image\");\n\n                AcquireNextImage(image_info,image,exception);\n\n                if (GetNextImageInList(image) == (Image *) NULL)\n                  return(DestroyImageList(image));\n\n                large_image=SyncNextImageInList(image);\n\n                large_image->columns=magnified_width;\n                large_image->rows=magnified_height;\n\n                magn_methx=mng_info->magn_methx;\n                magn_methy=mng_info->magn_methy;\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n#define QM unsigned short\n                if (magn_methx != 1 || magn_methy != 1)\n                  {\n                  /*\n                     Scale pixels to unsigned shorts to prevent\n                     overflow of intermediate values of interpolations\n                  */\n                     for (y=0; y < (ssize_t) image->rows; y++)\n                     {\n                       q=GetAuthenticPixels(image,0,y,image->columns,1,\n                          exception);\n\n                       for (x=(ssize_t) image->columns-1; x >= 0; x--)\n                       {\n                          SetPixelRed(image,ScaleQuantumToShort(\n                            GetPixelRed(image,q)),q);\n                          SetPixelGreen(image,ScaleQuantumToShort(\n                            GetPixelGreen(image,q)),q);\n                          SetPixelBlue(image,ScaleQuantumToShort(\n                            GetPixelBlue(image,q)),q);\n                          SetPixelAlpha(image,ScaleQuantumToShort(\n                            GetPixelAlpha(image,q)),q);\n                          q+=GetPixelChannels(image);\n                       }\n\n                       if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                         break;\n                     }\n                  }\n#else\n#define QM Quantum\n#endif\n\n                if (image->alpha_trait != UndefinedPixelTrait)\n                   (void) SetImageBackgroundColor(large_image,exception);\n\n                else\n                  {\n                    large_image->background_color.alpha=OpaqueAlpha;\n                    (void) SetImageBackgroundColor(large_image,exception);\n\n                    if (magn_methx == 4)\n                      magn_methx=2;\n\n                    if (magn_methx == 5)\n                      magn_methx=3;\n\n                    if (magn_methy == 4)\n                      magn_methy=2;\n\n                    if (magn_methy == 5)\n                      magn_methy=3;\n                  }\n\n                /* magnify the rows into the right side of the large image */\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Magnify the rows to %.20g\",\n                    (double) large_image->rows);\n                m=(ssize_t) mng_info->magn_mt;\n                yy=0;\n                length=(size_t) GetPixelChannels(image)*image->columns;\n                next=(Quantum *) AcquireQuantumMemory(length,sizeof(*next));\n                prev=(Quantum *) AcquireQuantumMemory(length,sizeof(*prev));\n\n                if ((prev == (Quantum *) NULL) ||\n                    (next == (Quantum *) NULL))\n                  {\n                     image=DestroyImageList(image);\n                     ThrowReaderException(ResourceLimitError,\n                       \"MemoryAllocationFailed\");\n                  }\n\n                n=GetAuthenticPixels(image,0,0,image->columns,1,exception);\n                (void) CopyMagickMemory(next,n,length);\n\n                for (y=0; y < (ssize_t) image->rows; y++)\n                {\n                  if (y == 0)\n                    m=(ssize_t) mng_info->magn_mt;\n\n                  else if (magn_methy > 1 && y == (ssize_t) image->rows-2)\n                    m=(ssize_t) mng_info->magn_mb;\n\n                  else if (magn_methy <= 1 && y == (ssize_t) image->rows-1)\n                    m=(ssize_t) mng_info->magn_mb;\n\n                  else if (magn_methy > 1 && y == (ssize_t) image->rows-1)\n                    m=1;\n\n                  else\n                    m=(ssize_t) mng_info->magn_my;\n\n                  n=prev;\n                  prev=next;\n                  next=n;\n\n                  if (y < (ssize_t) image->rows-1)\n                    {\n                      n=GetAuthenticPixels(image,0,y+1,image->columns,1,\n                          exception);\n                      (void) CopyMagickMemory(next,n,length);\n                    }\n\n                  for (i=0; i < m; i++, yy++)\n                  {\n                    register Quantum\n                      *pixels;\n\n                    assert(yy < (ssize_t) large_image->rows);\n                    pixels=prev;\n                    n=next;\n                    q=GetAuthenticPixels(large_image,0,yy,large_image->columns,\n                      1,exception);\n                    q+=(large_image->columns-image->columns)*\n                      GetPixelChannels(large_image);\n\n                    for (x=(ssize_t) image->columns-1; x >= 0; x--)\n                    {\n                      /* To do: get color as function of indexes[x] */\n                      /*\n                      if (image->storage_class == PseudoClass)\n                        {\n                        }\n                      */\n\n                      if (magn_methy <= 1)\n                        {\n                          /* replicate previous */\n                          SetPixelRed(large_image,GetPixelRed(image,pixels),q);\n                          SetPixelGreen(large_image,GetPixelGreen(image,\n                             pixels),q);\n                          SetPixelBlue(large_image,GetPixelBlue(image,\n                             pixels),q);\n                          SetPixelAlpha(large_image,GetPixelAlpha(image,\n                             pixels),q);\n                        }\n\n                      else if (magn_methy == 2 || magn_methy == 4)\n                        {\n                          if (i == 0)\n                            {\n                              SetPixelRed(large_image,GetPixelRed(image,\n                                 pixels),q);\n                              SetPixelGreen(large_image,GetPixelGreen(image,\n                                 pixels),q);\n                              SetPixelBlue(large_image,GetPixelBlue(image,\n                                 pixels),q);\n                              SetPixelAlpha(large_image,GetPixelAlpha(image,\n                                 pixels),q);\n                            }\n\n                          else\n                            {\n                              /* Interpolate */\n                              SetPixelRed(large_image,((QM) (((ssize_t)\n                                 (2*i*(GetPixelRed(image,n)\n                                 -GetPixelRed(image,pixels)+m))/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelRed(image,pixels)))),q);\n                              SetPixelGreen(large_image,((QM) (((ssize_t)\n                                 (2*i*(GetPixelGreen(image,n)\n                                 -GetPixelGreen(image,pixels)+m))/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelGreen(image,pixels)))),q);\n                              SetPixelBlue(large_image,((QM) (((ssize_t)\n                                 (2*i*(GetPixelBlue(image,n)\n                                 -GetPixelBlue(image,pixels)+m))/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelBlue(image,pixels)))),q);\n\n                              if (image->alpha_trait != UndefinedPixelTrait)\n                                 SetPixelAlpha(large_image, ((QM) (((ssize_t)\n                                    (2*i*(GetPixelAlpha(image,n)\n                                    -GetPixelAlpha(image,pixels)+m))\n                                    /((ssize_t) (m*2))+\n                                   GetPixelAlpha(image,pixels)))),q);\n                            }\n\n                          if (magn_methy == 4)\n                            {\n                              /* Replicate nearest */\n                              if (i <= ((m+1) << 1))\n                                 SetPixelAlpha(large_image,GetPixelAlpha(image,\n                                    pixels),q);\n                              else\n                                 SetPixelAlpha(large_image,GetPixelAlpha(image,\n                                    n),q);\n                            }\n                        }\n\n                      else /* if (magn_methy == 3 || magn_methy == 5) */\n                        {\n                          /* Replicate nearest */\n                          if (i <= ((m+1) << 1))\n                          {\n                             SetPixelRed(large_image,GetPixelRed(image,\n                                    pixels),q);\n                             SetPixelGreen(large_image,GetPixelGreen(image,\n                                    pixels),q);\n                             SetPixelBlue(large_image,GetPixelBlue(image,\n                                    pixels),q);\n                             SetPixelAlpha(large_image,GetPixelAlpha(image,\n                                    pixels),q);\n                          }\n\n                          else\n                          {\n                             SetPixelRed(large_image,GetPixelRed(image,n),q);\n                             SetPixelGreen(large_image,GetPixelGreen(image,n),\n                                    q);\n                             SetPixelBlue(large_image,GetPixelBlue(image,n),\n                                    q);\n                             SetPixelAlpha(large_image,GetPixelAlpha(image,n),\n                                    q);\n                          }\n\n                          if (magn_methy == 5)\n                            {\n                              SetPixelAlpha(large_image,(QM) (((ssize_t) (2*i*\n                                 (GetPixelAlpha(image,n)\n                                 -GetPixelAlpha(image,pixels))\n                                 +m))/((ssize_t) (m*2))\n                                 +GetPixelAlpha(image,pixels)),q);\n                            }\n                        }\n                      n+=GetPixelChannels(image);\n                      q+=GetPixelChannels(large_image);\n                      pixels+=GetPixelChannels(image);\n                    } /* x */\n\n                    if (SyncAuthenticPixels(large_image,exception) == 0)\n                      break;\n\n                  } /* i */\n                } /* y */\n\n                prev=(Quantum *) RelinquishMagickMemory(prev);\n                next=(Quantum *) RelinquishMagickMemory(next);\n\n                length=image->columns;\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Delete original image\");\n\n                DeleteImageFromList(&image);\n\n                image=large_image;\n\n                mng_info->image=image;\n\n                /* magnify the columns */\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Magnify the columns to %.20g\",\n                    (double) image->columns);\n\n                for (y=0; y < (ssize_t) image->rows; y++)\n                {\n                  register Quantum\n                    *pixels;\n\n                  q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n                  pixels=q+(image->columns-length)*GetPixelChannels(image);\n                  n=pixels+GetPixelChannels(image);\n\n                  for (x=(ssize_t) (image->columns-length);\n                    x < (ssize_t) image->columns; x++)\n                  {\n                    /* To do: Rewrite using Get/Set***PixelChannel() */\n\n                    if (x == (ssize_t) (image->columns-length))\n                      m=(ssize_t) mng_info->magn_ml;\n\n                    else if (magn_methx > 1 && x == (ssize_t) image->columns-2)\n                      m=(ssize_t) mng_info->magn_mr;\n\n                    else if (magn_methx <= 1 &&\n                        x == (ssize_t) image->columns-1)\n                      m=(ssize_t) mng_info->magn_mr;\n\n                    else if (magn_methx > 1 && x == (ssize_t) image->columns-1)\n                      m=1;\n\n                    else\n                      m=(ssize_t) mng_info->magn_mx;\n\n                    for (i=0; i < m; i++)\n                    {\n                      if (magn_methx <= 1)\n                        {\n                          /* replicate previous */\n                          SetPixelRed(image,GetPixelRed(image,pixels),q);\n                          SetPixelGreen(image,GetPixelGreen(image,pixels),q);\n                          SetPixelBlue(image,GetPixelBlue(image,pixels),q);\n                          SetPixelAlpha(image,GetPixelAlpha(image,pixels),q);\n                        }\n\n                      else if (magn_methx == 2 || magn_methx == 4)\n                        {\n                          if (i == 0)\n                          {\n                            SetPixelRed(image,GetPixelRed(image,pixels),q);\n                            SetPixelGreen(image,GetPixelGreen(image,pixels),q);\n                            SetPixelBlue(image,GetPixelBlue(image,pixels),q);\n                            SetPixelAlpha(image,GetPixelAlpha(image,pixels),q);\n                          }\n\n                          /* To do: Rewrite using Get/Set***PixelChannel() */\n                          else\n                            {\n                              /* Interpolate */\n                              SetPixelRed(image,(QM) ((2*i*(\n                                 GetPixelRed(image,n)\n                                 -GetPixelRed(image,pixels))+m)\n                                 /((ssize_t) (m*2))+\n                                 GetPixelRed(image,pixels)),q);\n\n                              SetPixelGreen(image,(QM) ((2*i*(\n                                 GetPixelGreen(image,n)\n                                 -GetPixelGreen(image,pixels))+m)\n                                 /((ssize_t) (m*2))+\n                                 GetPixelGreen(image,pixels)),q);\n\n                              SetPixelBlue(image,(QM) ((2*i*(\n                                 GetPixelBlue(image,n)\n                                 -GetPixelBlue(image,pixels))+m)\n                                 /((ssize_t) (m*2))+\n                                 GetPixelBlue(image,pixels)),q);\n                              if (image->alpha_trait != UndefinedPixelTrait)\n                                 SetPixelAlpha(image,(QM) ((2*i*(\n                                   GetPixelAlpha(image,n)\n                                   -GetPixelAlpha(image,pixels))+m)\n                                   /((ssize_t) (m*2))+\n                                   GetPixelAlpha(image,pixels)),q);\n                            }\n\n                          if (magn_methx == 4)\n                            {\n                              /* Replicate nearest */\n                              if (i <= ((m+1) << 1))\n                              {\n                                 SetPixelAlpha(image,\n                                   GetPixelAlpha(image,pixels)+0,q);\n                              }\n                              else\n                              {\n                                 SetPixelAlpha(image,\n                                   GetPixelAlpha(image,n)+0,q);\n                              }\n                            }\n                        }\n\n                      else /* if (magn_methx == 3 || magn_methx == 5) */\n                        {\n                          /* Replicate nearest */\n                          if (i <= ((m+1) << 1))\n                          {\n                             SetPixelRed(image,GetPixelRed(image,pixels),q);\n                             SetPixelGreen(image,GetPixelGreen(image,\n                                 pixels),q);\n                             SetPixelBlue(image,GetPixelBlue(image,pixels),q);\n                             SetPixelAlpha(image,GetPixelAlpha(image,\n                                 pixels),q);\n                          }\n\n                          else\n                          {\n                             SetPixelRed(image,GetPixelRed(image,n),q);\n                             SetPixelGreen(image,GetPixelGreen(image,n),q);\n                             SetPixelBlue(image,GetPixelBlue(image,n),q);\n                             SetPixelAlpha(image,GetPixelAlpha(image,n),q);\n                          }\n\n                          if (magn_methx == 5)\n                            {\n                              /* Interpolate */\n                              SetPixelAlpha(image,\n                                 (QM) ((2*i*( GetPixelAlpha(image,n)\n                                 -GetPixelAlpha(image,pixels))+m)/\n                                 ((ssize_t) (m*2))\n                                 +GetPixelAlpha(image,pixels)),q);\n                            }\n                        }\n                      q+=GetPixelChannels(image);\n                    }\n                    n+=GetPixelChannels(image);\n                  }\n\n                  if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                    break;\n                }\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n              if (magn_methx != 1 || magn_methy != 1)\n                {\n                /*\n                   Rescale pixels to Quantum\n                */\n                   for (y=0; y < (ssize_t) image->rows; y++)\n                   {\n                     q=GetAuthenticPixels(image,0,y,image->columns,1,\n                       exception);\n\n                     for (x=(ssize_t) image->columns-1; x >= 0; x--)\n                     {\n                        SetPixelRed(image,ScaleShortToQuantum(\n                          GetPixelRed(image,q)),q);\n                        SetPixelGreen(image,ScaleShortToQuantum(\n                          GetPixelGreen(image,q)),q);\n                        SetPixelBlue(image,ScaleShortToQuantum(\n                          GetPixelBlue(image,q)),q);\n                        SetPixelAlpha(image,ScaleShortToQuantum(\n                          GetPixelAlpha(image,q)),q);\n                        q+=GetPixelChannels(image);\n                     }\n\n                     if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                       break;\n                   }\n                }\n#endif\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"  Finished MAGN processing\");\n              }\n          }\n\n        /*\n          Crop_box is with respect to the upper left corner of the MNG.\n        */\n        crop_box.left=mng_info->image_box.left+mng_info->x_off[object_id];\n        crop_box.right=mng_info->image_box.right+mng_info->x_off[object_id];\n        crop_box.top=mng_info->image_box.top+mng_info->y_off[object_id];\n        crop_box.bottom=mng_info->image_box.bottom+mng_info->y_off[object_id];\n        crop_box=mng_minimum_box(crop_box,mng_info->clip);\n        crop_box=mng_minimum_box(crop_box,mng_info->frame);\n        crop_box=mng_minimum_box(crop_box,mng_info->object_clip[object_id]);\n        if ((crop_box.left != (mng_info->image_box.left\n            +mng_info->x_off[object_id])) ||\n            (crop_box.right != (mng_info->image_box.right\n            +mng_info->x_off[object_id])) ||\n            (crop_box.top != (mng_info->image_box.top\n            +mng_info->y_off[object_id])) ||\n            (crop_box.bottom != (mng_info->image_box.bottom\n            +mng_info->y_off[object_id])))\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  Crop the PNG image\");\n\n            if ((crop_box.left < crop_box.right) &&\n                (crop_box.top < crop_box.bottom))\n              {\n                Image\n                  *im;\n\n                RectangleInfo\n                  crop_info;\n\n                /*\n                  Crop_info is with respect to the upper left corner of\n                  the image.\n                */\n                crop_info.x=(crop_box.left-mng_info->x_off[object_id]);\n                crop_info.y=(crop_box.top-mng_info->y_off[object_id]);\n                crop_info.width=(size_t) (crop_box.right-crop_box.left);\n                crop_info.height=(size_t) (crop_box.bottom-crop_box.top);\n                image->page.width=image->columns;\n                image->page.height=image->rows;\n                image->page.x=0;\n                image->page.y=0;\n                im=CropImage(image,&crop_info,exception);\n\n                if (im != (Image *) NULL)\n                  {\n                    image->columns=im->columns;\n                    image->rows=im->rows;\n                    im=DestroyImage(im);\n                    image->page.width=image->columns;\n                    image->page.height=image->rows;\n                    image->page.x=crop_box.left;\n                    image->page.y=crop_box.top;\n                  }\n              }\n\n            else\n              {\n                /*\n                  No pixels in crop area.  The MNG spec still requires\n                  a layer, though, so make a single transparent pixel in\n                  the top left corner.\n                */\n                image->columns=1;\n                image->rows=1;\n                image->colors=2;\n                (void) SetImageBackgroundColor(image,exception);\n                image->page.width=1;\n                image->page.height=1;\n                image->page.x=0;\n                image->page.y=0;\n              }\n          }\n#ifndef PNG_READ_EMPTY_PLTE_SUPPORTED\n        image=mng_info->image;\n#endif\n      }\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n      /* PNG does not handle depths greater than 16 so reduce it even\n       * if lossy.\n       */\n      if (image->depth > 16)\n         image->depth=16;\n#endif\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 8)\n      if (image->depth > 8)\n        {\n          /* To do: fill low byte properly */\n          image->depth=16;\n        }\n\n      if (LosslessReduceDepthOK(image,exception) != MagickFalse)\n         image->depth = 8;\n#endif\n\n      if (image_info->number_scenes != 0)\n        {\n          if (mng_info->scenes_found >\n             (ssize_t) (image_info->first_scene+image_info->number_scenes))\n            break;\n        }\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Finished reading image datastream.\");\n\n  } while (LocaleCompare(image_info->magick,\"MNG\") == 0);\n\n  (void) CloseBlob(image);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Finished reading all image datastreams.\");\n\n#if defined(MNG_INSERT_LAYERS)\n  if (insert_layers && !mng_info->image_found && (mng_info->mng_width) &&\n       (mng_info->mng_height))\n    {\n      /*\n        Insert a background layer if nothing else was found.\n      */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  No images found.  Inserting a background layer.\");\n\n      if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n        {\n          /*\n            Allocate next image structure.\n          */\n          AcquireNextImage(image_info,image,exception);\n          if (GetNextImageInList(image) == (Image *) NULL)\n            {\n              if (logging != MagickFalse)\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Allocation failed, returning NULL.\");\n\n              return(DestroyImageList(image));;\n            }\n          image=SyncNextImageInList(image);\n        }\n      image->columns=mng_info->mng_width;\n      image->rows=mng_info->mng_height;\n      image->page.width=mng_info->mng_width;\n      image->page.height=mng_info->mng_height;\n      image->page.x=0;\n      image->page.y=0;\n      image->background_color=mng_background_color;\n      image->alpha_trait=UndefinedPixelTrait;\n\n      if (image_info->ping == MagickFalse)\n        (void) SetImageBackgroundColor(image,exception);\n\n      mng_info->image_found++;\n    }\n#endif\n  image->iterations=mng_iterations;\n\n  if (mng_iterations == 1)\n    image->start_loop=MagickTrue;\n\n  while (GetPreviousImageInList(image) != (Image *) NULL)\n  {\n    image_count++;\n    if (image_count > 10*mng_info->image_found)\n      {\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  No beginning\");\n\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CoderError,\"Linked list is corrupted, beginning of list not found\",\n          \"`%s'\",image_info->filename);\n\n        return(DestroyImageList(image));\n      }\n\n    image=GetPreviousImageInList(image);\n\n    if (GetNextImageInList(image) == (Image *) NULL)\n      {\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Corrupt list\");\n\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CoderError,\"Linked list is corrupted; next_image is NULL\",\"`%s'\",\n          image_info->filename);\n      }\n  }\n\n  if (mng_info->ticks_per_second && mng_info->image_found > 1 &&\n             GetNextImageInList(image) ==\n     (Image *) NULL)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  First image null\");\n\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        CoderError,\"image->next for first image is NULL but shouldn't be.\",\n        \"`%s'\",image_info->filename);\n    }\n\n  if (mng_info->image_found == 0)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  No visible images found.\");\n\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        CoderError,\"No visible images in file\",\"`%s'\",image_info->filename);\n\n      return(DestroyImageList(image));\n    }\n\n  if (mng_info->ticks_per_second)\n    final_delay=1UL*MagickMax(image->ticks_per_second,1L)*\n            final_delay/mng_info->ticks_per_second;\n\n  else\n    image->start_loop=MagickTrue;\n\n  /* Find final nonzero image delay */\n  final_image_delay=0;\n\n  while (GetNextImageInList(image) != (Image *) NULL)\n    {\n      if (image->delay)\n        final_image_delay=image->delay;\n\n      image=GetNextImageInList(image);\n    }\n\n  if (final_delay < final_image_delay)\n    final_delay=final_image_delay;\n\n  image->delay=final_delay;\n\n  if (logging != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  image->delay=%.20g, final_delay=%.20g\",(double) image->delay,\n        (double) final_delay);\n\n  if (logging != MagickFalse)\n    {\n      int\n        scene;\n\n      scene=0;\n      image=GetFirstImageInList(image);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Before coalesce:\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    scene 0 delay=%.20g\",(double) image->delay);\n\n      while (GetNextImageInList(image) != (Image *) NULL)\n      {\n        image=GetNextImageInList(image);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    scene %.20g delay=%.20g\",(double) scene++,\n          (double) image->delay);\n      }\n    }\n\n  image=GetFirstImageInList(image);\n#ifdef MNG_COALESCE_LAYERS\n  if (insert_layers)\n    {\n      Image\n        *next_image,\n        *next;\n\n      size_t\n        scene;\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Coalesce Images\");\n\n      scene=image->scene;\n      next_image=CoalesceImages(image,exception);\n\n      if (next_image == (Image *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n      image=DestroyImageList(image);\n      image=next_image;\n\n      for (next=image; next != (Image *) NULL; next=next_image)\n      {\n         next->page.width=mng_info->mng_width;\n         next->page.height=mng_info->mng_height;\n         next->page.x=0;\n         next->page.y=0;\n         next->scene=scene++;\n         next_image=GetNextImageInList(next);\n\n         if (next_image == (Image *) NULL)\n           break;\n\n         if (next->delay == 0)\n           {\n             scene--;\n             next_image->previous=GetPreviousImageInList(next);\n             if (GetPreviousImageInList(next) == (Image *) NULL)\n               image=next_image;\n             else\n               next->previous->next=next_image;\n             next=DestroyImage(next);\n           }\n      }\n    }\n#endif\n\n  while (GetNextImageInList(image) != (Image *) NULL)\n      image=GetNextImageInList(image);\n\n  image->dispose=BackgroundDispose;\n\n  if (logging != MagickFalse)\n    {\n      int\n        scene;\n\n      scene=0;\n      image=GetFirstImageInList(image);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  After coalesce:\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    scene 0 delay=%.20g dispose=%.20g\",(double) image->delay,\n        (double) image->dispose);\n\n      while (GetNextImageInList(image) != (Image *) NULL)\n      {\n        image=GetNextImageInList(image);\n\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    scene %.20g delay=%.20g dispose=%.20g\",(double) scene++,\n          (double) image->delay,(double) image->dispose);\n      }\n   }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit ReadOneMNGImage();\");\n\n  return(image);\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/channel.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/pixel.h\"\n#include \"MagickCore/MagickCore.h\"\n#include \"MagickCore/transform.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/profile.h\"\n#include \"zlib.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/layer.h\"\n#include \"MagickCore/enhance.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/histogram.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/utility.h\"\n#include \"png.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/color-private.h\"\n"
  },
  {
    "repository": "linux",
    "cve_id": "CVE-2019-16234",
    "cwe_list": [
      "CWE-476"
    ],
    "commit_hash": "8188a18ee2e48c9a7461139838048363bfce3fef",
    "short_hash": "8188a18e",
    "vulnerableMethods_before": [
      {
        "filename": "trans.c",
        "method_name": "vulnerable_function",
        "raw_code": "struct iwl_trans *iwl_trans_pcie_alloc(struct pci_dev *pdev,\n\t\t\t       const struct pci_device_id *ent,\n\t\t\t       const struct iwl_cfg_trans_params *cfg_trans)\n{\n\tstruct iwl_trans_pcie *trans_pcie;\n\tstruct iwl_trans *trans;\n\tint ret, addr_size;\n\n\tret = pcim_enable_device(pdev);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (cfg_trans->gen2)\n\t\ttrans = iwl_trans_alloc(sizeof(struct iwl_trans_pcie),\n\t\t\t\t\t&pdev->dev, &trans_ops_pcie_gen2);\n\telse\n\t\ttrans = iwl_trans_alloc(sizeof(struct iwl_trans_pcie),\n\t\t\t\t\t&pdev->dev, &trans_ops_pcie);\n\n\tif (!trans)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttrans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\n\ttrans_pcie->trans = trans;\n\ttrans_pcie->opmode_down = true;\n\tspin_lock_init(&trans_pcie->irq_lock);\n\tspin_lock_init(&trans_pcie->reg_lock);\n\tmutex_init(&trans_pcie->mutex);\n\tinit_waitqueue_head(&trans_pcie->ucode_write_waitq);\n\ttrans_pcie->tso_hdr_page = alloc_percpu(struct iwl_tso_hdr_page);\n\tif (!trans_pcie->tso_hdr_page) {\n\t\tret = -ENOMEM;\n\t\tgoto out_no_pci;\n\t}\n\ttrans_pcie->debug_rfkill = -1;\n\n\tif (!cfg_trans->base_params->pcie_l1_allowed) {\n\t\t/*\n\t\t * W/A - seems to solve weird behavior. We need to remove this\n\t\t * if we don't want to stay in L1 all the time. This wastes a\n\t\t * lot of power.\n\t\t */\n\t\tpci_disable_link_state(pdev, PCIE_LINK_STATE_L0S |\n\t\t\t\t       PCIE_LINK_STATE_L1 |\n\t\t\t\t       PCIE_LINK_STATE_CLKPM);\n\t}\n\n\ttrans_pcie->def_rx_queue = 0;\n\n\tif (cfg_trans->use_tfh) {\n\t\taddr_size = 64;\n\t\ttrans_pcie->max_tbs = IWL_TFH_NUM_TBS;\n\t\ttrans_pcie->tfd_size = sizeof(struct iwl_tfh_tfd);\n\t} else {\n\t\taddr_size = 36;\n\t\ttrans_pcie->max_tbs = IWL_NUM_OF_TBS;\n\t\ttrans_pcie->tfd_size = sizeof(struct iwl_tfd);\n\t}\n\ttrans->max_skb_frags = IWL_PCIE_MAX_FRAGS(trans_pcie);\n\n\tpci_set_master(pdev);\n\n\tret = pci_set_dma_mask(pdev, DMA_BIT_MASK(addr_size));\n\tif (!ret)\n\t\tret = pci_set_consistent_dma_mask(pdev,\n\t\t\t\t\t\t  DMA_BIT_MASK(addr_size));\n\tif (ret) {\n\t\tret = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\n\t\tif (!ret)\n\t\t\tret = pci_set_consistent_dma_mask(pdev,\n\t\t\t\t\t\t\t  DMA_BIT_MASK(32));\n\t\t/* both attempts failed: */\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"No suitable DMA available\\n\");\n\t\t\tgoto out_no_pci;\n\t\t}\n\t}\n\n\tret = pcim_iomap_regions_request_all(pdev, BIT(0), DRV_NAME);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"pcim_iomap_regions_request_all failed\\n\");\n\t\tgoto out_no_pci;\n\t}\n\n\ttrans_pcie->hw_base = pcim_iomap_table(pdev)[0];\n\tif (!trans_pcie->hw_base) {\n\t\tdev_err(&pdev->dev, \"pcim_iomap_table failed\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out_no_pci;\n\t}\n\n\t/* We disable the RETRY_TIMEOUT register (0x41) to keep\n\t * PCI Tx retries from interfering with C3 CPU state */\n\tpci_write_config_byte(pdev, PCI_CFG_RETRY_TIMEOUT, 0x00);\n\n\ttrans_pcie->pci_dev = pdev;\n\tiwl_disable_interrupts(trans);\n\n\ttrans->hw_rev = iwl_read32(trans, CSR_HW_REV);\n\tif (trans->hw_rev == 0xffffffff) {\n\t\tdev_err(&pdev->dev, \"HW_REV=0xFFFFFFFF, PCI issues?\\n\");\n\t\tret = -EIO;\n\t\tgoto out_no_pci;\n\t}\n\n\t/*\n\t * In the 8000 HW family the format of the 4 bytes of CSR_HW_REV have\n\t * changed, and now the revision step also includes bit 0-1 (no more\n\t * \"dash\" value). To keep hw_rev backwards compatible - we'll store it\n\t * in the old format.\n\t */\n\tif (cfg_trans->device_family >= IWL_DEVICE_FAMILY_8000) {\n\t\ttrans->hw_rev = (trans->hw_rev & 0xfff0) |\n\t\t\t\t(CSR_HW_REV_STEP(trans->hw_rev << 2) << 2);\n\n\t\tret = iwl_pcie_prepare_card_hw(trans);\n\t\tif (ret) {\n\t\t\tIWL_WARN(trans, \"Exit HW not ready\\n\");\n\t\t\tgoto out_no_pci;\n\t\t}\n\n\t\t/*\n\t\t * in-order to recognize C step driver should read chip version\n\t\t * id located at the AUX bus MISC address space.\n\t\t */\n\t\tret = iwl_finish_nic_init(trans, cfg_trans);\n\t\tif (ret)\n\t\t\tgoto out_no_pci;\n\n\t}\n\n\tIWL_DEBUG_INFO(trans, \"HW REV: 0x%0x\\n\", trans->hw_rev);\n\n\tiwl_pcie_set_interrupt_capa(pdev, trans, cfg_trans);\n\ttrans->hw_id = (pdev->device << 16) + pdev->subsystem_device;\n\tsnprintf(trans->hw_id_str, sizeof(trans->hw_id_str),\n\t\t \"PCI ID: 0x%04X:0x%04X\", pdev->device, pdev->subsystem_device);\n\n\t/* Initialize the wait queue for commands */\n\tinit_waitqueue_head(&trans_pcie->wait_command_queue);\n\n\tinit_waitqueue_head(&trans_pcie->sx_waitq);\n\n\tif (trans_pcie->msix_enabled) {\n\t\tret = iwl_pcie_init_msix_handler(pdev, trans_pcie);\n\t\tif (ret)\n\t\t\tgoto out_no_pci;\n\t } else {\n\t\tret = iwl_pcie_alloc_ict(trans);\n\t\tif (ret)\n\t\t\tgoto out_no_pci;\n\n\t\tret = devm_request_threaded_irq(&pdev->dev, pdev->irq,\n\t\t\t\t\t\tiwl_pcie_isr,\n\t\t\t\t\t\tiwl_pcie_irq_handler,\n\t\t\t\t\t\tIRQF_SHARED, DRV_NAME, trans);\n\t\tif (ret) {\n\t\t\tIWL_ERR(trans, \"Error allocating IRQ %d\\n\", pdev->irq);\n\t\t\tgoto out_free_ict;\n\t\t}\n\t\ttrans_pcie->inta_mask = CSR_INI_SET_MASK;\n\t }\n\n\ttrans_pcie->rba.alloc_wq = alloc_workqueue(\"rb_allocator\",\n\t\t\t\t\t\t   WQ_HIGHPRI | WQ_UNBOUND, 1);\n\tINIT_WORK(&trans_pcie->rba.rx_alloc, iwl_pcie_rx_allocator_work);\n\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\ttrans_pcie->fw_mon_data.state = IWL_FW_MON_DBGFS_STATE_CLOSED;\n\tmutex_init(&trans_pcie->fw_mon_data.mutex);\n#endif\n\n\treturn trans;\n\nout_free_ict:\n\tiwl_pcie_free_ict(trans);\nout_no_pci:\n\tfree_percpu(trans_pcie->tso_hdr_page);\n\tiwl_trans_free(trans);\n\treturn ERR_PTR(ret);\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "trans.c",
        "method_name": "fixed_function",
        "raw_code": "struct iwl_trans *iwl_trans_pcie_alloc(struct pci_dev *pdev,\n\t\t\t       const struct pci_device_id *ent,\n\t\t\t       const struct iwl_cfg_trans_params *cfg_trans)\n{\n\tstruct iwl_trans_pcie *trans_pcie;\n\tstruct iwl_trans *trans;\n\tint ret, addr_size;\n\n\tret = pcim_enable_device(pdev);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (cfg_trans->gen2)\n\t\ttrans = iwl_trans_alloc(sizeof(struct iwl_trans_pcie),\n\t\t\t\t\t&pdev->dev, &trans_ops_pcie_gen2);\n\telse\n\t\ttrans = iwl_trans_alloc(sizeof(struct iwl_trans_pcie),\n\t\t\t\t\t&pdev->dev, &trans_ops_pcie);\n\n\tif (!trans)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttrans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);\n\n\ttrans_pcie->trans = trans;\n\ttrans_pcie->opmode_down = true;\n\tspin_lock_init(&trans_pcie->irq_lock);\n\tspin_lock_init(&trans_pcie->reg_lock);\n\tmutex_init(&trans_pcie->mutex);\n\tinit_waitqueue_head(&trans_pcie->ucode_write_waitq);\n\n\ttrans_pcie->rba.alloc_wq = alloc_workqueue(\"rb_allocator\",\n\t\t\t\t\t\t   WQ_HIGHPRI | WQ_UNBOUND, 1);\n\tif (!trans_pcie->rba.alloc_wq) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_trans;\n\t}\n\tINIT_WORK(&trans_pcie->rba.rx_alloc, iwl_pcie_rx_allocator_work);\n\n\ttrans_pcie->tso_hdr_page = alloc_percpu(struct iwl_tso_hdr_page);\n\tif (!trans_pcie->tso_hdr_page) {\n\t\tret = -ENOMEM;\n\t\tgoto out_no_pci;\n\t}\n\ttrans_pcie->debug_rfkill = -1;\n\n\tif (!cfg_trans->base_params->pcie_l1_allowed) {\n\t\t/*\n\t\t * W/A - seems to solve weird behavior. We need to remove this\n\t\t * if we don't want to stay in L1 all the time. This wastes a\n\t\t * lot of power.\n\t\t */\n\t\tpci_disable_link_state(pdev, PCIE_LINK_STATE_L0S |\n\t\t\t\t       PCIE_LINK_STATE_L1 |\n\t\t\t\t       PCIE_LINK_STATE_CLKPM);\n\t}\n\n\ttrans_pcie->def_rx_queue = 0;\n\n\tif (cfg_trans->use_tfh) {\n\t\taddr_size = 64;\n\t\ttrans_pcie->max_tbs = IWL_TFH_NUM_TBS;\n\t\ttrans_pcie->tfd_size = sizeof(struct iwl_tfh_tfd);\n\t} else {\n\t\taddr_size = 36;\n\t\ttrans_pcie->max_tbs = IWL_NUM_OF_TBS;\n\t\ttrans_pcie->tfd_size = sizeof(struct iwl_tfd);\n\t}\n\ttrans->max_skb_frags = IWL_PCIE_MAX_FRAGS(trans_pcie);\n\n\tpci_set_master(pdev);\n\n\tret = pci_set_dma_mask(pdev, DMA_BIT_MASK(addr_size));\n\tif (!ret)\n\t\tret = pci_set_consistent_dma_mask(pdev,\n\t\t\t\t\t\t  DMA_BIT_MASK(addr_size));\n\tif (ret) {\n\t\tret = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\n\t\tif (!ret)\n\t\t\tret = pci_set_consistent_dma_mask(pdev,\n\t\t\t\t\t\t\t  DMA_BIT_MASK(32));\n\t\t/* both attempts failed: */\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"No suitable DMA available\\n\");\n\t\t\tgoto out_no_pci;\n\t\t}\n\t}\n\n\tret = pcim_iomap_regions_request_all(pdev, BIT(0), DRV_NAME);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"pcim_iomap_regions_request_all failed\\n\");\n\t\tgoto out_no_pci;\n\t}\n\n\ttrans_pcie->hw_base = pcim_iomap_table(pdev)[0];\n\tif (!trans_pcie->hw_base) {\n\t\tdev_err(&pdev->dev, \"pcim_iomap_table failed\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out_no_pci;\n\t}\n\n\t/* We disable the RETRY_TIMEOUT register (0x41) to keep\n\t * PCI Tx retries from interfering with C3 CPU state */\n\tpci_write_config_byte(pdev, PCI_CFG_RETRY_TIMEOUT, 0x00);\n\n\ttrans_pcie->pci_dev = pdev;\n\tiwl_disable_interrupts(trans);\n\n\ttrans->hw_rev = iwl_read32(trans, CSR_HW_REV);\n\tif (trans->hw_rev == 0xffffffff) {\n\t\tdev_err(&pdev->dev, \"HW_REV=0xFFFFFFFF, PCI issues?\\n\");\n\t\tret = -EIO;\n\t\tgoto out_no_pci;\n\t}\n\n\t/*\n\t * In the 8000 HW family the format of the 4 bytes of CSR_HW_REV have\n\t * changed, and now the revision step also includes bit 0-1 (no more\n\t * \"dash\" value). To keep hw_rev backwards compatible - we'll store it\n\t * in the old format.\n\t */\n\tif (cfg_trans->device_family >= IWL_DEVICE_FAMILY_8000) {\n\t\ttrans->hw_rev = (trans->hw_rev & 0xfff0) |\n\t\t\t\t(CSR_HW_REV_STEP(trans->hw_rev << 2) << 2);\n\n\t\tret = iwl_pcie_prepare_card_hw(trans);\n\t\tif (ret) {\n\t\t\tIWL_WARN(trans, \"Exit HW not ready\\n\");\n\t\t\tgoto out_no_pci;\n\t\t}\n\n\t\t/*\n\t\t * in-order to recognize C step driver should read chip version\n\t\t * id located at the AUX bus MISC address space.\n\t\t */\n\t\tret = iwl_finish_nic_init(trans, cfg_trans);\n\t\tif (ret)\n\t\t\tgoto out_no_pci;\n\n\t}\n\n\tIWL_DEBUG_INFO(trans, \"HW REV: 0x%0x\\n\", trans->hw_rev);\n\n\tiwl_pcie_set_interrupt_capa(pdev, trans, cfg_trans);\n\ttrans->hw_id = (pdev->device << 16) + pdev->subsystem_device;\n\tsnprintf(trans->hw_id_str, sizeof(trans->hw_id_str),\n\t\t \"PCI ID: 0x%04X:0x%04X\", pdev->device, pdev->subsystem_device);\n\n\t/* Initialize the wait queue for commands */\n\tinit_waitqueue_head(&trans_pcie->wait_command_queue);\n\n\tinit_waitqueue_head(&trans_pcie->sx_waitq);\n\n\tif (trans_pcie->msix_enabled) {\n\t\tret = iwl_pcie_init_msix_handler(pdev, trans_pcie);\n\t\tif (ret)\n\t\t\tgoto out_no_pci;\n\t } else {\n\t\tret = iwl_pcie_alloc_ict(trans);\n\t\tif (ret)\n\t\t\tgoto out_no_pci;\n\n\t\tret = devm_request_threaded_irq(&pdev->dev, pdev->irq,\n\t\t\t\t\t\tiwl_pcie_isr,\n\t\t\t\t\t\tiwl_pcie_irq_handler,\n\t\t\t\t\t\tIRQF_SHARED, DRV_NAME, trans);\n\t\tif (ret) {\n\t\t\tIWL_ERR(trans, \"Error allocating IRQ %d\\n\", pdev->irq);\n\t\t\tgoto out_free_ict;\n\t\t}\n\t\ttrans_pcie->inta_mask = CSR_INI_SET_MASK;\n\t }\n\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\ttrans_pcie->fw_mon_data.state = IWL_FW_MON_DBGFS_STATE_CLOSED;\n\tmutex_init(&trans_pcie->fw_mon_data.mutex);\n#endif\n\n\treturn trans;\n\nout_free_ict:\n\tiwl_pcie_free_ict(trans);\nout_no_pci:\n\tfree_percpu(trans_pcie->tso_hdr_page);\n\tdestroy_workqueue(trans_pcie->rba.alloc_wq);\nout_free_trans:\n\tiwl_trans_free(trans);\n\treturn ERR_PTR(ret);\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <linux/wait.h>\n#include <linux/pci.h>\n#include \"fw/dbg.h\"\n#include <linux/bitops.h>\n#include <linux/debugfs.h>\n#include \"iwl-fh.h\"\n#include \"fw/error-dump.h\"\n#include \"iwl-csr.h\"\n#include \"iwl-trans.h\"\n#include \"iwl-prph.h\"\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include \"internal.h\"\n#include <linux/module.h>\n#include \"iwl-scd.h\"\n#include <linux/gfp.h>\n#include <linux/vmalloc.h>\n#include \"iwl-agn-hw.h\"\n#include \"iwl-drv.h\"\n\n// Type Definitions:\n// iwl_trans:\nstruct iwl_trans\n\n// pci_dev:\nstruct pci_dev\n\n// iwl_trans_ops:\nstatic const struct iwl_trans_ops\n\n// iwl_cfg_trans_params:\nstruct iwl_cfg_trans_params {\n\tconst struct iwl_base_params *base_params;\n\tconst struct iwl_csr_params *csr;\n\tenum iwl_device_family device_family;\n\tu32 umac_prph_offset;\n\tu32 rf_id:1,\n\t    use_tfh:1,\n\t    gen2:1,\n\t    mq_rx_supported:1,\n\t    bisr_workaround:1;\n}\n\n// Called Methods (top 10):\n// iwl_read32 from drivers/net/wireless/intel/iwlwifi/iwl-io.c:\nu32 iwl_read32(struct iwl_trans *trans, u32 ofs) /* <=== iwl_read32 */ \n{\n\tu32 val = iwl_trans_read32(trans, ofs);\n\n\ttrace_iwlwifi_dev_ioread32(trans->dev, ofs, val);\n\treturn val;\n}\n\n// DRV_NAME from drivers/net/wireless/intel/iwlwifi/pcie/iwl-drv.h:\n\n\n// PCI_CFG_RETRY_TIMEOUT from drivers/net/wireless/intel/iwlwifi/pcie/trans.c:\n#define PCI_CFG_RETRY_TIMEOUT\t0x041 /* <=== drivers/net/wireless/intel/iwlwifi/pcie/trans.c:296:296:PCI_CFG_RETRY_TIMEOUT:0 */ \n"
  },
  {
    "repository": "pjproject",
    "cve_id": "CVE-2021-37706",
    "cwe_list": [
      "CWE-191"
    ],
    "commit_hash": "15663e3f37091069b8c98a7fce680dc04bc8e865",
    "short_hash": "15663e3f",
    "vulnerableMethods_before": [
      {
        "filename": "None",
        "method_name": "vulnerable_function",
        "raw_code": "static pj_status_t decode_errcode_attr(pj_pool_t *pool, \n\t\t\t\t       const pj_uint8_t *buf,\n\t\t\t\t       const pj_stun_msg_hdr *msghdr, \n\t\t\t\t       void **p_attr)\n{\n    pj_stun_errcode_attr *attr;\n    pj_str_t value;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_errcode_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    attr->err_code = buf[6] * 100 + buf[7];\n\n    /* Get pointer to the string in the message */\n    value.ptr = ((char*)buf + ATTR_HDR_LEN + 4);\n    value.slen = attr->hdr.length - 4;\n\n    /* Copy the string to the attribute */\n    pj_strdup(pool, &attr->reason, &value);\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "None",
        "method_name": "fixed_function",
        "raw_code": "static pj_status_t decode_errcode_attr(pj_pool_t *pool, \n\t\t\t\t       const pj_uint8_t *buf,\n\t\t\t\t       const pj_stun_msg_hdr *msghdr, \n\t\t\t\t       void **p_attr)\n{\n    pj_stun_errcode_attr *attr;\n    pj_str_t value;\n\n    PJ_UNUSED_ARG(msghdr);\n\n    /* Create the attribute */\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_errcode_attr);\n    GETATTRHDR(buf, &attr->hdr);\n\n    attr->err_code = buf[6] * 100 + buf[7];\n\n    /* Get pointer to the string in the message */\n    value.ptr = ((char*)buf + ATTR_HDR_LEN + 4);\n    value.slen = attr->hdr.length - 4;\n    /* Make sure the length is never negative */\n    if (value.slen < 0)\n    \tvalue.slen = 0;\n\n    /* Copy the string to the attribute */\n    pj_strdup(pool, &attr->reason, &value);\n\n    /* Done */\n    *p_attr = attr;\n\n    return PJ_SUCCESS;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <pj/rand.h>\n#include <pjlib-util/hmac_sha1.h>\n#include <pjlib-util/crc32.h>\n#include <pj/assert.h>\n#include <pjnath/errno.h>\n#include <pjnath/stun_msg.h>\n#include <pj/string.h>\n#include <pj/pool.h>\n#include <pj/log.h>\n#include <pj/os.h>\n\n// Type Definitions:\n// pj_status_t:\ntypedef int\t\tpj_status_t;\n\n// pj_stun_errcode_attr:\ntypedef struct pj_stun_errcode_attr\n{\n    /**\n     * Standard STUN attribute header.\n     */\n    pj_stun_attr_hdr\thdr;\n\n    /**\n     * STUN error code.\n     */\n    int\t\t\terr_code;\n\n    /**\n     * The reason phrase.\n     */\n    pj_str_t\t\treason;\n\n} pj_stun_errcode_attr;\n\n// pj_stun_errcode_attr:\ntypedef struct pj_stun_errcode_attr\n{\n    /**\n     * Standard STUN attribute header.\n     */\n    pj_stun_attr_hdr\thdr;\n\n    /**\n     * STUN error code.\n     */\n    int\t\t\terr_code;\n\n    /**\n     * The reason phrase.\n     */\n    pj_str_t\t\treason;\n\n}\n\n// pj_uint8_t:\ntypedef unsigned char\tpj_uint8_t;\n\n// pj_pool_t:\nstruct pj_pool_t\n{\n    PJ_DECL_LIST_MEMBER(struct pj_pool_t);  /**< Standard list elements.    */\n\n    /** Pool name */\n    char\t    obj_name[PJ_MAX_OBJ_NAME];\n\n    /** Pool factory. */\n    pj_pool_factory *factory;\n\n    /** Data put by factory */\n    void\t    *factory_data;\n\n    /** Current capacity allocated by the pool. */\n    pj_size_t\t    capacity;\n\n    /** Size of memory block to be allocated when the pool runs out of memory */\n    pj_size_t\t    increment_size;\n\n    /** List of memory blocks allcoated by the pool. */\n    pj_pool_block   block_list;\n\n    /** The callback to be called when the pool is unable to allocate memory. */\n    pj_pool_callback *callback;\n\n}\n\n// pj_str_t:\nstruct pj_str_t\n{\n    /** Buffer pointer, which is by convention NOT null terminated. */\n    char       *ptr;\n\n    /** The length of the string. */\n    pj_ssize_t  slen;\n}\n\n// Called Methods (top 10):\n// pj_pool_alloc from pjlib/include/pj/pool_i.h:\nPJ_IDEF(void*) pj_pool_alloc( pj_pool_t *pool, pj_size_t size) /* <=== pj_pool_alloc */ \n{\n    void *ptr = pj_pool_alloc_from_block(pool->block_list.next, size);\n    if (!ptr)\n\tptr = pj_pool_allocate_find(pool, size);\n    return ptr;\n}\n\n// pj_pool_allocate_find from pjlib/src/pj/pool.c:\nPJ_DEF(void*) pj_pool_allocate_find(pj_pool_t *pool, pj_size_t size) /* <=== pj_pool_allocate_find */ \n{\n    pj_pool_block *block = pool->block_list.next;\n    void *p;\n    pj_size_t block_size;\n\n    PJ_CHECK_STACK();\n\n    while (block != &pool->block_list) {\n\tp = pj_pool_alloc_from_block(block, size);\n\tif (p != NULL)\n\t    return p;\n\tblock = block->next;\n    }\n    /* No available space in all blocks. */\n\n    /* If pool is configured NOT to expand, return error. */\n    if (pool->increment_size == 0) {\n\tLOG((pool->obj_name, \"Can't expand pool to allocate %u bytes \"\n\t     \"(used=%u, cap=%u)\",\n\t     size, pj_pool_get_used_size(pool), pool->capacity));\n\t(*pool->callback)(pool, size);\n\treturn NULL;\n    }\n\n    /* If pool is configured to expand, but the increment size\n     * is less than the required size, expand the pool by multiple\n     * increment size. Also count the size wasted due to aligning\n     * the block.\n     */\n    if (pool->increment_size < \n\t    size + sizeof(pj_pool_block) + PJ_POOL_ALIGNMENT) \n    {\n        pj_size_t count;\n        count = (size + pool->increment_size + sizeof(pj_pool_block) +\n                 PJ_POOL_ALIGNMENT) / \n                pool->increment_size;\n        block_size = count * pool->increment_size;\n\n    } else {\n        block_size = pool->increment_size;\n    }\n\n    LOG((pool->obj_name, \n\t \"%u bytes requested, resizing pool by %u bytes (used=%u, cap=%u)\",\n\t size, block_size, pj_pool_get_used_size(pool), pool->capacity));\n\n    block = pj_pool_create_block(pool, block_size);\n    if (!block)\n\treturn NULL;\n\n    p = pj_pool_alloc_from_block(block, size);\n    pj_assert(p != NULL);\n#if PJ_DEBUG\n    if (p == NULL) {\n\tPJ_UNUSED_ARG(p);\n    }\n#endif\n    return p;\n}\n\n// pj_pool_alloc_from_block from pjlib/include/pj/pool_i.h:\nPJ_IDEF(void*) pj_pool_alloc_from_block( pj_pool_block *block, pj_size_t size ) /* <=== pj_pool_alloc_from_block */ \n{\n    /* The operation below is valid for size==0. \n     * When size==0, the function will return the pointer to the pool\n     * memory address, but no memory will be allocated.\n     */\n    if (size & (PJ_POOL_ALIGNMENT-1)) {\n\tsize = (size + PJ_POOL_ALIGNMENT) & ~(PJ_POOL_ALIGNMENT-1);\n    }\n    if ((pj_size_t)(block->end - block->cur) >= size) {\n\tvoid *ptr = block->cur;\n\tblock->cur += size;\n\treturn ptr;\n    }\n    return NULL;\n}\n\n// pj_strdup from pjlib/include/pj/string_i.h:\npj_strdup(pj_pool_t *pool,\n\t\t\t      pj_str_t *dst,\n\t\t\t      const pj_str_t *src)\n{\n    pj_assert(src->slen >= 0);\n\n    /* Without this, destination will be corrupted */\n    if (dst == src)\n\treturn dst;\n\n    if (src->slen > 0) {\n\tdst->ptr = (char*)pj_pool_alloc(pool, src->slen);\n\tpj_memcpy(dst->ptr, src->ptr, src->slen);\n    }\n    dst->slen = (src->slen < 0)? 0: src->slen;\n    return dst;\n}\n\n// ATTR_HDR_LEN from pjnath/src/pjnath/stun_msg.c:\n<empty>\n\n// pj_memcpy from pjlib/include/pj/string.h:\nPJ_INLINE(void*) pj_memcpy(void *dst, const void *src, pj_size_t size) /* <=== pj_memcpy */ \n{\n    return memcpy(dst, src, size);\n}\n"
  },
  {
    "repository": "tensorflow",
    "cve_id": "CVE-2022-21733",
    "cwe_list": [
      "CWE-190"
    ],
    "commit_hash": "f68fdab93fb7f4ddb4eb438c8fe052753c9413e8",
    "short_hash": "f68fdab9",
    "vulnerableMethods_before": [
      {
        "filename": "string_ngrams_op.cc",
        "method_name": "vulnerable_function",
        "raw_code": "  void Compute(tensorflow::OpKernelContext* context) override {\n    for (int ngram_width : ngram_widths_) {\n      OP_REQUIRES(\n          context, ngram_width > 0,\n          errors::InvalidArgument(\"ngram_widths must contain positive values\"));\n    }\n\n    const tensorflow::Tensor* data;\n    OP_REQUIRES_OK(context, context->input(\"data\", &data));\n    const auto& input_data = data->flat<tstring>().data();\n\n    const tensorflow::Tensor* splits;\n    OP_REQUIRES_OK(context, context->input(\"data_splits\", &splits));\n    const auto& splits_vec = splits->flat<SPLITS_TYPE>();\n\n    // Validate that the splits are valid indices into data, only if there are\n    // splits specified.\n    const int input_data_size = data->flat<tstring>().size();\n    const int splits_vec_size = splits_vec.size();\n    if (splits_vec_size > 0) {\n      int prev_split = splits_vec(0);\n      OP_REQUIRES(context, prev_split == 0,\n                  errors::InvalidArgument(\"First split value must be 0, got \",\n                                          prev_split));\n      for (int i = 1; i < splits_vec_size; ++i) {\n        bool valid_splits = splits_vec(i) >= prev_split;\n        valid_splits = valid_splits && (splits_vec(i) <= input_data_size);\n        OP_REQUIRES(context, valid_splits,\n                    errors::InvalidArgument(\n                        \"Invalid split value \", splits_vec(i), \", must be in [\",\n                        prev_split, \", \", input_data_size, \"]\"));\n        prev_split = splits_vec(i);\n      }\n      OP_REQUIRES(context, prev_split == input_data_size,\n                  errors::InvalidArgument(\n                      \"Last split value must be data size. Expected \",\n                      input_data_size, \", got \", prev_split));\n    }\n\n    int num_batch_items = splits_vec.size() - 1;\n    tensorflow::Tensor* ngrams_splits;\n    OP_REQUIRES_OK(\n        context, context->allocate_output(1, splits->shape(), &ngrams_splits));\n    auto ngrams_splits_data = ngrams_splits->flat<SPLITS_TYPE>().data();\n\n    // If there is no data or size, return an empty RT.\n    if (data->flat<tstring>().size() == 0 || splits_vec.size() == 0) {\n      tensorflow::Tensor* empty;\n      OP_REQUIRES_OK(context,\n                     context->allocate_output(0, data->shape(), &empty));\n      for (int i = 0; i <= num_batch_items; ++i) {\n        ngrams_splits_data[i] = 0;\n      }\n      return;\n    }\n\n    ngrams_splits_data[0] = 0;\n    for (int i = 1; i <= num_batch_items; ++i) {\n      int length = splits_vec(i) - splits_vec(i - 1);\n      int num_ngrams = 0;\n      for (int ngram_width : ngram_widths_)\n        num_ngrams += get_num_ngrams(length, ngram_width);\n      if (preserve_short_ && length > 0 && num_ngrams == 0) {\n        num_ngrams = 1;\n      }\n      ngrams_splits_data[i] = ngrams_splits_data[i - 1] + num_ngrams;\n    }\n\n    tensorflow::Tensor* ngrams;\n    OP_REQUIRES_OK(\n        context,\n        context->allocate_output(\n            0, TensorShape({ngrams_splits_data[num_batch_items]}), &ngrams));\n    auto ngrams_data = ngrams->flat<tstring>().data();\n\n    for (int i = 0; i < num_batch_items; ++i) {\n      auto data_start = &input_data[splits_vec(i)];\n      int output_start_idx = ngrams_splits_data[i];\n      for (int ngram_width : ngram_widths_) {\n        auto output_start = &ngrams_data[output_start_idx];\n        int length = splits_vec(i + 1) - splits_vec(i);\n        int num_ngrams = get_num_ngrams(length, ngram_width);\n        CreateNgrams(data_start, output_start, num_ngrams, ngram_width);\n        output_start_idx += num_ngrams;\n      }\n      // If we're preserving short sequences, check to see if no sequence was\n      // generated by comparing the current output start idx to the original\n      // one (ngram_splits_data). If no ngrams were generated, then they will\n      // be equal (since we increment output_start_idx by num_ngrams every\n      // time we create a set of ngrams.)\n      if (preserve_short_ && output_start_idx == ngrams_splits_data[i]) {\n        int data_length = splits_vec(i + 1) - splits_vec(i);\n        // One legitimate reason to not have any ngrams when preserve_short_\n        // is true is if the sequence itself is empty. In that case, move on.\n        if (data_length == 0) {\n          continue;\n        }\n        // We don't have to worry about dynamic padding sizes here: if padding\n        // was dynamic, every sequence would have had sufficient padding to\n        // generate at least one ngram.\n        int ngram_width = data_length + 2 * pad_width_;\n        auto output_start = &ngrams_data[output_start_idx];\n        int num_ngrams = 1;\n        CreateNgrams(data_start, output_start, num_ngrams, ngram_width);\n      }\n    }\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "string_ngrams_op.cc",
        "method_name": "fixed_function",
        "raw_code": "  void Compute(tensorflow::OpKernelContext* context) override {\n    for (int ngram_width : ngram_widths_) {\n      OP_REQUIRES(\n          context, ngram_width > 0,\n          errors::InvalidArgument(\"ngram_widths must contain positive values\"));\n    }\n\n    const tensorflow::Tensor* data;\n    OP_REQUIRES_OK(context, context->input(\"data\", &data));\n    const auto& input_data = data->flat<tstring>().data();\n\n    const tensorflow::Tensor* splits;\n    OP_REQUIRES_OK(context, context->input(\"data_splits\", &splits));\n    const auto& splits_vec = splits->flat<SPLITS_TYPE>();\n\n    // Validate that the splits are valid indices into data, only if there are\n    // splits specified.\n    const int input_data_size = data->flat<tstring>().size();\n    const int splits_vec_size = splits_vec.size();\n    if (splits_vec_size > 0) {\n      int prev_split = splits_vec(0);\n      OP_REQUIRES(context, prev_split == 0,\n                  errors::InvalidArgument(\"First split value must be 0, got \",\n                                          prev_split));\n      for (int i = 1; i < splits_vec_size; ++i) {\n        bool valid_splits = splits_vec(i) >= prev_split;\n        valid_splits = valid_splits && (splits_vec(i) <= input_data_size);\n        OP_REQUIRES(context, valid_splits,\n                    errors::InvalidArgument(\n                        \"Invalid split value \", splits_vec(i), \", must be in [\",\n                        prev_split, \", \", input_data_size, \"]\"));\n        prev_split = splits_vec(i);\n      }\n      OP_REQUIRES(context, prev_split == input_data_size,\n                  errors::InvalidArgument(\n                      \"Last split value must be data size. Expected \",\n                      input_data_size, \", got \", prev_split));\n    }\n\n    int num_batch_items = splits_vec.size() - 1;\n    tensorflow::Tensor* ngrams_splits;\n    OP_REQUIRES_OK(\n        context, context->allocate_output(1, splits->shape(), &ngrams_splits));\n    auto ngrams_splits_data = ngrams_splits->flat<SPLITS_TYPE>().data();\n\n    // If there is no data or size, return an empty RT.\n    if (data->flat<tstring>().size() == 0 || splits_vec.size() == 0) {\n      tensorflow::Tensor* empty;\n      OP_REQUIRES_OK(context,\n                     context->allocate_output(0, data->shape(), &empty));\n      for (int i = 0; i <= num_batch_items; ++i) {\n        ngrams_splits_data[i] = 0;\n      }\n      return;\n    }\n\n    ngrams_splits_data[0] = 0;\n    for (int i = 1; i <= num_batch_items; ++i) {\n      int length = splits_vec(i) - splits_vec(i - 1);\n      int num_ngrams = 0;\n      for (int ngram_width : ngram_widths_)\n        num_ngrams += get_num_ngrams(length, ngram_width);\n      if (preserve_short_ && length > 0 && num_ngrams == 0) {\n        num_ngrams = 1;\n      }\n      ngrams_splits_data[i] = ngrams_splits_data[i - 1] + num_ngrams;\n    }\n\n    tensorflow::Tensor* ngrams;\n    OP_REQUIRES_OK(\n        context,\n        context->allocate_output(\n            0, TensorShape({ngrams_splits_data[num_batch_items]}), &ngrams));\n    auto ngrams_data = ngrams->flat<tstring>().data();\n\n    for (int i = 0; i < num_batch_items; ++i) {\n      auto data_start = &input_data[splits_vec(i)];\n      int output_start_idx = ngrams_splits_data[i];\n      for (int ngram_width : ngram_widths_) {\n        auto output_start = &ngrams_data[output_start_idx];\n        int length = splits_vec(i + 1) - splits_vec(i);\n        int num_ngrams = get_num_ngrams(length, ngram_width);\n        CreateNgrams(data_start, output_start, num_ngrams, ngram_width);\n        output_start_idx += num_ngrams;\n      }\n      // If we're preserving short sequences, check to see if no sequence was\n      // generated by comparing the current output start idx to the original\n      // one (ngram_splits_data). If no ngrams were generated, then they will\n      // be equal (since we increment output_start_idx by num_ngrams every\n      // time we create a set of ngrams.)\n      if (preserve_short_ && output_start_idx == ngrams_splits_data[i]) {\n        int data_length = splits_vec(i + 1) - splits_vec(i);\n        // One legitimate reason to not have any ngrams when preserve_short_\n        // is true is if the sequence itself is empty. In that case, move on.\n        if (data_length == 0) {\n          continue;\n        }\n        // We don't have to worry about dynamic padding sizes here: if padding\n        // was dynamic, every sequence would have had sufficient padding to\n        // generate at least one ngram.\n\n        // If reached here, pad_width should be > 0, pad_width_ = -1,\n        // which indicates max(ngram_widths) - 1 cannot be used here since\n        // ngram_width is not known.\n        OP_REQUIRES(\n            context, pad_width_ >= 0,\n            errors::InvalidArgument(\"Pad width should be >= 0 when \"\n                                    \"preserve_short_sequences is True and \"\n                                    \"ngram_widths are not provided, got \",\n                                    pad_width_));\n        int ngram_width = data_length + 2 * pad_width_;\n        auto output_start = &ngrams_data[output_start_idx];\n        int num_ngrams = 1;\n        CreateNgrams(data_start, output_start, num_ngrams, ngram_width);\n      }\n    }\n  }",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"absl/strings/ascii.h\"\n#include <locale>\n#include \"tensorflow/core/platform/errors.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include <string>\n#include \"absl/strings/str_cat.h\"\n\n// Type Definitions:\n// Tensor:\ntensorflow.TensorHandle.Tensor:tensorflow.Status(tensorflow.Tensor**)<const>\n\n// iterator:\nclass iterator {\n   public:\n    typedef ssize_t difference_type;\n    typedef T value_type;\n    typedef const T* pointer;\n    typedef const T& reference;\n    typedef ::std::forward_iterator_tag iterator_category;\n\n    explicit iterator(uintptr_t rep)\n        : bigrep_(false), single_(reinterpret_cast<T>(rep)) {}\n    explicit iterator(typename BigRep::iterator iter)\n        : bigrep_(true), single_(nullptr), iter_(iter) {}\n\n    iterator& operator++() {\n      if (bigrep_) {\n        ++iter_;\n      } else {\n        DCHECK(single_ != nullptr);\n        single_ = nullptr;\n      }\n      return *this;\n    }\n    // maybe post-increment?\n\n    bool operator==(const iterator& other) const {\n      if (bigrep_) {\n        return iter_ == other.iter_;\n      } else {\n        return single_ == other.single_;\n      }\n    }\n    bool operator!=(const iterator& other) const { return !(*this == other); }\n\n    const T& operator*() const {\n      if (bigrep_) {\n        return *iter_;\n      } else {\n        DCH...\n\n// Status:\nclass Status\n\n// OpKernelContext:\nclass OpKernelContext {\n public:\n  // The first element of a WrappedAllocator is a \"base\" Allocator and\n  // the second element is that Allocator wrapped by a\n  // TrackingAllocator\n  typedef std::pair<Allocator*, TrackingAllocator*> WrappedAllocator;\n\n  // TODO(zhifengc): Do some cleanup of Params.\n  // The Params struct is passed in to initialize an OpKernelContext,\n  // and must outlive the OpKernelContext.\n  struct Params {\n    ~Params() { delete eigen_gpu_device; }\n\n    // The step being executed.\n    int64_t step_id = 0;\n\n    // Timestamp for the start of graph execution. Used for latency metrics.\n    int64_t start_time_usecs = 0;\n\n    // The deadline for the session to complete by. Empty if unspecified.\n    absl::optional<absl::Time> deadline;\n\n    // The op kernel being computed.\n    OpKernel* op_kernel = nullptr;\n\n    // The device on which the kernel is running.\n    DeviceBase* device = nullptr;\n\n    // The Eigen GPU device wrapper, which may include a per-op\n    // wrappe...\n\n// Status:\nclass Status {\n public:\n  /// Create a success status.\n  Status() {}\n\n  /// \\brief Create a status with the specified error code and msg as a\n  /// human-readable string containing more detailed information.\n  Status(tensorflow::error::Code code, tensorflow::StringPiece msg)\n      : Status(code, msg, {}) {}\n\n  /// \\brief Create a status with the specified error code, msg, and stack trace\n  /// as a human-readable string containing more detailed information.\n#ifndef SWIG\n  Status(tensorflow::error::Code code, tensorflow::StringPiece msg,\n         std::vector<StackFrame>&& stack_trace);\n#endif\n\n  /// Copy the specified status.\n  Status(const Status& s);\n  Status& operator=(const Status& s);\n#ifndef SWIG\n  Status(Status&& s) noexcept;\n  Status& operator=(Status&& s) noexcept;\n#endif  // SWIG\n\n  static Status OK() { return Status(); }\n\n  /// Returns true iff the status indicates success.\n  bool ok() const { return (state_ == nullptr); }\n\n  tensorflow::error::Code code() const {\n    retu...\n\n// OpKernelContext:\ntensorflow.OpKernelContext.OpKernelContext:ANY(tensorflow.OpKernelContext.Params*)\n\n// TensorShape:\nclass TensorShape : public TensorShapeBase<TensorShape> {\n public:\n  using TensorShapeBase<TensorShape>::TensorShapeBase;\n\n  // These factory methods should be used instead of the constructors that take\n  // an array of sizes if calling code cannot validate that the sizes specify a\n  // valid `TensorShape`.\n  // The value in `*out` is valid iff the returned value is `Status::OK`.\n  static Status BuildTensorShape(gtl::ArraySlice<int64_t> dim_sizes,\n                                 TensorShape* out) {\n    return BuildTensorShapeBase(dim_sizes, out);\n  }\n  static Status BuildTensorShape(std::initializer_list<int64_t> dim_sizes,\n                                 TensorShape* out) {\n    return BuildTensorShape(gtl::ArraySlice<int64_t>(dim_sizes), out);\n  }\n  static Status BuildTensorShape(const TensorShapeProto& proto,\n                                 TensorShape* out) {\n    return BuildTensorShapeBase(proto, out);\n  }\n\n  /// Allow a TensorShape to be used as a PartialTensorShape without ...\n\n// Called Methods (top 10):\n// Update from tensorflow/core/platform/status.cc:\nvoid Status::Update(const Status& new_status) { /* <=== tensorflow.Status.Update:void(tensorflow.Status&) */ \n  if (ok()) {\n    *this = new_status;\n  }\n}\n\n// CtxFailure from tensorflow/core/framework/op_kernel.cc:\nvoid OpKernelContext::CtxFailure(const char* file, int line, const Status& s) { /* <=== tensorflow.OpKernelContext.CtxFailure:void(char*,int,tensorflow.Status&) */ \n  VLOG(1) << \"OP_REQUIRES failed at \" << io::Basename(file) << \":\" << line\n          << \" : \" << s;\n  SetStatus(s);\n}\n\n// ok from tensorflow/core/platform/status.h:\n  bool ok() const { return (state_ == nullptr); } /* <=== tensorflow.Status.ok:bool()<const> */ \n\n// CheckNotInComputeAsync from tensorflow/core/framework/op_kernel.cc:\nvoid CheckNotInComputeAsync(OpKernelContext* ctx, /* <=== tensorflow.CheckNotInComputeAsync:void(tensorflow.OpKernelContext*,char*) */ \n                            const char* correct_macro_name) {\n  CHECK_EQ(nullptr, ctx->params_->op_kernel->AsAsync())\n      << \"Use \" << correct_macro_name << \" in AsyncOpKernel implementations.\";\n}\n\n// VLOG from tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/platform/logging.h:\n\n\n// SetStatus from tensorflow/core/framework/op_kernel.cc:\nvoid OpKernelConstruction::SetStatus(const Status& status) { /* <=== tensorflow.OpKernelConstruction.SetStatus:void(tensorflow.Status&) */ \n  status_->Update(status);\n}\n\n// TF_RETURN_IF_ERROR from tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/errors.h:\n\n\n// maybe_initialize_scope_id_set from tensorflow/core/framework/op_kernel.cc:\nvoid OpKernelContext::maybe_initialize_scope_id_set() { /* <=== tensorflow.OpKernelContext.maybe_initialize_scope_id_set:void() */ \n  if (allocated_scope_ids_ == nullptr) {\n    allocated_scope_ids_ = absl::make_unique<std::unordered_set<int32>>();\n  }\n}\n\n// CHECK_EQ from tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/platform/logging.h:\n\n\n// allocate_output from tensorflow/core/framework/op_kernel.cc:\nStatus OpKernelContext::allocate_output(int index, const TensorShape& shape, /* <=== tensorflow.OpKernelContext.allocate_output:tensorflow.Status(int,tensorflow.TensorShape&,tensorflow.Tensor**) */ \n                                        Tensor** tensor) {\n  if (index < 0) {\n    return errors::Internal(\"allocate_output with bad index=\", index,\n                            \" kernel=\", params_->op_kernel->name());\n  }\n  if (index >= num_outputs()) {\n    return errors::Internal(\"allocate_output with bad index=\", index,\n                            \" num_outputs=\", num_outputs(),\n                            \" kernel=\", params_->op_kernel->name());\n  }\n  bool forward_expected =\n      (params_->forward_from_array != nullptr && index >= 0 &&\n       params_->forward_from_array[index] >= 0);\n  if (forward_expected) {\n    return errors::Internal(\n        \"Explicit allocate_output call where input forwarding required.  Try \"\n        \"turning off the ScopedAllocator optimizer.\");\n  }\n  AllocatorAttributes attr = output_alloc_attr(index);\n  return allocate_output(index, shape, tensor, attr);\n}\n"
  },
  {
    "repository": "nf",
    "cve_id": "CVE-2022-25636",
    "cwe_list": [
      "CWE-269"
    ],
    "commit_hash": "b1a5983f56e371046dcf164f90bfaf704d2b89f6",
    "short_hash": "b1a5983f",
    "vulnerableMethods_before": [
      {
        "filename": "nf_tables_offload.c",
        "method_name": "vulnerable_function",
        "raw_code": "struct nft_flow_rule *nft_flow_rule_create(struct net *net,\n\t\t\t\t\t   const struct nft_rule *rule)\n{\n\tstruct nft_offload_ctx *ctx;\n\tstruct nft_flow_rule *flow;\n\tint num_actions = 0, err;\n\tstruct nft_expr *expr;\n\n\texpr = nft_expr_first(rule);\n\twhile (nft_expr_more(rule, expr)) {\n\t\tif (expr->ops->offload_flags & NFT_OFFLOAD_F_ACTION)\n\t\t\tnum_actions++;\n\n\t\texpr = nft_expr_next(expr);\n\t}\n\n\tif (num_actions == 0)\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tflow = nft_flow_rule_alloc(num_actions);\n\tif (!flow)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\texpr = nft_expr_first(rule);\n\n\tctx = kzalloc(sizeof(struct nft_offload_ctx), GFP_KERNEL);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\tctx->net = net;\n\tctx->dep.type = NFT_OFFLOAD_DEP_UNSPEC;\n\n\twhile (nft_expr_more(rule, expr)) {\n\t\tif (!expr->ops->offload) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err_out;\n\t\t}\n\t\terr = expr->ops->offload(ctx, flow, expr);\n\t\tif (err < 0)\n\t\t\tgoto err_out;\n\n\t\texpr = nft_expr_next(expr);\n\t}\n\tnft_flow_rule_transfer_vlan(ctx, flow);\n\n\tflow->proto = ctx->dep.l3num;\n\tkfree(ctx);\n\n\treturn flow;\nerr_out:\n\tkfree(ctx);\n\tnft_flow_rule_destroy(flow);\n\n\treturn ERR_PTR(err);\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "nf_tables_offload.c",
        "method_name": "fixed_function",
        "raw_code": "struct nft_flow_rule *nft_flow_rule_create(struct net *net,\n\t\t\t\t\t   const struct nft_rule *rule)\n{\n\tstruct nft_offload_ctx *ctx;\n\tstruct nft_flow_rule *flow;\n\tint num_actions = 0, err;\n\tstruct nft_expr *expr;\n\n\texpr = nft_expr_first(rule);\n\twhile (nft_expr_more(rule, expr)) {\n\t\tif (expr->ops->offload_action &&\n\t\t    expr->ops->offload_action(expr))\n\t\t\tnum_actions++;\n\n\t\texpr = nft_expr_next(expr);\n\t}\n\n\tif (num_actions == 0)\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tflow = nft_flow_rule_alloc(num_actions);\n\tif (!flow)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\texpr = nft_expr_first(rule);\n\n\tctx = kzalloc(sizeof(struct nft_offload_ctx), GFP_KERNEL);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\tctx->net = net;\n\tctx->dep.type = NFT_OFFLOAD_DEP_UNSPEC;\n\n\twhile (nft_expr_more(rule, expr)) {\n\t\tif (!expr->ops->offload) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err_out;\n\t\t}\n\t\terr = expr->ops->offload(ctx, flow, expr);\n\t\tif (err < 0)\n\t\t\tgoto err_out;\n\n\t\texpr = nft_expr_next(expr);\n\t}\n\tnft_flow_rule_transfer_vlan(ctx, flow);\n\n\tflow->proto = ctx->dep.l3num;\n\tkfree(ctx);\n\n\treturn flow;\nerr_out:\n\tkfree(ctx);\n\tnft_flow_rule_destroy(flow);\n\n\treturn ERR_PTR(err);\n}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "vim",
    "cve_id": "CVE-2022-1769",
    "cwe_list": [
      "CWE-703"
    ],
    "commit_hash": "4748c4bd64610cf943a431d215bb1aad51f8d0b4",
    "short_hash": "4748c4bd",
    "vulnerableMethods_before": [
      {
        "filename": "scriptfile.c",
        "method_name": "vulnerable_function",
        "raw_code": "get_one_sourceline(source_cookie_T *sp)\n{\n    garray_T\t\tga;\n    int\t\t\tlen;\n    int\t\t\tc;\n    char_u\t\t*buf;\n#ifdef USE_CRNL\n    int\t\t\thas_cr;\t\t// CR-LF found\n#endif\n    int\t\t\thave_read = FALSE;\n\n    // use a growarray to store the sourced line\n    ga_init2(&ga, 1, 250);\n\n    // Loop until there is a finished line (or end-of-file).\n    ++sp->sourcing_lnum;\n    for (;;)\n    {\n\t// make room to read at least 120 (more) characters\n\tif (ga_grow(&ga, 120) == FAIL)\n\t    break;\n\tif (sp->source_from_buf)\n\t{\n\t    if (sp->buf_lnum >= sp->buflines.ga_len)\n\t\tbreak;\t\t    // all the lines are processed\n\t    ga_concat(&ga, ((char_u **)sp->buflines.ga_data)[sp->buf_lnum]);\n\t    sp->buf_lnum++;\n\t    if (ga_grow(&ga, 1) == FAIL)\n\t\tbreak;\n\t    buf = (char_u *)ga.ga_data;\n\t    buf[ga.ga_len++] = NUL;\n\t}\n\telse\n\t{\n\t    buf = (char_u *)ga.ga_data;\n\t    if (fgets((char *)buf + ga.ga_len, ga.ga_maxlen - ga.ga_len,\n\t\t\tsp->fp) == NULL)\n\t\tbreak;\n\t}\n\tlen = ga.ga_len + (int)STRLEN(buf + ga.ga_len);\n#ifdef USE_CRNL\n\t// Ignore a trailing CTRL-Z, when in Dos mode.\tOnly recognize the\n\t// CTRL-Z by its own, or after a NL.\n\tif (\t   (len == 1 || (len >= 2 && buf[len - 2] == '\\n'))\n\t\t&& sp->fileformat == EOL_DOS\n\t\t&& buf[len - 1] == Ctrl_Z)\n\t{\n\t    buf[len - 1] = NUL;\n\t    break;\n\t}\n#endif\n\n\thave_read = TRUE;\n\tga.ga_len = len;\n\n\t// If the line was longer than the buffer, read more.\n\tif (ga.ga_maxlen - ga.ga_len == 1 && buf[len - 1] != '\\n')\n\t    continue;\n\n\tif (len >= 1 && buf[len - 1] == '\\n')\t// remove trailing NL\n\t{\n#ifdef USE_CRNL\n\t    has_cr = (len >= 2 && buf[len - 2] == '\\r');\n\t    if (sp->fileformat == EOL_UNKNOWN)\n\t    {\n\t\tif (has_cr)\n\t\t    sp->fileformat = EOL_DOS;\n\t\telse\n\t\t    sp->fileformat = EOL_UNIX;\n\t    }\n\n\t    if (sp->fileformat == EOL_DOS)\n\t    {\n\t\tif (has_cr)\t    // replace trailing CR\n\t\t{\n\t\t    buf[len - 2] = '\\n';\n\t\t    --len;\n\t\t    --ga.ga_len;\n\t\t}\n\t\telse\t    // lines like \":map xx yy^M\" will have failed\n\t\t{\n\t\t    if (!sp->error)\n\t\t    {\n\t\t\tmsg_source(HL_ATTR(HLF_W));\n\t\t\temsg(_(\"W15: Warning: Wrong line separator, ^M may be missing\"));\n\t\t    }\n\t\t    sp->error = TRUE;\n\t\t    sp->fileformat = EOL_UNIX;\n\t\t}\n\t    }\n#endif\n\t    // The '\\n' is escaped if there is an odd number of ^V's just\n\t    // before it, first set \"c\" just before the 'V's and then check\n\t    // len&c parities (is faster than ((len-c)%2 == 0)) -- Acevedo\n\t    for (c = len - 2; c >= 0 && buf[c] == Ctrl_V; c--)\n\t\t;\n\t    if ((len & 1) != (c & 1))\t// escaped NL, read more\n\t    {\n\t\t++sp->sourcing_lnum;\n\t\tcontinue;\n\t    }\n\n\t    buf[len - 1] = NUL;\t\t// remove the NL\n\t}\n\n\t// Check for ^C here now and then, so recursive :so can be broken.\n\tline_breakcheck();\n\tbreak;\n    }\n\n    if (have_read)\n\treturn (char_u *)ga.ga_data;\n\n    vim_free(ga.ga_data);\n    return NULL;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "scriptfile.c",
        "method_name": "fixed_function",
        "raw_code": "get_one_sourceline(source_cookie_T *sp)\n{\n    garray_T\t\tga;\n    int\t\t\tlen;\n    int\t\t\tc;\n    char_u\t\t*buf;\n#ifdef USE_CRNL\n    int\t\t\thas_cr;\t\t// CR-LF found\n#endif\n    int\t\t\thave_read = FALSE;\n\n    // use a growarray to store the sourced line\n    ga_init2(&ga, 1, 250);\n\n    // Loop until there is a finished line (or end-of-file).\n    ++sp->sourcing_lnum;\n    for (;;)\n    {\n\t// make room to read at least 120 (more) characters\n\tif (ga_grow(&ga, 120) == FAIL)\n\t    break;\n\tif (sp->source_from_buf)\n\t{\n\t    if (sp->buf_lnum >= sp->buflines.ga_len)\n\t\tbreak;\t\t    // all the lines are processed\n\t    ga_concat(&ga, ((char_u **)sp->buflines.ga_data)[sp->buf_lnum]);\n\t    sp->buf_lnum++;\n\t    if (ga_grow(&ga, 1) == FAIL)\n\t\tbreak;\n\t    buf = (char_u *)ga.ga_data;\n\t    buf[ga.ga_len++] = NUL;\n\t    len = ga.ga_len;\n\t}\n\telse\n\t{\n\t    buf = (char_u *)ga.ga_data;\n\t    if (fgets((char *)buf + ga.ga_len, ga.ga_maxlen - ga.ga_len,\n\t\t\tsp->fp) == NULL)\n\t\tbreak;\n\t    len = ga.ga_len + (int)STRLEN(buf + ga.ga_len);\n\t}\n#ifdef USE_CRNL\n\t// Ignore a trailing CTRL-Z, when in Dos mode.\tOnly recognize the\n\t// CTRL-Z by its own, or after a NL.\n\tif (\t   (len == 1 || (len >= 2 && buf[len - 2] == '\\n'))\n\t\t&& sp->fileformat == EOL_DOS\n\t\t&& buf[len - 1] == Ctrl_Z)\n\t{\n\t    buf[len - 1] = NUL;\n\t    break;\n\t}\n#endif\n\n\thave_read = TRUE;\n\tga.ga_len = len;\n\n\t// If the line was longer than the buffer, read more.\n\tif (ga.ga_maxlen - ga.ga_len == 1 && buf[len - 1] != '\\n')\n\t    continue;\n\n\tif (len >= 1 && buf[len - 1] == '\\n')\t// remove trailing NL\n\t{\n#ifdef USE_CRNL\n\t    has_cr = (len >= 2 && buf[len - 2] == '\\r');\n\t    if (sp->fileformat == EOL_UNKNOWN)\n\t    {\n\t\tif (has_cr)\n\t\t    sp->fileformat = EOL_DOS;\n\t\telse\n\t\t    sp->fileformat = EOL_UNIX;\n\t    }\n\n\t    if (sp->fileformat == EOL_DOS)\n\t    {\n\t\tif (has_cr)\t    // replace trailing CR\n\t\t{\n\t\t    buf[len - 2] = '\\n';\n\t\t    --len;\n\t\t    --ga.ga_len;\n\t\t}\n\t\telse\t    // lines like \":map xx yy^M\" will have failed\n\t\t{\n\t\t    if (!sp->error)\n\t\t    {\n\t\t\tmsg_source(HL_ATTR(HLF_W));\n\t\t\temsg(_(\"W15: Warning: Wrong line separator, ^M may be missing\"));\n\t\t    }\n\t\t    sp->error = TRUE;\n\t\t    sp->fileformat = EOL_UNIX;\n\t\t}\n\t    }\n#endif\n\t    // The '\\n' is escaped if there is an odd number of ^V's just\n\t    // before it, first set \"c\" just before the 'V's and then check\n\t    // len&c parities (is faster than ((len-c)%2 == 0)) -- Acevedo\n\t    for (c = len - 2; c >= 0 && buf[c] == Ctrl_V; c--)\n\t\t;\n\t    if ((len & 1) != (c & 1))\t// escaped NL, read more\n\t    {\n\t\t++sp->sourcing_lnum;\n\t\tcontinue;\n\t    }\n\n\t    buf[len - 1] = NUL;\t\t// remove the NL\n\t}\n\n\t// Check for ^C here now and then, so recursive :so can be broken.\n\tline_breakcheck();\n\tbreak;\n    }\n\n    if (have_read)\n\treturn (char_u *)ga.ga_data;\n\n    vim_free(ga.ga_data);\n    return NULL;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"vim.h\"\n\n// Type Definitions:\n// garray_T:\ntypedef struct growarray\n{\n    int\t    ga_len;\t\t    // current number of items used\n    int\t    ga_maxlen;\t\t    // maximum number of items possible\n    int\t    ga_itemsize;\t    // sizeof(item)\n    int\t    ga_growsize;\t    // number of items to grow each time\n    void    *ga_data;\t\t    // pointer to the first item\n} garray_T;\n\n// source_cookie_T:\ntypedef struct {\n    FILE\t*fp;\t\t// opened file for sourcing\n    char_u\t*nextline;\t// if not NULL: line that was read ahead\n    linenr_T\tsourcing_lnum;\t// line number of the source file\n    int\t\tfinished;\t// \":finish\" used\n    int\t\tsource_from_buf;// TRUE if sourcing from current buffer\n    int\t\tbuf_lnum;\t// line number in the current buffer\n    garray_T\tbuflines;\t// lines in the current buffer\n#ifdef USE_CRNL\n    int\t\tfileformat;\t// EOL_UNKNOWN, EOL_UNIX or EOL_DOS\n    int\t\terror;\t\t// TRUE if LF found after CR-LF\n#endif\n#ifdef FEAT_EVAL\n    linenr_T\tbreakpoint;\t// next line with breakpoint or zero\n    char_u\t*fname;\t\t// name of sourced file\n    int\t\tdbg_tick;\t// debug_tick when breakpoint was set\n    int\t\tlevel;\t\t// top nesting level of sourced file\n#endif\n    vimconv_T\tconv;\t\t// type of conversion\n}\n\n// char_u:\ntypedef unsigned char\tchar_u;\n\n// Called Methods (top 10):\n// FALSE from src/vim.h:\n# define FALSE\t0\t    // note: this is an int, not a long! /* <=== src/vim.h:1475:1475:FALSE:0 */ \n\n// FAIL from src/vim.h:\n#define FAIL\t\t\t0 /* <=== src/vim.h:723:723:FAIL:0 */ \n\n// Ctrl_V from src/ascii.h:\n#define Ctrl_V\t\t22 /* <=== src/ascii.h:63:63:Ctrl_V:0 */ \n\n// ga_grow_inner from src/alloc.c:\n    int /* <=== ga_grow_inner */ \nga_grow_inner(garray_T *gap, int n)\n{\n    size_t\told_len;\n    size_t\tnew_len;\n    char_u\t*pp;\n\n    if (n < gap->ga_growsize)\n\tn = gap->ga_growsize;\n\n    // A linear growth is very inefficient when the array grows big.  This\n    // is a compromise between allocating memory that won't be used and too\n    // many copy operations. A factor of 1.5 seems reasonable.\n    if (n < gap->ga_len / 2)\n\tn = gap->ga_len / 2;\n\n    new_len = (size_t)gap->ga_itemsize * (gap->ga_len + n);\n    pp = vim_realloc(gap->ga_data, new_len);\n    if (pp == NULL)\n\treturn FAIL;\n    old_len = (size_t)gap->ga_itemsize * gap->ga_maxlen;\n    vim_memset(pp + old_len, 0, new_len - old_len);\n    gap->ga_maxlen = gap->ga_len + n;\n    gap->ga_data = pp;\n    return OK;\n}\n\n// BREAKCHECK_SKIP from src/misc1.c:\n# define BREAKCHECK_SKIP 1000 /* <=== src/misc1.c:2228:2228:BREAKCHECK_SKIP:0 */ \n\n// ga_concat from src/alloc.c:\n    void /* <=== ga_concat */ \nga_concat(garray_T *gap, char_u *s)\n{\n    int    len;\n\n    if (s == NULL || *s == NUL)\n\treturn;\n    len = (int)STRLEN(s);\n    if (ga_grow(gap, len) == OK)\n    {\n\tmch_memmove((char *)gap->ga_data + gap->ga_len, s, (size_t)len);\n\tgap->ga_len += len;\n    }\n}\n\n// STRLEN from src/vim.h:\n#define STRLEN(s)\t    strlen((char *)(s)) /* <=== src/vim.h:1641:1641:STRLEN:1 */ \n\n// TRUE from src/vim.h:\n# define TRUE\t1 /* <=== src/vim.h:1476:1476:TRUE:0 */ \n\n// line_breakcheck from src/misc1.c:\n    void /* <=== line_breakcheck */ \nline_breakcheck(void)\n{\n    if (++breakcheck_count >= BREAKCHECK_SKIP)\n    {\n\tbreakcheck_count = 0;\n\tui_breakcheck();\n    }\n}\n\n// mch_memmove from src/vim.h:\n# define mch_memmove(to, from, len) memmove((char*)(to), (char*)(from), (size_t)(len)) /* <=== src/vim.h:1764:1764:mch_memmove:3 */ \n"
  },
  {
    "repository": "weechat",
    "cve_id": "CVE-2020-9759",
    "cwe_list": [
      "CWE-476"
    ],
    "commit_hash": "9904cb6d2eb40f679d8ff6557c22d53a3e3dc75a",
    "short_hash": "9904cb6d",
    "vulnerableMethods_before": [
      {
        "filename": "irc-protocol.c",
        "method_name": "vulnerable_function",
        "raw_code": "IRC_PROTOCOL_CALLBACK(352)\n{\n    char *pos_attr, *pos_hopcount, *pos_realname, *str_host;\n    int arg_start, length;\n    struct t_irc_channel *ptr_channel;\n    struct t_irc_nick *ptr_nick;\n\n    IRC_PROTOCOL_MIN_ARGS(5);\n\n    /* silently ignore malformed 352 message (missing infos) */\n    if (argc < 8)\n        return WEECHAT_RC_OK;\n\n    pos_attr = NULL;\n    pos_hopcount = NULL;\n    pos_realname = NULL;\n\n    if (argc > 8)\n    {\n        arg_start = (strcmp (argv[8], \"*\") == 0) ? 9 : 8;\n        if (argv[arg_start][0] == ':')\n        {\n            pos_attr = NULL;\n            pos_hopcount = (argc > arg_start) ? argv[arg_start] + 1 : NULL;\n            pos_realname = (argc > arg_start + 1) ? argv_eol[arg_start + 1] : NULL;\n        }\n        else\n        {\n            pos_attr = argv[arg_start];\n            pos_hopcount = (argc > arg_start + 1) ? argv[arg_start + 1] + 1 : NULL;\n            pos_realname = (argc > arg_start + 2) ? argv_eol[arg_start + 2] : NULL;\n        }\n    }\n\n    ptr_channel = irc_channel_search (server, argv[3]);\n    ptr_nick = (ptr_channel) ?\n        irc_nick_search (server, ptr_channel, argv[7]) : NULL;\n\n    /* update host in nick */\n    if (ptr_nick)\n    {\n        length = strlen (argv[4]) + 1 + strlen (argv[5]) + 1;\n        str_host = malloc (length);\n        if (str_host)\n        {\n            snprintf (str_host, length, \"%s@%s\", argv[4], argv[5]);\n            irc_nick_set_host (ptr_nick, str_host);\n            free (str_host);\n        }\n    }\n\n    /* update away flag in nick */\n    if (ptr_channel && ptr_nick && pos_attr)\n    {\n        irc_nick_set_away (server, ptr_channel, ptr_nick,\n                           (pos_attr[0] == 'G') ? 1 : 0);\n    }\n\n    /* update realname in nick */\n    if (ptr_channel && ptr_nick && pos_realname)\n    {\n        if (ptr_nick->realname)\n            free (ptr_nick->realname);\n        if (pos_realname &&\n            weechat_hashtable_has_key (server->cap_list, \"extended-join\"))\n        {\n            ptr_nick->realname = strdup (pos_realname);\n        }\n        else\n        {\n            ptr_nick->realname = NULL;\n        }\n    }\n\n    /* display output of who (manual who from user) */\n    if (!ptr_channel || (ptr_channel->checking_whox <= 0))\n    {\n        weechat_printf_date_tags (\n            irc_msgbuffer_get_target_buffer (\n                server, NULL, command, \"who\", NULL),\n            date,\n            irc_protocol_tags (command, \"irc_numeric\", NULL, NULL),\n            \"%s%s[%s%s%s] %s%s %s(%s%s@%s%s)%s %s%s%s%s(%s)\",\n            weechat_prefix (\"network\"),\n            IRC_COLOR_CHAT_DELIMITERS,\n            IRC_COLOR_CHAT_CHANNEL,\n            argv[3],\n            IRC_COLOR_CHAT_DELIMITERS,\n            irc_nick_color_for_msg (server, 1, NULL, argv[7]),\n            argv[7],\n            IRC_COLOR_CHAT_DELIMITERS,\n            IRC_COLOR_CHAT_HOST,\n            argv[4],\n            argv[5],\n            IRC_COLOR_CHAT_DELIMITERS,\n            IRC_COLOR_RESET,\n            (pos_attr) ? pos_attr : \"\",\n            (pos_attr) ? \" \" : \"\",\n            (pos_hopcount) ? pos_hopcount : \"\",\n            (pos_hopcount) ? \" \" : \"\",\n            (pos_realname) ? pos_realname : \"\");\n    }\n\n    return WEECHAT_RC_OK;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "irc-protocol.c",
        "method_name": "fixed_function",
        "raw_code": "IRC_PROTOCOL_CALLBACK(352)\n{\n    char *pos_attr, *pos_hopcount, *pos_realname, *str_host;\n    int arg_start, length;\n    struct t_irc_channel *ptr_channel;\n    struct t_irc_nick *ptr_nick;\n\n    IRC_PROTOCOL_MIN_ARGS(5);\n\n    /* silently ignore malformed 352 message (missing infos) */\n    if (argc < 8)\n        return WEECHAT_RC_OK;\n\n    pos_attr = NULL;\n    pos_hopcount = NULL;\n    pos_realname = NULL;\n\n    if (argc > 8)\n    {\n        arg_start = ((argc > 9) && (strcmp (argv[8], \"*\") == 0)) ? 9 : 8;\n        if (argv[arg_start][0] == ':')\n        {\n            pos_attr = NULL;\n            pos_hopcount = (argc > arg_start) ? argv[arg_start] + 1 : NULL;\n            pos_realname = (argc > arg_start + 1) ? argv_eol[arg_start + 1] : NULL;\n        }\n        else\n        {\n            pos_attr = argv[arg_start];\n            pos_hopcount = (argc > arg_start + 1) ? argv[arg_start + 1] + 1 : NULL;\n            pos_realname = (argc > arg_start + 2) ? argv_eol[arg_start + 2] : NULL;\n        }\n    }\n\n    ptr_channel = irc_channel_search (server, argv[3]);\n    ptr_nick = (ptr_channel) ?\n        irc_nick_search (server, ptr_channel, argv[7]) : NULL;\n\n    /* update host in nick */\n    if (ptr_nick)\n    {\n        length = strlen (argv[4]) + 1 + strlen (argv[5]) + 1;\n        str_host = malloc (length);\n        if (str_host)\n        {\n            snprintf (str_host, length, \"%s@%s\", argv[4], argv[5]);\n            irc_nick_set_host (ptr_nick, str_host);\n            free (str_host);\n        }\n    }\n\n    /* update away flag in nick */\n    if (ptr_channel && ptr_nick && pos_attr)\n    {\n        irc_nick_set_away (server, ptr_channel, ptr_nick,\n                           (pos_attr[0] == 'G') ? 1 : 0);\n    }\n\n    /* update realname in nick */\n    if (ptr_channel && ptr_nick && pos_realname)\n    {\n        if (ptr_nick->realname)\n            free (ptr_nick->realname);\n        if (pos_realname &&\n            weechat_hashtable_has_key (server->cap_list, \"extended-join\"))\n        {\n            ptr_nick->realname = strdup (pos_realname);\n        }\n        else\n        {\n            ptr_nick->realname = NULL;\n        }\n    }\n\n    /* display output of who (manual who from user) */\n    if (!ptr_channel || (ptr_channel->checking_whox <= 0))\n    {\n        weechat_printf_date_tags (\n            irc_msgbuffer_get_target_buffer (\n                server, NULL, command, \"who\", NULL),\n            date,\n            irc_protocol_tags (command, \"irc_numeric\", NULL, NULL),\n            \"%s%s[%s%s%s] %s%s %s(%s%s@%s%s)%s %s%s%s%s(%s)\",\n            weechat_prefix (\"network\"),\n            IRC_COLOR_CHAT_DELIMITERS,\n            IRC_COLOR_CHAT_CHANNEL,\n            argv[3],\n            IRC_COLOR_CHAT_DELIMITERS,\n            irc_nick_color_for_msg (server, 1, NULL, argv[7]),\n            argv[7],\n            IRC_COLOR_CHAT_DELIMITERS,\n            IRC_COLOR_CHAT_HOST,\n            argv[4],\n            argv[5],\n            IRC_COLOR_CHAT_DELIMITERS,\n            IRC_COLOR_RESET,\n            (pos_attr) ? pos_attr : \"\",\n            (pos_attr) ? \" \" : \"\",\n            (pos_hopcount) ? pos_hopcount : \"\",\n            (pos_hopcount) ? \" \" : \"\",\n            (pos_realname) ? pos_realname : \"\");\n    }\n\n    return WEECHAT_RC_OK;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <time.h>\n#include \"irc-server.h\"\n#include \"irc-notify.h\"\n#include \"irc-ignore.h\"\n#include <sys/time.h>\n#include \"irc-color.h\"\n#include \"irc-bar-item.h\"\n#include \"irc-command.h\"\n#include \"irc-config.h\"\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include \"irc-msgbuffer.h\"\n#include \"irc-message.h\"\n#include \"irc-modelist.h\"\n#include \"irc-mode.h\"\n#include <stdlib.h>\n#include \"irc-nick.h\"\n#include \"irc-buffer.h\"\n#include \"irc.h\"\n#include \"irc-protocol.h\"\n#include \"irc-channel.h\"\n#include \"../weechat-plugin.h\"\n#include \"irc-sasl.h\"\n#include \"irc-ctcp.h\"\n"
  },
  {
    "repository": "ImageMagick",
    "cve_id": "CVE-2022-32546",
    "cwe_list": [
      "CWE-190"
    ],
    "commit_hash": "f221ea0fa3171f0f4fdf74ac9d81b203b9534c23",
    "short_hash": "f221ea0f",
    "vulnerableMethods_before": [
      {
        "filename": "pcl.c",
        "method_name": "vulnerable_function",
        "raw_code": "static Image *ReadPCLImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define CropBox  \"CropBox\"\n#define DeviceCMYK  \"DeviceCMYK\"\n#define MediaBox  \"MediaBox\"\n#define RenderPCLText  \"  Rendering PCL...  \"\n\n  char\n    command[MagickPathExtent],\n    *density,\n    filename[MagickPathExtent],\n    geometry[MagickPathExtent],\n    *options,\n    input_filename[MagickPathExtent];\n\n  const DelegateInfo\n    *delegate_info;\n\n  Image\n    *image,\n    *next_image;\n\n  ImageInfo\n    *read_info;\n\n  MagickBooleanType\n    cmyk,\n    status;\n\n  PointInfo\n    delta;\n\n  RectangleInfo\n    bounding_box,\n    page;\n\n  char\n    *p;\n\n  ssize_t\n    c;\n\n  SegmentInfo\n    bounds;\n\n  size_t\n    height,\n    width;\n\n  ssize_t\n    count;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  /*\n    Open image file.\n  */\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  status=AcquireUniqueSymbolicLink(image_info->filename,input_filename);\n  if (status == MagickFalse)\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        image_info->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Set the page density.\n  */\n  delta.x=DefaultResolution;\n  delta.y=DefaultResolution;\n  if ((image->resolution.x == 0.0) || (image->resolution.y == 0.0))\n    {\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      flags=ParseGeometry(PSDensityGeometry,&geometry_info);\n      if ((flags & RhoValue) != 0)\n        image->resolution.x=geometry_info.rho;\n      image->resolution.y=image->resolution.x;\n      if ((flags & SigmaValue) != 0)\n        image->resolution.y=geometry_info.sigma;\n    }\n  /*\n    Determine page geometry from the PCL media box.\n  */\n  cmyk=image->colorspace == CMYKColorspace ? MagickTrue : MagickFalse;\n  count=0;\n  (void) memset(&bounding_box,0,sizeof(bounding_box));\n  (void) memset(&bounds,0,sizeof(bounds));\n  (void) memset(&page,0,sizeof(page));\n  (void) memset(command,0,sizeof(command));\n  p=command;\n  for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))\n  {\n    if (image_info->page != (char *) NULL)\n      continue;\n    /*\n      Note PCL elements.\n    */\n    *p++=(char) c;\n    if ((c != (int) '/') && (c != '\\n') &&\n        ((size_t) (p-command) < (MagickPathExtent-1)))\n      continue;\n    *p='\\0';\n    p=command;\n    /*\n      Is this a CMYK document?\n    */\n    if (LocaleNCompare(DeviceCMYK,command,strlen(DeviceCMYK)) == 0)\n      cmyk=MagickTrue;\n    if (LocaleNCompare(CropBox,command,strlen(CropBox)) == 0)\n      {\n        /*\n          Note region defined by crop box.\n        */\n        count=(ssize_t) sscanf(command,\"CropBox [%lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        if (count != 4)\n          count=(ssize_t) sscanf(command,\"CropBox[%lf %lf %lf %lf\",\n            &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n      }\n    if (LocaleNCompare(MediaBox,command,strlen(MediaBox)) == 0)\n      {\n        /*\n          Note region defined by media box.\n        */\n        count=(ssize_t) sscanf(command,\"MediaBox [%lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        if (count != 4)\n          count=(ssize_t) sscanf(command,\"MediaBox[%lf %lf %lf %lf\",\n            &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n      }\n    if (count != 4)\n      continue;\n    /*\n      Set PCL render geometry.\n    */\n    width=(size_t) floor(bounds.x2-bounds.x1+0.5);\n    height=(size_t) floor(bounds.y2-bounds.y1+0.5);\n    if (width > page.width)\n      page.width=width;\n    if (height > page.height)\n      page.height=height;\n  }\n  (void) CloseBlob(image);\n  /*\n    Render PCL with the GhostPCL delegate.\n  */\n  if ((page.width == 0) || (page.height == 0))\n    (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n  (void) FormatLocaleString(geometry,MagickPathExtent,\"%.20gx%.20g\",(double)\n    page.width,(double) page.height);\n  if (image_info->monochrome != MagickFalse)\n    delegate_info=GetDelegateInfo(\"pcl:mono\",(char *) NULL,exception);\n  else\n     if (cmyk != MagickFalse)\n       delegate_info=GetDelegateInfo(\"pcl:cmyk\",(char *) NULL,exception);\n     else\n       delegate_info=GetDelegateInfo(\"pcl:color\",(char *) NULL,exception);\n  if (delegate_info == (const DelegateInfo *) NULL)\n    {\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  if ((page.width == 0) || (page.height == 0))\n    (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n  density=AcquireString(\"\");\n  options=AcquireString(\"\");\n  (void) FormatLocaleString(density,MagickPathExtent,\"%gx%g\",\n    image->resolution.x,image->resolution.y);\n  if (image_info->ping != MagickFalse)\n    (void) FormatLocaleString(density,MagickPathExtent,\"2.0x2.0\");\n  page.width=(size_t) floor(page.width*image->resolution.x/delta.x+0.5);\n  page.height=(size_t) floor(page.height*image->resolution.y/delta.y+0.5);\n  (void) FormatLocaleString(options,MagickPathExtent,\"-g%.20gx%.20g \",(double)\n    page.width,(double) page.height);\n  image=DestroyImage(image);\n  read_info=CloneImageInfo(image_info);\n  *read_info->magick='\\0';\n  if (read_info->number_scenes != 0)\n    {\n      if (read_info->number_scenes != 1)\n        (void) FormatLocaleString(options,MagickPathExtent,\"-dLastPage=%.20g\",\n          (double) (read_info->scene+read_info->number_scenes));\n      else\n        (void) FormatLocaleString(options,MagickPathExtent,\n          \"-dFirstPage=%.20g -dLastPage=%.20g\",(double) read_info->scene+1,\n          (double) (read_info->scene+read_info->number_scenes));\n      read_info->number_scenes=0;\n      if (read_info->scenes != (char *) NULL)\n        *read_info->scenes='\\0';\n    }\n  (void) CopyMagickString(filename,read_info->filename,MagickPathExtent);\n  (void) AcquireUniqueFilename(read_info->filename);\n  (void) FormatLocaleString(command,MagickPathExtent,\n    GetDelegateCommands(delegate_info),\n    read_info->antialias != MagickFalse ? 4 : 1,\n    read_info->antialias != MagickFalse ? 4 : 1,density,options,\n    read_info->filename,input_filename);\n  options=DestroyString(options);\n  density=DestroyString(density);\n  status=ExternalDelegateCommand(MagickFalse,read_info->verbose,command,\n    (char *) NULL,exception) != 0 ? MagickTrue : MagickFalse;\n  image=ReadImage(read_info,exception);\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  (void) RelinquishUniqueFileResource(input_filename);\n  read_info=DestroyImageInfo(read_info);\n  if (image == (Image *) NULL)\n    ThrowReaderException(DelegateError,\"PCLDelegateFailed\");\n  if (LocaleCompare(image->magick,\"BMP\") == 0)\n    {\n      Image\n        *cmyk_image;\n\n      cmyk_image=ConsolidateCMYKImages(image,exception);\n      if (cmyk_image != (Image *) NULL)\n        {\n          image=DestroyImageList(image);\n          image=cmyk_image;\n        }\n    }\n  do\n  {\n    (void) CopyMagickString(image->filename,filename,MagickPathExtent);\n    image->page=page;\n    if (image_info->ping != MagickFalse)\n      {\n        image->magick_columns*=image->resolution.x/2.0;\n        image->magick_rows*=image->resolution.y/2.0;\n        image->columns*=image->resolution.x/2.0;\n        image->rows*=image->resolution.y/2.0;\n      }\n    next_image=SyncNextImageInList(image);\n    if (next_image != (Image *) NULL)\n      image=next_image;\n  } while (next_image != (Image *) NULL);\n  return(GetFirstImageInList(image));\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "pcl.c",
        "method_name": "fixed_function",
        "raw_code": "static Image *ReadPCLImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define CropBox  \"CropBox\"\n#define DeviceCMYK  \"DeviceCMYK\"\n#define MediaBox  \"MediaBox\"\n#define RenderPCLText  \"  Rendering PCL...  \"\n\n  char\n    command[MagickPathExtent],\n    *density,\n    filename[MagickPathExtent],\n    geometry[MagickPathExtent],\n    *options,\n    input_filename[MagickPathExtent];\n\n  const DelegateInfo\n    *delegate_info;\n\n  Image\n    *image,\n    *next_image;\n\n  ImageInfo\n    *read_info;\n\n  MagickBooleanType\n    cmyk,\n    status;\n\n  PointInfo\n    delta;\n\n  RectangleInfo\n    bounding_box,\n    page;\n\n  char\n    *p;\n\n  ssize_t\n    c;\n\n  SegmentInfo\n    bounds;\n\n  size_t\n    height,\n    width;\n\n  ssize_t\n    count;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  /*\n    Open image file.\n  */\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  status=AcquireUniqueSymbolicLink(image_info->filename,input_filename);\n  if (status == MagickFalse)\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        image_info->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Set the page density.\n  */\n  delta.x=DefaultResolution;\n  delta.y=DefaultResolution;\n  if ((image->resolution.x == 0.0) || (image->resolution.y == 0.0))\n    {\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      flags=ParseGeometry(PSDensityGeometry,&geometry_info);\n      if ((flags & RhoValue) != 0)\n        image->resolution.x=geometry_info.rho;\n      image->resolution.y=image->resolution.x;\n      if ((flags & SigmaValue) != 0)\n        image->resolution.y=geometry_info.sigma;\n    }\n  /*\n    Determine page geometry from the PCL media box.\n  */\n  cmyk=image->colorspace == CMYKColorspace ? MagickTrue : MagickFalse;\n  count=0;\n  (void) memset(&bounding_box,0,sizeof(bounding_box));\n  (void) memset(&bounds,0,sizeof(bounds));\n  (void) memset(&page,0,sizeof(page));\n  (void) memset(command,0,sizeof(command));\n  p=command;\n  for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))\n  {\n    if (image_info->page != (char *) NULL)\n      continue;\n    /*\n      Note PCL elements.\n    */\n    *p++=(char) c;\n    if ((c != (int) '/') && (c != '\\n') &&\n        ((size_t) (p-command) < (MagickPathExtent-1)))\n      continue;\n    *p='\\0';\n    p=command;\n    /*\n      Is this a CMYK document?\n    */\n    if (LocaleNCompare(DeviceCMYK,command,strlen(DeviceCMYK)) == 0)\n      cmyk=MagickTrue;\n    if (LocaleNCompare(CropBox,command,strlen(CropBox)) == 0)\n      {\n        /*\n          Note region defined by crop box.\n        */\n        count=(ssize_t) sscanf(command,\"CropBox [%lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        if (count != 4)\n          count=(ssize_t) sscanf(command,\"CropBox[%lf %lf %lf %lf\",\n            &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n      }\n    if (LocaleNCompare(MediaBox,command,strlen(MediaBox)) == 0)\n      {\n        /*\n          Note region defined by media box.\n        */\n        count=(ssize_t) sscanf(command,\"MediaBox [%lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        if (count != 4)\n          count=(ssize_t) sscanf(command,\"MediaBox[%lf %lf %lf %lf\",\n            &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n      }\n    if (count != 4)\n      continue;\n    /*\n      Set PCL render geometry.\n    */\n    width=(size_t)CastDoubleToLong(floor(bounds.x2-bounds.x1+0.5));\n    height=(size_t)CastDoubleToLong(floor(bounds.y2-bounds.y1+0.5));\n    if (width > page.width)\n      page.width=width;\n    if (height > page.height)\n      page.height=height;\n  }\n  (void) CloseBlob(image);\n  /*\n    Render PCL with the GhostPCL delegate.\n  */\n  if ((page.width == 0) || (page.height == 0))\n    (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n  (void) FormatLocaleString(geometry,MagickPathExtent,\"%.20gx%.20g\",(double)\n    page.width,(double) page.height);\n  if (image_info->monochrome != MagickFalse)\n    delegate_info=GetDelegateInfo(\"pcl:mono\",(char *) NULL,exception);\n  else\n     if (cmyk != MagickFalse)\n       delegate_info=GetDelegateInfo(\"pcl:cmyk\",(char *) NULL,exception);\n     else\n       delegate_info=GetDelegateInfo(\"pcl:color\",(char *) NULL,exception);\n  if (delegate_info == (const DelegateInfo *) NULL)\n    {\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  if ((page.width == 0) || (page.height == 0))\n    (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n  density=AcquireString(\"\");\n  options=AcquireString(\"\");\n  (void) FormatLocaleString(density,MagickPathExtent,\"%gx%g\",\n    image->resolution.x,image->resolution.y);\n  if (image_info->ping != MagickFalse)\n    (void) FormatLocaleString(density,MagickPathExtent,\"2.0x2.0\");\n  page.width=(size_t) floor(page.width*image->resolution.x/delta.x+0.5);\n  page.height=(size_t) floor(page.height*image->resolution.y/delta.y+0.5);\n  (void) FormatLocaleString(options,MagickPathExtent,\"-g%.20gx%.20g \",(double)\n    page.width,(double) page.height);\n  image=DestroyImage(image);\n  read_info=CloneImageInfo(image_info);\n  *read_info->magick='\\0';\n  if (read_info->number_scenes != 0)\n    {\n      if (read_info->number_scenes != 1)\n        (void) FormatLocaleString(options,MagickPathExtent,\"-dLastPage=%.20g\",\n          (double) (read_info->scene+read_info->number_scenes));\n      else\n        (void) FormatLocaleString(options,MagickPathExtent,\n          \"-dFirstPage=%.20g -dLastPage=%.20g\",(double) read_info->scene+1,\n          (double) (read_info->scene+read_info->number_scenes));\n      read_info->number_scenes=0;\n      if (read_info->scenes != (char *) NULL)\n        *read_info->scenes='\\0';\n    }\n  (void) CopyMagickString(filename,read_info->filename,MagickPathExtent);\n  (void) AcquireUniqueFilename(read_info->filename);\n  (void) FormatLocaleString(command,MagickPathExtent,\n    GetDelegateCommands(delegate_info),\n    read_info->antialias != MagickFalse ? 4 : 1,\n    read_info->antialias != MagickFalse ? 4 : 1,density,options,\n    read_info->filename,input_filename);\n  options=DestroyString(options);\n  density=DestroyString(density);\n  status=ExternalDelegateCommand(MagickFalse,read_info->verbose,command,\n    (char *) NULL,exception) != 0 ? MagickTrue : MagickFalse;\n  image=ReadImage(read_info,exception);\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  (void) RelinquishUniqueFileResource(input_filename);\n  read_info=DestroyImageInfo(read_info);\n  if (image == (Image *) NULL)\n    ThrowReaderException(DelegateError,\"PCLDelegateFailed\");\n  if (LocaleCompare(image->magick,\"BMP\") == 0)\n    {\n      Image\n        *cmyk_image;\n\n      cmyk_image=ConsolidateCMYKImages(image,exception);\n      if (cmyk_image != (Image *) NULL)\n        {\n          image=DestroyImageList(image);\n          image=cmyk_image;\n        }\n    }\n  do\n  {\n    (void) CopyMagickString(image->filename,filename,MagickPathExtent);\n    image->page=page;\n    if (image_info->ping != MagickFalse)\n      {\n        image->magick_columns*=image->resolution.x/2.0;\n        image->magick_rows*=image->resolution.y/2.0;\n        image->columns*=image->resolution.x/2.0;\n        image->rows*=image->resolution.y/2.0;\n      }\n    next_image=SyncNextImageInList(image);\n    if (next_image != (Image *) NULL)\n      image=next_image;\n  } while (next_image != (Image *) NULL);\n  return(GetFirstImageInList(image));\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/transform.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/delegate.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/color-private.h\"\n\n// Type Definitions:\n// SegmentInfo:\ntypedef struct _SegmentInfo\n{\n  double\n    x1,\n    y1,\n    x2,\n    y2;\n} SegmentInfo;\n\n// Image:\nclass MagickPPExport Image\n  {\n  public:\n\n    // Default constructor\n    Image(void);\n\n    // Construct Image from in-memory BLOB\n    Image(const Blob &blob_);\n\n    // Construct Image of specified size from in-memory BLOB\n    Image(const Blob &blob_,const Geometry &size_);\n\n    // Construct Image of specified size and depth from in-memory BLOB\n    Image(const Blob &blob_,const Geometry &size_,const size_t depth_);\n\n    // Construct Image of specified size, depth, and format from\n    // in-memory BLOB\n    Image(const Blob &blob_,const Geometry &size_,const size_t depth_,\n      const std::string &magick_);\n\n    // Construct Image of specified size, and format from in-memory BLOB\n    Image(const Blob &blob_,const Geometry &size_,const std::string &magick_);\n\n    // Construct a blank image canvas of specified size and color\n    Image(const Geometry &size_,const Color &color_);\n\n    // Copy constructor\n    Image(const Image &image_);\n\n    // Copy constructor to copy part of the image\n   ...\n\n// RectangleInfo:\ntypedef struct _RectangleInfo\n{\n  size_t\n    width,\n    height;\n\n  ssize_t\n    x,\n    y;\n} RectangleInfo;\n\n// _DelegateInfo:\ntypedef struct _DelegateInfo\n{\n  char\n    *path,\n    *decode,\n    *encode,\n    *commands;\n\n  ssize_t\n    mode;\n\n  MagickBooleanType\n    thread_support,\n    spawn,\n    stealth;\n\n  SemaphoreInfo\n    *semaphore;\n\n  size_t\n    signature;\n}\n\n// PointInfo:\ntypedef struct _PointInfo\n{\n  double\n    x,\n    y;\n} PointInfo;\n\n// _Image:\nstruct _Image\n{\n  ClassType\n    storage_class;\n\n  ColorspaceType\n    colorspace;         /* colorspace of image data */\n\n  CompressionType\n    compression;        /* compression of image when read/write */\n\n  size_t\n    quality;            /* compression quality setting, meaning varies */\n\n  OrientationType\n    orientation;        /* photo orientation of image */\n\n  MagickBooleanType\n    taint;              /* has image been modified since reading */\n\n  size_t\n    columns,            /* physical size of image */\n    rows,\n    depth,              /* depth of image on read/write */\n    colors;             /* Size of color table, or actual color count */\n                        /* Only valid if image is not DirectClass */\n\n  PixelInfo\n    *colormap,\n    alpha_color,        /* deprecated */\n    background_color,   /* current background color attribute */\n    border_color,       /* current bordercolor attribute */\n    transparent_color;  /* color for 'transparent' color index in GIF */\n\n...\n\n// ImageInfo:\ntypedef struct _ImageInfo ImageInfo;\n\n// _ImageInfo:\nstruct _ImageInfo\n{\n  CompressionType\n    compression;        /* compression method when reading/saving image */\n\n  OrientationType\n    orientation;        /* orientation setting */\n\n  MagickBooleanType\n    temporary,          /* image file to be deleted after read \"empemeral:\" */\n    adjoin,             /* save images to separate scene files */\n    affirm,\n    antialias;\n\n  char\n    *size,              /* image generation size */\n    *extract,           /* crop/resize string on image read */\n    *page,\n    *scenes;            /* scene numbers that is to be read in */\n\n  size_t\n    scene,              /* starting value for image save numbering */\n    number_scenes,      /* total number of images in list - for escapes */\n    depth;              /* current read/save depth of images */\n\n  InterlaceType\n    interlace;          /* interlace for image write */\n\n  EndianType\n    endian;             /* integer endian order for raw image data */\n\n  ResolutionType\n    units;              /* d...\n\n// Image:\nMagick.Image.Image:ANY(void)\n\n// MagickBooleanType:\ntypedef enum\n{\n  MagickFalse = 0,\n  MagickTrue = 1\n}\n\n// ExceptionInfo:\ntypedef struct _ExceptionInfo ExceptionInfo;\n\n// DelegateInfo:\ntypedef struct _DelegateInfo\n{\n  char\n    *path,\n    *decode,\n    *encode,\n    *commands;\n\n  ssize_t\n    mode;\n\n  MagickBooleanType\n    thread_support,\n    spawn,\n    stealth;\n\n  SemaphoreInfo\n    *semaphore;\n\n  size_t\n    signature;\n} DelegateInfo;\n\n// Called Methods (top 10):\n// fopen_utf8 from MagickCore/utility-private.h:\nstatic inline FILE *fopen_utf8(const char *path,const char *mode) /* <=== fopen_utf8 */ \n{\n#if !defined(MAGICKCORE_WINDOWS_SUPPORT) || defined(__CYGWIN__)\n  return(fopen(path,mode));\n#else\n   FILE\n     *file;\n\n   wchar_t\n     *mode_wide,\n     *path_wide;\n\n   path_wide=create_wchar_path(path);\n   if (path_wide == (wchar_t *) NULL)\n     return((FILE *) NULL);\n   mode_wide=create_wchar_mode(mode);\n   if (mode_wide == (wchar_t *) NULL)\n     {\n       path_wide=(wchar_t *) RelinquishMagickMemory(path_wide);\n       return((FILE *) NULL);\n     }\n   file=_wfopen(path_wide,mode_wide);\n   mode_wide=(wchar_t *) RelinquishMagickMemory(mode_wide);\n   path_wide=(wchar_t *) RelinquishMagickMemory(path_wide);\n   return(file);\n#endif\n}\n\n// SetImageBackgroundColor from MagickCore/image.c:\nMagickExport MagickBooleanType SetImageBackgroundColor(Image *image, /* <=== SetImageBackgroundColor */ \n  ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  PixelInfo\n    background;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickCoreSignature);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  if ((image->background_color.alpha_trait != UndefinedPixelTrait) &&\n      (image->alpha_trait == UndefinedPixelTrait))\n    (void) SetImageAlphaChannel(image,OnAlphaChannel,exception);\n  ConformPixelInfo(image,&image->background_color,&background,exception);\n  /*\n    Set image background color.\n  */\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    Quantum\n      *magick_restrict q;\n\n    ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=QueueCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      SetPixelViaPixelInfo(image,&background,q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\n// GetBlobSize from MagickCore/blob.c:\nMagickExport MagickSizeType GetBlobSize(const Image *image) /* <=== GetBlobSize */ \n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  MagickSizeType\n    extent;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(image->blob != (BlobInfo *) NULL);\n  blob_info=image->blob;\n  extent=0;\n  switch (blob_info->type)\n  {\n    case UndefinedStream:\n    case StandardStream:\n    {\n      extent=blob_info->size;\n      break;\n    }\n    case FileStream:\n    {\n      int\n        file_descriptor;\n\n      extent=(MagickSizeType) blob_info->properties.st_size;\n      if (extent == 0)\n        extent=blob_info->size;\n      file_descriptor=fileno(blob_info->file_info.file);\n      if (file_descriptor == -1)\n        break;\n      if (fstat(file_descriptor,&blob_info->properties) == 0)\n        extent=(MagickSizeType) blob_info->properties.st_size;\n      break;\n    }\n    case PipeStream:\n    {\n      extent=blob_info->size;\n      break;\n    }\n    case ZipStream:\n    case BZipStream:\n    {\n      MagickBooleanType\n        status;\n\n      status=GetPathAttributes(image->filename,&blob_info->properties);\n      if (status != MagickFalse)\n        extent=(MagickSizeType) blob_info->properties.st_size;\n      break;\n    }\n    case FifoStream:\n      break;\n    case BlobStream:\n    {\n      extent=(MagickSizeType) blob_info->length;\n      break;\n    }\n    case CustomStream:\n    {\n      if ((blob_info->custom_stream->teller != (CustomStreamTeller) NULL) &&\n          (blob_info->custom_stream->seeker != (CustomStreamSeeker) NULL))\n        {\n          MagickOffsetType\n            offset;\n\n          offset=blob_info->custom_stream->teller(\n            blob_info->custom_stream->data);\n          extent=(MagickSizeType) blob_info->custom_stream->seeker(0,SEEK_END,\n            blob_info->custom_stream->data);\n          (void) blob_info->custom_stream->seeker(offset,SEEK_SET,\n            blob_info->custom_stream->data);\n        }\n      break;\n    }\n  }\n  return(extent);\n}\n\n// InterpretImageProperties from MagickCore/property.c:\nMagickExport char *InterpretImageProperties(ImageInfo *image_info,Image *image, /* <=== InterpretImageProperties */ \n  const char *embed_text,ExceptionInfo *exception)\n{\n#define ExtendInterpretText(string_length) \\\n{ \\\n  size_t length=(string_length); \\\n  if ((size_t) (q-interpret_text+length+1) >= extent) \\\n    { \\\n      extent+=length; \\\n      interpret_text=(char *) ResizeQuantumMemory(interpret_text,extent+ \\\n        MagickPathExtent,sizeof(*interpret_text)); \\\n      if (interpret_text == (char *) NULL) \\\n        { \\\n          if (property_image != image) \\\n            property_image=DestroyImage(property_image); \\\n          if (property_info != image_info) \\\n            property_info=DestroyImageInfo(property_info); \\\n          return((char *) NULL); \\\n        } \\\n      q=interpret_text+strlen(interpret_text); \\\n   } \\\n}\n\n#define AppendKeyValue2Text(key,value)\\\n{ \\\n  size_t length=strlen(key)+strlen(value)+2; \\\n  if ((size_t) (q-interpret_text+length+1) >= extent) \\\n    { \\\n      extent+=length; \\\n      interpret_text=(char *) ResizeQuantumMemory(interpret_text,extent+ \\\n        MagickPathExtent,sizeof(*interpret_text)); \\\n      if (interpret_text == (char *) NULL) \\\n        { \\\n          if (property_image != image) \\\n            property_image=DestroyImage(property_image); \\\n          if (property_info != image_info) \\\n            property_info=DestroyImageInfo(property_info); \\\n          return((char *) NULL); \\\n        } \\\n      q=interpret_text+strlen(interpret_text); \\\n     } \\\n   q+=FormatLocaleString(q,extent,\"%s=%s\\n\",(key),(value)); \\\n}\n\n#define AppendString2Text(string) \\\n{ \\\n  size_t length=strlen((string)); \\\n  if ((size_t) (q-interpret_text+length+1) >= extent) \\\n    { \\\n      extent+=length; \\\n      interpret_text=(char *) ResizeQuantumMemory(interpret_text,extent+ \\\n        MagickPathExtent,sizeof(*interpret_text)); \\\n      if (interpret_text == (char *) NULL) \\\n        { \\\n          if (property_image != image) \\\n            property_image=DestroyImage(property_image); \\\n          if (property_info != image_info) \\\n            property_info=DestroyImageInfo(property_info); \\\n          return((char *) NULL); \\\n        } \\\n      q=interpret_text+strlen(interpret_text); \\\n    } \\\n  (void) CopyMagickString(q,(string),extent); \\\n  q+=length; \\\n}\n\n  char\n    *interpret_text;\n\n  Image\n    *property_image;\n\n  ImageInfo\n    *property_info;\n\n  MagickBooleanType\n    number;\n\n  char\n    *q;  /* current position in interpret_text */\n\n  const char\n    *p;  /* position in embed_text string being expanded */\n\n  size_t\n    extent;  /* allocated length of interpret_text */\n\n  if ((image != (Image *) NULL) && (image->debug != MagickFalse))\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  else\n   if ((image_info != (ImageInfo *) NULL) && (image_info->debug != MagickFalse))\n     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n       image_info->filename);\n   else\n     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\"no image\");\n  if (embed_text == (const char *) NULL)\n    return(ConstantString(\"\"));\n  p=embed_text;\n  while ((isspace((int) ((unsigned char) *p)) != 0) && (*p != '\\0'))\n    p++;\n  if (*p == '\\0')\n    return(ConstantString(\"\"));\n  if ((*p == '@') && (IsPathAccessible(p+1) != MagickFalse))\n    {\n      /*\n        Handle a '@' replace string from file.\n      */\n      if (IsRightsAuthorized(PathPolicyDomain,ReadPolicyRights,p) == MagickFalse)\n        {\n          errno=EPERM;\n          (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n            \"NotAuthorized\",\"`%s'\",p);\n          return(ConstantString(\"\"));\n        }\n      interpret_text=FileToString(p+1,~0UL,exception);\n      if (interpret_text != (char *) NULL)\n        return(interpret_text);\n    }\n  /*\n    Translate any embedded format characters.\n  */\n  if (image_info != (ImageInfo *) NULL)\n    property_info=image_info;\n  else\n    property_info=CloneImageInfo(image_info);\n  if ((image != (Image *) NULL) && (image->columns != 0) && (image->rows != 0))\n    property_image=image;\n  else\n    {\n      property_image=AcquireImage(image_info,exception);\n      (void) SetImageExtent(property_image,1,1,exception);\n      (void) SetImageBackgroundColor(property_image,exception);\n    }\n  interpret_text=AcquireString(embed_text); /* new string with extra space */\n  extent=MagickPathExtent;                  /* allocated space in string */\n  number=MagickFalse;                       /* is last char a number? */\n  for (q=interpret_text; *p!='\\0'; number=isdigit((int) ((unsigned char) *p)) ? MagickTrue : MagickFalse,p++)\n  {\n    /*\n      Look for the various escapes, (and handle other specials)\n    */\n    *q='\\0';\n    ExtendInterpretText(MagickPathExtent);\n    switch (*p)\n    {\n      case '\\\\':\n      {\n        switch (*(p+1))\n        {\n          case '\\0':\n            continue;\n          case 'r':  /* convert to RETURN */\n          {\n            *q++='\\r';\n            p++;\n            continue;\n          }\n          case 'n':  /* convert to NEWLINE */\n          {\n            *q++='\\n';\n            p++;\n            continue;\n          }\n          case '\\n':  /* EOL removal UNIX,MacOSX */\n          {\n            p++;\n            continue;\n          }\n          case '\\r':  /* EOL removal DOS,Windows */\n          {\n            p++;\n            if (*p == '\\n') /* return-newline EOL */\n              p++;\n            continue;\n          }\n          default:\n          {\n            p++;\n            *q++=(*p);\n          }\n        }\n        continue;\n      }\n      case '&':\n      {\n        if (LocaleNCompare(\"&lt;\",p,4) == 0)\n          {\n            *q++='<';\n            p+=3;\n          }\n        else\n          if (LocaleNCompare(\"&gt;\",p,4) == 0)\n            {\n              *q++='>';\n              p+=3;\n            }\n          else\n            if (LocaleNCompare(\"&amp;\",p,5) == 0)\n              {\n                *q++='&';\n                p+=4;\n              }\n            else\n              *q++=(*p);\n        continue;\n      }\n      case '%':\n        break;  /* continue to next set of handlers */\n      default:\n      {\n        *q++=(*p);  /* any thing else is 'as normal' */\n        continue;\n      }\n    }\n    p++; /* advance beyond the percent */\n    /*\n      Doubled Percent - or percent at end of string.\n    */\n    if ((*p == '\\0') || (*p == '\\'') || (*p == '\"'))\n      p--;\n    if (*p == '%')\n      {\n        *q++='%';\n        continue;\n      }\n    /*\n      Single letter escapes %c.\n    */\n    if (*p != '[')\n      {\n        const char\n          *string;\n\n        if (number != MagickFalse)\n          {\n            /*\n              But only if not preceeded by a number!\n            */\n            *q++='%'; /* do NOT substitute the percent */\n            p--;      /* back up one */\n            continue;\n          }\n        string=GetMagickPropertyLetter(property_info,image,*p,exception);\n        if (string != (char *) NULL)\n          {\n            AppendString2Text(string);\n            (void) DeleteImageArtifact(property_image,\"magick-property\");\n            (void) DeleteImageOption(property_info,\"magick-property\");\n            continue;\n          }\n        (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n          \"UnknownImageProperty\",\"\\\"%%%c\\\"\",*p);\n        continue;\n      }\n    {\n      char\n        pattern[2*MagickPathExtent];\n\n      const char\n        *key,\n        *string;\n\n      ssize_t\n        len;\n\n      ssize_t\n        depth;\n\n      /*\n        Braced Percent Escape %[...].\n      */\n      p++;  /* advance p to just inside the opening brace */\n      depth=1;\n      if (*p == ']')\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n            \"UnknownImageProperty\",\"\\\"%%[]\\\"\");\n          break;\n        }\n      for (len=0; len < (MagickPathExtent-1L) && (*p != '\\0'); )\n      {\n        if ((*p == '\\\\') && (*(p+1) != '\\0'))\n          {\n            /*\n              Skip escaped braces within braced pattern.\n            */\n            pattern[len++]=(*p++);\n            pattern[len++]=(*p++);\n            continue;\n          }\n        if (*p == '[')\n          depth++;\n        if (*p == ']')\n          depth--;\n        if (depth <= 0)\n          break;\n        pattern[len++]=(*p++);\n      }\n      pattern[len]='\\0';\n      if (depth != 0)\n        {\n          /*\n            Check for unmatched final ']' for \"%[...]\".\n          */\n          if (len >= 64)\n            {\n              pattern[61] = '.';  /* truncate string for error message */\n              pattern[62] = '.';\n              pattern[63] = '.';\n              pattern[64] = '\\0';\n            }\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"UnbalancedBraces\",\"\\\"%%[%s\\\"\",pattern);\n          interpret_text=DestroyString(interpret_text);\n          if (property_image != image)\n            property_image=DestroyImage(property_image);\n          if (property_info != image_info)\n            property_info=DestroyImageInfo(property_info);\n          return((char *) NULL);\n        }\n      /*\n        Special Lookup Prefixes %[prefix:...].\n      */\n      if (LocaleNCompare(\"fx:\",pattern,3) == 0)\n        {\n          double\n            value;\n\n          FxInfo\n            *fx_info;\n\n          MagickBooleanType\n            status;\n\n          /*\n            FX - value calculator.\n          */\n          fx_info=AcquireFxInfo(property_image,pattern+3,exception);\n          if (fx_info == (FxInfo *) NULL)\n            continue;\n          status=FxEvaluateChannelExpression(fx_info,CompositePixelChannel,0,0,\n            &value,exception);\n          fx_info=DestroyFxInfo(fx_info);\n          if (status != MagickFalse)\n            {\n              char\n                result[MagickPathExtent];\n\n              (void) FormatLocaleString(result,MagickPathExtent,\"%.*g\",\n                GetMagickPrecision(),(double) value);\n              AppendString2Text(result);\n            }\n          continue;\n        }\n      if (LocaleNCompare(\"hex:\",pattern,4) == 0)\n        {\n          double\n            value;\n\n          FxInfo\n            *fx_info;\n\n          MagickStatusType\n            status;\n\n          PixelInfo\n            pixel;\n\n          /*\n            Pixel - color value calculator.\n          */\n          GetPixelInfo(property_image,&pixel);\n          fx_info=AcquireFxInfo(property_image,pattern+4,exception);\n          if (fx_info == (FxInfo *) NULL)\n            continue;\n          status=FxEvaluateChannelExpression(fx_info,RedPixelChannel,0,0,\n            &value,exception);\n          pixel.red=(double) QuantumRange*value;\n          status&=FxEvaluateChannelExpression(fx_info,GreenPixelChannel,0,0,\n            &value,exception);\n          pixel.green=(double) QuantumRange*value;\n          status&=FxEvaluateChannelExpression(fx_info,BluePixelChannel,0,0,\n            &value,exception);\n          pixel.blue=(double) QuantumRange*value;\n          if (property_image->colorspace == CMYKColorspace)\n            {\n              status&=FxEvaluateChannelExpression(fx_info,BlackPixelChannel,0,0,\n                &value,exception);\n              pixel.black=(double) QuantumRange*value;\n            }\n          status&=FxEvaluateChannelExpression(fx_info,AlphaPixelChannel,0,0,\n            &value,exception);\n          pixel.alpha=(double) QuantumRange*value;\n          fx_info=DestroyFxInfo(fx_info);\n          if (status != MagickFalse)\n            {\n              char\n                hex[MagickPathExtent];\n\n              GetColorTuple(&pixel,MagickTrue,hex);\n              AppendString2Text(hex+1);\n            }\n          continue;\n        }\n      if (LocaleNCompare(\"pixel:\",pattern,6) == 0)\n        {\n          double\n            value;\n\n          FxInfo\n            *fx_info;\n\n          MagickStatusType\n            status;\n\n          PixelInfo\n            pixel;\n\n          /*\n            Pixel - color value calculator.\n          */\n          GetPixelInfo(property_image,&pixel);\n          fx_info=AcquireFxInfo(property_image,pattern+6,exception);\n          if (fx_info == (FxInfo *) NULL)\n            continue;\n          status=FxEvaluateChannelExpression(fx_info,RedPixelChannel,0,0,\n            &value,exception);\n          pixel.red=(double) QuantumRange*value;\n          status&=FxEvaluateChannelExpression(fx_info,GreenPixelChannel,0,0,\n            &value,exception);\n          pixel.green=(double) QuantumRange*value;\n          status&=FxEvaluateChannelExpression(fx_info,BluePixelChannel,0,0,\n            &value,exception);\n          pixel.blue=(double) QuantumRange*value;\n          if (property_image->colorspace == CMYKColorspace)\n            {\n              status&=FxEvaluateChannelExpression(fx_info,BlackPixelChannel,0,0,\n                &value,exception);\n              pixel.black=(double) QuantumRange*value;\n            }\n          status&=FxEvaluateChannelExpression(fx_info,AlphaPixelChannel,0,0,\n            &value,exception);\n          pixel.alpha=(double) QuantumRange*value;\n          fx_info=DestroyFxInfo(fx_info);\n          if (status != MagickFalse)\n            {\n              char\n                name[MagickPathExtent];\n\n              GetColorTuple(&pixel,MagickFalse,name);\n              string=GetImageArtifact(property_image,\"pixel:compliance\");\n              if (string != (char *) NULL)\n                {\n                  ComplianceType compliance=(ComplianceType) ParseCommandOption(\n                    MagickComplianceOptions,MagickFalse,string);\n                  (void) QueryColorname(property_image,&pixel,compliance,name,\n                    exception);\n                }\n              AppendString2Text(name);\n            }\n          continue;\n        }\n      if (LocaleNCompare(\"option:\",pattern,7) == 0)\n        {\n          /*\n            Option - direct global option lookup (with globbing).\n          */\n          if (IsGlob(pattern+7) != MagickFalse)\n            {\n              ResetImageOptionIterator(property_info);\n              while ((key=GetNextImageOption(property_info)) != (const char *) NULL)\n                if (GlobExpression(key,pattern+7,MagickTrue) != MagickFalse)\n                  {\n                    string=GetImageOption(property_info,key);\n                    if (string != (const char *) NULL)\n                      AppendKeyValue2Text(key,string);\n                    /* else - assertion failure? key found but no string value! */\n                  }\n              continue;\n            }\n          string=GetImageOption(property_info,pattern+7);\n          if (string == (char *) NULL)\n            goto PropertyLookupFailure; /* no artifact of this specifc name */\n          AppendString2Text(string);\n          continue;\n        }\n      if (LocaleNCompare(\"artifact:\",pattern,9) == 0)\n        {\n          /*\n            Artifact - direct image artifact lookup (with glob).\n          */\n          if (IsGlob(pattern+9) != MagickFalse)\n            {\n              ResetImageArtifactIterator(property_image);\n              while ((key=GetNextImageArtifact(property_image)) != (const char *) NULL)\n              if (GlobExpression(key,pattern+9,MagickTrue) != MagickFalse)\n                {\n                  string=GetImageArtifact(property_image,key);\n                  if (string != (const char *) NULL)\n                    AppendKeyValue2Text(key,string);\n                  /* else - assertion failure? key found but no string value! */\n                }\n              continue;\n            }\n          string=GetImageArtifact(property_image,pattern+9);\n          if (string == (char *) NULL)\n            goto PropertyLookupFailure; /* no artifact of this specifc name */\n          AppendString2Text(string);\n          continue;\n        }\n      if (LocaleNCompare(\"property:\",pattern,9) == 0)\n        {\n          /*\n            Property - direct image property lookup (with glob).\n          */\n          if (IsGlob(pattern+9) != MagickFalse)\n            {\n              ResetImagePropertyIterator(property_image);\n              while ((key=GetNextImageProperty(property_image)) != (const char *) NULL)\n                if (GlobExpression(key,pattern,MagickTrue) != MagickFalse)\n                  {\n                    string=GetImageProperty(property_image,key,exception);\n                    if (string != (const char *) NULL)\n                      AppendKeyValue2Text(key,string);\n                    /* else - assertion failure? */\n                  }\n              continue;\n            }\n          string=GetImageProperty(property_image,pattern+9,exception);\n          if (string == (char *) NULL)\n            goto PropertyLookupFailure; /* no artifact of this specifc name */\n          AppendString2Text(string);\n          continue;\n        }\n      /*\n        Properties without special prefix.  This handles attributes,\n        properties, and profiles such as %[exif:...].  Note the profile\n        properties may also include a glob expansion pattern.\n      */\n      string=GetImageProperty(property_image,pattern,exception);\n      if (string != (const char *) NULL)\n        {\n          AppendString2Text(string);\n          (void) DeleteImageArtifact(property_image,\"magick-property\");\n          (void) DeleteImageOption(property_info,\"magick-property\");\n          continue;\n        }\n      if (IsGlob(pattern) != MagickFalse)\n        {\n          /*\n            Handle property 'glob' patterns such as:\n            %[*] %[user:array_??] %[filename:e*]>\n          */\n          ResetImagePropertyIterator(property_image);\n          while ((key=GetNextImageProperty(property_image)) != (const char *) NULL)\n            if (GlobExpression(key,pattern,MagickTrue) != MagickFalse)\n              {\n                string=GetImageProperty(property_image,key,exception);\n                if (string != (const char *) NULL)\n                  AppendKeyValue2Text(key,string);\n                /* else - assertion failure? */\n              }\n          continue;\n        }\n      /*\n        Look for a known property or image attribute such as\n        %[basename] %[denisty] %[delay].  Also handles a braced single\n        letter: %[b] %[G] %[g].\n      */\n      string=GetMagickProperty(property_info,property_image,pattern,exception);\n      if (string != (const char *) NULL)\n        {\n          AppendString2Text(string);\n          continue;\n        }\n      /*\n        Look for a per-image artifact. This includes option lookup\n        (FUTURE: interpreted according to image).\n      */\n      string=GetImageArtifact(property_image,pattern);\n      if (string != (char *) NULL)\n        {\n          AppendString2Text(string);\n          continue;\n        }\n      /*\n        No image, so direct 'option' lookup (no delayed percent escapes).\n      */\n      string=GetImageOption(property_info,pattern);\n      if (string != (char *) NULL)\n        {\n          AppendString2Text(string);\n          continue;\n        }\nPropertyLookupFailure:\n      /*\n        Failed to find any match anywhere!\n      */\n      if (len >= 64)\n        {\n          pattern[61] = '.';  /* truncate string for error message */\n          pattern[62] = '.';\n          pattern[63] = '.';\n          pattern[64] = '\\0';\n        }\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n        \"UnknownImageProperty\",\"\\\"%%[%s]\\\"\",pattern);\n    }\n  }\n  *q='\\0';\n  if (property_image != image)\n    property_image=DestroyImage(property_image);\n  if (property_info != image_info)\n    property_info=DestroyImageInfo(property_info);\n  return(interpret_text);\n}\n\n// DestroyStringInfo from MagickCore/string.c:\nMagickExport StringInfo *DestroyStringInfo(StringInfo *string_info) /* <=== DestroyStringInfo */ \n{\n  assert(string_info != (StringInfo *) NULL);\n  assert(string_info->signature == MagickCoreSignature);\n  if (string_info->datum != (unsigned char *) NULL)\n    string_info->datum=(unsigned char *) RelinquishMagickMemory(\n      string_info->datum);\n  if (string_info->name != (char *) NULL)\n    string_info->name=DestroyString(string_info->name);\n  if (string_info->path != (char *) NULL)\n    string_info->path=DestroyString(string_info->path);\n  string_info->signature=(~MagickCoreSignature);\n  string_info=(StringInfo *) RelinquishMagickMemory(string_info);\n  return(string_info);\n}\n\n// GetExceptionMessage from MagickCore/exception.c:\nMagickExport char *GetExceptionMessage(const int error) /* <=== GetExceptionMessage */ \n{\n  char\n    exception[MagickPathExtent];\n\n  *exception='\\0';\n#if defined(MAGICKCORE_HAVE_STRERROR_R)\n#if !defined(MAGICKCORE_STRERROR_R_CHAR_P)\n  (void) strerror_r(error,exception,sizeof(exception));\n#else\n  (void) CopyMagickString(exception,strerror_r(error,exception,\n    sizeof(exception)),sizeof(exception));\n#endif\n#else\n  (void) CopyMagickString(exception,strerror(error),sizeof(exception));\n#endif\n  return(ConstantString(exception));\n}\n\n// PrintChannelMoments from MagickCore/identify.c:\nstatic ssize_t PrintChannelMoments(FILE *file,const PixelChannel channel, /* <=== PrintChannelMoments */ \n  const char *name,const double scale,const ChannelMoments *channel_moments)\n{\n  double\n    powers[MaximumNumberOfImageMoments] =\n      { 1.0, 2.0, 3.0, 3.0, 6.0, 4.0, 6.0, 4.0 };\n\n  ssize_t\n    i;\n\n  ssize_t\n    n;\n\n  n=FormatLocaleFile(file,\"    %s:\\n\",name);\n  n+=FormatLocaleFile(file,\"      Centroid: %.*g,%.*g\\n\",\n    GetMagickPrecision(),channel_moments[channel].centroid.x,\n    GetMagickPrecision(),channel_moments[channel].centroid.y);\n  n+=FormatLocaleFile(file,\"      Ellipse Semi-Major/Minor axis: %.*g,%.*g\\n\",\n    GetMagickPrecision(),channel_moments[channel].ellipse_axis.x,\n    GetMagickPrecision(),channel_moments[channel].ellipse_axis.y);\n  n+=FormatLocaleFile(file,\"      Ellipse angle: %.*g\\n\",\n    GetMagickPrecision(),channel_moments[channel].ellipse_angle);\n  n+=FormatLocaleFile(file,\"      Ellipse eccentricity: %.*g\\n\",\n    GetMagickPrecision(),channel_moments[channel].ellipse_eccentricity);\n  n+=FormatLocaleFile(file,\"      Ellipse intensity: %.*g (%.*g)\\n\",\n    GetMagickPrecision(),pow(scale,powers[0])*\n    channel_moments[channel].ellipse_intensity,GetMagickPrecision(),\n    channel_moments[channel].ellipse_intensity);\n  for (i=0; i < MaximumNumberOfImageMoments; i++)\n    n+=FormatLocaleFile(file,\"      I%.20g: %.*g (%.*g)\\n\",i+1.0,\n      GetMagickPrecision(),channel_moments[channel].invariant[i]/pow(scale,\n      powers[i]),GetMagickPrecision(),channel_moments[channel].invariant[i]);\n  return(n);\n}\n\n// QuantumRange from MagickCore/MagickCore/MagickCore/magick-type.h:\n\n\n// RemoveImageFromList from MagickCore/list.c:\nMagickExport Image *RemoveImageFromList(Image **images) /* <=== RemoveImageFromList */ \n{\n  Image\n    *p;\n\n  assert(images != (Image **) NULL);\n  if ((*images) == (Image *) NULL)\n    return((Image *) NULL);\n  assert((*images)->signature == MagickCoreSignature);\n  if ((*images)->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      (*images)->filename);\n  p=(*images);\n  if ((p->previous == (Image *) NULL) && (p->next == (Image *) NULL))\n    *images=(Image *) NULL;\n  else\n    {\n      if (p->previous != (Image *) NULL)\n        {\n          p->previous->next=p->next;\n          *images=p->previous;\n        }\n      if (p->next != (Image *) NULL)\n        {\n          p->next->previous=p->previous;\n          *images=p->next;\n        }\n      p->previous=(Image *) NULL;\n      p->next=(Image *) NULL;\n    }\n  return(p);\n}\n\n// MatteColor from MagickCore/MagickCore/MagickCore/MagickCore/image-private.h:\n\n"
  },
  {
    "repository": "qtbase",
    "cve_id": "CVE-2021-38593",
    "cwe_list": [
      "CWE-787"
    ],
    "commit_hash": "6b400e3147dcfd8cc3a393ace1bd118c93762e0c",
    "short_hash": "6b400e31",
    "vulnerableMethods_before": [
      {
        "filename": "qpaintengineex.cpp",
        "method_name": "vulnerable_function",
        "raw_code": "void QPaintEngineEx::stroke(const QVectorPath &path, const QPen &inPen)\n{\n#ifdef QT_DEBUG_DRAW\n    qDebug() << \"QPaintEngineEx::stroke()\" << pen;\n#endif\n\n    Q_D(QPaintEngineEx);\n\n    if (path.isEmpty())\n        return;\n\n    if (!d->strokeHandler) {\n        d->strokeHandler = new StrokeHandler(path.elementCount()+4);\n        d->stroker.setMoveToHook(qpaintengineex_moveTo);\n        d->stroker.setLineToHook(qpaintengineex_lineTo);\n        d->stroker.setCubicToHook(qpaintengineex_cubicTo);\n    }\n\n    QRectF clipRect;\n    QPen pen = inPen;\n    if (pen.style() > Qt::SolidLine) {\n        QRectF cpRect = path.controlPointRect();\n        const QTransform &xf = state()->matrix;\n        if (pen.isCosmetic()) {\n            clipRect = d->exDeviceRect;\n            cpRect.translate(xf.dx(), xf.dy());\n        } else {\n            clipRect = xf.inverted().mapRect(QRectF(d->exDeviceRect));\n        }\n        // Check to avoid generating unwieldy amount of dashes that will not be visible anyway\n        QRectF extentRect = cpRect & clipRect;\n        qreal extent = qMax(extentRect.width(), extentRect.height());\n        qreal patternLength = 0;\n        const QList<qreal> pattern = pen.dashPattern();\n        const int patternSize = qMin(pattern.size(), 32);\n        for (int i = 0; i < patternSize; i++)\n            patternLength += qMax(pattern.at(i), qreal(0));\n        if (pen.widthF())\n            patternLength *= pen.widthF();\n        if (qFuzzyIsNull(patternLength)) {\n            pen.setStyle(Qt::NoPen);\n        } else if (extent / patternLength > 10000) {\n            // approximate stream of tiny dashes with semi-transparent solid line\n            pen.setStyle(Qt::SolidLine);\n            QColor color(pen.color());\n            color.setAlpha(color.alpha() / 2);\n            pen.setColor(color);\n        }\n    }\n\n    if (!qpen_fast_equals(pen, d->strokerPen)) {\n        d->strokerPen = pen;\n        d->stroker.setJoinStyle(pen.joinStyle());\n        d->stroker.setCapStyle(pen.capStyle());\n        d->stroker.setMiterLimit(pen.miterLimit());\n        qreal penWidth = pen.widthF();\n        if (penWidth == 0)\n            d->stroker.setStrokeWidth(1);\n        else\n            d->stroker.setStrokeWidth(penWidth);\n\n        Qt::PenStyle style = pen.style();\n        if (style == Qt::SolidLine) {\n            d->activeStroker = &d->stroker;\n        } else if (style == Qt::NoPen) {\n            d->activeStroker = nullptr;\n        } else {\n            d->dasher.setDashPattern(pen.dashPattern());\n            d->dasher.setDashOffset(pen.dashOffset());\n            d->activeStroker = &d->dasher;\n        }\n    }\n\n    if (!d->activeStroker) {\n        return;\n    }\n\n    if (!clipRect.isNull())\n        d->activeStroker->setClipRect(clipRect);\n\n    if (d->activeStroker == &d->stroker)\n        d->stroker.setForceOpen(path.hasExplicitOpen());\n\n    const QPainterPath::ElementType *types = path.elements();\n    const qreal *points = path.points();\n    int pointCount = path.elementCount();\n\n    const qreal *lastPoint = points + (pointCount<<1);\n\n    d->strokeHandler->types.reset();\n    d->strokeHandler->pts.reset();\n\n    // Some engines might decide to optimize for the non-shape hint later on...\n    uint flags = QVectorPath::WindingFill;\n\n    if (path.elementCount() > 2)\n        flags |= QVectorPath::NonConvexShapeMask;\n\n    if (d->stroker.capStyle() == Qt::RoundCap || d->stroker.joinStyle() == Qt::RoundJoin)\n        flags |= QVectorPath::CurvedShapeMask;\n\n    // ### Perspective Xforms are currently not supported...\n    if (!pen.isCosmetic()) {\n        // We include cosmetic pens in this case to avoid having to\n        // change the current transform. Normal transformed,\n        // non-cosmetic pens will be transformed as part of fill\n        // later, so they are also covered here..\n        d->activeStroker->setCurveThresholdFromTransform(state()->matrix);\n        d->activeStroker->begin(d->strokeHandler);\n        if (types) {\n            while (points < lastPoint) {\n                switch (*types) {\n                case QPainterPath::MoveToElement:\n                    d->activeStroker->moveTo(points[0], points[1]);\n                    points += 2;\n                    ++types;\n                    break;\n                case QPainterPath::LineToElement:\n                    d->activeStroker->lineTo(points[0], points[1]);\n                    points += 2;\n                    ++types;\n                    break;\n                case QPainterPath::CurveToElement:\n                    d->activeStroker->cubicTo(points[0], points[1],\n                                              points[2], points[3],\n                                              points[4], points[5]);\n                    points += 6;\n                    types += 3;\n                    flags |= QVectorPath::CurvedShapeMask;\n                    break;\n                default:\n                    break;\n                }\n            }\n            if (path.hasImplicitClose())\n                d->activeStroker->lineTo(path.points()[0], path.points()[1]);\n\n        } else {\n            d->activeStroker->moveTo(points[0], points[1]);\n            points += 2;\n            while (points < lastPoint) {\n                d->activeStroker->lineTo(points[0], points[1]);\n                points += 2;\n            }\n            if (path.hasImplicitClose())\n                d->activeStroker->lineTo(path.points()[0], path.points()[1]);\n        }\n        d->activeStroker->end();\n\n        if (!d->strokeHandler->types.size()) // an empty path...\n            return;\n\n        QVectorPath strokePath(d->strokeHandler->pts.data(),\n                               d->strokeHandler->types.size(),\n                               d->strokeHandler->types.data(),\n                               flags);\n        fill(strokePath, pen.brush());\n    } else {\n        // For cosmetic pens we need a bit of trickery... We to process xform the input points\n        if (state()->matrix.type() >= QTransform::TxProject) {\n            QPainterPath painterPath = state()->matrix.map(path.convertToPainterPath());\n            d->activeStroker->strokePath(painterPath, d->strokeHandler, QTransform());\n        } else {\n            d->activeStroker->setCurveThresholdFromTransform(QTransform());\n            d->activeStroker->begin(d->strokeHandler);\n            if (types) {\n                while (points < lastPoint) {\n                    switch (*types) {\n                    case QPainterPath::MoveToElement: {\n                        QPointF pt = (*(const QPointF *) points) * state()->matrix;\n                        d->activeStroker->moveTo(pt.x(), pt.y());\n                        points += 2;\n                        ++types;\n                        break;\n                    }\n                    case QPainterPath::LineToElement: {\n                        QPointF pt = (*(const QPointF *) points) * state()->matrix;\n                        d->activeStroker->lineTo(pt.x(), pt.y());\n                        points += 2;\n                        ++types;\n                        break;\n                    }\n                    case QPainterPath::CurveToElement: {\n                        QPointF c1 = ((const QPointF *) points)[0] * state()->matrix;\n                        QPointF c2 = ((const QPointF *) points)[1] * state()->matrix;\n                        QPointF e =  ((const QPointF *) points)[2] * state()->matrix;\n                        d->activeStroker->cubicTo(c1.x(), c1.y(), c2.x(), c2.y(), e.x(), e.y());\n                        points += 6;\n                        types += 3;\n                        flags |= QVectorPath::CurvedShapeMask;\n                        break;\n                    }\n                    default:\n                        break;\n                    }\n                }\n                if (path.hasImplicitClose()) {\n                    QPointF pt = * ((const QPointF *) path.points()) * state()->matrix;\n                    d->activeStroker->lineTo(pt.x(), pt.y());\n                }\n\n            } else {\n                QPointF p = ((const QPointF *)points)[0] * state()->matrix;\n                d->activeStroker->moveTo(p.x(), p.y());\n                points += 2;\n                while (points < lastPoint) {\n                    QPointF p = ((const QPointF *)points)[0] * state()->matrix;\n                    d->activeStroker->lineTo(p.x(), p.y());\n                    points += 2;\n                }\n                if (path.hasImplicitClose())\n                    d->activeStroker->lineTo(p.x(), p.y());\n            }\n            d->activeStroker->end();\n        }\n\n        QVectorPath strokePath(d->strokeHandler->pts.data(),\n                               d->strokeHandler->types.size(),\n                               d->strokeHandler->types.data(),\n                               flags);\n\n        QTransform xform = state()->matrix;\n        state()->matrix = QTransform();\n        transformChanged();\n\n        QBrush brush = pen.brush();\n        if (qbrush_style(brush) != Qt::SolidPattern)\n            brush.setTransform(brush.transform() * xform);\n\n        fill(strokePath, brush);\n\n        state()->matrix = xform;\n        transformChanged();\n    }\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "qpaintengineex.cpp",
        "method_name": "fixed_function",
        "raw_code": "void QPaintEngineEx::stroke(const QVectorPath &path, const QPen &inPen)\n{\n#ifdef QT_DEBUG_DRAW\n    qDebug() << \"QPaintEngineEx::stroke()\" << pen;\n#endif\n\n    Q_D(QPaintEngineEx);\n\n    if (path.isEmpty())\n        return;\n\n    if (!d->strokeHandler) {\n        d->strokeHandler = new StrokeHandler(path.elementCount()+4);\n        d->stroker.setMoveToHook(qpaintengineex_moveTo);\n        d->stroker.setLineToHook(qpaintengineex_lineTo);\n        d->stroker.setCubicToHook(qpaintengineex_cubicTo);\n    }\n\n    QRectF clipRect;\n    QPen pen = inPen;\n    if (pen.style() > Qt::SolidLine) {\n        QRectF cpRect = path.controlPointRect();\n        const QTransform &xf = state()->matrix;\n        if (pen.isCosmetic()) {\n            clipRect = d->exDeviceRect;\n            cpRect.translate(xf.dx(), xf.dy());\n        } else {\n            clipRect = xf.inverted().mapRect(QRectF(d->exDeviceRect));\n        }\n        // Check to avoid generating unwieldy amount of dashes that will not be visible anyway\n        QRectF extentRect = cpRect & clipRect;\n        qreal extent = qMax(extentRect.width(), extentRect.height());\n        qreal patternLength = 0;\n        const QList<qreal> pattern = pen.dashPattern();\n        const int patternSize = qMin(pattern.size(), 32);\n        for (int i = 0; i < patternSize; i++)\n            patternLength += qMax(pattern.at(i), qreal(0));\n        if (pen.widthF())\n            patternLength *= pen.widthF();\n        if (qFuzzyIsNull(patternLength)) {\n            pen.setStyle(Qt::NoPen);\n        } else if (qFuzzyIsNull(extent) || extent / patternLength > 10000) {\n            // approximate stream of tiny dashes with semi-transparent solid line\n            pen.setStyle(Qt::SolidLine);\n            QColor color(pen.color());\n            color.setAlpha(color.alpha() / 2);\n            pen.setColor(color);\n        }\n    }\n\n    if (!qpen_fast_equals(pen, d->strokerPen)) {\n        d->strokerPen = pen;\n        d->stroker.setJoinStyle(pen.joinStyle());\n        d->stroker.setCapStyle(pen.capStyle());\n        d->stroker.setMiterLimit(pen.miterLimit());\n        qreal penWidth = pen.widthF();\n        if (penWidth == 0)\n            d->stroker.setStrokeWidth(1);\n        else\n            d->stroker.setStrokeWidth(penWidth);\n\n        Qt::PenStyle style = pen.style();\n        if (style == Qt::SolidLine) {\n            d->activeStroker = &d->stroker;\n        } else if (style == Qt::NoPen) {\n            d->activeStroker = nullptr;\n        } else {\n            d->dasher.setDashPattern(pen.dashPattern());\n            d->dasher.setDashOffset(pen.dashOffset());\n            d->activeStroker = &d->dasher;\n        }\n    }\n\n    if (!d->activeStroker) {\n        return;\n    }\n\n    if (!clipRect.isNull())\n        d->activeStroker->setClipRect(clipRect);\n\n    if (d->activeStroker == &d->stroker)\n        d->stroker.setForceOpen(path.hasExplicitOpen());\n\n    const QPainterPath::ElementType *types = path.elements();\n    const qreal *points = path.points();\n    int pointCount = path.elementCount();\n\n    const qreal *lastPoint = points + (pointCount<<1);\n\n    d->strokeHandler->types.reset();\n    d->strokeHandler->pts.reset();\n\n    // Some engines might decide to optimize for the non-shape hint later on...\n    uint flags = QVectorPath::WindingFill;\n\n    if (path.elementCount() > 2)\n        flags |= QVectorPath::NonConvexShapeMask;\n\n    if (d->stroker.capStyle() == Qt::RoundCap || d->stroker.joinStyle() == Qt::RoundJoin)\n        flags |= QVectorPath::CurvedShapeMask;\n\n    // ### Perspective Xforms are currently not supported...\n    if (!pen.isCosmetic()) {\n        // We include cosmetic pens in this case to avoid having to\n        // change the current transform. Normal transformed,\n        // non-cosmetic pens will be transformed as part of fill\n        // later, so they are also covered here..\n        d->activeStroker->setCurveThresholdFromTransform(state()->matrix);\n        d->activeStroker->begin(d->strokeHandler);\n        if (types) {\n            while (points < lastPoint) {\n                switch (*types) {\n                case QPainterPath::MoveToElement:\n                    d->activeStroker->moveTo(points[0], points[1]);\n                    points += 2;\n                    ++types;\n                    break;\n                case QPainterPath::LineToElement:\n                    d->activeStroker->lineTo(points[0], points[1]);\n                    points += 2;\n                    ++types;\n                    break;\n                case QPainterPath::CurveToElement:\n                    d->activeStroker->cubicTo(points[0], points[1],\n                                              points[2], points[3],\n                                              points[4], points[5]);\n                    points += 6;\n                    types += 3;\n                    flags |= QVectorPath::CurvedShapeMask;\n                    break;\n                default:\n                    break;\n                }\n            }\n            if (path.hasImplicitClose())\n                d->activeStroker->lineTo(path.points()[0], path.points()[1]);\n\n        } else {\n            d->activeStroker->moveTo(points[0], points[1]);\n            points += 2;\n            while (points < lastPoint) {\n                d->activeStroker->lineTo(points[0], points[1]);\n                points += 2;\n            }\n            if (path.hasImplicitClose())\n                d->activeStroker->lineTo(path.points()[0], path.points()[1]);\n        }\n        d->activeStroker->end();\n\n        if (!d->strokeHandler->types.size()) // an empty path...\n            return;\n\n        QVectorPath strokePath(d->strokeHandler->pts.data(),\n                               d->strokeHandler->types.size(),\n                               d->strokeHandler->types.data(),\n                               flags);\n        fill(strokePath, pen.brush());\n    } else {\n        // For cosmetic pens we need a bit of trickery... We to process xform the input points\n        if (state()->matrix.type() >= QTransform::TxProject) {\n            QPainterPath painterPath = state()->matrix.map(path.convertToPainterPath());\n            d->activeStroker->strokePath(painterPath, d->strokeHandler, QTransform());\n        } else {\n            d->activeStroker->setCurveThresholdFromTransform(QTransform());\n            d->activeStroker->begin(d->strokeHandler);\n            if (types) {\n                while (points < lastPoint) {\n                    switch (*types) {\n                    case QPainterPath::MoveToElement: {\n                        QPointF pt = (*(const QPointF *) points) * state()->matrix;\n                        d->activeStroker->moveTo(pt.x(), pt.y());\n                        points += 2;\n                        ++types;\n                        break;\n                    }\n                    case QPainterPath::LineToElement: {\n                        QPointF pt = (*(const QPointF *) points) * state()->matrix;\n                        d->activeStroker->lineTo(pt.x(), pt.y());\n                        points += 2;\n                        ++types;\n                        break;\n                    }\n                    case QPainterPath::CurveToElement: {\n                        QPointF c1 = ((const QPointF *) points)[0] * state()->matrix;\n                        QPointF c2 = ((const QPointF *) points)[1] * state()->matrix;\n                        QPointF e =  ((const QPointF *) points)[2] * state()->matrix;\n                        d->activeStroker->cubicTo(c1.x(), c1.y(), c2.x(), c2.y(), e.x(), e.y());\n                        points += 6;\n                        types += 3;\n                        flags |= QVectorPath::CurvedShapeMask;\n                        break;\n                    }\n                    default:\n                        break;\n                    }\n                }\n                if (path.hasImplicitClose()) {\n                    QPointF pt = * ((const QPointF *) path.points()) * state()->matrix;\n                    d->activeStroker->lineTo(pt.x(), pt.y());\n                }\n\n            } else {\n                QPointF p = ((const QPointF *)points)[0] * state()->matrix;\n                d->activeStroker->moveTo(p.x(), p.y());\n                points += 2;\n                while (points < lastPoint) {\n                    QPointF p = ((const QPointF *)points)[0] * state()->matrix;\n                    d->activeStroker->lineTo(p.x(), p.y());\n                    points += 2;\n                }\n                if (path.hasImplicitClose())\n                    d->activeStroker->lineTo(p.x(), p.y());\n            }\n            d->activeStroker->end();\n        }\n\n        QVectorPath strokePath(d->strokeHandler->pts.data(),\n                               d->strokeHandler->types.size(),\n                               d->strokeHandler->types.data(),\n                               flags);\n\n        QTransform xform = state()->matrix;\n        state()->matrix = QTransform();\n        transformChanged();\n\n        QBrush brush = pen.brush();\n        if (qbrush_style(brush) != Qt::SolidPattern)\n            brush.setTransform(brush.transform() * xform);\n\n        fill(strokePath, brush);\n\n        state()->matrix = xform;\n        transformChanged();\n    }\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <qdebug.h>\n#include \"qpainter_p.h\"\n#include <private/qpainterpath_p.h>\n#include \"qpaintengineex_p.h\"\n#include <private/qstatictext_p.h>\n#include <qvarlengtharray.h>\n#include \"qstroker_p.h\"\n#include \"qbezier_p.h\"\n#include <private/qfontengine_p.h>\n\n// Type Definitions:\n// QVectorPath:\nfriend class QVectorPath\n\n// uint:\ntypedef unsigned int uint;\n\n// QPainterPath:\nQPainterPath.QPainterPath:ANY(QPainterPath&)\n\n// ElementType:\nenum ElementType {\n        // universal\n        BooleanType = 0x01,\n        IntegerType  = 0x02,\n        BitStringType  = 0x03,\n        OctetStringType = 0x04,\n        NullType = 0x05,\n        ObjectIdentifierType = 0x06,\n        Utf8StringType = 0x0c,\n        PrintableStringType = 0x13,\n        TeletexStringType = 0x14,\n        UtcTimeType = 0x17,\n        GeneralizedTimeType = 0x18,\n        SequenceType = 0x30,\n        SetType = 0x31,\n\n        // GeneralNameTypes\n        Rfc822NameType = 0x81,\n        DnsNameType = 0x82,\n        UniformResourceIdentifierType = 0x86,\n        IpAddressType = 0x87,\n\n        // context specific\n        Context0Type = 0xA0,\n        Context1Type = 0xA1,\n        Context3Type = 0xA3\n    }\n\n// QPen:\nQPen.QPen:ANY(QBrush&,qreal,Qt.PenStyle,Qt.PenCapStyle,Qt.PenJoinStyle)\n\n// QPaintEngineExPrivate:\nQPaintEngineExPrivate.QPaintEngineExPrivate:ANY()\n\n// QBrush:\nQBrush.QBrush:ANY(Qt.GlobalColor,Qt.BrushStyle)\n\n// StrokeHandler:\nstruct StrokeHandler {\n    StrokeHandler(int reserve) : pts(reserve), types(reserve) {}\n    QDataBuffer<qreal> pts;\n    QDataBuffer<QPainterPath::ElementType> types;\n}\n\n// QTransform:\nfriend class QTransform\n\n// PenStyle:\nenum PenStyle { // pen style\n        NoPen,\n        SolidLine,\n        DashLine,\n        DotLine,\n        DashDotLine,\n        DashDotDotLine,\n        CustomDashLine\n#ifndef Q_MOC_RUN\n        , MPenStyle = 0x0f\n#endif\n    }\n\n// QColor:\nQColor.QColor:ANY(Qt.GlobalColor)\n\n// QRectF:\nQRectF.QRectF:ANY(qreal,qreal,qreal,qreal)\n\n// QPointF:\nclass QPointF\n{\npublic:\n    constexpr QPointF() noexcept;\n    constexpr QPointF(const QPoint &p) noexcept;\n    constexpr QPointF(qreal xpos, qreal ypos) noexcept;\n\n    constexpr inline qreal manhattanLength() const;\n\n    inline bool isNull() const noexcept;\n\n    constexpr inline qreal x() const noexcept;\n    constexpr inline qreal y() const noexcept;\n    constexpr inline void setX(qreal x) noexcept;\n    constexpr inline void setY(qreal y) noexcept;\n\n    constexpr QPointF transposed() const noexcept { return {yp, xp}; }\n\n    constexpr inline qreal &rx() noexcept;\n    constexpr inline qreal &ry() noexcept;\n\n    constexpr inline QPointF &operator+=(const QPointF &p);\n    constexpr inline QPointF &operator-=(const QPointF &p);\n    constexpr inline QPointF &operator*=(qreal c);\n    constexpr inline QPointF &operator/=(qreal c);\n\n    constexpr static inline qreal dotProduct(const QPointF &p1, const QPointF &p2)\n    {\n        return p1.xp * p2.xp + p1.yp * p2.yp;\n    }\n\n    QT_WARNING_PUSH...\n\n// QList:\nclass QList\n#ifndef Q_QDOC\n    : public QListSpecialMethods<T>\n#endif\n{\n    using Data = QTypedArrayData<T>;\n    using DataOps = QArrayDataOps<T>;\n    using DataPointer = QArrayDataPointer<T>;\n    class DisableRValueRefs {};\n\n    DataPointer d;\n\n    template <typename V, typename U> friend qsizetype QtPrivate::indexOf(const QList<V> &list, const U &u, qsizetype from) noexcept;\n    template <typename V, typename U> friend qsizetype QtPrivate::lastIndexOf(const QList<V> &list, const U &u, qsizetype from) noexcept;\n\npublic:\n    using Type = T;\n    using value_type = T;\n    using pointer = T *;\n    using const_pointer = const T *;\n    using reference = T &;\n    using const_reference = const T &;\n    using size_type = qsizetype;\n    using difference_type = qptrdiff;\n#ifndef Q_QDOC\n    using parameter_type = typename DataPointer::parameter_type;\n    using rvalue_ref = typename std::conditional<DataPointer::pass_parameter_by_value, DisableRValueRefs, T &&>::type;\n#else  // simplified alias...\n\n// QPaintEngineEx:\nQPaintEngineEx.QPaintEngineEx:ANY()\n\n// QPaintEngineEx:\nQPaintEngineEx.QPaintEngineEx:ANY(QPaintEngineExPrivate&)\n\n// QRectF:\nQRectF\n\n// qreal:\ntypedef QT_COORD_TYPE qreal;\n\n// QPen:\nQPen.QPen:ANY(Qt.PenStyle)\n\n// Called Methods (top 10):\n// Q_D from src/gui/painting/private/QtCore/private/qglobal.h:\n\n"
  },
  {
    "repository": "firejail",
    "cve_id": "CVE-2022-31214",
    "cwe_list": [
      "CWE-94"
    ],
    "commit_hash": "1884ea22a90d225950d81c804f1771b42ae55f54",
    "short_hash": "1884ea22",
    "vulnerableMethods_before": [
      {
        "filename": "None",
        "method_name": "vulnerable_function",
        "raw_code": "static void build_dirs(char *src, char *dst, size_t src_prefix_len, size_t dst_prefix_len) {\n\tchar *p = src + src_prefix_len + 1;\n\tchar *q = dst + dst_prefix_len + 1;\n\tchar *r = dst + dst_prefix_len;\n\tstruct stat s;\n\tbool last = false;\n\t*r = '\\0';\n\tfor (; !last; p++, q++) {\n\t\tif (*p == '\\0') {\n\t\t\tlast = true;\n\t\t}\n\t\tif (*p == '\\0' || (*p == '/' && *(p - 1) != '/')) {\n\t\t\t// We found a new component of our src path.\n\t\t\t// Null-terminate it temporarily here so that we can work\n\t\t\t// with it.\n\t\t\t*p = '\\0';\n\t\t\tif (stat(src, &s) == 0 && S_ISDIR(s.st_mode)) {\n\t\t\t\t// Null-terminate the dst path and undo its previous\n\t\t\t\t// termination.\n\t\t\t\t*q = '\\0';\n\t\t\t\t*r = '/';\n\t\t\t\tr = q;\n\t\t\t\tmkdir_attr(dst, s.st_mode, 0, 0);\n\t\t\t}\n\t\t\tif (!last) {\n\t\t\t\t// If we're not at the final terminating null, restore\n\t\t\t\t// the slash so that we can continue our traversal.\n\t\t\t\t*p = '/';\n\t\t\t}\n\t\t}\n\t}\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "None",
        "method_name": "fixed_function",
        "raw_code": "static void build_dirs(char *src, char *dst, size_t src_prefix_len, size_t dst_prefix_len) {\n\tchar *p = src + src_prefix_len + 1;\n\tchar *q = dst + dst_prefix_len + 1;\n\tchar *r = dst + dst_prefix_len;\n\tstruct stat s;\n\tbool last = false;\n\t*r = '\\0';\n\tfor (; !last; p++, q++) {\n\t\tif (*p == '\\0') {\n\t\t\tlast = true;\n\t\t}\n\t\tif (*p == '\\0' || (*p == '/' && *(p - 1) != '/')) {\n\t\t\t// We found a new component of our src path.\n\t\t\t// Null-terminate it temporarily here so that we can work\n\t\t\t// with it.\n\t\t\t*p = '\\0';\n\t\t\tif (stat(src, &s) == 0 && S_ISDIR(s.st_mode)) {\n\t\t\t\t// Null-terminate the dst path and undo its previous\n\t\t\t\t// termination.\n\t\t\t\t*q = '\\0';\n\t\t\t\t*r = '/';\n\t\t\t\tr = q;\n\t\t\t\tif (mkdir(dst, 0700) != 0 && errno != EEXIST)\n\t\t\t\t\terrExit(\"mkdir\");\n\t\t\t\tif (chmod(dst, s.st_mode) != 0)\n\t\t\t\t\terrExit(\"chmod\");\n\t\t\t}\n\t\t\tif (!last) {\n\t\t\t\t// If we're not at the final terminating null, restore\n\t\t\t\t// the slash so that we can continue our traversal.\n\t\t\t\t*p = '/';\n\t\t\t}\n\t\t}\n\t}\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <dirent.h>\n#include <time.h>\n#include \"firejail.h\"\n#include <errno.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n\n// Type Definitions:\n// stat:\nstat\n\n// Called Methods (top 10):\n// errExit from src/include/common.h:\n<empty>\n\n// errExit from src/include/common.h:\n#define errExit(msg)    do { char msgout[500]; snprintf(msgout, 500, \"Error %s: %s:%d %s\", msg, __FILE__, __LINE__, __FUNCTION__); perror(msgout); exit(1);} while (0) /* <=== src/include/common.h:39:39:errExit:1 */ \n\n// stat from src/libtrace/libtrace.c:\nint stat(const char *pathname, struct stat *statbuf) {\n\tif (!orig_stat)\n\t\torig_stat = (orig_stat_t)dlsym(RTLD_NEXT, \"stat\");\n\n\tint rv = orig_stat(pathname, statbuf);\n\ttprintf(ftty, \"%u:%s:stat %s:%d\\n\", mypid, myname, pathname, rv);\n\treturn rv;\n}\n\n// tprintf from src/libtrace/libtrace.c:\n#define tprintf(fp, args...) \\ /* <=== src/libtrace/libtrace.c:37:42:tprintf:2 */ \n    do { \\\n        if (!fp)\\\n            init(); \\\n        fprintf(fp, args); \\\n    } while(0)\n\n// mkdir from src/libtrace/libtrace.c:\nint mkdir(const char *pathname, mode_t mode) {\n\tif (!orig_mkdir)\n\t\torig_mkdir = (orig_mkdir_t)dlsym(RTLD_NEXT, \"mkdir\");\n\n\tint rv = orig_mkdir(pathname, mode);\n\ttprintf(ftty, \"%u:%s:mkdir %s:%d\\n\", mypid, myname, pathname, rv);\n\treturn rv;\n}\n\n// init from src/fids/blake2b.c:\nstatic int init(CTX *ctx, size_t outlen) {      // (keylen=0: no key) /* <=== init */ \n\tsize_t i;\n\n\tif (outlen == 0 || outlen > 64)\n\t\treturn -1;\n\n\tfor (i = 0; i < 8; i++)\n\t\tctx->h[i] = iv[i];\n\tctx->h[0] ^= 0x01010000  ^ outlen;\n\n\tctx->t[0] = 0;\n\tctx->t[1] = 0;\n\tctx->c = 0;\n\tctx->outlen = outlen;\n\n\treturn 0;\n}\n\n// mkdir from src/libtrace/libtrace.c:\nint mkdir(const char *pathname, mode_t mode) { /* <=== mkdir */ \n\tif (!orig_mkdir)\n\t\torig_mkdir = (orig_mkdir_t)dlsym(RTLD_NEXT, \"mkdir\");\n\n\tint rv = orig_mkdir(pathname, mode);\n\ttprintf(ftty, \"%u:%s:mkdir %s:%d\\n\", mypid, myname, pathname, rv);\n\treturn rv;\n}\n\n// mkdir_attr from src/fcopy/main.c:\nstatic void mkdir_attr(const char *fname, mode_t mode, uid_t uid, gid_t gid) {\n\tassert(fname);\n\tmode &= 07777;\n\n\tif (mkdir(fname, mode) == -1 ||\n\tchmod(fname, mode) == -1) {\n\t\tfprintf(stderr, \"Error fcopy: failed to create %s directory\\n\", fname);\n\t\terrExit(\"mkdir/chmod\");\n\t}\n\tif (chown(fname, uid, gid)) {\n\t\tif (!arg_quiet)\n\t\t\tfprintf(stderr, \"Warning fcopy: failed to change ownership of %s\\n\", fname);\n\t}\n}\n"
  },
  {
    "repository": "vim",
    "cve_id": "CVE-2021-3903",
    "cwe_list": [
      "CWE-122"
    ],
    "commit_hash": "777e7c21b7627be80961848ac560cb0a9978ff43",
    "short_hash": "777e7c21",
    "vulnerableMethods_before": [
      {
        "filename": "move.c",
        "method_name": "vulnerable_function",
        "raw_code": "update_topline(void)\n{\n    long\tline_count;\n    int\t\thalfheight;\n    int\t\tn;\n    linenr_T\told_topline;\n#ifdef FEAT_DIFF\n    int\t\told_topfill;\n#endif\n#ifdef FEAT_FOLDING\n    linenr_T\tlnum;\n#endif\n    int\t\tcheck_topline = FALSE;\n    int\t\tcheck_botline = FALSE;\n    long        *so_ptr = curwin->w_p_so >= 0 ? &curwin->w_p_so : &p_so;\n    int\t\tsave_so = *so_ptr;\n\n    // If there is no valid screen and when the window height is zero just use\n    // the cursor line.\n    if (!screen_valid(TRUE) || curwin->w_height == 0)\n    {\n\tcheck_cursor_lnum();\n\tcurwin->w_topline = curwin->w_cursor.lnum;\n\tcurwin->w_botline = curwin->w_topline;\n\tcurwin->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;\n\tcurwin->w_scbind_pos = 1;\n\treturn;\n    }\n\n    check_cursor_moved(curwin);\n    if (curwin->w_valid & VALID_TOPLINE)\n\treturn;\n\n    // When dragging with the mouse, don't scroll that quickly\n    if (mouse_dragging > 0)\n\t*so_ptr = mouse_dragging - 1;\n\n    old_topline = curwin->w_topline;\n#ifdef FEAT_DIFF\n    old_topfill = curwin->w_topfill;\n#endif\n\n    /*\n     * If the buffer is empty, always set topline to 1.\n     */\n    if (BUFEMPTY())\t\t// special case - file is empty\n    {\n\tif (curwin->w_topline != 1)\n\t    redraw_later(NOT_VALID);\n\tcurwin->w_topline = 1;\n\tcurwin->w_botline = 2;\n\tcurwin->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;\n\tcurwin->w_scbind_pos = 1;\n    }\n\n    /*\n     * If the cursor is above or near the top of the window, scroll the window\n     * to show the line the cursor is in, with 'scrolloff' context.\n     */\n    else\n    {\n\tif (curwin->w_topline > 1)\n\t{\n\t    // If the cursor is above topline, scrolling is always needed.\n\t    // If the cursor is far below topline and there is no folding,\n\t    // scrolling down is never needed.\n\t    if (curwin->w_cursor.lnum < curwin->w_topline)\n\t\tcheck_topline = TRUE;\n\t    else if (check_top_offset())\n\t\tcheck_topline = TRUE;\n\t}\n#ifdef FEAT_DIFF\n\t    // Check if there are more filler lines than allowed.\n\tif (!check_topline && curwin->w_topfill > diff_check_fill(curwin,\n\t\t\t\t\t\t\t   curwin->w_topline))\n\t    check_topline = TRUE;\n#endif\n\n\tif (check_topline)\n\t{\n\t    halfheight = curwin->w_height / 2 - 1;\n\t    if (halfheight < 2)\n\t\thalfheight = 2;\n\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\t// Count the number of logical lines between the cursor and\n\t\t// topline + scrolloff (approximation of how much will be\n\t\t// scrolled).\n\t\tn = 0;\n\t\tfor (lnum = curwin->w_cursor.lnum;\n\t\t\t\t    lnum < curwin->w_topline + *so_ptr; ++lnum)\n\t\t{\n\t\t    ++n;\n\t\t    // stop at end of file or when we know we are far off\n\t\t    if (lnum >= curbuf->b_ml.ml_line_count || n >= halfheight)\n\t\t\tbreak;\n\t\t    (void)hasFolding(lnum, NULL, &lnum);\n\t\t}\n\t    }\n\t    else\n#endif\n\t\tn = curwin->w_topline + *so_ptr - curwin->w_cursor.lnum;\n\n\t    // If we weren't very close to begin with, we scroll to put the\n\t    // cursor in the middle of the window.  Otherwise put the cursor\n\t    // near the top of the window.\n\t    if (n >= halfheight)\n\t\tscroll_cursor_halfway(FALSE);\n\t    else\n\t    {\n\t\tscroll_cursor_top(scrolljump_value(), FALSE);\n\t\tcheck_botline = TRUE;\n\t    }\n\t}\n\n\telse\n\t{\n#ifdef FEAT_FOLDING\n\t    // Make sure topline is the first line of a fold.\n\t    (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n\t    check_botline = TRUE;\n\t}\n    }\n\n    /*\n     * If the cursor is below the bottom of the window, scroll the window\n     * to put the cursor on the window.\n     * When w_botline is invalid, recompute it first, to avoid a redraw later.\n     * If w_botline was approximated, we might need a redraw later in a few\n     * cases, but we don't want to spend (a lot of) time recomputing w_botline\n     * for every small change.\n     */\n    if (check_botline)\n    {\n\tif (!(curwin->w_valid & VALID_BOTLINE_AP))\n\t    validate_botline();\n\n\tif (curwin->w_botline <= curbuf->b_ml.ml_line_count)\n\t{\n\t    if (curwin->w_cursor.lnum < curwin->w_botline)\n\t    {\n\t      if (((long)curwin->w_cursor.lnum\n\t\t\t\t\t     >= (long)curwin->w_botline - *so_ptr\n#ifdef FEAT_FOLDING\n\t\t\t|| hasAnyFolding(curwin)\n#endif\n\t\t\t))\n\t      {\n\t\tlineoff_T\tloff;\n\n\t\t// Cursor is (a few lines) above botline, check if there are\n\t\t// 'scrolloff' window lines below the cursor.  If not, need to\n\t\t// scroll.\n\t\tn = curwin->w_empty_rows;\n\t\tloff.lnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n\t\t// In a fold go to its last line.\n\t\t(void)hasFolding(loff.lnum, NULL, &loff.lnum);\n#endif\n#ifdef FEAT_DIFF\n\t\tloff.fill = 0;\n\t\tn += curwin->w_filler_rows;\n#endif\n\t\tloff.height = 0;\n\t\twhile (loff.lnum < curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t\t&& (loff.lnum + 1 < curwin->w_botline || loff.fill == 0)\n#endif\n\t\t\t)\n\t\t{\n\t\t    n += loff.height;\n\t\t    if (n >= *so_ptr)\n\t\t\tbreak;\n\t\t    botline_forw(&loff);\n\t\t}\n\t\tif (n >= *so_ptr)\n\t\t    // sufficient context, no need to scroll\n\t\t    check_botline = FALSE;\n\t      }\n\t      else\n\t\t  // sufficient context, no need to scroll\n\t\t  check_botline = FALSE;\n\t    }\n\t    if (check_botline)\n\t    {\n#ifdef FEAT_FOLDING\n\t\tif (hasAnyFolding(curwin))\n\t\t{\n\t\t    // Count the number of logical lines between the cursor and\n\t\t    // botline - scrolloff (approximation of how much will be\n\t\t    // scrolled).\n\t\t    line_count = 0;\n\t\t    for (lnum = curwin->w_cursor.lnum;\n\t\t\t\t   lnum >= curwin->w_botline - *so_ptr; --lnum)\n\t\t    {\n\t\t\t++line_count;\n\t\t\t// stop at end of file or when we know we are far off\n\t\t\tif (lnum <= 0 || line_count > curwin->w_height + 1)\n\t\t\t    break;\n\t\t\t(void)hasFolding(lnum, &lnum, NULL);\n\t\t    }\n\t\t}\n\t\telse\n#endif\n\t\t    line_count = curwin->w_cursor.lnum - curwin->w_botline\n\t\t\t\t\t\t\t\t   + 1 + *so_ptr;\n\t\tif (line_count <= curwin->w_height + 1)\n\t\t    scroll_cursor_bot(scrolljump_value(), FALSE);\n\t\telse\n\t\t    scroll_cursor_halfway(FALSE);\n\t    }\n\t}\n    }\n    curwin->w_valid |= VALID_TOPLINE;\n\n    /*\n     * Need to redraw when topline changed.\n     */\n    if (curwin->w_topline != old_topline\n#ifdef FEAT_DIFF\n\t    || curwin->w_topfill != old_topfill\n#endif\n\t    )\n    {\n\tdollar_vcol = -1;\n\tif (curwin->w_skipcol != 0)\n\t{\n\t    curwin->w_skipcol = 0;\n\t    redraw_later(NOT_VALID);\n\t}\n\telse\n\t    redraw_later(VALID);\n\t// May need to set w_skipcol when cursor in w_topline.\n\tif (curwin->w_cursor.lnum == curwin->w_topline)\n\t    validate_cursor();\n    }\n\n    *so_ptr = save_so;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "move.c",
        "method_name": "fixed_function",
        "raw_code": "update_topline(void)\n{\n    long\tline_count;\n    int\t\thalfheight;\n    int\t\tn;\n    linenr_T\told_topline;\n#ifdef FEAT_DIFF\n    int\t\told_topfill;\n#endif\n#ifdef FEAT_FOLDING\n    linenr_T\tlnum;\n#endif\n    int\t\tcheck_topline = FALSE;\n    int\t\tcheck_botline = FALSE;\n    long        *so_ptr = curwin->w_p_so >= 0 ? &curwin->w_p_so : &p_so;\n    int\t\tsave_so = *so_ptr;\n\n    // If there is no valid screen and when the window height is zero just use\n    // the cursor line.\n    if (!screen_valid(TRUE) || curwin->w_height == 0)\n    {\n\tcheck_cursor_lnum();\n\tcurwin->w_topline = curwin->w_cursor.lnum;\n\tcurwin->w_botline = curwin->w_topline;\n\tcurwin->w_scbind_pos = 1;\n\treturn;\n    }\n\n    check_cursor_moved(curwin);\n    if (curwin->w_valid & VALID_TOPLINE)\n\treturn;\n\n    // When dragging with the mouse, don't scroll that quickly\n    if (mouse_dragging > 0)\n\t*so_ptr = mouse_dragging - 1;\n\n    old_topline = curwin->w_topline;\n#ifdef FEAT_DIFF\n    old_topfill = curwin->w_topfill;\n#endif\n\n    /*\n     * If the buffer is empty, always set topline to 1.\n     */\n    if (BUFEMPTY())\t\t// special case - file is empty\n    {\n\tif (curwin->w_topline != 1)\n\t    redraw_later(NOT_VALID);\n\tcurwin->w_topline = 1;\n\tcurwin->w_botline = 2;\n\tcurwin->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;\n\tcurwin->w_scbind_pos = 1;\n    }\n\n    /*\n     * If the cursor is above or near the top of the window, scroll the window\n     * to show the line the cursor is in, with 'scrolloff' context.\n     */\n    else\n    {\n\tif (curwin->w_topline > 1)\n\t{\n\t    // If the cursor is above topline, scrolling is always needed.\n\t    // If the cursor is far below topline and there is no folding,\n\t    // scrolling down is never needed.\n\t    if (curwin->w_cursor.lnum < curwin->w_topline)\n\t\tcheck_topline = TRUE;\n\t    else if (check_top_offset())\n\t\tcheck_topline = TRUE;\n\t}\n#ifdef FEAT_DIFF\n\t    // Check if there are more filler lines than allowed.\n\tif (!check_topline && curwin->w_topfill > diff_check_fill(curwin,\n\t\t\t\t\t\t\t   curwin->w_topline))\n\t    check_topline = TRUE;\n#endif\n\n\tif (check_topline)\n\t{\n\t    halfheight = curwin->w_height / 2 - 1;\n\t    if (halfheight < 2)\n\t\thalfheight = 2;\n\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\t// Count the number of logical lines between the cursor and\n\t\t// topline + scrolloff (approximation of how much will be\n\t\t// scrolled).\n\t\tn = 0;\n\t\tfor (lnum = curwin->w_cursor.lnum;\n\t\t\t\t    lnum < curwin->w_topline + *so_ptr; ++lnum)\n\t\t{\n\t\t    ++n;\n\t\t    // stop at end of file or when we know we are far off\n\t\t    if (lnum >= curbuf->b_ml.ml_line_count || n >= halfheight)\n\t\t\tbreak;\n\t\t    (void)hasFolding(lnum, NULL, &lnum);\n\t\t}\n\t    }\n\t    else\n#endif\n\t\tn = curwin->w_topline + *so_ptr - curwin->w_cursor.lnum;\n\n\t    // If we weren't very close to begin with, we scroll to put the\n\t    // cursor in the middle of the window.  Otherwise put the cursor\n\t    // near the top of the window.\n\t    if (n >= halfheight)\n\t\tscroll_cursor_halfway(FALSE);\n\t    else\n\t    {\n\t\tscroll_cursor_top(scrolljump_value(), FALSE);\n\t\tcheck_botline = TRUE;\n\t    }\n\t}\n\n\telse\n\t{\n#ifdef FEAT_FOLDING\n\t    // Make sure topline is the first line of a fold.\n\t    (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);\n#endif\n\t    check_botline = TRUE;\n\t}\n    }\n\n    /*\n     * If the cursor is below the bottom of the window, scroll the window\n     * to put the cursor on the window.\n     * When w_botline is invalid, recompute it first, to avoid a redraw later.\n     * If w_botline was approximated, we might need a redraw later in a few\n     * cases, but we don't want to spend (a lot of) time recomputing w_botline\n     * for every small change.\n     */\n    if (check_botline)\n    {\n\tif (!(curwin->w_valid & VALID_BOTLINE_AP))\n\t    validate_botline();\n\n\tif (curwin->w_botline <= curbuf->b_ml.ml_line_count)\n\t{\n\t    if (curwin->w_cursor.lnum < curwin->w_botline)\n\t    {\n\t      if (((long)curwin->w_cursor.lnum\n\t\t\t\t\t     >= (long)curwin->w_botline - *so_ptr\n#ifdef FEAT_FOLDING\n\t\t\t|| hasAnyFolding(curwin)\n#endif\n\t\t\t))\n\t      {\n\t\tlineoff_T\tloff;\n\n\t\t// Cursor is (a few lines) above botline, check if there are\n\t\t// 'scrolloff' window lines below the cursor.  If not, need to\n\t\t// scroll.\n\t\tn = curwin->w_empty_rows;\n\t\tloff.lnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n\t\t// In a fold go to its last line.\n\t\t(void)hasFolding(loff.lnum, NULL, &loff.lnum);\n#endif\n#ifdef FEAT_DIFF\n\t\tloff.fill = 0;\n\t\tn += curwin->w_filler_rows;\n#endif\n\t\tloff.height = 0;\n\t\twhile (loff.lnum < curwin->w_botline\n#ifdef FEAT_DIFF\n\t\t\t&& (loff.lnum + 1 < curwin->w_botline || loff.fill == 0)\n#endif\n\t\t\t)\n\t\t{\n\t\t    n += loff.height;\n\t\t    if (n >= *so_ptr)\n\t\t\tbreak;\n\t\t    botline_forw(&loff);\n\t\t}\n\t\tif (n >= *so_ptr)\n\t\t    // sufficient context, no need to scroll\n\t\t    check_botline = FALSE;\n\t      }\n\t      else\n\t\t  // sufficient context, no need to scroll\n\t\t  check_botline = FALSE;\n\t    }\n\t    if (check_botline)\n\t    {\n#ifdef FEAT_FOLDING\n\t\tif (hasAnyFolding(curwin))\n\t\t{\n\t\t    // Count the number of logical lines between the cursor and\n\t\t    // botline - scrolloff (approximation of how much will be\n\t\t    // scrolled).\n\t\t    line_count = 0;\n\t\t    for (lnum = curwin->w_cursor.lnum;\n\t\t\t\t   lnum >= curwin->w_botline - *so_ptr; --lnum)\n\t\t    {\n\t\t\t++line_count;\n\t\t\t// stop at end of file or when we know we are far off\n\t\t\tif (lnum <= 0 || line_count > curwin->w_height + 1)\n\t\t\t    break;\n\t\t\t(void)hasFolding(lnum, &lnum, NULL);\n\t\t    }\n\t\t}\n\t\telse\n#endif\n\t\t    line_count = curwin->w_cursor.lnum - curwin->w_botline\n\t\t\t\t\t\t\t\t   + 1 + *so_ptr;\n\t\tif (line_count <= curwin->w_height + 1)\n\t\t    scroll_cursor_bot(scrolljump_value(), FALSE);\n\t\telse\n\t\t    scroll_cursor_halfway(FALSE);\n\t    }\n\t}\n    }\n    curwin->w_valid |= VALID_TOPLINE;\n\n    /*\n     * Need to redraw when topline changed.\n     */\n    if (curwin->w_topline != old_topline\n#ifdef FEAT_DIFF\n\t    || curwin->w_topfill != old_topfill\n#endif\n\t    )\n    {\n\tdollar_vcol = -1;\n\tif (curwin->w_skipcol != 0)\n\t{\n\t    curwin->w_skipcol = 0;\n\t    redraw_later(NOT_VALID);\n\t}\n\telse\n\t    redraw_later(VALID);\n\t// May need to set w_skipcol when cursor in w_topline.\n\tif (curwin->w_cursor.lnum == curwin->w_topline)\n\t    validate_cursor();\n    }\n\n    *so_ptr = save_so;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"vim.h\"\n\n// Called Methods (top 10):\n// screen_valid from src/screen.c:\nint\nscreen_valid(int doclear)\n{\n    screenalloc(doclear);\t   // allocate screen buffers if size changed\n    return (ScreenLines != NULL);\n}\n\n// VALID_BOTLINE_AP from src/vim.h:\n<empty>\n\n// TRUE from src/vim.h:\n<empty>\n\n// VALID_BOTLINE from src/vim.h:\n<empty>\n"
  },
  {
    "repository": "vim",
    "cve_id": "CVE-2022-0714",
    "cwe_list": [
      "CWE-787"
    ],
    "commit_hash": "4e889f98e95ac05d7c8bd3ee933ab4d47820fdfa",
    "short_hash": "4e889f98",
    "vulnerableMethods_before": [
      {
        "filename": "indent.c",
        "method_name": "vulnerable_function",
        "raw_code": "change_indent(\n    int\t\ttype,\n    int\t\tamount,\n    int\t\tround,\n    int\t\treplaced,\t// replaced character, put on replace stack\n    int\t\tcall_changed_bytes)\t// call changed_bytes()\n{\n    int\t\tvcol;\n    int\t\tlast_vcol;\n    int\t\tinsstart_less;\t\t// reduction for Insstart.col\n    int\t\tnew_cursor_col;\n    int\t\ti;\n    char_u\t*ptr;\n    int\t\tsave_p_list;\n    int\t\tstart_col;\n    colnr_T\tvc;\n    colnr_T\torig_col = 0;\t\t// init for GCC\n    char_u\t*new_line, *orig_line = NULL;\t// init for GCC\n\n    // VREPLACE mode needs to know what the line was like before changing\n    if (State & VREPLACE_FLAG)\n    {\n\torig_line = vim_strsave(ml_get_curline());  // Deal with NULL below\n\torig_col = curwin->w_cursor.col;\n    }\n\n    // for the following tricks we don't want list mode\n    save_p_list = curwin->w_p_list;\n    curwin->w_p_list = FALSE;\n    vc = getvcol_nolist(&curwin->w_cursor);\n    vcol = vc;\n\n    // For Replace mode we need to fix the replace stack later, which is only\n    // possible when the cursor is in the indent.  Remember the number of\n    // characters before the cursor if it's possible.\n    start_col = curwin->w_cursor.col;\n\n    // determine offset from first non-blank\n    new_cursor_col = curwin->w_cursor.col;\n    beginline(BL_WHITE);\n    new_cursor_col -= curwin->w_cursor.col;\n\n    insstart_less = curwin->w_cursor.col;\n\n    // If the cursor is in the indent, compute how many screen columns the\n    // cursor is to the left of the first non-blank.\n    if (new_cursor_col < 0)\n\tvcol = get_indent() - vcol;\n\n    if (new_cursor_col > 0)\t    // can't fix replace stack\n\tstart_col = -1;\n\n    // Set the new indent.  The cursor will be put on the first non-blank.\n    if (type == INDENT_SET)\n\t(void)set_indent(amount, call_changed_bytes ? SIN_CHANGED : 0);\n    else\n    {\n\tint\tsave_State = State;\n\n\t// Avoid being called recursively.\n\tif (State & VREPLACE_FLAG)\n\t    State = INSERT;\n\tshift_line(type == INDENT_DEC, round, 1, call_changed_bytes);\n\tState = save_State;\n    }\n    insstart_less -= curwin->w_cursor.col;\n\n    // Try to put cursor on same character.\n    // If the cursor is at or after the first non-blank in the line,\n    // compute the cursor column relative to the column of the first\n    // non-blank character.\n    // If we are not in insert mode, leave the cursor on the first non-blank.\n    // If the cursor is before the first non-blank, position it relative\n    // to the first non-blank, counted in screen columns.\n    if (new_cursor_col >= 0)\n    {\n\t// When changing the indent while the cursor is touching it, reset\n\t// Insstart_col to 0.\n\tif (new_cursor_col == 0)\n\t    insstart_less = MAXCOL;\n\tnew_cursor_col += curwin->w_cursor.col;\n    }\n    else if (!(State & INSERT))\n\tnew_cursor_col = curwin->w_cursor.col;\n    else\n    {\n\t// Compute the screen column where the cursor should be.\n\tvcol = get_indent() - vcol;\n\tcurwin->w_virtcol = (colnr_T)((vcol < 0) ? 0 : vcol);\n\n\t// Advance the cursor until we reach the right screen column.\n\tvcol = last_vcol = 0;\n\tnew_cursor_col = -1;\n\tptr = ml_get_curline();\n\twhile (vcol <= (int)curwin->w_virtcol)\n\t{\n\t    last_vcol = vcol;\n\t    if (has_mbyte && new_cursor_col >= 0)\n\t\tnew_cursor_col += (*mb_ptr2len)(ptr + new_cursor_col);\n\t    else\n\t\t++new_cursor_col;\n\t    vcol += lbr_chartabsize(ptr, ptr + new_cursor_col, (colnr_T)vcol);\n\t}\n\tvcol = last_vcol;\n\n\t// May need to insert spaces to be able to position the cursor on\n\t// the right screen column.\n\tif (vcol != (int)curwin->w_virtcol)\n\t{\n\t    curwin->w_cursor.col = (colnr_T)new_cursor_col;\n\t    i = (int)curwin->w_virtcol - vcol;\n\t    ptr = alloc(i + 1);\n\t    if (ptr != NULL)\n\t    {\n\t\tnew_cursor_col += i;\n\t\tptr[i] = NUL;\n\t\twhile (--i >= 0)\n\t\t    ptr[i] = ' ';\n\t\tins_str(ptr);\n\t\tvim_free(ptr);\n\t    }\n\t}\n\n\t// When changing the indent while the cursor is in it, reset\n\t// Insstart_col to 0.\n\tinsstart_less = MAXCOL;\n    }\n\n    curwin->w_p_list = save_p_list;\n\n    if (new_cursor_col <= 0)\n\tcurwin->w_cursor.col = 0;\n    else\n\tcurwin->w_cursor.col = (colnr_T)new_cursor_col;\n    curwin->w_set_curswant = TRUE;\n    changed_cline_bef_curs();\n\n    // May have to adjust the start of the insert.\n    if (State & INSERT)\n    {\n\tif (curwin->w_cursor.lnum == Insstart.lnum && Insstart.col != 0)\n\t{\n\t    if ((int)Insstart.col <= insstart_less)\n\t\tInsstart.col = 0;\n\t    else\n\t\tInsstart.col -= insstart_less;\n\t}\n\tif ((int)ai_col <= insstart_less)\n\t    ai_col = 0;\n\telse\n\t    ai_col -= insstart_less;\n    }\n\n    // For REPLACE mode, may have to fix the replace stack, if it's possible.\n    // If the number of characters before the cursor decreased, need to pop a\n    // few characters from the replace stack.\n    // If the number of characters before the cursor increased, need to push a\n    // few NULs onto the replace stack.\n    if (REPLACE_NORMAL(State) && start_col >= 0)\n    {\n\twhile (start_col > (int)curwin->w_cursor.col)\n\t{\n\t    replace_join(0);\t    // remove a NUL from the replace stack\n\t    --start_col;\n\t}\n\twhile (start_col < (int)curwin->w_cursor.col || replaced)\n\t{\n\t    replace_push(NUL);\n\t    if (replaced)\n\t    {\n\t\treplace_push(replaced);\n\t\treplaced = NUL;\n\t    }\n\t    ++start_col;\n\t}\n    }\n\n    // For VREPLACE mode, we also have to fix the replace stack.  In this case\n    // it is always possible because we backspace over the whole line and then\n    // put it back again the way we wanted it.\n    if (State & VREPLACE_FLAG)\n    {\n\t// If orig_line didn't allocate, just return.  At least we did the job,\n\t// even if you can't backspace.\n\tif (orig_line == NULL)\n\t    return;\n\n\t// Save new line\n\tnew_line = vim_strsave(ml_get_curline());\n\tif (new_line == NULL)\n\t    return;\n\n\t// We only put back the new line up to the cursor\n\tnew_line[curwin->w_cursor.col] = NUL;\n\n\t// Put back original line\n\tml_replace(curwin->w_cursor.lnum, orig_line, FALSE);\n\tcurwin->w_cursor.col = orig_col;\n\n\t// Backspace from cursor to start of line\n\tbackspace_until_column(0);\n\n\t// Insert new stuff into line again\n\tins_bytes(new_line);\n\n\tvim_free(new_line);\n    }\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "indent.c",
        "method_name": "fixed_function",
        "raw_code": "change_indent(\n    int\t\ttype,\n    int\t\tamount,\n    int\t\tround,\n    int\t\treplaced,\t// replaced character, put on replace stack\n    int\t\tcall_changed_bytes)\t// call changed_bytes()\n{\n    int\t\tvcol;\n    int\t\tlast_vcol;\n    int\t\tinsstart_less;\t\t// reduction for Insstart.col\n    int\t\tnew_cursor_col;\n    int\t\ti;\n    char_u\t*ptr;\n    int\t\tsave_p_list;\n    int\t\tstart_col;\n    colnr_T\tvc;\n    colnr_T\torig_col = 0;\t\t// init for GCC\n    char_u\t*new_line, *orig_line = NULL;\t// init for GCC\n\n    // VREPLACE mode needs to know what the line was like before changing\n    if (State & VREPLACE_FLAG)\n    {\n\torig_line = vim_strsave(ml_get_curline());  // Deal with NULL below\n\torig_col = curwin->w_cursor.col;\n    }\n\n    // for the following tricks we don't want list mode\n    save_p_list = curwin->w_p_list;\n    curwin->w_p_list = FALSE;\n    vc = getvcol_nolist(&curwin->w_cursor);\n    vcol = vc;\n\n    // For Replace mode we need to fix the replace stack later, which is only\n    // possible when the cursor is in the indent.  Remember the number of\n    // characters before the cursor if it's possible.\n    start_col = curwin->w_cursor.col;\n\n    // determine offset from first non-blank\n    new_cursor_col = curwin->w_cursor.col;\n    beginline(BL_WHITE);\n    new_cursor_col -= curwin->w_cursor.col;\n\n    insstart_less = curwin->w_cursor.col;\n\n    // If the cursor is in the indent, compute how many screen columns the\n    // cursor is to the left of the first non-blank.\n    if (new_cursor_col < 0)\n\tvcol = get_indent() - vcol;\n\n    if (new_cursor_col > 0)\t    // can't fix replace stack\n\tstart_col = -1;\n\n    // Set the new indent.  The cursor will be put on the first non-blank.\n    if (type == INDENT_SET)\n\t(void)set_indent(amount, call_changed_bytes ? SIN_CHANGED : 0);\n    else\n    {\n\tint\tsave_State = State;\n\n\t// Avoid being called recursively.\n\tif (State & VREPLACE_FLAG)\n\t    State = INSERT;\n\tshift_line(type == INDENT_DEC, round, 1, call_changed_bytes);\n\tState = save_State;\n    }\n    insstart_less -= curwin->w_cursor.col;\n\n    // Try to put cursor on same character.\n    // If the cursor is at or after the first non-blank in the line,\n    // compute the cursor column relative to the column of the first\n    // non-blank character.\n    // If we are not in insert mode, leave the cursor on the first non-blank.\n    // If the cursor is before the first non-blank, position it relative\n    // to the first non-blank, counted in screen columns.\n    if (new_cursor_col >= 0)\n    {\n\t// When changing the indent while the cursor is touching it, reset\n\t// Insstart_col to 0.\n\tif (new_cursor_col == 0)\n\t    insstart_less = MAXCOL;\n\tnew_cursor_col += curwin->w_cursor.col;\n    }\n    else if (!(State & INSERT))\n\tnew_cursor_col = curwin->w_cursor.col;\n    else\n    {\n\t// Compute the screen column where the cursor should be.\n\tvcol = get_indent() - vcol;\n\tcurwin->w_virtcol = (colnr_T)((vcol < 0) ? 0 : vcol);\n\n\t// Advance the cursor until we reach the right screen column.\n\tvcol = last_vcol = 0;\n\tnew_cursor_col = -1;\n\tptr = ml_get_curline();\n\twhile (vcol <= (int)curwin->w_virtcol)\n\t{\n\t    last_vcol = vcol;\n\t    if (has_mbyte && new_cursor_col >= 0)\n\t\tnew_cursor_col += (*mb_ptr2len)(ptr + new_cursor_col);\n\t    else\n\t\t++new_cursor_col;\n\t    if (ptr[new_cursor_col] == NUL)\n\t\tbreak;\n\t    vcol += lbr_chartabsize(ptr, ptr + new_cursor_col, (colnr_T)vcol);\n\t}\n\tvcol = last_vcol;\n\n\t// May need to insert spaces to be able to position the cursor on\n\t// the right screen column.\n\tif (vcol != (int)curwin->w_virtcol)\n\t{\n\t    curwin->w_cursor.col = (colnr_T)new_cursor_col;\n\t    i = (int)curwin->w_virtcol - vcol;\n\t    ptr = alloc(i + 1);\n\t    if (ptr != NULL)\n\t    {\n\t\tnew_cursor_col += i;\n\t\tptr[i] = NUL;\n\t\twhile (--i >= 0)\n\t\t    ptr[i] = ' ';\n\t\tins_str(ptr);\n\t\tvim_free(ptr);\n\t    }\n\t}\n\n\t// When changing the indent while the cursor is in it, reset\n\t// Insstart_col to 0.\n\tinsstart_less = MAXCOL;\n    }\n\n    curwin->w_p_list = save_p_list;\n\n    if (new_cursor_col <= 0)\n\tcurwin->w_cursor.col = 0;\n    else\n\tcurwin->w_cursor.col = (colnr_T)new_cursor_col;\n    curwin->w_set_curswant = TRUE;\n    changed_cline_bef_curs();\n\n    // May have to adjust the start of the insert.\n    if (State & INSERT)\n    {\n\tif (curwin->w_cursor.lnum == Insstart.lnum && Insstart.col != 0)\n\t{\n\t    if ((int)Insstart.col <= insstart_less)\n\t\tInsstart.col = 0;\n\t    else\n\t\tInsstart.col -= insstart_less;\n\t}\n\tif ((int)ai_col <= insstart_less)\n\t    ai_col = 0;\n\telse\n\t    ai_col -= insstart_less;\n    }\n\n    // For REPLACE mode, may have to fix the replace stack, if it's possible.\n    // If the number of characters before the cursor decreased, need to pop a\n    // few characters from the replace stack.\n    // If the number of characters before the cursor increased, need to push a\n    // few NULs onto the replace stack.\n    if (REPLACE_NORMAL(State) && start_col >= 0)\n    {\n\twhile (start_col > (int)curwin->w_cursor.col)\n\t{\n\t    replace_join(0);\t    // remove a NUL from the replace stack\n\t    --start_col;\n\t}\n\twhile (start_col < (int)curwin->w_cursor.col || replaced)\n\t{\n\t    replace_push(NUL);\n\t    if (replaced)\n\t    {\n\t\treplace_push(replaced);\n\t\treplaced = NUL;\n\t    }\n\t    ++start_col;\n\t}\n    }\n\n    // For VREPLACE mode, we also have to fix the replace stack.  In this case\n    // it is always possible because we backspace over the whole line and then\n    // put it back again the way we wanted it.\n    if (State & VREPLACE_FLAG)\n    {\n\t// If orig_line didn't allocate, just return.  At least we did the job,\n\t// even if you can't backspace.\n\tif (orig_line == NULL)\n\t    return;\n\n\t// Save new line\n\tnew_line = vim_strsave(ml_get_curline());\n\tif (new_line == NULL)\n\t    return;\n\n\t// We only put back the new line up to the cursor\n\tnew_line[curwin->w_cursor.col] = NUL;\n\n\t// Put back original line\n\tml_replace(curwin->w_cursor.lnum, orig_line, FALSE);\n\tcurwin->w_cursor.col = orig_col;\n\n\t// Backspace from cursor to start of line\n\tbackspace_until_column(0);\n\n\t// Insert new stuff into line again\n\tins_bytes(new_line);\n\n\tvim_free(new_line);\n    }\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"vim.h\"\n\n// Type Definitions:\n// colnr_T:\ntypedef int\t\tcolnr_T;\n\n// colnr_T:\ntypedef int\tcolnr_T;\n\n// char_u:\ntypedef unsigned char\tchar_u;\n\n// Called Methods (top 10):\n// alloc from src/alloc.c:\nvoid *\nalloc(size_t size)\n{\n    return lalloc(size, TRUE);\n}\n\n// vim_free from src/alloc.c:\nvoid\nvim_free(void *x)\n{\n    if (x != NULL && !really_exiting)\n    {\n#ifdef MEM_PROFILE\n\tmem_pre_free(&x);\n#endif\n\tfree(x);\n    }\n}\n\n// ins_bytes from src/change.c:\nvoid\nins_bytes(char_u *p)\n{\n    ins_bytes_len(p, (int)STRLEN(p));\n}\n\n// ml_get_curline from src/memline.c:\nchar_u *\nml_get_curline(void)\n{\n    return ml_get_buf(curbuf, curwin->w_cursor.lnum, FALSE);\n}\n\n// NUL from src/ascii.h:\n<empty>\n\n// FALSE from src/vim.h:\n<empty>\n\n// lbr_chartabsize from src/charset.c:\nint\nlbr_chartabsize(\n    char_u\t\t*line UNUSED, // start of the line\n    unsigned char\t*s,\n    colnr_T\t\tcol)\n{\n#ifdef FEAT_LINEBREAK\n    if (!curwin->w_p_lbr && *get_showbreak_value(curwin) == NUL\n\t\t\t\t\t\t\t   && !curwin->w_p_bri)\n    {\n#endif\n\tif (curwin->w_p_wrap)\n\t    return win_nolbr_chartabsize(curwin, s, col, NULL);\n\tRET_WIN_BUF_CHARTABSIZE(curwin, curbuf, s, col)\n#ifdef FEAT_LINEBREAK\n    }\n    return win_lbr_chartabsize(curwin, line == NULL ? s : line, s, col, NULL);\n#endif\n}\n\n// INSERT from src/vim.h:\n<empty>\n\n// replace_push from src/edit.c:\nvoid\nreplace_push(\n    int\t    c)\t    // character that is replaced (NUL is none)\n{\n    char_u  *p;\n\n    if (replace_stack_nr < replace_offset)\t// nothing to do\n\treturn;\n    if (replace_stack_len <= replace_stack_nr)\n    {\n\treplace_stack_len += 50;\n\tp = ALLOC_MULT(char_u, replace_stack_len);\n\tif (p == NULL)\t    // out of memory\n\t{\n\t    replace_stack_len -= 50;\n\t    return;\n\t}\n\tif (replace_stack != NULL)\n\t{\n\t    mch_memmove(p, replace_stack,\n\t\t\t\t (size_t)(replace_stack_nr * sizeof(char_u)));\n\t    vim_free(replace_stack);\n\t}\n\treplace_stack = p;\n    }\n    p = replace_stack + replace_stack_nr - replace_offset;\n    if (replace_offset)\n\tmch_memmove(p + 1, p, (size_t)(replace_offset * sizeof(char_u)));\n    *p = c;\n    ++replace_stack_nr;\n}\n\n// vim_strsave from src/strings.c:\nchar_u *\nvim_strsave(char_u *string)\n{\n    char_u\t*p;\n    size_t\tlen;\n\n    len = STRLEN(string) + 1;\n    p = alloc(len);\n    if (p != NULL)\n\tmch_memmove(p, string, len);\n    return p;\n}\n"
  },
  {
    "repository": "linux-2.6",
    "cve_id": "CVE-2008-1294",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "9926e4c74300c4b31dee007298c6475d33369df0",
    "short_hash": "9926e4c7",
    "vulnerableMethods_before": [
      {
        "filename": "None",
        "method_name": "vulnerable_function",
        "raw_code": "asmlinkage long sys_setrlimit(unsigned int resource, struct rlimit __user *rlim)\n{\n\tstruct rlimit new_rlim, *old_rlim;\n\tunsigned long it_prof_secs;\n\tint retval;\n\n\tif (resource >= RLIM_NLIMITS)\n\t\treturn -EINVAL;\n\tif (copy_from_user(&new_rlim, rlim, sizeof(*rlim)))\n\t\treturn -EFAULT;\n\tif (new_rlim.rlim_cur > new_rlim.rlim_max)\n\t\treturn -EINVAL;\n\told_rlim = current->signal->rlim + resource;\n\tif ((new_rlim.rlim_max > old_rlim->rlim_max) &&\n\t    !capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\tif (resource == RLIMIT_NOFILE && new_rlim.rlim_max > NR_OPEN)\n\t\treturn -EPERM;\n\n\tretval = security_task_setrlimit(resource, &new_rlim);\n\tif (retval)\n\t\treturn retval;\n\n\ttask_lock(current->group_leader);\n\t*old_rlim = new_rlim;\n\ttask_unlock(current->group_leader);\n\n\tif (resource != RLIMIT_CPU)\n\t\tgoto out;\n\n\t/*\n\t * RLIMIT_CPU handling.   Note that the kernel fails to return an error\n\t * code if it rejected the user's attempt to set RLIMIT_CPU.  This is a\n\t * very long-standing error, and fixing it now risks breakage of\n\t * applications, so we live with it\n\t */\n\tif (new_rlim.rlim_cur == RLIM_INFINITY)\n\t\tgoto out;\n\n\tit_prof_secs = cputime_to_secs(current->signal->it_prof_expires);\n\tif (it_prof_secs == 0 || new_rlim.rlim_cur <= it_prof_secs) {\n\t\tunsigned long rlim_cur = new_rlim.rlim_cur;\n\t\tcputime_t cputime;\n\n\t\tif (rlim_cur == 0) {\n\t\t\t/*\n\t\t\t * The caller is asking for an immediate RLIMIT_CPU\n\t\t\t * expiry.  But we use the zero value to mean \"it was\n\t\t\t * never set\".  So let's cheat and make it one second\n\t\t\t * instead\n\t\t\t */\n\t\t\trlim_cur = 1;\n\t\t}\n\t\tcputime = secs_to_cputime(rlim_cur);\n\t\tread_lock(&tasklist_lock);\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\tset_process_cpu_timer(current, CPUCLOCK_PROF, &cputime, NULL);\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tread_unlock(&tasklist_lock);\n\t}\nout:\n\treturn 0;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "None",
        "method_name": "fixed_function",
        "raw_code": "asmlinkage long sys_setrlimit(unsigned int resource, struct rlimit __user *rlim)\n{\n\tstruct rlimit new_rlim, *old_rlim;\n\tunsigned long it_prof_secs;\n\tint retval;\n\n\tif (resource >= RLIM_NLIMITS)\n\t\treturn -EINVAL;\n\tif (copy_from_user(&new_rlim, rlim, sizeof(*rlim)))\n\t\treturn -EFAULT;\n\tif (new_rlim.rlim_cur > new_rlim.rlim_max)\n\t\treturn -EINVAL;\n\told_rlim = current->signal->rlim + resource;\n\tif ((new_rlim.rlim_max > old_rlim->rlim_max) &&\n\t    !capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\tif (resource == RLIMIT_NOFILE && new_rlim.rlim_max > NR_OPEN)\n\t\treturn -EPERM;\n\n\tretval = security_task_setrlimit(resource, &new_rlim);\n\tif (retval)\n\t\treturn retval;\n\n\tif (resource == RLIMIT_CPU && new_rlim.rlim_cur == 0) {\n\t\t/*\n\t\t * The caller is asking for an immediate RLIMIT_CPU\n\t\t * expiry.  But we use the zero value to mean \"it was\n\t\t * never set\".  So let's cheat and make it one second\n\t\t * instead\n\t\t */\n\t\tnew_rlim.rlim_cur = 1;\n\t}\n\n\ttask_lock(current->group_leader);\n\t*old_rlim = new_rlim;\n\ttask_unlock(current->group_leader);\n\n\tif (resource != RLIMIT_CPU)\n\t\tgoto out;\n\n\t/*\n\t * RLIMIT_CPU handling.   Note that the kernel fails to return an error\n\t * code if it rejected the user's attempt to set RLIMIT_CPU.  This is a\n\t * very long-standing error, and fixing it now risks breakage of\n\t * applications, so we live with it\n\t */\n\tif (new_rlim.rlim_cur == RLIM_INFINITY)\n\t\tgoto out;\n\n\tit_prof_secs = cputime_to_secs(current->signal->it_prof_expires);\n\tif (it_prof_secs == 0 || new_rlim.rlim_cur <= it_prof_secs) {\n\t\tunsigned long rlim_cur = new_rlim.rlim_cur;\n\t\tcputime_t cputime;\n\n\t\tcputime = secs_to_cputime(rlim_cur);\n\t\tread_lock(&tasklist_lock);\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\tset_process_cpu_timer(current, CPUCLOCK_PROF, &cputime, NULL);\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tread_unlock(&tasklist_lock);\n\t}\nout:\n\treturn 0;\n}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "wireless-drivers",
    "cve_id": "CVE-2019-15504",
    "cwe_list": [
      "CWE-415"
    ],
    "commit_hash": "8b51dc7291473093c821195c4b6af85fadedbc2f",
    "short_hash": "8b51dc72",
    "vulnerableMethods_before": [
      {
        "filename": "rsi_91x_usb.c",
        "method_name": "vulnerable_function",
        "raw_code": "static int rsi_init_usb_interface(struct rsi_hw *adapter,\n\t\t\t\t  struct usb_interface *pfunction)\n{\n\tstruct rsi_91x_usbdev *rsi_dev;\n\tint status;\n\n\trsi_dev = kzalloc(sizeof(*rsi_dev), GFP_KERNEL);\n\tif (!rsi_dev)\n\t\treturn -ENOMEM;\n\n\tadapter->rsi_dev = rsi_dev;\n\trsi_dev->usbdev = interface_to_usbdev(pfunction);\n\trsi_dev->priv = (void *)adapter;\n\n\tif (rsi_find_bulk_in_and_out_endpoints(pfunction, adapter)) {\n\t\tstatus = -EINVAL;\n\t\tgoto fail_eps;\n\t}\n\n\tadapter->device = &pfunction->dev;\n\tusb_set_intfdata(pfunction, adapter);\n\n\trsi_dev->tx_buffer = kmalloc(2048, GFP_KERNEL);\n\tif (!rsi_dev->tx_buffer) {\n\t\tstatus = -ENOMEM;\n\t\tgoto fail_eps;\n\t}\n\n\tif (rsi_usb_init_rx(adapter)) {\n\t\trsi_dbg(ERR_ZONE, \"Failed to init RX handle\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto fail_rx;\n\t}\n\n\trsi_dev->tx_blk_size = 252;\n\tadapter->block_size = rsi_dev->tx_blk_size;\n\n\t/* Initializing function callbacks */\n\tadapter->check_hw_queue_status = rsi_usb_check_queue_status;\n\tadapter->determine_event_timeout = rsi_usb_event_timeout;\n\tadapter->rsi_host_intf = RSI_HOST_INTF_USB;\n\tadapter->host_intf_ops = &usb_host_intf_ops;\n\n#ifdef CONFIG_RSI_DEBUGFS\n\t/* In USB, one less than the MAX_DEBUGFS_ENTRIES entries is required */\n\tadapter->num_debugfs_entries = (MAX_DEBUGFS_ENTRIES - 1);\n#endif\n\n\trsi_dbg(INIT_ZONE, \"%s: Enabled the interface\\n\", __func__);\n\treturn 0;\n\nfail_rx:\n\tkfree(rsi_dev->tx_buffer);\n\nfail_eps:\n\tkfree(rsi_dev);\n\n\treturn status;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "rsi_91x_usb.c",
        "method_name": "fixed_function",
        "raw_code": "static int rsi_init_usb_interface(struct rsi_hw *adapter,\n\t\t\t\t  struct usb_interface *pfunction)\n{\n\tstruct rsi_91x_usbdev *rsi_dev;\n\tint status;\n\n\trsi_dev = kzalloc(sizeof(*rsi_dev), GFP_KERNEL);\n\tif (!rsi_dev)\n\t\treturn -ENOMEM;\n\n\tadapter->rsi_dev = rsi_dev;\n\trsi_dev->usbdev = interface_to_usbdev(pfunction);\n\trsi_dev->priv = (void *)adapter;\n\n\tif (rsi_find_bulk_in_and_out_endpoints(pfunction, adapter)) {\n\t\tstatus = -EINVAL;\n\t\tgoto fail_eps;\n\t}\n\n\tadapter->device = &pfunction->dev;\n\tusb_set_intfdata(pfunction, adapter);\n\n\trsi_dev->tx_buffer = kmalloc(2048, GFP_KERNEL);\n\tif (!rsi_dev->tx_buffer) {\n\t\tstatus = -ENOMEM;\n\t\tgoto fail_eps;\n\t}\n\n\tif (rsi_usb_init_rx(adapter)) {\n\t\trsi_dbg(ERR_ZONE, \"Failed to init RX handle\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto fail_rx;\n\t}\n\n\trsi_dev->tx_blk_size = 252;\n\tadapter->block_size = rsi_dev->tx_blk_size;\n\n\t/* Initializing function callbacks */\n\tadapter->check_hw_queue_status = rsi_usb_check_queue_status;\n\tadapter->determine_event_timeout = rsi_usb_event_timeout;\n\tadapter->rsi_host_intf = RSI_HOST_INTF_USB;\n\tadapter->host_intf_ops = &usb_host_intf_ops;\n\n#ifdef CONFIG_RSI_DEBUGFS\n\t/* In USB, one less than the MAX_DEBUGFS_ENTRIES entries is required */\n\tadapter->num_debugfs_entries = (MAX_DEBUGFS_ENTRIES - 1);\n#endif\n\n\trsi_dbg(INIT_ZONE, \"%s: Enabled the interface\\n\", __func__);\n\treturn 0;\n\nfail_rx:\n\tkfree(rsi_dev->tx_buffer);\n\nfail_eps:\n\n\treturn status;\n}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "zlib",
    "cve_id": "CVE-2022-37434",
    "cwe_list": [
      "CWE-787"
    ],
    "commit_hash": "eff308af425b67093bab25f80f1ae950166bece1",
    "short_hash": "eff308af",
    "vulnerableMethods_before": [
      {
        "filename": "inflate.c",
        "method_name": "vulnerable_function",
        "raw_code": "int ZEXPORT inflate(strm, flush)\nz_streamp strm;\nint flush;\n{\n    struct inflate_state FAR *state;\n    z_const unsigned char FAR *next;    /* next input */\n    unsigned char FAR *put;     /* next output */\n    unsigned have, left;        /* available input and output */\n    unsigned long hold;         /* bit buffer */\n    unsigned bits;              /* bits in bit buffer */\n    unsigned in, out;           /* save starting available input and output */\n    unsigned copy;              /* number of stored or match bytes to copy */\n    unsigned char FAR *from;    /* where to copy match bytes from */\n    code here;                  /* current decoding table entry */\n    code last;                  /* parent table entry */\n    unsigned len;               /* length to copy for repeats, bits to drop */\n    int ret;                    /* return code */\n#ifdef GUNZIP\n    unsigned char hbuf[4];      /* buffer for gzip header crc calculation */\n#endif\n    static const unsigned short order[19] = /* permutation of code lengths */\n        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n\n    if (inflateStateCheck(strm) || strm->next_out == Z_NULL ||\n        (strm->next_in == Z_NULL && strm->avail_in != 0))\n        return Z_STREAM_ERROR;\n\n    state = (struct inflate_state FAR *)strm->state;\n    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */\n    LOAD();\n    in = have;\n    out = left;\n    ret = Z_OK;\n    for (;;)\n        switch (state->mode) {\n        case HEAD:\n            if (state->wrap == 0) {\n                state->mode = TYPEDO;\n                break;\n            }\n            NEEDBITS(16);\n#ifdef GUNZIP\n            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */\n                if (state->wbits == 0)\n                    state->wbits = 15;\n                state->check = crc32(0L, Z_NULL, 0);\n                CRC2(state->check, hold);\n                INITBITS();\n                state->mode = FLAGS;\n                break;\n            }\n            if (state->head != Z_NULL)\n                state->head->done = -1;\n            if (!(state->wrap & 1) ||   /* check if zlib header allowed */\n#else\n            if (\n#endif\n                ((BITS(8) << 8) + (hold >> 8)) % 31) {\n                strm->msg = (char *)\"incorrect header check\";\n                state->mode = BAD;\n                break;\n            }\n            if (BITS(4) != Z_DEFLATED) {\n                strm->msg = (char *)\"unknown compression method\";\n                state->mode = BAD;\n                break;\n            }\n            DROPBITS(4);\n            len = BITS(4) + 8;\n            if (state->wbits == 0)\n                state->wbits = len;\n            if (len > 15 || len > state->wbits) {\n                strm->msg = (char *)\"invalid window size\";\n                state->mode = BAD;\n                break;\n            }\n            state->dmax = 1U << len;\n            state->flags = 0;               /* indicate zlib header */\n            Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n            strm->adler = state->check = adler32(0L, Z_NULL, 0);\n            state->mode = hold & 0x200 ? DICTID : TYPE;\n            INITBITS();\n            break;\n#ifdef GUNZIP\n        case FLAGS:\n            NEEDBITS(16);\n            state->flags = (int)(hold);\n            if ((state->flags & 0xff) != Z_DEFLATED) {\n                strm->msg = (char *)\"unknown compression method\";\n                state->mode = BAD;\n                break;\n            }\n            if (state->flags & 0xe000) {\n                strm->msg = (char *)\"unknown header flags set\";\n                state->mode = BAD;\n                break;\n            }\n            if (state->head != Z_NULL)\n                state->head->text = (int)((hold >> 8) & 1);\n            if ((state->flags & 0x0200) && (state->wrap & 4))\n                CRC2(state->check, hold);\n            INITBITS();\n            state->mode = TIME;\n                /* fallthrough */\n        case TIME:\n            NEEDBITS(32);\n            if (state->head != Z_NULL)\n                state->head->time = hold;\n            if ((state->flags & 0x0200) && (state->wrap & 4))\n                CRC4(state->check, hold);\n            INITBITS();\n            state->mode = OS;\n                /* fallthrough */\n        case OS:\n            NEEDBITS(16);\n            if (state->head != Z_NULL) {\n                state->head->xflags = (int)(hold & 0xff);\n                state->head->os = (int)(hold >> 8);\n            }\n            if ((state->flags & 0x0200) && (state->wrap & 4))\n                CRC2(state->check, hold);\n            INITBITS();\n            state->mode = EXLEN;\n                /* fallthrough */\n        case EXLEN:\n            if (state->flags & 0x0400) {\n                NEEDBITS(16);\n                state->length = (unsigned)(hold);\n                if (state->head != Z_NULL)\n                    state->head->extra_len = (unsigned)hold;\n                if ((state->flags & 0x0200) && (state->wrap & 4))\n                    CRC2(state->check, hold);\n                INITBITS();\n            }\n            else if (state->head != Z_NULL)\n                state->head->extra = Z_NULL;\n            state->mode = EXTRA;\n                /* fallthrough */\n        case EXTRA:\n            if (state->flags & 0x0400) {\n                copy = state->length;\n                if (copy > have) copy = have;\n                if (copy) {\n                    if (state->head != Z_NULL &&\n                        state->head->extra != Z_NULL) {\n                        len = state->head->extra_len - state->length;\n                        zmemcpy(state->head->extra + len, next,\n                                len + copy > state->head->extra_max ?\n                                state->head->extra_max - len : copy);\n                    }\n                    if ((state->flags & 0x0200) && (state->wrap & 4))\n                        state->check = crc32(state->check, next, copy);\n                    have -= copy;\n                    next += copy;\n                    state->length -= copy;\n                }\n                if (state->length) goto inf_leave;\n            }\n            state->length = 0;\n            state->mode = NAME;\n                /* fallthrough */\n        case NAME:\n            if (state->flags & 0x0800) {\n                if (have == 0) goto inf_leave;\n                copy = 0;\n                do {\n                    len = (unsigned)(next[copy++]);\n                    if (state->head != Z_NULL &&\n                            state->head->name != Z_NULL &&\n                            state->length < state->head->name_max)\n                        state->head->name[state->length++] = (Bytef)len;\n                } while (len && copy < have);\n                if ((state->flags & 0x0200) && (state->wrap & 4))\n                    state->check = crc32(state->check, next, copy);\n                have -= copy;\n                next += copy;\n                if (len) goto inf_leave;\n            }\n            else if (state->head != Z_NULL)\n                state->head->name = Z_NULL;\n            state->length = 0;\n            state->mode = COMMENT;\n                /* fallthrough */\n        case COMMENT:\n            if (state->flags & 0x1000) {\n                if (have == 0) goto inf_leave;\n                copy = 0;\n                do {\n                    len = (unsigned)(next[copy++]);\n                    if (state->head != Z_NULL &&\n                            state->head->comment != Z_NULL &&\n                            state->length < state->head->comm_max)\n                        state->head->comment[state->length++] = (Bytef)len;\n                } while (len && copy < have);\n                if ((state->flags & 0x0200) && (state->wrap & 4))\n                    state->check = crc32(state->check, next, copy);\n                have -= copy;\n                next += copy;\n                if (len) goto inf_leave;\n            }\n            else if (state->head != Z_NULL)\n                state->head->comment = Z_NULL;\n            state->mode = HCRC;\n                /* fallthrough */\n        case HCRC:\n            if (state->flags & 0x0200) {\n                NEEDBITS(16);\n                if ((state->wrap & 4) && hold != (state->check & 0xffff)) {\n                    strm->msg = (char *)\"header crc mismatch\";\n                    state->mode = BAD;\n                    break;\n                }\n                INITBITS();\n            }\n            if (state->head != Z_NULL) {\n                state->head->hcrc = (int)((state->flags >> 9) & 1);\n                state->head->done = 1;\n            }\n            strm->adler = state->check = crc32(0L, Z_NULL, 0);\n            state->mode = TYPE;\n            break;\n#endif\n        case DICTID:\n            NEEDBITS(32);\n            strm->adler = state->check = ZSWAP32(hold);\n            INITBITS();\n            state->mode = DICT;\n                /* fallthrough */\n        case DICT:\n            if (state->havedict == 0) {\n                RESTORE();\n                return Z_NEED_DICT;\n            }\n            strm->adler = state->check = adler32(0L, Z_NULL, 0);\n            state->mode = TYPE;\n                /* fallthrough */\n        case TYPE:\n            if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;\n                /* fallthrough */\n        case TYPEDO:\n            if (state->last) {\n                BYTEBITS();\n                state->mode = CHECK;\n                break;\n            }\n            NEEDBITS(3);\n            state->last = BITS(1);\n            DROPBITS(1);\n            switch (BITS(2)) {\n            case 0:                             /* stored block */\n                Tracev((stderr, \"inflate:     stored block%s\\n\",\n                        state->last ? \" (last)\" : \"\"));\n                state->mode = STORED;\n                break;\n            case 1:                             /* fixed block */\n                fixedtables(state);\n                Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n                        state->last ? \" (last)\" : \"\"));\n                state->mode = LEN_;             /* decode codes */\n                if (flush == Z_TREES) {\n                    DROPBITS(2);\n                    goto inf_leave;\n                }\n                break;\n            case 2:                             /* dynamic block */\n                Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n                        state->last ? \" (last)\" : \"\"));\n                state->mode = TABLE;\n                break;\n            case 3:\n                strm->msg = (char *)\"invalid block type\";\n                state->mode = BAD;\n            }\n            DROPBITS(2);\n            break;\n        case STORED:\n            BYTEBITS();                         /* go to byte boundary */\n            NEEDBITS(32);\n            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {\n                strm->msg = (char *)\"invalid stored block lengths\";\n                state->mode = BAD;\n                break;\n            }\n            state->length = (unsigned)hold & 0xffff;\n            Tracev((stderr, \"inflate:       stored length %u\\n\",\n                    state->length));\n            INITBITS();\n            state->mode = COPY_;\n            if (flush == Z_TREES) goto inf_leave;\n                /* fallthrough */\n        case COPY_:\n            state->mode = COPY;\n                /* fallthrough */\n        case COPY:\n            copy = state->length;\n            if (copy) {\n                if (copy > have) copy = have;\n                if (copy > left) copy = left;\n                if (copy == 0) goto inf_leave;\n                zmemcpy(put, next, copy);\n                have -= copy;\n                next += copy;\n                left -= copy;\n                put += copy;\n                state->length -= copy;\n                break;\n            }\n            Tracev((stderr, \"inflate:       stored end\\n\"));\n            state->mode = TYPE;\n            break;\n        case TABLE:\n            NEEDBITS(14);\n            state->nlen = BITS(5) + 257;\n            DROPBITS(5);\n            state->ndist = BITS(5) + 1;\n            DROPBITS(5);\n            state->ncode = BITS(4) + 4;\n            DROPBITS(4);\n#ifndef PKZIP_BUG_WORKAROUND\n            if (state->nlen > 286 || state->ndist > 30) {\n                strm->msg = (char *)\"too many length or distance symbols\";\n                state->mode = BAD;\n                break;\n            }\n#endif\n            Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n            state->have = 0;\n            state->mode = LENLENS;\n                /* fallthrough */\n        case LENLENS:\n            while (state->have < state->ncode) {\n                NEEDBITS(3);\n                state->lens[order[state->have++]] = (unsigned short)BITS(3);\n                DROPBITS(3);\n            }\n            while (state->have < 19)\n                state->lens[order[state->have++]] = 0;\n            state->next = state->codes;\n            state->lencode = (const code FAR *)(state->next);\n            state->lenbits = 7;\n            ret = inflate_table(CODES, state->lens, 19, &(state->next),\n                                &(state->lenbits), state->work);\n            if (ret) {\n                strm->msg = (char *)\"invalid code lengths set\";\n                state->mode = BAD;\n                break;\n            }\n            Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n            state->have = 0;\n            state->mode = CODELENS;\n                /* fallthrough */\n        case CODELENS:\n            while (state->have < state->nlen + state->ndist) {\n                for (;;) {\n                    here = state->lencode[BITS(state->lenbits)];\n                    if ((unsigned)(here.bits) <= bits) break;\n                    PULLBYTE();\n                }\n                if (here.val < 16) {\n                    DROPBITS(here.bits);\n                    state->lens[state->have++] = here.val;\n                }\n                else {\n                    if (here.val == 16) {\n                        NEEDBITS(here.bits + 2);\n                        DROPBITS(here.bits);\n                        if (state->have == 0) {\n                            strm->msg = (char *)\"invalid bit length repeat\";\n                            state->mode = BAD;\n                            break;\n                        }\n                        len = state->lens[state->have - 1];\n                        copy = 3 + BITS(2);\n                        DROPBITS(2);\n                    }\n                    else if (here.val == 17) {\n                        NEEDBITS(here.bits + 3);\n                        DROPBITS(here.bits);\n                        len = 0;\n                        copy = 3 + BITS(3);\n                        DROPBITS(3);\n                    }\n                    else {\n                        NEEDBITS(here.bits + 7);\n                        DROPBITS(here.bits);\n                        len = 0;\n                        copy = 11 + BITS(7);\n                        DROPBITS(7);\n                    }\n                    if (state->have + copy > state->nlen + state->ndist) {\n                        strm->msg = (char *)\"invalid bit length repeat\";\n                        state->mode = BAD;\n                        break;\n                    }\n                    while (copy--)\n                        state->lens[state->have++] = (unsigned short)len;\n                }\n            }\n\n            /* handle error breaks in while */\n            if (state->mode == BAD) break;\n\n            /* check for end-of-block code (better have one) */\n            if (state->lens[256] == 0) {\n                strm->msg = (char *)\"invalid code -- missing end-of-block\";\n                state->mode = BAD;\n                break;\n            }\n\n            /* build code tables -- note: do not change the lenbits or distbits\n               values here (9 and 6) without reading the comments in inftrees.h\n               concerning the ENOUGH constants, which depend on those values */\n            state->next = state->codes;\n            state->lencode = (const code FAR *)(state->next);\n            state->lenbits = 9;\n            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),\n                                &(state->lenbits), state->work);\n            if (ret) {\n                strm->msg = (char *)\"invalid literal/lengths set\";\n                state->mode = BAD;\n                break;\n            }\n            state->distcode = (const code FAR *)(state->next);\n            state->distbits = 6;\n            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,\n                            &(state->next), &(state->distbits), state->work);\n            if (ret) {\n                strm->msg = (char *)\"invalid distances set\";\n                state->mode = BAD;\n                break;\n            }\n            Tracev((stderr, \"inflate:       codes ok\\n\"));\n            state->mode = LEN_;\n            if (flush == Z_TREES) goto inf_leave;\n                /* fallthrough */\n        case LEN_:\n            state->mode = LEN;\n                /* fallthrough */\n        case LEN:\n            if (have >= 6 && left >= 258) {\n                RESTORE();\n                inflate_fast(strm, out);\n                LOAD();\n                if (state->mode == TYPE)\n                    state->back = -1;\n                break;\n            }\n            state->back = 0;\n            for (;;) {\n                here = state->lencode[BITS(state->lenbits)];\n                if ((unsigned)(here.bits) <= bits) break;\n                PULLBYTE();\n            }\n            if (here.op && (here.op & 0xf0) == 0) {\n                last = here;\n                for (;;) {\n                    here = state->lencode[last.val +\n                            (BITS(last.bits + last.op) >> last.bits)];\n                    if ((unsigned)(last.bits + here.bits) <= bits) break;\n                    PULLBYTE();\n                }\n                DROPBITS(last.bits);\n                state->back += last.bits;\n            }\n            DROPBITS(here.bits);\n            state->back += here.bits;\n            state->length = (unsigned)here.val;\n            if ((int)(here.op) == 0) {\n                Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n                        \"inflate:         literal '%c'\\n\" :\n                        \"inflate:         literal 0x%02x\\n\", here.val));\n                state->mode = LIT;\n                break;\n            }\n            if (here.op & 32) {\n                Tracevv((stderr, \"inflate:         end of block\\n\"));\n                state->back = -1;\n                state->mode = TYPE;\n                break;\n            }\n            if (here.op & 64) {\n                strm->msg = (char *)\"invalid literal/length code\";\n                state->mode = BAD;\n                break;\n            }\n            state->extra = (unsigned)(here.op) & 15;\n            state->mode = LENEXT;\n                /* fallthrough */\n        case LENEXT:\n            if (state->extra) {\n                NEEDBITS(state->extra);\n                state->length += BITS(state->extra);\n                DROPBITS(state->extra);\n                state->back += state->extra;\n            }\n            Tracevv((stderr, \"inflate:         length %u\\n\", state->length));\n            state->was = state->length;\n            state->mode = DIST;\n                /* fallthrough */\n        case DIST:\n            for (;;) {\n                here = state->distcode[BITS(state->distbits)];\n                if ((unsigned)(here.bits) <= bits) break;\n                PULLBYTE();\n            }\n            if ((here.op & 0xf0) == 0) {\n                last = here;\n                for (;;) {\n                    here = state->distcode[last.val +\n                            (BITS(last.bits + last.op) >> last.bits)];\n                    if ((unsigned)(last.bits + here.bits) <= bits) break;\n                    PULLBYTE();\n                }\n                DROPBITS(last.bits);\n                state->back += last.bits;\n            }\n            DROPBITS(here.bits);\n            state->back += here.bits;\n            if (here.op & 64) {\n                strm->msg = (char *)\"invalid distance code\";\n                state->mode = BAD;\n                break;\n            }\n            state->offset = (unsigned)here.val;\n            state->extra = (unsigned)(here.op) & 15;\n            state->mode = DISTEXT;\n                /* fallthrough */\n        case DISTEXT:\n            if (state->extra) {\n                NEEDBITS(state->extra);\n                state->offset += BITS(state->extra);\n                DROPBITS(state->extra);\n                state->back += state->extra;\n            }\n#ifdef INFLATE_STRICT\n            if (state->offset > state->dmax) {\n                strm->msg = (char *)\"invalid distance too far back\";\n                state->mode = BAD;\n                break;\n            }\n#endif\n            Tracevv((stderr, \"inflate:         distance %u\\n\", state->offset));\n            state->mode = MATCH;\n                /* fallthrough */\n        case MATCH:\n            if (left == 0) goto inf_leave;\n            copy = out - left;\n            if (state->offset > copy) {         /* copy from window */\n                copy = state->offset - copy;\n                if (copy > state->whave) {\n                    if (state->sane) {\n                        strm->msg = (char *)\"invalid distance too far back\";\n                        state->mode = BAD;\n                        break;\n                    }\n#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n                    Trace((stderr, \"inflate.c too far\\n\"));\n                    copy -= state->whave;\n                    if (copy > state->length) copy = state->length;\n                    if (copy > left) copy = left;\n                    left -= copy;\n                    state->length -= copy;\n                    do {\n                        *put++ = 0;\n                    } while (--copy);\n                    if (state->length == 0) state->mode = LEN;\n                    break;\n#endif\n                }\n                if (copy > state->wnext) {\n                    copy -= state->wnext;\n                    from = state->window + (state->wsize - copy);\n                }\n                else\n                    from = state->window + (state->wnext - copy);\n                if (copy > state->length) copy = state->length;\n            }\n            else {                              /* copy from output */\n                from = put - state->offset;\n                copy = state->length;\n            }\n            if (copy > left) copy = left;\n            left -= copy;\n            state->length -= copy;\n            do {\n                *put++ = *from++;\n            } while (--copy);\n            if (state->length == 0) state->mode = LEN;\n            break;\n        case LIT:\n            if (left == 0) goto inf_leave;\n            *put++ = (unsigned char)(state->length);\n            left--;\n            state->mode = LEN;\n            break;\n        case CHECK:\n            if (state->wrap) {\n                NEEDBITS(32);\n                out -= left;\n                strm->total_out += out;\n                state->total += out;\n                if ((state->wrap & 4) && out)\n                    strm->adler = state->check =\n                        UPDATE_CHECK(state->check, put - out, out);\n                out = left;\n                if ((state->wrap & 4) && (\n#ifdef GUNZIP\n                     state->flags ? hold :\n#endif\n                     ZSWAP32(hold)) != state->check) {\n                    strm->msg = (char *)\"incorrect data check\";\n                    state->mode = BAD;\n                    break;\n                }\n                INITBITS();\n                Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n            }\n#ifdef GUNZIP\n            state->mode = LENGTH;\n                /* fallthrough */\n        case LENGTH:\n            if (state->wrap && state->flags) {\n                NEEDBITS(32);\n                if ((state->wrap & 4) && hold != (state->total & 0xffffffff)) {\n                    strm->msg = (char *)\"incorrect length check\";\n                    state->mode = BAD;\n                    break;\n                }\n                INITBITS();\n                Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n            }\n#endif\n            state->mode = DONE;\n                /* fallthrough */\n        case DONE:\n            ret = Z_STREAM_END;\n            goto inf_leave;\n        case BAD:\n            ret = Z_DATA_ERROR;\n            goto inf_leave;\n        case MEM:\n            return Z_MEM_ERROR;\n        case SYNC:\n                /* fallthrough */\n        default:\n            return Z_STREAM_ERROR;\n        }\n\n    /*\n       Return from inflate(), updating the total counts and the check value.\n       If there was no progress during the inflate() call, return a buffer\n       error.  Call updatewindow() to create and/or update the window state.\n       Note: a memory error from inflate() is non-recoverable.\n     */\n  inf_leave:\n    RESTORE();\n    if (state->wsize || (out != strm->avail_out && state->mode < BAD &&\n            (state->mode < CHECK || flush != Z_FINISH)))\n        if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {\n            state->mode = MEM;\n            return Z_MEM_ERROR;\n        }\n    in -= strm->avail_in;\n    out -= strm->avail_out;\n    strm->total_in += in;\n    strm->total_out += out;\n    state->total += out;\n    if ((state->wrap & 4) && out)\n        strm->adler = state->check =\n            UPDATE_CHECK(state->check, strm->next_out - out, out);\n    strm->data_type = (int)state->bits + (state->last ? 64 : 0) +\n                      (state->mode == TYPE ? 128 : 0) +\n                      (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);\n    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)\n        ret = Z_BUF_ERROR;\n    return ret;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "inflate.c",
        "method_name": "fixed_function",
        "raw_code": "int ZEXPORT inflate(strm, flush)\nz_streamp strm;\nint flush;\n{\n    struct inflate_state FAR *state;\n    z_const unsigned char FAR *next;    /* next input */\n    unsigned char FAR *put;     /* next output */\n    unsigned have, left;        /* available input and output */\n    unsigned long hold;         /* bit buffer */\n    unsigned bits;              /* bits in bit buffer */\n    unsigned in, out;           /* save starting available input and output */\n    unsigned copy;              /* number of stored or match bytes to copy */\n    unsigned char FAR *from;    /* where to copy match bytes from */\n    code here;                  /* current decoding table entry */\n    code last;                  /* parent table entry */\n    unsigned len;               /* length to copy for repeats, bits to drop */\n    int ret;                    /* return code */\n#ifdef GUNZIP\n    unsigned char hbuf[4];      /* buffer for gzip header crc calculation */\n#endif\n    static const unsigned short order[19] = /* permutation of code lengths */\n        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n\n    if (inflateStateCheck(strm) || strm->next_out == Z_NULL ||\n        (strm->next_in == Z_NULL && strm->avail_in != 0))\n        return Z_STREAM_ERROR;\n\n    state = (struct inflate_state FAR *)strm->state;\n    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */\n    LOAD();\n    in = have;\n    out = left;\n    ret = Z_OK;\n    for (;;)\n        switch (state->mode) {\n        case HEAD:\n            if (state->wrap == 0) {\n                state->mode = TYPEDO;\n                break;\n            }\n            NEEDBITS(16);\n#ifdef GUNZIP\n            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */\n                if (state->wbits == 0)\n                    state->wbits = 15;\n                state->check = crc32(0L, Z_NULL, 0);\n                CRC2(state->check, hold);\n                INITBITS();\n                state->mode = FLAGS;\n                break;\n            }\n            if (state->head != Z_NULL)\n                state->head->done = -1;\n            if (!(state->wrap & 1) ||   /* check if zlib header allowed */\n#else\n            if (\n#endif\n                ((BITS(8) << 8) + (hold >> 8)) % 31) {\n                strm->msg = (char *)\"incorrect header check\";\n                state->mode = BAD;\n                break;\n            }\n            if (BITS(4) != Z_DEFLATED) {\n                strm->msg = (char *)\"unknown compression method\";\n                state->mode = BAD;\n                break;\n            }\n            DROPBITS(4);\n            len = BITS(4) + 8;\n            if (state->wbits == 0)\n                state->wbits = len;\n            if (len > 15 || len > state->wbits) {\n                strm->msg = (char *)\"invalid window size\";\n                state->mode = BAD;\n                break;\n            }\n            state->dmax = 1U << len;\n            state->flags = 0;               /* indicate zlib header */\n            Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n            strm->adler = state->check = adler32(0L, Z_NULL, 0);\n            state->mode = hold & 0x200 ? DICTID : TYPE;\n            INITBITS();\n            break;\n#ifdef GUNZIP\n        case FLAGS:\n            NEEDBITS(16);\n            state->flags = (int)(hold);\n            if ((state->flags & 0xff) != Z_DEFLATED) {\n                strm->msg = (char *)\"unknown compression method\";\n                state->mode = BAD;\n                break;\n            }\n            if (state->flags & 0xe000) {\n                strm->msg = (char *)\"unknown header flags set\";\n                state->mode = BAD;\n                break;\n            }\n            if (state->head != Z_NULL)\n                state->head->text = (int)((hold >> 8) & 1);\n            if ((state->flags & 0x0200) && (state->wrap & 4))\n                CRC2(state->check, hold);\n            INITBITS();\n            state->mode = TIME;\n                /* fallthrough */\n        case TIME:\n            NEEDBITS(32);\n            if (state->head != Z_NULL)\n                state->head->time = hold;\n            if ((state->flags & 0x0200) && (state->wrap & 4))\n                CRC4(state->check, hold);\n            INITBITS();\n            state->mode = OS;\n                /* fallthrough */\n        case OS:\n            NEEDBITS(16);\n            if (state->head != Z_NULL) {\n                state->head->xflags = (int)(hold & 0xff);\n                state->head->os = (int)(hold >> 8);\n            }\n            if ((state->flags & 0x0200) && (state->wrap & 4))\n                CRC2(state->check, hold);\n            INITBITS();\n            state->mode = EXLEN;\n                /* fallthrough */\n        case EXLEN:\n            if (state->flags & 0x0400) {\n                NEEDBITS(16);\n                state->length = (unsigned)(hold);\n                if (state->head != Z_NULL)\n                    state->head->extra_len = (unsigned)hold;\n                if ((state->flags & 0x0200) && (state->wrap & 4))\n                    CRC2(state->check, hold);\n                INITBITS();\n            }\n            else if (state->head != Z_NULL)\n                state->head->extra = Z_NULL;\n            state->mode = EXTRA;\n                /* fallthrough */\n        case EXTRA:\n            if (state->flags & 0x0400) {\n                copy = state->length;\n                if (copy > have) copy = have;\n                if (copy) {\n                    len = state->head->extra_len - state->length;\n                    if (state->head != Z_NULL &&\n                        state->head->extra != Z_NULL &&\n                        len < state->head->extra_max) {\n                        zmemcpy(state->head->extra + len, next,\n                                len + copy > state->head->extra_max ?\n                                state->head->extra_max - len : copy);\n                    }\n                    if ((state->flags & 0x0200) && (state->wrap & 4))\n                        state->check = crc32(state->check, next, copy);\n                    have -= copy;\n                    next += copy;\n                    state->length -= copy;\n                }\n                if (state->length) goto inf_leave;\n            }\n            state->length = 0;\n            state->mode = NAME;\n                /* fallthrough */\n        case NAME:\n            if (state->flags & 0x0800) {\n                if (have == 0) goto inf_leave;\n                copy = 0;\n                do {\n                    len = (unsigned)(next[copy++]);\n                    if (state->head != Z_NULL &&\n                            state->head->name != Z_NULL &&\n                            state->length < state->head->name_max)\n                        state->head->name[state->length++] = (Bytef)len;\n                } while (len && copy < have);\n                if ((state->flags & 0x0200) && (state->wrap & 4))\n                    state->check = crc32(state->check, next, copy);\n                have -= copy;\n                next += copy;\n                if (len) goto inf_leave;\n            }\n            else if (state->head != Z_NULL)\n                state->head->name = Z_NULL;\n            state->length = 0;\n            state->mode = COMMENT;\n                /* fallthrough */\n        case COMMENT:\n            if (state->flags & 0x1000) {\n                if (have == 0) goto inf_leave;\n                copy = 0;\n                do {\n                    len = (unsigned)(next[copy++]);\n                    if (state->head != Z_NULL &&\n                            state->head->comment != Z_NULL &&\n                            state->length < state->head->comm_max)\n                        state->head->comment[state->length++] = (Bytef)len;\n                } while (len && copy < have);\n                if ((state->flags & 0x0200) && (state->wrap & 4))\n                    state->check = crc32(state->check, next, copy);\n                have -= copy;\n                next += copy;\n                if (len) goto inf_leave;\n            }\n            else if (state->head != Z_NULL)\n                state->head->comment = Z_NULL;\n            state->mode = HCRC;\n                /* fallthrough */\n        case HCRC:\n            if (state->flags & 0x0200) {\n                NEEDBITS(16);\n                if ((state->wrap & 4) && hold != (state->check & 0xffff)) {\n                    strm->msg = (char *)\"header crc mismatch\";\n                    state->mode = BAD;\n                    break;\n                }\n                INITBITS();\n            }\n            if (state->head != Z_NULL) {\n                state->head->hcrc = (int)((state->flags >> 9) & 1);\n                state->head->done = 1;\n            }\n            strm->adler = state->check = crc32(0L, Z_NULL, 0);\n            state->mode = TYPE;\n            break;\n#endif\n        case DICTID:\n            NEEDBITS(32);\n            strm->adler = state->check = ZSWAP32(hold);\n            INITBITS();\n            state->mode = DICT;\n                /* fallthrough */\n        case DICT:\n            if (state->havedict == 0) {\n                RESTORE();\n                return Z_NEED_DICT;\n            }\n            strm->adler = state->check = adler32(0L, Z_NULL, 0);\n            state->mode = TYPE;\n                /* fallthrough */\n        case TYPE:\n            if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;\n                /* fallthrough */\n        case TYPEDO:\n            if (state->last) {\n                BYTEBITS();\n                state->mode = CHECK;\n                break;\n            }\n            NEEDBITS(3);\n            state->last = BITS(1);\n            DROPBITS(1);\n            switch (BITS(2)) {\n            case 0:                             /* stored block */\n                Tracev((stderr, \"inflate:     stored block%s\\n\",\n                        state->last ? \" (last)\" : \"\"));\n                state->mode = STORED;\n                break;\n            case 1:                             /* fixed block */\n                fixedtables(state);\n                Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n                        state->last ? \" (last)\" : \"\"));\n                state->mode = LEN_;             /* decode codes */\n                if (flush == Z_TREES) {\n                    DROPBITS(2);\n                    goto inf_leave;\n                }\n                break;\n            case 2:                             /* dynamic block */\n                Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n                        state->last ? \" (last)\" : \"\"));\n                state->mode = TABLE;\n                break;\n            case 3:\n                strm->msg = (char *)\"invalid block type\";\n                state->mode = BAD;\n            }\n            DROPBITS(2);\n            break;\n        case STORED:\n            BYTEBITS();                         /* go to byte boundary */\n            NEEDBITS(32);\n            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {\n                strm->msg = (char *)\"invalid stored block lengths\";\n                state->mode = BAD;\n                break;\n            }\n            state->length = (unsigned)hold & 0xffff;\n            Tracev((stderr, \"inflate:       stored length %u\\n\",\n                    state->length));\n            INITBITS();\n            state->mode = COPY_;\n            if (flush == Z_TREES) goto inf_leave;\n                /* fallthrough */\n        case COPY_:\n            state->mode = COPY;\n                /* fallthrough */\n        case COPY:\n            copy = state->length;\n            if (copy) {\n                if (copy > have) copy = have;\n                if (copy > left) copy = left;\n                if (copy == 0) goto inf_leave;\n                zmemcpy(put, next, copy);\n                have -= copy;\n                next += copy;\n                left -= copy;\n                put += copy;\n                state->length -= copy;\n                break;\n            }\n            Tracev((stderr, \"inflate:       stored end\\n\"));\n            state->mode = TYPE;\n            break;\n        case TABLE:\n            NEEDBITS(14);\n            state->nlen = BITS(5) + 257;\n            DROPBITS(5);\n            state->ndist = BITS(5) + 1;\n            DROPBITS(5);\n            state->ncode = BITS(4) + 4;\n            DROPBITS(4);\n#ifndef PKZIP_BUG_WORKAROUND\n            if (state->nlen > 286 || state->ndist > 30) {\n                strm->msg = (char *)\"too many length or distance symbols\";\n                state->mode = BAD;\n                break;\n            }\n#endif\n            Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n            state->have = 0;\n            state->mode = LENLENS;\n                /* fallthrough */\n        case LENLENS:\n            while (state->have < state->ncode) {\n                NEEDBITS(3);\n                state->lens[order[state->have++]] = (unsigned short)BITS(3);\n                DROPBITS(3);\n            }\n            while (state->have < 19)\n                state->lens[order[state->have++]] = 0;\n            state->next = state->codes;\n            state->lencode = (const code FAR *)(state->next);\n            state->lenbits = 7;\n            ret = inflate_table(CODES, state->lens, 19, &(state->next),\n                                &(state->lenbits), state->work);\n            if (ret) {\n                strm->msg = (char *)\"invalid code lengths set\";\n                state->mode = BAD;\n                break;\n            }\n            Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n            state->have = 0;\n            state->mode = CODELENS;\n                /* fallthrough */\n        case CODELENS:\n            while (state->have < state->nlen + state->ndist) {\n                for (;;) {\n                    here = state->lencode[BITS(state->lenbits)];\n                    if ((unsigned)(here.bits) <= bits) break;\n                    PULLBYTE();\n                }\n                if (here.val < 16) {\n                    DROPBITS(here.bits);\n                    state->lens[state->have++] = here.val;\n                }\n                else {\n                    if (here.val == 16) {\n                        NEEDBITS(here.bits + 2);\n                        DROPBITS(here.bits);\n                        if (state->have == 0) {\n                            strm->msg = (char *)\"invalid bit length repeat\";\n                            state->mode = BAD;\n                            break;\n                        }\n                        len = state->lens[state->have - 1];\n                        copy = 3 + BITS(2);\n                        DROPBITS(2);\n                    }\n                    else if (here.val == 17) {\n                        NEEDBITS(here.bits + 3);\n                        DROPBITS(here.bits);\n                        len = 0;\n                        copy = 3 + BITS(3);\n                        DROPBITS(3);\n                    }\n                    else {\n                        NEEDBITS(here.bits + 7);\n                        DROPBITS(here.bits);\n                        len = 0;\n                        copy = 11 + BITS(7);\n                        DROPBITS(7);\n                    }\n                    if (state->have + copy > state->nlen + state->ndist) {\n                        strm->msg = (char *)\"invalid bit length repeat\";\n                        state->mode = BAD;\n                        break;\n                    }\n                    while (copy--)\n                        state->lens[state->have++] = (unsigned short)len;\n                }\n            }\n\n            /* handle error breaks in while */\n            if (state->mode == BAD) break;\n\n            /* check for end-of-block code (better have one) */\n            if (state->lens[256] == 0) {\n                strm->msg = (char *)\"invalid code -- missing end-of-block\";\n                state->mode = BAD;\n                break;\n            }\n\n            /* build code tables -- note: do not change the lenbits or distbits\n               values here (9 and 6) without reading the comments in inftrees.h\n               concerning the ENOUGH constants, which depend on those values */\n            state->next = state->codes;\n            state->lencode = (const code FAR *)(state->next);\n            state->lenbits = 9;\n            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),\n                                &(state->lenbits), state->work);\n            if (ret) {\n                strm->msg = (char *)\"invalid literal/lengths set\";\n                state->mode = BAD;\n                break;\n            }\n            state->distcode = (const code FAR *)(state->next);\n            state->distbits = 6;\n            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,\n                            &(state->next), &(state->distbits), state->work);\n            if (ret) {\n                strm->msg = (char *)\"invalid distances set\";\n                state->mode = BAD;\n                break;\n            }\n            Tracev((stderr, \"inflate:       codes ok\\n\"));\n            state->mode = LEN_;\n            if (flush == Z_TREES) goto inf_leave;\n                /* fallthrough */\n        case LEN_:\n            state->mode = LEN;\n                /* fallthrough */\n        case LEN:\n            if (have >= 6 && left >= 258) {\n                RESTORE();\n                inflate_fast(strm, out);\n                LOAD();\n                if (state->mode == TYPE)\n                    state->back = -1;\n                break;\n            }\n            state->back = 0;\n            for (;;) {\n                here = state->lencode[BITS(state->lenbits)];\n                if ((unsigned)(here.bits) <= bits) break;\n                PULLBYTE();\n            }\n            if (here.op && (here.op & 0xf0) == 0) {\n                last = here;\n                for (;;) {\n                    here = state->lencode[last.val +\n                            (BITS(last.bits + last.op) >> last.bits)];\n                    if ((unsigned)(last.bits + here.bits) <= bits) break;\n                    PULLBYTE();\n                }\n                DROPBITS(last.bits);\n                state->back += last.bits;\n            }\n            DROPBITS(here.bits);\n            state->back += here.bits;\n            state->length = (unsigned)here.val;\n            if ((int)(here.op) == 0) {\n                Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n                        \"inflate:         literal '%c'\\n\" :\n                        \"inflate:         literal 0x%02x\\n\", here.val));\n                state->mode = LIT;\n                break;\n            }\n            if (here.op & 32) {\n                Tracevv((stderr, \"inflate:         end of block\\n\"));\n                state->back = -1;\n                state->mode = TYPE;\n                break;\n            }\n            if (here.op & 64) {\n                strm->msg = (char *)\"invalid literal/length code\";\n                state->mode = BAD;\n                break;\n            }\n            state->extra = (unsigned)(here.op) & 15;\n            state->mode = LENEXT;\n                /* fallthrough */\n        case LENEXT:\n            if (state->extra) {\n                NEEDBITS(state->extra);\n                state->length += BITS(state->extra);\n                DROPBITS(state->extra);\n                state->back += state->extra;\n            }\n            Tracevv((stderr, \"inflate:         length %u\\n\", state->length));\n            state->was = state->length;\n            state->mode = DIST;\n                /* fallthrough */\n        case DIST:\n            for (;;) {\n                here = state->distcode[BITS(state->distbits)];\n                if ((unsigned)(here.bits) <= bits) break;\n                PULLBYTE();\n            }\n            if ((here.op & 0xf0) == 0) {\n                last = here;\n                for (;;) {\n                    here = state->distcode[last.val +\n                            (BITS(last.bits + last.op) >> last.bits)];\n                    if ((unsigned)(last.bits + here.bits) <= bits) break;\n                    PULLBYTE();\n                }\n                DROPBITS(last.bits);\n                state->back += last.bits;\n            }\n            DROPBITS(here.bits);\n            state->back += here.bits;\n            if (here.op & 64) {\n                strm->msg = (char *)\"invalid distance code\";\n                state->mode = BAD;\n                break;\n            }\n            state->offset = (unsigned)here.val;\n            state->extra = (unsigned)(here.op) & 15;\n            state->mode = DISTEXT;\n                /* fallthrough */\n        case DISTEXT:\n            if (state->extra) {\n                NEEDBITS(state->extra);\n                state->offset += BITS(state->extra);\n                DROPBITS(state->extra);\n                state->back += state->extra;\n            }\n#ifdef INFLATE_STRICT\n            if (state->offset > state->dmax) {\n                strm->msg = (char *)\"invalid distance too far back\";\n                state->mode = BAD;\n                break;\n            }\n#endif\n            Tracevv((stderr, \"inflate:         distance %u\\n\", state->offset));\n            state->mode = MATCH;\n                /* fallthrough */\n        case MATCH:\n            if (left == 0) goto inf_leave;\n            copy = out - left;\n            if (state->offset > copy) {         /* copy from window */\n                copy = state->offset - copy;\n                if (copy > state->whave) {\n                    if (state->sane) {\n                        strm->msg = (char *)\"invalid distance too far back\";\n                        state->mode = BAD;\n                        break;\n                    }\n#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n                    Trace((stderr, \"inflate.c too far\\n\"));\n                    copy -= state->whave;\n                    if (copy > state->length) copy = state->length;\n                    if (copy > left) copy = left;\n                    left -= copy;\n                    state->length -= copy;\n                    do {\n                        *put++ = 0;\n                    } while (--copy);\n                    if (state->length == 0) state->mode = LEN;\n                    break;\n#endif\n                }\n                if (copy > state->wnext) {\n                    copy -= state->wnext;\n                    from = state->window + (state->wsize - copy);\n                }\n                else\n                    from = state->window + (state->wnext - copy);\n                if (copy > state->length) copy = state->length;\n            }\n            else {                              /* copy from output */\n                from = put - state->offset;\n                copy = state->length;\n            }\n            if (copy > left) copy = left;\n            left -= copy;\n            state->length -= copy;\n            do {\n                *put++ = *from++;\n            } while (--copy);\n            if (state->length == 0) state->mode = LEN;\n            break;\n        case LIT:\n            if (left == 0) goto inf_leave;\n            *put++ = (unsigned char)(state->length);\n            left--;\n            state->mode = LEN;\n            break;\n        case CHECK:\n            if (state->wrap) {\n                NEEDBITS(32);\n                out -= left;\n                strm->total_out += out;\n                state->total += out;\n                if ((state->wrap & 4) && out)\n                    strm->adler = state->check =\n                        UPDATE_CHECK(state->check, put - out, out);\n                out = left;\n                if ((state->wrap & 4) && (\n#ifdef GUNZIP\n                     state->flags ? hold :\n#endif\n                     ZSWAP32(hold)) != state->check) {\n                    strm->msg = (char *)\"incorrect data check\";\n                    state->mode = BAD;\n                    break;\n                }\n                INITBITS();\n                Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n            }\n#ifdef GUNZIP\n            state->mode = LENGTH;\n                /* fallthrough */\n        case LENGTH:\n            if (state->wrap && state->flags) {\n                NEEDBITS(32);\n                if ((state->wrap & 4) && hold != (state->total & 0xffffffff)) {\n                    strm->msg = (char *)\"incorrect length check\";\n                    state->mode = BAD;\n                    break;\n                }\n                INITBITS();\n                Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n            }\n#endif\n            state->mode = DONE;\n                /* fallthrough */\n        case DONE:\n            ret = Z_STREAM_END;\n            goto inf_leave;\n        case BAD:\n            ret = Z_DATA_ERROR;\n            goto inf_leave;\n        case MEM:\n            return Z_MEM_ERROR;\n        case SYNC:\n                /* fallthrough */\n        default:\n            return Z_STREAM_ERROR;\n        }\n\n    /*\n       Return from inflate(), updating the total counts and the check value.\n       If there was no progress during the inflate() call, return a buffer\n       error.  Call updatewindow() to create and/or update the window state.\n       Note: a memory error from inflate() is non-recoverable.\n     */\n  inf_leave:\n    RESTORE();\n    if (state->wsize || (out != strm->avail_out && state->mode < BAD &&\n            (state->mode < CHECK || flush != Z_FINISH)))\n        if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {\n            state->mode = MEM;\n            return Z_MEM_ERROR;\n        }\n    in -= strm->avail_in;\n    out -= strm->avail_out;\n    strm->total_in += in;\n    strm->total_out += out;\n    state->total += out;\n    if ((state->wrap & 4) && out)\n        strm->adler = state->check =\n            UPDATE_CHECK(state->check, strm->next_out - out, out);\n    strm->data_type = (int)state->bits + (state->last ? 64 : 0) +\n                      (state->mode == TYPE ? 128 : 0) +\n                      (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);\n    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)\n        ret = Z_BUF_ERROR;\n    return ret;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"inftrees.h\"\n#   include \"inffixed.h\"\n#include \"inflate.h\"\n#include \"zutil.h\"\n#include \"inffast.h\"\n#include <stdio.h>\n\n// Type Definitions:\n// code:\ntypedef struct {\n    unsigned char op;           /* operation, extra bits, table bits */\n    unsigned char bits;         /* bits in this part of the code */\n    unsigned short val;         /* offset in table or code value */\n}\n\n// z_streamp:\ntypedef z_stream FAR *z_streamp;\n\n// inflate_state:\nstruct inflate_state {\n    z_streamp strm;             /* pointer back to this zlib stream */\n    inflate_mode mode;          /* current inflate mode */\n    int last;                   /* true if processing last block */\n    int wrap;                   /* bit 0 true for zlib, bit 1 true for gzip,\n                                   bit 2 true to validate check value */\n    int havedict;               /* true if dictionary provided */\n    int flags;                  /* gzip header method and flags, 0 if zlib, or\n                                   -1 if raw or no header yet */\n    unsigned dmax;              /* zlib header max distance (INFLATE_STRICT) */\n    unsigned long check;        /* protected copy of check value */\n    unsigned long total;        /* protected copy of output count */\n    gz_headerp head;            /* where to save gzip header information */\n        /* sliding window */\n    unsigned wbits;             /* log base 2 of requested window size */\n    unsigned wsize; ...\n\n// inflate_state:\nstruct inflate_state {\n        /* sliding window */\n    unsigned char FAR *window;  /* allocated sliding window, if needed */\n        /* dynamic table building */\n    unsigned ncode;             /* number of code length code lengths */\n    unsigned nlen;              /* number of length code lengths */\n    unsigned ndist;             /* number of distance code lengths */\n    unsigned have;              /* number of code lengths in lens[] */\n    code FAR *next;             /* next available space in codes[] */\n    unsigned short lens[320];   /* temporary storage for code lengths */\n    unsigned short work[288];   /* work area for code table building */\n    code codes[ENOUGH];         /* space for code tables */\n}\n\n// Called Methods (top 10):\n// inflateStateCheck from inflate.c:\nlocal int inflateStateCheck(strm)\nz_streamp strm;\n{\n    struct inflate_state FAR *state;\n    if (strm == Z_NULL ||\n        strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0)\n        return 1;\n    state = (struct inflate_state FAR *)strm->state;\n    if (state == Z_NULL || state->strm != strm ||\n        state->mode < HEAD || state->mode > SYNC)\n        return 1;\n    return 0;\n}\n\n// PULLBYTE from inflate.c:\n<empty>\n\n// crc32 from crc32.c:\nunsigned long ZEXPORT crc32(crc, buf, len)\n    unsigned long crc;\n    const unsigned char FAR *buf;\n    uInt len;\n{\n    return crc32_z(crc, buf, len);\n}\n\n// Z_NEED_DICT from zlib.h:\n<empty>\n\n// MOD from adler32.c:\n\n\n// Z_STREAM_END from zlib.h:\n<empty>\n\n// Z_DATA_ERROR from zlib.h:\n<empty>\n\n// updatewindow from inflate.c:\nlocal int updatewindow(strm, end, copy)\nz_streamp strm;\nconst Bytef *end;\nunsigned copy;\n{\n    struct inflate_state FAR *state;\n    unsigned dist;\n\n    state = (struct inflate_state FAR *)strm->state;\n\n    /* if it hasn't been done already, allocate space for the window */\n    if (state->window == Z_NULL) {\n        state->window = (unsigned char FAR *)\n                        ZALLOC(strm, 1U << state->wbits,\n                               sizeof(unsigned char));\n        if (state->window == Z_NULL) return 1;\n    }\n\n    /* if window not in use yet, initialize */\n    if (state->wsize == 0) {\n        state->wsize = 1U << state->wbits;\n        state->wnext = 0;\n        state->whave = 0;\n    }\n\n    /* copy state->wsize or less output bytes into the circular window */\n    if (copy >= state->wsize) {\n        zmemcpy(state->window, end - state->wsize, state->wsize);\n        state->wnext = 0;\n        state->whave = state->wsize;\n    }\n    else {\n        dist = state->wsize - state->wnext;\n  ...\n\n// LOAD from inflate.c:\n<empty>\n\n// memcpy from zutil.c:\nvoid ZLIB_INTERNAL zmemcpy(dest, source, len)\n    Bytef* dest;\n    const Bytef* source;\n    uInt  len;\n{\n    if (len == 0) return;\n    do {\n        *dest++ = *source++; /* ??? to be unrolled */\n    } while (--len != 0);\n}\n"
  },
  {
    "repository": "tensorflow",
    "cve_id": "CVE-2021-41224",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "67bfd9feeecfb3c61d80f0e46d89c170fbee682b",
    "short_hash": "67bfd9fe",
    "vulnerableMethods_before": [
      {
        "filename": "sparse_fill_empty_rows_op.cc",
        "method_name": "vulnerable_function",
        "raw_code": "void SparseFillEmptyRowsOpImpl(OpKernelContext* context,\n                               AsyncOpKernel::DoneCallback done = nullptr) {\n  // Note that setting this empty lambda as the default parameter value directly\n  // can cause strange compiler/linker errors, so we do it like this instead.\n  if (!done) {\n    done = [] {};\n  }\n\n  const int kIndicesInput = 0;\n  const int kValuesInput = 1;\n  const int kDenseShapeInput = 2;\n  const int kDefaultValueInput = 3;\n\n  const Tensor& indices_t = context->input(kIndicesInput);\n  const Tensor& values_t = context->input(kValuesInput);\n  const Tensor& dense_shape_t = context->input(kDenseShapeInput);\n  const Tensor& default_value_t = context->input(kDefaultValueInput);\n\n  OP_REQUIRES_ASYNC(\n      context, TensorShapeUtils::IsVector(dense_shape_t.shape()),\n      errors::InvalidArgument(\"dense_shape must be a vector, saw: \",\n                              dense_shape_t.shape().DebugString()),\n      done);\n  OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsMatrix(indices_t.shape()),\n                    errors::InvalidArgument(\"indices must be a matrix, saw: \",\n                                            indices_t.shape().DebugString()),\n                    done);\n  OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsVector(values_t.shape()),\n                    errors::InvalidArgument(\"values must be a vector, saw: \",\n                                            values_t.shape().DebugString()),\n                    done);\n  OP_REQUIRES_ASYNC(\n      context, TensorShapeUtils::IsScalar(default_value_t.shape()),\n      errors::InvalidArgument(\"default_value must be a scalar, saw: \",\n                              default_value_t.shape().DebugString()),\n      done);\n  // TODO(ebrevdo): add shape checks between values, indices,\n  // Also add check that dense rank > 0.\n  OP_REQUIRES_ASYNC(context, dense_shape_t.NumElements() != 0,\n                    errors::InvalidArgument(\"Dense shape cannot be empty.\"),\n                    done);\n\n  using FunctorType = functor::SparseFillEmptyRows<Device, T, Tindex>;\n  OP_REQUIRES_OK_ASYNC(context,\n                       FunctorType()(context, default_value_t, indices_t,\n                                     values_t, dense_shape_t, done),\n                       done);\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "None",
        "method_name": "fixed_function",
        "raw_code": "void SparseFillEmptyRowsOpImpl(OpKernelContext* context,\n                               AsyncOpKernel::DoneCallback done = nullptr) {\n  // Note that setting this empty lambda as the default parameter value directly\n  // can cause strange compiler/linker errors, so we do it like this instead.\n  if (!done) {\n    done = [] {};\n  }\n\n  const int kIndicesInput = 0;\n  const int kValuesInput = 1;\n  const int kDenseShapeInput = 2;\n  const int kDefaultValueInput = 3;\n\n  const Tensor& indices_t = context->input(kIndicesInput);\n  const Tensor& values_t = context->input(kValuesInput);\n  const Tensor& dense_shape_t = context->input(kDenseShapeInput);\n  const Tensor& default_value_t = context->input(kDefaultValueInput);\n\n  OP_REQUIRES_ASYNC(\n      context, TensorShapeUtils::IsVector(dense_shape_t.shape()),\n      errors::InvalidArgument(\"dense_shape must be a vector, saw: \",\n                              dense_shape_t.shape().DebugString()),\n      done);\n  OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsMatrix(indices_t.shape()),\n                    errors::InvalidArgument(\"indices must be a matrix, saw: \",\n                                            indices_t.shape().DebugString()),\n                    done);\n  OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsVector(values_t.shape()),\n                    errors::InvalidArgument(\"values must be a vector, saw: \",\n                                            values_t.shape().DebugString()),\n                    done);\n  OP_REQUIRES_ASYNC(\n      context, indices_t.dim_size(0) == values_t.dim_size(0),\n      errors::InvalidArgument(\"The length of `values` (\", values_t.dim_size(0),\n                              \") must match the first dimension of `indices` (\",\n                              indices_t.dim_size(0), \").\"),\n      done);\n  OP_REQUIRES_ASYNC(\n      context, TensorShapeUtils::IsScalar(default_value_t.shape()),\n      errors::InvalidArgument(\"default_value must be a scalar, saw: \",\n                              default_value_t.shape().DebugString()),\n      done);\n  // TODO(ebrevdo): add shape checks between values, indices,\n  // Also add check that dense rank > 0.\n  OP_REQUIRES_ASYNC(context, dense_shape_t.NumElements() != 0,\n                    errors::InvalidArgument(\"Dense shape cannot be empty.\"),\n                    done);\n\n  using FunctorType = functor::SparseFillEmptyRows<Device, T, Tindex>;\n  OP_REQUIRES_OK_ASYNC(context,\n                       FunctorType()(context, default_value_t, indices_t,\n                                     values_t, dense_shape_t, done),\n                       done);\n}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "radare2",
    "cve_id": "CVE-2022-1031",
    "cwe_list": [
      "CWE-416"
    ],
    "commit_hash": "a7ce29647fcb38386d7439696375e16e093d6acb",
    "short_hash": "a7ce2964",
    "vulnerableMethods_before": [
      {
        "filename": "None",
        "method_name": "vulnerable_function",
        "raw_code": "static void extract_arg(RAnal *anal, RAnalFunction *fcn, RAnalOp *op, const char *reg, const char *sign, char type) {\n\tst64 ptr = 0;\n\tchar *addr, *esil_buf = NULL;\n\tconst st64 maxstackframe = 1024 * 8; \n\n\tr_return_if_fail (anal && fcn && op && reg);\n\n\tsize_t i;\n\tfor (i = 0; i < R_ARRAY_SIZE (op->src); i++) {\n\t\tif (op->src[i] && op->src[i]->reg && op->src[i]->reg->name) {\n\t\t\tif (!strcmp (reg, op->src[i]->reg->name)) {\n\t\t\t\tst64 delta = op->src[i]->delta;\n\t\t\t\tif ((delta > 0 && *sign == '+') || (delta < 0 && *sign == '-')) {\n\t\t\t\t\tptr = R_ABS (op->src[i]->delta);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!ptr) {\n\t\tconst char *op_esil = r_strbuf_get (&op->esil);\n\t\tif (!op_esil) {\n\t\t\treturn;\n\t\t}\n\t\tesil_buf = strdup (op_esil);\n\t\tif (!esil_buf) {\n\t\t\treturn;\n\t\t}\n\t\tr_strf_var (esilexpr, 64, \",%s,%s,\", reg, sign);\n\t\tchar *ptr_end = strstr (esil_buf, esilexpr);\n\t\tif (!ptr_end) {\n\t\t\tfree (esil_buf);\n\t\t\treturn;\n\t\t}\n\t\t*ptr_end = 0;\n\t\taddr = ptr_end;\n\t\twhile ((addr[0] != '0' || addr[1] != 'x') && addr >= esil_buf + 1 && *addr != ',') {\n\t\t\taddr--;\n\t\t}\n\t\tif (strncmp (addr, \"0x\", 2)) {\n\t\t\t//XXX: This is a workaround for inconsistent esil\n\t\t\tif (!op->stackop && op->dst) {\n\t\t\t\tconst char *sp = r_reg_get_name (anal->reg, R_REG_NAME_SP);\n\t\t\t\tconst char *bp = r_reg_get_name (anal->reg, R_REG_NAME_BP);\n\t\t\t\tconst char *rn = op->dst->reg ? op->dst->reg->name : NULL;\n\t\t\t\tif (rn && ((bp && !strcmp (bp, rn)) || (sp && !strcmp (sp, rn)))) {\n\t\t\t\t\tif (anal->verbose) {\n\t\t\t\t\t\teprintf (\"Warning: Analysis didn't fill op->stackop for instruction that alters stack at 0x%\" PFMT64x \".\\n\", op->addr);\n\t\t\t\t\t}\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (*addr == ',') {\n\t\t\t\taddr++;\n\t\t\t}\n\t\t\tif (!op->stackop && op->type != R_ANAL_OP_TYPE_PUSH && op->type != R_ANAL_OP_TYPE_POP\n\t\t\t\t&& op->type != R_ANAL_OP_TYPE_RET && r_str_isnumber (addr)) {\n\t\t\t\tptr = (st64)r_num_get (NULL, addr);\n\t\t\t\tif (ptr && op->src[0] && ptr == op->src[0]->imm) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t} else if ((op->stackop == R_ANAL_STACK_SET) || (op->stackop == R_ANAL_STACK_GET)) {\n\t\t\t\tif (op->ptr % 4) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tptr = R_ABS (op->ptr);\n\t\t\t} else {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t} else {\n\t\t\tptr = (st64)r_num_get (NULL, addr);\n\t\t}\n\t}\n\n\tif (anal->verbose && (!op->src[0] || !op->dst)) {\n\t\teprintf (\"Warning: Analysis didn't fill op->src/dst at 0x%\" PFMT64x \".\\n\", op->addr);\n\t}\n\n\tint rw = (op->direction == R_ANAL_OP_DIR_WRITE) ? R_ANAL_VAR_ACCESS_TYPE_WRITE : R_ANAL_VAR_ACCESS_TYPE_READ;\n\tif (*sign == '+') {\n\t\tconst bool isarg = type == R_ANAL_VAR_KIND_SPV ? ptr >= fcn->stack : ptr >= fcn->bp_off;\n\t\tconst char *pfx = isarg ? ARGPREFIX : VARPREFIX;\n\t\tst64 frame_off;\n\t\tif (type == R_ANAL_VAR_KIND_SPV) {\n\t\t\tframe_off = ptr - fcn->stack;\n\t\t} else {\n\t\t\tframe_off = ptr - fcn->bp_off;\n\t\t}\n\t\tif (maxstackframe != 0 && (frame_off > maxstackframe || frame_off < -maxstackframe)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tRAnalVar *var = get_stack_var (fcn, frame_off);\n\t\tif (var) {\n\t\t\tr_anal_var_set_access (var, reg, op->addr, rw, ptr);\n\t\t\tgoto beach;\n\t\t}\n\t\tchar *varname = NULL, *vartype = NULL;\n\t\tif (isarg) {\n\t\t\tconst char *place = fcn->cc ? r_anal_cc_arg (anal, fcn->cc, ST32_MAX) : NULL;\n\t\t\tbool stack_rev = place ? !strcmp (place, \"stack_rev\") : false;\n\t\t\tchar *fname = r_type_func_guess (anal->sdb_types, fcn->name);\n\t\t\tif (fname) {\n\t\t\t\tut64 sum_sz = 0;\n\t\t\t\tsize_t from, to, i;\n\t\t\t\tif (stack_rev) {\n\t\t\t\t\tconst size_t cnt = r_type_func_args_count (anal->sdb_types, fname);\n\t\t\t\t\tfrom = cnt ? cnt - 1 : cnt;\n\t\t\t\t\tto = fcn->cc ? r_anal_cc_max_arg (anal, fcn->cc) : 0;\n\t\t\t\t} else {\n\t\t\t\t\tfrom = fcn->cc ? r_anal_cc_max_arg (anal, fcn->cc) : 0;\n\t\t\t\t\tto = r_type_func_args_count (anal->sdb_types, fname);\n\t\t\t\t}\n\t\t\t\tconst int bytes = (fcn->bits ? fcn->bits : anal->bits) / 8;\n\t\t\t\tfor (i = from; stack_rev ? i >= to : i < to; stack_rev ? i-- : i++) {\n\t\t\t\t\tchar *tp = r_type_func_args_type (anal->sdb_types, fname, i);\n\t\t\t\t\tif (!tp) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (sum_sz == frame_off) {\n\t\t\t\t\t\tvartype = tp;\n\t\t\t\t\t\tvarname = strdup (r_type_func_args_name (anal->sdb_types, fname, i));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tut64 bit_sz = r_type_get_bitsize (anal->sdb_types, tp);\n\t\t\t\t\tsum_sz += bit_sz ? bit_sz / 8 : bytes;\n\t\t\t\t\tsum_sz = R_ROUND (sum_sz, bytes);\n\t\t\t\t\tfree (tp);\n\t\t\t\t}\n\t\t\t\tfree (fname);\n\t\t\t}\n\t\t}\n\t\tif (!varname) {\n\t\t\tif (anal->opt.varname_stack) {\n\t\t\t\tvarname = r_str_newf (\"%s_%\" PFMT64x \"h\", pfx, R_ABS (frame_off));\n\t\t\t} else {\n\t\t\t\tvarname = r_anal_function_autoname_var (fcn, type, pfx, ptr);\n\t\t\t}\n\t\t}\n\t\tif (varname) {\n#if 0\n\t\t\tif (isarg && frame_off > 48) {\n\t\t\t\tfree (varname);\n\t\t\t\tgoto beach;\n\t\t\t}\n#endif\n\t\t\tRAnalVar *var = r_anal_function_set_var (fcn, frame_off, type, vartype, anal->bits / 8, isarg, varname);\n\t\t\tif (var) {\n\t\t\t\tr_anal_var_set_access (var, reg, op->addr, rw, ptr);\n\t\t\t}\n\t\t\tfree (varname);\n\t\t}\n\t\tfree (vartype);\n\t} else {\n\t\tst64 frame_off = -(ptr + fcn->bp_off);\n\t\tif (maxstackframe != 0 && (frame_off > maxstackframe || frame_off < -maxstackframe)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tRAnalVar *var = get_stack_var (fcn, frame_off);\n\t\tif (var) {\n\t\t\tr_anal_var_set_access (var, reg, op->addr, rw, -ptr);\n\t\t\tgoto beach;\n\t\t}\n\t\tchar *varname = anal->opt.varname_stack\n\t\t\t? r_str_newf (\"%s_%\" PFMT64x \"h\", VARPREFIX, R_ABS (frame_off))\n\t\t\t: r_anal_function_autoname_var (fcn, type, VARPREFIX, -ptr);\n\t\tif (varname) {\n\t\t\tRAnalVar *var = r_anal_function_set_var (fcn, frame_off, type, NULL, anal->bits / 8, false, varname);\n\t\t\tif (var) {\n\t\t\t\tr_anal_var_set_access (var, reg, op->addr, rw, -ptr);\n\t\t\t}\n\t\t\tfree (varname);\n\t\t}\n\t}\nbeach:\n\tfree (esil_buf);\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "None",
        "method_name": "fixed_function",
        "raw_code": "static void extract_arg(RAnal *anal, RAnalFunction *fcn, RAnalOp *op, const char *reg, const char *sign, char type) {\n\tst64 ptr = 0;\n\tchar *addr, *esil_buf = NULL;\n\tconst st64 maxstackframe = 1024 * 8; \n\n\tr_return_if_fail (anal && fcn && op && reg);\n\n\tsize_t i;\n\tfor (i = 0; i < R_ARRAY_SIZE (op->src); i++) {\n\t\tif (op->src[i] && op->src[i]->reg && op->src[i]->reg->name) {\n\t\t\tif (!strcmp (reg, op->src[i]->reg->name)) {\n\t\t\t\tst64 delta = op->src[i]->delta;\n\t\t\t\tif ((delta > 0 && *sign == '+') || (delta < 0 && *sign == '-')) {\n\t\t\t\t\tptr = R_ABS (op->src[i]->delta);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!ptr) {\n\t\tconst char *op_esil = r_strbuf_get (&op->esil);\n\t\tif (!op_esil) {\n\t\t\treturn;\n\t\t}\n\t\tesil_buf = strdup (op_esil);\n\t\tif (!esil_buf) {\n\t\t\treturn;\n\t\t}\n\t\tr_strf_var (esilexpr, 64, \",%s,%s,\", reg, sign);\n\t\tchar *ptr_end = strstr (esil_buf, esilexpr);\n\t\tif (!ptr_end) {\n\t\t\tfree (esil_buf);\n\t\t\treturn;\n\t\t}\n\t\t*ptr_end = 0;\n\t\taddr = ptr_end;\n\t\twhile ((addr[0] != '0' || addr[1] != 'x') && addr >= esil_buf + 1 && *addr != ',') {\n\t\t\taddr--;\n\t\t}\n\t\tif (strncmp (addr, \"0x\", 2)) {\n\t\t\t//XXX: This is a workaround for inconsistent esil\n\t\t\tif (!op->stackop && op->dst) {\n\t\t\t\tconst char *sp = r_reg_get_name (anal->reg, R_REG_NAME_SP);\n\t\t\t\tconst char *bp = r_reg_get_name (anal->reg, R_REG_NAME_BP);\n\t\t\t\tconst char *rn = op->dst->reg ? op->dst->reg->name : NULL;\n\t\t\t\tif (rn && ((bp && !strcmp (bp, rn)) || (sp && !strcmp (sp, rn)))) {\n\t\t\t\t\tif (anal->verbose) {\n\t\t\t\t\t\teprintf (\"Warning: Analysis didn't fill op->stackop for instruction that alters stack at 0x%\" PFMT64x \".\\n\", op->addr);\n\t\t\t\t\t}\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (*addr == ',') {\n\t\t\t\taddr++;\n\t\t\t}\n\t\t\tif (!op->stackop && op->type != R_ANAL_OP_TYPE_PUSH && op->type != R_ANAL_OP_TYPE_POP\n\t\t\t\t&& op->type != R_ANAL_OP_TYPE_RET && r_str_isnumber (addr)) {\n\t\t\t\tptr = (st64)r_num_get (NULL, addr);\n\t\t\t\tif (ptr && op->src[0] && ptr == op->src[0]->imm) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t} else if ((op->stackop == R_ANAL_STACK_SET) || (op->stackop == R_ANAL_STACK_GET)) {\n\t\t\t\tif (op->ptr % 4) {\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tptr = R_ABS (op->ptr);\n\t\t\t} else {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t} else {\n\t\t\tptr = (st64)r_num_get (NULL, addr);\n\t\t}\n\t}\n\n\tif (anal->verbose && (!op->src[0] || !op->dst)) {\n\t\teprintf (\"Warning: Analysis didn't fill op->src/dst at 0x%\" PFMT64x \".\\n\", op->addr);\n\t}\n\n\tint rw = (op->direction == R_ANAL_OP_DIR_WRITE) ? R_ANAL_VAR_ACCESS_TYPE_WRITE : R_ANAL_VAR_ACCESS_TYPE_READ;\n\tif (*sign == '+') {\n\t\tconst bool isarg = type == R_ANAL_VAR_KIND_SPV ? ptr >= fcn->stack : ptr >= fcn->bp_off;\n\t\tconst char *pfx = isarg ? ARGPREFIX : VARPREFIX;\n\t\tst64 frame_off;\n\t\tif (type == R_ANAL_VAR_KIND_SPV) {\n\t\t\tframe_off = ptr - fcn->stack;\n\t\t} else {\n\t\t\tframe_off = ptr - fcn->bp_off;\n\t\t}\n\t\tif (maxstackframe != 0 && (frame_off > maxstackframe || frame_off < -maxstackframe)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tRAnalVar *var = get_stack_var (fcn, frame_off);\n\t\tif (var) {\n\t\t\tr_anal_var_set_access (var, reg, op->addr, rw, ptr);\n\t\t\tgoto beach;\n\t\t}\n\t\tchar *varname = NULL, *vartype = NULL;\n\t\tif (isarg) {\n\t\t\tconst char *place = fcn->cc ? r_anal_cc_arg (anal, fcn->cc, ST32_MAX) : NULL;\n\t\t\tbool stack_rev = place ? !strcmp (place, \"stack_rev\") : false;\n\t\t\tchar *fname = r_type_func_guess (anal->sdb_types, fcn->name);\n\t\t\tif (fname) {\n\t\t\t\tut64 sum_sz = 0;\n\t\t\t\tsize_t from, to, i;\n\t\t\t\tif (stack_rev) {\n\t\t\t\t\tconst size_t cnt = r_type_func_args_count (anal->sdb_types, fname);\n\t\t\t\t\tfrom = cnt ? cnt - 1 : cnt;\n\t\t\t\t\tto = fcn->cc ? r_anal_cc_max_arg (anal, fcn->cc) : 0;\n\t\t\t\t} else {\n\t\t\t\t\tfrom = fcn->cc ? r_anal_cc_max_arg (anal, fcn->cc) : 0;\n\t\t\t\t\tto = r_type_func_args_count (anal->sdb_types, fname);\n\t\t\t\t}\n\t\t\t\tconst int bytes = (fcn->bits ? fcn->bits : anal->bits) / 8;\n\t\t\t\tfor (i = from; stack_rev ? i >= to : i < to; stack_rev ? i-- : i++) {\n\t\t\t\t\tchar *tp = r_type_func_args_type (anal->sdb_types, fname, i);\n\t\t\t\t\tif (!tp) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (sum_sz == frame_off) {\n\t\t\t\t\t\tvartype = tp;\n\t\t\t\t\t\tvarname = strdup (r_type_func_args_name (anal->sdb_types, fname, i));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tut64 bit_sz = r_type_get_bitsize (anal->sdb_types, tp);\n\t\t\t\t\tsum_sz += bit_sz ? bit_sz / 8 : bytes;\n\t\t\t\t\tsum_sz = R_ROUND (sum_sz, bytes);\n\t\t\t\t\tfree (tp);\n\t\t\t\t}\n\t\t\t\tfree (fname);\n\t\t\t}\n\t\t}\n\t\tif (!varname) {\n\t\t\tif (anal->opt.varname_stack) {\n\t\t\t\tvarname = r_str_newf (\"%s_%\" PFMT64x \"h\", pfx, R_ABS (frame_off));\n\t\t\t} else {\n\t\t\t\tvarname = r_anal_function_autoname_var (fcn, type, pfx, ptr);\n\t\t\t}\n\t\t}\n\t\tif (varname) {\n#if 0\n\t\t\tif (isarg && frame_off > 48) {\n\t\t\t\tfree (varname);\n\t\t\t\tgoto beach;\n\t\t\t}\n#endif\n\t\t\tRAnalVar *var = r_anal_function_set_var (fcn, frame_off, type, vartype, anal->bits / 8, isarg, varname);\n\t\t\tif (var) {\n\t\t\t\tr_anal_var_set_access (var, reg, op->addr, rw, ptr);\n\t\t\t}\n\t\t\tfree (varname);\n\t\t}\n\t\tfree (vartype);\n\t} else {\n\t\tst64 frame_off = -(ptr + fcn->bp_off);\n\t\tif (maxstackframe > 0 && (frame_off > maxstackframe || frame_off < -maxstackframe)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tRAnalVar *var = get_stack_var (fcn, frame_off);\n\t\tif (var) {\n\t\t\tr_anal_var_set_access (var, reg, op->addr, rw, -ptr);\n\t\t\tgoto beach;\n\t\t}\n\t\tchar *varname = anal->opt.varname_stack\n\t\t\t? r_str_newf (\"%s_%\" PFMT64x \"h\", VARPREFIX, R_ABS (frame_off))\n\t\t\t: r_anal_function_autoname_var (fcn, type, VARPREFIX, -ptr);\n\t\tif (varname) {\n\t\t\tRAnalVar *var = r_anal_function_set_var (fcn, frame_off, type, NULL, anal->bits / 8, false, varname);\n\t\t\tif (var) {\n\t\t\t\tr_anal_var_set_access (var, reg, op->addr, rw, -ptr);\n\t\t\t}\n\t\t\tfree (varname);\n\t\t}\n\t}\nbeach:\n\tfree (esil_buf);\n}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "bash",
    "cve_id": "CVE-2019-18276",
    "cwe_list": [
      "CWE-787"
    ],
    "commit_hash": "951bdaad7a18cc0dc1036bba86b18b90874d39ff",
    "short_hash": "951bdaad",
    "vulnerableMethods_before": [
      {
        "filename": "shell.c",
        "method_name": "vulnerable_function",
        "raw_code": "disable_priv_mode ()\n{\n  int e;\n\n  if (setuid (current_user.uid) < 0)\n    {\n      e = errno;\n      sys_error (_(\"cannot set uid to %d: effective uid %d\"), current_user.uid, current_user.euid);\n#if defined (EXIT_ON_SETUID_FAILURE)\n      if (e == EAGAIN)\n\texit (e);\n#endif\n    }\n  if (setgid (current_user.gid) < 0)\n    sys_error (_(\"cannot set gid to %d: effective gid %d\"), current_user.gid, current_user.egid);\n\n  current_user.euid = current_user.uid;\n  current_user.egid = current_user.gid;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "shell.c",
        "method_name": "fixed_function",
        "raw_code": "disable_priv_mode ()\n{\n  int e;\n\n#if HAVE_DECL_SETRESUID\n  if (setresuid (current_user.uid, current_user.uid, current_user.uid) < 0)\n#else\n  if (setuid (current_user.uid) < 0)\n#endif\n    {\n      e = errno;\n      sys_error (_(\"cannot set uid to %d: effective uid %d\"), current_user.uid, current_user.euid);\n#if defined (EXIT_ON_SETUID_FAILURE)\n      if (e == EAGAIN)\n\texit (e);\n#endif\n    }\n#if HAVE_DECL_SETRESGID\n  if (setresgid (current_user.gid, current_user.gid, current_user.gid) < 0)\n#else\n  if (setgid (current_user.gid) < 0)\n#endif\n    sys_error (_(\"cannot set gid to %d: effective gid %d\"), current_user.gid, current_user.egid);\n\n  current_user.euid = current_user.uid;\n  current_user.egid = current_user.gid;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"xmalloc.h\"\n#include \"config.h\"\n#  include \"bashhist.h\"\n#include \"posixstat.h\"\n#  include <pwd.h>\n#  include \"bashline.h\"\n#    include <sys/types.h>\n#include \"bashansi.h\"\n#include \"parser.h\"\n#  include <strings.h>\n#include \"jobs.h\"\n#include \"trap.h\"\n#include <pwd.h>\n#include \"bashtypes.h\"\n#include \"builtins.h\"\n#include \"mailcheck.h\"\n#  include <sys/file.h>\n#include \"execute_cmd.h\"\n#  include <config.h>\n#include \"rlstdc.h\"\n#  include <limits.h>\n#include \"rlshell.h\"\n#include \"filecntl.h\"\n#include \"posixtime.h\"\n#include \"rldefs.h\"\n#  include <string.h>\n#  include <stdlib.h>\n#include \"builtins/common.h\"\n#include \"input.h\"\n#include \"findcmd.h\"\n#include \"bashintl.h\"\n#include <tilde/tilde.h>\n#include <glob/strmatch.h>\n#  include <malloc/shmalloc.h>\n#include <signal.h>\n#include \"flags.h\"\n#include <errno.h>\n#include <sys/types.h>\n#  include <readline/readline.h>\n#include <fcntl.h>\n#  include \"ansi_stdlib.h\"\n#include <stdio.h>\n#  include <opennt/opennt.h>\n#  include <readline/history.h>\n#  include <unistd.h>\n#include \"shell.h\"\n"
  },
  {
    "repository": "swtpm",
    "cve_id": "CVE-2022-23645",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "9f740868fc36761de27df3935513bdebf8852d19",
    "short_hash": "9f740868",
    "vulnerableMethods_before": [
      {
        "filename": "swtpm_nvfile.c",
        "method_name": "vulnerable_function",
        "raw_code": "SWTPM_NVRAM_CheckHeader(unsigned char *data, uint32_t length,\n                        uint32_t *dataoffset, uint16_t *hdrflags,\n                        uint8_t *hdrversion, bool quiet)\n{\n    blobheader *bh = (blobheader *)data;\n\n    if (length < sizeof(bh)) {\n        if (!quiet)\n            logprintf(STDERR_FILENO,\n                      \"not enough bytes for header: %u\\n\", length);\n        return TPM_BAD_PARAMETER;\n    }\n\n    if (ntohl(bh->totlen) != length) {\n        if (!quiet)\n            logprintf(STDERR_FILENO,\n                      \"broken header: bh->totlen %u != %u\\n\",\n                      htonl(bh->totlen), length);\n        return TPM_BAD_PARAMETER;\n    }\n\n    if (bh->min_version > BLOB_HEADER_VERSION) {\n        if (!quiet)\n            logprintf(STDERR_FILENO,\n                      \"Minimum required version for the blob is %d, we \"\n                      \"only support version %d\\n\", bh->min_version,\n                      BLOB_HEADER_VERSION);\n        return TPM_BAD_VERSION;\n    }\n\n    *hdrversion = bh->version;\n    *dataoffset = ntohs(bh->hdrsize);\n    *hdrflags = ntohs(bh->flags);\n\n    return TPM_SUCCESS;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "swtpm_nvstore.c",
        "method_name": "fixed_function",
        "raw_code": "SWTPM_NVRAM_CheckHeader(unsigned char *data, uint32_t length,\n                        uint32_t *dataoffset, uint16_t *hdrflags,\n                        uint8_t *hdrversion, bool quiet)\n{\n    blobheader *bh = (blobheader *)data;\n    uint16_t hdrsize;\n\n    if (length < sizeof(bh)) {\n        if (!quiet)\n            logprintf(STDERR_FILENO,\n                      \"not enough bytes for header: %u\\n\", length);\n        return TPM_BAD_PARAMETER;\n    }\n\n    if (ntohl(bh->totlen) != length) {\n        if (!quiet)\n            logprintf(STDERR_FILENO,\n                      \"broken header: bh->totlen %u != %u\\n\",\n                      htonl(bh->totlen), length);\n        return TPM_BAD_PARAMETER;\n    }\n\n    if (bh->min_version > BLOB_HEADER_VERSION) {\n        if (!quiet)\n            logprintf(STDERR_FILENO,\n                      \"Minimum required version for the blob is %d, we \"\n                      \"only support version %d\\n\", bh->min_version,\n                      BLOB_HEADER_VERSION);\n        return TPM_BAD_VERSION;\n    }\n\n    hdrsize = ntohs(bh->hdrsize);\n    if (hdrsize != sizeof(blobheader)) {\n        logprintf(STDERR_FILENO,\n                  \"bad header size: %u != %zu\\n\",\n                  hdrsize, sizeof(blobheader));\n        return TPM_BAD_DATASIZE;\n    }\n\n    *hdrversion = bh->version;\n    *dataoffset = hdrsize;\n    *hdrflags = ntohs(bh->flags);\n\n    return TPM_SUCCESS;\n}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "tensorflow",
    "cve_id": "CVE-2021-37665",
    "cwe_list": [
      "CWE-703"
    ],
    "commit_hash": "9e62869465573cb2d9b5053f1fa02a81fce21d69",
    "short_hash": "9e628694",
    "vulnerableMethods_before": [
      {
        "filename": "mkl_requantization_range_per_channel_op.cc",
        "method_name": "vulnerable_function",
        "raw_code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& input = ctx->input(kInputTensorIndex);\n    const Tensor& input_min = ctx->input(kInputMinIndex);\n    const Tensor& input_max = ctx->input(kInputMaxIndex);\n\n    const size_t depth = input_max.NumElements();\n    OP_REQUIRES(\n        ctx, input_min.dim_size(0) == depth,\n        errors::InvalidArgument(\"input_min has incorrect size, expected \",\n                                depth, \" was \", input_min.dim_size(0)));\n    OP_REQUIRES(\n        ctx, input_max.dim_size(0) == depth,\n        errors::InvalidArgument(\"input_max has incorrect size, expected \",\n                                depth, \" was \", input_max.dim_size(0)));\n\n    const float* input_min_data = input_min.flat<float>().data();\n    const float* input_max_data = input_max.flat<float>().data();\n    std::vector<float> ranges(depth);\n    bool is_non_negative = true;\n    Eigen::array<int, 2> shuffling({1, 0});\n    auto input_matrix = input.flat_inner_dims<qint32>();\n\n    // TODO: verify performance of not transposing and finding the min max\n    // directly from input_matrix vs the one presented below of transposing and\n    // using the transposed matrix as the transposing operation in itself might\n    // be more costly.\n    // Note that this operation is a calibration step for quantization and will\n    // cease to exist in the final inference graph(will exist as a const node).\n    auto transposed_input = input_matrix.shuffle(shuffling);\n\n    // Find the ranges of each channel in parallel.\n    float out_min_max = std::numeric_limits<float>::min();\n\n#ifdef ENABLE_ONEDNN_OPENMP\n#ifdef _MSC_VER\n#pragma omp parallel for\n#else\n#pragma omp parallel for reduction(max : out_min_max)\n#endif\n#endif  // ENABLE_ONEDNN_OPENMP\n    // TODO: Add eigen parallel_for\n    for (int64_t i = 0; i < depth; ++i) {\n      Eigen::Tensor<qint32, 0, Eigen::RowMajor> min =\n          transposed_input.chip<0>(i).minimum();\n      Eigen::Tensor<qint32, 0, Eigen::RowMajor> max =\n          transposed_input.chip<0>(i).maximum();\n      const int32_t min_per_channel = min();\n      const int32_t max_per_channel = max();\n      const int32_t abs_max =\n          std::max(std::abs(min_per_channel), std::abs(max_per_channel));\n      float scale =\n          std::max(std::abs(input_min_data[i]), std::abs(input_max_data[i]));\n      ranges[i] =\n          scale * static_cast<float>(abs_max) / static_cast<float>(1L << 31);\n      if (min_per_channel < 0) is_non_negative = false;\n\n      // Thread-local out_min_max.\n      out_min_max = std::max(out_min_max, ranges[i]);\n    }\n\n    // All local out_min_max gets max-reduced into one global out_min_max at\n    // the end of the loop by specifying reduction(max:out_min_max) along with\n    // omp parallel for.\n\n    // Fixing max to clip_value_max_ (example 6.0 to support relu6)\n    if (out_min_max > clip_value_max_) out_min_max = clip_value_max_;\n\n    Tensor* output_min = nullptr;\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(kOutputMinIndex, {}, &output_min));\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(kOutputMaxIndex, {}, &output_max));\n    output_min->flat<float>()(0) = is_non_negative ? 0.0f : -out_min_max;\n    output_max->flat<float>()(0) = out_min_max;\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "mkl_requantization_range_per_channel_op.cc",
        "method_name": "fixed_function",
        "raw_code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& input = ctx->input(kInputTensorIndex);\n    const Tensor& input_min = ctx->input(kInputMinIndex);\n    const Tensor& input_max = ctx->input(kInputMaxIndex);\n\n    const size_t depth = input_max.NumElements();\n    OP_REQUIRES(\n        ctx, input_min.dim_size(0) == depth,\n        errors::InvalidArgument(\"input_min has incorrect size, expected \",\n                                depth, \" was \", input_min.dim_size(0)));\n    OP_REQUIRES(\n        ctx, input_max.dim_size(0) == depth,\n        errors::InvalidArgument(\"input_max has incorrect size, expected \",\n                                depth, \" was \", input_max.dim_size(0)));\n    OP_REQUIRES(\n        ctx, input_min.NumElements() == depth,\n        errors::InvalidArgument(\"input_min must have the same number of \"\n                                \"elements as input_max, got \",\n                                input_min.NumElements(), \" and \", depth));\n    OP_REQUIRES(ctx, input.NumElements() > 0,\n                errors::InvalidArgument(\"input must not be empty\"));\n    OP_REQUIRES(ctx, input.dims() == 4,\n                errors::InvalidArgument(\"input must be in NHWC format\"));\n    OP_REQUIRES(\n        ctx, input.dim_size(3) == depth,\n        errors::InvalidArgument(\n            \"input must have same number of channels as length of input_min: \",\n            input.dim_size(3), \" vs \", depth));\n\n    const float* input_min_data = input_min.flat<float>().data();\n    const float* input_max_data = input_max.flat<float>().data();\n    std::vector<float> ranges(depth);\n    bool is_non_negative = true;\n    Eigen::array<int, 2> shuffling({1, 0});\n    auto input_matrix = input.flat_inner_dims<qint32>();\n\n    // TODO: verify performance of not transposing and finding the min max\n    // directly from input_matrix vs the one presented below of transposing and\n    // using the transposed matrix as the transposing operation in itself might\n    // be more costly.\n    // Note that this operation is a calibration step for quantization and will\n    // cease to exist in the final inference graph(will exist as a const node).\n    auto transposed_input = input_matrix.shuffle(shuffling);\n\n    // Find the ranges of each channel in parallel.\n    float out_min_max = std::numeric_limits<float>::min();\n\n#ifdef ENABLE_ONEDNN_OPENMP\n#ifdef _MSC_VER\n#pragma omp parallel for\n#else\n#pragma omp parallel for reduction(max : out_min_max)\n#endif\n#endif  // ENABLE_ONEDNN_OPENMP\n    // TODO: Add eigen parallel_for\n    for (int64_t i = 0; i < depth; ++i) {\n      Eigen::Tensor<qint32, 0, Eigen::RowMajor> min =\n          transposed_input.chip<0>(i).minimum();\n      Eigen::Tensor<qint32, 0, Eigen::RowMajor> max =\n          transposed_input.chip<0>(i).maximum();\n      const int32_t min_per_channel = min();\n      const int32_t max_per_channel = max();\n      const int32_t abs_max =\n          std::max(std::abs(min_per_channel), std::abs(max_per_channel));\n      float scale =\n          std::max(std::abs(input_min_data[i]), std::abs(input_max_data[i]));\n      ranges[i] =\n          scale * static_cast<float>(abs_max) / static_cast<float>(1L << 31);\n      if (min_per_channel < 0) is_non_negative = false;\n\n      // Thread-local out_min_max.\n      out_min_max = std::max(out_min_max, ranges[i]);\n    }\n\n    // All local out_min_max gets max-reduced into one global out_min_max at\n    // the end of the loop by specifying reduction(max:out_min_max) along with\n    // omp parallel for.\n\n    // Fixing max to clip_value_max_ (example 6.0 to support relu6)\n    if (out_min_max > clip_value_max_) out_min_max = clip_value_max_;\n\n    Tensor* output_min = nullptr;\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(kOutputMinIndex, {}, &output_min));\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(kOutputMaxIndex, {}, &output_max));\n    output_min->flat<float>()(0) = is_non_negative ? 0.0f : -out_min_max;\n    output_max->flat<float>()(0) = out_min_max;\n  }",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <limits>\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/kernels/no_op.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/util/mkl_util.h\"\n#include \"tensorflow/core/kernels/meta_support.h\"\n#include \"tensorflow/core/framework/op.h\"\n#include \"tensorflow/core/framework/type_traits.h\"\n#include <math.h>\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/util/mkl_threadpool.h\"\n"
  },
  {
    "repository": "libjpeg",
    "cve_id": "CVE-2022-31796",
    "cwe_list": [
      "CWE-787"
    ],
    "commit_hash": "187035b9726710b4fe11d565c7808975c930895d",
    "short_hash": "187035b9",
    "vulnerableMethods_before": [
      {
        "filename": "hierarchicalbitmaprequester.cpp",
        "method_name": "vulnerable_function",
        "raw_code": "void HierarchicalBitmapRequester::PrepareForDecoding(void)\n{\n#if ACCUSOFT_CODE\n\n  UBYTE i;\n\n  BuildCommon();\n\n  if (m_ppDecodingMCU == NULL) {\n    m_ppDecodingMCU = (struct Line **)m_pEnviron->AllocMem(sizeof(struct Line *) * m_ucCount*8);\n    memset(m_ppDecodingMCU,0,sizeof(struct Line *) * m_ucCount * 8);\n  }\n\n  if (m_ppUpsampler == NULL) {\n    m_ppUpsampler = (class UpsamplerBase **)m_pEnviron->AllocMem(sizeof(class UpsamplerBase *) * m_ucCount);\n    memset(m_ppUpsampler,0,sizeof(class Upsampler *) * m_ucCount);\n\n    for(i = 0;i < m_ucCount;i++) {\n      class Component *comp = m_pFrame->ComponentOf(i);\n      UBYTE sx = comp->SubXOf();\n      UBYTE sy = comp->SubYOf();\n\n      if (sx > 1 || sy > 1) {\n        m_ppUpsampler[i] = UpsamplerBase::CreateUpsampler(m_pEnviron,sx,sy,\n                                                          m_ulPixelWidth,m_ulPixelHeight,\n                                                          m_pFrame->TablesOf()->isChromaCentered());\n        m_bSubsampling   = true;\n      }\n    }\n  }\n\n  if (m_pLargestScale)\n    m_pLargestScale->PrepareForDecoding();\n#endif\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "hierarchicalbitmaprequester.cpp",
        "method_name": "fixed_function",
        "raw_code": "void HierarchicalBitmapRequester::PrepareForEncoding(void)\n{\n#if ACCUSOFT_CODE\n  \n  BuildCommon();\n\n  if (m_ppEncodingMCU == NULL) {\n    m_ppEncodingMCU = (struct Line **)m_pEnviron->AllocMem(sizeof(struct Line *) * m_ucCount *8);\n    memset(m_ppEncodingMCU,0,sizeof(struct Line *) * m_ucCount * 8);\n  }\n  \n  if (m_ppDownsampler == NULL) {\n    m_ppDownsampler = (class DownsamplerBase **)m_pEnviron->AllocMem(sizeof(class DownsamplerBase *) * m_ucCount);\n    memset(m_ppDownsampler,0,sizeof(class DownsamplerBase *) * m_ucCount);\n    \n    for(UBYTE i = 0;i < m_ucCount;i++) {\n      class Component *comp = m_pFrame->ComponentOf(i);\n      UBYTE sx = comp->SubXOf();\n      UBYTE sy = comp->SubYOf();\n\n      if (sx > 1 || sy > 1) {\n        m_ppDownsampler[i] = DownsamplerBase::CreateDownsampler(m_pEnviron,sx,sy,\n                                                                m_ulPixelWidth,m_ulPixelHeight,\n                                                                m_pFrame->TablesOf()->\n                                                                isDownsamplingInterpolated());\n        m_bSubsampling     = true;\n      }\n    }\n  }\n\n  if (m_pLargestScale)\n    m_pLargestScale->PrepareForEncoding();\n#endif\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"codestream/rectanglerequest.hpp\"\n#include \"colortrafo/colortrafo.hpp\"\n#include \"marker/frame.hpp\"\n#include \"control/lineadapter.hpp\"\n#include \"control/linemerger.hpp\"\n#include \"codestream/tables.hpp\"\n#include \"control/hierarchicalbitmaprequester.hpp\"\n#include \"upsampling/downsamplerbase.hpp\"\n#include \"upsampling/upsamplerbase.hpp\"\n#include \"std/string.hpp\"\n#include \"marker/component.hpp\"\n\n// Type Definitions:\n// HierarchicalBitmapRequester:\nclass HierarchicalBitmapRequester : public BitmapCtrl {\n  //\n#if ACCUSOFT_CODE\n  class DownsamplerBase    **m_ppDownsampler;\n  //\n  // And the inverse, if required.\n  class UpsamplerBase      **m_ppUpsampler;\n  //\n  // Temporary bitmaps\n  struct ImageBitMap       **m_ppTempIBM;\n  //\n  // The tree of line adapters. This here points to the smallest scale\n  // containing the low-pass.\n  class LineAdapter         *m_pSmallestScale;\n  //\n  // The largest scale of the tree, i.e. the end where more scales are\n  // added by means of exp.\n  class LineAdapter         *m_pLargestScale;\n  //\n  // Keeps dangling pointers on construction until the merger is build\n  // which then controls the life-time.\n  class LineAdapter         *m_pTempAdapter;\n  //\n  // Line counters how many lines have been already reconstructed.\n  ULONG                     *m_pulReadyLines;\n  //\n  // Y counters, but in subsampled lines.\n  ULONG                     *m_pulY;\n  //\n  // Height of each component, in subsampled co...\n\n// Line:\nstruct Line\n\n// Frame:\nclass Frame\n\n// Tables:\nclass Tables\n\n// Tables:\nclass Tables: public JKeeper {\n  //\n  // If there is a residual image, here are the settings for it.\n  class Tables                  *m_pResidualTables;\n  //\n  // If this are the tables for the residual tables, here are the\n  // main settings.\n  class Tables                  *m_pParent;\n  //\n  // If there is an alpha channel, here are its settings.\n  class Tables                  *m_pAlphaTables;\n  //\n  // In case this is an alpha channel, here is the pointer to the\n  // to the image data.\n  class Tables                  *m_pMaster;\n  //\n  // The quantization table.\n  class Quantization            *m_pQuant;\n  //\n  // The huffman table.\n  class HuffmanTable            *m_pHuffman;\n  //\n  // The AC table.\n  class ACTable                 *m_pConditioner;\n  //\n  // The restart interval definition if there is one.\n  class RestartIntervalMarker   *m_pRestart;\n  //\n  // The adobe color marker.\n  class AdobeMarker             *m_pColorInfo;\n  //\n  // The JFIF marker.\n  class JFIFMarker    ...\n\n// Component:\nclass Component : public JKeeper {\n  //\n  // The component number from zero up.\n  UBYTE m_ucIndex;\n  //\n  // The component identifier\n  UBYTE m_ucID;\n  //\n  // The horizontal subsampling factor.\n  UBYTE m_ucMCUWidth;\n  //\n  // The vertical subsampling factor.\n  UBYTE m_ucMCUHeight;\n  //\n  // Subsampling factors in X and Y direction.\n  UBYTE m_ucSubX,m_ucSubY;\n  //\n  // The quantization table index to use for quantization.\n  UBYTE m_ucQuantTable;\n  //\n  // The bit precision of this component.\n  UBYTE m_ucPrecision;\n  //\npublic:\n  Component(class Environ *env,UBYTE idx,UBYTE prec,UBYTE subx = 1,UBYTE suby = 1);\n  //\n  ~Component(void);\n  //\n  // Parse off parts of the frame marker.\n  void ParseMarker(class ByteStream *io);\n  //\n  // Write the contents of the component to the marker.\n  void WriteMarker(class ByteStream *io);\n  //\n  // Compute the subsampling factors for this component. \n  // Requires the maximum MCU size.\n  void SetSubsampling(UBYTE maxwidth,UBYTE maxheight)\n  {\n    if...\n\n// LineAdapter:\nclass LineAdapter : public BufferCtrl {\n  //\n  // The frame this is part of.\n  class Frame   *m_pFrame;\n  //\n  // Size of the lines in allocated elements \n  ULONG         *m_pulPixelsPerLine;\n  //\n  // The linked list of lines ready for recycling.\n  struct Line  **m_ppFree;\n  //\nprotected:\n  //\n  // Number of components handled here.\n  UBYTE          m_ucCount;\n  //\n  // Create the line adapter\n  LineAdapter(class Frame *frame);\n  //\n  // Build the substructures after construction.\n  void BuildCommon(void);\n  //\n  // Create a new line for the indicated component.\n  struct Line *AllocLine(UBYTE comp);\n  //\n  // Dispose a line of the indicated component.\n  void FreeLine(struct Line *line,UBYTE comp);\n  //\npublic:\n  //\n  // Dispose it again.\n  virtual ~LineAdapter(void);\n  //\n  // Return the next smaller scale adapter if there is any, or\n  // NULL otherwise.\n  virtual class LineAdapter *LowPassOf(void) const\n  {\n    return NULL;\n  }\n  //\n  // The high-pass end if there is one, or NULL....\n\n// Frame:\nclass Frame : public JKeeper {\n  // \n  // The image of this frame\n  class Image           *m_pParent;\n  //\n  // In case this frame is part of a sequence of\n  // hierarchical frames, this is the next larger\n  // frame required to compose the full image.\n  class Frame           *m_pNext;\n  //\n  // The tables of this frame, i.e. huffman and quantization tables.\n  class Tables          *m_pTables;\n  //\n  // The scan pattern.\n  class Scan            *m_pScan;\n  //\n  // The last scan.\n  class Scan            *m_pLast;\n  //\n  // The currently active scan.\n  class Scan            *m_pCurrent;\n  //\n  // The buffer this frame.\n  class BufferCtrl      *m_pImage;\n  //\n  // Computes the residual data.\n  class ResidualBlockHelper *m_pBlockHelper;\n  //\n  // The type of the frame encoding.\n  ScanType               m_Type;\n  //\n  // width of the image in pixels.\n  ULONG                  m_ulWidth; \n  //\n  // height of the image in pixels.\n  ULONG                  m_ulHeight;\n  //\n  // Sample precisi...\n\n// UpsamplerBase:\nclass UpsamplerBase : public JKeeper {\n  //\nprotected:\n  //\n  // The width of the upsampled data in subsampled pixels.\n  ULONG               m_ulWidth;\n  //\n  // The height of the upsampled data in subsampled lines.\n  LONG                m_lTotalLines;\n  //\n  // The top Y line of the buffer we hold.\n  LONG                m_lY;\n  //\n  // The number of lines buffered here.\n  LONG                m_lHeight;\n  //\n  // Dimensions in pixels.\n  ULONG               m_ulPixelWidth;\n  ULONG               m_ulPixelHeight;\n  //\n  // Subsampling factors.\n  UBYTE               m_ucSubX;\n  //\n  UBYTE               m_ucSubY;\n  //\n  // The reconstructed data itself. This is the input buffer\n  // of the upsampling filter.\n  struct Line        *m_pInputBuffer;\n  //\n  // The actual implementations: Filter horizontally from the line into the 8x8 buffer\n  template<int>\n  static void HorizontalFilterCore(int xmod,LONG *target);\n  //\n  template<int>\n  static void VerticalFilterCore(int ymod,struct Line *top...\n\n// LineAdapter:\nclass LineAdapter\n\n// Environ:\nclass Environ\n\n// Environ:\nclass Environ {  \n  friend ExceptionStack::ExceptionStack(class Environ *env);\n  friend void ExceptionStack::Link(class Environ *env);\n  //\n  //\npublic:\n  // Maximum alignment restriction: Defines how aligned a type\n  // can get at most. This guy here is never allocated, but its\n  // size defines the maximum alignment the types must have.\n  union Align {\n    UBYTE   a_byte;\n    UWORD   a_word;\n    ULONG   a_int;\n    FLOAT   a_float;\n    DOUBLE  a_double;\n    UQUAD   a_quad;\n    APTR    a_ptr;\n  };\n  //\nprivate:\n  // \n  // The first active exception (top exception stack entry)\n  class ExceptionStack   m_First;\n  // and the root of the exception tree\n  class ExceptionRoot    m_Root;\n  //\n  // The following class is here to collect warnings rather than\n  // exceptions.\n  class ExceptionRoot    m_WarnRoot;\n  //\n  // The memory pool, manages small memory allocations.\n  class MemoryPool      *m_pPool;\n  //\n  // In case this environment is a thread-local environment,\n  // here's the root.\n...\n\n// UBYTE:\ntypedef uint8_t             UBYTE;\n\n// UpsamplerBase:\nclass UpsamplerBase\n\n// Component:\nclass Component\n\n// Upsampler:\nUpsampler.Upsampler:ANY(Environ*,ULONG,ULONG)\n\n// HierarchicalBitmapRequester:\nHierarchicalBitmapRequester.HierarchicalBitmapRequester:ANY(Frame*)\n\n// Called Methods (top 10):\n// NULL from control/control/tools/interface/types.hpp:\n\n\n// JPG_THROW from control/control/tools/environment.hpp:\n\n"
  },
  {
    "repository": "vim",
    "cve_id": "CVE-2022-0407",
    "cwe_list": [
      "CWE-787"
    ],
    "commit_hash": "44db8213d38c39877d2148eff6a72f4beccfb94e",
    "short_hash": "44db8213",
    "vulnerableMethods_before": [
      {
        "filename": "register.c",
        "method_name": "vulnerable_function",
        "raw_code": "yank_copy_line(struct block_def *bd, long y_idx, int exclude_trailing_space)\n{\n    char_u\t*pnew;\n\n    if (exclude_trailing_space)\n\tbd->endspaces = 0;\n    if ((pnew = alloc(bd->startspaces + bd->endspaces + bd->textlen + 1))\n\t\t\t\t\t\t\t\t      == NULL)\n\treturn FAIL;\n    y_current->y_array[y_idx] = pnew;\n    vim_memset(pnew, ' ', (size_t)bd->startspaces);\n    pnew += bd->startspaces;\n    mch_memmove(pnew, bd->textstart, (size_t)bd->textlen);\n    pnew += bd->textlen;\n    vim_memset(pnew, ' ', (size_t)bd->endspaces);\n    pnew += bd->endspaces;\n    if (exclude_trailing_space)\n    {\n\tint s = bd->textlen + bd->endspaces;\n\n\twhile (VIM_ISWHITE(*(bd->textstart + s - 1)) && s > 0)\n\t{\n\t    s = s - (*mb_head_off)(bd->textstart, bd->textstart + s - 1) - 1;\n\t    pnew--;\n\t}\n    }\n    *pnew = NUL;\n    return OK;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "register.c",
        "method_name": "fixed_function",
        "raw_code": "yank_copy_line(struct block_def *bd, long y_idx, int exclude_trailing_space)\n{\n    char_u\t*pnew;\n\n    if (exclude_trailing_space)\n\tbd->endspaces = 0;\n    if ((pnew = alloc(bd->startspaces + bd->endspaces + bd->textlen + 1))\n\t\t\t\t\t\t\t\t      == NULL)\n\treturn FAIL;\n    y_current->y_array[y_idx] = pnew;\n    vim_memset(pnew, ' ', (size_t)bd->startspaces);\n    pnew += bd->startspaces;\n    mch_memmove(pnew, bd->textstart, (size_t)bd->textlen);\n    pnew += bd->textlen;\n    vim_memset(pnew, ' ', (size_t)bd->endspaces);\n    pnew += bd->endspaces;\n    if (exclude_trailing_space)\n    {\n\tint s = bd->textlen + bd->endspaces;\n\n\twhile (s > 0 && VIM_ISWHITE(*(bd->textstart + s - 1)))\n\t{\n\t    s = s - (*mb_head_off)(bd->textstart, bd->textstart + s - 1) - 1;\n\t    pnew--;\n\t}\n    }\n    *pnew = NUL;\n    return OK;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"vim.h\"\n\n// Type Definitions:\n// char_u:\ntypedef unsigned char\tchar_u;\n\n// block_def:\nstruct block_def\n{\n    int\t\tstartspaces;\t// 'extra' cols before first char\n    int\t\tendspaces;\t// 'extra' cols after last char\n    int\t\ttextlen;\t// chars in block\n    char_u\t*textstart;\t// pointer to 1st char (partially) in block\n    colnr_T\ttextcol;\t// index of chars (partially) in block\n    colnr_T\tstart_vcol;\t// start col of 1st char wholly inside block\n    colnr_T\tend_vcol;\t// start col of 1st char wholly after block\n    int\t\tis_short;\t// TRUE if line is too short to fit in block\n    int\t\tis_MAX;\t\t// TRUE if curswant==MAXCOL when starting\n    int\t\tis_oneChar;\t// TRUE if block within one character\n    int\t\tpre_whitesp;\t// screen cols of ws before block\n    int\t\tpre_whitesp_c;\t// chars of ws before block\n    colnr_T\tend_char_vcols;\t// number of vcols of post-block char\n    colnr_T\tstart_char_vcols; // number of vcols of pre-block char\n}\n\n// Called Methods (top 10):\n// clear_sb_text from src/message.c:\n    void /* <=== clear_sb_text */ \nclear_sb_text(int all)\n{\n    msgchunk_T\t*mp;\n    msgchunk_T\t**lastp;\n\n    if (all)\n\tlastp = &last_msgchunk;\n    else\n    {\n\tif (last_msgchunk == NULL)\n\t    return;\n\tlastp = &last_msgchunk->sb_prev;\n    }\n\n    while (*lastp != NULL)\n    {\n\tmp = (*lastp)->sb_prev;\n\tvim_free(*lastp);\n\t*lastp = mp;\n    }\n}\n\n// VIM_ISWHITE from src/macros.h:\n#define VIM_ISWHITE(x)\t\t((x) == ' ' || (x) == '\\t') /* <=== src/macros.h:44:44:VIM_ISWHITE:1 */ \n\n// lalloc from src/alloc.c:\n    void * /* <=== lalloc */ \nlalloc(size_t size, int message)\n{\n    void\t*p;\t\t    // pointer to new storage space\n    static int\treleasing = FALSE;  // don't do mf_release_all() recursive\n    int\t\ttry_again;\n#if defined(HAVE_AVAIL_MEM)\n    static size_t allocated = 0;    // allocated since last avail check\n#endif\n\n    // Safety check for allocating zero bytes\n    if (size == 0)\n    {\n\t// Don't hide this message\n\temsg_silent = 0;\n\tiemsg(_(e_internal_error_lalloc_zero));\n\treturn NULL;\n    }\n\n#ifdef MEM_PROFILE\n    mem_pre_alloc_l(&size);\n#endif\n\n    // Loop when out of memory: Try to release some memfile blocks and\n    // if some blocks are released call malloc again.\n    for (;;)\n    {\n\t// Handle three kinds of systems:\n\t// 1. No check for available memory: Just return.\n\t// 2. Slow check for available memory: call mch_avail_mem() after\n\t//    allocating KEEP_ROOM amount of memory.\n\t// 3. Strict check for available memory: call mch_avail_mem()\n\tif ((p = malloc(size)) != NULL)\n\t{\n#ifndef HAVE_AVAIL_MEM\n\t    // 1. No check for available memory: Just return.\n\t    goto theend;\n#else\n\t    // 2. Slow check for available memory: call mch_avail_mem() after\n\t    //    allocating (KEEP_ROOM / 2) amount of memory.\n\t    allocated += size;\n\t    if (allocated < KEEP_ROOM / 2)\n\t\tgoto theend;\n\t    allocated = 0;\n\n\t    // 3. check for available memory: call mch_avail_mem()\n\t    if (mch_avail_mem(TRUE) < KEEP_ROOM_KB && !releasing)\n\t    {\n\t\tfree(p);\t// System is low... no go!\n\t\tp = NULL;\n\t    }\n\t    else\n\t\tgoto theend;\n#endif\n\t}\n\t// Remember that mf_release_all() is being called to avoid an endless\n\t// loop, because mf_release_all() may call alloc() recursively.\n\tif (releasing)\n\t    break;\n\treleasing = TRUE;\n\n\tclear_sb_text(TRUE);\t      // free any scrollback text\n\ttry_again = mf_release_all(); // release as many blocks as possible\n\n\treleasing = FALSE;\n\tif (!try_again)\n\t    break;\n    }\n\n    if (message && p == NULL)\n\tdo_outofmem_msg(size);\n\ntheend:\n#ifdef MEM_PROFILE\n    mem_post_alloc(&p, size);\n#endif\n    return p;\n}\n\n// FALSE from src/vim.h:\n# define FALSE\t0\t    // note: this is an int, not a long! /* <=== src/vim.h:1467:1467:FALSE:0 */ \n\n// alloc from src/alloc.c:\n    void * /* <=== alloc */ \nalloc(size_t size)\n{\n    return lalloc(size, TRUE);\n}\n\n// iemsg from src/message.c:\n    void /* <=== iemsg */ \niemsg(char *s)\n{\n    if (!emsg_not_now())\n    {\n\temsg_core((char_u *)s);\n#if defined(ABORT_ON_INTERNAL_ERROR) && defined(FEAT_EVAL)\n\tset_vim_var_string(VV_ERRMSG, (char_u *)s, -1);\n\tabort();\n#endif\n    }\n}\n\n// TRUE from src/vim.h:\n# define TRUE\t1 /* <=== src/vim.h:1468:1468:TRUE:0 */ \n\n// _ from src/vim.h:\n# define _(x) ((char *)(x)) /* <=== src/vim.h:569:569:_:1 */ \n\n// mf_release_all from src/memfile.c:\n    int /* <=== mf_release_all */ \nmf_release_all(void)\n{\n    buf_T\t*buf;\n    memfile_T\t*mfp;\n    bhdr_T\t*hp;\n    int\t\tretval = FALSE;\n\n    FOR_ALL_BUFFERS(buf)\n    {\n\tmfp = buf->b_ml.ml_mfp;\n\tif (mfp != NULL)\n\t{\n\t    // If no swap file yet, may open one\n\t    if (mfp->mf_fd < 0 && buf->b_may_swap)\n\t\tml_open_file(buf);\n\n\t    // only if there is a swapfile\n\t    if (mfp->mf_fd >= 0)\n\t    {\n\t\tfor (hp = mfp->mf_used_last; hp != NULL; )\n\t\t{\n\t\t    if (!(hp->bh_flags & BH_LOCKED)\n\t\t\t    && (!(hp->bh_flags & BH_DIRTY)\n\t\t\t\t|| mf_write(mfp, hp) != FAIL))\n\t\t    {\n\t\t\tmf_rem_used(mfp, hp);\n\t\t\tmf_rem_hash(mfp, hp);\n\t\t\tmf_free_bhdr(hp);\n\t\t\thp = mfp->mf_used_last;\t// re-start, list was changed\n\t\t\tretval = TRUE;\n\t\t    }\n\t\t    else\n\t\t\thp = hp->bh_prev;\n\t\t}\n\t    }\n\t}\n    }\n    return retval;\n}\n\n// do_outofmem_msg from src/alloc.c:\n    void /* <=== do_outofmem_msg */ \ndo_outofmem_msg(size_t size)\n{\n    if (!did_outofmem_msg)\n    {\n\t// Don't hide this message\n\temsg_silent = 0;\n\n\t// Must come first to avoid coming back here when printing the error\n\t// message fails, e.g. when setting v:errmsg.\n\tdid_outofmem_msg = TRUE;\n\n\tsemsg(_(e_out_of_memory_allocating_nr_bytes), (long_u)size);\n\n\tif (starting == NO_SCREEN)\n\t    // Not even finished with initializations and already out of\n\t    // memory?  Then nothing is going to work, exit.\n\t    mch_exit(123);\n    }\n}\n"
  },
  {
    "repository": "tensorflow",
    "cve_id": "CVE-2021-29552",
    "cwe_list": [
      "CWE-703"
    ],
    "commit_hash": "704866eabe03a9aeda044ec91a8d0c83fc1ebdbe",
    "short_hash": "704866ea",
    "vulnerableMethods_before": [
      {
        "filename": "unsorted_segment_join_op.cc",
        "method_name": "vulnerable_function",
        "raw_code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const TensorShape& input_shape = input.shape();\n    const int32 input_dims = input_shape.dims();\n\n    const Tensor& segment_id = context->input(1);\n    const TensorShape& segment_id_shape = segment_id.shape();\n    const int32 segment_dims = segment_id_shape.dims();\n\n    const Tensor& num_segments_tensor = context->input(2);\n    auto num_segments = num_segments_tensor.scalar<NUM_SEGMENTS_TYPE>()();\n\n    OP_REQUIRES(context, segment_dims != 0,\n                errors::InvalidArgument(\"Segment_id cannot have rank 0\"));\n\n    OP_REQUIRES(\n        context, segment_dims <= input_dims,\n        errors::OutOfRange(\"Invalid segment_id rank \", segment_dims,\n                           \" for input with \", input_dims, \" dimension(s)\"));\n    for (auto i = 0; i < segment_dims; i++) {\n      OP_REQUIRES(\n          context, segment_id_shape.dim_size(i) == input_shape.dim_size(i),\n          errors::InvalidArgument(\n              \"Segment dimension is \", segment_id_shape.dim_size(i),\n              \" while input dimension is \", input_dims, \" in rank \", i));\n    }\n\n    // Making output tensor.\n    Tensor* output_tensor = nullptr;\n    TensorShape output_shape =\n        GetOutputShape(input_shape, segment_id_shape, num_segments);\n    OP_REQUIRES_OK(context, context->allocate_output(\"output\", output_shape,\n                                                     &output_tensor));\n\n    // Preparating flat tensors.\n    auto output_flat = output_tensor->flat<tstring>();\n    auto flat_segment_id = segment_id.flat<INDICES_TYPE>();\n    auto flat_input = input.flat<tstring>();\n\n    for (int i = 0; i < flat_segment_id.size(); i++) {\n      OP_REQUIRES(\n          context,\n          ((flat_segment_id(i) < num_segments) && (flat_segment_id(i) >= 0)),\n          errors::InvalidArgument(\n              \"segment_ids are not allowed to exceed num_segments or\"\n              \" to have negative values.\"));\n    }\n\n    int64 big_stride;\n    int64 small_stride;\n    std::tie(big_stride, small_stride) =\n        GetStrides<INDICES_TYPE>(input_shape, segment_id_shape);\n    auto relative_offset_set =\n        GetFlattenedRelativeOffsets<INDICES_TYPE>(small_stride, big_stride);\n    for (auto start_offset = 0; start_offset < big_stride; start_offset++) {\n      for (auto i = 0; i < relative_offset_set.size(); i++) {\n        auto output_index = start_offset + flat_segment_id(i) * big_stride;\n        auto offset = start_offset + relative_offset_set[i];\n        if (output_flat(output_index).length() != 0)\n          output_flat(output_index).append(separator_.c_str());\n        output_flat(output_index).append(flat_input(offset));\n      }\n    }\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "unsorted_segment_join_op.cc",
        "method_name": "fixed_function",
        "raw_code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const TensorShape& input_shape = input.shape();\n    const int32 input_dims = input_shape.dims();\n\n    const Tensor& segment_id = context->input(1);\n    const TensorShape& segment_id_shape = segment_id.shape();\n    const int32 segment_dims = segment_id_shape.dims();\n\n    const Tensor& num_segments_tensor = context->input(2);\n    OP_REQUIRES(context, num_segments_tensor.NumElements() != 0,\n                errors::InvalidArgument(\"Number of segments cannot be empty.\"));\n    auto num_segments = num_segments_tensor.scalar<NUM_SEGMENTS_TYPE>()();\n\n    OP_REQUIRES(context, segment_dims != 0,\n                errors::InvalidArgument(\"Segment_id cannot have rank 0\"));\n\n    OP_REQUIRES(\n        context, segment_dims <= input_dims,\n        errors::OutOfRange(\"Invalid segment_id rank \", segment_dims,\n                           \" for input with \", input_dims, \" dimension(s)\"));\n    for (auto i = 0; i < segment_dims; i++) {\n      OP_REQUIRES(\n          context, segment_id_shape.dim_size(i) == input_shape.dim_size(i),\n          errors::InvalidArgument(\n              \"Segment dimension is \", segment_id_shape.dim_size(i),\n              \" while input dimension is \", input_dims, \" in rank \", i));\n    }\n\n    // Making output tensor.\n    Tensor* output_tensor = nullptr;\n    TensorShape output_shape =\n        GetOutputShape(input_shape, segment_id_shape, num_segments);\n    OP_REQUIRES_OK(context, context->allocate_output(\"output\", output_shape,\n                                                     &output_tensor));\n\n    // Preparating flat tensors.\n    auto output_flat = output_tensor->flat<tstring>();\n    auto flat_segment_id = segment_id.flat<INDICES_TYPE>();\n    auto flat_input = input.flat<tstring>();\n\n    for (int i = 0; i < flat_segment_id.size(); i++) {\n      OP_REQUIRES(\n          context,\n          ((flat_segment_id(i) < num_segments) && (flat_segment_id(i) >= 0)),\n          errors::InvalidArgument(\n              \"segment_ids are not allowed to exceed num_segments or\"\n              \" to have negative values.\"));\n    }\n\n    int64 big_stride;\n    int64 small_stride;\n    std::tie(big_stride, small_stride) =\n        GetStrides<INDICES_TYPE>(input_shape, segment_id_shape);\n    auto relative_offset_set =\n        GetFlattenedRelativeOffsets<INDICES_TYPE>(small_stride, big_stride);\n    for (auto start_offset = 0; start_offset < big_stride; start_offset++) {\n      for (auto i = 0; i < relative_offset_set.size(); i++) {\n        auto output_index = start_offset + flat_segment_id(i) * big_stride;\n        auto offset = start_offset + relative_offset_set[i];\n        if (output_flat(output_index).length() != 0)\n          output_flat(output_index).append(separator_.c_str());\n        output_flat(output_index).append(flat_input(offset));\n      }\n    }\n  }",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"tensorflow/core/lib/core/errors.h\"\n#include <string>\n#include \"tensorflow/core/lib/gtl/inlined_vector.h\"\n#include \"tensorflow/core/lib/strings/str_util.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/lib/core/status.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/lib/core/stringpiece.h\"\n#include \"tensorflow/core/framework/kernel_def_builder.h\"\n#include <utility>\n\n// Type Definitions:\n// Tensor:\nclass Tensor {\n public:\n  /// \\brief Creates a 1-dimensional, 0-element float tensor.\n  ///\n  /// The returned Tensor is not a scalar (shape {}), but is instead\n  /// an empty one-dimensional Tensor (shape {0}, NumElements() ==\n  /// 0). Since it has no elements, it does not need to be assigned a\n  /// value and is initialized by default (IsInitialized() is\n  /// true). If this is undesirable, consider creating a one-element\n  /// scalar which does require initialization:\n  ///\n  /// ```c++\n  ///\n  ///     Tensor(DT_FLOAT, TensorShape({}))\n  ///\n  /// ```\n  Tensor();\n\n  /// \\brief Creates a Tensor of the given `type` and `shape`.  If\n  /// LogMemory::IsEnabled() the allocation is logged as coming from\n  /// an unknown kernel and step. Calling the Tensor constructor\n  /// directly from within an Op is deprecated: use the\n  /// OpKernelConstruction/OpKernelContext allocate_* methods to\n  /// allocate a new tensor, which record the kernel and step.\n  ///\n  /// The underlying buffer is ...\n\n// OpKernelContext:\ntensorflow.OpKernelContext.OpKernelContext:ANY(tensorflow.OpKernelContext.Params*)\n\n// int32:\ntypedef int int32;\n\n// Status:\nclass Status\n\n// Tensor:\ntensorflow.TensorHandle.Tensor:tensorflow.Status(tensorflow.Tensor**)<const>\n\n// TensorShape:\nclass TensorShape : public TensorShapeBase<TensorShape> {\n public:\n  using TensorShapeBase<TensorShape>::TensorShapeBase;\n\n  /// Allow a TensorShape to be used as a PartialTensorShape without copying\n  operator const PartialTensorShape&() const;  // NOLINT(runtime/explicit)\n\n  /// Returns true if `*this` and `b` have the same sizes. Ignores\n  /// dimension names.\n  bool IsSameSize(const TensorShape& b) const;\n  bool operator==(const TensorShape& b) const { return IsSameSize(b); }\n  bool operator!=(const TensorShape& b) const { return !IsSameSize(b); }\n\n  /// Fill `*dsizes` from `*this`.\n  /// Notice: Using IndexType=int32 in combination with To32Bit() can\n  /// significantly improve performance on GPU.\n  template <int NDIMS, typename IndexType = Eigen::DenseIndex>\n  Eigen::DSizes<IndexType, NDIMS> AsEigenDSizes() const;\n\n  // Same as `AsEigenDSizes()` but returns a `Status` instead.\n  // Use this method to surface error to user instead of crashing if `NDMIS` is\n  // not equal to `di...\n\n// UnsortedSegmentJoinOp:\nclass UnsortedSegmentJoinOp : public OpKernel {\n public:\n  using OpKernel::OpKernel;\n\n  explicit UnsortedSegmentJoinOp(OpKernelConstruction* ctx) : OpKernel(ctx) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"separator\", &separator_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const TensorShape& input_shape = input.shape();\n    const int32 input_dims = input_shape.dims();\n\n    const Tensor& segment_id = context->input(1);\n    const TensorShape& segment_id_shape = segment_id.shape();\n    const int32 segment_dims = segment_id_shape.dims();\n\n    const Tensor& num_segments_tensor = context->input(2);\n    OP_REQUIRES(context, num_segments_tensor.NumElements() != 0,\n                errors::InvalidArgument(\"Number of segments cannot be empty.\"));\n    auto num_segments = num_segments_tensor.scalar<NUM_SEGMENTS_TYPE>()();\n\n    OP_REQUIRES(context, segment_dims != 0,\n                errors::InvalidArgument(\"Segment_id cannot have rank 0...\n\n// OpKernelContext:\nclass OpKernelContext {\n public:\n  // The first element of a WrappedAllocator is a \"base\" Allocator and\n  // the second element is that Allocator wrapped by a\n  // TrackingAllocator\n  typedef std::pair<Allocator*, TrackingAllocator*> WrappedAllocator;\n\n  // TODO(zhifengc): Do some cleanup of Params.\n  // The Params struct is passed in to initialize an OpKernelContext,\n  // and must outlive the OpKernelContext.\n  struct Params {\n    ~Params() { delete eigen_gpu_device; }\n\n    // The step being executed.\n    int64 step_id = 0;\n\n    // The op kernel being computed.\n    OpKernel* op_kernel = nullptr;\n\n    // The device on which the kernel is running.\n    DeviceBase* device = nullptr;\n\n    // The Eigen GPU device wrapper, which may include a per-op\n    // wrapped allocator. The concrete type of this object depends on\n    // the type of this->device, so eigen_gpu_device can't be an\n    // inline member and must be heap allocated. However, we don't\n    // want to allocate a new eigen_gpu_d...\n\n// int64:\ntypedef std::int64_t int64;\n\n// Status:\nclass Status {\n public:\n  /// Create a success status.\n  Status() {}\n\n  /// \\brief Create a status with the specified error code and msg as a\n  /// human-readable string containing more detailed information.\n  Status(tensorflow::error::Code code, tensorflow::StringPiece msg)\n      : Status(code, msg, {}) {}\n\n  /// \\brief Create a status with the specified error code, msg, and stack trace\n  /// as a human-readable string containing more detailed information.\n#ifndef SWIG\n  Status(tensorflow::error::Code code, tensorflow::StringPiece msg,\n         std::vector<StackFrame>&& stack_trace);\n#endif\n\n  /// Copy the specified status.\n  Status(const Status& s);\n  Status& operator=(const Status& s);\n#ifndef SWIG\n  Status(Status&& s) noexcept;\n  Status& operator=(Status&& s) noexcept;\n#endif  // SWIG\n\n  static Status OK() { return Status(); }\n\n  /// Returns true iff the status indicates success.\n  bool ok() const { return (state_ == nullptr); }\n\n  tensorflow::error::Code code() const {\n    retu...\n\n// Called Methods (top 10):\n// OK from tensorflow/core/platform/status.h:\n  static Status OK() { return Status(); } /* <=== tensorflow.Status.OK:tensorflow.Status() */ \n\n// OP_REQUIRES_OK from tensorflow/core/kernels/tensorflow/core/framework/tensorflow/core/framework/op_requires.h:\n\n\n// Update from tensorflow/core/platform/status.h:\n  void Update(const Status& new_status); /* <=== tensorflow.Status.Update:void(tensorflow.Status&) */ \n\n// ok from tensorflow/core/platform/status.h:\n  bool ok() const { return (state_ == nullptr); } /* <=== tensorflow.Status.ok:bool()<const> */ \n\n// CHECK from tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/platform/tensorflow/core/platform/logging.h:\n\n\n// CHECK_GE from tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/platform/tensorflow/core/platform/logging.h:\n\n\n// CHECK_EQ from tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/platform/tensorflow/core/platform/logging.h:\n\n\n// CtxFailure from tensorflow/core/framework/op_kernel.cc:\nvoid OpKernelContext::CtxFailure(const char* file, int line, const Status& s) { /* <=== tensorflow.OpKernelContext.CtxFailure:void(char*,int,tensorflow.Status&) */ \n  VLOG(1) << \"OP_REQUIRES failed at \" << io::Basename(file) << \":\" << line\n          << \" : \" << s;\n  SetStatus(s);\n}\n\n// name from tensorflow/core/framework/op_kernel.h:\n  const std::string& name() const { return props_->node_def.name(); } /* <=== tensorflow.OpKernel.name:ANY()<const> */ \n\n// OP_REQUIRES from tensorflow/core/kernels/tensorflow/core/framework/tensorflow/core/framework/op_requires.h:\n\n"
  },
  {
    "repository": "unicorn",
    "cve_id": "CVE-2022-29694",
    "cwe_list": [
      "CWE-476"
    ],
    "commit_hash": "3d3deac5e6d38602b689c4fef5dac004f07a2e63",
    "short_hash": "3d3deac5",
    "vulnerableMethods_before": [
      {
        "filename": "exec.c",
        "method_name": "vulnerable_function",
        "raw_code": "void qemu_ram_free(struct uc_struct *uc, RAMBlock *block)\n{\n    if (!block) {\n        return;\n    }\n\n    //if (block->host) {\n    //    ram_block_notify_remove(block->host, block->max_length);\n    //}\n\n    QLIST_REMOVE(block, next);\n    uc->ram_list.mru_block = NULL;\n    /* Write list before version */\n    //smp_wmb();\n    // call_rcu(block, reclaim_ramblock, rcu);\n    reclaim_ramblock(uc, block);\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "exec.c",
        "method_name": "fixed_function",
        "raw_code": "void qemu_ram_free(struct uc_struct *uc, RAMBlock *block)\n{\n    if (!block) {\n        return;\n    }\n\n    //if (block->host) {\n    //    ram_block_notify_remove(block->host, block->max_length);\n    //}\n\n    QLIST_REMOVE_RCU(block, next);\n    uc->ram_list.mru_block = NULL;\n    /* Write list before version */\n    //smp_wmb();\n    // call_rcu(block, reclaim_ramblock, rcu);\n    reclaim_ramblock(uc, block);\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"qemu/rcu_queue.h\"\n#include \"exec/ioport.h\"\n#include \"exec/exec-all.h\"\n#include \"cpu.h\"\n#include \"exec/memory.h\"\n#include \"exec/cpu-defs.h\"\n#include \"sysemu/tcg.h\"\n#include \"qemu-common.h\"\n#include \"qemu/range.h\"\n#include \"uc_priv.h\"\n#include \"exec/ram_addr.h\"\n#include \"tcg/tcg.h\"\n#include \"qemu/osdep.h\"\n#include \"exec/target_page.h\"\n#include <linux/falloc.h>\n#include \"exec/memory-internal.h\"\n#include \"qemu/timer.h\"\n#include \"memory_ldst.inc.c\"\n#include \"qemu/cutils.h\"\n#include \"sysemu/sysemu.h\"\n#include \"accel/tcg/translate-all.h\"\n\n// Type Definitions:\n// RAMBlock:\nRAMBlock\n\n// ram_addr_t:\ntypedef uintptr_t ram_addr_t;\n\n// MemoryRegion:\nstruct MemoryRegion\n\n// RAMBlock:\nstruct RAMBlock {\n    struct MemoryRegion *mr;\n    uint8_t *host;\n    ram_addr_t offset;\n    ram_addr_t used_length;\n    ram_addr_t max_length;\n    uint32_t flags;\n    /* RCU-enabled, writes protected by the ramlist lock */\n    QLIST_ENTRY(RAMBlock) next;\n    size_t page_size;\n}\n\n// uc_struct:\nstruct uc_struct\n\n// uc_struct:\nstruct uc_struct {\n    uc_arch arch;\n    uc_mode mode;\n    uc_err errnum; // qemu/cpu-exec.c\n    AddressSpace address_space_memory;\n    AddressSpace address_space_io;\n    query_t query;\n    reg_read_t reg_read;\n    reg_write_t reg_write;\n    reg_reset_t reg_reset;\n\n    uc_write_mem_t write_mem;\n    uc_read_mem_t read_mem;\n    uc_args_void_t release;  // release resource when uc_close()\n    uc_args_uc_u64_t set_pc; // set PC for tracecode\n    uc_args_int_t\n        stop_interrupt; // check if the interrupt should stop emulation\n    uc_memory_map_io_t memory_map_io;\n\n    uc_args_uc_t init_arch, cpu_exec_init_all;\n    uc_args_int_uc_t vm_start;\n    uc_args_uc_long_t tcg_exec_init;\n    uc_args_uc_ram_size_t memory_map;\n    uc_args_uc_ram_size_ptr_t memory_map_ptr;\n    uc_mem_unmap_t memory_unmap;\n    uc_readonly_mem_t readonly_mem;\n    uc_mem_redirect_t mem_redirect;\n    uc_cpus_init cpus_init;\n    uc_target_page_init target_page;\n    uc_softfloat_initialize softfloat_initialize;\n    uc_...\n\n// Called Methods (top 10):\n// g_free from glib_compat/glib_compat.c:\nvoid g_free(gpointer ptr) /* <=== g_free */ \n{\n    free(ptr);\n}\n\n// qemu_ram_munmap from qemu/util/oslib-posix.c:\nstatic void qemu_ram_munmap(struct uc_struct *uc, void *ptr, size_t size) /* <=== qemu_ram_munmap */ \n{\n    size_t pagesize;\n\n    if (ptr) {\n        /* Unmap both the RAM block and the guard page */\n#if defined(__powerpc64__) && defined(__linux__)\n        pagesize = qemu_fd_getpagesize(uc);\n#else\n        pagesize = uc->qemu_real_host_page_size;\n#endif\n        munmap(ptr, size + pagesize);\n    }\n}\n\n// QLIST_REMOVE_RCU from qemu/qemu/rcu_queue.h:\n\n\n// QLIST_INSERT_BEFORE_RCU from qemu/qemu/rcu_queue.h:\n\n\n// QLIST_INSERT_BEFORE from qemu/exec/hw/core/qemu/queue.h:\n\n\n// QLIST_INSERT_AFTER from qemu/exec/hw/core/qemu/queue.h:\n\n\n// find_ram_offset from qemu/exec.c:\nstatic ram_addr_t find_ram_offset(struct uc_struct *uc, ram_addr_t size) /* <=== find_ram_offset */ \n{\n    RAMBlock *block, *next_block;\n    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;\n\n    assert(size != 0); /* it would hand out same offset multiple times */\n\n    if (QLIST_EMPTY_RCU(&uc->ram_list.blocks)) {\n        return 0;\n    }\n\n    RAMBLOCK_FOREACH(block) {\n        ram_addr_t candidate, next = RAM_ADDR_MAX;\n\n        /* Align blocks to start on a 'long' in the bitmap\n         * which makes the bitmap sync'ing take the fast path.\n         */\n        candidate = block->offset + block->max_length;\n        candidate = ROUND_UP(candidate, BITS_PER_LONG << TARGET_PAGE_BITS);\n\n        /* Search for the closest following block\n         * and find the gap.\n         */\n        RAMBLOCK_FOREACH(next_block) {\n            if (next_block->offset >= candidate) {\n                next = MIN(next, next_block->offset);\n            }\n        }\n\n        /* If it fits remember our place and remember the size\n         * of gap, but keep going so that we might find a smaller\n         * gap to fill so avoiding fragmentation.\n         */\n        if (next - candidate >= size && next - candidate < mingap) {\n            offset = candidate;\n            mingap = next - candidate;\n        }\n    }\n\n    if (offset == RAM_ADDR_MAX) {\n        fprintf(stderr, \"Failed to find gap of requested size: %\" PRIu64 \"\\n\",\n                (uint64_t)size);\n        abort();\n    }\n\n    return offset;\n}\n\n// QLIST_INSERT_HEAD_RCU from qemu/qemu/rcu_queue.h:\n\n\n// find_ram_offset from qemu/exec.c:\nstatic ram_addr_t find_ram_offset(struct uc_struct *uc, ram_addr_t size) /* <=== find_ram_offset */ \n{\n    RAMBlock *block, *next_block;\n    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;\n\n    assert(size != 0); /* it would hand out same offset multiple times */\n\n    if (QLIST_EMPTY(&uc->ram_list.blocks)) {\n        return 0;\n    }\n\n    RAMBLOCK_FOREACH(block) {\n        ram_addr_t candidate, next = RAM_ADDR_MAX;\n\n        /* Align blocks to start on a 'long' in the bitmap\n         * which makes the bitmap sync'ing take the fast path.\n         */\n        candidate = block->offset + block->max_length;\n        candidate = ROUND_UP(candidate, BITS_PER_LONG << TARGET_PAGE_BITS);\n\n        /* Search for the closest following block\n         * and find the gap.\n         */\n        RAMBLOCK_FOREACH(next_block) {\n            if (next_block->offset >= candidate) {\n                next = MIN(next, next_block->offset);\n            }\n        }\n\n        /* If it fits remember our place and remember the size\n         * of gap, but keep going so that we might find a smaller\n         * gap to fill so avoiding fragmentation.\n         */\n        if (next - candidate >= size && next - candidate < mingap) {\n            offset = candidate;\n            mingap = next - candidate;\n        }\n    }\n\n    if (offset == RAM_ADDR_MAX) {\n        fprintf(stderr, \"Failed to find gap of requested size: %\" PRIu64 \"\\n\",\n                (uint64_t)size);\n        abort();\n    }\n\n    return offset;\n}\n\n// QLIST_REMOVE from qemu/exec/hw/core/qemu/queue.h:\n\n"
  },
  {
    "repository": "tensorflow",
    "cve_id": "CVE-2021-37687",
    "cwe_list": [
      "CWE-703"
    ],
    "commit_hash": "eb921122119a6b6e470ee98b89e65d721663179d",
    "short_hash": "eb921122",
    "vulnerableMethods_before": [
      {
        "filename": "gather.cc",
        "method_name": "vulnerable_function",
        "raw_code": "TfLiteStatus Gather(const TfLiteGatherParams& params, const TfLiteTensor* input,\n                    const TfLiteTensor* positions, TfLiteTensor* output) {\n  tflite::GatherParams op_params;\n  op_params.axis = params.axis;\n  op_params.batch_dims = params.batch_dims;\n  optimized_ops::Gather(op_params, GetTensorShape(input),\n                        GetTensorData<InputT>(input), GetTensorShape(positions),\n                        GetTensorData<PositionsT>(positions),\n                        GetTensorShape(output), GetTensorData<InputT>(output));\n  return kTfLiteOk;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "gather.cc",
        "method_name": "fixed_function",
        "raw_code": "TfLiteStatus Gather(TfLiteContext* context, const TfLiteGatherParams& params,\n                    const TfLiteTensor* input, const TfLiteTensor* positions,\n                    TfLiteTensor* output) {\n  const PositionsT* indexes = GetTensorData<PositionsT>(positions);\n  bool indices_has_only_positive_elements = true;\n  const size_t num_indices = positions->bytes / sizeof(PositionsT);\n  for (size_t i = 0; i < num_indices; i++) {\n    if (indexes[i] < 0) {\n      indices_has_only_positive_elements = false;\n      break;\n    }\n  }\n  TF_LITE_ENSURE(context, indices_has_only_positive_elements);\n\n  tflite::GatherParams op_params;\n  op_params.axis = params.axis;\n  op_params.batch_dims = params.batch_dims;\n  optimized_ops::Gather(op_params, GetTensorShape(input),\n                        GetTensorData<InputT>(input), GetTensorShape(positions),\n                        GetTensorData<PositionsT>(positions),\n                        GetTensorShape(output), GetTensorData<InputT>(output));\n  return kTfLiteOk;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"tensorflow/lite/kernels/internal/tensor.h\"\n#include <stdint.h>\n#include \"tensorflow/lite/kernels/internal/reference/reference_ops.h\"\n#include \"tensorflow/lite/kernels/internal/optimized/optimized_ops.h\"\n#include \"tensorflow/lite/c/common.h\"\n#include \"tensorflow/lite/c/builtin_op_data.h\"\n#include \"tensorflow/lite/kernels/internal/types.h\"\n#include \"tensorflow/lite/string_util.h\"\n#include \"tensorflow/lite/kernels/internal/tensor_ctypes.h\"\n#include \"tensorflow/lite/kernels/kernel_util.h\"\n\n// Type Definitions:\n// DynamicBuffer:\nclass DynamicBuffer {\n public:\n  DynamicBuffer() : offset_({0}) {}\n\n  // Add string to dynamic buffer by resizing the buffer and copying the data.\n  void AddString(const StringRef& string);\n\n  // Add string to dynamic buffer by resizing the buffer and copying the data.\n  void AddString(const char* str, size_t len);\n\n  // Join a list of string with separator, and add as a single string to the\n  // buffer.\n  void AddJoinedString(const std::vector<StringRef>& strings, char separator);\n  void AddJoinedString(const std::vector<StringRef>& strings,\n                       StringRef separator);\n\n  // Fill content into a buffer and returns the number of bytes stored.\n  // The function allocates space for the buffer but does NOT take ownership.\n  int WriteToBuffer(char** buffer);\n\n  // Fill content into a string tensor, with the given new_shape. The new shape\n  // must match the number of strings in this object. Caller relinquishes\n  // ownership of new_shape. If 'new_shape' is nullptr, keep ...\n\n// TfLiteContext:\ntypedef struct TfLiteContext {\n  // Number of tensors in the context.\n  size_t tensors_size;\n\n  // The execution plan contains a list of the node indices in execution\n  // order. execution_plan->size is the current number of nodes. And,\n  // execution_plan->data[0] is the first node that needs to be run.\n  // TfLiteDelegates can traverse the current execution plan by iterating\n  // through each member of this array and using GetNodeAndRegistration() to\n  // access details about a node. i.e.\n  //\n  // TfLiteIntArray* execution_plan;\n  // TF_LITE_ENSURE_STATUS(context->GetExecutionPlan(context, &execution_plan));\n  // for (int exec_index = 0; exec_index < execution_plan->size; exec_index++) {\n  //    int node_index = execution_plan->data[exec_index];\n  //    TfLiteNode* node;\n  //    TfLiteRegistration* reg;\n  //    context->GetNodeAndRegistration(context, node_index, &node, &reg);\n  // }\n  // Note: the memory pointed by '`*execution_plan` is OWNED by TfLite runtime.\n  // Future calls...\n\n// RuntimeShape:\nclass RuntimeShape {\n public:\n  // Shapes with dimensions up to 5 are stored directly in the structure, while\n  // larger shapes are separately allocated.\n  static constexpr int kMaxSmallSize = 5;\n\n  RuntimeShape& operator=(RuntimeShape const&) = delete;\n\n  RuntimeShape() : size_(0) {}\n\n  explicit RuntimeShape(int dimensions_count) : size_(dimensions_count) {\n    if (dimensions_count > kMaxSmallSize) {\n#ifdef TF_LITE_STATIC_MEMORY\n      TFLITE_CHECK(false && \"No shape resizing supported on this platform\");\n#else  // TF_LITE_STATIC_MEMORY\n      dims_pointer_ = new int32_t[dimensions_count];\n#endif  // TF_LITE_STATIC_MEMORY\n    }\n  }\n\n  RuntimeShape(int shape_size, int32_t value) : size_(0) {\n    Resize(shape_size);\n    for (int i = 0; i < shape_size; ++i) {\n      SetDim(i, value);\n    }\n  }\n\n  RuntimeShape(int dimensions_count, const int32_t* dims_data) : size_(0) {\n    ReplaceWith(dimensions_count, dims_data);\n  }\n\n  RuntimeShape(const std::initializer_list<int> init_list) : size_(0...\n\n// TfLiteTensor:\ntypedef struct TfLiteTensor {\n  // The data type specification for data stored in `data`. This affects\n  // what member of `data` union should be used.\n  TfLiteType type;\n  // A union of data pointers. The appropriate type should be used for a typed\n  // tensor based on `type`.\n  TfLitePtrUnion data;\n  // A pointer to a structure representing the dimensionality interpretation\n  // that the buffer should have. NOTE: the product of elements of `dims`\n  // and the element datatype size should be equal to `bytes` below.\n  TfLiteIntArray* dims;\n  // Quantization information.\n  TfLiteQuantizationParams params;\n  // How memory is mapped\n  //  kTfLiteMmapRo: Memory mapped read only.\n  //  i.e. weights\n  //  kTfLiteArenaRw: Arena allocated read write memory\n  //  (i.e. temporaries, outputs).\n  TfLiteAllocationType allocation_type;\n  // The number of bytes required to store the data of this Tensor. I.e.\n  // (bytes of each element) * dims[0] * ... * dims[n-1].  For example, if\n  // type is kT...\n\n// TfLiteNode:\ntypedef struct TfLiteNode {\n  // Inputs to this node expressed as indices into the simulator's tensors.\n  TfLiteIntArray* inputs;\n\n  // Outputs to this node expressed as indices into the simulator's tensors.\n  TfLiteIntArray* outputs;\n\n  // intermediate tensors to this node expressed as indices into the simulator's\n  // tensors.\n  TfLiteIntArray* intermediates;\n\n  // Temporary tensors uses during the computations. This usually contains no\n  // tensors, but ops are allowed to change that if they need scratch space of\n  // any sort.\n  TfLiteIntArray* temporaries;\n\n  // Opaque data provided by the node implementer through `Registration.init`.\n  void* user_data;\n\n  // Opaque data provided to the node if the node is a builtin. This is usually\n  // a structure defined in builtin_op_data.h\n  void* builtin_data;\n\n  // Custom initial data. This is the opaque data provided in the flatbuffer.\n  // WARNING: This is an experimental interface that is subject to change.\n  const void* custom_initia...\n\n// GatherParams:\nstruct GatherParams {\n  int16_t axis;\n  int16_t batch_dims;\n}\n"
  },
  {
    "repository": "gpac",
    "cve_id": "CVE-2021-40571",
    "cwe_list": [
      "CWE-415"
    ],
    "commit_hash": "a69b567b8c95c72f9560c873c5ab348be058f340",
    "short_hash": "a69b567b",
    "vulnerableMethods_before": [
      {
        "filename": "descriptors.c",
        "method_name": "vulnerable_function",
        "raw_code": "GF_AV1Config *gf_odf_av1_cfg_read_bs_size(GF_BitStream *bs, u32 size)\n{\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tAV1State state;\n\tu8 reserved;\n\tGF_AV1Config *cfg;\n\n\tif (!size) size = (u32) gf_bs_available(bs);\n\tif (!size) return NULL;\n\n\tcfg = gf_odf_av1_cfg_new();\n\tgf_av1_init_state(&state);\n\tstate.config = cfg;\n\n\tcfg->marker = gf_bs_read_int(bs, 1);\n\tcfg->version = gf_bs_read_int(bs, 7);\n\tcfg->seq_profile = gf_bs_read_int(bs, 3);\n\tcfg->seq_level_idx_0 = gf_bs_read_int(bs, 5);\n\tcfg->seq_tier_0 = gf_bs_read_int(bs, 1);\n\tcfg->high_bitdepth = gf_bs_read_int(bs, 1);\n\tcfg->twelve_bit = gf_bs_read_int(bs, 1);\n\tcfg->monochrome = gf_bs_read_int(bs, 1);\n\tcfg->chroma_subsampling_x = gf_bs_read_int(bs, 1);\n\tcfg->chroma_subsampling_y = gf_bs_read_int(bs, 1);\n\tcfg->chroma_sample_position = gf_bs_read_int(bs, 2);\n\n\treserved = gf_bs_read_int(bs, 3);\n\tif (reserved != 0 || cfg->marker != 1 || cfg->version != 1) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1] wrong avcC reserved %d / marker %d / version %d expecting 0 1 1\\n\", reserved, cfg->marker, cfg->version));\n\t\tgf_odf_av1_cfg_del(cfg);\n\t\treturn NULL;\n\t}\n\tcfg->initial_presentation_delay_present = gf_bs_read_int(bs, 1);\n\tif (cfg->initial_presentation_delay_present) {\n\t\tcfg->initial_presentation_delay_minus_one = gf_bs_read_int(bs, 4);\n\t} else {\n\t\t/*reserved = */gf_bs_read_int(bs, 4);\n\t\tcfg->initial_presentation_delay_minus_one = 0;\n\t}\n\tsize -= 4;\n\n\twhile (size) {\n\t\tu64 pos, obu_size;\n\t\tObuType obu_type;\n\t\tGF_AV1_OBUArrayEntry *a;\n\n\t\tpos = gf_bs_get_position(bs);\n\t\tobu_size = 0;\n\t\tif (gf_av1_parse_obu(bs, &obu_type, &obu_size, NULL, &state) != GF_OK) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[AV1] could not parse AV1 OBU at position \"LLU\". Leaving parsing.\\n\", pos));\n\t\t\tbreak;\n\t\t}\n\t\tassert(obu_size == gf_bs_get_position(bs) - pos);\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1] parsed AV1 OBU type=%u size=\"LLU\" at position \"LLU\".\\n\", obu_type, obu_size, pos));\n\n\t\tif (!av1_is_obu_header(obu_type)) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1] AV1 unexpected OBU type=%u size=\"LLU\" found at position \"LLU\". Forwarding.\\n\", pos));\n\t\t}\n\t\tGF_SAFEALLOC(a, GF_AV1_OBUArrayEntry);\n\t\tif (!a) break;\n\t\ta->obu = gf_malloc((size_t)obu_size);\n\t\tif (!a->obu) {\n\t\t\tgf_free(a);\n\t\t\tbreak;\n\t\t}\n\t\tgf_bs_seek(bs, pos);\n\t\tgf_bs_read_data(bs, (char *) a->obu, (u32)obu_size);\n\t\ta->obu_length = obu_size;\n\t\ta->obu_type = obu_type;\n\t\tgf_list_add(cfg->obu_array, a);\n\n\t\tif (size<obu_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[AV1] AV1 config misses %d bytes to fit the entire OBU\\n\", obu_size - size));\n\t\t\tbreak;\n\t\t}\n\t\tsize -= (u32) obu_size;\n\t}\n\tgf_av1_reset_state(& state, GF_TRUE);\n\treturn cfg;\n#else\n\treturn NULL;\n#endif\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "descriptors.c",
        "method_name": "fixed_function",
        "raw_code": "GF_AV1Config *gf_odf_av1_cfg_read_bs_size(GF_BitStream *bs, u32 size)\n{\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tAV1State state;\n\tu8 reserved;\n\tGF_AV1Config *cfg;\n\n\tif (!size) size = (u32) gf_bs_available(bs);\n\tif (!size) return NULL;\n\n\tcfg = gf_odf_av1_cfg_new();\n\tgf_av1_init_state(&state);\n\tstate.config = cfg;\n\n\tcfg->marker = gf_bs_read_int(bs, 1);\n\tcfg->version = gf_bs_read_int(bs, 7);\n\tcfg->seq_profile = gf_bs_read_int(bs, 3);\n\tcfg->seq_level_idx_0 = gf_bs_read_int(bs, 5);\n\tcfg->seq_tier_0 = gf_bs_read_int(bs, 1);\n\tcfg->high_bitdepth = gf_bs_read_int(bs, 1);\n\tcfg->twelve_bit = gf_bs_read_int(bs, 1);\n\tcfg->monochrome = gf_bs_read_int(bs, 1);\n\tcfg->chroma_subsampling_x = gf_bs_read_int(bs, 1);\n\tcfg->chroma_subsampling_y = gf_bs_read_int(bs, 1);\n\tcfg->chroma_sample_position = gf_bs_read_int(bs, 2);\n\n\treserved = gf_bs_read_int(bs, 3);\n\tif (reserved != 0 || cfg->marker != 1 || cfg->version != 1) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1] wrong avcC reserved %d / marker %d / version %d expecting 0 1 1\\n\", reserved, cfg->marker, cfg->version));\n\t\tgf_odf_av1_cfg_del(cfg);\n\t\treturn NULL;\n\t}\n\tcfg->initial_presentation_delay_present = gf_bs_read_int(bs, 1);\n\tif (cfg->initial_presentation_delay_present) {\n\t\tcfg->initial_presentation_delay_minus_one = gf_bs_read_int(bs, 4);\n\t} else {\n\t\t/*reserved = */gf_bs_read_int(bs, 4);\n\t\tcfg->initial_presentation_delay_minus_one = 0;\n\t}\n\tsize -= 4;\n\n\twhile (size) {\n\t\tu64 pos, obu_size;\n\t\tObuType obu_type;\n\t\tGF_AV1_OBUArrayEntry *a;\n\n\t\tpos = gf_bs_get_position(bs);\n\t\tobu_size = 0;\n\t\tif (gf_av1_parse_obu(bs, &obu_type, &obu_size, NULL, &state) != GF_OK) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[AV1] could not parse AV1 OBU at position \"LLU\". Leaving parsing.\\n\", pos));\n\t\t\tbreak;\n\t\t}\n\t\tassert(obu_size == gf_bs_get_position(bs) - pos);\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1] parsed AV1 OBU type=%u size=\"LLU\" at position \"LLU\".\\n\", obu_type, obu_size, pos));\n\n\t\tif (!av1_is_obu_header(obu_type)) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1] AV1 unexpected OBU type=%u size=\"LLU\" found at position \"LLU\". Forwarding.\\n\", pos));\n\t\t}\n\t\tGF_SAFEALLOC(a, GF_AV1_OBUArrayEntry);\n\t\tif (!a) break;\n\t\ta->obu = gf_malloc((size_t)obu_size);\n\t\tif (!a->obu) {\n\t\t\tgf_free(a);\n\t\t\tbreak;\n\t\t}\n\t\tgf_bs_seek(bs, pos);\n\t\tgf_bs_read_data(bs, (char *) a->obu, (u32)obu_size);\n\t\ta->obu_length = obu_size;\n\t\ta->obu_type = obu_type;\n\t\tgf_list_add(cfg->obu_array, a);\n\n\t\tif (size<obu_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[AV1] AV1 config misses %d bytes to fit the entire OBU\\n\", obu_size - size));\n\t\t\tbreak;\n\t\t}\n\t\tsize -= (u32) obu_size;\n\t}\n\tgf_av1_reset_state(& state, GF_TRUE);\n\tgf_bs_align(bs);\n\treturn cfg;\n#else\n\treturn NULL;\n#endif\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/avparse.h>\n#include <gpac/internal/media_dev.h>\n#include <gpac/internal/odf_dev.h>\n#include <gpac/constants.h>\n\n// Type Definitions:\n// AV1State:\ntypedef struct\n{\n\t/*importing options*/\n\tBool keep_temporal_delim;\n\t/*parser config*/\n\t//if set only header frames are stored\n\tBool skip_frames;\n\t//if set, frame OBUs are not pushed to the frame_obus OBU list but are written in the below bitstream\n\tBool mem_mode;\n\t/*bitstream object for mem mode - this bitstream is NOT destroyed by gf_av1_reset_state(state, GF_TRUE) */\n\tGF_BitStream *bs;\n\tBool bs_overread, unframed;\n\tu8 *frame_obus;\n\tu32 frame_obus_alloc;\n\n\t/*general sequence information*/\n\tBool frame_id_numbers_present_flag;\n\tBool reduced_still_picture_header;\n\tBool decoder_model_info_present_flag;\n\tu16 OperatingPointIdc;\n\tu32 width, height, UpscaledWidth;\n\tu32 sequence_width, sequence_height;\n\tu32 tb_num, tb_den;\n\n\tBool use_128x128_superblock;\n\tu8 frame_width_bits_minus_1, frame_height_bits_minus_1;\n\tu8 equal_picture_interval;\n\tu8 delta_frame_id_length_minus_2;\n\tu8 additional_frame_id_length_minus_1;\n\tu8 seq_force_integer_mv;\n\tu8 seq_force_screen_content_tools;\n\tBool enable_superr...\n\n// GF_AV1Config:\ntypedef struct\n{\n\tBool marker;\n\tu8 version; /*7 bits*/\n\tu8 seq_profile; /*3 bits*/\n\tu8 seq_level_idx_0; /*5 bits*/\n\tBool seq_tier_0;\n\tBool high_bitdepth;\n\tBool twelve_bit;\n\tBool monochrome;\n\tBool chroma_subsampling_x;\n\tBool chroma_subsampling_y;\n\tu8 chroma_sample_position; /*2 bits*/\n\n\tBool initial_presentation_delay_present;\n\tu8 initial_presentation_delay_minus_one; /*4 bits*/\n\tGF_List *obu_array; /*GF_AV1_OBUArrayEntry*/\n}\n\n// GF_AV1_OBUArrayEntry:\ntypedef struct\n{\n\tu64 obu_length;\n\tint obu_type; /*ObuType*/\n\tu8 *obu;\n}\n\n// u32:\ntypedef unsigned int u32;\n\n// GF_BitStream:\ntypedef struct __tag_bitstream GF_BitStream;\n\n// u64:\ntypedef unsigned int u64;\n\n// ObuType:\ntypedef enum {\n\tOBU_RESERVED_0 = 0,\n\tOBU_SEQUENCE_HEADER = 1,\n\tOBU_TEMPORAL_DELIMITER = 2,\n\tOBU_FRAME_HEADER = 3,\n\tOBU_TILE_GROUP = 4,\n\tOBU_METADATA = 5,\n\tOBU_FRAME = 6,\n\tOBU_REDUNDANT_FRAME_HEADER = 7,\n\tOBU_TILE_LIST = 8,\n\tOBU_RESERVED_9 = 9,\n\tOBU_RESERVED_10 = 10,\n\tOBU_RESERVED_11 = 11,\n\tOBU_RESERVED_12 = 12,\n\tOBU_RESERVED_13 = 13,\n\tOBU_RESERVED_14 = 14,\n\tOBU_PADDING = 15,\n}\n\n// u8:\ntypedef unsigned char u8;\n\n// Called Methods (top 10):\n// gf_ftell from src/utils/os_file.c:\nu64 gf_ftell(FILE *fp) /* <=== gf_ftell */ \n{\n\tif (!fp) return -1;\n\n\tif (gf_fileio_check(fp)) {\n\t\tGF_FileIO *gfio = (GF_FileIO *)fp;\n\t\tif (!gfio->tell) return -1;\n\t\treturn gfio->tell(gfio);\n\t}\n\n#if defined(_WIN32_WCE)\n\treturn (u64) ftell(fp);\n#elif defined(GPAC_CONFIG_WIN32) && (defined(__CYGWIN__) || defined(__MINGW32__))\n#if (_FILE_OFFSET_BITS >= 64)\n\treturn (u64) ftello64(fp);\n#else\n\treturn (u64) ftell(fp);\n#endif\n#elif defined(WIN32)\n\treturn (u64) _ftelli64(fp);\n#elif defined(GPAC_CONFIG_LINUX) && !defined(GPAC_CONFIG_ANDROID)\n\treturn (u64) ftello64(fp);\n#elif (defined(GPAC_CONFIG_FREEBSD) || defined(GPAC_CONFIG_DARWIN))\n\treturn (u64) ftello(fp);\n#else\n\treturn (u64) ftell(fp);\n#endif\n}\n\n// gf_bs_set_eos_callback from src/utils/bitstream.c:\nvoid gf_bs_set_eos_callback(GF_BitStream *bs, void (*EndOfStream)(void *par), void *par) /* <=== gf_bs_set_eos_callback */ \n{\n\tbs->EndOfStream = EndOfStream;\n\tbs->par = par;\n}\n\n// gf_bs_get_position from src/utils/bitstream.c:\nu64 gf_bs_get_position(GF_BitStream *bs) /* <=== gf_bs_get_position */ \n{\n\tif (bs->cache_write)\n\t\treturn bs->position + bs->buffer_written;\n\treturn bs->position;\n}\n\n// gf_bs_available from src/utils/bitstream.c:\nu64 gf_bs_available(GF_BitStream *bs) /* <=== gf_bs_available */ \n{\n\ts64 cur, end;\n\n\t/*in WRITE mode only, this should not be called, but return something big in case ...*/\n\tif ( (bs->bsmode == GF_BITSTREAM_WRITE)\n\t        || (bs->bsmode == GF_BITSTREAM_WRITE_DYN)\n\t   )\n\t\treturn (u64) -1;\n\n\t/*we are in MEM mode*/\n\tif (bs->bsmode == GF_BITSTREAM_READ) {\n\t\tif (bs->size < bs->position)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn (bs->size - bs->position);\n\t}\n\t/*FILE READ: assume size hasn't changed, otherwise the user shall call gf_bs_get_refreshed_size*/\n\tif (bs->bsmode==GF_BITSTREAM_FILE_READ) {\n\t\tif (bs->position>bs->size) return 0;\n\t\treturn (bs->size - bs->position);\n\t}\n\tif (bs->cache_write)\n\t\tbs_flush_write_cache(bs);\n\n\tcur = gf_ftell(bs->stream);\n\tend = gf_fsize(bs->stream);\n\tgf_fseek(bs->stream, cur, SEEK_SET);\n\n\treturn (u64) (end - cur);\n}\n\n// gf_av1_parse_obu_header from src/media_tools/av_parsers.c:\nGF_Err gf_av1_parse_obu_header(GF_BitStream *bs, ObuType *obu_type, Bool *obu_extension_flag, Bool *obu_has_size_field, u8 *temporal_id, u8 *spatial_id) /* <=== gf_av1_parse_obu_header */ \n{\n\tBool forbidden = gf_bs_read_int(bs, 1);\n\tif (forbidden) {\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\t*obu_type = gf_bs_read_int(bs, 4);\n\t*obu_extension_flag = gf_bs_read_int(bs, 1);\n\t*obu_has_size_field = gf_bs_read_int(bs, 1);\n\tif (gf_bs_read_int(bs, 1) /*obu_reserved_1bit*/) {\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tif (*obu_extension_flag) {\n\t\t*temporal_id = gf_bs_read_int(bs, 3);\n\t\t*spatial_id = gf_bs_read_int(bs, 2);\n\t\t/*extension_header_reserved_3bits = */gf_bs_read_int(bs, 3);\n\t}\n\n\treturn GF_OK;\n}\n\n// timing_info from src/media_tools/av_parsers.c:\nstatic void timing_info(GF_BitStream *bs, AV1State *state) { /* <=== timing_info */ \n\tu32 time_scale = 0;\n\tu32 num_units_in_display_tick = gf_bs_read_int_log(bs, 32, \"num_units_in_display_tick\");\n\tif (num_units_in_display_tick == 0) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[AV1] num_units_in_display_tick must be greater than 0.\\n\"));\n\t}\n\ttime_scale = gf_bs_read_int_log(bs, 32, \"time_scale\");\n\tif (time_scale == 0) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[AV1] time_scale must be greater than 0.\\n\"));\n\t}\n\tstate->equal_picture_interval = gf_bs_read_int_log(bs, 1, \"equal_picture_interval\");\n\tif (state->equal_picture_interval) {\n\t\tu32 num_ticks_per_picture_minus_1 = av1_uvlc(bs, \"num_ticks_per_picture_minus_1\");\n\t\tstate->tb_num = time_scale;\n\t\tstate->tb_den = (num_ticks_per_picture_minus_1 + 1)*num_units_in_display_tick;\n\t}\n\telse {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[AV1] VFR not supported.\\n\"));\n\t\t//TODO: upload num_units_in_display_tick (eq. to the POC in H264), compute delta between frames, set it as dts_inc in gf_import_aom_av1()\n\t}\n}\n\n// av1_color_config from src/media_tools/av_parsers.c:\nstatic void av1_color_config(GF_BitStream *bs, AV1State *state) /* <=== av1_color_config */ \n{\n\tstate->config->high_bitdepth = gf_bs_read_int_log(bs, 1, \"high_bitdepth\");\n\tstate->bit_depth = 8;\n\tif (state->config->seq_profile == 2 && state->config->high_bitdepth) {\n\t\tstate->config->twelve_bit = gf_bs_read_int_log(bs, 1, \"twelve_bit\");\n\t\tstate->bit_depth = state->config->twelve_bit ? 12 : 10;\n\t}\n\telse if (state->config->seq_profile <= 2) {\n\t\tstate->bit_depth = state->config->high_bitdepth ? 10 : 8;\n\t}\n\n\tstate->config->monochrome = GF_FALSE;\n\tif (state->config->seq_profile == 1) {\n\t\tstate->config->monochrome = GF_FALSE;\n\t}\n\telse {\n\t\tstate->config->monochrome = gf_bs_read_int_log(bs, 1, \"monochrome\");\n\t}\n\t/*NumPlanes = mono_chrome ? 1 : 3;*/\n\tstate->color_description_present_flag = gf_bs_read_int_log(bs, 1, \"color_description_present_flag\");\n\tif (state->color_description_present_flag) {\n\t\tstate->color_primaries = gf_bs_read_int_log(bs, 8, \"color_primaries\");\n\t\tstate->transfer_characteristics = gf_bs_read_int_log(bs, 8, \"transfer_characteristics\");\n\t\tstate->matrix_coefficients = gf_bs_read_int_log(bs, 8, \"matrix_coefficients\");\n\t}\n\telse {\n\t\tstate->color_primaries = 2/*CP_UNSPECIFIED*/;\n\t\tstate->transfer_characteristics = 2/*TC_UNSPECIFIED*/;\n\t\tstate->matrix_coefficients = 2/*MC_UNSPECIFIED*/;\n\t}\n\tif (state->config->monochrome) {\n\t\tstate->color_range = gf_bs_read_int_log(bs, 1, \"color_range\");\n\t\tstate->config->chroma_subsampling_x = GF_TRUE;\n\t\tstate->config->chroma_subsampling_y = GF_TRUE;\n\t\tstate->config->chroma_sample_position = 0/*CSP_UNKNOWN*/;\n\t\tstate->separate_uv_delta_q = 0;\n\t\treturn;\n\t}\n\telse if (state->color_primaries == 0/*CP_BT_709*/ &&\n\t\tstate->transfer_characteristics == 13/*TC_SRGB*/ &&\n\t\tstate->matrix_coefficients == 0/*MC_IDENTITY*/) {\n\t\tstate->color_range = GF_TRUE;\n\t\tstate->config->chroma_subsampling_x = GF_FALSE;\n\t\tstate->config->chroma_subsampling_y = GF_FALSE;\n\t}\n\telse {\n\t\tstate->config->chroma_subsampling_x = GF_FALSE;\n\t\tstate->config->chroma_subsampling_y = GF_FALSE;\n\n\t\tstate->color_range = gf_bs_read_int_log(bs, 1, \"color_range\");\n\t\tif (state->config->seq_profile == 0) {\n\t\t\tstate->config->chroma_subsampling_x = GF_TRUE;\n\t\t\tstate->config->chroma_subsampling_y = GF_TRUE;\n\t\t}\n\t\telse if (state->config->seq_profile == 1) {\n\t\t\tstate->config->chroma_subsampling_x = GF_FALSE;\n\t\t\tstate->config->chroma_subsampling_y = GF_FALSE;\n\t\t}\n\t\telse {\n\t\t\tif (state->bit_depth == 12) {\n\t\t\t\tstate->config->chroma_subsampling_x = gf_bs_read_int_log(bs, 1, \"chroma_subsampling_x\");\n\t\t\t\tif (state->config->chroma_subsampling_x)\n\t\t\t\t\tstate->config->chroma_subsampling_y = gf_bs_read_int_log(bs, 1, \"chroma_subsampling_y\");\n\t\t\t\telse\n\t\t\t\t\tstate->config->chroma_subsampling_y = GF_FALSE;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstate->config->chroma_subsampling_x = GF_TRUE;\n\t\t\t\tstate->config->chroma_subsampling_y = GF_FALSE;\n\t\t\t}\n\t\t}\n\t\tif (state->config->chroma_subsampling_x && state->config->chroma_subsampling_y) {\n\t\t\tstate->config->chroma_sample_position = gf_bs_read_int_log(bs, 2, \"chroma_sample_position\");\n\t\t}\n\t}\n\tstate->separate_uv_delta_q = gf_bs_read_int_log(bs, 1, \"separate_uv_delta_q\");\n}\n\n// bs_flush_write_cache from src/utils/bitstream.c:\nstatic void bs_flush_write_cache(GF_BitStream *bs) /* <=== bs_flush_write_cache */ \n{\n\tif (bs->buffer_written) {\n\t\tu32 nb_write;\n\t\tnb_write = (u32) gf_fwrite(bs->cache_write, bs->buffer_written, bs->stream);\n\n\t\t//check we didn't rewind the bitstream\n\t\tif (bs->size == bs->position)\n\t\t\tbs->size += nb_write;\n\t\tbs->position += nb_write;\n\t\tbs->buffer_written = 0;\n\t}\n}\n\n// BS_SeekIntern from src/utils/bitstream.c:\nstatic GF_Err BS_SeekIntern(GF_BitStream *bs, u64 offset) /* <=== BS_SeekIntern */ \n{\n\tu32 i;\n\t/*if mem, do it */\n\tif ((bs->bsmode == GF_BITSTREAM_READ) || (bs->bsmode == GF_BITSTREAM_WRITE) || (bs->bsmode == GF_BITSTREAM_WRITE_DYN)) {\n\t\tif (offset > 0xFFFFFFFF) return GF_IO_ERR;\n\t\tif (!bs->original) return GF_BAD_PARAM;\n\t\t/*0 for write, read will be done automatically*/\n\t\tif (offset >= bs->size) {\n\t\t\tif ( (bs->bsmode == GF_BITSTREAM_READ) || (bs->bsmode == GF_BITSTREAM_WRITE) ) {\n\t\t\t\tif (offset > bs->size) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CORE, (\"[BS] Attempt to seek to %d after end of bitstream %d, assuming seek to end\\n\", offset, bs->size));\n\t\t\t\t}\n\t\t\t\tbs->position = bs->size;\n\t\t\t\tbs->nbBits = (bs->bsmode == GF_BITSTREAM_READ) ? 8 : 0;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\t/*in DYN, gf_realloc ...*/\n\t\t\tbs->original = (char*)gf_realloc(bs->original, (u32) (offset + 1));\n\t\t\tif (!bs->original)\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\tfor (i = 0; i < (u32) (offset + 1 - bs->size); i++) {\n\t\t\t\tbs->original[bs->size + i] = 0;\n\t\t\t}\n\t\t\tbs->size = offset + 1;\n\t\t}\n\t\tbs->current = bs->original[offset];\n\t\tbs->position = offset;\n\t\tbs->nbBits = (bs->bsmode == GF_BITSTREAM_READ) ? 8 : 0;\n\t\treturn GF_OK;\n\t}\n\n\tif (bs->cache_write)\n\t\tbs_flush_write_cache(bs);\n\n\tif (bs->cache_read) {\n\t\tbs->cache_read_pos = bs->cache_read_size;\n\t}\n\n\tgf_fseek(bs->stream, offset, SEEK_SET);\n\n\tbs->position = offset;\n\tbs->current = 0;\n\t/*setup NbBits so that next acccess to the buffer will trigger read/write*/\n\tbs->nbBits = (bs->bsmode == GF_BITSTREAM_FILE_READ) ? 8 : 0;\n\treturn GF_OK;\n}\n\n// bs_handle_nbits_overflow from src/utils/bitstream.c:\nstatic s32 bs_handle_nbits_overflow(GF_BitStream* bs, s32 nBits, s32 max_shift) /* <=== bs_handle_nbits_overflow */ \n{\n\tif (nBits > max_shift) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[BS] Attempt to write %d bits, when max is %d\\n\", nBits, max_shift));\n\t}\n\twhile (nBits > max_shift) {\n\t\tgf_bs_write_long_int(bs, 0, max_shift);\n\t\tnBits -= max_shift;\n\t}\n\n\treturn nBits;\n}\n"
  },
  {
    "repository": "vim",
    "cve_id": "CVE-2022-3134",
    "cwe_list": [
      "CWE-416"
    ],
    "commit_hash": "ccfde4d028e891a41e3548323c3d47b06fb0b83e",
    "short_hash": "ccfde4d0",
    "vulnerableMethods_before": [
      {
        "filename": "tag.c",
        "method_name": "vulnerable_function",
        "raw_code": "do_tag(\n    char_u\t*tag,\t\t// tag (pattern) to jump to\n    int\t\ttype,\n    int\t\tcount,\n    int\t\tforceit,\t// :ta with !\n    int\t\tverbose)\t// print \"tag not found\" message\n{\n    taggy_T\t*tagstack = curwin->w_tagstack;\n    int\t\ttagstackidx = curwin->w_tagstackidx;\n    int\t\ttagstacklen = curwin->w_tagstacklen;\n    int\t\tcur_match = 0;\n    int\t\tcur_fnum = curbuf->b_fnum;\n    int\t\toldtagstackidx = tagstackidx;\n    int\t\tprevtagstackidx = tagstackidx;\n    int\t\tprev_num_matches;\n    int\t\tnew_tag = FALSE;\n    int\t\ti;\n    int\t\tic;\n    int\t\tno_regexp = FALSE;\n    int\t\terror_cur_match = 0;\n    int\t\tsave_pos = FALSE;\n    fmark_T\tsaved_fmark;\n#ifdef FEAT_CSCOPE\n    int\t\tjumped_to_tag = FALSE;\n#endif\n    int\t\tnew_num_matches;\n    char_u\t**new_matches;\n    int\t\tuse_tagstack;\n    int\t\tskip_msg = FALSE;\n    char_u\t*buf_ffname = curbuf->b_ffname;\t    // name to use for\n\t\t\t\t\t\t    // priority computation\n    int\t\tuse_tfu = 1;\n    char_u\t*tofree = NULL;\n\n    // remember the matches for the last used tag\n    static int\t\tnum_matches = 0;\n    static int\t\tmax_num_matches = 0;  // limit used for match search\n    static char_u\t**matches = NULL;\n    static int\t\tflags;\n\n#ifdef FEAT_EVAL\n    if (tfu_in_use)\n    {\n\temsg(_(e_cannot_modify_tag_stack_within_tagfunc));\n\treturn FALSE;\n    }\n#endif\n\n#ifdef EXITFREE\n    if (type == DT_FREE)\n    {\n\t// remove the list of matches\n\tFreeWild(num_matches, matches);\n# ifdef FEAT_CSCOPE\n\tcs_free_tags();\n# endif\n\tnum_matches = 0;\n\treturn FALSE;\n    }\n#endif\n\n    if (type == DT_HELP)\n    {\n\ttype = DT_TAG;\n\tno_regexp = TRUE;\n\tuse_tfu = 0;\n    }\n\n    prev_num_matches = num_matches;\n    free_string_option(nofile_fname);\n    nofile_fname = NULL;\n\n    CLEAR_POS(&saved_fmark.mark);\t// shutup gcc 4.0\n    saved_fmark.fnum = 0;\n\n    /*\n     * Don't add a tag to the tagstack if 'tagstack' has been reset.\n     */\n    if ((!p_tgst && *tag != NUL))\n    {\n\tuse_tagstack = FALSE;\n\tnew_tag = TRUE;\n#if defined(FEAT_QUICKFIX)\n\tif (g_do_tagpreview != 0)\n\t{\n\t    tagstack_clear_entry(&ptag_entry);\n\t    if ((ptag_entry.tagname = vim_strsave(tag)) == NULL)\n\t\tgoto end_do_tag;\n\t}\n#endif\n    }\n    else\n    {\n#if defined(FEAT_QUICKFIX)\n\tif (g_do_tagpreview != 0)\n\t    use_tagstack = FALSE;\n\telse\n#endif\n\t    use_tagstack = TRUE;\n\n\t// new pattern, add to the tag stack\n\tif (*tag != NUL\n\t\t&& (type == DT_TAG || type == DT_SELECT || type == DT_JUMP\n#ifdef FEAT_QUICKFIX\n\t\t    || type == DT_LTAG\n#endif\n#ifdef FEAT_CSCOPE\n\t\t    || type == DT_CSCOPE\n#endif\n\t\t    ))\n\t{\n#if defined(FEAT_QUICKFIX)\n\t    if (g_do_tagpreview != 0)\n\t    {\n\t\tif (ptag_entry.tagname != NULL\n\t\t\t&& STRCMP(ptag_entry.tagname, tag) == 0)\n\t\t{\n\t\t    // Jumping to same tag: keep the current match, so that\n\t\t    // the CursorHold autocommand example works.\n\t\t    cur_match = ptag_entry.cur_match;\n\t\t    cur_fnum = ptag_entry.cur_fnum;\n\t\t}\n\t\telse\n\t\t{\n\t\t    tagstack_clear_entry(&ptag_entry);\n\t\t    if ((ptag_entry.tagname = vim_strsave(tag)) == NULL)\n\t\t\tgoto end_do_tag;\n\t\t}\n\t    }\n\t    else\n#endif\n\t    {\n\t\t/*\n\t\t * If the last used entry is not at the top, delete all tag\n\t\t * stack entries above it.\n\t\t */\n\t\twhile (tagstackidx < tagstacklen)\n\t\t    tagstack_clear_entry(&tagstack[--tagstacklen]);\n\n\t\t// if the tagstack is full: remove oldest entry\n\t\tif (++tagstacklen > TAGSTACKSIZE)\n\t\t{\n\t\t    tagstacklen = TAGSTACKSIZE;\n\t\t    tagstack_clear_entry(&tagstack[0]);\n\t\t    for (i = 1; i < tagstacklen; ++i)\n\t\t\ttagstack[i - 1] = tagstack[i];\n\t\t    --tagstackidx;\n\t\t}\n\n\t\t/*\n\t\t * put the tag name in the tag stack\n\t\t */\n\t\tif ((tagstack[tagstackidx].tagname = vim_strsave(tag)) == NULL)\n\t\t{\n\t\t    curwin->w_tagstacklen = tagstacklen - 1;\n\t\t    goto end_do_tag;\n\t\t}\n\t\tcurwin->w_tagstacklen = tagstacklen;\n\n\t\tsave_pos = TRUE;\t// save the cursor position below\n\t    }\n\n\t    new_tag = TRUE;\n\t}\n\telse\n\t{\n\t    if (\n#if defined(FEAT_QUICKFIX)\n\t\t    g_do_tagpreview != 0 ? ptag_entry.tagname == NULL :\n#endif\n\t\t    tagstacklen == 0)\n\t    {\n\t\t// empty stack\n\t\temsg(_(e_tag_stack_empty));\n\t\tgoto end_do_tag;\n\t    }\n\n\t    if (type == DT_POP)\t\t// go to older position\n\t    {\n#ifdef FEAT_FOLDING\n\t\tint\told_KeyTyped = KeyTyped;\n#endif\n\t\tif ((tagstackidx -= count) < 0)\n\t\t{\n\t\t    emsg(_(e_at_bottom_of_tag_stack));\n\t\t    if (tagstackidx + count == 0)\n\t\t    {\n\t\t\t// We did [num]^T from the bottom of the stack\n\t\t\ttagstackidx = 0;\n\t\t\tgoto end_do_tag;\n\t\t    }\n\t\t    // We weren't at the bottom of the stack, so jump all the\n\t\t    // way to the bottom now.\n\t\t    tagstackidx = 0;\n\t\t}\n\t\telse if (tagstackidx >= tagstacklen)    // count == 0?\n\t\t{\n\t\t    emsg(_(e_at_top_of_tag_stack));\n\t\t    goto end_do_tag;\n\t\t}\n\n\t\t// Make a copy of the fmark, autocommands may invalidate the\n\t\t// tagstack before it's used.\n\t\tsaved_fmark = tagstack[tagstackidx].fmark;\n\t\tif (saved_fmark.fnum != curbuf->b_fnum)\n\t\t{\n\t\t    /*\n\t\t     * Jump to other file. If this fails (e.g. because the\n\t\t     * file was changed) keep original position in tag stack.\n\t\t     */\n\t\t    if (buflist_getfile(saved_fmark.fnum, saved_fmark.mark.lnum,\n\t\t\t\t\t       GETF_SETMARK, forceit) == FAIL)\n\t\t    {\n\t\t\ttagstackidx = oldtagstackidx;  // back to old posn\n\t\t\tgoto end_do_tag;\n\t\t    }\n\t\t    // An BufReadPost autocommand may jump to the '\" mark, but\n\t\t    // we don't what that here.\n\t\t    curwin->w_cursor.lnum = saved_fmark.mark.lnum;\n\t\t}\n\t\telse\n\t\t{\n\t\t    setpcmark();\n\t\t    curwin->w_cursor.lnum = saved_fmark.mark.lnum;\n\t\t}\n\t\tcurwin->w_cursor.col = saved_fmark.mark.col;\n\t\tcurwin->w_set_curswant = TRUE;\n\t\tcheck_cursor();\n#ifdef FEAT_FOLDING\n\t\tif ((fdo_flags & FDO_TAG) && old_KeyTyped)\n\t\t    foldOpenCursor();\n#endif\n\n\t\t// remove the old list of matches\n\t\tFreeWild(num_matches, matches);\n#ifdef FEAT_CSCOPE\n\t\tcs_free_tags();\n#endif\n\t\tnum_matches = 0;\n\t\ttag_freematch();\n\t\tgoto end_do_tag;\n\t    }\n\n\t    if (type == DT_TAG\n#if defined(FEAT_QUICKFIX)\n\t\t    || type == DT_LTAG\n#endif\n\t       )\n\t    {\n#if defined(FEAT_QUICKFIX)\n\t\tif (g_do_tagpreview != 0)\n\t\t{\n\t\t    cur_match = ptag_entry.cur_match;\n\t\t    cur_fnum = ptag_entry.cur_fnum;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    // \":tag\" (no argument): go to newer pattern\n\t\t    save_pos = TRUE;\t// save the cursor position below\n\t\t    if ((tagstackidx += count - 1) >= tagstacklen)\n\t\t    {\n\t\t\t/*\n\t\t\t * Beyond the last one, just give an error message and\n\t\t\t * go to the last one.  Don't store the cursor\n\t\t\t * position.\n\t\t\t */\n\t\t\ttagstackidx = tagstacklen - 1;\n\t\t\temsg(_(e_at_top_of_tag_stack));\n\t\t\tsave_pos = FALSE;\n\t\t    }\n\t\t    else if (tagstackidx < 0)\t// must have been count == 0\n\t\t    {\n\t\t\temsg(_(e_at_bottom_of_tag_stack));\n\t\t\ttagstackidx = 0;\n\t\t\tgoto end_do_tag;\n\t\t    }\n\t\t    cur_match = tagstack[tagstackidx].cur_match;\n\t\t    cur_fnum = tagstack[tagstackidx].cur_fnum;\n\t\t}\n\t\tnew_tag = TRUE;\n\t    }\n\t    else\t\t\t\t// go to other matching tag\n\t    {\n\t\t// Save index for when selection is cancelled.\n\t\tprevtagstackidx = tagstackidx;\n\n#if defined(FEAT_QUICKFIX)\n\t\tif (g_do_tagpreview != 0)\n\t\t{\n\t\t    cur_match = ptag_entry.cur_match;\n\t\t    cur_fnum = ptag_entry.cur_fnum;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    if (--tagstackidx < 0)\n\t\t\ttagstackidx = 0;\n\t\t    cur_match = tagstack[tagstackidx].cur_match;\n\t\t    cur_fnum = tagstack[tagstackidx].cur_fnum;\n\t\t}\n\t\tswitch (type)\n\t\t{\n\t\t    case DT_FIRST: cur_match = count - 1; break;\n\t\t    case DT_SELECT:\n\t\t    case DT_JUMP:\n#ifdef FEAT_CSCOPE\n\t\t    case DT_CSCOPE:\n#endif\n\t\t    case DT_LAST:  cur_match = MAXCOL - 1; break;\n\t\t    case DT_NEXT:  cur_match += count; break;\n\t\t    case DT_PREV:  cur_match -= count; break;\n\t\t}\n\t\tif (cur_match >= MAXCOL)\n\t\t    cur_match = MAXCOL - 1;\n\t\telse if (cur_match < 0)\n\t\t{\n\t\t    emsg(_(e_cannot_go_before_first_matching_tag));\n\t\t    skip_msg = TRUE;\n\t\t    cur_match = 0;\n\t\t    cur_fnum = curbuf->b_fnum;\n\t\t}\n\t    }\n\t}\n\n#if defined(FEAT_QUICKFIX)\n\tif (g_do_tagpreview != 0)\n\t{\n\t    if (type != DT_SELECT && type != DT_JUMP)\n\t    {\n\t\tptag_entry.cur_match = cur_match;\n\t\tptag_entry.cur_fnum = cur_fnum;\n\t    }\n\t}\n\telse\n#endif\n\t{\n\t    /*\n\t     * For \":tag [arg]\" or \":tselect\" remember position before the jump.\n\t     */\n\t    saved_fmark = tagstack[tagstackidx].fmark;\n\t    if (save_pos)\n\t    {\n\t\ttagstack[tagstackidx].fmark.mark = curwin->w_cursor;\n\t\ttagstack[tagstackidx].fmark.fnum = curbuf->b_fnum;\n\t    }\n\n\t    // Curwin will change in the call to jumpto_tag() if \":stag\" was\n\t    // used or an autocommand jumps to another window; store value of\n\t    // tagstackidx now.\n\t    curwin->w_tagstackidx = tagstackidx;\n\t    if (type != DT_SELECT && type != DT_JUMP)\n\t    {\n\t\tcurwin->w_tagstack[tagstackidx].cur_match = cur_match;\n\t\tcurwin->w_tagstack[tagstackidx].cur_fnum = cur_fnum;\n\t    }\n\t}\n    }\n\n    // When not using the current buffer get the name of buffer \"cur_fnum\".\n    // Makes sure that the tag order doesn't change when using a remembered\n    // position for \"cur_match\".\n    if (cur_fnum != curbuf->b_fnum)\n    {\n\tbuf_T *buf = buflist_findnr(cur_fnum);\n\n\tif (buf != NULL)\n\t    buf_ffname = buf->b_ffname;\n    }\n\n    /*\n     * Repeat searching for tags, when a file has not been found.\n     */\n    for (;;)\n    {\n\tint\tother_name;\n\tchar_u\t*name;\n\n\t/*\n\t * When desired match not found yet, try to find it (and others).\n\t */\n\tif (use_tagstack)\n\t{\n\t    // make a copy, the tagstack may change in 'tagfunc'\n\t    name = vim_strsave(tagstack[tagstackidx].tagname);\n\t    vim_free(tofree);\n\t    tofree = name;\n\t}\n#if defined(FEAT_QUICKFIX)\n\telse if (g_do_tagpreview != 0)\n\t    name = ptag_entry.tagname;\n#endif\n\telse\n\t    name = tag;\n\tother_name = (tagmatchname == NULL || STRCMP(tagmatchname, name) != 0);\n\tif (new_tag\n\t\t|| (cur_match >= num_matches && max_num_matches != MAXCOL)\n\t\t|| other_name)\n\t{\n\t    if (other_name)\n\t    {\n\t\tvim_free(tagmatchname);\n\t\ttagmatchname = vim_strsave(name);\n\t    }\n\n\t    if (type == DT_SELECT || type == DT_JUMP\n#if defined(FEAT_QUICKFIX)\n\t\t|| type == DT_LTAG\n#endif\n\t\t)\n\t\tcur_match = MAXCOL - 1;\n\t    if (type == DT_TAG)\n\t\tmax_num_matches = MAXCOL;\n\t    else\n\t\tmax_num_matches = cur_match + 1;\n\n\t    // when the argument starts with '/', use it as a regexp\n\t    if (!no_regexp && *name == '/')\n\t    {\n\t\tflags = TAG_REGEXP;\n\t\t++name;\n\t    }\n\t    else\n\t\tflags = TAG_NOIC;\n\n#ifdef FEAT_CSCOPE\n\t    if (type == DT_CSCOPE)\n\t\tflags = TAG_CSCOPE;\n#endif\n\t    if (verbose)\n\t\tflags |= TAG_VERBOSE;\n\n\t    if (!use_tfu)\n\t\tflags |= TAG_NO_TAGFUNC;\n\n\t    if (find_tags(name, &new_num_matches, &new_matches, flags,\n\t\t\t\t\t    max_num_matches, buf_ffname) == OK\n\t\t    && new_num_matches < max_num_matches)\n\t\tmax_num_matches = MAXCOL; // If less than max_num_matches\n\t\t\t\t\t  // found: all matches found.\n\n\t    // If there already were some matches for the same name, move them\n\t    // to the start.  Avoids that the order changes when using\n\t    // \":tnext\" and jumping to another file.\n\t    if (!new_tag && !other_name)\n\t    {\n\t\tint\t    j, k;\n\t\tint\t    idx = 0;\n\t\ttagptrs_T   tagp, tagp2;\n\n\t\t// Find the position of each old match in the new list.  Need\n\t\t// to use parse_match() to find the tag line.\n\t\tfor (j = 0; j < num_matches; ++j)\n\t\t{\n\t\t    parse_match(matches[j], &tagp);\n\t\t    for (i = idx; i < new_num_matches; ++i)\n\t\t    {\n\t\t\tparse_match(new_matches[i], &tagp2);\n\t\t\tif (STRCMP(tagp.tagname, tagp2.tagname) == 0)\n\t\t\t{\n\t\t\t    char_u *p = new_matches[i];\n\t\t\t    for (k = i; k > idx; --k)\n\t\t\t\tnew_matches[k] = new_matches[k - 1];\n\t\t\t    new_matches[idx++] = p;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    FreeWild(num_matches, matches);\n\t    num_matches = new_num_matches;\n\t    matches = new_matches;\n\t}\n\n\tif (num_matches <= 0)\n\t{\n\t    if (verbose)\n\t\tsemsg(_(e_tag_not_found_str), name);\n#if defined(FEAT_QUICKFIX)\n\t    g_do_tagpreview = 0;\n#endif\n\t}\n\telse\n\t{\n\t    int ask_for_selection = FALSE;\n\n#ifdef FEAT_CSCOPE\n\t    if (type == DT_CSCOPE && num_matches > 1)\n\t    {\n\t\tcs_print_tags();\n\t\task_for_selection = TRUE;\n\t    }\n\t    else\n#endif\n\t    if (type == DT_TAG && *tag != NUL)\n\t\t// If a count is supplied to the \":tag <name>\" command, then\n\t\t// jump to count'th matching tag.\n\t\tcur_match = count > 0 ? count - 1 : 0;\n\t    else if (type == DT_SELECT || (type == DT_JUMP && num_matches > 1))\n\t    {\n\t\tprint_tag_list(new_tag, use_tagstack, num_matches, matches);\n\t\task_for_selection = TRUE;\n\t    }\n#if defined(FEAT_QUICKFIX) && defined(FEAT_EVAL)\n\t    else if (type == DT_LTAG)\n\t    {\n\t\tif (add_llist_tags(tag, num_matches, matches) == FAIL)\n\t\t    goto end_do_tag;\n\t\tcur_match = 0;\t\t// Jump to the first tag\n\t    }\n#endif\n\n\t    if (ask_for_selection == TRUE)\n\t    {\n\t\t/*\n\t\t * Ask to select a tag from the list.\n\t\t */\n\t\ti = prompt_for_number(NULL);\n\t\tif (i <= 0 || i > num_matches || got_int)\n\t\t{\n\t\t    // no valid choice: don't change anything\n\t\t    if (use_tagstack)\n\t\t    {\n\t\t\ttagstack[tagstackidx].fmark = saved_fmark;\n\t\t\ttagstackidx = prevtagstackidx;\n\t\t    }\n#ifdef FEAT_CSCOPE\n\t\t    cs_free_tags();\n\t\t    jumped_to_tag = TRUE;\n#endif\n\t\t    break;\n\t\t}\n\t\tcur_match = i - 1;\n\t    }\n\n\t    if (cur_match >= num_matches)\n\t    {\n\t\t// Avoid giving this error when a file wasn't found and we're\n\t\t// looking for a match in another file, which wasn't found.\n\t\t// There will be an emsg(\"file doesn't exist\") below then.\n\t\tif ((type == DT_NEXT || type == DT_FIRST)\n\t\t\t\t\t\t      && nofile_fname == NULL)\n\t\t{\n\t\t    if (num_matches == 1)\n\t\t\temsg(_(e_there_is_only_one_matching_tag));\n\t\t    else\n\t\t\temsg(_(e_cannot_go_beyond_last_matching_tag));\n\t\t    skip_msg = TRUE;\n\t\t}\n\t\tcur_match = num_matches - 1;\n\t    }\n\t    if (use_tagstack)\n\t    {\n\t\ttagptrs_T   tagp;\n\n\t\ttagstack[tagstackidx].cur_match = cur_match;\n\t\ttagstack[tagstackidx].cur_fnum = cur_fnum;\n\n\t\t// store user-provided data originating from tagfunc\n\t\tif (use_tfu && parse_match(matches[cur_match], &tagp) == OK\n\t\t\t&& tagp.user_data)\n\t\t{\n\t\t    VIM_CLEAR(tagstack[tagstackidx].user_data);\n\t\t    tagstack[tagstackidx].user_data = vim_strnsave(\n\t\t\t  tagp.user_data, tagp.user_data_end - tagp.user_data);\n\t\t}\n\n\t\t++tagstackidx;\n\t    }\n#if defined(FEAT_QUICKFIX)\n\t    else if (g_do_tagpreview != 0)\n\t    {\n\t\tptag_entry.cur_match = cur_match;\n\t\tptag_entry.cur_fnum = cur_fnum;\n\t    }\n#endif\n\n\t    /*\n\t     * Only when going to try the next match, report that the previous\n\t     * file didn't exist.  Otherwise an emsg() is given below.\n\t     */\n\t    if (nofile_fname != NULL && error_cur_match != cur_match)\n\t\tsmsg(_(\"File \\\"%s\\\" does not exist\"), nofile_fname);\n\n\n\t    ic = (matches[cur_match][0] & MT_IC_OFF);\n\t    if (type != DT_TAG && type != DT_SELECT && type != DT_JUMP\n#ifdef FEAT_CSCOPE\n\t\t&& type != DT_CSCOPE\n#endif\n\t\t&& (num_matches > 1 || ic)\n\t\t&& !skip_msg)\n\t    {\n\t\t// Give an indication of the number of matching tags\n\t\tsprintf((char *)IObuff, _(\"tag %d of %d%s\"),\n\t\t\t\tcur_match + 1,\n\t\t\t\tnum_matches,\n\t\t\t\tmax_num_matches != MAXCOL ? _(\" or more\") : \"\");\n\t\tif (ic)\n\t\t    STRCAT(IObuff, _(\"  Using tag with different case!\"));\n\t\tif ((num_matches > prev_num_matches || new_tag)\n\t\t\t\t\t\t\t   && num_matches > 1)\n\t\t{\n\t\t    if (ic)\n\t\t\tmsg_attr((char *)IObuff, HL_ATTR(HLF_W));\n\t\t    else\n\t\t\tmsg((char *)IObuff);\n\t\t    msg_scroll = TRUE;\t// don't overwrite this message\n\t\t}\n\t\telse\n\t\t    give_warning(IObuff, ic);\n\t\tif (ic && !msg_scrolled && msg_silent == 0)\n\t\t{\n\t\t    out_flush();\n\t\t    ui_delay(1007L, TRUE);\n\t\t}\n\t    }\n\n#if defined(FEAT_EVAL)\n\t    // Let the SwapExists event know what tag we are jumping to.\n\t    vim_snprintf((char *)IObuff, IOSIZE, \":ta %s\\r\", name);\n\t    set_vim_var_string(VV_SWAPCOMMAND, IObuff, -1);\n#endif\n\n\t    /*\n\t     * Jump to the desired match.\n\t     */\n\t    i = jumpto_tag(matches[cur_match], forceit, type != DT_CSCOPE);\n\n#if defined(FEAT_EVAL)\n\t    set_vim_var_string(VV_SWAPCOMMAND, NULL, -1);\n#endif\n\n\t    if (i == NOTAGFILE)\n\t    {\n\t\t// File not found: try again with another matching tag\n\t\tif ((type == DT_PREV && cur_match > 0)\n\t\t\t|| ((type == DT_TAG || type == DT_NEXT\n\t\t\t\t\t\t\t  || type == DT_FIRST)\n\t\t\t    && (max_num_matches != MAXCOL\n\t\t\t\t\t     || cur_match < num_matches - 1)))\n\t\t{\n\t\t    error_cur_match = cur_match;\n\t\t    if (use_tagstack)\n\t\t\t--tagstackidx;\n\t\t    if (type == DT_PREV)\n\t\t\t--cur_match;\n\t\t    else\n\t\t    {\n\t\t\ttype = DT_NEXT;\n\t\t\t++cur_match;\n\t\t    }\n\t\t    continue;\n\t\t}\n\t\tsemsg(_(e_file_str_does_not_exist), nofile_fname);\n\t    }\n\t    else\n\t    {\n\t\t// We may have jumped to another window, check that\n\t\t// tagstackidx is still valid.\n\t\tif (use_tagstack && tagstackidx > curwin->w_tagstacklen)\n\t\t    tagstackidx = curwin->w_tagstackidx;\n#ifdef FEAT_CSCOPE\n\t\tjumped_to_tag = TRUE;\n#endif\n\t    }\n\t}\n\tbreak;\n    }\n\nend_do_tag:\n    // Only store the new index when using the tagstack and it's valid.\n    if (use_tagstack && tagstackidx <= curwin->w_tagstacklen)\n\tcurwin->w_tagstackidx = tagstackidx;\n    postponed_split = 0;\t// don't split next time\n# ifdef FEAT_QUICKFIX\n    g_do_tagpreview = 0;\t// don't do tag preview next time\n# endif\n\n    vim_free(tofree);\n#ifdef FEAT_CSCOPE\n    return jumped_to_tag;\n#else\n    return FALSE;\n#endif\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "None",
        "method_name": "fixed_function",
        "raw_code": "do_tag(\n    char_u\t*tag,\t\t// tag (pattern) to jump to\n    int\t\ttype,\n    int\t\tcount,\n    int\t\tforceit,\t// :ta with !\n    int\t\tverbose)\t// print \"tag not found\" message\n{\n    taggy_T\t*tagstack = curwin->w_tagstack;\n    int\t\ttagstackidx = curwin->w_tagstackidx;\n    int\t\ttagstacklen = curwin->w_tagstacklen;\n    int\t\tcur_match = 0;\n    int\t\tcur_fnum = curbuf->b_fnum;\n    int\t\toldtagstackidx = tagstackidx;\n    int\t\tprevtagstackidx = tagstackidx;\n    int\t\tprev_num_matches;\n    int\t\tnew_tag = FALSE;\n    int\t\ti;\n    int\t\tic;\n    int\t\tno_regexp = FALSE;\n    int\t\terror_cur_match = 0;\n    int\t\tsave_pos = FALSE;\n    fmark_T\tsaved_fmark;\n#ifdef FEAT_CSCOPE\n    int\t\tjumped_to_tag = FALSE;\n#endif\n    int\t\tnew_num_matches;\n    char_u\t**new_matches;\n    int\t\tuse_tagstack;\n    int\t\tskip_msg = FALSE;\n    char_u\t*buf_ffname = curbuf->b_ffname;\t    // name to use for\n\t\t\t\t\t\t    // priority computation\n    int\t\tuse_tfu = 1;\n    char_u\t*tofree = NULL;\n\n    // remember the matches for the last used tag\n    static int\t\tnum_matches = 0;\n    static int\t\tmax_num_matches = 0;  // limit used for match search\n    static char_u\t**matches = NULL;\n    static int\t\tflags;\n\n#ifdef FEAT_EVAL\n    if (tfu_in_use)\n    {\n\temsg(_(e_cannot_modify_tag_stack_within_tagfunc));\n\treturn FALSE;\n    }\n#endif\n\n#ifdef EXITFREE\n    if (type == DT_FREE)\n    {\n\t// remove the list of matches\n\tFreeWild(num_matches, matches);\n# ifdef FEAT_CSCOPE\n\tcs_free_tags();\n# endif\n\tnum_matches = 0;\n\treturn FALSE;\n    }\n#endif\n\n    if (type == DT_HELP)\n    {\n\ttype = DT_TAG;\n\tno_regexp = TRUE;\n\tuse_tfu = 0;\n    }\n\n    prev_num_matches = num_matches;\n    free_string_option(nofile_fname);\n    nofile_fname = NULL;\n\n    CLEAR_POS(&saved_fmark.mark);\t// shutup gcc 4.0\n    saved_fmark.fnum = 0;\n\n    /*\n     * Don't add a tag to the tagstack if 'tagstack' has been reset.\n     */\n    if ((!p_tgst && *tag != NUL))\n    {\n\tuse_tagstack = FALSE;\n\tnew_tag = TRUE;\n#if defined(FEAT_QUICKFIX)\n\tif (g_do_tagpreview != 0)\n\t{\n\t    tagstack_clear_entry(&ptag_entry);\n\t    if ((ptag_entry.tagname = vim_strsave(tag)) == NULL)\n\t\tgoto end_do_tag;\n\t}\n#endif\n    }\n    else\n    {\n#if defined(FEAT_QUICKFIX)\n\tif (g_do_tagpreview != 0)\n\t    use_tagstack = FALSE;\n\telse\n#endif\n\t    use_tagstack = TRUE;\n\n\t// new pattern, add to the tag stack\n\tif (*tag != NUL\n\t\t&& (type == DT_TAG || type == DT_SELECT || type == DT_JUMP\n#ifdef FEAT_QUICKFIX\n\t\t    || type == DT_LTAG\n#endif\n#ifdef FEAT_CSCOPE\n\t\t    || type == DT_CSCOPE\n#endif\n\t\t    ))\n\t{\n#if defined(FEAT_QUICKFIX)\n\t    if (g_do_tagpreview != 0)\n\t    {\n\t\tif (ptag_entry.tagname != NULL\n\t\t\t&& STRCMP(ptag_entry.tagname, tag) == 0)\n\t\t{\n\t\t    // Jumping to same tag: keep the current match, so that\n\t\t    // the CursorHold autocommand example works.\n\t\t    cur_match = ptag_entry.cur_match;\n\t\t    cur_fnum = ptag_entry.cur_fnum;\n\t\t}\n\t\telse\n\t\t{\n\t\t    tagstack_clear_entry(&ptag_entry);\n\t\t    if ((ptag_entry.tagname = vim_strsave(tag)) == NULL)\n\t\t\tgoto end_do_tag;\n\t\t}\n\t    }\n\t    else\n#endif\n\t    {\n\t\t/*\n\t\t * If the last used entry is not at the top, delete all tag\n\t\t * stack entries above it.\n\t\t */\n\t\twhile (tagstackidx < tagstacklen)\n\t\t    tagstack_clear_entry(&tagstack[--tagstacklen]);\n\n\t\t// if the tagstack is full: remove oldest entry\n\t\tif (++tagstacklen > TAGSTACKSIZE)\n\t\t{\n\t\t    tagstacklen = TAGSTACKSIZE;\n\t\t    tagstack_clear_entry(&tagstack[0]);\n\t\t    for (i = 1; i < tagstacklen; ++i)\n\t\t\ttagstack[i - 1] = tagstack[i];\n\t\t    --tagstackidx;\n\t\t}\n\n\t\t/*\n\t\t * put the tag name in the tag stack\n\t\t */\n\t\tif ((tagstack[tagstackidx].tagname = vim_strsave(tag)) == NULL)\n\t\t{\n\t\t    curwin->w_tagstacklen = tagstacklen - 1;\n\t\t    goto end_do_tag;\n\t\t}\n\t\tcurwin->w_tagstacklen = tagstacklen;\n\n\t\tsave_pos = TRUE;\t// save the cursor position below\n\t    }\n\n\t    new_tag = TRUE;\n\t}\n\telse\n\t{\n\t    if (\n#if defined(FEAT_QUICKFIX)\n\t\t    g_do_tagpreview != 0 ? ptag_entry.tagname == NULL :\n#endif\n\t\t    tagstacklen == 0)\n\t    {\n\t\t// empty stack\n\t\temsg(_(e_tag_stack_empty));\n\t\tgoto end_do_tag;\n\t    }\n\n\t    if (type == DT_POP)\t\t// go to older position\n\t    {\n#ifdef FEAT_FOLDING\n\t\tint\told_KeyTyped = KeyTyped;\n#endif\n\t\tif ((tagstackidx -= count) < 0)\n\t\t{\n\t\t    emsg(_(e_at_bottom_of_tag_stack));\n\t\t    if (tagstackidx + count == 0)\n\t\t    {\n\t\t\t// We did [num]^T from the bottom of the stack\n\t\t\ttagstackidx = 0;\n\t\t\tgoto end_do_tag;\n\t\t    }\n\t\t    // We weren't at the bottom of the stack, so jump all the\n\t\t    // way to the bottom now.\n\t\t    tagstackidx = 0;\n\t\t}\n\t\telse if (tagstackidx >= tagstacklen)    // count == 0?\n\t\t{\n\t\t    emsg(_(e_at_top_of_tag_stack));\n\t\t    goto end_do_tag;\n\t\t}\n\n\t\t// Make a copy of the fmark, autocommands may invalidate the\n\t\t// tagstack before it's used.\n\t\tsaved_fmark = tagstack[tagstackidx].fmark;\n\t\tif (saved_fmark.fnum != curbuf->b_fnum)\n\t\t{\n\t\t    /*\n\t\t     * Jump to other file. If this fails (e.g. because the\n\t\t     * file was changed) keep original position in tag stack.\n\t\t     */\n\t\t    if (buflist_getfile(saved_fmark.fnum, saved_fmark.mark.lnum,\n\t\t\t\t\t       GETF_SETMARK, forceit) == FAIL)\n\t\t    {\n\t\t\ttagstackidx = oldtagstackidx;  // back to old posn\n\t\t\tgoto end_do_tag;\n\t\t    }\n\t\t    // An BufReadPost autocommand may jump to the '\" mark, but\n\t\t    // we don't what that here.\n\t\t    curwin->w_cursor.lnum = saved_fmark.mark.lnum;\n\t\t}\n\t\telse\n\t\t{\n\t\t    setpcmark();\n\t\t    curwin->w_cursor.lnum = saved_fmark.mark.lnum;\n\t\t}\n\t\tcurwin->w_cursor.col = saved_fmark.mark.col;\n\t\tcurwin->w_set_curswant = TRUE;\n\t\tcheck_cursor();\n#ifdef FEAT_FOLDING\n\t\tif ((fdo_flags & FDO_TAG) && old_KeyTyped)\n\t\t    foldOpenCursor();\n#endif\n\n\t\t// remove the old list of matches\n\t\tFreeWild(num_matches, matches);\n#ifdef FEAT_CSCOPE\n\t\tcs_free_tags();\n#endif\n\t\tnum_matches = 0;\n\t\ttag_freematch();\n\t\tgoto end_do_tag;\n\t    }\n\n\t    if (type == DT_TAG\n#if defined(FEAT_QUICKFIX)\n\t\t    || type == DT_LTAG\n#endif\n\t       )\n\t    {\n#if defined(FEAT_QUICKFIX)\n\t\tif (g_do_tagpreview != 0)\n\t\t{\n\t\t    cur_match = ptag_entry.cur_match;\n\t\t    cur_fnum = ptag_entry.cur_fnum;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    // \":tag\" (no argument): go to newer pattern\n\t\t    save_pos = TRUE;\t// save the cursor position below\n\t\t    if ((tagstackidx += count - 1) >= tagstacklen)\n\t\t    {\n\t\t\t/*\n\t\t\t * Beyond the last one, just give an error message and\n\t\t\t * go to the last one.  Don't store the cursor\n\t\t\t * position.\n\t\t\t */\n\t\t\ttagstackidx = tagstacklen - 1;\n\t\t\temsg(_(e_at_top_of_tag_stack));\n\t\t\tsave_pos = FALSE;\n\t\t    }\n\t\t    else if (tagstackidx < 0)\t// must have been count == 0\n\t\t    {\n\t\t\temsg(_(e_at_bottom_of_tag_stack));\n\t\t\ttagstackidx = 0;\n\t\t\tgoto end_do_tag;\n\t\t    }\n\t\t    cur_match = tagstack[tagstackidx].cur_match;\n\t\t    cur_fnum = tagstack[tagstackidx].cur_fnum;\n\t\t}\n\t\tnew_tag = TRUE;\n\t    }\n\t    else\t\t\t\t// go to other matching tag\n\t    {\n\t\t// Save index for when selection is cancelled.\n\t\tprevtagstackidx = tagstackidx;\n\n#if defined(FEAT_QUICKFIX)\n\t\tif (g_do_tagpreview != 0)\n\t\t{\n\t\t    cur_match = ptag_entry.cur_match;\n\t\t    cur_fnum = ptag_entry.cur_fnum;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    if (--tagstackidx < 0)\n\t\t\ttagstackidx = 0;\n\t\t    cur_match = tagstack[tagstackidx].cur_match;\n\t\t    cur_fnum = tagstack[tagstackidx].cur_fnum;\n\t\t}\n\t\tswitch (type)\n\t\t{\n\t\t    case DT_FIRST: cur_match = count - 1; break;\n\t\t    case DT_SELECT:\n\t\t    case DT_JUMP:\n#ifdef FEAT_CSCOPE\n\t\t    case DT_CSCOPE:\n#endif\n\t\t    case DT_LAST:  cur_match = MAXCOL - 1; break;\n\t\t    case DT_NEXT:  cur_match += count; break;\n\t\t    case DT_PREV:  cur_match -= count; break;\n\t\t}\n\t\tif (cur_match >= MAXCOL)\n\t\t    cur_match = MAXCOL - 1;\n\t\telse if (cur_match < 0)\n\t\t{\n\t\t    emsg(_(e_cannot_go_before_first_matching_tag));\n\t\t    skip_msg = TRUE;\n\t\t    cur_match = 0;\n\t\t    cur_fnum = curbuf->b_fnum;\n\t\t}\n\t    }\n\t}\n\n#if defined(FEAT_QUICKFIX)\n\tif (g_do_tagpreview != 0)\n\t{\n\t    if (type != DT_SELECT && type != DT_JUMP)\n\t    {\n\t\tptag_entry.cur_match = cur_match;\n\t\tptag_entry.cur_fnum = cur_fnum;\n\t    }\n\t}\n\telse\n#endif\n\t{\n\t    /*\n\t     * For \":tag [arg]\" or \":tselect\" remember position before the jump.\n\t     */\n\t    saved_fmark = tagstack[tagstackidx].fmark;\n\t    if (save_pos)\n\t    {\n\t\ttagstack[tagstackidx].fmark.mark = curwin->w_cursor;\n\t\ttagstack[tagstackidx].fmark.fnum = curbuf->b_fnum;\n\t    }\n\n\t    // Curwin will change in the call to jumpto_tag() if \":stag\" was\n\t    // used or an autocommand jumps to another window; store value of\n\t    // tagstackidx now.\n\t    curwin->w_tagstackidx = tagstackidx;\n\t    if (type != DT_SELECT && type != DT_JUMP)\n\t    {\n\t\tcurwin->w_tagstack[tagstackidx].cur_match = cur_match;\n\t\tcurwin->w_tagstack[tagstackidx].cur_fnum = cur_fnum;\n\t    }\n\t}\n    }\n\n    // When not using the current buffer get the name of buffer \"cur_fnum\".\n    // Makes sure that the tag order doesn't change when using a remembered\n    // position for \"cur_match\".\n    if (cur_fnum != curbuf->b_fnum)\n    {\n\tbuf_T *buf = buflist_findnr(cur_fnum);\n\n\tif (buf != NULL)\n\t    buf_ffname = buf->b_ffname;\n    }\n\n    /*\n     * Repeat searching for tags, when a file has not been found.\n     */\n    for (;;)\n    {\n\tint\tother_name;\n\tchar_u\t*name;\n\n\t/*\n\t * When desired match not found yet, try to find it (and others).\n\t */\n\tif (use_tagstack)\n\t{\n\t    // make a copy, the tagstack may change in 'tagfunc'\n\t    name = vim_strsave(tagstack[tagstackidx].tagname);\n\t    vim_free(tofree);\n\t    tofree = name;\n\t}\n#if defined(FEAT_QUICKFIX)\n\telse if (g_do_tagpreview != 0)\n\t    name = ptag_entry.tagname;\n#endif\n\telse\n\t    name = tag;\n\tother_name = (tagmatchname == NULL || STRCMP(tagmatchname, name) != 0);\n\tif (new_tag\n\t\t|| (cur_match >= num_matches && max_num_matches != MAXCOL)\n\t\t|| other_name)\n\t{\n\t    if (other_name)\n\t    {\n\t\tvim_free(tagmatchname);\n\t\ttagmatchname = vim_strsave(name);\n\t    }\n\n\t    if (type == DT_SELECT || type == DT_JUMP\n#if defined(FEAT_QUICKFIX)\n\t\t|| type == DT_LTAG\n#endif\n\t\t)\n\t\tcur_match = MAXCOL - 1;\n\t    if (type == DT_TAG)\n\t\tmax_num_matches = MAXCOL;\n\t    else\n\t\tmax_num_matches = cur_match + 1;\n\n\t    // when the argument starts with '/', use it as a regexp\n\t    if (!no_regexp && *name == '/')\n\t    {\n\t\tflags = TAG_REGEXP;\n\t\t++name;\n\t    }\n\t    else\n\t\tflags = TAG_NOIC;\n\n#ifdef FEAT_CSCOPE\n\t    if (type == DT_CSCOPE)\n\t\tflags = TAG_CSCOPE;\n#endif\n\t    if (verbose)\n\t\tflags |= TAG_VERBOSE;\n\n\t    if (!use_tfu)\n\t\tflags |= TAG_NO_TAGFUNC;\n\n\t    if (find_tags(name, &new_num_matches, &new_matches, flags,\n\t\t\t\t\t    max_num_matches, buf_ffname) == OK\n\t\t    && new_num_matches < max_num_matches)\n\t\tmax_num_matches = MAXCOL; // If less than max_num_matches\n\t\t\t\t\t  // found: all matches found.\n\n\t    // A tag function may do anything, which may cause various\n\t    // information to become invalid.  At least check for the tagstack\n\t    // to still be the same.\n\t    if (tagstack != curwin->w_tagstack)\n\t    {\n\t\temsg(_(e_window_unexpectedly_close_while_searching_for_tags));\n\t\tFreeWild(new_num_matches, new_matches);\n\t\tbreak;\n\t    }\n\n\t    // If there already were some matches for the same name, move them\n\t    // to the start.  Avoids that the order changes when using\n\t    // \":tnext\" and jumping to another file.\n\t    if (!new_tag && !other_name)\n\t    {\n\t\tint\t    j, k;\n\t\tint\t    idx = 0;\n\t\ttagptrs_T   tagp, tagp2;\n\n\t\t// Find the position of each old match in the new list.  Need\n\t\t// to use parse_match() to find the tag line.\n\t\tfor (j = 0; j < num_matches; ++j)\n\t\t{\n\t\t    parse_match(matches[j], &tagp);\n\t\t    for (i = idx; i < new_num_matches; ++i)\n\t\t    {\n\t\t\tparse_match(new_matches[i], &tagp2);\n\t\t\tif (STRCMP(tagp.tagname, tagp2.tagname) == 0)\n\t\t\t{\n\t\t\t    char_u *p = new_matches[i];\n\t\t\t    for (k = i; k > idx; --k)\n\t\t\t\tnew_matches[k] = new_matches[k - 1];\n\t\t\t    new_matches[idx++] = p;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    FreeWild(num_matches, matches);\n\t    num_matches = new_num_matches;\n\t    matches = new_matches;\n\t}\n\n\tif (num_matches <= 0)\n\t{\n\t    if (verbose)\n\t\tsemsg(_(e_tag_not_found_str), name);\n#if defined(FEAT_QUICKFIX)\n\t    g_do_tagpreview = 0;\n#endif\n\t}\n\telse\n\t{\n\t    int ask_for_selection = FALSE;\n\n#ifdef FEAT_CSCOPE\n\t    if (type == DT_CSCOPE && num_matches > 1)\n\t    {\n\t\tcs_print_tags();\n\t\task_for_selection = TRUE;\n\t    }\n\t    else\n#endif\n\t    if (type == DT_TAG && *tag != NUL)\n\t\t// If a count is supplied to the \":tag <name>\" command, then\n\t\t// jump to count'th matching tag.\n\t\tcur_match = count > 0 ? count - 1 : 0;\n\t    else if (type == DT_SELECT || (type == DT_JUMP && num_matches > 1))\n\t    {\n\t\tprint_tag_list(new_tag, use_tagstack, num_matches, matches);\n\t\task_for_selection = TRUE;\n\t    }\n#if defined(FEAT_QUICKFIX) && defined(FEAT_EVAL)\n\t    else if (type == DT_LTAG)\n\t    {\n\t\tif (add_llist_tags(tag, num_matches, matches) == FAIL)\n\t\t    goto end_do_tag;\n\t\tcur_match = 0;\t\t// Jump to the first tag\n\t    }\n#endif\n\n\t    if (ask_for_selection == TRUE)\n\t    {\n\t\t/*\n\t\t * Ask to select a tag from the list.\n\t\t */\n\t\ti = prompt_for_number(NULL);\n\t\tif (i <= 0 || i > num_matches || got_int)\n\t\t{\n\t\t    // no valid choice: don't change anything\n\t\t    if (use_tagstack)\n\t\t    {\n\t\t\ttagstack[tagstackidx].fmark = saved_fmark;\n\t\t\ttagstackidx = prevtagstackidx;\n\t\t    }\n#ifdef FEAT_CSCOPE\n\t\t    cs_free_tags();\n\t\t    jumped_to_tag = TRUE;\n#endif\n\t\t    break;\n\t\t}\n\t\tcur_match = i - 1;\n\t    }\n\n\t    if (cur_match >= num_matches)\n\t    {\n\t\t// Avoid giving this error when a file wasn't found and we're\n\t\t// looking for a match in another file, which wasn't found.\n\t\t// There will be an emsg(\"file doesn't exist\") below then.\n\t\tif ((type == DT_NEXT || type == DT_FIRST)\n\t\t\t\t\t\t      && nofile_fname == NULL)\n\t\t{\n\t\t    if (num_matches == 1)\n\t\t\temsg(_(e_there_is_only_one_matching_tag));\n\t\t    else\n\t\t\temsg(_(e_cannot_go_beyond_last_matching_tag));\n\t\t    skip_msg = TRUE;\n\t\t}\n\t\tcur_match = num_matches - 1;\n\t    }\n\t    if (use_tagstack)\n\t    {\n\t\ttagptrs_T   tagp;\n\n\t\ttagstack[tagstackidx].cur_match = cur_match;\n\t\ttagstack[tagstackidx].cur_fnum = cur_fnum;\n\n\t\t// store user-provided data originating from tagfunc\n\t\tif (use_tfu && parse_match(matches[cur_match], &tagp) == OK\n\t\t\t&& tagp.user_data)\n\t\t{\n\t\t    VIM_CLEAR(tagstack[tagstackidx].user_data);\n\t\t    tagstack[tagstackidx].user_data = vim_strnsave(\n\t\t\t  tagp.user_data, tagp.user_data_end - tagp.user_data);\n\t\t}\n\n\t\t++tagstackidx;\n\t    }\n#if defined(FEAT_QUICKFIX)\n\t    else if (g_do_tagpreview != 0)\n\t    {\n\t\tptag_entry.cur_match = cur_match;\n\t\tptag_entry.cur_fnum = cur_fnum;\n\t    }\n#endif\n\n\t    /*\n\t     * Only when going to try the next match, report that the previous\n\t     * file didn't exist.  Otherwise an emsg() is given below.\n\t     */\n\t    if (nofile_fname != NULL && error_cur_match != cur_match)\n\t\tsmsg(_(\"File \\\"%s\\\" does not exist\"), nofile_fname);\n\n\n\t    ic = (matches[cur_match][0] & MT_IC_OFF);\n\t    if (type != DT_TAG && type != DT_SELECT && type != DT_JUMP\n#ifdef FEAT_CSCOPE\n\t\t&& type != DT_CSCOPE\n#endif\n\t\t&& (num_matches > 1 || ic)\n\t\t&& !skip_msg)\n\t    {\n\t\t// Give an indication of the number of matching tags\n\t\tsprintf((char *)IObuff, _(\"tag %d of %d%s\"),\n\t\t\t\tcur_match + 1,\n\t\t\t\tnum_matches,\n\t\t\t\tmax_num_matches != MAXCOL ? _(\" or more\") : \"\");\n\t\tif (ic)\n\t\t    STRCAT(IObuff, _(\"  Using tag with different case!\"));\n\t\tif ((num_matches > prev_num_matches || new_tag)\n\t\t\t\t\t\t\t   && num_matches > 1)\n\t\t{\n\t\t    if (ic)\n\t\t\tmsg_attr((char *)IObuff, HL_ATTR(HLF_W));\n\t\t    else\n\t\t\tmsg((char *)IObuff);\n\t\t    msg_scroll = TRUE;\t// don't overwrite this message\n\t\t}\n\t\telse\n\t\t    give_warning(IObuff, ic);\n\t\tif (ic && !msg_scrolled && msg_silent == 0)\n\t\t{\n\t\t    out_flush();\n\t\t    ui_delay(1007L, TRUE);\n\t\t}\n\t    }\n\n#if defined(FEAT_EVAL)\n\t    // Let the SwapExists event know what tag we are jumping to.\n\t    vim_snprintf((char *)IObuff, IOSIZE, \":ta %s\\r\", name);\n\t    set_vim_var_string(VV_SWAPCOMMAND, IObuff, -1);\n#endif\n\n\t    /*\n\t     * Jump to the desired match.\n\t     */\n\t    i = jumpto_tag(matches[cur_match], forceit, type != DT_CSCOPE);\n\n#if defined(FEAT_EVAL)\n\t    set_vim_var_string(VV_SWAPCOMMAND, NULL, -1);\n#endif\n\n\t    if (i == NOTAGFILE)\n\t    {\n\t\t// File not found: try again with another matching tag\n\t\tif ((type == DT_PREV && cur_match > 0)\n\t\t\t|| ((type == DT_TAG || type == DT_NEXT\n\t\t\t\t\t\t\t  || type == DT_FIRST)\n\t\t\t    && (max_num_matches != MAXCOL\n\t\t\t\t\t     || cur_match < num_matches - 1)))\n\t\t{\n\t\t    error_cur_match = cur_match;\n\t\t    if (use_tagstack)\n\t\t\t--tagstackidx;\n\t\t    if (type == DT_PREV)\n\t\t\t--cur_match;\n\t\t    else\n\t\t    {\n\t\t\ttype = DT_NEXT;\n\t\t\t++cur_match;\n\t\t    }\n\t\t    continue;\n\t\t}\n\t\tsemsg(_(e_file_str_does_not_exist), nofile_fname);\n\t    }\n\t    else\n\t    {\n\t\t// We may have jumped to another window, check that\n\t\t// tagstackidx is still valid.\n\t\tif (use_tagstack && tagstackidx > curwin->w_tagstacklen)\n\t\t    tagstackidx = curwin->w_tagstackidx;\n#ifdef FEAT_CSCOPE\n\t\tjumped_to_tag = TRUE;\n#endif\n\t    }\n\t}\n\tbreak;\n    }\n\nend_do_tag:\n    // Only store the new index when using the tagstack and it's valid.\n    if (use_tagstack && tagstackidx <= curwin->w_tagstacklen)\n\tcurwin->w_tagstackidx = tagstackidx;\n    postponed_split = 0;\t// don't split next time\n# ifdef FEAT_QUICKFIX\n    g_do_tagpreview = 0;\t// don't do tag preview next time\n# endif\n\n    vim_free(tofree);\n#ifdef FEAT_CSCOPE\n    return jumped_to_tag;\n#else\n    return FALSE;\n#endif\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"vim.h\"\n\n// Type Definitions:\n// pos_T:\ntypedef struct\n{\n    linenr_T\tlnum;\t// line number\n    colnr_T\tcol;\t// column number\n    colnr_T\tcoladd; // extra virtual column\n}\n\n// tagsearch_info_T:\ntypedef struct\n{\n    off_T\tlow_offset;\t// offset for first char of first line that\n\t\t\t\t// could match\n    off_T\thigh_offset;\t// offset of char after last line that could\n\t\t\t\t// match\n    off_T\tcurr_offset;\t// Current file offset in search range\n    off_T\tcurr_offset_used; // curr_offset used when skipping back\n    off_T\tmatch_offset;\t// Where the binary search found a tag\n    int\tlow_char;\t\t// first char at low_offset\n    int\thigh_char;\t\t// first char at high_offset\n}\n\n// exarg_T:\ntypedef struct exarg exarg_T;\n\n// hash_T:\ntypedef long_u hash_T;\n\n// dictitem_T:\ntypedef struct dictitem_S dictitem_T;\n\n// tags_read_status_T:\ntypedef enum\n{\n    TAGS_READ_SUCCESS = 1,\n    TAGS_READ_EOF,\n    TAGS_READ_IGNORE,\n}\n\n// tagmatch_status_T:\ntypedef enum\n{\n    TAG_MATCH_SUCCESS = 1,\n    TAG_MATCH_FAIL,\n    TAG_MATCH_STOP,\n    TAG_MATCH_NEXT\n}\n\n// expand_T:\ntypedef struct expand\n{\n    char_u\t*xp_pattern;\t\t// start of item to expand\n    int\t\txp_context;\t\t// type of expansion\n    int\t\txp_pattern_len;\t\t// bytes in xp_pattern before cursor\n#if defined(FEAT_EVAL)\n    char_u\t*xp_arg;\t\t// completion function\n    sctx_T\txp_script_ctx;\t\t// SCTX for completion function\n#endif\n    int\t\txp_backslash;\t\t// one of the XP_BS_ values\n#ifndef BACKSLASH_IN_FILENAME\n    int\t\txp_shell;\t\t// TRUE for a shell command, more\n\t\t\t\t\t// characters need to be escaped\n#endif\n    int\t\txp_numfiles;\t\t// number of files found by\n\t\t\t\t\t// file name completion\n    int\t\txp_col;\t\t\t// cursor position in line\n    char_u\t**xp_files;\t\t// list of files\n    char_u\t*xp_line;\t\t// text being completed\n#define EXPAND_BUF_LEN 256\n    char_u\txp_buf[EXPAND_BUF_LEN];\t// buffer for returned match\n} expand_T;\n\n// taggy_T:\ntypedef struct taggy\n{\n    char_u\t*tagname;\t// tag name\n    fmark_T\tfmark;\t\t// cursor position BEFORE \":tag\"\n    int\t\tcur_match;\t// match number\n    int\t\tcur_fnum;\t// buffer number used for cur_match\n    char_u\t*user_data;\t// used with tagfunc\n} taggy_T;\n\n// pat_T:\ntypedef struct\n{\n    char_u\t*pat;\t\t// the pattern\n    int\t\tlen;\t\t// length of pat[]\n    char_u\t*head;\t\t// start of pattern head\n    int\t\theadlen;\t// length of head[]\n    regmatch_T\tregmatch;\t// regexp program, may be NULL\n}\n\n// tagptrs_T:\ntypedef struct tag_pointers\n{\n    // filled in by parse_tag_line():\n    char_u\t*tagname;\t// start of tag name (skip \"file:\")\n    char_u\t*tagname_end;\t// char after tag name\n    char_u\t*fname;\t\t// first char of file name\n    char_u\t*fname_end;\t// char after file name\n    char_u\t*command;\t// first char of command\n    // filled in by parse_match():\n    char_u\t*command_end;\t// first char after command\n    char_u\t*tag_fname;\t// file name of the tags file. This is used\n\t\t\t\t// when 'tr' is set.\n#ifdef FEAT_EMACS_TAGS\n    int\t\tis_etag;\t// TRUE for emacs tag\n#endif\n    char_u\t*tagkind;\t// \"kind:\" value\n    char_u\t*tagkind_end;\t// end of tagkind\n    char_u\t*user_data;\t// user_data string\n    char_u\t*user_data_end;\t// end of user_data\n    linenr_T\ttagline;\t// \"line:\" value\n} tagptrs_T;\n\n// dict_iterator_T:\ntypedef struct\n{\n    long_u\tdit_todo;\n    hashitem_T\t*dit_hi;\n}\n\n// win_T:\ntypedef struct window_S\t\twin_T;\n\n// linenr_T:\ntypedef long\t\tlinenr_T;\n\n// linenr_T:\ntypedef long\tlinenr_T;\n\n// garray_T:\ntypedef struct growarray\n{\n    int\t    ga_len;\t\t    // current number of items used\n    int\t    ga_maxlen;\t\t    // maximum number of items possible\n    int\t    ga_itemsize;\t    // sizeof(item)\n    int\t    ga_growsize;\t    // number of items to grow each time\n    void    *ga_data;\t\t    // pointer to the first item\n} garray_T;\n\n// dict_T:\ntypedef struct dictvar_S dict_T;\n\n// listitem_T:\ntypedef struct listitem_S listitem_T;\n\n// off_T:\ntypedef off_t off_T;\n\n// findtags_state_T:\ntypedef struct\n{\n    tagsearch_state_T\tstate;\t\t// tag search state\n    int\t\tstop_searching;\t\t// stop when match found or error\n    pat_T\t*orgpat;\t\t// holds unconverted pattern info\n    char_u     *lbuf;\t\t\t// line buffer\n    int\t\tlbuf_size;\t\t// length of lbuf\n    char_u\t*tag_fname;\t\t// name of the tag file\n    FILE\t*fp;\t\t\t// current tags file pointer\n    int\t\tflags;\t\t\t// flags used for tag search\n    int\t\ttag_file_sorted;\t// !_TAG_FILE_SORTED value\n    int\t\tget_searchpat;\t\t// used for 'showfulltag'\n    int\t\thelp_only;\t\t// only search for help tags\n    int\t\tdid_open;\t\t// did open a tag file\n    int\t\tmincount;\t\t// MAXCOL: find all matches\n\t\t\t\t\t// other: minimal number of matches\n    int\t\tlinear;\t\t\t// do a linear search\n    vimconv_T\tvimconv;\n#ifdef FEAT_EMACS_TAGS\n    int\t\tis_etag;\t\t// current file is emacs style\n    char_u\t*ebuf;\t\t\t// additional buffer for etag fname\n#endif\n#ifdef FEAT_MULTI_LANG\n    char_u\thelp_lang[3];\t\t// lang of current tags file\n    int\t\thelp_pri;\t\t// help langua...\n\n// char_u:\ntypedef unsigned char\tchar_u;\n\n// off_T:\ntypedef __int64 off_T;\n\n// fmark_T:\ntypedef struct filemark\n{\n    pos_T\tmark;\t\t// cursor position\n    int\t\tfnum;\t\t// file number\n} fmark_T;\n\n// typval_T:\ntypedef struct\n{\n    vartype_T\tv_type;\n    char\tv_lock;\t    // see below: VAR_LOCKED, VAR_FIXED\n    union\n    {\n\tvarnumber_T\tv_number;\t// number value\n#ifdef FEAT_FLOAT\n\tfloat_T\t\tv_float;\t// floating number value\n#endif\n\tchar_u\t\t*v_string;\t// string value (can be NULL!)\n\tlist_T\t\t*v_list;\t// list value (can be NULL!)\n\tdict_T\t\t*v_dict;\t// dict value (can be NULL!)\n\tpartial_T\t*v_partial;\t// closure: function with args\n#ifdef FEAT_JOB_CHANNEL\n\tjob_T\t\t*v_job;\t\t// job value (can be NULL!)\n\tchannel_T\t*v_channel;\t// channel value (can be NULL!)\n#endif\n\tblob_T\t\t*v_blob;\t// blob value (can be NULL!)\n\tinstr_T\t\t*v_instr;\t// instructions to execute\n    }\t\tvval;\n}\n\n// optmagic_T:\ntypedef enum {\n    OPTION_MAGIC_NOT_SET,\t// p_magic not overruled\n    OPTION_MAGIC_ON,\t\t// magic on inside regexp\n    OPTION_MAGIC_OFF\t\t// magic off inside regexp\n}\n\n// tagname_T:\ntypedef struct\n{\n    char_u\t*tn_tags;\t// value of 'tags' when starting\n    char_u\t*tn_np;\t\t// current position in tn_tags\n    int\t\ttn_did_filefind_init;\n    int\t\ttn_hf_idx;\n    void\t*tn_search_ctx;\n}\n\n// findtags_match_args_T:\ntypedef struct\n{\n    int\tmatchoff;\t\t// tag match offset\n    int\tmatch_re;\t\t// TRUE if the tag matches a regexp\n    int\tmatch_no_ic;\t\t// TRUE if the tag matches with case\n    int\thas_re;\t\t\t// regular expression used\n    int\tsortic;\t\t\t// tags file sorted ignoring case (foldcase)\n    int\tsort_error;\t\t// tags file not sorted\n}\n\n// buf_T:\ntypedef struct file_buffer\tbuf_T;\n\n// hashitem_T:\ntypedef struct hashitem_S\n{\n    long_u\thi_hash;\t// cached hash number of hi_key\n    char_u\t*hi_key;\n} hashitem_T;\n\n// list_T:\ntypedef struct listvar_S list_T;\n\n// callback_T:\ntypedef struct {\n    char_u\t*cb_name;\n    partial_T\t*cb_partial;\n    int\t\tcb_free_name;\t    // cb_name was allocated\n}\n\n// Called Methods (top 10):\n// find_wininfo from src/buffer.c:\n    static wininfo_T * /* <=== find_wininfo */ \nfind_wininfo(\n    buf_T\t*buf,\n    int\t\tneed_options,\n    int\t\tskip_diff_buffer UNUSED)\n{\n    wininfo_T\t*wip;\n\n    FOR_ALL_BUF_WININFO(buf, wip)\n\tif (wip->wi_win == curwin\n#ifdef FEAT_DIFF\n\t\t&& (!skip_diff_buffer || !wininfo_other_tab_diff(wip))\n#endif\n\n\t\t&& (!need_options || wip->wi_optset))\n\t    break;\n\n    // If no wininfo for curwin, use the first in the list (that doesn't have\n    // 'diff' set and is in another tab page).\n    // If \"need_options\" is TRUE skip entries that don't have options set,\n    // unless the window is editing \"buf\", so we can copy from the window\n    // itself.\n    if (wip == NULL)\n    {\n#ifdef FEAT_DIFF\n\tif (skip_diff_buffer)\n\t{\n\t    FOR_ALL_BUF_WININFO(buf, wip)\n\t\tif (!wininfo_other_tab_diff(wip)\n\t\t\t&& (!need_options || wip->wi_optset\n\t\t\t    || (wip->wi_win != NULL\n\t\t\t\t\t     && wip->wi_win->w_buffer == buf)))\n\t\t    break;\n\t}\n\telse\n#endif\n\t    wip = buf->b_wininfo;\n    }\n    return wip;\n}\n\n// set_vv_searchforward from src/search.c:\n    static void /* <=== set_vv_searchforward */ \nset_vv_searchforward(void)\n{\n    set_vim_var_nr(VV_SEARCHFORWARD, (long)(spats[0].off.dir == '/'));\n}\n\n// POPF_INFO from src/vim.h:\n#define POPF_INFO\t0x200\t// used for info of popup menu /* <=== src/vim.h:641:641:POPF_INFO:0 */ \n\n// DOCMD_EXCRESET from src/vim.h:\n#define DOCMD_EXCRESET\t0x10\t// reset exception environment (for debugging) /* <=== src/vim.h:1088:1088:DOCMD_EXCRESET:0 */ \n\n// TC_MATCH from src/option.h:\n<empty>\n\n// win_split_ins from src/window.c:\n    int /* <=== win_split_ins */ \nwin_split_ins(\n    int\t\tsize,\n    int\t\tflags,\n    win_T\t*new_wp,\n    int\t\tdir)\n{\n    win_T\t*wp = new_wp;\n    win_T\t*oldwin;\n    int\t\tnew_size = size;\n    int\t\ti;\n    int\t\tneed_status = 0;\n    int\t\tdo_equal = FALSE;\n    int\t\tneeded;\n    int\t\tavailable;\n    int\t\toldwin_height = 0;\n    int\t\tlayout;\n    frame_T\t*frp, *curfrp, *frp2, *prevfrp;\n    int\t\tbefore;\n    int\t\tminheight;\n    int\t\twmh1;\n    int\t\tdid_set_fraction = FALSE;\n\n    if (flags & WSP_TOP)\n\toldwin = firstwin;\n    else if (flags & WSP_BOT)\n\toldwin = lastwin;\n    else\n\toldwin = curwin;\n\n    // add a status line when p_ls == 1 and splitting the first window\n    if (ONE_WINDOW && p_ls == 1 && oldwin->w_status_height == 0)\n    {\n\tif (VISIBLE_HEIGHT(oldwin) <= p_wmh && new_wp == NULL)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    return FAIL;\n\t}\n\tneed_status = STATUS_HEIGHT;\n    }\n\n#ifdef FEAT_GUI\n    // May be needed for the scrollbars that are going to change.\n    if (gui.in_use)\n\tout_flush();\n#endif\n\n    if (flags & WSP_VERT)\n    {\n\tint\twmw1;\n\tint\tminwidth;\n\n\tlayout = FR_ROW;\n\n\t/*\n\t * Check if we are able to split the current window and compute its\n\t * width.\n\t */\n\t// Current window requires at least 1 space.\n\twmw1 = (p_wmw == 0 ? 1 : p_wmw);\n\tneeded = wmw1 + 1;\n\tif (flags & WSP_ROOM)\n\t    needed += p_wiw - wmw1;\n\tif (flags & (WSP_BOT | WSP_TOP))\n\t{\n\t    minwidth = frame_minwidth(topframe, NOWIN);\n\t    available = topframe->fr_width;\n\t    needed += minwidth;\n\t}\n\telse if (p_ea)\n\t{\n\t    minwidth = frame_minwidth(oldwin->w_frame, NOWIN);\n\t    prevfrp = oldwin->w_frame;\n\t    for (frp = oldwin->w_frame->fr_parent; frp != NULL;\n\t\t\t\t\t\t\tfrp = frp->fr_parent)\n\t    {\n\t\tif (frp->fr_layout == FR_ROW)\n\t\t    FOR_ALL_FRAMES(frp2, frp->fr_child)\n\t\t\tif (frp2 != prevfrp)\n\t\t\t    minwidth += frame_minwidth(frp2, NOWIN);\n\t\tprevfrp = frp;\n\t    }\n\t    available = topframe->fr_width;\n\t    needed += minwidth;\n\t}\n\telse\n\t{\n\t    minwidth = frame_minwidth(oldwin->w_frame, NOWIN);\n\t    available = oldwin->w_frame->fr_width;\n\t    needed += minwidth;\n\t}\n\tif (available < needed && new_wp == NULL)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    return FAIL;\n\t}\n\tif (new_size == 0)\n\t    new_size = oldwin->w_width / 2;\n\tif (new_size > available - minwidth - 1)\n\t    new_size = available - minwidth - 1;\n\tif (new_size < wmw1)\n\t    new_size = wmw1;\n\n\t// if it doesn't fit in the current window, need win_equal()\n\tif (oldwin->w_width - new_size - 1 < p_wmw)\n\t    do_equal = TRUE;\n\n\t// We don't like to take lines for the new window from a\n\t// 'winfixwidth' window.  Take them from a window to the left or right\n\t// instead, if possible. Add one for the separator.\n\tif (oldwin->w_p_wfw)\n\t    win_setwidth_win(oldwin->w_width + new_size + 1, oldwin);\n\n\t// Only make all windows the same width if one of them (except oldwin)\n\t// is wider than one of the split windows.\n\tif (!do_equal && p_ea && size == 0 && *p_ead != 'v'\n\t\t\t\t\t && oldwin->w_frame->fr_parent != NULL)\n\t{\n\t    frp = oldwin->w_frame->fr_parent->fr_child;\n\t    while (frp != NULL)\n\t    {\n\t\tif (frp->fr_win != oldwin && frp->fr_win != NULL\n\t\t\t&& (frp->fr_win->w_width > new_size\n\t\t\t    || frp->fr_win->w_width > oldwin->w_width\n\t\t\t\t\t\t\t      - new_size - 1))\n\t\t{\n\t\t    do_equal = TRUE;\n\t\t    break;\n\t\t}\n\t\tfrp = frp->fr_next;\n\t    }\n\t}\n    }\n    else\n    {\n\tlayout = FR_COL;\n\n\t/*\n\t * Check if we are able to split the current window and compute its\n\t * height.\n\t */\n\t// Current window requires at least 1 space.\n\twmh1 = (p_wmh == 0 ? 1 : p_wmh) + WINBAR_HEIGHT(curwin);\n\tneeded = wmh1 + STATUS_HEIGHT;\n\tif (flags & WSP_ROOM)\n\t    needed += p_wh - wmh1;\n\tif (flags & (WSP_BOT | WSP_TOP))\n\t{\n\t    minheight = frame_minheight(topframe, NOWIN) + need_status;\n\t    available = topframe->fr_height;\n\t    needed += minheight;\n\t}\n\telse if (p_ea)\n\t{\n\t    minheight = frame_minheight(oldwin->w_frame, NOWIN) + need_status;\n\t    prevfrp = oldwin->w_frame;\n\t    for (frp = oldwin->w_frame->fr_parent; frp != NULL;\n\t\t\t\t\t\t\tfrp = frp->fr_parent)\n\t    {\n\t\tif (frp->fr_layout == FR_COL)\n\t\t    FOR_ALL_FRAMES(frp2, frp->fr_child)\n\t\t\tif (frp2 != prevfrp)\n\t\t\t    minheight += frame_minheight(frp2, NOWIN);\n\t\tprevfrp = frp;\n\t    }\n\t    available = topframe->fr_height;\n\t    needed += minheight;\n\t}\n\telse\n\t{\n\t    minheight = frame_minheight(oldwin->w_frame, NOWIN) + need_status;\n\t    available = oldwin->w_frame->fr_height;\n\t    needed += minheight;\n\t}\n\tif (available < needed && new_wp == NULL)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    return FAIL;\n\t}\n\toldwin_height = oldwin->w_height;\n\tif (need_status)\n\t{\n\t    oldwin->w_status_height = STATUS_HEIGHT;\n\t    oldwin_height -= STATUS_HEIGHT;\n\t}\n\tif (new_size == 0)\n\t    new_size = oldwin_height / 2;\n\tif (new_size > available - minheight - STATUS_HEIGHT)\n\t    new_size = available - minheight - STATUS_HEIGHT;\n\tif (new_size < wmh1)\n\t    new_size = wmh1;\n\n\t// if it doesn't fit in the current window, need win_equal()\n\tif (oldwin_height - new_size - STATUS_HEIGHT < p_wmh)\n\t    do_equal = TRUE;\n\n\t// We don't like to take lines for the new window from a\n\t// 'winfixheight' window.  Take them from a window above or below\n\t// instead, if possible.\n\tif (oldwin->w_p_wfh)\n\t{\n\t    // Set w_fraction now so that the cursor keeps the same relative\n\t    // vertical position using the old height.\n\t    set_fraction(oldwin);\n\t    did_set_fraction = TRUE;\n\n\t    win_setheight_win(oldwin->w_height + new_size + STATUS_HEIGHT,\n\t\t\t\t\t\t\t\t      oldwin);\n\t    oldwin_height = oldwin->w_height;\n\t    if (need_status)\n\t\toldwin_height -= STATUS_HEIGHT;\n\t}\n\n\t// Only make all windows the same height if one of them (except oldwin)\n\t// is higher than one of the split windows.\n\tif (!do_equal && p_ea && size == 0 && *p_ead != 'h'\n\t   && oldwin->w_frame->fr_parent != NULL)\n\t{\n\t    frp = oldwin->w_frame->fr_parent->fr_child;\n\t    while (frp != NULL)\n\t    {\n\t\tif (frp->fr_win != oldwin && frp->fr_win != NULL\n\t\t\t&& (frp->fr_win->w_height > new_size\n\t\t\t    || frp->fr_win->w_height > oldwin_height - new_size\n\t\t\t\t\t\t\t      - STATUS_HEIGHT))\n\t\t{\n\t\t    do_equal = TRUE;\n\t\t    break;\n\t\t}\n\t\tfrp = frp->fr_next;\n\t    }\n\t}\n    }\n\n    /*\n     * allocate new window structure and link it in the window list\n     */\n    if ((flags & WSP_TOP) == 0\n\t    && ((flags & WSP_BOT)\n\t\t|| (flags & WSP_BELOW)\n\t\t|| (!(flags & WSP_ABOVE)\n\t\t    && ( (flags & WSP_VERT) ? p_spr : p_sb))))\n    {\n\t// new window below/right of current one\n\tif (new_wp == NULL)\n\t    wp = win_alloc(oldwin, FALSE);\n\telse\n\t    win_append(oldwin, wp);\n    }\n    else\n    {\n\tif (new_wp == NULL)\n\t    wp = win_alloc(oldwin->w_prev, FALSE);\n\telse\n\t    win_append(oldwin->w_prev, wp);\n    }\n\n    if (new_wp == NULL)\n    {\n\tif (wp == NULL)\n\t    return FAIL;\n\n\tnew_frame(wp);\n\tif (wp->w_frame == NULL)\n\t{\n\t    win_free(wp, NULL);\n\t    return FAIL;\n\t}\n\n\t// make the contents of the new window the same as the current one\n\twin_init(wp, curwin, flags);\n    }\n\n    /*\n     * Reorganise the tree of frames to insert the new window.\n     */\n    if (flags & (WSP_TOP | WSP_BOT))\n    {\n\tif ((topframe->fr_layout == FR_COL && (flags & WSP_VERT) == 0)\n\t    || (topframe->fr_layout == FR_ROW && (flags & WSP_VERT) != 0))\n\t{\n\t    curfrp = topframe->fr_child;\n\t    if (flags & WSP_BOT)\n\t\twhile (curfrp->fr_next != NULL)\n\t\t    curfrp = curfrp->fr_next;\n\t}\n\telse\n\t    curfrp = topframe;\n\tbefore = (flags & WSP_TOP);\n    }\n    else\n    {\n\tcurfrp = oldwin->w_frame;\n\tif (flags & WSP_BELOW)\n\t    before = FALSE;\n\telse if (flags & WSP_ABOVE)\n\t    before = TRUE;\n\telse if (flags & WSP_VERT)\n\t    before = !p_spr;\n\telse\n\t    before = !p_sb;\n    }\n    if (curfrp->fr_parent == NULL || curfrp->fr_parent->fr_layout != layout)\n    {\n\t// Need to create a new frame in the tree to make a branch.\n\tfrp = ALLOC_CLEAR_ONE(frame_T);\n\t*frp = *curfrp;\n\tcurfrp->fr_layout = layout;\n\tfrp->fr_parent = curfrp;\n\tfrp->fr_next = NULL;\n\tfrp->fr_prev = NULL;\n\tcurfrp->fr_child = frp;\n\tcurfrp->fr_win = NULL;\n\tcurfrp = frp;\n\tif (frp->fr_win != NULL)\n\t    oldwin->w_frame = frp;\n\telse\n\t    FOR_ALL_FRAMES(frp, frp->fr_child)\n\t\tfrp->fr_parent = curfrp;\n    }\n\n    if (new_wp == NULL)\n\tfrp = wp->w_frame;\n    else\n\tfrp = new_wp->w_frame;\n    frp->fr_parent = curfrp->fr_parent;\n\n    // Insert the new frame at the right place in the frame list.\n    if (before)\n\tframe_insert(curfrp, frp);\n    else\n\tframe_append(curfrp, frp);\n\n    // Set w_fraction now so that the cursor keeps the same relative\n    // vertical position.\n    if (!did_set_fraction)\n\tset_fraction(oldwin);\n    wp->w_fraction = oldwin->w_fraction;\n\n    if (flags & WSP_VERT)\n    {\n\twp->w_p_scr = curwin->w_p_scr;\n\n\tif (need_status)\n\t{\n\t    win_new_height(oldwin, oldwin->w_height - 1);\n\t    oldwin->w_status_height = need_status;\n\t}\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    // set height and row of new window to full height\n\t    wp->w_winrow = tabline_height();\n\t    win_new_height(wp, curfrp->fr_height - (p_ls > 0)\n\t\t\t\t\t\t\t  - WINBAR_HEIGHT(wp));\n\t    wp->w_status_height = (p_ls > 0);\n\t}\n\telse\n\t{\n\t    // height and row of new window is same as current window\n\t    wp->w_winrow = oldwin->w_winrow;\n\t    win_new_height(wp, VISIBLE_HEIGHT(oldwin));\n\t    wp->w_status_height = oldwin->w_status_height;\n\t}\n\tfrp->fr_height = curfrp->fr_height;\n\n\t// \"new_size\" of the current window goes to the new window, use\n\t// one column for the vertical separator\n\twin_new_width(wp, new_size);\n\tif (before)\n\t    wp->w_vsep_width = 1;\n\telse\n\t{\n\t    wp->w_vsep_width = oldwin->w_vsep_width;\n\t    oldwin->w_vsep_width = 1;\n\t}\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    if (flags & WSP_BOT)\n\t\tframe_add_vsep(curfrp);\n\t    // Set width of neighbor frame\n\t    frame_new_width(curfrp, curfrp->fr_width\n\t\t     - (new_size + ((flags & WSP_TOP) != 0)), flags & WSP_TOP,\n\t\t\t\t\t\t\t\t       FALSE);\n\t}\n\telse\n\t    win_new_width(oldwin, oldwin->w_width - (new_size + 1));\n\tif (before)\t// new window left of current one\n\t{\n\t    wp->w_wincol = oldwin->w_wincol;\n\t    oldwin->w_wincol += new_size + 1;\n\t}\n\telse\t\t// new window right of current one\n\t    wp->w_wincol = oldwin->w_wincol + oldwin->w_width + 1;\n\tframe_fix_width(oldwin);\n\tframe_fix_width(wp);\n    }\n    else\n    {\n\t// width and column of new window is same as current window\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    wp->w_wincol = 0;\n\t    win_new_width(wp, Columns);\n\t    wp->w_vsep_width = 0;\n\t}\n\telse\n\t{\n\t    wp->w_wincol = oldwin->w_wincol;\n\t    win_new_width(wp, oldwin->w_width);\n\t    wp->w_vsep_width = oldwin->w_vsep_width;\n\t}\n\tfrp->fr_width = curfrp->fr_width;\n\n\t// \"new_size\" of the current window goes to the new window, use\n\t// one row for the status line\n\twin_new_height(wp, new_size);\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    int new_fr_height = curfrp->fr_height - new_size\n\t\t\t\t\t\t\t  + WINBAR_HEIGHT(wp) ;\n\n\t    if (!((flags & WSP_BOT) && p_ls == 0))\n\t\tnew_fr_height -= STATUS_HEIGHT;\n\t    frame_new_height(curfrp, new_fr_height, flags & WSP_TOP, FALSE);\n\t}\n\telse\n\t    win_new_height(oldwin, oldwin_height - (new_size + STATUS_HEIGHT));\n\tif (before)\t// new window above current one\n\t{\n\t    wp->w_winrow = oldwin->w_winrow;\n\t    wp->w_status_height = STATUS_HEIGHT;\n\t    oldwin->w_winrow += wp->w_height + STATUS_HEIGHT;\n\t}\n\telse\t\t// new window below current one\n\t{\n\t    wp->w_winrow = oldwin->w_winrow + VISIBLE_HEIGHT(oldwin)\n\t\t\t\t\t\t\t       + STATUS_HEIGHT;\n\t    wp->w_status_height = oldwin->w_status_height;\n\t    if (!(flags & WSP_BOT))\n\t\toldwin->w_status_height = STATUS_HEIGHT;\n\t}\n\tif (flags & WSP_BOT)\n\t    frame_add_statusline(curfrp);\n\tframe_fix_height(wp);\n\tframe_fix_height(oldwin);\n    }\n\n    if (flags & (WSP_TOP | WSP_BOT))\n\t(void)win_comp_pos();\n\n     // Both windows need redrawing.  Update all status lines, in case they\n     // show something related to the window count or position.\n    redraw_win_later(wp, UPD_NOT_VALID);\n    redraw_win_later(oldwin, UPD_NOT_VALID);\n    status_redraw_all();\n\n    if (need_status)\n    {\n\tmsg_row = Rows - 1;\n\tmsg_col = sc_col;\n\tmsg_clr_eos_force();\t// Old command/ruler may still be there\n\tcomp_col();\n\tmsg_row = Rows - 1;\n\tmsg_col = 0;\t// put position back at start of line\n    }\n\n    /*\n     * equalize the window sizes.\n     */\n    if (do_equal || dir != 0)\n\twin_equal(wp, TRUE,\n\t\t(flags & WSP_VERT) ? (dir == 'v' ? 'b' : 'h')\n\t\t: dir == 'h' ? 'b' : 'v');\n\n    // Don't change the window height/width to 'winheight' / 'winwidth' if a\n    // size was given.\n    if (flags & WSP_VERT)\n    {\n\ti = p_wiw;\n\tif (size != 0)\n\t    p_wiw = size;\n\n# ifdef FEAT_GUI\n\t// When 'guioptions' includes 'L' or 'R' may have to add scrollbars.\n\tif (gui.in_use)\n\t    gui_init_which_components(NULL);\n# endif\n    }\n    else\n    {\n\ti = p_wh;\n\tif (size != 0)\n\t    p_wh = size;\n    }\n\n    /*\n     * make the new window the current window\n     */\n    (void)win_enter_ext(wp, WEE_TRIGGER_NEW_AUTOCMDS\n\t\t    | WEE_TRIGGER_ENTER_AUTOCMDS | WEE_TRIGGER_LEAVE_AUTOCMDS);\n    if (flags & WSP_VERT)\n\tp_wiw = i;\n    else\n\tp_wh = i;\n\n    return OK;\n}\n\n// ENC_LATIN9 from src/vim.h:\n#define ENC_LATIN9\t0x400\t    // Latin9 /* <=== src/vim.h:2389:2389:ENC_LATIN9:0 */ \n\n// FDO_SEARCH from src/option.h:\n# define FDO_SEARCH\t\t0x040 /* <=== src/option.h:583:583:FDO_SEARCH:0 */ \n\n// TAG_INS_COMP from src/vim.h:\n<empty>\n\n// dict_alloc_id from src/dict.c:\ndict_T *\ndict_alloc_id(alloc_id_T id UNUSED)\n{\n#ifdef FEAT_EVAL\n    if (alloc_fail_id == id && alloc_does_fail(sizeof(list_T)))\n\treturn NULL;\n#endif\n    return (dict_alloc());\n}\n"
  },
  {
    "repository": "linux-2.6",
    "cve_id": "CVE-2008-4934",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "649f1ee6c705aab644035a7998d7b574193a598a",
    "short_hash": "649f1ee6",
    "vulnerableMethods_before": [
      {
        "filename": "None",
        "method_name": "vulnerable_function",
        "raw_code": "int hfsplus_block_allocate(struct super_block *sb, u32 size, u32 offset, u32 *max)\n{\n\tstruct page *page;\n\tstruct address_space *mapping;\n\t__be32 *pptr, *curr, *end;\n\tu32 mask, start, len, n;\n\t__be32 val;\n\tint i;\n\n\tlen = *max;\n\tif (!len)\n\t\treturn size;\n\n\tdprint(DBG_BITMAP, \"block_allocate: %u,%u,%u\\n\", size, offset, len);\n\tmutex_lock(&HFSPLUS_SB(sb).alloc_file->i_mutex);\n\tmapping = HFSPLUS_SB(sb).alloc_file->i_mapping;\n\tpage = read_mapping_page(mapping, offset / PAGE_CACHE_BITS, NULL);\n\tpptr = kmap(page);\n\tcurr = pptr + (offset & (PAGE_CACHE_BITS - 1)) / 32;\n\ti = offset % 32;\n\toffset &= ~(PAGE_CACHE_BITS - 1);\n\tif ((size ^ offset) / PAGE_CACHE_BITS)\n\t\tend = pptr + PAGE_CACHE_BITS / 32;\n\telse\n\t\tend = pptr + ((size + 31) & (PAGE_CACHE_BITS - 1)) / 32;\n\n\t/* scan the first partial u32 for zero bits */\n\tval = *curr;\n\tif (~val) {\n\t\tn = be32_to_cpu(val);\n\t\tmask = (1U << 31) >> i;\n\t\tfor (; i < 32; mask >>= 1, i++) {\n\t\t\tif (!(n & mask))\n\t\t\t\tgoto found;\n\t\t}\n\t}\n\tcurr++;\n\n\t/* scan complete u32s for the first zero bit */\n\twhile (1) {\n\t\twhile (curr < end) {\n\t\t\tval = *curr;\n\t\t\tif (~val) {\n\t\t\t\tn = be32_to_cpu(val);\n\t\t\t\tmask = 1 << 31;\n\t\t\t\tfor (i = 0; i < 32; mask >>= 1, i++) {\n\t\t\t\t\tif (!(n & mask))\n\t\t\t\t\t\tgoto found;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurr++;\n\t\t}\n\t\tkunmap(page);\n\t\toffset += PAGE_CACHE_BITS;\n\t\tif (offset >= size)\n\t\t\tbreak;\n\t\tpage = read_mapping_page(mapping, offset / PAGE_CACHE_BITS,\n\t\t\t\t\t NULL);\n\t\tcurr = pptr = kmap(page);\n\t\tif ((size ^ offset) / PAGE_CACHE_BITS)\n\t\t\tend = pptr + PAGE_CACHE_BITS / 32;\n\t\telse\n\t\t\tend = pptr + ((size + 31) & (PAGE_CACHE_BITS - 1)) / 32;\n\t}\n\tdprint(DBG_BITMAP, \"bitmap full\\n\");\n\tstart = size;\n\tgoto out;\n\nfound:\n\tstart = offset + (curr - pptr) * 32 + i;\n\tif (start >= size) {\n\t\tdprint(DBG_BITMAP, \"bitmap full\\n\");\n\t\tgoto out;\n\t}\n\t/* do any partial u32 at the start */\n\tlen = min(size - start, len);\n\twhile (1) {\n\t\tn |= mask;\n\t\tif (++i >= 32)\n\t\t\tbreak;\n\t\tmask >>= 1;\n\t\tif (!--len || n & mask)\n\t\t\tgoto done;\n\t}\n\tif (!--len)\n\t\tgoto done;\n\t*curr++ = cpu_to_be32(n);\n\t/* do full u32s */\n\twhile (1) {\n\t\twhile (curr < end) {\n\t\t\tn = be32_to_cpu(*curr);\n\t\t\tif (len < 32)\n\t\t\t\tgoto last;\n\t\t\tif (n) {\n\t\t\t\tlen = 32;\n\t\t\t\tgoto last;\n\t\t\t}\n\t\t\t*curr++ = cpu_to_be32(0xffffffff);\n\t\t\tlen -= 32;\n\t\t}\n\t\tset_page_dirty(page);\n\t\tkunmap(page);\n\t\toffset += PAGE_CACHE_BITS;\n\t\tpage = read_mapping_page(mapping, offset / PAGE_CACHE_BITS,\n\t\t\t\t\t NULL);\n\t\tpptr = kmap(page);\n\t\tcurr = pptr;\n\t\tend = pptr + PAGE_CACHE_BITS / 32;\n\t}\nlast:\n\t/* do any partial u32 at end */\n\tmask = 1U << 31;\n\tfor (i = 0; i < len; i++) {\n\t\tif (n & mask)\n\t\t\tbreak;\n\t\tn |= mask;\n\t\tmask >>= 1;\n\t}\ndone:\n\t*curr = cpu_to_be32(n);\n\tset_page_dirty(page);\n\tkunmap(page);\n\t*max = offset + (curr - pptr) * 32 + i - start;\n\tHFSPLUS_SB(sb).free_blocks -= *max;\n\tsb->s_dirt = 1;\n\tdprint(DBG_BITMAP, \"-> %u,%u\\n\", start, *max);\nout:\n\tmutex_unlock(&HFSPLUS_SB(sb).alloc_file->i_mutex);\n\treturn start;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "None",
        "method_name": "fixed_function",
        "raw_code": "int hfsplus_block_allocate(struct super_block *sb, u32 size, u32 offset, u32 *max)\n{\n\tstruct page *page;\n\tstruct address_space *mapping;\n\t__be32 *pptr, *curr, *end;\n\tu32 mask, start, len, n;\n\t__be32 val;\n\tint i;\n\n\tlen = *max;\n\tif (!len)\n\t\treturn size;\n\n\tdprint(DBG_BITMAP, \"block_allocate: %u,%u,%u\\n\", size, offset, len);\n\tmutex_lock(&HFSPLUS_SB(sb).alloc_file->i_mutex);\n\tmapping = HFSPLUS_SB(sb).alloc_file->i_mapping;\n\tpage = read_mapping_page(mapping, offset / PAGE_CACHE_BITS, NULL);\n\tif (IS_ERR(page)) {\n\t\tstart = size;\n\t\tgoto out;\n\t}\n\tpptr = kmap(page);\n\tcurr = pptr + (offset & (PAGE_CACHE_BITS - 1)) / 32;\n\ti = offset % 32;\n\toffset &= ~(PAGE_CACHE_BITS - 1);\n\tif ((size ^ offset) / PAGE_CACHE_BITS)\n\t\tend = pptr + PAGE_CACHE_BITS / 32;\n\telse\n\t\tend = pptr + ((size + 31) & (PAGE_CACHE_BITS - 1)) / 32;\n\n\t/* scan the first partial u32 for zero bits */\n\tval = *curr;\n\tif (~val) {\n\t\tn = be32_to_cpu(val);\n\t\tmask = (1U << 31) >> i;\n\t\tfor (; i < 32; mask >>= 1, i++) {\n\t\t\tif (!(n & mask))\n\t\t\t\tgoto found;\n\t\t}\n\t}\n\tcurr++;\n\n\t/* scan complete u32s for the first zero bit */\n\twhile (1) {\n\t\twhile (curr < end) {\n\t\t\tval = *curr;\n\t\t\tif (~val) {\n\t\t\t\tn = be32_to_cpu(val);\n\t\t\t\tmask = 1 << 31;\n\t\t\t\tfor (i = 0; i < 32; mask >>= 1, i++) {\n\t\t\t\t\tif (!(n & mask))\n\t\t\t\t\t\tgoto found;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurr++;\n\t\t}\n\t\tkunmap(page);\n\t\toffset += PAGE_CACHE_BITS;\n\t\tif (offset >= size)\n\t\t\tbreak;\n\t\tpage = read_mapping_page(mapping, offset / PAGE_CACHE_BITS,\n\t\t\t\t\t NULL);\n\t\tif (IS_ERR(page)) {\n\t\t\tstart = size;\n\t\t\tgoto out;\n\t\t}\n\t\tcurr = pptr = kmap(page);\n\t\tif ((size ^ offset) / PAGE_CACHE_BITS)\n\t\t\tend = pptr + PAGE_CACHE_BITS / 32;\n\t\telse\n\t\t\tend = pptr + ((size + 31) & (PAGE_CACHE_BITS - 1)) / 32;\n\t}\n\tdprint(DBG_BITMAP, \"bitmap full\\n\");\n\tstart = size;\n\tgoto out;\n\nfound:\n\tstart = offset + (curr - pptr) * 32 + i;\n\tif (start >= size) {\n\t\tdprint(DBG_BITMAP, \"bitmap full\\n\");\n\t\tgoto out;\n\t}\n\t/* do any partial u32 at the start */\n\tlen = min(size - start, len);\n\twhile (1) {\n\t\tn |= mask;\n\t\tif (++i >= 32)\n\t\t\tbreak;\n\t\tmask >>= 1;\n\t\tif (!--len || n & mask)\n\t\t\tgoto done;\n\t}\n\tif (!--len)\n\t\tgoto done;\n\t*curr++ = cpu_to_be32(n);\n\t/* do full u32s */\n\twhile (1) {\n\t\twhile (curr < end) {\n\t\t\tn = be32_to_cpu(*curr);\n\t\t\tif (len < 32)\n\t\t\t\tgoto last;\n\t\t\tif (n) {\n\t\t\t\tlen = 32;\n\t\t\t\tgoto last;\n\t\t\t}\n\t\t\t*curr++ = cpu_to_be32(0xffffffff);\n\t\t\tlen -= 32;\n\t\t}\n\t\tset_page_dirty(page);\n\t\tkunmap(page);\n\t\toffset += PAGE_CACHE_BITS;\n\t\tpage = read_mapping_page(mapping, offset / PAGE_CACHE_BITS,\n\t\t\t\t\t NULL);\n\t\tif (IS_ERR(page)) {\n\t\t\tstart = size;\n\t\t\tgoto out;\n\t\t}\n\t\tpptr = kmap(page);\n\t\tcurr = pptr;\n\t\tend = pptr + PAGE_CACHE_BITS / 32;\n\t}\nlast:\n\t/* do any partial u32 at end */\n\tmask = 1U << 31;\n\tfor (i = 0; i < len; i++) {\n\t\tif (n & mask)\n\t\t\tbreak;\n\t\tn |= mask;\n\t\tmask >>= 1;\n\t}\ndone:\n\t*curr = cpu_to_be32(n);\n\tset_page_dirty(page);\n\tkunmap(page);\n\t*max = offset + (curr - pptr) * 32 + i - start;\n\tHFSPLUS_SB(sb).free_blocks -= *max;\n\tsb->s_dirt = 1;\n\tdprint(DBG_BITMAP, \"-> %u,%u\\n\", start, *max);\nout:\n\tmutex_unlock(&HFSPLUS_SB(sb).alloc_file->i_mutex);\n\treturn start;\n}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "rsyslog",
    "cve_id": "CVE-2018-16881",
    "cwe_list": [
      "CWE-190"
    ],
    "commit_hash": "0381a0de64a5a048c3d48b79055bd9848d0c7fc2",
    "short_hash": "0381a0de",
    "vulnerableMethods_before": [
      {
        "filename": "imptcp.c",
        "method_name": "vulnerable_function",
        "raw_code": "processDataRcvd(ptcpsess_t *const __restrict__ pThis,\n\tchar **buff,\n\tconst int buffLen,\n\tstruct syslogTime *stTime,\n\tconst time_t ttGenTime,\n\tmulti_submit_t *pMultiSub,\n\tunsigned *const __restrict__ pnMsgs)\n{\n\tDEFiRet;\n\tchar c = **buff;\n\tint octatesToCopy, octatesToDiscard;\n\n\tif(pThis->inputState == eAtStrtFram) {\n\t\tif(pThis->bSuppOctetFram && isdigit((int) c)) {\n\t\t\tpThis->inputState = eInOctetCnt;\n\t\t\tpThis->iOctetsRemain = 0;\n\t\t\tpThis->eFraming = TCP_FRAMING_OCTET_COUNTING;\n\t\t} else if(pThis->bSPFramingFix && c == ' ') {\n\t\t\t/* Cisco very occasionally sends a SP after a LF, which\n\t\t\t * thrashes framing if not taken special care of. Here,\n\t\t\t * we permit space *in front of the next frame* and\n\t\t\t * ignore it.\n\t\t\t */\n\t\t\t FINALIZE;\n\t\t} else {\n\t\t\tpThis->inputState = eInMsg;\n\t\t\tpThis->eFraming = TCP_FRAMING_OCTET_STUFFING;\n\t\t}\n\t}\n\n\tif(pThis->inputState == eInOctetCnt) {\n\t\tif(isdigit(c)) {\n\t\t\tpThis->iOctetsRemain = pThis->iOctetsRemain * 10 + c - '0';\n\t\t} else { /* done with the octet count, so this must be the SP terminator */\n\t\t\tDBGPRINTF(\"TCP Message with octet-counter, size %d.\\n\", pThis->iOctetsRemain);\n\t\t\tif(c != ' ') {\n\t\t\t\terrmsg.LogError(0, NO_ERRCODE, \"Framing Error in received TCP message: \"\n\t\t\t\t\t    \"delimiter is not SP but has ASCII value %d.\", c);\n\t\t\t}\n\t\t\tif(pThis->iOctetsRemain < 1) {\n\t\t\t\t/* TODO: handle the case where the octet count is 0! */\n\t\t\t\tDBGPRINTF(\"Framing Error: invalid octet count\\n\");\n\t\t\t\terrmsg.LogError(0, NO_ERRCODE, \"Framing Error in received TCP message: \"\n\t\t\t\t\t    \"invalid octet count %d.\", pThis->iOctetsRemain);\n\t\t\t} else if(pThis->iOctetsRemain > iMaxLine) {\n\t\t\t\t/* while we can not do anything against it, we can at least log an indication\n\t\t\t\t * that something went wrong) -- rgerhards, 2008-03-14\n\t\t\t\t */\n\t\t\t\tDBGPRINTF(\"truncating message with %d octets - max msg size is %d\\n\",\n\t\t\t\t\t  pThis->iOctetsRemain, iMaxLine);\n\t\t\t\terrmsg.LogError(0, NO_ERRCODE, \"received oversize message: size is %d bytes, \"\n\t\t\t\t\t        \"max msg size is %d, truncating...\", pThis->iOctetsRemain, iMaxLine);\n\t\t\t}\n\t\t\tpThis->inputState = eInMsg;\n\t\t}\n\t} else {\n\t\tassert(pThis->inputState == eInMsg);\n\n\t\tif (pThis->eFraming == TCP_FRAMING_OCTET_STUFFING) {\n\t\t\tif(pThis->iMsg >= iMaxLine) {\n\t\t\t\t/* emergency, we now need to flush, no matter if we are at end of message or not... */\n\t\t\t\tint i = 1;\n\t\t\t\tchar currBuffChar;\n\t\t\t\twhile(i < buffLen && ((currBuffChar = (*buff)[i]) != '\\n'\n\t\t\t\t\t&& (pThis->pLstn->pSrv->iAddtlFrameDelim == TCPSRV_NO_ADDTL_DELIMITER\n\t\t\t\t\t\t|| currBuffChar != pThis->pLstn->pSrv->iAddtlFrameDelim))) {\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tLogError(0, NO_ERRCODE, \"error: message received is at least %d byte larger than max msg\"\n\t\t\t\t\t\" size; message will be split starting at: \\\"%.*s\\\"\\n\", i, (i < 32) ? i : 32, *buff);\n\t\t\t\tdoSubmitMsg(pThis, stTime, ttGenTime, pMultiSub);\n\t\t\t\t++(*pnMsgs);\n\t\t\t\t/* we might think if it is better to ignore the rest of the\n\t\t\t\t * message than to treat it as a new one. Maybe this is a good\n\t\t\t\t * candidate for a configuration parameter...\n\t\t\t\t * rgerhards, 2006-12-04\n\t\t\t\t */\n\t\t\t}\n\n\t\t\tif ((c == '\\n')\n\t\t\t\t   || ((pThis->pLstn->pSrv->iAddtlFrameDelim != TCPSRV_NO_ADDTL_DELIMITER)\n\t\t\t\t\t   && (c == pThis->pLstn->pSrv->iAddtlFrameDelim))\n\t\t\t\t   ) { /* record delimiter? */\n\t\t\t\tdoSubmitMsg(pThis, stTime, ttGenTime, pMultiSub);\n\t\t\t\t++(*pnMsgs);\n\t\t\t\tpThis->inputState = eAtStrtFram;\n\t\t\t} else {\n\t\t\t\t/* IMPORTANT: here we copy the actual frame content to the message - for BOTH framing modes!\n\t\t\t\t * If we have a message that is larger than the max msg size, we truncate it. This is the best\n\t\t\t\t * we can do in light of what the engine supports. -- rgerhards, 2008-03-14\n\t\t\t\t */\n\t\t\t\tif(pThis->iMsg < iMaxLine) {\n\t\t\t\t\t*(pThis->pMsg + pThis->iMsg++) = c;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tassert(pThis->eFraming == TCP_FRAMING_OCTET_COUNTING);\n\t\t\toctatesToCopy = pThis->iOctetsRemain;\n\t\t\toctatesToDiscard = 0;\n\t\t\tif (buffLen < octatesToCopy) {\n\t\t\t\toctatesToCopy = buffLen;\n\t\t\t}\n\t\t\tif (octatesToCopy + pThis->iMsg > iMaxLine) {\n\t\t\t\toctatesToDiscard = octatesToCopy - (iMaxLine - pThis->iMsg);\n\t\t\t\toctatesToCopy = iMaxLine - pThis->iMsg;\n\t\t\t}\n\n\t\t\tmemcpy(pThis->pMsg + pThis->iMsg, *buff, octatesToCopy);\n\t\t\tpThis->iMsg += octatesToCopy;\n\t\t\tpThis->iOctetsRemain -= (octatesToCopy + octatesToDiscard);\n\t\t\t*buff += (octatesToCopy + octatesToDiscard - 1);\n\t\t\tif (pThis->iOctetsRemain == 0) {\n\t\t\t\t/* we have end of frame! */\n\t\t\t\tdoSubmitMsg(pThis, stTime, ttGenTime, pMultiSub);\n\t\t\t\t++(*pnMsgs);\n\t\t\t\tpThis->inputState = eAtStrtFram;\n\t\t\t}\n\t\t}\n\n\t}\n\nfinalize_it:\n\tRETiRet;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "imptcp.c",
        "method_name": "fixed_function",
        "raw_code": "processDataRcvd(ptcpsess_t *const __restrict__ pThis,\n\tchar **buff,\n\tconst int buffLen,\n\tstruct syslogTime *stTime,\n\tconst time_t ttGenTime,\n\tmulti_submit_t *pMultiSub,\n\tunsigned *const __restrict__ pnMsgs)\n{\n\tDEFiRet;\n\tchar c = **buff;\n\tint octatesToCopy, octatesToDiscard;\n\n\tif(pThis->inputState == eAtStrtFram) {\n\t\tif(pThis->bSuppOctetFram && isdigit((int) c)) {\n\t\t\tpThis->inputState = eInOctetCnt;\n\t\t\tpThis->iOctetsRemain = 0;\n\t\t\tpThis->eFraming = TCP_FRAMING_OCTET_COUNTING;\n\t\t} else if(pThis->bSPFramingFix && c == ' ') {\n\t\t\t/* Cisco very occasionally sends a SP after a LF, which\n\t\t\t * thrashes framing if not taken special care of. Here,\n\t\t\t * we permit space *in front of the next frame* and\n\t\t\t * ignore it.\n\t\t\t */\n\t\t\t FINALIZE;\n\t\t} else {\n\t\t\tpThis->inputState = eInMsg;\n\t\t\tpThis->eFraming = TCP_FRAMING_OCTET_STUFFING;\n\t\t}\n\t}\n\n\tif(pThis->inputState == eInOctetCnt) {\n\t\tif(isdigit(c)) {\n\t\t\tif(pThis->iOctetsRemain <= 200000000) {\n\t\t\t\tpThis->iOctetsRemain = pThis->iOctetsRemain * 10 + c - '0';\n\t\t\t} else {\n\t\t\t\terrmsg.LogError(0, NO_ERRCODE, \"Framing Error in received TCP message: \"\n\t\t\t\t\t\t\"frame too large (at least %d%c), change to octet stuffing\",\n\t\t\t\t\t\tpThis->iOctetsRemain, c);\n\t\t\t\tpThis->eFraming = TCP_FRAMING_OCTET_STUFFING;\n\t\t\t\tpThis->inputState = eInMsg;\n\t\t\t}\n\t\t\t*(pThis->pMsg + pThis->iMsg++) = c;\n\t\t} else { /* done with the octet count, so this must be the SP terminator */\n\t\t\tDBGPRINTF(\"TCP Message with octet-counter, size %d.\\n\", pThis->iOctetsRemain);\n\t\t\tif(c != ' ') {\n\t\t\t\terrmsg.LogError(0, NO_ERRCODE, \"Framing Error in received TCP message: \"\n\t\t\t\t\t    \"delimiter is not SP but has ASCII value %d.\", c);\n\t\t\t}\n\t\t\tif(pThis->iOctetsRemain < 1) {\n\t\t\t\t/* TODO: handle the case where the octet count is 0! */\n\t\t\t\terrmsg.LogError(0, NO_ERRCODE, \"Framing Error in received TCP message: \"\n\t\t\t\t\t    \"invalid octet count %d.\", pThis->iOctetsRemain);\n\t\t\t\tpThis->eFraming = TCP_FRAMING_OCTET_STUFFING;\n\t\t\t} else if(pThis->iOctetsRemain > iMaxLine) {\n\t\t\t\t/* while we can not do anything against it, we can at least log an indication\n\t\t\t\t * that something went wrong) -- rgerhards, 2008-03-14\n\t\t\t\t */\n\t\t\t\tDBGPRINTF(\"truncating message with %d octets - max msg size is %d\\n\",\n\t\t\t\t\t  pThis->iOctetsRemain, iMaxLine);\n\t\t\t\terrmsg.LogError(0, NO_ERRCODE, \"received oversize message: size is %d bytes, \"\n\t\t\t\t\t        \"max msg size is %d, truncating...\", pThis->iOctetsRemain, iMaxLine);\n\t\t\t}\n\t\t\tpThis->inputState = eInMsg;\n\t\t\tpThis->iMsg = 0;\n\t\t}\n\t} else {\n\t\tassert(pThis->inputState == eInMsg);\n\n\t\tif (pThis->eFraming == TCP_FRAMING_OCTET_STUFFING) {\n\t\t\tif(pThis->iMsg >= iMaxLine) {\n\t\t\t\t/* emergency, we now need to flush, no matter if we are at end of message or not... */\n\t\t\t\tint i = 1;\n\t\t\t\tchar currBuffChar;\n\t\t\t\twhile(i < buffLen && ((currBuffChar = (*buff)[i]) != '\\n'\n\t\t\t\t\t&& (pThis->pLstn->pSrv->iAddtlFrameDelim == TCPSRV_NO_ADDTL_DELIMITER\n\t\t\t\t\t\t|| currBuffChar != pThis->pLstn->pSrv->iAddtlFrameDelim))) {\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tLogError(0, NO_ERRCODE, \"error: message received is at least %d byte larger than max msg\"\n\t\t\t\t\t\" size; message will be split starting at: \\\"%.*s\\\"\\n\", i, (i < 32) ? i : 32, *buff);\n\t\t\t\tdoSubmitMsg(pThis, stTime, ttGenTime, pMultiSub);\n\t\t\t\t++(*pnMsgs);\n\t\t\t\t/* we might think if it is better to ignore the rest of the\n\t\t\t\t * message than to treat it as a new one. Maybe this is a good\n\t\t\t\t * candidate for a configuration parameter...\n\t\t\t\t * rgerhards, 2006-12-04\n\t\t\t\t */\n\t\t\t}\n\n\t\t\tif ((c == '\\n')\n\t\t\t\t   || ((pThis->pLstn->pSrv->iAddtlFrameDelim != TCPSRV_NO_ADDTL_DELIMITER)\n\t\t\t\t\t   && (c == pThis->pLstn->pSrv->iAddtlFrameDelim))\n\t\t\t\t   ) { /* record delimiter? */\n\t\t\t\tdoSubmitMsg(pThis, stTime, ttGenTime, pMultiSub);\n\t\t\t\t++(*pnMsgs);\n\t\t\t\tpThis->inputState = eAtStrtFram;\n\t\t\t} else {\n\t\t\t\t/* IMPORTANT: here we copy the actual frame content to the message - for BOTH framing modes!\n\t\t\t\t * If we have a message that is larger than the max msg size, we truncate it. This is the best\n\t\t\t\t * we can do in light of what the engine supports. -- rgerhards, 2008-03-14\n\t\t\t\t */\n\t\t\t\tif(pThis->iMsg < iMaxLine) {\n\t\t\t\t\t*(pThis->pMsg + pThis->iMsg++) = c;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tassert(pThis->eFraming == TCP_FRAMING_OCTET_COUNTING);\n\t\t\toctatesToCopy = pThis->iOctetsRemain;\n\t\t\toctatesToDiscard = 0;\n\t\t\tif (buffLen < octatesToCopy) {\n\t\t\t\toctatesToCopy = buffLen;\n\t\t\t}\n\t\t\tif (octatesToCopy + pThis->iMsg > iMaxLine) {\n\t\t\t\toctatesToDiscard = octatesToCopy - (iMaxLine - pThis->iMsg);\n\t\t\t\toctatesToCopy = iMaxLine - pThis->iMsg;\n\t\t\t}\n\n\t\t\tmemcpy(pThis->pMsg + pThis->iMsg, *buff, octatesToCopy);\n\t\t\tpThis->iMsg += octatesToCopy;\n\t\t\tpThis->iOctetsRemain -= (octatesToCopy + octatesToDiscard);\n\t\t\t*buff += (octatesToCopy + octatesToDiscard - 1);\n\t\t\tif (pThis->iOctetsRemain == 0) {\n\t\t\t\t/* we have end of frame! */\n\t\t\t\tdoSubmitMsg(pThis, stTime, ttGenTime, pMultiSub);\n\t\t\t\t++(*pnMsgs);\n\t\t\t\tpThis->inputState = eAtStrtFram;\n\t\t\t}\n\t\t}\n\n\t}\n\nfinalize_it:\n\tRETiRet;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"config.h\"\n#include \"net.h\"\n#include <sys/stat.h>\n#include \"rsyslog.h\"\n#include <netinet/tcp.h>\n#include <stdarg.h>\n#include \"ruleset.h\"\n#include <sys/socket.h>\n#include \"datetime.h\"\n#include \"errmsg.h\"\n#include <stdlib.h>\n#include <stdint.h>\n#include <sys/queue.h>\n#include \"statsobj.h\"\n#include \"dirty.h\"\n#include \"unicode-helper.h\"\n#include \"im-helper.h\"\n#include <ctype.h>\n#include <netinet/in.h>\n#include <sys/epoll.h>\n#include \"glbl.h\"\n#include <zlib.h>\n#include \"srUtils.h\"\n#include <sys/un.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"prop.h\"\n#include <sys/types.h>\n#include <fcntl.h>\n#include <assert.h>\n#include \"ratelimit.h\"\n#include <stdio.h>\n#include \"module-template.h\"\n#include <unistd.h>\n#include \"cfsysline.h\"\n#include <string.h>\n#include \"msg.h\"\n\n// Type Definitions:\n// ptcpsess_t:\ntypedef struct ptcpsess_s ptcpsess_t;\n\n// rsRetVal:\ntypedef enum rsRetVal_ rsRetVal;\n\n// Called Methods (top 10):\n// DBGPRINTF from plugins/imptcp/debug.h:\n<empty>\n\n// NO_ERRCODE from plugins/imptcp/datetime.h:\n<empty>\n\n// FINALIZE from plugins/imptcp/rsyslog.h:\n<empty>\n\n// dbgprintf from grammar/testdriver.c:\nvoid\ndbgprintf(char *fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tvfprintf(stdout, fmt, ap);\n\tva_end(ap);\n}\n"
  },
  {
    "repository": "tensorflow",
    "cve_id": "CVE-2021-41219",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "e6cf28c72ba2eb949ca950d834dd6d66bb01cfae",
    "short_hash": "e6cf28c7",
    "vulnerableMethods_before": [
      {
        "filename": "sparse_matmul_op.cc",
        "method_name": "vulnerable_function",
        "raw_code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& a = ctx->input(0);\n    const Tensor& b = ctx->input(1);\n    OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(a.shape()),\n                errors::InvalidArgument(\"a is not a matrix\"));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(b.shape()),\n                errors::InvalidArgument(\"b is not a matrix\"));\n\n    const int m = transpose_a_ ? a.dim_size(1) : a.dim_size(0);\n    const int k = transpose_a_ ? a.dim_size(0) : a.dim_size(1);\n    const int n = transpose_b_ ? b.dim_size(0) : b.dim_size(1);\n    const int k2 = transpose_b_ ? b.dim_size(1) : b.dim_size(0);\n\n    OP_REQUIRES(ctx, k == k2,\n                errors::InvalidArgument(\n                    \"Matrix size incompatible: a: \", a.shape().DebugString(),\n                    \", b: \", b.shape().DebugString()));\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({m, n}), &output));\n\n    if (k == 0) {\n      // If the inner dimension k in the matrix multiplication is zero, we fill\n      // the output with zeros.\n      functor::SetZeroFunctor<CPUDevice, float> f;\n      f(ctx->eigen_device<CPUDevice>(), output->flat<float>());\n      return;\n    }\n\n    auto out = output->matrix<float>();\n\n    std::unique_ptr<Tensor> a_float;\n    std::unique_ptr<Tensor> b_float;\n    if (!a_is_sparse_ && !b_is_sparse_) {\n      auto left = &a;\n      auto right = &b;\n      // TODO(agarwal): multi-thread the conversions from bfloat16 to float.\n      if (std::is_same<TL, bfloat16>::value) {\n        a_float.reset(new Tensor(DT_FLOAT, a.shape()));\n        BFloat16ToFloat(a.flat<bfloat16>().data(),\n                        a_float->flat<float>().data(), a.NumElements());\n        left = a_float.get();\n      }\n      if (std::is_same<TR, bfloat16>::value) {\n        b_float.reset(new Tensor(DT_FLOAT, b.shape()));\n        BFloat16ToFloat(b.flat<bfloat16>().data(),\n                        b_float->flat<float>().data(), b.NumElements());\n        right = b_float.get();\n      }\n      Eigen::array<Eigen::IndexPair<Eigen::DenseIndex>, 1> dim_pair;\n      dim_pair[0].first = transpose_a_ ? 0 : 1;\n      dim_pair[0].second = transpose_b_ ? 1 : 0;\n\n      out.device(ctx->template eigen_device<CPUDevice>()) =\n          left->matrix<float>().contract(right->matrix<float>(), dim_pair);\n      return;\n    }\n\n    auto left = &a;\n    auto right = &b;\n    bool transpose_output = false;\n    bool transpose_a = transpose_a_;\n    bool transpose_b = transpose_b_;\n    if (!a_is_sparse_) {\n      // Swap the order of multiplications using the identity:\n      // A * B = (B' *  A')'.\n      std::swap(left, right);\n      std::swap(transpose_a, transpose_b);\n      transpose_a = !transpose_a;\n      transpose_b = !transpose_b;\n      transpose_output = !transpose_output;\n    }\n\n    std::unique_ptr<Tensor> right_tr;\n    if (transpose_b) {\n      // TODO(agarwal): avoid transposing the matrix here and directly handle\n      // transpose in CreateDenseSlices.\n      OP_REQUIRES(ctx, right->dim_size(0) != 0,\n                  errors::InvalidArgument(\"b has an entry 0 in it's shape.\"));\n      OP_REQUIRES(ctx, right->dim_size(1) != 0,\n                  errors::InvalidArgument(\"b has an entry 0 in it's shape.\"));\n      right_tr.reset(\n          new Tensor(right->dtype(),\n                     TensorShape({right->dim_size(1), right->dim_size(0)})));\n\n      const auto perm = dsizes_10();\n      if (transpose_output) {\n        right_tr->matrix<TL>().device(ctx->template eigen_device<CPUDevice>()) =\n            right->matrix<TL>().shuffle(perm);\n      } else {\n        right_tr->matrix<TR>().device(ctx->template eigen_device<CPUDevice>()) =\n            right->matrix<TR>().shuffle(perm);\n      }\n      right = right_tr.get();\n    }\n\n    if (transpose_output) {\n      DoMatMul<TR, TL>::Compute(&this->cache_tr_, left->matrix<TR>(),\n                                right->matrix<TL>(), transpose_a,\n                                ctx->device()->tensorflow_cpu_worker_threads(),\n                                transpose_output, &out);\n    } else {\n      DoMatMul<TL, TR>::Compute(&this->cache_nt_, left->matrix<TL>(),\n                                right->matrix<TR>(), transpose_a,\n                                ctx->device()->tensorflow_cpu_worker_threads(),\n                                transpose_output, &out);\n    }\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "sparse_matmul_op.cc",
        "method_name": "fixed_function",
        "raw_code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& a = ctx->input(0);\n    const Tensor& b = ctx->input(1);\n    OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(a.shape()),\n                errors::InvalidArgument(\"a is not a matrix\"));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(b.shape()),\n                errors::InvalidArgument(\"b is not a matrix\"));\n\n    const int m = transpose_a_ ? a.dim_size(1) : a.dim_size(0);\n    const int k = transpose_a_ ? a.dim_size(0) : a.dim_size(1);\n    const int n = transpose_b_ ? b.dim_size(0) : b.dim_size(1);\n    const int k2 = transpose_b_ ? b.dim_size(1) : b.dim_size(0);\n\n    OP_REQUIRES(ctx, k == k2,\n                errors::InvalidArgument(\n                    \"Matrix size incompatible: a: \", a.shape().DebugString(),\n                    \", b: \", b.shape().DebugString()));\n    OP_REQUIRES(ctx, m >= 0 && n >= 0 && k >= 0,\n                errors::InvalidArgument(\n                    \"Matrix dimensions cannot be negative: a: \",\n                    a.shape().DebugString(), \", b: \", b.shape().DebugString()));\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({m, n}), &output));\n\n    // Return early if at least one of the output dimension size is 0.\n    if (m == 0 || n == 0) {\n      return;\n    }\n\n    if (k == 0) {\n      // If the inner dimension k in the matrix multiplication is zero, we fill\n      // the output with zeros.\n      functor::SetZeroFunctor<CPUDevice, float> f;\n      f(ctx->eigen_device<CPUDevice>(), output->flat<float>());\n      return;\n    }\n\n    auto out = output->matrix<float>();\n\n    std::unique_ptr<Tensor> a_float;\n    std::unique_ptr<Tensor> b_float;\n    if (!a_is_sparse_ && !b_is_sparse_) {\n      auto left = &a;\n      auto right = &b;\n      // TODO(agarwal): multi-thread the conversions from bfloat16 to float.\n      if (std::is_same<TL, bfloat16>::value) {\n        a_float.reset(new Tensor(DT_FLOAT, a.shape()));\n        BFloat16ToFloat(a.flat<bfloat16>().data(),\n                        a_float->flat<float>().data(), a.NumElements());\n        left = a_float.get();\n      }\n      if (std::is_same<TR, bfloat16>::value) {\n        b_float.reset(new Tensor(DT_FLOAT, b.shape()));\n        BFloat16ToFloat(b.flat<bfloat16>().data(),\n                        b_float->flat<float>().data(), b.NumElements());\n        right = b_float.get();\n      }\n      Eigen::array<Eigen::IndexPair<Eigen::DenseIndex>, 1> dim_pair;\n      dim_pair[0].first = transpose_a_ ? 0 : 1;\n      dim_pair[0].second = transpose_b_ ? 1 : 0;\n\n      out.device(ctx->template eigen_device<CPUDevice>()) =\n          left->matrix<float>().contract(right->matrix<float>(), dim_pair);\n      return;\n    }\n\n    auto left = &a;\n    auto right = &b;\n    bool transpose_output = false;\n    bool transpose_a = transpose_a_;\n    bool transpose_b = transpose_b_;\n    if (!a_is_sparse_) {\n      // Swap the order of multiplications using the identity:\n      // A * B = (B' *  A')'.\n      std::swap(left, right);\n      std::swap(transpose_a, transpose_b);\n      transpose_a = !transpose_a;\n      transpose_b = !transpose_b;\n      transpose_output = !transpose_output;\n    }\n\n    std::unique_ptr<Tensor> right_tr;\n    if (transpose_b) {\n      // TODO(agarwal): avoid transposing the matrix here and directly handle\n      // transpose in CreateDenseSlices.\n      OP_REQUIRES(ctx, right->dim_size(0) != 0,\n                  errors::InvalidArgument(\"b has an entry 0 in it's shape.\"));\n      OP_REQUIRES(ctx, right->dim_size(1) != 0,\n                  errors::InvalidArgument(\"b has an entry 0 in it's shape.\"));\n      right_tr.reset(\n          new Tensor(right->dtype(),\n                     TensorShape({right->dim_size(1), right->dim_size(0)})));\n\n      const auto perm = dsizes_10();\n      if (transpose_output) {\n        right_tr->matrix<TL>().device(ctx->template eigen_device<CPUDevice>()) =\n            right->matrix<TL>().shuffle(perm);\n      } else {\n        right_tr->matrix<TR>().device(ctx->template eigen_device<CPUDevice>()) =\n            right->matrix<TR>().shuffle(perm);\n      }\n      right = right_tr.get();\n    }\n\n    if (transpose_output) {\n      DoMatMul<TR, TL>::Compute(&this->cache_tr_, left->matrix<TR>(),\n                                right->matrix<TL>(), transpose_a,\n                                ctx->device()->tensorflow_cpu_worker_threads(),\n                                transpose_output, &out);\n    } else {\n      DoMatMul<TL, TR>::Compute(&this->cache_nt_, left->matrix<TL>(),\n                                right->matrix<TR>(), transpose_a,\n                                ctx->device()->tensorflow_cpu_worker_threads(),\n                                transpose_output, &out);\n    }\n  }",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"tensorflow/core/platform/macros.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/common_runtime/device.h\"\n#include \"tensorflow/core/kernels/eigen_contraction_kernel.h\"\n#include \"include/libxsmm_spmdm.h\"\n#include \"tensorflow/core/platform/types.h\"\n#include \"tensorflow/core/kernels/sparse_matmul_op.h\"\n#include \"tensorflow/core/platform/errors.h\"\n#include \"include/libxsmm_intrinsics_x86.h\"\n#include \"tensorflow/core/lib/core/threadpool.h\"\n#include \"tensorflow/core/kernels/fill_functor.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include <map>\n#include \"tensorflow/core/framework/bfloat16.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include \"include/libxsmm_malloc.h\"\n#include \"tensorflow/core/framework/op.h\"\n#include <vector>\n#include \"tensorflow/core/platform/thread_annotations.h\"\n#include \"tensorflow/core/lib/core/blocking_counter.h\"\n#include <memory>\n#include \"tensorflow/core/platform/mutex.h\"\n\n// Type Definitions:\n// CpuWorkerThreads:\nstruct CpuWorkerThreads {\n    int num_threads = 0;\n    thread::ThreadPool* workers = nullptr;\n  }\n\n// SetZeroFunctor:\nstruct SetZeroFunctor<Eigen::ThreadPoolDevice, tstring> {\n  void operator()(const Eigen::ThreadPoolDevice& d,\n                  typename TTypes<tstring>::Flat out);\n}\n\n// SparseMatMulOp:\nclass SparseMatMulOp : public OpKernel {\n  using MatrixR = BasicMatrix<TR>;\n  using ConstMatrixMapR = BasicMatrixMap<const TR>;\n\n public:\n  explicit SparseMatMulOp(OpKernelConstruction* ctx) : OpKernel(ctx) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"transpose_a\", &transpose_a_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"transpose_b\", &transpose_b_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"a_is_sparse\", &a_is_sparse_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"b_is_sparse\", &b_is_sparse_));\n  }\n\n  void Compute(OpKernelContext* ctx) override {\n    const Tensor& a = ctx->input(0);\n    const Tensor& b = ctx->input(1);\n    OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(a.shape()),\n                errors::InvalidArgument(\"a is not a matrix\"));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(b.shape()),\n                errors::InvalidArgument(\"b is not a matrix\"));\n\n    const int m = transpose_a_ ? a.dim_size(1) : a.dim_size(0);\n    const int k = transpose_a_ ? a.dim_size(0) : a.dim_size(1);\n    const ...\n\n// Status:\nclass Status {\n public:\n  /// Create a success status.\n  Status() {}\n\n  /// \\brief Create a status with the specified error code and msg as a\n  /// human-readable string containing more detailed information.\n  Status(tensorflow::error::Code code, tensorflow::StringPiece msg)\n      : Status(code, msg, {}) {}\n\n  /// \\brief Create a status with the specified error code, msg, and stack trace\n  /// as a human-readable string containing more detailed information.\n#ifndef SWIG\n  Status(tensorflow::error::Code code, tensorflow::StringPiece msg,\n         std::vector<StackFrame>&& stack_trace);\n#endif\n\n  /// Copy the specified status.\n  Status(const Status& s);\n  Status& operator=(const Status& s);\n#ifndef SWIG\n  Status(Status&& s) noexcept;\n  Status& operator=(Status&& s) noexcept;\n#endif  // SWIG\n\n  static Status OK() { return Status(); }\n\n  /// Returns true iff the status indicates success.\n  bool ok() const { return (state_ == nullptr); }\n\n  tensorflow::error::Code code() const {\n    retu...\n\n// Status:\nclass Status\n\n// Tensor:\nclass Tensor {\n public:\n  /// \\brief Creates a 1-dimensional, 0-element float tensor.\n  ///\n  /// The returned Tensor is not a scalar (shape {}), but is instead\n  /// an empty one-dimensional Tensor (shape {0}, NumElements() ==\n  /// 0). Since it has no elements, it does not need to be assigned a\n  /// value and is initialized by default (IsInitialized() is\n  /// true). If this is undesirable, consider creating a one-element\n  /// scalar which does require initialization:\n  ///\n  /// ```c++\n  ///\n  ///     Tensor(DT_FLOAT, TensorShape({}))\n  ///\n  /// ```\n  Tensor();\n\n  /// \\brief Creates a Tensor of the given `type` and `shape`.  If\n  /// LogMemory::IsEnabled() the allocation is logged as coming from\n  /// an unknown kernel and step. Calling the Tensor constructor\n  /// directly from within an Op is deprecated: use the\n  /// OpKernelConstruction/OpKernelContext allocate_* methods to\n  /// allocate a new tensor, which record the kernel and step.\n  ///\n  /// The underlying buffer is ...\n\n// ThreadPoolDevice:\nclass ThreadPoolDevice : public LocalDevice {\n public:\n  ThreadPoolDevice(const SessionOptions& options, const string& name,\n                   Bytes memory_limit, const DeviceLocality& locality,\n                   Allocator* allocator);\n  ~ThreadPoolDevice() override;\n\n  Allocator* GetAllocator(AllocatorAttributes attr) override;\n  Allocator* GetScopedAllocator(AllocatorAttributes attr,\n                                int64_t step_id) override;\n  ScopedAllocatorMgr* GetScopedAllocatorMgr() const override {\n    return scoped_allocator_mgr_.get();\n  }\n  Status MakeTensorFromProto(const TensorProto& tensor_proto,\n                             const AllocatorAttributes alloc_attrs,\n                             Tensor* tensor) override;\n  void CopyTensorInSameDevice(const Tensor* input_tensor, Tensor* output_tensor,\n                              const DeviceContext* device_context,\n                              StatusCallback done) override;\n\n  Status Sync() override { return Status::OK(...\n\n// Tensor:\ntensorflow.TensorHandle.Tensor:tensorflow.Status(tensorflow.Tensor**)<const>\n\n// DeviceBase:\nclass DeviceBase {\n public:\n  explicit DeviceBase(Env* env) : env_(env) {}\n  virtual ~DeviceBase();\n\n  Env* env() const { return env_; }\n\n  struct CpuWorkerThreads {\n    int num_threads = 0;\n    thread::ThreadPool* workers = nullptr;\n  };\n\n  // Does not take ownership.\n  void set_tensorflow_cpu_worker_threads(CpuWorkerThreads* t) {\n    cpu_worker_threads_ = t;\n  }\n\n  virtual const CpuWorkerThreads* tensorflow_cpu_worker_threads() const {\n    CHECK(cpu_worker_threads_ != nullptr);\n    return cpu_worker_threads_;\n  }\n\n  // \"stream\" is used in special circumstances (such as the\n  // constructors of Ops) where there is no available OpKernelContext.\n  // \"default_context\" is used by OpKernelContext whenever a device does not\n  // supply a DeviceContext for an op in TryGetDeviceContext() (e.g. when only\n  // using a single stream.)\n  // \"event_mgr\" is used to delay deallocation of temporary GPU buffers.\n  // TODO(pbar) Work out how to move this out of DeviceBase.\n  // GpuDeviceInfo name i...\n\n// OpKernelContext:\ntensorflow.OpKernelContext.OpKernelContext:ANY(tensorflow.OpKernelContext.Params*)\n\n// TensorShape:\nclass TensorShape : public TensorShapeBase<TensorShape> {\n public:\n  using TensorShapeBase<TensorShape>::TensorShapeBase;\n\n  /// Allow a TensorShape to be used as a PartialTensorShape without copying\n  operator const PartialTensorShape&() const;  // NOLINT(runtime/explicit)\n\n  /// Returns true if `*this` and `b` have the same sizes. Ignores\n  /// dimension names.\n  bool IsSameSize(const TensorShape& b) const;\n  bool operator==(const TensorShape& b) const { return IsSameSize(b); }\n  bool operator!=(const TensorShape& b) const { return !IsSameSize(b); }\n\n  /// Fill `*dsizes` from `*this`.\n  /// Notice: Using IndexType=int32 in combination with To32Bit() can\n  /// significantly improve performance on GPU.\n  template <int NDIMS, typename IndexType = Eigen::DenseIndex>\n  Eigen::DSizes<IndexType, NDIMS> AsEigenDSizes() const;\n\n  // Same as `AsEigenDSizes()` but returns a `Status` instead.\n  // Use this method to surface error to user instead of crashing if `NDMIS` is\n  // not equal to `di...\n\n// OpKernelContext:\nclass OpKernelContext {\n public:\n  // The first element of a WrappedAllocator is a \"base\" Allocator and\n  // the second element is that Allocator wrapped by a\n  // TrackingAllocator\n  typedef std::pair<Allocator*, TrackingAllocator*> WrappedAllocator;\n\n  // TODO(zhifengc): Do some cleanup of Params.\n  // The Params struct is passed in to initialize an OpKernelContext,\n  // and must outlive the OpKernelContext.\n  struct Params {\n    ~Params() { delete eigen_gpu_device; }\n\n    // The step being executed.\n    int64_t step_id = 0;\n\n    // Timestamp for the start of graph execution. Used for latency metrics.\n    int64_t start_time_usecs = 0;\n\n    // The deadline for the session to complete by. Empty if unspecified.\n    absl::optional<absl::Time> deadline;\n\n    // The op kernel being computed.\n    OpKernel* op_kernel = nullptr;\n\n    // The device on which the kernel is running.\n    DeviceBase* device = nullptr;\n\n    // The Eigen GPU device wrapper, which may include a per-op\n    // wrappe...\n\n// Called Methods (top 10):\n// SetStatus from tensorflow/core/framework/op_kernel.cc:\nvoid OpKernelConstruction::SetStatus(const Status& status) { /* <=== tensorflow.OpKernelConstruction.SetStatus:void(tensorflow.Status&) */ \n  status_->Update(status);\n}\n\n// OP_REQUIRES from tensorflow/core/kernels/tensorflow/core/framework/tensorflow/core/framework/op_requires.h:\n\n\n// name from tensorflow/core/framework/op_kernel.h:\n  const std::string& name() const { return props_->node_def.name(); } /* <=== tensorflow.OpKernel.name:ANY()<const> */ \n\n// TF_RETURN_IF_ERROR from tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/errors.h:\n\n\n// Update from tensorflow/core/platform/status.cc:\nvoid Status::Update(const Status& new_status) { /* <=== tensorflow.Status.Update:void(tensorflow.Status&) */ \n  if (ok()) {\n    *this = new_status;\n  }\n}\n\n// shape from tensorflow/core/framework/tensor.h:\n  const TensorShape& shape() const { return shape_; } /* <=== tensorflow.Tensor.shape:tensorflow.TensorShape&()<const> */ \n\n// CHECK_EQ from tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/platform/logging.h:\n\n\n// IsMatrix from tensorflow/core/framework/tensor_shape.h:\n  static bool IsMatrix(const TensorShape& shape) { return shape.dims() == 2; } /* <=== tensorflow.TensorShapeUtils.IsMatrix:bool(tensorflow.TensorShape&) */ \n\n// OP_REQUIRES_OK from tensorflow/core/kernels/tensorflow/core/framework/tensorflow/core/framework/op_requires.h:\n\n\n// CHECK_LT from tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/platform/logging.h:\n\n"
  },
  {
    "repository": "mruby",
    "cve_id": "CVE-2022-1427",
    "cwe_list": [
      "CWE-703"
    ],
    "commit_hash": "a4d97934d51cb88954cc49161dc1d151f64afb6b",
    "short_hash": "a4d97934",
    "vulnerableMethods_before": [
      {
        "filename": "vm.c",
        "method_name": "vulnerable_function",
        "raw_code": "mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)\n{\n  /* mrb_assert(MRB_PROC_CFUNC_P(proc)) */\n  const mrb_irep *irep = proc->body.irep;\n  const mrb_pool_value *pool = irep->pool;\n  const mrb_sym *syms = irep->syms;\n  mrb_code insn;\n  int ai = mrb_gc_arena_save(mrb);\n  struct mrb_jmpbuf *prev_jmp = mrb->jmp;\n  struct mrb_jmpbuf c_jmp;\n  uint32_t a;\n  uint16_t b;\n  uint16_t c;\n  mrb_sym mid;\n  const struct mrb_irep_catch_handler *ch;\n\n#ifdef DIRECT_THREADED\n  static const void * const optable[] = {\n#define OPCODE(x,_) &&L_OP_ ## x,\n#include \"mruby/ops.h\"\n#undef OPCODE\n  };\n#endif\n\n  mrb_bool exc_catched = FALSE;\nRETRY_TRY_BLOCK:\n\n  MRB_TRY(&c_jmp) {\n\n  if (exc_catched) {\n    exc_catched = FALSE;\n    mrb_gc_arena_restore(mrb, ai);\n    if (mrb->exc && mrb->exc->tt == MRB_TT_BREAK)\n      goto L_BREAK;\n    goto L_RAISE;\n  }\n  mrb->jmp = &c_jmp;\n  mrb_vm_ci_proc_set(mrb->c->ci, proc);\n\n#define regs (mrb->c->ci->stack)\n  INIT_DISPATCH {\n    CASE(OP_NOP, Z) {\n      /* do nothing */\n      NEXT;\n    }\n\n    CASE(OP_MOVE, BB) {\n      regs[a] = regs[b];\n      NEXT;\n    }\n\n    CASE(OP_LOADL, BB) {\n      switch (pool[b].tt) {   /* number */\n      case IREP_TT_INT32:\n        regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i32);\n        break;\n      case IREP_TT_INT64:\n#if defined(MRB_INT64)\n        regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);\n        break;\n#else\n#if defined(MRB_64BIT)\n        if (INT32_MIN <= pool[b].u.i64 && pool[b].u.i64 <= INT32_MAX) {\n          regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);\n          break;\n        }\n#endif\n        goto L_INT_OVERFLOW;\n#endif\n      case IREP_TT_BIGINT:\n#ifdef MRB_USE_BIGINT\n        {\n          const char *s = pool[b].u.str;\n          regs[a] = mrb_bint_new_str(mrb, s+2, (mrb_int)s[0], (mrb_int)s[1]);\n        }\n        break;\n#else\n        goto L_INT_OVERFLOW;\n#endif\n#ifndef MRB_NO_FLOAT\n      case IREP_TT_FLOAT:\n        regs[a] = mrb_float_value(mrb, pool[b].u.f);\n        break;\n#endif\n      default:\n        /* should not happen (tt:string) */\n        regs[a] = mrb_nil_value();\n        break;\n      }\n      NEXT;\n    }\n\n    CASE(OP_LOADI, BB) {\n      SET_FIXNUM_VALUE(regs[a], b);\n      NEXT;\n    }\n\n    CASE(OP_LOADINEG, BB) {\n      SET_FIXNUM_VALUE(regs[a], -b);\n      NEXT;\n    }\n\n    CASE(OP_LOADI__1,B) goto L_LOADI;\n    CASE(OP_LOADI_0,B) goto L_LOADI;\n    CASE(OP_LOADI_1,B) goto L_LOADI;\n    CASE(OP_LOADI_2,B) goto L_LOADI;\n    CASE(OP_LOADI_3,B) goto L_LOADI;\n    CASE(OP_LOADI_4,B) goto L_LOADI;\n    CASE(OP_LOADI_5,B) goto L_LOADI;\n    CASE(OP_LOADI_6,B) goto L_LOADI;\n    CASE(OP_LOADI_7, B) {\n    L_LOADI:\n      SET_FIXNUM_VALUE(regs[a], (mrb_int)insn - (mrb_int)OP_LOADI_0);\n      NEXT;\n    }\n\n    CASE(OP_LOADI16, BS) {\n      SET_FIXNUM_VALUE(regs[a], (mrb_int)(int16_t)b);\n      NEXT;\n    }\n\n    CASE(OP_LOADI32, BSS) {\n      SET_INT_VALUE(mrb, regs[a], (int32_t)(((uint32_t)b<<16)+c));\n      NEXT;\n    }\n\n    CASE(OP_LOADSYM, BB) {\n      SET_SYM_VALUE(regs[a], syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_LOADNIL, B) {\n      SET_NIL_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADSELF, B) {\n      regs[a] = regs[0];\n      NEXT;\n    }\n\n    CASE(OP_LOADT, B) {\n      SET_TRUE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADF, B) {\n      SET_FALSE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETGV, BB) {\n      mrb_value val = mrb_gv_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETGV, BB) {\n      mrb_gv_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETSV, BB) {\n      mrb_value val = mrb_vm_special_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETSV, BB) {\n      mrb_vm_special_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIV, BB) {\n      regs[a] = mrb_iv_get(mrb, regs[0], syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_SETIV, BB) {\n      mrb_iv_set(mrb, regs[0], syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETCV, BB) {\n      mrb_value val;\n      val = mrb_vm_cv_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETCV, BB) {\n      mrb_vm_cv_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIDX, B) {\n      mrb_value va = regs[a], vb = regs[a+1];\n      switch (mrb_type(va)) {\n      case MRB_TT_ARRAY:\n        if (!mrb_integer_p(vb)) goto getidx_fallback;\n        regs[a] = mrb_ary_entry(va, mrb_integer(vb));\n        break;\n      case MRB_TT_HASH:\n        va = mrb_hash_get(mrb, va, vb);\n        regs[a] = va;\n        break;\n      case MRB_TT_STRING:\n        switch (mrb_type(vb)) {\n        case MRB_TT_INTEGER:\n        case MRB_TT_STRING:\n        case MRB_TT_RANGE:\n          va = mrb_str_aref(mrb, va, vb, mrb_undef_value());\n          regs[a] = va;\n          break;\n        default:\n          goto getidx_fallback;\n        }\n        break;\n      default:\n      getidx_fallback:\n        mid = MRB_OPSYM(aref);\n        goto L_SEND_SYM;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SETIDX, B) {\n      c = 2;\n      mid = MRB_OPSYM(aset);\n      SET_NIL_VALUE(regs[a+3]);\n      goto L_SENDB_SYM;\n    }\n\n    CASE(OP_GETCONST, BB) {\n      mrb_value v = mrb_vm_const_get(mrb, syms[b]);\n      regs[a] = v;\n      NEXT;\n    }\n\n    CASE(OP_SETCONST, BB) {\n      mrb_vm_const_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETMCNST, BB) {\n      mrb_value v = mrb_const_get(mrb, regs[a], syms[b]);\n      regs[a] = v;\n      NEXT;\n    }\n\n    CASE(OP_SETMCNST, BB) {\n      mrb_const_set(mrb, regs[a+1], syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETUPVAR, BBB) {\n      mrb_value *regs_a = regs + a;\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e && b < MRB_ENV_LEN(e)) {\n        *regs_a = e->stack[b];\n      }\n      else {\n        *regs_a = mrb_nil_value();\n      }\n      NEXT;\n    }\n\n    CASE(OP_SETUPVAR, BBB) {\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e) {\n        mrb_value *regs_a = regs + a;\n\n        if (b < MRB_ENV_LEN(e)) {\n          e->stack[b] = *regs_a;\n          mrb_write_barrier(mrb, (struct RBasic*)e);\n        }\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMP, S) {\n      pc += (int16_t)a;\n      JUMP;\n    }\n    CASE(OP_JMPIF, BS) {\n      if (mrb_test(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n    CASE(OP_JMPNOT, BS) {\n      if (!mrb_test(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n    CASE(OP_JMPNIL, BS) {\n      if (mrb_nil_p(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMPUW, S) {\n      a = (uint32_t)((pc - irep->iseq) + (int16_t)a);\n      CHECKPOINT_RESTORE(RBREAK_TAG_JUMP) {\n        struct RBreak *brk = (struct RBreak*)mrb->exc;\n        mrb_value target = mrb_break_value_get(brk);\n        mrb_assert(mrb_integer_p(target));\n        a = (uint32_t)mrb_integer(target);\n        mrb_assert(a >= 0 && a < irep->ilen);\n      }\n      CHECKPOINT_MAIN(RBREAK_TAG_JUMP) {\n        ch = catch_handler_find(mrb, mrb->c->ci, pc, MRB_CATCH_FILTER_ENSURE);\n        if (ch) {\n          /* avoiding a jump from a catch handler into the same handler */\n          if (a < mrb_irep_catch_handler_unpack(ch->begin) || a >= mrb_irep_catch_handler_unpack(ch->end)) {\n            THROW_TAGGED_BREAK(mrb, RBREAK_TAG_JUMP, proc, mrb_fixnum_value(a));\n          }\n        }\n      }\n      CHECKPOINT_END(RBREAK_TAG_JUMP);\n\n      mrb->exc = NULL; /* clear break object */\n      pc = irep->iseq + a;\n      JUMP;\n    }\n\n    CASE(OP_EXCEPT, B) {\n      mrb_value exc;\n\n      if (mrb->exc == NULL) {\n        exc = mrb_nil_value();\n      }\n      else {\n        switch (mrb->exc->tt) {\n        case MRB_TT_BREAK:\n        case MRB_TT_EXCEPTION:\n          exc = mrb_obj_value(mrb->exc);\n          break;\n        default:\n          mrb_assert(!\"bad mrb_type\");\n          exc = mrb_nil_value();\n          break;\n        }\n        mrb->exc = NULL;\n      }\n      regs[a] = exc;\n      NEXT;\n    }\n    CASE(OP_RESCUE, BB) {\n      mrb_value exc = regs[a];  /* exc on stack */\n      mrb_value e = regs[b];\n      struct RClass *ec;\n\n      switch (mrb_type(e)) {\n      case MRB_TT_CLASS:\n      case MRB_TT_MODULE:\n        break;\n      default:\n        {\n          mrb_value exc;\n\n          exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                    \"class or module required for rescue clause\");\n          mrb_exc_set(mrb, exc);\n          goto L_RAISE;\n        }\n      }\n      ec = mrb_class_ptr(e);\n      regs[b] = mrb_bool_value(mrb_obj_is_kind_of(mrb, exc, ec));\n      NEXT;\n    }\n\n    CASE(OP_RAISEIF, B) {\n      mrb_value exc = regs[a];\n      if (mrb_break_p(exc)) {\n        mrb->exc = mrb_obj_ptr(exc);\n        goto L_BREAK;\n      }\n      mrb_exc_set(mrb, exc);\n      if (mrb->exc) {\n        goto L_RAISE;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SSEND, BBB) {\n      regs[a] = regs[0];\n      insn = OP_SEND;\n    }\n    goto L_SENDB;\n\n    CASE(OP_SSENDB, BBB) {\n      regs[a] = regs[0];\n    }\n    goto L_SENDB;\n\n    CASE(OP_SEND, BBB)\n    goto L_SENDB;\n\n    L_SEND_SYM:\n    c = 1;\n    /* push nil after arguments */\n    SET_NIL_VALUE(regs[a+2]);\n    goto L_SENDB_SYM;\n\n    CASE(OP_SENDB, BBB)\n    L_SENDB:\n    mid = syms[b];\n    L_SENDB_SYM:\n    {\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_method_t m;\n      struct RClass *cls;\n      mrb_value recv, blk;\n\n      ARGUMENT_NORMALIZE(a, &c, insn);\n\n      recv = regs[a];\n      cls = mrb_class(mrb, recv);\n      m = mrb_method_search_vm(mrb, &cls, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        m = prepare_missing(mrb, recv, mid, &cls, a, &c, blk, 0);\n        mid = MRB_SYM(method_missing);\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb, a, 0, cls, NULL, mid, c);\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        if (MRB_METHOD_PROC_P(m)) {\n          struct RProc *p = MRB_METHOD_PROC(m);\n\n          mrb_vm_ci_proc_set(ci, p);\n          recv = p->body.func(mrb, recv);\n        }\n        else {\n          if (MRB_METHOD_NOARG_P(m)) {\n            check_method_noarg(mrb, ci);\n          }\n          recv = MRB_METHOD_FUNC(m)(mrb, recv);\n        }\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        if (mrb_proc_p(blk)) {\n          struct RProc *p = mrb_proc_ptr(blk);\n          if (p && !MRB_PROC_STRICT_P(p) && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n        if (!ci->u.target_class) { /* return from context modifying method (resume/yield) */\n          if (ci->cci == CINFO_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return recv;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        ci->stack[0] = recv;\n        /* pop stackpos */\n        ci = cipop(mrb);\n        pc = ci->pc;\n      }\n      else {\n        /* setup environment for calling method */\n        mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);\n        pc = irep->iseq;\n      }\n    }\n    JUMP;\n\n    CASE(OP_CALL, Z) {\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv = ci->stack[0];\n      struct RProc *m = mrb_proc_ptr(recv);\n\n      /* replace callinfo */\n      ci->u.target_class = MRB_PROC_TARGET_CLASS(m);\n      mrb_vm_ci_proc_set(ci, m);\n      if (MRB_PROC_ENV_P(m)) {\n        ci->mid = MRB_PROC_ENV(m)->mid;\n      }\n\n      /* prepare stack */\n      if (MRB_PROC_CFUNC_P(m)) {\n        recv = MRB_PROC_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        /* pop stackpos */\n        ci = cipop(mrb);\n        pc = ci->pc;\n        ci[1].stack[0] = recv;\n        irep = mrb->c->ci->proc->body.irep;\n      }\n      else {\n        /* setup environment for calling method */\n        proc = m;\n        irep = m->body.irep;\n        if (!irep) {\n          mrb->c->ci->stack[0] = mrb_nil_value();\n          a = 0;\n          c = OP_R_NORMAL;\n          goto L_OP_RETURN_BODY;\n        }\n        mrb_int nargs = mrb_ci_bidx(ci)+1;\n        if (nargs < irep->nregs) {\n          mrb_stack_extend(mrb, irep->nregs);\n          stack_clear(regs+nargs, irep->nregs-nargs);\n        }\n        if (MRB_PROC_ENV_P(m)) {\n          regs[0] = MRB_PROC_ENV(m)->stack[0];\n        }\n        pc = irep->iseq;\n      }\n      pool = irep->pool;\n      syms = irep->syms;\n      JUMP;\n    }\n\n    CASE(OP_SUPER, BB) {\n      mrb_method_t m;\n      struct RClass *cls;\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv, blk;\n      const struct RProc *p = ci->proc;\n      mrb_sym mid = ci->mid;\n      struct RClass* target_class = MRB_PROC_TARGET_CLASS(p);\n\n      if (MRB_PROC_ENV_P(p) && p->e.env->mid && p->e.env->mid != mid) { /* alias support */\n        mid = p->e.env->mid;    /* restore old mid */\n      }\n\n      if (mid == 0 || !target_class) {\n        mrb_value exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (target_class->flags & MRB_FL_CLASS_IS_PREPENDED) {\n        target_class = mrb_vm_ci_target_class(ci);\n      }\n      else if (target_class->tt == MRB_TT_MODULE) {\n        target_class = mrb_vm_ci_target_class(ci);\n        if (!target_class || target_class->tt != MRB_TT_ICLASS) {\n          goto super_typeerror;\n        }\n      }\n      recv = regs[0];\n      if (!mrb_obj_is_kind_of(mrb, recv, target_class)) {\n      super_typeerror: ;\n        mrb_value exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                            \"self has wrong type to call super in this context\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n\n      ARGUMENT_NORMALIZE(a, &b, OP_SUPER);\n\n      cls = target_class->super;\n      m = mrb_method_search_vm(mrb, &cls, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        m = prepare_missing(mrb, recv, mid, &cls, a, &b, blk, 1);\n        mid = MRB_SYM(method_missing);\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb, a, 0, cls, NULL, mid, b);\n\n      /* prepare stack */\n      ci->stack[0] = recv;\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        mrb_value v;\n\n        if (MRB_METHOD_PROC_P(m)) {\n          mrb_vm_ci_proc_set(ci, MRB_METHOD_PROC(m));\n        }\n        v = MRB_METHOD_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_restore(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        mrb_assert(!mrb_break_p(v));\n        if (!mrb_vm_ci_target_class(ci)) { /* return from context modifying method (resume/yield) */\n          if (ci->cci == CINFO_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return v;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        mrb->c->ci->stack[0] = v;\n        ci = cipop(mrb);\n        pc = ci->pc;\n      }\n      else {\n        /* setup environment for calling method */\n        mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);\n        pc = irep->iseq;\n      }\n      JUMP;\n    }\n\n    CASE(OP_ARGARY, BS) {\n      mrb_int m1 = (b>>11)&0x3f;\n      mrb_int r  = (b>>10)&0x1;\n      mrb_int m2 = (b>>5)&0x1f;\n      mrb_int kd = (b>>4)&0x1;\n      mrb_int lv = (b>>0)&0xf;\n      mrb_value *stack;\n\n      if (mrb->c->ci->mid == 0 || mrb_vm_ci_target_class(mrb->c->ci) == NULL) {\n        mrb_value exc;\n\n      L_NOSUPER:\n        exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e) goto L_NOSUPER;\n        if (MRB_ENV_LEN(e) <= m1+r+m2+1)\n          goto L_NOSUPER;\n        stack = e->stack + 1;\n      }\n      if (r == 0) {\n        regs[a] = mrb_ary_new_from_values(mrb, m1+m2, stack);\n      }\n      else {\n        mrb_value *pp = NULL;\n        struct RArray *rest;\n        mrb_int len = 0;\n\n        if (mrb_array_p(stack[m1])) {\n          struct RArray *ary = mrb_ary_ptr(stack[m1]);\n\n          pp = ARY_PTR(ary);\n          len = ARY_LEN(ary);\n        }\n        regs[a] = mrb_ary_new_capa(mrb, m1+len+m2);\n        rest = mrb_ary_ptr(regs[a]);\n        if (m1 > 0) {\n          stack_copy(ARY_PTR(rest), stack, m1);\n        }\n        if (len > 0) {\n          stack_copy(ARY_PTR(rest)+m1, pp, len);\n        }\n        if (m2 > 0) {\n          stack_copy(ARY_PTR(rest)+m1+len, stack+m1+1, m2);\n        }\n        ARY_SET_LEN(rest, m1+len+m2);\n      }\n      if (kd) {\n        regs[a+1] = stack[m1+r+m2];\n        regs[a+2] = stack[m1+r+m2+1];\n      }\n      else {\n        regs[a+1] = stack[m1+r+m2];\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ENTER, W) {\n      mrb_int m1 = MRB_ASPEC_REQ(a);\n      mrb_int o  = MRB_ASPEC_OPT(a);\n      mrb_int r  = MRB_ASPEC_REST(a);\n      mrb_int m2 = MRB_ASPEC_POST(a);\n      mrb_int kd = (MRB_ASPEC_KEY(a) > 0 || MRB_ASPEC_KDICT(a))? 1 : 0;\n      /* unused\n      int b  = MRB_ASPEC_BLOCK(a);\n      */\n      mrb_int const len = m1 + o + r + m2;\n\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_int argc = ci->n;\n      mrb_value *argv = regs+1;\n      mrb_value * const argv0 = argv;\n      mrb_int const kw_pos = len + kd;    /* where kwhash should be */\n      mrb_int const blk_pos = kw_pos + 1; /* where block should be */\n      mrb_value blk = regs[mrb_ci_bidx(ci)];\n      mrb_value kdict = mrb_nil_value();\n\n      /* keyword arguments */\n      if (ci->nk > 0) {\n        mrb_int kidx = mrb_ci_kidx(ci);\n        kdict = regs[kidx];\n        if (!mrb_hash_p(kdict) || mrb_hash_size(mrb, kdict) == 0) {\n          kdict = mrb_nil_value();\n          ci->nk = 0;\n        }\n      }\n      if (!kd && !mrb_nil_p(kdict)) {\n        if (argc < 14) {\n          ci->n++;\n          argc++;    /* include kdict in normal arguments */\n        }\n        else if (argc == 14) {\n          /* pack arguments and kdict */\n          regs[1] = mrb_ary_new_from_values(mrb, argc+1, &regs[1]);\n          argc = ci->n = 15;\n        }\n        else {/* argc == 15 */\n          /* push kdict to packed arguments */\n          mrb_ary_push(mrb, regs[1], regs[2]);\n        }\n        ci->nk = 0;\n      }\n      if (kd && MRB_ASPEC_KEY(a) > 0 && mrb_hash_p(kdict)) {\n        kdict = mrb_hash_dup(mrb, kdict);\n      }\n\n      /* arguments is passed with Array */\n      if (argc == 15) {\n        struct RArray *ary = mrb_ary_ptr(regs[1]);\n        argv = ARY_PTR(ary);\n        argc = (int)ARY_LEN(ary);\n        mrb_gc_protect(mrb, regs[1]);\n      }\n\n      /* strict argument check */\n      if (ci->proc && MRB_PROC_STRICT_P(ci->proc)) {\n        if (argc < m1 + m2 || (r == 0 && argc > len)) {\n          argnum_error(mrb, m1+m2);\n          goto L_RAISE;\n        }\n      }\n      /* extract first argument array to arguments */\n      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {\n        mrb_gc_protect(mrb, argv[0]);\n        argc = (int)RARRAY_LEN(argv[0]);\n        argv = RARRAY_PTR(argv[0]);\n      }\n\n      /* rest arguments */\n      mrb_value rest = mrb_nil_value();\n      if (argc < len) {\n        mrb_int mlen = m2;\n        if (argc < m1+m2) {\n          mlen = m1 < argc ? argc - m1 : 0;\n        }\n\n        /* copy mandatory and optional arguments */\n        if (argv0 != argv && argv) {\n          value_move(&regs[1], argv, argc-mlen); /* m1 + o */\n        }\n        if (argc < m1) {\n          stack_clear(&regs[argc+1], m1-argc);\n        }\n        /* copy post mandatory arguments */\n        if (mlen) {\n          value_move(&regs[len-m2+1], &argv[argc-mlen], mlen);\n        }\n        if (mlen < m2) {\n          stack_clear(&regs[len-m2+mlen+1], m2-mlen);\n        }\n        /* initialize rest arguments with empty Array */\n        if (r) {\n          rest = mrb_ary_new_capa(mrb, 0);\n          regs[m1+o+1] = rest;\n        }\n        /* skip initializer of passed arguments */\n        if (o > 0 && argc > m1+m2)\n          pc += (argc - m1 - m2)*3;\n      }\n      else {\n        mrb_int rnum = 0;\n        if (argv0 != argv) {\n          value_move(&regs[1], argv, m1+o);\n        }\n        if (r) {\n          rnum = argc-m1-o-m2;\n          rest = mrb_ary_new_from_values(mrb, rnum, argv+m1+o);\n          regs[m1+o+1] = rest;\n        }\n        if (m2 > 0 && argc-m2 > m1) {\n          value_move(&regs[m1+o+r+1], &argv[m1+o+rnum], m2);\n        }\n        pc += o*3;\n      }\n\n      /* need to be update blk first to protect blk from GC */\n      regs[blk_pos] = blk;              /* move block */\n      if (kd) {\n        if (mrb_nil_p(kdict))\n          kdict = mrb_hash_new_capa(mrb, 0);\n        regs[kw_pos] = kdict;           /* set kwhash */\n      }\n\n      /* format arguments for generated code */\n      mrb->c->ci->n = (uint8_t)len;\n\n      /* clear local (but non-argument) variables */\n      if (irep->nlocals-blk_pos-1 > 0) {\n        stack_clear(&regs[blk_pos+1], irep->nlocals-blk_pos-1);\n      }\n      JUMP;\n    }\n\n    CASE(OP_KARG, BB) {\n      mrb_value k = mrb_symbol_value(syms[b]);\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict, v;\n\n      if (kidx < 0 || !mrb_hash_p(kdict=regs[kidx]) || !mrb_hash_key_p(mrb, kdict, k)) {\n        mrb_value str = mrb_format(mrb, \"missing keyword: %v\", k);\n        mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));\n        goto L_RAISE;\n      }\n      v = mrb_hash_get(mrb, kdict, k);\n      regs[a] = v;\n      mrb_hash_delete_key(mrb, kdict, k);\n      NEXT;\n    }\n\n    CASE(OP_KEY_P, BB) {\n      mrb_value k = mrb_symbol_value(syms[b]);\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict;\n      mrb_bool key_p = FALSE;\n\n      if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx])) {\n        key_p = mrb_hash_key_p(mrb, kdict, k);\n      }\n      regs[a] = mrb_bool_value(key_p);\n      NEXT;\n    }\n\n    CASE(OP_KEYEND, Z) {\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict;\n\n      if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx]) && !mrb_hash_empty_p(mrb, kdict)) {\n        mrb_value keys = mrb_hash_keys(mrb, kdict);\n        mrb_value key1 = RARRAY_PTR(keys)[0];\n        mrb_value str = mrb_format(mrb, \"unknown keyword: %v\", key1);\n        mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));\n        goto L_RAISE;\n      }\n      NEXT;\n    }\n\n    CASE(OP_BREAK, B) {\n      c = OP_R_BREAK;\n      goto L_RETURN;\n    }\n    CASE(OP_RETURN_BLK, B) {\n      c = OP_R_RETURN;\n      goto L_RETURN;\n    }\n    CASE(OP_RETURN, B)\n    c = OP_R_NORMAL;\n    L_RETURN:\n    {\n      mrb_callinfo *ci;\n\n      ci = mrb->c->ci;\n      if (ci->mid) {\n        mrb_value blk = regs[mrb_ci_bidx(ci)];\n\n        if (mrb_proc_p(blk)) {\n          struct RProc *p = mrb_proc_ptr(blk);\n\n          if (!MRB_PROC_STRICT_P(p) &&\n              ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n      }\n\n      if (mrb->exc) {\n      L_RAISE:\n        ci = mrb->c->ci;\n        if (ci == mrb->c->cibase) {\n          ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);\n          if (ch == NULL) goto L_FTOP;\n          goto L_CATCH;\n        }\n        while ((ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL)) == NULL) {\n          ci = cipop(mrb);\n          if (ci[1].cci == CINFO_SKIP && prev_jmp) {\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          pc = ci[0].pc;\n          if (ci == mrb->c->cibase) {\n            ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);\n            if (ch == NULL) {\n            L_FTOP:             /* fiber top */\n              if (mrb->c == mrb->root_c) {\n                mrb->c->ci->stack = mrb->c->stbase;\n                goto L_STOP;\n              }\n              else {\n                struct mrb_context *c = mrb->c;\n\n                c->status = MRB_FIBER_TERMINATED;\n                mrb->c = c->prev;\n                c->prev = NULL;\n                goto L_RAISE;\n              }\n            }\n            break;\n          }\n        }\n      L_CATCH:\n        if (ch == NULL) goto L_STOP;\n        if (FALSE) {\n        L_CATCH_TAGGED_BREAK: /* from THROW_TAGGED_BREAK() or UNWIND_ENSURE() */\n          ci = mrb->c->ci;\n        }\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, irep->nregs);\n        pc = irep->iseq + mrb_irep_catch_handler_unpack(ch->target);\n      }\n      else {\n        mrb_int acc;\n        mrb_value v;\n\n        ci = mrb->c->ci;\n        v = regs[a];\n        mrb_gc_protect(mrb, v);\n        switch (c) {\n        case OP_R_RETURN:\n          /* Fall through to OP_R_NORMAL otherwise */\n          if (ci->cci == CINFO_NONE && MRB_PROC_ENV_P(proc) && !MRB_PROC_STRICT_P(proc)) {\n            const struct RProc *dst;\n            mrb_callinfo *cibase;\n            cibase = mrb->c->cibase;\n            dst = top_proc(mrb, proc);\n\n            if (MRB_PROC_ENV_P(dst)) {\n              struct REnv *e = MRB_PROC_ENV(dst);\n\n              if (!MRB_ENV_ONSTACK_P(e) || (e->cxt && e->cxt != mrb->c)) {\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n            }\n            /* check jump destination */\n            while (cibase <= ci && ci->proc != dst) {\n              if (ci->cci > CINFO_NONE) { /* jump cross C boundary */\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n              ci--;\n            }\n            if (ci <= cibase) { /* no jump destination */\n              localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n              goto L_RAISE;\n            }\n            ci = mrb->c->ci;\n            while (cibase <= ci && ci->proc != dst) {\n              CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_BLOCK) {\n                cibase = mrb->c->cibase;\n                dst = top_proc(mrb, proc);\n              }\n              CHECKPOINT_MAIN(RBREAK_TAG_RETURN_BLOCK) {\n                UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_BLOCK, proc, v);\n              }\n              CHECKPOINT_END(RBREAK_TAG_RETURN_BLOCK);\n              ci = cipop(mrb);\n              pc = ci->pc;\n            }\n            proc = ci->proc;\n            mrb->exc = NULL; /* clear break object */\n            break;\n          }\n          /* fallthrough */\n        case OP_R_NORMAL:\n        NORMAL_RETURN:\n          if (ci == mrb->c->cibase) {\n            struct mrb_context *c;\n            c = mrb->c;\n\n            if (!c->prev) { /* toplevel return */\n              regs[irep->nlocals] = v;\n              goto CHECKPOINT_LABEL_MAKE(RBREAK_TAG_STOP);\n            }\n            if (!c->vmexec && c->prev->ci == c->prev->cibase) {\n              mrb_value exc = mrb_exc_new_lit(mrb, E_FIBER_ERROR, \"double resume\");\n              mrb_exc_set(mrb, exc);\n              goto L_RAISE;\n            }\n            CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_TOPLEVEL) {\n              c = mrb->c;\n            }\n            CHECKPOINT_MAIN(RBREAK_TAG_RETURN_TOPLEVEL) {\n              UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_TOPLEVEL, proc, v);\n            }\n            CHECKPOINT_END(RBREAK_TAG_RETURN_TOPLEVEL);\n            /* automatic yield at the end */\n            c->status = MRB_FIBER_TERMINATED;\n            mrb->c = c->prev;\n            mrb->c->status = MRB_FIBER_RUNNING;\n            c->prev = NULL;\n            if (c->vmexec) {\n              mrb_gc_arena_restore(mrb, ai);\n              c->vmexec = FALSE;\n              mrb->jmp = prev_jmp;\n              return v;\n            }\n            ci = mrb->c->ci;\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_RETURN) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_RETURN) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_RETURN);\n          mrb->exc = NULL; /* clear break object */\n          break;\n        case OP_R_BREAK:\n          if (MRB_PROC_STRICT_P(proc)) goto NORMAL_RETURN;\n          if (MRB_PROC_ORPHAN_P(proc)) {\n            mrb_value exc;\n\n          L_BREAK_ERROR:\n            exc = mrb_exc_new_lit(mrb, E_LOCALJUMP_ERROR,\n                                      \"break from proc-closure\");\n            mrb_exc_set(mrb, exc);\n            goto L_RAISE;\n          }\n          if (!MRB_PROC_ENV_P(proc) || !MRB_ENV_ONSTACK_P(MRB_PROC_ENV(proc))) {\n            goto L_BREAK_ERROR;\n          }\n          else {\n            struct REnv *e = MRB_PROC_ENV(proc);\n\n            if (e->cxt != mrb->c) {\n              goto L_BREAK_ERROR;\n            }\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_BREAK) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_BREAK);\n          /* break from fiber block */\n          if (ci == mrb->c->cibase && ci->pc) {\n            struct mrb_context *c = mrb->c;\n\n            mrb->c = c->prev;\n            c->prev = NULL;\n            ci = mrb->c->ci;\n          }\n          if (ci->cci > CINFO_NONE) {\n            ci = cipop(mrb);\n            mrb->exc = (struct RObject*)break_new(mrb, RBREAK_TAG_BREAK, proc, v);\n            mrb_gc_arena_restore(mrb, ai);\n            mrb->c->vmexec = FALSE;\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          if (FALSE) {\n            struct RBreak *brk;\n\n          L_BREAK:\n            brk = (struct RBreak*)mrb->exc;\n            proc = mrb_break_proc_get(brk);\n            v = mrb_break_value_get(brk);\n            ci = mrb->c->ci;\n\n            switch (mrb_break_tag_get(brk)) {\n#define DISPATCH_CHECKPOINTS(n, i) case n: goto CHECKPOINT_LABEL_MAKE(n);\n              RBREAK_TAG_FOREACH(DISPATCH_CHECKPOINTS)\n#undef DISPATCH_CHECKPOINTS\n              default:\n                mrb_assert(!\"wrong break tag\");\n            }\n          }\n          while (mrb->c->cibase < ci && ci[-1].proc != proc->upper) {\n            if (ci[-1].cci == CINFO_SKIP) {\n              goto L_BREAK_ERROR;\n            }\n            CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_UPPER) {\n              /* do nothing */\n            }\n            CHECKPOINT_MAIN(RBREAK_TAG_BREAK_UPPER) {\n              UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_UPPER, proc, v);\n            }\n            CHECKPOINT_END(RBREAK_TAG_BREAK_UPPER);\n            ci = cipop(mrb);\n            pc = ci->pc;\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_INTARGET) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_BREAK_INTARGET) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_INTARGET, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_BREAK_INTARGET);\n          if (ci == mrb->c->cibase) {\n            goto L_BREAK_ERROR;\n          }\n          mrb->exc = NULL; /* clear break object */\n          break;\n        default:\n          /* cannot happen */\n          break;\n        }\n        mrb_assert(ci == mrb->c->ci);\n        mrb_assert(mrb->exc == NULL);\n\n        if (mrb->c->vmexec && !mrb_vm_ci_target_class(ci)) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->c->vmexec = FALSE;\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        acc = ci->cci;\n        ci = cipop(mrb);\n        if (acc == CINFO_SKIP || acc == CINFO_DIRECT) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        pc = ci->pc;\n        DEBUG(fprintf(stderr, \"from :%s\\n\", mrb_sym_name(mrb, ci->mid)));\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n\n        ci[1].stack[0] = v;\n        mrb_gc_arena_restore(mrb, ai);\n      }\n      JUMP;\n    }\n\n    CASE(OP_BLKPUSH, BS) {\n      int m1 = (b>>11)&0x3f;\n      int r  = (b>>10)&0x1;\n      int m2 = (b>>5)&0x1f;\n      int kd = (b>>4)&0x1;\n      int lv = (b>>0)&0xf;\n      mrb_value *stack;\n\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e || (!MRB_ENV_ONSTACK_P(e) && e->mid == 0) ||\n            MRB_ENV_LEN(e) <= m1+r+m2+1) {\n          localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n          goto L_RAISE;\n        }\n        stack = e->stack + 1;\n      }\n      if (mrb_nil_p(stack[m1+r+m2+kd])) {\n        localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n        goto L_RAISE;\n      }\n      regs[a] = stack[m1+r+m2+kd];\n      NEXT;\n    }\n\n#if !defined(MRB_USE_BIGINT) || defined(MRB_INT32)\n  L_INT_OVERFLOW:\n    {\n      mrb_value exc = mrb_exc_new_lit(mrb, E_RANGE_ERROR, \"integer overflow\");\n      mrb_exc_set(mrb, exc);\n    }\n    goto L_RAISE;\n#endif\n\n#define TYPES2(a,b) ((((uint16_t)(a))<<8)|(((uint16_t)(b))&0xff))\n#define OP_MATH(op_name)                                                    \\\n  /* need to check if op is overridden */                                   \\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {                  \\\n    OP_MATH_CASE_INTEGER(op_name);                                          \\\n    OP_MATH_CASE_FLOAT(op_name, integer, float);                            \\\n    OP_MATH_CASE_FLOAT(op_name, float,  integer);                           \\\n    OP_MATH_CASE_FLOAT(op_name, float,  float);                             \\\n    OP_MATH_CASE_STRING_##op_name();                                        \\\n    default:                                                                \\\n      mid = MRB_OPSYM(op_name);                                             \\\n      goto L_SEND_SYM;                                                      \\\n  }                                                                         \\\n  NEXT;\n#define OP_MATH_CASE_INTEGER(op_name)                                       \\\n  case TYPES2(MRB_TT_INTEGER, MRB_TT_INTEGER):                              \\\n    {                                                                       \\\n      mrb_int x = mrb_integer(regs[a]), y = mrb_integer(regs[a+1]), z;      \\\n      if (mrb_int_##op_name##_overflow(x, y, &z)) {                         \\\n        OP_MATH_OVERFLOW_INT(op_name,x,y);                                  \\\n      }                                                                     \\\n      else                                                                  \\\n        SET_INT_VALUE(mrb,regs[a], z);                                      \\\n    }                                                                       \\\n    break\n#ifdef MRB_NO_FLOAT\n#define OP_MATH_CASE_FLOAT(op_name, t1, t2) (void)0\n#else\n#define OP_MATH_CASE_FLOAT(op_name, t1, t2)                                     \\\n  case TYPES2(OP_MATH_TT_##t1, OP_MATH_TT_##t2):                                \\\n    {                                                                           \\\n      mrb_float z = mrb_##t1(regs[a]) OP_MATH_OP_##op_name mrb_##t2(regs[a+1]); \\\n      SET_FLOAT_VALUE(mrb, regs[a], z);                                         \\\n    }                                                                           \\\n    break\n#endif\n#ifdef MRB_USE_BIGINT\n#define OP_MATH_OVERFLOW_INT(op,x,y) regs[a] = mrb_bint_##op##_ii(mrb,x,y)\n#else\n#define OP_MATH_OVERFLOW_INT(op,x,y) goto L_INT_OVERFLOW\n#endif\n#define OP_MATH_CASE_STRING_add()                                           \\\n  case TYPES2(MRB_TT_STRING, MRB_TT_STRING):                                \\\n    regs[a] = mrb_str_plus(mrb, regs[a], regs[a+1]);                        \\\n    mrb_gc_arena_restore(mrb, ai);                                          \\\n    break\n#define OP_MATH_CASE_STRING_sub() (void)0\n#define OP_MATH_CASE_STRING_mul() (void)0\n#define OP_MATH_OP_add +\n#define OP_MATH_OP_sub -\n#define OP_MATH_OP_mul *\n#define OP_MATH_TT_integer MRB_TT_INTEGER\n#define OP_MATH_TT_float   MRB_TT_FLOAT\n\n    CASE(OP_ADD, B) {\n      OP_MATH(add);\n    }\n\n    CASE(OP_SUB, B) {\n      OP_MATH(sub);\n    }\n\n    CASE(OP_MUL, B) {\n      OP_MATH(mul);\n    }\n\n    CASE(OP_DIV, B) {\n#ifndef MRB_NO_FLOAT\n      mrb_float x, y, f;\n#endif\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\n        {\n          mrb_int x = mrb_integer(regs[a]);\n          mrb_int y = mrb_integer(regs[a+1]);\n          mrb_int div = mrb_div_int(mrb, x, y);\n          SET_INT_VALUE(mrb, regs[a], div);\n        }\n        NEXT;\n#ifndef MRB_NO_FLOAT\n      case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\n        x = (mrb_float)mrb_integer(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\n        x = mrb_float(regs[a]);\n        y = (mrb_float)mrb_integer(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n        x = mrb_float(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n#endif\n      default:\n        mid = MRB_OPSYM(div);\n        goto L_SEND_SYM;\n      }\n\n#ifndef MRB_NO_FLOAT\n      f = mrb_div_float(x, y);\n      SET_FLOAT_VALUE(mrb, regs[a], f);\n#endif\n      NEXT;\n    }\n\n#define OP_MATHI(op_name)                                                   \\\n  /* need to check if op is overridden */                                   \\\n  switch (mrb_type(regs[a])) {                                              \\\n    OP_MATHI_CASE_INTEGER(op_name);                                         \\\n    OP_MATHI_CASE_FLOAT(op_name);                                           \\\n    default:                                                                \\\n      SET_INT_VALUE(mrb,regs[a+1], b);                                      \\\n      mid = MRB_OPSYM(op_name);                                             \\\n      goto L_SEND_SYM;                                                      \\\n  }                                                                         \\\n  NEXT;\n#define OP_MATHI_CASE_INTEGER(op_name)                                      \\\n  case MRB_TT_INTEGER:                                                      \\\n    {                                                                       \\\n      mrb_int x = mrb_integer(regs[a]), y = (mrb_int)b, z;                  \\\n      if (mrb_int_##op_name##_overflow(x, y, &z)) {                         \\\n        OP_MATH_OVERFLOW_INT(op_name,x,y);                                  \\\n      }                                                                     \\\n      else                                                                  \\\n        SET_INT_VALUE(mrb,regs[a], z);                                      \\\n    }                                                                       \\\n    break\n#ifdef MRB_NO_FLOAT\n#define OP_MATHI_CASE_FLOAT(op_name) (void)0\n#else\n#define OP_MATHI_CASE_FLOAT(op_name)                                        \\\n  case MRB_TT_FLOAT:                                                        \\\n    {                                                                       \\\n      mrb_float z = mrb_float(regs[a]) OP_MATH_OP_##op_name b;              \\\n      SET_FLOAT_VALUE(mrb, regs[a], z);                                     \\\n    }                                                                       \\\n    break\n#endif\n\n    CASE(OP_ADDI, BB) {\n      OP_MATHI(add);\n    }\n\n    CASE(OP_SUBI, BB) {\n      OP_MATHI(sub);\n    }\n\n#define OP_CMP_BODY(op,v1,v2) (v1(regs[a]) op v2(regs[a+1]))\n\n#ifdef MRB_NO_FLOAT\n#define OP_CMP(op,sym) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  default:\\\n    mid = MRB_OPSYM(sym);\\\n    goto L_SEND_SYM;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#else\n#define OP_CMP(op, sym) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_float);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_float);\\\n    break;\\\n  default:\\\n    mid = MRB_OPSYM(sym);\\\n    goto L_SEND_SYM;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#endif\n\n    CASE(OP_EQ, B) {\n      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {\n        SET_TRUE_VALUE(regs[a]);\n      }\n      else {\n        OP_CMP(==,eq);\n      }\n      NEXT;\n    }\n\n    CASE(OP_LT, B) {\n      OP_CMP(<,lt);\n      NEXT;\n    }\n\n    CASE(OP_LE, B) {\n      OP_CMP(<=,le);\n      NEXT;\n    }\n\n    CASE(OP_GT, B) {\n      OP_CMP(>,gt);\n      NEXT;\n    }\n\n    CASE(OP_GE, B) {\n      OP_CMP(>=,ge);\n      NEXT;\n    }\n\n    CASE(OP_ARRAY, BB) {\n      regs[a] = mrb_ary_new_from_values(mrb, b, &regs[a]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_ARRAY2, BBB) {\n      regs[a] = mrb_ary_new_from_values(mrb, c, &regs[b]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYCAT, B) {\n      mrb_value splat = mrb_ary_splat(mrb, regs[a+1]);\n      if (mrb_nil_p(regs[a])) {\n        regs[a] = splat;\n      }\n      else {\n        mrb_assert(mrb_array_p(regs[a]));\n        mrb_ary_concat(mrb, regs[a], splat);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYPUSH, BB) {\n      mrb_assert(mrb_array_p(regs[a]));\n      for (mrb_int i=0; i<b; i++) {\n        mrb_ary_push(mrb, regs[a], regs[a+i+1]);\n      }\n      NEXT;\n    }\n\n    CASE(OP_ARYDUP, B) {\n      mrb_value ary = regs[a];\n      if (mrb_array_p(ary)) {\n        ary = mrb_ary_new_from_values(mrb, RARRAY_LEN(ary), RARRAY_PTR(ary));\n      }\n      else {\n        ary = mrb_ary_new_from_values(mrb, 1, &ary);\n      }\n      regs[a] = ary;\n      NEXT;\n    }\n\n    CASE(OP_AREF, BBB) {\n      mrb_value v = regs[b];\n\n      if (!mrb_array_p(v)) {\n        if (c == 0) {\n          regs[a] = v;\n        }\n        else {\n          SET_NIL_VALUE(regs[a]);\n        }\n      }\n      else {\n        v = mrb_ary_ref(mrb, v, c);\n        regs[a] = v;\n      }\n      NEXT;\n    }\n\n    CASE(OP_ASET, BBB) {\n      mrb_assert(mrb_array_p(regs[a]));\n      mrb_ary_set(mrb, regs[b], c, regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_APOST, BBB) {\n      mrb_value v = regs[a];\n      int pre  = b;\n      int post = c;\n      struct RArray *ary;\n      int len, idx;\n\n      if (!mrb_array_p(v)) {\n        v = mrb_ary_new_from_values(mrb, 1, &regs[a]);\n      }\n      ary = mrb_ary_ptr(v);\n      len = (int)ARY_LEN(ary);\n      if (len > pre + post) {\n        v = mrb_ary_new_from_values(mrb, len - pre - post, ARY_PTR(ary)+pre);\n        regs[a++] = v;\n        while (post--) {\n          regs[a++] = ARY_PTR(ary)[len-post-1];\n        }\n      }\n      else {\n        v = mrb_ary_new_capa(mrb, 0);\n        regs[a++] = v;\n        for (idx=0; idx+pre<len; idx++) {\n          regs[a+idx] = ARY_PTR(ary)[pre+idx];\n        }\n        while (idx < post) {\n          SET_NIL_VALUE(regs[a+idx]);\n          idx++;\n        }\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_INTERN, B) {\n      mrb_assert(mrb_string_p(regs[a]));\n      mrb_sym sym = mrb_intern_str(mrb, regs[a]);\n      regs[a] = mrb_symbol_value(sym);\n      NEXT;\n    }\n\n    CASE(OP_SYMBOL, BB) {\n      size_t len;\n      mrb_sym sym;\n\n      mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);\n      len = pool[b].tt >> 2;\n      if (pool[b].tt & IREP_TT_SFLAG) {\n        sym = mrb_intern_static(mrb, pool[b].u.str, len);\n      }\n      else {\n        sym  = mrb_intern(mrb, pool[b].u.str, len);\n      }\n      regs[a] = mrb_symbol_value(sym);\n      NEXT;\n    }\n\n    CASE(OP_STRING, BB) {\n      mrb_int len;\n\n      mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);\n      len = pool[b].tt >> 2;\n      if (pool[b].tt & IREP_TT_SFLAG) {\n        regs[a] = mrb_str_new_static(mrb, pool[b].u.str, len);\n      }\n      else {\n        regs[a] = mrb_str_new(mrb, pool[b].u.str, len);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_STRCAT, B) {\n      mrb_assert(mrb_string_p(regs[a]));\n      mrb_str_concat(mrb, regs[a], regs[a+1]);\n      NEXT;\n    }\n\n    CASE(OP_HASH, BB) {\n      mrb_value hash = mrb_hash_new_capa(mrb, b);\n      int i;\n      int lim = a+b*2;\n\n      for (i=a; i<lim; i+=2) {\n        mrb_hash_set(mrb, hash, regs[i], regs[i+1]);\n      }\n      regs[a] = hash;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_HASHADD, BB) {\n      mrb_value hash;\n      int i;\n      int lim = a+b*2+1;\n\n      hash = regs[a];\n      mrb_ensure_hash_type(mrb, hash);\n      for (i=a+1; i<lim; i+=2) {\n        mrb_hash_set(mrb, hash, regs[i], regs[i+1]);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_HASHCAT, B) {\n      mrb_value hash = regs[a];\n\n      mrb_assert(mrb_hash_p(hash));\n      mrb_hash_merge(mrb, hash, regs[a+1]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_LAMBDA, BB)\n    c = OP_L_LAMBDA;\n    L_MAKE_LAMBDA:\n    {\n      struct RProc *p;\n      const mrb_irep *nirep = irep->reps[b];\n\n      if (c & OP_L_CAPTURE) {\n        p = mrb_closure_new(mrb, nirep);\n      }\n      else {\n        p = mrb_proc_new(mrb, nirep);\n        p->flags |= MRB_PROC_SCOPE;\n      }\n      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;\n      regs[a] = mrb_obj_value(p);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_BLOCK, BB) {\n      c = OP_L_BLOCK;\n      goto L_MAKE_LAMBDA;\n    }\n    CASE(OP_METHOD, BB) {\n      c = OP_L_METHOD;\n      goto L_MAKE_LAMBDA;\n    }\n\n    CASE(OP_RANGE_INC, B) {\n      mrb_value v = mrb_range_new(mrb, regs[a], regs[a+1], FALSE);\n      regs[a] = v;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_RANGE_EXC, B) {\n      mrb_value v = mrb_range_new(mrb, regs[a], regs[a+1], TRUE);\n      regs[a] = v;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_OCLASS, B) {\n      regs[a] = mrb_obj_value(mrb->object_class);\n      NEXT;\n    }\n\n    CASE(OP_CLASS, BB) {\n      struct RClass *c = 0, *baseclass;\n      mrb_value base, super;\n      mrb_sym id = syms[b];\n\n      base = regs[a];\n      super = regs[a+1];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        if (!baseclass) baseclass = mrb->object_class;\n        base = mrb_obj_value(baseclass);\n      }\n      c = mrb_vm_define_class(mrb, base, super, id);\n      regs[a] = mrb_obj_value(c);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_MODULE, BB) {\n      struct RClass *cls = 0, *baseclass;\n      mrb_value base;\n      mrb_sym id = syms[b];\n\n      base = regs[a];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        if (!baseclass) baseclass = mrb->object_class;\n        base = mrb_obj_value(baseclass);\n      }\n      cls = mrb_vm_define_module(mrb, base, id);\n      regs[a] = mrb_obj_value(cls);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_EXEC, BB)\n    {\n      mrb_value recv = regs[a];\n      struct RProc *p;\n      const mrb_irep *nirep = irep->reps[b];\n\n      /* prepare closure */\n      p = mrb_proc_new(mrb, nirep);\n      p->c = NULL;\n      mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)proc);\n      MRB_PROC_SET_TARGET_CLASS(p, mrb_class_ptr(recv));\n      p->flags |= MRB_PROC_SCOPE;\n\n      /* prepare call stack */\n      cipush(mrb, a, 0, mrb_class_ptr(recv), p, 0, 0);\n\n      irep = p->body.irep;\n      pool = irep->pool;\n      syms = irep->syms;\n      mrb_stack_extend(mrb, irep->nregs);\n      stack_clear(regs+1, irep->nregs-1);\n      pc = irep->iseq;\n      JUMP;\n    }\n\n    CASE(OP_DEF, BB) {\n      struct RClass *target = mrb_class_ptr(regs[a]);\n      struct RProc *p = mrb_proc_ptr(regs[a+1]);\n      mrb_method_t m;\n      mrb_sym mid = syms[b];\n\n      MRB_METHOD_FROM_PROC(m, p);\n      mrb_define_method_raw(mrb, target, mid, m);\n      mrb_method_added(mrb, target, mid);\n      mrb_gc_arena_restore(mrb, ai);\n      regs[a] = mrb_symbol_value(mid);\n      NEXT;\n    }\n\n    CASE(OP_SCLASS, B) {\n      regs[a] = mrb_singleton_class(mrb, regs[a]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_TCLASS, B) {\n      struct RClass *target = check_target_class(mrb);\n      if (!target) goto L_RAISE;\n      regs[a] = mrb_obj_value(target);\n      NEXT;\n    }\n\n    CASE(OP_ALIAS, BB) {\n      struct RClass *target = check_target_class(mrb);\n\n      if (!target) goto L_RAISE;\n      mrb_alias_method(mrb, target, syms[a], syms[b]);\n      mrb_method_added(mrb, target, syms[a]);\n      NEXT;\n    }\n    CASE(OP_UNDEF, B) {\n      struct RClass *target = check_target_class(mrb);\n\n      if (!target) goto L_RAISE;\n      mrb_undef_method_id(mrb, target, syms[a]);\n      NEXT;\n    }\n\n    CASE(OP_DEBUG, Z) {\n      FETCH_BBB();\n#ifdef MRB_USE_DEBUG_HOOK\n      mrb->debug_op_hook(mrb, irep, pc, regs);\n#else\n#ifndef MRB_NO_STDIO\n      printf(\"OP_DEBUG %d %d %d\\n\", a, b, c);\n#else\n      abort();\n#endif\n#endif\n      NEXT;\n    }\n\n    CASE(OP_ERR, B) {\n      size_t len = pool[a].tt >> 2;\n      mrb_value exc;\n\n      mrb_assert((pool[a].tt&IREP_TT_NFLAG)==0);\n      exc = mrb_exc_new(mrb, E_LOCALJUMP_ERROR, pool[a].u.str, len);\n      mrb_exc_set(mrb, exc);\n      goto L_RAISE;\n    }\n\n    CASE(OP_EXT1, Z) {\n      insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _1(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n    CASE(OP_EXT2, Z) {\n      insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _2(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n    CASE(OP_EXT3, Z) {\n      uint8_t insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _3(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n\n    CASE(OP_STOP, Z) {\n      /*        stop VM */\n      CHECKPOINT_RESTORE(RBREAK_TAG_STOP) {\n        /* do nothing */\n      }\n      CHECKPOINT_MAIN(RBREAK_TAG_STOP) {\n        UNWIND_ENSURE(mrb, mrb->c->ci, pc, RBREAK_TAG_STOP, proc, mrb_nil_value());\n      }\n      CHECKPOINT_END(RBREAK_TAG_STOP);\n    L_STOP:\n      mrb->jmp = prev_jmp;\n      if (mrb->exc) {\n        mrb_assert(mrb->exc->tt == MRB_TT_EXCEPTION);\n        return mrb_obj_value(mrb->exc);\n      }\n      return regs[irep->nlocals];\n    }\n  }\n  END_DISPATCH;\n#undef regs\n  }\n  MRB_CATCH(&c_jmp) {\n    mrb_callinfo *ci = mrb->c->ci;\n    while (ci > mrb->c->cibase && ci->cci == CINFO_DIRECT) {\n      ci = cipop(mrb);\n    }\n    exc_catched = TRUE;\n    pc = ci->pc;\n    goto RETRY_TRY_BLOCK;\n  }\n  MRB_END_EXC(&c_jmp);\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "vm.c",
        "method_name": "fixed_function",
        "raw_code": "mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)\n{\n  /* mrb_assert(MRB_PROC_CFUNC_P(proc)) */\n  const mrb_irep *irep = proc->body.irep;\n  const mrb_pool_value *pool = irep->pool;\n  const mrb_sym *syms = irep->syms;\n  mrb_code insn;\n  int ai = mrb_gc_arena_save(mrb);\n  struct mrb_jmpbuf *prev_jmp = mrb->jmp;\n  struct mrb_jmpbuf c_jmp;\n  uint32_t a;\n  uint16_t b;\n  uint16_t c;\n  mrb_sym mid;\n  const struct mrb_irep_catch_handler *ch;\n\n#ifdef DIRECT_THREADED\n  static const void * const optable[] = {\n#define OPCODE(x,_) &&L_OP_ ## x,\n#include \"mruby/ops.h\"\n#undef OPCODE\n  };\n#endif\n\n  mrb_bool exc_catched = FALSE;\nRETRY_TRY_BLOCK:\n\n  MRB_TRY(&c_jmp) {\n\n  if (exc_catched) {\n    exc_catched = FALSE;\n    mrb_gc_arena_restore(mrb, ai);\n    if (mrb->exc && mrb->exc->tt == MRB_TT_BREAK)\n      goto L_BREAK;\n    goto L_RAISE;\n  }\n  mrb->jmp = &c_jmp;\n  mrb_vm_ci_proc_set(mrb->c->ci, proc);\n\n#define regs (mrb->c->ci->stack)\n  INIT_DISPATCH {\n    CASE(OP_NOP, Z) {\n      /* do nothing */\n      NEXT;\n    }\n\n    CASE(OP_MOVE, BB) {\n      regs[a] = regs[b];\n      NEXT;\n    }\n\n    CASE(OP_LOADL, BB) {\n      switch (pool[b].tt) {   /* number */\n      case IREP_TT_INT32:\n        regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i32);\n        break;\n      case IREP_TT_INT64:\n#if defined(MRB_INT64)\n        regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);\n        break;\n#else\n#if defined(MRB_64BIT)\n        if (INT32_MIN <= pool[b].u.i64 && pool[b].u.i64 <= INT32_MAX) {\n          regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);\n          break;\n        }\n#endif\n        goto L_INT_OVERFLOW;\n#endif\n      case IREP_TT_BIGINT:\n#ifdef MRB_USE_BIGINT\n        {\n          const char *s = pool[b].u.str;\n          regs[a] = mrb_bint_new_str(mrb, s+2, (mrb_int)s[0], (mrb_int)s[1]);\n        }\n        break;\n#else\n        goto L_INT_OVERFLOW;\n#endif\n#ifndef MRB_NO_FLOAT\n      case IREP_TT_FLOAT:\n        regs[a] = mrb_float_value(mrb, pool[b].u.f);\n        break;\n#endif\n      default:\n        /* should not happen (tt:string) */\n        regs[a] = mrb_nil_value();\n        break;\n      }\n      NEXT;\n    }\n\n    CASE(OP_LOADI, BB) {\n      SET_FIXNUM_VALUE(regs[a], b);\n      NEXT;\n    }\n\n    CASE(OP_LOADINEG, BB) {\n      SET_FIXNUM_VALUE(regs[a], -b);\n      NEXT;\n    }\n\n    CASE(OP_LOADI__1,B) goto L_LOADI;\n    CASE(OP_LOADI_0,B) goto L_LOADI;\n    CASE(OP_LOADI_1,B) goto L_LOADI;\n    CASE(OP_LOADI_2,B) goto L_LOADI;\n    CASE(OP_LOADI_3,B) goto L_LOADI;\n    CASE(OP_LOADI_4,B) goto L_LOADI;\n    CASE(OP_LOADI_5,B) goto L_LOADI;\n    CASE(OP_LOADI_6,B) goto L_LOADI;\n    CASE(OP_LOADI_7, B) {\n    L_LOADI:\n      SET_FIXNUM_VALUE(regs[a], (mrb_int)insn - (mrb_int)OP_LOADI_0);\n      NEXT;\n    }\n\n    CASE(OP_LOADI16, BS) {\n      SET_FIXNUM_VALUE(regs[a], (mrb_int)(int16_t)b);\n      NEXT;\n    }\n\n    CASE(OP_LOADI32, BSS) {\n      SET_INT_VALUE(mrb, regs[a], (int32_t)(((uint32_t)b<<16)+c));\n      NEXT;\n    }\n\n    CASE(OP_LOADSYM, BB) {\n      SET_SYM_VALUE(regs[a], syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_LOADNIL, B) {\n      SET_NIL_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADSELF, B) {\n      regs[a] = regs[0];\n      NEXT;\n    }\n\n    CASE(OP_LOADT, B) {\n      SET_TRUE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADF, B) {\n      SET_FALSE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETGV, BB) {\n      mrb_value val = mrb_gv_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETGV, BB) {\n      mrb_gv_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETSV, BB) {\n      mrb_value val = mrb_vm_special_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETSV, BB) {\n      mrb_vm_special_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIV, BB) {\n      regs[a] = mrb_iv_get(mrb, regs[0], syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_SETIV, BB) {\n      mrb_iv_set(mrb, regs[0], syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETCV, BB) {\n      mrb_value val;\n      val = mrb_vm_cv_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETCV, BB) {\n      mrb_vm_cv_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIDX, B) {\n      mrb_value va = regs[a], vb = regs[a+1];\n      switch (mrb_type(va)) {\n      case MRB_TT_ARRAY:\n        if (!mrb_integer_p(vb)) goto getidx_fallback;\n        regs[a] = mrb_ary_entry(va, mrb_integer(vb));\n        break;\n      case MRB_TT_HASH:\n        va = mrb_hash_get(mrb, va, vb);\n        regs[a] = va;\n        break;\n      case MRB_TT_STRING:\n        switch (mrb_type(vb)) {\n        case MRB_TT_INTEGER:\n        case MRB_TT_STRING:\n        case MRB_TT_RANGE:\n          va = mrb_str_aref(mrb, va, vb, mrb_undef_value());\n          regs[a] = va;\n          break;\n        default:\n          goto getidx_fallback;\n        }\n        break;\n      default:\n      getidx_fallback:\n        mid = MRB_OPSYM(aref);\n        goto L_SEND_SYM;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SETIDX, B) {\n      c = 2;\n      mid = MRB_OPSYM(aset);\n      SET_NIL_VALUE(regs[a+3]);\n      goto L_SENDB_SYM;\n    }\n\n    CASE(OP_GETCONST, BB) {\n      mrb_value v = mrb_vm_const_get(mrb, syms[b]);\n      regs[a] = v;\n      NEXT;\n    }\n\n    CASE(OP_SETCONST, BB) {\n      mrb_vm_const_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETMCNST, BB) {\n      mrb_value v = mrb_const_get(mrb, regs[a], syms[b]);\n      regs[a] = v;\n      NEXT;\n    }\n\n    CASE(OP_SETMCNST, BB) {\n      mrb_const_set(mrb, regs[a+1], syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETUPVAR, BBB) {\n      mrb_value *regs_a = regs + a;\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e && b < MRB_ENV_LEN(e)) {\n        *regs_a = e->stack[b];\n      }\n      else {\n        *regs_a = mrb_nil_value();\n      }\n      NEXT;\n    }\n\n    CASE(OP_SETUPVAR, BBB) {\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e) {\n        mrb_value *regs_a = regs + a;\n\n        if (b < MRB_ENV_LEN(e)) {\n          e->stack[b] = *regs_a;\n          mrb_write_barrier(mrb, (struct RBasic*)e);\n        }\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMP, S) {\n      pc += (int16_t)a;\n      JUMP;\n    }\n    CASE(OP_JMPIF, BS) {\n      if (mrb_test(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n    CASE(OP_JMPNOT, BS) {\n      if (!mrb_test(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n    CASE(OP_JMPNIL, BS) {\n      if (mrb_nil_p(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMPUW, S) {\n      a = (uint32_t)((pc - irep->iseq) + (int16_t)a);\n      CHECKPOINT_RESTORE(RBREAK_TAG_JUMP) {\n        struct RBreak *brk = (struct RBreak*)mrb->exc;\n        mrb_value target = mrb_break_value_get(brk);\n        mrb_assert(mrb_integer_p(target));\n        a = (uint32_t)mrb_integer(target);\n        mrb_assert(a >= 0 && a < irep->ilen);\n      }\n      CHECKPOINT_MAIN(RBREAK_TAG_JUMP) {\n        ch = catch_handler_find(mrb, mrb->c->ci, pc, MRB_CATCH_FILTER_ENSURE);\n        if (ch) {\n          /* avoiding a jump from a catch handler into the same handler */\n          if (a < mrb_irep_catch_handler_unpack(ch->begin) || a >= mrb_irep_catch_handler_unpack(ch->end)) {\n            THROW_TAGGED_BREAK(mrb, RBREAK_TAG_JUMP, proc, mrb_fixnum_value(a));\n          }\n        }\n      }\n      CHECKPOINT_END(RBREAK_TAG_JUMP);\n\n      mrb->exc = NULL; /* clear break object */\n      pc = irep->iseq + a;\n      JUMP;\n    }\n\n    CASE(OP_EXCEPT, B) {\n      mrb_value exc;\n\n      if (mrb->exc == NULL) {\n        exc = mrb_nil_value();\n      }\n      else {\n        switch (mrb->exc->tt) {\n        case MRB_TT_BREAK:\n        case MRB_TT_EXCEPTION:\n          exc = mrb_obj_value(mrb->exc);\n          break;\n        default:\n          mrb_assert(!\"bad mrb_type\");\n          exc = mrb_nil_value();\n          break;\n        }\n        mrb->exc = NULL;\n      }\n      regs[a] = exc;\n      NEXT;\n    }\n    CASE(OP_RESCUE, BB) {\n      mrb_value exc = regs[a];  /* exc on stack */\n      mrb_value e = regs[b];\n      struct RClass *ec;\n\n      switch (mrb_type(e)) {\n      case MRB_TT_CLASS:\n      case MRB_TT_MODULE:\n        break;\n      default:\n        {\n          mrb_value exc;\n\n          exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                    \"class or module required for rescue clause\");\n          mrb_exc_set(mrb, exc);\n          goto L_RAISE;\n        }\n      }\n      ec = mrb_class_ptr(e);\n      regs[b] = mrb_bool_value(mrb_obj_is_kind_of(mrb, exc, ec));\n      NEXT;\n    }\n\n    CASE(OP_RAISEIF, B) {\n      mrb_value exc = regs[a];\n      if (mrb_break_p(exc)) {\n        mrb->exc = mrb_obj_ptr(exc);\n        goto L_BREAK;\n      }\n      mrb_exc_set(mrb, exc);\n      if (mrb->exc) {\n        goto L_RAISE;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SSEND, BBB) {\n      regs[a] = regs[0];\n      insn = OP_SEND;\n    }\n    goto L_SENDB;\n\n    CASE(OP_SSENDB, BBB) {\n      regs[a] = regs[0];\n    }\n    goto L_SENDB;\n\n    CASE(OP_SEND, BBB)\n    goto L_SENDB;\n\n    L_SEND_SYM:\n    c = 1;\n    /* push nil after arguments */\n    SET_NIL_VALUE(regs[a+2]);\n    goto L_SENDB_SYM;\n\n    CASE(OP_SENDB, BBB)\n    L_SENDB:\n    mid = syms[b];\n    L_SENDB_SYM:\n    {\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_method_t m;\n      struct RClass *cls;\n      mrb_value recv, blk;\n\n      ARGUMENT_NORMALIZE(a, &c, insn);\n\n      recv = regs[a];\n      cls = mrb_class(mrb, recv);\n      m = mrb_method_search_vm(mrb, &cls, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        m = prepare_missing(mrb, recv, mid, &cls, a, &c, blk, 0);\n        mid = MRB_SYM(method_missing);\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb, a, 0, cls, NULL, mid, c);\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        if (MRB_METHOD_PROC_P(m)) {\n          struct RProc *p = MRB_METHOD_PROC(m);\n\n          mrb_vm_ci_proc_set(ci, p);\n          recv = p->body.func(mrb, recv);\n        }\n        else {\n          if (MRB_METHOD_NOARG_P(m)) {\n            check_method_noarg(mrb, ci);\n          }\n          recv = MRB_METHOD_FUNC(m)(mrb, recv);\n        }\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        if (mrb_proc_p(blk)) {\n          struct RProc *p = mrb_proc_ptr(blk);\n          if (p && !MRB_PROC_STRICT_P(p) && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n        if (!ci->u.target_class) { /* return from context modifying method (resume/yield) */\n          if (ci->cci == CINFO_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return recv;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        ci->stack[0] = recv;\n        /* pop stackpos */\n        ci = cipop(mrb);\n        pc = ci->pc;\n      }\n      else {\n        /* setup environment for calling method */\n        mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);\n        pc = irep->iseq;\n      }\n    }\n    JUMP;\n\n    CASE(OP_CALL, Z) {\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv = ci->stack[0];\n      struct RProc *m = mrb_proc_ptr(recv);\n\n      /* replace callinfo */\n      ci->u.target_class = MRB_PROC_TARGET_CLASS(m);\n      mrb_vm_ci_proc_set(ci, m);\n      if (MRB_PROC_ENV_P(m)) {\n        ci->mid = MRB_PROC_ENV(m)->mid;\n      }\n\n      /* prepare stack */\n      if (MRB_PROC_CFUNC_P(m)) {\n        recv = MRB_PROC_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        /* pop stackpos */\n        ci = cipop(mrb);\n        pc = ci->pc;\n        ci[1].stack[0] = recv;\n        irep = mrb->c->ci->proc->body.irep;\n      }\n      else {\n        /* setup environment for calling method */\n        proc = m;\n        irep = m->body.irep;\n        if (!irep) {\n          mrb->c->ci->stack[0] = mrb_nil_value();\n          a = 0;\n          c = OP_R_NORMAL;\n          goto L_OP_RETURN_BODY;\n        }\n        mrb_int nargs = mrb_ci_bidx(ci)+1;\n        if (nargs < irep->nregs) {\n          mrb_stack_extend(mrb, irep->nregs);\n          stack_clear(regs+nargs, irep->nregs-nargs);\n        }\n        if (MRB_PROC_ENV_P(m)) {\n          regs[0] = MRB_PROC_ENV(m)->stack[0];\n        }\n        pc = irep->iseq;\n      }\n      pool = irep->pool;\n      syms = irep->syms;\n      JUMP;\n    }\n\n    CASE(OP_SUPER, BB) {\n      mrb_method_t m;\n      struct RClass *cls;\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv, blk;\n      const struct RProc *p = ci->proc;\n      mrb_sym mid = ci->mid;\n      struct RClass* target_class = MRB_PROC_TARGET_CLASS(p);\n\n      if (MRB_PROC_ENV_P(p) && p->e.env->mid && p->e.env->mid != mid) { /* alias support */\n        mid = p->e.env->mid;    /* restore old mid */\n      }\n\n      if (mid == 0 || !target_class) {\n        mrb_value exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if ((target_class->flags & MRB_FL_CLASS_IS_PREPENDED) || target_class->tt == MRB_TT_MODULE) {\n        target_class = mrb_vm_ci_target_class(ci);\n        if (!target_class || target_class->tt != MRB_TT_ICLASS) {\n          goto super_typeerror;\n        }\n      }\n      recv = regs[0];\n      if (!mrb_obj_is_kind_of(mrb, recv, target_class)) {\n      super_typeerror: ;\n        mrb_value exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                            \"self has wrong type to call super in this context\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n\n      ARGUMENT_NORMALIZE(a, &b, OP_SUPER);\n\n      cls = target_class->super;\n      m = mrb_method_search_vm(mrb, &cls, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        m = prepare_missing(mrb, recv, mid, &cls, a, &b, blk, 1);\n        mid = MRB_SYM(method_missing);\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb, a, 0, cls, NULL, mid, b);\n\n      /* prepare stack */\n      ci->stack[0] = recv;\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        mrb_value v;\n\n        if (MRB_METHOD_PROC_P(m)) {\n          mrb_vm_ci_proc_set(ci, MRB_METHOD_PROC(m));\n        }\n        v = MRB_METHOD_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_restore(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        mrb_assert(!mrb_break_p(v));\n        if (!mrb_vm_ci_target_class(ci)) { /* return from context modifying method (resume/yield) */\n          if (ci->cci == CINFO_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return v;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        mrb->c->ci->stack[0] = v;\n        ci = cipop(mrb);\n        pc = ci->pc;\n      }\n      else {\n        /* setup environment for calling method */\n        mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);\n        pc = irep->iseq;\n      }\n      JUMP;\n    }\n\n    CASE(OP_ARGARY, BS) {\n      mrb_int m1 = (b>>11)&0x3f;\n      mrb_int r  = (b>>10)&0x1;\n      mrb_int m2 = (b>>5)&0x1f;\n      mrb_int kd = (b>>4)&0x1;\n      mrb_int lv = (b>>0)&0xf;\n      mrb_value *stack;\n\n      if (mrb->c->ci->mid == 0 || mrb_vm_ci_target_class(mrb->c->ci) == NULL) {\n        mrb_value exc;\n\n      L_NOSUPER:\n        exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e) goto L_NOSUPER;\n        if (MRB_ENV_LEN(e) <= m1+r+m2+1)\n          goto L_NOSUPER;\n        stack = e->stack + 1;\n      }\n      if (r == 0) {\n        regs[a] = mrb_ary_new_from_values(mrb, m1+m2, stack);\n      }\n      else {\n        mrb_value *pp = NULL;\n        struct RArray *rest;\n        mrb_int len = 0;\n\n        if (mrb_array_p(stack[m1])) {\n          struct RArray *ary = mrb_ary_ptr(stack[m1]);\n\n          pp = ARY_PTR(ary);\n          len = ARY_LEN(ary);\n        }\n        regs[a] = mrb_ary_new_capa(mrb, m1+len+m2);\n        rest = mrb_ary_ptr(regs[a]);\n        if (m1 > 0) {\n          stack_copy(ARY_PTR(rest), stack, m1);\n        }\n        if (len > 0) {\n          stack_copy(ARY_PTR(rest)+m1, pp, len);\n        }\n        if (m2 > 0) {\n          stack_copy(ARY_PTR(rest)+m1+len, stack+m1+1, m2);\n        }\n        ARY_SET_LEN(rest, m1+len+m2);\n      }\n      if (kd) {\n        regs[a+1] = stack[m1+r+m2];\n        regs[a+2] = stack[m1+r+m2+1];\n      }\n      else {\n        regs[a+1] = stack[m1+r+m2];\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ENTER, W) {\n      mrb_int m1 = MRB_ASPEC_REQ(a);\n      mrb_int o  = MRB_ASPEC_OPT(a);\n      mrb_int r  = MRB_ASPEC_REST(a);\n      mrb_int m2 = MRB_ASPEC_POST(a);\n      mrb_int kd = (MRB_ASPEC_KEY(a) > 0 || MRB_ASPEC_KDICT(a))? 1 : 0;\n      /* unused\n      int b  = MRB_ASPEC_BLOCK(a);\n      */\n      mrb_int const len = m1 + o + r + m2;\n\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_int argc = ci->n;\n      mrb_value *argv = regs+1;\n      mrb_value * const argv0 = argv;\n      mrb_int const kw_pos = len + kd;    /* where kwhash should be */\n      mrb_int const blk_pos = kw_pos + 1; /* where block should be */\n      mrb_value blk = regs[mrb_ci_bidx(ci)];\n      mrb_value kdict = mrb_nil_value();\n\n      /* keyword arguments */\n      if (ci->nk > 0) {\n        mrb_int kidx = mrb_ci_kidx(ci);\n        kdict = regs[kidx];\n        if (!mrb_hash_p(kdict) || mrb_hash_size(mrb, kdict) == 0) {\n          kdict = mrb_nil_value();\n          ci->nk = 0;\n        }\n      }\n      if (!kd && !mrb_nil_p(kdict)) {\n        if (argc < 14) {\n          ci->n++;\n          argc++;    /* include kdict in normal arguments */\n        }\n        else if (argc == 14) {\n          /* pack arguments and kdict */\n          regs[1] = mrb_ary_new_from_values(mrb, argc+1, &regs[1]);\n          argc = ci->n = 15;\n        }\n        else {/* argc == 15 */\n          /* push kdict to packed arguments */\n          mrb_ary_push(mrb, regs[1], regs[2]);\n        }\n        ci->nk = 0;\n      }\n      if (kd && MRB_ASPEC_KEY(a) > 0 && mrb_hash_p(kdict)) {\n        kdict = mrb_hash_dup(mrb, kdict);\n      }\n\n      /* arguments is passed with Array */\n      if (argc == 15) {\n        struct RArray *ary = mrb_ary_ptr(regs[1]);\n        argv = ARY_PTR(ary);\n        argc = (int)ARY_LEN(ary);\n        mrb_gc_protect(mrb, regs[1]);\n      }\n\n      /* strict argument check */\n      if (ci->proc && MRB_PROC_STRICT_P(ci->proc)) {\n        if (argc < m1 + m2 || (r == 0 && argc > len)) {\n          argnum_error(mrb, m1+m2);\n          goto L_RAISE;\n        }\n      }\n      /* extract first argument array to arguments */\n      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {\n        mrb_gc_protect(mrb, argv[0]);\n        argc = (int)RARRAY_LEN(argv[0]);\n        argv = RARRAY_PTR(argv[0]);\n      }\n\n      /* rest arguments */\n      mrb_value rest = mrb_nil_value();\n      if (argc < len) {\n        mrb_int mlen = m2;\n        if (argc < m1+m2) {\n          mlen = m1 < argc ? argc - m1 : 0;\n        }\n\n        /* copy mandatory and optional arguments */\n        if (argv0 != argv && argv) {\n          value_move(&regs[1], argv, argc-mlen); /* m1 + o */\n        }\n        if (argc < m1) {\n          stack_clear(&regs[argc+1], m1-argc);\n        }\n        /* copy post mandatory arguments */\n        if (mlen) {\n          value_move(&regs[len-m2+1], &argv[argc-mlen], mlen);\n        }\n        if (mlen < m2) {\n          stack_clear(&regs[len-m2+mlen+1], m2-mlen);\n        }\n        /* initialize rest arguments with empty Array */\n        if (r) {\n          rest = mrb_ary_new_capa(mrb, 0);\n          regs[m1+o+1] = rest;\n        }\n        /* skip initializer of passed arguments */\n        if (o > 0 && argc > m1+m2)\n          pc += (argc - m1 - m2)*3;\n      }\n      else {\n        mrb_int rnum = 0;\n        if (argv0 != argv) {\n          value_move(&regs[1], argv, m1+o);\n        }\n        if (r) {\n          rnum = argc-m1-o-m2;\n          rest = mrb_ary_new_from_values(mrb, rnum, argv+m1+o);\n          regs[m1+o+1] = rest;\n        }\n        if (m2 > 0 && argc-m2 > m1) {\n          value_move(&regs[m1+o+r+1], &argv[m1+o+rnum], m2);\n        }\n        pc += o*3;\n      }\n\n      /* need to be update blk first to protect blk from GC */\n      regs[blk_pos] = blk;              /* move block */\n      if (kd) {\n        if (mrb_nil_p(kdict))\n          kdict = mrb_hash_new_capa(mrb, 0);\n        regs[kw_pos] = kdict;           /* set kwhash */\n      }\n\n      /* format arguments for generated code */\n      mrb->c->ci->n = (uint8_t)len;\n\n      /* clear local (but non-argument) variables */\n      if (irep->nlocals-blk_pos-1 > 0) {\n        stack_clear(&regs[blk_pos+1], irep->nlocals-blk_pos-1);\n      }\n      JUMP;\n    }\n\n    CASE(OP_KARG, BB) {\n      mrb_value k = mrb_symbol_value(syms[b]);\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict, v;\n\n      if (kidx < 0 || !mrb_hash_p(kdict=regs[kidx]) || !mrb_hash_key_p(mrb, kdict, k)) {\n        mrb_value str = mrb_format(mrb, \"missing keyword: %v\", k);\n        mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));\n        goto L_RAISE;\n      }\n      v = mrb_hash_get(mrb, kdict, k);\n      regs[a] = v;\n      mrb_hash_delete_key(mrb, kdict, k);\n      NEXT;\n    }\n\n    CASE(OP_KEY_P, BB) {\n      mrb_value k = mrb_symbol_value(syms[b]);\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict;\n      mrb_bool key_p = FALSE;\n\n      if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx])) {\n        key_p = mrb_hash_key_p(mrb, kdict, k);\n      }\n      regs[a] = mrb_bool_value(key_p);\n      NEXT;\n    }\n\n    CASE(OP_KEYEND, Z) {\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict;\n\n      if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx]) && !mrb_hash_empty_p(mrb, kdict)) {\n        mrb_value keys = mrb_hash_keys(mrb, kdict);\n        mrb_value key1 = RARRAY_PTR(keys)[0];\n        mrb_value str = mrb_format(mrb, \"unknown keyword: %v\", key1);\n        mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));\n        goto L_RAISE;\n      }\n      NEXT;\n    }\n\n    CASE(OP_BREAK, B) {\n      c = OP_R_BREAK;\n      goto L_RETURN;\n    }\n    CASE(OP_RETURN_BLK, B) {\n      c = OP_R_RETURN;\n      goto L_RETURN;\n    }\n    CASE(OP_RETURN, B)\n    c = OP_R_NORMAL;\n    L_RETURN:\n    {\n      mrb_callinfo *ci;\n\n      ci = mrb->c->ci;\n      if (ci->mid) {\n        mrb_value blk = regs[mrb_ci_bidx(ci)];\n\n        if (mrb_proc_p(blk)) {\n          struct RProc *p = mrb_proc_ptr(blk);\n\n          if (!MRB_PROC_STRICT_P(p) &&\n              ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n      }\n\n      if (mrb->exc) {\n      L_RAISE:\n        ci = mrb->c->ci;\n        if (ci == mrb->c->cibase) {\n          ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);\n          if (ch == NULL) goto L_FTOP;\n          goto L_CATCH;\n        }\n        while ((ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL)) == NULL) {\n          ci = cipop(mrb);\n          if (ci[1].cci == CINFO_SKIP && prev_jmp) {\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          pc = ci[0].pc;\n          if (ci == mrb->c->cibase) {\n            ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);\n            if (ch == NULL) {\n            L_FTOP:             /* fiber top */\n              if (mrb->c == mrb->root_c) {\n                mrb->c->ci->stack = mrb->c->stbase;\n                goto L_STOP;\n              }\n              else {\n                struct mrb_context *c = mrb->c;\n\n                c->status = MRB_FIBER_TERMINATED;\n                mrb->c = c->prev;\n                c->prev = NULL;\n                goto L_RAISE;\n              }\n            }\n            break;\n          }\n        }\n      L_CATCH:\n        if (ch == NULL) goto L_STOP;\n        if (FALSE) {\n        L_CATCH_TAGGED_BREAK: /* from THROW_TAGGED_BREAK() or UNWIND_ENSURE() */\n          ci = mrb->c->ci;\n        }\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, irep->nregs);\n        pc = irep->iseq + mrb_irep_catch_handler_unpack(ch->target);\n      }\n      else {\n        mrb_int acc;\n        mrb_value v;\n\n        ci = mrb->c->ci;\n        v = regs[a];\n        mrb_gc_protect(mrb, v);\n        switch (c) {\n        case OP_R_RETURN:\n          /* Fall through to OP_R_NORMAL otherwise */\n          if (ci->cci == CINFO_NONE && MRB_PROC_ENV_P(proc) && !MRB_PROC_STRICT_P(proc)) {\n            const struct RProc *dst;\n            mrb_callinfo *cibase;\n            cibase = mrb->c->cibase;\n            dst = top_proc(mrb, proc);\n\n            if (MRB_PROC_ENV_P(dst)) {\n              struct REnv *e = MRB_PROC_ENV(dst);\n\n              if (!MRB_ENV_ONSTACK_P(e) || (e->cxt && e->cxt != mrb->c)) {\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n            }\n            /* check jump destination */\n            while (cibase <= ci && ci->proc != dst) {\n              if (ci->cci > CINFO_NONE) { /* jump cross C boundary */\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n              ci--;\n            }\n            if (ci <= cibase) { /* no jump destination */\n              localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n              goto L_RAISE;\n            }\n            ci = mrb->c->ci;\n            while (cibase <= ci && ci->proc != dst) {\n              CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_BLOCK) {\n                cibase = mrb->c->cibase;\n                dst = top_proc(mrb, proc);\n              }\n              CHECKPOINT_MAIN(RBREAK_TAG_RETURN_BLOCK) {\n                UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_BLOCK, proc, v);\n              }\n              CHECKPOINT_END(RBREAK_TAG_RETURN_BLOCK);\n              ci = cipop(mrb);\n              pc = ci->pc;\n            }\n            proc = ci->proc;\n            mrb->exc = NULL; /* clear break object */\n            break;\n          }\n          /* fallthrough */\n        case OP_R_NORMAL:\n        NORMAL_RETURN:\n          if (ci == mrb->c->cibase) {\n            struct mrb_context *c;\n            c = mrb->c;\n\n            if (!c->prev) { /* toplevel return */\n              regs[irep->nlocals] = v;\n              goto CHECKPOINT_LABEL_MAKE(RBREAK_TAG_STOP);\n            }\n            if (!c->vmexec && c->prev->ci == c->prev->cibase) {\n              mrb_value exc = mrb_exc_new_lit(mrb, E_FIBER_ERROR, \"double resume\");\n              mrb_exc_set(mrb, exc);\n              goto L_RAISE;\n            }\n            CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_TOPLEVEL) {\n              c = mrb->c;\n            }\n            CHECKPOINT_MAIN(RBREAK_TAG_RETURN_TOPLEVEL) {\n              UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_TOPLEVEL, proc, v);\n            }\n            CHECKPOINT_END(RBREAK_TAG_RETURN_TOPLEVEL);\n            /* automatic yield at the end */\n            c->status = MRB_FIBER_TERMINATED;\n            mrb->c = c->prev;\n            mrb->c->status = MRB_FIBER_RUNNING;\n            c->prev = NULL;\n            if (c->vmexec) {\n              mrb_gc_arena_restore(mrb, ai);\n              c->vmexec = FALSE;\n              mrb->jmp = prev_jmp;\n              return v;\n            }\n            ci = mrb->c->ci;\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_RETURN) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_RETURN) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_RETURN);\n          mrb->exc = NULL; /* clear break object */\n          break;\n        case OP_R_BREAK:\n          if (MRB_PROC_STRICT_P(proc)) goto NORMAL_RETURN;\n          if (MRB_PROC_ORPHAN_P(proc)) {\n            mrb_value exc;\n\n          L_BREAK_ERROR:\n            exc = mrb_exc_new_lit(mrb, E_LOCALJUMP_ERROR,\n                                      \"break from proc-closure\");\n            mrb_exc_set(mrb, exc);\n            goto L_RAISE;\n          }\n          if (!MRB_PROC_ENV_P(proc) || !MRB_ENV_ONSTACK_P(MRB_PROC_ENV(proc))) {\n            goto L_BREAK_ERROR;\n          }\n          else {\n            struct REnv *e = MRB_PROC_ENV(proc);\n\n            if (e->cxt != mrb->c) {\n              goto L_BREAK_ERROR;\n            }\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_BREAK) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_BREAK);\n          /* break from fiber block */\n          if (ci == mrb->c->cibase && ci->pc) {\n            struct mrb_context *c = mrb->c;\n\n            mrb->c = c->prev;\n            c->prev = NULL;\n            ci = mrb->c->ci;\n          }\n          if (ci->cci > CINFO_NONE) {\n            ci = cipop(mrb);\n            mrb->exc = (struct RObject*)break_new(mrb, RBREAK_TAG_BREAK, proc, v);\n            mrb_gc_arena_restore(mrb, ai);\n            mrb->c->vmexec = FALSE;\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          if (FALSE) {\n            struct RBreak *brk;\n\n          L_BREAK:\n            brk = (struct RBreak*)mrb->exc;\n            proc = mrb_break_proc_get(brk);\n            v = mrb_break_value_get(brk);\n            ci = mrb->c->ci;\n\n            switch (mrb_break_tag_get(brk)) {\n#define DISPATCH_CHECKPOINTS(n, i) case n: goto CHECKPOINT_LABEL_MAKE(n);\n              RBREAK_TAG_FOREACH(DISPATCH_CHECKPOINTS)\n#undef DISPATCH_CHECKPOINTS\n              default:\n                mrb_assert(!\"wrong break tag\");\n            }\n          }\n          while (mrb->c->cibase < ci && ci[-1].proc != proc->upper) {\n            if (ci[-1].cci == CINFO_SKIP) {\n              goto L_BREAK_ERROR;\n            }\n            CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_UPPER) {\n              /* do nothing */\n            }\n            CHECKPOINT_MAIN(RBREAK_TAG_BREAK_UPPER) {\n              UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_UPPER, proc, v);\n            }\n            CHECKPOINT_END(RBREAK_TAG_BREAK_UPPER);\n            ci = cipop(mrb);\n            pc = ci->pc;\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_INTARGET) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_BREAK_INTARGET) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_INTARGET, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_BREAK_INTARGET);\n          if (ci == mrb->c->cibase) {\n            goto L_BREAK_ERROR;\n          }\n          mrb->exc = NULL; /* clear break object */\n          break;\n        default:\n          /* cannot happen */\n          break;\n        }\n        mrb_assert(ci == mrb->c->ci);\n        mrb_assert(mrb->exc == NULL);\n\n        if (mrb->c->vmexec && !mrb_vm_ci_target_class(ci)) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->c->vmexec = FALSE;\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        acc = ci->cci;\n        ci = cipop(mrb);\n        if (acc == CINFO_SKIP || acc == CINFO_DIRECT) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        pc = ci->pc;\n        DEBUG(fprintf(stderr, \"from :%s\\n\", mrb_sym_name(mrb, ci->mid)));\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n\n        ci[1].stack[0] = v;\n        mrb_gc_arena_restore(mrb, ai);\n      }\n      JUMP;\n    }\n\n    CASE(OP_BLKPUSH, BS) {\n      int m1 = (b>>11)&0x3f;\n      int r  = (b>>10)&0x1;\n      int m2 = (b>>5)&0x1f;\n      int kd = (b>>4)&0x1;\n      int lv = (b>>0)&0xf;\n      mrb_value *stack;\n\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e || (!MRB_ENV_ONSTACK_P(e) && e->mid == 0) ||\n            MRB_ENV_LEN(e) <= m1+r+m2+1) {\n          localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n          goto L_RAISE;\n        }\n        stack = e->stack + 1;\n      }\n      if (mrb_nil_p(stack[m1+r+m2+kd])) {\n        localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n        goto L_RAISE;\n      }\n      regs[a] = stack[m1+r+m2+kd];\n      NEXT;\n    }\n\n#if !defined(MRB_USE_BIGINT) || defined(MRB_INT32)\n  L_INT_OVERFLOW:\n    {\n      mrb_value exc = mrb_exc_new_lit(mrb, E_RANGE_ERROR, \"integer overflow\");\n      mrb_exc_set(mrb, exc);\n    }\n    goto L_RAISE;\n#endif\n\n#define TYPES2(a,b) ((((uint16_t)(a))<<8)|(((uint16_t)(b))&0xff))\n#define OP_MATH(op_name)                                                    \\\n  /* need to check if op is overridden */                                   \\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {                  \\\n    OP_MATH_CASE_INTEGER(op_name);                                          \\\n    OP_MATH_CASE_FLOAT(op_name, integer, float);                            \\\n    OP_MATH_CASE_FLOAT(op_name, float,  integer);                           \\\n    OP_MATH_CASE_FLOAT(op_name, float,  float);                             \\\n    OP_MATH_CASE_STRING_##op_name();                                        \\\n    default:                                                                \\\n      mid = MRB_OPSYM(op_name);                                             \\\n      goto L_SEND_SYM;                                                      \\\n  }                                                                         \\\n  NEXT;\n#define OP_MATH_CASE_INTEGER(op_name)                                       \\\n  case TYPES2(MRB_TT_INTEGER, MRB_TT_INTEGER):                              \\\n    {                                                                       \\\n      mrb_int x = mrb_integer(regs[a]), y = mrb_integer(regs[a+1]), z;      \\\n      if (mrb_int_##op_name##_overflow(x, y, &z)) {                         \\\n        OP_MATH_OVERFLOW_INT(op_name,x,y);                                  \\\n      }                                                                     \\\n      else                                                                  \\\n        SET_INT_VALUE(mrb,regs[a], z);                                      \\\n    }                                                                       \\\n    break\n#ifdef MRB_NO_FLOAT\n#define OP_MATH_CASE_FLOAT(op_name, t1, t2) (void)0\n#else\n#define OP_MATH_CASE_FLOAT(op_name, t1, t2)                                     \\\n  case TYPES2(OP_MATH_TT_##t1, OP_MATH_TT_##t2):                                \\\n    {                                                                           \\\n      mrb_float z = mrb_##t1(regs[a]) OP_MATH_OP_##op_name mrb_##t2(regs[a+1]); \\\n      SET_FLOAT_VALUE(mrb, regs[a], z);                                         \\\n    }                                                                           \\\n    break\n#endif\n#ifdef MRB_USE_BIGINT\n#define OP_MATH_OVERFLOW_INT(op,x,y) regs[a] = mrb_bint_##op##_ii(mrb,x,y)\n#else\n#define OP_MATH_OVERFLOW_INT(op,x,y) goto L_INT_OVERFLOW\n#endif\n#define OP_MATH_CASE_STRING_add()                                           \\\n  case TYPES2(MRB_TT_STRING, MRB_TT_STRING):                                \\\n    regs[a] = mrb_str_plus(mrb, regs[a], regs[a+1]);                        \\\n    mrb_gc_arena_restore(mrb, ai);                                          \\\n    break\n#define OP_MATH_CASE_STRING_sub() (void)0\n#define OP_MATH_CASE_STRING_mul() (void)0\n#define OP_MATH_OP_add +\n#define OP_MATH_OP_sub -\n#define OP_MATH_OP_mul *\n#define OP_MATH_TT_integer MRB_TT_INTEGER\n#define OP_MATH_TT_float   MRB_TT_FLOAT\n\n    CASE(OP_ADD, B) {\n      OP_MATH(add);\n    }\n\n    CASE(OP_SUB, B) {\n      OP_MATH(sub);\n    }\n\n    CASE(OP_MUL, B) {\n      OP_MATH(mul);\n    }\n\n    CASE(OP_DIV, B) {\n#ifndef MRB_NO_FLOAT\n      mrb_float x, y, f;\n#endif\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\n        {\n          mrb_int x = mrb_integer(regs[a]);\n          mrb_int y = mrb_integer(regs[a+1]);\n          mrb_int div = mrb_div_int(mrb, x, y);\n          SET_INT_VALUE(mrb, regs[a], div);\n        }\n        NEXT;\n#ifndef MRB_NO_FLOAT\n      case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\n        x = (mrb_float)mrb_integer(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\n        x = mrb_float(regs[a]);\n        y = (mrb_float)mrb_integer(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n        x = mrb_float(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n#endif\n      default:\n        mid = MRB_OPSYM(div);\n        goto L_SEND_SYM;\n      }\n\n#ifndef MRB_NO_FLOAT\n      f = mrb_div_float(x, y);\n      SET_FLOAT_VALUE(mrb, regs[a], f);\n#endif\n      NEXT;\n    }\n\n#define OP_MATHI(op_name)                                                   \\\n  /* need to check if op is overridden */                                   \\\n  switch (mrb_type(regs[a])) {                                              \\\n    OP_MATHI_CASE_INTEGER(op_name);                                         \\\n    OP_MATHI_CASE_FLOAT(op_name);                                           \\\n    default:                                                                \\\n      SET_INT_VALUE(mrb,regs[a+1], b);                                      \\\n      mid = MRB_OPSYM(op_name);                                             \\\n      goto L_SEND_SYM;                                                      \\\n  }                                                                         \\\n  NEXT;\n#define OP_MATHI_CASE_INTEGER(op_name)                                      \\\n  case MRB_TT_INTEGER:                                                      \\\n    {                                                                       \\\n      mrb_int x = mrb_integer(regs[a]), y = (mrb_int)b, z;                  \\\n      if (mrb_int_##op_name##_overflow(x, y, &z)) {                         \\\n        OP_MATH_OVERFLOW_INT(op_name,x,y);                                  \\\n      }                                                                     \\\n      else                                                                  \\\n        SET_INT_VALUE(mrb,regs[a], z);                                      \\\n    }                                                                       \\\n    break\n#ifdef MRB_NO_FLOAT\n#define OP_MATHI_CASE_FLOAT(op_name) (void)0\n#else\n#define OP_MATHI_CASE_FLOAT(op_name)                                        \\\n  case MRB_TT_FLOAT:                                                        \\\n    {                                                                       \\\n      mrb_float z = mrb_float(regs[a]) OP_MATH_OP_##op_name b;              \\\n      SET_FLOAT_VALUE(mrb, regs[a], z);                                     \\\n    }                                                                       \\\n    break\n#endif\n\n    CASE(OP_ADDI, BB) {\n      OP_MATHI(add);\n    }\n\n    CASE(OP_SUBI, BB) {\n      OP_MATHI(sub);\n    }\n\n#define OP_CMP_BODY(op,v1,v2) (v1(regs[a]) op v2(regs[a+1]))\n\n#ifdef MRB_NO_FLOAT\n#define OP_CMP(op,sym) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  default:\\\n    mid = MRB_OPSYM(sym);\\\n    goto L_SEND_SYM;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#else\n#define OP_CMP(op, sym) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_float);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_float);\\\n    break;\\\n  default:\\\n    mid = MRB_OPSYM(sym);\\\n    goto L_SEND_SYM;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#endif\n\n    CASE(OP_EQ, B) {\n      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {\n        SET_TRUE_VALUE(regs[a]);\n      }\n      else {\n        OP_CMP(==,eq);\n      }\n      NEXT;\n    }\n\n    CASE(OP_LT, B) {\n      OP_CMP(<,lt);\n      NEXT;\n    }\n\n    CASE(OP_LE, B) {\n      OP_CMP(<=,le);\n      NEXT;\n    }\n\n    CASE(OP_GT, B) {\n      OP_CMP(>,gt);\n      NEXT;\n    }\n\n    CASE(OP_GE, B) {\n      OP_CMP(>=,ge);\n      NEXT;\n    }\n\n    CASE(OP_ARRAY, BB) {\n      regs[a] = mrb_ary_new_from_values(mrb, b, &regs[a]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_ARRAY2, BBB) {\n      regs[a] = mrb_ary_new_from_values(mrb, c, &regs[b]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYCAT, B) {\n      mrb_value splat = mrb_ary_splat(mrb, regs[a+1]);\n      if (mrb_nil_p(regs[a])) {\n        regs[a] = splat;\n      }\n      else {\n        mrb_assert(mrb_array_p(regs[a]));\n        mrb_ary_concat(mrb, regs[a], splat);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYPUSH, BB) {\n      mrb_assert(mrb_array_p(regs[a]));\n      for (mrb_int i=0; i<b; i++) {\n        mrb_ary_push(mrb, regs[a], regs[a+i+1]);\n      }\n      NEXT;\n    }\n\n    CASE(OP_ARYDUP, B) {\n      mrb_value ary = regs[a];\n      if (mrb_array_p(ary)) {\n        ary = mrb_ary_new_from_values(mrb, RARRAY_LEN(ary), RARRAY_PTR(ary));\n      }\n      else {\n        ary = mrb_ary_new_from_values(mrb, 1, &ary);\n      }\n      regs[a] = ary;\n      NEXT;\n    }\n\n    CASE(OP_AREF, BBB) {\n      mrb_value v = regs[b];\n\n      if (!mrb_array_p(v)) {\n        if (c == 0) {\n          regs[a] = v;\n        }\n        else {\n          SET_NIL_VALUE(regs[a]);\n        }\n      }\n      else {\n        v = mrb_ary_ref(mrb, v, c);\n        regs[a] = v;\n      }\n      NEXT;\n    }\n\n    CASE(OP_ASET, BBB) {\n      mrb_assert(mrb_array_p(regs[a]));\n      mrb_ary_set(mrb, regs[b], c, regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_APOST, BBB) {\n      mrb_value v = regs[a];\n      int pre  = b;\n      int post = c;\n      struct RArray *ary;\n      int len, idx;\n\n      if (!mrb_array_p(v)) {\n        v = mrb_ary_new_from_values(mrb, 1, &regs[a]);\n      }\n      ary = mrb_ary_ptr(v);\n      len = (int)ARY_LEN(ary);\n      if (len > pre + post) {\n        v = mrb_ary_new_from_values(mrb, len - pre - post, ARY_PTR(ary)+pre);\n        regs[a++] = v;\n        while (post--) {\n          regs[a++] = ARY_PTR(ary)[len-post-1];\n        }\n      }\n      else {\n        v = mrb_ary_new_capa(mrb, 0);\n        regs[a++] = v;\n        for (idx=0; idx+pre<len; idx++) {\n          regs[a+idx] = ARY_PTR(ary)[pre+idx];\n        }\n        while (idx < post) {\n          SET_NIL_VALUE(regs[a+idx]);\n          idx++;\n        }\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_INTERN, B) {\n      mrb_assert(mrb_string_p(regs[a]));\n      mrb_sym sym = mrb_intern_str(mrb, regs[a]);\n      regs[a] = mrb_symbol_value(sym);\n      NEXT;\n    }\n\n    CASE(OP_SYMBOL, BB) {\n      size_t len;\n      mrb_sym sym;\n\n      mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);\n      len = pool[b].tt >> 2;\n      if (pool[b].tt & IREP_TT_SFLAG) {\n        sym = mrb_intern_static(mrb, pool[b].u.str, len);\n      }\n      else {\n        sym  = mrb_intern(mrb, pool[b].u.str, len);\n      }\n      regs[a] = mrb_symbol_value(sym);\n      NEXT;\n    }\n\n    CASE(OP_STRING, BB) {\n      mrb_int len;\n\n      mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);\n      len = pool[b].tt >> 2;\n      if (pool[b].tt & IREP_TT_SFLAG) {\n        regs[a] = mrb_str_new_static(mrb, pool[b].u.str, len);\n      }\n      else {\n        regs[a] = mrb_str_new(mrb, pool[b].u.str, len);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_STRCAT, B) {\n      mrb_assert(mrb_string_p(regs[a]));\n      mrb_str_concat(mrb, regs[a], regs[a+1]);\n      NEXT;\n    }\n\n    CASE(OP_HASH, BB) {\n      mrb_value hash = mrb_hash_new_capa(mrb, b);\n      int i;\n      int lim = a+b*2;\n\n      for (i=a; i<lim; i+=2) {\n        mrb_hash_set(mrb, hash, regs[i], regs[i+1]);\n      }\n      regs[a] = hash;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_HASHADD, BB) {\n      mrb_value hash;\n      int i;\n      int lim = a+b*2+1;\n\n      hash = regs[a];\n      mrb_ensure_hash_type(mrb, hash);\n      for (i=a+1; i<lim; i+=2) {\n        mrb_hash_set(mrb, hash, regs[i], regs[i+1]);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_HASHCAT, B) {\n      mrb_value hash = regs[a];\n\n      mrb_assert(mrb_hash_p(hash));\n      mrb_hash_merge(mrb, hash, regs[a+1]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_LAMBDA, BB)\n    c = OP_L_LAMBDA;\n    L_MAKE_LAMBDA:\n    {\n      struct RProc *p;\n      const mrb_irep *nirep = irep->reps[b];\n\n      if (c & OP_L_CAPTURE) {\n        p = mrb_closure_new(mrb, nirep);\n      }\n      else {\n        p = mrb_proc_new(mrb, nirep);\n        p->flags |= MRB_PROC_SCOPE;\n      }\n      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;\n      regs[a] = mrb_obj_value(p);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_BLOCK, BB) {\n      c = OP_L_BLOCK;\n      goto L_MAKE_LAMBDA;\n    }\n    CASE(OP_METHOD, BB) {\n      c = OP_L_METHOD;\n      goto L_MAKE_LAMBDA;\n    }\n\n    CASE(OP_RANGE_INC, B) {\n      mrb_value v = mrb_range_new(mrb, regs[a], regs[a+1], FALSE);\n      regs[a] = v;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_RANGE_EXC, B) {\n      mrb_value v = mrb_range_new(mrb, regs[a], regs[a+1], TRUE);\n      regs[a] = v;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_OCLASS, B) {\n      regs[a] = mrb_obj_value(mrb->object_class);\n      NEXT;\n    }\n\n    CASE(OP_CLASS, BB) {\n      struct RClass *c = 0, *baseclass;\n      mrb_value base, super;\n      mrb_sym id = syms[b];\n\n      base = regs[a];\n      super = regs[a+1];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        if (!baseclass) baseclass = mrb->object_class;\n        base = mrb_obj_value(baseclass);\n      }\n      c = mrb_vm_define_class(mrb, base, super, id);\n      regs[a] = mrb_obj_value(c);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_MODULE, BB) {\n      struct RClass *cls = 0, *baseclass;\n      mrb_value base;\n      mrb_sym id = syms[b];\n\n      base = regs[a];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        if (!baseclass) baseclass = mrb->object_class;\n        base = mrb_obj_value(baseclass);\n      }\n      cls = mrb_vm_define_module(mrb, base, id);\n      regs[a] = mrb_obj_value(cls);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_EXEC, BB)\n    {\n      mrb_value recv = regs[a];\n      struct RProc *p;\n      const mrb_irep *nirep = irep->reps[b];\n\n      /* prepare closure */\n      p = mrb_proc_new(mrb, nirep);\n      p->c = NULL;\n      mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)proc);\n      MRB_PROC_SET_TARGET_CLASS(p, mrb_class_ptr(recv));\n      p->flags |= MRB_PROC_SCOPE;\n\n      /* prepare call stack */\n      cipush(mrb, a, 0, mrb_class_ptr(recv), p, 0, 0);\n\n      irep = p->body.irep;\n      pool = irep->pool;\n      syms = irep->syms;\n      mrb_stack_extend(mrb, irep->nregs);\n      stack_clear(regs+1, irep->nregs-1);\n      pc = irep->iseq;\n      JUMP;\n    }\n\n    CASE(OP_DEF, BB) {\n      struct RClass *target = mrb_class_ptr(regs[a]);\n      struct RProc *p = mrb_proc_ptr(regs[a+1]);\n      mrb_method_t m;\n      mrb_sym mid = syms[b];\n\n      MRB_METHOD_FROM_PROC(m, p);\n      mrb_define_method_raw(mrb, target, mid, m);\n      mrb_method_added(mrb, target, mid);\n      mrb_gc_arena_restore(mrb, ai);\n      regs[a] = mrb_symbol_value(mid);\n      NEXT;\n    }\n\n    CASE(OP_SCLASS, B) {\n      regs[a] = mrb_singleton_class(mrb, regs[a]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_TCLASS, B) {\n      struct RClass *target = check_target_class(mrb);\n      if (!target) goto L_RAISE;\n      regs[a] = mrb_obj_value(target);\n      NEXT;\n    }\n\n    CASE(OP_ALIAS, BB) {\n      struct RClass *target = check_target_class(mrb);\n\n      if (!target) goto L_RAISE;\n      mrb_alias_method(mrb, target, syms[a], syms[b]);\n      mrb_method_added(mrb, target, syms[a]);\n      NEXT;\n    }\n    CASE(OP_UNDEF, B) {\n      struct RClass *target = check_target_class(mrb);\n\n      if (!target) goto L_RAISE;\n      mrb_undef_method_id(mrb, target, syms[a]);\n      NEXT;\n    }\n\n    CASE(OP_DEBUG, Z) {\n      FETCH_BBB();\n#ifdef MRB_USE_DEBUG_HOOK\n      mrb->debug_op_hook(mrb, irep, pc, regs);\n#else\n#ifndef MRB_NO_STDIO\n      printf(\"OP_DEBUG %d %d %d\\n\", a, b, c);\n#else\n      abort();\n#endif\n#endif\n      NEXT;\n    }\n\n    CASE(OP_ERR, B) {\n      size_t len = pool[a].tt >> 2;\n      mrb_value exc;\n\n      mrb_assert((pool[a].tt&IREP_TT_NFLAG)==0);\n      exc = mrb_exc_new(mrb, E_LOCALJUMP_ERROR, pool[a].u.str, len);\n      mrb_exc_set(mrb, exc);\n      goto L_RAISE;\n    }\n\n    CASE(OP_EXT1, Z) {\n      insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _1(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n    CASE(OP_EXT2, Z) {\n      insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _2(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n    CASE(OP_EXT3, Z) {\n      uint8_t insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _3(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n\n    CASE(OP_STOP, Z) {\n      /*        stop VM */\n      CHECKPOINT_RESTORE(RBREAK_TAG_STOP) {\n        /* do nothing */\n      }\n      CHECKPOINT_MAIN(RBREAK_TAG_STOP) {\n        UNWIND_ENSURE(mrb, mrb->c->ci, pc, RBREAK_TAG_STOP, proc, mrb_nil_value());\n      }\n      CHECKPOINT_END(RBREAK_TAG_STOP);\n    L_STOP:\n      mrb->jmp = prev_jmp;\n      if (mrb->exc) {\n        mrb_assert(mrb->exc->tt == MRB_TT_EXCEPTION);\n        return mrb_obj_value(mrb->exc);\n      }\n      return regs[irep->nlocals];\n    }\n  }\n  END_DISPATCH;\n#undef regs\n  }\n  MRB_CATCH(&c_jmp) {\n    mrb_callinfo *ci = mrb->c->ci;\n    while (ci > mrb->c->cibase && ci->cci == CINFO_DIRECT) {\n      ci = cipop(mrb);\n    }\n    exc_catched = TRUE;\n    pc = ci->pc;\n    goto RETRY_TRY_BLOCK;\n  }\n  MRB_END_EXC(&c_jmp);\n}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "tar",
    "cve_id": "CVE-2019-9923",
    "cwe_list": [
      "CWE-476"
    ],
    "commit_hash": "cb07844454d8cc9fb21f53ace75975f91185a120",
    "short_hash": "cb078444",
    "vulnerableMethods_before": [
      {
        "filename": "None",
        "method_name": "vulnerable_function",
        "raw_code": "pax_decode_header (struct tar_sparse_file *file)\n{\n  if (file->stat_info->sparse_major > 0)\n    {\n      uintmax_t u;\n      char nbuf[UINTMAX_STRSIZE_BOUND];\n      union block *blk;\n      char *p;\n      size_t i;\n      off_t start;\n      \n#define COPY_BUF(b,buf,src) do                                     \\\n {                                                                 \\\n   char *endp = b->buffer + BLOCKSIZE;                             \\\n   char *dst = buf;                                                \\\n   do                                                              \\\n     {                                                             \\\n       if (dst == buf + UINTMAX_STRSIZE_BOUND -1)                  \\\n         {                                                         \\\n           ERROR ((0, 0, _(\"%s: numeric overflow in sparse archive member\"), \\\n\t          file->stat_info->orig_file_name));               \\\n           return false;                                           \\\n         }                                                         \\\n       if (src == endp)                                            \\\n\t {                                                         \\\n\t   set_next_block_after (b);                               \\\n           b = find_next_block ();                                 \\\n           src = b->buffer;                                        \\\n\t   endp = b->buffer + BLOCKSIZE;                           \\\n\t }                                                         \\\n       *dst = *src++;                                              \\\n     }                                                             \\\n   while (*dst++ != '\\n');                                         \\\n   dst[-1] = 0;                                                    \\\n } while (0)\n\n      start = current_block_ordinal ();\n      set_next_block_after (current_header);\n      blk = find_next_block ();\n      p = blk->buffer;\n      COPY_BUF (blk,nbuf,p);\n      if (!decode_num (&u, nbuf, TYPE_MAXIMUM (size_t)))\n\t{\n\t  ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t  file->stat_info->orig_file_name));\n\t  return false;\n\t}\n      file->stat_info->sparse_map_size = u;\n      file->stat_info->sparse_map = xcalloc (file->stat_info->sparse_map_size,\n\t\t\t\t\t     sizeof (*file->stat_info->sparse_map));\n      file->stat_info->sparse_map_avail = 0;\n      for (i = 0; i < file->stat_info->sparse_map_size; i++)\n\t{\n\t  struct sp_array sp;\n\n\t  COPY_BUF (blk,nbuf,p);\n\t  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))\n\t    {\n\t      ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t      file->stat_info->orig_file_name));\n\t      return false;\n\t    }\n\t  sp.offset = u;\n\t  COPY_BUF (blk,nbuf,p);\n\t  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))\n\t    {\n\t      ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t      file->stat_info->orig_file_name));\n\t      return false;\n\t    }\n\t  sp.numbytes = u;\n\t  sparse_add_map (file->stat_info, &sp);\n\t}\n      set_next_block_after (blk);\n\n      file->dumped_size += BLOCKSIZE * (current_block_ordinal () - start);\n    }\n\n  return true;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "None",
        "method_name": "fixed_function",
        "raw_code": "pax_decode_header (struct tar_sparse_file *file)\n{\n  if (file->stat_info->sparse_major > 0)\n    {\n      uintmax_t u;\n      char nbuf[UINTMAX_STRSIZE_BOUND];\n      union block *blk;\n      char *p;\n      size_t i;\n      off_t start;\n      \n#define COPY_BUF(b,buf,src) do                                     \\\n {                                                                 \\\n   char *endp = b->buffer + BLOCKSIZE;                             \\\n   char *dst = buf;                                                \\\n   do                                                              \\\n     {                                                             \\\n       if (dst == buf + UINTMAX_STRSIZE_BOUND -1)                  \\\n         {                                                         \\\n           ERROR ((0, 0, _(\"%s: numeric overflow in sparse archive member\"), \\\n\t          file->stat_info->orig_file_name));               \\\n           return false;                                           \\\n         }                                                         \\\n       if (src == endp)                                            \\\n\t {                                                         \\\n\t   set_next_block_after (b);                               \\\n           b = find_next_block ();                                 \\\n           if (!b)                                                 \\\n             FATAL_ERROR ((0, 0, _(\"Unexpected EOF in archive\"))); \\\n           src = b->buffer;                                        \\\n\t   endp = b->buffer + BLOCKSIZE;                           \\\n\t }                                                         \\\n       *dst = *src++;                                              \\\n     }                                                             \\\n   while (*dst++ != '\\n');                                         \\\n   dst[-1] = 0;                                                    \\\n } while (0)\n\n      start = current_block_ordinal ();\n      set_next_block_after (current_header);\n      blk = find_next_block ();\n      if (!blk)\n        FATAL_ERROR ((0, 0, _(\"Unexpected EOF in archive\")));\n      p = blk->buffer;\n      COPY_BUF (blk,nbuf,p);\n      if (!decode_num (&u, nbuf, TYPE_MAXIMUM (size_t)))\n\t{\n\t  ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t  file->stat_info->orig_file_name));\n\t  return false;\n\t}\n      file->stat_info->sparse_map_size = u;\n      file->stat_info->sparse_map = xcalloc (file->stat_info->sparse_map_size,\n\t\t\t\t\t     sizeof (*file->stat_info->sparse_map));\n      file->stat_info->sparse_map_avail = 0;\n      for (i = 0; i < file->stat_info->sparse_map_size; i++)\n\t{\n\t  struct sp_array sp;\n\n\t  COPY_BUF (blk,nbuf,p);\n\t  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))\n\t    {\n\t      ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t      file->stat_info->orig_file_name));\n\t      return false;\n\t    }\n\t  sp.offset = u;\n\t  COPY_BUF (blk,nbuf,p);\n\t  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))\n\t    {\n\t      ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t      file->stat_info->orig_file_name));\n\t      return false;\n\t    }\n\t  sp.numbytes = u;\n\t  sparse_add_map (file->stat_info, &sp);\n\t}\n      set_next_block_after (blk);\n\n      file->dumped_size += BLOCKSIZE * (current_block_ordinal () - start);\n    }\n\n  return true;\n}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "ImageMagick6",
    "cve_id": "CVE-2018-18024",
    "cwe_list": [
      "CWE-835"
    ],
    "commit_hash": "b268ce7a59440972f4476b9fd98104b6a836d971",
    "short_hash": "b268ce7a",
    "vulnerableMethods_before": [
      {
        "filename": "bmp.c",
        "method_name": "vulnerable_function",
        "raw_code": "static Image *ReadBMPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  BMPInfo\n    bmp_info;\n\n  Image\n    *image;\n\n  IndexPacket\n    index;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset,\n    start_position;\n\n  MemoryInfo\n    *pixel