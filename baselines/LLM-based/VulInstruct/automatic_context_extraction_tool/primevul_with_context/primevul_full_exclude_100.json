[
  {
    "repository": "gocd",
    "cve_id": "CVE-2024-56321",
    "cwe_list": [
      "CWE-36"
    ],
    "commit_hash": "631f315d17fcb73f310eee6c881974c9b55ca9f0",
    "short_hash": "631f315d",
    "vulnerableMethods_before": [
      {
        "filename": "BackupService.java",
        "method_name": "performBackup",
        "raw_code": "private ServerBackup performBackup(ServerBackup backup, List<BackupUpdateListener> backupUpdateListeners, BackupInitiator initiatedBy) {\n        GoMailSender mailSender = goConfigService.getMailSender();\n        File destDir = new File(backup.getPath());\n        synchronized (BACKUP_MUTEX) {\n            try {\n                runningBackup = backup;\n                notifyUpdateToListeners(backupUpdateListeners, BackupProgressStatus.CREATING_DIR);\n                if (!destDir.mkdirs()) {\n                    notifyErrorToListeners(backupUpdateListeners, \"Failed to perform backup. Reason: Could not create the backup directory.\");\n                    return backup;\n                }\n                backupVersion(destDir, backupUpdateListeners);\n                backupConfig(destDir, backupUpdateListeners);\n                boolean backedUpWrapperConfig = backupWrapperConfig(destDir, backupUpdateListeners);\n                backupConfigRepo(backupUpdateListeners, destDir);\n                backupDb(destDir, backupUpdateListeners);\n                boolean passed = executePostBackupScript(backup.getUsername(), initiatedBy, backup, backupUpdateListeners);\n                if (passed) {\n                    sendBackupSuccessEmail(backup.getUsername(), mailSender, destDir);\n                    notifyCompletionToListeners(backupUpdateListeners, backedUpWrapperConfig);\n                    LOGGER.debug(\"Backup Completed Successfully\");\n                }\n            } catch (Exception e) {\n                FileUtils.deleteQuietly(destDir);\n                sendBackupFailedEmail(mailSender, e);\n                notifyErrorToListeners(backupUpdateListeners, String.format(\"Failed to perform backup. Reason: %s\", e.getMessage()));\n                LOGGER.error(\"[Backup] Failed to backup Go.\", e);\n            } finally {\n                runningBackup = null;\n            }\n        }\n        return backup;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "BackupService.java",
        "method_name": "performBackup",
        "raw_code": "private ServerBackup performBackup(ServerBackup backup, List<BackupUpdateListener> backupUpdateListeners, BackupInitiator initiatedBy) {\n        GoMailSender mailSender = goConfigService.getMailSender();\n        File destDir = new File(backup.getPath());\n        synchronized (BACKUP_MUTEX) {\n            try {\n                runningBackup = backup;\n                validator.validatePostBackupScript(postBackupScriptFile());\n                notifyUpdateToListeners(backupUpdateListeners, BackupProgressStatus.CREATING_DIR);\n                if (!destDir.mkdirs()) {\n                    notifyErrorToListeners(backupUpdateListeners, \"Failed to perform backup. Reason: Could not create the backup directory.\");\n                    return backup;\n                }\n                backupVersion(destDir, backupUpdateListeners);\n                backupConfig(destDir, backupUpdateListeners);\n                boolean backedUpWrapperConfig = backupWrapperConfig(destDir, backupUpdateListeners);\n                backupConfigRepo(backupUpdateListeners, destDir);\n                backupDb(destDir, backupUpdateListeners);\n                boolean passed = executePostBackupScript(backup.getUsername(), initiatedBy, backup, backupUpdateListeners);\n                if (passed) {\n                    sendBackupSuccessEmail(backup.getUsername(), mailSender, destDir);\n                    notifyCompletionToListeners(backupUpdateListeners, backedUpWrapperConfig);\n                    LOGGER.debug(\"Backup Completed Successfully\");\n                }\n            } catch (Exception e) {\n                FileUtils.deleteQuietly(destDir);\n                sendBackupFailedEmail(mailSender, e);\n                notifyErrorToListeners(backupUpdateListeners, String.format(\"Failed to perform backup. Reason: %s\", e.getMessage()));\n                LOGGER.error(\"[Backup] Failed to backup Go.\", e);\n            } finally {\n                runningBackup = null;\n            }\n        }\n        return backup;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "gocd",
    "cve_id": "CVE-2024-56321",
    "cwe_list": [
      "CWE-36"
    ],
    "commit_hash": "631f315d17fcb73f310eee6c881974c9b55ca9f0",
    "short_hash": "631f315d",
    "vulnerableMethods_before": [
      {
        "filename": "BackupServiceIntegrationTest.java",
        "method_name": "shouldSendEmailToAdminWhenTheBackupFails",
        "raw_code": "@Test\n    public void shouldSendEmailToAdminWhenTheBackupFails() throws Exception {\n        GoConfigService configService = mock(GoConfigService.class);\n        ServerConfig serverConfig = new ServerConfig();\n        serverConfig.setBackupConfig(new BackupConfig().setEmailOnFailure(true));\n        when(configService.serverConfig()).thenReturn(serverConfig);\n        when(configService.adminEmail()).thenReturn(\"mail@admin.com\");\n\n        GoMailSender goMailSender = mock(GoMailSender.class);\n        when(configService.getMailSender()).thenReturn(goMailSender);\n        when(configService.isUserAdmin(admin)).thenReturn(true);\n\n        DateTime now = new DateTime();\n        TimeProvider timeProvider = mock(TimeProvider.class);\n        when(timeProvider.currentDateTime()).thenReturn(now);\n\n        Database databaseStrategyMock = mock(Database.class);\n        doThrow(new RuntimeException(\"Oh no!\")).when(databaseStrategyMock).backup(any(File.class));\n        BackupService service = new BackupService(artifactsDirHolder, configService, timeProvider, backupInfoRepository, systemEnvSpy, configRepository,\n                databaseStrategyMock, null);\n        ServerBackup backup = service.startBackup(admin);\n\n        String ipAddress = SystemUtil.getFirstLocalNonLoopbackIpAddress();\n        String body = String.format(\"Backup of the Go server at '%s' has failed. The reason is: %s\", ipAddress, \"Oh no!\");\n\n        assertThat(backup.isSuccessful()).isFalse();\n        assertThat(backup.getMessage()).isEqualTo(\"Failed to perform backup. Reason: Oh no!\");\n        verify(goMailSender).send(new SendEmailMessage(\"Server Backup Failed\", body, \"mail@admin.com\"));\n        verifyNoMoreInteractions(goMailSender);\n\n        assertThat(FileUtils.listFiles(backupsDirectory, TrueFileFilter.TRUE, TrueFileFilter.TRUE).isEmpty()).isTrue();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "BackupServiceIntegrationTest.java",
        "method_name": "shouldSendEmailToAdminWhenTheBackupFails",
        "raw_code": "@Test\n    public void shouldSendEmailToAdminWhenTheBackupFails() {\n        GoConfigService configService = mock(GoConfigService.class);\n        ServerConfig serverConfig = new ServerConfig();\n        serverConfig.setBackupConfig(new BackupConfig().setEmailOnFailure(true));\n        when(configService.serverConfig()).thenReturn(serverConfig);\n        when(configService.adminEmail()).thenReturn(\"mail@admin.com\");\n\n        GoMailSender goMailSender = mock(GoMailSender.class);\n        when(configService.getMailSender()).thenReturn(goMailSender);\n        when(configService.isUserAdmin(admin)).thenReturn(true);\n\n        DateTime now = new DateTime();\n        TimeProvider timeProvider = mock(TimeProvider.class);\n        when(timeProvider.currentDateTime()).thenReturn(now);\n\n        Database databaseStrategyMock = mock(Database.class);\n        doThrow(new RuntimeException(\"Oh no!\")).when(databaseStrategyMock).backup(any(File.class));\n        BackupService service = new BackupService(artifactsDirHolder, configService, timeProvider, backupInfoRepository, systemEnvSpy, configRepository,\n                databaseStrategyMock, null);\n        ServerBackup backup = service.startBackup(admin);\n\n        String ipAddress = SystemUtil.getFirstLocalNonLoopbackIpAddress();\n        String body = String.format(\"Backup of the Go server at '%s' has failed. The reason is: %s\", ipAddress, \"Oh no!\");\n\n        assertThat(backup.isSuccessful()).isFalse();\n        assertThat(backup.getMessage()).isEqualTo(\"Failed to perform backup. Reason: Oh no!\");\n        verify(goMailSender).send(new SendEmailMessage(\"Server Backup Failed\", body, \"mail@admin.com\"));\n        verifyNoMoreInteractions(goMailSender);\n\n        assertThat(FileUtils.listFiles(backupsDirectory, TrueFileFilter.TRUE, TrueFileFilter.TRUE)).isEmpty();\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "gocd",
    "cve_id": "CVE-2024-56321",
    "cwe_list": [
      "CWE-36"
    ],
    "commit_hash": "631f315d17fcb73f310eee6c881974c9b55ca9f0",
    "short_hash": "631f315d",
    "vulnerableMethods_before": [
      {
        "filename": "BackupServiceIntegrationTest.java",
        "method_name": "shouldNotSendEmailToAdminWhenTheBackupFailsAndEmailConfigIsNotSet",
        "raw_code": "@Test\n    public void shouldNotSendEmailToAdminWhenTheBackupFailsAndEmailConfigIsNotSet() throws Exception {\n        GoConfigService configService = mock(GoConfigService.class);\n        ServerConfig serverConfig = new ServerConfig();\n        serverConfig.setBackupConfig(new BackupConfig());\n        when(configService.serverConfig()).thenReturn(serverConfig);\n        when(configService.adminEmail()).thenReturn(\"mail@admin.com\");\n\n        GoMailSender goMailSender = mock(GoMailSender.class);\n        when(configService.getMailSender()).thenReturn(goMailSender);\n        when(configService.isUserAdmin(admin)).thenReturn(true);\n\n        DateTime now = new DateTime();\n        TimeProvider timeProvider = mock(TimeProvider.class);\n        when(timeProvider.currentDateTime()).thenReturn(now);\n\n        Database databaseStrategyMock = mock(Database.class);\n        doThrow(new RuntimeException(\"Oh no!\")).when(databaseStrategyMock).backup(any(File.class));\n        BackupService service = new BackupService(artifactsDirHolder, configService, timeProvider, backupInfoRepository, systemEnvSpy, configRepository,\n                databaseStrategyMock, null);\n        ServerBackup backup = service.startBackup(admin);\n\n        assertThat(backup.isSuccessful()).isFalse();\n        assertThat(backup.getMessage()).isEqualTo(\"Failed to perform backup. Reason: Oh no!\");\n        verifyNoMoreInteractions(goMailSender);\n\n        assertThat(FileUtils.listFiles(backupsDirectory, TrueFileFilter.TRUE, TrueFileFilter.TRUE).isEmpty()).isTrue();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "BackupServiceIntegrationTest.java",
        "method_name": "shouldNotSendEmailToAdminWhenTheBackupFailsAndEmailConfigIsNotSet",
        "raw_code": "@Test\n    public void shouldNotSendEmailToAdminWhenTheBackupFailsAndEmailConfigIsNotSet() {\n        GoConfigService configService = mock(GoConfigService.class);\n        ServerConfig serverConfig = new ServerConfig();\n        serverConfig.setBackupConfig(new BackupConfig());\n        when(configService.serverConfig()).thenReturn(serverConfig);\n        when(configService.adminEmail()).thenReturn(\"mail@admin.com\");\n\n        GoMailSender goMailSender = mock(GoMailSender.class);\n        when(configService.getMailSender()).thenReturn(goMailSender);\n        when(configService.isUserAdmin(admin)).thenReturn(true);\n\n        DateTime now = new DateTime();\n        TimeProvider timeProvider = mock(TimeProvider.class);\n        when(timeProvider.currentDateTime()).thenReturn(now);\n\n        Database databaseStrategyMock = mock(Database.class);\n        doThrow(new RuntimeException(\"Oh no!\")).when(databaseStrategyMock).backup(any(File.class));\n        BackupService service = new BackupService(artifactsDirHolder, configService, timeProvider, backupInfoRepository, systemEnvSpy, configRepository,\n                databaseStrategyMock, null);\n        ServerBackup backup = service.startBackup(admin);\n\n        assertThat(backup.isSuccessful()).isFalse();\n        assertThat(backup.getMessage()).isEqualTo(\"Failed to perform backup. Reason: Oh no!\");\n        verifyNoMoreInteractions(goMailSender);\n\n        assertThat(FileUtils.listFiles(backupsDirectory, TrueFileFilter.TRUE, TrueFileFilter.TRUE)).isEmpty();\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "gocd",
    "cve_id": "CVE-2024-56321",
    "cwe_list": [
      "CWE-36"
    ],
    "commit_hash": "631f315d17fcb73f310eee6c881974c9b55ca9f0",
    "short_hash": "631f315d",
    "vulnerableMethods_before": [
      {
        "filename": "BackupServiceIntegrationTest.java",
        "method_name": "shouldExecutePostBackupScriptAndReturnResultOnSuccess",
        "raw_code": "@Test\n    public void shouldExecutePostBackupScriptAndReturnResultOnSuccess() throws InterruptedException {\n        final Semaphore waitForBackupToComplete = new Semaphore(1);\n        GoConfigService configService = mock(GoConfigService.class);\n        ServerConfig serverConfig = new ServerConfig();\n        serverConfig.setBackupConfig(new BackupConfig().setSchedule(null).setPostBackupScript(\"jcmd\"));\n        when(configService.serverConfig()).thenReturn(serverConfig);\n        GoMailSender goMailSender = mock(GoMailSender.class);\n        when(configService.getMailSender()).thenReturn(goMailSender);\n        when(configService.adminEmail()).thenReturn(\"mail@admin.com\");\n        when(configService.isUserAdmin(admin)).thenReturn(true);\n        TimeProvider timeProvider = mock(TimeProvider.class);\n        DateTime now = new DateTime();\n        when(timeProvider.currentDateTime()).thenReturn(now);\n\n        final MessageCollectingBackupUpdateListener backupUpdateListener = new MessageCollectingBackupUpdateListener(waitForBackupToComplete);\n\n        waitForBackupToComplete.acquire();\n        backupService = new BackupService(artifactsDirHolder, configService, timeProvider, backupInfoRepository, systemEnvSpy, configRepository,\n                databaseStrategy, backupQueue);\n        Thread backupThd = new Thread(() -> backupService.startBackup(admin, backupUpdateListener));\n\n        backupThd.start();\n        waitForBackupToComplete.acquire();\n        assertThat(backupUpdateListener.getMessages().contains(BackupProgressStatus.POST_BACKUP_SCRIPT_COMPLETE.getMessage())).isTrue();\n        backupThd.join();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "BackupServiceIntegrationTest.java",
        "method_name": "shouldExecutePostBackupScriptAndReturnResultOnSuccess",
        "raw_code": "@Test\n    public void shouldExecutePostBackupScriptAndReturnResultOnSuccess() throws InterruptedException {\n        final Semaphore waitForBackupToComplete = new Semaphore(1);\n        GoConfigService configService = mock(GoConfigService.class);\n        ServerConfig serverConfig = new ServerConfig();\n        serverConfig.setBackupConfig(new BackupConfig().setSchedule(null).setPostBackupScript(\"jcmd\"));\n        when(configService.serverConfig()).thenReturn(serverConfig);\n        GoMailSender goMailSender = mock(GoMailSender.class);\n        when(configService.getMailSender()).thenReturn(goMailSender);\n        when(configService.adminEmail()).thenReturn(\"mail@admin.com\");\n        when(configService.isUserAdmin(admin)).thenReturn(true);\n        TimeProvider timeProvider = mock(TimeProvider.class);\n        DateTime now = new DateTime();\n        when(timeProvider.currentDateTime()).thenReturn(now);\n\n        final MessageCollectingBackupUpdateListener backupUpdateListener = new MessageCollectingBackupUpdateListener(waitForBackupToComplete);\n\n        waitForBackupToComplete.acquire();\n        backupService = new BackupService(artifactsDirHolder, configService, timeProvider, backupInfoRepository, systemEnvSpy, configRepository,\n                databaseStrategy, backupQueue);\n        Thread backupThd = new Thread(() -> backupService.startBackup(admin, backupUpdateListener));\n\n        backupThd.start();\n        waitForBackupToComplete.acquire();\n        assertThat(backupUpdateListener.messages).contains(BackupProgressStatus.POST_BACKUP_SCRIPT_COMPLETE.getMessage());\n        backupThd.join();\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "gocd",
    "cve_id": "CVE-2024-56321",
    "cwe_list": [
      "CWE-36"
    ],
    "commit_hash": "631f315d17fcb73f310eee6c881974c9b55ca9f0",
    "short_hash": "631f315d",
    "vulnerableMethods_before": [
      {
        "filename": "BackupServiceIntegrationTest.java",
        "method_name": "cleanupBackups",
        "raw_code": "private void cleanupBackups() throws IOException {\n        FileUtils.deleteQuietly(artifactsDirHolder.getArtifactsDir());\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "BackupServiceIntegrationTest.java",
        "method_name": "cleanupBackups",
        "raw_code": "private void cleanupBackups() {\n        FileUtils.deleteQuietly(artifactsDirHolder.getArtifactsDir());\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "gocd",
    "cve_id": "CVE-2024-56321",
    "cwe_list": [
      "CWE-36"
    ],
    "commit_hash": "631f315d17fcb73f310eee6c881974c9b55ca9f0",
    "short_hash": "631f315d",
    "vulnerableMethods_before": [
      {
        "filename": "BackupServiceIntegrationTest.java",
        "method_name": "error",
        "raw_code": "@Override\n            public void error(String message) {\n            }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "BackupServiceIntegrationTest.java",
        "method_name": "error",
        "raw_code": "@Override\n        public void error(String message) {\n            errors.add(message);\n            backupComplete.release();\n        }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49585",
    "cwe_list": [
      "CWE-357"
    ],
    "commit_hash": "385bde985cdb61ebf315d30c0b144b6d2e2c2d45",
    "short_hash": "385bde98",
    "vulnerableMethods_before": [
      {
        "filename": "XWikiDocumentRequiredRightAnalyzerTest.java",
        "method_name": "analyze",
        "raw_code": "@Test\n    void analyze() throws Exception\n    {\n        when(this.documentContextExecutor.call(any(), any())).thenAnswer(invocation -> {\n            Callable<List<RequiredRightAnalysisResult>> callable = invocation.getArgument(0);\n            return callable.call();\n        });\n\n        XWikiDocument document = mock();\n        when(document.getTitle()).thenReturn(\"title\");\n        DocumentReference mockDocumentReference = mock();\n        when(document.getDocumentReferenceWithLocale()).thenReturn(mockDocumentReference);\n        BaseObject object = mock();\n        when(document.getXObjects()).thenReturn(Map.of(mock(), List.of(object)));\n\n        XDOM xdom = mock();\n        when(document.getXDOM()).thenReturn(xdom);\n        RequiredRightAnalysisResult xdomResult = mock();\n        when(this.xdomRequiredRightAnalyzer.analyze(xdom)).thenReturn(List.of(xdomResult));\n\n        RequiredRightAnalysisResult objectResult = mock();\n        when(this.objectRequiredRightAnalyzer.analyze(object)).thenReturn(List.of(objectResult));\n\n        assertEquals(List.of(xdomResult, objectResult), this.analyzer.analyze(document));\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XWikiDocumentRequiredRightAnalyzerTest.java",
        "method_name": "analyze",
        "raw_code": "@Test\n    void analyze() throws Exception\n    {\n        when(this.documentContextExecutor.call(any(), any())).thenAnswer(invocation -> {\n            Callable<List<RequiredRightAnalysisResult>> callable = invocation.getArgument(0);\n            return callable.call();\n        });\n\n        XWikiDocument document = mock();\n        when(document.getTitle()).thenReturn(\"title\");\n        DocumentReference mockDocumentReference = mock();\n        when(document.getDocumentReferenceWithLocale()).thenReturn(mockDocumentReference);\n        BaseObject object = mock();\n        when(document.getXObjects()).thenReturn(Map.of(mock(), List.of(object)));\n\n        BaseClass baseClass = mock();\n        when(document.getXClass()).thenReturn(baseClass);\n\n        XDOM xdom = mock();\n        when(document.getXDOM()).thenReturn(xdom);\n        RequiredRightAnalysisResult xdomResult = mock();\n        when(this.xdomRequiredRightAnalyzer.analyze(xdom)).thenReturn(List.of(xdomResult));\n\n        RequiredRightAnalysisResult objectResult = mock();\n        when(this.objectRequiredRightAnalyzer.analyze(object)).thenReturn(List.of(objectResult));\n\n        RequiredRightAnalysisResult baseClassResult = mock();\n        when(this.baseClassRequiredRightAnalyzer.analyze(baseClass)).thenReturn(List.of(baseClassResult));\n\n        assertEquals(List.of(xdomResult, baseClassResult, objectResult), this.analyzer.analyze(document));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49585",
    "cwe_list": [
      "CWE-357"
    ],
    "commit_hash": "385bde985cdb61ebf315d30c0b144b6d2e2c2d45",
    "short_hash": "385bde98",
    "vulnerableMethods_before": [
      {
        "filename": "XWikiDocumentRequiredRightAnalyzer.java",
        "method_name": "analyze",
        "raw_code": "@Override\n    public List<RequiredRightAnalysisResult> analyze(XWikiDocument document) throws RequiredRightsException\n    {\n        // Analyze the content\n        try {\n            // Push the document into the context such that we, e.g., get the correct context wiki with the correct\n            // wiki macros etc.\n            return this.documentContextExecutor.call(() ->\n            {\n                List<RequiredRightAnalysisResult> result = new ArrayList<>();\n\n                // Analyze the title\n                if (this.velocityDetector.containsVelocityScript(document.getTitle())) {\n                    result.add(new RequiredRightAnalysisResult(\n                        document.getDocumentReferenceWithLocale(),\n                        this.translationMessageSupplierProvider.get(\"security.requiredrights.title\"),\n                        this.translationMessageSupplierProvider.get(\"security.requiredrights.title.description\",\n                            document.getTitle()),\n                        List.of(RequiredRight.MAYBE_SCRIPT, RequiredRight.MAYBE_PROGRAM)\n                    ));\n                }\n\n                // Analyze the content\n                result.addAll(this.xdomRequiredRightAnalyzer.analyze(document.getXDOM()));\n\n                // Analyze XObjects on the Root locale version of the document\n                XWikiDocument rootLocaleDocument = document;\n                if (document.getLocale() != null && !document.getLocale().equals(Locale.ROOT)) {\n                    XWikiContext context = this.contextProvider.get();\n                    rootLocaleDocument = context.getWiki().getDocument(document.getDocumentReference(), context);\n                }\n\n                for (List<BaseObject> baseObjects : rootLocaleDocument.getXObjects().values()) {\n                    for (BaseObject object : baseObjects) {\n                        result.addAll(this.objectRequiredRightAnalyzer.analyze(object));\n                    }\n                }\n\n                return result;\n            }, document);\n        } catch (Exception e) {\n            throw new RequiredRightsException(\"Error...\", e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XWikiDocumentRequiredRightAnalyzer.java",
        "method_name": "analyze",
        "raw_code": "@Override\n    public List<RequiredRightAnalysisResult> analyze(XWikiDocument document) throws RequiredRightsException\n    {\n        // Analyze the content\n        try {\n            // Push the document into the context such that we, e.g., get the correct context wiki with the correct\n            // wiki macros etc.\n            return this.documentContextExecutor.call(() ->\n            {\n                List<RequiredRightAnalysisResult> result = new ArrayList<>();\n\n                // Analyze the title\n                if (this.velocityDetector.containsVelocityScript(document.getTitle())) {\n                    result.add(new RequiredRightAnalysisResult(\n                        document.getDocumentReferenceWithLocale(),\n                        this.translationMessageSupplierProvider.get(\"security.requiredrights.title\"),\n                        this.translationMessageSupplierProvider.get(\"security.requiredrights.title.description\",\n                            document.getTitle()),\n                        List.of(RequiredRight.MAYBE_SCRIPT, RequiredRight.MAYBE_PROGRAM)\n                    ));\n                }\n\n                // Analyze the content\n                result.addAll(this.xdomRequiredRightAnalyzer.analyze(document.getXDOM()));\n\n                // Analyze XObjects and XClass on the Root locale version of the document\n                XWikiDocument rootLocaleDocument = document;\n                if (document.getLocale() != null && !document.getLocale().equals(Locale.ROOT)) {\n                    XWikiContext context = this.contextProvider.get();\n                    rootLocaleDocument = context.getWiki().getDocument(document.getDocumentReference(), context);\n                }\n\n                result.addAll(this.classRequiredRightAnalyzer.analyze(rootLocaleDocument.getXClass()));\n\n                for (List<BaseObject> baseObjects : rootLocaleDocument.getXObjects().values()) {\n                    for (BaseObject object : baseObjects) {\n                        result.addAll(this.objectRequiredRightAnalyzer.analyze(object));\n                    }\n                }\n\n                return result;\n            }, document);\n        } catch (Exception e) {\n            throw new RequiredRightsException(\"Error...\", e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "restapi",
    "cve_id": "CVE-2025-32960",
    "cwe_list": [
      "CWE-79"
    ],
    "commit_hash": "b3d599f6657d7e212fdb134a61ab5e0888669eb1",
    "short_hash": "b3d599f6",
    "vulnerableMethods_before": [
      {
        "filename": "FileDownloadController.java",
        "method_name": "downloadFile",
        "raw_code": "@GetMapping(\"/{fileDescriptorId}\")\n    public void downloadFile(@PathVariable String fileDescriptorId,\n                             @RequestParam(required = false) Boolean attachment,\n                             HttpServletResponse response) {\n\n        checkCanReadFileDescriptor();\n\n        UUID uuid;\n        try {\n            uuid = UUID.fromString(fileDescriptorId);\n        } catch (IllegalArgumentException e) {\n            throw new RestAPIException(\"Invalid entity ID\",\n                    String.format(\"Cannot convert %s into valid entity ID\", fileDescriptorId),\n                    HttpStatus.BAD_REQUEST,\n                    e);\n        }\n        LoadContext<FileDescriptor> ctx = LoadContext.create(FileDescriptor.class).setId(uuid);\n        FileDescriptor fd = dataService.load(ctx);\n        if (fd == null) {\n            throw new RestAPIException(\"File not found\", \"File not found. Id: \" + fileDescriptorId, HttpStatus.NOT_FOUND);\n        }\n\n        try {\n            response.setHeader(\"Cache-Control\", \"no-cache\");\n            response.setHeader(\"Pragma\", \"no-cache\");\n            response.setDateHeader(\"Expires\", 0);\n            response.setHeader(\"Content-Type\", getContentType(fd));\n            response.setHeader(\"Content-Disposition\", (BooleanUtils.isTrue(attachment) ? \"attachment\" : \"inline\")\n                    + \"; filename=\\\"\" + URLEncodeUtils.encodeUtf8(fd.getName()) + \"\\\"\");\n\n            downloadFromMiddlewareAndWriteResponse(fd, response);\n        } catch (Exception e) {\n            log.error(\"Error on downloading the file {}\", fileDescriptorId, e);\n            throw new RestAPIException(\"Error on downloading the file\", \"\", HttpStatus.INTERNAL_SERVER_ERROR, e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FileDownloadController.java",
        "method_name": "downloadFile",
        "raw_code": "@GetMapping(\"/{fileDescriptorId}\")\n    public void downloadFile(@PathVariable String fileDescriptorId,\n                             @RequestParam(required = false) Boolean attachment,\n                             HttpServletResponse response) {\n\n        checkCanReadFileDescriptor();\n\n        UUID uuid;\n        try {\n            uuid = UUID.fromString(fileDescriptorId);\n        } catch (IllegalArgumentException e) {\n            throw new RestAPIException(\"Invalid entity ID\",\n                    String.format(\"Cannot convert %s into valid entity ID\", fileDescriptorId),\n                    HttpStatus.BAD_REQUEST,\n                    e);\n        }\n        LoadContext<FileDescriptor> ctx = LoadContext.create(FileDescriptor.class).setId(uuid);\n        FileDescriptor fd = dataService.load(ctx);\n        if (fd == null) {\n            throw new RestAPIException(\"File not found\", \"File not found. Id: \" + fileDescriptorId, HttpStatus.NOT_FOUND);\n        }\n\n        attachment = resolveAttachmentValue(attachment, fd);\n\n        try {\n            response.setHeader(\"Cache-Control\", \"no-cache\");\n            response.setHeader(\"Pragma\", \"no-cache\");\n            response.setDateHeader(\"Expires\", 0);\n            response.setHeader(\"Content-Type\", getContentType(fd));\n            response.setHeader(\"Content-Disposition\", (BooleanUtils.isTrue(attachment) ? \"attachment\" : \"inline\")\n                    + \"; filename=\\\"\" + URLEncodeUtils.encodeUtf8(fd.getName()) + \"\\\"\");\n\n            downloadFromMiddlewareAndWriteResponse(fd, response);\n        } catch (Exception e) {\n            log.error(\"Error on downloading the file {}\", fileDescriptorId, e);\n            throw new RestAPIException(\"Error on downloading the file\", \"\", HttpStatus.INTERNAL_SERVER_ERROR, e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "langchain4j-aideepin",
    "cve_id": "CVE-2025-21604",
    "cwe_list": [
      "CWE-328"
    ],
    "commit_hash": "3cf625c5044a151a8cbcbdf98e10b4b46b8a975a",
    "short_hash": "3cf625c5",
    "vulnerableMethods_before": [
      {
        "filename": "ConversationService.java",
        "method_name": "add",
        "raw_code": "public ConvDto add(String title, String systemMessage) {\n        Conversation conversation = this.lambdaQuery()\n                .eq(Conversation::getUserId, ThreadContext.getCurrentUserId())\n                .eq(Conversation::getTitle, title)\n                .eq(Conversation::getIsDeleted, false)\n                .one();\n        if (null != conversation) {\n            throw new BaseException(A_CONVERSATION_TITLE_EXIST);\n        }\n        String uuid = UuidUtil.createShort();\n        Conversation one = new Conversation();\n        one.setUuid(uuid);\n        one.setTitle(title);\n        one.setAiSystemMessage(systemMessage);\n        one.setUserId(ThreadContext.getCurrentUserId());\n        baseMapper.insert(one);\n\n        Conversation conv = this.lambdaQuery().eq(Conversation::getUuid, uuid).one();\n        return MPPageUtil.convertTo(conv, ConvDto.class);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ConversationService.java",
        "method_name": "add",
        "raw_code": "public ConvDto add(String title, String remark, String systemMessage) {\n        Conversation conversation = this.lambdaQuery()\n                .eq(Conversation::getUserId, ThreadContext.getCurrentUserId())\n                .eq(Conversation::getTitle, title)\n                .eq(Conversation::getIsDeleted, false)\n                .one();\n        if (null != conversation) {\n            throw new BaseException(A_CONVERSATION_TITLE_EXIST);\n        }\n        String uuid = UuidUtil.createShort();\n        Conversation one = new Conversation();\n        one.setUuid(uuid);\n        one.setTitle(title);\n        one.setAiSystemMessage(systemMessage);\n        one.setUserId(ThreadContext.getCurrentUserId());\n        one.setRemark(remark);\n        baseMapper.insert(one);\n\n        Conversation conv = this.lambdaQuery().eq(Conversation::getUuid, uuid).one();\n        return MPPageUtil.convertTo(conv, ConvDto.class);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "langchain4j-aideepin",
    "cve_id": "CVE-2025-21604",
    "cwe_list": [
      "CWE-328"
    ],
    "commit_hash": "3cf625c5044a151a8cbcbdf98e10b4b46b8a975a",
    "short_hash": "3cf625c5",
    "vulnerableMethods_before": [
      {
        "filename": "ConversationService.java",
        "method_name": "addByPresetConv",
        "raw_code": "public ConvDto addByPresetConv(String presetConvUuid) {\n        ConversationPreset presetConv = this.conversationPresetService.lambdaQuery()\n                .eq(ConversationPreset::getUuid, presetConvUuid)\n                .eq(ConversationPreset::getIsDeleted, false)\n                .oneOpt()\n                .orElseThrow(() -> new BaseException(A_PRESET_CONVERSATION_NOT_EXIST));\n        ConversationPresetRel presetRel = this.conversationPresetRelService.lambdaQuery()\n                .eq(ConversationPresetRel::getUserId, ThreadContext.getCurrentUserId())\n                .eq(ConversationPresetRel::getUserConvId, presetConv.getId())\n                .eq(ConversationPresetRel::getIsDeleted, false)\n                .oneOpt()\n                .orElse(null);\n        if (null != presetRel) {\n            Conversation conv = this.getById(presetRel.getUserConvId());\n            return MPPageUtil.convertTo(conv, ConvDto.class);\n        }\n        ConvDto convDto = self.add(presetConv.getTitle(), presetConv.getAiSystemMessage());\n        conversationPresetRelService.save(\n                ConversationPresetRel.builder()\n                        .presetConvId(presetConv.getId())\n                        .userConvId(convDto.getId())\n                        .userId(ThreadContext.getCurrentUserId())\n                        .build()\n        );\n        return convDto;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ConversationService.java",
        "method_name": "addByPresetConv",
        "raw_code": "public ConvDto addByPresetConv(String presetConvUuid) {\n        ConversationPreset presetConv = this.conversationPresetService.lambdaQuery()\n                .eq(ConversationPreset::getUuid, presetConvUuid)\n                .eq(ConversationPreset::getIsDeleted, false)\n                .oneOpt()\n                .orElseThrow(() -> new BaseException(A_PRESET_CONVERSATION_NOT_EXIST));\n        ConversationPresetRel presetRel = this.conversationPresetRelService.lambdaQuery()\n                .eq(ConversationPresetRel::getUserId, ThreadContext.getCurrentUserId())\n                .eq(ConversationPresetRel::getUserConvId, presetConv.getId())\n                .eq(ConversationPresetRel::getIsDeleted, false)\n                .oneOpt()\n                .orElse(null);\n        if (null != presetRel) {\n            Conversation conv = this.getById(presetRel.getUserConvId());\n            return MPPageUtil.convertTo(conv, ConvDto.class);\n        }\n        ConvDto convDto = self.add(presetConv.getTitle(), presetConv.getRemark(), presetConv.getAiSystemMessage());\n        conversationPresetRelService.save(\n                ConversationPresetRel.builder()\n                        .presetConvId(presetConv.getId())\n                        .userConvId(convDto.getId())\n                        .userId(ThreadContext.getCurrentUserId())\n                        .build()\n        );\n        return convDto;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "langchain4j-aideepin",
    "cve_id": "CVE-2025-21604",
    "cwe_list": [
      "CWE-328"
    ],
    "commit_hash": "3cf625c5044a151a8cbcbdf98e10b4b46b8a975a",
    "short_hash": "3cf625c5",
    "vulnerableMethods_before": [
      {
        "filename": "FileService.java",
        "method_name": "writeToLocal",
        "raw_code": "public AdiFile writeToLocal(MultipartFile file, boolean image) {\n        String md5 = MD5Utils.md5ByMultipartFile(file);\n        Optional<AdiFile> existFile = this.lambdaQuery()\n                .eq(AdiFile::getMd5, md5)\n                .eq(AdiFile::getIsDeleted, false)\n                .oneOpt();\n        if (existFile.isPresent()) {\n            AdiFile adiFile = existFile.get();\n            boolean exist = FileUtil.checkIfExist(adiFile.getPath());\n            if (exist) {\n                return adiFile;\n            } else {\n                log.warn(\"文件不存在,删除记录以便后续重新生成,fileId:{},uuid:{},md5:{}\", adiFile.getId(), adiFile.getUuid(), adiFile.getMd5());\n                this.lambdaUpdate().eq(AdiFile::getId, adiFile.getId()).set(AdiFile::getIsDeleted, true).update();\n            }\n        }\n        String uuid = UuidUtil.createShort();\n        Pair<String, String> originalFile = FileUtil.saveToLocal(file, image ? imagePath : filePath, uuid);\n        AdiFile adiFile = new AdiFile();\n        adiFile.setName(file.getOriginalFilename());\n        adiFile.setUuid(uuid);\n        adiFile.setMd5(md5);\n        adiFile.setPath(originalFile.getLeft());\n        adiFile.setExt(originalFile.getRight());\n        adiFile.setUserId(ThreadContext.getCurrentUserId());\n        this.getBaseMapper().insert(adiFile);\n        return adiFile;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FileService.java",
        "method_name": "writeToLocal",
        "raw_code": "public AdiFile writeToLocal(MultipartFile file, boolean image) {\n        String sha256 = HashUtil.sha256(file);\n        Optional<AdiFile> existFile = this.lambdaQuery()\n                .eq(AdiFile::getSha256, md5)\n                .eq(AdiFile::getIsDeleted, false)\n                .oneOpt();\n        if (existFile.isPresent()) {\n            AdiFile adiFile = existFile.get();\n            boolean exist = FileUtil.checkIfExist(adiFile.getPath());\n            if (exist) {\n                return adiFile;\n            } else {\n                log.warn(\"文件不存在,删除记录以便后续重新生成,fileId:{},uuid:{},sha256:{}\", adiFile.getId(), adiFile.getUuid(), adiFile.getSha256());\n                this.lambdaUpdate().eq(AdiFile::getId, adiFile.getId()).set(AdiFile::getIsDeleted, true).update();\n            }\n        }\n        String uuid = UuidUtil.createShort();\n        Pair<String, String> originalFile = FileUtil.saveToLocal(file, image ? imagePath : filePath, uuid);\n        AdiFile adiFile = new AdiFile();\n        adiFile.setName(file.getOriginalFilename());\n        adiFile.setUuid(uuid);\n        adiFile.setSha256(sha256);\n        adiFile.setPath(originalFile.getLeft());\n        adiFile.setExt(originalFile.getRight());\n        adiFile.setUserId(ThreadContext.getCurrentUserId());\n        this.getBaseMapper().insert(adiFile);\n        return adiFile;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "langchain4j-aideepin",
    "cve_id": "CVE-2025-21604",
    "cwe_list": [
      "CWE-328"
    ],
    "commit_hash": "3cf625c5044a151a8cbcbdf98e10b4b46b8a975a",
    "short_hash": "3cf625c5",
    "vulnerableMethods_before": [
      {
        "filename": "FileService.java",
        "method_name": "saveImageToLocal",
        "raw_code": "public String saveImageToLocal(User user, String sourceImageUrl) {\n        String uuid = UuidUtil.createShort();\n        String localPath = imagePath + uuid + \".png\";\n        File target = new File(localPath);\n        try {\n            FileUtils.createParentDirectories(target);\n            FileUtils.copyURLToFile(new URL(sourceImageUrl), target);\n        } catch (IOException e) {\n            log.error(\"saveToLocal\", e);\n            throw new BaseException(B_SAVE_IMAGE_ERROR);\n        }\n        AdiFile adiFile = new AdiFile();\n        adiFile.setName(target.getName());\n        adiFile.setUuid(uuid);\n        adiFile.setMd5(MD5Utils.calculateMD5(localPath));\n        adiFile.setPath(localPath);\n        adiFile.setUserId(user.getId());\n        adiFile.setExt(\"png\");\n        this.getBaseMapper().insert(adiFile);\n        return uuid;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FileService.java",
        "method_name": "saveImageToLocal",
        "raw_code": "public String saveImageToLocal(User user, String sourceImageUrl) {\n        String uuid = UuidUtil.createShort();\n        String localPath = imagePath + uuid + \".png\";\n        File target = new File(localPath);\n        try {\n            FileUtils.createParentDirectories(target);\n            FileUtils.copyURLToFile(new URL(sourceImageUrl), target);\n        } catch (IOException e) {\n            log.error(\"saveToLocal\", e);\n            throw new BaseException(B_SAVE_IMAGE_ERROR);\n        }\n        AdiFile adiFile = new AdiFile();\n        adiFile.setName(target.getName());\n        adiFile.setUuid(uuid);\n        adiFile.setSha256(HashUtil.sha256(localPath));\n        adiFile.setPath(localPath);\n        adiFile.setUserId(user.getId());\n        adiFile.setExt(\"png\");\n        this.getBaseMapper().insert(adiFile);\n        return uuid;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "langchain4j-aideepin",
    "cve_id": "CVE-2025-21604",
    "cwe_list": [
      "CWE-328"
    ],
    "commit_hash": "3cf625c5044a151a8cbcbdf98e10b4b46b8a975a",
    "short_hash": "3cf625c5",
    "vulnerableMethods_before": [
      {
        "filename": "FileService.java",
        "method_name": "removeFileAndSoftDel",
        "raw_code": "public void removeFileAndSoftDel(String uuid) {\n        AdiFile adiFile = this.lambdaQuery()\n                .eq(AdiFile::getUserId, ThreadContext.getCurrentUserId())\n                .eq(AdiFile::getUuid, uuid)\n                .oneOpt()\n                .orElse(null);\n        if (null == adiFile) {\n            return;\n        }\n        if (StringUtils.isNotBlank(adiFile.getPath())) {\n            File file = new File(adiFile.getPath());\n            if (!file.delete()) {\n                log.warn(\"Delete file error,uuid:{}\", uuid);\n            }\n        }\n        this.softDel(uuid);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FileService.java",
        "method_name": "removeFileAndSoftDel",
        "raw_code": "public void removeFileAndSoftDel(String uuid) {\n        AdiFile adiFile = this.lambdaQuery()\n                .eq(AdiFile::getUserId, ThreadContext.getCurrentUserId())\n                .eq(AdiFile::getUuid, uuid)\n                .oneOpt()\n                .orElse(null);\n        if (null == adiFile) {\n            return;\n        }\n        if (StringUtils.isNotBlank(adiFile.getPath())) {\n            try {\n                if (!Files.deleteIfExists(Paths.get(adiFile.getPath()))) {\n                    log.warn(\"Delete file fail,uuid:{}\", uuid);\n                }\n            } catch (IOException e) {\n                throw new BaseException(B_DELETE_FILE_ERROR);\n            }\n        }\n        this.softDel(uuid);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "langchain4j-aideepin",
    "cve_id": "CVE-2025-21604",
    "cwe_list": [
      "CWE-328"
    ],
    "commit_hash": "3cf625c5044a151a8cbcbdf98e10b4b46b8a975a",
    "short_hash": "3cf625c5",
    "vulnerableMethods_before": [
      {
        "filename": "FileService.java",
        "method_name": "readImage",
        "raw_code": "private BufferedImage readImage(AdiFile adiFile, boolean thumbnail) {\n        try {\n            String currentFilePath = adiFile.getPath();\n            if (thumbnail) {\n                currentFilePath = thumbnailsPath + adiFile.getUuid() + \".\" + adiFile.getExt();\n                //不存在则创建\n                if (new File(adiFile.getPath()).exists() && !new File(currentFilePath).exists()) {\n                    ImgUtil.scale(\n                            cn.hutool.core.io.FileUtil.file(adiFile.getPath()),\n                            cn.hutool.core.io.FileUtil.file(currentFilePath),\n                            0.2f\n                    );\n                }\n            }\n            return ImageIO.read(new FileInputStream(currentFilePath));\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FileService.java",
        "method_name": "readImage",
        "raw_code": "private BufferedImage readImage(AdiFile adiFile, boolean thumbnail) {\n        try {\n            String currentFilePath = adiFile.getPath();\n            if (thumbnail) {\n                currentFilePath = thumbnailsPath + adiFile.getUuid() + \".\" + adiFile.getExt();\n                //不存在则创建\n                if (new File(adiFile.getPath()).exists() && !new File(currentFilePath).exists()) {\n                    ImgUtil.scale(\n                            cn.hutool.core.io.FileUtil.file(adiFile.getPath()),\n                            cn.hutool.core.io.FileUtil.file(currentFilePath),\n                            0.2f\n                    );\n                }\n            }\n            return ImageIO.read(new FileInputStream(currentFilePath));\n        } catch (IOException e) {\n            throw new BaseException(B_IO_EXCEPTION);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "langchain4j-aideepin",
    "cve_id": "CVE-2025-21604",
    "cwe_list": [
      "CWE-328"
    ],
    "commit_hash": "3cf625c5044a151a8cbcbdf98e10b4b46b8a975a",
    "short_hash": "3cf625c5",
    "vulnerableMethods_before": [
      {
        "filename": "ConversationController.java",
        "method_name": "add",
        "raw_code": "@PostMapping(\"/add\")\n    public ConvDto add(@RequestBody @Validated ConvAddReq convAddReq) {\n        return conversationService.add(convAddReq.getTitle(), convAddReq.getAiSystemMessage());\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ConversationController.java",
        "method_name": "add",
        "raw_code": "@PostMapping(\"/add\")\n    public ConvDto add(@RequestBody @Validated ConvAddReq convAddReq) {\n        return conversationService.add(convAddReq.getTitle(), convAddReq.getRemark(), convAddReq.getAiSystemMessage());\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "simofa",
    "cve_id": "CVE-2024-56799",
    "cwe_list": [
      "CWE-306"
    ],
    "commit_hash": "1b04ba413a9c1d12a33dd50a32f67345c2fa6f2a",
    "short_hash": "1b04ba41",
    "vulnerableMethods_before": [
      {
        "filename": "RouteLoader.java",
        "method_name": "load",
        "raw_code": "public void load(Javalin server) throws Exception {\n        // Ignore RouteLoaderException which gets\n        // thrown if a request fails verification\n        server.exception(RouteLoaderException.class, (exception, context) -> {});\n\n        for (Class<? extends Route> route : getRoutes(ROUTES_LOCATION)) {\n            if (!route.isAnnotationPresent(RouteClass.class)) continue;\n            RouteClass routeClass = route.getAnnotation(RouteClass.class);\n            Route routeInstance = route.getDeclaredConstructor().newInstance();\n            boolean registeredBefore = false;\n\n            for (Method method : route.getMethods()) {\n                if (!method.isAnnotationPresent(RouteInfo.class)) continue;\n                if (method.getParameterCount() != 1) {\n                    throw new Exception(\"Failed to load route [\" + method.getName() + \"] \" + route.getSimpleName() + \". Method has too many parameters.\");\n                }\n\n                try {\n                    Class<?> firstParam = method.getParameterTypes()[0];\n                    firstParam.asSubclass(Context.class);\n\n                    RouteInfo routeInfo = method.getAnnotation(RouteInfo.class);\n\n                    if (!registeredBefore) {\n                        if (routeClass.verifyLogin()) {\n                            server.before(routeInfo.url(), ctx -> {\n                                if (routeClass.verifyLogin()) {\n                                    if (!Route.verifyLogin(ctx)) {\n                                        throw new RouteLoaderException();\n                                    }\n                                }\n                            });\n                        }\n\n                        registeredBefore = true;\n                    }\n\n                    server.addHandler(routeInfo.method(), routeInfo.url(), ctx -> {\n                        try {\n                            method.invoke(routeInstance, ctx);\n                        } catch (InvocationTargetException e) {\n                            if (e.getTargetException() instanceof HttpResponseException) {\n                                throw (HttpResponseException) e.getTargetException();\n                            }\n\n                            throw e;\n                        }\n                    });\n\n                    Simofa.getLogger().info(\n                            String.format(\"Registered route %s %s\", routeInfo.method(), routeInfo.url())\n                    );\n                } catch (Exception e) {\n                    throw new Exception(\"Failed to load route \" + route.getSimpleName(), e);\n                }\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "RouteLoader.java",
        "method_name": "load",
        "raw_code": "public void load(Javalin server) throws Exception {\n        // Ignore RouteLoaderException which gets\n        // thrown if a request fails verification\n        server.exception(RouteLoaderException.class, (exception, context) -> {});\n\n        for (Class<? extends Route> route : getRoutes(ROUTES_LOCATION)) {\n            if (!route.isAnnotationPresent(RouteClass.class)) continue;\n            RouteClass routeClass = route.getAnnotation(RouteClass.class);\n            Route routeInstance = route.getDeclaredConstructor().newInstance();\n            Set<String> registeredBefore = new HashSet<>();\n\n            for (Method method : route.getMethods()) {\n                if (!method.isAnnotationPresent(RouteInfo.class)) continue;\n                if (method.getParameterCount() != 1) {\n                    throw new Exception(\"Failed to load route [\" + method.getName() + \"] \" + route.getSimpleName() + \". Method has too many parameters.\");\n                }\n\n                try {\n                    Class<?> firstParam = method.getParameterTypes()[0];\n                    firstParam.asSubclass(Context.class);\n\n                    RouteInfo routeInfo = method.getAnnotation(RouteInfo.class);\n\n                    if (!registeredBefore.contains(routeInfo.url()) && routeClass.verifyLogin()) {\n                        server.before(routeInfo.url(), ctx -> {\n                            if (!Route.verifyLogin(ctx)) {\n                                throw new RouteLoaderException();\n                            }\n                        });\n\n                        registeredBefore.add(routeInfo.url());\n                    }\n\n                    server.addHandler(routeInfo.method(), routeInfo.url(), ctx -> {\n                        try {\n                            method.invoke(routeInstance, ctx);\n                        } catch (InvocationTargetException e) {\n                            if (e.getTargetException() instanceof HttpResponseException) {\n                                throw (HttpResponseException) e.getTargetException();\n                            }\n\n                            throw e;\n                        }\n                    });\n\n                    Simofa.getLogger().info(\n                            String.format(\"Registered route %s %s\", routeInfo.method(), routeInfo.url())\n                    );\n                } catch (Exception e) {\n                    throw new Exception(\"Failed to load route \" + route.getSimpleName(), e);\n                }\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "tapir",
    "cve_id": "CVE-2024-56802",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "c36360b611fa0ba4f5e250fa43ecf8a294785a03",
    "short_hash": "c36360b6",
    "vulnerableMethods_before": [
      {
        "filename": "ElasticSearchDeployKeyRepositoryTest.java",
        "method_name": "tearDown",
        "raw_code": "@AfterEach\n  void tearDown() throws IOException {\n    restClient.performRequest(new Request(HttpMethod.DELETE, \"/deploykeys\"));\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ElasticSearchDeployKeyRepositoryTest.java",
        "method_name": "tearDown",
        "raw_code": "@AfterEach\n    void tearDown() throws IOException {\n        restClient.performRequest(new Request(HttpMethod.DELETE, \"/deploykeys\"));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "tapir",
    "cve_id": "CVE-2024-56802",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "c36360b611fa0ba4f5e250fa43ecf8a294785a03",
    "short_hash": "c36360b6",
    "vulnerableMethods_before": [
      {
        "filename": "CosmosDbRepository.java",
        "method_name": "getDeployKeyByValue",
        "raw_code": "@Override\n  public DeployKey getDeployKeyByValue(String value) throws DeployKeyNotFoundException {\n      try {\n          Collection<DeployKey> deployKeys = (Collection<DeployKey>) findDeployKeys(\"\", 1, value).getEntities();\n          if (deployKeys == null || deployKeys.size() != 1) {\n            throw new DeployKeyNotFoundException(\"Could not find matching key\");\n          }\n          return deployKeys.stream().findFirst().orElseThrow(() -> new DeployKeyNotFoundException(\"Could not find matching key\"));\n      } catch (Exception e) {\n          throw new DeployKeyNotFoundException(\"Could not find matching key\");\n      }\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "CosmosDbRepository.java",
        "method_name": "getDeployKeyByValue",
        "raw_code": "@Override\n  public DeployKey getDeployKeyByValue(String value) throws DeployKeyNotFoundException {\n      try {\n          Collection<DeployKey> deployKeys = (Collection<DeployKey>) findDeployKeys(\"\", 1, value).getEntities();\n          if (deployKeys == null || deployKeys.isEmpty() {\n            throw new DeployKeyNotFoundException(\"Could not find matching key\");\n          }\n\n          return deployKeys\n            .stream()\n            .filter(deployKey -> deployKey.getKey().equals(value)) // Ensure exact match\n            .findFirst()\n            .orElseThrow(() -> new DeployKeyNotFoundException(\"Could not find matching key\"));\n      } catch (Exception e) {\n          throw new DeployKeyNotFoundException(\"Could not find matching key\");\n      }\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "tapir",
    "cve_id": "CVE-2024-56802",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "c36360b611fa0ba4f5e250fa43ecf8a294785a03",
    "short_hash": "c36360b6",
    "vulnerableMethods_before": [
      {
        "filename": "DynamodbRepository.java",
        "method_name": "getDeployKeyByValue",
        "raw_code": "public DeployKey getDeployKeyByValue(String value) throws DeployKeyNotFoundException {\n    Collection<DeployKey> deployKeys = (Collection<DeployKey>) findDeployKeys(\"\", 1, value).getEntities();\n    if (deployKeys == null || deployKeys.size() != 1) {\n      throw new DeployKeyNotFoundException(\"Could not find matching key\");\n    }\n    return deployKeys.stream().findFirst().orElseThrow(() -> new DeployKeyNotFoundException(\"Could not find matching key\"));\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DynamodbRepository.java",
        "method_name": "getDeployKeyByValue",
        "raw_code": "public DeployKey getDeployKeyByValue(String value) throws DeployKeyNotFoundException {\n    Collection<DeployKey> deployKeys = (Collection<DeployKey>) findDeployKeys(\"\", 1, value).getEntities();\n    if (deployKeys == null || deployKeys.isEmpty()) {\n      throw new DeployKeyNotFoundException(\"Could not find matching key\");\n    }\n    return deployKeys\n      .stream()\n      .filter(deployKey -> deployKey.getKey().equals(value)) // Ensure exact match\n      .findFirst()\n      .orElseThrow(() -> new DeployKeyNotFoundException(\"Could not find matching key\"));\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "tapir",
    "cve_id": "CVE-2024-56802",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "c36360b611fa0ba4f5e250fa43ecf8a294785a03",
    "short_hash": "c36360b6",
    "vulnerableMethods_before": [
      {
        "filename": "ElasticSearchRepository.java",
        "method_name": "getDeployKeyByValue",
        "raw_code": "@Override\n  public DeployKey getDeployKeyByValue(String value) throws DeployKeyNotFoundException {\n      try {\n        Collection<DeployKey> deployKeys = (Collection<DeployKey>) findDeployKeys(\"\", 1, value).getEntities();\n        if (deployKeys == null || deployKeys.size() != 1) {\n          throw new DeployKeyNotFoundException(\"Could not find matching key\");\n        }\n        return deployKeys.stream().findFirst().orElseThrow(() -> new DeployKeyNotFoundException(\"Could not find matching key\"));\n      } catch (Exception e) {\n        throw new DeployKeyNotFoundException(\"Could not find matching key\");\n      }\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ElasticSearchRepository.java",
        "method_name": "getDeployKeyByValue",
        "raw_code": "@Override\n  public DeployKey getDeployKeyByValue(String value) throws DeployKeyNotFoundException {\n    try {\n      Collection<DeployKey> deployKeys = (Collection<DeployKey>) findDeployKeys(\"\", 1, value).getEntities();\n      if (deployKeys == null || deployKeys.isEmpty()) {\n        throw new DeployKeyNotFoundException(\"Could not find matching key\");\n      }\n      // Ensure we match the key exactly\n      return deployKeys.stream()\n          .filter(deployKey -> deployKey.getKey().equals(value)) // Ensure it's an exact match\n          .findFirst()\n          .orElseThrow(() -> new DeployKeyNotFoundException(\"Could not find matching key\"));\n    } catch (Exception e) {\n      throw new DeployKeyNotFoundException(\"Could not find matching key\");\n    }\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49586",
    "cwe_list": [
      "CWE-863"
    ],
    "commit_hash": "ef978315649cf83eae396021bb33603a1a5f7e42",
    "short_hash": "ef978315",
    "vulnerableMethods_before": [
      {
        "filename": "PropertyClass.java",
        "method_name": "displayCustom",
        "raw_code": "public void displayCustom(StringBuffer buffer, String fieldName, String prefix, String type, BaseObject object,\n        final XWikiContext context) throws XWikiException\n    {\n        String content = \"\";\n        try {\n            ScriptContext scontext = Utils.getComponent(ScriptContextManager.class).getCurrentScriptContext();\n            scontext.setAttribute(\"name\", fieldName, ScriptContext.ENGINE_SCOPE);\n            scontext.setAttribute(\"prefix\", prefix, ScriptContext.ENGINE_SCOPE);\n            // The PropertyClass instance can be used to access meta properties in the custom displayer (e.g.\n            // dateFormat, multiSelect). It can be obtained from the XClass of the given object but only if the property\n            // has been added to the XClass. We need to have it in the Velocity context for the use case when an XClass\n            // property needs to be previewed before being added to the XClass.\n            scontext.setAttribute(\"field\", new com.xpn.xwiki.api.PropertyClass(this, context),\n                ScriptContext.ENGINE_SCOPE);\n            scontext.setAttribute(\"object\", new com.xpn.xwiki.api.Object(object, context), ScriptContext.ENGINE_SCOPE);\n            scontext.setAttribute(\"type\", type, ScriptContext.ENGINE_SCOPE);\n\n            BaseProperty prop = (BaseProperty) object.safeget(fieldName);\n            if (prop != null) {\n                scontext.setAttribute(\"value\", prop.getValue(), ScriptContext.ENGINE_SCOPE);\n            } else {\n                // The $value property can exist in the velocity context, we overwrite it to make sure we don't get a\n                // wrong value in the displayer when the property does not exist yet.\n                scontext.setAttribute(\"value\", null, ScriptContext.ENGINE_SCOPE);\n            }\n\n            String customDisplayer = getCachedDefaultCustomDisplayer(context);\n            if (StringUtils.isNotEmpty(customDisplayer)) {\n                if (customDisplayer.equals(CLASS_DISPLAYER_IDENTIFIER)) {\n                    final String rawContent = getCustomDisplay();\n                    XWikiDocument classDocument =\n                        context.getWiki().getDocument(getObject().getDocumentReference(), context);\n                    final String classSyntax = classDocument.getSyntax().toIdString();\n                    // Using author reference since the document content is not relevant in this case.\n                    DocumentReference authorReference = classDocument.getAuthorReference();\n                    if (authorReference == null && classDocument.isNew()) {\n                        // If the class document has not been saved yet (e.g. we could be previewing a class property in\n                        // the class editor) then use the context user as author (e.g. the user that is in the process\n                        // of creating the class).\n                        authorReference = context.getUserReference();\n                    }\n\n                    // Make sure we render the custom displayer with the rights of the user who wrote it (i.e. class\n                    // document author).\n                    content = renderContentInContext(rawContent, classSyntax, authorReference,\n                        classDocument.getDocumentReference(), context);\n                } else if (customDisplayer.startsWith(DOCUMENT_DISPLAYER_IDENTIFIER_PREFIX)) {\n                    XWikiDocument displayerDoc = context.getWiki().getDocument(\n                        StringUtils.substringAfter(customDisplayer, DOCUMENT_DISPLAYER_IDENTIFIER_PREFIX), context);\n                    final String rawContent = displayerDoc.getContent();\n                    final String displayerDocSyntax = displayerDoc.getSyntax().toIdString();\n                    DocumentReference authorReference = displayerDoc.getContentAuthorReference();\n\n                    // Make sure we render the custom displayer with the rights of the user who wrote it (i.e. displayer\n                    // document content author).\n                    content = renderContentInContext(rawContent, displayerDocSyntax, authorReference,\n                        displayerDoc.getDocumentReference(), context);\n                } else if (customDisplayer.startsWith(TEMPLATE_DISPLAYER_IDENTIFIER_PREFIX)) {\n                    content = context.getWiki().evaluateTemplate(\n                        StringUtils.substringAfter(customDisplayer, TEMPLATE_DISPLAYER_IDENTIFIER_PREFIX), context);\n                }\n            }\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_CLASSES,\n                XWikiException.ERROR_XWIKI_CLASSES_CANNOT_PREPARE_CUSTOM_DISPLAY,\n                \"Exception while preparing the custom display of \" + fieldName, e, null);\n\n        }\n        buffer.append(content);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "PropertyClass.java",
        "method_name": "displayCustom",
        "raw_code": "public void displayCustom(StringBuffer buffer, String fieldName, String prefix, String type, BaseObject object,\n        final XWikiContext context) throws XWikiException\n    {\n        String content = \"\";\n        try {\n            ScriptContext scontext = Utils.getComponent(ScriptContextManager.class).getCurrentScriptContext();\n            scontext.setAttribute(\"name\", fieldName, ScriptContext.ENGINE_SCOPE);\n            scontext.setAttribute(\"prefix\", prefix, ScriptContext.ENGINE_SCOPE);\n            // The PropertyClass instance can be used to access meta properties in the custom displayer (e.g.\n            // dateFormat, multiSelect). It can be obtained from the XClass of the given object but only if the property\n            // has been added to the XClass. We need to have it in the Velocity context for the use case when an XClass\n            // property needs to be previewed before being added to the XClass.\n            scontext.setAttribute(\"field\", new com.xpn.xwiki.api.PropertyClass(this, context),\n                ScriptContext.ENGINE_SCOPE);\n            scontext.setAttribute(\"object\", new com.xpn.xwiki.api.Object(object, context), ScriptContext.ENGINE_SCOPE);\n            scontext.setAttribute(\"type\", type, ScriptContext.ENGINE_SCOPE);\n\n            BaseProperty prop = (BaseProperty) object.safeget(fieldName);\n            if (prop != null) {\n                scontext.setAttribute(\"value\", prop.getValue(), ScriptContext.ENGINE_SCOPE);\n            } else {\n                // The $value property can exist in the velocity context, we overwrite it to make sure we don't get a\n                // wrong value in the displayer when the property does not exist yet.\n                scontext.setAttribute(\"value\", null, ScriptContext.ENGINE_SCOPE);\n            }\n\n            String customDisplayer = getCachedDefaultCustomDisplayer(context);\n            if (StringUtils.isNotEmpty(customDisplayer)) {\n                if (customDisplayer.equals(CLASS_DISPLAYER_IDENTIFIER)) {\n                    final String rawContent = getCustomDisplay();\n                    XWikiDocument classDocument = getObject().getOwnerDocument();\n                    final String classSyntax = classDocument.getSyntax().toIdString();\n                    // Using author reference since the document content is not relevant in this case.\n                    DocumentReference authorReference = classDocument.getAuthorReference();\n                    if (authorReference == null && classDocument.isNew()) {\n                        // If the class document has not been saved yet (e.g. we could be previewing a class property in\n                        // the class editor) then use the context user as author (e.g. the user that is in the process\n                        // of creating the class).\n                        authorReference = context.getUserReference();\n                    }\n\n                    // Make sure we render the custom displayer with the rights of the user who wrote it (i.e. class\n                    // document author).\n                    content = renderContentInContext(rawContent, classSyntax, authorReference,\n                        classDocument.getDocumentReference(), classDocument.isRestricted(), context);\n                } else if (customDisplayer.startsWith(DOCUMENT_DISPLAYER_IDENTIFIER_PREFIX)) {\n                    XWikiDocument displayerDoc = context.getWiki().getDocument(\n                        StringUtils.substringAfter(customDisplayer, DOCUMENT_DISPLAYER_IDENTIFIER_PREFIX), context);\n                    final String rawContent = displayerDoc.getContent();\n                    final String displayerDocSyntax = displayerDoc.getSyntax().toIdString();\n                    DocumentReference authorReference = displayerDoc.getContentAuthorReference();\n\n                    // Make sure we render the custom displayer with the rights of the user who wrote it (i.e. displayer\n                    // document content author).\n                    content = renderContentInContext(rawContent, displayerDocSyntax, authorReference,\n                        displayerDoc.getDocumentReference(), context);\n                } else if (customDisplayer.startsWith(TEMPLATE_DISPLAYER_IDENTIFIER_PREFIX)) {\n                    content = context.getWiki().evaluateTemplate(\n                        StringUtils.substringAfter(customDisplayer, TEMPLATE_DISPLAYER_IDENTIFIER_PREFIX), context);\n                }\n            }\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_CLASSES,\n                XWikiException.ERROR_XWIKI_CLASSES_CANNOT_PREPARE_CUSTOM_DISPLAY,\n                \"Exception while preparing the custom display of \" + fieldName, e, null);\n\n        }\n        buffer.append(content);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49586",
    "cwe_list": [
      "CWE-863"
    ],
    "commit_hash": "ef978315649cf83eae396021bb33603a1a5f7e42",
    "short_hash": "ef978315",
    "vulnerableMethods_before": [
      {
        "filename": "PropertyClass.java",
        "method_name": "renderContentInContext",
        "raw_code": "@Deprecated\n    protected String renderContentInContext(final String content, final String syntax,\n        DocumentReference authorReference, final XWikiContext context) throws Exception\n    {\n        return renderContentInContext(content, syntax, authorReference, null, context);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "PropertyClass.java",
        "method_name": "renderContentInContext",
        "raw_code": "@Unstable\n    protected String renderContentInContext(final String content, final String syntax,\n        DocumentReference authorReference, DocumentReference secureDocument,\n        boolean restricted, final XWikiContext context)\n        throws Exception\n    {\n        return Utils.getComponent(AuthorExecutor.class)\n            .call(() -> context.getDoc().getRenderedContent(content, syntax, restricted, context), authorReference,\n                secureDocument);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49586",
    "cwe_list": [
      "CWE-863"
    ],
    "commit_hash": "ef978315649cf83eae396021bb33603a1a5f7e42",
    "short_hash": "ef978315",
    "vulnerableMethods_before": [
      {
        "filename": "PropertyClassTest.java",
        "method_name": "before",
        "raw_code": "@BeforeEach\n    public void before() throws Exception\n    {\n        DocumentReference classReference = new DocumentReference(\"wiki\", Arrays.asList(\"Path\", \"To\"), \"Class\");\n        XWikiDocument classDocument = new XWikiDocument(classReference);\n        classDocument.setSyntax(Syntax.XWIKI_2_1);\n        doReturn(classDocument).when(this.oldCore.getSpyXWiki()).getDocument(classReference,\n            this.oldCore.getXWikiContext());\n\n        this.xclass.setOwnerDocument(classDocument);\n\n        this.oldCore.getMocker().registerMockComponent(EntityReferenceSerializer.TYPE_STRING, \"compactwiki\");\n        this.oldCore.getMocker().registerMockComponent(DocumentReferenceResolver.TYPE_STRING, \"currentmixed\");\n        this.oldCore.getMocker().registerMockComponent(EntityReferenceSerializer.TYPE_STRING, \"local\");\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "PropertyClassTest.java",
        "method_name": "before",
        "raw_code": "@BeforeEach\n    public void before() throws Exception\n    {\n        DocumentReference classReference = new DocumentReference(\"wiki\", Arrays.asList(\"Path\", \"To\"), \"Class\");\n        XWikiDocument classDocument = new XWikiDocument(classReference);\n        classDocument.setSyntax(Syntax.XWIKI_2_1);\n        this.xclass.setOwnerDocument(classDocument);\n\n        this.oldCore.getMocker().registerMockComponent(EntityReferenceSerializer.TYPE_STRING, \"compactwiki\");\n        this.oldCore.getMocker().registerMockComponent(DocumentReferenceResolver.TYPE_STRING, \"currentmixed\");\n        this.oldCore.getMocker().registerMockComponent(EntityReferenceSerializer.TYPE_STRING, \"local\");\n\n        DocumentReference contextDocumentReference = new DocumentReference(\"wiki\", \"XWiki\", \"Context\");\n        this.oldCore.getXWikiContext().setDoc(new XWikiDocument(contextDocumentReference));\n\n        when(this.renderingContext.getTargetSyntax()).thenReturn(Syntax.HTML_5_0);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49586",
    "cwe_list": [
      "CWE-863"
    ],
    "commit_hash": "ef978315649cf83eae396021bb33603a1a5f7e42",
    "short_hash": "ef978315",
    "vulnerableMethods_before": [
      {
        "filename": "PropertyClassTest.java",
        "method_name": "displayCustomWithClassDisplayerAndClassIsNew",
        "raw_code": "@Test\n    public void displayCustomWithClassDisplayerAndClassIsNew() throws Exception\n    {\n        DocumentReference userReference = new DocumentReference(\"wiki\", \"XWiki\", \"Alice\");\n        this.oldCore.getXWikiContext().setUserReference(userReference);\n\n        displayCustomWithAuthor(userReference, this.xclass.getDocumentReference());\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "PropertyClassTest.java",
        "method_name": "displayCustomWithClassDisplayerAndClassIsNew",
        "raw_code": "@Test\n    public void displayCustomWithClassDisplayerAndClassIsNew() throws Exception\n    {\n        DocumentReference userReference = new DocumentReference(\"wiki\", \"XWiki\", \"Alice\");\n        this.oldCore.getXWikiContext().setUserReference(userReference);\n\n        displayCustomWithAuthor(userReference, this.xclass.getDocumentReference());\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49586",
    "cwe_list": [
      "CWE-863"
    ],
    "commit_hash": "ef978315649cf83eae396021bb33603a1a5f7e42",
    "short_hash": "ef978315",
    "vulnerableMethods_before": [
      {
        "filename": "PropertyClassTest.java",
        "method_name": "displayCustomWithAuthor",
        "raw_code": "private void displayCustomWithAuthor(DocumentReference authorReference, DocumentReference secureDocument)\n        throws Exception\n    {\n        when(this.authorExecutor.call(any(Callable.class), eq(authorReference), eq(secureDocument)))\n            .thenReturn(\"output\");\n\n        PropertyClass propertyClass = new PropertyClass();\n        propertyClass.setCustomDisplay(\"test\");\n        propertyClass.setObject(this.xclass);\n\n        StringBuffer buffer = new StringBuffer();\n\n        propertyClass.displayCustom(buffer, \"date\", \"Path.To.Class_0_\", \"edit\", new BaseObject(),\n            this.oldCore.getXWikiContext());\n\n        assertEquals(\"output\", buffer.toString());\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "PropertyClassTest.java",
        "method_name": "displayCustomWithAuthor",
        "raw_code": "private void displayCustomWithAuthor(DocumentReference authorReference, DocumentReference secureDocument)\n        throws Exception\n    {\n        when(this.authorExecutor.call(any(), eq(authorReference), eq(secureDocument)))\n            .then(invocationOnMock -> {\n                Callable<String> callable = invocationOnMock.getArgument(0);\n                return callable.call();\n            });\n\n        String output = \"output\";\n        XDOM mockXDOM = mock();\n        when(this.documentDisplayer.display(any(), any())).thenReturn(mockXDOM);\n\n        doAnswer(invocationOnMock -> {\n            WikiPrinter printer = invocationOnMock.getArgument(1);\n            printer.print(output);\n            return null;\n        }).when(this.htmlRenderer).render(same(mockXDOM), any());\n\n        PropertyClass propertyClass = new PropertyClass();\n        propertyClass.setCustomDisplay(CUSTOM_DISPLAY);\n        propertyClass.setObject(this.xclass);\n\n        StringBuffer buffer = new StringBuffer();\n\n        propertyClass.displayCustom(buffer, \"date\", \"Path.To.Class_0_\", \"edit\", new BaseObject(),\n            this.oldCore.getXWikiContext());\n\n        assertEquals(output, buffer.toString());\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49582",
    "cwe_list": [
      "CWE-357"
    ],
    "commit_hash": "abdcefc0db27035b67329add836fd683e0cf92b8",
    "short_hash": "abdcefc0",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultMacroBlockRequiredRightAnalyzer.java",
        "method_name": "analyzeWithExceptions",
        "raw_code": "private List<RequiredRightAnalysisResult> analyzeWithExceptions(MacroBlock macroBlock)\n        throws RequiredRightsException\n    {\n        List<RequiredRightAnalysisResult> result;\n\n        Optional<RequiredRightAnalyzer<MacroBlock>>\n            specificAnalyzer = getMacroBlockRequiredRightAnalyzer(macroBlock);\n\n        if (specificAnalyzer.isPresent()) {\n            result = specificAnalyzer.get().analyze(macroBlock);\n        } else {\n            // Check if there is a macro analyzer for this macro, if yes, use it.\n            Optional<MacroRequiredRightsAnalyzer> macroAnalyzer = getMacroAnalyzer(macroBlock.getId());\n\n            if (macroAnalyzer.isPresent()) {\n                DefaultMacroRequiredRightReporter reporter = this.macroRequiredRightReporterProvider.get();\n                macroAnalyzer.get().analyze(macroBlock, reporter);\n                result = reporter.getResults();\n            } else {\n                // No specific analyzer found, get more information about the macro.\n                Macro<?> macro = getMacro(macroBlock);\n\n                if (macro instanceof ScriptMacro) {\n                    result = this.scriptMacroAnalyzer.analyze(macroBlock);\n                } else if (macro != null && this.shouldMacroContentBeParsed(macro)) {\n                    result = analyzeMacroContent(macroBlock, macroBlock.getContent());\n                } else {\n                    result = List.of();\n                }\n            }\n        }\n\n        return result;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultMacroBlockRequiredRightAnalyzer.java",
        "method_name": "analyzeWithExceptions",
        "raw_code": "private List<RequiredRightAnalysisResult> analyzeWithExceptions(MacroBlock macroBlock)\n        throws RequiredRightsException\n    {\n        List<RequiredRightAnalysisResult> result;\n\n        Optional<RequiredRightAnalyzer<MacroBlock>>\n            specificAnalyzer = getMacroBlockRequiredRightAnalyzer(macroBlock);\n\n        if (specificAnalyzer.isPresent()) {\n            result = specificAnalyzer.get().analyze(macroBlock);\n        } else {\n            // Check if there is a macro analyzer for this macro, if yes, use it.\n            Optional<MacroRequiredRightsAnalyzer> macroAnalyzer = getMacroAnalyzer(macroBlock.getId());\n\n            if (macroAnalyzer.isPresent()) {\n                DefaultMacroRequiredRightReporter reporter = this.macroRequiredRightReporterProvider.get();\n                macroAnalyzer.get().analyze(macroBlock, reporter);\n                result = reporter.getResults();\n            } else {\n                // No specific analyzer found, get more information about the macro.\n                Macro<?> macro = getMacro(macroBlock);\n\n                if (macro instanceof ScriptMacro) {\n                    result = this.scriptMacroAnalyzer.analyze(macroBlock);\n                } else if (macro != null) {\n                    result = new ArrayList<>(maybeAnalyzeMacroContent(macroBlock, macro));\n                    result.addAll(maybeAnalyzeParameters(macroBlock, macro));\n                } else {\n                    result = List.of();\n                }\n            }\n        }\n\n        return result;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49581",
    "cwe_list": [
      "CWE-270"
    ],
    "commit_hash": "c99d501ed41cbee6a3c02ff927714531570789de",
    "short_hash": "c99d501e",
    "vulnerableMethods_before": [
      {
        "filename": "ObjectPropertyRequiredRightAnalyzer.java",
        "method_name": "analyzeWikiContent",
        "raw_code": "private List<RequiredRightAnalysisResult> analyzeWikiContent(BaseObject object, String value,\n        EntityReference reference)\n        throws RequiredRightsException\n    {\n        try {\n            XDOM parsedContent = this.contentParser.parse(value, object.getOwnerDocument().getSyntax(),\n                object.getDocumentReference());\n            parsedContent.getMetaData().addMetaData(XDOMRequiredRightAnalyzer.ENTITY_REFERENCE_METADATA, reference);\n            return this.xdomRequiredRightAnalyzer.analyze(parsedContent);\n        } catch (ParseException | MissingParserException e) {\n            throw new RequiredRightsException(\"Failed to parse content of object property\", e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ObjectPropertyRequiredRightAnalyzer.java",
        "method_name": "analyzeWikiContent",
        "raw_code": "public List<RequiredRightAnalysisResult> analyzeWikiContent(BaseObject object, String value,\n        EntityReference reference)\n        throws RequiredRightsException\n    {\n        try {\n            XDOM parsedContent = this.contentParser.parse(value, object.getOwnerDocument().getSyntax(),\n                object.getDocumentReference());\n            parsedContent.getMetaData().addMetaData(XDOMRequiredRightAnalyzer.ENTITY_REFERENCE_METADATA, reference);\n            return this.xdomRequiredRightAnalyzer.analyze(parsedContent);\n        } catch (ParseException | MissingParserException e) {\n            throw new RequiredRightsException(\"Failed to parse content of object property\", e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49581",
    "cwe_list": [
      "CWE-270"
    ],
    "commit_hash": "c99d501ed41cbee6a3c02ff927714531570789de",
    "short_hash": "c99d501e",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultWikiMacroRenderer.java",
        "method_name": "parseWiki",
        "raw_code": "private XDOM parseWiki(String macroContent, boolean inline) throws RenderingException\n    {\n        try {\n            return this.contentParser.parse(macroContent, this.syncContext, false, inline);\n        } catch (MacroExecutionException e) {\n            throw new RenderingException(\"Failed to parse the passed content\", e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultWikiMacroRenderer.java",
        "method_name": "parseWiki",
        "raw_code": "private XDOM parseWiki(String macroContent, Syntax syntax, boolean transform, boolean inline)\n        throws RenderingException\n    {\n        try {\n            return this.contentParser.parse(macroContent, syntax, this.syncContext, transform, null, inline);\n        } catch (MacroExecutionException e) {\n            throw new RenderingException(\"Failed to parse the passed content\", e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49581",
    "cwe_list": [
      "CWE-270"
    ],
    "commit_hash": "c99d501ed41cbee6a3c02ff927714531570789de",
    "short_hash": "c99d501e",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultWikiMacroRenderer.java",
        "method_name": "parseContent",
        "raw_code": "private XDOM parseContent(String macroContent, boolean inline) throws RenderingException\n    {\n        ContentDescriptor contentDescriptor = this.wikimacro.getDescriptor().getContentDescriptor();\n        if (contentDescriptor == null || !contentDescriptor.getType().equals(Block.LIST_BLOCK_TYPE)) {\n            try {\n                return this.plainTextParser.parse(new StringReader(macroContent));\n            } catch (ParseException e) {\n                throw new RenderingException(\"Error while parsing the macro content in plain text.\", e);\n            }\n        } else {\n            return parseWiki(macroContent, inline);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultWikiMacroRenderer.java",
        "method_name": "parseContent",
        "raw_code": "private XDOM parseContent(String macroContent, boolean inline) throws RenderingException\n    {\n        ContentDescriptor contentDescriptor = this.wikimacro.getDescriptor().getContentDescriptor();\n        if (contentDescriptor == null || !contentDescriptor.getType().equals(Block.LIST_BLOCK_TYPE)) {\n            try {\n                return this.plainTextParser.parse(new StringReader(macroContent));\n            } catch (ParseException e) {\n                throw new RenderingException(\"Error while parsing the macro content in plain text.\", e);\n            }\n        } else {\n            return parseWiki(macroContent, null, false, inline);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49581",
    "cwe_list": [
      "CWE-270"
    ],
    "commit_hash": "c99d501ed41cbee6a3c02ff927714531570789de",
    "short_hash": "c99d501e",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultWikiMacroRenderer.java",
        "method_name": "parseParameterValue",
        "raw_code": "private XDOM parseParameterValue(String macroParameterContent, String macroParameterName, boolean inline)\n        throws MacroExecutionException, RenderingException\n    {\n        MacroDescriptor macroDescriptor = this.wikimacro.getDescriptor();\n        ParameterDescriptor parameterDescriptor = null;\n        if (macroDescriptor != null) {\n            parameterDescriptor = macroDescriptor.getParameterDescriptorMap().get(macroParameterName);\n        }\n\n        if (parameterDescriptor == null || !parameterDescriptor.getParameterType().equals(Block.LIST_BLOCK_TYPE)) {\n            try {\n                return this.plainTextParser.parse(new StringReader(macroParameterContent));\n            } catch (ParseException e) {\n                throw new MacroExecutionException(\"Error while parsing the macro parameter content in plain.\", e);\n            }\n        } else {\n            return parseWiki(macroParameterContent, inline);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultWikiMacroRenderer.java",
        "method_name": "parseParameterValue",
        "raw_code": "private XDOM parseParameterValue(String macroParameterContent, String macroParameterName, boolean inline)\n        throws MacroExecutionException, RenderingException\n    {\n        MacroDescriptor macroDescriptor = this.wikimacro.getDescriptor();\n        ParameterDescriptor parameterDescriptor = null;\n        if (macroDescriptor != null) {\n            parameterDescriptor = macroDescriptor.getParameterDescriptorMap().get(macroParameterName);\n        }\n\n        if (parameterDescriptor == null || !parameterDescriptor.getParameterType().equals(Block.LIST_BLOCK_TYPE)) {\n            try {\n                return this.plainTextParser.parse(new StringReader(macroParameterContent));\n            } catch (ParseException e) {\n                throw new MacroExecutionException(\"Error while parsing the macro parameter content in plain.\", e);\n            }\n        } else {\n            boolean executeWithMacroAuthor =\n                Objects.equals(macroParameterContent, parameterDescriptor.getDefaultValue());\n            if (executeWithMacroAuthor) {\n                return parseWiki(macroParameterContent, this.wikimacro.getSourceSyntax(), true, inline);\n            } else {\n                return parseWiki(macroParameterContent, null, false, inline);\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49582",
    "cwe_list": [
      "CWE-357"
    ],
    "commit_hash": "cc74dc802efe0e2d3fa2ba3355dbadc51c5fd8c7",
    "short_hash": "cc74dc80",
    "vulnerableMethods_before": [
      {
        "filename": "ContextMacroRequiredRightsAnalyzer.java",
        "method_name": "analyze",
        "raw_code": "@Override\n    public void analyze(MacroBlock macroBlock, MacroRequiredRightReporter reporter)\n    {\n        ContextMacroParameters parameters = new ContextMacroParameters();\n\n        try {\n            this.beanManager.populate(parameters, macroBlock.getParameters());\n\n            // Analyze the content only when it isn't restricted.\n            if (!parameters.isRestricted()) {\n                reporter.analyzeContent(macroBlock, macroBlock.getContent());\n            }\n        } catch (PropertyException e) {\n            // Ignore, the macro won't be executed when populating the parameters fails.\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ContextMacroRequiredRightsAnalyzer.java",
        "method_name": "analyze",
        "raw_code": "@Override\n    public void analyze(MacroBlock macroBlock, MacroRequiredRightReporter reporter)\n    {\n        ContextMacroParameters parameters = new ContextMacroParameters();\n\n        try {\n            this.beanManager.populate(parameters, macroBlock.getParameters());\n\n            // If the source parameter is set, the content is ignored, and we should analyze the source parameter\n            // instead.\n            if (parameters.getSource() != null) {\n                String sourceType = parameters.getSource().getType();\n\n                switch (sourceType) {\n                    case MacroContentSourceReference.TYPE_STRING:\n                        if (!parameters.isRestricted()) {\n                            reporter.analyzeContent(macroBlock, parameters.getSource().getReference());\n                        }\n                        break;\n\n                    case MacroContentSourceReference.TYPE_SCRIPT:\n                        if (parameters.isRestricted()) {\n                            reporter.report(macroBlock, List.of(MacroRequiredRight.SCRIPT),\n                                \"rendering.macro.context.requiredRights.restrictedScriptSource\");\n                        } else {\n                            // We don't know the actual content, but at least script right is needed and the content\n                            // could contain anything, so it might require programming right.\n                            reporter.report(macroBlock,\n                                List.of(MacroRequiredRight.SCRIPT, MacroRequiredRight.MAYBE_PROGRAM),\n                                \"rendering.macro.context.requiredRights.arbitraryScriptSource\");\n                        }\n                        break;\n\n                    default:\n                        // Do nothing.\n                }\n            } else if (!parameters.isRestricted()) {\n                reporter.analyzeContent(macroBlock, macroBlock.getContent());\n            }\n        } catch (PropertyException e) {\n            // Ignore, the macro won't be executed when populating the parameters fails.\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49582",
    "cwe_list": [
      "CWE-357"
    ],
    "commit_hash": "3d451e957fe2b14459e9ac64172b4a0e4c46971c",
    "short_hash": "3d451e95",
    "vulnerableMethods_before": [
      {
        "filename": "CacheMacroRequiredRightsAnalyzerTest.java",
        "method_name": "analyze",
        "raw_code": "@Test\n    void analyze()\n    {\n        MacroBlock macroBlock = mock();\n        String idValue = \"idValue\";\n        String contentValue = \"contentValue\";\n        when(macroBlock.getParameter(\"id\")).thenReturn(idValue);\n        when(macroBlock.getContent()).thenReturn(contentValue);\n        MacroRequiredRightReporter reporter = mock();\n\n        this.analyzer.analyze(macroBlock, reporter);\n\n        verify(reporter).analyzeContent(macroBlock, idValue);\n        verify(reporter).analyzeContent(macroBlock, contentValue);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "CacheMacroRequiredRightsAnalyzerTest.java",
        "method_name": "analyze",
        "raw_code": "@ParameterizedTest\n    @MethodSource(\"idValuesProvider\")\n    void analyze(String parameterName)\n    {\n        String idValue = \"idValue\";\n        String contentValue = \"contentValue\";\n        MacroBlock macroBlock = new MacroBlock(\"cache\", Map.of(parameterName, idValue), contentValue, false);\n        MacroRequiredRightReporter reporter = mock();\n\n        this.analyzer.analyze(macroBlock, reporter);\n\n        verify(reporter).analyzeContent(macroBlock, idValue);\n        verify(reporter).analyzeContent(macroBlock, contentValue);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49582",
    "cwe_list": [
      "CWE-357"
    ],
    "commit_hash": "3d451e957fe2b14459e9ac64172b4a0e4c46971c",
    "short_hash": "3d451e95",
    "vulnerableMethods_before": [
      {
        "filename": "HTMLMacroRequiredRightsAnalyzer.java",
        "method_name": "analyze",
        "raw_code": "@Override\n    public void analyze(MacroBlock macroBlock, MacroRequiredRightReporter reporter)\n    {\n        boolean wiki = Boolean.TRUE.equals(this.converter.convert(Boolean.class, macroBlock.getParameter(\"wiki\")));\n        String cleanParameter = macroBlock.getParameter(\"clean\");\n        // Cleaning is enabled by default.\n        boolean clean =\n            cleanParameter == null || Boolean.TRUE.equals(this.converter.convert(Boolean.class, cleanParameter));\n\n        if (wiki) {\n            reporter.analyzeContent(macroBlock, macroBlock.getContent());\n        }\n\n        if (!clean) {\n            reporter.report(macroBlock, List.of(MacroRequiredRight.SCRIPT),\n                TRANSLATION_PREFIX + \"noClean\");\n        } else if (wiki) {\n            reporter.report(macroBlock, List.of(MacroRequiredRight.MAYBE_SCRIPT),\n                TRANSLATION_PREFIX + \"wikiContent\");\n        } else {\n            HTMLCleanerConfiguration cleanerConfiguration = this.htmlCleaner.getDefaultConfiguration();\n            Map<String, String> parameters = new HashMap<>(cleanerConfiguration.getParameters());\n            // Assume HTML 5 as there is no real way to determine the target version of the rendering action. Also,\n            // the analysis shouldn't really be affected by the HTML version.\n            parameters.put(HTMLCleanerConfiguration.HTML_VERSION, \"5\");\n            cleanerConfiguration.setParameters(parameters);\n\n            // Add the filter for detecting content that would be filtered by restricted mode.\n            List<HTMLFilter> filters = new ArrayList<>(cleanerConfiguration.getFilters());\n            filters.add(this.restrictedFilterDetector);\n            cleanerConfiguration.setFilters(filters);\n\n            Document document = this.htmlCleaner.clean(new StringReader(macroBlock.getContent()), cleanerConfiguration);\n            if (Boolean.parseBoolean(document.getDocumentElement()\n                .getAttribute(SanitizerDetectorFilter.ATTRIBUTE_FILTERED)))\n            {\n                reporter.report(macroBlock, List.of(MacroRequiredRight.SCRIPT),\n                    TRANSLATION_PREFIX + \"dangerousContent\");\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "HTMLMacroRequiredRightsAnalyzer.java",
        "method_name": "analyze",
        "raw_code": "@Override\n    public void analyze(MacroBlock macroBlock, MacroRequiredRightReporter reporter)\n    {\n        boolean wiki = getBooleanParameterValues(macroBlock, \"wiki\").anyMatch(Boolean.TRUE::equals);\n\n        // Cleaning is enabled by default.\n        boolean clean = getBooleanParameterValues(macroBlock, \"clean\").noneMatch(Boolean.FALSE::equals);\n\n        if (wiki) {\n            reporter.analyzeContent(macroBlock, macroBlock.getContent());\n        }\n\n        if (!clean) {\n            reporter.report(macroBlock, List.of(MacroRequiredRight.SCRIPT),\n                TRANSLATION_PREFIX + \"noClean\");\n        } else if (wiki) {\n            reporter.report(macroBlock, List.of(MacroRequiredRight.MAYBE_SCRIPT),\n                TRANSLATION_PREFIX + \"wikiContent\");\n        } else {\n            HTMLCleanerConfiguration cleanerConfiguration = this.htmlCleaner.getDefaultConfiguration();\n            Map<String, String> parameters = new HashMap<>(cleanerConfiguration.getParameters());\n            // Assume HTML 5 as there is no real way to determine the target version of the rendering action. Also,\n            // the analysis shouldn't really be affected by the HTML version.\n            parameters.put(HTMLCleanerConfiguration.HTML_VERSION, \"5\");\n            cleanerConfiguration.setParameters(parameters);\n\n            // Add the filter for detecting content that would be filtered by restricted mode.\n            List<HTMLFilter> filters = new ArrayList<>(cleanerConfiguration.getFilters());\n            filters.add(this.restrictedFilterDetector);\n            cleanerConfiguration.setFilters(filters);\n\n            Document document = this.htmlCleaner.clean(new StringReader(macroBlock.getContent()), cleanerConfiguration);\n            if (Boolean.parseBoolean(document.getDocumentElement()\n                .getAttribute(SanitizerDetectorFilter.ATTRIBUTE_FILTERED)))\n            {\n                reporter.report(macroBlock, List.of(MacroRequiredRight.SCRIPT),\n                    TRANSLATION_PREFIX + \"dangerousContent\");\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49582",
    "cwe_list": [
      "CWE-357"
    ],
    "commit_hash": "3d451e957fe2b14459e9ac64172b4a0e4c46971c",
    "short_hash": "3d451e95",
    "vulnerableMethods_before": [
      {
        "filename": "RawMacroRequiredRightsAnalyzerTest.java",
        "method_name": "analyzeTestCases",
        "raw_code": "private static Stream<Arguments> analyzeTestCases()\n    {\n        return Stream.of(\n            Arguments.of(\"plain\", Syntax.PLAIN_1_0, null),\n            Arguments.of(\"html\", Syntax.HTML_5_0, MacroRequiredRight.SCRIPT)\n        );\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "RawMacroRequiredRightsAnalyzerTest.java",
        "method_name": "analyzeTestCases",
        "raw_code": "private static Stream<Arguments> analyzeTestCases()\n    {\n        return Stream.of(\n            Arguments.of(Map.of(SYNTAX_PARAMETER, PLAIN_VALUE), null),\n            Arguments.of(Map.of(SYNTAX_PARAMETER, HTML_VALUE), MacroRequiredRight.SCRIPT),\n            Arguments.of(Map.of(\"sYnTaX\", HTML_VALUE), MacroRequiredRight.SCRIPT),\n            Arguments.of(Map.of(\"sYntax\", HTML_VALUE, SYNTAX_PARAMETER, PLAIN_VALUE), MacroRequiredRight.SCRIPT),\n            Arguments.of(Map.of(\"Syntax\", PLAIN_VALUE, \"SYNTAX\", HTML_VALUE), MacroRequiredRight.SCRIPT),\n            Arguments.of(Map.of(\"syntaX\", PLAIN_VALUE), null)\n        );\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49582",
    "cwe_list": [
      "CWE-357"
    ],
    "commit_hash": "3d451e957fe2b14459e9ac64172b4a0e4c46971c",
    "short_hash": "3d451e95",
    "vulnerableMethods_before": [
      {
        "filename": "RawMacroRequiredRightsAnalyzerTest.java",
        "method_name": "analyze",
        "raw_code": "@ParameterizedTest\n    @MethodSource(\"analyzeTestCases\")\n    void analyze(String syntaxValue, Syntax expectedSyntax, MacroRequiredRight expectedRight) throws ParseException\n    {\n        when(this.syntaxRegistry.resolveSyntax(syntaxValue)).thenReturn(expectedSyntax);\n\n        MacroBlock macroBlock = mock();\n        when(macroBlock.getParameter(SYNTAX_PARAMETER)).thenReturn(syntaxValue);\n\n        MacroRequiredRightReporter reporter = mock();\n        this.analyzer.analyze(macroBlock, reporter);\n\n        verify(this.syntaxRegistry).resolveSyntax(syntaxValue);\n        if (expectedRight != null) {\n            verify(reporter).report(macroBlock, List.of(expectedRight), \"rendering.macro.rawMacroRequiredRights\");\n        } else {\n            verifyNoInteractions(reporter);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "RawMacroRequiredRightsAnalyzerTest.java",
        "method_name": "analyze",
        "raw_code": "@ParameterizedTest\n    @MethodSource(\"analyzeTestCases\")\n    void analyze(Map<String, String> parameters, MacroRequiredRight expectedRight)\n    {\n        MacroBlock macroBlock = new MacroBlock(\"raw\", parameters, false);\n\n        MacroRequiredRightReporter reporter = mock();\n        this.analyzer.analyze(macroBlock, reporter);\n\n        if (expectedRight != null) {\n            verify(reporter).report(macroBlock, List.of(expectedRight), \"rendering.macro.rawMacroRequiredRights\");\n        } else {\n            verifyNoInteractions(reporter);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49582",
    "cwe_list": [
      "CWE-357"
    ],
    "commit_hash": "3d451e957fe2b14459e9ac64172b4a0e4c46971c",
    "short_hash": "3d451e95",
    "vulnerableMethods_before": [
      {
        "filename": "RawMacroRequiredRightsAnalyzer.java",
        "method_name": "analyze",
        "raw_code": "@Override\n    public void analyze(MacroBlock macroBlock, MacroRequiredRightReporter reporter)\n    {\n        try {\n            SyntaxType syntax = this.syntaxRegistry.resolveSyntax(macroBlock.getParameter(\"syntax\")).getType();\n            if (SyntaxType.HTML_FAMILY_TYPES.contains(syntax)) {\n                reporter.report(macroBlock, List.of(MacroRequiredRight.SCRIPT),\n                    \"rendering.macro.rawMacroRequiredRights\");\n            }\n        } catch (ParseException e) {\n            // Ignore, this should fail the macro or at least won't produce HTML output.\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "RawMacroRequiredRightsAnalyzer.java",
        "method_name": "analyze",
        "raw_code": "@Override\n    public void analyze(MacroBlock macroBlock, MacroRequiredRightReporter reporter)\n    {\n        // Check if any parameter that is equal to \"syntax\" ignoring case is an HTML syntax.\n        boolean isHTML = macroBlock.getParameters().entrySet().stream()\n            .filter(entry -> \"syntax\".equalsIgnoreCase(entry.getKey()))\n            .anyMatch(entry -> isHTMLSyntax(entry.getValue()));\n\n        if (isHTML) {\n            reporter.report(macroBlock, List.of(MacroRequiredRight.SCRIPT), \"rendering.macro.rawMacroRequiredRights\");\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49582",
    "cwe_list": [
      "CWE-357"
    ],
    "commit_hash": "3d451e957fe2b14459e9ac64172b4a0e4c46971c",
    "short_hash": "3d451e95",
    "vulnerableMethods_before": [
      {
        "filename": "CacheMacroRequiredRightsAnalyzer.java",
        "method_name": "analyze",
        "raw_code": "@Override\n    public void analyze(MacroBlock macroBlock, MacroRequiredRightReporter reporter)\n    {\n        reporter.analyzeContent(macroBlock, macroBlock.getParameter(\"id\"));\n        reporter.analyzeContent(macroBlock, macroBlock.getContent());\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "CacheMacroRequiredRightsAnalyzer.java",
        "method_name": "analyze",
        "raw_code": "@Override\n    public void analyze(MacroBlock macroBlock, MacroRequiredRightReporter reporter)\n    {\n        macroBlock.getParameters().entrySet().stream()\n            .filter(entry -> \"id\".equalsIgnoreCase(entry.getKey()))\n            .forEach(entry -> reporter.analyzeContent(macroBlock, entry.getValue()));\n\n        reporter.analyzeContent(macroBlock, macroBlock.getContent());\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49584",
    "cwe_list": [
      "CWE-201"
    ],
    "commit_hash": "ee642f973a7c95d2d146fe03c81bcdee1871f4ec",
    "short_hash": "ee642f97",
    "vulnerableMethods_before": [
      {
        "filename": "AbstractDocumentListClassPropertyValuesProvider.java",
        "method_name": "getValue",
        "raw_code": "@Override\n    public PropertyValue getValue(ClassPropertyReference propertyReference, Object rawValue)\n        throws XWikiRestException\n    {\n\n        String reference = \"\";\n        if (rawValue != null) {\n            reference = rawValue.toString();\n        }\n        if (StringUtils.isEmpty(reference)) {\n            return null;\n        }\n\n        DocumentReference documentReference = this.documentReferenceResolver.resolve(reference, propertyReference);\n\n        PropertyValue propertyValue = null;\n        if (exists(documentReference)) {\n            propertyValue = super.getValue(propertyReference, documentReference);\n        }\n\n        if (propertyValue == null) {\n            propertyValue = new PropertyValue();\n        }\n\n        propertyValue.setValue(reference);\n\n        return propertyValue;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AbstractDocumentListClassPropertyValuesProvider.java",
        "method_name": "getValue",
        "raw_code": "@Override\n    public PropertyValue getValue(ClassPropertyReference propertyReference, Object rawValue)\n        throws XWikiRestException\n    {\n\n        String reference = \"\";\n        if (rawValue != null) {\n            reference = rawValue.toString();\n        }\n        if (StringUtils.isEmpty(reference)) {\n            return null;\n        }\n\n        DocumentReference documentReference = this.documentReferenceResolver.resolve(reference, propertyReference);\n\n        PropertyValue propertyValue = null;\n        if (this.contextualAuthorizationManager.hasAccess(Right.VIEW, documentReference) && exists(documentReference)) {\n            propertyValue = super.getValue(propertyReference, documentReference);\n        }\n\n        if (propertyValue == null) {\n            propertyValue = new PropertyValue();\n        }\n\n        propertyValue.setValue(reference);\n\n        return propertyValue;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49584",
    "cwe_list": [
      "CWE-201"
    ],
    "commit_hash": "ee642f973a7c95d2d146fe03c81bcdee1871f4ec",
    "short_hash": "ee642f97",
    "vulnerableMethods_before": [
      {
        "filename": "AbstractListClassPropertyValuesProviderTest.java",
        "method_name": "configure",
        "raw_code": "public void configure() throws Exception\n    {\n        Provider<XWikiContext> xcontextProvider = this.componentManager.getInstance(XWikiContext.TYPE_PROVIDER);\n        BaseClass xclass = mock(BaseClass.class);\n        DocumentReference authorReference = new DocumentReference(\"wiki\", \"Users\", \"Alice\");\n\n        when(xcontextProvider.get()).thenReturn(this.xcontext);\n        when(this.xcontext.getWiki()).thenReturn(this.xwiki);\n        when(this.classDocument.getXClass()).thenReturn(xclass);\n        when(this.classDocument.getDocumentReference()).thenReturn(this.classReference);\n        when(this.classDocument.getAuthorReference()).thenReturn(authorReference);\n\n        QueryParameter queryParameter = mock(QueryParameter.class);\n        when(this.allowedValuesQuery.bindValue(\"text\")).thenReturn(queryParameter);\n        when(this.usedValuesQuery.bindValue(\"text\")).thenReturn(queryParameter);\n        when(queryParameter.anyChars()).thenReturn(queryParameter);\n        when(queryParameter.literal(\"foo\")).thenReturn(queryParameter);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AbstractListClassPropertyValuesProviderTest.java",
        "method_name": "configure",
        "raw_code": "public void configure() throws Exception\n    {\n        Provider<XWikiContext> xcontextProvider = this.componentManager.getInstance(XWikiContext.TYPE_PROVIDER);\n        BaseClass xclass = mock(BaseClass.class);\n        DocumentReference authorReference = new DocumentReference(\"wiki\", \"Users\", \"Alice\");\n\n        when(xcontextProvider.get()).thenReturn(this.xcontext);\n        when(this.readonlyXWikiContextProvider.get()).thenReturn(this.xcontext);\n        when(this.xcontext.getWiki()).thenReturn(this.xwiki);\n        when(this.classDocument.getXClass()).thenReturn(xclass);\n        when(this.classDocument.getDocumentReference()).thenReturn(this.classReference);\n        when(this.classDocument.getAuthorReference()).thenReturn(authorReference);\n\n        QueryParameter queryParameter = mock(QueryParameter.class);\n        when(this.allowedValuesQuery.bindValue(\"text\")).thenReturn(queryParameter);\n        when(this.usedValuesQuery.bindValue(\"text\")).thenReturn(queryParameter);\n        when(queryParameter.anyChars()).thenReturn(queryParameter);\n        when(queryParameter.literal(\"foo\")).thenReturn(queryParameter);\n\n        when(this.iconManager.getMetaData(anyString())).thenAnswer(i -> mock(Map.class, i.<String>getArgument(0)));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49584",
    "cwe_list": [
      "CWE-201"
    ],
    "commit_hash": "ee642f973a7c95d2d146fe03c81bcdee1871f4ec",
    "short_hash": "ee642f97",
    "vulnerableMethods_before": [
      {
        "filename": "UsersClassPropertyValuesProviderTest.java",
        "method_name": "getValuesLocal",
        "raw_code": "@Test\n    public void getValuesLocal() throws Exception\n    {\n        when(this.wikiUserManager.getUserScope(this.classReference.getWikiReference().getName()))\n            .thenReturn(UserScope.LOCAL_ONLY);\n\n        DocumentReference aliceReference = new DocumentReference(\"wiki\", \"Users\", \"Alice\");\n        when(this.allowedValuesQuery.execute())\n            .thenReturn(Collections.singletonList(new Object[]{ aliceReference, \" Alice One \" }));\n        when(this.xcontext.getWiki().getDocument(aliceReference, this.xcontext))\n            .thenReturn(mock(XWikiDocument.class, \"alice\"));\n\n        QueryFilter documentFilter = this.componentManager.getInstance(QueryFilter.class, \"document\");\n        QueryFilter viewableFilter = this.componentManager.getInstance(QueryFilter.class, \"viewable\");\n        List<QueryFilter> filters = mock(List.class);\n        DocumentReference bobReference = new DocumentReference(\"wiki\", \"Users\", \"Bob\");\n        when(this.usedValuesQuery.getFilters()).thenReturn(filters);\n        when(this.usedValuesQuery.execute())\n            .thenReturn(Arrays.asList(new Object[]{ bobReference, 17L }, new Object[]{ aliceReference, 3L }));\n\n        EntityReferenceSerializer<String> compactSerializer =\n            this.componentManager.getInstance(EntityReferenceSerializer.TYPE_STRING, \"compact\");\n        when(compactSerializer.serialize(aliceReference, this.classReference.getWikiReference()))\n            .thenReturn(\"Users.Alice\");\n        when(compactSerializer.serialize(bobReference, this.classReference.getWikiReference())).thenReturn(\"Users.Bob\");\n\n        when(this.xcontext.getWiki().getPlainUserName(bobReference, this.xcontext)).thenReturn(\"Bob the Great\");\n\n        when(this.xcontext.getWiki().getURL(aliceReference, this.xcontext)).thenReturn(\"url/to/alice\");\n        when(this.xcontext.getWiki().getURL(bobReference, this.xcontext)).thenReturn(\"url/to/bob\");\n\n        XWikiDocument bobProfile = mock(XWikiDocument.class);\n        XWikiAttachment bobAvatar = mock(XWikiAttachment.class);\n        AttachmentReference bobAvatarReference = new AttachmentReference(\"somePhoto.png\", bobReference);\n        when(this.xcontext.getWiki().getDocument(bobReference, this.xcontext)).thenReturn(bobProfile);\n        when(bobProfile.getStringValue(\"avatar\")).thenReturn(bobAvatarReference.getName());\n        when(bobProfile.getAttachment(\"somePhoto.png\")).thenReturn(bobAvatar);\n        when(bobAvatar.isImage(this.xcontext)).thenReturn(true);\n        when(bobAvatar.getReference()).thenReturn(bobAvatarReference);\n        when(this.xcontext.getWiki().getURL(bobAvatarReference, \"download\", \"width=30&height=30&keepAspectRatio=true\",\n            null, this.xcontext)).thenReturn(\"url/to/bob/avatar\");\n\n        PropertyValues values = this.provider.getValues(this.propertyReference, 5, \"foo\");\n\n        assertEquals(2, values.getPropertyValues().size());\n\n        assertEquals(\"Users.Alice\", values.getPropertyValues().get(0).getValue());\n        assertEquals(\"Alice One\", values.getPropertyValues().get(0).getMetaData().get(\"label\"));\n        assertEquals(3L, values.getPropertyValues().get(0).getMetaData().get(\"count\"));\n        assertTrue(values.getPropertyValues().get(0).getMetaData().get(\"icon\") instanceof Map);\n        assertEquals(\"url/to/alice\", values.getPropertyValues().get(0).getMetaData().get(\"url\"));\n\n        assertEquals(\"Users.Bob\", values.getPropertyValues().get(1).getValue());\n        assertEquals(\"Bob the Great\", values.getPropertyValues().get(1).getMetaData().get(\"label\"));\n        assertEquals(17L, values.getPropertyValues().get(1).getMetaData().get(\"count\"));\n        assertTrue(values.getPropertyValues().get(1).getMetaData().get(\"icon\") instanceof Map);\n        Map icon = (Map) values.getPropertyValues().get(1).getMetaData().get(\"icon\");\n        assertEquals(\"url/to/bob/avatar\", icon.get(\"url\"));\n        assertEquals(\"IMAGE\", icon.get(\"iconSetType\"));\n        assertEquals(\"url/to/bob\", values.getPropertyValues().get(1).getMetaData().get(\"url\"));\n\n        verify(this.allowedValuesQuery, never()).setWiki(any(String.class));\n        verify(this.allowedValuesQuery, times(1)).execute();\n\n        verify(filters).clear();\n        verify(this.usedValuesQuery).addFilter(documentFilter);\n        verify(this.usedValuesQuery).addFilter(viewableFilter);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "UsersClassPropertyValuesProviderTest.java",
        "method_name": "getValuesLocal",
        "raw_code": "@ParameterizedTest\n    @ValueSource(booleans = { true, false })\n    void getValuesLocal(boolean hasAccess) throws Exception\n    {\n        when(this.authorizationManager.hasAccess(any(), any())).thenReturn(hasAccess);\n\n        when(this.wikiUserManager.getUserScope(this.classReference.getWikiReference().getName()))\n            .thenReturn(UserScope.LOCAL_ONLY);\n\n        DocumentReference aliceReference = new DocumentReference(\"wiki\", \"Users\", \"Alice\");\n        when(this.allowedValuesQuery.execute())\n            .thenReturn(Collections.singletonList(new Object[] { aliceReference, \" Alice One \" }));\n        when(this.xcontext.getWiki().getDocument(aliceReference, this.xcontext))\n            .thenReturn(mock(XWikiDocument.class, \"alice\"));\n\n        QueryFilter documentFilter = this.componentManager.getInstance(QueryFilter.class, \"document\");\n        QueryFilter viewableFilter = this.componentManager.getInstance(QueryFilter.class, \"viewable\");\n        List<QueryFilter> filters = mock(List.class);\n        DocumentReference bobReference = new DocumentReference(\"wiki\", \"Users\", \"Bob\");\n        when(this.usedValuesQuery.getFilters()).thenReturn(filters);\n        when(this.usedValuesQuery.execute())\n            .thenReturn(Arrays.asList(new Object[] { bobReference, 17L }, new Object[] { aliceReference, 3L }));\n\n        EntityReferenceSerializer<String> compactSerializer =\n            this.componentManager.getInstance(EntityReferenceSerializer.TYPE_STRING, \"compact\");\n        when(compactSerializer.serialize(aliceReference, this.classReference.getWikiReference()))\n            .thenReturn(\"Users.Alice\");\n        when(compactSerializer.serialize(bobReference, this.classReference.getWikiReference())).thenReturn(\"Users.Bob\");\n\n        when(this.xcontext.getWiki().getPlainUserName(bobReference, this.xcontext)).thenReturn(\"Bob the Great\");\n\n        when(this.xcontext.getWiki().getURL(aliceReference, this.xcontext)).thenReturn(\"url/to/alice\");\n        when(this.xcontext.getWiki().getURL(bobReference, this.xcontext)).thenReturn(\"url/to/bob\");\n\n        XWikiDocument bobProfile = mock(XWikiDocument.class);\n        XWikiAttachment bobAvatar = mock(XWikiAttachment.class);\n        AttachmentReference bobAvatarReference = new AttachmentReference(\"somePhoto.png\", bobReference);\n        when(this.xcontext.getWiki().getDocument(bobReference, this.xcontext)).thenReturn(bobProfile);\n        when(bobProfile.getStringValue(\"avatar\")).thenReturn(bobAvatarReference.getName());\n        when(bobProfile.getAttachment(\"somePhoto.png\")).thenReturn(bobAvatar);\n        when(bobAvatar.isImage(this.xcontext)).thenReturn(true);\n        when(bobAvatar.getReference()).thenReturn(bobAvatarReference);\n        when(this.xcontext.getWiki().getURL(bobAvatarReference, \"download\", \"width=30&height=30&keepAspectRatio=true\",\n            null, this.xcontext)).thenReturn(\"url/to/bob/avatar\");\n\n        PropertyValues values = this.provider.getValues(this.propertyReference, 5, \"foo\");\n\n        assertEquals(2, values.getPropertyValues().size());\n\n        assertEquals(\"Users.Alice\", values.getPropertyValues().get(0).getValue());\n        assertEquals(\"Alice One\", values.getPropertyValues().get(0).getMetaData().get(\"label\"));\n        assertEquals(3L, values.getPropertyValues().get(0).getMetaData().get(\"count\"));\n        assertTrue(values.getPropertyValues().get(0).getMetaData().get(\"icon\") instanceof Map);\n        assertEquals(\"url/to/alice\", values.getPropertyValues().get(0).getMetaData().get(\"url\"));\n\n        assertEquals(\"Users.Bob\", values.getPropertyValues().get(1).getValue());\n        assertEquals(\"Bob the Great\", values.getPropertyValues().get(1).getMetaData().get(\"label\"));\n        assertEquals(17L, values.getPropertyValues().get(1).getMetaData().get(\"count\"));\n        assertTrue(values.getPropertyValues().get(1).getMetaData().get(\"icon\") instanceof Map);\n        Map icon = (Map) values.getPropertyValues().get(1).getMetaData().get(\"icon\");\n        if (hasAccess) {\n            assertEquals(\"url/to/bob/avatar\", icon.get(\"url\"));\n            assertEquals(\"IMAGE\", icon.get(\"iconSetType\"));\n        } else {\n            assertEquals(\"user\", mockingDetails(icon).getMockCreationSettings().getMockName().toString());\n        }\n        assertEquals(\"url/to/bob\", values.getPropertyValues().get(1).getMetaData().get(\"url\"));\n\n        verify(this.allowedValuesQuery, never()).setWiki(any(String.class));\n        verify(this.allowedValuesQuery, times(1)).execute();\n\n        verify(filters).clear();\n        verify(this.usedValuesQuery).addFilter(documentFilter);\n        verify(this.usedValuesQuery).addFilter(viewableFilter);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49584",
    "cwe_list": [
      "CWE-201"
    ],
    "commit_hash": "ee642f973a7c95d2d146fe03c81bcdee1871f4ec",
    "short_hash": "ee642f97",
    "vulnerableMethods_before": [
      {
        "filename": "UsersClassPropertyValuesProvider.java",
        "method_name": "getIcon",
        "raw_code": "@Override\n    protected Map<String, Object> getIcon(DocumentReference userReference)\n    {\n        Map<String, Object> icon = new HashMap<>();\n        XWikiContext xcontext = this.xcontextProvider.get();\n        try {\n            XWikiDocument userProfileDocument = xcontext.getWiki().getDocument(userReference, xcontext);\n            String avatar = userProfileDocument.getStringValue(\"avatar\");\n            XWikiAttachment avatarAttachment = userProfileDocument.getAttachment(avatar);\n            if (avatarAttachment != null && avatarAttachment.isImage(xcontext)) {\n                icon.put(IconManager.META_DATA_URL, xcontext.getWiki().getURL(avatarAttachment.getReference(),\n                    \"download\", \"width=30&height=30&keepAspectRatio=true\", null, xcontext));\n                icon.put(IconManager.META_DATA_ICON_SET_TYPE, IconType.IMAGE.name());\n            }\n        } catch (XWikiException e) {\n            this.logger.warn(\n                \"Failed to read the avatar of user [{}]. Root cause is [{}]. Using the default avatar instead.\",\n                userReference.getName(), ExceptionUtils.getRootCauseMessage(e));\n        }\n        if (!icon.containsKey(IconManager.META_DATA_URL)) {\n            try {\n                icon = this.iconManager.getMetaData(DEFAULT_ICON_NAME);\n            } catch (IconException e) {\n                this.logger.warn(\"Error getting the icon [{}]. Root cause is [{}].\", DEFAULT_ICON_NAME,\n                    ExceptionUtils.getRootCause(e));\n            }\n        }\n\n        return icon;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "UsersClassPropertyValuesProvider.java",
        "method_name": "getIcon",
        "raw_code": "@Override\n    protected Map<String, Object> getIcon(DocumentReference userReference)\n    {\n        Map<String, Object> icon = new HashMap<>();\n\n        if (this.contextualAuthorizationManager.hasAccess(Right.VIEW, userReference)) {\n            XWikiContext xcontext = this.xcontextProvider.get();\n            try {\n                XWikiDocument userProfileDocument = xcontext.getWiki().getDocument(userReference, xcontext);\n                String avatar = userProfileDocument.getStringValue(\"avatar\");\n                XWikiAttachment avatarAttachment = userProfileDocument.getAttachment(avatar);\n                if (avatarAttachment != null && avatarAttachment.isImage(xcontext)) {\n                    icon.put(IconManager.META_DATA_URL, xcontext.getWiki().getURL(avatarAttachment.getReference(),\n                        \"download\", \"width=30&height=30&keepAspectRatio=true\", null, xcontext));\n                    icon.put(IconManager.META_DATA_ICON_SET_TYPE, IconType.IMAGE.name());\n                }\n            } catch (XWikiException e) {\n                this.logger.warn(\n                    \"Failed to read the avatar of user [{}]. Root cause is [{}]. Using the default avatar instead.\",\n                    userReference.getName(), ExceptionUtils.getRootCauseMessage(e));\n            }\n        }\n\n        if (!icon.containsKey(IconManager.META_DATA_URL)) {\n            try {\n                icon = this.iconManager.getMetaData(DEFAULT_ICON_NAME);\n            } catch (IconException e) {\n                this.logger.warn(\"Error getting the icon [{}]. Root cause is [{}].\", DEFAULT_ICON_NAME,\n                    ExceptionUtils.getRootCause(e));\n            }\n        }\n\n        return icon;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49584",
    "cwe_list": [
      "CWE-201"
    ],
    "commit_hash": "ee642f973a7c95d2d146fe03c81bcdee1871f4ec",
    "short_hash": "ee642f97",
    "vulnerableMethods_before": [
      {
        "filename": "GroupsClassPropertyValuesProviderTest.java",
        "method_name": "getValuesLocal",
        "raw_code": "@Test\n    public void getValuesLocal() throws Exception\n    {\n        when(this.wikiUserManager.getUserScope(this.classReference.getWikiReference().getName()))\n            .thenReturn(UserScope.LOCAL_ONLY);\n\n        DocumentReference devsReference = new DocumentReference(\"wiki\", \"Groups\", \"Devs\");\n        XWikiDocument devsProfile = mock(XWikiDocument.class, \"devs\");\n        when(this.xcontext.getWiki().getDocument(devsReference, this.xcontext)).thenReturn(devsProfile);\n        when(devsProfile.getRenderedTitle(Syntax.PLAIN_1_0, this.xcontext)).thenReturn(\"Developers\");\n\n        DocumentReference adminsReference = new DocumentReference(\"wiki\", \"Groups\", \"Admins\");\n        XWikiDocument adminsProfile = mock(XWikiDocument.class, \"admins\");\n        XWikiAttachment notAnImageAttachment = mock(XWikiAttachment.class, \"noAnImage\");\n        XWikiAttachment imageAttachment = mock(XWikiAttachment.class, \"image\");\n        AttachmentReference imageAttachmentReference = new AttachmentReference(\"admins.png\", adminsReference);\n        when(this.xcontext.getWiki().getDocument(adminsReference, this.xcontext)).thenReturn(adminsProfile);\n        when(adminsProfile.getRenderedTitle(Syntax.PLAIN_1_0, this.xcontext)).thenReturn(\"Administrators\");\n        when(adminsProfile.getAttachmentList()).thenReturn(Arrays.asList(notAnImageAttachment, imageAttachment));\n        when(imageAttachment.isImage(this.xcontext)).thenReturn(true);\n        when(imageAttachment.getReference()).thenReturn(imageAttachmentReference);\n        when(this.xcontext.getWiki().getURL(imageAttachmentReference, \"download\",\n            \"width=30&height=30&keepAspectRatio=true\", null, this.xcontext)).thenReturn(\"url/to/admins/image\");\n\n        when(this.allowedValuesQuery.execute()).thenReturn(Arrays.asList(devsReference, adminsReference));\n\n        PropertyValues values = this.provider.getValues(this.propertyReference, 5, \"foo\");\n\n        assertEquals(2, values.getPropertyValues().size());\n\n        assertEquals(\"Developers\", values.getPropertyValues().get(0).getMetaData().get(\"label\"));\n        assertTrue(values.getPropertyValues().get(0).getMetaData().get(\"icon\") instanceof Map);\n\n        assertEquals(\"Administrators\", values.getPropertyValues().get(1).getMetaData().get(\"label\"));\n        assertTrue(values.getPropertyValues().get(1).getMetaData().get(\"icon\") instanceof Map);\n        Map icon = (Map) values.getPropertyValues().get(1).getMetaData().get(\"icon\");\n        assertEquals(\"url/to/admins/image\", icon.get(\"url\"));\n        assertEquals(\"IMAGE\", icon.get(\"iconSetType\"));\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "GroupsClassPropertyValuesProviderTest.java",
        "method_name": "getValuesLocal",
        "raw_code": "@ParameterizedTest\n    @ValueSource(booleans = { true, false })\n    void getValuesLocal(boolean hasAccess) throws Exception\n    {\n        when(this.wikiUserManager.getUserScope(this.classReference.getWikiReference().getName()))\n            .thenReturn(UserScope.LOCAL_ONLY);\n        when(this.authorizationManager.hasAccess(any(), any())).thenReturn(hasAccess);\n\n        DocumentReference devsReference = new DocumentReference(\"wiki\", \"Groups\", \"Devs\");\n        XWikiDocument devsProfile = mock(XWikiDocument.class, \"devs\");\n        when(this.xcontext.getWiki().getDocument(devsReference, this.xcontext)).thenReturn(devsProfile);\n        when(devsProfile.getRenderedTitle(Syntax.PLAIN_1_0, this.xcontext)).thenReturn(\"Developers\");\n\n        DocumentReference adminsReference = new DocumentReference(\"wiki\", \"Groups\", \"Admins\");\n        XWikiDocument adminsProfile = mock(XWikiDocument.class, \"admins\");\n        XWikiAttachment notAnImageAttachment = mock(XWikiAttachment.class, \"noAnImage\");\n        XWikiAttachment imageAttachment = mock(XWikiAttachment.class, \"image\");\n        AttachmentReference imageAttachmentReference = new AttachmentReference(\"admins.png\", adminsReference);\n        when(this.xcontext.getWiki().getDocument(adminsReference, this.xcontext)).thenReturn(adminsProfile);\n        when(adminsProfile.getRenderedTitle(Syntax.PLAIN_1_0, this.xcontext)).thenReturn(\"Administrators\");\n        when(adminsProfile.getAttachmentList()).thenReturn(Arrays.asList(notAnImageAttachment, imageAttachment));\n        when(imageAttachment.isImage(this.xcontext)).thenReturn(true);\n        when(imageAttachment.getReference()).thenReturn(imageAttachmentReference);\n        when(this.xcontext.getWiki().getURL(imageAttachmentReference, \"download\",\n            \"width=30&height=30&keepAspectRatio=true\", null, this.xcontext)).thenReturn(\"url/to/admins/image\");\n\n        when(this.allowedValuesQuery.execute()).thenReturn(Arrays.asList(devsReference, adminsReference));\n\n        PropertyValues values = this.provider.getValues(this.propertyReference, 5, \"foo\");\n\n        assertEquals(2, values.getPropertyValues().size());\n\n        Object devsLabel = values.getPropertyValues().get(0).getMetaData().get(\"label\");\n        if (hasAccess) {\n            assertEquals(\"Developers\", devsLabel);\n        } else {\n            assertEquals(\"Devs\", devsLabel);\n        }\n        assertInstanceOf(Map.class, values.getPropertyValues().get(0).getMetaData().get(\"icon\"));\n\n        Object adminLabel = values.getPropertyValues().get(1).getMetaData().get(\"label\");\n        if (hasAccess) {\n            assertEquals(\"Administrators\", adminLabel);\n        } else {\n            assertEquals(\"Admins\", adminLabel);\n        }\n        assertInstanceOf(Map.class, values.getPropertyValues().get(1).getMetaData().get(\"icon\"));\n        Map icon = (Map) values.getPropertyValues().get(1).getMetaData().get(\"icon\");\n        if (hasAccess) {\n            assertEquals(\"url/to/admins/image\", icon.get(\"url\"));\n            assertEquals(\"IMAGE\", icon.get(\"iconSetType\"));\n        } else {\n            assertEquals(\"group\", mockingDetails(icon).getMockCreationSettings().getMockName().toString());\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49584",
    "cwe_list": [
      "CWE-201"
    ],
    "commit_hash": "ee642f973a7c95d2d146fe03c81bcdee1871f4ec",
    "short_hash": "ee642f97",
    "vulnerableMethods_before": [
      {
        "filename": "GroupsClassPropertyValuesProviderTest.java",
        "method_name": "getValuesLocalAndGlobal",
        "raw_code": "@Test\n    public void getValuesLocalAndGlobal() throws Exception\n    {\n        // We can have local groups.\n        when(this.wikiUserManager.getUserScope(this.classReference.getWikiReference().getName()))\n            .thenReturn(UserScope.GLOBAL_ONLY);\n\n        WikiDescriptorManager wikiDescriptorManager = this.componentManager.getInstance(WikiDescriptorManager.class);\n        when(wikiDescriptorManager.getMainWikiId()).thenReturn(\"chess\");\n\n        this.provider.getValues(this.propertyReference, 5, \"foo\");\n\n        verify(this.allowedValuesQuery).setWiki(\"chess\");\n        verify(this.allowedValuesQuery, times(2)).execute();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "GroupsClassPropertyValuesProviderTest.java",
        "method_name": "getValuesLocalAndGlobal",
        "raw_code": "@Test\n    void getValuesLocalAndGlobal() throws Exception\n    {\n        // We can have local groups.\n        when(this.wikiUserManager.getUserScope(this.classReference.getWikiReference().getName()))\n            .thenReturn(UserScope.GLOBAL_ONLY);\n\n        WikiDescriptorManager wikiDescriptorManager = this.componentManager.getInstance(WikiDescriptorManager.class);\n        when(wikiDescriptorManager.getMainWikiId()).thenReturn(\"chess\");\n\n        this.provider.getValues(this.propertyReference, 5, \"foo\");\n\n        verify(this.allowedValuesQuery).setWiki(\"chess\");\n        verify(this.allowedValuesQuery, times(2)).execute();\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49584",
    "cwe_list": [
      "CWE-201"
    ],
    "commit_hash": "ee642f973a7c95d2d146fe03c81bcdee1871f4ec",
    "short_hash": "ee642f97",
    "vulnerableMethods_before": [
      {
        "filename": "GroupsClassPropertyValuesProvider.java",
        "method_name": "getIcon",
        "raw_code": "@Override\n    protected Map<String, Object> getIcon(DocumentReference groupReference)\n    {\n        Map<String, Object> icon = new HashMap<>();\n        XWikiContext xcontext = this.xcontextProvider.get();\n        try {\n            XWikiDocument groupProfileDocument = xcontext.getWiki().getDocument(groupReference, xcontext);\n            XWikiAttachment avatarAttachment = getFirstImageAttachment(groupProfileDocument, xcontext);\n            if (avatarAttachment != null) {\n                icon.put(IconManager.META_DATA_URL, xcontext.getWiki().getURL(avatarAttachment.getReference(),\n                    \"download\", \"width=30&height=30&keepAspectRatio=true\", null, xcontext));\n                icon.put(IconManager.META_DATA_ICON_SET_TYPE, IconType.IMAGE.name());\n            }\n        } catch (XWikiException e) {\n            this.logger.warn(\n                \"Failed to read the avatar of group [{}]. Root cause is [{}]. Using the default avatar instead.\",\n                groupReference.getName(), ExceptionUtils.getRootCauseMessage(e));\n        }\n        if (!icon.containsKey(IconManager.META_DATA_URL)) {\n            try {\n                icon = this.iconManager.getMetaData(DEFAULT_ICON_NAME);\n            } catch (IconException e) {\n                this.logger.warn(\"Error getting the icon [{}]. Root cause is [{}].\", DEFAULT_ICON_NAME,\n                    ExceptionUtils.getRootCause(e));\n            }\n        }\n\n        return icon;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "GroupsClassPropertyValuesProvider.java",
        "method_name": "getIcon",
        "raw_code": "@Override\n    protected Map<String, Object> getIcon(DocumentReference groupReference)\n    {\n        Map<String, Object> icon = new HashMap<>();\n        XWikiContext xcontext = this.xcontextProvider.get();\n        if (this.contextualAuthorizationManager.hasAccess(Right.VIEW, groupReference)) {\n            try {\n                XWikiDocument groupProfileDocument = xcontext.getWiki().getDocument(groupReference, xcontext);\n                XWikiAttachment avatarAttachment = getFirstImageAttachment(groupProfileDocument, xcontext);\n                if (avatarAttachment != null) {\n                    icon.put(IconManager.META_DATA_URL, xcontext.getWiki().getURL(avatarAttachment.getReference(),\n                        \"download\", \"width=30&height=30&keepAspectRatio=true\", null, xcontext));\n                    icon.put(IconManager.META_DATA_ICON_SET_TYPE, IconType.IMAGE.name());\n                }\n            } catch (XWikiException e) {\n                this.logger.warn(\n                    \"Failed to read the avatar of group [{}]. Root cause is [{}]. Using the default avatar instead.\",\n                    groupReference.getName(), ExceptionUtils.getRootCauseMessage(e));\n            }\n        }\n\n        if (!icon.containsKey(IconManager.META_DATA_URL)) {\n            try {\n                icon = this.iconManager.getMetaData(DEFAULT_ICON_NAME);\n            } catch (IconException e) {\n                this.logger.warn(\"Error getting the icon [{}]. Root cause is [{}].\", DEFAULT_ICON_NAME,\n                    ExceptionUtils.getRootCause(e));\n            }\n        }\n\n        return icon;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49584",
    "cwe_list": [
      "CWE-201"
    ],
    "commit_hash": "ee642f973a7c95d2d146fe03c81bcdee1871f4ec",
    "short_hash": "ee642f97",
    "vulnerableMethods_before": [
      {
        "filename": "GroupsClassPropertyValuesProvider.java",
        "method_name": "getLabel",
        "raw_code": "@Override\n    protected String getLabel(DocumentReference groupReference, Object currentLabel)\n    {\n        try {\n            XWikiContext xcontext = this.xcontextProvider.get();\n            return xcontext.getWiki().getDocument(groupReference, xcontext).getRenderedTitle(Syntax.PLAIN_1_0,\n                xcontext);\n        } catch (XWikiException e) {\n            this.logger.warn(\"Failed to get the title of group [{}]. Root cause is [{}].\",\n                this.entityReferenceSerializer.serialize(groupReference), ExceptionUtils.getRootCauseMessage(e));\n            return super.getLabel(groupReference, currentLabel);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "GroupsClassPropertyValuesProvider.java",
        "method_name": "getLabel",
        "raw_code": "@Override\n    protected String getLabel(DocumentReference groupReference, Object currentLabel)\n    {\n        if (this.contextualAuthorizationManager.hasAccess(Right.VIEW, groupReference)) {\n            try {\n                XWikiContext xcontext = this.xcontextProvider.get();\n                return xcontext.getWiki().getDocument(groupReference, xcontext).getRenderedTitle(Syntax.PLAIN_1_0,\n                    xcontext);\n            } catch (XWikiException e) {\n                this.logger.warn(\"Failed to get the title of group [{}]. Root cause is [{}].\",\n                    this.entityReferenceSerializer.serialize(groupReference), ExceptionUtils.getRootCauseMessage(e));\n            }\n        }\n\n        return super.getLabel(groupReference, currentLabel);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49584",
    "cwe_list": [
      "CWE-201"
    ],
    "commit_hash": "ee642f973a7c95d2d146fe03c81bcdee1871f4ec",
    "short_hash": "ee642f97",
    "vulnerableMethods_before": [
      {
        "filename": "PageClassPropertyValuesProviderTest.java",
        "method_name": "configure",
        "raw_code": "@BeforeEach\n    public void configure() throws Exception\n    {\n        super.configure();\n\n        when(this.pageClass.getOwnerDocument()).thenReturn(this.classDocument);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "PageClassPropertyValuesProviderTest.java",
        "method_name": "configure",
        "raw_code": "@Override\n    @BeforeEach\n    public void configure() throws Exception\n    {\n        super.configure();\n\n        when(this.pageClass.getOwnerDocument()).thenReturn(this.classDocument);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49584",
    "cwe_list": [
      "CWE-201"
    ],
    "commit_hash": "ee642f973a7c95d2d146fe03c81bcdee1871f4ec",
    "short_hash": "ee642f97",
    "vulnerableMethods_before": [
      {
        "filename": "PageClassPropertyValuesProviderTest.java",
        "method_name": "getValues",
        "raw_code": "@Test\n    public void getValues() throws Exception\n    {\n        WikiReference wikiRef = new WikiReference(\"wiki\");\n        SpaceReference space1Ref = new SpaceReference(\"space1\", wikiRef);\n        SpaceReference space2Ref = new SpaceReference(\"space2\", space1Ref);\n        EntityReference pageRef = new DocumentReference(\"page\", space2Ref);\n\n        XWikiDocument space1Doc = mock(XWikiDocument.class);\n        XWikiDocument space2Doc = mock(XWikiDocument.class);\n        XWikiDocument pageDoc = mock(XWikiDocument.class);\n        when(this.xwiki.getDocument(space1Ref, this.xcontext)).thenReturn(space1Doc);\n        when(this.xwiki.getDocument(space2Ref, this.xcontext)).thenReturn(space2Doc);\n        when(this.xwiki.getDocument(pageRef, this.xcontext)).thenReturn(pageDoc);\n        when(space1Doc.getTranslatedDocument(this.xcontext)).thenReturn(space1Doc);\n        when(space2Doc.getTranslatedDocument(this.xcontext)).thenReturn(space2Doc);\n        when(pageDoc.getTranslatedDocument(this.xcontext)).thenReturn(pageDoc);\n        when(space1Doc.getRenderedTitle(Syntax.PLAIN_1_0, this.xcontext)).thenReturn(\"Space 1\");\n        when(space2Doc.getRenderedTitle(Syntax.PLAIN_1_0, this.xcontext)).thenReturn(\"Space 2\");\n        when(pageDoc.getRenderedTitle(Syntax.PLAIN_1_0, this.xcontext)).thenReturn(\"Page\");\n\n        Query query = mock(Query.class);\n        when(query.execute()).thenReturn(Collections.singletonList(pageRef));\n\n        PropertyValues values = this.provider.getValues(query, 3, \"\", this.pageClass);\n        assertEquals(1, values.getPropertyValues().size());\n\n        Map<String, Object> metadata = values.getPropertyValues().get(0).getMetaData();\n        assertEquals(\"Space 1 / Space 2\", metadata.get(\"hint\"));\n        assertEquals(\"Page\", metadata.get(\"label\"));\n        assertTrue(metadata.containsKey(META_DATA_ICON));\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "PageClassPropertyValuesProviderTest.java",
        "method_name": "getValues",
        "raw_code": "@ParameterizedTest\n    @ValueSource(booleans = { true, false })\n    void getValues(boolean hasAccess) throws Exception\n    {\n        when(this.authorizationManager.hasAccess(any(), any())).thenReturn(hasAccess);\n\n        WikiReference wikiRef = new WikiReference(\"wiki\");\n        SpaceReference space1Ref = new SpaceReference(\"space1\", wikiRef);\n        SpaceReference space2Ref = new SpaceReference(\"space2\", space1Ref);\n        EntityReference pageRef = new DocumentReference(\"page\", space2Ref);\n\n        XWikiDocument space1Doc = mock(XWikiDocument.class);\n        XWikiDocument space2Doc = mock(XWikiDocument.class);\n        XWikiDocument pageDoc = mock(XWikiDocument.class);\n        when(this.xwiki.getDocument(space1Ref, this.xcontext)).thenReturn(space1Doc);\n        when(this.xwiki.getDocument(space2Ref, this.xcontext)).thenReturn(space2Doc);\n        when(this.xwiki.getDocument(pageRef, this.xcontext)).thenReturn(pageDoc);\n        when(space1Doc.getTranslatedDocument(this.xcontext)).thenReturn(space1Doc);\n        when(space2Doc.getTranslatedDocument(this.xcontext)).thenReturn(space2Doc);\n        when(pageDoc.getTranslatedDocument(this.xcontext)).thenReturn(pageDoc);\n        when(space1Doc.getRenderedTitle(Syntax.PLAIN_1_0, this.xcontext)).thenReturn(\"Space 1\");\n        when(space2Doc.getRenderedTitle(Syntax.PLAIN_1_0, this.xcontext)).thenReturn(\"Space 2\");\n        when(pageDoc.getRenderedTitle(Syntax.PLAIN_1_0, this.xcontext)).thenReturn(\"Page\");\n\n        Query query = mock(Query.class);\n        when(query.execute()).thenReturn(Collections.singletonList(pageRef));\n\n        PropertyValues values = this.provider.getValues(query, 3, \"\", this.pageClass);\n        assertEquals(1, values.getPropertyValues().size());\n\n        Map<String, Object> metadata = values.getPropertyValues().get(0).getMetaData();\n        if (hasAccess) {\n            assertEquals(\"Space 1 / Space 2\", metadata.get(\"hint\"));\n            assertEquals(\"Page\", metadata.get(\"label\"));\n        } else {\n            assertEquals(\"space1 / space2\", metadata.get(\"hint\"));\n            assertEquals(\"page\", metadata.get(\"label\"));\n        }\n        assertTrue(metadata.containsKey(META_DATA_ICON));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49584",
    "cwe_list": [
      "CWE-201"
    ],
    "commit_hash": "ee642f973a7c95d2d146fe03c81bcdee1871f4ec",
    "short_hash": "ee642f97",
    "vulnerableMethods_before": [
      {
        "filename": "PageClassPropertyValuesProviderTest.java",
        "method_name": "getValuesWithTerminalPage",
        "raw_code": "@Test\n    public void getValuesWithTerminalPage() throws Exception\n    {\n        WikiReference wikiRef = new WikiReference(\"wiki\");\n        SpaceReference space1Ref = new SpaceReference(\"space1\", wikiRef);\n        SpaceReference space2Ref = new SpaceReference(\"space2\", space1Ref);\n        EntityReference page1Ref = new DocumentReference(\"page\", space2Ref);\n        EntityReference page2Ref = new DocumentReference(XWiki.DEFAULT_SPACE_HOMEPAGE, space2Ref);\n\n        XWikiDocument space1Doc = mock(XWikiDocument.class);\n        XWikiDocument space2Doc = mock(XWikiDocument.class);\n        XWikiDocument page1Doc = mock(XWikiDocument.class);\n        XWikiDocument page2Doc = mock(XWikiDocument.class);\n        when(this.xwiki.getDocument(space1Ref, this.xcontext)).thenReturn(space1Doc);\n        when(this.xwiki.getDocument(space2Ref, this.xcontext)).thenReturn(page2Doc);\n        when(this.xwiki.getDocument(page1Ref, this.xcontext)).thenReturn(page1Doc);\n        when(this.xwiki.getDocument(page2Ref, this.xcontext)).thenReturn(page2Doc);\n        when(space1Doc.getTranslatedDocument(this.xcontext)).thenReturn(space1Doc);\n        when(space2Doc.getTranslatedDocument(this.xcontext)).thenReturn(space2Doc);\n        when(page1Doc.getTranslatedDocument(this.xcontext)).thenReturn(page1Doc);\n        when(page2Doc.getTranslatedDocument(this.xcontext)).thenReturn(page2Doc);\n        when(space1Doc.getRenderedTitle(Syntax.PLAIN_1_0, this.xcontext)).thenReturn(\"Space 1\");\n        when(space2Doc.getRenderedTitle(Syntax.PLAIN_1_0, this.xcontext)).thenReturn(\"Space 2\");\n        when(page1Doc.getRenderedTitle(Syntax.PLAIN_1_0, this.xcontext)).thenReturn(\"Page 1\");\n        when(page2Doc.getRenderedTitle(Syntax.PLAIN_1_0, this.xcontext)).thenReturn(\"Page 2\");\n\n        Query query = mock(Query.class);\n        when(query.execute()).thenReturn(Arrays.asList(page1Ref, page2Ref));\n\n        PropertyValues values = this.provider.getValues(query, 3, \"\", this.pageClass);\n        assertEquals(2, values.getPropertyValues().size());\n\n        Map<String, Object> metadata = values.getPropertyValues().get(0).getMetaData();\n        assertEquals(\"Space 1 / Page 2\", metadata.get(\"hint\"));\n        assertEquals(\"Page 1\", metadata.get(\"label\"));\n        assertTrue(metadata.containsKey(META_DATA_ICON));\n\n        metadata = values.getPropertyValues().get(1).getMetaData();\n        assertEquals(\"Space 1\", metadata.get(\"hint\"));\n        assertEquals(\"Page 2\", metadata.get(\"label\"));\n        assertTrue(metadata.containsKey(META_DATA_ICON));\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "PageClassPropertyValuesProviderTest.java",
        "method_name": "getValuesWithTerminalPage",
        "raw_code": "@ParameterizedTest\n    @ValueSource(booleans = { true, false })\n    void getValuesWithTerminalPage(boolean hasAccess) throws Exception\n    {\n        when(this.authorizationManager.hasAccess(any(), any())).thenReturn(hasAccess);\n\n        WikiReference wikiRef = new WikiReference(\"wiki\");\n        SpaceReference space1Ref = new SpaceReference(\"space1\", wikiRef);\n        SpaceReference space2Ref = new SpaceReference(\"space2\", space1Ref);\n        EntityReference page1Ref = new DocumentReference(\"page\", space2Ref);\n        EntityReference page2Ref = new DocumentReference(XWiki.DEFAULT_SPACE_HOMEPAGE, space2Ref);\n\n        XWikiDocument space1Doc = mock(XWikiDocument.class);\n        XWikiDocument space2Doc = mock(XWikiDocument.class);\n        XWikiDocument page1Doc = mock(XWikiDocument.class);\n        XWikiDocument page2Doc = mock(XWikiDocument.class);\n        when(this.xwiki.getDocument(space1Ref, this.xcontext)).thenReturn(space1Doc);\n        when(this.xwiki.getDocument(space2Ref, this.xcontext)).thenReturn(page2Doc);\n        when(this.xwiki.getDocument(page1Ref, this.xcontext)).thenReturn(page1Doc);\n        when(this.xwiki.getDocument(page2Ref, this.xcontext)).thenReturn(page2Doc);\n        when(space1Doc.getTranslatedDocument(this.xcontext)).thenReturn(space1Doc);\n        when(space2Doc.getTranslatedDocument(this.xcontext)).thenReturn(space2Doc);\n        when(page1Doc.getTranslatedDocument(this.xcontext)).thenReturn(page1Doc);\n        when(page2Doc.getTranslatedDocument(this.xcontext)).thenReturn(page2Doc);\n        when(space1Doc.getRenderedTitle(Syntax.PLAIN_1_0, this.xcontext)).thenReturn(\"Space 1\");\n        when(space2Doc.getRenderedTitle(Syntax.PLAIN_1_0, this.xcontext)).thenReturn(\"Space 2\");\n        when(page1Doc.getRenderedTitle(Syntax.PLAIN_1_0, this.xcontext)).thenReturn(\"Page 1\");\n        when(page2Doc.getRenderedTitle(Syntax.PLAIN_1_0, this.xcontext)).thenReturn(\"Page 2\");\n\n        Query query = mock(Query.class);\n        when(query.execute()).thenReturn(Arrays.asList(page1Ref, page2Ref));\n\n        PropertyValues values = this.provider.getValues(query, 3, \"\", this.pageClass);\n        assertEquals(2, values.getPropertyValues().size());\n\n        Map<String, Object> metadata = values.getPropertyValues().get(0).getMetaData();\n        if (hasAccess) {\n            assertEquals(\"Space 1 / Page 2\", metadata.get(\"hint\"));\n            assertEquals(\"Page 1\", metadata.get(\"label\"));\n        } else {\n            assertEquals(\"space1 / space2\", metadata.get(\"hint\"));\n            assertEquals(\"page\", metadata.get(\"label\"));\n        }\n        assertTrue(metadata.containsKey(META_DATA_ICON));\n\n        metadata = values.getPropertyValues().get(1).getMetaData();\n        if (hasAccess) {\n            assertEquals(\"Space 1\", metadata.get(\"hint\"));\n            assertEquals(\"Page 2\", metadata.get(\"label\"));\n        } else {\n            assertEquals(\"space1\", metadata.get(\"hint\"));\n            assertEquals(\"space2\", metadata.get(\"label\"));\n        }\n        assertTrue(metadata.containsKey(META_DATA_ICON));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49584",
    "cwe_list": [
      "CWE-201"
    ],
    "commit_hash": "ee642f973a7c95d2d146fe03c81bcdee1871f4ec",
    "short_hash": "ee642f97",
    "vulnerableMethods_before": [
      {
        "filename": "PageClassPropertyValuesProvider.java",
        "method_name": "getLabel",
        "raw_code": "private String getLabel(EntityReference entityReference)\n    {\n        String label;\n        try {\n            XWikiContext xcontext = this.xcontextProvider.get();\n            XWikiDocument document;\n            document = xcontext.getWiki().getDocument(entityReference, xcontext).getTranslatedDocument(xcontext);\n            label = document.getRenderedTitle(Syntax.PLAIN_1_0, xcontext);\n        } catch (XWikiException e) {\n            this.logger.error(\"Error while loading the document [{}]. Root cause is [{}]\", entityReference,\n                ExceptionUtils.getRootCause(e));\n            if (entityReference instanceof DocumentReference) {\n                label = super.getLabel((DocumentReference) entityReference, \"\");\n            } else {\n                label = entityReference.getName();\n            }\n        }\n        return label;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "PageClassPropertyValuesProvider.java",
        "method_name": "getLabel",
        "raw_code": "private String getLabel(EntityReference entityReference)\n    {\n        String label = null;\n\n        if (this.contextualAuthorizationManager.hasAccess(Right.VIEW, entityReference)) {\n            try {\n                XWikiContext xcontext = this.xcontextProvider.get();\n                XWikiDocument document;\n                document = xcontext.getWiki().getDocument(entityReference, xcontext).getTranslatedDocument(xcontext);\n                label = document.getRenderedTitle(Syntax.PLAIN_1_0, xcontext);\n            } catch (XWikiException e) {\n                this.logger.error(\"Error while loading the document [{}]. Root cause is [{}]\", entityReference,\n                    ExceptionUtils.getRootCauseMessage(e), e);\n            }\n        }\n\n        if (label == null) {\n            if (entityReference instanceof DocumentReference documentReference) {\n                label = super.getLabel(documentReference, \"\");\n            } else {\n                label = entityReference.getName();\n            }\n        }\n        return label;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "fhir-ig-publisher",
    "cve_id": "CVE-2025-24363",
    "cwe_list": [
      "CWE-200"
    ],
    "commit_hash": "d968694b7dd041640efab5414d7077d5028569f7",
    "short_hash": "d968694b",
    "vulnerableMethods_before": [
      {
        "filename": "Publisher.java",
        "method_name": "generateDataFile",
        "raw_code": "private void generateDataFile(DBBuilder db) throws IOException, FHIRException, SQLException {\n    JsonObject data = new JsonObject();\n    data.add(\"path\", checkAppendSlash(specPath));\n    data.add(\"canonical\", igpkp.getCanonical());\n    data.add(\"igId\", publishedIg.getId());\n    data.add(\"igName\", publishedIg.getName());\n    data.add(\"packageId\", npmName);\n    data.add(\"igVer\", workingVersion());\n    data.add(\"errorCount\", getErrorCount());\n    data.add(\"version\", version);\n    \n    StringType rl = findReleaseLabel();  \n    if (rl == null) {\n      data.add(\"releaseLabel\", \"n/a\");\n      for (String l : allLangs()) {\n        data.add(\"releaseLabel\"+l, rcLangs.get(l).formatPhrase(RenderingI18nContext._NA));\n      }\n    } else { \n      data.add(\"releaseLabel\", rl.getValue());\n      addTranslationsToJson(data, \"releaseLabel\", rl, false);\n    }\n    data.add(\"revision\", specMaps.get(0).getBuild());\n    data.add(\"versionFull\", version+\"-\"+specMaps.get(0).getBuild());\n    data.add(\"toolingVersion\", Constants.VERSION);\n    data.add(\"toolingRevision\", ToolsVersion.TOOLS_VERSION_STR);\n    data.add(\"toolingVersionFull\", Constants.VERSION+\" (\"+ToolsVersion.TOOLS_VERSION_STR+\")\");\n    data.add(\"totalFiles\", fileList.size());\n    data.add(\"processedFiles\", changeList.size());\n    \n    if (repoSource != null) {\n      data.add(\"repoSource\", gh());\n    } else {\n      String git= getGitSource();\n      if (git != null) {\n        data.add(\"repoSource\", git);\n      }\n    }\n    data.add(\"genDate\", genTime());\n    data.add(\"genDay\", genDate());\n    if (db != null) {\n      for (JsonProperty p : data.getProperties()) {\n        db.metadata(p.getName(), p.getValue().asString());\n      }\n    }\n    JsonArray rt = data.forceArray(\"resourceTypes\");\n    List<String> rtl = context.getResourceNames();\n    for (String s : rtl) {\n      rt.add(s);\n    }\n    rt = data.forceArray(\"dataTypes\");\n    ContextUtilities cu = new ContextUtilities(context);\n    for (String s : cu.getTypeNames()) {\n      if (!rtl.contains(s)) {\n        rt.add(s);\n      }\n    }\n\n    JsonObject ig = new JsonObject();\n    data.add(\"ig\", ig);\n    ig.add(\"id\", publishedIg.getId());\n    ig.add(\"name\", publishedIg.getName());\n    ig.add(\"title\", publishedIg.getTitle());\n    addTranslationsToJson(ig, \"title\", publishedIg.getTitleElement(), false);\n    ig.add(\"url\", publishedIg.getUrl());\n    ig.add(\"version\", workingVersion());\n    ig.add(\"status\", publishedIg.getStatusElement().asStringValue());\n    ig.add(\"experimental\", publishedIg.getExperimental());\n    ig.add(\"publisher\", publishedIg.getPublisher());    \n    addTranslationsToJson(ig, \"publisher\", publishedIg.getPublisherElement(), false);\n    if (db != null) {\n      db.metadata(\"gitstatus\", getGitStatus());\n    }\n    if (previousVersionComparator != null && previousVersionComparator.hasLast() && !targetUrl().startsWith(\"file:\")) {\n      JsonObject diff = new JsonObject();\n      data.add(\"diff\", diff);\n      diff.add(\"name\", Utilities.encodeUri(previousVersionComparator.getLastName()));\n      diff.add(\"current\", Utilities.encodeUri(targetUrl()));\n      diff.add(\"previous\", Utilities.encodeUri(previousVersionComparator.getLastUrl()));\n    }    \n    if (ipaComparator != null && ipaComparator.hasLast() && !targetUrl().startsWith(\"file:\")) {\n      JsonObject diff = new JsonObject();\n      data.add(\"iga-diff\", diff);\n      diff.add(\"name\", Utilities.encodeUri(ipaComparator.getLastName()));\n      diff.add(\"current\", Utilities.encodeUri(targetUrl()));\n      diff.add(\"previous\", Utilities.encodeUri(ipaComparator.getLastUrl()));\n    }\n    if (ipsComparator != null && ipsComparator.hasLast() && !targetUrl().startsWith(\"file:\")) {\n      JsonObject diff = new JsonObject();\n      data.add(\"iga-diff\", diff);\n      diff.add(\"name\", Utilities.encodeUri(ipsComparator.getLastName()));\n      diff.add(\"current\", Utilities.encodeUri(targetUrl()));\n      diff.add(\"previous\", Utilities.encodeUri(ipsComparator.getLastUrl()));\n    }\n\n    if (publishedIg.hasContact()) {\n      JsonArray jc = new JsonArray();\n      ig.add(\"contact\", jc);\n      for (ContactDetail c : publishedIg.getContact()) {\n        JsonObject jco = new JsonObject();\n        jc.add(jco);\n        jco.add(\"name\", c.getName());\n        if (c.hasTelecom()) {\n          JsonArray jct = new JsonArray();\n          jco.add(\"telecom\", jct);\n          for (ContactPoint cc : c.getTelecom()) {\n            jct.add(new JsonString(cc.getValue()));\n          }\n        }\n      }\n      for (String l : allLangs()) {\n        jc = new JsonArray();\n        ig.add(\"contact\"+l, jc);\n        for (ContactDetail c : publishedIg.getContact()) {\n          JsonObject jco = new JsonObject();\n          jc.add(jco);\n          jco.add(\"name\", langUtils.getTranslationOrBase(c.getNameElement(), l));\n          if (c.hasTelecom()) {\n            JsonArray jct = new JsonArray();\n            jco.add(\"telecom\", jct);\n            for (ContactPoint cc : c.getTelecom()) {\n              jct.add(new JsonString(cc.getValue()));\n            }\n          }\n        }\n        \n      }\n    }\n    ig.add(\"date\", publishedIg.getDateElement().asStringValue());\n    ig.add(\"description\", ProfileUtilities.processRelativeUrls(publishedIg.getDescription(), \"\", igpkp.specPath(), context.getResourceNames(), specMaps.get(0).listTargets(), pageTargets(), false));\n    addTranslationsToJson(ig, \"description\", publishedIg.getDescriptionElement(), true);\n\n    if (context.getTxClientManager() != null && context.getTxClientManager().getMaster() != null) {\n      ig.add(\"tx-server\", context.getTxClientManager().getMaster().getAddress());\n    }\n    ig.add(\"copyright\", publishedIg.getCopyright());\n    addTranslationsToJson(ig, \"copyright\", publishedIg.getCopyrightElement(), true);\n\n    for (Enumeration<FHIRVersion> v : publishedIg.getFhirVersion()) {\n      ig.add(\"fhirVersion\", v.asStringValue());\n      break;\n    }\n\n    for (SpecMapManager sm : specMaps) {\n      if (sm.getName() != null) {\n        data.set(sm.getName(), appendTrailingSlashInDataFile ? sm.getBase() : Utilities.appendForwardSlash(sm.getBase()));\n        if (!data.has(\"ver\")) {\n          data.add(\"ver\", new JsonObject());\n        }\n        data.getJsonObject(\"ver\").set(sm.getName(), appendTrailingSlashInDataFile ? sm.getBase2() : Utilities.appendForwardSlash(sm.getBase2()));\n      }\n    }\n    String json = org.hl7.fhir.utilities.json.parser.JsonParser.compose(data, true);\n    TextFile.stringToFile(json, Utilities.path(tempDir, \"_data\", \"fhir.json\"));\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "Publisher.java",
        "method_name": "generateDataFile",
        "raw_code": "private void generateDataFile(DBBuilder db) throws IOException, FHIRException, SQLException {\n    JsonObject data = new JsonObject();\n    data.add(\"path\", checkAppendSlash(specPath));\n    data.add(\"canonical\", igpkp.getCanonical());\n    data.add(\"igId\", publishedIg.getId());\n    data.add(\"igName\", publishedIg.getName());\n    data.add(\"packageId\", npmName);\n    data.add(\"igVer\", workingVersion());\n    data.add(\"errorCount\", getErrorCount());\n    data.add(\"version\", version);\n    \n    StringType rl = findReleaseLabel();  \n    if (rl == null) {\n      data.add(\"releaseLabel\", \"n/a\");\n      for (String l : allLangs()) {\n        data.add(\"releaseLabel\"+l, rcLangs.get(l).formatPhrase(RenderingI18nContext._NA));\n      }\n    } else { \n      data.add(\"releaseLabel\", rl.getValue());\n      addTranslationsToJson(data, \"releaseLabel\", rl, false);\n    }\n    data.add(\"revision\", specMaps.get(0).getBuild());\n    data.add(\"versionFull\", version+\"-\"+specMaps.get(0).getBuild());\n    data.add(\"toolingVersion\", Constants.VERSION);\n    data.add(\"toolingRevision\", ToolsVersion.TOOLS_VERSION_STR);\n    data.add(\"toolingVersionFull\", Constants.VERSION+\" (\"+ToolsVersion.TOOLS_VERSION_STR+\")\");\n\n    data.add(\"genDate\", genTime());\n    data.add(\"genDay\", genDate());\n    if (db != null) {\n      for (JsonProperty p : data.getProperties()) {\n        db.metadata(p.getName(), p.getValue().asString());\n      }\n      db.metadata(\"gitstatus\", getGitStatus());\n    }\n\n    data.add(\"totalFiles\", fileList.size());\n    data.add(\"processedFiles\", changeList.size());\n\n    if (repoSource != null) {\n      data.add(\"repoSource\", gh());\n    } else {\n      String git= getGitSource();\n      if (git != null) {\n        data.add(\"repoSource\", git);\n      }\n    }\n\n    JsonArray rt = data.forceArray(\"resourceTypes\");\n    List<String> rtl = context.getResourceNames();\n    for (String s : rtl) {\n      rt.add(s);\n    }\n    rt = data.forceArray(\"dataTypes\");\n    ContextUtilities cu = new ContextUtilities(context);\n    for (String s : cu.getTypeNames()) {\n      if (!rtl.contains(s)) {\n        rt.add(s);\n      }\n    }\n\n    JsonObject ig = new JsonObject();\n    data.add(\"ig\", ig);\n    ig.add(\"id\", publishedIg.getId());\n    ig.add(\"name\", publishedIg.getName());\n    ig.add(\"title\", publishedIg.getTitle());\n    addTranslationsToJson(ig, \"title\", publishedIg.getTitleElement(), false);\n    ig.add(\"url\", publishedIg.getUrl());\n    ig.add(\"version\", workingVersion());\n    ig.add(\"status\", publishedIg.getStatusElement().asStringValue());\n    ig.add(\"experimental\", publishedIg.getExperimental());\n    ig.add(\"publisher\", publishedIg.getPublisher());    \n    addTranslationsToJson(ig, \"publisher\", publishedIg.getPublisherElement(), false);\n\n    if (previousVersionComparator != null && previousVersionComparator.hasLast() && !targetUrl().startsWith(\"file:\")) {\n      JsonObject diff = new JsonObject();\n      data.add(\"diff\", diff);\n      diff.add(\"name\", Utilities.encodeUri(previousVersionComparator.getLastName()));\n      diff.add(\"current\", Utilities.encodeUri(targetUrl()));\n      diff.add(\"previous\", Utilities.encodeUri(previousVersionComparator.getLastUrl()));\n    }    \n    if (ipaComparator != null && ipaComparator.hasLast() && !targetUrl().startsWith(\"file:\")) {\n      JsonObject diff = new JsonObject();\n      data.add(\"iga-diff\", diff);\n      diff.add(\"name\", Utilities.encodeUri(ipaComparator.getLastName()));\n      diff.add(\"current\", Utilities.encodeUri(targetUrl()));\n      diff.add(\"previous\", Utilities.encodeUri(ipaComparator.getLastUrl()));\n    }\n    if (ipsComparator != null && ipsComparator.hasLast() && !targetUrl().startsWith(\"file:\")) {\n      JsonObject diff = new JsonObject();\n      data.add(\"iga-diff\", diff);\n      diff.add(\"name\", Utilities.encodeUri(ipsComparator.getLastName()));\n      diff.add(\"current\", Utilities.encodeUri(targetUrl()));\n      diff.add(\"previous\", Utilities.encodeUri(ipsComparator.getLastUrl()));\n    }\n\n    if (publishedIg.hasContact()) {\n      JsonArray jc = new JsonArray();\n      ig.add(\"contact\", jc);\n      for (ContactDetail c : publishedIg.getContact()) {\n        JsonObject jco = new JsonObject();\n        jc.add(jco);\n        jco.add(\"name\", c.getName());\n        if (c.hasTelecom()) {\n          JsonArray jct = new JsonArray();\n          jco.add(\"telecom\", jct);\n          for (ContactPoint cc : c.getTelecom()) {\n            jct.add(new JsonString(cc.getValue()));\n          }\n        }\n      }\n      for (String l : allLangs()) {\n        jc = new JsonArray();\n        ig.add(\"contact\"+l, jc);\n        for (ContactDetail c : publishedIg.getContact()) {\n          JsonObject jco = new JsonObject();\n          jc.add(jco);\n          jco.add(\"name\", langUtils.getTranslationOrBase(c.getNameElement(), l));\n          if (c.hasTelecom()) {\n            JsonArray jct = new JsonArray();\n            jco.add(\"telecom\", jct);\n            for (ContactPoint cc : c.getTelecom()) {\n              jct.add(new JsonString(cc.getValue()));\n            }\n          }\n        }\n        \n      }\n    }\n    ig.add(\"date\", publishedIg.getDateElement().asStringValue());\n    ig.add(\"description\", ProfileUtilities.processRelativeUrls(publishedIg.getDescription(), \"\", igpkp.specPath(), context.getResourceNames(), specMaps.get(0).listTargets(), pageTargets(), false));\n    addTranslationsToJson(ig, \"description\", publishedIg.getDescriptionElement(), true);\n\n    if (context.getTxClientManager() != null && context.getTxClientManager().getMaster() != null) {\n      ig.add(\"tx-server\", context.getTxClientManager().getMaster().getAddress());\n    }\n    ig.add(\"copyright\", publishedIg.getCopyright());\n    addTranslationsToJson(ig, \"copyright\", publishedIg.getCopyrightElement(), true);\n\n    for (Enumeration<FHIRVersion> v : publishedIg.getFhirVersion()) {\n      ig.add(\"fhirVersion\", v.asStringValue());\n      break;\n    }\n\n    for (SpecMapManager sm : specMaps) {\n      if (sm.getName() != null) {\n        data.set(sm.getName(), appendTrailingSlashInDataFile ? sm.getBase() : Utilities.appendForwardSlash(sm.getBase()));\n        if (!data.has(\"ver\")) {\n          data.add(\"ver\", new JsonObject());\n        }\n        data.getJsonObject(\"ver\").set(sm.getName(), appendTrailingSlashInDataFile ? sm.getBase2() : Utilities.appendForwardSlash(sm.getBase2()));\n      }\n    }\n    String json = org.hl7.fhir.utilities.json.parser.JsonParser.compose(data, true);\n    TextFile.stringToFile(json, Utilities.path(tempDir, \"_data\", \"fhir.json\"));\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "snowflake-jdbc",
    "cve_id": "CVE-2025-24790",
    "cwe_list": [
      "CWE-276"
    ],
    "commit_hash": "9e1a5acf12406b16c4780ca013f4c4db48b74b59",
    "short_hash": "9e1a5acf",
    "vulnerableMethods_before": [
      {
        "filename": "SFConnectionConfigParserTest.java",
        "method_name": "createFilePathWithPermission",
        "raw_code": "private Path createFilePathWithPermission(Path path, boolean onlyUserPermission)\n      throws IOException {\n    if (Constants.getOS() != Constants.OS.WINDOWS) {\n      FileAttribute<Set<PosixFilePermission>> fileAttribute =\n          onlyUserPermission\n              ? PosixFilePermissions.asFileAttribute(PosixFilePermissions.fromString(\"rw-------\"))\n              : PosixFilePermissions.asFileAttribute(PosixFilePermissions.fromString(\"rwxrw----\"));\n      return Files.createFile(path, fileAttribute);\n    } else {\n      return Files.createFile(path);\n    }\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SFConnectionConfigParserTest.java",
        "method_name": "createFilePathWithPermission",
        "raw_code": "private Path createFilePathWithPermission(Path path, boolean onlyUserPermission)\n      throws IOException {\n    if (!isWindows()) {\n      FileAttribute<Set<PosixFilePermission>> fileAttribute =\n          onlyUserPermission\n              ? PosixFilePermissions.asFileAttribute(PosixFilePermissions.fromString(\"rw-------\"))\n              : PosixFilePermissions.asFileAttribute(PosixFilePermissions.fromString(\"rwxrw----\"));\n      return Files.createFile(path, fileAttribute);\n    } else {\n      return Files.createFile(path);\n    }\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "snowflake-jdbc",
    "cve_id": "CVE-2025-24790",
    "cwe_list": [
      "CWE-276"
    ],
    "commit_hash": "9e1a5acf12406b16c4780ca013f4c4db48b74b59",
    "short_hash": "9e1a5acf",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultSFConnectionHandler.java",
        "method_name": "checkLogFolderPermissions",
        "raw_code": "private void checkLogFolderPermissions(Path path) throws SnowflakeSQLLoggedException {\n    if (Constants.getOS() != Constants.OS.WINDOWS) {\n      try {\n        Set<PosixFilePermission> folderPermissions = Files.getPosixFilePermissions(path);\n        if (folderPermissions.contains(PosixFilePermission.GROUP_WRITE)\n            || folderPermissions.contains(PosixFilePermission.GROUP_READ)\n            || folderPermissions.contains(PosixFilePermission.GROUP_EXECUTE)\n            || folderPermissions.contains(PosixFilePermission.OTHERS_WRITE)\n            || folderPermissions.contains(PosixFilePermission.OTHERS_READ)\n            || folderPermissions.contains(PosixFilePermission.OTHERS_EXECUTE)) {\n          logger.warn(\n              \"Access permission for the logs directory '{}' is currently {} and is potentially \"\n                  + \"accessible to users other than the owner of the logs directory.\",\n              path.toString(),\n              folderPermissions.toString());\n        }\n      } catch (IOException ex) {\n        throw new SnowflakeSQLLoggedException(\n            sfSession,\n            ErrorCode.INTERNAL_ERROR,\n            String.format(\n                \"Unable to get permissions of log directory %s ,%s\",\n                path.toString(), ex.getMessage(), ex.getCause()));\n      }\n    }\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultSFConnectionHandler.java",
        "method_name": "checkLogFolderPermissions",
        "raw_code": "private void checkLogFolderPermissions(Path path) throws SnowflakeSQLLoggedException {\n    if (!isWindows()) {\n      try {\n        Set<PosixFilePermission> folderPermissions = Files.getPosixFilePermissions(path);\n        if (folderPermissions.contains(PosixFilePermission.GROUP_WRITE)\n            || folderPermissions.contains(PosixFilePermission.GROUP_READ)\n            || folderPermissions.contains(PosixFilePermission.GROUP_EXECUTE)\n            || folderPermissions.contains(PosixFilePermission.OTHERS_WRITE)\n            || folderPermissions.contains(PosixFilePermission.OTHERS_READ)\n            || folderPermissions.contains(PosixFilePermission.OTHERS_EXECUTE)) {\n          logger.warn(\n              \"Access permission for the logs directory '{}' is currently {} and is potentially \"\n                  + \"accessible to users other than the owner of the logs directory.\",\n              path.toString(),\n              folderPermissions.toString());\n        }\n      } catch (IOException ex) {\n        throw new SnowflakeSQLLoggedException(\n            sfSession,\n            ErrorCode.INTERNAL_ERROR,\n            String.format(\n                \"Unable to get permissions of log directory %s ,%s\",\n                path.toString(), ex.getMessage(), ex.getCause()));\n      }\n    }\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "snowflake-jdbc",
    "cve_id": "CVE-2025-24790",
    "cwe_list": [
      "CWE-276"
    ],
    "commit_hash": "9e1a5acf12406b16c4780ca013f4c4db48b74b59",
    "short_hash": "9e1a5acf",
    "vulnerableMethods_before": [
      {
        "filename": "FileCacheManager.java",
        "method_name": "overrideCacheFile",
        "raw_code": "void overrideCacheFile(File newCacheFile) {\n    this.cacheFile = newCacheFile;\n    this.cacheDir = newCacheFile.getParentFile();\n    this.baseCacheFileName = newCacheFile.getName();\n    FileUtil.logFileUsage(cacheFile, \"Override cache file\", true);\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FileCacheManager.java",
        "method_name": "overrideCacheFile",
        "raw_code": "void overrideCacheFile(File newCacheFile) {\n    if (!newCacheFile.exists()) {\n      logger.debug(\"Cache file doesn't exists. File: {}\", newCacheFile);\n    }\n    if (onlyOwnerPermissions) {\n      FileUtil.throwWhenPermiossionDifferentThanReadWriteForOwner(\n          newCacheFile, \"Override cache file\");\n    } else {\n      FileUtil.logFileUsage(cacheFile, \"Override cache file\", false);\n    }\n    this.cacheFile = newCacheFile;\n    this.cacheDir = newCacheFile.getParentFile();\n    this.baseCacheFileName = newCacheFile.getName();\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "snowflake-jdbc",
    "cve_id": "CVE-2025-24790",
    "cwe_list": [
      "CWE-276"
    ],
    "commit_hash": "9e1a5acf12406b16c4780ca013f4c4db48b74b59",
    "short_hash": "9e1a5acf",
    "vulnerableMethods_before": [
      {
        "filename": "FileCacheManager.java",
        "method_name": "build",
        "raw_code": "FileCacheManager build() {\n    // try to get cacheDir from system property or environment variable\n    String cacheDirPath =\n        this.cacheDirectorySystemProperty != null\n            ? systemGetProperty(this.cacheDirectorySystemProperty)\n            : null;\n    if (cacheDirPath == null) {\n      try {\n        cacheDirPath =\n            this.cacheDirectoryEnvironmentVariable != null\n                ? systemGetEnv(this.cacheDirectoryEnvironmentVariable)\n                : null;\n      } catch (Throwable ex) {\n        logger.debug(\n            \"Cannot get environment variable for cache directory, skip using cache\", false);\n        // In Boomi cloud, System.getenv is not allowed due to policy,\n        // so we catch the exception and skip cache completely\n        return this;\n      }\n    }\n\n    if (cacheDirPath != null) {\n      this.cacheDir = new File(cacheDirPath);\n    } else {\n      // use user home directory to store the cache file\n      String homeDir = systemGetProperty(\"user.home\");\n      if (homeDir == null) {\n        // use tmp dir if not exists.\n        homeDir = systemGetProperty(\"java.io.tmpdir\");\n      } else {\n        // Checking if home directory is writable.\n        File homeFile = new File(homeDir);\n        if (!homeFile.canWrite()) {\n          logger.debug(\"Home directory not writeable, using tmpdir\", false);\n          homeDir = systemGetProperty(\"java.io.tmpdir\");\n        }\n      }\n      if (homeDir == null) {\n        // if still home directory is null, no cache dir is set.\n        return this;\n      }\n      if (Constants.getOS() == Constants.OS.WINDOWS) {\n        this.cacheDir =\n            new File(\n                new File(new File(new File(homeDir, \"AppData\"), \"Local\"), \"Snowflake\"), \"Caches\");\n      } else if (Constants.getOS() == Constants.OS.MAC) {\n        this.cacheDir = new File(new File(new File(homeDir, \"Library\"), \"Caches\"), \"Snowflake\");\n      } else {\n        this.cacheDir = new File(new File(homeDir, \".cache\"), \"snowflake\");\n      }\n    }\n\n    if (!this.cacheDir.mkdirs() && !this.cacheDir.exists()) {\n      logger.debug(\n          \"Cannot create the cache directory {}. Giving up.\", this.cacheDir.getAbsolutePath());\n      return this;\n    }\n    logger.debug(\"Verified Directory {}\", this.cacheDir.getAbsolutePath());\n\n    File cacheFileTmp = new File(this.cacheDir, this.baseCacheFileName).getAbsoluteFile();\n    try {\n      // create an empty file if not exists and return true.\n      // If exists. the method returns false.\n      // In this particular case, it doesn't matter as long as the file is\n      // writable.\n      if (cacheFileTmp.createNewFile()) {\n        logger.debug(\"Successfully created a cache file {}\", cacheFileTmp);\n      } else {\n        logger.debug(\"Cache file already exists {}\", cacheFileTmp);\n      }\n      FileUtil.logFileUsage(cacheFileTmp, \"Cache file creation\", false);\n      this.cacheFile = cacheFileTmp.getCanonicalFile();\n      this.cacheLockFile =\n          new File(this.cacheFile.getParentFile(), this.baseCacheFileName + \".lck\");\n    } catch (IOException | SecurityException ex) {\n      logger.debug(\"Failed to touch the cache file. Ignored. {}\", cacheFileTmp.getAbsoluteFile());\n    }\n    return this;\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FileCacheManager.java",
        "method_name": "build",
        "raw_code": "FileCacheManager build() {\n    // try to get cacheDir from system property or environment variable\n    String cacheDirPath =\n        this.cacheDirectorySystemProperty != null\n            ? systemGetProperty(this.cacheDirectorySystemProperty)\n            : null;\n    if (cacheDirPath == null) {\n      try {\n        cacheDirPath =\n            this.cacheDirectoryEnvironmentVariable != null\n                ? systemGetEnv(this.cacheDirectoryEnvironmentVariable)\n                : null;\n      } catch (Throwable ex) {\n        logger.debug(\n            \"Cannot get environment variable for cache directory, skip using cache\", false);\n        // In Boomi cloud, System.getenv is not allowed due to policy,\n        // so we catch the exception and skip cache completely\n        return this;\n      }\n    }\n\n    if (cacheDirPath != null) {\n      this.cacheDir = new File(cacheDirPath);\n    } else {\n      // use user home directory to store the cache file\n      String homeDir = systemGetProperty(\"user.home\");\n      if (homeDir != null) {\n        // Checking if home directory is writable.\n        File homeFile = new File(homeDir);\n        if (!homeFile.canWrite()) {\n          logger.debug(\"Home directory not writeable, skip using cache\", false);\n          homeDir = null;\n        }\n      }\n      if (homeDir == null) {\n        // if still home directory is null, no cache dir is set.\n        return this;\n      }\n      if (Constants.getOS() == Constants.OS.WINDOWS) {\n        this.cacheDir =\n            new File(\n                new File(new File(new File(homeDir, \"AppData\"), \"Local\"), \"Snowflake\"), \"Caches\");\n      } else if (Constants.getOS() == Constants.OS.MAC) {\n        this.cacheDir = new File(new File(new File(homeDir, \"Library\"), \"Caches\"), \"Snowflake\");\n      } else {\n        this.cacheDir = new File(new File(homeDir, \".cache\"), \"snowflake\");\n      }\n    }\n\n    if (!this.cacheDir.mkdirs() && !this.cacheDir.exists()) {\n      logger.debug(\n          \"Cannot create the cache directory {}. Giving up.\", this.cacheDir.getAbsolutePath());\n      return this;\n    }\n    logger.debug(\"Verified Directory {}\", this.cacheDir.getAbsolutePath());\n\n    File cacheFileTmp = new File(this.cacheDir, this.baseCacheFileName).getAbsoluteFile();\n    try {\n      // create an empty file if not exists and return true.\n      // If exists. the method returns false.\n      // In this particular case, it doesn't matter as long as the file is\n      // writable.\n      if (!cacheFileTmp.exists()) {\n        if (!isWindows() && onlyOwnerPermissions) {\n          Files.createFile(\n              cacheFileTmp.toPath(),\n              PosixFilePermissions.asFileAttribute(\n                  Stream.of(PosixFilePermission.OWNER_READ, PosixFilePermission.OWNER_WRITE)\n                      .collect(Collectors.toSet())));\n        } else {\n          Files.createFile(cacheFileTmp.toPath());\n        }\n        logger.debug(\"Successfully created a cache file {}\", cacheFileTmp);\n      } else {\n        logger.debug(\"Cache file already exists {}\", cacheFileTmp);\n      }\n      FileUtil.logFileUsage(cacheFileTmp, \"Cache file creation\", false);\n      this.cacheFile = cacheFileTmp.getCanonicalFile();\n      this.cacheLockFile =\n          new File(this.cacheFile.getParentFile(), this.baseCacheFileName + \".lck\");\n    } catch (IOException | SecurityException ex) {\n      logger.info(\n          \"Failed to touch the cache file: {}. Ignored. {}\",\n          ex.getMessage(),\n          cacheFileTmp.getAbsoluteFile());\n    }\n    return this;\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "snowflake-jdbc",
    "cve_id": "CVE-2025-24790",
    "cwe_list": [
      "CWE-276"
    ],
    "commit_hash": "9e1a5acf12406b16c4780ca013f4c4db48b74b59",
    "short_hash": "9e1a5acf",
    "vulnerableMethods_before": [
      {
        "filename": "FileCacheManager.java",
        "method_name": "readCacheFile",
        "raw_code": "JsonNode readCacheFile() {\n    if (cacheFile == null || !this.checkCacheLockFile()) {\n      // no cache or the cache is not valid.\n      return null;\n    }\n    try {\n      if (!cacheFile.exists()) {\n        logger.debug(\"Cache file doesn't exists. File: {}\", cacheFile);\n        return null;\n      }\n\n      try (Reader reader =\n          new InputStreamReader(new FileInputStream(cacheFile), DEFAULT_FILE_ENCODING)) {\n        FileUtil.logFileUsage(cacheFile, \"Read cache\", false);\n        return OBJECT_MAPPER.readTree(reader);\n      }\n    } catch (IOException ex) {\n      logger.debug(\"Failed to read the cache file. No worry. File: {}, Err: {}\", cacheFile, ex);\n    }\n    return null;\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FileCacheManager.java",
        "method_name": "readCacheFile",
        "raw_code": "JsonNode readCacheFile() {\n    if (cacheFile == null || !this.checkCacheLockFile()) {\n      // no cache or the cache is not valid.\n      return null;\n    }\n    try {\n      if (!cacheFile.exists()) {\n        logger.debug(\"Cache file doesn't exists. File: {}\", cacheFile);\n        return null;\n      }\n\n      try (Reader reader =\n          new InputStreamReader(new FileInputStream(cacheFile), DEFAULT_FILE_ENCODING)) {\n\n        if (onlyOwnerPermissions) {\n          FileUtil.throwWhenPermiossionDifferentThanReadWriteForOwner(cacheFile, \"Read cache\");\n          FileUtil.throwWhenOwnerDifferentThanCurrentUser(cacheFile, \"Read cache\");\n        } else {\n          FileUtil.logFileUsage(cacheFile, \"Read cache\", false);\n        }\n        return OBJECT_MAPPER.readTree(reader);\n      }\n    } catch (IOException ex) {\n      logger.debug(\"Failed to read the cache file. No worry. File: {}, Err: {}\", cacheFile, ex);\n    }\n    return null;\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "snowflake-jdbc",
    "cve_id": "CVE-2025-24790",
    "cwe_list": [
      "CWE-276"
    ],
    "commit_hash": "9e1a5acf12406b16c4780ca013f4c4db48b74b59",
    "short_hash": "9e1a5acf",
    "vulnerableMethods_before": [
      {
        "filename": "FileCacheManager.java",
        "method_name": "writeCacheFile",
        "raw_code": "void writeCacheFile(JsonNode input) {\n    logger.debug(\"Writing cache file. File: {}\", cacheFile);\n    if (cacheFile == null || !tryLockCacheFile()) {\n      // no cache file or it failed to lock file\n      logger.debug(\n          \"No cache file exists or failed to lock the file. Skipping writing the cache\", false);\n      return;\n    }\n    // NOTE: must unlock cache file\n    try {\n      if (input == null) {\n        return;\n      }\n      try (Writer writer =\n          new OutputStreamWriter(new FileOutputStream(cacheFile), DEFAULT_FILE_ENCODING)) {\n        FileUtil.logFileUsage(cacheFile, \"Write to cache\", false);\n        writer.write(input.toString());\n      }\n    } catch (IOException ex) {\n      logger.debug(\"Failed to write the cache file. File: {}\", cacheFile);\n    } finally {\n      if (!unlockCacheFile()) {\n        logger.debug(\"Failed to unlock cache file\", false);\n      }\n    }\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FileCacheManager.java",
        "method_name": "writeCacheFile",
        "raw_code": "void writeCacheFile(JsonNode input) {\n    logger.debug(\"Writing cache file. File: {}\", cacheFile);\n    if (cacheFile == null || !tryLockCacheFile()) {\n      // no cache file or it failed to lock file\n      logger.debug(\n          \"No cache file exists or failed to lock the file. Skipping writing the cache\", false);\n      return;\n    }\n    // NOTE: must unlock cache file\n    try {\n      if (input == null) {\n        return;\n      }\n      try (Writer writer =\n          new OutputStreamWriter(new FileOutputStream(cacheFile), DEFAULT_FILE_ENCODING)) {\n        if (onlyOwnerPermissions) {\n          FileUtil.throwWhenPermiossionDifferentThanReadWriteForOwner(cacheFile, \"Write to cache\");\n        } else {\n          FileUtil.logFileUsage(cacheFile, \"Write to cache\", false);\n        }\n        writer.write(input.toString());\n      }\n    } catch (IOException ex) {\n      logger.debug(\"Failed to write the cache file. File: {}\", cacheFile);\n    } finally {\n      if (!unlockCacheFile()) {\n        logger.debug(\"Failed to unlock cache file\", false);\n      }\n    }\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "snowflake-jdbc",
    "cve_id": "CVE-2025-24790",
    "cwe_list": [
      "CWE-276"
    ],
    "commit_hash": "9e1a5acf12406b16c4780ca013f4c4db48b74b59",
    "short_hash": "9e1a5acf",
    "vulnerableMethods_before": [
      {
        "filename": "SFConnectionConfigParser.java",
        "method_name": "verifyFilePermissionSecure",
        "raw_code": "private static void verifyFilePermissionSecure(Path configFilePath)\n      throws IOException, SnowflakeSQLException {\n    if (Constants.getOS() != Constants.OS.WINDOWS) {\n      PosixFileAttributeView posixFileAttributeView =\n          Files.getFileAttributeView(configFilePath, PosixFileAttributeView.class);\n      if (!posixFileAttributeView.readAttributes().permissions().stream()\n          .allMatch(\n              o ->\n                  Arrays.asList(PosixFilePermission.OWNER_WRITE, PosixFilePermission.OWNER_READ)\n                      .contains(o))) {\n        logger.error(\n            \"Reading from file %s is not safe because file permissions are different than read/write for user\",\n            configFilePath);\n        throw new SnowflakeSQLException(\n            String.format(\n                \"Reading from file %s is not safe because file permissions are different than read/write for user\",\n                configFilePath));\n      }\n    }\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SFConnectionConfigParser.java",
        "method_name": "verifyFilePermissionSecure",
        "raw_code": "private static void verifyFilePermissionSecure(Path configFilePath)\n      throws IOException, SnowflakeSQLException {\n    if (!isWindows()) {\n      PosixFileAttributeView posixFileAttributeView =\n          Files.getFileAttributeView(configFilePath, PosixFileAttributeView.class);\n      if (!posixFileAttributeView.readAttributes().permissions().stream()\n          .allMatch(\n              o ->\n                  Arrays.asList(PosixFilePermission.OWNER_WRITE, PosixFilePermission.OWNER_READ)\n                      .contains(o))) {\n        logger.error(\n            \"Reading from file %s is not safe because file permissions are different than read/write for user\",\n            configFilePath);\n        throw new SnowflakeSQLException(\n            String.format(\n                \"Reading from file %s is not safe because file permissions are different than read/write for user\",\n                configFilePath));\n      }\n    }\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "snowflake-jdbc",
    "cve_id": "CVE-2025-24790",
    "cwe_list": [
      "CWE-276"
    ],
    "commit_hash": "9e1a5acf12406b16c4780ca013f4c4db48b74b59",
    "short_hash": "9e1a5acf",
    "vulnerableMethods_before": [
      {
        "filename": "FileUtil.java",
        "method_name": "logFileUsage",
        "raw_code": "public static void logFileUsage(Path filePath, String context, boolean logReadAccess) {\n    logger.info(\"{}Accessing file: {}\", getContextStr(context), filePath);\n    logWarnWhenAccessibleByOthers(filePath, context, logReadAccess);\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FileUtil.java",
        "method_name": "logFileUsage",
        "raw_code": "public static void logFileUsage(Path filePath, String context, boolean logReadAccess) {\n    logWarnWhenAccessibleByOthers(filePath, context, logReadAccess);\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "snowflake-jdbc",
    "cve_id": "CVE-2025-24790",
    "cwe_list": [
      "CWE-276"
    ],
    "commit_hash": "9e1a5acf12406b16c4780ca013f4c4db48b74b59",
    "short_hash": "9e1a5acf",
    "vulnerableMethods_before": [
      {
        "filename": "FileUtil.java",
        "method_name": "logWarnWhenAccessibleByOthers",
        "raw_code": "private static void logWarnWhenAccessibleByOthers(\n      Path filePath, String context, boolean logReadAccess) {\n    // we do not check the permissions for Windows\n    if (Constants.getOS() == Constants.OS.WINDOWS) {\n      return;\n    }\n\n    try {\n      Collection<PosixFilePermission> filePermissions = Files.getPosixFilePermissions(filePath);\n      logger.debug(\n          \"{}File {} access rights: {}\", getContextStr(context), filePath, filePermissions);\n\n      boolean isWritableByOthers = isPermPresent(filePermissions, WRITE_BY_OTHERS);\n      boolean isReadableByOthers = isPermPresent(filePermissions, READ_BY_OTHERS);\n\n      if (isWritableByOthers || (isReadableByOthers && logReadAccess)) {\n        logger.warn(\n            \"{}File {} is accessible by others to:{}{}\",\n            getContextStr(context),\n            filePath,\n            isReadableByOthers && logReadAccess ? \" read\" : \"\",\n            isWritableByOthers ? \" write\" : \"\");\n      }\n    } catch (IOException e) {\n      logger.warn(\n          \"{}Unable to access the file to check the permissions: {}. Error: {}\",\n          getContextStr(context),\n          filePath,\n          e);\n    }\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FileUtil.java",
        "method_name": "logWarnWhenAccessibleByOthers",
        "raw_code": "private static void logWarnWhenAccessibleByOthers(\n      Path filePath, String context, boolean logReadAccess) {\n    // we do not check the permissions for Windows\n    if (isWindows()) {\n      return;\n    }\n\n    try {\n      Collection<PosixFilePermission> filePermissions = Files.getPosixFilePermissions(filePath);\n      logger.debug(\n          \"{}File {} access rights: {}\", getContextStr(context), filePath, filePermissions);\n\n      boolean isWritableByOthers = isPermPresent(filePermissions, WRITE_BY_OTHERS);\n      boolean isReadableByOthers = isPermPresent(filePermissions, READ_BY_OTHERS);\n      boolean isExecutable = isPermPresent(filePermissions, EXECUTABLE);\n\n      if (isWritableByOthers || (isReadableByOthers || isExecutable)) {\n        logger.warn(\n            \"{}File {} is accessible by others to:{}{}\",\n            getContextStr(context),\n            filePath,\n            isReadableByOthers && logReadAccess ? \" read\" : \"\",\n            isWritableByOthers ? \" write\" : \"\",\n            isExecutable ? \" executable\" : \"\");\n      }\n    } catch (IOException e) {\n      logger.warn(\n          \"{}Unable to access the file to check the permissions: {}. Error: {}\",\n          getContextStr(context),\n          filePath,\n          e);\n    }\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "snowflake-jdbc",
    "cve_id": "CVE-2025-24789",
    "cwe_list": [
      "CWE-426"
    ],
    "commit_hash": "4f01bb8f9b708c71e7a2111c87371dbfc1d53dd6",
    "short_hash": "4f01bb8f",
    "vulnerableMethods_before": [
      {
        "filename": "SessionUtilExternalBrowser.java",
        "method_name": "openBrowser",
        "raw_code": "void openBrowser(String ssoUrl) throws SFException;",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SessionUtilExternalBrowser.java",
        "method_name": "openBrowser",
        "raw_code": "@Override\n    public void openBrowser(String ssoUrl) throws SFException {\n      if (!URLUtil.isValidURL(ssoUrl)) {\n        throw new SFException(ErrorCode.INVALID_CONNECTION_URL, \"Invalid SSOUrl found - \" + ssoUrl);\n      }\n      try {\n        // start web browser\n        Runtime runtime = Runtime.getRuntime();\n        Constants.OS os = Constants.getOS();\n        if (Desktop.isDesktopSupported()\n            && Desktop.getDesktop().isSupported(Desktop.Action.BROWSE)) {\n          Desktop.getDesktop().browse(new URI(ssoUrl));\n        } else if (os == Constants.OS.MAC) {\n          runtime.exec(\"open \" + ssoUrl);\n        } else if (os == Constants.OS.WINDOWS) {\n          runtime.exec(new String[] {\"rundll32\", \"url.dll,FileProtocolHandler\", ssoUrl});\n        } else {\n          runtime.exec(\"xdg-open \" + ssoUrl);\n        }\n      } catch (URISyntaxException | IOException ex) {\n        throw new SFException(ex, ErrorCode.NETWORK_ERROR, ex.getMessage());\n      }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49580",
    "cwe_list": [
      "CWE-266"
    ],
    "commit_hash": "ab209acd780da69a4c5ff77ff011efd698273cec",
    "short_hash": "ab209acd",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultReferenceUpdater.java",
        "method_name": "renameLinks",
        "raw_code": "private void renameLinks(XWikiDocument document, EntityReference oldTarget, EntityReference newTarget,\n        XWikiContext xcontext, boolean relative, RenameLambda renameLambda) throws XWikiException\n    {\n        DocumentReference currentDocumentReference = document.getDocumentReference();\n\n        ComponentManager componentManager = this.contextComponentManagerProvider.get();\n\n        // We support only the syntaxes for which there is an available renderer.\n        if (!componentManager.hasComponent(BlockRenderer.class, document.getSyntax().toIdString())) {\n            this.logger.warn(\n                \"We can't rename the links from [{}] because there is no renderer available for its syntax [{}].\",\n                currentDocumentReference, document.getSyntax());\n\n            return;\n        }\n\n        // Load the renderer\n        BlockRenderer renderer;\n        try {\n            renderer = componentManager.getInstance(BlockRenderer.class, document.getSyntax().toIdString());\n        } catch (ComponentLookupException e) {\n            this.logger.error(\n                \"We can't rename the links from [{}] because the renderer for syntax [{}] cannot be loaded.\",\n                currentDocumentReference, document.getSyntax(), e);\n\n            return;\n        }\n\n        // Document content\n        boolean modified = renameLinks(document, relative, renameLambda);\n\n        // XObjects properties\n        for (List<BaseObject> xobjects : document.getXObjects().values()) {\n            for (BaseObject xobject : xobjects) {\n                if (xobject != null) {\n                    modified |= renameLinks(xobject, document, renderer, xcontext, relative, renameLambda);\n                }\n            }\n        }\n\n        if (modified) {\n            if (relative) {\n                saveDocumentPreservingContentAuthor(document, \"Updated the relative links.\", true);\n\n                info(\"Updated the relative links from [{}].\", currentDocumentReference);\n            } else {\n                saveDocumentPreservingContentAuthor(document, \"Renamed back-links.\", false);\n\n                info(\"The links from [{}] that were targeting [{}] have been updated to target [{}].\",\n                    document.getDocumentReferenceWithLocale(), oldTarget, newTarget);\n            }\n        } else {\n            if (relative) {\n                info(\"No relative links to update in [{}].\", currentDocumentReference);\n            } else {\n                info(\"No back-links to update in [{}].\", currentDocumentReference);\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultReferenceUpdater.java",
        "method_name": "renameLinks",
        "raw_code": "private void renameLinks(XWikiDocument document, EntityReference oldTarget, EntityReference newTarget,\n        XWikiContext xcontext, boolean relative, RenameLambda renameLambda) throws XWikiException\n    {\n        DocumentReference currentDocumentReference = document.getDocumentReference();\n\n        ComponentManager componentManager = this.contextComponentManagerProvider.get();\n\n        // We support only the syntaxes for which there is an available renderer.\n        if (!componentManager.hasComponent(BlockRenderer.class, document.getSyntax().toIdString())) {\n            this.logger.warn(\n                \"We can't rename the links from [{}] because there is no renderer available for its syntax [{}].\",\n                currentDocumentReference, document.getSyntax());\n\n            return;\n        }\n\n        // Load the renderer\n        BlockRenderer renderer;\n        try {\n            renderer = componentManager.getInstance(BlockRenderer.class, document.getSyntax().toIdString());\n        } catch (ComponentLookupException e) {\n            this.logger.error(\n                \"We can't rename the links from [{}] because the renderer for syntax [{}] cannot be loaded.\",\n                currentDocumentReference, document.getSyntax(), e);\n\n            return;\n        }\n\n        // Document content\n        boolean modified = renameLinks(document, relative, renameLambda);\n\n        // XObjects properties\n        for (List<BaseObject> xobjects : document.getXObjects().values()) {\n            for (BaseObject xobject : xobjects) {\n                if (xobject != null) {\n                    modified |= renameLinks(xobject, document, renderer, xcontext, relative, renameLambda);\n                }\n            }\n        }\n\n        if (modified) {\n            if (relative) {\n                saveDocumentPreservingAuthors(document, \"refactoring.referenceUpdater.saveMessage.relativeLink\");\n\n                info(\"Updated the relative links from [{}].\", currentDocumentReference);\n            } else {\n                saveDocumentPreservingAuthors(document, \"refactoring.referenceUpdater.saveMessage.backlinks\");\n\n                info(\"The links from [{}] that were targeting [{}] have been updated to target [{}].\",\n                    document.getDocumentReferenceWithLocale(), oldTarget, newTarget);\n            }\n        } else {\n            if (relative) {\n                info(\"No relative links to update in [{}].\", currentDocumentReference);\n            } else {\n                info(\"No back-links to update in [{}].\", currentDocumentReference);\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49580",
    "cwe_list": [
      "CWE-266"
    ],
    "commit_hash": "ab209acd780da69a4c5ff77ff011efd698273cec",
    "short_hash": "ab209acd",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "beforeEach",
        "raw_code": "@BeforeEach\n    void beforeEach() throws Exception\n    {\n        XWiki xwiki = mock(XWiki.class);\n        when(this.xcontext.getWiki()).thenReturn(xwiki);\n        when(xwiki.exists(any(DocumentReference.class), eq(this.xcontext))).thenReturn(true);\n\n        when(this.xcontextProvider.get()).thenReturn(this.xcontext);\n        when(this.componentManagerProvider.get()).thenReturn(this.componentManager);\n\n        when(this.jobContext.getCurrentJob()).thenReturn(this.job);\n        when(this.job.getRequest()).thenReturn(jobrequest);\n        when(this.jobrequest.isVerbose()).thenReturn(true);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "beforeEach",
        "raw_code": "@BeforeEach\n    void beforeEach() throws Exception\n    {\n        XWiki xwiki = mock(XWiki.class);\n        when(this.xcontext.getWiki()).thenReturn(xwiki);\n        when(xwiki.exists(any(DocumentReference.class), eq(this.xcontext))).thenReturn(true);\n\n        when(this.xcontextProvider.get()).thenReturn(this.xcontext);\n        when(this.componentManagerProvider.get()).thenReturn(this.componentManager);\n\n        when(this.jobContext.getCurrentJob()).thenReturn(this.job);\n        when(this.job.getRequest()).thenReturn(jobrequest);\n        when(this.jobrequest.isVerbose()).thenReturn(true);\n        when(this.localizationManager.getDefaultLocale()).thenReturn(Locale.FRENCH);\n        when(this.localizationManager.getTranslationPlain(SAVE_COMMENT_RELATIVE_LINK_KEY, Locale.FRENCH))\n            .thenReturn(TRANSLATED_RELATIVE_COMMENT);\n        when(this.localizationManager.getTranslationPlain(SAVE_COMMENT_BACKLINK_KEY, Locale.FRENCH))\n            .thenReturn(TRANSLATED_BACKLINK_COMMENT);\n        when(this.userReferenceResolver.resolve(CurrentUserReference.INSTANCE)).thenReturn(currentUserReference);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49580",
    "cwe_list": [
      "CWE-266"
    ],
    "commit_hash": "ab209acd780da69a4c5ff77ff011efd698273cec",
    "short_hash": "ab209acd",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "updateRelativeLinks",
        "raw_code": "@Test\n    void updateRelativeLinks() throws Exception\n    {\n        DocumentReference oldReference = new DocumentReference(\"wiki\", \"A\", \"B\");\n        AttachmentReference oldImageTargetAttachment = new AttachmentReference(\"attachment.txt\", oldReference);\n        DocumentReference newReference = new DocumentReference(\"wiki\", \"X\", \"Y\");\n        AttachmentReference newImageTargetAttachment = new AttachmentReference(\"attachment.txt\", newReference);\n        AttachmentReference absoluteTargetAttachment = new AttachmentReference(\"attachment.txt\",\n            new DocumentReference(\"wiki\", \"Main\", \"WebHome\"));\n\n        XWikiDocument newDocument = mock(XWikiDocument.class);\n        when(this.xcontext.getWiki().getDocument(newReference, this.xcontext)).thenReturn(newDocument);\n        when(newDocument.getDocumentReference()).thenReturn(newReference);\n        when(newDocument.getSyntax()).thenReturn(Syntax.XWIKI_2_1);\n\n        // Setup document content\n        ResourceReference docLinkReference = new ResourceReference(\"C\", ResourceType.DOCUMENT);\n        LinkBlock docLinkBlock = new LinkBlock(List.of(), docLinkReference, false);\n        ResourceReference spaceLinkReference = new ResourceReference(\"Z\", ResourceType.SPACE);\n        LinkBlock spaceLinkBlock = new LinkBlock(List.of(), spaceLinkReference, false);\n        ResourceReference imageReference = new AttachmentResourceReference(\"attachment.txt\");\n        ImageBlock imageBlock = new ImageBlock(imageReference, false);\n        ResourceReference absoluteDocLinkResourceReference = new ResourceReference(\"xwiki:C.WebHome\",\n            ResourceType.DOCUMENT);\n        LinkBlock absoluteDocLinkBlock =\n            new LinkBlock(List.of(), absoluteDocLinkResourceReference, false);\n        when(newDocument.getXDOM())\n            .thenReturn(new XDOM(List.of(docLinkBlock, spaceLinkBlock, imageBlock, absoluteDocLinkBlock)));\n\n        // Setup object content\n        ResourceReference xobjectDocLinkReference = new ResourceReference(\"C\", ResourceType.DOCUMENT);\n        LinkBlock xobjectDocLinkBlock = new LinkBlock(List.of(), xobjectDocLinkReference, false);\n        ResourceReference xobjectSpaceLinkReference = new ResourceReference(\"Z\", ResourceType.SPACE);\n        LinkBlock xobjectSpaceLinkBlock =\n            new LinkBlock(List.of(), xobjectSpaceLinkReference, false);\n        ResourceReference xobjectImageReference = new AttachmentResourceReference(\"attachment.txt\");\n        ImageBlock xobjectImageBlock = new ImageBlock(xobjectImageReference, false);\n        setTextarea(newDocument,\n            new XDOM(List.of(xobjectDocLinkBlock, xobjectSpaceLinkBlock, xobjectImageBlock)));\n\n        DocumentReference originalDocLinkReference = new DocumentReference(\"WebHome\",\n            new SpaceReference(\"C\", oldReference.getLastSpaceReference()));\n        DocumentReference absoluteDocLinkReference = new DocumentReference(\"WebHome\", new SpaceReference(\"wiki\", \"C\"));\n        EntityReference relativeDocLinkReference = new EntityReference(\"WebHome\", EntityType.DOCUMENT,\n            new EntityReference(\"C\", EntityType.SPACE));\n        when(this.resourceReferenceResolver.resolve(docLinkReference, null))\n            .thenReturn(absoluteDocLinkReference);\n        when(this.relativeEntityReferenceResolver.resolve(docLinkReference, null, null))\n            .thenReturn(relativeDocLinkReference);\n        when(this.resourceReferenceResolver.resolve(absoluteDocLinkResourceReference, null))\n            .thenReturn(absoluteDocLinkReference);\n        when(this.relativeEntityReferenceResolver.resolve(absoluteDocLinkResourceReference, null, null))\n            .thenReturn(absoluteDocLinkReference);\n        when(this.resourceReferenceResolver.resolve(docLinkReference, null, oldReference))\n            .thenReturn(originalDocLinkReference);\n        when(this.resourceReferenceResolver.resolve(absoluteDocLinkResourceReference, null, oldReference))\n            .thenReturn(absoluteDocLinkReference);\n        when(this.resourceReferenceResolver.resolve(xobjectDocLinkReference, null))\n            .thenReturn(absoluteDocLinkReference);\n        when(this.relativeEntityReferenceResolver.resolve(xobjectDocLinkReference, null, null))\n            .thenReturn(relativeDocLinkReference);\n        when(this.resourceReferenceResolver.resolve(xobjectDocLinkReference, null, oldReference))\n            .thenReturn(originalDocLinkReference);\n        when(this.resourceReferenceResolver.resolve(imageReference, null))\n            .thenReturn(absoluteTargetAttachment);\n        when(this.resourceReferenceResolver.resolve(imageReference, null, oldReference))\n            .thenReturn(oldImageTargetAttachment);\n        when(this.relativeEntityReferenceResolver.resolve(imageReference, null, null))\n            .thenReturn(relativeDocLinkReference);\n        DocumentReference newDocLinkReference = new DocumentReference(\"WebHome\",\n            new SpaceReference(\"C\", newReference.getLastSpaceReference()));\n        when(this.resourceReferenceResolver.resolve(docLinkReference, null, newReference))\n            .thenReturn(newDocLinkReference);\n        when(this.resourceReferenceResolver.resolve(xobjectDocLinkReference, null, newReference))\n            .thenReturn(newDocLinkReference);\n        when(this.resourceReferenceResolver.resolve(imageReference, null, newReference))\n            .thenReturn(newImageTargetAttachment);\n        when(this.resourceReferenceResolver.resolve(absoluteDocLinkResourceReference, null, newReference))\n            .thenReturn(new DocumentReference(\"WebHome\", new SpaceReference(\"wiki\", \"E\")));\n\n        SpaceReference originalSpaceReference = new SpaceReference(\"wiki\", \"Z\");\n        EntityReference relativeSpaceReference = new EntityReference(\"Z\", EntityType.SPACE);\n        when(this.resourceReferenceResolver.resolve(spaceLinkReference, null))\n            .thenReturn(originalSpaceReference);\n        when(this.relativeEntityReferenceResolver.resolve(spaceLinkReference, null, null))\n            .thenReturn(relativeSpaceReference);\n        when(this.resourceReferenceResolver.resolve(spaceLinkReference, null, oldReference))\n            .thenReturn(originalSpaceReference);\n        when(this.resourceReferenceResolver.resolve(xobjectSpaceLinkReference, null))\n            .thenReturn(originalSpaceReference);\n        when(this.resourceReferenceResolver.resolve(xobjectSpaceLinkReference, null, oldReference))\n            .thenReturn(originalSpaceReference);\n        when(this.resourceReferenceResolver.resolve(spaceLinkReference, null, newReference))\n            .thenReturn(originalSpaceReference);\n        when(this.resourceReferenceResolver.resolve(xobjectSpaceLinkReference, null, newReference))\n            .thenReturn(originalSpaceReference);\n\n        when(this.compactEntityReferenceSerializer.serialize(originalDocLinkReference, newReference)).thenReturn(\"A.C\");\n        when(this.defaultEntityReferenceSerializer.serialize(absoluteDocLinkReference, newReference))\n            .thenReturn(\"wiki:C.WebHome\");\n\n        updater.update(newReference, oldReference, newReference);\n\n        // Document link block is updated.\n        assertEquals(\"A.C\", docLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.DOCUMENT, docLinkBlock.getReference().getType());\n        assertEquals(\"wiki:C.WebHome\", absoluteDocLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.DOCUMENT, absoluteDocLinkBlock.getReference().getType());\n        // Space link block stays the same, since they were on the same wiki.\n        assertEquals(\"Z\", spaceLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.SPACE, spaceLinkBlock.getReference().getType());\n        // Image link relative to the document stay the same\n        assertEquals(\"attachment.txt\", imageBlock.getReference().getReference());\n\n        // XObject Document link block is updated.\n        assertEquals(\"A.C\", xobjectDocLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.DOCUMENT, xobjectDocLinkBlock.getReference().getType());\n        // XObject Space link block stays the same, since they were on the same wiki.\n        assertEquals(\"Z\", xobjectSpaceLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.SPACE, xobjectSpaceLinkBlock.getReference().getType());\n        // Image link relative to the document stay the same\n        assertEquals(\"attachment.txt\", xobjectImageBlock.getReference().getReference());\n\n        verifyDocumentSave(newDocument, \"Updated the relative links.\", true, true);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "updateRelativeLinks",
        "raw_code": "@Test\n    void updateRelativeLinks() throws Exception\n    {\n        DocumentReference oldReference = new DocumentReference(\"wiki\", \"A\", \"B\");\n        AttachmentReference oldImageTargetAttachment = new AttachmentReference(\"attachment.txt\", oldReference);\n        DocumentReference newReference = new DocumentReference(\"wiki\", \"X\", \"Y\");\n        AttachmentReference newImageTargetAttachment = new AttachmentReference(\"attachment.txt\", newReference);\n        AttachmentReference absoluteTargetAttachment = new AttachmentReference(\"attachment.txt\",\n            new DocumentReference(\"wiki\", \"Main\", \"WebHome\"));\n\n        XWikiDocument newDocument = mock(XWikiDocument.class);\n        DocumentAuthors authors = mock(DocumentAuthors.class);\n        when(newDocument.getAuthors()).thenReturn(authors);\n        when(this.xcontext.getWiki().getDocument(newReference, this.xcontext)).thenReturn(newDocument);\n        when(newDocument.getDocumentReference()).thenReturn(newReference);\n        when(newDocument.getSyntax()).thenReturn(Syntax.XWIKI_2_1);\n\n        // Setup document content\n        ResourceReference docLinkReference = new ResourceReference(\"C\", ResourceType.DOCUMENT);\n        LinkBlock docLinkBlock = new LinkBlock(List.of(), docLinkReference, false);\n        ResourceReference spaceLinkReference = new ResourceReference(\"Z\", ResourceType.SPACE);\n        LinkBlock spaceLinkBlock = new LinkBlock(List.of(), spaceLinkReference, false);\n        ResourceReference imageReference = new AttachmentResourceReference(\"attachment.txt\");\n        ImageBlock imageBlock = new ImageBlock(imageReference, false);\n        ResourceReference absoluteDocLinkResourceReference = new ResourceReference(\"xwiki:C.WebHome\",\n            ResourceType.DOCUMENT);\n        LinkBlock absoluteDocLinkBlock =\n            new LinkBlock(List.of(), absoluteDocLinkResourceReference, false);\n        when(newDocument.getXDOM())\n            .thenReturn(new XDOM(List.of(docLinkBlock, spaceLinkBlock, imageBlock, absoluteDocLinkBlock)));\n\n        // Setup object content\n        ResourceReference xobjectDocLinkReference = new ResourceReference(\"C\", ResourceType.DOCUMENT);\n        LinkBlock xobjectDocLinkBlock = new LinkBlock(List.of(), xobjectDocLinkReference, false);\n        ResourceReference xobjectSpaceLinkReference = new ResourceReference(\"Z\", ResourceType.SPACE);\n        LinkBlock xobjectSpaceLinkBlock =\n            new LinkBlock(List.of(), xobjectSpaceLinkReference, false);\n        ResourceReference xobjectImageReference = new AttachmentResourceReference(\"attachment.txt\");\n        ImageBlock xobjectImageBlock = new ImageBlock(xobjectImageReference, false);\n        setTextarea(newDocument,\n            new XDOM(List.of(xobjectDocLinkBlock, xobjectSpaceLinkBlock, xobjectImageBlock)));\n\n        DocumentReference originalDocLinkReference = new DocumentReference(\"WebHome\",\n            new SpaceReference(\"C\", oldReference.getLastSpaceReference()));\n        DocumentReference absoluteDocLinkReference = new DocumentReference(\"WebHome\", new SpaceReference(\"wiki\", \"C\"));\n        EntityReference relativeDocLinkReference = new EntityReference(\"WebHome\", EntityType.DOCUMENT,\n            new EntityReference(\"C\", EntityType.SPACE));\n        when(this.resourceReferenceResolver.resolve(docLinkReference, null))\n            .thenReturn(absoluteDocLinkReference);\n        when(this.relativeEntityReferenceResolver.resolve(docLinkReference, null, null))\n            .thenReturn(relativeDocLinkReference);\n        when(this.resourceReferenceResolver.resolve(absoluteDocLinkResourceReference, null))\n            .thenReturn(absoluteDocLinkReference);\n        when(this.relativeEntityReferenceResolver.resolve(absoluteDocLinkResourceReference, null, null))\n            .thenReturn(absoluteDocLinkReference);\n        when(this.resourceReferenceResolver.resolve(docLinkReference, null, oldReference))\n            .thenReturn(originalDocLinkReference);\n        when(this.resourceReferenceResolver.resolve(absoluteDocLinkResourceReference, null, oldReference))\n            .thenReturn(absoluteDocLinkReference);\n        when(this.resourceReferenceResolver.resolve(xobjectDocLinkReference, null))\n            .thenReturn(absoluteDocLinkReference);\n        when(this.relativeEntityReferenceResolver.resolve(xobjectDocLinkReference, null, null))\n            .thenReturn(relativeDocLinkReference);\n        when(this.resourceReferenceResolver.resolve(xobjectDocLinkReference, null, oldReference))\n            .thenReturn(originalDocLinkReference);\n        when(this.resourceReferenceResolver.resolve(imageReference, null))\n            .thenReturn(absoluteTargetAttachment);\n        when(this.resourceReferenceResolver.resolve(imageReference, null, oldReference))\n            .thenReturn(oldImageTargetAttachment);\n        when(this.relativeEntityReferenceResolver.resolve(imageReference, null, null))\n            .thenReturn(relativeDocLinkReference);\n        DocumentReference newDocLinkReference = new DocumentReference(\"WebHome\",\n            new SpaceReference(\"C\", newReference.getLastSpaceReference()));\n        when(this.resourceReferenceResolver.resolve(docLinkReference, null, newReference))\n            .thenReturn(newDocLinkReference);\n        when(this.resourceReferenceResolver.resolve(xobjectDocLinkReference, null, newReference))\n            .thenReturn(newDocLinkReference);\n        when(this.resourceReferenceResolver.resolve(imageReference, null, newReference))\n            .thenReturn(newImageTargetAttachment);\n        when(this.resourceReferenceResolver.resolve(absoluteDocLinkResourceReference, null, newReference))\n            .thenReturn(new DocumentReference(\"WebHome\", new SpaceReference(\"wiki\", \"E\")));\n\n        SpaceReference originalSpaceReference = new SpaceReference(\"wiki\", \"Z\");\n        EntityReference relativeSpaceReference = new EntityReference(\"Z\", EntityType.SPACE);\n        when(this.resourceReferenceResolver.resolve(spaceLinkReference, null))\n            .thenReturn(originalSpaceReference);\n        when(this.relativeEntityReferenceResolver.resolve(spaceLinkReference, null, null))\n            .thenReturn(relativeSpaceReference);\n        when(this.resourceReferenceResolver.resolve(spaceLinkReference, null, oldReference))\n            .thenReturn(originalSpaceReference);\n        when(this.resourceReferenceResolver.resolve(xobjectSpaceLinkReference, null))\n            .thenReturn(originalSpaceReference);\n        when(this.resourceReferenceResolver.resolve(xobjectSpaceLinkReference, null, oldReference))\n            .thenReturn(originalSpaceReference);\n        when(this.resourceReferenceResolver.resolve(spaceLinkReference, null, newReference))\n            .thenReturn(originalSpaceReference);\n        when(this.resourceReferenceResolver.resolve(xobjectSpaceLinkReference, null, newReference))\n            .thenReturn(originalSpaceReference);\n\n        when(this.compactEntityReferenceSerializer.serialize(originalDocLinkReference, newReference)).thenReturn(\"A.C\");\n        when(this.defaultEntityReferenceSerializer.serialize(absoluteDocLinkReference, newReference))\n            .thenReturn(\"wiki:C.WebHome\");\n\n        updater.update(newReference, oldReference, newReference);\n\n        // Document link block is updated.\n        assertEquals(\"A.C\", docLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.DOCUMENT, docLinkBlock.getReference().getType());\n        assertEquals(\"wiki:C.WebHome\", absoluteDocLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.DOCUMENT, absoluteDocLinkBlock.getReference().getType());\n        // Space link block stays the same, since they were on the same wiki.\n        assertEquals(\"Z\", spaceLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.SPACE, spaceLinkBlock.getReference().getType());\n        // Image link relative to the document stay the same\n        assertEquals(\"attachment.txt\", imageBlock.getReference().getReference());\n\n        // XObject Document link block is updated.\n        assertEquals(\"A.C\", xobjectDocLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.DOCUMENT, xobjectDocLinkBlock.getReference().getType());\n        // XObject Space link block stays the same, since they were on the same wiki.\n        assertEquals(\"Z\", xobjectSpaceLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.SPACE, xobjectSpaceLinkBlock.getReference().getType());\n        // Image link relative to the document stay the same\n        assertEquals(\"attachment.txt\", xobjectImageBlock.getReference().getReference());\n\n        verifyDocumentSave(newDocument, true);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49580",
    "cwe_list": [
      "CWE-266"
    ],
    "commit_hash": "ab209acd780da69a4c5ff77ff011efd698273cec",
    "short_hash": "ab209acd",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "updateRelativeLinksAcrossWikis",
        "raw_code": "@Test\n    void updateRelativeLinksAcrossWikis() throws Exception\n    {\n        DocumentReference oldReference = new DocumentReference(\"wiki1\", \"A\", \"B\");\n        DocumentReference newReference = new DocumentReference(\"wiki2\", \"X\", \"Y\");\n\n        XWikiDocument newDocument = mock(XWikiDocument.class);\n        when(this.xcontext.getWiki().getDocument(newReference, this.xcontext)).thenReturn(newDocument);\n        when(newDocument.getDocumentReference()).thenReturn(newReference);\n        when(newDocument.getSyntax()).thenReturn(Syntax.XWIKI_2_1);\n\n        XDOM xdom = mock(XDOM.class);\n        when(newDocument.getXDOM()).thenReturn(xdom);\n\n        ResourceReference docLinkReference = new ResourceReference(\"C\", ResourceType.DOCUMENT);\n        LinkBlock docLinkBlock = new LinkBlock(List.of(), docLinkReference, false);\n\n        ResourceReference spaceLinkReference = new ResourceReference(\"Z\", ResourceType.SPACE);\n        LinkBlock spaceLinkBlock = new LinkBlock(List.of(), spaceLinkReference, false);\n\n        when(xdom.getBlocks(any(), eq(Block.Axes.DESCENDANT)))\n            .thenReturn(List.of(docLinkBlock, spaceLinkBlock));\n\n        DocumentReference originalDocLinkReference = new DocumentReference(\"C\", oldReference.getLastSpaceReference());\n        DocumentReference absoluteDocLinkReference = new DocumentReference(\"C\", new SpaceReference(\"xwiki\", \"Main\"));\n        EntityReference relativeDocLinkReference = new EntityReference(\"C\", EntityType.DOCUMENT,\n            new EntityReference(\"B\", EntityType.SPACE));\n        EntityReference relativeSpaceLinkReference = new EntityReference(\"Z\", EntityType.SPACE);\n        when(this.resourceReferenceResolver.resolve(docLinkReference, null)).thenReturn(absoluteDocLinkReference);\n        when(this.resourceReferenceResolver.resolve(docLinkReference, null, oldReference))\n            .thenReturn(originalDocLinkReference);\n        DocumentReference newDocLinkReference = new DocumentReference(\"C\", newReference.getLastSpaceReference());\n        when(this.resourceReferenceResolver.resolve(docLinkReference, null, newReference))\n            .thenReturn(newDocLinkReference);\n        when(this.relativeEntityReferenceResolver.resolve(docLinkReference, null, null))\n            .thenReturn(relativeDocLinkReference);\n\n        SpaceReference originalSpaceReference = new SpaceReference(\"wiki1\", \"Z\");\n        SpaceReference absoluteSpaceReference = new SpaceReference(\"xwiki\", \"Z\");\n        when(this.resourceReferenceResolver.resolve(spaceLinkReference, null)).thenReturn(absoluteSpaceReference);\n        when(this.resourceReferenceResolver.resolve(spaceLinkReference, null, oldReference))\n            .thenReturn(originalSpaceReference);\n        SpaceReference newSpaceReference = new SpaceReference(\"wiki2\", \"Z\");\n        when(this.resourceReferenceResolver.resolve(spaceLinkReference, null, newReference))\n            .thenReturn(newSpaceReference);\n        when(this.relativeEntityReferenceResolver.resolve(spaceLinkReference, null, null))\n            .thenReturn(relativeSpaceLinkReference);\n\n        when(this.compactEntityReferenceSerializer.serialize(originalDocLinkReference, newReference))\n            .thenReturn(\"wiki1:A.C\");\n        when(this.compactEntityReferenceSerializer.serialize(originalSpaceReference, newReference))\n            .thenReturn(\"wiki1:Z\");\n\n        updater.update(newReference, oldReference, newReference);\n\n        // Document link block is updated.\n        assertEquals(\"wiki1:A.C\", docLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.DOCUMENT, docLinkBlock.getReference().getType());\n        // Space link is also updated, since they were referring entities on a different wiki.\n        assertEquals(\"wiki1:Z\", spaceLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.SPACE, spaceLinkBlock.getReference().getType());\n        verifyDocumentSave(newDocument, \"Updated the relative links.\", true, true);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "updateRelativeLinksAcrossWikis",
        "raw_code": "@Test\n    void updateRelativeLinksAcrossWikis() throws Exception\n    {\n        DocumentReference oldReference = new DocumentReference(\"wiki1\", \"A\", \"B\");\n        DocumentReference newReference = new DocumentReference(\"wiki2\", \"X\", \"Y\");\n\n        XWikiDocument newDocument = mock(XWikiDocument.class);\n        DocumentAuthors authors = mock(DocumentAuthors.class);\n        when(newDocument.getAuthors()).thenReturn(authors);\n        when(this.xcontext.getWiki().getDocument(newReference, this.xcontext)).thenReturn(newDocument);\n        when(newDocument.getDocumentReference()).thenReturn(newReference);\n        when(newDocument.getSyntax()).thenReturn(Syntax.XWIKI_2_1);\n\n        XDOM xdom = mock(XDOM.class);\n        when(newDocument.getXDOM()).thenReturn(xdom);\n\n        ResourceReference docLinkReference = new ResourceReference(\"C\", ResourceType.DOCUMENT);\n        LinkBlock docLinkBlock = new LinkBlock(List.of(), docLinkReference, false);\n\n        ResourceReference spaceLinkReference = new ResourceReference(\"Z\", ResourceType.SPACE);\n        LinkBlock spaceLinkBlock = new LinkBlock(List.of(), spaceLinkReference, false);\n\n        when(xdom.getBlocks(any(), eq(Block.Axes.DESCENDANT)))\n            .thenReturn(List.of(docLinkBlock, spaceLinkBlock));\n\n        DocumentReference originalDocLinkReference = new DocumentReference(\"C\", oldReference.getLastSpaceReference());\n        DocumentReference absoluteDocLinkReference = new DocumentReference(\"C\", new SpaceReference(\"xwiki\", \"Main\"));\n        EntityReference relativeDocLinkReference = new EntityReference(\"C\", EntityType.DOCUMENT,\n            new EntityReference(\"B\", EntityType.SPACE));\n        EntityReference relativeSpaceLinkReference = new EntityReference(\"Z\", EntityType.SPACE);\n        when(this.resourceReferenceResolver.resolve(docLinkReference, null)).thenReturn(absoluteDocLinkReference);\n        when(this.resourceReferenceResolver.resolve(docLinkReference, null, oldReference))\n            .thenReturn(originalDocLinkReference);\n        DocumentReference newDocLinkReference = new DocumentReference(\"C\", newReference.getLastSpaceReference());\n        when(this.resourceReferenceResolver.resolve(docLinkReference, null, newReference))\n            .thenReturn(newDocLinkReference);\n        when(this.relativeEntityReferenceResolver.resolve(docLinkReference, null, null))\n            .thenReturn(relativeDocLinkReference);\n\n        SpaceReference originalSpaceReference = new SpaceReference(\"wiki1\", \"Z\");\n        SpaceReference absoluteSpaceReference = new SpaceReference(\"xwiki\", \"Z\");\n        when(this.resourceReferenceResolver.resolve(spaceLinkReference, null)).thenReturn(absoluteSpaceReference);\n        when(this.resourceReferenceResolver.resolve(spaceLinkReference, null, oldReference))\n            .thenReturn(originalSpaceReference);\n        SpaceReference newSpaceReference = new SpaceReference(\"wiki2\", \"Z\");\n        when(this.resourceReferenceResolver.resolve(spaceLinkReference, null, newReference))\n            .thenReturn(newSpaceReference);\n        when(this.relativeEntityReferenceResolver.resolve(spaceLinkReference, null, null))\n            .thenReturn(relativeSpaceLinkReference);\n\n        when(this.compactEntityReferenceSerializer.serialize(originalDocLinkReference, newReference))\n            .thenReturn(\"wiki1:A.C\");\n        when(this.compactEntityReferenceSerializer.serialize(originalSpaceReference, newReference))\n            .thenReturn(\"wiki1:Z\");\n\n        updater.update(newReference, oldReference, newReference);\n\n        // Document link block is updated.\n        assertEquals(\"wiki1:A.C\", docLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.DOCUMENT, docLinkBlock.getReference().getType());\n        // Space link is also updated, since they were referring entities on a different wiki.\n        assertEquals(\"wiki1:Z\", spaceLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.SPACE, spaceLinkBlock.getReference().getType());\n        verifyDocumentSave(newDocument, true);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49580",
    "cwe_list": [
      "CWE-266"
    ],
    "commit_hash": "ab209acd780da69a4c5ff77ff011efd698273cec",
    "short_hash": "ab209acd",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "update",
        "raw_code": "@Test\n    void update() throws Exception\n    {\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(this.xcontext.getWiki().getDocument(documentReference, this.xcontext)).thenReturn(document);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.getSyntax()).thenReturn(Syntax.XWIKI_2_1);\n\n        // From a terminal document to another terminal document.\n        DocumentReference oldLinkTarget = new DocumentReference(\"wiki\", \"A\", \"B\");\n        DocumentReference newLinkTarget = new DocumentReference(\"wiki\", \"X\", \"Y\");\n\n        // Setup document content\n        ResourceReference linkReference = new ResourceReference(\"A.B\", ResourceType.DOCUMENT);\n        LinkBlock linkBlock = new LinkBlock(List.of(), linkReference, false);\n        ResourceReference absoluteLinkReference = new ResourceReference(\"xwiki:A.B.WebHome\", ResourceType.DOCUMENT);\n        LinkBlock absoluteLinkBlock = new LinkBlock(List.of(), absoluteLinkReference, false);\n        XDOM xdom = new XDOM(List.of(linkBlock, absoluteLinkBlock));\n        when(document.getXDOM()).thenReturn(xdom);\n\n        // Setup object content\n        ResourceReference xobjectLinkReference = new ResourceReference(\"A.B\", ResourceType.DOCUMENT);\n        LinkBlock xobjectLinkBlock = new LinkBlock(List.of(), xobjectLinkReference, false);\n        XDOM xobjectXDOM = new XDOM(List.of(xobjectLinkBlock));\n        setTextarea(document, xobjectXDOM);\n\n        EntityReference relativeLinkReference = new EntityReference(\"B\", EntityType.DOCUMENT,\n            new EntityReference(\"A\", EntityType.SPACE));\n        EntityReference relativeAbsoluteLinkReference = new EntityReference(\"WebHome\", EntityType.DOCUMENT,\n            new EntityReference(\"B\", EntityType.SPACE, new EntityReference(\"B\", EntityType.SPACE,\n                new EntityReference(\"xwiki\", EntityType.WIKI))));\n\n        when(this.resourceReferenceResolver.resolve(linkReference, null)).thenReturn(oldLinkTarget);\n        when(this.resourceReferenceResolver.resolve(linkReference, null, documentReference)).thenReturn(oldLinkTarget);\n        when(this.resourceReferenceResolver.resolve(absoluteLinkReference, null)).thenReturn(oldLinkTarget);\n        when(this.resourceReferenceResolver.resolve(absoluteLinkReference, null, documentReference))\n            .thenReturn(oldLinkTarget);\n        when(this.resourceReferenceResolver.resolve(xobjectLinkReference, null))\n            .thenReturn(oldLinkTarget);\n        when(this.resourceReferenceResolver.resolve(xobjectLinkReference, null, documentReference))\n            .thenReturn(oldLinkTarget);\n        when(this.defaultReferenceDocumentReferenceResolver.resolve(oldLinkTarget)).thenReturn(oldLinkTarget);\n        when(this.relativeEntityReferenceResolver.resolve(xobjectLinkReference,null, null))\n            .thenReturn(relativeLinkReference);\n        when(this.relativeEntityReferenceResolver.resolve(linkReference, null, null))\n            .thenReturn(relativeLinkReference);\n        when(this.relativeEntityReferenceResolver.resolve(absoluteLinkReference, null, null))\n            .thenReturn(relativeAbsoluteLinkReference);\n\n        when(this.compactEntityReferenceSerializer.serialize(newLinkTarget, documentReference)).thenReturn(\"X.Y\");\n        when(this.defaultEntityReferenceSerializer.serialize(newLinkTarget, documentReference))\n            .thenReturn(\"xwiki:X.Y.WebHome\");\n\n        updater.update(documentReference, oldLinkTarget, newLinkTarget);\n\n        assertEquals(\"X.Y\", linkBlock.getReference().getReference());\n        assertEquals(\"xwiki:X.Y.WebHome\", absoluteLinkBlock.getReference().getReference());\n        assertEquals(\"X.Y\", xobjectLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.DOCUMENT, linkBlock.getReference().getType());\n        verifyDocumentSave(document, \"Renamed back-links.\", false, false);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "update",
        "raw_code": "@Test\n    void update() throws Exception\n    {\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        DocumentAuthors authors = mock(DocumentAuthors.class);\n        when(document.getAuthors()).thenReturn(authors);\n        when(this.xcontext.getWiki().getDocument(documentReference, this.xcontext)).thenReturn(document);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.getSyntax()).thenReturn(Syntax.XWIKI_2_1);\n\n        // From a terminal document to another terminal document.\n        DocumentReference oldLinkTarget = new DocumentReference(\"wiki\", \"A\", \"B\");\n        DocumentReference newLinkTarget = new DocumentReference(\"wiki\", \"X\", \"Y\");\n\n        // Setup document content\n        ResourceReference linkReference = new ResourceReference(\"A.B\", ResourceType.DOCUMENT);\n        LinkBlock linkBlock = new LinkBlock(List.of(), linkReference, false);\n        ResourceReference absoluteLinkReference = new ResourceReference(\"xwiki:A.B.WebHome\", ResourceType.DOCUMENT);\n        LinkBlock absoluteLinkBlock = new LinkBlock(List.of(), absoluteLinkReference, false);\n        XDOM xdom = new XDOM(List.of(linkBlock, absoluteLinkBlock));\n        when(document.getXDOM()).thenReturn(xdom);\n\n        // Setup object content\n        ResourceReference xobjectLinkReference = new ResourceReference(\"A.B\", ResourceType.DOCUMENT);\n        LinkBlock xobjectLinkBlock = new LinkBlock(List.of(), xobjectLinkReference, false);\n        XDOM xobjectXDOM = new XDOM(List.of(xobjectLinkBlock));\n        setTextarea(document, xobjectXDOM);\n\n        EntityReference relativeLinkReference = new EntityReference(\"B\", EntityType.DOCUMENT,\n            new EntityReference(\"A\", EntityType.SPACE));\n        EntityReference relativeAbsoluteLinkReference = new EntityReference(\"WebHome\", EntityType.DOCUMENT,\n            new EntityReference(\"B\", EntityType.SPACE, new EntityReference(\"B\", EntityType.SPACE,\n                new EntityReference(\"xwiki\", EntityType.WIKI))));\n\n        when(this.resourceReferenceResolver.resolve(linkReference, null)).thenReturn(oldLinkTarget);\n        when(this.resourceReferenceResolver.resolve(linkReference, null, documentReference)).thenReturn(oldLinkTarget);\n        when(this.resourceReferenceResolver.resolve(absoluteLinkReference, null)).thenReturn(oldLinkTarget);\n        when(this.resourceReferenceResolver.resolve(absoluteLinkReference, null, documentReference))\n            .thenReturn(oldLinkTarget);\n        when(this.resourceReferenceResolver.resolve(xobjectLinkReference, null))\n            .thenReturn(oldLinkTarget);\n        when(this.resourceReferenceResolver.resolve(xobjectLinkReference, null, documentReference))\n            .thenReturn(oldLinkTarget);\n        when(this.defaultReferenceDocumentReferenceResolver.resolve(oldLinkTarget)).thenReturn(oldLinkTarget);\n        when(this.relativeEntityReferenceResolver.resolve(xobjectLinkReference,null, null))\n            .thenReturn(relativeLinkReference);\n        when(this.relativeEntityReferenceResolver.resolve(linkReference, null, null))\n            .thenReturn(relativeLinkReference);\n        when(this.relativeEntityReferenceResolver.resolve(absoluteLinkReference, null, null))\n            .thenReturn(relativeAbsoluteLinkReference);\n\n        when(this.compactEntityReferenceSerializer.serialize(newLinkTarget, documentReference)).thenReturn(\"X.Y\");\n        when(this.defaultEntityReferenceSerializer.serialize(newLinkTarget, documentReference))\n            .thenReturn(\"xwiki:X.Y.WebHome\");\n\n        updater.update(documentReference, oldLinkTarget, newLinkTarget);\n\n        assertEquals(\"X.Y\", linkBlock.getReference().getReference());\n        assertEquals(\"xwiki:X.Y.WebHome\", absoluteLinkBlock.getReference().getReference());\n        assertEquals(\"X.Y\", xobjectLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.DOCUMENT, linkBlock.getReference().getType());\n        verifyDocumentSave(document, false);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49580",
    "cwe_list": [
      "CWE-266"
    ],
    "commit_hash": "ab209acd780da69a4c5ff77ff011efd698273cec",
    "short_hash": "ab209acd",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "renameImage",
        "raw_code": "@Test\n    void renameImage() throws Exception\n    {\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(this.xcontext.getWiki().getDocument(documentReference, this.xcontext)).thenReturn(document);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.getSyntax()).thenReturn(Syntax.XWIKI_2_1);\n\n        // From a terminal document to another terminal document.\n        DocumentReference oldImageTarget = new DocumentReference(\"wiki\", \"A\", \"B\");\n        AttachmentReference oldImageTargetAttachment = new AttachmentReference(\"attachment.txt\", oldImageTarget);\n        DocumentReference newImageTarget = new DocumentReference(\"wiki\", \"X\", \"Y\");\n        AttachmentReference newImageTargetAttachment = new AttachmentReference(\"attachment.txt\", newImageTarget);\n\n        XDOM xdom = mock(XDOM.class);\n        when(document.getXDOM()).thenReturn(xdom);\n\n        ResourceReference imageReference = new AttachmentResourceReference(\"A.B@attachment.txt\");\n        ImageBlock imageBlock = new ImageBlock(imageReference, false);\n        when(xdom.getBlocks(any(), eq(Block.Axes.DESCENDANT))).thenReturn(List.of(imageBlock));\n\n        EntityReference relativeReference = new EntityReference(\"attachment.txt\", EntityType.ATTACHMENT,\n            new EntityReference(\"B\", EntityType.DOCUMENT, new EntityReference(\"A\", EntityType.SPACE)));\n\n        when(this.resourceReferenceResolver.resolve(imageReference, null)).thenReturn(oldImageTargetAttachment);\n        when(this.resourceReferenceResolver.resolve(imageReference, null, documentReference))\n            .thenReturn(oldImageTargetAttachment);\n        when(this.defaultReferenceDocumentReferenceResolver.resolve(oldImageTargetAttachment))\n            .thenReturn(oldImageTarget);\n        when(this.relativeEntityReferenceResolver.resolve(imageReference, null, null)).thenReturn(relativeReference);\n\n        when(this.compactEntityReferenceSerializer.serialize(newImageTargetAttachment, documentReference))\n            .thenReturn(\"X.Y@attachment.txt\");\n\n        updater.update(documentReference, oldImageTarget, newImageTarget);\n\n        assertEquals(\"X.Y@attachment.txt\", imageBlock.getReference().getReference());\n        assertEquals(ResourceType.ATTACHMENT, imageBlock.getReference().getType());\n        verifyDocumentSave(document, \"Renamed back-links.\", false, false);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "renameImage",
        "raw_code": "@Test\n    void renameImage() throws Exception\n    {\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        DocumentAuthors authors = mock(DocumentAuthors.class);\n        when(document.getAuthors()).thenReturn(authors);\n        when(this.xcontext.getWiki().getDocument(documentReference, this.xcontext)).thenReturn(document);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.getSyntax()).thenReturn(Syntax.XWIKI_2_1);\n\n        // From a terminal document to another terminal document.\n        DocumentReference oldImageTarget = new DocumentReference(\"wiki\", \"A\", \"B\");\n        AttachmentReference oldImageTargetAttachment = new AttachmentReference(\"attachment.txt\", oldImageTarget);\n        DocumentReference newImageTarget = new DocumentReference(\"wiki\", \"X\", \"Y\");\n        AttachmentReference newImageTargetAttachment = new AttachmentReference(\"attachment.txt\", newImageTarget);\n\n        XDOM xdom = mock(XDOM.class);\n        when(document.getXDOM()).thenReturn(xdom);\n\n        ResourceReference imageReference = new AttachmentResourceReference(\"A.B@attachment.txt\");\n        ImageBlock imageBlock = new ImageBlock(imageReference, false);\n        when(xdom.getBlocks(any(), eq(Block.Axes.DESCENDANT))).thenReturn(List.of(imageBlock));\n\n        EntityReference relativeReference = new EntityReference(\"attachment.txt\", EntityType.ATTACHMENT,\n            new EntityReference(\"B\", EntityType.DOCUMENT, new EntityReference(\"A\", EntityType.SPACE)));\n\n        when(this.resourceReferenceResolver.resolve(imageReference, null)).thenReturn(oldImageTargetAttachment);\n        when(this.resourceReferenceResolver.resolve(imageReference, null, documentReference))\n            .thenReturn(oldImageTargetAttachment);\n        when(this.defaultReferenceDocumentReferenceResolver.resolve(oldImageTargetAttachment))\n            .thenReturn(oldImageTarget);\n        when(this.relativeEntityReferenceResolver.resolve(imageReference, null, null)).thenReturn(relativeReference);\n\n        when(this.compactEntityReferenceSerializer.serialize(newImageTargetAttachment, documentReference))\n            .thenReturn(\"X.Y@attachment.txt\");\n\n        updater.update(documentReference, oldImageTarget, newImageTarget);\n\n        assertEquals(\"X.Y@attachment.txt\", imageBlock.getReference().getReference());\n        assertEquals(ResourceType.ATTACHMENT, imageBlock.getReference().getType());\n        verifyDocumentSave(document, false);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49580",
    "cwe_list": [
      "CWE-266"
    ],
    "commit_hash": "ab209acd780da69a4c5ff77ff011efd698273cec",
    "short_hash": "ab209acd",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "renameAttachment",
        "raw_code": "@Test\n    void renameAttachment() throws Exception\n    {\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(this.xcontext.getWiki().getDocument(documentReference, this.xcontext)).thenReturn(document);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.getSyntax()).thenReturn(Syntax.XWIKI_2_1);\n\n        // From a terminal document to another terminal document.\n        DocumentReference oldLinkTarget = new DocumentReference(\"wiki\", \"A\", \"B\");\n        AttachmentReference oldLinkTargetAttachment = new AttachmentReference(\"attachment.txt\", oldLinkTarget);\n        DocumentReference newLinkTarget = new DocumentReference(\"wiki\", \"X\", \"Y\");\n        AttachmentReference newLinkTargetAttachment = new AttachmentReference(\"attachment.txt\", newLinkTarget);\n\n        XDOM xdom = mock(XDOM.class);\n        when(document.getXDOM()).thenReturn(xdom);\n\n        ResourceReference linkReference = new AttachmentResourceReference(\"A.B@attachment.txt\");\n        LinkBlock linkBlock = new LinkBlock(List.of(), linkReference, false);\n        when(xdom.getBlocks(any(), eq(Block.Axes.DESCENDANT))).thenReturn(List.of(linkBlock));\n\n        EntityReference relativeReference = new EntityReference(\"attachment.txt\", EntityType.ATTACHMENT,\n            new EntityReference(\"B\", EntityType.DOCUMENT, new EntityReference(\"A\", EntityType.SPACE)));\n\n        when(this.resourceReferenceResolver.resolve(linkReference, null))\n            .thenReturn(oldLinkTargetAttachment);\n        when(this.resourceReferenceResolver.resolve(linkReference, null, documentReference))\n            .thenReturn(oldLinkTargetAttachment);\n        when(this.defaultReferenceDocumentReferenceResolver.resolve(oldLinkTargetAttachment)).thenReturn(oldLinkTarget);\n        when(this.relativeEntityReferenceResolver.resolve(linkReference, null, null)).thenReturn(relativeReference);\n\n        when(this.compactEntityReferenceSerializer.serialize(newLinkTargetAttachment, documentReference))\n            .thenReturn(\"X.Y@attachment.txt\");\n\n        updater.update(documentReference, oldLinkTarget, newLinkTarget);\n\n        assertEquals(\"X.Y@attachment.txt\", linkBlock.getReference().getReference());\n        assertEquals(ResourceType.ATTACHMENT, linkBlock.getReference().getType());\n        verifyDocumentSave(document, \"Renamed back-links.\", false, false);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "renameAttachment",
        "raw_code": "@Test\n    void renameAttachment() throws Exception\n    {\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        DocumentAuthors authors = mock(DocumentAuthors.class);\n        when(document.getAuthors()).thenReturn(authors);\n        when(this.xcontext.getWiki().getDocument(documentReference, this.xcontext)).thenReturn(document);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.getSyntax()).thenReturn(Syntax.XWIKI_2_1);\n\n        // From a terminal document to another terminal document.\n        DocumentReference oldLinkTarget = new DocumentReference(\"wiki\", \"A\", \"B\");\n        AttachmentReference oldLinkTargetAttachment = new AttachmentReference(\"attachment.txt\", oldLinkTarget);\n        DocumentReference newLinkTarget = new DocumentReference(\"wiki\", \"X\", \"Y\");\n        AttachmentReference newLinkTargetAttachment = new AttachmentReference(\"attachment.txt\", newLinkTarget);\n\n        XDOM xdom = mock(XDOM.class);\n        when(document.getXDOM()).thenReturn(xdom);\n\n        ResourceReference linkReference = new AttachmentResourceReference(\"A.B@attachment.txt\");\n        LinkBlock linkBlock = new LinkBlock(List.of(), linkReference, false);\n        when(xdom.getBlocks(any(), eq(Block.Axes.DESCENDANT))).thenReturn(List.of(linkBlock));\n\n        EntityReference relativeReference = new EntityReference(\"attachment.txt\", EntityType.ATTACHMENT,\n            new EntityReference(\"B\", EntityType.DOCUMENT, new EntityReference(\"A\", EntityType.SPACE)));\n\n        when(this.resourceReferenceResolver.resolve(linkReference, null))\n            .thenReturn(oldLinkTargetAttachment);\n        when(this.resourceReferenceResolver.resolve(linkReference, null, documentReference))\n            .thenReturn(oldLinkTargetAttachment);\n        when(this.defaultReferenceDocumentReferenceResolver.resolve(oldLinkTargetAttachment)).thenReturn(oldLinkTarget);\n        when(this.relativeEntityReferenceResolver.resolve(linkReference, null, null)).thenReturn(relativeReference);\n\n        when(this.compactEntityReferenceSerializer.serialize(newLinkTargetAttachment, documentReference))\n            .thenReturn(\"X.Y@attachment.txt\");\n\n        updater.update(documentReference, oldLinkTarget, newLinkTarget);\n\n        assertEquals(\"X.Y@attachment.txt\", linkBlock.getReference().getReference());\n        assertEquals(ResourceType.ATTACHMENT, linkBlock.getReference().getType());\n        verifyDocumentSave(document, false);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49580",
    "cwe_list": [
      "CWE-266"
    ],
    "commit_hash": "ab209acd780da69a4c5ff77ff011efd698273cec",
    "short_hash": "ab209acd",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "renameNonTerminalDocumentLinks",
        "raw_code": "@Test\n    void renameNonTerminalDocumentLinks() throws Exception\n    {\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(this.xcontext.getWiki().getDocument(documentReference, this.xcontext)).thenReturn(document);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.getSyntax()).thenReturn(Syntax.XWIKI_2_1);\n\n        // From a non-terminal document to another non-terminal document.\n        DocumentReference oldLinkTarget = new DocumentReference(\"wiki\", \"A\", \"WebHome\");\n        DocumentReference newLinkTarget = new DocumentReference(\"wiki\", \"X\", \"WebHome\");\n\n        XDOM xdom = mock(XDOM.class);\n        when(document.getXDOM()).thenReturn(xdom);\n\n        ResourceReference docLinkReference = new ResourceReference(\"A.WebHome\", ResourceType.DOCUMENT);\n        LinkBlock documentLinkBlock = new LinkBlock(List.of(), docLinkReference, false);\n        EntityReference relativeReference = new EntityReference(\"WebHome\", EntityType.DOCUMENT,\n            new EntityReference(\"A\", EntityType.SPACE));\n\n        ResourceReference spaceLinkReference = new ResourceReference(\"A\", ResourceType.SPACE);\n        LinkBlock spaceLinkBlock = new LinkBlock(List.of(), spaceLinkReference, false);\n        EntityReference relativeSpaceReference = new EntityReference(\"A\", EntityType.SPACE);\n\n        when(xdom.getBlocks(any(), eq(Block.Axes.DESCENDANT)))\n            .thenReturn(List.of(documentLinkBlock, spaceLinkBlock));\n\n        // Doc link\n        when(this.resourceReferenceResolver.resolve(docLinkReference, null))\n            .thenReturn(oldLinkTarget);\n        when(this.resourceReferenceResolver.resolve(docLinkReference, null, documentReference))\n            .thenReturn(oldLinkTarget);\n        when(this.defaultReferenceDocumentReferenceResolver.resolve(oldLinkTarget)).thenReturn(oldLinkTarget);\n        when(this.compactEntityReferenceSerializer.serialize(newLinkTarget, documentReference)).thenReturn(\"X.WebHome\");\n        when(this.relativeEntityReferenceResolver.resolve(docLinkReference, null, null)).thenReturn(relativeReference);\n\n        // Space link\n        SpaceReference spaceReference = oldLinkTarget.getLastSpaceReference();\n        when(this.resourceReferenceResolver.resolve(spaceLinkReference, null))\n            .thenReturn(spaceReference);\n        when(this.resourceReferenceResolver.resolve(spaceLinkReference, null, documentReference))\n            .thenReturn(spaceReference);\n        when(this.defaultReferenceDocumentReferenceResolver.resolve(spaceReference)).thenReturn(oldLinkTarget);\n        when(this.compactEntityReferenceSerializer.serialize(newLinkTarget.getLastSpaceReference(), documentReference))\n            .thenReturn(\"X\");\n        when(this.relativeEntityReferenceResolver.resolve(spaceLinkReference, null, null))\n            .thenReturn(relativeSpaceReference);\n\n        updater.update(documentReference, oldLinkTarget, newLinkTarget);\n\n        assertEquals(\"X.WebHome\", documentLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.DOCUMENT, documentLinkBlock.getReference().getType());\n        assertEquals(\"X\", spaceLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.SPACE, spaceLinkBlock.getReference().getType());\n        verifyDocumentSave(document, \"Renamed back-links.\", false, false);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "renameNonTerminalDocumentLinks",
        "raw_code": "@Test\n    void renameNonTerminalDocumentLinks() throws Exception\n    {\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        DocumentAuthors authors = mock(DocumentAuthors.class);\n        when(document.getAuthors()).thenReturn(authors);\n        when(this.xcontext.getWiki().getDocument(documentReference, this.xcontext)).thenReturn(document);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.getSyntax()).thenReturn(Syntax.XWIKI_2_1);\n\n        // From a non-terminal document to another non-terminal document.\n        DocumentReference oldLinkTarget = new DocumentReference(\"wiki\", \"A\", \"WebHome\");\n        DocumentReference newLinkTarget = new DocumentReference(\"wiki\", \"X\", \"WebHome\");\n\n        XDOM xdom = mock(XDOM.class);\n        when(document.getXDOM()).thenReturn(xdom);\n\n        ResourceReference docLinkReference = new ResourceReference(\"A.WebHome\", ResourceType.DOCUMENT);\n        LinkBlock documentLinkBlock = new LinkBlock(List.of(), docLinkReference, false);\n        EntityReference relativeReference = new EntityReference(\"WebHome\", EntityType.DOCUMENT,\n            new EntityReference(\"A\", EntityType.SPACE));\n\n        ResourceReference spaceLinkReference = new ResourceReference(\"A\", ResourceType.SPACE);\n        LinkBlock spaceLinkBlock = new LinkBlock(List.of(), spaceLinkReference, false);\n        EntityReference relativeSpaceReference = new EntityReference(\"A\", EntityType.SPACE);\n\n        when(xdom.getBlocks(any(), eq(Block.Axes.DESCENDANT)))\n            .thenReturn(List.of(documentLinkBlock, spaceLinkBlock));\n\n        // Doc link\n        when(this.resourceReferenceResolver.resolve(docLinkReference, null))\n            .thenReturn(oldLinkTarget);\n        when(this.resourceReferenceResolver.resolve(docLinkReference, null, documentReference))\n            .thenReturn(oldLinkTarget);\n        when(this.defaultReferenceDocumentReferenceResolver.resolve(oldLinkTarget)).thenReturn(oldLinkTarget);\n        when(this.compactEntityReferenceSerializer.serialize(newLinkTarget, documentReference)).thenReturn(\"X.WebHome\");\n        when(this.relativeEntityReferenceResolver.resolve(docLinkReference, null, null)).thenReturn(relativeReference);\n\n        // Space link\n        SpaceReference spaceReference = oldLinkTarget.getLastSpaceReference();\n        when(this.resourceReferenceResolver.resolve(spaceLinkReference, null))\n            .thenReturn(spaceReference);\n        when(this.resourceReferenceResolver.resolve(spaceLinkReference, null, documentReference))\n            .thenReturn(spaceReference);\n        when(this.defaultReferenceDocumentReferenceResolver.resolve(spaceReference)).thenReturn(oldLinkTarget);\n        when(this.compactEntityReferenceSerializer.serialize(newLinkTarget.getLastSpaceReference(), documentReference))\n            .thenReturn(\"X\");\n        when(this.relativeEntityReferenceResolver.resolve(spaceLinkReference, null, null))\n            .thenReturn(relativeSpaceReference);\n\n        updater.update(documentReference, oldLinkTarget, newLinkTarget);\n\n        assertEquals(\"X.WebHome\", documentLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.DOCUMENT, documentLinkBlock.getReference().getType());\n        assertEquals(\"X\", spaceLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.SPACE, spaceLinkBlock.getReference().getType());\n        verifyDocumentSave(document, false);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49580",
    "cwe_list": [
      "CWE-266"
    ],
    "commit_hash": "ab209acd780da69a4c5ff77ff011efd698273cec",
    "short_hash": "ab209acd",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "renameNonTerminalToTerminalDocumentLinks",
        "raw_code": "@Test\n    void renameNonTerminalToTerminalDocumentLinks() throws Exception\n    {\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(this.xcontext.getWiki().getDocument(documentReference, this.xcontext)).thenReturn(document);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.getSyntax()).thenReturn(Syntax.XWIKI_2_1);\n\n        // From a non-terminal document to a terminal document.\n        DocumentReference oldLinkTarget = new DocumentReference(\"wiki\", \"A\", \"WebHome\");\n        DocumentReference newLinkTarget = new DocumentReference(\"wiki\", \"X\", \"Y\");\n\n        XDOM xdom = mock(XDOM.class);\n        when(document.getXDOM()).thenReturn(xdom);\n\n        ResourceReference docLinkReference = new ResourceReference(\"A.WebHome\", ResourceType.DOCUMENT);\n        LinkBlock documentLinkBlock = new LinkBlock(List.of(), docLinkReference, false);\n\n        EntityReference relativeReference = new EntityReference(\"WebHome\", EntityType.DOCUMENT,\n            new EntityReference(\"A\", EntityType.SPACE));\n\n        ResourceReference spaceLinkReference = new ResourceReference(\"A\", ResourceType.SPACE);\n        LinkBlock spaceLinkBlock = new LinkBlock(List.of(), spaceLinkReference, false);\n\n        EntityReference relativeSpaceReference = new EntityReference(\"A\", EntityType.SPACE);\n\n        when(xdom.getBlocks(any(), eq(Block.Axes.DESCENDANT)))\n            .thenReturn(List.of(documentLinkBlock, spaceLinkBlock));\n\n        // Doc link\n        when(this.resourceReferenceResolver.resolve(docLinkReference, null))\n            .thenReturn(oldLinkTarget);\n        when(this.resourceReferenceResolver.resolve(docLinkReference, null, documentReference))\n            .thenReturn(oldLinkTarget);\n        when(this.defaultReferenceDocumentReferenceResolver.resolve(oldLinkTarget)).thenReturn(oldLinkTarget);\n        when(this.compactEntityReferenceSerializer.serialize(newLinkTarget, documentReference)).thenReturn(\"X.Y\");\n        when(this.relativeEntityReferenceResolver.resolve(docLinkReference, null, null)).thenReturn(relativeReference);\n\n        // Space link\n        SpaceReference spaceReference = oldLinkTarget.getLastSpaceReference();\n        when(this.resourceReferenceResolver.resolve(spaceLinkReference, null))\n            .thenReturn(spaceReference);\n        when(this.resourceReferenceResolver.resolve(spaceLinkReference, null, documentReference))\n            .thenReturn(spaceReference);\n        when(this.defaultReferenceDocumentReferenceResolver.resolve(spaceReference)).thenReturn(oldLinkTarget);\n        when(this.compactEntityReferenceSerializer.serialize(newLinkTarget.getLastSpaceReference(), documentReference))\n            .thenReturn(\"X\");\n        when(this.relativeEntityReferenceResolver.resolve(spaceLinkReference, null, null))\n            .thenReturn(relativeSpaceReference);\n\n        updater.update(documentReference, oldLinkTarget, newLinkTarget);\n\n        // Note that both resulting renamed back-links are of type document. (i.e. the space link was converted to a doc\n        // link)\n        assertEquals(\"X.Y\", documentLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.DOCUMENT, documentLinkBlock.getReference().getType());\n        assertEquals(\"X.Y\", spaceLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.DOCUMENT, spaceLinkBlock.getReference().getType());\n        verifyDocumentSave(document, \"Renamed back-links.\", false, false);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "renameNonTerminalToTerminalDocumentLinks",
        "raw_code": "@Test\n    void renameNonTerminalToTerminalDocumentLinks() throws Exception\n    {\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        DocumentAuthors authors = mock(DocumentAuthors.class);\n        when(document.getAuthors()).thenReturn(authors);\n        when(this.xcontext.getWiki().getDocument(documentReference, this.xcontext)).thenReturn(document);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.getSyntax()).thenReturn(Syntax.XWIKI_2_1);\n\n        // From a non-terminal document to a terminal document.\n        DocumentReference oldLinkTarget = new DocumentReference(\"wiki\", \"A\", \"WebHome\");\n        DocumentReference newLinkTarget = new DocumentReference(\"wiki\", \"X\", \"Y\");\n\n        XDOM xdom = mock(XDOM.class);\n        when(document.getXDOM()).thenReturn(xdom);\n\n        ResourceReference docLinkReference = new ResourceReference(\"A.WebHome\", ResourceType.DOCUMENT);\n        LinkBlock documentLinkBlock = new LinkBlock(List.of(), docLinkReference, false);\n\n        EntityReference relativeReference = new EntityReference(\"WebHome\", EntityType.DOCUMENT,\n            new EntityReference(\"A\", EntityType.SPACE));\n\n        ResourceReference spaceLinkReference = new ResourceReference(\"A\", ResourceType.SPACE);\n        LinkBlock spaceLinkBlock = new LinkBlock(List.of(), spaceLinkReference, false);\n\n        EntityReference relativeSpaceReference = new EntityReference(\"A\", EntityType.SPACE);\n\n        when(xdom.getBlocks(any(), eq(Block.Axes.DESCENDANT)))\n            .thenReturn(List.of(documentLinkBlock, spaceLinkBlock));\n\n        // Doc link\n        when(this.resourceReferenceResolver.resolve(docLinkReference, null))\n            .thenReturn(oldLinkTarget);\n        when(this.resourceReferenceResolver.resolve(docLinkReference, null, documentReference))\n            .thenReturn(oldLinkTarget);\n        when(this.defaultReferenceDocumentReferenceResolver.resolve(oldLinkTarget)).thenReturn(oldLinkTarget);\n        when(this.compactEntityReferenceSerializer.serialize(newLinkTarget, documentReference)).thenReturn(\"X.Y\");\n        when(this.relativeEntityReferenceResolver.resolve(docLinkReference, null, null)).thenReturn(relativeReference);\n\n        // Space link\n        SpaceReference spaceReference = oldLinkTarget.getLastSpaceReference();\n        when(this.resourceReferenceResolver.resolve(spaceLinkReference, null))\n            .thenReturn(spaceReference);\n        when(this.resourceReferenceResolver.resolve(spaceLinkReference, null, documentReference))\n            .thenReturn(spaceReference);\n        when(this.defaultReferenceDocumentReferenceResolver.resolve(spaceReference)).thenReturn(oldLinkTarget);\n        when(this.compactEntityReferenceSerializer.serialize(newLinkTarget.getLastSpaceReference(), documentReference))\n            .thenReturn(\"X\");\n        when(this.relativeEntityReferenceResolver.resolve(spaceLinkReference, null, null))\n            .thenReturn(relativeSpaceReference);\n\n        updater.update(documentReference, oldLinkTarget, newLinkTarget);\n\n        // Note that both resulting renamed back-links are of type document. (i.e. the space link was converted to a doc\n        // link)\n        assertEquals(\"X.Y\", documentLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.DOCUMENT, documentLinkBlock.getReference().getType());\n        assertEquals(\"X.Y\", spaceLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.DOCUMENT, spaceLinkBlock.getReference().getType());\n        verifyDocumentSave(document, false);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49580",
    "cwe_list": [
      "CWE-266"
    ],
    "commit_hash": "ab209acd780da69a4c5ff77ff011efd698273cec",
    "short_hash": "ab209acd",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "updateFromMacros",
        "raw_code": "@Test\n    void updateFromMacros(MockitoComponentManager componentManager) throws Exception\n    {\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(this.xcontext.getWiki().getDocument(documentReference, this.xcontext)).thenReturn(document);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.getSyntax()).thenReturn(Syntax.XWIKI_2_1);\n\n        // From a terminal document to another terminal document.\n        DocumentReference oldLinkTarget = new DocumentReference(\"wiki\", \"A\", \"B\");\n        DocumentReference newLinkTarget = new DocumentReference(\"wiki\", \"X\", \"Y\");\n\n        XDOM xdom = mock(XDOM.class);\n        when(document.getXDOM()).thenReturn(xdom);\n\n        Map<String, String> includeParameters = new HashMap<String, String>();\n        includeParameters.put(\"reference\", \"A.B\");\n        MacroBlock includeMacroBlock1 = new MacroBlock(\"include\", includeParameters, false);\n        includeMacroBlock1.setParent(xdom);\n\n        Map<String, String> includeOldParameters = new HashMap<String, String>();\n        includeOldParameters.put(\"document\", \"A.B\");\n        MacroBlock includeMacroBlock2 = new MacroBlock(\"include\", includeOldParameters, false);\n        includeMacroBlock2.setParent(xdom);\n\n        Map<String, String> displayParameters = new HashMap<String, String>();\n        displayParameters.put(\"reference\", \"A.B\");\n        MacroBlock displayMacroBlock = new MacroBlock(\"display\", displayParameters, false);\n        displayMacroBlock.setParent(xdom);\n\n        when(xdom.getBlocks(any(), eq(Block.Axes.DESCENDANT)))\n            .thenReturn(List.of(includeMacroBlock1, includeMacroBlock2, displayMacroBlock));\n\n        ResourceReference macroResourceReference = new ResourceReference(\"A.B\", ResourceType.DOCUMENT);\n\n        when(this.resourceReferenceResolver.resolve(macroResourceReference, null))\n            .thenReturn(oldLinkTarget);\n        when(this.resourceReferenceResolver.resolve(macroResourceReference, null, documentReference))\n            .thenReturn(oldLinkTarget);\n        when(this.defaultReferenceDocumentReferenceResolver.resolve(oldLinkTarget)).thenReturn(oldLinkTarget);\n        when(this.compactEntityReferenceSerializer.serialize(newLinkTarget, documentReference)).thenReturn(\"X.Y\");\n\n        MacroRefactoring includeMacroRefactoring =\n            componentManager.registerMockComponent(MacroRefactoring.class, \"include\");\n        MacroRefactoring displayMacroRefactoring =\n            componentManager.registerMockComponent(MacroRefactoring.class, \"display\");\n        when(displayMacroRefactoring.replaceReference(any(), any(), any(DocumentReference.class), any(), anyBoolean()\n            , any()))\n            .thenReturn(Optional.of(displayMacroBlock));\n        when(this.documentAccessBridge.getDocumentInstance(documentReference)).thenReturn(document);\n        updater.update(documentReference, oldLinkTarget, newLinkTarget);\n\n        verify(includeMacroRefactoring).replaceReference(includeMacroBlock1, documentReference, oldLinkTarget,\n            newLinkTarget, false, Map.of(oldLinkTarget, newLinkTarget));\n        verify(includeMacroRefactoring).replaceReference(includeMacroBlock2, documentReference, oldLinkTarget,\n            newLinkTarget, false, Map.of(oldLinkTarget, newLinkTarget));\n        verify(displayMacroRefactoring).replaceReference(displayMacroBlock, documentReference, oldLinkTarget,\n            newLinkTarget, false, Map.of(oldLinkTarget, newLinkTarget));\n        verify(this.mutableRenderingContext, times(3)).push(any(), any(), eq(Syntax.XWIKI_2_1), any(), anyBoolean(),\n            any());\n        verify(this.mutableRenderingContext, times(3)).pop();\n        verifyDocumentSave(document, \"Renamed back-links.\", false, false);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "updateFromMacros",
        "raw_code": "@Test\n    void updateFromMacros(MockitoComponentManager componentManager) throws Exception\n    {\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        DocumentAuthors authors = mock(DocumentAuthors.class);\n        when(document.getAuthors()).thenReturn(authors);\n        when(this.xcontext.getWiki().getDocument(documentReference, this.xcontext)).thenReturn(document);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.getSyntax()).thenReturn(Syntax.XWIKI_2_1);\n\n        // From a terminal document to another terminal document.\n        DocumentReference oldLinkTarget = new DocumentReference(\"wiki\", \"A\", \"B\");\n        DocumentReference newLinkTarget = new DocumentReference(\"wiki\", \"X\", \"Y\");\n\n        XDOM xdom = mock(XDOM.class);\n        when(document.getXDOM()).thenReturn(xdom);\n\n        Map<String, String> includeParameters = new HashMap<String, String>();\n        includeParameters.put(\"reference\", \"A.B\");\n        MacroBlock includeMacroBlock1 = new MacroBlock(\"include\", includeParameters, false);\n        includeMacroBlock1.setParent(xdom);\n\n        Map<String, String> includeOldParameters = new HashMap<String, String>();\n        includeOldParameters.put(\"document\", \"A.B\");\n        MacroBlock includeMacroBlock2 = new MacroBlock(\"include\", includeOldParameters, false);\n        includeMacroBlock2.setParent(xdom);\n\n        Map<String, String> displayParameters = new HashMap<String, String>();\n        displayParameters.put(\"reference\", \"A.B\");\n        MacroBlock displayMacroBlock = new MacroBlock(\"display\", displayParameters, false);\n        displayMacroBlock.setParent(xdom);\n\n        when(xdom.getBlocks(any(), eq(Block.Axes.DESCENDANT)))\n            .thenReturn(List.of(includeMacroBlock1, includeMacroBlock2, displayMacroBlock));\n\n        ResourceReference macroResourceReference = new ResourceReference(\"A.B\", ResourceType.DOCUMENT);\n\n        when(this.resourceReferenceResolver.resolve(macroResourceReference, null))\n            .thenReturn(oldLinkTarget);\n        when(this.resourceReferenceResolver.resolve(macroResourceReference, null, documentReference))\n            .thenReturn(oldLinkTarget);\n        when(this.defaultReferenceDocumentReferenceResolver.resolve(oldLinkTarget)).thenReturn(oldLinkTarget);\n        when(this.compactEntityReferenceSerializer.serialize(newLinkTarget, documentReference)).thenReturn(\"X.Y\");\n\n        MacroRefactoring includeMacroRefactoring =\n            componentManager.registerMockComponent(MacroRefactoring.class, \"include\");\n        MacroRefactoring displayMacroRefactoring =\n            componentManager.registerMockComponent(MacroRefactoring.class, \"display\");\n        when(displayMacroRefactoring.replaceReference(any(), any(), any(DocumentReference.class), any(), anyBoolean()\n            , any()))\n            .thenReturn(Optional.of(displayMacroBlock));\n        when(this.documentAccessBridge.getDocumentInstance(documentReference)).thenReturn(document);\n        updater.update(documentReference, oldLinkTarget, newLinkTarget);\n\n        verify(includeMacroRefactoring).replaceReference(includeMacroBlock1, documentReference, oldLinkTarget,\n            newLinkTarget, false, Map.of(oldLinkTarget, newLinkTarget));\n        verify(includeMacroRefactoring).replaceReference(includeMacroBlock2, documentReference, oldLinkTarget,\n            newLinkTarget, false, Map.of(oldLinkTarget, newLinkTarget));\n        verify(displayMacroRefactoring).replaceReference(displayMacroBlock, documentReference, oldLinkTarget,\n            newLinkTarget, false, Map.of(oldLinkTarget, newLinkTarget));\n        verify(this.mutableRenderingContext, times(3)).push(any(), any(), eq(Syntax.XWIKI_2_1), any(), anyBoolean(),\n            any());\n        verify(this.mutableRenderingContext, times(3)).pop();\n        verifyDocumentSave(document, false);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49580",
    "cwe_list": [
      "CWE-266"
    ],
    "commit_hash": "ab209acd780da69a4c5ff77ff011efd698273cec",
    "short_hash": "ab209acd",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "updateAttachments",
        "raw_code": "@Test\n    void updateAttachments() throws Exception\n    {\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        DocumentReference sourceDocument = new DocumentReference(\"wiki\", \"Space\", \"Source\");\n        AttachmentReference oldLinkTarget = new AttachmentReference(\"oldname.txt\", sourceDocument);\n        DocumentReference targetDocument = new DocumentReference(\"wiki\", \"Space\", \"Target\");\n        AttachmentReference newLinkTarget = new AttachmentReference(\"newname.txt\", targetDocument);\n        ResourceReference resourceReference = new ResourceReference(\"oldname.txt\", ResourceType.ATTACHMENT);\n        LinkBlock documentLinkBlock = new LinkBlock(List.of(), resourceReference, false);\n\n        XWikiDocument document = mock(XWikiDocument.class);\n        XDOM xdom = mock(XDOM.class);\n\n        when(this.xcontext.getWiki().getDocument(documentReference, this.xcontext)).thenReturn(document);\n        when(document.getTranslationLocales(this.xcontext)).thenReturn(List.of());\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.getSyntax()).thenReturn(Syntax.XWIKI_2_1);\n        when(document.getXDOM()).thenReturn(xdom);\n        when(xdom.getBlocks(any(), eq(Block.Axes.DESCENDANT))).thenReturn(List.of(documentLinkBlock));\n        when(this.resourceReferenceResolver.resolve(resourceReference, null)).thenReturn(\n            new AttachmentReference(\"oldname.txt\", new DocumentReference(\"wiki\", \"Main\", \"WebHome\")));\n        when(this.resourceReferenceResolver.resolve(resourceReference, null, documentReference)).thenReturn(\n            oldLinkTarget);\n        when(this.compactEntityReferenceSerializer.serialize(newLinkTarget, documentReference)).thenReturn(\n            \"newname.txt\");\n\n        updater.update(documentReference, oldLinkTarget, newLinkTarget);\n\n        verify(this.progressManager).pushLevelProgress(1, updater);\n        verify(document).setContent(xdom);\n        verify(document).setContentDirty(false);\n        verify(document).setMetaDataDirty(true);\n        verify(this.xcontext.getWiki()).saveDocument(document, \"Renamed back-links.\", false, this.xcontext);\n        verify(this.progressManager).popLevelProgress(updater);\n        assertEquals(1, this.logCapture.size());\n        assertEquals(\n            \"The links from [null] that were targeting [Attachment wiki:Space.Source@oldname.txt] have \"\n                + \"been updated to target [Attachment wiki:Space.Target@newname.txt].\", this.logCapture.getMessage(0));\n        assertEquals(Level.INFO, this.logCapture.getLogEvent(0).getLevel());\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "updateAttachments",
        "raw_code": "@Test\n    void updateAttachments() throws Exception\n    {\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        DocumentReference sourceDocument = new DocumentReference(\"wiki\", \"Space\", \"Source\");\n        AttachmentReference oldLinkTarget = new AttachmentReference(\"oldname.txt\", sourceDocument);\n        DocumentReference targetDocument = new DocumentReference(\"wiki\", \"Space\", \"Target\");\n        AttachmentReference newLinkTarget = new AttachmentReference(\"newname.txt\", targetDocument);\n        ResourceReference resourceReference = new ResourceReference(\"oldname.txt\", ResourceType.ATTACHMENT);\n        LinkBlock documentLinkBlock = new LinkBlock(List.of(), resourceReference, false);\n\n        XWikiDocument document = mock(XWikiDocument.class);\n        DocumentAuthors authors = mock(DocumentAuthors.class);\n        when(document.getAuthors()).thenReturn(authors);\n        XDOM xdom = mock(XDOM.class);\n\n        when(this.xcontext.getWiki().getDocument(documentReference, this.xcontext)).thenReturn(document);\n        when(document.getTranslationLocales(this.xcontext)).thenReturn(List.of());\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.getSyntax()).thenReturn(Syntax.XWIKI_2_1);\n        when(document.getXDOM()).thenReturn(xdom);\n        when(xdom.getBlocks(any(), eq(Block.Axes.DESCENDANT))).thenReturn(List.of(documentLinkBlock));\n        when(this.resourceReferenceResolver.resolve(resourceReference, null)).thenReturn(\n            new AttachmentReference(\"oldname.txt\", new DocumentReference(\"wiki\", \"Main\", \"WebHome\")));\n        when(this.resourceReferenceResolver.resolve(resourceReference, null, documentReference)).thenReturn(\n            oldLinkTarget);\n        when(this.compactEntityReferenceSerializer.serialize(newLinkTarget, documentReference)).thenReturn(\n            \"newname.txt\");\n\n        updater.update(documentReference, oldLinkTarget, newLinkTarget);\n\n        verify(this.progressManager).pushLevelProgress(1, updater);\n        verifyDocumentSave(document, false);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49580",
    "cwe_list": [
      "CWE-266"
    ],
    "commit_hash": "ab209acd780da69a4c5ff77ff011efd698273cec",
    "short_hash": "ab209acd",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "updateFromLinksAndMacros",
        "raw_code": "@Test\n    void updateFromLinksAndMacros(MockitoComponentManager componentManager) throws Exception\n    {\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        when(this.xcontext.getWiki().getDocument(documentReference, this.xcontext)).thenReturn(document);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.getSyntax()).thenReturn(Syntax.XWIKI_2_1);\n\n        // From a terminal document to another terminal document.\n        DocumentReference oldLinkTarget = new DocumentReference(\"wiki\", \"A\", \"B\");\n        DocumentReference newLinkTarget = new DocumentReference(\"wiki\", \"X\", \"Y\");\n\n        XDOM xdom = mock(XDOM.class);\n        when(document.getXDOM()).thenReturn(xdom);\n\n        Map<String, String> includeParameters = new HashMap<>();\n        includeParameters.put(\"reference\", \"A.B\");\n        MacroBlock includeMacroBlock = new MacroBlock(\"include\", includeParameters, false);\n\n        ResourceReference resourceReference = new ResourceReference(\"A.B\", ResourceType.DOCUMENT);\n        LinkBlock documentLinkBlock = new LinkBlock(List.of(), resourceReference, false);\n        EntityReference relativeReference = new EntityReference(\"B\", EntityType.DOCUMENT,\n            new EntityReference(\"A\", EntityType.SPACE));\n\n        when(xdom.getBlocks(any(), eq(Block.Axes.DESCENDANT)))\n            .thenReturn(List.of(includeMacroBlock, documentLinkBlock));\n\n        when(this.resourceReferenceResolver.resolve(resourceReference, null))\n            .thenReturn(oldLinkTarget);\n        when(this.resourceReferenceResolver.resolve(resourceReference, null, documentReference))\n            .thenReturn(oldLinkTarget);\n        when(this.defaultReferenceDocumentReferenceResolver.resolve(oldLinkTarget)).thenReturn(oldLinkTarget);\n        when(this.compactEntityReferenceSerializer.serialize(newLinkTarget, documentReference)).thenReturn(\"X.Y\");\n        when(this.relativeEntityReferenceResolver.resolve(resourceReference, null, null)).thenReturn(relativeReference);\n\n        MacroRefactoring includeMacroRefactoring =\n            componentManager.registerMockComponent(MacroRefactoring.class, \"include\");\n        when(this.documentAccessBridge.getDocumentInstance(documentReference)).thenReturn(document);\n        updater.update(documentReference, oldLinkTarget, newLinkTarget);\n\n        verify(includeMacroRefactoring).replaceReference(includeMacroBlock, documentReference, oldLinkTarget,\n            newLinkTarget, false, Map.of(oldLinkTarget, newLinkTarget));\n        assertEquals(\"X.Y\", documentLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.DOCUMENT, documentLinkBlock.getReference().getType());\n        verifyDocumentSave(document, \"Renamed back-links.\", false, false);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "updateFromLinksAndMacros",
        "raw_code": "@Test\n    void updateFromLinksAndMacros(MockitoComponentManager componentManager) throws Exception\n    {\n        DocumentReference documentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        XWikiDocument document = mock(XWikiDocument.class);\n        DocumentAuthors authors = mock(DocumentAuthors.class);\n        when(document.getAuthors()).thenReturn(authors);\n        when(this.xcontext.getWiki().getDocument(documentReference, this.xcontext)).thenReturn(document);\n        when(document.getDocumentReference()).thenReturn(documentReference);\n        when(document.getSyntax()).thenReturn(Syntax.XWIKI_2_1);\n\n        // From a terminal document to another terminal document.\n        DocumentReference oldLinkTarget = new DocumentReference(\"wiki\", \"A\", \"B\");\n        DocumentReference newLinkTarget = new DocumentReference(\"wiki\", \"X\", \"Y\");\n\n        XDOM xdom = mock(XDOM.class);\n        when(document.getXDOM()).thenReturn(xdom);\n\n        Map<String, String> includeParameters = new HashMap<>();\n        includeParameters.put(\"reference\", \"A.B\");\n        MacroBlock includeMacroBlock = new MacroBlock(\"include\", includeParameters, false);\n\n        ResourceReference resourceReference = new ResourceReference(\"A.B\", ResourceType.DOCUMENT);\n        LinkBlock documentLinkBlock = new LinkBlock(List.of(), resourceReference, false);\n        EntityReference relativeReference = new EntityReference(\"B\", EntityType.DOCUMENT,\n            new EntityReference(\"A\", EntityType.SPACE));\n\n        when(xdom.getBlocks(any(), eq(Block.Axes.DESCENDANT)))\n            .thenReturn(List.of(includeMacroBlock, documentLinkBlock));\n\n        when(this.resourceReferenceResolver.resolve(resourceReference, null))\n            .thenReturn(oldLinkTarget);\n        when(this.resourceReferenceResolver.resolve(resourceReference, null, documentReference))\n            .thenReturn(oldLinkTarget);\n        when(this.defaultReferenceDocumentReferenceResolver.resolve(oldLinkTarget)).thenReturn(oldLinkTarget);\n        when(this.compactEntityReferenceSerializer.serialize(newLinkTarget, documentReference)).thenReturn(\"X.Y\");\n        when(this.relativeEntityReferenceResolver.resolve(resourceReference, null, null)).thenReturn(relativeReference);\n\n        MacroRefactoring includeMacroRefactoring =\n            componentManager.registerMockComponent(MacroRefactoring.class, \"include\");\n        when(this.documentAccessBridge.getDocumentInstance(documentReference)).thenReturn(document);\n        updater.update(documentReference, oldLinkTarget, newLinkTarget);\n\n        verify(includeMacroRefactoring).replaceReference(includeMacroBlock, documentReference, oldLinkTarget,\n            newLinkTarget, false, Map.of(oldLinkTarget, newLinkTarget));\n        assertEquals(\"X.Y\", documentLinkBlock.getReference().getReference());\n        assertEquals(ResourceType.DOCUMENT, documentLinkBlock.getReference().getType());\n        verifyDocumentSave(document, false);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49580",
    "cwe_list": [
      "CWE-266"
    ],
    "commit_hash": "ab209acd780da69a4c5ff77ff011efd698273cec",
    "short_hash": "ab209acd",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "verifyDocumentSave",
        "raw_code": "private void verifyDocumentSave(XWikiDocument document, String comment, boolean minorEdit, boolean relative)\n        throws Exception\n    {\n        // Verify we preserve the content author.\n        verify(document).setContentDirty(false);\n        // Verify the version is going to be incremented.\n        verify(document).setMetaDataDirty(true);\n        verify(this.xcontext.getWiki()).saveDocument(document, comment, minorEdit, this.xcontext);\n        ILoggingEvent logEvent = this.logCapture.getLogEvent(this.logIndex++);\n        if (relative) {\n            assertEquals(\"Updated the relative links from [{}].\", logEvent.getMessage());\n        } else {\n            assertEquals(\"The links from [{}] that were targeting [{}] have been updated to target [{}].\",\n                logEvent.getMessage());\n        }\n        assertEquals(Level.INFO, logEvent.getLevel());\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "verifyDocumentSave",
        "raw_code": "private void verifyDocumentSave(XWikiDocument document, boolean relative)\n        throws Exception\n    {\n        // Verify we preserve the content author.\n        verify(document).setContentDirty(false);\n        // Verify the version is going to be incremented.\n        verify(document).setMetaDataDirty(true);\n        String comment = (relative) ? TRANSLATED_RELATIVE_COMMENT : TRANSLATED_BACKLINK_COMMENT;\n        verify(this.xcontext.getWiki()).saveDocument(document, comment, true, this.xcontext);\n        verify(document.getAuthors()).setOriginalMetadataAuthor(currentUserReference);\n        ILoggingEvent logEvent = this.logCapture.getLogEvent(this.logIndex++);\n        if (relative) {\n            assertEquals(\"Updated the relative links from [{}].\", logEvent.getMessage());\n        } else {\n            assertEquals(\"The links from [{}] that were targeting [{}] have been updated to target [{}].\",\n                logEvent.getMessage());\n        }\n        assertEquals(Level.INFO, logEvent.getLevel());\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49580",
    "cwe_list": [
      "CWE-266"
    ],
    "commit_hash": "ab209acd780da69a4c5ff77ff011efd698273cec",
    "short_hash": "ab209acd",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "updateAndTranslations",
        "raw_code": "@Test\n    void updateAndTranslations() throws Exception\n    {\n        DocumentReference baseDocumentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        XWikiDocument baseDocument = mock(XWikiDocument.class);\n        when(this.xcontext.getWiki().getDocument(baseDocumentReference, this.xcontext)).thenReturn(baseDocument);\n        when(baseDocument.getDocumentReference()).thenReturn(baseDocumentReference);\n\n        when(baseDocument.getTranslationLocales(xcontext)).thenReturn(List.of(Locale.FRENCH, Locale.ENGLISH));\n        DocumentReference frenchDocumentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\", Locale.FRENCH);\n        XWikiDocument frenchDocument = mock(XWikiDocument.class);\n        when(baseDocument.getTranslatedDocument(Locale.FRENCH, xcontext)).thenReturn(frenchDocument);\n        when(frenchDocument.getDocumentReference()).thenReturn(frenchDocumentReference);\n\n        DocumentReference englishDocumentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\", Locale.ENGLISH);\n        XWikiDocument englishDocument = mock(XWikiDocument.class);\n        when(baseDocument.getTranslatedDocument(Locale.ENGLISH, xcontext)).thenReturn(englishDocument);\n        when(englishDocument.getDocumentReference()).thenReturn(englishDocumentReference);\n\n        // From a terminal document to another terminal document.\n        DocumentReference oldLinkTarget = new DocumentReference(\"wiki\", \"A\", \"B\");\n        DocumentReference newLinkTarget = new DocumentReference(\"wiki\", \"X\", \"Y\");\n\n        List<XWikiDocument> documentsToUpdate = List.of(baseDocument, frenchDocument, englishDocument);\n\n        for (XWikiDocument xWikiDocument : documentsToUpdate) {\n            DocumentReference documentReference = xWikiDocument.getDocumentReference();\n            when(xWikiDocument.getSyntax()).thenReturn(Syntax.XWIKI_2_1);\n            XDOM xdom = mock(XDOM.class);\n            when(xWikiDocument.getXDOM()).thenReturn(xdom);\n\n            ResourceReference linkReference = new ResourceReference(\"A.B\", ResourceType.DOCUMENT);\n            EntityReference relativeReference = new EntityReference(\"B\", EntityType.DOCUMENT,\n                new EntityReference(\"A\", EntityType.SPACE));\n            LinkBlock linkBlock = new LinkBlock(List.of(), linkReference, false);\n            when(xdom.getBlocks(any(), eq(Block.Axes.DESCENDANT))).thenReturn(List.of(linkBlock));\n\n            when(this.resourceReferenceResolver.resolve(linkReference, null))\n                .thenReturn(oldLinkTarget);\n            when(this.resourceReferenceResolver.resolve(linkReference, null, documentReference))\n                .thenReturn(oldLinkTarget);\n            when(this.defaultReferenceDocumentReferenceResolver.resolve(oldLinkTarget)).thenReturn(oldLinkTarget);\n            when(this.compactEntityReferenceSerializer.serialize(newLinkTarget, documentReference)).thenReturn(\"X.Y\");\n            when(this.relativeEntityReferenceResolver.resolve(linkReference, null, null))\n                .thenReturn(relativeReference);\n        }\n        updater.update(baseDocumentReference, oldLinkTarget, newLinkTarget);\n\n        for (XWikiDocument xWikiDocument : documentsToUpdate) {\n            verifyDocumentSave(xWikiDocument, \"Renamed back-links.\", false, false);\n            LinkBlock linkBlock =\n                (LinkBlock) xWikiDocument.getXDOM().getBlocks(mock(BlockMatcher.class), Block.Axes.DESCENDANT).get(0);\n            assertEquals(\"X.Y\", linkBlock.getReference().getReference());\n            assertEquals(ResourceType.DOCUMENT, linkBlock.getReference().getType());\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultReferenceUpdaterTest.java",
        "method_name": "updateAndTranslations",
        "raw_code": "@Test\n    void updateAndTranslations() throws Exception\n    {\n        DocumentReference baseDocumentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\");\n        XWikiDocument baseDocument = mock(XWikiDocument.class);\n        DocumentAuthors baseAuthors = mock(DocumentAuthors.class);\n        when(baseDocument.getAuthors()).thenReturn(baseAuthors);\n        when(this.xcontext.getWiki().getDocument(baseDocumentReference, this.xcontext)).thenReturn(baseDocument);\n        when(baseDocument.getDocumentReference()).thenReturn(baseDocumentReference);\n\n        when(baseDocument.getTranslationLocales(xcontext)).thenReturn(List.of(Locale.FRENCH, Locale.ENGLISH));\n        DocumentReference frenchDocumentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\", Locale.FRENCH);\n        XWikiDocument frenchDocument = mock(XWikiDocument.class);\n        DocumentAuthors frenchAuthors = mock(DocumentAuthors.class);\n        when(frenchDocument.getAuthors()).thenReturn(frenchAuthors);\n        when(baseDocument.getTranslatedDocument(Locale.FRENCH, xcontext)).thenReturn(frenchDocument);\n        when(frenchDocument.getDocumentReference()).thenReturn(frenchDocumentReference);\n\n        DocumentReference englishDocumentReference = new DocumentReference(\"wiki\", \"Space\", \"Page\", Locale.ENGLISH);\n        XWikiDocument englishDocument = mock(XWikiDocument.class);\n        DocumentAuthors englishAuthors = mock(DocumentAuthors.class);\n        when(englishDocument.getAuthors()).thenReturn(englishAuthors);\n        when(baseDocument.getTranslatedDocument(Locale.ENGLISH, xcontext)).thenReturn(englishDocument);\n        when(englishDocument.getDocumentReference()).thenReturn(englishDocumentReference);\n\n        // From a terminal document to another terminal document.\n        DocumentReference oldLinkTarget = new DocumentReference(\"wiki\", \"A\", \"B\");\n        DocumentReference newLinkTarget = new DocumentReference(\"wiki\", \"X\", \"Y\");\n\n        List<XWikiDocument> documentsToUpdate = List.of(baseDocument, frenchDocument, englishDocument);\n\n        for (XWikiDocument xWikiDocument : documentsToUpdate) {\n            DocumentReference documentReference = xWikiDocument.getDocumentReference();\n            when(xWikiDocument.getSyntax()).thenReturn(Syntax.XWIKI_2_1);\n            XDOM xdom = mock(XDOM.class);\n            when(xWikiDocument.getXDOM()).thenReturn(xdom);\n\n            ResourceReference linkReference = new ResourceReference(\"A.B\", ResourceType.DOCUMENT);\n            EntityReference relativeReference = new EntityReference(\"B\", EntityType.DOCUMENT,\n                new EntityReference(\"A\", EntityType.SPACE));\n            LinkBlock linkBlock = new LinkBlock(List.of(), linkReference, false);\n            when(xdom.getBlocks(any(), eq(Block.Axes.DESCENDANT))).thenReturn(List.of(linkBlock));\n\n            when(this.resourceReferenceResolver.resolve(linkReference, null))\n                .thenReturn(oldLinkTarget);\n            when(this.resourceReferenceResolver.resolve(linkReference, null, documentReference))\n                .thenReturn(oldLinkTarget);\n            when(this.defaultReferenceDocumentReferenceResolver.resolve(oldLinkTarget)).thenReturn(oldLinkTarget);\n            when(this.compactEntityReferenceSerializer.serialize(newLinkTarget, documentReference)).thenReturn(\"X.Y\");\n            when(this.relativeEntityReferenceResolver.resolve(linkReference, null, null))\n                .thenReturn(relativeReference);\n        }\n        updater.update(baseDocumentReference, oldLinkTarget, newLinkTarget);\n\n        for (XWikiDocument xWikiDocument : documentsToUpdate) {\n            verifyDocumentSave(xWikiDocument, false);\n            LinkBlock linkBlock =\n                (LinkBlock) xWikiDocument.getXDOM().getBlocks(mock(BlockMatcher.class), Block.Axes.DESCENDANT).get(0);\n            assertEquals(\"X.Y\", linkBlock.getReference().getReference());\n            assertEquals(ResourceType.DOCUMENT, linkBlock.getReference().getType());\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "s3proxy",
    "cve_id": "CVE-2025-24961",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "86b6ee4749aa163a78e7898efc063617ed171980",
    "short_hash": "86b6ee47",
    "vulnerableMethods_before": [
      {
        "filename": "AbstractNio2BlobStore.java",
        "method_name": "list",
        "raw_code": "@Override\n    public final PageSet<? extends StorageMetadata> list(String container,\n            ListContainerOptions options) {\n        if (!containerExists(container)) {\n            throw new ContainerNotFoundException(container, \"\");\n        }\n\n        var delimiter = options.getDelimiter();\n        if (\"\".equals(delimiter)) {\n            delimiter = null;\n        } else if (delimiter != null && !delimiter.equals(\"/\")) {\n            throw new IllegalArgumentException(\"Delimiters other than / not supported\");\n        }\n\n        var prefix = options.getPrefix();\n        var dirPrefix = root.resolve(container);\n        if (prefix != null) {\n            int idx = prefix.lastIndexOf('/');\n            if (idx != -1) {\n                dirPrefix = dirPrefix.resolve(prefix.substring(0, idx));\n            }\n        } else {\n            prefix = \"\";\n        }\n        var pathPrefix = root.resolve(container).resolve(prefix);\n        var set = ImmutableSortedSet.<StorageMetadata>naturalOrder();\n        try {\n            listHelper(set, container, dirPrefix, pathPrefix, delimiter);\n            var sorted = set.build();\n            if (options.getMarker() != null) {\n                var found = false;\n                for (var blob : sorted) {\n                    if (blob.getName().compareTo(options.getMarker()) > 0) {\n                        sorted = sorted.tailSet(blob);\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    sorted = ImmutableSortedSet.of();\n                }\n            }\n            String marker = null;\n            if (options.getMaxResults() != null) {\n                // TODO: efficiency?\n                var temp = ImmutableSortedSet.copyOf(sorted.stream().limit(options.getMaxResults().intValue()).collect(Collectors.toSet()));\n                if (!temp.isEmpty()) {\n                    var next = sorted.higher(temp.last());\n                    if (next != null) {\n                        marker = temp.last().getName();\n                    }\n                }\n                sorted = temp;\n            }\n            return new PageSetImpl<StorageMetadata>(sorted, marker);\n        } catch (IOException ioe) {\n            logger.error(\"unexpected exception\", ioe);\n            throw new RuntimeException(ioe);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AbstractNio2BlobStore.java",
        "method_name": "list",
        "raw_code": "@Override\n    public final PageSet<? extends StorageMetadata> list(String container,\n            ListContainerOptions options) {\n        if (!containerExists(container)) {\n            throw new ContainerNotFoundException(container, \"\");\n        }\n\n        var delimiter = options.getDelimiter();\n        if (\"\".equals(delimiter)) {\n            delimiter = null;\n        } else if (delimiter != null && !delimiter.equals(\"/\")) {\n            throw new IllegalArgumentException(\"Delimiters other than / not supported\");\n        }\n\n        var prefix = options.getPrefix();\n        var dirPrefix = root.resolve(container);\n        if (prefix != null) {\n            int idx = prefix.lastIndexOf('/');\n            if (idx != -1) {\n                dirPrefix = dirPrefix.resolve(prefix.substring(0, idx));\n            }\n        } else {\n            prefix = \"\";\n        }\n        var containerPath = root.resolve(container);\n        var pathPrefix = containerPath.resolve(prefix).normalize();\n        checkValidPath(containerPath, pathPrefix);\n        logger.debug(\"Listing blobs at: {}\", pathPrefix);\n        var set = ImmutableSortedSet.<StorageMetadata>naturalOrder();\n        try {\n            listHelper(set, container, dirPrefix, pathPrefix, delimiter);\n            var sorted = set.build();\n            if (options.getMarker() != null) {\n                var found = false;\n                for (var blob : sorted) {\n                    if (blob.getName().compareTo(options.getMarker()) > 0) {\n                        sorted = sorted.tailSet(blob);\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    sorted = ImmutableSortedSet.of();\n                }\n            }\n            String marker = null;\n            if (options.getMaxResults() != null) {\n                // TODO: efficiency?\n                var temp = ImmutableSortedSet.copyOf(sorted.stream().limit(options.getMaxResults().intValue()).collect(Collectors.toSet()));\n                if (!temp.isEmpty()) {\n                    var next = sorted.higher(temp.last());\n                    if (next != null) {\n                        marker = temp.last().getName();\n                    }\n                }\n                sorted = temp;\n            }\n            return new PageSetImpl<StorageMetadata>(sorted, marker);\n        } catch (IOException ioe) {\n            logger.error(\"unexpected exception\", ioe);\n            throw new RuntimeException(ioe);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "s3proxy",
    "cve_id": "CVE-2025-24961",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "86b6ee4749aa163a78e7898efc063617ed171980",
    "short_hash": "86b6ee47",
    "vulnerableMethods_before": [
      {
        "filename": "AbstractNio2BlobStore.java",
        "method_name": "getBlob",
        "raw_code": "@Override\n    public final Blob getBlob(String container, String key, GetOptions options) {\n        if (!containerExists(container)) {\n            throw new ContainerNotFoundException(container, \"\");\n        }\n\n        var path = root.resolve(container).resolve(key);\n        logger.debug(\"Getting blob at: {}\", path);\n\n        try {\n            var isDirectory = Files.isDirectory(path);\n            var attr = Files.readAttributes(path, BasicFileAttributes.class);\n            var view = Files.getFileAttributeView(path, UserDefinedFileAttributeView.class);\n            var attributes = Set.copyOf(view.list());\n            var cacheControl = readStringAttributeIfPresent(view, attributes, XATTR_CACHE_CONTROL);\n            var contentDisposition = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_DISPOSITION);\n            var contentEncoding = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_ENCODING);\n            var contentLanguage = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_LANGUAGE);\n            var contentType = isDirectory ? \"application/x-directory\" :\n                    readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_TYPE);\n            Date expires = null;\n            HashCode hashCode = null;\n            String eTag = null;\n            var tier = Tier.STANDARD;\n            var userMetadata = ImmutableMap.<String, String>builder();\n            var lastModifiedTime = new Date(attr.lastModifiedTime().toMillis());\n            var creationTime = new Date(attr.creationTime().toMillis());\n\n            if (isDirectory) {\n                if (!attributes.contains(XATTR_CONTENT_MD5)) {\n                    // Lacks directory marker -- implicit directory.\n                    return null;\n                }\n            } else if (attributes.contains(XATTR_CONTENT_MD5)) {\n                var buf = ByteBuffer.allocate(view.size(XATTR_CONTENT_MD5));\n                view.read(XATTR_CONTENT_MD5, buf);\n                var etagBytes = buf.array();\n                if (etagBytes.length == 16) {\n                    // regular object\n                    hashCode = HashCode.fromBytes(buf.array());\n                    eTag = \"\\\"\" + hashCode + \"\\\"\";\n                } else {\n                    // multi-part object\n                    eTag = new String(etagBytes, StandardCharsets.US_ASCII);\n                }\n            }\n            if (attributes.contains(XATTR_EXPIRES)) {\n                ByteBuffer buf = ByteBuffer.allocate(view.size(XATTR_EXPIRES));\n                view.read(XATTR_EXPIRES, buf);\n                buf.flip();\n                expires = new Date(buf.asLongBuffer().get());\n            }\n            var tierString = readStringAttributeIfPresent(view, attributes, XATTR_STORAGE_TIER);\n            if (tierString != null) {\n                tier = Tier.valueOf(tierString);\n            }\n            for (String attribute : attributes) {\n                if (!attribute.startsWith(XATTR_USER_METADATA_PREFIX)) {\n                    continue;\n                }\n                var value = readStringAttributeIfPresent(view, attributes, attribute);\n                userMetadata.put(attribute.substring(XATTR_USER_METADATA_PREFIX.length()), value);\n            }\n\n            // Handle range.\n            String contentRange = null;\n            InputStream inputStream;\n            long size;\n            if (isDirectory) {\n                inputStream = ByteSource.empty().openStream();\n                size = 0;\n            } else {\n                inputStream = Files.newInputStream(path);  // TODO: leaky on exception\n                size = attr.size();\n                if (options.getRanges().size() > 0) {\n                    var range = options.getRanges().get(0);\n                    // HTTP uses a closed interval while Java array indexing uses a\n                    // half-open interval.\n                    long offset = 0;\n                    long last = size;\n                    if (range.startsWith(\"-\")) {\n                        offset = last - Long.parseLong(range.substring(1));\n                        if (offset < 0) {\n                            offset = 0;\n                        }\n                    } else if (range.endsWith(\"-\")) {\n                        offset = Long.parseLong(range.substring(0, range.length() - 1));\n                    } else if (range.contains(\"-\")) {\n                        String[] firstLast = range.split(\"\\\\-\", 2);\n                        offset = Long.parseLong(firstLast[0]);\n                        last = Long.parseLong(firstLast[1]);\n                    } else {\n                        throw new HttpResponseException(\"illegal range: \" + range, null, HttpResponse.builder().statusCode(416).build());\n                    }\n\n                    if (offset >= size) {\n                        throw new HttpResponseException(\"illegal range: \" + range, null, HttpResponse.builder().statusCode(416).build());\n                    }\n                    if (last + 1 > size) {\n                        last = size - 1;\n                    }\n                    ByteStreams.skipFully(inputStream, offset);\n                    size = last - offset + 1;\n                    inputStream = ByteStreams.limit(inputStream, size);\n                    contentRange = \"bytes \" + offset + \"-\" + last + \"/\" + attr.size();\n                }\n            }\n\n            if (eTag != null) {\n                eTag = maybeQuoteETag(eTag);\n                if (options.getIfMatch() != null) {\n                    if (!eTag.equals(maybeQuoteETag(options.getIfMatch()))) {\n                        HttpResponse response = HttpResponse.builder().statusCode(Status.PRECONDITION_FAILED.getStatusCode()).addHeader(HttpHeaders.ETAG, eTag).build();\n                        throw new HttpResponseException(new HttpCommand(HttpRequest.builder().method(\"GET\").endpoint(\"http://stub\").build()), response);\n                    }\n                }\n                if (options.getIfNoneMatch() != null) {\n                    if (eTag.equals(maybeQuoteETag(options.getIfNoneMatch()))) {\n                        HttpResponse response = HttpResponse.builder().statusCode(Status.NOT_MODIFIED.getStatusCode()).addHeader(HttpHeaders.ETAG, eTag).build();\n                        throw new HttpResponseException(new HttpCommand(HttpRequest.builder().method(\"GET\").endpoint(\"http://stub\").build()), response);\n                    }\n                }\n            }\n            if (options.getIfModifiedSince() != null) {\n                Date modifiedSince = options.getIfModifiedSince();\n                if (lastModifiedTime.before(modifiedSince)) {\n                    HttpResponse.Builder response = HttpResponse.builder().statusCode(Status.NOT_MODIFIED.getStatusCode());\n                    if (eTag != null) {\n                        response.addHeader(HttpHeaders.ETAG, eTag);\n                    }\n                    throw new HttpResponseException(String.format(\"%1$s is before %2$s\", lastModifiedTime, modifiedSince), null, response.build());\n                }\n\n            }\n            if (options.getIfUnmodifiedSince() != null) {\n                Date unmodifiedSince = options.getIfUnmodifiedSince();\n                if (lastModifiedTime.after(unmodifiedSince)) {\n                    HttpResponse.Builder response = HttpResponse.builder().statusCode(Status.PRECONDITION_FAILED.getStatusCode());\n                    if (eTag != null) {\n                        response.addHeader(HttpHeaders.ETAG, eTag);\n                    }\n                    throw new HttpResponseException(String.format(\"%1$s is after %2$s\", lastModifiedTime, unmodifiedSince), null, response.build());\n                }\n            }\n\n            Blob blob = new BlobBuilderImpl()\n                    .type(isDirectory ? StorageType.FOLDER : StorageType.BLOB)\n                    .name(key)\n                    .userMetadata(userMetadata.build())\n                    .payload(inputStream)\n                    .cacheControl(cacheControl)\n                    .contentDisposition(contentDisposition)\n                    .contentEncoding(contentEncoding)\n                    .contentLanguage(contentLanguage)\n                    .contentLength(size)\n                    .contentMD5(hashCode)\n                    .contentType(contentType)\n                    .eTag(eTag)\n                    .expires(expires)\n                    .tier(tier)\n                    .build();\n            blob.getMetadata().setContainer(container);\n            blob.getMetadata().setCreationDate(creationTime);\n            blob.getMetadata().setLastModified(lastModifiedTime);\n            blob.getMetadata().setSize(size);\n            if (contentRange != null) {\n                blob.getAllHeaders().put(HttpHeaders.CONTENT_RANGE, contentRange);\n            }\n            if (hashCode != null) {\n                blob.getMetadata().setETag(BaseEncoding.base16().lowerCase().encode(hashCode.asBytes()));\n            }\n            return blob;\n        } catch (NoSuchFileException nsfe) {\n            return null;\n        } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AbstractNio2BlobStore.java",
        "method_name": "getBlob",
        "raw_code": "@Override\n    public final Blob getBlob(String container, String key, GetOptions options) {\n        if (!containerExists(container)) {\n            throw new ContainerNotFoundException(container, \"\");\n        }\n\n        var containerPath = root.resolve(container);\n        var path = containerPath.resolve(key);\n        checkValidPath(containerPath, path);\n        logger.debug(\"Getting blob at: {}\", path);\n\n        try {\n            var isDirectory = Files.isDirectory(path);\n            var attr = Files.readAttributes(path, BasicFileAttributes.class);\n            var view = Files.getFileAttributeView(path, UserDefinedFileAttributeView.class);\n            var attributes = Set.copyOf(view.list());\n            var cacheControl = readStringAttributeIfPresent(view, attributes, XATTR_CACHE_CONTROL);\n            var contentDisposition = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_DISPOSITION);\n            var contentEncoding = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_ENCODING);\n            var contentLanguage = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_LANGUAGE);\n            var contentType = isDirectory ? \"application/x-directory\" :\n                    readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_TYPE);\n            Date expires = null;\n            HashCode hashCode = null;\n            String eTag = null;\n            var tier = Tier.STANDARD;\n            var userMetadata = ImmutableMap.<String, String>builder();\n            var lastModifiedTime = new Date(attr.lastModifiedTime().toMillis());\n            var creationTime = new Date(attr.creationTime().toMillis());\n\n            if (isDirectory) {\n                if (!attributes.contains(XATTR_CONTENT_MD5)) {\n                    // Lacks directory marker -- implicit directory.\n                    return null;\n                }\n            } else if (attributes.contains(XATTR_CONTENT_MD5)) {\n                var buf = ByteBuffer.allocate(view.size(XATTR_CONTENT_MD5));\n                view.read(XATTR_CONTENT_MD5, buf);\n                var etagBytes = buf.array();\n                if (etagBytes.length == 16) {\n                    // regular object\n                    hashCode = HashCode.fromBytes(buf.array());\n                    eTag = \"\\\"\" + hashCode + \"\\\"\";\n                } else {\n                    // multi-part object\n                    eTag = new String(etagBytes, StandardCharsets.US_ASCII);\n                }\n            }\n            if (attributes.contains(XATTR_EXPIRES)) {\n                ByteBuffer buf = ByteBuffer.allocate(view.size(XATTR_EXPIRES));\n                view.read(XATTR_EXPIRES, buf);\n                buf.flip();\n                expires = new Date(buf.asLongBuffer().get());\n            }\n            var tierString = readStringAttributeIfPresent(view, attributes, XATTR_STORAGE_TIER);\n            if (tierString != null) {\n                tier = Tier.valueOf(tierString);\n            }\n            for (String attribute : attributes) {\n                if (!attribute.startsWith(XATTR_USER_METADATA_PREFIX)) {\n                    continue;\n                }\n                var value = readStringAttributeIfPresent(view, attributes, attribute);\n                userMetadata.put(attribute.substring(XATTR_USER_METADATA_PREFIX.length()), value);\n            }\n\n            // Handle range.\n            String contentRange = null;\n            InputStream inputStream;\n            long size;\n            if (isDirectory) {\n                inputStream = ByteSource.empty().openStream();\n                size = 0;\n            } else {\n                inputStream = Files.newInputStream(path);  // TODO: leaky on exception\n                size = attr.size();\n                if (options.getRanges().size() > 0) {\n                    var range = options.getRanges().get(0);\n                    // HTTP uses a closed interval while Java array indexing uses a\n                    // half-open interval.\n                    long offset = 0;\n                    long last = size;\n                    if (range.startsWith(\"-\")) {\n                        offset = last - Long.parseLong(range.substring(1));\n                        if (offset < 0) {\n                            offset = 0;\n                        }\n                    } else if (range.endsWith(\"-\")) {\n                        offset = Long.parseLong(range.substring(0, range.length() - 1));\n                    } else if (range.contains(\"-\")) {\n                        String[] firstLast = range.split(\"\\\\-\", 2);\n                        offset = Long.parseLong(firstLast[0]);\n                        last = Long.parseLong(firstLast[1]);\n                    } else {\n                        throw new HttpResponseException(\"illegal range: \" + range, null, HttpResponse.builder().statusCode(416).build());\n                    }\n\n                    if (offset >= size) {\n                        throw new HttpResponseException(\"illegal range: \" + range, null, HttpResponse.builder().statusCode(416).build());\n                    }\n                    if (last + 1 > size) {\n                        last = size - 1;\n                    }\n                    ByteStreams.skipFully(inputStream, offset);\n                    size = last - offset + 1;\n                    inputStream = ByteStreams.limit(inputStream, size);\n                    contentRange = \"bytes \" + offset + \"-\" + last + \"/\" + attr.size();\n                }\n            }\n\n            if (eTag != null) {\n                eTag = maybeQuoteETag(eTag);\n                if (options.getIfMatch() != null) {\n                    if (!eTag.equals(maybeQuoteETag(options.getIfMatch()))) {\n                        HttpResponse response = HttpResponse.builder().statusCode(Status.PRECONDITION_FAILED.getStatusCode()).addHeader(HttpHeaders.ETAG, eTag).build();\n                        throw new HttpResponseException(new HttpCommand(HttpRequest.builder().method(\"GET\").endpoint(\"http://stub\").build()), response);\n                    }\n                }\n                if (options.getIfNoneMatch() != null) {\n                    if (eTag.equals(maybeQuoteETag(options.getIfNoneMatch()))) {\n                        HttpResponse response = HttpResponse.builder().statusCode(Status.NOT_MODIFIED.getStatusCode()).addHeader(HttpHeaders.ETAG, eTag).build();\n                        throw new HttpResponseException(new HttpCommand(HttpRequest.builder().method(\"GET\").endpoint(\"http://stub\").build()), response);\n                    }\n                }\n            }\n            if (options.getIfModifiedSince() != null) {\n                Date modifiedSince = options.getIfModifiedSince();\n                if (lastModifiedTime.before(modifiedSince)) {\n                    HttpResponse.Builder response = HttpResponse.builder().statusCode(Status.NOT_MODIFIED.getStatusCode());\n                    if (eTag != null) {\n                        response.addHeader(HttpHeaders.ETAG, eTag);\n                    }\n                    throw new HttpResponseException(String.format(\"%1$s is before %2$s\", lastModifiedTime, modifiedSince), null, response.build());\n                }\n\n            }\n            if (options.getIfUnmodifiedSince() != null) {\n                Date unmodifiedSince = options.getIfUnmodifiedSince();\n                if (lastModifiedTime.after(unmodifiedSince)) {\n                    HttpResponse.Builder response = HttpResponse.builder().statusCode(Status.PRECONDITION_FAILED.getStatusCode());\n                    if (eTag != null) {\n                        response.addHeader(HttpHeaders.ETAG, eTag);\n                    }\n                    throw new HttpResponseException(String.format(\"%1$s is after %2$s\", lastModifiedTime, unmodifiedSince), null, response.build());\n                }\n            }\n\n            Blob blob = new BlobBuilderImpl()\n                    .type(isDirectory ? StorageType.FOLDER : StorageType.BLOB)\n                    .name(key)\n                    .userMetadata(userMetadata.build())\n                    .payload(inputStream)\n                    .cacheControl(cacheControl)\n                    .contentDisposition(contentDisposition)\n                    .contentEncoding(contentEncoding)\n                    .contentLanguage(contentLanguage)\n                    .contentLength(size)\n                    .contentMD5(hashCode)\n                    .contentType(contentType)\n                    .eTag(eTag)\n                    .expires(expires)\n                    .tier(tier)\n                    .build();\n            blob.getMetadata().setContainer(container);\n            blob.getMetadata().setCreationDate(creationTime);\n            blob.getMetadata().setLastModified(lastModifiedTime);\n            blob.getMetadata().setSize(size);\n            if (contentRange != null) {\n                blob.getAllHeaders().put(HttpHeaders.CONTENT_RANGE, contentRange);\n            }\n            if (hashCode != null) {\n                blob.getMetadata().setETag(BaseEncoding.base16().lowerCase().encode(hashCode.asBytes()));\n            }\n            return blob;\n        } catch (NoSuchFileException nsfe) {\n            return null;\n        } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "s3proxy",
    "cve_id": "CVE-2025-24961",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "86b6ee4749aa163a78e7898efc063617ed171980",
    "short_hash": "86b6ee47",
    "vulnerableMethods_before": [
      {
        "filename": "AbstractNio2BlobStore.java",
        "method_name": "putBlob",
        "raw_code": "@Override\n    public final String putBlob(String container, Blob blob, PutOptions options) {\n        if (!containerExists(container)) {\n            throw new ContainerNotFoundException(container, \"\");\n        }\n\n        var path = root.resolve(container).resolve(blob.getMetadata().getName());\n        // TODO: should we use a known suffix to filter these out during list?\n        var tmpPath = root.resolve(container).resolve(blob.getMetadata().getName() + \"-\" + UUID.randomUUID());\n        logger.debug(\"Creating blob at: {}\", path);\n\n        if (blob.getMetadata().getName().endsWith(\"/\")) {\n            try {\n                logger.debug(\"Creating directory blob: {}\", path);\n                Files.createDirectories(path);\n            } catch (FileAlreadyExistsException faee) {\n                logger.debug(\"Parent directories already exist: {}\", path.getParent());\n            } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n            }\n\n            var view = Files.getFileAttributeView(path, UserDefinedFileAttributeView.class);\n            try {\n                writeCommonMetadataAttr(view, blob);\n                view.write(XATTR_CONTENT_MD5, ByteBuffer.wrap(DIRECTORY_MD5));\n            } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n            }\n\n            return BaseEncoding.base16().lowerCase().encode(DIRECTORY_MD5);\n        }\n\n        // Create parent directories.\n        try {\n            Files.createDirectories(path.getParent());\n        } catch (FileAlreadyExistsException faee) {\n            logger.debug(\"Parent directories already exist: {}\", path.getParent());\n        } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n        }\n\n        var metadata = blob.getMetadata().getContentMetadata();\n        try (var is = new HashingInputStream(Hashing.md5(), blob.getPayload().openStream());\n             var os = Files.newOutputStream(tmpPath)) {\n            var count = is.transferTo(os);\n            var actualHashCode = is.hash();\n            var expectedHashCode = metadata.getContentMD5AsHashCode();\n            if (expectedHashCode != null && !actualHashCode.equals(expectedHashCode)) {\n                Files.delete(tmpPath);\n                throw returnResponseException(400);\n            }\n\n            var view = Files.getFileAttributeView(tmpPath, UserDefinedFileAttributeView.class);\n            if (view != null) {\n                try {\n                    var eTag = actualHashCode.asBytes();\n                    view.write(XATTR_CONTENT_MD5, ByteBuffer.wrap(eTag));\n                    writeStringAttributeIfPresent(view, XATTR_CACHE_CONTROL, metadata.getCacheControl());\n                    writeStringAttributeIfPresent(view, XATTR_CONTENT_DISPOSITION, metadata.getContentDisposition());\n                    writeStringAttributeIfPresent(view, XATTR_CONTENT_ENCODING, metadata.getContentEncoding());\n                    writeStringAttributeIfPresent(view, XATTR_CONTENT_LANGUAGE, metadata.getContentLanguage());\n                    writeStringAttributeIfPresent(view, XATTR_CONTENT_TYPE, metadata.getContentType());\n                    var expires = metadata.getExpires();\n                    if (expires != null) {\n                        ByteBuffer buf = ByteBuffer.allocate(Longs.BYTES).putLong(expires.getTime());\n                        buf.flip();\n                        view.write(XATTR_EXPIRES, buf);\n                    }\n                    writeStringAttributeIfPresent(view, XATTR_STORAGE_TIER, blob.getMetadata().getTier().toString());\n                    for (var entry : blob.getMetadata().getUserMetadata().entrySet()) {\n                        writeStringAttributeIfPresent(view, XATTR_USER_METADATA_PREFIX + entry.getKey(), entry.getValue());\n                    }\n                } catch (IOException e) {\n                    // TODO:\n                    //logger.debug(\"xattrs not supported on %s\", path);\n                }\n            }\n\n            Files.move(tmpPath, path, StandardCopyOption.ATOMIC_MOVE, StandardCopyOption.REPLACE_EXISTING);\n\n            setBlobAccess(container, blob.getMetadata().getName(), options.getBlobAccess());\n\n            return \"\\\"\" + actualHashCode + \"\\\"\";\n        } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AbstractNio2BlobStore.java",
        "method_name": "putBlob",
        "raw_code": "@Override\n    public final String putBlob(String container, Blob blob, PutOptions options) {\n        if (!containerExists(container)) {\n            throw new ContainerNotFoundException(container, \"\");\n        }\n\n        var containerPath = root.resolve(container);\n        var path = containerPath.resolve(blob.getMetadata().getName());\n        checkValidPath(containerPath, path);\n        // TODO: should we use a known suffix to filter these out during list?\n        var tmpPath = root.resolve(container).resolve(blob.getMetadata().getName() + \"-\" + UUID.randomUUID());\n        logger.debug(\"Creating blob at: {}\", path);\n\n        if (blob.getMetadata().getName().endsWith(\"/\")) {\n            try {\n                logger.debug(\"Creating directory blob: {}\", path);\n                Files.createDirectories(path);\n            } catch (FileAlreadyExistsException faee) {\n                logger.debug(\"Parent directories already exist: {}\", path.getParent());\n            } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n            }\n\n            var view = Files.getFileAttributeView(path, UserDefinedFileAttributeView.class);\n            try {\n                writeCommonMetadataAttr(view, blob);\n                view.write(XATTR_CONTENT_MD5, ByteBuffer.wrap(DIRECTORY_MD5));\n            } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n            }\n\n            return BaseEncoding.base16().lowerCase().encode(DIRECTORY_MD5);\n        }\n\n        // Create parent directories.\n        try {\n            Files.createDirectories(path.getParent());\n        } catch (FileAlreadyExistsException faee) {\n            logger.debug(\"Parent directories already exist: {}\", path.getParent());\n        } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n        }\n\n        var metadata = blob.getMetadata().getContentMetadata();\n        try (var is = new HashingInputStream(Hashing.md5(), blob.getPayload().openStream());\n             var os = Files.newOutputStream(tmpPath)) {\n            var count = is.transferTo(os);\n            var actualHashCode = is.hash();\n            var expectedHashCode = metadata.getContentMD5AsHashCode();\n            if (expectedHashCode != null && !actualHashCode.equals(expectedHashCode)) {\n                Files.delete(tmpPath);\n                throw returnResponseException(400);\n            }\n\n            var view = Files.getFileAttributeView(tmpPath, UserDefinedFileAttributeView.class);\n            if (view != null) {\n                try {\n                    var eTag = actualHashCode.asBytes();\n                    view.write(XATTR_CONTENT_MD5, ByteBuffer.wrap(eTag));\n                    writeStringAttributeIfPresent(view, XATTR_CACHE_CONTROL, metadata.getCacheControl());\n                    writeStringAttributeIfPresent(view, XATTR_CONTENT_DISPOSITION, metadata.getContentDisposition());\n                    writeStringAttributeIfPresent(view, XATTR_CONTENT_ENCODING, metadata.getContentEncoding());\n                    writeStringAttributeIfPresent(view, XATTR_CONTENT_LANGUAGE, metadata.getContentLanguage());\n                    writeStringAttributeIfPresent(view, XATTR_CONTENT_TYPE, metadata.getContentType());\n                    var expires = metadata.getExpires();\n                    if (expires != null) {\n                        ByteBuffer buf = ByteBuffer.allocate(Longs.BYTES).putLong(expires.getTime());\n                        buf.flip();\n                        view.write(XATTR_EXPIRES, buf);\n                    }\n                    writeStringAttributeIfPresent(view, XATTR_STORAGE_TIER, blob.getMetadata().getTier().toString());\n                    for (var entry : blob.getMetadata().getUserMetadata().entrySet()) {\n                        writeStringAttributeIfPresent(view, XATTR_USER_METADATA_PREFIX + entry.getKey(), entry.getValue());\n                    }\n                } catch (IOException e) {\n                    // TODO:\n                    //logger.debug(\"xattrs not supported on %s\", path);\n                }\n            }\n\n            Files.move(tmpPath, path, StandardCopyOption.ATOMIC_MOVE, StandardCopyOption.REPLACE_EXISTING);\n\n            setBlobAccess(container, blob.getMetadata().getName(), options.getBlobAccess());\n\n            return \"\\\"\" + actualHashCode + \"\\\"\";\n        } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "s3proxy",
    "cve_id": "CVE-2025-24961",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "86b6ee4749aa163a78e7898efc063617ed171980",
    "short_hash": "86b6ee47",
    "vulnerableMethods_before": [
      {
        "filename": "AbstractNio2BlobStore.java",
        "method_name": "removeBlob",
        "raw_code": "@Override\n    public final void removeBlob(String container, String key) {\n        try {\n            var containerPath = root.resolve(container);\n            var path = containerPath.resolve(key);\n            Files.delete(path);\n            removeEmptyParentDirectories(containerPath, path.getParent());\n        } catch (NoSuchFileException nsfe) {\n            return;\n        } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AbstractNio2BlobStore.java",
        "method_name": "removeBlob",
        "raw_code": "@Override\n    public final void removeBlob(String container, String key) {\n        try {\n            var containerPath = root.resolve(container);\n            var path = containerPath.resolve(key).normalize();\n            checkValidPath(containerPath, path);\n            logger.debug(\"Deleting blob at: {}\", path);\n            Files.delete(path);\n            removeEmptyParentDirectories(containerPath, path.getParent());\n        } catch (NoSuchFileException nsfe) {\n            return;\n        } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "s3proxy",
    "cve_id": "CVE-2025-24961",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "86b6ee4749aa163a78e7898efc063617ed171980",
    "short_hash": "86b6ee47",
    "vulnerableMethods_before": [
      {
        "filename": "AbstractNio2BlobStore.java",
        "method_name": "getBlobAccess",
        "raw_code": "@Override\n    public final BlobAccess getBlobAccess(String container, String key) {\n        if (!containerExists(container)) {\n            throw new ContainerNotFoundException(container, \"\");\n        }\n        if (!blobExists(container, key)) {\n            throw new KeyNotFoundException(container, key, \"\");\n        }\n\n        var path = root.resolve(container).resolve(key);\n        Set<PosixFilePermission> permissions;\n        try {\n            permissions = Files.getPosixFilePermissions(path);\n        } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n        }\n        return permissions.contains(PosixFilePermission.OTHERS_READ) ?\n                BlobAccess.PUBLIC_READ : BlobAccess.PRIVATE;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AbstractNio2BlobStore.java",
        "method_name": "getBlobAccess",
        "raw_code": "@Override\n    public final BlobAccess getBlobAccess(String container, String key) {\n        if (!containerExists(container)) {\n            throw new ContainerNotFoundException(container, \"\");\n        }\n        if (!blobExists(container, key)) {\n            throw new KeyNotFoundException(container, key, \"\");\n        }\n\n        var containerPath = root.resolve(container);\n        var path = containerPath.resolve(key).normalize();\n        checkValidPath(containerPath, path);\n\n        Set<PosixFilePermission> permissions;\n        try {\n            permissions = Files.getPosixFilePermissions(path);\n        } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n        }\n        return permissions.contains(PosixFilePermission.OTHERS_READ) ?\n                BlobAccess.PUBLIC_READ : BlobAccess.PRIVATE;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "s3proxy",
    "cve_id": "CVE-2025-24961",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "86b6ee4749aa163a78e7898efc063617ed171980",
    "short_hash": "86b6ee47",
    "vulnerableMethods_before": [
      {
        "filename": "AbstractNio2BlobStore.java",
        "method_name": "setBlobAccess",
        "raw_code": "@Override\n    public final void setBlobAccess(String container, String key, BlobAccess access) {\n        if (!containerExists(container)) {\n            throw new ContainerNotFoundException(container, \"\");\n        }\n        if (!blobExists(container, key)) {\n            throw new KeyNotFoundException(container, key, \"\");\n        }\n\n        var path = root.resolve(container).resolve(key);\n        Set<PosixFilePermission> permissions;\n        try {\n            permissions = new HashSet<>(Files.getPosixFilePermissions(path));\n            if (access == BlobAccess.PRIVATE) {\n                permissions.remove(PosixFilePermission.OTHERS_READ);\n            } else if (access == BlobAccess.PUBLIC_READ) {\n                permissions.add(PosixFilePermission.OTHERS_READ);\n            }\n            Files.setPosixFilePermissions(path, permissions);\n        } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AbstractNio2BlobStore.java",
        "method_name": "setBlobAccess",
        "raw_code": "@Override\n    public final void setBlobAccess(String container, String key, BlobAccess access) {\n        if (!containerExists(container)) {\n            throw new ContainerNotFoundException(container, \"\");\n        }\n        if (!blobExists(container, key)) {\n            throw new KeyNotFoundException(container, key, \"\");\n        }\n\n        var containerPath = root.resolve(container);\n        var path = containerPath.resolve(key).normalize();\n        checkValidPath(containerPath, path);\n\n        Set<PosixFilePermission> permissions;\n        try {\n            permissions = new HashSet<>(Files.getPosixFilePermissions(path));\n            if (access == BlobAccess.PRIVATE) {\n                permissions.remove(PosixFilePermission.OTHERS_READ);\n            } else if (access == BlobAccess.PUBLIC_READ) {\n                permissions.add(PosixFilePermission.OTHERS_READ);\n            }\n            Files.setPosixFilePermissions(path, permissions);\n        } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "opal",
    "cve_id": "CVE-2025-27101",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "fca7dc9c8348064741b2e8b2c31b66660a935743",
    "short_hash": "fca7dc9c",
    "vulnerableMethods_before": [
      {
        "filename": "FilesResource.java",
        "method_name": "moveToFolder",
        "raw_code": "private Response moveToFolder(FileObject destinationFolder, Iterable<String> sourcesPath) throws IOException {\n    // destination check\n    String destinationPath = destinationFolder.getName().getPath();\n    if (!destinationFolder.exists()) return getPathNotExistResponse(destinationPath);\n    if (destinationFolder.getType() != FileType.FOLDER)\n      return Response.status(Status.BAD_REQUEST).entity(\"Destination must be a folder: \" + destinationPath).build();\n\n    // sources check\n    for (String sourcePath : sourcesPath) {\n      Response check = checkSourceFile(resolveFileInFileSystem(sourcePath));\n      if (check != null) return check;\n    }\n\n    // do action\n    for (String sourcePath : sourcesPath) {\n      if (!sourcePath.equals(destinationPath)) {\n        FileObject sourceFile = resolveFileInFileSystem(sourcePath);\n        FileObject destinationFile = resolveFileInFileSystem(destinationPath + \"/\" + sourceFile.getName().getBaseName());\n        sourceFile.moveTo(destinationFile);\n      }\n    }\n\n    return Response.ok().build();\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FilesResource.java",
        "method_name": "moveToFolder",
        "raw_code": "private Response moveToFolder(FileObject destinationFolder, Iterable<String> sourcesPath) throws IOException {\n    // destination check\n    String destinationPath = destinationFolder.getName().getPath();\n    if (!destinationFolder.exists()) return getPathNotExistResponse(destinationPath);\n    if (destinationFolder.getType() != FileType.FOLDER)\n      return Response.status(Status.BAD_REQUEST).entity(\"Destination must be a folder: \" + destinationPath).build();\n\n    // sources check\n    for (String sourcePath : sourcesPath) {\n      Response check = checkSourceFile(resolveFileInFileSystem(sourcePath));\n      if (check != null) return check;\n    }\n\n    // do action\n    for (String sourcePath : sourcesPath) {\n      if (!sourcePath.equals(destinationPath)) {\n        FileObject sourceFile = resolveFileInFileSystem(sourcePath);\n        checkSourceIsNotParent(sourceFile, destinationFolder);\n        FileObject destinationFile = resolveFileInFileSystem(destinationPath + \"/\" + sourceFile.getName().getBaseName());\n        sourceFile.moveTo(destinationFile);\n      }\n    }\n\n    return Response.ok().build();\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "opal",
    "cve_id": "CVE-2025-27101",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "fca7dc9c8348064741b2e8b2c31b66660a935743",
    "short_hash": "fca7dc9c",
    "vulnerableMethods_before": [
      {
        "filename": "FilesResource.java",
        "method_name": "copyFrom",
        "raw_code": "private Response copyFrom(FileObject destinationFolder, Iterable<String> sourcesPath) throws IOException {\n    // destination check\n    String destinationPath = destinationFolder.getName().getPath();\n    if (!destinationFolder.exists()) return getPathNotExistResponse(destinationPath);\n    if (destinationFolder.getType() != FileType.FOLDER)\n      return Response.status(Status.BAD_REQUEST).entity(\"Destination must be a folder: \" + destinationPath).build();\n\n    // sources check\n    for (String sourcePath : sourcesPath) {\n      FileObject sourceFile = resolveFileInFileSystem(sourcePath);\n      if (!sourceFile.exists()) getPathNotExistResponse(sourcePath);\n      if (!sourceFile.isReadable()) {\n        return Response.status(Status.FORBIDDEN).entity(\"Source file is not readable: \" + sourcePath).build();\n      }\n    }\n\n    // do action\n    for (String sourcePath : sourcesPath) {\n      if (!sourcePath.equals(destinationPath)) {\n        FileObject sourceFile = resolveFileInFileSystem(sourcePath);\n        FileObject destinationFile = resolveFileInFileSystem(destinationPath + \"/\" + sourceFile.getName().getBaseName());\n        FileSelector selector = sourceFile.getType() == FileType.FOLDER ? Selectors.SELECT_ALL : Selectors.SELECT_SELF;\n        destinationFile.copyFrom(sourceFile, selector);\n      }\n    }\n\n    return Response.ok().build();\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FilesResource.java",
        "method_name": "copyFrom",
        "raw_code": "private Response copyFrom(FileObject destinationFolder, Iterable<String> sourcesPath) throws IOException {\n    // destination check\n    String destinationPath = destinationFolder.getName().getPath();\n    if (!destinationFolder.exists()) return getPathNotExistResponse(destinationPath);\n    if (destinationFolder.getType() != FileType.FOLDER)\n      return Response.status(Status.BAD_REQUEST).entity(\"Destination must be a folder: \" + destinationPath).build();\n\n    // sources check\n    for (String sourcePath : sourcesPath) {\n      FileObject sourceFile = resolveFileInFileSystem(sourcePath);\n      if (!sourceFile.exists()) getPathNotExistResponse(sourcePath);\n      if (!sourceFile.isReadable()) {\n        return Response.status(Status.FORBIDDEN).entity(\"Source file is not readable: \" + sourcePath).build();\n      }\n      checkSourceIsNotParent(sourceFile, destinationFolder);\n    }\n\n    // do action\n    for (String sourcePath : sourcesPath) {\n      if (!sourcePath.equals(destinationPath)) {\n        FileObject sourceFile = resolveFileInFileSystem(sourcePath);\n        FileObject destinationFile = resolveFileInFileSystem(destinationPath + \"/\" + sourceFile.getName().getBaseName());\n        FileSelector selector = sourceFile.getType() == FileType.FOLDER ? Selectors.SELECT_ALL : Selectors.SELECT_SELF;\n        destinationFile.copyFrom(sourceFile, selector);\n      }\n    }\n\n    return Response.ok().build();\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-48063",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "2557813aef3b863988d6cca58de996e207086898",
    "short_hash": "2557813a",
    "vulnerableMethods_before": [
      {
        "filename": "RightsFilterListenerTest.java",
        "method_name": "checkEnforcedButAllowedRequiredRights",
        "raw_code": "@Test\n    void checkEnforcedButAllowedRequiredRights() throws AccessDeniedException\n    {\n        XWikiDocument document = createTestDocument();\n        XWikiDocument originalDocument = document.clone();\n        document.setOriginalDocument(originalDocument);\n\n        DocumentRequiredRights requiredRights = new DocumentRequiredRights(true,\n            Set.of(new DocumentRequiredRight(Right.SCRIPT, EntityType.DOCUMENT)));\n        DocumentRequiredRights previousRequiredRights = new DocumentRequiredRights(true, Set.of());\n\n        when(this.requiredRightsReader.readRequiredRights(same(document))).thenReturn(requiredRights);\n        when(this.requiredRightsReader.readRequiredRights(same(originalDocument))).thenReturn(previousRequiredRights);\n\n        UserUpdatingDocumentEvent event = new UserUpdatingDocumentEvent();\n        this.listener.onEvent(event, document, null);\n        assertFalse(event.isCanceled());\n        verify(this.authorization).checkAccess(Right.SCRIPT, null, document.getDocumentReference());\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "RightsFilterListenerTest.java",
        "method_name": "checkEnforcedButAllowedRequiredRights",
        "raw_code": "@Test\n    void checkEnforcedButAllowedRequiredRights() throws AccessDeniedException\n    {\n        XWikiDocument document = createTestDocument();\n        XWikiDocument originalDocument = document.clone();\n        document.setOriginalDocument(originalDocument);\n\n        DocumentRequiredRights requiredRights = new DocumentRequiredRights(true,\n            Set.of(new DocumentRequiredRight(Right.SCRIPT, EntityType.DOCUMENT)));\n        DocumentRequiredRights previousRequiredRights = new DocumentRequiredRights(true, Set.of());\n\n        when(this.requiredRightsReader.readRequiredRights(same(document))).thenReturn(requiredRights);\n        when(this.requiredRightsReader.readRequiredRights(same(originalDocument))).thenReturn(previousRequiredRights);\n\n        UserUpdatingDocumentEvent event = new UserUpdatingDocumentEvent();\n        this.listener.onEvent(event, document, null);\n        assertFalse(event.isCanceled());\n        verify(this.authorization).checkAccess(Right.SCRIPT, null, document.getDocumentReference());\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-48063",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "2557813aef3b863988d6cca58de996e207086898",
    "short_hash": "2557813a",
    "vulnerableMethods_before": [
      {
        "filename": "RightsFilterListener.java",
        "method_name": "checkModifiedRequiredRights",
        "raw_code": "private void checkModifiedRequiredRights(DocumentReference user, XWikiDocument document,\n        CancelableEvent event)\n    {\n        XWikiDocument originalDocument = document.getOriginalDocument();\n        DocumentRequiredRights originalRequiredRights =\n            this.documentRequiredRightsReader.readRequiredRights(originalDocument);\n        DocumentRequiredRights requiredRights = this.documentRequiredRightsReader.readRequiredRights(document);\n\n        if (!originalRequiredRights.equals(requiredRights) && requiredRights.enforce()) {\n            // We can assume that the current user has all existing required rights as otherwise editing would be\n            // denied.\n            // Therefore, only check if the user has all rights specified in the updated document that could either\n            // have changed required rights or where enforcing has just been enabled.\n            for (DocumentRequiredRight requiredRight : requiredRights.rights()) {\n                try {\n                    this.authorization.checkAccess(requiredRight.right(), user,\n                        document.getDocumentReference().extractReference(requiredRight.scope()));\n                } catch (AccessDeniedException e) {\n                    event.cancel(\n                        \"The author doesn't have the right [%s] on the [%s] level that has been specified as required.\"\n                            .formatted(requiredRight.right().getName(), requiredRight.scope().getLowerCase()));\n                    break;\n                }\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "RightsFilterListener.java",
        "method_name": "checkModifiedRequiredRights",
        "raw_code": "private void checkModifiedRequiredRights(DocumentReference user, XWikiDocument document,\n        CancelableEvent event)\n    {\n        XWikiDocument originalDocument = document.getOriginalDocument();\n        DocumentRequiredRights originalRequiredRights =\n            this.documentRequiredRightsReader.readRequiredRights(originalDocument);\n        DocumentRequiredRights requiredRights = this.documentRequiredRightsReader.readRequiredRights(document);\n\n        if (!originalRequiredRights.equals(requiredRights) && requiredRights.enforce()) {\n            // We can assume that the current user has all existing required rights as otherwise editing would be\n            // denied.\n            // Therefore, only check if the user has all rights specified in the updated document that could either\n            // have changed required rights or where enforcing has just been enabled.\n            for (DocumentRequiredRight requiredRight : requiredRights.rights()) {\n                try {\n                    this.authorization.checkAccess(requiredRight.right(), user,\n                        document.getDocumentReference().extractReference(requiredRight.scope()));\n                } catch (AccessDeniedException e) {\n                    event.cancel(\n                        \"The author doesn't have the right [%s] on the [%s] level that has been specified as required.\"\n                            .formatted(requiredRight.right().getName(), requiredRight.scope()));\n                    break;\n                }\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "netty",
    "cve_id": "CVE-2025-25193",
    "cwe_list": [
      "CWE-400"
    ],
    "commit_hash": "d1fbda62d3a47835d3fb35db8bd42ecc205a5386",
    "short_hash": "d1fbda62",
    "vulnerableMethods_before": [
      {
        "filename": "BoundedInputStream.java",
        "method_name": "read",
        "raw_code": "@Override\n    public int read(byte[] buf, int off, int len) throws IOException {\n        checkMaxBytesRead();\n\n        // Calculate the maximum number of bytes that we should try to read.\n        int num = Math.min(len, maxBytesRead - numRead + 1);\n\n        int b = super.read(buf, off, num);\n\n        if (b > 0) {\n            numRead += b;\n        }\n\n        checkMaxBytesRead();\n        return b;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "BoundedInputStream.java",
        "method_name": "read",
        "raw_code": "@Override\n    public int read(byte[] buf, int off, int len) throws IOException {\n        checkMaxBytesRead();\n\n        // Calculate the maximum number of bytes that we should try to read.\n        int num = Math.min(len, maxBytesRead - numRead + 1);\n\n        int b = super.read(buf, off, num);\n\n        if (b != -1) {\n            numRead += b;\n        }\n        return b;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "netty",
    "cve_id": "CVE-2025-25193",
    "cwe_list": [
      "CWE-400"
    ],
    "commit_hash": "d1fbda62d3a47835d3fb35db8bd42ecc205a5386",
    "short_hash": "d1fbda62",
    "vulnerableMethods_before": [
      {
        "filename": "BoundedInputStreamTest.java",
        "method_name": "testBoundEnforced",
        "raw_code": "@Test\n    void testBoundEnforced() throws IOException {\n        final byte[] bytes = new byte[64];\n        PlatformDependent.threadLocalRandom().nextBytes(bytes);\n        final BoundedInputStream reader = new BoundedInputStream(new ByteArrayInputStream(bytes), bytes.length - 1);\n        assertEquals(bytes[0], (byte) reader.read());\n\n        assertThrows(IOException.class, new Executable() {\n            @Override\n            public void execute() throws Throwable {\n                reader.read(new byte[64], 0, 64);\n            }\n        });\n        reader.close();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "BoundedInputStreamTest.java",
        "method_name": "testBoundEnforced",
        "raw_code": "@RepeatedTest(50)\n    void testBoundEnforced() throws IOException {\n        final byte[] bytes = new byte[64];\n        PlatformDependent.threadLocalRandom().nextBytes(bytes);\n        final BoundedInputStream reader = new BoundedInputStream(new ByteArrayInputStream(bytes), bytes.length - 1);\n        assertEquals(bytes[0], (byte) reader.read());\n\n        assertThrows(IOException.class, new Executable() {\n            @Override\n            public void execute() throws Throwable {\n                int max = bytes.length;\n                do {\n                    int result = reader.read(new byte[max], 0, max);\n                    assertThat(result).isNotEqualTo(-1);\n                    max -= result;\n                } while (max > 0);\n            }\n        });\n        reader.close();\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "netty",
    "cve_id": "CVE-2025-25193",
    "cwe_list": [
      "CWE-400"
    ],
    "commit_hash": "d1fbda62d3a47835d3fb35db8bd42ecc205a5386",
    "short_hash": "d1fbda62",
    "vulnerableMethods_before": [
      {
        "filename": "BoundedInputStreamTest.java",
        "method_name": "testBigReadsPermittedIfUnderlyingStreamIsSmall",
        "raw_code": "@Test\n    void testBigReadsPermittedIfUnderlyingStreamIsSmall() throws IOException {\n        final byte[] bytes = new byte[64];\n        PlatformDependent.threadLocalRandom().nextBytes(bytes);\n        final BoundedInputStream reader = new BoundedInputStream(new ByteArrayInputStream(bytes), 8192);\n        final byte[] buffer = new byte[10000];\n        reader.read(buffer, 0, 10000);\n        assertArrayEquals(bytes, Arrays.copyOfRange(buffer, 0, 64));\n        reader.close();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "BoundedInputStreamTest.java",
        "method_name": "testBigReadsPermittedIfUnderlyingStreamIsSmall",
        "raw_code": "@RepeatedTest(50)\n    void testBigReadsPermittedIfUnderlyingStreamIsSmall() throws IOException {\n        final byte[] bytes = new byte[64];\n        PlatformDependent.threadLocalRandom().nextBytes(bytes);\n        final BoundedInputStream reader = new BoundedInputStream(new ByteArrayInputStream(bytes), 8192);\n        final byte[] buffer = new byte[10000];\n        assertThat(reader.read(buffer, 0, 10000)).isEqualTo(64);\n        assertArrayEquals(bytes, Arrays.copyOfRange(buffer, 0, 64));\n        reader.close();\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "netty",
    "cve_id": "CVE-2025-24970",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "87f40725155b2f89adfde68c7732f97c153676c4",
    "short_hash": "87f40725",
    "vulnerableMethods_before": [
      {
        "filename": "SslUtils.java",
        "method_name": "getEncryptedPacketLength",
        "raw_code": "private static int getEncryptedPacketLength(ByteBuffer buffer) {\n        int packetLength = 0;\n        int pos = buffer.position();\n        // SSLv3 or TLS - Check ContentType\n        boolean tls;\n        switch (unsignedByte(buffer.get(pos))) {\n            case SSL_CONTENT_TYPE_CHANGE_CIPHER_SPEC:\n            case SSL_CONTENT_TYPE_ALERT:\n            case SSL_CONTENT_TYPE_HANDSHAKE:\n            case SSL_CONTENT_TYPE_APPLICATION_DATA:\n            case SSL_CONTENT_TYPE_EXTENSION_HEARTBEAT:\n                tls = true;\n                break;\n            default:\n                // SSLv2 or bad data\n                tls = false;\n        }\n\n        if (tls) {\n            // SSLv3 or TLS or GMSSLv1.0 or GMSSLv1.1 - Check ProtocolVersion\n            int majorVersion = unsignedByte(buffer.get(pos + 1));\n            if (majorVersion == 3 || buffer.getShort(pos + 1) == GMSSL_PROTOCOL_VERSION) {\n                // SSLv3 or TLS or GMSSLv1.0 or GMSSLv1.1\n                packetLength = unsignedShortBE(buffer, pos + 3) + SSL_RECORD_HEADER_LENGTH;\n                if (packetLength <= SSL_RECORD_HEADER_LENGTH) {\n                    // Neither SSLv3 or TLSv1 (i.e. SSLv2 or bad data)\n                    tls = false;\n                }\n            } else {\n                // Neither SSLv3 or TLSv1 (i.e. SSLv2 or bad data)\n                tls = false;\n            }\n        }\n\n        if (!tls) {\n            // SSLv2 or bad data - Check the version\n            int headerLength = (unsignedByte(buffer.get(pos)) & 0x80) != 0 ? 2 : 3;\n            int majorVersion = unsignedByte(buffer.get(pos + headerLength + 1));\n            if (majorVersion == 2 || majorVersion == 3) {\n                // SSLv2\n                packetLength = headerLength == 2 ?\n                        (shortBE(buffer, pos) & 0x7FFF) + 2 : (shortBE(buffer, pos) & 0x3FFF) + 3;\n                if (packetLength <= headerLength) {\n                    return NOT_ENOUGH_DATA;\n                }\n            } else {\n                return NOT_ENCRYPTED;\n            }\n        }\n        return packetLength;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SslUtils.java",
        "method_name": "getEncryptedPacketLength",
        "raw_code": "private static int getEncryptedPacketLength(ByteBuffer buffer) {\n        int remaining = buffer.remaining();\n        if (remaining < SSL_RECORD_HEADER_LENGTH) {\n            return NOT_ENOUGH_DATA;\n        }\n        int packetLength = 0;\n        int pos = buffer.position();\n\n        // SSLv3 or TLS - Check ContentType\n        boolean tls;\n        switch (unsignedByte(buffer.get(pos))) {\n            case SSL_CONTENT_TYPE_CHANGE_CIPHER_SPEC:\n            case SSL_CONTENT_TYPE_ALERT:\n            case SSL_CONTENT_TYPE_HANDSHAKE:\n            case SSL_CONTENT_TYPE_APPLICATION_DATA:\n            case SSL_CONTENT_TYPE_EXTENSION_HEARTBEAT:\n                tls = true;\n                break;\n            default:\n                // SSLv2 or bad data\n                tls = false;\n        }\n\n        if (tls) {\n            // SSLv3 or TLS or GMSSLv1.0 or GMSSLv1.1 - Check ProtocolVersion\n            int majorVersion = unsignedByte(buffer.get(pos + 1));\n            if (majorVersion == 3 || buffer.getShort(pos + 1) == GMSSL_PROTOCOL_VERSION) {\n                // SSLv3 or TLS or GMSSLv1.0 or GMSSLv1.1\n                packetLength = unsignedShortBE(buffer, pos + 3) + SSL_RECORD_HEADER_LENGTH;\n                if (packetLength <= SSL_RECORD_HEADER_LENGTH) {\n                    // Neither SSLv3 or TLSv1 (i.e. SSLv2 or bad data)\n                    tls = false;\n                }\n            } else {\n                // Neither SSLv3 or TLSv1 (i.e. SSLv2 or bad data)\n                tls = false;\n            }\n        }\n\n        if (!tls) {\n            // SSLv2 or bad data - Check the version\n            int headerLength = (unsignedByte(buffer.get(pos)) & 0x80) != 0 ? 2 : 3;\n            int majorVersion = unsignedByte(buffer.get(pos + headerLength + 1));\n            if (majorVersion == 2 || majorVersion == 3) {\n                // SSLv2\n                packetLength = headerLength == 2 ?\n                        (shortBE(buffer, pos) & 0x7FFF) + 2 : (shortBE(buffer, pos) & 0x3FFF) + 3;\n                if (packetLength <= headerLength) {\n                    // If there's no data then consider this package as not encrypted.\n                    return NOT_ENCRYPTED;\n                }\n            } else {\n                return NOT_ENCRYPTED;\n            }\n        }\n        return packetLength;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "netty",
    "cve_id": "CVE-2025-24970",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "87f40725155b2f89adfde68c7732f97c153676c4",
    "short_hash": "87f40725",
    "vulnerableMethods_before": [
      {
        "filename": "ReferenceCountedOpenSslEngine.java",
        "method_name": "unwrap",
        "raw_code": "public final SSLEngineResult unwrap(\n            final ByteBuffer[] srcs, int srcsOffset, final int srcsLength,\n            final ByteBuffer[] dsts, int dstsOffset, final int dstsLength) throws SSLException {\n\n        // Throw required runtime exceptions\n        checkNotNullWithIAE(srcs, \"srcs\");\n        if (srcsOffset >= srcs.length\n                || srcsOffset + srcsLength > srcs.length) {\n            throw new IndexOutOfBoundsException(\n                    \"offset: \" + srcsOffset + \", length: \" + srcsLength +\n                            \" (expected: offset <= offset + length <= srcs.length (\" + srcs.length + \"))\");\n        }\n        checkNotNullWithIAE(dsts, \"dsts\");\n        if (dstsOffset >= dsts.length || dstsOffset + dstsLength > dsts.length) {\n            throw new IndexOutOfBoundsException(\n                    \"offset: \" + dstsOffset + \", length: \" + dstsLength +\n                            \" (expected: offset <= offset + length <= dsts.length (\" + dsts.length + \"))\");\n        }\n        long capacity = 0;\n        final int dstsEndOffset = dstsOffset + dstsLength;\n        for (int i = dstsOffset; i < dstsEndOffset; i ++) {\n            ByteBuffer dst = checkNotNullArrayParam(dsts[i], i, \"dsts\");\n            if (dst.isReadOnly()) {\n                throw new ReadOnlyBufferException();\n            }\n            capacity += dst.remaining();\n        }\n\n        final int srcsEndOffset = srcsOffset + srcsLength;\n        long len = 0;\n        for (int i = srcsOffset; i < srcsEndOffset; i++) {\n            ByteBuffer src = checkNotNullArrayParam(srcs[i], i, \"srcs\");\n            len += src.remaining();\n        }\n\n        synchronized (this) {\n            if (isInboundDone()) {\n                return isOutboundDone() || isDestroyed() ? CLOSED_NOT_HANDSHAKING : NEED_WRAP_CLOSED;\n            }\n\n            SSLEngineResult.HandshakeStatus status = NOT_HANDSHAKING;\n            HandshakeState oldHandshakeState = handshakeState;\n            // Prepare OpenSSL to work in server mode and receive handshake\n            if (handshakeState != HandshakeState.FINISHED) {\n                if (handshakeState != HandshakeState.STARTED_EXPLICITLY) {\n                    // Update accepted so we know we triggered the handshake via wrap\n                    handshakeState = HandshakeState.STARTED_IMPLICITLY;\n                }\n\n                status = handshake();\n\n                if (status == NEED_TASK) {\n                    return newResult(status, 0, 0);\n                }\n\n                if (status == NEED_WRAP) {\n                    return NEED_WRAP_OK;\n                }\n                // Check if the inbound is considered to be closed if so let us try to wrap again.\n                if (isInboundDone) {\n                    return NEED_WRAP_CLOSED;\n                }\n            }\n\n            int sslPending = sslPending0();\n            int packetLength;\n            // The JDK implies that only a single SSL packet should be processed per unwrap call [1]. If we are in\n            // JDK compatibility mode then we should honor this, but if not we just wrap as much as possible. If there\n            // are multiple records or partial records this may reduce thrashing events through the pipeline.\n            // [1] https://docs.oracle.com/javase/7/docs/api/javax/net/ssl/SSLEngine.html\n            if (jdkCompatibilityMode ||\n                    // If the handshake was not finished before we entered the method, we also ensure we only\n                    // unwrap one record. We do this to ensure we not produce any extra data before the caller\n                    // of the method is able to observe handshake completion and react on it.\n                    oldHandshakeState != HandshakeState.FINISHED) {\n                if (len < SSL_RECORD_HEADER_LENGTH) {\n                    return newResultMayFinishHandshake(BUFFER_UNDERFLOW, status, 0, 0);\n                }\n\n                packetLength = SslUtils.getEncryptedPacketLength(srcs, srcsOffset);\n                if (packetLength == SslUtils.NOT_ENCRYPTED) {\n                    throw new NotSslRecordException(\"not an SSL/TLS record\");\n                }\n\n                final int packetLengthDataOnly = packetLength - SSL_RECORD_HEADER_LENGTH;\n                if (packetLengthDataOnly > capacity) {\n                    // Not enough space in the destination buffer so signal the caller that the buffer needs to be\n                    // increased.\n                    if (packetLengthDataOnly > MAX_RECORD_SIZE) {\n                        // The packet length MUST NOT exceed 2^14 [1]. However we do accommodate more data to support\n                        // legacy use cases which may violate this condition (e.g. OpenJDK's SslEngineImpl). If the max\n                        // length is exceeded we fail fast here to avoid an infinite loop due to the fact that we\n                        // won't allocate a buffer large enough.\n                        // [1] https://tools.ietf.org/html/rfc5246#section-6.2.1\n                        throw new SSLException(\"Illegal packet length: \" + packetLengthDataOnly + \" > \" +\n                                                session.getApplicationBufferSize());\n                    } else {\n                        session.tryExpandApplicationBufferSize(packetLengthDataOnly);\n                    }\n                    return newResultMayFinishHandshake(BUFFER_OVERFLOW, status, 0, 0);\n                }\n\n                if (len < packetLength) {\n                    // We either don't have enough data to read the packet length or not enough for reading the whole\n                    // packet.\n                    return newResultMayFinishHandshake(BUFFER_UNDERFLOW, status, 0, 0);\n                }\n            } else if (len == 0 && sslPending <= 0) {\n                return newResultMayFinishHandshake(BUFFER_UNDERFLOW, status, 0, 0);\n            } else if (capacity == 0) {\n                return newResultMayFinishHandshake(BUFFER_OVERFLOW, status, 0, 0);\n            } else {\n                packetLength = (int) min(MAX_VALUE, len);\n            }\n\n            // This must always be the case when we reached here as if not we returned BUFFER_UNDERFLOW.\n            assert srcsOffset < srcsEndOffset;\n\n            // This must always be the case if we reached here.\n            assert capacity > 0;\n\n            // Number of produced bytes\n            int bytesProduced = 0;\n            int bytesConsumed = 0;\n            try {\n                srcLoop:\n                for (;;) {\n                    ByteBuffer src = srcs[srcsOffset];\n                    int remaining = src.remaining();\n                    final ByteBuf bioWriteCopyBuf;\n                    int pendingEncryptedBytes;\n                    if (remaining == 0) {\n                        if (sslPending <= 0) {\n                            // We must skip empty buffers as BIO_write will return 0 if asked to write something\n                            // with length 0.\n                            if (++srcsOffset >= srcsEndOffset) {\n                                break;\n                            }\n                            continue;\n                        } else {\n                            bioWriteCopyBuf = null;\n                            pendingEncryptedBytes = SSL.bioLengthByteBuffer(networkBIO);\n                        }\n                    } else {\n                        // Write more encrypted data into the BIO. Ensure we only read one packet at a time as\n                        // stated in the SSLEngine javadocs.\n                        pendingEncryptedBytes = min(packetLength, remaining);\n                        try {\n                            bioWriteCopyBuf = writeEncryptedData(src, pendingEncryptedBytes);\n                        } catch (SSLException e) {\n                            // Ensure we correctly handle the error stack.\n                            return handleUnwrapException(bytesConsumed, bytesProduced, e);\n                        }\n                    }\n                    try {\n                        for (;;) {\n                            ByteBuffer dst = dsts[dstsOffset];\n                            if (!dst.hasRemaining()) {\n                                // No space left in the destination buffer, skip it.\n                                if (++dstsOffset >= dstsEndOffset) {\n                                    break srcLoop;\n                                }\n                                continue;\n                            }\n\n                            int bytesRead;\n                            try {\n                                bytesRead = readPlaintextData(dst);\n                            } catch (SSLException e) {\n                                // Ensure we correctly handle the error stack.\n                                return handleUnwrapException(bytesConsumed, bytesProduced, e);\n                            }\n                            // We are directly using the ByteBuffer memory for the write, and so we only know what has\n                            // been consumed after we let SSL decrypt the data. At this point we should update the\n                            // number of bytes consumed, update the ByteBuffer position, and release temp ByteBuf.\n                            int localBytesConsumed = pendingEncryptedBytes - SSL.bioLengthByteBuffer(networkBIO);\n                            bytesConsumed += localBytesConsumed;\n                            packetLength -= localBytesConsumed;\n                            pendingEncryptedBytes -= localBytesConsumed;\n                            src.position(src.position() + localBytesConsumed);\n\n                            if (bytesRead > 0) {\n                                bytesProduced += bytesRead;\n\n                                if (!dst.hasRemaining()) {\n                                    sslPending = sslPending0();\n                                    // Move to the next dst buffer as this one is full.\n                                    if (++dstsOffset >= dstsEndOffset) {\n                                        return sslPending > 0 ?\n                                                newResult(BUFFER_OVERFLOW, status, bytesConsumed, bytesProduced) :\n                                                newResultMayFinishHandshake(isInboundDone() ? CLOSED : OK, status,\n                                                        bytesConsumed, bytesProduced);\n                                    }\n                                } else if (packetLength == 0 || jdkCompatibilityMode) {\n                                    // We either consumed all data or we are in jdkCompatibilityMode and have consumed\n                                    // a single TLS packet and should stop consuming until this method is called again.\n                                    break srcLoop;\n                                }\n                            } else {\n                                int sslError = SSL.getError(ssl, bytesRead);\n                                if (sslError == SSL.SSL_ERROR_WANT_READ || sslError == SSL.SSL_ERROR_WANT_WRITE) {\n                                    // break to the outer loop as we want to read more data which means we need to\n                                    // write more to the BIO.\n                                    break;\n                                } else if (sslError == SSL.SSL_ERROR_ZERO_RETURN) {\n                                    // This means the connection was shutdown correctly, close inbound and outbound\n                                    if (!receivedShutdown) {\n                                        closeAll();\n                                    }\n                                    return newResultMayFinishHandshake(isInboundDone() ? CLOSED : OK, status,\n                                            bytesConsumed, bytesProduced);\n                                } else if (sslError == SSL.SSL_ERROR_WANT_X509_LOOKUP ||\n                                        sslError == SSL.SSL_ERROR_WANT_CERTIFICATE_VERIFY ||\n                                        sslError == SSL.SSL_ERROR_WANT_PRIVATE_KEY_OPERATION) {\n                                    return newResult(isInboundDone() ? CLOSED : OK,\n                                            NEED_TASK, bytesConsumed, bytesProduced);\n                                } else {\n                                    return sslReadErrorResult(sslError, SSL.getLastErrorNumber(), bytesConsumed,\n                                            bytesProduced);\n                                }\n                            }\n                        }\n\n                        if (++srcsOffset >= srcsEndOffset) {\n                            break;\n                        }\n                    } finally {\n                        if (bioWriteCopyBuf != null) {\n                            bioWriteCopyBuf.release();\n                        }\n                    }\n                }\n            } finally {\n                SSL.bioClearByteBuffer(networkBIO);\n                rejectRemoteInitiatedRenegotiation();\n            }\n\n            // Check to see if we received a close_notify message from the peer.\n            if (!receivedShutdown && (SSL.getShutdown(ssl) & SSL.SSL_RECEIVED_SHUTDOWN) == SSL.SSL_RECEIVED_SHUTDOWN) {\n                closeAll();\n            }\n\n            return newResultMayFinishHandshake(isInboundDone() ? CLOSED : OK, status, bytesConsumed, bytesProduced);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ReferenceCountedOpenSslEngine.java",
        "method_name": "unwrap",
        "raw_code": "public final SSLEngineResult unwrap(\n            final ByteBuffer[] srcs, int srcsOffset, final int srcsLength,\n            final ByteBuffer[] dsts, int dstsOffset, final int dstsLength) throws SSLException {\n\n        // Throw required runtime exceptions\n        checkNotNullWithIAE(srcs, \"srcs\");\n        if (srcsOffset >= srcs.length\n                || srcsOffset + srcsLength > srcs.length) {\n            throw new IndexOutOfBoundsException(\n                    \"offset: \" + srcsOffset + \", length: \" + srcsLength +\n                            \" (expected: offset <= offset + length <= srcs.length (\" + srcs.length + \"))\");\n        }\n        checkNotNullWithIAE(dsts, \"dsts\");\n        if (dstsOffset >= dsts.length || dstsOffset + dstsLength > dsts.length) {\n            throw new IndexOutOfBoundsException(\n                    \"offset: \" + dstsOffset + \", length: \" + dstsLength +\n                            \" (expected: offset <= offset + length <= dsts.length (\" + dsts.length + \"))\");\n        }\n        long capacity = 0;\n        final int dstsEndOffset = dstsOffset + dstsLength;\n        for (int i = dstsOffset; i < dstsEndOffset; i ++) {\n            ByteBuffer dst = checkNotNullArrayParam(dsts[i], i, \"dsts\");\n            if (dst.isReadOnly()) {\n                throw new ReadOnlyBufferException();\n            }\n            capacity += dst.remaining();\n        }\n\n        final int srcsEndOffset = srcsOffset + srcsLength;\n        long len = 0;\n        for (int i = srcsOffset; i < srcsEndOffset; i++) {\n            ByteBuffer src = checkNotNullArrayParam(srcs[i], i, \"srcs\");\n            len += src.remaining();\n        }\n\n        synchronized (this) {\n            if (isInboundDone()) {\n                return isOutboundDone() || isDestroyed() ? CLOSED_NOT_HANDSHAKING : NEED_WRAP_CLOSED;\n            }\n\n            SSLEngineResult.HandshakeStatus status = NOT_HANDSHAKING;\n            HandshakeState oldHandshakeState = handshakeState;\n            // Prepare OpenSSL to work in server mode and receive handshake\n            if (handshakeState != HandshakeState.FINISHED) {\n                if (handshakeState != HandshakeState.STARTED_EXPLICITLY) {\n                    // Update accepted so we know we triggered the handshake via wrap\n                    handshakeState = HandshakeState.STARTED_IMPLICITLY;\n                }\n\n                status = handshake();\n\n                if (status == NEED_TASK) {\n                    return newResult(status, 0, 0);\n                }\n\n                if (status == NEED_WRAP) {\n                    return NEED_WRAP_OK;\n                }\n                // Check if the inbound is considered to be closed if so let us try to wrap again.\n                if (isInboundDone) {\n                    return NEED_WRAP_CLOSED;\n                }\n            }\n\n            int sslPending = sslPending0();\n            int packetLength;\n            // The JDK implies that only a single SSL packet should be processed per unwrap call [1]. If we are in\n            // JDK compatibility mode then we should honor this, but if not we just wrap as much as possible. If there\n            // are multiple records or partial records this may reduce thrashing events through the pipeline.\n            // [1] https://docs.oracle.com/javase/7/docs/api/javax/net/ssl/SSLEngine.html\n            if (jdkCompatibilityMode ||\n                    // If the handshake was not finished before we entered the method, we also ensure we only\n                    // unwrap one record. We do this to ensure we not produce any extra data before the caller\n                    // of the method is able to observe handshake completion and react on it.\n                    oldHandshakeState != HandshakeState.FINISHED) {\n                if (len < SSL_RECORD_HEADER_LENGTH) {\n                    return newResultMayFinishHandshake(BUFFER_UNDERFLOW, status, 0, 0);\n                }\n\n                packetLength = SslUtils.getEncryptedPacketLength(srcs, srcsOffset);\n                if (packetLength == SslUtils.NOT_ENCRYPTED) {\n                    throw new NotSslRecordException(\"not an SSL/TLS record\");\n                }\n\n                assert packetLength >= 0;\n\n                final int packetLengthDataOnly = packetLength - SSL_RECORD_HEADER_LENGTH;\n                if (packetLengthDataOnly > capacity) {\n                    // Not enough space in the destination buffer so signal the caller that the buffer needs to be\n                    // increased.\n                    if (packetLengthDataOnly > MAX_RECORD_SIZE) {\n                        // The packet length MUST NOT exceed 2^14 [1]. However we do accommodate more data to support\n                        // legacy use cases which may violate this condition (e.g. OpenJDK's SslEngineImpl). If the max\n                        // length is exceeded we fail fast here to avoid an infinite loop due to the fact that we\n                        // won't allocate a buffer large enough.\n                        // [1] https://tools.ietf.org/html/rfc5246#section-6.2.1\n                        throw new SSLException(\"Illegal packet length: \" + packetLengthDataOnly + \" > \" +\n                                                session.getApplicationBufferSize());\n                    } else {\n                        session.tryExpandApplicationBufferSize(packetLengthDataOnly);\n                    }\n                    return newResultMayFinishHandshake(BUFFER_OVERFLOW, status, 0, 0);\n                }\n\n                if (len < packetLength) {\n                    // We either don't have enough data to read the packet length or not enough for reading the whole\n                    // packet.\n                    return newResultMayFinishHandshake(BUFFER_UNDERFLOW, status, 0, 0);\n                }\n            } else if (len == 0 && sslPending <= 0) {\n                return newResultMayFinishHandshake(BUFFER_UNDERFLOW, status, 0, 0);\n            } else if (capacity == 0) {\n                return newResultMayFinishHandshake(BUFFER_OVERFLOW, status, 0, 0);\n            } else {\n                packetLength = (int) min(MAX_VALUE, len);\n            }\n\n            // This must always be the case when we reached here as if not we returned BUFFER_UNDERFLOW.\n            assert srcsOffset < srcsEndOffset;\n\n            // This must always be the case if we reached here.\n            assert capacity > 0;\n\n            // Number of produced bytes\n            int bytesProduced = 0;\n            int bytesConsumed = 0;\n            try {\n                srcLoop:\n                for (;;) {\n                    ByteBuffer src = srcs[srcsOffset];\n                    int remaining = src.remaining();\n                    final ByteBuf bioWriteCopyBuf;\n                    int pendingEncryptedBytes;\n                    if (remaining == 0) {\n                        if (sslPending <= 0) {\n                            // We must skip empty buffers as BIO_write will return 0 if asked to write something\n                            // with length 0.\n                            if (++srcsOffset >= srcsEndOffset) {\n                                break;\n                            }\n                            continue;\n                        } else {\n                            bioWriteCopyBuf = null;\n                            pendingEncryptedBytes = SSL.bioLengthByteBuffer(networkBIO);\n                        }\n                    } else {\n                        // Write more encrypted data into the BIO. Ensure we only read one packet at a time as\n                        // stated in the SSLEngine javadocs.\n                        pendingEncryptedBytes = min(packetLength, remaining);\n                        try {\n                            bioWriteCopyBuf = writeEncryptedData(src, pendingEncryptedBytes);\n                        } catch (SSLException e) {\n                            // Ensure we correctly handle the error stack.\n                            return handleUnwrapException(bytesConsumed, bytesProduced, e);\n                        }\n                    }\n                    try {\n                        for (;;) {\n                            ByteBuffer dst = dsts[dstsOffset];\n                            if (!dst.hasRemaining()) {\n                                // No space left in the destination buffer, skip it.\n                                if (++dstsOffset >= dstsEndOffset) {\n                                    break srcLoop;\n                                }\n                                continue;\n                            }\n\n                            int bytesRead;\n                            try {\n                                bytesRead = readPlaintextData(dst);\n                            } catch (SSLException e) {\n                                // Ensure we correctly handle the error stack.\n                                return handleUnwrapException(bytesConsumed, bytesProduced, e);\n                            }\n                            // We are directly using the ByteBuffer memory for the write, and so we only know what has\n                            // been consumed after we let SSL decrypt the data. At this point we should update the\n                            // number of bytes consumed, update the ByteBuffer position, and release temp ByteBuf.\n                            int localBytesConsumed = pendingEncryptedBytes - SSL.bioLengthByteBuffer(networkBIO);\n                            bytesConsumed += localBytesConsumed;\n                            packetLength -= localBytesConsumed;\n                            pendingEncryptedBytes -= localBytesConsumed;\n                            src.position(src.position() + localBytesConsumed);\n\n                            if (bytesRead > 0) {\n                                bytesProduced += bytesRead;\n\n                                if (!dst.hasRemaining()) {\n                                    sslPending = sslPending0();\n                                    // Move to the next dst buffer as this one is full.\n                                    if (++dstsOffset >= dstsEndOffset) {\n                                        return sslPending > 0 ?\n                                                newResult(BUFFER_OVERFLOW, status, bytesConsumed, bytesProduced) :\n                                                newResultMayFinishHandshake(isInboundDone() ? CLOSED : OK, status,\n                                                        bytesConsumed, bytesProduced);\n                                    }\n                                } else if (packetLength == 0 || jdkCompatibilityMode) {\n                                    // We either consumed all data or we are in jdkCompatibilityMode and have consumed\n                                    // a single TLS packet and should stop consuming until this method is called again.\n                                    break srcLoop;\n                                }\n                            } else {\n                                int sslError = SSL.getError(ssl, bytesRead);\n                                if (sslError == SSL.SSL_ERROR_WANT_READ || sslError == SSL.SSL_ERROR_WANT_WRITE) {\n                                    // break to the outer loop as we want to read more data which means we need to\n                                    // write more to the BIO.\n                                    break;\n                                } else if (sslError == SSL.SSL_ERROR_ZERO_RETURN) {\n                                    // This means the connection was shutdown correctly, close inbound and outbound\n                                    if (!receivedShutdown) {\n                                        closeAll();\n                                    }\n                                    return newResultMayFinishHandshake(isInboundDone() ? CLOSED : OK, status,\n                                            bytesConsumed, bytesProduced);\n                                } else if (sslError == SSL.SSL_ERROR_WANT_X509_LOOKUP ||\n                                        sslError == SSL.SSL_ERROR_WANT_CERTIFICATE_VERIFY ||\n                                        sslError == SSL.SSL_ERROR_WANT_PRIVATE_KEY_OPERATION) {\n                                    return newResult(isInboundDone() ? CLOSED : OK,\n                                            NEED_TASK, bytesConsumed, bytesProduced);\n                                } else {\n                                    return sslReadErrorResult(sslError, SSL.getLastErrorNumber(), bytesConsumed,\n                                            bytesProduced);\n                                }\n                            }\n                        }\n\n                        if (++srcsOffset >= srcsEndOffset) {\n                            break;\n                        }\n                    } finally {\n                        if (bioWriteCopyBuf != null) {\n                            bioWriteCopyBuf.release();\n                        }\n                    }\n                }\n            } finally {\n                SSL.bioClearByteBuffer(networkBIO);\n                rejectRemoteInitiatedRenegotiation();\n            }\n\n            // Check to see if we received a close_notify message from the peer.\n            if (!receivedShutdown && (SSL.getShutdown(ssl) & SSL.SSL_RECEIVED_SHUTDOWN) == SSL.SSL_RECEIVED_SHUTDOWN) {\n                closeAll();\n            }\n\n            return newResultMayFinishHandshake(isInboundDone() ? CLOSED : OK, status, bytesConsumed, bytesProduced);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54124",
    "cwe_list": [
      "CWE-359"
    ],
    "commit_hash": "f2ca8649cba2ed3765061660bf5c7f801afa0b24",
    "short_hash": "f2ca8649",
    "vulnerableMethods_before": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilder.java",
        "method_name": "addFieldToQuery",
        "raw_code": "private void addFieldToQuery(String fieldName, String fieldAlias, boolean hasClassName, List<String> selectClause,\n        List<String> fromClause, List<String> whereClause, Map<String, Object> parameters)\n    {\n        if (fieldName.startsWith(DOC_PREFIX) || fieldName.startsWith(OBJ_PREFIX)) {\n            selectClause.add(fieldName);\n        } else if (!hasClassName) {\n            selectClause.add(DOC_PREFIX + fieldName);\n        } else {\n            selectClause.add(fieldAlias + \".value\");\n            fromClause.add(\"StringProperty as \" + fieldAlias);\n            whereClause.add(String.format(\"obj.id = %1$s.id.id and %1$s.id.name = :%1$s\", fieldAlias));\n            parameters.put(fieldAlias, fieldName);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilder.java",
        "method_name": "addFieldToQuery",
        "raw_code": "private void addFieldToQuery(String fieldName, String fieldAlias, DBListQuerySpec spec, List<String> selectClause,\n        List<String> fromClause, List<String> whereClause, Map<String, Object> parameters) throws QueryException\n    {\n        if (fieldName.startsWith(DOC_PREFIX) || fieldName.startsWith(OBJ_PREFIX)) {\n            checkSimpleFieldName(fieldName);\n            selectClause.add(fieldName);\n        } else if (!spec.hasClassName) {\n            checkSimpleFieldName(fieldName);\n            selectClause.add(DOC_PREFIX + fieldName);\n        } else {\n            try {\n                // Only load the XClass when really needed.\n                if (spec.xClass == null) {\n                    // Resolve the reference relative to the specified wiki.\n                    DocumentReference classReference = this.documentReferenceResolver.resolve(spec.className,\n                        new WikiReference(spec.wiki));\n                    XWikiContext xWikiContext = this.contextProvider.get();\n                    spec.xClass = xWikiContext.getWiki().getXClass(classReference, xWikiContext);\n                }\n\n                PropertyInterface propertyInterface = spec.xClass.get(fieldName);\n                if (propertyInterface instanceof PasswordClass) {\n                    throw new QueryException(\"Queries for password field [%s] on class [%s] aren't allowed\"\n                        .formatted(fieldName, spec.className), null);\n                } else if (propertyInterface instanceof EmailClass && this.mailConfiguration.shouldObfuscate()) {\n                    throw new QueryException((\"Queries for email property [%s] on class [%s] aren't allowed as email \"\n                        + \"obfuscation is enabled.\").formatted(fieldName, spec.className), null);\n                }\n                selectClause.add(fieldAlias + \".value\");\n                fromClause.add(\"StringProperty as \" + fieldAlias);\n                whereClause.add(String.format(\"obj.id = %1$s.id.id and %1$s.id.name = :%1$s\", fieldAlias));\n                parameters.put(fieldAlias, fieldName);\n            } catch (XWikiException e) {\n                throw new QueryException(\"Failed to get the XClass definition\", null, e);\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54124",
    "cwe_list": [
      "CWE-359"
    ],
    "commit_hash": "f2ca8649cba2ed3765061660bf5c7f801afa0b24",
    "short_hash": "f2ca8649",
    "vulnerableMethods_before": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilder.java",
        "method_name": "getStatementWhenIdOrValueFieldsAreSpecified",
        "raw_code": "private String getStatementWhenIdOrValueFieldsAreSpecified(DBListQuerySpec spec, Map<String, Object> parameters)\n    {\n        // Make sure we always have an id field. Ignore the value field if it duplicates the id field and there's no\n        // parent field specified.\n        if (!spec.hasIdField || (spec.idField.equals(spec.valueField) && !spec.hasParentField)) {\n            // If the parent field is specified then we need to include the value field, even if it duplicates the id\n            // field, because otherwise we can't distinguish between the value and the parent.\n            spec.idField = spec.valueField;\n            spec.hasIdField = true;\n            spec.valueField = spec.hasParentField ? spec.valueField : \"\";\n            spec.hasValueField = spec.hasParentField;\n        } else if (!spec.hasValueField && spec.hasParentField) {\n            // Same as above, we need to include the value field when the parent field is specified.\n            spec.valueField = spec.idField;\n            spec.hasValueField = true;\n        }\n\n        return getStatementWhenIdFieldIsSpecified(spec, parameters);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilder.java",
        "method_name": "getStatementWhenIdOrValueFieldsAreSpecified",
        "raw_code": "private String getStatementWhenIdOrValueFieldsAreSpecified(DBListQuerySpec spec, Map<String, Object> parameters)\n        throws QueryException\n    {\n        // Make sure we always have an id field. Ignore the value field if it duplicates the id field and there's no\n        // parent field specified.\n        if (!spec.hasIdField || (spec.idField.equals(spec.valueField) && !spec.hasParentField)) {\n            // If the parent field is specified then we need to include the value field, even if it duplicates the id\n            // field, because otherwise we can't distinguish between the value and the parent.\n            spec.idField = spec.valueField;\n            spec.hasIdField = true;\n            spec.valueField = spec.hasParentField ? spec.valueField : \"\";\n            spec.hasValueField = spec.hasParentField;\n        } else if (!spec.hasValueField && spec.hasParentField) {\n            // Same as above, we need to include the value field when the parent field is specified.\n            spec.valueField = spec.idField;\n            spec.hasValueField = true;\n        }\n\n        return getStatementWhenIdFieldIsSpecified(spec, parameters);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54124",
    "cwe_list": [
      "CWE-359"
    ],
    "commit_hash": "f2ca8649cba2ed3765061660bf5c7f801afa0b24",
    "short_hash": "f2ca8649",
    "vulnerableMethods_before": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilder.java",
        "method_name": "getStatementWhenIdFieldIsSpecified",
        "raw_code": "private String getStatementWhenIdFieldIsSpecified(DBListQuerySpec spec, Map<String, Object> parameters)\n    {\n        List<String> selectClause = new ArrayList<>();\n        List<String> fromClause = new ArrayList<>();\n        List<String> whereClause = new ArrayList<>();\n\n        // We need to select the document in order to be able to check access rights on the results. At the same time we\n        // want to skip this column when filtering the Database List property values.\n        selectClause.add(\"doc.fullName as unfilterable0\");\n        fromClause.add(\"XWikiDocument as doc\");\n\n        // We need to join the objects table if the class name is specified or if one of the selected columns is an\n        // object property.\n        if (spec.hasClassName || spec.idField.startsWith(OBJ_PREFIX) || spec.valueField.startsWith(OBJ_PREFIX)\n            || spec.parentField.startsWith(OBJ_PREFIX)) {\n            fromClause.add(\"BaseObject as obj\");\n            whereClause.add(\"doc.fullName = obj.name\");\n            if (spec.hasClassName) {\n                whereClause.add(\"obj.className = :className and doc.fullName <> :templateName\");\n                parameters.put(CLASS_NAME, spec.className);\n                parameters.put(TEMPLATE_NAME, getTemplateName(spec.className));\n            }\n        }\n\n        addFieldToQuery(spec.idField, \"idProp\", spec.hasClassName, selectClause, fromClause, whereClause, parameters);\n\n        if (spec.hasValueField) {\n            addFieldToQuery(spec.valueField, \"valueProp\", spec.hasClassName, selectClause, fromClause, whereClause,\n                parameters);\n\n            // We cannot include the parent field if there's no value field because we would confuse it with the value\n            // field (the second column in the result set is reserved for the value).\n            if (spec.hasParentField) {\n                addFieldToQuery(spec.parentField, \"parentProp\", spec.hasClassName, selectClause, fromClause,\n                    whereClause, parameters);\n            }\n        }\n\n        StringBuilder statementBuilder =\n            new StringBuilder(\"select distinct \").append(StringUtils.join(selectClause, COLUMN_SEPARATOR))\n                .append(\" from \").append(StringUtils.join(fromClause, COLUMN_SEPARATOR));\n        if (whereClause.size() > 0) {\n            statementBuilder.append(\" where \").append(StringUtils.join(whereClause, \" and \"));\n        }\n\n        return statementBuilder.toString();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilder.java",
        "method_name": "getStatementWhenIdFieldIsSpecified",
        "raw_code": "private String getStatementWhenIdFieldIsSpecified(DBListQuerySpec spec, Map<String, Object> parameters)\n        throws QueryException\n    {\n        List<String> selectClause = new ArrayList<>();\n        List<String> fromClause = new ArrayList<>();\n        List<String> whereClause = new ArrayList<>();\n\n        // We need to select the document in order to be able to check access rights on the results. At the same time we\n        // want to skip this column when filtering the Database List property values.\n        selectClause.add(\"doc.fullName as unfilterable0\");\n        fromClause.add(\"XWikiDocument as doc\");\n\n        // We need to join the objects table if the class name is specified or if one of the selected columns is an\n        // object property.\n        if (spec.hasClassName || spec.idField.startsWith(OBJ_PREFIX) || spec.valueField.startsWith(OBJ_PREFIX)\n            || spec.parentField.startsWith(OBJ_PREFIX)) {\n            fromClause.add(\"BaseObject as obj\");\n            whereClause.add(\"doc.fullName = obj.name\");\n            if (spec.hasClassName) {\n                whereClause.add(\"obj.className = :className and doc.fullName <> :templateName\");\n                parameters.put(CLASS_NAME, spec.className);\n                parameters.put(TEMPLATE_NAME, getTemplateName(spec.className));\n            }\n        }\n\n        addFieldToQuery(spec.idField, \"idProp\", spec, selectClause, fromClause, whereClause, parameters);\n\n        if (spec.hasValueField) {\n            addFieldToQuery(spec.valueField, \"valueProp\", spec, selectClause, fromClause, whereClause,\n                parameters);\n\n            // We cannot include the parent field if there's no value field because we would confuse it with the value\n            // field (the second column in the result set is reserved for the value).\n            if (spec.hasParentField) {\n                addFieldToQuery(spec.parentField, \"parentProp\", spec, selectClause, fromClause,\n                    whereClause, parameters);\n            }\n        }\n\n        StringBuilder statementBuilder =\n            new StringBuilder(\"select distinct \").append(StringUtils.join(selectClause, COLUMN_SEPARATOR))\n                .append(\" from \").append(StringUtils.join(fromClause, COLUMN_SEPARATOR));\n        if (whereClause.size() > 0) {\n            statementBuilder.append(\" where \").append(StringUtils.join(whereClause, \" and \"));\n        }\n\n        return statementBuilder.toString();\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54124",
    "cwe_list": [
      "CWE-359"
    ],
    "commit_hash": "f2ca8649cba2ed3765061660bf5c7f801afa0b24",
    "short_hash": "f2ca8649",
    "vulnerableMethods_before": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilderTest.java",
        "method_name": "configure",
        "raw_code": "@Before\n    public void configure() throws Exception\n    {\n        this.queryManager = this.mocker.getInstance(QueryManager.class);\n        this.viewableValueFilter = this.mocker.getInstance(QueryFilter.class, \"viewableAllowedDBListPropertyValue\");\n\n        XWikiDocument ownerDocument = mock(XWikiDocument.class);\n        when(ownerDocument.getDocumentReference()).thenReturn(new DocumentReference(\"tests\", \"Some\", \"Page\"));\n        this.dbListClass.setOwnerDocument(ownerDocument);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilderTest.java",
        "method_name": "configure",
        "raw_code": "@BeforeEach\n    void configure()\n    {\n        XWikiDocument ownerDocument = mock(XWikiDocument.class);\n        when(ownerDocument.getDocumentReference()).thenReturn(new DocumentReference(\"tests\", \"Some\", \"Page\"));\n        this.dbListClass.setOwnerDocument(ownerDocument);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54124",
    "cwe_list": [
      "CWE-359"
    ],
    "commit_hash": "f2ca8649cba2ed3765061660bf5c7f801afa0b24",
    "short_hash": "f2ca8649",
    "vulnerableMethods_before": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilderTest.java",
        "method_name": "assertQuery",
        "raw_code": "private Query assertQuery(String statement) throws Exception\n    {\n        Query query = mock(Query.class);\n        when(this.queryManager.createQuery(statement, Query.HQL)).thenReturn(query);\n\n        assertSame(query, this.mocker.getComponentUnderTest().build(this.dbListClass));\n        return query;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilderTest.java",
        "method_name": "assertQuery",
        "raw_code": "private Query assertQuery(String statement) throws Exception\n    {\n        Query query = mock(Query.class);\n        when(this.queryManager.createQuery(statement, Query.HQL)).thenReturn(query);\n\n        assertSame(query, this.implicitlyAllowedValuesDBListQueryBuilder.build(this.dbListClass));\n        return query;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54124",
    "cwe_list": [
      "CWE-359"
    ],
    "commit_hash": "f2ca8649cba2ed3765061660bf5c7f801afa0b24",
    "short_hash": "f2ca8649",
    "vulnerableMethods_before": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilderTest.java",
        "method_name": "buildDefaultQuery",
        "raw_code": "@Test\n    public void buildDefaultQuery() throws Exception\n    {\n        Query query = assertQuery(\"select doc.name from XWikiDocument doc where 1 = 0\");\n\n        verify(query).setWiki(\"tests\");\n        verify(query).addFilter(this.viewableValueFilter);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilderTest.java",
        "method_name": "buildDefaultQuery",
        "raw_code": "@Test\n    void buildDefaultQuery() throws Exception\n    {\n        Query query = assertQuery(\"select doc.name from XWikiDocument doc where 1 = 0\");\n\n        verify(query).setWiki(\"tests\");\n        verify(query).addFilter(this.viewableValueFilter);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54124",
    "cwe_list": [
      "CWE-359"
    ],
    "commit_hash": "f2ca8649cba2ed3765061660bf5c7f801afa0b24",
    "short_hash": "f2ca8649",
    "vulnerableMethods_before": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilderTest.java",
        "method_name": "buildWithClassName",
        "raw_code": "@Test\n    public void buildWithClassName() throws Exception\n    {\n        this.dbListClass.setClassname(\"Blog.CategoryClass\");\n\n        Query query = assertQuery(\"select distinct doc.fullName from XWikiDocument as doc, BaseObject as obj\"\n            + \" where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName\");\n\n        verify(query).bindValue(\"className\", \"Blog.CategoryClass\");\n        verify(query).bindValue(\"templateName\", \"Blog.CategoryTemplate\");\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilderTest.java",
        "method_name": "buildWithClassName",
        "raw_code": "@Test\n    void buildWithClassName() throws Exception\n    {\n        this.dbListClass.setClassname(\"Blog.CategoryClass\");\n\n        Query query = assertQuery(\"select distinct doc.fullName from XWikiDocument as doc, BaseObject as obj\"\n            + \" where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName\");\n\n        verify(query).bindValue(\"className\", \"Blog.CategoryClass\");\n        verify(query).bindValue(\"templateName\", \"Blog.CategoryTemplate\");\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54124",
    "cwe_list": [
      "CWE-359"
    ],
    "commit_hash": "f2ca8649cba2ed3765061660bf5c7f801afa0b24",
    "short_hash": "f2ca8649",
    "vulnerableMethods_before": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilderTest.java",
        "method_name": "buildWithId",
        "raw_code": "@Test\n    public void buildWithId() throws Exception\n    {\n        this.dbListClass.setIdField(\"doc.name\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.name from XWikiDocument as doc\");\n\n        this.dbListClass.setIdField(\"obj.className\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, obj.className \"\n            + \"from XWikiDocument as doc, BaseObject as obj \" + \"where doc.fullName = obj.name\");\n\n        this.dbListClass.setIdField(\"property\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.property from XWikiDocument as doc\");\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilderTest.java",
        "method_name": "buildWithId",
        "raw_code": "@Test\n    void buildWithId() throws Exception\n    {\n        this.dbListClass.setIdField(\"doc.name\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.name from XWikiDocument as doc\");\n\n        this.dbListClass.setIdField(\"obj.className\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, obj.className \"\n            + \"from XWikiDocument as doc, BaseObject as obj \" + \"where doc.fullName = obj.name\");\n\n        this.dbListClass.setIdField(\"property\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.property from XWikiDocument as doc\");\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54124",
    "cwe_list": [
      "CWE-359"
    ],
    "commit_hash": "f2ca8649cba2ed3765061660bf5c7f801afa0b24",
    "short_hash": "f2ca8649",
    "vulnerableMethods_before": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilderTest.java",
        "method_name": "buildWithValue",
        "raw_code": "@Test\n    public void buildWithValue() throws Exception\n    {\n        this.dbListClass.setValueField(\"doc.name\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.name from XWikiDocument as doc\");\n\n        this.dbListClass.setValueField(\"obj.className\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, obj.className \"\n            + \"from XWikiDocument as doc, BaseObject as obj \" + \"where doc.fullName = obj.name\");\n\n        this.dbListClass.setValueField(\"property\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.property from XWikiDocument as doc\");\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilderTest.java",
        "method_name": "buildWithValue",
        "raw_code": "@Test\n    void buildWithValue() throws Exception\n    {\n        this.dbListClass.setValueField(\"doc.name\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.name from XWikiDocument as doc\");\n\n        this.dbListClass.setValueField(\"obj.className\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, obj.className \"\n            + \"from XWikiDocument as doc, BaseObject as obj \" + \"where doc.fullName = obj.name\");\n\n        this.dbListClass.setValueField(\"property\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.property from XWikiDocument as doc\");\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54124",
    "cwe_list": [
      "CWE-359"
    ],
    "commit_hash": "f2ca8649cba2ed3765061660bf5c7f801afa0b24",
    "short_hash": "f2ca8649",
    "vulnerableMethods_before": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilderTest.java",
        "method_name": "buildWithIdAndClassName",
        "raw_code": "@Test\n    public void buildWithIdAndClassName() throws Exception\n    {\n        this.dbListClass.setClassname(\"XWiki.XWikiUsers\");\n        this.dbListClass.setIdField(\"doc.name\");\n        Query query = assertQuery(\n            \"select distinct doc.fullName as unfilterable0, doc.name \" + \"from XWikiDocument as doc, BaseObject as obj \"\n                + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName\");\n        verify(query).bindValue(\"className\", \"XWiki.XWikiUsers\");\n        verify(query).bindValue(\"templateName\", \"XWiki.XWikiUsersTemplate\");\n\n        this.dbListClass.setIdField(\"obj.className\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, obj.className \"\n            + \"from XWikiDocument as doc, BaseObject as obj \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName\");\n\n        this.dbListClass.setIdField(\"property\");\n        query = assertQuery(\"select distinct doc.fullName as unfilterable0, idProp.value \"\n            + \"from XWikiDocument as doc, BaseObject as obj, StringProperty as idProp \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName\"\n            + \" and obj.id = idProp.id.id and idProp.id.name = :idProp\");\n        verify(query).bindValue(\"idProp\", \"property\");\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilderTest.java",
        "method_name": "buildWithIdAndClassName",
        "raw_code": "@Test\n    void buildWithIdAndClassName() throws Exception\n    {\n        this.dbListClass.setClassname(\"XWiki.XWikiUsers\");\n        this.dbListClass.setIdField(\"doc.name\");\n        Query query = assertQuery(\n            \"select distinct doc.fullName as unfilterable0, doc.name \" + \"from XWikiDocument as doc, BaseObject as obj \"\n                + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName\");\n        verify(query).bindValue(\"className\", \"XWiki.XWikiUsers\");\n        verify(query).bindValue(\"templateName\", \"XWiki.XWikiUsersTemplate\");\n\n        this.dbListClass.setIdField(\"obj.className\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, obj.className \"\n            + \"from XWikiDocument as doc, BaseObject as obj \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName\");\n\n        this.dbListClass.setIdField(\"property\");\n        query = assertQuery(\"select distinct doc.fullName as unfilterable0, idProp.value \"\n            + \"from XWikiDocument as doc, BaseObject as obj, StringProperty as idProp \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName\"\n            + \" and obj.id = idProp.id.id and idProp.id.name = :idProp\");\n        verify(query).bindValue(\"idProp\", \"property\");\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54124",
    "cwe_list": [
      "CWE-359"
    ],
    "commit_hash": "f2ca8649cba2ed3765061660bf5c7f801afa0b24",
    "short_hash": "f2ca8649",
    "vulnerableMethods_before": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilderTest.java",
        "method_name": "buildWithIdAndValue",
        "raw_code": "@Test\n    public void buildWithIdAndValue() throws Exception\n    {\n        this.dbListClass.setIdField(\"doc.name\");\n        this.dbListClass.setValueField(\"doc.name\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.name from XWikiDocument as doc\");\n\n        this.dbListClass.setValueField(\"doc.creator\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.name, doc.creator from XWikiDocument as doc\");\n\n        this.dbListClass.setValueField(\"obj.className\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.name, obj.className \"\n            + \"from XWikiDocument as doc, BaseObject as obj where doc.fullName = obj.name\");\n\n        this.dbListClass.setValueField(\"property\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.name, doc.property from XWikiDocument as doc\");\n\n        this.dbListClass.setIdField(\"obj.className\");\n        this.dbListClass.setValueField(\"doc.name\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, obj.className, doc.name \"\n            + \"from XWikiDocument as doc, BaseObject as obj where doc.fullName = obj.name\");\n\n        this.dbListClass.setValueField(\"obj.className\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, obj.className \"\n            + \"from XWikiDocument as doc, BaseObject as obj where doc.fullName = obj.name\");\n\n        this.dbListClass.setValueField(\"obj.id\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, obj.className, obj.id \"\n            + \"from XWikiDocument as doc, BaseObject as obj where doc.fullName = obj.name\");\n\n        this.dbListClass.setValueField(\"property\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, obj.className, doc.property \"\n            + \"from XWikiDocument as doc, BaseObject as obj where doc.fullName = obj.name\");\n\n        this.dbListClass.setIdField(\"property\");\n        this.dbListClass.setValueField(\"doc.name\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.property, doc.name from XWikiDocument as doc\");\n\n        this.dbListClass.setValueField(\"obj.className\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.property, obj.className \"\n            + \"from XWikiDocument as doc, BaseObject as obj where doc.fullName = obj.name\");\n\n        this.dbListClass.setValueField(\"property\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.property from XWikiDocument as doc\");\n\n        this.dbListClass.setValueField(\"otherProperty\");\n        assertQuery(\n            \"select distinct doc.fullName as unfilterable0, doc.property, doc.otherProperty from XWikiDocument as doc\");\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilderTest.java",
        "method_name": "buildWithIdAndValue",
        "raw_code": "@Test\n    void buildWithIdAndValue() throws Exception\n    {\n        this.dbListClass.setIdField(\"doc.name\");\n        this.dbListClass.setValueField(\"doc.name\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.name from XWikiDocument as doc\");\n\n        this.dbListClass.setValueField(\"doc.creator\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.name, doc.creator from XWikiDocument as doc\");\n\n        this.dbListClass.setValueField(\"obj.className\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.name, obj.className \"\n            + \"from XWikiDocument as doc, BaseObject as obj where doc.fullName = obj.name\");\n\n        this.dbListClass.setValueField(\"property\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.name, doc.property from XWikiDocument as doc\");\n\n        this.dbListClass.setIdField(\"obj.className\");\n        this.dbListClass.setValueField(\"doc.name\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, obj.className, doc.name \"\n            + \"from XWikiDocument as doc, BaseObject as obj where doc.fullName = obj.name\");\n\n        this.dbListClass.setValueField(\"obj.className\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, obj.className \"\n            + \"from XWikiDocument as doc, BaseObject as obj where doc.fullName = obj.name\");\n\n        this.dbListClass.setValueField(\"obj.id\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, obj.className, obj.id \"\n            + \"from XWikiDocument as doc, BaseObject as obj where doc.fullName = obj.name\");\n\n        this.dbListClass.setValueField(\"property\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, obj.className, doc.property \"\n            + \"from XWikiDocument as doc, BaseObject as obj where doc.fullName = obj.name\");\n\n        this.dbListClass.setIdField(\"property\");\n        this.dbListClass.setValueField(\"doc.name\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.property, doc.name from XWikiDocument as doc\");\n\n        this.dbListClass.setValueField(\"obj.className\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.property, obj.className \"\n            + \"from XWikiDocument as doc, BaseObject as obj where doc.fullName = obj.name\");\n\n        this.dbListClass.setValueField(\"property\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.property from XWikiDocument as doc\");\n\n        this.dbListClass.setValueField(\"otherProperty\");\n        assertQuery(\n            \"select distinct doc.fullName as unfilterable0, doc.property, doc.otherProperty from XWikiDocument as doc\");\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54124",
    "cwe_list": [
      "CWE-359"
    ],
    "commit_hash": "f2ca8649cba2ed3765061660bf5c7f801afa0b24",
    "short_hash": "f2ca8649",
    "vulnerableMethods_before": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilderTest.java",
        "method_name": "buildWithIdValueAndClassName",
        "raw_code": "@Test\n    public void buildWithIdValueAndClassName() throws Exception\n    {\n        this.dbListClass.setClassname(\"XWiki.TagClass\");\n        this.dbListClass.setIdField(\"doc.name\");\n        this.dbListClass.setValueField(\"doc.name\");\n        assertQuery(\n            \"select distinct doc.fullName as unfilterable0, doc.name \" + \"from XWikiDocument as doc, BaseObject as obj \"\n                + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName\");\n\n        this.dbListClass.setValueField(\"doc.creator\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.name, doc.creator \"\n            + \"from XWikiDocument as doc, BaseObject as obj \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName\");\n\n        this.dbListClass.setValueField(\"obj.className\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.name, obj.className \"\n            + \"from XWikiDocument as doc, BaseObject as obj \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName\");\n\n        this.dbListClass.setValueField(\"property\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.name, valueProp.value \"\n            + \"from XWikiDocument as doc, BaseObject as obj, StringProperty as valueProp \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName \"\n            + \"and obj.id = valueProp.id.id and valueProp.id.name = :valueProp\");\n\n        this.dbListClass.setIdField(\"obj.className\");\n        this.dbListClass.setValueField(\"doc.name\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, obj.className, doc.name \"\n            + \"from XWikiDocument as doc, BaseObject as obj \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName\");\n\n        this.dbListClass.setValueField(\"obj.className\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, obj.className \"\n            + \"from XWikiDocument as doc, BaseObject as obj \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName\");\n\n        this.dbListClass.setValueField(\"obj.id\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, obj.className, obj.id \"\n            + \"from XWikiDocument as doc, BaseObject as obj \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName\");\n\n        this.dbListClass.setValueField(\"property\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, obj.className, valueProp.value \"\n            + \"from XWikiDocument as doc, BaseObject as obj, StringProperty as valueProp \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName \"\n            + \"and obj.id = valueProp.id.id and valueProp.id.name = :valueProp\");\n\n        this.dbListClass.setIdField(\"property\");\n        this.dbListClass.setValueField(\"doc.name\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, idProp.value, doc.name \"\n            + \"from XWikiDocument as doc, BaseObject as obj, StringProperty as idProp \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName \"\n            + \"and obj.id = idProp.id.id and idProp.id.name = :idProp\");\n\n        this.dbListClass.setValueField(\"obj.className\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, idProp.value, obj.className \"\n            + \"from XWikiDocument as doc, BaseObject as obj, StringProperty as idProp \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName \"\n            + \"and obj.id = idProp.id.id and idProp.id.name = :idProp\");\n\n        this.dbListClass.setValueField(\"property\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, idProp.value \"\n            + \"from XWikiDocument as doc, BaseObject as obj, StringProperty as idProp \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName \"\n            + \"and obj.id = idProp.id.id and idProp.id.name = :idProp\");\n\n        this.dbListClass.setValueField(\"otherProperty\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, idProp.value, valueProp.value \"\n            + \"from XWikiDocument as doc, BaseObject as obj, StringProperty as idProp, StringProperty as valueProp \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName \"\n            + \"and obj.id = idProp.id.id and idProp.id.name = :idProp \"\n            + \"and obj.id = valueProp.id.id and valueProp.id.name = :valueProp\");\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilderTest.java",
        "method_name": "buildWithIdValueAndClassName",
        "raw_code": "@Test\n    void buildWithIdValueAndClassName() throws Exception\n    {\n        this.dbListClass.setClassname(\"XWiki.TagClass\");\n        this.dbListClass.setIdField(\"doc.name\");\n        this.dbListClass.setValueField(\"doc.name\");\n        assertQuery(\n            \"select distinct doc.fullName as unfilterable0, doc.name \" + \"from XWikiDocument as doc, BaseObject as obj \"\n                + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName\");\n\n        this.dbListClass.setValueField(\"doc.creator\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.name, doc.creator \"\n            + \"from XWikiDocument as doc, BaseObject as obj \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName\");\n\n        this.dbListClass.setValueField(\"obj.className\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.name, obj.className \"\n            + \"from XWikiDocument as doc, BaseObject as obj \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName\");\n\n        this.dbListClass.setValueField(\"property\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.name, valueProp.value \"\n            + \"from XWikiDocument as doc, BaseObject as obj, StringProperty as valueProp \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName \"\n            + \"and obj.id = valueProp.id.id and valueProp.id.name = :valueProp\");\n\n        this.dbListClass.setIdField(\"obj.className\");\n        this.dbListClass.setValueField(\"doc.name\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, obj.className, doc.name \"\n            + \"from XWikiDocument as doc, BaseObject as obj \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName\");\n\n        this.dbListClass.setValueField(\"obj.className\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, obj.className \"\n            + \"from XWikiDocument as doc, BaseObject as obj \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName\");\n\n        this.dbListClass.setValueField(\"obj.id\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, obj.className, obj.id \"\n            + \"from XWikiDocument as doc, BaseObject as obj \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName\");\n\n        this.dbListClass.setValueField(\"property\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, obj.className, valueProp.value \"\n            + \"from XWikiDocument as doc, BaseObject as obj, StringProperty as valueProp \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName \"\n            + \"and obj.id = valueProp.id.id and valueProp.id.name = :valueProp\");\n\n        this.dbListClass.setIdField(\"property\");\n        this.dbListClass.setValueField(\"doc.name\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, idProp.value, doc.name \"\n            + \"from XWikiDocument as doc, BaseObject as obj, StringProperty as idProp \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName \"\n            + \"and obj.id = idProp.id.id and idProp.id.name = :idProp\");\n\n        this.dbListClass.setValueField(\"obj.className\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, idProp.value, obj.className \"\n            + \"from XWikiDocument as doc, BaseObject as obj, StringProperty as idProp \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName \"\n            + \"and obj.id = idProp.id.id and idProp.id.name = :idProp\");\n\n        this.dbListClass.setValueField(\"property\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, idProp.value \"\n            + \"from XWikiDocument as doc, BaseObject as obj, StringProperty as idProp \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName \"\n            + \"and obj.id = idProp.id.id and idProp.id.name = :idProp\");\n\n        this.dbListClass.setValueField(\"otherProperty\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, idProp.value, valueProp.value \"\n            + \"from XWikiDocument as doc, BaseObject as obj, StringProperty as idProp, StringProperty as valueProp \"\n            + \"where doc.fullName = obj.name and obj.className = :className and doc.fullName <> :templateName \"\n            + \"and obj.id = idProp.id.id and idProp.id.name = :idProp \"\n            + \"and obj.id = valueProp.id.id and valueProp.id.name = :valueProp\");\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54124",
    "cwe_list": [
      "CWE-359"
    ],
    "commit_hash": "f2ca8649cba2ed3765061660bf5c7f801afa0b24",
    "short_hash": "f2ca8649",
    "vulnerableMethods_before": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilderTest.java",
        "method_name": "buildWithParent",
        "raw_code": "@Test\n    public void buildWithParent() throws Exception\n    {\n        DBTreeListClass dbTreeListClass = new DBTreeListClass();\n        dbTreeListClass.setOwnerDocument(this.dbListClass.getOwnerDocument());\n        dbTreeListClass.setParentField(\"parent\");\n\n        this.dbListClass = dbTreeListClass;\n        assertQuery(\"select doc.name from XWikiDocument doc where 1 = 0\");\n\n        this.dbListClass.setIdField(\"doc.fullName\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.fullName, doc.fullName, doc.parent\"\n            + \" from XWikiDocument as doc\");\n\n        this.dbListClass.setIdField(\"\");\n        this.dbListClass.setValueField(\"title\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.title, doc.title, doc.parent\"\n            + \" from XWikiDocument as doc\");\n        \n        this.dbListClass.setIdField(\"title\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.title, doc.title, doc.parent\"\n            + \" from XWikiDocument as doc\");\n\n        this.dbListClass.setIdField(\"fullName\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.fullName, doc.title, doc.parent\"\n            + \" from XWikiDocument as doc\");\n\n        this.dbListClass.setClassname(\"XWiki.TagClass\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, idProp.value, valueProp.value, parentProp.value\"\n            + \" from XWikiDocument as doc, BaseObject as obj, StringProperty as idProp, StringProperty as valueProp,\"\n            + \" StringProperty as parentProp where doc.fullName = obj.name and obj.className = :className and\"\n            + \" doc.fullName <> :templateName and obj.id = idProp.id.id and idProp.id.name = :idProp and\"\n            + \" obj.id = valueProp.id.id and valueProp.id.name = :valueProp and obj.id = parentProp.id.id and\"\n            + \" parentProp.id.name = :parentProp\");\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ImplicitlyAllowedValuesDBListQueryBuilderTest.java",
        "method_name": "buildWithParent",
        "raw_code": "@Test\n    void buildWithParent() throws Exception\n    {\n        DBTreeListClass dbTreeListClass = new DBTreeListClass();\n        dbTreeListClass.setOwnerDocument(this.dbListClass.getOwnerDocument());\n        dbTreeListClass.setParentField(\"parent\");\n\n        this.dbListClass = dbTreeListClass;\n        assertQuery(\"select doc.name from XWikiDocument doc where 1 = 0\");\n\n        this.dbListClass.setIdField(\"doc.fullName\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.fullName, doc.fullName, doc.parent\"\n            + \" from XWikiDocument as doc\");\n\n        this.dbListClass.setIdField(\"\");\n        this.dbListClass.setValueField(\"title\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.title, doc.title, doc.parent\"\n            + \" from XWikiDocument as doc\");\n\n        this.dbListClass.setIdField(\"title\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.title, doc.title, doc.parent\"\n            + \" from XWikiDocument as doc\");\n\n        this.dbListClass.setIdField(\"fullName\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, doc.fullName, doc.title, doc.parent\"\n            + \" from XWikiDocument as doc\");\n\n        this.dbListClass.setClassname(\"XWiki.TagClass\");\n        assertQuery(\"select distinct doc.fullName as unfilterable0, idProp.value, valueProp.value, parentProp.value\"\n            + \" from XWikiDocument as doc, BaseObject as obj, StringProperty as idProp, StringProperty as valueProp,\"\n            + \" StringProperty as parentProp where doc.fullName = obj.name and obj.className = :className and\"\n            + \" doc.fullName <> :templateName and obj.id = idProp.id.id and idProp.id.name = :idProp and\"\n            + \" obj.id = valueProp.id.id and valueProp.id.name = :valueProp and obj.id = parentProp.id.id and\"\n            + \" parentProp.id.name = :parentProp\");\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "solon",
    "cve_id": "CVE-2025-1584",
    "cwe_list": [
      "CWE-24"
    ],
    "commit_hash": "f46e47fd1f8455b9467d7ead3cdb0509115b2ef1",
    "short_hash": "f46e47fd",
    "vulnerableMethods_before": [
      {
        "filename": "StaticMappings.java",
        "method_name": "find",
        "raw_code": "public static URL find(String path) throws Exception {\n        URL rst = null;\n\n        for (StaticLocation m : locationMap.values()) {\n            if (path.startsWith(m.pathPrefix)) {\n                if (m.repositoryIncPrefix) {\n                    //path = /demo/file.htm\n                    //relativePath = demo/file.htm （没有'/'开头）\n                    rst = m.repository.find(path.substring(1));\n                } else {\n                    //path = /demo/file.htm\n                    //relativePath = demo/file.htm （没有'/'开头）\n                    if (m.pathPrefixAsFile) {\n                        //如果是文件\n                        int idx = m.pathPrefix.lastIndexOf(\"/\");\n                        rst = m.repository.find(m.pathPrefix.substring(idx + 1));\n                    } else {\n                        //如果是路段\n                        rst = m.repository.find(path.substring(m.pathPrefix.length()));\n                    }\n                }\n\n                if (rst != null) {\n                    return rst;\n                }\n            }\n        }\n\n        return rst;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "StaticMappings.java",
        "method_name": "find",
        "raw_code": "public static URL find(String path) throws Exception {\n        URL rst = null;\n\n        if (path.contains(\"/../\") == false) {\n            // '/../' 不安全，禁止进入静态资料库\n            for (StaticLocation m : locationMap.values()) {\n                if (path.startsWith(m.pathPrefix)) {\n                    if (m.repositoryIncPrefix) {\n                        //path = /demo/file.htm\n                        //relativePath = demo/file.htm （没有'/'开头）\n                        rst = m.repository.find(path.substring(1));\n                    } else {\n                        //path = /demo/file.htm\n                        //relativePath = demo/file.htm （没有'/'开头）\n                        if (m.pathPrefixAsFile) {\n                            //如果是文件\n                            int idx = m.pathPrefix.lastIndexOf(\"/\");\n                            rst = m.repository.find(m.pathPrefix.substring(idx + 1));\n                        } else {\n                            //如果是路段\n                            rst = m.repository.find(path.substring(m.pathPrefix.length()));\n                        }\n                    }\n\n                    if (rst != null) {\n                        return rst;\n                    }\n                }\n            }\n        }\n\n        return rst;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "local-s3",
    "cve_id": "CVE-2025-27136",
    "cwe_list": [
      "CWE-611"
    ],
    "commit_hash": "d6ed756ceb30c1eb9d4263321ac683d734f8836f",
    "short_hash": "d6ed756c",
    "vulnerableMethods_before": [
      {
        "filename": "LocalS3.java",
        "method_name": "createServiceFactory",
        "raw_code": "private ServiceFactory createServiceFactory() {\n\n    LocalS3Manager manager;\n    if (mode == LocalS3Mode.IN_MEMORY) {\n      log.info(\"Created in-memory LocalS3 manager.\");\n      manager = LocalS3Manager.createInMemoryS3Manager(dataPath, initialDataCacheEnabled);\n    } else {\n      log.info(\"Created file system LocalS3 manager.\");\n      manager = LocalS3Manager.createFileSystemS3Manager(dataPath);\n    }\n\n    ServiceFactory serviceFactory = new DefaultServiceFactory();\n    BucketService bucketService = manager.bucketService();\n    ObjectService objectService = manager.objectService();\n    serviceFactory.register(BucketService.class, () -> bucketService);\n    serviceFactory.register(ObjectService.class, () -> objectService);\n\n    XMLInputFactory input = new WstxInputFactory();\n    input.setProperty(XMLInputFactory.IS_NAMESPACE_AWARE, Boolean.FALSE);\n    XmlMapper xmlMapper = new XmlMapper(new XmlFactory(input, new WstxOutputFactory()));\n    xmlMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n    xmlMapper.registerModule(new Jdk8Module());\n    xmlMapper.registerModule(new JavaTimeModule());\n    serviceFactory.register(XmlMapper.class, () -> xmlMapper);\n    return serviceFactory;\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "LocalS3.java",
        "method_name": "createServiceFactory",
        "raw_code": "private ServiceFactory createServiceFactory() {\n\n    LocalS3Manager manager;\n    if (mode == LocalS3Mode.IN_MEMORY) {\n      log.info(\"Created in-memory LocalS3 manager.\");\n      manager = LocalS3Manager.createInMemoryS3Manager(dataPath, initialDataCacheEnabled);\n    } else {\n      log.info(\"Created file system LocalS3 manager.\");\n      manager = LocalS3Manager.createFileSystemS3Manager(dataPath);\n    }\n\n    ServiceFactory serviceFactory = new DefaultServiceFactory();\n    BucketService bucketService = manager.bucketService();\n    ObjectService objectService = manager.objectService();\n    serviceFactory.register(BucketService.class, () -> bucketService);\n    serviceFactory.register(ObjectService.class, () -> objectService);\n\n    XMLInputFactory input = new WstxInputFactory();\n    input.setProperty(XMLInputFactory.IS_NAMESPACE_AWARE, Boolean.FALSE);\n    input.setProperty(XMLInputFactory.SUPPORT_DTD, Boolean.FALSE); // Disable DTDs\n    input.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, Boolean.FALSE); // Disable external entities\n\n    XmlMapper xmlMapper = new XmlMapper(new XmlFactory(input, new WstxOutputFactory()));\n    xmlMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n    xmlMapper.registerModule(new Jdk8Module());\n    xmlMapper.registerModule(new JavaTimeModule());\n    serviceFactory.register(XmlMapper.class, () -> xmlMapper);\n    return serviceFactory;\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "application-urlshortener",
    "cve_id": "CVE-2025-48885",
    "cwe_list": [
      "CWE-352"
    ],
    "commit_hash": "f121a9c973fd25948e82efcb6289d53fe00a9e7d",
    "short_hash": "f121a9c9",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultURLShortenerResourceTest.java",
        "method_name": "createShortenedURLWithObject",
        "raw_code": "@Test\n    void createShortenedURLWithObject() throws Exception\n    {\n        String currentDocRefStr = \"A.B\";\n        DocumentReference currentDocRef = new DocumentReference(\"wiki\", \"A\", \"B\");\n        when(documentReferenceResolver.resolve(currentDocRefStr)).thenReturn(currentDocRef);\n        when(authorization.hasAccess(Right.VIEW, currentDocRef)).thenReturn(true);\n        when(xwiki.getDocument(currentDocRef, xcontext)).thenReturn(document);\n\n        // The URLShortenerClass object already exists\n        BaseObject urlObject = new BaseObject();\n        urlObject.setStringValue(PAGE_ID, PAGE_ID_VALUE);\n        when(document.getXObject(URL_SHORTENER_CLASS_REFERENCE)).thenReturn(urlObject);\n\n        Response response = this.urlShortenerResource.createShortenedURL(currentDocRefStr);\n        assertEquals(\"{pageID=12345}\", String.valueOf(response.getEntity()));\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultURLShortenerResourceTest.java",
        "method_name": "createShortenedURLWithObject",
        "raw_code": "@Test\n    void createShortenedURLWithObject() throws Exception\n    {\n        String currentDocRefStr = \"A.B\";\n        DocumentReference currentDocRef = new DocumentReference(\"wiki\", \"A\", \"B\");\n        when(documentReferenceResolver.resolve(currentDocRefStr)).thenReturn(currentDocRef);\n        when(authorization.hasAccess(Right.VIEW, currentDocRef)).thenReturn(true);\n        when(xwiki.getDocument(currentDocRef, xcontext)).thenReturn(document);\n        when(xwiki.exists(currentDocRef, xcontext)).thenReturn(true);\n\n        // The URLShortenerClass object already exists\n        BaseObject urlObject = new BaseObject();\n        urlObject.setStringValue(PAGE_ID, PAGE_ID_VALUE);\n        when(document.getXObject(URL_SHORTENER_CLASS_REFERENCE)).thenReturn(urlObject);\n\n        Response response = this.urlShortenerResource.createShortenedURL(currentDocRefStr);\n        assertEquals(\"{pageID=12345}\", String.valueOf(response.getEntity()));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "application-urlshortener",
    "cve_id": "CVE-2025-48885",
    "cwe_list": [
      "CWE-352"
    ],
    "commit_hash": "f121a9c973fd25948e82efcb6289d53fe00a9e7d",
    "short_hash": "f121a9c9",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultURLShortenerResourceTest.java",
        "method_name": "createShortenedURLWithoutObject",
        "raw_code": "@Test\n    void createShortenedURLWithoutObject() throws Exception\n    {\n        String currentDocRefStr = \"A.B\";\n        DocumentReference currentDocRef = new DocumentReference(\"wiki\", \"A\", \"B\");\n        when(documentReferenceResolver.resolve(currentDocRefStr)).thenReturn(currentDocRef);\n        when(authorization.hasAccess(Right.VIEW, currentDocRef)).thenReturn(true);\n        when(xwiki.getDocument(currentDocRef, xcontext)).thenReturn(document);\n\n        // The URLShortenerClass object does not exist.\n        when(document.getXObject(URL_SHORTENER_CLASS_REFERENCE)).thenReturn(null);\n        when(document.newXObject(URL_SHORTENER_CLASS_REFERENCE, xcontext)).thenReturn(object);\n\n        // There is no other document with the generated ID.\n        SolrDocumentList solrDocumentList = new SolrDocumentList();\n        when(queryManager.createQuery(any(String.class), eq(\"solr\"))).thenReturn(query);\n        when(query.execute()).thenReturn(Collections.singletonList(queryResponse));\n        when(queryResponse.getResults()).thenReturn(solrDocumentList);\n\n        this.urlShortenerResource.createShortenedURL(currentDocRefStr);\n\n        verify(xwiki).saveDocument(document, \"Created URL Shortener.\", true, xcontext);\n        verify(object).set(eq(PAGE_ID), any(String.class), eq(xcontext));\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultURLShortenerResourceTest.java",
        "method_name": "createShortenedURLWithoutObject",
        "raw_code": "@Test\n    void createShortenedURLWithoutObject() throws Exception\n    {\n        String currentDocRefStr = \"A.B\";\n        DocumentReference currentDocRef = new DocumentReference(\"wiki\", \"A\", \"B\");\n        when(documentReferenceResolver.resolve(currentDocRefStr)).thenReturn(currentDocRef);\n        when(authorization.hasAccess(Right.VIEW, currentDocRef)).thenReturn(true);\n        when(xwiki.getDocument(currentDocRef, xcontext)).thenReturn(document);\n        when(xwiki.exists(currentDocRef, xcontext)).thenReturn(true);\n\n        // The URLShortenerClass object does not exist.\n        when(document.getXObject(URL_SHORTENER_CLASS_REFERENCE)).thenReturn(null);\n        when(document.newXObject(URL_SHORTENER_CLASS_REFERENCE, xcontext)).thenReturn(object);\n\n        // There is no other document with the generated ID.\n        SolrDocumentList solrDocumentList = new SolrDocumentList();\n        when(queryManager.createQuery(any(String.class), eq(\"solr\"))).thenReturn(query);\n        when(query.execute()).thenReturn(Collections.singletonList(queryResponse));\n        when(queryResponse.getResults()).thenReturn(solrDocumentList);\n\n        this.urlShortenerResource.createShortenedURL(currentDocRefStr);\n\n        verify(xwiki).saveDocument(document, \"Created URL Shortener.\", true, xcontext);\n        verify(object).set(eq(PAGE_ID), any(String.class), eq(xcontext));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "application-urlshortener",
    "cve_id": "CVE-2025-48885",
    "cwe_list": [
      "CWE-352"
    ],
    "commit_hash": "f121a9c973fd25948e82efcb6289d53fe00a9e7d",
    "short_hash": "f121a9c9",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultURLShortenerResourceTest.java",
        "method_name": "createShortenedURLWithoutViewAccess",
        "raw_code": "@Test\n    void createShortenedURLWithoutViewAccess() throws Exception\n    {\n        String currentDocRefStr = \"A.B\";\n        DocumentReference currentDocRef = new DocumentReference(\"wiki\", \"A\", \"B\");\n        when(documentReferenceResolver.resolve(currentDocRefStr)).thenReturn(currentDocRef);\n        when(authorization.hasAccess(Right.VIEW, currentDocRef)).thenReturn(false);\n\n        WebApplicationException exception = assertThrows(WebApplicationException.class,\n            () -> this.urlShortenerResource.createShortenedURL(currentDocRefStr));\n        assertEquals(Response.Status.UNAUTHORIZED.getStatusCode(), exception.getResponse().getStatus());\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultURLShortenerResourceTest.java",
        "method_name": "createShortenedURLWithoutViewAccess",
        "raw_code": "@Test\n    void createShortenedURLWithoutViewAccess() throws Exception\n    {\n        String currentDocRefStr = \"A.B\";\n        DocumentReference currentDocRef = new DocumentReference(\"wiki\", \"A\", \"B\");\n        when(documentReferenceResolver.resolve(currentDocRefStr)).thenReturn(currentDocRef);\n        when(authorization.hasAccess(Right.VIEW, currentDocRef)).thenReturn(false);\n        when(xwiki.exists(currentDocRef, xcontext)).thenReturn(true);\n\n        WebApplicationException exception = assertThrows(WebApplicationException.class,\n            () -> this.urlShortenerResource.createShortenedURL(currentDocRefStr));\n        assertEquals(Response.Status.UNAUTHORIZED.getStatusCode(), exception.getResponse().getStatus());\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "application-urlshortener",
    "cve_id": "CVE-2025-48885",
    "cwe_list": [
      "CWE-352"
    ],
    "commit_hash": "f121a9c973fd25948e82efcb6289d53fe00a9e7d",
    "short_hash": "f121a9c9",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultURLShortenerResourceTest.java",
        "method_name": "createShortenedURLWithErrorOnPageID",
        "raw_code": "@Test\n    void createShortenedURLWithErrorOnPageID() throws Exception\n    {\n        String currentDocRefStr = \"A.B\";\n        DocumentReference currentDocRef = new DocumentReference(\"wiki\", \"A\", \"B\");\n        when(documentReferenceResolver.resolve(currentDocRefStr)).thenReturn(currentDocRef);\n        when(authorization.hasAccess(Right.VIEW, currentDocRef)).thenReturn(true);\n        when(xwiki.getDocument(currentDocRef, xcontext)).thenReturn(document);\n        when(document.getDocumentReference()).thenReturn(currentDocRef);\n\n        // The URLShortenerClass object does not exist.\n        when(document.getXObject(URL_SHORTENER_CLASS_REFERENCE)).thenReturn(null);\n        when(document.newXObject(URL_SHORTENER_CLASS_REFERENCE, xcontext)).thenThrow(new XWikiException());\n\n        WebApplicationException exception = assertThrows(WebApplicationException.class,\n            () -> this.urlShortenerResource.createShortenedURL(currentDocRefStr));\n        assertEquals(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode(), exception.getResponse().getStatus());\n\n        assertEquals(1, logCapture.size());\n        assertEquals(Level.ERROR, logCapture.getLogEvent(0).getLevel());\n        assertEquals(String.format(\n            \"Error while computing the shortened URL for document [%s]. Root cause: [XWikiException: Error number\"\n                + \" 0 in 0]\", currentDocRef.toString()), logCapture.getMessage(0));\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultURLShortenerResourceTest.java",
        "method_name": "createShortenedURLWithErrorOnPageID",
        "raw_code": "@Test\n    void createShortenedURLWithErrorOnPageID() throws Exception\n    {\n        String currentDocRefStr = \"A.B\";\n        DocumentReference currentDocRef = new DocumentReference(\"wiki\", \"A\", \"B\");\n        when(documentReferenceResolver.resolve(currentDocRefStr)).thenReturn(currentDocRef);\n        when(authorization.hasAccess(Right.VIEW, currentDocRef)).thenReturn(true);\n        when(xwiki.getDocument(currentDocRef, xcontext)).thenReturn(document);\n        when(document.getDocumentReference()).thenReturn(currentDocRef);\n        when(xwiki.exists(currentDocRef, xcontext)).thenReturn(true);\n\n        // The URLShortenerClass object does not exist.\n        when(document.getXObject(URL_SHORTENER_CLASS_REFERENCE)).thenReturn(null);\n        when(document.newXObject(URL_SHORTENER_CLASS_REFERENCE, xcontext)).thenThrow(new XWikiException());\n\n        WebApplicationException exception = assertThrows(WebApplicationException.class,\n            () -> this.urlShortenerResource.createShortenedURL(currentDocRefStr));\n        assertEquals(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode(), exception.getResponse().getStatus());\n\n        assertEquals(1, logCapture.size());\n        assertEquals(Level.ERROR, logCapture.getLogEvent(0).getLevel());\n        assertEquals(String.format(\n            \"Error while computing the shortened URL for document [%s]. Root cause: [XWikiException: Error number\"\n                + \" 0 in 0]\", currentDocRef.toString()), logCapture.getMessage(0));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "application-urlshortener",
    "cve_id": "CVE-2025-48885",
    "cwe_list": [
      "CWE-352"
    ],
    "commit_hash": "f121a9c973fd25948e82efcb6289d53fe00a9e7d",
    "short_hash": "f121a9c9",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultURLShortenerResource.java",
        "method_name": "createShortenedURL",
        "raw_code": "@Override\n    public Response createShortenedURL(String currentDocRef) throws Exception\n    {\n\n        XWikiContext xcontext = xcontextProvider.get();\n        DocumentReference documentReference = documentReferenceResolver.resolve(currentDocRef);\n        if (authorization.hasAccess(Right.VIEW, documentReference)) {\n            XWikiDocument currentDoc = xcontext.getWiki().getDocument(documentReference, xcontext);\n            String pageID = addURLShortenerXObject(currentDoc);\n            if (pageID == null || pageID.isEmpty()) {\n                throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);\n            }\n\n            return Response.ok().entity(Map.of(PAGE_ID, pageID)).type(MediaType.APPLICATION_JSON).build();\n        } else {\n            throw new WebApplicationException(Response.Status.UNAUTHORIZED);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultURLShortenerResource.java",
        "method_name": "createShortenedURL",
        "raw_code": "@Override\n    public Response createShortenedURL(String currentDocRef) throws Exception\n    {\n\n        XWikiContext xcontext = xcontextProvider.get();\n        DocumentReference documentReference = documentReferenceResolver.resolve(currentDocRef);\n\n        if (!xcontext.getWiki().exists(documentReference, xcontext)) {\n            return Response.status(Response.Status.NOT_FOUND).type(MediaType.APPLICATION_JSON).build();\n        }\n\n        if (authorization.hasAccess(Right.VIEW, documentReference)) {\n            XWikiDocument currentDoc = xcontext.getWiki().getDocument(documentReference, xcontext);\n            String pageID = addURLShortenerXObject(currentDoc);\n            if (pageID == null || pageID.isEmpty()) {\n                throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);\n            }\n\n            return Response.ok().entity(Map.of(PAGE_ID, pageID)).type(MediaType.APPLICATION_JSON).build();\n        } else {\n            throw new WebApplicationException(Response.Status.UNAUTHORIZED);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54125",
    "cwe_list": [
      "CWE-359"
    ],
    "commit_hash": "742ee3482ef6c2bd4ad03d0de9cdd81d0e8f3d59",
    "short_hash": "742ee348",
    "vulnerableMethods_before": [
      {
        "filename": "BaseObjectEventGenerator.java",
        "method_name": "write",
        "raw_code": "@Override\n    public void write(BaseObject xobject, Object filter, BaseObjectFilter objectFilter,\n        DocumentInstanceInputProperties properties) throws FilterException\n    {\n        XWikiContext xcontext = this.xcontextProvider.get();\n\n        // > WikiObject\n\n        FilterEventParameters objectParameters = new FilterEventParameters();\n\n        objectParameters.put(WikiObjectFilter.PARAMETER_NAME, xobject.getName());\n        objectParameters.put(WikiObjectFilter.PARAMETER_CLASS_REFERENCE, xobject.getClassName());\n        objectParameters.put(WikiObjectFilter.PARAMETER_GUID, xobject.getGuid());\n        objectParameters.put(WikiObjectFilter.PARAMETER_NUMBER, xobject.getNumber());\n\n        objectFilter.beginWikiObject(xobject.getReference() != null ? xobject.getReference().getName() : null,\n            objectParameters);\n\n        // Object class\n\n        BaseClass xclass = xobject.getXClass(xcontext);\n        ((BaseClassEventGenerator) this.classEventGenerator).write(xclass, filter, objectFilter, properties);\n\n        // Properties\n\n        // Iterate over values/properties sorted by field name so that the values are\n        // exported to XML in a consistent order.\n        Iterator<BaseProperty<?>> it = xobject.getSortedIterator();\n        while (it.hasNext()) {\n            BaseProperty<?> xproperty = it.next();\n\n            String pname = xproperty.getName();\n            if (pname != null && !pname.trim().equals(\"\")) {\n                ((BasePropertyEventGenerator) this.propertyEventGenerator).write(xproperty, filter,\n                    (Map<String, Object>) properties);\n            }\n        }\n\n        // < WikiObject\n\n        objectFilter.endWikiObject(xobject.getReference().getName(), objectParameters);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "BaseObjectEventGenerator.java",
        "method_name": "write",
        "raw_code": "@Override\n    public void write(BaseObject xobject, Object filter, BaseObjectFilter objectFilter,\n        DocumentInstanceInputProperties properties) throws FilterException\n    {\n        XWikiContext xcontext = this.xcontextProvider.get();\n\n        // > WikiObject\n\n        FilterEventParameters objectParameters = new FilterEventParameters();\n\n        objectParameters.put(WikiObjectFilter.PARAMETER_NAME, xobject.getName());\n        objectParameters.put(WikiObjectFilter.PARAMETER_CLASS_REFERENCE, xobject.getClassName());\n        objectParameters.put(WikiObjectFilter.PARAMETER_GUID, xobject.getGuid());\n        objectParameters.put(WikiObjectFilter.PARAMETER_NUMBER, xobject.getNumber());\n\n        objectFilter.beginWikiObject(xobject.getReference() != null ? xobject.getReference().getName() : null,\n            objectParameters);\n\n        // Object class\n\n        BaseClass xclass = xobject.getXClass(xcontext);\n        ((BaseClassEventGenerator) this.classEventGenerator).write(xclass, filter, objectFilter, properties);\n\n        // Properties\n\n        // Iterate over values/properties sorted by field name so that the values are\n        // exported to XML in a consistent order.\n        Iterator<BaseProperty<?>> it = xobject.getSortedIterator();\n        while (it.hasNext()) {\n            BaseProperty<?> xproperty = it.next();\n\n            String pname = xproperty.getName();\n            if (StringUtils.isNotBlank(pname)\n                && (!(xclass.get(pname) instanceof PropertyClass propertyClass)\n                || !properties.getExcludedPropertyTypes().contains(propertyClass.getClassType())))\n            {\n                ((BasePropertyEventGenerator) this.propertyEventGenerator).write(xproperty, filter,\n                    (Map<String, Object>) properties);\n            }\n        }\n\n        // < WikiObject\n\n        objectFilter.endWikiObject(xobject.getReference().getName(), objectParameters);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54125",
    "cwe_list": [
      "CWE-359"
    ],
    "commit_hash": "742ee3482ef6c2bd4ad03d0de9cdd81d0e8f3d59",
    "short_hash": "742ee348",
    "vulnerableMethods_before": [
      {
        "filename": "Document.java",
        "method_name": "getXMLContent",
        "raw_code": "public String getXMLContent() throws XWikiException\n    {\n        String xml = this.doc.getXMLContent(getXWikiContext());\n        return getXWikiContext().getUtil().substitute(\"s/<email>.*?<\\\\/email>/<email>********<\\\\/email>/goi\",\n            getXWikiContext().getUtil().substitute(\"s/<password>.*?<\\\\/password>/<password>********<\\\\/password>/goi\",\n                xml));\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "Document.java",
        "method_name": "getXMLContent",
        "raw_code": "public String getXMLContent() throws XWikiException\n    {\n        StringWriter writer = new StringWriter();\n        OutputTarget outputTarget = new DefaultWriterOutputTarget(writer);\n\n        DocumentInstanceInputProperties documentProperties = new DocumentInstanceInputProperties();\n        documentProperties.setWithWikiDocumentContentHTML(true);\n        documentProperties.setWithWikiAttachmentsContent(false);\n        documentProperties.setWithJRCSRevisions(false);\n        documentProperties.setWithRevisions(false);\n        documentProperties.setExcludedPropertyTypes(Set.of(\"Email\", \"Password\"));\n\n        // Output\n        XAROutputProperties xarProperties = new XAROutputProperties();\n        xarProperties.setPreserveVersion(false);\n        xarProperties.setTarget(outputTarget);\n\n        this.doc.toXML(documentProperties, xarProperties);\n\n        return writer.toString();\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "faction",
    "cve_id": "CVE-2025-27422",
    "cwe_list": [
      "CWE-287"
    ],
    "commit_hash": "0a6848d388d6dba1c81918cce2772b1e805cd3d6",
    "short_hash": "0a6848d3",
    "vulnerableMethods_before": [
      {
        "filename": "Login.java",
        "method_name": "execute",
        "raw_code": "@Action(value = \"index\", results = { @Result(name = \"createAccount\", location = \"/WEB-INF/jsp/newInstance.jsp\"),\n\t\t\t@Result(name = \"failedAuth\", location = \"/index.jsp\"),\n\t\t\t@Result(name = \"redirect_to_oauth\", location = \"/oauth\"),\n\t\t\t@Result(name = \"assessorQueue\", type = \"redirectAction\", location = \"portal/Dashboard\"),\n\t\t\t@Result(name = \"engagement\", type = \"redirectAction\", location = \"portal/Engagement\"),\n\t\t\t@Result(name = \"admin\", type = \"redirectAction\", location = \"portal/Users\"),\n\t\t\t@Result(name = \"calendar\", type = \"redirectAction\", location = \"portal/Calendar\"),\n\t\t\t@Result(name = \"remediation\", type = \"redirectAction\", location = \"portal/Remediation\") })\n\tpublic String execute() {\n\t\t\n\n\t\tif (AccessControl.isNewInstance(em) && action == null) {\n\t\t\treturn \"createAccount\";\n\t\t} else if (AccessControl.isAuthenticated(this.JSESSION)) {\n\t\t\treturn redirectIt(this.getSessionUser());\n\t\t}else if ( (username != null && !username.equals(\"\")) || (getProfiles() != null && getProfiles().size()>0) ) {\n\t\t\tAuthResult result = AccessControl.Authenticate(username, password, request, em, getProfiles());\n\t\t\tif (result == AuthResult.SUCCESS) {\n\t\t\t\tHibHelper.getInstance().preJoin();\n\t\t\t\tem.joinTransaction();\n\t\t\t\tHttpSession session = ServletActionContext.getRequest().getSession();\n\t\t\t\tAuditLog.audit(username, this, \"Successsfully logged in\", AuditLog.Login, false);\n\t\t\t\tHibHelper.getInstance().commit();\n\t\t\t\tUser user = (User) session.getAttribute(\"user\");\n\t\t\t\tSystemSettings ss = (SystemSettings) em.createQuery(\"from SystemSettings\").getResultList().stream()\n\t\t\t\t\t\t.findFirst().orElse(null);\n\t\t\t\tString tier = this.getTier();\n\t\t\t\tsession.setAttribute(\"tier\", tier);\n\t\t\t\tif (tier == \"consultant\") {\n\t\t\t\t\tsession.setAttribute(\"retestsEnabled\", false);\n\t\t\t\t\tsession.setAttribute(\"prEnabled\", false);\n\t\t\t\t\tsession.setAttribute(\"feedEnabled\", false);\n\t\t\t\t} else {\n\t\t\t\t\tsession.setAttribute(\"prEnabled\", ss.getPeerreview());\n\t\t\t\t\tsession.setAttribute(\"feedEnabled\", ss.getEnablefeed());\n\t\t\t\t\tsession.setAttribute(\"retestsEnabled\", true);\n\t\t\t\t}\n\t\t\t\tsession.setAttribute(\"title1\", ss.getBoldTitle() == null ? \"FACTION\" : ss.getBoldTitle());\n\t\t\t\tsession.setAttribute(\"title2\", ss.getOtherTitle() == null ? \"oss\" : ss.getOtherTitle());\n\n\t\t\t\treturn redirectIt(user);\n\t\t\t} else if (result == AuthResult.FAILED_AUTH) {\n\t\t\t\tHibHelper.getInstance().preJoin();\n\t\t\t\tem.joinTransaction();\n\t\t\t\tAuditLog.notAuthorized(username, this, \" Failed Authentication\", false);\n\t\t\t\tHibHelper.getInstance().commit();\n\t\t\t\tfailed = true;\n\t\t\t\tmessage = \"Username and/or Password was incorrect.\";\n\t\t\t\treturn \"failedAuth\";\n\t\t\t} else if (result == AuthResult.LOCKEDOUT) {\n\t\t\t\tHibHelper.getInstance().preJoin();\n\t\t\t\tem.joinTransaction();\n\t\t\t\tAuditLog.notAuthorized(username, this, username + \" Account Lock Out\", false);\n\t\t\t\tHibHelper.getInstance().commit();\n\n\t\t\t\tfailed = true;\n\t\t\t\tmessage = \"Your account has been locked.\";\n\t\t\t\treturn \"failedAuth\";\n\t\t\t} else if (result == AuthResult.INACTIVITY) {\n\t\t\t\tHibHelper.getInstance().preJoin();\n\t\t\t\tem.joinTransaction();\n\t\t\t\tAuditLog.notAuthorized(username, this, username + \" Account was Lock Out due to inactivity\", false);\n\t\t\t\tHibHelper.getInstance().commit();\n\n\t\t\t\tfailed = true;\n\t\t\t\tmessage = \"Your account has been locked due to inactivity. Please contact your administrator\";\n\t\t\t\treturn \"failedAuth\";\n\t\t\t} else if (result == AuthResult.REDIRECT_OAUTH) {\n\t\t\t\tMap<String,String[]> map = request.getParameterMap();\n\t\t\t\treturn \"redirect_to_oauth\";\n\t\t\t}else if (result == AuthResult.NOT_VALID_OAUTH_ACCOUNT) {\n\t\t\t\tfailed = true;\n\t\t\t\tmessage = \"Not a valid OAuth User. Try another account or contact the administrator.\";\n\t\t\t\treturn \"failedAuth\";\n\t\t\t} else {\n\t\t\t\tHibHelper.getInstance().preJoin();\n\t\t\t\tem.joinTransaction();\n\t\t\t\tAuditLog.error(username, this, \"Access control result of \" + result, AuditLog.Login, false);\n\t\t\t\tHibHelper.getInstance().commit();\n\n\t\t\t\tfailed = true;\n\t\t\t\tmessage = \"Username and/or Password was incorrect.\";\n\t\t\t\treturn \"failedAuth\";\n\t\t\t}\n\n\t\t} else if (action != null && action.equals(\"create\")) {\n\t\t\tif (adminUsername == null || adminUsername.trim().equals(\"\")) {\n\t\t\t\tthis.message = \"Username is blank\";\n\t\t\t\treturn \"createAccount\";\n\n\t\t\t}\n\t\t\tif (adminPassword == null || confirm == null || !adminPassword.equals(confirm)) {\n\t\t\t\tthis.message = \"Passwords do not match\";\n\t\t\t\treturn \"createAccount\";\n\t\t\t}\n\t\t\tif (first == null || last == null || first.equals(\"\") || last.equals(\"\")) {\n\t\t\t\tthis.message = \"First and/or Last Name are missing\";\n\t\t\t\treturn \"createAccount\";\n\t\t\t}\n\n\t\t\tif (email == null || email.equals(\"\")) {\n\t\t\t\tthis.message = \"Email address is missing\";\n\t\t\t\treturn \"createAccount\";\n\n\t\t\t}\n\t\t\t\n\t\t\tString errorMessage = AccessControl.checkPassword(adminPassword, confirm);\n\t\t\tif(!errorMessage.equals(\"\")) {\n\t\t\t\tthis.message = errorMessage;\n\t\t\t\treturn \"createAccount\";\n\t\t\t}\n\n\t\t\tif (adminPassword.equals(confirm)) {\n\t\t\t\tif (this.team.equals(\"\"))\n\t\t\t\t\tthis.team = \"Hacking Team\";\n\n\t\t\t\tUser testAdmin = em.createQuery(\"from User where username = :uname\", User.class)\n\t\t\t\t\t\t.setParameter(\"uname\", this.adminUsername).getResultList().stream().findFirst().orElse(null);\n\t\t\t\tif (testAdmin != null) {\n\t\t\t\t\tthis.message = \"Username already taken\";\n\t\t\t\t\treturn \"createAccount\";\n\t\t\t\t}\n\t\t\t\tHibHelper.getInstance().preJoin();\n\t\t\t\tem.joinTransaction();\n\t\t\t\tAccessControl.createAdmin(adminUsername.trim().toLowerCase(), adminPassword, first, last, email, em);\n\n\t\t\t\tSystemSettings settings = em.find(SystemSettings.class, 2l);\n\t\t\t\tTeams theTeam = em.createQuery(\"from Teams where TeamName = :team\", Teams.class)\n\t\t\t\t\t\t.setParameter(\"team\", team).getResultList().stream().findFirst().orElse(null);\n\t\t\t\tList<AssessmentType> atype = em.createQuery(\"from AssessmentType\").getResultList();\n\t\t\t\tList<Campaign> campaigns = em.createQuery(\"from Campaign\").getResultList();\n\t\t\t\tList<RiskLevel> levels = em.createQuery(\"from RiskLevel\").getResultList();\n\t\t\t\tList<ReportTemplates> reportTemplates = em.createQuery(\"from ReportTemplates\").getResultList();\n\t\t\t\tCategory cat = new Category();\n\t\t\t\tcat.setName(\"Uncategorized\");\n\t\t\t\tDefaultVulnerability dv = new DefaultVulnerability();\n\t\t\t\tdv.setActive(true);\n\t\t\t\tdv.setCategory(cat);\n\t\t\t\tdv.setName(\"Generic Vulnerability\");\n\t\t\t\tdv.setLikelyhood(4);\n\t\t\t\tdv.setOverall(4);\n\t\t\t\tdv.setImpact(4);\n\t\t\t\tdv.setDescription(\"\");\n\t\t\t\tdv.setRecommendation(\"\");\n\t\t\t\tem.persist(cat);\n\t\t\t\tem.persist(dv);\n\t\t\t\tif (settings == null) {\n\t\t\t\t\tsettings = new SystemSettings();\n\t\t\t\t\tsettings.setDefaultStatus(\"Open\");\n\t\t\t\t\tList<String> status = new ArrayList<String>();\n\t\t\t\t\tstatus.add(\"Open\");\n\t\t\t\t\tstatus.add(\"In Progress\");\n\t\t\t\t\tstatus.add(\"On Hold\");\n\t\t\t\t\tstatus.add(\"Closed\");\n\t\t\t\t\tsettings.setStatus(status);\n\t\t\t\t\tsettings.setDefaultStatus(\"Open\");\n\t\t\t\t}\n\t\t\t\tif (theTeam == null)\n\t\t\t\t\ttheTeam = new Teams();\n\t\t\t\tif (levels == null || levels.size() == 0) {\n\t\t\t\t\tString[] risk = { \"Informational\", \"Recommended\", \"Low\", \"Medium\", \"High\", \"Critical\" };\n\t\t\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\t\t\tRiskLevel level = new RiskLevel();\n\t\t\t\t\t\tlevel.setRiskId(i);\n\t\t\t\t\t\tif (i < risk.length)\n\t\t\t\t\t\t\tlevel.setRisk(risk[i]);\n\t\t\t\t\t\tem.persist(level);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (campaigns == null || campaigns.size() == 0) {\n\t\t\t\t\tCampaign camp = new Campaign();\n\t\t\t\t\tDate now = new Date();\n\t\t\t\t\tSimpleDateFormat sdf = new SimpleDateFormat(\"yyyy\");\n\t\t\t\t\tcamp.setName(\"\" + sdf.format(now) + \" Assessments\");\n\t\t\t\t\tem.persist(camp);\n\n\t\t\t\t}\n\n\t\t\t\ttheTeam.setTeamName(this.team);\n\t\t\t\tem.persist(settings);\n\t\t\t\tem.persist(theTeam);\n\t\t\t\tUser admin = em.createQuery(\"from User where username = :uname\", User.class)\n\t\t\t\t\t\t.setParameter(\"uname\", this.adminUsername.trim()).getSingleResult();\n\t\t\t\tadmin.getPermissions().setAssessor(true);\n\t\t\t\tadmin.getPermissions().setEngagement(true);\n\t\t\t\tadmin.getPermissions().setManager(true);\n\t\t\t\tadmin.getPermissions().setRemediation(true);\n\n\t\t\t\tadmin.setTeam(theTeam);\n\t\t\t\tem.persist(admin);\n\n\t\t\t\tif (atype == null || atype.isEmpty()) {\n\n\t\t\t\t\tAssessmentType newType = new AssessmentType();\n\t\t\t\t\tnewType.setType(\"Security Assessment\");\n\t\t\t\t\tem.persist(newType);\n\t\t\t\t\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (reportTemplates == null || reportTemplates.isEmpty()) {\n\t\t\t\t\t\t\tReportTemplates reportTemplate = new ReportTemplates();\n\t\t\t\t\t\t\treportTemplate.initDefaultTemplate(theTeam, newType);\n\t\t\t\t\t\t}\n\t\t\t\t\t}catch(Exception ex) {\n\t\t\t\t\t\tex.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tAuditLog.audit(adminUsername, this, \"Admin Account Created\", AuditLog.Login, false);\n\t\t\t\tHibHelper.getInstance().commit();\n\n\t\t\t}\n\t\t\treturn SUCCESS;\n\n\t\t}else {\n\n\t\t\treturn SUCCESS;\n\t\t}\n\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "Login.java",
        "method_name": "execute",
        "raw_code": "@Action(value = \"index\", results = { @Result(name = \"createAccount\", location = \"/WEB-INF/jsp/newInstance.jsp\"),\n\t\t\t@Result(name = \"failedAuth\", location = \"/index.jsp\"),\n\t\t\t@Result(name = \"redirect_to_oauth\", location = \"/oauth\"),\n\t\t\t@Result(name = \"assessorQueue\", type = \"redirectAction\", location = \"portal/Dashboard\"),\n\t\t\t@Result(name = \"engagement\", type = \"redirectAction\", location = \"portal/Engagement\"),\n\t\t\t@Result(name = \"admin\", type = \"redirectAction\", location = \"portal/Users\"),\n\t\t\t@Result(name = \"calendar\", type = \"redirectAction\", location = \"portal/Calendar\"),\n\t\t\t@Result(name = \"remediation\", type = \"redirectAction\", location = \"portal/Remediation\") })\n\tpublic String execute() {\n\t\t\n\n\t\tif (AccessControl.isNewInstance(em) && action == null) {\n\t\t\treturn \"createAccount\";\n\t\t} else if (AccessControl.isAuthenticated(this.JSESSION)) {\n\t\t\treturn redirectIt(this.getSessionUser());\n\t\t}else if ( (username != null && !username.equals(\"\")) || (getProfiles() != null && getProfiles().size()>0) ) {\n\t\t\tAuthResult result = AccessControl.Authenticate(username, password, request, em, getProfiles());\n\t\t\tif (result == AuthResult.SUCCESS) {\n\t\t\t\tHibHelper.getInstance().preJoin();\n\t\t\t\tem.joinTransaction();\n\t\t\t\tHttpSession session = ServletActionContext.getRequest().getSession();\n\t\t\t\tAuditLog.audit(username, this, \"Successsfully logged in\", AuditLog.Login, false);\n\t\t\t\tHibHelper.getInstance().commit();\n\t\t\t\tUser user = (User) session.getAttribute(\"user\");\n\t\t\t\tSystemSettings ss = (SystemSettings) em.createQuery(\"from SystemSettings\").getResultList().stream()\n\t\t\t\t\t\t.findFirst().orElse(null);\n\t\t\t\tString tier = this.getTier();\n\t\t\t\tsession.setAttribute(\"tier\", tier);\n\t\t\t\tif (tier == \"consultant\") {\n\t\t\t\t\tsession.setAttribute(\"retestsEnabled\", false);\n\t\t\t\t\tsession.setAttribute(\"prEnabled\", false);\n\t\t\t\t\tsession.setAttribute(\"feedEnabled\", false);\n\t\t\t\t} else {\n\t\t\t\t\tsession.setAttribute(\"prEnabled\", ss.getPeerreview());\n\t\t\t\t\tsession.setAttribute(\"feedEnabled\", ss.getEnablefeed());\n\t\t\t\t\tsession.setAttribute(\"retestsEnabled\", true);\n\t\t\t\t}\n\t\t\t\tsession.setAttribute(\"title1\", ss.getBoldTitle() == null ? \"FACTION\" : ss.getBoldTitle());\n\t\t\t\tsession.setAttribute(\"title2\", ss.getOtherTitle() == null ? \"oss\" : ss.getOtherTitle());\n\n\t\t\t\treturn redirectIt(user);\n\t\t\t} else if (result == AuthResult.FAILED_AUTH) {\n\t\t\t\tHibHelper.getInstance().preJoin();\n\t\t\t\tem.joinTransaction();\n\t\t\t\tAuditLog.notAuthorized(username, this, \" Failed Authentication\", false);\n\t\t\t\tHibHelper.getInstance().commit();\n\t\t\t\tfailed = true;\n\t\t\t\tmessage = \"Username and/or Password was incorrect.\";\n\t\t\t\treturn \"failedAuth\";\n\t\t\t} else if (result == AuthResult.LOCKEDOUT) {\n\t\t\t\tHibHelper.getInstance().preJoin();\n\t\t\t\tem.joinTransaction();\n\t\t\t\tAuditLog.notAuthorized(username, this, username + \" Account Lock Out\", false);\n\t\t\t\tHibHelper.getInstance().commit();\n\n\t\t\t\tfailed = true;\n\t\t\t\tmessage = \"Your account has been locked.\";\n\t\t\t\treturn \"failedAuth\";\n\t\t\t} else if (result == AuthResult.INACTIVITY) {\n\t\t\t\tHibHelper.getInstance().preJoin();\n\t\t\t\tem.joinTransaction();\n\t\t\t\tAuditLog.notAuthorized(username, this, username + \" Account was Lock Out due to inactivity\", false);\n\t\t\t\tHibHelper.getInstance().commit();\n\n\t\t\t\tfailed = true;\n\t\t\t\tmessage = \"Your account has been locked due to inactivity. Please contact your administrator\";\n\t\t\t\treturn \"failedAuth\";\n\t\t\t} else if (result == AuthResult.REDIRECT_OAUTH) {\n\t\t\t\tMap<String,String[]> map = request.getParameterMap();\n\t\t\t\treturn \"redirect_to_oauth\";\n\t\t\t}else if (result == AuthResult.NOT_VALID_OAUTH_ACCOUNT) {\n\t\t\t\tfailed = true;\n\t\t\t\tmessage = \"Not a valid OAuth User. Try another account or contact the administrator.\";\n\t\t\t\treturn \"failedAuth\";\n\t\t\t} else {\n\t\t\t\tHibHelper.getInstance().preJoin();\n\t\t\t\tem.joinTransaction();\n\t\t\t\tAuditLog.error(username, this, \"Access control result of \" + result, AuditLog.Login, false);\n\t\t\t\tHibHelper.getInstance().commit();\n\n\t\t\t\tfailed = true;\n\t\t\t\tmessage = \"Username and/or Password was incorrect.\";\n\t\t\t\treturn \"failedAuth\";\n\t\t\t}\n\n\t\t} else if (AccessControl.isNewInstance(em) && (action != null && action.equals(\"create\"))) {\n\t\t\tif (adminUsername == null || adminUsername.trim().equals(\"\")) {\n\t\t\t\tthis.message = \"Username is blank\";\n\t\t\t\treturn \"createAccount\";\n\n\t\t\t}\n\t\t\tif (adminPassword == null || confirm == null || !adminPassword.equals(confirm)) {\n\t\t\t\tthis.message = \"Passwords do not match\";\n\t\t\t\treturn \"createAccount\";\n\t\t\t}\n\t\t\tif (first == null || last == null || first.equals(\"\") || last.equals(\"\")) {\n\t\t\t\tthis.message = \"First and/or Last Name are missing\";\n\t\t\t\treturn \"createAccount\";\n\t\t\t}\n\n\t\t\tif (email == null || email.equals(\"\")) {\n\t\t\t\tthis.message = \"Email address is missing\";\n\t\t\t\treturn \"createAccount\";\n\n\t\t\t}\n\t\t\t\n\t\t\tString errorMessage = AccessControl.checkPassword(adminPassword, confirm);\n\t\t\tif(!errorMessage.equals(\"\")) {\n\t\t\t\tthis.message = errorMessage;\n\t\t\t\treturn \"createAccount\";\n\t\t\t}\n\n\t\t\tif (adminPassword.equals(confirm)) {\n\t\t\t\tif (this.team.equals(\"\"))\n\t\t\t\t\tthis.team = \"Hacking Team\";\n\n\t\t\t\tUser testAdmin = em.createQuery(\"from User where username = :uname\", User.class)\n\t\t\t\t\t\t.setParameter(\"uname\", this.adminUsername).getResultList().stream().findFirst().orElse(null);\n\t\t\t\tif (testAdmin != null) {\n\t\t\t\t\tthis.message = \"Username already taken\";\n\t\t\t\t\treturn \"createAccount\";\n\t\t\t\t}\n\t\t\t\tHibHelper.getInstance().preJoin();\n\t\t\t\tem.joinTransaction();\n\t\t\t\tAccessControl.createAdmin(adminUsername.trim().toLowerCase(), adminPassword, first, last, email, em);\n\n\t\t\t\tSystemSettings settings = em.find(SystemSettings.class, 2l);\n\t\t\t\tTeams theTeam = em.createQuery(\"from Teams where TeamName = :team\", Teams.class)\n\t\t\t\t\t\t.setParameter(\"team\", team).getResultList().stream().findFirst().orElse(null);\n\t\t\t\tList<AssessmentType> atype = em.createQuery(\"from AssessmentType\").getResultList();\n\t\t\t\tList<Campaign> campaigns = em.createQuery(\"from Campaign\").getResultList();\n\t\t\t\tList<RiskLevel> levels = em.createQuery(\"from RiskLevel\").getResultList();\n\t\t\t\tList<ReportTemplates> reportTemplates = em.createQuery(\"from ReportTemplates\").getResultList();\n\t\t\t\tCategory cat = new Category();\n\t\t\t\tcat.setName(\"Uncategorized\");\n\t\t\t\tDefaultVulnerability dv = new DefaultVulnerability();\n\t\t\t\tdv.setActive(true);\n\t\t\t\tdv.setCategory(cat);\n\t\t\t\tdv.setName(\"Generic Vulnerability\");\n\t\t\t\tdv.setLikelyhood(4);\n\t\t\t\tdv.setOverall(4);\n\t\t\t\tdv.setImpact(4);\n\t\t\t\tdv.setDescription(\"\");\n\t\t\t\tdv.setRecommendation(\"\");\n\t\t\t\tem.persist(cat);\n\t\t\t\tem.persist(dv);\n\t\t\t\tif (settings == null) {\n\t\t\t\t\tsettings = new SystemSettings();\n\t\t\t\t\tsettings.setDefaultStatus(\"Open\");\n\t\t\t\t\tList<String> status = new ArrayList<String>();\n\t\t\t\t\tstatus.add(\"Open\");\n\t\t\t\t\tstatus.add(\"In Progress\");\n\t\t\t\t\tstatus.add(\"On Hold\");\n\t\t\t\t\tstatus.add(\"Closed\");\n\t\t\t\t\tsettings.setStatus(status);\n\t\t\t\t\tsettings.setDefaultStatus(\"Open\");\n\t\t\t\t}\n\t\t\t\tif (theTeam == null)\n\t\t\t\t\ttheTeam = new Teams();\n\t\t\t\tif (levels == null || levels.size() == 0) {\n\t\t\t\t\tString[] risk = { \"Informational\", \"Recommended\", \"Low\", \"Medium\", \"High\", \"Critical\" };\n\t\t\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\t\t\tRiskLevel level = new RiskLevel();\n\t\t\t\t\t\tlevel.setRiskId(i);\n\t\t\t\t\t\tif (i < risk.length)\n\t\t\t\t\t\t\tlevel.setRisk(risk[i]);\n\t\t\t\t\t\tem.persist(level);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (campaigns == null || campaigns.size() == 0) {\n\t\t\t\t\tCampaign camp = new Campaign();\n\t\t\t\t\tDate now = new Date();\n\t\t\t\t\tSimpleDateFormat sdf = new SimpleDateFormat(\"yyyy\");\n\t\t\t\t\tcamp.setName(\"\" + sdf.format(now) + \" Assessments\");\n\t\t\t\t\tem.persist(camp);\n\n\t\t\t\t}\n\n\t\t\t\ttheTeam.setTeamName(this.team);\n\t\t\t\tem.persist(settings);\n\t\t\t\tem.persist(theTeam);\n\t\t\t\tUser admin = em.createQuery(\"from User where username = :uname\", User.class)\n\t\t\t\t\t\t.setParameter(\"uname\", this.adminUsername.trim()).getSingleResult();\n\t\t\t\tadmin.getPermissions().setAssessor(true);\n\t\t\t\tadmin.getPermissions().setEngagement(true);\n\t\t\t\tadmin.getPermissions().setManager(true);\n\t\t\t\tadmin.getPermissions().setRemediation(true);\n\n\t\t\t\tadmin.setTeam(theTeam);\n\t\t\t\tem.persist(admin);\n\n\t\t\t\tif (atype == null || atype.isEmpty()) {\n\n\t\t\t\t\tAssessmentType newType = new AssessmentType();\n\t\t\t\t\tnewType.setType(\"Security Assessment\");\n\t\t\t\t\tem.persist(newType);\n\t\t\t\t\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (reportTemplates == null || reportTemplates.isEmpty()) {\n\t\t\t\t\t\t\tReportTemplates reportTemplate = new ReportTemplates();\n\t\t\t\t\t\t\treportTemplate.initDefaultTemplate(theTeam, newType);\n\t\t\t\t\t\t}\n\t\t\t\t\t}catch(Exception ex) {\n\t\t\t\t\t\tex.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tAuditLog.audit(adminUsername, this, \"Admin Account Created\", AuditLog.Login, false);\n\t\t\t\tHibHelper.getInstance().commit();\n\n\t\t\t}\n\t\t\treturn SUCCESS;\n\n\t\t}else {\n\n\t\t\treturn SUCCESS;\n\t\t}\n\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "OpenDJ",
    "cve_id": "CVE-2025-27497",
    "cwe_list": [
      "CWE-835"
    ],
    "commit_hash": "08aee4724608e4a32baa3c7d7499ec913a275aaf",
    "short_hash": "08aee472",
    "vulnerableMethods_before": [
      {
        "filename": "LocalBackendSearchOperation.java",
        "method_name": "processSearch",
        "raw_code": "private void processSearch(AtomicBoolean executePostOpPlugins) throws CanceledOperationException\n  {\n    // Process the search base and filter to convert them from their raw forms\n    // as provided by the client to the forms required for the rest of the\n    // search processing.\n    baseDN = getBaseDN();\n    filter = getFilter();\n\n    if (baseDN == null || filter == null)\n    {\n      return;\n    }\n\n    // Check to see if there are any controls in the request. If so, then\n    // see if there is any special processing required.\n    try\n    {\n      handleRequestControls();\n    }\n    catch (DirectoryException de)\n    {\n      logger.traceException(de);\n\n      setResponseData(de);\n      return;\n    }\n\n\n    // Check to see if the client has permission to perform the search.\n\n    // FIXME: for now assume that this will check all permission\n    // pertinent to the operation. This includes proxy authorization\n    // and any other controls specified.\n    try\n    {\n      if (!getAccessControlHandler().isAllowed(this))\n      {\n        setResultCode(ResultCode.INSUFFICIENT_ACCESS_RIGHTS);\n        appendErrorMessage(ERR_SEARCH_AUTHZ_INSUFFICIENT_ACCESS_RIGHTS.get(baseDN));\n        return;\n      }\n    }\n    catch (DirectoryException e)\n    {\n      setResultCode(e.getResultCode());\n      appendErrorMessage(e.getMessageObject());\n      return;\n    }\n\n    // Check for a request to cancel this operation.\n    checkIfCanceled(false);\n\n\n    // Invoke the pre-operation search plugins.\n    executePostOpPlugins.set(true);\n    if (!processOperationResult(this, getPluginConfigManager().invokePreOperationSearchPlugins(this)))\n    {\n      return;\n    }\n\n\n    // Check for a request to cancel this operation.\n    checkIfCanceled(false);\n\n\n    // Get the backend that should hold the search base. If there is none,\n    // then fail.\n    if (backend == null)\n    {\n      setResultCode(ResultCode.NO_SUCH_OBJECT);\n      appendErrorMessage(ERR_SEARCH_BASE_DOESNT_EXIST.get(baseDN));\n      return;\n    }\n\n\n    // We'll set the result code to \"success\". If a problem occurs, then it\n    // will be overwritten.\n    setResultCode(ResultCode.SUCCESS);\n\n    try\n    {\n      //DereferenceAliasesPolicy\n      if (\n              DereferenceAliasesPolicy.ALWAYS.equals(getDerefPolicy())\n              || DereferenceAliasesPolicy.FINDING_BASE.equals(getDerefPolicy())\n              || (DereferenceAliasesPolicy.IN_SEARCHING.equals(getDerefPolicy()) && SearchScope.WHOLE_SUBTREE.equals(getScope()))\n      ) {\n        final Entry baseEntry=DirectoryServer.getEntry(baseDN);\n        if (baseEntry!=null && baseEntry.isAlias()) {\n          setBaseDN(baseEntry.getAliasedDN());\n          processSearch(executePostOpPlugins);\n          return;\n        }\n      }\n\n      // If there's a persistent search, then register it with the server.\n      boolean processSearchNow = true;\n      if (persistentSearch != null)\n      {\n        // If we're only interested in changes, then we do not actually want\n        // to process the search now.\n        processSearchNow = !persistentSearch.isChangesOnly();\n\n        // The Core server maintains the count of concurrent persistent searches\n        // so that all the backends (Remote and Local) are aware of it. Verify\n        // with the core if we have already reached the threshold.\n        if (!DirectoryServer.allowNewPersistentSearch())\n        {\n          setResultCode(ResultCode.ADMIN_LIMIT_EXCEEDED);\n          appendErrorMessage(ERR_MAX_PSEARCH_LIMIT_EXCEEDED.get());\n          return;\n        }\n        backend.registerPersistentSearch(persistentSearch);\n        persistentSearch.enable();\n      }\n\n\n      if (processSearchNow)\n      {\n        // Process the search in the backend and all its subordinates.\n        backend.search(this);\n      }\n    }\n    catch (DirectoryException de)\n    {\n      logger.traceException(de);\n      setResponseData(de);\n\n      if (persistentSearch != null)\n      {\n        persistentSearch.cancel();\n        setSendResponse(true);\n      }\n\n      return;\n    }\n    catch (CanceledOperationException coe)\n    {\n      if (persistentSearch != null)\n      {\n        persistentSearch.cancel();\n        setSendResponse(true);\n      }\n\n      throw coe;\n    }\n    catch (Exception e)\n    {\n      logger.traceException(e);\n\n      setResultCode(DirectoryServer.getCoreConfigManager().getServerErrorResultCode());\n      appendErrorMessage(ERR_SEARCH_BACKEND_EXCEPTION\n          .get(getExceptionMessage(e)));\n\n      if (persistentSearch != null)\n      {\n        persistentSearch.cancel();\n        setSendResponse(true);\n      }\n    }\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "LocalBackendSearchOperation.java",
        "method_name": "processSearch",
        "raw_code": "private void processSearch(AtomicBoolean executePostOpPlugins) throws CanceledOperationException\n  {\n    // Process the search base and filter to convert them from their raw forms\n    // as provided by the client to the forms required for the rest of the\n    // search processing.\n    baseDN = getBaseDN();\n    filter = getFilter();\n\n    if (baseDN == null || filter == null)\n    {\n      return;\n    }\n\n    // Check to see if there are any controls in the request. If so, then\n    // see if there is any special processing required.\n    try\n    {\n      handleRequestControls();\n    }\n    catch (DirectoryException de)\n    {\n      logger.traceException(de);\n\n      setResponseData(de);\n      return;\n    }\n\n\n    // Check to see if the client has permission to perform the search.\n\n    // FIXME: for now assume that this will check all permission\n    // pertinent to the operation. This includes proxy authorization\n    // and any other controls specified.\n    try\n    {\n      if (!getAccessControlHandler().isAllowed(this))\n      {\n        setResultCode(ResultCode.INSUFFICIENT_ACCESS_RIGHTS);\n        appendErrorMessage(ERR_SEARCH_AUTHZ_INSUFFICIENT_ACCESS_RIGHTS.get(baseDN));\n        return;\n      }\n    }\n    catch (DirectoryException e)\n    {\n      setResultCode(e.getResultCode());\n      appendErrorMessage(e.getMessageObject());\n      return;\n    }\n\n    // Check for a request to cancel this operation.\n    checkIfCanceled(false);\n\n\n    // Invoke the pre-operation search plugins.\n    executePostOpPlugins.set(true);\n    if (!processOperationResult(this, getPluginConfigManager().invokePreOperationSearchPlugins(this)))\n    {\n      return;\n    }\n\n\n    // Check for a request to cancel this operation.\n    checkIfCanceled(false);\n\n\n    // Get the backend that should hold the search base. If there is none,\n    // then fail.\n    if (backend == null)\n    {\n      setResultCode(ResultCode.NO_SUCH_OBJECT);\n      appendErrorMessage(ERR_SEARCH_BASE_DOESNT_EXIST.get(baseDN));\n      return;\n    }\n\n\n    // We'll set the result code to \"success\". If a problem occurs, then it\n    // will be overwritten.\n    setResultCode(ResultCode.SUCCESS);\n\n    try\n    {\n      //DereferenceAliasesPolicy\n      if (\n              DereferenceAliasesPolicy.ALWAYS.equals(getDerefPolicy())\n              || DereferenceAliasesPolicy.FINDING_BASE.equals(getDerefPolicy())\n              || (DereferenceAliasesPolicy.IN_SEARCHING.equals(getDerefPolicy()) && SearchScope.WHOLE_SUBTREE.equals(getScope()))\n      ) {\n        final Entry baseEntry=DirectoryServer.getEntry(baseDN);\n        if (baseEntry!=null && baseEntry.isAlias()) {\n          final DN aliasedDn = baseEntry.getAliasedDN();\n          if(!dereferencingDNs.contains(aliasedDn)) { //detect recursive search\n            dereferencingDNs.add(aliasedDn);\n            setBaseDN(aliasedDn);\n            try {\n              processSearch(executePostOpPlugins);\n            } catch (StackOverflowError error) {\n              throw new Exception(error);\n            }\n            dereferencingDNs.remove(aliasedDn);\n            return;\n          }\n        }\n      }\n\n      // If there's a persistent search, then register it with the server.\n      boolean processSearchNow = true;\n      if (persistentSearch != null)\n      {\n        // If we're only interested in changes, then we do not actually want\n        // to process the search now.\n        processSearchNow = !persistentSearch.isChangesOnly();\n\n        // The Core server maintains the count of concurrent persistent searches\n        // so that all the backends (Remote and Local) are aware of it. Verify\n        // with the core if we have already reached the threshold.\n        if (!DirectoryServer.allowNewPersistentSearch())\n        {\n          setResultCode(ResultCode.ADMIN_LIMIT_EXCEEDED);\n          appendErrorMessage(ERR_MAX_PSEARCH_LIMIT_EXCEEDED.get());\n          return;\n        }\n        backend.registerPersistentSearch(persistentSearch);\n        persistentSearch.enable();\n      }\n\n\n      if (processSearchNow)\n      {\n        // Process the search in the backend and all its subordinates.\n        backend.search(this);\n      }\n    }\n    catch (DirectoryException de)\n    {\n      logger.traceException(de);\n      setResponseData(de);\n\n      if (persistentSearch != null)\n      {\n        persistentSearch.cancel();\n        setSendResponse(true);\n      }\n\n      return;\n    }\n    catch (CanceledOperationException coe)\n    {\n      if (persistentSearch != null)\n      {\n        persistentSearch.cancel();\n        setSendResponse(true);\n      }\n\n      throw coe;\n    }\n    catch (Exception e)\n    {\n      logger.traceException(e);\n\n      setResultCode(DirectoryServer.getCoreConfigManager().getServerErrorResultCode());\n      appendErrorMessage(ERR_SEARCH_BACKEND_EXCEPTION\n          .get(getExceptionMessage(e)));\n\n      if (persistentSearch != null)\n      {\n        persistentSearch.cancel();\n        setSendResponse(true);\n      }\n    }\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "OpenDJ",
    "cve_id": "CVE-2025-27497",
    "cwe_list": [
      "CWE-835"
    ],
    "commit_hash": "08aee4724608e4a32baa3c7d7499ec913a275aaf",
    "short_hash": "08aee472",
    "vulnerableMethods_before": [
      {
        "filename": "AliasTestCase.java",
        "method_name": "startServer",
        "raw_code": "@BeforeClass\n    public void startServer() throws Exception {\n        TestCaseUtils.startServer();\n        TestCaseUtils.initializeTestBackend(true);\n\n        TestCaseUtils.addEntries(\n                 \"dn: o=MyCompany, o=test\",\n                        \"o: MyCompany\",\n                        \"objectclass:organization\",\n                        \"\",\n                        \"dn: ou=Area1, o=test\",\n                        \"objectclass: alias\",\n                        \"objectclass: extensibleobject\",\n                        \"ou: Area1\",\n                        \"aliasedObjectName: o=MyCompany, o=test\",\n                        \"\",\n                        \"dn: cn=John Doe, o=MyCompany, o=test\",\n                        \"cn: John Doe\",\n                        \"sn: Doe\",\n                        \"objectclass: person\",\n                        \"\",\n                        \"dn: cn=President, o=MyCompany, o=test\",\n                        \"objectclass: alias\",\n                        \"objectclass: extensibleobject\",\n                        \"cn: President\",\n                        \"aliasedobjectname: cn=John Doe, o=MyCompany, o=test\",\n                        \"\"\n        );\n\n        final LDAPConnectionFactory factory =new LDAPConnectionFactory(\"localhost\", TestCaseUtils.getServerLdapPort());\n        connection = factory.getConnection();\n        connection.bind(\"cn=Directory Manager\", \"password\".toCharArray());\n        assertThat(connection.isValid()).isTrue();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AliasTestCase.java",
        "method_name": "startServer",
        "raw_code": "@BeforeClass\n    public void startServer() throws Exception {\n        TestCaseUtils.startServer();\n        TestCaseUtils.initializeTestBackend(true);\n\n        TestCaseUtils.addEntries(\n                 \"dn: o=MyCompany, o=test\",\n                        \"o: MyCompany\",\n                        \"objectclass:organization\",\n                        \"\",\n                        \"dn: ou=Area1, o=test\",\n                        \"objectclass: alias\",\n                        \"objectclass: extensibleobject\",\n                        \"ou: Area1\",\n                        \"aliasedObjectName: o=MyCompany, o=test\",\n                        \"\",\n                        \"dn: cn=John Doe, o=MyCompany, o=test\",\n                        \"cn: John Doe\",\n                        \"sn: Doe\",\n                        \"objectclass: person\",\n                        \"\",\n                        \"dn: cn=President, o=MyCompany, o=test\",\n                        \"objectclass: alias\",\n                        \"objectclass: extensibleobject\",\n                        \"cn: President\",\n                        \"aliasedobjectname: cn=John Doe, o=MyCompany, o=test\",\n                        \"\",\n\n                        \"dn: ou=employees,o=test\",\n                        \"objectClass: top\",\n                        \"objectClass: organizationalUnit\",\n                        \"ou: employees\",\n                        \"description: All employees\",\n                        \"\",\n                        \"dn: uid=jdoe,ou=employees,o=test\",\n                        \"objectClass: alias\",\n                        \"objectClass: top\",\n                        \"objectClass: extensibleObject\",\n                        \"aliasedObjectName: uid=jdoe,ou=researchers,o=test\",\n                        \"uid: jdoe\",\n                        \"\",\n                        \"dn: ou=researchers,o=test\",\n                        \"objectClass: top\",\n                        \"objectClass: organizationalUnit\",\n                        \"ou: researchers\",\n                        \"description: All reasearchers\",\n                        \"\",\n                        \"dn: uid=jdoe,ou=researchers,o=test\",\n                        \"objectClass: alias\",\n                        \"objectClass: top\",\n                        \"objectClass: extensibleObject\",\n                        \"aliasedObjectName: uid=jdoe,ou=employees,o=test\",\n                        \"uid: jdoe\",\n\n                        \"\",\n                        \"dn: ou=students,o=test\",\n                        \"objectClass: top\",\n                        \"objectClass: organizationalUnit\",\n                        \"ou: students\",\n                        \"description: All students\",\n                        \"\",\n                        \"dn: uid=janedoe,ou=students,o=test\",\n                        \"objectClass: alias\",\n                        \"objectClass: top\",\n                        \"objectClass: extensibleObject\",\n                        \"aliasedObjectName: uid=janedoe,ou=researchers,o=test\",\n                        \"uid: janedoe\",\n                        \"\",\n                        \"dn: uid=janedoe,ou=researchers,o=test\",\n                        \"objectClass: alias\",\n                        \"objectClass: top\",\n                        \"objectClass: extensibleObject\",\n                        \"aliasedObjectName: uid=janedoe,ou=employees,o=test\",\n                        \"uid: janedoe\",\n                        \"\",\n                        \"dn: uid=janedoe,ou=employees,o=test\",\n                        \"objectClass: alias\",\n                        \"objectClass: top\",\n                        \"objectClass: extensibleObject\",\n                        \"aliasedObjectName: uid=janedoe,ou=students,o=test\",\n                        \"uid: janedoe\",\n                        \"\"\n        );\n\n        final LDAPConnectionFactory factory =new LDAPConnectionFactory(\"localhost\", TestCaseUtils.getServerLdapPort());\n        connection = factory.getConnection();\n        connection.bind(\"cn=Directory Manager\", \"password\".toCharArray());\n        assertThat(connection.isValid()).isTrue();\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "OpenDJ",
    "cve_id": "CVE-2025-27497",
    "cwe_list": [
      "CWE-835"
    ],
    "commit_hash": "08aee4724608e4a32baa3c7d7499ec913a275aaf",
    "short_hash": "08aee472",
    "vulnerableMethods_before": [
      {
        "filename": "AliasTestCase.java",
        "method_name": "search",
        "raw_code": "public HashMap<String,SearchResultEntry> search(SearchScope scope,DereferenceAliasesPolicy policy) throws SearchResultReferenceIOException, LdapException {\n        final SearchRequest request =Requests.newSearchRequest(\"ou=Area1,o=test\", scope,\"(objectclass=*)\")\n                .setDereferenceAliasesPolicy(policy);\n        System.out.println(\"---------------------------------------------------------------------------------------\");\n        System.out.println(request);\n\n        HashMap<String,SearchResultEntry> res=new HashMap<>();\n        final ConnectionEntryReader reader = connection.search(request);\n        while (reader.hasNext()) {\n            final SearchResultEntry srEntry = reader.readEntry();\n            System.out.println(srEntry);\n            assertThat(res.put(srEntry.getName().toString(),srEntry)).isNull();\n        }\n        return res;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AliasTestCase.java",
        "method_name": "search",
        "raw_code": "public HashMap<String,SearchResultEntry> search(String dn, SearchScope scope,DereferenceAliasesPolicy policy) throws SearchResultReferenceIOException, LdapException {\n        final SearchRequest request =Requests.newSearchRequest(dn, scope,\"(objectclass=*)\")\n                .setDereferenceAliasesPolicy(policy);\n        System.out.println(\"---------------------------------------------------------------------------------------\");\n        System.out.println(request);\n\n        HashMap<String,SearchResultEntry> res=new HashMap<>();\n        final ConnectionEntryReader reader = connection.search(request);\n        while (reader.hasNext()) {\n            final SearchResultEntry srEntry = reader.readEntry();\n            System.out.println(srEntry);\n            assertThat(res.put(srEntry.getName().toString(),srEntry)).isNull();\n        }\n        return res;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "OpenDJ",
    "cve_id": "CVE-2025-27497",
    "cwe_list": [
      "CWE-835"
    ],
    "commit_hash": "08aee4724608e4a32baa3c7d7499ec913a275aaf",
    "short_hash": "08aee472",
    "vulnerableMethods_before": [
      {
        "filename": "AliasTestCase.java",
        "method_name": "test_base_search",
        "raw_code": "@Test\n    public void test_base_search() throws SearchResultReferenceIOException, LdapException  {\n        HashMap<String,SearchResultEntry> res=search(SearchScope.BASE_OBJECT,DereferenceAliasesPolicy.IN_SEARCHING);\n\n        assertThat(res.containsKey(\"ou=Area1,o=test\")).isTrue();\n        assertThat(res.containsKey(\"o=MyCompany,o=test\")).isFalse();\n        assertThat(res.containsKey(\"cn=President,o=MyCompany,o=test\")).isFalse();\n        assertThat(res.containsKey(\"cn=John Doe,o=MyCompany,o=test\")).isFalse();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AliasTestCase.java",
        "method_name": "test_base_search",
        "raw_code": "@Test\n    public void test_base_search() throws SearchResultReferenceIOException, LdapException  {\n        HashMap<String,SearchResultEntry> res=search(SearchScope.BASE_OBJECT, DereferenceAliasesPolicy.IN_SEARCHING);\n\n        assertThat(res.containsKey(\"ou=Area1,o=test\")).isTrue();\n        assertThat(res.containsKey(\"o=MyCompany,o=test\")).isFalse();\n        assertThat(res.containsKey(\"cn=President,o=MyCompany,o=test\")).isFalse();\n        assertThat(res.containsKey(\"cn=John Doe,o=MyCompany,o=test\")).isFalse();\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "cuba",
    "cve_id": "CVE-2025-32959",
    "cwe_list": [
      "CWE-770"
    ],
    "commit_hash": "42b6c00fd0572b8e52ae31afd1babc827a3161a1",
    "short_hash": "42b6c00f",
    "vulnerableMethods_before": [
      {
        "filename": "FileStorage.java",
        "method_name": "saveStream",
        "raw_code": "@Override\n    public long saveStream(final FileDescriptor fileDescr, final InputStream inputStream) throws FileStorageException {\n        checkFileDescriptor(fileDescr);\n\n        File[] roots = getStorageRoots();\n\n        // Store to primary storage\n\n        checkStorageDefined(roots, fileDescr);\n        checkPrimaryStorageAccessible(roots, fileDescr);\n\n        File dir = getStorageDir(roots[0], fileDescr);\n        dir.mkdirs();\n        checkDirectoryExists(dir);\n\n        final File file = new File(dir, getFileName(fileDescr));\n        checkFileExists(file);\n\n        long size = 0;\n        OutputStream os = null;\n        try {\n            os = FileUtils.openOutputStream(file);\n            size = IOUtils.copyLarge(inputStream, os);\n            os.flush();\n            writeLog(file, false);\n        } catch (IOException e) {\n            IOUtils.closeQuietly(os);\n            FileUtils.deleteQuietly(file);\n\n            throw new FileStorageException(FileStorageException.Type.IO_EXCEPTION, file.getAbsolutePath(), e);\n        } finally {\n            IOUtils.closeQuietly(os);\n        }\n\n        // Copy file to secondary storages asynchronously\n\n        final SecurityContext securityContext = AppContext.getSecurityContext();\n        for (int i = 1; i < roots.length; i++) {\n            if (!roots[i].exists()) {\n                log.error(\"Error saving {} into {} : directory doesn't exist\", fileDescr, roots[i]);\n                continue;\n            }\n\n            File copyDir = getStorageDir(roots[i], fileDescr);\n            final File fileCopy = new File(copyDir, getFileName(fileDescr));\n\n            writeExecutor.submit(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        AppContext.setSecurityContext(securityContext);\n                        FileUtils.copyFile(file, fileCopy, true);\n                        writeLog(fileCopy, false);\n                    } catch (Exception e) {\n                        log.error(\"Error saving {} into {} : {}\", fileDescr, fileCopy.getAbsolutePath(), e.getMessage());\n                    } finally {\n                        AppContext.setSecurityContext(null);\n                    }\n                }\n            });\n        }\n\n        return size;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FileStorage.java",
        "method_name": "saveStream",
        "raw_code": "@Override\n    public long saveStream(final FileDescriptor fileDescr, final InputStream inputStream) throws FileStorageException {\n        checkFileDescriptor(fileDescr);\n\n        File[] roots = getStorageRoots();\n\n        // Store to primary storage\n\n        checkStorageDefined(roots, fileDescr);\n        checkPrimaryStorageAccessible(roots, fileDescr);\n\n        File dir = getStorageDir(roots[0], fileDescr);\n        dir.mkdirs();\n        checkDirectoryExists(dir);\n\n        final File file = new File(dir, getFileName(fileDescr));\n        checkFileExists(file);\n\n        ServerConfig serverConfig = configuration.getConfig(ServerConfig.class);\n        long maxAllowedSize = serverConfig.getFileStorageMaxFileSize().toBytes();\n        long size = 0;\n        OutputStream os = null;\n        try {\n            os = FileUtils.openOutputStream(file);\n            size = IOUtils.copyLarge(inputStream, os, 0, maxAllowedSize);\n\n            if (size >= maxAllowedSize) {\n                if (inputStream.read() != IOUtils.EOF) {\n                    os.close();\n                    if (file.exists()) {\n                        if (!file.delete()) {\n                            log.warn(\"Failed to delete an incorrectly uploaded file '{}'. \" +\n                                            \"File was to large and has been rejected but already loaded part was not deleted.\",\n                                    file.getAbsolutePath());\n                        }\n                    }\n                    throw new FileStorageException(FileStorageException.Type.IO_EXCEPTION,\n                            String.format(\"File is too large: '%s'. Max file size = %s MB is exceeded but there are unread bytes left.\",\n                                    file.getAbsolutePath(),\n                                    serverConfig.getFileStorageMaxFileSize().toMegabytes()));\n                }\n            }\n            os.flush();\n            writeLog(file, false);\n        } catch (IOException e) {\n            IOUtils.closeQuietly(os);\n            FileUtils.deleteQuietly(file);\n\n            throw new FileStorageException(FileStorageException.Type.IO_EXCEPTION, file.getAbsolutePath(), e);\n        } finally {\n            IOUtils.closeQuietly(os);\n        }\n\n        // Copy file to secondary storages asynchronously\n\n        final SecurityContext securityContext = AppContext.getSecurityContext();\n        for (int i = 1; i < roots.length; i++) {\n            if (!roots[i].exists()) {\n                log.error(\"Error saving {} into {} : directory doesn't exist\", fileDescr, roots[i]);\n                continue;\n            }\n\n            File copyDir = getStorageDir(roots[i], fileDescr);\n            final File fileCopy = new File(copyDir, getFileName(fileDescr));\n\n            writeExecutor.submit(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        AppContext.setSecurityContext(securityContext);\n                        FileUtils.copyFile(file, fileCopy, true);\n                        writeLog(fileCopy, false);\n                    } catch (Exception e) {\n                        log.error(\"Error saving {} into {} : {}\", fileDescr, fileCopy.getAbsolutePath(), e.getMessage());\n                    } finally {\n                        AppContext.setSecurityContext(null);\n                    }\n                }\n            });\n        }\n\n        return size;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "snowflake-jdbc",
    "cve_id": "CVE-2025-27496",
    "cwe_list": [
      "CWE-532"
    ],
    "commit_hash": "ef81582ce2f1dbc3c8794a696c94f4fe65fad507",
    "short_hash": "ef81582c",
    "vulnerableMethods_before": [
      {
        "filename": "SnowflakeFileTransferAgent.java",
        "method_name": "parseCommandInGS",
        "raw_code": "private static JsonNode parseCommandInGS(SFStatement statement, String command)\n      throws SnowflakeSQLException {\n    Object result = null;\n    // send the command to GS\n    try {\n      result =\n          statement.executeHelper(\n              command,\n              \"application/json\",\n              null, // bindValues\n              false, // describeOnly\n              false, // internal\n              false, // async\n              new ExecTimeTelemetryData()); // OOB telemetry timing queries\n    } catch (SFException ex) {\n      throw new SnowflakeSQLException(\n          ex.getQueryId(), ex, ex.getSqlState(), ex.getVendorCode(), ex.getParams());\n    }\n\n    JsonNode jsonNode = (JsonNode) result;\n    logger.debug(\"Response: {}\", jsonNode.toString());\n\n    SnowflakeUtil.checkErrorAndThrowException(jsonNode);\n    return jsonNode;\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SnowflakeFileTransferAgent.java",
        "method_name": "parseCommandInGS",
        "raw_code": "private static JsonNode parseCommandInGS(SFStatement statement, String command)\n      throws SnowflakeSQLException {\n    Object result = null;\n    // send the command to GS\n    try {\n      result =\n          statement.executeHelper(\n              command,\n              \"application/json\",\n              null, // bindValues\n              false, // describeOnly\n              false, // internal\n              false, // async\n              new ExecTimeTelemetryData()); // OOB telemetry timing queries\n    } catch (SFException ex) {\n      throw new SnowflakeSQLException(\n          ex.getQueryId(), ex, ex.getSqlState(), ex.getVendorCode(), ex.getParams());\n    }\n\n    JsonNode jsonNode = (JsonNode) result;\n\n    logger.debug(\"Response: {}\", SecretDetector.maskSecrets(jsonNode.toString()));\n\n    SnowflakeUtil.checkErrorAndThrowException(jsonNode);\n    return jsonNode;\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "snowflake-jdbc",
    "cve_id": "CVE-2025-27496",
    "cwe_list": [
      "CWE-532"
    ],
    "commit_hash": "ef81582ce2f1dbc3c8794a696c94f4fe65fad507",
    "short_hash": "ef81582c",
    "vulnerableMethods_before": [
      {
        "filename": "SecretDetector.java",
        "method_name": "maskSecrets",
        "raw_code": "public static String maskSecrets(String text) {\n    return filterAccessTokens(\n        filterConnectionTokens(\n            filterPassword(filterSASTokens(filterAWSKeys(filterOAuthTokens(text))))));\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SecretDetector.java",
        "method_name": "maskSecrets",
        "raw_code": "public static String maskSecrets(String text) {\n    return filterAccessTokens(\n        filterConnectionTokens(\n            filterPassword(\n                filterSASTokens(\n                    filterAWSKeys(filterOAuthTokens(filterEncryptionMaterial(text)))))));\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "snowflake-jdbc",
    "cve_id": "CVE-2025-27496",
    "cwe_list": [
      "CWE-532"
    ],
    "commit_hash": "ef81582ce2f1dbc3c8794a696c94f4fe65fad507",
    "short_hash": "ef81582c",
    "vulnerableMethods_before": [
      {
        "filename": "SecretDetector.java",
        "method_name": "filterAccessTokens",
        "raw_code": "public static String filterAccessTokens(String message) {\n    Matcher awsMatcher = AWS_TOKEN_PATTERN.matcher(message);\n\n    // aws\n    if (awsMatcher.find()) {\n      message = awsMatcher.replaceAll(\"$1\\\":\\\"XXXX\\\"\");\n    }\n\n    // azure\n    Matcher azureMatcher = SAS_TOKEN_PATTERN.matcher(message);\n\n    if (azureMatcher.find()) {\n      message = azureMatcher.replaceAll(\"$1=XXXX\");\n    }\n\n    // GCS\n    Matcher gcsMatcher = PRIVATE_KEY_PATTERN.matcher(message);\n    if (gcsMatcher.find()) {\n      message =\n          gcsMatcher.replaceAll(\n              \"-----BEGIN PRIVATE KEY-----\" // #pragma: allowlist secret\n                  + \"\\\\\\\\nXXXX\\\\\\\\n\"\n                  + \"-----END PRIVATE KEY-----\");\n    }\n\n    gcsMatcher = PRIVATE_KEY_DATA_PATTERN.matcher(message);\n    if (gcsMatcher.find()) {\n      message = gcsMatcher.replaceAll(\"\\\"privateKeyData\\\": \\\"XXXX\\\"\");\n    }\n\n    return message;\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SecretDetector.java",
        "method_name": "filterAccessTokens",
        "raw_code": "public static String filterAccessTokens(String message) {\n    Matcher awsMatcher = AWS_TOKEN_PATTERN.matcher(message);\n\n    // aws\n    if (awsMatcher.find()) {\n      message = awsMatcher.replaceAll(\"$1\\\":\\\"XXXX\\\"\");\n    }\n\n    // azure\n    Matcher azureMatcher = SAS_TOKEN_PATTERN.matcher(message);\n\n    if (azureMatcher.find()) {\n      message = azureMatcher.replaceAll(\"$1=XXXX\");\n    }\n\n    // GCS\n    Matcher gcsMatcher = PRIVATE_KEY_PATTERN.matcher(message);\n    if (gcsMatcher.find()) {\n      message =\n          gcsMatcher.replaceAll(\n              \"-----BEGIN PRIVATE KEY-----\" // #pragma: allowlist secret\n                  + \"\\\\\\\\nXXXX\\\\\\\\n\"\n                  + \"-----END PRIVATE KEY-----\");\n    }\n\n    gcsMatcher = PRIVATE_KEY_DATA_PATTERN.matcher(message);\n    if (gcsMatcher.find()) {\n      message = gcsMatcher.replaceAll(\"\\\"privateKeyData\\\": \\\"XXXX\\\"\");\n    }\n\n    return message;\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "jpawebapi",
    "cve_id": "CVE-2025-32961",
    "cwe_list": [
      "CWE-79"
    ],
    "commit_hash": "78b837d7e2b12d0df69cef1bc6042ebf3bdaf22c",
    "short_hash": "78b837d7",
    "vulnerableMethods_before": [
      {
        "filename": "RestFileDownloadController.java",
        "method_name": "download",
        "raw_code": "@RequestMapping(value = \"/download\", method = RequestMethod.GET)\n    public ModelAndView download(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        UserSession userSession = getSession(request, response);\n        if (userSession == null) {\n            error(response);\n            return null;\n        }\n\n        AppContext.setSecurityContext(new SecurityContext(userSession));\n        try {\n            UUID fileId;\n            try {\n                fileId = UUID.fromString(request.getParameter(\"f\"));\n            } catch (Exception e) {\n                log.error(e.toString());\n                error(response);\n                return null;\n            }\n\n            FileDescriptor fd = dataService.load(new LoadContext<>(FileDescriptor.class).setId(fileId));\n            if (fd == null) {\n                log.warn(\"Unable to find file with id \" + fileId);\n                error(response);\n                return null;\n            }\n\n            String fileName = URLEncodeUtils.encodeUtf8(fd.getName());\n\n            response.setHeader(\"Cache-Control\", \"no-cache\");\n            response.setHeader(\"Pragma\", \"no-cache\");\n            response.setDateHeader(\"Expires\", 0);\n            response.setHeader(\"Content-Type\", getContentType(fd));\n            response.setHeader(\"Pragma\", \"no-cache\");\n\n            boolean attach = Boolean.valueOf(request.getParameter(\"a\"));\n            response.setHeader(\"Content-Disposition\", (attach ? \"attachment\" : \"inline\")\n                    + \"; filename=\" + fileName);\n\n            writeResponse(response, userSession, fd);\n\n        } finally {\n            AppContext.setSecurityContext(null);\n        }\n        return null;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "RestFileDownloadController.java",
        "method_name": "download",
        "raw_code": "@RequestMapping(value = \"/download\", method = RequestMethod.GET)\n    public ModelAndView download(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        UserSession userSession = getSession(request, response);\n        if (userSession == null) {\n            error(response);\n            return null;\n        }\n\n        AppContext.setSecurityContext(new SecurityContext(userSession));\n        try {\n            UUID fileId;\n            try {\n                fileId = UUID.fromString(request.getParameter(\"f\"));\n            } catch (Exception e) {\n                log.error(e.toString());\n                error(response);\n                return null;\n            }\n\n            FileDescriptor fd = dataService.load(new LoadContext<>(FileDescriptor.class).setId(fileId));\n            if (fd == null) {\n                log.warn(\"Unable to find file with id \" + fileId);\n                error(response);\n                return null;\n            }\n\n            String fileName = URLEncodeUtils.encodeUtf8(fd.getName());\n\n            response.setHeader(\"Cache-Control\", \"no-cache\");\n            response.setHeader(\"Pragma\", \"no-cache\");\n            response.setDateHeader(\"Expires\", 0);\n            response.setHeader(\"Content-Type\", getContentType(fd));\n            response.setHeader(\"Pragma\", \"no-cache\");\n\n            boolean attach = Boolean.valueOf(request.getParameter(\"a\"));\n\n            attach = resolveAttachmentValue(attach, fd);\n\n            response.setHeader(\"Content-Disposition\", (attach ? \"attachment\" : \"inline\")\n                    + \"; filename=\" + fileName);\n\n            writeResponse(response, userSession, fd);\n\n        } finally {\n            AppContext.setSecurityContext(null);\n        }\n        return null;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "ruoyi-ai",
    "cve_id": "CVE-2025-6466",
    "cwe_list": [
      "CWE-434"
    ],
    "commit_hash": "4e93ac86d4891c59ecfcd27c051de9b3c5379315",
    "short_hash": "4e93ac86",
    "vulnerableMethods_before": [
      {
        "filename": "SseServiceImpl.java",
        "method_name": "speechToTextTranscriptionsV2",
        "raw_code": "@Override\n    public WhisperResponse speechToTextTranscriptionsV2(MultipartFile file) {\n        // 确保文件不为空\n        if (file.isEmpty()) {\n            throw new IllegalStateException(\"Cannot convert an empty MultipartFile\");\n        }\n        // 创建一个文件对象\n        File fileA = new File(System.getProperty(\"java.io.tmpdir\") + File.separator + file.getOriginalFilename());\n        try {\n            // 将 MultipartFile 的内容写入文件\n            file.transferTo(fileA);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to convert MultipartFile to File\", e);\n        }\n        return openAiStreamClient.speechToTextTranscriptions(fileA);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SseServiceImpl.java",
        "method_name": "speechToTextTranscriptionsV2",
        "raw_code": "@Override\n    public WhisperResponse speechToTextTranscriptionsV2(MultipartFile file) {\n        // 确保文件不为空\n        if (file.isEmpty()) {\n            throw new IllegalStateException(\"Cannot convert an empty MultipartFile\");\n        }\n        if (!FileUtils.isValidFileExtention(file, MimeTypeUtils.AUDIO__EXTENSION)) {\n            throw new IllegalStateException(\"File Extention not supported\");\n        }\n        // 创建一个文件对象\n        File fileA = new File(System.getProperty(\"java.io.tmpdir\") + File.separator + file.getOriginalFilename());\n        try {\n            // 将 MultipartFile 的内容写入文件\n            file.transferTo(fileA);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to convert MultipartFile to File\", e);\n        }\n        return openAiStreamClient.speechToTextTranscriptions(fileA);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "ruoyi-ai",
    "cve_id": "CVE-2025-6466",
    "cwe_list": [
      "CWE-434"
    ],
    "commit_hash": "4e93ac86d4891c59ecfcd27c051de9b3c5379315",
    "short_hash": "4e93ac86",
    "vulnerableMethods_before": [
      {
        "filename": "SseServiceImpl.java",
        "method_name": "upload",
        "raw_code": "@Override\n    public UploadFileResponse upload(MultipartFile file) {\n        openAiStreamClient = chatConfig.getOpenAiStreamClient();\n        return openAiStreamClient.uploadFile(\"fine-tune\", convertMultiPartToFile(file));\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SseServiceImpl.java",
        "method_name": "upload",
        "raw_code": "@Override\n    public UploadFileResponse upload(MultipartFile file) {\n        if (file.isEmpty()) {\n            throw new IllegalStateException(\"Cannot upload an empty MultipartFile\");\n        }\n        if (!FileUtils.isValidFileExtention(file, MimeTypeUtils.DEFAULT_ALLOWED_EXTENSION)) {\n            throw new IllegalStateException(\"File Extention not supported\");\n        }\n        openAiStreamClient = chatConfig.getOpenAiStreamClient();\n        return openAiStreamClient.uploadFile(\"fine-tune\", convertMultiPartToFile(file));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "hmdm-server",
    "cve_id": "CVE-2025-43720",
    "cwe_list": [
      "CWE-862"
    ],
    "commit_hash": "19e4a63f732c99064444df7e8c61b4f01df362e8",
    "short_hash": "19e4a63f",
    "vulnerableMethods_before": [
      {
        "filename": "ConfigureModule.java",
        "method_name": "configure",
        "raw_code": "protected void configure() {\n        this.bindConstant().annotatedWith(Names.named(filesDirectoryParameter)).to(this.context.getInitParameter(filesDirectoryParameter));\n        this.bindConstant().annotatedWith(Names.named(baseUrlParameter)).to(this.context.getInitParameter(baseUrlParameter));\n        this.bindConstant().annotatedWith(Names.named(pluginFilesDirectoryParameter)).to(this.context.getInitParameter(pluginFilesDirectoryParameter));\n        this.bindConstant().annotatedWith(Names.named(usageScenarioParameter)).to(this.context.getInitParameter(usageScenarioParameter));\n        String secureEnrollment = this.context.getInitParameter(secureEnrollmentParameter);\n        this.bindConstant().annotatedWith(Names.named(secureEnrollmentParameter)).to(\n                secureEnrollment != null && (secureEnrollment.equals(\"1\") || secureEnrollment.equalsIgnoreCase(\"true\"))\n        );\n        this.bindConstant().annotatedWith(Names.named(hashSecretParameter)).to(this.context.getInitParameter(hashSecretParameter));\n        String hsts = this.context.getInitParameter(hstsParameter);\n        this.bindConstant().annotatedWith(Names.named(hstsParameter)).to(\n                hsts != null && (hsts.equals(\"1\") || hsts.equalsIgnoreCase(\"true\"))\n        );\n        this.bindConstant().annotatedWith(Names.named(aaptCommandParameter)).to(this.context.getInitParameter(aaptCommandParameter));\n        this.bindConstant().annotatedWith(Names.named(roleOrgadminIdParameter)).to(\n                Integer.parseInt(this.context.getInitParameter(roleOrgadminIdParameter))\n        );\n        String launcherPackage = this.context.getInitParameter(launcherPackageParameter);\n        if (launcherPackage == null) {\n            launcherPackage = Application.DEFAULT_LAUNCHER_PACKAGE;\n        }\n        this.bindConstant().annotatedWith(Names.named(launcherPackageParameter)).to(launcherPackage);\n\n        // Optional parameters (Guice doesn't allow to bind string to null)\n        String opt;\n\n        opt = this.context.getInitParameter(baseDirectoryParameter);\n        this.bindConstant().annotatedWith(Names.named(baseDirectoryParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(transmitPasswordParameter);\n        this.bindConstant().annotatedWith(Names.named(transmitPasswordParameter)).to(\n                opt != null && (opt.equals(\"1\") || opt.equalsIgnoreCase(\"true\")));\n        opt = this.context.getInitParameter(authClassParameter);\n        try {\n            Class authImpl = opt != null ? Class.forName(\"com.hmdm.auth.\" + opt + \"Auth\") : LocalAuth.class;\n            this.bind(HmdmAuthInterface.class).annotatedWith(Names.named(authClassParameter))\n                    .to(authImpl);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        // Rebranding\n        opt = this.context.getInitParameter(rebrandingNameParameter);\n        this.bindConstant().annotatedWith(Names.named(rebrandingNameParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(rebrandingVendorParameter);\n        this.bindConstant().annotatedWith(Names.named(rebrandingVendorParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(rebrandingVendorLinkParameter);\n        this.bindConstant().annotatedWith(Names.named(rebrandingVendorLinkParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(rebrandingLogoParameter);\n        this.bindConstant().annotatedWith(Names.named(rebrandingLogoParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(rebrandingMobileNameParameter);\n        this.bindConstant().annotatedWith(Names.named(rebrandingMobileNameParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(rebrandingSignupLinkParameter);\n        this.bindConstant().annotatedWith(Names.named(rebrandingSignupLinkParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(rebrandingTermsLinkParameter);\n        this.bindConstant().annotatedWith(Names.named(rebrandingTermsLinkParameter)).to(opt != null ? opt : \"\");\n\n        // SMTP\n        opt = this.context.getInitParameter(smtpHostParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpHostParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(smtpPortParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpPortParameter)).to(opt != null && !opt.equals(\"\") ? Integer.parseInt(opt): 25);\n        opt = this.context.getInitParameter(smtpSslParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpSslParameter)).to(\n                opt != null && (opt.equals(\"1\") || opt.equalsIgnoreCase(\"true\")));\n        opt = this.context.getInitParameter(smtpStartTlsParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpStartTlsParameter)).to(\n                opt != null && (opt.equals(\"1\") || opt.equalsIgnoreCase(\"true\")));\n        opt = this.context.getInitParameter(smtpSslProtocolsParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpSslProtocolsParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(smtpSslTrustParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpSslTrustParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(smtpUsernameParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpUsernameParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(smtpPasswordParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpPasswordParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(smtpFromParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpFromParameter)).to(opt != null ? opt : \"\");\n\n        // Other\n        opt = this.context.getInitParameter(deviceFastSearchCharsParameter);\n        this.bindConstant().annotatedWith(Names.named(deviceFastSearchCharsParameter)).to(opt != null && !opt.equals(\"\") ? Integer.parseInt(opt): 5);\n        opt = this.context.getInitParameter(sqlInitScriptPath);\n        this.bindConstant().annotatedWith(Names.named(sqlInitScriptPath)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(proxyAddresses);\n        this.bindConstant().annotatedWith(Names.named(proxyAddresses)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(proxyIpHeader);\n        this.bindConstant().annotatedWith(Names.named(proxyIpHeader)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(customerAutoStatus);\n        this.bindConstant().annotatedWith(Names.named(customerAutoStatus)).to(\n                opt != null && (opt.equals(\"1\") || opt.equalsIgnoreCase(\"true\")));\n        opt = this.context.getInitParameter(adminEmail);\n        this.bindConstant().annotatedWith(Names.named(adminEmail)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(mailchimpUrl);\n        this.bindConstant().annotatedWith(Names.named(mailchimpUrl)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(mailchimpKey);\n        this.bindConstant().annotatedWith(Names.named(mailchimpKey)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(customerSignup);\n        this.bindConstant().annotatedWith(Names.named(customerSignup)).to(\n                opt != null && (opt.equals(\"1\") || opt.equalsIgnoreCase(\"true\")));\n        opt = this.context.getInitParameter(customerSignupCopySettings);\n        this.bindConstant().annotatedWith(Names.named(customerSignupCopySettings)).to(\n                opt != null && (opt.equals(\"1\") || opt.equalsIgnoreCase(\"true\")));\n        opt = this.context.getInitParameter(customerSignupConfigurations);\n        this.bindConstant().annotatedWith(Names.named(customerSignupConfigurations)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(customerSignupSupportEmail);\n        this.bindConstant().annotatedWith(Names.named(customerSignupSupportEmail)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(customerSignupDeviceLimit);\n        // I have absolutely no idea why int can't be bound here but it can't!!!\n        // Let's proceed as an Indian and send String to SignupResource instead of int :-/\n        this.bindConstant().annotatedWith(Names.named(customerSignupDeviceLimit)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(customerSignupSizeLimit);\n        this.bindConstant().annotatedWith(Names.named(customerSignupSizeLimit)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(customerSignupExpiryDays);\n        this.bindConstant().annotatedWith(Names.named(customerSignupExpiryDays)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(customerSignupDeviceConfig);\n        this.bindConstant().annotatedWith(Names.named(customerSignupDeviceConfig)).to(opt != null ? opt : \"\");\n\n        opt = this.context.getInitParameter(emailRecoverySubj);\n        this.bindConstant().annotatedWith(Names.named(emailRecoverySubj)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(emailRecoveryBody);\n        this.bindConstant().annotatedWith(Names.named(emailRecoveryBody)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(emailSignupSubj);\n        this.bindConstant().annotatedWith(Names.named(emailSignupSubj)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(emailSignupBody);\n        this.bindConstant().annotatedWith(Names.named(emailSignupBody)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(emailSignupCompleteSubj);\n        this.bindConstant().annotatedWith(Names.named(emailSignupCompleteSubj)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(emailSignupCompleteBody);\n        this.bindConstant().annotatedWith(Names.named(emailSignupCompleteBody)).to(opt != null ? opt : \"\");\n\n        opt = this.context.getInitParameter(ldapAdminBind);\n        this.bindConstant().annotatedWith(Names.named(ldapAdminBind)).to(\n                opt != null && (opt.equals(\"1\") || opt.equalsIgnoreCase(\"true\")));\n        opt = this.context.getInitParameter(ldapHost);\n        this.bindConstant().annotatedWith(Names.named(ldapHost)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(ldapPort);\n        this.bindConstant().annotatedWith(Names.named(ldapPort)).to(opt != null && !opt.equals(\"\") ? Integer.parseInt(opt): 389);\n        opt = this.context.getInitParameter(ldapBaseDn);\n        this.bindConstant().annotatedWith(Names.named(ldapBaseDn)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(ldapAdminDn);\n        this.bindConstant().annotatedWith(Names.named(ldapAdminDn)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(ldapAdminPassword);\n        this.bindConstant().annotatedWith(Names.named(ldapAdminPassword)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(ldapUsernameAttribute);\n        this.bindConstant().annotatedWith(Names.named(ldapUsernameAttribute)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(ldapUserDn);\n        this.bindConstant().annotatedWith(Names.named(ldapUserDn)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(ldapDefaultRole);\n        this.bindConstant().annotatedWith(Names.named(ldapDefaultRole)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(ldapCustomerId);\n        this.bindConstant().annotatedWith(Names.named(ldapCustomerId)).to(opt != null && !opt.equals(\"\") ? Integer.parseInt(opt): 1);\n        opt = this.context.getInitParameter(deviceAllowedAddress);\n        this.bindConstant().annotatedWith(Names.named(deviceAllowedAddress)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(uiAllowedAddress);\n        this.bindConstant().annotatedWith(Names.named(uiAllowedAddress)).to(opt != null ? opt : \"\");\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ConfigureModule.java",
        "method_name": "configure",
        "raw_code": "protected void configure() {\n        this.bindConstant().annotatedWith(Names.named(filesDirectoryParameter)).to(this.context.getInitParameter(filesDirectoryParameter));\n        this.bindConstant().annotatedWith(Names.named(baseUrlParameter)).to(this.context.getInitParameter(baseUrlParameter));\n        this.bindConstant().annotatedWith(Names.named(pluginFilesDirectoryParameter)).to(this.context.getInitParameter(pluginFilesDirectoryParameter));\n        this.bindConstant().annotatedWith(Names.named(usageScenarioParameter)).to(this.context.getInitParameter(usageScenarioParameter));\n        String secureEnrollment = this.context.getInitParameter(secureEnrollmentParameter);\n        this.bindConstant().annotatedWith(Names.named(secureEnrollmentParameter)).to(\n                secureEnrollment != null && (secureEnrollment.equals(\"1\") || secureEnrollment.equalsIgnoreCase(\"true\"))\n        );\n        this.bindConstant().annotatedWith(Names.named(hashSecretParameter)).to(this.context.getInitParameter(hashSecretParameter));\n        String hsts = this.context.getInitParameter(hstsParameter);\n        this.bindConstant().annotatedWith(Names.named(hstsParameter)).to(\n                hsts != null && (hsts.equals(\"1\") || hsts.equalsIgnoreCase(\"true\"))\n        );\n        String preventDuplicate = this.context.getInitParameter(preventDuplicateParameter);\n        this.bindConstant().annotatedWith(Names.named(preventDuplicateParameter)).to(\n                preventDuplicate != null && (preventDuplicate.equals(\"1\") || preventDuplicate.equalsIgnoreCase(\"true\"))\n        );\n        this.bindConstant().annotatedWith(Names.named(aaptCommandParameter)).to(this.context.getInitParameter(aaptCommandParameter));\n        this.bindConstant().annotatedWith(Names.named(roleOrgadminIdParameter)).to(\n                Integer.parseInt(this.context.getInitParameter(roleOrgadminIdParameter))\n        );\n        String launcherPackage = this.context.getInitParameter(launcherPackageParameter);\n        if (launcherPackage == null) {\n            launcherPackage = Application.DEFAULT_LAUNCHER_PACKAGE;\n        }\n        this.bindConstant().annotatedWith(Names.named(launcherPackageParameter)).to(launcherPackage);\n\n        // Optional parameters (Guice doesn't allow to bind string to null)\n        String opt;\n\n        opt = this.context.getInitParameter(baseDirectoryParameter);\n        this.bindConstant().annotatedWith(Names.named(baseDirectoryParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(transmitPasswordParameter);\n        this.bindConstant().annotatedWith(Names.named(transmitPasswordParameter)).to(\n                opt != null && (opt.equals(\"1\") || opt.equalsIgnoreCase(\"true\")));\n        opt = this.context.getInitParameter(authClassParameter);\n        try {\n            Class authImpl = opt != null ? Class.forName(\"com.hmdm.auth.\" + opt + \"Auth\") : LocalAuth.class;\n            this.bind(HmdmAuthInterface.class).annotatedWith(Names.named(authClassParameter))\n                    .to(authImpl);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        // Rebranding\n        opt = this.context.getInitParameter(rebrandingNameParameter);\n        this.bindConstant().annotatedWith(Names.named(rebrandingNameParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(rebrandingVendorParameter);\n        this.bindConstant().annotatedWith(Names.named(rebrandingVendorParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(rebrandingVendorLinkParameter);\n        this.bindConstant().annotatedWith(Names.named(rebrandingVendorLinkParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(rebrandingLogoParameter);\n        this.bindConstant().annotatedWith(Names.named(rebrandingLogoParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(rebrandingMobileNameParameter);\n        this.bindConstant().annotatedWith(Names.named(rebrandingMobileNameParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(rebrandingSignupLinkParameter);\n        this.bindConstant().annotatedWith(Names.named(rebrandingSignupLinkParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(rebrandingTermsLinkParameter);\n        this.bindConstant().annotatedWith(Names.named(rebrandingTermsLinkParameter)).to(opt != null ? opt : \"\");\n\n        // SMTP\n        opt = this.context.getInitParameter(smtpHostParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpHostParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(smtpPortParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpPortParameter)).to(opt != null && !opt.equals(\"\") ? Integer.parseInt(opt): 25);\n        opt = this.context.getInitParameter(smtpSslParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpSslParameter)).to(\n                opt != null && (opt.equals(\"1\") || opt.equalsIgnoreCase(\"true\")));\n        opt = this.context.getInitParameter(smtpStartTlsParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpStartTlsParameter)).to(\n                opt != null && (opt.equals(\"1\") || opt.equalsIgnoreCase(\"true\")));\n        opt = this.context.getInitParameter(smtpSslProtocolsParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpSslProtocolsParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(smtpSslTrustParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpSslTrustParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(smtpUsernameParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpUsernameParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(smtpPasswordParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpPasswordParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(smtpFromParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpFromParameter)).to(opt != null ? opt : \"\");\n\n        // Other\n        opt = this.context.getInitParameter(deviceFastSearchCharsParameter);\n        this.bindConstant().annotatedWith(Names.named(deviceFastSearchCharsParameter)).to(opt != null && !opt.equals(\"\") ? Integer.parseInt(opt): 5);\n        opt = this.context.getInitParameter(sqlInitScriptPath);\n        this.bindConstant().annotatedWith(Names.named(sqlInitScriptPath)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(proxyAddresses);\n        this.bindConstant().annotatedWith(Names.named(proxyAddresses)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(proxyIpHeader);\n        this.bindConstant().annotatedWith(Names.named(proxyIpHeader)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(customerAutoStatus);\n        this.bindConstant().annotatedWith(Names.named(customerAutoStatus)).to(\n                opt != null && (opt.equals(\"1\") || opt.equalsIgnoreCase(\"true\")));\n        opt = this.context.getInitParameter(adminEmail);\n        this.bindConstant().annotatedWith(Names.named(adminEmail)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(mailchimpUrl);\n        this.bindConstant().annotatedWith(Names.named(mailchimpUrl)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(mailchimpKey);\n        this.bindConstant().annotatedWith(Names.named(mailchimpKey)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(customerSignup);\n        this.bindConstant().annotatedWith(Names.named(customerSignup)).to(\n                opt != null && (opt.equals(\"1\") || opt.equalsIgnoreCase(\"true\")));\n        opt = this.context.getInitParameter(customerSignupCopySettings);\n        this.bindConstant().annotatedWith(Names.named(customerSignupCopySettings)).to(\n                opt != null && (opt.equals(\"1\") || opt.equalsIgnoreCase(\"true\")));\n        opt = this.context.getInitParameter(customerSignupConfigurations);\n        this.bindConstant().annotatedWith(Names.named(customerSignupConfigurations)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(customerSignupSupportEmail);\n        this.bindConstant().annotatedWith(Names.named(customerSignupSupportEmail)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(customerSignupDeviceLimit);\n        // I have absolutely no idea why int can't be bound here but it can't!!!\n        // Let's proceed as an Indian and send String to SignupResource instead of int :-/\n        this.bindConstant().annotatedWith(Names.named(customerSignupDeviceLimit)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(customerSignupSizeLimit);\n        this.bindConstant().annotatedWith(Names.named(customerSignupSizeLimit)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(customerSignupExpiryDays);\n        this.bindConstant().annotatedWith(Names.named(customerSignupExpiryDays)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(customerSignupDeviceConfig);\n        this.bindConstant().annotatedWith(Names.named(customerSignupDeviceConfig)).to(opt != null ? opt : \"\");\n\n        opt = this.context.getInitParameter(emailRecoverySubj);\n        this.bindConstant().annotatedWith(Names.named(emailRecoverySubj)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(emailRecoveryBody);\n        this.bindConstant().annotatedWith(Names.named(emailRecoveryBody)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(emailSignupSubj);\n        this.bindConstant().annotatedWith(Names.named(emailSignupSubj)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(emailSignupBody);\n        this.bindConstant().annotatedWith(Names.named(emailSignupBody)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(emailSignupCompleteSubj);\n        this.bindConstant().annotatedWith(Names.named(emailSignupCompleteSubj)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(emailSignupCompleteBody);\n        this.bindConstant().annotatedWith(Names.named(emailSignupCompleteBody)).to(opt != null ? opt : \"\");\n\n        opt = this.context.getInitParameter(ldapAdminBind);\n        this.bindConstant().annotatedWith(Names.named(ldapAdminBind)).to(\n                opt != null && (opt.equals(\"1\") || opt.equalsIgnoreCase(\"true\")));\n        opt = this.context.getInitParameter(ldapHost);\n        this.bindConstant().annotatedWith(Names.named(ldapHost)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(ldapPort);\n        this.bindConstant().annotatedWith(Names.named(ldapPort)).to(opt != null && !opt.equals(\"\") ? Integer.parseInt(opt): 389);\n        opt = this.context.getInitParameter(ldapBaseDn);\n        this.bindConstant().annotatedWith(Names.named(ldapBaseDn)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(ldapAdminDn);\n        this.bindConstant().annotatedWith(Names.named(ldapAdminDn)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(ldapAdminPassword);\n        this.bindConstant().annotatedWith(Names.named(ldapAdminPassword)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(ldapUsernameAttribute);\n        this.bindConstant().annotatedWith(Names.named(ldapUsernameAttribute)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(ldapUserDn);\n        this.bindConstant().annotatedWith(Names.named(ldapUserDn)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(ldapDefaultRole);\n        this.bindConstant().annotatedWith(Names.named(ldapDefaultRole)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(ldapCustomerId);\n        this.bindConstant().annotatedWith(Names.named(ldapCustomerId)).to(opt != null && !opt.equals(\"\") ? Integer.parseInt(opt): 1);\n        opt = this.context.getInitParameter(deviceAllowedAddress);\n        this.bindConstant().annotatedWith(Names.named(deviceAllowedAddress)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(uiAllowedAddress);\n        this.bindConstant().annotatedWith(Names.named(uiAllowedAddress)).to(opt != null ? opt : \"\");\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "hmdm-server",
    "cve_id": "CVE-2025-43720",
    "cwe_list": [
      "CWE-862"
    ],
    "commit_hash": "19e4a63f732c99064444df7e8c61b4f01df362e8",
    "short_hash": "19e4a63f",
    "vulnerableMethods_before": [
      {
        "filename": "ConfigurationResource.java",
        "method_name": "getAllConfigurations",
        "raw_code": "@ApiOperation(\n            value = \"Get configurations\",\n            notes = \"Gets the list of available configurations\",\n            response = Configuration.class,\n            responseContainer = \"List\"\n    )\n    @GET\n    @Path(\"/search\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public Response getAllConfigurations() {\n        // There should be different permissions to view and edit configurations\n        // By now, let's just remove this check to avoid issues with getting config lists\n//        if (!SecurityContext.get().hasPermission(\"configurations\")) {\n//            log.error(\"Unauthorized attempt to access configurations\");\n//            return Response.PERMISSION_DENIED();\n//        }\n        List<Configuration> configurations = this.configurationDAO.getAllConfigurations();\n        configurations.forEach(c -> c.setBaseUrl(this.configurationDAO.getBaseUrl()));\n        return Response.OK(configurations);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ConfigurationResource.java",
        "method_name": "getAllConfigurations",
        "raw_code": "@ApiOperation(\n            value = \"Get configurations\",\n            notes = \"Gets the list of available configurations\",\n            response = Configuration.class,\n            responseContainer = \"List\"\n    )\n    @GET\n    @Path(\"/search\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public Response getAllConfigurations() {\n        if (!SecurityContext.get().hasPermission(\"configurations\")) {\n            log.error(\"Unauthorized attempt to access configurations\");\n            return Response.PERMISSION_DENIED();\n        }\n        List<Configuration> configurations = this.configurationDAO.getAllConfigurations();\n        configurations.forEach(c -> c.setBaseUrl(this.configurationDAO.getBaseUrl()));\n        return Response.OK(configurations);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "hmdm-server",
    "cve_id": "CVE-2025-43720",
    "cwe_list": [
      "CWE-862"
    ],
    "commit_hash": "19e4a63f732c99064444df7e8c61b4f01df362e8",
    "short_hash": "19e4a63f",
    "vulnerableMethods_before": [
      {
        "filename": "ConfigurationResource.java",
        "method_name": "searchConfigurations",
        "raw_code": "@ApiOperation(\n            value = \"Search configurations\",\n            notes = \"Searches configurations meeting the specified filter value\",\n            response = Configuration.class,\n            responseContainer = \"List\"\n    )\n    @GET\n    @Path(\"/search/{value}\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public Response searchConfigurations(@PathParam(\"value\") String value) {\n//        if (!SecurityContext.get().hasPermission(\"configurations\")) {\n//            log.error(\"Unauthorized attempt to access configurations\");\n//            return Response.PERMISSION_DENIED();\n//        }\n        List<Configuration> configurations = this.configurationDAO.getAllConfigurationsByValue(value);\n        configurations.forEach(c -> c.setBaseUrl(this.configurationDAO.getBaseUrl()));\n        return Response.OK(configurations);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ConfigurationResource.java",
        "method_name": "searchConfigurations",
        "raw_code": "@ApiOperation(\n            value = \"Search configurations\",\n            notes = \"Searches configurations meeting the specified filter value\",\n            response = Configuration.class,\n            responseContainer = \"List\"\n    )\n    @GET\n    @Path(\"/search/{value}\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public Response searchConfigurations(@PathParam(\"value\") String value) {\n        if (!SecurityContext.get().hasPermission(\"configurations\")) {\n            log.error(\"Unauthorized attempt to access configurations\");\n            return Response.PERMISSION_DENIED();\n        }\n        List<Configuration> configurations = this.configurationDAO.getAllConfigurationsByValue(value);\n        configurations.forEach(c -> c.setBaseUrl(this.configurationDAO.getBaseUrl()));\n        return Response.OK(configurations);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "hmdm-server",
    "cve_id": "CVE-2025-43720",
    "cwe_list": [
      "CWE-862"
    ],
    "commit_hash": "19e4a63f732c99064444df7e8c61b4f01df362e8",
    "short_hash": "19e4a63f",
    "vulnerableMethods_before": [
      {
        "filename": "ConfigurationResource.java",
        "method_name": "getConfigurationApplications",
        "raw_code": "@ApiOperation(\n            value = \"Get configuration applications\",\n            notes = \"Gets the list of all applications in context of usage by the requested configuration\",\n            response = Application.class,\n            responseContainer = \"List\"\n    )\n    @GET\n    @Path(\"/applications/{id}\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public Response getConfigurationApplications(@PathParam(\"id\") @ApiParam(\"Configuration ID\") Integer id) {\n//        if (!SecurityContext.get().hasPermission(\"configurations\")) {\n//            log.error(\"Unauthorized attempt to access configuration applications\");\n//            return Response.PERMISSION_DENIED();\n//        }\n        return Response.OK(this.configurationDAO.getConfigurationApplications(id));\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ConfigurationResource.java",
        "method_name": "getConfigurationApplications",
        "raw_code": "@ApiOperation(\n            value = \"Get configuration applications\",\n            notes = \"Gets the list of all applications in context of usage by the requested configuration\",\n            response = Application.class,\n            responseContainer = \"List\"\n    )\n    @GET\n    @Path(\"/applications/{id}\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public Response getConfigurationApplications(@PathParam(\"id\") @ApiParam(\"Configuration ID\") Integer id) {\n        if (!SecurityContext.get().hasPermission(\"configurations\")) {\n            log.error(\"Unauthorized attempt to access configuration applications\");\n            return Response.PERMISSION_DENIED();\n        }\n        return Response.OK(this.configurationDAO.getConfigurationApplications(id));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "hmdm-server",
    "cve_id": "CVE-2025-43720",
    "cwe_list": [
      "CWE-862"
    ],
    "commit_hash": "19e4a63f732c99064444df7e8c61b4f01df362e8",
    "short_hash": "19e4a63f",
    "vulnerableMethods_before": [
      {
        "filename": "ConfigurationResource.java",
        "method_name": "getConfigurationById",
        "raw_code": "@ApiOperation(\n            value = \"Get configuration\",\n            notes = \"Gets the details for configuration referenced by the specified ID\",\n            response = Configuration.class\n    )\n    @GET\n    @Path(\"/{id}\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public Response getConfigurationById(@PathParam(\"id\") Integer id) {\n//        if (!SecurityContext.get().hasPermission(\"configurations\")) {\n//            log.error(\"Unauthorized attempt to access the configuration \" + id);\n//            return Response.PERMISSION_DENIED();\n//        }\n\n        Configuration configurationById = getConfiguration(id);\n\n        return Response.OK(configurationById);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ConfigurationResource.java",
        "method_name": "getConfigurationById",
        "raw_code": "@ApiOperation(\n            value = \"Get configuration\",\n            notes = \"Gets the details for configuration referenced by the specified ID\",\n            response = Configuration.class\n    )\n    @GET\n    @Path(\"/{id}\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public Response getConfigurationById(@PathParam(\"id\") Integer id) {\n        if (!SecurityContext.get().hasPermission(\"configurations\")) {\n            log.error(\"Unauthorized attempt to access the configuration \" + id);\n            return Response.PERMISSION_DENIED();\n        }\n\n        Configuration configurationById = getConfiguration(id);\n\n        return Response.OK(configurationById);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "hmdm-server",
    "cve_id": "CVE-2025-43720",
    "cwe_list": [
      "CWE-862"
    ],
    "commit_hash": "19e4a63f732c99064444df7e8c61b4f01df362e8",
    "short_hash": "19e4a63f",
    "vulnerableMethods_before": [
      {
        "filename": "SyncResource.java",
        "method_name": "getDeviceSetting",
        "raw_code": "@ApiOperation(\n            value = \"Get device settings\",\n            notes = \"Gets the device info and settings from the MDM server.\",\n            response = SyncResponse.class\n    )\n    @GET\n    @Path(\"/configuration/{deviceId}\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public Response getDeviceSetting(@PathParam(\"deviceId\")\n                                     @ApiParam(\"An identifier of device within MDM server\")\n                                     String number,\n                                     @Context HttpServletRequest request,\n                                     @Context HttpServletResponse response) {\n        logger.debug(\"/public/sync/configuration/{}\", number);\n\n        if (secureEnrollment) {\n            if (!CryptoUtil.checkRequestSignature(request.getHeader(HEADER_ENROLLMENT_SIGNATURE), hashSecret + number)) {\n                logger.warn(\"Failed to setup device {}: signature mismatch\", number);\n                return Response.PERMISSION_DENIED();\n            }\n        }\n\n        try {\n            Device dbDevice = this.unsecureDAO.getDeviceByNumber(number);\n            boolean migration = false;\n            boolean foundByImeiOrSerial = false;\n\n            if (dbDevice == null) {\n                dbDevice = this.unsecureDAO.getDeviceByOldNumber(number);\n                migration = dbDevice != null;\n            }\n\n            if (dbDevice == null) {\n                dbDevice = this.unsecureDAO.getDeviceByImeiOrSerial(number);\n                foundByImeiOrSerial = dbDevice != null;\n            }\n\n            // Device creation on demand\n            if (dbDevice == null) {\n                if (unsecureDAO.isSingleCustomer()) {\n                    dbDevice = unsecureDAO.createNewDeviceOnDemand(number);\n                } else {\n                    logger.warn(\"Not allowed to create devices in the multi-tenant setup\");\n                }\n            }\n\n            if (dbDevice != null) {\n                return getDeviceSettingInternal(dbDevice, migration, foundByImeiOrSerial, request, response);\n            } else {\n                logger.warn(\"Requested device {} was not found\", number);\n                return Response.DEVICE_NOT_FOUND_ERROR();\n            }\n        } catch (Exception e) {\n            logger.error(\"Unexpected error when getting device settings\", e);\n            e.printStackTrace();\n            return Response.INTERNAL_ERROR();\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SyncResource.java",
        "method_name": "getDeviceSetting",
        "raw_code": "@ApiOperation(\n            value = \"Get device settings\",\n            notes = \"Gets the device info and settings from the MDM server.\",\n            response = SyncResponse.class\n    )\n    @GET\n    @Path(\"/configuration/{deviceId}\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public Response getDeviceSetting(@PathParam(\"deviceId\")\n                                     @ApiParam(\"An identifier of device within MDM server\")\n                                     String number,\n                                     @Context HttpServletRequest request,\n                                     @Context HttpServletResponse response) {\n        logger.debug(\"/public/sync/configuration/{}\", number);\n\n        if (secureEnrollment) {\n            if (!CryptoUtil.checkRequestSignature(request.getHeader(HEADER_ENROLLMENT_SIGNATURE), hashSecret + number)) {\n                logger.warn(\"Failed to setup device {}: signature mismatch\", number);\n                return Response.PERMISSION_DENIED();\n            }\n        }\n\n        try {\n            Device dbDevice = this.unsecureDAO.getDeviceByNumber(number);\n            boolean migration = false;\n            boolean foundByImeiOrSerial = false;\n\n            if (dbDevice == null) {\n                dbDevice = this.unsecureDAO.getDeviceByOldNumber(number);\n                migration = dbDevice != null;\n            }\n\n            if (dbDevice == null) {\n                dbDevice = this.unsecureDAO.getDeviceByImeiOrSerial(number);\n                foundByImeiOrSerial = dbDevice != null;\n                if (foundByImeiOrSerial) {\n                    logger.info(\"IMEI/Serial {}: assigned existing number: {}\", number, dbDevice.getNumber());\n                }\n            }\n\n            // Device creation on demand\n            if (dbDevice == null) {\n                if (unsecureDAO.isSingleCustomer()) {\n                    dbDevice = unsecureDAO.createNewDeviceOnDemand(number);\n                } else {\n                    logger.warn(\"Not allowed to create devices in the multi-tenant setup\");\n                }\n            }\n\n            if (dbDevice != null) {\n                return getDeviceSettingInternal(dbDevice, migration, foundByImeiOrSerial, request, response);\n            } else {\n                logger.warn(\"Requested device {} was not found\", number);\n                return Response.DEVICE_NOT_FOUND_ERROR();\n            }\n        } catch (Exception e) {\n            logger.error(\"Unexpected error when getting device settings\", e);\n            e.printStackTrace();\n            return Response.INTERNAL_ERROR();\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54385",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "7313dc9b533c70f14b7672379c8b3b63d1fd8f51",
    "short_hash": "7313dc9b",
    "vulnerableMethods_before": [
      {
        "filename": "HqlQueryUtils.java",
        "method_name": "isShortFormStatement",
        "raw_code": "public static boolean isShortFormStatement(String statement)\n    {\n        return StringUtils.startsWithAny(statement.trim().toLowerCase(), \",\", \"where \", \"order by\");\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "HqlQueryUtils.java",
        "method_name": "isShortFormStatement",
        "raw_code": "public static boolean isShortFormStatement(String statement)\n    {\n        return StringUtils.startsWithAny(statement.trim().toLowerCase(), COMMA, WHERE, ORDER_BY);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54385",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "7313dc9b533c70f14b7672379c8b3b63d1fd8f51",
    "short_hash": "7313dc9b",
    "vulnerableMethods_before": [
      {
        "filename": "XWikiHibernateStore.java",
        "method_name": "createSQLQuery",
        "raw_code": "protected String createSQLQuery(String queryPrefix, String whereSQL)\n    {\n        StringBuilder sql = new StringBuilder(queryPrefix);\n\n        String normalizedWhereSQL;\n        if (StringUtils.isBlank(whereSQL)) {\n            normalizedWhereSQL = \"\";\n        } else {\n            normalizedWhereSQL = whereSQL.trim();\n        }\n\n        sql.append(getColumnsForSelectStatement(normalizedWhereSQL));\n        sql.append(\" from XWikiDocument as doc\");\n\n        if (!normalizedWhereSQL.equals(\"\")) {\n            if ((!normalizedWhereSQL.startsWith(\"where\")) && (!normalizedWhereSQL.startsWith(\",\"))) {\n                sql.append(\" where \");\n            } else {\n                sql.append(\" \");\n            }\n            sql.append(normalizedWhereSQL);\n        }\n\n        return sql.toString();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XWikiHibernateStore.java",
        "method_name": "createSQLQuery",
        "raw_code": "protected String createSQLQuery(String queryPrefix, String whereSQL)\n    {\n        return HqlQueryUtils.createLegacySQLQuery(queryPrefix, whereSQL);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54385",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "7313dc9b533c70f14b7672379c8b3b63d1fd8f51",
    "short_hash": "7313dc9b",
    "vulnerableMethods_before": [
      {
        "filename": "XWikiHibernateStore.java",
        "method_name": "getColumnsForSelectStatement",
        "raw_code": "protected String getColumnsForSelectStatement(String whereSQL)\n    {\n        StringBuilder columns = new StringBuilder();\n\n        int orderByPos = whereSQL.toLowerCase().indexOf(\"order by\");\n        if (orderByPos >= 0) {\n            String orderByStatement = whereSQL.substring(orderByPos + \"order by\".length() + 1);\n            StringTokenizer tokenizer = new StringTokenizer(orderByStatement, \",\");\n            while (tokenizer.hasMoreTokens()) {\n                String column = tokenizer.nextToken().trim();\n                // Remove \"desc\" or \"asc\" from the column found\n                column = StringUtils.removeEndIgnoreCase(column, \" desc\");\n                column = StringUtils.removeEndIgnoreCase(column, \" asc\");\n                columns.append(\", \").append(column.trim());\n            }\n        }\n\n        return columns.toString();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XWikiHibernateStore.java",
        "method_name": "getColumnsForSelectStatement",
        "raw_code": "protected String getColumnsForSelectStatement(String whereSQL)\n    {\n        return HqlQueryUtils.getColumnsForSelectStatement(whereSQL);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54385",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "7313dc9b533c70f14b7672379c8b3b63d1fd8f51",
    "short_hash": "7313dc9b",
    "vulnerableMethods_before": [
      {
        "filename": "XWiki.java",
        "method_name": "getMetaclass",
        "raw_code": "public MetaClass getMetaclass()\n    {\n        return this.xwiki.getMetaclass();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XWiki.java",
        "method_name": "getMetaclass",
        "raw_code": "public MetaClass getMetaclass()\n    {\n        return this.xwiki.getMetaclass();\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54385",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "7313dc9b533c70f14b7672379c8b3b63d1fd8f51",
    "short_hash": "7313dc9b",
    "vulnerableMethods_before": [
      {
        "filename": "XWiki.java",
        "method_name": "searchDocuments",
        "raw_code": "@Deprecated\n    public List<String> searchDocuments(String parameterizedWhereClause, List<?> parameterValues) throws XWikiException\n    {\n        return this.xwiki.getStore().searchDocumentsNames(parameterizedWhereClause, parameterValues, getXWikiContext());\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XWiki.java",
        "method_name": "searchDocuments",
        "raw_code": "@Deprecated\n    public List<String> searchDocuments(String parameterizedWhereClause, List<?> parameterValues) throws XWikiException\n    {\n        checkSearchQueryAllowed(parameterizedWhereClause);\n\n        return this.xwiki.getStore().searchDocumentsNames(parameterizedWhereClause, parameterValues, getXWikiContext());\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54385",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "7313dc9b533c70f14b7672379c8b3b63d1fd8f51",
    "short_hash": "7313dc9b",
    "vulnerableMethods_before": [
      {
        "filename": "XWiki.java",
        "method_name": "searchDocumentsNames",
        "raw_code": "@Deprecated\n    public List<String> searchDocumentsNames(String wikiName, String parameterizedWhereClause, int maxResults,\n        int startOffset, List<?> parameterValues) throws XWikiException\n    {\n        String database = this.context.getWikiId();\n\n        try {\n            this.context.setWikiId(wikiName);\n\n            return searchDocuments(parameterizedWhereClause, maxResults, startOffset, parameterValues);\n        } finally {\n            this.context.setWikiId(database);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XWiki.java",
        "method_name": "searchDocumentsNames",
        "raw_code": "@Deprecated\n    public List<String> searchDocumentsNames(String wikiName, String parameterizedWhereClause, int maxResults,\n        int startOffset, List<?> parameterValues) throws XWikiException\n    {\n        String database = this.context.getWikiId();\n\n        try {\n            this.context.setWikiId(wikiName);\n\n            checkSearchQueryAllowed(parameterizedWhereClause);\n\n            return searchDocuments(parameterizedWhereClause, maxResults, startOffset, parameterValues);\n        } finally {\n            this.context.setWikiId(database);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54385",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "7313dc9b533c70f14b7672379c8b3b63d1fd8f51",
    "short_hash": "7313dc9b",
    "vulnerableMethods_before": [
      {
        "filename": "XWiki.java",
        "method_name": "searchSpacesNames",
        "raw_code": "public List<String> searchSpacesNames(String parametrizedSqlClause, int nb, int start, List<?> parameterValues)\n        throws XWikiException\n    {\n        return this.xwiki.getStore().search(\"select distinct doc.space from XWikiDocument doc \" + parametrizedSqlClause,\n            nb, start, parameterValues, this.context);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XWiki.java",
        "method_name": "searchSpacesNames",
        "raw_code": "public List<String> searchSpacesNames(String parameterizedSqlClause, int nb, int start, List<?> parameterValues)\n        throws XWikiException\n    {\n        checkSearchQueryAllowed(parameterizedSqlClause);\n\n        return this.xwiki.getStore().search(\"select distinct doc.space from XWikiDocument doc \" + parameterizedSqlClause,\n            nb, start, parameterValues, this.context);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54385",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "7313dc9b533c70f14b7672379c8b3b63d1fd8f51",
    "short_hash": "7313dc9b",
    "vulnerableMethods_before": [
      {
        "filename": "XWiki.java",
        "method_name": "searchAttachments",
        "raw_code": "public List<Attachment> searchAttachments(String parametrizedSqlClause, int nb, int start, List<?> parameterValues)\n        throws XWikiException\n    {\n        return convertAttachments(\n            this.xwiki.searchAttachments(parametrizedSqlClause, true, nb, start, parameterValues, this.context));\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XWiki.java",
        "method_name": "searchAttachments",
        "raw_code": "public List<Attachment> searchAttachments(String parameterizedSqlClause, int nb, int start, List<?> parameterValues)\n        throws XWikiException\n    {\n        checkSearchQueryAllowed(parameterizedSqlClause);\n\n        return convertAttachments(\n            this.xwiki.searchAttachments(parameterizedSqlClause, true, nb, start, parameterValues, this.context));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54385",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "7313dc9b533c70f14b7672379c8b3b63d1fd8f51",
    "short_hash": "7313dc9b",
    "vulnerableMethods_before": [
      {
        "filename": "XWiki.java",
        "method_name": "countAttachments",
        "raw_code": "public int countAttachments(String parametrizedSqlClause, List<?> parameterValues) throws XWikiException\n    {\n        return this.xwiki.countAttachments(parametrizedSqlClause, parameterValues, this.context);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XWiki.java",
        "method_name": "countAttachments",
        "raw_code": "public int countAttachments(String parameterizedSqlClause, List<?> parameterValues) throws XWikiException\n    {\n        checkSearchQueryAllowed(parameterizedSqlClause);\n\n        return this.xwiki.countAttachments(parameterizedSqlClause, parameterValues, this.context);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54385",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "7c4087d44ac550610b2fa413dd4f5375409265a5",
    "short_hash": "7c4087d4",
    "vulnerableMethods_before": [
      {
        "filename": "HqlQueryUtils.java",
        "method_name": "isShortFormStatement",
        "raw_code": "public static boolean isShortFormStatement(String statement)\n    {\n        return StringUtils.startsWithAny(statement.trim().toLowerCase(), \",\", \"where \", \"order by\");\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "HqlQueryUtils.java",
        "method_name": "isShortFormStatement",
        "raw_code": "public static boolean isShortFormStatement(String statement)\n    {\n        return StringUtils.startsWithAny(statement.trim().toLowerCase(), COMMA, WHERE, ORDER_BY);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54385",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "7c4087d44ac550610b2fa413dd4f5375409265a5",
    "short_hash": "7c4087d4",
    "vulnerableMethods_before": [
      {
        "filename": "XWikiHibernateStore.java",
        "method_name": "createSQLQuery",
        "raw_code": "protected String createSQLQuery(String queryPrefix, String whereSQL)\n    {\n        StringBuilder sql = new StringBuilder(queryPrefix);\n\n        String normalizedWhereSQL;\n        if (StringUtils.isBlank(whereSQL)) {\n            normalizedWhereSQL = \"\";\n        } else {\n            normalizedWhereSQL = whereSQL.trim();\n        }\n\n        sql.append(getColumnsForSelectStatement(normalizedWhereSQL));\n        sql.append(\" from XWikiDocument as doc\");\n\n        if (!normalizedWhereSQL.equals(\"\")) {\n            if ((!normalizedWhereSQL.startsWith(\"where\")) && (!normalizedWhereSQL.startsWith(\",\"))) {\n                sql.append(\" where \");\n            } else {\n                sql.append(\" \");\n            }\n            sql.append(normalizedWhereSQL);\n        }\n\n        return sql.toString();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XWikiHibernateStore.java",
        "method_name": "createSQLQuery",
        "raw_code": "protected String createSQLQuery(String queryPrefix, String whereSQL)\n    {\n        return HqlQueryUtils.createLegacySQLQuery(queryPrefix, whereSQL);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54385",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "7c4087d44ac550610b2fa413dd4f5375409265a5",
    "short_hash": "7c4087d4",
    "vulnerableMethods_before": [
      {
        "filename": "XWikiHibernateStore.java",
        "method_name": "getColumnsForSelectStatement",
        "raw_code": "protected String getColumnsForSelectStatement(String whereSQL)\n    {\n        StringBuilder columns = new StringBuilder();\n\n        int orderByPos = whereSQL.toLowerCase().indexOf(\"order by\");\n        if (orderByPos >= 0) {\n            String orderByStatement = whereSQL.substring(orderByPos + \"order by\".length() + 1);\n            StringTokenizer tokenizer = new StringTokenizer(orderByStatement, \",\");\n            while (tokenizer.hasMoreTokens()) {\n                String column = tokenizer.nextToken().trim();\n                // Remove \"desc\" or \"asc\" from the column found\n                column = StringUtils.removeEndIgnoreCase(column, \" desc\");\n                column = StringUtils.removeEndIgnoreCase(column, \" asc\");\n                columns.append(\", \").append(column.trim());\n            }\n        }\n\n        return columns.toString();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XWikiHibernateStore.java",
        "method_name": "getColumnsForSelectStatement",
        "raw_code": "protected String getColumnsForSelectStatement(String whereSQL)\n    {\n        return HqlQueryUtils.getColumnsForSelectStatement(whereSQL);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54385",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "7c4087d44ac550610b2fa413dd4f5375409265a5",
    "short_hash": "7c4087d4",
    "vulnerableMethods_before": [
      {
        "filename": "XWiki.java",
        "method_name": "getMetaclass",
        "raw_code": "public MetaClass getMetaclass()\n    {\n        return this.xwiki.getMetaclass();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XWiki.java",
        "method_name": "getMetaclass",
        "raw_code": "public MetaClass getMetaclass()\n    {\n        return this.xwiki.getMetaclass();\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54385",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "7c4087d44ac550610b2fa413dd4f5375409265a5",
    "short_hash": "7c4087d4",
    "vulnerableMethods_before": [
      {
        "filename": "XWiki.java",
        "method_name": "searchDocuments",
        "raw_code": "@Deprecated\n    public List<String> searchDocuments(String parameterizedWhereClause, List<?> parameterValues) throws XWikiException\n    {\n        return this.xwiki.getStore().searchDocumentsNames(parameterizedWhereClause, parameterValues, getXWikiContext());\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XWiki.java",
        "method_name": "searchDocuments",
        "raw_code": "@Deprecated\n    public List<String> searchDocuments(String parameterizedWhereClause, List<?> parameterValues) throws XWikiException\n    {\n        checkSearchQueryAllowed(parameterizedWhereClause);\n\n        return this.xwiki.getStore().searchDocumentsNames(parameterizedWhereClause, parameterValues, getXWikiContext());\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54385",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "7c4087d44ac550610b2fa413dd4f5375409265a5",
    "short_hash": "7c4087d4",
    "vulnerableMethods_before": [
      {
        "filename": "XWiki.java",
        "method_name": "searchDocumentsNames",
        "raw_code": "@Deprecated\n    public List<String> searchDocumentsNames(String wikiName, String parameterizedWhereClause, int maxResults,\n        int startOffset, List<?> parameterValues) throws XWikiException\n    {\n        String database = this.context.getWikiId();\n\n        try {\n            this.context.setWikiId(wikiName);\n\n            return searchDocuments(parameterizedWhereClause, maxResults, startOffset, parameterValues);\n        } finally {\n            this.context.setWikiId(database);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XWiki.java",
        "method_name": "searchDocumentsNames",
        "raw_code": "@Deprecated\n    public List<String> searchDocumentsNames(String wikiName, String parameterizedWhereClause, int maxResults,\n        int startOffset, List<?> parameterValues) throws XWikiException\n    {\n        String database = this.context.getWikiId();\n\n        try {\n            this.context.setWikiId(wikiName);\n\n            checkSearchQueryAllowed(parameterizedWhereClause);\n\n            return searchDocuments(parameterizedWhereClause, maxResults, startOffset, parameterValues);\n        } finally {\n            this.context.setWikiId(database);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54385",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "7c4087d44ac550610b2fa413dd4f5375409265a5",
    "short_hash": "7c4087d4",
    "vulnerableMethods_before": [
      {
        "filename": "XWiki.java",
        "method_name": "searchSpacesNames",
        "raw_code": "public List<String> searchSpacesNames(String parametrizedSqlClause, int nb, int start, List<?> parameterValues)\n        throws XWikiException\n    {\n        return this.xwiki.getStore().search(\"select distinct doc.space from XWikiDocument doc \" + parametrizedSqlClause,\n            nb, start, parameterValues, this.context);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XWiki.java",
        "method_name": "searchSpacesNames",
        "raw_code": "public List<String> searchSpacesNames(String parameterizedSqlClause, int nb, int start, List<?> parameterValues)\n        throws XWikiException\n    {\n        checkSearchQueryAllowed(parameterizedSqlClause);\n\n        return this.xwiki.getStore().search(\"select distinct doc.space from XWikiDocument doc \" + parameterizedSqlClause,\n            nb, start, parameterValues, this.context);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54385",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "7c4087d44ac550610b2fa413dd4f5375409265a5",
    "short_hash": "7c4087d4",
    "vulnerableMethods_before": [
      {
        "filename": "XWiki.java",
        "method_name": "searchAttachments",
        "raw_code": "public List<Attachment> searchAttachments(String parametrizedSqlClause, int nb, int start, List<?> parameterValues)\n        throws XWikiException\n    {\n        return convertAttachments(\n            this.xwiki.searchAttachments(parametrizedSqlClause, true, nb, start, parameterValues, this.context));\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XWiki.java",
        "method_name": "searchAttachments",
        "raw_code": "public List<Attachment> searchAttachments(String parameterizedSqlClause, int nb, int start, List<?> parameterValues)\n        throws XWikiException\n    {\n        checkSearchQueryAllowed(parameterizedSqlClause);\n\n        return convertAttachments(\n            this.xwiki.searchAttachments(parameterizedSqlClause, true, nb, start, parameterValues, this.context));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-54385",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "7c4087d44ac550610b2fa413dd4f5375409265a5",
    "short_hash": "7c4087d4",
    "vulnerableMethods_before": [
      {
        "filename": "XWiki.java",
        "method_name": "countAttachments",
        "raw_code": "public int countAttachments(String parametrizedSqlClause, List<?> parameterValues) throws XWikiException\n    {\n        return this.xwiki.countAttachments(parametrizedSqlClause, parameterValues, this.context);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XWiki.java",
        "method_name": "countAttachments",
        "raw_code": "public int countAttachments(String parameterizedSqlClause, List<?> parameterValues) throws XWikiException\n    {\n        checkSearchQueryAllowed(parameterizedSqlClause);\n\n        return this.xwiki.countAttachments(parameterizedSqlClause, parameterValues, this.context);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "ruoyi-ai",
    "cve_id": "CVE-2025-3199",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "c0daf641fb25b244591b7a6c3affa35c69d321fe",
    "short_hash": "c0daf641",
    "vulnerableMethods_before": [
      {
        "filename": "SysModelController.java",
        "method_name": "export",
        "raw_code": "@Log(title = \"系统模型\", businessType = BusinessType.EXPORT)\n    @PostMapping(\"/export\")\n    public void export(SysModelBo bo, HttpServletResponse response) {\n        List<SysModelVo> list = sysModelService.queryList(bo);\n        ExcelUtil.exportExcel(list, \"系统模型\", SysModelVo.class, response);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SysModelController.java",
        "method_name": "export",
        "raw_code": "@SaCheckPermission(\"system:model:export\")\n    @Log(title = \"系统模型\", businessType = BusinessType.EXPORT)\n    @PostMapping(\"/export\")\n    public void export(SysModelBo bo, HttpServletResponse response) {\n        List<SysModelVo> list = sysModelService.queryList(bo);\n        ExcelUtil.exportExcel(list, \"系统模型\", SysModelVo.class, response);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "ruoyi-ai",
    "cve_id": "CVE-2025-3199",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "c0daf641fb25b244591b7a6c3affa35c69d321fe",
    "short_hash": "c0daf641",
    "vulnerableMethods_before": [
      {
        "filename": "SysModelController.java",
        "method_name": "add",
        "raw_code": "@Log(title = \"系统模型\", businessType = BusinessType.INSERT)\n    @PostMapping()\n    public R<Void> add(@Validated(AddGroup.class) @RequestBody SysModelBo bo) {\n        return toAjax(sysModelService.insertByBo(bo));\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SysModelController.java",
        "method_name": "add",
        "raw_code": "@SaCheckPermission(\"system:model:add\")\n    @Log(title = \"系统模型\", businessType = BusinessType.INSERT)\n    @PostMapping()\n    public R<Void> add(@Validated(AddGroup.class) @RequestBody SysModelBo bo) {\n        return toAjax(sysModelService.insertByBo(bo));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "ruoyi-ai",
    "cve_id": "CVE-2025-3199",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "c0daf641fb25b244591b7a6c3affa35c69d321fe",
    "short_hash": "c0daf641",
    "vulnerableMethods_before": [
      {
        "filename": "SysModelController.java",
        "method_name": "edit",
        "raw_code": "@Log(title = \"系统模型\", businessType = BusinessType.UPDATE)\n    @RepeatSubmit()\n    @PutMapping()\n    public R<Void> edit(@Validated(EditGroup.class) @RequestBody SysModelBo bo) {\n        return toAjax(sysModelService.updateByBo(bo));\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SysModelController.java",
        "method_name": "edit",
        "raw_code": "@SaCheckPermission(\"system:model:edit\")\n    @Log(title = \"系统模型\", businessType = BusinessType.UPDATE)\n    @RepeatSubmit()\n    @PutMapping()\n    public R<Void> edit(@Validated(EditGroup.class) @RequestBody SysModelBo bo) {\n        return toAjax(sysModelService.updateByBo(bo));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "ruoyi-ai",
    "cve_id": "CVE-2025-3202",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "6382e177bf90cc56ff70521842409e35c50df32d",
    "short_hash": "6382e177",
    "vulnerableMethods_before": [
      {
        "filename": "SysNoticeController.java",
        "method_name": "list",
        "raw_code": "@GetMapping(\"/list\")\n    public TableDataInfo<SysNoticeVo> list(SysNoticeBo notice, PageQuery pageQuery) {\n        //公告类型（1通知 2公告）\n        notice.setNoticeType(\"2\");\n        return noticeService.selectPageNoticeList(notice, pageQuery);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SysNoticeController.java",
        "method_name": "list",
        "raw_code": "@SaCheckPermission(\"system:notice:list\")\n    @GetMapping(\"/list\")\n    public TableDataInfo<SysNoticeVo> list(SysNoticeBo notice, PageQuery pageQuery) {\n        //公告类型（1通知 2公告）\n        notice.setNoticeType(\"2\");\n        return noticeService.selectPageNoticeList(notice, pageQuery);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "ruoyi-ai",
    "cve_id": "CVE-2025-3202",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "6382e177bf90cc56ff70521842409e35c50df32d",
    "short_hash": "6382e177",
    "vulnerableMethods_before": [
      {
        "filename": "SysNoticeController.java",
        "method_name": "edit",
        "raw_code": "@Log(title = \"通知公告\", businessType = BusinessType.UPDATE)\n    @PutMapping\n    public R<Void> edit(@Validated @RequestBody SysNoticeBo notice) {\n        return toAjax(noticeService.updateNotice(notice));\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SysNoticeController.java",
        "method_name": "edit",
        "raw_code": "@SaCheckPermission(\"system:notice:edit\")\n    @Log(title = \"通知公告\", businessType = BusinessType.UPDATE)\n    @PutMapping\n    public R<Void> edit(@Validated @RequestBody SysNoticeBo notice) {\n        return toAjax(noticeService.updateNotice(notice));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "open-kilda",
    "cve_id": "CVE-2025-54992",
    "cwe_list": [
      "CWE-611"
    ],
    "commit_hash": "1eddb4983a6287d083e3e99a56dc4c291abd347e",
    "short_hash": "1eddb498",
    "vulnerableMethods_before": [
      {
        "filename": "SamlValidator.java",
        "method_name": "validateCreateProvider",
        "raw_code": "public void validateCreateProvider(MultipartFile file, String name, String entityId, String url, \n            boolean userCreation, List<Long> roleIds) {\n        SamlConfigEntity samlConfigEntity = samlRepository.findByEntityIdOrNameEqualsIgnoreCase(entityId, name);\n        if (samlConfigEntity != null) {\n            throw new RequestValidationException(messageUtil.getAttributeUnique(\"Provider name or Entity Id\"));\n        }\n        if (file == null && url == null) {\n            throw new RequestValidationException(messageUtil.getAttributeNotNull(\"Metadata file or url\"));\n        }\n        if (file != null) {\n            if (!FilenameUtils.getExtension(file.getOriginalFilename()).equals(\"xml\")) {\n                throw new RequestValidationException(messageUtil.getAttributeMetadataInvalid(\"file\"));\n            }\n        }\n        String metadataEntityId = validateEntityId(file, url);\n        if (!metadataEntityId.equals(entityId)) { \n            throw new RequestValidationException(\"Entity Id must be same as Metadata Entity Id\");\n        }\n        if (userCreation) {\n            if (roleIds.isEmpty() || roleIds == null) {\n                throw new RequestValidationException(messageUtil.getAttributeNotNull(\"role\"));\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SamlValidator.java",
        "method_name": "validateCreateProvider",
        "raw_code": "public void validateCreateProvider(MultipartFile file, String name, String entityId, String url,\n            boolean userCreation, List<Long> roleIds) {\n        SamlConfigEntity samlConfigEntity = samlRepository.findByEntityIdOrNameEqualsIgnoreCase(entityId, name);\n        if (samlConfigEntity != null) {\n            throw new RequestValidationException(messageUtil.getAttributeUnique(\"Provider name or Entity Id\"));\n        }\n        if (file == null && url == null) {\n            throw new RequestValidationException(messageUtil.getAttributeNotNull(\"Metadata file or url\"));\n        }\n        if (file != null) {\n            if (!FilenameUtils.getExtension(file.getOriginalFilename()).equals(\"xml\")) {\n                throw new RequestValidationException(messageUtil.getAttributeMetadataInvalid(\"file\"));\n            }\n        }\n        String metadataEntityId = validateEntityId(file, url);\n        if (!metadataEntityId.equals(entityId)) {\n            throw new RequestValidationException(\"Entity Id must be same as Metadata Entity Id\");\n        }\n        if (userCreation) {\n            if (roleIds.isEmpty() || roleIds == null) {\n                throw new RequestValidationException(messageUtil.getAttributeNotNull(\"role\"));\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "open-kilda",
    "cve_id": "CVE-2025-54992",
    "cwe_list": [
      "CWE-611"
    ],
    "commit_hash": "1eddb4983a6287d083e3e99a56dc4c291abd347e",
    "short_hash": "1eddb498",
    "vulnerableMethods_before": [
      {
        "filename": "SamlValidator.java",
        "method_name": "validateUpdateProvider",
        "raw_code": "public SamlConfigEntity validateUpdateProvider(String uuid, MultipartFile file, String name, \n            String entityId, String url, boolean userCreation, List<Long> roleIds) {\n        SamlConfigEntity samlConfigEntity = getEntityByUuid(uuid);\n        SamlConfigEntity configEntity = samlRepository.findByUuidNotAndEntityIdOrUuidNotAndNameEqualsIgnoreCase(\n                uuid, entityId, uuid, name);\n        if (configEntity != null) {\n            throw new RequestValidationException(messageUtil.getAttributeUnique(\"Provider name or Entity Id\"));\n        }\n        if (file != null) {\n            if (!FilenameUtils.getExtension(file.getOriginalFilename()).equals(\"xml\")) {\n                throw new RequestValidationException(messageUtil.getAttributeMetadataInvalid(\"file\"));\n            }\n        }\n        if (file == null && url == null) {\n            if (!samlConfigEntity.getEntityId().equals(entityId)) {\n                throw new RequestValidationException(messageUtil.getAttributeInvalid(\"Entity Id\", entityId));\n            }\n        } else {\n            String metadataEntityId = validateEntityId(file, url);\n            if (!metadataEntityId.equals(entityId)) {\n                throw new RequestValidationException(\"Entity Id must be same as Metadata Entity Id\");\n            } \n        }\n        if (userCreation) {\n            if (roleIds.isEmpty() || roleIds == null) {\n                throw new RequestValidationException(messageUtil.getAttributeNotNull(\"role\"));\n            }\n        }\n        return samlConfigEntity;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SamlValidator.java",
        "method_name": "validateUpdateProvider",
        "raw_code": "public SamlConfigEntity validateUpdateProvider(String uuid, MultipartFile file, String name,\n            String entityId, String url, boolean userCreation, List<Long> roleIds) {\n        SamlConfigEntity samlConfigEntity = getEntityByUuid(uuid);\n        SamlConfigEntity configEntity = samlRepository.findByUuidNotAndEntityIdOrUuidNotAndNameEqualsIgnoreCase(\n                uuid, entityId, uuid, name);\n        if (configEntity != null) {\n            throw new RequestValidationException(messageUtil.getAttributeUnique(\"Provider name or Entity Id\"));\n        }\n        if (file != null) {\n            if (!FilenameUtils.getExtension(file.getOriginalFilename()).equals(\"xml\")) {\n                throw new RequestValidationException(messageUtil.getAttributeMetadataInvalid(\"file\"));\n            }\n        }\n        if (file == null && url == null) {\n            if (!samlConfigEntity.getEntityId().equals(entityId)) {\n                throw new RequestValidationException(messageUtil.getAttributeInvalid(\"Entity Id\", entityId));\n            }\n        } else {\n            String metadataEntityId = validateEntityId(file, url);\n            if (!metadataEntityId.equals(entityId)) {\n                throw new RequestValidationException(\"Entity Id must be same as Metadata Entity Id\");\n            }\n        }\n        if (userCreation) {\n            if (roleIds.isEmpty() || roleIds == null) {\n                throw new RequestValidationException(messageUtil.getAttributeNotNull(\"role\"));\n            }\n        }\n        return samlConfigEntity;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "open-kilda",
    "cve_id": "CVE-2025-54992",
    "cwe_list": [
      "CWE-611"
    ],
    "commit_hash": "1eddb4983a6287d083e3e99a56dc4c291abd347e",
    "short_hash": "1eddb498",
    "vulnerableMethods_before": [
      {
        "filename": "SamlValidator.java",
        "method_name": "validateEntityId",
        "raw_code": "private String validateEntityId(MultipartFile file, String url) {\n        String entityId = null;\n        try {\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder docBuilder = dbFactory.newDocumentBuilder();\n            Document doc = null; \n            if (file != null) {\n                doc = docBuilder.parse(file.getInputStream());\n            } else if (url != null) {\n                doc = docBuilder.parse(new URL(url).openStream());\n            }\n            doc.getDocumentElement().normalize();\n            NodeList nodeList = doc.getElementsByTagName(doc.getDocumentElement().getNodeName());\n            for (int temp = 0; temp < nodeList.getLength(); temp++) {\n                Node node = nodeList.item(temp);\n                if (node.getNodeType() == Node.ELEMENT_NODE) {\n                    Element element = (Element) node;\n                    entityId = element.getAttribute(\"entityID\");\n                }\n            }\n            return entityId;\n        } catch (Exception e) {\n            LOGGER.error(\"Error occurred while validating entity ID\" + e);\n            throw new RequestValidationException(messageUtil.getAttributeMetadataInvalid(\"url\"));\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SamlValidator.java",
        "method_name": "validateEntityId",
        "raw_code": "private String validateEntityId(MultipartFile file, String url) {\n        String entityId = null;\n        try {\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            dbFactory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            dbFactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            dbFactory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            DocumentBuilder docBuilder = dbFactory.newDocumentBuilder();\n            Document doc = null;\n            if (file != null) {\n                doc = docBuilder.parse(file.getInputStream());\n            } else if (url != null) {\n                doc = docBuilder.parse(new URL(url).openStream());\n            }\n            doc.getDocumentElement().normalize();\n            NodeList nodeList = doc.getElementsByTagName(doc.getDocumentElement().getNodeName());\n            for (int temp = 0; temp < nodeList.getLength(); temp++) {\n                Node node = nodeList.item(temp);\n                if (node.getNodeType() == Node.ELEMENT_NODE) {\n                    Element element = (Element) node;\n                    entityId = element.getAttribute(\"entityID\");\n                }\n            }\n            return entityId;\n        } catch (Exception e) {\n            LOGGER.error(\"Error occurred while validating entity ID\" + e);\n            throw new RequestValidationException(messageUtil.getAttributeMetadataInvalid(\"url\"));\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "jooby",
    "cve_id": "CVE-2025-31129",
    "cwe_list": [
      "CWE-502"
    ],
    "commit_hash": "3e13562cf36d7407813eae464e0f4b598de15692",
    "short_hash": "3e13562c",
    "vulnerableMethods_before": [
      {
        "filename": "SessionStoreImpl.java",
        "method_name": "get",
        "raw_code": "@Override\n  public Optional<Object> get(WebContext context, String key) {\n    Optional sessionValue =\n        getSessionOrEmpty(context)\n            .map(session -> session.get(key))\n            .map(SessionStoreImpl::strToObject)\n            .orElseGet(Optional::empty);\n    return sessionValue;\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SessionStoreImpl.java",
        "method_name": "get",
        "raw_code": "@Override\n  public Optional<Object> get(WebContext context, String key) {\n    return getSessionOrEmpty(context)\n        .map(session -> session.get(key))\n        .flatMap(value -> strToObject(context(context).require(Serializer.class), value));\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "jooby",
    "cve_id": "CVE-2025-31129",
    "cwe_list": [
      "CWE-502"
    ],
    "commit_hash": "3e13562cf36d7407813eae464e0f4b598de15692",
    "short_hash": "3e13562c",
    "vulnerableMethods_before": [
      {
        "filename": "SessionStoreImpl.java",
        "method_name": "set",
        "raw_code": "@Override\n  public void set(WebContext context, String key, Object value) {\n    if (value == null || value.toString().length() == 0) {\n      getSessionOrEmpty(context).ifPresent(session -> session.remove(key));\n    } else {\n      String encoded = objToStr(value);\n      getSession(context).put(key, encoded);\n    }\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SessionStoreImpl.java",
        "method_name": "set",
        "raw_code": "@Override\n  public void set(WebContext context, String key, Object value) {\n    if (value == null || value.toString().isEmpty()) {\n      getSessionOrEmpty(context).ifPresent(session -> session.remove(key));\n    } else {\n      String encoded = objToStr(context(context).require(Serializer.class), value);\n      getSession(context).put(key, encoded);\n    }\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "jooby",
    "cve_id": "CVE-2025-31129",
    "cwe_list": [
      "CWE-502"
    ],
    "commit_hash": "3e13562cf36d7407813eae464e0f4b598de15692",
    "short_hash": "3e13562c",
    "vulnerableMethods_before": [
      {
        "filename": "SessionStoreImpl.java",
        "method_name": "renewSession",
        "raw_code": "@Override\n  public boolean renewSession(WebContext context) {\n    getSessionOrEmpty(context).ifPresent(session -> session.renewId());\n    return true;\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SessionStoreImpl.java",
        "method_name": "renewSession",
        "raw_code": "@Override\n  public boolean renewSession(WebContext context) {\n    var session = getSessionOrEmpty(context);\n    session.ifPresent(Session::renewId);\n    return session.isPresent();\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "jooby",
    "cve_id": "CVE-2025-31129",
    "cwe_list": [
      "CWE-502"
    ],
    "commit_hash": "3e13562cf36d7407813eae464e0f4b598de15692",
    "short_hash": "3e13562c",
    "vulnerableMethods_before": [
      {
        "filename": "SessionStoreImpl.java",
        "method_name": "strToObject",
        "raw_code": "static Optional<Object> strToObject(final Value node) {\n    if (node.isMissing()) {\n      return Optional.empty();\n    }\n    String value = node.value();\n    if (value.startsWith(BIN)) {\n      try {\n        byte[] bytes = Base64.getDecoder().decode(value.substring(BIN.length()));\n        return Optional.of(new ObjectInputStream(new ByteArrayInputStream(bytes)).readObject());\n      } catch (Exception x) {\n        throw SneakyThrows.propagate(x);\n      }\n    } else if (value.startsWith(PAC4J)) {\n      return Optional.of(strToAction(value.substring(PAC4J.length())));\n    }\n    return Optional.of(value);\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SessionStoreImpl.java",
        "method_name": "strToObject",
        "raw_code": "static Optional<Object> strToObject(Serializer serializer, Value node) {\n    if (node.isMissing()) {\n      return Optional.empty();\n    }\n    String value = node.value();\n    if (value.startsWith(BIN)) {\n      return Optional.of(serializer.deserializeFromString(value.substring(BIN.length())));\n    } else if (value.startsWith(PAC4J)) {\n      return Optional.of(strToAction(value.substring(PAC4J.length())));\n    }\n    return Optional.of(value);\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "jooby",
    "cve_id": "CVE-2025-31129",
    "cwe_list": [
      "CWE-502"
    ],
    "commit_hash": "3e13562cf36d7407813eae464e0f4b598de15692",
    "short_hash": "3e13562c",
    "vulnerableMethods_before": [
      {
        "filename": "SessionStoreImpl.java",
        "method_name": "objToStr",
        "raw_code": "static String objToStr(final Object value) {\n    if (value instanceof CharSequence || value instanceof Number || value instanceof Boolean) {\n      return value.toString();\n    } else if (value instanceof HttpAction) {\n      return actionToStr((HttpAction) value);\n    }\n    try {\n      ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n      ObjectOutputStream stream = new ObjectOutputStream(bytes);\n      stream.writeObject(value);\n      stream.flush();\n      return BIN + Base64.getEncoder().encodeToString(bytes.toByteArray());\n    } catch (IOException x) {\n      throw SneakyThrows.propagate(x);\n    }\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SessionStoreImpl.java",
        "method_name": "objToStr",
        "raw_code": "static String objToStr(Serializer serializer, Object value) {\n    if (value instanceof CharSequence || value instanceof Number || value instanceof Boolean) {\n      return value.toString();\n    } else if (value instanceof HttpAction) {\n      return actionToStr((HttpAction) value);\n    } else {\n      return BIN + serializer.serializeToString(value);\n    }\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "jooby",
    "cve_id": "CVE-2025-31129",
    "cwe_list": [
      "CWE-502"
    ],
    "commit_hash": "3e13562cf36d7407813eae464e0f4b598de15692",
    "short_hash": "3e13562c",
    "vulnerableMethods_before": [
      {
        "filename": "Pac4jOptions.java",
        "method_name": "setLogoutUrlPattern",
        "raw_code": "public void setLogoutUrlPattern(String logoutUrlPattern) {\n    this.logoutUrlPattern = logoutUrlPattern;\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "Pac4jOptions.java",
        "method_name": "setLogoutUrlPattern",
        "raw_code": "public @NonNull Pac4jOptions setLogoutUrlPattern(String logoutUrlPattern) {\n    this.logoutUrlPattern = logoutUrlPattern;\n    return this;\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "jooby",
    "cve_id": "CVE-2025-31129",
    "cwe_list": [
      "CWE-502"
    ],
    "commit_hash": "3e13562cf36d7407813eae464e0f4b598de15692",
    "short_hash": "3e13562c",
    "vulnerableMethods_before": [
      {
        "filename": "Pac4jModule.java",
        "method_name": "install",
        "raw_code": "@Override\n  public void install(@NonNull Jooby app) throws Exception {\n    app.getServices().putIfAbsent(Pac4jOptions.class, options);\n\n    var clients =\n        ofNullable(options.getClients())\n            /* No client? set a default one: */\n            .orElseGet(Clients::new);\n\n    /* No client instance added from DSL, init them from pac4j config. */\n    if (clientMap == null) {\n      clientMap = initializeClients(options);\n    }\n\n    var contextPath = app.getContextPath().equals(\"/\") ? \"\" : app.getContextPath();\n\n    Map<String, List<ClientReference>> allClients = new LinkedHashMap<>();\n\n    /* Should add simple login form? */\n    var devLogin = false;\n    if (clientMap.isEmpty()) {\n      devLogin = true;\n      client(\n          conf ->\n              new FormClient(\n                  contextPath + \"/login\", new SimpleTestUsernamePasswordAuthenticator()));\n    }\n    var conf = app.getConfig();\n    /* Initialize clients from DSL: */\n    for (var routing : clientMap.entrySet()) {\n      var localClients = allClients.computeIfAbsent(routing.getKey(), k -> new ArrayList<>());\n      var path = routing.getValue();\n      for (var candidate : path.clients) {\n        if (candidate instanceof Class) {\n          localClients.add(new ClientReference((Class<Client>) candidate));\n        } else if (candidate instanceof Client) {\n          localClients.add(new ClientReference((Client) candidate));\n        } else {\n          Function<com.typesafe.config.Config, Client> clientProvider =\n              (Function<com.typesafe.config.Config, Client>) candidate;\n          localClients.add(new ClientReference(clientProvider.apply(conf)));\n        }\n      }\n      allClients.put(routing.getKey(), localClients);\n\n      // check for forwarding authorizers\n      for (var authorizerName : path.authorizers) {\n        Authorizer authorizer = options.getAuthorizers().get(authorizerName);\n        if (authorizer instanceof ForwardingAuthorizer) {\n          ((ForwardingAuthorizer) authorizer).setRegistry(app);\n        }\n      }\n    }\n\n    options.getAuthorizers().put(NoopAuthorizer.NAME, new NoopAuthorizer());\n\n    /* Default callback URL if none was set at client level: */\n    clients.setCallbackUrl(\n        ofNullable(clients.getCallbackUrl()).orElse(contextPath + options.getCallbackPath()));\n    /* Default URL resolver if none was set at client level: */\n    clients.setUrlResolver(\n        ofNullable(clients.getUrlResolver()).orElseGet(Pac4jModule::newUrlResolver));\n\n    /* Set resolved clients: */\n    clients.setClients(\n        allClients.values().stream()\n            .flatMap(List::stream)\n            .filter(ClientReference::isResolved)\n            .map(ClientReference::getClient)\n            .collect(Collectors.toList()));\n    options.setClients(clients);\n\n    /* Delay setting unresolved clients: */\n    var unresolved =\n        allClients.values().stream().flatMap(List::stream).filter(r -> !r.isResolved()).toList();\n\n    if (!unresolved.isEmpty()) {\n      app.onStarting(\n          () -> {\n            List<Client> clientList = new ArrayList<>(clients.getClients());\n            unresolved.stream()\n                .peek(r -> r.resolve(app::require))\n                .map(ClientReference::getClient)\n                .forEachOrdered(clientList::add);\n            clients.setClients(clientList);\n\n            /** If the global client was unresolved at initialization, try to set it now: */\n            List<ClientReference> defaultSecurityFilter = allClients.get(\"*\");\n            if (defaultSecurityFilter != null && options.getDefaultClient() == null) {\n              options.setDefaultClient(defaultSecurityFilter.get(0).getClient().getName());\n            }\n          });\n    }\n\n    /* Set default http action adapter: */\n    options.setHttpActionAdapter(\n        ofNullable(options.getHttpActionAdapter()).orElseGet(Pac4jModule::newActionAdapter));\n\n    /* WebContextFactory: */\n    options.setWebContextFactory(\n        ofNullable(options.getWebContextFactory()).orElseGet(ContextFactoryImpl::new));\n    options.setSessionStoreFactory(\n        ofNullable(options.getSessionStoreFactory()).orElseGet(SessionStoreFactoryImpl::new));\n    options.setProfileManagerFactory(\n        ofNullable(options.getProfileManagerFactory()).orElse(ProfileManagerFactory.DEFAULT));\n\n    if (devLogin) {\n      app.get(\"/login\", new DevLoginForm(options, contextPath + options.getCallbackPath()));\n    }\n\n    /*\n     * If we have multiple clients on specific paths, we collect those path and configure pac4j to\n     * ignore them. So after login they are redirected to the requested url and not to one of this\n     * sign-in endpoints.\n     *\n     * <pre>\n     *   install(new Pac4jModule()\n     *     .client(\"/google\", ...)\n     *     .client(\"/twitter\", ....);\n     *   );\n     * </pre>\n     *\n     * So <code>google</code> and <code>twitter</code> paths are never saved as requested urls.\n     */\n    var excludes =\n        allClients.keySet().stream()\n            .filter(it -> !it.equals(\"*\"))\n            .map(it -> contextPath + it)\n            .collect(Collectors.toSet());\n\n    var callbackLogic = options.getCallbackLogic();\n    if (callbackLogic == null) {\n      options.setCallbackLogic(newCallbackLogic(excludes));\n    }\n    var direct = clients.getClients().stream().allMatch(it -> it instanceof DirectClient);\n    if (!direct || options.isForceCallbackRoutes()) {\n      CallbackFilterImpl callbackFilter = new CallbackFilterImpl(options, options);\n      app.get(options.getCallbackPath(), callbackFilter);\n      app.post(options.getCallbackPath(), callbackFilter);\n    }\n\n    var securityLogic = options.getSecurityLogic();\n    if (securityLogic == null) {\n      options.setSecurityLogic(newSecurityLogic(excludes));\n    }\n\n    /** For each client to a specific path, add a security handler. */\n    for (var entry : allClients.entrySet()) {\n      String pattern = entry.getKey();\n      if (!pattern.equals(\"*\")) {\n        List<String> keys = Router.pathKeys(pattern);\n        if (keys.isEmpty()) {\n          SecurityFilterImpl securityFilter =\n              new SecurityFilterImpl(\n                  null,\n                  options,\n                  options,\n                  lazyClientNameList(entry.getValue()),\n                  clientMap.get(pattern).authorizers);\n          app.get(pattern, securityFilter);\n          // POST for direct authentication\n          app.post(pattern, securityFilter);\n        } else {\n          app.use(\n              new SecurityFilterImpl(\n                  pattern,\n                  options,\n                  options,\n                  lazyClientNameList(entry.getValue()),\n                  clientMap.get(pattern).authorizers));\n        }\n      }\n    }\n\n    /* Is there is a global client, use it as decorator/filter (default client): */\n    var defaultSecurityFilter = allClients.get(\"*\");\n    if (defaultSecurityFilter != null) {\n      if (options.getDefaultClient() == null && defaultSecurityFilter.get(0).isResolved()) {\n        options.setDefaultClient(defaultSecurityFilter.get(0).getClient().getName());\n      }\n      app.use(\n          new SecurityFilterImpl(\n              null,\n              options,\n              options,\n              lazyClientNameList(defaultSecurityFilter),\n              clientMap.get(\"*\").authorizers));\n    }\n\n    /* Logout configuration: */\n    var logoutLogic = options.getLogoutLogic();\n    if (logoutLogic == null) {\n      options.setLogoutLogic(newLogoutLogic());\n    }\n    if (!direct || options.isForceLogoutRoutes()) {\n      app.get(options.getLogoutPath(), new LogoutImpl(options, options));\n    }\n\n    /* Better response code for some errors. */\n    app.errorCode(UnauthorizedAction.class, StatusCode.UNAUTHORIZED);\n    app.errorCode(ForbiddenAction.class, StatusCode.FORBIDDEN);\n\n    /* Compute default url as next available route. We only select static path patterns. */\n    if (options.getDefaultUrl() == null) {\n      int index = app.getRoutes().size();\n      app.onStarting(\n          () -> {\n            List<Route> routes = app.getRoutes();\n            String defaultUrl = app.getContextPath();\n            if (index < routes.size()) {\n              Route route = routes.get(index);\n              if (route.getPathKeys().isEmpty()) {\n                defaultUrl = contextPath + route.getPattern();\n              }\n            }\n            options.setDefaultUrl(defaultUrl);\n          });\n    }\n\n    app.getServices().put(Config.class, options);\n\n    /* Set current user provider */\n    app.setCurrentUser(new Pac4jCurrentUser(options));\n    // cleanup\n    clientMap.clear();\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "Pac4jModule.java",
        "method_name": "install",
        "raw_code": "@Override\n  public void install(@NonNull Jooby app) throws Exception {\n    var services = app.getServices();\n    services.putIfAbsent(Pac4jOptions.class, options);\n    // Set defaults:\n    services.putIfAbsent(Serializer.class, options.getSerializer());\n\n    var clients =\n        ofNullable(options.getClients())\n            /* No client? set a default one: */\n            .orElseGet(Clients::new);\n\n    /* No client instance added from DSL, init them from pac4j config. */\n    if (clientMap == null) {\n      clientMap = initializeClients(options);\n    }\n\n    var contextPath = app.getContextPath().equals(\"/\") ? \"\" : app.getContextPath();\n\n    Map<String, List<ClientReference>> allClients = new LinkedHashMap<>();\n\n    /* Should add simple login form? */\n    var devLogin = false;\n    if (clientMap.isEmpty()) {\n      devLogin = true;\n      client(\n          conf ->\n              new FormClient(\n                  contextPath + \"/login\", new SimpleTestUsernamePasswordAuthenticator()));\n    }\n    var conf = app.getConfig();\n    /* Initialize clients from DSL: */\n    for (var routing : clientMap.entrySet()) {\n      var localClients = allClients.computeIfAbsent(routing.getKey(), k -> new ArrayList<>());\n      var path = routing.getValue();\n      for (var candidate : path.clients) {\n        if (candidate instanceof Class) {\n          localClients.add(new ClientReference((Class<Client>) candidate));\n        } else if (candidate instanceof Client) {\n          localClients.add(new ClientReference((Client) candidate));\n        } else {\n          Function<com.typesafe.config.Config, Client> clientProvider =\n              (Function<com.typesafe.config.Config, Client>) candidate;\n          localClients.add(new ClientReference(clientProvider.apply(conf)));\n        }\n      }\n      allClients.put(routing.getKey(), localClients);\n\n      // check for forwarding authorizers\n      for (var authorizerName : path.authorizers) {\n        Authorizer authorizer = options.getAuthorizers().get(authorizerName);\n        if (authorizer instanceof ForwardingAuthorizer) {\n          ((ForwardingAuthorizer) authorizer).setRegistry(app);\n        }\n      }\n    }\n\n    options.getAuthorizers().put(NoopAuthorizer.NAME, new NoopAuthorizer());\n\n    /* Default callback URL if none was set at client level: */\n    clients.setCallbackUrl(\n        ofNullable(clients.getCallbackUrl()).orElse(contextPath + options.getCallbackPath()));\n    /* Default URL resolver if none was set at client level: */\n    clients.setUrlResolver(\n        ofNullable(clients.getUrlResolver()).orElseGet(Pac4jModule::newUrlResolver));\n\n    /* Set resolved clients: */\n    clients.setClients(\n        allClients.values().stream()\n            .flatMap(List::stream)\n            .filter(ClientReference::isResolved)\n            .map(ClientReference::getClient)\n            .collect(Collectors.toList()));\n    options.setClients(clients);\n\n    /* Delay setting unresolved clients: */\n    var unresolved =\n        allClients.values().stream().flatMap(List::stream).filter(r -> !r.isResolved()).toList();\n\n    if (!unresolved.isEmpty()) {\n      app.onStarting(\n          () -> {\n            List<Client> clientList = new ArrayList<>(clients.getClients());\n            unresolved.stream()\n                .peek(r -> r.resolve(app::require))\n                .map(ClientReference::getClient)\n                .forEachOrdered(clientList::add);\n            clients.setClients(clientList);\n\n            /** If the global client was unresolved at initialization, try to set it now: */\n            List<ClientReference> defaultSecurityFilter = allClients.get(\"*\");\n            if (defaultSecurityFilter != null && options.getDefaultClient() == null) {\n              options.setDefaultClient(defaultSecurityFilter.get(0).getClient().getName());\n            }\n          });\n    }\n\n    /* Set default http action adapter: */\n    options.setHttpActionAdapter(\n        ofNullable(options.getHttpActionAdapter()).orElseGet(Pac4jModule::newActionAdapter));\n\n    /* WebContextFactory: */\n    options.setWebContextFactory(\n        ofNullable(options.getWebContextFactory()).orElseGet(ContextFactoryImpl::new));\n    options.setSessionStoreFactory(\n        ofNullable(options.getSessionStoreFactory()).orElseGet(SessionStoreFactoryImpl::new));\n    options.setProfileManagerFactory(\n        ofNullable(options.getProfileManagerFactory()).orElse(ProfileManagerFactory.DEFAULT));\n\n    if (devLogin) {\n      app.get(\"/login\", new DevLoginForm(options, contextPath + options.getCallbackPath()));\n    }\n\n    /*\n     * If we have multiple clients on specific paths, we collect those path and configure pac4j to\n     * ignore them. So after login they are redirected to the requested url and not to one of this\n     * sign-in endpoints.\n     *\n     * <pre>\n     *   install(new Pac4jModule()\n     *     .client(\"/google\", ...)\n     *     .client(\"/twitter\", ....);\n     *   );\n     * </pre>\n     *\n     * So <code>google</code> and <code>twitter</code> paths are never saved as requested urls.\n     */\n    var excludes =\n        allClients.keySet().stream()\n            .filter(it -> !it.equals(\"*\"))\n            .map(it -> contextPath + it)\n            .collect(Collectors.toSet());\n\n    var callbackLogic = options.getCallbackLogic();\n    if (callbackLogic == null) {\n      options.setCallbackLogic(newCallbackLogic(excludes));\n    }\n    var direct = clients.getClients().stream().allMatch(it -> it instanceof DirectClient);\n    if (!direct || options.isForceCallbackRoutes()) {\n      CallbackFilterImpl callbackFilter = new CallbackFilterImpl(options, options);\n      app.get(options.getCallbackPath(), callbackFilter);\n      app.post(options.getCallbackPath(), callbackFilter);\n    }\n\n    var securityLogic = options.getSecurityLogic();\n    if (securityLogic == null) {\n      options.setSecurityLogic(newSecurityLogic(excludes));\n    }\n    app.use(new UntrustedSessionDataDetector());\n\n    /** For each client to a specific path, add a security handler. */\n    for (var entry : allClients.entrySet()) {\n      String pattern = entry.getKey();\n      if (!pattern.equals(\"*\")) {\n        List<String> keys = Router.pathKeys(pattern);\n        if (keys.isEmpty()) {\n          SecurityFilterImpl securityFilter =\n              new SecurityFilterImpl(\n                  null,\n                  options,\n                  options,\n                  lazyClientNameList(entry.getValue()),\n                  clientMap.get(pattern).authorizers);\n          app.get(pattern, securityFilter);\n          // POST for direct authentication\n          app.post(pattern, securityFilter);\n        } else {\n          app.use(\n              new SecurityFilterImpl(\n                  pattern,\n                  options,\n                  options,\n                  lazyClientNameList(entry.getValue()),\n                  clientMap.get(pattern).authorizers));\n        }\n      }\n    }\n\n    /* Is there is a global client, use it as decorator/filter (default client): */\n    var defaultSecurityFilter = allClients.get(\"*\");\n    if (defaultSecurityFilter != null) {\n      if (options.getDefaultClient() == null && defaultSecurityFilter.get(0).isResolved()) {\n        options.setDefaultClient(defaultSecurityFilter.get(0).getClient().getName());\n      }\n      app.use(\n          new SecurityFilterImpl(\n              null,\n              options,\n              options,\n              lazyClientNameList(defaultSecurityFilter),\n              clientMap.get(\"*\").authorizers));\n    }\n\n    /* Logout configuration: */\n    var logoutLogic = options.getLogoutLogic();\n    if (logoutLogic == null) {\n      options.setLogoutLogic(newLogoutLogic());\n    }\n    if (!direct || options.isForceLogoutRoutes()) {\n      app.get(options.getLogoutPath(), new LogoutImpl(options, options));\n    }\n\n    /* Better response code for some errors. */\n    app.errorCode(UnauthorizedAction.class, StatusCode.UNAUTHORIZED);\n    app.errorCode(ForbiddenAction.class, StatusCode.FORBIDDEN);\n\n    /* Compute default url as next available route. We only select static path patterns. */\n    if (options.getDefaultUrl() == null) {\n      int index = app.getRoutes().size();\n      app.onStarting(\n          () -> {\n            List<Route> routes = app.getRoutes();\n            String defaultUrl = app.getContextPath();\n            if (index < routes.size()) {\n              Route route = routes.get(index);\n              if (route.getPathKeys().isEmpty()) {\n                defaultUrl = contextPath + route.getPattern();\n              }\n            }\n            options.setDefaultUrl(defaultUrl);\n          });\n    }\n\n    app.getServices().put(Config.class, options);\n\n    /* Set current user provider */\n    app.setCurrentUser(new Pac4jCurrentUser(options));\n    // cleanup\n    clientMap.clear();\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "graylog2-server",
    "cve_id": "CVE-2025-30373",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "31bc13d3cd6f550ec83473d0f8666cd3ebf50f10",
    "short_hash": "31bc13d3",
    "vulnerableMethods_before": [
      {
        "filename": "HttpHandler.java",
        "method_name": "channelRead0",
        "raw_code": "@Override\n    protected void channelRead0(ChannelHandlerContext ctx, HttpRequest request) throws Exception {\n        final Channel channel = ctx.channel();\n        final boolean keepAlive = HttpUtil.isKeepAlive(request);\n        final HttpVersion httpRequestVersion = request.protocolVersion();\n        final String origin = request.headers().get(HttpHeaderNames.ORIGIN);\n\n        if (isNotBlank(authorizationHeader)) {\n            // Authentication is required.\n            final String suppliedAuthHeaderValue = request.headers().get(authorizationHeader);\n            if (isBlank(suppliedAuthHeaderValue) || !suppliedAuthHeaderValue.equals(authorizationHeaderValue)) {\n                writeResponse(channel, keepAlive, httpRequestVersion, HttpResponseStatus.UNAUTHORIZED, origin);\n            }\n        }\n\n        // to allow for future changes, let's be at least a little strict in what we accept here.\n        if (HttpMethod.OPTIONS.equals(request.method())) {\n            writeResponse(channel, keepAlive, httpRequestVersion, HttpResponseStatus.OK, origin);\n            return;\n        } else if (!HttpMethod.POST.equals(request.method())) {\n            writeResponse(channel, keepAlive, httpRequestVersion, HttpResponseStatus.METHOD_NOT_ALLOWED, origin);\n            return;\n        }\n\n        final boolean correctPath = path.equals(request.uri());\n        if (correctPath && request instanceof FullHttpRequest) {\n            final FullHttpRequest fullHttpRequest = (FullHttpRequest) request;\n            final ByteBuf buffer = fullHttpRequest.content();\n\n            // send on to raw message handler\n            writeResponse(channel, keepAlive, httpRequestVersion, HttpResponseStatus.ACCEPTED, origin);\n            ctx.fireChannelRead(buffer.retain());\n        } else {\n            writeResponse(channel, keepAlive, httpRequestVersion, HttpResponseStatus.NOT_FOUND, origin);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "HttpHandler.java",
        "method_name": "channelRead0",
        "raw_code": "@Override\n    protected void channelRead0(ChannelHandlerContext ctx, HttpRequest request) throws Exception {\n        final Channel channel = ctx.channel();\n        final boolean keepAlive = HttpUtil.isKeepAlive(request);\n        final HttpVersion httpRequestVersion = request.protocolVersion();\n        final String origin = request.headers().get(HttpHeaderNames.ORIGIN);\n\n        if (isNotBlank(authorizationHeader)) {\n            // Authentication is required.\n            final String suppliedAuthHeaderValue = request.headers().get(authorizationHeader);\n            if (isBlank(suppliedAuthHeaderValue) || !suppliedAuthHeaderValue.equals(authorizationHeaderValue)) {\n                writeResponse(channel, keepAlive, httpRequestVersion, HttpResponseStatus.UNAUTHORIZED, origin);\n                return;\n            }\n        }\n\n        // to allow for future changes, let's be at least a little strict in what we accept here.\n        if (HttpMethod.OPTIONS.equals(request.method())) {\n            writeResponse(channel, keepAlive, httpRequestVersion, HttpResponseStatus.OK, origin);\n            return;\n        } else if (!HttpMethod.POST.equals(request.method())) {\n            writeResponse(channel, keepAlive, httpRequestVersion, HttpResponseStatus.METHOD_NOT_ALLOWED, origin);\n            return;\n        }\n\n        final boolean correctPath = path.equals(request.uri());\n        if (correctPath && request instanceof FullHttpRequest) {\n            final FullHttpRequest fullHttpRequest = (FullHttpRequest) request;\n            final ByteBuf buffer = fullHttpRequest.content();\n\n            // send on to raw message handler\n            writeResponse(channel, keepAlive, httpRequestVersion, HttpResponseStatus.ACCEPTED, origin);\n            ctx.fireChannelRead(buffer.retain());\n        } else {\n            writeResponse(channel, keepAlive, httpRequestVersion, HttpResponseStatus.NOT_FOUND, origin);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "graylog2-server",
    "cve_id": "CVE-2025-30373",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "31bc13d3cd6f550ec83473d0f8666cd3ebf50f10",
    "short_hash": "31bc13d3",
    "vulnerableMethods_before": [
      {
        "filename": "HttpHandlerTest.java",
        "method_name": "testAuthentication",
        "raw_code": "private void testAuthentication(String expectedAuthHeader, String expectedAuthHeaderValue, AsciiString suppliedAuthHeader, String suppliedAuthHeaderValue,\n                                    HttpResponseStatus expectedStatus) {\n        final FullHttpRequest httpRequest = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, \"/gelf\");\n        httpRequest.headers().add(HOST, \"localhost\");\n        httpRequest.headers().add(ORIGIN, \"http://example.com\");\n        httpRequest.headers().add(CONNECTION, HttpHeaderValues.CLOSE);\n        if (suppliedAuthHeader != null) {\n            httpRequest.headers().add(suppliedAuthHeader, suppliedAuthHeaderValue);\n        }\n\n        httpRequest.content().writeBytes(GELF_MESSAGE);\n\n        channel = new EmbeddedChannel(new HttpHandler(true, expectedAuthHeader, expectedAuthHeaderValue, \"/gelf\"));\n        channel.writeInbound(httpRequest);\n        channel.finish();\n\n        final HttpResponse httpResponse = channel.readOutbound();\n        // Request should be successful.\n        assertThat(httpResponse.status()).isEqualTo(expectedStatus);\n        final HttpHeaders headers = httpResponse.headers();\n        assertThat(headers.get(CONTENT_LENGTH)).isEqualTo(\"0\");\n        assertThat(headers.get(ACCESS_CONTROL_ALLOW_ORIGIN)).isEqualTo(\"http://example.com\");\n        assertThat(headers.get(ACCESS_CONTROL_ALLOW_CREDENTIALS)).isEqualTo(\"true\");\n        assertThat(headers.get(ACCESS_CONTROL_ALLOW_HEADERS)).isEqualTo(\"Authorization, Content-Type\");\n        assertThat(headers.get(CONNECTION)).isEqualTo(HttpHeaderValues.CLOSE.toString());\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "HttpHandlerTest.java",
        "method_name": "testAuthentication",
        "raw_code": "private void testAuthentication(String expectedAuthHeader, String expectedAuthHeaderValue, AsciiString suppliedAuthHeader, String suppliedAuthHeaderValue,\n                                    HttpResponseStatus expectedStatus) {\n        final FullHttpRequest httpRequest = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, \"/gelf\");\n        httpRequest.headers().add(HOST, \"localhost\");\n        httpRequest.headers().add(ORIGIN, \"http://example.com\");\n        httpRequest.headers().add(CONNECTION, HttpHeaderValues.CLOSE);\n        if (suppliedAuthHeader != null) {\n            httpRequest.headers().add(suppliedAuthHeader, suppliedAuthHeaderValue);\n        }\n\n        httpRequest.content().writeBytes(GELF_MESSAGE);\n\n        final DownstreamHandler downstreamHandler = new DownstreamHandler();\n        channel = new EmbeddedChannel(new HttpHandler(true, expectedAuthHeader, expectedAuthHeaderValue, \"/gelf\"), downstreamHandler);\n        channel.writeInbound(httpRequest);\n        channel.finish();\n\n        final HttpResponse httpResponse = channel.readOutbound();\n        // Request should be successful.\n        assertThat(httpResponse.status()).isEqualTo(expectedStatus);\n        final HttpHeaders headers = httpResponse.headers();\n        assertThat(headers.get(CONTENT_LENGTH)).isEqualTo(\"0\");\n        assertThat(headers.get(ACCESS_CONTROL_ALLOW_ORIGIN)).isEqualTo(\"http://example.com\");\n        assertThat(headers.get(ACCESS_CONTROL_ALLOW_CREDENTIALS)).isEqualTo(\"true\");\n        assertThat(headers.get(ACCESS_CONTROL_ALLOW_HEADERS)).isEqualTo(\"Authorization, Content-Type\");\n        assertThat(headers.get(CONNECTION)).isEqualTo(HttpHeaderValues.CLOSE.toString());\n        if (expectedStatus == HttpResponseStatus.ACCEPTED) {\n            assertThat(downstreamHandler.received).isTrue();\n        }else if (expectedStatus == HttpResponseStatus.UNAUTHORIZED) {\n            assertThat(downstreamHandler.received).isFalse();\n        } else {\n            throw new AssertionError(\"Unexpected status: \" + expectedStatus);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "EDDI",
    "cve_id": "CVE-2025-32779",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "1e207d0e4f72a5a93920bc0f76cad53ffd8e7065",
    "short_hash": "1e207d0e",
    "vulnerableMethods_before": [
      {
        "filename": "RestImportService.java",
        "method_name": "importBot",
        "raw_code": "@Override\n    public void importBot(InputStream zippedBotConfigFiles, AsyncResponse response) {\n        try {\n            if (response != null) response.setTimeout(60, TimeUnit.SECONDS);\n            File targetDir = new File(FileUtilities.buildPath(tmpPath.toString(), UUID.randomUUID().toString()));\n            importBotZipFile(zippedBotConfigFiles, targetDir, response);\n        } catch (IOException e) {\n            log.error(e.getLocalizedMessage(), e);\n            response.resume(new InternalServerErrorException());\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "RestImportService.java",
        "method_name": "importBot",
        "raw_code": "@Override\n    public void importBot(InputStream zippedBotConfigFiles, AsyncResponse response) {\n        try {\n            if (response != null) response.setTimeout(60, TimeUnit.SECONDS);\n            File targetDir = new File(FileUtilities.buildPath(tmpPath.toString(), UUID.randomUUID().toString()));\n            importBotZipFile(zippedBotConfigFiles, targetDir, response);\n        } catch (IOException e) {\n            log.error(e.getLocalizedMessage(), e);\n            if (response != null) {\n                response.resume(new InternalServerErrorException());\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "EDDI",
    "cve_id": "CVE-2025-32779",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "1e207d0e4f72a5a93920bc0f76cad53ffd8e7065",
    "short_hash": "1e207d0e",
    "vulnerableMethods_before": [
      {
        "filename": "RestImportService.java",
        "method_name": "importBotZipFile",
        "raw_code": "private void importBotZipFile(InputStream zippedBotConfigFiles, File targetDir, AsyncResponse response) throws\n            IOException {\n        this.zipArchive.unzip(zippedBotConfigFiles, targetDir);\n\n        String targetDirPath = targetDir.getPath();\n        Files.newDirectoryStream(Paths.get(targetDirPath),\n                        path -> path.toString().endsWith(BOT_FILE_ENDING))\n                .forEach(botFilePath -> {\n                    try {\n                        String botFileString = readFile(botFilePath);\n                        BotConfiguration botConfiguration =\n                                jsonSerialization.deserialize(botFileString, BotConfiguration.class);\n                        botConfiguration.getPackages().forEach(packageUri ->\n                                parsePackage(targetDirPath, packageUri, botConfiguration, response));\n\n                        URI newBotUri = createNewBot(botConfiguration);\n                        updateDocumentDescriptor(Paths.get(targetDirPath), buildOldBotUri(botFilePath), newBotUri);\n                        response.resume(Response.ok().location(newBotUri).build());\n                    } catch (IOException | RestInterfaceFactory.RestInterfaceFactoryException e) {\n                        log.error(e.getLocalizedMessage(), e);\n                        response.resume(new InternalServerErrorException());\n                    }\n                });\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "RestImportService.java",
        "method_name": "importBotZipFile",
        "raw_code": "private void importBotZipFile(InputStream zippedBotConfigFiles, File targetDir, AsyncResponse response)\n            throws IOException {\n\n        this.zipArchive.unzip(zippedBotConfigFiles, targetDir);\n        var targetDirPath = targetDir.getPath();\n        try (var directoryStream = Files.newDirectoryStream(Paths.get(targetDirPath),\n                path -> path.toString().endsWith(BOT_FILE_ENDING))) {\n            directoryStream.forEach(botFilePath -> {\n                try {\n                    String botFileString = readFile(botFilePath);\n                    BotConfiguration botConfiguration =\n                            jsonSerialization.deserialize(botFileString, BotConfiguration.class);\n                    botConfiguration.getPackages().forEach(packageUri ->\n                            parsePackage(targetDirPath, packageUri, botConfiguration, response));\n\n                    URI newBotUri = createNewBot(botConfiguration);\n                    updateDocumentDescriptor(Paths.get(targetDirPath), buildOldBotUri(botFilePath), newBotUri);\n                    response.resume(Response.ok().location(newBotUri).build());\n                } catch (IOException | RestInterfaceFactory.RestInterfaceFactoryException e) {\n                    log.error(e.getLocalizedMessage(), e);\n                    response.resume(new InternalServerErrorException());\n                }\n            });\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "EDDI",
    "cve_id": "CVE-2025-32779",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "1e207d0e4f72a5a93920bc0f76cad53ffd8e7065",
    "short_hash": "1e207d0e",
    "vulnerableMethods_before": [
      {
        "filename": "RestImportService.java",
        "method_name": "parsePackage",
        "raw_code": "private void parsePackage(String targetDirPath, URI packageUri, BotConfiguration\n            botConfiguration, AsyncResponse response) {\n        try {\n            IResourceId packageResourceId = RestUtilities.extractResourceId(packageUri);\n            String packageId = packageResourceId.getId();\n            String packageVersion = String.valueOf(packageResourceId.getVersion());\n\n            Files.newDirectoryStream(Paths.get(FileUtilities.buildPath(targetDirPath, packageId, packageVersion)),\n                            packageFilePath -> packageFilePath.toString().endsWith(\".package.json\")).\n                    forEach(packageFilePath -> {\n                        try {\n                            Path packagePath = packageFilePath.getParent();\n                            String packageFileString = readFile(packageFilePath);\n\n                            // loading old resources, creating them in the new system,\n                            // updating document descriptor and replacing references in package config\n\n                            // ... for dictionaries\n                            List<URI> dictionaryUris = extractResourcesUris(packageFileString, DICTIONARY_URI_PATTERN);\n                            List<URI> newDictionaryUris = createNewDictionaries(\n                                    readResources(dictionaryUris, packagePath,\n                                            DICTIONARY_EXT, RegularDictionaryConfiguration.class));\n\n                            updateDocumentDescriptor(packagePath, dictionaryUris, newDictionaryUris);\n                            packageFileString = replaceURIs(packageFileString, dictionaryUris, newDictionaryUris);\n\n                            // ... for behavior\n                            List<URI> behaviorUris = extractResourcesUris(packageFileString, BEHAVIOR_URI_PATTERN);\n                            List<URI> newBehaviorUris = createNewBehaviors(\n                                    readResources(behaviorUris, packagePath,\n                                            BEHAVIOR_EXT, BehaviorConfiguration.class));\n\n                            updateDocumentDescriptor(packagePath, behaviorUris, newBehaviorUris);\n                            packageFileString = replaceURIs(packageFileString, behaviorUris, newBehaviorUris);\n\n                            // ... for http calls\n                            List<URI> httpCallsUris = extractResourcesUris(packageFileString, HTTPCALLS_URI_PATTERN);\n                            List<URI> newHttpCallsUris = createNewHttpCalls(\n                                    readResources(httpCallsUris, packagePath,\n                                            HTTPCALLS_EXT, HttpCallsConfiguration.class));\n\n                            updateDocumentDescriptor(packagePath, httpCallsUris, newHttpCallsUris);\n                            packageFileString = replaceURIs(packageFileString, httpCallsUris, newHttpCallsUris);\n\n                            // ... for langchain\n                            List<URI> langchainUris = extractResourcesUris(packageFileString, LANGCHAIN_URI_PATTERN);\n                            List<URI> newLangchainUris = createNewLangchain(\n                                    readResources(langchainUris, packagePath,\n                                            LANGCHAIN_EXT, LangChainConfiguration.class));\n\n                            updateDocumentDescriptor(packagePath, langchainUris, newLangchainUris);\n                            packageFileString = replaceURIs(packageFileString, langchainUris, newLangchainUris);\n\n                            // ... for property\n                            List<URI> propertyUris = extractResourcesUris(packageFileString, PROPERTY_URI_PATTERN);\n                            List<URI> newPropertyUris = createNewProperties(\n                                    readResources(propertyUris, packagePath,\n                                            PROPERTY_EXT, PropertySetterConfiguration.class));\n\n                            updateDocumentDescriptor(packagePath, propertyUris, newPropertyUris);\n                            packageFileString = replaceURIs(packageFileString, propertyUris, newPropertyUris);\n\n                            // ... for output\n                            List<URI> outputUris = extractResourcesUris(packageFileString, OUTPUT_URI_PATTERN);\n                            List<URI> newOutputUris = createNewOutputs(\n                                    readResources(outputUris, packagePath,\n                                            OUTPUT_EXT, OutputConfigurationSet.class));\n\n                            updateDocumentDescriptor(packagePath, outputUris, newOutputUris);\n                            packageFileString = replaceURIs(packageFileString, outputUris, newOutputUris);\n\n                            // creating updated package and replacing references in bot config\n                            URI newPackageUri = createNewPackage(packageFileString);\n                            updateDocumentDescriptor(packagePath, packageUri, newPackageUri);\n                            botConfiguration.setPackages(botConfiguration.getPackages().stream().\n                                    map(uri -> uri.equals(packageUri) ? newPackageUri : uri).\n                                    collect(Collectors.toList()));\n\n                        } catch (IOException | RestInterfaceFactory.RestInterfaceFactoryException |\n                                 CallbackMatcher.CallbackMatcherException e) {\n                            log.error(e.getLocalizedMessage(), e);\n                            response.resume(new InternalServerErrorException());\n                        }\n                    });\n        } catch (IOException e) {\n            log.error(e.getLocalizedMessage(), e);\n            response.resume(new InternalServerErrorException());\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "RestImportService.java",
        "method_name": "parsePackage",
        "raw_code": "private void parsePackage(String targetDirPath, URI packageUri, BotConfiguration\n            botConfiguration, AsyncResponse response) {\n        try {\n            IResourceId packageResourceId = RestUtilities.extractResourceId(packageUri);\n            if (packageResourceId == null) {\n                return;\n            }\n            String packageId = packageResourceId.getId();\n            String packageVersion = String.valueOf(packageResourceId.getVersion());\n\n            var dir = Paths.get(FileUtilities.buildPath(targetDirPath, packageId, packageVersion));\n            try(var directoryStream = Files.newDirectoryStream(dir,\n                    packageFilePath -> packageFilePath.toString().endsWith(\".package.json\"))) {\n                directoryStream.\n                        forEach(packageFilePath -> {\n                            try {\n                                Path packagePath = packageFilePath.getParent();\n                                String packageFileString = readFile(packageFilePath);\n\n                                // loading old resources, creating them in the new system,\n                                // updating document descriptor and replacing references in package config\n\n                                // ... for dictionaries\n                                List<URI> dictionaryUris = extractResourcesUris(packageFileString, DICTIONARY_URI_PATTERN);\n                                List<URI> newDictionaryUris = createNewDictionaries(\n                                        readResources(dictionaryUris, packagePath,\n                                                DICTIONARY_EXT, RegularDictionaryConfiguration.class));\n\n                                updateDocumentDescriptor(packagePath, dictionaryUris, newDictionaryUris);\n                                packageFileString = replaceURIs(packageFileString, dictionaryUris, newDictionaryUris);\n\n                                // ... for behavior\n                                List<URI> behaviorUris = extractResourcesUris(packageFileString, BEHAVIOR_URI_PATTERN);\n                                List<URI> newBehaviorUris = createNewBehaviors(\n                                        readResources(behaviorUris, packagePath,\n                                                BEHAVIOR_EXT, BehaviorConfiguration.class));\n\n                                updateDocumentDescriptor(packagePath, behaviorUris, newBehaviorUris);\n                                packageFileString = replaceURIs(packageFileString, behaviorUris, newBehaviorUris);\n\n                                // ... for http calls\n                                List<URI> httpCallsUris = extractResourcesUris(packageFileString, HTTPCALLS_URI_PATTERN);\n                                List<URI> newHttpCallsUris = createNewHttpCalls(\n                                        readResources(httpCallsUris, packagePath,\n                                                HTTPCALLS_EXT, HttpCallsConfiguration.class));\n\n                                updateDocumentDescriptor(packagePath, httpCallsUris, newHttpCallsUris);\n                                packageFileString = replaceURIs(packageFileString, httpCallsUris, newHttpCallsUris);\n\n                                // ... for langchain\n                                List<URI> langchainUris = extractResourcesUris(packageFileString, LANGCHAIN_URI_PATTERN);\n                                List<URI> newLangchainUris = createNewLangchain(\n                                        readResources(langchainUris, packagePath,\n                                                LANGCHAIN_EXT, LangChainConfiguration.class));\n\n                                updateDocumentDescriptor(packagePath, langchainUris, newLangchainUris);\n                                packageFileString = replaceURIs(packageFileString, langchainUris, newLangchainUris);\n\n                                // ... for property\n                                List<URI> propertyUris = extractResourcesUris(packageFileString, PROPERTY_URI_PATTERN);\n                                List<URI> newPropertyUris = createNewProperties(\n                                        readResources(propertyUris, packagePath,\n                                                PROPERTY_EXT, PropertySetterConfiguration.class));\n\n                                updateDocumentDescriptor(packagePath, propertyUris, newPropertyUris);\n                                packageFileString = replaceURIs(packageFileString, propertyUris, newPropertyUris);\n\n                                // ... for output\n                                List<URI> outputUris = extractResourcesUris(packageFileString, OUTPUT_URI_PATTERN);\n                                List<URI> newOutputUris = createNewOutputs(\n                                        readResources(outputUris, packagePath,\n                                                OUTPUT_EXT, OutputConfigurationSet.class));\n\n                                updateDocumentDescriptor(packagePath, outputUris, newOutputUris);\n                                packageFileString = replaceURIs(packageFileString, outputUris, newOutputUris);\n\n                                // creating updated package and replacing references in bot config\n                                URI newPackageUri = createNewPackage(packageFileString);\n                                updateDocumentDescriptor(packagePath, packageUri, newPackageUri);\n                                botConfiguration.setPackages(botConfiguration.getPackages().stream().\n                                        map(uri -> uri.equals(packageUri) ? newPackageUri : uri).\n                                        collect(Collectors.toList()));\n\n                            } catch (IOException | RestInterfaceFactory.RestInterfaceFactoryException |\n                                     CallbackMatcher.CallbackMatcherException e) {\n                                log.error(e.getLocalizedMessage(), e);\n                                response.resume(new InternalServerErrorException());\n                            }\n                        });\n\n            }\n\n        } catch (IOException e) {\n            log.error(e.getLocalizedMessage(), e);\n            response.resume(new InternalServerErrorException());\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "EDDI",
    "cve_id": "CVE-2025-32779",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "1e207d0e4f72a5a93920bc0f76cad53ffd8e7065",
    "short_hash": "1e207d0e",
    "vulnerableMethods_before": [
      {
        "filename": "RestImportService.java",
        "method_name": "updateDocumentDescriptor",
        "raw_code": "private void updateDocumentDescriptor(Path directoryPath, List<URI> oldUris, List<URI> newUris)\n            throws RestInterfaceFactory.RestInterfaceFactoryException {\n\n        IRestDocumentDescriptorStore restDocumentDescriptorStore = getRestResourceStore(IRestDocumentDescriptorStore.class);\n        IntStream.range(0, oldUris.size()).forEach(idx -> {\n            try {\n                URI oldUri = oldUris.get(idx);\n                IResourceId oldResourceId = RestUtilities.extractResourceId(oldUri);\n                DocumentDescriptor oldDocumentDescriptor = readDocumentDescriptorFromFile(directoryPath, oldResourceId);\n\n                URI newUri = newUris.get(idx);\n                IResourceId newResourceId = RestUtilities.extractResourceId(newUri);\n\n                PatchInstruction<DocumentDescriptor> patchInstruction = new PatchInstruction<>();\n                patchInstruction.setOperation(PatchInstruction.PatchOperation.SET);\n                patchInstruction.setDocument(oldDocumentDescriptor);\n\n                restDocumentDescriptorStore.patchDescriptor(newResourceId.getId(), newResourceId.getVersion(), patchInstruction);\n            } catch (IOException e) {\n                log.error(e.getLocalizedMessage(), e);\n            }\n        });\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "RestImportService.java",
        "method_name": "updateDocumentDescriptor",
        "raw_code": "private void updateDocumentDescriptor(Path directoryPath, List<URI> oldUris, List<URI> newUris)\n            throws RestInterfaceFactory.RestInterfaceFactoryException {\n\n        IRestDocumentDescriptorStore restDocumentDescriptorStore = getRestResourceStore(IRestDocumentDescriptorStore.class);\n        IntStream.range(0, oldUris.size()).forEach(idx -> {\n            try {\n                URI oldUri = oldUris.get(idx);\n                IResourceId oldResourceId = RestUtilities.extractResourceId(oldUri);\n                if (oldResourceId != null) {\n                    var oldDocumentDescriptor = readDocumentDescriptorFromFile(directoryPath, oldResourceId);\n\n                    URI newUri = newUris.get(idx);\n                    IResourceId newResourceId = RestUtilities.extractResourceId(newUri);\n\n                    if (newResourceId != null) {\n                        PatchInstruction<DocumentDescriptor> patchInstruction = new PatchInstruction<>();\n                        patchInstruction.setOperation(PatchInstruction.PatchOperation.SET);\n                        patchInstruction.setDocument(oldDocumentDescriptor);\n\n                        restDocumentDescriptorStore.patchDescriptor(newResourceId.getId(),\n                                newResourceId.getVersion(), patchInstruction);\n                    }\n                }\n            } catch (IOException e) {\n                log.error(e.getLocalizedMessage(), e);\n            }\n        });\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "EDDI",
    "cve_id": "CVE-2025-32779",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "1e207d0e4f72a5a93920bc0f76cad53ffd8e7065",
    "short_hash": "1e207d0e",
    "vulnerableMethods_before": [
      {
        "filename": "RestImportService.java",
        "method_name": "readResources",
        "raw_code": "@SuppressWarnings(\"unchecked\")\n    private <T> List<T> readResources(List<URI> uris, Path packagePath, String extension, Class<T> clazz) {\n        return uris.stream().map(uri -> {\n            Path resourcePath = null;\n            String resourceContent = null;\n            try {\n                IResourceId resourceId = RestUtilities.extractResourceId(uri);\n                resourcePath = createResourcePath(packagePath, resourceId.getId(), extension);\n                resourceContent = readFile(resourcePath);\n                if (uri.toString().startsWith(IRestPropertySetterStore.resourceBaseType)) {\n                    var resourceAsMap = jsonSerialization.deserialize(resourceContent, Map.class);\n                    var migratedPropertySetterDocument =\n                            migrationManager.migratePropertySetter().\n                                    migrate(new Document(resourceAsMap));\n\n                    if (migratedPropertySetterDocument != null) {\n                        resourceContent = jsonSerialization.serialize(migratedPropertySetterDocument);\n                    }\n                } else if (uri.toString().startsWith(IRestHttpCallsStore.resourceBaseType)) {\n                    var resourceAsMap = jsonSerialization.deserialize(resourceContent, Map.class);\n                    var migratedHttpCallsDocument =\n                            migrationManager.migrateHttpCalls().\n                                    migrate(new Document(resourceAsMap));\n\n                    if (migratedHttpCallsDocument != null) {\n                        resourceContent = jsonSerialization.serialize(migratedHttpCallsDocument);\n                    }\n                } else if (uri.toString().startsWith(IRestOutputStore.resourceBaseType)) {\n                    var resourceAsMap = jsonSerialization.deserialize(resourceContent, Map.class);\n                    var migratedOutputDocument =\n                            migrationManager.migrateOutput().\n                                    migrate(new Document(resourceAsMap));\n\n                    if (migratedOutputDocument != null) {\n                        resourceContent = jsonSerialization.serialize(migratedOutputDocument);\n                    }\n                }\n                return jsonSerialization.deserialize(resourceContent, clazz);\n            } catch (IOException e) {\n                log.error(e.getLocalizedMessage(), e);\n                log.error(String.format(\"uri is: %s\", uri));\n                log.error(String.format(\"packagePath is: %s\", packagePath));\n                log.error(String.format(\"resourcePath is: %s\", resourcePath));\n                log.error(String.format(\"resourceContent is:\\n%s\", resourceContent));\n                return null;\n            }\n        }).collect(Collectors.toList());\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "RestImportService.java",
        "method_name": "readResources",
        "raw_code": "@SuppressWarnings(\"unchecked\")\n    private <T> List<T> readResources(List<URI> uris, Path packagePath, String extension, Class<T> clazz) {\n        return uris.stream().map(uri -> {\n            Path resourcePath = null;\n            String resourceContent = null;\n            try {\n                IResourceId resourceId = RestUtilities.extractResourceId(uri);\n                if (resourceId == null) {\n                    throw new IOException(\"resourceId was null\");\n                }\n                resourcePath = createResourcePath(packagePath, resourceId.getId(), extension);\n                resourceContent = readFile(resourcePath);\n                if (uri.toString().startsWith(IRestPropertySetterStore.resourceBaseType)) {\n                    var resourceAsMap = jsonSerialization.deserialize(resourceContent, Map.class);\n                    var migratedPropertySetterDocument =\n                            migrationManager.migratePropertySetter().\n                                    migrate(new Document(resourceAsMap));\n\n                    if (migratedPropertySetterDocument != null) {\n                        resourceContent = jsonSerialization.serialize(migratedPropertySetterDocument);\n                    }\n                } else if (uri.toString().startsWith(IRestHttpCallsStore.resourceBaseType)) {\n                    var resourceAsMap = jsonSerialization.deserialize(resourceContent, Map.class);\n                    var migratedHttpCallsDocument =\n                            migrationManager.migrateHttpCalls().\n                                    migrate(new Document(resourceAsMap));\n\n                    if (migratedHttpCallsDocument != null) {\n                        resourceContent = jsonSerialization.serialize(migratedHttpCallsDocument);\n                    }\n                } else if (uri.toString().startsWith(IRestOutputStore.resourceBaseType)) {\n                    var resourceAsMap = jsonSerialization.deserialize(resourceContent, Map.class);\n                    var migratedOutputDocument =\n                            migrationManager.migrateOutput().\n                                    migrate(new Document(resourceAsMap));\n\n                    if (migratedOutputDocument != null) {\n                        resourceContent = jsonSerialization.serialize(migratedOutputDocument);\n                    }\n                }\n                return jsonSerialization.deserialize(resourceContent, clazz);\n            } catch (IOException e) {\n                log.error(e.getLocalizedMessage(), e);\n                log.error(String.format(\"uri is: %s\", uri));\n                log.error(String.format(\"packagePath is: %s\", packagePath));\n                log.error(String.format(\"resourcePath is: %s\", resourcePath));\n                log.error(String.format(\"resourceContent is:\\n%s\", resourceContent));\n                return null;\n            }\n        }).collect(Collectors.toList());\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "EDDI",
    "cve_id": "CVE-2025-32779",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "1e207d0e4f72a5a93920bc0f76cad53ffd8e7065",
    "short_hash": "1e207d0e",
    "vulnerableMethods_before": [
      {
        "filename": "ZipArchive.java",
        "method_name": "writeZipFile",
        "raw_code": "private static void writeZipFile(String targetZipFile, File directoryToZip, List<File> fileList) throws IOException {\n        FileOutputStream fos = new FileOutputStream(targetZipFile);\n        ZipOutputStream zos = new ZipOutputStream(new BufferedOutputStream(fos));\n\n        for (File file : fileList) {\n            if (!file.isDirectory()) { // we only zip files, not directories\n                addToZip(directoryToZip, file, zos);\n            }\n        }\n\n        zos.close();\n        fos.close();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ZipArchive.java",
        "method_name": "writeZipFile",
        "raw_code": "private static void writeZipFile(String targetZipFile, File directoryToZip, List<File> fileList) throws IOException {\n        try (FileOutputStream fos = new FileOutputStream(targetZipFile);\n             ZipOutputStream zos = new ZipOutputStream(new BufferedOutputStream(fos))) {\n\n            for (File file : fileList) {\n                if (!file.isDirectory()) {\n                    addToZip(directoryToZip, file, zos);\n                }\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "EDDI",
    "cve_id": "CVE-2025-32779",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "1e207d0e4f72a5a93920bc0f76cad53ffd8e7065",
    "short_hash": "1e207d0e",
    "vulnerableMethods_before": [
      {
        "filename": "ZipArchive.java",
        "method_name": "addToZip",
        "raw_code": "private static void addToZip(File directoryToZip, File file, ZipOutputStream zos) throws IOException {\n        FileInputStream fis = new FileInputStream(file);\n\n        String zipFilePath = file.getCanonicalPath().\n                substring(directoryToZip.getCanonicalPath().length() + 1).replace('\\\\', '/');\n        ZipEntry zipEntry = new ZipEntry(zipFilePath);\n        zos.putNextEntry(zipEntry);\n\n        byte[] bytes = new byte[1024];\n        int length;\n        while ((length = fis.read(bytes)) >= 0) {\n            zos.write(bytes, 0, length);\n        }\n\n        zos.closeEntry();\n        fis.close();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ZipArchive.java",
        "method_name": "addToZip",
        "raw_code": "private static void addToZip(File directoryToZip, File file, ZipOutputStream zos) throws IOException {\n        // Use try-with-resources for automatic stream closing\n        try (FileInputStream fis = new FileInputStream(file)) {\n            // Ensure consistent path separators and protect against traversal in entry name creation itself\n            var zipEntry = getZipEntry(directoryToZip, file);\n            zos.putNextEntry(zipEntry);\n\n            byte[] bytes = new byte[BUFFER_SIZE];\n            int length;\n            while ((length = fis.read(bytes)) >= 0) {\n                zos.write(bytes, 0, length);\n            }\n            zos.closeEntry();\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "EDDI",
    "cve_id": "CVE-2025-32779",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "1e207d0e4f72a5a93920bc0f76cad53ffd8e7065",
    "short_hash": "1e207d0e",
    "vulnerableMethods_before": [
      {
        "filename": "ZipArchive.java",
        "method_name": "unzip",
        "raw_code": "@Override\n    public void unzip(InputStream zipFile, File targetDir) throws IOException {\n        if (!targetDir.exists()) {\n            targetDir.mkdir();\n        }\n        ZipInputStream zipIn = new ZipInputStream(zipFile);\n\n        ZipEntry entry = zipIn.getNextEntry();\n        // iterates over entries in the zip file\n        while (entry != null) {\n            String filePath = targetDir.getPath() + File.separator + entry.getName();\n            if (!entry.isDirectory()) {\n                // if the entry is a file, extracts it\n                new File(filePath).getParentFile().mkdirs();\n                extractFile(zipIn, filePath);\n            } else {\n                // if the entry is a directory, make the directory\n                File dir = new File(filePath);\n                dir.mkdirs();\n            }\n            zipIn.closeEntry();\n            entry = zipIn.getNextEntry();\n        }\n        zipIn.close();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ZipArchive.java",
        "method_name": "unzip",
        "raw_code": "@Override\n    public void unzip(InputStream zipFile, File targetDir) throws IOException {\n        if (!targetDir.exists()) {\n            if (!targetDir.mkdirs()) {\n                throw new IOException(\"Could not create target directory: \" + targetDir);\n            }\n        }\n\n        String targetDirPath = targetDir.getCanonicalPath();\n        try (ZipInputStream zipIn = new ZipInputStream(new BufferedInputStream(zipFile))) {\n            ZipEntry entry;\n            while ((entry = zipIn.getNextEntry()) != null) {\n                File destFile = new File(targetDir, entry.getName());\n                String destFilePath = destFile.getCanonicalPath();\n\n                // Ensure the resolved destination path starts with the target directory path\n                if (!destFilePath.startsWith(targetDirPath + File.separator)) {\n                    throw new IOException(\"Entry is outside of the target dir: \" + entry.getName());\n                }\n\n                if (entry.isDirectory()) {\n                    if (!destFile.mkdirs() && !destFile.isDirectory()) {\n                        throw new IOException(\"Could not create directory: \" + destFilePath);\n                    }\n                } else {\n                    File parentDir = destFile.getParentFile();\n                    if (!parentDir.mkdirs() && !parentDir.isDirectory()) {\n                        throw new IOException(\"Could not create parent directories for: \" + destFilePath);\n                    }\n                    extractFile(zipIn, destFile);\n                }\n                zipIn.closeEntry();\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "EDDI",
    "cve_id": "CVE-2025-32779",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "1e207d0e4f72a5a93920bc0f76cad53ffd8e7065",
    "short_hash": "1e207d0e",
    "vulnerableMethods_before": [
      {
        "filename": "ZipArchive.java",
        "method_name": "extractFile",
        "raw_code": "private void extractFile(ZipInputStream zipIn, String filePath) throws IOException {\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(filePath));\n        byte[] bytesIn = new byte[BUFFER_SIZE];\n        int read;\n        while ((read = zipIn.read(bytesIn)) != -1) {\n            bos.write(bytesIn, 0, read);\n        }\n        bos.close();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ZipArchive.java",
        "method_name": "extractFile",
        "raw_code": "private void extractFile(ZipInputStream zipIn, File destFile) throws IOException {\n        try (BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(destFile))) {\n            byte[] bytesIn = new byte[BUFFER_SIZE];\n            int read;\n            while ((read = zipIn.read(bytesIn)) != -1) {\n                bos.write(bytesIn, 0, read);\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-32429",
    "cwe_list": [
      "CWE-89"
    ],
    "commit_hash": "dfd0744e9c18d24ac66a0d261dc6cafd1c209101",
    "short_hash": "dfd0744e",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultHQLStatementValidator.java",
        "method_name": "checkOrderBySafe",
        "raw_code": "@Override\n    public void checkOrderBySafe(List<String> allowedPrefixes, String orderByValue) throws QueryException\n    {\n        if (StringUtils.isBlank(orderByValue)) {\n            return;\n        }\n\n        StringTokenizer tokenizer = new StringTokenizer(orderByValue, \",\");\n        while (tokenizer.hasMoreTokens()) {\n            String orderByColumn = tokenizer.nextToken().trim();\n\n            boolean valid = false;\n            if (SAFE_ORDERBY_ELEMENT.matcher(orderByColumn).matches()) {\n                valid = isValidOrderBy(allowedPrefixes, orderByColumn);\n            }\n\n            if (!valid) {\n                throw new QueryException(\"Usafe ORDER BY value [\" + orderByValue + \"].\", null);\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultHQLStatementValidator.java",
        "method_name": "checkOrderBySafe",
        "raw_code": "@Override\n    public void checkOrderBySafe(List<String> allowedPrefixes, String orderByValue) throws QueryException\n    {\n        if (StringUtils.isBlank(orderByValue)) {\n            return;\n        }\n\n        StringTokenizer tokenizer = new StringTokenizer(orderByValue, \",\");\n        while (tokenizer.hasMoreTokens()) {\n            String orderByColumn = tokenizer.nextToken().trim();\n\n            boolean valid = false;\n            if (SAFE_ORDERBY_ELEMENT.matcher(orderByColumn).matches()) {\n                valid = isValidOrderBy(allowedPrefixes, orderByColumn);\n            }\n\n            if (!valid) {\n                throw new QueryException(\"Unsafe ORDER BY value [\" + orderByValue + \"].\", null);\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-32429",
    "cwe_list": [
      "CWE-89"
    ],
    "commit_hash": "f502b5d5fd36284a50890ad26d168b7d8dc80bd3",
    "short_hash": "f502b5d5",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultHQLStatementValidator.java",
        "method_name": "checkOrderBySafe",
        "raw_code": "@Override\n    public void checkOrderBySafe(List<String> allowedPrefixes, String orderByValue) throws QueryException\n    {\n        if (StringUtils.isBlank(orderByValue)) {\n            return;\n        }\n\n        StringTokenizer tokenizer = new StringTokenizer(orderByValue, \",\");\n        while (tokenizer.hasMoreTokens()) {\n            String orderByColumn = tokenizer.nextToken().trim();\n\n            boolean valid = false;\n            if (SAFE_ORDERBY_ELEMENT.matcher(orderByColumn).matches()) {\n                valid = isValidOrderBy(allowedPrefixes, orderByColumn);\n            }\n\n            if (!valid) {\n                throw new QueryException(\"Usafe ORDER BY value [\" + orderByValue + \"].\", null);\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultHQLStatementValidator.java",
        "method_name": "checkOrderBySafe",
        "raw_code": "@Override\n    public void checkOrderBySafe(List<String> allowedPrefixes, String orderByValue) throws QueryException\n    {\n        if (StringUtils.isBlank(orderByValue)) {\n            return;\n        }\n\n        StringTokenizer tokenizer = new StringTokenizer(orderByValue, \",\");\n        while (tokenizer.hasMoreTokens()) {\n            String orderByColumn = tokenizer.nextToken().trim();\n\n            boolean valid = false;\n            if (SAFE_ORDERBY_ELEMENT.matcher(orderByColumn).matches()) {\n                valid = isValidOrderBy(allowedPrefixes, orderByColumn);\n            }\n\n            if (!valid) {\n                throw new QueryException(\"Unsafe ORDER BY value [\" + orderByValue + \"].\", null);\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "dataease",
    "cve_id": "CVE-2025-48999",
    "cwe_list": [
      "CWE-923"
    ],
    "commit_hash": "03b18db8a0fb7e9dc2c44f6d26d8c6221b7748c4",
    "short_hash": "03b18db8",
    "vulnerableMethods_before": [
      {
        "filename": "Redshift.java",
        "method_name": "getJdbc",
        "raw_code": "public String getJdbc() {\n        if(StringUtils.isNoneEmpty(getUrlType()) && !getUrlType().equalsIgnoreCase(\"hostName\")){\n            return getJdbcUrl();\n        }\n        return \"jdbc:redshift://HOSTNAME:PORT/DATABASE\"\n                .replace(\"HOSTNAME\", getLHost().trim())\n                .replace(\"PORT\", getLPort().toString().trim())\n                .replace(\"DATABASE\", getDataBase().trim());\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "Redshift.java",
        "method_name": "getJdbc",
        "raw_code": "public String getJdbc() {\n        if(StringUtils.isNoneEmpty(getUrlType()) && !getUrlType().equalsIgnoreCase(\"hostName\")){\n            for (String illegalParameter : illegalParameters) {\n                if (URLDecoder.decode(getJdbcUrl()).contains(illegalParameter)) {\n                    DEException.throwException(\"Illegal parameter: \" + illegalParameter);\n                }\n            }\n            return getJdbcUrl();\n        }\n        return \"jdbc:redshift://HOSTNAME:PORT/DATABASE\"\n                .replace(\"HOSTNAME\", getLHost().trim())\n                .replace(\"PORT\", getLPort().toString().trim())\n                .replace(\"DATABASE\", getDataBase().trim());\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-58049",
    "cwe_list": [
      "CWE-257"
    ],
    "commit_hash": "60982ad0057b1701ed8297f28cad35d170686539",
    "short_hash": "60982ad0",
    "vulnerableMethods_before": [
      {
        "filename": "PDFExportJob.java",
        "method_name": "runInternal",
        "raw_code": "@Override\n    protected void runInternal() throws Exception\n    {\n        if (!this.request.getDocuments().isEmpty()) {\n            this.requiredSkinExtensionsRecorder.start();\n            render(this.request.getDocuments());\n            if (!this.status.isCanceled()) {\n                this.status.setRequiredSkinExtensions(this.requiredSkinExtensionsRecorder.stop());\n            }\n\n            if (this.request.isServerSide() && !this.status.isCanceled()) {\n                saveAsPDF();\n                this.status.getDocumentRenderingResults().clear();\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "PDFExportJob.java",
        "method_name": "runInternal",
        "raw_code": "@Override\n    protected void runInternal() throws Exception\n    {\n        try {\n            exportAsPDF();\n        } finally {\n            cleanup();\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-58049",
    "cwe_list": [
      "CWE-257"
    ],
    "commit_hash": "60982ad0057b1701ed8297f28cad35d170686539",
    "short_hash": "60982ad0",
    "vulnerableMethods_before": [
      {
        "filename": "PDFExportJobTest.java",
        "method_name": "runServerSide",
        "raw_code": "@Test\n    void runServerSide() throws Exception\n    {\n        when(this.requiredSkinExtensionsRecorder.stop()).thenReturn(\"required skin extensions\");\n\n        URL printPreviewURL = new URL(\"http://www.xwiki.org\");\n        when(this.printPreviewURLBuilder.getPrintPreviewURL(this.request)).thenReturn(printPreviewURL);\n\n        InputStream pdfContent = mock(InputStream.class);\n        when(this.pdfPrinter.print(printPreviewURL)).thenReturn(pdfContent);\n\n        this.request.setServerSide(true);\n        this.pdfExportJob.initialize(this.request);\n        this.pdfExportJob.runInternal();\n\n        verify(this.requiredSkinExtensionsRecorder).start();\n\n        PDFExportJobStatus jobStatus = this.pdfExportJob.getStatus();\n        assertEquals(\"required skin extensions\", jobStatus.getRequiredSkinExtensions());\n        assertEquals(0, jobStatus.getDocumentRenderingResults().size());\n\n        TemporaryResourceReference pdfFileReference = jobStatus.getPDFFileReference();\n        verify(this.temporaryResourceStore).createTemporaryFile(pdfFileReference, pdfContent);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "PDFExportJobTest.java",
        "method_name": "runServerSide",
        "raw_code": "@Test\n    void runServerSide() throws Exception\n    {\n        when(this.requiredSkinExtensionsRecorder.stop()).thenReturn(\"required skin extensions\");\n\n        URL printPreviewURL = new URL(\"http://www.xwiki.org\");\n        when(this.printPreviewURLBuilder.getPrintPreviewURL(this.request)).thenReturn(printPreviewURL);\n\n        InputStream pdfContent = mock(InputStream.class);\n        when(this.pdfPrinter.print(printPreviewURL)).thenReturn(pdfContent);\n\n        this.request.setServerSide(true);\n        this.request.getContext().put(\"request.session\", \"session\");\n        this.pdfExportJob.initialize(this.request);\n        this.pdfExportJob.runInternal();\n\n        verify(this.requiredSkinExtensionsRecorder).start();\n\n        PDFExportJobStatus jobStatus = this.pdfExportJob.getStatus();\n        assertEquals(\"required skin extensions\", jobStatus.getRequiredSkinExtensions());\n        assertEquals(0, jobStatus.getDocumentRenderingResults().size());\n\n        TemporaryResourceReference pdfFileReference = jobStatus.getPDFFileReference();\n        verify(this.temporaryResourceStore).createTemporaryFile(pdfFileReference, pdfContent);\n\n        assertFalse(this.request.getContext().containsKey(\"request.session\"));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-58049",
    "cwe_list": [
      "CWE-257"
    ],
    "commit_hash": "60982ad0057b1701ed8297f28cad35d170686539",
    "short_hash": "60982ad0",
    "vulnerableMethods_before": [
      {
        "filename": "PDFExportJobTest.java",
        "method_name": "runClientSide",
        "raw_code": "@Test\n    void runClientSide() throws Exception\n    {\n        this.pdfExportJob.initialize(this.request);\n        this.pdfExportJob.runInternal();\n\n        PDFExportJobStatus jobStatus = this.pdfExportJob.getStatus();\n        assertNull(jobStatus.getPDFFileReference());\n\n        verify(this.temporaryResourceStore, never()).createTemporaryFile(any(TemporaryResourceReference.class),\n            any(InputStream.class));\n\n        List<DocumentRenderingResult> renderingResults = jobStatus.getDocumentRenderingResults();\n        assertEquals(2, renderingResults.size());\n        assertSame(this.firstPageRendering, renderingResults.get(0));\n        assertSame(this.secondPageRendering, renderingResults.get(1));\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "PDFExportJobTest.java",
        "method_name": "runClientSide",
        "raw_code": "@Test\n    void runClientSide() throws Exception\n    {\n        this.request.getContext().put(\"request.headers\", \"headers\");\n        this.pdfExportJob.initialize(this.request);\n        this.pdfExportJob.runInternal();\n\n        PDFExportJobStatus jobStatus = this.pdfExportJob.getStatus();\n        assertNull(jobStatus.getPDFFileReference());\n\n        verify(this.temporaryResourceStore, never()).createTemporaryFile(any(TemporaryResourceReference.class),\n            any(InputStream.class));\n\n        List<DocumentRenderingResult> renderingResults = jobStatus.getDocumentRenderingResults();\n        assertEquals(2, renderingResults.size());\n        assertSame(this.firstPageRendering, renderingResults.get(0));\n        assertSame(this.secondPageRendering, renderingResults.get(1));\n\n        assertFalse(this.request.getContext().containsKey(\"request.headers\"));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-58049",
    "cwe_list": [
      "CWE-257"
    ],
    "commit_hash": "60982ad0057b1701ed8297f28cad35d170686539",
    "short_hash": "60982ad0",
    "vulnerableMethods_before": [
      {
        "filename": "PDFExportJobTest.java",
        "method_name": "runWithoutDocuments",
        "raw_code": "@Test\n    void runWithoutDocuments() throws Exception\n    {\n        this.request.setDocuments(Collections.emptyList());\n        this.pdfExportJob.initialize(this.request);\n        this.pdfExportJob.runInternal();\n\n        PDFExportJobStatus jobStatus = this.pdfExportJob.getStatus();\n        assertNull(jobStatus.getPDFFileReference());\n        assertNull(jobStatus.getRequiredSkinExtensions());\n        assertEquals(0, jobStatus.getDocumentRenderingResults().size());\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "PDFExportJobTest.java",
        "method_name": "runWithoutDocuments",
        "raw_code": "@Test\n    void runWithoutDocuments() throws Exception\n    {\n        this.request.getContext().put(\"request.cookies\", \"cookies\");\n        this.request.setDocuments(Collections.emptyList());\n        this.pdfExportJob.initialize(this.request);\n        this.pdfExportJob.runInternal();\n\n        PDFExportJobStatus jobStatus = this.pdfExportJob.getStatus();\n        assertNull(jobStatus.getPDFFileReference());\n        assertNull(jobStatus.getRequiredSkinExtensions());\n        assertEquals(0, jobStatus.getDocumentRenderingResults().size());\n\n        assertFalse(this.request.getContext().containsKey(\"request.cookies\"));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-58049",
    "cwe_list": [
      "CWE-257"
    ],
    "commit_hash": "60982ad0057b1701ed8297f28cad35d170686539",
    "short_hash": "60982ad0",
    "vulnerableMethods_before": [
      {
        "filename": "PDFExportJobTest.java",
        "method_name": "runWithContentSizeLimitExceeded",
        "raw_code": "@Test\n    void runWithContentSizeLimitExceeded() throws Exception\n    {\n        DocumentRenderingResult largeResult = new DocumentRenderingResult(this.secondPageReference,\n            new XDOM(Collections.singletonList(new WordBlock(\"second\"))), StringUtils.repeat('x', 1000));\n        when(this.documentRenderer.render(this.secondPageReference, this.rendererParameters)).thenReturn(largeResult);\n\n        this.pdfExportJob.initialize(this.request);\n        try {\n            this.pdfExportJob.runInternal();\n            fail();\n        } catch (Exception e) {\n            assertEquals(\n                \"The content size exceeds the configured 1KB limit. Wiki administrators can increase\"\n                    + \" or disable this limit from the PDF Export administration section or from XWiki properties.\",\n                e.getMessage());\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "PDFExportJobTest.java",
        "method_name": "runWithContentSizeLimitExceeded",
        "raw_code": "@Test\n    void runWithContentSizeLimitExceeded() throws Exception\n    {\n        DocumentRenderingResult largeResult = new DocumentRenderingResult(this.secondPageReference,\n            new XDOM(Collections.singletonList(new WordBlock(\"second\"))), StringUtils.repeat('x', 1000));\n        when(this.documentRenderer.render(this.secondPageReference, this.rendererParameters)).thenReturn(largeResult);\n\n        this.request.getContext().put(\"request.cookies\", \"cookies\");\n        this.request.getContext().put(\"request.foo\", \"bar\");\n        this.pdfExportJob.initialize(this.request);\n        try {\n            this.pdfExportJob.runInternal();\n            fail();\n        } catch (Exception e) {\n            assertEquals(\n                \"The content size exceeds the configured 1KB limit. Wiki administrators can increase\"\n                    + \" or disable this limit from the PDF Export administration section or from XWiki properties.\",\n                e.getMessage());\n        }\n\n        assertFalse(this.request.getContext().containsKey(\"request.cookies\"));\n        assertEquals(\"bar\", this.request.getContext().get(\"request.foo\"));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "application-blog",
    "cve_id": "CVE-2025-58365",
    "cwe_list": [
      "CWE-95"
    ],
    "commit_hash": "b98ab6f17da3029576f42d12b4442cd555c7e0b4",
    "short_hash": "b98ab6f1",
    "vulnerableMethods_before": [
      {
        "filename": "BlogScriptService.java",
        "method_name": "renderRSSDescription",
        "raw_code": "public String renderRSSDescription(String contentToRender, Document blogDocument) throws XWikiException\n    {\n        XWikiContext context = this.xwikiContextProvider.get();\n        XWikiURLFactory currentURLFactory = context.getURLFactory();\n        try {\n            context.setURLFactory(new ExternalServletURLFactory(context));\n            return blogDocument.getRenderedContent(contentToRender, blogDocument.getSyntax().toIdString());\n        } finally {\n            context.setURLFactory(currentURLFactory);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "BlogScriptService.java",
        "method_name": "renderRSSDescription",
        "raw_code": "@Deprecated\n    public String renderRSSDescription(String contentToRender, Document blogDocument) throws XWikiException\n    {\n        XWikiContext context = this.xwikiContextProvider.get();\n        XWikiURLFactory currentURLFactory = context.getURLFactory();\n        try {\n            context.setURLFactory(new ExternalServletURLFactory(context));\n            return blogDocument.getRenderedContent(contentToRender, blogDocument.getSyntax().toIdString());\n        } finally {\n            context.setURLFactory(currentURLFactory);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-55747",
    "cwe_list": [
      "CWE-23"
    ],
    "commit_hash": "9e7b4c03f2143978d891109a17159f73d4cdd318#diff-45ea9c87d5fb68cd5db0da7f78cf25e76f1325f5fe56e21618b21786fc706236R80-R81",
    "short_hash": "9e7b4c03",
    "vulnerableMethods_before": [
      {
        "filename": "AbstractServletResourceReferenceHandler.java",
        "method_name": "handle",
        "raw_code": "@Override\n    public void handle(ResourceReference resourceReference, ResourceReferenceHandlerChain chain)\n        throws ResourceReferenceHandlerException\n    {\n        @SuppressWarnings(\"unchecked\")\n        R typedResourceReference = (R) resourceReference;\n\n        if (!isResourceAccessible(typedResourceReference)) {\n            sendError(HttpStatus.SC_FORBIDDEN, \"You are not allowed to view [%s].\",\n                getResourceName(typedResourceReference));\n        } else if (!shouldBrowserUseCachedContent(typedResourceReference)) {\n            // If we get here then either the resource is not cached by the browser or the resource is dynamic.\n            try (InputStream resourceStream = getResourceStream(typedResourceReference)) {\n                if (resourceStream != null) {\n                    try (InputStream filteredSteam = filterResource(typedResourceReference, resourceStream)) {\n                        serveResource(typedResourceReference, filteredSteam);\n                    }\n                } else {\n                    sendError(HttpStatus.SC_NOT_FOUND, \"Resource not found [%s].\",\n                        getResourceName(typedResourceReference));\n                }\n            } catch (IOException | ResourceReferenceHandlerException e) {\n                this.logger.error(e.getMessage(), e);\n                sendError(HttpStatus.SC_INTERNAL_SERVER_ERROR, e.getMessage());\n            }\n        }\n\n        // Be a good citizen, continue the chain, in case some lower-priority handler has something to do for this\n        // resource reference.\n        chain.handleNext(resourceReference);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AbstractServletResourceReferenceHandler.java",
        "method_name": "handle",
        "raw_code": "@Override\n    public void handle(ResourceReference resourceReference, ResourceReferenceHandlerChain chain)\n        throws ResourceReferenceHandlerException\n    {\n        @SuppressWarnings(\"unchecked\")\n        R typedResourceReference = (R) resourceReference;\n\n        if (!isResourceAccessible(typedResourceReference)) {\n            sendError(HttpStatus.SC_FORBIDDEN, \"You are not allowed to view [%s].\",\n                getResourceName(typedResourceReference));\n        } else if (!shouldBrowserUseCachedContent(typedResourceReference)) {\n            // If we get here then either the resource is not cached by the browser or the resource is dynamic.\n            try (InputStream resourceStream = getResourceStream(typedResourceReference)) {\n                if (resourceStream != null) {\n                    try (InputStream filteredSteam = filterResource(typedResourceReference, resourceStream)) {\n                        serveResource(typedResourceReference, filteredSteam);\n                    }\n                } else {\n                    sendError(HttpStatus.SC_NOT_FOUND, \"Resource not found [%s].\",\n                        getResourceName(typedResourceReference));\n                }\n            } catch (Exception e) {\n                this.logger.error(e.getMessage(), e);\n                sendError(HttpStatus.SC_INTERNAL_SERVER_ERROR, e.getMessage());\n            }\n        }\n\n        // Be a good citizen, continue the chain, in case some lower-priority handler has something to do for this\n        // resource reference.\n        chain.handleNext(resourceReference);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-55747",
    "cwe_list": [
      "CWE-23"
    ],
    "commit_hash": "9e7b4c03f2143978d891109a17159f73d4cdd318#diff-45ea9c87d5fb68cd5db0da7f78cf25e76f1325f5fe56e21618b21786fc706236R80-R81",
    "short_hash": "9e7b4c03",
    "vulnerableMethods_before": [],
    "vulnerableMethods_after": [
      {
        "filename": "InternalTemplateManager.java",
        "method_name": "getClassloaderTemplate",
        "raw_code": "private Template getClassloaderTemplate(ClassLoader classloader, String prefixPath, String templateName)\n    {\n        URL url;\n        try {\n            url = ClassLoaderUtils.getResource(classloader, prefixPath, templateName);\n        } catch (IllegalArgumentException e) {\n            this.logger.warn(\"The template name [{}] is trying to execute a path traversal attack!\", templateName);\n\n            return null;\n        }\n\n        return url != null ? new ClassloaderTemplate(new ClassloaderResource(url, templateName)) : null;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-55747",
    "cwe_list": [
      "CWE-23"
    ],
    "commit_hash": "9e7b4c03f2143978d891109a17159f73d4cdd318#diff-45ea9c87d5fb68cd5db0da7f78cf25e76f1325f5fe56e21618b21786fc706236R80-R81",
    "short_hash": "9e7b4c03",
    "vulnerableMethods_before": [
      {
        "filename": "WebJarsResourceReferenceHandler.java",
        "method_name": "getResourceStream",
        "raw_code": "@Override\n    protected InputStream getResourceStream(WebJarsResourceReference resourceReference)\n    {\n        String resourcePath = String.format(\"%s%s\", WEBJARS_RESOURCE_PREFIX, getResourceName(resourceReference));\n        return getClassLoader(resourceReference.getNamespace()).getResourceAsStream(resourcePath);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "WebJarsResourceReferenceHandler.java",
        "method_name": "getResourceStream",
        "raw_code": "@Override\n    protected InputStream getResourceStream(WebJarsResourceReference resourceReference)\n    {\n        return ClassLoaderUtils.getResourceAsStream(getClassLoader(resourceReference.getNamespace()),\n            WEBJARS_RESOURCE_PREFIX, getResourceName(resourceReference));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-55747",
    "cwe_list": [
      "CWE-23"
    ],
    "commit_hash": "9e7b4c03f2143978d891109a17159f73d4cdd318#diff-45ea9c87d5fb68cd5db0da7f78cf25e76f1325f5fe56e21618b21786fc706236R80-R81",
    "short_hash": "9e7b4c03",
    "vulnerableMethods_before": [
      {
        "filename": "SxResourceSource.java",
        "method_name": "getContent",
        "raw_code": "@Override\n    public String getContent()\n    {\n        try {\n            // Load from the current context class loader to allow extensions to contribute skin extensions.\n            ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();\n            try (InputStream in = contextClassLoader.getResourceAsStream(this.resourceName)) {\n                return IOUtils.toString(in, StandardCharsets.UTF_8);\n            }\n        } catch (NullPointerException e) {\n            // This happens when the file was not found. Forward an IAE so that the sx action returns 404\n            throw new IllegalArgumentException(e);\n        } catch (IOException e) {\n            return \"\";\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SxResourceSource.java",
        "method_name": "getContent",
        "raw_code": "@Override\n    public String getContent()\n    {\n        try {\n            // Load from the current context class loader to allow extensions to contribute skin extensions.\n            ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();\n            try (InputStream in = ClassLoaderUtils.getResourceAsStream(contextClassLoader, this.resourceName)) {\n                return IOUtils.toString(in, StandardCharsets.UTF_8);\n            }\n        } catch (NullPointerException e) {\n            // This happens when the file was not found. Forward an IAE so that the sx action returns 404\n            throw new IllegalArgumentException(e);\n        } catch (IOException e) {\n            return \"\";\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "Java-springboot-codebase",
    "cve_id": "CVE-2025-46822",
    "cwe_list": [
      "CWE-36"
    ],
    "commit_hash": "c835c6f7799eacada4c0fc77e0816f250af01ad2",
    "short_hash": "c835c6f7",
    "vulnerableMethods_before": [],
    "vulnerableMethods_after": [
      {
        "filename": "FileSystemStorageService.java",
        "method_name": "store",
        "raw_code": "@Override\n    public int store(MultipartFile file, String nameAndExt) {\n        Path location = Paths.get(rootLocation+\"/\");\n\n        try {\n            Files.createDirectories(location);\n            if (file.isEmpty()) {\n                return OP_STATUS_FILE_EMPTY;\n            }\n            if (nameAndExt.contains(\"..\") || !fileNamePattern.matcher(nameAndExt).matches()) {\n                // This is a security check\n               return OP_STATUS_INVALID_FILE_NAME;\n            }\n\n            if(!isAllowedFileType(file)) return OP_STATUS_FILE_TYPE_NOT_ALLOWED;\n\n            try (InputStream inputStream = file.getInputStream()) {\n\n                Files.copy(inputStream, location.resolve(nameAndExt),\n                        StandardCopyOption.REPLACE_EXISTING);\n\n                if(isImage(FilenameUtils.getExtension(file.getOriginalFilename()))){\n                    createThumbnail(file,thumbWidth,nameAndExt);\n                }\n            }\n            return OP_STATUS_SUCCESS;\n        }\n        catch (IOException e) {\n            log.error(\"[EXCEPTION] store : {},{}\",e.getMessage(),e.getCause());\n            return OP_STATUS_FAILED;\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "Java-springboot-codebase",
    "cve_id": "CVE-2025-46822",
    "cwe_list": [
      "CWE-36"
    ],
    "commit_hash": "c835c6f7799eacada4c0fc77e0816f250af01ad2",
    "short_hash": "c835c6f7",
    "vulnerableMethods_before": [
      {
        "filename": "FileSystemStorageService.java",
        "method_name": "loadAsResource",
        "raw_code": "@Override\n    public Resource loadAsResource(String filename) {\n        try {\n            Path location = Paths.get(rootLocation+\"/\");\n            Path file = load(filename,location);\n            Resource resource = new UrlResource(file.toUri());\n            if (resource.exists() || resource.isReadable()) {\n                return resource;\n            }\n            else {\n              return null;\n            }\n        } catch (MalformedURLException e) {\n           log.error(\"[EXCEPTION] loadAsResource: {},{}\",e.getMessage(),e.getCause());\n           return null;\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FileSystemStorageService.java",
        "method_name": "loadAsResource",
        "raw_code": "@Override\n    public Resource loadAsResource(String filename) {\n        try {\n            if(!fileNamePattern.matcher(filename).matches()){\n                log.error(\"[ERROR] loadAsResource: invalid file name\");\n                return null;\n            }\n            Path location = Paths.get(rootLocation+\"/\");\n            Path file = load(filename,location);\n            Resource resource = new UrlResource(file.toUri());\n            if (resource.exists() || resource.isReadable()) {\n                return resource;\n            }\n            else {\n              return null;\n            }\n        } catch (MalformedURLException e) {\n           log.error(\"[EXCEPTION] loadAsResource: {},{}\",e.getMessage(),e.getCause());\n           return null;\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "fess",
    "cve_id": "CVE-2025-48382",
    "cwe_list": [
      "CWE-732"
    ],
    "commit_hash": "25b2009fea2a0f6ccd5aa8154aa54b536c08f6c4",
    "short_hash": "25b2009f",
    "vulnerableMethods_before": [
      {
        "filename": "SystemHelper.java",
        "method_name": "createTempFile",
        "raw_code": "public File createTempFile(final String prefix, final String suffix) {\n        try {\n            final File file = File.createTempFile(prefix, suffix);\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Create {} as a temp file.\", file.getAbsolutePath());\n            }\n            return file;\n        } catch (final IOException e) {\n            throw new IORuntimeException(e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SystemHelper.java",
        "method_name": "createTempFile",
        "raw_code": "public File createTempFile(final String prefix, final String suffix) {\n        try {\n            final File file = File.createTempFile(prefix, suffix);\n            file.setReadable(false, false);\n            file.setReadable(true, true);\n            file.setWritable(false, false);\n            file.setWritable(true, true);\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Create {} as a temp file.\", file.getAbsolutePath());\n            }\n            return file;\n        } catch (final IOException e) {\n            throw new IORuntimeException(e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "para",
    "cve_id": "CVE-2025-48955",
    "cwe_list": [
      "CWE-532"
    ],
    "commit_hash": "1e8a89558542854bb0683ab234c4429ad93b0835",
    "short_hash": "1e8a8955",
    "vulnerableMethods_before": [
      {
        "filename": "HealthUtils.java",
        "method_name": "saveConfigFile",
        "raw_code": "private void saveConfigFile(String confFile, Map<String, String> rootAppCredentials) {\n\t\t\tif (rootAppCredentials.containsKey(\"secretKey\")) {\n\t\t\t\tString confString = \"\";\n\t\t\t\ttry {\n\t\t\t\t\tconfString = loadConfigFile(confFile);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tlogger.info(\"Initialized root app with access key '{}' and secret '{}', \"\n\t\t\t\t\t\t\t+ \"but could not write these to {}.\",\n\t\t\t\t\t\t\trootAppCredentials.get(\"accessKey\"), rootAppCredentials.get(\"secretKey\"), confFile);\n\t\t\t\t}\n\t\t\t\tString accessKey = \"para.root_access_key = \\\"\" + rootAppCredentials.get(\"accessKey\") + \"\\\"\";\n\t\t\t\tString secretKey = \"para.root_secret_key = \\\"\" + rootAppCredentials.get(\"secretKey\") + \"\\\"\";\n\t\t\t\tif (confString.contains(\"para.root_access_key\")) {\n\t\t\t\t\tconfString = confString.replaceAll(\"para\\\\.root_access_key\\\\s*=\\\\s*\\\".*?\\\"\", accessKey);\n\t\t\t\t} else {\n\t\t\t\t\tconfString += \"\\n\" + accessKey;\n\t\t\t\t}\n\t\t\t\tif (confString.contains(\"para.root_secret_key\")) {\n\t\t\t\t\tconfString = confString.replaceAll(\"para\\\\.root_secret_key\\\\s*=\\\\s*\\\".*?\\\"\", secretKey);\n\t\t\t\t} else {\n\t\t\t\t\tconfString += \"\\n\" + secretKey;\n\t\t\t\t}\n\t\t\t\tPara.getFileStore().store(confFile, new ByteArrayInputStream(confString.\n\t\t\t\t\t\tgetBytes(StandardCharsets.UTF_8)));\n\t\t\t\tlogger.info(\"Saved root app credentials to {}.\", confFile);\n\t\t\t} else {\n\t\t\t\tlogger.warn(\"Server is unhealthy - failed to initialize root app. Open http://localhost:\" +\n\t\t\t\t\t\tPara.getConfig().serverPort() + \"/v1/_setup in the browser to initialize Para manually.\");\n\t\t\t}\n\t\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "HealthUtils.java",
        "method_name": "saveConfigFile",
        "raw_code": "private void saveConfigFile(String confFile, Map<String, String> rootAppCredentials) {\n\t\t\tif (rootAppCredentials.containsKey(\"secretKey\")) {\n\t\t\t\tString confString = \"\";\n\t\t\t\ttry {\n\t\t\t\t\tconfString = loadConfigFile(confFile);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tlogger.info(\"Initialized root app with access key '{}', \"\n\t\t\t\t\t\t\t+ \"but could not write to {}.\", rootAppCredentials.get(\"accessKey\"), confFile);\n\t\t\t\t}\n\t\t\t\tString accessKey = \"para.root_access_key = \\\"\" + rootAppCredentials.get(\"accessKey\") + \"\\\"\";\n\t\t\t\tString secretKey = \"para.root_secret_key = \\\"\" + rootAppCredentials.get(\"secretKey\") + \"\\\"\";\n\t\t\t\tif (confString.contains(\"para.root_access_key\")) {\n\t\t\t\t\tconfString = confString.replaceAll(\"para\\\\.root_access_key\\\\s*=\\\\s*\\\".*?\\\"\", accessKey);\n\t\t\t\t} else {\n\t\t\t\t\tconfString += \"\\n\" + accessKey;\n\t\t\t\t}\n\t\t\t\tif (confString.contains(\"para.root_secret_key\")) {\n\t\t\t\t\tconfString = confString.replaceAll(\"para\\\\.root_secret_key\\\\s*=\\\\s*\\\".*?\\\"\", secretKey);\n\t\t\t\t} else {\n\t\t\t\t\tconfString += \"\\n\" + secretKey;\n\t\t\t\t}\n\t\t\t\tPara.getFileStore().store(confFile, new ByteArrayInputStream(confString.\n\t\t\t\t\t\tgetBytes(StandardCharsets.UTF_8)));\n\t\t\t\tlogger.info(\"Saved root app credentials to {}.\", confFile);\n\t\t\t} else {\n\t\t\t\tlogger.warn(\"Server is unhealthy - failed to initialize root app. Open http://localhost:\" +\n\t\t\t\t\t\tPara.getConfig().serverPort() + \"/v1/_setup in the browser to initialize Para manually.\");\n\t\t\t}\n\t\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "para",
    "cve_id": "CVE-2025-49009",
    "cwe_list": [
      "CWE-532"
    ],
    "commit_hash": "46a908d887da02037384193f70a69345f04887cf",
    "short_hash": "46a908d8",
    "vulnerableMethods_before": [
      {
        "filename": "FacebookAuthFilter.java",
        "method_name": "getOrCreateUser",
        "raw_code": "@SuppressWarnings(\"unchecked\")\n\tpublic UserAuthentication getOrCreateUser(App app, String accessToken) throws IOException {\n\t\tif (accessToken == null) {\n\t\t\treturn SecurityUtils.checkIfActive(null, null, false);\n\t\t}\n\t\tHttpGet profileGet = new HttpGet(PROFILE_URL + accessToken);\n\t\treturn httpclient.execute(profileGet, (resp2) -> {\n\t\t\tUserAuthentication userAuth = null;\n\t\t\tUser user = new User();\n\t\t\ttry {\n\t\t\t\tHttpEntity respEntity = resp2.getEntity();\n\t\t\t\tif (respEntity != null) {\n\t\t\t\t\tMap<String, Object> profile = jreader.readValue(respEntity.getContent());\n\n\t\t\t\t\tif (profile != null && profile.containsKey(\"id\")) {\n\t\t\t\t\t\tString fbId = (String) profile.get(\"id\");\n\t\t\t\t\t\tString email = (String) profile.get(\"email\");\n\t\t\t\t\t\tString name = (String) profile.get(\"name\");\n\n\t\t\t\t\t\tuser.setAppid(getAppid(app));\n\t\t\t\t\t\tuser.setIdentifier(Config.FB_PREFIX.concat(fbId));\n\t\t\t\t\t\tuser.setEmail(email);\n\t\t\t\t\t\tuser = User.readUserForIdentifier(user);\n\t\t\t\t\t\tif (user == null) {\n\t\t\t\t\t\t\t//user is new\n\t\t\t\t\t\t\tuser = new User();\n\t\t\t\t\t\t\tuser.setActive(true);\n\t\t\t\t\t\t\tuser.setAppid(getAppid(app));\n\t\t\t\t\t\t\tuser.setEmail(StringUtils.isBlank(email) ? Utils.getNewId() + \"@facebook.com\" : email);\n\t\t\t\t\t\t\tuser.setName(StringUtils.isBlank(name) ? \"No Name\" : name);\n\t\t\t\t\t\t\tuser.setPassword(Utils.generateSecurityToken());\n\t\t\t\t\t\t\tuser.setPicture(getPicture(fbId));\n\t\t\t\t\t\t\tuser.setIdentifier(Config.FB_PREFIX.concat(fbId));\n\t\t\t\t\t\t\tString id = user.create();\n\t\t\t\t\t\t\tif (id == null) {\n\t\t\t\t\t\t\t\tthrow new AuthenticationServiceException(\"Authentication failed: cannot create new user.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (updateUserInfo(user, fbId, email, name)) {\n\t\t\t\t\t\t\t\tuser.update();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tuserAuth = new UserAuthentication(new AuthenticatedUserDetails(user));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlogger.info(\"Authentication request failed because user profile doesn't contain the expected attributes\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlogger.info(\"Authentication request failed because response was missing or contained invalid JSON.\");\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tlogger.warn(\"Facebook auth request failed: GET \" + PROFILE_URL + accessToken, e);\n\t\t\t}\n\t\t\treturn SecurityUtils.checkIfActive(userAuth, user, false);\n\t\t});\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FacebookAuthFilter.java",
        "method_name": "getOrCreateUser",
        "raw_code": "@SuppressWarnings(\"unchecked\")\n\tpublic UserAuthentication getOrCreateUser(App app, String accessToken) throws IOException {\n\t\tif (accessToken == null) {\n\t\t\treturn SecurityUtils.checkIfActive(null, null, false);\n\t\t}\n\t\tHttpGet profileGet = new HttpGet(PROFILE_URL + accessToken);\n\t\treturn httpclient.execute(profileGet, (resp2) -> {\n\t\t\tUserAuthentication userAuth = null;\n\t\t\tUser user = new User();\n\t\t\ttry {\n\t\t\t\tHttpEntity respEntity = resp2.getEntity();\n\t\t\t\tif (respEntity != null) {\n\t\t\t\t\tMap<String, Object> profile = jreader.readValue(respEntity.getContent());\n\n\t\t\t\t\tif (profile != null && profile.containsKey(\"id\")) {\n\t\t\t\t\t\tString fbId = (String) profile.get(\"id\");\n\t\t\t\t\t\tString email = (String) profile.get(\"email\");\n\t\t\t\t\t\tString name = (String) profile.get(\"name\");\n\n\t\t\t\t\t\tuser.setAppid(getAppid(app));\n\t\t\t\t\t\tuser.setIdentifier(Config.FB_PREFIX.concat(fbId));\n\t\t\t\t\t\tuser.setEmail(email);\n\t\t\t\t\t\tuser = User.readUserForIdentifier(user);\n\t\t\t\t\t\tif (user == null) {\n\t\t\t\t\t\t\t//user is new\n\t\t\t\t\t\t\tuser = new User();\n\t\t\t\t\t\t\tuser.setActive(true);\n\t\t\t\t\t\t\tuser.setAppid(getAppid(app));\n\t\t\t\t\t\t\tuser.setEmail(StringUtils.isBlank(email) ? Utils.getNewId() + \"@facebook.com\" : email);\n\t\t\t\t\t\t\tuser.setName(StringUtils.isBlank(name) ? \"No Name\" : name);\n\t\t\t\t\t\t\tuser.setPassword(Utils.generateSecurityToken());\n\t\t\t\t\t\t\tuser.setPicture(getPicture(fbId));\n\t\t\t\t\t\t\tuser.setIdentifier(Config.FB_PREFIX.concat(fbId));\n\t\t\t\t\t\t\tString id = user.create();\n\t\t\t\t\t\t\tif (id == null) {\n\t\t\t\t\t\t\t\tthrow new AuthenticationServiceException(\"Authentication failed: cannot create new user.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (updateUserInfo(user, fbId, email, name)) {\n\t\t\t\t\t\t\t\tuser.update();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tuserAuth = new UserAuthentication(new AuthenticatedUserDetails(user));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlogger.info(\"Authentication request failed because user profile doesn't contain the expected attributes\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlogger.info(\"Authentication request failed because response was missing or contained invalid JSON.\");\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tlogger.warn(\"Facebook auth request failed: GET \" + PROFILE_URL + \"{access_token}\", e);\n\t\t\t}\n\t\t\treturn SecurityUtils.checkIfActive(userAuth, user, false);\n\t\t});\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "jans",
    "cve_id": "CVE-2025-53003",
    "cwe_list": [
      "CWE-284"
    ],
    "commit_hash": "92eea4d4637f1cae16ad2f07b2c16378ff3fc5f1",
    "short_hash": "92eea4d4",
    "vulnerableMethods_before": [
      {
        "filename": "AuthUtil.java",
        "method_name": "findMissingElements",
        "raw_code": "public List<String> findMissingElements(List<String> list1, List<String> list2) {\n        if (list1 == null || list1.isEmpty() || list2 == null || list2.isEmpty()) {\n            return Collections.emptyList();\n        }\n        return list1.stream().filter(e -> !list2.contains(e)).collect(Collectors.toList());\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AuthUtil.java",
        "method_name": "findMissingElements",
        "raw_code": "public List<String> findMissingElements(List<String> list1, List<String> list2) {\n        if (list1 == null || list1.isEmpty()) {\n            return Collections.emptyList();\n        }\n        if(list2==null || list2.isEmpty()) {\n            return list1;\n        }\n        return list1.stream().filter(e -> !list2.contains(e)).collect(Collectors.toList());\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "jans",
    "cve_id": "CVE-2025-53003",
    "cwe_list": [
      "CWE-284"
    ],
    "commit_hash": "92eea4d4637f1cae16ad2f07b2c16378ff3fc5f1",
    "short_hash": "92eea4d4",
    "vulnerableMethods_before": [
      {
        "filename": "OpenIdAuthorizationService.java",
        "method_name": "validateScope",
        "raw_code": "private String validateScope(String accessToken, List<String> tokenScopes, ResourceInfo resourceInfo, String issuer)\n            throws WebApplicationException {\n        logger.info(\"Validate scope, accessToken:{}, tokenScopes:{}, resourceInfo: {}, issuer: {}\", accessToken,\n                tokenScopes, resourceInfo, issuer);\n        try {\n            // Get resource scope\n            Map<ProtectionScopeType, List<String>> resourceScopesByType = getRequestedScopes(resourceInfo);\n            List<String> resourceScopes = getAllScopeList(resourceScopesByType);\n            logger.debug(\"Validate scope, resourceScopesByType: {}, resourceScopes: {}\", resourceScopesByType,\n                    resourceScopes);\n\n            // find missing scopes\n            List<String> missingScopes = findMissingScopes(resourceScopesByType, tokenScopes);\n            logger.info(\"missingScopes:{}\", missingScopes);\n\n            // Check if resource requires auth server specific scope\n            List<String> authSpecificScope = getAuthSpecificScopeRequired(resourceInfo);\n            logger.info(\" resourceScopes:{}, authSpecificScope:{} \", resourceScopes, authSpecificScope);\n\n            // If No auth scope required OR if token contains the authSpecificScope\n            if ((authSpecificScope == null || authSpecificScope.isEmpty())) {\n                logger.info(\"Validating token scopes as no authSpecificScope required\");\n                if ((missingScopes != null && !missingScopes.isEmpty())) {\n                    logger.error(\"Insufficient scopes! Required scope:{} -  however token scopes:{}\", resourceScopes,\n                            tokenScopes);\n                    throw new WebApplicationException(\"Insufficient scopes! , Required scope: \" + resourceScopes\n                            + \", however token scopes: \" + tokenScopes,\n                            Response.status(Response.Status.UNAUTHORIZED).build());\n                }\n                return AUTHENTICATION_SCHEME + accessToken;\n            }\n\n            // If only authSpecificScope missing then proceed with token creation else throw\n            // error\n            if (missingScopes != null && !missingScopes.isEmpty()\n                    && !isEqualCollection(missingScopes, authSpecificScope)) {\n                logger.error(\"Insufficient scopes!! Required scope:{}, , however token scopes:{} \", resourceScopes,\n                        tokenScopes);\n                throw new WebApplicationException(\"Insufficient scopes!! , Required scope: \" + resourceScopes\n                        + \", however token scopes: \" + tokenScopes,\n                        Response.status(Response.Status.UNAUTHORIZED).build());\n            }\n            \n            //If no scope is missing\n            if (missingScopes == null || missingScopes.isEmpty()) {\n                logger.info(\" No missing scopes and hence returning original accessToken\");\n                return AUTHENTICATION_SCHEME + accessToken;\n            }\n\n            logger.info(\"Generating new token with authSpecificScope\");\n            // Generate token with required resourceScopes\n            resourceScopes.addAll(authSpecificScope);\n            accessToken = openIdService.requestAccessToken(authUtil.getClientId(), resourceScopes);\n            logger.debug(\"Introspecting new accessToken:{}\", accessToken);\n\n            // Introspect\n            IntrospectionResponse introspectionResponse = openIdService\n                    .getIntrospectionResponse(AUTHENTICATION_SCHEME + accessToken, accessToken, authUtil.getIssuer());\n\n            // Validate Token Scope\n            if (!validateScope(introspectionResponse.getScope(), resourceScopes)) {\n                logger.error(\"Insufficient scopes!!! for new token as well - Required scope:{}, token scopes:{}\",\n                        resourceScopes, introspectionResponse.getScope());\n                throw new WebApplicationException(\n                        \"Insufficient scopes!!! Required scope: \" + resourceScopes + \", token scopes: \"\n                                + introspectionResponse.getScope(),\n                        Response.status(Response.Status.UNAUTHORIZED).build());\n            }\n\n            logger.info(\"Token scopes Valid Returning accessToken:{}\", accessToken);\n            return AUTHENTICATION_SCHEME + accessToken;\n        } catch (Exception ex) {\n            if (logger.isErrorEnabled()) {\n                logger.error(\"oAuth authorization error:{} \", ex.getMessage());\n            }\n            throw new WebApplicationException(\"oAuth authorization error \" + ex.getMessage(),\n                    Response.status(Response.Status.INTERNAL_SERVER_ERROR).build());\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "OpenIdAuthorizationService.java",
        "method_name": "validateScope",
        "raw_code": "private String validateScope(String accessToken, List<String> tokenScopes, ResourceInfo resourceInfo, String issuer)\n            throws WebApplicationException {\n        logger.info(\"Validate scope, accessToken:{}, tokenScopes:{}, resourceInfo: {}, issuer: {}\", accessToken,\n                tokenScopes, resourceInfo, issuer);\n        try {\n            // Get resource scope\n            Map<ProtectionScopeType, List<String>> resourceScopesByType = getRequestedScopes(resourceInfo);\n            List<String> resourceScopes = getAllScopeList(resourceScopesByType);\n            logger.debug(\"Validate scope, resourceScopesByType: {}, resourceScopes: {}\", resourceScopesByType,\n                    resourceScopes);\n          \n            //If no scope required\n            if (resourceScopes == null || resourceScopes.isEmpty()) {\n                logger.info(\" If no resource scopes required return original accessToken\");\n                return AUTHENTICATION_SCHEME + accessToken;\n            }\n            \n            // find missing scopes\n            List<String> missingScopes = findMissingScopes(resourceScopesByType, tokenScopes);\n            logger.info(\"missingScopes:{}\", missingScopes);\n\n            // Check if resource requires auth server specific scope\n            List<String> authSpecificScope = getAuthSpecificScopeRequired(resourceInfo);\n            logger.info(\" resourceScopes:{}, authSpecificScope:{} \", resourceScopes, authSpecificScope);\n\n            // If No auth scope required OR if token contains the authSpecificScope\n            if ((authSpecificScope == null || authSpecificScope.isEmpty())) {\n                logger.info(\"Validating token scopes as no authSpecificScope required\");\n                if ((missingScopes != null && !missingScopes.isEmpty())) {\n                    logger.error(\"Insufficient scopes! Required scope:{} -  however token scopes:{}\", resourceScopes,\n                            tokenScopes);\n                    throw new WebApplicationException(\"Insufficient scopes! , Required scope: \" + resourceScopes\n                            + \", however token scopes: \" + tokenScopes,\n                            Response.status(Response.Status.UNAUTHORIZED).build());\n                }\n                return AUTHENTICATION_SCHEME + accessToken;\n            }\n\n            // If only authSpecificScope missing then proceed with token creation else throw\n            // error\n            if (missingScopes != null && !missingScopes.isEmpty()\n                    && !isEqualCollection(missingScopes, authSpecificScope)) {\n                logger.error(\"Insufficient scopes!! Required scope:{}, , however token scopes:{} \", resourceScopes,\n                        tokenScopes);\n                throw new WebApplicationException(\"Insufficient scopes!! , Required scope: \" + resourceScopes\n                        + \", however token scopes: \" + tokenScopes,\n                        Response.status(Response.Status.UNAUTHORIZED).build());\n            }\n            \n            //If no scope is missing\n            if (missingScopes == null || missingScopes.isEmpty()) {\n                logger.info(\" No missing scopes and hence returning original accessToken\");\n                return AUTHENTICATION_SCHEME + accessToken;\n            }\n\n            logger.info(\"Generating new token with authSpecificScope\");\n            // Generate token with required resourceScopes\n            resourceScopes.addAll(authSpecificScope);\n            accessToken = openIdService.requestAccessToken(authUtil.getClientId(), resourceScopes);\n            logger.debug(\"Introspecting new accessToken:{}\", accessToken);\n\n            // Introspect\n            IntrospectionResponse introspectionResponse = openIdService\n                    .getIntrospectionResponse(AUTHENTICATION_SCHEME + accessToken, accessToken, authUtil.getIssuer());\n\n            // Validate Token Scope\n            if (!validateScope(introspectionResponse.getScope(), resourceScopes)) {\n                logger.error(\"Insufficient scopes!!! for new token as well - Required scope:{}, token scopes:{}\",\n                        resourceScopes, introspectionResponse.getScope());\n                throw new WebApplicationException(\n                        \"Insufficient scopes!!! Required scope: \" + resourceScopes + \", token scopes: \"\n                                + introspectionResponse.getScope(),\n                        Response.status(Response.Status.UNAUTHORIZED).build());\n            }\n\n            logger.info(\"Token scopes Valid Returning accessToken:{}\", accessToken);\n            return AUTHENTICATION_SCHEME + accessToken;\n        } catch (Exception ex) {\n            if (logger.isErrorEnabled()) {\n                logger.error(\"oAuth authorization error:{} \", ex.getMessage());\n            }\n            throw new WebApplicationException(\"oAuth authorization error \" + ex.getMessage(),\n                    Response.status(Response.Status.INTERNAL_SERVER_ERROR).build());\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "pgjdbc",
    "cve_id": "CVE-2025-49146",
    "cwe_list": [
      "CWE-287"
    ],
    "commit_hash": "9217ed16cb2918ab1b6b9258ae97e6ede244d8a0",
    "short_hash": "9217ed16",
    "vulnerableMethods_before": [
      {
        "filename": "ConnectionFactoryImpl.java",
        "method_name": "doAuthentication",
        "raw_code": "private static void doAuthentication(PGStream pgStream, String host, String user, Properties info) throws IOException, SQLException {\n    // Now get the response from the backend, either an error message\n    // or an authentication request\n\n    /* SSPI negotiation state, if used */\n    ISSPIClient sspiClient = null;\n\n    /* SCRAM authentication state, if used */\n    ScramAuthenticator scramAuthenticator = null;\n    // TODO: figure out how to deal with new protocols\n    int protocol = 3 << 16;\n\n    try {\n      authloop: while (true) {\n        int beresp = pgStream.receiveChar();\n\n        switch (beresp) {\n          case PgMessageType.NEGOTIATE_PROTOCOL_RESPONSE:  // Negotiate Protocol Version\n            // read the length and ignore it.\n            pgStream.receiveInteger4();\n            protocol = pgStream.receiveInteger4();\n            int numOptionsNotRecognized = pgStream.receiveInteger4();\n            if (numOptionsNotRecognized > 0) {\n              // do not connect and throw an error\n              String errorMessage = \"Protocol error, received invalid options: \";\n              for (int i = 0; i < numOptionsNotRecognized; i++) {\n                errorMessage  += i > 0 ? \"\" : \",\" + pgStream.receiveString();\n              }\n              LOGGER.log(Level.FINEST, errorMessage);\n              throw new PSQLException(errorMessage, PSQLState.PROTOCOL_VIOLATION);\n            }\n            int major = protocol >> 16 & 0xff;\n            int minor = protocol & 0xff;\n            pgStream.setProtocolVersion( ProtocolVersion.fromMajorMinor(major, minor));\n            break;\n          case PgMessageType.ERROR_RESPONSE:\n            // An error occurred, so pass the error message to the\n            // user.\n            //\n            // The most common one to be thrown here is:\n            // \"User authentication failed\"\n            //\n            int elen = pgStream.receiveInteger4();\n\n            ServerErrorMessage errorMsg =\n                new ServerErrorMessage(pgStream.receiveErrorString(elen - 4));\n            LOGGER.log(Level.FINEST, \" <=BE ErrorMessage({0})\", errorMsg);\n            throw new PSQLException(errorMsg, PGProperty.LOG_SERVER_ERROR_DETAIL.getBoolean(info));\n\n          case PgMessageType.AUTHENTICATION_RESPONSE:\n            // Authentication request.\n            // Get the message length\n            int msgLen = pgStream.receiveInteger4();\n\n            // Get the type of request\n            int areq = pgStream.receiveInteger4();\n\n            // Process the request.\n            switch (areq) {\n              case AUTH_REQ_MD5: {\n                byte[] md5Salt = pgStream.receive(4);\n                if (LOGGER.isLoggable(Level.FINEST)) {\n                  LOGGER.log(Level.FINEST, \" <=BE AuthenticationReqMD5(salt={0})\", Utils.toHexString(md5Salt));\n                }\n\n                byte[] digest = AuthenticationPluginManager.withEncodedPassword(\n                    AuthenticationRequestType.MD5_PASSWORD, info,\n                    encodedPassword -> MD5Digest.encode(user.getBytes(StandardCharsets.UTF_8),\n                        encodedPassword, md5Salt)\n                );\n\n                if (LOGGER.isLoggable(Level.FINEST)) {\n                  LOGGER.log(Level.FINEST, \" FE=> Password(md5digest={0})\", new String(digest, StandardCharsets.US_ASCII));\n                }\n\n                try {\n                  pgStream.sendChar(PgMessageType.PASSWORD_REQUEST);\n                  pgStream.sendInteger4(4 + digest.length + 1);\n                  pgStream.send(digest);\n                } finally {\n                  Arrays.fill(digest, (byte) 0);\n                }\n                pgStream.sendChar(0);\n                pgStream.flush();\n\n                break;\n              }\n\n              case AUTH_REQ_PASSWORD: {\n                LOGGER.log(Level.FINEST, \"<=BE AuthenticationReqPassword\");\n                LOGGER.log(Level.FINEST, \" FE=> Password(password=<not shown>)\");\n\n                AuthenticationPluginManager.withEncodedPassword(AuthenticationRequestType.CLEARTEXT_PASSWORD, info, encodedPassword -> {\n                  pgStream.sendChar(PgMessageType.PASSWORD_REQUEST);\n                  pgStream.sendInteger4(4 + encodedPassword.length + 1);\n                  pgStream.send(encodedPassword);\n                  return void.class;\n                });\n                pgStream.sendChar(0);\n                pgStream.flush();\n\n                break;\n              }\n\n              case AUTH_REQ_GSS:\n              case AUTH_REQ_SSPI:\n                /*\n                 * Use GSSAPI if requested on all platforms, via JSSE.\n                 *\n                 * For SSPI auth requests, if we're on Windows attempt native SSPI authentication if\n                 * available, and if not disabled by setting a kerberosServerName. On other\n                 * platforms, attempt JSSE GSSAPI negotiation with the SSPI server.\n                 *\n                 * Note that this is slightly different to libpq, which uses SSPI for GSSAPI where\n                 * supported. We prefer to use the existing Java JSSE Kerberos support rather than\n                 * going to native (via JNA) calls where possible, so that JSSE system properties\n                 * etc continue to work normally.\n                 *\n                 * Note that while SSPI is often Kerberos-based there's no guarantee it will be; it\n                 * may be NTLM or anything else. If the client responds to an SSPI request via\n                 * GSSAPI and the other end isn't using Kerberos for SSPI then authentication will\n                 * fail.\n                 */\n                final String gsslib = PGProperty.GSS_LIB.getOrDefault(info);\n                final boolean usespnego = PGProperty.USE_SPNEGO.getBoolean(info);\n\n                boolean useSSPI = false;\n\n                /*\n                 * Use SSPI if we're in auto mode on windows and have a request for SSPI auth, or if\n                 * it's forced. Otherwise use gssapi. If the user has specified a Kerberos server\n                 * name we'll always use JSSE GSSAPI.\n                 */\n                if (\"gssapi\".equals(gsslib)) {\n                  LOGGER.log(Level.FINE, \"Using JSSE GSSAPI, param gsslib=gssapi\");\n                } else if (areq == AUTH_REQ_GSS && !\"sspi\".equals(gsslib)) {\n                  LOGGER.log(Level.FINE,\n                      \"Using JSSE GSSAPI, gssapi requested by server and gsslib=sspi not forced\");\n                } else {\n                  /* Determine if SSPI is supported by the client */\n                  sspiClient = createSSPI(pgStream, PGProperty.SSPI_SERVICE_CLASS.getOrDefault(info),\n                      /* Use negotiation for SSPI, or if explicitly requested for GSS */\n                      areq == AUTH_REQ_SSPI || (areq == AUTH_REQ_GSS && usespnego));\n\n                  useSSPI = sspiClient.isSSPISupported();\n                  LOGGER.log(Level.FINE, \"SSPI support detected: {0}\", useSSPI);\n\n                  if (!useSSPI) {\n                    /* No need to dispose() if no SSPI used */\n                    sspiClient = null;\n\n                    if (\"sspi\".equals(gsslib)) {\n                      throw new PSQLException(\n                          \"SSPI forced with gsslib=sspi, but SSPI not available; set loglevel=2 for details\",\n                          PSQLState.CONNECTION_UNABLE_TO_CONNECT);\n                    }\n                  }\n\n                  if (LOGGER.isLoggable(Level.FINE)) {\n                    LOGGER.log(Level.FINE, \"Using SSPI: {0}, gsslib={1} and SSPI support detected\", new Object[]{useSSPI, gsslib});\n                  }\n                }\n\n                if (useSSPI) {\n                  /* SSPI requested and detected as available */\n                  castNonNull(sspiClient).startSSPI();\n                } else {\n                  /* Use JGSS's GSSAPI for this request */\n                  AuthenticationPluginManager.withPassword(AuthenticationRequestType.GSS, info, password -> {\n                    MakeGSS.authenticate(false, pgStream, host, user, password,\n                        PGProperty.JAAS_APPLICATION_NAME.getOrDefault(info),\n                        PGProperty.KERBEROS_SERVER_NAME.getOrDefault(info), usespnego,\n                        PGProperty.JAAS_LOGIN.getBoolean(info),\n                        PGProperty.GSS_USE_DEFAULT_CREDS.getBoolean(info),\n                        PGProperty.LOG_SERVER_ERROR_DETAIL.getBoolean(info));\n                    return void.class;\n                  });\n                }\n                break;\n\n              case AUTH_REQ_GSS_CONTINUE:\n                /*\n                 * Only called for SSPI, as GSS is handled by an inner loop in MakeGSS.\n                 */\n                castNonNull(sspiClient).continueSSPI(msgLen - 8);\n                break;\n\n              case AUTH_REQ_SASL:\n                scramAuthenticator = AuthenticationPluginManager.withPassword(AuthenticationRequestType.SASL, info, password -> {\n                  if (password == null) {\n                    throw new PSQLException(\n                        GT.tr(\n                            \"The server requested SCRAM-based authentication, but no password was provided.\"),\n                        PSQLState.CONNECTION_REJECTED);\n                  }\n                  if (password.length == 0) {\n                    throw new PSQLException(\n                        GT.tr(\n                            \"The server requested SCRAM-based authentication, but the password is an empty string.\"),\n                        PSQLState.CONNECTION_REJECTED);\n                  }\n                  return new ScramAuthenticator(password, pgStream, info);\n                });\n                scramAuthenticator.handleAuthenticationSASL();\n                break;\n\n              case AUTH_REQ_SASL_CONTINUE:\n                castNonNull(scramAuthenticator).handleAuthenticationSASLContinue(msgLen - 4 - 4);\n                break;\n\n              case AUTH_REQ_SASL_FINAL:\n                castNonNull(scramAuthenticator).handleAuthenticationSASLFinal(msgLen - 4 - 4);\n                break;\n\n              case AUTH_REQ_OK:\n                /* Cleanup after successful authentication */\n                LOGGER.log(Level.FINEST, \" <=BE AuthenticationOk\");\n                break authloop; // We're done.\n\n              default:\n                LOGGER.log(Level.FINEST, \" <=BE AuthenticationReq (unsupported type {0})\", areq);\n                throw new PSQLException(GT.tr(\n                    \"The authentication type {0} is not supported. Check that you have configured the pg_hba.conf file to include the client''s IP address or subnet, and that it is using an authentication scheme supported by the driver.\",\n                    areq), PSQLState.CONNECTION_REJECTED);\n            }\n\n            break;\n\n          default:\n            throw new PSQLException(GT.tr(\"Protocol error.  Session setup failed.\"),\n                PSQLState.PROTOCOL_VIOLATION);\n        }\n      }\n    } finally {\n      /* Cleanup after successful or failed authentication attempts */\n      if (sspiClient != null) {\n        try {\n          sspiClient.dispose();\n        } catch (RuntimeException ex) {\n          LOGGER.log(Level.FINE, \"Unexpected error during SSPI context disposal\", ex);\n        }\n      }\n    }\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ConnectionFactoryImpl.java",
        "method_name": "doAuthentication",
        "raw_code": "private static void doAuthentication(PGStream pgStream, String host, String user, Properties info) throws IOException, SQLException {\n    // Now get the response from the backend, either an error message\n    // or an authentication request\n\n    /* SSPI negotiation state, if used */\n    ISSPIClient sspiClient = null;\n\n    /* SCRAM authentication state, if used */\n    ScramAuthenticator scramAuthenticator = null;\n    // TODO: figure out how to deal with new protocols\n    int protocol = 3 << 16;\n\n    boolean saslHandshakeCompleted = false;\n\n    try {\n      authloop: while (true) {\n        int beresp = pgStream.receiveChar();\n\n        switch (beresp) {\n          case PgMessageType.NEGOTIATE_PROTOCOL_RESPONSE:  // Negotiate Protocol Version\n            // read the length and ignore it.\n            pgStream.receiveInteger4();\n            protocol = pgStream.receiveInteger4();\n            int numOptionsNotRecognized = pgStream.receiveInteger4();\n            if (numOptionsNotRecognized > 0) {\n              // do not connect and throw an error\n              String errorMessage = \"Protocol error, received invalid options: \";\n              for (int i = 0; i < numOptionsNotRecognized; i++) {\n                errorMessage  += i > 0 ? \"\" : \",\" + pgStream.receiveString();\n              }\n              LOGGER.log(Level.FINEST, errorMessage);\n              throw new PSQLException(errorMessage, PSQLState.PROTOCOL_VIOLATION);\n            }\n            int major = protocol >> 16 & 0xff;\n            int minor = protocol & 0xff;\n            pgStream.setProtocolVersion( ProtocolVersion.fromMajorMinor(major, minor));\n            break;\n          case PgMessageType.ERROR_RESPONSE:\n            // An error occurred, so pass the error message to the\n            // user.\n            //\n            // The most common one to be thrown here is:\n            // \"User authentication failed\"\n            //\n            int elen = pgStream.receiveInteger4();\n\n            ServerErrorMessage errorMsg =\n                new ServerErrorMessage(pgStream.receiveErrorString(elen - 4));\n            LOGGER.log(Level.FINEST, \" <=BE ErrorMessage({0})\", errorMsg);\n            throw new PSQLException(errorMsg, PGProperty.LOG_SERVER_ERROR_DETAIL.getBoolean(info));\n\n          case PgMessageType.AUTHENTICATION_RESPONSE:\n            // Authentication request.\n            // Get the message length\n            int msgLen = pgStream.receiveInteger4();\n\n            // Get the type of request\n            int areq = pgStream.receiveInteger4();\n\n            if (ChannelBindingOption.of(info) == ChannelBindingOption.REQUIRE) {\n              if (areq == AUTH_REQ_OK) {\n                if (!saslHandshakeCompleted) {\n                  throw new PSQLException(\n                      GT.tr(\"Channel binding is required, but server skipped authentication. \"\n                          + \"Channel binding is only supported with SCRAM authentication over encrypted connections.\"),\n                      PSQLState.CONNECTION_REJECTED);\n                }\n              } else if (areq != AUTH_REQ_SASL && areq != AUTH_REQ_SASL_CONTINUE && areq != AUTH_REQ_SASL_FINAL) {\n                throw new PSQLException(\n                      GT.tr(\"Channel binding is required, but server requested ''{0}'' authentication. \"\n                          + \"Channel binding is only supported with SCRAM authentication over encrypted connections.\",\n                          getAuthenticationMethodName(areq)),\n                      PSQLState.CONNECTION_REJECTED);\n              }\n            }\n\n            // Process the request.\n            switch (areq) {\n              case AUTH_REQ_MD5: {\n                byte[] md5Salt = pgStream.receive(4);\n                if (LOGGER.isLoggable(Level.FINEST)) {\n                  LOGGER.log(Level.FINEST, \" <=BE AuthenticationReqMD5(salt={0})\", Utils.toHexString(md5Salt));\n                }\n\n                byte[] digest = AuthenticationPluginManager.withEncodedPassword(\n                    AuthenticationRequestType.MD5_PASSWORD, info,\n                    encodedPassword -> MD5Digest.encode(user.getBytes(StandardCharsets.UTF_8),\n                        encodedPassword, md5Salt)\n                );\n\n                if (LOGGER.isLoggable(Level.FINEST)) {\n                  LOGGER.log(Level.FINEST, \" FE=> Password(md5digest={0})\", new String(digest, StandardCharsets.US_ASCII));\n                }\n\n                try {\n                  pgStream.sendChar(PgMessageType.PASSWORD_REQUEST);\n                  pgStream.sendInteger4(4 + digest.length + 1);\n                  pgStream.send(digest);\n                } finally {\n                  Arrays.fill(digest, (byte) 0);\n                }\n                pgStream.sendChar(0);\n                pgStream.flush();\n\n                break;\n              }\n\n              case AUTH_REQ_PASSWORD: {\n                LOGGER.log(Level.FINEST, \"<=BE AuthenticationReqPassword\");\n                LOGGER.log(Level.FINEST, \" FE=> Password(password=<not shown>)\");\n\n                AuthenticationPluginManager.withEncodedPassword(AuthenticationRequestType.CLEARTEXT_PASSWORD, info, encodedPassword -> {\n                  pgStream.sendChar(PgMessageType.PASSWORD_REQUEST);\n                  pgStream.sendInteger4(4 + encodedPassword.length + 1);\n                  pgStream.send(encodedPassword);\n                  return void.class;\n                });\n                pgStream.sendChar(0);\n                pgStream.flush();\n\n                break;\n              }\n\n              case AUTH_REQ_GSS:\n              case AUTH_REQ_SSPI:\n                /*\n                 * Use GSSAPI if requested on all platforms, via JSSE.\n                 *\n                 * For SSPI auth requests, if we're on Windows attempt native SSPI authentication if\n                 * available, and if not disabled by setting a kerberosServerName. On other\n                 * platforms, attempt JSSE GSSAPI negotiation with the SSPI server.\n                 *\n                 * Note that this is slightly different to libpq, which uses SSPI for GSSAPI where\n                 * supported. We prefer to use the existing Java JSSE Kerberos support rather than\n                 * going to native (via JNA) calls where possible, so that JSSE system properties\n                 * etc continue to work normally.\n                 *\n                 * Note that while SSPI is often Kerberos-based there's no guarantee it will be; it\n                 * may be NTLM or anything else. If the client responds to an SSPI request via\n                 * GSSAPI and the other end isn't using Kerberos for SSPI then authentication will\n                 * fail.\n                 */\n                final String gsslib = PGProperty.GSS_LIB.getOrDefault(info);\n                final boolean usespnego = PGProperty.USE_SPNEGO.getBoolean(info);\n\n                boolean useSSPI = false;\n\n                /*\n                 * Use SSPI if we're in auto mode on windows and have a request for SSPI auth, or if\n                 * it's forced. Otherwise use gssapi. If the user has specified a Kerberos server\n                 * name we'll always use JSSE GSSAPI.\n                 */\n                if (\"gssapi\".equals(gsslib)) {\n                  LOGGER.log(Level.FINE, \"Using JSSE GSSAPI, param gsslib=gssapi\");\n                } else if (areq == AUTH_REQ_GSS && !\"sspi\".equals(gsslib)) {\n                  LOGGER.log(Level.FINE,\n                      \"Using JSSE GSSAPI, gssapi requested by server and gsslib=sspi not forced\");\n                } else {\n                  /* Determine if SSPI is supported by the client */\n                  sspiClient = createSSPI(pgStream, PGProperty.SSPI_SERVICE_CLASS.getOrDefault(info),\n                      /* Use negotiation for SSPI, or if explicitly requested for GSS */\n                      areq == AUTH_REQ_SSPI || (areq == AUTH_REQ_GSS && usespnego));\n\n                  useSSPI = sspiClient.isSSPISupported();\n                  LOGGER.log(Level.FINE, \"SSPI support detected: {0}\", useSSPI);\n\n                  if (!useSSPI) {\n                    /* No need to dispose() if no SSPI used */\n                    sspiClient = null;\n\n                    if (\"sspi\".equals(gsslib)) {\n                      throw new PSQLException(\n                          \"SSPI forced with gsslib=sspi, but SSPI not available; set loglevel=2 for details\",\n                          PSQLState.CONNECTION_UNABLE_TO_CONNECT);\n                    }\n                  }\n\n                  if (LOGGER.isLoggable(Level.FINE)) {\n                    LOGGER.log(Level.FINE, \"Using SSPI: {0}, gsslib={1} and SSPI support detected\", new Object[]{useSSPI, gsslib});\n                  }\n                }\n\n                if (useSSPI) {\n                  /* SSPI requested and detected as available */\n                  castNonNull(sspiClient).startSSPI();\n                } else {\n                  /* Use JGSS's GSSAPI for this request */\n                  AuthenticationPluginManager.withPassword(AuthenticationRequestType.GSS, info, password -> {\n                    MakeGSS.authenticate(false, pgStream, host, user, password,\n                        PGProperty.JAAS_APPLICATION_NAME.getOrDefault(info),\n                        PGProperty.KERBEROS_SERVER_NAME.getOrDefault(info), usespnego,\n                        PGProperty.JAAS_LOGIN.getBoolean(info),\n                        PGProperty.GSS_USE_DEFAULT_CREDS.getBoolean(info),\n                        PGProperty.LOG_SERVER_ERROR_DETAIL.getBoolean(info));\n                    return void.class;\n                  });\n                }\n                break;\n\n              case AUTH_REQ_GSS_CONTINUE:\n                /*\n                 * Only called for SSPI, as GSS is handled by an inner loop in MakeGSS.\n                 */\n                castNonNull(sspiClient).continueSSPI(msgLen - 8);\n                break;\n\n              case AUTH_REQ_SASL:\n                scramAuthenticator = AuthenticationPluginManager.withPassword(AuthenticationRequestType.SASL, info, password -> {\n                  if (password == null) {\n                    throw new PSQLException(\n                        GT.tr(\n                            \"The server requested SCRAM-based authentication, but no password was provided.\"),\n                        PSQLState.CONNECTION_REJECTED);\n                  }\n                  if (password.length == 0) {\n                    throw new PSQLException(\n                        GT.tr(\n                            \"The server requested SCRAM-based authentication, but the password is an empty string.\"),\n                        PSQLState.CONNECTION_REJECTED);\n                  }\n                  return new ScramAuthenticator(password, pgStream, info);\n                });\n                scramAuthenticator.handleAuthenticationSASL();\n                break;\n\n              case AUTH_REQ_SASL_CONTINUE:\n                castNonNull(scramAuthenticator).handleAuthenticationSASLContinue(msgLen - 4 - 4);\n                break;\n\n              case AUTH_REQ_SASL_FINAL:\n                castNonNull(scramAuthenticator).handleAuthenticationSASLFinal(msgLen - 4 - 4);\n                saslHandshakeCompleted = true;\n                break;\n\n              case AUTH_REQ_OK:\n                /* Cleanup after successful authentication */\n                LOGGER.log(Level.FINEST, \" <=BE AuthenticationOk\");\n                break authloop; // We're done.\n\n              default:\n                LOGGER.log(Level.FINEST, \" <=BE AuthenticationReq (unsupported type {0})\", areq);\n                throw new PSQLException(GT.tr(\n                    \"The authentication type {0} is not supported. Check that you have configured the pg_hba.conf file to include the client''s IP address or subnet, and that it is using an authentication scheme supported by the driver.\",\n                    areq), PSQLState.CONNECTION_REJECTED);\n            }\n\n            break;\n\n          default:\n            throw new PSQLException(GT.tr(\"Protocol error.  Session setup failed.\"),\n                PSQLState.PROTOCOL_VIOLATION);\n        }\n      }\n    } finally {\n      /* Cleanup after successful or failed authentication attempts */\n      if (sspiClient != null) {\n        try {\n          sspiClient.dispose();\n        } catch (RuntimeException ex) {\n          LOGGER.log(Level.FINE, \"Unexpected error during SSPI context disposal\", ex);\n        }\n      }\n    }\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "oidc",
    "cve_id": "CVE-2025-49594",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "d90d717172283aaa96bb5bb44e357f910ae64adb",
    "short_hash": "d90d7171",
    "vulnerableMethods_before": [
      {
        "filename": "OIDCTest.java",
        "method_name": "init",
        "raw_code": "@BeforeClass\n    public static void init() throws Exception\n    {\n        // This will not be null if we are in the middle of allTests\n        if (context == null) {\n            PersistentTestContext persistentTestContext =\n                new PersistentTestContext(Arrays.asList(new XWikiExecutor(0)/*, new XWikiExecutor(1)*/));\n            initializeSystem(persistentTestContext);\n\n            // Start XWiki\n            persistentTestContext.start();\n\n            // Cache the initial CSRF token since that token needs to be passed to all forms (this is done automatically\n            // in TestUtils), including the login form. Whenever a new user logs in we need to recache.\n            // Note that this requires a running XWiki instance.\n            getUtil().recacheSecretToken();\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "OIDCTest.java",
        "method_name": "init",
        "raw_code": "@BeforeClass\n    public static void init() throws Exception\n    {\n        // This will not be null if we are in the middle of allTests\n        if (context == null) {\n            PersistentTestContext persistentTestContext =\n                new PersistentTestContext(Arrays.asList(new XWikiExecutor(0)/* , new XWikiExecutor(1) */));\n            initializeSystem(persistentTestContext);\n\n            // Start XWiki\n            persistentTestContext.start();\n\n            // Cache the initial CSRF token since that token needs to be passed to all forms (this is done automatically\n            // in TestUtils), including the login form. Whenever a new user logs in we need to recache.\n            // Note that this requires a running XWiki instance.\n            getUtil().recacheSecretToken();\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "oidc",
    "cve_id": "CVE-2025-49594",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "d90d717172283aaa96bb5bb44e357f910ae64adb",
    "short_hash": "d90d7171",
    "vulnerableMethods_before": [
      {
        "filename": "OIDCTest.java",
        "method_name": "logout",
        "raw_code": "private void logout(int index)\n    {\n        getUtil().switchExecutor(index);\n        getUtil().gotoPage(getURL(index, \"/bin/logout/XWiki/XWikiLogout?xredirect=%2Fxwiki%2Fbin%2Fview%2FMain%2F\"));\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "OIDCTest.java",
        "method_name": "logout",
        "raw_code": "private void logout(int index)\n    {\n        getUtil().switchExecutor(index);\n        getUtil().gotoPage(getURL(index, \"/bin/logout/XWiki/XWikiLogout?xredirect=%2Fxwiki%2Fbin%2Fview%2FMain%2F\"));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "oidc",
    "cve_id": "CVE-2025-49594",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "d90d717172283aaa96bb5bb44e357f910ae64adb",
    "short_hash": "d90d7171",
    "vulnerableMethods_before": [
      {
        "filename": "OIDCTest.java",
        "method_name": "authenticate",
        "raw_code": "@Test\n    public void authenticate() throws Exception\n    {\n        cleanupClient();\n        cleanupProvider();\n\n        // Create a user on the provider\n        gotoHome(1);\n        getUtil().recacheSecretToken();\n        getUtil().createUser(\"provideruser\", \"providerpassword\", null);\n\n        // Login on the client\n        gotToClientLogin();\n\n        // We are asked for the provider to use, set it\n        OIDCClientProviderPage providerPage = new OIDCClientProviderPage();\n        providerPage.setProvider(getURL(1, \"/oidc\"));\n\n        // Start authentication\n        providerPage.clickAuthenticate();\n\n        // It gets redirected to the provider login page, login\n        LoginPage loginPage = new LoginPage();\n        loginPage.loginAs(\"provideruser\", \"providerpassword\");\n        // A consent is asked, accept\n        OIDCProviderConsentPage consentPage = new OIDCProviderConsentPage();\n        consentPage.clickAccept();\n\n        // It gets redirected back to the client authenticated with the remote user\n        assertEquals(getHomeURL(0), getUtil().getDriver().getCurrentUrl());\n\n        // Make sure the we are authenticated and we get the expected id on client side\n        assertEquals(\"xwiki:XWiki.127001-provideruser\", getCurrentUserReference());\n\n        // Log out of the client\n        logout(0);\n\n        // We are logged out of the provider and come back on the client\n        assertEquals(getHomeURL(0), getUtil().getDriver().getCurrentUrl());\n\n        // Make sure we are logged out of the client\n        assertNull(getCurrentUserReference());\n\n        // Make sure we are logged out of the provider too\n        gotoHome(1);\n        assertNull(getCurrentUserReference());\n\n        // Login again\n        gotToClientLogin();\n\n        // We are asked for the provider to use, set it\n        providerPage = new OIDCClientProviderPage();\n        providerPage.setProvider(getURL(1, \"/oidc\"));\n\n        // Start authentication\n        providerPage.clickAuthenticate();\n\n        // It gets redirected to the provider login page, login\n        loginPage = new LoginPage();\n        loginPage.loginAs(\"provideruser\", \"providerpassword\");\n        // No consent is needed this time\n\n        // It gets redirected back to the client authenticated with the remote user\n        assertEquals(getHomeURL(0), getUtil().getDriver().getCurrentUrl());\n\n        // Make sure the we are authenticated and we get the expected id on client side\n        assertEquals(\"xwiki:XWiki.127001-provideruser\", getCurrentUserReference());\n\n        // Make sure the user is logged in the provider\n        gotoHome(1);\n        assertEquals(\"xwiki:XWiki.provideruser\", getCurrentUserReference());\n\n        // Create a token on the provider\n        getUtil().gotoPage(getURL(1, \"/bin/view/XWiki/provideruser?category=userapplications\"));\n        OIDCApplicationsUserProfilePage applications = new OIDCApplicationsUserProfilePage(\"provideruser\");\n\n        applications.setApplicationName(\"My Application\");\n        applications = applications.clickCreate();\n\n        String token = applications.getToken();\n\n        URL url = new URL(getURL(1, \"/rest/\"));\n        URLConnection connection = url.openConnection();\n        connection.setRequestProperty(\"Authorization\", \"Bearer \" + token);\n        connection.connect();\n\n        assertEquals(\"xwiki:XWiki.provideruser\", connection.getHeaderField(\"XWiki-User\"));\n\n        // TODO: Add support on provider side to automatically catch standard logout and send a backchannel logout to\n        // all registered clients\n        // Log out of the provider\n        // logout(1);\n        //\n        // Make sure we are logged out of the provider\n        // assertNull(getCurrentUserReference());\n        //\n        // Make sure we are also logged out of the client\n        // gotoHome(0);\n        // assertNull(getCurrentUserReference());\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "OIDCTest.java",
        "method_name": "authenticate",
        "raw_code": "@Test\n    public void authenticate() throws Exception\n    {\n        cleanupClient();\n        cleanupProvider();\n\n        // Create a user on the provider\n        gotoHome(1);\n        getUtil().recacheSecretToken();\n        getUtil().createUser(\"provideruser\", \"providerpassword\", null);\n\n        // Go to token management of provideruser\n        getUtil().gotoPage(getURL(1, \"/bin/view/XWiki/provideruser?category=userapplications\"));\n        // Make sure guest user is not allowed to access the user token management\n        assertFalse(OIDCApplicationsUserProfilePage.isAllowed());\n\n        // Login on the client\n        gotToLogin(0);\n\n        // We are asked for the provider to use, set it\n        OIDCClientProviderPage providerPage = new OIDCClientProviderPage();\n        providerPage.setProvider(getURL(1, \"/oidc\"));\n\n        // Start authentication\n        providerPage.clickAuthenticate();\n\n        // It gets redirected to the provider login page, login\n        LoginPage loginPage = new LoginPage();\n        loginPage.loginAs(\"provideruser\", \"providerpassword\");\n        // A consent is asked, accept\n        OIDCProviderConsentPage consentPage = new OIDCProviderConsentPage();\n        consentPage.clickAccept();\n\n        // It gets redirected back to the client authenticated with the remote user\n        assertEquals(getHomeURL(0), getUtil().getDriver().getCurrentUrl());\n\n        // Make sure the we are authenticated and we get the expected id on client side\n        assertEquals(\"xwiki:XWiki.127001-provideruser\", getCurrentUserReference());\n\n        // Log out of the client\n        logout(0);\n\n        // We are logged out of the provider and come back on the client\n        assertEquals(getHomeURL(0), getUtil().getDriver().getCurrentUrl());\n\n        // Make sure we are logged out of the client\n        assertNull(getCurrentUserReference());\n\n        // Make sure we are logged out of the provider too\n        gotoHome(1);\n        assertNull(getCurrentUserReference());\n\n        // Login again\n        gotToLogin(0);\n\n        // We are asked for the provider to use, set it\n        providerPage = new OIDCClientProviderPage();\n        providerPage.setProvider(getURL(1, \"/oidc\"));\n\n        // Start authentication\n        providerPage.clickAuthenticate();\n\n        // It gets redirected to the provider login page, login\n        loginPage = new LoginPage();\n        loginPage.loginAs(\"provideruser\", \"providerpassword\");\n        // No consent is needed this time\n\n        // It gets redirected back to the client authenticated with the remote user\n        assertEquals(getHomeURL(0), getUtil().getDriver().getCurrentUrl());\n\n        // Make sure the we are authenticated and we get the expected id on client side\n        assertEquals(\"xwiki:XWiki.127001-provideruser\", getCurrentUserReference());\n\n        // Make sure the user is logged in the provider\n        gotoHome(1);\n        assertEquals(\"xwiki:XWiki.provideruser\", getCurrentUserReference());\n\n        // Create a token on the provider\n        getUtil().gotoPage(getURL(1, \"/bin/view/XWiki/provideruser?category=userapplications\"));\n        OIDCApplicationsUserProfilePage applications = new OIDCApplicationsUserProfilePage(\"provideruser\");\n\n        applications.setApplicationName(\"My Application\");\n        applications = applications.clickCreate();\n\n        String token = applications.getToken();\n\n        URL url = new URL(getURL(1, \"/rest/\"));\n        URLConnection connection = url.openConnection();\n        connection.setRequestProperty(\"Authorization\", \"Bearer \" + token);\n        connection.connect();\n\n        assertEquals(\"xwiki:XWiki.provideruser\", connection.getHeaderField(\"XWiki-User\"));\n\n        // TODO: Add support on provider side to automatically catch standard logout and send a backchannel logout to\n        // all registered clients\n        // Log out of the provider\n        // logout(1);\n        //\n        // Make sure we are logged out of the provider\n        // assertNull(getCurrentUserReference());\n        //\n        // Make sure we are also logged out of the client\n        // gotoHome(0);\n        // assertNull(getCurrentUserReference());\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-52472",
    "cwe_list": [
      "CWE-89"
    ],
    "commit_hash": "743ebf8696ffa55161ed2c5ecf26b09f69e6bcf1",
    "short_hash": "743ebf86",
    "vulnerableMethods_before": [],
    "vulnerableMethods_after": [
      {
        "filename": "ModificationsResourceImpl.java",
        "method_name": "getModifications",
        "raw_code": "@Override\n    public History getModifications(String wikiName, Integer start, Integer number, String order, Long ts,\n            Boolean withPrettyNames) throws XWikiRestException\n    {\n        try {\n            String validOrder = HqlQueryUtils.getValidQueryOrder(order, \"desc\");\n\n            History history = new History();\n\n            String query = String.format(\"select doc.space, doc.name, doc.language, rcs.id, rcs.date, rcs.author,\"\n                + \" rcs.comment from XWikiRCSNodeInfo as rcs, XWikiDocument as doc where rcs.id.docId = doc.id and\"\n                + \" rcs.date > :date order by rcs.date %s, rcs.id.version1 %s, rcs.id.version2 %s\",\n                validOrder, validOrder, validOrder);\n\n            List<Object> queryResult = null;\n            queryResult = this.queryManager.createQuery(query, Query.XWQL).bindValue(\"date\", new Date(ts))\n                .setLimit(number).setOffset(start).setWiki(wikiName).execute();\n\n            for (Object object : queryResult) {\n                Object[] fields = (Object[]) object;\n\n                String spaceId = (String) fields[0];\n                List<String> spaces = Utils.getSpacesFromSpaceId(spaceId);\n                String pageName = (String) fields[1];\n\n                DocumentReference documentReference =\n                    this.resolver.resolve(Utils.getPageId(wikiName, spaces, pageName));\n                if (this.authorizationManager.hasAccess(VIEW, documentReference)) {\n                    String language = (String) fields[2];\n                    if (language.equals(\"\")) {\n                        language = null;\n                    }\n                    XWikiRCSNodeId nodeId = (XWikiRCSNodeId) fields[3];\n                    Timestamp timestamp = (Timestamp) fields[4];\n                    Date modified = new Date(timestamp.getTime());\n                    String modifier = (String) fields[5];\n                    String comment = (String) fields[6];\n\n                    HistorySummary historySummary =\n                        DomainObjectFactory.createHistorySummary(this.objectFactory, this.uriInfo.getBaseUri(),\n                            wikiName, spaces, pageName, language, nodeId.getVersion(), modifier, modified, comment,\n                            Utils.getXWikiApi(this.componentManager), withPrettyNames);\n                    history.getHistorySummaries().add(historySummary);\n                }\n            }\n\n            return history;\n        } catch (QueryException e) {\n            throw new XWikiRestException(e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-52472",
    "cwe_list": [
      "CWE-89"
    ],
    "commit_hash": "743ebf8696ffa55161ed2c5ecf26b09f69e6bcf1",
    "short_hash": "743ebf86",
    "vulnerableMethods_before": [],
    "vulnerableMethods_after": [
      {
        "filename": "PageHistoryResourceImpl.java",
        "method_name": "getPageHistory",
        "raw_code": "@Override\n    public History getPageHistory(String wikiName, String spaceName, String pageName, Integer start, Integer number,\n            String order, Boolean withPrettyNames) throws XWikiRestException\n    {\n        List<String> spaces = parseSpaceSegments(spaceName);\n\n        DocumentReference documentReference = new DocumentReference(wikiName, spaces, pageName);\n        try {\n            this.contextualAuthorizationManager.checkAccess(Right.VIEW, documentReference);\n        } catch (AccessDeniedException e) {\n            throw new WebApplicationException(Response.Status.UNAUTHORIZED);\n        }\n\n        String spaceId = Utils.getLocalSpaceId(spaces);\n\n        History history = new History();\n\n        try {\n            String validOrder = HqlQueryUtils.getValidQueryOrder(order, \"desc\");\n\n            // Note that the query is made to work with Oracle which treats empty strings as null.\n            String query = String.format(\"select doc.space, doc.name, rcs.id, rcs.date, rcs.author, rcs.comment\"\n                + \" from XWikiRCSNodeInfo as rcs, XWikiDocument as doc where rcs.id.docId = doc.id and\"\n                + \" doc.space = :space and doc.name = :name and (doc.language = '' or doc.language is null)\"\n                + \" order by rcs.date %s, rcs.id.version1 %s, rcs.id.version2 %s\", validOrder, validOrder, validOrder);\n\n            List<Object> queryResult = null;\n            queryResult = this.queryManager.createQuery(query, Query.XWQL).bindValue(\"space\", spaceId)\n                .bindValue(\"name\", pageName).setLimit(number).setOffset(start).setWiki(wikiName).execute();\n\n            for (Object object : queryResult) {\n                Object[] fields = (Object[]) object;\n\n                XWikiRCSNodeId nodeId = (XWikiRCSNodeId) fields[2];\n                Timestamp timestamp = (Timestamp) fields[3];\n                Date modified = new Date(timestamp.getTime());\n                String modifier = (String) fields[4];\n                String comment = (String) fields[5];\n\n                HistorySummary historySummary = DomainObjectFactory.createHistorySummary(objectFactory,\n                        uriInfo.getBaseUri(), wikiName, spaces, pageName, null, nodeId.getVersion(), modifier,\n                        modified, comment, Utils.getXWikiApi(componentManager), withPrettyNames);\n\n                history.getHistorySummaries().add(historySummary);\n            }\n        } catch (QueryException e) {\n            throw new XWikiRestException(e);\n        }\n\n        return history;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-52472",
    "cwe_list": [
      "CWE-89"
    ],
    "commit_hash": "743ebf8696ffa55161ed2c5ecf26b09f69e6bcf1",
    "short_hash": "743ebf86",
    "vulnerableMethods_before": [],
    "vulnerableMethods_after": [
      {
        "filename": "PageTranslationHistoryResourceImpl.java",
        "method_name": "getPageTranslationHistory",
        "raw_code": "@Override\n    public History getPageTranslationHistory(String wikiName, String spaceName, String pageName, String language,\n            Integer start, Integer number, String order, Boolean withPrettyNames) throws XWikiRestException\n    {\n        List<String> spaces = parseSpaceSegments(spaceName);\n\n        DocumentReference documentReference = new DocumentReference(wikiName, spaces, pageName);\n        try {\n            this.contextualAuthorizationManager.checkAccess(Right.VIEW, documentReference);\n        } catch (AccessDeniedException e) {\n            throw new WebApplicationException(Response.Status.UNAUTHORIZED);\n        }\n\n        String spaceId = Utils.getLocalSpaceId(spaces);\n\n        History history = new History();\n\n        try {\n            String validOrder = HqlQueryUtils.getValidQueryOrder(order, \"desc\");\n\n            String query = String.format(\"select doc.space, doc.name, rcs.id, rcs.date, rcs.author, rcs.comment\"\n                + \" from XWikiRCSNodeInfo as rcs, XWikiDocument as doc where rcs.id.docId = doc.id and\"\n                + \" doc.space = :space and doc.name = :name and doc.language = :language\"\n                + \" order by rcs.date %s, rcs.id.version1 %s, rcs.id.version2 %s\", validOrder, validOrder, validOrder);\n            \n            List<Object> queryResult = null;\n            queryResult = this.queryManager.createQuery(query, Query.XWQL).bindValue(\"space\", spaceId)\n                .bindValue(\"name\", pageName).setLimit(number).bindValue(\"language\", language).setOffset(start)\n                .setWiki(wikiName).execute();\n\n            for (Object object : queryResult) {\n                Object[] fields = (Object[]) object;\n\n                XWikiRCSNodeId nodeId = (XWikiRCSNodeId) fields[2];\n                Timestamp timestamp = (Timestamp) fields[3];\n                Date modified = new Date(timestamp.getTime());\n                String modifier = (String) fields[4];\n                String comment = (String) fields[5];\n\n                HistorySummary historySummary = DomainObjectFactory.createHistorySummary(objectFactory,\n                        uriInfo.getBaseUri(), wikiName, spaces, pageName, language, nodeId.getVersion(), modifier,\n                        modified, comment, Utils.getXWikiApi(componentManager), withPrettyNames);\n\n                history.getHistorySummaries().add(historySummary);\n            }\n        } catch (QueryException e) {\n            throw new XWikiRestException(e);\n        }\n\n        return history;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-52472",
    "cwe_list": [
      "CWE-89"
    ],
    "commit_hash": "743ebf8696ffa55161ed2c5ecf26b09f69e6bcf1",
    "short_hash": "743ebf86",
    "vulnerableMethods_before": [
      {
        "filename": "BaseSearchResult.java",
        "method_name": "searchPages",
        "raw_code": "protected List<SearchResult> searchPages(List<SearchScope> searchScopes, String keywords, String wikiName,\n        String space, boolean hasProgrammingRights, int number, int start, String orderField, String order,\n        Boolean withPrettyNames, Boolean isLocaleAware) throws QueryException, IllegalArgumentException,\n            UriBuilderException, XWikiException\n    {\n        String database = Utils.getXWikiContext(componentManager).getWikiId();\n\n        /* This try is just needed for executing the finally clause. */\n        try {\n            if (keywords == null) {\n                return new ArrayList<>();\n            }\n\n            Formatter f = new Formatter();\n\n            /*\n             * If the order field is already one of the field hard coded in the base query, then do not add it to the\n             * select clause.\n             */\n            String addColumn = \"\";\n            if (!StringUtils.isBlank(orderField)) {\n                addColumn =\n                    (orderField.equals(\"\") || orderField.equals(\"fullName\") || orderField.equals(\"name\") || orderField\n                        .equals(\"space\")) ? \"\" : \", doc.\" + orderField;\n            }\n\n            String addSpace = \"\";\n            if (searchScopes.contains(SearchScope.NAME)) {\n                // Join the space to get the last space name.\n                addSpace = \"left join XWikiSpace as space on doc.space = space.reference\";\n            }\n\n            if (space != null) {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, doc.language\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc %s where doc.space = :space and ( \", addSpace);\n            } else {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, doc.language\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc %s where ( \", addSpace);\n            }\n\n            /* Look for scopes related to pages */\n            int acceptedScopes = 0;\n            for (int i = 0; i < searchScopes.size(); i++) {\n                SearchScope scope = searchScopes.get(i);\n\n                switch (scope) {\n                    case CONTENT:\n                        f.format(\"upper(doc.content) like :keywords \");\n                        acceptedScopes++;\n                        break;\n                    case NAME:\n                        String matchTerminalPage = \"doc.name <> :defaultDocName and upper(doc.name) like :keywords\";\n                        String matchNestedPage = \"doc.name = :defaultDocName and upper(space.name) like :keywords\";\n                        f.format(\"((%s) or (%s)) \", matchTerminalPage, matchNestedPage);\n                        acceptedScopes++;\n                        break;\n                    case TITLE:\n                        f.format(\"(upper(doc.title) like :keywords\");\n                        if (isLocaleAware) {\n                            f.format(\" and (\");\n                            // In Oracle database, an empty language is stored as null.\n                            String emptyLanguageCondition = \"(doc.language = '' or doc.language is null)\";\n                            f.format(\"(doc.language = :locale or (%s and doc.defaultLanguage = :locale)) \",\n                                emptyLanguageCondition);\n                            f.format(\"or (doc.language = :language or (%s and doc.defaultLanguage = :language)) \",\n                                emptyLanguageCondition);\n                            f.format((\"or (%s and not exists(\"\n                                    + \" from XWikiDocument as doc2\"\n                                    + \" where doc2.fullName = doc.fullName\"\n                                    + \" and (doc2.language = :locale or doc2.language = :language)))\"\n                                    + \")\"), emptyLanguageCondition);\n                        }\n                        f.format(\") \");\n                        acceptedScopes++;\n                        break;\n                }\n\n                if (i != searchScopes.size() - 1) {\n                    f.format(\" or \");\n                }\n            }\n\n            /* If we don't find any scope related to pages then return empty results */\n            if (acceptedScopes == 0) {\n                return new ArrayList<>();\n            }\n\n            /* Build the order clause. */\n            String orderClause;\n            if (StringUtils.isBlank(orderField)) {\n                orderClause = \"doc.fullName asc\";\n            } else {\n                /* Check if the order parameter is a valid \"asc\" or \"desc\" string, otherwise use \"asc\" */\n                if (\"asc\".equals(order) || \"desc\".equals(order)) {\n                    orderClause = String.format(\"doc.%s %s\", orderField, order);\n                } else {\n                    orderClause = String.format(\"doc.%s asc\", orderField);\n                }\n            }\n\n            // Add ordering\n            f.format(\") order by %s\", orderClause);\n            String queryString = f.toString();\n\n            Query query = this.queryManager.createQuery(queryString, Query.HQL)\n                    .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase()))\n                    .addFilter(Utils.getHiddenQueryFilter(this.componentManager)).setOffset(start)\n                    // Worst case scenario when making the locale aware query:\n                    // e.g.: Search matches a document translated in fr_CA and fr\n                    .setLimit(number * 2);\n\n            if (space != null) {\n                query.bindValue(\"space\", space);\n            }\n\n            if (searchScopes.contains(SearchScope.NAME)) {\n                query.bindValue(\"defaultDocName\",\n                    this.defaultEntityReferenceProvider.getDefaultReference(EntityType.DOCUMENT).getName());\n            }\n\n            // Search only pages translated in the user locale (e.g. fr_CA)\n            if (isLocaleAware && searchScopes.contains(SearchScope.TITLE)) {\n                Locale userLocale = localizationContext.getCurrentLocale();\n                query.bindValue(\"locale\", userLocale.toString());\n                query.bindValue(\"language\", userLocale.getLanguage());\n            }\n\n            return getPagesSearchResults(query.execute(), wikiName, withPrettyNames, number, isLocaleAware);\n        } finally {\n            Utils.getXWikiContext(componentManager).setWikiId(database);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "BaseSearchResult.java",
        "method_name": "searchPages",
        "raw_code": "protected List<SearchResult> searchPages(List<SearchScope> searchScopes, String keywords, String wikiName,\n        String space, boolean hasProgrammingRights, int number, int start, String orderField, String order,\n        Boolean withPrettyNames, Boolean isLocaleAware) throws QueryException, IllegalArgumentException,\n            UriBuilderException, XWikiException\n    {\n        String database = Utils.getXWikiContext(componentManager).getWikiId();\n\n        /* This try is just needed for executing the finally clause. */\n        try {\n            if (keywords == null) {\n                return new ArrayList<>();\n            }\n\n            Formatter f = new Formatter();\n\n            /*\n             * If the order field is already one of the field hard coded in the base query, then do not add it to the\n             * select clause.\n             */\n            String addColumn = \"\";\n            if (!StringUtils.isBlank(orderField)) {\n                addColumn =\n                    (orderField.equals(\"\") || orderField.equals(\"fullName\") || orderField.equals(\"name\") || orderField\n                        .equals(\"space\")) ? \"\" : \", doc.\" + orderField;\n            }\n\n            String addSpace = \"\";\n            if (searchScopes.contains(SearchScope.NAME)) {\n                // Join the space to get the last space name.\n                addSpace = \"left join XWikiSpace as space on doc.space = space.reference\";\n            }\n\n            if (space != null) {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, doc.language\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc %s where doc.space = :space and ( \", addSpace);\n            } else {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, doc.language\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc %s where ( \", addSpace);\n            }\n\n            /* Look for scopes related to pages */\n            int acceptedScopes = 0;\n            for (int i = 0; i < searchScopes.size(); i++) {\n                SearchScope scope = searchScopes.get(i);\n\n                switch (scope) {\n                    case CONTENT:\n                        f.format(\"upper(doc.content) like :keywords \");\n                        acceptedScopes++;\n                        break;\n                    case NAME:\n                        String matchTerminalPage = \"doc.name <> :defaultDocName and upper(doc.name) like :keywords\";\n                        String matchNestedPage = \"doc.name = :defaultDocName and upper(space.name) like :keywords\";\n                        f.format(\"((%s) or (%s)) \", matchTerminalPage, matchNestedPage);\n                        acceptedScopes++;\n                        break;\n                    case TITLE:\n                        f.format(\"(upper(doc.title) like :keywords\");\n                        if (isLocaleAware) {\n                            f.format(\" and (\");\n                            // In Oracle database, an empty language is stored as null.\n                            String emptyLanguageCondition = \"(doc.language = '' or doc.language is null)\";\n                            f.format(\"(doc.language = :locale or (%s and doc.defaultLanguage = :locale)) \",\n                                emptyLanguageCondition);\n                            f.format(\"or (doc.language = :language or (%s and doc.defaultLanguage = :language)) \",\n                                emptyLanguageCondition);\n                            f.format((\"or (%s and not exists(\"\n                                    + \" from XWikiDocument as doc2\"\n                                    + \" where doc2.fullName = doc.fullName\"\n                                    + \" and (doc2.language = :locale or doc2.language = :language)))\"\n                                    + \")\"), emptyLanguageCondition);\n                        }\n                        f.format(\") \");\n                        acceptedScopes++;\n                        break;\n                }\n\n                if (i != searchScopes.size() - 1) {\n                    f.format(\" or \");\n                }\n            }\n\n            /* If we don't find any scope related to pages then return empty results */\n            if (acceptedScopes == 0) {\n                return new ArrayList<>();\n            }\n\n            /* Build the order clause. */\n            String orderClause;\n            if (StringUtils.isBlank(orderField)) {\n                orderClause = \"doc.fullName asc\";\n            } else {\n                orderClause = String.format(\"doc.%s %s\", orderField, HqlQueryUtils.getValidQueryOrder(order, \"asc\"));\n            }\n\n            // Add ordering\n            f.format(\") order by %s\", orderClause);\n            String queryString = f.toString();\n\n            Query query = this.secureQueryManager.createQuery(queryString, Query.HQL)\n                    .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase()))\n                    .addFilter(Utils.getHiddenQueryFilter(this.componentManager)).setOffset(start)\n                    // Worst case scenario when making the locale aware query:\n                    // e.g.: Search matches a document translated in fr_CA and fr\n                    .setLimit(number * 2);\n\n            if (space != null) {\n                query.bindValue(\"space\", space);\n            }\n\n            if (searchScopes.contains(SearchScope.NAME)) {\n                query.bindValue(\"defaultDocName\",\n                    this.defaultEntityReferenceProvider.getDefaultReference(EntityType.DOCUMENT).getName());\n            }\n\n            // Search only pages translated in the user locale (e.g. fr_CA)\n            if (isLocaleAware && searchScopes.contains(SearchScope.TITLE)) {\n                Locale userLocale = localizationContext.getCurrentLocale();\n                query.bindValue(\"locale\", userLocale.toString());\n                query.bindValue(\"language\", userLocale.getLanguage());\n            }\n\n            return getPagesSearchResults(query.execute(), wikiName, withPrettyNames, number, isLocaleAware);\n        } finally {\n            Utils.getXWikiContext(componentManager).setWikiId(database);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-52472",
    "cwe_list": [
      "CWE-89"
    ],
    "commit_hash": "743ebf8696ffa55161ed2c5ecf26b09f69e6bcf1",
    "short_hash": "743ebf86",
    "vulnerableMethods_before": [
      {
        "filename": "BaseSearchResult.java",
        "method_name": "searchSpaces",
        "raw_code": "protected List<SearchResult> searchSpaces(String keywords, String wikiName, int number, int start)\n        throws QueryException, IllegalArgumentException, UriBuilderException, XWikiException\n    {\n        List<SearchResult> result = new ArrayList<SearchResult>();\n\n        if (StringUtils.isEmpty(keywords)) {\n            return result;\n        }\n        String escapedKeywords = keywords.replaceAll(\"([%_!])\", \"!$1\");\n\n        String query = \"select space.reference from XWikiSpace as space\"\n            + \" where lower(space.name) like lower(:keywords) escape '!'\"\n            + \" or lower(space.reference) like lower(:prefix) escape '!'\"\n            + \" order by lower(space.reference), space.reference\";\n\n        List<Object> queryResult = queryManager.createQuery(query, Query.HQL)\n            .bindValue(\"keywords\", String.format(\"%%%s%%\", escapedKeywords))\n            .bindValue(\"prefix\", String.format(\"%s%%\", escapedKeywords))\n            .setWiki(wikiName).setLimit(number).setOffset(start)\n            .addFilter(this.hiddenSpaceFilterProvider.get()).execute();\n\n        XWiki xwikiApi = Utils.getXWikiApi(componentManager);\n        for (Object object : queryResult) {\n            String spaceId = (String) object;\n            List<String> spaces = Utils.getSpacesFromSpaceId(spaceId);\n            SpaceReference spaceReference = new SpaceReference(wikiName, spaces);\n\n            if (this.authorizationManager.hasAccess(Right.VIEW, spaceReference)) {\n                Document spaceDoc = xwikiApi.getDocument(spaceReference);\n\n                SearchResult searchResult = objectFactory.createSearchResult();\n                searchResult.setType(\"space\");\n                searchResult.setId(spaceId);\n                searchResult.setWiki(wikiName);\n                searchResult.setSpace(spaceId);\n                searchResult.setTitle(spaceDoc != null ? spaceDoc.getPlainTitle() : spaceReference.getName());\n\n                List<String> restSpacesValue = Utils.getSpacesURLElements(spaces);\n\n                // Add a link to the space information.\n                Link spaceLink = new Link();\n                spaceLink.setRel(Relations.SPACE);\n                spaceLink.setHref(\n                    Utils.createURI(uriInfo.getBaseUri(), SpaceResource.class, wikiName, restSpacesValue).toString());\n                searchResult.getLinks().add(spaceLink);\n\n                // Add a link to the home page if it exists and it is viewable.\n                if (spaceDoc != null && !spaceDoc.isNew()) {\n                    Link pageLink = new Link();\n                    pageLink.setHref(Utils.createURI(uriInfo.getBaseUri(), PageResource.class, wikiName,\n                        restSpacesValue, spaceDoc.getDocumentReference().getName()).toString());\n                    pageLink.setRel(Relations.HOME);\n                    searchResult.getLinks().add(pageLink);\n                }\n\n                result.add(searchResult);\n            }\n        }\n\n        return result;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "BaseSearchResult.java",
        "method_name": "searchSpaces",
        "raw_code": "protected List<SearchResult> searchSpaces(String keywords, String wikiName, int number, int start)\n        throws QueryException, IllegalArgumentException, UriBuilderException, XWikiException\n    {\n        List<SearchResult> result = new ArrayList<SearchResult>();\n\n        if (StringUtils.isEmpty(keywords)) {\n            return result;\n        }\n        String escapedKeywords = keywords.replaceAll(\"([%_!])\", \"!$1\");\n\n        String query = \"select space.reference from XWikiSpace as space\"\n            + \" where lower(space.name) like lower(:keywords) escape '!'\"\n            + \" or lower(space.reference) like lower(:prefix) escape '!'\"\n            + \" order by lower(space.reference), space.reference\";\n\n        List<Object> queryResult = this.secureQueryManager.createQuery(query, Query.HQL)\n            .bindValue(\"keywords\", String.format(\"%%%s%%\", escapedKeywords))\n            .bindValue(\"prefix\", String.format(\"%s%%\", escapedKeywords))\n            .setWiki(wikiName).setLimit(number).setOffset(start)\n            .addFilter(this.hiddenSpaceFilterProvider.get()).execute();\n\n        XWiki xwikiApi = Utils.getXWikiApi(componentManager);\n        for (Object object : queryResult) {\n            String spaceId = (String) object;\n            List<String> spaces = Utils.getSpacesFromSpaceId(spaceId);\n            SpaceReference spaceReference = new SpaceReference(wikiName, spaces);\n\n            if (this.authorizationManager.hasAccess(Right.VIEW, spaceReference)) {\n                Document spaceDoc = xwikiApi.getDocument(spaceReference);\n\n                SearchResult searchResult = objectFactory.createSearchResult();\n                searchResult.setType(\"space\");\n                searchResult.setId(spaceId);\n                searchResult.setWiki(wikiName);\n                searchResult.setSpace(spaceId);\n                searchResult.setTitle(spaceDoc != null ? spaceDoc.getPlainTitle() : spaceReference.getName());\n\n                List<String> restSpacesValue = Utils.getSpacesURLElements(spaces);\n\n                // Add a link to the space information.\n                Link spaceLink = new Link();\n                spaceLink.setRel(Relations.SPACE);\n                spaceLink.setHref(\n                    Utils.createURI(uriInfo.getBaseUri(), SpaceResource.class, wikiName, restSpacesValue).toString());\n                searchResult.getLinks().add(spaceLink);\n\n                // Add a link to the home page if it exists and it is viewable.\n                if (spaceDoc != null && !spaceDoc.isNew()) {\n                    Link pageLink = new Link();\n                    pageLink.setHref(Utils.createURI(uriInfo.getBaseUri(), PageResource.class, wikiName,\n                        restSpacesValue, spaceDoc.getDocumentReference().getName()).toString());\n                    pageLink.setRel(Relations.HOME);\n                    searchResult.getLinks().add(pageLink);\n                }\n\n                result.add(searchResult);\n            }\n        }\n\n        return result;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-52472",
    "cwe_list": [
      "CWE-89"
    ],
    "commit_hash": "743ebf8696ffa55161ed2c5ecf26b09f69e6bcf1",
    "short_hash": "743ebf86",
    "vulnerableMethods_before": [
      {
        "filename": "BaseSearchResult.java",
        "method_name": "searchObjects",
        "raw_code": "protected List<SearchResult> searchObjects(String keywords, String wikiName, String space,\n        boolean hasProgrammingRights, int number, int start, String orderField, String order, Boolean withPrettyNames)\n        throws QueryException, IllegalArgumentException, UriBuilderException, XWikiException\n    {\n        XWikiContext xwikiContext = Utils.getXWikiContext(componentManager);\n\n        XWiki xwikiApi = Utils.getXWikiApi(componentManager);\n\n        String database = Utils.getXWikiContext(componentManager).getWikiId();\n\n        /* This try is just needed for executing the finally clause. */\n        try {\n            List<SearchResult> result = new ArrayList<SearchResult>();\n\n            if (keywords == null) {\n                return result;\n            }\n\n            Formatter f = new Formatter();\n\n            /*\n             * If the order field is already one of the field hard coded in the base query, then do not add it to the\n             * select clause.\n             */\n            String addColumn =\n                (orderField.equals(\"\") || orderField.equals(\"fullName\") || orderField.equals(\"name\") || orderField\n                    .equals(\"space\")) ? \"\" : \", doc.\" + orderField;\n\n            if (space != null) {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, obj.className, obj.number\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc, BaseObject as obj, StringProperty as sp, LargeStringProperty as lsp where doc.space = :space and obj.name=doc.fullName and sp.id.id = obj.id and lsp.id.id = obj.id and (upper(sp.value) like :keywords or upper(lsp.value) like :keywords) \");\n            } else {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, obj.className, obj.number\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc, BaseObject as obj, StringProperty as sp, LargeStringProperty as lsp where obj.name=doc.fullName and sp.id.id = obj.id and lsp.id.id = obj.id and (upper(sp.value) like :keywords or upper(lsp.value) like :keywords) \");\n            }\n\n            /* Build the order clause. */\n            String orderClause = null;\n            if (StringUtils.isBlank(orderField)) {\n                orderClause = \"doc.fullName asc\";\n            } else {\n                /* Check if the order parameter is a valid \"asc\" or \"desc\" string, otherwise use \"asc\" */\n                if (\"asc\".equals(order) || \"desc\".equals(order)) {\n                    orderClause = String.format(\"doc.%s %s\", orderField, order);\n                } else {\n                    orderClause = String.format(\"doc.%s asc\", orderField);\n                }\n            }\n\n            /* Add some filters if the user doesn't have programming rights. */\n            if (hasProgrammingRights) {\n                f.format(\" order by %s\", orderClause);\n            } else {\n                f.format(\n                    \" and doc.space<>'XWiki' and doc.space<>'Admin' and doc.space<>'Panels' and doc.name<>'WebPreferences' order by %s\",\n                    orderClause);\n            }\n\n            String query = f.toString();\n\n            List<Object> queryResult = null;\n\n            /* This is needed because if the :space placeholder is not in the query, setting it would cause an exception */\n            if (space != null) {\n                queryResult =\n                    queryManager.createQuery(query, Query.XWQL)\n                        .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase()))\n                        .bindValue(\"space\", space).setLimit(number).execute();\n            } else {\n                queryResult =\n                    queryManager.createQuery(query, Query.XWQL)\n                        .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase())).setLimit(number)\n                        .execute();\n            }\n\n            /* Build the result. */\n            for (Object object : queryResult) {\n                Object[] fields = (Object[]) object;\n\n                String spaceId = (String) fields[1];\n                List<String> spaces = Utils.getSpacesFromSpaceId(spaceId);\n                String pageName = (String) fields[2];\n                String className = (String) fields[3];\n                int objectNumber = (Integer) fields[4];\n\n                String id = Utils.getObjectId(wikiName, spaces, pageName, className, objectNumber);\n\n                String pageId = Utils.getPageId(wikiName, spaces, pageName);\n                String pageFullName = Utils.getPageFullName(wikiName, spaces, pageName);\n\n                /*\n                 * Check if the user has the right to see the found document. We also prevent guest users to access\n                 * object data in order to avoid leaking important information such as emails to crawlers.\n                 */\n                if (xwikiApi.hasAccessLevel(\"view\", pageId) && xwikiContext.getUserReference() != null) {\n                    Document doc = xwikiApi.getDocument(pageFullName);\n                    String title = doc.getDisplayTitle();\n                    SearchResult searchResult = objectFactory.createSearchResult();\n                    searchResult.setType(\"object\");\n                    searchResult.setId(id);\n                    searchResult.setPageFullName(pageFullName);\n                    searchResult.setTitle(title);\n                    searchResult.setWiki(wikiName);\n                    searchResult.setSpace(spaceId);\n                    searchResult.setPageName(pageName);\n                    searchResult.setVersion(doc.getVersion());\n                    searchResult.setClassName(className);\n                    searchResult.setObjectNumber(objectNumber);\n                    searchResult.setAuthor(doc.getAuthor());\n                    Calendar calendar = Calendar.getInstance();\n                    calendar.setTime(doc.getDate());\n                    searchResult.setModified(calendar);\n\n                    if (withPrettyNames) {\n                        searchResult.setAuthorName(Utils.getAuthorName(doc.getAuthorReference(), componentManager));\n                    }\n\n                    List<String> restSpacesValue = Utils.getSpacesURLElements(spaces);\n\n                    String pageUri =\n                        Utils.createURI(uriInfo.getBaseUri(), PageResource.class, wikiName, restSpacesValue, pageName)\n                            .toString();\n                    Link pageLink = new Link();\n                    pageLink.setHref(pageUri);\n                    pageLink.setRel(Relations.PAGE);\n                    searchResult.getLinks().add(pageLink);\n\n                    String objectUri = Utils.createURI(uriInfo.getBaseUri(), ObjectResource.class, wikiName,\n                        restSpacesValue, pageName, className, objectNumber).toString();\n                    Link objectLink = new Link();\n                    objectLink.setHref(objectUri);\n                    objectLink.setRel(Relations.OBJECT);\n                    searchResult.getLinks().add(objectLink);\n\n                    result.add(searchResult);\n                }\n            }\n\n            return result;\n        } finally {\n            Utils.getXWikiContext(componentManager).setWikiId(database);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "BaseSearchResult.java",
        "method_name": "searchObjects",
        "raw_code": "protected List<SearchResult> searchObjects(String keywords, String wikiName, String space,\n        boolean hasProgrammingRights, int number, int start, String orderField, String order, Boolean withPrettyNames)\n        throws QueryException, IllegalArgumentException, UriBuilderException, XWikiException\n    {\n        XWikiContext xwikiContext = Utils.getXWikiContext(componentManager);\n\n        XWiki xwikiApi = Utils.getXWikiApi(componentManager);\n\n        String database = Utils.getXWikiContext(componentManager).getWikiId();\n\n        /* This try is just needed for executing the finally clause. */\n        try {\n            List<SearchResult> result = new ArrayList<SearchResult>();\n\n            if (keywords == null) {\n                return result;\n            }\n\n            Formatter f = new Formatter();\n\n            /*\n             * If the order field is already one of the field hard coded in the base query, then do not add it to the\n             * select clause.\n             */\n            String addColumn =\n                (orderField.equals(\"\") || orderField.equals(\"fullName\") || orderField.equals(\"name\") || orderField\n                    .equals(\"space\")) ? \"\" : \", doc.\" + orderField;\n\n            if (space != null) {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, obj.className, obj.number\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc, BaseObject as obj, StringProperty as sp, LargeStringProperty as lsp where doc.space = :space and obj.name=doc.fullName and sp.id.id = obj.id and lsp.id.id = obj.id and (upper(sp.value) like :keywords or upper(lsp.value) like :keywords) \");\n            } else {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, obj.className, obj.number\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc, BaseObject as obj, StringProperty as sp, LargeStringProperty as lsp where obj.name=doc.fullName and sp.id.id = obj.id and lsp.id.id = obj.id and (upper(sp.value) like :keywords or upper(lsp.value) like :keywords) \");\n            }\n\n            /* Build the order clause. */\n            String orderClause = null;\n            if (StringUtils.isBlank(orderField)) {\n                orderClause = \"doc.fullName asc\";\n            } else {\n                /* Check if the order parameter is a valid \"asc\" or \"desc\" string, otherwise use \"asc\" */\n                if (\"asc\".equals(order) || \"desc\".equals(order)) {\n                    orderClause = String.format(\"doc.%s %s\", orderField, order);\n                } else {\n                    orderClause = String.format(\"doc.%s asc\", orderField);\n                }\n            }\n\n            /* Add some filters if the user doesn't have programming rights. */\n            if (hasProgrammingRights) {\n                f.format(\" order by %s\", orderClause);\n            } else {\n                f.format(\n                    \" and doc.space<>'XWiki' and doc.space<>'Admin' and doc.space<>'Panels' and doc.name<>'WebPreferences' order by %s\",\n                    orderClause);\n            }\n\n            String query = f.toString();\n\n            List<Object> queryResult = null;\n\n            /* This is needed because if the :space placeholder is not in the query, setting it would cause an exception */\n            if (space != null) {\n                queryResult =\n                    this.secureQueryManager.createQuery(query, Query.XWQL)\n                        .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase()))\n                        .bindValue(\"space\", space).setLimit(number).execute();\n            } else {\n                queryResult =\n                    this.secureQueryManager.createQuery(query, Query.XWQL)\n                        .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase())).setLimit(number)\n                        .execute();\n            }\n\n            /* Build the result. */\n            for (Object object : queryResult) {\n                Object[] fields = (Object[]) object;\n\n                String spaceId = (String) fields[1];\n                List<String> spaces = Utils.getSpacesFromSpaceId(spaceId);\n                String pageName = (String) fields[2];\n                String className = (String) fields[3];\n                int objectNumber = (Integer) fields[4];\n\n                String id = Utils.getObjectId(wikiName, spaces, pageName, className, objectNumber);\n\n                String pageId = Utils.getPageId(wikiName, spaces, pageName);\n                String pageFullName = Utils.getPageFullName(wikiName, spaces, pageName);\n\n                /*\n                 * Check if the user has the right to see the found document. We also prevent guest users to access\n                 * object data in order to avoid leaking important information such as emails to crawlers.\n                 */\n                if (xwikiApi.hasAccessLevel(\"view\", pageId) && xwikiContext.getUserReference() != null) {\n                    Document doc = xwikiApi.getDocument(pageFullName);\n                    String title = doc.getDisplayTitle();\n                    SearchResult searchResult = objectFactory.createSearchResult();\n                    searchResult.setType(\"object\");\n                    searchResult.setId(id);\n                    searchResult.setPageFullName(pageFullName);\n                    searchResult.setTitle(title);\n                    searchResult.setWiki(wikiName);\n                    searchResult.setSpace(spaceId);\n                    searchResult.setPageName(pageName);\n                    searchResult.setVersion(doc.getVersion());\n                    searchResult.setClassName(className);\n                    searchResult.setObjectNumber(objectNumber);\n                    searchResult.setAuthor(doc.getAuthor());\n                    Calendar calendar = Calendar.getInstance();\n                    calendar.setTime(doc.getDate());\n                    searchResult.setModified(calendar);\n\n                    if (withPrettyNames) {\n                        searchResult.setAuthorName(Utils.getAuthorName(doc.getAuthorReference(), componentManager));\n                    }\n\n                    List<String> restSpacesValue = Utils.getSpacesURLElements(spaces);\n\n                    String pageUri =\n                        Utils.createURI(uriInfo.getBaseUri(), PageResource.class, wikiName, restSpacesValue, pageName)\n                            .toString();\n                    Link pageLink = new Link();\n                    pageLink.setHref(pageUri);\n                    pageLink.setRel(Relations.PAGE);\n                    searchResult.getLinks().add(pageLink);\n\n                    String objectUri = Utils.createURI(uriInfo.getBaseUri(), ObjectResource.class, wikiName,\n                        restSpacesValue, pageName, className, objectNumber).toString();\n                    Link objectLink = new Link();\n                    objectLink.setHref(objectUri);\n                    objectLink.setRel(Relations.OBJECT);\n                    searchResult.getLinks().add(objectLink);\n\n                    result.add(searchResult);\n                }\n            }\n\n            return result;\n        } finally {\n            Utils.getXWikiContext(componentManager).setWikiId(database);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-52472",
    "cwe_list": [
      "CWE-89"
    ],
    "commit_hash": "743ebf8696ffa55161ed2c5ecf26b09f69e6bcf1",
    "short_hash": "743ebf86",
    "vulnerableMethods_before": [
      {
        "filename": "HqlQueryUtilsTest.java",
        "method_name": "toCompleteStatement",
        "raw_code": "@Test\n    public void toCompleteStatement()\n    {\n        assertEquals(\"from table\", HqlQueryUtils.toCompleteStatement(\"from table\"));\n        assertEquals(\"select * from table\", HqlQueryUtils.toCompleteStatement(\"select * from table\"));\n\n        assertEquals(\"select doc.fullName from XWikiDocument doc where doc.name = 'name'\",\n            HqlQueryUtils.toCompleteStatement(\"where doc.name = 'name'\"));\n        assertEquals(\"select doc.fullName from XWikiDocument doc order by doc.name\",\n            HqlQueryUtils.toCompleteStatement(\"order by doc.name\"));\n        assertEquals(\"select doc.fullName from XWikiDocument doc , XWikiSpace space\",\n            HqlQueryUtils.toCompleteStatement(\", XWikiSpace space\"));\n\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "HqlQueryUtilsTest.java",
        "method_name": "toCompleteStatement",
        "raw_code": "@Test\n    public void toCompleteStatement()\n    {\n        assertEquals(\"from table\", HqlQueryUtils.toCompleteStatement(\"from table\"));\n        assertEquals(\"select * from table\", HqlQueryUtils.toCompleteStatement(\"select * from table\"));\n\n        assertEquals(\"select doc.fullName from XWikiDocument doc where doc.name = 'name'\",\n            HqlQueryUtils.toCompleteStatement(\"where doc.name = 'name'\"));\n        assertEquals(\"select doc.fullName from XWikiDocument doc order by doc.name\",\n            HqlQueryUtils.toCompleteStatement(\"order by doc.name\"));\n        assertEquals(\"select doc.fullName from XWikiDocument doc , XWikiSpace space\",\n            HqlQueryUtils.toCompleteStatement(\", XWikiSpace space\"));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-52472",
    "cwe_list": [
      "CWE-89"
    ],
    "commit_hash": "a45eca2af772abb7324e56d7fd2df1ac937bc445",
    "short_hash": "a45eca2a",
    "vulnerableMethods_before": [
      {
        "filename": "DatabaseKeywordSearchSource.java",
        "method_name": "searchPages",
        "raw_code": "private List<SearchResult> searchPages(KeywordSearchOptions options, String keywords, URI baseURI)\n        throws QueryException, IllegalArgumentException,\n        UriBuilderException, XWikiException\n    {\n        String database = this.contextProvider.get().getWikiId();\n\n        /* This try is just needed for executing the finally clause. */\n        try (Formatter f = new Formatter()) {\n            if (keywords == null) {\n                return new ArrayList<>();\n            }\n\n            String orderField = options.orderField();\n            /*\n             * If the order field is already one of the field hard coded in the base query, then do not add it to the\n             * select clause.\n             */\n            String addColumn = \"\";\n            if (!StringUtils.isBlank(orderField)) {\n                addColumn =\n                    (orderField.equals(\"\") || orderField.equals(\"fullName\") || orderField.equals(\"name\") || orderField\n                        .equals(\"space\")) ? \"\" : \", doc.\" + orderField;\n            }\n\n            String addSpace = \"\";\n            if (options.searchScopes().contains(NAME)) {\n                // Join the space to get the last space name.\n                addSpace = \"left join XWikiSpace as space on doc.space = space.reference\";\n            }\n\n            if (options.space() != null) {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, doc.language\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc %s where doc.space = :space and ( \", addSpace);\n            } else {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, doc.language\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc %s where ( \", addSpace);\n            }\n\n            /* Look for scopes related to pages */\n            int acceptedScopes = 0;\n            for (int i = 0; i < options.searchScopes().size(); i++) {\n                KeywordSearchScope scope = options.searchScopes().get(i);\n\n                switch (scope) {\n                    case CONTENT:\n                        f.format(\"upper(doc.content) like :keywords \");\n                        acceptedScopes++;\n                        break;\n                    case NAME:\n                        String matchTerminalPage = \"doc.name <> :defaultDocName and upper(doc.name) like :keywords\";\n                        String matchNestedPage = \"doc.name = :defaultDocName and upper(space.name) like :keywords\";\n                        f.format(\"((%s) or (%s)) \", matchTerminalPage, matchNestedPage);\n                        acceptedScopes++;\n                        break;\n                    case TITLE:\n                        f.format(\"(upper(doc.title) like :keywords\");\n                        if (Boolean.TRUE.equals(options.isLocaleAware())) {\n                            f.format(\" and (\");\n                            // In Oracle database, an empty language is stored as null.\n                            String emptyLanguageCondition = \"(doc.language = '' or doc.language is null)\";\n                            f.format(\"(doc.language = :locale or (%s and doc.defaultLanguage = :locale)) \",\n                                emptyLanguageCondition);\n                            f.format(\"or (doc.language = :language or (%s and doc.defaultLanguage = :language)) \",\n                                emptyLanguageCondition);\n                            f.format((\"or (%s and not exists(\"\n                                + \" from XWikiDocument as doc2\"\n                                + \" where doc2.fullName = doc.fullName\"\n                                + \" and (doc2.language = :locale or doc2.language = :language)))\"\n                                + \")\"), emptyLanguageCondition);\n                        }\n                        f.format(\") \");\n                        acceptedScopes++;\n                        break;\n                    default:\n                        // Ignore other scopes.\n                }\n\n                if (i != options.searchScopes().size() - 1) {\n                    f.format(\" or \");\n                }\n            }\n\n            /* If we don't find any scope related to pages then return empty results */\n            if (acceptedScopes == 0) {\n                return new ArrayList<>();\n            }\n\n            /* Build the order clause. */\n            String orderClause;\n            if (StringUtils.isBlank(orderField)) {\n                orderClause = \"doc.fullName asc\";\n            } else {\n                orderClause =\n                    String.format(\"doc.%s %s\", orderField, HqlQueryUtils.getValidQueryOrder(options.order(), \"asc\"));\n            }\n\n            // Add ordering\n            f.format(\") order by %s\", orderClause);\n            String queryString = f.toString();\n\n            Query query = this.secureQueryManager.createQuery(queryString, Query.HQL)\n                .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase()))\n                .addFilter(this.hiddenDocumentFilterProvider.get()).setOffset(options.start())\n                // Worst case scenario when making the locale aware query:\n                // e.g.: Search matches a document translated in fr_CA and fr\n                .setLimit(options.number() * 2);\n\n            if (options.space() != null) {\n                query.bindValue(\"space\", options.space());\n            }\n\n            if (options.searchScopes().contains(NAME)) {\n                query.bindValue(\"defaultDocName\",\n                    this.defaultEntityReferenceProvider.getDefaultReference(EntityType.DOCUMENT).getName());\n            }\n\n            // Search only pages translated in the user locale (e.g. fr_CA)\n            if (options.isLocaleAware() && options.searchScopes().contains(TITLE)) {\n                Locale userLocale = this.localizationContext.getCurrentLocale();\n                query.bindValue(\"locale\", userLocale.toString());\n                query.bindValue(\"language\", userLocale.getLanguage());\n            }\n\n            return getPagesSearchResults(query.execute(), options.wikiName(), options.withPrettyNames(),\n                options.number(), options.isLocaleAware(), baseURI);\n        } finally {\n            this.contextProvider.get().setWikiId(database);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DatabaseKeywordSearchSource.java",
        "method_name": "searchPages",
        "raw_code": "private List<SearchResult> searchPages(KeywordSearchOptions options, String keywords, URI baseURI)\n        throws QueryException, IllegalArgumentException,\n        UriBuilderException, XWikiException\n    {\n        String database = this.contextProvider.get().getWikiId();\n\n        /* This try is just needed for executing the finally clause. */\n        try (Formatter f = new Formatter()) {\n            if (keywords == null) {\n                return new ArrayList<>();\n            }\n\n            QueryManager finalQueryManager = this.queryManager;\n\n            String orderField = options.orderField();\n            /*\n             * If the order field is already one of the field hard coded in the base query, then do not add it to the\n             * select clause.\n             */\n            String addColumn = \"\";\n            if (!StringUtils.isBlank(orderField)) {\n                addColumn =\n                    (orderField.equals(\"\") || orderField.equals(\"fullName\") || orderField.equals(\"name\") || orderField\n                        .equals(\"space\")) ? \"\" : \", doc.\" + orderField;\n            }\n\n            String addSpace = \"\";\n            if (options.searchScopes().contains(NAME)) {\n                // Join the space to get the last space name.\n                addSpace = \"left join XWikiSpace as space on doc.space = space.reference\";\n            }\n\n            if (options.space() != null) {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, doc.language\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc %s where doc.space = :space and ( \", addSpace);\n            } else {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, doc.language\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc %s where ( \", addSpace);\n            }\n\n            /* Look for scopes related to pages */\n            int acceptedScopes = 0;\n            for (int i = 0; i < options.searchScopes().size(); i++) {\n                KeywordSearchScope scope = options.searchScopes().get(i);\n\n                switch (scope) {\n                    case CONTENT:\n                        f.format(\"upper(doc.content) like :keywords \");\n                        acceptedScopes++;\n                        break;\n                    case NAME:\n                        String matchTerminalPage = \"doc.name <> :defaultDocName and upper(doc.name) like :keywords\";\n                        String matchNestedPage = \"doc.name = :defaultDocName and upper(space.name) like :keywords\";\n                        f.format(\"((%s) or (%s)) \", matchTerminalPage, matchNestedPage);\n                        acceptedScopes++;\n                        break;\n                    case TITLE:\n                        f.format(\"(upper(doc.title) like :keywords\");\n                        if (Boolean.TRUE.equals(options.isLocaleAware())) {\n                            f.format(\" and (\");\n                            // In Oracle database, an empty language is stored as null.\n                            String emptyLanguageCondition = \"(doc.language = '' or doc.language is null)\";\n                            f.format(\"(doc.language = :locale or (%s and doc.defaultLanguage = :locale)) \",\n                                emptyLanguageCondition);\n                            f.format(\"or (doc.language = :language or (%s and doc.defaultLanguage = :language)) \",\n                                emptyLanguageCondition);\n                            f.format((\"or (%s and not exists(\"\n                                + \" from XWikiDocument as doc2\"\n                                + \" where doc2.fullName = doc.fullName\"\n                                + \" and (doc2.language = :locale or doc2.language = :language)))\"\n                                + \")\"), emptyLanguageCondition);\n                        }\n                        f.format(\") \");\n                        acceptedScopes++;\n                        break;\n                    default:\n                        // Ignore other scopes.\n                }\n\n                if (i != options.searchScopes().size() - 1) {\n                    f.format(\" or \");\n                }\n            }\n\n            /* If we don't find any scope related to pages then return empty results */\n            if (acceptedScopes == 0) {\n                return new ArrayList<>();\n            }\n\n            /* Build the order clause. */\n            String orderClause;\n            if (StringUtils.isBlank(orderField)) {\n                orderClause = \"doc.fullName asc\";\n            } else {\n                orderClause =\n                    String.format(\"doc.%s %s\", orderField, HqlQueryUtils.getValidQueryOrder(options.order(), \"asc\"));\n\n                if (!StringUtils.isAlphanumeric(orderField)) {\n                    finalQueryManager = this.secureQueryManager;\n                }\n            }\n\n            // Add ordering\n            f.format(\") order by %s\", orderClause);\n            String queryString = f.toString();\n\n            Query query = finalQueryManager.createQuery(queryString, Query.HQL)\n                .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase()))\n                .addFilter(this.hiddenDocumentFilterProvider.get()).setOffset(options.start())\n                // Worst case scenario when making the locale aware query:\n                // e.g.: Search matches a document translated in fr_CA and fr\n                .setLimit(options.number() * 2);\n\n            if (options.space() != null) {\n                query.bindValue(\"space\", options.space());\n            }\n\n            if (options.searchScopes().contains(NAME)) {\n                query.bindValue(\"defaultDocName\",\n                    this.defaultEntityReferenceProvider.getDefaultReference(EntityType.DOCUMENT).getName());\n            }\n\n            // Search only pages translated in the user locale (e.g. fr_CA)\n            if (options.isLocaleAware() && options.searchScopes().contains(TITLE)) {\n                Locale userLocale = this.localizationContext.getCurrentLocale();\n                query.bindValue(\"locale\", userLocale.toString());\n                query.bindValue(\"language\", userLocale.getLanguage());\n            }\n\n            return getPagesSearchResults(query.execute(), options.wikiName(), options.withPrettyNames(),\n                options.number(), options.isLocaleAware(), baseURI);\n        } finally {\n            this.contextProvider.get().setWikiId(database);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-52472",
    "cwe_list": [
      "CWE-89"
    ],
    "commit_hash": "a45eca2af772abb7324e56d7fd2df1ac937bc445",
    "short_hash": "a45eca2a",
    "vulnerableMethods_before": [
      {
        "filename": "DatabaseKeywordSearchSource.java",
        "method_name": "searchSpaces",
        "raw_code": "private List<SearchResult> searchSpaces(String keywords, String wikiName, int number, int start, URI baseURI)\n        throws QueryException, IllegalArgumentException, UriBuilderException, XWikiException\n    {\n        List<SearchResult> result = new ArrayList<>();\n\n        if (StringUtils.isEmpty(keywords)) {\n            return result;\n        }\n        String escapedKeywords = keywords.replaceAll(\"([%_!])\", \"!$1\");\n\n        String query = \"select space.reference from XWikiSpace as space\"\n            + \" where lower(space.name) like lower(:keywords) escape '!'\"\n            + \" or lower(space.reference) like lower(:prefix) escape '!'\"\n            + \" order by lower(space.reference), space.reference\";\n\n        List<Object> queryResult = this.secureQueryManager.createQuery(query, Query.HQL)\n            .bindValue(\"keywords\", String.format(\"%%%s%%\", escapedKeywords))\n            .bindValue(\"prefix\", String.format(\"%s%%\", escapedKeywords))\n            .setWiki(wikiName).setLimit(number).setOffset(start)\n            .addFilter(this.hiddenSpaceFilterProvider.get()).execute();\n\n        XWikiContext context = this.contextProvider.get();\n        XWiki xwikiApi = new XWiki(context.getWiki(), context);\n        ObjectFactory objectFactory = new ObjectFactory();\n        for (Object object : queryResult) {\n            String spaceId = (String) object;\n            List<String> spaces = Utils.getSpacesFromSpaceId(spaceId);\n            SpaceReference spaceReference = new SpaceReference(wikiName, spaces);\n\n            if (this.authorizationManager.hasAccess(Right.VIEW, spaceReference)) {\n                Document spaceDoc = xwikiApi.getDocument(spaceReference);\n\n                SearchResult searchResult = objectFactory.createSearchResult();\n                searchResult.setType(\"space\");\n                searchResult.setId(spaceId);\n                searchResult.setWiki(wikiName);\n                searchResult.setSpace(spaceId);\n                searchResult.setTitle(spaceDoc != null ? spaceDoc.getPlainTitle() : spaceReference.getName());\n\n                List<String> restSpacesValue = Utils.getSpacesURLElements(spaces);\n\n                // Add a link to the space information.\n                Link spaceLink = new Link();\n                spaceLink.setRel(Relations.SPACE);\n                spaceLink.setHref(\n                    Utils.createURI(baseURI, SpaceResource.class, wikiName, restSpacesValue).toString());\n                searchResult.getLinks().add(spaceLink);\n\n                // Add a link to the home page if it exists and it is viewable.\n                if (spaceDoc != null && !spaceDoc.isNew()) {\n                    Link pageLink = new Link();\n                    pageLink.setHref(Utils.createURI(baseURI, PageResource.class, wikiName,\n                        restSpacesValue, spaceDoc.getDocumentReference().getName()).toString());\n                    pageLink.setRel(Relations.HOME);\n                    searchResult.getLinks().add(pageLink);\n                }\n\n                result.add(searchResult);\n            }\n        }\n\n        return result;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DatabaseKeywordSearchSource.java",
        "method_name": "searchSpaces",
        "raw_code": "private List<SearchResult> searchSpaces(String keywords, String wikiName, int number, int start, URI baseURI)\n        throws QueryException, IllegalArgumentException, UriBuilderException, XWikiException\n    {\n        List<SearchResult> result = new ArrayList<>();\n\n        if (StringUtils.isEmpty(keywords)) {\n            return result;\n        }\n        String escapedKeywords = keywords.replaceAll(\"([%_!])\", \"!$1\");\n\n        String query = \"select space.reference from XWikiSpace as space\"\n            + \" where lower(space.name) like lower(:keywords) escape '!'\"\n            + \" or lower(space.reference) like lower(:prefix) escape '!'\"\n            + \" order by lower(space.reference), space.reference\";\n\n        List<Object> queryResult = this.queryManager.createQuery(query, Query.HQL)\n            .bindValue(\"keywords\", String.format(\"%%%s%%\", escapedKeywords))\n            .bindValue(\"prefix\", String.format(\"%s%%\", escapedKeywords))\n            .setWiki(wikiName).setLimit(number).setOffset(start)\n            .addFilter(this.hiddenSpaceFilterProvider.get()).execute();\n\n        XWikiContext context = this.contextProvider.get();\n        XWiki xwikiApi = new XWiki(context.getWiki(), context);\n        ObjectFactory objectFactory = new ObjectFactory();\n        for (Object object : queryResult) {\n            String spaceId = (String) object;\n            List<String> spaces = Utils.getSpacesFromSpaceId(spaceId);\n            SpaceReference spaceReference = new SpaceReference(wikiName, spaces);\n\n            if (this.authorizationManager.hasAccess(Right.VIEW, spaceReference)) {\n                Document spaceDoc = xwikiApi.getDocument(spaceReference);\n\n                SearchResult searchResult = objectFactory.createSearchResult();\n                searchResult.setType(\"space\");\n                searchResult.setId(spaceId);\n                searchResult.setWiki(wikiName);\n                searchResult.setSpace(spaceId);\n                searchResult.setTitle(spaceDoc != null ? spaceDoc.getPlainTitle() : spaceReference.getName());\n\n                List<String> restSpacesValue = Utils.getSpacesURLElements(spaces);\n\n                // Add a link to the space information.\n                Link spaceLink = new Link();\n                spaceLink.setRel(Relations.SPACE);\n                spaceLink.setHref(\n                    Utils.createURI(baseURI, SpaceResource.class, wikiName, restSpacesValue).toString());\n                searchResult.getLinks().add(spaceLink);\n\n                // Add a link to the home page if it exists and it is viewable.\n                if (spaceDoc != null && !spaceDoc.isNew()) {\n                    Link pageLink = new Link();\n                    pageLink.setHref(Utils.createURI(baseURI, PageResource.class, wikiName,\n                        restSpacesValue, spaceDoc.getDocumentReference().getName()).toString());\n                    pageLink.setRel(Relations.HOME);\n                    searchResult.getLinks().add(pageLink);\n                }\n\n                result.add(searchResult);\n            }\n        }\n\n        return result;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-52472",
    "cwe_list": [
      "CWE-89"
    ],
    "commit_hash": "a45eca2af772abb7324e56d7fd2df1ac937bc445",
    "short_hash": "a45eca2a",
    "vulnerableMethods_before": [
      {
        "filename": "DatabaseKeywordSearchSource.java",
        "method_name": "searchObjects",
        "raw_code": "private List<SearchResult> searchObjects(String keywords, KeywordSearchOptions options,\n        boolean hasProgrammingRights, URI baseURI)\n        throws QueryException, IllegalArgumentException, UriBuilderException, XWikiException\n    {\n        XWikiContext context = this.contextProvider.get();\n\n        XWiki xwikiApi = new XWiki(context.getWiki(), context);\n\n        String database = context.getWikiId();\n\n        try (Formatter f = new Formatter()) {\n            List<SearchResult> result = new ArrayList<SearchResult>();\n\n            if (keywords == null) {\n                return result;\n            }\n\n            String orderField = options.orderField();\n            /*\n             * If the order field is already one of the field hard coded in the base query, then do not add it to the\n             * select clause.\n             */\n            String addColumn =\n                (orderField.isEmpty() || orderField.equals(\"fullName\") || orderField.equals(\"name\") || orderField\n                    .equals(\"space\")) ? \"\" : \", doc.\" + orderField;\n\n            if (options.space() != null) {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, obj.className, obj.number\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc, BaseObject as obj, StringProperty as sp, \"\n                    + \"LargeStringProperty as lsp where doc.space = :space and obj.name=doc.fullName \"\n                    + \"and sp.id.id = obj.id and lsp.id.id = obj.id \"\n                    + \"and (upper(sp.value) like :keywords or upper(lsp.value) like :keywords) \");\n            } else {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, obj.className, obj.number\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc, BaseObject as obj, StringProperty as sp, \"\n                    + \"LargeStringProperty as lsp where obj.name=doc.fullName and sp.id.id = obj.id \"\n                    + \"and lsp.id.id = obj.id and (upper(sp.value) like :keywords \"\n                    + \"or upper(lsp.value) like :keywords) \");\n            }\n\n            /* Build the order clause. */\n            String orderClause = null;\n            if (StringUtils.isBlank(orderField)) {\n                orderClause = \"doc.fullName asc\";\n            } else {\n                /* Check if the order parameter is a valid \"asc\" or \"desc\" string, otherwise use \"asc\" */\n                if (\"asc\".equals(options.order()) || \"desc\".equals(options.order())) {\n                    orderClause = String.format(\"doc.%s %s\", orderField, options.order());\n                } else {\n                    orderClause = String.format(\"doc.%s asc\", orderField);\n                }\n            }\n\n            /* Add some filters if the user doesn't have programming rights. */\n            if (hasProgrammingRights) {\n                f.format(\" order by %s\", orderClause);\n            } else {\n                f.format(\" and doc.space<>'XWiki' and doc.space<>'Admin' and doc.space<>'Panels' \"\n                        + \"and doc.name<>'WebPreferences' order by %s\",\n                    orderClause);\n            }\n\n            String query = f.toString();\n\n            List<Object> queryResult = null;\n\n            /* This is needed because if the :space placeholder is not in the query, setting it would cause an\n            exception */\n            if (options.space() != null) {\n                queryResult =\n                    this.secureQueryManager.createQuery(query, Query.XWQL)\n                        .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase()))\n                        .bindValue(\"space\", options.space()).setLimit(options.number()).execute();\n            } else {\n                queryResult =\n                    this.secureQueryManager.createQuery(query, Query.XWQL)\n                        .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase()))\n                        .setLimit(options.number())\n                        .execute();\n            }\n\n            /* Build the result. */\n            ObjectFactory objectFactory = new ObjectFactory();\n            for (Object object : queryResult) {\n                Object[] fields = (Object[]) object;\n\n                String spaceId = (String) fields[1];\n                List<String> spaces = Utils.getSpacesFromSpaceId(spaceId);\n                String pageName = (String) fields[2];\n                String className = (String) fields[3];\n                int objectNumber = (Integer) fields[4];\n\n                String id = Utils.getObjectId(options.wikiName(), spaces, pageName, className, objectNumber);\n\n                String pageId = Utils.getPageId(options.wikiName(), spaces, pageName);\n                String pageFullName = Utils.getPageFullName(options.wikiName(), spaces, pageName);\n\n                /*\n                 * Check if the user has the right to see the found document. We also prevent guest users to access\n                 * object data in order to avoid leaking important information such as emails to crawlers.\n                 */\n                if (xwikiApi.hasAccessLevel(\"view\", pageId) && context.getUserReference() != null) {\n                    Document doc = xwikiApi.getDocument(pageFullName);\n                    String title = doc.getDisplayTitle();\n                    SearchResult searchResult = objectFactory.createSearchResult();\n                    searchResult.setType(\"object\");\n                    searchResult.setId(id);\n                    searchResult.setPageFullName(pageFullName);\n                    searchResult.setTitle(title);\n                    searchResult.setWiki(options.wikiName());\n                    searchResult.setSpace(spaceId);\n                    searchResult.setPageName(pageName);\n                    searchResult.setVersion(doc.getVersion());\n                    searchResult.setClassName(className);\n                    searchResult.setObjectNumber(objectNumber);\n                    searchResult.setAuthor(doc.getAuthor());\n                    Calendar calendar = Calendar.getInstance();\n                    calendar.setTime(doc.getDate());\n                    searchResult.setModified(calendar);\n\n                    if (options.withPrettyNames()) {\n                        searchResult.setAuthorName(\n                            context.getWiki().getPlainUserName(doc.getAuthorReference(), context));\n                    }\n\n                    List<String> restSpacesValue = Utils.getSpacesURLElements(spaces);\n\n                    String pageUri =\n                        Utils.createURI(baseURI, PageResource.class, options.wikiName(), restSpacesValue, pageName)\n                            .toString();\n                    Link pageLink = new Link();\n                    pageLink.setHref(pageUri);\n                    pageLink.setRel(Relations.PAGE);\n                    searchResult.getLinks().add(pageLink);\n\n                    String objectUri = Utils.createURI(baseURI, ObjectResource.class, options.wikiName(),\n                        restSpacesValue, pageName, className, objectNumber).toString();\n                    Link objectLink = new Link();\n                    objectLink.setHref(objectUri);\n                    objectLink.setRel(Relations.OBJECT);\n                    searchResult.getLinks().add(objectLink);\n\n                    result.add(searchResult);\n                }\n            }\n\n            return result;\n        } finally {\n            this.contextProvider.get().setWikiId(database);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DatabaseKeywordSearchSource.java",
        "method_name": "searchObjects",
        "raw_code": "private List<SearchResult> searchObjects(KeywordSearchOptions options, URI baseURI, List<Object> queryResult,\n        XWikiContext context) throws UriBuilderException, XWikiException\n    {\n        List<SearchResult> result = new ArrayList<>();\n\n        XWiki xwikiApi = new XWiki(context.getWiki(), context);\n\n        /* Build the result. */\n        ObjectFactory objectFactory = new ObjectFactory();\n        for (Object object : queryResult) {\n            Object[] fields = (Object[]) object;\n\n            String spaceId = (String) fields[1];\n            List<String> spaces = Utils.getSpacesFromSpaceId(spaceId);\n            String pageName = (String) fields[2];\n            String className = (String) fields[3];\n            int objectNumber = (Integer) fields[4];\n\n            String id = Utils.getObjectId(options.wikiName(), spaces, pageName, className, objectNumber);\n\n            String pageId = Utils.getPageId(options.wikiName(), spaces, pageName);\n            String pageFullName = Utils.getPageFullName(options.wikiName(), spaces, pageName);\n\n            /*\n             * Check if the user has the right to see the found document. We also prevent guest users to access object\n             * data in order to avoid leaking important information such as emails to crawlers.\n             */\n            if (xwikiApi.hasAccessLevel(\"view\", pageId) && context.getUserReference() != null) {\n                Document doc = xwikiApi.getDocument(pageFullName);\n                String title = doc.getDisplayTitle();\n                SearchResult searchResult = objectFactory.createSearchResult();\n                searchResult.setType(\"object\");\n                searchResult.setId(id);\n                searchResult.setPageFullName(pageFullName);\n                searchResult.setTitle(title);\n                searchResult.setWiki(options.wikiName());\n                searchResult.setSpace(spaceId);\n                searchResult.setPageName(pageName);\n                searchResult.setVersion(doc.getVersion());\n                searchResult.setClassName(className);\n                searchResult.setObjectNumber(objectNumber);\n                searchResult.setAuthor(doc.getAuthor());\n                Calendar calendar = Calendar.getInstance();\n                calendar.setTime(doc.getDate());\n                searchResult.setModified(calendar);\n\n                if (options.withPrettyNames()) {\n                    searchResult.setAuthorName(context.getWiki().getPlainUserName(doc.getAuthorReference(), context));\n                }\n\n                List<String> restSpacesValue = Utils.getSpacesURLElements(spaces);\n\n                String pageUri = Utils\n                    .createURI(baseURI, PageResource.class, options.wikiName(), restSpacesValue, pageName).toString();\n                Link pageLink = new Link();\n                pageLink.setHref(pageUri);\n                pageLink.setRel(Relations.PAGE);\n                searchResult.getLinks().add(pageLink);\n\n                String objectUri = Utils.createURI(baseURI, ObjectResource.class, options.wikiName(), restSpacesValue,\n                    pageName, className, objectNumber).toString();\n                Link objectLink = new Link();\n                objectLink.setHref(objectUri);\n                objectLink.setRel(Relations.OBJECT);\n                searchResult.getLinks().add(objectLink);\n\n                result.add(searchResult);\n            }\n        }\n\n        return result;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-48058",
    "cwe_list": [
      "CWE-1333"
    ],
    "commit_hash": "72f79dec6d4292f892fbddd68a19c67935c7d81f",
    "short_hash": "72f79dec",
    "vulnerableMethods_before": [
      {
        "filename": "ConversionUtil.java",
        "method_name": "getElementCount",
        "raw_code": "public static long getElementCount(String xmlFile, String className) {\n        String regex = \"(<cim:\" + className + \" (rdf:ID=\\\"_|rdf:about=\\\"#_).*?\\\")>\";\n        Pattern pattern = Pattern.compile(regex);\n        Matcher matcher = pattern.matcher(xmlFile);\n        return matcher.results().count();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ConversionUtil.java",
        "method_name": "getElementCount",
        "raw_code": "public static long getElementCount(String xmlFile, String className) {\n        String regex = \"(<cim:\" + className + \" (rdf:ID=\\\"_|rdf:about=\\\"#_).*?\\\")>\";\n        Pattern pattern = Pattern.compile(regex);\n        Matcher matcher = pattern.matcher(xmlFile);\n        return matcherCount(matcher);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-48058",
    "cwe_list": [
      "CWE-1333"
    ],
    "commit_hash": "72f79dec6d4292f892fbddd68a19c67935c7d81f",
    "short_hash": "72f79dec",
    "vulnerableMethods_before": [
      {
        "filename": "CgmesExportTest.java",
        "method_name": "testModelEquipmentOperationProfile",
        "raw_code": "@Test\n    void testModelEquipmentOperationProfile() throws IOException {\n        String importDir = \"/issues/switches/\";\n        Network network = readCgmesResources(importDir, \"disconnected_terminal_EQ.xml\");\n\n        String exportDir = \"/testModelProfile\";\n        try (FileSystem fs = Jimfs.newFileSystem(Configuration.unix())) {\n            Path tmpDir = Files.createDirectory(fs.getPath(exportDir));\n            String eqFile = writeCgmesProfile(network, \"EQ\", tmpDir);\n\n            String regex = \"<md:Model.profile>http://entsoe.eu/CIM/EquipmentOperation/3/1</md:Model.profile>\";\n            Pattern pattern = Pattern.compile(regex);\n            Matcher matcher = pattern.matcher(eqFile);\n            assertEquals(1, matcher.results().count());\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "CgmesExportTest.java",
        "method_name": "testModelEquipmentOperationProfile",
        "raw_code": "@Test\n    void testModelEquipmentOperationProfile() throws IOException {\n        String importDir = \"/issues/switches/\";\n        Network network = readCgmesResources(importDir, \"disconnected_terminal_EQ.xml\");\n\n        String exportDir = \"/testModelProfile\";\n        try (FileSystem fs = Jimfs.newFileSystem(Configuration.unix())) {\n            Path tmpDir = Files.createDirectory(fs.getPath(exportDir));\n            String eqFile = writeCgmesProfile(network, \"EQ\", tmpDir);\n\n            String regex = \"<md:Model.profile>http://entsoe.eu/CIM/EquipmentOperation/3/1</md:Model.profile>\";\n            Pattern pattern = Pattern.compile(regex);\n            Matcher matcher = pattern.matcher(eqFile);\n            assertEquals(1, matcherCount(matcher));\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-48058",
    "cwe_list": [
      "CWE-1333"
    ],
    "commit_hash": "72f79dec6d4292f892fbddd68a19c67935c7d81f",
    "short_hash": "72f79dec",
    "vulnerableMethods_before": [
      {
        "filename": "StateVariablesExportTest.java",
        "method_name": "testWriteBoundaryTnInTopologicalIsland",
        "raw_code": "@Test\n    void testWriteBoundaryTnInTopologicalIsland() throws XMLStreamException {\n        Network network = Network.read(CgmesConformity1Catalog.microGridBaseCaseNL().dataSource());\n        Optional<? extends Terminal> terminal = network.getBusBreakerView().getBus(\"97d7d14a-7294-458f-a8d7-024700a08717\").getConnectedTerminalStream().findFirst();\n        assertTrue(terminal.isPresent());\n        ReferenceTerminals.addTerminal(terminal.get());\n        String sv = exportSvAsString(network, false);\n        Pattern p = Pattern.compile(\"<cim:TopologicalIsland.TopologicalNodes rdf:resource=\");\n        assertEquals(10, p.matcher(sv).results().count());\n        // 10 is the number of topological nodes in the island associated to buses and to dangling lines\n        assertEquals(5, network.getBusBreakerView().getBusStream().count());\n        assertEquals(5, network.getDanglingLineStream().count());\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "StateVariablesExportTest.java",
        "method_name": "testWriteBoundaryTnInTopologicalIsland",
        "raw_code": "@Test\n    void testWriteBoundaryTnInTopologicalIsland() throws XMLStreamException {\n        Network network = Network.read(CgmesConformity1Catalog.microGridBaseCaseNL().dataSource());\n        Optional<? extends Terminal> terminal = network.getBusBreakerView().getBus(\"97d7d14a-7294-458f-a8d7-024700a08717\").getConnectedTerminalStream().findFirst();\n        assertTrue(terminal.isPresent());\n        ReferenceTerminals.addTerminal(terminal.get());\n        String sv = exportSvAsString(network, false);\n        Pattern p = Pattern.compile(\"<cim:TopologicalIsland.TopologicalNodes rdf:resource=\");\n        assertEquals(10, matcherCount(p.matcher(sv)));\n        // 10 is the number of topological nodes in the island associated to buses and to dangling lines\n        assertEquals(5, network.getBusBreakerView().getBusStream().count());\n        assertEquals(5, network.getDanglingLineStream().count());\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "StateVariablesExportTest.java",
        "method_name": "readSvShuntCompensatorSections",
        "raw_code": "private static SvShuntCompensatorSections readSvShuntCompensatorSections(String sv) {\n        final String svShuntCompensatorSections = \"SvShuntCompensatorSections\";\n        final String svShuntCompensatorSectionsSections = \"SvShuntCompensatorSections.sections\";\n        final String svShuntCompensatorSectionsShuntCompensator = \"SvShuntCompensatorSections.ShuntCompensator\";\n        final String attrResource = \"resource\";\n\n        SvShuntCompensatorSections svdata = new SvShuntCompensatorSections();\n        try (InputStream is = new ByteArrayInputStream(sv.getBytes(StandardCharsets.UTF_8))) {\n            XMLStreamReader reader = XMLInputFactory.newInstance().createXMLStreamReader(is);\n            Integer sections = null;\n            String shuntCompensatorId = null;\n            while (reader.hasNext()) {\n                int next = reader.next();\n                if (next == XMLStreamConstants.START_ELEMENT) {\n                    if (reader.getLocalName().equals(svShuntCompensatorSections)) {\n                        sections = null;\n                        shuntCompensatorId = null;\n                    } else if (reader.getLocalName().equals(svShuntCompensatorSectionsSections)) {\n                        String text = reader.getElementText();\n                        sections = Integer.parseInt(text);\n                    } else if (reader.getLocalName().equals(svShuntCompensatorSectionsShuntCompensator)) {\n                        shuntCompensatorId = reader.getAttributeValue(CgmesNamespace.RDF_NAMESPACE, attrResource).substring(2);\n                    }\n                } else if (next == XMLStreamConstants.END_ELEMENT) {\n                    if (reader.getLocalName().equals(svShuntCompensatorSections) && sections != null) {\n                        svdata.add(shuntCompensatorId, sections);\n                    }\n                }\n            }\n            reader.close();\n        } catch (XMLStreamException | IOException e) {\n            throw new RuntimeException(e);\n        }\n        return svdata;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "StateVariablesExportTest.java",
        "method_name": "readSvShuntCompensatorSections",
        "raw_code": "private static SvShuntCompensatorSections readSvShuntCompensatorSections(String sv) {\n        final String svShuntCompensatorSections = \"SvShuntCompensatorSections\";\n        final String svShuntCompensatorSectionsSections = \"SvShuntCompensatorSections.sections\";\n        final String svShuntCompensatorSectionsShuntCompensator = \"SvShuntCompensatorSections.ShuntCompensator\";\n        final String attrResource = \"resource\";\n\n        SvShuntCompensatorSections svdata = new SvShuntCompensatorSections();\n        try (InputStream is = new ByteArrayInputStream(sv.getBytes(StandardCharsets.UTF_8))) {\n            XMLStreamReader reader = getXMLInputFactory().createXMLStreamReader(is);\n            Integer sections = null;\n            String shuntCompensatorId = null;\n            while (reader.hasNext()) {\n                int next = reader.next();\n                if (next == XMLStreamConstants.START_ELEMENT) {\n                    if (reader.getLocalName().equals(svShuntCompensatorSections)) {\n                        sections = null;\n                        shuntCompensatorId = null;\n                    } else if (reader.getLocalName().equals(svShuntCompensatorSectionsSections)) {\n                        String text = reader.getElementText();\n                        sections = Integer.parseInt(text);\n                    } else if (reader.getLocalName().equals(svShuntCompensatorSectionsShuntCompensator)) {\n                        shuntCompensatorId = reader.getAttributeValue(CgmesNamespace.RDF_NAMESPACE, attrResource).substring(2);\n                    }\n                } else if (next == XMLStreamConstants.END_ELEMENT) {\n                    if (reader.getLocalName().equals(svShuntCompensatorSections) && sections != null) {\n                        svdata.add(shuntCompensatorId, sections);\n                    }\n                }\n            }\n            reader.close();\n        } catch (XMLStreamException | IOException e) {\n            throw new RuntimeException(e);\n        }\n        return svdata;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "StateVariablesExportTest.java",
        "method_name": "readFirstTopologicalIslandDescription",
        "raw_code": "private static String readFirstTopologicalIslandDescription(Path sv) {\n        String description = \"\";\n        boolean insideTopologicalIsland = false;\n        try (InputStream is = Files.newInputStream(sv)) {\n            XMLStreamReader reader = XMLInputFactory.newInstance().createXMLStreamReader(is);\n            while (reader.hasNext()) {\n                int token = reader.next();\n                if (token == XMLStreamConstants.START_ELEMENT) {\n                    // Retrieve the TopologicalIsland node\n                    if (reader.getLocalName().equals(CgmesNames.TOPOLOGICAL_ISLAND)) {\n                        insideTopologicalIsland = true;\n                    }\n                    if (insideTopologicalIsland && reader.getLocalName().equals(CgmesNames.IDENTIFIED_OBJECT_DESCRIPTION)) {\n                        description = reader.getElementText();\n                    }\n                } else if (token == XMLStreamConstants.END_ELEMENT && reader.getLocalName().equals(CgmesNames.TOPOLOGICAL_ISLAND)) {\n                    break;\n                }\n            }\n            reader.close();\n        } catch (IOException | XMLStreamException e) {\n            throw new RuntimeException(e);\n        }\n        return description;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "StateVariablesExportTest.java",
        "method_name": "readFirstTopologicalIslandDescription",
        "raw_code": "private static String readFirstTopologicalIslandDescription(Path sv) {\n        String description = \"\";\n        boolean insideTopologicalIsland = false;\n        try (InputStream is = Files.newInputStream(sv)) {\n            XMLStreamReader reader = getXMLInputFactory().createXMLStreamReader(is);\n            while (reader.hasNext()) {\n                int token = reader.next();\n                if (token == XMLStreamConstants.START_ELEMENT) {\n                    // Retrieve the TopologicalIsland node\n                    if (reader.getLocalName().equals(CgmesNames.TOPOLOGICAL_ISLAND)) {\n                        insideTopologicalIsland = true;\n                    }\n                    if (insideTopologicalIsland && reader.getLocalName().equals(CgmesNames.IDENTIFIED_OBJECT_DESCRIPTION)) {\n                        description = reader.getElementText();\n                    }\n                } else if (token == XMLStreamConstants.END_ELEMENT && reader.getLocalName().equals(CgmesNames.TOPOLOGICAL_ISLAND)) {\n                    break;\n                }\n            }\n            reader.close();\n        } catch (IOException | XMLStreamException e) {\n            throw new RuntimeException(e);\n        }\n        return description;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "StateVariablesExportTest.java",
        "method_name": "readSvTapSteps",
        "raw_code": "private static SvTapSteps readSvTapSteps(String sv) {\n        final String svTapStep = \"SvTapStep\";\n        final String svTapStepPosition = \"SvTapStep.position\";\n        final String svTapStepTapChanger = \"SvTapStep.TapChanger\";\n        final String attrResource = \"resource\";\n\n        SvTapSteps svTapSteps = new SvTapSteps();\n        try (InputStream is = new ByteArrayInputStream(sv.getBytes(StandardCharsets.UTF_8))) {\n            XMLStreamReader reader = XMLInputFactory.newInstance().createXMLStreamReader(is);\n            Integer position = null;\n            String tapChangerId = null;\n            while (reader.hasNext()) {\n                int next = reader.next();\n                if (next == XMLStreamConstants.START_ELEMENT) {\n                    if (reader.getLocalName().equals(svTapStep)) {\n                        position = null;\n                        tapChangerId = null;\n                    } else if (reader.getLocalName().equals(svTapStepPosition)) {\n                        String text = reader.getElementText();\n                        position = Integer.parseInt(text);\n                    } else if (reader.getLocalName().equals(svTapStepTapChanger)) {\n                        tapChangerId = reader.getAttributeValue(CgmesNamespace.RDF_NAMESPACE, attrResource).substring(2);\n                    }\n                } else if (next == XMLStreamConstants.END_ELEMENT) {\n                    if (reader.getLocalName().equals(svTapStep) && position != null) {\n                        svTapSteps.add(tapChangerId, position);\n                    }\n                }\n            }\n            reader.close();\n        } catch (XMLStreamException | IOException e) {\n            throw new RuntimeException(e);\n        }\n        return svTapSteps;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "StateVariablesExportTest.java",
        "method_name": "readSvTapSteps",
        "raw_code": "private static SvTapSteps readSvTapSteps(String sv) {\n        final String svTapStep = \"SvTapStep\";\n        final String svTapStepPosition = \"SvTapStep.position\";\n        final String svTapStepTapChanger = \"SvTapStep.TapChanger\";\n        final String attrResource = \"resource\";\n\n        SvTapSteps svTapSteps = new SvTapSteps();\n        try (InputStream is = new ByteArrayInputStream(sv.getBytes(StandardCharsets.UTF_8))) {\n            XMLStreamReader reader = getXMLInputFactory().createXMLStreamReader(is);\n            Integer position = null;\n            String tapChangerId = null;\n            while (reader.hasNext()) {\n                int next = reader.next();\n                if (next == XMLStreamConstants.START_ELEMENT) {\n                    if (reader.getLocalName().equals(svTapStep)) {\n                        position = null;\n                        tapChangerId = null;\n                    } else if (reader.getLocalName().equals(svTapStepPosition)) {\n                        String text = reader.getElementText();\n                        position = Integer.parseInt(text);\n                    } else if (reader.getLocalName().equals(svTapStepTapChanger)) {\n                        tapChangerId = reader.getAttributeValue(CgmesNamespace.RDF_NAMESPACE, attrResource).substring(2);\n                    }\n                } else if (next == XMLStreamConstants.END_ELEMENT) {\n                    if (reader.getLocalName().equals(svTapStep) && position != null) {\n                        svTapSteps.add(tapChangerId, position);\n                    }\n                }\n            }\n            reader.close();\n        } catch (XMLStreamException | IOException e) {\n            throw new RuntimeException(e);\n        }\n        return svTapSteps;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "TapChangerNeutralStepTest.java",
        "method_name": "readTapChangerNeutralSteps",
        "raw_code": "private static Map<String, Integer> readTapChangerNeutralSteps(Path eq) {\n        Map<String, Integer> map = new HashMap<>();\n        String tapChangerId = null;\n        Integer neutralStep = null;\n        try (InputStream is = Files.newInputStream(eq)) {\n            XMLStreamReader reader = XMLInputFactory.newInstance().createXMLStreamReader(is);\n            while (reader.hasNext()) {\n                int next = reader.next();\n                if (next == XMLStreamConstants.START_ELEMENT) {\n                    if (isTapChanger(reader.getLocalName())) {\n                        tapChangerId = reader.getAttributeValue(CgmesNamespace.RDF_NAMESPACE, ATTR_ID).substring(1);\n                    } else if (reader.getLocalName().equals(TAP_CHANGER_NEUTRAL_STEP)) {\n                        neutralStep = Integer.parseInt(reader.getElementText());\n                    }\n                } else if (next == XMLStreamConstants.END_ELEMENT) {\n                    if (isTapChanger(reader.getLocalName()) && tapChangerId != null && neutralStep != null) {\n                        map.put(tapChangerId, neutralStep);\n                    }\n                }\n            }\n            reader.close();\n        } catch (XMLStreamException | IOException e) {\n            throw new RuntimeException(e);\n        }\n        return map;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "TapChangerNeutralStepTest.java",
        "method_name": "readTapChangerNeutralSteps",
        "raw_code": "private static Map<String, Integer> readTapChangerNeutralSteps(Path eq) {\n        Map<String, Integer> map = new HashMap<>();\n        String tapChangerId = null;\n        Integer neutralStep = null;\n        try (InputStream is = Files.newInputStream(eq)) {\n            XMLStreamReader reader = getXMLInputFactory().createXMLStreamReader(is);\n            while (reader.hasNext()) {\n                int next = reader.next();\n                if (next == XMLStreamConstants.START_ELEMENT) {\n                    if (isTapChanger(reader.getLocalName())) {\n                        tapChangerId = reader.getAttributeValue(CgmesNamespace.RDF_NAMESPACE, ATTR_ID).substring(1);\n                    } else if (reader.getLocalName().equals(TAP_CHANGER_NEUTRAL_STEP)) {\n                        neutralStep = Integer.parseInt(reader.getElementText());\n                    }\n                } else if (next == XMLStreamConstants.END_ELEMENT) {\n                    if (isTapChanger(reader.getLocalName()) && tapChangerId != null && neutralStep != null) {\n                        map.put(tapChangerId, neutralStep);\n                    }\n                }\n            }\n            reader.close();\n        } catch (XMLStreamException | IOException e) {\n            throw new RuntimeException(e);\n        }\n        return map;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "ConversionUtil.java",
        "method_name": "xmlContains",
        "raw_code": "public static boolean xmlContains(InputStream is, String clazz, String ns, String attr, String expectedValue) {\n        try {\n            XMLStreamReader reader = XMLInputFactory.newInstance().createXMLStreamReader(is);\n            while (reader.hasNext()) {\n                if (reader.next() == XMLStreamConstants.START_ELEMENT && reader.getLocalName().equals(clazz)) {\n                    String actualValue = reader.getAttributeValue(ns, attr);\n                    if (expectedValue.equals(actualValue)) {\n                        reader.close();\n                        return true;\n                    }\n                }\n            }\n            reader.close();\n        } catch (XMLStreamException e) {\n            throw new RuntimeException(e);\n        }\n        return false;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ConversionUtil.java",
        "method_name": "xmlContains",
        "raw_code": "public static boolean xmlContains(InputStream is, String clazz, String ns, String attr, String expectedValue) {\n        try {\n            XMLStreamReader reader = getXMLInputFactory().createXMLStreamReader(is);\n            while (reader.hasNext()) {\n                if (reader.next() == XMLStreamConstants.START_ELEMENT && reader.getLocalName().equals(clazz)) {\n                    String actualValue = reader.getAttributeValue(ns, attr);\n                    if (expectedValue.equals(actualValue)) {\n                        reader.close();\n                        return true;\n                    }\n                }\n            }\n            reader.close();\n        } catch (XMLStreamException e) {\n            throw new RuntimeException(e);\n        }\n        return false;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "CgmesImport.java",
        "method_name": "separateByModelingAuthority",
        "raw_code": "private Set<ReadOnlyDataSource> separateByModelingAuthority() {\n            xmlInputFactory = XMLInputFactory.newInstance();\n            Map<String, List<String>> igmNames = new CgmesOnDataSource(dataSource).names().stream()\n                    // We consider IGMs only the modeling authorities that have an EQ file\n                    // The CGM SV should have the MA of the merging agent\n                    .filter(CgmesSubset.EQUIPMENT::isValidName)\n                    .map(name -> readModelingAuthority(name).map(ma -> Map.entry(ma, name)))\n                    .flatMap(Optional::stream)\n                    .collect(Collectors.toMap(Map.Entry::getKey, e -> new ArrayList<>(List.of(e.getValue()))));\n            if (!igmNames.isEmpty()) {\n                LOGGER.info(\"IGM EQ files identified by Modeling Authority:\");\n                igmNames.forEach((k, v) -> LOGGER.info(\"  {} {}\", k, v.get(0)));\n            }\n            // If we only have found one IGM there is no need to partition\n            if (igmNames.size() == 1) {\n                return Set.of(dataSource);\n            }\n            Set<String> shared = new HashSet<>();\n            new CgmesOnDataSource(dataSource).names().stream()\n                    // We read the modeling authorities present in the rest of instance files\n                    // and mark the instance name as linked to an IGM or as shared\n                    .filter(not(CgmesSubset.EQUIPMENT::isValidName))\n                    .filter(not(MultipleGridModelChecker::isBoundary))\n                    .forEach(name -> {\n                        Optional<String> ma = readModelingAuthority(name);\n                        if (ma.isPresent() && igmNames.containsKey(ma.get())) {\n                            igmNames.get(ma.get()).add(name);\n                        } else {\n                            shared.add(name);\n                        }\n                    });\n            // Build one data source for each IGM found\n            if (!igmNames.isEmpty()) {\n                LOGGER.info(\"IGM files identified by Modeling Authority:\");\n                igmNames.forEach((k, v) -> LOGGER.info(\"  {} {}\", k, String.join(\",\", v)));\n                if (!shared.isEmpty()) {\n                    LOGGER.info(\"Shared files:\");\n                    shared.forEach(name -> LOGGER.info(\"  {}\", name));\n                }\n                LOGGER.info(\"Boundaries:\");\n                try {\n                    dataSource.listNames(\".*\").stream().filter(MultipleGridModelChecker::isBoundary).forEach(name -> LOGGER.info(\"  {}\", name));\n                } catch (IOException e) {\n                    throw new PowsyblException(e);\n                }\n            }\n            return igmNames.keySet().stream()\n                    .map(ma -> new FilteredReadOnlyDataSource(dataSource,\n                            name -> isBoundary(name) || igmNames.get(ma).contains(name) || shared.contains(name)))\n                    .collect(Collectors.toSet());\n        }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "CgmesImport.java",
        "method_name": "separateByModelingAuthority",
        "raw_code": "private Set<ReadOnlyDataSource> separateByModelingAuthority() {\n            xmlInputFactory = getXMLInputFactory();\n            Map<String, List<String>> igmNames = new CgmesOnDataSource(dataSource).names().stream()\n                    // We consider IGMs only the modeling authorities that have an EQ file\n                    // The CGM SV should have the MA of the merging agent\n                    .filter(CgmesSubset.EQUIPMENT::isValidName)\n                    .map(name -> readModelingAuthority(name).map(ma -> Map.entry(ma, name)))\n                    .flatMap(Optional::stream)\n                    .collect(Collectors.toMap(Map.Entry::getKey, e -> new ArrayList<>(List.of(e.getValue()))));\n            if (!igmNames.isEmpty()) {\n                LOGGER.info(\"IGM EQ files identified by Modeling Authority:\");\n                igmNames.forEach((k, v) -> LOGGER.info(\"  {} {}\", k, v.get(0)));\n            }\n            // If we only have found one IGM there is no need to partition\n            if (igmNames.size() == 1) {\n                return Set.of(dataSource);\n            }\n            Set<String> shared = new HashSet<>();\n            new CgmesOnDataSource(dataSource).names().stream()\n                    // We read the modeling authorities present in the rest of instance files\n                    // and mark the instance name as linked to an IGM or as shared\n                    .filter(not(CgmesSubset.EQUIPMENT::isValidName))\n                    .filter(not(MultipleGridModelChecker::isBoundary))\n                    .forEach(name -> {\n                        Optional<String> ma = readModelingAuthority(name);\n                        if (ma.isPresent() && igmNames.containsKey(ma.get())) {\n                            igmNames.get(ma.get()).add(name);\n                        } else {\n                            shared.add(name);\n                        }\n                    });\n            // Build one data source for each IGM found\n            if (!igmNames.isEmpty()) {\n                LOGGER.info(\"IGM files identified by Modeling Authority:\");\n                igmNames.forEach((k, v) -> LOGGER.info(\"  {} {}\", k, String.join(\",\", v)));\n                if (!shared.isEmpty()) {\n                    LOGGER.info(\"Shared files:\");\n                    shared.forEach(name -> LOGGER.info(\"  {}\", name));\n                }\n                LOGGER.info(\"Boundaries:\");\n                try {\n                    dataSource.listNames(\".*\").stream().filter(MultipleGridModelChecker::isBoundary).forEach(name -> LOGGER.info(\"  {}\", name));\n                } catch (IOException e) {\n                    throw new PowsyblException(e);\n                }\n            }\n            return igmNames.keySet().stream()\n                    .map(ma -> new FilteredReadOnlyDataSource(dataSource,\n                            name -> isBoundary(name) || igmNames.get(ma).contains(name) || shared.contains(name)))\n                    .collect(Collectors.toSet());\n        }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "XmlUtilTest.java",
        "method_name": "readAttributes",
        "raw_code": "@Test\n    void readAttributes() throws XMLStreamException {\n        AtomicReference<Boolean> attrBoolBoxed = new AtomicReference<>(false);\n        AtomicBoolean attrBool = new AtomicBoolean(false);\n        AtomicReference<Integer> attrInteger = new AtomicReference<>(-1);\n        AtomicInteger attrInt = new AtomicInteger(-1);\n        AtomicReference<Double> attrDbl = new AtomicReference<>(0d);\n        AtomicReference<Float> attrFloat = new AtomicReference<>(0f);\n        try (StringReader reader = new StringReader(XML)) {\n            XMLStreamReader xmlReader = XMLInputFactory.newInstance().createXMLStreamReader(reader);\n            xmlReader.next();\n            try {\n                XmlUtil.readSubElements(xmlReader, elementName -> {\n                    if (\"b\".equals(elementName)) {\n                        attrBoolBoxed.set(XmlUtil.readBooleanAttribute(xmlReader, \"attrBool\"));\n                        attrBool.set(XmlUtil.readBooleanAttribute(xmlReader, \"attrBool\", false));\n                        attrInteger.set(XmlUtil.readIntegerAttribute(xmlReader, \"attrInt\"));\n                        attrInt.set(XmlUtil.readIntAttribute(xmlReader, \"attrInt\", -1));\n                        attrDbl.set(XmlUtil.readDoubleAttribute(xmlReader, \"attrDbl\", 0));\n                        attrFloat.set(XmlUtil.readFloatAttribute(xmlReader, \"attrFlt\", 0));\n                    }\n                });\n            } finally {\n                xmlReader.close();\n            }\n        }\n\n        assertTrue(attrBoolBoxed::get);\n        assertTrue(attrBool.get());\n        assertEquals(34, attrInteger.get());\n        assertEquals(34, attrInt.get());\n        assertEquals(2e-65, attrDbl.get(), 1e-80);\n        assertEquals(0.054864f, attrFloat.get(), 1e-15);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XmlUtilTest.java",
        "method_name": "readAttributes",
        "raw_code": "@Test\n    void readAttributes() throws XMLStreamException {\n        AtomicReference<Boolean> attrBoolBoxed = new AtomicReference<>(false);\n        AtomicBoolean attrBool = new AtomicBoolean(false);\n        AtomicReference<Integer> attrInteger = new AtomicReference<>(-1);\n        AtomicInteger attrInt = new AtomicInteger(-1);\n        AtomicReference<Double> attrDbl = new AtomicReference<>(0d);\n        AtomicReference<Float> attrFloat = new AtomicReference<>(0f);\n        try (StringReader reader = new StringReader(XML)) {\n            XMLStreamReader xmlReader = getXMLInputFactory().createXMLStreamReader(reader);\n            xmlReader.next();\n            try {\n                XmlUtil.readSubElements(xmlReader, elementName -> {\n                    if (\"b\".equals(elementName)) {\n                        attrBoolBoxed.set(XmlUtil.readBooleanAttribute(xmlReader, \"attrBool\"));\n                        attrBool.set(XmlUtil.readBooleanAttribute(xmlReader, \"attrBool\", false));\n                        attrInteger.set(XmlUtil.readIntegerAttribute(xmlReader, \"attrInt\"));\n                        attrInt.set(XmlUtil.readIntAttribute(xmlReader, \"attrInt\", -1));\n                        attrDbl.set(XmlUtil.readDoubleAttribute(xmlReader, \"attrDbl\", 0));\n                        attrFloat.set(XmlUtil.readFloatAttribute(xmlReader, \"attrFlt\", 0));\n                    }\n                });\n            } finally {\n                xmlReader.close();\n            }\n        }\n\n        assertTrue(attrBoolBoxed::get);\n        assertTrue(attrBool.get());\n        assertEquals(34, attrInteger.get());\n        assertEquals(34, attrInt.get());\n        assertEquals(2e-65, attrDbl.get(), 1e-80);\n        assertEquals(0.054864f, attrFloat.get(), 1e-15);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "XmlUtilTest.java",
        "method_name": "readUntilEndElementWithDepthTest",
        "raw_code": "@Test\n    void readUntilEndElementWithDepthTest() throws XMLStreamException {\n        Map<String, Integer> depths = new HashMap<>();\n        try (StringReader reader = new StringReader(XML)) {\n            XMLStreamReader xmlReader = XMLInputFactory.newInstance().createXMLStreamReader(reader);\n            xmlReader.next();\n            try {\n                XmlUtil.readSubElements(xmlReader, elementName -> {\n                    depths.put(elementName, 0);\n                    XmlUtil.readSubElements(xmlReader, elementName1 -> {\n                        depths.put(elementName1, 1);\n                        XmlUtil.skipSubElements(xmlReader);\n                    });\n                });\n            } finally {\n                xmlReader.close();\n            }\n        }\n        assertEquals(ImmutableMap.of(\"b\", 0, \"c\", 1, \"d\", 0), depths);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XmlUtilTest.java",
        "method_name": "readUntilEndElementWithDepthTest",
        "raw_code": "@Test\n    void readUntilEndElementWithDepthTest() throws XMLStreamException {\n        Map<String, Integer> depths = new HashMap<>();\n        try (StringReader reader = new StringReader(XML)) {\n            XMLStreamReader xmlReader = getXMLInputFactory().createXMLStreamReader(reader);\n            xmlReader.next();\n            try {\n                XmlUtil.readSubElements(xmlReader, elementName -> {\n                    depths.put(elementName, 0);\n                    XmlUtil.readSubElements(xmlReader, elementName1 -> {\n                        depths.put(elementName1, 1);\n                        XmlUtil.skipSubElements(xmlReader);\n                    });\n                });\n            } finally {\n                xmlReader.close();\n            }\n        }\n        assertEquals(ImmutableMap.of(\"b\", 0, \"c\", 1, \"d\", 0), depths);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "XmlUtilTest.java",
        "method_name": "nestedReadUntilEndElementWithDepthTest",
        "raw_code": "@Test\n    void nestedReadUntilEndElementWithDepthTest() throws XMLStreamException {\n        Map<String, Integer> depths = new HashMap<>();\n        try (StringReader reader = new StringReader(XML)) {\n            XMLStreamReader xmlReader = XMLInputFactory.newInstance().createXMLStreamReader(reader);\n            try {\n                xmlReader.next();\n                XmlUtil.readSubElements(xmlReader, elementName -> {\n                    depths.put(elementName, 0);\n                    // consume b and c\n                    if (elementName.equals(\"b\")) {\n                        XmlUtil.readSubElements(xmlReader, elementName1 -> {\n                            depths.put(elementName1, 1);\n                            XmlUtil.skipSubElements(xmlReader);\n                        });\n                    }\n                });\n            } finally {\n                xmlReader.close();\n            }\n        }\n        assertEquals(ImmutableMap.of(\"b\", 0, \"c\", 1, \"d\", 0), depths);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XmlUtilTest.java",
        "method_name": "nestedReadUntilEndElementWithDepthTest",
        "raw_code": "@Test\n    void nestedReadUntilEndElementWithDepthTest() throws XMLStreamException {\n        Map<String, Integer> depths = new HashMap<>();\n        try (StringReader reader = new StringReader(XML)) {\n            XMLStreamReader xmlReader = getXMLInputFactory().createXMLStreamReader(reader);\n            try {\n                xmlReader.next();\n                XmlUtil.readSubElements(xmlReader, elementName -> {\n                    depths.put(elementName, 0);\n                    // consume b and c\n                    if (elementName.equals(\"b\")) {\n                        XmlUtil.readSubElements(xmlReader, elementName1 -> {\n                            depths.put(elementName1, 1);\n                            XmlUtil.skipSubElements(xmlReader);\n                        });\n                    }\n                });\n            } finally {\n                xmlReader.close();\n            }\n        }\n        assertEquals(ImmutableMap.of(\"b\", 0, \"c\", 1, \"d\", 0), depths);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "XmlUtilTest.java",
        "method_name": "readUntilStartElementTest",
        "raw_code": "private void readUntilStartElementTest(String path, String expected) throws XMLStreamException {\n        try (StringReader reader = new StringReader(XML)) {\n            XMLStreamReader xmlReader = XMLInputFactory.newInstance().createXMLStreamReader(reader);\n            try {\n                XmlUtil.readUntilStartElement(path, xmlReader, elementName -> assertEquals(expected, xmlReader.getLocalName()));\n            } finally {\n                xmlReader.close();\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XmlUtilTest.java",
        "method_name": "readUntilStartElementTest",
        "raw_code": "private void readUntilStartElementTest(String path, String expected) throws XMLStreamException {\n        try (StringReader reader = new StringReader(XML)) {\n            XMLStreamReader xmlReader = getXMLInputFactory().createXMLStreamReader(reader);\n            try {\n                XmlUtil.readUntilStartElement(path, xmlReader, elementName -> assertEquals(expected, xmlReader.getLocalName()));\n            } finally {\n                xmlReader.close();\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "XmlUtilTest.java",
        "method_name": "readTextTest",
        "raw_code": "@Test\n    void readTextTest() throws XMLStreamException {\n        String xml = \"<a>hello</a>\";\n        try (StringReader reader = new StringReader(xml)) {\n            XMLStreamReader xmlReader = XMLInputFactory.newInstance().createXMLStreamReader(reader);\n            try {\n                String text = null;\n                while (xmlReader.hasNext()) {\n                    int next = xmlReader.next();\n                    if (next == XMLStreamConstants.START_ELEMENT && xmlReader.getLocalName().equals(\"a\")) {\n                        text = XmlUtil.readText(xmlReader);\n                    }\n                }\n                assertEquals(\"hello\", text);\n            } finally {\n                xmlReader.close();\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XmlUtilTest.java",
        "method_name": "readTextTest",
        "raw_code": "@Test\n    void readTextTest() throws XMLStreamException {\n        String xml = \"<a>hello</a>\";\n        try (StringReader reader = new StringReader(xml)) {\n            XMLStreamReader xmlReader = getXMLInputFactory().createXMLStreamReader(reader);\n            try {\n                String text = null;\n                while (xmlReader.hasNext()) {\n                    int next = xmlReader.next();\n                    if (next == XMLStreamConstants.START_ELEMENT && xmlReader.getLocalName().equals(\"a\")) {\n                        text = XmlUtil.readText(xmlReader);\n                    }\n                }\n                assertEquals(\"hello\", text);\n            } finally {\n                xmlReader.close();\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "XMLImporter.java",
        "method_name": "exists",
        "raw_code": "protected boolean exists(ReadOnlyDataSource dataSource, String ext) throws IOException {\n        try {\n            if (ext != null) {\n                try (InputStream is = dataSource.newInputStream(null, ext)) {\n                    // check the first root element is network and namespace is IIDM\n                    XMLStreamReader xmlsr = XML_INPUT_FACTORY_SUPPLIER.get().createXMLStreamReader(is);\n                    try {\n                        while (xmlsr.hasNext()) {\n                            int eventType = xmlsr.next();\n                            if (eventType == XMLStreamConstants.START_ELEMENT) {\n                                String name = xmlsr.getLocalName();\n                                String ns = xmlsr.getNamespaceURI();\n                                return NetworkSerDe.NETWORK_ROOT_ELEMENT_NAME.equals(name)\n                                        && (Stream.of(IidmVersion.values()).anyMatch(v -> v.getNamespaceURI().equals(ns))\n                                        || Stream.of(IidmVersion.values()).filter(v -> v.compareTo(IidmVersion.V_1_7) >= 0).anyMatch(v -> v.getNamespaceURI(false).equals(ns)));\n                            }\n                        }\n                    } finally {\n                        cleanClose(xmlsr);\n                    }\n                }\n            }\n            return false;\n        } catch (XMLStreamException e) {\n            // not a valid xml file\n            return false;\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XMLImporter.java",
        "method_name": "exists",
        "raw_code": "protected boolean exists(ReadOnlyDataSource dataSource, String ext) throws IOException {\n        try {\n            if (ext != null) {\n                try (InputStream is = dataSource.newInputStream(null, ext)) {\n                    // check the first root element is network and namespace is IIDM\n                    XMLStreamReader xmlsr = getXMLInputFactory().createXMLStreamReader(is);\n                    try {\n                        while (xmlsr.hasNext()) {\n                            int eventType = xmlsr.next();\n                            if (eventType == XMLStreamConstants.START_ELEMENT) {\n                                String name = xmlsr.getLocalName();\n                                String ns = xmlsr.getNamespaceURI();\n                                return NetworkSerDe.NETWORK_ROOT_ELEMENT_NAME.equals(name)\n                                        && (Stream.of(IidmVersion.values()).anyMatch(v -> v.getNamespaceURI().equals(ns))\n                                        || Stream.of(IidmVersion.values()).filter(v -> v.compareTo(IidmVersion.V_1_7) >= 0).anyMatch(v -> v.getNamespaceURI(false).equals(ns)));\n                            }\n                        }\n                    } finally {\n                        cleanClose(xmlsr);\n                    }\n                }\n            }\n            return false;\n        } catch (XMLStreamException e) {\n            // not a valid xml file\n            return false;\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "XMLImporter.java",
        "method_name": "cleanClose",
        "raw_code": "private void cleanClose(XMLStreamReader xmlStreamReader) {\n        try {\n            xmlStreamReader.close();\n            XmlUtil.gcXmlInputFactory(XML_INPUT_FACTORY_SUPPLIER.get());\n        } catch (XMLStreamException e) {\n            LOGGER.error(e.toString(), e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XMLImporter.java",
        "method_name": "cleanClose",
        "raw_code": "private void cleanClose(XMLStreamReader xmlStreamReader) {\n        try {\n            xmlStreamReader.close();\n            XmlUtil.gcXmlInputFactory(getXMLInputFactory());\n        } catch (XMLStreamException e) {\n            LOGGER.error(e.toString(), e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "XmlReader.java",
        "method_name": "close",
        "raw_code": "@Override\n    public void close() {\n        try {\n            reader.close();\n            XmlUtil.gcXmlInputFactory(XML_INPUT_FACTORY_SUPPLIER.get());\n        } catch (XMLStreamException e) {\n            throw new UncheckedXmlStreamException(e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XmlReader.java",
        "method_name": "close",
        "raw_code": "@Override\n    public void close() {\n        try {\n            reader.close();\n            XmlUtil.gcXmlInputFactory(getXMLInputFactory());\n        } catch (XMLStreamException e) {\n            throw new UncheckedXmlStreamException(e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "CommonGridModelExportTest.java",
        "method_name": "readVersion",
        "raw_code": "private static Optional<Integer> readVersion(InputStream is) {\n        try {\n            XMLStreamReader reader = XMLInputFactory.newInstance().createXMLStreamReader(is);\n            while (reader.hasNext()) {\n                int next = reader.next();\n                if (next == XMLStreamConstants.START_ELEMENT && reader.getLocalName().equals(\"Model.version\")) {\n                    String version = reader.getElementText();\n                    reader.close();\n                    return Optional.of(Integer.parseInt(version));\n                }\n            }\n            reader.close();\n        } catch (XMLStreamException e) {\n            throw new RuntimeException(e);\n        }\n        return Optional.empty();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "CommonGridModelExportTest.java",
        "method_name": "readVersion",
        "raw_code": "private static Optional<Integer> readVersion(InputStream is) {\n        try {\n            XMLStreamReader reader = getXMLInputFactory().createXMLStreamReader(is);\n            while (reader.hasNext()) {\n                int next = reader.next();\n                if (next == XMLStreamConstants.START_ELEMENT && reader.getLocalName().equals(\"Model.version\")) {\n                    String version = reader.getElementText();\n                    reader.close();\n                    return Optional.of(Integer.parseInt(version));\n                }\n            }\n            reader.close();\n        } catch (XMLStreamException e) {\n            throw new RuntimeException(e);\n        }\n        return Optional.empty();\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "CommonGridModelExportTest.java",
        "method_name": "readId",
        "raw_code": "private static String readId(InputStream is) {\n        try {\n            XMLStreamReader reader = XMLInputFactory.newInstance().createXMLStreamReader(is);\n            while (reader.hasNext()) {\n                int next = reader.next();\n                if (next == XMLStreamConstants.START_ELEMENT && reader.getLocalName().equals(\"FullModel\")) {\n                    String id = reader.getAttributeValue(CgmesNamespace.RDF_NAMESPACE, \"about\");\n                    reader.close();\n                    return id;\n                }\n            }\n            reader.close();\n        } catch (XMLStreamException e) {\n            throw new RuntimeException(e);\n        }\n        return null;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "CommonGridModelExportTest.java",
        "method_name": "readId",
        "raw_code": "private static String readId(InputStream is) {\n        try {\n            XMLStreamReader reader = getXMLInputFactory().createXMLStreamReader(is);\n            while (reader.hasNext()) {\n                int next = reader.next();\n                if (next == XMLStreamConstants.START_ELEMENT && reader.getLocalName().equals(\"FullModel\")) {\n                    String id = reader.getAttributeValue(CgmesNamespace.RDF_NAMESPACE, \"about\");\n                    reader.close();\n                    return id;\n                }\n            }\n            reader.close();\n        } catch (XMLStreamException e) {\n            throw new RuntimeException(e);\n        }\n        return null;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "FullModel.java",
        "method_name": "parse",
        "raw_code": "public static FullModel parse(Reader reader) {\n        Objects.requireNonNull(reader);\n        ParsingContext context = new ParsingContext();\n        try {\n            XMLStreamReader xmlReader = XML_INPUT_FACTORY_SUPPLIER.get().createXMLStreamReader(reader);\n            try {\n                XmlUtil.readUntilStartElement(new String[] {\"/\", CgmesNames.RDF, CgmesNames.FULL_MODEL}, xmlReader, elementName1 -> {\n                    context.id = xmlReader.getAttributeValue(CgmesNamespace.RDF_NAMESPACE, CgmesNames.ABOUT);\n                    XmlUtil.readSubElements(xmlReader, subElementName -> readSubElement(subElementName, context, xmlReader));\n                });\n            } finally {\n                xmlReader.close();\n                XmlUtil.gcXmlInputFactory(XML_INPUT_FACTORY_SUPPLIER.get());\n            }\n        } catch (XMLStreamException e) {\n            throw new UncheckedXmlStreamException(e);\n        }\n        // the other attributes are checked in the constructor\n        if (context.version == null) {\n            throw new PowsyblException(\"Version is missing\");\n        }\n        return new FullModel(context.id, context.scenarioTime, context.created, context.description, context.version,\n                             context.profiles, context.dependentOn, context.supersedes, context.modelingAuthoritySet);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FullModel.java",
        "method_name": "parse",
        "raw_code": "public static FullModel parse(Reader reader) {\n        Objects.requireNonNull(reader);\n        ParsingContext context = new ParsingContext();\n        try {\n            XMLStreamReader xmlReader = getXMLInputFactory().createXMLStreamReader(reader);\n            try {\n                XmlUtil.readUntilStartElement(new String[] {\"/\", CgmesNames.RDF, CgmesNames.FULL_MODEL}, xmlReader, elementName1 -> {\n                    context.id = xmlReader.getAttributeValue(CgmesNamespace.RDF_NAMESPACE, CgmesNames.ABOUT);\n                    XmlUtil.readSubElements(xmlReader, subElementName -> readSubElement(subElementName, context, xmlReader));\n                });\n            } finally {\n                xmlReader.close();\n                XmlUtil.gcXmlInputFactory(getXMLInputFactory());\n            }\n        } catch (XMLStreamException e) {\n            throw new UncheckedXmlStreamException(e);\n        }\n        // the other attributes are checked in the constructor\n        if (context.version == null) {\n            throw new PowsyblException(\"Version is missing\");\n        }\n        return new FullModel(context.id, context.scenarioTime, context.created, context.description, context.version,\n                             context.profiles, context.dependentOn, context.supersedes, context.modelingAuthoritySet);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "NamespaceReader.java",
        "method_name": "namespaces1",
        "raw_code": "private static Set<String> namespaces1(InputStream is) throws XMLStreamException {\n        Set<String> found = new HashSet<>();\n        XMLStreamReader xmlsr = XML_INPUT_FACTORY_SUPPLIER.get().createXMLStreamReader(is);\n        try {\n            boolean root = false;\n            while (xmlsr.hasNext() && !root) {\n                int eventType = xmlsr.next();\n                if (eventType == XMLStreamConstants.START_ELEMENT) {\n                    root = true;\n                    for (int k = 0; k < xmlsr.getNamespaceCount(); k++) {\n                        found.add(xmlsr.getNamespaceURI(k));\n                    }\n                }\n            }\n        } finally {\n            xmlsr.close();\n            XmlUtil.gcXmlInputFactory(XML_INPUT_FACTORY_SUPPLIER.get());\n        }\n        return found;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "NamespaceReader.java",
        "method_name": "namespaces1",
        "raw_code": "private static Set<String> namespaces1(InputStream is) throws XMLStreamException {\n        Set<String> found = new HashSet<>();\n        XMLStreamReader xmlsr = getXMLInputFactory().createXMLStreamReader(is);\n        try {\n            boolean root = false;\n            while (xmlsr.hasNext() && !root) {\n                int eventType = xmlsr.next();\n                if (eventType == XMLStreamConstants.START_ELEMENT) {\n                    root = true;\n                    for (int k = 0; k < xmlsr.getNamespaceCount(); k++) {\n                        found.add(xmlsr.getNamespaceURI(k));\n                    }\n                }\n            }\n        } finally {\n            xmlsr.close();\n            XmlUtil.gcXmlInputFactory(getXMLInputFactory());\n        }\n        return found;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "NamespaceReader.java",
        "method_name": "base",
        "raw_code": "public static String base(InputStream is) {\n        XMLStreamReader xmlsr;\n        try {\n            xmlsr = XML_INPUT_FACTORY_SUPPLIER.get().createXMLStreamReader(is);\n            try {\n                while (xmlsr.hasNext()) {\n                    int eventType = xmlsr.next();\n                    if (eventType == XMLStreamConstants.START_ELEMENT) {\n                        return xmlsr.getAttributeValue(null, \"base\");\n                    }\n                }\n            } finally {\n                xmlsr.close();\n                XmlUtil.gcXmlInputFactory(XML_INPUT_FACTORY_SUPPLIER.get());\n            }\n            return null;\n        } catch (XMLStreamException e) {\n            throw new CgmesModelException(\"base\", e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "NamespaceReader.java",
        "method_name": "base",
        "raw_code": "public static String base(InputStream is) {\n        XMLStreamReader xmlsr;\n        try {\n            xmlsr = getXMLInputFactory().createXMLStreamReader(is);\n            try {\n                while (xmlsr.hasNext()) {\n                    int eventType = xmlsr.next();\n                    if (eventType == XMLStreamConstants.START_ELEMENT) {\n                        return xmlsr.getAttributeValue(null, \"base\");\n                    }\n                }\n            } finally {\n                xmlsr.close();\n                XmlUtil.gcXmlInputFactory(getXMLInputFactory());\n            }\n            return null;\n        } catch (XMLStreamException e) {\n            throw new CgmesModelException(\"base\", e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "CgmesExportTest.java",
        "method_name": "xmlFileContainsRegulatingControl",
        "raw_code": "private static boolean xmlFileContainsRegulatingControl(String expectedRdfIdAttributeValue, String rdfIdAttributeName, Path file) throws IOException, XMLStreamException {\n        try (InputStream is = Files.newInputStream(file)) {\n            XMLStreamReader reader = XMLInputFactory.newInstance().createXMLStreamReader(is);\n            while (reader.hasNext()) {\n                if (reader.next() == XMLStreamConstants.START_ELEMENT && reader.getLocalName().equals(\"TapChangerControl\")) {\n                    String id = reader.getAttributeValue(CgmesNamespace.RDF_NAMESPACE, rdfIdAttributeName);\n                    if (expectedRdfIdAttributeValue.equals(id)) {\n                        reader.close();\n                        return true;\n                    }\n                }\n            }\n            reader.close();\n        }\n        return false;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "CgmesExportTest.java",
        "method_name": "xmlFileContainsRegulatingControl",
        "raw_code": "private static boolean xmlFileContainsRegulatingControl(String expectedRdfIdAttributeValue, String rdfIdAttributeName, Path file) throws IOException, XMLStreamException {\n        try (InputStream is = Files.newInputStream(file)) {\n            XMLStreamReader reader = getXMLInputFactory().createXMLStreamReader(is);\n            while (reader.hasNext()) {\n                if (reader.next() == XMLStreamConstants.START_ELEMENT && reader.getLocalName().equals(\"TapChangerControl\")) {\n                    String id = reader.getAttributeValue(CgmesNamespace.RDF_NAMESPACE, rdfIdAttributeName);\n                    if (expectedRdfIdAttributeValue.equals(id)) {\n                        reader.close();\n                        return true;\n                    }\n                }\n            }\n            reader.close();\n        }\n        return false;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "PropertiesModuleConfigRepository.java",
        "method_name": "writeXml",
        "raw_code": "public static void writeXml(Path configDir, Path xmlFile) throws IOException, XMLStreamException {\n        XMLOutputFactory output = XMLOutputFactory.newInstance();\n        try (Writer writer = Files.newBufferedWriter(xmlFile, StandardCharsets.UTF_8)) {\n            XMLStreamWriter xmlWriter = output.createXMLStreamWriter(writer);\n            try {\n                xmlWriter.writeStartDocument(StandardCharsets.UTF_8.toString(), \"1.0\");\n                xmlWriter.writeStartElement(\"config\");\n                try (DirectoryStream<Path> ds = Files.newDirectoryStream(configDir, entry -> Files.isRegularFile(entry) && entry.getFileName().toString().endsWith(\".properties\"))) {\n                    for (Path file : ds) {\n                        String fileName = file.getFileName().toString();\n                        String fileNameWithoutExtension = fileName.substring(0, fileName.length() - 11);\n                        xmlWriter.writeStartElement(fileNameWithoutExtension);\n                        Properties properties = new Properties();\n                        try (Reader reader = Files.newBufferedReader(file, StandardCharsets.UTF_8)) {\n                            properties.load(reader);\n                        }\n                        for (String name : properties.stringPropertyNames()) {\n                            String value = properties.getProperty(name);\n                            xmlWriter.writeStartElement(name);\n                            xmlWriter.writeCharacters(value);\n                            xmlWriter.writeEndElement();\n                        }\n                        xmlWriter.writeEndElement();\n                    }\n                }\n                xmlWriter.writeEndElement();\n                xmlWriter.writeEndDocument();\n            } finally {\n                xmlWriter.close();\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "PropertiesModuleConfigRepository.java",
        "method_name": "writeXml",
        "raw_code": "public static void writeXml(Path configDir, Path xmlFile) throws IOException, XMLStreamException {\n        XMLOutputFactory output = getXMLOutputFactory();\n        try (Writer writer = Files.newBufferedWriter(xmlFile, StandardCharsets.UTF_8)) {\n            XMLStreamWriter xmlWriter = output.createXMLStreamWriter(writer);\n            try {\n                xmlWriter.writeStartDocument(StandardCharsets.UTF_8.toString(), \"1.0\");\n                xmlWriter.writeStartElement(\"config\");\n                try (DirectoryStream<Path> ds = Files.newDirectoryStream(configDir, entry -> Files.isRegularFile(entry) && entry.getFileName().toString().endsWith(\".properties\"))) {\n                    for (Path file : ds) {\n                        String fileName = file.getFileName().toString();\n                        String fileNameWithoutExtension = fileName.substring(0, fileName.length() - 11);\n                        xmlWriter.writeStartElement(fileNameWithoutExtension);\n                        Properties properties = new Properties();\n                        try (Reader reader = Files.newBufferedReader(file, StandardCharsets.UTF_8)) {\n                            properties.load(reader);\n                        }\n                        for (String name : properties.stringPropertyNames()) {\n                            String value = properties.getProperty(name);\n                            xmlWriter.writeStartElement(name);\n                            xmlWriter.writeCharacters(value);\n                            xmlWriter.writeEndElement();\n                        }\n                        xmlWriter.writeEndElement();\n                    }\n                }\n                xmlWriter.writeEndElement();\n                xmlWriter.writeEndDocument();\n            } finally {\n                xmlWriter.close();\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "SteadyStateHypothesisExportTest.java",
        "method_name": "readSshLinearShuntCompensator",
        "raw_code": "private static SshLinearShuntCompensators readSshLinearShuntCompensator(String ssh) {\n        final String sshLinearShuntCompensator = \"LinearShuntCompensator\";\n        final String sshLinearShuntCompensatorSections = \"ShuntCompensator.sections\";\n        final String sshLinearShuntCompensatorControlEnabled = \"RegulatingCondEq.controlEnabled\";\n        final String attrAbout = \"about\";\n\n        SshLinearShuntCompensators sshLinearShuntCompensators = new SshLinearShuntCompensators();\n        try (InputStream is = new ByteArrayInputStream(ssh.getBytes(StandardCharsets.UTF_8))) {\n            XMLStreamReader reader = XMLInputFactory.newInstance().createXMLStreamReader(is);\n            Integer sections = null;\n            Boolean controlEnabled = null;\n            String shuntCompensatorId = null;\n            while (reader.hasNext()) {\n                int next = reader.next();\n                if (next == XMLStreamConstants.START_ELEMENT) {\n                    if (reader.getLocalName().equals(sshLinearShuntCompensator)) {\n                        sections = null;\n                        controlEnabled = null;\n                        shuntCompensatorId = reader.getAttributeValue(CgmesNamespace.RDF_NAMESPACE, attrAbout).substring(2);\n                    } else if (reader.getLocalName().equals(sshLinearShuntCompensatorSections)) {\n                        String text = reader.getElementText();\n                        sections = Integer.parseInt(text);\n                    } else if (reader.getLocalName().equals(sshLinearShuntCompensatorControlEnabled)) {\n                        String text = reader.getElementText();\n                        controlEnabled = Boolean.valueOf(text);\n                    }\n                } else if (next == XMLStreamConstants.END_ELEMENT) {\n                    if (reader.getLocalName().equals(sshLinearShuntCompensator) && sections != null && controlEnabled != null) {\n                        sshLinearShuntCompensators.add(shuntCompensatorId, sections, controlEnabled);\n                    }\n                }\n            }\n            reader.close();\n        } catch (XMLStreamException | IOException e) {\n            throw new RuntimeException(e);\n        }\n        return sshLinearShuntCompensators;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SteadyStateHypothesisExportTest.java",
        "method_name": "readSshLinearShuntCompensator",
        "raw_code": "private static SshLinearShuntCompensators readSshLinearShuntCompensator(String ssh) {\n        final String sshLinearShuntCompensator = \"LinearShuntCompensator\";\n        final String sshLinearShuntCompensatorSections = \"ShuntCompensator.sections\";\n        final String sshLinearShuntCompensatorControlEnabled = \"RegulatingCondEq.controlEnabled\";\n        final String attrAbout = \"about\";\n\n        SshLinearShuntCompensators sshLinearShuntCompensators = new SshLinearShuntCompensators();\n        try (InputStream is = new ByteArrayInputStream(ssh.getBytes(StandardCharsets.UTF_8))) {\n            XMLStreamReader reader = getXMLInputFactory().createXMLStreamReader(is);\n            Integer sections = null;\n            Boolean controlEnabled = null;\n            String shuntCompensatorId = null;\n            while (reader.hasNext()) {\n                int next = reader.next();\n                if (next == XMLStreamConstants.START_ELEMENT) {\n                    if (reader.getLocalName().equals(sshLinearShuntCompensator)) {\n                        sections = null;\n                        controlEnabled = null;\n                        shuntCompensatorId = reader.getAttributeValue(CgmesNamespace.RDF_NAMESPACE, attrAbout).substring(2);\n                    } else if (reader.getLocalName().equals(sshLinearShuntCompensatorSections)) {\n                        String text = reader.getElementText();\n                        sections = Integer.parseInt(text);\n                    } else if (reader.getLocalName().equals(sshLinearShuntCompensatorControlEnabled)) {\n                        String text = reader.getElementText();\n                        controlEnabled = Boolean.valueOf(text);\n                    }\n                } else if (next == XMLStreamConstants.END_ELEMENT) {\n                    if (reader.getLocalName().equals(sshLinearShuntCompensator) && sections != null && controlEnabled != null) {\n                        sshLinearShuntCompensators.add(shuntCompensatorId, sections, controlEnabled);\n                    }\n                }\n            }\n            reader.close();\n        } catch (XMLStreamException | IOException e) {\n            throw new RuntimeException(e);\n        }\n        return sshLinearShuntCompensators;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47293",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
    "short_hash": "e6c7c499",
    "vulnerableMethods_before": [
      {
        "filename": "SteadyStateHypothesisExportTest.java",
        "method_name": "readSshControlAreas",
        "raw_code": "private static Collection<SshExportedControlArea> readSshControlAreas(Path ssh) {\n        List<SshExportedControlArea> sshExportedControlAreas = new ArrayList<>();\n        SshExportedControlArea sshExportedControlArea = null;\n        try (InputStream is = Files.newInputStream(ssh)) {\n            XMLStreamReader reader = XMLInputFactory.newInstance().createXMLStreamReader(is);\n            while (reader.hasNext()) {\n                int next = reader.next();\n                if (next == XMLStreamConstants.START_ELEMENT) {\n                    if (reader.getLocalName().equals(CONTROL_AREA)) {\n                        sshExportedControlArea = new SshExportedControlArea();\n                        sshExportedControlArea.id = reader.getAttributeValue(CgmesNamespace.RDF_NAMESPACE, ATTR_ABOUT).substring(2);\n                    } else if (reader.getLocalName().equals(CONTROL_AREA_NET_INTERCHANGE) && sshExportedControlArea != null) {\n                        sshExportedControlArea.netInterchange = Double.parseDouble(reader.getElementText());\n                    } else if (reader.getLocalName().equals(CONTROL_AREA_P_TOLERANCE) && sshExportedControlArea != null) {\n                        sshExportedControlArea.pTolerance = Double.parseDouble(reader.getElementText());\n                    }\n                } else if (next == XMLStreamConstants.END_ELEMENT) {\n                    if (reader.getLocalName().equals(CONTROL_AREA) && sshExportedControlArea != null) {\n                        sshExportedControlAreas.add(sshExportedControlArea);\n                        sshExportedControlArea = null;\n                    }\n                }\n            }\n            reader.close();\n        } catch (XMLStreamException | IOException e) {\n            throw new RuntimeException(e);\n        }\n        return sshExportedControlAreas;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SteadyStateHypothesisExportTest.java",
        "method_name": "readSshControlAreas",
        "raw_code": "private static Collection<SshExportedControlArea> readSshControlAreas(Path ssh) {\n        List<SshExportedControlArea> sshExportedControlAreas = new ArrayList<>();\n        SshExportedControlArea sshExportedControlArea = null;\n        try (InputStream is = Files.newInputStream(ssh)) {\n            XMLStreamReader reader = getXMLInputFactory().createXMLStreamReader(is);\n            while (reader.hasNext()) {\n                int next = reader.next();\n                if (next == XMLStreamConstants.START_ELEMENT) {\n                    if (reader.getLocalName().equals(CONTROL_AREA)) {\n                        sshExportedControlArea = new SshExportedControlArea();\n                        sshExportedControlArea.id = reader.getAttributeValue(CgmesNamespace.RDF_NAMESPACE, ATTR_ABOUT).substring(2);\n                    } else if (reader.getLocalName().equals(CONTROL_AREA_NET_INTERCHANGE) && sshExportedControlArea != null) {\n                        sshExportedControlArea.netInterchange = Double.parseDouble(reader.getElementText());\n                    } else if (reader.getLocalName().equals(CONTROL_AREA_P_TOLERANCE) && sshExportedControlArea != null) {\n                        sshExportedControlArea.pTolerance = Double.parseDouble(reader.getElementText());\n                    }\n                } else if (next == XMLStreamConstants.END_ELEMENT) {\n                    if (reader.getLocalName().equals(CONTROL_AREA) && sshExportedControlArea != null) {\n                        sshExportedControlAreas.add(sshExportedControlArea);\n                        sshExportedControlArea = null;\n                    }\n                }\n            }\n            reader.close();\n        } catch (XMLStreamException | IOException e) {\n            throw new RuntimeException(e);\n        }\n        return sshExportedControlAreas;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "powsybl-core",
    "cve_id": "CVE-2025-47771",
    "cwe_list": [
      "CWE-502"
    ],
    "commit_hash": "8ed16ce41683c4aef5f6aa1dd5ae8642aa5ed2bd",
    "short_hash": "8ed16ce4",
    "vulnerableMethods_before": [
      {
        "filename": "SparseMatrix.java",
        "method_name": "read",
        "raw_code": "public static SparseMatrix read(InputStream inputStream) {\n        Objects.requireNonNull(inputStream);\n        try (ObjectInputStream objectInputStream = new ObjectInputStream(inputStream)) {\n            return (SparseMatrix) objectInputStream.readObject();\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        } catch (ClassNotFoundException e) {\n            throw new UncheckedClassNotFoundException(e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SparseMatrix.java",
        "method_name": "read",
        "raw_code": "public static SparseMatrix read(InputStream inputStream) {\n        Objects.requireNonNull(inputStream);\n        try (ObjectInputStream objectInputStream = new ObjectInputStream(inputStream)) {\n            // Check that the object to deserialize is really a SparseMatrix.\n            // This check is done prior to its complete deserialization to prevent security problems (RCE).\n            // - Check that all non-null encountered classes are among the accepted ones (the one composing a SparseMatrix).\n            ObjectInputFilter allowedClassesFilter = ObjectInputFilter.allowFilter(ALLOWED_CLASSES::contains, ObjectInputFilter.Status.REJECTED);\n            objectInputStream.setObjectInputFilter(allowedClassesFilter);\n            return (SparseMatrix) objectInputStream.readObject();\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        } catch (ClassNotFoundException e) {\n            throw new UncheckedClassNotFoundException(e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "allure2",
    "cve_id": "CVE-2025-52888",
    "cwe_list": [
      "CWE-611"
    ],
    "commit_hash": "cbcb33719851ff70adce85d38e15d20fc58d4eb7",
    "short_hash": "cbcb3371",
    "vulnerableMethods_before": [
      {
        "filename": "XunitXmlPlugin.java",
        "method_name": "parseAssemblies",
        "raw_code": "private void parseAssemblies(final Path parsedFile, final RandomUidContext context, final ResultsVisitor visitor) {\n        try {\n            LOGGER.debug(\"Parsing file {}\", parsedFile);\n            final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            final DocumentBuilder builder = factory.newDocumentBuilder();\n            final Document document = builder.parse(parsedFile.toFile());\n            final XmlElement assembliesElement = new XmlElement(document.getDocumentElement());\n            final String elementName = assembliesElement.getName();\n            if (!ASSEMBLIES_ELEMENT_NAME.equals(elementName)) {\n                LOGGER.debug(\"{} is not a valid XUnit xml file. Unknown root element {}\", parsedFile, elementName);\n                return;\n            }\n\n            assembliesElement.get(ASSEMBLY_ELEMENT_NAME)\n                    .forEach(element -> parseAssembly(element, context, visitor));\n        } catch (SAXException | ParserConfigurationException | IOException e) {\n            LOGGER.error(\"Could not parse file {}: {}\", parsedFile, e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XunitXmlPlugin.java",
        "method_name": "parseAssemblies",
        "raw_code": "private void parseAssemblies(final Path parsedFile, final RandomUidContext context, final ResultsVisitor visitor) {\n        try {\n            LOGGER.debug(\"Parsing file {}\", parsedFile);\n            final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            final DocumentBuilder builder = factory.newDocumentBuilder();\n            builder.setEntityResolver(new ClasspathEntityResolver());\n            final Document document = builder.parse(parsedFile.toFile());\n            final XmlElement assembliesElement = new XmlElement(document.getDocumentElement());\n            final String elementName = assembliesElement.getName();\n            if (!ASSEMBLIES_ELEMENT_NAME.equals(elementName)) {\n                LOGGER.debug(\"{} is not a valid XUnit xml file. Unknown root element {}\", parsedFile, elementName);\n                return;\n            }\n\n            assembliesElement.get(ASSEMBLY_ELEMENT_NAME)\n                    .forEach(element -> parseAssembly(element, context, visitor));\n        } catch (SAXException | ParserConfigurationException | IOException e) {\n            LOGGER.error(\"Could not parse file {}: {}\", parsedFile, e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "allure2",
    "cve_id": "CVE-2025-52888",
    "cwe_list": [
      "CWE-611"
    ],
    "commit_hash": "cbcb33719851ff70adce85d38e15d20fc58d4eb7",
    "short_hash": "cbcb3371",
    "vulnerableMethods_before": [
      {
        "filename": "TrxPlugin.java",
        "method_name": "parseTestRun",
        "raw_code": "protected void parseTestRun(final Path parsedFile, final RandomUidContext context, final ResultsVisitor visitor) {\n        try {\n            LOGGER.debug(\"Parsing file {}\", parsedFile);\n\n            final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            final DocumentBuilder builder = factory.newDocumentBuilder();\n            final Document document = builder.parse(parsedFile.toFile());\n            final XmlElement testRunElement = new XmlElement(document.getDocumentElement());\n            final String elementName = testRunElement.getName();\n            if (!TEST_RUN_ELEMENT_NAME.equals(elementName)) {\n                LOGGER.debug(\"{} is not a valid TRX file. Unknown root element {}\", parsedFile, elementName);\n                return;\n            }\n            final Map<String, UnitTest> tests = new HashMap<>();\n            testRunElement.getFirst(TEST_DEFINITIONS_ELEMENT)\n                    .ifPresent(testDefinitions -> {\n                        testDefinitions.get(UNIT_TEST_ELEMENT).forEach(unitTestElement -> {\n                            final UnitTest unitTest = parseUnitTest(unitTestElement);\n                            tests.put(unitTest.getExecutionId(), unitTest);\n                        });\n                    });\n            testRunElement.getFirst(RESULTS_ELEMENT_NAME)\n                    .ifPresent(resultsElement -> parseResults(resultsElement, tests, context, visitor));\n        } catch (SAXException | ParserConfigurationException | IOException e) {\n            LOGGER.error(\"Could not parse file {}\", parsedFile, e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "TrxPlugin.java",
        "method_name": "parseTestRun",
        "raw_code": "protected void parseTestRun(final Path parsedFile, final RandomUidContext context, final ResultsVisitor visitor) {\n        try {\n            LOGGER.debug(\"Parsing file {}\", parsedFile);\n\n            final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            final DocumentBuilder builder = factory.newDocumentBuilder();\n            builder.setEntityResolver(new ClasspathEntityResolver());\n            final Document document = builder.parse(parsedFile.toFile());\n            final XmlElement testRunElement = new XmlElement(document.getDocumentElement());\n            final String elementName = testRunElement.getName();\n            if (!TEST_RUN_ELEMENT_NAME.equals(elementName)) {\n                LOGGER.debug(\"{} is not a valid TRX file. Unknown root element {}\", parsedFile, elementName);\n                return;\n            }\n            final Map<String, UnitTest> tests = new HashMap<>();\n            testRunElement.getFirst(TEST_DEFINITIONS_ELEMENT)\n                    .ifPresent(testDefinitions -> {\n                        testDefinitions.get(UNIT_TEST_ELEMENT).forEach(unitTestElement -> {\n                            final UnitTest unitTest = parseUnitTest(unitTestElement);\n                            tests.put(unitTest.getExecutionId(), unitTest);\n                        });\n                    });\n            testRunElement.getFirst(RESULTS_ELEMENT_NAME)\n                    .ifPresent(resultsElement -> parseResults(resultsElement, tests, context, visitor));\n        } catch (SAXException | ParserConfigurationException | IOException e) {\n            LOGGER.error(\"Could not parse file {}\", parsedFile, e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "allure2",
    "cve_id": "CVE-2025-52888",
    "cwe_list": [
      "CWE-611"
    ],
    "commit_hash": "cbcb33719851ff70adce85d38e15d20fc58d4eb7",
    "short_hash": "cbcb3371",
    "vulnerableMethods_before": [
      {
        "filename": "XunitXmlPluginTest.java",
        "method_name": "shouldSetStatusDetails",
        "raw_code": "@ParameterizedTest\n    @MethodSource(\"data\")\n    void shouldSetStatusDetails(final String resource,\n                                final String fileName,\n                                final String message,\n                                final String trace) throws Exception {\n        process(resource, fileName);\n\n        final ArgumentCaptor<TestResult> captor = ArgumentCaptor.captor();\n        verify(visitor, times(1)).visitTestResult(captor.capture());\n\n        assertThat(captor.getAllValues())\n                .hasSize(1)\n                .extracting(TestResult::getStatusMessage, TestResult::getStatusTrace)\n                .containsExactlyInAnyOrder(\n                        Tuple.tuple(message, trace)\n                );\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XunitXmlPluginTest.java",
        "method_name": "shouldSetStatusDetails",
        "raw_code": "@ParameterizedTest\n    @MethodSource(\"data\")\n    void shouldSetStatusDetails(final String resource,\n                                final String fileName,\n                                final String message,\n                                final String trace) throws Exception {\n        process(resource, fileName);\n\n        final ArgumentCaptor<TestResult> captor = ArgumentCaptor.captor();\n        verify(visitor, times(1)).visitTestResult(captor.capture());\n\n        assertThat(captor.getAllValues())\n                .hasSize(1)\n                .extracting(TestResult::getStatusMessage, TestResult::getStatusTrace)\n                .containsExactlyInAnyOrder(\n                        Tuple.tuple(message, trace)\n                );\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "allure2",
    "cve_id": "CVE-2025-52888",
    "cwe_list": [
      "CWE-611"
    ],
    "commit_hash": "cbcb33719851ff70adce85d38e15d20fc58d4eb7",
    "short_hash": "cbcb3371",
    "vulnerableMethods_before": [
      {
        "filename": "JunitXmlPlugin.java",
        "method_name": "parseRootElement",
        "raw_code": "private void parseRootElement(final Path resultsDirectory, final Path parsedFile,\n                                  final RandomUidContext context, final ResultsVisitor visitor) {\n        try {\n            LOGGER.debug(\"Parsing file {}\", parsedFile);\n            final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            final DocumentBuilder builder = factory.newDocumentBuilder();\n\n            final XmlElement rootElement = new XmlElement(builder.parse(parsedFile.toFile()).getDocumentElement());\n            final String elementName = rootElement.getName();\n\n            if (TEST_SUITE_ELEMENT_NAME.equals(elementName)) {\n                parseTestSuite(rootElement, parsedFile, context, visitor, resultsDirectory);\n                return;\n            }\n            if (TEST_SUITES_ELEMENT_NAME.equals(elementName)) {\n                rootElement.get(TEST_SUITE_ELEMENT_NAME)\n                        .forEach(element -> parseTestSuite(element, parsedFile, context, visitor, resultsDirectory));\n                return;\n            }\n            LOGGER.debug(\"File {} is not a valid JUnit xml. Unknown root element {}\", parsedFile, elementName);\n        } catch (SAXException | ParserConfigurationException | IOException e) {\n            LOGGER.error(\"Could not parse file {}: {}\", parsedFile, e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "JunitXmlPlugin.java",
        "method_name": "parseRootElement",
        "raw_code": "private void parseRootElement(final Path resultsDirectory, final Path parsedFile,\n                                  final RandomUidContext context, final ResultsVisitor visitor) {\n        try {\n            LOGGER.debug(\"Parsing file {}\", parsedFile);\n            final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            final DocumentBuilder builder = factory.newDocumentBuilder();\n            builder.setEntityResolver(new ClasspathEntityResolver());\n\n            final XmlElement rootElement = new XmlElement(builder.parse(parsedFile.toFile()).getDocumentElement());\n            final String elementName = rootElement.getName();\n\n            if (TEST_SUITE_ELEMENT_NAME.equals(elementName)) {\n                parseTestSuite(rootElement, parsedFile, context, visitor, resultsDirectory);\n                return;\n            }\n            if (TEST_SUITES_ELEMENT_NAME.equals(elementName)) {\n                rootElement.get(TEST_SUITE_ELEMENT_NAME)\n                        .forEach(element -> parseTestSuite(element, parsedFile, context, visitor, resultsDirectory));\n                return;\n            }\n            LOGGER.debug(\"File {} is not a valid JUnit xml. Unknown root element {}\", parsedFile, elementName);\n        } catch (SAXException | ParserConfigurationException | IOException e) {\n            LOGGER.error(\"Could not parse file {}: {}\", parsedFile, e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "graylog2-server",
    "cve_id": "CVE-2025-53106",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "6936bd16a783c2944a3d2f1e83902062520f90e3",
    "short_hash": "6936bd16",
    "vulnerableMethods_before": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "createTokenFailsIfCreateNotAllowed",
        "raw_code": "@Test\n    public void createTokenFailsIfCreateNotAllowed() {\n        final Map<String, Object> userProps = Map.of(UserImpl.USERNAME, USERNAME);\n        createTokenAndPrepareMocks(userProps, false);\n\n        try {\n            final UsersResource.GenerateTokenTTL ttl = new UsersResource.GenerateTokenTTL(Optional.of(PeriodDuration.of(Duration.ofDays(30))));\n            assertThrows(ForbiddenException.class, () -> usersResource.generateNewToken(USERNAME, TOKEN_NAME, ttl));\n        } finally {\n            verify(subject).getPrincipal();\n            verify(subject).isPermitted(USERS_TOKENCREATE + \":\" + USERNAME);\n            verifyNoMoreInteractions(clusterConfigService, accessTokenService);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "createTokenFailsIfCreateNotAllowed",
        "raw_code": "@Test\n    public void createTokenFailsIfCreateNotAllowed() {\n        final Map<String, Object> userProps = Map.of(UserImpl.USERNAME, USERNAME);\n        createTokenAndPrepareMocks(userProps, false);\n\n        try {\n            final UsersResource.GenerateTokenTTL ttl = new UsersResource.GenerateTokenTTL(Optional.of(PeriodDuration.of(Duration.ofDays(30))));\n            assertThrows(ForbiddenException.class, () -> usersResource.generateNewToken(USERNAME, TOKEN_NAME, ttl));\n        } finally {\n            verify(subject).isPermitted(USERS_TOKENCREATE + \":\" + USERNAME);\n            verifyNoMoreInteractions(clusterConfigService, accessTokenService);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "graylog2-server",
    "cve_id": "CVE-2025-53106",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "6936bd16a783c2944a3d2f1e83902062520f90e3",
    "short_hash": "6936bd16",
    "vulnerableMethods_before": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "createTokenSucceedsEvenWithNULLBody",
        "raw_code": "@Test\n    public void createTokenSucceedsEvenWithNULLBody() {\n        final Map<String, Object> userProps = Map.of(UserImpl.USERNAME, USERNAME, UserImpl.EXTERNAL_USER, \"FALSE\");\n        final Token expected = createTokenAndPrepareMocks(userProps, true);\n\n        try {\n            final Token actual = usersResource.generateNewToken(USERNAME, TOKEN_NAME, null);\n            assertEquals(expected, actual);\n        } finally {\n            verify(subject).getPrincipal();\n            verify(subject).isPermitted(USERS_TOKENCREATE + \":\" + USERNAME);\n            verify(clusterConfigService).getOrDefault(UserConfiguration.class, UserConfiguration.DEFAULT_VALUES);\n            verify(accessTokenService).create(USERNAME, TOKEN_NAME, PeriodDuration.of(Duration.ofDays(30)));\n            verifyNoMoreInteractions(clusterConfigService, accessTokenService);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "createTokenSucceedsEvenWithNULLBody",
        "raw_code": "@Test\n    public void createTokenSucceedsEvenWithNULLBody() {\n        final Map<String, Object> userProps = Map.of(UserImpl.USERNAME, USERNAME, UserImpl.EXTERNAL_USER, \"FALSE\");\n        final Token expected = createTokenAndPrepareMocks(userProps, true);\n\n        try {\n            final Token actual = usersResource.generateNewToken(USERNAME, TOKEN_NAME, null);\n            assertEquals(expected, actual);\n        } finally {\n            verify(subject).isPermitted(USERS_TOKENCREATE + \":\" + USERNAME);\n            verify(clusterConfigService).getOrDefault(UserConfiguration.class, UserConfiguration.DEFAULT_VALUES);\n            verify(accessTokenService).create(USERNAME, TOKEN_NAME, PeriodDuration.of(Duration.ofDays(30)));\n            verifyNoMoreInteractions(clusterConfigService, accessTokenService);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "graylog2-server",
    "cve_id": "CVE-2025-53106",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "6936bd16a783c2944a3d2f1e83902062520f90e3",
    "short_hash": "6936bd16",
    "vulnerableMethods_before": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "adminCanCreateTokensForOtherUsers",
        "raw_code": "@Test\n    public void adminCanCreateTokensForOtherUsers() {\n        final String adminUserName = \"admin\";\n        final Map<String, Object> owningUser = Map.of(UserImpl.USERNAME, USERNAME);\n        final Map<String, Object> callingUser = Map.of(UserImpl.USERNAME, adminUserName);\n        final Token expected = createTokenAndPrepareMocks(owningUser, callingUser, true);\n\n        try {\n            final Token actual = usersResource.generateNewToken(USERNAME, TOKEN_NAME, null);\n            assertEquals(expected, actual);\n        } finally {\n            verify(subject).getPrincipal();\n            verify(subject).isPermitted(USERS_TOKENCREATE + \":\" + adminUserName);\n            verify(clusterConfigService).getOrDefault(UserConfiguration.class, UserConfiguration.DEFAULT_VALUES);\n            verify(accessTokenService).create(USERNAME, TOKEN_NAME, PeriodDuration.of(Duration.ofDays(30)));\n            verifyNoMoreInteractions(clusterConfigService, accessTokenService);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "adminCanCreateTokensForOtherUsers",
        "raw_code": "@Test\n    public void adminCanCreateTokensForOtherUsers() {\n        final String adminUserName = \"admin\";\n        final Map<String, Object> owningUser = Map.of(UserImpl.USERNAME, USERNAME);\n        final Map<String, Object> callingUser = Map.of(UserImpl.USERNAME, adminUserName);\n        final Token expected = createTokenAndPrepareMocks(owningUser, callingUser, true);\n\n        try {\n            final Token actual = usersResource.generateNewToken(USERNAME, TOKEN_NAME, null);\n            assertEquals(expected, actual);\n        } finally {\n            verify(subject).isPermitted(USERS_TOKENCREATE + \":\" + USERNAME);\n            verify(clusterConfigService).getOrDefault(UserConfiguration.class, UserConfiguration.DEFAULT_VALUES);\n            verify(accessTokenService).create(USERNAME, TOKEN_NAME, PeriodDuration.of(Duration.ofDays(30)));\n            verifyNoMoreInteractions(clusterConfigService, accessTokenService);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "graylog2-server",
    "cve_id": "CVE-2025-53106",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "6936bd16a783c2944a3d2f1e83902062520f90e3",
    "short_hash": "6936bd16",
    "vulnerableMethods_before": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "regularUserCannotCreateTokensForOtherUsers",
        "raw_code": "@Test\n    public void regularUserCannotCreateTokensForOtherUsers() {\n        final String otherUserName = \"Dee-Dee\";\n        final Map<String, Object> owningUser = Map.of(UserImpl.USERNAME, USERNAME);\n        final Map<String, Object> callingUser = Map.of(UserImpl.USERNAME, otherUserName);\n        createTokenAndPrepareMocks(owningUser, callingUser, false);\n\n        try {\n            assertThrows(ForbiddenException.class, () -> usersResource.generateNewToken(USERNAME, TOKEN_NAME, null));\n        } finally {\n            verify(subject).getPrincipal();\n            verify(subject).isPermitted(USERS_TOKENCREATE + \":\" + otherUserName);\n            verifyNoMoreInteractions(clusterConfigService, accessTokenService);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "regularUserCannotCreateTokensForOtherUsers",
        "raw_code": "@Test\n    public void regularUserCannotCreateTokensForOtherUsers() {\n        final String otherUserName = \"Dee-Dee\";\n        final Map<String, Object> owningUser = Map.of(UserImpl.USERNAME, USERNAME);\n        final Map<String, Object> callingUser = Map.of(UserImpl.USERNAME, otherUserName);\n        createTokenAndPrepareMocks(owningUser, callingUser, false);\n\n        try {\n            assertThrows(ForbiddenException.class, () -> usersResource.generateNewToken(USERNAME, TOKEN_NAME, null));\n        } finally {\n            verify(subject).isPermitted(USERS_TOKENCREATE + \":\" + USERNAME);\n            verifyNoMoreInteractions(clusterConfigService, accessTokenService);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "graylog2-server",
    "cve_id": "CVE-2025-53106",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "6936bd16a783c2944a3d2f1e83902062520f90e3",
    "short_hash": "6936bd16",
    "vulnerableMethods_before": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "createTokenAndPrepareMocks",
        "raw_code": "private Token createTokenAndPrepareMocks(Map<String, Object> userProps, boolean allowCreateToken) {\n        final String token = \"someToken\";\n        final DateTime lastAccess = Tools.nowUTC();\n        final Map<String, Object> tokenProps = Map.of(AccessTokenImpl.NAME, TOKEN_NAME, AccessTokenImpl.TOKEN, token, AccessTokenImpl.LAST_ACCESS, lastAccess);\n        final ObjectId tokenId = new ObjectId();\n        final AccessToken accessToken = new AccessTokenImpl(tokenId, tokenProps);\n\n        prepareMocks(userProps, accessToken, allowCreateToken);\n\n        return Token.create(tokenId.toHexString(), TOKEN_NAME, token, lastAccess);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "createTokenAndPrepareMocks",
        "raw_code": "private Token createTokenAndPrepareMocks(Map<String, Object> userProps, boolean allowCreateToken) {\n        final String token = \"someToken\";\n        final DateTime lastAccess = Tools.nowUTC();\n        final Map<String, Object> tokenProps = Map.of(AccessTokenImpl.NAME, TOKEN_NAME, AccessTokenImpl.TOKEN, token, AccessTokenImpl.LAST_ACCESS, lastAccess);\n        final ObjectId tokenId = new ObjectId();\n        final AccessToken accessToken = allowCreateToken ? new AccessTokenImpl(tokenId, tokenProps) : null;\n\n        prepareMocks(userProps, accessToken, allowCreateToken);\n\n        return Token.create(tokenId.toHexString(), TOKEN_NAME, token, lastAccess);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "graylog2-server",
    "cve_id": "CVE-2025-53106",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "6936bd16a783c2944a3d2f1e83902062520f90e3",
    "short_hash": "6936bd16",
    "vulnerableMethods_before": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "prepareMocks",
        "raw_code": "private void prepareMocks(Map<String, Object> userProps, AccessToken accessToken, boolean allow) {\n        final User user = userImplFactory.create(userProps);\n        when(subject.getPrincipal()).thenReturn(USERNAME);\n        when(userService.loadById(USERNAME)).thenReturn(user);\n        when(userManagementService.loadById(USERNAME)).thenReturn(user);\n        when(subject.isPermitted(USERS_TOKENCREATE + \":\" + USERNAME)).thenReturn(allow);\n        when(clusterConfigService.getOrDefault(UserConfiguration.class, UserConfiguration.DEFAULT_VALUES)).thenReturn(UserConfiguration.DEFAULT_VALUES);\n        if (accessToken != null) {\n            when(accessTokenService.create(USERNAME, UsersResourceTest.TOKEN_NAME, PeriodDuration.of(Duration.ofDays(30)))).thenReturn(accessToken);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "prepareMocks",
        "raw_code": "private void prepareMocks(Map<String, Object> userProps, AccessToken accessToken, boolean allow) {\n        final User user = userImplFactory.create(userProps);\n        when(userManagementService.loadById(USERNAME)).thenReturn(user);\n        when(subject.isPermitted(USERS_TOKENCREATE + \":\" + USERNAME)).thenReturn(allow);\n        if (allow) {\n            when(clusterConfigService.getOrDefault(UserConfiguration.class, UserConfiguration.DEFAULT_VALUES)).thenReturn(UserConfiguration.DEFAULT_VALUES);\n        }\n        if (accessToken != null) {\n            when(accessTokenService.create(USERNAME, UsersResourceTest.TOKEN_NAME, PeriodDuration.of(Duration.ofDays(30)))).thenReturn(accessToken);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "graylog2-server",
    "cve_id": "CVE-2025-53106",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "6936bd16a783c2944a3d2f1e83902062520f90e3",
    "short_hash": "6936bd16",
    "vulnerableMethods_before": [
      {
        "filename": "UsersResource.java",
        "method_name": "generateNewToken",
        "raw_code": "@POST\n    @Path(\"{userId}/tokens/{name}\")\n    @ApiOperation(\"Generates a new access token for a user\")\n    @AuditEvent(type = AuditEventTypes.USER_ACCESS_TOKEN_CREATE)\n    public Token generateNewToken(\n            @ApiParam(name = \"userId\", required = true) @PathParam(\"userId\") String userId,\n            @ApiParam(name = \"name\", value = \"Descriptive name for this token (e.g. 'cronjob') \", required = true) @PathParam(\"name\") String name,\n            @ApiParam(name = \"JSON Body\", value = \"Can optionally contain the token's TTL.\", defaultValue = \"{\\\"token_ttl\\\":null}\") GenerateTokenTTL body) {\n        final User futureOwner = loadUserById(userId);\n        final User currentUser = getCurrentUser();\n\n        if (currentUser == null) {\n            throw new ForbiddenException(\"Not allowed to create tokens for unknown user.\");\n        }\n        if (!isPermitted(USERS_TOKENCREATE, currentUser.getName())) {\n            throw new ForbiddenException(currentUser.getName() + \" is not allowed to create token.\");\n        }\n\n        if (body == null) {\n            body = new GenerateTokenTTL(Optional.empty());\n        }\n        final AccessToken accessToken = accessTokenService.create(futureOwner.getName(), name, body.getTTL(() -> clusterConfigService.getOrDefault(UserConfiguration.class, UserConfiguration.DEFAULT_VALUES).defaultTTLForNewTokens()));\n\n        return Token.create(accessToken.getId(), accessToken.getName(), accessToken.getToken(), accessToken.getLastAccess());\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "UsersResource.java",
        "method_name": "generateNewToken",
        "raw_code": "@POST\n    @Path(\"{userId}/tokens/{name}\")\n    @ApiOperation(\"Generates a new access token for a user\")\n    @AuditEvent(type = AuditEventTypes.USER_ACCESS_TOKEN_CREATE)\n    public Token generateNewToken(\n            @ApiParam(name = \"userId\", required = true) @PathParam(\"userId\") String userId,\n            @ApiParam(name = \"name\", value = \"Descriptive name for this token (e.g. 'cronjob') \", required = true) @PathParam(\"name\") String name,\n            @ApiParam(name = \"JSON Body\", value = \"Can optionally contain the token's TTL.\", defaultValue = \"{\\\"token_ttl\\\":null}\") GenerateTokenTTL body) {\n        final User futureOwner = loadUserById(userId);\n\n        if (!isPermitted(USERS_TOKENCREATE, futureOwner.getName())) {\n            throw new ForbiddenException(\"You are not allowed to create a token for user \" + futureOwner.getName() + \".\");\n        }\n\n        if (body == null) {\n            body = new GenerateTokenTTL(Optional.empty());\n        }\n        final AccessToken accessToken = accessTokenService.create(futureOwner.getName(), name, body.getTTL(() -> clusterConfigService.getOrDefault(UserConfiguration.class, UserConfiguration.DEFAULT_VALUES).defaultTTLForNewTokens()));\n\n        return Token.create(accessToken.getId(), accessToken.getName(), accessToken.getToken(), accessToken.getLastAccess());\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "graylog2-server",
    "cve_id": "CVE-2025-53106",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "9215b8f1fd32566c31e6f7447ed864df3590c157",
    "short_hash": "9215b8f1",
    "vulnerableMethods_before": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "createTokenFailsIfCreateNotAllowed",
        "raw_code": "@Test\n    public void createTokenFailsIfCreateNotAllowed() {\n        final Map<String, Object> userProps = Map.of(UserImpl.USERNAME, USERNAME);\n        createTokenAndPrepareMocks(userProps, false);\n\n        try {\n            final UsersResource.GenerateTokenTTL ttl = new UsersResource.GenerateTokenTTL(Optional.of(PeriodDuration.of(Duration.ofDays(30))));\n            assertThrows(ForbiddenException.class, () -> usersResource.generateNewToken(USERNAME, TOKEN_NAME, ttl));\n        } finally {\n            verify(subject).getPrincipal();\n            verify(subject).isPermitted(USERS_TOKENCREATE + \":\" + USERNAME);\n            verifyNoMoreInteractions(clusterConfigService, accessTokenService);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "createTokenFailsIfCreateNotAllowed",
        "raw_code": "@Test\n    public void createTokenFailsIfCreateNotAllowed() {\n        final Map<String, Object> userProps = Map.of(UserImpl.USERNAME, USERNAME);\n        createTokenAndPrepareMocks(userProps, false);\n\n        try {\n            final UsersResource.GenerateTokenTTL ttl = new UsersResource.GenerateTokenTTL(Optional.of(PeriodDuration.of(Duration.ofDays(30))));\n            assertThrows(ForbiddenException.class, () -> usersResource.generateNewToken(USERNAME, TOKEN_NAME, ttl));\n        } finally {\n            verify(subject).isPermitted(USERS_TOKENCREATE + \":\" + USERNAME);\n            verifyNoMoreInteractions(clusterConfigService, accessTokenService);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "graylog2-server",
    "cve_id": "CVE-2025-53106",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "9215b8f1fd32566c31e6f7447ed864df3590c157",
    "short_hash": "9215b8f1",
    "vulnerableMethods_before": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "createTokenSucceedsEvenWithNULLBody",
        "raw_code": "@Test\n    public void createTokenSucceedsEvenWithNULLBody() {\n        final Map<String, Object> userProps = Map.of(UserImpl.USERNAME, USERNAME, UserImpl.EXTERNAL_USER, \"FALSE\");\n        final Token expected = createTokenAndPrepareMocks(userProps, true);\n\n        try {\n            final Token actual = usersResource.generateNewToken(USERNAME, TOKEN_NAME, null);\n            assertEquals(expected, actual);\n        } finally {\n            verify(subject).getPrincipal();\n            verify(subject).isPermitted(USERS_TOKENCREATE + \":\" + USERNAME);\n            verify(clusterConfigService).getOrDefault(UserConfiguration.class, UserConfiguration.DEFAULT_VALUES);\n            verify(accessTokenService).create(USERNAME, TOKEN_NAME, PeriodDuration.of(Duration.ofDays(30)));\n            verifyNoMoreInteractions(clusterConfigService, accessTokenService);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "createTokenSucceedsEvenWithNULLBody",
        "raw_code": "@Test\n    public void createTokenSucceedsEvenWithNULLBody() {\n        final Map<String, Object> userProps = Map.of(UserImpl.USERNAME, USERNAME, UserImpl.EXTERNAL_USER, \"FALSE\");\n        final Token expected = createTokenAndPrepareMocks(userProps, true);\n\n        try {\n            final Token actual = usersResource.generateNewToken(USERNAME, TOKEN_NAME, null);\n            assertEquals(expected, actual);\n        } finally {\n            verify(subject).isPermitted(USERS_TOKENCREATE + \":\" + USERNAME);\n            verify(clusterConfigService).getOrDefault(UserConfiguration.class, UserConfiguration.DEFAULT_VALUES);\n            verify(accessTokenService).create(USERNAME, TOKEN_NAME, PeriodDuration.of(Duration.ofDays(30)));\n            verifyNoMoreInteractions(clusterConfigService, accessTokenService);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "graylog2-server",
    "cve_id": "CVE-2025-53106",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "9215b8f1fd32566c31e6f7447ed864df3590c157",
    "short_hash": "9215b8f1",
    "vulnerableMethods_before": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "adminCanCreateTokensForOtherUsers",
        "raw_code": "@Test\n    public void adminCanCreateTokensForOtherUsers() {\n        final String adminUserName = \"admin\";\n        final Map<String, Object> owningUser = Map.of(UserImpl.USERNAME, USERNAME);\n        final Map<String, Object> callingUser = Map.of(UserImpl.USERNAME, adminUserName);\n        final Token expected = createTokenAndPrepareMocks(owningUser, callingUser, true);\n\n        try {\n            final Token actual = usersResource.generateNewToken(USERNAME, TOKEN_NAME, null);\n            assertEquals(expected, actual);\n        } finally {\n            verify(subject).getPrincipal();\n            verify(subject).isPermitted(USERS_TOKENCREATE + \":\" + adminUserName);\n            verify(clusterConfigService).getOrDefault(UserConfiguration.class, UserConfiguration.DEFAULT_VALUES);\n            verify(accessTokenService).create(USERNAME, TOKEN_NAME, PeriodDuration.of(Duration.ofDays(30)));\n            verifyNoMoreInteractions(clusterConfigService, accessTokenService);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "adminCanCreateTokensForOtherUsers",
        "raw_code": "@Test\n    public void adminCanCreateTokensForOtherUsers() {\n        final String adminUserName = \"admin\";\n        final Map<String, Object> owningUser = Map.of(UserImpl.USERNAME, USERNAME);\n        final Map<String, Object> callingUser = Map.of(UserImpl.USERNAME, adminUserName);\n        final Token expected = createTokenAndPrepareMocks(owningUser, callingUser, true);\n\n        try {\n            final Token actual = usersResource.generateNewToken(USERNAME, TOKEN_NAME, null);\n            assertEquals(expected, actual);\n        } finally {\n            verify(subject).isPermitted(USERS_TOKENCREATE + \":\" + USERNAME);\n            verify(clusterConfigService).getOrDefault(UserConfiguration.class, UserConfiguration.DEFAULT_VALUES);\n            verify(accessTokenService).create(USERNAME, TOKEN_NAME, PeriodDuration.of(Duration.ofDays(30)));\n            verifyNoMoreInteractions(clusterConfigService, accessTokenService);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "graylog2-server",
    "cve_id": "CVE-2025-53106",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "9215b8f1fd32566c31e6f7447ed864df3590c157",
    "short_hash": "9215b8f1",
    "vulnerableMethods_before": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "regularUserCannotCreateTokensForOtherUsers",
        "raw_code": "@Test\n    public void regularUserCannotCreateTokensForOtherUsers() {\n        final String otherUserName = \"Dee-Dee\";\n        final Map<String, Object> owningUser = Map.of(UserImpl.USERNAME, USERNAME);\n        final Map<String, Object> callingUser = Map.of(UserImpl.USERNAME, otherUserName);\n        createTokenAndPrepareMocks(owningUser, callingUser, false);\n\n        try {\n            assertThrows(ForbiddenException.class, () -> usersResource.generateNewToken(USERNAME, TOKEN_NAME, null));\n        } finally {\n            verify(subject).getPrincipal();\n            verify(subject).isPermitted(USERS_TOKENCREATE + \":\" + otherUserName);\n            verifyNoMoreInteractions(clusterConfigService, accessTokenService);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "regularUserCannotCreateTokensForOtherUsers",
        "raw_code": "@Test\n    public void regularUserCannotCreateTokensForOtherUsers() {\n        final String otherUserName = \"Dee-Dee\";\n        final Map<String, Object> owningUser = Map.of(UserImpl.USERNAME, USERNAME);\n        final Map<String, Object> callingUser = Map.of(UserImpl.USERNAME, otherUserName);\n        createTokenAndPrepareMocks(owningUser, callingUser, false);\n\n        try {\n            assertThrows(ForbiddenException.class, () -> usersResource.generateNewToken(USERNAME, TOKEN_NAME, null));\n        } finally {\n            verify(subject).isPermitted(USERS_TOKENCREATE + \":\" + USERNAME);\n            verifyNoMoreInteractions(clusterConfigService, accessTokenService);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "graylog2-server",
    "cve_id": "CVE-2025-53106",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "9215b8f1fd32566c31e6f7447ed864df3590c157",
    "short_hash": "9215b8f1",
    "vulnerableMethods_before": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "createTokenAndPrepareMocks",
        "raw_code": "private Token createTokenAndPrepareMocks(Map<String, Object> userProps, boolean allowCreateToken) {\n        final String token = \"someToken\";\n        final DateTime lastAccess = Tools.nowUTC();\n        final Map<String, Object> tokenProps = Map.of(AccessTokenImpl.NAME, TOKEN_NAME, AccessTokenImpl.TOKEN, token, AccessTokenImpl.LAST_ACCESS, lastAccess);\n        final ObjectId tokenId = new ObjectId();\n        final AccessToken accessToken = new AccessTokenImpl(tokenId, tokenProps);\n\n        prepareMocks(userProps, accessToken, allowCreateToken);\n\n        return Token.create(tokenId.toHexString(), TOKEN_NAME, token, lastAccess);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "createTokenAndPrepareMocks",
        "raw_code": "private Token createTokenAndPrepareMocks(Map<String, Object> userProps, boolean allowCreateToken) {\n        final String token = \"someToken\";\n        final DateTime lastAccess = Tools.nowUTC();\n        final Map<String, Object> tokenProps = Map.of(AccessTokenImpl.NAME, TOKEN_NAME, AccessTokenImpl.TOKEN, token, AccessTokenImpl.LAST_ACCESS, lastAccess);\n        final ObjectId tokenId = new ObjectId();\n        final AccessToken accessToken = allowCreateToken ? new AccessTokenImpl(tokenId, tokenProps) : null;\n\n        prepareMocks(userProps, accessToken, allowCreateToken);\n\n        return Token.create(tokenId.toHexString(), TOKEN_NAME, token, lastAccess);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "graylog2-server",
    "cve_id": "CVE-2025-53106",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "9215b8f1fd32566c31e6f7447ed864df3590c157",
    "short_hash": "9215b8f1",
    "vulnerableMethods_before": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "prepareMocks",
        "raw_code": "private void prepareMocks(Map<String, Object> userProps, AccessToken accessToken, boolean allow) {\n        final User user = userImplFactory.create(userProps);\n        when(subject.getPrincipal()).thenReturn(USERNAME);\n        when(userService.loadById(USERNAME)).thenReturn(user);\n        when(userManagementService.loadById(USERNAME)).thenReturn(user);\n        when(subject.isPermitted(USERS_TOKENCREATE + \":\" + USERNAME)).thenReturn(allow);\n        when(clusterConfigService.getOrDefault(UserConfiguration.class, UserConfiguration.DEFAULT_VALUES)).thenReturn(UserConfiguration.DEFAULT_VALUES);\n        if (accessToken != null) {\n            when(accessTokenService.create(USERNAME, UsersResourceTest.TOKEN_NAME, PeriodDuration.of(Duration.ofDays(30)))).thenReturn(accessToken);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "UsersResourceTest.java",
        "method_name": "prepareMocks",
        "raw_code": "private void prepareMocks(Map<String, Object> userProps, AccessToken accessToken, boolean allow) {\n        final User user = userImplFactory.create(userProps);\n        when(userManagementService.loadById(USERNAME)).thenReturn(user);\n        when(subject.isPermitted(USERS_TOKENCREATE + \":\" + USERNAME)).thenReturn(allow);\n        if (allow) {\n            when(clusterConfigService.getOrDefault(UserConfiguration.class, UserConfiguration.DEFAULT_VALUES)).thenReturn(UserConfiguration.DEFAULT_VALUES);\n        }\n        if (accessToken != null) {\n            when(accessTokenService.create(USERNAME, UsersResourceTest.TOKEN_NAME, PeriodDuration.of(Duration.ofDays(30)))).thenReturn(accessToken);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "graylog2-server",
    "cve_id": "CVE-2025-53106",
    "cwe_list": [
      "CWE-285"
    ],
    "commit_hash": "9215b8f1fd32566c31e6f7447ed864df3590c157",
    "short_hash": "9215b8f1",
    "vulnerableMethods_before": [
      {
        "filename": "UsersResource.java",
        "method_name": "generateNewToken",
        "raw_code": "@POST\n    @Path(\"{userId}/tokens/{name}\")\n    @ApiOperation(\"Generates a new access token for a user\")\n    @AuditEvent(type = AuditEventTypes.USER_ACCESS_TOKEN_CREATE)\n    public Token generateNewToken(\n            @ApiParam(name = \"userId\", required = true) @PathParam(\"userId\") String userId,\n            @ApiParam(name = \"name\", value = \"Descriptive name for this token (e.g. 'cronjob') \", required = true) @PathParam(\"name\") String name,\n            @ApiParam(name = \"JSON Body\", value = \"Can optionally contain the token's TTL.\", defaultValue = \"{\\\"token_ttl\\\":null}\") GenerateTokenTTL body) {\n        final User futureOwner = loadUserById(userId);\n        final User currentUser = getCurrentUser();\n\n        if (currentUser == null) {\n            throw new ForbiddenException(\"Not allowed to create tokens for unknown user.\");\n        }\n        if (!isPermitted(USERS_TOKENCREATE, currentUser.getName())) {\n            throw new ForbiddenException(currentUser.getName() + \" is not allowed to create token.\");\n        }\n\n        if (body == null) {\n            body = new GenerateTokenTTL(Optional.empty());\n        }\n        final AccessToken accessToken = accessTokenService.create(futureOwner.getName(), name, body.getTTL(() -> clusterConfigService.getOrDefault(UserConfiguration.class, UserConfiguration.DEFAULT_VALUES).defaultTTLForNewTokens()));\n\n        return Token.create(accessToken.getId(), accessToken.getName(), accessToken.getToken(), accessToken.getLastAccess());\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "UsersResource.java",
        "method_name": "generateNewToken",
        "raw_code": "@POST\n    @Path(\"{userId}/tokens/{name}\")\n    @ApiOperation(\"Generates a new access token for a user\")\n    @AuditEvent(type = AuditEventTypes.USER_ACCESS_TOKEN_CREATE)\n    public Token generateNewToken(\n            @ApiParam(name = \"userId\", required = true) @PathParam(\"userId\") String userId,\n            @ApiParam(name = \"name\", value = \"Descriptive name for this token (e.g. 'cronjob') \", required = true) @PathParam(\"name\") String name,\n            @ApiParam(name = \"JSON Body\", value = \"Can optionally contain the token's TTL.\", defaultValue = \"{\\\"token_ttl\\\":null}\") GenerateTokenTTL body) {\n        final User futureOwner = loadUserById(userId);\n\n        if (!isPermitted(USERS_TOKENCREATE, futureOwner.getName())) {\n            throw new ForbiddenException(\"You are not allowed to create a token for user \" + futureOwner.getName() + \".\");\n        }\n\n        if (body == null) {\n            body = new GenerateTokenTTL(Optional.empty());\n        }\n        final AccessToken accessToken = accessTokenService.create(futureOwner.getName(), name, body.getTTL(() -> clusterConfigService.getOrDefault(UserConfiguration.class, UserConfiguration.DEFAULT_VALUES).defaultTTLForNewTokens()));\n\n        return Token.create(accessToken.getId(), accessToken.getName(), accessToken.getToken(), accessToken.getLastAccess());\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "quarkus",
    "cve_id": "CVE-2025-49574",
    "cwe_list": [
      "CWE-668"
    ],
    "commit_hash": "2b58f59f4bf0bae7d35b1abb585b65f2a66787d1",
    "short_hash": "2b58f59f",
    "vulnerableMethods_before": [
      {
        "filename": "AbstractResponseWrapper.java",
        "method_name": "write",
        "raw_code": "@Override\n\n    public Future<Void> write(String chunk, String enc) {\n        return delegate.write(chunk, enc);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AbstractResponseWrapper.java",
        "method_name": "write",
        "raw_code": "@Override\n\n    public Future<Void> write(String chunk, String enc) {\n        return delegate.write(chunk, enc);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "quarkus",
    "cve_id": "CVE-2025-49574",
    "cwe_list": [
      "CWE-668"
    ],
    "commit_hash": "2b58f59f4bf0bae7d35b1abb585b65f2a66787d1",
    "short_hash": "2b58f59f",
    "vulnerableMethods_before": [
      {
        "filename": "ContextualEmitterImpl.java",
        "method_name": "sendMessage",
        "raw_code": "@Override\n    @CheckReturnValue\n    public <M extends Message<? extends T>> Uni<Void> sendMessage(M msg) {\n        if (msg == null) {\n            throw ex.illegalArgumentForNullValue();\n        }\n\n        // If we are running on a Vert.x context, we need to capture the context to switch back\n        // during the emission.\n        Context context = Vertx.currentContext();\n        // context propagation capture and duplicate the context\n        var msgUni = Uni.createFrom().item(() -> ContextAwareMessage.withContextMetadata((Message<? extends T>) msg));\n        if (context != null) {\n            msgUni = msgUni.emitOn(r -> context.runOnContext(x -> r.run()));\n        }\n        // emit the message, skip context propagation as it is unnecessary here\n        Uni<Void> uni = transformToUni(msgUni, message -> ContextualEmitterImpl.emitter(e -> {\n            try {\n                emit(message\n                        .withAck(() -> {\n                            e.complete(null);\n                            return msg.ack();\n                        })\n                        .withNack(t -> {\n                            e.fail(t);\n                            return msg.nack(t);\n                        }));\n            } catch (Exception t) {\n                // Capture synchronous exception and nack the message.\n                msg.nack(t);\n                throw t;\n            }\n        }));\n        // switch back to the caller context\n        if (context != null) {\n            return uni.emitOn(r -> context.runOnContext(x -> r.run()));\n        } else {\n            return uni;\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ContextualEmitterImpl.java",
        "method_name": "sendMessage",
        "raw_code": "@Override\n    @CheckReturnValue\n    public <M extends Message<? extends T>> Uni<Void> sendMessage(M msg) {\n        if (msg == null) {\n            throw ex.illegalArgumentForNullValue();\n        }\n\n        // If we are running on a Vert.x context, we need to capture the context to switch back\n        // during the emission.\n        Context context = Vertx.currentContext();\n        // context propagation capture and duplicate the context\n        var msgUni = Uni.createFrom().item(() -> createContextualMessage((Message<? extends T>) msg, context));\n        if (context != null) {\n            msgUni = msgUni.emitOn(r -> context.runOnContext(x -> r.run()));\n        }\n        // emit the message, skip context propagation as it is unnecessary here\n        Uni<Void> uni = transformToUni(msgUni, message -> ContextualEmitterImpl.emitter(e -> {\n            try {\n                emit(message\n                        .withAck(() -> {\n                            e.complete(null);\n                            return msg.ack();\n                        })\n                        .withNack(t -> {\n                            e.fail(t);\n                            return msg.nack(t);\n                        }));\n            } catch (Exception t) {\n                // Capture synchronous exception and nack the message.\n                msg.nack(t);\n                throw t;\n            }\n        }));\n        // switch back to the caller context\n        if (context != null) {\n            return uni.emitOn(r -> context.runOnContext(x -> r.run()));\n        } else {\n            return uni;\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "quarkus",
    "cve_id": "CVE-2025-49574",
    "cwe_list": [
      "CWE-668"
    ],
    "commit_hash": "2b58f59f4bf0bae7d35b1abb585b65f2a66787d1",
    "short_hash": "2b58f59f",
    "vulnerableMethods_before": [
      {
        "filename": "KafkaContextPropagationTest.java",
        "method_name": "testNonBlocking",
        "raw_code": "@Test\n        void testNonBlocking() {\n            given().body(\"rose\").post(\"/flowers\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"peony\").post(\"/flowers\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"daisy\").post(\"/flowers\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n        }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "KafkaContextPropagationTest.java",
        "method_name": "testNonBlocking",
        "raw_code": "@Test\n        void testNonBlocking() {\n            given().body(\"rose\").post(\"/flowers/mutiny\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"peony\").post(\"/flowers/mutiny\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"daisy\").post(\"/flowers/mutiny\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n        }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "quarkus",
    "cve_id": "CVE-2025-49574",
    "cwe_list": [
      "CWE-668"
    ],
    "commit_hash": "2b58f59f4bf0bae7d35b1abb585b65f2a66787d1",
    "short_hash": "2b58f59f",
    "vulnerableMethods_before": [
      {
        "filename": "KafkaContextPropagationTest.java",
        "method_name": "testNonBlockingUni",
        "raw_code": "@Test\n        void testNonBlockingUni() {\n            given().body(\"rose\").post(\"/flowers/uni\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"peony\").post(\"/flowers/uni\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"daisy\").post(\"/flowers/uni\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n        }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "KafkaContextPropagationTest.java",
        "method_name": "testNonBlockingUni",
        "raw_code": "@Test\n        void testNonBlockingUni() {\n            given().body(\"rose\").post(\"/flowers/mutiny/uni\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"peony\").post(\"/flowers/mutiny/uni\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"daisy\").post(\"/flowers/mutiny/uni\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n        }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "quarkus",
    "cve_id": "CVE-2025-49574",
    "cwe_list": [
      "CWE-668"
    ],
    "commit_hash": "2b58f59f4bf0bae7d35b1abb585b65f2a66787d1",
    "short_hash": "2b58f59f",
    "vulnerableMethods_before": [
      {
        "filename": "KafkaContextPropagationTest.java",
        "method_name": "testBlocking",
        "raw_code": "@Test\n        void testBlocking() {\n            given().body(\"rose\").post(\"/flowers/blocking\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"peony\").post(\"/flowers/blocking\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"daisy\").post(\"/flowers/blocking\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n        }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "KafkaContextPropagationTest.java",
        "method_name": "testBlocking",
        "raw_code": "@Test\n        void testBlocking() {\n            given().body(\"rose\").post(\"/flowers/mutiny/blocking\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"peony\").post(\"/flowers/mutiny/blocking\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"daisy\").post(\"/flowers/mutiny/blocking\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n        }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "quarkus",
    "cve_id": "CVE-2025-49574",
    "cwe_list": [
      "CWE-668"
    ],
    "commit_hash": "2b58f59f4bf0bae7d35b1abb585b65f2a66787d1",
    "short_hash": "2b58f59f",
    "vulnerableMethods_before": [
      {
        "filename": "KafkaContextPropagationTest.java",
        "method_name": "testBlockingUni",
        "raw_code": "@Test\n        void testBlockingUni() {\n            given().body(\"rose\").post(\"/flowers/uni/blocking\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"peony\").post(\"/flowers/uni/blocking\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"daisy\").post(\"/flowers/uni/blocking\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n        }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "KafkaContextPropagationTest.java",
        "method_name": "testBlockingUni",
        "raw_code": "@Test\n        void testBlockingUni() {\n            given().body(\"rose\").post(\"/flowers/mutiny/uni/blocking\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"peony\").post(\"/flowers/mutiny/uni/blocking\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"daisy\").post(\"/flowers/mutiny/uni/blocking\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n        }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "quarkus",
    "cve_id": "CVE-2025-49574",
    "cwe_list": [
      "CWE-668"
    ],
    "commit_hash": "2b58f59f4bf0bae7d35b1abb585b65f2a66787d1",
    "short_hash": "2b58f59f",
    "vulnerableMethods_before": [
      {
        "filename": "KafkaContextPropagationTest.java",
        "method_name": "testBlockingNamed",
        "raw_code": "@Test\n        void testBlockingNamed() {\n            given().body(\"rose\").post(\"/flowers/blocking-named\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"peony\").post(\"/flowers/blocking-named\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"daisy\").post(\"/flowers/blocking-named\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n        }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "KafkaContextPropagationTest.java",
        "method_name": "testBlockingNamed",
        "raw_code": "@Test\n        void testBlockingNamed() {\n            given().body(\"rose\").post(\"/flowers/mutiny/blocking-named\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"peony\").post(\"/flowers/mutiny/blocking-named\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"daisy\").post(\"/flowers/mutiny/blocking-named\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n        }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "quarkus",
    "cve_id": "CVE-2025-49574",
    "cwe_list": [
      "CWE-668"
    ],
    "commit_hash": "2b58f59f4bf0bae7d35b1abb585b65f2a66787d1",
    "short_hash": "2b58f59f",
    "vulnerableMethods_before": [
      {
        "filename": "KafkaContextPropagationTest.java",
        "method_name": "testBlockingNamedUni",
        "raw_code": "@Test\n        void testBlockingNamedUni() {\n            given().body(\"rose\").post(\"/flowers/uni/blocking-named\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"peony\").post(\"/flowers/uni/blocking-named\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"daisy\").post(\"/flowers/uni/blocking-named\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n        }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "KafkaContextPropagationTest.java",
        "method_name": "testBlockingNamedUni",
        "raw_code": "@Test\n        void testBlockingNamedUni() {\n            given().body(\"rose\").post(\"/flowers/mutiny/uni/blocking-named\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"peony\").post(\"/flowers/mutiny/uni/blocking-named\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"daisy\").post(\"/flowers/mutiny/uni/blocking-named\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n        }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "quarkus",
    "cve_id": "CVE-2025-49574",
    "cwe_list": [
      "CWE-668"
    ],
    "commit_hash": "2b58f59f4bf0bae7d35b1abb585b65f2a66787d1",
    "short_hash": "2b58f59f",
    "vulnerableMethods_before": [
      {
        "filename": "KafkaContextPropagationTest.java",
        "method_name": "testVirtualThread",
        "raw_code": "@Test\n        @EnabledForJreRange(min = JRE.JAVA_21)\n        void testVirtualThread() {\n            given().body(\"rose\").post(\"/flowers/virtual-thread\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"peony\").post(\"/flowers/virtual-thread\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"daisy\").post(\"/flowers/virtual-thread\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n        }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "KafkaContextPropagationTest.java",
        "method_name": "testVirtualThread",
        "raw_code": "@Test\n        @EnabledForJreRange(min = JRE.JAVA_21)\n        void testVirtualThread() {\n            given().body(\"rose\").post(\"/flowers/mutiny/virtual-thread\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"peony\").post(\"/flowers/mutiny/virtual-thread\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"daisy\").post(\"/flowers/mutiny/virtual-thread\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n        }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "quarkus",
    "cve_id": "CVE-2025-49574",
    "cwe_list": [
      "CWE-668"
    ],
    "commit_hash": "2b58f59f4bf0bae7d35b1abb585b65f2a66787d1",
    "short_hash": "2b58f59f",
    "vulnerableMethods_before": [
      {
        "filename": "KafkaContextPropagationTest.java",
        "method_name": "testVirtualThreadUni",
        "raw_code": "@Test\n        @EnabledForJreRange(min = JRE.JAVA_21)\n        void testVirtualThreadUni() {\n            given().body(\"rose\").post(\"/flowers/uni/virtual-thread\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"peony\").post(\"/flowers/uni/virtual-thread\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"daisy\").post(\"/flowers/uni/virtual-thread\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n        }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "KafkaContextPropagationTest.java",
        "method_name": "testVirtualThreadUni",
        "raw_code": "@Test\n        @EnabledForJreRange(min = JRE.JAVA_21)\n        void testVirtualThreadUni() {\n            given().body(\"rose\").post(\"/flowers/mutiny/uni/virtual-thread\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"peony\").post(\"/flowers/mutiny/uni/virtual-thread\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n            given().body(\"daisy\").post(\"/flowers/mutiny/uni/virtual-thread\").then()\n                    .statusCode(500)\n                    .body(assertBodyRequestScopedContextWasNotActive());\n        }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "junit-framework",
    "cve_id": "CVE-2025-53103",
    "cwe_list": [
      "CWE-312"
    ],
    "commit_hash": "d4fc834c8c1c0b3168cd030c13551d1d041f51bc",
    "short_hash": "d4fc834c",
    "vulnerableMethods_before": [
      {
        "filename": "OpenTestReportGeneratingListener.java",
        "method_name": "testPlanExecutionStarted",
        "raw_code": "@Override\n\tpublic void testPlanExecutionStarted(TestPlan testPlan) {\n\t\tConfigurationParameters config = testPlan.getConfigurationParameters();\n\t\tif (isEnabled(config)) {\n\t\t\tNamespaceRegistry namespaceRegistry = NamespaceRegistry.builder(Namespace.REPORTING_CORE) //\n\t\t\t\t\t.add(\"e\", Namespace.REPORTING_EVENTS) //\n\t\t\t\t\t.add(\"git\", Namespace.REPORTING_GIT) //\n\t\t\t\t\t.add(\"java\", Namespace.REPORTING_JAVA) //\n\t\t\t\t\t.add(\"junit\", JUnitFactory.NAMESPACE, \"https://schemas.junit.org/open-test-reporting/junit-1.9.xsd\") //\n\t\t\t\t\t.build();\n\t\t\toutputDir = testPlan.getOutputDirectoryProvider().getRootDirectory();\n\t\t\tPath eventsXml = outputDir.resolve(\"open-test-report.xml\");\n\t\t\ttry {\n\t\t\t\teventsFileWriter = Events.createDocumentWriter(namespaceRegistry, eventsXml);\n\t\t\t\treportInfrastructure();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow new JUnitException(\"Failed to initialize XML events file: \" + eventsXml, e);\n\t\t\t}\n\t\t}\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "OpenTestReportGeneratingListener.java",
        "method_name": "testPlanExecutionStarted",
        "raw_code": "@Override\n\tpublic void testPlanExecutionStarted(TestPlan testPlan) {\n\t\tConfigurationParameters config = testPlan.getConfigurationParameters();\n\t\tif (isEnabled(config)) {\n\t\t\tNamespaceRegistry namespaceRegistry = NamespaceRegistry.builder(Namespace.REPORTING_CORE) //\n\t\t\t\t\t.add(\"e\", Namespace.REPORTING_EVENTS) //\n\t\t\t\t\t.add(\"git\", Namespace.REPORTING_GIT) //\n\t\t\t\t\t.add(\"java\", Namespace.REPORTING_JAVA) //\n\t\t\t\t\t.add(\"junit\", JUnitFactory.NAMESPACE, \"https://schemas.junit.org/open-test-reporting/junit-1.9.xsd\") //\n\t\t\t\t\t.build();\n\t\t\toutputDir = testPlan.getOutputDirectoryProvider().getRootDirectory();\n\t\t\tPath eventsXml = outputDir.resolve(\"open-test-report.xml\");\n\t\t\ttry {\n\t\t\t\teventsFileWriter = Events.createDocumentWriter(namespaceRegistry, eventsXml);\n\t\t\t\treportInfrastructure(config);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow new JUnitException(\"Failed to initialize XML events file: \" + eventsXml, e);\n\t\t\t}\n\t\t}\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "junit-framework",
    "cve_id": "CVE-2025-53103",
    "cwe_list": [
      "CWE-312"
    ],
    "commit_hash": "d4fc834c8c1c0b3168cd030c13551d1d041f51bc",
    "short_hash": "d4fc834c",
    "vulnerableMethods_before": [
      {
        "filename": "OpenTestReportGeneratingListener.java",
        "method_name": "isEnabled",
        "raw_code": "private Boolean isEnabled(ConfigurationParameters config) {\n\t\treturn config.getBoolean(ENABLED_PROPERTY_NAME).orElse(false);\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "OpenTestReportGeneratingListener.java",
        "method_name": "isEnabled",
        "raw_code": "private boolean isEnabled(ConfigurationParameters config) {\n\t\treturn config.getBoolean(ENABLED_PROPERTY_NAME).orElse(false);\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "junit-framework",
    "cve_id": "CVE-2025-53103",
    "cwe_list": [
      "CWE-312"
    ],
    "commit_hash": "d4fc834c8c1c0b3168cd030c13551d1d041f51bc",
    "short_hash": "d4fc834c",
    "vulnerableMethods_before": [
      {
        "filename": "OpenTestReportGeneratingListener.java",
        "method_name": "reportInfrastructure",
        "raw_code": "private void reportInfrastructure() {\n\t\teventsFileWriter.append(infrastructure(), infrastructure -> {\n\t\t\ttry {\n\t\t\t\tString hostName = InetAddress.getLocalHost().getHostName();\n\t\t\t\tinfrastructure.append(hostName(hostName));\n\t\t\t}\n\t\t\tcatch (UnknownHostException ignored) {\n\t\t\t}\n\t\t\tinfrastructure //\n\t\t\t\t\t.append(userName(System.getProperty(\"user.name\"))) //\n\t\t\t\t\t.append(operatingSystem(System.getProperty(\"os.name\"))) //\n\t\t\t\t\t.append(cpuCores(Runtime.getRuntime().availableProcessors())) //\n\t\t\t\t\t.append(javaVersion(System.getProperty(\"java.version\"))) //\n\t\t\t\t\t.append(fileEncoding(System.getProperty(\"file.encoding\"))) //\n\t\t\t\t\t.append(heapSize(), heapSize -> heapSize.withMax(Runtime.getRuntime().maxMemory()));\n\n\t\t\taddGitInfo(infrastructure);\n\t\t});\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "OpenTestReportGeneratingListener.java",
        "method_name": "reportInfrastructure",
        "raw_code": "private void reportInfrastructure(ConfigurationParameters config) {\n\t\teventsFileWriter.append(infrastructure(), infrastructure -> {\n\t\t\ttry {\n\t\t\t\tString hostName = InetAddress.getLocalHost().getHostName();\n\t\t\t\tinfrastructure.append(hostName(hostName));\n\t\t\t}\n\t\t\tcatch (UnknownHostException ignored) {\n\t\t\t}\n\t\t\tinfrastructure //\n\t\t\t\t\t.append(userName(System.getProperty(\"user.name\"))) //\n\t\t\t\t\t.append(operatingSystem(System.getProperty(\"os.name\"))) //\n\t\t\t\t\t.append(cpuCores(Runtime.getRuntime().availableProcessors())) //\n\t\t\t\t\t.append(javaVersion(System.getProperty(\"java.version\"))) //\n\t\t\t\t\t.append(fileEncoding(System.getProperty(\"file.encoding\"))) //\n\t\t\t\t\t.append(heapSize(), heapSize -> heapSize.withMax(Runtime.getRuntime().maxMemory()));\n\n\t\t\tif (isGitEnabled(config)) {\n\t\t\t\tGitInfoCollector.get(workingDir).ifPresent(git -> addGitInfo(infrastructure, git));\n\t\t\t}\n\t\t});\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "junit-framework",
    "cve_id": "CVE-2025-53103",
    "cwe_list": [
      "CWE-312"
    ],
    "commit_hash": "d4fc834c8c1c0b3168cd030c13551d1d041f51bc",
    "short_hash": "d4fc834c",
    "vulnerableMethods_before": [
      {
        "filename": "OpenTestReportGeneratingListener.java",
        "method_name": "addGitInfo",
        "raw_code": "private void addGitInfo(Infrastructure infrastructure) {\n\t\tboolean gitInstalled = exec(\"git\", \"--version\").isPresent();\n\t\tif (gitInstalled) {\n\t\t\texec(\"git\", \"config\", \"--get\", \"remote.origin.url\") //\n\t\t\t\t\t.filter(StringUtils::isNotBlank) //\n\t\t\t\t\t.ifPresent(\n\t\t\t\t\t\tgitUrl -> infrastructure.append(repository(), repository -> repository.withOriginUrl(gitUrl)));\n\t\t\texec(\"git\", \"rev-parse\", \"--abbrev-ref\", \"HEAD\") //\n\t\t\t\t\t.filter(StringUtils::isNotBlank) //\n\t\t\t\t\t.ifPresent(branch -> infrastructure.append(branch(branch)));\n\t\t\texec(\"git\", \"rev-parse\", \"--verify\", \"HEAD\") //\n\t\t\t\t\t.filter(StringUtils::isNotBlank) //\n\t\t\t\t\t.ifPresent(gitCommitHash -> infrastructure.append(commit(gitCommitHash)));\n\t\t\texec(\"git\", \"status\", \"--porcelain\") //\n\t\t\t\t\t.ifPresent(statusOutput -> infrastructure.append(status(statusOutput),\n\t\t\t\t\t\tstatus -> status.withClean(statusOutput.isEmpty())));\n\t\t}\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "OpenTestReportGeneratingListener.java",
        "method_name": "addGitInfo",
        "raw_code": "private void addGitInfo(Infrastructure infrastructure, GitInfoCollector git) {\n\t\tgit.getOriginUrl() //\n\t\t\t\t.ifPresent(\n\t\t\t\t\tgitUrl -> infrastructure.append(repository(), repository -> repository.withOriginUrl(gitUrl)));\n\t\tgit.getBranch() //\n\t\t\t\t.ifPresent(branch -> infrastructure.append(branch(branch)));\n\t\tgit.getCommitHash() //\n\t\t\t\t.ifPresent(gitCommitHash -> infrastructure.append(commit(gitCommitHash)));\n\t\tgit.getStatus() //\n\t\t\t\t.ifPresent(statusOutput -> infrastructure.append(status(statusOutput),\n\t\t\t\t\tstatus -> status.withClean(statusOutput.isEmpty())));\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "junit-framework",
    "cve_id": "CVE-2025-53103",
    "cwe_list": [
      "CWE-312"
    ],
    "commit_hash": "d4fc834c8c1c0b3168cd030c13551d1d041f51bc",
    "short_hash": "d4fc834c",
    "vulnerableMethods_before": [
      {
        "filename": "OpenTestReportGeneratingListenerTests.java",
        "method_name": "executeTests",
        "raw_code": "private void executeTests(Path tempDirectory, TestEngine engine, Path outputDir) {\n\t\tvar build = request() //\n\t\t\t\t.selectors(selectUniqueId(UniqueId.forEngine(engine.getId()))) //\n\t\t\t\t.configurationParameter(ENABLED_PROPERTY_NAME, String.valueOf(true)) //\n\t\t\t\t.configurationParameter(CAPTURE_STDOUT_PROPERTY_NAME, String.valueOf(true)) //\n\t\t\t\t.configurationParameter(CAPTURE_STDERR_PROPERTY_NAME, String.valueOf(true)) //\n\t\t\t\t.configurationParameter(OUTPUT_DIR_PROPERTY_NAME, outputDir.toString()) //\n\t\t\t\t.build();\n\t\tcreateLauncher(engine).execute(build, new OpenTestReportGeneratingListener(tempDirectory));\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "OpenTestReportGeneratingListenerTests.java",
        "method_name": "executeTests",
        "raw_code": "private static void executeTests(Path tempDirectory, TestEngine engine, Path outputDir,\n\t\t\tMap<String, String> extraConfigurationParameters) {\n\t\tvar request = request() //\n\t\t\t\t.selectors(selectUniqueId(UniqueId.forEngine(engine.getId()))) //\n\t\t\t\t.enableImplicitConfigurationParameters(false) //\n\t\t\t\t.configurationParameter(ENABLED_PROPERTY_NAME, String.valueOf(true)) //\n\t\t\t\t.configurationParameter(CAPTURE_STDOUT_PROPERTY_NAME, String.valueOf(true)) //\n\t\t\t\t.configurationParameter(CAPTURE_STDERR_PROPERTY_NAME, String.valueOf(true)) //\n\t\t\t\t.configurationParameter(OUTPUT_DIR_PROPERTY_NAME, outputDir.toString()) //\n\t\t\t\t.configurationParameters(extraConfigurationParameters) //\n\t\t\t\t.build();\n\t\tcreateLauncher(engine).execute(request, new OpenTestReportGeneratingListener(tempDirectory));\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "quarkus",
    "cve_id": "CVE-2025-49574",
    "cwe_list": [
      "CWE-668"
    ],
    "commit_hash": "d1ee57e7b826872b6355cfec0ae13465840e232c",
    "short_hash": "d1ee57e7",
    "vulnerableMethods_before": [
      {
        "filename": "AbstractResponseWrapper.java",
        "method_name": "write",
        "raw_code": "@Override\n\n    public Future<Void> write(String chunk, String enc) {\n        return delegate.write(chunk, enc);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AbstractResponseWrapper.java",
        "method_name": "write",
        "raw_code": "@Override\n\n    public Future<Void> write(String chunk, String enc) {\n        return delegate.write(chunk, enc);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "quarkus",
    "cve_id": "CVE-2025-49574",
    "cwe_list": [
      "CWE-668"
    ],
    "commit_hash": "31e8a3bfcf4e223788615d5ce25eb929ca251275",
    "short_hash": "31e8a3bf",
    "vulnerableMethods_before": [
      {
        "filename": "AbstractResponseWrapper.java",
        "method_name": "write",
        "raw_code": "@Override\n\n    public Future<Void> write(String chunk, String enc) {\n        return delegate.write(chunk, enc);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AbstractResponseWrapper.java",
        "method_name": "write",
        "raw_code": "@Override\n\n    public Future<Void> write(String chunk, String enc) {\n        return delegate.write(chunk, enc);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "esapi-java-legacy",
    "cve_id": "CVE-2025-5878",
    "cwe_list": [
      "CWE-138"
    ],
    "commit_hash": "f75ac2c2647a81d2cfbdc9c899f8719c240ed512",
    "short_hash": "f75ac2c2",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultEncoder.java",
        "method_name": "encodeForSQL",
        "raw_code": "public String encodeForSQL(Codec codec, String input) {\n        if( input == null ) {\n            return null;\n        }\n        return codec.encode(IMMUNE_SQL, input);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultEncoder.java",
        "method_name": "encodeForSQL",
        "raw_code": "@Deprecated\n    public String encodeForSQL(Codec codec, String input) {\n\n        // This will throw if this method is not explicitly enabled in ESAPI.properties.\n        ensureDangerousMethodExplicitlyEnabled( DefaultEncoder.class.getName() + \".encodeForSQL\",\n                                                \"<default>\",\n                                                \"see CVE-2025-5878 and ESAPI Security Bulletin #13 for details\" );\n\n        if( input == null ) {\n            return null;\n        }\n        return codec.encode(IMMUNE_SQL, input);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "esapi-java-legacy",
    "cve_id": "CVE-2025-5878",
    "cwe_list": [
      "CWE-138"
    ],
    "commit_hash": "f75ac2c2647a81d2cfbdc9c899f8719c240ed512",
    "short_hash": "f75ac2c2",
    "vulnerableMethods_before": [
      {
        "filename": "Encoder.java",
        "method_name": "encodeForSQL",
        "raw_code": "String encodeForSQL(Codec codec, String input);",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "Encoder.java",
        "method_name": "encodeForSQL",
        "raw_code": "@Deprecated\n     String encodeForSQL(Codec codec, String input);",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "jeesite5",
    "cve_id": "CVE-2025-7759",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "1c5e49b0818037452148e0f8ff69ed04cb8fefdc",
    "short_hash": "1c5e49b0",
    "vulnerableMethods_before": [
      {
        "filename": "FileTempleteUtils.java",
        "method_name": "getFileTempleteByResource",
        "raw_code": "public static FileTemplete getFileTempleteByResource(String fileName) throws IOException {\n\t\tResource resource = ResourceUtils.getResource(fileName);\n\t\treturn new FileTemplete(resource, fileName);\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FileTempleteUtils.java",
        "method_name": "getFileTempleteByResource",
        "raw_code": "public static FileTemplete getFileTempleteByResource(String fileName) {\n\t\tif (!StringUtils.startsWith(fileName, \"views/modules/cmsfront\")) {\n\t\t\tfileName = \"views/modules/cmsfront/themes/default/index.html\";\n\t\t}\n\t\tResource resource = ResourceUtils.getResource(fileName);\n\t\treturn new FileTemplete(resource, fileName);\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "jeesite5",
    "cve_id": "CVE-2025-7759",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "1c5e49b0818037452148e0f8ff69ed04cb8fefdc",
    "short_hash": "1c5e49b0",
    "vulnerableMethods_before": [
      {
        "filename": "ActionEnter.java",
        "method_name": "invoke",
        "raw_code": "public String invoke() {\n        if (actionType == null || !ActionMap.mapping.containsKey(actionType)) {\n            return new BaseState(false, AppInfo.INVALID_ACTION).toJSONString();\n        }\n        if (this.configManager == null || !this.configManager.valid()) {\n            return new BaseState(false, AppInfo.CONFIG_ERROR).toJSONString();\n        }\n        State state = null;\n        int actionCode = ActionMap.getType(this.actionType);\n        Map<String, Object> conf = null;\n        switch (actionCode) {\n            case ActionMap.CONFIG:\n                return this.configManager.getAllConfig().toString();\n            case ActionMap.UPLOAD_IMAGE:\n            case ActionMap.UPLOAD_SCRAWL:\n            case ActionMap.UPLOAD_VIDEO:\n            case ActionMap.UPLOAD_FILE:\n                if (Global.isDemoMode()) {\n                    state = new BaseState(false, \"演示模式，不允许操作！\");\n                    break;\n                }\n                conf = this.configManager.getConfig(actionCode);\n                state = new Uploader(request, conf).doExec();\n                break;\n            case ActionMap.CATCH_IMAGE:\n                if (Global.isDemoMode()) {\n                    state = new BaseState(false, \"演示模式，不允许操作！\");\n                    break;\n                }\n                conf = configManager.getConfig(actionCode);\n                String[] list = this.request.getParameterValues((String) conf.get(\"fieldName\"));\n                state = new ImageHunter(request, conf).capture(list);\n                break;\n            case ActionMap.LIST_IMAGE:\n            case ActionMap.LIST_FILE:\n                if (Global.isDemoMode()) {\n                    state = new BaseState(false, \"演示模式，不允许操作！\");\n                    break;\n                }\n                conf = configManager.getConfig(actionCode);\n                int start = this.getStartIndex();\n                state = new FileManager(conf).listFile(this.request, start);\n                break;\n        }\n        return state.toJSONString();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ActionEnter.java",
        "method_name": "invoke",
        "raw_code": "public String invoke() {\n        if (actionType == null || !ActionMap.mapping.containsKey(actionType)) {\n            return new BaseState(false, AppInfo.INVALID_ACTION).toJSONString();\n        }\n        if (this.configManager == null || !this.configManager.valid()) {\n            return new BaseState(false, AppInfo.CONFIG_ERROR).toJSONString();\n        }\n        State state = null;\n        int actionCode = ActionMap.getType(this.actionType);\n        Map<String, Object> conf = null;\n        switch (actionCode) {\n            case ActionMap.CONFIG:\n                return this.configManager.getAllConfig().toString();\n            case ActionMap.UPLOAD_IMAGE:\n            case ActionMap.UPLOAD_SCRAWL:\n            case ActionMap.UPLOAD_VIDEO:\n            case ActionMap.UPLOAD_FILE:\n                if (Global.isDemoMode()) {\n                    state = new BaseState(false, \"演示模式，不允许操作！\");\n                    break;\n                }\n                conf = this.configManager.getConfig(actionCode);\n                state = new Uploader(request, conf).doExec();\n                break;\n            case ActionMap.CATCH_IMAGE:\n//                if (Global.isDemoMode()) {\n//                    state = new BaseState(false, \"演示模式，不允许操作！\");\n//                    break;\n//                }\n//                conf = configManager.getConfig(actionCode);\n//                String[] list = this.request.getParameterValues((String) conf.get(\"fieldName\"));\n//                state = new ImageHunter(request, conf).capture(list);\n\t\t\t\tstate = new BaseState(false, \"该功能暂不提供支持\");\n                break;\n            case ActionMap.LIST_IMAGE:\n            case ActionMap.LIST_FILE:\n                if (Global.isDemoMode()) {\n                    state = new BaseState(false, \"演示模式，不允许操作！\");\n                    break;\n                }\n                conf = configManager.getConfig(actionCode);\n                int start = this.getStartIndex();\n                state = new FileManager(conf).listFile(this.request, start);\n                break;\n        }\n        return state.toJSONString();\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "jeesite5",
    "cve_id": "CVE-2025-7864",
    "cwe_list": [
      "CWE-434"
    ],
    "commit_hash": "3585737d21fe490ff6948d913fcbd8d99c41fc08",
    "short_hash": "3585737d",
    "vulnerableMethods_before": [
      {
        "filename": "EncodeUtilsTest.java",
        "method_name": "main",
        "raw_code": "public static void main(String[] args) {\n\t\tEncodeUtils.xssFilter(\"1 你好 <script>alert(document.cookie)</script>我还在。\");\n\t\tEncodeUtils.xssFilter(\"2 你好 <strong>加粗文字</strong>我还在。\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->3 你好 \\\"><strong>加粗文字</strong>我还在。\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->4 你好 <iframe src=\\\"abcdef\\\"></iframe><strong>加粗文字</strong>我还在。\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->5 你好 <iframe src=\\\"abcdef\\\"/><strong>加粗文字</strong>我还在。\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->6 你好 <iframe src=\\\"abcdef\\\"><strong>加粗文字</strong>我还在。\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->7 你好 <script type=\\\"text/javascript\\\">alert(document.cookie)</script>我还在。\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->8 你好 <script\\n type=\\\"text/javascript\\\">\\nalert(document.cookie)\\n</script>我还在。\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->9 你好 <script src='' onerror='alert(document.cookie)'></script>我还在。\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->10 你好 <script type=text/javascript>alert()我还在。\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->11 你好 <script>alert(document.cookie)</script>我还在。\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->12 你好 <script>window.location='url'我还在。\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->13 你好 </script></iframe>我还在。\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->14 你好 eval(abc)我还在。\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->15 你好 expression(abc)我还在。\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->16 你好 <img src='abc.jpg' onerror='location='';alert(document.cookie);'></img>我还在。\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->17 你好 <img src='abc.jpg' onerror='alert(document.cookie);'/>我还在。\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->18 你好 <img src='abc.jpg' onerror='alert(document.cookie);'>我还在。\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->19 你好 <a onload='alert(\\\"abc\\\")'>hello</a>我还在。\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->20 你好 <a href=\\\"/abc\\\">hello</a>我还在。\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->21 你好 <a href='/abc'>hello</a>我还在。\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->22 你好 <a href='vbscript:alert(\\\"abc\\\");'>hello</a>我还在。\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->23 你好 <a href='javascript:alert(\\\"abc\\\");'>hello</a>我还在。\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->24 你好 ?abc=def&hello=123&world={\\\"a\\\":1}我还在。\");\n\t\tEncodeUtils.xssFilter(\"<!--HTML-->25 你好 ?abc=def&hello=123&world={'a':1}我还在。\");\n\t\tEncodeUtils.sqlFilter(\"1 你好 select * from xxx where abc=def and 1=1我还在。\");\n\t\tEncodeUtils.sqlFilter(\"2 你好 insert into xxx values(1,2,3,4,5)我还在。\");\n\t\tEncodeUtils.sqlFilter(\"3 你好 delete from xxx我还在。\");\n\t\tEncodeUtils.sqlFilter(\"4 a.audit_result asc,case when 1 like case when length(database())=6 then 1 else exp(111) end then 1 else 1/0 end\", \"orderBy\");\n\t\tEncodeUtils.sqlFilter(\"5 if(1=2,1,SLEEP(10)), if(mid(database(),{},1)=\\\\\\\"{}\\\\\\\",a.id,a.login_name)\", \"orderBy\");\n\t\tEncodeUtils.sqlFilter(\"6 a.audit_result asc, b.audit_result2 desc, b.AuditResult3 desc\", \"orderBy\");\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "EncodeUtilsTest.java",
        "method_name": "main",
        "raw_code": "public static void main(String[] args) {\n\t\tint i = 0;\n\t\txssFilter(i++, \"你好 <script>alert(document.cookie)</script>我还在。\");\n\t\txssFilter(i++, \"你好 <strong>加粗文字</strong>我还在。\");\n\t\txssFilter(i++, \"<!--HTML-->你好 \\\"><strong>加粗文字</strong>我还在。\");\n\t\txssFilter(i++, \"<!--HTML-->你好 <iframe src=\\\"abcdef\\\"></iframe><strong>加粗文字</strong>我还在。\");\n\t\txssFilter(i++, \"<!--HTML-->你好 <iframe src=\\\"abcdef\\\"/><strong>加粗文字</strong>我还在。\");\n\t\txssFilter(i++, \"<!--HTML-->你好 <iframe src=\\\"abcdef\\\"><strong>加粗文字</strong>我还在。\");\n\t\txssFilter(i++, \"<!--HTML-->你好 <script type=\\\"text/javascript\\\">alert(document.cookie)</script>我还在。\");\n\t\txssFilter(i++, \"<!--HTML-->你好 <script\\n type=\\\"text/javascript\\\">\\nalert(document.cookie)\\n</script>我还在。\");\n\t\txssFilter(i++, \"<!--HTML-->你好 <script src='' onerror='alert(document.cookie)'></script>我还在。\");\n\t\txssFilter(i++, \"<!--HTML-->你好 <script type=text/javascript>alert()我还在。\");\n\t\txssFilter(i++, \"<!--HTML-->你好 <script>alert(document.cookie)</script>我还在。\");\n\t\txssFilter(i++, \"<!--HTML-->你好 <script>window.location='url'我还在。\");\n\t\txssFilter(i++, \"<!--HTML-->你好 </script></iframe>我还在。\");\n\t\txssFilter(i++, \"<!--HTML-->你好 eval(abc)我还在。\");\n\t\txssFilter(i++, \"<!--HTML-->你好 expression(abc)我还在。\");\n\t\txssFilter(i++, \"<!--HTML-->你好 <img src='abc.jpg' onerror='location='';alert(document.cookie);'></img>我还在。\");\n\t\txssFilter(i++, \"<!--HTML-->你好 <img src='abc.jpg' onerror='alert(document.cookie);'/>我还在。\");\n\t\txssFilter(i++, \"<!--HTML-->你好 <img src='abc.jpg' onerror='alert(document.cookie);'>我还在。\");\n\t\txssFilter(i++, \"<!--HTML-->你好 <a onload='alert(\\\"abc\\\")'>hello</a>我还在。\");\n\t\txssFilter(i++, \"<!--HTML-->你好 <a href=\\\"/abc\\\">hello</a>我还在。\");\n\t\txssFilter(i++, \"<!--HTML-->你好 <a href='/abc'>hello</a>我还在。\");\n\t\txssFilter(i++, \"<!--HTML-->你好 <a href='vbscript:alert(\\\"abc\\\");'>hello</a>我还在。\");\n\t\txssFilter(i++, \"<!--HTML-->你好 <a href='javascript:alert(\\\"abc\\\");'>hello</a>我还在。\");\n\t\txssFilter(i++, \"<!--HTML-->你好 ?abc=def&hello=123&world={\\\"a\\\":1}我还在。\");\n\t\txssFilter(i++, \"<!--HTML-->你好 ?abc=def&hello=123&world={'a':1}我还在。\");\n\t\txssFilter(i++, \"<!--HTML-->\\\"><svg/ONLOAD=confirm(3) />\");\n\t\tsqlFilter(i++, \"你好 select * from xxx where abc=def and 1=1我还在。\", \"common\");\n\t\tsqlFilter(i++, \"你好 insert into xxx values(1,2,3,4,5)我还在。\", \"common\");\n\t\tsqlFilter(i++, \"你好 delete from xxx我还在。\", \"common\");\n\t\tsqlFilter(i++, \"a.audit_result asc,case when 1 like case when length(database())=6 then 1 else exp(111) end then 1 else 1/0 end\", \"orderBy\");\n\t\tsqlFilter(i++, \"if(1=2,1,SLEEP(10)), if(mid(database(),{},1)=\\\\\\\"{}\\\\\\\",a.id,a.login_name)\", \"orderBy\");\n\t\tsqlFilter(i++, \"a.audit_result asc, b.audit_result2 desc, b.AuditResult3 desc\", \"orderBy\");\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  }
]