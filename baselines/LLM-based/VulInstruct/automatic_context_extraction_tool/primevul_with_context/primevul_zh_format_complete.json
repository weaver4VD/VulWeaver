[
  {
    "repository": "tensorflow",
    "cve_id": "CVE-2022-21734",
    "cwe_list": [
      "CWE-843"
    ],
    "commit_hash": "f57315566d7094f322b784947093406c2aea0d7d",
    "short_hash": "f5731556",
    "vulnerableMethods_before": [
      {
        "filename": "map_stage_op.cc",
        "method_name": "vulnerable_function",
        "raw_code": "  void Compute(OpKernelContext* ctx) override {\n    StagingMap<Ordered>* map = nullptr;\n    OP_REQUIRES_OK(ctx, GetStagingMap(ctx, def(), &map));\n    core::ScopedUnref scope(map);\n    typename StagingMap<Ordered>::OptionalTuple tuple;\n\n    const Tensor* key_tensor;\n    const Tensor* indices_tensor;\n    OpInputList values_tensor;\n\n    OP_REQUIRES_OK(ctx, ctx->input(\"key\", &key_tensor));\n    OP_REQUIRES_OK(ctx, ctx->input(\"indices\", &indices_tensor));\n    OP_REQUIRES_OK(ctx, ctx->input_list(\"values\", &values_tensor));\n    OP_REQUIRES(ctx, key_tensor->NumElements() > 0,\n                errors::InvalidArgument(\"key must not be empty\"));\n\n    // Create copy for insertion into Staging Area\n    Tensor key(*key_tensor);\n\n    // Create the tuple to store\n    for (std::size_t i = 0; i < values_tensor.size(); ++i) {\n      tuple.push_back(values_tensor[i]);\n    }\n\n    // Store the tuple in the map\n    OP_REQUIRES_OK(ctx, map->put(&key, indices_tensor, &tuple));\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "map_stage_op.cc",
        "method_name": "fixed_function",
        "raw_code": "  void Compute(OpKernelContext* ctx) override {\n    StagingMap<Ordered>* map = nullptr;\n    OP_REQUIRES_OK(ctx, GetStagingMap(ctx, def(), &map));\n    core::ScopedUnref scope(map);\n    typename StagingMap<Ordered>::OptionalTuple tuple;\n\n    const Tensor* key_tensor;\n    const Tensor* indices_tensor;\n    OpInputList values_tensor;\n\n    OP_REQUIRES_OK(ctx, ctx->input(\"key\", &key_tensor));\n    OP_REQUIRES_OK(ctx, ctx->input(\"indices\", &indices_tensor));\n    OP_REQUIRES_OK(ctx, ctx->input_list(\"values\", &values_tensor));\n    OP_REQUIRES(ctx, key_tensor->NumElements() > 0,\n                errors::InvalidArgument(\"key must not be empty\"));\n\n    OP_REQUIRES(ctx, key_tensor->NumElements() == 1,\n                errors::InvalidArgument(\n                    \"key must be an int64 scalar, got tensor with shape: \",\n                    key_tensor->shape()));\n\n    // Create copy for insertion into Staging Area\n    Tensor key(*key_tensor);\n\n    // Create the tuple to store\n    for (std::size_t i = 0; i < values_tensor.size(); ++i) {\n      tuple.push_back(values_tensor[i]);\n    }\n\n    // Store the tuple in the map\n    OP_REQUIRES_OK(ctx, map->put(&key, indices_tensor, &tuple));\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "vim",
    "cve_id": "CVE-2022-2580",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "1e56bda9048a9625bce6e660938c834c5c15b07d",
    "short_hash": "1e56bda9",
    "vulnerableMethods_before": [
      {
        "filename": "typval.c",
        "method_name": "vulnerable_function",
        "raw_code": "eval_string(char_u **arg, typval_T *rettv, int evaluate, int interpolate)\n{\n    char_u\t*p;\n    char_u\t*end;\n    int\t\textra = interpolate ? 1 : 0;\n    int\t\toff = interpolate ? 0 : 1;\n    int\t\tlen;\n\n    // Find the end of the string, skipping backslashed characters.\n    for (p = *arg + off; *p != NUL && *p != '\"'; MB_PTR_ADV(p))\n    {\n\tif (*p == '\\\\' && p[1] != NUL)\n\t{\n\t    ++p;\n\t    // A \"\\<x>\" form occupies at least 4 characters, and produces up\n\t    // to 9 characters (6 for the char and 3 for a modifier):\n\t    // reserve space for 5 extra.\n\t    if (*p == '<')\n\t\textra += 5;\n\t}\n\telse if (interpolate && (*p == '{' || *p == '}'))\n\t{\n\t    if (*p == '{' && p[1] != '{') // start of expression\n\t\tbreak;\n\t    ++p;\n\t    if (p[-1] == '}' && *p != '}') // single '}' is an error\n\t    {\n\t\tsemsg(_(e_stray_closing_curly_str), *arg);\n\t\treturn FAIL;\n\t    }\n\t    --extra;  // \"{{\" becomes \"{\", \"}}\" becomes \"}\"\n\t}\n    }\n\n    if (*p != '\"' && !(interpolate && *p == '{'))\n    {\n\tsemsg(_(e_missing_double_quote_str), *arg);\n\treturn FAIL;\n    }\n\n    // If only parsing, set *arg and return here\n    if (!evaluate)\n    {\n\t*arg = p + off;\n\treturn OK;\n    }\n\n    // Copy the string into allocated memory, handling backslashed\n    // characters.\n    rettv->v_type = VAR_STRING;\n    len = (int)(p - *arg + extra);\n    rettv->vval.v_string = alloc(len);\n    if (rettv->vval.v_string == NULL)\n\treturn FAIL;\n    end = rettv->vval.v_string;\n\n    for (p = *arg + off; *p != NUL && *p != '\"'; )\n    {\n\tif (*p == '\\\\')\n\t{\n\t    switch (*++p)\n\t    {\n\t\tcase 'b': *end++ = BS; ++p; break;\n\t\tcase 'e': *end++ = ESC; ++p; break;\n\t\tcase 'f': *end++ = FF; ++p; break;\n\t\tcase 'n': *end++ = NL; ++p; break;\n\t\tcase 'r': *end++ = CAR; ++p; break;\n\t\tcase 't': *end++ = TAB; ++p; break;\n\n\t\tcase 'X': // hex: \"\\x1\", \"\\x12\"\n\t\tcase 'x':\n\t\tcase 'u': // Unicode: \"\\u0023\"\n\t\tcase 'U':\n\t\t\t  if (vim_isxdigit(p[1]))\n\t\t\t  {\n\t\t\t      int\tn, nr;\n\t\t\t      int\tc = toupper(*p);\n\n\t\t\t      if (c == 'X')\n\t\t\t\t  n = 2;\n\t\t\t      else if (*p == 'u')\n\t\t\t\t  n = 4;\n\t\t\t      else\n\t\t\t\t  n = 8;\n\t\t\t      nr = 0;\n\t\t\t      while (--n >= 0 && vim_isxdigit(p[1]))\n\t\t\t      {\n\t\t\t\t  ++p;\n\t\t\t\t  nr = (nr << 4) + hex2nr(*p);\n\t\t\t      }\n\t\t\t      ++p;\n\t\t\t      // For \"\\u\" store the number according to\n\t\t\t      // 'encoding'.\n\t\t\t      if (c != 'X')\n\t\t\t\t  end += (*mb_char2bytes)(nr, end);\n\t\t\t      else\n\t\t\t\t  *end++ = nr;\n\t\t\t  }\n\t\t\t  break;\n\n\t\t\t  // octal: \"\\1\", \"\\12\", \"\\123\"\n\t\tcase '0':\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '4':\n\t\tcase '5':\n\t\tcase '6':\n\t\tcase '7': *end = *p++ - '0';\n\t\t\t  if (*p >= '0' && *p <= '7')\n\t\t\t  {\n\t\t\t      *end = (*end << 3) + *p++ - '0';\n\t\t\t      if (*p >= '0' && *p <= '7')\n\t\t\t\t  *end = (*end << 3) + *p++ - '0';\n\t\t\t  }\n\t\t\t  ++end;\n\t\t\t  break;\n\n\t\t\t  // Special key, e.g.: \"\\<C-W>\"\n\t\tcase '<':\n\t\t\t  {\n\t\t\t      int flags = FSK_KEYCODE | FSK_IN_STRING;\n\n\t\t\t      if (p[1] != '*')\n\t\t\t\t  flags |= FSK_SIMPLIFY;\n\t\t\t      extra = trans_special(&p, end, flags, FALSE, NULL);\n\t\t\t      if (extra != 0)\n\t\t\t      {\n\t\t\t\t  end += extra;\n\t\t\t\t  if (end >= rettv->vval.v_string + len)\n\t\t\t\t      iemsg(\"eval_string() used more space than allocated\");\n\t\t\t\t  break;\n\t\t\t      }\n\t\t\t  }\n\t\t\t  // FALLTHROUGH\n\n\t\tdefault: MB_COPY_CHAR(p, end);\n\t\t\t  break;\n\t    }\n\t}\n\telse\n\t{\n\t    if (interpolate && (*p == '{' || *p == '}'))\n\t    {\n\t\tif (*p == '{' && p[1] != '{') // start of expression\n\t\t    break;\n\t\t++p;  // reduce \"{{\" to \"{\" and \"}}\" to \"}\"\n\t    }\n\t    MB_COPY_CHAR(p, end);\n\t}\n    }\n    *end = NUL;\n    if (*p == '\"' && !interpolate)\n\t++p;\n    *arg = p;\n\n    return OK;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "typval.c",
        "method_name": "fixed_function",
        "raw_code": "eval_string(char_u **arg, typval_T *rettv, int evaluate, int interpolate)\n{\n    char_u\t*p;\n    char_u\t*end;\n    int\t\textra = interpolate ? 1 : 0;\n    int\t\toff = interpolate ? 0 : 1;\n    int\t\tlen;\n\n    // Find the end of the string, skipping backslashed characters.\n    for (p = *arg + off; *p != NUL && *p != '\"'; MB_PTR_ADV(p))\n    {\n\tif (*p == '\\\\' && p[1] != NUL)\n\t{\n\t    ++p;\n\t    // A \"\\<x>\" form occupies at least 4 characters, and produces up\n\t    // to 9 characters (6 for the char and 3 for a modifier):\n\t    // reserve space for 5 extra.\n\t    if (*p == '<')\n\t    {\n\t\tint\t\tmodifiers = 0;\n\t\tint\t\tflags = FSK_KEYCODE | FSK_IN_STRING;\n\n\t\textra += 5;\n\n\t\t// Skip to the '>' to avoid using '{' inside for string\n\t\t// interpolation.\n\t\tif (p[1] != '*')\n\t\t    flags |= FSK_SIMPLIFY;\n\t\tif (find_special_key(&p, &modifiers, flags, NULL) != 0)\n\t\t    --p;  // leave \"p\" on the \">\"\n\t    }\n\t}\n\telse if (interpolate && (*p == '{' || *p == '}'))\n\t{\n\t    if (*p == '{' && p[1] != '{') // start of expression\n\t\tbreak;\n\t    ++p;\n\t    if (p[-1] == '}' && *p != '}') // single '}' is an error\n\t    {\n\t\tsemsg(_(e_stray_closing_curly_str), *arg);\n\t\treturn FAIL;\n\t    }\n\t    --extra;  // \"{{\" becomes \"{\", \"}}\" becomes \"}\"\n\t}\n    }\n\n    if (*p != '\"' && !(interpolate && *p == '{'))\n    {\n\tsemsg(_(e_missing_double_quote_str), *arg);\n\treturn FAIL;\n    }\n\n    // If only parsing, set *arg and return here\n    if (!evaluate)\n    {\n\t*arg = p + off;\n\treturn OK;\n    }\n\n    // Copy the string into allocated memory, handling backslashed\n    // characters.\n    rettv->v_type = VAR_STRING;\n    len = (int)(p - *arg + extra);\n    rettv->vval.v_string = alloc(len);\n    if (rettv->vval.v_string == NULL)\n\treturn FAIL;\n    end = rettv->vval.v_string;\n\n    for (p = *arg + off; *p != NUL && *p != '\"'; )\n    {\n\tif (*p == '\\\\')\n\t{\n\t    switch (*++p)\n\t    {\n\t\tcase 'b': *end++ = BS; ++p; break;\n\t\tcase 'e': *end++ = ESC; ++p; break;\n\t\tcase 'f': *end++ = FF; ++p; break;\n\t\tcase 'n': *end++ = NL; ++p; break;\n\t\tcase 'r': *end++ = CAR; ++p; break;\n\t\tcase 't': *end++ = TAB; ++p; break;\n\n\t\tcase 'X': // hex: \"\\x1\", \"\\x12\"\n\t\tcase 'x':\n\t\tcase 'u': // Unicode: \"\\u0023\"\n\t\tcase 'U':\n\t\t\t  if (vim_isxdigit(p[1]))\n\t\t\t  {\n\t\t\t      int\tn, nr;\n\t\t\t      int\tc = toupper(*p);\n\n\t\t\t      if (c == 'X')\n\t\t\t\t  n = 2;\n\t\t\t      else if (*p == 'u')\n\t\t\t\t  n = 4;\n\t\t\t      else\n\t\t\t\t  n = 8;\n\t\t\t      nr = 0;\n\t\t\t      while (--n >= 0 && vim_isxdigit(p[1]))\n\t\t\t      {\n\t\t\t\t  ++p;\n\t\t\t\t  nr = (nr << 4) + hex2nr(*p);\n\t\t\t      }\n\t\t\t      ++p;\n\t\t\t      // For \"\\u\" store the number according to\n\t\t\t      // 'encoding'.\n\t\t\t      if (c != 'X')\n\t\t\t\t  end += (*mb_char2bytes)(nr, end);\n\t\t\t      else\n\t\t\t\t  *end++ = nr;\n\t\t\t  }\n\t\t\t  break;\n\n\t\t\t  // octal: \"\\1\", \"\\12\", \"\\123\"\n\t\tcase '0':\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '4':\n\t\tcase '5':\n\t\tcase '6':\n\t\tcase '7': *end = *p++ - '0';\n\t\t\t  if (*p >= '0' && *p <= '7')\n\t\t\t  {\n\t\t\t      *end = (*end << 3) + *p++ - '0';\n\t\t\t      if (*p >= '0' && *p <= '7')\n\t\t\t\t  *end = (*end << 3) + *p++ - '0';\n\t\t\t  }\n\t\t\t  ++end;\n\t\t\t  break;\n\n\t\t\t  // Special key, e.g.: \"\\<C-W>\"\n\t\tcase '<':\n\t\t\t  {\n\t\t\t      int flags = FSK_KEYCODE | FSK_IN_STRING;\n\n\t\t\t      if (p[1] != '*')\n\t\t\t\t  flags |= FSK_SIMPLIFY;\n\t\t\t      extra = trans_special(&p, end, flags, FALSE, NULL);\n\t\t\t      if (extra != 0)\n\t\t\t      {\n\t\t\t\t  end += extra;\n\t\t\t\t  if (end >= rettv->vval.v_string + len)\n\t\t\t\t      iemsg(\"eval_string() used more space than allocated\");\n\t\t\t\t  break;\n\t\t\t      }\n\t\t\t  }\n\t\t\t  // FALLTHROUGH\n\n\t\tdefault: MB_COPY_CHAR(p, end);\n\t\t\t  break;\n\t    }\n\t}\n\telse\n\t{\n\t    if (interpolate && (*p == '{' || *p == '}'))\n\t    {\n\t\tif (*p == '{' && p[1] != '{') // start of expression\n\t\t    break;\n\t\t++p;  // reduce \"{{\" to \"{\" and \"}}\" to \"}\"\n\t    }\n\t    MB_COPY_CHAR(p, end);\n\t}\n    }\n    *end = NUL;\n    if (*p == '\"' && !interpolate)\n\t++p;\n    *arg = p;\n\n    return OK;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"vim.h\"\n\n// Type Definitions:\n// char_u:\ntypedef unsigned char\tchar_u;\n\n// typval_T:\ntypedef struct\n{\n    vartype_T\tv_type;\n    char\tv_lock;\t    // see below: VAR_LOCKED, VAR_FIXED\n    union\n    {\n\tvarnumber_T\tv_number;\t// number value\n#ifdef FEAT_FLOAT\n\tfloat_T\t\tv_float;\t// floating number value\n#endif\n\tchar_u\t\t*v_string;\t// string value (can be NULL!)\n\tlist_T\t\t*v_list;\t// list value (can be NULL!)\n\tdict_T\t\t*v_dict;\t// dict value (can be NULL!)\n\tpartial_T\t*v_partial;\t// closure: function with args\n#ifdef FEAT_JOB_CHANNEL\n\tjob_T\t\t*v_job;\t\t// job value (can be NULL!)\n\tchannel_T\t*v_channel;\t// channel value (can be NULL!)\n#endif\n\tblob_T\t\t*v_blob;\t// blob value (can be NULL!)\n\tinstr_T\t\t*v_instr;\t// instructions to execute\n    }\t\tvval;\n}\n\n// Called Methods (top 10):\n// trans_special from src/misc2.c:\nint\ntrans_special(\n    char_u\t**srcp,\n    char_u\t*dst,\n    int\t\tflags,\t\t// FSK_ values\n    int\t\tescape_ks,\t// escape K_SPECIAL bytes in the character\n    int\t\t*did_simplify)  // FSK_SIMPLIFY and found <C-H> or <A-x>\n{\n    int\t\tmodifiers = 0;\n    int\t\tkey;\n\n    key = find_special_key(srcp, &modifiers, flags, did_simplify);\n    if (key == 0)\n\treturn 0;\n\n    return special_to_buf(key, modifiers, escape_ks, dst);\n}\n\n// MB_PTR_ADV from src/macros.h:\n<empty>\n\n// alloc from src/alloc.c:\nvoid *\nalloc(size_t size)\n{\n    return lalloc(size, TRUE);\n}\n\n// CAR from src/ascii.h:\n<empty>\n\n// MB_COPY_CHAR from src/macros.h:\n<empty>\n\n// mb_copy_char from src/mbyte.c:\nvoid\nmb_copy_char(char_u **fp, char_u **tp)\n{\n    int\t    l = (*mb_ptr2len)(*fp);\n\n    mch_memmove(*tp, *fp, (size_t)l);\n    *tp += l;\n    *fp += l;\n}\n\n// semsg from src/message.c:\nint\nsemsg(const char *s, ...)\n{\n    // Skip this if not giving error messages at the moment.\n    if (!emsg_not_now())\n    {\n\tif (IObuff == NULL)\n\t{\n\t    // Very early in initialisation and already something wrong, just\n\t    // give the raw message so the user at least gets a hint.\n\t    return emsg_core((char_u *)s);\n\t}\n\telse\n\t{\n\t    va_list ap;\n\n\t    va_start(ap, s);\n\t    vim_vsnprintf((char *)IObuff, IOSIZE, s, ap);\n\t    va_end(ap);\n\t    return emsg_core(IObuff);\n\t}\n    }\n    return TRUE;\t\t// no error messages at the moment\n}\n\n// ESC from src/ascii.h:\n<empty>\n\n// iemsg from src/message.c:\nvoid\niemsg(char *s)\n{\n    if (!emsg_not_now())\n    {\n\temsg_core((char_u *)s);\n#if defined(ABORT_ON_INTERNAL_ERROR) && defined(FEAT_EVAL)\n\tset_vim_var_string(VV_ERRMSG, (char_u *)s, -1);\n\tabort();\n#endif\n    }\n}\n\n// FALSE from src/vim.h:\n<empty>\n"
  },
  {
    "repository": "LibRaw",
    "cve_id": "CVE-2015-3885",
    "cwe_list": [
      "CWE-189"
    ],
    "commit_hash": "4606c28f494a750892c5c1ac7903e62dd1c6fdb5",
    "short_hash": "4606c28f",
    "vulnerableMethods_before": [
      {
        "filename": "dcraw.c",
        "method_name": "vulnerable_function",
        "raw_code": "int CLASS ljpeg_start (struct jhead *jh, int info_only)\n{\n  int c, tag, len;\n  uchar data[0x10000];\n  const uchar *dp;\n\n  memset (jh, 0, sizeof *jh);\n  jh->restart = INT_MAX;\n  fread (data, 2, 1, ifp);\n  if (data[1] != 0xd8) return 0;\n  do {\n    fread (data, 2, 2, ifp);\n    tag =  data[0] << 8 | data[1];\n    len = (data[2] << 8 | data[3]) - 2;\n    if (tag <= 0xff00) return 0;\n    fread (data, 1, len, ifp);\n    switch (tag) {\n      case 0xffc3:\n\tjh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;\n      case 0xffc0:\n\tjh->bits = data[0];\n\tjh->high = data[1] << 8 | data[2];\n\tjh->wide = data[3] << 8 | data[4];\n\tjh->clrs = data[5] + jh->sraw;\n\tif (len == 9 && !dng_version) getc(ifp);\n\tbreak;\n      case 0xffc4:\n\tif (info_only) break;\n\tfor (dp = data; dp < data+len && (c = *dp++) < 4; )\n\t  jh->free[c] = jh->huff[c] = make_decoder_ref (&dp);\n\tbreak;\n      case 0xffda:\n\tjh->psv = data[1+data[0]*2];\n\tjh->bits -= data[3+data[0]*2] & 15;\n\tbreak;\n      case 0xffdd:\n\tjh->restart = data[0] << 8 | data[1];\n    }\n  } while (tag != 0xffda);\n  if (info_only) return 1;\n  if (jh->clrs > 6 || !jh->huff[0]) return 0;\n  FORC(5) if (!jh->huff[c+1]) jh->huff[c+1] = jh->huff[c];\n  if (jh->sraw) {\n    FORC(4)        jh->huff[2+c] = jh->huff[1];\n    FORC(jh->sraw) jh->huff[1+c] = jh->huff[0];\n  }\n  jh->row = (ushort *) calloc (jh->wide*jh->clrs, 4);\n  merror (jh->row, \"ljpeg_start()\");\n  return zero_after_ff = 1;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "None",
        "method_name": "fixed_function",
        "raw_code": "int CLASS ljpeg_start (struct jhead *jh, int info_only)\n{\n  int c, tag;\n  ushort len;\n  uchar data[0x10000];\n  const uchar *dp;\n\n  memset (jh, 0, sizeof *jh);\n  jh->restart = INT_MAX;\n  fread (data, 2, 1, ifp);\n  if (data[1] != 0xd8) return 0;\n  do {\n    fread (data, 2, 2, ifp);\n    tag =  data[0] << 8 | data[1];\n    len = (data[2] << 8 | data[3]) - 2;\n    if (tag <= 0xff00) return 0;\n    fread (data, 1, len, ifp);\n    switch (tag) {\n      case 0xffc3:\n\tjh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;\n      case 0xffc0:\n\tjh->bits = data[0];\n\tjh->high = data[1] << 8 | data[2];\n\tjh->wide = data[3] << 8 | data[4];\n\tjh->clrs = data[5] + jh->sraw;\n\tif (len == 9 && !dng_version) getc(ifp);\n\tbreak;\n      case 0xffc4:\n\tif (info_only) break;\n\tfor (dp = data; dp < data+len && (c = *dp++) < 4; )\n\t  jh->free[c] = jh->huff[c] = make_decoder_ref (&dp);\n\tbreak;\n      case 0xffda:\n\tjh->psv = data[1+data[0]*2];\n\tjh->bits -= data[3+data[0]*2] & 15;\n\tbreak;\n      case 0xffdd:\n\tjh->restart = data[0] << 8 | data[1];\n    }\n  } while (tag != 0xffda);\n  if (info_only) return 1;\n  if (jh->clrs > 6 || !jh->huff[0]) return 0;\n  FORC(5) if (!jh->huff[c+1]) jh->huff[c+1] = jh->huff[c];\n  if (jh->sraw) {\n    FORC(4)        jh->huff[2+c] = jh->huff[1];\n    FORC(jh->sraw) jh->huff[1+c] = jh->huff[0];\n  }\n  jh->row = (ushort *) calloc (jh->wide*jh->clrs, 4);\n  merror (jh->row, \"ljpeg_start()\");\n  return zero_after_ff = 1;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <time.h>\n#include <jasper/jasper.h>\n#include <stdlib.h>\n#include <utime.h>\n#include <winsock2.h>\n#include <lcms.h>\n#include <math.h>\n#include <limits.h>\n#include <setjmp.h>\n#include <io.h>\n#include <errno.h>\n#include <lcms2.h>\n#include <fcntl.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/utime.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <float.h>\n#include <jpeglib.h>\n#include <libintl.h>\n#include <string.h>\n"
  },
  {
    "repository": "micro-ecc",
    "cve_id": "CVE-2020-27209",
    "cwe_list": [
      "CWE-415"
    ],
    "commit_hash": "1b5f5cea5145c96dd8791b9b2c41424fc74c2172",
    "short_hash": "1b5f5cea",
    "vulnerableMethods_before": [
      {
        "filename": "uECC.c",
        "method_name": "vulnerable_function",
        "raw_code": "static int uECC_sign_with_k(const uint8_t *private_key,\n                            const uint8_t *message_hash,\n                            unsigned hash_size,\n                            uECC_word_t *k,\n                            uint8_t *signature,\n                            uECC_Curve curve) {\n\n    uECC_word_t tmp[uECC_MAX_WORDS];\n    uECC_word_t s[uECC_MAX_WORDS];\n    uECC_word_t *k2[2] = {tmp, s};\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN\n    uECC_word_t *p = (uECC_word_t *)signature;\n#else\n    uECC_word_t p[uECC_MAX_WORDS * 2];\n#endif\n    uECC_word_t carry;\n    wordcount_t num_words = curve->num_words;\n    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);\n    bitcount_t num_n_bits = curve->num_n_bits;\n\n    /* Make sure 0 < k < curve_n */\n    if (uECC_vli_isZero(k, num_words) || uECC_vli_cmp(curve->n, k, num_n_words) != 1) {\n        return 0;\n    }\n\n    carry = regularize_k(k, tmp, s, curve);\n    EccPoint_mult(p, curve->G, k2[!carry], 0, num_n_bits + 1, curve);\n    if (uECC_vli_isZero(p, num_words)) {\n        return 0;\n    }\n\n    /* If an RNG function was specified, get a random number\n       to prevent side channel analysis of k. */\n    if (!g_rng_function) {\n        uECC_vli_clear(tmp, num_n_words);\n        tmp[0] = 1;\n    } else if (!uECC_generate_random_int(tmp, curve->n, num_n_words)) {\n        return 0;\n    }\n\n    /* Prevent side channel analysis of uECC_vli_modInv() to determine\n       bits of k / the private key by premultiplying by a random number */\n    uECC_vli_modMult(k, k, tmp, curve->n, num_n_words); /* k' = rand * k */\n    uECC_vli_modInv(k, k, curve->n, num_n_words);       /* k = 1 / k' */\n    uECC_vli_modMult(k, k, tmp, curve->n, num_n_words); /* k = 1 / k */\n\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN == 0\n    uECC_vli_nativeToBytes(signature, curve->num_bytes, p); /* store r */\n#endif\n\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN\n    bcopy((uint8_t *) tmp, private_key, BITS_TO_BYTES(curve->num_n_bits));\n#else\n    uECC_vli_bytesToNative(tmp, private_key, BITS_TO_BYTES(curve->num_n_bits)); /* tmp = d */\n#endif\n\n    s[num_n_words - 1] = 0;\n    uECC_vli_set(s, p, num_words);\n    uECC_vli_modMult(s, tmp, s, curve->n, num_n_words); /* s = r*d */\n\n    bits2int(tmp, message_hash, hash_size, curve);\n    uECC_vli_modAdd(s, tmp, s, curve->n, num_n_words); /* s = e + r*d */\n    uECC_vli_modMult(s, s, k, curve->n, num_n_words);  /* s = (e + r*d) / k */\n    if (uECC_vli_numBits(s, num_n_words) > (bitcount_t)curve->num_bytes * 8) {\n        return 0;\n    }\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN\n    bcopy((uint8_t *) signature + curve->num_bytes, (uint8_t *) s, curve->num_bytes);\n#else\n    uECC_vli_nativeToBytes(signature + curve->num_bytes, curve->num_bytes, s);\n#endif    \n    return 1;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "uECC.c",
        "method_name": "fixed_function",
        "raw_code": "static int uECC_sign_with_k(const uint8_t *private_key,\n                            const uint8_t *message_hash,\n                            unsigned hash_size,\n                            uECC_word_t *k,\n                            uint8_t *signature,\n                            uECC_Curve curve) {\n\n    uECC_word_t tmp[uECC_MAX_WORDS];\n    uECC_word_t s[uECC_MAX_WORDS];\n    uECC_word_t *k2[2] = {tmp, s};\n    uECC_word_t *initial_Z = 0;\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN\n    uECC_word_t *p = (uECC_word_t *)signature;\n#else\n    uECC_word_t p[uECC_MAX_WORDS * 2];\n#endif\n    uECC_word_t carry;\n    wordcount_t num_words = curve->num_words;\n    wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);\n    bitcount_t num_n_bits = curve->num_n_bits;\n\n    /* Make sure 0 < k < curve_n */\n    if (uECC_vli_isZero(k, num_words) || uECC_vli_cmp(curve->n, k, num_n_words) != 1) {\n        return 0;\n    }\n\n    carry = regularize_k(k, tmp, s, curve);\n    /* If an RNG function was specified, try to get a random initial Z value to improve\n       protection against side-channel attacks. */\n    if (g_rng_function) {\n        if (!uECC_generate_random_int(k2[carry], curve->p, num_words)) {\n            return 0;\n        }\n        initial_Z = k2[carry];\n    }\n    EccPoint_mult(p, curve->G, k2[!carry], initial_Z, num_n_bits + 1, curve);\n    if (uECC_vli_isZero(p, num_words)) {\n        return 0;\n    }\n\n    /* If an RNG function was specified, get a random number\n       to prevent side channel analysis of k. */\n    if (!g_rng_function) {\n        uECC_vli_clear(tmp, num_n_words);\n        tmp[0] = 1;\n    } else if (!uECC_generate_random_int(tmp, curve->n, num_n_words)) {\n        return 0;\n    }\n\n    /* Prevent side channel analysis of uECC_vli_modInv() to determine\n       bits of k / the private key by premultiplying by a random number */\n    uECC_vli_modMult(k, k, tmp, curve->n, num_n_words); /* k' = rand * k */\n    uECC_vli_modInv(k, k, curve->n, num_n_words);       /* k = 1 / k' */\n    uECC_vli_modMult(k, k, tmp, curve->n, num_n_words); /* k = 1 / k */\n\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN == 0\n    uECC_vli_nativeToBytes(signature, curve->num_bytes, p); /* store r */\n#endif\n\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN\n    bcopy((uint8_t *) tmp, private_key, BITS_TO_BYTES(curve->num_n_bits));\n#else\n    uECC_vli_bytesToNative(tmp, private_key, BITS_TO_BYTES(curve->num_n_bits)); /* tmp = d */\n#endif\n\n    s[num_n_words - 1] = 0;\n    uECC_vli_set(s, p, num_words);\n    uECC_vli_modMult(s, tmp, s, curve->n, num_n_words); /* s = r*d */\n\n    bits2int(tmp, message_hash, hash_size, curve);\n    uECC_vli_modAdd(s, tmp, s, curve->n, num_n_words); /* s = e + r*d */\n    uECC_vli_modMult(s, s, k, curve->n, num_n_words);  /* s = (e + r*d) / k */\n    if (uECC_vli_numBits(s, num_n_words) > (bitcount_t)curve->num_bytes * 8) {\n        return 0;\n    }\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN\n    bcopy((uint8_t *) signature + curve->num_bytes, (uint8_t *) s, curve->num_bytes);\n#else\n    uECC_vli_nativeToBytes(signature + curve->num_bytes, curve->num_bytes, s);\n#endif\n    return 1;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"uECC.h\"\n#include \"asm_arm.inc\"\n#include \"uECC_vli.h\"\n#include \"platform-specific.inc\"\n#include \"curve-specific.inc\"\n#include \"asm_avr.inc\"\n\n// Type Definitions:\n// bitcount_t:\ntypedef int16_t bitcount_t;\n\n// wordcount_t:\ntypedef int8_t wordcount_t;\n\n// uECC_word_t:\ntypedef uint8_t uECC_word_t;\n\n// uECC_word_t:\ntypedef uint32_t uECC_word_t;\n\n// uECC_Curve:\ntypedef const struct uECC_Curve_t * uECC_Curve;\n\n// Called Methods (top 10):\n// uECC_vli_sub from uECC.c:\nuECC_VLI_API uECC_word_t uECC_vli_sub(uECC_word_t *result, /* <=== uECC_vli_sub */ \n                                      const uECC_word_t *left,\n                                      const uECC_word_t *right,\n                                      wordcount_t num_words) {\n    uECC_word_t borrow = 0;\n    wordcount_t i;\n    for (i = 0; i < num_words; ++i) {\n        uECC_word_t diff = left[i] - right[i] - borrow;\n        if (diff != left[i]) {\n            borrow = (diff > left[i]);\n        }\n        result[i] = diff;\n    }\n    return borrow;\n}\n\n// uECC_vli_nativeToBytes from uECC.c:\nuECC_VLI_API void uECC_vli_nativeToBytes(uint8_t *bytes, /* <=== uECC_vli_nativeToBytes */ \n                                         int num_bytes,\n                                         const uint8_t *native) {\n    wordcount_t i;\n    for (i = 0; i < num_bytes; ++i) {\n        bytes[i] = native[(num_bytes - 1) - i];\n    }\n}\n\n// uECC_WORD_BITS_SHIFT from types.h:\n#define uECC_WORD_BITS_SHIFT 5 /* <=== types.h:91:91:uECC_WORD_BITS_SHIFT:0 */ \n\n// XYcZ_initial_double from uECC.c:\nstatic void XYcZ_initial_double(uECC_word_t * X1, /* <=== XYcZ_initial_double */ \n                                uECC_word_t * Y1,\n                                uECC_word_t * X2,\n                                uECC_word_t * Y2,\n                                const uECC_word_t * const initial_Z,\n                                uECC_Curve curve) {\n    uECC_word_t z[uECC_MAX_WORDS];\n    wordcount_t num_words = curve->num_words;\n    if (initial_Z) {\n        uECC_vli_set(z, initial_Z, num_words);\n    } else {\n        uECC_vli_clear(z, num_words);\n        z[0] = 1;\n    }\n\n    uECC_vli_set(X2, X1, num_words);\n    uECC_vli_set(Y2, Y1, num_words);\n\n    apply_z(X1, Y1, z, curve);\n    curve->double_jacobian(X1, Y1, z, curve);\n    apply_z(X2, Y2, z, curve);\n}\n\n// uECC_vli_mmod from uECC.c:\nuECC_VLI_API void uECC_vli_mmod(uECC_word_t *result, /* <=== uECC_vli_mmod */ \n                                uECC_word_t *product,\n                                const uECC_word_t *mod,\n                                wordcount_t num_words) {\n    uECC_word_t mod_multiple[2 * uECC_MAX_WORDS];\n    uECC_word_t tmp[2 * uECC_MAX_WORDS];\n    uECC_word_t *v[2] = {tmp, product};\n    uECC_word_t index;\n\n    /* Shift mod so its highest set bit is at the maximum position. */\n    bitcount_t shift = (num_words * 2 * uECC_WORD_BITS) - uECC_vli_numBits(mod, num_words);\n    wordcount_t word_shift = shift / uECC_WORD_BITS;\n    wordcount_t bit_shift = shift % uECC_WORD_BITS;\n    uECC_word_t carry = 0;\n    uECC_vli_clear(mod_multiple, word_shift);\n    if (bit_shift > 0) {\n        for(index = 0; index < (uECC_word_t)num_words; ++index) {\n            mod_multiple[word_shift + index] = (mod[index] << bit_shift) | carry;\n            carry = mod[index] >> (uECC_WORD_BITS - bit_shift);\n        }\n    } else {\n        uECC_vli_set(mod_multiple + word_shift, mod, num_words);\n    }\n\n    for (index = 1; shift >= 0; --shift) {\n        uECC_word_t borrow = 0;\n        wordcount_t i;\n        for (i = 0; i < num_words * 2; ++i) {\n            uECC_word_t diff = v[index][i] - mod_multiple[i] - borrow;\n            if (diff != v[index][i]) {\n                borrow = (diff > v[index][i]);\n            }\n            v[1 - index][i] = diff;\n        }\n        index = !(index ^ borrow); /* Swap the index if there was no borrow */\n        uECC_vli_rshift1(mod_multiple, num_words);\n        mod_multiple[num_words - 1] |= mod_multiple[num_words] << (uECC_WORD_BITS - 1);\n        uECC_vli_rshift1(mod_multiple + num_words, num_words);\n    }\n    uECC_vli_set(result, v[index], num_words);\n}\n\n// uECC_vli_clear from uECC.c:\nuECC_VLI_API void uECC_vli_clear(uECC_word_t *vli, wordcount_t num_words) { /* <=== uECC_vli_clear */ \n    wordcount_t i;\n    for (i = 0; i < num_words; ++i) {\n        vli[i] = 0;\n    }\n}\n\n// uECC_vli_bytesToNative from uECC.c:\nuECC_VLI_API void uECC_vli_bytesToNative(uint8_t *native, /* <=== uECC_vli_bytesToNative */ \n                                         const uint8_t *bytes,\n                                         int num_bytes) {\n    uECC_vli_nativeToBytes(native, num_bytes, bytes);\n}\n\n// EccPoint_mult from uECC.c:\nstatic void EccPoint_mult(uECC_word_t * result, /* <=== EccPoint_mult */ \n                          const uECC_word_t * point,\n                          const uECC_word_t * scalar,\n                          const uECC_word_t * initial_Z,\n                          bitcount_t num_bits,\n                          uECC_Curve curve) {\n    /* R0 and R1 */\n    uECC_word_t Rx[2][uECC_MAX_WORDS];\n    uECC_word_t Ry[2][uECC_MAX_WORDS];\n    uECC_word_t z[uECC_MAX_WORDS];\n    bitcount_t i;\n    uECC_word_t nb;\n    wordcount_t num_words = curve->num_words;\n\n    uECC_vli_set(Rx[1], point, num_words);\n    uECC_vli_set(Ry[1], point + num_words, num_words);\n\n    XYcZ_initial_double(Rx[1], Ry[1], Rx[0], Ry[0], initial_Z, curve);\n\n    for (i = num_bits - 2; i > 0; --i) {\n        nb = !uECC_vli_testBit(scalar, i);\n        XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);\n        XYcZ_add(Rx[nb], Ry[nb], Rx[1 - nb], Ry[1 - nb], curve);\n    }\n\n    nb = !uECC_vli_testBit(scalar, 0);\n    XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);\n\n    /* Find final 1/Z value. */\n    uECC_vli_modSub(z, Rx[1], Rx[0], curve->p, num_words); /* X1 - X0 */\n    uECC_vli_modMult_fast(z, z, Ry[1 - nb], curve);               /* Yb * (X1 - X0) */\n    uECC_vli_modMult_fast(z, z, point, curve);                    /* xP * Yb * (X1 - X0) */\n    uECC_vli_modInv(z, z, curve->p, num_words);            /* 1 / (xP * Yb * (X1 - X0)) */\n    /* yP / (xP * Yb * (X1 - X0)) */\n    uECC_vli_modMult_fast(z, z, point + num_words, curve);\n    uECC_vli_modMult_fast(z, z, Rx[1 - nb], curve); /* Xb * yP / (xP * Yb * (X1 - X0)) */\n    /* End 1/Z calculation */\n\n    XYcZ_add(Rx[nb], Ry[nb], Rx[1 - nb], Ry[1 - nb], curve);\n    apply_z(Rx[0], Ry[0], z, curve);\n\n    uECC_vli_set(result, Rx[0], num_words);\n    uECC_vli_set(result + num_words, Ry[0], num_words);\n}\n\n// uECC_vli_modInv from uECC.c:\nuECC_VLI_API void uECC_vli_modInv(uECC_word_t *result, /* <=== uECC_vli_modInv */ \n                                  const uECC_word_t *input,\n                                  const uECC_word_t *mod,\n                                  wordcount_t num_words) {\n    uECC_word_t a[uECC_MAX_WORDS], b[uECC_MAX_WORDS], u[uECC_MAX_WORDS], v[uECC_MAX_WORDS];\n    cmpresult_t cmpResult;\n\n    if (uECC_vli_isZero(input, num_words)) {\n        uECC_vli_clear(result, num_words);\n        return;\n    }\n\n    uECC_vli_set(a, input, num_words);\n    uECC_vli_set(b, mod, num_words);\n    uECC_vli_clear(u, num_words);\n    u[0] = 1;\n    uECC_vli_clear(v, num_words);\n    while ((cmpResult = uECC_vli_cmp_unsafe(a, b, num_words)) != 0) {\n        if (EVEN(a)) {\n            uECC_vli_rshift1(a, num_words);\n            vli_modInv_update(u, mod, num_words);\n        } else if (EVEN(b)) {\n            uECC_vli_rshift1(b, num_words);\n            vli_modInv_update(v, mod, num_words);\n        } else if (cmpResult > 0) {\n            uECC_vli_sub(a, a, b, num_words);\n            uECC_vli_rshift1(a, num_words);\n            if (uECC_vli_cmp_unsafe(u, v, num_words) < 0) {\n                uECC_vli_add(u, u, mod, num_words);\n            }\n            uECC_vli_sub(u, u, v, num_words);\n            vli_modInv_update(u, mod, num_words);\n        } else {\n            uECC_vli_sub(b, b, a, num_words);\n            uECC_vli_rshift1(b, num_words);\n            if (uECC_vli_cmp_unsafe(v, u, num_words) < 0) {\n                uECC_vli_add(v, v, mod, num_words);\n            }\n            uECC_vli_sub(v, v, u, num_words);\n            vli_modInv_update(v, mod, num_words);\n        }\n    }\n    uECC_vli_set(result, u, num_words);\n}\n\n// XYcZ_add from uECC.c:\nstatic void XYcZ_add(uECC_word_t * X1, /* <=== XYcZ_add */ \n                     uECC_word_t * Y1,\n                     uECC_word_t * X2,\n                     uECC_word_t * Y2,\n                     uECC_Curve curve) {\n    /* t1 = X1, t2 = Y1, t3 = X2, t4 = Y2 */\n    uECC_word_t t5[uECC_MAX_WORDS];\n    wordcount_t num_words = curve->num_words;\n\n    uECC_vli_modSub(t5, X2, X1, curve->p, num_words); /* t5 = x2 - x1 */\n    uECC_vli_modSquare_fast(t5, t5, curve);                  /* t5 = (x2 - x1)^2 = A */\n    uECC_vli_modMult_fast(X1, X1, t5, curve);                /* t1 = x1*A = B */\n    uECC_vli_modMult_fast(X2, X2, t5, curve);                /* t3 = x2*A = C */\n    uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = y2 - y1 */\n    uECC_vli_modSquare_fast(t5, Y2, curve);                  /* t5 = (y2 - y1)^2 = D */\n\n    uECC_vli_modSub(t5, t5, X1, curve->p, num_words); /* t5 = D - B */\n    uECC_vli_modSub(t5, t5, X2, curve->p, num_words); /* t5 = D - B - C = x3 */\n    uECC_vli_modSub(X2, X2, X1, curve->p, num_words); /* t3 = C - B */\n    uECC_vli_modMult_fast(Y1, Y1, X2, curve);                /* t2 = y1*(C - B) */\n    uECC_vli_modSub(X2, X1, t5, curve->p, num_words); /* t3 = B - x3 */\n    uECC_vli_modMult_fast(Y2, Y2, X2, curve);                /* t4 = (y2 - y1)*(B - x3) */\n    uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = y3 */\n\n    uECC_vli_set(X2, t5, num_words);\n}\n"
  },
  {
    "repository": "FreeRDP",
    "cve_id": "CVE-2020-11038",
    "cwe_list": [
      "CWE-190"
    ],
    "commit_hash": "06c32f170093a6ecde93e3bc07fed6a706bfbeb3",
    "short_hash": "06c32f17",
    "vulnerableMethods_before": [
      {
        "filename": "video_main.c",
        "method_name": "vulnerable_function",
        "raw_code": "static PresentationContext* PresentationContext_new(VideoClientContext* video, BYTE PresentationId,\n                                                    UINT32 x, UINT32 y, UINT32 width, UINT32 height)\n{\n\tVideoClientContextPriv* priv = video->priv;\n\tPresentationContext* ret = calloc(1, sizeof(*ret));\n\tif (!ret)\n\t\treturn NULL;\n\n\tret->video = video;\n\tret->PresentationId = PresentationId;\n\n\tret->h264 = h264_context_new(FALSE);\n\tif (!ret->h264)\n\t{\n\t\tWLog_ERR(TAG, \"unable to create a h264 context\");\n\t\tgoto error_h264;\n\t}\n\th264_context_reset(ret->h264, width, height);\n\n\tret->currentSample = Stream_New(NULL, 4096);\n\tif (!ret->currentSample)\n\t{\n\t\tWLog_ERR(TAG, \"unable to create current packet stream\");\n\t\tgoto error_currentSample;\n\t}\n\n\tret->surfaceData = BufferPool_Take(priv->surfacePool, width * height * 4);\n\tif (!ret->surfaceData)\n\t{\n\t\tWLog_ERR(TAG, \"unable to allocate surfaceData\");\n\t\tgoto error_surfaceData;\n\t}\n\n\tret->surface = video->createSurface(video, ret->surfaceData, x, y, width, height);\n\tif (!ret->surface)\n\t{\n\t\tWLog_ERR(TAG, \"unable to create surface\");\n\t\tgoto error_surface;\n\t}\n\n\tret->yuv = yuv_context_new(FALSE);\n\tif (!ret->yuv)\n\t{\n\t\tWLog_ERR(TAG, \"unable to create YUV decoder\");\n\t\tgoto error_yuv;\n\t}\n\n\tyuv_context_reset(ret->yuv, width, height);\n\tret->refCounter = 1;\n\treturn ret;\n\nerror_yuv:\n\tvideo->deleteSurface(video, ret->surface);\nerror_surface:\n\tBufferPool_Return(priv->surfacePool, ret->surfaceData);\nerror_surfaceData:\n\tStream_Free(ret->currentSample, TRUE);\nerror_currentSample:\n\th264_context_free(ret->h264);\nerror_h264:\n\tfree(ret);\n\treturn NULL;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "video_main.c",
        "method_name": "fixed_function",
        "raw_code": "static PresentationContext* PresentationContext_new(VideoClientContext* video, BYTE PresentationId,\n                                                    UINT32 x, UINT32 y, UINT32 width, UINT32 height)\n{\n\tsize_t s;\n\tVideoClientContextPriv* priv = video->priv;\n\tPresentationContext* ret;\n\ts = width * height * 4ULL;\n\tif (s > INT32_MAX)\n\t\treturn NULL;\n\n\tret = calloc(1, sizeof(*ret));\n\tif (!ret)\n\t\treturn NULL;\n\n\tret->video = video;\n\tret->PresentationId = PresentationId;\n\n\tret->h264 = h264_context_new(FALSE);\n\tif (!ret->h264)\n\t{\n\t\tWLog_ERR(TAG, \"unable to create a h264 context\");\n\t\tgoto error_h264;\n\t}\n\th264_context_reset(ret->h264, width, height);\n\n\tret->currentSample = Stream_New(NULL, 4096);\n\tif (!ret->currentSample)\n\t{\n\t\tWLog_ERR(TAG, \"unable to create current packet stream\");\n\t\tgoto error_currentSample;\n\t}\n\n\tret->surfaceData = BufferPool_Take(priv->surfacePool, s);\n\tif (!ret->surfaceData)\n\t{\n\t\tWLog_ERR(TAG, \"unable to allocate surfaceData\");\n\t\tgoto error_surfaceData;\n\t}\n\n\tret->surface = video->createSurface(video, ret->surfaceData, x, y, width, height);\n\tif (!ret->surface)\n\t{\n\t\tWLog_ERR(TAG, \"unable to create surface\");\n\t\tgoto error_surface;\n\t}\n\n\tret->yuv = yuv_context_new(FALSE);\n\tif (!ret->yuv)\n\t{\n\t\tWLog_ERR(TAG, \"unable to create YUV decoder\");\n\t\tgoto error_yuv;\n\t}\n\n\tyuv_context_reset(ret->yuv, width, height);\n\tret->refCounter = 1;\n\treturn ret;\n\nerror_yuv:\n\tvideo->deleteSurface(video, ret->surface);\nerror_surface:\n\tBufferPool_Return(priv->surfacePool, ret->surfaceData);\nerror_surfaceData:\n\tStream_Free(ret->currentSample, TRUE);\nerror_currentSample:\n\th264_context_free(ret->h264);\nerror_h264:\n\tfree(ret);\n\treturn NULL;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <winpr/interlocked.h>\n#include <freerdp/client/geometry.h>\n#include <winpr/print.h>\n#include <winpr/sysinfo.h>\n#include <freerdp/codec/h264.h>\n#include <winpr/stream.h>\n#include <freerdp/channels/log.h>\n#include <freerdp/addin.h>\n#include \"config.h\"\n#include <freerdp/client/video.h>\n#include <freerdp/codec/yuv.h>\n#include <stdlib.h>\n#include <winpr/collections.h>\n#include <freerdp/primitives.h>\n#include <winpr/synch.h>\n#include <winpr/cmdline.h>\n#include \"video_main.h\"\n#include <stdio.h>\n#include <winpr/crt.h>\n#include <string.h>\n\n// Type Definitions:\n// VideoClientContextPriv:\ntypedef struct _VideoClientContextPriv VideoClientContextPriv;\n\n// VideoClientContext:\ntypedef struct _VideoClientContext VideoClientContext;\n\n// PresentationContext:\ntypedef struct _PresentationContext PresentationContext;\n\n// BYTE:\ntypedef unsigned char BYTE;\n\n// Called Methods (top 10):\n// GetSystemInfo from winpr/libwinpr/sysinfo/sysinfo.c:\nvoid GetSystemInfo(LPSYSTEM_INFO lpSystemInfo) /* <=== GetSystemInfo */ \n{\n\tlpSystemInfo->wProcessorArchitecture = GetProcessorArchitecture();\n\tlpSystemInfo->wReserved = 0;\n\tlpSystemInfo->dwPageSize = GetSystemPageSize();\n\tlpSystemInfo->lpMinimumApplicationAddress = NULL;\n\tlpSystemInfo->lpMaximumApplicationAddress = NULL;\n\tlpSystemInfo->dwActiveProcessorMask = 0;\n\tlpSystemInfo->dwNumberOfProcessors = GetNumberOfProcessors();\n\tlpSystemInfo->dwProcessorType = 0;\n\tlpSystemInfo->dwAllocationGranularity = 0;\n\tlpSystemInfo->wProcessorLevel = 0;\n\tlpSystemInfo->wProcessorRevision = 0;\n}\n\n// TAG from channels/video/client/video_main.c:\n#define TAG CHANNELS_TAG(\"video\") /* <=== channels/video/client/video_main.c:45:45:TAG:0 */ \n\n// BufferPool_ShiftUsed from winpr/libwinpr/utils/collections/BufferPool.c:\nstatic BOOL BufferPool_ShiftUsed(wBufferPool* pool, int index, int count) /* <=== BufferPool_ShiftUsed */ \n{\n\tif (count > 0)\n\t{\n\t\tif (pool->uSize + count > pool->uCapacity)\n\t\t{\n\t\t\tint newUCapacity = pool->uCapacity * 2;\n\t\t\twBufferPoolItem* newUArray =\n\t\t\t    (wBufferPoolItem*)realloc(pool->uArray, sizeof(wBufferPoolItem) * newUCapacity);\n\t\t\tif (!newUArray)\n\t\t\t\treturn FALSE;\n\t\t\tpool->uCapacity = newUCapacity;\n\t\t\tpool->uArray = newUArray;\n\t\t}\n\n\t\tMoveMemory(&pool->uArray[index + count], &pool->uArray[index],\n\t\t           (pool->uSize - index) * sizeof(wBufferPoolItem));\n\t\tpool->uSize += count;\n\t}\n\telse if (count < 0)\n\t{\n\t\tMoveMemory(&pool->uArray[index], &pool->uArray[index - count],\n\t\t           (pool->uSize - index) * sizeof(wBufferPoolItem));\n\t\tpool->uSize += count;\n\t}\n\treturn TRUE;\n}\n\n// WINPR_ALIGNED_MEM_SIGNATURE from winpr/libwinpr/crt/alignment.c:\n#define WINPR_ALIGNED_MEM_SIGNATURE 0x0BA0BAB /* <=== winpr/libwinpr/crt/alignment.c:33:33:WINPR_ALIGNED_MEM_SIGNATURE:0 */ \n\n// GetNativeSystemInfo from winpr/libwinpr/sysinfo/sysinfo.c:\nvoid GetNativeSystemInfo(LPSYSTEM_INFO lpSystemInfo) /* <=== GetNativeSystemInfo */ \n{\n\tGetSystemInfo(lpSystemInfo);\n}\n\n// GetCurrentThreadId from winpr/libwinpr/thread/thread.c:\nDWORD GetCurrentThreadId(VOID) /* <=== GetCurrentThreadId */ \n{\n\tpthread_t tid;\n\ttid = pthread_self();\n\t/* Since pthread_t can be 64-bits on some systems, take just the    */\n\t/* lower 32-bits of it for the thread ID returned by this function. */\n\treturn (DWORD)tid & 0xffffffffUL;\n}\n\n// TAG from libfreerdp/codec/h264.c:\n#define TAG FREERDP_TAG(\"codec\") /* <=== libfreerdp/codec/h264.c:37:37:TAG:0 */ \n\n// BufferPool_Return from winpr/libwinpr/utils/collections/BufferPool.c:\nBOOL BufferPool_Return(wBufferPool* pool, void* buffer) /* <=== BufferPool_Return */ \n{\n\tint size = 0;\n\tint index = 0;\n\tBOOL found = FALSE;\n\n\tif (pool->synchronized)\n\t\tEnterCriticalSection(&pool->lock);\n\n\tif (pool->fixedSize)\n\t{\n\t\t/* fixed size buffers */\n\n\t\tif ((pool->size + 1) >= pool->capacity)\n\t\t{\n\t\t\tint newCapacity = pool->capacity * 2;\n\t\t\tvoid** newArray = (void**)realloc(pool->array, sizeof(void*) * newCapacity);\n\t\t\tif (!newArray)\n\t\t\t\tgoto out_error;\n\n\t\t\tpool->capacity = newCapacity;\n\t\t\tpool->array = newArray;\n\t\t}\n\n\t\tpool->array[(pool->size)++] = buffer;\n\t}\n\telse\n\t{\n\t\t/* variable size buffers */\n\n\t\tfor (index = 0; index < pool->uSize; index++)\n\t\t{\n\t\t\tif (pool->uArray[index].buffer == buffer)\n\t\t\t{\n\t\t\t\tfound = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (found)\n\t\t{\n\t\t\tsize = pool->uArray[index].size;\n\t\t\tif (!BufferPool_ShiftUsed(pool, index, -1))\n\t\t\t\tgoto out_error;\n\t\t}\n\n\t\tif (size)\n\t\t{\n\t\t\tif ((pool->aSize + 1) >= pool->aCapacity)\n\t\t\t{\n\t\t\t\tint newCapacity = pool->aCapacity * 2;\n\t\t\t\twBufferPoolItem* newArray =\n\t\t\t\t    (wBufferPoolItem*)realloc(pool->aArray, sizeof(wBufferPoolItem) * newCapacity);\n\t\t\t\tif (!newArray)\n\t\t\t\t\tgoto out_error;\n\n\t\t\t\tpool->aCapacity = newCapacity;\n\t\t\t\tpool->aArray = newArray;\n\t\t\t}\n\n\t\t\tpool->aArray[pool->aSize].buffer = buffer;\n\t\t\tpool->aArray[pool->aSize].size = size;\n\t\t\t(pool->aSize)++;\n\t\t}\n\t}\n\n\tif (pool->synchronized)\n\t\tLeaveCriticalSection(&pool->lock);\n\treturn TRUE;\n\nout_error:\n\tif (pool->synchronized)\n\t\tLeaveCriticalSection(&pool->lock);\n\treturn FALSE;\n}\n\n// LeaveCriticalSection from winpr/libwinpr/synch/critical.c:\nVOID LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection) /* <=== LeaveCriticalSection */ \n{\n\t/* Decrement RecursionCount and check if this is the last LeaveCriticalSection call ...*/\n\tif (--lpCriticalSection->RecursionCount < 1)\n\t{\n\t\t/* Last recursion, clear owner, unlock and if there are other waiting threads ... */\n\t\tlpCriticalSection->OwningThread = NULL;\n\n\t\tif (InterlockedDecrement(&lpCriticalSection->LockCount) >= 0)\n\t\t{\n\t\t\t/* ...signal the semaphore to unblock the next waiting thread */\n\t\t\t_UnWaitCriticalSection(lpCriticalSection);\n\t\t}\n\t}\n\telse\n\t{\n\t\tInterlockedDecrement(&lpCriticalSection->LockCount);\n\t}\n}\n\n// yuv_context_new from libfreerdp/codec/yuv.c:\nYUV_CONTEXT* yuv_context_new(BOOL encoder) /* <=== yuv_context_new */ \n{\n\tSYSTEM_INFO sysInfos;\n\tYUV_CONTEXT* ret = calloc(1, sizeof(*ret));\n\tif (!ret)\n\t\treturn NULL;\n\n\t/** do it here to avoid a race condition between threads */\n\tprimitives_get();\n\n\tGetNativeSystemInfo(&sysInfos);\n\tret->useThreads = (sysInfos.dwNumberOfProcessors > 1);\n\tif (ret->useThreads)\n\t{\n\t\tret->nthreads = sysInfos.dwNumberOfProcessors;\n\t\tret->threadPool = CreateThreadpool(NULL);\n\t\tif (!ret->threadPool)\n\t\t{\n\t\t\tgoto error_threadpool;\n\t\t}\n\n\t\tInitializeThreadpoolEnvironment(&ret->ThreadPoolEnv);\n\t\tSetThreadpoolCallbackPool(&ret->ThreadPoolEnv, ret->threadPool);\n\t}\n\telse\n\t{\n\t\tret->nthreads = 1;\n\t}\n\n\treturn ret;\n\nerror_threadpool:\n\tfree(ret);\n\treturn NULL;\n}\n"
  },
  {
    "repository": "FreeRTOS-Kernel",
    "cve_id": "CVE-2021-31571",
    "cwe_list": [
      "CWE-200"
    ],
    "commit_hash": "47338393f1f79558f6144213409f09f81d7c4837",
    "short_hash": "47338393",
    "vulnerableMethods_before": [
      {
        "filename": "queue.c",
        "method_name": "vulnerable_function",
        "raw_code": "    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,\r\n                                       const UBaseType_t uxItemSize,\r\n                                       const uint8_t ucQueueType )\r\n    {\r\n        Queue_t * pxNewQueue;\r\n        size_t xQueueSizeInBytes;\r\n        uint8_t * pucQueueStorage;\r\n\r\n        configASSERT( uxQueueLength > ( UBaseType_t ) 0 );\r\n\r\n        /* Allocate enough space to hold the maximum number of items that\r\n         * can be in the queue at any time.  It is valid for uxItemSize to be\r\n         * zero in the case the queue is used as a semaphore. */\r\n        xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */\r\n\r\n        /* Check for multiplication overflow. */\r\n        configASSERT( ( uxItemSize == 0 ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) ) );\r\n\r\n        /* Allocate the queue and storage area.  Justification for MISRA\r\n         * deviation as follows:  pvPortMalloc() always ensures returned memory\r\n         * blocks are aligned per the requirements of the MCU stack.  In this case\r\n         * pvPortMalloc() must return a pointer that is guaranteed to meet the\r\n         * alignment requirements of the Queue_t structure - which in this case\r\n         * is an int8_t *.  Therefore, whenever the stack alignment requirements\r\n         * are greater than or equal to the pointer to char requirements the cast\r\n         * is safe.  In other cases alignment requirements are not strict (one or\r\n         * two bytes). */\r\n        pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */\r\n\r\n        if( pxNewQueue != NULL )\r\n        {\r\n            /* Jump past the queue structure to find the location of the queue\r\n             * storage area. */\r\n            pucQueueStorage = ( uint8_t * ) pxNewQueue;\r\n            pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */\r\n\r\n            #if ( configSUPPORT_STATIC_ALLOCATION == 1 )\r\n                {\r\n                    /* Queues can be created either statically or dynamically, so\r\n                     * note this task was created dynamically in case it is later\r\n                     * deleted. */\r\n                    pxNewQueue->ucStaticallyAllocated = pdFALSE;\r\n                }\r\n            #endif /* configSUPPORT_STATIC_ALLOCATION */\r\n\r\n            prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );\r\n        }\r\n        else\r\n        {\r\n            traceQUEUE_CREATE_FAILED( ucQueueType );\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n\r\n        return pxNewQueue;\r\n    }\r",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "queue.c",
        "method_name": "fixed_function",
        "raw_code": "    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,\r\n                                       const UBaseType_t uxItemSize,\r\n                                       const uint8_t ucQueueType )\r\n    {\r\n        Queue_t * pxNewQueue;\r\n        size_t xQueueSizeInBytes;\r\n        uint8_t * pucQueueStorage;\r\n\r\n        configASSERT( uxQueueLength > ( UBaseType_t ) 0 );\r\n\r\n        /* Allocate enough space to hold the maximum number of items that\r\n         * can be in the queue at any time.  It is valid for uxItemSize to be\r\n         * zero in the case the queue is used as a semaphore. */\r\n        xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */\r\n\r\n        /* Check for multiplication overflow. */\r\n        configASSERT( ( uxItemSize == 0 ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) ) );\r\n\r\n        /* Check for addition overflow. */\r\n        configASSERT( ( sizeof( Queue_t ) + xQueueSizeInBytes ) >  xQueueSizeInBytes );\r\n\r\n        /* Allocate the queue and storage area.  Justification for MISRA\r\n         * deviation as follows:  pvPortMalloc() always ensures returned memory\r\n         * blocks are aligned per the requirements of the MCU stack.  In this case\r\n         * pvPortMalloc() must return a pointer that is guaranteed to meet the\r\n         * alignment requirements of the Queue_t structure - which in this case\r\n         * is an int8_t *.  Therefore, whenever the stack alignment requirements\r\n         * are greater than or equal to the pointer to char requirements the cast\r\n         * is safe.  In other cases alignment requirements are not strict (one or\r\n         * two bytes). */\r\n        pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */\r\n\r\n        if( pxNewQueue != NULL )\r\n        {\r\n            /* Jump past the queue structure to find the location of the queue\r\n             * storage area. */\r\n            pucQueueStorage = ( uint8_t * ) pxNewQueue;\r\n            pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */\r\n\r\n            #if ( configSUPPORT_STATIC_ALLOCATION == 1 )\r\n                {\r\n                    /* Queues can be created either statically or dynamically, so\r\n                     * note this task was created dynamically in case it is later\r\n                     * deleted. */\r\n                    pxNewQueue->ucStaticallyAllocated = pdFALSE;\r\n                }\r\n            #endif /* configSUPPORT_STATIC_ALLOCATION */\r\n\r\n            prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );\r\n        }\r\n        else\r\n        {\r\n            traceQUEUE_CREATE_FAILED( ucQueueType );\r\n            mtCOVERAGE_TEST_MARKER();\r\n        }\r\n\r\n        return pxNewQueue;\r\n    }\r",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <stdlib.h>\n#include \"FreeRTOS.h\"\n#include \"croutine.h\"\n#include \"queue.h\"\n#include \"task.h\"\n#include <string.h>\n"
  },
  {
    "repository": "ImageMagick",
    "cve_id": "CVE-2018-14551",
    "cwe_list": [
      "CWE-787"
    ],
    "commit_hash": "389ecc365a7c61404ba078a72c3fa5a3cf1b4101",
    "short_hash": "389ecc36",
    "vulnerableMethods_before": [
      {
        "filename": "mat.c",
        "method_name": "vulnerable_function",
        "raw_code": "static Image *ReadMATImageV4(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  typedef struct {\n    unsigned char Type[4];\n    unsigned int nRows;\n    unsigned int nCols;\n    unsigned int imagf;\n    unsigned int nameLen;\n  } MAT4_HDR;\n\n  long\n    ldblk;\n\n  EndianType\n    endian;\n\n  Image\n    *rotated_image;\n\n  MagickBooleanType\n    status;\n\n  MAT4_HDR\n    HDR;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumFormatType\n    format_type;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  unsigned int\n    depth;\n\n\n  quantum_info=(QuantumInfo *) NULL;\n  (void) SeekBlob(image,0,SEEK_SET);\n  while (EOFBlob(image) == MagickFalse)\n  {\n    /*\n     Object parser loop.\n    */\n    ldblk=ReadBlobLSBLong(image);\n    if ((ldblk > 9999) || (ldblk < 0))\n      break;\n    HDR.Type[3]=ldblk % 10; ldblk /= 10;  /* T digit */\n    HDR.Type[2]=ldblk % 10; ldblk /= 10;  /* P digit */\n    HDR.Type[1]=ldblk % 10; ldblk /= 10;  /* O digit */\n    HDR.Type[0]=ldblk;        /* M digit */\n    if (HDR.Type[3] != 0)\n      break;  /* Data format */\n    if (HDR.Type[2] != 0)\n      break;  /* Always 0 */\n    if (HDR.Type[0] == 0)\n      {\n        HDR.nRows=ReadBlobLSBLong(image);\n        HDR.nCols=ReadBlobLSBLong(image);\n        HDR.imagf=ReadBlobLSBLong(image);\n        HDR.nameLen=ReadBlobLSBLong(image);\n        endian=LSBEndian;\n      }\n    else\n      {\n        HDR.nRows=ReadBlobMSBLong(image);\n        HDR.nCols=ReadBlobMSBLong(image);\n        HDR.imagf=ReadBlobMSBLong(image);\n        HDR.nameLen=ReadBlobMSBLong(image);\n        endian=MSBEndian;\n      }\n    if ((HDR.imagf != 0) && (HDR.imagf != 1))\n      break;\n    if (HDR.nameLen > 0xFFFF)\n      return(DestroyImageList(image));\n    for (i=0; i < (ssize_t) HDR.nameLen; i++)\n    {\n      int\n        byte;\n\n      /*\n        Skip matrix name.\n      */\n      byte=ReadBlobByte(image);\n      if (byte == EOF)\n        {\n          ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n            image->filename);\n          break;\n        }\n    }\n    image->columns=(size_t) HDR.nRows;\n    image->rows=(size_t) HDR.nCols;\n    if ((image->columns == 0) || (image->rows == 0))\n      return(DestroyImageList(image));\n    if (image_info->ping != MagickFalse)\n      {\n        Swap(image->columns,image->rows);\n        if(HDR.imagf==1) ldblk *= 2;\n        SeekBlob(image, HDR.nCols*ldblk, SEEK_CUR);\n        if ((image->columns == 0) || (image->rows == 0))\n          return(image->previous == (Image *) NULL ? DestroyImageList(image)\n            : image);\n        goto skip_reading_current;\n      }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    (void) SetImageBackgroundColor(image,exception);\n    (void) SetImageColorspace(image,GRAYColorspace,exception);\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      return(DestroyImageList(image));\n    switch(HDR.Type[1])\n    {\n      case 0:\n        format_type=FloatingPointQuantumFormat;\n        depth=64;\n        break;\n      case 1:\n        format_type=FloatingPointQuantumFormat;\n        depth=32;\n        break;\n      case 2:\n        format_type=UnsignedQuantumFormat;\n        depth=16;\n        break;\n      case 3:\n        format_type=SignedQuantumFormat;\n        depth=16;\n        break;\n      case 4:\n        format_type=UnsignedQuantumFormat;\n        depth=8;\n        break;\n      default:\n        format_type=UnsignedQuantumFormat;\n        depth=8;\n        break;\n    }\n    image->depth=depth;\n    if (HDR.Type[0] != 0)\n      SetQuantumEndian(image,quantum_info,MSBEndian);\n    status=SetQuantumFormat(image,quantum_info,format_type);\n    status=SetQuantumDepth(image,quantum_info,depth);\n    status=SetQuantumEndian(image,quantum_info,endian);\n    SetQuantumScale(quantum_info,1.0);\n    pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      register Quantum\n        *magick_restrict q;\n\n      count=ReadBlob(image,depth/8*image->columns,(char *) pixels);\n      if (count == -1)\n        break;\n      q=QueueAuthenticPixels(image,0,image->rows-y-1,image->columns,1,\n        exception);\n      if (q == (Quantum *) NULL)\n        break;\n      (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n        GrayQuantum,pixels,exception);\n      if ((HDR.Type[1] == 2) || (HDR.Type[1] == 3))\n        FixSignedValues(image,q,(int) image->columns);\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    if (HDR.imagf == 1)\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        /*\n          Read complex pixels.\n        */\n        count=ReadBlob(image,depth/8*image->columns,(char *) pixels);\n        if (count == -1)\n          break;\n        if (HDR.Type[1] == 0)\n          InsertComplexDoubleRow(image,(double *) pixels,y,0,0,exception);\n        else\n          InsertComplexFloatRow(image,(float *) pixels,y,0,0,exception);\n      }\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    rotated_image=RotateImage(image,90.0,exception);\n    if (rotated_image != (Image *) NULL)\n      {\n        rotated_image->page.x=0;\n        rotated_image->page.y=0;\n        rotated_image->colors = image->colors;\n        DestroyBlob(rotated_image);\n        rotated_image->blob=ReferenceBlob(image->blob);\n        AppendImageToList(&image,rotated_image);\n        DeleteImageFromList(&image);\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    /*\n      Allocate next image structure.\n    */\nskip_reading_current:\n    AcquireNextImage(image_info,image,exception);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      {\n        status=MagickFalse;\n        break;\n      }\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      GetBlobSize(image));\n    if (status == MagickFalse)\n      break;\n  }\n  (void) CloseBlob(image);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "mat.c",
        "method_name": "fixed_function",
        "raw_code": "static Image *ReadMATImageV4(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  typedef struct {\n    unsigned char Type[4];\n    unsigned int nRows;\n    unsigned int nCols;\n    unsigned int imagf;\n    unsigned int nameLen;\n  } MAT4_HDR;\n\n  long\n    ldblk;\n\n  EndianType\n    endian;\n\n  Image\n    *rotated_image;\n\n  MagickBooleanType\n    status;\n\n  MAT4_HDR\n    HDR;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumFormatType\n    format_type;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  unsigned int\n    depth;\n\n  quantum_info=(QuantumInfo *) NULL;\n  (void) SeekBlob(image,0,SEEK_SET);\n  status=MagickTrue;\n  while (EOFBlob(image) == MagickFalse)\n  {\n    /*\n     Object parser loop.\n    */\n    ldblk=ReadBlobLSBLong(image);\n    if ((ldblk > 9999) || (ldblk < 0))\n      break;\n    HDR.Type[3]=ldblk % 10; ldblk /= 10;  /* T digit */\n    HDR.Type[2]=ldblk % 10; ldblk /= 10;  /* P digit */\n    HDR.Type[1]=ldblk % 10; ldblk /= 10;  /* O digit */\n    HDR.Type[0]=ldblk;        /* M digit */\n    if (HDR.Type[3] != 0)\n      break;  /* Data format */\n    if (HDR.Type[2] != 0)\n      break;  /* Always 0 */\n    if (HDR.Type[0] == 0)\n      {\n        HDR.nRows=ReadBlobLSBLong(image);\n        HDR.nCols=ReadBlobLSBLong(image);\n        HDR.imagf=ReadBlobLSBLong(image);\n        HDR.nameLen=ReadBlobLSBLong(image);\n        endian=LSBEndian;\n      }\n    else\n      {\n        HDR.nRows=ReadBlobMSBLong(image);\n        HDR.nCols=ReadBlobMSBLong(image);\n        HDR.imagf=ReadBlobMSBLong(image);\n        HDR.nameLen=ReadBlobMSBLong(image);\n        endian=MSBEndian;\n      }\n    if ((HDR.imagf != 0) && (HDR.imagf != 1))\n      break;\n    if (HDR.nameLen > 0xFFFF)\n      return(DestroyImageList(image));\n    for (i=0; i < (ssize_t) HDR.nameLen; i++)\n    {\n      int\n        byte;\n\n      /*\n        Skip matrix name.\n      */\n      byte=ReadBlobByte(image);\n      if (byte == EOF)\n        {\n          ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n            image->filename);\n          break;\n        }\n    }\n    image->columns=(size_t) HDR.nRows;\n    image->rows=(size_t) HDR.nCols;\n    if ((image->columns == 0) || (image->rows == 0))\n      return(DestroyImageList(image));\n    if (image_info->ping != MagickFalse)\n      {\n        Swap(image->columns,image->rows);\n        if(HDR.imagf==1) ldblk *= 2;\n        SeekBlob(image, HDR.nCols*ldblk, SEEK_CUR);\n        if ((image->columns == 0) || (image->rows == 0))\n          return(image->previous == (Image *) NULL ? DestroyImageList(image)\n            : image);\n        goto skip_reading_current;\n      }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    (void) SetImageBackgroundColor(image,exception);\n    (void) SetImageColorspace(image,GRAYColorspace,exception);\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      return(DestroyImageList(image));\n    switch(HDR.Type[1])\n    {\n      case 0:\n        format_type=FloatingPointQuantumFormat;\n        depth=64;\n        break;\n      case 1:\n        format_type=FloatingPointQuantumFormat;\n        depth=32;\n        break;\n      case 2:\n        format_type=UnsignedQuantumFormat;\n        depth=16;\n        break;\n      case 3:\n        format_type=SignedQuantumFormat;\n        depth=16;\n        break;\n      case 4:\n        format_type=UnsignedQuantumFormat;\n        depth=8;\n        break;\n      default:\n        format_type=UnsignedQuantumFormat;\n        depth=8;\n        break;\n    }\n    image->depth=depth;\n    if (HDR.Type[0] != 0)\n      SetQuantumEndian(image,quantum_info,MSBEndian);\n    status=SetQuantumFormat(image,quantum_info,format_type);\n    status=SetQuantumDepth(image,quantum_info,depth);\n    status=SetQuantumEndian(image,quantum_info,endian);\n    SetQuantumScale(quantum_info,1.0);\n    pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      register Quantum\n        *magick_restrict q;\n\n      count=ReadBlob(image,depth/8*image->columns,(char *) pixels);\n      if (count == -1)\n        break;\n      q=QueueAuthenticPixels(image,0,image->rows-y-1,image->columns,1,\n        exception);\n      if (q == (Quantum *) NULL)\n        break;\n      (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n        GrayQuantum,pixels,exception);\n      if ((HDR.Type[1] == 2) || (HDR.Type[1] == 3))\n        FixSignedValues(image,q,(int) image->columns);\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    if (HDR.imagf == 1)\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        /*\n          Read complex pixels.\n        */\n        count=ReadBlob(image,depth/8*image->columns,(char *) pixels);\n        if (count == -1)\n          break;\n        if (HDR.Type[1] == 0)\n          InsertComplexDoubleRow(image,(double *) pixels,y,0,0,exception);\n        else\n          InsertComplexFloatRow(image,(float *) pixels,y,0,0,exception);\n      }\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    rotated_image=RotateImage(image,90.0,exception);\n    if (rotated_image != (Image *) NULL)\n      {\n        rotated_image->page.x=0;\n        rotated_image->page.y=0;\n        rotated_image->colors = image->colors;\n        DestroyBlob(rotated_image);\n        rotated_image->blob=ReferenceBlob(image->blob);\n        AppendImageToList(&image,rotated_image);\n        DeleteImageFromList(&image);\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    /*\n      Allocate next image structure.\n    */\nskip_reading_current:\n    AcquireNextImage(image_info,image,exception);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      {\n        status=MagickFalse;\n        break;\n      }\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      GetBlobSize(image));\n    if (status == MagickFalse)\n      break;\n  }\n  (void) CloseBlob(image);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/transform.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/distort.h\"\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/module.h\"\n#include \"zlib.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/utility-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/string_.h\"\n\n// Type Definitions:\n// _Image:\nstruct _Image\n{\n  ClassType\n    storage_class;\n\n  ColorspaceType\n    colorspace;         /* colorspace of image data */\n\n  CompressionType\n    compression;        /* compression of image when read/write */\n\n  size_t\n    quality;            /* compression quality setting, meaning varies */\n\n  OrientationType\n    orientation;        /* photo orientation of image */\n\n  MagickBooleanType\n    taint;              /* has image been modified since reading */\n\n  size_t\n    columns,            /* physical size of image */\n    rows,\n    depth,              /* depth of image on read/write */\n    colors;             /* Size of color table, or actual color count */\n                        /* Only valid if image is not DirectClass */\n\n  PixelInfo\n    *colormap,\n    alpha_color,        /* deprecated */\n    background_color,   /* current background color attribute */\n    border_color,       /* current bordercolor attribute */\n    transparent_color;  /* color for 'transparent' color index in GIF */\n\n...\n\n// Image:\nclass MagickPPExport Image\n  {\n  public:\n\n    // Default constructor\n    Image(void);\n\n    // Construct Image from in-memory BLOB\n    Image(const Blob &blob_);\n\n    // Construct Image of specified size from in-memory BLOB\n    Image(const Blob &blob_,const Geometry &size_);\n\n    // Construct Image of specified size and depth from in-memory BLOB\n    Image(const Blob &blob_,const Geometry &size_,const size_t depth_);\n\n    // Construct Image of specified size, depth, and format from\n    // in-memory BLOB\n    Image(const Blob &blob_,const Geometry &size_,const size_t depth_,\n      const std::string &magick_);\n\n    // Construct Image of specified size, and format from in-memory BLOB\n    Image(const Blob &blob_,const Geometry &size_,const std::string &magick_);\n\n    // Construct a blank image canvas of specified size and color\n    Image(const Geometry &size_,const Color &color_);\n\n    // Copy constructor\n    Image(const Image &image_);\n\n    // Copy constructor to copy part of the image\n   ...\n\n// MagickBooleanType:\ntypedef enum\n{\n  MagickFalse = 0,\n  MagickTrue = 1\n}\n\n// Called Methods (top 10):\n// RemoveImageFromList from MagickCore/list.c:\nMagickExport Image *RemoveImageFromList(Image **images) /* <=== RemoveImageFromList */ \n{\n  register Image\n    *p;\n\n  assert(images != (Image **) NULL);\n  if ((*images) == (Image *) NULL)\n    return((Image *) NULL);\n  assert((*images)->signature == MagickCoreSignature);\n  if ((*images)->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      (*images)->filename);\n  p=(*images);\n  if ((p->previous == (Image *) NULL) && (p->next == (Image *) NULL))\n    *images=(Image *) NULL;\n  else\n    {\n      if (p->previous != (Image *) NULL)\n        {\n          p->previous->next=p->next;\n          *images=p->previous;\n        }\n      if (p->next != (Image *) NULL)\n        {\n          p->next->previous=p->previous;\n          *images=p->next;\n        }\n      p->previous=(Image *) NULL;\n      p->next=(Image *) NULL;\n    }\n  return(p);\n}\n\n// LogMagickEvent from MagickCore/log.c:\nMagickExport MagickBooleanType LogMagickEvent(const LogEventType type, /* <=== LogMagickEvent */ \n  const char *module,const char *function,const size_t line,\n  const char *format,...)\n{\n  va_list\n    operands;\n\n  MagickBooleanType\n    status;\n\n  if (IsEventLogging() == MagickFalse)\n    return(MagickFalse);\n  va_start(operands,format);\n  status=LogMagickEventList(type,module,function,line,format,operands);\n  va_end(operands);\n  return(status);\n}\n\n// DeleteImageFromList from MagickCore/list.c:\nMagickExport void DeleteImageFromList(Image **images) /* <=== DeleteImageFromList */ \n{\n  Image\n    *image;\n\n  image=RemoveImageFromList(images);\n  if (image != (Image *) NULL)\n    (void) DestroyImage(image);\n}\n\n// GetMagickModule from MagickCore/MagickCore/MagickCore/log.h:\n\n\n// DestroyImageList from MagickCore/list.c:\nMagickExport Image *DestroyImageList(Image *images) /* <=== DestroyImageList */ \n{\n  if (images == (Image *) NULL)\n    return((Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  while (images != (Image *) NULL)\n    DeleteImageFromList(&images);\n  return((Image *) NULL);\n}\n\n// LogMagickEventList from MagickCore/log.c:\nMagickExport MagickBooleanType LogMagickEventList(const LogEventType type, /* <=== LogMagickEventList */ \n  const char *module,const char *function,const size_t line,const char *format,\n  va_list operands)\n{\n  char\n    event[MagickPathExtent],\n    *text;\n\n  const char\n    *domain;\n\n  ExceptionInfo\n    *exception;\n\n  int\n    n;\n\n  LogInfo\n    *log_info;\n\n  exception=AcquireExceptionInfo();\n  log_info=(LogInfo *) GetLogInfo(\"*\",exception);\n  exception=DestroyExceptionInfo(exception);\n  if (event_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&event_semaphore);\n  LockSemaphoreInfo(event_semaphore);\n  if ((log_info->event_mask & type) == 0)\n    {\n      UnlockSemaphoreInfo(event_semaphore);\n      return(MagickTrue);\n    }\n  domain=CommandOptionToMnemonic(MagickLogEventOptions,type);\n#if defined(MAGICKCORE_HAVE_VSNPRINTF)\n  n=vsnprintf(event,MagickPathExtent,format,operands);\n#else\n  n=vsprintf(event,format,operands);\n#endif\n  if (n < 0)\n    event[MagickPathExtent-1]='\\0';\n  text=TranslateEvent(module,function,line,domain,event);\n  if (text == (char *) NULL)\n    {\n      (void) ContinueTimer((TimerInfo *) &log_info->timer);\n      UnlockSemaphoreInfo(event_semaphore);\n      return(MagickFalse);\n    }\n  if ((log_info->handler_mask & ConsoleHandler) != 0)\n    {\n      (void) FormatLocaleFile(stderr,\"%s\\n\",text);\n      (void) fflush(stderr);\n    }\n  if ((log_info->handler_mask & DebugHandler) != 0)\n    {\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n      OutputDebugString(text);\n      OutputDebugString(\"\\n\");\n#endif\n    }\n  if ((log_info->handler_mask & EventHandler) != 0)\n    {\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n      (void) NTReportEvent(text,MagickFalse);\n#endif\n    }\n  if ((log_info->handler_mask & FileHandler) != 0)\n    {\n      struct stat\n        file_info;\n\n      file_info.st_size=0;\n      if (log_info->file != (FILE *) NULL)\n        (void) fstat(fileno(log_info->file),&file_info);\n      if (file_info.st_size > (ssize_t) (1024*1024*log_info->limit))\n        {\n          (void) FormatLocaleFile(log_info->file,\"</log>\\n\");\n          (void) fclose(log_info->file);\n          log_info->file=(FILE *) NULL;\n        }\n      if (log_info->file == (FILE *) NULL)\n        {\n          char\n            *filename;\n\n          filename=TranslateFilename(log_info);\n          if (filename == (char *) NULL)\n            {\n              (void) ContinueTimer((TimerInfo *) &log_info->timer);\n              UnlockSemaphoreInfo(event_semaphore);\n              return(MagickFalse);\n            }\n          log_info->append=IsPathAccessible(filename);\n          log_info->file=fopen_utf8(filename,\"ab\");\n          filename=(char  *) RelinquishMagickMemory(filename);\n          if (log_info->file == (FILE *) NULL)\n            {\n              UnlockSemaphoreInfo(event_semaphore);\n              return(MagickFalse);\n            }\n          log_info->generation++;\n          if (log_info->append == MagickFalse)\n            (void) FormatLocaleFile(log_info->file,\"<?xml version=\\\"1.0\\\" \"\n              \"encoding=\\\"UTF-8\\\" standalone=\\\"yes\\\"?>\\n\");\n          (void) FormatLocaleFile(log_info->file,\"<log>\\n\");\n        }\n      (void) FormatLocaleFile(log_info->file,\"  <event>%s</event>\\n\",text);\n      (void) fflush(log_info->file);\n    }\n  if ((log_info->handler_mask & MethodHandler) != 0)\n    {\n      if (log_info->method != (MagickLogMethod) NULL)\n        log_info->method(type,text);\n    }\n  if ((log_info->handler_mask & StdoutHandler) != 0)\n    {\n      (void) FormatLocaleFile(stdout,\"%s\\n\",text);\n      (void) fflush(stdout);\n    }\n  if ((log_info->handler_mask & StderrHandler) != 0)\n    {\n      (void) FormatLocaleFile(stderr,\"%s\\n\",text);\n      (void) fflush(stderr);\n    }\n  text=(char  *) RelinquishMagickMemory(text);\n  (void) ContinueTimer((TimerInfo *) &log_info->timer);\n  UnlockSemaphoreInfo(event_semaphore);\n  return(MagickTrue);\n}\n\n// MagickCoreSignature from MagickCore/MagickCore/MagickCore/method-attribute.h:\n\n\n// GetFirstImageInList from MagickCore/list.c:\nMagickExport Image *GetFirstImageInList(const Image *images) /* <=== GetFirstImageInList */ \n{\n  register const Image\n    *p;\n\n  if (images == (Image *) NULL)\n    return((Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  for (p=images; p->previous != (Image *) NULL; p=p->previous) ;\n  return((Image *) p);\n}\n\n// IsEventLogging from MagickCore/log.c:\nMagickExport MagickBooleanType IsEventLogging(void) /* <=== IsEventLogging */ \n{\n  return(event_logging);\n}\n\n// DestroyImage from MagickCore/image.c:\nMagickExport Image *DestroyImage(Image *image) /* <=== DestroyImage */ \n{\n  MagickBooleanType\n    destroy;\n\n  /*\n    Dereference image.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  destroy=MagickFalse;\n  LockSemaphoreInfo(image->semaphore);\n  image->reference_count--;\n  if (image->reference_count == 0)\n    destroy=MagickTrue;\n  UnlockSemaphoreInfo(image->semaphore);\n  if (destroy == MagickFalse)\n    return((Image *) NULL);\n  /*\n    Destroy image.\n  */\n  DestroyImagePixels(image);\n  image->channel_map=DestroyPixelChannelMap(image->channel_map);\n  if (image->montage != (char *) NULL)\n    image->montage=DestroyString(image->montage);\n  if (image->directory != (char *) NULL)\n    image->directory=DestroyString(image->directory);\n  if (image->colormap != (PixelInfo *) NULL)\n    image->colormap=(PixelInfo *) RelinquishMagickMemory(image->colormap);\n  if (image->geometry != (char *) NULL)\n    image->geometry=DestroyString(image->geometry);\n  DestroyImageProfiles(image);\n  DestroyImageProperties(image);\n  DestroyImageArtifacts(image);\n  if (image->ascii85 != (Ascii85Info *) NULL)\n    image->ascii85=(Ascii85Info *) RelinquishMagickMemory(image->ascii85);\n  if (image->image_info != (ImageInfo *) NULL)\n    image->image_info=DestroyImageInfo(image->image_info);\n  DestroyBlob(image);\n  if (image->semaphore != (SemaphoreInfo *) NULL)\n    RelinquishSemaphoreInfo(&image->semaphore);\n  image->signature=(~MagickCoreSignature);\n  image=(Image *) RelinquishMagickMemory(image);\n  return(image);\n}\n"
  },
  {
    "repository": "vim",
    "cve_id": "CVE-2022-1968",
    "cwe_list": [
      "CWE-416"
    ],
    "commit_hash": "409510c588b1eec1ae33511ae97a21eb8e110895",
    "short_hash": "409510c5",
    "vulnerableMethods_before": [
      {
        "filename": "search.c",
        "method_name": "vulnerable_function",
        "raw_code": "find_pattern_in_path(\n    char_u\t*ptr,\t\t// pointer to search pattern\n    int\t\tdir UNUSED,\t// direction of expansion\n    int\t\tlen,\t\t// length of search pattern\n    int\t\twhole,\t\t// match whole words only\n    int\t\tskip_comments,\t// don't match inside comments\n    int\t\ttype,\t\t// Type of search; are we looking for a type?\n\t\t\t\t// a macro?\n    long\tcount,\n    int\t\taction,\t\t// What to do when we find it\n    linenr_T\tstart_lnum,\t// first line to start searching\n    linenr_T\tend_lnum)\t// last line for searching\n{\n    SearchedFile *files;\t\t// Stack of included files\n    SearchedFile *bigger;\t\t// When we need more space\n    int\t\tmax_path_depth = 50;\n    long\tmatch_count = 1;\n\n    char_u\t*pat;\n    char_u\t*new_fname;\n    char_u\t*curr_fname = curbuf->b_fname;\n    char_u\t*prev_fname = NULL;\n    linenr_T\tlnum;\n    int\t\tdepth;\n    int\t\tdepth_displayed;\t// For type==CHECK_PATH\n    int\t\told_files;\n    int\t\talready_searched;\n    char_u\t*file_line;\n    char_u\t*line;\n    char_u\t*p;\n    char_u\tsave_char;\n    int\t\tdefine_matched;\n    regmatch_T\tregmatch;\n    regmatch_T\tincl_regmatch;\n    regmatch_T\tdef_regmatch;\n    int\t\tmatched = FALSE;\n    int\t\tdid_show = FALSE;\n    int\t\tfound = FALSE;\n    int\t\ti;\n    char_u\t*already = NULL;\n    char_u\t*startp = NULL;\n    char_u\t*inc_opt = NULL;\n#if defined(FEAT_QUICKFIX)\n    win_T\t*curwin_save = NULL;\n#endif\n\n    regmatch.regprog = NULL;\n    incl_regmatch.regprog = NULL;\n    def_regmatch.regprog = NULL;\n\n    file_line = alloc(LSIZE);\n    if (file_line == NULL)\n\treturn;\n\n    if (type != CHECK_PATH && type != FIND_DEFINE\n\t    // when CONT_SOL is set compare \"ptr\" with the beginning of the\n\t    // line is faster than quote_meta/regcomp/regexec \"ptr\" -- Acevedo\n\t    && !compl_status_sol())\n    {\n\tpat = alloc(len + 5);\n\tif (pat == NULL)\n\t    goto fpip_end;\n\tsprintf((char *)pat, whole ? \"\\\\<%.*s\\\\>\" : \"%.*s\", len, ptr);\n\t// ignore case according to p_ic, p_scs and pat\n\tregmatch.rm_ic = ignorecase(pat);\n\tregmatch.regprog = vim_regcomp(pat, magic_isset() ? RE_MAGIC : 0);\n\tvim_free(pat);\n\tif (regmatch.regprog == NULL)\n\t    goto fpip_end;\n    }\n    inc_opt = (*curbuf->b_p_inc == NUL) ? p_inc : curbuf->b_p_inc;\n    if (*inc_opt != NUL)\n    {\n\tincl_regmatch.regprog = vim_regcomp(inc_opt,\n\t\t\t\t\t\t magic_isset() ? RE_MAGIC : 0);\n\tif (incl_regmatch.regprog == NULL)\n\t    goto fpip_end;\n\tincl_regmatch.rm_ic = FALSE;\t// don't ignore case in incl. pat.\n    }\n    if (type == FIND_DEFINE && (*curbuf->b_p_def != NUL || *p_def != NUL))\n    {\n\tdef_regmatch.regprog = vim_regcomp(*curbuf->b_p_def == NUL\n\t\t\t   ? p_def : curbuf->b_p_def,\n\t\t\t\t\t\t magic_isset() ? RE_MAGIC : 0);\n\tif (def_regmatch.regprog == NULL)\n\t    goto fpip_end;\n\tdef_regmatch.rm_ic = FALSE;\t// don't ignore case in define pat.\n    }\n    files = lalloc_clear(max_path_depth * sizeof(SearchedFile), TRUE);\n    if (files == NULL)\n\tgoto fpip_end;\n    old_files = max_path_depth;\n    depth = depth_displayed = -1;\n\n    lnum = start_lnum;\n    if (end_lnum > curbuf->b_ml.ml_line_count)\n\tend_lnum = curbuf->b_ml.ml_line_count;\n    if (lnum > end_lnum)\t\t// do at least one line\n\tlnum = end_lnum;\n    line = ml_get(lnum);\n\n    for (;;)\n    {\n\tif (incl_regmatch.regprog != NULL\n\t\t&& vim_regexec(&incl_regmatch, line, (colnr_T)0))\n\t{\n\t    char_u *p_fname = (curr_fname == curbuf->b_fname)\n\t\t\t\t\t      ? curbuf->b_ffname : curr_fname;\n\n\t    if (inc_opt != NULL && strstr((char *)inc_opt, \"\\\\zs\") != NULL)\n\t\t// Use text from '\\zs' to '\\ze' (or end) of 'include'.\n\t\tnew_fname = find_file_name_in_path(incl_regmatch.startp[0],\n\t\t       (int)(incl_regmatch.endp[0] - incl_regmatch.startp[0]),\n\t\t\t\t FNAME_EXP|FNAME_INCL|FNAME_REL, 1L, p_fname);\n\t    else\n\t\t// Use text after match with 'include'.\n\t\tnew_fname = file_name_in_line(incl_regmatch.endp[0], 0,\n\t\t\t     FNAME_EXP|FNAME_INCL|FNAME_REL, 1L, p_fname, NULL);\n\t    already_searched = FALSE;\n\t    if (new_fname != NULL)\n\t    {\n\t\t// Check whether we have already searched in this file\n\t\tfor (i = 0;; i++)\n\t\t{\n\t\t    if (i == depth + 1)\n\t\t\ti = old_files;\n\t\t    if (i == max_path_depth)\n\t\t\tbreak;\n\t\t    if (fullpathcmp(new_fname, files[i].name, TRUE, TRUE)\n\t\t\t\t\t\t\t\t    & FPC_SAME)\n\t\t    {\n\t\t\tif (type != CHECK_PATH\n\t\t\t\t&& action == ACTION_SHOW_ALL\n\t\t\t\t&& files[i].matched)\n\t\t\t{\n\t\t\t    msg_putchar('\\n');\t    // cursor below last one\n\t\t\t    if (!got_int)\t    // don't display if 'q'\n\t\t\t\t\t\t    // typed at \"--more--\"\n\t\t\t\t\t\t    // message\n\t\t\t    {\n\t\t\t\tmsg_home_replace_hl(new_fname);\n\t\t\t\tmsg_puts(_(\" (includes previously listed match)\"));\n\t\t\t\tprev_fname = NULL;\n\t\t\t    }\n\t\t\t}\n\t\t\tVIM_CLEAR(new_fname);\n\t\t\talready_searched = TRUE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\n\t    if (type == CHECK_PATH && (action == ACTION_SHOW_ALL\n\t\t\t\t || (new_fname == NULL && !already_searched)))\n\t    {\n\t\tif (did_show)\n\t\t    msg_putchar('\\n');\t    // cursor below last one\n\t\telse\n\t\t{\n\t\t    gotocmdline(TRUE);\t    // cursor at status line\n\t\t    msg_puts_title(_(\"--- Included files \"));\n\t\t    if (action != ACTION_SHOW_ALL)\n\t\t\tmsg_puts_title(_(\"not found \"));\n\t\t    msg_puts_title(_(\"in path ---\\n\"));\n\t\t}\n\t\tdid_show = TRUE;\n\t\twhile (depth_displayed < depth && !got_int)\n\t\t{\n\t\t    ++depth_displayed;\n\t\t    for (i = 0; i < depth_displayed; i++)\n\t\t\tmsg_puts(\"  \");\n\t\t    msg_home_replace(files[depth_displayed].name);\n\t\t    msg_puts(\" -->\\n\");\n\t\t}\n\t\tif (!got_int)\t\t    // don't display if 'q' typed\n\t\t\t\t\t    // for \"--more--\" message\n\t\t{\n\t\t    for (i = 0; i <= depth_displayed; i++)\n\t\t\tmsg_puts(\"  \");\n\t\t    if (new_fname != NULL)\n\t\t    {\n\t\t\t// using \"new_fname\" is more reliable, e.g., when\n\t\t\t// 'includeexpr' is set.\n\t\t\tmsg_outtrans_attr(new_fname, HL_ATTR(HLF_D));\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t/*\n\t\t\t * Isolate the file name.\n\t\t\t * Include the surrounding \"\" or <> if present.\n\t\t\t */\n\t\t\tif (inc_opt != NULL\n\t\t\t\t   && strstr((char *)inc_opt, \"\\\\zs\") != NULL)\n\t\t\t{\n\t\t\t    // pattern contains \\zs, use the match\n\t\t\t    p = incl_regmatch.startp[0];\n\t\t\t    i = (int)(incl_regmatch.endp[0]\n\t\t\t\t\t\t   - incl_regmatch.startp[0]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // find the file name after the end of the match\n\t\t\t    for (p = incl_regmatch.endp[0];\n\t\t\t\t\t\t  *p && !vim_isfilec(*p); p++)\n\t\t\t\t;\n\t\t\t    for (i = 0; vim_isfilec(p[i]); i++)\n\t\t\t\t;\n\t\t\t}\n\n\t\t\tif (i == 0)\n\t\t\t{\n\t\t\t    // Nothing found, use the rest of the line.\n\t\t\t    p = incl_regmatch.endp[0];\n\t\t\t    i = (int)STRLEN(p);\n\t\t\t}\n\t\t\t// Avoid checking before the start of the line, can\n\t\t\t// happen if \\zs appears in the regexp.\n\t\t\telse if (p > line)\n\t\t\t{\n\t\t\t    if (p[-1] == '\"' || p[-1] == '<')\n\t\t\t    {\n\t\t\t\t--p;\n\t\t\t\t++i;\n\t\t\t    }\n\t\t\t    if (p[i] == '\"' || p[i] == '>')\n\t\t\t\t++i;\n\t\t\t}\n\t\t\tsave_char = p[i];\n\t\t\tp[i] = NUL;\n\t\t\tmsg_outtrans_attr(p, HL_ATTR(HLF_D));\n\t\t\tp[i] = save_char;\n\t\t    }\n\n\t\t    if (new_fname == NULL && action == ACTION_SHOW_ALL)\n\t\t    {\n\t\t\tif (already_searched)\n\t\t\t    msg_puts(_(\"  (Already listed)\"));\n\t\t\telse\n\t\t\t    msg_puts(_(\"  NOT FOUND\"));\n\t\t    }\n\t\t}\n\t\tout_flush();\t    // output each line directly\n\t    }\n\n\t    if (new_fname != NULL)\n\t    {\n\t\t// Push the new file onto the file stack\n\t\tif (depth + 1 == old_files)\n\t\t{\n\t\t    bigger = ALLOC_MULT(SearchedFile, max_path_depth * 2);\n\t\t    if (bigger != NULL)\n\t\t    {\n\t\t\tfor (i = 0; i <= depth; i++)\n\t\t\t    bigger[i] = files[i];\n\t\t\tfor (i = depth + 1; i < old_files + max_path_depth; i++)\n\t\t\t{\n\t\t\t    bigger[i].fp = NULL;\n\t\t\t    bigger[i].name = NULL;\n\t\t\t    bigger[i].lnum = 0;\n\t\t\t    bigger[i].matched = FALSE;\n\t\t\t}\n\t\t\tfor (i = old_files; i < max_path_depth; i++)\n\t\t\t    bigger[i + max_path_depth] = files[i];\n\t\t\told_files += max_path_depth;\n\t\t\tmax_path_depth *= 2;\n\t\t\tvim_free(files);\n\t\t\tfiles = bigger;\n\t\t    }\n\t\t}\n\t\tif ((files[depth + 1].fp = mch_fopen((char *)new_fname, \"r\"))\n\t\t\t\t\t\t\t\t    == NULL)\n\t\t    vim_free(new_fname);\n\t\telse\n\t\t{\n\t\t    if (++depth == old_files)\n\t\t    {\n\t\t\t/*\n\t\t\t * lalloc() for 'bigger' must have failed above.  We\n\t\t\t * will forget one of our already visited files now.\n\t\t\t */\n\t\t\tvim_free(files[old_files].name);\n\t\t\t++old_files;\n\t\t    }\n\t\t    files[depth].name = curr_fname = new_fname;\n\t\t    files[depth].lnum = 0;\n\t\t    files[depth].matched = FALSE;\n\t\t    if (action == ACTION_EXPAND)\n\t\t    {\n\t\t\tmsg_hist_off = TRUE;\t// reset in msg_trunc_attr()\n\t\t\tvim_snprintf((char*)IObuff, IOSIZE,\n\t\t\t\t_(\"Scanning included file: %s\"),\n\t\t\t\t(char *)new_fname);\n\t\t\tmsg_trunc_attr((char *)IObuff, TRUE, HL_ATTR(HLF_R));\n\t\t    }\n\t\t    else if (p_verbose >= 5)\n\t\t    {\n\t\t\tverbose_enter();\n\t\t\tsmsg(_(\"Searching included file %s\"),\n\t\t\t\t\t\t\t   (char *)new_fname);\n\t\t\tverbose_leave();\n\t\t    }\n\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    /*\n\t     * Check if the line is a define (type == FIND_DEFINE)\n\t     */\n\t    p = line;\nsearch_line:\n\t    define_matched = FALSE;\n\t    if (def_regmatch.regprog != NULL\n\t\t\t      && vim_regexec(&def_regmatch, line, (colnr_T)0))\n\t    {\n\t\t/*\n\t\t * Pattern must be first identifier after 'define', so skip\n\t\t * to that position before checking for match of pattern.  Also\n\t\t * don't let it match beyond the end of this identifier.\n\t\t */\n\t\tp = def_regmatch.endp[0];\n\t\twhile (*p && !vim_iswordc(*p))\n\t\t    p++;\n\t\tdefine_matched = TRUE;\n\t    }\n\n\t    /*\n\t     * Look for a match.  Don't do this if we are looking for a\n\t     * define and this line didn't match define_prog above.\n\t     */\n\t    if (def_regmatch.regprog == NULL || define_matched)\n\t    {\n\t\tif (define_matched || compl_status_sol())\n\t\t{\n\t\t    // compare the first \"len\" chars from \"ptr\"\n\t\t    startp = skipwhite(p);\n\t\t    if (p_ic)\n\t\t\tmatched = !MB_STRNICMP(startp, ptr, len);\n\t\t    else\n\t\t\tmatched = !STRNCMP(startp, ptr, len);\n\t\t    if (matched && define_matched && whole\n\t\t\t\t\t\t  && vim_iswordc(startp[len]))\n\t\t\tmatched = FALSE;\n\t\t}\n\t\telse if (regmatch.regprog != NULL\n\t\t\t && vim_regexec(&regmatch, line, (colnr_T)(p - line)))\n\t\t{\n\t\t    matched = TRUE;\n\t\t    startp = regmatch.startp[0];\n\t\t    /*\n\t\t     * Check if the line is not a comment line (unless we are\n\t\t     * looking for a define).  A line starting with \"# define\"\n\t\t     * is not considered to be a comment line.\n\t\t     */\n\t\t    if (!define_matched && skip_comments)\n\t\t    {\n\t\t\tif ((*line != '#' ||\n\t\t\t\tSTRNCMP(skipwhite(line + 1), \"define\", 6) != 0)\n\t\t\t\t&& get_leader_len(line, NULL, FALSE, TRUE))\n\t\t\t    matched = FALSE;\n\n\t\t\t/*\n\t\t\t * Also check for a \"/ *\" or \"/ /\" before the match.\n\t\t\t * Skips lines like \"int backwards;  / * normal index\n\t\t\t * * /\" when looking for \"normal\".\n\t\t\t * Note: Doesn't skip \"/ *\" in comments.\n\t\t\t */\n\t\t\tp = skipwhite(line);\n\t\t\tif (matched\n\t\t\t\t|| (p[0] == '/' && p[1] == '*') || p[0] == '*')\n\t\t\t    for (p = line; *p && p < startp; ++p)\n\t\t\t    {\n\t\t\t\tif (matched\n\t\t\t\t\t&& p[0] == '/'\n\t\t\t\t\t&& (p[1] == '*' || p[1] == '/'))\n\t\t\t\t{\n\t\t\t\t    matched = FALSE;\n\t\t\t\t    // After \"//\" all text is comment\n\t\t\t\t    if (p[1] == '/')\n\t\t\t\t\tbreak;\n\t\t\t\t    ++p;\n\t\t\t\t}\n\t\t\t\telse if (!matched && p[0] == '*' && p[1] == '/')\n\t\t\t\t{\n\t\t\t\t    // Can find match after \"* /\".\n\t\t\t\t    matched = TRUE;\n\t\t\t\t    ++p;\n\t\t\t\t}\n\t\t\t    }\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif (matched)\n\t{\n\t    if (action == ACTION_EXPAND)\n\t    {\n\t\tint\tcont_s_ipos = FALSE;\n\t\tint\tadd_r;\n\t\tchar_u\t*aux;\n\n\t\tif (depth == -1 && lnum == curwin->w_cursor.lnum)\n\t\t    break;\n\t\tfound = TRUE;\n\t\taux = p = startp;\n\t\tif (compl_status_adding())\n\t\t{\n\t\t    p += ins_compl_len();\n\t\t    if (vim_iswordp(p))\n\t\t\tgoto exit_matched;\n\t\t    p = find_word_start(p);\n\t\t}\n\t\tp = find_word_end(p);\n\t\ti = (int)(p - aux);\n\n\t\tif (compl_status_adding() && i == ins_compl_len())\n\t\t{\n\t\t    // IOSIZE > compl_length, so the STRNCPY works\n\t\t    STRNCPY(IObuff, aux, i);\n\n\t\t    // Get the next line: when \"depth\" < 0  from the current\n\t\t    // buffer, otherwise from the included file.  Jump to\n\t\t    // exit_matched when past the last line.\n\t\t    if (depth < 0)\n\t\t    {\n\t\t\tif (lnum >= end_lnum)\n\t\t\t    goto exit_matched;\n\t\t\tline = ml_get(++lnum);\n\t\t    }\n\t\t    else if (vim_fgets(line = file_line,\n\t\t\t\t\t\t      LSIZE, files[depth].fp))\n\t\t\tgoto exit_matched;\n\n\t\t    // we read a line, set \"already\" to check this \"line\" later\n\t\t    // if depth >= 0 we'll increase files[depth].lnum far\n\t\t    // below  -- Acevedo\n\t\t    already = aux = p = skipwhite(line);\n\t\t    p = find_word_start(p);\n\t\t    p = find_word_end(p);\n\t\t    if (p > aux)\n\t\t    {\n\t\t\tif (*aux != ')' && IObuff[i-1] != TAB)\n\t\t\t{\n\t\t\t    if (IObuff[i-1] != ' ')\n\t\t\t\tIObuff[i++] = ' ';\n\t\t\t    // IObuf =~ \"\\(\\k\\|\\i\\).* \", thus i >= 2\n\t\t\t    if (p_js\n\t\t\t\t&& (IObuff[i-2] == '.'\n\t\t\t\t    || (vim_strchr(p_cpo, CPO_JOINSP) == NULL\n\t\t\t\t\t&& (IObuff[i-2] == '?'\n\t\t\t\t\t    || IObuff[i-2] == '!'))))\n\t\t\t\tIObuff[i++] = ' ';\n\t\t\t}\n\t\t\t// copy as much as possible of the new word\n\t\t\tif (p - aux >= IOSIZE - i)\n\t\t\t    p = aux + IOSIZE - i - 1;\n\t\t\tSTRNCPY(IObuff + i, aux, p - aux);\n\t\t\ti += (int)(p - aux);\n\t\t\tcont_s_ipos = TRUE;\n\t\t    }\n\t\t    IObuff[i] = NUL;\n\t\t    aux = IObuff;\n\n\t\t    if (i == ins_compl_len())\n\t\t\tgoto exit_matched;\n\t\t}\n\n\t\tadd_r = ins_compl_add_infercase(aux, i, p_ic,\n\t\t\tcurr_fname == curbuf->b_fname ? NULL : curr_fname,\n\t\t\tdir, cont_s_ipos);\n\t\tif (add_r == OK)\n\t\t    // if dir was BACKWARD then honor it just once\n\t\t    dir = FORWARD;\n\t\telse if (add_r == FAIL)\n\t\t    break;\n\t    }\n\t    else if (action == ACTION_SHOW_ALL)\n\t    {\n\t\tfound = TRUE;\n\t\tif (!did_show)\n\t\t    gotocmdline(TRUE);\t\t// cursor at status line\n\t\tif (curr_fname != prev_fname)\n\t\t{\n\t\t    if (did_show)\n\t\t\tmsg_putchar('\\n');\t// cursor below last one\n\t\t    if (!got_int)\t\t// don't display if 'q' typed\n\t\t\t\t\t\t// at \"--more--\" message\n\t\t\tmsg_home_replace_hl(curr_fname);\n\t\t    prev_fname = curr_fname;\n\t\t}\n\t\tdid_show = TRUE;\n\t\tif (!got_int)\n\t\t    show_pat_in_path(line, type, TRUE, action,\n\t\t\t    (depth == -1) ? NULL : files[depth].fp,\n\t\t\t    (depth == -1) ? &lnum : &files[depth].lnum,\n\t\t\t    match_count++);\n\n\t\t// Set matched flag for this file and all the ones that\n\t\t// include it\n\t\tfor (i = 0; i <= depth; ++i)\n\t\t    files[i].matched = TRUE;\n\t    }\n\t    else if (--count <= 0)\n\t    {\n\t\tfound = TRUE;\n\t\tif (depth == -1 && lnum == curwin->w_cursor.lnum\n#if defined(FEAT_QUICKFIX)\n\t\t\t\t\t\t      && g_do_tagpreview == 0\n#endif\n\t\t\t\t\t\t      )\n\t\t    emsg(_(e_match_is_on_current_line));\n\t\telse if (action == ACTION_SHOW)\n\t\t{\n\t\t    show_pat_in_path(line, type, did_show, action,\n\t\t\t(depth == -1) ? NULL : files[depth].fp,\n\t\t\t(depth == -1) ? &lnum : &files[depth].lnum, 1L);\n\t\t    did_show = TRUE;\n\t\t}\n\t\telse\n\t\t{\n#ifdef FEAT_GUI\n\t\t    need_mouse_correct = TRUE;\n#endif\n#if defined(FEAT_QUICKFIX)\n\t\t    // \":psearch\" uses the preview window\n\t\t    if (g_do_tagpreview != 0)\n\t\t    {\n\t\t\tcurwin_save = curwin;\n\t\t\tprepare_tagpreview(TRUE, TRUE, FALSE);\n\t\t    }\n#endif\n\t\t    if (action == ACTION_SPLIT)\n\t\t    {\n\t\t\tif (win_split(0, 0) == FAIL)\n\t\t\t    break;\n\t\t\tRESET_BINDING(curwin);\n\t\t    }\n\t\t    if (depth == -1)\n\t\t    {\n\t\t\t// match in current file\n#if defined(FEAT_QUICKFIX)\n\t\t\tif (g_do_tagpreview != 0)\n\t\t\t{\n\t\t\t    if (!win_valid(curwin_save))\n\t\t\t\tbreak;\n\t\t\t    if (!GETFILE_SUCCESS(getfile(\n\t\t\t\t\t   curwin_save->w_buffer->b_fnum, NULL,\n\t\t\t\t\t\t     NULL, TRUE, lnum, FALSE)))\n\t\t\t\tbreak;\t// failed to jump to file\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t    setpcmark();\n\t\t\tcurwin->w_cursor.lnum = lnum;\n\t\t\tcheck_cursor();\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (!GETFILE_SUCCESS(getfile(\n\t\t\t\t\t0, files[depth].name, NULL, TRUE,\n\t\t\t\t\t\t    files[depth].lnum, FALSE)))\n\t\t\t    break;\t// failed to jump to file\n\t\t\t// autocommands may have changed the lnum, we don't\n\t\t\t// want that here\n\t\t\tcurwin->w_cursor.lnum = files[depth].lnum;\n\t\t    }\n\t\t}\n\t\tif (action != ACTION_SHOW)\n\t\t{\n\t\t    curwin->w_cursor.col = (colnr_T)(startp - line);\n\t\t    curwin->w_set_curswant = TRUE;\n\t\t}\n\n#if defined(FEAT_QUICKFIX)\n\t\tif (g_do_tagpreview != 0\n\t\t\t   && curwin != curwin_save && win_valid(curwin_save))\n\t\t{\n\t\t    // Return cursor to where we were\n\t\t    validate_cursor();\n\t\t    redraw_later(VALID);\n\t\t    win_enter(curwin_save, TRUE);\n\t\t}\n# ifdef FEAT_PROP_POPUP\n\t\telse if (WIN_IS_POPUP(curwin))\n\t\t    // can't keep focus in popup window\n\t\t    win_enter(firstwin, TRUE);\n# endif\n#endif\n\t\tbreak;\n\t    }\nexit_matched:\n\t    matched = FALSE;\n\t    // look for other matches in the rest of the line if we\n\t    // are not at the end of it already\n\t    if (def_regmatch.regprog == NULL\n\t\t    && action == ACTION_EXPAND\n\t\t    && !compl_status_sol()\n\t\t    && *startp != NUL\n\t\t    && *(p = startp + mb_ptr2len(startp)) != NUL)\n\t\tgoto search_line;\n\t}\n\tline_breakcheck();\n\tif (action == ACTION_EXPAND)\n\t    ins_compl_check_keys(30, FALSE);\n\tif (got_int || ins_compl_interrupted())\n\t    break;\n\n\t/*\n\t * Read the next line.  When reading an included file and encountering\n\t * end-of-file, close the file and continue in the file that included\n\t * it.\n\t */\n\twhile (depth >= 0 && !already\n\t\t&& vim_fgets(line = file_line, LSIZE, files[depth].fp))\n\t{\n\t    fclose(files[depth].fp);\n\t    --old_files;\n\t    files[old_files].name = files[depth].name;\n\t    files[old_files].matched = files[depth].matched;\n\t    --depth;\n\t    curr_fname = (depth == -1) ? curbuf->b_fname\n\t\t\t\t       : files[depth].name;\n\t    if (depth < depth_displayed)\n\t\tdepth_displayed = depth;\n\t}\n\tif (depth >= 0)\t\t// we could read the line\n\t{\n\t    files[depth].lnum++;\n\t    // Remove any CR and LF from the line.\n\t    i = (int)STRLEN(line);\n\t    if (i > 0 && line[i - 1] == '\\n')\n\t\tline[--i] = NUL;\n\t    if (i > 0 && line[i - 1] == '\\r')\n\t\tline[--i] = NUL;\n\t}\n\telse if (!already)\n\t{\n\t    if (++lnum > end_lnum)\n\t\tbreak;\n\t    line = ml_get(lnum);\n\t}\n\talready = NULL;\n    }\n    // End of big for (;;) loop.\n\n    // Close any files that are still open.\n    for (i = 0; i <= depth; i++)\n    {\n\tfclose(files[i].fp);\n\tvim_free(files[i].name);\n    }\n    for (i = old_files; i < max_path_depth; i++)\n\tvim_free(files[i].name);\n    vim_free(files);\n\n    if (type == CHECK_PATH)\n    {\n\tif (!did_show)\n\t{\n\t    if (action != ACTION_SHOW_ALL)\n\t\tmsg(_(\"All included files were found\"));\n\t    else\n\t\tmsg(_(\"No included files\"));\n\t}\n    }\n    else if (!found && action != ACTION_EXPAND)\n    {\n\tif (got_int || ins_compl_interrupted())\n\t    emsg(_(e_interrupted));\n\telse if (type == FIND_DEFINE)\n\t    emsg(_(e_couldnt_find_definition));\n\telse\n\t    emsg(_(e_couldnt_find_pattern));\n    }\n    if (action == ACTION_SHOW || action == ACTION_SHOW_ALL)\n\tmsg_end();\n\nfpip_end:\n    vim_free(file_line);\n    vim_regfree(regmatch.regprog);\n    vim_regfree(incl_regmatch.regprog);\n    vim_regfree(def_regmatch.regprog);\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "search.c",
        "method_name": "fixed_function",
        "raw_code": "find_pattern_in_path(\n    char_u\t*ptr,\t\t// pointer to search pattern\n    int\t\tdir UNUSED,\t// direction of expansion\n    int\t\tlen,\t\t// length of search pattern\n    int\t\twhole,\t\t// match whole words only\n    int\t\tskip_comments,\t// don't match inside comments\n    int\t\ttype,\t\t// Type of search; are we looking for a type?\n\t\t\t\t// a macro?\n    long\tcount,\n    int\t\taction,\t\t// What to do when we find it\n    linenr_T\tstart_lnum,\t// first line to start searching\n    linenr_T\tend_lnum)\t// last line for searching\n{\n    SearchedFile *files;\t\t// Stack of included files\n    SearchedFile *bigger;\t\t// When we need more space\n    int\t\tmax_path_depth = 50;\n    long\tmatch_count = 1;\n\n    char_u\t*pat;\n    char_u\t*new_fname;\n    char_u\t*curr_fname = curbuf->b_fname;\n    char_u\t*prev_fname = NULL;\n    linenr_T\tlnum;\n    int\t\tdepth;\n    int\t\tdepth_displayed;\t// For type==CHECK_PATH\n    int\t\told_files;\n    int\t\talready_searched;\n    char_u\t*file_line;\n    char_u\t*line;\n    char_u\t*p;\n    char_u\tsave_char;\n    int\t\tdefine_matched;\n    regmatch_T\tregmatch;\n    regmatch_T\tincl_regmatch;\n    regmatch_T\tdef_regmatch;\n    int\t\tmatched = FALSE;\n    int\t\tdid_show = FALSE;\n    int\t\tfound = FALSE;\n    int\t\ti;\n    char_u\t*already = NULL;\n    char_u\t*startp = NULL;\n    char_u\t*inc_opt = NULL;\n#if defined(FEAT_QUICKFIX)\n    win_T\t*curwin_save = NULL;\n#endif\n\n    regmatch.regprog = NULL;\n    incl_regmatch.regprog = NULL;\n    def_regmatch.regprog = NULL;\n\n    file_line = alloc(LSIZE);\n    if (file_line == NULL)\n\treturn;\n\n    if (type != CHECK_PATH && type != FIND_DEFINE\n\t    // when CONT_SOL is set compare \"ptr\" with the beginning of the\n\t    // line is faster than quote_meta/regcomp/regexec \"ptr\" -- Acevedo\n\t    && !compl_status_sol())\n    {\n\tpat = alloc(len + 5);\n\tif (pat == NULL)\n\t    goto fpip_end;\n\tsprintf((char *)pat, whole ? \"\\\\<%.*s\\\\>\" : \"%.*s\", len, ptr);\n\t// ignore case according to p_ic, p_scs and pat\n\tregmatch.rm_ic = ignorecase(pat);\n\tregmatch.regprog = vim_regcomp(pat, magic_isset() ? RE_MAGIC : 0);\n\tvim_free(pat);\n\tif (regmatch.regprog == NULL)\n\t    goto fpip_end;\n    }\n    inc_opt = (*curbuf->b_p_inc == NUL) ? p_inc : curbuf->b_p_inc;\n    if (*inc_opt != NUL)\n    {\n\tincl_regmatch.regprog = vim_regcomp(inc_opt,\n\t\t\t\t\t\t magic_isset() ? RE_MAGIC : 0);\n\tif (incl_regmatch.regprog == NULL)\n\t    goto fpip_end;\n\tincl_regmatch.rm_ic = FALSE;\t// don't ignore case in incl. pat.\n    }\n    if (type == FIND_DEFINE && (*curbuf->b_p_def != NUL || *p_def != NUL))\n    {\n\tdef_regmatch.regprog = vim_regcomp(*curbuf->b_p_def == NUL\n\t\t\t   ? p_def : curbuf->b_p_def,\n\t\t\t\t\t\t magic_isset() ? RE_MAGIC : 0);\n\tif (def_regmatch.regprog == NULL)\n\t    goto fpip_end;\n\tdef_regmatch.rm_ic = FALSE;\t// don't ignore case in define pat.\n    }\n    files = lalloc_clear(max_path_depth * sizeof(SearchedFile), TRUE);\n    if (files == NULL)\n\tgoto fpip_end;\n    old_files = max_path_depth;\n    depth = depth_displayed = -1;\n\n    lnum = start_lnum;\n    if (end_lnum > curbuf->b_ml.ml_line_count)\n\tend_lnum = curbuf->b_ml.ml_line_count;\n    if (lnum > end_lnum)\t\t// do at least one line\n\tlnum = end_lnum;\n    line = get_line_and_copy(lnum, file_line);\n\n    for (;;)\n    {\n\tif (incl_regmatch.regprog != NULL\n\t\t&& vim_regexec(&incl_regmatch, line, (colnr_T)0))\n\t{\n\t    char_u *p_fname = (curr_fname == curbuf->b_fname)\n\t\t\t\t\t      ? curbuf->b_ffname : curr_fname;\n\n\t    if (inc_opt != NULL && strstr((char *)inc_opt, \"\\\\zs\") != NULL)\n\t\t// Use text from '\\zs' to '\\ze' (or end) of 'include'.\n\t\tnew_fname = find_file_name_in_path(incl_regmatch.startp[0],\n\t\t       (int)(incl_regmatch.endp[0] - incl_regmatch.startp[0]),\n\t\t\t\t FNAME_EXP|FNAME_INCL|FNAME_REL, 1L, p_fname);\n\t    else\n\t\t// Use text after match with 'include'.\n\t\tnew_fname = file_name_in_line(incl_regmatch.endp[0], 0,\n\t\t\t     FNAME_EXP|FNAME_INCL|FNAME_REL, 1L, p_fname, NULL);\n\t    already_searched = FALSE;\n\t    if (new_fname != NULL)\n\t    {\n\t\t// Check whether we have already searched in this file\n\t\tfor (i = 0;; i++)\n\t\t{\n\t\t    if (i == depth + 1)\n\t\t\ti = old_files;\n\t\t    if (i == max_path_depth)\n\t\t\tbreak;\n\t\t    if (fullpathcmp(new_fname, files[i].name, TRUE, TRUE)\n\t\t\t\t\t\t\t\t    & FPC_SAME)\n\t\t    {\n\t\t\tif (type != CHECK_PATH\n\t\t\t\t&& action == ACTION_SHOW_ALL\n\t\t\t\t&& files[i].matched)\n\t\t\t{\n\t\t\t    msg_putchar('\\n');\t    // cursor below last one\n\t\t\t    if (!got_int)\t    // don't display if 'q'\n\t\t\t\t\t\t    // typed at \"--more--\"\n\t\t\t\t\t\t    // message\n\t\t\t    {\n\t\t\t\tmsg_home_replace_hl(new_fname);\n\t\t\t\tmsg_puts(_(\" (includes previously listed match)\"));\n\t\t\t\tprev_fname = NULL;\n\t\t\t    }\n\t\t\t}\n\t\t\tVIM_CLEAR(new_fname);\n\t\t\talready_searched = TRUE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\n\t    if (type == CHECK_PATH && (action == ACTION_SHOW_ALL\n\t\t\t\t || (new_fname == NULL && !already_searched)))\n\t    {\n\t\tif (did_show)\n\t\t    msg_putchar('\\n');\t    // cursor below last one\n\t\telse\n\t\t{\n\t\t    gotocmdline(TRUE);\t    // cursor at status line\n\t\t    msg_puts_title(_(\"--- Included files \"));\n\t\t    if (action != ACTION_SHOW_ALL)\n\t\t\tmsg_puts_title(_(\"not found \"));\n\t\t    msg_puts_title(_(\"in path ---\\n\"));\n\t\t}\n\t\tdid_show = TRUE;\n\t\twhile (depth_displayed < depth && !got_int)\n\t\t{\n\t\t    ++depth_displayed;\n\t\t    for (i = 0; i < depth_displayed; i++)\n\t\t\tmsg_puts(\"  \");\n\t\t    msg_home_replace(files[depth_displayed].name);\n\t\t    msg_puts(\" -->\\n\");\n\t\t}\n\t\tif (!got_int)\t\t    // don't display if 'q' typed\n\t\t\t\t\t    // for \"--more--\" message\n\t\t{\n\t\t    for (i = 0; i <= depth_displayed; i++)\n\t\t\tmsg_puts(\"  \");\n\t\t    if (new_fname != NULL)\n\t\t    {\n\t\t\t// using \"new_fname\" is more reliable, e.g., when\n\t\t\t// 'includeexpr' is set.\n\t\t\tmsg_outtrans_attr(new_fname, HL_ATTR(HLF_D));\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t/*\n\t\t\t * Isolate the file name.\n\t\t\t * Include the surrounding \"\" or <> if present.\n\t\t\t */\n\t\t\tif (inc_opt != NULL\n\t\t\t\t   && strstr((char *)inc_opt, \"\\\\zs\") != NULL)\n\t\t\t{\n\t\t\t    // pattern contains \\zs, use the match\n\t\t\t    p = incl_regmatch.startp[0];\n\t\t\t    i = (int)(incl_regmatch.endp[0]\n\t\t\t\t\t\t   - incl_regmatch.startp[0]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // find the file name after the end of the match\n\t\t\t    for (p = incl_regmatch.endp[0];\n\t\t\t\t\t\t  *p && !vim_isfilec(*p); p++)\n\t\t\t\t;\n\t\t\t    for (i = 0; vim_isfilec(p[i]); i++)\n\t\t\t\t;\n\t\t\t}\n\n\t\t\tif (i == 0)\n\t\t\t{\n\t\t\t    // Nothing found, use the rest of the line.\n\t\t\t    p = incl_regmatch.endp[0];\n\t\t\t    i = (int)STRLEN(p);\n\t\t\t}\n\t\t\t// Avoid checking before the start of the line, can\n\t\t\t// happen if \\zs appears in the regexp.\n\t\t\telse if (p > line)\n\t\t\t{\n\t\t\t    if (p[-1] == '\"' || p[-1] == '<')\n\t\t\t    {\n\t\t\t\t--p;\n\t\t\t\t++i;\n\t\t\t    }\n\t\t\t    if (p[i] == '\"' || p[i] == '>')\n\t\t\t\t++i;\n\t\t\t}\n\t\t\tsave_char = p[i];\n\t\t\tp[i] = NUL;\n\t\t\tmsg_outtrans_attr(p, HL_ATTR(HLF_D));\n\t\t\tp[i] = save_char;\n\t\t    }\n\n\t\t    if (new_fname == NULL && action == ACTION_SHOW_ALL)\n\t\t    {\n\t\t\tif (already_searched)\n\t\t\t    msg_puts(_(\"  (Already listed)\"));\n\t\t\telse\n\t\t\t    msg_puts(_(\"  NOT FOUND\"));\n\t\t    }\n\t\t}\n\t\tout_flush();\t    // output each line directly\n\t    }\n\n\t    if (new_fname != NULL)\n\t    {\n\t\t// Push the new file onto the file stack\n\t\tif (depth + 1 == old_files)\n\t\t{\n\t\t    bigger = ALLOC_MULT(SearchedFile, max_path_depth * 2);\n\t\t    if (bigger != NULL)\n\t\t    {\n\t\t\tfor (i = 0; i <= depth; i++)\n\t\t\t    bigger[i] = files[i];\n\t\t\tfor (i = depth + 1; i < old_files + max_path_depth; i++)\n\t\t\t{\n\t\t\t    bigger[i].fp = NULL;\n\t\t\t    bigger[i].name = NULL;\n\t\t\t    bigger[i].lnum = 0;\n\t\t\t    bigger[i].matched = FALSE;\n\t\t\t}\n\t\t\tfor (i = old_files; i < max_path_depth; i++)\n\t\t\t    bigger[i + max_path_depth] = files[i];\n\t\t\told_files += max_path_depth;\n\t\t\tmax_path_depth *= 2;\n\t\t\tvim_free(files);\n\t\t\tfiles = bigger;\n\t\t    }\n\t\t}\n\t\tif ((files[depth + 1].fp = mch_fopen((char *)new_fname, \"r\"))\n\t\t\t\t\t\t\t\t    == NULL)\n\t\t    vim_free(new_fname);\n\t\telse\n\t\t{\n\t\t    if (++depth == old_files)\n\t\t    {\n\t\t\t/*\n\t\t\t * lalloc() for 'bigger' must have failed above.  We\n\t\t\t * will forget one of our already visited files now.\n\t\t\t */\n\t\t\tvim_free(files[old_files].name);\n\t\t\t++old_files;\n\t\t    }\n\t\t    files[depth].name = curr_fname = new_fname;\n\t\t    files[depth].lnum = 0;\n\t\t    files[depth].matched = FALSE;\n\t\t    if (action == ACTION_EXPAND)\n\t\t    {\n\t\t\tmsg_hist_off = TRUE;\t// reset in msg_trunc_attr()\n\t\t\tvim_snprintf((char*)IObuff, IOSIZE,\n\t\t\t\t_(\"Scanning included file: %s\"),\n\t\t\t\t(char *)new_fname);\n\t\t\tmsg_trunc_attr((char *)IObuff, TRUE, HL_ATTR(HLF_R));\n\t\t    }\n\t\t    else if (p_verbose >= 5)\n\t\t    {\n\t\t\tverbose_enter();\n\t\t\tsmsg(_(\"Searching included file %s\"),\n\t\t\t\t\t\t\t   (char *)new_fname);\n\t\t\tverbose_leave();\n\t\t    }\n\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    /*\n\t     * Check if the line is a define (type == FIND_DEFINE)\n\t     */\n\t    p = line;\nsearch_line:\n\t    define_matched = FALSE;\n\t    if (def_regmatch.regprog != NULL\n\t\t\t      && vim_regexec(&def_regmatch, line, (colnr_T)0))\n\t    {\n\t\t/*\n\t\t * Pattern must be first identifier after 'define', so skip\n\t\t * to that position before checking for match of pattern.  Also\n\t\t * don't let it match beyond the end of this identifier.\n\t\t */\n\t\tp = def_regmatch.endp[0];\n\t\twhile (*p && !vim_iswordc(*p))\n\t\t    p++;\n\t\tdefine_matched = TRUE;\n\t    }\n\n\t    /*\n\t     * Look for a match.  Don't do this if we are looking for a\n\t     * define and this line didn't match define_prog above.\n\t     */\n\t    if (def_regmatch.regprog == NULL || define_matched)\n\t    {\n\t\tif (define_matched || compl_status_sol())\n\t\t{\n\t\t    // compare the first \"len\" chars from \"ptr\"\n\t\t    startp = skipwhite(p);\n\t\t    if (p_ic)\n\t\t\tmatched = !MB_STRNICMP(startp, ptr, len);\n\t\t    else\n\t\t\tmatched = !STRNCMP(startp, ptr, len);\n\t\t    if (matched && define_matched && whole\n\t\t\t\t\t\t  && vim_iswordc(startp[len]))\n\t\t\tmatched = FALSE;\n\t\t}\n\t\telse if (regmatch.regprog != NULL\n\t\t\t && vim_regexec(&regmatch, line, (colnr_T)(p - line)))\n\t\t{\n\t\t    matched = TRUE;\n\t\t    startp = regmatch.startp[0];\n\t\t    /*\n\t\t     * Check if the line is not a comment line (unless we are\n\t\t     * looking for a define).  A line starting with \"# define\"\n\t\t     * is not considered to be a comment line.\n\t\t     */\n\t\t    if (!define_matched && skip_comments)\n\t\t    {\n\t\t\tif ((*line != '#' ||\n\t\t\t\tSTRNCMP(skipwhite(line + 1), \"define\", 6) != 0)\n\t\t\t\t&& get_leader_len(line, NULL, FALSE, TRUE))\n\t\t\t    matched = FALSE;\n\n\t\t\t/*\n\t\t\t * Also check for a \"/ *\" or \"/ /\" before the match.\n\t\t\t * Skips lines like \"int backwards;  / * normal index\n\t\t\t * * /\" when looking for \"normal\".\n\t\t\t * Note: Doesn't skip \"/ *\" in comments.\n\t\t\t */\n\t\t\tp = skipwhite(line);\n\t\t\tif (matched\n\t\t\t\t|| (p[0] == '/' && p[1] == '*') || p[0] == '*')\n\t\t\t    for (p = line; *p && p < startp; ++p)\n\t\t\t    {\n\t\t\t\tif (matched\n\t\t\t\t\t&& p[0] == '/'\n\t\t\t\t\t&& (p[1] == '*' || p[1] == '/'))\n\t\t\t\t{\n\t\t\t\t    matched = FALSE;\n\t\t\t\t    // After \"//\" all text is comment\n\t\t\t\t    if (p[1] == '/')\n\t\t\t\t\tbreak;\n\t\t\t\t    ++p;\n\t\t\t\t}\n\t\t\t\telse if (!matched && p[0] == '*' && p[1] == '/')\n\t\t\t\t{\n\t\t\t\t    // Can find match after \"* /\".\n\t\t\t\t    matched = TRUE;\n\t\t\t\t    ++p;\n\t\t\t\t}\n\t\t\t    }\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif (matched)\n\t{\n\t    if (action == ACTION_EXPAND)\n\t    {\n\t\tint\tcont_s_ipos = FALSE;\n\t\tint\tadd_r;\n\t\tchar_u\t*aux;\n\n\t\tif (depth == -1 && lnum == curwin->w_cursor.lnum)\n\t\t    break;\n\t\tfound = TRUE;\n\t\taux = p = startp;\n\t\tif (compl_status_adding())\n\t\t{\n\t\t    p += ins_compl_len();\n\t\t    if (vim_iswordp(p))\n\t\t\tgoto exit_matched;\n\t\t    p = find_word_start(p);\n\t\t}\n\t\tp = find_word_end(p);\n\t\ti = (int)(p - aux);\n\n\t\tif (compl_status_adding() && i == ins_compl_len())\n\t\t{\n\t\t    // IOSIZE > compl_length, so the STRNCPY works\n\t\t    STRNCPY(IObuff, aux, i);\n\n\t\t    // Get the next line: when \"depth\" < 0  from the current\n\t\t    // buffer, otherwise from the included file.  Jump to\n\t\t    // exit_matched when past the last line.\n\t\t    if (depth < 0)\n\t\t    {\n\t\t\tif (lnum >= end_lnum)\n\t\t\t    goto exit_matched;\n\t\t\tline = get_line_and_copy(++lnum, file_line);\n\t\t    }\n\t\t    else if (vim_fgets(line = file_line,\n\t\t\t\t\t\t      LSIZE, files[depth].fp))\n\t\t\tgoto exit_matched;\n\n\t\t    // we read a line, set \"already\" to check this \"line\" later\n\t\t    // if depth >= 0 we'll increase files[depth].lnum far\n\t\t    // below  -- Acevedo\n\t\t    already = aux = p = skipwhite(line);\n\t\t    p = find_word_start(p);\n\t\t    p = find_word_end(p);\n\t\t    if (p > aux)\n\t\t    {\n\t\t\tif (*aux != ')' && IObuff[i-1] != TAB)\n\t\t\t{\n\t\t\t    if (IObuff[i-1] != ' ')\n\t\t\t\tIObuff[i++] = ' ';\n\t\t\t    // IObuf =~ \"\\(\\k\\|\\i\\).* \", thus i >= 2\n\t\t\t    if (p_js\n\t\t\t\t&& (IObuff[i-2] == '.'\n\t\t\t\t    || (vim_strchr(p_cpo, CPO_JOINSP) == NULL\n\t\t\t\t\t&& (IObuff[i-2] == '?'\n\t\t\t\t\t    || IObuff[i-2] == '!'))))\n\t\t\t\tIObuff[i++] = ' ';\n\t\t\t}\n\t\t\t// copy as much as possible of the new word\n\t\t\tif (p - aux >= IOSIZE - i)\n\t\t\t    p = aux + IOSIZE - i - 1;\n\t\t\tSTRNCPY(IObuff + i, aux, p - aux);\n\t\t\ti += (int)(p - aux);\n\t\t\tcont_s_ipos = TRUE;\n\t\t    }\n\t\t    IObuff[i] = NUL;\n\t\t    aux = IObuff;\n\n\t\t    if (i == ins_compl_len())\n\t\t\tgoto exit_matched;\n\t\t}\n\n\t\tadd_r = ins_compl_add_infercase(aux, i, p_ic,\n\t\t\tcurr_fname == curbuf->b_fname ? NULL : curr_fname,\n\t\t\tdir, cont_s_ipos);\n\t\tif (add_r == OK)\n\t\t    // if dir was BACKWARD then honor it just once\n\t\t    dir = FORWARD;\n\t\telse if (add_r == FAIL)\n\t\t    break;\n\t    }\n\t    else if (action == ACTION_SHOW_ALL)\n\t    {\n\t\tfound = TRUE;\n\t\tif (!did_show)\n\t\t    gotocmdline(TRUE);\t\t// cursor at status line\n\t\tif (curr_fname != prev_fname)\n\t\t{\n\t\t    if (did_show)\n\t\t\tmsg_putchar('\\n');\t// cursor below last one\n\t\t    if (!got_int)\t\t// don't display if 'q' typed\n\t\t\t\t\t\t// at \"--more--\" message\n\t\t\tmsg_home_replace_hl(curr_fname);\n\t\t    prev_fname = curr_fname;\n\t\t}\n\t\tdid_show = TRUE;\n\t\tif (!got_int)\n\t\t    show_pat_in_path(line, type, TRUE, action,\n\t\t\t    (depth == -1) ? NULL : files[depth].fp,\n\t\t\t    (depth == -1) ? &lnum : &files[depth].lnum,\n\t\t\t    match_count++);\n\n\t\t// Set matched flag for this file and all the ones that\n\t\t// include it\n\t\tfor (i = 0; i <= depth; ++i)\n\t\t    files[i].matched = TRUE;\n\t    }\n\t    else if (--count <= 0)\n\t    {\n\t\tfound = TRUE;\n\t\tif (depth == -1 && lnum == curwin->w_cursor.lnum\n#if defined(FEAT_QUICKFIX)\n\t\t\t\t\t\t      && g_do_tagpreview == 0\n#endif\n\t\t\t\t\t\t      )\n\t\t    emsg(_(e_match_is_on_current_line));\n\t\telse if (action == ACTION_SHOW)\n\t\t{\n\t\t    show_pat_in_path(line, type, did_show, action,\n\t\t\t(depth == -1) ? NULL : files[depth].fp,\n\t\t\t(depth == -1) ? &lnum : &files[depth].lnum, 1L);\n\t\t    did_show = TRUE;\n\t\t}\n\t\telse\n\t\t{\n#ifdef FEAT_GUI\n\t\t    need_mouse_correct = TRUE;\n#endif\n#if defined(FEAT_QUICKFIX)\n\t\t    // \":psearch\" uses the preview window\n\t\t    if (g_do_tagpreview != 0)\n\t\t    {\n\t\t\tcurwin_save = curwin;\n\t\t\tprepare_tagpreview(TRUE, TRUE, FALSE);\n\t\t    }\n#endif\n\t\t    if (action == ACTION_SPLIT)\n\t\t    {\n\t\t\tif (win_split(0, 0) == FAIL)\n\t\t\t    break;\n\t\t\tRESET_BINDING(curwin);\n\t\t    }\n\t\t    if (depth == -1)\n\t\t    {\n\t\t\t// match in current file\n#if defined(FEAT_QUICKFIX)\n\t\t\tif (g_do_tagpreview != 0)\n\t\t\t{\n\t\t\t    if (!win_valid(curwin_save))\n\t\t\t\tbreak;\n\t\t\t    if (!GETFILE_SUCCESS(getfile(\n\t\t\t\t\t   curwin_save->w_buffer->b_fnum, NULL,\n\t\t\t\t\t\t     NULL, TRUE, lnum, FALSE)))\n\t\t\t\tbreak;\t// failed to jump to file\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t    setpcmark();\n\t\t\tcurwin->w_cursor.lnum = lnum;\n\t\t\tcheck_cursor();\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (!GETFILE_SUCCESS(getfile(\n\t\t\t\t\t0, files[depth].name, NULL, TRUE,\n\t\t\t\t\t\t    files[depth].lnum, FALSE)))\n\t\t\t    break;\t// failed to jump to file\n\t\t\t// autocommands may have changed the lnum, we don't\n\t\t\t// want that here\n\t\t\tcurwin->w_cursor.lnum = files[depth].lnum;\n\t\t    }\n\t\t}\n\t\tif (action != ACTION_SHOW)\n\t\t{\n\t\t    curwin->w_cursor.col = (colnr_T)(startp - line);\n\t\t    curwin->w_set_curswant = TRUE;\n\t\t}\n\n#if defined(FEAT_QUICKFIX)\n\t\tif (g_do_tagpreview != 0\n\t\t\t   && curwin != curwin_save && win_valid(curwin_save))\n\t\t{\n\t\t    // Return cursor to where we were\n\t\t    validate_cursor();\n\t\t    redraw_later(VALID);\n\t\t    win_enter(curwin_save, TRUE);\n\t\t}\n# ifdef FEAT_PROP_POPUP\n\t\telse if (WIN_IS_POPUP(curwin))\n\t\t    // can't keep focus in popup window\n\t\t    win_enter(firstwin, TRUE);\n# endif\n#endif\n\t\tbreak;\n\t    }\nexit_matched:\n\t    matched = FALSE;\n\t    // look for other matches in the rest of the line if we\n\t    // are not at the end of it already\n\t    if (def_regmatch.regprog == NULL\n\t\t    && action == ACTION_EXPAND\n\t\t    && !compl_status_sol()\n\t\t    && *startp != NUL\n\t\t    && *(p = startp + mb_ptr2len(startp)) != NUL)\n\t\tgoto search_line;\n\t}\n\tline_breakcheck();\n\tif (action == ACTION_EXPAND)\n\t    ins_compl_check_keys(30, FALSE);\n\tif (got_int || ins_compl_interrupted())\n\t    break;\n\n\t/*\n\t * Read the next line.  When reading an included file and encountering\n\t * end-of-file, close the file and continue in the file that included\n\t * it.\n\t */\n\twhile (depth >= 0 && !already\n\t\t&& vim_fgets(line = file_line, LSIZE, files[depth].fp))\n\t{\n\t    fclose(files[depth].fp);\n\t    --old_files;\n\t    files[old_files].name = files[depth].name;\n\t    files[old_files].matched = files[depth].matched;\n\t    --depth;\n\t    curr_fname = (depth == -1) ? curbuf->b_fname\n\t\t\t\t       : files[depth].name;\n\t    if (depth < depth_displayed)\n\t\tdepth_displayed = depth;\n\t}\n\tif (depth >= 0)\t\t// we could read the line\n\t{\n\t    files[depth].lnum++;\n\t    // Remove any CR and LF from the line.\n\t    i = (int)STRLEN(line);\n\t    if (i > 0 && line[i - 1] == '\\n')\n\t\tline[--i] = NUL;\n\t    if (i > 0 && line[i - 1] == '\\r')\n\t\tline[--i] = NUL;\n\t}\n\telse if (!already)\n\t{\n\t    if (++lnum > end_lnum)\n\t\tbreak;\n\t    line = get_line_and_copy(lnum, file_line);\n\t}\n\talready = NULL;\n    }\n    // End of big for (;;) loop.\n\n    // Close any files that are still open.\n    for (i = 0; i <= depth; i++)\n    {\n\tfclose(files[i].fp);\n\tvim_free(files[i].name);\n    }\n    for (i = old_files; i < max_path_depth; i++)\n\tvim_free(files[i].name);\n    vim_free(files);\n\n    if (type == CHECK_PATH)\n    {\n\tif (!did_show)\n\t{\n\t    if (action != ACTION_SHOW_ALL)\n\t\tmsg(_(\"All included files were found\"));\n\t    else\n\t\tmsg(_(\"No included files\"));\n\t}\n    }\n    else if (!found && action != ACTION_EXPAND)\n    {\n\tif (got_int || ins_compl_interrupted())\n\t    emsg(_(e_interrupted));\n\telse if (type == FIND_DEFINE)\n\t    emsg(_(e_couldnt_find_definition));\n\telse\n\t    emsg(_(e_couldnt_find_pattern));\n    }\n    if (action == ACTION_SHOW || action == ACTION_SHOW_ALL)\n\tmsg_end();\n\nfpip_end:\n    vim_free(file_line);\n    vim_regfree(regmatch.regprog);\n    vim_regfree(incl_regmatch.regprog);\n    vim_regfree(def_regmatch.regprog);\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"vim.h\"\n\n// Type Definitions:\n// win_T:\ntypedef struct window_S\t\twin_T;\n\n// linenr_T:\ntypedef long\tlinenr_T;\n\n// linenr_T:\ntypedef long\t\tlinenr_T;\n\n// regmatch_T:\ntypedef struct\n{\n    regprog_T\t\t*regprog;\n    char_u\t\t*startp[NSUBEXP];\n    char_u\t\t*endp[NSUBEXP];\n    int\t\t\trm_ic;\n}\n\n// SearchedFile:\ntypedef struct SearchedFile\n{\n    FILE\t*fp;\t\t// File pointer\n    char_u\t*name;\t\t// Full name of file\n    linenr_T\tlnum;\t\t// Line we were up to in file\n    int\t\tmatched;\t// Found a match in this file\n}\n\n// SearchedFile:\ntypedef struct SearchedFile\n{\n    FILE\t*fp;\t\t// File pointer\n    char_u\t*name;\t\t// Full name of file\n    linenr_T\tlnum;\t\t// Line we were up to in file\n    int\t\tmatched;\t// Found a match in this file\n} SearchedFile;\n\n// char_u:\ntypedef unsigned char\tchar_u;\n\n// Called Methods (top 10):\n// COM_MAX_LEN from src/option.h:\n#define COM_MAX_LEN\t50\t\t// maximum length of a part /* <=== src/option.h:313:313:COM_MAX_LEN:0 */ \n\n// set_file_options from src/fileio.c:\n    void /* <=== set_file_options */ \nset_file_options(int set_options, exarg_T *eap)\n{\n    // set default 'fileformat'\n    if (set_options)\n    {\n\tif (eap != NULL && eap->force_ff != 0)\n\t    set_fileformat(get_fileformat_force(curbuf, eap), OPT_LOCAL);\n\telse if (*p_ffs != NUL)\n\t    set_fileformat(default_fileformat(), OPT_LOCAL);\n    }\n\n    // set or reset 'binary'\n    if (eap != NULL && eap->force_bin != 0)\n    {\n\tint\toldval = curbuf->b_p_bin;\n\n\tcurbuf->b_p_bin = (eap->force_bin == FORCE_BIN);\n\tset_options_bin(oldval, curbuf->b_p_bin, OPT_LOCAL);\n    }\n}\n\n// report_re_switch from src/regexp.c:\n    static void /* <=== report_re_switch */ \nreport_re_switch(char_u *pat)\n{\n    if (p_verbose > 0)\n    {\n\tverbose_enter();\n\tmsg_puts(_(\"Switching to backtracking RE engine for pattern: \"));\n\tmsg_puts((char *)pat);\n\tverbose_leave();\n    }\n}\n\n// PLAN_NL from src/screen.c:\n#define PLAN_NL\t    3 /* <=== src/screen.c:3121:3121:PLAN_NL:0 */ \n\n// vim_fgets from src/fileio.c:\n    int /* <=== vim_fgets */ \nvim_fgets(char_u *buf, int size, FILE *fp)\n{\n    char\t*eof;\n#define FGETS_SIZE 200\n    char\ttbuf[FGETS_SIZE];\n\n    buf[size - 2] = NUL;\n    eof = fgets((char *)buf, size, fp);\n    if (buf[size - 2] != NUL && buf[size - 2] != '\\n')\n    {\n\tbuf[size - 1] = NUL;\t    // Truncate the line\n\n\t// Now throw away the rest of the line:\n\tdo\n\t{\n\t    tbuf[FGETS_SIZE - 2] = NUL;\n\t    vim_ignoredp = fgets((char *)tbuf, FGETS_SIZE, fp);\n\t} while (tbuf[FGETS_SIZE - 2] != NUL && tbuf[FGETS_SIZE - 2] != '\\n');\n    }\n    return (eof == NULL);\n}\n\n// win_new_height from src/window.c:\n    void /* <=== win_new_height */ \nwin_new_height(win_T *wp, int height)\n{\n    int\t\tprev_height = wp->w_height;\n\n    // Don't want a negative height.  Happens when splitting a tiny window.\n    // Will equalize heights soon to fix it.\n    if (height < 0)\n\theight = 0;\n    if (wp->w_height == height)\n\treturn;\t    // nothing to do\n\n    if (wp->w_height > 0)\n    {\n\tif (wp == curwin)\n\t    // w_wrow needs to be valid. When setting 'laststatus' this may\n\t    // call win_new_height() recursively.\n\t    validate_cursor();\n\tif (wp->w_height != prev_height)\n\t    return;  // Recursive call already changed the size, bail out here\n\t\t     //\tto avoid the following to mess things up.\n\tif (wp->w_wrow != wp->w_prev_fraction_row)\n\t    set_fraction(wp);\n    }\n\n    wp->w_height = height;\n    wp->w_skipcol = 0;\n\n    // There is no point in adjusting the scroll position when exiting.  Some\n    // values might be invalid.\n    if (!exiting)\n\tscroll_to_fraction(wp, prev_height);\n}\n\n// MB_STRICMP from src/vim.h:\n# define MB_STRICMP(d, s)\tmb_strnicmp((char_u *)(d), (char_u *)(s), (int)MAXCOL) /* <=== src/vim.h:1681:1681:MB_STRICMP:2 */ \n\n// K_MIDDLEMOUSE from src/keymap.h:\n#define K_MIDDLEMOUSE\tTERMCAP2KEY(KS_EXTRA, KE_MIDDLEMOUSE) /* <=== src/keymap.h:450:450:K_MIDDLEMOUSE:0 */ \n\n// skipdigits from src/charset.c:\n    char_u * /* <=== skipdigits */ \nskipdigits(char_u *q)\n{\n    char_u\t*p = q;\n\n    while (VIM_ISDIGIT(*p))\t// skip to next non-digit\n\t++p;\n    return p;\n}\n\n// msg_trunc_attr from src/message.c:\n    char * /* <=== msg_trunc_attr */ \nmsg_trunc_attr(char *s, int force, int attr)\n{\n    int\t\tn;\n    char\t*ts;\n\n    // Add message to history before truncating\n    add_msg_hist((char_u *)s, -1, attr);\n\n    ts = (char *)msg_may_trunc(force, (char_u *)s);\n\n    msg_hist_off = TRUE;\n    n = msg_attr(ts, attr);\n    msg_hist_off = FALSE;\n\n    if (n)\n\treturn ts;\n    return NULL;\n}\n"
  },
  {
    "repository": "mruby",
    "cve_id": "CVE-2022-0717",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "f72315575f78a9a773adbce0ee7d3ec33434cb76",
    "short_hash": "f7231557",
    "vulnerableMethods_before": [
      {
        "filename": "codegen.c",
        "method_name": "vulnerable_function",
        "raw_code": "gen_assignment(codegen_scope *s, node *tree, node *rhs, int sp, int val)\n{\n  int idx;\n  int type = nint(tree->car);\n\n  switch (type) {\n  case NODE_GVAR:\n  case NODE_ARG:\n  case NODE_LVAR:\n  case NODE_IVAR:\n  case NODE_CVAR:\n  case NODE_CONST:\n  case NODE_NIL:\n  case NODE_MASGN:\n    if (rhs) {\n      codegen(s, rhs, VAL);\n      pop();\n      sp = cursp();\n    }\n    break;\n\n  case NODE_COLON2:\n  case NODE_CALL:\n  case NODE_SCALL:\n    /* keep evaluation order */\n    break;\n\n  case NODE_NVAR:\n    codegen_error(s, \"Can't assign to numbered parameter\");\n    break;\n\n  default:\n    codegen_error(s, \"unknown lhs\");\n    break;\n  }\n\n  tree = tree->cdr;\n  switch (type) {\n  case NODE_GVAR:\n    gen_setxv(s, OP_SETGV, sp, nsym(tree), val);\n    break;\n  case NODE_ARG:\n  case NODE_LVAR:\n    idx = lv_idx(s, nsym(tree));\n    if (idx > 0) {\n      if (idx != sp) {\n        gen_move(s, idx, sp, val);\n      }\n      break;\n    }\n    else {                      /* upvar */\n      gen_setupvar(s, sp, nsym(tree));\n    }\n    break;\n  case NODE_IVAR:\n    gen_setxv(s, OP_SETIV, sp, nsym(tree), val);\n    break;\n  case NODE_CVAR:\n    gen_setxv(s, OP_SETCV, sp, nsym(tree), val);\n    break;\n  case NODE_CONST:\n    gen_setxv(s, OP_SETCONST, sp, nsym(tree), val);\n    break;\n  case NODE_COLON2:\n    if (sp) {\n      gen_move(s, cursp(), sp, 0);\n    }\n    sp = cursp();\n    push();\n    codegen(s, tree->car, VAL);\n    if (rhs) {\n      codegen(s, rhs, VAL); pop();\n      gen_move(s, sp, cursp(), 0);\n    }\n    pop_n(2);\n    idx = new_sym(s, nsym(tree->cdr));\n    genop_2(s, OP_SETMCNST, sp, idx);\n    break;\n\n  case NODE_CALL:\n  case NODE_SCALL:\n    {\n      int noself = 0, safe = (type == NODE_SCALL), skip = 0, top, call, n = 0;\n      mrb_sym mid = nsym(tree->cdr->car);\n\n      top = cursp();\n      if (val || sp == cursp()) {\n        push();                   /* room for retval */\n      }\n      call = cursp();\n      if (!tree->car) {\n        noself = 1;\n        push();\n      }\n      else {\n        codegen(s, tree->car, VAL); /* receiver */\n      }\n      if (safe) {\n        int recv = cursp()-1;\n        gen_move(s, cursp(), recv, 1);\n        skip = genjmp2_0(s, OP_JMPNIL, cursp(), val);\n      }\n      tree = tree->cdr->cdr->car;\n      if (tree) {\n        if (tree->car) {            /* positional arguments */\n          n = gen_values(s, tree->car, VAL, (tree->cdr->car)?13:14);\n          if (n < 0) {              /* variable length */\n            n = 15;\n            push();\n          }\n        }\n        if (tree->cdr->car) {       /* keyword arguments */\n          if (n == 14) {\n            pop_n(n);\n            genop_2(s, OP_ARRAY, cursp(), n);\n            push();\n            n = 15;\n          }\n          gen_hash(s, tree->cdr->car->cdr, VAL, 0);\n          if (n < 14) {\n            n++;\n          }\n          else {\n            pop_n(2);\n            genop_2(s, OP_ARYPUSH, cursp(), 1);\n          }\n          push();\n        }\n      }\n      if (rhs) {\n        codegen(s, rhs, VAL);\n        pop();\n      }\n      else {\n        gen_move(s, cursp(), sp, 0);\n      }\n      if (val) {\n        gen_move(s, top, cursp(), 1);\n      }\n      if (n < 14) {\n        n++;\n      }\n      else {\n        pop();\n        genop_2(s, OP_ARYPUSH, cursp(), 1);\n      }\n      s->sp = call;\n      if (mid == MRB_OPSYM_2(s->mrb, aref) && n == 2) {\n        genop_1(s, OP_SETIDX, cursp());\n      }\n      else {\n        genop_3(s, noself ? OP_SSEND : OP_SEND, cursp(), new_sym(s, attrsym(s, mid)), n);\n      }\n      if (safe) {\n        dispatch(s, skip);\n      }\n      s->sp = top;\n    }\n    break;\n\n  case NODE_MASGN:\n    gen_vmassignment(s, tree->car, sp, val);\n    break;\n\n  /* splat without assignment */\n  case NODE_NIL:\n    break;\n\n  default:\n    codegen_error(s, \"unknown lhs\");\n    break;\n  }\n  if (val) push();\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "None",
        "method_name": "fixed_function",
        "raw_code": "gen_assignment(codegen_scope *s, node *tree, node *rhs, int sp, int val)\n{\n  int idx;\n  int type = nint(tree->car);\n\n  switch (type) {\n  case NODE_GVAR:\n  case NODE_ARG:\n  case NODE_LVAR:\n  case NODE_IVAR:\n  case NODE_CVAR:\n  case NODE_CONST:\n  case NODE_NIL:\n  case NODE_MASGN:\n    if (rhs) {\n      codegen(s, rhs, VAL);\n      pop();\n      sp = cursp();\n    }\n    break;\n\n  case NODE_COLON2:\n  case NODE_CALL:\n  case NODE_SCALL:\n    /* keep evaluation order */\n    break;\n\n  case NODE_NVAR:\n    codegen_error(s, \"Can't assign to numbered parameter\");\n    break;\n\n  default:\n    codegen_error(s, \"unknown lhs\");\n    break;\n  }\n\n  tree = tree->cdr;\n  switch (type) {\n  case NODE_GVAR:\n    gen_setxv(s, OP_SETGV, sp, nsym(tree), val);\n    break;\n  case NODE_ARG:\n  case NODE_LVAR:\n    idx = lv_idx(s, nsym(tree));\n    if (idx > 0) {\n      if (idx != sp) {\n        gen_move(s, idx, sp, val);\n      }\n      break;\n    }\n    else {                      /* upvar */\n      gen_setupvar(s, sp, nsym(tree));\n    }\n    break;\n  case NODE_IVAR:\n    gen_setxv(s, OP_SETIV, sp, nsym(tree), val);\n    break;\n  case NODE_CVAR:\n    gen_setxv(s, OP_SETCV, sp, nsym(tree), val);\n    break;\n  case NODE_CONST:\n    gen_setxv(s, OP_SETCONST, sp, nsym(tree), val);\n    break;\n  case NODE_COLON2:\n    if (sp) {\n      gen_move(s, cursp(), sp, 0);\n    }\n    sp = cursp();\n    push();\n    codegen(s, tree->car, VAL);\n    if (rhs) {\n      codegen(s, rhs, VAL); pop();\n      gen_move(s, sp, cursp(), 0);\n    }\n    pop_n(2);\n    idx = new_sym(s, nsym(tree->cdr));\n    genop_2(s, OP_SETMCNST, sp, idx);\n    break;\n\n  case NODE_CALL:\n  case NODE_SCALL:\n    {\n      int noself = 0, safe = (type == NODE_SCALL), skip = 0, top, call, n = 0;\n      mrb_sym mid = nsym(tree->cdr->car);\n\n      top = cursp();\n      if (val || sp == cursp()) {\n        push();                   /* room for retval */\n      }\n      call = cursp();\n      if (!tree->car) {\n        noself = 1;\n        push();\n      }\n      else {\n        codegen(s, tree->car, VAL); /* receiver */\n      }\n      if (safe) {\n        int recv = cursp()-1;\n        gen_move(s, cursp(), recv, 1);\n        skip = genjmp2_0(s, OP_JMPNIL, cursp(), val);\n      }\n      tree = tree->cdr->cdr->car;\n      if (tree) {\n        if (tree->car) {            /* positional arguments */\n          n = gen_values(s, tree->car, VAL, (tree->cdr->car)?13:14);\n          if (n < 0) {              /* variable length */\n            n = 15;\n            push();\n          }\n        }\n        if (tree->cdr->car) {       /* keyword arguments */\n          if (n == 14) {\n            pop_n(n);\n            genop_2(s, OP_ARRAY, cursp(), n);\n            push();\n            n = 15;\n          }\n          gen_hash(s, tree->cdr->car->cdr, VAL, 0);\n          if (n < 14) {\n            n++;\n          }\n          else {\n            pop_n(2);\n            genop_2(s, OP_ARYPUSH, cursp(), 1);\n          }\n          push();\n        }\n      }\n      if (rhs) {\n        codegen(s, rhs, VAL);\n        pop();\n      }\n      else {\n        gen_move(s, cursp(), sp, 0);\n      }\n      if (val) {\n        gen_move(s, top, cursp(), 1);\n      }\n      if (n < 15) {\n        n++;\n        if (n == 15) {\n          pop_n(14);\n          genop_2(s, OP_ARRAY, cursp(), 15);\n        }\n      }\n      else {\n        pop();\n        genop_2(s, OP_ARYPUSH, cursp(), 1);\n      }\n      s->sp = call;\n      if (mid == MRB_OPSYM_2(s->mrb, aref) && n == 2) {\n        genop_1(s, OP_SETIDX, cursp());\n      }\n      else {\n        genop_3(s, noself ? OP_SSEND : OP_SEND, cursp(), new_sym(s, attrsym(s, mid)), n);\n      }\n      if (safe) {\n        dispatch(s, skip);\n      }\n      s->sp = top;\n    }\n    break;\n\n  case NODE_MASGN:\n    gen_vmassignment(s, tree->car, sp, val);\n    break;\n\n  /* splat without assignment */\n  case NODE_NIL:\n    break;\n\n  default:\n    codegen_error(s, \"unknown lhs\");\n    break;\n  }\n  if (val) push();\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"mruby/ops.h\"\n#include <mruby/string.h>\n#include <string.h>\n#include <mruby/throw.h>\n#include <mruby/debug.h>\n#include \"node.h\"\n#include <ctype.h>\n#include <mruby/compile.h>\n#include <mruby/numeric.h>\n#include <mruby/proc.h>\n#include <mruby/presym.h>\n#include <mruby/opcode.h>\n#include <mruby.h>\n#include <mruby/re.h>\n#include <mruby/dump.h>\n\n// Type Definitions:\n// mrb_sym:\ntypedef uint32_t mrb_sym;\n\n// codegen_scope:\ntypedef struct scope {\n  mrb_state *mrb;\n  mrb_pool *mpool;\n\n  struct scope *prev;\n\n  node *lv;\n\n  uint16_t sp;\n  uint32_t pc;\n  uint32_t lastpc;\n  uint32_t lastlabel;\n  uint16_t ainfo:15;\n  mrb_bool mscope:1;\n\n  struct loopinfo *loop;\n  mrb_sym filename_sym;\n  uint16_t lineno;\n\n  mrb_code *iseq;\n  uint16_t *lines;\n  uint32_t icapa;\n\n  mrb_irep *irep;\n  mrb_pool_value *pool;\n  mrb_sym *syms;\n  mrb_irep **reps;\n  struct mrb_irep_catch_handler *catch_table;\n  uint32_t pcapa, scapa, rcapa;\n\n  uint16_t nlocals;\n  uint16_t nregs;\n  int ai;\n\n  int debug_start_pos;\n  uint16_t filename_index;\n  parser_state* parser;\n\n  int rlev;                     /* recursion levels */\n} codegen_scope;\n\n// node:\ntypedef mrb_ast_node node;\n\n// Called Methods (top 10):\n// mrb_format from src/error.c:\nmrb_format(mrb_state *mrb, const char *format, ...) /* <=== mrb_format */ \n{\n  va_list ap;\n  mrb_value str;\n\n  va_start(ap, format);\n  str = mrb_vformat(mrb, format, ap);\n  va_end(ap);\n\n  return str;\n}\n\n// new_litbn from mrbgems/mruby-compiler/core/codegen.c:\nstatic int /* <=== new_litbn */ \nnew_litbn(codegen_scope *s, const char *p, int base, mrb_bool neg)\n{\n  int i;\n  size_t plen;\n  mrb_pool_value *pv;\n\n  plen = strlen(p);\n  if (plen > 255) {\n    codegen_error(s, \"integer too big\");\n  }\n  for (i=0; i<s->irep->plen; i++) {\n    size_t len;\n    pv = &s->pool[i];\n    if (pv->tt != IREP_TT_BIGINT) continue;\n    len = pv->u.str[0];\n    if (len == plen && pv->u.str[1] == base && memcmp(pv->u.str+2, p, len) == 0)\n      return i;\n  }\n\n  if (s->irep->plen == s->pcapa) {\n    s->pcapa *= 2;\n    s->pool = (mrb_pool_value*)codegen_realloc(s, s->pool, sizeof(mrb_pool_value)*s->pcapa);\n  }\n\n  pv = &s->pool[s->irep->plen];\n  i = s->irep->plen++;\n  {\n    char *buf;\n    pv->tt = IREP_TT_BIGINT;\n    buf = (char*)codegen_realloc(s, NULL, plen+3);\n    buf[0] = (char)plen;\n    buf[1] = base;\n    if (neg) buf[1] = 0x80;\n    memcpy(buf+2, p, plen);\n    buf[plen+2] = '\\0';\n    pv->u.str = buf;\n  }\n  return i;\n}\n\n// gen_return from mrbgems/mruby-compiler/core/codegen.c:\nstatic void /* <=== gen_return */ \ngen_return(codegen_scope *s, uint8_t op, uint16_t src)\n{\n  if (no_peephole(s)) {\n    genop_1(s, op, src);\n  }\n  else {\n    struct mrb_insn_data data = mrb_last_insn(s);\n\n    if (data.insn == OP_MOVE && src == data.a) {\n      rewind_pc(s);\n      genop_1(s, op, data.b);\n    }\n    else if (data.insn != OP_RETURN) {\n      genop_1(s, op, src);\n    }\n  }\n}\n\n// loop_break from mrbgems/mruby-compiler/core/codegen.c:\nstatic void /* <=== loop_break */ \nloop_break(codegen_scope *s, node *tree)\n{\n  if (!s->loop) {\n    codegen(s, tree, NOVAL);\n    raise_error(s, \"unexpected break\");\n  }\n  else {\n    struct loopinfo *loop;\n\n\n    loop = s->loop;\n    if (tree) {\n      if (loop->reg < 0) {\n        codegen(s, tree, NOVAL);\n      }\n      else {\n        gen_retval(s, tree);\n      }\n    }\n    while (loop) {\n      if (loop->type == LOOP_BEGIN) {\n        loop = loop->prev;\n      }\n      else if (loop->type == LOOP_RESCUE) {\n        loop = loop->prev;\n      }\n      else{\n        break;\n      }\n    }\n    if (!loop) {\n      raise_error(s, \"unexpected break\");\n      return;\n    }\n\n    if (loop->type == LOOP_NORMAL) {\n      int tmp;\n\n      if (loop->reg >= 0) {\n        if (tree) {\n          gen_move(s, loop->reg, cursp(), 0);\n        }\n        else {\n          genop_1(s, OP_LOADNIL, loop->reg);\n        }\n      }\n      tmp = genjmp(s, OP_JMPUW, loop->pc2);\n      loop->pc2 = tmp;\n    }\n    else {\n      if (!tree) {\n        genop_1(s, OP_LOADNIL, cursp());\n      }\n      gen_return(s, OP_BREAK, cursp());\n    }\n  }\n}\n\n// genop_3 from mrbgems/mruby-compiler/core/codegen.c:\nstatic void\ngenop_3(codegen_scope *s, mrb_code i, uint16_t a, uint16_t b, uint8_t c)\n{\n  genop_2(s, i, a, b);\n  gen_B(s, c);\n}\n\n// genop_1 from mrbgems/mruby-compiler/core/codegen.c:\nstatic void\ngenop_1(codegen_scope *s, mrb_code i, uint16_t a)\n{\n  s->lastpc = s->pc;\n  check_no_ext_ops(s, a, 0);\n  if (a > 0xff) {\n    gen_B(s, OP_EXT1);\n    gen_B(s, i);\n    gen_S(s, a);\n  }\n  else {\n    gen_B(s, i);\n    gen_B(s, (uint8_t)a);\n  }\n}\n\n// mrb_realloc_simple from src/gc.c:\nMRB_API void* /* <=== mrb_realloc_simple */ \nmrb_realloc_simple(mrb_state *mrb, void *p,  size_t len)\n{\n  void *p2;\n\n  p2 = (mrb->allocf)(mrb, p, len, mrb->allocf_ud);\n  if (!p2 && len > 0 && mrb->gc.heaps) {\n    mrb_full_gc(mrb);\n    p2 = (mrb->allocf)(mrb, p, len, mrb->allocf_ud);\n  }\n\n  return p2;\n}\n\n// mrb_intern_str from src/symbol.c:\nmrb_intern_str(mrb_state *mrb, mrb_value str) /* <=== mrb_intern_str */ \n{\n  return mrb_intern(mrb, RSTRING_PTR(str), RSTRING_LEN(str));\n}\n\n// genop_2 from mrbgems/mruby-compiler/core/codegen.c:\nstatic void\ngenop_2(codegen_scope *s, mrb_code i, uint16_t a, uint16_t b)\n{\n  s->lastpc = s->pc;\n  check_no_ext_ops(s, a, b);\n  if (a > 0xff && b > 0xff) {\n    gen_B(s, OP_EXT3);\n    gen_B(s, i);\n    gen_S(s, a);\n    gen_S(s, b);\n  }\n  else if (b > 0xff) {\n    gen_B(s, OP_EXT2);\n    gen_B(s, i);\n    gen_B(s, (uint8_t)a);\n    gen_S(s, b);\n  }\n  else if (a > 0xff) {\n    gen_B(s, OP_EXT1);\n    gen_B(s, i);\n    gen_S(s, a);\n    gen_B(s, (uint8_t)b);\n  }\n  else {\n    gen_B(s, i);\n    gen_B(s, (uint8_t)a);\n    gen_B(s, (uint8_t)b);\n  }\n}\n\n// mrb_str_new_cstr from src/string.c:\nmrb_str_new_cstr(mrb_state *mrb, const char *p) /* <=== mrb_str_new_cstr */ \n{\n  struct RString *s;\n  size_t len;\n\n  if (p) {\n    len = strlen(p);\n  }\n  else {\n    len = 0;\n  }\n\n  s = str_new(mrb, p, len);\n\n  return mrb_obj_value(s);\n}\n"
  },
  {
    "repository": "njs",
    "cve_id": "CVE-2022-31307",
    "cwe_list": [
      "CWE-703"
    ],
    "commit_hash": "eafe4c7a326b163612f10861392622b5da5b1792",
    "short_hash": "eafe4c7a",
    "vulnerableMethods_before": [
      {
        "filename": "njs_iterator.c",
        "method_name": "vulnerable_function",
        "raw_code": "njs_object_iterate_reverse(njs_vm_t *vm, njs_iterator_args_t *args,\n    njs_iterator_handler_t handler)\n{\n    double              idx;\n    int64_t             i, from, to, length;\n    njs_int_t           ret;\n    njs_array_t         *array, *keys;\n    njs_value_t         *entry, *value, prop, character, string_obj;\n    const u_char        *p, *end, *pos;\n    njs_string_prop_t   string_prop;\n    njs_object_value_t  *object;\n\n    value = args->value;\n    from = args->from;\n    to = args->to;\n\n    if (njs_is_array(value)) {\n        array = njs_array(value);\n\n        from += 1;\n\n        while (from-- > to) {\n            if (njs_slow_path(!array->object.fast_array)) {\n                goto process_object;\n            }\n\n            if (njs_fast_path(from < array->length\n                              && njs_is_valid(&array->start[from])))\n            {\n                ret = handler(vm, args, &array->start[from], from);\n\n            } else {\n                entry = njs_value_arg(&njs_value_invalid);\n                ret = njs_value_property_i64(vm, value, from, &prop);\n                if (njs_slow_path(ret != NJS_DECLINED)) {\n                    if (ret == NJS_ERROR) {\n                        return NJS_ERROR;\n                    }\n\n                    entry = &prop;\n                }\n\n                ret = handler(vm, args, entry, from);\n            }\n\n            if (njs_slow_path(ret != NJS_OK)) {\n                if (ret == NJS_DONE) {\n                    return NJS_DONE;\n                }\n\n                return NJS_ERROR;\n            }\n        }\n\n        return NJS_OK;\n    }\n\n    if (njs_is_string(value) || njs_is_object_string(value)) {\n\n        if (njs_is_string(value)) {\n            object = njs_object_value_alloc(vm, NJS_OBJ_TYPE_STRING, 0, value);\n            if (njs_slow_path(object == NULL)) {\n                return NJS_ERROR;\n            }\n\n            njs_set_object_value(&string_obj, object);\n\n            args->value = &string_obj;\n        }\n        else {\n            value = njs_object_value(value);\n        }\n\n        length = njs_string_prop(&string_prop, value);\n        end = string_prop.start + string_prop.size;\n\n        if ((size_t) length == string_prop.size) {\n            /* Byte or ASCII string. */\n\n            p = string_prop.start + from;\n\n            i = from + 1;\n\n            while (i-- > to) {\n                /* This cannot fail. */\n                (void) njs_string_new(vm, &character, p, 1, 1);\n\n                ret = handler(vm, args, &character, i);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    if (ret == NJS_DONE) {\n                        return NJS_DONE;\n                    }\n\n                    return NJS_ERROR;\n                }\n\n                p--;\n            }\n\n        } else {\n            /* UTF-8 string. */\n\n            p = njs_string_offset(string_prop.start, end, from);\n            p = njs_utf8_next(p, end);\n\n            i = from + 1;\n\n            while (i-- > to) {\n                pos = njs_utf8_prev(p);\n\n                /* This cannot fail. */\n                (void) njs_string_new(vm, &character, pos, p - pos , 1);\n\n                ret = handler(vm, args, &character, i);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    if (ret == NJS_DONE) {\n                        return NJS_DONE;\n                    }\n\n                    return NJS_ERROR;\n                }\n\n                p = pos;\n            }\n        }\n\n        return NJS_OK;\n    }\n\n    if (!njs_is_object(value)) {\n        return NJS_OK;\n    }\n\nprocess_object:\n\n    if (!njs_fast_object(from - to)) {\n        keys = njs_array_indices(vm, value);\n        if (njs_slow_path(keys == NULL)) {\n            return NJS_ERROR;\n        }\n\n        i = keys->length;\n\n        while (i > 0) {\n            idx = njs_string_to_index(&keys->start[--i]);\n\n            if (idx < to || idx > from) {\n                continue;\n            }\n\n            ret = njs_iterator_object_handler(vm, handler, args,\n                                              &keys->start[i], idx);\n            if (njs_slow_path(ret != NJS_OK)) {\n                njs_array_destroy(vm, keys);\n                return ret;\n            }\n        }\n\n        njs_array_destroy(vm, keys);\n\n        return NJS_OK;\n    }\n\n    i = from + 1;\n\n    while (i-- > to) {\n        ret = njs_iterator_object_handler(vm, handler, args, NULL, i);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n    }\n\n    return NJS_OK;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "njs_iterator.c",
        "method_name": "fixed_function",
        "raw_code": "njs_object_iterate_reverse(njs_vm_t *vm, njs_iterator_args_t *args,\n    njs_iterator_handler_t handler)\n{\n    double              idx;\n    int64_t             i, from, to, length;\n    njs_int_t           ret;\n    njs_array_t         *array, *keys;\n    njs_value_t         *entry, *value, prop, character, string_obj;\n    const u_char        *p, *end, *pos;\n    njs_string_prop_t   string_prop;\n    njs_object_value_t  *object;\n\n    value = args->value;\n    from = args->from;\n    to = args->to;\n\n    if (njs_is_array(value)) {\n        array = njs_array(value);\n\n        from += 1;\n\n        while (from-- > to) {\n            if (njs_slow_path(!array->object.fast_array)) {\n                goto process_object;\n            }\n\n            if (njs_fast_path(from < array->length\n                              && njs_is_valid(&array->start[from])))\n            {\n                ret = handler(vm, args, &array->start[from], from);\n\n            } else {\n                entry = njs_value_arg(&njs_value_invalid);\n                ret = njs_value_property_i64(vm, value, from, &prop);\n                if (njs_slow_path(ret != NJS_DECLINED)) {\n                    if (ret == NJS_ERROR) {\n                        return NJS_ERROR;\n                    }\n\n                    entry = &prop;\n                }\n\n                ret = handler(vm, args, entry, from);\n            }\n\n            if (njs_slow_path(ret != NJS_OK)) {\n                if (ret == NJS_DONE) {\n                    return NJS_DONE;\n                }\n\n                return NJS_ERROR;\n            }\n        }\n\n        return NJS_OK;\n    }\n\n    if (njs_is_string(value) || njs_is_object_string(value)) {\n\n        if (njs_is_string(value)) {\n            object = njs_object_value_alloc(vm, NJS_OBJ_TYPE_STRING, 0, value);\n            if (njs_slow_path(object == NULL)) {\n                return NJS_ERROR;\n            }\n\n            njs_set_object_value(&string_obj, object);\n\n            args->value = &string_obj;\n        }\n        else {\n            value = njs_object_value(value);\n        }\n\n        length = njs_string_prop(&string_prop, value);\n        end = string_prop.start + string_prop.size;\n\n        if ((size_t) length == string_prop.size) {\n            /* Byte or ASCII string. */\n\n            p = string_prop.start + from;\n\n            i = from + 1;\n\n            while (i-- > to) {\n                /* This cannot fail. */\n                (void) njs_string_new(vm, &character, p, 1, 1);\n\n                ret = handler(vm, args, &character, i);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    if (ret == NJS_DONE) {\n                        return NJS_DONE;\n                    }\n\n                    return NJS_ERROR;\n                }\n\n                p--;\n            }\n\n        } else {\n            /* UTF-8 string. */\n\n            p = NULL;\n            i = from + 1;\n\n            if (i > to) {\n                p = njs_string_offset(string_prop.start, end, from);\n                p = njs_utf8_next(p, end);\n            }\n\n            while (i-- > to) {\n                pos = njs_utf8_prev(p);\n\n                /* This cannot fail. */\n                (void) njs_string_new(vm, &character, pos, p - pos , 1);\n\n                ret = handler(vm, args, &character, i);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    if (ret == NJS_DONE) {\n                        return NJS_DONE;\n                    }\n\n                    return NJS_ERROR;\n                }\n\n                p = pos;\n            }\n        }\n\n        return NJS_OK;\n    }\n\n    if (!njs_is_object(value)) {\n        return NJS_OK;\n    }\n\nprocess_object:\n\n    if (!njs_fast_object(from - to)) {\n        keys = njs_array_indices(vm, value);\n        if (njs_slow_path(keys == NULL)) {\n            return NJS_ERROR;\n        }\n\n        i = keys->length;\n\n        while (i > 0) {\n            idx = njs_string_to_index(&keys->start[--i]);\n\n            if (idx < to || idx > from) {\n                continue;\n            }\n\n            ret = njs_iterator_object_handler(vm, handler, args,\n                                              &keys->start[i], idx);\n            if (njs_slow_path(ret != NJS_OK)) {\n                njs_array_destroy(vm, keys);\n                return ret;\n            }\n        }\n\n        njs_array_destroy(vm, keys);\n\n        return NJS_OK;\n    }\n\n    i = from + 1;\n\n    while (i-- > to) {\n        ret = njs_iterator_object_handler(vm, handler, args, NULL, i);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n    }\n\n    return NJS_OK;\n}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "vim",
    "cve_id": "CVE-2022-2982",
    "cwe_list": [
      "CWE-703"
    ],
    "commit_hash": "d6c67629ed05aae436164eec474832daf8ba7420",
    "short_hash": "d6c67629",
    "vulnerableMethods_before": [
      {
        "filename": "None",
        "method_name": "vulnerable_function",
        "raw_code": "call_qftf_func(qf_list_T *qfl, int qf_winid, long start_idx, long end_idx)\n{\n    callback_T\t*cb = &qftf_cb;\n    list_T\t*qftf_list = NULL;\n\n    // If 'quickfixtextfunc' is set, then use the user-supplied function to get\n    // the text to display. Use the local value of 'quickfixtextfunc' if it is\n    // set.\n    if (qfl->qf_qftf_cb.cb_name != NULL)\n\tcb = &qfl->qf_qftf_cb;\n    if (cb->cb_name != NULL)\n    {\n\ttypval_T\targs[1];\n\tdict_T\t\t*d;\n\ttypval_T\trettv;\n\n\t// create the dict argument\n\tif ((d = dict_alloc_lock(VAR_FIXED)) == NULL)\n\t    return NULL;\n\tdict_add_number(d, \"quickfix\", (long)IS_QF_LIST(qfl));\n\tdict_add_number(d, \"winid\", (long)qf_winid);\n\tdict_add_number(d, \"id\", (long)qfl->qf_id);\n\tdict_add_number(d, \"start_idx\", start_idx);\n\tdict_add_number(d, \"end_idx\", end_idx);\n\t++d->dv_refcount;\n\targs[0].v_type = VAR_DICT;\n\targs[0].vval.v_dict = d;\n\n\tqftf_list = NULL;\n\tif (call_callback(cb, 0, &rettv, 1, args) != FAIL)\n\t{\n\t    if (rettv.v_type == VAR_LIST)\n\t    {\n\t\tqftf_list = rettv.vval.v_list;\n\t\tqftf_list->lv_refcount++;\n\t    }\n\t    clear_tv(&rettv);\n\t}\n\tdict_unref(d);\n    }\n\n    return qftf_list;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "quickfix.c",
        "method_name": "fixed_function",
        "raw_code": "call_qftf_func(qf_list_T *qfl, int qf_winid, long start_idx, long end_idx)\n{\n    callback_T\t*cb = &qftf_cb;\n    list_T\t*qftf_list = NULL;\n    static int\trecursive = FALSE;\n\n    if (recursive)\n\treturn NULL;  // this doesn't work properly recursively\n    recursive = TRUE;\n\n    // If 'quickfixtextfunc' is set, then use the user-supplied function to get\n    // the text to display. Use the local value of 'quickfixtextfunc' if it is\n    // set.\n    if (qfl->qf_qftf_cb.cb_name != NULL)\n\tcb = &qfl->qf_qftf_cb;\n    if (cb->cb_name != NULL)\n    {\n\ttypval_T\targs[1];\n\tdict_T\t\t*d;\n\ttypval_T\trettv;\n\n\t// create the dict argument\n\tif ((d = dict_alloc_lock(VAR_FIXED)) == NULL)\n\t{\n\t    recursive = FALSE;\n\t    return NULL;\n\t}\n\tdict_add_number(d, \"quickfix\", (long)IS_QF_LIST(qfl));\n\tdict_add_number(d, \"winid\", (long)qf_winid);\n\tdict_add_number(d, \"id\", (long)qfl->qf_id);\n\tdict_add_number(d, \"start_idx\", start_idx);\n\tdict_add_number(d, \"end_idx\", end_idx);\n\t++d->dv_refcount;\n\targs[0].v_type = VAR_DICT;\n\targs[0].vval.v_dict = d;\n\n\tqftf_list = NULL;\n\tif (call_callback(cb, 0, &rettv, 1, args) != FAIL)\n\t{\n\t    if (rettv.v_type == VAR_LIST)\n\t    {\n\t\tqftf_list = rettv.vval.v_list;\n\t\tqftf_list->lv_refcount++;\n\t    }\n\t    clear_tv(&rettv);\n\t}\n\tdict_unref(d);\n    }\n\n    recursive = FALSE;\n    return qftf_list;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"vim.h\"\n\n// Type Definitions:\n// qf_list_T:\ntypedef struct qf_list_S\n{\n    int_u\tqf_id;\t\t// Unique identifier for this list\n    qfltype_T\tqfl_type;\n    qfline_T\t*qf_start;\t// pointer to the first error\n    qfline_T\t*qf_last;\t// pointer to the last error\n    qfline_T\t*qf_ptr;\t// pointer to the current error\n    int\t\tqf_count;\t// number of errors (0 means empty list)\n    int\t\tqf_index;\t// current index in the error list\n    int\t\tqf_nonevalid;\t// TRUE if not a single valid entry found\n    char_u\t*qf_title;\t// title derived from the command that created\n\t\t\t\t// the error list or set by setqflist\n    typval_T\t*qf_ctx;\t// context set by setqflist/setloclist\n    callback_T  qf_qftf_cb;\t// 'quickfixtextfunc' callback function\n\n    struct dir_stack_T\t*qf_dir_stack;\n    char_u\t\t*qf_directory;\n    struct dir_stack_T\t*qf_file_stack;\n    char_u\t\t*qf_currfile;\n    int\t\t\tqf_multiline;\n    int\t\t\tqf_multiignore;\n    int\t\t\tqf_multiscan;\n    long\t\tqf_changedtick;\n} qf_list_T;\n\n// callback_T:\ntypedef struct {\n    char_u\t*cb_name;\n    partial_T\t*cb_partial;\n    int\t\tcb_free_name;\t    // cb_name was allocated\n}\n\n// dict_T:\ntypedef struct dictvar_S dict_T;\n\n// list_T:\ntypedef struct listvar_S list_T;\n\n// typval_T:\ntypedef struct\n{\n    vartype_T\tv_type;\n    char\tv_lock;\t    // see below: VAR_LOCKED, VAR_FIXED\n    union\n    {\n\tvarnumber_T\tv_number;\t// number value\n#ifdef FEAT_FLOAT\n\tfloat_T\t\tv_float;\t// floating number value\n#endif\n\tchar_u\t\t*v_string;\t// string value (can be NULL!)\n\tlist_T\t\t*v_list;\t// list value (can be NULL!)\n\tdict_T\t\t*v_dict;\t// dict value (can be NULL!)\n\tpartial_T\t*v_partial;\t// closure: function with args\n#ifdef FEAT_JOB_CHANNEL\n\tjob_T\t\t*v_job;\t\t// job value (can be NULL!)\n\tchannel_T\t*v_channel;\t// channel value (can be NULL!)\n#endif\n\tblob_T\t\t*v_blob;\t// blob value (can be NULL!)\n\tinstr_T\t\t*v_instr;\t// instructions to execute\n    }\t\tvval;\n}\n\n// Called Methods (top 10):\n// NUL from src/ascii.h:\n#define NUL\t\t'\\000' /* <=== src/ascii.h:18:18:NUL:0 */ \n\n// partial_unref from src/eval.c:\n    void /* <=== partial_unref */ \npartial_unref(partial_T *pt)\n{\n    if (pt != NULL)\n    {\n\tif (--pt->pt_refcount <= 0)\n\t    partial_free(pt);\n\n\t// If the reference count goes down to one, the funcstack may be the\n\t// only reference and can be freed if no other partials reference it.\n\telse if (pt->pt_refcount == 1 && pt->pt_funcstack != NULL)\n\t    funcstack_check_refcount(pt->pt_funcstack);\n    }\n}\n\n// emsg from src/message.c:\n    int /* <=== emsg */ \nemsg(char *s)\n{\n    // Skip this if not giving error messages at the moment.\n    if (!emsg_not_now())\n\treturn emsg_core((char_u *)s);\n    return TRUE;\t\t// no error messages at the moment\n}\n\n// VAR_FIXED from src/structs.h:\n<empty>\n\n// clear_tv from src/typval.c:\nvoid\nclear_tv(typval_T *varp)\n{\n    if (varp != NULL)\n    {\n\tswitch (varp->v_type)\n\t{\n\t    case VAR_FUNC:\n\t\tfunc_unref(varp->vval.v_string);\n\t\t// FALLTHROUGH\n\t    case VAR_STRING:\n\t\tVIM_CLEAR(varp->vval.v_string);\n\t\tbreak;\n\t    case VAR_PARTIAL:\n\t\tpartial_unref(varp->vval.v_partial);\n\t\tvarp->vval.v_partial = NULL;\n\t\tbreak;\n\t    case VAR_BLOB:\n\t\tblob_unref(varp->vval.v_blob);\n\t\tvarp->vval.v_blob = NULL;\n\t\tbreak;\n\t    case VAR_LIST:\n\t\tlist_unref(varp->vval.v_list);\n\t\tvarp->vval.v_list = NULL;\n\t\tbreak;\n\t    case VAR_DICT:\n\t\tdict_unref(varp->vval.v_dict);\n\t\tvarp->vval.v_dict = NULL;\n\t\tbreak;\n\t    case VAR_NUMBER:\n\t    case VAR_BOOL:\n\t    case VAR_SPECIAL:\n\t\tvarp->vval.v_number = 0;\n\t\tbreak;\n\t    case VAR_FLOAT:\n#ifdef FEAT_FLOAT\n\t\tvarp->vval.v_float = 0.0;\n\t\tbreak;\n#endif\n\t    case VAR_JOB:\n#ifdef FEAT_JOB_CHANNEL\n\t\tjob_unref(varp->vval.v_job);\n\t\tvarp->vval.v_job = NULL;\n#endif\n\t\tbreak;\n\t    case VAR_CHANNEL:\n#ifdef FEAT_JOB_CHANNEL\n\t\tchannel_unref(varp->vval.v_channel);\n\t\tvarp->vval.v_...\n\n// FCERR_OTHER from src/vim.h:\n#define FCERR_OTHER\t6 /* <=== src/vim.h:2677:2677:FCERR_OTHER:0 */ \n\n// alloc_clear from src/alloc.c:\n    void * /* <=== alloc_clear */ \nalloc_clear(size_t size)\n{\n    void *p;\n\n    p = lalloc(size, TRUE);\n    if (p != NULL)\n\t(void)vim_memset(p, 0, size);\n    return p;\n}\n\n// FC_DELETED from src/structs.h:\n#define FC_DELETED  0x10\t// :delfunction used while uf_refcount > 0 /* <=== src/structs.h:1716:1716:FC_DELETED:0 */ \n\n// FCERR_NONE from src/vim.h:\n#define FCERR_NONE\t5 /* <=== src/vim.h:2676:2676:FCERR_NONE:0 */ \n\n// IOSIZE from src/vim.h:\n#define IOSIZE\t   (1024+1)\t// file i/o and sprintf buffer size /* <=== src/vim.h:1574:1574:IOSIZE:0 */ \n"
  },
  {
    "repository": "tensorflow",
    "cve_id": "CVE-2022-29200",
    "cwe_list": [
      "CWE-703"
    ],
    "commit_hash": "803404044ae7a1efac48ba82d74111fce1ddb09a",
    "short_hash": "80340404",
    "vulnerableMethods_before": [
      {
        "filename": "lstm_ops.cc",
        "method_name": "vulnerable_function",
        "raw_code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor* x_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"x\", &x_tensor));\n\n    const Tensor* cs_prev_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"cs_prev\", &cs_prev_tensor));\n\n    const Tensor* h_prev_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"h_prev\", &h_prev_tensor));\n\n    const Tensor* w_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"w\", &w_tensor));\n\n    const Tensor* wci_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"wci\", &wci_tensor));\n\n    const Tensor* wcf_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"wcf\", &wcf_tensor));\n\n    const Tensor* wco_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"wco\", &wco_tensor));\n\n    const Tensor* b_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"b\", &b_tensor));\n\n    const int64_t batch_size = x_tensor->dim_size(0);\n    const int64_t input_size = x_tensor->dim_size(1);\n    const int64_t cell_size = cs_prev_tensor->dim_size(1);\n\n    // Sanity checks for our input shapes.\n    OP_REQUIRES(ctx, cs_prev_tensor->dim_size(0) == batch_size,\n                errors::InvalidArgument(\"cs_prev.dims(0) != batch_size: \",\n                                        cs_prev_tensor->dim_size(0), \" vs. \",\n                                        batch_size));\n    OP_REQUIRES(ctx, cs_prev_tensor->dim_size(1) == cell_size,\n                errors::InvalidArgument(\"cs_prev.dims(1) != cell_size: \",\n                                        cs_prev_tensor->dim_size(1), \" vs. \",\n                                        cell_size));\n\n    OP_REQUIRES(ctx, h_prev_tensor->dim_size(0) == batch_size,\n                errors::InvalidArgument(\"h_prev.dims(0) != batch_size: \",\n                                        h_prev_tensor->dim_size(0), \" vs. \",\n                                        batch_size));\n    OP_REQUIRES(ctx, h_prev_tensor->dim_size(1) == cell_size,\n                errors::InvalidArgument(\n                    \"h_prev.dims(1) != cell_size: \", h_prev_tensor->dim_size(1),\n                    \" vs. \", cell_size));\n\n    OP_REQUIRES(ctx, w_tensor->dim_size(0) == input_size + cell_size,\n                errors::InvalidArgument(\n                    \"w.dim_size(0) != input_size + cell_size: \",\n                    w_tensor->dim_size(0), \" vs. \", input_size + cell_size));\n    OP_REQUIRES(ctx, w_tensor->dim_size(1) == cell_size * 4,\n                errors::InvalidArgument(\n                    \"w.dim_size(1) != cell_size * 4: \", w_tensor->dim_size(1),\n                    \" vs. \", cell_size * 4));\n\n    OP_REQUIRES(ctx, b_tensor->dim_size(0) == cell_size * 4,\n                errors::InvalidArgument(\n                    \"b.dim_size(0) != cell_size * 4: \", b_tensor->dim_size(0),\n                    \" vs. \", cell_size * 4));\n\n    // Allocate our output tensors.\n    Tensor* i_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->forward_input_or_allocate_output(\n                            {\"h_prev\"}, \"i\",\n                            TensorShape({batch_size, cell_size}), &i_tensor));\n\n    Tensor* cs_tensor = nullptr;\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_output(\"cs\", TensorShape({batch_size, cell_size}),\n                                  &cs_tensor));\n\n    Tensor* f_tensor = nullptr;\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_output(\"f\", TensorShape({batch_size, cell_size}),\n                                  &f_tensor));\n\n    Tensor* o_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->forward_input_or_allocate_output(\n                            {\"cs_prev\"}, \"o\",\n                            TensorShape({batch_size, cell_size}), &o_tensor));\n\n    Tensor* ci_tensor = nullptr;\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_output(\"ci\", TensorShape({batch_size, cell_size}),\n                                  &ci_tensor));\n\n    Tensor* co_tensor = nullptr;\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_output(\"co\", TensorShape({batch_size, cell_size}),\n                                  &co_tensor));\n\n    Tensor* h_tensor = nullptr;\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_output(\"h\", TensorShape({batch_size, cell_size}),\n                                  &h_tensor));\n\n    // Allocate our temp tensors.\n    Tensor xh_tensor;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(\n                            DataTypeToEnum<T>::v(),\n                            TensorShape({batch_size, input_size + cell_size}),\n                            &xh_tensor));\n\n    Tensor gates_tensor;\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_temp(DataTypeToEnum<T>::v(),\n                                      TensorShape({batch_size, cell_size * 4}),\n                                      &gates_tensor));\n\n    const Device& device = ctx->eigen_device<Device>();\n\n    functor::LSTMBlockCellFprop<Device, T, USE_CUBLAS, gate_layout>(\n        batch_size, input_size, cell_size)(\n        ctx, device, forget_bias_, cell_clip_, use_peephole_,\n        x_tensor->matrix<T>(), cs_prev_tensor->matrix<T>(),\n        h_prev_tensor->matrix<T>(), w_tensor->matrix<T>(), wci_tensor->vec<T>(),\n        wcf_tensor->vec<T>(), wco_tensor->vec<T>(), b_tensor->vec<T>(),\n        xh_tensor.matrix<T>(), i_tensor->matrix<T>(), cs_tensor->matrix<T>(),\n        f_tensor->matrix<T>(), o_tensor->matrix<T>(), ci_tensor->matrix<T>(),\n        co_tensor->matrix<T>(), gates_tensor.matrix<T>(),\n        h_tensor->matrix<T>());\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "lstm_ops.cc",
        "method_name": "fixed_function",
        "raw_code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor* x_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"x\", &x_tensor));\n\n    const Tensor* cs_prev_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"cs_prev\", &cs_prev_tensor));\n\n    const Tensor* h_prev_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"h_prev\", &h_prev_tensor));\n\n    const Tensor* w_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"w\", &w_tensor));\n\n    const Tensor* wci_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"wci\", &wci_tensor));\n\n    const Tensor* wcf_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"wcf\", &wcf_tensor));\n\n    const Tensor* wco_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"wco\", &wco_tensor));\n\n    const Tensor* b_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"b\", &b_tensor));\n\n    const int64_t batch_size = x_tensor->dim_size(0);\n    const int64_t input_size = x_tensor->dim_size(1);\n    const int64_t cell_size = cs_prev_tensor->dim_size(1);\n\n    // Sanity checks for our input shapes.\n    OP_REQUIRES(ctx, cs_prev_tensor->dim_size(0) == batch_size,\n                errors::InvalidArgument(\"cs_prev.dims(0) != batch_size: \",\n                                        cs_prev_tensor->dim_size(0), \" vs. \",\n                                        batch_size));\n    OP_REQUIRES(ctx, cs_prev_tensor->dim_size(1) == cell_size,\n                errors::InvalidArgument(\"cs_prev.dims(1) != cell_size: \",\n                                        cs_prev_tensor->dim_size(1), \" vs. \",\n                                        cell_size));\n\n    OP_REQUIRES(ctx, h_prev_tensor->dim_size(0) == batch_size,\n                errors::InvalidArgument(\"h_prev.dims(0) != batch_size: \",\n                                        h_prev_tensor->dim_size(0), \" vs. \",\n                                        batch_size));\n    OP_REQUIRES(ctx, h_prev_tensor->dim_size(1) == cell_size,\n                errors::InvalidArgument(\n                    \"h_prev.dims(1) != cell_size: \", h_prev_tensor->dim_size(1),\n                    \" vs. \", cell_size));\n\n    OP_REQUIRES(ctx, w_tensor->dim_size(0) == input_size + cell_size,\n                errors::InvalidArgument(\n                    \"w.dim_size(0) != input_size + cell_size: \",\n                    w_tensor->dim_size(0), \" vs. \", input_size + cell_size));\n    OP_REQUIRES(ctx, w_tensor->dim_size(1) == cell_size * 4,\n                errors::InvalidArgument(\n                    \"w.dim_size(1) != cell_size * 4: \", w_tensor->dim_size(1),\n                    \" vs. \", cell_size * 4));\n\n    OP_REQUIRES(ctx, b_tensor->dim_size(0) == cell_size * 4,\n                errors::InvalidArgument(\n                    \"b.dim_size(0) != cell_size * 4: \", b_tensor->dim_size(0),\n                    \" vs. \", cell_size * 4));\n\n    // Allocate our output tensors.\n    Tensor* i_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->forward_input_or_allocate_output(\n                            {\"h_prev\"}, \"i\",\n                            TensorShape({batch_size, cell_size}), &i_tensor));\n\n    Tensor* cs_tensor = nullptr;\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_output(\"cs\", TensorShape({batch_size, cell_size}),\n                                  &cs_tensor));\n\n    Tensor* f_tensor = nullptr;\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_output(\"f\", TensorShape({batch_size, cell_size}),\n                                  &f_tensor));\n\n    Tensor* o_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->forward_input_or_allocate_output(\n                            {\"cs_prev\"}, \"o\",\n                            TensorShape({batch_size, cell_size}), &o_tensor));\n\n    Tensor* ci_tensor = nullptr;\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_output(\"ci\", TensorShape({batch_size, cell_size}),\n                                  &ci_tensor));\n\n    Tensor* co_tensor = nullptr;\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_output(\"co\", TensorShape({batch_size, cell_size}),\n                                  &co_tensor));\n\n    Tensor* h_tensor = nullptr;\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_output(\"h\", TensorShape({batch_size, cell_size}),\n                                  &h_tensor));\n\n    // Allocate our temp tensors.\n    Tensor xh_tensor;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(\n                            DataTypeToEnum<T>::v(),\n                            TensorShape({batch_size, input_size + cell_size}),\n                            &xh_tensor));\n\n    Tensor gates_tensor;\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_temp(DataTypeToEnum<T>::v(),\n                                      TensorShape({batch_size, cell_size * 4}),\n                                      &gates_tensor));\n\n    const Device& device = ctx->eigen_device<Device>();\n\n    // Sanity check that each of the tensors have the required NDIMS.\n    OP_REQUIRES(ctx, x_tensor->dims() == 2,\n                errors::InvalidArgument(\"x_tensor must be rank 2 but is rank \",\n                                        x_tensor->dims(), \".\"));\n    OP_REQUIRES(\n        ctx, cs_prev_tensor->dims() == 2,\n        errors::InvalidArgument(\"cs_prev_tensor must be rank 2 but is rank \",\n                                cs_prev_tensor->dims(), \".\"));\n    OP_REQUIRES(\n        ctx, h_prev_tensor->dims() == 2,\n        errors::InvalidArgument(\"h_prev_tensor must be rank 2 but is rank \",\n                                h_prev_tensor->dims(), \".\"));\n    OP_REQUIRES(ctx, w_tensor->dims() == 2,\n                errors::InvalidArgument(\"w_tensor must be rank 2 but is rank \",\n                                        w_tensor->dims(), \".\"));\n    OP_REQUIRES(\n        ctx, wci_tensor->dims() == 1,\n        errors::InvalidArgument(\"wci_tensor must be rank 1 but is rank \",\n                                wci_tensor->dims(), \".\"));\n    OP_REQUIRES(\n        ctx, wcf_tensor->dims() == 1,\n        errors::InvalidArgument(\"wcf_tensor must be rank 1 but is rank \",\n                                wci_tensor->dims(), \".\"));\n    OP_REQUIRES(\n        ctx, wco_tensor->dims() == 1,\n        errors::InvalidArgument(\"wco_tensor must be rank 1 but is rank \",\n                                wco_tensor->dims(), \".\"));\n    OP_REQUIRES(ctx, b_tensor->dims() == 1,\n                errors::InvalidArgument(\"b_tensor must be rank 1 but is rank \",\n                                        b_tensor->dims(), \".\"));\n    OP_REQUIRES(ctx, xh_tensor.dims() == 2,\n                errors::InvalidArgument(\"xh_tensor must be rank 2 but is rank \",\n                                        xh_tensor.dims(), \".\"));\n    OP_REQUIRES(ctx, i_tensor->dims() == 2,\n                errors::InvalidArgument(\"i_tensor must be rank 2 but is rank \",\n                                        i_tensor->dims(), \".\"));\n    OP_REQUIRES(ctx, cs_tensor->dims() == 2,\n                errors::InvalidArgument(\"cs_tensor must be rank 2 but is rank \",\n                                        cs_tensor->dims(), \".\"));\n    OP_REQUIRES(ctx, f_tensor->dims() == 2,\n                errors::InvalidArgument(\"f_tensor must be rank 2 but is rank \",\n                                        f_tensor->dims(), \".\"));\n    OP_REQUIRES(ctx, o_tensor->dims() == 2,\n                errors::InvalidArgument(\"o_tensor must be rank 2 but is rank \",\n                                        o_tensor->dims(), \".\"));\n    OP_REQUIRES(ctx, ci_tensor->dims() == 2,\n                errors::InvalidArgument(\"ci_tensor must be rank 2 but is rank \",\n                                        ci_tensor->dims(), \".\"));\n    OP_REQUIRES(ctx, co_tensor->dims() == 2,\n                errors::InvalidArgument(\"co_tensor must be rank 2 but is rank \",\n                                        co_tensor->dims(), \".\"));\n    OP_REQUIRES(\n        ctx, gates_tensor.dims() == 2,\n        errors::InvalidArgument(\"gates_tensor must be rank 2 but is rank \",\n                                gates_tensor.dims(), \".\"));\n    OP_REQUIRES(ctx, h_tensor->dims() == 2,\n                errors::InvalidArgument(\"h_tensor must be rank 2 but is rank \",\n                                        h_tensor->dims(), \".\"));\n\n    functor::LSTMBlockCellFprop<Device, T, USE_CUBLAS, gate_layout>(\n        batch_size, input_size, cell_size)(\n        ctx, device, forget_bias_, cell_clip_, use_peephole_,\n        x_tensor->matrix<T>(), cs_prev_tensor->matrix<T>(),\n        h_prev_tensor->matrix<T>(), w_tensor->matrix<T>(), wci_tensor->vec<T>(),\n        wcf_tensor->vec<T>(), wco_tensor->vec<T>(), b_tensor->vec<T>(),\n        xh_tensor.matrix<T>(), i_tensor->matrix<T>(), cs_tensor->matrix<T>(),\n        f_tensor->matrix<T>(), o_tensor->matrix<T>(), ci_tensor->matrix<T>(),\n        co_tensor->matrix<T>(), gates_tensor.matrix<T>(),\n        h_tensor->matrix<T>());\n  }",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"tensorflow/core/platform/macros.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/kernels/rnn/lstm_ops.h\"\n#include \"tensorflow/core/framework/tensor_types.h\"\n#include <memory>\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include <vector>\n\n// Type Definitions:\n// OpKernelContext:\ntensorflow.OpKernelContext.OpKernelContext:ANY(tensorflow.OpKernelContext.Params*)\n\n// LSTMBlockCellOp:\nclass LSTMBlockCellOp : public OpKernel {\n public:\n  explicit LSTMBlockCellOp(OpKernelConstruction* ctx) : OpKernel(ctx) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"forget_bias\", &forget_bias_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"cell_clip\", &cell_clip_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"use_peephole\", &use_peephole_));\n  }\n\n  void Compute(OpKernelContext* ctx) override {\n    const Tensor* x_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"x\", &x_tensor));\n\n    const Tensor* cs_prev_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"cs_prev\", &cs_prev_tensor));\n\n    const Tensor* h_prev_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"h_prev\", &h_prev_tensor));\n\n    const Tensor* w_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"w\", &w_tensor));\n\n    const Tensor* wci_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"wci\", &wci_tensor));\n\n    const Tensor* wcf_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"wcf\", &wcf_tensor));\n\n    const Tensor* w...\n\n// Status:\nclass Status\n\n// Tensor:\nclass Tensor {\n public:\n  /// \\brief Creates a 1-dimensional, 0-element float tensor.\n  ///\n  /// The returned Tensor is not a scalar (shape {}), but is instead\n  /// an empty one-dimensional Tensor (shape {0}, NumElements() ==\n  /// 0). Since it has no elements, it does not need to be assigned a\n  /// value and is initialized by default (IsInitialized() is\n  /// true). If this is undesirable, consider creating a one-element\n  /// scalar which does require initialization:\n  ///\n  /// ```c++\n  ///\n  ///     Tensor(DT_FLOAT, TensorShape({}))\n  ///\n  /// ```\n  Tensor();\n\n  /// \\brief Creates a Tensor of the given `type` and `shape`.  If\n  /// LogMemory::IsEnabled() the allocation is logged as coming from\n  /// an unknown kernel and step. Calling the Tensor constructor\n  /// directly from within an Op is deprecated: use the\n  /// OpKernelConstruction/OpKernelContext allocate_* methods to\n  /// allocate a new tensor, which record the kernel and step.\n  ///\n  /// The underlying buffer is ...\n\n// Tensor:\ntensorflow.TensorHandle.Tensor:tensorflow.Status(tensorflow.Tensor**)<const>\n\n// Status:\nclass Status {\n public:\n  /// Create a success status.\n  Status() {}\n\n  /// \\brief Create a status with the specified error code and msg as a\n  /// human-readable string containing more detailed information.\n  Status(tensorflow::error::Code code, tensorflow::StringPiece msg)\n      : Status(code, msg, {}) {}\n\n  /// \\brief Create a status with the specified error code, msg, and stack trace\n  /// as a human-readable string containing more detailed information.\n#ifndef SWIG\n  Status(tensorflow::error::Code code, tensorflow::StringPiece msg,\n         std::vector<StackFrame>&& stack_trace);\n#endif\n\n  /// Copy the specified status.\n  Status(const Status& s);\n  Status& operator=(const Status& s);\n#ifndef SWIG\n  Status(Status&& s) noexcept;\n  Status& operator=(Status&& s) noexcept;\n#endif  // SWIG\n\n  static Status OK() { return Status(); }\n\n  /// Returns true iff the status indicates success.\n  bool ok() const { return (state_ == nullptr); }\n\n  tensorflow::error::Code code() const {\n    retu...\n\n// OpKernelContext:\nclass OpKernelContext {\n public:\n  // The first element of a WrappedAllocator is a \"base\" Allocator and\n  // the second element is that Allocator wrapped by a\n  // TrackingAllocator\n  typedef std::pair<Allocator*, TrackingAllocator*> WrappedAllocator;\n\n  // TODO(zhifengc): Do some cleanup of Params.\n  // The Params struct is passed in to initialize an OpKernelContext,\n  // and must outlive the OpKernelContext.\n  struct Params {\n    ~Params() { delete eigen_gpu_device; }\n\n    // The step being executed.\n    int64_t step_id = 0;\n\n    // Timestamp for the start of graph execution. Used for latency metrics.\n    int64_t start_time_usecs = 0;\n\n    // The deadline for the session to complete by. Empty if unspecified.\n    absl::optional<absl::Time> deadline;\n\n    // The op kernel being computed.\n    OpKernel* op_kernel = nullptr;\n\n    // The device on which the kernel is running.\n    DeviceBase* device = nullptr;\n\n    // The Eigen GPU device wrapper, which may include a per-op\n    // wrappe...\n\n// Called Methods (top 10):\n// SetStatus from tensorflow/core/framework/op_kernel.cc:\nvoid OpKernelConstruction::SetStatus(const Status& status) { /* <=== tensorflow.OpKernelConstruction.SetStatus:void(tensorflow.Status&) */ \n  status_->Update(status);\n}\n\n// dims from tensorflow/core/framework/tensor.h:\n  int dims() const { return shape().dims(); } /* <=== tensorflow.Tensor.dims:int()<const> */ \n\n// Update from tensorflow/core/platform/status.cc:\nvoid Status::Update(const Status& new_status) { /* <=== tensorflow.Status.Update:void(tensorflow.Status&) */ \n  if (ok()) {\n    *this = new_status;\n  }\n}\n\n// CHECK_EQ from tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/platform/logging.h:\n\n\n// OP_REQUIRES from tensorflow/core/kernels/rnn/tensorflow/core/framework/tensorflow/core/framework/op_requires.h:\n\n\n// CheckNotInComputeAsync from tensorflow/core/framework/op_kernel.cc:\nvoid CheckNotInComputeAsync(OpKernelContext* ctx, /* <=== tensorflow.CheckNotInComputeAsync:void(tensorflow.OpKernelContext*,char*) */ \n                            const char* correct_macro_name) {\n  CHECK_EQ(nullptr, ctx->params_->op_kernel->AsAsync())\n      << \"Use \" << correct_macro_name << \" in AsyncOpKernel implementations.\";\n}\n\n// ok from tensorflow/core/platform/status.h:\n  bool ok() const { return (state_ == nullptr); } /* <=== tensorflow.Status.ok:bool()<const> */ \n\n// VLOG from tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/platform/logging.h:\n\n\n// OP_REQUIRES_OK from tensorflow/core/kernels/rnn/tensorflow/core/framework/tensorflow/core/framework/op_requires.h:\n\n\n// CtxFailure from tensorflow/core/framework/op_kernel.cc:\nvoid OpKernelContext::CtxFailure(const char* file, int line, const Status& s) { /* <=== tensorflow.OpKernelContext.CtxFailure:void(char*,int,tensorflow.Status&) */ \n  VLOG(1) << \"OP_REQUIRES failed at \" << io::Basename(file) << \":\" << line\n          << \" : \" << s;\n  SetStatus(s);\n}\n"
  },
  {
    "repository": "tensorflow",
    "cve_id": "CVE-2022-29199",
    "cwe_list": [
      "CWE-703"
    ],
    "commit_hash": "3150642acbbe254e3c3c5d2232143fa591855ac9",
    "short_hash": "3150642a",
    "vulnerableMethods_before": [
      {
        "filename": "load_and_remap_matrix_op.cc",
        "method_name": "vulnerable_function",
        "raw_code": "  void Compute(OpKernelContext* context) override {\n    // Checks what we're remapping and inverts the relevant remapping Tensors to\n    // be maps with key = old ID, value = new ID.\n    std::unordered_map<int64_t, int64_t> old_row_to_new_row_map;\n    std::vector<bool> row_id_present;\n    const Tensor* row_remapping_t;\n    OP_REQUIRES_OK(context, context->input(\"row_remapping\", &row_remapping_t));\n    const auto row_remapping = row_remapping_t->vec<int64_t>();\n    OP_REQUIRES(context, row_remapping.size() == num_rows_,\n                errors::InvalidArgument(strings::StrCat(\n                    \"Size of row_remapping is \", row_remapping.size(),\n                    \" instead of being equal to num_rows=\", num_rows_)));\n    OP_REQUIRES_OK(context, RemapVectorToMap(row_remapping, &row_id_present,\n                                             &old_row_to_new_row_map));\n\n    // Calculates the min/max old row ID that we need to read, to save us from\n    // reading some unnecessary slices of the old tensor.\n    int64_t min_old_row = -1;\n    int64_t max_old_row = -1;\n    for (int i = 0; i < row_remapping.size(); ++i) {\n      if (min_old_row < 0 ||\n          (row_remapping(i) >= 0 && row_remapping(i) < min_old_row)) {\n        min_old_row = row_remapping(i);\n      }\n      if (max_old_row < 0 ||\n          (row_remapping(i) >= 0 && row_remapping(i) > max_old_row)) {\n        max_old_row = row_remapping(i);\n      }\n    }\n\n    // Processes the remapping for columns.\n    std::unordered_map<int64_t, int64_t> old_col_to_new_col_map;\n    std::vector<bool> col_id_present;\n    const Tensor* col_remapping_t;\n    OP_REQUIRES_OK(context, context->input(\"col_remapping\", &col_remapping_t));\n    const auto col_remapping = col_remapping_t->vec<int64_t>();\n    // Note that we always \"remap rows\", even when the row vocabulary does\n    // not change, because partitioning requires a mapping from partitioned\n    // Variables to the full checkpoints we load.\n    const bool remap_cols = col_remapping.size() > 0;\n    if (remap_cols) {\n      OP_REQUIRES(\n          context, col_remapping.size() == num_cols_,\n          errors::InvalidArgument(strings::StrCat(\n              \"Provided col_remapping, but its size is \", col_remapping.size(),\n              \" instead of being equal to num_cols=\", num_cols_)));\n      OP_REQUIRES_OK(context, RemapVectorToMap(col_remapping, &col_id_present,\n                                               &old_col_to_new_col_map));\n    } else {\n      col_id_present.clear();\n      col_id_present.resize(num_cols_, true);\n    }\n\n    // Processes the checkpoint source and the provided Tensor name.\n    const Tensor* ckpt_path_t;\n    OP_REQUIRES_OK(context, context->input(\"ckpt_path\", &ckpt_path_t));\n    OP_REQUIRES(\n        context, ckpt_path_t->NumElements() == 1,\n        errors::InvalidArgument(\"The `ckpt_path` tensor must have exactly one \"\n                                \"element, got tensor of shape \",\n                                ckpt_path_t->shape().DebugString()));\n    const string& ckpt_path = ckpt_path_t->scalar<tstring>()();\n    const Tensor* old_tensor_name_t;\n    OP_REQUIRES_OK(context,\n                   context->input(\"old_tensor_name\", &old_tensor_name_t));\n    const string& old_tensor_name = old_tensor_name_t->scalar<tstring>()();\n\n    LOG(INFO) << \"Processing checkpoint : \" << ckpt_path;\n    BundleReader reader(context->env(), ckpt_path);\n    OP_REQUIRES_OK(context, reader.status());\n\n    DataType tensor_type;\n    TensorShape tensor_shape;\n    OP_REQUIRES_OK(context, reader.LookupDtypeAndShape(\n                                old_tensor_name, &tensor_type, &tensor_shape));\n    OP_REQUIRES(context, tensor_type == DT_FLOAT,\n                errors::InvalidArgument(strings::StrCat(\n                    \"Tensor \", old_tensor_name, \" has invalid type \",\n                    DataTypeString(tensor_type), \" instead of expected type \",\n                    DataTypeString(DT_FLOAT))));\n    // This op is limited to loading Tensors of rank 2 (matrices).\n    OP_REQUIRES(\n        context, tensor_shape.dims() == 2,\n        errors::InvalidArgument(strings::StrCat(\n            \"Tensor \", old_tensor_name, \" has shape \",\n            tensor_shape.DebugString(), \" of invalid rank \",\n            tensor_shape.dims(), \" instead of expected shape of rank 2.\")));\n\n    if (!remap_cols) {\n      // TODO(weiho): Consider relaxing this restriction to allow partial column\n      // loading (even when no column remapping is specified) if there turns out\n      // to be a use case for it.\n      OP_REQUIRES(context, num_cols_ == tensor_shape.dim_size(1),\n                  errors::InvalidArgument(strings::StrCat(\n                      \"Tensor \", old_tensor_name, \" has shape \",\n                      tensor_shape.DebugString(),\n                      \", where the size of its 2nd dimension is \",\n                      tensor_shape.dim_size(1),\n                      \" instead of being equal to num_cols=\", num_cols_)));\n    }\n\n    // Uses TensorSlice to potentially load the old tensor in chunks in case\n    // memory usage is a concern.\n    std::vector<TensorSlice> tensor_slices;\n    TensorSlice slice(tensor_shape.dims());\n    if (min_old_row >= 0 && max_old_row >= 0) {\n      int64_t row_start = min_old_row;\n      // TODO(weiho): Given the list of old row IDs of interest (the keys of\n      // old_row_to_new_row_map), we could also try something smarter to\n      // find some minimal set of covering ranges for the list of old row IDs\n      // such that the size of each range is less than max_rows_in_memory_.\n      while (row_start <= max_old_row) {\n        const int64_t slice_length =\n            max_rows_in_memory_ <= 0\n                // If max_rows_in_memory_ <= 0, we just load the entire chunk.\n                ? max_old_row - row_start + 1\n                : std::min(max_rows_in_memory_, max_old_row - row_start + 1);\n        slice.set_start(0, row_start);\n        slice.set_length(0, slice_length);\n        tensor_slices.push_back(slice);\n        row_start += slice_length;\n      }\n    }\n\n    // Allocates the output matrix.\n    Tensor* output_matrix_t = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(\"output_matrix\",\n                                            TensorShape({num_rows_, num_cols_}),\n                                            &output_matrix_t));\n    auto output_matrix = output_matrix_t->matrix<float>();\n\n    // Iterates through tensor slices and copies over values from the old tensor\n    // to the output matrix.\n    int64_t row_index = min_old_row;\n    int64_t rows_copied = 0;\n    Tensor loaded_tensor_t;\n    for (const TensorSlice& tensor_slice : tensor_slices) {\n      LOG(INFO) << \"Loading slice \" << tensor_slice.DebugString();\n      TensorShape slice_shape;\n      OP_REQUIRES_OK(context,\n                     tensor_slice.SliceTensorShape(tensor_shape, &slice_shape));\n      // Potentially re-allocates the tensor buffer since the last slice may\n      // have fewer rows than the other slices.\n      if (loaded_tensor_t.shape() != slice_shape) {\n        loaded_tensor_t = Tensor(DT_FLOAT, slice_shape);\n      }\n      OP_REQUIRES_OK(context, reader.LookupSlice(old_tensor_name, tensor_slice,\n                                                 &loaded_tensor_t));\n\n      // Iterates through the old loaded tensor slice row-by-row.\n      for (int row = 0; row < loaded_tensor_t.dim_size(0); ++row, ++row_index) {\n        if (row_index % 500000 == min_old_row) {\n          LOG(INFO) << \"Processing old row \" << row_index;\n        }\n\n        // If the old row ID is not found in old_row_to_new_row_map, continue\n        // to the next row; otherwise, copy it to the output matrix.\n        const int64_t* new_row_ptr =\n            gtl::FindOrNull(old_row_to_new_row_map, row_index);\n        if (new_row_ptr == nullptr) {\n          continue;\n        }\n        ++rows_copied;\n        const int64_t new_row = *new_row_ptr;\n\n        // Copies over the row element-by-element, in case remapping is needed\n        // along the column axis.\n        const auto& loaded_tensor = loaded_tensor_t.matrix<float>();\n        for (int old_col = 0; old_col < loaded_tensor_t.dim_size(1);\n             ++old_col) {\n          int64_t new_col = old_col;\n          if (remap_cols) {\n            const int64_t* new_col_ptr =\n                gtl::FindOrNull(old_col_to_new_col_map, old_col);\n            if (new_col_ptr == nullptr) {\n              // Column remapping is specified, but this column is not found in\n              // old_col_to_new_col_map, so we leave it uninitialized, to be\n              // filled in with initializing_values later.\n              continue;\n            }\n            new_col = *new_col_ptr;\n          }\n\n          OP_REQUIRES(context,\n                      new_row < num_rows_ && new_col < num_cols_ &&\n                          new_row >= 0 && new_col >= 0,\n                      errors::Internal(strings::StrCat(\n                          \"new_row=\", new_row, \" and new_col=\", new_col,\n                          \" should have been less than num_rows_=\", num_rows_,\n                          \" and num_cols_=\", num_cols_,\n                          \" and non-negative. This should never have happened \"\n                          \"if the code were correct. Please file a bug.\")));\n          output_matrix(new_row, new_col) = loaded_tensor(row, old_col);\n        }\n      }\n    }\n    LOG(INFO) << \"Copied \" << rows_copied << \" rows from old matrix (with \"\n              << tensor_shape.dim_size(0) << \" rows) to new matrix (with \"\n              << num_rows_ << \" rows).\";\n\n    // At this point, there are potentially whole rows/columns uninitialized\n    // (corresponding to the indices where row_id_present/col_id_present are\n    // false). We fill this in cell-by-cell using row_id_present and\n    // col_id_present while dequeuing from the initializing_values vector.\n    const Tensor* initializing_values_t;\n    OP_REQUIRES_OK(\n        context, context->input(\"initializing_values\", &initializing_values_t));\n    const auto initializing_values = initializing_values_t->flat<float>();\n    int64_t initializing_values_index = 0;\n    for (int i = 0; i < num_rows_; ++i) {\n      for (int j = 0; j < num_cols_; ++j) {\n        if (row_id_present[i] && col_id_present[j]) continue;\n        OP_REQUIRES(\n            context, initializing_values_index < initializing_values.size(),\n            errors::InvalidArgument(\n                \"initializing_values contained \", initializing_values.size(),\n                \" elements, but more missing values remain.\"));\n        output_matrix(i, j) = initializing_values(initializing_values_index);\n        ++initializing_values_index;\n      }\n    }\n\n    // Checks that we used all the given initializing values.\n    OP_REQUIRES(\n        context, initializing_values_index == initializing_values.size(),\n        errors::InvalidArgument(\n            \"initializing_values contained \", initializing_values.size(),\n            \" elements, but only \", initializing_values_index,\n            \" elements were used to fill in missing values.\"));\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "load_and_remap_matrix_op.cc",
        "method_name": "fixed_function",
        "raw_code": "  void Compute(OpKernelContext* context) override {\n    // Checks what we're remapping and inverts the relevant remapping Tensors to\n    // be maps with key = old ID, value = new ID.\n    std::unordered_map<int64_t, int64_t> old_row_to_new_row_map;\n    std::vector<bool> row_id_present;\n    const Tensor* row_remapping_t;\n    OP_REQUIRES_OK(context, context->input(\"row_remapping\", &row_remapping_t));\n    OP_REQUIRES(\n        context, row_remapping_t->dims() == 1,\n        errors::InvalidArgument(\"The `row_remapping` tensor must be 1-D, got \"\n                                \"a tensor of shape \",\n                                row_remapping_t->shape().DebugString()));\n    const auto row_remapping = row_remapping_t->vec<int64_t>();\n    OP_REQUIRES(context, row_remapping.size() == num_rows_,\n                errors::InvalidArgument(strings::StrCat(\n                    \"Size of row_remapping is \", row_remapping.size(),\n                    \" instead of being equal to num_rows=\", num_rows_)));\n    OP_REQUIRES_OK(context, RemapVectorToMap(row_remapping, &row_id_present,\n                                             &old_row_to_new_row_map));\n\n    // Calculates the min/max old row ID that we need to read, to save us from\n    // reading some unnecessary slices of the old tensor.\n    int64_t min_old_row = -1;\n    int64_t max_old_row = -1;\n    for (int i = 0; i < row_remapping.size(); ++i) {\n      if (min_old_row < 0 ||\n          (row_remapping(i) >= 0 && row_remapping(i) < min_old_row)) {\n        min_old_row = row_remapping(i);\n      }\n      if (max_old_row < 0 ||\n          (row_remapping(i) >= 0 && row_remapping(i) > max_old_row)) {\n        max_old_row = row_remapping(i);\n      }\n    }\n\n    // Processes the remapping for columns.\n    std::unordered_map<int64_t, int64_t> old_col_to_new_col_map;\n    std::vector<bool> col_id_present;\n    const Tensor* col_remapping_t;\n    OP_REQUIRES_OK(context, context->input(\"col_remapping\", &col_remapping_t));\n    const auto col_remapping = col_remapping_t->vec<int64_t>();\n    // Note that we always \"remap rows\", even when the row vocabulary does\n    // not change, because partitioning requires a mapping from partitioned\n    // Variables to the full checkpoints we load.\n    const bool remap_cols = col_remapping.size() > 0;\n    if (remap_cols) {\n      OP_REQUIRES(\n          context, col_remapping.size() == num_cols_,\n          errors::InvalidArgument(strings::StrCat(\n              \"Provided col_remapping, but its size is \", col_remapping.size(),\n              \" instead of being equal to num_cols=\", num_cols_)));\n      OP_REQUIRES_OK(context, RemapVectorToMap(col_remapping, &col_id_present,\n                                               &old_col_to_new_col_map));\n    } else {\n      col_id_present.clear();\n      col_id_present.resize(num_cols_, true);\n    }\n\n    // Processes the checkpoint source and the provided Tensor name.\n    const Tensor* ckpt_path_t;\n    OP_REQUIRES_OK(context, context->input(\"ckpt_path\", &ckpt_path_t));\n    OP_REQUIRES(\n        context, ckpt_path_t->NumElements() == 1,\n        errors::InvalidArgument(\"The `ckpt_path` tensor must have exactly one \"\n                                \"element, got tensor of shape \",\n                                ckpt_path_t->shape().DebugString()));\n    const string& ckpt_path = ckpt_path_t->scalar<tstring>()();\n    const Tensor* old_tensor_name_t;\n    OP_REQUIRES_OK(context,\n                   context->input(\"old_tensor_name\", &old_tensor_name_t));\n    const string& old_tensor_name = old_tensor_name_t->scalar<tstring>()();\n\n    LOG(INFO) << \"Processing checkpoint : \" << ckpt_path;\n    BundleReader reader(context->env(), ckpt_path);\n    OP_REQUIRES_OK(context, reader.status());\n\n    DataType tensor_type;\n    TensorShape tensor_shape;\n    OP_REQUIRES_OK(context, reader.LookupDtypeAndShape(\n                                old_tensor_name, &tensor_type, &tensor_shape));\n    OP_REQUIRES(context, tensor_type == DT_FLOAT,\n                errors::InvalidArgument(strings::StrCat(\n                    \"Tensor \", old_tensor_name, \" has invalid type \",\n                    DataTypeString(tensor_type), \" instead of expected type \",\n                    DataTypeString(DT_FLOAT))));\n    // This op is limited to loading Tensors of rank 2 (matrices).\n    OP_REQUIRES(\n        context, tensor_shape.dims() == 2,\n        errors::InvalidArgument(strings::StrCat(\n            \"Tensor \", old_tensor_name, \" has shape \",\n            tensor_shape.DebugString(), \" of invalid rank \",\n            tensor_shape.dims(), \" instead of expected shape of rank 2.\")));\n\n    if (!remap_cols) {\n      // TODO(weiho): Consider relaxing this restriction to allow partial column\n      // loading (even when no column remapping is specified) if there turns out\n      // to be a use case for it.\n      OP_REQUIRES(context, num_cols_ == tensor_shape.dim_size(1),\n                  errors::InvalidArgument(strings::StrCat(\n                      \"Tensor \", old_tensor_name, \" has shape \",\n                      tensor_shape.DebugString(),\n                      \", where the size of its 2nd dimension is \",\n                      tensor_shape.dim_size(1),\n                      \" instead of being equal to num_cols=\", num_cols_)));\n    }\n\n    // Uses TensorSlice to potentially load the old tensor in chunks in case\n    // memory usage is a concern.\n    std::vector<TensorSlice> tensor_slices;\n    TensorSlice slice(tensor_shape.dims());\n    if (min_old_row >= 0 && max_old_row >= 0) {\n      int64_t row_start = min_old_row;\n      // TODO(weiho): Given the list of old row IDs of interest (the keys of\n      // old_row_to_new_row_map), we could also try something smarter to\n      // find some minimal set of covering ranges for the list of old row IDs\n      // such that the size of each range is less than max_rows_in_memory_.\n      while (row_start <= max_old_row) {\n        const int64_t slice_length =\n            max_rows_in_memory_ <= 0\n                // If max_rows_in_memory_ <= 0, we just load the entire chunk.\n                ? max_old_row - row_start + 1\n                : std::min(max_rows_in_memory_, max_old_row - row_start + 1);\n        slice.set_start(0, row_start);\n        slice.set_length(0, slice_length);\n        tensor_slices.push_back(slice);\n        row_start += slice_length;\n      }\n    }\n\n    // Allocates the output matrix.\n    Tensor* output_matrix_t = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(\"output_matrix\",\n                                            TensorShape({num_rows_, num_cols_}),\n                                            &output_matrix_t));\n    auto output_matrix = output_matrix_t->matrix<float>();\n\n    // Iterates through tensor slices and copies over values from the old tensor\n    // to the output matrix.\n    int64_t row_index = min_old_row;\n    int64_t rows_copied = 0;\n    Tensor loaded_tensor_t;\n    for (const TensorSlice& tensor_slice : tensor_slices) {\n      LOG(INFO) << \"Loading slice \" << tensor_slice.DebugString();\n      TensorShape slice_shape;\n      OP_REQUIRES_OK(context,\n                     tensor_slice.SliceTensorShape(tensor_shape, &slice_shape));\n      // Potentially re-allocates the tensor buffer since the last slice may\n      // have fewer rows than the other slices.\n      if (loaded_tensor_t.shape() != slice_shape) {\n        loaded_tensor_t = Tensor(DT_FLOAT, slice_shape);\n      }\n      OP_REQUIRES_OK(context, reader.LookupSlice(old_tensor_name, tensor_slice,\n                                                 &loaded_tensor_t));\n\n      // Iterates through the old loaded tensor slice row-by-row.\n      for (int row = 0; row < loaded_tensor_t.dim_size(0); ++row, ++row_index) {\n        if (row_index % 500000 == min_old_row) {\n          LOG(INFO) << \"Processing old row \" << row_index;\n        }\n\n        // If the old row ID is not found in old_row_to_new_row_map, continue\n        // to the next row; otherwise, copy it to the output matrix.\n        const int64_t* new_row_ptr =\n            gtl::FindOrNull(old_row_to_new_row_map, row_index);\n        if (new_row_ptr == nullptr) {\n          continue;\n        }\n        ++rows_copied;\n        const int64_t new_row = *new_row_ptr;\n\n        // Copies over the row element-by-element, in case remapping is needed\n        // along the column axis.\n        const auto& loaded_tensor = loaded_tensor_t.matrix<float>();\n        for (int old_col = 0; old_col < loaded_tensor_t.dim_size(1);\n             ++old_col) {\n          int64_t new_col = old_col;\n          if (remap_cols) {\n            const int64_t* new_col_ptr =\n                gtl::FindOrNull(old_col_to_new_col_map, old_col);\n            if (new_col_ptr == nullptr) {\n              // Column remapping is specified, but this column is not found in\n              // old_col_to_new_col_map, so we leave it uninitialized, to be\n              // filled in with initializing_values later.\n              continue;\n            }\n            new_col = *new_col_ptr;\n          }\n\n          OP_REQUIRES(context,\n                      new_row < num_rows_ && new_col < num_cols_ &&\n                          new_row >= 0 && new_col >= 0,\n                      errors::Internal(strings::StrCat(\n                          \"new_row=\", new_row, \" and new_col=\", new_col,\n                          \" should have been less than num_rows_=\", num_rows_,\n                          \" and num_cols_=\", num_cols_,\n                          \" and non-negative. This should never have happened \"\n                          \"if the code were correct. Please file a bug.\")));\n          output_matrix(new_row, new_col) = loaded_tensor(row, old_col);\n        }\n      }\n    }\n    LOG(INFO) << \"Copied \" << rows_copied << \" rows from old matrix (with \"\n              << tensor_shape.dim_size(0) << \" rows) to new matrix (with \"\n              << num_rows_ << \" rows).\";\n\n    // At this point, there are potentially whole rows/columns uninitialized\n    // (corresponding to the indices where row_id_present/col_id_present are\n    // false). We fill this in cell-by-cell using row_id_present and\n    // col_id_present while dequeuing from the initializing_values vector.\n    const Tensor* initializing_values_t;\n    OP_REQUIRES_OK(\n        context, context->input(\"initializing_values\", &initializing_values_t));\n    const auto initializing_values = initializing_values_t->flat<float>();\n    int64_t initializing_values_index = 0;\n    for (int i = 0; i < num_rows_; ++i) {\n      for (int j = 0; j < num_cols_; ++j) {\n        if (row_id_present[i] && col_id_present[j]) continue;\n        OP_REQUIRES(\n            context, initializing_values_index < initializing_values.size(),\n            errors::InvalidArgument(\n                \"initializing_values contained \", initializing_values.size(),\n                \" elements, but more missing values remain.\"));\n        output_matrix(i, j) = initializing_values(initializing_values_index);\n        ++initializing_values_index;\n      }\n    }\n\n    // Checks that we used all the given initializing values.\n    OP_REQUIRES(\n        context, initializing_values_index == initializing_values.size(),\n        errors::InvalidArgument(\n            \"initializing_values contained \", initializing_values.size(),\n            \" elements, but only \", initializing_values_index,\n            \" elements were used to fill in missing values.\"));\n  }",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <unordered_map>\n#include <algorithm>\n#include \"tensorflow/core/framework/tensor_types.h\"\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include <string>\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/lib/gtl/map_util.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/kernel_def_builder.h\"\n#include \"tensorflow/core/util/tensor_bundle/tensor_bundle.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include <vector>\n\n// Type Definitions:\n// TensorSlice:\nclass TensorSlice {\n public:\n  // Construct a tensor slice: you have a number of ways:\n  // -- creating an empty slice\n  // -- from just a dimension (in this case it will create a full slice)\n  // -- from an array of pairs of integers.\n  // -- from a TensorSliceProto protocol buffer\n  // -- from a string format of \"start,length:start,length...\" where each\n  //    \"start,length\" pair represents the slice on one dimension. We allow a\n  //    special \"-\" that means \"everything for this dimension\". One such example\n  //    is:  0,10:-:14,1:-:-\n  TensorSlice() {}\n  explicit TensorSlice(int dim);\n  explicit TensorSlice(const TensorSliceProto& proto);\n  explicit TensorSlice(\n      std::initializer_list<std::pair<int64_t, int64_t>> extents);\n\n  // This factory methods should be used instead of the constructor that takes a\n  // `TensorSliceProto` if calling code cannot validate that the sizes specify a\n  // valid `TensorSlice`.\n  static Status BuildTensorSlice(const TensorSliceProto& proto,\n...\n\n// Status:\nclass Status {\n public:\n  /// Create a success status.\n  Status() {}\n\n  /// \\brief Create a status with the specified error code and msg as a\n  /// human-readable string containing more detailed information.\n  Status(tensorflow::error::Code code, tensorflow::StringPiece msg)\n      : Status(code, msg, {}) {}\n\n  /// \\brief Create a status with the specified error code, msg, and stack trace\n  /// as a human-readable string containing more detailed information.\n#ifndef SWIG\n  Status(tensorflow::error::Code code, tensorflow::StringPiece msg,\n         std::vector<StackFrame>&& stack_trace);\n#endif\n\n  /// Copy the specified status.\n  Status(const Status& s);\n  Status& operator=(const Status& s);\n#ifndef SWIG\n  Status(Status&& s) noexcept;\n  Status& operator=(Status&& s) noexcept;\n#endif  // SWIG\n\n  static Status OK() { return Status(); }\n\n  /// Returns true iff the status indicates success.\n  bool ok() const { return (state_ == nullptr); }\n\n  tensorflow::error::Code code() const {\n    retu...\n\n// DataType:\ntensorflow.TensorHandle.DataType:DataType()<const>\n\n// OpKernelContext:\nclass OpKernelContext {\n public:\n  // The first element of a WrappedAllocator is a \"base\" Allocator and\n  // the second element is that Allocator wrapped by a\n  // TrackingAllocator\n  typedef std::pair<Allocator*, TrackingAllocator*> WrappedAllocator;\n\n  // TODO(zhifengc): Do some cleanup of Params.\n  // The Params struct is passed in to initialize an OpKernelContext,\n  // and must outlive the OpKernelContext.\n  struct Params {\n    ~Params() { delete eigen_gpu_device; }\n\n    // The step being executed.\n    int64_t step_id = 0;\n\n    // Timestamp for the start of graph execution. Used for latency metrics.\n    int64_t start_time_usecs = 0;\n\n    // The deadline for the session to complete by. Empty if unspecified.\n    absl::optional<absl::Time> deadline;\n\n    // The op kernel being computed.\n    OpKernel* op_kernel = nullptr;\n\n    // The device on which the kernel is running.\n    DeviceBase* device = nullptr;\n\n    // The Eigen GPU device wrapper, which may include a per-op\n    // wrappe...\n\n// TensorShape:\nclass TensorShape : public TensorShapeBase<TensorShape> {\n public:\n  using TensorShapeBase<TensorShape>::TensorShapeBase;\n\n  // These factory methods should be used instead of the constructors that take\n  // an array of sizes if calling code cannot validate that the sizes specify a\n  // valid `TensorShape`.\n  // The value in `*out` is valid iff the returned value is `Status::OK`.\n  static Status BuildTensorShape(gtl::ArraySlice<int64_t> dim_sizes,\n                                 TensorShape* out) {\n    return BuildTensorShapeBase(dim_sizes, out);\n  }\n  static Status BuildTensorShape(std::initializer_list<int64_t> dim_sizes,\n                                 TensorShape* out) {\n    return BuildTensorShape(gtl::ArraySlice<int64_t>(dim_sizes), out);\n  }\n  static Status BuildTensorShape(const TensorShapeProto& proto,\n                                 TensorShape* out) {\n    return BuildTensorShapeBase(proto, out);\n  }\n\n  static StatusOr<TensorShape> BuildTensorShape(const TensorShapeProt...\n\n// Status:\nclass Status\n\n// Tensor:\nclass Tensor {\n public:\n  /// \\brief Creates a 1-dimensional, 0-element float tensor.\n  ///\n  /// The returned Tensor is not a scalar (shape {}), but is instead\n  /// an empty one-dimensional Tensor (shape {0}, NumElements() ==\n  /// 0). Since it has no elements, it does not need to be assigned a\n  /// value and is initialized by default (IsInitialized() is\n  /// true). If this is undesirable, consider creating a one-element\n  /// scalar which does require initialization:\n  ///\n  /// ```c++\n  ///\n  ///     Tensor(DT_FLOAT, TensorShape({}))\n  ///\n  /// ```\n  Tensor();\n\n  /// \\brief Creates a Tensor of the given `type` and `shape`.  If\n  /// LogMemory::IsEnabled() the allocation is logged as coming from\n  /// an unknown kernel and step. Calling the Tensor constructor\n  /// directly from within an Op is deprecated: use the\n  /// OpKernelConstruction/OpKernelContext allocate_* methods to\n  /// allocate a new tensor, which record the kernel and step.\n  ///\n  /// The underlying buffer is ...\n\n// Env:\nclass Env {\n public:\n  Env();\n  virtual ~Env() = default;\n\n  /// \\brief Returns a default environment suitable for the current operating\n  /// system.\n  ///\n  /// Sophisticated users may wish to provide their own Env\n  /// implementation instead of relying on this default environment.\n  ///\n  /// The result of Default() belongs to this library and must never be deleted.\n  static Env* Default();\n\n  /// \\brief Returns the FileSystem object to handle operations on the file\n  /// specified by 'fname'. The FileSystem object is used as the implementation\n  /// for the file system related (non-virtual) functions that follow.\n  /// Returned FileSystem object is still owned by the Env object and will\n  // (might) be destroyed when the environment is destroyed.\n  virtual Status GetFileSystemForFile(const std::string& fname,\n                                      FileSystem** result);\n\n  /// \\brief Returns the file system schemes registered for this Env.\n  virtual Status GetRegisteredFileSystem...\n\n// iterator:\nclass iterator {\n   public:\n    typedef ssize_t difference_type;\n    typedef T value_type;\n    typedef const T* pointer;\n    typedef const T& reference;\n    typedef ::std::forward_iterator_tag iterator_category;\n\n    explicit iterator(uintptr_t rep)\n        : bigrep_(false), single_(reinterpret_cast<T>(rep)) {}\n    explicit iterator(typename BigRep::iterator iter)\n        : bigrep_(true), single_(nullptr), iter_(iter) {}\n\n    iterator& operator++() {\n      if (bigrep_) {\n        ++iter_;\n      } else {\n        DCHECK(single_ != nullptr);\n        single_ = nullptr;\n      }\n      return *this;\n    }\n    // maybe post-increment?\n\n    bool operator==(const iterator& other) const {\n      if (bigrep_) {\n        return iter_ == other.iter_;\n      } else {\n        return single_ == other.single_;\n      }\n    }\n    bool operator!=(const iterator& other) const { return !(*this == other); }\n\n    const T& operator*() const {\n      if (bigrep_) {\n        return *iter_;\n      } else {\n        DCH...\n\n// Tensor:\ntensorflow.TensorHandle.Tensor:tensorflow.Status(tensorflow.Tensor**)<const>\n\n// OpKernelContext:\ntensorflow.OpKernelContext.OpKernelContext:ANY(tensorflow.OpKernelContext.Params*)\n\n// LoadAndRemapMatrixOp:\nclass LoadAndRemapMatrixOp : public OpKernel {\n public:\n  explicit LoadAndRemapMatrixOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_rows\", &num_rows_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_cols\", &num_cols_));\n    OP_REQUIRES_OK(\n        context, context->GetAttr(\"max_rows_in_memory\", &max_rows_in_memory_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    // Checks what we're remapping and inverts the relevant remapping Tensors to\n    // be maps with key = old ID, value = new ID.\n    std::unordered_map<int64_t, int64_t> old_row_to_new_row_map;\n    std::vector<bool> row_id_present;\n    const Tensor* row_remapping_t;\n    OP_REQUIRES_OK(context, context->input(\"row_remapping\", &row_remapping_t));\n    OP_REQUIRES(\n        context, row_remapping_t->dims() == 1,\n        errors::InvalidArgument(\"The `row_remapping` tensor must be 1-D, got \"\n                                \"a tensor of shape \",\n     ...\n\n// Called Methods (top 10):\n// dims from tensorflow/core/framework/tensor.h:\n  int dims() const { return shape().dims(); } /* <=== tensorflow.Tensor.dims:int()<const> */ \n\n// env from tensorflow/core/framework/device_base.h:\n  Env* env() const { return env_; } /* <=== tensorflow.DeviceBase.env:tensorflow.Env*()<const> */ \n\n// LOG from tensorflow/core/kernels/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/platform/logging.h:\n\n\n// SetStatus from tensorflow/core/framework/op_kernel.cc:\nvoid OpKernelConstruction::SetStatus(const Status& status) { /* <=== tensorflow.OpKernelConstruction.SetStatus:void(tensorflow.Status&) */ \n  status_->Update(status);\n}\n\n// Update from tensorflow/core/platform/status.cc:\nvoid Status::Update(const Status& new_status) { /* <=== tensorflow.Status.Update:void(tensorflow.Status&) */ \n  if (ok()) {\n    *this = new_status;\n  }\n}\n\n// shape from tensorflow/core/framework/tensor.h:\n  const TensorShape& shape() const { return shape_; } /* <=== tensorflow.Tensor.shape:tensorflow.TensorShape&()<const> */ \n\n// CHECK_EQ from tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/platform/logging.h:\n\n\n// LOG from tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/platform/logging.h:\n\n\n// CheckNotInComputeAsync from tensorflow/core/framework/op_kernel.cc:\nvoid CheckNotInComputeAsync(OpKernelContext* ctx, /* <=== tensorflow.CheckNotInComputeAsync:void(tensorflow.OpKernelContext*,char*) */ \n                            const char* correct_macro_name) {\n  CHECK_EQ(nullptr, ctx->params_->op_kernel->AsAsync())\n      << \"Use \" << correct_macro_name << \" in AsyncOpKernel implementations.\";\n}\n\n// CtxFailureWithWarning from tensorflow/core/framework/op_kernel.cc:\nvoid OpKernelContext::CtxFailureWithWarning(const char* file, int line, /* <=== tensorflow.OpKernelContext.CtxFailureWithWarning:void(char*,int,tensorflow.Status&) */ \n                                            const Status& s) {\n  LOG(WARNING) << \"OP_REQUIRES failed at \" << io::Basename(file) << \":\" << line\n               << \" : \" << s;\n  SetStatus(s);\n}\n"
  },
  {
    "repository": "tensorflow",
    "cve_id": "CVE-2021-37651",
    "cwe_list": [
      "CWE-476"
    ],
    "commit_hash": "0f931751fb20f565c4e94aa6df58d54a003cdb30",
    "short_hash": "0f931751",
    "vulnerableMethods_before": [
      {
        "filename": "fractional_avg_pool_op.cc",
        "method_name": "vulnerable_function",
        "raw_code": "  void Compute(OpKernelContext* context) override {\n    // Here's the basic idea:\n    // Batch and depth dimension are independent from row and col dimension. And\n    // because FractionalAvgPool currently only support pooling along row and\n    // col, we can basically think of this 4D tensor backpropagation as\n    // operation of a series of 2D planes.\n    //\n    // For each element of a 'slice' (2D plane) of output_backprop, we need to\n    // figure out its contributors when doing FractionalAvgPool operation. This\n    // can be done based on row_pooling_sequence, col_pooling_seq and\n    // overlapping.\n    // Once we figure out the original contributors, we just need to evenly\n    // divide the value of this element among these contributors.\n    //\n    // Internally, we divide the out_backprop tensor and store it in a temporary\n    // tensor of double type. And cast it to the corresponding type.\n    typedef Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>\n        ConstEigenMatrixMap;\n    typedef Eigen::Map<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>>\n        EigenDoubleMatrixMap;\n\n    // Grab the inputs.\n    const Tensor& orig_input_tensor_shape = context->input(0);\n    OP_REQUIRES(context,\n                orig_input_tensor_shape.dims() == 1 &&\n                    orig_input_tensor_shape.NumElements() == 4,\n                errors::InvalidArgument(\"original input tensor shape must be\"\n                                        \"1-dimensional and 4 elements\"));\n    const Tensor& out_backprop = context->input(1);\n    const Tensor& row_seq_tensor = context->input(2);\n    const Tensor& col_seq_tensor = context->input(3);\n\n    const int64_t out_batch = out_backprop.dim_size(0);\n    const int64_t out_rows = out_backprop.dim_size(1);\n    const int64_t out_cols = out_backprop.dim_size(2);\n    const int64_t out_depth = out_backprop.dim_size(3);\n\n    OP_REQUIRES(context, row_seq_tensor.NumElements() > out_rows,\n                errors::InvalidArgument(\"Given out_backprop shape \",\n                                        out_backprop.shape().DebugString(),\n                                        \", row_seq_tensor must have at least \",\n                                        out_rows + 1, \" elements, but got \",\n                                        row_seq_tensor.NumElements()));\n    OP_REQUIRES(context, col_seq_tensor.NumElements() > out_cols,\n                errors::InvalidArgument(\"Given out_backprop shape \",\n                                        out_backprop.shape().DebugString(),\n                                        \", col_seq_tensor must have at least \",\n                                        out_cols + 1, \" elements, but got \",\n                                        col_seq_tensor.NumElements()));\n\n    auto row_seq_tensor_flat = row_seq_tensor.flat<int64>();\n    auto col_seq_tensor_flat = col_seq_tensor.flat<int64>();\n    auto orig_input_tensor_shape_flat = orig_input_tensor_shape.flat<int64>();\n\n    const int64_t in_batch = orig_input_tensor_shape_flat(0);\n    const int64_t in_rows = orig_input_tensor_shape_flat(1);\n    const int64_t in_cols = orig_input_tensor_shape_flat(2);\n    const int64_t in_depth = orig_input_tensor_shape_flat(3);\n\n    constexpr int tensor_in_and_out_dims = 4;\n    // Transform orig_input_tensor_shape into TensorShape\n    TensorShape in_shape;\n    for (auto i = 0; i < tensor_in_and_out_dims; ++i) {\n      in_shape.AddDim(orig_input_tensor_shape_flat(i));\n    }\n\n    // Create intermediate in_backprop.\n    Tensor in_backprop_tensor_temp;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_temp(\n                                {0}, DataTypeToEnum<double>::v(), in_shape,\n                                &in_backprop_tensor_temp));\n    in_backprop_tensor_temp.flat<double>().setZero();\n    // Transform 4D tensor to 2D matrix.\n    EigenDoubleMatrixMap in_backprop_tensor_temp_mat(\n        in_backprop_tensor_temp.flat<double>().data(), in_depth,\n        in_cols * in_rows * in_batch);\n    ConstEigenMatrixMap out_backprop_mat(out_backprop.flat<T>().data(),\n                                         out_depth,\n                                         out_cols * out_rows * out_batch);\n    // Loop through each element of out_backprop and evenly distribute the\n    // element to the corresponding pooling cell.\n    const int64_t in_max_row_index = in_rows - 1;\n    const int64_t in_max_col_index = in_cols - 1;\n    for (int64_t b = 0; b < out_batch; ++b) {\n      for (int64_t r = 0; r < out_rows; ++r) {\n        const int64_t in_row_start = row_seq_tensor_flat(r);\n        int64_t in_row_end = overlapping_ ? row_seq_tensor_flat(r + 1)\n                                          : row_seq_tensor_flat(r + 1) - 1;\n        in_row_end = std::min(in_row_end, in_max_row_index);\n        for (int64_t c = 0; c < out_cols; ++c) {\n          const int64_t in_col_start = col_seq_tensor_flat(c);\n          int64_t in_col_end = overlapping_ ? col_seq_tensor_flat(c + 1)\n                                            : col_seq_tensor_flat(c + 1) - 1;\n          in_col_end = std::min(in_col_end, in_max_col_index);\n\n          const int64_t num_elements_in_pooling_cell =\n              (in_row_end - in_row_start + 1) * (in_col_end - in_col_start + 1);\n          const int64_t out_index = (b * out_rows + r) * out_cols + c;\n          // Now we can evenly distribute out_backprop(b, h, w, *) to\n          // in_backprop(b, hs:he, ws:we, *).\n          for (int64_t in_r = in_row_start; in_r <= in_row_end; ++in_r) {\n            for (int64_t in_c = in_col_start; in_c <= in_col_end; ++in_c) {\n              const int64_t in_index = (b * in_rows + in_r) * in_cols + in_c;\n              // Walk through each channel (depth).\n              for (int64_t d = 0; d < out_depth; ++d) {\n                const double out_backprop_element = static_cast<double>(\n                    out_backprop_mat.coeffRef(d, out_index));\n                double& in_backprop_ref =\n                    in_backprop_tensor_temp_mat.coeffRef(d, in_index);\n                in_backprop_ref +=\n                    out_backprop_element / num_elements_in_pooling_cell;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Depending on the type, cast double to type T.\n    Tensor* in_backprop_tensor = nullptr;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                {0}, 0, in_shape, &in_backprop_tensor));\n    auto in_backprop_tensor_flat = in_backprop_tensor->flat<T>();\n    auto in_backprop_tensor_temp_flat = in_backprop_tensor_temp.flat<double>();\n    for (int64_t i = 0; i < in_backprop_tensor_flat.size(); ++i) {\n      in_backprop_tensor_flat(i) =\n          static_cast<T>(in_backprop_tensor_temp_flat(i));\n    }\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "fractional_avg_pool_op.cc",
        "method_name": "fixed_function",
        "raw_code": "  void Compute(OpKernelContext* context) override {\n    // Here's the basic idea:\n    // Batch and depth dimension are independent from row and col dimension. And\n    // because FractionalAvgPool currently only support pooling along row and\n    // col, we can basically think of this 4D tensor backpropagation as\n    // operation of a series of 2D planes.\n    //\n    // For each element of a 'slice' (2D plane) of output_backprop, we need to\n    // figure out its contributors when doing FractionalAvgPool operation. This\n    // can be done based on row_pooling_sequence, col_pooling_seq and\n    // overlapping.\n    // Once we figure out the original contributors, we just need to evenly\n    // divide the value of this element among these contributors.\n    //\n    // Internally, we divide the out_backprop tensor and store it in a temporary\n    // tensor of double type. And cast it to the corresponding type.\n    typedef Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>\n        ConstEigenMatrixMap;\n    typedef Eigen::Map<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>>\n        EigenDoubleMatrixMap;\n\n    // Grab the inputs.\n    const Tensor& orig_input_tensor_shape = context->input(0);\n    OP_REQUIRES(context,\n                orig_input_tensor_shape.dims() == 1 &&\n                    orig_input_tensor_shape.NumElements() == 4,\n                errors::InvalidArgument(\"original input tensor shape must be\"\n                                        \"1-dimensional and 4 elements\"));\n    const Tensor& out_backprop = context->input(1);\n    const Tensor& row_seq_tensor = context->input(2);\n    const Tensor& col_seq_tensor = context->input(3);\n\n    const int64_t out_batch = out_backprop.dim_size(0);\n    const int64_t out_rows = out_backprop.dim_size(1);\n    const int64_t out_cols = out_backprop.dim_size(2);\n    const int64_t out_depth = out_backprop.dim_size(3);\n\n    OP_REQUIRES(context, row_seq_tensor.NumElements() > out_rows,\n                errors::InvalidArgument(\"Given out_backprop shape \",\n                                        out_backprop.shape().DebugString(),\n                                        \", row_seq_tensor must have at least \",\n                                        out_rows + 1, \" elements, but got \",\n                                        row_seq_tensor.NumElements()));\n    OP_REQUIRES(context, col_seq_tensor.NumElements() > out_cols,\n                errors::InvalidArgument(\"Given out_backprop shape \",\n                                        out_backprop.shape().DebugString(),\n                                        \", col_seq_tensor must have at least \",\n                                        out_cols + 1, \" elements, but got \",\n                                        col_seq_tensor.NumElements()));\n\n    auto row_seq_tensor_flat = row_seq_tensor.flat<int64>();\n    auto col_seq_tensor_flat = col_seq_tensor.flat<int64>();\n    auto orig_input_tensor_shape_flat = orig_input_tensor_shape.flat<int64>();\n\n    const int64_t in_batch = orig_input_tensor_shape_flat(0);\n    const int64_t in_rows = orig_input_tensor_shape_flat(1);\n    const int64_t in_cols = orig_input_tensor_shape_flat(2);\n    const int64_t in_depth = orig_input_tensor_shape_flat(3);\n    OP_REQUIRES(\n        context, in_batch != 0,\n        errors::InvalidArgument(\"Batch dimension of input must not be 0\"));\n    OP_REQUIRES(\n        context, in_rows != 0,\n        errors::InvalidArgument(\"Rows dimension of input must not be 0\"));\n    OP_REQUIRES(\n        context, in_cols != 0,\n        errors::InvalidArgument(\"Columns dimension of input must not be 0\"));\n    OP_REQUIRES(\n        context, in_depth != 0,\n        errors::InvalidArgument(\"Depth dimension of input must not be 0\"));\n\n    constexpr int tensor_in_and_out_dims = 4;\n    // Transform orig_input_tensor_shape into TensorShape\n    TensorShape in_shape;\n    for (auto i = 0; i < tensor_in_and_out_dims; ++i) {\n      in_shape.AddDim(orig_input_tensor_shape_flat(i));\n    }\n\n    // Create intermediate in_backprop.\n    Tensor in_backprop_tensor_temp;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_temp(\n                                {0}, DataTypeToEnum<double>::v(), in_shape,\n                                &in_backprop_tensor_temp));\n    in_backprop_tensor_temp.flat<double>().setZero();\n    // Transform 4D tensor to 2D matrix.\n    EigenDoubleMatrixMap in_backprop_tensor_temp_mat(\n        in_backprop_tensor_temp.flat<double>().data(), in_depth,\n        in_cols * in_rows * in_batch);\n    ConstEigenMatrixMap out_backprop_mat(out_backprop.flat<T>().data(),\n                                         out_depth,\n                                         out_cols * out_rows * out_batch);\n    // Loop through each element of out_backprop and evenly distribute the\n    // element to the corresponding pooling cell.\n    const int64_t in_max_row_index = in_rows - 1;\n    const int64_t in_max_col_index = in_cols - 1;\n    for (int64_t b = 0; b < out_batch; ++b) {\n      for (int64_t r = 0; r < out_rows; ++r) {\n        const int64_t in_row_start = row_seq_tensor_flat(r);\n        int64_t in_row_end = overlapping_ ? row_seq_tensor_flat(r + 1)\n                                          : row_seq_tensor_flat(r + 1) - 1;\n        in_row_end = std::min(in_row_end, in_max_row_index);\n        for (int64_t c = 0; c < out_cols; ++c) {\n          const int64_t in_col_start = col_seq_tensor_flat(c);\n          int64_t in_col_end = overlapping_ ? col_seq_tensor_flat(c + 1)\n                                            : col_seq_tensor_flat(c + 1) - 1;\n          in_col_end = std::min(in_col_end, in_max_col_index);\n\n          const int64_t num_elements_in_pooling_cell =\n              (in_row_end - in_row_start + 1) * (in_col_end - in_col_start + 1);\n          const int64_t out_index = (b * out_rows + r) * out_cols + c;\n          // Now we can evenly distribute out_backprop(b, h, w, *) to\n          // in_backprop(b, hs:he, ws:we, *).\n          for (int64_t in_r = in_row_start; in_r <= in_row_end; ++in_r) {\n            for (int64_t in_c = in_col_start; in_c <= in_col_end; ++in_c) {\n              const int64_t in_index = (b * in_rows + in_r) * in_cols + in_c;\n              // Walk through each channel (depth).\n              for (int64_t d = 0; d < out_depth; ++d) {\n                const double out_backprop_element = static_cast<double>(\n                    out_backprop_mat.coeffRef(d, out_index));\n                double& in_backprop_ref =\n                    in_backprop_tensor_temp_mat.coeffRef(d, in_index);\n                in_backprop_ref +=\n                    out_backprop_element / num_elements_in_pooling_cell;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Depending on the type, cast double to type T.\n    Tensor* in_backprop_tensor = nullptr;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                {0}, 0, in_shape, &in_backprop_tensor));\n    auto in_backprop_tensor_flat = in_backprop_tensor->flat<T>();\n    auto in_backprop_tensor_temp_flat = in_backprop_tensor_temp.flat<double>();\n    for (int64_t i = 0; i < in_backprop_tensor_flat.size(); ++i) {\n      in_backprop_tensor_flat(i) =\n          static_cast<T>(in_backprop_tensor_temp_flat(i));\n    }\n  }",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <cmath>\n#include \"tensorflow/core/util/guarded_philox_random.h\"\n#include \"tensorflow/core/lib/random/random.h\"\n#include <algorithm>\n#include \"tensorflow/core/platform/logging.h\"\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include <random>\n#include \"tensorflow/core/platform/mutex.h\"\n#include \"tensorflow/core/kernels/fractional_pool_common.h\"\n#include \"tensorflow/core/framework/numeric_op.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include <vector>\n\n// Type Definitions:\n// OpKernelContext:\ntensorflow.OpKernelContext.OpKernelContext:ANY(tensorflow.OpKernelContext.Params*)\n\n// OpKernelContext:\nclass OpKernelContext {\n public:\n  // The first element of a WrappedAllocator is a \"base\" Allocator and\n  // the second element is that Allocator wrapped by a\n  // TrackingAllocator\n  typedef std::pair<Allocator*, TrackingAllocator*> WrappedAllocator;\n\n  // TODO(zhifengc): Do some cleanup of Params.\n  // The Params struct is passed in to initialize an OpKernelContext,\n  // and must outlive the OpKernelContext.\n  struct Params {\n    ~Params() { delete eigen_gpu_device; }\n\n    // The step being executed.\n    int64 step_id = 0;\n\n    // Timestamp for the start of graph execution. Used for latency metrics.\n    int64 start_time_usecs = 0;\n\n    // The op kernel being computed.\n    OpKernel* op_kernel = nullptr;\n\n    // The device on which the kernel is running.\n    DeviceBase* device = nullptr;\n\n    // The Eigen GPU device wrapper, which may include a per-op\n    // wrapped allocator. The concrete type of this object depends on\n    // the type of this->device, so eigen_gpu_device can't be a...\n\n// TensorShape:\nclass TensorShape : public TensorShapeBase<TensorShape> {\n public:\n  using TensorShapeBase<TensorShape>::TensorShapeBase;\n\n  /// Allow a TensorShape to be used as a PartialTensorShape without copying\n  operator const PartialTensorShape&() const;  // NOLINT(runtime/explicit)\n\n  /// Returns true if `*this` and `b` have the same sizes. Ignores\n  /// dimension names.\n  bool IsSameSize(const TensorShape& b) const;\n  bool operator==(const TensorShape& b) const { return IsSameSize(b); }\n  bool operator!=(const TensorShape& b) const { return !IsSameSize(b); }\n\n  /// Fill `*dsizes` from `*this`.\n  /// Notice: Using IndexType=int32 in combination with To32Bit() can\n  /// significantly improve performance on GPU.\n  template <int NDIMS, typename IndexType = Eigen::DenseIndex>\n  Eigen::DSizes<IndexType, NDIMS> AsEigenDSizes() const;\n\n  // Same as `AsEigenDSizes()` but returns a `Status` instead.\n  // Use this method to surface error to user instead of crashing if `NDMIS` is\n  // not equal to `di...\n\n// Status:\nclass Status\n\n// FractionalAvgPoolGradOp:\nclass FractionalAvgPoolGradOp : public OpKernel {\n public:\n  explicit FractionalAvgPoolGradOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"overlapping\", &overlapping_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    // Here's the basic idea:\n    // Batch and depth dimension are independent from row and col dimension. And\n    // because FractionalAvgPool currently only support pooling along row and\n    // col, we can basically think of this 4D tensor backpropagation as\n    // operation of a series of 2D planes.\n    //\n    // For each element of a 'slice' (2D plane) of output_backprop, we need to\n    // figure out its contributors when doing FractionalAvgPool operation. This\n    // can be done based on row_pooling_sequence, col_pooling_seq and\n    // overlapping.\n    // Once we figure out the original contributors, we just need to evenly\n    // divide the value of this element among these contributors.\n    //\n ...\n\n// Tensor:\nclass Tensor {\n public:\n  /// \\brief Creates a 1-dimensional, 0-element float tensor.\n  ///\n  /// The returned Tensor is not a scalar (shape {}), but is instead\n  /// an empty one-dimensional Tensor (shape {0}, NumElements() ==\n  /// 0). Since it has no elements, it does not need to be assigned a\n  /// value and is initialized by default (IsInitialized() is\n  /// true). If this is undesirable, consider creating a one-element\n  /// scalar which does require initialization:\n  ///\n  /// ```c++\n  ///\n  ///     Tensor(DT_FLOAT, TensorShape({}))\n  ///\n  /// ```\n  Tensor();\n\n  /// \\brief Creates a Tensor of the given `type` and `shape`.  If\n  /// LogMemory::IsEnabled() the allocation is logged as coming from\n  /// an unknown kernel and step. Calling the Tensor constructor\n  /// directly from within an Op is deprecated: use the\n  /// OpKernelConstruction/OpKernelContext allocate_* methods to\n  /// allocate a new tensor, which record the kernel and step.\n  ///\n  /// The underlying buffer is ...\n\n// Tensor:\ntensorflow.TensorHandle.Tensor:tensorflow.Status(tensorflow.Tensor**)<const>\n\n// ConstEigenMatrixMap:\ntypedef Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>\n          ConstEigenMatrixMap;\n\n// Status:\nclass Status {\n public:\n  /// Create a success status.\n  Status() {}\n\n  /// \\brief Create a status with the specified error code and msg as a\n  /// human-readable string containing more detailed information.\n  Status(tensorflow::error::Code code, tensorflow::StringPiece msg)\n      : Status(code, msg, {}) {}\n\n  /// \\brief Create a status with the specified error code, msg, and stack trace\n  /// as a human-readable string containing more detailed information.\n#ifndef SWIG\n  Status(tensorflow::error::Code code, tensorflow::StringPiece msg,\n         std::vector<StackFrame>&& stack_trace);\n#endif\n\n  /// Copy the specified status.\n  Status(const Status& s);\n  Status& operator=(const Status& s);\n#ifndef SWIG\n  Status(Status&& s) noexcept;\n  Status& operator=(Status&& s) noexcept;\n#endif  // SWIG\n\n  static Status OK() { return Status(); }\n\n  /// Returns true iff the status indicates success.\n  bool ok() const { return (state_ == nullptr); }\n\n  tensorflow::error::Code code() const {\n    retu...\n\n// EigenDoubleMatrixMap:\ntypedef Eigen::Map<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>>\n        EigenDoubleMatrixMap;\n\n// Called Methods (top 10):\n// SetStatus from tensorflow/core/framework/op_kernel.cc:\nvoid OpKernelConstruction::SetStatus(const Status& status) { /* <=== tensorflow.OpKernelConstruction.SetStatus:void(tensorflow.Status&) */ \n  status_->Update(status);\n}\n\n// dims from tensorflow/core/framework/tensor.h:\n  int dims() const { return shape().dims(); } /* <=== tensorflow.Tensor.dims:int()<const> */ \n\n// name from tensorflow/core/framework/op_kernel.h:\n  const std::string& name() const { return props_->node_def.name(); } /* <=== tensorflow.OpKernel.name:ANY()<const> */ \n\n// OP_REQUIRES_OK from tensorflow/core/kernels/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/op_requires.h:\n\n\n// TF_RETURN_IF_ERROR from tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/errors.h:\n\n\n// CHECK_EQ from tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/platform/logging.h:\n\n\n// CheckNotInComputeAsync from tensorflow/core/framework/op_kernel.cc:\nvoid CheckNotInComputeAsync(OpKernelContext* ctx, /* <=== tensorflow.CheckNotInComputeAsync:void(tensorflow.OpKernelContext*,char*) */ \n                            const char* correct_macro_name) {\n  CHECK_EQ(nullptr, ctx->params_->op_kernel->AsAsync())\n      << \"Use \" << correct_macro_name << \" in AsyncOpKernel implementations.\";\n}\n\n// input from tensorflow/core/framework/op_kernel.cc:\nconst Tensor& OpKernelContext::input(int index) const { /* <=== tensorflow.OpKernelContext.input:tensorflow.Tensor&(int)<const> */ \n  CHECK_GE(index, 0);\n  CHECK_LT(index, num_inputs()) << \" name: \" << op_kernel().name();\n  CHECK(!input_is_ref(index));\n  const Tensor& tensor = *((*params_->inputs)[index].tensor);\n  return tensor;\n}\n\n// Update from tensorflow/core/platform/status.h:\n  void Update(const Status& new_status); /* <=== tensorflow.Status.Update:void(tensorflow.Status&) */ \n\n// LOG from tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/platform/logging.h:\n\n"
  },
  {
    "repository": "ovs",
    "cve_id": "CVE-2021-3905",
    "cwe_list": [
      "CWE-401"
    ],
    "commit_hash": "803ed12e31b0377c37d7aa8c94b3b92f2081e349",
    "short_hash": "803ed12e",
    "vulnerableMethods_before": [
      {
        "filename": "ipf.c",
        "method_name": "vulnerable_function",
        "raw_code": "ipf_extract_frags_from_batch(struct ipf *ipf, struct dp_packet_batch *pb,\n                             ovs_be16 dl_type, uint16_t zone, long long now,\n                             uint32_t hash_basis)\n{\n    const size_t pb_cnt = dp_packet_batch_size(pb);\n    int pb_idx; /* Index in a packet batch. */\n    struct dp_packet *pkt;\n\n    DP_PACKET_BATCH_REFILL_FOR_EACH (pb_idx, pb_cnt, pkt, pb) {\n        if (OVS_UNLIKELY((dl_type == htons(ETH_TYPE_IP) &&\n                          ipf_is_valid_v4_frag(ipf, pkt))\n                          ||\n                          (dl_type == htons(ETH_TYPE_IPV6) &&\n                          ipf_is_valid_v6_frag(ipf, pkt)))) {\n\n            ovs_mutex_lock(&ipf->ipf_lock);\n            if (!ipf_handle_frag(ipf, pkt, dl_type, zone, now, hash_basis)) {\n                dp_packet_batch_refill(pb, pkt, pb_idx);\n            }\n            ovs_mutex_unlock(&ipf->ipf_lock);\n        } else {\n            dp_packet_batch_refill(pb, pkt, pb_idx);\n        }\n    }\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ipf.c",
        "method_name": "fixed_function",
        "raw_code": "ipf_extract_frags_from_batch(struct ipf *ipf, struct dp_packet_batch *pb,\n                             ovs_be16 dl_type, uint16_t zone, long long now,\n                             uint32_t hash_basis)\n{\n    const size_t pb_cnt = dp_packet_batch_size(pb);\n    int pb_idx; /* Index in a packet batch. */\n    struct dp_packet *pkt;\n\n    DP_PACKET_BATCH_REFILL_FOR_EACH (pb_idx, pb_cnt, pkt, pb) {\n        if (OVS_UNLIKELY((dl_type == htons(ETH_TYPE_IP) &&\n                          ipf_is_valid_v4_frag(ipf, pkt))\n                          ||\n                          (dl_type == htons(ETH_TYPE_IPV6) &&\n                          ipf_is_valid_v6_frag(ipf, pkt)))) {\n\n            ovs_mutex_lock(&ipf->ipf_lock);\n            if (!ipf_handle_frag(ipf, pkt, dl_type, zone, now, hash_basis)) {\n                dp_packet_batch_refill(pb, pkt, pb_idx);\n            } else {\n                dp_packet_delete(pkt);\n            }\n            ovs_mutex_unlock(&ipf->ipf_lock);\n        } else {\n            dp_packet_batch_refill(pb, pkt, pb_idx);\n        }\n    }\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"ipf.h\"\n#include \"openvswitch/poll-loop.h\"\n#include <ctype.h>\n#include <netinet/ip6.h>\n#include <netinet/in.h>\n#include \"openvswitch/vlog.h\"\n#include \"coverage.h\"\n#include <sys/types.h>\n#include <config.h>\n#include <errno.h>\n#include <netinet/icmp6.h>\n#include \"ovs-atomic.h\"\n#include \"util.h\"\n#include <string.h>\n#include \"packets.h\"\n#include \"latch.h\"\n#include \"openvswitch/hmap.h\"\n#include \"csum.h\"\n\n// Type Definitions:\n// dp_packet_batch:\nstruct dp_packet_batch\n\n// dp_packet:\nstruct dp_packet\n\n// ovs_be16:\ntypedef unsigned short uint16, uint16_t, ovs_be16, u16;\n\n// uint32_t:\ntypedef unsigned int uint32, uint32_t, ovs_be32, u32;\n\n// uint16_t:\ntypedef unsigned short uint16, uint16_t, ovs_be16, u16;\n\n// ipf:\nstruct ipf {\n    /* The clean thread is used to clean up fragments in the 'ipf'\n     * module if packet batches are not longer be sent through its user. */\n    pthread_t ipf_clean_thread;\n    struct latch ipf_clean_thread_exit;\n\n    int max_v4_frag_list_size;\n\n    struct ovs_mutex ipf_lock; /* Protects all of the following. */\n    /* These contain 'struct ipf_list's. */\n    struct hmap frag_lists OVS_GUARDED;\n    struct ovs_list frag_exp_list OVS_GUARDED;\n    struct ovs_list frag_complete_list OVS_GUARDED;\n    /* Contains 'struct reassembled_pkt's. */\n    struct ovs_list reassembled_pkt_list OVS_GUARDED;\n\n    /* Used to allow disabling fragmentation reassembly. */\n    atomic_bool ifp_v4_enabled;\n    atomic_bool ifp_v6_enabled;\n\n    /* Will be clamped above 400 bytes; the value chosen should handle\n     * alg control packets of interest that use string encoding of mutable\n     * IP fields; meaning, the control packets should not be fragmented. */\n    atomic_uint min_v4_frag_size;\n   ...\n\n// dp_packet:\nstruct dp_packet {\n#ifdef DPDK_NETDEV\n    struct rte_mbuf mbuf;       /* DPDK mbuf */\n#else\n    void *base_;                /* First byte of allocated space. */\n    uint16_t allocated_;        /* Number of bytes allocated. */\n    uint16_t data_ofs;          /* First byte actually in use. */\n    uint32_t size_;             /* Number of bytes in use. */\n    uint32_t ol_flags;          /* Offloading flags. */\n    uint32_t rss_hash;          /* Packet hash. */\n    uint32_t flow_mark;         /* Packet flow mark. */\n#endif\n    enum dp_packet_source source;  /* Source of memory allocated as 'base'. */\n\n    /* All the following elements of this struct are copied in a single call\n     * of memcpy in dp_packet_clone_with_headroom. */\n    uint16_t l2_pad_size;          /* Detected l2 padding size.\n                                    * Padding is non-pullable. */\n    uint16_t l2_5_ofs;             /* MPLS label stack offset, or UINT16_MAX */\n    uint16_t l3_ofs;               /* Network-level ...\n\n// Called Methods (top 10):\n// ipf_is_valid_v4_frag from lib/ipf.c:\nstatic bool\nipf_is_valid_v4_frag(struct ipf *ipf, struct dp_packet *pkt)\n{\n    if (OVS_UNLIKELY(dp_packet_ip_checksum_bad(pkt))) {\n        COVERAGE_INC(ipf_l3csum_err);\n        goto invalid_pkt;\n    }\n\n    const struct eth_header *l2 = dp_packet_eth(pkt);\n    const struct ip_header *l3 = dp_packet_l3(pkt);\n\n    if (OVS_UNLIKELY(!l2 || !l3)) {\n        goto invalid_pkt;\n    }\n\n    size_t l3_size = dp_packet_l3_size(pkt);\n    if (OVS_UNLIKELY(l3_size < IP_HEADER_LEN)) {\n        goto invalid_pkt;\n    }\n\n    if (!IP_IS_FRAGMENT(l3->ip_frag_off)) {\n        return false;\n    }\n\n    uint16_t ip_tot_len = ntohs(l3->ip_tot_len);\n    if (OVS_UNLIKELY(ip_tot_len != l3_size)) {\n        goto invalid_pkt;\n    }\n\n    size_t ip_hdr_len = IP_IHL(l3->ip_ihl_ver) * 4;\n    if (OVS_UNLIKELY(ip_hdr_len < IP_HEADER_LEN)) {\n        goto invalid_pkt;\n    }\n    if (OVS_UNLIKELY(l3_size < ip_hdr_len)) {\n        goto invalid_pkt;\n    }\n\n    if (OVS_UNLIKELY(!dp_packet_ip_checksum_valid(pkt)\n                    ...\n\n// OVS_UNLIKELY from lib/openvswitch/compiler.h:\n<empty>\n\n// ipf_is_valid_v6_frag from lib/ipf.c:\nstatic bool\nipf_is_valid_v6_frag(struct ipf *ipf, struct dp_packet *pkt)\n{\n    const struct eth_header *l2 = dp_packet_eth(pkt);\n    const struct  ovs_16aligned_ip6_hdr *l3 = dp_packet_l3(pkt);\n    const char *l4 = dp_packet_l4(pkt);\n\n    if (OVS_UNLIKELY(!l2 || !l3 || !l4)) {\n        goto invalid_pkt;\n    }\n\n    size_t l3_size = dp_packet_l3_size(pkt);\n    size_t l3_hdr_size = sizeof *l3;\n\n    if (OVS_UNLIKELY(l3_size < l3_hdr_size)) {\n        goto invalid_pkt;\n    }\n\n    uint8_t nw_frag = 0;\n    uint8_t nw_proto = l3->ip6_nxt;\n    const void *data = l3 + 1;\n    size_t datasize = l3_size - l3_hdr_size;\n    const struct ovs_16aligned_ip6_frag *frag_hdr = NULL;\n    if (!parse_ipv6_ext_hdrs(&data, &datasize, &nw_proto, &nw_frag,\n                             &frag_hdr) || !nw_frag || !frag_hdr) {\n        return false;\n    }\n\n    int pl = ntohs(l3->ip6_plen);\n    if (OVS_UNLIKELY(pl + l3_hdr_size != l3_size)) {\n        goto invalid_pkt;\n    }\n\n    ovs_be16 ip6f_offlg = frag_hdr->ip6f_of...\n\n// dp_packet_batch_size from lib/dp-packet.h:\nstatic inline size_t\ndp_packet_batch_size(const struct dp_packet_batch *batch)\n{\n    return batch->count;\n}\n\n// ipf_handle_frag from lib/ipf.c:\nstatic bool\nipf_handle_frag(struct ipf *ipf, struct dp_packet *pkt, ovs_be16 dl_type,\n                uint16_t zone, long long now, uint32_t hash_basis)\n    OVS_REQUIRES(ipf->ipf_lock)\n{\n    struct ipf_list_key key;\n    /* Initialize 4 variables for some versions of GCC. */\n    uint16_t start_data_byte = 0;\n    uint16_t end_data_byte = 0;\n    bool ff = false;\n    bool lf = false;\n    bool v6 = dl_type == htons(ETH_TYPE_IPV6);\n\n    if (v6 && ipf_get_v6_enabled(ipf)) {\n        ipf_v6_key_extract(pkt, dl_type, zone, &key, &start_data_byte,\n                           &end_data_byte, &ff, &lf);\n    } else if (!v6 && ipf_get_v4_enabled(ipf)) {\n        ipf_v4_key_extract(pkt, dl_type, zone, &key, &start_data_byte,\n                           &end_data_byte, &ff, &lf);\n    } else {\n        return false;\n    }\n\n    unsigned int nfrag_max;\n    atomic_read_relaxed(&ipf->nfrag_max, &nfrag_max);\n    if (atomic_count_get(&ipf->nfrag) >= nfrag_max) {\n        return false;\n    }\n\n    uint32_t hash =...\n\n// ovs_mutex_lock from lib/openvswitch/thread.h:\n<empty>\n\n// dp_packet_delete from lib/dp-packet.h:\nstatic inline void\ndp_packet_delete(struct dp_packet *b)\n{\n    if (b) {\n        if (b->source == DPBUF_DPDK) {\n            /* If this dp_packet was allocated by DPDK it must have been\n             * created as a dp_packet */\n            free_dpdk_buf((struct dp_packet*) b);\n            return;\n        }\n\n        if (b->source == DPBUF_AFXDP) {\n            free_afxdp_buf(b);\n            return;\n        }\n\n        dp_packet_uninit(b);\n        free(b);\n    }\n}\n\n// htons from include/sparse/netinet/in.h:\nstatic inline ovs_be16 htons(uint16_t x)\n{\n    return (OVS_FORCE ovs_be16) x;\n}\n"
  },
  {
    "repository": "gpac",
    "cve_id": "CVE-2022-1795",
    "cwe_list": [
      "CWE-416"
    ],
    "commit_hash": "c535bad50d5812d27ee5b22b54371bddec411514",
    "short_hash": "c535bad5",
    "vulnerableMethods_before": [
      {
        "filename": "memory_decoder.c",
        "method_name": "vulnerable_function",
        "raw_code": "static GF_Err BM_ParseGlobalQuantizer(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tGF_Node *node;\n\tGF_Command *com;\n\tGF_CommandField *inf;\n\tnode = gf_bifs_dec_node(codec, bs, NDT_SFWorldNode);\n\tif (!node) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t/*reset global QP*/\n\tif (codec->scenegraph->global_qp) {\n\t\tgf_node_unregister(codec->scenegraph->global_qp, NULL);\n\t}\n\tcodec->ActiveQP = NULL;\n\tcodec->scenegraph->global_qp = NULL;\n\n\tif (gf_node_get_tag(node) != TAG_MPEG4_QuantizationParameter) {\n\t\tgf_node_unregister(node, NULL);\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\t/*register global QP*/\n\tcodec->ActiveQP = (M_QuantizationParameter *) node;\n\tcodec->ActiveQP->isLocal = 0;\n\tcodec->scenegraph->global_qp = node;\n\n\t/*register TWICE: once for the command, and for the scenegraph globalQP*/\n\tnode->sgprivate->num_instances = 2;\n\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_GLOBAL_QUANTIZER);\n\tinf = gf_sg_command_field_new(com);\n\tinf->new_node = node;\n\tinf->field_ptr = &inf->new_node;\n\tinf->fieldType = GF_SG_VRML_SFNODE;\n\tgf_list_add(com_list, com);\n\treturn GF_OK;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "memory_decoder.c",
        "method_name": "fixed_function",
        "raw_code": "static GF_Err BM_ParseGlobalQuantizer(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tGF_Node *node;\n\tGF_Command *com;\n\tGF_CommandField *inf;\n\tnode = gf_bifs_dec_node(codec, bs, NDT_SFWorldNode);\n\tif (!node) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t/*reset global QP*/\n\tif (codec->scenegraph->global_qp) {\n\t\tgf_node_unregister(codec->scenegraph->global_qp, NULL);\n\t}\n\tcodec->ActiveQP = NULL;\n\tcodec->scenegraph->global_qp = NULL;\n\n\tif (gf_node_get_tag(node) != TAG_MPEG4_QuantizationParameter) {\n\t\t//if node was just created (num_instances == 0), unregister\n\t\t//otherwise (USE node) don't do anything\n\t\tif (!node->sgprivate->num_instances) {\n\t\t\tnode->sgprivate->num_instances = 1;\n\t\t\tgf_node_unregister(node, NULL);\n\t\t}\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\t/*register global QP*/\n\tcodec->ActiveQP = (M_QuantizationParameter *) node;\n\tcodec->ActiveQP->isLocal = 0;\n\tcodec->scenegraph->global_qp = node;\n\n\t/*register TWICE: once for the command, and for the scenegraph globalQP*/\n\tgf_node_unregister(node, NULL);\n\tgf_node_unregister(node, NULL);\n\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_GLOBAL_QUANTIZER);\n\tinf = gf_sg_command_field_new(com);\n\tinf->new_node = node;\n\tinf->field_ptr = &inf->new_node;\n\tinf->fieldType = GF_SG_VRML_SFNODE;\n\tgf_list_add(com_list, com);\n\treturn GF_OK;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <gpac/internal/bifs_dev.h>\n#include \"quant.h\"\n\n// Type Definitions:\n// GF_BifsDecoder:\ntypedef struct __tag_bifs_dec GF_BifsDecoder;\n\n// GF_Node:\ntypedef struct _base_node\n{\n\tBASE_NODE\n} GF_Node;\n\n// GF_BitStream:\ntypedef struct __tag_bitstream GF_BitStream;\n\n// GF_CommandField:\ntypedef struct\n{\n\tu32 fieldIndex;\n\t/*field type*/\n\tu32 fieldType;\n\t/*field pointer for multiple replace/multiple indexed replace - if multiple indexed replace, must be the SF field being changed*/\n\tvoid *field_ptr;\n\t/*replace/insert/delete pos - -1 is append except in multiple indexed replace*/\n\ts32 pos;\n\n\t/*Whenever field pointer is of type GF_Node, store the node here and set the far pointer to this address.*/\n\tGF_Node *new_node;\n\t/*Whenever field pointer is of type MFNode, store the node list here and set the far pointer to this address.*/\n\tGF_ChildNodeItem *node_list;\n}\n\n// Called Methods (top 10):\n// NDT_V4_GetNumBits from src/bifs/bifs_node_tables.c:\nu32 NDT_V4_GetNumBits(u32 NDT_Tag) /* <=== NDT_V4_GetNumBits */ \n{\n\tswitch (NDT_Tag) {\n\tcase NDT_SFWorldNode:\n\t\treturn SFWorldNode_V4_NUMBITS;\n\tcase NDT_SF3DNode:\n\t\treturn SF3DNode_V4_NUMBITS;\n\tcase NDT_SF2DNode:\n\t\treturn SF2DNode_V4_NUMBITS;\n\tcase NDT_SFTextureNode:\n\t\treturn SFTextureNode_V4_NUMBITS;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n// gf_bifs_dec_qp14_enter from src/bifs/unquantize.c:\nvoid gf_bifs_dec_qp14_enter(GF_BifsDecoder * codec, Bool Enter) /* <=== gf_bifs_dec_qp14_enter */ \n{\n\tif (!codec->ActiveQP) return;\n\tif (Enter) codec->storing_coord = GF_TRUE;\n\telse {\n\t\tif (codec->storing_coord) codec->coord_stored = GF_TRUE;\n\t\tcodec->storing_coord = GF_FALSE;\n\t}\n}\n\n// BD_OffsetSFTime from src/bifs/field_decode.c:\nvoid BD_OffsetSFTime(GF_BifsDecoder * codec, Double *time) /* <=== BD_OffsetSFTime */ \n{\n\tif ((!codec->is_com_dec && codec->pCurrentProto) || codec->dec_memory_mode) return;\n\t*time += codec->cts_offset;\n}\n\n// gf_strdup from src/utils/alloc.c:\nchar *gf_strdup(const char *str) /* <=== gf_strdup */ \n{\n\tSTRDUP(str);\n}\n\n// FREE from src/utils/alloc.c:\n#define FREE\tfree /* <=== src/utils/alloc.c:124:124:FREE:0 */ \n\n// gf_get_bit_size from src/utils/math.c:\nu32 gf_get_bit_size(u32 MaxVal) /* <=== gf_get_bit_size */ \n{\n\tu32 k=0;\n\twhile (MaxVal > (((u32)1<<k)-1) ) {\n\t\tif (k==31) {\n\t\t\treturn 32;\n\t\t}\n\t\tk+=1;\n\t}\n\treturn k;\n}\n\n// gf_node_set_callback_function from src/scenegraph/base_scenegraph.c:\nGF_Err gf_node_set_callback_function(GF_Node *p, void (*TraverseNode)(GF_Node *node, void *render_stack, Bool is_destroy) ) /* <=== gf_node_set_callback_function */ \n{\n\tassert(p);\n\tp->sgprivate->UserCallback = TraverseNode;\n\treturn GF_OK;\n}\n\n// NDT_V8_GetNodeTag from src/bifs/bifs_node_tables.c:\nu32 NDT_V8_GetNodeTag(u32 Context_NDT_Tag, u32 NodeType) /* <=== NDT_V8_GetNodeTag */ \n{\n\tif (!NodeType) return 0;\n\t/* adjust according to the table version */\n\t/* v8: 0 reserved for extensions */\n\tNodeType -= 1;\n\tswitch (Context_NDT_Tag) {\n\tcase NDT_SFWorldNode:\n\t\tif (NodeType >= SFWorldNode_V8_Count) return 0;\n\t\treturn SFWorldNode_V8_TypeToTag[NodeType];\n\tcase NDT_SF3DNode:\n\t\tif (NodeType >= SF3DNode_V8_Count) return 0;\n\t\treturn SF3DNode_V8_TypeToTag[NodeType];\n\tcase NDT_SF2DNode:\n\t\tif (NodeType >= SF2DNode_V8_Count) return 0;\n\t\treturn SF2DNode_V8_TypeToTag[NodeType];\n\tcase NDT_SFMusicScoreNode:\n\t\tif (NodeType >= SFMusicScoreNode_V8_Count) return 0;\n\t\treturn SFMusicScoreNode_V8_TypeToTag[NodeType];\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n// gf_bifs_dec_qp14_set_length from src/bifs/unquantize.c:\nvoid gf_bifs_dec_qp14_set_length(GF_BifsDecoder * codec, u32 NbElements) /* <=== gf_bifs_dec_qp14_set_length */ \n{\n\tif (!codec->ActiveQP || !codec->storing_coord || codec->coord_stored) return;\n\tcodec->NumCoord = NbElements;\n}\n\n// gf_malloc from src/utils/alloc.c:\nvoid *gf_malloc(size_t size) /* <=== gf_malloc */ \n{\n\treturn MALLOC(size);\n}\n"
  },
  {
    "repository": "mujs",
    "cve_id": "CVE-2022-30975",
    "cwe_list": [
      "CWE-476"
    ],
    "commit_hash": "f5b3c703e18725e380b83427004632e744f85a6f",
    "short_hash": "f5b3c703",
    "vulnerableMethods_before": [
      {
        "filename": "jsdump.c",
        "method_name": "vulnerable_function",
        "raw_code": "void jsP_dumpsyntax(js_State *J, js_Ast *prog, int dominify)\n{\n\tminify = dominify;\n\tif (prog->type == AST_LIST)\n\t\tpstmlist(-1, prog);\n\telse {\n\t\tpstm(0, prog);\n\t\tnl();\n\t}\n\tif (minify > 1)\n\t\tputchar('\\n');\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "jsdump.c",
        "method_name": "fixed_function",
        "raw_code": "void jsP_dumpsyntax(js_State *J, js_Ast *prog, int dominify)\n{\n\tminify = dominify;\n\tif (prog) {\n\t\tif (prog->type == AST_LIST)\n\t\t\tpstmlist(-1, prog);\n\t\telse {\n\t\t\tpstm(0, prog);\n\t\t\tnl();\n\t\t}\n\t}\n\tif (minify > 1)\n\t\tputchar('\\n');\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"utf.h\"\n#include \"jscompile.h\"\n#include \"jsparse.h\"\n#include \"jsi.h\"\n#include \"opnames.h\"\n#include <assert.h>\n#include \"astnames.h\"\n#include \"jsvalue.h\"\n\n// Type Definitions:\n// js_Ast:\ntypedef struct js_Ast\n\n// js_Ast:\nstruct js_Ast\n{\n\tenum js_AstType type;\n\tint line;\n\tjs_Ast *parent, *a, *b, *c, *d;\n\tdouble number;\n\tconst char *string;\n\tjs_JumpList *jumps; /* list of break/continue jumps to patch */\n\tint casejump; /* for switch case clauses */\n\tjs_Ast *gcnext; /* next in alloc list */\n}\n\n// Called Methods (top 10):\n// pstm from jsdump.c:\nstatic void pstm(int d, js_Ast *stm) /* <=== pstm */ \n{\n\tif (stm->type == STM_BLOCK) {\n\t\tpblock(d, stm);\n\t\treturn;\n\t}\n\n\tin(d);\n\n\tswitch (stm->type) {\n\tcase AST_FUNDEC:\n\t\tps(\"function \");\n\t\tpexp(d, stm->a);\n\t\tpc('(');\n\t\tpargs(d, stm->b);\n\t\tpc(')'); sp(); pc('{'); nl();\n\t\tpstmlist(d, stm->c);\n\t\tin(d); pc('}');\n\t\tbreak;\n\n\tcase STM_EMPTY:\n\t\tpc(';');\n\t\tbreak;\n\n\tcase STM_VAR:\n\t\tps(\"var \");\n\t\tpvarlist(d, stm->a);\n\t\tpc(';');\n\t\tbreak;\n\n\tcase STM_IF:\n\t\tps(\"if\"); sp(); pc('('); pexp(d, stm->a); pc(')');\n\t\tpstmh(d, stm->b);\n\t\tif (stm->c) {\n\t\t\tnl(); in(d); ps(\"else\");\n\t\t\tpstmh(d, stm->c);\n\t\t}\n\t\tbreak;\n\n\tcase STM_DO:\n\t\tps(\"do\");\n\t\tpstmh(d, stm->a);\n\t\tnl();\n\t\tin(d); ps(\"while\"); sp(); pc('('); pexp(d, stm->b); pc(')'); pc(';');\n\t\tbreak;\n\n\tcase STM_WHILE:\n\t\tps(\"while\"); sp(); pc('('); pexp(d, stm->a); pc(')');\n\t\tpstmh(d, stm->b);\n\t\tbreak;\n\n\tcase STM_FOR:\n\t\tps(\"for\"); sp(); pc('(');\n\t\tpexp(d, stm->a); pc(';'); sp();\n\t\tpexp(d, stm->b); pc(';'); sp();\n\t\tpexp(d, stm->c); pc(')');\n\t\tpstmh(d, stm->d);\n\t\tbreak;\n\tcase STM_FOR_VAR:\n\t\tps(\"for\"); sp(); ps(\"(var \");\n\t\tpvarlist(d, stm->a); pc(';'); sp();\n\t\tpexp(d, stm->b); pc(';'); sp();\n\t\tpexp(d, stm->c); pc(')');\n\t\tpstmh(d, stm->d);\n\t\tbreak;\n\tcase STM_FOR_IN:\n\t\tps(\"for\"); sp(); pc('(');\n\t\tpexp(d, stm->a); ps(\" in \");\n\t\tpexp(d, stm->b); pc(')');\n\t\tpstmh(d, stm->c);\n\t\tbreak;\n\tcase STM_FOR_IN_VAR:\n\t\tps(\"for\"); sp(); ps(\"(var \");\n\t\tpvarlist(d, stm->a); ps(\" in \");\n\t\tpexp(d, stm->b); pc(')');\n\t\tpstmh(d, stm->c);\n\t\tbreak;\n\n\tcase STM_CONTINUE:\n\t\tps(\"continue\");\n\t\tif (stm->a) {\n\t\t\tpc(' '); pexp(d, stm->a);\n\t\t}\n\t\tpc(';');\n\t\tbreak;\n\n\tcase STM_BREAK:\n\t\tps(\"break\");\n\t\tif (stm->a) {\n\t\t\tpc(' '); pexp(d, stm->a);\n\t\t}\n\t\tpc(';');\n\t\tbreak;\n\n\tcase STM_RETURN:\n\t\tps(\"return\");\n\t\tif (stm->a) {\n\t\t\tpc(' '); pexp(d, stm->a);\n\t\t}\n\t\tpc(';');\n\t\tbreak;\n\n\tcase STM_WITH:\n\t\tps(\"with\"); sp(); pc('('); pexp(d, stm->a); pc(')');\n\t\tpstmh(d, stm->b);\n\t\tbreak;\n\n\tcase STM_SWITCH:\n\t\tps(\"switch\"); sp(); pc('(');\n\t\tpexp(d, stm->a);\n\t\tpc(')'); sp(); pc('{'); nl();\n\t\tpcaselist(d, stm->b);\n\t\tin(d); pc('}');\n\t\tbreak;\n\n\tcase STM_THROW:\n\t\tps(\"throw \"); pexp(d, stm->a); pc(';');\n\t\tbreak;\n\n\tcase STM_TRY:\n\t\tps(\"try\");\n\t\tif (minify && stm->a->type != STM_BLOCK)\n\t\t\tpc(' ');\n\t\tpstmh(d, stm->a);\n\t\tif (stm->b && stm->c) {\n\t\t\tnl(); in(d); ps(\"catch\"); sp(); pc('('); pexp(d, stm->b); pc(')');\n\t\t\tpstmh(d, stm->c);\n\t\t}\n\t\tif (stm->d) {\n\t\t\tnl(); in(d); ps(\"finally\");\n\t\t\tpstmh(d, stm->d);\n\t\t}\n\t\tbreak;\n\n\tcase STM_LABEL:\n\t\tpexp(d, stm->a); pc(':'); sp(); pstm(d, stm->b);\n\t\tbreak;\n\n\tcase STM_DEBUGGER:\n\t\tps(\"debugger\");\n\t\tpc(';');\n\t\tbreak;\n\n\tdefault:\n\t\tpexp(d, stm);\n\t\tpc(';');\n\t}\n}\n\n// pblock from jsdump.c:\nstatic void pblock(int d, js_Ast *block) /* <=== pblock */ \n{\n\tassert(block->type == STM_BLOCK);\n\tpc('{'); nl();\n\tpstmlist(d, block->a);\n\tin(d); pc('}');\n}\n\n// COMMA from jsdump.c:\n#define COMMA 15 /* <=== jsdump.c:126:126:COMMA:0 */ \n\n// pcaselist from jsdump.c:\nstatic void pcaselist(int d, js_Ast *list) /* <=== pcaselist */ \n{\n\twhile (list) {\n\t\tjs_Ast *stm = list->a;\n\t\tif (stm->type == STM_CASE) {\n\t\t\tin(d); ps(\"case \"); pexp(d, stm->a); pc(':'); nl();\n\t\t\tpstmlist(d, stm->b);\n\t\t}\n\t\tif (stm->type == STM_DEFAULT) {\n\t\t\tin(d); ps(\"default:\"); nl();\n\t\t\tpstmlist(d, stm->a);\n\t\t}\n\t\tlist = list->b;\n\t}\n}\n\n// pexp from jsdump.c:\nstatic void pexp(int d, js_Ast *exp) /* <=== pexp */ \n{\n\tpexpi(d, 0, exp);\n}\n\n// comma from jsdump.c:\nstatic void comma(void) /* <=== comma */ \n{\n\tputchar(',');\n\tsp();\n}\n\n// nl from jsdump.c:\nstatic void nl(void) /* <=== nl */ \n{\n\tif (minify < 2)\n\t\tputchar('\\n');\n}\n\n// chartorune from utf.h:\n#define chartorune\tjsU_chartorune /* <=== utf.h:19:19:chartorune:0 */ \n\n// slist from jsdump.c:\nstatic void slist(int d, js_Ast *list) /* <=== slist */ \n{\n\tpc('[');\n\twhile (list) {\n\t\tassert(list->type == AST_LIST);\n\t\tsnode(d, list->a);\n\t\tlist = list->b;\n\t\tif (list)\n\t\t\tpc(' ');\n\t}\n\tpc(']');\n}\n\n// pvarlist from jsdump.c:\nstatic void pvarlist(int d, js_Ast *list) /* <=== pvarlist */ \n{\n\twhile (list) {\n\t\tassert(list->type == AST_LIST);\n\t\tpvar(d, list->a);\n\t\tlist = list->b;\n\t\tif (list)\n\t\t\tcomma();\n\t}\n}\n"
  },
  {
    "repository": "furnace",
    "cve_id": "CVE-2022-1289",
    "cwe_list": [
      "CWE-703"
    ],
    "commit_hash": "0eb02422d5161767e9983bdaa5c429762d3477ce",
    "short_hash": "0eb02422",
    "vulnerableMethods_before": [
      {
        "filename": "pattern.cpp",
        "method_name": "vulnerable_function",
        "raw_code": "inline void FurnaceGUI::patternRow(int i, bool isPlaying, float lineHeight, int chans, int ord, const DivPattern** patCache) {\n  static char id[32];\n  bool selectedRow=(i>=sel1.y && i<=sel2.y);\n  ImGui::TableNextRow(0,lineHeight);\n  ImGui::TableNextColumn();\n  float cursorPosY=ImGui::GetCursorPos().y-ImGui::GetScrollY();\n  // check if the row is visible\n  if (cursorPosY<-lineHeight || cursorPosY>ImGui::GetWindowSize().y) {\n    return;\n  }\n  // check if we are in range\n  if (ord<0 || ord>=e->song.ordersLen) {\n    return;\n  }\n  if (i<0 || i>=e->song.patLen) {\n    return;\n  }\n  bool isPushing=false;\n  ImVec4 activeColor=uiColors[GUI_COLOR_PATTERN_ACTIVE];\n  ImVec4 inactiveColor=uiColors[GUI_COLOR_PATTERN_INACTIVE];\n  ImVec4 rowIndexColor=uiColors[GUI_COLOR_PATTERN_ROW_INDEX];\n  if (e->song.hilightB>0 && !(i%e->song.hilightB)) {\n    activeColor=uiColors[GUI_COLOR_PATTERN_ACTIVE_HI2];\n    inactiveColor=uiColors[GUI_COLOR_PATTERN_INACTIVE_HI2];\n    rowIndexColor=uiColors[GUI_COLOR_PATTERN_ROW_INDEX_HI2];\n  } else if (e->song.hilightA>0 && !(i%e->song.hilightA)) {\n    activeColor=uiColors[GUI_COLOR_PATTERN_ACTIVE_HI1];\n    inactiveColor=uiColors[GUI_COLOR_PATTERN_INACTIVE_HI1];\n    rowIndexColor=uiColors[GUI_COLOR_PATTERN_ROW_INDEX_HI1];\n  }\n  // check overflow highlight\n  if (settings.overflowHighlight) {\n    if (edit && cursor.y==i) {\n      ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_EDITING]));\n    } else if (isPlaying && oldRow==i) {\n      ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_PLAY_HEAD]));\n    } else if (e->song.hilightB>0 && !(i%e->song.hilightB)) {\n      ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_2]));\n    } else if (e->song.hilightA>0 && !(i%e->song.hilightA)) {\n      ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_1]));\n    }\n  } else {\n    isPushing=true;\n    if (edit && cursor.y==i) {\n      ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_EDITING]));\n    } else if (isPlaying && oldRow==i) {\n      ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_PLAY_HEAD]));\n    } else if (e->song.hilightB>0 && !(i%e->song.hilightB)) {\n      ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_2]));\n    } else if (e->song.hilightA>0 && !(i%e->song.hilightA)) {\n      ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_1]));\n    } else {\n      isPushing=false;\n    }\n  }\n  // row number\n  if (settings.patRowsBase==1) {\n    ImGui::TextColored(rowIndexColor,\" %.2X \",i);\n  } else {\n    ImGui::TextColored(rowIndexColor,\"%3d \",i);\n  }\n  // for each column\n  for (int j=0; j<chans; j++) {\n    // check if channel is not hidden\n    if (!e->song.chanShow[j]) {\n      patChanX[j]=ImGui::GetCursorPosX();\n      continue;\n    }\n    int chanVolMax=e->getMaxVolumeChan(j);\n    if (chanVolMax<1) chanVolMax=1;\n    const DivPattern* pat=patCache[j];\n    ImGui::TableNextColumn();\n    patChanX[j]=ImGui::GetCursorPosX();\n\n    // selection highlight flags\n    int sel1XSum=sel1.xCoarse*32+sel1.xFine;\n    int sel2XSum=sel2.xCoarse*32+sel2.xFine;\n    int j32=j*32;\n    bool selectedNote=selectedRow && (j32>=sel1XSum && j32<=sel2XSum);\n    bool selectedIns=selectedRow && (j32+1>=sel1XSum && j32+1<=sel2XSum);\n    bool selectedVol=selectedRow && (j32+2>=sel1XSum && j32+2<=sel2XSum);\n    bool cursorNote=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==0);\n    bool cursorIns=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==1);\n    bool cursorVol=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==2);\n\n    // note\n    sprintf(id,\"%s##PN_%d_%d\",noteName(pat->data[i][0],pat->data[i][1]),i,j);\n    if (pat->data[i][0]==0 && pat->data[i][1]==0) {\n      ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n    } else {\n      ImGui::PushStyleColor(ImGuiCol_Text,activeColor);\n    }\n    if (cursorNote) {\n      ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);\n      ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n      ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n      ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,threeChars);\n      demandX=ImGui::GetCursorPosX();\n      ImGui::PopStyleColor(3);\n    } else {\n      if (selectedNote) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n      ImGui::Selectable(id,isPushing || selectedNote,ImGuiSelectableFlags_NoPadWithHalfSpacing,threeChars);\n      if (selectedNote) ImGui::PopStyleColor();\n    }\n    if (ImGui::IsItemClicked()) {\n      startSelection(j,0,i);\n    }\n    if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n      updateSelection(j,0,i);\n    }\n    ImGui::PopStyleColor();\n\n    // the following is only visible when the channel is not collapsed\n    if (!e->song.chanCollapse[j]) {\n      // instrument\n      if (pat->data[i][2]==-1) {\n        ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n        sprintf(id,\"..##PI_%d_%d\",i,j);\n      } else {\n        if (pat->data[i][2]<0 || pat->data[i][2]>=e->song.insLen) {\n          ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_INS_ERROR]);\n        } else {\n          DivInstrumentType t=e->song.ins[pat->data[i][2]]->type;\n          if (t!=DIV_INS_AMIGA && t!=e->getPreferInsType(j)) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_INS_WARN]);\n          } else {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_INS]);\n          }\n        }\n        sprintf(id,\"%.2X##PI_%d_%d\",pat->data[i][2],i,j);\n      }\n      ImGui::SameLine(0.0f,0.0f);\n      if (cursorIns) {\n        ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);\n        ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n        ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n        ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n        demandX=ImGui::GetCursorPosX();\n        ImGui::PopStyleColor(3);\n      } else {\n        if (selectedIns) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n        ImGui::Selectable(id,isPushing || selectedIns,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n        if (selectedIns) ImGui::PopStyleColor();\n      }\n      if (ImGui::IsItemClicked()) {\n        startSelection(j,1,i);\n      }\n      if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n        updateSelection(j,1,i);\n      }\n      ImGui::PopStyleColor();\n\n      // volume\n      if (pat->data[i][3]==-1) {\n        sprintf(id,\"..##PV_%d_%d\",i,j);\n        ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n      } else {\n        int volColor=(pat->data[i][3]*127)/chanVolMax;\n        if (volColor>127) volColor=127;\n        if (volColor<0) volColor=0;\n        sprintf(id,\"%.2X##PV_%d_%d\",pat->data[i][3],i,j);\n        ImGui::PushStyleColor(ImGuiCol_Text,volColors[volColor]);\n      }\n      ImGui::SameLine(0.0f,0.0f);\n      if (cursorVol) {\n        ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);\n        ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n        ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n        ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n        demandX=ImGui::GetCursorPosX();\n        ImGui::PopStyleColor(3);\n      } else {\n        if (selectedVol) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n        ImGui::Selectable(id,isPushing || selectedVol,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n        if (selectedVol) ImGui::PopStyleColor();\n      }\n      if (ImGui::IsItemClicked()) {\n        startSelection(j,2,i);\n      }\n      if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n        updateSelection(j,2,i);\n      }\n      ImGui::PopStyleColor();\n\n      // effects\n      for (int k=0; k<e->song.pat[j].effectRows; k++) {\n        int index=4+(k<<1);\n        bool selectedEffect=selectedRow && (j32+index-1>=sel1XSum && j32+index-1<=sel2XSum);\n        bool selectedEffectVal=selectedRow && (j32+index>=sel1XSum && j32+index<=sel2XSum);\n        bool cursorEffect=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==index-1);\n        bool cursorEffectVal=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==index);\n        \n        // effect\n        if (pat->data[i][index]==-1) {\n          sprintf(id,\"..##PE%d_%d_%d\",k,i,j);\n          ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n        } else {\n          sprintf(id,\"%.2X##PE%d_%d_%d\",pat->data[i][index],k,i,j);\n          if (pat->data[i][index]<0x10) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[fxColors[pat->data[i][index]]]);\n          } else if (pat->data[i][index]<0x20) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);\n          } else if (pat->data[i][index]<0x30) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_SECONDARY]);\n          } else if (pat->data[i][index]<0x48) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);\n          } else if (pat->data[i][index]<0x90) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n          } else if (pat->data[i][index]<0xa0) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_MISC]);\n          } else if (pat->data[i][index]<0xc0) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n          } else if (pat->data[i][index]<0xd0) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SPEED]);\n          } else if (pat->data[i][index]<0xe0) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n          } else {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[extFxColors[pat->data[i][index]-0xe0]]);\n          }\n        }\n        ImGui::SameLine(0.0f,0.0f);\n        if (cursorEffect) {\n          ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);  \n          ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n          ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n          ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n          demandX=ImGui::GetCursorPosX();\n          ImGui::PopStyleColor(3);\n        } else {\n          if (selectedEffect) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n          ImGui::Selectable(id,isPushing || selectedEffect,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n          if (selectedEffect) ImGui::PopStyleColor();\n        }\n        if (ImGui::IsItemClicked()) {\n          startSelection(j,index-1,i);\n        }\n        if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n          updateSelection(j,index-1,i);\n        }\n\n        // effect value\n        if (pat->data[i][index+1]==-1) {\n          sprintf(id,\"..##PF%d_%d_%d\",k,i,j);\n        } else {\n          sprintf(id,\"%.2X##PF%d_%d_%d\",pat->data[i][index+1],k,i,j);\n        }\n        ImGui::SameLine(0.0f,0.0f);\n        if (cursorEffectVal) {\n          ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);  \n          ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n          ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n          ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n          demandX=ImGui::GetCursorPosX();\n          ImGui::PopStyleColor(3);\n        } else {\n          if (selectedEffectVal) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n          ImGui::Selectable(id,isPushing || selectedEffectVal,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n          if (selectedEffectVal) ImGui::PopStyleColor();\n        }\n        if (ImGui::IsItemClicked()) {\n          startSelection(j,index,i);\n        }\n        if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n          updateSelection(j,index,i);\n        }\n        ImGui::PopStyleColor();\n      }\n    }\n  }\n  if (isPushing) {\n    ImGui::PopStyleColor();\n  }\n  ImGui::TableNextColumn();\n  patChanX[chans]=ImGui::GetCursorPosX();\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "pattern.cpp",
        "method_name": "fixed_function",
        "raw_code": "inline void FurnaceGUI::patternRow(int i, bool isPlaying, float lineHeight, int chans, int ord, const DivPattern** patCache) {\n  static char id[32];\n  bool selectedRow=(i>=sel1.y && i<=sel2.y);\n  ImGui::TableNextRow(0,lineHeight);\n  ImGui::TableNextColumn();\n  float cursorPosY=ImGui::GetCursorPos().y-ImGui::GetScrollY();\n  // check if the row is visible\n  if (cursorPosY<-lineHeight || cursorPosY>ImGui::GetWindowSize().y) {\n    return;\n  }\n  // check if we are in range\n  if (ord<0 || ord>=e->song.ordersLen) {\n    return;\n  }\n  if (i<0 || i>=e->song.patLen) {\n    return;\n  }\n  bool isPushing=false;\n  ImVec4 activeColor=uiColors[GUI_COLOR_PATTERN_ACTIVE];\n  ImVec4 inactiveColor=uiColors[GUI_COLOR_PATTERN_INACTIVE];\n  ImVec4 rowIndexColor=uiColors[GUI_COLOR_PATTERN_ROW_INDEX];\n  if (e->song.hilightB>0 && !(i%e->song.hilightB)) {\n    activeColor=uiColors[GUI_COLOR_PATTERN_ACTIVE_HI2];\n    inactiveColor=uiColors[GUI_COLOR_PATTERN_INACTIVE_HI2];\n    rowIndexColor=uiColors[GUI_COLOR_PATTERN_ROW_INDEX_HI2];\n  } else if (e->song.hilightA>0 && !(i%e->song.hilightA)) {\n    activeColor=uiColors[GUI_COLOR_PATTERN_ACTIVE_HI1];\n    inactiveColor=uiColors[GUI_COLOR_PATTERN_INACTIVE_HI1];\n    rowIndexColor=uiColors[GUI_COLOR_PATTERN_ROW_INDEX_HI1];\n  }\n  // check overflow highlight\n  if (settings.overflowHighlight) {\n    if (edit && cursor.y==i) {\n      ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_EDITING]));\n    } else if (isPlaying && oldRow==i) {\n      ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_PLAY_HEAD]));\n    } else if (e->song.hilightB>0 && !(i%e->song.hilightB)) {\n      ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_2]));\n    } else if (e->song.hilightA>0 && !(i%e->song.hilightA)) {\n      ImGui::TableSetBgColor(ImGuiTableBgTarget_RowBg0,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_1]));\n    }\n  } else {\n    isPushing=true;\n    if (edit && cursor.y==i) {\n      ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_EDITING]));\n    } else if (isPlaying && oldRow==i) {\n      ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_PLAY_HEAD]));\n    } else if (e->song.hilightB>0 && !(i%e->song.hilightB)) {\n      ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_2]));\n    } else if (e->song.hilightA>0 && !(i%e->song.hilightA)) {\n      ImGui::PushStyleColor(ImGuiCol_Header,ImGui::GetColorU32(uiColors[GUI_COLOR_PATTERN_HI_1]));\n    } else {\n      isPushing=false;\n    }\n  }\n  // row number\n  if (settings.patRowsBase==1) {\n    ImGui::TextColored(rowIndexColor,\" %.2X \",i);\n  } else {\n    ImGui::TextColored(rowIndexColor,\"%3d \",i);\n  }\n  // for each column\n  for (int j=0; j<chans; j++) {\n    // check if channel is not hidden\n    if (!e->song.chanShow[j]) {\n      patChanX[j]=ImGui::GetCursorPosX();\n      continue;\n    }\n    int chanVolMax=e->getMaxVolumeChan(j);\n    if (chanVolMax<1) chanVolMax=1;\n    const DivPattern* pat=patCache[j];\n    ImGui::TableNextColumn();\n    patChanX[j]=ImGui::GetCursorPosX();\n\n    // selection highlight flags\n    int sel1XSum=sel1.xCoarse*32+sel1.xFine;\n    int sel2XSum=sel2.xCoarse*32+sel2.xFine;\n    int j32=j*32;\n    bool selectedNote=selectedRow && (j32>=sel1XSum && j32<=sel2XSum);\n    bool selectedIns=selectedRow && (j32+1>=sel1XSum && j32+1<=sel2XSum);\n    bool selectedVol=selectedRow && (j32+2>=sel1XSum && j32+2<=sel2XSum);\n    bool cursorNote=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==0);\n    bool cursorIns=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==1);\n    bool cursorVol=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==2);\n\n    // note\n    sprintf(id,\"%s##PN_%d_%d\",noteName(pat->data[i][0],pat->data[i][1]),i,j);\n    if (pat->data[i][0]==0 && pat->data[i][1]==0) {\n      ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n    } else {\n      ImGui::PushStyleColor(ImGuiCol_Text,activeColor);\n    }\n    if (cursorNote) {\n      ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);\n      ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n      ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n      ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,threeChars);\n      demandX=ImGui::GetCursorPosX();\n      ImGui::PopStyleColor(3);\n    } else {\n      if (selectedNote) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n      ImGui::Selectable(id,isPushing || selectedNote,ImGuiSelectableFlags_NoPadWithHalfSpacing,threeChars);\n      if (selectedNote) ImGui::PopStyleColor();\n    }\n    if (ImGui::IsItemClicked()) {\n      startSelection(j,0,i);\n    }\n    if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n      updateSelection(j,0,i);\n    }\n    ImGui::PopStyleColor();\n\n    // the following is only visible when the channel is not collapsed\n    if (!e->song.chanCollapse[j]) {\n      // instrument\n      if (pat->data[i][2]==-1) {\n        ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n        sprintf(id,\"..##PI_%d_%d\",i,j);\n      } else {\n        if (pat->data[i][2]<0 || pat->data[i][2]>=e->song.insLen) {\n          ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_INS_ERROR]);\n        } else {\n          DivInstrumentType t=e->song.ins[pat->data[i][2]]->type;\n          if (t!=DIV_INS_AMIGA && t!=e->getPreferInsType(j)) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_INS_WARN]);\n          } else {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_INS]);\n          }\n        }\n        sprintf(id,\"%.2X##PI_%d_%d\",pat->data[i][2],i,j);\n      }\n      ImGui::SameLine(0.0f,0.0f);\n      if (cursorIns) {\n        ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);\n        ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n        ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n        ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n        demandX=ImGui::GetCursorPosX();\n        ImGui::PopStyleColor(3);\n      } else {\n        if (selectedIns) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n        ImGui::Selectable(id,isPushing || selectedIns,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n        if (selectedIns) ImGui::PopStyleColor();\n      }\n      if (ImGui::IsItemClicked()) {\n        startSelection(j,1,i);\n      }\n      if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n        updateSelection(j,1,i);\n      }\n      ImGui::PopStyleColor();\n\n      // volume\n      if (pat->data[i][3]==-1) {\n        sprintf(id,\"..##PV_%d_%d\",i,j);\n        ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n      } else {\n        int volColor=(pat->data[i][3]*127)/chanVolMax;\n        if (volColor>127) volColor=127;\n        if (volColor<0) volColor=0;\n        sprintf(id,\"%.2X##PV_%d_%d\",pat->data[i][3],i,j);\n        ImGui::PushStyleColor(ImGuiCol_Text,volColors[volColor]);\n      }\n      ImGui::SameLine(0.0f,0.0f);\n      if (cursorVol) {\n        ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);\n        ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n        ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n        ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n        demandX=ImGui::GetCursorPosX();\n        ImGui::PopStyleColor(3);\n      } else {\n        if (selectedVol) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n        ImGui::Selectable(id,isPushing || selectedVol,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n        if (selectedVol) ImGui::PopStyleColor();\n      }\n      if (ImGui::IsItemClicked()) {\n        startSelection(j,2,i);\n      }\n      if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n        updateSelection(j,2,i);\n      }\n      ImGui::PopStyleColor();\n\n      // effects\n      for (int k=0; k<e->song.pat[j].effectRows; k++) {\n        int index=4+(k<<1);\n        bool selectedEffect=selectedRow && (j32+index-1>=sel1XSum && j32+index-1<=sel2XSum);\n        bool selectedEffectVal=selectedRow && (j32+index>=sel1XSum && j32+index<=sel2XSum);\n        bool cursorEffect=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==index-1);\n        bool cursorEffectVal=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==index);\n        \n        // effect\n        if (pat->data[i][index]==-1) {\n          sprintf(id,\"..##PE%d_%d_%d\",k,i,j);\n          ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n        } else {\n          if (pat->data[i][index]>0xff) {\n            sprintf(id,\"??##PE%d_%d_%d\",k,i,j);\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n          } else {\n            const unsigned char data=pat->data[i][index];\n            sprintf(id,\"%.2X##PE%d_%d_%d\",data,k,i,j);\n            if (data<0x10) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[fxColors[data]]);\n            } else if (data<0x20) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);\n            } else if (data<0x30) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_SECONDARY]);\n            } else if (data<0x48) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);\n            } else if (data<0x90) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n            } else if (data<0xa0) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_MISC]);\n            } else if (data<0xc0) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n            } else if (data<0xd0) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SPEED]);\n            } else if (data<0xe0) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n            } else {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[extFxColors[data-0xe0]]);\n            }\n          }\n        }\n        ImGui::SameLine(0.0f,0.0f);\n        if (cursorEffect) {\n          ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);  \n          ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n          ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n          ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n          demandX=ImGui::GetCursorPosX();\n          ImGui::PopStyleColor(3);\n        } else {\n          if (selectedEffect) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n          ImGui::Selectable(id,isPushing || selectedEffect,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n          if (selectedEffect) ImGui::PopStyleColor();\n        }\n        if (ImGui::IsItemClicked()) {\n          startSelection(j,index-1,i);\n        }\n        if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n          updateSelection(j,index-1,i);\n        }\n\n        // effect value\n        if (pat->data[i][index+1]==-1) {\n          sprintf(id,\"..##PF%d_%d_%d\",k,i,j);\n        } else {\n          sprintf(id,\"%.2X##PF%d_%d_%d\",pat->data[i][index+1],k,i,j);\n        }\n        ImGui::SameLine(0.0f,0.0f);\n        if (cursorEffectVal) {\n          ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);  \n          ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n          ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n          ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n          demandX=ImGui::GetCursorPosX();\n          ImGui::PopStyleColor(3);\n        } else {\n          if (selectedEffectVal) ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_SELECTION]);\n          ImGui::Selectable(id,isPushing || selectedEffectVal,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n          if (selectedEffectVal) ImGui::PopStyleColor();\n        }\n        if (ImGui::IsItemClicked()) {\n          startSelection(j,index,i);\n        }\n        if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem)) {\n          updateSelection(j,index,i);\n        }\n        ImGui::PopStyleColor();\n      }\n    }\n  }\n  if (isPushing) {\n    ImGui::PopStyleColor();\n  }\n  ImGui::TableNextColumn();\n  patChanX[chans]=ImGui::GetCursorPosX();\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"IconsFontAwesome4.h\"\n#include \"misc/cpp/imgui_stdlib.h\"\n#include \"../ta-log.h\"\n#include \"gui.h\"\n#include <fmt/printf.h>\n#include \"guiConst.h\"\n#include \"imgui_internal.h\"\n\n// Type Definitions:\n// FurnaceGUI:\nFurnaceGUI.FurnaceGUI:ANY()\n\n// DivPattern:\nstruct DivPattern {\n  String name;\n  short data[256][32];\n\n  /**\n   * copy this pattern to another.\n   * @param dest the destination pattern.\n   */\n  void copyOn(DivPattern* dest);\n\n  /**\n   * don't use yet!\n   * @param len the pattern length\n   * @param fxRows number of effect ...columns\n   * @return a SafeReader.\n   */\n  SafeReader* compile(int len=256, int fxRows=1);\n  DivPattern();\n}\n\n// DivPattern:\nDivPattern.DivPattern:ANY()\n\n// FurnaceGUI:\nclass FurnaceGUI {\n  DivEngine* e;\n\n  SDL_Window* sdlWin;\n  SDL_Renderer* sdlRend;\n\n  SDL_Texture* sampleTex;\n  int sampleTexW, sampleTexH;\n  bool updateSampleTex;\n\n  String workingDir, fileName, clipboard, warnString, errorString, lastError, curFileName, nextFile;\n  String workingDirSong, workingDirIns, workingDirWave, workingDirSample, workingDirAudioExport, workingDirVGMExport, workingDirFont, workingDirColors, workingDirKeybinds, workingDirLayout;\n  String mmlString[13];\n  String mmlStringW;\n\n  bool quit, warnQuit, willCommit, edit, modified, displayError, displayExporting, vgmExportLoop;\n  bool displayNew;\n  bool willExport[32];\n  int vgmExportVersion;\n\n  FurnaceGUIFileDialogs curFileDialog;\n  FurnaceGUIWarnings warnAction;\n\n  FurnaceGUIFileDialog* fileDialog;\n\n  int scrW, scrH;\n\n  double dpiScale;\n\n  double aboutScroll, aboutSin;\n  float aboutHue;\n\n  double backupTimer;\n  std::future<bool> backupTask;\n  std::mutex backupLock;\n  String backupPath;\n\n  std::mutex midiLock;\n  std:...\n"
  },
  {
    "repository": "lua",
    "cve_id": "CVE-2022-28805",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "1f3c6f4534c6411313361697d98d1145a1f030fa",
    "short_hash": "1f3c6f45",
    "vulnerableMethods_before": [
      {
        "filename": "lparser.c",
        "method_name": "vulnerable_function",
        "raw_code": "static void singlevar (LexState *ls, expdesc *var) {\n  TString *varname = str_checkname(ls);\n  FuncState *fs = ls->fs;\n  singlevaraux(fs, varname, var, 1);\n  if (var->k == VVOID) {  /* global name? */\n    expdesc key;\n    singlevaraux(fs, ls->envn, var, 1);  /* get environment variable */\n    lua_assert(var->k != VVOID);  /* this one must exist */\n    codestring(&key, varname);  /* key is variable name */\n    luaK_indexed(fs, var, &key);  /* env[varname] */\n  }\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "lparser.c",
        "method_name": "fixed_function",
        "raw_code": "static void singlevar (LexState *ls, expdesc *var) {\n  TString *varname = str_checkname(ls);\n  FuncState *fs = ls->fs;\n  singlevaraux(fs, varname, var, 1);\n  if (var->k == VVOID) {  /* global name? */\n    expdesc key;\n    singlevaraux(fs, ls->envn, var, 1);  /* get environment variable */\n    lua_assert(var->k != VVOID);  /* this one must exist */\n    luaK_exp2anyregup(fs, var);  /* but could be a constant */\n    codestring(&key, varname);  /* key is variable name */\n    luaK_indexed(fs, var, &key);  /* env[varname] */\n  }\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"lprefix.h\"\n#include \"llex.h\"\n#include \"lstate.h\"\n#include <limits.h>\n#include \"lcode.h\"\n#include \"lmem.h\"\n#include \"lopcodes.h\"\n#include \"lua.h\"\n#include \"lstring.h\"\n#include \"ldo.h\"\n#include \"lobject.h\"\n#include \"ltable.h\"\n#include \"ldebug.h\"\n#include <string.h>\n#include \"lparser.h\"\n#include \"lfunc.h\"\n\n// Type Definitions:\n// FuncState:\ntypedef struct FuncState {\n  Proto *f;  /* current function header */\n  struct FuncState *prev;  /* enclosing function */\n  struct LexState *ls;  /* lexical state */\n  struct BlockCnt *bl;  /* chain of current blocks */\n  int pc;  /* next position to code (equivalent to 'ncode') */\n  int lasttarget;   /* 'label' of last 'jump label' */\n  int previousline;  /* last line that was saved in 'lineinfo' */\n  int nk;  /* number of elements in 'k' */\n  int np;  /* number of elements in 'p' */\n  int nabslineinfo;  /* number of elements in 'abslineinfo' */\n  int firstlocal;  /* index of first local var (in Dyndata array) */\n  int firstlabel;  /* index of first label (in 'dyd->label->arr') */\n  short ndebugvars;  /* number of elements in 'f->locvars' */\n  lu_byte nactvar;  /* number of active local variables */\n  lu_byte nups;  /* number of upvalues */\n  lu_byte freereg;  /* first free register */\n  lu_byte iwthabs;  /* instructions issued since last absolute line info */\n  lu_byte needclose; ...\n\n// FuncState:\nstruct FuncState\n\n// LexState:\ntypedef struct LexState {\n  int current;  /* current character (charint) */\n  int linenumber;  /* input line counter */\n  int lastline;  /* line of last token 'consumed' */\n  Token t;  /* current token */\n  Token lookahead;  /* look ahead token */\n  struct FuncState *fs;  /* current function (parser) */\n  struct lua_State *L;\n  ZIO *z;  /* input stream */\n  Mbuffer *buff;  /* buffer for tokens */\n  Table *h;  /* to avoid collection/reuse strings */\n  struct Dyndata *dyd;  /* dynamic structures used by the parser */\n  TString *source;  /* current source name */\n  TString *envn;  /* environment variable name */\n}\n\n// expdesc:\ntypedef struct expdesc {\n  expkind k;\n  union {\n    lua_Integer ival;    /* for VKINT */\n    lua_Number nval;  /* for VKFLT */\n    TString *strval;  /* for VKSTR */\n    int info;  /* for generic use */\n    struct {  /* for indexed variables */\n      short idx;  /* index (R or \"long\" K) */\n      lu_byte t;  /* table (register or upvalue) */\n    } ind;\n    struct {  /* for local variables */\n      lu_byte ridx;  /* register holding the variable */\n      unsigned short vidx;  /* compiler index (in 'actvar.arr')  */\n    } var;\n  } u;\n  int t;  /* patch list of 'exit when true' */\n  int f;  /* patch list of 'exit when false' */\n}\n\n// expdesc:\ntypedef struct expdesc {\n  expkind k;\n  union {\n    lua_Integer ival;    /* for VKINT */\n    lua_Number nval;  /* for VKFLT */\n    TString *strval;  /* for VKSTR */\n    int info;  /* for generic use */\n    struct {  /* for indexed variables */\n      short idx;  /* index (R or \"long\" K) */\n      lu_byte t;  /* table (register or upvalue) */\n    } ind;\n    struct {  /* for local variables */\n      lu_byte ridx;  /* register holding the variable */\n      unsigned short vidx;  /* compiler index (in 'actvar.arr')  */\n    } var;\n  } u;\n  int t;  /* patch list of 'exit when true' */\n  int f;  /* patch list of 'exit when false' */\n} expdesc;\n\n// Called Methods (top 10):\n// luaK_exp2anyregup from lcode.c:\nvoid luaK_exp2anyregup (FuncState *fs, expdesc *e) {\n  if (e->k != VUPVAL || hasjumps(e))\n    luaK_exp2anyreg(fs, e);\n}\n\n// luaK_indexed from lcode.c:\nvoid luaK_indexed (FuncState *fs, expdesc *t, expdesc *k) {\n  if (k->k == VKSTR)\n    str2K(fs, k);\n  lua_assert(!hasjumps(t) &&\n             (t->k == VLOCAL || t->k == VNONRELOC || t->k == VUPVAL));\n  if (t->k == VUPVAL && !isKstr(fs, k))  /* upvalue indexed by non 'Kstr'? */\n    luaK_exp2anyreg(fs, t);  /* put it in a register */\n  if (t->k == VUPVAL) {\n    t->u.ind.t = t->u.info;  /* upvalue index */\n    t->u.ind.idx = k->u.info;  /* literal string */\n    t->k = VINDEXUP;\n  }\n  else {\n    /* register index of the table */\n    t->u.ind.t = (t->k == VLOCAL) ? t->u.var.ridx: t->u.info;\n    if (isKstr(fs, k)) {\n      t->u.ind.idx = k->u.info;  /* literal string */\n      t->k = VINDEXSTR;\n    }\n    else if (isCint(k)) {\n      t->u.ind.idx = cast_int(k->u.ival);  /* int. constant in proper range */\n      t->k = VINDEXI;\n    }\n    else {\n      t->u.ind.idx = luaK_exp2anyreg(fs, k);  /* register */\n      t->k = VINDEXED;\n    }\n  }\n}\n"
  },
  {
    "repository": "server",
    "cve_id": "CVE-2022-27448",
    "cwe_list": [
      "CWE-617"
    ],
    "commit_hash": "ecb6f9c894d3ebafeff1c6eb3b65cd248062296f",
    "short_hash": "ecb6f9c8",
    "vulnerableMethods_before": [
      {
        "filename": "None",
        "method_name": "vulnerable_function",
        "raw_code": "multi_update::initialize_tables(JOIN *join)\n{\n  TABLE_LIST *table_ref;\n  DBUG_ENTER(\"initialize_tables\");\n\n  if (unlikely((thd->variables.option_bits & OPTION_SAFE_UPDATES) &&\n               error_if_full_join(join)))\n    DBUG_RETURN(1);\n  main_table=join->join_tab->table;\n  table_to_update= 0;\n\n  /* Any update has at least one pair (field, value) */\n  DBUG_ASSERT(fields->elements);\n  /*\n   Only one table may be modified by UPDATE of an updatable view.\n   For an updatable view first_table_for_update indicates this\n   table.\n   For a regular multi-update it refers to some updated table.\n  */ \n  TABLE *first_table_for_update= ((Item_field *) fields->head())->field->table;\n\n  /* Create a temporary table for keys to all tables, except main table */\n  for (table_ref= update_tables; table_ref; table_ref= table_ref->next_local)\n  {\n    TABLE *table=table_ref->table;\n    uint cnt= table_ref->shared;\n    List<Item> temp_fields;\n    ORDER     group;\n    TMP_TABLE_PARAM *tmp_param;\n\n    if (ignore)\n      table->file->extra(HA_EXTRA_IGNORE_DUP_KEY);\n    if (table == main_table)\t\t\t// First table in join\n    {\n      if (safe_update_on_fly(thd, join->join_tab, table_ref, all_tables))\n      {\n\ttable_to_update= table;\t\t\t// Update table on the fly\n        has_vers_fields= table->vers_check_update(*fields);\n\tcontinue;\n      }\n    }\n    table->prepare_for_position();\n    join->map2table[table->tablenr]->keep_current_rowid= true;\n\n    /*\n      enable uncacheable flag if we update a view with check option\n      and check option has a subselect, otherwise, the check option\n      can be evaluated after the subselect was freed as independent\n      (See full_local in JOIN::join_free()).\n    */\n    if (table_ref->check_option && !join->select_lex->uncacheable)\n    {\n      SELECT_LEX_UNIT *tmp_unit;\n      SELECT_LEX *sl;\n      for (tmp_unit= join->select_lex->first_inner_unit();\n           tmp_unit;\n           tmp_unit= tmp_unit->next_unit())\n      {\n        for (sl= tmp_unit->first_select(); sl; sl= sl->next_select())\n        {\n          if (sl->master_unit()->item)\n          {\n            join->select_lex->uncacheable|= UNCACHEABLE_CHECKOPTION;\n            goto loop_end;\n          }\n        }\n      }\n    }\nloop_end:\n\n    if (table == first_table_for_update && table_ref->check_option)\n    {\n      table_map unupdated_tables= table_ref->check_option->used_tables() &\n                                  ~first_table_for_update->map;\n      List_iterator<TABLE_LIST> ti(*leaves);\n      TABLE_LIST *tbl_ref;\n      while ((tbl_ref= ti++) && unupdated_tables)\n      {\n        if (unupdated_tables & tbl_ref->table->map)\n          unupdated_tables&= ~tbl_ref->table->map;\n        else\n          continue;\n        if (unupdated_check_opt_tables.push_back(tbl_ref->table))\n          DBUG_RETURN(1);\n      }\n    }\n\n    tmp_param= tmp_table_param+cnt;\n\n    /*\n      Create a temporary table to store all fields that are changed for this\n      table. The first field in the temporary table is a pointer to the\n      original row so that we can find and update it. For the updatable\n      VIEW a few following fields are rowids of tables used in the CHECK\n      OPTION condition.\n    */\n\n    List_iterator_fast<TABLE> tbl_it(unupdated_check_opt_tables);\n    TABLE *tbl= table;\n    do\n    {\n      LEX_CSTRING field_name;\n      field_name.str= tbl->alias.c_ptr();\n      field_name.length= strlen(field_name.str);\n      /*\n        Signal each table (including tables referenced by WITH CHECK OPTION\n        clause) for which we will store row position in the temporary table\n        that we need a position to be read first.\n      */\n      tbl->prepare_for_position();\n      join->map2table[tbl->tablenr]->keep_current_rowid= true;\n\n      Item_temptable_rowid *item=\n        new (thd->mem_root) Item_temptable_rowid(tbl);\n      if (!item)\n         DBUG_RETURN(1);\n      item->fix_fields(thd, 0);\n      if (temp_fields.push_back(item, thd->mem_root))\n        DBUG_RETURN(1);\n    } while ((tbl= tbl_it++));\n\n    temp_fields.append(fields_for_table[cnt]);\n\n    /* Make an unique key over the first field to avoid duplicated updates */\n    bzero((char*) &group, sizeof(group));\n    group.direction= ORDER::ORDER_ASC;\n    group.item= (Item**) temp_fields.head_ref();\n\n    tmp_param->quick_group= 1;\n    tmp_param->field_count= temp_fields.elements;\n    tmp_param->func_count=  temp_fields.elements - 1;\n    calc_group_buffer(tmp_param, &group);\n    /* small table, ignore SQL_BIG_TABLES */\n    my_bool save_big_tables= thd->variables.big_tables; \n    thd->variables.big_tables= FALSE;\n    tmp_tables[cnt]=create_tmp_table(thd, tmp_param, temp_fields,\n                                     (ORDER*) &group, 0, 0,\n                                     TMP_TABLE_ALL_COLUMNS, HA_POS_ERROR, &empty_clex_str);\n    thd->variables.big_tables= save_big_tables;\n    if (!tmp_tables[cnt])\n      DBUG_RETURN(1);\n    tmp_tables[cnt]->file->extra(HA_EXTRA_WRITE_CACHE);\n  }\n  join->tmp_table_keep_current_rowid= TRUE;\n  DBUG_RETURN(0);\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "None",
        "method_name": "fixed_function",
        "raw_code": "multi_update::initialize_tables(JOIN *join)\n{\n  TABLE_LIST *table_ref;\n  DBUG_ENTER(\"initialize_tables\");\n\n  if (unlikely((thd->variables.option_bits & OPTION_SAFE_UPDATES) &&\n               error_if_full_join(join)))\n    DBUG_RETURN(1);\n  if (join->implicit_grouping)\n  {\n    my_error(ER_INVALID_GROUP_FUNC_USE, MYF(0));\n    DBUG_RETURN(1);\n  }\n  main_table=join->join_tab->table;\n  table_to_update= 0;\n\n  /* Any update has at least one pair (field, value) */\n  DBUG_ASSERT(fields->elements);\n  /*\n   Only one table may be modified by UPDATE of an updatable view.\n   For an updatable view first_table_for_update indicates this\n   table.\n   For a regular multi-update it refers to some updated table.\n  */ \n  TABLE *first_table_for_update= ((Item_field *) fields->head())->field->table;\n\n  /* Create a temporary table for keys to all tables, except main table */\n  for (table_ref= update_tables; table_ref; table_ref= table_ref->next_local)\n  {\n    TABLE *table=table_ref->table;\n    uint cnt= table_ref->shared;\n    List<Item> temp_fields;\n    ORDER     group;\n    TMP_TABLE_PARAM *tmp_param;\n\n    if (ignore)\n      table->file->extra(HA_EXTRA_IGNORE_DUP_KEY);\n    if (table == main_table)\t\t\t// First table in join\n    {\n      if (safe_update_on_fly(thd, join->join_tab, table_ref, all_tables))\n      {\n\ttable_to_update= table;\t\t\t// Update table on the fly\n        has_vers_fields= table->vers_check_update(*fields);\n\tcontinue;\n      }\n    }\n    table->prepare_for_position();\n    join->map2table[table->tablenr]->keep_current_rowid= true;\n\n    /*\n      enable uncacheable flag if we update a view with check option\n      and check option has a subselect, otherwise, the check option\n      can be evaluated after the subselect was freed as independent\n      (See full_local in JOIN::join_free()).\n    */\n    if (table_ref->check_option && !join->select_lex->uncacheable)\n    {\n      SELECT_LEX_UNIT *tmp_unit;\n      SELECT_LEX *sl;\n      for (tmp_unit= join->select_lex->first_inner_unit();\n           tmp_unit;\n           tmp_unit= tmp_unit->next_unit())\n      {\n        for (sl= tmp_unit->first_select(); sl; sl= sl->next_select())\n        {\n          if (sl->master_unit()->item)\n          {\n            join->select_lex->uncacheable|= UNCACHEABLE_CHECKOPTION;\n            goto loop_end;\n          }\n        }\n      }\n    }\nloop_end:\n\n    if (table == first_table_for_update && table_ref->check_option)\n    {\n      table_map unupdated_tables= table_ref->check_option->used_tables() &\n                                  ~first_table_for_update->map;\n      List_iterator<TABLE_LIST> ti(*leaves);\n      TABLE_LIST *tbl_ref;\n      while ((tbl_ref= ti++) && unupdated_tables)\n      {\n        if (unupdated_tables & tbl_ref->table->map)\n          unupdated_tables&= ~tbl_ref->table->map;\n        else\n          continue;\n        if (unupdated_check_opt_tables.push_back(tbl_ref->table))\n          DBUG_RETURN(1);\n      }\n    }\n\n    tmp_param= tmp_table_param+cnt;\n\n    /*\n      Create a temporary table to store all fields that are changed for this\n      table. The first field in the temporary table is a pointer to the\n      original row so that we can find and update it. For the updatable\n      VIEW a few following fields are rowids of tables used in the CHECK\n      OPTION condition.\n    */\n\n    List_iterator_fast<TABLE> tbl_it(unupdated_check_opt_tables);\n    TABLE *tbl= table;\n    do\n    {\n      LEX_CSTRING field_name;\n      field_name.str= tbl->alias.c_ptr();\n      field_name.length= strlen(field_name.str);\n      /*\n        Signal each table (including tables referenced by WITH CHECK OPTION\n        clause) for which we will store row position in the temporary table\n        that we need a position to be read first.\n      */\n      tbl->prepare_for_position();\n      join->map2table[tbl->tablenr]->keep_current_rowid= true;\n\n      Item_temptable_rowid *item=\n        new (thd->mem_root) Item_temptable_rowid(tbl);\n      if (!item)\n         DBUG_RETURN(1);\n      item->fix_fields(thd, 0);\n      if (temp_fields.push_back(item, thd->mem_root))\n        DBUG_RETURN(1);\n    } while ((tbl= tbl_it++));\n\n    temp_fields.append(fields_for_table[cnt]);\n\n    /* Make an unique key over the first field to avoid duplicated updates */\n    bzero((char*) &group, sizeof(group));\n    group.direction= ORDER::ORDER_ASC;\n    group.item= (Item**) temp_fields.head_ref();\n\n    tmp_param->quick_group= 1;\n    tmp_param->field_count= temp_fields.elements;\n    tmp_param->func_count=  temp_fields.elements - 1;\n    calc_group_buffer(tmp_param, &group);\n    /* small table, ignore SQL_BIG_TABLES */\n    my_bool save_big_tables= thd->variables.big_tables; \n    thd->variables.big_tables= FALSE;\n    tmp_tables[cnt]=create_tmp_table(thd, tmp_param, temp_fields,\n                                     (ORDER*) &group, 0, 0,\n                                     TMP_TABLE_ALL_COLUMNS, HA_POS_ERROR, &empty_clex_str);\n    thd->variables.big_tables= save_big_tables;\n    if (!tmp_tables[cnt])\n      DBUG_RETURN(1);\n    tmp_tables[cnt]->file->extra(HA_EXTRA_WRITE_CACHE);\n  }\n  join->tmp_table_keep_current_rowid= TRUE;\n  DBUG_RETURN(0);\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"records.h\"\n#include \"filesort.h\"\n#include \"sql_partition.h\"\n#include \"sql_insert.h\"\n#include \"sp_head.h\"\n#include \"sql_cache.h\"\n#include \"probes_mysql.h\"\n#include \"sql_parse.h\"\n#include \"sql_statistics.h\"\n#include \"sql_acl.h\"\n#include \"sql_base.h\"\n#include \"sql_priv.h\"\n#include \"sql_derived.h\"\n#include \"sql_update.h\"\n#include \"key.h\"\n#include \"mariadb.h\"\n#include \"sql_view.h\"\n#include \"debug_sync.h\"\n#include \"sql_trigger.h\"\n#include \"sql_select.h\"\n\n// Type Definitions:\n// JOIN:\nclass JOIN :public Sql_alloc\n{\nprivate:\n  JOIN(const JOIN &rhs);                        /**< not implemented */\n  JOIN& operator=(const JOIN &rhs);             /**< not implemented */\n\nprotected:\n\n  /**\n    The subset of the state of a JOIN that represents an optimized query\n    execution plan. Allows saving/restoring different JOIN plans for the same\n    query.\n  */\n  class Join_plan_state {\n  public:\n    DYNAMIC_ARRAY keyuse;        /* Copy of the JOIN::keyuse array. */\n    POSITION *best_positions;    /* Copy of JOIN::best_positions */\n    /* Copies of the JOIN_TAB::keyuse pointers for each JOIN_TAB. */\n    KEYUSE **join_tab_keyuse;\n    /* Copies of JOIN_TAB::checked_keys for each JOIN_TAB. */\n    key_map *join_tab_checked_keys;\n    SJ_MATERIALIZATION_INFO **sj_mat_info;\n    my_bool error;\n  public:\n    Join_plan_state(uint tables) : error(0)\n    {   \n      keyuse.elements= 0;\n      keyuse.buffer= NULL;\n      keyuse.malloc_flags= 0;\n      best_positions= 0;                       ...\n\n// JOIN:\nclass JOIN\n\n// Called Methods (top 10):\n// OPTION_SAFE_UPDATES from sql/sql_priv.h:\n<empty>\n"
  },
  {
    "repository": "linux",
    "cve_id": "CVE-2022-3239",
    "cwe_list": [
      "CWE-416"
    ],
    "commit_hash": "c08eadca1bdfa099e20a32f8fa4b52b2f672236d",
    "short_hash": "c08eadca",
    "vulnerableMethods_before": [
      {
        "filename": "em28xx-cards.c",
        "method_name": "vulnerable_function",
        "raw_code": "static int em28xx_usb_probe(struct usb_interface *intf,\n\t\t\t    const struct usb_device_id *id)\n{\n\tstruct usb_device *udev;\n\tstruct em28xx *dev = NULL;\n\tint retval;\n\tbool has_vendor_audio = false, has_video = false, has_dvb = false;\n\tint i, nr, try_bulk;\n\tconst int ifnum = intf->altsetting[0].desc.bInterfaceNumber;\n\tchar *speed;\n\n\tudev = usb_get_dev(interface_to_usbdev(intf));\n\n\t/* Check to see next free device and mark as used */\n\tdo {\n\t\tnr = find_first_zero_bit(em28xx_devused, EM28XX_MAXBOARDS);\n\t\tif (nr >= EM28XX_MAXBOARDS) {\n\t\t\t/* No free device slots */\n\t\t\tdev_err(&intf->dev,\n\t\t\t\t\"Driver supports up to %i em28xx boards.\\n\",\n\t\t\t       EM28XX_MAXBOARDS);\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto err_no_slot;\n\t\t}\n\t} while (test_and_set_bit(nr, em28xx_devused));\n\n\t/* Don't register audio interfaces */\n\tif (intf->altsetting[0].desc.bInterfaceClass == USB_CLASS_AUDIO) {\n\t\tdev_info(&intf->dev,\n\t\t\t\"audio device (%04x:%04x): interface %i, class %i\\n\",\n\t\t\tle16_to_cpu(udev->descriptor.idVendor),\n\t\t\tle16_to_cpu(udev->descriptor.idProduct),\n\t\t\tifnum,\n\t\t\tintf->altsetting[0].desc.bInterfaceClass);\n\n\t\tretval = -ENODEV;\n\t\tgoto err;\n\t}\n\n\t/* allocate memory for our device state and initialize it */\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev) {\n\t\tretval = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t/* compute alternate max packet sizes */\n\tdev->alt_max_pkt_size_isoc = kcalloc(intf->num_altsetting,\n\t\t\t\t\t     sizeof(dev->alt_max_pkt_size_isoc[0]),\n\t\t\t\t\t     GFP_KERNEL);\n\tif (!dev->alt_max_pkt_size_isoc) {\n\t\tkfree(dev);\n\t\tretval = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t/* Get endpoints */\n\tfor (i = 0; i < intf->num_altsetting; i++) {\n\t\tint ep;\n\n\t\tfor (ep = 0;\n\t\t     ep < intf->altsetting[i].desc.bNumEndpoints;\n\t\t     ep++)\n\t\t\tem28xx_check_usb_descriptor(dev, udev, intf,\n\t\t\t\t\t\t    i, ep,\n\t\t\t\t\t\t    &has_vendor_audio,\n\t\t\t\t\t\t    &has_video,\n\t\t\t\t\t\t    &has_dvb);\n\t}\n\n\tif (!(has_vendor_audio || has_video || has_dvb)) {\n\t\tretval = -ENODEV;\n\t\tgoto err_free;\n\t}\n\n\tswitch (udev->speed) {\n\tcase USB_SPEED_LOW:\n\t\tspeed = \"1.5\";\n\t\tbreak;\n\tcase USB_SPEED_UNKNOWN:\n\tcase USB_SPEED_FULL:\n\t\tspeed = \"12\";\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\n\t\tspeed = \"480\";\n\t\tbreak;\n\tdefault:\n\t\tspeed = \"unknown\";\n\t}\n\n\tdev_info(&intf->dev,\n\t\t\"New device %s %s @ %s Mbps (%04x:%04x, interface %d, class %d)\\n\",\n\t\tudev->manufacturer ? udev->manufacturer : \"\",\n\t\tudev->product ? udev->product : \"\",\n\t\tspeed,\n\t\tle16_to_cpu(udev->descriptor.idVendor),\n\t\tle16_to_cpu(udev->descriptor.idProduct),\n\t\tifnum,\n\t\tintf->altsetting->desc.bInterfaceNumber);\n\n\t/*\n\t * Make sure we have 480 Mbps of bandwidth, otherwise things like\n\t * video stream wouldn't likely work, since 12 Mbps is generally\n\t * not enough even for most Digital TV streams.\n\t */\n\tif (udev->speed != USB_SPEED_HIGH && disable_usb_speed_check == 0) {\n\t\tdev_err(&intf->dev, \"Device initialization failed.\\n\");\n\t\tdev_err(&intf->dev,\n\t\t\t\"Device must be connected to a high-speed USB 2.0 port.\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto err_free;\n\t}\n\n\tdev->devno = nr;\n\tdev->model = id->driver_info;\n\tdev->alt   = -1;\n\tdev->is_audio_only = has_vendor_audio && !(has_video || has_dvb);\n\tdev->has_video = has_video;\n\tdev->ifnum = ifnum;\n\n\tdev->ts = PRIMARY_TS;\n\tsnprintf(dev->name, 28, \"em28xx\");\n\tdev->dev_next = NULL;\n\n\tif (has_vendor_audio) {\n\t\tdev_info(&intf->dev,\n\t\t\t\"Audio interface %i found (Vendor Class)\\n\", ifnum);\n\t\tdev->usb_audio_type = EM28XX_USB_AUDIO_VENDOR;\n\t}\n\t/* Checks if audio is provided by a USB Audio Class intf */\n\tfor (i = 0; i < udev->config->desc.bNumInterfaces; i++) {\n\t\tstruct usb_interface *uif = udev->config->interface[i];\n\n\t\tif (uif->altsetting[0].desc.bInterfaceClass == USB_CLASS_AUDIO) {\n\t\t\tif (has_vendor_audio)\n\t\t\t\tdev_err(&intf->dev,\n\t\t\t\t\t\"em28xx: device seems to have vendor AND usb audio class interfaces !\\n\"\n\t\t\t\t\t\"\\t\\tThe vendor interface will be ignored. Please contact the developers <linux-media@vger.kernel.org>\\n\");\n\t\t\tdev->usb_audio_type = EM28XX_USB_AUDIO_CLASS;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (has_video)\n\t\tdev_info(&intf->dev, \"Video interface %i found:%s%s\\n\",\n\t\t\tifnum,\n\t\t\tdev->analog_ep_bulk ? \" bulk\" : \"\",\n\t\t\tdev->analog_ep_isoc ? \" isoc\" : \"\");\n\tif (has_dvb)\n\t\tdev_info(&intf->dev, \"DVB interface %i found:%s%s\\n\",\n\t\t\tifnum,\n\t\t\tdev->dvb_ep_bulk ? \" bulk\" : \"\",\n\t\t\tdev->dvb_ep_isoc ? \" isoc\" : \"\");\n\n\tdev->num_alt = intf->num_altsetting;\n\n\tif ((unsigned int)card[nr] < em28xx_bcount)\n\t\tdev->model = card[nr];\n\n\t/* save our data pointer in this intf device */\n\tusb_set_intfdata(intf, dev);\n\n\t/* allocate device struct and check if the device is a webcam */\n\tmutex_init(&dev->lock);\n\tretval = em28xx_init_dev(dev, udev, intf, nr);\n\tif (retval)\n\t\tgoto err_free;\n\n\tif (usb_xfer_mode < 0) {\n\t\tif (dev->is_webcam)\n\t\t\ttry_bulk = 1;\n\t\telse\n\t\t\ttry_bulk = 0;\n\t} else {\n\t\ttry_bulk = usb_xfer_mode > 0;\n\t}\n\n\t/* Disable V4L2 if the device doesn't have a decoder or image sensor */\n\tif (has_video &&\n\t    dev->board.decoder == EM28XX_NODECODER &&\n\t    dev->em28xx_sensor == EM28XX_NOSENSOR) {\n\t\tdev_err(&intf->dev,\n\t\t\t\"Currently, V4L2 is not supported on this model\\n\");\n\t\thas_video = false;\n\t\tdev->has_video = false;\n\t}\n\n\tif (dev->board.has_dual_ts &&\n\t    (dev->tuner_type != TUNER_ABSENT || INPUT(0)->type)) {\n\t\t/*\n\t\t * The logic with sets alternate is not ready for dual-tuners\n\t\t * which analog modes.\n\t\t */\n\t\tdev_err(&intf->dev,\n\t\t\t\"We currently don't support analog TV or stream capture on dual tuners.\\n\");\n\t\thas_video = false;\n\t}\n\n\t/* Select USB transfer types to use */\n\tif (has_video) {\n\t\tif (!dev->analog_ep_isoc || (try_bulk && dev->analog_ep_bulk))\n\t\t\tdev->analog_xfer_bulk = 1;\n\t\tdev_info(&intf->dev, \"analog set to %s mode.\\n\",\n\t\t\tdev->analog_xfer_bulk ? \"bulk\" : \"isoc\");\n\t}\n\tif (has_dvb) {\n\t\tif (!dev->dvb_ep_isoc || (try_bulk && dev->dvb_ep_bulk))\n\t\t\tdev->dvb_xfer_bulk = 1;\n\t\tdev_info(&intf->dev, \"dvb set to %s mode.\\n\",\n\t\t\tdev->dvb_xfer_bulk ? \"bulk\" : \"isoc\");\n\t}\n\n\tif (dev->board.has_dual_ts && em28xx_duplicate_dev(dev) == 0) {\n\t\tdev->dev_next->ts = SECONDARY_TS;\n\t\tdev->dev_next->alt   = -1;\n\t\tdev->dev_next->is_audio_only = has_vendor_audio &&\n\t\t\t\t\t\t!(has_video || has_dvb);\n\t\tdev->dev_next->has_video = false;\n\t\tdev->dev_next->ifnum = ifnum;\n\t\tdev->dev_next->model = id->driver_info;\n\n\t\tmutex_init(&dev->dev_next->lock);\n\t\tretval = em28xx_init_dev(dev->dev_next, udev, intf,\n\t\t\t\t\t dev->dev_next->devno);\n\t\tif (retval)\n\t\t\tgoto err_free;\n\n\t\tdev->dev_next->board.ir_codes = NULL; /* No IR for 2nd tuner */\n\t\tdev->dev_next->board.has_ir_i2c = 0; /* No IR for 2nd tuner */\n\n\t\tif (usb_xfer_mode < 0) {\n\t\t\tif (dev->dev_next->is_webcam)\n\t\t\t\ttry_bulk = 1;\n\t\t\telse\n\t\t\t\ttry_bulk = 0;\n\t\t} else {\n\t\t\ttry_bulk = usb_xfer_mode > 0;\n\t\t}\n\n\t\t/* Select USB transfer types to use */\n\t\tif (has_dvb) {\n\t\t\tif (!dev->dvb_ep_isoc_ts2 ||\n\t\t\t    (try_bulk && dev->dvb_ep_bulk_ts2))\n\t\t\t\tdev->dev_next->dvb_xfer_bulk = 1;\n\t\t\tdev_info(&dev->intf->dev, \"dvb ts2 set to %s mode.\\n\",\n\t\t\t\t dev->dev_next->dvb_xfer_bulk ? \"bulk\" : \"isoc\");\n\t\t}\n\n\t\tdev->dev_next->dvb_ep_isoc = dev->dvb_ep_isoc_ts2;\n\t\tdev->dev_next->dvb_ep_bulk = dev->dvb_ep_bulk_ts2;\n\t\tdev->dev_next->dvb_max_pkt_size_isoc = dev->dvb_max_pkt_size_isoc_ts2;\n\t\tdev->dev_next->dvb_alt_isoc = dev->dvb_alt_isoc;\n\n\t\t/* Configure hardware to support TS2*/\n\t\tif (dev->dvb_xfer_bulk) {\n\t\t\t/* The ep4 and ep5 are configured for BULK */\n\t\t\tem28xx_write_reg(dev, 0x0b, 0x96);\n\t\t\tmdelay(100);\n\t\t\tem28xx_write_reg(dev, 0x0b, 0x80);\n\t\t\tmdelay(100);\n\t\t} else {\n\t\t\t/* The ep4 and ep5 are configured for ISO */\n\t\t\tem28xx_write_reg(dev, 0x0b, 0x96);\n\t\t\tmdelay(100);\n\t\t\tem28xx_write_reg(dev, 0x0b, 0x82);\n\t\t\tmdelay(100);\n\t\t}\n\n\t\tkref_init(&dev->dev_next->ref);\n\t}\n\n\tkref_init(&dev->ref);\n\n\trequest_modules(dev);\n\n\t/*\n\t * Do it at the end, to reduce dynamic configuration changes during\n\t * the device init. Yet, as request_modules() can be async, the\n\t * topology will likely change after the load of the em28xx subdrivers.\n\t */\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tretval = media_device_register(dev->media_dev);\n#endif\n\n\treturn 0;\n\nerr_free:\n\tkfree(dev->alt_max_pkt_size_isoc);\n\tkfree(dev);\n\nerr:\n\tclear_bit(nr, em28xx_devused);\n\nerr_no_slot:\n\tusb_put_dev(udev);\n\treturn retval;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "em28xx-cards.c",
        "method_name": "fixed_function",
        "raw_code": "static int em28xx_usb_probe(struct usb_interface *intf,\n\t\t\t    const struct usb_device_id *id)\n{\n\tstruct usb_device *udev;\n\tstruct em28xx *dev = NULL;\n\tint retval;\n\tbool has_vendor_audio = false, has_video = false, has_dvb = false;\n\tint i, nr, try_bulk;\n\tconst int ifnum = intf->altsetting[0].desc.bInterfaceNumber;\n\tchar *speed;\n\n\tudev = usb_get_dev(interface_to_usbdev(intf));\n\n\t/* Check to see next free device and mark as used */\n\tdo {\n\t\tnr = find_first_zero_bit(em28xx_devused, EM28XX_MAXBOARDS);\n\t\tif (nr >= EM28XX_MAXBOARDS) {\n\t\t\t/* No free device slots */\n\t\t\tdev_err(&intf->dev,\n\t\t\t\t\"Driver supports up to %i em28xx boards.\\n\",\n\t\t\t       EM28XX_MAXBOARDS);\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto err_no_slot;\n\t\t}\n\t} while (test_and_set_bit(nr, em28xx_devused));\n\n\t/* Don't register audio interfaces */\n\tif (intf->altsetting[0].desc.bInterfaceClass == USB_CLASS_AUDIO) {\n\t\tdev_info(&intf->dev,\n\t\t\t\"audio device (%04x:%04x): interface %i, class %i\\n\",\n\t\t\tle16_to_cpu(udev->descriptor.idVendor),\n\t\t\tle16_to_cpu(udev->descriptor.idProduct),\n\t\t\tifnum,\n\t\t\tintf->altsetting[0].desc.bInterfaceClass);\n\n\t\tretval = -ENODEV;\n\t\tgoto err;\n\t}\n\n\t/* allocate memory for our device state and initialize it */\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev) {\n\t\tretval = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t/* compute alternate max packet sizes */\n\tdev->alt_max_pkt_size_isoc = kcalloc(intf->num_altsetting,\n\t\t\t\t\t     sizeof(dev->alt_max_pkt_size_isoc[0]),\n\t\t\t\t\t     GFP_KERNEL);\n\tif (!dev->alt_max_pkt_size_isoc) {\n\t\tkfree(dev);\n\t\tretval = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t/* Get endpoints */\n\tfor (i = 0; i < intf->num_altsetting; i++) {\n\t\tint ep;\n\n\t\tfor (ep = 0;\n\t\t     ep < intf->altsetting[i].desc.bNumEndpoints;\n\t\t     ep++)\n\t\t\tem28xx_check_usb_descriptor(dev, udev, intf,\n\t\t\t\t\t\t    i, ep,\n\t\t\t\t\t\t    &has_vendor_audio,\n\t\t\t\t\t\t    &has_video,\n\t\t\t\t\t\t    &has_dvb);\n\t}\n\n\tif (!(has_vendor_audio || has_video || has_dvb)) {\n\t\tretval = -ENODEV;\n\t\tgoto err_free;\n\t}\n\n\tswitch (udev->speed) {\n\tcase USB_SPEED_LOW:\n\t\tspeed = \"1.5\";\n\t\tbreak;\n\tcase USB_SPEED_UNKNOWN:\n\tcase USB_SPEED_FULL:\n\t\tspeed = \"12\";\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\n\t\tspeed = \"480\";\n\t\tbreak;\n\tdefault:\n\t\tspeed = \"unknown\";\n\t}\n\n\tdev_info(&intf->dev,\n\t\t\"New device %s %s @ %s Mbps (%04x:%04x, interface %d, class %d)\\n\",\n\t\tudev->manufacturer ? udev->manufacturer : \"\",\n\t\tudev->product ? udev->product : \"\",\n\t\tspeed,\n\t\tle16_to_cpu(udev->descriptor.idVendor),\n\t\tle16_to_cpu(udev->descriptor.idProduct),\n\t\tifnum,\n\t\tintf->altsetting->desc.bInterfaceNumber);\n\n\t/*\n\t * Make sure we have 480 Mbps of bandwidth, otherwise things like\n\t * video stream wouldn't likely work, since 12 Mbps is generally\n\t * not enough even for most Digital TV streams.\n\t */\n\tif (udev->speed != USB_SPEED_HIGH && disable_usb_speed_check == 0) {\n\t\tdev_err(&intf->dev, \"Device initialization failed.\\n\");\n\t\tdev_err(&intf->dev,\n\t\t\t\"Device must be connected to a high-speed USB 2.0 port.\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto err_free;\n\t}\n\n\tkref_init(&dev->ref);\n\n\tdev->devno = nr;\n\tdev->model = id->driver_info;\n\tdev->alt   = -1;\n\tdev->is_audio_only = has_vendor_audio && !(has_video || has_dvb);\n\tdev->has_video = has_video;\n\tdev->ifnum = ifnum;\n\n\tdev->ts = PRIMARY_TS;\n\tsnprintf(dev->name, 28, \"em28xx\");\n\tdev->dev_next = NULL;\n\n\tif (has_vendor_audio) {\n\t\tdev_info(&intf->dev,\n\t\t\t\"Audio interface %i found (Vendor Class)\\n\", ifnum);\n\t\tdev->usb_audio_type = EM28XX_USB_AUDIO_VENDOR;\n\t}\n\t/* Checks if audio is provided by a USB Audio Class intf */\n\tfor (i = 0; i < udev->config->desc.bNumInterfaces; i++) {\n\t\tstruct usb_interface *uif = udev->config->interface[i];\n\n\t\tif (uif->altsetting[0].desc.bInterfaceClass == USB_CLASS_AUDIO) {\n\t\t\tif (has_vendor_audio)\n\t\t\t\tdev_err(&intf->dev,\n\t\t\t\t\t\"em28xx: device seems to have vendor AND usb audio class interfaces !\\n\"\n\t\t\t\t\t\"\\t\\tThe vendor interface will be ignored. Please contact the developers <linux-media@vger.kernel.org>\\n\");\n\t\t\tdev->usb_audio_type = EM28XX_USB_AUDIO_CLASS;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (has_video)\n\t\tdev_info(&intf->dev, \"Video interface %i found:%s%s\\n\",\n\t\t\tifnum,\n\t\t\tdev->analog_ep_bulk ? \" bulk\" : \"\",\n\t\t\tdev->analog_ep_isoc ? \" isoc\" : \"\");\n\tif (has_dvb)\n\t\tdev_info(&intf->dev, \"DVB interface %i found:%s%s\\n\",\n\t\t\tifnum,\n\t\t\tdev->dvb_ep_bulk ? \" bulk\" : \"\",\n\t\t\tdev->dvb_ep_isoc ? \" isoc\" : \"\");\n\n\tdev->num_alt = intf->num_altsetting;\n\n\tif ((unsigned int)card[nr] < em28xx_bcount)\n\t\tdev->model = card[nr];\n\n\t/* save our data pointer in this intf device */\n\tusb_set_intfdata(intf, dev);\n\n\t/* allocate device struct and check if the device is a webcam */\n\tmutex_init(&dev->lock);\n\tretval = em28xx_init_dev(dev, udev, intf, nr);\n\tif (retval)\n\t\tgoto err_free;\n\n\tif (usb_xfer_mode < 0) {\n\t\tif (dev->is_webcam)\n\t\t\ttry_bulk = 1;\n\t\telse\n\t\t\ttry_bulk = 0;\n\t} else {\n\t\ttry_bulk = usb_xfer_mode > 0;\n\t}\n\n\t/* Disable V4L2 if the device doesn't have a decoder or image sensor */\n\tif (has_video &&\n\t    dev->board.decoder == EM28XX_NODECODER &&\n\t    dev->em28xx_sensor == EM28XX_NOSENSOR) {\n\t\tdev_err(&intf->dev,\n\t\t\t\"Currently, V4L2 is not supported on this model\\n\");\n\t\thas_video = false;\n\t\tdev->has_video = false;\n\t}\n\n\tif (dev->board.has_dual_ts &&\n\t    (dev->tuner_type != TUNER_ABSENT || INPUT(0)->type)) {\n\t\t/*\n\t\t * The logic with sets alternate is not ready for dual-tuners\n\t\t * which analog modes.\n\t\t */\n\t\tdev_err(&intf->dev,\n\t\t\t\"We currently don't support analog TV or stream capture on dual tuners.\\n\");\n\t\thas_video = false;\n\t}\n\n\t/* Select USB transfer types to use */\n\tif (has_video) {\n\t\tif (!dev->analog_ep_isoc || (try_bulk && dev->analog_ep_bulk))\n\t\t\tdev->analog_xfer_bulk = 1;\n\t\tdev_info(&intf->dev, \"analog set to %s mode.\\n\",\n\t\t\tdev->analog_xfer_bulk ? \"bulk\" : \"isoc\");\n\t}\n\tif (has_dvb) {\n\t\tif (!dev->dvb_ep_isoc || (try_bulk && dev->dvb_ep_bulk))\n\t\t\tdev->dvb_xfer_bulk = 1;\n\t\tdev_info(&intf->dev, \"dvb set to %s mode.\\n\",\n\t\t\tdev->dvb_xfer_bulk ? \"bulk\" : \"isoc\");\n\t}\n\n\tif (dev->board.has_dual_ts && em28xx_duplicate_dev(dev) == 0) {\n\t\tkref_init(&dev->dev_next->ref);\n\n\t\tdev->dev_next->ts = SECONDARY_TS;\n\t\tdev->dev_next->alt   = -1;\n\t\tdev->dev_next->is_audio_only = has_vendor_audio &&\n\t\t\t\t\t\t!(has_video || has_dvb);\n\t\tdev->dev_next->has_video = false;\n\t\tdev->dev_next->ifnum = ifnum;\n\t\tdev->dev_next->model = id->driver_info;\n\n\t\tmutex_init(&dev->dev_next->lock);\n\t\tretval = em28xx_init_dev(dev->dev_next, udev, intf,\n\t\t\t\t\t dev->dev_next->devno);\n\t\tif (retval)\n\t\t\tgoto err_free;\n\n\t\tdev->dev_next->board.ir_codes = NULL; /* No IR for 2nd tuner */\n\t\tdev->dev_next->board.has_ir_i2c = 0; /* No IR for 2nd tuner */\n\n\t\tif (usb_xfer_mode < 0) {\n\t\t\tif (dev->dev_next->is_webcam)\n\t\t\t\ttry_bulk = 1;\n\t\t\telse\n\t\t\t\ttry_bulk = 0;\n\t\t} else {\n\t\t\ttry_bulk = usb_xfer_mode > 0;\n\t\t}\n\n\t\t/* Select USB transfer types to use */\n\t\tif (has_dvb) {\n\t\t\tif (!dev->dvb_ep_isoc_ts2 ||\n\t\t\t    (try_bulk && dev->dvb_ep_bulk_ts2))\n\t\t\t\tdev->dev_next->dvb_xfer_bulk = 1;\n\t\t\tdev_info(&dev->intf->dev, \"dvb ts2 set to %s mode.\\n\",\n\t\t\t\t dev->dev_next->dvb_xfer_bulk ? \"bulk\" : \"isoc\");\n\t\t}\n\n\t\tdev->dev_next->dvb_ep_isoc = dev->dvb_ep_isoc_ts2;\n\t\tdev->dev_next->dvb_ep_bulk = dev->dvb_ep_bulk_ts2;\n\t\tdev->dev_next->dvb_max_pkt_size_isoc = dev->dvb_max_pkt_size_isoc_ts2;\n\t\tdev->dev_next->dvb_alt_isoc = dev->dvb_alt_isoc;\n\n\t\t/* Configure hardware to support TS2*/\n\t\tif (dev->dvb_xfer_bulk) {\n\t\t\t/* The ep4 and ep5 are configured for BULK */\n\t\t\tem28xx_write_reg(dev, 0x0b, 0x96);\n\t\t\tmdelay(100);\n\t\t\tem28xx_write_reg(dev, 0x0b, 0x80);\n\t\t\tmdelay(100);\n\t\t} else {\n\t\t\t/* The ep4 and ep5 are configured for ISO */\n\t\t\tem28xx_write_reg(dev, 0x0b, 0x96);\n\t\t\tmdelay(100);\n\t\t\tem28xx_write_reg(dev, 0x0b, 0x82);\n\t\t\tmdelay(100);\n\t\t}\n\t}\n\n\trequest_modules(dev);\n\n\t/*\n\t * Do it at the end, to reduce dynamic configuration changes during\n\t * the device init. Yet, as request_modules() can be async, the\n\t * topology will likely change after the load of the em28xx subdrivers.\n\t */\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tretval = media_device_register(dev->media_dev);\n#endif\n\n\treturn 0;\n\nerr_free:\n\tkfree(dev->alt_max_pkt_size_isoc);\n\tkfree(dev);\n\nerr:\n\tclear_bit(nr, em28xx_devused);\n\nerr_no_slot:\n\tusb_put_dev(udev);\n\treturn retval;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <media/v4l2-common.h>\n#include <media/tuner.h>\n#include <sound/ac97_codec.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include \"em28xx.h\"\n#include <media/i2c/saa7115.h>\n#include <linux/usb.h>\n#include <dt-bindings/media/tvp5150.h>\n#include <linux/module.h>\n#include <media/drv-intf/msp3400.h>\n#include <media/i2c/tvaudio.h>\n#include <media/tveeprom.h>\n#include <linux/delay.h>\n\n// Type Definitions:\n// usb_interface:\nstruct usb_interface\n\n// em28xx_board:\nstruct em28xx_board {\n\tchar *name;\n\tint vchannels;\n\tint tuner_type;\n\tint tuner_addr;\n\tunsigned int def_i2c_bus;\t/* Default I2C bus */\n\n\t/* i2c flags */\n\tunsigned int tda9887_conf;\n\n\t/* GPIO sequences */\n\tconst struct em28xx_reg_seq *dvb_gpio;\n\tconst struct em28xx_reg_seq *suspend_gpio;\n\tconst struct em28xx_reg_seq *tuner_gpio;\n\tconst struct em28xx_reg_seq *mute_gpio;\n\n\tunsigned int is_em2800:1;\n\tunsigned int has_msp34xx:1;\n\tunsigned int mts_firmware:1;\n\tunsigned int max_range_640_480:1;\n\tunsigned int has_dvb:1;\n\tunsigned int has_dual_ts:1;\n\tunsigned int is_webcam:1;\n\tunsigned int valid:1;\n\tunsigned int has_ir_i2c:1;\n\n\tunsigned char xclk, i2c_speed;\n\tunsigned char radio_addr;\n\tunsigned short tvaudio_addr;\n\n\tenum em28xx_decoder decoder;\n\tenum em28xx_adecoder adecoder;\n\n\tstruct em28xx_input       input[MAX_EM28XX_INPUT];\n\tstruct em28xx_input\t  radio;\n\tchar\t\t\t  *ir_codes;\n\n\t/* LEDs that need to be controlled explicitly */\n\tstruct em28xx_led\t  *leds;\n\n\t/* Buttons */\n\tconst struct em28xx_...\n\n// usb_device_id:\nstatic const struct usb_device_id\n\n// em28xx:\nstruct em28xx\n\n// em28xx_input:\nstruct em28xx_input {\n\tenum enum28xx_itype type;\n\tunsigned int vmux;\n\tenum em28xx_amux amux;\n\tenum em28xx_aout aout;\n\tconst struct em28xx_reg_seq *gpio;\n}\n\n// usb_device:\nstruct usb_device\n\n// em28xx:\nstruct em28xx {\n\tstruct kref ref;\n\n\t// Sub-module data\n\tstruct em28xx_v4l2 *v4l2;\n\tstruct em28xx_dvb *dvb;\n\tstruct em28xx_audio adev;\n\tstruct em28xx_IR *ir;\n\n\t// generic device properties\n\tint model;\t\t// index in the device_data struct\n\tint devno;\t\t// marks the number of this device\n\tenum em28xx_chip_id chip_id;\n\n\tunsigned int is_em25xx:1;\t// em25xx/em276x/7x/8x family bridge\n\tunsigned int disconnected:1;\t// device has been disconnected\n\tunsigned int has_video:1;\n\tunsigned int is_audio_only:1;\n\tunsigned int is_webcam:1;\n\tunsigned int has_msp34xx:1;\n\tunsigned int i2c_speed:2;\n\tenum em28xx_int_audio_type int_audio_type;\n\tenum em28xx_usb_audio_type usb_audio_type;\n\tunsigned char name[32];\n\n\tstruct em28xx_board board;\n\n\tenum em28xx_sensor em28xx_sensor;\t// camera specific\n\n\t// Some older em28xx chips needs a waiting time after writing\n\tunsigned int wait_after_write;\n\n\tstruct list_head\tdevlist;\n\n\tu32 i2s_speed;\t\t// I2S speed for audio digital stream\n\n\tstruct em28xx_audio_mode audio_mode;...\n\n// Called Methods (top 10):\n// em28xx_set_model from drivers/media/usb/em28xx/em28xx-cards.c:\nstatic inline void em28xx_set_model(struct em28xx *dev) /* <=== em28xx_set_model */ \n{\n\tdev->board = em28xx_boards[dev->model];\n\tdev->has_msp34xx = dev->board.has_msp34xx;\n\tdev->is_webcam = dev->board.is_webcam;\n\n\tem28xx_set_xclk_i2c_speed(dev);\n\n\t/* Should be initialized early, for I2C to work */\n\tdev->def_i2c_bus = dev->board.def_i2c_bus;\n}\n\n// EM28XX_R06_I2C_CLK from drivers/media/usb/em28xx/em28xx-reg.h:\n#define EM28XX_R06_I2C_CLK\t0x06 /* <=== drivers/media/usb/em28xx/em28xx-reg.h:63:63:EM28XX_R06_I2C_CLK:0 */ \n\n// EM2820_BOARD_IODATA_GVMVP_SZ from drivers/media/usb/em28xx/em28xx.h:\n#define EM2820_BOARD_IODATA_GVMVP_SZ\t\t  65 /* <=== drivers/media/usb/em28xx/em28xx.h:114:114:EM2820_BOARD_IODATA_GVMVP_SZ:0 */ \n\n// INPUT from drivers/media/usb/em28xx/em28xx.h:\n#define INPUT(nr) (&em28xx_boards[dev->model].input[nr]) /* <=== drivers/media/usb/em28xx/em28xx.h:431:431:INPUT:1 */ \n\n// EM28XX_R0A_CHIPID from drivers/media/usb/em28xx/em28xx-reg.h:\n#define EM28XX_R0A_CHIPID\t0x0a /* <=== drivers/media/usb/em28xx/em28xx-reg.h:76:76:EM28XX_R0A_CHIPID:0 */ \n\n// em28xx_media_device_init from drivers/media/usb/em28xx/em28xx-cards.c:\nstatic int em28xx_media_device_init(struct em28xx *dev, /* <=== em28xx_media_device_init */ \n\t\t\t\t    struct usb_device *udev)\n{\n#ifdef CONFIG_MEDIA_CONTROLLER\n\tstruct media_device *mdev;\n\n\tmdev = kzalloc(sizeof(*mdev), GFP_KERNEL);\n\tif (!mdev)\n\t\treturn -ENOMEM;\n\n\tif (udev->product)\n\t\tmedia_device_usb_init(mdev, udev, udev->product);\n\telse if (udev->manufacturer)\n\t\tmedia_device_usb_init(mdev, udev, udev->manufacturer);\n\telse\n\t\tmedia_device_usb_init(mdev, udev, dev_name(&dev->intf->dev));\n\n\tdev->media_dev = mdev;\n#endif\n\treturn 0;\n}\n\n// EM28XX_CHIPCFG_AUDIOMASK from drivers/media/usb/em28xx/em28xx-reg.h:\n#define EM28XX_CHIPCFG_AUDIOMASK\t\t0x30 /* <=== drivers/media/usb/em28xx/em28xx-reg.h:41:41:EM28XX_CHIPCFG_AUDIOMASK:0 */ \n\n// EM2860_BOARD_EASYCAP from drivers/media/usb/em28xx/em28xx.h:\n#define EM2860_BOARD_EASYCAP\t\t\t  64 /* <=== drivers/media/usb/em28xx/em28xx.h:113:113:EM2860_BOARD_EASYCAP:0 */ \n\n// em28xx_i2c_register from drivers/media/usb/em28xx/em28xx-i2c.c:\nint em28xx_i2c_register(struct em28xx *dev, unsigned int bus, /* <=== em28xx_i2c_register */ \n\t\t\tenum em28xx_i2c_algo_type algo_type)\n{\n\tint retval;\n\n\tif (WARN_ON(!dev->em28xx_write_regs || !dev->em28xx_read_reg ||\n\t\t    !dev->em28xx_write_regs_req || !dev->em28xx_read_reg_req))\n\t\treturn -ENODEV;\n\n\tif (bus >= NUM_I2C_BUSES)\n\t\treturn -ENODEV;\n\n\tdev->i2c_adap[bus] = em28xx_adap_template;\n\tdev->i2c_adap[bus].dev.parent = &dev->intf->dev;\n\tstrscpy(dev->i2c_adap[bus].name, dev_name(&dev->intf->dev),\n\t\tsizeof(dev->i2c_adap[bus].name));\n\n\tdev->i2c_bus[bus].bus = bus;\n\tdev->i2c_bus[bus].algo_type = algo_type;\n\tdev->i2c_bus[bus].dev = dev;\n\tdev->i2c_adap[bus].algo_data = &dev->i2c_bus[bus];\n\n\tretval = i2c_add_adapter(&dev->i2c_adap[bus]);\n\tif (retval < 0) {\n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"%s: i2c_add_adapter failed! retval [%d]\\n\",\n\t\t\t__func__, retval);\n\t\treturn retval;\n\t}\n\n\tdev->i2c_client[bus] = em28xx_client_template;\n\tdev->i2c_client[bus].adapter = &dev->i2c_adap[bus];\n\n\t/* Up to now, all eeproms are at bus 0 */\n\tif (!bus) {\n\t\tretval = em28xx_i2c_eeprom(dev, bus,\n\t\t\t\t\t   &dev->eedata, &dev->eedata_len);\n\t\tif (retval < 0 && retval != -ENODEV) {\n\t\t\tdev_err(&dev->intf->dev,\n\t\t\t\t\"%s: em28xx_i2_eeprom failed! retval [%d]\\n\",\n\t\t\t\t__func__, retval);\n\t\t}\n\t}\n\n\tif (i2c_scan)\n\t\tem28xx_do_i2c_scan(dev, bus);\n\n\treturn 0;\n}\n\n// EM28XX_BOARD_NOT_VALIDATED from drivers/media/usb/em28xx/em28xx.h:\n#define EM28XX_BOARD_NOT_VALIDATED 1 /* <=== drivers/media/usb/em28xx/em28xx.h:165:165:EM28XX_BOARD_NOT_VALIDATED:0 */ \n"
  },
  {
    "repository": "tensorflow",
    "cve_id": "CVE-2021-41210",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "701cfaca222a82afbeeb17496bd718baa65a67d2",
    "short_hash": "701cfaca",
    "vulnerableMethods_before": [
      {
        "filename": "count_ops.cc",
        "method_name": "vulnerable_function",
        "raw_code": "Status SparseCountSparseOutputShapeFn(InferenceContext *c) {\n  auto rank = c->Dim(c->input(0), 1);\n  auto nvals = c->UnknownDim();\n  c->set_output(0, c->Matrix(nvals, rank));  // out.indices\n  c->set_output(1, c->Vector(nvals));        // out.values\n  c->set_output(2, c->Vector(rank));         // out.dense_shape\n  return Status::OK();\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "count_ops.cc",
        "method_name": "fixed_function",
        "raw_code": "Status SparseCountSparseOutputShapeFn(InferenceContext *c) {\n  ShapeHandle unused;\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &unused));\n  auto rank = c->Dim(c->input(0), 1);\n  auto nvals = c->UnknownDim();\n  c->set_output(0, c->Matrix(nvals, rank));  // out.indices\n  c->set_output(1, c->Vector(nvals));        // out.values\n  c->set_output(2, c->Vector(rank));         // out.dense_shape\n  return Status::OK();\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"tensorflow/core/framework/shape_inference.h\"\n#include \"tensorflow/core/framework/common_shape_fns.h\"\n#include \"tensorflow/core/framework/op.h\"\n\n// Type Definitions:\n// DimensionHandle:\nclass DimensionHandle {\n public:\n  DimensionHandle() {}\n  bool SameHandle(DimensionHandle d) const { return ptr_ == d.ptr_; }\n  std::size_t Handle() const { return reinterpret_cast<std::size_t>(ptr_); }\n\n private:\n  DimensionHandle(const Dimension* dim) { ptr_ = dim; }\n\n  const Dimension* operator->() const { return ptr_; }\n  bool IsSet() const { return ptr_ != nullptr; }\n\n  const Dimension* ptr_ = nullptr;\n\n  friend struct DimensionOrConstant;\n  friend class InferenceContext;\n  friend class ShapeInferenceTest;\n  friend class ShapeInferenceTestutil;\n  friend class ::tensorflow::grappler::GraphProperties;\n  friend class ::tensorflow::grappler::SymbolicShapeManager;\n\n  // Intentionally copyable.\n}\n\n// Status:\nclass Status\n\n// Status:\nclass Status {\n public:\n  /// Create a success status.\n  Status() {}\n\n  /// \\brief Create a status with the specified error code and msg as a\n  /// human-readable string containing more detailed information.\n  Status(tensorflow::error::Code code, tensorflow::StringPiece msg)\n      : Status(code, msg, {}) {}\n\n  /// \\brief Create a status with the specified error code, msg, and stack trace\n  /// as a human-readable string containing more detailed information.\n#ifndef SWIG\n  Status(tensorflow::error::Code code, tensorflow::StringPiece msg,\n         std::vector<StackFrame>&& stack_trace);\n#endif\n\n  /// Copy the specified status.\n  Status(const Status& s);\n  Status& operator=(const Status& s);\n#ifndef SWIG\n  Status(Status&& s) noexcept;\n  Status& operator=(Status&& s) noexcept;\n#endif  // SWIG\n\n  static Status OK() { return Status(); }\n\n  /// Returns true iff the status indicates success.\n  bool ok() const { return (state_ == nullptr); }\n\n  tensorflow::error::Code code() const {\n    retu...\n\n// InferenceContext:\nInferenceContext.InferenceContext:ANY(int,AttrSlice&,OpDef&,std.vector&,std.vector&,std.vector&,std.vector&)\n\n// InferenceContext:\nclass InferenceContext {\n public:\n  static constexpr int64_t kUnknownDim = -1;\n  static constexpr int32_t kUnknownRank = -1;\n\n  // <input_tensors> is NULL-padded to be the same size as <input_shapes>.\n  //\n  // Elements of <input_tensors_as_shapes> are used for when a shape function\n  // makes a call to MakeShapeFromShapeTensor; in particular, when the\n  // input_tensors[i] is nullptr but the shape represented by it is partially\n  // known from analysis of the graph.\n  // <input_tensors_as_shapes> can have fewer elements than <input_shapes>.\n  // Values of <input_tensors_as_shapes> do not need to outlive the context.\n  InferenceContext(int graph_def_version, const AttrSlice& attrs,\n                   const OpDef& op_def,\n                   const std::vector<ShapeHandle>& input_shapes,\n                   const std::vector<const Tensor*>& input_tensors,\n                   const std::vector<ShapeHandle>& input_tensors_as_shapes,\n                   std::vector<std::unique_ptr<std::vecto...\n\n// ShapeHandle:\nclass ShapeHandle {\n public:\n  ShapeHandle() {}\n  bool SameHandle(ShapeHandle s) const { return ptr_ == s.ptr_; }\n  std::size_t Handle() const { return reinterpret_cast<std::size_t>(ptr_); }\n\n private:\n  ShapeHandle(const Shape* shape) { ptr_ = shape; }\n  const Shape* operator->() const { return ptr_; }\n  bool IsSet() const { return ptr_ != nullptr; }\n\n  const Shape* ptr_ = nullptr;\n\n  friend class InferenceContext;\n  friend class ShapeInferenceTest;\n  friend class ShapeInferenceTestutil;\n  friend class ::tensorflow::grappler::SymbolicShapeManager;\n\n  // Intentionally copyable.\n}\n\n// Called Methods (top 10):\n// set_output from tensorflow/core/framework/shape_inference.h:\n  void set_output(int idx, ShapeHandle shape) { outputs_.at(idx) = shape; } /* <=== tensorflow.shape_inference.InferenceContext.set_output:void(int,tensorflow.shape_inference.ShapeHandle) */ \n\n// OK from tensorflow/core/platform/status.h:\n  static Status OK() { return Status(); } /* <=== tensorflow.Status.OK:tensorflow.Status() */ \n\n// MakeDim from tensorflow/core/framework/shape_inference.h:\n  inline DimensionHandle MakeDim(DimensionOrConstant d) { /* <=== tensorflow.shape_inference.InferenceContext.MakeDim:tensorflow.shape_inference.DimensionHandle(tensorflow.shape_inference.DimensionOrConstant) */ \n    return shape_manager_.MakeDim(d);\n  }\n\n// ok from tensorflow/core/platform/status.h:\n  bool ok() const { return (state_ == nullptr); } /* <=== tensorflow.Status.ok:bool()<const> */ \n\n// Vector from tensorflow/core/framework/shape_inference.h:\n  ShapeHandle Vector(DimensionOrConstant dim); /* <=== tensorflow.shape_inference.InferenceContext.Vector:tensorflow.shape_inference.ShapeHandle(tensorflow.shape_inference.DimensionOrConstant) */ \n\n// TF_RETURN_IF_ERROR from tensorflow/core/ops/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/common_runtime/eager/tensorflow/core/framework/tensorflow/core/platform/errors.h:\n\n\n// UnknownDim from tensorflow/core/framework/shape_inference.h:\n  inline DimensionHandle UnknownDim() { return MakeDim(kUnknownDim); } /* <=== tensorflow.shape_inference.InferenceContext.UnknownDim:tensorflow.shape_inference.DimensionHandle() */ \n\n// IsSet from tensorflow/core/framework/shape_inference.h:\n  bool IsSet() const { return ptr_ != nullptr; } /* <=== tensorflow.shape_inference.DimensionHandle.IsSet:bool()<const> */ \n"
  },
  {
    "repository": "linux",
    "cve_id": "CVE-2022-1055",
    "cwe_list": [
      "CWE-416"
    ],
    "commit_hash": "04c2a47ffb13c29778e2a14e414ad4cb5a5db4b5",
    "short_hash": "04c2a47f",
    "vulnerableMethods_before": [
      {
        "filename": "cls_api.c",
        "method_name": "vulnerable_function",
        "raw_code": "static int tc_new_tfilter(struct sk_buff *skb, struct nlmsghdr *n,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *tca[TCA_MAX + 1];\n\tchar name[IFNAMSIZ];\n\tstruct tcmsg *t;\n\tu32 protocol;\n\tu32 prio;\n\tbool prio_allocate;\n\tu32 parent;\n\tu32 chain_index;\n\tstruct Qdisc *q = NULL;\n\tstruct tcf_chain_info chain_info;\n\tstruct tcf_chain *chain = NULL;\n\tstruct tcf_block *block;\n\tstruct tcf_proto *tp;\n\tunsigned long cl;\n\tvoid *fh;\n\tint err;\n\tint tp_created;\n\tbool rtnl_held = false;\n\tu32 flags;\n\n\tif (!netlink_ns_capable(skb, net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\nreplay:\n\ttp_created = 0;\n\n\terr = nlmsg_parse_deprecated(n, sizeof(*t), tca, TCA_MAX,\n\t\t\t\t     rtm_tca_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tt = nlmsg_data(n);\n\tprotocol = TC_H_MIN(t->tcm_info);\n\tprio = TC_H_MAJ(t->tcm_info);\n\tprio_allocate = false;\n\tparent = t->tcm_parent;\n\ttp = NULL;\n\tcl = 0;\n\tblock = NULL;\n\tflags = 0;\n\n\tif (prio == 0) {\n\t\t/* If no priority is provided by the user,\n\t\t * we allocate one.\n\t\t */\n\t\tif (n->nlmsg_flags & NLM_F_CREATE) {\n\t\t\tprio = TC_H_MAKE(0x80000000U, 0U);\n\t\t\tprio_allocate = true;\n\t\t} else {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid filter command with priority of zero\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\t/* Find head of filter chain. */\n\n\terr = __tcf_qdisc_find(net, &q, &parent, t->tcm_ifindex, false, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (tcf_proto_check_kind(tca[TCA_KIND], name)) {\n\t\tNL_SET_ERR_MSG(extack, \"Specified TC filter name too long\");\n\t\terr = -EINVAL;\n\t\tgoto errout;\n\t}\n\n\t/* Take rtnl mutex if rtnl_held was set to true on previous iteration,\n\t * block is shared (no qdisc found), qdisc is not unlocked, classifier\n\t * type is not specified, classifier is not unlocked.\n\t */\n\tif (rtnl_held ||\n\t    (q && !(q->ops->cl_ops->flags & QDISC_CLASS_OPS_DOIT_UNLOCKED)) ||\n\t    !tcf_proto_is_unlocked(name)) {\n\t\trtnl_held = true;\n\t\trtnl_lock();\n\t}\n\n\terr = __tcf_qdisc_cl_find(q, parent, &cl, t->tcm_ifindex, extack);\n\tif (err)\n\t\tgoto errout;\n\n\tblock = __tcf_block_find(net, q, cl, t->tcm_ifindex, t->tcm_block_index,\n\t\t\t\t extack);\n\tif (IS_ERR(block)) {\n\t\terr = PTR_ERR(block);\n\t\tgoto errout;\n\t}\n\tblock->classid = parent;\n\n\tchain_index = tca[TCA_CHAIN] ? nla_get_u32(tca[TCA_CHAIN]) : 0;\n\tif (chain_index > TC_ACT_EXT_VAL_MASK) {\n\t\tNL_SET_ERR_MSG(extack, \"Specified chain index exceeds upper limit\");\n\t\terr = -EINVAL;\n\t\tgoto errout;\n\t}\n\tchain = tcf_chain_get(block, chain_index, true);\n\tif (!chain) {\n\t\tNL_SET_ERR_MSG(extack, \"Cannot create specified filter chain\");\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\n\tmutex_lock(&chain->filter_chain_lock);\n\ttp = tcf_chain_tp_find(chain, &chain_info, protocol,\n\t\t\t       prio, prio_allocate);\n\tif (IS_ERR(tp)) {\n\t\tNL_SET_ERR_MSG(extack, \"Filter with specified priority/protocol not found\");\n\t\terr = PTR_ERR(tp);\n\t\tgoto errout_locked;\n\t}\n\n\tif (tp == NULL) {\n\t\tstruct tcf_proto *tp_new = NULL;\n\n\t\tif (chain->flushing) {\n\t\t\terr = -EAGAIN;\n\t\t\tgoto errout_locked;\n\t\t}\n\n\t\t/* Proto-tcf does not exist, create new one */\n\n\t\tif (tca[TCA_KIND] == NULL || !protocol) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Filter kind and protocol must be specified\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto errout_locked;\n\t\t}\n\n\t\tif (!(n->nlmsg_flags & NLM_F_CREATE)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Need both RTM_NEWTFILTER and NLM_F_CREATE to create a new filter\");\n\t\t\terr = -ENOENT;\n\t\t\tgoto errout_locked;\n\t\t}\n\n\t\tif (prio_allocate)\n\t\t\tprio = tcf_auto_prio(tcf_chain_tp_prev(chain,\n\t\t\t\t\t\t\t       &chain_info));\n\n\t\tmutex_unlock(&chain->filter_chain_lock);\n\t\ttp_new = tcf_proto_create(name, protocol, prio, chain,\n\t\t\t\t\t  rtnl_held, extack);\n\t\tif (IS_ERR(tp_new)) {\n\t\t\terr = PTR_ERR(tp_new);\n\t\t\tgoto errout_tp;\n\t\t}\n\n\t\ttp_created = 1;\n\t\ttp = tcf_chain_tp_insert_unique(chain, tp_new, protocol, prio,\n\t\t\t\t\t\trtnl_held);\n\t\tif (IS_ERR(tp)) {\n\t\t\terr = PTR_ERR(tp);\n\t\t\tgoto errout_tp;\n\t\t}\n\t} else {\n\t\tmutex_unlock(&chain->filter_chain_lock);\n\t}\n\n\tif (tca[TCA_KIND] && nla_strcmp(tca[TCA_KIND], tp->ops->kind)) {\n\t\tNL_SET_ERR_MSG(extack, \"Specified filter kind does not match existing one\");\n\t\terr = -EINVAL;\n\t\tgoto errout;\n\t}\n\n\tfh = tp->ops->get(tp, t->tcm_handle);\n\n\tif (!fh) {\n\t\tif (!(n->nlmsg_flags & NLM_F_CREATE)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Need both RTM_NEWTFILTER and NLM_F_CREATE to create a new filter\");\n\t\t\terr = -ENOENT;\n\t\t\tgoto errout;\n\t\t}\n\t} else if (n->nlmsg_flags & NLM_F_EXCL) {\n\t\ttfilter_put(tp, fh);\n\t\tNL_SET_ERR_MSG(extack, \"Filter already exists\");\n\t\terr = -EEXIST;\n\t\tgoto errout;\n\t}\n\n\tif (chain->tmplt_ops && chain->tmplt_ops != tp->ops) {\n\t\tNL_SET_ERR_MSG(extack, \"Chain template is set to a different filter kind\");\n\t\terr = -EINVAL;\n\t\tgoto errout;\n\t}\n\n\tif (!(n->nlmsg_flags & NLM_F_CREATE))\n\t\tflags |= TCA_ACT_FLAGS_REPLACE;\n\tif (!rtnl_held)\n\t\tflags |= TCA_ACT_FLAGS_NO_RTNL;\n\terr = tp->ops->change(net, skb, tp, cl, t->tcm_handle, tca, &fh,\n\t\t\t      flags, extack);\n\tif (err == 0) {\n\t\ttfilter_notify(net, skb, n, tp, block, q, parent, fh,\n\t\t\t       RTM_NEWTFILTER, false, rtnl_held);\n\t\ttfilter_put(tp, fh);\n\t\t/* q pointer is NULL for shared blocks */\n\t\tif (q)\n\t\t\tq->flags &= ~TCQ_F_CAN_BYPASS;\n\t}\n\nerrout:\n\tif (err && tp_created)\n\t\ttcf_chain_tp_delete_empty(chain, tp, rtnl_held, NULL);\nerrout_tp:\n\tif (chain) {\n\t\tif (tp && !IS_ERR(tp))\n\t\t\ttcf_proto_put(tp, rtnl_held, NULL);\n\t\tif (!tp_created)\n\t\t\ttcf_chain_put(chain);\n\t}\n\ttcf_block_release(q, block, rtnl_held);\n\n\tif (rtnl_held)\n\t\trtnl_unlock();\n\n\tif (err == -EAGAIN) {\n\t\t/* Take rtnl lock in case EAGAIN is caused by concurrent flush\n\t\t * of target chain.\n\t\t */\n\t\trtnl_held = true;\n\t\t/* Replay the request. */\n\t\tgoto replay;\n\t}\n\treturn err;\n\nerrout_locked:\n\tmutex_unlock(&chain->filter_chain_lock);\n\tgoto errout;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "cls_api.c",
        "method_name": "fixed_function",
        "raw_code": "static int tc_new_tfilter(struct sk_buff *skb, struct nlmsghdr *n,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *tca[TCA_MAX + 1];\n\tchar name[IFNAMSIZ];\n\tstruct tcmsg *t;\n\tu32 protocol;\n\tu32 prio;\n\tbool prio_allocate;\n\tu32 parent;\n\tu32 chain_index;\n\tstruct Qdisc *q;\n\tstruct tcf_chain_info chain_info;\n\tstruct tcf_chain *chain;\n\tstruct tcf_block *block;\n\tstruct tcf_proto *tp;\n\tunsigned long cl;\n\tvoid *fh;\n\tint err;\n\tint tp_created;\n\tbool rtnl_held = false;\n\tu32 flags;\n\n\tif (!netlink_ns_capable(skb, net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\nreplay:\n\ttp_created = 0;\n\n\terr = nlmsg_parse_deprecated(n, sizeof(*t), tca, TCA_MAX,\n\t\t\t\t     rtm_tca_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tt = nlmsg_data(n);\n\tprotocol = TC_H_MIN(t->tcm_info);\n\tprio = TC_H_MAJ(t->tcm_info);\n\tprio_allocate = false;\n\tparent = t->tcm_parent;\n\ttp = NULL;\n\tcl = 0;\n\tblock = NULL;\n\tq = NULL;\n\tchain = NULL;\n\tflags = 0;\n\n\tif (prio == 0) {\n\t\t/* If no priority is provided by the user,\n\t\t * we allocate one.\n\t\t */\n\t\tif (n->nlmsg_flags & NLM_F_CREATE) {\n\t\t\tprio = TC_H_MAKE(0x80000000U, 0U);\n\t\t\tprio_allocate = true;\n\t\t} else {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid filter command with priority of zero\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\t/* Find head of filter chain. */\n\n\terr = __tcf_qdisc_find(net, &q, &parent, t->tcm_ifindex, false, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (tcf_proto_check_kind(tca[TCA_KIND], name)) {\n\t\tNL_SET_ERR_MSG(extack, \"Specified TC filter name too long\");\n\t\terr = -EINVAL;\n\t\tgoto errout;\n\t}\n\n\t/* Take rtnl mutex if rtnl_held was set to true on previous iteration,\n\t * block is shared (no qdisc found), qdisc is not unlocked, classifier\n\t * type is not specified, classifier is not unlocked.\n\t */\n\tif (rtnl_held ||\n\t    (q && !(q->ops->cl_ops->flags & QDISC_CLASS_OPS_DOIT_UNLOCKED)) ||\n\t    !tcf_proto_is_unlocked(name)) {\n\t\trtnl_held = true;\n\t\trtnl_lock();\n\t}\n\n\terr = __tcf_qdisc_cl_find(q, parent, &cl, t->tcm_ifindex, extack);\n\tif (err)\n\t\tgoto errout;\n\n\tblock = __tcf_block_find(net, q, cl, t->tcm_ifindex, t->tcm_block_index,\n\t\t\t\t extack);\n\tif (IS_ERR(block)) {\n\t\terr = PTR_ERR(block);\n\t\tgoto errout;\n\t}\n\tblock->classid = parent;\n\n\tchain_index = tca[TCA_CHAIN] ? nla_get_u32(tca[TCA_CHAIN]) : 0;\n\tif (chain_index > TC_ACT_EXT_VAL_MASK) {\n\t\tNL_SET_ERR_MSG(extack, \"Specified chain index exceeds upper limit\");\n\t\terr = -EINVAL;\n\t\tgoto errout;\n\t}\n\tchain = tcf_chain_get(block, chain_index, true);\n\tif (!chain) {\n\t\tNL_SET_ERR_MSG(extack, \"Cannot create specified filter chain\");\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\n\tmutex_lock(&chain->filter_chain_lock);\n\ttp = tcf_chain_tp_find(chain, &chain_info, protocol,\n\t\t\t       prio, prio_allocate);\n\tif (IS_ERR(tp)) {\n\t\tNL_SET_ERR_MSG(extack, \"Filter with specified priority/protocol not found\");\n\t\terr = PTR_ERR(tp);\n\t\tgoto errout_locked;\n\t}\n\n\tif (tp == NULL) {\n\t\tstruct tcf_proto *tp_new = NULL;\n\n\t\tif (chain->flushing) {\n\t\t\terr = -EAGAIN;\n\t\t\tgoto errout_locked;\n\t\t}\n\n\t\t/* Proto-tcf does not exist, create new one */\n\n\t\tif (tca[TCA_KIND] == NULL || !protocol) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Filter kind and protocol must be specified\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto errout_locked;\n\t\t}\n\n\t\tif (!(n->nlmsg_flags & NLM_F_CREATE)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Need both RTM_NEWTFILTER and NLM_F_CREATE to create a new filter\");\n\t\t\terr = -ENOENT;\n\t\t\tgoto errout_locked;\n\t\t}\n\n\t\tif (prio_allocate)\n\t\t\tprio = tcf_auto_prio(tcf_chain_tp_prev(chain,\n\t\t\t\t\t\t\t       &chain_info));\n\n\t\tmutex_unlock(&chain->filter_chain_lock);\n\t\ttp_new = tcf_proto_create(name, protocol, prio, chain,\n\t\t\t\t\t  rtnl_held, extack);\n\t\tif (IS_ERR(tp_new)) {\n\t\t\terr = PTR_ERR(tp_new);\n\t\t\tgoto errout_tp;\n\t\t}\n\n\t\ttp_created = 1;\n\t\ttp = tcf_chain_tp_insert_unique(chain, tp_new, protocol, prio,\n\t\t\t\t\t\trtnl_held);\n\t\tif (IS_ERR(tp)) {\n\t\t\terr = PTR_ERR(tp);\n\t\t\tgoto errout_tp;\n\t\t}\n\t} else {\n\t\tmutex_unlock(&chain->filter_chain_lock);\n\t}\n\n\tif (tca[TCA_KIND] && nla_strcmp(tca[TCA_KIND], tp->ops->kind)) {\n\t\tNL_SET_ERR_MSG(extack, \"Specified filter kind does not match existing one\");\n\t\terr = -EINVAL;\n\t\tgoto errout;\n\t}\n\n\tfh = tp->ops->get(tp, t->tcm_handle);\n\n\tif (!fh) {\n\t\tif (!(n->nlmsg_flags & NLM_F_CREATE)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Need both RTM_NEWTFILTER and NLM_F_CREATE to create a new filter\");\n\t\t\terr = -ENOENT;\n\t\t\tgoto errout;\n\t\t}\n\t} else if (n->nlmsg_flags & NLM_F_EXCL) {\n\t\ttfilter_put(tp, fh);\n\t\tNL_SET_ERR_MSG(extack, \"Filter already exists\");\n\t\terr = -EEXIST;\n\t\tgoto errout;\n\t}\n\n\tif (chain->tmplt_ops && chain->tmplt_ops != tp->ops) {\n\t\tNL_SET_ERR_MSG(extack, \"Chain template is set to a different filter kind\");\n\t\terr = -EINVAL;\n\t\tgoto errout;\n\t}\n\n\tif (!(n->nlmsg_flags & NLM_F_CREATE))\n\t\tflags |= TCA_ACT_FLAGS_REPLACE;\n\tif (!rtnl_held)\n\t\tflags |= TCA_ACT_FLAGS_NO_RTNL;\n\terr = tp->ops->change(net, skb, tp, cl, t->tcm_handle, tca, &fh,\n\t\t\t      flags, extack);\n\tif (err == 0) {\n\t\ttfilter_notify(net, skb, n, tp, block, q, parent, fh,\n\t\t\t       RTM_NEWTFILTER, false, rtnl_held);\n\t\ttfilter_put(tp, fh);\n\t\t/* q pointer is NULL for shared blocks */\n\t\tif (q)\n\t\t\tq->flags &= ~TCQ_F_CAN_BYPASS;\n\t}\n\nerrout:\n\tif (err && tp_created)\n\t\ttcf_chain_tp_delete_empty(chain, tp, rtnl_held, NULL);\nerrout_tp:\n\tif (chain) {\n\t\tif (tp && !IS_ERR(tp))\n\t\t\ttcf_proto_put(tp, rtnl_held, NULL);\n\t\tif (!tp_created)\n\t\t\ttcf_chain_put(chain);\n\t}\n\ttcf_block_release(q, block, rtnl_held);\n\n\tif (rtnl_held)\n\t\trtnl_unlock();\n\n\tif (err == -EAGAIN) {\n\t\t/* Take rtnl lock in case EAGAIN is caused by concurrent flush\n\t\t * of target chain.\n\t\t */\n\t\trtnl_held = true;\n\t\t/* Replay the request. */\n\t\tgoto replay;\n\t}\n\treturn err;\n\nerrout_locked:\n\tmutex_unlock(&chain->filter_chain_lock);\n\tgoto errout;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <net/sock.h>\n#include <net/tc_act/tc_vlan.h>\n#include <net/tc_act/tc_mirred.h>\n#include <linux/kmod.h>\n#include <net/pkt_cls.h>\n#include <net/flow_offload.h>\n#include <net/tc_act/tc_gate.h>\n#include <net/net_namespace.h>\n#include <net/tc_act/tc_csum.h>\n#include <net/pkt_sched.h>\n#include <net/tc_act/tc_skbedit.h>\n#include <net/netlink.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/skbuff.h>\n#include <linux/module.h>\n#include <net/tc_act/tc_pedit.h>\n#include <net/tc_act/tc_sample.h>\n#include <net/tc_act/tc_gact.h>\n#include <net/tc_act/tc_mpls.h>\n#include <linux/errno.h>\n#include <linux/jhash.h>\n#include <net/tc_act/tc_police.h>\n#include <net/tc_act/tc_ct.h>\n#include <linux/types.h>\n#include <net/tc_act/tc_tunnel_key.h>\n#include <linux/kernel.h>\n\n// Type Definitions:\n// net:\nstruct net\n\n// Qdisc:\nstruct Qdisc {\n\tint \t\t\t(*enqueue)(struct sk_buff *skb,\n\t\t\t\t\t   struct Qdisc *sch,\n\t\t\t\t\t   struct sk_buff **to_free);\n\tstruct sk_buff *\t(*dequeue)(struct Qdisc *sch);\n\tunsigned int\t\tflags;\n#define TCQ_F_BUILTIN\t\t1\n#define TCQ_F_INGRESS\t\t2\n#define TCQ_F_CAN_BYPASS\t4\n#define TCQ_F_MQROOT\t\t8\n#define TCQ_F_ONETXQUEUE\t0x10 /* dequeue_skb() can assume all skbs are for\n\t\t\t\t      * q->dev_queue : It can test\n\t\t\t\t      * netif_xmit_frozen_or_stopped() before\n\t\t\t\t      * dequeueing next packet.\n\t\t\t\t      * Its true for MQ/MQPRIO slaves, or non\n\t\t\t\t      * multiqueue device.\n\t\t\t\t      */\n#define TCQ_F_WARN_NONWC\t(1 << 16)\n#define TCQ_F_CPUSTATS\t\t0x20 /* run using percpu statistics */\n#define TCQ_F_NOPARENT\t\t0x40 /* root of its hierarchy :\n\t\t\t\t      * qdisc_tree_decrease_qlen() should stop.\n\t\t\t\t      */\n#define TCQ_F_INVISIBLE\t\t0x80 /* invisible by default in dump */\n#define TCQ_F_NOLOCK\t\t0x100 /* qdisc does not require locking */\n#define TCQ_F_OFFLOADED\t\t0x200 /* qdisc is offloaded to HW */\n\tu3...\n\n// tcf_proto:\nstatic struct tcf_proto\n\n// tcf_proto:\nstruct tcf_proto {\n\t/* Fast access part */\n\tstruct tcf_proto __rcu\t*next;\n\tvoid __rcu\t\t*root;\n\n\t/* called under RCU BH lock*/\n\tint\t\t\t(*classify)(struct sk_buff *,\n\t\t\t\t\t    const struct tcf_proto *,\n\t\t\t\t\t    struct tcf_result *);\n\t__be16\t\t\tprotocol;\n\n\t/* All the rest */\n\tu32\t\t\tprio;\n\tvoid\t\t\t*data;\n\tconst struct tcf_proto_ops\t*ops;\n\tstruct tcf_chain\t*chain;\n\t/* Lock protects tcf_proto shared state and can be used by unlocked\n\t * classifiers to protect their private data.\n\t */\n\tspinlock_t\t\tlock;\n\tbool\t\t\tdeleting;\n\trefcount_t\t\trefcnt;\n\tstruct rcu_head\t\trcu;\n\tstruct hlist_node\tdestroy_ht_node;\n}\n\n// netlink_ext_ack:\nstruct netlink_ext_ack {\n\tconst char *_msg;\n\tconst struct nlattr *bad_attr;\n\tconst struct nla_policy *policy;\n\tu8 cookie[NETLINK_MAX_COOKIE_LEN];\n\tu8 cookie_len;\n}\n\n// tcf_block:\nstruct tcf_block\n\n// Qdisc:\nstruct Qdisc\n\n// net:\nstruct net {\n\t/* First cache line can be often dirtied.\n\t * Do not place here read-mostly fields.\n\t */\n\trefcount_t\t\tpassive;\t/* To decide when the network\n\t\t\t\t\t\t * namespace should be freed.\n\t\t\t\t\t\t */\n\tspinlock_t\t\trules_mod_lock;\n\n\tunsigned int\t\tdev_unreg_count;\n\n\tunsigned int\t\tdev_base_seq;\t/* protected by rtnl_mutex */\n\tint\t\t\tifindex;\n\n\tspinlock_t\t\tnsid_lock;\n\tatomic_t\t\tfnhe_genid;\n\n\tstruct list_head\tlist;\t\t/* list of network namespaces */\n\tstruct list_head\texit_list;\t/* To linked to call pernet exit\n\t\t\t\t\t\t * methods on dead net (\n\t\t\t\t\t\t * pernet_ops_rwsem read locked),\n\t\t\t\t\t\t * or to unregister pernet ops\n\t\t\t\t\t\t * (pernet_ops_rwsem write locked).\n\t\t\t\t\t\t */\n\tstruct llist_node\tcleanup_list;\t/* namespaces on death row */\n\n#ifdef CONFIG_KEYS\n\tstruct key_tag\t\t*key_domain;\t/* Key domain of operation tag */\n#endif\n\tstruct user_namespace   *user_ns;\t/* Owning user namespace */\n\tstruct ucounts\t\t*ucounts;\n\tstruct idr\t\tnetns_ids;\n\n\tstruct ns_common\tns;\n\tstruct ref_tracker_dir  refcnt_tracke...\n\n// tcf_block:\nstruct tcf_block {\n\t/* Lock protects tcf_block and lifetime-management data of chains\n\t * attached to the block (refcnt, action_refcnt, explicitly_created).\n\t */\n\tstruct mutex lock;\n\tstruct list_head chain_list;\n\tu32 index; /* block index for shared blocks */\n\tu32 classid; /* which class this block belongs to */\n\trefcount_t refcnt;\n\tstruct net *net;\n\tstruct Qdisc *q;\n\tstruct rw_semaphore cb_lock; /* protects cb_list and offload counters */\n\tstruct flow_block flow_block;\n\tstruct list_head owner_list;\n\tbool keep_dst;\n\tatomic_t offloadcnt; /* Number of oddloaded filters */\n\tunsigned int nooffloaddevcnt; /* Number of devs unable to do offload */\n\tunsigned int lockeddevcnt; /* Number of devs that require rtnl lock. */\n\tstruct {\n\t\tstruct tcf_chain *chain;\n\t\tstruct list_head filter_chain_list;\n\t} chain0;\n\tstruct rcu_head rcu;\n\tDECLARE_HASHTABLE(proto_destroy_ht, 7);\n\tstruct mutex proto_destroy_lock; /* Lock for proto_destroy hashtable. */\n}\n\n// tcf_chain_info:\nstruct tcf_chain_info {\n\tstruct tcf_proto __rcu **pprev;\n\tstruct tcf_proto __rcu *next;\n}\n\n// tcf_chain:\nstruct tcf_chain {\n\t/* Protects filter_chain. */\n\tstruct mutex filter_chain_lock;\n\tstruct tcf_proto __rcu *filter_chain;\n\tstruct list_head list;\n\tstruct tcf_block *block;\n\tu32 index; /* chain index */\n\tunsigned int refcnt;\n\tunsigned int action_refcnt;\n\tbool explicitly_created;\n\tbool flushing;\n\tconst struct tcf_proto_ops *tmplt_ops;\n\tvoid *tmplt_priv;\n\tstruct rcu_head rcu;\n}\n\n// netlink_ext_ack:\nstruct netlink_ext_ack\n\n// nlmsghdr:\nconst struct nlmsghdr\n\n// tcf_chain:\nstruct tcf_chain\n\n// sk_buff:\nstruct sk_buff\n\n// sk_buff:\ntypedef struct sk_buff\n\n// Called Methods (top 10):\n// netdev_refcnt_read from net/core/dev.c:\nint netdev_refcnt_read(const struct net_device *dev) /* <=== netdev_refcnt_read */ \n{\n#ifdef CONFIG_PCPU_DEV_REFCNT\n\tint i, refcnt = 0;\n\n\tfor_each_possible_cpu(i)\n\t\trefcnt += *per_cpu_ptr(dev->pcpu_refcnt, i);\n\treturn refcnt;\n#else\n\treturn refcount_read(&dev->dev_refcnt);\n#endif\n}\n\n// rtnl_lock from net/core/rtnetlink.c:\nvoid rtnl_lock(void) /* <=== rtnl_lock */ \n{\n\tmutex_lock(&rtnl_mutex);\n}\n\n// tcf_chain_tp_find from net/sched/cls_api.c:\nstatic struct tcf_proto *tcf_chain_tp_find(struct tcf_chain *chain, /* <=== tcf_chain_tp_find */ \n\t\t\t\t\t   struct tcf_chain_info *chain_info,\n\t\t\t\t\t   u32 protocol, u32 prio,\n\t\t\t\t\t   bool prio_allocate)\n{\n\tstruct tcf_proto **pprev;\n\tstruct tcf_proto *tp;\n\n\t/* Check the chain for existence of proto-tcf with this priority */\n\tfor (pprev = &chain->filter_chain;\n\t     (tp = tcf_chain_dereference(*pprev, chain));\n\t     pprev = &tp->next) {\n\t\tif (tp->prio >= prio) {\n\t\t\tif (tp->prio == prio) {\n\t\t\t\tif (prio_allocate ||\n\t\t\t\t    (tp->protocol != protocol && protocol))\n\t\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t} else {\n\t\t\t\ttp = NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tchain_info->pprev = pprev;\n\tif (tp) {\n\t\tchain_info->next = tp->next;\n\t\ttcf_proto_get(tp);\n\t} else {\n\t\tchain_info->next = NULL;\n\t}\n\treturn tp;\n}\n\n// nla_put_string from include/net/netlink.h:\nstatic inline int nla_put_string(struct sk_buff *skb, int attrtype, /* <=== nla_put_string */ \n\t\t\t\t const char *str)\n{\n\treturn nla_put(skb, attrtype, strlen(str) + 1, str);\n}\n\n// nlmsg_attrlen from include/net/netlink.h:\nstatic inline int nlmsg_attrlen(const struct nlmsghdr *nlh, int hdrlen) /* <=== nlmsg_attrlen */ \n{\n\treturn nlmsg_len(nlh) - NLMSG_ALIGN(hdrlen);\n}\n\n// tcf_chain_tp_prev from net/sched/cls_api.c:\nstatic struct tcf_proto *tcf_chain_tp_prev(struct tcf_chain *chain, /* <=== tcf_chain_tp_prev */ \n\t\t\t\t\t   struct tcf_chain_info *chain_info)\n{\n\treturn tcf_chain_dereference(*chain_info->pprev, chain);\n}\n\n// __tcf_block_put from net/sched/cls_api.c:\nstatic void __tcf_block_put(struct tcf_block *block, struct Qdisc *q, /* <=== __tcf_block_put */ \n\t\t\t    struct tcf_block_ext_info *ei, bool rtnl_held)\n{\n\tif (refcount_dec_and_mutex_lock(&block->refcnt, &block->lock)) {\n\t\t/* Flushing/putting all chains will cause the block to be\n\t\t * deallocated when last chain is freed. However, if chain_list\n\t\t * is empty, block has to be manually deallocated. After block\n\t\t * reference counter reached 0, it is no longer possible to\n\t\t * increment it or add new chains to block.\n\t\t */\n\t\tbool free_block = list_empty(&block->chain_list);\n\n\t\tmutex_unlock(&block->lock);\n\t\tif (tcf_block_shared(block))\n\t\t\ttcf_block_remove(block, block->net);\n\n\t\tif (q)\n\t\t\ttcf_block_offload_unbind(block, q, ei);\n\n\t\tif (free_block)\n\t\t\ttcf_block_destroy(block);\n\t\telse\n\t\t\ttcf_block_flush_all_chains(block, rtnl_held);\n\t} else if (q) {\n\t\ttcf_block_offload_unbind(block, q, ei);\n\t}\n}\n\n// __tcf_chain_put from net/sched/cls_api.c:\nstatic void __tcf_chain_put(struct tcf_chain *chain, bool by_act, /* <=== __tcf_chain_put */ \n\t\t\t    bool explicitly_created)\n{\n\tstruct tcf_block *block = chain->block;\n\tconst struct tcf_proto_ops *tmplt_ops;\n\tbool free_block = false;\n\tunsigned int refcnt;\n\tvoid *tmplt_priv;\n\n\tmutex_lock(&block->lock);\n\tif (explicitly_created) {\n\t\tif (!chain->explicitly_created) {\n\t\t\tmutex_unlock(&block->lock);\n\t\t\treturn;\n\t\t}\n\t\tchain->explicitly_created = false;\n\t}\n\n\tif (by_act)\n\t\tchain->action_refcnt--;\n\n\t/* tc_chain_notify_delete can't be called while holding block lock.\n\t * However, when block is unlocked chain can be changed concurrently, so\n\t * save these to temporary variables.\n\t */\n\trefcnt = --chain->refcnt;\n\ttmplt_ops = chain->tmplt_ops;\n\ttmplt_priv = chain->tmplt_priv;\n\n\t/* The last dropped non-action reference will trigger notification. */\n\tif (refcnt - chain->action_refcnt == 0 && !by_act) {\n\t\ttc_chain_notify_delete(tmplt_ops, tmplt_priv, chain->index,\n\t\t\t\t       block, NULL, 0, 0, false);\n\t\t/* Last reference to chain, no need to lock. */\n\t\tchain->flushing = false;\n\t}\n\n\tif (refcnt == 0)\n\t\tfree_block = tcf_chain_detach(chain);\n\tmutex_unlock(&block->lock);\n\n\tif (refcnt == 0) {\n\t\ttc_chain_tmplt_del(tmplt_ops, tmplt_priv);\n\t\ttcf_chain_destroy(chain, free_block);\n\t}\n}\n\n// tcf_chain_lookup from net/sched/cls_api.c:\nstatic struct tcf_chain *tcf_chain_lookup(struct tcf_block *block, /* <=== tcf_chain_lookup */ \n\t\t\t\t\t  u32 chain_index)\n{\n\tstruct tcf_chain *chain;\n\n\tASSERT_BLOCK_LOCKED(block);\n\n\tlist_for_each_entry(chain, &block->chain_list, list) {\n\t\tif (chain->index == chain_index)\n\t\t\treturn chain;\n\t}\n\treturn NULL;\n}\n\n// qdisc_match_from_root from net/sched/sch_api.c:\nstatic struct Qdisc *qdisc_match_from_root(struct Qdisc *root, u32 handle) /* <=== qdisc_match_from_root */ \n{\n\tstruct Qdisc *q;\n\n\tif (!qdisc_dev(root))\n\t\treturn (root->handle == handle ? root : NULL);\n\n\tif (!(root->flags & TCQ_F_BUILTIN) &&\n\t    root->handle == handle)\n\t\treturn root;\n\n\thash_for_each_possible_rcu(qdisc_dev(root)->qdisc_hash, q, hash, handle,\n\t\t\t\t   lockdep_rtnl_is_held()) {\n\t\tif (q->handle == handle)\n\t\t\treturn q;\n\t}\n\treturn NULL;\n}\n"
  },
  {
    "repository": "uWebSockets",
    "cve_id": "CVE-2020-36406",
    "cwe_list": [
      "CWE-787"
    ],
    "commit_hash": "03fca626a95130ab80f86adada54b29d27242759",
    "short_hash": "03fca626",
    "vulnerableMethods_before": [
      {
        "filename": "TopicTree.h",
        "method_name": "vulnerable_function",
        "raw_code": "    void publish(Topic *iterator, size_t start, size_t stop, std::string_view topic, std::pair<std::string_view, std::string_view> message) {\n        /* If we already have 64 triggered topics make sure to drain it here */\n        if (numTriggeredTopics == 64) {\n            drain();\n        }\n\n        /* Iterate over all segments in given topic */\n        for (; stop != std::string::npos; start = stop + 1) {\n            stop = topic.find('/', start);\n            std::string_view segment = topic.substr(start, stop - start);\n\n            /* It is very important to disallow wildcards when publishing.\n             * We will not catch EVERY misuse this lazy way, but enough to hinder\n             * explosive recursion.\n             * Terminating wildcards MAY still get triggered along the way, if for\n             * instace the error is found late while iterating the topic segments. */\n            if (segment.length() == 1) {\n                if (segment[0] == '+' || segment[0] == '#') {\n                    return;\n                }\n            }\n\n            /* Do we have a terminating wildcard child? */\n            if (iterator->terminatingWildcardChild) {\n                iterator->terminatingWildcardChild->messages[messageId] = message;\n\n                /* Add this topic to triggered */\n                if (!iterator->terminatingWildcardChild->triggered) {\n                    triggeredTopics[numTriggeredTopics++] = iterator->terminatingWildcardChild;\n                    iterator->terminatingWildcardChild->triggered = true;\n                }\n            }\n\n            /* Do we have a wildcard child? */\n            if (iterator->wildcardChild) {\n                publish(iterator->wildcardChild, stop + 1, stop, topic, message);\n            }\n\n            std::map<std::string_view, Topic *>::iterator it = iterator->children.find(segment);\n            if (it == iterator->children.end()) {\n                /* Stop trying to match by exact string */\n                return;\n            }\n\n            iterator = it->second;\n        }\n\n        /* If we went all the way we matched exactly */\n        iterator->messages[messageId] = message;\n\n        /* Add this topic to triggered */\n        if (!iterator->triggered) {\n            triggeredTopics[numTriggeredTopics++] = iterator;\n            iterator->triggered = true;\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "TopicTree.h",
        "method_name": "fixed_function",
        "raw_code": "    void publish(Topic *iterator, size_t start, size_t stop, std::string_view topic, std::pair<std::string_view, std::string_view> message) {\n\n        /* Iterate over all segments in given topic */\n        for (; stop != std::string::npos; start = stop + 1) {\n            stop = topic.find('/', start);\n            std::string_view segment = topic.substr(start, stop - start);\n\n            /* It is very important to disallow wildcards when publishing.\n             * We will not catch EVERY misuse this lazy way, but enough to hinder\n             * explosive recursion.\n             * Terminating wildcards MAY still get triggered along the way, if for\n             * instace the error is found late while iterating the topic segments. */\n            if (segment.length() == 1) {\n                if (segment[0] == '+' || segment[0] == '#') {\n                    return;\n                }\n            }\n\n            /* Do we have a terminating wildcard child? */\n            if (iterator->terminatingWildcardChild) {\n                iterator->terminatingWildcardChild->messages[messageId] = message;\n\n                /* Add this topic to triggered */\n                if (!iterator->terminatingWildcardChild->triggered) {\n                    /* If we already have 64 triggered topics make sure to drain it here */\n                    if (numTriggeredTopics == 64) {\n                        drain();\n                    }\n\n                    triggeredTopics[numTriggeredTopics++] = iterator->terminatingWildcardChild;\n                    iterator->terminatingWildcardChild->triggered = true;\n                }\n            }\n\n            /* Do we have a wildcard child? */\n            if (iterator->wildcardChild) {\n                publish(iterator->wildcardChild, stop + 1, stop, topic, message);\n            }\n\n            std::map<std::string_view, Topic *>::iterator it = iterator->children.find(segment);\n            if (it == iterator->children.end()) {\n                /* Stop trying to match by exact string */\n                return;\n            }\n\n            iterator = it->second;\n        }\n\n        /* If we went all the way we matched exactly */\n        iterator->messages[messageId] = message;\n\n        /* Add this topic to triggered */\n        if (!iterator->triggered) {\n            /* If we already have 64 triggered topics make sure to drain it here */\n            if (numTriggeredTopics == 64) {\n                drain();\n            }\n\n            triggeredTopics[numTriggeredTopics++] = iterator;\n            iterator->triggered = true;\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <chrono>\n#include <cstring>\n#include <vector>\n#include <functional>\n#include <map>\n#include <list>\n#include <iostream>\n#include <set>\n#include <string_view>\n"
  },
  {
    "repository": "ImageMagick",
    "cve_id": "CVE-2022-28463",
    "cwe_list": [
      "CWE-787"
    ],
    "commit_hash": "ca3654ebf7a439dc736f56f083c9aa98e4464b7f",
    "short_hash": "ca3654eb",
    "vulnerableMethods_before": [
      {
        "filename": "cin.c",
        "method_name": "vulnerable_function",
        "raw_code": "static Image *ReadCINImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define MonoColorType  1\n#define RGBColorType  3\n\n  char\n    property[MagickPathExtent];\n\n  CINInfo\n    cin;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  ssize_t\n    i;\n\n  Quantum\n    *q;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    magick[4],\n    *pixels;\n\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    File information.\n  */\n  offset=0;\n  count=ReadBlob(image,4,magick);\n  offset+=count;\n  if ((count != 4) ||\n      ((LocaleNCompare((char *) magick,\"\\200\\052\\137\\327\",4) != 0)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  memset(&cin,0,sizeof(cin));\n  image->endian=(magick[0] == 0x80) && (magick[1] == 0x2a) &&\n    (magick[2] == 0x5f) && (magick[3] == 0xd7) ? MSBEndian : LSBEndian;\n  cin.file.image_offset=ReadBlobLong(image);\n  offset+=4;\n  cin.file.generic_length=ReadBlobLong(image);\n  offset+=4;\n  cin.file.industry_length=ReadBlobLong(image);\n  offset+=4;\n  cin.file.user_length=ReadBlobLong(image);\n  offset+=4;\n  cin.file.file_size=ReadBlobLong(image);\n  offset+=4;\n  offset+=ReadBlob(image,sizeof(cin.file.version),(unsigned char *)\n    cin.file.version);\n  (void) CopyMagickString(property,cin.file.version,sizeof(cin.file.version));\n  (void) SetImageProperty(image,\"dpx:file.version\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.file.filename),(unsigned char *)\n    cin.file.filename);\n  (void) CopyMagickString(property,cin.file.filename,sizeof(cin.file.filename));\n  (void) SetImageProperty(image,\"dpx:file.filename\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.file.create_date),(unsigned char *)\n    cin.file.create_date);\n  (void) CopyMagickString(property,cin.file.create_date,\n    sizeof(cin.file.create_date));\n  (void) SetImageProperty(image,\"dpx:file.create_date\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.file.create_time),(unsigned char *)\n    cin.file.create_time);\n  (void) CopyMagickString(property,cin.file.create_time,\n    sizeof(cin.file.create_time));\n  (void) SetImageProperty(image,\"dpx:file.create_time\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.file.reserve),(unsigned char *)\n    cin.file.reserve);\n  /*\n    Image information.\n  */\n  cin.image.orientation=(unsigned char) ReadBlobByte(image);\n  offset++;\n  if (cin.image.orientation != (unsigned char) (~0))\n    (void) FormatImageProperty(image,\"dpx:image.orientation\",\"%d\",\n      cin.image.orientation);\n  switch (cin.image.orientation)\n  {\n    default:\n    case 0: image->orientation=TopLeftOrientation; break;\n    case 1: image->orientation=TopRightOrientation; break;\n    case 2: image->orientation=BottomLeftOrientation; break;\n    case 3: image->orientation=BottomRightOrientation; break;\n    case 4: image->orientation=LeftTopOrientation; break;\n    case 5: image->orientation=RightTopOrientation; break;\n    case 6: image->orientation=LeftBottomOrientation; break;\n    case 7: image->orientation=RightBottomOrientation; break;\n  }\n  cin.image.number_channels=(unsigned char) ReadBlobByte(image);\n  offset++;\n  offset+=ReadBlob(image,sizeof(cin.image.reserve1),(unsigned char *)\n    cin.image.reserve1);\n  for (i=0; i < 8; i++)\n  {\n    cin.image.channel[i].designator[0]=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].designator[1]=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].bits_per_pixel=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].reserve=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].pixels_per_line=ReadBlobLong(image);\n    offset+=4;\n    cin.image.channel[i].lines_per_image=ReadBlobLong(image);\n    offset+=4;\n    cin.image.channel[i].min_data=ReadBlobFloat(image);\n    offset+=4;\n    cin.image.channel[i].min_quantity=ReadBlobFloat(image);\n    offset+=4;\n    cin.image.channel[i].max_data=ReadBlobFloat(image);\n    offset+=4;\n    cin.image.channel[i].max_quantity=ReadBlobFloat(image);\n    offset+=4;\n  }\n  cin.image.white_point[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.white_point[0]) != MagickFalse)\n    image->chromaticity.white_point.x=cin.image.white_point[0];\n  cin.image.white_point[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.white_point[1]) != MagickFalse)\n    image->chromaticity.white_point.y=cin.image.white_point[1];\n  cin.image.red_primary_chromaticity[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.red_primary_chromaticity[0]) != MagickFalse)\n    image->chromaticity.red_primary.x=cin.image.red_primary_chromaticity[0];\n  cin.image.red_primary_chromaticity[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.red_primary_chromaticity[1]) != MagickFalse)\n    image->chromaticity.red_primary.y=cin.image.red_primary_chromaticity[1];\n  cin.image.green_primary_chromaticity[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.green_primary_chromaticity[0]) != MagickFalse)\n    image->chromaticity.red_primary.x=cin.image.green_primary_chromaticity[0];\n  cin.image.green_primary_chromaticity[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.green_primary_chromaticity[1]) != MagickFalse)\n    image->chromaticity.green_primary.y=cin.image.green_primary_chromaticity[1];\n  cin.image.blue_primary_chromaticity[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.blue_primary_chromaticity[0]) != MagickFalse)\n    image->chromaticity.blue_primary.x=cin.image.blue_primary_chromaticity[0];\n  cin.image.blue_primary_chromaticity[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.blue_primary_chromaticity[1]) != MagickFalse)\n    image->chromaticity.blue_primary.y=cin.image.blue_primary_chromaticity[1];\n  offset+=ReadBlob(image,sizeof(cin.image.label),(unsigned char *)\n    cin.image.label);\n  (void) CopyMagickString(property,cin.image.label,sizeof(cin.image.label));\n  (void) SetImageProperty(image,\"dpx:image.label\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.image.reserve),(unsigned char *)\n    cin.image.reserve);\n  /*\n    Image data format information.\n  */\n  cin.data_format.interleave=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.packing=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.sign=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.sense=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.line_pad=ReadBlobLong(image);\n  offset+=4;\n  cin.data_format.channel_pad=ReadBlobLong(image);\n  offset+=4;\n  offset+=ReadBlob(image,sizeof(cin.data_format.reserve),(unsigned char *)\n    cin.data_format.reserve);\n  /*\n    Image origination information.\n  */\n  cin.origination.x_offset=ReadBlobSignedLong(image);\n  offset+=4;\n  if ((size_t) cin.origination.x_offset != ~0UL)\n    (void) FormatImageProperty(image,\"dpx:origination.x_offset\",\"%.20g\",\n      (double) cin.origination.x_offset);\n  cin.origination.y_offset=(ssize_t) ReadBlobLong(image);\n  offset+=4;\n  if ((size_t) cin.origination.y_offset != ~0UL)\n    (void) FormatImageProperty(image,\"dpx:origination.y_offset\",\"%.20g\",\n      (double) cin.origination.y_offset);\n  offset+=ReadBlob(image,sizeof(cin.origination.filename),(unsigned char *)\n    cin.origination.filename);\n  (void) CopyMagickString(property,cin.origination.filename,\n    sizeof(cin.origination.filename));\n  (void) SetImageProperty(image,\"dpx:origination.filename\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.origination.create_date),(unsigned char *)\n    cin.origination.create_date);\n  (void) CopyMagickString(property,cin.origination.create_date,\n    sizeof(cin.origination.create_date));\n  (void) SetImageProperty(image,\"dpx:origination.create_date\",property,\n    exception);\n  offset+=ReadBlob(image,sizeof(cin.origination.create_time),(unsigned char *)\n    cin.origination.create_time);\n  (void) CopyMagickString(property,cin.origination.create_time,\n    sizeof(cin.origination.create_time));\n  (void) SetImageProperty(image,\"dpx:origination.create_time\",property,\n    exception);\n  offset+=ReadBlob(image,sizeof(cin.origination.device),(unsigned char *)\n    cin.origination.device);\n  (void) CopyMagickString(property,cin.origination.device,\n    sizeof(cin.origination.device));\n  (void) SetImageProperty(image,\"dpx:origination.device\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.origination.model),(unsigned char *)\n    cin.origination.model);\n  (void) CopyMagickString(property,cin.origination.model,\n    sizeof(cin.origination.model));\n  (void) SetImageProperty(image,\"dpx:origination.model\",property,exception);\n  (void) memset(cin.origination.serial,0, \n    sizeof(cin.origination.serial));\n  offset+=ReadBlob(image,sizeof(cin.origination.serial),(unsigned char *)\n    cin.origination.serial);\n  (void) CopyMagickString(property,cin.origination.serial,\n    sizeof(cin.origination.serial));\n  (void) SetImageProperty(image,\"dpx:origination.serial\",property,exception);\n  cin.origination.x_pitch=ReadBlobFloat(image);\n  offset+=4;\n  cin.origination.y_pitch=ReadBlobFloat(image);\n  offset+=4;\n  cin.origination.gamma=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.origination.gamma) != MagickFalse)\n    image->gamma=cin.origination.gamma;\n  offset+=ReadBlob(image,sizeof(cin.origination.reserve),(unsigned char *)\n    cin.origination.reserve);\n  if ((cin.file.image_offset > 2048) && (cin.file.user_length != 0))\n    {\n      int\n        c;\n\n      /*\n        Image film information.\n      */\n      cin.film.id=ReadBlobByte(image);\n      offset++;\n      c=cin.film.id;\n      if (c != ~0)\n        (void) FormatImageProperty(image,\"dpx:film.id\",\"%d\",cin.film.id);\n      cin.film.type=ReadBlobByte(image);\n      offset++;\n      c=cin.film.type;\n      if (c != ~0)\n        (void) FormatImageProperty(image,\"dpx:film.type\",\"%d\",cin.film.type);\n      cin.film.offset=ReadBlobByte(image);\n      offset++;\n      c=cin.film.offset;\n      if (c != ~0)\n        (void) FormatImageProperty(image,\"dpx:film.offset\",\"%d\",\n          cin.film.offset);\n      cin.film.reserve1=ReadBlobByte(image);\n      offset++;\n      cin.film.prefix=ReadBlobLong(image);\n      offset+=4;\n      if (cin.film.prefix != ~0UL)\n        (void) FormatImageProperty(image,\"dpx:film.prefix\",\"%.20g\",(double)\n          cin.film.prefix);\n      cin.film.count=ReadBlobLong(image);\n      offset+=4;\n      offset+=ReadBlob(image,sizeof(cin.film.format),(unsigned char *)\n        cin.film.format);\n      (void) CopyMagickString(property,cin.film.format,sizeof(cin.film.format));\n      (void) SetImageProperty(image,\"dpx:film.format\",property,exception);\n      cin.film.frame_position=ReadBlobLong(image);\n      offset+=4;\n      if (cin.film.frame_position != ~0UL)\n        (void) FormatImageProperty(image,\"dpx:film.frame_position\",\"%.20g\",\n          (double) cin.film.frame_position);\n      cin.film.frame_rate=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(cin.film.frame_rate) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:film.frame_rate\",\"%g\",\n          cin.film.frame_rate);\n      offset+=ReadBlob(image,sizeof(cin.film.frame_id),(unsigned char *)\n        cin.film.frame_id);\n      (void) CopyMagickString(property,cin.film.frame_id,\n        sizeof(cin.film.frame_id));\n      (void) SetImageProperty(image,\"dpx:film.frame_id\",property,exception);\n      offset+=ReadBlob(image,sizeof(cin.film.slate_info),(unsigned char *)\n        cin.film.slate_info);\n      (void) CopyMagickString(property,cin.film.slate_info,\n        sizeof(cin.film.slate_info));\n      (void) SetImageProperty(image,\"dpx:film.slate_info\",property,exception);\n      offset+=ReadBlob(image,sizeof(cin.film.reserve),(unsigned char *)\n        cin.film.reserve);\n    }\n  if ((cin.file.image_offset > 2048) && (cin.file.user_length != 0))\n    {\n      StringInfo\n        *profile;\n\n      /*\n        User defined data.\n      */\n      if (cin.file.user_length > GetBlobSize(image))\n        ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n      profile=BlobToStringInfo((const unsigned char *) NULL,\n        cin.file.user_length);\n      if (profile == (StringInfo *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      offset+=ReadBlob(image,GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n      (void) SetImageProfile(image,\"dpx:user.data\",profile,exception);\n      profile=DestroyStringInfo(profile);\n    }\n  image->depth=cin.image.channel[0].bits_per_pixel;\n  image->columns=cin.image.channel[0].pixels_per_line;\n  image->rows=cin.image.channel[0].lines_per_image;\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(image);\n    }\n  if (((MagickSizeType) image->columns*image->rows/8) > GetBlobSize(image))\n    ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n  for ( ; offset < (MagickOffsetType) cin.file.image_offset; offset++)\n  {\n    int\n      c;\n\n    c=ReadBlobByte(image);\n    if (c == EOF)\n      break;\n  }\n  if (offset < (MagickOffsetType) cin.file.image_offset)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  (void) SetImageBackgroundColor(image,exception);\n  /*\n    Convert CIN raster image to pixel packets.\n  */\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  SetQuantumQuantum(quantum_info,32);\n  SetQuantumPack(quantum_info,MagickFalse);\n  quantum_type=RGBQuantum;\n  length=GetBytesPerRow(image->columns,3,image->depth,MagickTrue);\n  if (cin.image.number_channels == 1)\n    {\n      quantum_type=GrayQuantum;\n      length=GetBytesPerRow(image->columns,1,image->depth,MagickTrue);\n    }\n  status=SetQuantumPad(image,quantum_info,0);\n  pixels=GetQuantumPixels(quantum_info);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    const void\n      *stream;\n\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    stream=ReadBlobStream(image,length,pixels,&count);\n    if ((size_t) count != length)\n      break;\n    (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n      quantum_type,(unsigned char *) stream,exception);\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  SetQuantumImageType(image,quantum_type);\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  SetImageColorspace(image,LogColorspace,exception);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "cin.c",
        "method_name": "fixed_function",
        "raw_code": "static Image *ReadCINImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define MonoColorType  1\n#define RGBColorType  3\n\n  char\n    property[MagickPathExtent];\n\n  CINInfo\n    cin;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  ssize_t\n    i;\n\n  Quantum\n    *q;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    magick[4],\n    *pixels;\n\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    File information.\n  */\n  offset=0;\n  count=ReadBlob(image,4,magick);\n  offset+=count;\n  if ((count != 4) ||\n      ((LocaleNCompare((char *) magick,\"\\200\\052\\137\\327\",4) != 0)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  memset(&cin,0,sizeof(cin));\n  image->endian=(magick[0] == 0x80) && (magick[1] == 0x2a) &&\n    (magick[2] == 0x5f) && (magick[3] == 0xd7) ? MSBEndian : LSBEndian;\n  cin.file.image_offset=ReadBlobLong(image);\n  if (cin.file.image_offset < 712)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  offset+=4;\n  cin.file.generic_length=ReadBlobLong(image);\n  offset+=4;\n  cin.file.industry_length=ReadBlobLong(image);\n  offset+=4;\n  cin.file.user_length=ReadBlobLong(image);\n  offset+=4;\n  cin.file.file_size=ReadBlobLong(image);\n  offset+=4;\n  offset+=ReadBlob(image,sizeof(cin.file.version),(unsigned char *)\n    cin.file.version);\n  (void) CopyMagickString(property,cin.file.version,sizeof(cin.file.version));\n  (void) SetImageProperty(image,\"dpx:file.version\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.file.filename),(unsigned char *)\n    cin.file.filename);\n  (void) CopyMagickString(property,cin.file.filename,sizeof(cin.file.filename));\n  (void) SetImageProperty(image,\"dpx:file.filename\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.file.create_date),(unsigned char *)\n    cin.file.create_date);\n  (void) CopyMagickString(property,cin.file.create_date,\n    sizeof(cin.file.create_date));\n  (void) SetImageProperty(image,\"dpx:file.create_date\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.file.create_time),(unsigned char *)\n    cin.file.create_time);\n  (void) CopyMagickString(property,cin.file.create_time,\n    sizeof(cin.file.create_time));\n  (void) SetImageProperty(image,\"dpx:file.create_time\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.file.reserve),(unsigned char *)\n    cin.file.reserve);\n  /*\n    Image information.\n  */\n  cin.image.orientation=(unsigned char) ReadBlobByte(image);\n  offset++;\n  if (cin.image.orientation != (unsigned char) (~0))\n    (void) FormatImageProperty(image,\"dpx:image.orientation\",\"%d\",\n      cin.image.orientation);\n  switch (cin.image.orientation)\n  {\n    default:\n    case 0: image->orientation=TopLeftOrientation; break;\n    case 1: image->orientation=TopRightOrientation; break;\n    case 2: image->orientation=BottomLeftOrientation; break;\n    case 3: image->orientation=BottomRightOrientation; break;\n    case 4: image->orientation=LeftTopOrientation; break;\n    case 5: image->orientation=RightTopOrientation; break;\n    case 6: image->orientation=LeftBottomOrientation; break;\n    case 7: image->orientation=RightBottomOrientation; break;\n  }\n  cin.image.number_channels=(unsigned char) ReadBlobByte(image);\n  offset++;\n  offset+=ReadBlob(image,sizeof(cin.image.reserve1),(unsigned char *)\n    cin.image.reserve1);\n  for (i=0; i < 8; i++)\n  {\n    cin.image.channel[i].designator[0]=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].designator[1]=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].bits_per_pixel=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].reserve=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].pixels_per_line=ReadBlobLong(image);\n    offset+=4;\n    cin.image.channel[i].lines_per_image=ReadBlobLong(image);\n    offset+=4;\n    cin.image.channel[i].min_data=ReadBlobFloat(image);\n    offset+=4;\n    cin.image.channel[i].min_quantity=ReadBlobFloat(image);\n    offset+=4;\n    cin.image.channel[i].max_data=ReadBlobFloat(image);\n    offset+=4;\n    cin.image.channel[i].max_quantity=ReadBlobFloat(image);\n    offset+=4;\n  }\n  cin.image.white_point[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.white_point[0]) != MagickFalse)\n    image->chromaticity.white_point.x=cin.image.white_point[0];\n  cin.image.white_point[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.white_point[1]) != MagickFalse)\n    image->chromaticity.white_point.y=cin.image.white_point[1];\n  cin.image.red_primary_chromaticity[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.red_primary_chromaticity[0]) != MagickFalse)\n    image->chromaticity.red_primary.x=cin.image.red_primary_chromaticity[0];\n  cin.image.red_primary_chromaticity[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.red_primary_chromaticity[1]) != MagickFalse)\n    image->chromaticity.red_primary.y=cin.image.red_primary_chromaticity[1];\n  cin.image.green_primary_chromaticity[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.green_primary_chromaticity[0]) != MagickFalse)\n    image->chromaticity.red_primary.x=cin.image.green_primary_chromaticity[0];\n  cin.image.green_primary_chromaticity[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.green_primary_chromaticity[1]) != MagickFalse)\n    image->chromaticity.green_primary.y=cin.image.green_primary_chromaticity[1];\n  cin.image.blue_primary_chromaticity[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.blue_primary_chromaticity[0]) != MagickFalse)\n    image->chromaticity.blue_primary.x=cin.image.blue_primary_chromaticity[0];\n  cin.image.blue_primary_chromaticity[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.blue_primary_chromaticity[1]) != MagickFalse)\n    image->chromaticity.blue_primary.y=cin.image.blue_primary_chromaticity[1];\n  offset+=ReadBlob(image,sizeof(cin.image.label),(unsigned char *)\n    cin.image.label);\n  (void) CopyMagickString(property,cin.image.label,sizeof(cin.image.label));\n  (void) SetImageProperty(image,\"dpx:image.label\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.image.reserve),(unsigned char *)\n    cin.image.reserve);\n  /*\n    Image data format information.\n  */\n  cin.data_format.interleave=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.packing=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.sign=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.sense=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.line_pad=ReadBlobLong(image);\n  offset+=4;\n  cin.data_format.channel_pad=ReadBlobLong(image);\n  offset+=4;\n  offset+=ReadBlob(image,sizeof(cin.data_format.reserve),(unsigned char *)\n    cin.data_format.reserve);\n  /*\n    Image origination information.\n  */\n  cin.origination.x_offset=ReadBlobSignedLong(image);\n  offset+=4;\n  if ((size_t) cin.origination.x_offset != ~0UL)\n    (void) FormatImageProperty(image,\"dpx:origination.x_offset\",\"%.20g\",\n      (double) cin.origination.x_offset);\n  cin.origination.y_offset=(ssize_t) ReadBlobLong(image);\n  offset+=4;\n  if ((size_t) cin.origination.y_offset != ~0UL)\n    (void) FormatImageProperty(image,\"dpx:origination.y_offset\",\"%.20g\",\n      (double) cin.origination.y_offset);\n  offset+=ReadBlob(image,sizeof(cin.origination.filename),(unsigned char *)\n    cin.origination.filename);\n  (void) CopyMagickString(property,cin.origination.filename,\n    sizeof(cin.origination.filename));\n  (void) SetImageProperty(image,\"dpx:origination.filename\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.origination.create_date),(unsigned char *)\n    cin.origination.create_date);\n  (void) CopyMagickString(property,cin.origination.create_date,\n    sizeof(cin.origination.create_date));\n  (void) SetImageProperty(image,\"dpx:origination.create_date\",property,\n    exception);\n  offset+=ReadBlob(image,sizeof(cin.origination.create_time),(unsigned char *)\n    cin.origination.create_time);\n  (void) CopyMagickString(property,cin.origination.create_time,\n    sizeof(cin.origination.create_time));\n  (void) SetImageProperty(image,\"dpx:origination.create_time\",property,\n    exception);\n  offset+=ReadBlob(image,sizeof(cin.origination.device),(unsigned char *)\n    cin.origination.device);\n  (void) CopyMagickString(property,cin.origination.device,\n    sizeof(cin.origination.device));\n  (void) SetImageProperty(image,\"dpx:origination.device\",property,exception);\n  offset+=ReadBlob(image,sizeof(cin.origination.model),(unsigned char *)\n    cin.origination.model);\n  (void) CopyMagickString(property,cin.origination.model,\n    sizeof(cin.origination.model));\n  (void) SetImageProperty(image,\"dpx:origination.model\",property,exception);\n  (void) memset(cin.origination.serial,0, \n    sizeof(cin.origination.serial));\n  offset+=ReadBlob(image,sizeof(cin.origination.serial),(unsigned char *)\n    cin.origination.serial);\n  (void) CopyMagickString(property,cin.origination.serial,\n    sizeof(cin.origination.serial));\n  (void) SetImageProperty(image,\"dpx:origination.serial\",property,exception);\n  cin.origination.x_pitch=ReadBlobFloat(image);\n  offset+=4;\n  cin.origination.y_pitch=ReadBlobFloat(image);\n  offset+=4;\n  cin.origination.gamma=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.origination.gamma) != MagickFalse)\n    image->gamma=cin.origination.gamma;\n  offset+=ReadBlob(image,sizeof(cin.origination.reserve),(unsigned char *)\n    cin.origination.reserve);\n  if ((cin.file.image_offset > 2048) && (cin.file.user_length != 0))\n    {\n      int\n        c;\n\n      /*\n        Image film information.\n      */\n      cin.film.id=ReadBlobByte(image);\n      offset++;\n      c=cin.film.id;\n      if (c != ~0)\n        (void) FormatImageProperty(image,\"dpx:film.id\",\"%d\",cin.film.id);\n      cin.film.type=ReadBlobByte(image);\n      offset++;\n      c=cin.film.type;\n      if (c != ~0)\n        (void) FormatImageProperty(image,\"dpx:film.type\",\"%d\",cin.film.type);\n      cin.film.offset=ReadBlobByte(image);\n      offset++;\n      c=cin.film.offset;\n      if (c != ~0)\n        (void) FormatImageProperty(image,\"dpx:film.offset\",\"%d\",\n          cin.film.offset);\n      cin.film.reserve1=ReadBlobByte(image);\n      offset++;\n      cin.film.prefix=ReadBlobLong(image);\n      offset+=4;\n      if (cin.film.prefix != ~0UL)\n        (void) FormatImageProperty(image,\"dpx:film.prefix\",\"%.20g\",(double)\n          cin.film.prefix);\n      cin.film.count=ReadBlobLong(image);\n      offset+=4;\n      offset+=ReadBlob(image,sizeof(cin.film.format),(unsigned char *)\n        cin.film.format);\n      (void) CopyMagickString(property,cin.film.format,sizeof(cin.film.format));\n      (void) SetImageProperty(image,\"dpx:film.format\",property,exception);\n      cin.film.frame_position=ReadBlobLong(image);\n      offset+=4;\n      if (cin.film.frame_position != ~0UL)\n        (void) FormatImageProperty(image,\"dpx:film.frame_position\",\"%.20g\",\n          (double) cin.film.frame_position);\n      cin.film.frame_rate=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(cin.film.frame_rate) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:film.frame_rate\",\"%g\",\n          cin.film.frame_rate);\n      offset+=ReadBlob(image,sizeof(cin.film.frame_id),(unsigned char *)\n        cin.film.frame_id);\n      (void) CopyMagickString(property,cin.film.frame_id,\n        sizeof(cin.film.frame_id));\n      (void) SetImageProperty(image,\"dpx:film.frame_id\",property,exception);\n      offset+=ReadBlob(image,sizeof(cin.film.slate_info),(unsigned char *)\n        cin.film.slate_info);\n      (void) CopyMagickString(property,cin.film.slate_info,\n        sizeof(cin.film.slate_info));\n      (void) SetImageProperty(image,\"dpx:film.slate_info\",property,exception);\n      offset+=ReadBlob(image,sizeof(cin.film.reserve),(unsigned char *)\n        cin.film.reserve);\n    }\n  if ((cin.file.image_offset > 2048) && (cin.file.user_length != 0))\n    {\n      StringInfo\n        *profile;\n\n      /*\n        User defined data.\n      */\n      if (cin.file.user_length > GetBlobSize(image))\n        ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n      profile=BlobToStringInfo((const unsigned char *) NULL,\n        cin.file.user_length);\n      if (profile == (StringInfo *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      offset+=ReadBlob(image,GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n      (void) SetImageProfile(image,\"dpx:user.data\",profile,exception);\n      profile=DestroyStringInfo(profile);\n    }\n  image->depth=cin.image.channel[0].bits_per_pixel;\n  image->columns=cin.image.channel[0].pixels_per_line;\n  image->rows=cin.image.channel[0].lines_per_image;\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(image);\n    }\n  if (((MagickSizeType) image->columns*image->rows/8) > GetBlobSize(image))\n    ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n  for ( ; offset < (MagickOffsetType) cin.file.image_offset; offset++)\n  {\n    int\n      c;\n\n    c=ReadBlobByte(image);\n    if (c == EOF)\n      break;\n  }\n  if (offset < (MagickOffsetType) cin.file.image_offset)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  (void) SetImageBackgroundColor(image,exception);\n  /*\n    Convert CIN raster image to pixel packets.\n  */\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  SetQuantumQuantum(quantum_info,32);\n  SetQuantumPack(quantum_info,MagickFalse);\n  quantum_type=RGBQuantum;\n  length=GetBytesPerRow(image->columns,3,image->depth,MagickTrue);\n  if (cin.image.number_channels == 1)\n    {\n      quantum_type=GrayQuantum;\n      length=GetBytesPerRow(image->columns,1,image->depth,MagickTrue);\n    }\n  status=SetQuantumPad(image,quantum_info,0);\n  pixels=GetQuantumPixels(quantum_info);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    const void\n      *stream;\n\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    stream=ReadBlobStream(image,length,pixels,&count);\n    if ((size_t) count != length)\n      break;\n    (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n      quantum_type,(unsigned char *) stream,exception);\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  SetQuantumImageType(image,quantum_type);\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  SetImageColorspace(image,LogColorspace,exception);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/timer-private.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/property.h\"\n\n// Type Definitions:\n// Quantum:\ntypedef MagickDoubleType Quantum;\n\n// ImageInfo:\ntypedef struct _ImageInfo ImageInfo;\n\n// MagickBooleanType:\ntypedef enum\n{\n  MagickFalse = 0,\n  MagickTrue = 1\n}\n\n// Image:\nclass MagickPPExport Image\n  {\n  public:\n\n    // Default constructor\n    Image(void);\n\n    // Construct Image from in-memory BLOB\n    Image(const Blob &blob_);\n\n    // Construct Image of specified size from in-memory BLOB\n    Image(const Blob &blob_,const Geometry &size_);\n\n    // Construct Image of specified size and depth from in-memory BLOB\n    Image(const Blob &blob_,const Geometry &size_,const size_t depth_);\n\n    // Construct Image of specified size, depth, and format from\n    // in-memory BLOB\n    Image(const Blob &blob_,const Geometry &size_,const size_t depth_,\n      const std::string &magick_);\n\n    // Construct Image of specified size, and format from in-memory BLOB\n    Image(const Blob &blob_,const Geometry &size_,const std::string &magick_);\n\n    // Construct a blank image canvas of specified size and color\n    Image(const Geometry &size_,const Color &color_);\n\n    // Copy constructor\n    Image(const Image &image_);\n\n    // Copy constructor to copy part of the image\n   ...\n\n// StringInfo:\ntypedef struct _StringInfo\n{\n  char\n    *path;\n\n  unsigned char\n    *datum;\n\n  size_t\n    length,\n    signature;\n\n  char\n    *name;\n} StringInfo;\n\n// ExceptionInfo:\ntypedef struct _ExceptionInfo ExceptionInfo;\n\n// Image:\nMagick.Image.Image:ANY(void)\n\n// CINInfo:\ntypedef struct CINInfo\n{\n  CINFileInfo\n    file;\n\n  CINImageInfo\n    image;\n\n  CINDataFormatInfo\n    data_format;\n\n  CINOriginationInfo\n    origination;\n\n  CINFilmInfo\n    film;\n\n  CINUserInfo\n    user;\n}\n\n// QuantumInfo:\ntypedef struct _QuantumInfo\n  QuantumInfo;\n\n// MagickOffsetType:\ntypedef long long MagickOffsetType;\n\n// _StringInfo:\ntypedef struct _StringInfo\n{\n  char\n    *path;\n\n  unsigned char\n    *datum;\n\n  size_t\n    length,\n    signature;\n\n  char\n    *name;\n}\n\n// _Image:\nstruct _Image\n{\n  ClassType\n    storage_class;\n\n  ColorspaceType\n    colorspace;         /* colorspace of image data */\n\n  CompressionType\n    compression;        /* compression of image when read/write */\n\n  size_t\n    quality;            /* compression quality setting, meaning varies */\n\n  OrientationType\n    orientation;        /* photo orientation of image */\n\n  MagickBooleanType\n    taint;              /* has image been modified since reading */\n\n  size_t\n    columns,            /* physical size of image */\n    rows,\n    depth,              /* depth of image on read/write */\n    colors;             /* Size of color table, or actual color count */\n                        /* Only valid if image is not DirectClass */\n\n  PixelInfo\n    *colormap,\n    alpha_color,        /* deprecated */\n    background_color,   /* current background color attribute */\n    border_color,       /* current bordercolor attribute */\n    transparent_color;  /* color for 'transparent' color index in GIF */\n\n...\n\n// QuantumType:\ntypedef enum\n{\n  UndefinedQuantum,\n  AlphaQuantum,\n  BGRAQuantum,\n  BGROQuantum,\n  BGRQuantum,\n  BlackQuantum,\n  BlueQuantum,\n  CbYCrAQuantum,\n  CbYCrQuantum,\n  CbYCrYQuantum,\n  CMYKAQuantum,\n  CMYKOQuantum,\n  CMYKQuantum,\n  CyanQuantum,\n  GrayAlphaQuantum,\n  GrayQuantum,\n  GreenQuantum,\n  IndexAlphaQuantum,\n  IndexQuantum,\n  MagentaQuantum,\n  OpacityQuantum,\n  RedQuantum,\n  RGBAQuantum,\n  RGBOQuantum,\n  RGBPadQuantum,\n  RGBQuantum,\n  YellowQuantum\n}\n\n// CINInfo:\ntypedef struct CINInfo\n{\n  CINFileInfo\n    file;\n\n  CINImageInfo\n    image;\n\n  CINDataFormatInfo\n    data_format;\n\n  CINOriginationInfo\n    origination;\n\n  CINFilmInfo\n    film;\n\n  CINUserInfo\n    user;\n} CINInfo;\n\n// _QuantumInfo:\nstruct _QuantumInfo\n{\n  size_t\n    depth,\n    quantum;\n\n  QuantumFormatType\n    format;\n\n  double\n    minimum,\n    maximum,\n    scale;\n\n  size_t\n    pad;\n\n  MagickBooleanType\n    min_is_white,\n    pack;\n\n  QuantumAlphaType\n    alpha_type;\n\n  size_t\n    number_threads;\n\n  MemoryInfo\n    **pixels;\n\n  size_t\n    extent;\n\n  EndianType\n    endian;\n\n  QuantumState\n    state;\n\n  SemaphoreInfo\n    *semaphore;\n\n  size_t\n    signature;\n}\n\n// Called Methods (top 10):\n// GetStringInfoDatum from MagickCore/string.c:\nunsigned char *GetStringInfoDatum(const StringInfo *string_info)\n{\n  assert(string_info != (StringInfo *) NULL);\n  assert(string_info->signature == MagickCoreSignature);\n  return(string_info->datum);\n}\n\n// GetStringInfoLength from MagickCore/string.c:\nsize_t GetStringInfoLength(const StringInfo *string_info)\n{\n  assert(string_info != (StringInfo *) NULL);\n  assert(string_info->signature == MagickCoreSignature);\n  return(string_info->length);\n}\n\n// BlobToStringInfo from MagickCore/string.c:\nStringInfo *BlobToStringInfo(const void *blob,const size_t length)\n{\n  StringInfo\n    *string_info;\n\n  if (~length < MagickPathExtent)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  string_info=AcquireStringInfoContainer();\n  string_info->length=length;\n  string_info->datum=(unsigned char *) AcquireQuantumMemory(length+\n    MagickPathExtent,sizeof(*string_info->datum));\n  if (string_info->datum == (unsigned char *) NULL)\n    {\n      string_info=DestroyStringInfo(string_info);\n      return((StringInfo *) NULL);\n    }\n  if (blob != (const void *) NULL)\n    (void) memcpy(string_info->datum,blob,length);\n  else\n    (void) memset(string_info->datum,0,length*sizeof(*string_info->datum));\n  (void) memset(string_info->datum+length,0,MagickPathExtent*\n    sizeof(*string_info->datum));\n  return(string_info);\n}\n\n// ImportQuantumPixels from MagickCore/quantum-import.c:\nsize_t ImportQuantumPixels(const Image *image,\n  CacheView *image_view,QuantumInfo *quantum_info,\n  const QuantumType quantum_type,const unsigned char *magick_restrict pixels,\n  ExceptionInfo *exception)\n{\n  MagickSizeType\n    number_pixels;\n\n  const unsigned char\n    *magick_restrict p;\n\n  ssize_t\n    x;\n\n  Quantum\n    *magick_restrict q;\n\n  size_t\n    extent;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  if (pixels == (const unsigned char *) NULL)\n    pixels=(const unsigned char *) GetQuantumPixels(quantum_info);\n  x=0;\n  p=pixels;\n  if (image_view == (CacheView *) NULL)\n    {\n      number_pixels=GetImageExtent(image);\n      q=GetAuthenticPixelQueue(image);\n    }\n  else\n    {\n      number_pixels=GetCacheViewExtent(image_vie...\n\n// QueueAuthenticPixels from MagickCore/cache.c:\nQuantum *QueueAuthenticPixels(Image *image,const ssize_t x,\n  const ssize_t y,const size_t columns,const size_t rows,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  Quantum\n    *magick_restrict pixels;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->methods.queue_authentic_pixels_handler !=\n      (QueueAuthenticPixelsHandler) NULL)\n    {\n      pixels=cache_info->methods.queue_authentic_pixels_handler(image,x,y,\n        columns,rows,exception);\n      return(pixels);\n    }\n  assert(id < (int) cache_info->number_threads);\n  pixels=QueueAuthenticPixelCacheNexus(image,x,y,columns,rows,MagickFalse,\n    cache_info->nexus_info[id],exception);\n  return(pixels);\n}\n\n// MagickCoreSignature from coders/MagickCore/MagickCore/method-attribute.h:\n<empty>\n\n// AcquireImage from MagickCore/image.c:\nImage *AcquireImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  const char\n    *option;\n\n  Image\n    *image;\n\n  MagickStatusType\n    flags;\n\n  /*\n    Allocate image structure.\n  */\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  image=(Image *) AcquireCriticalMemory(sizeof(*image));\n  (void) memset(image,0,sizeof(*image));\n  /*\n    Initialize Image structure.\n  */\n  (void) CopyMagickString(image->magick,\"MIFF\",MagickPathExtent);\n  image->storage_class=DirectClass;\n  image->depth=MAGICKCORE_QUANTUM_DEPTH;\n  image->colorspace=sRGBColorspace;\n  image->rendering_intent=PerceptualIntent;\n  image->gamma=1.000f/2.200f;\n  image->chromaticity.red_primary.x=0.6400f;\n  image->chromaticity.red_primary.y=0.3300f;\n  image->chromaticity.red_primary.z=0.0300f;\n  image->chromaticity.green_primary.x=0.3000f;\n  image->chromaticity.green_primary.y=0.6000f;\n  image->chromaticity.green_primary.z=0.1000f;\n  image->chromaticity.blue_primary.x=0.1500f;\n  image->chromaticity.b...\n\n// GetBlobSize from MagickCore/blob.c:\nMagickSizeType GetBlobSize(const Image *image)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  MagickSizeType\n    extent;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(image->blob != (BlobInfo *) NULL);\n  blob_info=image->blob;\n  extent=0;\n  switch (blob_info->type)\n  {\n    case UndefinedStream:\n    case StandardStream:\n    {\n      extent=blob_info->size;\n      break;\n    }\n    case FileStream:\n    {\n      int\n        file_descriptor;\n\n      extent=(MagickSizeType) blob_info->properties.st_size;\n      if (extent == 0)\n        extent=blob_info->size;\n      file_descriptor=fileno(blob_info->file_info.file);\n      if (file_descriptor == -1)\n        break;\n      if (fstat(file_descriptor,&blob_info->properties) == 0)\n        extent=(MagickSizeType) blob_info->properties.st_size;\n      break;\n    }\n    case PipeStream:\n    {\n  ...\n\n// GetFirstImageInList from MagickCore/list.c:\nImage *GetFirstImageInList(const Image *images)\n{\n  const Image\n    *p;\n\n  if (images == (Image *) NULL)\n    return((Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  for (p=images; p->previous != (Image *) NULL; p=p->previous) ;\n  return((Image *) p);\n}\n\n// SetImageBackgroundColor from MagickCore/image.c:\nMagickBooleanType SetImageBackgroundColor(Image *image,\n  ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  PixelInfo\n    background;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickCoreSignature);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  if ((image->background_color.alpha_trait != UndefinedPixelTrait) &&\n      (image->alpha_trait == UndefinedPixelTrait))\n    (void) SetImageAlphaChannel(image,OnAlphaChannel,exception);\n  ConformPixelInfo(image,&image->background_color,&background,exception);\n  /*\n    Set image background color.\n  */\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    Quantum\n      *magick_restrict q;\n\n    ssize_t\n      x;\n\n    if (status == MagickFalse)\n...\n"
  },
  {
    "repository": "tensorflow",
    "cve_id": "CVE-2021-37666",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "be7a4de6adfbd303ce08be4332554dff70362612",
    "short_hash": "be7a4de6",
    "vulnerableMethods_before": [
      {
        "filename": "ragged_tensor_to_variant_op.cc",
        "method_name": "vulnerable_function",
        "raw_code": "  void Compute(OpKernelContext* context) override {\n    // Read ragged_splits inputs.\n    OpInputList ragged_nested_splits_in;\n    OP_REQUIRES_OK(context, context->input_list(\"rt_nested_splits\",\n                                                &ragged_nested_splits_in));\n    const int ragged_nested_splits_len = ragged_nested_splits_in.size();\n    RaggedTensorVariant batched_ragged_input;\n    // Read ragged_values input.\n    batched_ragged_input.set_values(context->input(ragged_nested_splits_len));\n    batched_ragged_input.mutable_nested_splits()->reserve(\n        ragged_nested_splits_len);\n    for (int i = 0; i < ragged_nested_splits_len; i++) {\n      batched_ragged_input.append_splits(ragged_nested_splits_in[i]);\n    }\n\n    if (!batched_input_) {\n      // Encode as a Scalar Variant Tensor.\n      Tensor* encoded_scalar;\n      OP_REQUIRES_OK(context, context->allocate_output(0, TensorShape({}),\n                                                       &encoded_scalar));\n      encoded_scalar->scalar<Variant>()() = std::move(batched_ragged_input);\n      return;\n    }\n\n    // Unbatch the Ragged Tensor and encode the components.\n    std::vector<RaggedTensorVariant> unbatched_ragged_input;\n    auto batched_splits_top_vec =\n        batched_ragged_input.splits(0).vec<SPLIT_TYPE>();\n    int num_components = batched_splits_top_vec.size() - 1;\n    OP_REQUIRES(context, num_components >= 0,\n                errors::Internal(\"Invalid split argument.\"));\n    OP_REQUIRES_OK(context, UnbatchRaggedZerothDim<VALUE_TYPE, SPLIT_TYPE>(\n                                batched_ragged_input, &unbatched_ragged_input));\n\n    // Bundle the encoded scalar Variant Tensors into a rank-1 Variant Tensor.\n    Tensor* encoded_vector;\n    int output_size = unbatched_ragged_input.size();\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, TensorShape({output_size}),\n                                            &encoded_vector));\n    auto encoded_vector_t = encoded_vector->vec<Variant>();\n    for (int i = 0; i < output_size; i++) {\n      encoded_vector_t(i) = unbatched_ragged_input[i];\n    }\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ragged_tensor_to_variant_op.cc",
        "method_name": "fixed_function",
        "raw_code": "  void Compute(OpKernelContext* context) override {\n    // Read ragged_splits inputs.\n    OpInputList ragged_nested_splits_in;\n    OP_REQUIRES_OK(context, context->input_list(\"rt_nested_splits\",\n                                                &ragged_nested_splits_in));\n    const int ragged_nested_splits_len = ragged_nested_splits_in.size();\n    RaggedTensorVariant batched_ragged_input;\n    // Read ragged_values input.\n    batched_ragged_input.set_values(context->input(ragged_nested_splits_len));\n    batched_ragged_input.mutable_nested_splits()->reserve(\n        ragged_nested_splits_len);\n    for (int i = 0; i < ragged_nested_splits_len; i++) {\n      batched_ragged_input.append_splits(ragged_nested_splits_in[i]);\n    }\n\n    if (!batched_input_) {\n      // Encode as a Scalar Variant Tensor.\n      Tensor* encoded_scalar;\n      OP_REQUIRES_OK(context, context->allocate_output(0, TensorShape({}),\n                                                       &encoded_scalar));\n      encoded_scalar->scalar<Variant>()() = std::move(batched_ragged_input);\n      return;\n    }\n\n    // Checked here instead of at input in case batched_input_ is false\n    OP_REQUIRES(context, ragged_nested_splits_len > 0,\n                errors::InvalidArgument(\n                    \"rt_nested_splits must be a list of one or more, but \"\n                    \"received rt_nested_splits of length 0.\"));\n\n    // Unbatch the Ragged Tensor and encode the components.\n    std::vector<RaggedTensorVariant> unbatched_ragged_input;\n    auto batched_splits_top_vec =\n        batched_ragged_input.splits(0).vec<SPLIT_TYPE>();\n    int num_components = batched_splits_top_vec.size() - 1;\n    OP_REQUIRES(context, num_components >= 0,\n                errors::Internal(\"Invalid split argument.\"));\n    OP_REQUIRES_OK(context, UnbatchRaggedZerothDim<VALUE_TYPE, SPLIT_TYPE>(\n                                batched_ragged_input, &unbatched_ragged_input));\n\n    // Bundle the encoded scalar Variant Tensors into a rank-1 Variant Tensor.\n    Tensor* encoded_vector;\n    int output_size = unbatched_ragged_input.size();\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, TensorShape({output_size}),\n                                            &encoded_vector));\n    auto encoded_vector_t = encoded_vector->vec<Variant>();\n    for (int i = 0; i < output_size; i++) {\n      encoded_vector_t(i) = unbatched_ragged_input[i];\n    }\n  }",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"tensorflow/core/kernels/ragged_tensor_variant.h\"\n#include \"tensorflow/core/framework/variant_op_registry.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/variant.h\"\n#include \"tensorflow/core/framework/variant_encode_decode.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/util/tensor_ops_util.h\"\n#include <utility>\n#include \"tensorflow/core/lib/core/status.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/kernels/concat_lib.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include <vector>\n\n// Type Definitions:\n// RaggedTensorVariant:\nclass RaggedTensorVariant {\n public:\n  RaggedTensorVariant() {}\n  RaggedTensorVariant(Tensor values, const std::vector<Tensor>& nested_splits)\n      : values_(std::move(values)), nested_splits_(nested_splits) {}\n\n  // Variant support methods.\n  string TypeName() const;\n  string DebugString() const;\n  void Encode(VariantTensorData* data) const;\n  bool Decode(const VariantTensorData& data);\n\n  // The flat_values of the RaggedTensor.\n  const Tensor& values() const { return values_; }\n  Tensor* mutable_values() { return &values_; }\n  void set_values(const Tensor& new_values) { values_ = new_values; }\n\n  // The nested row_splits of the RaggedTensor.\n  int ragged_rank() const { return nested_splits_.size(); }\n  const std::vector<Tensor>& nested_splits() const { return nested_splits_; }\n  std::vector<Tensor>* mutable_nested_splits() { return &nested_splits_; }\n  const Tensor& splits(int i) const { return nested_splits_[i]; }\n  Tensor* mutable_splits(int i) { return &nested_splits_[i]; }\n  ...\n\n// OpInputList:\nclass OpInputList {\n public:\n  typedef OpArgIterator<OpInputList, const Tensor> Iterator;\n  OpInputList() : ctx_(nullptr), start_(0), stop_(0) {}\n  OpInputList(OpKernelContext* ctx, int start, int stop)\n      : ctx_(ctx), start_(start), stop_(stop) {}\n  OpInputList& operator=(const OpInputList& other) = default;\n  const Tensor& operator[](int i) const;\n  int size() const { return stop_ - start_; }\n  Iterator begin() const { return Iterator(this, 0); }\n  Iterator end() const { return Iterator(this, size()); }\n\n private:\n  OpKernelContext* ctx_;  // not owned\n  int start_;\n  int stop_;\n}\n\n// OpKernelContext:\ntensorflow.OpKernelContext.OpKernelContext:ANY(tensorflow.OpKernelContext.Params*)\n\n// OpKernelContext:\nclass OpKernelContext {\n public:\n  // The first element of a WrappedAllocator is a \"base\" Allocator and\n  // the second element is that Allocator wrapped by a\n  // TrackingAllocator\n  typedef std::pair<Allocator*, TrackingAllocator*> WrappedAllocator;\n\n  // TODO(zhifengc): Do some cleanup of Params.\n  // The Params struct is passed in to initialize an OpKernelContext,\n  // and must outlive the OpKernelContext.\n  struct Params {\n    ~Params() { delete eigen_gpu_device; }\n\n    // The step being executed.\n    int64 step_id = 0;\n\n    // Timestamp for the start of graph execution. Used for latency metrics.\n    int64 start_time_usecs = 0;\n\n    // The op kernel being computed.\n    OpKernel* op_kernel = nullptr;\n\n    // The device on which the kernel is running.\n    DeviceBase* device = nullptr;\n\n    // The Eigen GPU device wrapper, which may include a per-op\n    // wrapped allocator. The concrete type of this object depends on\n    // the type of this->device, so eigen_gpu_device can't be a...\n\n// RaggedTensorToVariantOp:\nclass RaggedTensorToVariantOp : public OpKernel {\n public:\n  explicit RaggedTensorToVariantOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"batched_input\", &batched_input_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    // Read ragged_splits inputs.\n    OpInputList ragged_nested_splits_in;\n    OP_REQUIRES_OK(context, context->input_list(\"rt_nested_splits\",\n                                                &ragged_nested_splits_in));\n    const int ragged_nested_splits_len = ragged_nested_splits_in.size();\n    RaggedTensorVariant batched_ragged_input;\n    // Read ragged_values input.\n    batched_ragged_input.set_values(context->input(ragged_nested_splits_len));\n    batched_ragged_input.mutable_nested_splits()->reserve(\n        ragged_nested_splits_len);\n    for (int i = 0; i < ragged_nested_splits_len; i++) {\n      batched_ragged_input.append_splits(ragged_nested_splits_in[i]);\n    }\n\n    if (!batched_input_) {\n ...\n\n// Status:\nclass Status\n\n// Tensor:\nclass Tensor {\n public:\n  /// \\brief Creates a 1-dimensional, 0-element float tensor.\n  ///\n  /// The returned Tensor is not a scalar (shape {}), but is instead\n  /// an empty one-dimensional Tensor (shape {0}, NumElements() ==\n  /// 0). Since it has no elements, it does not need to be assigned a\n  /// value and is initialized by default (IsInitialized() is\n  /// true). If this is undesirable, consider creating a one-element\n  /// scalar which does require initialization:\n  ///\n  /// ```c++\n  ///\n  ///     Tensor(DT_FLOAT, TensorShape({}))\n  ///\n  /// ```\n  Tensor();\n\n  /// \\brief Creates a Tensor of the given `type` and `shape`.  If\n  /// LogMemory::IsEnabled() the allocation is logged as coming from\n  /// an unknown kernel and step. Calling the Tensor constructor\n  /// directly from within an Op is deprecated: use the\n  /// OpKernelConstruction/OpKernelContext allocate_* methods to\n  /// allocate a new tensor, which record the kernel and step.\n  ///\n  /// The underlying buffer is ...\n\n// Status:\nclass Status {\n public:\n  /// Create a success status.\n  Status() {}\n\n  /// \\brief Create a status with the specified error code and msg as a\n  /// human-readable string containing more detailed information.\n  Status(tensorflow::error::Code code, tensorflow::StringPiece msg)\n      : Status(code, msg, {}) {}\n\n  /// \\brief Create a status with the specified error code, msg, and stack trace\n  /// as a human-readable string containing more detailed information.\n#ifndef SWIG\n  Status(tensorflow::error::Code code, tensorflow::StringPiece msg,\n         std::vector<StackFrame>&& stack_trace);\n#endif\n\n  /// Copy the specified status.\n  Status(const Status& s);\n  Status& operator=(const Status& s);\n#ifndef SWIG\n  Status(Status&& s) noexcept;\n  Status& operator=(Status&& s) noexcept;\n#endif  // SWIG\n\n  static Status OK() { return Status(); }\n\n  /// Returns true iff the status indicates success.\n  bool ok() const { return (state_ == nullptr); }\n\n  tensorflow::error::Code code() const {\n    retu...\n\n// Called Methods (top 10):\n// SetStatus from tensorflow/core/framework/op_kernel.cc:\nvoid OpKernelConstruction::SetStatus(const Status& status) { /* <=== tensorflow.OpKernelConstruction.SetStatus:void(tensorflow.Status&) */ \n  status_->Update(status);\n}\n\n// LOG from tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/platform/tensorflow/core/platform/logging.h:\n\n\n// OP_REQUIRES from tensorflow/core/kernels/tensorflow/core/framework/tensorflow/core/framework/op_requires.h:\n\n\n// name from tensorflow/core/framework/op_kernel.h:\n  const std::string& name() const { return props_->node_def.name(); } /* <=== tensorflow.OpKernel.name:ANY()<const> */ \n\n// size from tensorflow/core/framework/op_kernel.h:\n  int size() const { return stop_ - start_; } /* <=== tensorflow.OpInputList.size:int()<const> */ \n\n// TF_RETURN_IF_ERROR from tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/errors.h:\n\n\n// VLOG from tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/platform/tensorflow/core/platform/logging.h:\n\n\n// OP_REQUIRES_OK from tensorflow/core/kernels/tensorflow/core/framework/tensorflow/core/framework/op_requires.h:\n\n\n// CheckNotInComputeAsync from tensorflow/core/framework/op_kernel.cc:\nvoid CheckNotInComputeAsync(OpKernelContext* ctx, /* <=== tensorflow.CheckNotInComputeAsync:void(tensorflow.OpKernelContext*,char*) */ \n                            const char* correct_macro_name) {\n  CHECK_EQ(nullptr, ctx->params_->op_kernel->AsAsync())\n      << \"Use \" << correct_macro_name << \" in AsyncOpKernel implementations.\";\n}\n\n// Update from tensorflow/core/platform/status.h:\n  void Update(const Status& new_status); /* <=== tensorflow.Status.Update:void(tensorflow.Status&) */ \n"
  },
  {
    "repository": "ImageMagick6",
    "cve_id": "CVE-2022-32545",
    "cwe_list": [
      "CWE-190"
    ],
    "commit_hash": "450949ed017f009b399c937cf362f0058eacc5fa",
    "short_hash": "450949ed",
    "vulnerableMethods_before": [
      {
        "filename": "psd.c",
        "method_name": "vulnerable_function",
        "raw_code": "static MagickBooleanType ReadPSDChannelPixels(Image *image,\n  const size_t channels,const ssize_t row,const ssize_t type,\n  const unsigned char *pixels,ExceptionInfo *exception)\n{\n  Quantum\n    pixel;\n\n  const unsigned char\n    *p;\n\n  IndexPacket\n    *indexes;\n\n  PixelPacket\n    *q;\n\n  ssize_t\n    x;\n\n  size_t\n    packet_size;\n\n  unsigned short\n    nibble;\n\n  p=pixels;\n  q=GetAuthenticPixels(image,0,row,image->columns,1,exception);\n  if (q == (PixelPacket *) NULL)\n    return MagickFalse;\n  indexes=GetAuthenticIndexQueue(image);\n  packet_size=GetPSDPacketSize(image);\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    if (packet_size == 1)\n      pixel=ScaleCharToQuantum(*p++);\n    else\n      if (packet_size == 2)\n        {\n          p=PushShortPixel(MSBEndian,p,&nibble);\n          pixel=ScaleShortToQuantum(nibble);\n        }\n      else\n        {\n          MagickFloatType\n            nibble;\n\n          p=PushFloatPixel(MSBEndian,p,&nibble);\n          pixel=ClampToQuantum((MagickRealType)QuantumRange*nibble);\n        }\n    if (image->depth > 1)\n      {\n        SetPSDPixel(image,channels,type,packet_size,pixel,q,indexes,x);\n        q++;\n      }\n    else\n      {\n        ssize_t\n          bit,\n          number_bits;\n\n        number_bits=(ssize_t) image->columns-x;\n        if (number_bits > 8)\n          number_bits=8;\n        for (bit=0; bit < number_bits; bit++)\n        {\n          SetPSDPixel(image,channels,type,packet_size,(((unsigned char) pixel)\n            & (0x01 << (7-bit))) != 0 ? 0 : QuantumRange,q++,indexes,x++);\n        }\n        if (x != (ssize_t) image->columns)\n          x--;\n        continue;\n      }\n  }\n  return(SyncAuthenticPixels(image,exception));\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "psd.c",
        "method_name": "fixed_function",
        "raw_code": "static MagickBooleanType ReadPSDChannelPixels(Image *image,\n  const size_t channels,const ssize_t row,const ssize_t type,\n  const unsigned char *pixels,ExceptionInfo *exception)\n{\n  Quantum\n    pixel;\n\n  const unsigned char\n    *p;\n\n  IndexPacket\n    *indexes;\n\n  PixelPacket\n    *q;\n\n  ssize_t\n    x;\n\n  size_t\n    packet_size;\n\n  unsigned short\n    nibble;\n\n  p=pixels;\n  q=GetAuthenticPixels(image,0,row,image->columns,1,exception);\n  if (q == (PixelPacket *) NULL)\n    return MagickFalse;\n  indexes=GetAuthenticIndexQueue(image);\n  packet_size=GetPSDPacketSize(image);\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    if (packet_size == 1)\n      pixel=ScaleCharToQuantum(*p++);\n    else\n      if (packet_size == 2)\n        {\n          p=PushShortPixel(MSBEndian,p,&nibble);\n          pixel=ScaleShortToQuantum(nibble);\n        }\n      else\n        {\n          MagickFloatType\n            nibble;\n\n          p=PushFloatPixel(MSBEndian,p,&nibble);\n          pixel=ClampToQuantum((MagickRealType)QuantumRange*nibble);\n        }\n    if (image->depth > 1)\n      {\n        SetPSDPixel(image,channels,type,packet_size,pixel,q,indexes,x);\n        q++;\n      }\n    else\n      {\n        ssize_t\n          bit,\n          number_bits;\n\n        number_bits=(ssize_t) image->columns-x;\n        if (number_bits > 8)\n          number_bits=8;\n        for (bit=0; bit < number_bits; bit++)\n        {\n          SetPSDPixel(image,channels,type,packet_size,\n            (((unsigned char) ((ssize_t) pixel)) & (0x01 << (7-bit))) != 0 ? 0 :\n            QuantumRange,q++,indexes,x++);\n        }\n        if (x != (ssize_t) image->columns)\n          x--;\n        continue;\n      }\n  }\n  return(SyncAuthenticPixels(image,exception));\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"magick/colormap.h\"\n#include \"magick/magick.h\"\n#include \"magick/attribute.h\"\n#include \"magick/constitute.h\"\n#include \"magick/blob-private.h\"\n#include \"magick/log.h\"\n#include \"magick/policy.h\"\n#include \"magick/quantum-private.h\"\n#include \"magick/exception-private.h\"\n#include \"magick/pixel.h\"\n#include \"magick/registry.h\"\n#include \"magick/string-private.h\"\n#include \"magick/exception.h\"\n#include \"psd-private.h\"\n#include \"magick/colorspace.h\"\n#include \"magick/colorspace-private.h\"\n#include \"magick/image.h\"\n#include \"magick/image-private.h\"\n#include \"magick/memory_.h\"\n#include \"magick/static.h\"\n#include \"magick/thread-private.h\"\n#include \"magick/blob.h\"\n#include \"magick/property.h\"\n#include \"magick/monitor-private.h\"\n#include \"magick/string_.h\"\n#include \"magick/module.h\"\n#include <zlib.h>\n#include \"magick/profile.h\"\n#include \"magick/artifact.h\"\n#include \"magick/channel.h\"\n#include \"magick/cache.h\"\n#include \"magick/colormap-private.h\"\n#include \"magick/pixel-accessor.h\"\n#include \"magick/option.h\"\n#include \"magick/list.h\"\n#include \"magick/studio.h\"\n#include \"magick/enhance.h\"\n\n// Type Definitions:\n// Image:\nclass MagickPPExport Image\n  {\n  public:\n\n    // Obtain image statistics. Statistics are normalized to the range\n    // of 0.0 to 1.0 and are output to the specified ImageStatistics\n    // structure.\n    typedef struct _ImageChannelStatistics\n    {\n      /* Minimum value observed */\n      double maximum;\n      /* Maximum value observed */\n      double minimum;\n      /* Average (mean) value observed */\n      double mean;\n      /* Standard deviation, sqrt(variance) */\n      double standard_deviation;\n      /* Variance */\n      double variance;\n      /* Kurtosis */\n      double kurtosis;\n      /* Skewness */\n      double skewness;\n    } ImageChannelStatistics;\n\n    typedef struct _ImageStatistics\n    {\n      ImageChannelStatistics red;\n      ImageChannelStatistics green;\n      ImageChannelStatistics blue;\n      ImageChannelStatistics opacity;\n    } ImageStatistics;\n\n    // Default constructor\n    Image(void);\n\n    // Construct Image from in-memory BLOB\n    Image(const Blob &blob_);\n\n  ...\n\n// ExceptionInfo:\ntypedef struct _ExceptionInfo ExceptionInfo;\n\n// _PixelPacket:\ntypedef struct _PixelPacket\n{\n#if defined(MAGICKCORE_WORDS_BIGENDIAN)\n#define MAGICK_PIXEL_RGBA  1\n  Quantum\n    red,\n    green,\n    blue,\n    opacity;\n#else\n#define MAGICK_PIXEL_BGRA  1\n  Quantum\n    blue,\n    green,\n    red,\n    opacity;\n#endif\n}\n\n// Quantum:\ntypedef MagickDoubleType Quantum;\n\n// MagickFloatType:\ntypedef float MagickFloatType;\n\n// IndexPacket:\ntypedef Quantum IndexPacket;\n\n// Quantum:\ntypedef MagickFloatType Quantum;\n\n// PixelPacket:\ntypedef struct _PixelPacket\n{\n#if defined(MAGICKCORE_WORDS_BIGENDIAN)\n#define MAGICK_PIXEL_RGBA  1\n  Quantum\n    red,\n    green,\n    blue,\n    opacity;\n#else\n#define MAGICK_PIXEL_BGRA  1\n  Quantum\n    blue,\n    green,\n    red,\n    opacity;\n#endif\n} PixelPacket;\n\n// Image:\nMagick.Image.Image:ANY(void)\n\n// MagickFloatType:\ntypedef double MagickFloatType;\n\n// Called Methods (top 10):\n// ReadPixelCacheIndexes from magick/cache.c:\nstatic MagickBooleanType ReadPixelCacheIndexes( /* <=== ReadPixelCacheIndexes */ \n  CacheInfo *magick_restrict cache_info,NexusInfo *magick_restrict nexus_info,\n  ExceptionInfo *exception)\n{\n  IndexPacket\n    *magick_restrict q;\n\n  MagickOffsetType\n    count,\n    offset;\n\n  MagickSizeType\n    extent,\n    length;\n\n  ssize_t\n    y;\n\n  size_t\n    rows;\n\n  if (cache_info->active_index_channel == MagickFalse)\n    return(MagickFalse);\n  if (nexus_info->authentic_pixel_cache != MagickFalse)\n    return(MagickTrue);\n  offset=(MagickOffsetType) nexus_info->region.y*cache_info->columns+\n    nexus_info->region.x;\n  length=(MagickSizeType) nexus_info->region.width*sizeof(IndexPacket);\n  rows=nexus_info->region.height;\n  extent=length*rows;\n  q=nexus_info->indexes;\n  y=0;\n  switch (cache_info->type)\n  {\n    case MemoryCache:\n    case MapCache:\n    {\n      IndexPacket\n        *magick_restrict p;\n\n      /*\n        Read indexes from memory.\n      */\n      if ((cache_info->columns == nexus_info->region.width) &&\n          (extent == (MagickSizeType) ((size_t) extent)))\n        {\n          length=extent;\n          rows=1UL;\n        }\n      p=cache_info->indexes+offset;\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        (void) memcpy(q,p,(size_t) length);\n        p+=cache_info->columns;\n        q+=nexus_info->region.width;\n      }\n      break;\n    }\n    case DiskCache:\n    {\n      /*\n        Read indexes from disk.\n      */\n      LockSemaphoreInfo(cache_info->file_semaphore);\n      if (OpenPixelCacheOnDisk(cache_info,IOMode) == MagickFalse)\n        {\n          ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n            cache_info->cache_filename);\n          UnlockSemaphoreInfo(cache_info->file_semaphore);\n          return(MagickFalse);\n        }\n      if ((cache_info->columns == nexus_info->region.width) &&\n          (extent <= MagickMaxBufferExtent))\n        {\n          length=extent;\n          rows=1UL;\n        }\n      extent=(MagickSizeType) cache_info->columns*cache_info->rows;\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        count=ReadPixelCacheRegion(cache_info,cache_info->offset+extent*\n          sizeof(PixelPacket)+offset*sizeof(*q),length,(unsigned char *) q);\n        if (count < (MagickOffsetType) length)\n          break;\n        offset+=cache_info->columns;\n        q+=nexus_info->region.width;\n      }\n      if (IsFileDescriptorLimitExceeded() != MagickFalse)\n        (void) ClosePixelCacheOnDisk(cache_info);\n      UnlockSemaphoreInfo(cache_info->file_semaphore);\n      break;\n    }\n    case DistributedCache:\n    {\n      RectangleInfo\n        region;\n\n      /*\n        Read indexes from distributed cache.\n      */\n      LockSemaphoreInfo(cache_info->file_semaphore);\n      region=nexus_info->region;\n      if ((cache_info->columns != nexus_info->region.width) ||\n          (extent > MagickMaxBufferExtent))\n        region.height=1UL;\n      else\n        {\n          length=extent;\n          rows=1UL;\n        }\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        count=ReadDistributePixelCacheIndexes((DistributeCacheInfo *)\n          cache_info->server_info,&region,length,(unsigned char *) q);\n        if (count != (MagickOffsetType) length)\n          break;\n        q+=nexus_info->region.width;\n        region.y++;\n      }\n      UnlockSemaphoreInfo(cache_info->file_semaphore);\n      break;\n    }\n    default:\n      break;\n  }\n  if (y < (ssize_t) rows)\n    {\n      ThrowFileException(exception,CacheError,\"UnableToReadPixelCache\",\n        cache_info->cache_filename);\n      return(MagickFalse);\n    }\n  if ((cache_info->debug != MagickFalse) &&\n      (CacheTick(nexus_info->region.y,cache_info->rows) != MagickFalse))\n    (void) LogMagickEvent(CacheEvent,GetMagickModule(),\n      \"%s[%.20gx%.20g%+.20g%+.20g]\",cache_info->filename,(double)\n      nexus_info->region.width,(double) nexus_info->region.height,(double)\n      nexus_info->region.x,(double) nexus_info->region.y);\n  return(MagickTrue);\n}\n\n// IssRGBCompatibleColorspace from magick/colorspace-private.h:\nstatic inline MagickBooleanType IssRGBCompatibleColorspace( /* <=== IssRGBCompatibleColorspace */ \n  const ColorspaceType colorspace)\n{\n  if ((colorspace == sRGBColorspace) || (colorspace == RGBColorspace) ||\n      (colorspace == scRGBColorspace) ||\n      (colorspace == TransparentColorspace) || (colorspace == GRAYColorspace) ||\n      (colorspace == LinearGRAYColorspace))\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\n// GetPixelIndex from coders/magick/magick/pixel-accessor.h:\n\n\n// MagickCoreSignature from magick/magick/magick/method-attribute.h:\n\n\n// WritePixelCacheIndexes from magick/cache.c:\nstatic MagickBooleanType WritePixelCacheIndexes(CacheInfo *cache_info, /* <=== WritePixelCacheIndexes */ \n  NexusInfo *magick_restrict nexus_info,ExceptionInfo *exception)\n{\n  MagickOffsetType\n    count,\n    offset;\n\n  MagickSizeType\n    extent,\n    length;\n\n  const IndexPacket\n    *magick_restrict p;\n\n  ssize_t\n    y;\n\n  size_t\n    rows;\n\n  if (cache_info->active_index_channel == MagickFalse)\n    return(MagickFalse);\n  if (nexus_info->authentic_pixel_cache != MagickFalse)\n    return(MagickTrue);\n  offset=(MagickOffsetType) nexus_info->region.y*cache_info->columns+\n    nexus_info->region.x;\n  length=(MagickSizeType) nexus_info->region.width*sizeof(IndexPacket);\n  rows=nexus_info->region.height;\n  extent=(MagickSizeType) length*rows;\n  p=nexus_info->indexes;\n  y=0;\n  switch (cache_info->type)\n  {\n    case MemoryCache:\n    case MapCache:\n    {\n      IndexPacket\n        *magick_restrict q;\n\n      /*\n        Write indexes to memory.\n      */\n      if ((cache_info->columns == nexus_info->region.width) &&\n          (extent == (MagickSizeType) ((size_t) extent)))\n        {\n          length=extent;\n          rows=1UL;\n        }\n      q=cache_info->indexes+offset;\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        (void) memcpy(q,p,(size_t) length);\n        p+=nexus_info->region.width;\n        q+=cache_info->columns;\n      }\n      break;\n    }\n    case DiskCache:\n    {\n      /*\n        Write indexes to disk.\n      */\n      LockSemaphoreInfo(cache_info->file_semaphore);\n      if (OpenPixelCacheOnDisk(cache_info,IOMode) == MagickFalse)\n        {\n          ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n            cache_info->cache_filename);\n          UnlockSemaphoreInfo(cache_info->file_semaphore);\n          return(MagickFalse);\n        }\n      if ((cache_info->columns == nexus_info->region.width) &&\n          (extent <= MagickMaxBufferExtent))\n        {\n          length=extent;\n          rows=1UL;\n        }\n      extent=(MagickSizeType) cache_info->columns*cache_info->rows;\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        count=WritePixelCacheRegion(cache_info,cache_info->offset+extent*\n          sizeof(PixelPacket)+offset*sizeof(*p),length,(const unsigned char *)\n          p);\n        if (count < (MagickOffsetType) length)\n          break;\n        p+=nexus_info->region.width;\n        offset+=cache_info->columns;\n      }\n      if (IsFileDescriptorLimitExceeded() != MagickFalse)\n        (void) ClosePixelCacheOnDisk(cache_info);\n      UnlockSemaphoreInfo(cache_info->file_semaphore);\n      break;\n    }\n    case DistributedCache:\n    {\n      RectangleInfo\n        region;\n\n      /*\n        Write indexes to distributed cache.\n      */\n      LockSemaphoreInfo(cache_info->file_semaphore);\n      region=nexus_info->region;\n      if ((cache_info->columns != nexus_info->region.width) ||\n          (extent > MagickMaxBufferExtent))\n        region.height=1UL;\n      else\n        {\n          length=extent;\n          rows=1UL;\n        }\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        count=WriteDistributePixelCacheIndexes((DistributeCacheInfo *)\n          cache_info->server_info,&region,length,(const unsigned char *) p);\n        if (count != (MagickOffsetType) length)\n          break;\n        p+=nexus_info->region.width;\n        region.y++;\n      }\n      UnlockSemaphoreInfo(cache_info->file_semaphore);\n      break;\n    }\n    default:\n      break;\n  }\n  if (y < (ssize_t) rows)\n    {\n      ThrowFileException(exception,CacheError,\"UnableToWritePixelCache\",\n        cache_info->cache_filename);\n      return(MagickFalse);\n    }\n  if ((cache_info->debug != MagickFalse) &&\n      (CacheTick(nexus_info->region.y,cache_info->rows) != MagickFalse))\n    (void) LogMagickEvent(CacheEvent,GetMagickModule(),\n      \"%s[%.20gx%.20g%+.20g%+.20g]\",cache_info->filename,(double)\n      nexus_info->region.width,(double) nexus_info->region.height,(double)\n      nexus_info->region.x,(double) nexus_info->region.y);\n  return(MagickTrue);\n}\n\n// MaskPixelCacheNexus from magick/cache.c:\nstatic MagickBooleanType MaskPixelCacheNexus(Image *image,NexusInfo *nexus_info, /* <=== MaskPixelCacheNexus */ \n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const PixelPacket\n    *magick_restrict r;\n\n  IndexPacket\n    *magick_restrict nexus_indexes,\n    *magick_restrict indexes;\n\n  MagickOffsetType\n    n;\n\n  MagickPixelPacket\n    alpha,\n    beta;\n\n  NexusInfo\n    **magick_restrict mask_nexus;\n\n  PixelPacket\n    *magick_restrict p,\n    *magick_restrict q;\n\n  ssize_t\n    y;\n\n  /*\n    Apply composite mask.\n  */\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if ((image->mask == (Image *) NULL) || (image->storage_class == PseudoClass))\n    return(MagickTrue);\n  if ((nexus_info->region.width == 0) || (nexus_info->region.height == 0))\n    return(MagickTrue);\n  cache_info=(CacheInfo *) image->cache;\n  if (cache_info == (Cache) NULL)\n    return(MagickFalse);\n  mask_nexus=AcquirePixelCacheNexus(1);\n  p=GetAuthenticPixelCacheNexus(image,nexus_info->region.x,nexus_info->region.y,    nexus_info->region.width,nexus_info->region.height,\n    nexus_info->virtual_nexus,exception);\n  indexes=nexus_info->virtual_nexus->indexes;\n  q=nexus_info->pixels;\n  nexus_indexes=nexus_info->indexes;\n  r=GetVirtualPixelCacheNexus(image->mask,MaskVirtualPixelMethod,\n    nexus_info->region.x,nexus_info->region.y,nexus_info->region.width,\n    nexus_info->region.height,mask_nexus[0],&image->exception);\n  if ((p == (PixelPacket *) NULL) || (q == (PixelPacket *) NULL) ||\n      (r == (const PixelPacket *) NULL))\n    return(MagickFalse);\n  n=0;\n  GetMagickPixelPacket(image,&alpha);\n  GetMagickPixelPacket(image,&beta);\n  for (y=0; y < (ssize_t) nexus_info->region.height; y++)\n  {\n    ssize_t\n      x;\n\n    for (x=0; x < (ssize_t) nexus_info->region.width; x++)\n    {\n      SetMagickPixelPacket(image,p,indexes+n,&alpha);\n      SetMagickPixelPacket(image,q,nexus_indexes+n,&beta);\n      ApplyPixelCompositeMask(&beta,GetPixelIntensity(image,r),&alpha,\n        alpha.opacity,&beta);\n      SetPixelRed(q,ClampToQuantum(beta.red));\n      SetPixelGreen(q,ClampToQuantum(beta.green));\n      SetPixelBlue(q,ClampToQuantum(beta.blue));\n      SetPixelOpacity(q,ClampToQuantum(beta.opacity));\n      if (cache_info->active_index_channel != MagickFalse)\n        SetPixelIndex(nexus_indexes+n,GetPixelIndex(indexes+n));\n      p++;\n      q++;\n      r++;\n      n++;\n    }\n  }\n  mask_nexus=DestroyPixelCacheNexus(mask_nexus,1);\n  return(MagickTrue);\n}\n\n// ClampToQuantum from magick/quantum.h:\nstatic inline Quantum ClampToQuantum(const MagickRealType quantum) /* <=== ClampToQuantum */ \n{\n#if defined(MAGICKCORE_HDRI_SUPPORT)\n  return((Quantum) quantum);\n#else\n  if ((IsNaN(quantum) != 0) || (quantum <= 0.0))\n    return((Quantum) 0);\n  if (quantum >= (MagickRealType) QuantumRange)\n    return(QuantumRange);\n  return((Quantum) (quantum+0.5));\n#endif\n}\n\n// SyncAuthenticPixelCacheNexus from magick/cache.c:\nMagickExport MagickBooleanType SyncAuthenticPixelCacheNexus(Image *image, /* <=== SyncAuthenticPixelCacheNexus */ \n  NexusInfo *magick_restrict nexus_info,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  MagickBooleanType\n    status;\n\n  /*\n    Transfer pixels to the cache.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->cache == (Cache) NULL)\n    ThrowBinaryException(CacheError,\"PixelCacheIsNotOpen\",image->filename);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->type == UndefinedCache)\n    return(MagickFalse);\n  if ((image->storage_class == DirectClass) &&\n      (image->clip_mask != (Image *) NULL) &&\n      (ClipPixelCacheNexus(image,nexus_info,exception) == MagickFalse))\n    return(MagickFalse);\n  if ((image->storage_class == DirectClass) &&\n      (image->mask != (Image *) NULL) &&\n      (MaskPixelCacheNexus(image,nexus_info,exception) == MagickFalse))\n    return(MagickFalse);\n  if (nexus_info->authentic_pixel_cache != MagickFalse)\n    {\n      if (image->taint == MagickFalse)\n        image->taint=MagickTrue;\n      return(MagickTrue);\n    }\n  assert(cache_info->signature == MagickCoreSignature);\n  status=WritePixelCachePixels(cache_info,nexus_info,exception);\n  if ((cache_info->active_index_channel != MagickFalse) &&\n      (WritePixelCacheIndexes(cache_info,nexus_info,exception) == MagickFalse))\n    return(MagickFalse);\n  if ((status != MagickFalse) && (image->taint == MagickFalse))\n    image->taint=MagickTrue;\n  return(status);\n}\n\n// GetOpenMPThreadId from magick/thread-private.h:\nstatic inline int GetOpenMPThreadId(void) /* <=== GetOpenMPThreadId */ \n{\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  return(omp_get_thread_num());\n#else\n  return(0);\n#endif\n}\n\n// SetPixelRGBO from coders/magick/magick/pixel-accessor.h:\n\n"
  },
  {
    "repository": "tensorflow",
    "cve_id": "CVE-2022-21730",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "002408c3696b173863228223d535f9de72a101a9",
    "short_hash": "002408c3",
    "vulnerableMethods_before": [
      {
        "filename": "fractional_avg_pool_op.cc",
        "method_name": "vulnerable_function",
        "raw_code": "  void Compute(OpKernelContext* context) override {\n    // Here's the basic idea:\n    // Batch and depth dimension are independent from row and col dimension. And\n    // because FractionalAvgPool currently only support pooling along row and\n    // col, we can basically think of this 4D tensor backpropagation as\n    // operation of a series of 2D planes.\n    //\n    // For each element of a 'slice' (2D plane) of output_backprop, we need to\n    // figure out its contributors when doing FractionalAvgPool operation. This\n    // can be done based on row_pooling_sequence, col_pooling_seq and\n    // overlapping.\n    // Once we figure out the original contributors, we just need to evenly\n    // divide the value of this element among these contributors.\n    //\n    // Internally, we divide the out_backprop tensor and store it in a temporary\n    // tensor of double type. And cast it to the corresponding type.\n    typedef Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>\n        ConstEigenMatrixMap;\n    typedef Eigen::Map<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>>\n        EigenDoubleMatrixMap;\n\n    // Grab the inputs.\n    const Tensor& orig_input_tensor_shape = context->input(0);\n    OP_REQUIRES(context,\n                orig_input_tensor_shape.dims() == 1 &&\n                    orig_input_tensor_shape.NumElements() == 4,\n                errors::InvalidArgument(\"original input tensor shape must be\"\n                                        \"1-dimensional and 4 elements\"));\n    const Tensor& out_backprop = context->input(1);\n    const Tensor& row_seq_tensor = context->input(2);\n    const Tensor& col_seq_tensor = context->input(3);\n\n    const int64_t out_batch = out_backprop.dim_size(0);\n    const int64_t out_rows = out_backprop.dim_size(1);\n    const int64_t out_cols = out_backprop.dim_size(2);\n    const int64_t out_depth = out_backprop.dim_size(3);\n\n    OP_REQUIRES(context, row_seq_tensor.NumElements() > out_rows,\n                errors::InvalidArgument(\"Given out_backprop shape \",\n                                        out_backprop.shape().DebugString(),\n                                        \", row_seq_tensor must have at least \",\n                                        out_rows + 1, \" elements, but got \",\n                                        row_seq_tensor.NumElements()));\n    OP_REQUIRES(context, col_seq_tensor.NumElements() > out_cols,\n                errors::InvalidArgument(\"Given out_backprop shape \",\n                                        out_backprop.shape().DebugString(),\n                                        \", col_seq_tensor must have at least \",\n                                        out_cols + 1, \" elements, but got \",\n                                        col_seq_tensor.NumElements()));\n\n    auto row_seq_tensor_flat = row_seq_tensor.flat<int64_t>();\n    auto col_seq_tensor_flat = col_seq_tensor.flat<int64_t>();\n    auto orig_input_tensor_shape_flat = orig_input_tensor_shape.flat<int64_t>();\n\n    const int64_t in_batch = orig_input_tensor_shape_flat(0);\n    const int64_t in_rows = orig_input_tensor_shape_flat(1);\n    const int64_t in_cols = orig_input_tensor_shape_flat(2);\n    const int64_t in_depth = orig_input_tensor_shape_flat(3);\n    OP_REQUIRES(\n        context, in_batch != 0,\n        errors::InvalidArgument(\"Batch dimension of input must not be 0\"));\n    OP_REQUIRES(\n        context, in_rows != 0,\n        errors::InvalidArgument(\"Rows dimension of input must not be 0\"));\n    OP_REQUIRES(\n        context, in_cols != 0,\n        errors::InvalidArgument(\"Columns dimension of input must not be 0\"));\n    OP_REQUIRES(\n        context, in_depth != 0,\n        errors::InvalidArgument(\"Depth dimension of input must not be 0\"));\n\n    constexpr int tensor_in_and_out_dims = 4;\n    // Transform orig_input_tensor_shape into TensorShape\n    TensorShape in_shape;\n    for (auto i = 0; i < tensor_in_and_out_dims; ++i) {\n      in_shape.AddDim(orig_input_tensor_shape_flat(i));\n    }\n\n    // Create intermediate in_backprop.\n    Tensor in_backprop_tensor_temp;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_temp(\n                                {0}, DataTypeToEnum<double>::v(), in_shape,\n                                &in_backprop_tensor_temp));\n    in_backprop_tensor_temp.flat<double>().setZero();\n    // Transform 4D tensor to 2D matrix.\n    EigenDoubleMatrixMap in_backprop_tensor_temp_mat(\n        in_backprop_tensor_temp.flat<double>().data(), in_depth,\n        in_cols * in_rows * in_batch);\n    ConstEigenMatrixMap out_backprop_mat(out_backprop.flat<T>().data(),\n                                         out_depth,\n                                         out_cols * out_rows * out_batch);\n    // Loop through each element of out_backprop and evenly distribute the\n    // element to the corresponding pooling cell.\n    const int64_t in_max_row_index = in_rows - 1;\n    const int64_t in_max_col_index = in_cols - 1;\n    for (int64_t b = 0; b < out_batch; ++b) {\n      for (int64_t r = 0; r < out_rows; ++r) {\n        const int64_t in_row_start = row_seq_tensor_flat(r);\n        int64_t in_row_end = overlapping_ ? row_seq_tensor_flat(r + 1)\n                                          : row_seq_tensor_flat(r + 1) - 1;\n        in_row_end = std::min(in_row_end, in_max_row_index);\n        for (int64_t c = 0; c < out_cols; ++c) {\n          const int64_t in_col_start = col_seq_tensor_flat(c);\n          int64_t in_col_end = overlapping_ ? col_seq_tensor_flat(c + 1)\n                                            : col_seq_tensor_flat(c + 1) - 1;\n          in_col_end = std::min(in_col_end, in_max_col_index);\n\n          const int64_t num_elements_in_pooling_cell =\n              (in_row_end - in_row_start + 1) * (in_col_end - in_col_start + 1);\n          const int64_t out_index = (b * out_rows + r) * out_cols + c;\n          // Now we can evenly distribute out_backprop(b, h, w, *) to\n          // in_backprop(b, hs:he, ws:we, *).\n          for (int64_t in_r = in_row_start; in_r <= in_row_end; ++in_r) {\n            for (int64_t in_c = in_col_start; in_c <= in_col_end; ++in_c) {\n              const int64_t in_index = (b * in_rows + in_r) * in_cols + in_c;\n              // Walk through each channel (depth).\n              for (int64_t d = 0; d < out_depth; ++d) {\n                const double out_backprop_element = static_cast<double>(\n                    out_backprop_mat.coeffRef(d, out_index));\n                double& in_backprop_ref =\n                    in_backprop_tensor_temp_mat.coeffRef(d, in_index);\n                in_backprop_ref +=\n                    out_backprop_element / num_elements_in_pooling_cell;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Depending on the type, cast double to type T.\n    Tensor* in_backprop_tensor = nullptr;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                {0}, 0, in_shape, &in_backprop_tensor));\n    auto in_backprop_tensor_flat = in_backprop_tensor->flat<T>();\n    auto in_backprop_tensor_temp_flat = in_backprop_tensor_temp.flat<double>();\n    for (int64_t i = 0; i < in_backprop_tensor_flat.size(); ++i) {\n      in_backprop_tensor_flat(i) =\n          static_cast<T>(in_backprop_tensor_temp_flat(i));\n    }\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "fractional_avg_pool_op.cc",
        "method_name": "fixed_function",
        "raw_code": "  void Compute(OpKernelContext* context) override {\n    // Here's the basic idea:\n    // Batch and depth dimension are independent from row and col dimension. And\n    // because FractionalAvgPool currently only support pooling along row and\n    // col, we can basically think of this 4D tensor backpropagation as\n    // operation of a series of 2D planes.\n    //\n    // For each element of a 'slice' (2D plane) of output_backprop, we need to\n    // figure out its contributors when doing FractionalAvgPool operation. This\n    // can be done based on row_pooling_sequence, col_pooling_seq and\n    // overlapping.\n    // Once we figure out the original contributors, we just need to evenly\n    // divide the value of this element among these contributors.\n    //\n    // Internally, we divide the out_backprop tensor and store it in a temporary\n    // tensor of double type. And cast it to the corresponding type.\n    typedef Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>\n        ConstEigenMatrixMap;\n    typedef Eigen::Map<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>>\n        EigenDoubleMatrixMap;\n\n    // Grab the inputs.\n    const Tensor& orig_input_tensor_shape = context->input(0);\n    OP_REQUIRES(context,\n                orig_input_tensor_shape.dims() == 1 &&\n                    orig_input_tensor_shape.NumElements() == 4,\n                errors::InvalidArgument(\"original input tensor shape must be\"\n                                        \"1-dimensional and 4 elements\"));\n    const Tensor& out_backprop = context->input(1);\n    const Tensor& row_seq_tensor = context->input(2);\n    const Tensor& col_seq_tensor = context->input(3);\n\n    const int64_t out_batch = out_backprop.dim_size(0);\n    const int64_t out_rows = out_backprop.dim_size(1);\n    const int64_t out_cols = out_backprop.dim_size(2);\n    const int64_t out_depth = out_backprop.dim_size(3);\n\n    OP_REQUIRES(context, row_seq_tensor.NumElements() > out_rows,\n                errors::InvalidArgument(\"Given out_backprop shape \",\n                                        out_backprop.shape().DebugString(),\n                                        \", row_seq_tensor must have at least \",\n                                        out_rows + 1, \" elements, but got \",\n                                        row_seq_tensor.NumElements()));\n    OP_REQUIRES(context, col_seq_tensor.NumElements() > out_cols,\n                errors::InvalidArgument(\"Given out_backprop shape \",\n                                        out_backprop.shape().DebugString(),\n                                        \", col_seq_tensor must have at least \",\n                                        out_cols + 1, \" elements, but got \",\n                                        col_seq_tensor.NumElements()));\n\n    auto row_seq_tensor_flat = row_seq_tensor.flat<int64_t>();\n    auto col_seq_tensor_flat = col_seq_tensor.flat<int64_t>();\n    auto orig_input_tensor_shape_flat = orig_input_tensor_shape.flat<int64_t>();\n\n    const int64_t in_batch = orig_input_tensor_shape_flat(0);\n    const int64_t in_rows = orig_input_tensor_shape_flat(1);\n    const int64_t in_cols = orig_input_tensor_shape_flat(2);\n    const int64_t in_depth = orig_input_tensor_shape_flat(3);\n    OP_REQUIRES(\n        context, in_batch != 0,\n        errors::InvalidArgument(\"Batch dimension of input must not be 0\"));\n    OP_REQUIRES(\n        context, in_rows != 0,\n        errors::InvalidArgument(\"Rows dimension of input must not be 0\"));\n    OP_REQUIRES(\n        context, in_cols != 0,\n        errors::InvalidArgument(\"Columns dimension of input must not be 0\"));\n    OP_REQUIRES(\n        context, in_depth != 0,\n        errors::InvalidArgument(\"Depth dimension of input must not be 0\"));\n\n    constexpr int tensor_in_and_out_dims = 4;\n    // Transform orig_input_tensor_shape into TensorShape\n    TensorShape in_shape;\n    for (auto i = 0; i < tensor_in_and_out_dims; ++i) {\n      in_shape.AddDim(orig_input_tensor_shape_flat(i));\n    }\n\n    // Create intermediate in_backprop.\n    Tensor in_backprop_tensor_temp;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_temp(\n                                {0}, DataTypeToEnum<double>::v(), in_shape,\n                                &in_backprop_tensor_temp));\n    in_backprop_tensor_temp.flat<double>().setZero();\n    // Transform 4D tensor to 2D matrix.\n    EigenDoubleMatrixMap in_backprop_tensor_temp_mat(\n        in_backprop_tensor_temp.flat<double>().data(), in_depth,\n        in_cols * in_rows * in_batch);\n    ConstEigenMatrixMap out_backprop_mat(out_backprop.flat<T>().data(),\n                                         out_depth,\n                                         out_cols * out_rows * out_batch);\n    // Loop through each element of out_backprop and evenly distribute the\n    // element to the corresponding pooling cell.\n    const int64_t in_max_row_index = in_rows - 1;\n    const int64_t in_max_col_index = in_cols - 1;\n    for (int64_t b = 0; b < out_batch; ++b) {\n      for (int64_t r = 0; r < out_rows; ++r) {\n        const int64_t in_row_start = row_seq_tensor_flat(r);\n\n        int64_t in_row_end = overlapping_ ? row_seq_tensor_flat(r + 1)\n                                          : row_seq_tensor_flat(r + 1) - 1;\n        in_row_end = std::min(in_row_end, in_max_row_index);\n        OP_REQUIRES(context, in_row_start >= 0 && in_row_end >= 0,\n                    errors::InvalidArgument(\n                        \"Row sequence tensor values must not be negative, got \",\n                        row_seq_tensor_flat));\n\n        for (int64_t c = 0; c < out_cols; ++c) {\n          const int64_t in_col_start = col_seq_tensor_flat(c);\n          int64_t in_col_end = overlapping_ ? col_seq_tensor_flat(c + 1)\n                                            : col_seq_tensor_flat(c + 1) - 1;\n          in_col_end = std::min(in_col_end, in_max_col_index);\n\n          OP_REQUIRES(\n              context, in_col_start >= 0 && in_col_end >= 0,\n              errors::InvalidArgument(\n                  \"Column sequence tensor values must not be negative, got \",\n                  col_seq_tensor_flat));\n          const int64_t num_elements_in_pooling_cell =\n              (in_row_end - in_row_start + 1) * (in_col_end - in_col_start + 1);\n          const int64_t out_index = (b * out_rows + r) * out_cols + c;\n          // Now we can evenly distribute out_backprop(b, h, w, *) to\n          // in_backprop(b, hs:he, ws:we, *).\n          for (int64_t in_r = in_row_start; in_r <= in_row_end; ++in_r) {\n            for (int64_t in_c = in_col_start; in_c <= in_col_end; ++in_c) {\n              const int64_t in_index = (b * in_rows + in_r) * in_cols + in_c;\n              // Walk through each channel (depth).\n              for (int64_t d = 0; d < out_depth; ++d) {\n                const double out_backprop_element = static_cast<double>(\n                    out_backprop_mat.coeffRef(d, out_index));\n                double& in_backprop_ref =\n                    in_backprop_tensor_temp_mat.coeffRef(d, in_index);\n                in_backprop_ref +=\n                    out_backprop_element / num_elements_in_pooling_cell;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Depending on the type, cast double to type T.\n    Tensor* in_backprop_tensor = nullptr;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                {0}, 0, in_shape, &in_backprop_tensor));\n    auto in_backprop_tensor_flat = in_backprop_tensor->flat<T>();\n    auto in_backprop_tensor_temp_flat = in_backprop_tensor_temp.flat<double>();\n    for (int64_t i = 0; i < in_backprop_tensor_flat.size(); ++i) {\n      in_backprop_tensor_flat(i) =\n          static_cast<T>(in_backprop_tensor_temp_flat(i));\n    }\n  }",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <cmath>\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/kernels/fractional_pool_common.h\"\n#include <algorithm>\n#include <random>\n#include <vector>\n#include \"tensorflow/core/framework/numeric_op.h\"\n#include \"tensorflow/core/platform/mutex.h\"\n#include \"tensorflow/core/util/guarded_philox_random.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/lib/random/random.h\"\n\n// Type Definitions:\n// FractionalAvgPoolGradOp:\nclass FractionalAvgPoolGradOp : public OpKernel {\n public:\n  explicit FractionalAvgPoolGradOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"overlapping\", &overlapping_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    // Here's the basic idea:\n    // Batch and depth dimension are independent from row and col dimension. And\n    // because FractionalAvgPool currently only support pooling along row and\n    // col, we can basically think of this 4D tensor backpropagation as\n    // operation of a series of 2D planes.\n    //\n    // For each element of a 'slice' (2D plane) of output_backprop, we need to\n    // figure out its contributors when doing FractionalAvgPool operation. This\n    // can be done based on row_pooling_sequence, col_pooling_seq and\n    // overlapping.\n    // Once we figure out the original contributors, we just need to evenly\n    // divide the value of this element among these contributors.\n    //\n ...\n\n// Tensor:\ntensorflow.TensorHandle.Tensor:tensorflow.Status(tensorflow.Tensor**)<const>\n\n// Status:\nclass Status\n\n// OpKernelContext:\nclass OpKernelContext {\n public:\n  // The first element of a WrappedAllocator is a \"base\" Allocator and\n  // the second element is that Allocator wrapped by a\n  // TrackingAllocator\n  typedef std::pair<Allocator*, TrackingAllocator*> WrappedAllocator;\n\n  // TODO(zhifengc): Do some cleanup of Params.\n  // The Params struct is passed in to initialize an OpKernelContext,\n  // and must outlive the OpKernelContext.\n  struct Params {\n    ~Params() { delete eigen_gpu_device; }\n\n    // The step being executed.\n    int64_t step_id = 0;\n\n    // Timestamp for the start of graph execution. Used for latency metrics.\n    int64_t start_time_usecs = 0;\n\n    // The deadline for the session to complete by. Empty if unspecified.\n    absl::optional<absl::Time> deadline;\n\n    // The op kernel being computed.\n    OpKernel* op_kernel = nullptr;\n\n    // The device on which the kernel is running.\n    DeviceBase* device = nullptr;\n\n    // The Eigen GPU device wrapper, which may include a per-op\n    // wrappe...\n\n// Status:\nclass Status {\n public:\n  /// Create a success status.\n  Status() {}\n\n  /// \\brief Create a status with the specified error code and msg as a\n  /// human-readable string containing more detailed information.\n  Status(tensorflow::error::Code code, tensorflow::StringPiece msg)\n      : Status(code, msg, {}) {}\n\n  /// \\brief Create a status with the specified error code, msg, and stack trace\n  /// as a human-readable string containing more detailed information.\n#ifndef SWIG\n  Status(tensorflow::error::Code code, tensorflow::StringPiece msg,\n         std::vector<StackFrame>&& stack_trace);\n#endif\n\n  /// Copy the specified status.\n  Status(const Status& s);\n  Status& operator=(const Status& s);\n#ifndef SWIG\n  Status(Status&& s) noexcept;\n  Status& operator=(Status&& s) noexcept;\n#endif  // SWIG\n\n  static Status OK() { return Status(); }\n\n  /// Returns true iff the status indicates success.\n  bool ok() const { return (state_ == nullptr); }\n\n  tensorflow::error::Code code() const {\n    retu...\n\n// OpKernelContext:\ntensorflow.OpKernelContext.OpKernelContext:ANY(tensorflow.OpKernelContext.Params*)\n\n// EigenDoubleMatrixMap:\ntypedef Eigen::Map<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>>\n        EigenDoubleMatrixMap;\n\n// TensorShape:\nclass TensorShape : public TensorShapeBase<TensorShape> {\n public:\n  using TensorShapeBase<TensorShape>::TensorShapeBase;\n\n  // These factory methods should be used instead of the constructors that take\n  // an array of sizes if calling code cannot validate that the sizes specify a\n  // valid `TensorShape`.\n  // The value in `*out` is valid iff the returned value is `Status::OK`.\n  static Status BuildTensorShape(gtl::ArraySlice<int64_t> dim_sizes,\n                                 TensorShape* out) {\n    return BuildTensorShapeBase(dim_sizes, out);\n  }\n  static Status BuildTensorShape(std::initializer_list<int64_t> dim_sizes,\n                                 TensorShape* out) {\n    return BuildTensorShape(gtl::ArraySlice<int64_t>(dim_sizes), out);\n  }\n  static Status BuildTensorShape(const TensorShapeProto& proto,\n                                 TensorShape* out) {\n    return BuildTensorShapeBase(proto, out);\n  }\n\n  /// Allow a TensorShape to be used as a PartialTensorShape without ...\n\n// ConstEigenMatrixMap:\ntypedef Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>\n          ConstEigenMatrixMap;\n\n// Tensor:\nclass Tensor {\n public:\n  /// \\brief Creates a 1-dimensional, 0-element float tensor.\n  ///\n  /// The returned Tensor is not a scalar (shape {}), but is instead\n  /// an empty one-dimensional Tensor (shape {0}, NumElements() ==\n  /// 0). Since it has no elements, it does not need to be assigned a\n  /// value and is initialized by default (IsInitialized() is\n  /// true). If this is undesirable, consider creating a one-element\n  /// scalar which does require initialization:\n  ///\n  /// ```c++\n  ///\n  ///     Tensor(DT_FLOAT, TensorShape({}))\n  ///\n  /// ```\n  Tensor();\n\n  /// \\brief Creates a Tensor of the given `type` and `shape`.  If\n  /// LogMemory::IsEnabled() the allocation is logged as coming from\n  /// an unknown kernel and step. Calling the Tensor constructor\n  /// directly from within an Op is deprecated: use the\n  /// OpKernelConstruction/OpKernelContext allocate_* methods to\n  /// allocate a new tensor, which record the kernel and step.\n  ///\n  /// The underlying buffer is ...\n\n// Called Methods (top 10):\n// Update from tensorflow/core/platform/status.cc:\nvoid Status::Update(const Status& new_status) { /* <=== tensorflow.Status.Update:void(tensorflow.Status&) */ \n  if (ok()) {\n    *this = new_status;\n  }\n}\n\n// CHECK_LT from tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/platform/logging.h:\n\n\n// CHECK_GE from tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/platform/logging.h:\n\n\n// ok from tensorflow/core/platform/status.h:\n  bool ok() const { return (state_ == nullptr); } /* <=== tensorflow.Status.ok:bool()<const> */ \n\n// LOG from tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/platform/logging.h:\n\n\n// CheckNotInComputeAsync from tensorflow/core/framework/op_kernel.cc:\nvoid CheckNotInComputeAsync(OpKernelContext* ctx, /* <=== tensorflow.CheckNotInComputeAsync:void(tensorflow.OpKernelContext*,char*) */ \n                            const char* correct_macro_name) {\n  CHECK_EQ(nullptr, ctx->params_->op_kernel->AsAsync())\n      << \"Use \" << correct_macro_name << \" in AsyncOpKernel implementations.\";\n}\n\n// CtxFailureWithWarning from tensorflow/core/framework/op_kernel.cc:\nvoid OpKernelContext::CtxFailureWithWarning(const char* file, int line, /* <=== tensorflow.OpKernelContext.CtxFailureWithWarning:void(char*,int,tensorflow.Status&) */ \n                                            const Status& s) {\n  LOG(WARNING) << \"OP_REQUIRES failed at \" << io::Basename(file) << \":\" << line\n               << \" : \" << s;\n  SetStatus(s);\n}\n\n// dims from tensorflow/core/framework/tensor.h:\n  int dims() const { return shape().dims(); } /* <=== tensorflow.Tensor.dims:int()<const> */ \n\n// SetStatus from tensorflow/core/framework/op_kernel.cc:\nvoid OpKernelConstruction::SetStatus(const Status& status) { /* <=== tensorflow.OpKernelConstruction.SetStatus:void(tensorflow.Status&) */ \n  status_->Update(status);\n}\n\n// TF_RETURN_IF_ERROR from tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/errors.h:\n\n"
  },
  {
    "repository": "ImageMagick6",
    "cve_id": "CVE-2022-28463",
    "cwe_list": [
      "CWE-787"
    ],
    "commit_hash": "e6ea5876e0228165ee3abc6e959aa174cee06680",
    "short_hash": "e6ea5876",
    "vulnerableMethods_before": [
      {
        "filename": "cin.c",
        "method_name": "vulnerable_function",
        "raw_code": "static Image *ReadCINImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define MonoColorType  1\n#define RGBColorType  3\n\n  char\n    property[MaxTextExtent];\n\n  CINInfo\n    cin;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  ssize_t\n    i;\n\n  PixelPacket\n    *q;\n\n  size_t\n    extent,\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    magick[4],\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    File information.\n  */\n  offset=0;\n  count=ReadBlob(image,4,magick);\n  offset+=count;\n  if ((count != 4) ||\n      ((LocaleNCompare((char *) magick,\"\\200\\052\\137\\327\",4) != 0)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  memset(&cin,0,sizeof(cin));\n  image->endian=(magick[0] == 0x80) && (magick[1] == 0x2a) &&\n    (magick[2] == 0x5f) && (magick[3] == 0xd7) ? MSBEndian : LSBEndian;\n  cin.file.image_offset=ReadBlobLong(image);\n  offset+=4;\n  cin.file.generic_length=ReadBlobLong(image);\n  offset+=4;\n  cin.file.industry_length=ReadBlobLong(image);\n  offset+=4;\n  cin.file.user_length=ReadBlobLong(image);\n  offset+=4;\n  cin.file.file_size=ReadBlobLong(image);\n  offset+=4;\n  offset+=ReadBlob(image,sizeof(cin.file.version),(unsigned char *)\n    cin.file.version);\n  (void) CopyMagickString(property,cin.file.version,sizeof(cin.file.version));\n  (void) SetImageProperty(image,\"dpx:file.version\",property);\n  offset+=ReadBlob(image,sizeof(cin.file.filename),(unsigned char *)\n    cin.file.filename);\n  (void) CopyMagickString(property,cin.file.filename,sizeof(cin.file.filename));\n  (void) SetImageProperty(image,\"dpx:file.filename\",property);\n  offset+=ReadBlob(image,sizeof(cin.file.create_date),(unsigned char *)\n    cin.file.create_date);\n  (void) CopyMagickString(property,cin.file.create_date,\n    sizeof(cin.file.create_date));\n  (void) SetImageProperty(image,\"dpx:file.create_date\",property);\n  offset+=ReadBlob(image,sizeof(cin.file.create_time),(unsigned char *)\n    cin.file.create_time);\n  (void) CopyMagickString(property,cin.file.create_time,\n     sizeof(cin.file.create_time));\n  (void) SetImageProperty(image,\"dpx:file.create_time\",property);\n  offset+=ReadBlob(image,sizeof(cin.file.reserve),(unsigned char *)\n    cin.file.reserve);\n  /*\n    Image information.\n  */\n  cin.image.orientation=(unsigned char) ReadBlobByte(image);\n  offset++;\n  if (cin.image.orientation != (unsigned char) (~0))\n    (void) FormatImageProperty(image,\"dpx:image.orientation\",\"%d\",\n      cin.image.orientation);\n  switch (cin.image.orientation)\n  {\n    default:\n    case 0: image->orientation=TopLeftOrientation; break;\n    case 1: image->orientation=TopRightOrientation; break;\n    case 2: image->orientation=BottomLeftOrientation; break;\n    case 3: image->orientation=BottomRightOrientation; break;\n    case 4: image->orientation=LeftTopOrientation; break;\n    case 5: image->orientation=RightTopOrientation; break;\n    case 6: image->orientation=LeftBottomOrientation; break;\n    case 7: image->orientation=RightBottomOrientation; break;\n  }\n  cin.image.number_channels=(unsigned char) ReadBlobByte(image);\n  offset++;\n  offset+=ReadBlob(image,sizeof(cin.image.reserve1),(unsigned char *)\n    cin.image.reserve1);\n  for (i=0; i < 8; i++)\n  {\n    cin.image.channel[i].designator[0]=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].designator[1]=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].bits_per_pixel=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].reserve=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].pixels_per_line=ReadBlobLong(image);\n    offset+=4;\n    cin.image.channel[i].lines_per_image=ReadBlobLong(image);\n    offset+=4;\n    cin.image.channel[i].min_data=ReadBlobFloat(image);\n    offset+=4;\n    cin.image.channel[i].min_quantity=ReadBlobFloat(image);\n    offset+=4;\n    cin.image.channel[i].max_data=ReadBlobFloat(image);\n    offset+=4;\n    cin.image.channel[i].max_quantity=ReadBlobFloat(image);\n    offset+=4;\n  }\n  cin.image.white_point[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.white_point[0]) != MagickFalse)\n    image->chromaticity.white_point.x=cin.image.white_point[0];\n  cin.image.white_point[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.white_point[1]) != MagickFalse)\n    image->chromaticity.white_point.y=cin.image.white_point[1];\n  cin.image.red_primary_chromaticity[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.red_primary_chromaticity[0]) != MagickFalse)\n    image->chromaticity.red_primary.x=cin.image.red_primary_chromaticity[0];\n  cin.image.red_primary_chromaticity[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.red_primary_chromaticity[1]) != MagickFalse)\n    image->chromaticity.red_primary.y=cin.image.red_primary_chromaticity[1];\n  cin.image.green_primary_chromaticity[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.green_primary_chromaticity[0]) != MagickFalse)\n    image->chromaticity.red_primary.x=cin.image.green_primary_chromaticity[0];\n  cin.image.green_primary_chromaticity[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.green_primary_chromaticity[1]) != MagickFalse)\n    image->chromaticity.green_primary.y=cin.image.green_primary_chromaticity[1];\n  cin.image.blue_primary_chromaticity[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.blue_primary_chromaticity[0]) != MagickFalse)\n    image->chromaticity.blue_primary.x=cin.image.blue_primary_chromaticity[0];\n  cin.image.blue_primary_chromaticity[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.blue_primary_chromaticity[1]) != MagickFalse)\n    image->chromaticity.blue_primary.y=cin.image.blue_primary_chromaticity[1];\n  offset+=ReadBlob(image,sizeof(cin.image.label),(unsigned char *)\n    cin.image.label);\n  (void) CopyMagickString(property,cin.image.label,sizeof(cin.image.label));\n  (void) SetImageProperty(image,\"dpx:image.label\",property);\n  offset+=ReadBlob(image,sizeof(cin.image.reserve),(unsigned char *)\n    cin.image.reserve);\n  /*\n    Image data format information.\n  */\n  cin.data_format.interleave=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.packing=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.sign=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.sense=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.line_pad=ReadBlobLong(image);\n  offset+=4;\n  cin.data_format.channel_pad=ReadBlobLong(image);\n  offset+=4;\n  offset+=ReadBlob(image,sizeof(cin.data_format.reserve),(unsigned char *)\n    cin.data_format.reserve);\n  /*\n    Image origination information.\n  */\n  cin.origination.x_offset=ReadBlobSignedLong(image);\n  offset+=4;\n  if ((size_t) cin.origination.x_offset != ~0UL)\n    (void) FormatImageProperty(image,\"dpx:origination.x_offset\",\"%.20g\",\n      (double) cin.origination.x_offset);\n  cin.origination.y_offset=(ssize_t) ReadBlobLong(image);\n  offset+=4;\n  if ((size_t) cin.origination.y_offset != ~0UL)\n    (void) FormatImageProperty(image,\"dpx:origination.y_offset\",\"%.20g\",\n      (double) cin.origination.y_offset);\n  offset+=ReadBlob(image,sizeof(cin.origination.filename),(unsigned char *)\n    cin.origination.filename);\n  (void) CopyMagickString(property,cin.origination.filename,\n    sizeof(cin.origination.filename));\n  (void) SetImageProperty(image,\"dpx:origination.filename\",property);\n  offset+=ReadBlob(image,sizeof(cin.origination.create_date),(unsigned char *)\n    cin.origination.create_date);\n  (void) CopyMagickString(property,cin.origination.create_date,\n    sizeof(cin.origination.create_date));\n  (void) SetImageProperty(image,\"dpx:origination.create_date\",property);\n  offset+=ReadBlob(image,sizeof(cin.origination.create_time),(unsigned char *)\n    cin.origination.create_time);\n  (void) CopyMagickString(property,cin.origination.create_time,\n    sizeof(cin.origination.create_time));\n  (void) SetImageProperty(image,\"dpx:origination.create_time\",property);\n  offset+=ReadBlob(image,sizeof(cin.origination.device),(unsigned char *)\n    cin.origination.device);\n  (void) CopyMagickString(property,cin.origination.device,\n    sizeof(cin.origination.device));\n  (void) SetImageProperty(image,\"dpx:origination.device\",property);\n  offset+=ReadBlob(image,sizeof(cin.origination.model),(unsigned char *)\n    cin.origination.model);\n  (void) CopyMagickString(property,cin.origination.model,\n    sizeof(cin.origination.model));\n  (void) SetImageProperty(image,\"dpx:origination.model\",property);\n  (void) memset(cin.origination.serial,0,\n    sizeof(cin.origination.serial));\n  offset+=ReadBlob(image,sizeof(cin.origination.serial),(unsigned char *)\n    cin.origination.serial);\n  (void) CopyMagickString(property,cin.origination.serial,\n    sizeof(cin.origination.serial));\n  (void) SetImageProperty(image,\"dpx:origination.serial\",property);\n  cin.origination.x_pitch=ReadBlobFloat(image);\n  offset+=4;\n  cin.origination.y_pitch=ReadBlobFloat(image);\n  offset+=4;\n  cin.origination.gamma=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.origination.gamma) != MagickFalse)\n    image->gamma=cin.origination.gamma;\n  offset+=ReadBlob(image,sizeof(cin.origination.reserve),(unsigned char *)\n    cin.origination.reserve);\n  if ((cin.file.image_offset > 2048) && (cin.file.user_length != 0))\n    {\n      int\n        c;\n\n      /*\n        Image film information.\n      */\n      cin.film.id=ReadBlobByte(image);\n      offset++;\n      c=cin.film.id;\n      if (c != ~0)\n        (void) FormatImageProperty(image,\"dpx:film.id\",\"%d\",cin.film.id);\n      cin.film.type=ReadBlobByte(image);\n      offset++;\n      c=cin.film.type;\n      if (c != ~0)\n        (void) FormatImageProperty(image,\"dpx:film.type\",\"%d\",cin.film.type);\n      cin.film.offset=ReadBlobByte(image);\n      offset++;\n      c=cin.film.offset;\n      if (c != ~0)\n        (void) FormatImageProperty(image,\"dpx:film.offset\",\"%d\",\n          cin.film.offset);\n      cin.film.reserve1=ReadBlobByte(image);\n      offset++;\n      cin.film.prefix=ReadBlobLong(image);\n      offset+=4;\n      if (cin.film.prefix != ~0UL)\n        (void) FormatImageProperty(image,\"dpx:film.prefix\",\"%.20g\",(double)\n          cin.film.prefix);\n      cin.film.count=ReadBlobLong(image);\n      offset+=4;\n      offset+=ReadBlob(image,sizeof(cin.film.format),(unsigned char *)\n        cin.film.format);\n      (void) CopyMagickString(property,cin.film.format,\n        sizeof(cin.film.format));\n      (void) SetImageProperty(image,\"dpx:film.format\",property);\n      cin.film.frame_position=ReadBlobLong(image);\n      offset+=4;\n      if (cin.film.frame_position != ~0UL)\n        (void) FormatImageProperty(image,\"dpx:film.frame_position\",\"%.20g\",\n          (double) cin.film.frame_position);\n      cin.film.frame_rate=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(cin.film.frame_rate) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:film.frame_rate\",\"%g\",\n          cin.film.frame_rate);\n      offset+=ReadBlob(image,sizeof(cin.film.frame_id),(unsigned char *)\n        cin.film.frame_id);\n      (void) CopyMagickString(property,cin.film.frame_id,\n        sizeof(cin.film.frame_id));\n      (void) SetImageProperty(image,\"dpx:film.frame_id\",property);\n      offset+=ReadBlob(image,sizeof(cin.film.slate_info),(unsigned char *)\n        cin.film.slate_info);\n      (void) CopyMagickString(property,cin.film.slate_info,\n        sizeof(cin.film.slate_info));\n      (void) SetImageProperty(image,\"dpx:film.slate_info\",property);\n      offset+=ReadBlob(image,sizeof(cin.film.reserve),(unsigned char *)\n        cin.film.reserve);\n    }\n  if ((cin.file.image_offset > 2048) && (cin.file.user_length != 0))\n    {\n      StringInfo\n        *profile;\n\n      /*\n        User defined data.\n      */\n      if (cin.file.user_length > GetBlobSize(image))\n        ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n      profile=BlobToStringInfo((const void *) NULL,cin.file.user_length);\n      if (profile == (StringInfo *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      offset+=ReadBlob(image,GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n      (void) SetImageProfile(image,\"dpx:user.data\",profile);\n      profile=DestroyStringInfo(profile);\n    }\n  image->depth=cin.image.channel[0].bits_per_pixel;\n  image->columns=cin.image.channel[0].pixels_per_line;\n  image->rows=cin.image.channel[0].lines_per_image;\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(image);\n    }\n  if (((MagickSizeType) image->columns*image->rows/8) > GetBlobSize(image))\n    ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n  for ( ; offset < (MagickOffsetType) cin.file.image_offset; offset++)\n  {\n    int\n      c;\n\n    c=ReadBlobByte(image);\n    if (c == EOF)\n      break;\n  }\n  if (offset < (MagickOffsetType) cin.file.image_offset)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  (void) SetImageBackgroundColor(image);\n  /*\n    Convert CIN raster image to pixel packets.\n  */\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  SetQuantumQuantum(quantum_info,32);\n  SetQuantumPack(quantum_info,MagickFalse);\n  quantum_type=RGBQuantum;\n  extent=GetQuantumExtent(image,quantum_info,quantum_type);\n  (void) extent;\n  length=GetBytesPerRow(image->columns,3,image->depth,MagickTrue);\n  if (cin.image.number_channels == 1)\n    {\n      quantum_type=GrayQuantum;\n      length=GetBytesPerRow(image->columns,1,image->depth,MagickTrue);\n    }\n  status=SetQuantumPad(image,quantum_info,0);\n  pixels=GetQuantumPixels(quantum_info);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    const void\n      *stream;\n\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      break;\n    stream=ReadBlobStream(image,length,pixels,&count);\n    if (count != (ssize_t) length)\n      break;\n    (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n      quantum_type,(unsigned char *) stream,exception);\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  SetQuantumImageType(image,quantum_type);\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  SetImageColorspace(image,LogColorspace);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "cin.c",
        "method_name": "fixed_function",
        "raw_code": "static Image *ReadCINImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define MonoColorType  1\n#define RGBColorType  3\n\n  char\n    property[MaxTextExtent];\n\n  CINInfo\n    cin;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\n  ssize_t\n    i;\n\n  PixelPacket\n    *q;\n\n  size_t\n    extent,\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    magick[4],\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    File information.\n  */\n  offset=0;\n  count=ReadBlob(image,4,magick);\n  offset+=count;\n  if ((count != 4) ||\n      ((LocaleNCompare((char *) magick,\"\\200\\052\\137\\327\",4) != 0)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  memset(&cin,0,sizeof(cin));\n  image->endian=(magick[0] == 0x80) && (magick[1] == 0x2a) &&\n    (magick[2] == 0x5f) && (magick[3] == 0xd7) ? MSBEndian : LSBEndian;\n  cin.file.image_offset=ReadBlobLong(image);\n  if (cin.file.image_offset < 712)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  offset+=4;\n  cin.file.generic_length=ReadBlobLong(image);\n  offset+=4;\n  cin.file.industry_length=ReadBlobLong(image);\n  offset+=4;\n  cin.file.user_length=ReadBlobLong(image);\n  offset+=4;\n  cin.file.file_size=ReadBlobLong(image);\n  offset+=4;\n  offset+=ReadBlob(image,sizeof(cin.file.version),(unsigned char *)\n    cin.file.version);\n  (void) CopyMagickString(property,cin.file.version,sizeof(cin.file.version));\n  (void) SetImageProperty(image,\"dpx:file.version\",property);\n  offset+=ReadBlob(image,sizeof(cin.file.filename),(unsigned char *)\n    cin.file.filename);\n  (void) CopyMagickString(property,cin.file.filename,sizeof(cin.file.filename));\n  (void) SetImageProperty(image,\"dpx:file.filename\",property);\n  offset+=ReadBlob(image,sizeof(cin.file.create_date),(unsigned char *)\n    cin.file.create_date);\n  (void) CopyMagickString(property,cin.file.create_date,\n    sizeof(cin.file.create_date));\n  (void) SetImageProperty(image,\"dpx:file.create_date\",property);\n  offset+=ReadBlob(image,sizeof(cin.file.create_time),(unsigned char *)\n    cin.file.create_time);\n  (void) CopyMagickString(property,cin.file.create_time,\n     sizeof(cin.file.create_time));\n  (void) SetImageProperty(image,\"dpx:file.create_time\",property);\n  offset+=ReadBlob(image,sizeof(cin.file.reserve),(unsigned char *)\n    cin.file.reserve);\n  /*\n    Image information.\n  */\n  cin.image.orientation=(unsigned char) ReadBlobByte(image);\n  offset++;\n  if (cin.image.orientation != (unsigned char) (~0))\n    (void) FormatImageProperty(image,\"dpx:image.orientation\",\"%d\",\n      cin.image.orientation);\n  switch (cin.image.orientation)\n  {\n    default:\n    case 0: image->orientation=TopLeftOrientation; break;\n    case 1: image->orientation=TopRightOrientation; break;\n    case 2: image->orientation=BottomLeftOrientation; break;\n    case 3: image->orientation=BottomRightOrientation; break;\n    case 4: image->orientation=LeftTopOrientation; break;\n    case 5: image->orientation=RightTopOrientation; break;\n    case 6: image->orientation=LeftBottomOrientation; break;\n    case 7: image->orientation=RightBottomOrientation; break;\n  }\n  cin.image.number_channels=(unsigned char) ReadBlobByte(image);\n  offset++;\n  offset+=ReadBlob(image,sizeof(cin.image.reserve1),(unsigned char *)\n    cin.image.reserve1);\n  for (i=0; i < 8; i++)\n  {\n    cin.image.channel[i].designator[0]=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].designator[1]=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].bits_per_pixel=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].reserve=(unsigned char) ReadBlobByte(image);\n    offset++;\n    cin.image.channel[i].pixels_per_line=ReadBlobLong(image);\n    offset+=4;\n    cin.image.channel[i].lines_per_image=ReadBlobLong(image);\n    offset+=4;\n    cin.image.channel[i].min_data=ReadBlobFloat(image);\n    offset+=4;\n    cin.image.channel[i].min_quantity=ReadBlobFloat(image);\n    offset+=4;\n    cin.image.channel[i].max_data=ReadBlobFloat(image);\n    offset+=4;\n    cin.image.channel[i].max_quantity=ReadBlobFloat(image);\n    offset+=4;\n  }\n  cin.image.white_point[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.white_point[0]) != MagickFalse)\n    image->chromaticity.white_point.x=cin.image.white_point[0];\n  cin.image.white_point[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.white_point[1]) != MagickFalse)\n    image->chromaticity.white_point.y=cin.image.white_point[1];\n  cin.image.red_primary_chromaticity[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.red_primary_chromaticity[0]) != MagickFalse)\n    image->chromaticity.red_primary.x=cin.image.red_primary_chromaticity[0];\n  cin.image.red_primary_chromaticity[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.red_primary_chromaticity[1]) != MagickFalse)\n    image->chromaticity.red_primary.y=cin.image.red_primary_chromaticity[1];\n  cin.image.green_primary_chromaticity[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.green_primary_chromaticity[0]) != MagickFalse)\n    image->chromaticity.red_primary.x=cin.image.green_primary_chromaticity[0];\n  cin.image.green_primary_chromaticity[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.green_primary_chromaticity[1]) != MagickFalse)\n    image->chromaticity.green_primary.y=cin.image.green_primary_chromaticity[1];\n  cin.image.blue_primary_chromaticity[0]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.blue_primary_chromaticity[0]) != MagickFalse)\n    image->chromaticity.blue_primary.x=cin.image.blue_primary_chromaticity[0];\n  cin.image.blue_primary_chromaticity[1]=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.image.blue_primary_chromaticity[1]) != MagickFalse)\n    image->chromaticity.blue_primary.y=cin.image.blue_primary_chromaticity[1];\n  offset+=ReadBlob(image,sizeof(cin.image.label),(unsigned char *)\n    cin.image.label);\n  (void) CopyMagickString(property,cin.image.label,sizeof(cin.image.label));\n  (void) SetImageProperty(image,\"dpx:image.label\",property);\n  offset+=ReadBlob(image,sizeof(cin.image.reserve),(unsigned char *)\n    cin.image.reserve);\n  /*\n    Image data format information.\n  */\n  cin.data_format.interleave=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.packing=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.sign=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.sense=(unsigned char) ReadBlobByte(image);\n  offset++;\n  cin.data_format.line_pad=ReadBlobLong(image);\n  offset+=4;\n  cin.data_format.channel_pad=ReadBlobLong(image);\n  offset+=4;\n  offset+=ReadBlob(image,sizeof(cin.data_format.reserve),(unsigned char *)\n    cin.data_format.reserve);\n  /*\n    Image origination information.\n  */\n  cin.origination.x_offset=ReadBlobSignedLong(image);\n  offset+=4;\n  if ((size_t) cin.origination.x_offset != ~0UL)\n    (void) FormatImageProperty(image,\"dpx:origination.x_offset\",\"%.20g\",\n      (double) cin.origination.x_offset);\n  cin.origination.y_offset=(ssize_t) ReadBlobLong(image);\n  offset+=4;\n  if ((size_t) cin.origination.y_offset != ~0UL)\n    (void) FormatImageProperty(image,\"dpx:origination.y_offset\",\"%.20g\",\n      (double) cin.origination.y_offset);\n  offset+=ReadBlob(image,sizeof(cin.origination.filename),(unsigned char *)\n    cin.origination.filename);\n  (void) CopyMagickString(property,cin.origination.filename,\n    sizeof(cin.origination.filename));\n  (void) SetImageProperty(image,\"dpx:origination.filename\",property);\n  offset+=ReadBlob(image,sizeof(cin.origination.create_date),(unsigned char *)\n    cin.origination.create_date);\n  (void) CopyMagickString(property,cin.origination.create_date,\n    sizeof(cin.origination.create_date));\n  (void) SetImageProperty(image,\"dpx:origination.create_date\",property);\n  offset+=ReadBlob(image,sizeof(cin.origination.create_time),(unsigned char *)\n    cin.origination.create_time);\n  (void) CopyMagickString(property,cin.origination.create_time,\n    sizeof(cin.origination.create_time));\n  (void) SetImageProperty(image,\"dpx:origination.create_time\",property);\n  offset+=ReadBlob(image,sizeof(cin.origination.device),(unsigned char *)\n    cin.origination.device);\n  (void) CopyMagickString(property,cin.origination.device,\n    sizeof(cin.origination.device));\n  (void) SetImageProperty(image,\"dpx:origination.device\",property);\n  offset+=ReadBlob(image,sizeof(cin.origination.model),(unsigned char *)\n    cin.origination.model);\n  (void) CopyMagickString(property,cin.origination.model,\n    sizeof(cin.origination.model));\n  (void) SetImageProperty(image,\"dpx:origination.model\",property);\n  (void) memset(cin.origination.serial,0,\n    sizeof(cin.origination.serial));\n  offset+=ReadBlob(image,sizeof(cin.origination.serial),(unsigned char *)\n    cin.origination.serial);\n  (void) CopyMagickString(property,cin.origination.serial,\n    sizeof(cin.origination.serial));\n  (void) SetImageProperty(image,\"dpx:origination.serial\",property);\n  cin.origination.x_pitch=ReadBlobFloat(image);\n  offset+=4;\n  cin.origination.y_pitch=ReadBlobFloat(image);\n  offset+=4;\n  cin.origination.gamma=ReadBlobFloat(image);\n  offset+=4;\n  if (IsFloatDefined(cin.origination.gamma) != MagickFalse)\n    image->gamma=cin.origination.gamma;\n  offset+=ReadBlob(image,sizeof(cin.origination.reserve),(unsigned char *)\n    cin.origination.reserve);\n  if ((cin.file.image_offset > 2048) && (cin.file.user_length != 0))\n    {\n      int\n        c;\n\n      /*\n        Image film information.\n      */\n      cin.film.id=ReadBlobByte(image);\n      offset++;\n      c=cin.film.id;\n      if (c != ~0)\n        (void) FormatImageProperty(image,\"dpx:film.id\",\"%d\",cin.film.id);\n      cin.film.type=ReadBlobByte(image);\n      offset++;\n      c=cin.film.type;\n      if (c != ~0)\n        (void) FormatImageProperty(image,\"dpx:film.type\",\"%d\",cin.film.type);\n      cin.film.offset=ReadBlobByte(image);\n      offset++;\n      c=cin.film.offset;\n      if (c != ~0)\n        (void) FormatImageProperty(image,\"dpx:film.offset\",\"%d\",\n          cin.film.offset);\n      cin.film.reserve1=ReadBlobByte(image);\n      offset++;\n      cin.film.prefix=ReadBlobLong(image);\n      offset+=4;\n      if (cin.film.prefix != ~0UL)\n        (void) FormatImageProperty(image,\"dpx:film.prefix\",\"%.20g\",(double)\n          cin.film.prefix);\n      cin.film.count=ReadBlobLong(image);\n      offset+=4;\n      offset+=ReadBlob(image,sizeof(cin.film.format),(unsigned char *)\n        cin.film.format);\n      (void) CopyMagickString(property,cin.film.format,\n        sizeof(cin.film.format));\n      (void) SetImageProperty(image,\"dpx:film.format\",property);\n      cin.film.frame_position=ReadBlobLong(image);\n      offset+=4;\n      if (cin.film.frame_position != ~0UL)\n        (void) FormatImageProperty(image,\"dpx:film.frame_position\",\"%.20g\",\n          (double) cin.film.frame_position);\n      cin.film.frame_rate=ReadBlobFloat(image);\n      offset+=4;\n      if (IsFloatDefined(cin.film.frame_rate) != MagickFalse)\n        (void) FormatImageProperty(image,\"dpx:film.frame_rate\",\"%g\",\n          cin.film.frame_rate);\n      offset+=ReadBlob(image,sizeof(cin.film.frame_id),(unsigned char *)\n        cin.film.frame_id);\n      (void) CopyMagickString(property,cin.film.frame_id,\n        sizeof(cin.film.frame_id));\n      (void) SetImageProperty(image,\"dpx:film.frame_id\",property);\n      offset+=ReadBlob(image,sizeof(cin.film.slate_info),(unsigned char *)\n        cin.film.slate_info);\n      (void) CopyMagickString(property,cin.film.slate_info,\n        sizeof(cin.film.slate_info));\n      (void) SetImageProperty(image,\"dpx:film.slate_info\",property);\n      offset+=ReadBlob(image,sizeof(cin.film.reserve),(unsigned char *)\n        cin.film.reserve);\n    }\n  if ((cin.file.image_offset > 2048) && (cin.file.user_length != 0))\n    {\n      StringInfo\n        *profile;\n\n      /*\n        User defined data.\n      */\n      if (cin.file.user_length > GetBlobSize(image))\n        ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n      profile=BlobToStringInfo((const void *) NULL,cin.file.user_length);\n      if (profile == (StringInfo *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      offset+=ReadBlob(image,GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n      (void) SetImageProfile(image,\"dpx:user.data\",profile);\n      profile=DestroyStringInfo(profile);\n    }\n  image->depth=cin.image.channel[0].bits_per_pixel;\n  image->columns=cin.image.channel[0].pixels_per_line;\n  image->rows=cin.image.channel[0].lines_per_image;\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(image);\n    }\n  if (((MagickSizeType) image->columns*image->rows/8) > GetBlobSize(image))\n    ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n  for ( ; offset < (MagickOffsetType) cin.file.image_offset; offset++)\n  {\n    int\n      c;\n\n    c=ReadBlobByte(image);\n    if (c == EOF)\n      break;\n  }\n  if (offset < (MagickOffsetType) cin.file.image_offset)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  (void) SetImageBackgroundColor(image);\n  /*\n    Convert CIN raster image to pixel packets.\n  */\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  SetQuantumQuantum(quantum_info,32);\n  SetQuantumPack(quantum_info,MagickFalse);\n  quantum_type=RGBQuantum;\n  extent=GetQuantumExtent(image,quantum_info,quantum_type);\n  (void) extent;\n  length=GetBytesPerRow(image->columns,3,image->depth,MagickTrue);\n  if (cin.image.number_channels == 1)\n    {\n      quantum_type=GrayQuantum;\n      length=GetBytesPerRow(image->columns,1,image->depth,MagickTrue);\n    }\n  status=SetQuantumPad(image,quantum_info,0);\n  pixels=GetQuantumPixels(quantum_info);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    const void\n      *stream;\n\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      break;\n    stream=ReadBlobStream(image,length,pixels,&count);\n    if (count != (ssize_t) length)\n      break;\n    (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n      quantum_type,(unsigned char *) stream,exception);\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  SetQuantumImageType(image,quantum_type);\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  SetImageColorspace(image,LogColorspace);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"magick/blob-private.h\"\n#include \"magick/pixel-accessor.h\"\n#include \"magick/magick.h\"\n#include \"magick/artifact.h\"\n#include \"magick/exception.h\"\n#include \"magick/property.h\"\n#include \"magick/module.h\"\n#include \"magick/string-private.h\"\n#include \"magick/image.h\"\n#include \"magick/monitor.h\"\n#include \"magick/monitor-private.h\"\n#include \"magick/quantum-private.h\"\n#include \"magick/static.h\"\n#include \"magick/string_.h\"\n#include \"magick/image-private.h\"\n#include \"magick/studio.h\"\n#include \"magick/colorspace.h\"\n#include \"magick/blob.h\"\n#include \"magick/list.h\"\n#include \"magick/cache.h\"\n#include \"magick/timer-private.h\"\n#include \"magick/option.h\"\n#include \"magick/memory_.h\"\n#include \"magick/profile.h\"\n#include \"magick/exception-private.h\"\n\n// Type Definitions:\n// ImageInfo:\ntypedef struct _ImageInfo ImageInfo;\n\n// Image:\nclass MagickPPExport Image\n  {\n  public:\n\n    // Obtain image statistics. Statistics are normalized to the range\n    // of 0.0 to 1.0 and are output to the specified ImageStatistics\n    // structure.\n    typedef struct _ImageChannelStatistics\n    {\n      /* Minimum value observed */\n      double maximum;\n      /* Maximum value observed */\n      double minimum;\n      /* Average (mean) value observed */\n      double mean;\n      /* Standard deviation, sqrt(variance) */\n      double standard_deviation;\n      /* Variance */\n      double variance;\n      /* Kurtosis */\n      double kurtosis;\n      /* Skewness */\n      double skewness;\n    } ImageChannelStatistics;\n\n    typedef struct _ImageStatistics\n    {\n      ImageChannelStatistics red;\n      ImageChannelStatistics green;\n      ImageChannelStatistics blue;\n      ImageChannelStatistics opacity;\n    } ImageStatistics;\n\n    // Default constructor\n    Image(void);\n\n    // Construct Image from in-memory BLOB\n    Image(const Blob &blob_);\n\n  ...\n\n// StringInfo:\ntypedef struct _StringInfo\n{\n  char\n    path[MaxTextExtent];\n\n  unsigned char\n    *datum;\n\n  size_t\n    length,\n    signature;\n\n  char\n    *name;\n} StringInfo;\n\n// MagickBooleanType:\ntypedef enum\n{\n  MagickFalse = 0,\n  MagickTrue = 1\n}\n\n// _StringInfo:\ntypedef struct _StringInfo\n{\n  char\n    path[MaxTextExtent];\n\n  unsigned char\n    *datum;\n\n  size_t\n    length,\n    signature;\n\n  char\n    *name;\n}\n\n// _Image:\nstruct _Image\n{\n  ClassType\n    storage_class;\n\n  ColorspaceType\n    colorspace;      /* colorspace of image data */\n\n  CompressionType\n    compression;     /* compression of image when read/write */\n\n  size_t\n    quality;         /* compression quality setting, meaning varies */\n\n  OrientationType\n    orientation;     /* photo orientation of image */\n\n  MagickBooleanType\n    taint,           /* has image been modified since reading */\n    matte;           /* is transparency channel defined and active */\n\n  size_t\n    columns,         /* physical size of image */\n    rows,\n    depth,           /* depth of image on read/write */\n    colors;          /* size of color table on read */\n\n  PixelPacket\n    *colormap,\n    background_color, /* current background color attribute */\n    border_color,     /* current bordercolor attribute */\n    matte_color;      /* current mattecolor attribute */\n\n  double\n    gamma;\n\n  ChromaticityInfo\n    chromaticity;\n\n  RenderingIntent\n    rendering_intent...\n\n// Image:\nMagick.Image.Image:ANY(void)\n\n// _PixelPacket:\ntypedef struct _PixelPacket\n{\n#if defined(MAGICKCORE_WORDS_BIGENDIAN)\n#define MAGICK_PIXEL_RGBA  1\n  Quantum\n    red,\n    green,\n    blue,\n    opacity;\n#else\n#define MAGICK_PIXEL_BGRA  1\n  Quantum\n    blue,\n    green,\n    red,\n    opacity;\n#endif\n}\n\n// ExceptionInfo:\ntypedef struct _ExceptionInfo ExceptionInfo;\n\n// QuantumInfo:\ntypedef struct _QuantumInfo\n  QuantumInfo;\n\n// MagickOffsetType:\ntypedef long long MagickOffsetType;\n\n// PixelPacket:\ntypedef struct _PixelPacket\n{\n#if defined(MAGICKCORE_WORDS_BIGENDIAN)\n#define MAGICK_PIXEL_RGBA  1\n  Quantum\n    red,\n    green,\n    blue,\n    opacity;\n#else\n#define MAGICK_PIXEL_BGRA  1\n  Quantum\n    blue,\n    green,\n    red,\n    opacity;\n#endif\n} PixelPacket;\n\n// QuantumType:\ntypedef enum\n{\n  UndefinedQuantum,\n  AlphaQuantum,\n  BlackQuantum,\n  BlueQuantum,\n  CMYKAQuantum,\n  CMYKQuantum,\n  CyanQuantum,\n  GrayAlphaQuantum,\n  GrayQuantum,\n  GreenQuantum,\n  IndexAlphaQuantum,\n  IndexQuantum,\n  MagentaQuantum,\n  OpacityQuantum,\n  RedQuantum,\n  RGBAQuantum,\n  BGRAQuantum,\n  RGBOQuantum,\n  RGBQuantum,\n  YellowQuantum,\n  GrayPadQuantum,  /* deprecated */\n  RGBPadQuantum,\n  CbYCrYQuantum,\n  CbYCrQuantum,\n  CbYCrAQuantum,\n  CMYKOQuantum,\n  BGRQuantum,\n  BGROQuantum\n}\n\n// CINInfo:\ntypedef struct CINInfo\n{\n  CINFileInfo\n    file;\n\n  CINImageInfo\n    image;\n\n  CINDataFormatInfo\n    data_format;\n\n  CINOriginationInfo\n    origination;\n\n  CINFilmInfo\n    film;\n\n  CINUserInfo\n    user;\n}\n\n// CINInfo:\ntypedef struct CINInfo\n{\n  CINFileInfo\n    file;\n\n  CINImageInfo\n    image;\n\n  CINDataFormatInfo\n    data_format;\n\n  CINOriginationInfo\n    origination;\n\n  CINFilmInfo\n    film;\n\n  CINUserInfo\n    user;\n} CINInfo;\n\n// _QuantumInfo:\nstruct _QuantumInfo\n{\n  size_t\n    depth,\n    quantum;\n\n  QuantumFormatType\n    format;\n\n  double\n    minimum,\n    maximum,\n    scale;\n\n  size_t\n    pad;\n\n  MagickBooleanType\n    min_is_white,\n    pack;\n\n  QuantumAlphaType\n    alpha_type;\n\n  size_t\n    number_threads;\n\n  MemoryInfo\n    **pixels;\n\n  size_t\n    extent;\n\n  EndianType\n    endian;\n\n  QuantumState\n    state;\n\n  SemaphoreInfo\n    *semaphore;\n\n  size_t\n    signature;\n}\n\n// Called Methods (top 10):\n// CloseBlob from magick/blob.c:\nMagickBooleanType CloseBlob(Image *image)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  int\n    status;\n\n  /*\n    Close image file.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  blob_info=image->blob;\n  if ((blob_info == (BlobInfo *) NULL) || (blob_info->type == UndefinedStream))\n    return(MagickTrue);\n  status=SyncBlob(image);\n  switch (blob_info->type)\n  {\n    case UndefinedStream:\n    case StandardStream:\n      break;\n    case FileStream:\n    case PipeStream:\n    {\n      if (blob_info->synchronize != MagickFalse)\n        {\n          status=fflush(blob_info->file_info.file);\n          if (status != 0)\n            ThrowBlobException(blob_info);\n          status=fsync(fileno(blob_info->file_info.file));\n          if (status != 0)\n            ThrowBlobException(blob_info);\n        }\n      if ((status != 0) && (ferror(blob_i...\n\n// ReadBlob from magick/blob.c:\nssize_t ReadBlob(Image *image,const size_t length,\n  unsigned char *data)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  int\n    c;\n\n  unsigned char\n    *q;\n\n  ssize_t\n    count;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->blob != (BlobInfo *) NULL);\n  assert(image->blob->type != UndefinedStream);\n  if (length == 0)\n    return(0);\n  assert(data != (void *) NULL);\n  blob_info=image->blob;\n  count=0;\n  q=data;\n  switch (blob_info->type)\n  {\n    case UndefinedStream:\n      break;\n    case StandardStream:\n    case FileStream:\n    case PipeStream:\n    {\n      switch (length)\n      {\n        default:\n        {\n          count=(ssize_t) fread(q,1,length,blob_info->file_info.file);\n          break;\n        }\n        case 4:\n        {\n          c=getc(blob_info->file_info.file);\n          if (c == EOF)\n            break;\n          *q++=(unsigned char) c;\n          count++;\n        }\n        case 3:\n        {\n          c=getc(blob_in...\n\n// GetQuantumExtent from magick/quantum.c:\nsize_t GetQuantumExtent(const Image *image,\n  const QuantumInfo *quantum_info,const QuantumType quantum_type)\n{\n  size_t\n    packet_size;\n\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  packet_size=1;\n  switch (quantum_type)\n  {\n    case GrayAlphaQuantum: packet_size=2; break;\n    case IndexAlphaQuantum: packet_size=2; break;\n    case RGBQuantum: packet_size=3; break;\n    case BGRQuantum: packet_size=3; break;\n    case RGBAQuantum: packet_size=4; break;\n    case RGBOQuantum: packet_size=4; break;\n    case BGRAQuantum: packet_size=4; break;\n    case CMYKQuantum: packet_size=4; break;\n    case CMYKAQuantum: packet_size=5; break;\n    case CbYCrAQuantum: packet_size=4; break;\n    case CbYCrQuantum: packet_size=3; break;\n    case CbYCrYQuantum: packet_size=4; break;\n    default: break;\n  }\n  if (quantum_info->pack == MagickFalse)\n    return((size_t) (packet_size*image->columns*((quantum_info->depth+7)/8)));\n  return((size_t) ((...\n\n// InheritException from magick/exception.c:\nvoid InheritException(ExceptionInfo *exception,\n  const ExceptionInfo *relative)\n{\n  const ExceptionInfo\n    *p;\n\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  assert(relative != (ExceptionInfo *) NULL);\n  assert(relative->signature == MagickCoreSignature);\n  assert(exception != relative);\n  if (relative->exceptions == (void *) NULL)\n    return;\n  LockSemaphoreInfo(relative->semaphore);\n  ResetLinkedListIterator((LinkedListInfo *) relative->exceptions);\n  p=(const ExceptionInfo *) GetNextValueInLinkedList((LinkedListInfo *)\n    relative->exceptions);\n  while (p != (const ExceptionInfo *) NULL)\n  {\n    (void) ThrowException(exception,p->severity,p->reason,p->description);\n    p=(const ExceptionInfo *) GetNextValueInLinkedList((LinkedListInfo *)\n      relative->exceptions);\n  }\n  UnlockSemaphoreInfo(relative->semaphore);\n}\n\n// ReadBlobSignedLong from magick/blob.c:\nsigned int ReadBlobSignedLong(Image *image)\n{\n  union\n  {\n    unsigned int\n      unsigned_value;\n\n    signed int\n      signed_value;\n  } quantum;\n\n  quantum.unsigned_value=ReadBlobLong(image);\n  return(quantum.signed_value);\n}\n\n// ReadBlobStream from magick/blob.c:\nconst void *ReadBlobStream(Image *image,\n  const size_t length,void *magick_restrict data,ssize_t *count)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->blob != (BlobInfo *) NULL);\n  assert(image->blob->type != UndefinedStream);\n  assert(count != (ssize_t *) NULL);\n  blob_info=image->blob;\n  if (blob_info->type != BlobStream)\n    {\n      assert(data != NULL);\n      *count=ReadBlob(image,length,(unsigned char *) data);\n      return(data);\n    }\n  if (blob_info->offset >= (MagickOffsetType) blob_info->length)\n    {\n      *count=0;\n      blob_info->eof=MagickTrue;\n      return(data);\n    }\n  data=blob_info->data+blob_info->offset;\n  *count=(ssize_t) MagickMin((MagickOffsetType) length,(MagickOffsetType)\n    blob_info->length-blob_info->offset);\n  blob_info->offset+=(*count);\n  if (*count != (ssize_t) length)\n    blob_info->eof=MagickTrue;\n  return(data);\n}\n\n// MagickCoreSignature from coders/magick/magick/method-attribute.h:\n<empty>\n\n// ReadBlobByte from magick/blob.c:\nint ReadBlobByte(Image *image)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  const unsigned char\n    *p;\n\n  unsigned char\n    buffer[1];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->blob != (BlobInfo *) NULL);\n  assert(image->blob->type != UndefinedStream);\n  blob_info=image->blob;\n  switch (blob_info->type)\n  {\n    case StandardStream:\n    case FileStream:\n    case PipeStream:\n    {\n      int\n        c;\n\n      p=(const unsigned char *) buffer;\n      c=getc(blob_info->file_info.file);\n      if (c == EOF)\n        return(EOF);\n      *buffer=(unsigned char) c;\n      break;\n    }\n    default:\n    {\n      ssize_t\n        count;\n\n      p=(const unsigned char *) ReadBlobStream(image,1,buffer,&count);\n      if (count != 1)\n        return(EOF);\n      break;\n    }\n  }\n  return((int) (*p));\n}\n\n// SetQuantumQuantum from magick/quantum.c:\nvoid SetQuantumQuantum(QuantumInfo *quantum_info,\n  const size_t quantum)\n{\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  quantum_info->quantum=quantum;\n}\n\n// FormatImageProperty from magick/property.c:\nMagickBooleanType FormatImageProperty(Image *image,\n  const char *property,const char *format,...)\n{\n  char\n    value[MaxTextExtent];\n\n  ssize_t\n    n;\n\n  va_list\n    operands;\n\n  va_start(operands,format);\n  n=FormatLocaleStringList(value,MaxTextExtent,format,operands);\n  (void) n;\n  va_end(operands);\n  return(SetImageProperty(image,property,value));\n}\n"
  },
  {
    "repository": "vim",
    "cve_id": "CVE-2022-0361",
    "cwe_list": [
      "CWE-787"
    ],
    "commit_hash": "dc5490e2cbc8c16022a23b449b48c1bd0083f366",
    "short_hash": "dc5490e2",
    "vulnerableMethods_before": [
      {
        "filename": "ex_cmds.c",
        "method_name": "vulnerable_function",
        "raw_code": "ex_copy(linenr_T line1, linenr_T line2, linenr_T n)\n{\n    linenr_T\tcount;\n    char_u\t*p;\n\n    count = line2 - line1 + 1;\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\tcurbuf->b_op_start.lnum = n + 1;\n\tcurbuf->b_op_end.lnum = n + count;\n\tcurbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n    }\n\n    /*\n     * there are three situations:\n     * 1. destination is above line1\n     * 2. destination is between line1 and line2\n     * 3. destination is below line2\n     *\n     * n = destination (when starting)\n     * curwin->w_cursor.lnum = destination (while copying)\n     * line1 = start of source (while copying)\n     * line2 = end of source (while copying)\n     */\n    if (u_save(n, n + 1) == FAIL)\n\treturn;\n\n    curwin->w_cursor.lnum = n;\n    while (line1 <= line2)\n    {\n\t// need to use vim_strsave() because the line will be unlocked within\n\t// ml_append()\n\tp = vim_strsave(ml_get(line1));\n\tif (p != NULL)\n\t{\n\t    ml_append(curwin->w_cursor.lnum, p, (colnr_T)0, FALSE);\n\t    vim_free(p);\n\t}\n\t// situation 2: skip already copied lines\n\tif (line1 == n)\n\t    line1 = curwin->w_cursor.lnum;\n\t++line1;\n\tif (curwin->w_cursor.lnum < line1)\n\t    ++line1;\n\tif (curwin->w_cursor.lnum < line2)\n\t    ++line2;\n\t++curwin->w_cursor.lnum;\n    }\n\n    appended_lines_mark(n, count);\n\n    msgmore((long)count);\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ex_cmds.c",
        "method_name": "fixed_function",
        "raw_code": "ex_copy(linenr_T line1, linenr_T line2, linenr_T n)\n{\n    linenr_T\tcount;\n    char_u\t*p;\n\n    count = line2 - line1 + 1;\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\tcurbuf->b_op_start.lnum = n + 1;\n\tcurbuf->b_op_end.lnum = n + count;\n\tcurbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n    }\n\n    /*\n     * there are three situations:\n     * 1. destination is above line1\n     * 2. destination is between line1 and line2\n     * 3. destination is below line2\n     *\n     * n = destination (when starting)\n     * curwin->w_cursor.lnum = destination (while copying)\n     * line1 = start of source (while copying)\n     * line2 = end of source (while copying)\n     */\n    if (u_save(n, n + 1) == FAIL)\n\treturn;\n\n    curwin->w_cursor.lnum = n;\n    while (line1 <= line2)\n    {\n\t// need to use vim_strsave() because the line will be unlocked within\n\t// ml_append()\n\tp = vim_strsave(ml_get(line1));\n\tif (p != NULL)\n\t{\n\t    ml_append(curwin->w_cursor.lnum, p, (colnr_T)0, FALSE);\n\t    vim_free(p);\n\t}\n\t// situation 2: skip already copied lines\n\tif (line1 == n)\n\t    line1 = curwin->w_cursor.lnum;\n\t++line1;\n\tif (curwin->w_cursor.lnum < line1)\n\t    ++line1;\n\tif (curwin->w_cursor.lnum < line2)\n\t    ++line2;\n\t++curwin->w_cursor.lnum;\n    }\n\n    appended_lines_mark(n, count);\n    if (VIsual_active)\n\tcheck_pos(curbuf, &VIsual);\n\n    msgmore((long)count);\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"version.h\"\n# include <float.h>\n#include \"vim.h\"\n\n// Type Definitions:\n// linenr_T:\ntypedef long\tlinenr_T;\n\n// Called Methods (top 10):\n// check_pos from src/misc2.c:\nvoid\ncheck_pos(buf_T *buf, pos_T *pos)\n{\n    char_u *line;\n    colnr_T len;\n\n    if (pos->lnum > buf->b_ml.ml_line_count)\n\tpos->lnum = buf->b_ml.ml_line_count;\n\n    if (pos->col > 0)\n    {\n\tline = ml_get_buf(buf, pos->lnum, FALSE);\n\tlen = (colnr_T)STRLEN(line);\n\tif (pos->col > len)\n\t    pos->col = len;\n    }\n}\n\n// CMOD_LOCKMARKS from src/structs.h:\n<empty>\n\n// u_save from src/undo.c:\nint\nu_save(linenr_T top, linenr_T bot)\n{\n    if (undo_off)\n\treturn OK;\n\n    if (top >= bot || bot > curbuf->b_ml.ml_line_count + 1)\n\treturn FAIL;\t// rely on caller to give an error message\n\n    if (top + 2 == bot)\n\tu_saveline((linenr_T)(top + 1));\n\n    return (u_savecommon(top, bot, (linenr_T)0, FALSE));\n}\n\n// FAIL from src/vim.h:\n<empty>\n"
  },
  {
    "repository": "vim",
    "cve_id": "CVE-2022-3134",
    "cwe_list": [
      "CWE-416"
    ],
    "commit_hash": "ccfde4d028e891a41e3548323c3d47b06fb0b83e",
    "short_hash": "ccfde4d0",
    "vulnerableMethods_before": [
      {
        "filename": "tag.c",
        "method_name": "vulnerable_function",
        "raw_code": "do_tag(\n    char_u\t*tag,\t\t// tag (pattern) to jump to\n    int\t\ttype,\n    int\t\tcount,\n    int\t\tforceit,\t// :ta with !\n    int\t\tverbose)\t// print \"tag not found\" message\n{\n    taggy_T\t*tagstack = curwin->w_tagstack;\n    int\t\ttagstackidx = curwin->w_tagstackidx;\n    int\t\ttagstacklen = curwin->w_tagstacklen;\n    int\t\tcur_match = 0;\n    int\t\tcur_fnum = curbuf->b_fnum;\n    int\t\toldtagstackidx = tagstackidx;\n    int\t\tprevtagstackidx = tagstackidx;\n    int\t\tprev_num_matches;\n    int\t\tnew_tag = FALSE;\n    int\t\ti;\n    int\t\tic;\n    int\t\tno_regexp = FALSE;\n    int\t\terror_cur_match = 0;\n    int\t\tsave_pos = FALSE;\n    fmark_T\tsaved_fmark;\n#ifdef FEAT_CSCOPE\n    int\t\tjumped_to_tag = FALSE;\n#endif\n    int\t\tnew_num_matches;\n    char_u\t**new_matches;\n    int\t\tuse_tagstack;\n    int\t\tskip_msg = FALSE;\n    char_u\t*buf_ffname = curbuf->b_ffname;\t    // name to use for\n\t\t\t\t\t\t    // priority computation\n    int\t\tuse_tfu = 1;\n    char_u\t*tofree = NULL;\n\n    // remember the matches for the last used tag\n    static int\t\tnum_matches = 0;\n    static int\t\tmax_num_matches = 0;  // limit used for match search\n    static char_u\t**matches = NULL;\n    static int\t\tflags;\n\n#ifdef FEAT_EVAL\n    if (tfu_in_use)\n    {\n\temsg(_(e_cannot_modify_tag_stack_within_tagfunc));\n\treturn FALSE;\n    }\n#endif\n\n#ifdef EXITFREE\n    if (type == DT_FREE)\n    {\n\t// remove the list of matches\n\tFreeWild(num_matches, matches);\n# ifdef FEAT_CSCOPE\n\tcs_free_tags();\n# endif\n\tnum_matches = 0;\n\treturn FALSE;\n    }\n#endif\n\n    if (type == DT_HELP)\n    {\n\ttype = DT_TAG;\n\tno_regexp = TRUE;\n\tuse_tfu = 0;\n    }\n\n    prev_num_matches = num_matches;\n    free_string_option(nofile_fname);\n    nofile_fname = NULL;\n\n    CLEAR_POS(&saved_fmark.mark);\t// shutup gcc 4.0\n    saved_fmark.fnum = 0;\n\n    /*\n     * Don't add a tag to the tagstack if 'tagstack' has been reset.\n     */\n    if ((!p_tgst && *tag != NUL))\n    {\n\tuse_tagstack = FALSE;\n\tnew_tag = TRUE;\n#if defined(FEAT_QUICKFIX)\n\tif (g_do_tagpreview != 0)\n\t{\n\t    tagstack_clear_entry(&ptag_entry);\n\t    if ((ptag_entry.tagname = vim_strsave(tag)) == NULL)\n\t\tgoto end_do_tag;\n\t}\n#endif\n    }\n    else\n    {\n#if defined(FEAT_QUICKFIX)\n\tif (g_do_tagpreview != 0)\n\t    use_tagstack = FALSE;\n\telse\n#endif\n\t    use_tagstack = TRUE;\n\n\t// new pattern, add to the tag stack\n\tif (*tag != NUL\n\t\t&& (type == DT_TAG || type == DT_SELECT || type == DT_JUMP\n#ifdef FEAT_QUICKFIX\n\t\t    || type == DT_LTAG\n#endif\n#ifdef FEAT_CSCOPE\n\t\t    || type == DT_CSCOPE\n#endif\n\t\t    ))\n\t{\n#if defined(FEAT_QUICKFIX)\n\t    if (g_do_tagpreview != 0)\n\t    {\n\t\tif (ptag_entry.tagname != NULL\n\t\t\t&& STRCMP(ptag_entry.tagname, tag) == 0)\n\t\t{\n\t\t    // Jumping to same tag: keep the current match, so that\n\t\t    // the CursorHold autocommand example works.\n\t\t    cur_match = ptag_entry.cur_match;\n\t\t    cur_fnum = ptag_entry.cur_fnum;\n\t\t}\n\t\telse\n\t\t{\n\t\t    tagstack_clear_entry(&ptag_entry);\n\t\t    if ((ptag_entry.tagname = vim_strsave(tag)) == NULL)\n\t\t\tgoto end_do_tag;\n\t\t}\n\t    }\n\t    else\n#endif\n\t    {\n\t\t/*\n\t\t * If the last used entry is not at the top, delete all tag\n\t\t * stack entries above it.\n\t\t */\n\t\twhile (tagstackidx < tagstacklen)\n\t\t    tagstack_clear_entry(&tagstack[--tagstacklen]);\n\n\t\t// if the tagstack is full: remove oldest entry\n\t\tif (++tagstacklen > TAGSTACKSIZE)\n\t\t{\n\t\t    tagstacklen = TAGSTACKSIZE;\n\t\t    tagstack_clear_entry(&tagstack[0]);\n\t\t    for (i = 1; i < tagstacklen; ++i)\n\t\t\ttagstack[i - 1] = tagstack[i];\n\t\t    --tagstackidx;\n\t\t}\n\n\t\t/*\n\t\t * put the tag name in the tag stack\n\t\t */\n\t\tif ((tagstack[tagstackidx].tagname = vim_strsave(tag)) == NULL)\n\t\t{\n\t\t    curwin->w_tagstacklen = tagstacklen - 1;\n\t\t    goto end_do_tag;\n\t\t}\n\t\tcurwin->w_tagstacklen = tagstacklen;\n\n\t\tsave_pos = TRUE;\t// save the cursor position below\n\t    }\n\n\t    new_tag = TRUE;\n\t}\n\telse\n\t{\n\t    if (\n#if defined(FEAT_QUICKFIX)\n\t\t    g_do_tagpreview != 0 ? ptag_entry.tagname == NULL :\n#endif\n\t\t    tagstacklen == 0)\n\t    {\n\t\t// empty stack\n\t\temsg(_(e_tag_stack_empty));\n\t\tgoto end_do_tag;\n\t    }\n\n\t    if (type == DT_POP)\t\t// go to older position\n\t    {\n#ifdef FEAT_FOLDING\n\t\tint\told_KeyTyped = KeyTyped;\n#endif\n\t\tif ((tagstackidx -= count) < 0)\n\t\t{\n\t\t    emsg(_(e_at_bottom_of_tag_stack));\n\t\t    if (tagstackidx + count == 0)\n\t\t    {\n\t\t\t// We did [num]^T from the bottom of the stack\n\t\t\ttagstackidx = 0;\n\t\t\tgoto end_do_tag;\n\t\t    }\n\t\t    // We weren't at the bottom of the stack, so jump all the\n\t\t    // way to the bottom now.\n\t\t    tagstackidx = 0;\n\t\t}\n\t\telse if (tagstackidx >= tagstacklen)    // count == 0?\n\t\t{\n\t\t    emsg(_(e_at_top_of_tag_stack));\n\t\t    goto end_do_tag;\n\t\t}\n\n\t\t// Make a copy of the fmark, autocommands may invalidate the\n\t\t// tagstack before it's used.\n\t\tsaved_fmark = tagstack[tagstackidx].fmark;\n\t\tif (saved_fmark.fnum != curbuf->b_fnum)\n\t\t{\n\t\t    /*\n\t\t     * Jump to other file. If this fails (e.g. because the\n\t\t     * file was changed) keep original position in tag stack.\n\t\t     */\n\t\t    if (buflist_getfile(saved_fmark.fnum, saved_fmark.mark.lnum,\n\t\t\t\t\t       GETF_SETMARK, forceit) == FAIL)\n\t\t    {\n\t\t\ttagstackidx = oldtagstackidx;  // back to old posn\n\t\t\tgoto end_do_tag;\n\t\t    }\n\t\t    // An BufReadPost autocommand may jump to the '\" mark, but\n\t\t    // we don't what that here.\n\t\t    curwin->w_cursor.lnum = saved_fmark.mark.lnum;\n\t\t}\n\t\telse\n\t\t{\n\t\t    setpcmark();\n\t\t    curwin->w_cursor.lnum = saved_fmark.mark.lnum;\n\t\t}\n\t\tcurwin->w_cursor.col = saved_fmark.mark.col;\n\t\tcurwin->w_set_curswant = TRUE;\n\t\tcheck_cursor();\n#ifdef FEAT_FOLDING\n\t\tif ((fdo_flags & FDO_TAG) && old_KeyTyped)\n\t\t    foldOpenCursor();\n#endif\n\n\t\t// remove the old list of matches\n\t\tFreeWild(num_matches, matches);\n#ifdef FEAT_CSCOPE\n\t\tcs_free_tags();\n#endif\n\t\tnum_matches = 0;\n\t\ttag_freematch();\n\t\tgoto end_do_tag;\n\t    }\n\n\t    if (type == DT_TAG\n#if defined(FEAT_QUICKFIX)\n\t\t    || type == DT_LTAG\n#endif\n\t       )\n\t    {\n#if defined(FEAT_QUICKFIX)\n\t\tif (g_do_tagpreview != 0)\n\t\t{\n\t\t    cur_match = ptag_entry.cur_match;\n\t\t    cur_fnum = ptag_entry.cur_fnum;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    // \":tag\" (no argument): go to newer pattern\n\t\t    save_pos = TRUE;\t// save the cursor position below\n\t\t    if ((tagstackidx += count - 1) >= tagstacklen)\n\t\t    {\n\t\t\t/*\n\t\t\t * Beyond the last one, just give an error message and\n\t\t\t * go to the last one.  Don't store the cursor\n\t\t\t * position.\n\t\t\t */\n\t\t\ttagstackidx = tagstacklen - 1;\n\t\t\temsg(_(e_at_top_of_tag_stack));\n\t\t\tsave_pos = FALSE;\n\t\t    }\n\t\t    else if (tagstackidx < 0)\t// must have been count == 0\n\t\t    {\n\t\t\temsg(_(e_at_bottom_of_tag_stack));\n\t\t\ttagstackidx = 0;\n\t\t\tgoto end_do_tag;\n\t\t    }\n\t\t    cur_match = tagstack[tagstackidx].cur_match;\n\t\t    cur_fnum = tagstack[tagstackidx].cur_fnum;\n\t\t}\n\t\tnew_tag = TRUE;\n\t    }\n\t    else\t\t\t\t// go to other matching tag\n\t    {\n\t\t// Save index for when selection is cancelled.\n\t\tprevtagstackidx = tagstackidx;\n\n#if defined(FEAT_QUICKFIX)\n\t\tif (g_do_tagpreview != 0)\n\t\t{\n\t\t    cur_match = ptag_entry.cur_match;\n\t\t    cur_fnum = ptag_entry.cur_fnum;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    if (--tagstackidx < 0)\n\t\t\ttagstackidx = 0;\n\t\t    cur_match = tagstack[tagstackidx].cur_match;\n\t\t    cur_fnum = tagstack[tagstackidx].cur_fnum;\n\t\t}\n\t\tswitch (type)\n\t\t{\n\t\t    case DT_FIRST: cur_match = count - 1; break;\n\t\t    case DT_SELECT:\n\t\t    case DT_JUMP:\n#ifdef FEAT_CSCOPE\n\t\t    case DT_CSCOPE:\n#endif\n\t\t    case DT_LAST:  cur_match = MAXCOL - 1; break;\n\t\t    case DT_NEXT:  cur_match += count; break;\n\t\t    case DT_PREV:  cur_match -= count; break;\n\t\t}\n\t\tif (cur_match >= MAXCOL)\n\t\t    cur_match = MAXCOL - 1;\n\t\telse if (cur_match < 0)\n\t\t{\n\t\t    emsg(_(e_cannot_go_before_first_matching_tag));\n\t\t    skip_msg = TRUE;\n\t\t    cur_match = 0;\n\t\t    cur_fnum = curbuf->b_fnum;\n\t\t}\n\t    }\n\t}\n\n#if defined(FEAT_QUICKFIX)\n\tif (g_do_tagpreview != 0)\n\t{\n\t    if (type != DT_SELECT && type != DT_JUMP)\n\t    {\n\t\tptag_entry.cur_match = cur_match;\n\t\tptag_entry.cur_fnum = cur_fnum;\n\t    }\n\t}\n\telse\n#endif\n\t{\n\t    /*\n\t     * For \":tag [arg]\" or \":tselect\" remember position before the jump.\n\t     */\n\t    saved_fmark = tagstack[tagstackidx].fmark;\n\t    if (save_pos)\n\t    {\n\t\ttagstack[tagstackidx].fmark.mark = curwin->w_cursor;\n\t\ttagstack[tagstackidx].fmark.fnum = curbuf->b_fnum;\n\t    }\n\n\t    // Curwin will change in the call to jumpto_tag() if \":stag\" was\n\t    // used or an autocommand jumps to another window; store value of\n\t    // tagstackidx now.\n\t    curwin->w_tagstackidx = tagstackidx;\n\t    if (type != DT_SELECT && type != DT_JUMP)\n\t    {\n\t\tcurwin->w_tagstack[tagstackidx].cur_match = cur_match;\n\t\tcurwin->w_tagstack[tagstackidx].cur_fnum = cur_fnum;\n\t    }\n\t}\n    }\n\n    // When not using the current buffer get the name of buffer \"cur_fnum\".\n    // Makes sure that the tag order doesn't change when using a remembered\n    // position for \"cur_match\".\n    if (cur_fnum != curbuf->b_fnum)\n    {\n\tbuf_T *buf = buflist_findnr(cur_fnum);\n\n\tif (buf != NULL)\n\t    buf_ffname = buf->b_ffname;\n    }\n\n    /*\n     * Repeat searching for tags, when a file has not been found.\n     */\n    for (;;)\n    {\n\tint\tother_name;\n\tchar_u\t*name;\n\n\t/*\n\t * When desired match not found yet, try to find it (and others).\n\t */\n\tif (use_tagstack)\n\t{\n\t    // make a copy, the tagstack may change in 'tagfunc'\n\t    name = vim_strsave(tagstack[tagstackidx].tagname);\n\t    vim_free(tofree);\n\t    tofree = name;\n\t}\n#if defined(FEAT_QUICKFIX)\n\telse if (g_do_tagpreview != 0)\n\t    name = ptag_entry.tagname;\n#endif\n\telse\n\t    name = tag;\n\tother_name = (tagmatchname == NULL || STRCMP(tagmatchname, name) != 0);\n\tif (new_tag\n\t\t|| (cur_match >= num_matches && max_num_matches != MAXCOL)\n\t\t|| other_name)\n\t{\n\t    if (other_name)\n\t    {\n\t\tvim_free(tagmatchname);\n\t\ttagmatchname = vim_strsave(name);\n\t    }\n\n\t    if (type == DT_SELECT || type == DT_JUMP\n#if defined(FEAT_QUICKFIX)\n\t\t|| type == DT_LTAG\n#endif\n\t\t)\n\t\tcur_match = MAXCOL - 1;\n\t    if (type == DT_TAG)\n\t\tmax_num_matches = MAXCOL;\n\t    else\n\t\tmax_num_matches = cur_match + 1;\n\n\t    // when the argument starts with '/', use it as a regexp\n\t    if (!no_regexp && *name == '/')\n\t    {\n\t\tflags = TAG_REGEXP;\n\t\t++name;\n\t    }\n\t    else\n\t\tflags = TAG_NOIC;\n\n#ifdef FEAT_CSCOPE\n\t    if (type == DT_CSCOPE)\n\t\tflags = TAG_CSCOPE;\n#endif\n\t    if (verbose)\n\t\tflags |= TAG_VERBOSE;\n\n\t    if (!use_tfu)\n\t\tflags |= TAG_NO_TAGFUNC;\n\n\t    if (find_tags(name, &new_num_matches, &new_matches, flags,\n\t\t\t\t\t    max_num_matches, buf_ffname) == OK\n\t\t    && new_num_matches < max_num_matches)\n\t\tmax_num_matches = MAXCOL; // If less than max_num_matches\n\t\t\t\t\t  // found: all matches found.\n\n\t    // If there already were some matches for the same name, move them\n\t    // to the start.  Avoids that the order changes when using\n\t    // \":tnext\" and jumping to another file.\n\t    if (!new_tag && !other_name)\n\t    {\n\t\tint\t    j, k;\n\t\tint\t    idx = 0;\n\t\ttagptrs_T   tagp, tagp2;\n\n\t\t// Find the position of each old match in the new list.  Need\n\t\t// to use parse_match() to find the tag line.\n\t\tfor (j = 0; j < num_matches; ++j)\n\t\t{\n\t\t    parse_match(matches[j], &tagp);\n\t\t    for (i = idx; i < new_num_matches; ++i)\n\t\t    {\n\t\t\tparse_match(new_matches[i], &tagp2);\n\t\t\tif (STRCMP(tagp.tagname, tagp2.tagname) == 0)\n\t\t\t{\n\t\t\t    char_u *p = new_matches[i];\n\t\t\t    for (k = i; k > idx; --k)\n\t\t\t\tnew_matches[k] = new_matches[k - 1];\n\t\t\t    new_matches[idx++] = p;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    FreeWild(num_matches, matches);\n\t    num_matches = new_num_matches;\n\t    matches = new_matches;\n\t}\n\n\tif (num_matches <= 0)\n\t{\n\t    if (verbose)\n\t\tsemsg(_(e_tag_not_found_str), name);\n#if defined(FEAT_QUICKFIX)\n\t    g_do_tagpreview = 0;\n#endif\n\t}\n\telse\n\t{\n\t    int ask_for_selection = FALSE;\n\n#ifdef FEAT_CSCOPE\n\t    if (type == DT_CSCOPE && num_matches > 1)\n\t    {\n\t\tcs_print_tags();\n\t\task_for_selection = TRUE;\n\t    }\n\t    else\n#endif\n\t    if (type == DT_TAG && *tag != NUL)\n\t\t// If a count is supplied to the \":tag <name>\" command, then\n\t\t// jump to count'th matching tag.\n\t\tcur_match = count > 0 ? count - 1 : 0;\n\t    else if (type == DT_SELECT || (type == DT_JUMP && num_matches > 1))\n\t    {\n\t\tprint_tag_list(new_tag, use_tagstack, num_matches, matches);\n\t\task_for_selection = TRUE;\n\t    }\n#if defined(FEAT_QUICKFIX) && defined(FEAT_EVAL)\n\t    else if (type == DT_LTAG)\n\t    {\n\t\tif (add_llist_tags(tag, num_matches, matches) == FAIL)\n\t\t    goto end_do_tag;\n\t\tcur_match = 0;\t\t// Jump to the first tag\n\t    }\n#endif\n\n\t    if (ask_for_selection == TRUE)\n\t    {\n\t\t/*\n\t\t * Ask to select a tag from the list.\n\t\t */\n\t\ti = prompt_for_number(NULL);\n\t\tif (i <= 0 || i > num_matches || got_int)\n\t\t{\n\t\t    // no valid choice: don't change anything\n\t\t    if (use_tagstack)\n\t\t    {\n\t\t\ttagstack[tagstackidx].fmark = saved_fmark;\n\t\t\ttagstackidx = prevtagstackidx;\n\t\t    }\n#ifdef FEAT_CSCOPE\n\t\t    cs_free_tags();\n\t\t    jumped_to_tag = TRUE;\n#endif\n\t\t    break;\n\t\t}\n\t\tcur_match = i - 1;\n\t    }\n\n\t    if (cur_match >= num_matches)\n\t    {\n\t\t// Avoid giving this error when a file wasn't found and we're\n\t\t// looking for a match in another file, which wasn't found.\n\t\t// There will be an emsg(\"file doesn't exist\") below then.\n\t\tif ((type == DT_NEXT || type == DT_FIRST)\n\t\t\t\t\t\t      && nofile_fname == NULL)\n\t\t{\n\t\t    if (num_matches == 1)\n\t\t\temsg(_(e_there_is_only_one_matching_tag));\n\t\t    else\n\t\t\temsg(_(e_cannot_go_beyond_last_matching_tag));\n\t\t    skip_msg = TRUE;\n\t\t}\n\t\tcur_match = num_matches - 1;\n\t    }\n\t    if (use_tagstack)\n\t    {\n\t\ttagptrs_T   tagp;\n\n\t\ttagstack[tagstackidx].cur_match = cur_match;\n\t\ttagstack[tagstackidx].cur_fnum = cur_fnum;\n\n\t\t// store user-provided data originating from tagfunc\n\t\tif (use_tfu && parse_match(matches[cur_match], &tagp) == OK\n\t\t\t&& tagp.user_data)\n\t\t{\n\t\t    VIM_CLEAR(tagstack[tagstackidx].user_data);\n\t\t    tagstack[tagstackidx].user_data = vim_strnsave(\n\t\t\t  tagp.user_data, tagp.user_data_end - tagp.user_data);\n\t\t}\n\n\t\t++tagstackidx;\n\t    }\n#if defined(FEAT_QUICKFIX)\n\t    else if (g_do_tagpreview != 0)\n\t    {\n\t\tptag_entry.cur_match = cur_match;\n\t\tptag_entry.cur_fnum = cur_fnum;\n\t    }\n#endif\n\n\t    /*\n\t     * Only when going to try the next match, report that the previous\n\t     * file didn't exist.  Otherwise an emsg() is given below.\n\t     */\n\t    if (nofile_fname != NULL && error_cur_match != cur_match)\n\t\tsmsg(_(\"File \\\"%s\\\" does not exist\"), nofile_fname);\n\n\n\t    ic = (matches[cur_match][0] & MT_IC_OFF);\n\t    if (type != DT_TAG && type != DT_SELECT && type != DT_JUMP\n#ifdef FEAT_CSCOPE\n\t\t&& type != DT_CSCOPE\n#endif\n\t\t&& (num_matches > 1 || ic)\n\t\t&& !skip_msg)\n\t    {\n\t\t// Give an indication of the number of matching tags\n\t\tsprintf((char *)IObuff, _(\"tag %d of %d%s\"),\n\t\t\t\tcur_match + 1,\n\t\t\t\tnum_matches,\n\t\t\t\tmax_num_matches != MAXCOL ? _(\" or more\") : \"\");\n\t\tif (ic)\n\t\t    STRCAT(IObuff, _(\"  Using tag with different case!\"));\n\t\tif ((num_matches > prev_num_matches || new_tag)\n\t\t\t\t\t\t\t   && num_matches > 1)\n\t\t{\n\t\t    if (ic)\n\t\t\tmsg_attr((char *)IObuff, HL_ATTR(HLF_W));\n\t\t    else\n\t\t\tmsg((char *)IObuff);\n\t\t    msg_scroll = TRUE;\t// don't overwrite this message\n\t\t}\n\t\telse\n\t\t    give_warning(IObuff, ic);\n\t\tif (ic && !msg_scrolled && msg_silent == 0)\n\t\t{\n\t\t    out_flush();\n\t\t    ui_delay(1007L, TRUE);\n\t\t}\n\t    }\n\n#if defined(FEAT_EVAL)\n\t    // Let the SwapExists event know what tag we are jumping to.\n\t    vim_snprintf((char *)IObuff, IOSIZE, \":ta %s\\r\", name);\n\t    set_vim_var_string(VV_SWAPCOMMAND, IObuff, -1);\n#endif\n\n\t    /*\n\t     * Jump to the desired match.\n\t     */\n\t    i = jumpto_tag(matches[cur_match], forceit, type != DT_CSCOPE);\n\n#if defined(FEAT_EVAL)\n\t    set_vim_var_string(VV_SWAPCOMMAND, NULL, -1);\n#endif\n\n\t    if (i == NOTAGFILE)\n\t    {\n\t\t// File not found: try again with another matching tag\n\t\tif ((type == DT_PREV && cur_match > 0)\n\t\t\t|| ((type == DT_TAG || type == DT_NEXT\n\t\t\t\t\t\t\t  || type == DT_FIRST)\n\t\t\t    && (max_num_matches != MAXCOL\n\t\t\t\t\t     || cur_match < num_matches - 1)))\n\t\t{\n\t\t    error_cur_match = cur_match;\n\t\t    if (use_tagstack)\n\t\t\t--tagstackidx;\n\t\t    if (type == DT_PREV)\n\t\t\t--cur_match;\n\t\t    else\n\t\t    {\n\t\t\ttype = DT_NEXT;\n\t\t\t++cur_match;\n\t\t    }\n\t\t    continue;\n\t\t}\n\t\tsemsg(_(e_file_str_does_not_exist), nofile_fname);\n\t    }\n\t    else\n\t    {\n\t\t// We may have jumped to another window, check that\n\t\t// tagstackidx is still valid.\n\t\tif (use_tagstack && tagstackidx > curwin->w_tagstacklen)\n\t\t    tagstackidx = curwin->w_tagstackidx;\n#ifdef FEAT_CSCOPE\n\t\tjumped_to_tag = TRUE;\n#endif\n\t    }\n\t}\n\tbreak;\n    }\n\nend_do_tag:\n    // Only store the new index when using the tagstack and it's valid.\n    if (use_tagstack && tagstackidx <= curwin->w_tagstacklen)\n\tcurwin->w_tagstackidx = tagstackidx;\n    postponed_split = 0;\t// don't split next time\n# ifdef FEAT_QUICKFIX\n    g_do_tagpreview = 0;\t// don't do tag preview next time\n# endif\n\n    vim_free(tofree);\n#ifdef FEAT_CSCOPE\n    return jumped_to_tag;\n#else\n    return FALSE;\n#endif\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "None",
        "method_name": "fixed_function",
        "raw_code": "do_tag(\n    char_u\t*tag,\t\t// tag (pattern) to jump to\n    int\t\ttype,\n    int\t\tcount,\n    int\t\tforceit,\t// :ta with !\n    int\t\tverbose)\t// print \"tag not found\" message\n{\n    taggy_T\t*tagstack = curwin->w_tagstack;\n    int\t\ttagstackidx = curwin->w_tagstackidx;\n    int\t\ttagstacklen = curwin->w_tagstacklen;\n    int\t\tcur_match = 0;\n    int\t\tcur_fnum = curbuf->b_fnum;\n    int\t\toldtagstackidx = tagstackidx;\n    int\t\tprevtagstackidx = tagstackidx;\n    int\t\tprev_num_matches;\n    int\t\tnew_tag = FALSE;\n    int\t\ti;\n    int\t\tic;\n    int\t\tno_regexp = FALSE;\n    int\t\terror_cur_match = 0;\n    int\t\tsave_pos = FALSE;\n    fmark_T\tsaved_fmark;\n#ifdef FEAT_CSCOPE\n    int\t\tjumped_to_tag = FALSE;\n#endif\n    int\t\tnew_num_matches;\n    char_u\t**new_matches;\n    int\t\tuse_tagstack;\n    int\t\tskip_msg = FALSE;\n    char_u\t*buf_ffname = curbuf->b_ffname;\t    // name to use for\n\t\t\t\t\t\t    // priority computation\n    int\t\tuse_tfu = 1;\n    char_u\t*tofree = NULL;\n\n    // remember the matches for the last used tag\n    static int\t\tnum_matches = 0;\n    static int\t\tmax_num_matches = 0;  // limit used for match search\n    static char_u\t**matches = NULL;\n    static int\t\tflags;\n\n#ifdef FEAT_EVAL\n    if (tfu_in_use)\n    {\n\temsg(_(e_cannot_modify_tag_stack_within_tagfunc));\n\treturn FALSE;\n    }\n#endif\n\n#ifdef EXITFREE\n    if (type == DT_FREE)\n    {\n\t// remove the list of matches\n\tFreeWild(num_matches, matches);\n# ifdef FEAT_CSCOPE\n\tcs_free_tags();\n# endif\n\tnum_matches = 0;\n\treturn FALSE;\n    }\n#endif\n\n    if (type == DT_HELP)\n    {\n\ttype = DT_TAG;\n\tno_regexp = TRUE;\n\tuse_tfu = 0;\n    }\n\n    prev_num_matches = num_matches;\n    free_string_option(nofile_fname);\n    nofile_fname = NULL;\n\n    CLEAR_POS(&saved_fmark.mark);\t// shutup gcc 4.0\n    saved_fmark.fnum = 0;\n\n    /*\n     * Don't add a tag to the tagstack if 'tagstack' has been reset.\n     */\n    if ((!p_tgst && *tag != NUL))\n    {\n\tuse_tagstack = FALSE;\n\tnew_tag = TRUE;\n#if defined(FEAT_QUICKFIX)\n\tif (g_do_tagpreview != 0)\n\t{\n\t    tagstack_clear_entry(&ptag_entry);\n\t    if ((ptag_entry.tagname = vim_strsave(tag)) == NULL)\n\t\tgoto end_do_tag;\n\t}\n#endif\n    }\n    else\n    {\n#if defined(FEAT_QUICKFIX)\n\tif (g_do_tagpreview != 0)\n\t    use_tagstack = FALSE;\n\telse\n#endif\n\t    use_tagstack = TRUE;\n\n\t// new pattern, add to the tag stack\n\tif (*tag != NUL\n\t\t&& (type == DT_TAG || type == DT_SELECT || type == DT_JUMP\n#ifdef FEAT_QUICKFIX\n\t\t    || type == DT_LTAG\n#endif\n#ifdef FEAT_CSCOPE\n\t\t    || type == DT_CSCOPE\n#endif\n\t\t    ))\n\t{\n#if defined(FEAT_QUICKFIX)\n\t    if (g_do_tagpreview != 0)\n\t    {\n\t\tif (ptag_entry.tagname != NULL\n\t\t\t&& STRCMP(ptag_entry.tagname, tag) == 0)\n\t\t{\n\t\t    // Jumping to same tag: keep the current match, so that\n\t\t    // the CursorHold autocommand example works.\n\t\t    cur_match = ptag_entry.cur_match;\n\t\t    cur_fnum = ptag_entry.cur_fnum;\n\t\t}\n\t\telse\n\t\t{\n\t\t    tagstack_clear_entry(&ptag_entry);\n\t\t    if ((ptag_entry.tagname = vim_strsave(tag)) == NULL)\n\t\t\tgoto end_do_tag;\n\t\t}\n\t    }\n\t    else\n#endif\n\t    {\n\t\t/*\n\t\t * If the last used entry is not at the top, delete all tag\n\t\t * stack entries above it.\n\t\t */\n\t\twhile (tagstackidx < tagstacklen)\n\t\t    tagstack_clear_entry(&tagstack[--tagstacklen]);\n\n\t\t// if the tagstack is full: remove oldest entry\n\t\tif (++tagstacklen > TAGSTACKSIZE)\n\t\t{\n\t\t    tagstacklen = TAGSTACKSIZE;\n\t\t    tagstack_clear_entry(&tagstack[0]);\n\t\t    for (i = 1; i < tagstacklen; ++i)\n\t\t\ttagstack[i - 1] = tagstack[i];\n\t\t    --tagstackidx;\n\t\t}\n\n\t\t/*\n\t\t * put the tag name in the tag stack\n\t\t */\n\t\tif ((tagstack[tagstackidx].tagname = vim_strsave(tag)) == NULL)\n\t\t{\n\t\t    curwin->w_tagstacklen = tagstacklen - 1;\n\t\t    goto end_do_tag;\n\t\t}\n\t\tcurwin->w_tagstacklen = tagstacklen;\n\n\t\tsave_pos = TRUE;\t// save the cursor position below\n\t    }\n\n\t    new_tag = TRUE;\n\t}\n\telse\n\t{\n\t    if (\n#if defined(FEAT_QUICKFIX)\n\t\t    g_do_tagpreview != 0 ? ptag_entry.tagname == NULL :\n#endif\n\t\t    tagstacklen == 0)\n\t    {\n\t\t// empty stack\n\t\temsg(_(e_tag_stack_empty));\n\t\tgoto end_do_tag;\n\t    }\n\n\t    if (type == DT_POP)\t\t// go to older position\n\t    {\n#ifdef FEAT_FOLDING\n\t\tint\told_KeyTyped = KeyTyped;\n#endif\n\t\tif ((tagstackidx -= count) < 0)\n\t\t{\n\t\t    emsg(_(e_at_bottom_of_tag_stack));\n\t\t    if (tagstackidx + count == 0)\n\t\t    {\n\t\t\t// We did [num]^T from the bottom of the stack\n\t\t\ttagstackidx = 0;\n\t\t\tgoto end_do_tag;\n\t\t    }\n\t\t    // We weren't at the bottom of the stack, so jump all the\n\t\t    // way to the bottom now.\n\t\t    tagstackidx = 0;\n\t\t}\n\t\telse if (tagstackidx >= tagstacklen)    // count == 0?\n\t\t{\n\t\t    emsg(_(e_at_top_of_tag_stack));\n\t\t    goto end_do_tag;\n\t\t}\n\n\t\t// Make a copy of the fmark, autocommands may invalidate the\n\t\t// tagstack before it's used.\n\t\tsaved_fmark = tagstack[tagstackidx].fmark;\n\t\tif (saved_fmark.fnum != curbuf->b_fnum)\n\t\t{\n\t\t    /*\n\t\t     * Jump to other file. If this fails (e.g. because the\n\t\t     * file was changed) keep original position in tag stack.\n\t\t     */\n\t\t    if (buflist_getfile(saved_fmark.fnum, saved_fmark.mark.lnum,\n\t\t\t\t\t       GETF_SETMARK, forceit) == FAIL)\n\t\t    {\n\t\t\ttagstackidx = oldtagstackidx;  // back to old posn\n\t\t\tgoto end_do_tag;\n\t\t    }\n\t\t    // An BufReadPost autocommand may jump to the '\" mark, but\n\t\t    // we don't what that here.\n\t\t    curwin->w_cursor.lnum = saved_fmark.mark.lnum;\n\t\t}\n\t\telse\n\t\t{\n\t\t    setpcmark();\n\t\t    curwin->w_cursor.lnum = saved_fmark.mark.lnum;\n\t\t}\n\t\tcurwin->w_cursor.col = saved_fmark.mark.col;\n\t\tcurwin->w_set_curswant = TRUE;\n\t\tcheck_cursor();\n#ifdef FEAT_FOLDING\n\t\tif ((fdo_flags & FDO_TAG) && old_KeyTyped)\n\t\t    foldOpenCursor();\n#endif\n\n\t\t// remove the old list of matches\n\t\tFreeWild(num_matches, matches);\n#ifdef FEAT_CSCOPE\n\t\tcs_free_tags();\n#endif\n\t\tnum_matches = 0;\n\t\ttag_freematch();\n\t\tgoto end_do_tag;\n\t    }\n\n\t    if (type == DT_TAG\n#if defined(FEAT_QUICKFIX)\n\t\t    || type == DT_LTAG\n#endif\n\t       )\n\t    {\n#if defined(FEAT_QUICKFIX)\n\t\tif (g_do_tagpreview != 0)\n\t\t{\n\t\t    cur_match = ptag_entry.cur_match;\n\t\t    cur_fnum = ptag_entry.cur_fnum;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    // \":tag\" (no argument): go to newer pattern\n\t\t    save_pos = TRUE;\t// save the cursor position below\n\t\t    if ((tagstackidx += count - 1) >= tagstacklen)\n\t\t    {\n\t\t\t/*\n\t\t\t * Beyond the last one, just give an error message and\n\t\t\t * go to the last one.  Don't store the cursor\n\t\t\t * position.\n\t\t\t */\n\t\t\ttagstackidx = tagstacklen - 1;\n\t\t\temsg(_(e_at_top_of_tag_stack));\n\t\t\tsave_pos = FALSE;\n\t\t    }\n\t\t    else if (tagstackidx < 0)\t// must have been count == 0\n\t\t    {\n\t\t\temsg(_(e_at_bottom_of_tag_stack));\n\t\t\ttagstackidx = 0;\n\t\t\tgoto end_do_tag;\n\t\t    }\n\t\t    cur_match = tagstack[tagstackidx].cur_match;\n\t\t    cur_fnum = tagstack[tagstackidx].cur_fnum;\n\t\t}\n\t\tnew_tag = TRUE;\n\t    }\n\t    else\t\t\t\t// go to other matching tag\n\t    {\n\t\t// Save index for when selection is cancelled.\n\t\tprevtagstackidx = tagstackidx;\n\n#if defined(FEAT_QUICKFIX)\n\t\tif (g_do_tagpreview != 0)\n\t\t{\n\t\t    cur_match = ptag_entry.cur_match;\n\t\t    cur_fnum = ptag_entry.cur_fnum;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    if (--tagstackidx < 0)\n\t\t\ttagstackidx = 0;\n\t\t    cur_match = tagstack[tagstackidx].cur_match;\n\t\t    cur_fnum = tagstack[tagstackidx].cur_fnum;\n\t\t}\n\t\tswitch (type)\n\t\t{\n\t\t    case DT_FIRST: cur_match = count - 1; break;\n\t\t    case DT_SELECT:\n\t\t    case DT_JUMP:\n#ifdef FEAT_CSCOPE\n\t\t    case DT_CSCOPE:\n#endif\n\t\t    case DT_LAST:  cur_match = MAXCOL - 1; break;\n\t\t    case DT_NEXT:  cur_match += count; break;\n\t\t    case DT_PREV:  cur_match -= count; break;\n\t\t}\n\t\tif (cur_match >= MAXCOL)\n\t\t    cur_match = MAXCOL - 1;\n\t\telse if (cur_match < 0)\n\t\t{\n\t\t    emsg(_(e_cannot_go_before_first_matching_tag));\n\t\t    skip_msg = TRUE;\n\t\t    cur_match = 0;\n\t\t    cur_fnum = curbuf->b_fnum;\n\t\t}\n\t    }\n\t}\n\n#if defined(FEAT_QUICKFIX)\n\tif (g_do_tagpreview != 0)\n\t{\n\t    if (type != DT_SELECT && type != DT_JUMP)\n\t    {\n\t\tptag_entry.cur_match = cur_match;\n\t\tptag_entry.cur_fnum = cur_fnum;\n\t    }\n\t}\n\telse\n#endif\n\t{\n\t    /*\n\t     * For \":tag [arg]\" or \":tselect\" remember position before the jump.\n\t     */\n\t    saved_fmark = tagstack[tagstackidx].fmark;\n\t    if (save_pos)\n\t    {\n\t\ttagstack[tagstackidx].fmark.mark = curwin->w_cursor;\n\t\ttagstack[tagstackidx].fmark.fnum = curbuf->b_fnum;\n\t    }\n\n\t    // Curwin will change in the call to jumpto_tag() if \":stag\" was\n\t    // used or an autocommand jumps to another window; store value of\n\t    // tagstackidx now.\n\t    curwin->w_tagstackidx = tagstackidx;\n\t    if (type != DT_SELECT && type != DT_JUMP)\n\t    {\n\t\tcurwin->w_tagstack[tagstackidx].cur_match = cur_match;\n\t\tcurwin->w_tagstack[tagstackidx].cur_fnum = cur_fnum;\n\t    }\n\t}\n    }\n\n    // When not using the current buffer get the name of buffer \"cur_fnum\".\n    // Makes sure that the tag order doesn't change when using a remembered\n    // position for \"cur_match\".\n    if (cur_fnum != curbuf->b_fnum)\n    {\n\tbuf_T *buf = buflist_findnr(cur_fnum);\n\n\tif (buf != NULL)\n\t    buf_ffname = buf->b_ffname;\n    }\n\n    /*\n     * Repeat searching for tags, when a file has not been found.\n     */\n    for (;;)\n    {\n\tint\tother_name;\n\tchar_u\t*name;\n\n\t/*\n\t * When desired match not found yet, try to find it (and others).\n\t */\n\tif (use_tagstack)\n\t{\n\t    // make a copy, the tagstack may change in 'tagfunc'\n\t    name = vim_strsave(tagstack[tagstackidx].tagname);\n\t    vim_free(tofree);\n\t    tofree = name;\n\t}\n#if defined(FEAT_QUICKFIX)\n\telse if (g_do_tagpreview != 0)\n\t    name = ptag_entry.tagname;\n#endif\n\telse\n\t    name = tag;\n\tother_name = (tagmatchname == NULL || STRCMP(tagmatchname, name) != 0);\n\tif (new_tag\n\t\t|| (cur_match >= num_matches && max_num_matches != MAXCOL)\n\t\t|| other_name)\n\t{\n\t    if (other_name)\n\t    {\n\t\tvim_free(tagmatchname);\n\t\ttagmatchname = vim_strsave(name);\n\t    }\n\n\t    if (type == DT_SELECT || type == DT_JUMP\n#if defined(FEAT_QUICKFIX)\n\t\t|| type == DT_LTAG\n#endif\n\t\t)\n\t\tcur_match = MAXCOL - 1;\n\t    if (type == DT_TAG)\n\t\tmax_num_matches = MAXCOL;\n\t    else\n\t\tmax_num_matches = cur_match + 1;\n\n\t    // when the argument starts with '/', use it as a regexp\n\t    if (!no_regexp && *name == '/')\n\t    {\n\t\tflags = TAG_REGEXP;\n\t\t++name;\n\t    }\n\t    else\n\t\tflags = TAG_NOIC;\n\n#ifdef FEAT_CSCOPE\n\t    if (type == DT_CSCOPE)\n\t\tflags = TAG_CSCOPE;\n#endif\n\t    if (verbose)\n\t\tflags |= TAG_VERBOSE;\n\n\t    if (!use_tfu)\n\t\tflags |= TAG_NO_TAGFUNC;\n\n\t    if (find_tags(name, &new_num_matches, &new_matches, flags,\n\t\t\t\t\t    max_num_matches, buf_ffname) == OK\n\t\t    && new_num_matches < max_num_matches)\n\t\tmax_num_matches = MAXCOL; // If less than max_num_matches\n\t\t\t\t\t  // found: all matches found.\n\n\t    // A tag function may do anything, which may cause various\n\t    // information to become invalid.  At least check for the tagstack\n\t    // to still be the same.\n\t    if (tagstack != curwin->w_tagstack)\n\t    {\n\t\temsg(_(e_window_unexpectedly_close_while_searching_for_tags));\n\t\tFreeWild(new_num_matches, new_matches);\n\t\tbreak;\n\t    }\n\n\t    // If there already were some matches for the same name, move them\n\t    // to the start.  Avoids that the order changes when using\n\t    // \":tnext\" and jumping to another file.\n\t    if (!new_tag && !other_name)\n\t    {\n\t\tint\t    j, k;\n\t\tint\t    idx = 0;\n\t\ttagptrs_T   tagp, tagp2;\n\n\t\t// Find the position of each old match in the new list.  Need\n\t\t// to use parse_match() to find the tag line.\n\t\tfor (j = 0; j < num_matches; ++j)\n\t\t{\n\t\t    parse_match(matches[j], &tagp);\n\t\t    for (i = idx; i < new_num_matches; ++i)\n\t\t    {\n\t\t\tparse_match(new_matches[i], &tagp2);\n\t\t\tif (STRCMP(tagp.tagname, tagp2.tagname) == 0)\n\t\t\t{\n\t\t\t    char_u *p = new_matches[i];\n\t\t\t    for (k = i; k > idx; --k)\n\t\t\t\tnew_matches[k] = new_matches[k - 1];\n\t\t\t    new_matches[idx++] = p;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    FreeWild(num_matches, matches);\n\t    num_matches = new_num_matches;\n\t    matches = new_matches;\n\t}\n\n\tif (num_matches <= 0)\n\t{\n\t    if (verbose)\n\t\tsemsg(_(e_tag_not_found_str), name);\n#if defined(FEAT_QUICKFIX)\n\t    g_do_tagpreview = 0;\n#endif\n\t}\n\telse\n\t{\n\t    int ask_for_selection = FALSE;\n\n#ifdef FEAT_CSCOPE\n\t    if (type == DT_CSCOPE && num_matches > 1)\n\t    {\n\t\tcs_print_tags();\n\t\task_for_selection = TRUE;\n\t    }\n\t    else\n#endif\n\t    if (type == DT_TAG && *tag != NUL)\n\t\t// If a count is supplied to the \":tag <name>\" command, then\n\t\t// jump to count'th matching tag.\n\t\tcur_match = count > 0 ? count - 1 : 0;\n\t    else if (type == DT_SELECT || (type == DT_JUMP && num_matches > 1))\n\t    {\n\t\tprint_tag_list(new_tag, use_tagstack, num_matches, matches);\n\t\task_for_selection = TRUE;\n\t    }\n#if defined(FEAT_QUICKFIX) && defined(FEAT_EVAL)\n\t    else if (type == DT_LTAG)\n\t    {\n\t\tif (add_llist_tags(tag, num_matches, matches) == FAIL)\n\t\t    goto end_do_tag;\n\t\tcur_match = 0;\t\t// Jump to the first tag\n\t    }\n#endif\n\n\t    if (ask_for_selection == TRUE)\n\t    {\n\t\t/*\n\t\t * Ask to select a tag from the list.\n\t\t */\n\t\ti = prompt_for_number(NULL);\n\t\tif (i <= 0 || i > num_matches || got_int)\n\t\t{\n\t\t    // no valid choice: don't change anything\n\t\t    if (use_tagstack)\n\t\t    {\n\t\t\ttagstack[tagstackidx].fmark = saved_fmark;\n\t\t\ttagstackidx = prevtagstackidx;\n\t\t    }\n#ifdef FEAT_CSCOPE\n\t\t    cs_free_tags();\n\t\t    jumped_to_tag = TRUE;\n#endif\n\t\t    break;\n\t\t}\n\t\tcur_match = i - 1;\n\t    }\n\n\t    if (cur_match >= num_matches)\n\t    {\n\t\t// Avoid giving this error when a file wasn't found and we're\n\t\t// looking for a match in another file, which wasn't found.\n\t\t// There will be an emsg(\"file doesn't exist\") below then.\n\t\tif ((type == DT_NEXT || type == DT_FIRST)\n\t\t\t\t\t\t      && nofile_fname == NULL)\n\t\t{\n\t\t    if (num_matches == 1)\n\t\t\temsg(_(e_there_is_only_one_matching_tag));\n\t\t    else\n\t\t\temsg(_(e_cannot_go_beyond_last_matching_tag));\n\t\t    skip_msg = TRUE;\n\t\t}\n\t\tcur_match = num_matches - 1;\n\t    }\n\t    if (use_tagstack)\n\t    {\n\t\ttagptrs_T   tagp;\n\n\t\ttagstack[tagstackidx].cur_match = cur_match;\n\t\ttagstack[tagstackidx].cur_fnum = cur_fnum;\n\n\t\t// store user-provided data originating from tagfunc\n\t\tif (use_tfu && parse_match(matches[cur_match], &tagp) == OK\n\t\t\t&& tagp.user_data)\n\t\t{\n\t\t    VIM_CLEAR(tagstack[tagstackidx].user_data);\n\t\t    tagstack[tagstackidx].user_data = vim_strnsave(\n\t\t\t  tagp.user_data, tagp.user_data_end - tagp.user_data);\n\t\t}\n\n\t\t++tagstackidx;\n\t    }\n#if defined(FEAT_QUICKFIX)\n\t    else if (g_do_tagpreview != 0)\n\t    {\n\t\tptag_entry.cur_match = cur_match;\n\t\tptag_entry.cur_fnum = cur_fnum;\n\t    }\n#endif\n\n\t    /*\n\t     * Only when going to try the next match, report that the previous\n\t     * file didn't exist.  Otherwise an emsg() is given below.\n\t     */\n\t    if (nofile_fname != NULL && error_cur_match != cur_match)\n\t\tsmsg(_(\"File \\\"%s\\\" does not exist\"), nofile_fname);\n\n\n\t    ic = (matches[cur_match][0] & MT_IC_OFF);\n\t    if (type != DT_TAG && type != DT_SELECT && type != DT_JUMP\n#ifdef FEAT_CSCOPE\n\t\t&& type != DT_CSCOPE\n#endif\n\t\t&& (num_matches > 1 || ic)\n\t\t&& !skip_msg)\n\t    {\n\t\t// Give an indication of the number of matching tags\n\t\tsprintf((char *)IObuff, _(\"tag %d of %d%s\"),\n\t\t\t\tcur_match + 1,\n\t\t\t\tnum_matches,\n\t\t\t\tmax_num_matches != MAXCOL ? _(\" or more\") : \"\");\n\t\tif (ic)\n\t\t    STRCAT(IObuff, _(\"  Using tag with different case!\"));\n\t\tif ((num_matches > prev_num_matches || new_tag)\n\t\t\t\t\t\t\t   && num_matches > 1)\n\t\t{\n\t\t    if (ic)\n\t\t\tmsg_attr((char *)IObuff, HL_ATTR(HLF_W));\n\t\t    else\n\t\t\tmsg((char *)IObuff);\n\t\t    msg_scroll = TRUE;\t// don't overwrite this message\n\t\t}\n\t\telse\n\t\t    give_warning(IObuff, ic);\n\t\tif (ic && !msg_scrolled && msg_silent == 0)\n\t\t{\n\t\t    out_flush();\n\t\t    ui_delay(1007L, TRUE);\n\t\t}\n\t    }\n\n#if defined(FEAT_EVAL)\n\t    // Let the SwapExists event know what tag we are jumping to.\n\t    vim_snprintf((char *)IObuff, IOSIZE, \":ta %s\\r\", name);\n\t    set_vim_var_string(VV_SWAPCOMMAND, IObuff, -1);\n#endif\n\n\t    /*\n\t     * Jump to the desired match.\n\t     */\n\t    i = jumpto_tag(matches[cur_match], forceit, type != DT_CSCOPE);\n\n#if defined(FEAT_EVAL)\n\t    set_vim_var_string(VV_SWAPCOMMAND, NULL, -1);\n#endif\n\n\t    if (i == NOTAGFILE)\n\t    {\n\t\t// File not found: try again with another matching tag\n\t\tif ((type == DT_PREV && cur_match > 0)\n\t\t\t|| ((type == DT_TAG || type == DT_NEXT\n\t\t\t\t\t\t\t  || type == DT_FIRST)\n\t\t\t    && (max_num_matches != MAXCOL\n\t\t\t\t\t     || cur_match < num_matches - 1)))\n\t\t{\n\t\t    error_cur_match = cur_match;\n\t\t    if (use_tagstack)\n\t\t\t--tagstackidx;\n\t\t    if (type == DT_PREV)\n\t\t\t--cur_match;\n\t\t    else\n\t\t    {\n\t\t\ttype = DT_NEXT;\n\t\t\t++cur_match;\n\t\t    }\n\t\t    continue;\n\t\t}\n\t\tsemsg(_(e_file_str_does_not_exist), nofile_fname);\n\t    }\n\t    else\n\t    {\n\t\t// We may have jumped to another window, check that\n\t\t// tagstackidx is still valid.\n\t\tif (use_tagstack && tagstackidx > curwin->w_tagstacklen)\n\t\t    tagstackidx = curwin->w_tagstackidx;\n#ifdef FEAT_CSCOPE\n\t\tjumped_to_tag = TRUE;\n#endif\n\t    }\n\t}\n\tbreak;\n    }\n\nend_do_tag:\n    // Only store the new index when using the tagstack and it's valid.\n    if (use_tagstack && tagstackidx <= curwin->w_tagstacklen)\n\tcurwin->w_tagstackidx = tagstackidx;\n    postponed_split = 0;\t// don't split next time\n# ifdef FEAT_QUICKFIX\n    g_do_tagpreview = 0;\t// don't do tag preview next time\n# endif\n\n    vim_free(tofree);\n#ifdef FEAT_CSCOPE\n    return jumped_to_tag;\n#else\n    return FALSE;\n#endif\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"vim.h\"\n\n// Type Definitions:\n// pos_T:\ntypedef struct\n{\n    linenr_T\tlnum;\t// line number\n    colnr_T\tcol;\t// column number\n    colnr_T\tcoladd; // extra virtual column\n}\n\n// tagsearch_info_T:\ntypedef struct\n{\n    off_T\tlow_offset;\t// offset for first char of first line that\n\t\t\t\t// could match\n    off_T\thigh_offset;\t// offset of char after last line that could\n\t\t\t\t// match\n    off_T\tcurr_offset;\t// Current file offset in search range\n    off_T\tcurr_offset_used; // curr_offset used when skipping back\n    off_T\tmatch_offset;\t// Where the binary search found a tag\n    int\tlow_char;\t\t// first char at low_offset\n    int\thigh_char;\t\t// first char at high_offset\n}\n\n// exarg_T:\ntypedef struct exarg exarg_T;\n\n// hash_T:\ntypedef long_u hash_T;\n\n// dictitem_T:\ntypedef struct dictitem_S dictitem_T;\n\n// tags_read_status_T:\ntypedef enum\n{\n    TAGS_READ_SUCCESS = 1,\n    TAGS_READ_EOF,\n    TAGS_READ_IGNORE,\n}\n\n// tagmatch_status_T:\ntypedef enum\n{\n    TAG_MATCH_SUCCESS = 1,\n    TAG_MATCH_FAIL,\n    TAG_MATCH_STOP,\n    TAG_MATCH_NEXT\n}\n\n// expand_T:\ntypedef struct expand\n{\n    char_u\t*xp_pattern;\t\t// start of item to expand\n    int\t\txp_context;\t\t// type of expansion\n    int\t\txp_pattern_len;\t\t// bytes in xp_pattern before cursor\n#if defined(FEAT_EVAL)\n    char_u\t*xp_arg;\t\t// completion function\n    sctx_T\txp_script_ctx;\t\t// SCTX for completion function\n#endif\n    int\t\txp_backslash;\t\t// one of the XP_BS_ values\n#ifndef BACKSLASH_IN_FILENAME\n    int\t\txp_shell;\t\t// TRUE for a shell command, more\n\t\t\t\t\t// characters need to be escaped\n#endif\n    int\t\txp_numfiles;\t\t// number of files found by\n\t\t\t\t\t// file name completion\n    int\t\txp_col;\t\t\t// cursor position in line\n    char_u\t**xp_files;\t\t// list of files\n    char_u\t*xp_line;\t\t// text being completed\n#define EXPAND_BUF_LEN 256\n    char_u\txp_buf[EXPAND_BUF_LEN];\t// buffer for returned match\n} expand_T;\n\n// taggy_T:\ntypedef struct taggy\n{\n    char_u\t*tagname;\t// tag name\n    fmark_T\tfmark;\t\t// cursor position BEFORE \":tag\"\n    int\t\tcur_match;\t// match number\n    int\t\tcur_fnum;\t// buffer number used for cur_match\n    char_u\t*user_data;\t// used with tagfunc\n} taggy_T;\n\n// pat_T:\ntypedef struct\n{\n    char_u\t*pat;\t\t// the pattern\n    int\t\tlen;\t\t// length of pat[]\n    char_u\t*head;\t\t// start of pattern head\n    int\t\theadlen;\t// length of head[]\n    regmatch_T\tregmatch;\t// regexp program, may be NULL\n}\n\n// tagptrs_T:\ntypedef struct tag_pointers\n{\n    // filled in by parse_tag_line():\n    char_u\t*tagname;\t// start of tag name (skip \"file:\")\n    char_u\t*tagname_end;\t// char after tag name\n    char_u\t*fname;\t\t// first char of file name\n    char_u\t*fname_end;\t// char after file name\n    char_u\t*command;\t// first char of command\n    // filled in by parse_match():\n    char_u\t*command_end;\t// first char after command\n    char_u\t*tag_fname;\t// file name of the tags file. This is used\n\t\t\t\t// when 'tr' is set.\n#ifdef FEAT_EMACS_TAGS\n    int\t\tis_etag;\t// TRUE for emacs tag\n#endif\n    char_u\t*tagkind;\t// \"kind:\" value\n    char_u\t*tagkind_end;\t// end of tagkind\n    char_u\t*user_data;\t// user_data string\n    char_u\t*user_data_end;\t// end of user_data\n    linenr_T\ttagline;\t// \"line:\" value\n} tagptrs_T;\n\n// dict_iterator_T:\ntypedef struct\n{\n    long_u\tdit_todo;\n    hashitem_T\t*dit_hi;\n}\n\n// win_T:\ntypedef struct window_S\t\twin_T;\n\n// linenr_T:\ntypedef long\t\tlinenr_T;\n\n// linenr_T:\ntypedef long\tlinenr_T;\n\n// garray_T:\ntypedef struct growarray\n{\n    int\t    ga_len;\t\t    // current number of items used\n    int\t    ga_maxlen;\t\t    // maximum number of items possible\n    int\t    ga_itemsize;\t    // sizeof(item)\n    int\t    ga_growsize;\t    // number of items to grow each time\n    void    *ga_data;\t\t    // pointer to the first item\n} garray_T;\n\n// dict_T:\ntypedef struct dictvar_S dict_T;\n\n// listitem_T:\ntypedef struct listitem_S listitem_T;\n\n// off_T:\ntypedef off_t off_T;\n\n// findtags_state_T:\ntypedef struct\n{\n    tagsearch_state_T\tstate;\t\t// tag search state\n    int\t\tstop_searching;\t\t// stop when match found or error\n    pat_T\t*orgpat;\t\t// holds unconverted pattern info\n    char_u     *lbuf;\t\t\t// line buffer\n    int\t\tlbuf_size;\t\t// length of lbuf\n    char_u\t*tag_fname;\t\t// name of the tag file\n    FILE\t*fp;\t\t\t// current tags file pointer\n    int\t\tflags;\t\t\t// flags used for tag search\n    int\t\ttag_file_sorted;\t// !_TAG_FILE_SORTED value\n    int\t\tget_searchpat;\t\t// used for 'showfulltag'\n    int\t\thelp_only;\t\t// only search for help tags\n    int\t\tdid_open;\t\t// did open a tag file\n    int\t\tmincount;\t\t// MAXCOL: find all matches\n\t\t\t\t\t// other: minimal number of matches\n    int\t\tlinear;\t\t\t// do a linear search\n    vimconv_T\tvimconv;\n#ifdef FEAT_EMACS_TAGS\n    int\t\tis_etag;\t\t// current file is emacs style\n    char_u\t*ebuf;\t\t\t// additional buffer for etag fname\n#endif\n#ifdef FEAT_MULTI_LANG\n    char_u\thelp_lang[3];\t\t// lang of current tags file\n    int\t\thelp_pri;\t\t// help langua...\n\n// char_u:\ntypedef unsigned char\tchar_u;\n\n// off_T:\ntypedef __int64 off_T;\n\n// fmark_T:\ntypedef struct filemark\n{\n    pos_T\tmark;\t\t// cursor position\n    int\t\tfnum;\t\t// file number\n} fmark_T;\n\n// typval_T:\ntypedef struct\n{\n    vartype_T\tv_type;\n    char\tv_lock;\t    // see below: VAR_LOCKED, VAR_FIXED\n    union\n    {\n\tvarnumber_T\tv_number;\t// number value\n#ifdef FEAT_FLOAT\n\tfloat_T\t\tv_float;\t// floating number value\n#endif\n\tchar_u\t\t*v_string;\t// string value (can be NULL!)\n\tlist_T\t\t*v_list;\t// list value (can be NULL!)\n\tdict_T\t\t*v_dict;\t// dict value (can be NULL!)\n\tpartial_T\t*v_partial;\t// closure: function with args\n#ifdef FEAT_JOB_CHANNEL\n\tjob_T\t\t*v_job;\t\t// job value (can be NULL!)\n\tchannel_T\t*v_channel;\t// channel value (can be NULL!)\n#endif\n\tblob_T\t\t*v_blob;\t// blob value (can be NULL!)\n\tinstr_T\t\t*v_instr;\t// instructions to execute\n    }\t\tvval;\n}\n\n// optmagic_T:\ntypedef enum {\n    OPTION_MAGIC_NOT_SET,\t// p_magic not overruled\n    OPTION_MAGIC_ON,\t\t// magic on inside regexp\n    OPTION_MAGIC_OFF\t\t// magic off inside regexp\n}\n\n// tagname_T:\ntypedef struct\n{\n    char_u\t*tn_tags;\t// value of 'tags' when starting\n    char_u\t*tn_np;\t\t// current position in tn_tags\n    int\t\ttn_did_filefind_init;\n    int\t\ttn_hf_idx;\n    void\t*tn_search_ctx;\n}\n\n// findtags_match_args_T:\ntypedef struct\n{\n    int\tmatchoff;\t\t// tag match offset\n    int\tmatch_re;\t\t// TRUE if the tag matches a regexp\n    int\tmatch_no_ic;\t\t// TRUE if the tag matches with case\n    int\thas_re;\t\t\t// regular expression used\n    int\tsortic;\t\t\t// tags file sorted ignoring case (foldcase)\n    int\tsort_error;\t\t// tags file not sorted\n}\n\n// buf_T:\ntypedef struct file_buffer\tbuf_T;\n\n// hashitem_T:\ntypedef struct hashitem_S\n{\n    long_u\thi_hash;\t// cached hash number of hi_key\n    char_u\t*hi_key;\n} hashitem_T;\n\n// list_T:\ntypedef struct listvar_S list_T;\n\n// callback_T:\ntypedef struct {\n    char_u\t*cb_name;\n    partial_T\t*cb_partial;\n    int\t\tcb_free_name;\t    // cb_name was allocated\n}\n\n// Called Methods (top 10):\n// find_wininfo from src/buffer.c:\n    static wininfo_T * /* <=== find_wininfo */ \nfind_wininfo(\n    buf_T\t*buf,\n    int\t\tneed_options,\n    int\t\tskip_diff_buffer UNUSED)\n{\n    wininfo_T\t*wip;\n\n    FOR_ALL_BUF_WININFO(buf, wip)\n\tif (wip->wi_win == curwin\n#ifdef FEAT_DIFF\n\t\t&& (!skip_diff_buffer || !wininfo_other_tab_diff(wip))\n#endif\n\n\t\t&& (!need_options || wip->wi_optset))\n\t    break;\n\n    // If no wininfo for curwin, use the first in the list (that doesn't have\n    // 'diff' set and is in another tab page).\n    // If \"need_options\" is TRUE skip entries that don't have options set,\n    // unless the window is editing \"buf\", so we can copy from the window\n    // itself.\n    if (wip == NULL)\n    {\n#ifdef FEAT_DIFF\n\tif (skip_diff_buffer)\n\t{\n\t    FOR_ALL_BUF_WININFO(buf, wip)\n\t\tif (!wininfo_other_tab_diff(wip)\n\t\t\t&& (!need_options || wip->wi_optset\n\t\t\t    || (wip->wi_win != NULL\n\t\t\t\t\t     && wip->wi_win->w_buffer == buf)))\n\t\t    break;\n\t}\n\telse\n#endif\n\t    wip = buf->b_wininfo;\n    }\n    return wip;\n}\n\n// set_vv_searchforward from src/search.c:\n    static void /* <=== set_vv_searchforward */ \nset_vv_searchforward(void)\n{\n    set_vim_var_nr(VV_SEARCHFORWARD, (long)(spats[0].off.dir == '/'));\n}\n\n// POPF_INFO from src/vim.h:\n#define POPF_INFO\t0x200\t// used for info of popup menu /* <=== src/vim.h:641:641:POPF_INFO:0 */ \n\n// DOCMD_EXCRESET from src/vim.h:\n#define DOCMD_EXCRESET\t0x10\t// reset exception environment (for debugging) /* <=== src/vim.h:1088:1088:DOCMD_EXCRESET:0 */ \n\n// TC_MATCH from src/option.h:\n<empty>\n\n// win_split_ins from src/window.c:\n    int /* <=== win_split_ins */ \nwin_split_ins(\n    int\t\tsize,\n    int\t\tflags,\n    win_T\t*new_wp,\n    int\t\tdir)\n{\n    win_T\t*wp = new_wp;\n    win_T\t*oldwin;\n    int\t\tnew_size = size;\n    int\t\ti;\n    int\t\tneed_status = 0;\n    int\t\tdo_equal = FALSE;\n    int\t\tneeded;\n    int\t\tavailable;\n    int\t\toldwin_height = 0;\n    int\t\tlayout;\n    frame_T\t*frp, *curfrp, *frp2, *prevfrp;\n    int\t\tbefore;\n    int\t\tminheight;\n    int\t\twmh1;\n    int\t\tdid_set_fraction = FALSE;\n\n    if (flags & WSP_TOP)\n\toldwin = firstwin;\n    else if (flags & WSP_BOT)\n\toldwin = lastwin;\n    else\n\toldwin = curwin;\n\n    // add a status line when p_ls == 1 and splitting the first window\n    if (ONE_WINDOW && p_ls == 1 && oldwin->w_status_height == 0)\n    {\n\tif (VISIBLE_HEIGHT(oldwin) <= p_wmh && new_wp == NULL)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    return FAIL;\n\t}\n\tneed_status = STATUS_HEIGHT;\n    }\n\n#ifdef FEAT_GUI\n    // May be needed for the scrollbars that are going to change.\n    if (gui.in_use)\n\tout_flush();\n#endif\n\n    if (flags & WSP_VERT)\n    {\n\tint\twmw1;\n\tint\tminwidth;\n\n\tlayout = FR_ROW;\n\n\t/*\n\t * Check if we are able to split the current window and compute its\n\t * width.\n\t */\n\t// Current window requires at least 1 space.\n\twmw1 = (p_wmw == 0 ? 1 : p_wmw);\n\tneeded = wmw1 + 1;\n\tif (flags & WSP_ROOM)\n\t    needed += p_wiw - wmw1;\n\tif (flags & (WSP_BOT | WSP_TOP))\n\t{\n\t    minwidth = frame_minwidth(topframe, NOWIN);\n\t    available = topframe->fr_width;\n\t    needed += minwidth;\n\t}\n\telse if (p_ea)\n\t{\n\t    minwidth = frame_minwidth(oldwin->w_frame, NOWIN);\n\t    prevfrp = oldwin->w_frame;\n\t    for (frp = oldwin->w_frame->fr_parent; frp != NULL;\n\t\t\t\t\t\t\tfrp = frp->fr_parent)\n\t    {\n\t\tif (frp->fr_layout == FR_ROW)\n\t\t    FOR_ALL_FRAMES(frp2, frp->fr_child)\n\t\t\tif (frp2 != prevfrp)\n\t\t\t    minwidth += frame_minwidth(frp2, NOWIN);\n\t\tprevfrp = frp;\n\t    }\n\t    available = topframe->fr_width;\n\t    needed += minwidth;\n\t}\n\telse\n\t{\n\t    minwidth = frame_minwidth(oldwin->w_frame, NOWIN);\n\t    available = oldwin->w_frame->fr_width;\n\t    needed += minwidth;\n\t}\n\tif (available < needed && new_wp == NULL)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    return FAIL;\n\t}\n\tif (new_size == 0)\n\t    new_size = oldwin->w_width / 2;\n\tif (new_size > available - minwidth - 1)\n\t    new_size = available - minwidth - 1;\n\tif (new_size < wmw1)\n\t    new_size = wmw1;\n\n\t// if it doesn't fit in the current window, need win_equal()\n\tif (oldwin->w_width - new_size - 1 < p_wmw)\n\t    do_equal = TRUE;\n\n\t// We don't like to take lines for the new window from a\n\t// 'winfixwidth' window.  Take them from a window to the left or right\n\t// instead, if possible. Add one for the separator.\n\tif (oldwin->w_p_wfw)\n\t    win_setwidth_win(oldwin->w_width + new_size + 1, oldwin);\n\n\t// Only make all windows the same width if one of them (except oldwin)\n\t// is wider than one of the split windows.\n\tif (!do_equal && p_ea && size == 0 && *p_ead != 'v'\n\t\t\t\t\t && oldwin->w_frame->fr_parent != NULL)\n\t{\n\t    frp = oldwin->w_frame->fr_parent->fr_child;\n\t    while (frp != NULL)\n\t    {\n\t\tif (frp->fr_win != oldwin && frp->fr_win != NULL\n\t\t\t&& (frp->fr_win->w_width > new_size\n\t\t\t    || frp->fr_win->w_width > oldwin->w_width\n\t\t\t\t\t\t\t      - new_size - 1))\n\t\t{\n\t\t    do_equal = TRUE;\n\t\t    break;\n\t\t}\n\t\tfrp = frp->fr_next;\n\t    }\n\t}\n    }\n    else\n    {\n\tlayout = FR_COL;\n\n\t/*\n\t * Check if we are able to split the current window and compute its\n\t * height.\n\t */\n\t// Current window requires at least 1 space.\n\twmh1 = (p_wmh == 0 ? 1 : p_wmh) + WINBAR_HEIGHT(curwin);\n\tneeded = wmh1 + STATUS_HEIGHT;\n\tif (flags & WSP_ROOM)\n\t    needed += p_wh - wmh1;\n\tif (flags & (WSP_BOT | WSP_TOP))\n\t{\n\t    minheight = frame_minheight(topframe, NOWIN) + need_status;\n\t    available = topframe->fr_height;\n\t    needed += minheight;\n\t}\n\telse if (p_ea)\n\t{\n\t    minheight = frame_minheight(oldwin->w_frame, NOWIN) + need_status;\n\t    prevfrp = oldwin->w_frame;\n\t    for (frp = oldwin->w_frame->fr_parent; frp != NULL;\n\t\t\t\t\t\t\tfrp = frp->fr_parent)\n\t    {\n\t\tif (frp->fr_layout == FR_COL)\n\t\t    FOR_ALL_FRAMES(frp2, frp->fr_child)\n\t\t\tif (frp2 != prevfrp)\n\t\t\t    minheight += frame_minheight(frp2, NOWIN);\n\t\tprevfrp = frp;\n\t    }\n\t    available = topframe->fr_height;\n\t    needed += minheight;\n\t}\n\telse\n\t{\n\t    minheight = frame_minheight(oldwin->w_frame, NOWIN) + need_status;\n\t    available = oldwin->w_frame->fr_height;\n\t    needed += minheight;\n\t}\n\tif (available < needed && new_wp == NULL)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    return FAIL;\n\t}\n\toldwin_height = oldwin->w_height;\n\tif (need_status)\n\t{\n\t    oldwin->w_status_height = STATUS_HEIGHT;\n\t    oldwin_height -= STATUS_HEIGHT;\n\t}\n\tif (new_size == 0)\n\t    new_size = oldwin_height / 2;\n\tif (new_size > available - minheight - STATUS_HEIGHT)\n\t    new_size = available - minheight - STATUS_HEIGHT;\n\tif (new_size < wmh1)\n\t    new_size = wmh1;\n\n\t// if it doesn't fit in the current window, need win_equal()\n\tif (oldwin_height - new_size - STATUS_HEIGHT < p_wmh)\n\t    do_equal = TRUE;\n\n\t// We don't like to take lines for the new window from a\n\t// 'winfixheight' window.  Take them from a window above or below\n\t// instead, if possible.\n\tif (oldwin->w_p_wfh)\n\t{\n\t    // Set w_fraction now so that the cursor keeps the same relative\n\t    // vertical position using the old height.\n\t    set_fraction(oldwin);\n\t    did_set_fraction = TRUE;\n\n\t    win_setheight_win(oldwin->w_height + new_size + STATUS_HEIGHT,\n\t\t\t\t\t\t\t\t      oldwin);\n\t    oldwin_height = oldwin->w_height;\n\t    if (need_status)\n\t\toldwin_height -= STATUS_HEIGHT;\n\t}\n\n\t// Only make all windows the same height if one of them (except oldwin)\n\t// is higher than one of the split windows.\n\tif (!do_equal && p_ea && size == 0 && *p_ead != 'h'\n\t   && oldwin->w_frame->fr_parent != NULL)\n\t{\n\t    frp = oldwin->w_frame->fr_parent->fr_child;\n\t    while (frp != NULL)\n\t    {\n\t\tif (frp->fr_win != oldwin && frp->fr_win != NULL\n\t\t\t&& (frp->fr_win->w_height > new_size\n\t\t\t    || frp->fr_win->w_height > oldwin_height - new_size\n\t\t\t\t\t\t\t      - STATUS_HEIGHT))\n\t\t{\n\t\t    do_equal = TRUE;\n\t\t    break;\n\t\t}\n\t\tfrp = frp->fr_next;\n\t    }\n\t}\n    }\n\n    /*\n     * allocate new window structure and link it in the window list\n     */\n    if ((flags & WSP_TOP) == 0\n\t    && ((flags & WSP_BOT)\n\t\t|| (flags & WSP_BELOW)\n\t\t|| (!(flags & WSP_ABOVE)\n\t\t    && ( (flags & WSP_VERT) ? p_spr : p_sb))))\n    {\n\t// new window below/right of current one\n\tif (new_wp == NULL)\n\t    wp = win_alloc(oldwin, FALSE);\n\telse\n\t    win_append(oldwin, wp);\n    }\n    else\n    {\n\tif (new_wp == NULL)\n\t    wp = win_alloc(oldwin->w_prev, FALSE);\n\telse\n\t    win_append(oldwin->w_prev, wp);\n    }\n\n    if (new_wp == NULL)\n    {\n\tif (wp == NULL)\n\t    return FAIL;\n\n\tnew_frame(wp);\n\tif (wp->w_frame == NULL)\n\t{\n\t    win_free(wp, NULL);\n\t    return FAIL;\n\t}\n\n\t// make the contents of the new window the same as the current one\n\twin_init(wp, curwin, flags);\n    }\n\n    /*\n     * Reorganise the tree of frames to insert the new window.\n     */\n    if (flags & (WSP_TOP | WSP_BOT))\n    {\n\tif ((topframe->fr_layout == FR_COL && (flags & WSP_VERT) == 0)\n\t    || (topframe->fr_layout == FR_ROW && (flags & WSP_VERT) != 0))\n\t{\n\t    curfrp = topframe->fr_child;\n\t    if (flags & WSP_BOT)\n\t\twhile (curfrp->fr_next != NULL)\n\t\t    curfrp = curfrp->fr_next;\n\t}\n\telse\n\t    curfrp = topframe;\n\tbefore = (flags & WSP_TOP);\n    }\n    else\n    {\n\tcurfrp = oldwin->w_frame;\n\tif (flags & WSP_BELOW)\n\t    before = FALSE;\n\telse if (flags & WSP_ABOVE)\n\t    before = TRUE;\n\telse if (flags & WSP_VERT)\n\t    before = !p_spr;\n\telse\n\t    before = !p_sb;\n    }\n    if (curfrp->fr_parent == NULL || curfrp->fr_parent->fr_layout != layout)\n    {\n\t// Need to create a new frame in the tree to make a branch.\n\tfrp = ALLOC_CLEAR_ONE(frame_T);\n\t*frp = *curfrp;\n\tcurfrp->fr_layout = layout;\n\tfrp->fr_parent = curfrp;\n\tfrp->fr_next = NULL;\n\tfrp->fr_prev = NULL;\n\tcurfrp->fr_child = frp;\n\tcurfrp->fr_win = NULL;\n\tcurfrp = frp;\n\tif (frp->fr_win != NULL)\n\t    oldwin->w_frame = frp;\n\telse\n\t    FOR_ALL_FRAMES(frp, frp->fr_child)\n\t\tfrp->fr_parent = curfrp;\n    }\n\n    if (new_wp == NULL)\n\tfrp = wp->w_frame;\n    else\n\tfrp = new_wp->w_frame;\n    frp->fr_parent = curfrp->fr_parent;\n\n    // Insert the new frame at the right place in the frame list.\n    if (before)\n\tframe_insert(curfrp, frp);\n    else\n\tframe_append(curfrp, frp);\n\n    // Set w_fraction now so that the cursor keeps the same relative\n    // vertical position.\n    if (!did_set_fraction)\n\tset_fraction(oldwin);\n    wp->w_fraction = oldwin->w_fraction;\n\n    if (flags & WSP_VERT)\n    {\n\twp->w_p_scr = curwin->w_p_scr;\n\n\tif (need_status)\n\t{\n\t    win_new_height(oldwin, oldwin->w_height - 1);\n\t    oldwin->w_status_height = need_status;\n\t}\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    // set height and row of new window to full height\n\t    wp->w_winrow = tabline_height();\n\t    win_new_height(wp, curfrp->fr_height - (p_ls > 0)\n\t\t\t\t\t\t\t  - WINBAR_HEIGHT(wp));\n\t    wp->w_status_height = (p_ls > 0);\n\t}\n\telse\n\t{\n\t    // height and row of new window is same as current window\n\t    wp->w_winrow = oldwin->w_winrow;\n\t    win_new_height(wp, VISIBLE_HEIGHT(oldwin));\n\t    wp->w_status_height = oldwin->w_status_height;\n\t}\n\tfrp->fr_height = curfrp->fr_height;\n\n\t// \"new_size\" of the current window goes to the new window, use\n\t// one column for the vertical separator\n\twin_new_width(wp, new_size);\n\tif (before)\n\t    wp->w_vsep_width = 1;\n\telse\n\t{\n\t    wp->w_vsep_width = oldwin->w_vsep_width;\n\t    oldwin->w_vsep_width = 1;\n\t}\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    if (flags & WSP_BOT)\n\t\tframe_add_vsep(curfrp);\n\t    // Set width of neighbor frame\n\t    frame_new_width(curfrp, curfrp->fr_width\n\t\t     - (new_size + ((flags & WSP_TOP) != 0)), flags & WSP_TOP,\n\t\t\t\t\t\t\t\t       FALSE);\n\t}\n\telse\n\t    win_new_width(oldwin, oldwin->w_width - (new_size + 1));\n\tif (before)\t// new window left of current one\n\t{\n\t    wp->w_wincol = oldwin->w_wincol;\n\t    oldwin->w_wincol += new_size + 1;\n\t}\n\telse\t\t// new window right of current one\n\t    wp->w_wincol = oldwin->w_wincol + oldwin->w_width + 1;\n\tframe_fix_width(oldwin);\n\tframe_fix_width(wp);\n    }\n    else\n    {\n\t// width and column of new window is same as current window\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    wp->w_wincol = 0;\n\t    win_new_width(wp, Columns);\n\t    wp->w_vsep_width = 0;\n\t}\n\telse\n\t{\n\t    wp->w_wincol = oldwin->w_wincol;\n\t    win_new_width(wp, oldwin->w_width);\n\t    wp->w_vsep_width = oldwin->w_vsep_width;\n\t}\n\tfrp->fr_width = curfrp->fr_width;\n\n\t// \"new_size\" of the current window goes to the new window, use\n\t// one row for the status line\n\twin_new_height(wp, new_size);\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    int new_fr_height = curfrp->fr_height - new_size\n\t\t\t\t\t\t\t  + WINBAR_HEIGHT(wp) ;\n\n\t    if (!((flags & WSP_BOT) && p_ls == 0))\n\t\tnew_fr_height -= STATUS_HEIGHT;\n\t    frame_new_height(curfrp, new_fr_height, flags & WSP_TOP, FALSE);\n\t}\n\telse\n\t    win_new_height(oldwin, oldwin_height - (new_size + STATUS_HEIGHT));\n\tif (before)\t// new window above current one\n\t{\n\t    wp->w_winrow = oldwin->w_winrow;\n\t    wp->w_status_height = STATUS_HEIGHT;\n\t    oldwin->w_winrow += wp->w_height + STATUS_HEIGHT;\n\t}\n\telse\t\t// new window below current one\n\t{\n\t    wp->w_winrow = oldwin->w_winrow + VISIBLE_HEIGHT(oldwin)\n\t\t\t\t\t\t\t       + STATUS_HEIGHT;\n\t    wp->w_status_height = oldwin->w_status_height;\n\t    if (!(flags & WSP_BOT))\n\t\toldwin->w_status_height = STATUS_HEIGHT;\n\t}\n\tif (flags & WSP_BOT)\n\t    frame_add_statusline(curfrp);\n\tframe_fix_height(wp);\n\tframe_fix_height(oldwin);\n    }\n\n    if (flags & (WSP_TOP | WSP_BOT))\n\t(void)win_comp_pos();\n\n     // Both windows need redrawing.  Update all status lines, in case they\n     // show something related to the window count or position.\n    redraw_win_later(wp, UPD_NOT_VALID);\n    redraw_win_later(oldwin, UPD_NOT_VALID);\n    status_redraw_all();\n\n    if (need_status)\n    {\n\tmsg_row = Rows - 1;\n\tmsg_col = sc_col;\n\tmsg_clr_eos_force();\t// Old command/ruler may still be there\n\tcomp_col();\n\tmsg_row = Rows - 1;\n\tmsg_col = 0;\t// put position back at start of line\n    }\n\n    /*\n     * equalize the window sizes.\n     */\n    if (do_equal || dir != 0)\n\twin_equal(wp, TRUE,\n\t\t(flags & WSP_VERT) ? (dir == 'v' ? 'b' : 'h')\n\t\t: dir == 'h' ? 'b' : 'v');\n\n    // Don't change the window height/width to 'winheight' / 'winwidth' if a\n    // size was given.\n    if (flags & WSP_VERT)\n    {\n\ti = p_wiw;\n\tif (size != 0)\n\t    p_wiw = size;\n\n# ifdef FEAT_GUI\n\t// When 'guioptions' includes 'L' or 'R' may have to add scrollbars.\n\tif (gui.in_use)\n\t    gui_init_which_components(NULL);\n# endif\n    }\n    else\n    {\n\ti = p_wh;\n\tif (size != 0)\n\t    p_wh = size;\n    }\n\n    /*\n     * make the new window the current window\n     */\n    (void)win_enter_ext(wp, WEE_TRIGGER_NEW_AUTOCMDS\n\t\t    | WEE_TRIGGER_ENTER_AUTOCMDS | WEE_TRIGGER_LEAVE_AUTOCMDS);\n    if (flags & WSP_VERT)\n\tp_wiw = i;\n    else\n\tp_wh = i;\n\n    return OK;\n}\n\n// ENC_LATIN9 from src/vim.h:\n#define ENC_LATIN9\t0x400\t    // Latin9 /* <=== src/vim.h:2389:2389:ENC_LATIN9:0 */ \n\n// FDO_SEARCH from src/option.h:\n# define FDO_SEARCH\t\t0x040 /* <=== src/option.h:583:583:FDO_SEARCH:0 */ \n\n// TAG_INS_COMP from src/vim.h:\n<empty>\n\n// dict_alloc_id from src/dict.c:\ndict_T *\ndict_alloc_id(alloc_id_T id UNUSED)\n{\n#ifdef FEAT_EVAL\n    if (alloc_fail_id == id && alloc_does_fail(sizeof(list_T)))\n\treturn NULL;\n#endif\n    return (dict_alloc());\n}\n"
  },
  {
    "repository": "squirrel",
    "cve_id": "CVE-2021-41556",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "23a0620658714b996d20da3d4dd1a0dcf9b0bd98",
    "short_hash": "23a06206",
    "vulnerableMethods_before": [
      {
        "filename": "sqclass.cpp",
        "method_name": "vulnerable_function",
        "raw_code": "bool SQClass::NewSlot(SQSharedState *ss,const SQObjectPtr &key,const SQObjectPtr &val,bool bstatic)\n{\n    SQObjectPtr temp;\n    bool belongs_to_static_table = sq_type(val) == OT_CLOSURE || sq_type(val) == OT_NATIVECLOSURE || bstatic;\n    if(_locked && !belongs_to_static_table)\n        return false; //the class already has an instance so cannot be modified\n    if(_members->Get(key,temp) && _isfield(temp)) //overrides the default value\n    {\n        _defaultvalues[_member_idx(temp)].val = val;\n        return true;\n    }\n    if(belongs_to_static_table) {\n        SQInteger mmidx;\n        if((sq_type(val) == OT_CLOSURE || sq_type(val) == OT_NATIVECLOSURE) &&\n            (mmidx = ss->GetMetaMethodIdxByName(key)) != -1) {\n            _metamethods[mmidx] = val;\n        }\n        else {\n            SQObjectPtr theval = val;\n            if(_base && sq_type(val) == OT_CLOSURE) {\n                theval = _closure(val)->Clone();\n                _closure(theval)->_base = _base;\n                __ObjAddRef(_base); //ref for the closure\n            }\n            if(sq_type(temp) == OT_NULL) {\n                bool isconstructor;\n                SQVM::IsEqual(ss->_constructoridx, key, isconstructor);\n                if(isconstructor) {\n                    _constructoridx = (SQInteger)_methods.size();\n                }\n                SQClassMember m;\n                m.val = theval;\n                _members->NewSlot(key,SQObjectPtr(_make_method_idx(_methods.size())));\n                _methods.push_back(m);\n            }\n            else {\n                _methods[_member_idx(temp)].val = theval;\n            }\n        }\n        return true;\n    }\n    SQClassMember m;\n    m.val = val;\n    _members->NewSlot(key,SQObjectPtr(_make_field_idx(_defaultvalues.size())));\n    _defaultvalues.push_back(m);\n    return true;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "sqclass.cpp",
        "method_name": "fixed_function",
        "raw_code": "bool SQClass::NewSlot(SQSharedState *ss,const SQObjectPtr &key,const SQObjectPtr &val,bool bstatic)\n{\n    SQObjectPtr temp;\n    bool belongs_to_static_table = sq_type(val) == OT_CLOSURE || sq_type(val) == OT_NATIVECLOSURE || bstatic;\n    if(_locked && !belongs_to_static_table)\n        return false; //the class already has an instance so cannot be modified\n    if(_members->Get(key,temp) && _isfield(temp)) //overrides the default value\n    {\n        _defaultvalues[_member_idx(temp)].val = val;\n        return true;\n    }\n\tif (_members->CountUsed() >= MEMBER_MAX_COUNT) {\n\t\treturn false;\n\t}\n    if(belongs_to_static_table) {\n        SQInteger mmidx;\n        if((sq_type(val) == OT_CLOSURE || sq_type(val) == OT_NATIVECLOSURE) &&\n            (mmidx = ss->GetMetaMethodIdxByName(key)) != -1) {\n            _metamethods[mmidx] = val;\n        }\n        else {\n            SQObjectPtr theval = val;\n            if(_base && sq_type(val) == OT_CLOSURE) {\n                theval = _closure(val)->Clone();\n                _closure(theval)->_base = _base;\n                __ObjAddRef(_base); //ref for the closure\n            }\n            if(sq_type(temp) == OT_NULL) {\n                bool isconstructor;\n                SQVM::IsEqual(ss->_constructoridx, key, isconstructor);\n                if(isconstructor) {\n                    _constructoridx = (SQInteger)_methods.size();\n                }\n                SQClassMember m;\n                m.val = theval;\n                _members->NewSlot(key,SQObjectPtr(_make_method_idx(_methods.size())));\n                _methods.push_back(m);\n            }\n            else {\n                _methods[_member_idx(temp)].val = theval;\n            }\n        }\n        return true;\n    }\n    SQClassMember m;\n    m.val = val;\n    _members->NewSlot(key,SQObjectPtr(_make_field_idx(_defaultvalues.size())));\n    _defaultvalues.push_back(m);\n    return true;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"sqvm.h\"\n#include \"sqclosure.h\"\n#include \"sqclass.h\"\n#include \"sqtable.h\"\n#include \"sqfuncproto.h\"\n#include \"sqpcheader.h\"\n\n// Type Definitions:\n// SQClass:\nSQClass.SQClass:ANY(SQSharedState*,SQClass*)\n\n// SQTable:\nSQTable.SQTable:ANY(SQSharedState*,SQInteger)\n\n// SQObjectPtr:\nstruct SQObjectPtr : public SQObject\n{\n    SQObjectPtr()\n    {\n        SQ_OBJECT_RAWINIT()\n        _type=OT_NULL;\n        _unVal.pUserPointer=NULL;\n    }\n    SQObjectPtr(const SQObjectPtr &o)\n    {\n        _type = o._type;\n        _unVal = o._unVal;\n        __AddRef(_type,_unVal);\n    }\n    SQObjectPtr(const SQObject &o)\n    {\n        _type = o._type;\n        _unVal = o._unVal;\n        __AddRef(_type,_unVal);\n    }\n    _REF_TYPE_DECL(OT_TABLE,SQTable,pTable)\n    _REF_TYPE_DECL(OT_CLASS,SQClass,pClass)\n    _REF_TYPE_DECL(OT_INSTANCE,SQInstance,pInstance)\n    _REF_TYPE_DECL(OT_ARRAY,SQArray,pArray)\n    _REF_TYPE_DECL(OT_CLOSURE,SQClosure,pClosure)\n    _REF_TYPE_DECL(OT_NATIVECLOSURE,SQNativeClosure,pNativeClosure)\n    _REF_TYPE_DECL(OT_OUTER,SQOuter,pOuter)\n    _REF_TYPE_DECL(OT_GENERATOR,SQGenerator,pGenerator)\n    _REF_TYPE_DECL(OT_STRING,SQString,pString)\n    _REF_TYPE_DECL(OT_USERDATA,SQUserData,pUserData)\n    _REF_TYPE_DECL(OT_WEAKREF,SQWeakRef,pWeakRef)\n    _REF_TYPE_DECL(OT_THR...\n\n// sqvector:\nclass sqvector\n{\npublic:\n    sqvector()\n    {\n        _vals = NULL;\n        _size = 0;\n        _allocated = 0;\n    }\n    sqvector(const sqvector<T>& v)\n    {\n        copy(v);\n    }\n    void copy(const sqvector<T>& v)\n    {\n        if(_size) {\n            resize(0); //destroys all previous stuff\n        }\n        //resize(v._size);\n        if(v._size > _allocated) {\n            _realloc(v._size);\n        }\n        for(SQUnsignedInteger i = 0; i < v._size; i++) {\n            new ((void *)&_vals[i]) T(v._vals[i]);\n        }\n        _size = v._size;\n    }\n    ~sqvector()\n    {\n        if(_allocated) {\n            for(SQUnsignedInteger i = 0; i < _size; i++)\n                _vals[i].~T();\n            SQ_FREE(_vals, (_allocated * sizeof(T)));\n        }\n    }\n    void reserve(SQUnsignedInteger newsize) { _realloc(newsize); }\n    void resize(SQUnsignedInteger newsize, const T& fill = T())\n    {\n        if(newsize > _allocated)\n            _realloc(newsize);\n        if(newsize > _size) {\n   ...\n\n// SQTable:\nstruct SQTable : public SQDelegable\n{\nprivate:\n    struct _HashNode\n    {\n        _HashNode() { next = NULL; }\n        SQObjectPtr val;\n        SQObjectPtr key;\n        _HashNode *next;\n    };\n    _HashNode *_firstfree;\n    _HashNode *_nodes;\n    SQInteger _numofnodes;\n    SQInteger _usednodes;\n\n///////////////////////////\n    void AllocNodes(SQInteger nSize);\n    void Rehash(bool force);\n    SQTable(SQSharedState *ss, SQInteger nInitialSize);\n    void _ClearNodes();\npublic:\n    static SQTable* Create(SQSharedState *ss,SQInteger nInitialSize)\n    {\n        SQTable *newtable = (SQTable*)SQ_MALLOC(sizeof(SQTable));\n        new (newtable) SQTable(ss, nInitialSize);\n        newtable->_delegate = NULL;\n        return newtable;\n    }\n    void Finalize();\n    SQTable *Clone();\n    ~SQTable()\n    {\n        SetDelegate(NULL);\n        REMOVE_FROM_CHAIN(&_sharedstate->_gc_chain, this);\n        for (SQInteger i = 0; i < _numofnodes; i++) _nodes[i].~_HashNode();\n        SQ_FREE(_nodes, _numofnod...\n\n// SQClass:\nstruct SQClass : public CHAINABLE_OBJ\n{\n    SQClass(SQSharedState *ss,SQClass *base);\npublic:\n    static SQClass* Create(SQSharedState *ss,SQClass *base) {\n        SQClass *newclass = (SQClass *)SQ_MALLOC(sizeof(SQClass));\n        new (newclass) SQClass(ss, base);\n        return newclass;\n    }\n    ~SQClass();\n    bool NewSlot(SQSharedState *ss, const SQObjectPtr &key,const SQObjectPtr &val,bool bstatic);\n    bool Get(const SQObjectPtr &key,SQObjectPtr &val) {\n        if(_members->Get(key,val)) {\n            if(_isfield(val)) {\n                SQObjectPtr &o = _defaultvalues[_member_idx(val)].val;\n                val = _realval(o);\n            }\n            else {\n                val = _methods[_member_idx(val)].val;\n            }\n            return true;\n        }\n        return false;\n    }\n    bool GetConstructor(SQObjectPtr &ctor)\n    {\n        if(_constructoridx != -1) {\n            ctor = _methods[_constructoridx].val;\n            return true;\n        }\n        return false;\n ...\n\n// SQClassMember:\nstruct SQClassMember {\n    SQObjectPtr val;\n    SQObjectPtr attrs;\n    void Null() {\n        val.Null();\n        attrs.Null();\n    }\n}\n\n// SQSharedState:\nstruct SQSharedState\n{\n    SQSharedState();\n    ~SQSharedState();\n    void Init();\npublic:\n    SQChar* GetScratchPad(SQInteger size);\n    SQInteger GetMetaMethodIdxByName(const SQObjectPtr &name);\n#ifndef NO_GARBAGE_COLLECTOR\n    SQInteger CollectGarbage(SQVM *vm);\n    void RunMark(SQVM *vm,SQCollectable **tchain);\n    SQInteger ResurrectUnreachable(SQVM *vm);\n    static void MarkObject(SQObjectPtr &o,SQCollectable **chain);\n#endif\n    SQObjectPtrVec *_metamethods;\n    SQObjectPtr _metamethodsmap;\n    SQObjectPtrVec *_systemstrings;\n    SQObjectPtrVec *_types;\n    SQStringTable *_stringtable;\n    RefTable _refs_table;\n    SQObjectPtr _registry;\n    SQObjectPtr _consts;\n    SQObjectPtr _constructoridx;\n#ifndef NO_GARBAGE_COLLECTOR\n    SQCollectable *_gc_chain;\n#endif\n    SQObjectPtr _root_vm;\n    SQObjectPtr _table_default_delegate;\n    static const SQRegFunction _table_default_delegate_funcz[];\n    SQObjectPtr _array_default_delegate;\n    static const SQRegFunction _array_default_de...\n\n// SQInteger:\ntypedef long long SQInteger;\n\n// Called Methods (top 10):\n// _closure from squirrel/sqobject.h:\n<empty>\n\n// _make_method_idx from squirrel/sqclass.h:\n<empty>\n\n// _member_idx from squirrel/sqclass.h:\n<empty>\n\n// _isfield from squirrel/sqclass.h:\n<empty>\n\n// IsEqual from squirrel/sqvm.cpp:\nbool SQVM::IsEqual(const SQObjectPtr &o1,const SQObjectPtr &o2,bool &res)\n{\n\tSQObjectType t1 = sq_type(o1), t2 = sq_type(o2);\n    if(t1 == t2) {\n\t\tif (t1 == OT_FLOAT) {\n\t\t\tres = (_float(o1) == _float(o2));\n\t\t}\n\t\telse {\n\t\t\tres = (_rawval(o1) == _rawval(o2));\n\t\t}\n    }\n    else {\n        if(sq_isnumeric(o1) && sq_isnumeric(o2)) {\n            res = (tofloat(o1) == tofloat(o2));\n        }\n        else {\n            res = false;\n        }\n    }\n    return true;\n}\n\n// MEMBER_MAX_COUNT from squirrel/sqclass.h:\n<empty>\n\n// GetMetaMethodIdxByName from squirrel/sqstate.h:\nSQInteger GetMetaMethodIdxByName(const SQObjectPtr &name);\n\n// NewSlot from squirrel/sqtable.cpp:\nbool SQTable::NewSlot(const SQObjectPtr &key,const SQObjectPtr &val)\n{\n    assert(sq_type(key) != OT_NULL);\n    SQHash h = HashObj(key) & (_numofnodes - 1);\n    _HashNode *n = _Get(key, h);\n    if (n) {\n        n->val = val;\n        return false;\n    }\n    _HashNode *mp = &_nodes[h];\n    n = mp;\n\n\n    //key not found I'll insert it\n    //main pos is not free\n\n    if(sq_type(mp->key) != OT_NULL) {\n        n = _firstfree;  /* get a free place */\n        SQHash mph = HashObj(mp->key) & (_numofnodes - 1);\n        _HashNode *othern;  /* main position of colliding node */\n\n        if (mp > n && (othern = &_nodes[mph]) != mp){\n            /* yes; move colliding node into free position */\n            while (othern->next != mp){\n                assert(othern->next != NULL);\n                othern = othern->next;  /* find previous */\n            }\n            othern->next = n;  /* redo the chain with `n' in place of `mp' */\n            n->key = mp->key;\n            n->val = mp->val;/* copy co...\n\n// _make_field_idx from squirrel/sqclass.h:\n<empty>\n\n// Get from squirrel/sqtable.cpp:\nbool SQTable::Get(const SQObjectPtr &key,SQObjectPtr &val)\n{\n    if(sq_type(key) == OT_NULL)\n        return false;\n    _HashNode *n = _Get(key, HashObj(key) & (_numofnodes - 1));\n    if (n) {\n        val = _realval(n->val);\n        return true;\n    }\n    return false;\n}\n"
  },
  {
    "repository": "JUCE",
    "cve_id": "CVE-2021-23521",
    "cwe_list": [
      "CWE-59"
    ],
    "commit_hash": "2e874e80cba0152201aff6a4d0dc407997d10a7f",
    "short_hash": "2e874e80",
    "vulnerableMethods_before": [
      {
        "filename": "None",
        "method_name": "vulnerable_function",
        "raw_code": "Result ZipFile::uncompressEntry (int index, const File& targetDirectory, bool shouldOverwriteFiles)\r\n{\r\n    auto* zei = entries.getUnchecked (index);\r\n\r\n   #if JUCE_WINDOWS\r\n    auto entryPath = zei->entry.filename;\r\n   #else\r\n    auto entryPath = zei->entry.filename.replaceCharacter ('\\\\', '/');\r\n   #endif\r\n\r\n    if (entryPath.isEmpty())\r\n        return Result::ok();\r\n\r\n    auto targetFile = targetDirectory.getChildFile (entryPath);\r\n\r\n    if (entryPath.endsWithChar ('/') || entryPath.endsWithChar ('\\\\'))\r\n        return targetFile.createDirectory(); // (entry is a directory, not a file)\r\n\r\n    std::unique_ptr<InputStream> in (createStreamForEntry (index));\r\n\r\n    if (in == nullptr)\r\n        return Result::fail (\"Failed to open the zip file for reading\");\r\n\r\n    if (targetFile.exists())\r\n    {\r\n        if (! shouldOverwriteFiles)\r\n            return Result::ok();\r\n\r\n        if (! targetFile.deleteFile())\r\n            return Result::fail (\"Failed to write to target file: \" + targetFile.getFullPathName());\r\n    }\r\n\r\n    if (! targetFile.getParentDirectory().createDirectory())\r\n        return Result::fail (\"Failed to create target folder: \" + targetFile.getParentDirectory().getFullPathName());\r\n\r\n    if (zei->entry.isSymbolicLink)\r\n    {\r\n        String originalFilePath (in->readEntireStreamAsString()\r\n                                    .replaceCharacter (L'/', File::getSeparatorChar()));\r\n\r\n        if (! File::createSymbolicLink (targetFile, originalFilePath, true))\r\n            return Result::fail (\"Failed to create symbolic link: \" + originalFilePath);\r\n    }\r\n    else\r\n    {\r\n        FileOutputStream out (targetFile);\r\n\r\n        if (out.failedToOpen())\r\n            return Result::fail (\"Failed to write to target file: \" + targetFile.getFullPathName());\r\n\r\n        out << *in;\r\n    }\r\n\r\n    targetFile.setCreationTime (zei->entry.fileTime);\r\n    targetFile.setLastModificationTime (zei->entry.fileTime);\r\n    targetFile.setLastAccessTime (zei->entry.fileTime);\r\n\r\n    return Result::ok();\r\n}\r",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "None",
        "method_name": "fixed_function",
        "raw_code": "Result ZipFile::uncompressEntry (int index, const File& targetDirectory, OverwriteFiles overwriteFiles, FollowSymlinks followSymlinks)\r\n{\r\n    auto* zei = entries.getUnchecked (index);\r\n\r\n   #if JUCE_WINDOWS\r\n    auto entryPath = zei->entry.filename;\r\n   #else\r\n    auto entryPath = zei->entry.filename.replaceCharacter ('\\\\', '/');\r\n   #endif\r\n\r\n    if (entryPath.isEmpty())\r\n        return Result::ok();\r\n\r\n    auto targetFile = targetDirectory.getChildFile (entryPath);\r\n\r\n    if (! targetFile.isAChildOf (targetDirectory))\r\n        return Result::fail (\"Entry \" + entryPath + \" is outside the target directory\");\r\n\r\n    if (entryPath.endsWithChar ('/') || entryPath.endsWithChar ('\\\\'))\r\n        return targetFile.createDirectory(); // (entry is a directory, not a file)\r\n\r\n    std::unique_ptr<InputStream> in (createStreamForEntry (index));\r\n\r\n    if (in == nullptr)\r\n        return Result::fail (\"Failed to open the zip file for reading\");\r\n\r\n    if (targetFile.exists())\r\n    {\r\n        if (overwriteFiles == OverwriteFiles::no)\r\n            return Result::ok();\r\n\r\n        if (! targetFile.deleteFile())\r\n            return Result::fail (\"Failed to write to target file: \" + targetFile.getFullPathName());\r\n    }\r\n\r\n    if (followSymlinks == FollowSymlinks::no && hasSymbolicPart (targetDirectory, targetFile.getParentDirectory()))\r\n        return Result::fail (\"Parent directory leads through symlink for target file: \" + targetFile.getFullPathName());\r\n\r\n    if (! targetFile.getParentDirectory().createDirectory())\r\n        return Result::fail (\"Failed to create target folder: \" + targetFile.getParentDirectory().getFullPathName());\r\n\r\n    if (zei->entry.isSymbolicLink)\r\n    {\r\n        String originalFilePath (in->readEntireStreamAsString()\r\n                                    .replaceCharacter (L'/', File::getSeparatorChar()));\r\n\r\n        if (! File::createSymbolicLink (targetFile, originalFilePath, true))\r\n            return Result::fail (\"Failed to create symbolic link: \" + originalFilePath);\r\n    }\r\n    else\r\n    {\r\n        FileOutputStream out (targetFile);\r\n\r\n        if (out.failedToOpen())\r\n            return Result::fail (\"Failed to write to target file: \" + targetFile.getFullPathName());\r\n\r\n        out << *in;\r\n    }\r\n\r\n    targetFile.setCreationTime (zei->entry.fileTime);\r\n    targetFile.setLastModificationTime (zei->entry.fileTime);\r\n    targetFile.setLastAccessTime (zei->entry.fileTime);\r\n\r\n    return Result::ok();\r\n}\r",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "linux",
    "cve_id": "CVE-2020-16166",
    "cwe_list": [
      "CWE-200"
    ],
    "commit_hash": "f227e3ec3b5cad859ad15666874405e8c1bbc1d4",
    "short_hash": "f227e3ec",
    "vulnerableMethods_before": [
      {
        "filename": "timer.c",
        "method_name": "vulnerable_function",
        "raw_code": "void update_process_times(int user_tick)\n{\n\tstruct task_struct *p = current;\n\n\t/* Note: this timer irq context must be accounted for as well. */\n\taccount_process_tick(p, user_tick);\n\trun_local_timers();\n\trcu_sched_clock_irq(user_tick);\n#ifdef CONFIG_IRQ_WORK\n\tif (in_irq())\n\t\tirq_work_tick();\n#endif\n\tscheduler_tick();\n\tif (IS_ENABLED(CONFIG_POSIX_TIMERS))\n\t\trun_posix_cpu_timers();\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "timer.c",
        "method_name": "fixed_function",
        "raw_code": "void update_process_times(int user_tick)\n{\n\tstruct task_struct *p = current;\n\n\t/* Note: this timer irq context must be accounted for as well. */\n\taccount_process_tick(p, user_tick);\n\trun_local_timers();\n\trcu_sched_clock_irq(user_tick);\n#ifdef CONFIG_IRQ_WORK\n\tif (in_irq())\n\t\tirq_work_tick();\n#endif\n\tscheduler_tick();\n\tif (IS_ENABLED(CONFIG_POSIX_TIMERS))\n\t\trun_posix_cpu_timers();\n\n\t/* The current CPU might make use of net randoms without receiving IRQs\n\t * to renew them often enough. Let's update the net_rand_state from a\n\t * non-constant value that's not affine to the number of calls to make\n\t * sure it's updated when there's some activity (we don't care in idle).\n\t */\n\tthis_cpu_add(net_rand_state.s1, rol32(jiffies, 24) + user_tick);\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <asm/io.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/thread_info.h>\n#include <linux/pid_namespace.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <trace/events/timer.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/notifier.h>\n#include <linux/interrupt.h>\n#include <linux/compat.h>\n#include <asm/div64.h>\n#include <linux/cpu.h>\n#include <asm/unistd.h>\n#include <linux/jiffies.h>\n#include <linux/random.h>\n#include <linux/tick.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/sched/sysctl.h>\n#include <linux/mm.h>\n#include <asm/timex.h>\n#include \"tick-internal.h\"\n#include <linux/irq_work.h>\n#include <linux/percpu.h>\n#include <linux/kallsyms.h>\n#include <linux/delay.h>\n\n// Type Definitions:\n// task_struct:\nstruct task_struct\n"
  },
  {
    "repository": "php-src",
    "cve_id": "CVE-2016-7130",
    "cwe_list": [
      "CWE-476"
    ],
    "commit_hash": "698a691724c0a949295991e5df091ce16f899e02",
    "short_hash": "698a6917",
    "vulnerableMethods_before": [
      {
        "filename": "wddx.c",
        "method_name": "vulnerable_function",
        "raw_code": " */\nstatic void php_wddx_pop_element(void *user_data, const XML_Char *name)\n{\n\tst_entry \t\t\t*ent1, *ent2;\n\twddx_stack \t\t\t*stack = (wddx_stack *)user_data;\n\tHashTable \t\t\t*target_hash;\n\tzend_class_entry \t**pce;\n\tzval\t\t\t\t*obj;\n\tzval\t\t\t\t*tmp;\n\tTSRMLS_FETCH();\n\n/* OBJECTS_FIXME */\n\tif (stack->top == 0) {\n\t\treturn;\n\t}\n\n\tif (!strcmp(name, EL_STRING) || !strcmp(name, EL_NUMBER) ||\n\t\t!strcmp(name, EL_BOOLEAN) || !strcmp(name, EL_NULL) ||\n\t  \t!strcmp(name, EL_ARRAY) || !strcmp(name, EL_STRUCT) ||\n\t\t!strcmp(name, EL_RECORDSET) || !strcmp(name, EL_BINARY) ||\n\t\t!strcmp(name, EL_DATETIME)) {\n\t\twddx_stack_top(stack, (void**)&ent1);\n\n\t\tif (!ent1->data) {\n\t\t\tif (stack->top > 1) {\n\t\t\t\tstack->top--;\n\t\t\t} else {\n\t\t\t\tstack->done = 1;\n\t\t\t}\n\t\t\tefree(ent1);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!strcmp(name, EL_BINARY)) {\n\t\t\tint new_len=0;\n\t\t\tunsigned char *new_str;\n\n\t\t\tnew_str = php_base64_decode(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data), &new_len);\n\t\t\tSTR_FREE(Z_STRVAL_P(ent1->data));\n\t\t\tZ_STRVAL_P(ent1->data) = new_str;\n\t\t\tZ_STRLEN_P(ent1->data) = new_len;\n\t\t}\n\n\t\t/* Call __wakeup() method on the object. */\n\t\tif (Z_TYPE_P(ent1->data) == IS_OBJECT) {\n\t\t\tzval *fname, *retval = NULL;\n\n\t\t\tMAKE_STD_ZVAL(fname);\n\t\t\tZVAL_STRING(fname, \"__wakeup\", 1);\n\n\t\t\tcall_user_function_ex(NULL, &ent1->data, fname, &retval, 0, 0, 0, NULL TSRMLS_CC);\n\n\t\t\tzval_dtor(fname);\n\t\t\tFREE_ZVAL(fname);\n\t\t\tif (retval) {\n\t\t\t\tzval_ptr_dtor(&retval);\n\t\t\t}\n\t\t}\n\n\t\tif (stack->top > 1) {\n\t\t\tstack->top--;\n\t\t\twddx_stack_top(stack, (void**)&ent2);\n\n\t\t\t/* if non-existent field */\n\t\t\tif (ent2->type == ST_FIELD && ent2->data == NULL) {\n\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\tefree(ent1);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (Z_TYPE_P(ent2->data) == IS_ARRAY || Z_TYPE_P(ent2->data) == IS_OBJECT) {\n\t\t\t\ttarget_hash = HASH_OF(ent2->data);\n\n\t\t\t\tif (ent1->varname) {\n\t\t\t\t\tif (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) &&\n\t\t\t\t\t\tZ_TYPE_P(ent1->data) == IS_STRING && Z_STRLEN_P(ent1->data) &&\n\t\t\t\t\t\tent2->type == ST_STRUCT && Z_TYPE_P(ent2->data) == IS_ARRAY) {\n\t\t\t\t\t\tzend_bool incomplete_class = 0;\n\n\t\t\t\t\t\tzend_str_tolower(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));\n\t\t\t\t\t\tif (zend_hash_find(EG(class_table), Z_STRVAL_P(ent1->data),\n\t\t\t\t\t\t\t\t\t\t   Z_STRLEN_P(ent1->data)+1, (void **) &pce)==FAILURE) {\n\t\t\t\t\t\t\tincomplete_class = 1;\n\t\t\t\t\t\t\tpce = &PHP_IC_ENTRY;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Initialize target object */\n\t\t\t\t\t\tMAKE_STD_ZVAL(obj);\n\t\t\t\t\t\tobject_init_ex(obj, *pce);\n\n\t\t\t\t\t\t/* Merge current hashtable with object's default properties */\n\t\t\t\t\t\tzend_hash_merge(Z_OBJPROP_P(obj),\n\t\t\t\t\t\t\t\t\t\tZ_ARRVAL_P(ent2->data),\n\t\t\t\t\t\t\t\t\t\t(void (*)(void *)) zval_add_ref,\n\t\t\t\t\t\t\t\t\t\t(void *) &tmp, sizeof(zval *), 0);\n\n\t\t\t\t\t\tif (incomplete_class) {\n\t\t\t\t\t\t\tphp_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Clean up old array entry */\n\t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n\n\t\t\t\t\t\t/* Set stack entry to point to the newly created object */\n\t\t\t\t\t\tent2->data = obj;\n\n\t\t\t\t\t\t/* Clean up class name var entry */\n\t\t\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\t\t} else if (Z_TYPE_P(ent2->data) == IS_OBJECT) {\n\t\t\t\t\t\tzend_class_entry *old_scope = EG(scope);\n\n\t\t\t\t\t\tEG(scope) = Z_OBJCE_P(ent2->data);\n\t\t\t\t\t\tZ_DELREF_P(ent1->data);\n\t\t\t\t\t\tadd_property_zval(ent2->data, ent1->varname, ent1->data);\n\t\t\t\t\t\tEG(scope) = old_scope;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tzend_symtable_update(target_hash, ent1->varname, strlen(ent1->varname)+1, &ent1->data, sizeof(zval *), NULL);\n\t\t\t\t\t}\n\t\t\t\t\tefree(ent1->varname);\n\t\t\t\t} else\t{\n\t\t\t\t\tzend_hash_next_index_insert(target_hash, &ent1->data, sizeof(zval *), NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tefree(ent1);\n\t\t} else {\n\t\t\tstack->done = 1;\n\t\t}\n\t} else if (!strcmp(name, EL_VAR) && stack->varname) {\n\t\tefree(stack->varname);\n\t\tstack->varname = NULL;\n\t} else if (!strcmp(name, EL_FIELD)) {\n\t\tst_entry *ent;\n\t\twddx_stack_top(stack, (void **)&ent);\n\t\tefree(ent);\n\t\tstack->top--;\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "wddx.c",
        "method_name": "fixed_function",
        "raw_code": " */\nstatic void php_wddx_pop_element(void *user_data, const XML_Char *name)\n{\n\tst_entry \t\t\t*ent1, *ent2;\n\twddx_stack \t\t\t*stack = (wddx_stack *)user_data;\n\tHashTable \t\t\t*target_hash;\n\tzend_class_entry \t**pce;\n\tzval\t\t\t\t*obj;\n\tzval\t\t\t\t*tmp;\n\tTSRMLS_FETCH();\n\n/* OBJECTS_FIXME */\n\tif (stack->top == 0) {\n\t\treturn;\n\t}\n\n\tif (!strcmp(name, EL_STRING) || !strcmp(name, EL_NUMBER) ||\n\t\t!strcmp(name, EL_BOOLEAN) || !strcmp(name, EL_NULL) ||\n\t  \t!strcmp(name, EL_ARRAY) || !strcmp(name, EL_STRUCT) ||\n\t\t!strcmp(name, EL_RECORDSET) || !strcmp(name, EL_BINARY) ||\n\t\t!strcmp(name, EL_DATETIME)) {\n\t\twddx_stack_top(stack, (void**)&ent1);\n\n\t\tif (!ent1->data) {\n\t\t\tif (stack->top > 1) {\n\t\t\t\tstack->top--;\n\t\t\t} else {\n\t\t\t\tstack->done = 1;\n\t\t\t}\n\t\t\tefree(ent1);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!strcmp(name, EL_BINARY)) {\n\t\t\tint new_len=0;\n\t\t\tunsigned char *new_str;\n\n\t\t\tnew_str = php_base64_decode(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data), &new_len);\n\t\t\tSTR_FREE(Z_STRVAL_P(ent1->data));\n\t\t\tif (new_str) {\n\t\t\t\tZ_STRVAL_P(ent1->data) = new_str;\n\t\t\t\tZ_STRLEN_P(ent1->data) = new_len;\n\t\t\t} else {\n\t\t\t\tZVAL_EMPTY_STRING(ent1->data);\n\t\t\t}\n\t\t}\n\n\t\t/* Call __wakeup() method on the object. */\n\t\tif (Z_TYPE_P(ent1->data) == IS_OBJECT) {\n\t\t\tzval *fname, *retval = NULL;\n\n\t\t\tMAKE_STD_ZVAL(fname);\n\t\t\tZVAL_STRING(fname, \"__wakeup\", 1);\n\n\t\t\tcall_user_function_ex(NULL, &ent1->data, fname, &retval, 0, 0, 0, NULL TSRMLS_CC);\n\n\t\t\tzval_dtor(fname);\n\t\t\tFREE_ZVAL(fname);\n\t\t\tif (retval) {\n\t\t\t\tzval_ptr_dtor(&retval);\n\t\t\t}\n\t\t}\n\n\t\tif (stack->top > 1) {\n\t\t\tstack->top--;\n\t\t\twddx_stack_top(stack, (void**)&ent2);\n\n\t\t\t/* if non-existent field */\n\t\t\tif (ent2->type == ST_FIELD && ent2->data == NULL) {\n\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\tefree(ent1);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (Z_TYPE_P(ent2->data) == IS_ARRAY || Z_TYPE_P(ent2->data) == IS_OBJECT) {\n\t\t\t\ttarget_hash = HASH_OF(ent2->data);\n\n\t\t\t\tif (ent1->varname) {\n\t\t\t\t\tif (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) &&\n\t\t\t\t\t\tZ_TYPE_P(ent1->data) == IS_STRING && Z_STRLEN_P(ent1->data) &&\n\t\t\t\t\t\tent2->type == ST_STRUCT && Z_TYPE_P(ent2->data) == IS_ARRAY) {\n\t\t\t\t\t\tzend_bool incomplete_class = 0;\n\n\t\t\t\t\t\tzend_str_tolower(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));\n\t\t\t\t\t\tif (zend_hash_find(EG(class_table), Z_STRVAL_P(ent1->data),\n\t\t\t\t\t\t\t\t\t\t   Z_STRLEN_P(ent1->data)+1, (void **) &pce)==FAILURE) {\n\t\t\t\t\t\t\tincomplete_class = 1;\n\t\t\t\t\t\t\tpce = &PHP_IC_ENTRY;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Initialize target object */\n\t\t\t\t\t\tMAKE_STD_ZVAL(obj);\n\t\t\t\t\t\tobject_init_ex(obj, *pce);\n\n\t\t\t\t\t\t/* Merge current hashtable with object's default properties */\n\t\t\t\t\t\tzend_hash_merge(Z_OBJPROP_P(obj),\n\t\t\t\t\t\t\t\t\t\tZ_ARRVAL_P(ent2->data),\n\t\t\t\t\t\t\t\t\t\t(void (*)(void *)) zval_add_ref,\n\t\t\t\t\t\t\t\t\t\t(void *) &tmp, sizeof(zval *), 0);\n\n\t\t\t\t\t\tif (incomplete_class) {\n\t\t\t\t\t\t\tphp_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Clean up old array entry */\n\t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n\n\t\t\t\t\t\t/* Set stack entry to point to the newly created object */\n\t\t\t\t\t\tent2->data = obj;\n\n\t\t\t\t\t\t/* Clean up class name var entry */\n\t\t\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\t\t} else if (Z_TYPE_P(ent2->data) == IS_OBJECT) {\n\t\t\t\t\t\tzend_class_entry *old_scope = EG(scope);\n\n\t\t\t\t\t\tEG(scope) = Z_OBJCE_P(ent2->data);\n\t\t\t\t\t\tZ_DELREF_P(ent1->data);\n\t\t\t\t\t\tadd_property_zval(ent2->data, ent1->varname, ent1->data);\n\t\t\t\t\t\tEG(scope) = old_scope;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tzend_symtable_update(target_hash, ent1->varname, strlen(ent1->varname)+1, &ent1->data, sizeof(zval *), NULL);\n\t\t\t\t\t}\n\t\t\t\t\tefree(ent1->varname);\n\t\t\t\t} else\t{\n\t\t\t\t\tzend_hash_next_index_insert(target_hash, &ent1->data, sizeof(zval *), NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tefree(ent1);\n\t\t} else {\n\t\t\tstack->done = 1;\n\t\t}\n\t} else if (!strcmp(name, EL_VAR) && stack->varname) {\n\t\tefree(stack->varname);\n\t\tstack->varname = NULL;\n\t} else if (!strcmp(name, EL_FIELD)) {\n\t\tst_entry *ent;\n\t\twddx_stack_top(stack, (void **)&ent);\n\t\tefree(ent);\n\t\tstack->top--;\n\t}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"config.h\"\n#include \"ext/xml/expat_compat.h\"\n#include \"php_wddx.h\"\n#include \"ext/standard/php_string.h\"\n#include \"zend_globals.h\"\n#include \"ext/standard/base64.h\"\n#include \"php.h\"\n#include \"ext/xml/php_xml.h\"\n#include \"ext/standard/html.h\"\n#include \"ext/standard/php_incomplete_class.h\"\n#include \"ext/date/php_date.h\"\n#include \"ext/standard/php_smart_str.h\"\n#include \"php_wddx_api.h\"\n#include \"ext/session/php_session.h\"\n#include \"ext/standard/info.h\"\n"
  },
  {
    "repository": "tensorflow",
    "cve_id": "CVE-2021-41206",
    "cwe_list": [
      "CWE-354"
    ],
    "commit_hash": "579261dcd446385831fe4f7457d802a59685121d",
    "short_hash": "579261dc",
    "vulnerableMethods_before": [
      {
        "filename": "matrix_solve_op.cc",
        "method_name": "vulnerable_function",
        "raw_code": "  void ComputeAsync(OpKernelContext* context, DoneCallback done) final {\n    const Tensor& input = context->input(0);\n    const Tensor& rhs = context->input(1);\n    const int ndims = input.dims();\n    const int64 n = input.dim_size(ndims - 1);\n    const int64 nrhs = rhs.dim_size(ndims - 1);\n    // Validate inputs.\n    OP_REQUIRES_ASYNC(\n        context, ndims >= 2,\n        errors::InvalidArgument(\"Input must have rank >= 2, got \", ndims),\n        done);\n    OP_REQUIRES_ASYNC(context, rhs.dims() == ndims,\n                      errors::InvalidArgument(\n                          \"Input and right-hand side must have same rank, got \",\n                          ndims, \" != \", rhs.dims()),\n                      done);\n    OP_REQUIRES_ASYNC(\n        context, input.dim_size(ndims - 2) == n,\n        errors::InvalidArgument(\"Input matrices must be squares, got\",\n                                input.dim_size(ndims - 2), \" != \", n),\n        done);\n    OP_REQUIRES_ASYNC(context, rhs.dim_size(ndims - 2) == n,\n                      errors::InvalidArgument(\n                          \"Input matrix and right-hand side must have the \"\n                          \"same number of rows, got\",\n                          n, \" != \", rhs.dim_size(ndims - 2)),\n                      done);\n\n    // Allocate output.\n    Tensor* output;\n    OP_REQUIRES_OK_ASYNC(\n        context,\n        context->forward_input_or_allocate_output({1}, 0, rhs.shape(), &output),\n        done);\n\n    // To be consistent with the MatrixInverse op, we define the solution for\n    // an empty set of equations as the empty matrix.\n    if (input.NumElements() == 0 || rhs.NumElements() == 0) {\n      done();\n      return;\n    }\n\n    // TODO(rmlarsen): Convert to std::make_unique when available.\n    std::unique_ptr<CudaSolver> solver(new CudaSolver(context));\n\n    // Make a copy of the input for the factorization step, or, if adjoint_ is\n    // false, try to reuse the input buffer if this op owns it exclusively.\n    Tensor input_copy;\n    const GPUDevice& device = context->eigen_device<GPUDevice>();\n    if (adjoint_) {\n      // For the adjoint case, it is simpler to always make a transposed copy up\n      // front.\n      OP_REQUIRES_OK_ASYNC(\n          context,\n          solver->allocate_scoped_tensor(DataTypeToEnum<Scalar>::value,\n                                         input.shape(), &input_copy),\n          done);\n      OP_REQUIRES_OK_ASYNC(context,\n                           DoMatrixTranspose(device, input, &input_copy), done);\n    } else {\n      OP_REQUIRES_OK_ASYNC(\n          context,\n          solver->forward_input_or_allocate_scoped_tensor(\n              {0}, DataTypeToEnum<Scalar>::value, input.shape(), &input_copy),\n          done);\n      if (!input.SharesBufferWith(input_copy)) {\n        device.memcpy(input_copy.flat<Scalar>().data(),\n                      input.flat<Scalar>().data(),\n                      input.NumElements() * sizeof(Scalar));\n      }\n    }\n    auto input_copy_reshaped = input_copy.template flat_inner_dims<Scalar, 3>();\n    const int64 batch_size = input_copy_reshaped.dimension(0);\n\n    // Allocate pivots on the device.\n    Tensor pivots;\n    OP_REQUIRES_OK_ASYNC(\n        context,\n        solver->allocate_scoped_tensor(DataTypeToEnum<int>::value,\n                                       TensorShape{batch_size, n}, &pivots),\n        done);\n    auto pivots_mat = pivots.template matrix<int>();\n\n    // 1. Compute the partially pivoted LU factorization(s) of the\n    // matrix/matrices.\n    std::vector<DeviceLapackInfo> dev_info;\n    auto input_copy_ptrs = solver->GetScratchSpace<uint8>(\n        sizeof(Scalar*) * batch_size, \"input_copt_ptrs\",\n        /* on_host */ true);\n    const int kMaxMatrixSizeToBatchSizeRatio = 128;\n    const bool use_batched_solver =\n        n <= kMaxMatrixSizeToBatchSizeRatio * batch_size;\n    if (use_batched_solver) {\n      // For small matrices or large batch sizes, we use the batched interface\n      // from cuBlas.\n      const Scalar** input_copy_ptrs_base =\n          reinterpret_cast<const Scalar**>(input_copy_ptrs.mutable_data());\n      for (int batch = 0; batch < batch_size; ++batch) {\n        input_copy_ptrs_base[batch] = &input_copy_reshaped(batch, 0, 0);\n      }\n      dev_info.push_back(\n          solver->GetDeviceLapackInfo(batch_size, \"getrfBatched\"));\n      OP_REQUIRES_OK_ASYNC(\n          context,\n          solver->GetrfBatched(n, input_copy_ptrs_base, n, pivots_mat.data(),\n                               &dev_info.back(), batch_size),\n          done);\n    } else {\n      // For small batch sizes or large matrices, we use the non-batched\n      // interface from cuSolver, which is much faster for large matrices.\n      dev_info.push_back(solver->GetDeviceLapackInfo(batch_size, \"getrf\"));\n      for (int batch = 0; batch < batch_size; ++batch) {\n        OP_REQUIRES_OK_ASYNC(\n            context,\n            solver->Getrf(n, n, &input_copy_reshaped(batch, 0, 0), n,\n                          &pivots_mat(batch, 0), &dev_info.back()(batch)),\n            done);\n      }\n    }\n\n    // 2. Make a transposed copy of the right-hand sides. This is necessary\n    // because cuBLAS assumes column-major storage while TensorFlow TF uses\n    // row-major.\n    TensorShape transposed_rhs_shape(rhs.shape());\n    transposed_rhs_shape.RemoveLastDims(2);\n    transposed_rhs_shape.AddDim(nrhs);\n    transposed_rhs_shape.AddDim(n);\n    Tensor transposed_rhs;\n    OP_REQUIRES_OK_ASYNC(\n        context,\n        solver->allocate_scoped_tensor(DataTypeToEnum<Scalar>::value,\n                                       transposed_rhs_shape, &transposed_rhs),\n        done);\n    if (nrhs > 1) {\n      OP_REQUIRES_OK_ASYNC(\n          context, DoMatrixTranspose(device, rhs, &transposed_rhs), done);\n    } else {\n      device.memcpy(transposed_rhs.flat<Scalar>().data(),\n                    rhs.flat<Scalar>().data(),\n                    rhs.NumElements() * sizeof(Scalar));\n    }\n\n    // 3. Solve op(A) X = B (in column major form).\n    // We use a trick here: If adjoint_ is true, we converted A to column major\n    // form above. If adjoint is false then I leave A in row-major form and use\n    // trans_a = CUBLAS_OP_T to effectively transform it to column-major on the\n    // fly. (This means that we actually use the LU-factorization of A^T in that\n    // case, but that is equally good for solving AX=B). This way we save an\n    // explicit transpose in the more common case of adjoint_ == false.\n    auto input_copy_ptr_array = solver->GetScratchSpace<uint8>(\n        sizeof(Scalar*) * batch_size, \"input_copy_ptr_array\",\n        /* on_host */ true);\n    auto transposed_rhs_ptr_array = solver->GetScratchSpace<uint8>(\n        sizeof(Scalar*) * batch_size, \"transposed_rhs_ptr_array\",\n        /* on_host */ true);\n    auto transposed_rhs_reshaped =\n        transposed_rhs.template flat_inner_dims<Scalar, 3>();\n    if (use_batched_solver) {\n      const Scalar** input_copy_ptrs_base =\n          reinterpret_cast<const Scalar**>(input_copy_ptr_array.mutable_data());\n      const Scalar** transposed_rhs_ptrs_base =\n          reinterpret_cast<const Scalar**>(\n              transposed_rhs_ptr_array.mutable_data());\n      for (int batch = 0; batch < batch_size; ++batch) {\n        input_copy_ptrs_base[batch] = &input_copy_reshaped(batch, 0, 0);\n        transposed_rhs_ptrs_base[batch] = &transposed_rhs_reshaped(batch, 0, 0);\n      }\n      int host_info = 0;\n      OP_REQUIRES_OK_ASYNC(\n          context,\n          solver->GetrsBatched(adjoint_ ? CUBLAS_OP_C : CUBLAS_OP_T, n, nrhs,\n                               input_copy_ptrs_base, n, pivots_mat.data(),\n                               transposed_rhs_ptrs_base, n, &host_info,\n                               batch_size),\n          done);\n      OP_REQUIRES_ASYNC(\n          context, host_info == 0,\n          errors::InvalidArgument(\"The \", -host_info,\n                                  \"'th argument to cublas*getrsBatched had \"\n                                  \"an illegal value.\"),\n          done);\n    } else {\n      dev_info.push_back(solver->GetDeviceLapackInfo(batch_size, \"getrs\"));\n      for (int batch = 0; batch < batch_size; ++batch) {\n        OP_REQUIRES_OK_ASYNC(\n            context,\n            solver->Getrs(adjoint_ ? CUBLAS_OP_C : CUBLAS_OP_T, n, nrhs,\n                          &input_copy_reshaped(batch, 0, 0), n,\n                          &pivots_mat(batch, 0),\n                          &transposed_rhs_reshaped(batch, 0, 0), n,\n                          &dev_info.back()(batch)),\n            done);\n      }\n    }\n\n    // 4. Transpose X to get the final result in row-major form.\n    if (nrhs > 1) {\n      OP_REQUIRES_OK_ASYNC(\n          context, DoMatrixTranspose(device, transposed_rhs, output), done);\n    } else {\n      device.memcpy(output->flat<Scalar>().data(),\n                    transposed_rhs.flat<Scalar>().data(),\n                    transposed_rhs.NumElements() * sizeof(Scalar));\n    }\n\n    // Callback for checking info after kernels finish. Also capture the\n    // temporary Tensors/ScratchSpace so they don't get deallocated before the\n    // kernels run. TODO(rmlarsen): Use move capture once C++14 becomes\n    // available.\n    auto info_checker = [context, done, dev_info](\n                            const Status& status,\n                            const std::vector<HostLapackInfo>& host_infos) {\n      if (!status.ok() && errors::IsInvalidArgument(status) &&\n          !host_infos.empty()) {\n        for (int i = 0; i < host_infos[0].size(); ++i) {\n          // Match the CPU error message for singular matrices. Otherwise\n          // just print the original error message from the status below.\n          OP_REQUIRES_ASYNC(context, host_infos[0].data()[i] <= 0,\n                            errors::InvalidArgument(kErrMsg), done);\n        }\n      }\n      OP_REQUIRES_OK_ASYNC(context, status, done);\n      done();\n    };\n    CudaSolver::CheckLapackInfoAndDeleteSolverAsync(std::move(solver), dev_info,\n                                                    std::move(info_checker));\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "matrix_solve_op.cc",
        "method_name": "fixed_function",
        "raw_code": "  void ComputeAsync(OpKernelContext* context, DoneCallback done) final {\n    const Tensor& input = context->input(0);\n    const Tensor& rhs = context->input(1);\n    const int ndims = input.dims();\n    const int64 n = input.dim_size(ndims - 1);\n    const int64 nrhs = rhs.dim_size(ndims - 1);\n    // Validate inputs.\n    OP_REQUIRES_ASYNC(\n        context, ndims >= 2,\n        errors::InvalidArgument(\"Input must have rank >= 2, got \", ndims),\n        done);\n    OP_REQUIRES_ASYNC(context, rhs.dims() == ndims,\n                      errors::InvalidArgument(\n                          \"Input and right-hand side must have same rank, got \",\n                          ndims, \" != \", rhs.dims()),\n                      done);\n    OP_REQUIRES_ASYNC(\n        context, input.dim_size(ndims - 2) == n,\n        errors::InvalidArgument(\"Input matrices must be squares, got \",\n                                input.dim_size(ndims - 2), \" != \", n),\n        done);\n    OP_REQUIRES_ASYNC(context, rhs.dim_size(ndims - 2) == n,\n                      errors::InvalidArgument(\n                          \"Input matrix and right-hand side must have the \"\n                          \"same number of rows, got \",\n                          n, \" != \", rhs.dim_size(ndims - 2)),\n                      done);\n    for (int dim = 0; dim < ndims - 2; dim++) {\n      OP_REQUIRES_ASYNC(\n          context, input.dim_size(dim) == rhs.dim_size(dim),\n          errors::InvalidArgument(\n              \"All input tensors must have the same outer dimensions.\"),\n          done);\n    }\n\n    // Allocate output.\n    Tensor* output;\n    OP_REQUIRES_OK_ASYNC(\n        context,\n        context->forward_input_or_allocate_output({1}, 0, rhs.shape(), &output),\n        done);\n\n    // To be consistent with the MatrixInverse op, we define the solution for\n    // an empty set of equations as the empty matrix.\n    if (input.NumElements() == 0 || rhs.NumElements() == 0) {\n      done();\n      return;\n    }\n\n    // TODO(rmlarsen): Convert to std::make_unique when available.\n    std::unique_ptr<CudaSolver> solver(new CudaSolver(context));\n\n    // Make a copy of the input for the factorization step, or, if adjoint_ is\n    // false, try to reuse the input buffer if this op owns it exclusively.\n    Tensor input_copy;\n    const GPUDevice& device = context->eigen_device<GPUDevice>();\n    if (adjoint_) {\n      // For the adjoint case, it is simpler to always make a transposed copy up\n      // front.\n      OP_REQUIRES_OK_ASYNC(\n          context,\n          solver->allocate_scoped_tensor(DataTypeToEnum<Scalar>::value,\n                                         input.shape(), &input_copy),\n          done);\n      OP_REQUIRES_OK_ASYNC(context,\n                           DoMatrixTranspose(device, input, &input_copy), done);\n    } else {\n      OP_REQUIRES_OK_ASYNC(\n          context,\n          solver->forward_input_or_allocate_scoped_tensor(\n              {0}, DataTypeToEnum<Scalar>::value, input.shape(), &input_copy),\n          done);\n      if (!input.SharesBufferWith(input_copy)) {\n        device.memcpy(input_copy.flat<Scalar>().data(),\n                      input.flat<Scalar>().data(),\n                      input.NumElements() * sizeof(Scalar));\n      }\n    }\n    auto input_copy_reshaped = input_copy.template flat_inner_dims<Scalar, 3>();\n    const int64 batch_size = input_copy_reshaped.dimension(0);\n\n    // Allocate pivots on the device.\n    Tensor pivots;\n    OP_REQUIRES_OK_ASYNC(\n        context,\n        solver->allocate_scoped_tensor(DataTypeToEnum<int>::value,\n                                       TensorShape{batch_size, n}, &pivots),\n        done);\n    auto pivots_mat = pivots.template matrix<int>();\n\n    // 1. Compute the partially pivoted LU factorization(s) of the\n    // matrix/matrices.\n    std::vector<DeviceLapackInfo> dev_info;\n    auto input_copy_ptrs = solver->GetScratchSpace<uint8>(\n        sizeof(Scalar*) * batch_size, \"input_copt_ptrs\",\n        /* on_host */ true);\n    const int kMaxMatrixSizeToBatchSizeRatio = 128;\n    const bool use_batched_solver =\n        n <= kMaxMatrixSizeToBatchSizeRatio * batch_size;\n    if (use_batched_solver) {\n      // For small matrices or large batch sizes, we use the batched interface\n      // from cuBlas.\n      const Scalar** input_copy_ptrs_base =\n          reinterpret_cast<const Scalar**>(input_copy_ptrs.mutable_data());\n      for (int batch = 0; batch < batch_size; ++batch) {\n        input_copy_ptrs_base[batch] = &input_copy_reshaped(batch, 0, 0);\n      }\n      dev_info.push_back(\n          solver->GetDeviceLapackInfo(batch_size, \"getrfBatched\"));\n      OP_REQUIRES_OK_ASYNC(\n          context,\n          solver->GetrfBatched(n, input_copy_ptrs_base, n, pivots_mat.data(),\n                               &dev_info.back(), batch_size),\n          done);\n    } else {\n      // For small batch sizes or large matrices, we use the non-batched\n      // interface from cuSolver, which is much faster for large matrices.\n      dev_info.push_back(solver->GetDeviceLapackInfo(batch_size, \"getrf\"));\n      for (int batch = 0; batch < batch_size; ++batch) {\n        OP_REQUIRES_OK_ASYNC(\n            context,\n            solver->Getrf(n, n, &input_copy_reshaped(batch, 0, 0), n,\n                          &pivots_mat(batch, 0), &dev_info.back()(batch)),\n            done);\n      }\n    }\n\n    // 2. Make a transposed copy of the right-hand sides. This is necessary\n    // because cuBLAS assumes column-major storage while TensorFlow TF uses\n    // row-major.\n    TensorShape transposed_rhs_shape(rhs.shape());\n    transposed_rhs_shape.RemoveLastDims(2);\n    transposed_rhs_shape.AddDim(nrhs);\n    transposed_rhs_shape.AddDim(n);\n    Tensor transposed_rhs;\n    OP_REQUIRES_OK_ASYNC(\n        context,\n        solver->allocate_scoped_tensor(DataTypeToEnum<Scalar>::value,\n                                       transposed_rhs_shape, &transposed_rhs),\n        done);\n    if (nrhs > 1) {\n      OP_REQUIRES_OK_ASYNC(\n          context, DoMatrixTranspose(device, rhs, &transposed_rhs), done);\n    } else {\n      device.memcpy(transposed_rhs.flat<Scalar>().data(),\n                    rhs.flat<Scalar>().data(),\n                    rhs.NumElements() * sizeof(Scalar));\n    }\n\n    // 3. Solve op(A) X = B (in column major form).\n    // We use a trick here: If adjoint_ is true, we converted A to column major\n    // form above. If adjoint is false then I leave A in row-major form and use\n    // trans_a = CUBLAS_OP_T to effectively transform it to column-major on the\n    // fly. (This means that we actually use the LU-factorization of A^T in that\n    // case, but that is equally good for solving AX=B). This way we save an\n    // explicit transpose in the more common case of adjoint_ == false.\n    auto input_copy_ptr_array = solver->GetScratchSpace<uint8>(\n        sizeof(Scalar*) * batch_size, \"input_copy_ptr_array\",\n        /* on_host */ true);\n    auto transposed_rhs_ptr_array = solver->GetScratchSpace<uint8>(\n        sizeof(Scalar*) * batch_size, \"transposed_rhs_ptr_array\",\n        /* on_host */ true);\n    auto transposed_rhs_reshaped =\n        transposed_rhs.template flat_inner_dims<Scalar, 3>();\n    if (use_batched_solver) {\n      const Scalar** input_copy_ptrs_base =\n          reinterpret_cast<const Scalar**>(input_copy_ptr_array.mutable_data());\n      const Scalar** transposed_rhs_ptrs_base =\n          reinterpret_cast<const Scalar**>(\n              transposed_rhs_ptr_array.mutable_data());\n      for (int batch = 0; batch < batch_size; ++batch) {\n        input_copy_ptrs_base[batch] = &input_copy_reshaped(batch, 0, 0);\n        transposed_rhs_ptrs_base[batch] = &transposed_rhs_reshaped(batch, 0, 0);\n      }\n      int host_info = 0;\n      OP_REQUIRES_OK_ASYNC(\n          context,\n          solver->GetrsBatched(adjoint_ ? CUBLAS_OP_C : CUBLAS_OP_T, n, nrhs,\n                               input_copy_ptrs_base, n, pivots_mat.data(),\n                               transposed_rhs_ptrs_base, n, &host_info,\n                               batch_size),\n          done);\n      OP_REQUIRES_ASYNC(\n          context, host_info == 0,\n          errors::InvalidArgument(\"The \", -host_info,\n                                  \"'th argument to cublas*getrsBatched had \"\n                                  \"an illegal value.\"),\n          done);\n    } else {\n      dev_info.push_back(solver->GetDeviceLapackInfo(batch_size, \"getrs\"));\n      for (int batch = 0; batch < batch_size; ++batch) {\n        OP_REQUIRES_OK_ASYNC(\n            context,\n            solver->Getrs(adjoint_ ? CUBLAS_OP_C : CUBLAS_OP_T, n, nrhs,\n                          &input_copy_reshaped(batch, 0, 0), n,\n                          &pivots_mat(batch, 0),\n                          &transposed_rhs_reshaped(batch, 0, 0), n,\n                          &dev_info.back()(batch)),\n            done);\n      }\n    }\n\n    // 4. Transpose X to get the final result in row-major form.\n    if (nrhs > 1) {\n      OP_REQUIRES_OK_ASYNC(\n          context, DoMatrixTranspose(device, transposed_rhs, output), done);\n    } else {\n      device.memcpy(output->flat<Scalar>().data(),\n                    transposed_rhs.flat<Scalar>().data(),\n                    transposed_rhs.NumElements() * sizeof(Scalar));\n    }\n\n    // Callback for checking info after kernels finish. Also capture the\n    // temporary Tensors/ScratchSpace so they don't get deallocated before the\n    // kernels run. TODO(rmlarsen): Use move capture once C++14 becomes\n    // available.\n    auto info_checker = [context, done, dev_info](\n                            const Status& status,\n                            const std::vector<HostLapackInfo>& host_infos) {\n      if (!status.ok() && errors::IsInvalidArgument(status) &&\n          !host_infos.empty()) {\n        for (int i = 0; i < host_infos[0].size(); ++i) {\n          // Match the CPU error message for singular matrices. Otherwise\n          // just print the original error message from the status below.\n          OP_REQUIRES_ASYNC(context, host_infos[0].data()[i] <= 0,\n                            errors::InvalidArgument(kErrMsg), done);\n        }\n      }\n      OP_REQUIRES_OK_ASYNC(context, status, done);\n      done();\n    };\n    CudaSolver::CheckLapackInfoAndDeleteSolverAsync(std::move(solver), dev_info,\n                                                    std::move(info_checker));\n  }",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <numeric>\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/kernel_def_builder.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/kernels/linalg/linalg_ops_common.h\"\n#include \"tensorflow/core/platform/types.h\"\n#include \"third_party/eigen3/Eigen/Core\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/kernels/transpose_functor.h\"\n#include \"third_party/eigen3/Eigen/LU\"\n#include \"tensorflow/core/platform/macros.h\"\n#include \"tensorflow/core/util/cuda_solvers.h\"\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n"
  },
  {
    "repository": "vim",
    "cve_id": "CVE-2022-2207",
    "cwe_list": [
      "CWE-787"
    ],
    "commit_hash": "0971c7a4e537ea120a6bb2195960be8d0815e97b",
    "short_hash": "0971c7a4",
    "vulnerableMethods_before": [
      {
        "filename": "edit.c",
        "method_name": "vulnerable_function",
        "raw_code": "ins_bs(\n    int\t\tc,\n    int\t\tmode,\n    int\t\t*inserted_space_p)\n{\n    linenr_T\tlnum;\n    int\t\tcc;\n    int\t\ttemp = 0;\t    // init for GCC\n    colnr_T\tsave_col;\n    colnr_T\tmincol;\n    int\t\tdid_backspace = FALSE;\n    int\t\tin_indent;\n    int\t\toldState;\n    int\t\tcpc[MAX_MCO];\t    // composing characters\n    int\t\tcall_fix_indent = FALSE;\n\n    /*\n     * can't delete anything in an empty file\n     * can't backup past first character in buffer\n     * can't backup past starting point unless 'backspace' > 1\n     * can backup to a previous line if 'backspace' == 0\n     */\n    if (       BUFEMPTY()\n\t    || (\n#ifdef FEAT_RIGHTLEFT\n\t\t!revins_on &&\n#endif\n\t\t((curwin->w_cursor.lnum == 1 && curwin->w_cursor.col == 0)\n\t\t    || (!can_bs(BS_START)\n\t\t\t&& ((arrow_used\n#ifdef FEAT_JOB_CHANNEL\n\t\t\t\t&& !bt_prompt(curbuf)\n#endif\n\t\t\t) || (curwin->w_cursor.lnum == Insstart_orig.lnum\n\t\t\t\t&& curwin->w_cursor.col <= Insstart_orig.col)))\n\t\t    || (!can_bs(BS_INDENT) && !arrow_used && ai_col > 0\n\t\t\t\t\t && curwin->w_cursor.col <= ai_col)\n\t\t    || (!can_bs(BS_EOL) && curwin->w_cursor.col == 0))))\n    {\n\tvim_beep(BO_BS);\n\treturn FALSE;\n    }\n\n    if (stop_arrow() == FAIL)\n\treturn FALSE;\n    in_indent = inindent(0);\n    if (in_indent)\n\tcan_cindent = FALSE;\n    end_comment_pending = NUL;\t// After BS, don't auto-end comment\n#ifdef FEAT_RIGHTLEFT\n    if (revins_on)\t    // put cursor after last inserted char\n\tinc_cursor();\n#endif\n\n    // Virtualedit:\n    //\tBACKSPACE_CHAR eats a virtual space\n    //\tBACKSPACE_WORD eats all coladd\n    //\tBACKSPACE_LINE eats all coladd and keeps going\n    if (curwin->w_cursor.coladd > 0)\n    {\n\tif (mode == BACKSPACE_CHAR)\n\t{\n\t    --curwin->w_cursor.coladd;\n\t    return TRUE;\n\t}\n\tif (mode == BACKSPACE_WORD)\n\t{\n\t    curwin->w_cursor.coladd = 0;\n\t    return TRUE;\n\t}\n\tcurwin->w_cursor.coladd = 0;\n    }\n\n    /*\n     * Delete newline!\n     */\n    if (curwin->w_cursor.col == 0)\n    {\n\tlnum = Insstart.lnum;\n\tif (curwin->w_cursor.lnum == lnum\n#ifdef FEAT_RIGHTLEFT\n\t\t\t|| revins_on\n#endif\n\t\t\t\t    )\n\t{\n\t    if (u_save((linenr_T)(curwin->w_cursor.lnum - 2),\n\t\t\t       (linenr_T)(curwin->w_cursor.lnum + 1)) == FAIL)\n\t\treturn FALSE;\n\t    --Insstart.lnum;\n\t    Insstart.col = (colnr_T)STRLEN(ml_get(Insstart.lnum));\n\t}\n\t/*\n\t * In replace mode:\n\t * cc < 0: NL was inserted, delete it\n\t * cc >= 0: NL was replaced, put original characters back\n\t */\n\tcc = -1;\n\tif (State & REPLACE_FLAG)\n\t    cc = replace_pop();\t    // returns -1 if NL was inserted\n\t/*\n\t * In replace mode, in the line we started replacing, we only move the\n\t * cursor.\n\t */\n\tif ((State & REPLACE_FLAG) && curwin->w_cursor.lnum <= lnum)\n\t{\n\t    dec_cursor();\n\t}\n\telse\n\t{\n\t    if (!(State & VREPLACE_FLAG)\n\t\t\t\t   || curwin->w_cursor.lnum > orig_line_count)\n\t    {\n\t\ttemp = gchar_cursor();\t// remember current char\n\t\t--curwin->w_cursor.lnum;\n\n\t\t// When \"aw\" is in 'formatoptions' we must delete the space at\n\t\t// the end of the line, otherwise the line will be broken\n\t\t// again when auto-formatting.\n\t\tif (has_format_option(FO_AUTO)\n\t\t\t\t\t   && has_format_option(FO_WHITE_PAR))\n\t\t{\n\t\t    char_u  *ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum,\n\t\t\t\t\t\t\t\t\tTRUE);\n\t\t    int\t    len;\n\n\t\t    len = (int)STRLEN(ptr);\n\t\t    if (len > 0 && ptr[len - 1] == ' ')\n\t\t\tptr[len - 1] = NUL;\n\t\t}\n\n\t\t(void)do_join(2, FALSE, FALSE, FALSE, FALSE);\n\t\tif (temp == NUL && gchar_cursor() != NUL)\n\t\t    inc_cursor();\n\t    }\n\t    else\n\t\tdec_cursor();\n\n\t    /*\n\t     * In MODE_REPLACE mode we have to put back the text that was\n\t     * replaced by the NL. On the replace stack is first a\n\t     * NUL-terminated sequence of characters that were deleted and then\n\t     * the characters that NL replaced.\n\t     */\n\t    if (State & REPLACE_FLAG)\n\t    {\n\t\t/*\n\t\t * Do the next ins_char() in MODE_NORMAL state, to\n\t\t * prevent ins_char() from replacing characters and\n\t\t * avoiding showmatch().\n\t\t */\n\t\toldState = State;\n\t\tState = MODE_NORMAL;\n\t\t/*\n\t\t * restore characters (blanks) deleted after cursor\n\t\t */\n\t\twhile (cc > 0)\n\t\t{\n\t\t    save_col = curwin->w_cursor.col;\n\t\t    mb_replace_pop_ins(cc);\n\t\t    curwin->w_cursor.col = save_col;\n\t\t    cc = replace_pop();\n\t\t}\n\t\t// restore the characters that NL replaced\n\t\treplace_pop_ins();\n\t\tState = oldState;\n\t    }\n\t}\n\tdid_ai = FALSE;\n    }\n    else\n    {\n\t/*\n\t * Delete character(s) before the cursor.\n\t */\n#ifdef FEAT_RIGHTLEFT\n\tif (revins_on)\t\t// put cursor on last inserted char\n\t    dec_cursor();\n#endif\n\tmincol = 0;\n\t\t\t\t\t\t// keep indent\n\tif (mode == BACKSPACE_LINE\n\t\t&& (curbuf->b_p_ai || cindent_on())\n#ifdef FEAT_RIGHTLEFT\n\t\t&& !revins_on\n#endif\n\t\t\t    )\n\t{\n\t    save_col = curwin->w_cursor.col;\n\t    beginline(BL_WHITE);\n\t    if (curwin->w_cursor.col < save_col)\n\t    {\n\t\tmincol = curwin->w_cursor.col;\n\t\t// should now fix the indent to match with the previous line\n\t\tcall_fix_indent = TRUE;\n\t    }\n\t    curwin->w_cursor.col = save_col;\n\t}\n\n\t/*\n\t * Handle deleting one 'shiftwidth' or 'softtabstop'.\n\t */\n\tif (\t   mode == BACKSPACE_CHAR\n\t\t&& ((p_sta && in_indent)\n\t\t    || ((get_sts_value() != 0\n#ifdef FEAT_VARTABS\n\t\t\t|| tabstop_count(curbuf->b_p_vsts_array)\n#endif\n\t\t\t)\n\t\t\t&& curwin->w_cursor.col > 0\n\t\t\t&& (*(ml_get_cursor() - 1) == TAB\n\t\t\t    || (*(ml_get_cursor() - 1) == ' '\n\t\t\t\t&& (!*inserted_space_p\n\t\t\t\t    || arrow_used))))))\n\t{\n\t    int\t\tts;\n\t    colnr_T\tvcol;\n\t    colnr_T\twant_vcol;\n\t    colnr_T\tstart_vcol;\n\n\t    *inserted_space_p = FALSE;\n\t    // Compute the virtual column where we want to be.  Since\n\t    // 'showbreak' may get in the way, need to get the last column of\n\t    // the previous character.\n\t    getvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL);\n\t    start_vcol = vcol;\n\t    dec_cursor();\n\t    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &want_vcol);\n\t    inc_cursor();\n#ifdef FEAT_VARTABS\n\t    if (p_sta && in_indent)\n\t    {\n\t\tts = (int)get_sw_value(curbuf);\n\t\twant_vcol = (want_vcol / ts) * ts;\n\t    }\n\t    else\n\t\twant_vcol = tabstop_start(want_vcol, get_sts_value(),\n\t\t\t\t\t\t       curbuf->b_p_vsts_array);\n#else\n\t    if (p_sta && in_indent)\n\t\tts = (int)get_sw_value(curbuf);\n\t    else\n\t\tts = (int)get_sts_value();\n\t    want_vcol = (want_vcol / ts) * ts;\n#endif\n\n\t    // delete characters until we are at or before want_vcol\n\t    while (vcol > want_vcol\n\t\t    && (cc = *(ml_get_cursor() - 1), VIM_ISWHITE(cc)))\n\t\tins_bs_one(&vcol);\n\n\t    // insert extra spaces until we are at want_vcol\n\t    while (vcol < want_vcol)\n\t    {\n\t\t// Remember the first char we inserted\n\t\tif (curwin->w_cursor.lnum == Insstart_orig.lnum\n\t\t\t\t   && curwin->w_cursor.col < Insstart_orig.col)\n\t\t    Insstart_orig.col = curwin->w_cursor.col;\n\n\t\tif (State & VREPLACE_FLAG)\n\t\t    ins_char(' ');\n\t\telse\n\t\t{\n\t\t    ins_str((char_u *)\" \");\n\t\t    if ((State & REPLACE_FLAG))\n\t\t\treplace_push(NUL);\n\t\t}\n\t\tgetvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL);\n\t    }\n\n\t    // If we are now back where we started delete one character.  Can\n\t    // happen when using 'sts' and 'linebreak'.\n\t    if (vcol >= start_vcol)\n\t\tins_bs_one(&vcol);\n\t}\n\n\t/*\n\t * Delete up to starting point, start of line or previous word.\n\t */\n\telse\n\t{\n\t    int cclass = 0, prev_cclass = 0;\n\n\t    if (has_mbyte)\n\t\tcclass = mb_get_class(ml_get_cursor());\n\t    do\n\t    {\n#ifdef FEAT_RIGHTLEFT\n\t\tif (!revins_on) // put cursor on char to be deleted\n#endif\n\t\t    dec_cursor();\n\n\t\tcc = gchar_cursor();\n\t\t// look multi-byte character class\n\t\tif (has_mbyte)\n\t\t{\n\t\t    prev_cclass = cclass;\n\t\t    cclass = mb_get_class(ml_get_cursor());\n\t\t}\n\n\t\t// start of word?\n\t\tif (mode == BACKSPACE_WORD && !vim_isspace(cc))\n\t\t{\n\t\t    mode = BACKSPACE_WORD_NOT_SPACE;\n\t\t    temp = vim_iswordc(cc);\n\t\t}\n\t\t// end of word?\n\t\telse if (mode == BACKSPACE_WORD_NOT_SPACE\n\t\t\t&& ((vim_isspace(cc) || vim_iswordc(cc) != temp)\n\t\t\t|| prev_cclass != cclass))\n\t\t{\n#ifdef FEAT_RIGHTLEFT\n\t\t    if (!revins_on)\n#endif\n\t\t\tinc_cursor();\n#ifdef FEAT_RIGHTLEFT\n\t\t    else if (State & REPLACE_FLAG)\n\t\t\tdec_cursor();\n#endif\n\t\t    break;\n\t\t}\n\t\tif (State & REPLACE_FLAG)\n\t\t    replace_do_bs(-1);\n\t\telse\n\t\t{\n\t\t    if (enc_utf8 && p_deco)\n\t\t\t(void)utfc_ptr2char(ml_get_cursor(), cpc);\n\t\t    (void)del_char(FALSE);\n\t\t    /*\n\t\t     * If there are combining characters and 'delcombine' is set\n\t\t     * move the cursor back.  Don't back up before the base\n\t\t     * character.\n\t\t     */\n\t\t    if (enc_utf8 && p_deco && cpc[0] != NUL)\n\t\t\tinc_cursor();\n#ifdef FEAT_RIGHTLEFT\n\t\t    if (revins_chars)\n\t\t    {\n\t\t\trevins_chars--;\n\t\t\trevins_legal++;\n\t\t    }\n\t\t    if (revins_on && gchar_cursor() == NUL)\n\t\t\tbreak;\n#endif\n\t\t}\n\t\t// Just a single backspace?:\n\t\tif (mode == BACKSPACE_CHAR)\n\t\t    break;\n\t    } while (\n#ifdef FEAT_RIGHTLEFT\n\t\t    revins_on ||\n#endif\n\t\t    (curwin->w_cursor.col > mincol\n\t\t    &&  (can_bs(BS_NOSTOP)\n\t\t\t|| (curwin->w_cursor.lnum != Insstart_orig.lnum\n\t\t\t|| curwin->w_cursor.col != Insstart_orig.col)\n\t\t    )));\n\t}\n\tdid_backspace = TRUE;\n    }\n    did_si = FALSE;\n    can_si = FALSE;\n    can_si_back = FALSE;\n    if (curwin->w_cursor.col <= 1)\n\tdid_ai = FALSE;\n\n    if (call_fix_indent)\n\tfix_indent();\n\n    /*\n     * It's a little strange to put backspaces into the redo\n     * buffer, but it makes auto-indent a lot easier to deal\n     * with.\n     */\n    AppendCharToRedobuff(c);\n\n    // If deleted before the insertion point, adjust it\n    if (curwin->w_cursor.lnum == Insstart_orig.lnum\n\t\t\t\t  && curwin->w_cursor.col < Insstart_orig.col)\n\tInsstart_orig.col = curwin->w_cursor.col;\n\n    // vi behaviour: the cursor moves backward but the character that\n    //\t\t     was there remains visible\n    // Vim behaviour: the cursor moves backward and the character that\n    //\t\t      was there is erased from the screen.\n    // We can emulate the vi behaviour by pretending there is a dollar\n    // displayed even when there isn't.\n    //  --pkv Sun Jan 19 01:56:40 EST 2003\n    if (vim_strchr(p_cpo, CPO_BACKSPACE) != NULL && dollar_vcol == -1)\n\tdollar_vcol = curwin->w_virtcol;\n\n#ifdef FEAT_FOLDING\n    // When deleting a char the cursor line must never be in a closed fold.\n    // E.g., when 'foldmethod' is indent and deleting the first non-white\n    // char before a Tab.\n    if (did_backspace)\n\tfoldOpenCursor();\n#endif\n\n    return did_backspace;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "edit.c",
        "method_name": "fixed_function",
        "raw_code": "ins_bs(\n    int\t\tc,\n    int\t\tmode,\n    int\t\t*inserted_space_p)\n{\n    linenr_T\tlnum;\n    int\t\tcc;\n    int\t\ttemp = 0;\t    // init for GCC\n    colnr_T\tsave_col;\n    colnr_T\tmincol;\n    int\t\tdid_backspace = FALSE;\n    int\t\tin_indent;\n    int\t\toldState;\n    int\t\tcpc[MAX_MCO];\t    // composing characters\n    int\t\tcall_fix_indent = FALSE;\n\n    /*\n     * can't delete anything in an empty file\n     * can't backup past first character in buffer\n     * can't backup past starting point unless 'backspace' > 1\n     * can backup to a previous line if 'backspace' == 0\n     */\n    if (       BUFEMPTY()\n\t    || (\n#ifdef FEAT_RIGHTLEFT\n\t\t!revins_on &&\n#endif\n\t\t((curwin->w_cursor.lnum == 1 && curwin->w_cursor.col == 0)\n\t\t    || (!can_bs(BS_START)\n\t\t\t&& ((arrow_used\n#ifdef FEAT_JOB_CHANNEL\n\t\t\t\t&& !bt_prompt(curbuf)\n#endif\n\t\t\t) || (curwin->w_cursor.lnum == Insstart_orig.lnum\n\t\t\t\t&& curwin->w_cursor.col <= Insstart_orig.col)))\n\t\t    || (!can_bs(BS_INDENT) && !arrow_used && ai_col > 0\n\t\t\t\t\t && curwin->w_cursor.col <= ai_col)\n\t\t    || (!can_bs(BS_EOL) && curwin->w_cursor.col == 0))))\n    {\n\tvim_beep(BO_BS);\n\treturn FALSE;\n    }\n\n    if (stop_arrow() == FAIL)\n\treturn FALSE;\n    in_indent = inindent(0);\n    if (in_indent)\n\tcan_cindent = FALSE;\n    end_comment_pending = NUL;\t// After BS, don't auto-end comment\n#ifdef FEAT_RIGHTLEFT\n    if (revins_on)\t    // put cursor after last inserted char\n\tinc_cursor();\n#endif\n\n    // Virtualedit:\n    //\tBACKSPACE_CHAR eats a virtual space\n    //\tBACKSPACE_WORD eats all coladd\n    //\tBACKSPACE_LINE eats all coladd and keeps going\n    if (curwin->w_cursor.coladd > 0)\n    {\n\tif (mode == BACKSPACE_CHAR)\n\t{\n\t    --curwin->w_cursor.coladd;\n\t    return TRUE;\n\t}\n\tif (mode == BACKSPACE_WORD)\n\t{\n\t    curwin->w_cursor.coladd = 0;\n\t    return TRUE;\n\t}\n\tcurwin->w_cursor.coladd = 0;\n    }\n\n    /*\n     * Delete newline!\n     */\n    if (curwin->w_cursor.col == 0)\n    {\n\tlnum = Insstart.lnum;\n\tif (curwin->w_cursor.lnum == lnum\n#ifdef FEAT_RIGHTLEFT\n\t\t\t|| revins_on\n#endif\n\t\t\t\t    )\n\t{\n\t    if (u_save((linenr_T)(curwin->w_cursor.lnum - 2),\n\t\t\t       (linenr_T)(curwin->w_cursor.lnum + 1)) == FAIL)\n\t\treturn FALSE;\n\t    --Insstart.lnum;\n\t    Insstart.col = (colnr_T)STRLEN(ml_get(Insstart.lnum));\n\t}\n\t/*\n\t * In replace mode:\n\t * cc < 0: NL was inserted, delete it\n\t * cc >= 0: NL was replaced, put original characters back\n\t */\n\tcc = -1;\n\tif (State & REPLACE_FLAG)\n\t    cc = replace_pop();\t    // returns -1 if NL was inserted\n\t/*\n\t * In replace mode, in the line we started replacing, we only move the\n\t * cursor.\n\t */\n\tif ((State & REPLACE_FLAG) && curwin->w_cursor.lnum <= lnum)\n\t{\n\t    dec_cursor();\n\t}\n\telse\n\t{\n\t    if (!(State & VREPLACE_FLAG)\n\t\t\t\t   || curwin->w_cursor.lnum > orig_line_count)\n\t    {\n\t\ttemp = gchar_cursor();\t// remember current char\n\t\t--curwin->w_cursor.lnum;\n\n\t\t// When \"aw\" is in 'formatoptions' we must delete the space at\n\t\t// the end of the line, otherwise the line will be broken\n\t\t// again when auto-formatting.\n\t\tif (has_format_option(FO_AUTO)\n\t\t\t\t\t   && has_format_option(FO_WHITE_PAR))\n\t\t{\n\t\t    char_u  *ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum,\n\t\t\t\t\t\t\t\t\tTRUE);\n\t\t    int\t    len;\n\n\t\t    len = (int)STRLEN(ptr);\n\t\t    if (len > 0 && ptr[len - 1] == ' ')\n\t\t\tptr[len - 1] = NUL;\n\t\t}\n\n\t\t(void)do_join(2, FALSE, FALSE, FALSE, FALSE);\n\t\tif (temp == NUL && gchar_cursor() != NUL)\n\t\t    inc_cursor();\n\t    }\n\t    else\n\t\tdec_cursor();\n\n\t    /*\n\t     * In MODE_REPLACE mode we have to put back the text that was\n\t     * replaced by the NL. On the replace stack is first a\n\t     * NUL-terminated sequence of characters that were deleted and then\n\t     * the characters that NL replaced.\n\t     */\n\t    if (State & REPLACE_FLAG)\n\t    {\n\t\t/*\n\t\t * Do the next ins_char() in MODE_NORMAL state, to\n\t\t * prevent ins_char() from replacing characters and\n\t\t * avoiding showmatch().\n\t\t */\n\t\toldState = State;\n\t\tState = MODE_NORMAL;\n\t\t/*\n\t\t * restore characters (blanks) deleted after cursor\n\t\t */\n\t\twhile (cc > 0)\n\t\t{\n\t\t    save_col = curwin->w_cursor.col;\n\t\t    mb_replace_pop_ins(cc);\n\t\t    curwin->w_cursor.col = save_col;\n\t\t    cc = replace_pop();\n\t\t}\n\t\t// restore the characters that NL replaced\n\t\treplace_pop_ins();\n\t\tState = oldState;\n\t    }\n\t}\n\tdid_ai = FALSE;\n    }\n    else\n    {\n\t/*\n\t * Delete character(s) before the cursor.\n\t */\n#ifdef FEAT_RIGHTLEFT\n\tif (revins_on)\t\t// put cursor on last inserted char\n\t    dec_cursor();\n#endif\n\tmincol = 0;\n\t\t\t\t\t\t// keep indent\n\tif (mode == BACKSPACE_LINE\n\t\t&& (curbuf->b_p_ai || cindent_on())\n#ifdef FEAT_RIGHTLEFT\n\t\t&& !revins_on\n#endif\n\t\t\t    )\n\t{\n\t    save_col = curwin->w_cursor.col;\n\t    beginline(BL_WHITE);\n\t    if (curwin->w_cursor.col < save_col)\n\t    {\n\t\tmincol = curwin->w_cursor.col;\n\t\t// should now fix the indent to match with the previous line\n\t\tcall_fix_indent = TRUE;\n\t    }\n\t    curwin->w_cursor.col = save_col;\n\t}\n\n\t/*\n\t * Handle deleting one 'shiftwidth' or 'softtabstop'.\n\t */\n\tif (\t   mode == BACKSPACE_CHAR\n\t\t&& ((p_sta && in_indent)\n\t\t    || ((get_sts_value() != 0\n#ifdef FEAT_VARTABS\n\t\t\t|| tabstop_count(curbuf->b_p_vsts_array)\n#endif\n\t\t\t)\n\t\t\t&& curwin->w_cursor.col > 0\n\t\t\t&& (*(ml_get_cursor() - 1) == TAB\n\t\t\t    || (*(ml_get_cursor() - 1) == ' '\n\t\t\t\t&& (!*inserted_space_p\n\t\t\t\t    || arrow_used))))))\n\t{\n\t    int\t\tts;\n\t    colnr_T\tvcol;\n\t    colnr_T\twant_vcol;\n\t    colnr_T\tstart_vcol;\n\n\t    *inserted_space_p = FALSE;\n\t    // Compute the virtual column where we want to be.  Since\n\t    // 'showbreak' may get in the way, need to get the last column of\n\t    // the previous character.\n\t    getvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL);\n\t    start_vcol = vcol;\n\t    dec_cursor();\n\t    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &want_vcol);\n\t    inc_cursor();\n#ifdef FEAT_VARTABS\n\t    if (p_sta && in_indent)\n\t    {\n\t\tts = (int)get_sw_value(curbuf);\n\t\twant_vcol = (want_vcol / ts) * ts;\n\t    }\n\t    else\n\t\twant_vcol = tabstop_start(want_vcol, get_sts_value(),\n\t\t\t\t\t\t       curbuf->b_p_vsts_array);\n#else\n\t    if (p_sta && in_indent)\n\t\tts = (int)get_sw_value(curbuf);\n\t    else\n\t\tts = (int)get_sts_value();\n\t    want_vcol = (want_vcol / ts) * ts;\n#endif\n\n\t    // delete characters until we are at or before want_vcol\n\t    while (vcol > want_vcol && curwin->w_cursor.col > 0\n\t\t    && (cc = *(ml_get_cursor() - 1), VIM_ISWHITE(cc)))\n\t\tins_bs_one(&vcol);\n\n\t    // insert extra spaces until we are at want_vcol\n\t    while (vcol < want_vcol)\n\t    {\n\t\t// Remember the first char we inserted\n\t\tif (curwin->w_cursor.lnum == Insstart_orig.lnum\n\t\t\t\t   && curwin->w_cursor.col < Insstart_orig.col)\n\t\t    Insstart_orig.col = curwin->w_cursor.col;\n\n\t\tif (State & VREPLACE_FLAG)\n\t\t    ins_char(' ');\n\t\telse\n\t\t{\n\t\t    ins_str((char_u *)\" \");\n\t\t    if ((State & REPLACE_FLAG))\n\t\t\treplace_push(NUL);\n\t\t}\n\t\tgetvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL);\n\t    }\n\n\t    // If we are now back where we started delete one character.  Can\n\t    // happen when using 'sts' and 'linebreak'.\n\t    if (vcol >= start_vcol)\n\t\tins_bs_one(&vcol);\n\t}\n\n\t/*\n\t * Delete up to starting point, start of line or previous word.\n\t */\n\telse\n\t{\n\t    int cclass = 0, prev_cclass = 0;\n\n\t    if (has_mbyte)\n\t\tcclass = mb_get_class(ml_get_cursor());\n\t    do\n\t    {\n#ifdef FEAT_RIGHTLEFT\n\t\tif (!revins_on) // put cursor on char to be deleted\n#endif\n\t\t    dec_cursor();\n\n\t\tcc = gchar_cursor();\n\t\t// look multi-byte character class\n\t\tif (has_mbyte)\n\t\t{\n\t\t    prev_cclass = cclass;\n\t\t    cclass = mb_get_class(ml_get_cursor());\n\t\t}\n\n\t\t// start of word?\n\t\tif (mode == BACKSPACE_WORD && !vim_isspace(cc))\n\t\t{\n\t\t    mode = BACKSPACE_WORD_NOT_SPACE;\n\t\t    temp = vim_iswordc(cc);\n\t\t}\n\t\t// end of word?\n\t\telse if (mode == BACKSPACE_WORD_NOT_SPACE\n\t\t\t&& ((vim_isspace(cc) || vim_iswordc(cc) != temp)\n\t\t\t|| prev_cclass != cclass))\n\t\t{\n#ifdef FEAT_RIGHTLEFT\n\t\t    if (!revins_on)\n#endif\n\t\t\tinc_cursor();\n#ifdef FEAT_RIGHTLEFT\n\t\t    else if (State & REPLACE_FLAG)\n\t\t\tdec_cursor();\n#endif\n\t\t    break;\n\t\t}\n\t\tif (State & REPLACE_FLAG)\n\t\t    replace_do_bs(-1);\n\t\telse\n\t\t{\n\t\t    if (enc_utf8 && p_deco)\n\t\t\t(void)utfc_ptr2char(ml_get_cursor(), cpc);\n\t\t    (void)del_char(FALSE);\n\t\t    /*\n\t\t     * If there are combining characters and 'delcombine' is set\n\t\t     * move the cursor back.  Don't back up before the base\n\t\t     * character.\n\t\t     */\n\t\t    if (enc_utf8 && p_deco && cpc[0] != NUL)\n\t\t\tinc_cursor();\n#ifdef FEAT_RIGHTLEFT\n\t\t    if (revins_chars)\n\t\t    {\n\t\t\trevins_chars--;\n\t\t\trevins_legal++;\n\t\t    }\n\t\t    if (revins_on && gchar_cursor() == NUL)\n\t\t\tbreak;\n#endif\n\t\t}\n\t\t// Just a single backspace?:\n\t\tif (mode == BACKSPACE_CHAR)\n\t\t    break;\n\t    } while (\n#ifdef FEAT_RIGHTLEFT\n\t\t    revins_on ||\n#endif\n\t\t    (curwin->w_cursor.col > mincol\n\t\t    &&  (can_bs(BS_NOSTOP)\n\t\t\t|| (curwin->w_cursor.lnum != Insstart_orig.lnum\n\t\t\t|| curwin->w_cursor.col != Insstart_orig.col)\n\t\t    )));\n\t}\n\tdid_backspace = TRUE;\n    }\n    did_si = FALSE;\n    can_si = FALSE;\n    can_si_back = FALSE;\n    if (curwin->w_cursor.col <= 1)\n\tdid_ai = FALSE;\n\n    if (call_fix_indent)\n\tfix_indent();\n\n    /*\n     * It's a little strange to put backspaces into the redo\n     * buffer, but it makes auto-indent a lot easier to deal\n     * with.\n     */\n    AppendCharToRedobuff(c);\n\n    // If deleted before the insertion point, adjust it\n    if (curwin->w_cursor.lnum == Insstart_orig.lnum\n\t\t\t\t  && curwin->w_cursor.col < Insstart_orig.col)\n\tInsstart_orig.col = curwin->w_cursor.col;\n\n    // vi behaviour: the cursor moves backward but the character that\n    //\t\t     was there remains visible\n    // Vim behaviour: the cursor moves backward and the character that\n    //\t\t      was there is erased from the screen.\n    // We can emulate the vi behaviour by pretending there is a dollar\n    // displayed even when there isn't.\n    //  --pkv Sun Jan 19 01:56:40 EST 2003\n    if (vim_strchr(p_cpo, CPO_BACKSPACE) != NULL && dollar_vcol == -1)\n\tdollar_vcol = curwin->w_virtcol;\n\n#ifdef FEAT_FOLDING\n    // When deleting a char the cursor line must never be in a closed fold.\n    // E.g., when 'foldmethod' is indent and deleting the first non-white\n    // char before a Tab.\n    if (did_backspace)\n\tfoldOpenCursor();\n#endif\n\n    return did_backspace;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"vim.h\"\n\n// Type Definitions:\n// colnr_T:\ntypedef int\tcolnr_T;\n\n// colnr_T:\ntypedef int\t\tcolnr_T;\n\n// Called Methods (top 10):\n// can_bs from src/option.c:\n    int /* <=== can_bs */ \ncan_bs(\n    int\t\twhat)\t    // BS_INDENT, BS_EOL, BS_START or BS_NOSTOP\n{\n#ifdef FEAT_JOB_CHANNEL\n    if (what == BS_START && bt_prompt(curbuf))\n\treturn FALSE;\n#endif\n    switch (*p_bs)\n    {\n\tcase '3':       return TRUE;\n\tcase '2':\treturn (what != BS_NOSTOP);\n\tcase '1':\treturn (what != BS_START);\n\tcase '0':\treturn FALSE;\n    }\n    return vim_strchr(p_bs, what) != NULL;\n}\n\n// vim_strchr from src/strings.c:\n    char_u  * /* <=== vim_strchr */ \nvim_strchr(char_u *string, int c)\n{\n    char_u\t*p;\n    int\t\tb;\n\n    p = string;\n    if (enc_utf8 && c >= 0x80)\n    {\n\twhile (*p != NUL)\n\t{\n\t    int l = utfc_ptr2len(p);\n\n\t    // Avoid matching an illegal byte here.\n\t    if (utf_ptr2char(p) == c && l > 1)\n\t\treturn p;\n\t    p += l;\n\t}\n\treturn NULL;\n    }\n    if (enc_dbcs != 0 && c > 255)\n    {\n\tint\tn2 = c & 0xff;\n\n\tc = ((unsigned)c >> 8) & 0xff;\n\twhile ((b = *p) != NUL)\n\t{\n\t    if (b == c && p[1] == n2)\n\t\treturn p;\n\t    p += (*mb_ptr2len)(p);\n\t}\n\treturn NULL;\n    }\n    if (has_mbyte)\n    {\n\twhile ((b = *p) != NUL)\n\t{\n\t    if (b == c)\n\t\treturn p;\n\t    p += (*mb_ptr2len)(p);\n\t}\n\treturn NULL;\n    }\n    while ((b = *p) != NUL)\n    {\n\tif (b == c)\n\t    return p;\n\t++p;\n    }\n    return NULL;\n}\n\n// linetabsize from src/charset.c:\n    int /* <=== linetabsize */ \nlinetabsize(char_u *s)\n{\n    return linetabsize_col(0, s);\n}\n\n// utf_ptr2char from src/mbyte.c:\n    int /* <=== utf_ptr2char */ \nutf_ptr2char(char_u *p)\n{\n    int\t\tlen;\n\n    if (p[0] < 0x80)\t// be quick for ASCII\n\treturn p[0];\n\n    len = utf8len_tab_zero[p[0]];\n    if (len > 1 && (p[1] & 0xc0) == 0x80)\n    {\n\tif (len == 2)\n\t    return ((p[0] & 0x1f) << 6) + (p[1] & 0x3f);\n\tif ((p[2] & 0xc0) == 0x80)\n\t{\n\t    if (len == 3)\n\t\treturn ((p[0] & 0x0f) << 12) + ((p[1] & 0x3f) << 6)\n\t\t    + (p[2] & 0x3f);\n\t    if ((p[3] & 0xc0) == 0x80)\n\t    {\n\t\tif (len == 4)\n\t\t    return ((p[0] & 0x07) << 18) + ((p[1] & 0x3f) << 12)\n\t\t\t+ ((p[2] & 0x3f) << 6) + (p[3] & 0x3f);\n\t\tif ((p[4] & 0xc0) == 0x80)\n\t\t{\n\t\t    if (len == 5)\n\t\t\treturn ((p[0] & 0x03) << 24) + ((p[1] & 0x3f) << 18)\n\t\t\t    + ((p[2] & 0x3f) << 12) + ((p[3] & 0x3f) << 6)\n\t\t\t    + (p[4] & 0x3f);\n\t\t    if ((p[5] & 0xc0) == 0x80 && len == 6)\n\t\t\treturn ((p[0] & 0x01) << 30) + ((p[1] & 0x3f) << 24)\n\t\t\t    + ((p[2] & 0x3f) << 18) + ((p[3] & 0x3f) << 12)\n\t\t\t    + ((p[4] & 0x3f) << 6) + (p[5] & 0x3f);\n\t\t}\n\t    }\n\t}\n    }\n    // Illegal value, just return the first byte\n    return p[0];\n}\n\n// ins_char_bytes from src/change.c:\n    void /* <=== ins_char_bytes */ \nins_char_bytes(char_u *buf, int charlen)\n{\n    int\t\tc = buf[0];\n    int\t\tnewlen;\t\t// nr of bytes inserted\n    int\t\toldlen;\t\t// nr of bytes deleted (0 when not replacing)\n    char_u\t*p;\n    char_u\t*newp;\n    char_u\t*oldp;\n    int\t\tlinelen;\t// length of old line including NUL\n    colnr_T\tcol;\n    linenr_T\tlnum = curwin->w_cursor.lnum;\n    int\t\ti;\n\n    // Break tabs if needed.\n    if (virtual_active() && curwin->w_cursor.coladd > 0)\n\tcoladvance_force(getviscol());\n\n    col = curwin->w_cursor.col;\n    oldp = ml_get(lnum);\n    linelen = (int)STRLEN(oldp) + 1;\n\n    // The lengths default to the values for when not replacing.\n    oldlen = 0;\n    newlen = charlen;\n\n    if (State & REPLACE_FLAG)\n    {\n\tif (State & VREPLACE_FLAG)\n\t{\n\t    colnr_T\tnew_vcol = 0;   // init for GCC\n\t    colnr_T\tvcol;\n\t    int\t\told_list;\n\n\t    // Disable 'list' temporarily, unless 'cpo' contains the 'L' flag.\n\t    // Returns the old value of list, so when finished,\n\t    // curwin->w_p_list should be set back to this.\n\t    old_list = curwin->w_p_list;\n\t    if (old_list && vim_strchr(p_cpo, CPO_LISTWM) == NULL)\n\t\tcurwin->w_p_list = FALSE;\n\n\t    // In virtual replace mode each character may replace one or more\n\t    // characters (zero if it's a TAB).  Count the number of bytes to\n\t    // be deleted to make room for the new character, counting screen\n\t    // cells.  May result in adding spaces to fill a gap.\n\t    getvcol(curwin, &curwin->w_cursor, NULL, &vcol, NULL);\n\t    new_vcol = vcol + chartabsize(buf, vcol);\n\t    while (oldp[col + oldlen] != NUL && vcol < new_vcol)\n\t    {\n\t\tvcol += chartabsize(oldp + col + oldlen, vcol);\n\t\t// Don't need to remove a TAB that takes us to the right\n\t\t// position.\n\t\tif (vcol > new_vcol && oldp[col + oldlen] == TAB)\n\t\t    break;\n\t\toldlen += (*mb_ptr2len)(oldp + col + oldlen);\n\t\t// Deleted a bit too much, insert spaces.\n\t\tif (vcol > new_vcol)\n\t\t    newlen += vcol - new_vcol;\n\t    }\n\t    curwin->w_p_list = old_list;\n\t}\n\telse if (oldp[col] != NUL)\n\t{\n\t    // normal replace\n\t    oldlen = (*mb_ptr2len)(oldp + col);\n\t}\n\n\n\t// Push the replaced bytes onto the replace stack, so that they can be\n\t// put back when BS is used.  The bytes of a multi-byte character are\n\t// done the other way around, so that the first byte is popped off\n\t// first (it tells the byte length of the character).\n\treplace_push(NUL);\n\tfor (i = 0; i < oldlen; ++i)\n\t{\n\t    if (has_mbyte)\n\t\ti += replace_push_mb(oldp + col + i) - 1;\n\t    else\n\t\treplace_push(oldp[col + i]);\n\t}\n    }\n\n    newp = alloc(linelen + newlen - oldlen);\n    if (newp == NULL)\n\treturn;\n\n    // Copy bytes before the cursor.\n    if (col > 0)\n\tmch_memmove(newp, oldp, (size_t)col);\n\n    // Copy bytes after the changed character(s).\n    p = newp + col;\n    if (linelen > col + oldlen)\n\tmch_memmove(p + newlen, oldp + col + oldlen,\n\t\t\t\t\t    (size_t)(linelen - col - oldlen));\n\n    // Insert or overwrite the new character.\n    mch_memmove(p, buf, charlen);\n    i = charlen;\n\n    // Fill with spaces when necessary.\n    while (i < newlen)\n\tp[i++] = ' ';\n\n    // Replace the line in the buffer.\n    ml_replace(lnum, newp, FALSE);\n\n    // mark the buffer as changed and prepare for displaying\n    changed_bytes(lnum, col);\n#ifdef FEAT_PROP_POPUP\n    if (curbuf->b_has_textprop && newlen != oldlen)\n\tadjust_prop_columns(lnum, col, newlen - oldlen,\n\t\t\t\t    State & REPLACE_FLAG ? APC_SUBSTITUTE : 0);\n#endif\n\n    // If we're in Insert or Replace mode and 'showmatch' is set, then briefly\n    // show the match for right parens and braces.\n    if (p_sm && (State & MODE_INSERT)\n\t    && msg_silent == 0\n\t    && !ins_compl_active())\n    {\n\tif (has_mbyte)\n\t    showmatch(mb_ptr2char(buf));\n\telse\n\t    showmatch(c);\n    }\n\n#ifdef FEAT_RIGHTLEFT\n    if (!p_ri || (State & REPLACE_FLAG))\n#endif\n    {\n\t// Normal insert: move cursor right\n\tcurwin->w_cursor.col += charlen;\n    }\n\n    // TODO: should try to update w_row here, to avoid recomputing it later.\n}\n\n// MB_CHARLEN from src/macros.h:\n#define MB_CHARLEN(p)\t    (has_mbyte ? mb_charlen(p) : (int)STRLEN(p)) /* <=== src/macros.h:240:240:MB_CHARLEN:1 */ \n\n// FALSE from src/vim.h:\n# define FALSE\t0\t    // note: this is an int, not a long! /* <=== src/vim.h:1481:1481:FALSE:0 */ \n\n// ml_get_buf from src/memline.c:\n    char_u  * /* <=== ml_get_buf */ \nml_get_buf(\n    buf_T\t*buf,\n    linenr_T\tlnum,\n    int\t\twill_change)\t\t// line will be changed\n{\n    bhdr_T\t*hp;\n    DATA_BL\t*dp;\n    static int\trecursive = 0;\n    static char_u questions[4];\n\n    if (lnum > buf->b_ml.ml_line_count)\t// invalid line number\n    {\n\tif (recursive == 0)\n\t{\n\t    // Avoid giving this message for a recursive call, may happen when\n\t    // the GUI redraws part of the text.\n\t    ++recursive;\n\t    siemsg(_(e_ml_get_invalid_lnum_nr), lnum);\n\t    --recursive;\n\t}\n\tml_flush_line(buf);\n\tbuf->b_ml.ml_flags &= ~ML_LINE_DIRTY;\nerrorret:\n\tSTRCPY(questions, \"???\");\n\tbuf->b_ml.ml_line_len = 4;\n\tbuf->b_ml.ml_line_lnum = lnum;\n\treturn questions;\n    }\n    if (lnum <= 0)\t\t\t// pretend line 0 is line 1\n\tlnum = 1;\n\n    if (buf->b_ml.ml_mfp == NULL)\t// there are no lines\n    {\n\tbuf->b_ml.ml_line_len = 1;\n\treturn (char_u *)\"\";\n    }\n\n    /*\n     * See if it is the same line as requested last time.\n     * Otherwise may need to flush last used line.\n     * Don't use the last used line when 'swapfile' is reset, need to load all\n     * blocks.\n     */\n    if (buf->b_ml.ml_line_lnum != lnum || mf_dont_release)\n    {\n\tunsigned    start, end;\n\tcolnr_T\t    len;\n\tint\t    idx;\n\n\tml_flush_line(buf);\n\n\t/*\n\t * Find the data block containing the line.\n\t * This also fills the stack with the blocks from the root to the data\n\t * block and releases any locked block.\n\t */\n\tif ((hp = ml_find_line(buf, lnum, ML_FIND)) == NULL)\n\t{\n\t    if (recursive == 0)\n\t    {\n\t\t// Avoid giving this message for a recursive call, may happen\n\t\t// when the GUI redraws part of the text.\n\t\t++recursive;\n\t\tget_trans_bufname(buf);\n\t\tshorten_dir(NameBuff);\n\t\tsiemsg(_(e_ml_get_cannot_find_line_nr_in_buffer_nr_str),\n\t\t\t\t\t\t  lnum, buf->b_fnum, NameBuff);\n\t\t--recursive;\n\t    }\n\t    goto errorret;\n\t}\n\n\tdp = (DATA_BL *)(hp->bh_data);\n\n\tidx = lnum - buf->b_ml.ml_locked_low;\n\tstart = ((dp->db_index[idx]) & DB_INDEX_MASK);\n\t// The text ends where the previous line starts.  The first line ends\n\t// at the end of the block.\n\tif (idx == 0)\n\t    end = dp->db_txt_end;\n\telse\n\t    end = ((dp->db_index[idx - 1]) & DB_INDEX_MASK);\n\tlen = end - start;\n\n\tbuf->b_ml.ml_line_ptr = (char_u *)dp + start;\n\tbuf->b_ml.ml_line_len = len;\n\tbuf->b_ml.ml_line_lnum = lnum;\n\tbuf->b_ml.ml_flags &= ~ML_LINE_DIRTY;\n    }\n    if (will_change)\n\tbuf->b_ml.ml_flags |= (ML_LOCKED_DIRTY | ML_LOCKED_POS);\n\n    return buf->b_ml.ml_line_ptr;\n}\n\n// ml_get_cursor from src/memline.c:\n    char_u * /* <=== ml_get_cursor */ \nml_get_cursor(void)\n{\n    return (ml_get_buf(curbuf, curwin->w_cursor.lnum, FALSE) +\n\t\t\t\t\t\t\tcurwin->w_cursor.col);\n}\n\n// ml_flush_line from src/memline.c:\n    static void /* <=== ml_flush_line */ \nml_flush_line(buf_T *buf)\n{\n    bhdr_T\t*hp;\n    DATA_BL\t*dp;\n    linenr_T\tlnum;\n    char_u\t*new_line;\n    char_u\t*old_line;\n    colnr_T\tnew_len;\n    int\t\told_len;\n    int\t\textra;\n    int\t\tidx;\n    int\t\tstart;\n    int\t\tcount;\n    int\t\ti;\n    static int  entered = FALSE;\n\n    if (buf->b_ml.ml_line_lnum == 0 || buf->b_ml.ml_mfp == NULL)\n\treturn;\t\t// nothing to do\n\n    if (buf->b_ml.ml_flags & ML_LINE_DIRTY)\n    {\n\t// This code doesn't work recursively, but Netbeans may call back here\n\t// when obtaining the cursor position.\n\tif (entered)\n\t    return;\n\tentered = TRUE;\n\n\tlnum = buf->b_ml.ml_line_lnum;\n\tnew_line = buf->b_ml.ml_line_ptr;\n\n\thp = ml_find_line(buf, lnum, ML_FIND);\n\tif (hp == NULL)\n\t    siemsg(_(e_cannot_find_line_nr), lnum);\n\telse\n\t{\n\t    dp = (DATA_BL *)(hp->bh_data);\n\t    idx = lnum - buf->b_ml.ml_locked_low;\n\t    start = ((dp->db_index[idx]) & DB_INDEX_MASK);\n\t    old_line = (char_u *)dp + start;\n\t    if (idx == 0)\t// line is last in block\n\t\told_len = dp->db_txt_end - start;\n\t    else\t\t// text of previous line follows\n\t\told_len = (dp->db_index[idx - 1] & DB_INDEX_MASK) - start;\n\t    new_len = buf->b_ml.ml_line_len;\n\t    extra = new_len - old_len;\t    // negative if lines gets smaller\n\n\t    /*\n\t     * if new line fits in data block, replace directly\n\t     */\n\t    if ((int)dp->db_free >= extra)\n\t    {\n#if defined(FEAT_BYTEOFF) && defined(FEAT_PROP_POPUP)\n\t\tint old_prop_len = 0;\n\t\tif (buf->b_has_textprop)\n\t\t    old_prop_len = old_len - (int)STRLEN(old_line) - 1;\n#endif\n\t\t// if the length changes and there are following lines\n\t\tcount = buf->b_ml.ml_locked_high - buf->b_ml.ml_locked_low + 1;\n\t\tif (extra != 0 && idx < count - 1)\n\t\t{\n\t\t    // move text of following lines\n\t\t    mch_memmove((char *)dp + dp->db_txt_start - extra,\n\t\t\t\t(char *)dp + dp->db_txt_start,\n\t\t\t\t(size_t)(start - dp->db_txt_start));\n\n\t\t    // adjust pointers of this and following lines\n\t\t    for (i = idx + 1; i < count; ++i)\n\t\t\tdp->db_index[i] -= extra;\n\t\t}\n\t\tdp->db_index[idx] -= extra;\n\n\t\t// adjust free space\n\t\tdp->db_free -= extra;\n\t\tdp->db_txt_start -= extra;\n\n\t\t// copy new line into the data block\n\t\tmch_memmove(old_line - extra, new_line, (size_t)new_len);\n\t\tbuf->b_ml.ml_flags |= (ML_LOCKED_DIRTY | ML_LOCKED_POS);\n#if defined(FEAT_BYTEOFF) && defined(FEAT_PROP_POPUP)\n\t\t// The else case is already covered by the insert and delete\n\t\tif (buf->b_has_textprop)\n\t\t{\n\t\t    // Do not count the size of any text properties.\n\t\t    extra += old_prop_len;\n\t\t    extra -= new_len - (int)STRLEN(new_line) - 1;\n\t\t}\n\t\tif (extra != 0)\n\t\t    ml_updatechunk(buf, lnum, (long)extra, ML_CHNK_UPDLINE);\n#endif\n\t    }\n\t    else\n\t    {\n\t\t/*\n\t\t * Cannot do it in one data block: Delete and append.\n\t\t * Append first, because ml_delete_int() cannot delete the\n\t\t * last line in a buffer, which causes trouble for a buffer\n\t\t * that has only one line.\n\t\t * Don't forget to copy the mark!\n\t\t */\n\t\t// How about handling errors???\n\t\t(void)ml_append_int(buf, lnum, new_line, new_len,\n\t\t\t ((dp->db_index[idx] & DB_MARKED) ? ML_APPEND_MARK : 0)\n#ifdef FEAT_PROP_POPUP\n\t\t\t     | ML_APPEND_NOPROP\n#endif\n\t\t\t );\n\t\t(void)ml_delete_int(buf, lnum, ML_DEL_NOPROP);\n\t    }\n\t}\n\tvim_free(new_line);\n\n\tentered = FALSE;\n    }\n\n    buf->b_ml.ml_line_lnum = 0;\n}\n"
  },
  {
    "repository": "gpac",
    "cve_id": "CVE-2021-40592",
    "cwe_list": [
      "CWE-703"
    ],
    "commit_hash": "71460d72ec07df766dab0a4d52687529f3efcf0a",
    "short_hash": "71460d72",
    "vulnerableMethods_before": [
      {
        "filename": "isoffin_read.c",
        "method_name": "vulnerable_function",
        "raw_code": "static GF_Err isoffin_process(GF_Filter *filter)\n{\n\tISOMReader *read = gf_filter_get_udta(filter);\n\tu32 i, count = gf_list_count(read->channels);\n\tBool is_active = GF_FALSE;\n\tBool in_is_eos = GF_FALSE;\n\tBool check_forced_end = GF_FALSE;\n\tBool has_new_data = GF_FALSE;\n\tu64 min_offset_plus_one = 0;\n\tu32 nb_forced_end=0;\n\tif (read->in_error)\n\t\treturn read->in_error;\n\n\tif (read->pid) {\n\t\tBool fetch_input = GF_TRUE;\n\n\t\t//we failed at loading the init segment during a dash switch, retry\n\t\tif (!read->is_partial_download && !read->mem_load_mode && (read->moov_not_loaded==2) ) {\n\t\t\tisoffin_configure_pid(filter, read->pid, GF_FALSE);\n\t\t\tif (read->moov_not_loaded) return GF_OK;\n\t\t}\n\t\tif (read->mem_load_mode==2) {\n\t\t\tif (!read->force_fetch && read->mem_blob.size > read->mstore_size) {\n\t\t\t\tfetch_input = GF_FALSE;\n\t\t\t}\n\t\t\tread->force_fetch = GF_FALSE;\n\t\t}\n\t\twhile (fetch_input) {\n\t\t\tGF_FilterPacket *pck = gf_filter_pid_get_packet(read->pid);\n\t\t\tif (!pck) {\n\t\t\t\t//we issued a seek, wait for the first packet to be received before fetching channels\n\t\t\t\t//otherwise we could end up reading from the wrong cache\n\t\t\t\tif (read->wait_for_source) {\n\t\t\t\t\t//something went wrong during the seek request\n\t\t\t\t\tif (gf_filter_pid_is_eos(read->pid))\n\t\t\t\t\t\treturn GF_EOS;\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tread->wait_for_source = GF_FALSE;\n\n\t\t\tif (read->mem_load_mode) {\n\t\t\t\tu32 data_size;\n\t\t\t\tconst u8 *pck_data = gf_filter_pck_get_data(pck, &data_size);\n\t\t\t\tisoffin_push_buffer(filter, read, pck_data, data_size);\n\t\t\t}\n\t\t\t//we just had a switch but init seg is not completely done: input packet is only a part of the init, drop it\n\t\t\telse if (read->moov_not_loaded==2) {\n\t\t\t\tgf_filter_pid_drop_packet(read->pid);\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tgf_filter_pid_drop_packet(read->pid);\n\t\t\thas_new_data = GF_TRUE;\n\t\t\tif (read->in_error)\n\t\t\t\treturn read->in_error;\n\t\t}\n\t\tif (gf_filter_pid_is_eos(read->pid)) {\n\t\t\tread->input_loaded = GF_TRUE;\n\t\t\tin_is_eos = GF_TRUE;\n\t\t}\n\t\tif (read->input_is_stop) {\n\t\t\tread->input_loaded = GF_TRUE;\n\t\t\tin_is_eos = GF_TRUE;\n\t\t\tread->input_is_stop = GF_FALSE;\n\t\t}\n\t\tif (!read->frag_type && read->input_loaded) {\n\t\t\tin_is_eos = GF_TRUE;\n\t\t}\n        //segment is invalid, wait for eos on input an send eos on all channels\n        if (read->invalid_segment) {\n            if (!in_is_eos) return GF_OK;\n            read->invalid_segment = GF_FALSE;\n\n            for (i=0; i<count; i++) {\n                ISOMChannel *ch = gf_list_get(read->channels, i);\n                if (!ch->playing) {\n                    continue;\n                }\n                if (!ch->eos_sent) {\n                    ch->eos_sent = GF_TRUE;\n                    gf_filter_pid_set_eos(ch->pid);\n                }\n            }\n            read->eos_signaled = GF_TRUE;\n            return GF_EOS;\n        }\n\t} else if (read->extern_mov) {\n\t\tin_is_eos = GF_TRUE;\n\t\tread->input_loaded = GF_TRUE;\n\t}\n\tif (read->moov_not_loaded==1) {\n\t\tif (read->mem_load_mode)\n\t\t\treturn GF_OK;\n\t\tread->moov_not_loaded = GF_FALSE;\n\t\treturn isoffin_setup(filter, read);\n\t}\n\n\tif (read->refresh_fragmented) {\n\t\tconst GF_PropertyValue *prop;\n\n\t\tif (in_is_eos) {\n\t\t\tread->refresh_fragmented = GF_FALSE;\n\t\t} else {\n\t\t\tprop = gf_filter_pid_get_property(read->pid, GF_PROP_PID_FILE_CACHED);\n\t\t\tif (prop && prop->value.boolean)\n\t\t\t\tread->refresh_fragmented = GF_FALSE;\n\t\t}\n\n\t\tif (has_new_data) {\n\t\t\tu64 bytesMissing=0;\n\t\t\tGF_Err e;\n\t\t\tconst char *new_url = NULL;\n\t\t\tprop = gf_filter_pid_get_property(read->pid, GF_PROP_PID_FILEPATH);\n\t\t\tif (prop) new_url = prop->value.string;\n\n\t\t\te = gf_isom_refresh_fragmented(read->mov, &bytesMissing, new_url);\n\n\t\t\tif (e && (e!= GF_ISOM_INCOMPLETE_FILE)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[IsoMedia] Failed to refresh current segment: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\tread->refresh_fragmented = GF_FALSE;\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[IsoMedia] Refreshing current segment at UTC \"LLU\" - \"LLU\" bytes still missing - input is EOS %d\\n\", gf_net_get_utc(), bytesMissing, in_is_eos));\n\t\t\t}\n\n\t\t\tif (!read->refresh_fragmented && (e==GF_ISOM_INCOMPLETE_FILE)) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[IsoMedia] Incomplete Segment received - \"LLU\" bytes missing but EOF found\\n\", bytesMissing ));\n\t\t\t}\n\n#ifndef GPAC_DISABLE_LOG\n\t\t\tif (gf_log_tool_level_on(GF_LOG_DASH, GF_LOG_DEBUG)) {\n\t\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\t\tISOMChannel *ch = gf_list_get(read->channels, i);\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[IsoMedia] refresh track %d fragment - cur sample %d - new sample count %d\\n\", ch->track, ch->sample_num, gf_isom_get_sample_count(ch->owner->mov, ch->track) ));\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tisor_check_producer_ref_time(read);\n\t\t\tif (!read->frag_type)\n\t\t\t\tread->refresh_fragmented = GF_FALSE;\n\t\t}\n\t}\n\n\tfor (i=0; i<count; i++) {\n\t\tu8 *data;\n\t\tu32 nb_pck=50;\n\t\tISOMChannel *ch;\n\t\tch = gf_list_get(read->channels, i);\n\t\tif (!ch->playing) {\n\t\t\tnb_forced_end++;\n\t\t\tcontinue;\n\t\t}\n\t\t//eos not sent on this channel, we are active\n\t\tif (!ch->eos_sent)\n\t\t\tis_active = GF_TRUE;\n\n\t\twhile (nb_pck) {\n\t\t\tch->sample_data_offset = 0;\n\t\t\tif (!read->full_segment_flush && gf_filter_pid_would_block(ch->pid) )\n\t\t\t\tbreak;\n\n\t\t\tif (ch->item_id) {\n\t\t\t\tisor_reader_get_sample_from_item(ch);\n\t\t\t} else {\n\t\t\t\tisor_reader_get_sample(ch);\n\t\t\t}\n\n\t\t\tif (read->stsd && (ch->last_sample_desc_index != read->stsd) && ch->sample) {\n\t\t\t\tisor_reader_release_sample(ch);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ch->sample) {\n\t\t\t\tu32 sample_dur;\n\t\t\t\tu8 dep_flags;\n\t\t\t\tu8 *subs_buf;\n\t\t\t\tu32 subs_buf_size;\n\t\t\t\tGF_FilterPacket *pck;\n\t\t\t\tif (ch->needs_pid_reconfig) {\n\t\t\t\t\tisor_update_channel_config(ch);\n\t\t\t\t\tch->needs_pid_reconfig = GF_FALSE;\n\t\t\t\t}\n\n\t\t\t\t//we have at least two samples, update GF_PROP_PID_HAS_SYNC if needed\n\t\t\t\tif (ch->check_has_rap && (gf_isom_get_sample_count(ch->owner->mov, ch->track)>1) && (gf_isom_has_sync_points(ch->owner->mov, ch->track)==1)) {\n\t\t\t\t\tch->check_has_rap = GF_FALSE;\n\t\t\t\t\tch->has_rap = GF_TRUE;\n\t\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_HAS_SYNC, &PROP_BOOL(ch->has_rap) );\n\t\t\t\t}\n\n\t\t\t\t//strip param sets from payload, trigger reconfig if needed\n\t\t\t\tisor_reader_check_config(ch);\n\n\t\t\t\tif (read->nodata) {\n\t\t\t\t\tpck = gf_filter_pck_new_shared(ch->pid, NULL, ch->sample->dataLength, NULL);\n\t\t\t\t\tif (!pck) return GF_OUT_OF_MEM;\n\t\t\t\t} else {\n\t\t\t\t\tpck = gf_filter_pck_new_alloc(ch->pid, ch->sample->dataLength, &data);\n\t\t\t\t\tif (!pck) return GF_OUT_OF_MEM;\n\n\t\t\t\t\tmemcpy(data, ch->sample->data, ch->sample->dataLength);\n\t\t\t\t}\n\t\t\t\tgf_filter_pck_set_dts(pck, ch->dts);\n\t\t\t\tgf_filter_pck_set_cts(pck, ch->cts);\n\t\t\t\tif (ch->sample->IsRAP==-1) {\n\t\t\t\t\tgf_filter_pck_set_sap(pck, GF_FILTER_SAP_1);\n\t\t\t\t\tch->redundant = 1;\n\t\t\t\t} else {\n\t\t\t\t\tgf_filter_pck_set_sap(pck, (GF_FilterSAPType) ch->sample->IsRAP);\n\t\t\t\t}\n\n\t\t\t\tif (ch->sap_3)\n\t\t\t\t\tgf_filter_pck_set_sap(pck, GF_FILTER_SAP_3);\n\t\t\t\telse if (ch->sap_4_type) {\n\t\t\t\t\tgf_filter_pck_set_sap(pck, (ch->sap_4_type==GF_ISOM_SAMPLE_PREROLL) ? GF_FILTER_SAP_4_PROL : GF_FILTER_SAP_4);\n\t\t\t\t\tgf_filter_pck_set_roll_info(pck, ch->roll);\n\t\t\t\t}\n\n\t\t\t\tsample_dur = ch->au_duration;\n\t\t\t\tif (ch->sample->nb_pack)\n\t\t\t\t\tsample_dur *= ch->sample->nb_pack;\n\t\t\t\tgf_filter_pck_set_duration(pck, sample_dur);\n\t\t\t\tgf_filter_pck_set_seek_flag(pck, ch->seek_flag);\n\n\t\t\t\t//for now we only signal xPS mask for non-sap\n\t\t\t\tif (ch->xps_mask && !gf_filter_pck_get_sap(pck) ) {\n\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_XPS_MASK, &PROP_UINT(ch->xps_mask) );\n\t\t\t\t}\n\n\t\t\t\tdep_flags = ch->isLeading;\n\t\t\t\tdep_flags <<= 2;\n\t\t\t\tdep_flags |= ch->dependsOn;\n\t\t\t\tdep_flags <<= 2;\n\t\t\t\tdep_flags |= ch->dependedOn;\n\t\t\t\tdep_flags <<= 2;\n\t\t\t\tdep_flags |= ch->redundant;\n\n\t\t\t\tif (dep_flags)\n\t\t\t\t\tgf_filter_pck_set_dependency_flags(pck, dep_flags);\n\n\t\t\t\tgf_filter_pck_set_crypt_flags(pck, ch->pck_encrypted ? GF_FILTER_PCK_CRYPT : 0);\n\t\t\t\tgf_filter_pck_set_seq_num(pck, ch->sample_num);\n\n\n\t\t\t\tsubs_buf = gf_isom_sample_get_subsamples_buffer(read->mov, ch->track, ch->sample_num, &subs_buf_size);\n\t\t\t\tif (subs_buf) {\n\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_SUBS, &PROP_DATA_NO_COPY(subs_buf, subs_buf_size) );\n\t\t\t\t}\n\n\t\t\t\tif (ch->sai_buffer && ch->pck_encrypted) {\n\t\t\t\t\tassert(ch->sai_buffer_size);\n\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_CENC_SAI, &PROP_DATA(ch->sai_buffer, ch->sai_buffer_size) );\n\t\t\t\t}\n\n\t\t\t\tif (read->sigfrag) {\n\t\t\t\t\tGF_ISOFragmentBoundaryInfo finfo;\n\t\t\t\t\tif (gf_isom_sample_is_fragment_start(read->mov, ch->track, ch->sample_num, &finfo) ) {\n\t\t\t\t\t\tu64 start=0;\n\t\t\t\t\t\tu32 traf_start = finfo.seg_start_plus_one ? 2 : 1;\n\n\t\t\t\t\t\tif (finfo.seg_start_plus_one)\n\t\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_CUE_START, &PROP_BOOL(GF_TRUE));\n\n\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_FRAG_START, &PROP_UINT(traf_start));\n\n\t\t\t\t\t\tstart = finfo.frag_start;\n\t\t\t\t\t\tif (finfo.seg_start_plus_one) start = finfo.seg_start_plus_one-1;\n\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_FRAG_RANGE, &PROP_FRAC64_INT(start, finfo.mdat_end));\n\t\t\t\t\t\tif (finfo.moof_template) {\n\t\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_MOOF_TEMPLATE, &PROP_DATA((u8 *)finfo.moof_template, finfo.moof_template_size));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (finfo.sidx_end) {\n\t\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_SIDX_RANGE, &PROP_FRAC64_INT(finfo.sidx_start , finfo.sidx_end));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (read->seg_name_changed) {\n\t\t\t\t\t\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property(read->pid, GF_PROP_PID_URL);\n\t\t\t\t\t\t\tread->seg_name_changed = GF_FALSE;\n\t\t\t\t\t\t\tif (p && p->value.string) {\n\t\t\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PID_URL, &PROP_STRING(p->value.string));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ch->sender_ntp) {\n\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_SENDER_NTP, &PROP_LONGUINT(ch->sender_ntp));\n\t\t\t\t\tif (ch->ntp_at_server_ntp) {\n\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_RECEIVER_NTP, &PROP_LONGUINT(ch->ntp_at_server_ntp));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tch->eos_sent = GF_FALSE;\n\n\t\t\t\t//this might not be the true end of stream\n\t\t\t\tif ((ch->streamType==GF_STREAM_AUDIO) && (ch->sample_num == gf_isom_get_sample_count(read->mov, ch->track))) {\n\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_END_RANGE, &PROP_BOOL(GF_TRUE));\n\t\t\t\t}\n\n\t\t\t\tgf_filter_pck_send(pck);\n\t\t\t\tisor_reader_release_sample(ch);\n\n\t\t\t\tch->last_valid_sample_data_offset = ch->sample_data_offset;\n\t\t\t\tnb_pck--;\n\t\t\t} else if (ch->last_state==GF_EOS) {\n\t\t\t\tif (ch->playing == 2) {\n\t\t\t\t\tif (in_is_eos) {\n\t\t\t\t\t\tch->playing = GF_FALSE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnb_forced_end++;\n\t\t\t\t\t\tcheck_forced_end = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (in_is_eos && !ch->eos_sent) {\n\t\t\t\t\tvoid *tfrf;\n\t\t\t\t\tconst void *gf_isom_get_tfrf(GF_ISOFile *movie, u32 trackNumber);\n\n\t\t\t\t\tch->eos_sent = GF_TRUE;\n\t\t\t\t\tread->eos_signaled = GF_TRUE;\n\n\t\t\t\t\ttfrf = (void *) gf_isom_get_tfrf(read->mov, ch->track);\n\t\t\t\t\tif (tfrf) {\n\t\t\t\t\t\tgf_filter_pid_set_info_str(ch->pid, \"smooth_tfrf\", &PROP_POINTER(tfrf) );\n\t\t\t\t\t\tch->last_has_tfrf = GF_TRUE;\n\t\t\t\t\t} else if (ch->last_has_tfrf) {\n\t\t\t\t\t\tgf_filter_pid_set_info_str(ch->pid, \"smooth_tfrf\", NULL);\n\t\t\t\t\t\tch->last_has_tfrf = GF_FALSE;\n\t\t\t\t\t}\n\n\t\t\t\t\tgf_filter_pid_set_eos(ch->pid);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tread->force_fetch = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!min_offset_plus_one || (min_offset_plus_one - 1 > ch->last_valid_sample_data_offset))\n\t\t\tmin_offset_plus_one = 1 + ch->last_valid_sample_data_offset;\n\t}\n\tif (read->mem_load_mode && min_offset_plus_one) {\n\t\tisoffin_purge_mem(read, min_offset_plus_one-1);\n\t}\n\n\t//we reached end of playback due to play range request, we must send eos - however for safety reason with DASH, we first need to cancel the input\n\tif (read->pid && check_forced_end && (nb_forced_end==count)) {\n\t\t//abort input\n\t\tGF_FilterEvent evt;\n\t\tGF_FEVT_INIT(evt, GF_FEVT_STOP, read->pid);\n\t\tgf_filter_pid_send_event(read->pid, &evt);\n\t}\n\n\n\tif (!is_active) {\n\t\treturn GF_EOS;\n\t}\n\t//if (in_is_eos)\n//\tgf_filter_ask_rt_reschedule(filter, 1);\n\treturn GF_OK;\n\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "isoffin_read.c",
        "method_name": "fixed_function",
        "raw_code": "static GF_Err isoffin_process(GF_Filter *filter)\n{\n\tISOMReader *read = gf_filter_get_udta(filter);\n\tu32 i, count = gf_list_count(read->channels);\n\tBool is_active = GF_FALSE;\n\tBool in_is_eos = GF_FALSE;\n\tBool check_forced_end = GF_FALSE;\n\tBool has_new_data = GF_FALSE;\n\tu64 min_offset_plus_one = 0;\n\tu32 nb_forced_end=0;\n\tif (read->in_error)\n\t\treturn read->in_error;\n\n\tif (read->pid) {\n\t\tBool fetch_input = GF_TRUE;\n\n\t\t//we failed at loading the init segment during a dash switch, retry\n\t\tif (!read->is_partial_download && !read->mem_load_mode && (read->moov_not_loaded==2) ) {\n\t\t\tisoffin_configure_pid(filter, read->pid, GF_FALSE);\n\t\t\tif (read->moov_not_loaded) return GF_OK;\n\t\t}\n\t\tif (read->mem_load_mode==2) {\n\t\t\tif (!read->force_fetch && read->mem_blob.size > read->mstore_size) {\n\t\t\t\tfetch_input = GF_FALSE;\n\t\t\t}\n\t\t\tread->force_fetch = GF_FALSE;\n\t\t}\n\t\twhile (fetch_input) {\n\t\t\tGF_FilterPacket *pck = gf_filter_pid_get_packet(read->pid);\n\t\t\tif (!pck) {\n\t\t\t\t//we issued a seek, wait for the first packet to be received before fetching channels\n\t\t\t\t//otherwise we could end up reading from the wrong cache\n\t\t\t\tif (read->wait_for_source) {\n\t\t\t\t\t//something went wrong during the seek request\n\t\t\t\t\tif (gf_filter_pid_is_eos(read->pid))\n\t\t\t\t\t\treturn GF_EOS;\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tread->wait_for_source = GF_FALSE;\n\n\t\t\tif (read->mem_load_mode) {\n\t\t\t\tu32 data_size;\n\t\t\t\tconst u8 *pck_data = gf_filter_pck_get_data(pck, &data_size);\n\t\t\t\tisoffin_push_buffer(filter, read, pck_data, data_size);\n\t\t\t}\n\t\t\t//we just had a switch but init seg is not completely done: input packet is only a part of the init, drop it\n\t\t\telse if (read->moov_not_loaded==2) {\n\t\t\t\tgf_filter_pid_drop_packet(read->pid);\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tgf_filter_pid_drop_packet(read->pid);\n\t\t\thas_new_data = GF_TRUE;\n\t\t\tif (read->in_error)\n\t\t\t\treturn read->in_error;\n\t\t}\n\t\tif (gf_filter_pid_is_eos(read->pid)) {\n\t\t\tread->input_loaded = GF_TRUE;\n\t\t\tin_is_eos = GF_TRUE;\n\t\t}\n\t\tif (read->input_is_stop) {\n\t\t\tread->input_loaded = GF_TRUE;\n\t\t\tin_is_eos = GF_TRUE;\n\t\t\tread->input_is_stop = GF_FALSE;\n\t\t}\n\t\tif (!read->frag_type && read->input_loaded) {\n\t\t\tin_is_eos = GF_TRUE;\n\t\t}\n        //segment is invalid, wait for eos on input an send eos on all channels\n        if (read->invalid_segment) {\n            if (!in_is_eos) return GF_OK;\n            read->invalid_segment = GF_FALSE;\n\n            for (i=0; i<count; i++) {\n                ISOMChannel *ch = gf_list_get(read->channels, i);\n                if (!ch->playing) {\n                    continue;\n                }\n                if (!ch->eos_sent) {\n                    ch->eos_sent = GF_TRUE;\n                    gf_filter_pid_set_eos(ch->pid);\n                }\n            }\n            read->eos_signaled = GF_TRUE;\n            return GF_EOS;\n        }\n\t} else if (read->extern_mov) {\n\t\tin_is_eos = GF_TRUE;\n\t\tread->input_loaded = GF_TRUE;\n\t}\n\tif (read->moov_not_loaded==1) {\n\t\tif (read->mem_load_mode)\n\t\t\treturn GF_OK;\n\t\tread->moov_not_loaded = GF_FALSE;\n\t\treturn isoffin_setup(filter, read);\n\t}\n\n\tif (read->refresh_fragmented) {\n\t\tconst GF_PropertyValue *prop;\n\n\t\tif (in_is_eos) {\n\t\t\tread->refresh_fragmented = GF_FALSE;\n\t\t} else {\n\t\t\tprop = gf_filter_pid_get_property(read->pid, GF_PROP_PID_FILE_CACHED);\n\t\t\tif (prop && prop->value.boolean)\n\t\t\t\tread->refresh_fragmented = GF_FALSE;\n\t\t}\n\n\t\tif (has_new_data) {\n\t\t\tu64 bytesMissing=0;\n\t\t\tGF_Err e;\n\t\t\tconst char *new_url = NULL;\n\t\t\tprop = gf_filter_pid_get_property(read->pid, GF_PROP_PID_FILEPATH);\n\t\t\tif (prop) new_url = prop->value.string;\n\n\t\t\te = gf_isom_refresh_fragmented(read->mov, &bytesMissing, new_url);\n\n\t\t\tif (e && (e!= GF_ISOM_INCOMPLETE_FILE)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[IsoMedia] Failed to refresh current segment: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\tread->refresh_fragmented = GF_FALSE;\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[IsoMedia] Refreshing current segment at UTC \"LLU\" - \"LLU\" bytes still missing - input is EOS %d\\n\", gf_net_get_utc(), bytesMissing, in_is_eos));\n\t\t\t}\n\n\t\t\tif (!read->refresh_fragmented && (e==GF_ISOM_INCOMPLETE_FILE)) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[IsoMedia] Incomplete Segment received - \"LLU\" bytes missing but EOF found\\n\", bytesMissing ));\n\t\t\t}\n\n#ifndef GPAC_DISABLE_LOG\n\t\t\tif (gf_log_tool_level_on(GF_LOG_DASH, GF_LOG_DEBUG)) {\n\t\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\t\tISOMChannel *ch = gf_list_get(read->channels, i);\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[IsoMedia] refresh track %d fragment - cur sample %d - new sample count %d\\n\", ch->track, ch->sample_num, gf_isom_get_sample_count(ch->owner->mov, ch->track) ));\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tisor_check_producer_ref_time(read);\n\t\t\tif (!read->frag_type)\n\t\t\t\tread->refresh_fragmented = GF_FALSE;\n\t\t}\n\t}\n\n\tfor (i=0; i<count; i++) {\n\t\tu8 *data;\n\t\tu32 nb_pck=50;\n\t\tISOMChannel *ch;\n\t\tch = gf_list_get(read->channels, i);\n\t\tif (!ch->playing) {\n\t\t\tnb_forced_end++;\n\t\t\tcontinue;\n\t\t}\n\t\t//eos not sent on this channel, we are active\n\t\tif (!ch->eos_sent)\n\t\t\tis_active = GF_TRUE;\n\n\t\twhile (nb_pck) {\n\t\t\tch->sample_data_offset = 0;\n\t\t\tif (!read->full_segment_flush && gf_filter_pid_would_block(ch->pid) )\n\t\t\t\tbreak;\n\n\t\t\tif (ch->item_id) {\n\t\t\t\tisor_reader_get_sample_from_item(ch);\n\t\t\t} else {\n\t\t\t\tisor_reader_get_sample(ch);\n\t\t\t}\n\n\t\t\tif (read->stsd && (ch->last_sample_desc_index != read->stsd) && ch->sample) {\n\t\t\t\tisor_reader_release_sample(ch);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ch->sample) {\n\t\t\t\tu32 sample_dur;\n\t\t\t\tu8 dep_flags;\n\t\t\t\tu8 *subs_buf;\n\t\t\t\tu32 subs_buf_size;\n\t\t\t\tGF_FilterPacket *pck;\n\t\t\t\tif (ch->needs_pid_reconfig) {\n\t\t\t\t\tisor_update_channel_config(ch);\n\t\t\t\t\tch->needs_pid_reconfig = GF_FALSE;\n\t\t\t\t}\n\n\t\t\t\t//we have at least two samples, update GF_PROP_PID_HAS_SYNC if needed\n\t\t\t\tif (ch->check_has_rap && (gf_isom_get_sample_count(ch->owner->mov, ch->track)>1) && (gf_isom_has_sync_points(ch->owner->mov, ch->track)==1)) {\n\t\t\t\t\tch->check_has_rap = GF_FALSE;\n\t\t\t\t\tch->has_rap = GF_TRUE;\n\t\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_HAS_SYNC, &PROP_BOOL(ch->has_rap) );\n\t\t\t\t}\n\n\t\t\t\t//strip param sets from payload, trigger reconfig if needed\n\t\t\t\tisor_reader_check_config(ch);\n\n\t\t\t\tif (read->nodata) {\n\t\t\t\t\tpck = gf_filter_pck_new_shared(ch->pid, NULL, ch->sample->dataLength, NULL);\n\t\t\t\t\tif (!pck) return GF_OUT_OF_MEM;\n\t\t\t\t} else {\n\t\t\t\t\tpck = gf_filter_pck_new_alloc(ch->pid, ch->sample->dataLength, &data);\n\t\t\t\t\tif (!pck) return GF_OUT_OF_MEM;\n\n\t\t\t\t\tmemcpy(data, ch->sample->data, ch->sample->dataLength);\n\t\t\t\t}\n\t\t\t\tgf_filter_pck_set_dts(pck, ch->dts);\n\t\t\t\tgf_filter_pck_set_cts(pck, ch->cts);\n\t\t\t\tif (ch->sample->IsRAP==-1) {\n\t\t\t\t\tgf_filter_pck_set_sap(pck, GF_FILTER_SAP_1);\n\t\t\t\t\tch->redundant = 1;\n\t\t\t\t} else {\n\t\t\t\t\tgf_filter_pck_set_sap(pck, (GF_FilterSAPType) ch->sample->IsRAP);\n\t\t\t\t}\n\n\t\t\t\tif (ch->sap_3)\n\t\t\t\t\tgf_filter_pck_set_sap(pck, GF_FILTER_SAP_3);\n\t\t\t\telse if (ch->sap_4_type) {\n\t\t\t\t\tgf_filter_pck_set_sap(pck, (ch->sap_4_type==GF_ISOM_SAMPLE_PREROLL) ? GF_FILTER_SAP_4_PROL : GF_FILTER_SAP_4);\n\t\t\t\t\tgf_filter_pck_set_roll_info(pck, ch->roll);\n\t\t\t\t}\n\n\t\t\t\tsample_dur = ch->au_duration;\n\t\t\t\tif (ch->sample->nb_pack)\n\t\t\t\t\tsample_dur *= ch->sample->nb_pack;\n\t\t\t\tgf_filter_pck_set_duration(pck, sample_dur);\n\t\t\t\tgf_filter_pck_set_seek_flag(pck, ch->seek_flag);\n\n\t\t\t\t//for now we only signal xPS mask for non-sap\n\t\t\t\tif (ch->xps_mask && !gf_filter_pck_get_sap(pck) ) {\n\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_XPS_MASK, &PROP_UINT(ch->xps_mask) );\n\t\t\t\t}\n\n\t\t\t\tdep_flags = ch->isLeading;\n\t\t\t\tdep_flags <<= 2;\n\t\t\t\tdep_flags |= ch->dependsOn;\n\t\t\t\tdep_flags <<= 2;\n\t\t\t\tdep_flags |= ch->dependedOn;\n\t\t\t\tdep_flags <<= 2;\n\t\t\t\tdep_flags |= ch->redundant;\n\n\t\t\t\tif (dep_flags)\n\t\t\t\t\tgf_filter_pck_set_dependency_flags(pck, dep_flags);\n\n\t\t\t\tgf_filter_pck_set_crypt_flags(pck, ch->pck_encrypted ? GF_FILTER_PCK_CRYPT : 0);\n\t\t\t\tgf_filter_pck_set_seq_num(pck, ch->sample_num);\n\n\n\t\t\t\tsubs_buf = gf_isom_sample_get_subsamples_buffer(read->mov, ch->track, ch->sample_num, &subs_buf_size);\n\t\t\t\tif (subs_buf) {\n\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_SUBS, &PROP_DATA_NO_COPY(subs_buf, subs_buf_size) );\n\t\t\t\t}\n\n\t\t\t\tif (ch->sai_buffer && ch->pck_encrypted) {\n\t\t\t\t\tassert(ch->sai_buffer_size);\n\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_CENC_SAI, &PROP_DATA(ch->sai_buffer, ch->sai_buffer_size) );\n\t\t\t\t}\n\n\t\t\t\tif (read->sigfrag) {\n\t\t\t\t\tGF_ISOFragmentBoundaryInfo finfo;\n\t\t\t\t\tif (gf_isom_sample_is_fragment_start(read->mov, ch->track, ch->sample_num, &finfo) ) {\n\t\t\t\t\t\tu64 start=0;\n\t\t\t\t\t\tu32 traf_start = finfo.seg_start_plus_one ? 2 : 1;\n\n\t\t\t\t\t\tif (finfo.seg_start_plus_one)\n\t\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_CUE_START, &PROP_BOOL(GF_TRUE));\n\n\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_FRAG_START, &PROP_UINT(traf_start));\n\n\t\t\t\t\t\tstart = finfo.frag_start;\n\t\t\t\t\t\tif (finfo.seg_start_plus_one) start = finfo.seg_start_plus_one-1;\n\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_FRAG_RANGE, &PROP_FRAC64_INT(start, finfo.mdat_end));\n\t\t\t\t\t\tif (finfo.moof_template) {\n\t\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_MOOF_TEMPLATE, &PROP_DATA((u8 *)finfo.moof_template, finfo.moof_template_size));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (finfo.sidx_end) {\n\t\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_SIDX_RANGE, &PROP_FRAC64_INT(finfo.sidx_start , finfo.sidx_end));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (read->seg_name_changed) {\n\t\t\t\t\t\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property(read->pid, GF_PROP_PID_URL);\n\t\t\t\t\t\t\tread->seg_name_changed = GF_FALSE;\n\t\t\t\t\t\t\tif (p && p->value.string) {\n\t\t\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PID_URL, &PROP_STRING(p->value.string));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ch->sender_ntp) {\n\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_SENDER_NTP, &PROP_LONGUINT(ch->sender_ntp));\n\t\t\t\t\tif (ch->ntp_at_server_ntp) {\n\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_RECEIVER_NTP, &PROP_LONGUINT(ch->ntp_at_server_ntp));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tch->eos_sent = GF_FALSE;\n\n\t\t\t\t//this might not be the true end of stream\n\t\t\t\tif ((ch->streamType==GF_STREAM_AUDIO) && (ch->sample_num == gf_isom_get_sample_count(read->mov, ch->track))) {\n\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_END_RANGE, &PROP_BOOL(GF_TRUE));\n\t\t\t\t}\n\n\t\t\t\tgf_filter_pck_send(pck);\n\t\t\t\tisor_reader_release_sample(ch);\n\n\t\t\t\tch->last_valid_sample_data_offset = ch->sample_data_offset;\n\t\t\t\tnb_pck--;\n\t\t\t} else if (ch->last_state==GF_EOS) {\n\t\t\t\tif (ch->playing == 2) {\n\t\t\t\t\tif (in_is_eos) {\n\t\t\t\t\t\tch->playing = GF_FALSE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnb_forced_end++;\n\t\t\t\t\t\tcheck_forced_end = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (in_is_eos && !ch->eos_sent) {\n\t\t\t\t\tvoid *tfrf;\n\t\t\t\t\tconst void *gf_isom_get_tfrf(GF_ISOFile *movie, u32 trackNumber);\n\n\t\t\t\t\tch->eos_sent = GF_TRUE;\n\t\t\t\t\tread->eos_signaled = GF_TRUE;\n\n\t\t\t\t\ttfrf = (void *) gf_isom_get_tfrf(read->mov, ch->track);\n\t\t\t\t\tif (tfrf) {\n\t\t\t\t\t\tgf_filter_pid_set_info_str(ch->pid, \"smooth_tfrf\", &PROP_POINTER(tfrf) );\n\t\t\t\t\t\tch->last_has_tfrf = GF_TRUE;\n\t\t\t\t\t} else if (ch->last_has_tfrf) {\n\t\t\t\t\t\tgf_filter_pid_set_info_str(ch->pid, \"smooth_tfrf\", NULL);\n\t\t\t\t\t\tch->last_has_tfrf = GF_FALSE;\n\t\t\t\t\t}\n\n\t\t\t\t\tgf_filter_pid_set_eos(ch->pid);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} else if (ch->last_state==GF_ISOM_INVALID_FILE) {\n\t\t\t\tif (!ch->eos_sent) {\n\t\t\t\t\tch->eos_sent = GF_TRUE;\n\t\t\t\t\tread->eos_signaled = GF_TRUE;\n\t\t\t\t\tgf_filter_pid_set_eos(ch->pid);\n\t\t\t\t}\n\t\t\t\treturn ch->last_state;\n\t\t\t} else {\n\t\t\t\tread->force_fetch = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!min_offset_plus_one || (min_offset_plus_one - 1 > ch->last_valid_sample_data_offset))\n\t\t\tmin_offset_plus_one = 1 + ch->last_valid_sample_data_offset;\n\t}\n\tif (read->mem_load_mode && min_offset_plus_one) {\n\t\tisoffin_purge_mem(read, min_offset_plus_one-1);\n\t}\n\n\t//we reached end of playback due to play range request, we must send eos - however for safety reason with DASH, we first need to cancel the input\n\tif (read->pid && check_forced_end && (nb_forced_end==count)) {\n\t\t//abort input\n\t\tGF_FilterEvent evt;\n\t\tGF_FEVT_INIT(evt, GF_FEVT_STOP, read->pid);\n\t\tgf_filter_pid_send_event(read->pid, &evt);\n\t}\n\n\n\tif (!is_active) {\n\t\treturn GF_EOS;\n\t}\n\t//if (in_is_eos)\n//\tgf_filter_ask_rt_reschedule(filter, 1);\n\treturn GF_OK;\n\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <gpac/crypt_tools.h>\n#include <gpac/media_tools.h>\n#include \"isoffin.h\"\n\n// Type Definitions:\n// u32:\ntypedef unsigned int u32;\n\n// u8:\ntypedef unsigned char u8;\n\n// ISOMChannel:\ntypedef struct\n{\n\tu32 track, track_id;\n\tu32 item_id, item_idx;\n\t/*base track if scalable media, 0 otherwise*/\n\tu32 base_track;\n\tu32 next_track;\n\tGF_FilterPid *pid;\n\tISOMReader *owner;\n\tu64 duration;\n\tBool last_has_tfrf;\n\n\t/*current sample*/\n\tGF_ISOSample *static_sample;\n\tGF_ISOSample *sample;\n\tu64 sample_data_offset, last_valid_sample_data_offset;\n\tGF_Err last_state;\n\tBool sap_3;\n\tGF_ISOSampleRollType sap_4_type;\n\ts32 roll;\n\tu32 xps_mask;\n\t\n\tBool has_edit_list;\n\tu32 sample_num;\n\ts64 ts_offset;\n/*\n\ts64 dts_offset;\n\tBool do_dts_shift_test;\n*/\n\n\t/*for edit lists*/\n\tu32 edit_sync_frame;\n\tu64 sample_time, last_rap_sample_time, start, end;\n\tDouble speed;\n\n\tu32 timescale;\n\tBool to_init, has_rap;\n\t//0: not playing, 1: playing 2: playing but end of range reached\n\tu32 playing;\n\tBool eos_sent;\n\tu8 streamType;\n\tBool initial_play_seen;\n\n\tBool is_encrypted, is_cenc;\n\n\tBool disable_seek;\n\tu32 nalu_extract_mode;\n\n\t//channel sample state\n\tu32 last_sample_desc_index;\n\tu32 isLeading, dependsOn, depend...\n\n// u64:\ntypedef unsigned int u64;\n\n// GF_PropertyValue:\ntypedef struct __gf_prop_val GF_PropertyValue;\n\n// GF_FilterEvent:\ntypedef union __gf_filter_event GF_FilterEvent;\n\n// GF_ISOFragmentBoundaryInfo:\ntypedef struct\n{\n\t/*! fragment start offset*/\n\tu64 frag_start;\n\t/*! mdat end offset*/\n\tu64 mdat_end;\n\t/*segment start offset plus one:\n\t\t0 if regular fragment, 1 if dash segment, offset indicates start of segment (styp or sidx)\n\t\tif sidx, it is writtent in the moof_template\n\t*/\n\tu64 seg_start_plus_one;\n\n\t/*! serialized array of styp (if present) sidx (if present) and moof with only the current traf*/\n\tconst u8 *moof_template;\n\t/*! size of serialized buffer*/\n\tu32 moof_template_size;\n\t/*! sidx start, 0 if absent*/\n\tu64 sidx_start;\n\t/*! sidx end, 0 if absent*/\n\tu64 sidx_end;\n}\n\n// Bool:\ntypedef enum {\n\tGF_FALSE = 0,\n\tGF_TRUE\n}\n\n// GF_FilterPacket:\ntypedef struct __gf_filter_pck GF_FilterPacket;\n\n// GF_Err:\ntypedef enum\n{\n\t/*!Message from any scripting engine used in the presentation (ECMAScript, MPEG-J, ...) (Info).*/\n\tGF_SCRIPT_INFO                                          = 3,\n\t/*!Indicates a send packet is not dispatched due to pending connections.*/\n\tGF_PENDING_PACKET\t\t\t\t\t= 2,\n\t/*!Indicates the end of a stream or of a file (Info).*/\n\tGF_EOS\t\t\t\t\t\t\t\t= 1,\n\t/*!\n\t\\n\\n\n\t*/\n\t/*!Operation success (no error).*/\n\tGF_OK\t\t\t\t\t\t\t\t= 0,\n\t/*!\\n*/\n\t/*!One of the input parameter is not correct or cannot be used in the current operating mode of the framework.*/\n\tGF_BAD_PARAM\t\t\t\t\t\t\t= -1,\n\t/*! Memory allocation failure.*/\n\tGF_OUT_OF_MEM\t\t\t\t\t\t\t= -2,\n\t/*! Input/Output failure (disk access, system call failures)*/\n\tGF_IO_ERR\t\t\t\t\t\t\t\t= -3,\n\t/*! The desired feature or operation is not supported by the framework*/\n\tGF_NOT_SUPPORTED\t\t\t\t\t\t= -4,\n\t/*! Input data has been corrupted*/\n\tGF_CORRUPTED_DATA\t\t\t\t\t\t= -5,\n\t/*! A modification was attempted on a scene node which could not be found*/\n\tGF_SG_UNKNOWN_NODE\t\t\t\t\t\t...\n\n// ISOMReader:\ntypedef struct\n{\n\tGF_InputService *input;\n\t/*the service we're responsible for*/\n\tGF_ClientService *service;\n\tLPNETCHANNEL channel;\n\n\t/*input file*/\n\tu32 time_scale;\n\n\tu32 base_track_id;\n\n\tstruct _tag_terminal *term;\n\n\tu32 cntr;\n\n\tu32 width;\n\tu32 height;\n\n\tBool started;\n\n\tJNIEnv* env;\n\tu8 isAttached;\n\tjclass camCtrlClass;\n\tjmethodID cid;\n\tjobject camCtrlObj;\n\tjmethodID startCamera;\n\tjmethodID stopCamera;\n\tjmethodID startProcessing;\n\tjmethodID stopProcessing;\n\tjmethodID getImageFormat;\n\tjmethodID getImageHeight;\n\tjmethodID getImageWidth;\n\tjmethodID getBitsPerPixel;\n\n}\n\n// GF_Filter:\ntypedef struct __gf_filter GF_Filter;\n\n// ISOMReader:\ntypedef struct\n{\n\t//options\n\tchar *src;\n\tBool allt, noedit, itt, itemid;\n\tu32 smode;\n\tu32 stsd;\n\tBool expart;\n\tBool alltk;\n\tu32 frame_size;\n\tchar* tkid;\n\tBool analyze;\n\tu32 xps_check;\n\tchar *catseg;\n\tBool sigfrag;\n\tBool nocrypt, strtxt, nodata;\n\tu32 mstore_purge, mstore_samples, mstore_size;\n\n\t//internal\n\n\tGF_Filter *filter;\n\n\t/*current channels*/\n\tGF_List *channels;\n\n\t/*input file*/\n\tGF_ISOFile *mov;\n\tBool extern_mov;\n\tu32 timescale;\n\tu32 nb_playing;\n\t//source data is completely available\n\tBool input_loaded;\n\t//fragmented file to be refreshed before processing it\n\tBool refresh_fragmented;\n\tBool input_is_stop;\n\tu64 missing_bytes, last_size;\n\n\tBool seg_name_changed;\n\tu32 play_only_track_id;\n\tu32 play_only_first_media;\n\tBool full_segment_flush;\n\t/*0: not fragmented - 1 fragmented - 2 fragmented and last fragment received*/\n\tu32 frag_type;\n\tBool waiting_for_data, reset_frag_state;\n\n\n\tu32 pending_scalable_enhancement_segment_index;\n\n\tBool in_data_flush;\n\tu32 has_pending_segments, nb_for...\n\n// Called Methods (top 10):\n// gf_filter_pid_drop_packet from src/filter_core/filter_pid.c:\nvoid gf_filter_pid_drop_packet(GF_FilterPid *pid) /* <=== gf_filter_pid_drop_packet */ \n{\n#ifdef GPAC_MEMORY_TRACKING\n\tu32 prev_nb_allocs, prev_nb_reallocs, nb_allocs, nb_reallocs;\n#endif\n\tu32 timescale = 0;\n\tu32 nb_pck=0;\n\tGF_FilterPacket *pck=NULL;\n\tGF_FilterPacketInstance *pcki;\n\tGF_FilterPidInst *pidinst = (GF_FilterPidInst *)pid;\n\n\tif (PID_IS_OUTPUT(pid)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (\"Attempt to discard a packet on an output PID in filter %s\\n\", pid->filter->name));\n\t\treturn;\n\t}\n\tif (pidinst->filter)\n\t\tpidinst->filter->nb_pck_io++;\n\n\t//remove pck instance\n\tpcki = gf_fq_pop(pidinst->packets);\n\n\tif (!pcki) {\n\t\tif (pidinst->filter && !pidinst->filter->finalized) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"Attempt to discard a packet already discarded in filter %s\\n\", pid->filter->name));\n\t\t}\n\t\treturn;\n\t}\n\n\tgf_rmt_begin(pck_drop, GF_RMT_AGGREGATE);\n\tpck = pcki->pck;\n\t//move to source pid\n\tpid = pid->pid;\n\tif (pck->pid_props)\n\t\ttimescale = pck->pid_props->timescale;\n\n\tgf_filter_pidinst_update_stats(pidinst, pck);\n\tif (timescale && (pck->info.cts!=GF_FILTER_NO_TS)) {\n\t\tpidinst->last_ts_drop.num = pck->info.cts;\n\t\tpidinst->last_ts_drop.den = timescale;\n\t}\n\n\n\t//make sure we lock the tasks mutex before getting the packet count, otherwise we might end up with a wrong number of packets\n\t//if one thread (the caller here) consumes one packet while the dispatching thread is still upddating the state for that pid\n\tgf_mx_p(pid->filter->tasks_mx);\n\tnb_pck = gf_fq_count(pidinst->packets);\n\n\tif (!nb_pck) {\n\t\tsafe_int64_sub(&pidinst->buffer_duration, pidinst->buffer_duration);\n\t} else if (pck->info.duration && (pck->info.flags & GF_PCKF_BLOCK_START) && timescale) {\n\t\ts64 d = gf_timestamp_rescale(pck->info.duration, timescale, 1000000);\n\t\tif (d > pidinst->buffer_duration) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, (\"Corrupted buffer level in PID instance %s (%s -> %s), dropping packet duration \"LLD\" us greater than buffer duration \"LLU\" us\\n\", pid->name, pid->filter->name, pidinst->filter ? pidinst->filter->name : \"disconnected\", d, pidinst->buffer_duration));\n\t\t\td = pidinst->buffer_duration;\n\t\t}\n\t\tassert(d <= pidinst->buffer_duration);\n\t\tsafe_int64_sub(&pidinst->buffer_duration, (s32) d);\n\t}\n\n\tif ( (pid->num_destinations==1) || (pid->filter->session->blocking_mode==GF_FS_NOBLOCK_FANOUT)) {\n\t\tif (nb_pck<pid->nb_buffer_unit) {\n\t\t\tpid->nb_buffer_unit = nb_pck;\n\t\t}\n\t\tif (!pid->buffer_duration || (pidinst->buffer_duration < (s64) pid->buffer_duration)) {\n\t\t\tpid->buffer_duration = pidinst->buffer_duration;\n\t\t}\n\t}\n\t//handle fan-out: we must browse all other pid instances and compute max buffer/nb_pck per pids\n\t//so that we don't unblock the PID if some instance is still blocking\n\telse {\n\t\tu32 i;\n\t\tu32 min_pck = nb_pck;\n\t\ts64 min_dur = pidinst->buffer_duration;\n\t\tfor (i=0; i<pid->num_destinations; i++) {\n\t\t\tGF_FilterPidInst *a_pidi = gf_list_get(pid->destinations, i);\n\t\t\tif (a_pidi==pidinst) continue;\n\t\t\tif (a_pidi->buffer_duration > min_dur)\n\t\t\t\tmin_dur = a_pidi->buffer_duration;\n\t\t\tnb_pck = gf_fq_count(a_pidi->packets);\n\t\t\tif (nb_pck>min_pck)\n\t\t\t\tmin_pck = nb_pck;\n\t\t}\n\t\tpid->buffer_duration = min_dur;\n\t\tpid->nb_buffer_unit = min_pck;\n\t}\n\tgf_filter_pid_check_unblock(pid);\n\n\tgf_mx_v(pid->filter->tasks_mx);\n\n#ifndef GPAC_DISABLE_LOG\n\tif (gf_log_tool_level_on(GF_LOG_FILTER, GF_LOG_DEBUG)) {\n\t\tu8 sap_type = (pck->info.flags & GF_PCK_SAP_MASK) >> GF_PCK_SAP_POS;\n\t\tBool seek_flag = (pck->info.flags & GF_PCKF_SEEK) ? 1 : 0;\n\n\t\tif ((pck->info.dts != GF_FILTER_NO_TS) && (pck->info.cts != GF_FILTER_NO_TS) ) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s PID %s (%s) drop packet DTS \"LLU\" CTS \"LLU\" SAP %d Seek %d - %d packets remaining buffer \"LLU\" us\\n\", pidinst->filter ? pidinst->filter->name : \"disconnected\", pid->name, pid->filter->name, pck->info.dts, pck->info.cts, sap_type, seek_flag, nb_pck, pidinst->buffer_duration));\n\t\t} else if ((pck->info.cts != GF_FILTER_NO_TS) ) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s PID %s (%s) drop packet CTS \"LLU\" SAP %d Seek %d - %d packets remaining buffer \"LLU\" us\\n\", pidinst->filter ? pidinst->filter->name : \"disconnected\", pid->name, pid->filter->name, pck->info.cts, sap_type, seek_flag, nb_pck, pidinst->buffer_duration));\n\t\t} else if ((pck->info.dts != GF_FILTER_NO_TS) ) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s PID %s (%s) drop packet DTS \"LLU\" SAP %d Seek %d - %d packets remaining buffer \"LLU\" us\\n\", pidinst->filter ? pidinst->filter->name : \"disconnected\", pid->name, pid->filter->name, pck->info.dts, sap_type, seek_flag, nb_pck, pidinst->buffer_duration));\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s PID %s (%s) drop packet SAP %d Seek %d - %d packets remaining buffer \"LLU\" us\\n\", pidinst->filter ? pidinst->filter->name : \"disconnected\", pid->name, pid->filter->name, sap_type, seek_flag, nb_pck, pidinst->buffer_duration));\n\t\t}\n\t}\n#endif\n\n\t//destroy pcki\n\tpcki->pck = NULL;\n\tpcki->pid = NULL;\n\n#ifdef GPAC_MEMORY_TRACKING\n\tif (pid->filter && pid->filter->session->check_allocs) {\n\t\tgf_mem_get_stats(&prev_nb_allocs, NULL, &prev_nb_reallocs, NULL);\n\t}\n#endif\n\n\tif (pid->filter->pcks_inst_reservoir) {\n\t\tgf_fq_add(pid->filter->pcks_inst_reservoir, pcki);\n\t} else {\n\t\tgf_free(pcki);\n\t}\n\t//unref pck\n\tassert(pck->reference_count);\n\tif (safe_int_dec(&pck->reference_count) == 0) {\n\t\tgf_filter_packet_destroy(pck);\n\t}\n\n#ifdef GPAC_MEMORY_TRACKING\n\tif (pid->filter && pid->filter->session->check_allocs) {\n\t\tgf_mem_get_stats(&nb_allocs, NULL, &nb_reallocs, NULL);\n\n\t\tpid->filter->session->nb_alloc_pck += (nb_allocs - prev_nb_allocs);\n\t\tpid->filter->session->nb_realloc_pck += (nb_reallocs - prev_nb_reallocs);\n\t}\n#endif\n\n\t//decrement number of pending packet on target filter if this is not a destroy\n\tif (pidinst->filter) {\n\t\tassert(pidinst->filter->pending_packets);\n\t\tsafe_int_dec(&pidinst->filter->pending_packets);\n\n\t\tgf_filter_forward_clock(pidinst->filter);\n\t}\n\n\tgf_rmt_end();\n}\n\n// gf_isom_get_media_duration from src/isomedia/isom_read.c:\nu64 gf_isom_get_media_duration(GF_ISOFile *movie, u32 trackNumber) /* <=== gf_isom_get_media_duration */ \n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return 0;\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\t/*except in dump mode always recompute the duration*/\n\tif (movie->openMode != GF_ISOM_OPEN_READ_DUMP) {\n\t\tif ( (movie->LastError = Media_SetDuration(trak)) ) return 0;\n\t}\n\n#endif\n\n\treturn trak->Media->mediaHeader->duration;\n}\n\n// gf_filter_packet_destroy from src/filter_core/filter_pck.c:\nvoid gf_filter_packet_destroy(GF_FilterPacket *pck) /* <=== gf_filter_packet_destroy */ \n{\n\tBool is_filter_destroyed = GF_FALSE;\n\tGF_FilterPid *pid = pck->pid;\n\tBool is_ref_props_packet = GF_FALSE;\n\n\t//this is a ref props packet, its destruction can happen at any time, included after destruction\n\t//of source filter/pid.  pck->src_filter or pck->pid shall not be trusted !\n\tif (pck->info.flags & GF_PCKF_PROPS_REFERENCE) {\n\t\tis_ref_props_packet = GF_TRUE;\n\t\tis_filter_destroyed = GF_TRUE;\n\t\tpck->src_filter = NULL;\n\t\tpck->pid = NULL;\n\t\tassert(!pck->destructor);\n\t\tassert(!pck->filter_owns_mem);\n\t\tassert(!pck->reference);\n\n\t\tif (pck->info.cts != GF_FILTER_NO_TS) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Destroying packet property reference CTS \"LLU\" size %d\\n\", pck->info.cts, pck->data_length));\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Destroying packet property reference size %d\\n\", pck->data_length));\n\t\t}\n\t}\n\t//if not null, we discard a non-sent packet\n\telse if (pck->src_filter) {\n\t\tis_filter_destroyed = pck->src_filter->finalized;\n\t}\n\n\tif (!is_filter_destroyed && !pck->is_dangling) {\n\t\tassert(pck->pid);\n\t\tif (pck->pid->filter) {\n\t\t\tif (pck->info.cts != GF_FILTER_NO_TS) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s PID %s destroying packet CTS \"LLU\"\\n\", pck->pid->filter->name, pck->pid->name, pck->info.cts));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s PID %s destroying packet\\n\", pck->pid->filter->name, pck->pid->name));\n\t\t\t}\n\t\t}\n\t}\n\t//never set for dangling packets\n\tif (pck->destructor) pck->destructor(pid->filter, pid, pck);\n\n\t//never set for dangling packets (theyr are never sent)\n\tif (pck->pid_props) {\n\t\tGF_PropertyMap *props = pck->pid_props;\n\t\tpck->pid_props = NULL;\n\n\t\tif (is_ref_props_packet) {\n\t\t\tassert(props->pckrefs_reference_count);\n\t\t\tif (safe_int_dec(&props->pckrefs_reference_count) == 0) {\n\t\t\t\tgf_props_del(props);\n\t\t\t}\n\t\t} else {\n\t\t\tassert(props->reference_count);\n\t\t\tif (safe_int_dec(&props->reference_count) == 0) {\n\t\t\t\tif (!is_filter_destroyed) {\n\t\t\t\t\tif (pck->pid->filter) {\n\t\t\t\t\t\t//see \\ref gf_filter_pid_merge_properties_internal for mutex\n\t\t\t\t\t\tgf_mx_p(pck->pid->filter->tasks_mx);\n\t\t\t\t\t\tgf_list_del_item(pck->pid->properties, props);\n\t\t\t\t\t\tgf_mx_v(pck->pid->filter->tasks_mx);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_list_del_item(pck->pid->properties, props);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_props_del(props);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pck->props) {\n\t\tGF_PropertyMap *props = pck->props;\n\t\tpck->props=NULL;\n\t\tassert(props->reference_count);\n\t\tif (safe_int_dec(&props->reference_count) == 0) {\n\t\t\tgf_props_del(props);\n\t\t}\n\t}\n\t//never set for dangling packets, they are either standalone mem or packet references\n\tif (pck->filter_owns_mem && !(pck->info.flags & GF_PCK_CMD_MASK) ) {\n\t\tassert(pck->pid);\n\t\tassert(pck->pid->nb_shared_packets_out);\n\t\tassert(pck->pid->filter);\n\t\tassert(pck->pid->filter->nb_shared_packets_out);\n\t\tsafe_int_dec(&pck->pid->nb_shared_packets_out);\n\t\tsafe_int_dec(&pck->pid->filter->nb_shared_packets_out);\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s PID %s has %d shared packets out\\n\", pck->pid->filter->name, pck->pid->name, pck->pid->nb_shared_packets_out));\n\t}\n\n\tpck->data_length = 0;\n\tpck->pid = NULL;\n\n\tif (pck->reference) {\n\t\tassert(pck->reference->pid->nb_shared_packets_out);\n\t\tassert(pck->reference->pid->filter->nb_shared_packets_out);\n\t\tsafe_int_dec(&pck->reference->pid->nb_shared_packets_out);\n\t\tsafe_int_dec(&pck->reference->pid->filter->nb_shared_packets_out);\n\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, (\"Filter %s PID %s has %d shared packets out\\n\", pck->reference->pid->filter->name, pck->reference->pid->name, pck->reference->pid->nb_shared_packets_out));\n\t\tassert(pck->reference->reference_count);\n\t\tif (safe_int_dec(&pck->reference->reference_count) == 0) {\n\t\t\tgf_filter_packet_destroy(pck->reference);\n\t\t}\n\t\tpck->reference = NULL;\n\t\tif (pck->is_dangling)\n\t\t\tpck->data = NULL;\n\t}\n\t/*this is a property reference packet, its destruction may happen at ANY time*/\n\tif (is_ref_props_packet) {\n\t\tif (pck->session->pcks_refprops_reservoir) {\n\t\t\tgf_fq_add(pck->session->pcks_refprops_reservoir, pck);\n\t\t} else {\n\t\t\tgf_free(pck);\n\t\t}\n\t} else if (is_filter_destroyed) {\n\t\tif (!pck->filter_owns_mem && pck->data) gf_free(pck->data);\n\t\tgf_free(pck);\n\t} else if (pck->is_dangling) {\n\t\tif (pck->data) gf_free(pck->data);\n\t\tgf_free(pck);\n\t}\n\telse if (pck->filter_owns_mem ) {\n\t\tif (pid->filter && pid->filter->pcks_shared_reservoir) {\n\t\t\tgf_fq_add(pid->filter->pcks_shared_reservoir, pck);\n\t\t} else {\n\t\t\tgf_free(pck);\n\t\t}\n\t} else {\n\t\tif (pid->filter && pid->filter->pcks_alloc_reservoir) {\n\t\t\tgf_fq_add(pid->filter->pcks_alloc_reservoir, pck);\n\t\t} else {\n\t\t\tif (pck->data) gf_free(pck->data);\n\t\t\tgf_free(pck);\n\t\t}\n\t}\n}\n\n// gf_filter_pid_copy_properties from src/filter_core/filter_pid.c:\nGF_Err gf_filter_pid_copy_properties(GF_FilterPid *dst_pid, GF_FilterPid *src_pid) /* <=== gf_filter_pid_copy_properties */ \n{\n\treturn gf_filter_pid_merge_properties_internal(dst_pid, src_pid, NULL, NULL, GF_FALSE);\n}\n\n// gf_odf_avc_cfg_write_bs from src/odf/descriptors.c:\nGF_Err gf_odf_avc_cfg_write_bs(GF_AVCConfig *cfg, GF_BitStream *bs) /* <=== gf_odf_avc_cfg_write_bs */ \n{\n\tu32 i, count;\n\n\tif (!cfg) return GF_BAD_PARAM;\n\n\tcount = gf_list_count(cfg->sequenceParameterSets);\n\n\tif (!cfg->write_annex_b) {\n\t\tgf_bs_write_int(bs, cfg->configurationVersion, 8);\n\t\tgf_bs_write_int(bs, cfg->AVCProfileIndication , 8);\n\t\tgf_bs_write_int(bs, cfg->profile_compatibility, 8);\n\t\tgf_bs_write_int(bs, cfg->AVCLevelIndication, 8);\n\t\tgf_bs_write_int(bs, 0x3F, 6);\n\t\tgf_bs_write_int(bs, cfg->nal_unit_size - 1, 2);\n\t\tgf_bs_write_int(bs, 0x7, 3);\n\t\tgf_bs_write_int(bs, count, 5);\n\t}\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *)gf_list_get(cfg->sequenceParameterSets, i);\n\t\tif (!cfg->write_annex_b) {\n\t\t\tgf_bs_write_u16(bs, sl->size);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, 1);\n\t\t}\n\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t}\n\tcount = gf_list_count(cfg->pictureParameterSets);\n\tif (!cfg->write_annex_b) {\n\t\tgf_bs_write_int(bs, count, 8);\n\t}\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *)gf_list_get(cfg->pictureParameterSets, i);\n\t\tif (!cfg->write_annex_b) {\n\t\t\tgf_bs_write_u16(bs, sl->size);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, 1);\n\t\t}\n\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t}\n\tif (gf_avc_is_rext_profile(cfg->AVCProfileIndication)) {\n\t\tif (!cfg->write_annex_b) {\n\t\t\tgf_bs_write_int(bs, 0xFF, 6);\n\t\t\tgf_bs_write_int(bs, cfg->chroma_format, 2);\n\t\t\tgf_bs_write_int(bs, 0xFF, 5);\n\t\t\tgf_bs_write_int(bs, cfg->luma_bit_depth - 8, 3);\n\t\t\tgf_bs_write_int(bs, 0xFF, 5);\n\t\t\tgf_bs_write_int(bs, cfg->chroma_bit_depth - 8, 3);\n\t\t}\n\t\tcount = cfg->sequenceParameterSetExtensions ? gf_list_count(cfg->sequenceParameterSetExtensions) : 0;\n\t\tif (!cfg->write_annex_b) {\n\t\t\tgf_bs_write_u8(bs, count);\n\t\t}\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *) gf_list_get(cfg->sequenceParameterSetExtensions, i);\n\t\t\tif (!cfg->write_annex_b) {\n\t\t\t\tgf_bs_write_u16(bs, sl->size);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u32(bs, 1);\n\t\t\t}\n\t\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n// gf_list_del from src/utils/list.c:\nvoid gf_list_del(GF_List *ptr) /* <=== gf_list_del */ \n{\n\tif (!ptr) return;\n\twhile (ptr->entryCount) gf_list_rem(ptr, 0);\n\tgf_free(ptr);\n}\n\n// gf_filter_notification_failure from src/filter_core/filter.c:\nvoid gf_filter_notification_failure(GF_Filter *filter, GF_Err reason, Bool force_disconnect) /* <=== gf_filter_notification_failure */ \n{\n\tstruct _gf_filter_setup_failure *stack;\n\tif (!filter->on_setup_error_filter && !force_disconnect) return;\n\n\tstack = gf_malloc(sizeof(struct _gf_filter_setup_failure));\n\tstack->e = reason;\n\tstack->notify_filter = filter->on_setup_error_filter;\n\tstack->filter = filter;\n\tstack->do_disconnect = force_disconnect;\n\tif (force_disconnect) {\n\t\tfilter->removed = GF_TRUE;\n\t}\n\tif (filter->on_setup_error_filter) {\n\t\tgf_fs_post_task(filter->session, gf_filter_setup_failure_notify_task, filter->on_setup_error_filter, NULL, \"setup_failure_notify\", stack);\n\t} else if (force_disconnect) {\n\t\tgf_fs_post_task(filter->session, gf_filter_setup_failure_task, NULL, NULL, \"setup_failure\", stack);\n\t}\n}\n\n// gf_isom_get_track_layout_info from src/isomedia/isom_read.c:\nGF_Err gf_isom_get_track_layout_info(GF_ISOFile *movie, u32 trackNumber, u32 *width, u32 *height, s32 *translation_x, s32 *translation_y, s16 *layer) /* <=== gf_isom_get_track_layout_info */ \n{\n\tGF_TrackBox *tk = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!tk) return GF_BAD_PARAM;\n\tif (width) *width = tk->Header->width>>16;\n\tif (height) *height = tk->Header->height>>16;\n\tif (layer) *layer = tk->Header->layer;\n\tif (translation_x) *translation_x = tk->Header->matrix[6] >> 16;\n\tif (translation_y) *translation_y = tk->Header->matrix[7] >> 16;\n\treturn GF_OK;\n}\n\n// stbl_RemoveSampleGroup from src/isomedia/stbl_write.c:\nGF_Err stbl_RemoveSampleGroup(GF_SampleTableBox *stbl, u32 SampleNumber) /* <=== stbl_RemoveSampleGroup */ \n{\n\tu32 i, k, count, prev_sample;\n\n\tif (!stbl->sampleGroups) return GF_OK;\n\n\tcount = gf_list_count(stbl->sampleGroups);\n\tprev_sample = 0;\n\tfor (i=0; i<count; i++) {\n\t\tGF_SampleGroupBox *e = gf_list_get(stbl->sampleGroups, i);\n\t\tfor (k=0; k<e->entry_count; k++) {\n\t\t\tif ((SampleNumber>prev_sample) && (SampleNumber <= prev_sample + e->sample_entries[k].sample_count) ) {\n\t\t\t\te->sample_entries[k].sample_count--;\n\t\t\t\tif (!e->sample_entries[k].sample_count) {\n\t\t\t\t\tmemmove(&e->sample_entries[k], &e->sample_entries[k+1], sizeof(GF_SampleGroupEntry) * (e->entry_count-k-1));\n\t\t\t\t\te->entry_count--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!e->entry_count) {\n\t\t\tgf_list_rem(stbl->sampleGroups, i);\n\t\t\ti--;\n\t\t\tcount--;\n\t\t\tgf_isom_box_del_parent(&stbl->child_boxes, (GF_Box *) e);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n// gf_bs_read_int from src/utils/bitstream.c:\nu32 gf_bs_read_int(GF_BitStream *bs, u32 nBits) /* <=== gf_bs_read_int */ \n{\n\tu32 ret;\n\n#ifndef NO_OPTS\n\tif (nBits + bs->nbBits <= 8) {\n\t\tbs->nbBits += nBits;\n\t\tret = (bs->current >> (8 - bs->nbBits) ) & bits_mask[nBits];\n\t\treturn ret;\n\t}\n#endif\n\tret = 0;\n\twhile (nBits-- > 0) {\n\t\tret <<= 1;\n\t\tret |= gf_bs_read_bit(bs);\n\t}\n\treturn ret;\n}\n"
  },
  {
    "repository": "libvirt",
    "cve_id": "CVE-2020-14301",
    "cwe_list": [
      "CWE-212"
    ],
    "commit_hash": "524de6cc35d3b222f0e940bb0fd027f5482572c5",
    "short_hash": "524de6cc",
    "vulnerableMethods_before": [
      {
        "filename": "virstoragetest.c",
        "method_name": "vulnerable_function",
        "raw_code": "testBackingParse(const void *args)\n{\n    const struct testBackingParseData *data = args;\n    g_auto(virBuffer) buf = VIR_BUFFER_INITIALIZER;\n    g_autofree char *xml = NULL;\n    g_autoptr(virStorageSource) src = NULL;\n    int rc;\n    int erc = data->rv;\n\n    /* expect failure return code with NULL expected data */\n    if (!data->expect)\n        erc = -1;\n\n    if ((rc = virStorageSourceNewFromBackingAbsolute(data->backing, &src)) != erc) {\n        fprintf(stderr, \"expected return value '%d' actual '%d'\\n\", erc, rc);\n        return -1;\n    }\n\n    if (!src)\n        return 0;\n\n    if (src && !data->expect) {\n        fprintf(stderr, \"parsing of backing store string '%s' should \"\n                        \"have failed\\n\", data->backing);\n        return -1;\n    }\n\n    if (virDomainDiskSourceFormat(&buf, src, \"source\", 0, false, 0, true, NULL) < 0 ||\n        !(xml = virBufferContentAndReset(&buf))) {\n        fprintf(stderr, \"failed to format disk source xml\\n\");\n        return -1;\n    }\n\n    if (STRNEQ(xml, data->expect)) {\n        fprintf(stderr, \"\\n backing store string '%s'\\n\"\n                        \"expected storage source xml:\\n%s\\n\"\n                        \"actual storage source xml:\\n%s\\n\",\n                        data->backing, data->expect, xml);\n        return -1;\n    }\n\n    return 0;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "virstoragetest.c",
        "method_name": "fixed_function",
        "raw_code": "testBackingParse(const void *args)\n{\n    const struct testBackingParseData *data = args;\n    g_auto(virBuffer) buf = VIR_BUFFER_INITIALIZER;\n    g_autofree char *xml = NULL;\n    g_autoptr(virStorageSource) src = NULL;\n    int rc;\n    int erc = data->rv;\n    unsigned int xmlformatflags = VIR_DOMAIN_DEF_FORMAT_SECURE;\n\n    /* expect failure return code with NULL expected data */\n    if (!data->expect)\n        erc = -1;\n\n    if ((rc = virStorageSourceNewFromBackingAbsolute(data->backing, &src)) != erc) {\n        fprintf(stderr, \"expected return value '%d' actual '%d'\\n\", erc, rc);\n        return -1;\n    }\n\n    if (!src)\n        return 0;\n\n    if (src && !data->expect) {\n        fprintf(stderr, \"parsing of backing store string '%s' should \"\n                        \"have failed\\n\", data->backing);\n        return -1;\n    }\n\n    if (virDomainDiskSourceFormat(&buf, src, \"source\", 0, false, xmlformatflags, true, NULL) < 0 ||\n        !(xml = virBufferContentAndReset(&buf))) {\n        fprintf(stderr, \"failed to format disk source xml\\n\");\n        return -1;\n    }\n\n    if (STRNEQ(xml, data->expect)) {\n        fprintf(stderr, \"\\n backing store string '%s'\\n\"\n                        \"expected storage source xml:\\n%s\\n\"\n                        \"actual storage source xml:\\n%s\\n\",\n                        data->backing, data->expect, xml);\n        return -1;\n    }\n\n    return 0;\n}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "mvfst",
    "cve_id": "CVE-2021-24029",
    "cwe_list": [
      "CWE-703"
    ],
    "commit_hash": "a67083ff4b8dcbb7ee2839da6338032030d712b0",
    "short_hash": "a67083ff",
    "vulnerableMethods_before": [
      {
        "filename": "ServerStateMachine.cpp",
        "method_name": "vulnerable_function",
        "raw_code": "void updateHandshakeState(QuicServerConnectionState& conn) {\n  // Zero RTT read cipher is available after chlo is processed with the\n  // condition that early data attempt is accepted.\n  auto handshakeLayer = conn.serverHandshakeLayer;\n  auto zeroRttReadCipher = handshakeLayer->getZeroRttReadCipher();\n  auto zeroRttHeaderCipher = handshakeLayer->getZeroRttReadHeaderCipher();\n  // One RTT write cipher is available at Fizz layer after chlo is processed.\n  // However, the cipher is only exported to QUIC if early data attempt is\n  // accepted. Otherwise, the cipher will be available after cfin is\n  // processed.\n  auto oneRttWriteCipher = handshakeLayer->getOneRttWriteCipher();\n  // One RTT read cipher is available after cfin is processed.\n  auto oneRttReadCipher = handshakeLayer->getOneRttReadCipher();\n\n  auto oneRttWriteHeaderCipher = handshakeLayer->getOneRttWriteHeaderCipher();\n  auto oneRttReadHeaderCipher = handshakeLayer->getOneRttReadHeaderCipher();\n\n  if (zeroRttReadCipher) {\n    if (conn.qLogger) {\n      conn.qLogger->addTransportStateUpdate(kDerivedZeroRttReadCipher);\n    }\n    QUIC_TRACE(fst_trace, conn, \"derived 0-rtt read cipher\");\n    conn.readCodec->setZeroRttReadCipher(std::move(zeroRttReadCipher));\n  }\n  if (zeroRttHeaderCipher) {\n    conn.readCodec->setZeroRttHeaderCipher(std::move(zeroRttHeaderCipher));\n  }\n  if (oneRttWriteHeaderCipher) {\n    conn.oneRttWriteHeaderCipher = std::move(oneRttWriteHeaderCipher);\n  }\n  if (oneRttReadHeaderCipher) {\n    conn.readCodec->setOneRttHeaderCipher(std::move(oneRttReadHeaderCipher));\n  }\n\n  if (oneRttWriteCipher) {\n    if (conn.qLogger) {\n      conn.qLogger->addTransportStateUpdate(kDerivedOneRttWriteCipher);\n    }\n    QUIC_TRACE(fst_trace, conn, \"derived 1-rtt write cipher\");\n    CHECK(!conn.oneRttWriteCipher.get());\n    conn.oneRttWriteCipher = std::move(oneRttWriteCipher);\n\n    updatePacingOnKeyEstablished(conn);\n\n    // We negotiate the transport parameters whenever we have the 1-RTT write\n    // keys available.\n    auto clientParams = handshakeLayer->getClientTransportParams();\n    if (!clientParams) {\n      throw QuicTransportException(\n          \"No client transport params\",\n          TransportErrorCode::TRANSPORT_PARAMETER_ERROR);\n    }\n    processClientInitialParams(conn, std::move(*clientParams));\n  }\n  if (oneRttReadCipher) {\n    if (conn.qLogger) {\n      conn.qLogger->addTransportStateUpdate(kDerivedOneRttReadCipher);\n    }\n    QUIC_TRACE(fst_trace, conn, \"derived 1-rtt read cipher\");\n    // Clear limit because CFIN is received at this point\n    conn.writableBytesLimit = folly::none;\n    conn.readCodec->setOneRttReadCipher(std::move(oneRttReadCipher));\n  }\n  auto handshakeReadCipher = handshakeLayer->getHandshakeReadCipher();\n  auto handshakeReadHeaderCipher =\n      handshakeLayer->getHandshakeReadHeaderCipher();\n  if (handshakeReadCipher) {\n    CHECK(handshakeReadHeaderCipher);\n    conn.readCodec->setHandshakeReadCipher(std::move(handshakeReadCipher));\n    conn.readCodec->setHandshakeHeaderCipher(\n        std::move(handshakeReadHeaderCipher));\n  }\n  if (handshakeLayer->isHandshakeDone()) {\n    CHECK(conn.oneRttWriteCipher);\n    if (conn.version != QuicVersion::MVFST_D24 && !conn.sentHandshakeDone) {\n      sendSimpleFrame(conn, HandshakeDoneFrame());\n      conn.sentHandshakeDone = true;\n    }\n  }\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ServerStateMachine.cpp",
        "method_name": "fixed_function",
        "raw_code": "void updateHandshakeState(QuicServerConnectionState& conn) {\n  // Zero RTT read cipher is available after chlo is processed with the\n  // condition that early data attempt is accepted.\n  auto handshakeLayer = conn.serverHandshakeLayer;\n  auto zeroRttReadCipher = handshakeLayer->getZeroRttReadCipher();\n  auto zeroRttHeaderCipher = handshakeLayer->getZeroRttReadHeaderCipher();\n  // One RTT write cipher is available at Fizz layer after chlo is processed.\n  // However, the cipher is only exported to QUIC if early data attempt is\n  // accepted. Otherwise, the cipher will be available after cfin is\n  // processed.\n  auto oneRttWriteCipher = handshakeLayer->getOneRttWriteCipher();\n  // One RTT read cipher is available after cfin is processed.\n  auto oneRttReadCipher = handshakeLayer->getOneRttReadCipher();\n\n  auto oneRttWriteHeaderCipher = handshakeLayer->getOneRttWriteHeaderCipher();\n  auto oneRttReadHeaderCipher = handshakeLayer->getOneRttReadHeaderCipher();\n\n  if (zeroRttReadCipher) {\n    if (conn.qLogger) {\n      conn.qLogger->addTransportStateUpdate(kDerivedZeroRttReadCipher);\n    }\n    QUIC_TRACE(fst_trace, conn, \"derived 0-rtt read cipher\");\n    conn.readCodec->setZeroRttReadCipher(std::move(zeroRttReadCipher));\n  }\n  if (zeroRttHeaderCipher) {\n    conn.readCodec->setZeroRttHeaderCipher(std::move(zeroRttHeaderCipher));\n  }\n  if (oneRttWriteHeaderCipher) {\n    conn.oneRttWriteHeaderCipher = std::move(oneRttWriteHeaderCipher);\n  }\n  if (oneRttReadHeaderCipher) {\n    conn.readCodec->setOneRttHeaderCipher(std::move(oneRttReadHeaderCipher));\n  }\n\n  if (oneRttWriteCipher) {\n    if (conn.qLogger) {\n      conn.qLogger->addTransportStateUpdate(kDerivedOneRttWriteCipher);\n    }\n    QUIC_TRACE(fst_trace, conn, \"derived 1-rtt write cipher\");\n    if (conn.oneRttWriteCipher) {\n      throw QuicTransportException(\n          \"Duplicate 1-rtt write cipher\", TransportErrorCode::CRYPTO_ERROR);\n    }\n    conn.oneRttWriteCipher = std::move(oneRttWriteCipher);\n\n    updatePacingOnKeyEstablished(conn);\n\n    // We negotiate the transport parameters whenever we have the 1-RTT write\n    // keys available.\n    auto clientParams = handshakeLayer->getClientTransportParams();\n    if (!clientParams) {\n      throw QuicTransportException(\n          \"No client transport params\",\n          TransportErrorCode::TRANSPORT_PARAMETER_ERROR);\n    }\n    processClientInitialParams(conn, std::move(*clientParams));\n  }\n  if (oneRttReadCipher) {\n    if (conn.qLogger) {\n      conn.qLogger->addTransportStateUpdate(kDerivedOneRttReadCipher);\n    }\n    QUIC_TRACE(fst_trace, conn, \"derived 1-rtt read cipher\");\n    // Clear limit because CFIN is received at this point\n    conn.writableBytesLimit = folly::none;\n    conn.readCodec->setOneRttReadCipher(std::move(oneRttReadCipher));\n  }\n  auto handshakeReadCipher = handshakeLayer->getHandshakeReadCipher();\n  auto handshakeReadHeaderCipher =\n      handshakeLayer->getHandshakeReadHeaderCipher();\n  if (handshakeReadCipher) {\n    CHECK(handshakeReadHeaderCipher);\n    conn.readCodec->setHandshakeReadCipher(std::move(handshakeReadCipher));\n    conn.readCodec->setHandshakeHeaderCipher(\n        std::move(handshakeReadHeaderCipher));\n  }\n  if (handshakeLayer->isHandshakeDone()) {\n    CHECK(conn.oneRttWriteCipher);\n    if (conn.version != QuicVersion::MVFST_D24 && !conn.sentHandshakeDone) {\n      sendSimpleFrame(conn, HandshakeDoneFrame());\n      conn.sentHandshakeDone = true;\n    }\n  }\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <quic/server/state/ServerStateMachine.h>\n#include <quic/common/BufUtil.h>\n#include <quic/flowcontrol/QuicFlowController.h>\n#include <quic/state/QuicPacingFunctions.h>\n#include <quic/state/QuicStreamFunctions.h>\n#include <quic/handshake/TransportParameters.h>\n#include <quic/state/QuicTransportStatsCallback.h>\n#include <quic/state/stream/StreamReceiveHandlers.h>\n#include <quic/state/stream/StreamSendHandlers.h>\n#include <quic/api/QuicTransportFunctions.h>\n#include <quic/fizz/handshake/FizzCryptoFactory.h>\n#include <quic/state/SimpleFrameFunctions.h>\n#include <quic/congestion_control/TokenlessPacer.h>\n#include <quic/congestion_control/CongestionControllerFactory.h>\n#include <quic/logging/QLoggerConstants.h>\n"
  },
  {
    "repository": "linux",
    "cve_id": "CVE-2022-1205",
    "cwe_list": [
      "CWE-476"
    ],
    "commit_hash": "82e31755e55fbcea6a9dfaae5fe4860ade17cbc0",
    "short_hash": "82e31755",
    "vulnerableMethods_before": [
      {
        "filename": "af_ax25.c",
        "method_name": "vulnerable_function",
        "raw_code": "static int ax25_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tax25_cb *ax25;\n\tax25_dev *ax25_dev;\n\n\tif (sk == NULL)\n\t\treturn 0;\n\n\tsock_hold(sk);\n\tlock_sock(sk);\n\tsock_orphan(sk);\n\tax25 = sk_to_ax25(sk);\n\tax25_dev = ax25->ax25_dev;\n\n\tif (sk->sk_type == SOCK_SEQPACKET) {\n\t\tswitch (ax25->state) {\n\t\tcase AX25_STATE_0:\n\t\t\trelease_sock(sk);\n\t\t\tax25_disconnect(ax25, 0);\n\t\t\tlock_sock(sk);\n\t\t\tax25_destroy_socket(ax25);\n\t\t\tbreak;\n\n\t\tcase AX25_STATE_1:\n\t\tcase AX25_STATE_2:\n\t\t\tax25_send_control(ax25, AX25_DISC, AX25_POLLON, AX25_COMMAND);\n\t\t\trelease_sock(sk);\n\t\t\tax25_disconnect(ax25, 0);\n\t\t\tlock_sock(sk);\n\t\t\tif (!sock_flag(ax25->sk, SOCK_DESTROY))\n\t\t\t\tax25_destroy_socket(ax25);\n\t\t\tbreak;\n\n\t\tcase AX25_STATE_3:\n\t\tcase AX25_STATE_4:\n\t\t\tax25_clear_queues(ax25);\n\t\t\tax25->n2count = 0;\n\n\t\t\tswitch (ax25->ax25_dev->values[AX25_VALUES_PROTOCOL]) {\n\t\t\tcase AX25_PROTO_STD_SIMPLEX:\n\t\t\tcase AX25_PROTO_STD_DUPLEX:\n\t\t\t\tax25_send_control(ax25,\n\t\t\t\t\t\t  AX25_DISC,\n\t\t\t\t\t\t  AX25_POLLON,\n\t\t\t\t\t\t  AX25_COMMAND);\n\t\t\t\tax25_stop_t2timer(ax25);\n\t\t\t\tax25_stop_t3timer(ax25);\n\t\t\t\tax25_stop_idletimer(ax25);\n\t\t\t\tbreak;\n#ifdef CONFIG_AX25_DAMA_SLAVE\n\t\t\tcase AX25_PROTO_DAMA_SLAVE:\n\t\t\t\tax25_stop_t3timer(ax25);\n\t\t\t\tax25_stop_idletimer(ax25);\n\t\t\t\tbreak;\n#endif\n\t\t\t}\n\t\t\tax25_calculate_t1(ax25);\n\t\t\tax25_start_t1timer(ax25);\n\t\t\tax25->state = AX25_STATE_2;\n\t\t\tsk->sk_state                = TCP_CLOSE;\n\t\t\tsk->sk_shutdown            |= SEND_SHUTDOWN;\n\t\t\tsk->sk_state_change(sk);\n\t\t\tsock_set_flag(sk, SOCK_DESTROY);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tsk->sk_state     = TCP_CLOSE;\n\t\tsk->sk_shutdown |= SEND_SHUTDOWN;\n\t\tsk->sk_state_change(sk);\n\t\tax25_destroy_socket(ax25);\n\t}\n\tif (ax25_dev) {\n\t\tdev_put_track(ax25_dev->dev, &ax25_dev->dev_tracker);\n\t\tax25_dev_put(ax25_dev);\n\t}\n\n\tsock->sk   = NULL;\n\trelease_sock(sk);\n\tsock_put(sk);\n\n\treturn 0;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "af_ax25.c",
        "method_name": "fixed_function",
        "raw_code": "static int ax25_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tax25_cb *ax25;\n\tax25_dev *ax25_dev;\n\n\tif (sk == NULL)\n\t\treturn 0;\n\n\tsock_hold(sk);\n\tlock_sock(sk);\n\tsock_orphan(sk);\n\tax25 = sk_to_ax25(sk);\n\tax25_dev = ax25->ax25_dev;\n\n\tif (sk->sk_type == SOCK_SEQPACKET) {\n\t\tswitch (ax25->state) {\n\t\tcase AX25_STATE_0:\n\t\t\trelease_sock(sk);\n\t\t\tax25_disconnect(ax25, 0);\n\t\t\tlock_sock(sk);\n\t\t\tax25_destroy_socket(ax25);\n\t\t\tbreak;\n\n\t\tcase AX25_STATE_1:\n\t\tcase AX25_STATE_2:\n\t\t\tax25_send_control(ax25, AX25_DISC, AX25_POLLON, AX25_COMMAND);\n\t\t\trelease_sock(sk);\n\t\t\tax25_disconnect(ax25, 0);\n\t\t\tlock_sock(sk);\n\t\t\tif (!sock_flag(ax25->sk, SOCK_DESTROY))\n\t\t\t\tax25_destroy_socket(ax25);\n\t\t\tbreak;\n\n\t\tcase AX25_STATE_3:\n\t\tcase AX25_STATE_4:\n\t\t\tax25_clear_queues(ax25);\n\t\t\tax25->n2count = 0;\n\n\t\t\tswitch (ax25->ax25_dev->values[AX25_VALUES_PROTOCOL]) {\n\t\t\tcase AX25_PROTO_STD_SIMPLEX:\n\t\t\tcase AX25_PROTO_STD_DUPLEX:\n\t\t\t\tax25_send_control(ax25,\n\t\t\t\t\t\t  AX25_DISC,\n\t\t\t\t\t\t  AX25_POLLON,\n\t\t\t\t\t\t  AX25_COMMAND);\n\t\t\t\tax25_stop_t2timer(ax25);\n\t\t\t\tax25_stop_t3timer(ax25);\n\t\t\t\tax25_stop_idletimer(ax25);\n\t\t\t\tbreak;\n#ifdef CONFIG_AX25_DAMA_SLAVE\n\t\t\tcase AX25_PROTO_DAMA_SLAVE:\n\t\t\t\tax25_stop_t3timer(ax25);\n\t\t\t\tax25_stop_idletimer(ax25);\n\t\t\t\tbreak;\n#endif\n\t\t\t}\n\t\t\tax25_calculate_t1(ax25);\n\t\t\tax25_start_t1timer(ax25);\n\t\t\tax25->state = AX25_STATE_2;\n\t\t\tsk->sk_state                = TCP_CLOSE;\n\t\t\tsk->sk_shutdown            |= SEND_SHUTDOWN;\n\t\t\tsk->sk_state_change(sk);\n\t\t\tsock_set_flag(sk, SOCK_DESTROY);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tsk->sk_state     = TCP_CLOSE;\n\t\tsk->sk_shutdown |= SEND_SHUTDOWN;\n\t\tsk->sk_state_change(sk);\n\t\tax25_destroy_socket(ax25);\n\t}\n\tif (ax25_dev) {\n\t\tdel_timer_sync(&ax25->timer);\n\t\tdel_timer_sync(&ax25->t1timer);\n\t\tdel_timer_sync(&ax25->t2timer);\n\t\tdel_timer_sync(&ax25->t3timer);\n\t\tdel_timer_sync(&ax25->idletimer);\n\t\tdev_put_track(ax25_dev->dev, &ax25_dev->dev_tracker);\n\t\tax25_dev_put(ax25_dev);\n\t}\n\n\tsock->sk   = NULL;\n\trelease_sock(sk);\n\tsock_put(sk);\n\n\treturn 0;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/sockios.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/sysctl.h>\n#include <linux/errno.h>\n#include <linux/timer.h>\n#include <linux/capability.h>\n#include <linux/if_arp.h>\n#include <linux/types.h>\n#include <linux/uaccess.h>\n#include <linux/init.h>\n#include <linux/sched/signal.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/notifier.h>\n#include <net/ax25.h>\n#include <linux/socket.h>\n#include <linux/inet.h>\n#include <linux/in.h>\n#include <net/tcp_states.h>\n#include <net/arp.h>\n#include <linux/proc_fs.h>\n#include <net/sock.h>\n#include <linux/mm.h>\n#include <net/net_namespace.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/interrupt.h>\n#include <linux/termios.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <net/ip.h>\n\n// Type Definitions:\n// sock:\nstruct sock\n\n// socket:\nstruct socket\n\n// Called Methods (top 10):\n// sock_flag from include/net/sock.h:\nstatic inline bool sock_flag(const struct sock *sk, enum sock_flags flag) /* <=== sock_flag */ \n{\n\treturn test_bit(flag, &sk->sk_flags);\n}\n"
  },
  {
    "repository": "tensorflow",
    "cve_id": "CVE-2022-23585",
    "cwe_list": [
      "CWE-401"
    ],
    "commit_hash": "ab51e5b813573dc9f51efa335aebcf2994125ee9",
    "short_hash": "ab51e5b8",
    "vulnerableMethods_before": [
      {
        "filename": "decode_image_op.cc",
        "method_name": "vulnerable_function",
        "raw_code": "  void DecodePngV2(OpKernelContext* context, StringPiece input) {\n    int channel_bits = (data_type_ == DataType::DT_UINT8) ? 8 : 16;\n    png::DecodeContext decode;\n    OP_REQUIRES(\n        context, png::CommonInitDecode(input, channels_, channel_bits, &decode),\n        errors::InvalidArgument(\"Invalid PNG. Failed to initialize decoder.\"));\n\n    // Verify that width and height are not too large:\n    // - verify width and height don't overflow int.\n    // - width can later be multiplied by channels_ and sizeof(uint16), so\n    //   verify single dimension is not too large.\n    // - verify when width and height are multiplied together, there are a few\n    //   bits to spare as well.\n    const int width = static_cast<int>(decode.width);\n    const int height = static_cast<int>(decode.height);\n    const int64_t total_size =\n        static_cast<int64_t>(width) * static_cast<int64_t>(height);\n    if (width != static_cast<int64_t>(decode.width) || width <= 0 ||\n        width >= (1LL << 27) || height != static_cast<int64_t>(decode.height) ||\n        height <= 0 || height >= (1LL << 27) || total_size >= (1LL << 29)) {\n      OP_REQUIRES(context, false,\n                  errors::InvalidArgument(\"PNG size too large for int: \",\n                                          decode.width, \" by \", decode.height));\n    }\n\n    Tensor* output = nullptr;\n    // By the existing API, we support decoding PNG with `DecodeGif` op.\n    // We need to make sure to return 4-D shapes when using `DecodeGif`.\n    if (op_type_ == \"DecodeGif\") {\n      OP_REQUIRES_OK(\n          context,\n          context->allocate_output(\n              0, TensorShape({1, height, width, decode.channels}), &output));\n    } else {\n      OP_REQUIRES_OK(\n          context,\n          context->allocate_output(\n              0, TensorShape({height, width, decode.channels}), &output));\n    }\n\n    if (op_type_ == \"DecodeBmp\") {\n      // TODO(b/171060723): Only DecodeBmp as op_type_ is not acceptable here\n      // because currently `decode_(jpeg|png|gif)` ops can decode any one of\n      // jpeg, png or gif but not bmp. Similarly, `decode_bmp` cannot decode\n      // anything but bmp formats. This behavior needs to be revisited. For more\n      // details, please refer to the bug.\n      OP_REQUIRES(context, false,\n                  errors::InvalidArgument(\n                      \"Trying to decode PNG format using DecodeBmp op. Use \"\n                      \"`decode_png` or `decode_image` instead.\"));\n    } else if (op_type_ == \"DecodeAndCropJpeg\") {\n      OP_REQUIRES(context, false,\n                  errors::InvalidArgument(\n                      \"DecodeAndCropJpeg operation can run on JPEG only, but \"\n                      \"detected PNG.\"));\n    }\n\n    if (data_type_ == DataType::DT_UINT8) {\n      OP_REQUIRES(\n          context,\n          png::CommonFinishDecode(\n              reinterpret_cast<png_bytep>(output->flat<uint8>().data()),\n              decode.channels * width * sizeof(uint8), &decode),\n          errors::InvalidArgument(\"Invalid PNG data, size \", input.size()));\n    } else if (data_type_ == DataType::DT_UINT16) {\n      OP_REQUIRES(\n          context,\n          png::CommonFinishDecode(\n              reinterpret_cast<png_bytep>(output->flat<uint16>().data()),\n              decode.channels * width * sizeof(uint16), &decode),\n          errors::InvalidArgument(\"Invalid PNG data, size \", input.size()));\n    } else if (data_type_ == DataType::DT_FLOAT) {\n      // `png::CommonFinishDecode` does not support `float`. First allocate\n      // uint16 buffer for the image and decode in uint16 (lossless). Wrap the\n      // buffer in `unique_ptr` so that we don't forget to delete the buffer.\n      std::unique_ptr<uint16[]> buffer(\n          new uint16[height * width * decode.channels]);\n      OP_REQUIRES(\n          context,\n          png::CommonFinishDecode(reinterpret_cast<png_bytep>(buffer.get()),\n                                  decode.channels * width * sizeof(uint16),\n                                  &decode),\n          errors::InvalidArgument(\"Invalid PNG data, size \", input.size()));\n\n      // Convert uint16 image data to desired data type.\n      // Use eigen threadpooling to speed up the copy operation.\n      const auto& device = context->eigen_device<Eigen::ThreadPoolDevice>();\n      TTypes<uint16, 3>::UnalignedConstTensor buf(buffer.get(), height, width,\n                                                  decode.channels);\n      float scale = 1. / std::numeric_limits<uint16>::max();\n      // Fill output tensor with desired dtype.\n      output->tensor<float, 3>().device(device) = buf.cast<float>() * scale;\n    }\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "decode_image_op.cc",
        "method_name": "fixed_function",
        "raw_code": "  void DecodePngV2(OpKernelContext* context, StringPiece input) {\n    int channel_bits = (data_type_ == DataType::DT_UINT8) ? 8 : 16;\n    png::DecodeContext decode;\n    OP_REQUIRES(\n        context, png::CommonInitDecode(input, channels_, channel_bits, &decode),\n        errors::InvalidArgument(\"Invalid PNG. Failed to initialize decoder.\"));\n\n    // If we reach this point, then there is data in `decode` which must be\n    // freed by the time we end execution in this function. We cannot call\n    // `png::CommonFreeDecode()` before an `OP_REQUIRES` because if\n    // `OP_REQUIRES` constraint is satisfied then the data would be freed\n    // prematurely. Instead, let's use a `Cleanup` object.\n    auto cleanup = gtl::MakeCleanup([&decode]() {\n      std::cerr << \"Cleanup called...\\n\";\n      png::CommonFreeDecode(&decode);\n    });\n\n    // Verify that width and height are not too large:\n    // - verify width and height don't overflow int.\n    // - width can later be multiplied by channels_ and sizeof(uint16), so\n    //   verify single dimension is not too large.\n    // - verify when width and height are multiplied together, there are a few\n    //   bits to spare as well.\n    const int width = static_cast<int>(decode.width);\n    const int height = static_cast<int>(decode.height);\n    const int64_t total_size =\n        static_cast<int64_t>(width) * static_cast<int64_t>(height);\n    if (width != static_cast<int64_t>(decode.width) || width <= 0 ||\n        width >= (1LL << 27) || height != static_cast<int64_t>(decode.height) ||\n        height <= 0 || height >= (1LL << 27) || total_size >= (1LL << 29)) {\n      OP_REQUIRES(context, false,\n                  errors::InvalidArgument(\"PNG size too large for int: \",\n                                          decode.width, \" by \", decode.height));\n    }\n\n    Tensor* output = nullptr;\n    // By the existing API, we support decoding PNG with `DecodeGif` op.\n    // We need to make sure to return 4-D shapes when using `DecodeGif`.\n    if (op_type_ == \"DecodeGif\") {\n      OP_REQUIRES_OK(\n          context,\n          context->allocate_output(\n              0, TensorShape({1, height, width, decode.channels}), &output));\n    } else {\n      OP_REQUIRES_OK(\n          context,\n          context->allocate_output(\n              0, TensorShape({height, width, decode.channels}), &output));\n    }\n\n    if (op_type_ == \"DecodeBmp\") {\n      // TODO(b/171060723): Only DecodeBmp as op_type_ is not acceptable here\n      // because currently `decode_(jpeg|png|gif)` ops can decode any one of\n      // jpeg, png or gif but not bmp. Similarly, `decode_bmp` cannot decode\n      // anything but bmp formats. This behavior needs to be revisited. For more\n      // details, please refer to the bug.\n      OP_REQUIRES(context, false,\n                  errors::InvalidArgument(\n                      \"Trying to decode PNG format using DecodeBmp op. Use \"\n                      \"`decode_png` or `decode_image` instead.\"));\n    } else if (op_type_ == \"DecodeAndCropJpeg\") {\n      OP_REQUIRES(context, false,\n                  errors::InvalidArgument(\n                      \"DecodeAndCropJpeg operation can run on JPEG only, but \"\n                      \"detected PNG.\"));\n    }\n\n    if (data_type_ == DataType::DT_UINT8) {\n      OP_REQUIRES(\n          context,\n          png::CommonFinishDecode(\n              reinterpret_cast<png_bytep>(output->flat<uint8>().data()),\n              decode.channels * width * sizeof(uint8), &decode),\n          errors::InvalidArgument(\"Invalid PNG data, size \", input.size()));\n    } else if (data_type_ == DataType::DT_UINT16) {\n      OP_REQUIRES(\n          context,\n          png::CommonFinishDecode(\n              reinterpret_cast<png_bytep>(output->flat<uint16>().data()),\n              decode.channels * width * sizeof(uint16), &decode),\n          errors::InvalidArgument(\"Invalid PNG data, size \", input.size()));\n    } else if (data_type_ == DataType::DT_FLOAT) {\n      // `png::CommonFinishDecode` does not support `float`. First allocate\n      // uint16 buffer for the image and decode in uint16 (lossless). Wrap the\n      // buffer in `unique_ptr` so that we don't forget to delete the buffer.\n      std::unique_ptr<uint16[]> buffer(\n          new uint16[height * width * decode.channels]);\n      OP_REQUIRES(\n          context,\n          png::CommonFinishDecode(reinterpret_cast<png_bytep>(buffer.get()),\n                                  decode.channels * width * sizeof(uint16),\n                                  &decode),\n          errors::InvalidArgument(\"Invalid PNG data, size \", input.size()));\n\n      // Convert uint16 image data to desired data type.\n      // Use eigen threadpooling to speed up the copy operation.\n      const auto& device = context->eigen_device<Eigen::ThreadPoolDevice>();\n      TTypes<uint16, 3>::UnalignedConstTensor buf(buffer.get(), height, width,\n                                                  decode.channels);\n      float scale = 1. / std::numeric_limits<uint16>::max();\n      // Fill output tensor with desired dtype.\n      output->tensor<float, 3>().device(device) = buf.cast<float>() * scale;\n    }\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "vim",
    "cve_id": "CVE-2022-1769",
    "cwe_list": [
      "CWE-703"
    ],
    "commit_hash": "4748c4bd64610cf943a431d215bb1aad51f8d0b4",
    "short_hash": "4748c4bd",
    "vulnerableMethods_before": [
      {
        "filename": "scriptfile.c",
        "method_name": "vulnerable_function",
        "raw_code": "get_one_sourceline(source_cookie_T *sp)\n{\n    garray_T\t\tga;\n    int\t\t\tlen;\n    int\t\t\tc;\n    char_u\t\t*buf;\n#ifdef USE_CRNL\n    int\t\t\thas_cr;\t\t// CR-LF found\n#endif\n    int\t\t\thave_read = FALSE;\n\n    // use a growarray to store the sourced line\n    ga_init2(&ga, 1, 250);\n\n    // Loop until there is a finished line (or end-of-file).\n    ++sp->sourcing_lnum;\n    for (;;)\n    {\n\t// make room to read at least 120 (more) characters\n\tif (ga_grow(&ga, 120) == FAIL)\n\t    break;\n\tif (sp->source_from_buf)\n\t{\n\t    if (sp->buf_lnum >= sp->buflines.ga_len)\n\t\tbreak;\t\t    // all the lines are processed\n\t    ga_concat(&ga, ((char_u **)sp->buflines.ga_data)[sp->buf_lnum]);\n\t    sp->buf_lnum++;\n\t    if (ga_grow(&ga, 1) == FAIL)\n\t\tbreak;\n\t    buf = (char_u *)ga.ga_data;\n\t    buf[ga.ga_len++] = NUL;\n\t}\n\telse\n\t{\n\t    buf = (char_u *)ga.ga_data;\n\t    if (fgets((char *)buf + ga.ga_len, ga.ga_maxlen - ga.ga_len,\n\t\t\tsp->fp) == NULL)\n\t\tbreak;\n\t}\n\tlen = ga.ga_len + (int)STRLEN(buf + ga.ga_len);\n#ifdef USE_CRNL\n\t// Ignore a trailing CTRL-Z, when in Dos mode.\tOnly recognize the\n\t// CTRL-Z by its own, or after a NL.\n\tif (\t   (len == 1 || (len >= 2 && buf[len - 2] == '\\n'))\n\t\t&& sp->fileformat == EOL_DOS\n\t\t&& buf[len - 1] == Ctrl_Z)\n\t{\n\t    buf[len - 1] = NUL;\n\t    break;\n\t}\n#endif\n\n\thave_read = TRUE;\n\tga.ga_len = len;\n\n\t// If the line was longer than the buffer, read more.\n\tif (ga.ga_maxlen - ga.ga_len == 1 && buf[len - 1] != '\\n')\n\t    continue;\n\n\tif (len >= 1 && buf[len - 1] == '\\n')\t// remove trailing NL\n\t{\n#ifdef USE_CRNL\n\t    has_cr = (len >= 2 && buf[len - 2] == '\\r');\n\t    if (sp->fileformat == EOL_UNKNOWN)\n\t    {\n\t\tif (has_cr)\n\t\t    sp->fileformat = EOL_DOS;\n\t\telse\n\t\t    sp->fileformat = EOL_UNIX;\n\t    }\n\n\t    if (sp->fileformat == EOL_DOS)\n\t    {\n\t\tif (has_cr)\t    // replace trailing CR\n\t\t{\n\t\t    buf[len - 2] = '\\n';\n\t\t    --len;\n\t\t    --ga.ga_len;\n\t\t}\n\t\telse\t    // lines like \":map xx yy^M\" will have failed\n\t\t{\n\t\t    if (!sp->error)\n\t\t    {\n\t\t\tmsg_source(HL_ATTR(HLF_W));\n\t\t\temsg(_(\"W15: Warning: Wrong line separator, ^M may be missing\"));\n\t\t    }\n\t\t    sp->error = TRUE;\n\t\t    sp->fileformat = EOL_UNIX;\n\t\t}\n\t    }\n#endif\n\t    // The '\\n' is escaped if there is an odd number of ^V's just\n\t    // before it, first set \"c\" just before the 'V's and then check\n\t    // len&c parities (is faster than ((len-c)%2 == 0)) -- Acevedo\n\t    for (c = len - 2; c >= 0 && buf[c] == Ctrl_V; c--)\n\t\t;\n\t    if ((len & 1) != (c & 1))\t// escaped NL, read more\n\t    {\n\t\t++sp->sourcing_lnum;\n\t\tcontinue;\n\t    }\n\n\t    buf[len - 1] = NUL;\t\t// remove the NL\n\t}\n\n\t// Check for ^C here now and then, so recursive :so can be broken.\n\tline_breakcheck();\n\tbreak;\n    }\n\n    if (have_read)\n\treturn (char_u *)ga.ga_data;\n\n    vim_free(ga.ga_data);\n    return NULL;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "scriptfile.c",
        "method_name": "fixed_function",
        "raw_code": "get_one_sourceline(source_cookie_T *sp)\n{\n    garray_T\t\tga;\n    int\t\t\tlen;\n    int\t\t\tc;\n    char_u\t\t*buf;\n#ifdef USE_CRNL\n    int\t\t\thas_cr;\t\t// CR-LF found\n#endif\n    int\t\t\thave_read = FALSE;\n\n    // use a growarray to store the sourced line\n    ga_init2(&ga, 1, 250);\n\n    // Loop until there is a finished line (or end-of-file).\n    ++sp->sourcing_lnum;\n    for (;;)\n    {\n\t// make room to read at least 120 (more) characters\n\tif (ga_grow(&ga, 120) == FAIL)\n\t    break;\n\tif (sp->source_from_buf)\n\t{\n\t    if (sp->buf_lnum >= sp->buflines.ga_len)\n\t\tbreak;\t\t    // all the lines are processed\n\t    ga_concat(&ga, ((char_u **)sp->buflines.ga_data)[sp->buf_lnum]);\n\t    sp->buf_lnum++;\n\t    if (ga_grow(&ga, 1) == FAIL)\n\t\tbreak;\n\t    buf = (char_u *)ga.ga_data;\n\t    buf[ga.ga_len++] = NUL;\n\t    len = ga.ga_len;\n\t}\n\telse\n\t{\n\t    buf = (char_u *)ga.ga_data;\n\t    if (fgets((char *)buf + ga.ga_len, ga.ga_maxlen - ga.ga_len,\n\t\t\tsp->fp) == NULL)\n\t\tbreak;\n\t    len = ga.ga_len + (int)STRLEN(buf + ga.ga_len);\n\t}\n#ifdef USE_CRNL\n\t// Ignore a trailing CTRL-Z, when in Dos mode.\tOnly recognize the\n\t// CTRL-Z by its own, or after a NL.\n\tif (\t   (len == 1 || (len >= 2 && buf[len - 2] == '\\n'))\n\t\t&& sp->fileformat == EOL_DOS\n\t\t&& buf[len - 1] == Ctrl_Z)\n\t{\n\t    buf[len - 1] = NUL;\n\t    break;\n\t}\n#endif\n\n\thave_read = TRUE;\n\tga.ga_len = len;\n\n\t// If the line was longer than the buffer, read more.\n\tif (ga.ga_maxlen - ga.ga_len == 1 && buf[len - 1] != '\\n')\n\t    continue;\n\n\tif (len >= 1 && buf[len - 1] == '\\n')\t// remove trailing NL\n\t{\n#ifdef USE_CRNL\n\t    has_cr = (len >= 2 && buf[len - 2] == '\\r');\n\t    if (sp->fileformat == EOL_UNKNOWN)\n\t    {\n\t\tif (has_cr)\n\t\t    sp->fileformat = EOL_DOS;\n\t\telse\n\t\t    sp->fileformat = EOL_UNIX;\n\t    }\n\n\t    if (sp->fileformat == EOL_DOS)\n\t    {\n\t\tif (has_cr)\t    // replace trailing CR\n\t\t{\n\t\t    buf[len - 2] = '\\n';\n\t\t    --len;\n\t\t    --ga.ga_len;\n\t\t}\n\t\telse\t    // lines like \":map xx yy^M\" will have failed\n\t\t{\n\t\t    if (!sp->error)\n\t\t    {\n\t\t\tmsg_source(HL_ATTR(HLF_W));\n\t\t\temsg(_(\"W15: Warning: Wrong line separator, ^M may be missing\"));\n\t\t    }\n\t\t    sp->error = TRUE;\n\t\t    sp->fileformat = EOL_UNIX;\n\t\t}\n\t    }\n#endif\n\t    // The '\\n' is escaped if there is an odd number of ^V's just\n\t    // before it, first set \"c\" just before the 'V's and then check\n\t    // len&c parities (is faster than ((len-c)%2 == 0)) -- Acevedo\n\t    for (c = len - 2; c >= 0 && buf[c] == Ctrl_V; c--)\n\t\t;\n\t    if ((len & 1) != (c & 1))\t// escaped NL, read more\n\t    {\n\t\t++sp->sourcing_lnum;\n\t\tcontinue;\n\t    }\n\n\t    buf[len - 1] = NUL;\t\t// remove the NL\n\t}\n\n\t// Check for ^C here now and then, so recursive :so can be broken.\n\tline_breakcheck();\n\tbreak;\n    }\n\n    if (have_read)\n\treturn (char_u *)ga.ga_data;\n\n    vim_free(ga.ga_data);\n    return NULL;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"vim.h\"\n\n// Type Definitions:\n// garray_T:\ntypedef struct growarray\n{\n    int\t    ga_len;\t\t    // current number of items used\n    int\t    ga_maxlen;\t\t    // maximum number of items possible\n    int\t    ga_itemsize;\t    // sizeof(item)\n    int\t    ga_growsize;\t    // number of items to grow each time\n    void    *ga_data;\t\t    // pointer to the first item\n} garray_T;\n\n// source_cookie_T:\ntypedef struct {\n    FILE\t*fp;\t\t// opened file for sourcing\n    char_u\t*nextline;\t// if not NULL: line that was read ahead\n    linenr_T\tsourcing_lnum;\t// line number of the source file\n    int\t\tfinished;\t// \":finish\" used\n    int\t\tsource_from_buf;// TRUE if sourcing from current buffer\n    int\t\tbuf_lnum;\t// line number in the current buffer\n    garray_T\tbuflines;\t// lines in the current buffer\n#ifdef USE_CRNL\n    int\t\tfileformat;\t// EOL_UNKNOWN, EOL_UNIX or EOL_DOS\n    int\t\terror;\t\t// TRUE if LF found after CR-LF\n#endif\n#ifdef FEAT_EVAL\n    linenr_T\tbreakpoint;\t// next line with breakpoint or zero\n    char_u\t*fname;\t\t// name of sourced file\n    int\t\tdbg_tick;\t// debug_tick when breakpoint was set\n    int\t\tlevel;\t\t// top nesting level of sourced file\n#endif\n    vimconv_T\tconv;\t\t// type of conversion\n}\n\n// char_u:\ntypedef unsigned char\tchar_u;\n\n// Called Methods (top 10):\n// FALSE from src/vim.h:\n# define FALSE\t0\t    // note: this is an int, not a long! /* <=== src/vim.h:1475:1475:FALSE:0 */ \n\n// FAIL from src/vim.h:\n#define FAIL\t\t\t0 /* <=== src/vim.h:723:723:FAIL:0 */ \n\n// Ctrl_V from src/ascii.h:\n#define Ctrl_V\t\t22 /* <=== src/ascii.h:63:63:Ctrl_V:0 */ \n\n// ga_grow_inner from src/alloc.c:\n    int /* <=== ga_grow_inner */ \nga_grow_inner(garray_T *gap, int n)\n{\n    size_t\told_len;\n    size_t\tnew_len;\n    char_u\t*pp;\n\n    if (n < gap->ga_growsize)\n\tn = gap->ga_growsize;\n\n    // A linear growth is very inefficient when the array grows big.  This\n    // is a compromise between allocating memory that won't be used and too\n    // many copy operations. A factor of 1.5 seems reasonable.\n    if (n < gap->ga_len / 2)\n\tn = gap->ga_len / 2;\n\n    new_len = (size_t)gap->ga_itemsize * (gap->ga_len + n);\n    pp = vim_realloc(gap->ga_data, new_len);\n    if (pp == NULL)\n\treturn FAIL;\n    old_len = (size_t)gap->ga_itemsize * gap->ga_maxlen;\n    vim_memset(pp + old_len, 0, new_len - old_len);\n    gap->ga_maxlen = gap->ga_len + n;\n    gap->ga_data = pp;\n    return OK;\n}\n\n// BREAKCHECK_SKIP from src/misc1.c:\n# define BREAKCHECK_SKIP 1000 /* <=== src/misc1.c:2228:2228:BREAKCHECK_SKIP:0 */ \n\n// ga_concat from src/alloc.c:\n    void /* <=== ga_concat */ \nga_concat(garray_T *gap, char_u *s)\n{\n    int    len;\n\n    if (s == NULL || *s == NUL)\n\treturn;\n    len = (int)STRLEN(s);\n    if (ga_grow(gap, len) == OK)\n    {\n\tmch_memmove((char *)gap->ga_data + gap->ga_len, s, (size_t)len);\n\tgap->ga_len += len;\n    }\n}\n\n// STRLEN from src/vim.h:\n#define STRLEN(s)\t    strlen((char *)(s)) /* <=== src/vim.h:1641:1641:STRLEN:1 */ \n\n// TRUE from src/vim.h:\n# define TRUE\t1 /* <=== src/vim.h:1476:1476:TRUE:0 */ \n\n// line_breakcheck from src/misc1.c:\n    void /* <=== line_breakcheck */ \nline_breakcheck(void)\n{\n    if (++breakcheck_count >= BREAKCHECK_SKIP)\n    {\n\tbreakcheck_count = 0;\n\tui_breakcheck();\n    }\n}\n\n// mch_memmove from src/vim.h:\n# define mch_memmove(to, from, len) memmove((char*)(to), (char*)(from), (size_t)(len)) /* <=== src/vim.h:1764:1764:mch_memmove:3 */ \n"
  },
  {
    "repository": "vim",
    "cve_id": "CVE-2022-0318",
    "cwe_list": [
      "CWE-787"
    ],
    "commit_hash": "57df9e8a9f9ae1aafdde9b86b10ad907627a87dc",
    "short_hash": "57df9e8a",
    "vulnerableMethods_before": [
      {
        "filename": "None",
        "method_name": "vulnerable_function",
        "raw_code": "block_insert(\n    oparg_T\t\t*oap,\n    char_u\t\t*s,\n    int\t\t\tb_insert,\n    struct block_def\t*bdp)\n{\n    int\t\tts_val;\n    int\t\tcount = 0;\t// extra spaces to replace a cut TAB\n    int\t\tspaces = 0;\t// non-zero if cutting a TAB\n    colnr_T\toffset;\t\t// pointer along new line\n    colnr_T\tstartcol;\t// column where insert starts\n    unsigned\ts_len;\t\t// STRLEN(s)\n    char_u\t*newp, *oldp;\t// new, old lines\n    linenr_T\tlnum;\t\t// loop var\n    int\t\toldstate = State;\n\n    State = INSERT;\t\t// don't want REPLACE for State\n    s_len = (unsigned)STRLEN(s);\n\n    for (lnum = oap->start.lnum + 1; lnum <= oap->end.lnum; lnum++)\n    {\n\tblock_prep(oap, bdp, lnum, TRUE);\n\tif (bdp->is_short && b_insert)\n\t    continue;\t// OP_INSERT, line ends before block start\n\n\toldp = ml_get(lnum);\n\n\tif (b_insert)\n\t{\n\t    ts_val = bdp->start_char_vcols;\n\t    spaces = bdp->startspaces;\n\t    if (spaces != 0)\n\t\tcount = ts_val - 1; // we're cutting a TAB\n\t    offset = bdp->textcol;\n\t}\n\telse // append\n\t{\n\t    ts_val = bdp->end_char_vcols;\n\t    if (!bdp->is_short) // spaces = padding after block\n\t    {\n\t\tspaces = (bdp->endspaces ? ts_val - bdp->endspaces : 0);\n\t\tif (spaces != 0)\n\t\t    count = ts_val - 1; // we're cutting a TAB\n\t\toffset = bdp->textcol + bdp->textlen - (spaces != 0);\n\t    }\n\t    else // spaces = padding to block edge\n\t    {\n\t\t// if $ used, just append to EOL (ie spaces==0)\n\t\tif (!bdp->is_MAX)\n\t\t    spaces = (oap->end_vcol - bdp->end_vcol) + 1;\n\t\tcount = spaces;\n\t\toffset = bdp->textcol + bdp->textlen;\n\t    }\n\t}\n\n\tif (has_mbyte && spaces > 0)\n\t{\n\t    int off;\n\n\t    // Avoid starting halfway a multi-byte character.\n\t    if (b_insert)\n\t    {\n\t\toff = (*mb_head_off)(oldp, oldp + offset + spaces);\n\t\tspaces -= off;\n\t\tcount -= off;\n\t    }\n\t    else\n\t    {\n\t\t// spaces fill the gap, the character that's at the edge moves\n\t\t// right\n\t\toff = (*mb_head_off)(oldp, oldp + offset);\n\t\toffset -= off;\n\t    }\n\t}\n\tif (spaces < 0)  // can happen when the cursor was moved\n\t    spaces = 0;\n\n\t// Make sure the allocated size matches what is actually copied below.\n\tnewp = alloc(STRLEN(oldp) + spaces + s_len\n\t\t    + (spaces > 0 && !bdp->is_short ? ts_val - spaces : 0)\n\t\t\t\t\t\t\t\t  + count + 1);\n\tif (newp == NULL)\n\t    continue;\n\n\t// copy up to shifted part\n\tmch_memmove(newp, oldp, (size_t)offset);\n\toldp += offset;\n\n\t// insert pre-padding\n\tvim_memset(newp + offset, ' ', (size_t)spaces);\n\tstartcol = offset + spaces;\n\n\t// copy the new text\n\tmch_memmove(newp + startcol, s, (size_t)s_len);\n\toffset += s_len;\n\n\tif (spaces > 0 && !bdp->is_short)\n\t{\n\t    if (*oldp == TAB)\n\t    {\n\t\t// insert post-padding\n\t\tvim_memset(newp + offset + spaces, ' ',\n\t\t\t\t\t\t    (size_t)(ts_val - spaces));\n\t\t// we're splitting a TAB, don't copy it\n\t\toldp++;\n\t\t// We allowed for that TAB, remember this now\n\t\tcount++;\n\t    }\n\t    else\n\t\t// Not a TAB, no extra spaces\n\t\tcount = spaces;\n\t}\n\n\tif (spaces > 0)\n\t    offset += count;\n\tSTRMOVE(newp + offset, oldp);\n\n\tml_replace(lnum, newp, FALSE);\n\n\tif (b_insert)\n\t    // correct any text properties\n\t    inserted_bytes(lnum, startcol, s_len);\n\n\tif (lnum == oap->end.lnum)\n\t{\n\t    // Set \"']\" mark to the end of the block instead of the end of\n\t    // the insert in the first line.\n\t    curbuf->b_op_end.lnum = oap->end.lnum;\n\t    curbuf->b_op_end.col = offset;\n\t}\n    } // for all lnum\n\n    changed_lines(oap->start.lnum + 1, 0, oap->end.lnum + 1, 0L);\n\n    State = oldstate;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "None",
        "method_name": "fixed_function",
        "raw_code": "block_insert(\n    oparg_T\t\t*oap,\n    char_u\t\t*s,\n    int\t\t\tb_insert,\n    struct block_def\t*bdp)\n{\n    int\t\tts_val;\n    int\t\tcount = 0;\t// extra spaces to replace a cut TAB\n    int\t\tspaces = 0;\t// non-zero if cutting a TAB\n    colnr_T\toffset;\t\t// pointer along new line\n    colnr_T\tstartcol;\t// column where insert starts\n    unsigned\ts_len;\t\t// STRLEN(s)\n    char_u\t*newp, *oldp;\t// new, old lines\n    linenr_T\tlnum;\t\t// loop var\n    int\t\toldstate = State;\n\n    State = INSERT;\t\t// don't want REPLACE for State\n    s_len = (unsigned)STRLEN(s);\n\n    for (lnum = oap->start.lnum + 1; lnum <= oap->end.lnum; lnum++)\n    {\n\tblock_prep(oap, bdp, lnum, TRUE);\n\tif (bdp->is_short && b_insert)\n\t    continue;\t// OP_INSERT, line ends before block start\n\n\toldp = ml_get(lnum);\n\n\tif (b_insert)\n\t{\n\t    ts_val = bdp->start_char_vcols;\n\t    spaces = bdp->startspaces;\n\t    if (spaces != 0)\n\t\tcount = ts_val - 1; // we're cutting a TAB\n\t    offset = bdp->textcol;\n\t}\n\telse // append\n\t{\n\t    ts_val = bdp->end_char_vcols;\n\t    if (!bdp->is_short) // spaces = padding after block\n\t    {\n\t\tspaces = (bdp->endspaces ? ts_val - bdp->endspaces : 0);\n\t\tif (spaces != 0)\n\t\t    count = ts_val - 1; // we're cutting a TAB\n\t\toffset = bdp->textcol + bdp->textlen - (spaces != 0);\n\t    }\n\t    else // spaces = padding to block edge\n\t    {\n\t\t// if $ used, just append to EOL (ie spaces==0)\n\t\tif (!bdp->is_MAX)\n\t\t    spaces = (oap->end_vcol - bdp->end_vcol) + 1;\n\t\tcount = spaces;\n\t\toffset = bdp->textcol + bdp->textlen;\n\t    }\n\t}\n\n\tif (has_mbyte && spaces > 0)\n\t    // avoid copying part of a multi-byte character\n\t    offset -= (*mb_head_off)(oldp, oldp + offset);\n\n\tif (spaces < 0)  // can happen when the cursor was moved\n\t    spaces = 0;\n\n\t// Make sure the allocated size matches what is actually copied below.\n\tnewp = alloc(STRLEN(oldp) + spaces + s_len\n\t\t    + (spaces > 0 && !bdp->is_short ? ts_val - spaces : 0)\n\t\t\t\t\t\t\t\t  + count + 1);\n\tif (newp == NULL)\n\t    continue;\n\n\t// copy up to shifted part\n\tmch_memmove(newp, oldp, (size_t)offset);\n\toldp += offset;\n\n\t// insert pre-padding\n\tvim_memset(newp + offset, ' ', (size_t)spaces);\n\tstartcol = offset + spaces;\n\n\t// copy the new text\n\tmch_memmove(newp + startcol, s, (size_t)s_len);\n\toffset += s_len;\n\n\tif (spaces > 0 && !bdp->is_short)\n\t{\n\t    if (*oldp == TAB)\n\t    {\n\t\t// insert post-padding\n\t\tvim_memset(newp + offset + spaces, ' ',\n\t\t\t\t\t\t    (size_t)(ts_val - spaces));\n\t\t// we're splitting a TAB, don't copy it\n\t\toldp++;\n\t\t// We allowed for that TAB, remember this now\n\t\tcount++;\n\t    }\n\t    else\n\t\t// Not a TAB, no extra spaces\n\t\tcount = spaces;\n\t}\n\n\tif (spaces > 0)\n\t    offset += count;\n\tSTRMOVE(newp + offset, oldp);\n\n\tml_replace(lnum, newp, FALSE);\n\n\tif (b_insert)\n\t    // correct any text properties\n\t    inserted_bytes(lnum, startcol, s_len);\n\n\tif (lnum == oap->end.lnum)\n\t{\n\t    // Set \"']\" mark to the end of the block instead of the end of\n\t    // the insert in the first line.\n\t    curbuf->b_op_end.lnum = oap->end.lnum;\n\t    curbuf->b_op_end.col = offset;\n\t}\n    } // for all lnum\n\n    changed_lines(oap->start.lnum + 1, 0, oap->end.lnum + 1, 0L);\n\n    State = oldstate;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"vim.h\"\n\n// Type Definitions:\n// block_def:\nstruct block_def\n{\n    int\t\tstartspaces;\t// 'extra' cols before first char\n    int\t\tendspaces;\t// 'extra' cols after last char\n    int\t\ttextlen;\t// chars in block\n    char_u\t*textstart;\t// pointer to 1st char (partially) in block\n    colnr_T\ttextcol;\t// index of chars (partially) in block\n    colnr_T\tstart_vcol;\t// start col of 1st char wholly inside block\n    colnr_T\tend_vcol;\t// start col of 1st char wholly after block\n    int\t\tis_short;\t// TRUE if line is too short to fit in block\n    int\t\tis_MAX;\t\t// TRUE if curswant==MAXCOL when starting\n    int\t\tis_oneChar;\t// TRUE if block within one character\n    int\t\tpre_whitesp;\t// screen cols of ws before block\n    int\t\tpre_whitesp_c;\t// chars of ws before block\n    colnr_T\tend_char_vcols;\t// number of vcols of post-block char\n    colnr_T\tstart_char_vcols; // number of vcols of pre-block char\n}\n\n// colnr_T:\ntypedef int\tcolnr_T;\n\n// oparg_T:\ntypedef struct oparg_S\n{\n    int\t\top_type;\t// current pending operator type\n    int\t\tregname;\t// register to use for the operator\n    int\t\tmotion_type;\t// type of the current cursor motion\n    int\t\tmotion_force;\t// force motion type: 'v', 'V' or CTRL-V\n    int\t\tuse_reg_one;\t// TRUE if delete uses reg 1 even when not\n\t\t\t\t// linewise\n    int\t\tinclusive;\t// TRUE if char motion is inclusive (only\n\t\t\t\t// valid when motion_type is MCHAR)\n    int\t\tend_adjusted;\t// backuped b_op_end one char (only used by\n\t\t\t\t// do_format())\n    pos_T\tstart;\t\t// start of the operator\n    pos_T\tend;\t\t// end of the operator\n    pos_T\tcursor_start;\t// cursor position before motion for \"gw\"\n\n    long\tline_count;\t// number of lines from op_start to op_end\n\t\t\t\t// (inclusive)\n    int\t\tempty;\t\t// op_start and op_end the same (only used by\n\t\t\t\t// do_change())\n    int\t\tis_VIsual;\t// operator on Visual area\n    int\t\tblock_mode;\t// current operator is Visual block mode\n    colnr_T\tstart_vcol;\t// start col for block mod...\n\n// colnr_T:\ntypedef int\t\tcolnr_T;\n\n// char_u:\ntypedef unsigned char\tchar_u;\n\n// linenr_T:\ntypedef long\t\tlinenr_T;\n\n// linenr_T:\ntypedef long\tlinenr_T;\n\n// Called Methods (top 10):\n// get_trans_bufname from src/screen.c:\n    void /* <=== get_trans_bufname */ \nget_trans_bufname(buf_T *buf)\n{\n    if (buf_spname(buf) != NULL)\n\tvim_strncpy(NameBuff, buf_spname(buf), MAXPATHL - 1);\n    else\n\thome_replace(buf, buf->b_fname, NameBuff, MAXPATHL, TRUE);\n    trans_characters(NameBuff, MAXPATHL);\n}\n\n// lbr_chartabsize from src/charset.c:\n    int /* <=== lbr_chartabsize */ \nlbr_chartabsize(\n    char_u\t\t*line UNUSED, // start of the line\n    unsigned char\t*s,\n    colnr_T\t\tcol)\n{\n#ifdef FEAT_LINEBREAK\n    if (!curwin->w_p_lbr && *get_showbreak_value(curwin) == NUL\n\t\t\t\t\t\t\t   && !curwin->w_p_bri)\n    {\n#endif\n\tif (curwin->w_p_wrap)\n\t    return win_nolbr_chartabsize(curwin, s, col, NULL);\n\tRET_WIN_BUF_CHARTABSIZE(curwin, curbuf, s, col)\n#ifdef FEAT_LINEBREAK\n    }\n    return win_lbr_chartabsize(curwin, line == NULL ? s : line, s, col, NULL);\n#endif\n}\n\n// foldUpdate from src/fold.c:\n    void /* <=== foldUpdate */ \nfoldUpdate(win_T *wp, linenr_T top, linenr_T bot)\n{\n    fold_T\t*fp;\n\n    if (disable_fold_update > 0)\n\treturn;\n#ifdef FEAT_DIFF\n    if (need_diff_redraw)\n\t// will update later\n\treturn;\n#endif\n\n    if (wp->w_folds.ga_len > 0)\n    {\n\t// Mark all folds from top to bot as maybe-small.\n\t(void)foldFind(&wp->w_folds, top, &fp);\n\twhile (fp < (fold_T *)wp->w_folds.ga_data + wp->w_folds.ga_len\n\t\t&& fp->fd_top < bot)\n\t{\n\t    fp->fd_small = MAYBE;\n\t    ++fp;\n\t}\n    }\n\n    if (foldmethodIsIndent(wp)\n\t    || foldmethodIsExpr(wp)\n\t    || foldmethodIsMarker(wp)\n#ifdef FEAT_DIFF\n\t    || foldmethodIsDiff(wp)\n#endif\n\t    || foldmethodIsSyntax(wp))\n    {\n\tint save_got_int = got_int;\n\n\t// reset got_int here, otherwise it won't work\n\tgot_int = FALSE;\n\tfoldUpdateIEMS(wp, top, bot);\n\tgot_int |= save_got_int;\n    }\n}\n\n// ml_replace_len from src/memline.c:\n    int /* <=== ml_replace_len */ \nml_replace_len(\n\tlinenr_T    lnum,\n\tchar_u\t    *line_arg,\n\tcolnr_T\t    len_arg,\n\tint\t    has_props,\n\tint\t    copy)\n{\n    char_u *line = line_arg;\n    colnr_T len = len_arg;\n\n    if (line == NULL)\t\t// just checking...\n\treturn FAIL;\n\n    // When starting up, we might still need to create the memfile\n    if (curbuf->b_ml.ml_mfp == NULL && open_buffer(FALSE, NULL, 0) == FAIL)\n\treturn FAIL;\n\n    if (!has_props)\n\t++len;  // include the NUL after the text\n    if (copy)\n    {\n\t// copy the line to allocated memory\n#ifdef FEAT_PROP_POPUP\n\tif (has_props)\n\t    line = vim_memsave(line, len);\n\telse\n#endif\n\t    line = vim_strnsave(line, len - 1);\n\tif (line == NULL)\n\t    return FAIL;\n    }\n\n#ifdef FEAT_NETBEANS_INTG\n    if (netbeans_active())\n    {\n\tnetbeans_removed(curbuf, lnum, 0, (long)STRLEN(ml_get(lnum)));\n\tnetbeans_inserted(curbuf, lnum, 0, line, (int)STRLEN(line));\n    }\n#endif\n    if (curbuf->b_ml.ml_line_lnum != lnum)\n    {\n\t// another line is buffered, flush it\n\tml_flush_line(curbuf);\n\tcurbuf->b_ml.ml_flags &= ~ML_LINE_DIRTY;\n\n#ifdef FEAT_PROP_POPUP\n\tif (curbuf->b_has_textprop && !has_props)\n\t    // Need to fetch the old line to copy over any text properties.\n\t    ml_get_buf(curbuf, lnum, TRUE);\n#endif\n    }\n\n#ifdef FEAT_PROP_POPUP\n    if (curbuf->b_has_textprop && !has_props)\n    {\n\tsize_t\toldtextlen = STRLEN(curbuf->b_ml.ml_line_ptr) + 1;\n\n\tif (oldtextlen < (size_t)curbuf->b_ml.ml_line_len)\n\t{\n\t    char_u *newline;\n\t    size_t textproplen = curbuf->b_ml.ml_line_len - oldtextlen;\n\n\t    // Need to copy over text properties, stored after the text.\n\t    newline = alloc(len + (int)textproplen);\n\t    if (newline != NULL)\n\t    {\n\t\tmch_memmove(newline, line, len);\n\t\tmch_memmove(newline + len, curbuf->b_ml.ml_line_ptr\n\t\t\t\t\t\t    + oldtextlen, textproplen);\n\t\tvim_free(line);\n\t\tline = newline;\n\t\tlen += (colnr_T)textproplen;\n\t    }\n\t}\n    }\n#endif\n\n    if (curbuf->b_ml.ml_flags & ML_LINE_DIRTY)\t// same line allocated\n\tvim_free(curbuf->b_ml.ml_line_ptr);\t// free it\n\n    curbuf->b_ml.ml_line_ptr = line;\n    curbuf->b_ml.ml_line_len = len;\n    curbuf->b_ml.ml_line_lnum = lnum;\n    curbuf->b_ml.ml_flags = (curbuf->b_ml.ml_flags | ML_LINE_DIRTY) & ~ML_EMPTY;\n\n    return OK;\n}\n\n// ml_get_buf from src/memline.c:\n    char_u  * /* <=== ml_get_buf */ \nml_get_buf(\n    buf_T\t*buf,\n    linenr_T\tlnum,\n    int\t\twill_change)\t\t// line will be changed\n{\n    bhdr_T\t*hp;\n    DATA_BL\t*dp;\n    static int\trecursive = 0;\n    static char_u questions[4];\n\n    if (lnum > buf->b_ml.ml_line_count)\t// invalid line number\n    {\n\tif (recursive == 0)\n\t{\n\t    // Avoid giving this message for a recursive call, may happen when\n\t    // the GUI redraws part of the text.\n\t    ++recursive;\n\t    siemsg(_(e_ml_get_invalid_lnum_nr), lnum);\n\t    --recursive;\n\t}\nerrorret:\n\tSTRCPY(questions, \"???\");\n\tbuf->b_ml.ml_line_len = 4;\n\treturn questions;\n    }\n    if (lnum <= 0)\t\t\t// pretend line 0 is line 1\n\tlnum = 1;\n\n    if (buf->b_ml.ml_mfp == NULL)\t// there are no lines\n    {\n\tbuf->b_ml.ml_line_len = 1;\n\treturn (char_u *)\"\";\n    }\n\n    /*\n     * See if it is the same line as requested last time.\n     * Otherwise may need to flush last used line.\n     * Don't use the last used line when 'swapfile' is reset, need to load all\n     * blocks.\n     */\n    if (buf->b_ml.ml_line_lnum != lnum || mf_dont_release)\n    {\n\tunsigned    start, end;\n\tcolnr_T\t    len;\n\tint\t    idx;\n\n\tml_flush_line(buf);\n\n\t/*\n\t * Find the data block containing the line.\n\t * This also fills the stack with the blocks from the root to the data\n\t * block and releases any locked block.\n\t */\n\tif ((hp = ml_find_line(buf, lnum, ML_FIND)) == NULL)\n\t{\n\t    if (recursive == 0)\n\t    {\n\t\t// Avoid giving this message for a recursive call, may happen\n\t\t// when the GUI redraws part of the text.\n\t\t++recursive;\n\t\tget_trans_bufname(buf);\n\t\tshorten_dir(NameBuff);\n\t\tsiemsg(_(e_ml_get_cannot_find_line_nr_in_buffer_nr_str),\n\t\t\t\t\t\t  lnum, buf->b_fnum, NameBuff);\n\t\t--recursive;\n\t    }\n\t    goto errorret;\n\t}\n\n\tdp = (DATA_BL *)(hp->bh_data);\n\n\tidx = lnum - buf->b_ml.ml_locked_low;\n\tstart = ((dp->db_index[idx]) & DB_INDEX_MASK);\n\t// The text ends where the previous line starts.  The first line ends\n\t// at the end of the block.\n\tif (idx == 0)\n\t    end = dp->db_txt_end;\n\telse\n\t    end = ((dp->db_index[idx - 1]) & DB_INDEX_MASK);\n\tlen = end - start;\n\n\tbuf->b_ml.ml_line_ptr = (char_u *)dp + start;\n\tbuf->b_ml.ml_line_len = len;\n\tbuf->b_ml.ml_line_lnum = lnum;\n\tbuf->b_ml.ml_flags &= ~ML_LINE_DIRTY;\n    }\n    if (will_change)\n\tbuf->b_ml.ml_flags |= (ML_LOCKED_DIRTY | ML_LOCKED_POS);\n\n    return buf->b_ml.ml_line_ptr;\n}\n\n// ml_flush_line from src/memline.c:\n    static void /* <=== ml_flush_line */ \nml_flush_line(buf_T *buf)\n{\n    bhdr_T\t*hp;\n    DATA_BL\t*dp;\n    linenr_T\tlnum;\n    char_u\t*new_line;\n    char_u\t*old_line;\n    colnr_T\tnew_len;\n    int\t\told_len;\n    int\t\textra;\n    int\t\tidx;\n    int\t\tstart;\n    int\t\tcount;\n    int\t\ti;\n    static int  entered = FALSE;\n\n    if (buf->b_ml.ml_line_lnum == 0 || buf->b_ml.ml_mfp == NULL)\n\treturn;\t\t// nothing to do\n\n    if (buf->b_ml.ml_flags & ML_LINE_DIRTY)\n    {\n\t// This code doesn't work recursively, but Netbeans may call back here\n\t// when obtaining the cursor position.\n\tif (entered)\n\t    return;\n\tentered = TRUE;\n\n\tlnum = buf->b_ml.ml_line_lnum;\n\tnew_line = buf->b_ml.ml_line_ptr;\n\n\thp = ml_find_line(buf, lnum, ML_FIND);\n\tif (hp == NULL)\n\t    siemsg(_(e_cannot_find_line_nr), lnum);\n\telse\n\t{\n\t    dp = (DATA_BL *)(hp->bh_data);\n\t    idx = lnum - buf->b_ml.ml_locked_low;\n\t    start = ((dp->db_index[idx]) & DB_INDEX_MASK);\n\t    old_line = (char_u *)dp + start;\n\t    if (idx == 0)\t// line is last in block\n\t\told_len = dp->db_txt_end - start;\n\t    else\t\t// text of previous line follows\n\t\told_len = (dp->db_index[idx - 1] & DB_INDEX_MASK) - start;\n\t    new_len = buf->b_ml.ml_line_len;\n\t    extra = new_len - old_len;\t    // negative if lines gets smaller\n\n\t    /*\n\t     * if new line fits in data block, replace directly\n\t     */\n\t    if ((int)dp->db_free >= extra)\n\t    {\n#if defined(FEAT_BYTEOFF) && defined(FEAT_PROP_POPUP)\n\t\tint old_prop_len = 0;\n#endif\n\t\t// if the length changes and there are following lines\n\t\tcount = buf->b_ml.ml_locked_high - buf->b_ml.ml_locked_low + 1;\n\t\tif (extra != 0 && idx < count - 1)\n\t\t{\n\t\t    // move text of following lines\n\t\t    mch_memmove((char *)dp + dp->db_txt_start - extra,\n\t\t\t\t(char *)dp + dp->db_txt_start,\n\t\t\t\t(size_t)(start - dp->db_txt_start));\n\n\t\t    // adjust pointers of this and following lines\n\t\t    for (i = idx + 1; i < count; ++i)\n\t\t\tdp->db_index[i] -= extra;\n\t\t}\n\t\tdp->db_index[idx] -= extra;\n\n\t\t// adjust free space\n\t\tdp->db_free -= extra;\n\t\tdp->db_txt_start -= extra;\n#if defined(FEAT_BYTEOFF) && defined(FEAT_PROP_POPUP)\n\t\tif (buf->b_has_textprop)\n\t\t    old_prop_len = old_len - (int)STRLEN(new_line) - 1;\n#endif\n\n\t\t// copy new line into the data block\n\t\tmch_memmove(old_line - extra, new_line, (size_t)new_len);\n\t\tbuf->b_ml.ml_flags |= (ML_LOCKED_DIRTY | ML_LOCKED_POS);\n#if defined(FEAT_BYTEOFF) && defined(FEAT_PROP_POPUP)\n\t\t// The else case is already covered by the insert and delete\n\t\tif (buf->b_has_textprop)\n\t\t{\n\t\t    // Do not count the size of any text properties.\n\t\t    extra += old_prop_len;\n\t\t    extra -= new_len - (int)STRLEN(new_line) - 1;\n\t\t}\n\t\tif (extra != 0)\n\t\t    ml_updatechunk(buf, lnum, (long)extra, ML_CHNK_UPDLINE);\n#endif\n\t    }\n\t    else\n\t    {\n\t\t/*\n\t\t * Cannot do it in one data block: Delete and append.\n\t\t * Append first, because ml_delete_int() cannot delete the\n\t\t * last line in a buffer, which causes trouble for a buffer\n\t\t * that has only one line.\n\t\t * Don't forget to copy the mark!\n\t\t */\n\t\t// How about handling errors???\n\t\t(void)ml_append_int(buf, lnum, new_line, new_len,\n\t\t\t ((dp->db_index[idx] & DB_MARKED) ? ML_APPEND_MARK : 0)\n#ifdef FEAT_PROP_POPUP\n\t\t\t     | ML_APPEND_NOPROP\n#endif\n\t\t\t );\n\t\t(void)ml_delete_int(buf, lnum, ML_DEL_NOPROP);\n\t    }\n\t}\n\tvim_free(new_line);\n\n\tentered = FALSE;\n    }\n\n    buf->b_ml.ml_line_lnum = 0;\n}\n\n// siemsg from src/message.c:\n    void /* <=== siemsg */ \nsiemsg(const char *s, ...)\n{\n    if (!emsg_not_now())\n    {\n\tif (IObuff == NULL)\n\t{\n\t    // Very early in initialisation and already something wrong, just\n\t    // give the raw message so the user at least gets a hint.\n\t    emsg_core((char_u *)s);\n\t}\n\telse\n\t{\n\t    va_list ap;\n\n\t    va_start(ap, s);\n\t    vim_vsnprintf((char *)IObuff, IOSIZE, s, ap);\n\t    va_end(ap);\n\t    emsg_core(IObuff);\n\t}\n    }\n# ifdef ABORT_ON_INTERNAL_ERROR\n    abort();\n# endif\n}\n\n// comp_textwidth from src/textformat.c:\n    int /* <=== comp_textwidth */ \ncomp_textwidth(\n    int\t\tff)\t// force formatting (for \"gq\" command)\n{\n    int\t\ttextwidth;\n\n    textwidth = curbuf->b_p_tw;\n    if (textwidth == 0 && curbuf->b_p_wm)\n    {\n\t// The width is the window width minus 'wrapmargin' minus all the\n\t// things that add to the margin.\n\ttextwidth = curwin->w_width - curbuf->b_p_wm;\n#ifdef FEAT_CMDWIN\n\tif (cmdwin_type != 0)\n\t    textwidth -= 1;\n#endif\n#ifdef FEAT_FOLDING\n\ttextwidth -= curwin->w_p_fdc;\n#endif\n#ifdef FEAT_SIGNS\n\tif (signcolumn_on(curwin))\n\t    textwidth -= 1;\n#endif\n\tif (curwin->w_p_nu || curwin->w_p_rnu)\n\t    textwidth -= 8;\n    }\n    if (textwidth < 0)\n\ttextwidth = 0;\n    if (ff && textwidth == 0)\n    {\n\ttextwidth = curwin->w_width - 1;\n\tif (textwidth > 79)\n\t    textwidth = 79;\n    }\n    return textwidth;\n}\n\n// vim_memsave from src/alloc.c:\n    char_u * /* <=== vim_memsave */ \nvim_memsave(char_u *p, size_t len)\n{\n    char_u *ret = alloc(len);\n\n    if (ret != NULL)\n\tmch_memmove(ret, p, len);\n    return ret;\n}\n\n// RET_WIN_BUF_CHARTABSIZE from src/charset.c:\n# define RET_WIN_BUF_CHARTABSIZE(wp, buf, p, col) \\ /* <=== src/charset.c:761:769:RET_WIN_BUF_CHARTABSIZE:4 */ \n    if (*(p) == TAB && (!(wp)->w_p_list || wp->w_lcs_chars.tab1)) \\\n    { \\\n\tint ts; \\\n\tts = (buf)->b_p_ts; \\\n\treturn (int)(ts - (col % ts)); \\\n    } \\\n    else \\\n\treturn ptr2cells(p);\n"
  },
  {
    "repository": "linux",
    "cve_id": "CVE-2021-38205",
    "cwe_list": [
      "CWE-703"
    ],
    "commit_hash": "d0d62baa7f505bd4c59cd169692ff07ec49dde37",
    "short_hash": "d0d62baa",
    "vulnerableMethods_before": [
      {
        "filename": "xilinx_emaclite.c",
        "method_name": "vulnerable_function",
        "raw_code": "static int xemaclite_of_probe(struct platform_device *ofdev)\n{\n\tstruct resource *res;\n\tstruct net_device *ndev = NULL;\n\tstruct net_local *lp = NULL;\n\tstruct device *dev = &ofdev->dev;\n\n\tint rc = 0;\n\n\tdev_info(dev, \"Device Tree Probing\\n\");\n\n\t/* Create an ethernet device instance */\n\tndev = alloc_etherdev(sizeof(struct net_local));\n\tif (!ndev)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, ndev);\n\tSET_NETDEV_DEV(ndev, &ofdev->dev);\n\n\tlp = netdev_priv(ndev);\n\tlp->ndev = ndev;\n\n\t/* Get IRQ for the device */\n\tres = platform_get_resource(ofdev, IORESOURCE_IRQ, 0);\n\tif (!res) {\n\t\tdev_err(dev, \"no IRQ found\\n\");\n\t\trc = -ENXIO;\n\t\tgoto error;\n\t}\n\n\tndev->irq = res->start;\n\n\tres = platform_get_resource(ofdev, IORESOURCE_MEM, 0);\n\tlp->base_addr = devm_ioremap_resource(&ofdev->dev, res);\n\tif (IS_ERR(lp->base_addr)) {\n\t\trc = PTR_ERR(lp->base_addr);\n\t\tgoto error;\n\t}\n\n\tndev->mem_start = res->start;\n\tndev->mem_end = res->end;\n\n\tspin_lock_init(&lp->reset_lock);\n\tlp->next_tx_buf_to_use = 0x0;\n\tlp->next_rx_buf_to_use = 0x0;\n\tlp->tx_ping_pong = get_bool(ofdev, \"xlnx,tx-ping-pong\");\n\tlp->rx_ping_pong = get_bool(ofdev, \"xlnx,rx-ping-pong\");\n\n\trc = of_get_mac_address(ofdev->dev.of_node, ndev->dev_addr);\n\tif (rc) {\n\t\tdev_warn(dev, \"No MAC address found, using random\\n\");\n\t\teth_hw_addr_random(ndev);\n\t}\n\n\t/* Clear the Tx CSR's in case this is a restart */\n\txemaclite_writel(0, lp->base_addr + XEL_TSR_OFFSET);\n\txemaclite_writel(0, lp->base_addr + XEL_BUFFER_OFFSET + XEL_TSR_OFFSET);\n\n\t/* Set the MAC address in the EmacLite device */\n\txemaclite_update_address(lp, ndev->dev_addr);\n\n\tlp->phy_node = of_parse_phandle(ofdev->dev.of_node, \"phy-handle\", 0);\n\txemaclite_mdio_setup(lp, &ofdev->dev);\n\n\tdev_info(dev, \"MAC address is now %pM\\n\", ndev->dev_addr);\n\n\tndev->netdev_ops = &xemaclite_netdev_ops;\n\tndev->ethtool_ops = &xemaclite_ethtool_ops;\n\tndev->flags &= ~IFF_MULTICAST;\n\tndev->watchdog_timeo = TX_TIMEOUT;\n\n\t/* Finally, register the device */\n\trc = register_netdev(ndev);\n\tif (rc) {\n\t\tdev_err(dev,\n\t\t\t\"Cannot register network device, aborting\\n\");\n\t\tgoto error;\n\t}\n\n\tdev_info(dev,\n\t\t \"Xilinx EmacLite at 0x%08lX mapped to 0x%08lX, irq=%d\\n\",\n\t\t (unsigned long __force)ndev->mem_start,\n\t\t (unsigned long __force)lp->base_addr, ndev->irq);\n\treturn 0;\n\nerror:\n\tfree_netdev(ndev);\n\treturn rc;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "xilinx_emaclite.c",
        "method_name": "fixed_function",
        "raw_code": "static int xemaclite_of_probe(struct platform_device *ofdev)\n{\n\tstruct resource *res;\n\tstruct net_device *ndev = NULL;\n\tstruct net_local *lp = NULL;\n\tstruct device *dev = &ofdev->dev;\n\n\tint rc = 0;\n\n\tdev_info(dev, \"Device Tree Probing\\n\");\n\n\t/* Create an ethernet device instance */\n\tndev = alloc_etherdev(sizeof(struct net_local));\n\tif (!ndev)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, ndev);\n\tSET_NETDEV_DEV(ndev, &ofdev->dev);\n\n\tlp = netdev_priv(ndev);\n\tlp->ndev = ndev;\n\n\t/* Get IRQ for the device */\n\tres = platform_get_resource(ofdev, IORESOURCE_IRQ, 0);\n\tif (!res) {\n\t\tdev_err(dev, \"no IRQ found\\n\");\n\t\trc = -ENXIO;\n\t\tgoto error;\n\t}\n\n\tndev->irq = res->start;\n\n\tres = platform_get_resource(ofdev, IORESOURCE_MEM, 0);\n\tlp->base_addr = devm_ioremap_resource(&ofdev->dev, res);\n\tif (IS_ERR(lp->base_addr)) {\n\t\trc = PTR_ERR(lp->base_addr);\n\t\tgoto error;\n\t}\n\n\tndev->mem_start = res->start;\n\tndev->mem_end = res->end;\n\n\tspin_lock_init(&lp->reset_lock);\n\tlp->next_tx_buf_to_use = 0x0;\n\tlp->next_rx_buf_to_use = 0x0;\n\tlp->tx_ping_pong = get_bool(ofdev, \"xlnx,tx-ping-pong\");\n\tlp->rx_ping_pong = get_bool(ofdev, \"xlnx,rx-ping-pong\");\n\n\trc = of_get_mac_address(ofdev->dev.of_node, ndev->dev_addr);\n\tif (rc) {\n\t\tdev_warn(dev, \"No MAC address found, using random\\n\");\n\t\teth_hw_addr_random(ndev);\n\t}\n\n\t/* Clear the Tx CSR's in case this is a restart */\n\txemaclite_writel(0, lp->base_addr + XEL_TSR_OFFSET);\n\txemaclite_writel(0, lp->base_addr + XEL_BUFFER_OFFSET + XEL_TSR_OFFSET);\n\n\t/* Set the MAC address in the EmacLite device */\n\txemaclite_update_address(lp, ndev->dev_addr);\n\n\tlp->phy_node = of_parse_phandle(ofdev->dev.of_node, \"phy-handle\", 0);\n\txemaclite_mdio_setup(lp, &ofdev->dev);\n\n\tdev_info(dev, \"MAC address is now %pM\\n\", ndev->dev_addr);\n\n\tndev->netdev_ops = &xemaclite_netdev_ops;\n\tndev->ethtool_ops = &xemaclite_ethtool_ops;\n\tndev->flags &= ~IFF_MULTICAST;\n\tndev->watchdog_timeo = TX_TIMEOUT;\n\n\t/* Finally, register the device */\n\trc = register_netdev(ndev);\n\tif (rc) {\n\t\tdev_err(dev,\n\t\t\t\"Cannot register network device, aborting\\n\");\n\t\tgoto error;\n\t}\n\n\tdev_info(dev,\n\t\t \"Xilinx EmacLite at 0x%08lX mapped to 0x%p, irq=%d\\n\",\n\t\t (unsigned long __force)ndev->mem_start, lp->base_addr, ndev->irq);\n\treturn 0;\n\nerror:\n\tfree_netdev(ndev);\n\treturn rc;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <linux/of_mdio.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/of_device.h>\n#include <linux/of_net.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/of_address.h>\n#include <linux/netdevice.h>\n#include <linux/of_platform.h>\n#include <linux/ethtool.h>\n#include <linux/etherdevice.h>\n#include <linux/phy.h>\n"
  },
  {
    "repository": "chafa",
    "cve_id": "CVE-2022-2061",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "e6ce3746cdcf0836b9dae659a5aed15d73a080d8",
    "short_hash": "e6ce3746",
    "vulnerableMethods_before": [
      {
        "filename": "lzw.c",
        "method_name": "vulnerable_function",
        "raw_code": "lzw_result lzw_decode(struct lzw_ctx *ctx,\n\t\tconst uint8_t ** const stack_pos_out)\n{\n\tlzw_result res;\n\tuint32_t code_new;\n\tuint32_t code_out;\n\tuint8_t last_value;\n\tuint8_t *stack_pos = ctx->stack_base;\n\tuint32_t clear_code = ctx->clear_code;\n\tuint32_t current_entry = ctx->current_entry;\n\tstruct lzw_dictionary_entry * const table = ctx->table;\n\n\t/* Get a new code from the input */\n\tres = lzw__next_code(&ctx->input, ctx->current_code_size, &code_new);\n\tif (res != LZW_OK) {\n\t\treturn res;\n\t}\n\n\t/* Handle the new code */\n\tif (code_new == clear_code) {\n\t\t/* Got Clear code */\n\t\treturn lzw__clear_codes(ctx, stack_pos_out);\n\n\t} else if (code_new == ctx->eoi_code) {\n\t\t/* Got End of Information code */\n\t\treturn LZW_EOI_CODE;\n\n\t} else if (code_new > current_entry) {\n\t\t/* Code is invalid */\n\t\treturn LZW_BAD_CODE;\n\n\t} else if (code_new < current_entry) {\n\t\t/* Code is in table */\n\t\tcode_out = code_new;\n\t\tlast_value = table[code_new].first_value;\n\t} else {\n\t\t/* Code not in table */\n\t\t*stack_pos++ = ctx->previous_code_first;\n\t\tcode_out = ctx->previous_code;\n\t\tlast_value = ctx->previous_code_first;\n\t}\n\n\t/* Add to the dictionary, only if there's space */\n\tif (current_entry < (1 << LZW_CODE_MAX)) {\n\t\tstruct lzw_dictionary_entry *entry = table + current_entry;\n\t\tentry->last_value     = last_value;\n\t\tentry->first_value    = ctx->previous_code_first;\n\t\tentry->previous_entry = ctx->previous_code;\n\t\tctx->current_entry++;\n\t}\n\n\t/* Ensure code size is increased, if needed. */\n\tif (current_entry == ctx->current_code_size_max) {\n\t\tif (ctx->current_code_size < LZW_CODE_MAX) {\n\t\t\tctx->current_code_size++;\n\t\t\tctx->current_code_size_max =\n\t\t\t\t\t(1 << ctx->current_code_size) - 1;\n\t\t}\n\t}\n\n\t/* Store details of this code as \"previous code\" to the context. */\n\tctx->previous_code_first = table[code_new].first_value;\n\tctx->previous_code = code_new;\n\n\t/* Put rest of data for this code on output stack.\n\t * Note, in the case of \"code not in table\", the last entry of the\n\t * current code has already been placed on the stack above. */\n\twhile (code_out > clear_code) {\n\t\tstruct lzw_dictionary_entry *entry = table + code_out;\n\t\t*stack_pos++ = entry->last_value;\n\t\tcode_out = entry->previous_entry;\n\t}\n\t*stack_pos++ = table[code_out].last_value;\n\n\t*stack_pos_out = stack_pos;\n\treturn LZW_OK;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "lzw.c",
        "method_name": "fixed_function",
        "raw_code": "lzw_result lzw_decode(struct lzw_ctx *ctx,\n\t\tconst uint8_t ** const stack_pos_out)\n{\n\tlzw_result res;\n\tuint32_t code_new;\n\tuint32_t code_out;\n\tuint8_t last_value;\n\tuint8_t *stack_pos = ctx->stack_base;\n\tuint32_t clear_code = ctx->clear_code;\n\tuint32_t current_entry = ctx->current_entry;\n\tstruct lzw_dictionary_entry * const table = ctx->table;\n\n\t/* Get a new code from the input */\n\tres = lzw__next_code(&ctx->input, ctx->current_code_size, &code_new);\n\tif (res != LZW_OK) {\n\t\treturn res;\n\t}\n\n\t/* Handle the new code */\n\tif (code_new == clear_code) {\n\t\t/* Got Clear code */\n\t\treturn lzw__clear_codes(ctx, stack_pos_out);\n\n\t} else if (code_new == ctx->eoi_code) {\n\t\t/* Got End of Information code */\n\t\treturn LZW_EOI_CODE;\n\n\t} else if (code_new > current_entry) {\n\t\t/* Code is invalid */\n\t\treturn LZW_BAD_CODE;\n\n\t} else if (code_new >= 1 << LZW_CODE_MAX) {\n\t\t/* Don't access out of bound */\n\t\treturn LZW_BAD_CODE;\n\n\t} else if (code_new < current_entry) {\n\t\t/* Code is in table */\n\t\tcode_out = code_new;\n\t\tlast_value = table[code_new].first_value;\n\t} else {\n\t\t/* Code not in table */\n\t\t*stack_pos++ = ctx->previous_code_first;\n\t\tcode_out = ctx->previous_code;\n\t\tlast_value = ctx->previous_code_first;\n\t}\n\n\t/* Add to the dictionary, only if there's space */\n\tif (current_entry < (1 << LZW_CODE_MAX)) {\n\t\tstruct lzw_dictionary_entry *entry = table + current_entry;\n\t\tentry->last_value     = last_value;\n\t\tentry->first_value    = ctx->previous_code_first;\n\t\tentry->previous_entry = ctx->previous_code;\n\t\tctx->current_entry++;\n\t}\n\n\t/* Ensure code size is increased, if needed. */\n\tif (current_entry == ctx->current_code_size_max) {\n\t\tif (ctx->current_code_size < LZW_CODE_MAX) {\n\t\t\tctx->current_code_size++;\n\t\t\tctx->current_code_size_max =\n\t\t\t\t\t(1 << ctx->current_code_size) - 1;\n\t\t}\n\t}\n\n\t/* Store details of this code as \"previous code\" to the context. */\n\tctx->previous_code_first = table[code_new].first_value;\n\tctx->previous_code = code_new;\n\n\t/* Put rest of data for this code on output stack.\n\t * Note, in the case of \"code not in table\", the last entry of the\n\t * current code has already been placed on the stack above. */\n\twhile (code_out > clear_code) {\n\t\tstruct lzw_dictionary_entry *entry = table + code_out;\n\t\t*stack_pos++ = entry->last_value;\n\t\tcode_out = entry->previous_entry;\n\t}\n\t*stack_pos++ = table[code_out].last_value;\n\n\t*stack_pos_out = stack_pos;\n\treturn LZW_OK;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"lzw.h\"\n#include <assert.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdlib.h>\n\n// Type Definitions:\n// lzw_dictionary_entry:\nstruct lzw_dictionary_entry {\n\tuint8_t last_value;      /**< Last value for record ending at entry. */\n\tuint8_t first_value;     /**< First value for entry's record. */\n\tuint16_t previous_entry; /**< Offset in dictionary to previous entry. */\n}\n\n// lzw_result:\ntypedef enum lzw_result {\n\tLZW_OK,        /**< Success */\n\tLZW_OK_EOD,    /**< Success; reached zero-length sub-block */\n\tLZW_NO_MEM,    /**< Error: Out of memory */\n\tLZW_NO_DATA,   /**< Error: Out of data */\n\tLZW_EOI_CODE,  /**< Error: End of Information code */\n\tLZW_BAD_ICODE, /**< Error: Bad initial LZW code */\n\tLZW_BAD_CODE,  /**< Error: Bad LZW code */\n}\n\n// lzw_ctx:\nstruct lzw_ctx {\n\t/** Input reading context */\n\tstruct lzw_read_ctx input;\n\n\tuint32_t previous_code;       /**< Code read from input previously. */\n\tuint32_t previous_code_first; /**< First value of previous code. */\n\n\tuint32_t initial_code_size;     /**< Starting LZW code size. */\n\tuint32_t current_code_size;     /**< Current LZW code size. */\n\tuint32_t current_code_size_max; /**< Max code value for current size. */\n\n\tuint32_t clear_code; /**< Special Clear code value */\n\tuint32_t eoi_code;   /**< Special End of Information code value */\n\n\tuint32_t current_entry; /**< Next position in table to fill. */\n\n\t/** Output value stack. */\n\tuint8_t stack_base[1 << LZW_CODE_MAX];\n\n\t/** LZW decode dictionary. Generated during decode. */\n\tstruct lzw_dictionary_entry table[1 << LZW_CODE_MAX];\n}\n\n// Called Methods (top 10):\n// LZW_CODE_MAX from libnsgif/lzw.h:\n<empty>\n\n// lzw__block_advance from libnsgif/lzw.c:\nstatic lzw_result lzw__block_advance(struct lzw_read_ctx *ctx) /* <=== lzw__block_advance */ \n{\n\tuint64_t block_size;\n\tuint64_t next_block_pos = ctx->data_sb_next;\n\tconst uint8_t *data_next = ctx->data + next_block_pos;\n\n\tif (next_block_pos >= ctx->data_len) {\n\t\treturn LZW_NO_DATA;\n\t}\n\n\tblock_size = *data_next;\n\n\tif ((next_block_pos + block_size) >= ctx->data_len) {\n\t\treturn LZW_NO_DATA;\n\t}\n\n\tctx->sb_bit = 0;\n\tctx->sb_bit_count = block_size * 8;\n\n\tif (block_size == 0) {\n\t\tctx->data_sb_next += 1;\n\t\treturn LZW_OK_EOD;\n\t}\n\n\tctx->sb_data = data_next + 1;\n\tctx->data_sb_next += block_size + 1;\n\n\treturn LZW_OK;\n}\n\n// lzw__next_code from libnsgif/lzw.c:\nstatic inline lzw_result lzw__next_code(\n\t\tstruct lzw_read_ctx *ctx,\n\t\tuint8_t code_size,\n\t\tuint32_t *code_out)\n{\n\tuint32_t code = 0;\n\tuint8_t current_bit = ctx->sb_bit & 0x7;\n\tuint8_t byte_advance = (current_bit + code_size) >> 3;\n\n\tassert(byte_advance <= 2);\n\n\tif (ctx->sb_bit + code_size <= ctx->sb_bit_count) {\n\t\t/* Fast path: code fully inside this sub-block */\n\t\tconst uint8_t *data = ctx->sb_data + (ctx->sb_bit >> 3);\n\t\tswitch (byte_advance) {\n\t\t\tcase 2: code |= data[2] << 16; /* Fall through */\n\t\t\tcase 1: code |= data[1] <<  8; /* Fall through */\n\t\t\tcase 0: code |= data[0] <<  0;\n\t\t}\n\t\tctx->sb_bit += code_size;\n\t} else {\n\t\t/* Slow path: code spans sub-blocks */\n\t\tuint8_t byte = 0;\n\t\tuint8_t bits_remaining_0 = (code_size < (8 - current_bit)) ?\n\t\t\t\tcode_size : (8 - current_bit);\n\t\tuint8_t bits_remaining_1 = code_size - bits_remaining_0;\n\t\tuint8_t bits_used[3] = {\n\t\t\t[0] = bits_remaining_0,\n\t\t\t[1] = bits_remaining_1 < 8 ? bits_remaining_1 : 8,\n\t\t\t[2] = bits_remaining_1 - 8,\n\t\t};\n\n...\n"
  },
  {
    "repository": "Singular",
    "cve_id": "CVE-2022-40299",
    "cwe_list": [
      "CWE-269"
    ],
    "commit_hash": "5f28fbf066626fa9c4a8f0e6408c0bb362fb386c",
    "short_hash": "5f28fbf0",
    "vulnerableMethods_before": [
      {
        "filename": "None",
        "method_name": "vulnerable_function",
        "raw_code": "void sdb_edit(procinfo *pi)\n{\n  char * filename = omStrDup(\"/tmp/sd000000\");\n  sprintf(filename+7,\"%d\",getpid());\n  FILE *fp=fopen(filename,\"w\");\n  if (fp==NULL)\n  {\n    Print(\"cannot open %s\\n\",filename);\n    omFree(filename);\n    return;\n  }\n  if (pi->language!= LANG_SINGULAR)\n  {\n    Print(\"cannot edit type %d\\n\",pi->language);\n    fclose(fp);\n    fp=NULL;\n  }\n  else\n  {\n    const char *editor=getenv(\"EDITOR\");\n    if (editor==NULL)\n      editor=getenv(\"VISUAL\");\n    if (editor==NULL)\n      editor=\"vi\";\n    editor=omStrDup(editor);\n\n    if (pi->data.s.body==NULL)\n    {\n      iiGetLibProcBuffer(pi);\n      if (pi->data.s.body==NULL)\n      {\n        PrintS(\"cannot get the procedure body\\n\");\n        fclose(fp);\n        si_unlink(filename);\n        omFree(filename);\n        return;\n      }\n    }\n\n    fwrite(pi->data.s.body,1,strlen(pi->data.s.body),fp);\n    fclose(fp);\n\n    int pid=fork();\n    if (pid!=0)\n    {\n      si_wait(&pid);\n    }\n    else if(pid==0)\n    {\n      if (strchr(editor,' ')==NULL)\n      {\n        execlp(editor,editor,filename,NULL);\n        Print(\"cannot exec %s\\n\",editor);\n      }\n      else\n      {\n        char *p=(char *)omAlloc(strlen(editor)+strlen(filename)+2);\n        sprintf(p,\"%s %s\",editor,filename);\n        system(p);\n      }\n      exit(0);\n    }\n    else\n    {\n      PrintS(\"cannot fork\\n\");\n    }\n\n    fp=fopen(filename,\"r\");\n    if (fp==NULL)\n    {\n      Print(\"cannot read from %s\\n\",filename);\n    }\n    else\n    {\n      fseek(fp,0L,SEEK_END);\n      long len=ftell(fp);\n      fseek(fp,0L,SEEK_SET);\n\n      omFree((ADDRESS)pi->data.s.body);\n      pi->data.s.body=(char *)omAlloc((int)len+1);\n      myfread( pi->data.s.body, len, 1, fp);\n      pi->data.s.body[len]='\\0';\n      fclose(fp);\n    }\n  }\n  si_unlink(filename);\n  omFree(filename);\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "None",
        "method_name": "fixed_function",
        "raw_code": "void sdb_edit(procinfo *pi)\n{\n  char * filename = omStrDup(\"/tmp/sdXXXXXX\");\n  int f=mkstemp(filename);\n  if (f==-1)\n  {\n    Print(\"cannot open %s\\n\",filename);\n    omFree(filename);\n    return;\n  }\n  if (pi->language!= LANG_SINGULAR)\n  {\n    Print(\"cannot edit type %d\\n\",pi->language);\n    close(f);\n    f=NULL;\n  }\n  else\n  {\n    const char *editor=getenv(\"EDITOR\");\n    if (editor==NULL)\n      editor=getenv(\"VISUAL\");\n    if (editor==NULL)\n      editor=\"vi\";\n    editor=omStrDup(editor);\n\n    if (pi->data.s.body==NULL)\n    {\n      iiGetLibProcBuffer(pi);\n      if (pi->data.s.body==NULL)\n      {\n        PrintS(\"cannot get the procedure body\\n\");\n        close(f);\n        si_unlink(filename);\n        omFree(filename);\n        return;\n      }\n    }\n\n    write(f,pi->data.s.body,strlen(pi->data.s.body));\n    close(f);\n\n    int pid=fork();\n    if (pid!=0)\n    {\n      si_wait(&pid);\n    }\n    else if(pid==0)\n    {\n      if (strchr(editor,' ')==NULL)\n      {\n        execlp(editor,editor,filename,NULL);\n        Print(\"cannot exec %s\\n\",editor);\n      }\n      else\n      {\n        char *p=(char *)omAlloc(strlen(editor)+strlen(filename)+2);\n        sprintf(p,\"%s %s\",editor,filename);\n        system(p);\n      }\n      exit(0);\n    }\n    else\n    {\n      PrintS(\"cannot fork\\n\");\n    }\n\n    FILE* fp=fopen(filename,\"r\");\n    if (fp==NULL)\n    {\n      Print(\"cannot read from %s\\n\",filename);\n    }\n    else\n    {\n      fseek(fp,0L,SEEK_END);\n      long len=ftell(fp);\n      fseek(fp,0L,SEEK_SET);\n\n      omFree((ADDRESS)pi->data.s.body);\n      pi->data.s.body=(char *)omAlloc((int)len+1);\n      myfread( pi->data.s.body, len, 1, fp);\n      pi->data.s.body[len]='\\0';\n      fclose(fp);\n    }\n  }\n  si_unlink(filename);\n  omFree(filename);\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <unistd.h>\n#include \"Singular/ipid.h\"\n#include <sys/wait.h>\n#include \"reporter/si_signals.h\"\n#include \"Singular/tok.h\"\n#include \"kernel/oswrapper/feread.h\"\n#include \"Singular/sdb.h\"\n#include \"misc/options.h\"\n#include \"Singular/ipshell.h\"\n#include \"Singular/fevoices.h\"\n#include \"kernel/mod2.h\"\n#include \"omalloc/omalloc.h\"\n\n// Type Definitions:\n// int:\nBigInt.int:int()\n\n// procinfo:\nclass procinfo\n{\npublic:\n  char          *libname;\n  char          *procname;\n  package       pack;\n  language_defs language;\n  short         ref;\n  char          is_static;        // if set, proc not accessible for user\n  char          trace_flag;\n  procinfodata  data;\n}\n\n// int:\nRational.int:int()\n\n// Called Methods (top 10):\n// NULL from Singular/kernel/misc/auxiliary.h:\n<empty>\n\n// SEEK_END from Singular/kernel/mod2.h:\n<empty>\n\n// SI_PROT_O from libpolys/reporter/reporter/reporter.h:\n\n\n// assume from Singular/Singular/Singular/Singular/kernel/kernel/polys/monomials/coeffs/reporter/reporter.h:\n\n\n// omFree from libpolys/reporter/omalloc/omalloc/xalloc.h:\n\n\n// omAlloc from Singular/Singular/Singular/Singular/omalloc/omalloc/xalloc.h:\n\n\n// omAlloc from Singular/omalloc/omalloc/xalloc.h:\n<empty>\n\n// omAlloc from libpolys/reporter/omalloc/omalloc/xalloc.h:\n\n\n// PrintS from libpolys/reporter/reporter.cc:\nvoid PrintS(const char *s)\n{\n  if (sprint != NULL)\n  {\n    SPrintS(s);\n    return;\n  }\n  else if (feOut) /* do not print when option --no-out was given */\n  {\n\n    if (PrintS_callback!=NULL)\n    {\n      PrintS_callback(s);\n    }\n    else\n    {\n      fwrite(s,1,strlen(s),stdout);\n      fflush(stdout);\n      if (feProt&SI_PROT_O)\n      {\n        fwrite(s,1,strlen(s),feProtFile);\n      }\n    }\n  }\n}\n\n// dErrorBreak from libpolys/reporter/dError.cc:\nvoid dErrorBreak() /* <=== dErrorBreak */ \n{}\n"
  },
  {
    "repository": "tinyexr",
    "cve_id": "CVE-2020-19490",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "a685e3332f61cd4e59324bf3f669d36973d64270",
    "short_hash": "a685e333",
    "vulnerableMethods_before": [
      {
        "filename": "tinyexr.h",
        "method_name": "vulnerable_function",
        "raw_code": "static int DecodeChunk(EXRImage *exr_image, const EXRHeader *exr_header,\n                       const std::vector<tinyexr::tinyexr_uint64> &offsets,\n                       const unsigned char *head, const size_t size,\n                       std::string *err) {\n  int num_channels = exr_header->num_channels;\n\n  int num_scanline_blocks = 1;\n  if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_ZIP) {\n    num_scanline_blocks = 16;\n  } else if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_PIZ) {\n    num_scanline_blocks = 32;\n  } else if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_ZFP) {\n    num_scanline_blocks = 16;\n  }\n\n  int data_width = exr_header->data_window[2] - exr_header->data_window[0] + 1;\n  int data_height = exr_header->data_window[3] - exr_header->data_window[1] + 1;\n\n  if ((data_width < 0) || (data_height < 0)) {\n    if (err) {\n      std::stringstream ss;\n      ss << \"Invalid data width or data height: \" << data_width << \", \"\n         << data_height << std::endl;\n      (*err) += ss.str();\n    }\n    return TINYEXR_ERROR_INVALID_DATA;\n  }\n\n  // Do not allow too large data_width and data_height. header invalid?\n  {\n    const int threshold = 1024 * 8192;  // heuristics\n    if ((data_width > threshold) || (data_height > threshold)) {\n      if (err) {\n        std::stringstream ss;\n        ss << \"data_with or data_height too large. data_width: \" << data_width\n           << \", \"\n           << \"data_height = \" << data_height << std::endl;\n        (*err) += ss.str();\n      }\n      return TINYEXR_ERROR_INVALID_DATA;\n    }\n  }\n\n  size_t num_blocks = offsets.size();\n\n  std::vector<size_t> channel_offset_list;\n  int pixel_data_size = 0;\n  size_t channel_offset = 0;\n  if (!tinyexr::ComputeChannelLayout(&channel_offset_list, &pixel_data_size,\n                                     &channel_offset, num_channels,\n                                     exr_header->channels)) {\n    if (err) {\n      (*err) += \"Failed to compute channel layout.\\n\";\n    }\n    return TINYEXR_ERROR_INVALID_DATA;\n  }\n\n  bool invalid_data = false;  // TODO(LTE): Use atomic lock for MT safety.\n\n  if (exr_header->tiled) {\n    // value check\n    if (exr_header->tile_size_x < 0) {\n      if (err) {\n        std::stringstream ss;\n        ss << \"Invalid tile size x : \" << exr_header->tile_size_x << \"\\n\";\n        (*err) += ss.str();\n      }\n      return TINYEXR_ERROR_INVALID_HEADER;\n    }\n\n    if (exr_header->tile_size_y < 0) {\n      if (err) {\n        std::stringstream ss;\n        ss << \"Invalid tile size y : \" << exr_header->tile_size_y << \"\\n\";\n        (*err) += ss.str();\n      }\n      return TINYEXR_ERROR_INVALID_HEADER;\n    }\n\n    size_t num_tiles = offsets.size();  // = # of blocks\n\n    exr_image->tiles = static_cast<EXRTile *>(\n        calloc(sizeof(EXRTile), static_cast<size_t>(num_tiles)));\n\n    for (size_t tile_idx = 0; tile_idx < num_tiles; tile_idx++) {\n      // Allocate memory for each tile.\n      exr_image->tiles[tile_idx].images = tinyexr::AllocateImage(\n          num_channels, exr_header->channels, exr_header->requested_pixel_types,\n          exr_header->tile_size_x, exr_header->tile_size_y);\n\n      // 16 byte: tile coordinates\n      // 4 byte : data size\n      // ~      : data(uncompressed or compressed)\n      if (offsets[tile_idx] + sizeof(int) * 5 > size) {\n        if (err) {\n          (*err) += \"Insufficient data size.\\n\";\n        }\n        return TINYEXR_ERROR_INVALID_DATA;\n      }\n\n      size_t data_size = size_t(size - (offsets[tile_idx] + sizeof(int) * 5));\n      const unsigned char *data_ptr =\n          reinterpret_cast<const unsigned char *>(head + offsets[tile_idx]);\n\n      int tile_coordinates[4];\n      memcpy(tile_coordinates, data_ptr, sizeof(int) * 4);\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&tile_coordinates[0]));\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&tile_coordinates[1]));\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&tile_coordinates[2]));\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&tile_coordinates[3]));\n\n      // @todo{ LoD }\n      if (tile_coordinates[2] != 0) {\n        return TINYEXR_ERROR_UNSUPPORTED_FEATURE;\n      }\n      if (tile_coordinates[3] != 0) {\n        return TINYEXR_ERROR_UNSUPPORTED_FEATURE;\n      }\n\n      int data_len;\n      memcpy(&data_len, data_ptr + 16,\n             sizeof(int));  // 16 = sizeof(tile_coordinates)\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&data_len));\n\n      if (data_len < 4 || size_t(data_len) > data_size) {\n        if (err) {\n          (*err) += \"Insufficient data length.\\n\";\n        }\n        return TINYEXR_ERROR_INVALID_DATA;\n      }\n\n      // Move to data addr: 20 = 16 + 4;\n      data_ptr += 20;\n\n      tinyexr::DecodeTiledPixelData(\n          exr_image->tiles[tile_idx].images,\n          &(exr_image->tiles[tile_idx].width),\n          &(exr_image->tiles[tile_idx].height),\n          exr_header->requested_pixel_types, data_ptr,\n          static_cast<size_t>(data_len), exr_header->compression_type,\n          exr_header->line_order, data_width, data_height, tile_coordinates[0],\n          tile_coordinates[1], exr_header->tile_size_x, exr_header->tile_size_y,\n          static_cast<size_t>(pixel_data_size),\n          static_cast<size_t>(exr_header->num_custom_attributes),\n          exr_header->custom_attributes,\n          static_cast<size_t>(exr_header->num_channels), exr_header->channels,\n          channel_offset_list);\n\n      exr_image->tiles[tile_idx].offset_x = tile_coordinates[0];\n      exr_image->tiles[tile_idx].offset_y = tile_coordinates[1];\n      exr_image->tiles[tile_idx].level_x = tile_coordinates[2];\n      exr_image->tiles[tile_idx].level_y = tile_coordinates[3];\n\n      exr_image->num_tiles = static_cast<int>(num_tiles);\n    }\n  } else {  // scanline format\n\n    // Don't allow too large image(256GB * pixel_data_size or more). Workaround\n    // for #104.\n    size_t total_data_len =\n        size_t(data_width) * size_t(data_height) * size_t(num_channels);\n    const bool total_data_len_overflown = sizeof(void*) == 8 ? (total_data_len >= 0x4000000000) : false;\n    if ((total_data_len == 0) || total_data_len_overflown ) {\n      if (err) {\n        std::stringstream ss;\n        ss << \"Image data size is zero or too large: width = \" << data_width\n           << \", height = \" << data_height << \", channels = \" << num_channels\n           << std::endl;\n        (*err) += ss.str();\n      }\n      return TINYEXR_ERROR_INVALID_DATA;\n    }\n\n    exr_image->images = tinyexr::AllocateImage(\n        num_channels, exr_header->channels, exr_header->requested_pixel_types,\n        data_width, data_height);\n\n#ifdef _OPENMP\n#pragma omp parallel for\n#endif\n    for (int y = 0; y < static_cast<int>(num_blocks); y++) {\n      size_t y_idx = static_cast<size_t>(y);\n\n      if (offsets[y_idx] + sizeof(int) * 2 > size) {\n        invalid_data = true;\n      } else {\n        // 4 byte: scan line\n        // 4 byte: data size\n        // ~     : pixel data(uncompressed or compressed)\n        size_t data_size = size_t(size - (offsets[y_idx] + sizeof(int) * 2));\n        const unsigned char *data_ptr =\n            reinterpret_cast<const unsigned char *>(head + offsets[y_idx]);\n\n        int line_no;\n        memcpy(&line_no, data_ptr, sizeof(int));\n        int data_len;\n        memcpy(&data_len, data_ptr + 4, sizeof(int));\n        tinyexr::swap4(reinterpret_cast<unsigned int *>(&line_no));\n        tinyexr::swap4(reinterpret_cast<unsigned int *>(&data_len));\n\n        if (size_t(data_len) > data_size) {\n          invalid_data = true;\n        } else if (data_len == 0) {\n          // TODO(syoyo): May be ok to raise the threshold for example `data_len\n          // < 4`\n          invalid_data = true;\n        } else {\n          // line_no may be negative.\n          int end_line_no = (std::min)(line_no + num_scanline_blocks,\n                                       (exr_header->data_window[3] + 1));\n\n          int num_lines = end_line_no - line_no;\n\n          if (num_lines <= 0) {\n            invalid_data = true;\n          } else {\n            // Move to data addr: 8 = 4 + 4;\n            data_ptr += 8;\n\n            // Adjust line_no with data_window.bmin.y\n\n            // overflow check\n            tinyexr_int64 lno = static_cast<tinyexr_int64>(line_no) - static_cast<tinyexr_int64>(exr_header->data_window[1]);\n            if (lno > std::numeric_limits<int>::max()) {\n              line_no = -1; // invalid\n            } else if (lno < -std::numeric_limits<int>::max()) {\n              line_no = -1; // invalid\n            } else {\n              line_no -= exr_header->data_window[1];\n            }\n\n            if (line_no < 0) {\n              invalid_data = true;\n            } else {\n              if (!tinyexr::DecodePixelData(\n                      exr_image->images, exr_header->requested_pixel_types,\n                      data_ptr, static_cast<size_t>(data_len),\n                      exr_header->compression_type, exr_header->line_order,\n                      data_width, data_height, data_width, y, line_no,\n                      num_lines, static_cast<size_t>(pixel_data_size),\n                      static_cast<size_t>(exr_header->num_custom_attributes),\n                      exr_header->custom_attributes,\n                      static_cast<size_t>(exr_header->num_channels),\n                      exr_header->channels, channel_offset_list)) {\n                invalid_data = true;\n              }\n            }\n          }\n        }\n      }\n    }  // omp parallel\n  }\n\n  if (invalid_data) {\n    if (err) {\n      std::stringstream ss;\n      (*err) += \"Invalid data found when decoding pixels.\\n\";\n    }\n    return TINYEXR_ERROR_INVALID_DATA;\n  }\n\n  // Overwrite `pixel_type` with `requested_pixel_type`.\n  {\n    for (int c = 0; c < exr_header->num_channels; c++) {\n      exr_header->pixel_types[c] = exr_header->requested_pixel_types[c];\n    }\n  }\n\n  {\n    exr_image->num_channels = num_channels;\n\n    exr_image->width = data_width;\n    exr_image->height = data_height;\n  }\n\n  return TINYEXR_SUCCESS;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "tinyexr.h",
        "method_name": "fixed_function",
        "raw_code": "static int DecodeChunk(EXRImage *exr_image, const EXRHeader *exr_header,\n                       const std::vector<tinyexr::tinyexr_uint64> &offsets,\n                       const unsigned char *head, const size_t size,\n                       std::string *err) {\n  int num_channels = exr_header->num_channels;\n\n  int num_scanline_blocks = 1;\n  if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_ZIP) {\n    num_scanline_blocks = 16;\n  } else if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_PIZ) {\n    num_scanline_blocks = 32;\n  } else if (exr_header->compression_type == TINYEXR_COMPRESSIONTYPE_ZFP) {\n    num_scanline_blocks = 16;\n  }\n\n  int data_width = exr_header->data_window[2] - exr_header->data_window[0] + 1;\n  int data_height = exr_header->data_window[3] - exr_header->data_window[1] + 1;\n\n  if ((data_width < 0) || (data_height < 0)) {\n    if (err) {\n      std::stringstream ss;\n      ss << \"Invalid data width or data height: \" << data_width << \", \"\n         << data_height << std::endl;\n      (*err) += ss.str();\n    }\n    return TINYEXR_ERROR_INVALID_DATA;\n  }\n\n  // Do not allow too large data_width and data_height. header invalid?\n  {\n    const int threshold = 1024 * 8192;  // heuristics\n    if ((data_width > threshold) || (data_height > threshold)) {\n      if (err) {\n        std::stringstream ss;\n        ss << \"data_with or data_height too large. data_width: \" << data_width\n           << \", \"\n           << \"data_height = \" << data_height << std::endl;\n        (*err) += ss.str();\n      }\n      return TINYEXR_ERROR_INVALID_DATA;\n    }\n  }\n\n  size_t num_blocks = offsets.size();\n\n  std::vector<size_t> channel_offset_list;\n  int pixel_data_size = 0;\n  size_t channel_offset = 0;\n  if (!tinyexr::ComputeChannelLayout(&channel_offset_list, &pixel_data_size,\n                                     &channel_offset, num_channels,\n                                     exr_header->channels)) {\n    if (err) {\n      (*err) += \"Failed to compute channel layout.\\n\";\n    }\n    return TINYEXR_ERROR_INVALID_DATA;\n  }\n\n  bool invalid_data = false;  // TODO(LTE): Use atomic lock for MT safety.\n\n  if (exr_header->tiled) {\n    // value check\n    if (exr_header->tile_size_x < 0) {\n      if (err) {\n        std::stringstream ss;\n        ss << \"Invalid tile size x : \" << exr_header->tile_size_x << \"\\n\";\n        (*err) += ss.str();\n      }\n      return TINYEXR_ERROR_INVALID_HEADER;\n    }\n\n    if (exr_header->tile_size_y < 0) {\n      if (err) {\n        std::stringstream ss;\n        ss << \"Invalid tile size y : \" << exr_header->tile_size_y << \"\\n\";\n        (*err) += ss.str();\n      }\n      return TINYEXR_ERROR_INVALID_HEADER;\n    }\n\n    size_t num_tiles = offsets.size();  // = # of blocks\n\n    exr_image->tiles = static_cast<EXRTile *>(\n        calloc(sizeof(EXRTile), static_cast<size_t>(num_tiles)));\n\n    for (size_t tile_idx = 0; tile_idx < num_tiles; tile_idx++) {\n      // Allocate memory for each tile.\n      exr_image->tiles[tile_idx].images = tinyexr::AllocateImage(\n          num_channels, exr_header->channels, exr_header->requested_pixel_types,\n          exr_header->tile_size_x, exr_header->tile_size_y);\n\n      // 16 byte: tile coordinates\n      // 4 byte : data size\n      // ~      : data(uncompressed or compressed)\n      if (offsets[tile_idx] + sizeof(int) * 5 > size) {\n        if (err) {\n          (*err) += \"Insufficient data size.\\n\";\n        }\n        return TINYEXR_ERROR_INVALID_DATA;\n      }\n\n      size_t data_size = size_t(size - (offsets[tile_idx] + sizeof(int) * 5));\n      const unsigned char *data_ptr =\n          reinterpret_cast<const unsigned char *>(head + offsets[tile_idx]);\n\n      int tile_coordinates[4];\n      memcpy(tile_coordinates, data_ptr, sizeof(int) * 4);\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&tile_coordinates[0]));\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&tile_coordinates[1]));\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&tile_coordinates[2]));\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&tile_coordinates[3]));\n\n      // @todo{ LoD }\n      if (tile_coordinates[2] != 0) {\n        return TINYEXR_ERROR_UNSUPPORTED_FEATURE;\n      }\n      if (tile_coordinates[3] != 0) {\n        return TINYEXR_ERROR_UNSUPPORTED_FEATURE;\n      }\n\n      int data_len;\n      memcpy(&data_len, data_ptr + 16,\n             sizeof(int));  // 16 = sizeof(tile_coordinates)\n      tinyexr::swap4(reinterpret_cast<unsigned int *>(&data_len));\n\n      if (data_len < 4 || size_t(data_len) > data_size) {\n        if (err) {\n          (*err) += \"Insufficient data length.\\n\";\n        }\n        return TINYEXR_ERROR_INVALID_DATA;\n      }\n\n      // Move to data addr: 20 = 16 + 4;\n      data_ptr += 20;\n\n      tinyexr::DecodeTiledPixelData(\n          exr_image->tiles[tile_idx].images,\n          &(exr_image->tiles[tile_idx].width),\n          &(exr_image->tiles[tile_idx].height),\n          exr_header->requested_pixel_types, data_ptr,\n          static_cast<size_t>(data_len), exr_header->compression_type,\n          exr_header->line_order, data_width, data_height, tile_coordinates[0],\n          tile_coordinates[1], exr_header->tile_size_x, exr_header->tile_size_y,\n          static_cast<size_t>(pixel_data_size),\n          static_cast<size_t>(exr_header->num_custom_attributes),\n          exr_header->custom_attributes,\n          static_cast<size_t>(exr_header->num_channels), exr_header->channels,\n          channel_offset_list);\n\n      exr_image->tiles[tile_idx].offset_x = tile_coordinates[0];\n      exr_image->tiles[tile_idx].offset_y = tile_coordinates[1];\n      exr_image->tiles[tile_idx].level_x = tile_coordinates[2];\n      exr_image->tiles[tile_idx].level_y = tile_coordinates[3];\n\n      exr_image->num_tiles = static_cast<int>(num_tiles);\n    }\n  } else {  // scanline format\n\n    // Don't allow too large image(256GB * pixel_data_size or more). Workaround\n    // for #104.\n    size_t total_data_len =\n        size_t(data_width) * size_t(data_height) * size_t(num_channels);\n    const bool total_data_len_overflown = sizeof(void*) == 8 ? (total_data_len >= 0x4000000000) : false;\n    if ((total_data_len == 0) || total_data_len_overflown ) {\n      if (err) {\n        std::stringstream ss;\n        ss << \"Image data size is zero or too large: width = \" << data_width\n           << \", height = \" << data_height << \", channels = \" << num_channels\n           << std::endl;\n        (*err) += ss.str();\n      }\n      return TINYEXR_ERROR_INVALID_DATA;\n    }\n\n    exr_image->images = tinyexr::AllocateImage(\n        num_channels, exr_header->channels, exr_header->requested_pixel_types,\n        data_width, data_height);\n\n#ifdef _OPENMP\n#pragma omp parallel for\n#endif\n    for (int y = 0; y < static_cast<int>(num_blocks); y++) {\n      size_t y_idx = static_cast<size_t>(y);\n\n      if (offsets[y_idx] + sizeof(int) * 2 > size) {\n        invalid_data = true;\n      } else {\n        // 4 byte: scan line\n        // 4 byte: data size\n        // ~     : pixel data(uncompressed or compressed)\n        size_t data_size = size_t(size - (offsets[y_idx] + sizeof(int) * 2));\n        const unsigned char *data_ptr =\n            reinterpret_cast<const unsigned char *>(head + offsets[y_idx]);\n\n        int line_no;\n        memcpy(&line_no, data_ptr, sizeof(int));\n        int data_len;\n        memcpy(&data_len, data_ptr + 4, sizeof(int));\n        tinyexr::swap4(reinterpret_cast<unsigned int *>(&line_no));\n        tinyexr::swap4(reinterpret_cast<unsigned int *>(&data_len));\n\n        if (size_t(data_len) > data_size) {\n          invalid_data = true;\n\n        } else if ((line_no > (2 << 20)) || (line_no < -(2 << 20))) {\n          // Too large value. Assume this is invalid\n          // 2**20 = 1048576 = heuristic value.\n          invalid_data = true;\n        } else if (data_len == 0) {\n          // TODO(syoyo): May be ok to raise the threshold for example `data_len\n          // < 4`\n          invalid_data = true;\n        } else {\n          // line_no may be negative.\n          int end_line_no = (std::min)(line_no + num_scanline_blocks,\n                                       (exr_header->data_window[3] + 1));\n\n          int num_lines = end_line_no - line_no;\n\n          if (num_lines <= 0) {\n            invalid_data = true;\n          } else {\n            // Move to data addr: 8 = 4 + 4;\n            data_ptr += 8;\n\n            // Adjust line_no with data_window.bmin.y\n\n            // overflow check\n            tinyexr_int64 lno = static_cast<tinyexr_int64>(line_no) - static_cast<tinyexr_int64>(exr_header->data_window[1]);\n            if (lno > std::numeric_limits<int>::max()) {\n              line_no = -1; // invalid\n            } else if (lno < -std::numeric_limits<int>::max()) {\n              line_no = -1; // invalid\n            } else {\n              line_no -= exr_header->data_window[1];\n            }\n\n            if (line_no < 0) {\n              invalid_data = true;\n            } else {\n              if (!tinyexr::DecodePixelData(\n                      exr_image->images, exr_header->requested_pixel_types,\n                      data_ptr, static_cast<size_t>(data_len),\n                      exr_header->compression_type, exr_header->line_order,\n                      data_width, data_height, data_width, y, line_no,\n                      num_lines, static_cast<size_t>(pixel_data_size),\n                      static_cast<size_t>(exr_header->num_custom_attributes),\n                      exr_header->custom_attributes,\n                      static_cast<size_t>(exr_header->num_channels),\n                      exr_header->channels, channel_offset_list)) {\n                invalid_data = true;\n              }\n            }\n          }\n        }\n      }\n    }  // omp parallel\n  }\n\n  if (invalid_data) {\n    if (err) {\n      std::stringstream ss;\n      (*err) += \"Invalid data found when decoding pixels.\\n\";\n    }\n    return TINYEXR_ERROR_INVALID_DATA;\n  }\n\n  // Overwrite `pixel_type` with `requested_pixel_type`.\n  {\n    for (int c = 0; c < exr_header->num_channels; c++) {\n      exr_header->pixel_types[c] = exr_header->requested_pixel_types[c];\n    }\n  }\n\n  {\n    exr_image->num_channels = num_channels;\n\n    exr_image->width = data_width;\n    exr_image->height = data_height;\n  }\n\n  return TINYEXR_SUCCESS;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <algorithm>\n#include <cstdint>\n#include <string>\n#include <cstdio>\n#include <cassert>\n#include <cstdlib>\n#include <sstream>\n#include <stdint.h>\n#include <sys/stat.h>\n#include <utime.h>\n#include <limits>\n#include <cstring>\n#include <omp.h>\n#include \"zfp.h\"\n#include <vector>\n#include <stdio.h>\n#include <stddef.h>\n#include <sys/utime.h>\n"
  },
  {
    "repository": "linux",
    "cve_id": "CVE-2022-24448",
    "cwe_list": [
      "CWE-909"
    ],
    "commit_hash": "ab0fc21bc7105b54bafd85bd8b82742f9e68898a",
    "short_hash": "ab0fc21b",
    "vulnerableMethods_before": [
      {
        "filename": "nfs4file.c",
        "method_name": "vulnerable_function",
        "raw_code": "nfs4_file_open(struct inode *inode, struct file *filp)\n{\n\tstruct nfs_open_context *ctx;\n\tstruct dentry *dentry = file_dentry(filp);\n\tstruct dentry *parent = NULL;\n\tstruct inode *dir;\n\tunsigned openflags = filp->f_flags;\n\tstruct iattr attr;\n\tint err;\n\n\t/*\n\t * If no cached dentry exists or if it's negative, NFSv4 handled the\n\t * opens in ->lookup() or ->create().\n\t *\n\t * We only get this far for a cached positive dentry.  We skipped\n\t * revalidation, so handle it here by dropping the dentry and returning\n\t * -EOPENSTALE.  The VFS will retry the lookup/create/open.\n\t */\n\n\tdprintk(\"NFS: open file(%pd2)\\n\", dentry);\n\n\terr = nfs_check_flags(openflags);\n\tif (err)\n\t\treturn err;\n\n\tif ((openflags & O_ACCMODE) == 3)\n\t\treturn nfs_open(inode, filp);\n\n\t/* We can't create new files here */\n\topenflags &= ~(O_CREAT|O_EXCL);\n\n\tparent = dget_parent(dentry);\n\tdir = d_inode(parent);\n\n\tctx = alloc_nfs_open_context(file_dentry(filp), filp->f_mode, filp);\n\terr = PTR_ERR(ctx);\n\tif (IS_ERR(ctx))\n\t\tgoto out;\n\n\tattr.ia_valid = ATTR_OPEN;\n\tif (openflags & O_TRUNC) {\n\t\tattr.ia_valid |= ATTR_SIZE;\n\t\tattr.ia_size = 0;\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\t}\n\n\tinode = NFS_PROTO(dir)->open_context(dir, ctx, openflags, &attr, NULL);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tswitch (err) {\n\t\tdefault:\n\t\t\tgoto out_put_ctx;\n\t\tcase -ENOENT:\n\t\tcase -ESTALE:\n\t\tcase -EISDIR:\n\t\tcase -ENOTDIR:\n\t\tcase -ELOOP:\n\t\t\tgoto out_drop;\n\t\t}\n\t}\n\tif (inode != d_inode(dentry))\n\t\tgoto out_drop;\n\n\tnfs_file_set_open_context(filp, ctx);\n\tnfs_fscache_open_file(inode, filp);\n\terr = 0;\n\nout_put_ctx:\n\tput_nfs_open_context(ctx);\nout:\n\tdput(parent);\n\treturn err;\n\nout_drop:\n\td_drop(dentry);\n\terr = -EOPENSTALE;\n\tgoto out_put_ctx;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "nfs4file.c",
        "method_name": "fixed_function",
        "raw_code": "nfs4_file_open(struct inode *inode, struct file *filp)\n{\n\tstruct nfs_open_context *ctx;\n\tstruct dentry *dentry = file_dentry(filp);\n\tstruct dentry *parent = NULL;\n\tstruct inode *dir;\n\tunsigned openflags = filp->f_flags;\n\tstruct iattr attr;\n\tint err;\n\n\t/*\n\t * If no cached dentry exists or if it's negative, NFSv4 handled the\n\t * opens in ->lookup() or ->create().\n\t *\n\t * We only get this far for a cached positive dentry.  We skipped\n\t * revalidation, so handle it here by dropping the dentry and returning\n\t * -EOPENSTALE.  The VFS will retry the lookup/create/open.\n\t */\n\n\tdprintk(\"NFS: open file(%pd2)\\n\", dentry);\n\n\terr = nfs_check_flags(openflags);\n\tif (err)\n\t\treturn err;\n\n\tif ((openflags & O_ACCMODE) == 3)\n\t\topenflags--;\n\n\t/* We can't create new files here */\n\topenflags &= ~(O_CREAT|O_EXCL);\n\n\tparent = dget_parent(dentry);\n\tdir = d_inode(parent);\n\n\tctx = alloc_nfs_open_context(file_dentry(filp), filp->f_mode, filp);\n\terr = PTR_ERR(ctx);\n\tif (IS_ERR(ctx))\n\t\tgoto out;\n\n\tattr.ia_valid = ATTR_OPEN;\n\tif (openflags & O_TRUNC) {\n\t\tattr.ia_valid |= ATTR_SIZE;\n\t\tattr.ia_size = 0;\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\t}\n\n\tinode = NFS_PROTO(dir)->open_context(dir, ctx, openflags, &attr, NULL);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tswitch (err) {\n\t\tdefault:\n\t\t\tgoto out_put_ctx;\n\t\tcase -ENOENT:\n\t\tcase -ESTALE:\n\t\tcase -EISDIR:\n\t\tcase -ENOTDIR:\n\t\tcase -ELOOP:\n\t\t\tgoto out_drop;\n\t\t}\n\t}\n\tif (inode != d_inode(dentry))\n\t\tgoto out_drop;\n\n\tnfs_file_set_open_context(filp, ctx);\n\tnfs_fscache_open_file(inode, filp);\n\terr = 0;\n\nout_put_ctx:\n\tput_nfs_open_context(ctx);\nout:\n\tdput(parent);\n\treturn err;\n\nout_drop:\n\td_drop(dentry);\n\terr = -EOPENSTALE;\n\tgoto out_put_ctx;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <linux/falloc.h>\n#include <linux/mount.h>\n#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"nfs42.h\"\n#include <linux/file.h>\n#include \"nfstrace.h\"\n#include <linux/fs.h>\n#include <linux/nfs_ssc.h>\n#include <linux/nfs_fs.h>\n#include \"internal.h\"\n#include \"pnfs.h\"\n#include \"delegation.h\"\n\n// Type Definitions:\n// dentry:\nstatic struct dentry\n\n// file:\nstruct file {\n\tunion {\n\t\tstruct llist_node\tfu_llist;\n\t\tstruct rcu_head \tfu_rcuhead;\n\t} f_u;\n\tstruct path\t\tf_path;\n\tstruct inode\t\t*f_inode;\t/* cached value */\n\tconst struct file_operations\t*f_op;\n\n\t/*\n\t * Protects f_ep, f_flags.\n\t * Must not be taken from IRQ context.\n\t */\n\tspinlock_t\t\tf_lock;\n\tenum rw_hint\t\tf_write_hint;\n\tatomic_long_t\t\tf_count;\n\tunsigned int \t\tf_flags;\n\tfmode_t\t\t\tf_mode;\n\tstruct mutex\t\tf_pos_lock;\n\tloff_t\t\t\tf_pos;\n\tstruct fown_struct\tf_owner;\n\tconst struct cred\t*f_cred;\n\tstruct file_ra_state\tf_ra;\n\n\tu64\t\t\tf_version;\n#ifdef CONFIG_SECURITY\n\tvoid\t\t\t*f_security;\n#endif\n\t/* needed for tty driver, and maybe others */\n\tvoid\t\t\t*private_data;\n\n#ifdef CONFIG_EPOLL\n\t/* Used by fs/eventpoll.c to link all the hooks to this file */\n\tstruct hlist_head\t*f_ep;\n#endif /* #ifdef CONFIG_EPOLL */\n\tstruct address_space\t*f_mapping;\n\terrseq_t\t\tf_wb_err;\n\terrseq_t\t\tf_sb_err; /* for syncfs */\n}\n\n// inode:\nstruct inode {\n\tumode_t\t\t\ti_mode;\n\tunsigned short\t\ti_opflags;\n\tkuid_t\t\t\ti_uid;\n\tkgid_t\t\t\ti_gid;\n\tunsigned int\t\ti_flags;\n\n#ifdef CONFIG_FS_POSIX_ACL\n\tstruct posix_acl\t*i_acl;\n\tstruct posix_acl\t*i_default_acl;\n#endif\n\n\tconst struct inode_operations\t*i_op;\n\tstruct super_block\t*i_sb;\n\tstruct address_space\t*i_mapping;\n\n#ifdef CONFIG_SECURITY\n\tvoid\t\t\t*i_security;\n#endif\n\n\t/* Stat data, not accessed from path walking */\n\tunsigned long\t\ti_ino;\n\t/*\n\t * Filesystems may only read i_nlink directly.  They shall use the\n\t * following functions for modification:\n\t *\n\t *    (set|clear|inc|drop)_nlink\n\t *    inode_(inc|dec)_link_count\n\t */\n\tunion {\n\t\tconst unsigned int i_nlink;\n\t\tunsigned int __i_nlink;\n\t};\n\tdev_t\t\t\ti_rdev;\n\tloff_t\t\t\ti_size;\n\tstruct timespec64\ti_atime;\n\tstruct timespec64\ti_mtime;\n\tstruct timespec64\ti_ctime;\n\tspinlock_t\t\ti_lock;\t/* i_blocks, i_bytes, maybe i_size */\n\tunsigned short          i_bytes;\n\tu8\t\t\ti_blkbits;\n\tu8\t\t\ti_write_hint;\n\tblkcnt_t\t\ti_blocks;\n\n#ifdef __NEED_I_SIZE_ORDER...\n\n// iattr:\nstruct iattr {\n\tunsigned int\tia_valid;\n\tumode_t\t\tia_mode;\n\tkuid_t\t\tia_uid;\n\tkgid_t\t\tia_gid;\n\tloff_t\t\tia_size;\n\tstruct timespec64 ia_atime;\n\tstruct timespec64 ia_mtime;\n\tstruct timespec64 ia_ctime;\n\n\t/*\n\t * Not an attribute, but an auxiliary info for filesystems wanting to\n\t * implement an ftruncate() like method.  NOTE: filesystem should\n\t * check for (ia_valid & ATTR_FILE), and not for (ia_file != NULL).\n\t */\n\tstruct file\t*ia_file;\n}\n\n// file:\nstruct file\n\n// nfs_open_context:\nstruct nfs_open_context\n\n// inode:\nstruct inode\n\n// Called Methods (top 10):\n// inode_is_open_for_write from include/linux/fs.h:\nstatic inline bool inode_is_open_for_write(const struct inode *inode) /* <=== inode_is_open_for_write */ \n{\n\treturn atomic_read(&inode->i_writecount) > 0;\n}\n\n// __put_nfs_open_context from fs/nfs/inode.c:\nstatic void __put_nfs_open_context(struct nfs_open_context *ctx, int is_sync) /* <=== __put_nfs_open_context */ \n{\n\tstruct inode *inode = d_inode(ctx->dentry);\n\tstruct super_block *sb = ctx->dentry->d_sb;\n\n\tif (!refcount_dec_and_test(&ctx->lock_context.count))\n\t\treturn;\n\tif (!list_empty(&ctx->list)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tlist_del_rcu(&ctx->list);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\tif (inode != NULL)\n\t\tNFS_PROTO(inode)->close_context(ctx, is_sync);\n\tput_cred(ctx->cred);\n\tdput(ctx->dentry);\n\tnfs_sb_deactive(sb);\n\tput_rpccred(rcu_dereference_protected(ctx->ll_cred, 1));\n\tkfree(ctx->mdsthreshold);\n\tkfree_rcu(ctx, rcu_head);\n}\n\n// nfs_fscache_update_auxdata from fs/nfs/fscache.h:\nstatic inline void nfs_fscache_update_auxdata(struct nfs_fscache_inode_auxdata *auxdata, /* <=== nfs_fscache_update_auxdata */ \n\t\t\t\t\t      struct inode *inode)\n{\n\tmemset(auxdata, 0, sizeof(*auxdata));\n\tauxdata->mtime_sec  = inode->i_mtime.tv_sec;\n\tauxdata->mtime_nsec = inode->i_mtime.tv_nsec;\n\tauxdata->ctime_sec  = inode->i_ctime.tv_sec;\n\tauxdata->ctime_nsec = inode->i_ctime.tv_nsec;\n\n\tif (NFS_SERVER(inode)->nfs_client->rpc_ops->version == 4)\n\t\tauxdata->change_attr = inode_peek_iversion_raw(inode);\n}\n\n// file_inode from include/linux/fs.h:\nstatic inline struct inode *file_inode(const struct file *f) /* <=== file_inode */ \n{\n\treturn f->f_inode;\n}\n\n// filemap_write_and_wait from include/linux/fs.h:\nstatic inline int filemap_write_and_wait(struct address_space *mapping) /* <=== filemap_write_and_wait */ \n{\n\treturn filemap_write_and_wait_range(mapping, 0, LLONG_MAX);\n}\n\n// nfs_sb_deactive from fs/nfs/super.c:\nvoid nfs_sb_deactive(struct super_block *sb) /* <=== nfs_sb_deactive */ \n{\n\tstruct nfs_server *server = NFS_SB(sb);\n\n\tif (atomic_dec_and_test(&server->active))\n\t\tdeactivate_super(sb);\n}\n\n// i_size_read from include/linux/fs.h:\nstatic inline loff_t i_size_read(const struct inode *inode) /* <=== i_size_read */ \n{\n#if BITS_PER_LONG==32 && defined(CONFIG_SMP)\n\tloff_t i_size;\n\tunsigned int seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&inode->i_size_seqcount);\n\t\ti_size = inode->i_size;\n\t} while (read_seqcount_retry(&inode->i_size_seqcount, seq));\n\treturn i_size;\n#elif BITS_PER_LONG==32 && defined(CONFIG_PREEMPTION)\n\tloff_t i_size;\n\n\tpreempt_disable();\n\ti_size = inode->i_size;\n\tpreempt_enable();\n\treturn i_size;\n#else\n\treturn inode->i_size;\n#endif\n}\n\n// fscache_invalidate from include/linux/fscache.h:\nstatic inline /* <=== fscache_invalidate */ \nvoid fscache_invalidate(struct fscache_cookie *cookie,\n\t\t\tconst void *aux_data, loff_t size, unsigned int flags)\n{\n\tif (fscache_cookie_enabled(cookie))\n\t\t__fscache_invalidate(cookie, aux_data, size, flags);\n}\n\n// get_nfs_open_context from fs/nfs/inode.c:\nstruct nfs_open_context *get_nfs_open_context(struct nfs_open_context *ctx) /* <=== get_nfs_open_context */ \n{\n\tif (ctx != NULL && refcount_inc_not_zero(&ctx->lock_context.count))\n\t\treturn ctx;\n\treturn NULL;\n}\n\n// put_nfs_open_context from fs/nfs/inode.c:\nvoid put_nfs_open_context(struct nfs_open_context *ctx) /* <=== put_nfs_open_context */ \n{\n\t__put_nfs_open_context(ctx, 0);\n}\n"
  },
  {
    "repository": "MilkyTracker",
    "cve_id": "CVE-2019-14464",
    "cwe_list": [
      "CWE-787"
    ],
    "commit_hash": "fd607a3439fcdd0992e5efded3c16fc79c804e34",
    "short_hash": "fd607a34",
    "vulnerableMethods_before": [
      {
        "filename": "LoaderS3M.cpp",
        "method_name": "vulnerable_function",
        "raw_code": "mp_sint32 LoaderS3M::load(XMFileBase& f, XModule* module)\n{\t\n\tmodule->cleanUp();\n\n\t// this will make code much easier to read\n\tTXMHeader*\t\theader = &module->header;\n\tTXMInstrument*\tinstr  = module->instr;\n\tTXMSample*\t\tsmp\t   = module->smp;\n\tTXMPattern*\t\tphead  = module->phead;\t\n\n\t// we're already out of memory here\n\tif (!phead || !instr || !smp)\n\t\treturn MP_OUT_OF_MEMORY;\n\t\n\tf.read(&header->name,1,28);\n\theader->whythis1a = f.readByte();\n\t\n\tif (f.readByte() != 16) \n\t\treturn MP_LOADER_FAILED;\t// no ST3 module\n\t\n\tf.readByte(); // skip something\n\tf.readByte(); // skip something\n\t\n\theader->ordnum = f.readWord(); // number of positions in order list (songlength)\n\t\n\tmp_ubyte* orders = new mp_ubyte[header->ordnum];\n\tif (orders == NULL) \n\t\treturn MP_OUT_OF_MEMORY;\n\t\n\theader->insnum = f.readWord(); // number of instruments\n\theader->patnum = f.readWord(); // number of patterns\t\n\t\n\tmp_sint32 flags = f.readWord(); // st3 flags\t\n\n\tmp_sint32 Cvt = f.readWord();\n\n\theader->flags = XModule::MODULE_ST3NEWINSTRUMENT | XModule::MODULE_ST3DUALCOMMANDS;\n\n\tif (Cvt == 0x1300 || (flags & 64))\n\t\theader->flags |= module->MODULE_OLDS3MVOLSLIDES;\n\t\t\n\theader->flags |= module->MODULE_ST3NOTECUT;\n\t\n\t/*mp_uword Ffi = */f.readWord();\n\t\n\tf.read(header->sig,1,4);\n\t\n\theader->mainvol = module->vol64to255(f.readByte()); // initial main volume\n\t\n\theader->tempo = f.readByte(); // tempo\n\t\n\theader->speed = f.readByte(); // speed\n\t\n\tf.readByte(); // global volume? skipped...\n\t\n\tf.readByte(); // ignore GUS click removal\n\t\n\t/*mp_ubyte dp = */f.readByte();\n\t\n\tf.readDword();\t// skip something\n\tf.readDword();\t// skip something\n\tf.readWord();\t// skip some more...\n\t\n\tmp_ubyte channelSettings[32];\n\tf.read(channelSettings,1,32);\n\t\n\tmp_sint32 numChannels = 0;\n\t\n\tfor (numChannels = 0; numChannels < 32; numChannels++)\n\t\tif (channelSettings[numChannels] == 255)\n\t\t\tbreak;\n\t\n\theader->channum = numChannels; // number of channels\n\t\n\tf.read(orders,1,header->ordnum);\n\t\n\tmp_sint32 j = 0, i = 0;\n\tfor (i = 0; i < header->ordnum; i++)\n\t{\n\t\tif (orders[i] == 255) \n\t\t\tbreak;\n\t\t\n\t\theader->ord[j++] = orders[i];\t\t\n\t}\n\t\n\theader->ordnum = j; // final songlength\n\t\n\tdelete[] orders;\n\t\n\tmp_uword* insParaPtrs = new mp_uword[header->insnum];\n\t\n\tif (insParaPtrs == NULL)\n\t\treturn MP_OUT_OF_MEMORY;\n\t\n\tf.readWords(insParaPtrs,header->insnum);\n\t\n\tmp_uword* patParaPtrs = new mp_uword[header->patnum];\n\t\n\tif (patParaPtrs == NULL)\n\t{\n\t\tdelete[] insParaPtrs;\n\t\treturn MP_OUT_OF_MEMORY;\n\t}\n\t\n\tf.readWords(patParaPtrs,header->patnum);\n\t\n\t//for (i = 0; i < header->insnum; i++)\n\t//{\n\t//\tprintf(\"%x\\n\",insParaPtrs[i]*16);\n\t//}\n\t\t\n\t//////////////////////\n\t// read instruments //\n\t//////////////////////\n\tmp_uint32* samplePtrs = new mp_uint32[header->insnum];\n\tif (samplePtrs == NULL)\n\t{\n\t\tdelete[] insParaPtrs;\n\t\tdelete[] patParaPtrs;\n\t\treturn MP_OUT_OF_MEMORY;\n\t}\n\t\n\tmemset(samplePtrs,0,sizeof(mp_uint32)*header->insnum);\n\t\n\tmp_sint32 s = 0;\n\tfor (i = 0; i < header->insnum; i++)\n\t{\n\t\tmp_uint32 insOffs = insParaPtrs[i]*16;\n\n\t\tif (insOffs)\n\t\t{\n\t\t\tf.seekWithBaseOffset(insOffs);\n\t\t\n\t\t\t// We can only read that if it's a sample\n\t\t\tmp_ubyte type = f.readByte();\n\t\t\t\n\t\t\tif (type == 1)\n\t\t\t{\n\t\t\t\tf.read(smp[s].name,1,12);\t// read dos filename\n\t\t\n\t\t\t\tmp_ubyte bOffs = f.readByte();\n\t\t\t\tmp_uword wOffs = f.readWord();\n\t\t\t\t\n\t\t\t\t// stupid fileoffsets\n\t\t\t\tsamplePtrs[i] = (((mp_uint32)bOffs<<16)+(mp_uint32)wOffs)*16;\n\t\t\t\t\n\t\t\t\tsmp[s].flags = 1;\n\t\t\t\tsmp[s].pan = 0x80;\n\t\t\t\t\n\t\t\t\tsmp[s].samplen = f.readDword();\n\t\t\t\tsmp[s].loopstart = f.readDword();\n\t\t\t\tmp_sint32 looplen = ((mp_sint32)f.readDword() - (mp_sint32)smp[s].loopstart);\n\t\t\t\tif (looplen < 0) \n\t\t\t\t\tlooplen = 0;\n\t\t\t\tsmp[s].looplen = looplen;\n\t\t\t\t\n\t\t\t\tsmp[s].vol = module->vol64to255(f.readByte());\n\t\t\t\t\n\t\t\t\tf.readByte(); // skip something\n\t\t\t\t\n\t\t\t\tsmp[s].res = f.readByte() == 0x04 ? 0xAD : 0; // packing\n\t\t\t\t\n\t\t\t\tmp_ubyte flags = f.readByte();\n\t\t\t\t\n\t\t\t\t// looping\n\t\t\t\tif (flags & 1)\n\t\t\t\t{\n\t\t\t\t\tsmp[s].type = 1;\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// 16 bit sample\n\t\t\t\tif (flags & 4)\n\t\t\t\t{\n\t\t\t\t\tsmp[s].type |= 16;\n\t\t\t\t\tsmp[s].samplen >>= 1;\n\t\t\t\t\tsmp[s].loopstart >>= 1;\n\t\t\t\t\tsmp[s].looplen >>= 1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmp_uint32 c4spd = f.readDword();\n\t\t\t\t\n\t\t\t\tXModule::convertc4spd(c4spd,&smp[s].finetune,&smp[s].relnote);\n\n#ifdef VERBOSE\n\t\t\t\tprintf(\"%i, %i\\n\",c4spd,module->getc4spd(smp[s].relnote,smp[s].finetune));\t\t\t\t\n#endif\n\n\t\t\t\tf.readDword(); // skip something\n\t\t\t\t\n\t\t\t\tf.readDword(); // skip two internal words\n\t\t\t\t\n\t\t\t\tf.readDword(); // skip internal dword\n\n\t\t\t\tf.read(instr[i].name,1,28); // instrument name\n\t\t\t\t\n\t\t\t\tf.readDword(); // skip signature\n\t\t\t\t\n\t\t\t\tif (samplePtrs[i] && smp[s].samplen)\n\t\t\t\t{\n\t\t\t\t\tinstr[i].samp=1;\n\t\t\t\t\tfor (j=0;j<120;j++) \n\t\t\t\t\t\tinstr[i].snum[j] = s;\n\t\t\t\t\ts++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (type == 0)\n\t\t\t{\n\t\t\t\tsamplePtrs[i] = 0;\n\t\t\t\n\t\t\t\tmp_ubyte buffer[12];\n\t\t\t\tf.read(buffer,1,12);\t// read dos filename\n\t\t\n\t\t\t\tf.readByte();\n\t\t\t\tf.readWord();\n\t\t\t\t\n\t\t\t\tf.readDword();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readByte();\n\t\t\t\tf.readByte(); // skip something\n\t\t\t\tf.readByte(); // skip packing\n\t\t\t\t\n\t\t\t\tf.readByte();\n\t\t\t\t\n\t\t\t\tf.readDword();\n\t\t\t\t\n\t\t\t\tf.readDword(); // skip something\n\t\t\t\t\n\t\t\t\tf.readDword(); // skip two internal words\n\t\t\t\t\n\t\t\t\tf.readDword(); // skip internal dword\n\n\t\t\t\tf.read(instr[i].name,1,28); // instrument name\n\t\t\t\t\n\t\t\t\tf.readDword(); // skip signature\t\t\t\t\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tsamplePtrs[i] = 0;\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t}\n\t\n\t//////////////////////\n\t// read patterns\t//\n\t//////////////////////\n\tmp_ubyte* pattern = new mp_ubyte[64*32*5];\n\tif (pattern == NULL)\n\t{\n\t\tdelete[] insParaPtrs;\n\t\tdelete[] patParaPtrs;\n\t\tdelete[] samplePtrs;\n\t\treturn MP_OUT_OF_MEMORY;\n\t}\n\t\n\tmp_uint32 songMaxChannels = 1;\n\t\n\tfor (i = 0; i < header->patnum; i++)\n\t{\n\t\tfor (j = 0; j < 32*64; j++)\n\t\t{\n\t\t\tpattern[j*5] = 0xFF;\n\t\t\tpattern[j*5+1] = 0;\n\t\t\tpattern[j*5+2] = 0xFF;\n\t\t\tpattern[j*5+3] = 0xFF;\n\t\t\tpattern[j*5+4] = 0;\n\t\t}\n\t\t\n\t\tmp_uint32 patOffs = patParaPtrs[i]*16;\n\t\t\n\t\tmp_uint32 maxChannels = 1;\t\t\t\n\t\t\n\t\tif (patOffs)\n\t\t{\n\t\t\tf.seekWithBaseOffset(patOffs);\n\t\t\t\n\t\t\tmp_uint32 size = f.readWord();\n\t\t\t\n\t\t\tif (size > 2)\n\t\t\t{\n\t\t\t\tsize-=2;\n\t\t\t\t\n\t\t\t\tmp_ubyte* packed = new mp_ubyte[size+5];\n\t\t\t\tif (packed == NULL)\n\t\t\t\t{\n\t\t\t\t\tdelete[] insParaPtrs;\n\t\t\t\t\tdelete[] patParaPtrs;\n\t\t\t\t\tdelete[] samplePtrs;\n\t\t\t\t\tdelete[] pattern;\n\t\t\t\t\treturn MP_OUT_OF_MEMORY;\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmemset(packed, 0, size);\n\t\t\t\tf.read(packed, 1, size);\n\t\t\t\t\n\t\t\t\tmp_uint32 index = 0;\n\t\t\t\tmp_uint32 row = 0;\n\t\t\t\t\n\t\t\t\twhile (index<size)\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tmp_ubyte pi = safeRead(packed, index, size);\n\t\t\t\t\t\n\t\t\t\t\tif (pi == 0) \n\t\t\t\t\t{\n\t\t\t\t\t\trow++;\n\t\t\t\t\t\t// one more safety net for incorrectly saved pattern sizes\n\t\t\t\t\t\tif (row >= 64)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint i = 0;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tmp_uint32 chn = pi&31;\n\t\t\t\t\t\n\t\t\t\t\tif (chn>maxChannels && (pi & (32+64+128)))\n\t\t\t\t\t{\n\t\t\t\t\t\tmaxChannels = chn;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tmp_ubyte* slot = pattern+(row*32*5)+chn*5;\n\t\t\t\t\t\n\t\t\t\t\tif (pi & 32)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot[0] = safeRead(packed, index, size, 0xFF);\n\t\t\t\t\t\tslot[1] = safeRead(packed, index, size);\n\t\t\t\t\t}\n\t\t\t\t\tif (pi & 64)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot[2] = safeRead(packed, index, size, 0xFF);\n\t\t\t\t\t}\n\t\t\t\t\tif (pi & 128)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot[3] = safeRead(packed, index, size, 0xFF);\n\t\t\t\t\t\tslot[4] = safeRead(packed, index, size);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmaxChannels++;\n\t\t\t\t\n\t\t\t\tif (maxChannels > header->channum)\n\t\t\t\t\tmaxChannels = header->channum;\n\t\t\t\t\n\t\t\t\tdelete[] packed;\n\t\t\t}\n\t\t\t\n\t\t\tif (maxChannels > songMaxChannels)\n\t\t\t\tsongMaxChannels = maxChannels;\n\t\t\t\n\t\t}\n\t\t\n\t\tconvertS3MPattern(&phead[i], pattern, maxChannels, i);\n\t\t\n\t\t\n\t}\n\t\n\tif (header->channum > songMaxChannels)\n\t\theader->channum = songMaxChannels;\n\t\n\tdelete[] pattern;\n\tdelete[] insParaPtrs;\n\tdelete[] patParaPtrs;\n\t\n\ts = 0;\n\tfor (i = 0; i < header->insnum; i++)\n\t{\n\t\tmp_uint32 smpOffs = samplePtrs[i];\n\n\t\tif (smpOffs)\n\t\t{\n\t\t\tf.seekWithBaseOffset(smpOffs);\n\t\t\t\n\t\t\tif (!smp[s].samplen)\n\t\t\t\tcontinue;\n\n\t\t\tbool adpcm = (smp[s].res == 0xAD);\n\n\t\t\tmp_sint32 result = module->loadModuleSample(f, s, \n\t\t\t\t\t\t\t\t\t\t  adpcm ? XModule::ST_PACKING_ADPCM : XModule::ST_UNSIGNED, \n\t\t\t\t\t\t\t\t\t\t  adpcm ? (XModule::ST_16BIT | XModule::ST_PACKING_ADPCM) : (XModule::ST_16BIT | XModule::ST_UNSIGNED));\n\t\t\tif (result != MP_OK)\n\t\t\t{\n\t\t\t\tdelete[] samplePtrs;\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\t\n\t\t\tif (adpcm)\n\t\t\t\t// no longer needed\n\t\t\t\tsmp[s].res = 0;\t\t\t\n\t\t\t\t\t\t\t\n\t\t\ts++;\n\t\t\t\n\t\t}\n\n\t}\n\t\n\tdelete[] samplePtrs;\n\t\n\theader->smpnum = s;\n\t\n\tstrcpy(header->tracker,\"Screamtracker 3\");\n\t\n\tmodule->setDefaultPanning();\n\t\n\tmodule->postProcessSamples();\n\t\n\treturn MP_OK;\t\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "LoaderS3M.cpp",
        "method_name": "fixed_function",
        "raw_code": "mp_sint32 LoaderS3M::load(XMFileBase& f, XModule* module)\n{\t\n\tmodule->cleanUp();\n\n\t// this will make code much easier to read\n\tTXMHeader*\t\theader = &module->header;\n\tTXMInstrument*\tinstr  = module->instr;\n\tTXMSample*\t\tsmp\t   = module->smp;\n\tTXMPattern*\t\tphead  = module->phead;\t\n\n\t// we're already out of memory here\n\tif (!phead || !instr || !smp)\n\t\treturn MP_OUT_OF_MEMORY;\n\t\n\tf.read(&header->name,1,28);\n\theader->whythis1a = f.readByte();\n\t\n\tif (f.readByte() != 16) \n\t\treturn MP_LOADER_FAILED;\t// no ST3 module\n\t\n\tf.readByte(); // skip something\n\tf.readByte(); // skip something\n\t\n\theader->ordnum = f.readWord(); // number of positions in order list (songlength)\n\t\n\tmp_ubyte* orders = new mp_ubyte[header->ordnum];\n\tif (orders == NULL) \n\t\treturn MP_OUT_OF_MEMORY;\n\t\n\theader->insnum = f.readWord(); // number of instruments\n\tif (header->insnum > MP_MAXINS)\n\t\treturn MP_LOADER_FAILED;\n\theader->patnum = f.readWord(); // number of patterns\n\tif (header->patnum > 256)\n\t\treturn MP_LOADER_FAILED;\n\t\n\tmp_sint32 flags = f.readWord(); // st3 flags\t\n\n\tmp_sint32 Cvt = f.readWord();\n\n\theader->flags = XModule::MODULE_ST3NEWINSTRUMENT | XModule::MODULE_ST3DUALCOMMANDS;\n\n\tif (Cvt == 0x1300 || (flags & 64))\n\t\theader->flags |= module->MODULE_OLDS3MVOLSLIDES;\n\t\t\n\theader->flags |= module->MODULE_ST3NOTECUT;\n\t\n\t/*mp_uword Ffi = */f.readWord();\n\t\n\tf.read(header->sig,1,4);\n\t\n\theader->mainvol = module->vol64to255(f.readByte()); // initial main volume\n\t\n\theader->tempo = f.readByte(); // tempo\n\t\n\theader->speed = f.readByte(); // speed\n\t\n\tf.readByte(); // global volume? skipped...\n\t\n\tf.readByte(); // ignore GUS click removal\n\t\n\t/*mp_ubyte dp = */f.readByte();\n\t\n\tf.readDword();\t// skip something\n\tf.readDword();\t// skip something\n\tf.readWord();\t// skip some more...\n\t\n\tmp_ubyte channelSettings[32];\n\tf.read(channelSettings,1,32);\n\t\n\tmp_sint32 numChannels = 0;\n\t\n\tfor (numChannels = 0; numChannels < 32; numChannels++)\n\t\tif (channelSettings[numChannels] == 255)\n\t\t\tbreak;\n\t\n\theader->channum = numChannels; // number of channels\n\t\n\tf.read(orders,1,header->ordnum);\n\t\n\tmp_sint32 j = 0, i = 0;\n\tfor (i = 0; i < header->ordnum; i++)\n\t{\n\t\tif (orders[i] == 255) \n\t\t\tbreak;\n\t\t\n\t\theader->ord[j++] = orders[i];\t\t\n\t}\n\t\n\theader->ordnum = j; // final songlength\n\t\n\tdelete[] orders;\n\t\n\tmp_uword* insParaPtrs = new mp_uword[header->insnum];\n\t\n\tif (insParaPtrs == NULL)\n\t\treturn MP_OUT_OF_MEMORY;\n\t\n\tf.readWords(insParaPtrs,header->insnum);\n\t\n\tmp_uword* patParaPtrs = new mp_uword[header->patnum];\n\t\n\tif (patParaPtrs == NULL)\n\t{\n\t\tdelete[] insParaPtrs;\n\t\treturn MP_OUT_OF_MEMORY;\n\t}\n\t\n\tf.readWords(patParaPtrs,header->patnum);\n\t\n\t//for (i = 0; i < header->insnum; i++)\n\t//{\n\t//\tprintf(\"%x\\n\",insParaPtrs[i]*16);\n\t//}\n\t\t\n\t//////////////////////\n\t// read instruments //\n\t//////////////////////\n\tmp_uint32* samplePtrs = new mp_uint32[header->insnum];\n\tif (samplePtrs == NULL)\n\t{\n\t\tdelete[] insParaPtrs;\n\t\tdelete[] patParaPtrs;\n\t\treturn MP_OUT_OF_MEMORY;\n\t}\n\t\n\tmemset(samplePtrs,0,sizeof(mp_uint32)*header->insnum);\n\t\n\tmp_sint32 s = 0;\n\tfor (i = 0; i < header->insnum; i++)\n\t{\n\t\tmp_uint32 insOffs = insParaPtrs[i]*16;\n\n\t\tif (insOffs)\n\t\t{\n\t\t\tf.seekWithBaseOffset(insOffs);\n\t\t\n\t\t\t// We can only read that if it's a sample\n\t\t\tmp_ubyte type = f.readByte();\n\t\t\t\n\t\t\tif (type == 1)\n\t\t\t{\n\t\t\t\tf.read(smp[s].name,1,12);\t// read dos filename\n\t\t\n\t\t\t\tmp_ubyte bOffs = f.readByte();\n\t\t\t\tmp_uword wOffs = f.readWord();\n\t\t\t\t\n\t\t\t\t// stupid fileoffsets\n\t\t\t\tsamplePtrs[i] = (((mp_uint32)bOffs<<16)+(mp_uint32)wOffs)*16;\n\t\t\t\t\n\t\t\t\tsmp[s].flags = 1;\n\t\t\t\tsmp[s].pan = 0x80;\n\t\t\t\t\n\t\t\t\tsmp[s].samplen = f.readDword();\n\t\t\t\tsmp[s].loopstart = f.readDword();\n\t\t\t\tmp_sint32 looplen = ((mp_sint32)f.readDword() - (mp_sint32)smp[s].loopstart);\n\t\t\t\tif (looplen < 0) \n\t\t\t\t\tlooplen = 0;\n\t\t\t\tsmp[s].looplen = looplen;\n\t\t\t\t\n\t\t\t\tsmp[s].vol = module->vol64to255(f.readByte());\n\t\t\t\t\n\t\t\t\tf.readByte(); // skip something\n\t\t\t\t\n\t\t\t\tsmp[s].res = f.readByte() == 0x04 ? 0xAD : 0; // packing\n\t\t\t\t\n\t\t\t\tmp_ubyte flags = f.readByte();\n\t\t\t\t\n\t\t\t\t// looping\n\t\t\t\tif (flags & 1)\n\t\t\t\t{\n\t\t\t\t\tsmp[s].type = 1;\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// 16 bit sample\n\t\t\t\tif (flags & 4)\n\t\t\t\t{\n\t\t\t\t\tsmp[s].type |= 16;\n\t\t\t\t\tsmp[s].samplen >>= 1;\n\t\t\t\t\tsmp[s].loopstart >>= 1;\n\t\t\t\t\tsmp[s].looplen >>= 1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmp_uint32 c4spd = f.readDword();\n\t\t\t\t\n\t\t\t\tXModule::convertc4spd(c4spd,&smp[s].finetune,&smp[s].relnote);\n\n#ifdef VERBOSE\n\t\t\t\tprintf(\"%i, %i\\n\",c4spd,module->getc4spd(smp[s].relnote,smp[s].finetune));\t\t\t\t\n#endif\n\n\t\t\t\tf.readDword(); // skip something\n\t\t\t\t\n\t\t\t\tf.readDword(); // skip two internal words\n\t\t\t\t\n\t\t\t\tf.readDword(); // skip internal dword\n\n\t\t\t\tf.read(instr[i].name,1,28); // instrument name\n\t\t\t\t\n\t\t\t\tf.readDword(); // skip signature\n\t\t\t\t\n\t\t\t\tif (samplePtrs[i] && smp[s].samplen)\n\t\t\t\t{\n\t\t\t\t\tinstr[i].samp=1;\n\t\t\t\t\tfor (j=0;j<120;j++) \n\t\t\t\t\t\tinstr[i].snum[j] = s;\n\t\t\t\t\ts++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (type == 0)\n\t\t\t{\n\t\t\t\tsamplePtrs[i] = 0;\n\t\t\t\n\t\t\t\tmp_ubyte buffer[12];\n\t\t\t\tf.read(buffer,1,12);\t// read dos filename\n\t\t\n\t\t\t\tf.readByte();\n\t\t\t\tf.readWord();\n\t\t\t\t\n\t\t\t\tf.readDword();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readByte();\n\t\t\t\tf.readByte(); // skip something\n\t\t\t\tf.readByte(); // skip packing\n\t\t\t\t\n\t\t\t\tf.readByte();\n\t\t\t\t\n\t\t\t\tf.readDword();\n\t\t\t\t\n\t\t\t\tf.readDword(); // skip something\n\t\t\t\t\n\t\t\t\tf.readDword(); // skip two internal words\n\t\t\t\t\n\t\t\t\tf.readDword(); // skip internal dword\n\n\t\t\t\tf.read(instr[i].name,1,28); // instrument name\n\t\t\t\t\n\t\t\t\tf.readDword(); // skip signature\t\t\t\t\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tsamplePtrs[i] = 0;\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t}\n\t\n\t//////////////////////\n\t// read patterns\t//\n\t//////////////////////\n\tmp_ubyte* pattern = new mp_ubyte[64*32*5];\n\tif (pattern == NULL)\n\t{\n\t\tdelete[] insParaPtrs;\n\t\tdelete[] patParaPtrs;\n\t\tdelete[] samplePtrs;\n\t\treturn MP_OUT_OF_MEMORY;\n\t}\n\t\n\tmp_uint32 songMaxChannels = 1;\n\t\n\tfor (i = 0; i < header->patnum; i++)\n\t{\n\t\tfor (j = 0; j < 32*64; j++)\n\t\t{\n\t\t\tpattern[j*5] = 0xFF;\n\t\t\tpattern[j*5+1] = 0;\n\t\t\tpattern[j*5+2] = 0xFF;\n\t\t\tpattern[j*5+3] = 0xFF;\n\t\t\tpattern[j*5+4] = 0;\n\t\t}\n\t\t\n\t\tmp_uint32 patOffs = patParaPtrs[i]*16;\n\t\t\n\t\tmp_uint32 maxChannels = 1;\t\t\t\n\t\t\n\t\tif (patOffs)\n\t\t{\n\t\t\tf.seekWithBaseOffset(patOffs);\n\t\t\t\n\t\t\tmp_uint32 size = f.readWord();\n\t\t\t\n\t\t\tif (size > 2)\n\t\t\t{\n\t\t\t\tsize-=2;\n\t\t\t\t\n\t\t\t\tmp_ubyte* packed = new mp_ubyte[size+5];\n\t\t\t\tif (packed == NULL)\n\t\t\t\t{\n\t\t\t\t\tdelete[] insParaPtrs;\n\t\t\t\t\tdelete[] patParaPtrs;\n\t\t\t\t\tdelete[] samplePtrs;\n\t\t\t\t\tdelete[] pattern;\n\t\t\t\t\treturn MP_OUT_OF_MEMORY;\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmemset(packed, 0, size);\n\t\t\t\tf.read(packed, 1, size);\n\t\t\t\t\n\t\t\t\tmp_uint32 index = 0;\n\t\t\t\tmp_uint32 row = 0;\n\t\t\t\t\n\t\t\t\twhile (index<size)\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tmp_ubyte pi = safeRead(packed, index, size);\n\t\t\t\t\t\n\t\t\t\t\tif (pi == 0) \n\t\t\t\t\t{\n\t\t\t\t\t\trow++;\n\t\t\t\t\t\t// one more safety net for incorrectly saved pattern sizes\n\t\t\t\t\t\tif (row >= 64)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint i = 0;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tmp_uint32 chn = pi&31;\n\t\t\t\t\t\n\t\t\t\t\tif (chn>maxChannels && (pi & (32+64+128)))\n\t\t\t\t\t{\n\t\t\t\t\t\tmaxChannels = chn;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tmp_ubyte* slot = pattern+(row*32*5)+chn*5;\n\t\t\t\t\t\n\t\t\t\t\tif (pi & 32)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot[0] = safeRead(packed, index, size, 0xFF);\n\t\t\t\t\t\tslot[1] = safeRead(packed, index, size);\n\t\t\t\t\t}\n\t\t\t\t\tif (pi & 64)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot[2] = safeRead(packed, index, size, 0xFF);\n\t\t\t\t\t}\n\t\t\t\t\tif (pi & 128)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot[3] = safeRead(packed, index, size, 0xFF);\n\t\t\t\t\t\tslot[4] = safeRead(packed, index, size);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmaxChannels++;\n\t\t\t\t\n\t\t\t\tif (maxChannels > header->channum)\n\t\t\t\t\tmaxChannels = header->channum;\n\t\t\t\t\n\t\t\t\tdelete[] packed;\n\t\t\t}\n\t\t\t\n\t\t\tif (maxChannels > songMaxChannels)\n\t\t\t\tsongMaxChannels = maxChannels;\n\t\t\t\n\t\t}\n\t\t\n\t\tconvertS3MPattern(&phead[i], pattern, maxChannels, i);\n\t\t\n\t\t\n\t}\n\t\n\tif (header->channum > songMaxChannels)\n\t\theader->channum = songMaxChannels;\n\t\n\tdelete[] pattern;\n\tdelete[] insParaPtrs;\n\tdelete[] patParaPtrs;\n\t\n\ts = 0;\n\tfor (i = 0; i < header->insnum; i++)\n\t{\n\t\tmp_uint32 smpOffs = samplePtrs[i];\n\n\t\tif (smpOffs)\n\t\t{\n\t\t\tf.seekWithBaseOffset(smpOffs);\n\t\t\t\n\t\t\tif (!smp[s].samplen)\n\t\t\t\tcontinue;\n\n\t\t\tbool adpcm = (smp[s].res == 0xAD);\n\n\t\t\tmp_sint32 result = module->loadModuleSample(f, s, \n\t\t\t\t\t\t\t\t\t\t  adpcm ? XModule::ST_PACKING_ADPCM : XModule::ST_UNSIGNED, \n\t\t\t\t\t\t\t\t\t\t  adpcm ? (XModule::ST_16BIT | XModule::ST_PACKING_ADPCM) : (XModule::ST_16BIT | XModule::ST_UNSIGNED));\n\t\t\tif (result != MP_OK)\n\t\t\t{\n\t\t\t\tdelete[] samplePtrs;\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\t\n\t\t\tif (adpcm)\n\t\t\t\t// no longer needed\n\t\t\t\tsmp[s].res = 0;\t\t\t\n\t\t\t\t\t\t\t\n\t\t\ts++;\n\t\t\t\n\t\t}\n\n\t}\n\t\n\tdelete[] samplePtrs;\n\t\n\theader->smpnum = s;\n\t\n\tstrcpy(header->tracker,\"Screamtracker 3\");\n\t\n\tmodule->setDefaultPanning();\n\t\n\tmodule->postProcessSamples();\n\t\n\treturn MP_OK;\t\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"Loaders.h\"\n\n// Type Definitions:\n// XModule:\nclass XModule\n{\npublic:\n\tenum\n\t{\n\t\tIdentificationBufferSize\t= 2048,\n\t};\n\n\t///////////////////////////////////////////////////////\n\t// this is our loader interface (abstract class)\t //\n\t// each loader has to conform to this interface\t\t //\n\t///////////////////////////////////////////////////////\n\tclass LoaderInterface\n\t{\n\tpublic:\n\t\t// make GCC shut up\n\t\tvirtual ~LoaderInterface() { }\t\t\n\t\t// returns c-string which identifies the module, NULL if loader can't identify module\n\t\t// IMPORTANT: buffer MUST contain eIdentifyBufferSize bytes of the beginning of the file\n\t\tvirtual const char* identifyModule(const mp_ubyte* buffer)\t\t\t= 0;\n\t\t// try to load module (check with identifyModule first)\n\t\tvirtual mp_sint32   load(XMFileBase& f, XModule* module)\t\t\t= 0;\n\t};\n\n\tenum ModuleTypes\n\t{\n\t\tModuleType_UNKNOWN,\n\t\tModuleType_669,\n\t\tModuleType_AMF,\n\t\tModuleType_AMS,\n\t\tModuleType_CBA,\n\t\tModuleType_DBM,\n\t\tModuleType_DIGI,\n\t\tModuleType_DSM,\n\t\tModuleType_DSm,\n\t\tModuleType_DTM_1,\n\t\tModuleType_DTM_2,\n\t\tModu...\n\n// TXMSample:\nstruct TXMSample\n\n// TXMHeader:\nstruct TXMHeader \n{\n\tchar\t\tsig[17];\n\tchar\t\tname[MP_MAXTEXT];\n\tchar\t\twhythis1a;\n\tchar\t\ttracker[MP_MAXTEXT];\n\tmp_uword\tver;\n\tmp_uint32\thdrsize;\n\tmp_uword\tordnum;\n\tmp_uword\trestart;\n\tmp_uword\tchannum;\n\tmp_uword\tpatnum;\n\tmp_uword\tinsnum;\n\tmp_uword\tsmpnum;\t\t\t// additional: number of samples in tune\n\tmp_uword\tvolenvnum;\t\t// additional: number of volume envelopes\n\tmp_uword\tpanenvnum;\t\t// additional: number of panning envelopes\n\tmp_uword\tfrqenvnum;\t\t// additional: number of frequency envelopes (MDL)\n\tmp_uword\tvibenvnum;\t\t// additional: number of vibrato envelopes (AMS)\n\tmp_uword\tpitchenvnum;\t// additional: number of pitch envelopes (IT)\n\tmp_uword\tfreqtab;\n\tmp_ubyte\tuppernotebound;\t// additional: note limit if not zero\n\tmp_sbyte\trelnote;\t\t// additional: semitone adjust value\n\tmp_dword    flags;\t\t\t// additional: some flags \n\tmp_uword\ttempo;\n\tmp_uword\tspeed;\n\tmp_uword\tmainvol;\n\tmp_ubyte\tord[MP_MAXORDERS];\n\tmp_ubyte\tpan[256];\n}\n\n// mp_uword:\ntypedef unsigned short  mp_uword;\n\n// TXMInstrument:\nstruct TXMInstrument\n{\n\tenum Flags\n\t{\n\t\tIF_ITNOTEREMAPPING\t= 0x01,\n\t\tIF_ITFADEOUT\t\t= 0x02,\n\t\tIF_ITENVELOPES\t\t= 0x04,\n\t\tIF_ITGOBALINSVOL\t= 0x08\n\t};\n\n\tmp_uint32\tsize;\n\tchar\t\tname[MP_MAXTEXT];\n\tchar\t\ttype;\n\tmp_uword\tsamp;\n\tmp_uint32\tshsize;\n\tmp_sword\tsnum[120];\t\t// -1 is an invalid/empty sample\n\tmp_uword\tflags;\t\t\t// not in .XM => from myself\n\t\t\t\t\t\t\t\t// Also holds NNA (bit 4-5), DCT (bit 6-7), DCA (bit 8-9)\n\tmp_ubyte\tnotemap[120];\t// Impulse Tracker addition\n\tmp_uword\tvolfade;\t\t// Impulse Tracker addition\n\n\tmp_uword\tvenvnum;\t\t// Impulse Tracker envelopes can't be sample-based (different envelopes can map to the same sample) ...\n\tmp_uword\tpenvnum;\t\t// ... (only when IF_ITENVELOPES flag is set)\n\tmp_uword\tfenvnum;\n\tmp_uword\tvibenvnum;\t\t\n\tmp_uword\tpitchenvnum;\t// IT pitch envelope\n\t\n\tmp_uword\tres;\t\t\t// when bit 3 (= 8) of flags is set, take this as global instrument vol (Impulse Tracker)\n\t\n\tmp_ubyte\tifc;\t\t\t// IT Initial Filter cutoff\n\tmp_ubyte\tifr;\t\t\t// IT Initial Filter resonance\n\t//char\t\t...\n\n// XModule:\nXModule.XModule:ANY()\n\n// mp_sint32:\ntypedef int\t\t\t\tmp_sint32;\n\n// mp_ubyte:\ntypedef unsigned char   mp_ubyte;\n\n// TXMSample:\nstruct TXMSample \n{\nprivate:\n\tstruct TLoopDoubleBuffProps\n\t{\n\t\tenum\n\t\t{\n\t\t\tStateUnused,\n\t\t\tStateUsed,\n\t\t\tStateDirty,\n\t\t};\n\t\t\n\t\tmp_uint32 samplesize;\n\t\tmp_ubyte state[4];\n\t\tmp_uint32 lastloopend;\n\t};\n\n\tenum \n\t{\n\t\tLoopAreaBackupSize = 4,\n\t\tLoopAreaBackupSizeMaxInBytes = 8,\t\t\n\t\tEmptySize = 8,\n\t\tLeadingPadding = sizeof(TLoopDoubleBuffProps) + LoopAreaBackupSizeMaxInBytes + EmptySize,\n\t\tTrailingPadding = 16,\n\t\tPaddingSpace = LeadingPadding+TrailingPadding\n\t};\n\n\tvoid restoreLoopArea();\n\npublic:\n\tmp_uint32\tsamplen;\n\tmp_uint32\tloopstart;\n\tmp_uint32\tlooplen;\n\tmp_ubyte\tflags;\t\t\t// Bit 0: Use volume\n\t\t\t\t\t\t\t\t// Bit 1: Use panning\n\t\t\t\t\t\t\t\t// Bit 2: Use sample volume as channel global volume (.PLM modules)\n\t\t\t\t\t\t\t\t// Bit 3: Use the res field as global sample volume\n\t\t\t\t\t\t\t\t// Bit 4: Use IT style auto vibrato (not implemented yet)\n\tmp_ubyte\tvol;\n\tmp_sbyte\tfinetune;\n\tmp_ubyte\ttype;\t\t\t// In Addition to XM: Bit 5: One shot forward looping sample (MOD backward compatibility)\n\tmp_ubyte\tpan;\n\tmp_sbyte\tr...\n\n// mp_uint32:\ntypedef unsigned int\tmp_uint32;\n\n// TXMPattern:\nstruct TXMPattern \n{\n\tmp_uint32\tlen;\n\tmp_ubyte\tptype;\n\tmp_uword\trows;\n\tmp_ubyte\teffnum;\n\tmp_ubyte\tchannum;\n\tmp_uword\tpatdata;\n\tmp_ubyte*   patternData;\n\t\n\tmp_sint32 compress(mp_ubyte* dest) const;\n\tmp_sint32 decompress(mp_ubyte* src, mp_sint32 len);\n#ifdef MILKYTRACKER\n\tbool saveExtendedPattern(const SYSCHAR* fileName) const;\n\tbool loadExtendedPattern(const SYSCHAR* fileName);\n\n\tbool saveExtendedTrack(const SYSCHAR* fileName, mp_uint32 channel) const;\n\tbool loadExtendedTrack(const SYSCHAR* fileName, mp_uint32 channel);\t\n\t\n\tconst TXMPattern& operator=(const TXMPattern& src);\n#endif\n}\n\n// Called Methods (top 10):\n// ASSERT from src/milkyplay/MilkyPlayCommon.h:\n\t#define ASSERT assert /* <=== src/milkyplay/MilkyPlayCommon.h:61:61:ASSERT:0 */ \n\n// MP_OK from src/milkyplay/MilkyPlayResults.h:\n#define MP_OK\t\t\t\t\t0\t\t\t\t /* <=== src/milkyplay/MilkyPlayResults.h:41:41:MP_OK:0 */ \n\n// smoothLooping from src/milkyplay/XModule.cpp:\nvoid TXMSample::smoothLooping() /* <=== TXMSample.smoothLooping:void() */ \n{\n\tif ((type&16) || (type & 3) != 1 || sample == NULL || samplen < 1024 || looplen <= 32)\n\t\treturn;\n\n\tmp_sbyte* data = (mp_sbyte*)this->sample;\n\t\n\tconst mp_sint32 blockSize = 8;\n\t\n\tmp_sint32 max,t;\n\t\n\tfloat v1 = data[loopstart];\n\tfloat v2 = data[loopstart+looplen];\n\t\n\tfloat avg = (v1+v2)*0.5f;\n\t\n\t// step 1: Fade to avg from what's coming before loopstart\n\tmax = loopstart;\n\tif (max > blockSize) max = blockSize;\n\tfor (t = 0; t < max; t++)\n\t{\n\t\tfloat ft = (float)t/(float)max;\n\t\tmp_sint32 index = loopstart - max + t;\t\t\t\t\t\n\t\tmp_sint32 src = data[index];\n\t\tfloat final = src * (1.0f - ft) + (avg * ft);\n\t\tdata[index] = (mp_sbyte)final;\n\t}\n\t\n\t// step 2: Fade from avg into what's coming after loopstart\n\tmax = blockSize;\n\tfor (t = 0; t < max; t++)\n\t{\n\t\tfloat ft = (float)t/(float)max;\n\t\tmp_sint32 index = loopstart + t;\t\t\t\t\t\n\t\tmp_sint32 dst = data[index];\n\t\tfloat final = avg * (1.0f - ft) + (dst * ft);\n\t\tdata[index] = (mp_sbyte)final;\n\t}\n\t\n\t// step 3\n\tfor (t = 0; t < blockSize; t++)\n\t{\n\t\tmp_sint32 index = loopstart+looplen - blockSize + t;\n\t\t\n\t\tmp_sint32 src = data[index];\n\t\t\n\t\tfloat ft = (float)t/(float)blockSize;\n\t\tfloat final = src * (1.0f - ft) + (avg * ft);\n\t\tdata[index] = (mp_sbyte)final;\n\t}\n}\n\n// restoreLoopArea from src/milkyplay/XModule.cpp:\nvoid TXMSample::restoreLoopArea() /* <=== TXMSample.restoreLoopArea:void() */ \n{\n\tif (sample == NULL)\n\t\treturn;\n\t\n\tmp_ubyte* originalSample = getPadStartAddr((mp_ubyte*)sample) + sizeof(TLoopDoubleBuffProps);\n\tmp_uint32 saveLen = (type&16) ? LoopAreaBackupSize * sizeof(mp_sword) : LoopAreaBackupSize;\n\t\n\tTLoopDoubleBuffProps* loopBufferProps = (TLoopDoubleBuffProps*)getPadStartAddr((mp_ubyte*)sample);\n\t\n\tASSERT(saveLen <= LeadingPadding / 2);\n\n\t// 16 bit sample\n\tif (type&16)\n\t{\n\t\tmp_sword* data = (mp_sword*)this->sample;\n\t\t\n\t\t// save \"real\" loop area back from double buffer to sample\n\t\tif ((loopBufferProps->state[1] & 16) == (type & 16))\n\t\t\tmemcpy(data+loopBufferProps->lastloopend, originalSample, saveLen);\n\t\telse\n\t\t{\n\t\t\t// buffer has been 8 bit, now we're 16 bit => convert upwards\n\t\t\tfor (mp_sint32 i = 0; i < LoopAreaBackupSize; i++)\n\t\t\t\tdata[loopBufferProps->lastloopend+i] = ((mp_sbyte*)originalSample)[i] << 8;\n\t\t}\n\t\tloopBufferProps->state[0] = TLoopDoubleBuffProps::StateUnused;\n\t}\n\t// 8 bit sample\n\telse \n\t{\t\t\t\n\t\tmp_sbyte* data = (mp_sbyte*)this->sample;\n\t\n\t\t// save \"real\" loop area back from double buffer to sample\n\t\tif ((loopBufferProps->state[1] & 16) == (type & 16))\n\t\t\tmemcpy(data+loopBufferProps->lastloopend, originalSample, saveLen);\n\t\telse\n\t\t{\n\t\t\t// buffer has been 16 bit, now we're 8 bit => convert downwards\n\t\t\tfor (mp_sint32 i = 0; i < LoopAreaBackupSize; i++)\n\t\t\t\tdata[loopBufferProps->lastloopend+i] = ((mp_sword*)originalSample)[i] >> 8;\n\t\t}\n\t\tloopBufferProps->state[0] = TLoopDoubleBuffProps::StateUnused;\n\t}\n}\n\n// MP_MAXINS from src/milkyplay/XModule.h:\n#define MP_MAXINS 255 /* <=== src/milkyplay/XModule.h:43:43:MP_MAXINS:0 */ \n\n// readDword from src/milkyplay/XMFile.cpp:\nmp_dword XMFileBase::readDword() /* <=== XMFileBase.readDword:unsigned int() */ \n{\n\tmp_ubyte c[4];\n\tmp_sint32 bytesRead = read(&c,1,4);\n\t//ASSERT(bytesRead == 4);\n\n\tif (!(bytesRead == 4))\n\t\tc[0] = c[1] = c[2] = c[3] = 0;\n\n\treturn (mp_dword)((mp_uint32)c[0]+\n\t\t\t\t\t  ((mp_uint32)c[1]<<8)+\n\t\t\t\t\t  ((mp_uint32)c[2]<<16)+\n\t\t\t\t\t  ((mp_uint32)c[3]<<24));\n}\n\n// readWord from src/milkyplay/XMFile.cpp:\nmp_uword XMFileBase::readWord() /* <=== XMFileBase.readWord:unsigned shortint() */ \n{\n\tmp_ubyte c[2];\n\tmp_sint32 bytesRead = read(&c,1,2);\n\t//ASSERT(bytesRead == 2);\n\n\tif (!(bytesRead == 2))\n\t\tc[0] = c[1] = 0;\n\n\treturn (mp_uword)((mp_uword)c[0]+((mp_uword)c[1]<<8));\n}\n\n// postProcessSamples from src/milkyplay/XModule.cpp:\nvoid XModule::postProcessSamples(bool heavy/* = false*/) /* <=== XModule.postProcessSamples:void(bool) */ \n{\n\tfor (mp_uint32 i = 0; i < header.smpnum; i++)\n\t{\n\n\t\tTXMSample* smp = &this->smp[i];\n\n#ifdef VERBOSE\n\t\tprintf(\"%i: %i, %i, %i, %x\\n\",i,smp->samplen, smp->loopstart, smp->looplen,smp->pan);\n#endif\n\n\t\tif (smp->samplen == 0)\n\t\t{\n\t\t\tfreeSampleMem((mp_ubyte*)smp->sample, false);\n\t\t\tsmp->sample = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (heavy)\n\t\t\tsmp->smoothLooping();\n\t\t\n\t\tsmp->postProcessSamples();\n\t}\n\n}\n\n// setDefaultPanning from src/milkyplay/XModule.cpp:\nvoid XModule::setDefaultPanning() /* <=== XModule.setDefaultPanning:void() */ \n{\n\tfor (mp_sint32 i = 0; i < header.channum; i++)\n\t{\n\t\tif (i & 1) \n\t\t\theader.pan[i] = 192;\n\t\telse\n\t\t\theader.pan[i] = 64;\n\t}\n}\n\n// readByte from src/milkyplay/XMFile.cpp:\nmp_ubyte XMFileBase::readByte() /* <=== XMFileBase.readByte:unsigned char() */ \n{\n\tmp_ubyte c;\n\tmp_sint32 bytesRead = read(&c,1,1);\n\t//ASSERT(bytesRead == 1);\n\t\n\tif (!(bytesRead == 1))\n\t\tc = 0;\n\t\n\treturn (mp_ubyte)c;\n}\n"
  },
  {
    "repository": "vim",
    "cve_id": "CVE-2022-0413",
    "cwe_list": [
      "CWE-416"
    ],
    "commit_hash": "37f47958b8a2a44abc60614271d9537e7f14e51a",
    "short_hash": "37f47958",
    "vulnerableMethods_before": [
      {
        "filename": "ex_cmds.c",
        "method_name": "vulnerable_function",
        "raw_code": "ex_substitute(exarg_T *eap)\n{\n    linenr_T\tlnum;\n    long\ti = 0;\n    regmmatch_T regmatch;\n    static subflags_T subflags = {FALSE, FALSE, FALSE, TRUE, FALSE,\n\t\t\t\t\t\t\t      FALSE, FALSE, 0};\n#ifdef FEAT_EVAL\n    subflags_T\tsubflags_save;\n#endif\n    int\t\tsave_do_all;\t\t// remember user specified 'g' flag\n    int\t\tsave_do_ask;\t\t// remember user specified 'c' flag\n    char_u\t*pat = NULL, *sub = NULL;\t// init for GCC\n    int\t\tdelimiter;\n    int\t\tsublen;\n    int\t\tgot_quit = FALSE;\n    int\t\tgot_match = FALSE;\n    int\t\ttemp;\n    int\t\twhich_pat;\n    char_u\t*cmd;\n    int\t\tsave_State;\n    linenr_T\tfirst_line = 0;\t\t// first changed line\n    linenr_T\tlast_line= 0;\t\t// below last changed line AFTER the\n\t\t\t\t\t// change\n    linenr_T\told_line_count = curbuf->b_ml.ml_line_count;\n    linenr_T\tline2;\n    long\tnmatch;\t\t\t// number of lines in match\n    char_u\t*sub_firstline;\t\t// allocated copy of first sub line\n    int\t\tendcolumn = FALSE;\t// cursor in last column when done\n    pos_T\told_cursor = curwin->w_cursor;\n    int\t\tstart_nsubs;\n#ifdef FEAT_EVAL\n    int\t\tsave_ma = 0;\n#endif\n\n    cmd = eap->arg;\n    if (!global_busy)\n    {\n\tsub_nsubs = 0;\n\tsub_nlines = 0;\n    }\n    start_nsubs = sub_nsubs;\n\n    if (eap->cmdidx == CMD_tilde)\n\twhich_pat = RE_LAST;\t// use last used regexp\n    else\n\twhich_pat = RE_SUBST;\t// use last substitute regexp\n\n\t\t\t\t// new pattern and substitution\n    if (eap->cmd[0] == 's' && *cmd != NUL && !VIM_ISWHITE(*cmd)\n\t\t&& vim_strchr((char_u *)\"0123456789cegriIp|\\\"\", *cmd) == NULL)\n    {\n\t\t\t\t// don't accept alphanumeric for separator\n\tif (check_regexp_delim(*cmd) == FAIL)\n\t    return;\n#ifdef FEAT_EVAL\n\tif (in_vim9script() && check_global_and_subst(eap->cmd, eap->arg)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t    return;\n#endif\n\n\t/*\n\t * undocumented vi feature:\n\t *  \"\\/sub/\" and \"\\?sub?\" use last used search pattern (almost like\n\t *  //sub/r).  \"\\&sub&\" use last substitute pattern (like //sub/).\n\t */\n\tif (*cmd == '\\\\')\n\t{\n\t    ++cmd;\n\t    if (vim_strchr((char_u *)\"/?&\", *cmd) == NULL)\n\t    {\n\t\temsg(_(e_backslash_should_be_followed_by));\n\t\treturn;\n\t    }\n\t    if (*cmd != '&')\n\t\twhich_pat = RE_SEARCH;\t    // use last '/' pattern\n\t    pat = (char_u *)\"\";\t\t    // empty search pattern\n\t    delimiter = *cmd++;\t\t    // remember delimiter character\n\t}\n\telse\t\t// find the end of the regexp\n\t{\n\t    which_pat = RE_LAST;\t    // use last used regexp\n\t    delimiter = *cmd++;\t\t    // remember delimiter character\n\t    pat = cmd;\t\t\t    // remember start of search pat\n\t    cmd = skip_regexp_ex(cmd, delimiter, magic_isset(),\n\t\t\t\t\t\t\t&eap->arg, NULL, NULL);\n\t    if (cmd[0] == delimiter)\t    // end delimiter found\n\t\t*cmd++ = NUL;\t\t    // replace it with a NUL\n\t}\n\n\t/*\n\t * Small incompatibility: vi sees '\\n' as end of the command, but in\n\t * Vim we want to use '\\n' to find/substitute a NUL.\n\t */\n\tsub = cmd;\t    // remember the start of the substitution\n\tcmd = skip_substitute(cmd, delimiter);\n\n\tif (!eap->skip)\n\t{\n\t    // In POSIX vi \":s/pat/%/\" uses the previous subst. string.\n\t    if (STRCMP(sub, \"%\") == 0\n\t\t\t\t && vim_strchr(p_cpo, CPO_SUBPERCENT) != NULL)\n\t    {\n\t\tif (old_sub == NULL)\t// there is no previous command\n\t\t{\n\t\t    emsg(_(e_no_previous_substitute_regular_expression));\n\t\t    return;\n\t\t}\n\t\tsub = old_sub;\n\t    }\n\t    else\n\t    {\n\t\tvim_free(old_sub);\n\t\told_sub = vim_strsave(sub);\n\t    }\n\t}\n    }\n    else if (!eap->skip)\t// use previous pattern and substitution\n    {\n\tif (old_sub == NULL)\t// there is no previous command\n\t{\n\t    emsg(_(e_no_previous_substitute_regular_expression));\n\t    return;\n\t}\n\tpat = NULL;\t\t// search_regcomp() will use previous pattern\n\tsub = old_sub;\n\n\t// Vi compatibility quirk: repeating with \":s\" keeps the cursor in the\n\t// last column after using \"$\".\n\tendcolumn = (curwin->w_curswant == MAXCOL);\n    }\n\n    // Recognize \":%s/\\n//\" and turn it into a join command, which is much\n    // more efficient.\n    // TODO: find a generic solution to make line-joining operations more\n    // efficient, avoid allocating a string that grows in size.\n    if (pat != NULL && STRCMP(pat, \"\\\\n\") == 0\n\t    && *sub == NUL\n\t    && (*cmd == NUL || (cmd[1] == NUL && (*cmd == 'g' || *cmd == 'l'\n\t\t\t\t\t     || *cmd == 'p' || *cmd == '#'))))\n    {\n\tlinenr_T    joined_lines_count;\n\n\tif (eap->skip)\n\t    return;\n\tcurwin->w_cursor.lnum = eap->line1;\n\tif (*cmd == 'l')\n\t    eap->flags = EXFLAG_LIST;\n\telse if (*cmd == '#')\n\t    eap->flags = EXFLAG_NR;\n\telse if (*cmd == 'p')\n\t    eap->flags = EXFLAG_PRINT;\n\n\t// The number of lines joined is the number of lines in the range plus\n\t// one.  One less when the last line is included.\n\tjoined_lines_count = eap->line2 - eap->line1 + 1;\n\tif (eap->line2 < curbuf->b_ml.ml_line_count)\n\t    ++joined_lines_count;\n\tif (joined_lines_count > 1)\n\t{\n\t    (void)do_join(joined_lines_count, FALSE, TRUE, FALSE, TRUE);\n\t    sub_nsubs = joined_lines_count - 1;\n\t    sub_nlines = 1;\n\t    (void)do_sub_msg(FALSE);\n\t    ex_may_print(eap);\n\t}\n\n\tif ((cmdmod.cmod_flags & CMOD_KEEPPATTERNS) == 0)\n\t    save_re_pat(RE_SUBST, pat, magic_isset());\n\t// put pattern in history\n\tadd_to_history(HIST_SEARCH, pat, TRUE, NUL);\n\n\treturn;\n    }\n\n    /*\n     * Find trailing options.  When '&' is used, keep old options.\n     */\n    if (*cmd == '&')\n\t++cmd;\n    else\n    {\n#ifdef FEAT_EVAL\n\tif (in_vim9script())\n\t{\n\t    // ignore 'gdefault' and 'edcompatible'\n\t    subflags.do_all = FALSE;\n\t    subflags.do_ask = FALSE;\n\t}\n\telse\n#endif\n\tif (!p_ed)\n\t{\n\t    if (p_gd)\t\t// default is global on\n\t\tsubflags.do_all = TRUE;\n\t    else\n\t\tsubflags.do_all = FALSE;\n\t    subflags.do_ask = FALSE;\n\t}\n\tsubflags.do_error = TRUE;\n\tsubflags.do_print = FALSE;\n\tsubflags.do_list = FALSE;\n\tsubflags.do_count = FALSE;\n\tsubflags.do_number = FALSE;\n\tsubflags.do_ic = 0;\n    }\n    while (*cmd)\n    {\n\t/*\n\t * Note that 'g' and 'c' are always inverted, also when p_ed is off.\n\t * 'r' is never inverted.\n\t */\n\tif (*cmd == 'g')\n\t    subflags.do_all = !subflags.do_all;\n\telse if (*cmd == 'c')\n\t    subflags.do_ask = !subflags.do_ask;\n\telse if (*cmd == 'n')\n\t    subflags.do_count = TRUE;\n\telse if (*cmd == 'e')\n\t    subflags.do_error = !subflags.do_error;\n\telse if (*cmd == 'r')\t    // use last used regexp\n\t    which_pat = RE_LAST;\n\telse if (*cmd == 'p')\n\t    subflags.do_print = TRUE;\n\telse if (*cmd == '#')\n\t{\n\t    subflags.do_print = TRUE;\n\t    subflags.do_number = TRUE;\n\t}\n\telse if (*cmd == 'l')\n\t{\n\t    subflags.do_print = TRUE;\n\t    subflags.do_list = TRUE;\n\t}\n\telse if (*cmd == 'i')\t    // ignore case\n\t    subflags.do_ic = 'i';\n\telse if (*cmd == 'I')\t    // don't ignore case\n\t    subflags.do_ic = 'I';\n\telse\n\t    break;\n\t++cmd;\n    }\n    if (subflags.do_count)\n\tsubflags.do_ask = FALSE;\n\n    save_do_all = subflags.do_all;\n    save_do_ask = subflags.do_ask;\n\n    /*\n     * check for a trailing count\n     */\n    cmd = skipwhite(cmd);\n    if (VIM_ISDIGIT(*cmd))\n    {\n\ti = getdigits(&cmd);\n\tif (i <= 0 && !eap->skip && subflags.do_error)\n\t{\n\t    emsg(_(e_positive_count_required));\n\t    return;\n\t}\n\teap->line1 = eap->line2;\n\teap->line2 += i - 1;\n\tif (eap->line2 > curbuf->b_ml.ml_line_count)\n\t    eap->line2 = curbuf->b_ml.ml_line_count;\n    }\n\n    /*\n     * check for trailing command or garbage\n     */\n    cmd = skipwhite(cmd);\n    if (*cmd && *cmd != '\"')\t    // if not end-of-line or comment\n    {\n\tset_nextcmd(eap, cmd);\n\tif (eap->nextcmd == NULL)\n\t{\n\t    semsg(_(e_trailing_characters_str), cmd);\n\t    return;\n\t}\n    }\n\n    if (eap->skip)\t    // not executing commands, only parsing\n\treturn;\n\n    if (!subflags.do_count && !curbuf->b_p_ma)\n    {\n\t// Substitution is not allowed in non-'modifiable' buffer\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n\treturn;\n    }\n\n    if (search_regcomp(pat, RE_SUBST, which_pat, SEARCH_HIS, &regmatch) == FAIL)\n    {\n\tif (subflags.do_error)\n\t    emsg(_(e_invalid_command));\n\treturn;\n    }\n\n    // the 'i' or 'I' flag overrules 'ignorecase' and 'smartcase'\n    if (subflags.do_ic == 'i')\n\tregmatch.rmm_ic = TRUE;\n    else if (subflags.do_ic == 'I')\n\tregmatch.rmm_ic = FALSE;\n\n    sub_firstline = NULL;\n\n    /*\n     * ~ in the substitute pattern is replaced with the old pattern.\n     * We do it here once to avoid it to be replaced over and over again.\n     * But don't do it when it starts with \"\\=\", then it's an expression.\n     */\n    if (!(sub[0] == '\\\\' && sub[1] == '='))\n\tsub = regtilde(sub, magic_isset());\n\n    /*\n     * Check for a match on each line.\n     */\n    line2 = eap->line2;\n    for (lnum = eap->line1; lnum <= line2 && !(got_quit\n#if defined(FEAT_EVAL)\n\t\t|| aborting()\n#endif\n\t\t); ++lnum)\n    {\n\tnmatch = vim_regexec_multi(&regmatch, curwin, curbuf, lnum,\n\t\t\t\t\t\t       (colnr_T)0, NULL, NULL);\n\tif (nmatch)\n\t{\n\t    colnr_T\tcopycol;\n\t    colnr_T\tmatchcol;\n\t    colnr_T\tprev_matchcol = MAXCOL;\n\t    char_u\t*new_end, *new_start = NULL;\n\t    unsigned\tnew_start_len = 0;\n\t    char_u\t*p1;\n\t    int\t\tdid_sub = FALSE;\n\t    int\t\tlastone;\n\t    int\t\tlen, copy_len, needed_len;\n\t    long\tnmatch_tl = 0;\t// nr of lines matched below lnum\n\t    int\t\tdo_again;\t// do it again after joining lines\n\t    int\t\tskip_match = FALSE;\n\t    linenr_T\tsub_firstlnum;\t// nr of first sub line\n#ifdef FEAT_PROP_POPUP\n\t    int\t\tapc_flags = APC_SAVE_FOR_UNDO | APC_SUBSTITUTE;\n\t    colnr_T\ttotal_added =  0;\n#endif\n\n\t    /*\n\t     * The new text is build up step by step, to avoid too much\n\t     * copying.  There are these pieces:\n\t     * sub_firstline\tThe old text, unmodified.\n\t     * copycol\t\tColumn in the old text where we started\n\t     *\t\t\tlooking for a match; from here old text still\n\t     *\t\t\tneeds to be copied to the new text.\n\t     * matchcol\t\tColumn number of the old text where to look\n\t     *\t\t\tfor the next match.  It's just after the\n\t     *\t\t\tprevious match or one further.\n\t     * prev_matchcol\tColumn just after the previous match (if any).\n\t     *\t\t\tMostly equal to matchcol, except for the first\n\t     *\t\t\tmatch and after skipping an empty match.\n\t     * regmatch.*pos\tWhere the pattern matched in the old text.\n\t     * new_start\tThe new text, all that has been produced so\n\t     *\t\t\tfar.\n\t     * new_end\t\tThe new text, where to append new text.\n\t     *\n\t     * lnum\t\tThe line number where we found the start of\n\t     *\t\t\tthe match.  Can be below the line we searched\n\t     *\t\t\twhen there is a \\n before a \\zs in the\n\t     *\t\t\tpattern.\n\t     * sub_firstlnum\tThe line number in the buffer where to look\n\t     *\t\t\tfor a match.  Can be different from \"lnum\"\n\t     *\t\t\twhen the pattern or substitute string contains\n\t     *\t\t\tline breaks.\n\t     *\n\t     * Special situations:\n\t     * - When the substitute string contains a line break, the part up\n\t     *   to the line break is inserted in the text, but the copy of\n\t     *   the original line is kept.  \"sub_firstlnum\" is adjusted for\n\t     *   the inserted lines.\n\t     * - When the matched pattern contains a line break, the old line\n\t     *   is taken from the line at the end of the pattern.  The lines\n\t     *   in the match are deleted later, \"sub_firstlnum\" is adjusted\n\t     *   accordingly.\n\t     *\n\t     * The new text is built up in new_start[].  It has some extra\n\t     * room to avoid using alloc()/free() too often.  new_start_len is\n\t     * the length of the allocated memory at new_start.\n\t     *\n\t     * Make a copy of the old line, so it won't be taken away when\n\t     * updating the screen or handling a multi-line match.  The \"old_\"\n\t     * pointers point into this copy.\n\t     */\n\t    sub_firstlnum = lnum;\n\t    copycol = 0;\n\t    matchcol = 0;\n\n\t    // At first match, remember current cursor position.\n\t    if (!got_match)\n\t    {\n\t\tsetpcmark();\n\t\tgot_match = TRUE;\n\t    }\n\n\t    /*\n\t     * Loop until nothing more to replace in this line.\n\t     * 1. Handle match with empty string.\n\t     * 2. If do_ask is set, ask for confirmation.\n\t     * 3. substitute the string.\n\t     * 4. if do_all is set, find next match\n\t     * 5. break if there isn't another match in this line\n\t     */\n\t    for (;;)\n\t    {\n\t\t// Advance \"lnum\" to the line where the match starts.  The\n\t\t// match does not start in the first line when there is a line\n\t\t// break before \\zs.\n\t\tif (regmatch.startpos[0].lnum > 0)\n\t\t{\n\t\t    lnum += regmatch.startpos[0].lnum;\n\t\t    sub_firstlnum += regmatch.startpos[0].lnum;\n\t\t    nmatch -= regmatch.startpos[0].lnum;\n\t\t    VIM_CLEAR(sub_firstline);\n\t\t}\n\n\t\t// Match might be after the last line for \"\\n\\zs\" matching at\n\t\t// the end of the last line.\n\t\tif (lnum > curbuf->b_ml.ml_line_count)\n\t\t    break;\n\n\t\tif (sub_firstline == NULL)\n\t\t{\n\t\t    sub_firstline = vim_strsave(ml_get(sub_firstlnum));\n\t\t    if (sub_firstline == NULL)\n\t\t    {\n\t\t\tvim_free(new_start);\n\t\t\tgoto outofmem;\n\t\t    }\n\t\t}\n\n\t\t// Save the line number of the last change for the final\n\t\t// cursor position (just like Vi).\n\t\tcurwin->w_cursor.lnum = lnum;\n\t\tdo_again = FALSE;\n\n\t\t/*\n\t\t * 1. Match empty string does not count, except for first\n\t\t * match.  This reproduces the strange vi behaviour.\n\t\t * This also catches endless loops.\n\t\t */\n\t\tif (matchcol == prev_matchcol\n\t\t\t&& regmatch.endpos[0].lnum == 0\n\t\t\t&& matchcol == regmatch.endpos[0].col)\n\t\t{\n\t\t    if (sub_firstline[matchcol] == NUL)\n\t\t\t// We already were at the end of the line.  Don't look\n\t\t\t// for a match in this line again.\n\t\t\tskip_match = TRUE;\n\t\t    else\n\t\t    {\n\t\t\t // search for a match at next column\n\t\t\tif (has_mbyte)\n\t\t\t    matchcol += mb_ptr2len(sub_firstline + matchcol);\n\t\t\telse\n\t\t\t    ++matchcol;\n\t\t    }\n\t\t    goto skip;\n\t\t}\n\n\t\t// Normally we continue searching for a match just after the\n\t\t// previous match.\n\t\tmatchcol = regmatch.endpos[0].col;\n\t\tprev_matchcol = matchcol;\n\n\t\t/*\n\t\t * 2. If do_count is set only increase the counter.\n\t\t *    If do_ask is set, ask for confirmation.\n\t\t */\n\t\tif (subflags.do_count)\n\t\t{\n\t\t    // For a multi-line match, put matchcol at the NUL at\n\t\t    // the end of the line and set nmatch to one, so that\n\t\t    // we continue looking for a match on the next line.\n\t\t    // Avoids that \":s/\\nB\\@=//gc\" get stuck.\n\t\t    if (nmatch > 1)\n\t\t    {\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline);\n\t\t\tnmatch = 1;\n\t\t\tskip_match = TRUE;\n\t\t    }\n\t\t    sub_nsubs++;\n\t\t    did_sub = TRUE;\n#ifdef FEAT_EVAL\n\t\t    // Skip the substitution, unless an expression is used,\n\t\t    // then it is evaluated in the sandbox.\n\t\t    if (!(sub[0] == '\\\\' && sub[1] == '='))\n#endif\n\t\t\tgoto skip;\n\t\t}\n\n\t\tif (subflags.do_ask)\n\t\t{\n\t\t    int typed = 0;\n\n\t\t    // change State to CONFIRM, so that the mouse works\n\t\t    // properly\n\t\t    save_State = State;\n\t\t    State = CONFIRM;\n\t\t    setmouse();\t\t// disable mouse in xterm\n\t\t    curwin->w_cursor.col = regmatch.startpos[0].col;\n\t\t    if (curwin->w_p_crb)\n\t\t\tdo_check_cursorbind();\n\n\t\t    // When 'cpoptions' contains \"u\" don't sync undo when\n\t\t    // asking for confirmation.\n\t\t    if (vim_strchr(p_cpo, CPO_UNDO) != NULL)\n\t\t\t++no_u_sync;\n\n\t\t    /*\n\t\t     * Loop until 'y', 'n', 'q', CTRL-E or CTRL-Y typed.\n\t\t     */\n\t\t    while (subflags.do_ask)\n\t\t    {\n\t\t\tif (exmode_active)\n\t\t\t{\n\t\t\t    char_u\t*resp;\n\t\t\t    colnr_T\tsc, ec;\n\n\t\t\t    print_line_no_prefix(lnum,\n\t\t\t\t\t subflags.do_number, subflags.do_list);\n\n\t\t\t    getvcol(curwin, &curwin->w_cursor, &sc, NULL, NULL);\n\t\t\t    curwin->w_cursor.col = regmatch.endpos[0].col - 1;\n\t\t\t    if (curwin->w_cursor.col < 0)\n\t\t\t\tcurwin->w_cursor.col = 0;\n\t\t\t    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &ec);\n\t\t\t    curwin->w_cursor.col = regmatch.startpos[0].col;\n\t\t\t    if (subflags.do_number || curwin->w_p_nu)\n\t\t\t    {\n\t\t\t\tint numw = number_width(curwin) + 1;\n\t\t\t\tsc += numw;\n\t\t\t\tec += numw;\n\t\t\t    }\n\t\t\t    msg_start();\n\t\t\t    for (i = 0; i < (long)sc; ++i)\n\t\t\t\tmsg_putchar(' ');\n\t\t\t    for ( ; i <= (long)ec; ++i)\n\t\t\t\tmsg_putchar('^');\n\n\t\t\t    resp = getexmodeline('?', NULL, 0, TRUE);\n\t\t\t    if (resp != NULL)\n\t\t\t    {\n\t\t\t\ttyped = *resp;\n\t\t\t\tvim_free(resp);\n\t\t\t    }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    char_u *orig_line = NULL;\n\t\t\t    int    len_change = 0;\n\t\t\t    int\t   save_p_lz = p_lz;\n#ifdef FEAT_FOLDING\n\t\t\t    int save_p_fen = curwin->w_p_fen;\n\n\t\t\t    curwin->w_p_fen = FALSE;\n#endif\n\t\t\t    // Invert the matched string.\n\t\t\t    // Remove the inversion afterwards.\n\t\t\t    temp = RedrawingDisabled;\n\t\t\t    RedrawingDisabled = 0;\n\n\t\t\t    // avoid calling update_screen() in vgetorpeek()\n\t\t\t    p_lz = FALSE;\n\n\t\t\t    if (new_start != NULL)\n\t\t\t    {\n\t\t\t\t// There already was a substitution, we would\n\t\t\t\t// like to show this to the user.  We cannot\n\t\t\t\t// really update the line, it would change\n\t\t\t\t// what matches.  Temporarily replace the line\n\t\t\t\t// and change it back afterwards.\n\t\t\t\torig_line = vim_strsave(ml_get(lnum));\n\t\t\t\tif (orig_line != NULL)\n\t\t\t\t{\n\t\t\t\t    char_u *new_line = concat_str(new_start,\n\t\t\t\t\t\t     sub_firstline + copycol);\n\n\t\t\t\t    if (new_line == NULL)\n\t\t\t\t\tVIM_CLEAR(orig_line);\n\t\t\t\t    else\n\t\t\t\t    {\n\t\t\t\t\t// Position the cursor relative to the\n\t\t\t\t\t// end of the line, the previous\n\t\t\t\t\t// substitute may have inserted or\n\t\t\t\t\t// deleted characters before the\n\t\t\t\t\t// cursor.\n\t\t\t\t\tlen_change = (int)STRLEN(new_line)\n\t\t\t\t\t\t     - (int)STRLEN(orig_line);\n\t\t\t\t\tcurwin->w_cursor.col += len_change;\n\t\t\t\t\tml_replace(lnum, new_line, FALSE);\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t    search_match_lines = regmatch.endpos[0].lnum\n\t\t\t\t\t\t  - regmatch.startpos[0].lnum;\n\t\t\t    search_match_endcol = regmatch.endpos[0].col\n\t\t\t\t\t\t\t\t + len_change;\n\t\t\t    highlight_match = TRUE;\n\n\t\t\t    update_topline();\n\t\t\t    validate_cursor();\n\t\t\t    update_screen(SOME_VALID);\n\t\t\t    highlight_match = FALSE;\n\t\t\t    redraw_later(SOME_VALID);\n\n#ifdef FEAT_FOLDING\n\t\t\t    curwin->w_p_fen = save_p_fen;\n#endif\n\t\t\t    if (msg_row == Rows - 1)\n\t\t\t\tmsg_didout = FALSE;\t// avoid a scroll-up\n\t\t\t    msg_starthere();\n\t\t\t    i = msg_scroll;\n\t\t\t    msg_scroll = 0;\t\t// truncate msg when\n\t\t\t\t\t\t\t// needed\n\t\t\t    msg_no_more = TRUE;\n\t\t\t    // write message same highlighting as for\n\t\t\t    // wait_return\n\t\t\t    smsg_attr(HL_ATTR(HLF_R),\n\t\t\t\t_(\"replace with %s (y/n/a/q/l/^E/^Y)?\"), sub);\n\t\t\t    msg_no_more = FALSE;\n\t\t\t    msg_scroll = i;\n\t\t\t    showruler(TRUE);\n\t\t\t    windgoto(msg_row, msg_col);\n\t\t\t    RedrawingDisabled = temp;\n\n#ifdef USE_ON_FLY_SCROLL\n\t\t\t    dont_scroll = FALSE; // allow scrolling here\n#endif\n\t\t\t    ++no_mapping;\t// don't map this key\n\t\t\t    ++allow_keys;\t// allow special keys\n\t\t\t    typed = plain_vgetc();\n\t\t\t    --allow_keys;\n\t\t\t    --no_mapping;\n\n\t\t\t    // clear the question\n\t\t\t    msg_didout = FALSE;\t// don't scroll up\n\t\t\t    msg_col = 0;\n\t\t\t    gotocmdline(TRUE);\n\t\t\t    p_lz = save_p_lz;\n\n\t\t\t    // restore the line\n\t\t\t    if (orig_line != NULL)\n\t\t\t\tml_replace(lnum, orig_line, FALSE);\n\t\t\t}\n\n\t\t\tneed_wait_return = FALSE; // no hit-return prompt\n\t\t\tif (typed == 'q' || typed == ESC || typed == Ctrl_C\n#ifdef UNIX\n\t\t\t\t|| typed == intr_char\n#endif\n\t\t\t\t)\n\t\t\t{\n\t\t\t    got_quit = TRUE;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == 'n')\n\t\t\t    break;\n\t\t\tif (typed == 'y')\n\t\t\t    break;\n\t\t\tif (typed == 'l')\n\t\t\t{\n\t\t\t    // last: replace and then stop\n\t\t\t    subflags.do_all = FALSE;\n\t\t\t    line2 = lnum;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == 'a')\n\t\t\t{\n\t\t\t    subflags.do_ask = FALSE;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == Ctrl_E)\n\t\t\t    scrollup_clamp();\n\t\t\telse if (typed == Ctrl_Y)\n\t\t\t    scrolldown_clamp();\n\t\t    }\n\t\t    State = save_State;\n\t\t    setmouse();\n\t\t    if (vim_strchr(p_cpo, CPO_UNDO) != NULL)\n\t\t\t--no_u_sync;\n\n\t\t    if (typed == 'n')\n\t\t    {\n\t\t\t// For a multi-line match, put matchcol at the NUL at\n\t\t\t// the end of the line and set nmatch to one, so that\n\t\t\t// we continue looking for a match on the next line.\n\t\t\t// Avoids that \":%s/\\nB\\@=//gc\" and \":%s/\\n/,\\r/gc\"\n\t\t\t// get stuck when pressing 'n'.\n\t\t\tif (nmatch > 1)\n\t\t\t{\n\t\t\t    matchcol = (colnr_T)STRLEN(sub_firstline);\n\t\t\t    skip_match = TRUE;\n\t\t\t}\n\t\t\tgoto skip;\n\t\t    }\n\t\t    if (got_quit)\n\t\t\tgoto skip;\n\t\t}\n\n\t\t// Move the cursor to the start of the match, so that we can\n\t\t// use \"\\=col(\".\").\n\t\tcurwin->w_cursor.col = regmatch.startpos[0].col;\n\n\t\t/*\n\t\t * 3. substitute the string.\n\t\t */\n#ifdef FEAT_EVAL\n\t\tsave_ma = curbuf->b_p_ma;\n\t\tif (subflags.do_count)\n\t\t{\n\t\t    // prevent accidentally changing the buffer by a function\n\t\t    curbuf->b_p_ma = FALSE;\n\t\t    sandbox++;\n\t\t}\n\t\t// Save flags for recursion.  They can change for e.g.\n\t\t// :s/^/\\=execute(\"s#^##gn\")\n\t\tsubflags_save = subflags;\n#endif\n\t\t// get length of substitution part\n\t\tsublen = vim_regsub_multi(&regmatch,\n\t\t\t\t    sub_firstlnum - regmatch.startpos[0].lnum,\n\t\t\t       sub, sub_firstline, FALSE, magic_isset(), TRUE);\n#ifdef FEAT_EVAL\n\t\t// If getting the substitute string caused an error, don't do\n\t\t// the replacement.\n\t\t// Don't keep flags set by a recursive call.\n\t\tsubflags = subflags_save;\n\t\tif (aborting() || subflags.do_count)\n\t\t{\n\t\t    curbuf->b_p_ma = save_ma;\n\t\t    if (sandbox > 0)\n\t\t\tsandbox--;\n\t\t    goto skip;\n\t\t}\n#endif\n\n\t\t// When the match included the \"$\" of the last line it may\n\t\t// go beyond the last line of the buffer.\n\t\tif (nmatch > curbuf->b_ml.ml_line_count - sub_firstlnum + 1)\n\t\t{\n\t\t    nmatch = curbuf->b_ml.ml_line_count - sub_firstlnum + 1;\n\t\t    skip_match = TRUE;\n\t\t}\n\n\t\t// Need room for:\n\t\t// - result so far in new_start (not for first sub in line)\n\t\t// - original text up to match\n\t\t// - length of substituted part\n\t\t// - original text after match\n\t\t// Adjust text properties here, since we have all information\n\t\t// needed.\n\t\tif (nmatch == 1)\n\t\t{\n\t\t    p1 = sub_firstline;\n#ifdef FEAT_PROP_POPUP\n\t\t    if (curbuf->b_has_textprop)\n\t\t    {\n\t\t\tint bytes_added = sublen - 1 - (regmatch.endpos[0].col\n\t\t\t\t\t\t   - regmatch.startpos[0].col);\n\n\t\t\t// When text properties are changed, need to save for\n\t\t\t// undo first, unless done already.\n\t\t\tif (adjust_prop_columns(lnum,\n\t\t\t\t\ttotal_added + regmatch.startpos[0].col,\n\t\t\t\t\t\t       bytes_added, apc_flags))\n\t\t\t    apc_flags &= ~APC_SAVE_FOR_UNDO;\n\t\t\t// Offset for column byte number of the text property\n\t\t\t// in the resulting buffer afterwards.\n\t\t\ttotal_added += bytes_added;\n\t\t    }\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t    p1 = ml_get(sub_firstlnum + nmatch - 1);\n\t\t    nmatch_tl += nmatch - 1;\n\t\t}\n\t\tcopy_len = regmatch.startpos[0].col - copycol;\n\t\tneeded_len = copy_len + ((unsigned)STRLEN(p1)\n\t\t\t\t       - regmatch.endpos[0].col) + sublen + 1;\n\t\tif (new_start == NULL)\n\t\t{\n\t\t    /*\n\t\t     * Get some space for a temporary buffer to do the\n\t\t     * substitution into (and some extra space to avoid\n\t\t     * too many calls to alloc()/free()).\n\t\t     */\n\t\t    new_start_len = needed_len + 50;\n\t\t    if ((new_start = alloc(new_start_len)) == NULL)\n\t\t\tgoto outofmem;\n\t\t    *new_start = NUL;\n\t\t    new_end = new_start;\n\t\t}\n\t\telse\n\t\t{\n\t\t    /*\n\t\t     * Check if the temporary buffer is long enough to do the\n\t\t     * substitution into.  If not, make it larger (with a bit\n\t\t     * extra to avoid too many calls to alloc()/free()).\n\t\t     */\n\t\t    len = (unsigned)STRLEN(new_start);\n\t\t    needed_len += len;\n\t\t    if (needed_len > (int)new_start_len)\n\t\t    {\n\t\t\tnew_start_len = needed_len + 50;\n\t\t\tif ((p1 = alloc(new_start_len)) == NULL)\n\t\t\t{\n\t\t\t    vim_free(new_start);\n\t\t\t    goto outofmem;\n\t\t\t}\n\t\t\tmch_memmove(p1, new_start, (size_t)(len + 1));\n\t\t\tvim_free(new_start);\n\t\t\tnew_start = p1;\n\t\t    }\n\t\t    new_end = new_start + len;\n\t\t}\n\n\t\t/*\n\t\t * copy the text up to the part that matched\n\t\t */\n\t\tmch_memmove(new_end, sub_firstline + copycol, (size_t)copy_len);\n\t\tnew_end += copy_len;\n\n\t\t(void)vim_regsub_multi(&regmatch,\n\t\t\t\t    sub_firstlnum - regmatch.startpos[0].lnum,\n\t\t\t\t      sub, new_end, TRUE, magic_isset(), TRUE);\n\t\tsub_nsubs++;\n\t\tdid_sub = TRUE;\n\n\t\t// Move the cursor to the start of the line, to avoid that it\n\t\t// is beyond the end of the line after the substitution.\n\t\tcurwin->w_cursor.col = 0;\n\n\t\t// For a multi-line match, make a copy of the last matched\n\t\t// line and continue in that one.\n\t\tif (nmatch > 1)\n\t\t{\n\t\t    sub_firstlnum += nmatch - 1;\n\t\t    vim_free(sub_firstline);\n\t\t    sub_firstline = vim_strsave(ml_get(sub_firstlnum));\n\t\t    // When going beyond the last line, stop substituting.\n\t\t    if (sub_firstlnum <= line2)\n\t\t\tdo_again = TRUE;\n\t\t    else\n\t\t\tsubflags.do_all = FALSE;\n\t\t}\n\n\t\t// Remember next character to be copied.\n\t\tcopycol = regmatch.endpos[0].col;\n\n\t\tif (skip_match)\n\t\t{\n\t\t    // Already hit end of the buffer, sub_firstlnum is one\n\t\t    // less than what it ought to be.\n\t\t    vim_free(sub_firstline);\n\t\t    sub_firstline = vim_strsave((char_u *)\"\");\n\t\t    copycol = 0;\n\t\t}\n\n\t\t/*\n\t\t * Now the trick is to replace CTRL-M chars with a real line\n\t\t * break.  This would make it impossible to insert a CTRL-M in\n\t\t * the text.  The line break can be avoided by preceding the\n\t\t * CTRL-M with a backslash.  To be able to insert a backslash,\n\t\t * they must be doubled in the string and are halved here.\n\t\t * That is Vi compatible.\n\t\t */\n\t\tfor (p1 = new_end; *p1; ++p1)\n\t\t{\n\t\t    if (p1[0] == '\\\\' && p1[1] != NUL)  // remove backslash\n\t\t    {\n\t\t\tSTRMOVE(p1, p1 + 1);\n#ifdef FEAT_PROP_POPUP\n\t\t\tif (curbuf->b_has_textprop)\n\t\t\t{\n\t\t\t    // When text properties are changed, need to save\n\t\t\t    // for undo first, unless done already.\n\t\t\t    if (adjust_prop_columns(lnum,\n\t\t\t\t\t(colnr_T)(p1 - new_start), -1,\n\t\t\t\t\tapc_flags))\n\t\t\t\tapc_flags &= ~APC_SAVE_FOR_UNDO;\n\t\t\t}\n#endif\n\t\t    }\n\t\t    else if (*p1 == CAR)\n\t\t    {\n\t\t\tif (u_inssub(lnum) == OK)   // prepare for undo\n\t\t\t{\n\t\t\t    colnr_T\tplen = (colnr_T)(p1 - new_start + 1);\n\n\t\t\t    *p1 = NUL;\t\t    // truncate up to the CR\n\t\t\t    ml_append(lnum - 1, new_start, plen, FALSE);\n\t\t\t    mark_adjust(lnum + 1, (linenr_T)MAXLNUM, 1L, 0L);\n\t\t\t    if (subflags.do_ask)\n\t\t\t\tappended_lines(lnum - 1, 1L);\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tif (first_line == 0)\n\t\t\t\t    first_line = lnum;\n\t\t\t\tlast_line = lnum + 1;\n\t\t\t    }\n#ifdef FEAT_PROP_POPUP\n\t\t\t    adjust_props_for_split(lnum + 1, lnum, plen, 1);\n#endif\n\t\t\t    // all line numbers increase\n\t\t\t    ++sub_firstlnum;\n\t\t\t    ++lnum;\n\t\t\t    ++line2;\n\t\t\t    // move the cursor to the new line, like Vi\n\t\t\t    ++curwin->w_cursor.lnum;\n\t\t\t    // copy the rest\n\t\t\t    STRMOVE(new_start, p1 + 1);\n\t\t\t    p1 = new_start - 1;\n\t\t\t}\n\t\t    }\n\t\t    else if (has_mbyte)\n\t\t\tp1 += (*mb_ptr2len)(p1) - 1;\n\t\t}\n\n\t\t/*\n\t\t * 4. If do_all is set, find next match.\n\t\t * Prevent endless loop with patterns that match empty\n\t\t * strings, e.g. :s/$/pat/g or :s/[a-z]* /(&)/g.\n\t\t * But \":s/\\n/#/\" is OK.\n\t\t */\nskip:\n\t\t// We already know that we did the last subst when we are at\n\t\t// the end of the line, except that a pattern like\n\t\t// \"bar\\|\\nfoo\" may match at the NUL.  \"lnum\" can be below\n\t\t// \"line2\" when there is a \\zs in the pattern after a line\n\t\t// break.\n\t\tlastone = (skip_match\n\t\t\t|| got_int\n\t\t\t|| got_quit\n\t\t\t|| lnum > line2\n\t\t\t|| !(subflags.do_all || do_again)\n\t\t\t|| (sub_firstline[matchcol] == NUL && nmatch <= 1\n\t\t\t\t\t && !re_multiline(regmatch.regprog)));\n\t\tnmatch = -1;\n\n\t\t/*\n\t\t * Replace the line in the buffer when needed.  This is\n\t\t * skipped when there are more matches.\n\t\t * The check for nmatch_tl is needed for when multi-line\n\t\t * matching must replace the lines before trying to do another\n\t\t * match, otherwise \"\\@<=\" won't work.\n\t\t * When the match starts below where we start searching also\n\t\t * need to replace the line first (using \\zs after \\n).\n\t\t */\n\t\tif (lastone\n\t\t\t|| nmatch_tl > 0\n\t\t\t|| (nmatch = vim_regexec_multi(&regmatch, curwin,\n\t\t\t\t\t\t\tcurbuf, sub_firstlnum,\n\t\t\t\t\t\t    matchcol, NULL, NULL)) == 0\n\t\t\t|| regmatch.startpos[0].lnum > 0)\n\t\t{\n\t\t    if (new_start != NULL)\n\t\t    {\n\t\t\t/*\n\t\t\t * Copy the rest of the line, that didn't match.\n\t\t\t * \"matchcol\" has to be adjusted, we use the end of\n\t\t\t * the line as reference, because the substitute may\n\t\t\t * have changed the number of characters.  Same for\n\t\t\t * \"prev_matchcol\".\n\t\t\t */\n\t\t\tSTRCAT(new_start, sub_firstline + copycol);\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline) - matchcol;\n\t\t\tprev_matchcol = (colnr_T)STRLEN(sub_firstline)\n\t\t\t\t\t\t\t      - prev_matchcol;\n\n\t\t\tif (u_savesub(lnum) != OK)\n\t\t\t    break;\n\t\t\tml_replace(lnum, new_start, TRUE);\n\n\t\t\tif (nmatch_tl > 0)\n\t\t\t{\n\t\t\t    /*\n\t\t\t     * Matched lines have now been substituted and are\n\t\t\t     * useless, delete them.  The part after the match\n\t\t\t     * has been appended to new_start, we don't need\n\t\t\t     * it in the buffer.\n\t\t\t     */\n\t\t\t    ++lnum;\n\t\t\t    if (u_savedel(lnum, nmatch_tl) != OK)\n\t\t\t\tbreak;\n\t\t\t    for (i = 0; i < nmatch_tl; ++i)\n\t\t\t\tml_delete(lnum);\n\t\t\t    mark_adjust(lnum, lnum + nmatch_tl - 1,\n\t\t\t\t\t\t   (long)MAXLNUM, -nmatch_tl);\n\t\t\t    if (subflags.do_ask)\n\t\t\t\tdeleted_lines(lnum, nmatch_tl);\n\t\t\t    --lnum;\n\t\t\t    line2 -= nmatch_tl; // nr of lines decreases\n\t\t\t    nmatch_tl = 0;\n\t\t\t}\n\n\t\t\t// When asking, undo is saved each time, must also set\n\t\t\t// changed flag each time.\n\t\t\tif (subflags.do_ask)\n\t\t\t    changed_bytes(lnum, 0);\n\t\t\telse\n\t\t\t{\n\t\t\t    if (first_line == 0)\n\t\t\t\tfirst_line = lnum;\n\t\t\t    last_line = lnum + 1;\n\t\t\t}\n\n\t\t\tsub_firstlnum = lnum;\n\t\t\tvim_free(sub_firstline);    // free the temp buffer\n\t\t\tsub_firstline = new_start;\n\t\t\tnew_start = NULL;\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline) - matchcol;\n\t\t\tprev_matchcol = (colnr_T)STRLEN(sub_firstline)\n\t\t\t\t\t\t\t      - prev_matchcol;\n\t\t\tcopycol = 0;\n\t\t    }\n\t\t    if (nmatch == -1 && !lastone)\n\t\t\tnmatch = vim_regexec_multi(&regmatch, curwin, curbuf,\n\t\t\t\t\t  sub_firstlnum, matchcol, NULL, NULL);\n\n\t\t    /*\n\t\t     * 5. break if there isn't another match in this line\n\t\t     */\n\t\t    if (nmatch <= 0)\n\t\t    {\n\t\t\t// If the match found didn't start where we were\n\t\t\t// searching, do the next search in the line where we\n\t\t\t// found the match.\n\t\t\tif (nmatch == -1)\n\t\t\t    lnum -= regmatch.startpos[0].lnum;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t\tline_breakcheck();\n\t    }\n\n\t    if (did_sub)\n\t\t++sub_nlines;\n\t    vim_free(new_start);\t// for when substitute was cancelled\n\t    VIM_CLEAR(sub_firstline);\t// free the copy of the original line\n\t}\n\n\tline_breakcheck();\n    }\n\n    if (first_line != 0)\n    {\n\t// Need to subtract the number of added lines from \"last_line\" to get\n\t// the line number before the change (same as adding the number of\n\t// deleted lines).\n\ti = curbuf->b_ml.ml_line_count - old_line_count;\n\tchanged_lines(first_line, 0, last_line - i, i);\n    }\n\noutofmem:\n    vim_free(sub_firstline); // may have to free allocated copy of the line\n\n    // \":s/pat//n\" doesn't move the cursor\n    if (subflags.do_count)\n\tcurwin->w_cursor = old_cursor;\n\n    if (sub_nsubs > start_nsubs)\n    {\n\tif ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\t{\n\t    // Set the '[ and '] marks.\n\t    curbuf->b_op_start.lnum = eap->line1;\n\t    curbuf->b_op_end.lnum = line2;\n\t    curbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n\t}\n\n\tif (!global_busy)\n\t{\n\t    // when interactive leave cursor on the match\n\t    if (!subflags.do_ask)\n\t    {\n\t\tif (endcolumn)\n\t\t    coladvance((colnr_T)MAXCOL);\n\t\telse\n\t\t    beginline(BL_WHITE | BL_FIX);\n\t    }\n\t    if (!do_sub_msg(subflags.do_count) && subflags.do_ask)\n\t\tmsg(\"\");\n\t}\n\telse\n\t    global_need_beginline = TRUE;\n\tif (subflags.do_print)\n\t    print_line(curwin->w_cursor.lnum,\n\t\t\t\t\t subflags.do_number, subflags.do_list);\n    }\n    else if (!global_busy)\n    {\n\tif (got_int)\t\t// interrupted\n\t    emsg(_(e_interrupted));\n\telse if (got_match)\t// did find something but nothing substituted\n\t    msg(\"\");\n\telse if (subflags.do_error)\t// nothing found\n\t    semsg(_(e_pattern_not_found_str), get_search_pat());\n    }\n\n#ifdef FEAT_FOLDING\n    if (subflags.do_ask && hasAnyFolding(curwin))\n\t// Cursor position may require updating\n\tchanged_window_setting();\n#endif\n\n    vim_regfree(regmatch.regprog);\n\n    // Restore the flag values, they can be used for \":&&\".\n    subflags.do_all = save_do_all;\n    subflags.do_ask = save_do_ask;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ex_cmds.c",
        "method_name": "fixed_function",
        "raw_code": "ex_substitute(exarg_T *eap)\n{\n    linenr_T\tlnum;\n    long\ti = 0;\n    regmmatch_T regmatch;\n    static subflags_T subflags = {FALSE, FALSE, FALSE, TRUE, FALSE,\n\t\t\t\t\t\t\t      FALSE, FALSE, 0};\n#ifdef FEAT_EVAL\n    subflags_T\tsubflags_save;\n#endif\n    int\t\tsave_do_all;\t\t// remember user specified 'g' flag\n    int\t\tsave_do_ask;\t\t// remember user specified 'c' flag\n    char_u\t*pat = NULL, *sub = NULL;\t// init for GCC\n    char_u\t*sub_copy = NULL;\n    int\t\tdelimiter;\n    int\t\tsublen;\n    int\t\tgot_quit = FALSE;\n    int\t\tgot_match = FALSE;\n    int\t\ttemp;\n    int\t\twhich_pat;\n    char_u\t*cmd;\n    int\t\tsave_State;\n    linenr_T\tfirst_line = 0;\t\t// first changed line\n    linenr_T\tlast_line= 0;\t\t// below last changed line AFTER the\n\t\t\t\t\t// change\n    linenr_T\told_line_count = curbuf->b_ml.ml_line_count;\n    linenr_T\tline2;\n    long\tnmatch;\t\t\t// number of lines in match\n    char_u\t*sub_firstline;\t\t// allocated copy of first sub line\n    int\t\tendcolumn = FALSE;\t// cursor in last column when done\n    pos_T\told_cursor = curwin->w_cursor;\n    int\t\tstart_nsubs;\n#ifdef FEAT_EVAL\n    int\t\tsave_ma = 0;\n#endif\n\n    cmd = eap->arg;\n    if (!global_busy)\n    {\n\tsub_nsubs = 0;\n\tsub_nlines = 0;\n    }\n    start_nsubs = sub_nsubs;\n\n    if (eap->cmdidx == CMD_tilde)\n\twhich_pat = RE_LAST;\t// use last used regexp\n    else\n\twhich_pat = RE_SUBST;\t// use last substitute regexp\n\n\t\t\t\t// new pattern and substitution\n    if (eap->cmd[0] == 's' && *cmd != NUL && !VIM_ISWHITE(*cmd)\n\t\t&& vim_strchr((char_u *)\"0123456789cegriIp|\\\"\", *cmd) == NULL)\n    {\n\t\t\t\t// don't accept alphanumeric for separator\n\tif (check_regexp_delim(*cmd) == FAIL)\n\t    return;\n#ifdef FEAT_EVAL\n\tif (in_vim9script() && check_global_and_subst(eap->cmd, eap->arg)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t    return;\n#endif\n\n\t/*\n\t * undocumented vi feature:\n\t *  \"\\/sub/\" and \"\\?sub?\" use last used search pattern (almost like\n\t *  //sub/r).  \"\\&sub&\" use last substitute pattern (like //sub/).\n\t */\n\tif (*cmd == '\\\\')\n\t{\n\t    ++cmd;\n\t    if (vim_strchr((char_u *)\"/?&\", *cmd) == NULL)\n\t    {\n\t\temsg(_(e_backslash_should_be_followed_by));\n\t\treturn;\n\t    }\n\t    if (*cmd != '&')\n\t\twhich_pat = RE_SEARCH;\t    // use last '/' pattern\n\t    pat = (char_u *)\"\";\t\t    // empty search pattern\n\t    delimiter = *cmd++;\t\t    // remember delimiter character\n\t}\n\telse\t\t// find the end of the regexp\n\t{\n\t    which_pat = RE_LAST;\t    // use last used regexp\n\t    delimiter = *cmd++;\t\t    // remember delimiter character\n\t    pat = cmd;\t\t\t    // remember start of search pat\n\t    cmd = skip_regexp_ex(cmd, delimiter, magic_isset(),\n\t\t\t\t\t\t\t&eap->arg, NULL, NULL);\n\t    if (cmd[0] == delimiter)\t    // end delimiter found\n\t\t*cmd++ = NUL;\t\t    // replace it with a NUL\n\t}\n\n\t/*\n\t * Small incompatibility: vi sees '\\n' as end of the command, but in\n\t * Vim we want to use '\\n' to find/substitute a NUL.\n\t */\n\tsub = cmd;\t    // remember the start of the substitution\n\tcmd = skip_substitute(cmd, delimiter);\n\n\tif (!eap->skip)\n\t{\n\t    // In POSIX vi \":s/pat/%/\" uses the previous subst. string.\n\t    if (STRCMP(sub, \"%\") == 0\n\t\t\t\t && vim_strchr(p_cpo, CPO_SUBPERCENT) != NULL)\n\t    {\n\t\tif (old_sub == NULL)\t// there is no previous command\n\t\t{\n\t\t    emsg(_(e_no_previous_substitute_regular_expression));\n\t\t    return;\n\t\t}\n\t\tsub = old_sub;\n\t    }\n\t    else\n\t    {\n\t\tvim_free(old_sub);\n\t\told_sub = vim_strsave(sub);\n\t    }\n\t}\n    }\n    else if (!eap->skip)\t// use previous pattern and substitution\n    {\n\tif (old_sub == NULL)\t// there is no previous command\n\t{\n\t    emsg(_(e_no_previous_substitute_regular_expression));\n\t    return;\n\t}\n\tpat = NULL;\t\t// search_regcomp() will use previous pattern\n\tsub = old_sub;\n\n\t// Vi compatibility quirk: repeating with \":s\" keeps the cursor in the\n\t// last column after using \"$\".\n\tendcolumn = (curwin->w_curswant == MAXCOL);\n    }\n\n    // Recognize \":%s/\\n//\" and turn it into a join command, which is much\n    // more efficient.\n    // TODO: find a generic solution to make line-joining operations more\n    // efficient, avoid allocating a string that grows in size.\n    if (pat != NULL && STRCMP(pat, \"\\\\n\") == 0\n\t    && *sub == NUL\n\t    && (*cmd == NUL || (cmd[1] == NUL && (*cmd == 'g' || *cmd == 'l'\n\t\t\t\t\t     || *cmd == 'p' || *cmd == '#'))))\n    {\n\tlinenr_T    joined_lines_count;\n\n\tif (eap->skip)\n\t    return;\n\tcurwin->w_cursor.lnum = eap->line1;\n\tif (*cmd == 'l')\n\t    eap->flags = EXFLAG_LIST;\n\telse if (*cmd == '#')\n\t    eap->flags = EXFLAG_NR;\n\telse if (*cmd == 'p')\n\t    eap->flags = EXFLAG_PRINT;\n\n\t// The number of lines joined is the number of lines in the range plus\n\t// one.  One less when the last line is included.\n\tjoined_lines_count = eap->line2 - eap->line1 + 1;\n\tif (eap->line2 < curbuf->b_ml.ml_line_count)\n\t    ++joined_lines_count;\n\tif (joined_lines_count > 1)\n\t{\n\t    (void)do_join(joined_lines_count, FALSE, TRUE, FALSE, TRUE);\n\t    sub_nsubs = joined_lines_count - 1;\n\t    sub_nlines = 1;\n\t    (void)do_sub_msg(FALSE);\n\t    ex_may_print(eap);\n\t}\n\n\tif ((cmdmod.cmod_flags & CMOD_KEEPPATTERNS) == 0)\n\t    save_re_pat(RE_SUBST, pat, magic_isset());\n\t// put pattern in history\n\tadd_to_history(HIST_SEARCH, pat, TRUE, NUL);\n\n\treturn;\n    }\n\n    /*\n     * Find trailing options.  When '&' is used, keep old options.\n     */\n    if (*cmd == '&')\n\t++cmd;\n    else\n    {\n#ifdef FEAT_EVAL\n\tif (in_vim9script())\n\t{\n\t    // ignore 'gdefault' and 'edcompatible'\n\t    subflags.do_all = FALSE;\n\t    subflags.do_ask = FALSE;\n\t}\n\telse\n#endif\n\tif (!p_ed)\n\t{\n\t    if (p_gd)\t\t// default is global on\n\t\tsubflags.do_all = TRUE;\n\t    else\n\t\tsubflags.do_all = FALSE;\n\t    subflags.do_ask = FALSE;\n\t}\n\tsubflags.do_error = TRUE;\n\tsubflags.do_print = FALSE;\n\tsubflags.do_list = FALSE;\n\tsubflags.do_count = FALSE;\n\tsubflags.do_number = FALSE;\n\tsubflags.do_ic = 0;\n    }\n    while (*cmd)\n    {\n\t/*\n\t * Note that 'g' and 'c' are always inverted, also when p_ed is off.\n\t * 'r' is never inverted.\n\t */\n\tif (*cmd == 'g')\n\t    subflags.do_all = !subflags.do_all;\n\telse if (*cmd == 'c')\n\t    subflags.do_ask = !subflags.do_ask;\n\telse if (*cmd == 'n')\n\t    subflags.do_count = TRUE;\n\telse if (*cmd == 'e')\n\t    subflags.do_error = !subflags.do_error;\n\telse if (*cmd == 'r')\t    // use last used regexp\n\t    which_pat = RE_LAST;\n\telse if (*cmd == 'p')\n\t    subflags.do_print = TRUE;\n\telse if (*cmd == '#')\n\t{\n\t    subflags.do_print = TRUE;\n\t    subflags.do_number = TRUE;\n\t}\n\telse if (*cmd == 'l')\n\t{\n\t    subflags.do_print = TRUE;\n\t    subflags.do_list = TRUE;\n\t}\n\telse if (*cmd == 'i')\t    // ignore case\n\t    subflags.do_ic = 'i';\n\telse if (*cmd == 'I')\t    // don't ignore case\n\t    subflags.do_ic = 'I';\n\telse\n\t    break;\n\t++cmd;\n    }\n    if (subflags.do_count)\n\tsubflags.do_ask = FALSE;\n\n    save_do_all = subflags.do_all;\n    save_do_ask = subflags.do_ask;\n\n    /*\n     * check for a trailing count\n     */\n    cmd = skipwhite(cmd);\n    if (VIM_ISDIGIT(*cmd))\n    {\n\ti = getdigits(&cmd);\n\tif (i <= 0 && !eap->skip && subflags.do_error)\n\t{\n\t    emsg(_(e_positive_count_required));\n\t    return;\n\t}\n\teap->line1 = eap->line2;\n\teap->line2 += i - 1;\n\tif (eap->line2 > curbuf->b_ml.ml_line_count)\n\t    eap->line2 = curbuf->b_ml.ml_line_count;\n    }\n\n    /*\n     * check for trailing command or garbage\n     */\n    cmd = skipwhite(cmd);\n    if (*cmd && *cmd != '\"')\t    // if not end-of-line or comment\n    {\n\tset_nextcmd(eap, cmd);\n\tif (eap->nextcmd == NULL)\n\t{\n\t    semsg(_(e_trailing_characters_str), cmd);\n\t    return;\n\t}\n    }\n\n    if (eap->skip)\t    // not executing commands, only parsing\n\treturn;\n\n    if (!subflags.do_count && !curbuf->b_p_ma)\n    {\n\t// Substitution is not allowed in non-'modifiable' buffer\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n\treturn;\n    }\n\n    if (search_regcomp(pat, RE_SUBST, which_pat, SEARCH_HIS, &regmatch) == FAIL)\n    {\n\tif (subflags.do_error)\n\t    emsg(_(e_invalid_command));\n\treturn;\n    }\n\n    // the 'i' or 'I' flag overrules 'ignorecase' and 'smartcase'\n    if (subflags.do_ic == 'i')\n\tregmatch.rmm_ic = TRUE;\n    else if (subflags.do_ic == 'I')\n\tregmatch.rmm_ic = FALSE;\n\n    sub_firstline = NULL;\n\n    /*\n     * If the substitute pattern starts with \"\\=\" then it's an expression.\n     * Make a copy, a recursive function may free it.\n     * Otherwise, '~' in the substitute pattern is replaced with the old\n     * pattern.  We do it here once to avoid it to be replaced over and over\n     * again.\n     */\n    if (sub[0] == '\\\\' && sub[1] == '=')\n    {\n\tsub = vim_strsave(sub);\n\tif (sub == NULL)\n\t    return;\n\tsub_copy = sub;\n    }\n    else\n\tsub = regtilde(sub, magic_isset());\n\n    /*\n     * Check for a match on each line.\n     */\n    line2 = eap->line2;\n    for (lnum = eap->line1; lnum <= line2 && !(got_quit\n#if defined(FEAT_EVAL)\n\t\t|| aborting()\n#endif\n\t\t); ++lnum)\n    {\n\tnmatch = vim_regexec_multi(&regmatch, curwin, curbuf, lnum,\n\t\t\t\t\t\t       (colnr_T)0, NULL, NULL);\n\tif (nmatch)\n\t{\n\t    colnr_T\tcopycol;\n\t    colnr_T\tmatchcol;\n\t    colnr_T\tprev_matchcol = MAXCOL;\n\t    char_u\t*new_end, *new_start = NULL;\n\t    unsigned\tnew_start_len = 0;\n\t    char_u\t*p1;\n\t    int\t\tdid_sub = FALSE;\n\t    int\t\tlastone;\n\t    int\t\tlen, copy_len, needed_len;\n\t    long\tnmatch_tl = 0;\t// nr of lines matched below lnum\n\t    int\t\tdo_again;\t// do it again after joining lines\n\t    int\t\tskip_match = FALSE;\n\t    linenr_T\tsub_firstlnum;\t// nr of first sub line\n#ifdef FEAT_PROP_POPUP\n\t    int\t\tapc_flags = APC_SAVE_FOR_UNDO | APC_SUBSTITUTE;\n\t    colnr_T\ttotal_added =  0;\n#endif\n\n\t    /*\n\t     * The new text is build up step by step, to avoid too much\n\t     * copying.  There are these pieces:\n\t     * sub_firstline\tThe old text, unmodified.\n\t     * copycol\t\tColumn in the old text where we started\n\t     *\t\t\tlooking for a match; from here old text still\n\t     *\t\t\tneeds to be copied to the new text.\n\t     * matchcol\t\tColumn number of the old text where to look\n\t     *\t\t\tfor the next match.  It's just after the\n\t     *\t\t\tprevious match or one further.\n\t     * prev_matchcol\tColumn just after the previous match (if any).\n\t     *\t\t\tMostly equal to matchcol, except for the first\n\t     *\t\t\tmatch and after skipping an empty match.\n\t     * regmatch.*pos\tWhere the pattern matched in the old text.\n\t     * new_start\tThe new text, all that has been produced so\n\t     *\t\t\tfar.\n\t     * new_end\t\tThe new text, where to append new text.\n\t     *\n\t     * lnum\t\tThe line number where we found the start of\n\t     *\t\t\tthe match.  Can be below the line we searched\n\t     *\t\t\twhen there is a \\n before a \\zs in the\n\t     *\t\t\tpattern.\n\t     * sub_firstlnum\tThe line number in the buffer where to look\n\t     *\t\t\tfor a match.  Can be different from \"lnum\"\n\t     *\t\t\twhen the pattern or substitute string contains\n\t     *\t\t\tline breaks.\n\t     *\n\t     * Special situations:\n\t     * - When the substitute string contains a line break, the part up\n\t     *   to the line break is inserted in the text, but the copy of\n\t     *   the original line is kept.  \"sub_firstlnum\" is adjusted for\n\t     *   the inserted lines.\n\t     * - When the matched pattern contains a line break, the old line\n\t     *   is taken from the line at the end of the pattern.  The lines\n\t     *   in the match are deleted later, \"sub_firstlnum\" is adjusted\n\t     *   accordingly.\n\t     *\n\t     * The new text is built up in new_start[].  It has some extra\n\t     * room to avoid using alloc()/free() too often.  new_start_len is\n\t     * the length of the allocated memory at new_start.\n\t     *\n\t     * Make a copy of the old line, so it won't be taken away when\n\t     * updating the screen or handling a multi-line match.  The \"old_\"\n\t     * pointers point into this copy.\n\t     */\n\t    sub_firstlnum = lnum;\n\t    copycol = 0;\n\t    matchcol = 0;\n\n\t    // At first match, remember current cursor position.\n\t    if (!got_match)\n\t    {\n\t\tsetpcmark();\n\t\tgot_match = TRUE;\n\t    }\n\n\t    /*\n\t     * Loop until nothing more to replace in this line.\n\t     * 1. Handle match with empty string.\n\t     * 2. If do_ask is set, ask for confirmation.\n\t     * 3. substitute the string.\n\t     * 4. if do_all is set, find next match\n\t     * 5. break if there isn't another match in this line\n\t     */\n\t    for (;;)\n\t    {\n\t\t// Advance \"lnum\" to the line where the match starts.  The\n\t\t// match does not start in the first line when there is a line\n\t\t// break before \\zs.\n\t\tif (regmatch.startpos[0].lnum > 0)\n\t\t{\n\t\t    lnum += regmatch.startpos[0].lnum;\n\t\t    sub_firstlnum += regmatch.startpos[0].lnum;\n\t\t    nmatch -= regmatch.startpos[0].lnum;\n\t\t    VIM_CLEAR(sub_firstline);\n\t\t}\n\n\t\t// Match might be after the last line for \"\\n\\zs\" matching at\n\t\t// the end of the last line.\n\t\tif (lnum > curbuf->b_ml.ml_line_count)\n\t\t    break;\n\n\t\tif (sub_firstline == NULL)\n\t\t{\n\t\t    sub_firstline = vim_strsave(ml_get(sub_firstlnum));\n\t\t    if (sub_firstline == NULL)\n\t\t    {\n\t\t\tvim_free(new_start);\n\t\t\tgoto outofmem;\n\t\t    }\n\t\t}\n\n\t\t// Save the line number of the last change for the final\n\t\t// cursor position (just like Vi).\n\t\tcurwin->w_cursor.lnum = lnum;\n\t\tdo_again = FALSE;\n\n\t\t/*\n\t\t * 1. Match empty string does not count, except for first\n\t\t * match.  This reproduces the strange vi behaviour.\n\t\t * This also catches endless loops.\n\t\t */\n\t\tif (matchcol == prev_matchcol\n\t\t\t&& regmatch.endpos[0].lnum == 0\n\t\t\t&& matchcol == regmatch.endpos[0].col)\n\t\t{\n\t\t    if (sub_firstline[matchcol] == NUL)\n\t\t\t// We already were at the end of the line.  Don't look\n\t\t\t// for a match in this line again.\n\t\t\tskip_match = TRUE;\n\t\t    else\n\t\t    {\n\t\t\t // search for a match at next column\n\t\t\tif (has_mbyte)\n\t\t\t    matchcol += mb_ptr2len(sub_firstline + matchcol);\n\t\t\telse\n\t\t\t    ++matchcol;\n\t\t    }\n\t\t    goto skip;\n\t\t}\n\n\t\t// Normally we continue searching for a match just after the\n\t\t// previous match.\n\t\tmatchcol = regmatch.endpos[0].col;\n\t\tprev_matchcol = matchcol;\n\n\t\t/*\n\t\t * 2. If do_count is set only increase the counter.\n\t\t *    If do_ask is set, ask for confirmation.\n\t\t */\n\t\tif (subflags.do_count)\n\t\t{\n\t\t    // For a multi-line match, put matchcol at the NUL at\n\t\t    // the end of the line and set nmatch to one, so that\n\t\t    // we continue looking for a match on the next line.\n\t\t    // Avoids that \":s/\\nB\\@=//gc\" get stuck.\n\t\t    if (nmatch > 1)\n\t\t    {\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline);\n\t\t\tnmatch = 1;\n\t\t\tskip_match = TRUE;\n\t\t    }\n\t\t    sub_nsubs++;\n\t\t    did_sub = TRUE;\n#ifdef FEAT_EVAL\n\t\t    // Skip the substitution, unless an expression is used,\n\t\t    // then it is evaluated in the sandbox.\n\t\t    if (!(sub[0] == '\\\\' && sub[1] == '='))\n#endif\n\t\t\tgoto skip;\n\t\t}\n\n\t\tif (subflags.do_ask)\n\t\t{\n\t\t    int typed = 0;\n\n\t\t    // change State to CONFIRM, so that the mouse works\n\t\t    // properly\n\t\t    save_State = State;\n\t\t    State = CONFIRM;\n\t\t    setmouse();\t\t// disable mouse in xterm\n\t\t    curwin->w_cursor.col = regmatch.startpos[0].col;\n\t\t    if (curwin->w_p_crb)\n\t\t\tdo_check_cursorbind();\n\n\t\t    // When 'cpoptions' contains \"u\" don't sync undo when\n\t\t    // asking for confirmation.\n\t\t    if (vim_strchr(p_cpo, CPO_UNDO) != NULL)\n\t\t\t++no_u_sync;\n\n\t\t    /*\n\t\t     * Loop until 'y', 'n', 'q', CTRL-E or CTRL-Y typed.\n\t\t     */\n\t\t    while (subflags.do_ask)\n\t\t    {\n\t\t\tif (exmode_active)\n\t\t\t{\n\t\t\t    char_u\t*resp;\n\t\t\t    colnr_T\tsc, ec;\n\n\t\t\t    print_line_no_prefix(lnum,\n\t\t\t\t\t subflags.do_number, subflags.do_list);\n\n\t\t\t    getvcol(curwin, &curwin->w_cursor, &sc, NULL, NULL);\n\t\t\t    curwin->w_cursor.col = regmatch.endpos[0].col - 1;\n\t\t\t    if (curwin->w_cursor.col < 0)\n\t\t\t\tcurwin->w_cursor.col = 0;\n\t\t\t    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &ec);\n\t\t\t    curwin->w_cursor.col = regmatch.startpos[0].col;\n\t\t\t    if (subflags.do_number || curwin->w_p_nu)\n\t\t\t    {\n\t\t\t\tint numw = number_width(curwin) + 1;\n\t\t\t\tsc += numw;\n\t\t\t\tec += numw;\n\t\t\t    }\n\t\t\t    msg_start();\n\t\t\t    for (i = 0; i < (long)sc; ++i)\n\t\t\t\tmsg_putchar(' ');\n\t\t\t    for ( ; i <= (long)ec; ++i)\n\t\t\t\tmsg_putchar('^');\n\n\t\t\t    resp = getexmodeline('?', NULL, 0, TRUE);\n\t\t\t    if (resp != NULL)\n\t\t\t    {\n\t\t\t\ttyped = *resp;\n\t\t\t\tvim_free(resp);\n\t\t\t    }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    char_u *orig_line = NULL;\n\t\t\t    int    len_change = 0;\n\t\t\t    int\t   save_p_lz = p_lz;\n#ifdef FEAT_FOLDING\n\t\t\t    int save_p_fen = curwin->w_p_fen;\n\n\t\t\t    curwin->w_p_fen = FALSE;\n#endif\n\t\t\t    // Invert the matched string.\n\t\t\t    // Remove the inversion afterwards.\n\t\t\t    temp = RedrawingDisabled;\n\t\t\t    RedrawingDisabled = 0;\n\n\t\t\t    // avoid calling update_screen() in vgetorpeek()\n\t\t\t    p_lz = FALSE;\n\n\t\t\t    if (new_start != NULL)\n\t\t\t    {\n\t\t\t\t// There already was a substitution, we would\n\t\t\t\t// like to show this to the user.  We cannot\n\t\t\t\t// really update the line, it would change\n\t\t\t\t// what matches.  Temporarily replace the line\n\t\t\t\t// and change it back afterwards.\n\t\t\t\torig_line = vim_strsave(ml_get(lnum));\n\t\t\t\tif (orig_line != NULL)\n\t\t\t\t{\n\t\t\t\t    char_u *new_line = concat_str(new_start,\n\t\t\t\t\t\t     sub_firstline + copycol);\n\n\t\t\t\t    if (new_line == NULL)\n\t\t\t\t\tVIM_CLEAR(orig_line);\n\t\t\t\t    else\n\t\t\t\t    {\n\t\t\t\t\t// Position the cursor relative to the\n\t\t\t\t\t// end of the line, the previous\n\t\t\t\t\t// substitute may have inserted or\n\t\t\t\t\t// deleted characters before the\n\t\t\t\t\t// cursor.\n\t\t\t\t\tlen_change = (int)STRLEN(new_line)\n\t\t\t\t\t\t     - (int)STRLEN(orig_line);\n\t\t\t\t\tcurwin->w_cursor.col += len_change;\n\t\t\t\t\tml_replace(lnum, new_line, FALSE);\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t    search_match_lines = regmatch.endpos[0].lnum\n\t\t\t\t\t\t  - regmatch.startpos[0].lnum;\n\t\t\t    search_match_endcol = regmatch.endpos[0].col\n\t\t\t\t\t\t\t\t + len_change;\n\t\t\t    highlight_match = TRUE;\n\n\t\t\t    update_topline();\n\t\t\t    validate_cursor();\n\t\t\t    update_screen(SOME_VALID);\n\t\t\t    highlight_match = FALSE;\n\t\t\t    redraw_later(SOME_VALID);\n\n#ifdef FEAT_FOLDING\n\t\t\t    curwin->w_p_fen = save_p_fen;\n#endif\n\t\t\t    if (msg_row == Rows - 1)\n\t\t\t\tmsg_didout = FALSE;\t// avoid a scroll-up\n\t\t\t    msg_starthere();\n\t\t\t    i = msg_scroll;\n\t\t\t    msg_scroll = 0;\t\t// truncate msg when\n\t\t\t\t\t\t\t// needed\n\t\t\t    msg_no_more = TRUE;\n\t\t\t    // write message same highlighting as for\n\t\t\t    // wait_return\n\t\t\t    smsg_attr(HL_ATTR(HLF_R),\n\t\t\t\t_(\"replace with %s (y/n/a/q/l/^E/^Y)?\"), sub);\n\t\t\t    msg_no_more = FALSE;\n\t\t\t    msg_scroll = i;\n\t\t\t    showruler(TRUE);\n\t\t\t    windgoto(msg_row, msg_col);\n\t\t\t    RedrawingDisabled = temp;\n\n#ifdef USE_ON_FLY_SCROLL\n\t\t\t    dont_scroll = FALSE; // allow scrolling here\n#endif\n\t\t\t    ++no_mapping;\t// don't map this key\n\t\t\t    ++allow_keys;\t// allow special keys\n\t\t\t    typed = plain_vgetc();\n\t\t\t    --allow_keys;\n\t\t\t    --no_mapping;\n\n\t\t\t    // clear the question\n\t\t\t    msg_didout = FALSE;\t// don't scroll up\n\t\t\t    msg_col = 0;\n\t\t\t    gotocmdline(TRUE);\n\t\t\t    p_lz = save_p_lz;\n\n\t\t\t    // restore the line\n\t\t\t    if (orig_line != NULL)\n\t\t\t\tml_replace(lnum, orig_line, FALSE);\n\t\t\t}\n\n\t\t\tneed_wait_return = FALSE; // no hit-return prompt\n\t\t\tif (typed == 'q' || typed == ESC || typed == Ctrl_C\n#ifdef UNIX\n\t\t\t\t|| typed == intr_char\n#endif\n\t\t\t\t)\n\t\t\t{\n\t\t\t    got_quit = TRUE;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == 'n')\n\t\t\t    break;\n\t\t\tif (typed == 'y')\n\t\t\t    break;\n\t\t\tif (typed == 'l')\n\t\t\t{\n\t\t\t    // last: replace and then stop\n\t\t\t    subflags.do_all = FALSE;\n\t\t\t    line2 = lnum;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == 'a')\n\t\t\t{\n\t\t\t    subflags.do_ask = FALSE;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == Ctrl_E)\n\t\t\t    scrollup_clamp();\n\t\t\telse if (typed == Ctrl_Y)\n\t\t\t    scrolldown_clamp();\n\t\t    }\n\t\t    State = save_State;\n\t\t    setmouse();\n\t\t    if (vim_strchr(p_cpo, CPO_UNDO) != NULL)\n\t\t\t--no_u_sync;\n\n\t\t    if (typed == 'n')\n\t\t    {\n\t\t\t// For a multi-line match, put matchcol at the NUL at\n\t\t\t// the end of the line and set nmatch to one, so that\n\t\t\t// we continue looking for a match on the next line.\n\t\t\t// Avoids that \":%s/\\nB\\@=//gc\" and \":%s/\\n/,\\r/gc\"\n\t\t\t// get stuck when pressing 'n'.\n\t\t\tif (nmatch > 1)\n\t\t\t{\n\t\t\t    matchcol = (colnr_T)STRLEN(sub_firstline);\n\t\t\t    skip_match = TRUE;\n\t\t\t}\n\t\t\tgoto skip;\n\t\t    }\n\t\t    if (got_quit)\n\t\t\tgoto skip;\n\t\t}\n\n\t\t// Move the cursor to the start of the match, so that we can\n\t\t// use \"\\=col(\".\").\n\t\tcurwin->w_cursor.col = regmatch.startpos[0].col;\n\n\t\t/*\n\t\t * 3. substitute the string.\n\t\t */\n#ifdef FEAT_EVAL\n\t\tsave_ma = curbuf->b_p_ma;\n\t\tif (subflags.do_count)\n\t\t{\n\t\t    // prevent accidentally changing the buffer by a function\n\t\t    curbuf->b_p_ma = FALSE;\n\t\t    sandbox++;\n\t\t}\n\t\t// Save flags for recursion.  They can change for e.g.\n\t\t// :s/^/\\=execute(\"s#^##gn\")\n\t\tsubflags_save = subflags;\n#endif\n\t\t// get length of substitution part\n\t\tsublen = vim_regsub_multi(&regmatch,\n\t\t\t\t    sub_firstlnum - regmatch.startpos[0].lnum,\n\t\t\t       sub, sub_firstline, FALSE, magic_isset(), TRUE);\n#ifdef FEAT_EVAL\n\t\t// If getting the substitute string caused an error, don't do\n\t\t// the replacement.\n\t\t// Don't keep flags set by a recursive call.\n\t\tsubflags = subflags_save;\n\t\tif (aborting() || subflags.do_count)\n\t\t{\n\t\t    curbuf->b_p_ma = save_ma;\n\t\t    if (sandbox > 0)\n\t\t\tsandbox--;\n\t\t    goto skip;\n\t\t}\n#endif\n\n\t\t// When the match included the \"$\" of the last line it may\n\t\t// go beyond the last line of the buffer.\n\t\tif (nmatch > curbuf->b_ml.ml_line_count - sub_firstlnum + 1)\n\t\t{\n\t\t    nmatch = curbuf->b_ml.ml_line_count - sub_firstlnum + 1;\n\t\t    skip_match = TRUE;\n\t\t}\n\n\t\t// Need room for:\n\t\t// - result so far in new_start (not for first sub in line)\n\t\t// - original text up to match\n\t\t// - length of substituted part\n\t\t// - original text after match\n\t\t// Adjust text properties here, since we have all information\n\t\t// needed.\n\t\tif (nmatch == 1)\n\t\t{\n\t\t    p1 = sub_firstline;\n#ifdef FEAT_PROP_POPUP\n\t\t    if (curbuf->b_has_textprop)\n\t\t    {\n\t\t\tint bytes_added = sublen - 1 - (regmatch.endpos[0].col\n\t\t\t\t\t\t   - regmatch.startpos[0].col);\n\n\t\t\t// When text properties are changed, need to save for\n\t\t\t// undo first, unless done already.\n\t\t\tif (adjust_prop_columns(lnum,\n\t\t\t\t\ttotal_added + regmatch.startpos[0].col,\n\t\t\t\t\t\t       bytes_added, apc_flags))\n\t\t\t    apc_flags &= ~APC_SAVE_FOR_UNDO;\n\t\t\t// Offset for column byte number of the text property\n\t\t\t// in the resulting buffer afterwards.\n\t\t\ttotal_added += bytes_added;\n\t\t    }\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t    p1 = ml_get(sub_firstlnum + nmatch - 1);\n\t\t    nmatch_tl += nmatch - 1;\n\t\t}\n\t\tcopy_len = regmatch.startpos[0].col - copycol;\n\t\tneeded_len = copy_len + ((unsigned)STRLEN(p1)\n\t\t\t\t       - regmatch.endpos[0].col) + sublen + 1;\n\t\tif (new_start == NULL)\n\t\t{\n\t\t    /*\n\t\t     * Get some space for a temporary buffer to do the\n\t\t     * substitution into (and some extra space to avoid\n\t\t     * too many calls to alloc()/free()).\n\t\t     */\n\t\t    new_start_len = needed_len + 50;\n\t\t    if ((new_start = alloc(new_start_len)) == NULL)\n\t\t\tgoto outofmem;\n\t\t    *new_start = NUL;\n\t\t    new_end = new_start;\n\t\t}\n\t\telse\n\t\t{\n\t\t    /*\n\t\t     * Check if the temporary buffer is long enough to do the\n\t\t     * substitution into.  If not, make it larger (with a bit\n\t\t     * extra to avoid too many calls to alloc()/free()).\n\t\t     */\n\t\t    len = (unsigned)STRLEN(new_start);\n\t\t    needed_len += len;\n\t\t    if (needed_len > (int)new_start_len)\n\t\t    {\n\t\t\tnew_start_len = needed_len + 50;\n\t\t\tif ((p1 = alloc(new_start_len)) == NULL)\n\t\t\t{\n\t\t\t    vim_free(new_start);\n\t\t\t    goto outofmem;\n\t\t\t}\n\t\t\tmch_memmove(p1, new_start, (size_t)(len + 1));\n\t\t\tvim_free(new_start);\n\t\t\tnew_start = p1;\n\t\t    }\n\t\t    new_end = new_start + len;\n\t\t}\n\n\t\t/*\n\t\t * copy the text up to the part that matched\n\t\t */\n\t\tmch_memmove(new_end, sub_firstline + copycol, (size_t)copy_len);\n\t\tnew_end += copy_len;\n\n\t\t(void)vim_regsub_multi(&regmatch,\n\t\t\t\t    sub_firstlnum - regmatch.startpos[0].lnum,\n\t\t\t\t      sub, new_end, TRUE, magic_isset(), TRUE);\n\t\tsub_nsubs++;\n\t\tdid_sub = TRUE;\n\n\t\t// Move the cursor to the start of the line, to avoid that it\n\t\t// is beyond the end of the line after the substitution.\n\t\tcurwin->w_cursor.col = 0;\n\n\t\t// For a multi-line match, make a copy of the last matched\n\t\t// line and continue in that one.\n\t\tif (nmatch > 1)\n\t\t{\n\t\t    sub_firstlnum += nmatch - 1;\n\t\t    vim_free(sub_firstline);\n\t\t    sub_firstline = vim_strsave(ml_get(sub_firstlnum));\n\t\t    // When going beyond the last line, stop substituting.\n\t\t    if (sub_firstlnum <= line2)\n\t\t\tdo_again = TRUE;\n\t\t    else\n\t\t\tsubflags.do_all = FALSE;\n\t\t}\n\n\t\t// Remember next character to be copied.\n\t\tcopycol = regmatch.endpos[0].col;\n\n\t\tif (skip_match)\n\t\t{\n\t\t    // Already hit end of the buffer, sub_firstlnum is one\n\t\t    // less than what it ought to be.\n\t\t    vim_free(sub_firstline);\n\t\t    sub_firstline = vim_strsave((char_u *)\"\");\n\t\t    copycol = 0;\n\t\t}\n\n\t\t/*\n\t\t * Now the trick is to replace CTRL-M chars with a real line\n\t\t * break.  This would make it impossible to insert a CTRL-M in\n\t\t * the text.  The line break can be avoided by preceding the\n\t\t * CTRL-M with a backslash.  To be able to insert a backslash,\n\t\t * they must be doubled in the string and are halved here.\n\t\t * That is Vi compatible.\n\t\t */\n\t\tfor (p1 = new_end; *p1; ++p1)\n\t\t{\n\t\t    if (p1[0] == '\\\\' && p1[1] != NUL)  // remove backslash\n\t\t    {\n\t\t\tSTRMOVE(p1, p1 + 1);\n#ifdef FEAT_PROP_POPUP\n\t\t\tif (curbuf->b_has_textprop)\n\t\t\t{\n\t\t\t    // When text properties are changed, need to save\n\t\t\t    // for undo first, unless done already.\n\t\t\t    if (adjust_prop_columns(lnum,\n\t\t\t\t\t(colnr_T)(p1 - new_start), -1,\n\t\t\t\t\tapc_flags))\n\t\t\t\tapc_flags &= ~APC_SAVE_FOR_UNDO;\n\t\t\t}\n#endif\n\t\t    }\n\t\t    else if (*p1 == CAR)\n\t\t    {\n\t\t\tif (u_inssub(lnum) == OK)   // prepare for undo\n\t\t\t{\n\t\t\t    colnr_T\tplen = (colnr_T)(p1 - new_start + 1);\n\n\t\t\t    *p1 = NUL;\t\t    // truncate up to the CR\n\t\t\t    ml_append(lnum - 1, new_start, plen, FALSE);\n\t\t\t    mark_adjust(lnum + 1, (linenr_T)MAXLNUM, 1L, 0L);\n\t\t\t    if (subflags.do_ask)\n\t\t\t\tappended_lines(lnum - 1, 1L);\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tif (first_line == 0)\n\t\t\t\t    first_line = lnum;\n\t\t\t\tlast_line = lnum + 1;\n\t\t\t    }\n#ifdef FEAT_PROP_POPUP\n\t\t\t    adjust_props_for_split(lnum + 1, lnum, plen, 1);\n#endif\n\t\t\t    // all line numbers increase\n\t\t\t    ++sub_firstlnum;\n\t\t\t    ++lnum;\n\t\t\t    ++line2;\n\t\t\t    // move the cursor to the new line, like Vi\n\t\t\t    ++curwin->w_cursor.lnum;\n\t\t\t    // copy the rest\n\t\t\t    STRMOVE(new_start, p1 + 1);\n\t\t\t    p1 = new_start - 1;\n\t\t\t}\n\t\t    }\n\t\t    else if (has_mbyte)\n\t\t\tp1 += (*mb_ptr2len)(p1) - 1;\n\t\t}\n\n\t\t/*\n\t\t * 4. If do_all is set, find next match.\n\t\t * Prevent endless loop with patterns that match empty\n\t\t * strings, e.g. :s/$/pat/g or :s/[a-z]* /(&)/g.\n\t\t * But \":s/\\n/#/\" is OK.\n\t\t */\nskip:\n\t\t// We already know that we did the last subst when we are at\n\t\t// the end of the line, except that a pattern like\n\t\t// \"bar\\|\\nfoo\" may match at the NUL.  \"lnum\" can be below\n\t\t// \"line2\" when there is a \\zs in the pattern after a line\n\t\t// break.\n\t\tlastone = (skip_match\n\t\t\t|| got_int\n\t\t\t|| got_quit\n\t\t\t|| lnum > line2\n\t\t\t|| !(subflags.do_all || do_again)\n\t\t\t|| (sub_firstline[matchcol] == NUL && nmatch <= 1\n\t\t\t\t\t && !re_multiline(regmatch.regprog)));\n\t\tnmatch = -1;\n\n\t\t/*\n\t\t * Replace the line in the buffer when needed.  This is\n\t\t * skipped when there are more matches.\n\t\t * The check for nmatch_tl is needed for when multi-line\n\t\t * matching must replace the lines before trying to do another\n\t\t * match, otherwise \"\\@<=\" won't work.\n\t\t * When the match starts below where we start searching also\n\t\t * need to replace the line first (using \\zs after \\n).\n\t\t */\n\t\tif (lastone\n\t\t\t|| nmatch_tl > 0\n\t\t\t|| (nmatch = vim_regexec_multi(&regmatch, curwin,\n\t\t\t\t\t\t\tcurbuf, sub_firstlnum,\n\t\t\t\t\t\t    matchcol, NULL, NULL)) == 0\n\t\t\t|| regmatch.startpos[0].lnum > 0)\n\t\t{\n\t\t    if (new_start != NULL)\n\t\t    {\n\t\t\t/*\n\t\t\t * Copy the rest of the line, that didn't match.\n\t\t\t * \"matchcol\" has to be adjusted, we use the end of\n\t\t\t * the line as reference, because the substitute may\n\t\t\t * have changed the number of characters.  Same for\n\t\t\t * \"prev_matchcol\".\n\t\t\t */\n\t\t\tSTRCAT(new_start, sub_firstline + copycol);\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline) - matchcol;\n\t\t\tprev_matchcol = (colnr_T)STRLEN(sub_firstline)\n\t\t\t\t\t\t\t      - prev_matchcol;\n\n\t\t\tif (u_savesub(lnum) != OK)\n\t\t\t    break;\n\t\t\tml_replace(lnum, new_start, TRUE);\n\n\t\t\tif (nmatch_tl > 0)\n\t\t\t{\n\t\t\t    /*\n\t\t\t     * Matched lines have now been substituted and are\n\t\t\t     * useless, delete them.  The part after the match\n\t\t\t     * has been appended to new_start, we don't need\n\t\t\t     * it in the buffer.\n\t\t\t     */\n\t\t\t    ++lnum;\n\t\t\t    if (u_savedel(lnum, nmatch_tl) != OK)\n\t\t\t\tbreak;\n\t\t\t    for (i = 0; i < nmatch_tl; ++i)\n\t\t\t\tml_delete(lnum);\n\t\t\t    mark_adjust(lnum, lnum + nmatch_tl - 1,\n\t\t\t\t\t\t   (long)MAXLNUM, -nmatch_tl);\n\t\t\t    if (subflags.do_ask)\n\t\t\t\tdeleted_lines(lnum, nmatch_tl);\n\t\t\t    --lnum;\n\t\t\t    line2 -= nmatch_tl; // nr of lines decreases\n\t\t\t    nmatch_tl = 0;\n\t\t\t}\n\n\t\t\t// When asking, undo is saved each time, must also set\n\t\t\t// changed flag each time.\n\t\t\tif (subflags.do_ask)\n\t\t\t    changed_bytes(lnum, 0);\n\t\t\telse\n\t\t\t{\n\t\t\t    if (first_line == 0)\n\t\t\t\tfirst_line = lnum;\n\t\t\t    last_line = lnum + 1;\n\t\t\t}\n\n\t\t\tsub_firstlnum = lnum;\n\t\t\tvim_free(sub_firstline);    // free the temp buffer\n\t\t\tsub_firstline = new_start;\n\t\t\tnew_start = NULL;\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline) - matchcol;\n\t\t\tprev_matchcol = (colnr_T)STRLEN(sub_firstline)\n\t\t\t\t\t\t\t      - prev_matchcol;\n\t\t\tcopycol = 0;\n\t\t    }\n\t\t    if (nmatch == -1 && !lastone)\n\t\t\tnmatch = vim_regexec_multi(&regmatch, curwin, curbuf,\n\t\t\t\t\t  sub_firstlnum, matchcol, NULL, NULL);\n\n\t\t    /*\n\t\t     * 5. break if there isn't another match in this line\n\t\t     */\n\t\t    if (nmatch <= 0)\n\t\t    {\n\t\t\t// If the match found didn't start where we were\n\t\t\t// searching, do the next search in the line where we\n\t\t\t// found the match.\n\t\t\tif (nmatch == -1)\n\t\t\t    lnum -= regmatch.startpos[0].lnum;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t\tline_breakcheck();\n\t    }\n\n\t    if (did_sub)\n\t\t++sub_nlines;\n\t    vim_free(new_start);\t// for when substitute was cancelled\n\t    VIM_CLEAR(sub_firstline);\t// free the copy of the original line\n\t}\n\n\tline_breakcheck();\n    }\n\n    if (first_line != 0)\n    {\n\t// Need to subtract the number of added lines from \"last_line\" to get\n\t// the line number before the change (same as adding the number of\n\t// deleted lines).\n\ti = curbuf->b_ml.ml_line_count - old_line_count;\n\tchanged_lines(first_line, 0, last_line - i, i);\n    }\n\noutofmem:\n    vim_free(sub_firstline); // may have to free allocated copy of the line\n\n    // \":s/pat//n\" doesn't move the cursor\n    if (subflags.do_count)\n\tcurwin->w_cursor = old_cursor;\n\n    if (sub_nsubs > start_nsubs)\n    {\n\tif ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\t{\n\t    // Set the '[ and '] marks.\n\t    curbuf->b_op_start.lnum = eap->line1;\n\t    curbuf->b_op_end.lnum = line2;\n\t    curbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n\t}\n\n\tif (!global_busy)\n\t{\n\t    // when interactive leave cursor on the match\n\t    if (!subflags.do_ask)\n\t    {\n\t\tif (endcolumn)\n\t\t    coladvance((colnr_T)MAXCOL);\n\t\telse\n\t\t    beginline(BL_WHITE | BL_FIX);\n\t    }\n\t    if (!do_sub_msg(subflags.do_count) && subflags.do_ask)\n\t\tmsg(\"\");\n\t}\n\telse\n\t    global_need_beginline = TRUE;\n\tif (subflags.do_print)\n\t    print_line(curwin->w_cursor.lnum,\n\t\t\t\t\t subflags.do_number, subflags.do_list);\n    }\n    else if (!global_busy)\n    {\n\tif (got_int)\t\t// interrupted\n\t    emsg(_(e_interrupted));\n\telse if (got_match)\t// did find something but nothing substituted\n\t    msg(\"\");\n\telse if (subflags.do_error)\t// nothing found\n\t    semsg(_(e_pattern_not_found_str), get_search_pat());\n    }\n\n#ifdef FEAT_FOLDING\n    if (subflags.do_ask && hasAnyFolding(curwin))\n\t// Cursor position may require updating\n\tchanged_window_setting();\n#endif\n\n    vim_regfree(regmatch.regprog);\n    vim_free(sub_copy);\n\n    // Restore the flag values, they can be used for \":&&\".\n    subflags.do_all = save_do_all;\n    subflags.do_ask = save_do_ask;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"version.h\"\n# include <float.h>\n#include \"vim.h\"\n\n// Type Definitions:\n// colnr_T:\ntypedef int\t\tcolnr_T;\n\n// pos_T:\ntypedef struct\n{\n    linenr_T\tlnum;\t// line number\n    colnr_T\tcol;\t// column number\n    colnr_T\tcoladd; // extra virtual column\n}\n\n// linenr_T:\ntypedef long\t\tlinenr_T;\n\n// subflags_T:\ntypedef struct {\n    int\tdo_all;\t\t// do multiple substitutions per line\n    int\tdo_ask;\t\t// ask for confirmation\n    int\tdo_count;\t// count only\n    int\tdo_error;\t// if false, ignore errors\n    int\tdo_print;\t// print last line with subs.\n    int\tdo_list;\t// list last line with subs.\n    int\tdo_number;\t// list last line with line nr\n    int\tdo_ic;\t\t// ignore case flag\n}\n\n// exarg_T:\ntypedef struct exarg exarg_T;\n\n// regmmatch_T:\ntypedef struct\n{\n    regprog_T\t\t*regprog;\n    lpos_T\t\tstartpos[NSUBEXP];\n    lpos_T\t\tendpos[NSUBEXP];\n    int\t\t\trmm_ic;\n    colnr_T\t\trmm_maxcol;\t// when not zero: maximum column\n}\n\n// char_u:\ntypedef unsigned char\tchar_u;\n\n// Called Methods (top 10):\n// foldmethodIsSyntax from src/fold.c:\n    int /* <=== foldmethodIsSyntax */ \nfoldmethodIsSyntax(win_T *wp)\n{\n    return (wp->w_p_fdm[0] == 's');\n}\n\n// ML_LOCKED_DIRTY from src/structs.h:\n#define ML_LOCKED_DIRTY\t4\t// ml_locked was changed /* <=== src/structs.h:762:762:ML_LOCKED_DIRTY:0 */ \n\n// vim_strchr from src/strings.c:\n    char_u  * /* <=== vim_strchr */ \nvim_strchr(char_u *string, int c)\n{\n    char_u\t*p;\n    int\t\tb;\n\n    p = string;\n    if (enc_utf8 && c >= 0x80)\n    {\n\twhile (*p != NUL)\n\t{\n\t    int l = utfc_ptr2len(p);\n\n\t    // Avoid matching an illegal byte here.\n\t    if (utf_ptr2char(p) == c && l > 1)\n\t\treturn p;\n\t    p += l;\n\t}\n\treturn NULL;\n    }\n    if (enc_dbcs != 0 && c > 255)\n    {\n\tint\tn2 = c & 0xff;\n\n\tc = ((unsigned)c >> 8) & 0xff;\n\twhile ((b = *p) != NUL)\n\t{\n\t    if (b == c && p[1] == n2)\n\t\treturn p;\n\t    p += (*mb_ptr2len)(p);\n\t}\n\treturn NULL;\n    }\n    if (has_mbyte)\n    {\n\twhile ((b = *p) != NUL)\n\t{\n\t    if (b == c)\n\t\treturn p;\n\t    p += (*mb_ptr2len)(p);\n\t}\n\treturn NULL;\n    }\n    while ((b = *p) != NUL)\n    {\n\tif (b == c)\n\t    return p;\n\t++p;\n    }\n    return NULL;\n}\n\n// mark_col_adjust from src/mark.c:\n    void /* <=== mark_col_adjust */ \nmark_col_adjust(\n    linenr_T\tlnum,\n    colnr_T\tmincol,\n    long\tlnum_amount,\n    long\tcol_amount,\n    int\t\tspaces_removed)\n{\n    int\t\ti;\n    int\t\tfnum = curbuf->b_fnum;\n    win_T\t*win;\n    pos_T\t*posp;\n\n    if ((col_amount == 0L && lnum_amount == 0L)\n\t\t\t\t       || (cmdmod.cmod_flags & CMOD_LOCKMARKS))\n\treturn; // nothing to do\n\n    // named marks, lower case and upper case\n    for (i = 0; i < NMARKS; i++)\n    {\n\tcol_adjust(&(curbuf->b_namedm[i]));\n\tif (namedfm[i].fmark.fnum == fnum)\n\t    col_adjust(&(namedfm[i].fmark.mark));\n    }\n    for (i = NMARKS; i < NMARKS + EXTRA_MARKS; i++)\n    {\n\tif (namedfm[i].fmark.fnum == fnum)\n\t    col_adjust(&(namedfm[i].fmark.mark));\n    }\n\n    // last Insert position\n    col_adjust(&(curbuf->b_last_insert));\n\n    // last change position\n    col_adjust(&(curbuf->b_last_change));\n\n    // list of change positions\n    for (i = 0; i < curbuf->b_changelistlen; ++i)\n\tcol_adjust(&(curbuf->b_changelist[i]));\n\n    // Visual area\n    col_adjust(&(curbuf->b_visual.vi_start));\n    col_adjust(&(curbuf->b_visual.vi_end));\n\n    // previous context mark\n    col_adjust(&(curwin->w_pcmark));\n\n    // previous pcmark\n    col_adjust(&(curwin->w_prev_pcmark));\n\n    // saved cursor for formatting\n    col_adjust(&saved_cursor);\n\n    /*\n     * Adjust items in all windows related to the current buffer.\n     */\n    FOR_ALL_WINDOWS(win)\n    {\n\t// marks in the jumplist\n\tfor (i = 0; i < win->w_jumplistlen; ++i)\n\t    if (win->w_jumplist[i].fmark.fnum == fnum)\n\t\tcol_adjust(&(win->w_jumplist[i].fmark.mark));\n\n\tif (win->w_buffer == curbuf)\n\t{\n\t    // marks in the tag stack\n\t    for (i = 0; i < win->w_tagstacklen; i++)\n\t\tif (win->w_tagstack[i].fmark.fnum == fnum)\n\t\t    col_adjust(&(win->w_tagstack[i].fmark.mark));\n\n\t    // cursor position for other windows with the same buffer\n\t    if (win != curwin)\n\t\tcol_adjust(&win->w_cursor);\n\t}\n    }\n}\n\n// MB_BYTE2LEN_CHECK from src/vim.h:\n#define MB_BYTE2LEN_CHECK(b)\t(((b) < 0 || (b) > 255) ? 1 : mb_bytelen_tab[b]) /* <=== src/vim.h:2342:2342:MB_BYTE2LEN_CHECK:1 */ \n\n// sign_mark_adjust from src/sign.c:\n    void /* <=== sign_mark_adjust */ \nsign_mark_adjust(\n    linenr_T\tline1,\n    linenr_T\tline2,\n    long\tamount,\n    long\tamount_after)\n{\n    sign_entry_T\t*sign;\t\t// a sign in a b_signlist\n    linenr_T\t\tnew_lnum;\n\n    FOR_ALL_SIGNS_IN_BUF(curbuf, sign)\n    {\n\t// Ignore changes to lines after the sign\n\tif (sign->se_lnum < line1)\n\t    continue;\n\tnew_lnum = sign->se_lnum;\n\tif (sign->se_lnum >= line1 && sign->se_lnum <= line2)\n\t{\n\t    if (amount != MAXLNUM)\n\t\tnew_lnum += amount;\n\t}\n\telse if (sign->se_lnum > line2)\n\t    // Lines inserted or deleted before the sign\n\t    new_lnum += amount_after;\n\n\t// If the new sign line number is past the last line in the buffer,\n\t// then don't adjust the line number. Otherwise, it will always be past\n\t// the last line and will not be visible.\n\tif (new_lnum <= curbuf->b_ml.ml_line_count)\n\t    sign->se_lnum = new_lnum;\n    }\n}\n\n// K_KDEL from src/keymap.h:\n#define K_KDEL\t\tTERMCAP2KEY(KS_EXTRA, KE_KDEL) /* <=== src/keymap.h:386:386:K_KDEL:0 */ \n\n// adjust_prop from src/textprop.c:\n    static adjustres_T /* <=== adjust_prop */ \nadjust_prop(\n\ttextprop_T *prop,\n\tcolnr_T col,\n\tint added,\n\tint flags)\n{\n    proptype_T\t*pt = text_prop_type_by_id(curbuf, prop->tp_type);\n    int\t\tstart_incl = (pt != NULL\n\t\t\t\t    && (pt->pt_flags & PT_FLAG_INS_START_INCL))\n\t\t\t\t\t\t   || (flags & APC_SUBSTITUTE);\n    int\t\tend_incl = (pt != NULL\n\t\t\t\t     && (pt->pt_flags & PT_FLAG_INS_END_INCL));\n\t\t// Do not drop zero-width props if they later can increase in\n\t\t// size.\n    int\t\tdroppable = !(start_incl || end_incl);\n    adjustres_T res = {TRUE, FALSE};\n\n    if (added > 0)\n    {\n\tif (col + 1 <= prop->tp_col\n\t\t- (start_incl || (prop->tp_len == 0 && end_incl)))\n\t    // Change is entirely before the text property: Only shift\n\t    prop->tp_col += added;\n\telse if (col + 1 < prop->tp_col + prop->tp_len + end_incl)\n\t    // Insertion was inside text property\n\t    prop->tp_len += added;\n    }\n    else if (prop->tp_col > col + 1)\n    {\n\tif (prop->tp_col + added < col + 1)\n\t{\n\t    prop->tp_len += (prop->tp_col - 1 - col) + added;\n\t    prop->tp_col = col + 1;\n\t    if (prop->tp_len <= 0)\n\t    {\n\t\tprop->tp_len = 0;\n\t\tres.can_drop = droppable;\n\t    }\n\t}\n\telse\n\t    prop->tp_col += added;\n    }\n    else if (prop->tp_len > 0 && prop->tp_col + prop->tp_len > col)\n    {\n\tint after = col - added - (prop->tp_col - 1 + prop->tp_len);\n\n\tprop->tp_len += after > 0 ? added + after : added;\n\tres.can_drop = prop->tp_len <= 0 && droppable;\n    }\n    else\n\tres.dirty = FALSE;\n\n    return res;\n}\n\n// W_ENDCOL from src/vim.h:\n#define W_ENDCOL(wp)\t(wp->w_wincol + wp->w_width) /* <=== src/vim.h:855:855:W_ENDCOL:1 */ \n\n// check_cursor_col from src/misc2.c:\n    void /* <=== check_cursor_col */ \ncheck_cursor_col(void)\n{\n    check_cursor_col_win(curwin);\n}\n"
  },
  {
    "repository": "vim",
    "cve_id": "CVE-2022-0685",
    "cwe_list": [
      "CWE-703"
    ],
    "commit_hash": "5921aeb5741fc6e84c870d68c7c35b93ad0c9f87",
    "short_hash": "5921aeb5",
    "vulnerableMethods_before": [
      {
        "filename": "filepath.c",
        "method_name": "vulnerable_function",
        "raw_code": "unix_expandpath(\n    garray_T\t*gap,\n    char_u\t*path,\n    int\t\twildoff,\n    int\t\tflags,\t\t// EW_* flags\n    int\t\tdidstar)\t// expanded \"**\" once already\n{\n    char_u\t*buf;\n    char_u\t*path_end;\n    char_u\t*p, *s, *e;\n    int\t\tstart_len = gap->ga_len;\n    char_u\t*pat;\n    regmatch_T\tregmatch;\n    int\t\tstarts_with_dot;\n    int\t\tmatches;\n    int\t\tlen;\n    int\t\tstarstar = FALSE;\n    static int\tstardepth = 0;\t    // depth for \"**\" expansion\n\n    DIR\t\t*dirp;\n    struct dirent *dp;\n\n    // Expanding \"**\" may take a long time, check for CTRL-C.\n    if (stardepth > 0)\n    {\n\tui_breakcheck();\n\tif (got_int)\n\t    return 0;\n    }\n\n    // make room for file name\n    buf = alloc(STRLEN(path) + BASENAMELEN + 5);\n    if (buf == NULL)\n\treturn 0;\n\n    /*\n     * Find the first part in the path name that contains a wildcard.\n     * When EW_ICASE is set every letter is considered to be a wildcard.\n     * Copy it into \"buf\", including the preceding characters.\n     */\n    p = buf;\n    s = buf;\n    e = NULL;\n    path_end = path;\n    while (*path_end != NUL)\n    {\n\t// May ignore a wildcard that has a backslash before it; it will\n\t// be removed by rem_backslash() or file_pat_to_reg_pat() below.\n\tif (path_end >= path + wildoff && rem_backslash(path_end))\n\t    *p++ = *path_end++;\n\telse if (*path_end == '/')\n\t{\n\t    if (e != NULL)\n\t\tbreak;\n\t    s = p + 1;\n\t}\n\telse if (path_end >= path + wildoff\n\t\t\t && (vim_strchr((char_u *)\"*?[{~$\", *path_end) != NULL\n\t\t\t     || (!p_fic && (flags & EW_ICASE)\n\t\t\t\t\t     && isalpha(PTR2CHAR(path_end)))))\n\t    e = p;\n\tif (has_mbyte)\n\t{\n\t    len = (*mb_ptr2len)(path_end);\n\t    STRNCPY(p, path_end, len);\n\t    p += len;\n\t    path_end += len;\n\t}\n\telse\n\t    *p++ = *path_end++;\n    }\n    e = p;\n    *e = NUL;\n\n    // Now we have one wildcard component between \"s\" and \"e\".\n    // Remove backslashes between \"wildoff\" and the start of the wildcard\n    // component.\n    for (p = buf + wildoff; p < s; ++p)\n\tif (rem_backslash(p))\n\t{\n\t    STRMOVE(p, p + 1);\n\t    --e;\n\t    --s;\n\t}\n\n    // Check for \"**\" between \"s\" and \"e\".\n    for (p = s; p < e; ++p)\n\tif (p[0] == '*' && p[1] == '*')\n\t    starstar = TRUE;\n\n    // convert the file pattern to a regexp pattern\n    starts_with_dot = *s == '.';\n    pat = file_pat_to_reg_pat(s, e, NULL, FALSE);\n    if (pat == NULL)\n    {\n\tvim_free(buf);\n\treturn 0;\n    }\n\n    // compile the regexp into a program\n    if (flags & EW_ICASE)\n\tregmatch.rm_ic = TRUE;\t\t// 'wildignorecase' set\n    else\n\tregmatch.rm_ic = p_fic;\t// ignore case when 'fileignorecase' is set\n    if (flags & (EW_NOERROR | EW_NOTWILD))\n\t++emsg_silent;\n    regmatch.regprog = vim_regcomp(pat, RE_MAGIC);\n    if (flags & (EW_NOERROR | EW_NOTWILD))\n\t--emsg_silent;\n    vim_free(pat);\n\n    if (regmatch.regprog == NULL && (flags & EW_NOTWILD) == 0)\n    {\n\tvim_free(buf);\n\treturn 0;\n    }\n\n    // If \"**\" is by itself, this is the first time we encounter it and more\n    // is following then find matches without any directory.\n    if (!didstar && stardepth < 100 && starstar && e - s == 2\n\t\t\t\t\t\t\t  && *path_end == '/')\n    {\n\tSTRCPY(s, path_end + 1);\n\t++stardepth;\n\t(void)unix_expandpath(gap, buf, (int)(s - buf), flags, TRUE);\n\t--stardepth;\n    }\n\n    // open the directory for scanning\n    *s = NUL;\n    dirp = opendir(*buf == NUL ? \".\" : (char *)buf);\n\n    // Find all matching entries\n    if (dirp != NULL)\n    {\n\tfor (;;)\n\t{\n\t    dp = readdir(dirp);\n\t    if (dp == NULL)\n\t\tbreak;\n\t    if ((dp->d_name[0] != '.' || starts_with_dot\n\t\t\t|| ((flags & EW_DODOT)\n\t\t\t    && dp->d_name[1] != NUL\n\t\t\t    && (dp->d_name[1] != '.' || dp->d_name[2] != NUL)))\n\t\t && ((regmatch.regprog != NULL && vim_regexec(&regmatch,\n\t\t\t\t\t     (char_u *)dp->d_name, (colnr_T)0))\n\t\t   || ((flags & EW_NOTWILD)\n\t\t     && fnamencmp(path + (s - buf), dp->d_name, e - s) == 0)))\n\t    {\n\t\tSTRCPY(s, dp->d_name);\n\t\tlen = STRLEN(buf);\n\n\t\tif (starstar && stardepth < 100)\n\t\t{\n\t\t    // For \"**\" in the pattern first go deeper in the tree to\n\t\t    // find matches.\n\t\t    STRCPY(buf + len, \"/**\");\n\t\t    STRCPY(buf + len + 3, path_end);\n\t\t    ++stardepth;\n\t\t    (void)unix_expandpath(gap, buf, len + 1, flags, TRUE);\n\t\t    --stardepth;\n\t\t}\n\n\t\tSTRCPY(buf + len, path_end);\n\t\tif (mch_has_exp_wildcard(path_end)) // handle more wildcards\n\t\t{\n\t\t    // need to expand another component of the path\n\t\t    // remove backslashes for the remaining components only\n\t\t    (void)unix_expandpath(gap, buf, len + 1, flags, FALSE);\n\t\t}\n\t\telse\n\t\t{\n\t\t    stat_T  sb;\n\n\t\t    // no more wildcards, check if there is a match\n\t\t    // remove backslashes for the remaining components only\n\t\t    if (*path_end != NUL)\n\t\t\tbackslash_halve(buf + len + 1);\n\t\t    // add existing file or symbolic link\n\t\t    if ((flags & EW_ALLLINKS) ? mch_lstat((char *)buf, &sb) >= 0\n\t\t\t\t\t\t      : mch_getperm(buf) >= 0)\n\t\t    {\n#ifdef MACOS_CONVERT\n\t\t\tsize_t precomp_len = STRLEN(buf)+1;\n\t\t\tchar_u *precomp_buf =\n\t\t\t    mac_precompose_path(buf, precomp_len, &precomp_len);\n\n\t\t\tif (precomp_buf)\n\t\t\t{\n\t\t\t    mch_memmove(buf, precomp_buf, precomp_len);\n\t\t\t    vim_free(precomp_buf);\n\t\t\t}\n#endif\n\t\t\taddfile(gap, buf, flags);\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\tclosedir(dirp);\n    }\n\n    vim_free(buf);\n    vim_regfree(regmatch.regprog);\n\n    matches = gap->ga_len - start_len;\n    if (matches > 0)\n\tqsort(((char_u **)gap->ga_data) + start_len, matches,\n\t\t\t\t\t\t   sizeof(char_u *), pstrcmp);\n    return matches;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "filepath.c",
        "method_name": "fixed_function",
        "raw_code": "unix_expandpath(\n    garray_T\t*gap,\n    char_u\t*path,\n    int\t\twildoff,\n    int\t\tflags,\t\t// EW_* flags\n    int\t\tdidstar)\t// expanded \"**\" once already\n{\n    char_u\t*buf;\n    char_u\t*path_end;\n    char_u\t*p, *s, *e;\n    int\t\tstart_len = gap->ga_len;\n    char_u\t*pat;\n    regmatch_T\tregmatch;\n    int\t\tstarts_with_dot;\n    int\t\tmatches;\n    int\t\tlen;\n    int\t\tstarstar = FALSE;\n    static int\tstardepth = 0;\t    // depth for \"**\" expansion\n\n    DIR\t\t*dirp;\n    struct dirent *dp;\n\n    // Expanding \"**\" may take a long time, check for CTRL-C.\n    if (stardepth > 0)\n    {\n\tui_breakcheck();\n\tif (got_int)\n\t    return 0;\n    }\n\n    // make room for file name\n    buf = alloc(STRLEN(path) + BASENAMELEN + 5);\n    if (buf == NULL)\n\treturn 0;\n\n    /*\n     * Find the first part in the path name that contains a wildcard.\n     * When EW_ICASE is set every letter is considered to be a wildcard.\n     * Copy it into \"buf\", including the preceding characters.\n     */\n    p = buf;\n    s = buf;\n    e = NULL;\n    path_end = path;\n    while (*path_end != NUL)\n    {\n\t// May ignore a wildcard that has a backslash before it; it will\n\t// be removed by rem_backslash() or file_pat_to_reg_pat() below.\n\tif (path_end >= path + wildoff && rem_backslash(path_end))\n\t    *p++ = *path_end++;\n\telse if (*path_end == '/')\n\t{\n\t    if (e != NULL)\n\t\tbreak;\n\t    s = p + 1;\n\t}\n\telse if (path_end >= path + wildoff\n\t\t\t && (vim_strchr((char_u *)\"*?[{~$\", *path_end) != NULL\n\t\t\t     || (!p_fic && (flags & EW_ICASE)\n\t\t\t\t\t  && vim_isalpha(PTR2CHAR(path_end)))))\n\t    e = p;\n\tif (has_mbyte)\n\t{\n\t    len = (*mb_ptr2len)(path_end);\n\t    STRNCPY(p, path_end, len);\n\t    p += len;\n\t    path_end += len;\n\t}\n\telse\n\t    *p++ = *path_end++;\n    }\n    e = p;\n    *e = NUL;\n\n    // Now we have one wildcard component between \"s\" and \"e\".\n    // Remove backslashes between \"wildoff\" and the start of the wildcard\n    // component.\n    for (p = buf + wildoff; p < s; ++p)\n\tif (rem_backslash(p))\n\t{\n\t    STRMOVE(p, p + 1);\n\t    --e;\n\t    --s;\n\t}\n\n    // Check for \"**\" between \"s\" and \"e\".\n    for (p = s; p < e; ++p)\n\tif (p[0] == '*' && p[1] == '*')\n\t    starstar = TRUE;\n\n    // convert the file pattern to a regexp pattern\n    starts_with_dot = *s == '.';\n    pat = file_pat_to_reg_pat(s, e, NULL, FALSE);\n    if (pat == NULL)\n    {\n\tvim_free(buf);\n\treturn 0;\n    }\n\n    // compile the regexp into a program\n    if (flags & EW_ICASE)\n\tregmatch.rm_ic = TRUE;\t\t// 'wildignorecase' set\n    else\n\tregmatch.rm_ic = p_fic;\t// ignore case when 'fileignorecase' is set\n    if (flags & (EW_NOERROR | EW_NOTWILD))\n\t++emsg_silent;\n    regmatch.regprog = vim_regcomp(pat, RE_MAGIC);\n    if (flags & (EW_NOERROR | EW_NOTWILD))\n\t--emsg_silent;\n    vim_free(pat);\n\n    if (regmatch.regprog == NULL && (flags & EW_NOTWILD) == 0)\n    {\n\tvim_free(buf);\n\treturn 0;\n    }\n\n    // If \"**\" is by itself, this is the first time we encounter it and more\n    // is following then find matches without any directory.\n    if (!didstar && stardepth < 100 && starstar && e - s == 2\n\t\t\t\t\t\t\t  && *path_end == '/')\n    {\n\tSTRCPY(s, path_end + 1);\n\t++stardepth;\n\t(void)unix_expandpath(gap, buf, (int)(s - buf), flags, TRUE);\n\t--stardepth;\n    }\n\n    // open the directory for scanning\n    *s = NUL;\n    dirp = opendir(*buf == NUL ? \".\" : (char *)buf);\n\n    // Find all matching entries\n    if (dirp != NULL)\n    {\n\tfor (;;)\n\t{\n\t    dp = readdir(dirp);\n\t    if (dp == NULL)\n\t\tbreak;\n\t    if ((dp->d_name[0] != '.' || starts_with_dot\n\t\t\t|| ((flags & EW_DODOT)\n\t\t\t    && dp->d_name[1] != NUL\n\t\t\t    && (dp->d_name[1] != '.' || dp->d_name[2] != NUL)))\n\t\t && ((regmatch.regprog != NULL && vim_regexec(&regmatch,\n\t\t\t\t\t     (char_u *)dp->d_name, (colnr_T)0))\n\t\t   || ((flags & EW_NOTWILD)\n\t\t     && fnamencmp(path + (s - buf), dp->d_name, e - s) == 0)))\n\t    {\n\t\tSTRCPY(s, dp->d_name);\n\t\tlen = STRLEN(buf);\n\n\t\tif (starstar && stardepth < 100)\n\t\t{\n\t\t    // For \"**\" in the pattern first go deeper in the tree to\n\t\t    // find matches.\n\t\t    STRCPY(buf + len, \"/**\");\n\t\t    STRCPY(buf + len + 3, path_end);\n\t\t    ++stardepth;\n\t\t    (void)unix_expandpath(gap, buf, len + 1, flags, TRUE);\n\t\t    --stardepth;\n\t\t}\n\n\t\tSTRCPY(buf + len, path_end);\n\t\tif (mch_has_exp_wildcard(path_end)) // handle more wildcards\n\t\t{\n\t\t    // need to expand another component of the path\n\t\t    // remove backslashes for the remaining components only\n\t\t    (void)unix_expandpath(gap, buf, len + 1, flags, FALSE);\n\t\t}\n\t\telse\n\t\t{\n\t\t    stat_T  sb;\n\n\t\t    // no more wildcards, check if there is a match\n\t\t    // remove backslashes for the remaining components only\n\t\t    if (*path_end != NUL)\n\t\t\tbackslash_halve(buf + len + 1);\n\t\t    // add existing file or symbolic link\n\t\t    if ((flags & EW_ALLLINKS) ? mch_lstat((char *)buf, &sb) >= 0\n\t\t\t\t\t\t      : mch_getperm(buf) >= 0)\n\t\t    {\n#ifdef MACOS_CONVERT\n\t\t\tsize_t precomp_len = STRLEN(buf)+1;\n\t\t\tchar_u *precomp_buf =\n\t\t\t    mac_precompose_path(buf, precomp_len, &precomp_len);\n\n\t\t\tif (precomp_buf)\n\t\t\t{\n\t\t\t    mch_memmove(buf, precomp_buf, precomp_len);\n\t\t\t    vim_free(precomp_buf);\n\t\t\t}\n#endif\n\t\t\taddfile(gap, buf, flags);\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\tclosedir(dirp);\n    }\n\n    vim_free(buf);\n    vim_regfree(regmatch.regprog);\n\n    matches = gap->ga_len - start_len;\n    if (matches > 0)\n\tqsort(((char_u **)gap->ga_data) + start_len, matches,\n\t\t\t\t\t\t   sizeof(char_u *), pstrcmp);\n    return matches;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"vim.h\"\n"
  },
  {
    "repository": "tensorflow",
    "cve_id": "CVE-2022-23565",
    "cwe_list": [
      "CWE-617"
    ],
    "commit_hash": "c2b31ff2d3151acb230edc3f5b1832d2c713a9e0",
    "short_hash": "c2b31ff2",
    "vulnerableMethods_before": [
      {
        "filename": "op_def_util.cc",
        "method_name": "vulnerable_function",
        "raw_code": "bool RepeatedAttrDefEqual(\n    const protobuf::RepeatedPtrField<OpDef::AttrDef>& a1,\n    const protobuf::RepeatedPtrField<OpDef::AttrDef>& a2) {\n  std::unordered_map<string, const OpDef::AttrDef*> a1_set;\n  for (const OpDef::AttrDef& def : a1) {\n    DCHECK(a1_set.find(def.name()) == a1_set.end())\n        << \"AttrDef names must be unique, but '\" << def.name()\n        << \"' appears more than once\";\n    a1_set[def.name()] = &def;\n  }\n  for (const OpDef::AttrDef& def : a2) {\n    auto iter = a1_set.find(def.name());\n    if (iter == a1_set.end()) return false;\n    if (!AttrDefEqual(*iter->second, def)) return false;\n    a1_set.erase(iter);\n  }\n  if (!a1_set.empty()) return false;\n  return true;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "op_def_util.cc",
        "method_name": "fixed_function",
        "raw_code": "bool RepeatedAttrDefEqual(\n    const protobuf::RepeatedPtrField<OpDef::AttrDef>& a1,\n    const protobuf::RepeatedPtrField<OpDef::AttrDef>& a2) {\n  std::unordered_map<string, const OpDef::AttrDef*> a1_set;\n  for (const OpDef::AttrDef& def : a1) {\n    if (a1_set.find(def.name()) != a1_set.end()) {\n      LOG(ERROR) << \"AttrDef names must be unique, but '\" << def.name()\n                 << \"' appears more than once\";\n    }\n    a1_set[def.name()] = &def;\n  }\n  for (const OpDef::AttrDef& def : a2) {\n    auto iter = a1_set.find(def.name());\n    if (iter == a1_set.end()) return false;\n    if (!AttrDefEqual(*iter->second, def)) return false;\n    a1_set.erase(iter);\n  }\n  if (!a1_set.empty()) return false;\n  return true;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/lib/gtl/map_util.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/lib/core/stringpiece.h\"\n#include \"tensorflow/core/lib/hash/hash.h\"\n#include \"tensorflow/core/lib/strings/scanner.h\"\n#include \"tensorflow/core/platform/types.h\"\n#include \"tensorflow/core/lib/strings/strcat.h\"\n#include <set>\n#include \"tensorflow/core/platform/protobuf.h\"\n#include \"tensorflow/core/platform/mutex.h\"\n#include <unordered_set>\n#include \"tensorflow/core/framework/attr_value.pb.h\"\n#include <unordered_map>\n#include \"tensorflow/core/lib/strings/str_util.h\"\n#include \"tensorflow/core/framework/op_def_util.h\"\n#include \"tensorflow/core/lib/strings/proto_serialization.h\"\n#include \"tensorflow/core/framework/op_def.pb.h\"\n#include \"tensorflow/core/framework/attr_value_util.h\"\n\n// Type Definitions:\n// iterator:\nclass iterator {\n   public:\n    typedef ssize_t difference_type;\n    typedef T value_type;\n    typedef const T* pointer;\n    typedef const T& reference;\n    typedef ::std::forward_iterator_tag iterator_category;\n\n    explicit iterator(uintptr_t rep)\n        : bigrep_(false), single_(reinterpret_cast<T>(rep)) {}\n    explicit iterator(typename BigRep::iterator iter)\n        : bigrep_(true), single_(nullptr), iter_(iter) {}\n\n    iterator& operator++() {\n      if (bigrep_) {\n        ++iter_;\n      } else {\n        DCHECK(single_ != nullptr);\n        single_ = nullptr;\n      }\n      return *this;\n    }\n    // maybe post-increment?\n\n    bool operator==(const iterator& other) const {\n      if (bigrep_) {\n        return iter_ == other.iter_;\n      } else {\n        return single_ == other.single_;\n      }\n    }\n    bool operator!=(const iterator& other) const { return !(*this == other); }\n\n    const T& operator*() const {\n      if (bigrep_) {\n        return *iter_;\n      } else {\n        DCH...\n\n// Called Methods (top 10):\n// DCHECK from tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/platform/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/platform/logging.h:\n\n\n// LOG from tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/platform/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/platform/logging.h:\n\n"
  },
  {
    "repository": "clamav-devel",
    "cve_id": "CVE-2013-2020",
    "cwe_list": [
      "CWE-189"
    ],
    "commit_hash": "c6870a6c857dd722dffaf6d37ae52ec259d12492",
    "short_hash": "c6870a6c",
    "vulnerableMethods_before": [
      {
        "filename": "sis.c",
        "method_name": "vulnerable_function",
        "raw_code": "static char *getsistring(FILE *f, uint32_t ptr, uint32_t len) {\n  char *name;\n  uint32_t i;\n\n  if (!len) return NULL;\n  if (len>400) len=400;\n  name = cli_malloc(len);\n  if (!name) {\n    cli_dbgmsg(\"SIS: OOM\\n\");\n    return NULL;\n  }\n  fseek(f, ptr, SEEK_SET);\n  if (fread(name, len, 1, f)!=1) {\n    cli_dbgmsg(\"SIS: Unable to read string\\n\");\n    free(name);\n    return NULL;\n  }\n  for (i = 0 ; i < len; i+=2) name[i/2] = name[i];\n  name[i/2]='\\0';\n  return name;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "sis.c",
        "method_name": "fixed_function",
        "raw_code": "static char *getsistring(FILE *f, uint32_t ptr, uint32_t len) {\n  char *name;\n  uint32_t i;\n\n  if (!len) return NULL;\n  if (len>400) len=400;\n  name = cli_malloc(len+1);\n  if (!name) {\n    cli_dbgmsg(\"SIS: OOM\\n\");\n    return NULL;\n  }\n  fseek(f, ptr, SEEK_SET);\n  if (fread(name, len, 1, f)!=1) {\n    cli_dbgmsg(\"SIS: Unable to read string\\n\");\n    free(name);\n    return NULL;\n  }\n  for (i = 0 ; i < len; i+=2) name[i/2] = name[i];\n  name[i/2]='\\0';\n  return name;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"sis.h\"\n#include <zlib.h>\n#include \"others.h\"\n#include \"clamav.h\"\n#include <string.h>\n#include \"scanners.h\"\n#include \"clamav-config.h\"\n#include <fcntl.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <sys/stat.h>\n\n// Type Definitions:\n// uint32_t:\ntypedef unsigned int uint32_t;\n\n// uint32_t:\ntypedef unsigned long uint32_t;\n\n// Called Methods (top 10):\n// cli_errmsg from libclamav/others_common.c:\nvoid cli_errmsg(const char *str, ...) /* <=== cli_errmsg */ \n{\n    MSGCODE(buff, len, \"LibClamAV Error: \");\n    msg_callback(CL_MSG_ERROR, buff, buff+len, cli_getctx());\n}\n\n// CLI_MAX_ALLOCATION from libclamav/others.h:\n#define CLI_MAX_ALLOCATION (182*1024*1024) /* <=== libclamav/others.h:79:79:CLI_MAX_ALLOCATION:0 */ \n\n// cli_dbgmsg_internal from libclamav/others_common.c:\nvoid cli_dbgmsg_internal(const char *str, ...)\n{\n    MSGCODE(buff, len, \"LibClamAV debug: \");\n    fputs(buff, stderr);\n}\n\n// cli_getctx from libclamav/others_common.c:\nstatic inline void *cli_getctx(void) /* <=== cli_getctx */ \n{\n    cli_ctx *ctx;\n    pthread_once(&cli_ctx_tls_key_once, cli_ctx_tls_key_alloc);\n    ctx = pthread_getspecific(cli_ctx_tls_key);\n    return ctx ? ctx->cb_ctx : NULL;\n}\n\n// cli_malloc from libclamav/others_common.c:\nvoid *cli_malloc(size_t size)\n{\n\tvoid *alloc;\n\n\n    if(!size || size > CLI_MAX_ALLOCATION) {\n\tcli_errmsg(\"cli_malloc(): Attempt to allocate %lu bytes. Please report to http://bugs.clamav.net\\n\", (unsigned long int) size);\n\treturn NULL;\n    }\n\n    alloc = malloc(size);\n\n    if(!alloc) {\n\tcli_errmsg(\"cli_malloc(): Can't allocate memory (%lu bytes).\\n\", (unsigned long int) size);\n\tperror(\"malloc_problem\");\n\treturn NULL;\n    } else return alloc;\n}\n\n// cli_dbgmsg from libclamav/others.h:\n<empty>\n\n// MSGCODE from libclamav/others_common.c:\n#define MSGCODE(buff, len, x)\t\t\t\t    \\ /* <=== libclamav/others_common.c:135:143:MSGCODE:3 */ \n\tva_list args;\t\t\t\t\t    \\\n\tint len = sizeof(x) - 1;\t\t\t    \\\n\tchar buff[BUFSIZ];\t\t\t\t    \\\n    strncpy(buff, x, len);\t\t\t\t    \\\n    va_start(args, str);\t\t\t\t    \\\n    vsnprintf(buff + len, sizeof(buff) - len, str, args);   \\\n    buff[sizeof(buff) - 1] = '\\0';\t\t\t    \\\n    va_end(args)\n\n// malloc from libclamav/bytecode_api.h:\nvoid* malloc(uint32_t size); /* <=== malloc */ \n"
  },
  {
    "repository": "linux",
    "cve_id": "CVE-2022-3170",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "5934d9a0383619c14df91af8fd76261dc3de2f5f",
    "short_hash": "5934d9a0",
    "vulnerableMethods_before": [
      {
        "filename": "control.c",
        "method_name": "vulnerable_function",
        "raw_code": "static unsigned long get_ctl_id_hash(const struct snd_ctl_elem_id *id)\n{\n\tint i;\n\tunsigned long h;\n\n\th = id->iface;\n\th = MULTIPLIER * h + id->device;\n\th = MULTIPLIER * h + id->subdevice;\n\tfor (i = 0; id->name[i] && i < SNDRV_CTL_ELEM_ID_NAME_MAXLEN; i++)\n\t\th = MULTIPLIER * h + id->name[i];\n\th = MULTIPLIER * h + id->index;\n\th &= LONG_MAX;\n\treturn h;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "control.c",
        "method_name": "fixed_function",
        "raw_code": "static unsigned long get_ctl_id_hash(const struct snd_ctl_elem_id *id)\n{\n\tint i;\n\tunsigned long h;\n\n\th = id->iface;\n\th = MULTIPLIER * h + id->device;\n\th = MULTIPLIER * h + id->subdevice;\n\tfor (i = 0; i < SNDRV_CTL_ELEM_ID_NAME_MAXLEN && id->name[i]; i++)\n\t\th = MULTIPLIER * h + id->name[i];\n\th = MULTIPLIER * h + id->index;\n\th &= LONG_MAX;\n\treturn h;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <sound/info.h>\n#include <linux/math64.h>\n#include <linux/moduleparam.h>\n#include <linux/slab.h>\n#include \"control_compat.c\"\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <sound/control.h>\n#include <linux/interrupt.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/threads.h>\n#include <sound/core.h>\n#include <sound/minors.h>\n"
  },
  {
    "repository": "server",
    "cve_id": "CVE-2021-46668",
    "cwe_list": [
      "CWE-400"
    ],
    "commit_hash": "9e39d0ae44595dbd1570805d97c9c874778a6be8",
    "short_hash": "9e39d0ae",
    "vulnerableMethods_before": [
      {
        "filename": "None",
        "method_name": "vulnerable_function",
        "raw_code": "void ha_maria::drop_table(const char *name)\n{\n  DBUG_ASSERT(file->s->temporary);\n  (void) ha_close();\n  (void) maria_delete_table_files(name, 1, MY_WME);\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "None",
        "method_name": "fixed_function",
        "raw_code": "void ha_maria::drop_table(const char *name)\n{\n  DBUG_ASSERT(!file || file->s->temporary);\n  (void) ha_close();\n  (void) maria_delete_table_files(name, 1, MY_WME);\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <my_bit.h>\n#include <my_dir.h>\n#include \"trnman_public.h\"\n#include \"ma_trnman.h\"\n#include \"sql_class.h\"\n#include \"ma_blockrec.h\"\n#include \"key.h\"\n#include \"protocol.h\"\n#include <myisampack.h>\n#include \"ha_maria.h\"\n#include <m_ctype.h>\n#include \"ma_checkpoint.h\"\n#include \"maria_def.h\"\n#include \"trnman.h\"\n#include \"ma_recovery.h\"\n#include \"sql_parse.h\"\n#include \"log.h\"\n#include <my_global.h>\n#include \"ma_rt_index.h\"\n\n// Type Definitions:\n// ha_maria:\nclass __attribute__((visibility(\"default\"))) ha_maria :public handler\n{\npublic:\n  MARIA_HA *file;\nprivate:\n  ulonglong int_table_flags;\n  MARIA_RECORD_POS remember_pos;\n  char *data_file_name, *index_file_name;\n  enum data_file_type data_file_type;\n  bool can_enable_indexes;\n  /**\n    If a transactional table is doing bulk insert with a single\n    UNDO_BULK_INSERT with/without repair.\n  */\n  uint8 bulk_insert_single_undo;\n  int repair(THD * thd, HA_CHECK *param, bool optimize);\n  int zerofill(THD * thd, HA_CHECK_OPT *check_opt);\n\npublic:\n  ha_maria(handlerton *hton, TABLE_SHARE * table_arg);\n  ~ha_maria() {}\n  handler *clone(const char *name, MEM_ROOT *mem_root) override final;\n  const char *index_type(uint key_number) override final;\n  ulonglong table_flags() const override final\n  { return int_table_flags; }\n  ulong index_flags(uint inx, uint part, bool all_parts) const override final;\n  uint max_supported_keys() const override final\n  { return MARIA_MAX_KEY; }\n  uint max_supporte...\n\n// ha_maria:\nha_maria.ha_maria:ANY(handlerton*,TABLE_SHARE*)\n"
  },
  {
    "repository": "vim",
    "cve_id": "CVE-2022-2126",
    "cwe_list": [
      "CWE-787"
    ],
    "commit_hash": "156d3911952d73b03d7420dc3540215247db0fe8",
    "short_hash": "156d3911",
    "vulnerableMethods_before": [
      {
        "filename": "spellsuggest.c",
        "method_name": "vulnerable_function",
        "raw_code": "suggest_trie_walk(\n    suginfo_T\t*su,\n    langp_T\t*lp,\n    char_u\t*fword,\n    int\t\tsoundfold)\n{\n    char_u\ttword[MAXWLEN];\t    // good word collected so far\n    trystate_T\tstack[MAXWLEN];\n    char_u\tpreword[MAXWLEN * 3]; // word found with proper case;\n\t\t\t\t      // concatenation of prefix compound\n\t\t\t\t      // words and split word.  NUL terminated\n\t\t\t\t      // when going deeper but not when coming\n\t\t\t\t      // back.\n    char_u\tcompflags[MAXWLEN];\t// compound flags, one for each word\n    trystate_T\t*sp;\n    int\t\tnewscore;\n    int\t\tscore;\n    char_u\t*byts, *fbyts, *pbyts;\n    idx_T\t*idxs, *fidxs, *pidxs;\n    int\t\tdepth;\n    int\t\tc, c2, c3;\n    int\t\tn = 0;\n    int\t\tflags;\n    garray_T\t*gap;\n    idx_T\tarridx;\n    int\t\tlen;\n    char_u\t*p;\n    fromto_T\t*ftp;\n    int\t\tfl = 0, tl;\n    int\t\trepextra = 0;\t    // extra bytes in fword[] from REP item\n    slang_T\t*slang = lp->lp_slang;\n    int\t\tfword_ends;\n    int\t\tgoodword_ends;\n#ifdef DEBUG_TRIEWALK\n    // Stores the name of the change made at each level.\n    char_u\tchangename[MAXWLEN][80];\n#endif\n    int\t\tbreakcheckcount = 1000;\n#ifdef FEAT_RELTIME\n    proftime_T\ttime_limit;\n#endif\n    int\t\tcompound_ok;\n\n    // Go through the whole case-fold tree, try changes at each node.\n    // \"tword[]\" contains the word collected from nodes in the tree.\n    // \"fword[]\" the word we are trying to match with (initially the bad\n    // word).\n    depth = 0;\n    sp = &stack[0];\n    CLEAR_POINTER(sp);\n    sp->ts_curi = 1;\n\n    if (soundfold)\n    {\n\t// Going through the soundfold tree.\n\tbyts = fbyts = slang->sl_sbyts;\n\tidxs = fidxs = slang->sl_sidxs;\n\tpbyts = NULL;\n\tpidxs = NULL;\n\tsp->ts_prefixdepth = PFD_NOPREFIX;\n\tsp->ts_state = STATE_START;\n    }\n    else\n    {\n\t// When there are postponed prefixes we need to use these first.  At\n\t// the end of the prefix we continue in the case-fold tree.\n\tfbyts = slang->sl_fbyts;\n\tfidxs = slang->sl_fidxs;\n\tpbyts = slang->sl_pbyts;\n\tpidxs = slang->sl_pidxs;\n\tif (pbyts != NULL)\n\t{\n\t    byts = pbyts;\n\t    idxs = pidxs;\n\t    sp->ts_prefixdepth = PFD_PREFIXTREE;\n\t    sp->ts_state = STATE_NOPREFIX;\t// try without prefix first\n\t}\n\telse\n\t{\n\t    byts = fbyts;\n\t    idxs = fidxs;\n\t    sp->ts_prefixdepth = PFD_NOPREFIX;\n\t    sp->ts_state = STATE_START;\n\t}\n    }\n#ifdef FEAT_RELTIME\n    // The loop may take an indefinite amount of time. Break out after some\n    // time.\n    if (spell_suggest_timeout > 0)\n\tprofile_setlimit(spell_suggest_timeout, &time_limit);\n#endif\n\n    // Loop to find all suggestions.  At each round we either:\n    // - For the current state try one operation, advance \"ts_curi\",\n    //   increase \"depth\".\n    // - When a state is done go to the next, set \"ts_state\".\n    // - When all states are tried decrease \"depth\".\n    while (depth >= 0 && !got_int)\n    {\n\tsp = &stack[depth];\n\tswitch (sp->ts_state)\n\t{\n\tcase STATE_START:\n\tcase STATE_NOPREFIX:\n\t    // Start of node: Deal with NUL bytes, which means\n\t    // tword[] may end here.\n\t    arridx = sp->ts_arridx;\t    // current node in the tree\n\t    len = byts[arridx];\t\t    // bytes in this node\n\t    arridx += sp->ts_curi;\t    // index of current byte\n\n\t    if (sp->ts_prefixdepth == PFD_PREFIXTREE)\n\t    {\n\t\t// Skip over the NUL bytes, we use them later.\n\t\tfor (n = 0; n < len && byts[arridx + n] == 0; ++n)\n\t\t    ;\n\t\tsp->ts_curi += n;\n\n\t\t// Always past NUL bytes now.\n\t\tn = (int)sp->ts_state;\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_ENDNUL;\n\t\tsp->ts_save_badflags = su->su_badflags;\n\n\t\t// At end of a prefix or at start of prefixtree: check for\n\t\t// following word.\n\t\tif (depth < MAXWLEN - 1\n\t\t\t    && (byts[arridx] == 0 || n == (int)STATE_NOPREFIX))\n\t\t{\n\t\t    // Set su->su_badflags to the caps type at this position.\n\t\t    // Use the caps type until here for the prefix itself.\n\t\t    if (has_mbyte)\n\t\t\tn = nofold_len(fword, sp->ts_fidx, su->su_badptr);\n\t\t    else\n\t\t\tn = sp->ts_fidx;\n\t\t    flags = badword_captype(su->su_badptr, su->su_badptr + n);\n\t\t    su->su_badflags = badword_captype(su->su_badptr + n,\n\t\t\t\t\t       su->su_badptr + su->su_badlen);\n#ifdef DEBUG_TRIEWALK\n\t\t    sprintf(changename[depth], \"prefix\");\n#endif\n\t\t    go_deeper(stack, depth, 0);\n\t\t    ++depth;\n\t\t    sp = &stack[depth];\n\t\t    sp->ts_prefixdepth = depth - 1;\n\t\t    byts = fbyts;\n\t\t    idxs = fidxs;\n\t\t    sp->ts_arridx = 0;\n\n\t\t    // Move the prefix to preword[] with the right case\n\t\t    // and make find_keepcap_word() works.\n\t\t    tword[sp->ts_twordlen] = NUL;\n\t\t    make_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t  preword + sp->ts_prewordlen, flags);\n\t\t    sp->ts_prewordlen = (char_u)STRLEN(preword);\n\t\t    sp->ts_splitoff = sp->ts_twordlen;\n\t\t}\n\t\tbreak;\n\t    }\n\n\t    if (sp->ts_curi > len || byts[arridx] != 0)\n\t    {\n\t\t// Past bytes in node and/or past NUL bytes.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_ENDNUL;\n\t\tsp->ts_save_badflags = su->su_badflags;\n\t\tbreak;\n\t    }\n\n\t    // End of word in tree.\n\t    ++sp->ts_curi;\t\t// eat one NUL byte\n\n\t    flags = (int)idxs[arridx];\n\n\t    // Skip words with the NOSUGGEST flag.\n\t    if (flags & WF_NOSUGGEST)\n\t\tbreak;\n\n\t    fword_ends = (fword[sp->ts_fidx] == NUL\n\t\t\t   || (soundfold\n\t\t\t       ? VIM_ISWHITE(fword[sp->ts_fidx])\n\t\t\t       : !spell_iswordp(fword + sp->ts_fidx, curwin)));\n\t    tword[sp->ts_twordlen] = NUL;\n\n\t    if (sp->ts_prefixdepth <= PFD_NOTSPECIAL\n\t\t\t\t\t&& (sp->ts_flags & TSF_PREFIXOK) == 0\n\t\t\t\t\t&& pbyts != NULL)\n\t    {\n\t\t// There was a prefix before the word.  Check that the prefix\n\t\t// can be used with this word.\n\t\t// Count the length of the NULs in the prefix.  If there are\n\t\t// none this must be the first try without a prefix.\n\t\tn = stack[sp->ts_prefixdepth].ts_arridx;\n\t\tlen = pbyts[n++];\n\t\tfor (c = 0; c < len && pbyts[n + c] == 0; ++c)\n\t\t    ;\n\t\tif (c > 0)\n\t\t{\n\t\t    c = valid_word_prefix(c, n, flags,\n\t\t\t\t       tword + sp->ts_splitoff, slang, FALSE);\n\t\t    if (c == 0)\n\t\t\tbreak;\n\n\t\t    // Use the WF_RARE flag for a rare prefix.\n\t\t    if (c & WF_RAREPFX)\n\t\t\tflags |= WF_RARE;\n\n\t\t    // Tricky: when checking for both prefix and compounding\n\t\t    // we run into the prefix flag first.\n\t\t    // Remember that it's OK, so that we accept the prefix\n\t\t    // when arriving at a compound flag.\n\t\t    sp->ts_flags |= TSF_PREFIXOK;\n\t\t}\n\t    }\n\n\t    // Check NEEDCOMPOUND: can't use word without compounding.  Do try\n\t    // appending another compound word below.\n\t    if (sp->ts_complen == sp->ts_compsplit && fword_ends\n\t\t\t\t\t\t     && (flags & WF_NEEDCOMP))\n\t\tgoodword_ends = FALSE;\n\t    else\n\t\tgoodword_ends = TRUE;\n\n\t    p = NULL;\n\t    compound_ok = TRUE;\n\t    if (sp->ts_complen > sp->ts_compsplit)\n\t    {\n\t\tif (slang->sl_nobreak)\n\t\t{\n\t\t    // There was a word before this word.  When there was no\n\t\t    // change in this word (it was correct) add the first word\n\t\t    // as a suggestion.  If this word was corrected too, we\n\t\t    // need to check if a correct word follows.\n\t\t    if (sp->ts_fidx - sp->ts_splitfidx\n\t\t\t\t\t  == sp->ts_twordlen - sp->ts_splitoff\n\t\t\t    && STRNCMP(fword + sp->ts_splitfidx,\n\t\t\t\t\ttword + sp->ts_splitoff,\n\t\t\t\t\t sp->ts_fidx - sp->ts_splitfidx) == 0)\n\t\t    {\n\t\t\tpreword[sp->ts_prewordlen] = NUL;\n\t\t\tnewscore = score_wordcount_adj(slang, sp->ts_score,\n\t\t\t\t\t\t preword + sp->ts_prewordlen,\n\t\t\t\t\t\t sp->ts_prewordlen > 0);\n\t\t\t// Add the suggestion if the score isn't too bad.\n\t\t\tif (newscore <= su->su_maxscore)\n\t\t\t    add_suggestion(su, &su->su_ga, preword,\n\t\t\t\t    sp->ts_splitfidx - repextra,\n\t\t\t\t    newscore, 0, FALSE,\n\t\t\t\t    lp->lp_sallang, FALSE);\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    // There was a compound word before this word.  If this\n\t\t    // word does not support compounding then give up\n\t\t    // (splitting is tried for the word without compound\n\t\t    // flag).\n\t\t    if (((unsigned)flags >> 24) == 0\n\t\t\t    || sp->ts_twordlen - sp->ts_splitoff\n\t\t\t\t\t\t       < slang->sl_compminlen)\n\t\t\tbreak;\n\t\t    // For multi-byte chars check character length against\n\t\t    // COMPOUNDMIN.\n\t\t    if (has_mbyte\n\t\t\t    && slang->sl_compminlen > 0\n\t\t\t    && mb_charlen(tword + sp->ts_splitoff)\n\t\t\t\t\t\t       < slang->sl_compminlen)\n\t\t\tbreak;\n\n\t\t    compflags[sp->ts_complen] = ((unsigned)flags >> 24);\n\t\t    compflags[sp->ts_complen + 1] = NUL;\n\t\t    vim_strncpy(preword + sp->ts_prewordlen,\n\t\t\t    tword + sp->ts_splitoff,\n\t\t\t    sp->ts_twordlen - sp->ts_splitoff);\n\n\t\t    // Verify CHECKCOMPOUNDPATTERN  rules.\n\t\t    if (match_checkcompoundpattern(preword,  sp->ts_prewordlen,\n\t\t\t\t\t\t\t  &slang->sl_comppat))\n\t\t\tcompound_ok = FALSE;\n\n\t\t    if (compound_ok)\n\t\t    {\n\t\t\tp = preword;\n\t\t\twhile (*skiptowhite(p) != NUL)\n\t\t\t    p = skipwhite(skiptowhite(p));\n\t\t\tif (fword_ends && !can_compound(slang, p,\n\t\t\t\t\t\tcompflags + sp->ts_compsplit))\n\t\t\t    // Compound is not allowed.  But it may still be\n\t\t\t    // possible if we add another (short) word.\n\t\t\t    compound_ok = FALSE;\n\t\t    }\n\n\t\t    // Get pointer to last char of previous word.\n\t\t    p = preword + sp->ts_prewordlen;\n\t\t    MB_PTR_BACK(preword, p);\n\t\t}\n\t    }\n\n\t    // Form the word with proper case in preword.\n\t    // If there is a word from a previous split, append.\n\t    // For the soundfold tree don't change the case, simply append.\n\t    if (soundfold)\n\t\tSTRCPY(preword + sp->ts_prewordlen, tword + sp->ts_splitoff);\n\t    else if (flags & WF_KEEPCAP)\n\t\t// Must find the word in the keep-case tree.\n\t\tfind_keepcap_word(slang, tword + sp->ts_splitoff,\n\t\t\t\t\t\t preword + sp->ts_prewordlen);\n\t    else\n\t    {\n\t\t// Include badflags: If the badword is onecap or allcap\n\t\t// use that for the goodword too.  But if the badword is\n\t\t// allcap and it's only one char long use onecap.\n\t\tc = su->su_badflags;\n\t\tif ((c & WF_ALLCAP)\n\t\t\t&& su->su_badlen == (*mb_ptr2len)(su->su_badptr))\n\t\t    c = WF_ONECAP;\n\t\tc |= flags;\n\n\t\t// When appending a compound word after a word character don't\n\t\t// use Onecap.\n\t\tif (p != NULL && spell_iswordp_nmw(p, curwin))\n\t\t    c &= ~WF_ONECAP;\n\t\tmake_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t      preword + sp->ts_prewordlen, c);\n\t    }\n\n\t    if (!soundfold)\n\t    {\n\t\t// Don't use a banned word.  It may appear again as a good\n\t\t// word, thus remember it.\n\t\tif (flags & WF_BANNED)\n\t\t{\n\t\t    add_banned(su, preword + sp->ts_prewordlen);\n\t\t    break;\n\t\t}\n\t\tif ((sp->ts_complen == sp->ts_compsplit\n\t\t\t    && WAS_BANNED(su, preword + sp->ts_prewordlen))\n\t\t\t\t\t\t   || WAS_BANNED(su, preword))\n\t\t{\n\t\t    if (slang->sl_compprog == NULL)\n\t\t\tbreak;\n\t\t    // the word so far was banned but we may try compounding\n\t\t    goodword_ends = FALSE;\n\t\t}\n\t    }\n\n\t    newscore = 0;\n\t    if (!soundfold)\t// soundfold words don't have flags\n\t    {\n\t\tif ((flags & WF_REGION)\n\t\t\t    && (((unsigned)flags >> 16) & lp->lp_region) == 0)\n\t\t    newscore += SCORE_REGION;\n\t\tif (flags & WF_RARE)\n\t\t    newscore += SCORE_RARE;\n\n\t\tif (!spell_valid_case(su->su_badflags,\n\t\t\t\t  captype(preword + sp->ts_prewordlen, NULL)))\n\t\t    newscore += SCORE_ICASE;\n\t    }\n\n\t    // TODO: how about splitting in the soundfold tree?\n\t    if (fword_ends\n\t\t    && goodword_ends\n\t\t    && sp->ts_fidx >= sp->ts_fidxtry\n\t\t    && compound_ok)\n\t    {\n\t\t// The badword also ends: add suggestions.\n#ifdef DEBUG_TRIEWALK\n\t\tif (soundfold && STRCMP(preword, \"smwrd\") == 0)\n\t\t{\n\t\t    int\t    j;\n\n\t\t    // print the stack of changes that brought us here\n\t\t    smsg(\"------ %s -------\", fword);\n\t\t    for (j = 0; j < depth; ++j)\n\t\t\tsmsg(\"%s\", changename[j]);\n\t\t}\n#endif\n\t\tif (soundfold)\n\t\t{\n\t\t    // For soundfolded words we need to find the original\n\t\t    // words, the edit distance and then add them.\n\t\t    add_sound_suggest(su, preword, sp->ts_score, lp);\n\t\t}\n\t\telse if (sp->ts_fidx > 0)\n\t\t{\n\t\t    // Give a penalty when changing non-word char to word\n\t\t    // char, e.g., \"thes,\" -> \"these\".\n\t\t    p = fword + sp->ts_fidx;\n\t\t    MB_PTR_BACK(fword, p);\n\t\t    if (!spell_iswordp(p, curwin) && *preword != NUL)\n\t\t    {\n\t\t\tp = preword + STRLEN(preword);\n\t\t\tMB_PTR_BACK(preword, p);\n\t\t\tif (spell_iswordp(p, curwin))\n\t\t\t    newscore += SCORE_NONWORD;\n\t\t    }\n\n\t\t    // Give a bonus to words seen before.\n\t\t    score = score_wordcount_adj(slang,\n\t\t\t\t\t\tsp->ts_score + newscore,\n\t\t\t\t\t\tpreword + sp->ts_prewordlen,\n\t\t\t\t\t\tsp->ts_prewordlen > 0);\n\n\t\t    // Add the suggestion if the score isn't too bad.\n\t\t    if (score <= su->su_maxscore)\n\t\t    {\n\t\t\tadd_suggestion(su, &su->su_ga, preword,\n\t\t\t\t    sp->ts_fidx - repextra,\n\t\t\t\t    score, 0, FALSE, lp->lp_sallang, FALSE);\n\n\t\t\tif (su->su_badflags & WF_MIXCAP)\n\t\t\t{\n\t\t\t    // We really don't know if the word should be\n\t\t\t    // upper or lower case, add both.\n\t\t\t    c = captype(preword, NULL);\n\t\t\t    if (c == 0 || c == WF_ALLCAP)\n\t\t\t    {\n\t\t\t\tmake_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t      preword + sp->ts_prewordlen,\n\t\t\t\t\t\t      c == 0 ? WF_ALLCAP : 0);\n\n\t\t\t\tadd_suggestion(su, &su->su_ga, preword,\n\t\t\t\t\tsp->ts_fidx - repextra,\n\t\t\t\t\tscore + SCORE_ICASE, 0, FALSE,\n\t\t\t\t\tlp->lp_sallang, FALSE);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t    // Try word split and/or compounding.\n\t    if ((sp->ts_fidx >= sp->ts_fidxtry || fword_ends)\n\t\t    // Don't split halfway a character.\n\t\t    && (!has_mbyte || sp->ts_tcharlen == 0))\n\t    {\n\t\tint\ttry_compound;\n\t\tint\ttry_split;\n\n\t\t// If past the end of the bad word don't try a split.\n\t\t// Otherwise try changing the next word.  E.g., find\n\t\t// suggestions for \"the the\" where the second \"the\" is\n\t\t// different.  It's done like a split.\n\t\t// TODO: word split for soundfold words\n\t\ttry_split = (sp->ts_fidx - repextra < su->su_badlen)\n\t\t\t\t\t\t\t\t&& !soundfold;\n\n\t\t// Get here in several situations:\n\t\t// 1. The word in the tree ends:\n\t\t//    If the word allows compounding try that.  Otherwise try\n\t\t//    a split by inserting a space.  For both check that a\n\t\t//    valid words starts at fword[sp->ts_fidx].\n\t\t//    For NOBREAK do like compounding to be able to check if\n\t\t//    the next word is valid.\n\t\t// 2. The badword does end, but it was due to a change (e.g.,\n\t\t//    a swap).  No need to split, but do check that the\n\t\t//    following word is valid.\n\t\t// 3. The badword and the word in the tree end.  It may still\n\t\t//    be possible to compound another (short) word.\n\t\ttry_compound = FALSE;\n\t\tif (!soundfold\n\t\t\t&& !slang->sl_nocompoundsugs\n\t\t\t&& slang->sl_compprog != NULL\n\t\t\t&& ((unsigned)flags >> 24) != 0\n\t\t\t&& sp->ts_twordlen - sp->ts_splitoff\n\t\t\t\t\t\t       >= slang->sl_compminlen\n\t\t\t&& (!has_mbyte\n\t\t\t    || slang->sl_compminlen == 0\n\t\t\t    || mb_charlen(tword + sp->ts_splitoff)\n\t\t\t\t\t\t      >= slang->sl_compminlen)\n\t\t\t&& (slang->sl_compsylmax < MAXWLEN\n\t\t\t    || sp->ts_complen + 1 - sp->ts_compsplit\n\t\t\t\t\t\t\t  < slang->sl_compmax)\n\t\t\t&& (can_be_compound(sp, slang,\n\t\t\t\t\t compflags, ((unsigned)flags >> 24))))\n\n\t\t{\n\t\t    try_compound = TRUE;\n\t\t    compflags[sp->ts_complen] = ((unsigned)flags >> 24);\n\t\t    compflags[sp->ts_complen + 1] = NUL;\n\t\t}\n\n\t\t// For NOBREAK we never try splitting, it won't make any word\n\t\t// valid.\n\t\tif (slang->sl_nobreak && !slang->sl_nocompoundsugs)\n\t\t    try_compound = TRUE;\n\n\t\t// If we could add a compound word, and it's also possible to\n\t\t// split at this point, do the split first and set\n\t\t// TSF_DIDSPLIT to avoid doing it again.\n\t\telse if (!fword_ends\n\t\t\t&& try_compound\n\t\t\t&& (sp->ts_flags & TSF_DIDSPLIT) == 0)\n\t\t{\n\t\t    try_compound = FALSE;\n\t\t    sp->ts_flags |= TSF_DIDSPLIT;\n\t\t    --sp->ts_curi;\t    // do the same NUL again\n\t\t    compflags[sp->ts_complen] = NUL;\n\t\t}\n\t\telse\n\t\t    sp->ts_flags &= ~TSF_DIDSPLIT;\n\n\t\tif (try_split || try_compound)\n\t\t{\n\t\t    if (!try_compound && (!fword_ends || !goodword_ends))\n\t\t    {\n\t\t\t// If we're going to split need to check that the\n\t\t\t// words so far are valid for compounding.  If there\n\t\t\t// is only one word it must not have the NEEDCOMPOUND\n\t\t\t// flag.\n\t\t\tif (sp->ts_complen == sp->ts_compsplit\n\t\t\t\t\t\t     && (flags & WF_NEEDCOMP))\n\t\t\t    break;\n\t\t\tp = preword;\n\t\t\twhile (*skiptowhite(p) != NUL)\n\t\t\t    p = skipwhite(skiptowhite(p));\n\t\t\tif (sp->ts_complen > sp->ts_compsplit\n\t\t\t\t&& !can_compound(slang, p,\n\t\t\t\t\t\tcompflags + sp->ts_compsplit))\n\t\t\t    break;\n\n\t\t\tif (slang->sl_nosplitsugs)\n\t\t\t    newscore += SCORE_SPLIT_NO;\n\t\t\telse\n\t\t\t    newscore += SCORE_SPLIT;\n\n\t\t\t// Give a bonus to words seen before.\n\t\t\tnewscore = score_wordcount_adj(slang, newscore,\n\t\t\t\t\t   preword + sp->ts_prewordlen, TRUE);\n\t\t    }\n\n\t\t    if (TRY_DEEPER(su, stack, depth, newscore))\n\t\t    {\n\t\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\t\tif (!try_compound && !fword_ends)\n\t\t\t    sprintf(changename[depth], \"%.*s-%s: split\",\n\t\t\t\t sp->ts_twordlen, tword, fword + sp->ts_fidx);\n\t\t\telse\n\t\t\t    sprintf(changename[depth], \"%.*s-%s: compound\",\n\t\t\t\t sp->ts_twordlen, tword, fword + sp->ts_fidx);\n#endif\n\t\t\t// Save things to be restored at STATE_SPLITUNDO.\n\t\t\tsp->ts_save_badflags = su->su_badflags;\n\t\t\tPROF_STORE(sp->ts_state)\n\t\t\tsp->ts_state = STATE_SPLITUNDO;\n\n\t\t\t++depth;\n\t\t\tsp = &stack[depth];\n\n\t\t\t// Append a space to preword when splitting.\n\t\t\tif (!try_compound && !fword_ends)\n\t\t\t    STRCAT(preword, \" \");\n\t\t\tsp->ts_prewordlen = (char_u)STRLEN(preword);\n\t\t\tsp->ts_splitoff = sp->ts_twordlen;\n\t\t\tsp->ts_splitfidx = sp->ts_fidx;\n\n\t\t\t// If the badword has a non-word character at this\n\t\t\t// position skip it.  That means replacing the\n\t\t\t// non-word character with a space.  Always skip a\n\t\t\t// character when the word ends.  But only when the\n\t\t\t// good word can end.\n\t\t\tif (((!try_compound && !spell_iswordp_nmw(fword\n\t\t\t\t\t\t\t       + sp->ts_fidx,\n\t\t\t\t\t\t\t       curwin))\n\t\t\t\t    || fword_ends)\n\t\t\t\t&& fword[sp->ts_fidx] != NUL\n\t\t\t\t&& goodword_ends)\n\t\t\t{\n\t\t\t    int\t    l;\n\n\t\t\t    l = mb_ptr2len(fword + sp->ts_fidx);\n\t\t\t    if (fword_ends)\n\t\t\t    {\n\t\t\t\t// Copy the skipped character to preword.\n\t\t\t\tmch_memmove(preword + sp->ts_prewordlen,\n\t\t\t\t\t\t      fword + sp->ts_fidx, l);\n\t\t\t\tsp->ts_prewordlen += l;\n\t\t\t\tpreword[sp->ts_prewordlen] = NUL;\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tsp->ts_score -= SCORE_SPLIT - SCORE_SUBST;\n\t\t\t    sp->ts_fidx += l;\n\t\t\t}\n\n\t\t\t// When compounding include compound flag in\n\t\t\t// compflags[] (already set above).  When splitting we\n\t\t\t// may start compounding over again.\n\t\t\tif (try_compound)\n\t\t\t    ++sp->ts_complen;\n\t\t\telse\n\t\t\t    sp->ts_compsplit = sp->ts_complen;\n\t\t\tsp->ts_prefixdepth = PFD_NOPREFIX;\n\n\t\t\t// set su->su_badflags to the caps type at this\n\t\t\t// position\n\t\t\tif (has_mbyte)\n\t\t\t    n = nofold_len(fword, sp->ts_fidx, su->su_badptr);\n\t\t\telse\n\t\t\t    n = sp->ts_fidx;\n\t\t\tsu->su_badflags = badword_captype(su->su_badptr + n,\n\t\t\t\t\t       su->su_badptr + su->su_badlen);\n\n\t\t\t// Restart at top of the tree.\n\t\t\tsp->ts_arridx = 0;\n\n\t\t\t// If there are postponed prefixes, try these too.\n\t\t\tif (pbyts != NULL)\n\t\t\t{\n\t\t\t    byts = pbyts;\n\t\t\t    idxs = pidxs;\n\t\t\t    sp->ts_prefixdepth = PFD_PREFIXTREE;\n\t\t\t    PROF_STORE(sp->ts_state)\n\t\t\t    sp->ts_state = STATE_NOPREFIX;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\n\tcase STATE_SPLITUNDO:\n\t    // Undo the changes done for word split or compound word.\n\t    su->su_badflags = sp->ts_save_badflags;\n\n\t    // Continue looking for NUL bytes.\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_START;\n\n\t    // In case we went into the prefix tree.\n\t    byts = fbyts;\n\t    idxs = fidxs;\n\t    break;\n\n\tcase STATE_ENDNUL:\n\t    // Past the NUL bytes in the node.\n\t    su->su_badflags = sp->ts_save_badflags;\n\t    if (fword[sp->ts_fidx] == NUL && sp->ts_tcharlen == 0)\n\t    {\n\t\t// The badword ends, can't use STATE_PLAIN.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_DEL;\n\t\tbreak;\n\t    }\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_PLAIN;\n\t    // FALLTHROUGH\n\n\tcase STATE_PLAIN:\n\t    // Go over all possible bytes at this node, add each to tword[]\n\t    // and use child node.  \"ts_curi\" is the index.\n\t    arridx = sp->ts_arridx;\n\t    if (sp->ts_curi > byts[arridx])\n\t    {\n\t\t// Done all bytes at this node, do next state.  When still at\n\t\t// already changed bytes skip the other tricks.\n\t\tPROF_STORE(sp->ts_state)\n\t\tif (sp->ts_fidx >= sp->ts_fidxtry)\n\t\t    sp->ts_state = STATE_DEL;\n\t\telse\n\t\t    sp->ts_state = STATE_FINAL;\n\t    }\n\t    else\n\t    {\n\t\tarridx += sp->ts_curi++;\n\t\tc = byts[arridx];\n\n\t\t// Normal byte, go one level deeper.  If it's not equal to the\n\t\t// byte in the bad word adjust the score.  But don't even try\n\t\t// when the byte was already changed.  And don't try when we\n\t\t// just deleted this byte, accepting it is always cheaper than\n\t\t// delete + substitute.\n\t\tif (c == fword[sp->ts_fidx]\n\t\t\t|| (sp->ts_tcharlen > 0 && sp->ts_isdiff != DIFF_NONE))\n\t\t    newscore = 0;\n\t\telse\n\t\t    newscore = SCORE_SUBST;\n\t\tif ((newscore == 0\n\t\t\t    || (sp->ts_fidx >= sp->ts_fidxtry\n\t\t\t\t&& ((sp->ts_flags & TSF_DIDDEL) == 0\n\t\t\t\t    || c != fword[sp->ts_delidx])))\n\t\t\t&& TRY_DEEPER(su, stack, depth, newscore))\n\t\t{\n\t\t    go_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\t    if (newscore > 0)\n\t\t\tsprintf(changename[depth], \"%.*s-%s: subst %c to %c\",\n\t\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t\tfword[sp->ts_fidx], c);\n\t\t    else\n\t\t\tsprintf(changename[depth], \"%.*s-%s: accept %c\",\n\t\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t\tfword[sp->ts_fidx]);\n#endif\n\t\t    ++depth;\n\t\t    sp = &stack[depth];\n\t\t    if (fword[sp->ts_fidx] != NUL)\n\t\t\t++sp->ts_fidx;\n\t\t    tword[sp->ts_twordlen++] = c;\n\t\t    sp->ts_arridx = idxs[arridx];\n\t\t    if (newscore == SCORE_SUBST)\n\t\t\tsp->ts_isdiff = DIFF_YES;\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\t// Multi-byte characters are a bit complicated to\n\t\t\t// handle: They differ when any of the bytes differ\n\t\t\t// and then their length may also differ.\n\t\t\tif (sp->ts_tcharlen == 0)\n\t\t\t{\n\t\t\t    // First byte.\n\t\t\t    sp->ts_tcharidx = 0;\n\t\t\t    sp->ts_tcharlen = MB_BYTE2LEN(c);\n\t\t\t    sp->ts_fcharstart = sp->ts_fidx - 1;\n\t\t\t    sp->ts_isdiff = (newscore != 0)\n\t\t\t\t\t\t       ? DIFF_YES : DIFF_NONE;\n\t\t\t}\n\t\t\telse if (sp->ts_isdiff == DIFF_INSERT)\n\t\t\t    // When inserting trail bytes don't advance in the\n\t\t\t    // bad word.\n\t\t\t    --sp->ts_fidx;\n\t\t\tif (++sp->ts_tcharidx == sp->ts_tcharlen)\n\t\t\t{\n\t\t\t    // Last byte of character.\n\t\t\t    if (sp->ts_isdiff == DIFF_YES)\n\t\t\t    {\n\t\t\t\t// Correct ts_fidx for the byte length of the\n\t\t\t\t// character (we didn't check that before).\n\t\t\t\tsp->ts_fidx = sp->ts_fcharstart\n\t\t\t\t\t    + mb_ptr2len(\n\t\t\t\t\t\t    fword + sp->ts_fcharstart);\n\t\t\t\t// For changing a composing character adjust\n\t\t\t\t// the score from SCORE_SUBST to\n\t\t\t\t// SCORE_SUBCOMP.\n\t\t\t\tif (enc_utf8\n\t\t\t\t\t&& utf_iscomposing(\n\t\t\t\t\t    utf_ptr2char(tword\n\t\t\t\t\t\t+ sp->ts_twordlen\n\t\t\t\t\t\t\t   - sp->ts_tcharlen))\n\t\t\t\t\t&& utf_iscomposing(\n\t\t\t\t\t    utf_ptr2char(fword\n\t\t\t\t\t\t\t+ sp->ts_fcharstart)))\n\t\t\t\t    sp->ts_score -=\n\t\t\t\t\t\t  SCORE_SUBST - SCORE_SUBCOMP;\n\n\t\t\t\t// For a similar character adjust score from\n\t\t\t\t// SCORE_SUBST to SCORE_SIMILAR.\n\t\t\t\telse if (!soundfold\n\t\t\t\t\t&& slang->sl_has_map\n\t\t\t\t\t&& similar_chars(slang,\n\t\t\t\t\t    mb_ptr2char(tword\n\t\t\t\t\t\t+ sp->ts_twordlen\n\t\t\t\t\t\t\t   - sp->ts_tcharlen),\n\t\t\t\t\t    mb_ptr2char(fword\n\t\t\t\t\t\t\t+ sp->ts_fcharstart)))\n\t\t\t\t    sp->ts_score -=\n\t\t\t\t\t\t  SCORE_SUBST - SCORE_SIMILAR;\n\t\t\t    }\n\t\t\t    else if (sp->ts_isdiff == DIFF_INSERT\n\t\t\t\t\t && sp->ts_twordlen > sp->ts_tcharlen)\n\t\t\t    {\n\t\t\t\tp = tword + sp->ts_twordlen - sp->ts_tcharlen;\n\t\t\t\tc = mb_ptr2char(p);\n\t\t\t\tif (enc_utf8 && utf_iscomposing(c))\n\t\t\t\t{\n\t\t\t\t    // Inserting a composing char doesn't\n\t\t\t\t    // count that much.\n\t\t\t\t    sp->ts_score -= SCORE_INS - SCORE_INSCOMP;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    // If the previous character was the same,\n\t\t\t\t    // thus doubling a character, give a bonus\n\t\t\t\t    // to the score.  Also for the soundfold\n\t\t\t\t    // tree (might seem illogical but does\n\t\t\t\t    // give better scores).\n\t\t\t\t    MB_PTR_BACK(tword, p);\n\t\t\t\t    if (c == mb_ptr2char(p))\n\t\t\t\t\tsp->ts_score -= SCORE_INS\n\t\t\t\t\t\t\t       - SCORE_INSDUP;\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t    // Starting a new char, reset the length.\n\t\t\t    sp->ts_tcharlen = 0;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// If we found a similar char adjust the score.\n\t\t\t// We do this after calling go_deeper() because\n\t\t\t// it's slow.\n\t\t\tif (newscore != 0\n\t\t\t\t&& !soundfold\n\t\t\t\t&& slang->sl_has_map\n\t\t\t\t&& similar_chars(slang,\n\t\t\t\t\t\t   c, fword[sp->ts_fidx - 1]))\n\t\t\t    sp->ts_score -= SCORE_SUBST - SCORE_SIMILAR;\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\n\tcase STATE_DEL:\n\t    // When past the first byte of a multi-byte char don't try\n\t    // delete/insert/swap a character.\n\t    if (has_mbyte && sp->ts_tcharlen > 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\t    // Try skipping one character in the bad word (delete it).\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_INS_PREP;\n\t    sp->ts_curi = 1;\n\t    if (soundfold && sp->ts_fidx == 0 && fword[sp->ts_fidx] == '*')\n\t\t// Deleting a vowel at the start of a word counts less, see\n\t\t// soundalike_score().\n\t\tnewscore = 2 * SCORE_DEL / 3;\n\t    else\n\t\tnewscore = SCORE_DEL;\n\t    if (fword[sp->ts_fidx] != NUL\n\t\t\t\t    && TRY_DEEPER(su, stack, depth, newscore))\n\t    {\n\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: delete %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tfword[sp->ts_fidx]);\n#endif\n\t\t++depth;\n\n\t\t// Remember what character we deleted, so that we can avoid\n\t\t// inserting it again.\n\t\tstack[depth].ts_flags |= TSF_DIDDEL;\n\t\tstack[depth].ts_delidx = sp->ts_fidx;\n\n\t\t// Advance over the character in fword[].  Give a bonus to the\n\t\t// score if the same character is following \"nn\" -> \"n\".  It's\n\t\t// a bit illogical for soundfold tree but it does give better\n\t\t// results.\n\t\tif (has_mbyte)\n\t\t{\n\t\t    c = mb_ptr2char(fword + sp->ts_fidx);\n\t\t    stack[depth].ts_fidx += mb_ptr2len(fword + sp->ts_fidx);\n\t\t    if (enc_utf8 && utf_iscomposing(c))\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELCOMP;\n\t\t    else if (c == mb_ptr2char(fword + stack[depth].ts_fidx))\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++stack[depth].ts_fidx;\n\t\t    if (fword[sp->ts_fidx] == fword[sp->ts_fidx + 1])\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;\n\t\t}\n\t\tbreak;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase STATE_INS_PREP:\n\t    if (sp->ts_flags & TSF_DIDDEL)\n\t    {\n\t\t// If we just deleted a byte then inserting won't make sense,\n\t\t// a substitute is always cheaper.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP;\n\t\tbreak;\n\t    }\n\n\t    // skip over NUL bytes\n\t    n = sp->ts_arridx;\n\t    for (;;)\n\t    {\n\t\tif (sp->ts_curi > byts[n])\n\t\t{\n\t\t    // Only NUL bytes at this node, go to next state.\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_SWAP;\n\t\t    break;\n\t\t}\n\t\tif (byts[n + sp->ts_curi] != NUL)\n\t\t{\n\t\t    // Found a byte to insert.\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_INS;\n\t\t    break;\n\t\t}\n\t\t++sp->ts_curi;\n\t    }\n\t    break;\n\n\t    // FALLTHROUGH\n\n\tcase STATE_INS:\n\t    // Insert one byte.  Repeat this for each possible byte at this\n\t    // node.\n\t    n = sp->ts_arridx;\n\t    if (sp->ts_curi > byts[n])\n\t    {\n\t\t// Done all bytes at this node, go to next state.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP;\n\t\tbreak;\n\t    }\n\n\t    // Do one more byte at this node, but:\n\t    // - Skip NUL bytes.\n\t    // - Skip the byte if it's equal to the byte in the word,\n\t    //   accepting that byte is always better.\n\t    n += sp->ts_curi++;\n\t    c = byts[n];\n\t    if (soundfold && sp->ts_twordlen == 0 && c == '*')\n\t\t// Inserting a vowel at the start of a word counts less,\n\t\t// see soundalike_score().\n\t\tnewscore = 2 * SCORE_INS / 3;\n\t    else\n\t\tnewscore = SCORE_INS;\n\t    if (c != fword[sp->ts_fidx]\n\t\t\t\t    && TRY_DEEPER(su, stack, depth, newscore))\n\t    {\n\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: insert %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc);\n#endif\n\t\t++depth;\n\t\tsp = &stack[depth];\n\t\ttword[sp->ts_twordlen++] = c;\n\t\tsp->ts_arridx = idxs[n];\n\t\tif (has_mbyte)\n\t\t{\n\t\t    fl = MB_BYTE2LEN(c);\n\t\t    if (fl > 1)\n\t\t    {\n\t\t\t// There are following bytes for the same character.\n\t\t\t// We must find all bytes before trying\n\t\t\t// delete/insert/swap/etc.\n\t\t\tsp->ts_tcharlen = fl;\n\t\t\tsp->ts_tcharidx = 1;\n\t\t\tsp->ts_isdiff = DIFF_INSERT;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    fl = 1;\n\t\tif (fl == 1)\n\t\t{\n\t\t    // If the previous character was the same, thus doubling a\n\t\t    // character, give a bonus to the score.  Also for\n\t\t    // soundfold words (illogical but does give a better\n\t\t    // score).\n\t\t    if (sp->ts_twordlen >= 2\n\t\t\t\t\t   && tword[sp->ts_twordlen - 2] == c)\n\t\t\tsp->ts_score -= SCORE_INS - SCORE_INSDUP;\n\t\t}\n\t    }\n\t    break;\n\n\tcase STATE_SWAP:\n\t    // Swap two bytes in the bad word: \"12\" -> \"21\".\n\t    // We change \"fword\" here, it's changed back afterwards at\n\t    // STATE_UNSWAP.\n\t    p = fword + sp->ts_fidx;\n\t    c = *p;\n\t    if (c == NUL)\n\t    {\n\t\t// End of word, can't swap or replace.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\n\t    // Don't swap if the first character is not a word character.\n\t    // SWAP3 etc. also don't make sense then.\n\t    if (!soundfold && !spell_iswordp(p, curwin))\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\n\t    if (has_mbyte)\n\t    {\n\t\tn = MB_CPTR2LEN(p);\n\t\tc = mb_ptr2char(p);\n\t\tif (p[n] == NUL)\n\t\t    c2 = NUL;\n\t\telse if (!soundfold && !spell_iswordp(p + n, curwin))\n\t\t    c2 = c; // don't swap non-word char\n\t\telse\n\t\t    c2 = mb_ptr2char(p + n);\n\t    }\n\t    else\n\t    {\n\t\tif (p[1] == NUL)\n\t\t    c2 = NUL;\n\t\telse if (!soundfold && !spell_iswordp(p + 1, curwin))\n\t\t    c2 = c; // don't swap non-word char\n\t\telse\n\t\t    c2 = p[1];\n\t    }\n\n\t    // When the second character is NUL we can't swap.\n\t    if (c2 == NUL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\n\t    // When characters are identical, swap won't do anything.\n\t    // Also get here if the second char is not a word character.\n\t    if (c == c2)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP3;\n\t\tbreak;\n\t    }\n\t    if (c2 != NUL && TRY_DEEPER(su, stack, depth, SCORE_SWAP))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: swap %c and %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc, c2);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNSWAP;\n\t\t++depth;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    fl = mb_char2len(c2);\n\t\t    mch_memmove(p, p + n, fl);\n\t\t    mb_char2bytes(c, p + fl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[0] = c2;\n\t\t    p[1] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 2;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// If this swap doesn't work then SWAP3 won't either.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNSWAP:\n\t    // Undo the STATE_SWAP swap: \"21\" -> \"12\".\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tc = mb_ptr2char(p + n);\n\t\tmch_memmove(p + mb_ptr2len(p + n), p, n);\n\t\tmb_char2bytes(c, p);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[1];\n\t\tp[1] = c;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase STATE_SWAP3:\n\t    // Swap two bytes, skipping one: \"123\" -> \"321\".  We change\n\t    // \"fword\" here, it's changed back afterwards at STATE_UNSWAP3.\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = MB_CPTR2LEN(p);\n\t\tc = mb_ptr2char(p);\n\t\tfl = MB_CPTR2LEN(p + n);\n\t\tc2 = mb_ptr2char(p + n);\n\t\tif (!soundfold && !spell_iswordp(p + n + fl, curwin))\n\t\t    c3 = c;\t// don't swap non-word char\n\t\telse\n\t\t    c3 = mb_ptr2char(p + n + fl);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\tc2 = p[1];\n\t\tif (!soundfold && !spell_iswordp(p + 2, curwin))\n\t\t    c3 = c;\t// don't swap non-word char\n\t\telse\n\t\t    c3 = p[2];\n\t    }\n\n\t    // When characters are identical: \"121\" then SWAP3 result is\n\t    // identical, ROT3L result is same as SWAP: \"211\", ROT3L result is\n\t    // same as SWAP on next char: \"112\".  Thus skip all swapping.\n\t    // Also skip when c3 is NUL.\n\t    // Also get here when the third character is not a word character.\n\t    // Second character may any char: \"a.b\" -> \"b.a\"\n\t    if (c == c3 || c3 == NUL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: swap3 %c and %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc, c3);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNSWAP3;\n\t\t++depth;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    tl = mb_char2len(c3);\n\t\t    mch_memmove(p, p + n + fl, tl);\n\t\t    mb_char2bytes(c2, p + tl);\n\t\t    mb_char2bytes(c, p + fl + tl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl + tl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[0] = p[2];\n\t\t    p[2] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNSWAP3:\n\t    // Undo STATE_SWAP3: \"321\" -> \"123\"\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tc2 = mb_ptr2char(p + n);\n\t\tfl = mb_ptr2len(p + n);\n\t\tc = mb_ptr2char(p + n + fl);\n\t\ttl = mb_ptr2len(p + n + fl);\n\t\tmch_memmove(p + fl + tl, p, n);\n\t\tmb_char2bytes(c, p);\n\t\tmb_char2bytes(c2, p + tl);\n\t\tp = p + tl;\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[2];\n\t\tp[2] = c;\n\t\t++p;\n\t    }\n\n\t    if (!soundfold && !spell_iswordp(p, curwin))\n\t    {\n\t\t// Middle char is not a word char, skip the rotate.  First and\n\t\t// third char were already checked at swap and swap3.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\n\t    // Rotate three characters left: \"123\" -> \"231\".  We change\n\t    // \"fword\" here, it's changed back afterwards at STATE_UNROT3L.\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tp = fword + sp->ts_fidx;\n\t\tsprintf(changename[depth], \"%.*s-%s: rotate left %c%c%c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tp[0], p[1], p[2]);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNROT3L;\n\t\t++depth;\n\t\tp = fword + sp->ts_fidx;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    n = MB_CPTR2LEN(p);\n\t\t    c = mb_ptr2char(p);\n\t\t    fl = MB_CPTR2LEN(p + n);\n\t\t    fl += MB_CPTR2LEN(p + n + fl);\n\t\t    mch_memmove(p, p + n, fl);\n\t\t    mb_char2bytes(c, p + fl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = *p;\n\t\t    *p = p[1];\n\t\t    p[1] = p[2];\n\t\t    p[2] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNROT3L:\n\t    // Undo ROT3L: \"231\" -> \"123\"\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tn += mb_ptr2len(p + n);\n\t\tc = mb_ptr2char(p + n);\n\t\ttl = mb_ptr2len(p + n);\n\t\tmch_memmove(p + tl, p, n);\n\t\tmb_char2bytes(c, p);\n\t    }\n\t    else\n\t    {\n\t\tc = p[2];\n\t\tp[2] = p[1];\n\t\tp[1] = *p;\n\t\t*p = c;\n\t    }\n\n\t    // Rotate three bytes right: \"123\" -> \"312\".  We change \"fword\"\n\t    // here, it's changed back afterwards at STATE_UNROT3R.\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tp = fword + sp->ts_fidx;\n\t\tsprintf(changename[depth], \"%.*s-%s: rotate right %c%c%c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tp[0], p[1], p[2]);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNROT3R;\n\t\t++depth;\n\t\tp = fword + sp->ts_fidx;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    n = MB_CPTR2LEN(p);\n\t\t    n += MB_CPTR2LEN(p + n);\n\t\t    c = mb_ptr2char(p + n);\n\t\t    tl = MB_CPTR2LEN(p + n);\n\t\t    mch_memmove(p + tl, p, n);\n\t\t    mb_char2bytes(c, p);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + tl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = p[2];\n\t\t    p[2] = p[1];\n\t\t    p[1] = *p;\n\t\t    *p = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNROT3R:\n\t    // Undo ROT3R: \"312\" -> \"123\"\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tc = mb_ptr2char(p);\n\t\ttl = mb_ptr2len(p);\n\t\tn = mb_ptr2len(p + tl);\n\t\tn += mb_ptr2len(p + tl + n);\n\t\tmch_memmove(p, p + tl, n);\n\t\tmb_char2bytes(c, p + n);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[1];\n\t\tp[1] = p[2];\n\t\tp[2] = c;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase STATE_REP_INI:\n\t    // Check if matching with REP items from the .aff file would work.\n\t    // Quickly skip if:\n\t    // - there are no REP items and we are not in the soundfold trie\n\t    // - the score is going to be too high anyway\n\t    // - already applied a REP item or swapped here\n\t    if ((lp->lp_replang == NULL && !soundfold)\n\t\t    || sp->ts_score + SCORE_REP >= su->su_maxscore\n\t\t    || sp->ts_fidx < sp->ts_fidxtry)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\n\t    // Use the first byte to quickly find the first entry that may\n\t    // match.  If the index is -1 there is none.\n\t    if (soundfold)\n\t\tsp->ts_curi = slang->sl_repsal_first[fword[sp->ts_fidx]];\n\t    else\n\t\tsp->ts_curi = lp->lp_replang->sl_rep_first[fword[sp->ts_fidx]];\n\n\t    if (sp->ts_curi < 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_REP;\n\t    // FALLTHROUGH\n\n\tcase STATE_REP:\n\t    // Try matching with REP items from the .aff file.  For each match\n\t    // replace the characters and check if the resulting word is\n\t    // valid.\n\t    p = fword + sp->ts_fidx;\n\n\t    if (soundfold)\n\t\tgap = &slang->sl_repsal;\n\t    else\n\t\tgap = &lp->lp_replang->sl_rep;\n\t    while (sp->ts_curi < gap->ga_len)\n\t    {\n\t\tftp = (fromto_T *)gap->ga_data + sp->ts_curi++;\n\t\tif (*ftp->ft_from != *p)\n\t\t{\n\t\t    // past possible matching entries\n\t\t    sp->ts_curi = gap->ga_len;\n\t\t    break;\n\t\t}\n\t\tif (STRNCMP(ftp->ft_from, p, STRLEN(ftp->ft_from)) == 0\n\t\t\t&& TRY_DEEPER(su, stack, depth, SCORE_REP))\n\t\t{\n\t\t    go_deeper(stack, depth, SCORE_REP);\n#ifdef DEBUG_TRIEWALK\n\t\t    sprintf(changename[depth], \"%.*s-%s: replace %s with %s\",\n\t\t\t    sp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t    ftp->ft_from, ftp->ft_to);\n#endif\n\t\t    // Need to undo this afterwards.\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_REP_UNDO;\n\n\t\t    // Change the \"from\" to the \"to\" string.\n\t\t    ++depth;\n\t\t    fl = (int)STRLEN(ftp->ft_from);\n\t\t    tl = (int)STRLEN(ftp->ft_to);\n\t\t    if (fl != tl)\n\t\t    {\n\t\t\tSTRMOVE(p + tl, p + fl);\n\t\t\trepextra += tl - fl;\n\t\t    }\n\t\t    mch_memmove(p, ftp->ft_to, tl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + tl;\n\t\t    stack[depth].ts_tcharlen = 0;\n\t\t    break;\n\t\t}\n\t    }\n\n\t    if (sp->ts_curi >= gap->ga_len && sp->ts_state == STATE_REP)\n\t    {\n\t\t// No (more) matches.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t    }\n\n\t    break;\n\n\tcase STATE_REP_UNDO:\n\t    // Undo a REP replacement and continue with the next one.\n\t    if (soundfold)\n\t\tgap = &slang->sl_repsal;\n\t    else\n\t\tgap = &lp->lp_replang->sl_rep;\n\t    ftp = (fromto_T *)gap->ga_data + sp->ts_curi - 1;\n\t    fl = (int)STRLEN(ftp->ft_from);\n\t    tl = (int)STRLEN(ftp->ft_to);\n\t    p = fword + sp->ts_fidx;\n\t    if (fl != tl)\n\t    {\n\t\tSTRMOVE(p + fl, p + tl);\n\t\trepextra -= tl - fl;\n\t    }\n\t    mch_memmove(p, ftp->ft_from, fl);\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_REP;\n\t    break;\n\n\tdefault:\n\t    // Did all possible states at this level, go up one level.\n\t    --depth;\n\n\t    if (depth >= 0 && stack[depth].ts_prefixdepth == PFD_PREFIXTREE)\n\t    {\n\t\t// Continue in or go back to the prefix tree.\n\t\tbyts = pbyts;\n\t\tidxs = pidxs;\n\t    }\n\n\t    // Don't check for CTRL-C too often, it takes time.\n\t    if (--breakcheckcount == 0)\n\t    {\n\t\tui_breakcheck();\n\t\tbreakcheckcount = 1000;\n#ifdef FEAT_RELTIME\n\t\tif (spell_suggest_timeout > 0\n\t\t\t\t\t  && profile_passed_limit(&time_limit))\n\t\t    got_int = TRUE;\n#endif\n\t    }\n\t}\n    }\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "spellsuggest.c",
        "method_name": "fixed_function",
        "raw_code": "suggest_trie_walk(\n    suginfo_T\t*su,\n    langp_T\t*lp,\n    char_u\t*fword,\n    int\t\tsoundfold)\n{\n    char_u\ttword[MAXWLEN];\t    // good word collected so far\n    trystate_T\tstack[MAXWLEN];\n    char_u\tpreword[MAXWLEN * 3]; // word found with proper case;\n\t\t\t\t      // concatenation of prefix compound\n\t\t\t\t      // words and split word.  NUL terminated\n\t\t\t\t      // when going deeper but not when coming\n\t\t\t\t      // back.\n    char_u\tcompflags[MAXWLEN];\t// compound flags, one for each word\n    trystate_T\t*sp;\n    int\t\tnewscore;\n    int\t\tscore;\n    char_u\t*byts, *fbyts, *pbyts;\n    idx_T\t*idxs, *fidxs, *pidxs;\n    int\t\tdepth;\n    int\t\tc, c2, c3;\n    int\t\tn = 0;\n    int\t\tflags;\n    garray_T\t*gap;\n    idx_T\tarridx;\n    int\t\tlen;\n    char_u\t*p;\n    fromto_T\t*ftp;\n    int\t\tfl = 0, tl;\n    int\t\trepextra = 0;\t    // extra bytes in fword[] from REP item\n    slang_T\t*slang = lp->lp_slang;\n    int\t\tfword_ends;\n    int\t\tgoodword_ends;\n#ifdef DEBUG_TRIEWALK\n    // Stores the name of the change made at each level.\n    char_u\tchangename[MAXWLEN][80];\n#endif\n    int\t\tbreakcheckcount = 1000;\n#ifdef FEAT_RELTIME\n    proftime_T\ttime_limit;\n#endif\n    int\t\tcompound_ok;\n\n    // Go through the whole case-fold tree, try changes at each node.\n    // \"tword[]\" contains the word collected from nodes in the tree.\n    // \"fword[]\" the word we are trying to match with (initially the bad\n    // word).\n    depth = 0;\n    sp = &stack[0];\n    CLEAR_POINTER(sp);\n    sp->ts_curi = 1;\n\n    if (soundfold)\n    {\n\t// Going through the soundfold tree.\n\tbyts = fbyts = slang->sl_sbyts;\n\tidxs = fidxs = slang->sl_sidxs;\n\tpbyts = NULL;\n\tpidxs = NULL;\n\tsp->ts_prefixdepth = PFD_NOPREFIX;\n\tsp->ts_state = STATE_START;\n    }\n    else\n    {\n\t// When there are postponed prefixes we need to use these first.  At\n\t// the end of the prefix we continue in the case-fold tree.\n\tfbyts = slang->sl_fbyts;\n\tfidxs = slang->sl_fidxs;\n\tpbyts = slang->sl_pbyts;\n\tpidxs = slang->sl_pidxs;\n\tif (pbyts != NULL)\n\t{\n\t    byts = pbyts;\n\t    idxs = pidxs;\n\t    sp->ts_prefixdepth = PFD_PREFIXTREE;\n\t    sp->ts_state = STATE_NOPREFIX;\t// try without prefix first\n\t}\n\telse\n\t{\n\t    byts = fbyts;\n\t    idxs = fidxs;\n\t    sp->ts_prefixdepth = PFD_NOPREFIX;\n\t    sp->ts_state = STATE_START;\n\t}\n    }\n#ifdef FEAT_RELTIME\n    // The loop may take an indefinite amount of time. Break out after some\n    // time.\n    if (spell_suggest_timeout > 0)\n\tprofile_setlimit(spell_suggest_timeout, &time_limit);\n#endif\n\n    // Loop to find all suggestions.  At each round we either:\n    // - For the current state try one operation, advance \"ts_curi\",\n    //   increase \"depth\".\n    // - When a state is done go to the next, set \"ts_state\".\n    // - When all states are tried decrease \"depth\".\n    while (depth >= 0 && !got_int)\n    {\n\tsp = &stack[depth];\n\tswitch (sp->ts_state)\n\t{\n\tcase STATE_START:\n\tcase STATE_NOPREFIX:\n\t    // Start of node: Deal with NUL bytes, which means\n\t    // tword[] may end here.\n\t    arridx = sp->ts_arridx;\t    // current node in the tree\n\t    len = byts[arridx];\t\t    // bytes in this node\n\t    arridx += sp->ts_curi;\t    // index of current byte\n\n\t    if (sp->ts_prefixdepth == PFD_PREFIXTREE)\n\t    {\n\t\t// Skip over the NUL bytes, we use them later.\n\t\tfor (n = 0; n < len && byts[arridx + n] == 0; ++n)\n\t\t    ;\n\t\tsp->ts_curi += n;\n\n\t\t// Always past NUL bytes now.\n\t\tn = (int)sp->ts_state;\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_ENDNUL;\n\t\tsp->ts_save_badflags = su->su_badflags;\n\n\t\t// At end of a prefix or at start of prefixtree: check for\n\t\t// following word.\n\t\tif (depth < MAXWLEN - 1\n\t\t\t    && (byts[arridx] == 0 || n == (int)STATE_NOPREFIX))\n\t\t{\n\t\t    // Set su->su_badflags to the caps type at this position.\n\t\t    // Use the caps type until here for the prefix itself.\n\t\t    if (has_mbyte)\n\t\t\tn = nofold_len(fword, sp->ts_fidx, su->su_badptr);\n\t\t    else\n\t\t\tn = sp->ts_fidx;\n\t\t    flags = badword_captype(su->su_badptr, su->su_badptr + n);\n\t\t    su->su_badflags = badword_captype(su->su_badptr + n,\n\t\t\t\t\t       su->su_badptr + su->su_badlen);\n#ifdef DEBUG_TRIEWALK\n\t\t    sprintf(changename[depth], \"prefix\");\n#endif\n\t\t    go_deeper(stack, depth, 0);\n\t\t    ++depth;\n\t\t    sp = &stack[depth];\n\t\t    sp->ts_prefixdepth = depth - 1;\n\t\t    byts = fbyts;\n\t\t    idxs = fidxs;\n\t\t    sp->ts_arridx = 0;\n\n\t\t    // Move the prefix to preword[] with the right case\n\t\t    // and make find_keepcap_word() works.\n\t\t    tword[sp->ts_twordlen] = NUL;\n\t\t    make_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t  preword + sp->ts_prewordlen, flags);\n\t\t    sp->ts_prewordlen = (char_u)STRLEN(preword);\n\t\t    sp->ts_splitoff = sp->ts_twordlen;\n\t\t}\n\t\tbreak;\n\t    }\n\n\t    if (sp->ts_curi > len || byts[arridx] != 0)\n\t    {\n\t\t// Past bytes in node and/or past NUL bytes.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_ENDNUL;\n\t\tsp->ts_save_badflags = su->su_badflags;\n\t\tbreak;\n\t    }\n\n\t    // End of word in tree.\n\t    ++sp->ts_curi;\t\t// eat one NUL byte\n\n\t    flags = (int)idxs[arridx];\n\n\t    // Skip words with the NOSUGGEST flag.\n\t    if (flags & WF_NOSUGGEST)\n\t\tbreak;\n\n\t    fword_ends = (fword[sp->ts_fidx] == NUL\n\t\t\t   || (soundfold\n\t\t\t       ? VIM_ISWHITE(fword[sp->ts_fidx])\n\t\t\t       : !spell_iswordp(fword + sp->ts_fidx, curwin)));\n\t    tword[sp->ts_twordlen] = NUL;\n\n\t    if (sp->ts_prefixdepth <= PFD_NOTSPECIAL\n\t\t\t\t\t&& (sp->ts_flags & TSF_PREFIXOK) == 0\n\t\t\t\t\t&& pbyts != NULL)\n\t    {\n\t\t// There was a prefix before the word.  Check that the prefix\n\t\t// can be used with this word.\n\t\t// Count the length of the NULs in the prefix.  If there are\n\t\t// none this must be the first try without a prefix.\n\t\tn = stack[sp->ts_prefixdepth].ts_arridx;\n\t\tlen = pbyts[n++];\n\t\tfor (c = 0; c < len && pbyts[n + c] == 0; ++c)\n\t\t    ;\n\t\tif (c > 0)\n\t\t{\n\t\t    c = valid_word_prefix(c, n, flags,\n\t\t\t\t       tword + sp->ts_splitoff, slang, FALSE);\n\t\t    if (c == 0)\n\t\t\tbreak;\n\n\t\t    // Use the WF_RARE flag for a rare prefix.\n\t\t    if (c & WF_RAREPFX)\n\t\t\tflags |= WF_RARE;\n\n\t\t    // Tricky: when checking for both prefix and compounding\n\t\t    // we run into the prefix flag first.\n\t\t    // Remember that it's OK, so that we accept the prefix\n\t\t    // when arriving at a compound flag.\n\t\t    sp->ts_flags |= TSF_PREFIXOK;\n\t\t}\n\t    }\n\n\t    // Check NEEDCOMPOUND: can't use word without compounding.  Do try\n\t    // appending another compound word below.\n\t    if (sp->ts_complen == sp->ts_compsplit && fword_ends\n\t\t\t\t\t\t     && (flags & WF_NEEDCOMP))\n\t\tgoodword_ends = FALSE;\n\t    else\n\t\tgoodword_ends = TRUE;\n\n\t    p = NULL;\n\t    compound_ok = TRUE;\n\t    if (sp->ts_complen > sp->ts_compsplit)\n\t    {\n\t\tif (slang->sl_nobreak)\n\t\t{\n\t\t    // There was a word before this word.  When there was no\n\t\t    // change in this word (it was correct) add the first word\n\t\t    // as a suggestion.  If this word was corrected too, we\n\t\t    // need to check if a correct word follows.\n\t\t    if (sp->ts_fidx - sp->ts_splitfidx\n\t\t\t\t\t  == sp->ts_twordlen - sp->ts_splitoff\n\t\t\t    && STRNCMP(fword + sp->ts_splitfidx,\n\t\t\t\t\ttword + sp->ts_splitoff,\n\t\t\t\t\t sp->ts_fidx - sp->ts_splitfidx) == 0)\n\t\t    {\n\t\t\tpreword[sp->ts_prewordlen] = NUL;\n\t\t\tnewscore = score_wordcount_adj(slang, sp->ts_score,\n\t\t\t\t\t\t preword + sp->ts_prewordlen,\n\t\t\t\t\t\t sp->ts_prewordlen > 0);\n\t\t\t// Add the suggestion if the score isn't too bad.\n\t\t\tif (newscore <= su->su_maxscore)\n\t\t\t    add_suggestion(su, &su->su_ga, preword,\n\t\t\t\t    sp->ts_splitfidx - repextra,\n\t\t\t\t    newscore, 0, FALSE,\n\t\t\t\t    lp->lp_sallang, FALSE);\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    // There was a compound word before this word.  If this\n\t\t    // word does not support compounding then give up\n\t\t    // (splitting is tried for the word without compound\n\t\t    // flag).\n\t\t    if (((unsigned)flags >> 24) == 0\n\t\t\t    || sp->ts_twordlen - sp->ts_splitoff\n\t\t\t\t\t\t       < slang->sl_compminlen)\n\t\t\tbreak;\n\t\t    // For multi-byte chars check character length against\n\t\t    // COMPOUNDMIN.\n\t\t    if (has_mbyte\n\t\t\t    && slang->sl_compminlen > 0\n\t\t\t    && mb_charlen(tword + sp->ts_splitoff)\n\t\t\t\t\t\t       < slang->sl_compminlen)\n\t\t\tbreak;\n\n\t\t    compflags[sp->ts_complen] = ((unsigned)flags >> 24);\n\t\t    compflags[sp->ts_complen + 1] = NUL;\n\t\t    vim_strncpy(preword + sp->ts_prewordlen,\n\t\t\t    tword + sp->ts_splitoff,\n\t\t\t    sp->ts_twordlen - sp->ts_splitoff);\n\n\t\t    // Verify CHECKCOMPOUNDPATTERN  rules.\n\t\t    if (match_checkcompoundpattern(preword,  sp->ts_prewordlen,\n\t\t\t\t\t\t\t  &slang->sl_comppat))\n\t\t\tcompound_ok = FALSE;\n\n\t\t    if (compound_ok)\n\t\t    {\n\t\t\tp = preword;\n\t\t\twhile (*skiptowhite(p) != NUL)\n\t\t\t    p = skipwhite(skiptowhite(p));\n\t\t\tif (fword_ends && !can_compound(slang, p,\n\t\t\t\t\t\tcompflags + sp->ts_compsplit))\n\t\t\t    // Compound is not allowed.  But it may still be\n\t\t\t    // possible if we add another (short) word.\n\t\t\t    compound_ok = FALSE;\n\t\t    }\n\n\t\t    // Get pointer to last char of previous word.\n\t\t    p = preword + sp->ts_prewordlen;\n\t\t    MB_PTR_BACK(preword, p);\n\t\t}\n\t    }\n\n\t    // Form the word with proper case in preword.\n\t    // If there is a word from a previous split, append.\n\t    // For the soundfold tree don't change the case, simply append.\n\t    if (soundfold)\n\t\tSTRCPY(preword + sp->ts_prewordlen, tword + sp->ts_splitoff);\n\t    else if (flags & WF_KEEPCAP)\n\t\t// Must find the word in the keep-case tree.\n\t\tfind_keepcap_word(slang, tword + sp->ts_splitoff,\n\t\t\t\t\t\t preword + sp->ts_prewordlen);\n\t    else\n\t    {\n\t\t// Include badflags: If the badword is onecap or allcap\n\t\t// use that for the goodword too.  But if the badword is\n\t\t// allcap and it's only one char long use onecap.\n\t\tc = su->su_badflags;\n\t\tif ((c & WF_ALLCAP)\n\t\t\t&& su->su_badlen == (*mb_ptr2len)(su->su_badptr))\n\t\t    c = WF_ONECAP;\n\t\tc |= flags;\n\n\t\t// When appending a compound word after a word character don't\n\t\t// use Onecap.\n\t\tif (p != NULL && spell_iswordp_nmw(p, curwin))\n\t\t    c &= ~WF_ONECAP;\n\t\tmake_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t      preword + sp->ts_prewordlen, c);\n\t    }\n\n\t    if (!soundfold)\n\t    {\n\t\t// Don't use a banned word.  It may appear again as a good\n\t\t// word, thus remember it.\n\t\tif (flags & WF_BANNED)\n\t\t{\n\t\t    add_banned(su, preword + sp->ts_prewordlen);\n\t\t    break;\n\t\t}\n\t\tif ((sp->ts_complen == sp->ts_compsplit\n\t\t\t    && WAS_BANNED(su, preword + sp->ts_prewordlen))\n\t\t\t\t\t\t   || WAS_BANNED(su, preword))\n\t\t{\n\t\t    if (slang->sl_compprog == NULL)\n\t\t\tbreak;\n\t\t    // the word so far was banned but we may try compounding\n\t\t    goodword_ends = FALSE;\n\t\t}\n\t    }\n\n\t    newscore = 0;\n\t    if (!soundfold)\t// soundfold words don't have flags\n\t    {\n\t\tif ((flags & WF_REGION)\n\t\t\t    && (((unsigned)flags >> 16) & lp->lp_region) == 0)\n\t\t    newscore += SCORE_REGION;\n\t\tif (flags & WF_RARE)\n\t\t    newscore += SCORE_RARE;\n\n\t\tif (!spell_valid_case(su->su_badflags,\n\t\t\t\t  captype(preword + sp->ts_prewordlen, NULL)))\n\t\t    newscore += SCORE_ICASE;\n\t    }\n\n\t    // TODO: how about splitting in the soundfold tree?\n\t    if (fword_ends\n\t\t    && goodword_ends\n\t\t    && sp->ts_fidx >= sp->ts_fidxtry\n\t\t    && compound_ok)\n\t    {\n\t\t// The badword also ends: add suggestions.\n#ifdef DEBUG_TRIEWALK\n\t\tif (soundfold && STRCMP(preword, \"smwrd\") == 0)\n\t\t{\n\t\t    int\t    j;\n\n\t\t    // print the stack of changes that brought us here\n\t\t    smsg(\"------ %s -------\", fword);\n\t\t    for (j = 0; j < depth; ++j)\n\t\t\tsmsg(\"%s\", changename[j]);\n\t\t}\n#endif\n\t\tif (soundfold)\n\t\t{\n\t\t    // For soundfolded words we need to find the original\n\t\t    // words, the edit distance and then add them.\n\t\t    add_sound_suggest(su, preword, sp->ts_score, lp);\n\t\t}\n\t\telse if (sp->ts_fidx > 0)\n\t\t{\n\t\t    // Give a penalty when changing non-word char to word\n\t\t    // char, e.g., \"thes,\" -> \"these\".\n\t\t    p = fword + sp->ts_fidx;\n\t\t    MB_PTR_BACK(fword, p);\n\t\t    if (!spell_iswordp(p, curwin) && *preword != NUL)\n\t\t    {\n\t\t\tp = preword + STRLEN(preword);\n\t\t\tMB_PTR_BACK(preword, p);\n\t\t\tif (spell_iswordp(p, curwin))\n\t\t\t    newscore += SCORE_NONWORD;\n\t\t    }\n\n\t\t    // Give a bonus to words seen before.\n\t\t    score = score_wordcount_adj(slang,\n\t\t\t\t\t\tsp->ts_score + newscore,\n\t\t\t\t\t\tpreword + sp->ts_prewordlen,\n\t\t\t\t\t\tsp->ts_prewordlen > 0);\n\n\t\t    // Add the suggestion if the score isn't too bad.\n\t\t    if (score <= su->su_maxscore)\n\t\t    {\n\t\t\tadd_suggestion(su, &su->su_ga, preword,\n\t\t\t\t    sp->ts_fidx - repextra,\n\t\t\t\t    score, 0, FALSE, lp->lp_sallang, FALSE);\n\n\t\t\tif (su->su_badflags & WF_MIXCAP)\n\t\t\t{\n\t\t\t    // We really don't know if the word should be\n\t\t\t    // upper or lower case, add both.\n\t\t\t    c = captype(preword, NULL);\n\t\t\t    if (c == 0 || c == WF_ALLCAP)\n\t\t\t    {\n\t\t\t\tmake_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t      preword + sp->ts_prewordlen,\n\t\t\t\t\t\t      c == 0 ? WF_ALLCAP : 0);\n\n\t\t\t\tadd_suggestion(su, &su->su_ga, preword,\n\t\t\t\t\tsp->ts_fidx - repextra,\n\t\t\t\t\tscore + SCORE_ICASE, 0, FALSE,\n\t\t\t\t\tlp->lp_sallang, FALSE);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t    // Try word split and/or compounding.\n\t    if ((sp->ts_fidx >= sp->ts_fidxtry || fword_ends)\n\t\t    // Don't split halfway a character.\n\t\t    && (!has_mbyte || sp->ts_tcharlen == 0))\n\t    {\n\t\tint\ttry_compound;\n\t\tint\ttry_split;\n\n\t\t// If past the end of the bad word don't try a split.\n\t\t// Otherwise try changing the next word.  E.g., find\n\t\t// suggestions for \"the the\" where the second \"the\" is\n\t\t// different.  It's done like a split.\n\t\t// TODO: word split for soundfold words\n\t\ttry_split = (sp->ts_fidx - repextra < su->su_badlen)\n\t\t\t\t\t\t\t\t&& !soundfold;\n\n\t\t// Get here in several situations:\n\t\t// 1. The word in the tree ends:\n\t\t//    If the word allows compounding try that.  Otherwise try\n\t\t//    a split by inserting a space.  For both check that a\n\t\t//    valid words starts at fword[sp->ts_fidx].\n\t\t//    For NOBREAK do like compounding to be able to check if\n\t\t//    the next word is valid.\n\t\t// 2. The badword does end, but it was due to a change (e.g.,\n\t\t//    a swap).  No need to split, but do check that the\n\t\t//    following word is valid.\n\t\t// 3. The badword and the word in the tree end.  It may still\n\t\t//    be possible to compound another (short) word.\n\t\ttry_compound = FALSE;\n\t\tif (!soundfold\n\t\t\t&& !slang->sl_nocompoundsugs\n\t\t\t&& slang->sl_compprog != NULL\n\t\t\t&& ((unsigned)flags >> 24) != 0\n\t\t\t&& sp->ts_twordlen - sp->ts_splitoff\n\t\t\t\t\t\t       >= slang->sl_compminlen\n\t\t\t&& (!has_mbyte\n\t\t\t    || slang->sl_compminlen == 0\n\t\t\t    || mb_charlen(tword + sp->ts_splitoff)\n\t\t\t\t\t\t      >= slang->sl_compminlen)\n\t\t\t&& (slang->sl_compsylmax < MAXWLEN\n\t\t\t    || sp->ts_complen + 1 - sp->ts_compsplit\n\t\t\t\t\t\t\t  < slang->sl_compmax)\n\t\t\t&& (can_be_compound(sp, slang,\n\t\t\t\t\t compflags, ((unsigned)flags >> 24))))\n\n\t\t{\n\t\t    try_compound = TRUE;\n\t\t    compflags[sp->ts_complen] = ((unsigned)flags >> 24);\n\t\t    compflags[sp->ts_complen + 1] = NUL;\n\t\t}\n\n\t\t// For NOBREAK we never try splitting, it won't make any word\n\t\t// valid.\n\t\tif (slang->sl_nobreak && !slang->sl_nocompoundsugs)\n\t\t    try_compound = TRUE;\n\n\t\t// If we could add a compound word, and it's also possible to\n\t\t// split at this point, do the split first and set\n\t\t// TSF_DIDSPLIT to avoid doing it again.\n\t\telse if (!fword_ends\n\t\t\t&& try_compound\n\t\t\t&& (sp->ts_flags & TSF_DIDSPLIT) == 0)\n\t\t{\n\t\t    try_compound = FALSE;\n\t\t    sp->ts_flags |= TSF_DIDSPLIT;\n\t\t    --sp->ts_curi;\t    // do the same NUL again\n\t\t    compflags[sp->ts_complen] = NUL;\n\t\t}\n\t\telse\n\t\t    sp->ts_flags &= ~TSF_DIDSPLIT;\n\n\t\tif (try_split || try_compound)\n\t\t{\n\t\t    if (!try_compound && (!fword_ends || !goodword_ends))\n\t\t    {\n\t\t\t// If we're going to split need to check that the\n\t\t\t// words so far are valid for compounding.  If there\n\t\t\t// is only one word it must not have the NEEDCOMPOUND\n\t\t\t// flag.\n\t\t\tif (sp->ts_complen == sp->ts_compsplit\n\t\t\t\t\t\t     && (flags & WF_NEEDCOMP))\n\t\t\t    break;\n\t\t\tp = preword;\n\t\t\twhile (*skiptowhite(p) != NUL)\n\t\t\t    p = skipwhite(skiptowhite(p));\n\t\t\tif (sp->ts_complen > sp->ts_compsplit\n\t\t\t\t&& !can_compound(slang, p,\n\t\t\t\t\t\tcompflags + sp->ts_compsplit))\n\t\t\t    break;\n\n\t\t\tif (slang->sl_nosplitsugs)\n\t\t\t    newscore += SCORE_SPLIT_NO;\n\t\t\telse\n\t\t\t    newscore += SCORE_SPLIT;\n\n\t\t\t// Give a bonus to words seen before.\n\t\t\tnewscore = score_wordcount_adj(slang, newscore,\n\t\t\t\t\t   preword + sp->ts_prewordlen, TRUE);\n\t\t    }\n\n\t\t    if (TRY_DEEPER(su, stack, depth, newscore))\n\t\t    {\n\t\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\t\tif (!try_compound && !fword_ends)\n\t\t\t    sprintf(changename[depth], \"%.*s-%s: split\",\n\t\t\t\t sp->ts_twordlen, tword, fword + sp->ts_fidx);\n\t\t\telse\n\t\t\t    sprintf(changename[depth], \"%.*s-%s: compound\",\n\t\t\t\t sp->ts_twordlen, tword, fword + sp->ts_fidx);\n#endif\n\t\t\t// Save things to be restored at STATE_SPLITUNDO.\n\t\t\tsp->ts_save_badflags = su->su_badflags;\n\t\t\tPROF_STORE(sp->ts_state)\n\t\t\tsp->ts_state = STATE_SPLITUNDO;\n\n\t\t\t++depth;\n\t\t\tsp = &stack[depth];\n\n\t\t\t// Append a space to preword when splitting.\n\t\t\tif (!try_compound && !fword_ends)\n\t\t\t    STRCAT(preword, \" \");\n\t\t\tsp->ts_prewordlen = (char_u)STRLEN(preword);\n\t\t\tsp->ts_splitoff = sp->ts_twordlen;\n\t\t\tsp->ts_splitfidx = sp->ts_fidx;\n\n\t\t\t// If the badword has a non-word character at this\n\t\t\t// position skip it.  That means replacing the\n\t\t\t// non-word character with a space.  Always skip a\n\t\t\t// character when the word ends.  But only when the\n\t\t\t// good word can end.\n\t\t\tif (((!try_compound && !spell_iswordp_nmw(fword\n\t\t\t\t\t\t\t       + sp->ts_fidx,\n\t\t\t\t\t\t\t       curwin))\n\t\t\t\t    || fword_ends)\n\t\t\t\t&& fword[sp->ts_fidx] != NUL\n\t\t\t\t&& goodword_ends)\n\t\t\t{\n\t\t\t    int\t    l;\n\n\t\t\t    l = mb_ptr2len(fword + sp->ts_fidx);\n\t\t\t    if (fword_ends)\n\t\t\t    {\n\t\t\t\t// Copy the skipped character to preword.\n\t\t\t\tmch_memmove(preword + sp->ts_prewordlen,\n\t\t\t\t\t\t      fword + sp->ts_fidx, l);\n\t\t\t\tsp->ts_prewordlen += l;\n\t\t\t\tpreword[sp->ts_prewordlen] = NUL;\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tsp->ts_score -= SCORE_SPLIT - SCORE_SUBST;\n\t\t\t    sp->ts_fidx += l;\n\t\t\t}\n\n\t\t\t// When compounding include compound flag in\n\t\t\t// compflags[] (already set above).  When splitting we\n\t\t\t// may start compounding over again.\n\t\t\tif (try_compound)\n\t\t\t    ++sp->ts_complen;\n\t\t\telse\n\t\t\t    sp->ts_compsplit = sp->ts_complen;\n\t\t\tsp->ts_prefixdepth = PFD_NOPREFIX;\n\n\t\t\t// set su->su_badflags to the caps type at this\n\t\t\t// position\n\t\t\tif (has_mbyte)\n\t\t\t    n = nofold_len(fword, sp->ts_fidx, su->su_badptr);\n\t\t\telse\n\t\t\t    n = sp->ts_fidx;\n\t\t\tsu->su_badflags = badword_captype(su->su_badptr + n,\n\t\t\t\t\t       su->su_badptr + su->su_badlen);\n\n\t\t\t// Restart at top of the tree.\n\t\t\tsp->ts_arridx = 0;\n\n\t\t\t// If there are postponed prefixes, try these too.\n\t\t\tif (pbyts != NULL)\n\t\t\t{\n\t\t\t    byts = pbyts;\n\t\t\t    idxs = pidxs;\n\t\t\t    sp->ts_prefixdepth = PFD_PREFIXTREE;\n\t\t\t    PROF_STORE(sp->ts_state)\n\t\t\t    sp->ts_state = STATE_NOPREFIX;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\n\tcase STATE_SPLITUNDO:\n\t    // Undo the changes done for word split or compound word.\n\t    su->su_badflags = sp->ts_save_badflags;\n\n\t    // Continue looking for NUL bytes.\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_START;\n\n\t    // In case we went into the prefix tree.\n\t    byts = fbyts;\n\t    idxs = fidxs;\n\t    break;\n\n\tcase STATE_ENDNUL:\n\t    // Past the NUL bytes in the node.\n\t    su->su_badflags = sp->ts_save_badflags;\n\t    if (fword[sp->ts_fidx] == NUL && sp->ts_tcharlen == 0)\n\t    {\n\t\t// The badword ends, can't use STATE_PLAIN.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_DEL;\n\t\tbreak;\n\t    }\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_PLAIN;\n\t    // FALLTHROUGH\n\n\tcase STATE_PLAIN:\n\t    // Go over all possible bytes at this node, add each to tword[]\n\t    // and use child node.  \"ts_curi\" is the index.\n\t    arridx = sp->ts_arridx;\n\t    if (sp->ts_curi > byts[arridx])\n\t    {\n\t\t// Done all bytes at this node, do next state.  When still at\n\t\t// already changed bytes skip the other tricks.\n\t\tPROF_STORE(sp->ts_state)\n\t\tif (sp->ts_fidx >= sp->ts_fidxtry)\n\t\t    sp->ts_state = STATE_DEL;\n\t\telse\n\t\t    sp->ts_state = STATE_FINAL;\n\t    }\n\t    else\n\t    {\n\t\tarridx += sp->ts_curi++;\n\t\tc = byts[arridx];\n\n\t\t// Normal byte, go one level deeper.  If it's not equal to the\n\t\t// byte in the bad word adjust the score.  But don't even try\n\t\t// when the byte was already changed.  And don't try when we\n\t\t// just deleted this byte, accepting it is always cheaper than\n\t\t// delete + substitute.\n\t\tif (c == fword[sp->ts_fidx]\n\t\t\t|| (sp->ts_tcharlen > 0 && sp->ts_isdiff != DIFF_NONE))\n\t\t    newscore = 0;\n\t\telse\n\t\t    newscore = SCORE_SUBST;\n\t\tif ((newscore == 0\n\t\t\t    || (sp->ts_fidx >= sp->ts_fidxtry\n\t\t\t\t&& ((sp->ts_flags & TSF_DIDDEL) == 0\n\t\t\t\t    || c != fword[sp->ts_delidx])))\n\t\t\t&& TRY_DEEPER(su, stack, depth, newscore))\n\t\t{\n\t\t    go_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\t    if (newscore > 0)\n\t\t\tsprintf(changename[depth], \"%.*s-%s: subst %c to %c\",\n\t\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t\tfword[sp->ts_fidx], c);\n\t\t    else\n\t\t\tsprintf(changename[depth], \"%.*s-%s: accept %c\",\n\t\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t\tfword[sp->ts_fidx]);\n#endif\n\t\t    ++depth;\n\t\t    sp = &stack[depth];\n\t\t    if (fword[sp->ts_fidx] != NUL)\n\t\t\t++sp->ts_fidx;\n\t\t    tword[sp->ts_twordlen++] = c;\n\t\t    sp->ts_arridx = idxs[arridx];\n\t\t    if (newscore == SCORE_SUBST)\n\t\t\tsp->ts_isdiff = DIFF_YES;\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\t// Multi-byte characters are a bit complicated to\n\t\t\t// handle: They differ when any of the bytes differ\n\t\t\t// and then their length may also differ.\n\t\t\tif (sp->ts_tcharlen == 0)\n\t\t\t{\n\t\t\t    // First byte.\n\t\t\t    sp->ts_tcharidx = 0;\n\t\t\t    sp->ts_tcharlen = MB_BYTE2LEN(c);\n\t\t\t    sp->ts_fcharstart = sp->ts_fidx - 1;\n\t\t\t    sp->ts_isdiff = (newscore != 0)\n\t\t\t\t\t\t       ? DIFF_YES : DIFF_NONE;\n\t\t\t}\n\t\t\telse if (sp->ts_isdiff == DIFF_INSERT\n\t\t\t\t\t\t\t    && sp->ts_fidx > 0)\n\t\t\t    // When inserting trail bytes don't advance in the\n\t\t\t    // bad word.\n\t\t\t    --sp->ts_fidx;\n\t\t\tif (++sp->ts_tcharidx == sp->ts_tcharlen)\n\t\t\t{\n\t\t\t    // Last byte of character.\n\t\t\t    if (sp->ts_isdiff == DIFF_YES)\n\t\t\t    {\n\t\t\t\t// Correct ts_fidx for the byte length of the\n\t\t\t\t// character (we didn't check that before).\n\t\t\t\tsp->ts_fidx = sp->ts_fcharstart\n\t\t\t\t\t    + mb_ptr2len(\n\t\t\t\t\t\t    fword + sp->ts_fcharstart);\n\t\t\t\t// For changing a composing character adjust\n\t\t\t\t// the score from SCORE_SUBST to\n\t\t\t\t// SCORE_SUBCOMP.\n\t\t\t\tif (enc_utf8\n\t\t\t\t\t&& utf_iscomposing(\n\t\t\t\t\t    utf_ptr2char(tword\n\t\t\t\t\t\t+ sp->ts_twordlen\n\t\t\t\t\t\t\t   - sp->ts_tcharlen))\n\t\t\t\t\t&& utf_iscomposing(\n\t\t\t\t\t    utf_ptr2char(fword\n\t\t\t\t\t\t\t+ sp->ts_fcharstart)))\n\t\t\t\t    sp->ts_score -=\n\t\t\t\t\t\t  SCORE_SUBST - SCORE_SUBCOMP;\n\n\t\t\t\t// For a similar character adjust score from\n\t\t\t\t// SCORE_SUBST to SCORE_SIMILAR.\n\t\t\t\telse if (!soundfold\n\t\t\t\t\t&& slang->sl_has_map\n\t\t\t\t\t&& similar_chars(slang,\n\t\t\t\t\t    mb_ptr2char(tword\n\t\t\t\t\t\t+ sp->ts_twordlen\n\t\t\t\t\t\t\t   - sp->ts_tcharlen),\n\t\t\t\t\t    mb_ptr2char(fword\n\t\t\t\t\t\t\t+ sp->ts_fcharstart)))\n\t\t\t\t    sp->ts_score -=\n\t\t\t\t\t\t  SCORE_SUBST - SCORE_SIMILAR;\n\t\t\t    }\n\t\t\t    else if (sp->ts_isdiff == DIFF_INSERT\n\t\t\t\t\t && sp->ts_twordlen > sp->ts_tcharlen)\n\t\t\t    {\n\t\t\t\tp = tword + sp->ts_twordlen - sp->ts_tcharlen;\n\t\t\t\tc = mb_ptr2char(p);\n\t\t\t\tif (enc_utf8 && utf_iscomposing(c))\n\t\t\t\t{\n\t\t\t\t    // Inserting a composing char doesn't\n\t\t\t\t    // count that much.\n\t\t\t\t    sp->ts_score -= SCORE_INS - SCORE_INSCOMP;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    // If the previous character was the same,\n\t\t\t\t    // thus doubling a character, give a bonus\n\t\t\t\t    // to the score.  Also for the soundfold\n\t\t\t\t    // tree (might seem illogical but does\n\t\t\t\t    // give better scores).\n\t\t\t\t    MB_PTR_BACK(tword, p);\n\t\t\t\t    if (c == mb_ptr2char(p))\n\t\t\t\t\tsp->ts_score -= SCORE_INS\n\t\t\t\t\t\t\t       - SCORE_INSDUP;\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t    // Starting a new char, reset the length.\n\t\t\t    sp->ts_tcharlen = 0;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// If we found a similar char adjust the score.\n\t\t\t// We do this after calling go_deeper() because\n\t\t\t// it's slow.\n\t\t\tif (newscore != 0\n\t\t\t\t&& !soundfold\n\t\t\t\t&& slang->sl_has_map\n\t\t\t\t&& similar_chars(slang,\n\t\t\t\t\t\t   c, fword[sp->ts_fidx - 1]))\n\t\t\t    sp->ts_score -= SCORE_SUBST - SCORE_SIMILAR;\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\n\tcase STATE_DEL:\n\t    // When past the first byte of a multi-byte char don't try\n\t    // delete/insert/swap a character.\n\t    if (has_mbyte && sp->ts_tcharlen > 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\t    // Try skipping one character in the bad word (delete it).\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_INS_PREP;\n\t    sp->ts_curi = 1;\n\t    if (soundfold && sp->ts_fidx == 0 && fword[sp->ts_fidx] == '*')\n\t\t// Deleting a vowel at the start of a word counts less, see\n\t\t// soundalike_score().\n\t\tnewscore = 2 * SCORE_DEL / 3;\n\t    else\n\t\tnewscore = SCORE_DEL;\n\t    if (fword[sp->ts_fidx] != NUL\n\t\t\t\t    && TRY_DEEPER(su, stack, depth, newscore))\n\t    {\n\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: delete %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tfword[sp->ts_fidx]);\n#endif\n\t\t++depth;\n\n\t\t// Remember what character we deleted, so that we can avoid\n\t\t// inserting it again.\n\t\tstack[depth].ts_flags |= TSF_DIDDEL;\n\t\tstack[depth].ts_delidx = sp->ts_fidx;\n\n\t\t// Advance over the character in fword[].  Give a bonus to the\n\t\t// score if the same character is following \"nn\" -> \"n\".  It's\n\t\t// a bit illogical for soundfold tree but it does give better\n\t\t// results.\n\t\tif (has_mbyte)\n\t\t{\n\t\t    c = mb_ptr2char(fword + sp->ts_fidx);\n\t\t    stack[depth].ts_fidx += mb_ptr2len(fword + sp->ts_fidx);\n\t\t    if (enc_utf8 && utf_iscomposing(c))\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELCOMP;\n\t\t    else if (c == mb_ptr2char(fword + stack[depth].ts_fidx))\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++stack[depth].ts_fidx;\n\t\t    if (fword[sp->ts_fidx] == fword[sp->ts_fidx + 1])\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;\n\t\t}\n\t\tbreak;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase STATE_INS_PREP:\n\t    if (sp->ts_flags & TSF_DIDDEL)\n\t    {\n\t\t// If we just deleted a byte then inserting won't make sense,\n\t\t// a substitute is always cheaper.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP;\n\t\tbreak;\n\t    }\n\n\t    // skip over NUL bytes\n\t    n = sp->ts_arridx;\n\t    for (;;)\n\t    {\n\t\tif (sp->ts_curi > byts[n])\n\t\t{\n\t\t    // Only NUL bytes at this node, go to next state.\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_SWAP;\n\t\t    break;\n\t\t}\n\t\tif (byts[n + sp->ts_curi] != NUL)\n\t\t{\n\t\t    // Found a byte to insert.\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_INS;\n\t\t    break;\n\t\t}\n\t\t++sp->ts_curi;\n\t    }\n\t    break;\n\n\t    // FALLTHROUGH\n\n\tcase STATE_INS:\n\t    // Insert one byte.  Repeat this for each possible byte at this\n\t    // node.\n\t    n = sp->ts_arridx;\n\t    if (sp->ts_curi > byts[n])\n\t    {\n\t\t// Done all bytes at this node, go to next state.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP;\n\t\tbreak;\n\t    }\n\n\t    // Do one more byte at this node, but:\n\t    // - Skip NUL bytes.\n\t    // - Skip the byte if it's equal to the byte in the word,\n\t    //   accepting that byte is always better.\n\t    n += sp->ts_curi++;\n\t    c = byts[n];\n\t    if (soundfold && sp->ts_twordlen == 0 && c == '*')\n\t\t// Inserting a vowel at the start of a word counts less,\n\t\t// see soundalike_score().\n\t\tnewscore = 2 * SCORE_INS / 3;\n\t    else\n\t\tnewscore = SCORE_INS;\n\t    if (c != fword[sp->ts_fidx]\n\t\t\t\t    && TRY_DEEPER(su, stack, depth, newscore))\n\t    {\n\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: insert %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc);\n#endif\n\t\t++depth;\n\t\tsp = &stack[depth];\n\t\ttword[sp->ts_twordlen++] = c;\n\t\tsp->ts_arridx = idxs[n];\n\t\tif (has_mbyte)\n\t\t{\n\t\t    fl = MB_BYTE2LEN(c);\n\t\t    if (fl > 1)\n\t\t    {\n\t\t\t// There are following bytes for the same character.\n\t\t\t// We must find all bytes before trying\n\t\t\t// delete/insert/swap/etc.\n\t\t\tsp->ts_tcharlen = fl;\n\t\t\tsp->ts_tcharidx = 1;\n\t\t\tsp->ts_isdiff = DIFF_INSERT;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    fl = 1;\n\t\tif (fl == 1)\n\t\t{\n\t\t    // If the previous character was the same, thus doubling a\n\t\t    // character, give a bonus to the score.  Also for\n\t\t    // soundfold words (illogical but does give a better\n\t\t    // score).\n\t\t    if (sp->ts_twordlen >= 2\n\t\t\t\t\t   && tword[sp->ts_twordlen - 2] == c)\n\t\t\tsp->ts_score -= SCORE_INS - SCORE_INSDUP;\n\t\t}\n\t    }\n\t    break;\n\n\tcase STATE_SWAP:\n\t    // Swap two bytes in the bad word: \"12\" -> \"21\".\n\t    // We change \"fword\" here, it's changed back afterwards at\n\t    // STATE_UNSWAP.\n\t    p = fword + sp->ts_fidx;\n\t    c = *p;\n\t    if (c == NUL)\n\t    {\n\t\t// End of word, can't swap or replace.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\n\t    // Don't swap if the first character is not a word character.\n\t    // SWAP3 etc. also don't make sense then.\n\t    if (!soundfold && !spell_iswordp(p, curwin))\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\n\t    if (has_mbyte)\n\t    {\n\t\tn = MB_CPTR2LEN(p);\n\t\tc = mb_ptr2char(p);\n\t\tif (p[n] == NUL)\n\t\t    c2 = NUL;\n\t\telse if (!soundfold && !spell_iswordp(p + n, curwin))\n\t\t    c2 = c; // don't swap non-word char\n\t\telse\n\t\t    c2 = mb_ptr2char(p + n);\n\t    }\n\t    else\n\t    {\n\t\tif (p[1] == NUL)\n\t\t    c2 = NUL;\n\t\telse if (!soundfold && !spell_iswordp(p + 1, curwin))\n\t\t    c2 = c; // don't swap non-word char\n\t\telse\n\t\t    c2 = p[1];\n\t    }\n\n\t    // When the second character is NUL we can't swap.\n\t    if (c2 == NUL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\n\t    // When characters are identical, swap won't do anything.\n\t    // Also get here if the second char is not a word character.\n\t    if (c == c2)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP3;\n\t\tbreak;\n\t    }\n\t    if (c2 != NUL && TRY_DEEPER(su, stack, depth, SCORE_SWAP))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: swap %c and %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc, c2);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNSWAP;\n\t\t++depth;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    fl = mb_char2len(c2);\n\t\t    mch_memmove(p, p + n, fl);\n\t\t    mb_char2bytes(c, p + fl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[0] = c2;\n\t\t    p[1] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 2;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// If this swap doesn't work then SWAP3 won't either.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNSWAP:\n\t    // Undo the STATE_SWAP swap: \"21\" -> \"12\".\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tc = mb_ptr2char(p + n);\n\t\tmch_memmove(p + mb_ptr2len(p + n), p, n);\n\t\tmb_char2bytes(c, p);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[1];\n\t\tp[1] = c;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase STATE_SWAP3:\n\t    // Swap two bytes, skipping one: \"123\" -> \"321\".  We change\n\t    // \"fword\" here, it's changed back afterwards at STATE_UNSWAP3.\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = MB_CPTR2LEN(p);\n\t\tc = mb_ptr2char(p);\n\t\tfl = MB_CPTR2LEN(p + n);\n\t\tc2 = mb_ptr2char(p + n);\n\t\tif (!soundfold && !spell_iswordp(p + n + fl, curwin))\n\t\t    c3 = c;\t// don't swap non-word char\n\t\telse\n\t\t    c3 = mb_ptr2char(p + n + fl);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\tc2 = p[1];\n\t\tif (!soundfold && !spell_iswordp(p + 2, curwin))\n\t\t    c3 = c;\t// don't swap non-word char\n\t\telse\n\t\t    c3 = p[2];\n\t    }\n\n\t    // When characters are identical: \"121\" then SWAP3 result is\n\t    // identical, ROT3L result is same as SWAP: \"211\", ROT3L result is\n\t    // same as SWAP on next char: \"112\".  Thus skip all swapping.\n\t    // Also skip when c3 is NUL.\n\t    // Also get here when the third character is not a word character.\n\t    // Second character may any char: \"a.b\" -> \"b.a\"\n\t    if (c == c3 || c3 == NUL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: swap3 %c and %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc, c3);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNSWAP3;\n\t\t++depth;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    tl = mb_char2len(c3);\n\t\t    mch_memmove(p, p + n + fl, tl);\n\t\t    mb_char2bytes(c2, p + tl);\n\t\t    mb_char2bytes(c, p + fl + tl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl + tl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[0] = p[2];\n\t\t    p[2] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNSWAP3:\n\t    // Undo STATE_SWAP3: \"321\" -> \"123\"\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tc2 = mb_ptr2char(p + n);\n\t\tfl = mb_ptr2len(p + n);\n\t\tc = mb_ptr2char(p + n + fl);\n\t\ttl = mb_ptr2len(p + n + fl);\n\t\tmch_memmove(p + fl + tl, p, n);\n\t\tmb_char2bytes(c, p);\n\t\tmb_char2bytes(c2, p + tl);\n\t\tp = p + tl;\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[2];\n\t\tp[2] = c;\n\t\t++p;\n\t    }\n\n\t    if (!soundfold && !spell_iswordp(p, curwin))\n\t    {\n\t\t// Middle char is not a word char, skip the rotate.  First and\n\t\t// third char were already checked at swap and swap3.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\n\t    // Rotate three characters left: \"123\" -> \"231\".  We change\n\t    // \"fword\" here, it's changed back afterwards at STATE_UNROT3L.\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tp = fword + sp->ts_fidx;\n\t\tsprintf(changename[depth], \"%.*s-%s: rotate left %c%c%c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tp[0], p[1], p[2]);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNROT3L;\n\t\t++depth;\n\t\tp = fword + sp->ts_fidx;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    n = MB_CPTR2LEN(p);\n\t\t    c = mb_ptr2char(p);\n\t\t    fl = MB_CPTR2LEN(p + n);\n\t\t    fl += MB_CPTR2LEN(p + n + fl);\n\t\t    mch_memmove(p, p + n, fl);\n\t\t    mb_char2bytes(c, p + fl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = *p;\n\t\t    *p = p[1];\n\t\t    p[1] = p[2];\n\t\t    p[2] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNROT3L:\n\t    // Undo ROT3L: \"231\" -> \"123\"\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tn += mb_ptr2len(p + n);\n\t\tc = mb_ptr2char(p + n);\n\t\ttl = mb_ptr2len(p + n);\n\t\tmch_memmove(p + tl, p, n);\n\t\tmb_char2bytes(c, p);\n\t    }\n\t    else\n\t    {\n\t\tc = p[2];\n\t\tp[2] = p[1];\n\t\tp[1] = *p;\n\t\t*p = c;\n\t    }\n\n\t    // Rotate three bytes right: \"123\" -> \"312\".  We change \"fword\"\n\t    // here, it's changed back afterwards at STATE_UNROT3R.\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tp = fword + sp->ts_fidx;\n\t\tsprintf(changename[depth], \"%.*s-%s: rotate right %c%c%c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tp[0], p[1], p[2]);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNROT3R;\n\t\t++depth;\n\t\tp = fword + sp->ts_fidx;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    n = MB_CPTR2LEN(p);\n\t\t    n += MB_CPTR2LEN(p + n);\n\t\t    c = mb_ptr2char(p + n);\n\t\t    tl = MB_CPTR2LEN(p + n);\n\t\t    mch_memmove(p + tl, p, n);\n\t\t    mb_char2bytes(c, p);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + tl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = p[2];\n\t\t    p[2] = p[1];\n\t\t    p[1] = *p;\n\t\t    *p = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\n\tcase STATE_UNROT3R:\n\t    // Undo ROT3R: \"312\" -> \"123\"\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tc = mb_ptr2char(p);\n\t\ttl = mb_ptr2len(p);\n\t\tn = mb_ptr2len(p + tl);\n\t\tn += mb_ptr2len(p + tl + n);\n\t\tmch_memmove(p, p + tl, n);\n\t\tmb_char2bytes(c, p + n);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[1];\n\t\tp[1] = p[2];\n\t\tp[2] = c;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase STATE_REP_INI:\n\t    // Check if matching with REP items from the .aff file would work.\n\t    // Quickly skip if:\n\t    // - there are no REP items and we are not in the soundfold trie\n\t    // - the score is going to be too high anyway\n\t    // - already applied a REP item or swapped here\n\t    if ((lp->lp_replang == NULL && !soundfold)\n\t\t    || sp->ts_score + SCORE_REP >= su->su_maxscore\n\t\t    || sp->ts_fidx < sp->ts_fidxtry)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\n\t    // Use the first byte to quickly find the first entry that may\n\t    // match.  If the index is -1 there is none.\n\t    if (soundfold)\n\t\tsp->ts_curi = slang->sl_repsal_first[fword[sp->ts_fidx]];\n\t    else\n\t\tsp->ts_curi = lp->lp_replang->sl_rep_first[fword[sp->ts_fidx]];\n\n\t    if (sp->ts_curi < 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_REP;\n\t    // FALLTHROUGH\n\n\tcase STATE_REP:\n\t    // Try matching with REP items from the .aff file.  For each match\n\t    // replace the characters and check if the resulting word is\n\t    // valid.\n\t    p = fword + sp->ts_fidx;\n\n\t    if (soundfold)\n\t\tgap = &slang->sl_repsal;\n\t    else\n\t\tgap = &lp->lp_replang->sl_rep;\n\t    while (sp->ts_curi < gap->ga_len)\n\t    {\n\t\tftp = (fromto_T *)gap->ga_data + sp->ts_curi++;\n\t\tif (*ftp->ft_from != *p)\n\t\t{\n\t\t    // past possible matching entries\n\t\t    sp->ts_curi = gap->ga_len;\n\t\t    break;\n\t\t}\n\t\tif (STRNCMP(ftp->ft_from, p, STRLEN(ftp->ft_from)) == 0\n\t\t\t&& TRY_DEEPER(su, stack, depth, SCORE_REP))\n\t\t{\n\t\t    go_deeper(stack, depth, SCORE_REP);\n#ifdef DEBUG_TRIEWALK\n\t\t    sprintf(changename[depth], \"%.*s-%s: replace %s with %s\",\n\t\t\t    sp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t    ftp->ft_from, ftp->ft_to);\n#endif\n\t\t    // Need to undo this afterwards.\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_REP_UNDO;\n\n\t\t    // Change the \"from\" to the \"to\" string.\n\t\t    ++depth;\n\t\t    fl = (int)STRLEN(ftp->ft_from);\n\t\t    tl = (int)STRLEN(ftp->ft_to);\n\t\t    if (fl != tl)\n\t\t    {\n\t\t\tSTRMOVE(p + tl, p + fl);\n\t\t\trepextra += tl - fl;\n\t\t    }\n\t\t    mch_memmove(p, ftp->ft_to, tl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + tl;\n\t\t    stack[depth].ts_tcharlen = 0;\n\t\t    break;\n\t\t}\n\t    }\n\n\t    if (sp->ts_curi >= gap->ga_len && sp->ts_state == STATE_REP)\n\t    {\n\t\t// No (more) matches.\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t    }\n\n\t    break;\n\n\tcase STATE_REP_UNDO:\n\t    // Undo a REP replacement and continue with the next one.\n\t    if (soundfold)\n\t\tgap = &slang->sl_repsal;\n\t    else\n\t\tgap = &lp->lp_replang->sl_rep;\n\t    ftp = (fromto_T *)gap->ga_data + sp->ts_curi - 1;\n\t    fl = (int)STRLEN(ftp->ft_from);\n\t    tl = (int)STRLEN(ftp->ft_to);\n\t    p = fword + sp->ts_fidx;\n\t    if (fl != tl)\n\t    {\n\t\tSTRMOVE(p + fl, p + tl);\n\t\trepextra -= tl - fl;\n\t    }\n\t    mch_memmove(p, ftp->ft_from, fl);\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_REP;\n\t    break;\n\n\tdefault:\n\t    // Did all possible states at this level, go up one level.\n\t    --depth;\n\n\t    if (depth >= 0 && stack[depth].ts_prefixdepth == PFD_PREFIXTREE)\n\t    {\n\t\t// Continue in or go back to the prefix tree.\n\t\tbyts = pbyts;\n\t\tidxs = pidxs;\n\t    }\n\n\t    // Don't check for CTRL-C too often, it takes time.\n\t    if (--breakcheckcount == 0)\n\t    {\n\t\tui_breakcheck();\n\t\tbreakcheckcount = 1000;\n#ifdef FEAT_RELTIME\n\t\tif (spell_suggest_timeout > 0\n\t\t\t\t\t  && profile_passed_limit(&time_limit))\n\t\t    got_int = TRUE;\n#endif\n\t    }\n\t}\n    }\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"vim.h\"\n\n// Type Definitions:\n// fromto_T:\ntypedef struct fromto_S\n{\n    char_u\t*ft_from;\n    char_u\t*ft_to;\n} fromto_T;\n\n// trystate_T:\ntypedef struct trystate_S\n{\n    state_T\tts_state;\t// state at this level, STATE_\n    int\t\tts_score;\t// score\n    idx_T\tts_arridx;\t// index in tree array, start of node\n    short\tts_curi;\t// index in list of child nodes\n    char_u\tts_fidx;\t// index in fword[], case-folded bad word\n    char_u\tts_fidxtry;\t// ts_fidx at which bytes may be changed\n    char_u\tts_twordlen;\t// valid length of tword[]\n    char_u\tts_prefixdepth;\t// stack depth for end of prefix or\n\t\t\t\t// PFD_PREFIXTREE or PFD_NOPREFIX\n    char_u\tts_flags;\t// TSF_ flags\n    char_u\tts_tcharlen;\t// number of bytes in tword character\n    char_u\tts_tcharidx;\t// current byte index in tword character\n    char_u\tts_isdiff;\t// DIFF_ values\n    char_u\tts_fcharstart;\t// index in fword where badword char started\n    char_u\tts_prewordlen;\t// length of word in \"preword[]\"\n    char_u\tts_splitoff;\t// index in \"tword\" after last split\n    char_u\tts_splitfidx;\t// \"ts_fidx\" at word split\n    char_u\tts_complen;\t// nr of compound words used\n    c...\n\n// slang_T:\ntypedef struct slang_S slang_T;\n\n// suginfo_T:\ntypedef struct suginfo_S\n{\n    garray_T\tsu_ga;\t\t    // suggestions, contains \"suggest_T\"\n    int\t\tsu_maxcount;\t    // max. number of suggestions displayed\n    int\t\tsu_maxscore;\t    // maximum score for adding to su_ga\n    int\t\tsu_sfmaxscore;\t    // idem, for when doing soundfold words\n    garray_T\tsu_sga;\t\t    // like su_ga, sound-folded scoring\n    char_u\t*su_badptr;\t    // start of bad word in line\n    int\t\tsu_badlen;\t    // length of detected bad word in line\n    int\t\tsu_badflags;\t    // caps flags for bad word\n    char_u\tsu_badword[MAXWLEN]; // bad word truncated at su_badlen\n    char_u\tsu_fbadword[MAXWLEN]; // su_badword case-folded\n    char_u\tsu_sal_badword[MAXWLEN]; // su_badword soundfolded\n    hashtab_T\tsu_banned;\t    // table with banned words\n    slang_T\t*su_sallang;\t    // default language for sound folding\n} suginfo_T;\n\n// langp_T:\ntypedef struct langp_S\n{\n    slang_T\t*lp_slang;\t// info for this language\n    slang_T\t*lp_sallang;\t// language used for sound folding or NULL\n    slang_T\t*lp_replang;\t// language used for REP items or NULL\n    int\t\tlp_region;\t// bitmask for region or REGION_ALL\n} langp_T;\n\n// garray_T:\ntypedef struct growarray\n{\n    int\t    ga_len;\t\t    // current number of items used\n    int\t    ga_maxlen;\t\t    // maximum number of items possible\n    int\t    ga_itemsize;\t    // sizeof(item)\n    int\t    ga_growsize;\t    // number of items to grow each time\n    void    *ga_data;\t\t    // pointer to the first item\n} garray_T;\n\n// char_u:\ntypedef unsigned char\tchar_u;\n\n// idx_T:\ntypedef int idx_T;\n\n// Called Methods (top 10):\n// SCORE_SUBCOMP from src/spellsuggest.c:\n#define SCORE_SUBCOMP\t33\t// substitute a composing character /* <=== src/spellsuggest.c:95:95:SCORE_SUBCOMP:0 */ \n\n// vim_strnsave from src/strings.c:\n    char_u * /* <=== vim_strnsave */ \nvim_strnsave(char_u *string, size_t len)\n{\n    char_u\t*p;\n\n    p = alloc(len + 1);\n    if (p != NULL)\n    {\n\tSTRNCPY(p, string, len);\n\tp[len] = NUL;\n    }\n    return p;\n}\n\n// mb_ptr2char_adv from src/mbyte.c:\n    int /* <=== mb_ptr2char_adv */ \nmb_ptr2char_adv(char_u **pp)\n{\n    int\t\tc;\n\n    c = (*mb_ptr2char)(*pp);\n    *pp += (*mb_ptr2len)(*pp);\n    return c;\n}\n\n// STRMOVE from src/vim.h:\n#define STRMOVE(d, s)\t    mch_memmove((d), (s), STRLEN(s) + 1) /* <=== src/vim.h:1679:1679:STRMOVE:2 */ \n\n// SCORE_LIMITMAX from src/spellsuggest.c:\n#define SCORE_LIMITMAX\t350\t\t// for spell_edit_score_limit() /* <=== src/spellsuggest.c:123:123:SCORE_LIMITMAX:0 */ \n\n// WF_NOSUGGEST from src/spell.h:\n#define WF_NOSUGGEST 0x0400\t// word not to be suggested /* <=== src/spell.h:160:160:WF_NOSUGGEST:0 */ \n\n// hash_add_item from src/hashtab.c:\n    int /* <=== hash_add_item */ \nhash_add_item(\n    hashtab_T\t*ht,\n    hashitem_T\t*hi,\n    char_u\t*key,\n    hash_T\thash)\n{\n    // If resizing failed before and it fails again we can't add an item.\n    if (ht->ht_error && hash_may_resize(ht, 0) == FAIL)\n\treturn FAIL;\n\n    ++ht->ht_used;\n    ++ht->ht_changed;\n    if (hi->hi_key == NULL)\n\t++ht->ht_filled;\n    hi->hi_key = key;\n    hi->hi_hash = hash;\n\n    // When the space gets low may resize the array.\n    return hash_may_resize(ht, 0);\n}\n\n// WF_RAREPFX from src/spell.h:\n#define WF_RAREPFX  (WFP_RARE << 24)\t// rare postponed prefix /* <=== src/spell.h:174:174:WF_RAREPFX:0 */ \n\n// ui_breakcheck from src/ui.c:\n    void /* <=== ui_breakcheck */ \nui_breakcheck(void)\n{\n    ui_breakcheck_force(FALSE);\n}\n\n// FALSE from src/vim.h:\n# define FALSE\t0\t    // note: this is an int, not a long! /* <=== src/vim.h:1481:1481:FALSE:0 */ \n"
  },
  {
    "repository": "tensorflow",
    "cve_id": "CVE-2022-23566",
    "cwe_list": [
      "CWE-787"
    ],
    "commit_hash": "97282c6d0d34476b6ba033f961590b783fa184cd",
    "short_hash": "97282c6d",
    "vulnerableMethods_before": [
      {
        "filename": "graph_properties.cc",
        "method_name": "vulnerable_function",
        "raw_code": "  Status SetUnknownShape(const NodeDef* node, int output_port) {\n    shape_inference::ShapeHandle shape =\n        GetUnknownOutputShape(node, output_port);\n    InferenceContext* ctx = GetContext(node);\n    if (ctx == nullptr) {\n      return errors::InvalidArgument(\"Missing context\");\n    }\n    ctx->set_output(output_port, shape);\n    return Status::OK();\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "graph_properties.cc",
        "method_name": "fixed_function",
        "raw_code": "  Status SetUnknownShape(const NodeDef* node, int output_port) {\n    shape_inference::ShapeHandle shape =\n        GetUnknownOutputShape(node, output_port);\n    InferenceContext* ctx = GetContext(node);\n    if (ctx == nullptr) {\n      return errors::InvalidArgument(\"SetUnknownShape: Missing context\");\n    }\n    if (output_port < 0 || output_port >= ctx->num_outputs()) {\n      return errors::InvalidArgument(\n          \"SetUnknownShape: output_port must be in [0, \", ctx->num_outputs(),\n          \") but was \", output_port);\n    }\n    ctx->set_output(output_port, shape);\n    return Status::OK();\n  }",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"tensorflow/core/grappler/op_types.h\"\n#include \"tensorflow/core/framework/common_shape_fns.h\"\n#include \"tensorflow/core/grappler/optimizers/evaluation_utils.h\"\n#include \"absl/types/optional.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/framework/tensor_shape.pb.h\"\n#include \"tensorflow/core/grappler/costs/graph_properties.h\"\n#include \"tensorflow/core/grappler/mutable_graph_view.h\"\n#include \"tensorflow/core/lib/gtl/flatset.h\"\n#include \"tensorflow/core/grappler/utils/topological_sort.h\"\n#include \"tensorflow/core/grappler/utils/functions.h\"\n#include \"tensorflow/core/grappler/costs/utils.h\"\n#include \"tensorflow/core/grappler/utils.h\"\n#include \"tensorflow/core/lib/strings/str_util.h\"\n#include \"tensorflow/core/framework/versions.pb.h\"\n#include \"tensorflow/core/framework/types.pb.h\"\n#include \"tensorflow/core/framework/tensor.pb.h\"\n#include \"tensorflow/core/graph/tensor_id.h\"\n#include \"tensorflow/core/lib/gtl/cleanup.h\"\n#include \"tensorflow/core/framework/function.pb.h\"\n#include \"tensorflow/core/common_runtime/function.h\"\n#include \"tensorflow/core/common_runtime/graph_constructor.h\"\n#include \"tensorflow/core/framework/node_def_util.h\"\n\n// Type Definitions:\n// InferenceContext:\nInferenceContext.InferenceContext:ANY(int,AttrSlice&,OpDef&,std.vector&,std.vector&,std.vector&,std.vector&)\n\n// NodeDef:\nclass NodeDef\n\n// Status:\nclass Status\n\n// Status:\nclass Status {\n public:\n  /// Create a success status.\n  Status() {}\n\n  /// \\brief Create a status with the specified error code and msg as a\n  /// human-readable string containing more detailed information.\n  Status(tensorflow::error::Code code, tensorflow::StringPiece msg)\n      : Status(code, msg, {}) {}\n\n  /// \\brief Create a status with the specified error code, msg, and stack trace\n  /// as a human-readable string containing more detailed information.\n#ifndef SWIG\n  Status(tensorflow::error::Code code, tensorflow::StringPiece msg,\n         std::vector<StackFrame>&& stack_trace);\n#endif\n\n  /// Copy the specified status.\n  Status(const Status& s);\n  Status& operator=(const Status& s);\n#ifndef SWIG\n  Status(Status&& s) noexcept;\n  Status& operator=(Status&& s) noexcept;\n#endif  // SWIG\n\n  static Status OK() { return Status(); }\n\n  /// Returns true iff the status indicates success.\n  bool ok() const { return (state_ == nullptr); }\n\n  tensorflow::error::Code code() const {\n    retu...\n\n// Called Methods (top 10):\n// OK from tensorflow/core/platform/status.h:\n  static Status OK() { return Status(); } /* <=== tensorflow.Status.OK:tensorflow.Status() */ \n\n// GetContext from tensorflow/core/grappler/costs/graph_properties.cc:\n  InferenceContext* GetContext(const NodeDef* node) { /* <=== tensorflow.grappler.SymbolicShapeRefiner.GetContext:tensorflow.shape_inference.InferenceContext*(tensorflow.NodeDef*) */ \n    auto it = node_to_context_.find(node);\n    if (it == node_to_context_.end()) {\n      return nullptr;\n    }\n    return it->second.inference_context.get();\n  }\n"
  },
  {
    "repository": "cyrus-imapd",
    "cve_id": "CVE-2021-32056",
    "cwe_list": [
      "CWE-732"
    ],
    "commit_hash": "621f9e41465b521399f691c241181300fab55995",
    "short_hash": "621f9e41",
    "vulnerableMethods_before": [
      {
        "filename": "annotate.c",
        "method_name": "vulnerable_function",
        "raw_code": "static int write_entry(struct mailbox *mailbox,\n                       unsigned int uid,\n                       const char *entry,\n                       const char *userid,\n                       const struct buf *value,\n                       int ignorequota,\n                       int silent,\n                       const struct annotate_metadata *mdata,\n                       int maywrite)\n\n{\n    char key[MAX_MAILBOX_PATH+1];\n    int keylen, r;\n    annotate_db_t *d = NULL;\n    struct buf oldval = BUF_INITIALIZER;\n    const char *mboxname = mailbox ? mailbox->name : \"\";\n    modseq_t modseq = mdata ? mdata->modseq : 0;\n\n    r = _annotate_getdb(mboxname, uid, CYRUSDB_CREATE, &d);\n    if (r)\n        return r;\n\n    /* must be in a transaction to modify the db */\n    annotate_begin(d);\n\n    keylen = make_key(mboxname, uid, entry, userid, key, sizeof(key));\n\n    if (mailbox) {\n        struct annotate_metadata oldmdata;\n        r = read_old_value(d, key, keylen, &oldval, &oldmdata);\n        if (r) goto out;\n\n        /* if the value is identical, don't touch the mailbox */\n        if (oldval.len == value->len && (!value->len || !memcmp(oldval.s, value->s, value->len)))\n            goto out;\n\n        if (!ignorequota) {\n            quota_t qdiffs[QUOTA_NUMRESOURCES] = QUOTA_DIFFS_DONTCARE_INITIALIZER;\n            qdiffs[QUOTA_ANNOTSTORAGE] = value->len - (quota_t)oldval.len;\n            r = mailbox_quota_check(mailbox, qdiffs);\n            if (r) goto out;\n        }\n\n        if (!maywrite) {\n            r = IMAP_PERMISSION_DENIED;\n            if (r) goto out;\n        }\n\n        /* do the annot-changed here before altering the DB */\n        mailbox_annot_changed(mailbox, uid, entry, userid, &oldval, value, silent);\n\n        /* grab the message annotation modseq, if not overridden */\n        if (uid && !mdata) {\n            modseq = mailbox->i.highestmodseq;\n        }\n    }\n\n    /* zero length annotation is deletion.\n     * keep tombstones for message annotations */\n    if (!value->len && !uid) {\n\n#if DEBUG\n        syslog(LOG_ERR, \"write_entry: deleting key %s from %s\",\n                key_as_string(d, key, keylen), d->filename);\n#endif\n\n        do {\n            r = cyrusdb_delete(d->db, key, keylen, tid(d), /*force*/1);\n        } while (r == CYRUSDB_AGAIN);\n    }\n    else {\n        struct buf data = BUF_INITIALIZER;\n        unsigned char flags = 0;\n        if (!value->len || value->s == NULL) {\n            flags |= ANNOTATE_FLAG_DELETED;\n        }\n        else {\n            // this is only here to allow cleanup of invalid values in the past...\n            // the calling of this API with a NULL \"userid\" is bogus, because that's\n            // supposed to be reserved for the make_key of prefixes - but there has\n            // been API abuse in the past, so some of these are in the wild.  *sigh*.\n            // Don't allow new ones to be written\n            if (!userid) goto out;\n        }\n        make_entry(&data, value, modseq, flags);\n\n#if DEBUG\n        syslog(LOG_ERR, \"write_entry: storing key %s (value: %s) to %s (modseq=\" MODSEQ_FMT \")\",\n                key_as_string(d, key, keylen), value->s, d->filename, modseq);\n#endif\n\n        do {\n            r = cyrusdb_store(d->db, key, keylen, data.s, data.len, tid(d));\n        } while (r == CYRUSDB_AGAIN);\n        buf_free(&data);\n    }\n\n    if (!mailbox)\n        sync_log_annotation(\"\");\n\nout:\n    annotate_putdb(&d);\n    buf_free(&oldval);\n\n    return r;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "annotate.c",
        "method_name": "fixed_function",
        "raw_code": "static int write_entry(struct mailbox *mailbox,\n                       unsigned int uid,\n                       const char *entry,\n                       const char *userid,\n                       const struct buf *value,\n                       int ignorequota,\n                       int silent,\n                       const struct annotate_metadata *mdata,\n                       int maywrite)\n\n{\n    char key[MAX_MAILBOX_PATH+1];\n    int keylen, r;\n    annotate_db_t *d = NULL;\n    struct buf oldval = BUF_INITIALIZER;\n    const char *mboxname = mailbox ? mailbox->name : \"\";\n    modseq_t modseq = mdata ? mdata->modseq : 0;\n\n    r = _annotate_getdb(mboxname, uid, CYRUSDB_CREATE, &d);\n    if (r)\n        return r;\n\n    /* must be in a transaction to modify the db */\n    annotate_begin(d);\n\n    keylen = make_key(mboxname, uid, entry, userid, key, sizeof(key));\n\n    struct annotate_metadata oldmdata;\n    r = read_old_value(d, key, keylen, &oldval, &oldmdata);\n    if (r) goto out;\n\n    /* if the value is identical, don't touch the mailbox */\n    if (oldval.len == value->len && (!value->len || !memcmp(oldval.s, value->s, value->len)))\n        goto out;\n\n    if (!maywrite) {\n        r = IMAP_PERMISSION_DENIED;\n        if (r) goto out;\n    }\n\n    if (mailbox) {\n        if (!ignorequota) {\n            quota_t qdiffs[QUOTA_NUMRESOURCES] = QUOTA_DIFFS_DONTCARE_INITIALIZER;\n            qdiffs[QUOTA_ANNOTSTORAGE] = value->len - (quota_t)oldval.len;\n            r = mailbox_quota_check(mailbox, qdiffs);\n            if (r) goto out;\n        }\n\n        /* do the annot-changed here before altering the DB */\n        mailbox_annot_changed(mailbox, uid, entry, userid, &oldval, value, silent);\n\n        /* grab the message annotation modseq, if not overridden */\n        if (uid && !mdata) {\n            modseq = mailbox->i.highestmodseq;\n        }\n    }\n\n    /* zero length annotation is deletion.\n     * keep tombstones for message annotations */\n    if (!value->len && !uid) {\n\n#if DEBUG\n        syslog(LOG_ERR, \"write_entry: deleting key %s from %s\",\n                key_as_string(d, key, keylen), d->filename);\n#endif\n\n        do {\n            r = cyrusdb_delete(d->db, key, keylen, tid(d), /*force*/1);\n        } while (r == CYRUSDB_AGAIN);\n    }\n    else {\n        struct buf data = BUF_INITIALIZER;\n        unsigned char flags = 0;\n        if (!value->len || value->s == NULL) {\n            flags |= ANNOTATE_FLAG_DELETED;\n        }\n        else {\n            // this is only here to allow cleanup of invalid values in the past...\n            // the calling of this API with a NULL \"userid\" is bogus, because that's\n            // supposed to be reserved for the make_key of prefixes - but there has\n            // been API abuse in the past, so some of these are in the wild.  *sigh*.\n            // Don't allow new ones to be written\n            if (!userid) goto out;\n        }\n        make_entry(&data, value, modseq, flags);\n\n#if DEBUG\n        syslog(LOG_ERR, \"write_entry: storing key %s (value: %s) to %s (modseq=\" MODSEQ_FMT \")\",\n                key_as_string(d, key, keylen), value->s, d->filename, modseq);\n#endif\n\n        do {\n            r = cyrusdb_store(d->db, key, keylen, data.s, data.len, tid(d));\n        } while (r == CYRUSDB_AGAIN);\n        buf_free(&data);\n    }\n\n    if (!mailbox)\n        sync_log_annotation(\"\");\n\nout:\n    annotate_putdb(&d);\n    buf_free(&oldval);\n\n    return r;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"mboxlist.h\"\n#include \"cyrusdb.h\"\n#include <sys/uio.h>\n#include \"ptrarray.h\"\n#include <string.h>\n#include \"global.h\"\n#include \"annotate.h\"\n#include <config.h>\n#include \"xstrlcpy.h\"\n#include \"glob.h\"\n#include <sysexits.h>\n#include \"partlist.h\"\n#include <sys/types.h>\n#include <stdio.h>\n#include \"quota.h\"\n# include <stdint.h>\n#include \"xmalloc.h\"\n#include \"sync_log.h\"\n#include \"times.h\"\n#include \"acl.h\"\n#include \"imapd.h\"\n#include <errno.h>\n#include \"xstrlcat.h\"\n#include \"imap/imap_err.h\"\n#include \"assert.h\"\n#include <ctype.h>\n#include \"hash.h\"\n#include <fcntl.h>\n#include <unistd.h>\n# include <inttypes.h>\n#include <sys/stat.h>\n#include \"util.h\"\n#include <syslog.h>\n#include <stdlib.h>\n#include \"tok.h\"\n\n// Type Definitions:\n// annotate_db_t:\ntypedef struct annotate_db annotate_db_t;\n\n// mailbox:\nstruct mailbox {\n    int index_fd;\n    int header_fd;\n\n    ptrarray_t caches;\n    const char *index_base;\n    size_t index_len;   /* mapped size */\n\n    int index_locktype; /* 0 = none, 1 = shared, 2 = exclusive */\n    int is_readonly; /* true = open index and cache files readonly */\n\n    ino_t header_file_ino;\n    bit32 header_file_crc;\n\n    time_t index_mtime;\n    ino_t index_ino;\n    size_t index_size;\n\n    /* Information in mailbox list */\n    char *name;\n    uint32_t mbtype;\n    char *part;\n    char *acl;\n    modseq_t foldermodseq;\n\n    struct index_header i;\n\n    /* Information in header */\n    char *uniqueid;\n    char *quotaroot;\n    char *flagname[MAX_USER_FLAGS];\n\n    struct timeval starttime;\n\n    /* annotations */\n    struct annotate_state *annot_state;\n\n    /* conversations */\n    struct conversations_state *local_cstate;\n\n#ifdef WITH_DAV\n    struct caldav_db *local_caldav;\n    struct carddav_db *local_carddav;\n    struct webdav_db *local_webdav;\n#endif\n\n    /* change ma...\n\n// mailbox:\nstruct mailbox\n\n// buf:\nstruct buf {\n    char *s;\n    size_t len;\n    size_t alloc;\n    unsigned flags;\n}\n\n// modseq_t:\ntypedef unsigned long long int modseq_t;\n\n// buf:\nstruct buf\n\n// annotate_metadata:\nstruct annotate_metadata\n{\n    modseq_t modseq;\n    unsigned char flags; /* read-only */\n}\n\n// Called Methods (top 10):\n// xstrdup from lib/xmalloc.c:\nEXPORTED char *xstrdup(const char* str) /* <=== xstrdup */ \n{\n    char *p = xmalloc(strlen(str)+1);\n    strcpy(p, str);\n    return p;\n}\n\n// mailbox_quota_check from imap/mailbox.h:\n<empty>\n\n// buf_append from lib/util.c:\nEXPORTED void buf_append(struct buf *dst, const struct buf *src) /* <=== buf_append */ \n{\n    buf_appendmap(dst, src->s, src->len);\n}\n\n// mailbox_get_usage from imap/mailbox.c:\nEXPORTED void mailbox_get_usage(struct mailbox *mailbox, /* <=== mailbox_get_usage */ \n                        quota_t usage[QUOTA_NUMRESOURCES])\n{\n    int res;\n\n    for (res = 0; res < QUOTA_NUMRESOURCES; res++) {\n        usage[res] = 0;\n    }\n\n    if (!(mailbox->i.options & OPT_MAILBOX_DELETED)) {\n        usage[QUOTA_STORAGE] = mailbox->i.quota_mailbox_used;\n        usage[QUOTA_MESSAGE] = mailbox->i.exists;\n        usage[QUOTA_ANNOTSTORAGE] = mailbox->i.quota_annot_used;\n        usage[QUOTA_NUMFOLDERS] = 1;\n    }\n    /* else: mailbox is being deleted, thus its new usage is 0 */\n}\n\n// assert from imap/assert.h:\n\n\n// _htonll from lib/byteorder64.c:\nEXPORTED unsigned long long _htonll(unsigned long long x) /* <=== _htonll */ \n{\n    union byteswap_64_u u1;\n    union byteswap_64_u u2;\n\n    u1.a = x;\n\n    u2.b[0] = htonl(u1.b[1]);\n    u2.b[1] = htonl(u1.b[0]);\n\n    return u2.a;\n}\n\n// mailbox_find_index_record from imap/mailbox.c:\nEXPORTED int mailbox_find_index_record(struct mailbox *mailbox, uint32_t uid, /* <=== mailbox_find_index_record */ \n                                       struct index_record *record)\n{\n    uint32_t recno = mailbox_finduid(mailbox, uid);\n    /* no records? */\n    if (!recno) return IMAP_NOTFOUND;\n\n    int r = mailbox_read_index_record(mailbox, recno, record);\n    /* failed read? */\n    if (r) return r;\n\n    /* wasn't the actual record? */\n    if (record->uid != uid) return IMAP_NOTFOUND;\n\n    return 0;\n}\n\n// crc_annot from imap/mailbox.c:\nstatic uint32_t crc_annot(unsigned int uid, const char *entry, /* <=== crc_annot */ \n                          const char *userid, const struct buf *value)\n{\n    struct buf buf = BUF_INITIALIZER;\n    uint32_t res = 0;\n\n    // ignore everything with a NULL userid, it's bogus!\n    if (!userid) return 0;\n\n    buf_printf(&buf, \"%u %s %s \", uid, entry, userid);\n    buf_append(&buf, value);\n    res = crc32_buf(&buf);\n    buf_free(&buf);\n\n    return res;\n}\n\n// mboxlist_entry_free from imap/mboxlist.c:\nEXPORTED void mboxlist_entry_free(mbentry_t **mbentryptr) /* <=== mboxlist_entry_free */ \n{\n    mbentry_t *mbentry = *mbentryptr;\n\n    /* idempotent */\n    if (!mbentry) return;\n\n    free(mbentry->name);\n    free(mbentry->ext_name);\n\n    free(mbentry->partition);\n    free(mbentry->server);\n    free(mbentry->acl);\n    free(mbentry->uniqueid);\n\n    free(mbentry->legacy_specialuse);\n\n    free(mbentry);\n\n    *mbentryptr = NULL;\n}\n\n// quota_check_useds from imap/quota_db.c:\nint quota_check_useds(const char *quotaroot,\n                      const quota_t diff[QUOTA_NUMRESOURCES])\n{\n    int r = 0;\n    struct quota q;\n    int res;\n\n    init_internal();\n\n    /*\n     * We are always allowed to *reduce* usage even if it doesn't get us\n     * below the quota.  As a side effect this allows our caller to pass\n     * delta = -1 meaning \"don't care about quota checks\".\n     */\n    for (res = 0 ; res < QUOTA_NUMRESOURCES ; res++) {\n        if (diff[res] >= 0)\n            break;\n    }\n    if (res == QUOTA_NUMRESOURCES)\n        return 0;           /* all negative */\n\n    quota_init(&q, quotaroot);\n    r = quota_read(&q, NULL, /*wrlock*/0);\n\n    if (r == IMAP_QUOTAROOT_NONEXISTENT) {\n        r = 0;\n        goto done;\n    }\n    if (r) goto done;\n\n    for (res = 0 ; res < QUOTA_NUMRESOURCES ; res++) {\n        r = quota_check(&q, res, diff[res]);\n        if (r) goto done;\n    }\n\ndone:\n    quota_free(&q);\n    return r;\n}\n"
  },
  {
    "repository": "linux",
    "cve_id": "CVE-2021-28950",
    "cwe_list": [
      "CWE-834"
    ],
    "commit_hash": "775c5033a0d164622d9d10dd0f0a5531639ed3ed",
    "short_hash": "775c5033",
    "vulnerableMethods_before": [
      {
        "filename": "fuse_i.h",
        "method_name": "vulnerable_function",
        "raw_code": "static inline void fuse_make_bad(struct inode *inode)\n{\n\tset_bit(FUSE_I_BAD, &get_fuse_inode(inode)->state);\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "fuse_i.h",
        "method_name": "fixed_function",
        "raw_code": "static inline void fuse_make_bad(struct inode *inode)\n{\n\tremove_inode_hash(inode);\n\tset_bit(FUSE_I_BAD, &get_fuse_inode(inode)->state);\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <linux/wait.h>\n#include <linux/rwsem.h>\n#include <linux/xattr.h>\n#include <linux/kref.h>\n#include <linux/poll.h>\n#include <linux/pid_namespace.h>\n#include <linux/workqueue.h>\n#include <linux/fuse.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/refcount.h>\n#include <linux/user_namespace.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n\n// Type Definitions:\n// fuse_inode:\nstruct fuse_inode {\n\t/** Inode data */\n\tstruct inode inode;\n\n\t/** Unique ID, which identifies the inode between userspace\n\t * and kernel */\n\tu64 nodeid;\n\n\t/** Number of lookups on this inode */\n\tu64 nlookup;\n\n\t/** The request used for sending the FORGET message */\n\tstruct fuse_forget_link *forget;\n\n\t/** Time in jiffies until the file attributes are valid */\n\tu64 i_time;\n\n\t/* Which attributes are invalid */\n\tu32 inval_mask;\n\n\t/** The sticky bit in inode->i_mode may have been removed, so\n\t    preserve the original mode */\n\tumode_t orig_i_mode;\n\n\t/** 64 bit inode number */\n\tu64 orig_ino;\n\n\t/** Version of last attribute change */\n\tu64 attr_version;\n\n\tunion {\n\t\t/* Write related fields (regular file only) */\n\t\tstruct {\n\t\t\t/* Files usable in writepage.  Protected by fi->lock */\n\t\t\tstruct list_head write_files;\n\n\t\t\t/* Writepages pending on truncate or fsync */\n\t\t\tstruct list_head queued_writes;\n\n\t\t\t/* Number of sent writes, a negative bias\n\t\t\t * (FUSE_NOWRITE) means more writes are blocked ...\n\n// inode:\nstatic struct inode\n\n// Called Methods (top 10):\n// get_fuse_inode from fs/fuse/fuse_i.h:\nstatic inline struct fuse_inode *get_fuse_inode(struct inode *inode) /* <=== get_fuse_inode */ \n{\n\treturn container_of(inode, struct fuse_inode, inode);\n}\n"
  },
  {
    "repository": "tensorflow",
    "cve_id": "CVE-2022-29194",
    "cwe_list": [
      "CWE-703"
    ],
    "commit_hash": "cff267650c6a1b266e4b4500f69fbc49cdd773c5",
    "short_hash": "cff26765",
    "vulnerableMethods_before": [
      {
        "filename": "session_ops.cc",
        "method_name": "vulnerable_function",
        "raw_code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& handle = ctx->input(0);\n    const string& name = handle.scalar<tstring>()();\n    auto session_state = ctx->session_state();\n    OP_REQUIRES(ctx, session_state != nullptr,\n                errors::FailedPrecondition(\n                    \"DeleteSessionTensor called on null session state\"));\n    OP_REQUIRES_OK(ctx, session_state->DeleteTensor(name));\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "session_ops.cc",
        "method_name": "fixed_function",
        "raw_code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& handle = ctx->input(0);\n    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(handle.shape()),\n                errors::InvalidArgument(\"`handle` must be scalar\"));\n    const string& name = handle.scalar<tstring>()();\n    auto session_state = ctx->session_state();\n    OP_REQUIRES(ctx, session_state != nullptr,\n                errors::FailedPrecondition(\n                    \"DeleteSessionTensor called on null session state\"));\n    OP_REQUIRES_OK(ctx, session_state->DeleteTensor(name));\n  }",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"tensorflow/core/platform/thread_annotations.h\"\n#include \"tensorflow/core/platform/types.h\"\n#include \"tensorflow/core/platform/errors.h\"\n#include \"tensorflow/core/platform/macros.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/common_runtime/device.h\"\n#include <limits.h>\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/lib/gtl/map_util.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/platform/mutex.h\"\n#include \"tensorflow/core/framework/device_base.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include <vector>\n\n// Type Definitions:\n// OpKernelContext:\ntensorflow.OpKernelContext.OpKernelContext:ANY(tensorflow.OpKernelContext.Params*)\n\n// SessionState:\nclass SessionState {\n public:\n  // Get a tensor from the session state.\n  Status GetTensor(const std::string& handle, Tensor* tensor);\n\n  // Store a tensor in the session state.\n  Status AddTensor(const std::string& handle, const Tensor& tensor);\n\n  // Delete a tensor from the session state.\n  Status DeleteTensor(const std::string& handle);\n\n  int64_t GetNewId();\n\n  static const char* kTensorHandleResourceTypeName;\n\n private:\n  mutex state_lock_;\n\n  // For generating unique ids for tensors stored in the session.\n  int64_t tensor_id_ = 0;\n\n  // The live tensors in the session. A map from tensor handle to tensor.\n  std::unordered_map<string, Tensor> tensors_;\n}\n\n// Status:\nclass Status\n\n// TensorShape:\nclass TensorShape : public TensorShapeBase<TensorShape> {\n public:\n  using TensorShapeBase<TensorShape>::TensorShapeBase;\n\n  // These factory methods should be used instead of the constructors that take\n  // an array of sizes if calling code cannot validate that the sizes specify a\n  // valid `TensorShape`.\n  // The value in `*out` is valid iff the returned value is `Status::OK`.\n  static Status BuildTensorShape(gtl::ArraySlice<int64_t> dim_sizes,\n                                 TensorShape* out) {\n    return BuildTensorShapeBase(dim_sizes, out);\n  }\n  static Status BuildTensorShape(std::initializer_list<int64_t> dim_sizes,\n                                 TensorShape* out) {\n    return BuildTensorShape(gtl::ArraySlice<int64_t>(dim_sizes), out);\n  }\n  static Status BuildTensorShape(const TensorShapeProto& proto,\n                                 TensorShape* out) {\n    return BuildTensorShapeBase(proto, out);\n  }\n\n  static StatusOr<TensorShape> BuildTensorShape(const TensorShapeProt...\n\n// Tensor:\ntensorflow.TensorHandle.Tensor:tensorflow.Status(tensorflow.Tensor**)<const>\n\n// Status:\nclass Status {\n public:\n  /// Create a success status.\n  Status() {}\n\n  /// \\brief Create a status with the specified error code and msg as a\n  /// human-readable string containing more detailed information.\n  Status(tensorflow::error::Code code, tensorflow::StringPiece msg)\n      : Status(code, msg, {}) {}\n\n  /// \\brief Create a status with the specified error code, msg, and stack trace\n  /// as a human-readable string containing more detailed information.\n#ifndef SWIG\n  Status(tensorflow::error::Code code, tensorflow::StringPiece msg,\n         std::vector<StackFrame>&& stack_trace);\n#endif\n\n  /// Copy the specified status.\n  Status(const Status& s);\n  Status& operator=(const Status& s);\n#ifndef SWIG\n  Status(Status&& s) noexcept;\n  Status& operator=(Status&& s) noexcept;\n#endif  // SWIG\n\n  static Status OK() { return Status(); }\n\n  /// Returns true iff the status indicates success.\n  bool ok() const { return (state_ == nullptr); }\n\n  tensorflow::error::Code code() const {\n    retu...\n\n// OpKernelContext:\nclass OpKernelContext {\n public:\n  // The first element of a WrappedAllocator is a \"base\" Allocator and\n  // the second element is that Allocator wrapped by a\n  // TrackingAllocator\n  typedef std::pair<Allocator*, TrackingAllocator*> WrappedAllocator;\n\n  // TODO(zhifengc): Do some cleanup of Params.\n  // The Params struct is passed in to initialize an OpKernelContext,\n  // and must outlive the OpKernelContext.\n  struct Params {\n    ~Params() { delete eigen_gpu_device; }\n\n    // The step being executed.\n    int64_t step_id = 0;\n\n    // Timestamp for the start of graph execution. Used for latency metrics.\n    int64_t start_time_usecs = 0;\n\n    // The deadline for the session to complete by. Empty if unspecified.\n    absl::optional<absl::Time> deadline;\n\n    // The op kernel being computed.\n    OpKernel* op_kernel = nullptr;\n\n    // The device on which the kernel is running.\n    DeviceBase* device = nullptr;\n\n    // The Eigen GPU device wrapper, which may include a per-op\n    // wrappe...\n\n// Called Methods (top 10):\n// SetStatus from tensorflow/core/framework/op_kernel.cc:\nvoid OpKernelConstruction::SetStatus(const Status& status) { /* <=== tensorflow.OpKernelConstruction.SetStatus:void(tensorflow.Status&) */ \n  status_->Update(status);\n}\n\n// OP_REQUIRES from tensorflow/core/kernels/tensorflow/core/framework/tensorflow/core/framework/op_requires.h:\n\n\n// name from tensorflow/core/framework/op_kernel.h:\n  const std::string& name() const { return props_->node_def.name(); } /* <=== tensorflow.OpKernel.name:ANY()<const> */ \n\n// TF_RETURN_IF_ERROR from tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/errors.h:\n\n\n// Update from tensorflow/core/platform/status.cc:\nvoid Status::Update(const Status& new_status) { /* <=== tensorflow.Status.Update:void(tensorflow.Status&) */ \n  if (ok()) {\n    *this = new_status;\n  }\n}\n\n// IsScalar from tensorflow/core/framework/tensor_shape.h:\n  static bool IsScalar(const TensorShape& shape) { return shape.dims() == 0; } /* <=== tensorflow.TensorShapeUtils.IsScalar:bool(tensorflow.TensorShape&) */ \n\n// shape from tensorflow/core/framework/tensor.h:\n  const TensorShape& shape() const { return shape_; } /* <=== tensorflow.Tensor.shape:tensorflow.TensorShape&()<const> */ \n\n// CHECK_EQ from tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/platform/logging.h:\n\n\n// OP_REQUIRES_OK from tensorflow/core/kernels/tensorflow/core/framework/tensorflow/core/framework/op_requires.h:\n\n\n// CheckNotInComputeAsync from tensorflow/core/framework/op_kernel.cc:\nvoid CheckNotInComputeAsync(OpKernelContext* ctx, /* <=== tensorflow.CheckNotInComputeAsync:void(tensorflow.OpKernelContext*,char*) */ \n                            const char* correct_macro_name) {\n  CHECK_EQ(nullptr, ctx->params_->op_kernel->AsAsync())\n      << \"Use \" << correct_macro_name << \" in AsyncOpKernel implementations.\";\n}\n"
  },
  {
    "repository": "linux",
    "cve_id": "CVE-2021-28972",
    "cwe_list": [
      "CWE-120"
    ],
    "commit_hash": "cc7a0bb058b85ea03db87169c60c7cfdd5d34678",
    "short_hash": "cc7a0bb0",
    "vulnerableMethods_before": [
      {
        "filename": "rpadlpar_sysfs.c",
        "method_name": "vulnerable_function",
        "raw_code": "static ssize_t add_slot_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t      const char *buf, size_t nbytes)\n{\n\tchar drc_name[MAX_DRC_NAME_LEN];\n\tchar *end;\n\tint rc;\n\n\tif (nbytes >= MAX_DRC_NAME_LEN)\n\t\treturn 0;\n\n\tmemcpy(drc_name, buf, nbytes);\n\n\tend = strchr(drc_name, '\\n');\n\tif (!end)\n\t\tend = &drc_name[nbytes];\n\t*end = '\\0';\n\n\trc = dlpar_add_slot(drc_name);\n\tif (rc)\n\t\treturn rc;\n\n\treturn nbytes;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "rpadlpar_sysfs.c",
        "method_name": "fixed_function",
        "raw_code": "static ssize_t add_slot_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t      const char *buf, size_t nbytes)\n{\n\tchar drc_name[MAX_DRC_NAME_LEN];\n\tchar *end;\n\tint rc;\n\n\tif (nbytes >= MAX_DRC_NAME_LEN)\n\t\treturn 0;\n\n\tstrscpy(drc_name, buf, nbytes + 1);\n\n\tend = strchr(drc_name, '\\n');\n\tif (end)\n\t\t*end = '\\0';\n\n\trc = dlpar_add_slot(drc_name);\n\tif (rc)\n\t\treturn rc;\n\n\treturn nbytes;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <linux/string.h>\n#include <linux/pci_hotplug.h>\n#include \"rpadlpar.h\"\n#include <linux/kobject.h>\n#include \"../pci.h\"\n#include <linux/pci.h>\n#include \"rpaphp.h\"\n\n// Called Methods (top 10):\n// rpaphp_deregister_slot from drivers/pci/hotplug/rpaphp_slot.c:\n\n\n// dlpar_add_slot from drivers/pci/hotplug/rpadlpar_core.c:\n\n\n// NODE_TYPE_PHB from drivers/pci/hotplug/rpadlpar_core.c:\n\n\n// dlpar_add_vio_slot from drivers/pci/hotplug/rpadlpar_core.c:\n\n\n// rpaphp_add_slot from drivers/pci/hotplug/rpaphp_core.c:\n\n\n// dlpar_pci_add_bus from drivers/pci/hotplug/rpadlpar_core.c:\n\n\n// find_php_slot_pci_node from drivers/pci/hotplug/rpadlpar_core.c:\n\n\n// dlpar_remove_pci_slot from drivers/pci/hotplug/rpadlpar_core.c:\n\n\n// NODE_TYPE_VIO from drivers/pci/hotplug/rpadlpar_core.c:\n\n\n// dlpar_find_new_dev from drivers/pci/hotplug/rpadlpar_core.c:\n\n"
  },
  {
    "repository": "flatpak",
    "cve_id": "CVE-2021-43860",
    "cwe_list": [
      "CWE-276"
    ],
    "commit_hash": "65cbfac982cb1c83993a9e19aa424daee8e9f042",
    "short_hash": "65cbfac9",
    "vulnerableMethods_before": [
      {
        "filename": "flatpak-dir.c",
        "method_name": "vulnerable_function",
        "raw_code": "flatpak_dir_ensure_bundle_remote (FlatpakDir         *self,\n                                  GFile              *file,\n                                  GBytes             *extra_gpg_data,\n                                  FlatpakDecomposed **out_ref,\n                                  char              **out_checksum,\n                                  char              **out_metadata,\n                                  gboolean           *out_created_remote,\n                                  GCancellable       *cancellable,\n                                  GError            **error)\n{\n  g_autoptr(FlatpakDecomposed) ref = NULL;\n  gboolean created_remote = FALSE;\n  g_autoptr(GBytes) deploy_data = NULL;\n  g_autoptr(GVariant) metadata = NULL;\n  g_autofree char *origin = NULL;\n  g_autofree char *fp_metadata = NULL;\n  g_autofree char *basename = NULL;\n  g_autoptr(GBytes) included_gpg_data = NULL;\n  GBytes *gpg_data = NULL;\n  g_autofree char *to_checksum = NULL;\n  g_autofree char *remote = NULL;\n  g_autofree char *collection_id = NULL;\n\n  if (!flatpak_dir_ensure_repo (self, cancellable, error))\n    return NULL;\n\n  metadata = flatpak_bundle_load (file, &to_checksum,\n                                  &ref,\n                                  &origin,\n                                  NULL, &fp_metadata, NULL,\n                                  &included_gpg_data,\n                                  &collection_id,\n                                  error);\n  if (metadata == NULL)\n    return NULL;\n\n  gpg_data = extra_gpg_data ? extra_gpg_data : included_gpg_data;\n\n  deploy_data = flatpak_dir_get_deploy_data (self, ref, FLATPAK_DEPLOY_VERSION_ANY, cancellable, NULL);\n  if (deploy_data != NULL)\n    {\n      remote = g_strdup (flatpak_deploy_data_get_origin (deploy_data));\n\n      /* We need to import any gpg keys because otherwise the pull will fail */\n      if (gpg_data != NULL)\n        {\n          g_autoptr(GKeyFile) new_config = NULL;\n\n          new_config = ostree_repo_copy_config (flatpak_dir_get_repo (self));\n\n          if (!flatpak_dir_modify_remote (self, remote, new_config,\n                                          gpg_data, cancellable, error))\n            return NULL;\n        }\n    }\n  else\n    {\n      g_autofree char *id = flatpak_decomposed_dup_id (ref);\n      /* Add a remote for later updates */\n      basename = g_file_get_basename (file);\n      remote = flatpak_dir_create_origin_remote (self,\n                                                 origin,\n                                                 id,\n                                                 basename,\n                                                 flatpak_decomposed_get_ref (ref),\n                                                 gpg_data,\n                                                 collection_id,\n                                                 &created_remote,\n                                                 cancellable,\n                                                 error);\n      if (remote == NULL)\n        return NULL;\n    }\n\n  if (out_created_remote)\n    *out_created_remote = created_remote;\n\n  if (out_ref)\n    *out_ref = g_steal_pointer (&ref);\n\n  if (out_checksum)\n    *out_checksum = g_steal_pointer (&to_checksum);\n\n  if (out_metadata)\n    *out_metadata = g_steal_pointer (&fp_metadata);\n\n\n  return g_steal_pointer (&remote);\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "flatpak-dir.c",
        "method_name": "fixed_function",
        "raw_code": "flatpak_dir_ensure_bundle_remote (FlatpakDir         *self,\n                                  GFile              *file,\n                                  GBytes             *extra_gpg_data,\n                                  FlatpakDecomposed **out_ref,\n                                  char              **out_checksum,\n                                  char              **out_metadata,\n                                  gboolean           *out_created_remote,\n                                  GCancellable       *cancellable,\n                                  GError            **error)\n{\n  g_autoptr(FlatpakDecomposed) ref = NULL;\n  gboolean created_remote = FALSE;\n  g_autoptr(GBytes) deploy_data = NULL;\n  g_autoptr(GVariant) metadata = NULL;\n  g_autofree char *origin = NULL;\n  g_autofree char *fp_metadata = NULL;\n  g_autofree char *basename = NULL;\n  g_autoptr(GBytes) included_gpg_data = NULL;\n  GBytes *gpg_data = NULL;\n  g_autofree char *to_checksum = NULL;\n  g_autofree char *remote = NULL;\n  g_autofree char *collection_id = NULL;\n\n  if (!flatpak_dir_ensure_repo (self, cancellable, error))\n    return NULL;\n\n  metadata = flatpak_bundle_load (file, &to_checksum,\n                                  &ref,\n                                  &origin,\n                                  NULL, &fp_metadata, NULL,\n                                  &included_gpg_data,\n                                  &collection_id,\n                                  error);\n  if (metadata == NULL)\n    return NULL;\n\n  /* If we rely on metadata (to e.g. print permissions), check it exists before creating the remote */\n  if (out_metadata && fp_metadata == NULL)\n    {\n      flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, \"No metadata in bundler header\");\n      return NULL;\n    }\n\n  gpg_data = extra_gpg_data ? extra_gpg_data : included_gpg_data;\n\n  deploy_data = flatpak_dir_get_deploy_data (self, ref, FLATPAK_DEPLOY_VERSION_ANY, cancellable, NULL);\n  if (deploy_data != NULL)\n    {\n      remote = g_strdup (flatpak_deploy_data_get_origin (deploy_data));\n\n      /* We need to import any gpg keys because otherwise the pull will fail */\n      if (gpg_data != NULL)\n        {\n          g_autoptr(GKeyFile) new_config = NULL;\n\n          new_config = ostree_repo_copy_config (flatpak_dir_get_repo (self));\n\n          if (!flatpak_dir_modify_remote (self, remote, new_config,\n                                          gpg_data, cancellable, error))\n            return NULL;\n        }\n    }\n  else\n    {\n      g_autofree char *id = flatpak_decomposed_dup_id (ref);\n      /* Add a remote for later updates */\n      basename = g_file_get_basename (file);\n      remote = flatpak_dir_create_origin_remote (self,\n                                                 origin,\n                                                 id,\n                                                 basename,\n                                                 flatpak_decomposed_get_ref (ref),\n                                                 gpg_data,\n                                                 collection_id,\n                                                 &created_remote,\n                                                 cancellable,\n                                                 error);\n      if (remote == NULL)\n        return NULL;\n    }\n\n  if (out_created_remote)\n    *out_created_remote = created_remote;\n\n  if (out_ref)\n    *out_ref = g_steal_pointer (&ref);\n\n  if (out_checksum)\n    *out_checksum = g_steal_pointer (&to_checksum);\n\n  if (out_metadata)\n    *out_metadata = g_steal_pointer (&fp_metadata);\n\n\n  return g_steal_pointer (&remote);\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"flatpak-parental-controls-private.h\"\n#include <ostree.h>\n#include \"flatpak-error.h\"\n#include \"flatpak-oci-registry-private.h\"\n#include \"flatpak-variant-private.h\"\n#include <libxml/tree.h>\n#include \"libglnx/libglnx.h\"\n#include <glib/gstdio.h>\n#include <fcntl.h>\n#include <gio/gio.h>\n#include <sys/file.h>\n#include <glib/gi18n-lib.h>\n#include <utime.h>\n#include <stdio.h>\n#include \"system-helper/flatpak-system-helper.h\"\n#include \"config.h\"\n#include <string.h>\n#include \"flatpak-variant-impl-private.h\"\n#include \"flatpak-run-private.h\"\n#include \"flatpak-appdata-private.h\"\n#include <gio/gunixsocketaddress.h>\n#include <libxml/parser.h>\n#include <sys/socket.h>\n#include <libmalcontent/malcontent.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <polkit/polkit.h>\n#include \"flatpak-ref.h\"\n#include <systemd/sd-journal.h>\n#include \"flatpak-utils-base-private.h\"\n#include \"flatpak-dir-private.h\"\n\n// Type Definitions:\n// FlatpakDir:\nstruct FlatpakDir\n{\n  GObject          parent;\n\n  gboolean         user;\n  GFile           *basedir;\n  DirExtraData    *extra_data;\n  OstreeRepo      *repo;\n  GFile           *cache_dir;\n  gboolean         no_system_helper;\n  gboolean         no_interaction;\n  pid_t            source_pid;\n\n  GDBusConnection *system_helper_bus;\n\n  GHashTable      *summary_cache;\n\n  GHashTable      *remote_filters;\n\n  /* Config cache, protected by config_cache lock */\n  GRegex          *masked;\n  GRegex          *pinned;\n\n  SoupSession     *soup_session;\n}\n\n// FlatpakDecomposed:\ntypedef struct _FlatpakDecomposed FlatpakDecomposed;\n\n// Called Methods (top 10):\n// flatpak_decomposed_peek_id from common/flatpak-ref-utils.c:\nconst char * /* <=== flatpak_decomposed_peek_id */ \nflatpak_decomposed_peek_id (FlatpakDecomposed  *ref,\n                            gsize              *out_len)\n{\n  if (out_len)\n    *out_len = ref->arch_offset - ref->id_offset - 1;\n  return &ref->data[ref->id_offset];\n}\n\n// flatpak_dir_maybe_ensure_repo from common/flatpak-dir.c:\ngboolean /* <=== flatpak_dir_maybe_ensure_repo */ \nflatpak_dir_maybe_ensure_repo (FlatpakDir   *self,\n                               GCancellable *cancellable,\n                               GError      **error)\n{\n  return _flatpak_dir_ensure_repo (self, TRUE, cancellable, error);\n}\n\n// flatpak_dir_remote_clear_cached_summary from common/flatpak-dir.c:\nstatic gboolean /* <=== flatpak_dir_remote_clear_cached_summary */ \nflatpak_dir_remote_clear_cached_summary (FlatpakDir   *self,\n                                         const char   *remote,\n                                         GCancellable *cancellable,\n                                         GError      **error)\n{\n  g_debug (\"Clearing cached summaries for remote %s\", remote);\n  if (!_flatpak_dir_remote_clear_cached_summary (self, remote, NULL, cancellable, error))\n    return FALSE;\n  if (!_flatpak_dir_remote_clear_cached_summary (self, remote, \".sig\", cancellable, error))\n    return FALSE;\n  if (!_flatpak_dir_remote_clear_cached_summary (self, remote, \".idx\", cancellable, error))\n    return FALSE;\n  if (!_flatpak_dir_remote_clear_cached_summary (self, remote, \".idx.sig\", cancellable, error))\n    return FALSE;\n  return TRUE;\n}\n\n// flatpak_dir_create_origin_remote from common/flatpak-dir.c:\nchar * /* <=== flatpak_dir_create_origin_remote */ \nflatpak_dir_create_origin_remote (FlatpakDir   *self,\n                                  const char   *url,\n                                  const char   *id,\n                                  const char   *title,\n                                  const char   *main_ref,\n                                  GBytes       *gpg_data,\n                                  const char   *collection_id,\n                                  gboolean     *changed_config,\n                                  GCancellable *cancellable,\n                                  GError      **error)\n{\n  g_autoptr(GKeyFile) new_config = NULL;\n  g_autofree char *remote = NULL;\n\n  remote = create_origin_remote_config (self->repo, url, id, title, main_ref, gpg_data != NULL, collection_id, &new_config);\n\n  if (new_config &&\n      !flatpak_dir_modify_remote (self, remote, new_config,\n                                  gpg_data, cancellable, error))\n    return NULL;\n\n  if (new_config && !_flatpak_dir_reload_config (self, cancellable, error))\n    return FALSE;\n\n  if (changed_config)\n    *changed_config = (new_config != NULL);\n\n  return g_steal_pointer (&remote);\n}\n\n// flatpak_fail from common/flatpak-utils-private.h:\n#define flatpak_fail glnx_throw /* <=== common/flatpak-utils-private.h:98:98:flatpak_fail:0 */ \n\n// flatpak_fail_error from common/flatpak-utils.c:\ngboolean /* <=== flatpak_fail_error */ \nflatpak_fail_error (GError **error, FlatpakError code, const char *fmt, ...)\n{\n  if (error == NULL)\n    return FALSE;\n\n  va_list args;\n  va_start (args, fmt);\n  GError *new = g_error_new_valist (FLATPAK_ERROR, code, fmt, args);\n  va_end (args);\n  g_propagate_error (error, g_steal_pointer (&new));\n  return FALSE;\n}\n\n// flatpak_dir_get_deploy_dir from common/flatpak-dir.c:\nGFile * /* <=== flatpak_dir_get_deploy_dir */ \nflatpak_dir_get_deploy_dir (FlatpakDir *self,\n                            FlatpakDecomposed *ref)\n{\n  return g_file_resolve_relative_path (self->basedir, flatpak_decomposed_get_ref (ref));\n}\n\n// flatpak_dir_get_changed_path from common/flatpak-dir.c:\nGFile * /* <=== flatpak_dir_get_changed_path */ \nflatpak_dir_get_changed_path (FlatpakDir *self)\n{\n  return g_file_get_child (self->basedir, \".changed\");\n}\n\n// flatpak_dir_modify_remote from common/flatpak-dir.c:\ngboolean /* <=== flatpak_dir_modify_remote */ \nflatpak_dir_modify_remote (FlatpakDir   *self,\n                           const char   *remote_name,\n                           GKeyFile     *config,\n                           GBytes       *gpg_data,\n                           GCancellable *cancellable,\n                           GError      **error)\n{\n  g_autofree char *group = g_strdup_printf (\"remote \\\"%s\\\"\", remote_name);\n  g_autofree char *url = NULL;\n  g_autofree char *metalink = NULL;\n  g_autoptr(GKeyFile) new_config = NULL;\n  g_autofree gchar *filter_path = NULL;\n  gboolean has_remote;\n\n  if (strchr (remote_name, '/') != NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_REMOTE_NOT_FOUND, _(\"Invalid character '/' in remote name: %s\"),\n                               remote_name);\n\n  has_remote = flatpak_dir_has_remote (self, remote_name, NULL);\n\n  if (!g_key_file_has_group (config, group))\n    return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(\"No configuration for remote %s specified\"),\n                               remote_name);\n\n  if (!flatpak_dir_check_add_remotes_config_dir (self, error))\n    return FALSE;\n\n  if (flatpak_dir_use_system_helper (self, NULL))\n    {\n      g_autofree char *config_data = g_key_file_to_data (config, NULL, NULL);\n      g_autoptr(GVariant) gpg_data_v = NULL;\n      const char *installation = flatpak_dir_get_id (self);\n\n      if (gpg_data != NULL)\n        gpg_data_v = variant_new_ay_bytes (gpg_data);\n      else\n        gpg_data_v = g_variant_ref_sink (g_variant_new_from_data (G_VARIANT_TYPE (\"ay\"), \"\", 0, TRUE, NULL, NULL));\n\n      if (!flatpak_dir_system_helper_call_configure_remote (self,\n                                                            0, remote_name,\n                                                            config_data,\n                                                            gpg_data_v,\n                                                            installation ? installation : \"\",\n                                                            cancellable, error))\n        return FALSE;\n\n      /* If we e.g. changed url or gpg config the cached summary may be invalid */\n      if (!flatpak_dir_remote_clear_cached_summary (self, remote_name, cancellable, error))\n        return FALSE;\n\n      return TRUE;\n    }\n\n  metalink = g_key_file_get_string (config, group, \"metalink\", NULL);\n  if (metalink != NULL && *metalink != 0)\n    url = g_strconcat (\"metalink=\", metalink, NULL);\n  else\n    url = g_key_file_get_string (config, group, \"url\", NULL);\n\n  /* No url => disabled */\n  if (url == NULL)\n    url = g_strdup (\"\");\n\n  if (!flatpak_dir_cleanup_remote_for_url_change (self, remote_name, url, cancellable, error))\n    return FALSE;\n\n  /* Add it if its not there yet */\n  if (!ostree_repo_remote_change (self->repo, NULL,\n                                  OSTREE_REPO_REMOTE_CHANGE_ADD_IF_NOT_EXISTS,\n                                  remote_name,\n                                  url, NULL, cancellable, error))\n    return FALSE;\n\n  new_config = ostree_repo_copy_config (self->repo);\n\n  copy_remote_config (new_config, config, remote_name);\n\n  if (!ostree_repo_write_config (self->repo, new_config, error))\n    return FALSE;\n\n  if (gpg_data != NULL)\n    {\n      g_autoptr(GInputStream) input_stream = g_memory_input_stream_new_from_bytes (gpg_data);\n      guint imported = 0;\n\n      if (!ostree_repo_remote_gpg_import (self->repo, remote_name, input_stream,\n                                          NULL, &imported, cancellable, error))\n        return FALSE;\n\n      /* XXX If we ever add internationalization, use ngettext() here. */\n      g_debug (\"Imported %u GPG key%s to remote \\\"%s\\\"\",\n               imported, (imported == 1) ? \"\" : \"s\", remote_name);\n    }\n\n  filter_path = g_key_file_get_value (new_config, group, \"xa.filter\", NULL);\n  if (filter_path && *filter_path && g_file_test (filter_path, G_FILE_TEST_EXISTS))\n    {\n      /* Make a backup filter copy in case it goes away later */\n      g_autofree char *filter_name = g_strconcat (remote_name, \".filter\", NULL);\n      g_autoptr(GFile) filter_file = g_file_new_for_path (filter_path);\n      g_autoptr(GFile) filter_copy = flatpak_build_file (self->basedir, \"repo\", filter_name, NULL);\n      g_autoptr(GError) local_error = NULL;\n      g_autofree char *backup_data = NULL;\n      gsize backup_data_size;\n\n      if (g_file_load_contents (filter_file, cancellable, &backup_data, &backup_data_size, NULL, &local_error))\n        {\n          g_autofree char *backup_data_copy =\n            g_strdup_printf (\"# backup copy of %s, do not edit!\\n%s\", filter_path, backup_data);\n\n          if (!g_file_replace_contents (filter_copy, backup_data_copy, strlen (backup_data_copy),\n                                        NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, NULL, cancellable, &local_error))\n            g_debug (\"Failed to save backup copy of filter file %s: %s\\n\", filter_path, local_error->message);\n        }\n      else\n        {\n          g_debug (\"Failed to read filter %s file while making a backup copy: %s\\n\", filter_path, local_error->message);\n        }\n    }\n\n  /* If we e.g. changed url or gpg config the cached summary may be invalid */\n  if (!flatpak_dir_remote_clear_cached_summary (self, remote_name, cancellable, error))\n    return FALSE;\n\n  if (!flatpak_dir_mark_changed (self, error))\n    return FALSE;\n\n  if (has_remote)\n    flatpak_dir_log (self, \"modify remote\", remote_name, NULL, NULL, NULL, url,\n                     \"Modified remote %s to %s\", remote_name, url);\n  else\n    flatpak_dir_log (self, \"add remote\", remote_name, NULL, NULL, NULL, url,\n                     \"Added remote %s to %s\", remote_name, url);\n\n  return TRUE;\n}\n\n// _flatpak_dir_reload_config from common/flatpak-dir.c:\nstatic gboolean /* <=== _flatpak_dir_reload_config */ \n_flatpak_dir_reload_config (FlatpakDir   *self,\n                            GCancellable *cancellable,\n                            GError      **error)\n{\n  if (self->repo)\n    {\n      if (!ostree_repo_reload_config (self->repo, cancellable, error))\n        return FALSE;\n    }\n\n  /* Clear cached stuff from repo config */\n  G_LOCK (config_cache);\n\n  g_clear_pointer (&self->masked, g_regex_unref);\n  g_clear_pointer (&self->pinned, g_regex_unref);\n\n  G_UNLOCK (config_cache);\n  return TRUE;\n}\n"
  },
  {
    "repository": "linux",
    "cve_id": "CVE-2022-0847",
    "cwe_list": [
      "CWE-284"
    ],
    "commit_hash": "9d2231c5d74e13b2a0546fee6737ee4446017903",
    "short_hash": "9d2231c5",
    "vulnerableMethods_before": [
      {
        "filename": "iov_iter.c",
        "method_name": "vulnerable_function",
        "raw_code": "static size_t push_pipe(struct iov_iter *i, size_t size,\n\t\t\tint *iter_headp, size_t *offp)\n{\n\tstruct pipe_inode_info *pipe = i->pipe;\n\tunsigned int p_tail = pipe->tail;\n\tunsigned int p_mask = pipe->ring_size - 1;\n\tunsigned int iter_head;\n\tsize_t off;\n\tssize_t left;\n\n\tif (unlikely(size > i->count))\n\t\tsize = i->count;\n\tif (unlikely(!size))\n\t\treturn 0;\n\n\tleft = size;\n\tdata_start(i, &iter_head, &off);\n\t*iter_headp = iter_head;\n\t*offp = off;\n\tif (off) {\n\t\tleft -= PAGE_SIZE - off;\n\t\tif (left <= 0) {\n\t\t\tpipe->bufs[iter_head & p_mask].len += size;\n\t\t\treturn size;\n\t\t}\n\t\tpipe->bufs[iter_head & p_mask].len = PAGE_SIZE;\n\t\titer_head++;\n\t}\n\twhile (!pipe_full(iter_head, p_tail, pipe->max_usage)) {\n\t\tstruct pipe_buffer *buf = &pipe->bufs[iter_head & p_mask];\n\t\tstruct page *page = alloc_page(GFP_USER);\n\t\tif (!page)\n\t\t\tbreak;\n\n\t\tbuf->ops = &default_pipe_buf_ops;\n\t\tbuf->page = page;\n\t\tbuf->offset = 0;\n\t\tbuf->len = min_t(ssize_t, left, PAGE_SIZE);\n\t\tleft -= buf->len;\n\t\titer_head++;\n\t\tpipe->head = iter_head;\n\n\t\tif (left == 0)\n\t\t\treturn size;\n\t}\n\treturn size - left;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "iov_iter.c",
        "method_name": "fixed_function",
        "raw_code": "static size_t push_pipe(struct iov_iter *i, size_t size,\n\t\t\tint *iter_headp, size_t *offp)\n{\n\tstruct pipe_inode_info *pipe = i->pipe;\n\tunsigned int p_tail = pipe->tail;\n\tunsigned int p_mask = pipe->ring_size - 1;\n\tunsigned int iter_head;\n\tsize_t off;\n\tssize_t left;\n\n\tif (unlikely(size > i->count))\n\t\tsize = i->count;\n\tif (unlikely(!size))\n\t\treturn 0;\n\n\tleft = size;\n\tdata_start(i, &iter_head, &off);\n\t*iter_headp = iter_head;\n\t*offp = off;\n\tif (off) {\n\t\tleft -= PAGE_SIZE - off;\n\t\tif (left <= 0) {\n\t\t\tpipe->bufs[iter_head & p_mask].len += size;\n\t\t\treturn size;\n\t\t}\n\t\tpipe->bufs[iter_head & p_mask].len = PAGE_SIZE;\n\t\titer_head++;\n\t}\n\twhile (!pipe_full(iter_head, p_tail, pipe->max_usage)) {\n\t\tstruct pipe_buffer *buf = &pipe->bufs[iter_head & p_mask];\n\t\tstruct page *page = alloc_page(GFP_USER);\n\t\tif (!page)\n\t\t\tbreak;\n\n\t\tbuf->ops = &default_pipe_buf_ops;\n\t\tbuf->flags = 0;\n\t\tbuf->page = page;\n\t\tbuf->offset = 0;\n\t\tbuf->len = min_t(ssize_t, left, PAGE_SIZE);\n\t\tleft -= buf->len;\n\t\titer_head++;\n\t\tpipe->head = iter_head;\n\n\t\tif (left == 0)\n\t\t\treturn size;\n\t}\n\treturn size - left;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <linux/instrumented.h>\n#include <linux/fault-inject-usercopy.h>\n#include <linux/scatterlist.h>\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/bvec.h>\n#include <linux/uio.h>\n#include <linux/highmem.h>\n#include <net/checksum.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/pagemap.h>\n#include <linux/splice.h>\n#include <linux/compat.h>\n\n// Type Definitions:\n// page:\nstruct page\n\n// Called Methods (top 10):\n// sanity from lib/iov_iter.c:\nstatic bool sanity(const struct iov_iter *i) /* <=== sanity */ \n{\n\tstruct pipe_inode_info *pipe = i->pipe;\n\tunsigned int p_head = pipe->head;\n\tunsigned int p_tail = pipe->tail;\n\tunsigned int p_mask = pipe->ring_size - 1;\n\tunsigned int p_occupancy = pipe_occupancy(p_head, p_tail);\n\tunsigned int i_head = i->head;\n\tunsigned int idx;\n\n\tif (i->iov_offset) {\n\t\tstruct pipe_buffer *p;\n\t\tif (unlikely(p_occupancy == 0))\n\t\t\tgoto Bad;\t// pipe must be non-empty\n\t\tif (unlikely(i_head != p_head - 1))\n\t\t\tgoto Bad;\t// must be at the last buffer...\n\n\t\tp = &pipe->bufs[i_head & p_mask];\n\t\tif (unlikely(p->offset + p->len != i->iov_offset))\n\t\t\tgoto Bad;\t// ... at the end of segment\n\t} else {\n\t\tif (i_head != p_head)\n\t\t\tgoto Bad;\t// must be right after the last buffer\n\t}\n\treturn true;\nBad:\n\tprintk(KERN_ERR \"idx = %d, offset = %zd\\n\", i_head, i->iov_offset);\n\tprintk(KERN_ERR \"head = %d, tail = %d, buffers = %d\\n\",\n\t\t\tp_head, p_tail, pipe->ring_size);\n\tfor (idx = 0; idx < pipe->ring_size; idx++)\n\t\tprintk(KERN_ERR \"[%p %p %d %d]\\n\",\n\t\t\tpipe->bufs[idx].ops,\n\t\t\tpipe->bufs[idx].page,\n\t\t\tpipe->bufs[idx].offset,\n\t\t\tpipe->bufs[idx].len);\n\tWARN_ON(1);\n\treturn false;\n}\n"
  },
  {
    "repository": "pcre2",
    "cve_id": "CVE-2022-1587",
    "cwe_list": [
      "CWE-703"
    ],
    "commit_hash": "03654e751e7f0700693526b67dfcadda6b42c9d0",
    "short_hash": "03654e75",
    "vulnerableMethods_before": [
      {
        "filename": "pcre2_jit_compile.c",
        "method_name": "vulnerable_function",
        "raw_code": "static int get_recurse_data_length(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend,\n  BOOL *needs_control_head, BOOL *has_quit, BOOL *has_accept)\n{\nint length = 1;\nint size;\nPCRE2_SPTR alternative;\nBOOL quit_found = FALSE;\nBOOL accept_found = FALSE;\nBOOL setsom_found = FALSE;\nBOOL setmark_found = FALSE;\nBOOL capture_last_found = FALSE;\nBOOL control_head_found = FALSE;\n\n#if defined DEBUG_FORCE_CONTROL_HEAD && DEBUG_FORCE_CONTROL_HEAD\nSLJIT_ASSERT(common->control_head_ptr != 0);\ncontrol_head_found = TRUE;\n#endif\n\n/* Calculate the sum of the private machine words. */\nwhile (cc < ccend)\n  {\n  size = 0;\n  switch(*cc)\n    {\n    case OP_SET_SOM:\n    SLJIT_ASSERT(common->has_set_som);\n    setsom_found = TRUE;\n    cc += 1;\n    break;\n\n    case OP_RECURSE:\n    if (common->has_set_som)\n      setsom_found = TRUE;\n    if (common->mark_ptr != 0)\n      setmark_found = TRUE;\n    if (common->capture_last_ptr != 0)\n      capture_last_found = TRUE;\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_KET:\n    if (PRIVATE_DATA(cc) != 0)\n      {\n      length++;\n      SLJIT_ASSERT(PRIVATE_DATA(cc + 1) != 0);\n      cc += PRIVATE_DATA(cc + 1);\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_ASSERT:\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    case OP_ASSERT_NA:\n    case OP_ASSERTBACK_NA:\n    case OP_ONCE:\n    case OP_SCRIPT_RUN:\n    case OP_BRAPOS:\n    case OP_SBRA:\n    case OP_SBRAPOS:\n    case OP_SCOND:\n    length++;\n    SLJIT_ASSERT(PRIVATE_DATA(cc) != 0);\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_CBRA:\n    case OP_SCBRA:\n    length += 2;\n    if (common->capture_last_ptr != 0)\n      capture_last_found = TRUE;\n    if (common->optimized_cbracket[GET2(cc, 1 + LINK_SIZE)] == 0)\n      length++;\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_CBRAPOS:\n    case OP_SCBRAPOS:\n    length += 2 + 2;\n    if (common->capture_last_ptr != 0)\n      capture_last_found = TRUE;\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_COND:\n    /* Might be a hidden SCOND. */\n    alternative = cc + GET(cc, 1);\n    if (*alternative == OP_KETRMAX || *alternative == OP_KETRMIN)\n      length++;\n    cc += 1 + LINK_SIZE;\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_1\n    if (PRIVATE_DATA(cc) != 0)\n      length++;\n    cc += 2;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_2A\n    if (PRIVATE_DATA(cc) != 0)\n      length += 2;\n    cc += 2;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_2B\n    if (PRIVATE_DATA(cc) != 0)\n      length += 2;\n    cc += 2 + IMM2_SIZE;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_1\n    if (PRIVATE_DATA(cc) != 0)\n      length++;\n    cc += 1;\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_2A\n    if (PRIVATE_DATA(cc) != 0)\n      length += 2;\n    cc += 1;\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_2B\n    if (PRIVATE_DATA(cc) != 0)\n      length += 2;\n    cc += 1 + IMM2_SIZE;\n    break;\n\n    case OP_CLASS:\n    case OP_NCLASS:\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n    case OP_XCLASS:\n    size = (*cc == OP_XCLASS) ? GET(cc, 1) : 1 + 32 / (int)sizeof(PCRE2_UCHAR);\n#else\n    size = 1 + 32 / (int)sizeof(PCRE2_UCHAR);\n#endif\n    if (PRIVATE_DATA(cc) != 0)\n      length += get_class_iterator_size(cc + size);\n    cc += size;\n    break;\n\n    case OP_MARK:\n    case OP_COMMIT_ARG:\n    case OP_PRUNE_ARG:\n    case OP_THEN_ARG:\n    SLJIT_ASSERT(common->mark_ptr != 0);\n    if (!setmark_found)\n      setmark_found = TRUE;\n    if (common->control_head_ptr != 0)\n      control_head_found = TRUE;\n    if (*cc != OP_MARK)\n      quit_found = TRUE;\n\n    cc += 1 + 2 + cc[1];\n    break;\n\n    case OP_PRUNE:\n    case OP_SKIP:\n    case OP_COMMIT:\n    quit_found = TRUE;\n    cc++;\n    break;\n\n    case OP_SKIP_ARG:\n    quit_found = TRUE;\n    cc += 1 + 2 + cc[1];\n    break;\n\n    case OP_THEN:\n    SLJIT_ASSERT(common->control_head_ptr != 0);\n    quit_found = TRUE;\n    if (!control_head_found)\n      control_head_found = TRUE;\n    cc++;\n    break;\n\n    case OP_ACCEPT:\n    case OP_ASSERT_ACCEPT:\n    accept_found = TRUE;\n    cc++;\n    break;\n\n    default:\n    cc = next_opcode(common, cc);\n    SLJIT_ASSERT(cc != NULL);\n    break;\n    }\n  }\nSLJIT_ASSERT(cc == ccend);\n\nif (control_head_found)\n  length++;\nif (capture_last_found)\n  length++;\nif (quit_found)\n  {\n  if (setsom_found)\n    length++;\n  if (setmark_found)\n    length++;\n  }\n\n*needs_control_head = control_head_found;\n*has_quit = quit_found;\n*has_accept = accept_found;\nreturn length;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "pcre2_jit_compile.c",
        "method_name": "fixed_function",
        "raw_code": "static int get_recurse_data_length(compiler_common *common, PCRE2_SPTR cc, PCRE2_SPTR ccend,\n  BOOL *needs_control_head, BOOL *has_quit, BOOL *has_accept)\n{\nint length = 1;\nint size, offset;\nPCRE2_SPTR alternative;\nBOOL quit_found = FALSE;\nBOOL accept_found = FALSE;\nBOOL setsom_found = FALSE;\nBOOL setmark_found = FALSE;\nBOOL control_head_found = FALSE;\n\nmemset(common->recurse_bitset, 0, common->recurse_bitset_size);\n\n#if defined DEBUG_FORCE_CONTROL_HEAD && DEBUG_FORCE_CONTROL_HEAD\nSLJIT_ASSERT(common->control_head_ptr != 0);\ncontrol_head_found = TRUE;\n#endif\n\n/* Calculate the sum of the private machine words. */\nwhile (cc < ccend)\n  {\n  size = 0;\n  switch(*cc)\n    {\n    case OP_SET_SOM:\n    SLJIT_ASSERT(common->has_set_som);\n    setsom_found = TRUE;\n    cc += 1;\n    break;\n\n    case OP_RECURSE:\n    if (common->has_set_som)\n      setsom_found = TRUE;\n    if (common->mark_ptr != 0)\n      setmark_found = TRUE;\n    if (common->capture_last_ptr != 0 && recurse_check_bit(common, common->capture_last_ptr))\n      length++;\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_KET:\n    offset = PRIVATE_DATA(cc);\n    if (offset != 0)\n      {\n      if (recurse_check_bit(common, offset))\n        length++;\n      SLJIT_ASSERT(PRIVATE_DATA(cc + 1) != 0);\n      cc += PRIVATE_DATA(cc + 1);\n      }\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_ASSERT:\n    case OP_ASSERT_NOT:\n    case OP_ASSERTBACK:\n    case OP_ASSERTBACK_NOT:\n    case OP_ASSERT_NA:\n    case OP_ASSERTBACK_NA:\n    case OP_ONCE:\n    case OP_SCRIPT_RUN:\n    case OP_BRAPOS:\n    case OP_SBRA:\n    case OP_SBRAPOS:\n    case OP_SCOND:\n    SLJIT_ASSERT(PRIVATE_DATA(cc) != 0);\n    if (recurse_check_bit(common, PRIVATE_DATA(cc)))\n      length++;\n    cc += 1 + LINK_SIZE;\n    break;\n\n    case OP_CBRA:\n    case OP_SCBRA:\n    offset = GET2(cc, 1 + LINK_SIZE);\n    if (recurse_check_bit(common, OVECTOR(offset << 1)))\n      {\n      SLJIT_ASSERT(recurse_check_bit(common, OVECTOR((offset << 1) + 1)));\n      length += 2;\n      }\n    if (common->optimized_cbracket[offset] == 0 && recurse_check_bit(common, OVECTOR_PRIV(offset)))\n      length++;\n    if (common->capture_last_ptr != 0 && recurse_check_bit(common, common->capture_last_ptr))\n      length++;\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_CBRAPOS:\n    case OP_SCBRAPOS:\n    offset = GET2(cc, 1 + LINK_SIZE);\n    if (recurse_check_bit(common, OVECTOR(offset << 1)))\n      {\n      SLJIT_ASSERT(recurse_check_bit(common, OVECTOR((offset << 1) + 1)));\n      length += 2;\n      }\n    if (recurse_check_bit(common, OVECTOR_PRIV(offset)))\n      length++;\n    if (recurse_check_bit(common, PRIVATE_DATA(cc)))\n      length++;\n    if (common->capture_last_ptr != 0 && recurse_check_bit(common, common->capture_last_ptr))\n      length++;\n    cc += 1 + LINK_SIZE + IMM2_SIZE;\n    break;\n\n    case OP_COND:\n    /* Might be a hidden SCOND. */\n    alternative = cc + GET(cc, 1);\n    if ((*alternative == OP_KETRMAX || *alternative == OP_KETRMIN) && recurse_check_bit(common, PRIVATE_DATA(cc)))\n      length++;\n    cc += 1 + LINK_SIZE;\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_1\n    offset = PRIVATE_DATA(cc);\n    if (offset != 0 && recurse_check_bit(common, offset))\n      length++;\n    cc += 2;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_2A\n    offset = PRIVATE_DATA(cc);\n    if (offset != 0 && recurse_check_bit(common, offset))\n      {\n      SLJIT_ASSERT(recurse_check_bit(common, offset + sizeof(sljit_sw)));\n      length += 2;\n      }\n    cc += 2;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n    break;\n\n    CASE_ITERATOR_PRIVATE_DATA_2B\n    offset = PRIVATE_DATA(cc);\n    if (offset != 0 && recurse_check_bit(common, offset))\n      {\n      SLJIT_ASSERT(recurse_check_bit(common, offset + sizeof(sljit_sw)));\n      length += 2;\n      }\n    cc += 2 + IMM2_SIZE;\n#ifdef SUPPORT_UNICODE\n    if (common->utf && HAS_EXTRALEN(cc[-1])) cc += GET_EXTRALEN(cc[-1]);\n#endif\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_1\n    offset = PRIVATE_DATA(cc);\n    if (offset != 0 && recurse_check_bit(common, offset))\n      length++;\n    cc += 1;\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_2A\n    offset = PRIVATE_DATA(cc);\n    if (offset != 0 && recurse_check_bit(common, offset))\n      {\n      SLJIT_ASSERT(recurse_check_bit(common, offset + sizeof(sljit_sw)));\n      length += 2;\n      }\n    cc += 1;\n    break;\n\n    CASE_ITERATOR_TYPE_PRIVATE_DATA_2B\n    offset = PRIVATE_DATA(cc);\n    if (offset != 0 && recurse_check_bit(common, offset))\n      {\n      SLJIT_ASSERT(recurse_check_bit(common, offset + sizeof(sljit_sw)));\n      length += 2;\n      }\n    cc += 1 + IMM2_SIZE;\n    break;\n\n    case OP_CLASS:\n    case OP_NCLASS:\n#if defined SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8\n    case OP_XCLASS:\n    size = (*cc == OP_XCLASS) ? GET(cc, 1) : 1 + 32 / (int)sizeof(PCRE2_UCHAR);\n#else\n    size = 1 + 32 / (int)sizeof(PCRE2_UCHAR);\n#endif\n\n    offset = PRIVATE_DATA(cc);\n    if (offset != 0 && recurse_check_bit(common, offset))\n      length += get_class_iterator_size(cc + size);\n    cc += size;\n    break;\n\n    case OP_MARK:\n    case OP_COMMIT_ARG:\n    case OP_PRUNE_ARG:\n    case OP_THEN_ARG:\n    SLJIT_ASSERT(common->mark_ptr != 0);\n    if (!setmark_found)\n      setmark_found = TRUE;\n    if (common->control_head_ptr != 0)\n      control_head_found = TRUE;\n    if (*cc != OP_MARK)\n      quit_found = TRUE;\n\n    cc += 1 + 2 + cc[1];\n    break;\n\n    case OP_PRUNE:\n    case OP_SKIP:\n    case OP_COMMIT:\n    quit_found = TRUE;\n    cc++;\n    break;\n\n    case OP_SKIP_ARG:\n    quit_found = TRUE;\n    cc += 1 + 2 + cc[1];\n    break;\n\n    case OP_THEN:\n    SLJIT_ASSERT(common->control_head_ptr != 0);\n    quit_found = TRUE;\n    control_head_found = TRUE;\n    cc++;\n    break;\n\n    case OP_ACCEPT:\n    case OP_ASSERT_ACCEPT:\n    accept_found = TRUE;\n    cc++;\n    break;\n\n    default:\n    cc = next_opcode(common, cc);\n    SLJIT_ASSERT(cc != NULL);\n    break;\n    }\n  }\nSLJIT_ASSERT(cc == ccend);\n\nif (control_head_found)\n  length++;\nif (quit_found)\n  {\n  if (setsom_found)\n    length++;\n  if (setmark_found)\n    length++;\n  }\n\n*needs_control_head = control_head_found;\n*has_quit = quit_found;\n*has_accept = accept_found;\nreturn length;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"sljit/sljitLir.c\"\n#include \"pcre2_jit_misc.c\"\n#include \"pcre2_internal.h\"\n#include \"config.h\"\n#include \"pcre2_jit_match.c\"\n#include \"pcre2_jit_simd_inc.h\"\n\n// Type Definitions:\n// BOOL:\ntypedef int BOOL;\n\n// sljit_sw:\ntypedef long long sljit_sw;\n\n// compiler_common:\ntypedef struct compiler_common {\n  /* The sljit ceneric compiler. */\n  struct sljit_compiler *compiler;\n  /* Compiled regular expression. */\n  pcre2_real_code *re;\n  /* First byte code. */\n  PCRE2_SPTR start;\n  /* Maps private data offset to each opcode. */\n  sljit_s32 *private_data_ptrs;\n  /* Chain list of read-only data ptrs. */\n  void *read_only_data_head;\n  /* Tells whether the capturing bracket is optimized. */\n  sljit_u8 *optimized_cbracket;\n  /* Tells whether the starting offset is a target of then. */\n  sljit_u8 *then_offsets;\n  /* Current position where a THEN must jump. */\n  then_trap_backtrack *then_trap;\n  /* Starting offset of private data for capturing brackets. */\n  sljit_s32 cbra_ptr;\n  /* Output vector starting point. Must be divisible by 2. */\n  sljit_s32 ovector_start;\n  /* Points to the starting character of the current match. */\n  sljit_s32 start_ptr;\n  /* Last known position of the requested byte. */\n  sljit_s32 req_char_ptr;\n  /* Head of the last recursion. */...\n\n// sljit_sw:\ntypedef long int sljit_sw;\n"
  },
  {
    "repository": "mruby",
    "cve_id": "CVE-2021-4188",
    "cwe_list": [
      "CWE-476"
    ],
    "commit_hash": "27d1e0132a0804581dca28df042e7047fd27eaa8",
    "short_hash": "27d1e013",
    "vulnerableMethods_before": [
      {
        "filename": "array.c",
        "method_name": "vulnerable_function",
        "raw_code": "mrb_ary_shift_m(mrb_state *mrb, mrb_value self)\n{\n  struct RArray *a = mrb_ary_ptr(self);\n  mrb_int len = ARY_LEN(a);\n  mrb_int n;\n  mrb_value val;\n\n  if (mrb_get_args(mrb, \"|i\", &n) == 0) {\n    return mrb_ary_shift(mrb, self);\n  };\n  ary_modify_check(mrb, a);\n  if (len == 0 || n == 0) return mrb_ary_new(mrb);\n  if (n < 0) mrb_raise(mrb, E_ARGUMENT_ERROR, \"negative array shift\");\n  if (n > len) n = len;\n  val = mrb_ary_new_from_values(mrb, n, ARY_PTR(a));\n  if (ARY_SHARED_P(a)) {\n  L_SHIFT:\n    a->as.heap.ptr+=n;\n    a->as.heap.len-=n;\n    return val;\n  }\n  if (len > ARY_SHIFT_SHARED_MIN) {\n    ary_make_shared(mrb, a);\n    goto L_SHIFT;\n  }\n  else if (len == n) {\n    ARY_SET_LEN(a, 0);\n  }\n  else {\n    mrb_value *ptr = ARY_PTR(a);\n    mrb_int size = len-n;\n\n    while (size--) {\n      *ptr = *(ptr+n);\n      ++ptr;\n    }\n    ARY_SET_LEN(a, len-n);\n  }\n  return val;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "array.c",
        "method_name": "fixed_function",
        "raw_code": "mrb_ary_shift_m(mrb_state *mrb, mrb_value self)\n{\n  mrb_int n;\n\n  if (mrb_get_args(mrb, \"|i\", &n) == 0) {\n    return mrb_ary_shift(mrb, self);\n  }\n\n  struct RArray *a = mrb_ary_ptr(self);\n  mrb_int len = ARY_LEN(a);\n  mrb_value val;\n\n  ary_modify_check(mrb, a);\n  if (len == 0 || n == 0) return mrb_ary_new(mrb);\n  if (n < 0) mrb_raise(mrb, E_ARGUMENT_ERROR, \"negative array shift\");\n  if (n > len) n = len;\n  val = mrb_ary_new_from_values(mrb, n, ARY_PTR(a));\n  if (ARY_SHARED_P(a)) {\n  L_SHIFT:\n    a->as.heap.ptr+=n;\n    a->as.heap.len-=n;\n    return val;\n  }\n  if (len > ARY_SHIFT_SHARED_MIN) {\n    ary_make_shared(mrb, a);\n    goto L_SHIFT;\n  }\n  else if (len == n) {\n    ARY_SET_LEN(a, 0);\n  }\n  else {\n    mrb_value *ptr = ARY_PTR(a);\n    mrb_int size = len-n;\n\n    while (size--) {\n      *ptr = *(ptr+n);\n      ++ptr;\n    }\n    ARY_SET_LEN(a, len-n);\n  }\n  return val;\n}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "tensorflow",
    "cve_id": "CVE-2021-37647",
    "cwe_list": [
      "CWE-476"
    ],
    "commit_hash": "02cc160e29d20631de3859c6653184e3f876b9d7",
    "short_hash": "02cc160e",
    "vulnerableMethods_before": [
      {
        "filename": "sparse_tensor_slice_dataset_op.cc",
        "method_name": "vulnerable_function",
        "raw_code": "  void MakeDataset(OpKernelContext* ctx, DatasetBase** output) override {\n    // Create a new SparseTensorSliceDatasetOp::Dataset, insert it in\n    // the step container, and return it as the output.\n    const Tensor* indices;\n    OP_REQUIRES_OK(ctx, ctx->input(\"indices\", &indices));\n    const Tensor* values;\n    OP_REQUIRES_OK(ctx, ctx->input(\"values\", &values));\n    const Tensor* dense_shape;\n    OP_REQUIRES_OK(ctx, ctx->input(\"dense_shape\", &dense_shape));\n\n    OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(indices->shape()),\n                errors::InvalidArgument(\n                    \"Input indices should be a matrix but received shape \",\n                    indices->shape().DebugString()));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(values->shape()),\n                errors::InvalidArgument(\n                    \"Input values should be a vector but received shape \",\n                    indices->shape().DebugString()));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(dense_shape->shape()),\n                errors::InvalidArgument(\n                    \"Input shape should be a vector but received shape \",\n                    dense_shape->shape().DebugString()));\n\n    // We currently ensure that `sparse_tensor` is ordered in the\n    // batch dimension.\n    // TODO(mrry): Investigate ways to avoid this unconditional check\n    // if we can be sure that the sparse tensor was produced in an\n    // appropriate order (e.g. by `tf.parse_example()` or a Dataset\n    // that batches elements into rows of a SparseTensor).\n    int64_t previous_batch_index = -1;\n    for (int64_t i = 0; i < indices->dim_size(0); ++i) {\n      int64_t next_batch_index = indices->matrix<int64>()(i, 0);\n      OP_REQUIRES(\n          ctx, next_batch_index >= previous_batch_index,\n          errors::Unimplemented(\"The SparseTensor must be ordered in the batch \"\n                                \"dimension; handling arbitrarily ordered input \"\n                                \"is not currently supported.\"));\n      previous_batch_index = next_batch_index;\n    }\n    gtl::InlinedVector<int64, 8> std_order(dense_shape->NumElements(), 0);\n    sparse::SparseTensor tensor;\n    OP_REQUIRES_OK(\n        ctx, sparse::SparseTensor::Create(\n                 *indices, *values, TensorShape(dense_shape->vec<int64>()),\n                 std_order, &tensor));\n    *output = new Dataset<T>(ctx, std::move(tensor));\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "sparse_tensor_slice_dataset_op.cc",
        "method_name": "fixed_function",
        "raw_code": "  void MakeDataset(OpKernelContext* ctx, DatasetBase** output) override {\n    // Create a new SparseTensorSliceDatasetOp::Dataset, insert it in\n    // the step container, and return it as the output.\n    const Tensor* indices;\n    OP_REQUIRES_OK(ctx, ctx->input(\"indices\", &indices));\n    const Tensor* values;\n    OP_REQUIRES_OK(ctx, ctx->input(\"values\", &values));\n    const Tensor* dense_shape;\n    OP_REQUIRES_OK(ctx, ctx->input(\"dense_shape\", &dense_shape));\n\n    OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(indices->shape()),\n                errors::InvalidArgument(\n                    \"Input indices should be a matrix but received shape \",\n                    indices->shape().DebugString()));\n\n    const auto num_indices = indices->NumElements();\n    const auto num_values = values->NumElements();\n    if (num_indices == 0 || num_values == 0) {\n      OP_REQUIRES(ctx, num_indices == num_values,\n                  errors::InvalidArgument(\n                      \"If indices or values are empty, the other one must also \"\n                      \"be. Got indices of shape \",\n                      indices->shape().DebugString(), \" and values of shape \",\n                      values->shape().DebugString()));\n    }\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(values->shape()),\n                errors::InvalidArgument(\n                    \"Input values should be a vector but received shape \",\n                    indices->shape().DebugString()));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(dense_shape->shape()),\n                errors::InvalidArgument(\n                    \"Input shape should be a vector but received shape \",\n                    dense_shape->shape().DebugString()));\n\n    // We currently ensure that `sparse_tensor` is ordered in the\n    // batch dimension.\n    // TODO(mrry): Investigate ways to avoid this unconditional check\n    // if we can be sure that the sparse tensor was produced in an\n    // appropriate order (e.g. by `tf.parse_example()` or a Dataset\n    // that batches elements into rows of a SparseTensor).\n    int64_t previous_batch_index = -1;\n    for (int64_t i = 0; i < indices->dim_size(0); ++i) {\n      int64_t next_batch_index = indices->matrix<int64>()(i, 0);\n      OP_REQUIRES(\n          ctx, next_batch_index >= previous_batch_index,\n          errors::Unimplemented(\"The SparseTensor must be ordered in the batch \"\n                                \"dimension; handling arbitrarily ordered input \"\n                                \"is not currently supported.\"));\n      previous_batch_index = next_batch_index;\n    }\n    gtl::InlinedVector<int64, 8> std_order(dense_shape->NumElements(), 0);\n    sparse::SparseTensor tensor;\n    OP_REQUIRES_OK(\n        ctx, sparse::SparseTensor::Create(\n                 *indices, *values, TensorShape(dense_shape->vec<int64>()),\n                 std_order, &tensor));\n    *output = new Dataset<T>(ctx, std::move(tensor));\n  }",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"tensorflow/core/framework/dataset.h\"\n#include \"tensorflow/core/framework/partial_tensor_shape.h\"\n#include \"tensorflow/core/util/sparse/sparse_tensor.h\"\n#include <numeric>\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n\n// Type Definitions:\n// TensorShape:\nclass TensorShape : public TensorShapeBase<TensorShape> {\n public:\n  using TensorShapeBase<TensorShape>::TensorShapeBase;\n\n  /// Allow a TensorShape to be used as a PartialTensorShape without copying\n  operator const PartialTensorShape&() const;  // NOLINT(runtime/explicit)\n\n  /// Returns true if `*this` and `b` have the same sizes. Ignores\n  /// dimension names.\n  bool IsSameSize(const TensorShape& b) const;\n  bool operator==(const TensorShape& b) const { return IsSameSize(b); }\n  bool operator!=(const TensorShape& b) const { return !IsSameSize(b); }\n\n  /// Fill `*dsizes` from `*this`.\n  /// Notice: Using IndexType=int32 in combination with To32Bit() can\n  /// significantly improve performance on GPU.\n  template <int NDIMS, typename IndexType = Eigen::DenseIndex>\n  Eigen::DSizes<IndexType, NDIMS> AsEigenDSizes() const;\n\n  // Same as `AsEigenDSizes()` but returns a `Status` instead.\n  // Use this method to surface error to user instead of crashing if `NDMIS` is\n  // not equal to `di...\n\n// Tensor:\ntensorflow.TensorHandle.Tensor:tensorflow.Status(tensorflow.Tensor**)<const>\n\n// OpKernelContext:\nclass OpKernelContext {\n public:\n  // The first element of a WrappedAllocator is a \"base\" Allocator and\n  // the second element is that Allocator wrapped by a\n  // TrackingAllocator\n  typedef std::pair<Allocator*, TrackingAllocator*> WrappedAllocator;\n\n  // TODO(zhifengc): Do some cleanup of Params.\n  // The Params struct is passed in to initialize an OpKernelContext,\n  // and must outlive the OpKernelContext.\n  struct Params {\n    ~Params() { delete eigen_gpu_device; }\n\n    // The step being executed.\n    int64 step_id = 0;\n\n    // Timestamp for the start of graph execution. Used for latency metrics.\n    int64 start_time_usecs = 0;\n\n    // The op kernel being computed.\n    OpKernel* op_kernel = nullptr;\n\n    // The device on which the kernel is running.\n    DeviceBase* device = nullptr;\n\n    // The Eigen GPU device wrapper, which may include a per-op\n    // wrapped allocator. The concrete type of this object depends on\n    // the type of this->device, so eigen_gpu_device can't be a...\n\n// Dataset:\nclass BatchDatasetOp::Dataset : public DatasetBase {\n public:\n  Dataset(OpKernelContext* ctx, int64_t batch_size, bool drop_remainder,\n          bool parallel_copy, const DatasetBase* input, int op_version)\n      : DatasetBase(DatasetContext(ctx)),\n        batch_size_(batch_size),\n        // Dataset batch is sometimes used to stack all elements in the\n        // dataset. In such cases, a very large batch size (e.g., INT32_MAX)\n        // is passed with drop_remainder set to false. Avoid OOM in such case\n        // by limiting `reserve()` size by 2**16.\n        reserve_size_(drop_remainder ? batch_size\n                                     : std::min<int64>(batch_size, 1 << 16)),\n        drop_remainder_(drop_remainder),\n        parallel_copy_(parallel_copy),\n        input_(input),\n        op_version_(op_version),\n        traceme_metadata_(\n            {{\"batch_size\",\n              strings::Printf(\"%lld\", static_cast<long long>(batch_size))},\n             {\"drop_remainder\", drop_remain...\n\n// DatasetBase:\nclass DatasetBase : public core::RefCounted {\n public:\n  // Key for storing the Dataset graph in the serialized format.\n  TF_EXPORT static const char kDatasetGraphKey[];\n\n  // Key for storing the output node of the Dataset graph in the serialized\n  // format.\n  TF_EXPORT static const char kDatasetGraphOutputNodeKey[];\n\n  explicit DatasetBase(DatasetContext&& ctx)\n      : type_string_(ctx.type_string()), node_name_(ctx.node_name()) {}\n\n  // Op type name of this dataset.\n  const string& type_string() const { return type_string_; }\n\n  // Graph node name of this dataset op, uniquely identifying the dataset in\n  // the graph.\n  const string& node_name() const { return node_name_; }\n\n  // Initializes the dataset.\n  void Initialize();\n\n  const Options& options() const { return options_; }\n\n  int64 num_sources() const { return num_sources_; }\n\n  // Returns a new iterator for iterating over the range of elements in\n  // this dataset.\n  //\n  // This method may be called multiple times on the ...\n\n// Status:\nclass Status\n\n// Status:\nclass Status {\n public:\n  /// Create a success status.\n  Status() {}\n\n  /// \\brief Create a status with the specified error code and msg as a\n  /// human-readable string containing more detailed information.\n  Status(tensorflow::error::Code code, tensorflow::StringPiece msg)\n      : Status(code, msg, {}) {}\n\n  /// \\brief Create a status with the specified error code, msg, and stack trace\n  /// as a human-readable string containing more detailed information.\n#ifndef SWIG\n  Status(tensorflow::error::Code code, tensorflow::StringPiece msg,\n         std::vector<StackFrame>&& stack_trace);\n#endif\n\n  /// Copy the specified status.\n  Status(const Status& s);\n  Status& operator=(const Status& s);\n#ifndef SWIG\n  Status(Status&& s) noexcept;\n  Status& operator=(Status&& s) noexcept;\n#endif  // SWIG\n\n  static Status OK() { return Status(); }\n\n  /// Returns true iff the status indicates success.\n  bool ok() const { return (state_ == nullptr); }\n\n  tensorflow::error::Code code() const {\n    retu...\n\n// TensorShape:\nclass TensorShape\n\n// SparseTensor:\nclass SparseTensor {\n public:\n  typedef typename gtl::ArraySlice<int64> VarDimArray;\n  typedef typename gtl::InlinedVector<int64, 8> ShapeArray;\n\n  static Status Create(Tensor ix, Tensor vals, const VarDimArray shape,\n                       const VarDimArray order, SparseTensor* result);\n\n  static Status Create(Tensor ix, Tensor vals, const TensorShape& shape,\n                       SparseTensor* result);\n\n  static Status Create(Tensor ix, Tensor vals, const VarDimArray shape,\n                       SparseTensor* result);\n\n  static Status Create(Tensor ix, Tensor vals, const TensorShape& shape,\n                       const VarDimArray order, SparseTensor* result);\n\n  SparseTensor() : dims_(0) {}\n\n  ABSL_DEPRECATED(\"Use Create() functions instead of constructors directly.\")\n  SparseTensor(Tensor ix, Tensor vals, const TensorShape& shape)\n      : SparseTensor(std::move(ix), std::move(vals), TensorShapeToVector(shape),\n                     UndefinedOrder(TensorShapeToVector(shape))) {}...\n\n// OpKernelContext:\ntensorflow.OpKernelContext.OpKernelContext:ANY(tensorflow.OpKernelContext.Params*)\n\n// Tensor:\nclass Tensor {\n public:\n  /// \\brief Creates a 1-dimensional, 0-element float tensor.\n  ///\n  /// The returned Tensor is not a scalar (shape {}), but is instead\n  /// an empty one-dimensional Tensor (shape {0}, NumElements() ==\n  /// 0). Since it has no elements, it does not need to be assigned a\n  /// value and is initialized by default (IsInitialized() is\n  /// true). If this is undesirable, consider creating a one-element\n  /// scalar which does require initialization:\n  ///\n  /// ```c++\n  ///\n  ///     Tensor(DT_FLOAT, TensorShape({}))\n  ///\n  /// ```\n  Tensor();\n\n  /// \\brief Creates a Tensor of the given `type` and `shape`.  If\n  /// LogMemory::IsEnabled() the allocation is logged as coming from\n  /// an unknown kernel and step. Calling the Tensor constructor\n  /// directly from within an Op is deprecated: use the\n  /// OpKernelConstruction/OpKernelContext allocate_* methods to\n  /// allocate a new tensor, which record the kernel and step.\n  ///\n  /// The underlying buffer is ...\n\n// Called Methods (top 10):\n// CtxFailure from tensorflow/core/framework/op_kernel.cc:\nvoid OpKernelContext::CtxFailure(const char* file, int line, const Status& s) { /* <=== tensorflow.OpKernelContext.CtxFailure:void(char*,int,tensorflow.Status&) */ \n  VLOG(1) << \"OP_REQUIRES failed at \" << io::Basename(file) << \":\" << line\n          << \" : \" << s;\n  SetStatus(s);\n}\n\n// ok from tensorflow/core/platform/status.h:\n  bool ok() const { return (state_ == nullptr); } /* <=== tensorflow.Status.ok:bool()<const> */ \n\n// LOG from tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/platform/logging.h:\n\n\n// CheckNotInComputeAsync from tensorflow/core/framework/op_kernel.cc:\nvoid CheckNotInComputeAsync(OpKernelContext* ctx, /* <=== tensorflow.CheckNotInComputeAsync:void(tensorflow.OpKernelContext*,char*) */ \n                            const char* correct_macro_name) {\n  CHECK_EQ(nullptr, ctx->params_->op_kernel->AsAsync())\n      << \"Use \" << correct_macro_name << \" in AsyncOpKernel implementations.\";\n}\n\n// CtxFailureWithWarning from tensorflow/core/framework/op_kernel.cc:\nvoid OpKernelContext::CtxFailureWithWarning(const char* file, int line, /* <=== tensorflow.OpKernelContext.CtxFailureWithWarning:void(char*,int,tensorflow.Status&) */ \n                                            const Status& s) {\n  LOG(WARNING) << \"OP_REQUIRES failed at \" << io::Basename(file) << \":\" << line\n               << \" : \" << s;\n  SetStatus(s);\n}\n\n// VLOG from tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/platform/logging.h:\n\n\n// OP_REQUIRES from tensorflow/core/kernels/data/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/op_requires.h:\n\n\n// SetStatus from tensorflow/core/framework/op_kernel.cc:\nvoid OpKernelConstruction::SetStatus(const Status& status) { /* <=== tensorflow.OpKernelConstruction.SetStatus:void(tensorflow.Status&) */ \n  status_->Update(status);\n}\n\n// Update from tensorflow/core/platform/status.h:\n  void Update(const Status& new_status); /* <=== tensorflow.Status.Update:void(tensorflow.Status&) */ \n\n// CHECK_EQ from tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/platform/logging.h:\n\n"
  },
  {
    "repository": "weechat",
    "cve_id": "CVE-2020-9759",
    "cwe_list": [
      "CWE-476"
    ],
    "commit_hash": "9904cb6d2eb40f679d8ff6557c22d53a3e3dc75a",
    "short_hash": "9904cb6d",
    "vulnerableMethods_before": [
      {
        "filename": "irc-protocol.c",
        "method_name": "vulnerable_function",
        "raw_code": "IRC_PROTOCOL_CALLBACK(352)\n{\n    char *pos_attr, *pos_hopcount, *pos_realname, *str_host;\n    int arg_start, length;\n    struct t_irc_channel *ptr_channel;\n    struct t_irc_nick *ptr_nick;\n\n    IRC_PROTOCOL_MIN_ARGS(5);\n\n    /* silently ignore malformed 352 message (missing infos) */\n    if (argc < 8)\n        return WEECHAT_RC_OK;\n\n    pos_attr = NULL;\n    pos_hopcount = NULL;\n    pos_realname = NULL;\n\n    if (argc > 8)\n    {\n        arg_start = (strcmp (argv[8], \"*\") == 0) ? 9 : 8;\n        if (argv[arg_start][0] == ':')\n        {\n            pos_attr = NULL;\n            pos_hopcount = (argc > arg_start) ? argv[arg_start] + 1 : NULL;\n            pos_realname = (argc > arg_start + 1) ? argv_eol[arg_start + 1] : NULL;\n        }\n        else\n        {\n            pos_attr = argv[arg_start];\n            pos_hopcount = (argc > arg_start + 1) ? argv[arg_start + 1] + 1 : NULL;\n            pos_realname = (argc > arg_start + 2) ? argv_eol[arg_start + 2] : NULL;\n        }\n    }\n\n    ptr_channel = irc_channel_search (server, argv[3]);\n    ptr_nick = (ptr_channel) ?\n        irc_nick_search (server, ptr_channel, argv[7]) : NULL;\n\n    /* update host in nick */\n    if (ptr_nick)\n    {\n        length = strlen (argv[4]) + 1 + strlen (argv[5]) + 1;\n        str_host = malloc (length);\n        if (str_host)\n        {\n            snprintf (str_host, length, \"%s@%s\", argv[4], argv[5]);\n            irc_nick_set_host (ptr_nick, str_host);\n            free (str_host);\n        }\n    }\n\n    /* update away flag in nick */\n    if (ptr_channel && ptr_nick && pos_attr)\n    {\n        irc_nick_set_away (server, ptr_channel, ptr_nick,\n                           (pos_attr[0] == 'G') ? 1 : 0);\n    }\n\n    /* update realname in nick */\n    if (ptr_channel && ptr_nick && pos_realname)\n    {\n        if (ptr_nick->realname)\n            free (ptr_nick->realname);\n        if (pos_realname &&\n            weechat_hashtable_has_key (server->cap_list, \"extended-join\"))\n        {\n            ptr_nick->realname = strdup (pos_realname);\n        }\n        else\n        {\n            ptr_nick->realname = NULL;\n        }\n    }\n\n    /* display output of who (manual who from user) */\n    if (!ptr_channel || (ptr_channel->checking_whox <= 0))\n    {\n        weechat_printf_date_tags (\n            irc_msgbuffer_get_target_buffer (\n                server, NULL, command, \"who\", NULL),\n            date,\n            irc_protocol_tags (command, \"irc_numeric\", NULL, NULL),\n            \"%s%s[%s%s%s] %s%s %s(%s%s@%s%s)%s %s%s%s%s(%s)\",\n            weechat_prefix (\"network\"),\n            IRC_COLOR_CHAT_DELIMITERS,\n            IRC_COLOR_CHAT_CHANNEL,\n            argv[3],\n            IRC_COLOR_CHAT_DELIMITERS,\n            irc_nick_color_for_msg (server, 1, NULL, argv[7]),\n            argv[7],\n            IRC_COLOR_CHAT_DELIMITERS,\n            IRC_COLOR_CHAT_HOST,\n            argv[4],\n            argv[5],\n            IRC_COLOR_CHAT_DELIMITERS,\n            IRC_COLOR_RESET,\n            (pos_attr) ? pos_attr : \"\",\n            (pos_attr) ? \" \" : \"\",\n            (pos_hopcount) ? pos_hopcount : \"\",\n            (pos_hopcount) ? \" \" : \"\",\n            (pos_realname) ? pos_realname : \"\");\n    }\n\n    return WEECHAT_RC_OK;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "irc-protocol.c",
        "method_name": "fixed_function",
        "raw_code": "IRC_PROTOCOL_CALLBACK(352)\n{\n    char *pos_attr, *pos_hopcount, *pos_realname, *str_host;\n    int arg_start, length;\n    struct t_irc_channel *ptr_channel;\n    struct t_irc_nick *ptr_nick;\n\n    IRC_PROTOCOL_MIN_ARGS(5);\n\n    /* silently ignore malformed 352 message (missing infos) */\n    if (argc < 8)\n        return WEECHAT_RC_OK;\n\n    pos_attr = NULL;\n    pos_hopcount = NULL;\n    pos_realname = NULL;\n\n    if (argc > 8)\n    {\n        arg_start = ((argc > 9) && (strcmp (argv[8], \"*\") == 0)) ? 9 : 8;\n        if (argv[arg_start][0] == ':')\n        {\n            pos_attr = NULL;\n            pos_hopcount = (argc > arg_start) ? argv[arg_start] + 1 : NULL;\n            pos_realname = (argc > arg_start + 1) ? argv_eol[arg_start + 1] : NULL;\n        }\n        else\n        {\n            pos_attr = argv[arg_start];\n            pos_hopcount = (argc > arg_start + 1) ? argv[arg_start + 1] + 1 : NULL;\n            pos_realname = (argc > arg_start + 2) ? argv_eol[arg_start + 2] : NULL;\n        }\n    }\n\n    ptr_channel = irc_channel_search (server, argv[3]);\n    ptr_nick = (ptr_channel) ?\n        irc_nick_search (server, ptr_channel, argv[7]) : NULL;\n\n    /* update host in nick */\n    if (ptr_nick)\n    {\n        length = strlen (argv[4]) + 1 + strlen (argv[5]) + 1;\n        str_host = malloc (length);\n        if (str_host)\n        {\n            snprintf (str_host, length, \"%s@%s\", argv[4], argv[5]);\n            irc_nick_set_host (ptr_nick, str_host);\n            free (str_host);\n        }\n    }\n\n    /* update away flag in nick */\n    if (ptr_channel && ptr_nick && pos_attr)\n    {\n        irc_nick_set_away (server, ptr_channel, ptr_nick,\n                           (pos_attr[0] == 'G') ? 1 : 0);\n    }\n\n    /* update realname in nick */\n    if (ptr_channel && ptr_nick && pos_realname)\n    {\n        if (ptr_nick->realname)\n            free (ptr_nick->realname);\n        if (pos_realname &&\n            weechat_hashtable_has_key (server->cap_list, \"extended-join\"))\n        {\n            ptr_nick->realname = strdup (pos_realname);\n        }\n        else\n        {\n            ptr_nick->realname = NULL;\n        }\n    }\n\n    /* display output of who (manual who from user) */\n    if (!ptr_channel || (ptr_channel->checking_whox <= 0))\n    {\n        weechat_printf_date_tags (\n            irc_msgbuffer_get_target_buffer (\n                server, NULL, command, \"who\", NULL),\n            date,\n            irc_protocol_tags (command, \"irc_numeric\", NULL, NULL),\n            \"%s%s[%s%s%s] %s%s %s(%s%s@%s%s)%s %s%s%s%s(%s)\",\n            weechat_prefix (\"network\"),\n            IRC_COLOR_CHAT_DELIMITERS,\n            IRC_COLOR_CHAT_CHANNEL,\n            argv[3],\n            IRC_COLOR_CHAT_DELIMITERS,\n            irc_nick_color_for_msg (server, 1, NULL, argv[7]),\n            argv[7],\n            IRC_COLOR_CHAT_DELIMITERS,\n            IRC_COLOR_CHAT_HOST,\n            argv[4],\n            argv[5],\n            IRC_COLOR_CHAT_DELIMITERS,\n            IRC_COLOR_RESET,\n            (pos_attr) ? pos_attr : \"\",\n            (pos_attr) ? \" \" : \"\",\n            (pos_hopcount) ? pos_hopcount : \"\",\n            (pos_hopcount) ? \" \" : \"\",\n            (pos_realname) ? pos_realname : \"\");\n    }\n\n    return WEECHAT_RC_OK;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <time.h>\n#include \"irc-server.h\"\n#include \"irc-notify.h\"\n#include \"irc-ignore.h\"\n#include <sys/time.h>\n#include \"irc-color.h\"\n#include \"irc-bar-item.h\"\n#include \"irc-command.h\"\n#include \"irc-config.h\"\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include \"irc-msgbuffer.h\"\n#include \"irc-message.h\"\n#include \"irc-modelist.h\"\n#include \"irc-mode.h\"\n#include <stdlib.h>\n#include \"irc-nick.h\"\n#include \"irc-buffer.h\"\n#include \"irc.h\"\n#include \"irc-protocol.h\"\n#include \"irc-channel.h\"\n#include \"../weechat-plugin.h\"\n#include \"irc-sasl.h\"\n#include \"irc-ctcp.h\"\n"
  },
  {
    "repository": "newsbeuter",
    "cve_id": "CVE-2017-12904",
    "cwe_list": [
      "CWE-787"
    ],
    "commit_hash": "96e9506ae9e252c548665152d1b8968297128307",
    "short_hash": "96e9506a",
    "vulnerableMethods_before": [
      {
        "filename": "controller.cpp",
        "method_name": "vulnerable_function",
        "raw_code": "std::string controller::bookmark(\n\t\tconst std::string& url,\n\t\tconst std::string& title,\n\t\tconst std::string& description,\n\t\tconst std::string& feed_title)\n{\n\tstd::string bookmark_cmd = cfg.get_configvalue(\"bookmark-cmd\");\n\tbool is_interactive = cfg.get_configvalue_as_bool(\"bookmark-interactive\");\n\tif (bookmark_cmd.length() > 0) {\n\t\tstd::string cmdline = strprintf::fmt(\"%s '%s' %s %s %s\",\n\t\t                                       bookmark_cmd,\n\t\t                                       utils::replace_all(url,\"'\", \"%27\"),\n\t\t                                       quote_empty(stfl::quote(title)),\n\t\t                                       quote_empty(stfl::quote(description)),\n\t\t                                       quote_empty(stfl::quote(feed_title)));\n\n\t\tLOG(level::DEBUG, \"controller::bookmark: cmd = %s\", cmdline);\n\n\t\tif (is_interactive) {\n\t\t\tv->push_empty_formaction();\n\t\t\tstfl::reset();\n\t\t\tutils::run_interactively(cmdline, \"controller::bookmark\");\n\t\t\tv->pop_current_formaction();\n\t\t\treturn \"\";\n\t\t} else {\n\t\t\tchar * my_argv[4];\n\t\t\tmy_argv[0] = const_cast<char *>(\"/bin/sh\");\n\t\t\tmy_argv[1] = const_cast<char *>(\"-c\");\n\t\t\tmy_argv[2] = const_cast<char *>(cmdline.c_str());\n\t\t\tmy_argv[3] = nullptr;\n\t\t\treturn utils::run_program(my_argv, \"\");\n\t\t}\n\t} else {\n\t\treturn _(\"bookmarking support is not configured. Please set the configuration variable `bookmark-cmd' accordingly.\");\n\t}\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "controller.cpp",
        "method_name": "fixed_function",
        "raw_code": "std::string controller::bookmark(\n\t\tconst std::string& url,\n\t\tconst std::string& title,\n\t\tconst std::string& description,\n\t\tconst std::string& feed_title)\n{\n\tstd::string bookmark_cmd = cfg.get_configvalue(\"bookmark-cmd\");\n\tbool is_interactive = cfg.get_configvalue_as_bool(\"bookmark-interactive\");\n\tif (bookmark_cmd.length() > 0) {\n\t\tstd::string cmdline = strprintf::fmt(\"%s '%s' '%s' '%s' '%s'\",\n\t\t                                       bookmark_cmd,\n\t\t                                       utils::replace_all(url,\"'\", \"%27\"),\n\t\t                                       utils::replace_all(title,\"'\", \"%27\"),\n\t\t                                       utils::replace_all(description,\"'\", \"%27\"),\n\t\t                                       utils::replace_all(feed_title,\"'\", \"%27\"));\n\n\t\tLOG(level::DEBUG, \"controller::bookmark: cmd = %s\", cmdline);\n\n\t\tif (is_interactive) {\n\t\t\tv->push_empty_formaction();\n\t\t\tstfl::reset();\n\t\t\tutils::run_interactively(cmdline, \"controller::bookmark\");\n\t\t\tv->pop_current_formaction();\n\t\t\treturn \"\";\n\t\t} else {\n\t\t\tchar * my_argv[4];\n\t\t\tmy_argv[0] = const_cast<char *>(\"/bin/sh\");\n\t\t\tmy_argv[1] = const_cast<char *>(\"-c\");\n\t\t\tmy_argv[2] = const_cast<char *>(cmdline.c_str());\n\t\t\tmy_argv[3] = nullptr;\n\t\t\treturn utils::run_program(my_argv, \"\");\n\t\t}\n\t} else {\n\t\treturn _(\"bookmarking support is not configured. Please set the configuration variable `bookmark-cmd' accordingly.\");\n\t}\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <pwd.h>\n#include <remote_api.h>\n#include <newsblur_api.h>\n#include <libgen.h>\n#include <fstream>\n#include <libxml/tree.h>\n#include <controller.h>\n#include <downloadthread.h>\n#include <config.h>\n#include <logger.h>\n#include <exceptions.h>\n#include <curl/curl.h>\n#include <formatstring.h>\n#include <sys/types.h>\n#include <regexmanager.h>\n#include <libxml/xmlversion.h>\n#include <cstring>\n#include <iostream>\n#include <getopt.h>\n#include <utils.h>\n#include <sys/wait.h>\n#include <libxml/xmlsave.h>\n#include <oldreader_api.h>\n#include <exception.h>\n#include <xlicense.h>\n#include <mutex>\n#include <sys/utsname.h>\n#include <ocnews_api.h>\n#include <algorithm>\n#include <langinfo.h>\n#include <sys/time.h>\n#include <ncurses.h>\n#include <cerrno>\n#include <functional>\n#include <colormanager.h>\n#include <rss_parser.h>\n#include <unistd.h>\n#include <libxml/uri.h>\n#include <ttrss_api.h>\n#include <stflpp.h>\n#include <ctime>\n#include <sys/stat.h>\n#include <cassert>\n#include <configparser.h>\n#include <configcontainer.h>\n#include <libxml/parser.h>\n#include <view.h>\n#include <cstdlib>\n#include <signal.h>\n#include <strprintf.h>\n#include <feedhq_api.h>\n\n// Type Definitions:\n// controller:\ncontroller.controller:ANY()\n"
  },
  {
    "repository": "openssl",
    "cve_id": "CVE-2015-1791",
    "cwe_list": [
      "CWE-362"
    ],
    "commit_hash": "939b4960276b040fc0ed52232238fcc9e2e9ec21",
    "short_hash": "939b4960",
    "vulnerableMethods_before": [
      {
        "filename": "None",
        "method_name": "vulnerable_function",
        "raw_code": "int ssl3_get_new_session_ticket(SSL *s)\n{\n    int ok, al, ret = 0, ticklen;\n    long n;\n    const unsigned char *p;\n    unsigned char *d;\n\n    n = s->method->ssl_get_message(s,\n                                   SSL3_ST_CR_SESSION_TICKET_A,\n                                   SSL3_ST_CR_SESSION_TICKET_B,\n                                   SSL3_MT_NEWSESSION_TICKET, 16384, &ok);\n\n    if (!ok)\n        return ((int)n);\n\n    if (n < 6) {\n        /* need at least ticket_lifetime_hint + ticket length */\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n\n    p = d = (unsigned char *)s->init_msg;\n    n2l(p, s->session->tlsext_tick_lifetime_hint);\n    n2s(p, ticklen);\n    /* ticket_lifetime_hint + ticket_length + ticket */\n    if (ticklen + 6 != n) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n    if (s->session->tlsext_tick) {\n        OPENSSL_free(s->session->tlsext_tick);\n        s->session->tlsext_ticklen = 0;\n    }\n    s->session->tlsext_tick = OPENSSL_malloc(ticklen);\n    if (!s->session->tlsext_tick) {\n        SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    memcpy(s->session->tlsext_tick, p, ticklen);\n    s->session->tlsext_ticklen = ticklen;\n    /*\n     * There are two ways to detect a resumed ticket session. One is to set\n     * an appropriate session ID and then the server must return a match in\n     * ServerHello. This allows the normal client session ID matching to work\n     * and we know much earlier that the ticket has been accepted. The\n     * other way is to set zero length session ID when the ticket is\n     * presented and rely on the handshake to determine session resumption.\n     * We choose the former approach because this fits in with assumptions\n     * elsewhere in OpenSSL. The session ID is set to the SHA256 (or SHA1 is\n     * SHA256 is disabled) hash of the ticket.\n     */\n    EVP_Digest(p, ticklen,\n               s->session->session_id, &s->session->session_id_length,\n# ifndef OPENSSL_NO_SHA256\n               EVP_sha256(), NULL);\n# else\n               EVP_sha1(), NULL);\n# endif\n    ret = 1;\n    return (ret);\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n err:\n    s->state = SSL_ST_ERR;\n    return (-1);\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "None",
        "method_name": "fixed_function",
        "raw_code": "int ssl3_get_new_session_ticket(SSL *s)\n{\n    int ok, al, ret = 0, ticklen;\n    long n;\n    const unsigned char *p;\n    unsigned char *d;\n\n    n = s->method->ssl_get_message(s,\n                                   SSL3_ST_CR_SESSION_TICKET_A,\n                                   SSL3_ST_CR_SESSION_TICKET_B,\n                                   SSL3_MT_NEWSESSION_TICKET, 16384, &ok);\n\n    if (!ok)\n        return ((int)n);\n\n    if (n < 6) {\n        /* need at least ticket_lifetime_hint + ticket length */\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n\n    p = d = (unsigned char *)s->init_msg;\n\n    if (s->session->session_id_length > 0) {\n        int i = s->session_ctx->session_cache_mode;\n        SSL_SESSION *new_sess;\n        /*\n         * We reused an existing session, so we need to replace it with a new\n         * one\n         */\n        if (i & SSL_SESS_CACHE_CLIENT) {\n            /*\n             * Remove the old session from the cache\n             */\n            if (i & SSL_SESS_CACHE_NO_INTERNAL_STORE) {\n                if (s->session_ctx->remove_session_cb != NULL)\n                    s->session_ctx->remove_session_cb(s->session_ctx,\n                                                      s->session);\n            } else {\n                /* We carry on if this fails */\n                SSL_CTX_remove_session(s->session_ctx, s->session);\n            }\n        }\n\n        if ((new_sess = ssl_session_dup(s->session, 0)) == 0) {\n            al = SSL_AD_INTERNAL_ERROR;\n            SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, ERR_R_MALLOC_FAILURE);\n            goto f_err;\n        }\n\n        SSL_SESSION_free(s->session);\n        s->session = new_sess;\n    }\n\n    n2l(p, s->session->tlsext_tick_lifetime_hint);\n    n2s(p, ticklen);\n    /* ticket_lifetime_hint + ticket_length + ticket */\n    if (ticklen + 6 != n) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n    if (s->session->tlsext_tick) {\n        OPENSSL_free(s->session->tlsext_tick);\n        s->session->tlsext_ticklen = 0;\n    }\n    s->session->tlsext_tick = OPENSSL_malloc(ticklen);\n    if (!s->session->tlsext_tick) {\n        SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    memcpy(s->session->tlsext_tick, p, ticklen);\n    s->session->tlsext_ticklen = ticklen;\n    /*\n     * There are two ways to detect a resumed ticket session. One is to set\n     * an appropriate session ID and then the server must return a match in\n     * ServerHello. This allows the normal client session ID matching to work\n     * and we know much earlier that the ticket has been accepted. The\n     * other way is to set zero length session ID when the ticket is\n     * presented and rely on the handshake to determine session resumption.\n     * We choose the former approach because this fits in with assumptions\n     * elsewhere in OpenSSL. The session ID is set to the SHA256 (or SHA1 is\n     * SHA256 is disabled) hash of the ticket.\n     */\n    EVP_Digest(p, ticklen,\n               s->session->session_id, &s->session->session_id_length,\n# ifndef OPENSSL_NO_SHA256\n               EVP_sha256(), NULL);\n# else\n               EVP_sha1(), NULL);\n# endif\n    ret = 1;\n    return (ret);\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n err:\n    s->state = SSL_ST_ERR;\n    return (-1);\n}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "pjproject",
    "cve_id": "CVE-2022-24786",
    "cwe_list": [
      "CWE-200"
    ],
    "commit_hash": "11559e49e65bdf00922ad5ae28913ec6a198d508",
    "short_hash": "11559e49",
    "vulnerableMethods_before": [
      {
        "filename": "rtcp_fb.c",
        "method_name": "vulnerable_function",
        "raw_code": "PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_rpsi(\n\t\t\t\t\tconst void *buf,\n\t\t\t\t\tpj_size_t length,\n\t\t\t\t\tpjmedia_rtcp_fb_rpsi *rpsi)\n{\n    pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;\n    pj_uint8_t *p;\n    pj_uint8_t padlen;\n    pj_size_t rpsi_len;\n\n    PJ_ASSERT_RETURN(buf && rpsi, PJ_EINVAL);\n    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_common), PJ_ETOOSMALL);\n\n    /* RPSI uses pt==RTCP_PSFB and FMT==3 */\n    if (hdr->pt != RTCP_PSFB || hdr->count != 3)\n\treturn PJ_ENOTFOUND;\n\n    rpsi_len = (pj_ntohs((pj_uint16_t)hdr->length)-2) * 4;\n    if (length < rpsi_len + 12)\n\treturn PJ_ETOOSMALL;\n\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    padlen = *p++;\n    rpsi->pt = (*p++ & 0x7F);\n    rpsi->rpsi_bit_len = rpsi_len*8 - 16 - padlen;\n    pj_strset(&rpsi->rpsi, (char*)p, (rpsi->rpsi_bit_len + 7)/8);\n\n    return PJ_SUCCESS;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "rtcp_fb.c",
        "method_name": "fixed_function",
        "raw_code": "PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_rpsi(\n\t\t\t\t\tconst void *buf,\n\t\t\t\t\tpj_size_t length,\n\t\t\t\t\tpjmedia_rtcp_fb_rpsi *rpsi)\n{\n    pjmedia_rtcp_fb_common *hdr = (pjmedia_rtcp_fb_common*) buf;\n    pj_uint8_t *p;\n    pj_uint8_t padlen;\n    pj_size_t rpsi_len;\n\n    PJ_ASSERT_RETURN(buf && rpsi, PJ_EINVAL);\n    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_fb_common), PJ_ETOOSMALL);\n\n    /* RPSI uses pt==RTCP_PSFB and FMT==3 */\n    if (hdr->rtcp_common.pt != RTCP_PSFB || hdr->rtcp_common.count != 3)\n\treturn PJ_ENOTFOUND;\n\n    if (hdr->rtcp_common.length < 3) {    \n        PJ_PERROR(3, (THIS_FILE, PJ_ETOOSMALL,\n                      \"Failed parsing FB RPSI, invalid header length\"));\n\treturn PJ_ETOOSMALL;\n    }\n\n    rpsi_len = (pj_ntohs((pj_uint16_t)hdr->rtcp_common.length)-2) * 4;\n    if (length < rpsi_len + 12)\n\treturn PJ_ETOOSMALL;\n\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    padlen = *p++;\n\n    if (padlen >= 32) {\n        PJ_PERROR(3, (THIS_FILE, PJ_ETOOBIG,\n                      \"Failed parsing FB RPSI, invalid RPSI padding len\"));\n\treturn PJ_ETOOBIG;\n    }\n\n    if ((rpsi_len * 8) < (unsigned)(16 + padlen)) {\n        PJ_PERROR(3, (THIS_FILE, PJ_ETOOSMALL,\n                      \"Failed parsing FB RPSI, invalid RPSI bit len\"));\n\treturn PJ_ETOOSMALL;\n    }\n\n    rpsi->pt = (*p++ & 0x7F);\n    rpsi->rpsi_bit_len = rpsi_len*8 - 16 - padlen;\n    pj_strset(&rpsi->rpsi, (char*)p, (rpsi->rpsi_bit_len + 7)/8);\n\n    return PJ_SUCCESS;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <pj/assert.h>\n#include <pjmedia/codec.h>\n#include <pjmedia/vid_codec.h>\n#include <pjmedia/endpoint.h>\n#include <pj/sock.h>\n#include <pj/os.h>\n#include <pjmedia/errno.h>\n#include <pj/log.h>\n#include <pj/string.h>\n#include <pjmedia/rtcp_fb.h>\n"
  },
  {
    "repository": "tensorflow",
    "cve_id": "CVE-2022-23593",
    "cwe_list": [
      "CWE-754"
    ],
    "commit_hash": "35f0fabb4c178253a964d7aabdbb15c6a398b69a",
    "short_hash": "35f0fabb",
    "vulnerableMethods_before": [
      {
        "filename": "tf_cpurt_symbolic_shape_optimization.cc",
        "method_name": "vulnerable_function",
        "raw_code": "llvm::Optional<Value> simplifyBroadcast(ShapeComponentAnalysis& analysis,\n                                        ValueRange shapes, Location loc,\n                                        OpBuilder* builder) {\n  // First find the input shape with the largest rank.\n  SmallVector<ArrayRef<ShapeComponentAnalysis::SymbolicExpr>> shapes_found;\n  size_t maxRank = 0;\n  for (const auto &shape : llvm::enumerate(shapes)) {\n    auto found_shape = analysis.GetValueInfo(shape.value());\n    if (!found_shape) return {};\n    shapes_found.push_back(*found_shape);\n    maxRank = std::max(maxRank, found_shape->size());\n  }\n\n  SmallVector<const ShapeComponentAnalysis::SymbolicExpr*> joined_dimensions(\n      maxRank);\n  SmallVector<std::pair<Value, int64_t>> shape_and_rank_for_dim(maxRank);\n  for (const auto &shape : llvm::enumerate(shapes_found)) {\n    for (const auto &dim : llvm::enumerate(llvm::reverse(shape.value()))) {\n      // 1 dimensions don't contribute to the final result.\n      if (dim.value().isConstant(1)) continue;\n      // If it's not a 1 dimension it will be present in the result. Remember\n      // where it came from.\n      auto index = maxRank - dim.index() - 1;\n      if (!joined_dimensions[index]) {\n        joined_dimensions[index] = &dim.value();\n        shape_and_rank_for_dim[index] =\n            std::make_pair(shapes[shape.index()], shape.value().size());\n        continue;\n      }\n      // Bail if the dimensions are neither equal nor 1.\n      if (*joined_dimensions[index] != dim.value()) return {};\n    }\n  }\n  // If the output is the same as one of the inputs just return that.\n  if (llvm::is_splat(shape_and_rank_for_dim) &&\n      shape_and_rank_for_dim[0].first) {\n    return shape_and_rank_for_dim[0].first;\n  }\n  // Otherwise rematerialize the shape from the pieces we have.\n  SmallVector<Value> elements;\n  for (int i = 0; i != maxRank; ++i) {\n    // 1 dimensions are filtered above, recreate the constant.\n    if (!shape_and_rank_for_dim[i].first) {\n      auto one = builder->getIntegerAttr(\n          shapes[0].getType().cast<RankedTensorType>().getElementType(), 1);\n      elements.push_back(builder->create<ConstantOp>(loc, one));\n      continue;\n    }\n    // Extract from one of the shapes, accounting for the reverse indexing\n    // performed by broadcast.\n    Value index = builder->create<ConstantIndexOp>(\n        loc, i - maxRank + shape_and_rank_for_dim[i].second);\n    elements.push_back(builder->create<tensor::ExtractOp>(\n        loc, shape_and_rank_for_dim[i].first, index));\n  }\n  return Value(builder->create<tensor::FromElementsOp>(loc, elements));\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "tf_cpurt_symbolic_shape_optimization.cc",
        "method_name": "fixed_function",
        "raw_code": "llvm::Optional<Value> simplifyBroadcast(ShapeComponentAnalysis& analysis,\n                                        ValueRange shapes, Location loc,\n                                        OpBuilder* builder) {\n  // First find the input shape with the largest rank.\n  SmallVector<ArrayRef<ShapeComponentAnalysis::SymbolicExpr>> shapes_found;\n  size_t maxRank = 0;\n  for (const auto &shape : llvm::enumerate(shapes)) {\n    auto found_shape = analysis.GetValueInfo(shape.value());\n    if (!found_shape) return {};\n    shapes_found.push_back(*found_shape);\n    maxRank = std::max(maxRank, found_shape->size());\n  }\n  if (maxRank == 0) {\n    return Value(builder->create<tensor::FromElementsOp>(\n        loc, shapes[0].getType(), SmallVector<Value>()));\n  }\n\n  SmallVector<const ShapeComponentAnalysis::SymbolicExpr*> joined_dimensions(\n      maxRank);\n  SmallVector<std::pair<Value, int64_t>> shape_and_rank_for_dim(maxRank);\n  for (const auto &shape : llvm::enumerate(shapes_found)) {\n    for (const auto &dim : llvm::enumerate(llvm::reverse(shape.value()))) {\n      // 1 dimensions don't contribute to the final result.\n      if (dim.value().isConstant(1)) continue;\n      // If it's not a 1 dimension it will be present in the result. Remember\n      // where it came from.\n      auto index = maxRank - dim.index() - 1;\n      if (!joined_dimensions[index]) {\n        joined_dimensions[index] = &dim.value();\n        shape_and_rank_for_dim[index] =\n            std::make_pair(shapes[shape.index()], shape.value().size());\n        continue;\n      }\n      // Bail if the dimensions are neither equal nor 1.\n      if (*joined_dimensions[index] != dim.value()) return {};\n    }\n  }\n  // If the output is the same as one of the inputs just return that.\n  if (llvm::is_splat(shape_and_rank_for_dim) &&\n      shape_and_rank_for_dim[0].first) {\n    return shape_and_rank_for_dim[0].first;\n  }\n  // Otherwise rematerialize the shape from the pieces we have.\n  SmallVector<Value> elements;\n  for (int i = 0; i != maxRank; ++i) {\n    // 1 dimensions are filtered above, recreate the constant.\n    if (!shape_and_rank_for_dim[i].first) {\n      auto one = builder->getIntegerAttr(\n          shapes[0].getType().cast<RankedTensorType>().getElementType(), 1);\n      elements.push_back(builder->create<ConstantOp>(loc, one));\n      continue;\n    }\n    // Extract from one of the shapes, accounting for the reverse indexing\n    // performed by broadcast.\n    Value index = builder->create<ConstantIndexOp>(\n        loc, i - maxRank + shape_and_rank_for_dim[i].second);\n    elements.push_back(builder->create<tensor::ExtractOp>(\n        loc, shape_and_rank_for_dim[i].first, index));\n  }\n  return Value(builder->create<tensor::FromElementsOp>(loc, elements));\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"llvm/ADT/iterator_range.h\"\n#include \"tensorflow/compiler/mlir/tfrt/jit/transforms/tf_cpurt_passes.h\"\n#include \"tensorflow/compiler/mlir/hlo/include/mlir-hlo/Dialect/mhlo/IR/hlo_ops.h\"\n#include \"mlir/IR/TypeRange.h\"\n#include \"tensorflow/compiler/mlir/tfrt/jit/transforms/tf_cpurt_passes.h.inc\"\n#include \"mlir/IR/BuiltinTypes.h\"\n#include \"mlir/Dialect/StandardOps/IR/Ops.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"mlir/Transforms/GreedyPatternRewriteDriver.h\"\n#include \"llvm/ADT/StringExtras.h\"\n#include \"mlir/IR/MLIRContext.h\"\n#include \"mlir/IR/BuiltinOps.h\"\n#include \"llvm/Support/Alignment.h\"\n#include \"llvm/Support/ErrorOr.h\"\n#include \"mlir/IR/Operation.h\"\n#include <sys/types.h>\n#include \"llvm/ADT/STLExtras.h\"\n#include \"tensorflow/compiler/mlir/hlo/include/mlir-hlo/Analysis/shape_component_analysis.h\"\n#include \"mlir/IR/OperationSupport.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"mlir/IR/AffineMap.h\"\n#include <string>\n\n// Type Definitions:\n// iterator:\nusing iterator =\n      ShapeTreeIterator<std::vector<Node>, typename std::vector<Node>::iterator,\n                        std::pair<ShapeIndex, T>>;\n"
  },
  {
    "repository": "mongo",
    "cve_id": "CVE-2021-32037",
    "cwe_list": [
      "CWE-617"
    ],
    "commit_hash": "a5e2f9b0a236462a6d1ca129583c617f111367b4",
    "short_hash": "a5e2f9b0",
    "vulnerableMethods_before": [
      {
        "filename": "None",
        "method_name": "vulnerable_function",
        "raw_code": "createRandomCursorExecutor(const CollectionPtr& coll,\n                           const boost::intrusive_ptr<ExpressionContext>& expCtx,\n                           long long sampleSize,\n                           long long numRecords,\n                           boost::optional<BucketUnpacker> bucketUnpacker) {\n    OperationContext* opCtx = expCtx->opCtx;\n\n    // Verify that we are already under a collection lock. We avoid taking locks ourselves in this\n    // function because double-locking forces any PlanExecutor we create to adopt a NO_YIELD policy.\n    invariant(opCtx->lockState()->isCollectionLockedForMode(coll->ns(), MODE_IS));\n\n    static const double kMaxSampleRatioForRandCursor = 0.05;\n    if (!expCtx->ns.isTimeseriesBucketsCollection()) {\n        if (sampleSize > numRecords * kMaxSampleRatioForRandCursor || numRecords <= 100) {\n            return std::pair{nullptr, false};\n        }\n    } else {\n        // Suppose that a time-series bucket collection is observed to contain 200 buckets, and the\n        // 'gTimeseriesBucketMaxCount' parameter is set to 1000. If all buckets are full, then the\n        // maximum possible measurment count would be 200 * 1000 = 200,000. While the\n        // 'SampleFromTimeseriesBucket' plan is more efficient when the sample size is small\n        // relative to the total number of measurements in the time-series collection, for larger\n        // sample sizes the top-k sort based sample is faster. Experiments have approximated that\n        // the tipping point is roughly when the requested sample size is greater than 1% of the\n        // maximum possible number of measurements in the collection (i.e. numBuckets *\n        // maxMeasurementsPerBucket).\n        static const double kCoefficient = 0.01;\n        if (sampleSize > kCoefficient * numRecords * gTimeseriesBucketMaxCount) {\n            return std::pair{nullptr, false};\n        }\n    }\n\n    // Attempt to get a random cursor from the RecordStore.\n    auto rsRandCursor = coll->getRecordStore()->getRandomCursor(opCtx);\n    if (!rsRandCursor) {\n        // The storage engine has no random cursor support.\n        return std::pair{nullptr, false};\n    }\n\n    // Build a MultiIteratorStage and pass it the random-sampling RecordCursor.\n    auto ws = std::make_unique<WorkingSet>();\n    std::unique_ptr<PlanStage> root =\n        std::make_unique<MultiIteratorStage>(expCtx.get(), ws.get(), coll);\n    static_cast<MultiIteratorStage*>(root.get())->addIterator(std::move(rsRandCursor));\n\n    // If the incoming operation is sharded, use the CSS to infer the filtering metadata for the\n    // collection, otherwise treat it as unsharded\n    auto collectionFilter =\n        CollectionShardingState::get(opCtx, coll->ns())\n            ->getOwnershipFilter(\n                opCtx, CollectionShardingState::OrphanCleanupPolicy::kDisallowOrphanCleanup);\n\n    TrialStage* trialStage = nullptr;\n\n    // Because 'numRecords' includes orphan documents, our initial decision to optimize the $sample\n    // cursor may have been mistaken. For sharded collections, build a TRIAL plan that will switch\n    // to a collection scan if the ratio of orphaned to owned documents encountered over the first\n    // 100 works() is such that we would have chosen not to optimize.\n    static const size_t kMaxPresampleSize = 100;\n    if (collectionFilter.isSharded() && !expCtx->ns.isTimeseriesBucketsCollection()) {\n        // The ratio of owned to orphaned documents must be at least equal to the ratio between the\n        // requested sampleSize and the maximum permitted sampleSize for the original constraints to\n        // be satisfied. For instance, if there are 200 documents and the sampleSize is 5, then at\n        // least (5 / (200*0.05)) = (5/10) = 50% of those documents must be owned. If less than 5%\n        // of the documents in the collection are owned, we default to the backup plan.\n        const auto minAdvancedToWorkRatio = std::max(\n            sampleSize / (numRecords * kMaxSampleRatioForRandCursor), kMaxSampleRatioForRandCursor);\n        // The trial plan is SHARDING_FILTER-MULTI_ITERATOR.\n        auto randomCursorPlan = std::make_unique<ShardFilterStage>(\n            expCtx.get(), collectionFilter, ws.get(), std::move(root));\n        // The backup plan is SHARDING_FILTER-COLLSCAN.\n        std::unique_ptr<PlanStage> collScanPlan = std::make_unique<CollectionScan>(\n            expCtx.get(), coll, CollectionScanParams{}, ws.get(), nullptr);\n        collScanPlan = std::make_unique<ShardFilterStage>(\n            expCtx.get(), collectionFilter, ws.get(), std::move(collScanPlan));\n        // Place a TRIAL stage at the root of the plan tree, and pass it the trial and backup plans.\n        root = std::make_unique<TrialStage>(expCtx.get(),\n                                            ws.get(),\n                                            std::move(randomCursorPlan),\n                                            std::move(collScanPlan),\n                                            kMaxPresampleSize,\n                                            minAdvancedToWorkRatio);\n        trialStage = static_cast<TrialStage*>(root.get());\n    } else if (expCtx->ns.isTimeseriesBucketsCollection()) {\n        // Use a 'TrialStage' to run a trial between 'SampleFromTimeseriesBucket' and\n        // 'UnpackTimeseriesBucket' with $sample left in the pipeline in-place. If the buckets are\n        // not sufficiently full, or the 'SampleFromTimeseriesBucket' plan draws too many\n        // duplicates, then we will fall back to the 'TrialStage' backup plan. This backup plan uses\n        // the top-k sort sampling approach.\n        //\n        // Suppose the 'gTimeseriesBucketMaxCount' is 1000, but each bucket only contains 500\n        // documents on average. The observed trial advanced/work ratio approximates the average\n        // bucket fullness, noted here as \"abf\". In this example, abf = 500 / 1000 = 0.5.\n        // Experiments have shown that the optimized 'SampleFromTimeseriesBucket' algorithm performs\n        // better than backup plan when\n        //\n        //     sampleSize < 0.02 * abf * numRecords * gTimeseriesBucketMaxCount\n        //\n        //  This inequality can be rewritten as\n        //\n        //     abf > sampleSize / (0.02 * numRecords * gTimeseriesBucketMaxCount)\n        //\n        // Therefore, if the advanced/work ratio exceeds this threshold, we will use the\n        // 'SampleFromTimeseriesBucket' plan. Note that as the sample size requested by the user\n        // becomes larger with respect to the number of buckets, we require a higher advanced/work\n        // ratio in order to justify using 'SampleFromTimeseriesBucket'.\n        //\n        // Additionally, we require the 'TrialStage' to approximate the abf as at least 0.25. When\n        // buckets are mostly empty, the 'SampleFromTimeseriesBucket' will be inefficient due to a\n        // lot of sampling \"misses\".\n        static const auto kCoefficient = 0.02;\n        static const auto kMinBucketFullness = 0.25;\n        const auto minAdvancedToWorkRatio = std::max(\n            std::min(sampleSize / (kCoefficient * numRecords * gTimeseriesBucketMaxCount), 1.0),\n            kMinBucketFullness);\n\n        auto arhashPlan = std::make_unique<SampleFromTimeseriesBucket>(\n            expCtx.get(),\n            ws.get(),\n            std::move(root),\n            *bucketUnpacker,\n            // By using a quantity slightly higher than 'kMaxPresampleSize', we ensure that the\n            // 'SampleFromTimeseriesBucket' stage won't fail due to too many consecutive sampling\n            // attempts during the 'TrialStage's trial period.\n            kMaxPresampleSize + 5,\n            sampleSize,\n            gTimeseriesBucketMaxCount);\n\n        std::unique_ptr<PlanStage> collScanPlan = std::make_unique<CollectionScan>(\n            expCtx.get(), coll, CollectionScanParams{}, ws.get(), nullptr);\n\n        auto topkSortPlan = std::make_unique<UnpackTimeseriesBucket>(\n            expCtx.get(), ws.get(), std::move(collScanPlan), *bucketUnpacker);\n\n        root = std::make_unique<TrialStage>(expCtx.get(),\n                                            ws.get(),\n                                            std::move(arhashPlan),\n                                            std::move(topkSortPlan),\n                                            kMaxPresampleSize,\n                                            minAdvancedToWorkRatio);\n        trialStage = static_cast<TrialStage*>(root.get());\n    }\n\n    auto execStatus = plan_executor_factory::make(expCtx,\n                                                  std::move(ws),\n                                                  std::move(root),\n                                                  &coll,\n                                                  opCtx->inMultiDocumentTransaction()\n                                                      ? PlanYieldPolicy::YieldPolicy::INTERRUPT_ONLY\n                                                      : PlanYieldPolicy::YieldPolicy::YIELD_AUTO,\n                                                  QueryPlannerParams::RETURN_OWNED_DATA);\n    if (!execStatus.isOK()) {\n        return execStatus.getStatus();\n    }\n\n    // For sharded collections, the root of the plan tree is a TrialStage that may have chosen\n    // either a random-sampling cursor trial plan or a COLLSCAN backup plan. We can only optimize\n    // the $sample aggregation stage if the trial plan was chosen.\n    return std::pair{std::move(execStatus.getValue()),\n                     !trialStage || !trialStage->pickedBackupPlan()};\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "None",
        "method_name": "fixed_function",
        "raw_code": "createRandomCursorExecutor(const CollectionPtr& coll,\n                           const boost::intrusive_ptr<ExpressionContext>& expCtx,\n                           long long sampleSize,\n                           long long numRecords,\n                           boost::optional<BucketUnpacker> bucketUnpacker) {\n    OperationContext* opCtx = expCtx->opCtx;\n\n    // Verify that we are already under a collection lock. We avoid taking locks ourselves in this\n    // function because double-locking forces any PlanExecutor we create to adopt a NO_YIELD policy.\n    invariant(opCtx->lockState()->isCollectionLockedForMode(coll->ns(), MODE_IS));\n\n    static const double kMaxSampleRatioForRandCursor = 0.05;\n    if (!expCtx->ns.isTimeseriesBucketsCollection()) {\n        if (sampleSize > numRecords * kMaxSampleRatioForRandCursor || numRecords <= 100) {\n            return std::pair{nullptr, false};\n        }\n    } else {\n        // Suppose that a time-series bucket collection is observed to contain 200 buckets, and the\n        // 'gTimeseriesBucketMaxCount' parameter is set to 1000. If all buckets are full, then the\n        // maximum possible measurment count would be 200 * 1000 = 200,000. While the\n        // 'SampleFromTimeseriesBucket' plan is more efficient when the sample size is small\n        // relative to the total number of measurements in the time-series collection, for larger\n        // sample sizes the top-k sort based sample is faster. Experiments have approximated that\n        // the tipping point is roughly when the requested sample size is greater than 1% of the\n        // maximum possible number of measurements in the collection (i.e. numBuckets *\n        // maxMeasurementsPerBucket).\n        static const double kCoefficient = 0.01;\n        if (sampleSize > kCoefficient * numRecords * gTimeseriesBucketMaxCount) {\n            return std::pair{nullptr, false};\n        }\n    }\n\n    // Attempt to get a random cursor from the RecordStore.\n    auto rsRandCursor = coll->getRecordStore()->getRandomCursor(opCtx);\n    if (!rsRandCursor) {\n        // The storage engine has no random cursor support.\n        return std::pair{nullptr, false};\n    }\n\n    // Build a MultiIteratorStage and pass it the random-sampling RecordCursor.\n    auto ws = std::make_unique<WorkingSet>();\n    std::unique_ptr<PlanStage> root =\n        std::make_unique<MultiIteratorStage>(expCtx.get(), ws.get(), coll);\n    static_cast<MultiIteratorStage*>(root.get())->addIterator(std::move(rsRandCursor));\n\n    TrialStage* trialStage = nullptr;\n\n    // Because 'numRecords' includes orphan documents, our initial decision to optimize the $sample\n    // cursor may have been mistaken. For sharded collections, build a TRIAL plan that will switch\n    // to a collection scan if the ratio of orphaned to owned documents encountered over the first\n    // 100 works() is such that we would have chosen not to optimize.\n    static const size_t kMaxPresampleSize = 100;\n    if (auto css = CollectionShardingState::get(opCtx, coll->ns());\n        css->getCollectionDescription(opCtx).isSharded() &&\n        !expCtx->ns.isTimeseriesBucketsCollection()) {\n        // The ratio of owned to orphaned documents must be at least equal to the ratio between the\n        // requested sampleSize and the maximum permitted sampleSize for the original constraints to\n        // be satisfied. For instance, if there are 200 documents and the sampleSize is 5, then at\n        // least (5 / (200*0.05)) = (5/10) = 50% of those documents must be owned. If less than 5%\n        // of the documents in the collection are owned, we default to the backup plan.\n        const auto minAdvancedToWorkRatio = std::max(\n            sampleSize / (numRecords * kMaxSampleRatioForRandCursor), kMaxSampleRatioForRandCursor);\n        // Since the incoming operation is sharded, use the CSS to infer the filtering metadata for\n        // the collection. We get the shard ownership filter after checking to see if the collection\n        // is sharded to avoid an invariant from being fired in this call.\n        auto collectionFilter = css->getOwnershipFilter(\n            opCtx, CollectionShardingState::OrphanCleanupPolicy::kDisallowOrphanCleanup);\n        // The trial plan is SHARDING_FILTER-MULTI_ITERATOR.\n        auto randomCursorPlan = std::make_unique<ShardFilterStage>(\n            expCtx.get(), collectionFilter, ws.get(), std::move(root));\n        // The backup plan is SHARDING_FILTER-COLLSCAN.\n        std::unique_ptr<PlanStage> collScanPlan = std::make_unique<CollectionScan>(\n            expCtx.get(), coll, CollectionScanParams{}, ws.get(), nullptr);\n        collScanPlan = std::make_unique<ShardFilterStage>(\n            expCtx.get(), collectionFilter, ws.get(), std::move(collScanPlan));\n        // Place a TRIAL stage at the root of the plan tree, and pass it the trial and backup plans.\n        root = std::make_unique<TrialStage>(expCtx.get(),\n                                            ws.get(),\n                                            std::move(randomCursorPlan),\n                                            std::move(collScanPlan),\n                                            kMaxPresampleSize,\n                                            minAdvancedToWorkRatio);\n        trialStage = static_cast<TrialStage*>(root.get());\n    } else if (expCtx->ns.isTimeseriesBucketsCollection()) {\n        // Use a 'TrialStage' to run a trial between 'SampleFromTimeseriesBucket' and\n        // 'UnpackTimeseriesBucket' with $sample left in the pipeline in-place. If the buckets are\n        // not sufficiently full, or the 'SampleFromTimeseriesBucket' plan draws too many\n        // duplicates, then we will fall back to the 'TrialStage' backup plan. This backup plan uses\n        // the top-k sort sampling approach.\n        //\n        // Suppose the 'gTimeseriesBucketMaxCount' is 1000, but each bucket only contains 500\n        // documents on average. The observed trial advanced/work ratio approximates the average\n        // bucket fullness, noted here as \"abf\". In this example, abf = 500 / 1000 = 0.5.\n        // Experiments have shown that the optimized 'SampleFromTimeseriesBucket' algorithm performs\n        // better than backup plan when\n        //\n        //     sampleSize < 0.02 * abf * numRecords * gTimeseriesBucketMaxCount\n        //\n        //  This inequality can be rewritten as\n        //\n        //     abf > sampleSize / (0.02 * numRecords * gTimeseriesBucketMaxCount)\n        //\n        // Therefore, if the advanced/work ratio exceeds this threshold, we will use the\n        // 'SampleFromTimeseriesBucket' plan. Note that as the sample size requested by the user\n        // becomes larger with respect to the number of buckets, we require a higher advanced/work\n        // ratio in order to justify using 'SampleFromTimeseriesBucket'.\n        //\n        // Additionally, we require the 'TrialStage' to approximate the abf as at least 0.25. When\n        // buckets are mostly empty, the 'SampleFromTimeseriesBucket' will be inefficient due to a\n        // lot of sampling \"misses\".\n        static const auto kCoefficient = 0.02;\n        static const auto kMinBucketFullness = 0.25;\n        const auto minAdvancedToWorkRatio = std::max(\n            std::min(sampleSize / (kCoefficient * numRecords * gTimeseriesBucketMaxCount), 1.0),\n            kMinBucketFullness);\n\n        auto arhashPlan = std::make_unique<SampleFromTimeseriesBucket>(\n            expCtx.get(),\n            ws.get(),\n            std::move(root),\n            *bucketUnpacker,\n            // By using a quantity slightly higher than 'kMaxPresampleSize', we ensure that the\n            // 'SampleFromTimeseriesBucket' stage won't fail due to too many consecutive sampling\n            // attempts during the 'TrialStage's trial period.\n            kMaxPresampleSize + 5,\n            sampleSize,\n            gTimeseriesBucketMaxCount);\n\n        std::unique_ptr<PlanStage> collScanPlan = std::make_unique<CollectionScan>(\n            expCtx.get(), coll, CollectionScanParams{}, ws.get(), nullptr);\n\n        auto topkSortPlan = std::make_unique<UnpackTimeseriesBucket>(\n            expCtx.get(), ws.get(), std::move(collScanPlan), *bucketUnpacker);\n\n        root = std::make_unique<TrialStage>(expCtx.get(),\n                                            ws.get(),\n                                            std::move(arhashPlan),\n                                            std::move(topkSortPlan),\n                                            kMaxPresampleSize,\n                                            minAdvancedToWorkRatio);\n        trialStage = static_cast<TrialStage*>(root.get());\n    }\n\n    auto execStatus = plan_executor_factory::make(expCtx,\n                                                  std::move(ws),\n                                                  std::move(root),\n                                                  &coll,\n                                                  opCtx->inMultiDocumentTransaction()\n                                                      ? PlanYieldPolicy::YieldPolicy::INTERRUPT_ONLY\n                                                      : PlanYieldPolicy::YieldPolicy::YIELD_AUTO,\n                                                  QueryPlannerParams::RETURN_OWNED_DATA);\n    if (!execStatus.isOK()) {\n        return execStatus.getStatus();\n    }\n\n    // For sharded collections, the root of the plan tree is a TrialStage that may have chosen\n    // either a random-sampling cursor trial plan or a COLLSCAN backup plan. We can only optimize\n    // the $sample aggregation stage if the trial plan was chosen.\n    return std::pair{std::move(execStatus.getValue()),\n                     !trialStage || !trialStage->pickedBackupPlan()};\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"mongo/db/ops/write_ops_gen.h\"\n#include \"mongo/db/pipeline/document_source.h\"\n#include \"mongo/db/index/index_access_method.h\"\n#include \"mongo/db/pipeline/document_source_internal_unpack_bucket.h\"\n#include \"mongo/db/exec/multi_iterator.h\"\n#include \"mongo/db/pipeline/document_source_change_stream.h\"\n#include \"mongo/db/pipeline/document_source_cursor.h\"\n#include \"mongo/db/pipeline/document_source_sample.h\"\n#include \"mongo/db/service_context.h\"\n#include \"mongo/db/query/projection_parser.h\"\n#include \"mongo/db/query/sort_pattern.h\"\n#include \"mongo/db/pipeline/pipeline_d.h\"\n#include \"mongo/rpc/metadata/client_metadata.h\"\n#include \"mongo/db/pipeline/document_source_sort.h\"\n#include \"mongo/s/query/document_source_merge_cursors.h\"\n#include \"mongo/db/concurrency/d_concurrency.h\"\n#include \"mongo/db/ops/write_ops_exec.h\"\n#include \"mongo/db/pipeline/document_source_geo_near.h\"\n#include \"mongo/db/storage/record_store.h\"\n#include \"mongo/db/pipeline/skip_and_limit.h\"\n#include \"mongo/db/concurrency/write_conflict_exception.h\"\n#include \"mongo/db/namespace_string.h\"\n#include \"mongo/util/time_support.h\"\n#include \"mongo/db/query/get_executor.h\"\n#include \"mongo/bson/simple_bsonobj_comparator.h\"\n#include \"mongo/db/query/plan_summary_stats.h\"\n#include \"mongo/db/pipeline/document_source_match.h\"\n#include \"mongo/db/query/query_planner.h\"\n#include \"mongo/db/pipeline/document_source_sample_from_random_cursor.h\"\n#include \"mongo/db/catalog/collection.h\"\n#include \"mongo/db/exec/working_set.h\"\n#include \"mongo/db/matcher/extensions_callback_real.h\"\n#include \"mongo/db/pipeline/document_source_geo_near_cursor.h\"\n#include \"mongo/db/db_raii.h\"\n#include \"mongo/db/catalog/database.h\"\n#include \"mongo/db/exec/queued_data_stage.h\"\n#include \"mongo/db/exec/fetch.h\"\n#include \"mongo/db/exec/shard_filter.h\"\n#include \"mongo/db/exec/trial_stage.h\"\n#include \"mongo/db/pipeline/document_source_group.h\"\n#include \"mongo/db/catalog/index_catalog.h\"\n#include \"mongo/base/exact_cast.h\"\n#include \"mongo/platform/basic.h\"\n#include \"mongo/db/query/collation/collator_interface.h\"\n#include \"mongo/db/exec/collection_scan.h\"\n#include \"mongo/db/pipeline/pipeline.h\"\n#include \"mongo/db/exec/sample_from_timeseries_bucket.h\"\n#include \"mongo/db/query/plan_executor_factory.h\"\n#include \"mongo/db/stats/top.h\"\n#include \"mongo/db/timeseries/timeseries_gen.h\"\n#include \"mongo/db/s/collection_sharding_state.h\"\n#include \"mongo/db/pipeline/document_source_single_document_transformation.h\"\n#include \"mongo/db/exec/unpack_timeseries_bucket.h\"\n#include \"mongo/db/storage/sorted_data_interface.h\"\n\n// Type Definitions:\n// OperationContext:\nclass OperationContext\n"
  },
  {
    "repository": "curl",
    "cve_id": "CVE-2018-16842",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "70b1900dd13d16f2e83f571407a614541d5ac9ba",
    "short_hash": "70b1900d",
    "vulnerableMethods_before": [
      {
        "filename": "main.c",
        "method_name": "vulnerable_function",
        "raw_code": "static void warnf(struct Configurable *config, const char *fmt, ...)\n{\n  if(!(config->conf & CONF_MUTE)) {\n    va_list ap;\n    int len;\n    char *ptr;\n    char print_buffer[256];\n\n    va_start(ap, fmt);\n    va_start(ap, fmt);\n    len = vsnprintf(print_buffer, sizeof(print_buffer), fmt, ap);\n    va_end(ap);\n\n    ptr = print_buffer;\n    while(len > 0) {\n      fputs(WARN_PREFIX, config->errors);\n\n      if(len > (int)WARN_TEXTWIDTH) {\n        int cut = WARN_TEXTWIDTH-1;\n\n        while(!ISSPACE(ptr[cut]) && cut) {\n          cut--;\n        }\n\n        fwrite(ptr, cut + 1, 1, config->errors);\n        fputs(\"\\n\", config->errors);\n        ptr += cut+1; /* skip the space too */\n        len -= cut;\n      }\n      else {\n        fputs(ptr, config->errors);\n        len = 0;\n      }\n    }\n  }\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "main.c",
        "method_name": "fixed_function",
        "raw_code": "static void warnf(struct Configurable *config, const char *fmt, ...)\n{\n  if(!(config->conf & CONF_MUTE)) {\n    va_list ap;\n    int len;\n    char *ptr;\n    char print_buffer[256];\n\n    va_start(ap, fmt);\n    va_start(ap, fmt);\n    len = vsnprintf(print_buffer, sizeof(print_buffer), fmt, ap);\n    va_end(ap);\n\n    ptr = print_buffer;\n    while(len > 0) {\n      fputs(WARN_PREFIX, config->errors);\n\n      if(len > (int)WARN_TEXTWIDTH) {\n        int cut = WARN_TEXTWIDTH-1;\n\n        while(!ISSPACE(ptr[cut]) && cut) {\n          cut--;\n        }\n        if(0 == cut)\n          /* not a single cutting position was found, just cut it at the\n             max text width then! */\n          cut = WARN_TEXTWIDTH-1;\n\n        fwrite(ptr, cut + 1, 1, config->errors);\n        fputs(\"\\n\", config->errors);\n        ptr += cut+1; /* skip the space too */\n        len -= cut;\n      }\n      else {\n        fputs(ptr, config->errors);\n        len = 0;\n      }\n    }\n  }\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <iconv.h>\n#include <ctype.h>\n#include <utime.h>\n#include <dos.h>\n#include <io.h>\n#include <sys/poll.h>\n#include <errno.h>\n#include <locale.h>\n#include \"version.h\"\n#include <screen.h>\n#include \"curlutil.h\"\n#include <sys/stat.h>\n#include \"writeout.h\"\n#include <limits.h>\n#include <direct.h>\n#include <curl/curl.h>\n#include <string.h>\n#include \"setup.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/utime.h>\n#include <stdarg.h>\n#include \"curlmsg_vms.h\"\n#include \"homedir.h\"\n#include \"hugehelp.h\"\n#include \"urlglob.h\"\n#include \"writeenv.h\"\n#include <curlx.h>\n#include \"getpass.h\"\n#include <fcntl.h>\n#include <sys/types.h>\n#include \"memdebug.h\"\n\n// Type Definitions:\n// Configurable:\nstruct Configurable {\n  bool remote_time;\n  char *random_file;\n  char *egd_file;\n  char *useragent;\n  char *cookie;     /* single line with specified cookies */\n  char *cookiejar;  /* write to this file */\n  char *cookiefile; /* read from this file */\n  bool cookiesession; /* new session? */\n  bool encoding;    /* Accept-Encoding please */\n  long authtype;    /* auth bitmask */\n  bool use_resume;\n  bool resume_from_current;\n  bool disable_epsv;\n  bool disable_eprt;\n  curl_off_t resume_from;\n  char *postfields;\n  long postfieldsize;\n  char *referer;\n  long timeout;\n  long connecttimeout;\n  long maxredirs;\n  curl_off_t max_filesize;\n  char *headerfile;\n  char *ftpport;\n  char *iface;\n  int localport;\n  int localportrange;\n  unsigned short porttouse;\n  char *range;\n  long low_speed_limit;\n  long low_speed_time;\n  bool showerror;\n  char *userpwd;\n  char *proxyuserpwd;\n  char *proxy;\n  bool proxytunnel;\n  long conf;\n  struct getout *url_list; /* point to the first node */\n  struct getout...\n\n// Configurable:\nstruct Configurable\n\n// Called Methods (top 10):\n// WARN_TEXTWIDTH from src/main.c:\n<empty>\n\n// ISSPACE from src/setup_once.h:\n<empty>\n\n// fwrite from include/curl/stdcheaders.h:\nsize_t fwrite (const void *, size_t, size_t, FILE *);\n\n// WARN_PREFIX from src/main.c:\n<empty>\n\n// CONF_MUTE from src/main.c:\n<empty>\n"
  },
  {
    "repository": "tensorflow",
    "cve_id": "CVE-2021-37639",
    "cwe_list": [
      "CWE-476"
    ],
    "commit_hash": "9e82dce6e6bd1f36a57e08fa85af213e2b2f2622",
    "short_hash": "9e82dce6",
    "vulnerableMethods_before": [
      {
        "filename": "save_restore_tensor.cc",
        "method_name": "vulnerable_function",
        "raw_code": "void RestoreTensor(OpKernelContext* context,\n                   checkpoint::TensorSliceReader::OpenTableFunction open_func,\n                   int preferred_shard, bool restore_slice, int restore_index) {\n  const Tensor& file_pattern_t = context->input(0);\n  {\n    const int64_t size = file_pattern_t.NumElements();\n    OP_REQUIRES(\n        context, size == 1,\n        errors::InvalidArgument(\n            \"Input 0 (file_pattern) must be a string scalar; got a tensor of \",\n            size, \"elements\"));\n  }\n  const string& file_pattern = file_pattern_t.flat<tstring>()(0);\n\n  const Tensor& tensor_name_t = context->input(1);\n  const string& tensor_name = tensor_name_t.flat<tstring>()(restore_index);\n\n  // If we cannot find a cached reader we will allocate our own.\n  std::unique_ptr<checkpoint::TensorSliceReader> allocated_reader;\n\n  const checkpoint::TensorSliceReader* reader = nullptr;\n\n  if (context->slice_reader_cache()) {\n    reader = context->slice_reader_cache()->GetReader(file_pattern, open_func,\n                                                      preferred_shard);\n  }\n  if (!reader) {\n    allocated_reader.reset(new checkpoint::TensorSliceReader(\n        file_pattern, open_func, preferred_shard));\n    reader = allocated_reader.get();\n  }\n  OP_REQUIRES_OK(context, CHECK_NOTNULL(reader)->status());\n\n  // Get the shape and type from the save file.\n  DataType type;\n  TensorShape saved_shape;\n  OP_REQUIRES(\n      context, reader->HasTensor(tensor_name, &saved_shape, &type),\n      errors::NotFound(\"Tensor name \\\"\", tensor_name,\n                       \"\\\" not found in checkpoint files \", file_pattern));\n  OP_REQUIRES(\n      context, type == context->expected_output_dtype(restore_index),\n      errors::InvalidArgument(\"Expected to restore a tensor of type \",\n                              DataTypeString(context->expected_output_dtype(0)),\n                              \", got a tensor of type \", DataTypeString(type),\n                              \" instead: tensor_name = \", tensor_name));\n\n  // Shape of the output and slice to load.\n  TensorShape output_shape(saved_shape);\n  TensorSlice slice_to_load(saved_shape.dims());\n  if (restore_slice) {\n    const tstring& shape_spec =\n        context->input(2).flat<tstring>()(restore_index);\n    if (!shape_spec.empty()) {\n      TensorShape parsed_shape;\n      OP_REQUIRES_OK(context, checkpoint::ParseShapeAndSlice(\n                                  shape_spec, &parsed_shape, &slice_to_load,\n                                  &output_shape));\n      OP_REQUIRES(\n          context, parsed_shape.IsSameSize(saved_shape),\n          errors::InvalidArgument(\n              \"Shape in shape_and_slice spec does not match the shape in the \"\n              \"save file: \",\n              parsed_shape.DebugString(),\n              \", save file shape: \", saved_shape.DebugString()));\n    }\n  }\n\n  Tensor* t = nullptr;\n  OP_REQUIRES_OK(context,\n                 context->allocate_output(restore_index, output_shape, &t));\n\n  if (output_shape.num_elements() == 0) return;\n\n#define READER_COPY(T)                                                \\\n  case DataTypeToEnum<T>::value:                                      \\\n    OP_REQUIRES(context,                                              \\\n                reader->CopySliceData(tensor_name, slice_to_load,     \\\n                                      t->flat<T>().data()),           \\\n                errors::InvalidArgument(\"Error copying slice data\")); \\\n    break;\n\n  switch (type) {\n    TF_CALL_SAVE_RESTORE_TYPES(READER_COPY)\n    default:\n      context->SetStatus(errors::Unimplemented(\n          \"Restoring data type \", DataTypeString(type), \" not yet supported\"));\n  }\n#undef READER_COPY\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "save_restore_tensor.cc",
        "method_name": "fixed_function",
        "raw_code": "void RestoreTensor(OpKernelContext* context,\n                   checkpoint::TensorSliceReader::OpenTableFunction open_func,\n                   int preferred_shard, bool restore_slice, int restore_index) {\n  const Tensor& file_pattern_t = context->input(0);\n  {\n    const int64_t size = file_pattern_t.NumElements();\n    OP_REQUIRES(\n        context, size == 1,\n        errors::InvalidArgument(\n            \"Input 0 (file_pattern) must be a string scalar; got a tensor of \",\n            size, \" elements\"));\n  }\n  const string& file_pattern = file_pattern_t.flat<tstring>()(0);\n\n  const Tensor& tensor_name_t = context->input(1);\n  {\n    const int64_t size = tensor_name_t.NumElements();\n    OP_REQUIRES(context, size > restore_index,\n                errors::InvalidArgument(\n                    \"Input 1 (file_pattern) must be a have at least \",\n                    restore_index + 1, \" elements\"));\n  }\n  const string& tensor_name = tensor_name_t.flat<tstring>()(restore_index);\n\n  // If we cannot find a cached reader we will allocate our own.\n  std::unique_ptr<checkpoint::TensorSliceReader> allocated_reader;\n\n  const checkpoint::TensorSliceReader* reader = nullptr;\n\n  if (context->slice_reader_cache()) {\n    reader = context->slice_reader_cache()->GetReader(file_pattern, open_func,\n                                                      preferred_shard);\n  }\n  if (!reader) {\n    allocated_reader.reset(new checkpoint::TensorSliceReader(\n        file_pattern, open_func, preferred_shard));\n    reader = allocated_reader.get();\n  }\n  OP_REQUIRES_OK(context, CHECK_NOTNULL(reader)->status());\n\n  // Get the shape and type from the save file.\n  DataType type;\n  TensorShape saved_shape;\n  OP_REQUIRES(\n      context, reader->HasTensor(tensor_name, &saved_shape, &type),\n      errors::NotFound(\"Tensor name \\\"\", tensor_name,\n                       \"\\\" not found in checkpoint files \", file_pattern));\n  OP_REQUIRES(\n      context, type == context->expected_output_dtype(restore_index),\n      errors::InvalidArgument(\"Expected to restore a tensor of type \",\n                              DataTypeString(context->expected_output_dtype(0)),\n                              \", got a tensor of type \", DataTypeString(type),\n                              \" instead: tensor_name = \", tensor_name));\n\n  // Shape of the output and slice to load.\n  TensorShape output_shape(saved_shape);\n  TensorSlice slice_to_load(saved_shape.dims());\n  if (restore_slice) {\n    const tstring& shape_spec =\n        context->input(2).flat<tstring>()(restore_index);\n    if (!shape_spec.empty()) {\n      TensorShape parsed_shape;\n      OP_REQUIRES_OK(context, checkpoint::ParseShapeAndSlice(\n                                  shape_spec, &parsed_shape, &slice_to_load,\n                                  &output_shape));\n      OP_REQUIRES(\n          context, parsed_shape.IsSameSize(saved_shape),\n          errors::InvalidArgument(\n              \"Shape in shape_and_slice spec does not match the shape in the \"\n              \"save file: \",\n              parsed_shape.DebugString(),\n              \", save file shape: \", saved_shape.DebugString()));\n    }\n  }\n\n  Tensor* t = nullptr;\n  OP_REQUIRES_OK(context,\n                 context->allocate_output(restore_index, output_shape, &t));\n\n  if (output_shape.num_elements() == 0) return;\n\n#define READER_COPY(T)                                                \\\n  case DataTypeToEnum<T>::value:                                      \\\n    OP_REQUIRES(context,                                              \\\n                reader->CopySliceData(tensor_name, slice_to_load,     \\\n                                      t->flat<T>().data()),           \\\n                errors::InvalidArgument(\"Error copying slice data\")); \\\n    break;\n\n  switch (type) {\n    TF_CALL_SAVE_RESTORE_TYPES(READER_COPY)\n    default:\n      context->SetStatus(errors::Unimplemented(\n          \"Restoring data type \", DataTypeString(type), \" not yet supported\"));\n  }\n#undef READER_COPY\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"tensorflow/core/util/tensor_slice_writer.h\"\n#include <unordered_map>\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/framework/bounds_check.h\"\n#include \"tensorflow/core/util/tensor_slice_reader_cache.h\"\n#include \"tensorflow/core/lib/strings/strcat.h\"\n#include \"tensorflow/core/lib/gtl/array_slice.h\"\n#include \"tensorflow/core/platform/types.h\"\n#include \"tensorflow/core/lib/core/threadpool.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include <numeric>\n#include \"tensorflow/core/util/tensor_slice_reader.h\"\n#include <utility>\n#include \"tensorflow/core/kernels/save_restore_tensor.h\"\n#include \"tensorflow/core/util/tensor_bundle/tensor_bundle.h\"\n#include <vector>\n#include \"tensorflow/core/lib/strings/stringprintf.h\"\n#include \"tensorflow/core/lib/strings/str_util.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n\n// Type Definitions:\n// TensorSliceReaderCacheWrapper:\nclass TensorSliceReaderCacheWrapper\n\n// TensorSlice:\nclass TensorSlice {\n public:\n  // Construct a tensor slice: you have a number of ways:\n  // -- creating an empty slice\n  // -- from just a dimension (in this case it will create a full slice)\n  // -- from an array of pairs of integers.\n  // -- from a TensorSliceProto protocol buffer\n  // -- from a string format of \"start,length:start,length...\" where each\n  //    \"start,length\" pair represents the slice on one dimension. We allow a\n  //    special \"-\" that means \"everything for this dimension\". One such example\n  //    is:  0,10:-:14,1:-:-\n  TensorSlice() {}\n  explicit TensorSlice(int dim);\n  explicit TensorSlice(const TensorSliceProto& proto);\n  explicit TensorSlice(std::initializer_list<std::pair<int64, int64>> extents);\n\n  static Status Parse(const string& str, TensorSlice* output);\n  static TensorSlice ParseOrDie(const string& str) {\n    TensorSlice ret;\n    Status s = Parse(str, &ret);\n    if (!s.ok()) {\n      LOG(FATAL) << \"Could not parse TensorSlice\";\n    }\n    return ret;\n ...\n\n// DataTypeToEnum:\nstruct DataTypeToEnum<unsigned long> {\n  static DataType v() { return value; }\n  static DataType ref() { return MakeRefType(value); }\n  static constexpr DataType value =\n      sizeof(unsigned long) == 4 ? DT_UINT32 : DT_UINT64;\n}\n\n// OpKernelContext:\nclass OpKernelContext {\n public:\n  // The first element of a WrappedAllocator is a \"base\" Allocator and\n  // the second element is that Allocator wrapped by a\n  // TrackingAllocator\n  typedef std::pair<Allocator*, TrackingAllocator*> WrappedAllocator;\n\n  // TODO(zhifengc): Do some cleanup of Params.\n  // The Params struct is passed in to initialize an OpKernelContext,\n  // and must outlive the OpKernelContext.\n  struct Params {\n    ~Params() { delete eigen_gpu_device; }\n\n    // The step being executed.\n    int64 step_id = 0;\n\n    // Timestamp for the start of graph execution. Used for latency metrics.\n    int64 start_time_usecs = 0;\n\n    // The op kernel being computed.\n    OpKernel* op_kernel = nullptr;\n\n    // The device on which the kernel is running.\n    DeviceBase* device = nullptr;\n\n    // The Eigen GPU device wrapper, which may include a per-op\n    // wrapped allocator. The concrete type of this object depends on\n    // the type of this->device, so eigen_gpu_device can't be a...\n\n// Status:\nclass Status {\n public:\n  /// Create a success status.\n  Status() {}\n\n  /// \\brief Create a status with the specified error code and msg as a\n  /// human-readable string containing more detailed information.\n  Status(tensorflow::error::Code code, tensorflow::StringPiece msg)\n      : Status(code, msg, {}) {}\n\n  /// \\brief Create a status with the specified error code, msg, and stack trace\n  /// as a human-readable string containing more detailed information.\n#ifndef SWIG\n  Status(tensorflow::error::Code code, tensorflow::StringPiece msg,\n         std::vector<StackFrame>&& stack_trace);\n#endif\n\n  /// Copy the specified status.\n  Status(const Status& s);\n  Status& operator=(const Status& s);\n#ifndef SWIG\n  Status(Status&& s) noexcept;\n  Status& operator=(Status&& s) noexcept;\n#endif  // SWIG\n\n  static Status OK() { return Status(); }\n\n  /// Returns true iff the status indicates success.\n  bool ok() const { return (state_ == nullptr); }\n\n  tensorflow::error::Code code() const {\n    retu...\n\n// DataType:\ntensorflow.TensorHandle.DataType:DataType()<const>\n\n// Status:\nclass Status\n\n// Tensor:\nclass Tensor {\n public:\n  /// \\brief Creates a 1-dimensional, 0-element float tensor.\n  ///\n  /// The returned Tensor is not a scalar (shape {}), but is instead\n  /// an empty one-dimensional Tensor (shape {0}, NumElements() ==\n  /// 0). Since it has no elements, it does not need to be assigned a\n  /// value and is initialized by default (IsInitialized() is\n  /// true). If this is undesirable, consider creating a one-element\n  /// scalar which does require initialization:\n  ///\n  /// ```c++\n  ///\n  ///     Tensor(DT_FLOAT, TensorShape({}))\n  ///\n  /// ```\n  Tensor();\n\n  /// \\brief Creates a Tensor of the given `type` and `shape`.  If\n  /// LogMemory::IsEnabled() the allocation is logged as coming from\n  /// an unknown kernel and step. Calling the Tensor constructor\n  /// directly from within an Op is deprecated: use the\n  /// OpKernelConstruction/OpKernelContext allocate_* methods to\n  /// allocate a new tensor, which record the kernel and step.\n  ///\n  /// The underlying buffer is ...\n\n// Tensor:\ntensorflow.TensorHandle.Tensor:tensorflow.Status(tensorflow.Tensor**)<const>\n\n// OpKernelContext:\ntensorflow.OpKernelContext.OpKernelContext:ANY(tensorflow.OpKernelContext.Params*)\n\n// TensorShape:\nclass TensorShape : public TensorShapeBase<TensorShape> {\n public:\n  using TensorShapeBase<TensorShape>::TensorShapeBase;\n\n  /// Allow a TensorShape to be used as a PartialTensorShape without copying\n  operator const PartialTensorShape&() const;  // NOLINT(runtime/explicit)\n\n  /// Returns true if `*this` and `b` have the same sizes. Ignores\n  /// dimension names.\n  bool IsSameSize(const TensorShape& b) const;\n  bool operator==(const TensorShape& b) const { return IsSameSize(b); }\n  bool operator!=(const TensorShape& b) const { return !IsSameSize(b); }\n\n  /// Fill `*dsizes` from `*this`.\n  /// Notice: Using IndexType=int32 in combination with To32Bit() can\n  /// significantly improve performance on GPU.\n  template <int NDIMS, typename IndexType = Eigen::DenseIndex>\n  Eigen::DSizes<IndexType, NDIMS> AsEigenDSizes() const;\n\n  // Same as `AsEigenDSizes()` but returns a `Status` instead.\n  // Use this method to surface error to user instead of crashing if `NDMIS` is\n  // not equal to `di...\n\n// Called Methods (top 10):\n// SetStatus from tensorflow/core/framework/op_kernel.cc:\nvoid OpKernelConstruction::SetStatus(const Status& status) { /* <=== tensorflow.OpKernelConstruction.SetStatus:void(tensorflow.Status&) */ \n  status_->Update(status);\n}\n\n// OP_REQUIRES from tensorflow/core/kernels/tensorflow/core/framework/tensorflow/core/framework/op_requires.h:\n\n\n// name from tensorflow/core/framework/op_kernel.h:\n  const std::string& name() const { return props_->node_def.name(); } /* <=== tensorflow.OpKernel.name:ANY()<const> */ \n\n// TF_RETURN_IF_ERROR from tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/errors.h:\n\n\n// DCHECK_GE from tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/platform/logging.h:\n\n\n// DCHECK_LT from tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/platform/logging.h:\n\n\n// empty from tensorflow/core/platform/tstring.h:\ninline bool tstring::empty() const { return size() == 0; } /* <=== tensorflow.tstring.empty:bool()<const> */ \n\n// expected_output_dtype from tensorflow/core/framework/op_kernel.h:\n  DataType expected_output_dtype(int index) const; /* <=== tensorflow.OpKernelContext.expected_output_dtype:ANY(int)<const> */ \n\n// CHECK_EQ from tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/platform/logging.h:\n\n\n// OP_REQUIRES_OK from tensorflow/core/kernels/tensorflow/core/framework/tensorflow/core/framework/op_requires.h:\n\n"
  },
  {
    "repository": "linux",
    "cve_id": "CVE-2021-41864",
    "cwe_list": [
      "CWE-787"
    ],
    "commit_hash": "30e29a9a2bc6a4888335a6ede968b75cd329657a",
    "short_hash": "30e29a9a",
    "vulnerableMethods_before": [
      {
        "filename": "stackmap.c",
        "method_name": "vulnerable_function",
        "raw_code": "static int prealloc_elems_and_freelist(struct bpf_stack_map *smap)\n{\n\tu32 elem_size = sizeof(struct stack_map_bucket) + smap->map.value_size;\n\tint err;\n\n\tsmap->elems = bpf_map_area_alloc(elem_size * smap->map.max_entries,\n\t\t\t\t\t smap->map.numa_node);\n\tif (!smap->elems)\n\t\treturn -ENOMEM;\n\n\terr = pcpu_freelist_init(&smap->freelist);\n\tif (err)\n\t\tgoto free_elems;\n\n\tpcpu_freelist_populate(&smap->freelist, smap->elems, elem_size,\n\t\t\t       smap->map.max_entries);\n\treturn 0;\n\nfree_elems:\n\tbpf_map_area_free(smap->elems);\n\treturn err;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "stackmap.c",
        "method_name": "fixed_function",
        "raw_code": "static int prealloc_elems_and_freelist(struct bpf_stack_map *smap)\n{\n\tu64 elem_size = sizeof(struct stack_map_bucket) +\n\t\t\t(u64)smap->map.value_size;\n\tint err;\n\n\tsmap->elems = bpf_map_area_alloc(elem_size * smap->map.max_entries,\n\t\t\t\t\t smap->map.numa_node);\n\tif (!smap->elems)\n\t\treturn -ENOMEM;\n\n\terr = pcpu_freelist_init(&smap->freelist);\n\tif (err)\n\t\tgoto free_elems;\n\n\tpcpu_freelist_populate(&smap->freelist, smap->elems, elem_size,\n\t\t\t       smap->map.max_entries);\n\treturn 0;\n\nfree_elems:\n\tbpf_map_area_free(smap->elems);\n\treturn err;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"percpu_freelist.h\"\n#include <linux/bpf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/btf_ids.h>\n#include <linux/jhash.h>\n#include <linux/irq_work.h>\n#include <linux/buildid.h>\n#include <linux/stacktrace.h>\n#include <linux/kernel.h>\n\n// Type Definitions:\n// stack_map_bucket:\nstruct stack_map_bucket {\n\tstruct pcpu_freelist_node fnode;\n\tu32 hash;\n\tu32 nr;\n\tu64 data[];\n}\n\n// bpf_stack_map:\nstruct bpf_stack_map {\n\tstruct bpf_map map;\n\tvoid *elems;\n\tstruct pcpu_freelist freelist;\n\tu32 n_buckets;\n\tstruct stack_map_bucket *buckets[];\n}\n\n// u32:\ntypedef unsigned int   u32;\n\n// Called Methods (top 10):\n// for_each_possible_cpu from arch/x86/kernel/setup_percpu.c:\n\tfor_each_possible_cpu(cpu) { /* <=== for_each_possible_cpu */ \n\t\tint node = early_cpu_to_node(cpu);\n\n\t\tif (node_online(node) && NODE_DATA(node) &&\n\t\t    last && last != NODE_DATA(node))\n\t\t\treturn true;\n\n\t\tlast = NODE_DATA(node);\n\t}\n\n// pcpu_freelist_populate from kernel/bpf/percpu_freelist.c:\nvoid pcpu_freelist_populate(struct pcpu_freelist *s, void *buf, u32 elem_size, /* <=== pcpu_freelist_populate */ \n\t\t\t    u32 nr_elems)\n{\n\tstruct pcpu_freelist_head *head;\n\tint i, cpu, pcpu_entries;\n\n\tpcpu_entries = nr_elems / num_possible_cpus() + 1;\n\ti = 0;\n\n\tfor_each_possible_cpu(cpu) {\nagain:\n\t\thead = per_cpu_ptr(s->freelist, cpu);\n\t\t/* No locking required as this is not visible yet. */\n\t\tpcpu_freelist_push_node(head, buf);\n\t\ti++;\n\t\tbuf += elem_size;\n\t\tif (i == nr_elems)\n\t\t\tbreak;\n\t\tif (i % pcpu_entries)\n\t\t\tgoto again;\n\t}\n}\n\n// pcpu_freelist_push_node from kernel/bpf/percpu_freelist.c:\nstatic inline void pcpu_freelist_push_node(struct pcpu_freelist_head *head, /* <=== pcpu_freelist_push_node */ \n\t\t\t\t\t   struct pcpu_freelist_node *node)\n{\n\tnode->next = head->first;\n\thead->first = node;\n}\n\n// bpf_map_area_alloc from kernel/bpf/syscall.c:\nvoid *bpf_map_area_alloc(u64 size, int numa_node) /* <=== bpf_map_area_alloc */ \n{\n\treturn __bpf_map_area_alloc(size, numa_node, false);\n}\n\n// BUG_ON from arch/powerpc/kernel/interrupt.c:\n\tBUG_ON(user_mode(regs)); /* <=== BUG_ON */ \n\n// bpf_map_area_free from kernel/bpf/syscall.c:\nvoid bpf_map_area_free(void *area) /* <=== bpf_map_area_free */ \n{\n\tkvfree(area);\n}\n\n// pcpu_freelist_init from kernel/bpf/percpu_freelist.c:\nint pcpu_freelist_init(struct pcpu_freelist *s) /* <=== pcpu_freelist_init */ \n{\n\tint cpu;\n\n\ts->freelist = alloc_percpu(struct pcpu_freelist_head);\n\tif (!s->freelist)\n\t\treturn -ENOMEM;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct pcpu_freelist_head *head = per_cpu_ptr(s->freelist, cpu);\n\n\t\traw_spin_lock_init(&head->lock);\n\t\thead->first = NULL;\n\t}\n\traw_spin_lock_init(&s->extralist.lock);\n\ts->extralist.first = NULL;\n\treturn 0;\n}\n\n// __bpf_map_area_alloc from kernel/bpf/syscall.c:\nstatic void *__bpf_map_area_alloc(u64 size, int numa_node, bool mmapable) /* <=== __bpf_map_area_alloc */ \n{\n\t/* We really just want to fail instead of triggering OOM killer\n\t * under memory pressure, therefore we set __GFP_NORETRY to kmalloc,\n\t * which is used for lower order allocation requests.\n\t *\n\t * It has been observed that higher order allocation requests done by\n\t * vmalloc with __GFP_NORETRY being set might fail due to not trying\n\t * to reclaim memory from the page cache, thus we set\n\t * __GFP_RETRY_MAYFAIL to avoid such situations.\n\t */\n\n\tconst gfp_t gfp = __GFP_NOWARN | __GFP_ZERO | __GFP_ACCOUNT;\n\tunsigned int flags = 0;\n\tunsigned long align = 1;\n\tvoid *area;\n\n\tif (size >= SIZE_MAX)\n\t\treturn NULL;\n\n\t/* kmalloc()'ed memory can't be mmap()'ed */\n\tif (mmapable) {\n\t\tBUG_ON(!PAGE_ALIGNED(size));\n\t\talign = SHMLBA;\n\t\tflags = VM_USERMAP;\n\t} else if (size <= (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER)) {\n\t\tarea = kmalloc_node(size, gfp | GFP_USER | __GFP_NORETRY,\n\t\t\t\t    numa_node);\n\t\tif (area != NULL)\n\t\t\treturn area;\n\t}\n\n\treturn __vmalloc_node_range(size, align, VMALLOC_START, VMALLOC_END,\n\t\t\tgfp | GFP_KERNEL | __GFP_RETRY_MAYFAIL, PAGE_KERNEL,\n\t\t\tflags, numa_node, __builtin_return_address(0));\n}\n"
  },
  {
    "repository": "radare2",
    "cve_id": "CVE-2022-1899",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "193f4fe01d7f626e2ea937450f2e0c4604420e9d",
    "short_hash": "193f4fe0",
    "vulnerableMethods_before": [
      {
        "filename": "bfile.c",
        "method_name": "vulnerable_function",
        "raw_code": "static int string_scan_range(RList *list, RBinFile *bf, int min,\n\t\t\t      const ut64 from, const ut64 to, int type, int raw, RBinSection *section) {\n\tRBin *bin = bf->rbin;\n\tut8 tmp[R_STRING_SCAN_BUFFER_SIZE];\n\tut64 str_start, needle = from;\n\tint count = 0, i, rc, runes;\n\tint str_type = R_STRING_TYPE_DETECT;\n\n\t// if list is null it means its gonna dump\n\tr_return_val_if_fail (bf, -1);\n\n\tif (type == -1) {\n\t\ttype = R_STRING_TYPE_DETECT;\n\t}\n\tif (from == to) {\n\t\treturn 0;\n\t}\n\tif (from > to) {\n\t\teprintf (\"Invalid range to find strings 0x%\"PFMT64x\" .. 0x%\"PFMT64x\"\\n\", from, to);\n\t\treturn -1;\n\t}\n\tst64 len = (st64)(to - from);\n\tif (len < 1 || len > ST32_MAX) {\n\t\teprintf (\"String scan range is invalid (%\"PFMT64d\" bytes)\\n\", len);\n\t\treturn -1;\n\t}\n\tut8 *buf = calloc (len, 1);\n\tif (!buf || !min) {\n\t\tfree (buf);\n\t\treturn -1;\n\t}\n\tst64 vdelta = 0, pdelta = 0;\n\tRBinSection *s = NULL;\n\tbool ascii_only = false;\n\tPJ *pj = NULL;\n\tif (bf->strmode == R_MODE_JSON && !list) {\n\t\tpj = pj_new ();\n\t\tif (pj) {\n\t\t\tpj_a (pj);\n\t\t}\n\t}\n\tr_buf_read_at (bf->buf, from, buf, len);\n\tchar *charset = r_sys_getenv (\"RABIN2_CHARSET\");\n\tif (!R_STR_ISEMPTY (charset)) {\n\t\tRCharset *ch = r_charset_new ();\n\t\tif (r_charset_use (ch, charset)) {\n\t\t\tint outlen = len * 4;\n\t\t\tut8 *out = calloc (len, 4);\n\t\t\tif (out) {\n\t\t\t\tint res = r_charset_encode_str (ch, out, outlen, buf, len);\n\t\t\t\tint i;\n\t\t\t\t// TODO unknown chars should be translated to null bytes\n\t\t\t\tfor (i = 0; i < res; i++) {\n\t\t\t\t\tif (out[i] == '?') {\n\t\t\t\t\t\tout[i] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlen = res;\n\t\t\t\tfree (buf);\n\t\t\t\tbuf = out;\n\t\t\t} else {\n\t\t\t\teprintf (\"Cannot allocate\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Invalid value for RABIN2_CHARSET.\\n\");\n\t\t}\n\t\tr_charset_free (ch);\n\t}\n\tfree (charset);\n\tRConsIsBreaked is_breaked = (bin && bin->consb.is_breaked)? bin->consb.is_breaked: NULL;\n\t// may oobread\n\twhile (needle < to) {\n\t\tif (is_breaked && is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\t// smol optimization\n\t\tif (needle + 4 < to) {\n\t\t\tut32 n1 = r_read_le32 (buf + needle - from);\n\t\t\tif (!n1) {\n\t\t\t\tneedle += 4;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\trc = r_utf8_decode (buf + needle - from, to - needle, NULL);\n\t\tif (!rc) {\n\t\t\tneedle++;\n\t\t\tcontinue;\n\t\t}\n\t\tbool addr_aligned = !(needle % 4);\n\n\t\tif (type == R_STRING_TYPE_DETECT) {\n\t\t\tchar *w = (char *)buf + needle + rc - from;\n\t\t\tif (((to - needle) > 8 + rc)) {\n\t\t\t\t// TODO: support le and be\n\t\t\t\tbool is_wide32le = (needle + rc + 2 < to) && (!w[0] && !w[1] && !w[2] && w[3] && !w[4]);\n\t\t\t\t// reduce false positives\n\t\t\t\tif (is_wide32le) {\n\t\t\t\t\tif (!w[5] && !w[6] && w[7] && w[8]) {\n\t\t\t\t\t\tis_wide32le = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!addr_aligned) {\n\t\t\t\t\tis_wide32le = false;\n\t\t\t\t}\n\t\t\t\t///is_wide32be &= (n1 < 0xff && n11 < 0xff); // false; // n11 < 0xff;\n\t\t\t\tif (is_wide32le  && addr_aligned) {\n\t\t\t\t\tstr_type = R_STRING_TYPE_WIDE32; // asume big endian,is there little endian w32?\n\t\t\t\t} else {\n\t\t\t\t\t// bool is_wide = (n1 && n2 && n1 < 0xff && (!n2 || n2 < 0xff));\n\t\t\t\t\tbool is_wide = needle + rc + 4 < to && !w[0] && w[1] && !w[2] && w[3] && !w[4];\n\t\t\t\t\tstr_type = is_wide? R_STRING_TYPE_WIDE: R_STRING_TYPE_ASCII;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (rc > 1) {\n\t\t\t\t\tstr_type = R_STRING_TYPE_UTF8; // could be charset if set :?\n\t\t\t\t} else {\n\t\t\t\t\tstr_type = R_STRING_TYPE_ASCII;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (type == R_STRING_TYPE_UTF8) {\n\t\t\tstr_type = R_STRING_TYPE_ASCII; // initial assumption\n\t\t} else {\n\t\t\tstr_type = type;\n\t\t}\n\t\trunes = 0;\n\t\tstr_start = needle;\n\n\t\t/* Eat a whole C string */\n\t\tfor (i = 0; i < sizeof (tmp) - 4 && needle < to; i += rc) {\n\t\t\tRRune r = {0};\n\t\t\tif (str_type == R_STRING_TYPE_WIDE32) {\n\t\t\t\trc = r_utf32le_decode (buf + needle - from, to - needle, &r);\n\t\t\t\tif (rc) {\n\t\t\t\t\trc = 4;\n\t\t\t\t}\n\t\t\t} else if (str_type == R_STRING_TYPE_WIDE) {\n\t\t\t\trc = r_utf16le_decode (buf + needle - from, to - needle, &r);\n\t\t\t\tif (rc == 1) {\n\t\t\t\t\trc = 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trc = r_utf8_decode (buf + needle - from, to - needle, &r);\n\t\t\t\tif (rc > 1) {\n\t\t\t\t\tstr_type = R_STRING_TYPE_UTF8;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Invalid sequence detected */\n\t\t\tif (!rc || (ascii_only && r > 0x7f)) {\n\t\t\t\tneedle++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tneedle += rc;\n\n\t\t\tif (r_isprint (r) && r != '\\\\') {\n\t\t\t\tif (str_type == R_STRING_TYPE_WIDE32) {\n\t\t\t\t\tif (r == 0xff) {\n\t\t\t\t\t\tr = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trc = r_utf8_encode (tmp + i, r);\n\t\t\t\trunes++;\n\t\t\t\t/* Print the escape code */\n\t\t\t} else if (r && r < 0x100 && strchr (\"\\b\\v\\f\\n\\r\\t\\a\\033\\\\\", (char)r)) {\n\t\t\t\tif ((i + 32) < sizeof (tmp) && r < 93) {\n\t\t\t\t\ttmp[i + 0] = '\\\\';\n\t\t\t\t\ttmp[i + 1] = \"       abtnvfr             e  \"\n\t\t\t\t\t             \"                              \"\n\t\t\t\t\t             \"                              \"\n\t\t\t\t\t             \"  \\\\\"[r];\n\t\t\t\t} else {\n\t\t\t\t\t// string too long\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\trc = 2;\n\t\t\t\trunes++;\n\t\t\t} else {\n\t\t\t\t/* \\0 marks the end of C-strings */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\ttmp[i++] = '\\0';\n\n\t\tif (runes < min && runes >= 2 && str_type == R_STRING_TYPE_ASCII && needle < to) {\n\t\t\t// back up past the \\0 to the last char just in case it starts a wide string\n\t\t\tneedle -= 2;\n\t\t}\n\t\tif (runes >= min) {\n\t\t\t// reduce false positives\n\t\t\tint j, num_blocks, *block_list;\n\t\t\tint *freq_list = NULL, expected_ascii, actual_ascii, num_chars;\n\t\t\tif (str_type == R_STRING_TYPE_ASCII) {\n\t\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\t\tchar ch = tmp[j];\n\t\t\t\t\tif (ch != '\\n' && ch != '\\r' && ch != '\\t') {\n\t\t\t\t\t\tif (!IS_PRINTABLE (tmp[j])) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch (str_type) {\n\t\t\tcase R_STRING_TYPE_UTF8:\n\t\t\tcase R_STRING_TYPE_WIDE:\n\t\t\tcase R_STRING_TYPE_WIDE32:\n\t\t\t\tnum_blocks = 0;\n\t\t\t\tblock_list = r_utf_block_list ((const ut8*)tmp, i - 1,\n\t\t\t\t\t\tstr_type == R_STRING_TYPE_WIDE? &freq_list: NULL);\n\t\t\t\tif (block_list) {\n\t\t\t\t\tfor (j = 0; block_list[j] != -1; j++) {\n\t\t\t\t\t\tnum_blocks++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (freq_list) {\n\t\t\t\t\tnum_chars = 0;\n\t\t\t\t\tactual_ascii = 0;\n\t\t\t\t\tfor (j = 0; freq_list[j] != -1; j++) {\n\t\t\t\t\t\tnum_chars += freq_list[j];\n\t\t\t\t\t\tif (!block_list[j]) { // ASCII\n\t\t\t\t\t\t\tactual_ascii = freq_list[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree (freq_list);\n\t\t\t\t\texpected_ascii = num_blocks ? num_chars / num_blocks : 0;\n\t\t\t\t\tif (actual_ascii > expected_ascii) {\n\t\t\t\t\t\tascii_only = true;\n\t\t\t\t\t\tneedle = str_start;\n\t\t\t\t\t\tfree (block_list);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (block_list);\n\t\t\t\tif (num_blocks > R_STRING_MAX_UNI_BLOCKS) {\n\t\t\t\t\tneedle++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tRBinString *bs = R_NEW0 (RBinString);\n\t\t\tif (!bs) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbs->type = str_type;\n\t\t\tbs->length = runes;\n\t\t\tbs->size = needle - str_start;\n\t\t\tbs->ordinal = count++;\n\t\t\t// TODO: move into adjust_offset\n\t\t\tswitch (str_type) {\n\t\t\tcase R_STRING_TYPE_WIDE:\n\t\t\t\tif (str_start - from > 1) {\n\t\t\t\t\tconst ut8 *p = buf + str_start - 2 - from;\n\t\t\t\t\tif (p[0] == 0xff && p[1] == 0xfe) {\n\t\t\t\t\t\tstr_start -= 2; // \\xff\\xfe\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_STRING_TYPE_WIDE32:\n\t\t\t\tif (str_start - from > 3) {\n\t\t\t\t\tconst ut8 *p = buf + str_start - 4 - from;\n\t\t\t\t\tif (p[0] == 0xff && p[1] == 0xfe) {\n\t\t\t\t\t\tstr_start -= 4; // \\xff\\xfe\\x00\\x00\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!s) {\n\t\t\t\tif (section) {\n\t\t\t\t\ts = section;\n\t\t\t\t} else if (bf->o) {\n\t\t\t\t\ts = r_bin_get_section_at (bf->o, str_start, false);\n\t\t\t\t}\n\t\t\t\tif (s) {\n\t\t\t\t\tvdelta = s->vaddr;\n\t\t\t\t\tpdelta = s->paddr;\n\t\t\t\t}\n\t\t\t}\n\t\t\tut64 baddr = bf->loadaddr && bf->o? bf->o->baddr: bf->loadaddr;\n\t\t\tbs->paddr = str_start + baddr;\n\t\t\tbs->vaddr = str_start - pdelta + vdelta + baddr;\n\t\t\tbs->string = r_str_ndup ((const char *)tmp, i);\n\t\t\tif (list) {\n\t\t\t\tr_list_append (list, bs);\n\t\t\t\tif (bf->o) {\n\t\t\t\t\tht_up_insert (bf->o->strings_db, bs->vaddr, bs);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprint_string (bf, bs, raw, pj);\n\t\t\t\tr_bin_string_free (bs);\n\t\t\t}\n\t\t\tif (from == 0 && to == bf->size) {\n\t\t\t\t/* force lookup section at the next one */\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t}\n\t\tascii_only = false;\n\t}\n\tfree (buf);\n\tif (pj) {\n\t\tpj_end (pj);\n\t\tif (bin) {\n\t\t\tRIO *io = bin->iob.io;\n\t\t\tif (io) {\n\t\t\t\tio->cb_printf (\"%s\", pj_string (pj));\n\t\t\t}\n\t\t}\n\t\tpj_free (pj);\n\t}\n\treturn count;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "bfile.c",
        "method_name": "fixed_function",
        "raw_code": "static int string_scan_range(RList *list, RBinFile *bf, int min,\n\t\t\t      const ut64 from, const ut64 to, int type, int raw, RBinSection *section) {\n\tRBin *bin = bf->rbin;\n\tut8 tmp[R_STRING_SCAN_BUFFER_SIZE];\n\tut64 str_start, needle = from;\n\tint count = 0, i, rc, runes;\n\tint str_type = R_STRING_TYPE_DETECT;\n\n\t// if list is null it means its gonna dump\n\tr_return_val_if_fail (bf, -1);\n\n\tif (type == -1) {\n\t\ttype = R_STRING_TYPE_DETECT;\n\t}\n\tif (from == to) {\n\t\treturn 0;\n\t}\n\tif (from > to) {\n\t\teprintf (\"Invalid range to find strings 0x%\"PFMT64x\" .. 0x%\"PFMT64x\"\\n\", from, to);\n\t\treturn -1;\n\t}\n\tst64 len = (st64)(to - from);\n\tif (len < 1 || len > ST32_MAX) {\n\t\teprintf (\"String scan range is invalid (%\"PFMT64d\" bytes)\\n\", len);\n\t\treturn -1;\n\t}\n\tut8 *buf = calloc (len, 1);\n\tif (!buf || !min) {\n\t\tfree (buf);\n\t\treturn -1;\n\t}\n\tst64 vdelta = 0, pdelta = 0;\n\tRBinSection *s = NULL;\n\tbool ascii_only = false;\n\tPJ *pj = NULL;\n\tif (bf->strmode == R_MODE_JSON && !list) {\n\t\tpj = pj_new ();\n\t\tif (pj) {\n\t\t\tpj_a (pj);\n\t\t}\n\t}\n\tr_buf_read_at (bf->buf, from, buf, len);\n\tchar *charset = r_sys_getenv (\"RABIN2_CHARSET\");\n\tif (!R_STR_ISEMPTY (charset)) {\n\t\tRCharset *ch = r_charset_new ();\n\t\tif (r_charset_use (ch, charset)) {\n\t\t\tint outlen = len * 4;\n\t\t\tut8 *out = calloc (len, 4);\n\t\t\tif (out) {\n\t\t\t\tint res = r_charset_encode_str (ch, out, outlen, buf, len);\n\t\t\t\tint i;\n\t\t\t\t// TODO unknown chars should be translated to null bytes\n\t\t\t\tfor (i = 0; i < res; i++) {\n\t\t\t\t\tif (out[i] == '?') {\n\t\t\t\t\t\tout[i] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlen = res;\n\t\t\t\tfree (buf);\n\t\t\t\tbuf = out;\n\t\t\t} else {\n\t\t\t\teprintf (\"Cannot allocate\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Invalid value for RABIN2_CHARSET.\\n\");\n\t\t}\n\t\tr_charset_free (ch);\n\t}\n\tfree (charset);\n\tRConsIsBreaked is_breaked = (bin && bin->consb.is_breaked)? bin->consb.is_breaked: NULL;\n\t// may oobread\n\twhile (needle < to && needle < UT64_MAX - 4) {\n\t\tif (is_breaked && is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\t// smol optimization\n\t\tif (needle < to - 4) {\n\t\t\tut32 n1 = r_read_le32 (buf + (needle - from));\n\t\t\tif (!n1) {\n\t\t\t\tneedle += 4;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\trc = r_utf8_decode (buf + (needle - from), to - needle, NULL);\n\t\tif (!rc) {\n\t\t\tneedle++;\n\t\t\tcontinue;\n\t\t}\n\t\tbool addr_aligned = !(needle % 4);\n\n\t\tif (type == R_STRING_TYPE_DETECT) {\n\t\t\tchar *w = (char *)buf + (needle + rc - from);\n\t\t\tif (((to - needle) > 8 + rc)) {\n\t\t\t\t// TODO: support le and be\n\t\t\t\tbool is_wide32le = (needle + rc + 2 < to) && (!w[0] && !w[1] && !w[2] && w[3] && !w[4]);\n\t\t\t\t// reduce false positives\n\t\t\t\tif (is_wide32le) {\n\t\t\t\t\tif (!w[5] && !w[6] && w[7] && w[8]) {\n\t\t\t\t\t\tis_wide32le = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!addr_aligned) {\n\t\t\t\t\tis_wide32le = false;\n\t\t\t\t}\n\t\t\t\t///is_wide32be &= (n1 < 0xff && n11 < 0xff); // false; // n11 < 0xff;\n\t\t\t\tif (is_wide32le  && addr_aligned) {\n\t\t\t\t\tstr_type = R_STRING_TYPE_WIDE32; // asume big endian,is there little endian w32?\n\t\t\t\t} else {\n\t\t\t\t\t// bool is_wide = (n1 && n2 && n1 < 0xff && (!n2 || n2 < 0xff));\n\t\t\t\t\tbool is_wide = needle + rc + 4 < to && !w[0] && w[1] && !w[2] && w[3] && !w[4];\n\t\t\t\t\tstr_type = is_wide? R_STRING_TYPE_WIDE: R_STRING_TYPE_ASCII;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (rc > 1) {\n\t\t\t\t\tstr_type = R_STRING_TYPE_UTF8; // could be charset if set :?\n\t\t\t\t} else {\n\t\t\t\t\tstr_type = R_STRING_TYPE_ASCII;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (type == R_STRING_TYPE_UTF8) {\n\t\t\tstr_type = R_STRING_TYPE_ASCII; // initial assumption\n\t\t} else {\n\t\t\tstr_type = type;\n\t\t}\n\t\trunes = 0;\n\t\tstr_start = needle;\n\n\t\t/* Eat a whole C string */\n\t\tfor (i = 0; i < sizeof (tmp) - 4 && needle < to; i += rc) {\n\t\t\tRRune r = {0};\n\t\t\tif (str_type == R_STRING_TYPE_WIDE32) {\n\t\t\t\trc = r_utf32le_decode (buf + needle - from, to - needle, &r);\n\t\t\t\tif (rc) {\n\t\t\t\t\trc = 4;\n\t\t\t\t}\n\t\t\t} else if (str_type == R_STRING_TYPE_WIDE) {\n\t\t\t\trc = r_utf16le_decode (buf + needle - from, to - needle, &r);\n\t\t\t\tif (rc == 1) {\n\t\t\t\t\trc = 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trc = r_utf8_decode (buf + (needle - from), to - needle, &r);\n\t\t\t\tif (rc > 1) {\n\t\t\t\t\tstr_type = R_STRING_TYPE_UTF8;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Invalid sequence detected */\n\t\t\tif (!rc || (ascii_only && r > 0x7f)) {\n\t\t\t\tneedle++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tneedle += rc;\n\n\t\t\tif (r_isprint (r) && r != '\\\\') {\n\t\t\t\tif (str_type == R_STRING_TYPE_WIDE32) {\n\t\t\t\t\tif (r == 0xff) {\n\t\t\t\t\t\tr = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trc = r_utf8_encode (tmp + i, r);\n\t\t\t\trunes++;\n\t\t\t\t/* Print the escape code */\n\t\t\t} else if (r && r < 0x100 && strchr (\"\\b\\v\\f\\n\\r\\t\\a\\033\\\\\", (char)r)) {\n\t\t\t\tif ((i + 32) < sizeof (tmp) && r < 93) {\n\t\t\t\t\ttmp[i + 0] = '\\\\';\n\t\t\t\t\ttmp[i + 1] = \"       abtnvfr             e  \"\n\t\t\t\t\t             \"                              \"\n\t\t\t\t\t             \"                              \"\n\t\t\t\t\t             \"  \\\\\"[r];\n\t\t\t\t} else {\n\t\t\t\t\t// string too long\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\trc = 2;\n\t\t\t\trunes++;\n\t\t\t} else {\n\t\t\t\t/* \\0 marks the end of C-strings */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\ttmp[i++] = '\\0';\n\n\t\tif (runes < min && runes >= 2 && str_type == R_STRING_TYPE_ASCII && needle < to) {\n\t\t\t// back up past the \\0 to the last char just in case it starts a wide string\n\t\t\tneedle -= 2;\n\t\t}\n\t\tif (runes >= min) {\n\t\t\t// reduce false positives\n\t\t\tint j, num_blocks, *block_list;\n\t\t\tint *freq_list = NULL, expected_ascii, actual_ascii, num_chars;\n\t\t\tif (str_type == R_STRING_TYPE_ASCII) {\n\t\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\t\tchar ch = tmp[j];\n\t\t\t\t\tif (ch != '\\n' && ch != '\\r' && ch != '\\t') {\n\t\t\t\t\t\tif (!IS_PRINTABLE (tmp[j])) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch (str_type) {\n\t\t\tcase R_STRING_TYPE_UTF8:\n\t\t\tcase R_STRING_TYPE_WIDE:\n\t\t\tcase R_STRING_TYPE_WIDE32:\n\t\t\t\tnum_blocks = 0;\n\t\t\t\tblock_list = r_utf_block_list ((const ut8*)tmp, i - 1,\n\t\t\t\t\t\tstr_type == R_STRING_TYPE_WIDE? &freq_list: NULL);\n\t\t\t\tif (block_list) {\n\t\t\t\t\tfor (j = 0; block_list[j] != -1; j++) {\n\t\t\t\t\t\tnum_blocks++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (freq_list) {\n\t\t\t\t\tnum_chars = 0;\n\t\t\t\t\tactual_ascii = 0;\n\t\t\t\t\tfor (j = 0; freq_list[j] != -1; j++) {\n\t\t\t\t\t\tnum_chars += freq_list[j];\n\t\t\t\t\t\tif (!block_list[j]) { // ASCII\n\t\t\t\t\t\t\tactual_ascii = freq_list[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree (freq_list);\n\t\t\t\t\texpected_ascii = num_blocks ? num_chars / num_blocks : 0;\n\t\t\t\t\tif (actual_ascii > expected_ascii) {\n\t\t\t\t\t\tascii_only = true;\n\t\t\t\t\t\tneedle = str_start;\n\t\t\t\t\t\tfree (block_list);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (block_list);\n\t\t\t\tif (num_blocks > R_STRING_MAX_UNI_BLOCKS) {\n\t\t\t\t\tneedle++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tRBinString *bs = R_NEW0 (RBinString);\n\t\t\tif (!bs) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbs->type = str_type;\n\t\t\tbs->length = runes;\n\t\t\tbs->size = needle - str_start;\n\t\t\tbs->ordinal = count++;\n\t\t\t// TODO: move into adjust_offset\n\t\t\tswitch (str_type) {\n\t\t\tcase R_STRING_TYPE_WIDE:\n\t\t\t\tif (str_start - from > 1) {\n\t\t\t\t\tconst ut8 *p = buf + str_start - 2 - from;\n\t\t\t\t\tif (p[0] == 0xff && p[1] == 0xfe) {\n\t\t\t\t\t\tstr_start -= 2; // \\xff\\xfe\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_STRING_TYPE_WIDE32:\n\t\t\t\tif (str_start - from > 3) {\n\t\t\t\t\tconst ut8 *p = buf + str_start - 4 - from;\n\t\t\t\t\tif (p[0] == 0xff && p[1] == 0xfe) {\n\t\t\t\t\t\tstr_start -= 4; // \\xff\\xfe\\x00\\x00\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!s) {\n\t\t\t\tif (section) {\n\t\t\t\t\ts = section;\n\t\t\t\t} else if (bf->o) {\n\t\t\t\t\ts = r_bin_get_section_at (bf->o, str_start, false);\n\t\t\t\t}\n\t\t\t\tif (s) {\n\t\t\t\t\tvdelta = s->vaddr;\n\t\t\t\t\tpdelta = s->paddr;\n\t\t\t\t}\n\t\t\t}\n\t\t\tut64 baddr = bf->loadaddr && bf->o? bf->o->baddr: bf->loadaddr;\n\t\t\tbs->paddr = str_start + baddr;\n\t\t\tbs->vaddr = str_start - pdelta + vdelta + baddr;\n\t\t\tbs->string = r_str_ndup ((const char *)tmp, i);\n\t\t\tif (list) {\n\t\t\t\tr_list_append (list, bs);\n\t\t\t\tif (bf->o) {\n\t\t\t\t\tht_up_insert (bf->o->strings_db, bs->vaddr, bs);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprint_string (bf, bs, raw, pj);\n\t\t\t\tr_bin_string_free (bs);\n\t\t\t}\n\t\t\tif (from == 0 && to == bf->size) {\n\t\t\t\t/* force lookup section at the next one */\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t}\n\t\tascii_only = false;\n\t}\n\tfree (buf);\n\tif (pj) {\n\t\tpj_end (pj);\n\t\tif (bin) {\n\t\t\tRIO *io = bin->iob.io;\n\t\t\tif (io) {\n\t\t\t\tio->cb_printf (\"%s\", pj_string (pj));\n\t\t\t}\n\t\t}\n\t\tpj_free (pj);\n\t}\n\treturn count;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <r_bin.h>\n#include <r_hash.h>\n#include \"i/private.h\"\n\n// Type Definitions:\n// RBin:\ntypedef struct r_bin_t RBin;\n\n// RBinFile:\ntypedef struct r_bin_file_t {\n\tchar *file;\n\tint fd;\n\tut64 size;\n\tint rawstr;\n\tint strmode;\n\tut32 id;\n\tRBuffer *buf;\n\tut64 offset; // XXX\n\tRBinObject *o;\n\tvoid *xtr_obj;\n\tut64 loadaddr; // XXX\n\t/* values used when searching the strings */\n\tint minstrlen;\n\tint maxstrlen;\n\tint narch;\n\tstruct r_bin_xtr_plugin_t *curxtr;\n\t// struct r_bin_plugin_t *curplugin; // use o->plugin\n\tRList *xtr_data;\n\tSdb *sdb;\n// #warning RBinFile.sdb_info will be removed in r2-5.7.0\n\tSdb *sdb_info;\n\tSdb *sdb_addrinfo;\n\tstruct r_bin_t *rbin;\n} RBinFile;\n\n// RBinString:\ntypedef struct r_bin_string_t {\n\t// TODO: rename string->name (avoid colisions)\n\tchar *string;\n\tut64 vaddr;\n\tut64 paddr;\n\tut32 ordinal;\n\tut32 size; // size of buffer containing the string in bytes\n\tut32 length; // length of string in chars\n\tchar type; // Ascii Wide cp850 utf8 base64 ...\n} RBinString;\n\n// RBinSection:\ntypedef struct r_bin_section_t {\n\tchar *name;\n\tut64 size;\n\tut64 vsize;\n\tut64 vaddr;\n\tut64 paddr;\n\tut32 perm;\n\t// per section platform info\n\tconst char *arch;\n\tchar *format;\n\tint bits;\n\tbool has_strings;\n\tbool add; // indicates when you want to add the section to io `S` command\n\tbool is_data;\n\tbool is_segment;\n} RBinSection;\n\n// Called Methods (top 10):\n// r_bin_string_type from libr/bin/bin.c:\n\n\n// print_string from libr/bin/bfile.c:\n\n\n// r_bin_get_section_at from libr/bin/bin.c:\n\n\n// R_STRING_MAX_UNI_BLOCKS from libr/bin/bfile.c:\n\n\n// r_bin_get_vaddr from libr/bin/bin.c:\n\n\n// r_bin_file_get_vaddr from libr/bin/bfile.c:\n\n\n// r_bin_string_free from libr/bin/bin.c:\n\n\n// binobj_a2b from libr/bin/bin.c:\n\n"
  },
  {
    "repository": "linux",
    "cve_id": "CVE-2022-3103",
    "cwe_list": [
      "CWE-193"
    ],
    "commit_hash": "47abea041f897d64dbd5777f0cf7745148f85d75",
    "short_hash": "47abea04",
    "vulnerableMethods_before": [
      {
        "filename": "cancel.c",
        "method_name": "vulnerable_function",
        "raw_code": "static int __io_sync_cancel(struct io_uring_task *tctx,\n\t\t\t    struct io_cancel_data *cd, int fd)\n{\n\tstruct io_ring_ctx *ctx = cd->ctx;\n\n\t/* fixed must be grabbed every time since we drop the uring_lock */\n\tif ((cd->flags & IORING_ASYNC_CANCEL_FD) &&\n\t    (cd->flags & IORING_ASYNC_CANCEL_FD_FIXED)) {\n\t\tunsigned long file_ptr;\n\n\t\tif (unlikely(fd > ctx->nr_user_files))\n\t\t\treturn -EBADF;\n\t\tfd = array_index_nospec(fd, ctx->nr_user_files);\n\t\tfile_ptr = io_fixed_file_slot(&ctx->file_table, fd)->file_ptr;\n\t\tcd->file = (struct file *) (file_ptr & FFS_MASK);\n\t\tif (!cd->file)\n\t\t\treturn -EBADF;\n\t}\n\n\treturn __io_async_cancel(cd, tctx, 0);\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "cancel.c",
        "method_name": "fixed_function",
        "raw_code": "static int __io_sync_cancel(struct io_uring_task *tctx,\n\t\t\t    struct io_cancel_data *cd, int fd)\n{\n\tstruct io_ring_ctx *ctx = cd->ctx;\n\n\t/* fixed must be grabbed every time since we drop the uring_lock */\n\tif ((cd->flags & IORING_ASYNC_CANCEL_FD) &&\n\t    (cd->flags & IORING_ASYNC_CANCEL_FD_FIXED)) {\n\t\tunsigned long file_ptr;\n\n\t\tif (unlikely(fd >= ctx->nr_user_files))\n\t\t\treturn -EBADF;\n\t\tfd = array_index_nospec(fd, ctx->nr_user_files);\n\t\tfile_ptr = io_fixed_file_slot(&ctx->file_table, fd)->file_ptr;\n\t\tcd->file = (struct file *) (file_ptr & FFS_MASK);\n\t\tif (!cd->file)\n\t\t\treturn -EBADF;\n\t}\n\n\treturn __io_async_cancel(cd, tctx, 0);\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/io_uring.h>\n#include <linux/slab.h>\n#include <linux/nospec.h>\n#include \"tctx.h\"\n#include \"io_uring.h\"\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"timeout.h\"\n#include \"cancel.h\"\n#include <linux/fs.h>\n#include <uapi/linux/io_uring.h>\n#include \"poll.h\"\n#include <linux/file.h>\n\n// Called Methods (top 10):\n// io_async_cancel_one from io_uring/cancel.c:\n\n\n// __io_async_cancel from io_uring/cancel.c:\n\n\n// io_try_cancel from io_uring/cancel.c:\n\n"
  },
  {
    "repository": "linux",
    "cve_id": "CVE-2022-29968",
    "cwe_list": [
      "CWE-94"
    ],
    "commit_hash": "32452a3eb8b64e01e2be717f518c0be046975b9d",
    "short_hash": "32452a3e",
    "vulnerableMethods_before": [
      {
        "filename": "io_uring.c",
        "method_name": "vulnerable_function",
        "raw_code": "static int io_rw_init_file(struct io_kiocb *req, fmode_t mode)\n{\n\tstruct kiocb *kiocb = &req->rw.kiocb;\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct file *file = req->file;\n\tint ret;\n\n\tif (unlikely(!file || !(file->f_mode & mode)))\n\t\treturn -EBADF;\n\n\tif (!io_req_ffs_set(req))\n\t\treq->flags |= io_file_get_flags(file) << REQ_F_SUPPORT_NOWAIT_BIT;\n\n\tkiocb->ki_flags = iocb_flags(file);\n\tret = kiocb_set_rw_flags(kiocb, req->rw.flags);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\t/*\n\t * If the file is marked O_NONBLOCK, still allow retry for it if it\n\t * supports async. Otherwise it's impossible to use O_NONBLOCK files\n\t * reliably. If not, or it IOCB_NOWAIT is set, don't retry.\n\t */\n\tif ((kiocb->ki_flags & IOCB_NOWAIT) ||\n\t    ((file->f_flags & O_NONBLOCK) && !io_file_supports_nowait(req)))\n\t\treq->flags |= REQ_F_NOWAIT;\n\n\tif (ctx->flags & IORING_SETUP_IOPOLL) {\n\t\tif (!(kiocb->ki_flags & IOCB_DIRECT) || !file->f_op->iopoll)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tkiocb->ki_flags |= IOCB_HIPRI | IOCB_ALLOC_CACHE;\n\t\tkiocb->ki_complete = io_complete_rw_iopoll;\n\t\treq->iopoll_completed = 0;\n\t} else {\n\t\tif (kiocb->ki_flags & IOCB_HIPRI)\n\t\t\treturn -EINVAL;\n\t\tkiocb->ki_complete = io_complete_rw;\n\t}\n\n\treturn 0;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "io_uring.c",
        "method_name": "fixed_function",
        "raw_code": "static int io_rw_init_file(struct io_kiocb *req, fmode_t mode)\n{\n\tstruct kiocb *kiocb = &req->rw.kiocb;\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct file *file = req->file;\n\tint ret;\n\n\tif (unlikely(!file || !(file->f_mode & mode)))\n\t\treturn -EBADF;\n\n\tif (!io_req_ffs_set(req))\n\t\treq->flags |= io_file_get_flags(file) << REQ_F_SUPPORT_NOWAIT_BIT;\n\n\tkiocb->ki_flags = iocb_flags(file);\n\tret = kiocb_set_rw_flags(kiocb, req->rw.flags);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\t/*\n\t * If the file is marked O_NONBLOCK, still allow retry for it if it\n\t * supports async. Otherwise it's impossible to use O_NONBLOCK files\n\t * reliably. If not, or it IOCB_NOWAIT is set, don't retry.\n\t */\n\tif ((kiocb->ki_flags & IOCB_NOWAIT) ||\n\t    ((file->f_flags & O_NONBLOCK) && !io_file_supports_nowait(req)))\n\t\treq->flags |= REQ_F_NOWAIT;\n\n\tif (ctx->flags & IORING_SETUP_IOPOLL) {\n\t\tif (!(kiocb->ki_flags & IOCB_DIRECT) || !file->f_op->iopoll)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tkiocb->private = NULL;\n\t\tkiocb->ki_flags |= IOCB_HIPRI | IOCB_ALLOC_CACHE;\n\t\tkiocb->ki_complete = io_complete_rw_iopoll;\n\t\treq->iopoll_completed = 0;\n\t} else {\n\t\tif (kiocb->ki_flags & IOCB_HIPRI)\n\t\t\treturn -EINVAL;\n\t\tkiocb->ki_complete = io_complete_rw;\n\t}\n\n\treturn 0;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"io-wq.h\"\n#include <net/scm.h>\n#include <linux/nospec.h>\n#include <linux/fsnotify.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/anon_inodes.h>\n#include <linux/highmem.h>\n#include <linux/sched/mm.h>\n#include <linux/splice.h>\n#include <linux/bits.h>\n#include <linux/init.h>\n#include <linux/uaccess.h>\n#include <linux/hugetlb.h>\n#include <linux/sched/signal.h>\n#include <linux/blk-mq.h>\n#include <linux/uio.h>\n#include <linux/compat.h>\n#include <linux/eventpoll.h>\n#include <linux/task_work.h>\n#include <linux/security.h>\n#include <linux/audit.h>\n#include <net/sock.h>\n#include <linux/sizes.h>\n#include <linux/mm.h>\n#include <linux/io_uring.h>\n#include <trace/events/io_uring.h>\n#include <net/compat.h>\n#include <linux/refcount.h>\n#include <uapi/linux/io_uring.h>\n#include <linux/file.h>\n#include <linux/net.h>\n#include <linux/namei.h>\n#include <linux/bvec.h>\n#include <linux/fadvise.h>\n#include <linux/percpu.h>\n#include <linux/slab.h>\n#include <net/af_unix.h>\n#include <linux/fdtable.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include \"internal.h\"\n\n// Type Definitions:\n// io_kiocb:\nstruct io_kiocb\n\n// file:\nstruct file\n\n// io_ring_ctx:\nstruct io_ring_ctx\n\n// kiocb:\nstruct kiocb\n\n// Called Methods (top 10):\n// __io_file_supports_nowait from fs/io_uring.c:\nstatic bool __io_file_supports_nowait(struct file *file, umode_t mode) /* <=== __io_file_supports_nowait */ \n{\n\tif (S_ISBLK(mode)) {\n\t\tif (IS_ENABLED(CONFIG_BLOCK) &&\n\t\t    io_bdev_nowait(I_BDEV(file->f_mapping->host)))\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tif (S_ISSOCK(mode))\n\t\treturn true;\n\tif (S_ISREG(mode)) {\n\t\tif (IS_ENABLED(CONFIG_BLOCK) &&\n\t\t    io_bdev_nowait(file->f_inode->i_sb->s_bdev) &&\n\t\t    file->f_op != &io_uring_fops)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\t/* any ->read/write should understand O_NONBLOCK */\n\tif (file->f_flags & O_NONBLOCK)\n\t\treturn true;\n\treturn file->f_mode & FMODE_NOWAIT;\n}\n\n// FFS_ISREG from fs/io_uring.c:\n#define FFS_ISREG\t\t0x2UL /* <=== fs/io_uring.c:1603:1603:FFS_ISREG:0 */ \n\n// io_file_get_flags from fs/io_uring.c:\nstatic unsigned int io_file_get_flags(struct file *file) /* <=== io_file_get_flags */ \n{\n\tumode_t mode = file_inode(file)->i_mode;\n\tunsigned int res = 0;\n\n\tif (S_ISREG(mode))\n\t\tres |= FFS_ISREG;\n\tif (__io_file_supports_nowait(file, mode))\n\t\tres |= FFS_NOWAIT;\n\treturn res;\n}\n\n// io_req_ffs_set from fs/io_uring.c:\nstatic inline bool io_req_ffs_set(struct io_kiocb *req) /* <=== io_req_ffs_set */ \n{\n\treturn req->flags & REQ_F_FIXED_FILE;\n}\n\n// io_file_supports_nowait from fs/io_uring.c:\nstatic inline bool io_file_supports_nowait(struct io_kiocb *req) /* <=== io_file_supports_nowait */ \n{\n\treturn req->flags & REQ_F_SUPPORT_NOWAIT;\n}\n\n// io_bdev_nowait from fs/io_uring.c:\nstatic bool io_bdev_nowait(struct block_device *bdev) /* <=== io_bdev_nowait */ \n{\n\treturn !bdev || blk_queue_nowait(bdev_get_queue(bdev));\n}\n\n// FFS_NOWAIT from fs/io_uring.c:\n#define FFS_NOWAIT\t\t0x1UL /* <=== fs/io_uring.c:1602:1602:FFS_NOWAIT:0 */ \n"
  },
  {
    "repository": "linux",
    "cve_id": "CVE-2021-3739",
    "cwe_list": [
      "CWE-703"
    ],
    "commit_hash": "e4571b8c5e9ffa1e85c0c671995bd4dcc5c75091",
    "short_hash": "e4571b8c",
    "vulnerableMethods_before": [
      {
        "filename": "volumes.c",
        "method_name": "vulnerable_function",
        "raw_code": "int btrfs_rm_device(struct btrfs_fs_info *fs_info, const char *device_path,\n\t\t    u64 devid)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *cur_devices;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tu64 num_devices;\n\tint ret = 0;\n\n\tmutex_lock(&uuid_mutex);\n\n\tnum_devices = btrfs_num_devices(fs_info);\n\n\tret = btrfs_check_raid_min_devices(fs_info, num_devices - 1);\n\tif (ret)\n\t\tgoto out;\n\n\tdevice = btrfs_find_device_by_devspec(fs_info, devid, device_path);\n\n\tif (IS_ERR(device)) {\n\t\tif (PTR_ERR(device) == -ENOENT &&\n\t\t    strcmp(device_path, \"missing\") == 0)\n\t\t\tret = BTRFS_ERROR_DEV_MISSING_NOT_FOUND;\n\t\telse\n\t\t\tret = PTR_ERR(device);\n\t\tgoto out;\n\t}\n\n\tif (btrfs_pinned_by_swapfile(fs_info, device)) {\n\t\tbtrfs_warn_in_rcu(fs_info,\n\t\t  \"cannot remove device %s (devid %llu) due to active swapfile\",\n\t\t\t\t  rcu_str_deref(device->name), device->devid);\n\t\tret = -ETXTBSY;\n\t\tgoto out;\n\t}\n\n\tif (test_bit(BTRFS_DEV_STATE_REPLACE_TGT, &device->dev_state)) {\n\t\tret = BTRFS_ERROR_DEV_TGT_REPLACE;\n\t\tgoto out;\n\t}\n\n\tif (test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state) &&\n\t    fs_info->fs_devices->rw_devices == 1) {\n\t\tret = BTRFS_ERROR_DEV_ONLY_WRITABLE;\n\t\tgoto out;\n\t}\n\n\tif (test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state)) {\n\t\tmutex_lock(&fs_info->chunk_mutex);\n\t\tlist_del_init(&device->dev_alloc_list);\n\t\tdevice->fs_devices->rw_devices--;\n\t\tmutex_unlock(&fs_info->chunk_mutex);\n\t}\n\n\tmutex_unlock(&uuid_mutex);\n\tret = btrfs_shrink_device(device, 0);\n\tif (!ret)\n\t\tbtrfs_reada_remove_dev(device);\n\tmutex_lock(&uuid_mutex);\n\tif (ret)\n\t\tgoto error_undo;\n\n\t/*\n\t * TODO: the superblock still includes this device in its num_devices\n\t * counter although write_all_supers() is not locked out. This\n\t * could give a filesystem state which requires a degraded mount.\n\t */\n\tret = btrfs_rm_dev_item(device);\n\tif (ret)\n\t\tgoto error_undo;\n\n\tclear_bit(BTRFS_DEV_STATE_IN_FS_METADATA, &device->dev_state);\n\tbtrfs_scrub_cancel_dev(device);\n\n\t/*\n\t * the device list mutex makes sure that we don't change\n\t * the device list while someone else is writing out all\n\t * the device supers. Whoever is writing all supers, should\n\t * lock the device list mutex before getting the number of\n\t * devices in the super block (super_copy). Conversely,\n\t * whoever updates the number of devices in the super block\n\t * (super_copy) should hold the device list mutex.\n\t */\n\n\t/*\n\t * In normal cases the cur_devices == fs_devices. But in case\n\t * of deleting a seed device, the cur_devices should point to\n\t * its own fs_devices listed under the fs_devices->seed.\n\t */\n\tcur_devices = device->fs_devices;\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tlist_del_rcu(&device->dev_list);\n\n\tcur_devices->num_devices--;\n\tcur_devices->total_devices--;\n\t/* Update total_devices of the parent fs_devices if it's seed */\n\tif (cur_devices != fs_devices)\n\t\tfs_devices->total_devices--;\n\n\tif (test_bit(BTRFS_DEV_STATE_MISSING, &device->dev_state))\n\t\tcur_devices->missing_devices--;\n\n\tbtrfs_assign_next_active_device(device, NULL);\n\n\tif (device->bdev) {\n\t\tcur_devices->open_devices--;\n\t\t/* remove sysfs entry */\n\t\tbtrfs_sysfs_remove_device(device);\n\t}\n\n\tnum_devices = btrfs_super_num_devices(fs_info->super_copy) - 1;\n\tbtrfs_set_super_num_devices(fs_info->super_copy, num_devices);\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\t/*\n\t * at this point, the device is zero sized and detached from\n\t * the devices list.  All that's left is to zero out the old\n\t * supers and free the device.\n\t */\n\tif (test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state))\n\t\tbtrfs_scratch_superblocks(fs_info, device->bdev,\n\t\t\t\t\t  device->name->str);\n\n\tbtrfs_close_bdev(device);\n\tsynchronize_rcu();\n\tbtrfs_free_device(device);\n\n\tif (cur_devices->open_devices == 0) {\n\t\tlist_del_init(&cur_devices->seed_list);\n\t\tclose_fs_devices(cur_devices);\n\t\tfree_fs_devices(cur_devices);\n\t}\n\nout:\n\tmutex_unlock(&uuid_mutex);\n\treturn ret;\n\nerror_undo:\n\tbtrfs_reada_undo_remove_dev(device);\n\tif (test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state)) {\n\t\tmutex_lock(&fs_info->chunk_mutex);\n\t\tlist_add(&device->dev_alloc_list,\n\t\t\t &fs_devices->alloc_list);\n\t\tdevice->fs_devices->rw_devices++;\n\t\tmutex_unlock(&fs_info->chunk_mutex);\n\t}\n\tgoto out;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "volumes.c",
        "method_name": "fixed_function",
        "raw_code": "int btrfs_rm_device(struct btrfs_fs_info *fs_info, const char *device_path,\n\t\t    u64 devid)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *cur_devices;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tu64 num_devices;\n\tint ret = 0;\n\n\tmutex_lock(&uuid_mutex);\n\n\tnum_devices = btrfs_num_devices(fs_info);\n\n\tret = btrfs_check_raid_min_devices(fs_info, num_devices - 1);\n\tif (ret)\n\t\tgoto out;\n\n\tdevice = btrfs_find_device_by_devspec(fs_info, devid, device_path);\n\n\tif (IS_ERR(device)) {\n\t\tif (PTR_ERR(device) == -ENOENT &&\n\t\t    device_path && strcmp(device_path, \"missing\") == 0)\n\t\t\tret = BTRFS_ERROR_DEV_MISSING_NOT_FOUND;\n\t\telse\n\t\t\tret = PTR_ERR(device);\n\t\tgoto out;\n\t}\n\n\tif (btrfs_pinned_by_swapfile(fs_info, device)) {\n\t\tbtrfs_warn_in_rcu(fs_info,\n\t\t  \"cannot remove device %s (devid %llu) due to active swapfile\",\n\t\t\t\t  rcu_str_deref(device->name), device->devid);\n\t\tret = -ETXTBSY;\n\t\tgoto out;\n\t}\n\n\tif (test_bit(BTRFS_DEV_STATE_REPLACE_TGT, &device->dev_state)) {\n\t\tret = BTRFS_ERROR_DEV_TGT_REPLACE;\n\t\tgoto out;\n\t}\n\n\tif (test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state) &&\n\t    fs_info->fs_devices->rw_devices == 1) {\n\t\tret = BTRFS_ERROR_DEV_ONLY_WRITABLE;\n\t\tgoto out;\n\t}\n\n\tif (test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state)) {\n\t\tmutex_lock(&fs_info->chunk_mutex);\n\t\tlist_del_init(&device->dev_alloc_list);\n\t\tdevice->fs_devices->rw_devices--;\n\t\tmutex_unlock(&fs_info->chunk_mutex);\n\t}\n\n\tmutex_unlock(&uuid_mutex);\n\tret = btrfs_shrink_device(device, 0);\n\tif (!ret)\n\t\tbtrfs_reada_remove_dev(device);\n\tmutex_lock(&uuid_mutex);\n\tif (ret)\n\t\tgoto error_undo;\n\n\t/*\n\t * TODO: the superblock still includes this device in its num_devices\n\t * counter although write_all_supers() is not locked out. This\n\t * could give a filesystem state which requires a degraded mount.\n\t */\n\tret = btrfs_rm_dev_item(device);\n\tif (ret)\n\t\tgoto error_undo;\n\n\tclear_bit(BTRFS_DEV_STATE_IN_FS_METADATA, &device->dev_state);\n\tbtrfs_scrub_cancel_dev(device);\n\n\t/*\n\t * the device list mutex makes sure that we don't change\n\t * the device list while someone else is writing out all\n\t * the device supers. Whoever is writing all supers, should\n\t * lock the device list mutex before getting the number of\n\t * devices in the super block (super_copy). Conversely,\n\t * whoever updates the number of devices in the super block\n\t * (super_copy) should hold the device list mutex.\n\t */\n\n\t/*\n\t * In normal cases the cur_devices == fs_devices. But in case\n\t * of deleting a seed device, the cur_devices should point to\n\t * its own fs_devices listed under the fs_devices->seed.\n\t */\n\tcur_devices = device->fs_devices;\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tlist_del_rcu(&device->dev_list);\n\n\tcur_devices->num_devices--;\n\tcur_devices->total_devices--;\n\t/* Update total_devices of the parent fs_devices if it's seed */\n\tif (cur_devices != fs_devices)\n\t\tfs_devices->total_devices--;\n\n\tif (test_bit(BTRFS_DEV_STATE_MISSING, &device->dev_state))\n\t\tcur_devices->missing_devices--;\n\n\tbtrfs_assign_next_active_device(device, NULL);\n\n\tif (device->bdev) {\n\t\tcur_devices->open_devices--;\n\t\t/* remove sysfs entry */\n\t\tbtrfs_sysfs_remove_device(device);\n\t}\n\n\tnum_devices = btrfs_super_num_devices(fs_info->super_copy) - 1;\n\tbtrfs_set_super_num_devices(fs_info->super_copy, num_devices);\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\t/*\n\t * at this point, the device is zero sized and detached from\n\t * the devices list.  All that's left is to zero out the old\n\t * supers and free the device.\n\t */\n\tif (test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state))\n\t\tbtrfs_scratch_superblocks(fs_info, device->bdev,\n\t\t\t\t\t  device->name->str);\n\n\tbtrfs_close_bdev(device);\n\tsynchronize_rcu();\n\tbtrfs_free_device(device);\n\n\tif (cur_devices->open_devices == 0) {\n\t\tlist_del_init(&cur_devices->seed_list);\n\t\tclose_fs_devices(cur_devices);\n\t\tfree_fs_devices(cur_devices);\n\t}\n\nout:\n\tmutex_unlock(&uuid_mutex);\n\treturn ret;\n\nerror_undo:\n\tbtrfs_reada_undo_remove_dev(device);\n\tif (test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state)) {\n\t\tmutex_lock(&fs_info->chunk_mutex);\n\t\tlist_add(&device->dev_alloc_list,\n\t\t\t &fs_devices->alloc_list);\n\t\tdevice->fs_devices->rw_devices++;\n\t\tmutex_unlock(&fs_info->chunk_mutex);\n\t}\n\tgoto out;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"rcu-string.h\"\n#include <linux/sched.h>\n#include \"async-thread.h\"\n#include <linux/sched/mm.h>\n#include \"dev-replace.h\"\n#include \"block-group.h\"\n#include <linux/uuid.h>\n#include \"ctree.h\"\n#include \"zoned.h\"\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include \"extent_map.h\"\n#include \"space-info.h\"\n#include <linux/ratelimit.h>\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include <linux/kthread.h>\n#include \"volumes.h\"\n#include \"sysfs.h\"\n#include <linux/list_sort.h>\n#include \"raid56.h\"\n#include <linux/semaphore.h>\n#include \"misc.h\"\n#include \"discard.h\"\n#include <linux/raid/pq.h>\n#include \"check-integrity.h\"\n#include <linux/slab.h>\n#include \"print-tree.h\"\n#include \"tree-checker.h\"\n\n// Type Definitions:\n// btrfs_device:\nstruct btrfs_device {\n\tstruct list_head dev_list; /* device_list_mutex */\n\tstruct list_head dev_alloc_list; /* chunk mutex */\n\tstruct list_head post_commit_list; /* chunk mutex */\n\tstruct btrfs_fs_devices *fs_devices;\n\tstruct btrfs_fs_info *fs_info;\n\n\tstruct rcu_string __rcu *name;\n\n\tu64 generation;\n\n\tstruct block_device *bdev;\n\n\tstruct btrfs_zoned_device_info *zone_info;\n\n\t/* the mode sent to blkdev_get */\n\tfmode_t mode;\n\n\tunsigned long dev_state;\n\tblk_status_t last_flush_error;\n\n#ifdef __BTRFS_NEED_DEVICE_DATA_ORDERED\n\tseqcount_t data_seqcount;\n#endif\n\n\t/* the internal btrfs device id */\n\tu64 devid;\n\n\t/* size of the device in memory */\n\tu64 total_bytes;\n\n\t/* size of the device on disk */\n\tu64 disk_total_bytes;\n\n\t/* bytes used */\n\tu64 bytes_used;\n\n\t/* optimal io alignment for this device */\n\tu32 io_align;\n\n\t/* optimal io width for this device */\n\tu32 io_width;\n\t/* type and info about this device */\n\tu64 type;\n\n\t/* minimal io size for this device */\n\tu32 sector_size;\n\n\t/* physical d...\n\n// btrfs_device:\nstruct btrfs_device\n\n// btrfs_fs_info:\nstruct btrfs_fs_info\n\n// Called Methods (top 10):\n// btrfs_get_bdev_and_sb from fs/btrfs/volumes.c:\nstatic int /* <=== btrfs_get_bdev_and_sb */ \nbtrfs_get_bdev_and_sb(const char *device_path, fmode_t flags, void *holder,\n\t\t      int flush, struct block_device **bdev,\n\t\t      struct btrfs_super_block **disk_super)\n{\n\tint ret;\n\n\t*bdev = blkdev_get_by_path(device_path, flags, holder);\n\n\tif (IS_ERR(*bdev)) {\n\t\tret = PTR_ERR(*bdev);\n\t\tgoto error;\n\t}\n\n\tif (flush)\n\t\tfilemap_write_and_wait((*bdev)->bd_inode->i_mapping);\n\tret = set_blocksize(*bdev, BTRFS_BDEV_BLOCKSIZE);\n\tif (ret) {\n\t\tblkdev_put(*bdev, flags);\n\t\tgoto error;\n\t}\n\tinvalidate_bdev(*bdev);\n\t*disk_super = btrfs_read_dev_super(*bdev);\n\tif (IS_ERR(*disk_super)) {\n\t\tret = PTR_ERR(*disk_super);\n\t\tblkdev_put(*bdev, flags);\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\t*bdev = NULL;\n\treturn ret;\n}\n\n// BTRFS_DEV_STATE_IN_FS_METADATA from fs/btrfs/volumes.h:\n#define BTRFS_DEV_STATE_IN_FS_METADATA\t(1) /* <=== fs/btrfs/volumes.h:49:49:BTRFS_DEV_STATE_IN_FS_METADATA:0 */ \n\n// btrfs_stack_device_id from fs/btrfs/ctree.h:\nBTRFS_SETGET_STACK_FUNCS(stack_device_id, struct btrfs_dev_item, devid, 64); /* <=== btrfs_stack_device_id */ \n\n// btrfs_fs_incompat from fs/btrfs/ctree.h:\n#define btrfs_fs_incompat(fs_info, opt) \\ /* <=== fs/btrfs/ctree.h:3634:3635:btrfs_fs_incompat:2 */ \n\t__btrfs_fs_incompat((fs_info), BTRFS_FEATURE_INCOMPAT_##opt)\n\n// btrfs_find_device_by_path from fs/btrfs/volumes.c:\nstatic struct btrfs_device *btrfs_find_device_by_path( /* <=== btrfs_find_device_by_path */ \n\t\tstruct btrfs_fs_info *fs_info, const char *device_path)\n{\n\tint ret = 0;\n\tstruct btrfs_super_block *disk_super;\n\tu64 devid;\n\tu8 *dev_uuid;\n\tstruct block_device *bdev;\n\tstruct btrfs_device *device;\n\n\tret = btrfs_get_bdev_and_sb(device_path, FMODE_READ,\n\t\t\t\t    fs_info->bdev_holder, 0, &bdev, &disk_super);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tdevid = btrfs_stack_device_id(&disk_super->dev_item);\n\tdev_uuid = disk_super->dev_item.uuid;\n\tif (btrfs_fs_incompat(fs_info, METADATA_UUID))\n\t\tdevice = btrfs_find_device(fs_info->fs_devices, devid, dev_uuid,\n\t\t\t\t\t   disk_super->metadata_uuid);\n\telse\n\t\tdevice = btrfs_find_device(fs_info->fs_devices, devid, dev_uuid,\n\t\t\t\t\t   disk_super->fsid);\n\n\tbtrfs_release_disk_super(disk_super);\n\tif (!device)\n\t\tdevice = ERR_PTR(-ENOENT);\n\tblkdev_put(bdev, FMODE_READ);\n\treturn device;\n}\n\n// btrfs_release_disk_super from fs/btrfs/volumes.c:\nvoid btrfs_release_disk_super(struct btrfs_super_block *super) /* <=== btrfs_release_disk_super */ \n{\n\tstruct page *page = virt_to_page(super);\n\n\tput_page(page);\n}\n\n// btrfs_find_device from fs/btrfs/volumes.c:\nstruct btrfs_device *btrfs_find_device(struct btrfs_fs_devices *fs_devices, /* <=== btrfs_find_device */ \n\t\t\t\t       u64 devid, u8 *uuid, u8 *fsid)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *seed_devs;\n\n\tif (!fsid || !memcmp(fs_devices->metadata_uuid, fsid, BTRFS_FSID_SIZE)) {\n\t\tlist_for_each_entry(device, &fs_devices->devices, dev_list) {\n\t\t\tif (device->devid == devid &&\n\t\t\t    (!uuid || memcmp(device->uuid, uuid,\n\t\t\t\t\t     BTRFS_UUID_SIZE) == 0))\n\t\t\t\treturn device;\n\t\t}\n\t}\n\n\tlist_for_each_entry(seed_devs, &fs_devices->seed_list, seed_list) {\n\t\tif (!fsid ||\n\t\t    !memcmp(seed_devs->metadata_uuid, fsid, BTRFS_FSID_SIZE)) {\n\t\t\tlist_for_each_entry(device, &seed_devs->devices,\n\t\t\t\t\t    dev_list) {\n\t\t\t\tif (device->devid == devid &&\n\t\t\t\t    (!uuid || memcmp(device->uuid, uuid,\n\t\t\t\t\t\t     BTRFS_UUID_SIZE) == 0))\n\t\t\t\t\treturn device;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n// btrfs_find_device_by_devspec from fs/btrfs/volumes.c:\nstruct btrfs_device *btrfs_find_device_by_devspec( /* <=== btrfs_find_device_by_devspec */ \n\t\tstruct btrfs_fs_info *fs_info, u64 devid,\n\t\tconst char *device_path)\n{\n\tstruct btrfs_device *device;\n\n\tif (devid) {\n\t\tdevice = btrfs_find_device(fs_info->fs_devices, devid, NULL,\n\t\t\t\t\t   NULL);\n\t\tif (!device)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t\treturn device;\n\t}\n\n\tif (!device_path || !device_path[0])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (strcmp(device_path, \"missing\") == 0) {\n\t\t/* Find first missing device */\n\t\tlist_for_each_entry(device, &fs_info->fs_devices->devices,\n\t\t\t\t    dev_list) {\n\t\t\tif (test_bit(BTRFS_DEV_STATE_IN_FS_METADATA,\n\t\t\t\t     &device->dev_state) && !device->bdev)\n\t\t\t\treturn device;\n\t\t}\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\treturn btrfs_find_device_by_path(fs_info, device_path);\n}\n\n// __btrfs_fs_incompat from fs/btrfs/ctree.h:\nstatic inline bool __btrfs_fs_incompat(struct btrfs_fs_info *fs_info, u64 flag) /* <=== __btrfs_fs_incompat */ \n{\n\tstruct btrfs_super_block *disk_super;\n\tdisk_super = fs_info->super_copy;\n\treturn !!(btrfs_super_incompat_flags(disk_super) & flag);\n}\n"
  },
  {
    "repository": "gimp",
    "cve_id": "CVE-2017-17784",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "c57f9dcf1934a9ab0cd67650f2dea18cb0902270",
    "short_hash": "c57f9dcf",
    "vulnerableMethods_before": [
      {
        "filename": "file-gbr.c",
        "method_name": "vulnerable_function",
        "raw_code": "load_image (const gchar  *filename,\n            GError      **error)\n{\n  gchar             *name;\n  gint               fd;\n  BrushHeader        bh;\n  guchar            *brush_buf = NULL;\n  gint32             image_ID;\n  gint32             layer_ID;\n  GimpParasite      *parasite;\n  GimpDrawable      *drawable;\n  GimpPixelRgn       pixel_rgn;\n  gint               bn_size;\n  GimpImageBaseType  base_type;\n  GimpImageType      image_type;\n  gsize              size;\n\n  fd = g_open (filename, O_RDONLY | _O_BINARY, 0);\n\n  if (fd == -1)\n    {\n      g_set_error (error, G_FILE_ERROR, g_file_error_from_errno (errno),\n                   _(\"Could not open '%s' for reading: %s\"),\n                   gimp_filename_to_utf8 (filename), g_strerror (errno));\n      return -1;\n    }\n\n  gimp_progress_init_printf (_(\"Opening '%s'\"),\n                             gimp_filename_to_utf8 (filename));\n\n  if (read (fd, &bh, sizeof (BrushHeader)) != sizeof (BrushHeader))\n    {\n      close (fd);\n      return -1;\n    }\n\n  /*  rearrange the bytes in each unsigned int  */\n  bh.header_size  = g_ntohl (bh.header_size);\n  bh.version      = g_ntohl (bh.version);\n  bh.width        = g_ntohl (bh.width);\n  bh.height       = g_ntohl (bh.height);\n  bh.bytes        = g_ntohl (bh.bytes);\n  bh.magic_number = g_ntohl (bh.magic_number);\n  bh.spacing      = g_ntohl (bh.spacing);\n\n  /* Sanitize values */\n  if ((bh.width == 0) || (bh.width > GIMP_MAX_IMAGE_SIZE) ||\n      (bh.height == 0) || (bh.height > GIMP_MAX_IMAGE_SIZE) ||\n      ((bh.bytes != 1) && (bh.bytes != 2) && (bh.bytes != 4) &&\n       (bh.bytes != 18)) ||\n      (G_MAXSIZE / bh.width / bh.height / bh.bytes < 1))\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"Invalid header data in '%s': width=%lu, height=%lu, \"\n                     \"bytes=%lu\"), gimp_filename_to_utf8 (filename),\n                   (unsigned long int)bh.width, (unsigned long int)bh.height,\n                   (unsigned long int)bh.bytes);\n      return -1;\n    }\n\n  switch (bh.version)\n    {\n    case 1:\n      /* Version 1 didn't have a magic number and had no spacing  */\n      bh.spacing = 25;\n      /* And we need to rewind the handle, 4 due spacing and 4 due magic */\n      lseek (fd, -8, SEEK_CUR);\n      bh.header_size += 8;\n      break;\n\n    case 3: /*  cinepaint brush  */\n      if (bh.bytes == 18 /* FLOAT16_GRAY_GIMAGE */)\n        {\n          bh.bytes = 2;\n        }\n      else\n        {\n          g_message (_(\"Unsupported brush format\"));\n          close (fd);\n          return -1;\n        }\n      /*  fallthrough  */\n\n    case 2:\n      if (bh.magic_number == GBRUSH_MAGIC &&\n          bh.header_size  >  sizeof (BrushHeader))\n        break;\n\n    default:\n      g_message (_(\"Unsupported brush format\"));\n      close (fd);\n      return -1;\n    }\n\n  if ((bn_size = (bh.header_size - sizeof (BrushHeader))) > 0)\n    {\n      gchar *temp = g_new (gchar, bn_size);\n\n      if ((read (fd, temp, bn_size)) < bn_size)\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"Error in GIMP brush file '%s'\"),\n                       gimp_filename_to_utf8 (filename));\n          close (fd);\n          g_free (temp);\n          return -1;\n        }\n\n      name = gimp_any_to_utf8 (temp, -1,\n                               _(\"Invalid UTF-8 string in brush file '%s'.\"),\n                               gimp_filename_to_utf8 (filename));\n      g_free (temp);\n    }\n  else\n    {\n      name = g_strdup (_(\"Unnamed\"));\n    }\n\n  /* Now there's just raw data left. */\n\n  size = bh.width * bh.height * bh.bytes;\n  brush_buf = g_malloc (size);\n\n  if (read (fd, brush_buf, size) != size)\n    {\n      close (fd);\n      g_free (brush_buf);\n      g_free (name);\n      return -1;\n    }\n\n  switch (bh.bytes)\n    {\n    case 1:\n      {\n        PatternHeader ph;\n\n        /*  For backwards-compatibility, check if a pattern follows.\n            The obsolete .gpb format did it this way.  */\n\n        if (read (fd, &ph, sizeof (PatternHeader)) == sizeof(PatternHeader))\n          {\n            /*  rearrange the bytes in each unsigned int  */\n            ph.header_size  = g_ntohl (ph.header_size);\n            ph.version      = g_ntohl (ph.version);\n            ph.width        = g_ntohl (ph.width);\n            ph.height       = g_ntohl (ph.height);\n            ph.bytes        = g_ntohl (ph.bytes);\n            ph.magic_number = g_ntohl (ph.magic_number);\n\n            if (ph.magic_number == GPATTERN_MAGIC        &&\n                ph.version      == 1                     &&\n                ph.header_size  > sizeof (PatternHeader) &&\n                ph.bytes        == 3                     &&\n                ph.width        == bh.width              &&\n                ph.height       == bh.height             &&\n                lseek (fd, ph.header_size - sizeof (PatternHeader),\n                       SEEK_CUR) > 0)\n              {\n                guchar *plain_brush = brush_buf;\n                gint    i;\n\n                bh.bytes = 4;\n                brush_buf = g_malloc (4 * bh.width * bh.height);\n\n                for (i = 0; i < ph.width * ph.height; i++)\n                  {\n                    if (read (fd, brush_buf + i * 4, 3) != 3)\n                      {\n                        close (fd);\n                        g_free (name);\n                        g_free (plain_brush);\n                        g_free (brush_buf);\n                        return -1;\n                      }\n                    brush_buf[i * 4 + 3] = plain_brush[i];\n                  }\n                g_free (plain_brush);\n              }\n          }\n      }\n      break;\n\n    case 2:\n      {\n        guint16 *buf = (guint16 *) brush_buf;\n        gint     i;\n\n        for (i = 0; i < bh.width * bh.height; i++, buf++)\n          {\n            union\n            {\n              guint16 u[2];\n              gfloat  f;\n            } short_float;\n\n#if G_BYTE_ORDER == G_LITTLE_ENDIAN\n            short_float.u[0] = 0;\n            short_float.u[1] = GUINT16_FROM_BE (*buf);\n#else\n            short_float.u[0] = GUINT16_FROM_BE (*buf);\n            short_float.u[1] = 0;\n#endif\n\n            brush_buf[i] = (guchar) (short_float.f * 255.0 + 0.5);\n          }\n\n        bh.bytes = 1;\n      }\n      break;\n\n    default:\n      break;\n    }\n\n  /*\n   * Create a new image of the proper size and\n   * associate the filename with it.\n   */\n\n  switch (bh.bytes)\n    {\n    case 1:\n      base_type = GIMP_GRAY;\n      image_type = GIMP_GRAY_IMAGE;\n      break;\n\n    case 4:\n      base_type = GIMP_RGB;\n      image_type = GIMP_RGBA_IMAGE;\n      break;\n\n    default:\n      g_message (\"Unsupported brush depth: %d\\n\"\n                 \"GIMP Brushes must be GRAY or RGBA\\n\",\n                 bh.bytes);\n      g_free (name);\n      return -1;\n    }\n\n  image_ID = gimp_image_new (bh.width, bh.height, base_type);\n  gimp_image_set_filename (image_ID, filename);\n\n  parasite = gimp_parasite_new (\"gimp-brush-name\",\n                                GIMP_PARASITE_PERSISTENT,\n                                strlen (name) + 1, name);\n  gimp_image_attach_parasite (image_ID, parasite);\n  gimp_parasite_free (parasite);\n\n  layer_ID = gimp_layer_new (image_ID, name, bh.width, bh.height,\n                             image_type, 100, GIMP_NORMAL_MODE);\n  gimp_image_insert_layer (image_ID, layer_ID, -1, 0);\n\n  g_free (name);\n\n  drawable = gimp_drawable_get (layer_ID);\n  gimp_pixel_rgn_init (&pixel_rgn, drawable,\n                       0, 0, drawable->width, drawable->height,\n                       TRUE, FALSE);\n\n  gimp_pixel_rgn_set_rect (&pixel_rgn, brush_buf,\n                           0, 0, bh.width, bh.height);\n  g_free (brush_buf);\n\n  if (image_type == GIMP_GRAY_IMAGE)\n    gimp_invert (layer_ID);\n\n  close (fd);\n\n  gimp_drawable_flush (drawable);\n  gimp_progress_update (1.0);\n\n  return image_ID;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "file-gbr.c",
        "method_name": "fixed_function",
        "raw_code": "load_image (const gchar  *filename,\n            GError      **error)\n{\n  gchar             *name;\n  gint               fd;\n  BrushHeader        bh;\n  guchar            *brush_buf = NULL;\n  gint32             image_ID;\n  gint32             layer_ID;\n  GimpParasite      *parasite;\n  GimpDrawable      *drawable;\n  GimpPixelRgn       pixel_rgn;\n  gint               bn_size;\n  GimpImageBaseType  base_type;\n  GimpImageType      image_type;\n  gsize              size;\n\n  fd = g_open (filename, O_RDONLY | _O_BINARY, 0);\n\n  if (fd == -1)\n    {\n      g_set_error (error, G_FILE_ERROR, g_file_error_from_errno (errno),\n                   _(\"Could not open '%s' for reading: %s\"),\n                   gimp_filename_to_utf8 (filename), g_strerror (errno));\n      return -1;\n    }\n\n  gimp_progress_init_printf (_(\"Opening '%s'\"),\n                             gimp_filename_to_utf8 (filename));\n\n  if (read (fd, &bh, sizeof (BrushHeader)) != sizeof (BrushHeader))\n    {\n      close (fd);\n      return -1;\n    }\n\n  /*  rearrange the bytes in each unsigned int  */\n  bh.header_size  = g_ntohl (bh.header_size);\n  bh.version      = g_ntohl (bh.version);\n  bh.width        = g_ntohl (bh.width);\n  bh.height       = g_ntohl (bh.height);\n  bh.bytes        = g_ntohl (bh.bytes);\n  bh.magic_number = g_ntohl (bh.magic_number);\n  bh.spacing      = g_ntohl (bh.spacing);\n\n  /* Sanitize values */\n  if ((bh.width == 0) || (bh.width > GIMP_MAX_IMAGE_SIZE) ||\n      (bh.height == 0) || (bh.height > GIMP_MAX_IMAGE_SIZE) ||\n      ((bh.bytes != 1) && (bh.bytes != 2) && (bh.bytes != 4) &&\n       (bh.bytes != 18)) ||\n      (G_MAXSIZE / bh.width / bh.height / bh.bytes < 1))\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"Invalid header data in '%s': width=%lu, height=%lu, \"\n                     \"bytes=%lu\"), gimp_filename_to_utf8 (filename),\n                   (unsigned long int)bh.width, (unsigned long int)bh.height,\n                   (unsigned long int)bh.bytes);\n      return -1;\n    }\n\n  switch (bh.version)\n    {\n    case 1:\n      /* Version 1 didn't have a magic number and had no spacing  */\n      bh.spacing = 25;\n      /* And we need to rewind the handle, 4 due spacing and 4 due magic */\n      lseek (fd, -8, SEEK_CUR);\n      bh.header_size += 8;\n      break;\n\n    case 3: /*  cinepaint brush  */\n      if (bh.bytes == 18 /* FLOAT16_GRAY_GIMAGE */)\n        {\n          bh.bytes = 2;\n        }\n      else\n        {\n          g_message (_(\"Unsupported brush format\"));\n          close (fd);\n          return -1;\n        }\n      /*  fallthrough  */\n\n    case 2:\n      if (bh.magic_number == GBRUSH_MAGIC &&\n          bh.header_size  >  sizeof (BrushHeader))\n        break;\n\n    default:\n      g_message (_(\"Unsupported brush format\"));\n      close (fd);\n      return -1;\n    }\n\n  if ((bn_size = (bh.header_size - sizeof (BrushHeader))) > 0)\n    {\n      gchar *temp = g_new (gchar, bn_size);\n\n      if ((read (fd, temp, bn_size)) < bn_size ||\n          temp[bn_size - 1] != '\\0')\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"Error in GIMP brush file '%s'\"),\n                       gimp_filename_to_utf8 (filename));\n          close (fd);\n          g_free (temp);\n          return -1;\n        }\n\n      name = gimp_any_to_utf8 (temp, -1,\n                               _(\"Invalid UTF-8 string in brush file '%s'.\"),\n                               gimp_filename_to_utf8 (filename));\n      g_free (temp);\n    }\n  else\n    {\n      name = g_strdup (_(\"Unnamed\"));\n    }\n\n  /* Now there's just raw data left. */\n\n  size = bh.width * bh.height * bh.bytes;\n  brush_buf = g_malloc (size);\n\n  if (read (fd, brush_buf, size) != size)\n    {\n      close (fd);\n      g_free (brush_buf);\n      g_free (name);\n      return -1;\n    }\n\n  switch (bh.bytes)\n    {\n    case 1:\n      {\n        PatternHeader ph;\n\n        /*  For backwards-compatibility, check if a pattern follows.\n            The obsolete .gpb format did it this way.  */\n\n        if (read (fd, &ph, sizeof (PatternHeader)) == sizeof(PatternHeader))\n          {\n            /*  rearrange the bytes in each unsigned int  */\n            ph.header_size  = g_ntohl (ph.header_size);\n            ph.version      = g_ntohl (ph.version);\n            ph.width        = g_ntohl (ph.width);\n            ph.height       = g_ntohl (ph.height);\n            ph.bytes        = g_ntohl (ph.bytes);\n            ph.magic_number = g_ntohl (ph.magic_number);\n\n            if (ph.magic_number == GPATTERN_MAGIC        &&\n                ph.version      == 1                     &&\n                ph.header_size  > sizeof (PatternHeader) &&\n                ph.bytes        == 3                     &&\n                ph.width        == bh.width              &&\n                ph.height       == bh.height             &&\n                lseek (fd, ph.header_size - sizeof (PatternHeader),\n                       SEEK_CUR) > 0)\n              {\n                guchar *plain_brush = brush_buf;\n                gint    i;\n\n                bh.bytes = 4;\n                brush_buf = g_malloc (4 * bh.width * bh.height);\n\n                for (i = 0; i < ph.width * ph.height; i++)\n                  {\n                    if (read (fd, brush_buf + i * 4, 3) != 3)\n                      {\n                        close (fd);\n                        g_free (name);\n                        g_free (plain_brush);\n                        g_free (brush_buf);\n                        return -1;\n                      }\n                    brush_buf[i * 4 + 3] = plain_brush[i];\n                  }\n                g_free (plain_brush);\n              }\n          }\n      }\n      break;\n\n    case 2:\n      {\n        guint16 *buf = (guint16 *) brush_buf;\n        gint     i;\n\n        for (i = 0; i < bh.width * bh.height; i++, buf++)\n          {\n            union\n            {\n              guint16 u[2];\n              gfloat  f;\n            } short_float;\n\n#if G_BYTE_ORDER == G_LITTLE_ENDIAN\n            short_float.u[0] = 0;\n            short_float.u[1] = GUINT16_FROM_BE (*buf);\n#else\n            short_float.u[0] = GUINT16_FROM_BE (*buf);\n            short_float.u[1] = 0;\n#endif\n\n            brush_buf[i] = (guchar) (short_float.f * 255.0 + 0.5);\n          }\n\n        bh.bytes = 1;\n      }\n      break;\n\n    default:\n      break;\n    }\n\n  /*\n   * Create a new image of the proper size and\n   * associate the filename with it.\n   */\n\n  switch (bh.bytes)\n    {\n    case 1:\n      base_type = GIMP_GRAY;\n      image_type = GIMP_GRAY_IMAGE;\n      break;\n\n    case 4:\n      base_type = GIMP_RGB;\n      image_type = GIMP_RGBA_IMAGE;\n      break;\n\n    default:\n      g_message (\"Unsupported brush depth: %d\\n\"\n                 \"GIMP Brushes must be GRAY or RGBA\\n\",\n                 bh.bytes);\n      g_free (name);\n      return -1;\n    }\n\n  image_ID = gimp_image_new (bh.width, bh.height, base_type);\n  gimp_image_set_filename (image_ID, filename);\n\n  parasite = gimp_parasite_new (\"gimp-brush-name\",\n                                GIMP_PARASITE_PERSISTENT,\n                                strlen (name) + 1, name);\n  gimp_image_attach_parasite (image_ID, parasite);\n  gimp_parasite_free (parasite);\n\n  layer_ID = gimp_layer_new (image_ID, name, bh.width, bh.height,\n                             image_type, 100, GIMP_NORMAL_MODE);\n  gimp_image_insert_layer (image_ID, layer_ID, -1, 0);\n\n  g_free (name);\n\n  drawable = gimp_drawable_get (layer_ID);\n  gimp_pixel_rgn_init (&pixel_rgn, drawable,\n                       0, 0, drawable->width, drawable->height,\n                       TRUE, FALSE);\n\n  gimp_pixel_rgn_set_rect (&pixel_rgn, brush_buf,\n                           0, 0, bh.width, bh.height);\n  g_free (brush_buf);\n\n  if (image_type == GIMP_GRAY_IMAGE)\n    gimp_invert (layer_ID);\n\n  close (fd);\n\n  gimp_drawable_flush (drawable);\n  gimp_progress_update (1.0);\n\n  return image_ID;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <glib/gstdio.h>\n#include <fcntl.h>\n#include <libgimp/gimp.h>\n#include <libgimp/gimpui.h>\n#include <string.h>\n#include <glib.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"app/core/gimppattern-header.h\"\n#include \"libgimp/stdplugins-intl.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"config.h\"\n#include <io.h>\n#include \"app/core/gimpbrush-header.h\"\n\n// Called Methods (top 10):\n// _O_BINARY from plug-ins/common/file-gbr.c:\n<empty>\n"
  },
  {
    "repository": "v4l2loopback",
    "cve_id": "CVE-2022-2652",
    "cwe_list": [
      "CWE-134"
    ],
    "commit_hash": "e4cd225557486c420f6a34411f98c575effd43dd",
    "short_hash": "e4cd2255",
    "vulnerableMethods_before": [
      {
        "filename": "v4l2loopback.c",
        "method_name": "vulnerable_function",
        "raw_code": "static int vidioc_querycap(struct file *file, void *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n\tint labellen = (sizeof(cap->card) < sizeof(dev->card_label)) ?\n\t\t\t       sizeof(cap->card) :\n\t\t\t\t     sizeof(dev->card_label);\n\tint device_nr =\n\t\t((struct v4l2loopback_private *)video_get_drvdata(dev->vdev))\n\t\t\t->device_nr;\n\t__u32 capabilities = V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;\n\n\tstrlcpy(cap->driver, \"v4l2 loopback\", sizeof(cap->driver));\n\tsnprintf(cap->card, labellen, dev->card_label);\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info),\n\t\t \"platform:v4l2loopback-%03d\", device_nr);\n\n#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 1, 0)\n\t/* since 3.1.0, the v4l2-core system is supposed to set the version */\n\tcap->version = V4L2LOOPBACK_VERSION_CODE;\n#endif\n\n#ifdef V4L2_CAP_VIDEO_M2M\n\tcapabilities |= V4L2_CAP_VIDEO_M2M;\n#endif /* V4L2_CAP_VIDEO_M2M */\n\n\tif (dev->announce_all_caps) {\n\t\tcapabilities |= V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_OUTPUT;\n\t} else {\n\t\tif (dev->ready_for_capture) {\n\t\t\tcapabilities |= V4L2_CAP_VIDEO_CAPTURE;\n\t\t}\n\t\tif (dev->ready_for_output) {\n\t\t\tcapabilities |= V4L2_CAP_VIDEO_OUTPUT;\n\t\t}\n\t}\n\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)\n\tdev->vdev->device_caps =\n#endif /* >=linux-4.7.0 */\n\t\tcap->device_caps = cap->capabilities = capabilities;\n\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0)\n\tcap->capabilities |= V4L2_CAP_DEVICE_CAPS;\n#endif\n\n\tmemset(cap->reserved, 0, sizeof(cap->reserved));\n\treturn 0;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "v4l2loopback.c",
        "method_name": "fixed_function",
        "raw_code": "static int vidioc_querycap(struct file *file, void *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n\tint labellen = (sizeof(cap->card) < sizeof(dev->card_label)) ?\n\t\t\t       sizeof(cap->card) :\n\t\t\t\t     sizeof(dev->card_label);\n\tint device_nr =\n\t\t((struct v4l2loopback_private *)video_get_drvdata(dev->vdev))\n\t\t\t->device_nr;\n\t__u32 capabilities = V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;\n\n\tstrlcpy(cap->driver, \"v4l2 loopback\", sizeof(cap->driver));\n\tsnprintf(cap->card, labellen, \"%s\", dev->card_label);\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info),\n\t\t \"platform:v4l2loopback-%03d\", device_nr);\n\n#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 1, 0)\n\t/* since 3.1.0, the v4l2-core system is supposed to set the version */\n\tcap->version = V4L2LOOPBACK_VERSION_CODE;\n#endif\n\n#ifdef V4L2_CAP_VIDEO_M2M\n\tcapabilities |= V4L2_CAP_VIDEO_M2M;\n#endif /* V4L2_CAP_VIDEO_M2M */\n\n\tif (dev->announce_all_caps) {\n\t\tcapabilities |= V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_OUTPUT;\n\t} else {\n\t\tif (dev->ready_for_capture) {\n\t\t\tcapabilities |= V4L2_CAP_VIDEO_CAPTURE;\n\t\t}\n\t\tif (dev->ready_for_output) {\n\t\t\tcapabilities |= V4L2_CAP_VIDEO_OUTPUT;\n\t\t}\n\t}\n\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)\n\tdev->vdev->device_caps =\n#endif /* >=linux-4.7.0 */\n\t\tcap->device_caps = cap->capabilities = capabilities;\n\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0)\n\tcap->capabilities |= V4L2_CAP_DEVICE_CAPS;\n#endif\n\n\tmemset(cap->reserved, 0, sizeof(cap->reserved));\n\treturn 0;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <linux/eventpoll.h>\n#include <linux/sched.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-ctrls.h>\n#include <linux/module.h>\n#include <linux/miscdevice.h>\n#include <media/v4l2-common.h>\n#include <linux/version.h>\n#include <linux/fs.h>\n#include <media/v4l2-event.h>\n#include <linux/slab.h>\n#include \"v4l2loopback.h\"\n#include <media/v4l2-device.h>\n#include \"v4l2loopback_formats.h\"\n#include <linux/videodev2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n\n// Type Definitions:\n// v4l2_ctrl_handler:\nstruct v4l2_ctrl_handler {\n\tint error;\n}\n\n// v4l2loopback_private:\nstruct v4l2loopback_private {\n\tint device_nr;\n}\n\n// v4l2_loopback_config:\nstruct v4l2_loopback_config {\n\t/**\n         * the device-number (/dev/video<nr>)\n         * V4L2LOOPBACK_CTL_ADD:\n         * setting this to a value<0, will allocate an available one\n         * if nr>=0 and the device already exists, the ioctl will EEXIST\n         * if output_nr and capture_nr are the same, only a single device will be created\n         *\n         * V4L2LOOPBACK_CTL_QUERY:\n         * either both output_nr and capture_nr must refer to the same loopback,\n         * or one (and only one) of them must be -1\n         *\n         */\n\tint output_nr;\n\tint capture_nr;\n\n\t/**\n         * a nice name for your device\n         * if (*card_label)==0, an automatic name is assigned\n         */\n\tchar card_label[32];\n\n\t/**\n         * maximum allowed frame size\n         * if too low, default values are used\n         */\n\tint max_width;\n\tint max_height;\n\n\t/**\n         * whether to announce OUTPUT/CAPTURE capabilities exclusively\n         * for this device or not\n         * (!exclusive_caps)...\n\n// v4l2_loopback_device:\nstruct v4l2_loopback_device {\n\tstruct v4l2_device v4l2_dev;\n\tstruct v4l2_ctrl_handler ctrl_handler;\n\tstruct video_device *vdev;\n\t/* pixel and stream format */\n\tstruct v4l2_pix_format pix_format;\n\tstruct v4l2_captureparm capture_param;\n\tunsigned long frame_jiffies;\n\n\t/* ctrls */\n\tint keep_format; /* CID_KEEP_FORMAT; stay ready_for_capture even when all\n\t\t\t    openers close() the device */\n\tint sustain_framerate; /* CID_SUSTAIN_FRAMERATE; duplicate frames to maintain\n\t\t\t\t  (close to) nominal framerate */\n\n\t/* buffers stuff */\n\tu8 *image; /* pointer to actual buffers data */\n\tunsigned long int imagesize; /* size of buffers data */\n\tint buffers_number; /* should not be big, 4 is a good choice */\n\tstruct v4l2l_buffer buffers[MAX_BUFFERS]; /* inner driver buffers */\n\tint used_buffers; /* number of the actually used buffers */\n\tint max_openers; /* how many times can this device be opened */\n\n\tint write_position; /* number of last written frame + 1 */\n\tstruct list_head outbufs_list; /* buff...\n\n// v4l2_ctrl_config:\nstruct v4l2_ctrl_config {\n\tvoid *ops;\n\tu32 id;\n\tconst char *name;\n\tint type;\n\ts32 min;\n\ts32 max;\n\tu32 step;\n\ts32 def;\n}\n\n// Called Methods (top 10):\n// v4l2_ctrl_handler_free from v4l2loopback.c:\nvoid v4l2_ctrl_handler_free(struct v4l2_ctrl_handler *hdl) /* <=== v4l2_ctrl_handler_free */ \n{\n}\n\n// MAX_BUFFERS from v4l2loopback.c:\n#define MAX_BUFFERS 32 /* <=== v4l2loopback.c:207:207:MAX_BUFFERS:0 */ \n\n// DEFAULT_FROM_CONF from v4l2loopback.c:\n#define DEFAULT_FROM_CONF(confmember, default_condition, default_value)        \\ /* <=== v4l2loopback.c:2393:2397:DEFAULT_FROM_CONF:3 */ \n\t((conf) ?                                                              \\\n\t\t ((conf->confmember default_condition) ? (default_value) :     \\\n\t\t\t\t\t\t\t       (conf->confmember)) : \\\n\t\t       default_value)\n\n// dprintk from v4l2loopback.c:\n#define dprintk(fmt, args...)                                                  \\ /* <=== v4l2loopback.c:73:80:dprintk:2 */ \n\tdo {                                                                   \\\n\t\tif (debug > 0) {                                               \\\n\t\t\tprintk(KERN_INFO \"v4l2-loopback[\" STRINGIFY2(          \\\n\t\t\t\t       __LINE__) \"]: \" fmt,                    \\\n\t\t\t       ##args);                                        \\\n\t\t}                                                              \\\n\t} while (0)\n\n// v4l2l_get_timestamp from v4l2loopback.c:\nstatic inline void v4l2l_get_timestamp(struct v4l2_buffer *b) /* <=== v4l2l_get_timestamp */ \n{\n\t/* ktime_get_ts is considered deprecated, so use ktime_get_ts64 if possible */\n#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 17, 0)\n\tstruct timespec ts;\n\tktime_get_ts(&ts);\n#else\n\tstruct timespec64 ts;\n\tktime_get_ts64(&ts);\n#endif\n\n\tb->timestamp.tv_sec = ts.tv_sec;\n\tb->timestamp.tv_usec = (ts.tv_nsec / NSEC_PER_USEC);\n}\n\n// MARK from v4l2loopback.c:\n#define MARK()                                                                 \\ /* <=== v4l2loopback.c:82:88:MARK:0 */ \n\tdo {                                                                   \\\n\t\tif (debug > 1) {                                               \\\n\t\t\tprintk(KERN_INFO \"%s:%d[%s]\\n\", __FILE__, __LINE__,    \\\n\t\t\t       __func__);                                      \\\n\t\t}                                                              \\\n\t} while (0)\n\n// v4l2_device_unregister from v4l2loopback.c:\nstatic inline void v4l2_device_unregister(struct v4l2_device *v4l2_dev) /* <=== v4l2_device_unregister */ \n{\n\treturn;\n}\n\n// init_vdev from v4l2loopback.c:\nstatic void init_vdev(struct video_device *vdev, int nr) /* <=== init_vdev */ \n{\n\tMARK();\n\n#ifdef V4L2LOOPBACK_WITH_STD\n\tvdev->tvnorms = V4L2_STD_ALL;\n#endif /* V4L2LOOPBACK_WITH_STD */\n\n\tvdev->vfl_type = VFL_TYPE_VIDEO;\n\tvdev->fops = &v4l2_loopback_fops;\n\tvdev->ioctl_ops = &v4l2_loopback_ioctl_ops;\n\tvdev->release = &video_device_release;\n\tvdev->minor = -1;\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)\n\tvdev->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_OUTPUT |\n\t\t\t    V4L2_CAP_READWRITE | V4L2_CAP_STREAMING;\n#ifdef V4L2_CAP_VIDEO_M2M\n\tvdev->device_caps |= V4L2_CAP_VIDEO_M2M;\n#endif\n#endif /* >=linux-4.7.0 */\n\n\tif (debug > 1)\n#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 20, 0)\n\t\tvdev->debug = V4L2_DEBUG_IOCTL | V4L2_DEBUG_IOCTL_ARG;\n#else\n\t\tvdev->dev_debug =\n\t\t\tV4L2_DEV_DEBUG_IOCTL | V4L2_DEV_DEBUG_IOCTL_ARG;\n#endif\n\n\t\t/* since kernel-3.7, there is a new field 'vfl_dir' that has to be\n\t * set to VFL_DIR_M2M for bidirectional devices */\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 7, 0)\n\tvdev->vfl_dir = VFL_DIR_M2M;\n#endif\n\n\tMARK();\n}\n\n// V4L2_SYSFS_CREATE from v4l2loopback.c:\n#define V4L2_SYSFS_CREATE(x)                                                   \\ /* <=== v4l2loopback.c:641:644:V4L2_SYSFS_CREATE:1 */ \n\tres = device_create_file(&vdev->dev, &dev_attr_##x);                   \\\n\tif (res < 0)                                                           \\\n\tbreak\n\n// free_buffers from v4l2loopback.c:\nstatic void free_buffers(struct v4l2_loopback_device *dev) /* <=== free_buffers */ \n{\n\tMARK();\n\tdprintk(\"freeing image@%p for dev:%p\\n\", dev ? dev->image : NULL, dev);\n\tif (dev->image) {\n\t\tvfree(dev->image);\n\t\tdev->image = NULL;\n\t}\n\tif (dev->timeout_image) {\n\t\tvfree(dev->timeout_image);\n\t\tdev->timeout_image = NULL;\n\t}\n\tdev->imagesize = 0;\n}\n"
  },
  {
    "repository": "mruby",
    "cve_id": "CVE-2022-1276",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "c8c083cb750606b2da81582cd8e43b442bb143e6",
    "short_hash": "c8c083cb",
    "vulnerableMethods_before": [
      {
        "filename": "codegen.c",
        "method_name": "vulnerable_function",
        "raw_code": "gen_assignment(codegen_scope *s, node *tree, node *rhs, int sp, int val)\n{\n  int idx;\n  int type = nint(tree->car);\n\n  switch (type) {\n  case NODE_GVAR:\n  case NODE_ARG:\n  case NODE_LVAR:\n  case NODE_IVAR:\n  case NODE_CVAR:\n  case NODE_CONST:\n  case NODE_NIL:\n  case NODE_MASGN:\n    if (rhs) {\n      codegen(s, rhs, VAL);\n      pop();\n      sp = cursp();\n    }\n    break;\n\n  case NODE_COLON2:\n  case NODE_CALL:\n  case NODE_SCALL:\n    /* keep evaluation order */\n    break;\n\n  case NODE_NVAR:\n    codegen_error(s, \"Can't assign to numbered parameter\");\n    break;\n\n  default:\n    codegen_error(s, \"unknown lhs\");\n    break;\n  }\n\n  tree = tree->cdr;\n  switch (type) {\n  case NODE_GVAR:\n    gen_setxv(s, OP_SETGV, sp, nsym(tree), val);\n    break;\n  case NODE_ARG:\n  case NODE_LVAR:\n    idx = lv_idx(s, nsym(tree));\n    if (idx > 0) {\n      if (idx != sp) {\n        gen_move(s, idx, sp, val);\n      }\n      break;\n    }\n    else {                      /* upvar */\n      gen_setupvar(s, sp, nsym(tree));\n    }\n    break;\n  case NODE_IVAR:\n    gen_setxv(s, OP_SETIV, sp, nsym(tree), val);\n    break;\n  case NODE_CVAR:\n    gen_setxv(s, OP_SETCV, sp, nsym(tree), val);\n    break;\n  case NODE_CONST:\n    gen_setxv(s, OP_SETCONST, sp, nsym(tree), val);\n    break;\n  case NODE_COLON2:\n    if (sp) {\n      gen_move(s, cursp(), sp, 0);\n    }\n    sp = cursp();\n    push();\n    codegen(s, tree->car, VAL);\n    if (rhs) {\n      codegen(s, rhs, VAL); pop();\n      gen_move(s, sp, cursp(), 0);\n    }\n    pop_n(2);\n    idx = new_sym(s, nsym(tree->cdr));\n    genop_2(s, OP_SETMCNST, sp, idx);\n    break;\n\n  case NODE_CALL:\n  case NODE_SCALL:\n    {\n      int noself = 0, safe = (type == NODE_SCALL), skip = 0, top, call, n = 0;\n      mrb_sym mid = nsym(tree->cdr->car);\n\n      top = cursp();\n      if (val || sp == cursp()) {\n        push();                   /* room for retval */\n      }\n      call = cursp();\n      if (!tree->car) {\n        noself = 1;\n        push();\n      }\n      else {\n        codegen(s, tree->car, VAL); /* receiver */\n      }\n      if (safe) {\n        int recv = cursp()-1;\n        gen_move(s, cursp(), recv, 1);\n        skip = genjmp2_0(s, OP_JMPNIL, cursp(), val);\n      }\n      tree = tree->cdr->cdr->car;\n      if (tree) {\n        if (tree->car) {            /* positional arguments */\n          n = gen_values(s, tree->car, VAL, (tree->cdr->car)?13:14);\n          if (n < 0) {              /* variable length */\n            n = 15;\n            push();\n          }\n        }\n        if (tree->cdr->car) {       /* keyword arguments */\n          if (n == 14) {\n            pop_n(n);\n            genop_2(s, OP_ARRAY, cursp(), n);\n            push();\n            n = 15;\n          }\n          gen_hash(s, tree->cdr->car->cdr, VAL, 0);\n          if (n < 14) {\n            n++;\n          }\n          else {\n            pop_n(2);\n            genop_2(s, OP_ARYPUSH, cursp(), 1);\n          }\n          push();\n        }\n      }\n      if (rhs) {\n        codegen(s, rhs, VAL);\n        pop();\n      }\n      else {\n        gen_move(s, cursp(), sp, 0);\n      }\n      if (val) {\n        gen_move(s, top, cursp(), 1);\n      }\n      if (n < 15) {\n        n++;\n        if (n == 15) {\n          pop_n(14);\n          genop_2(s, OP_ARRAY, cursp(), 15);\n        }\n      }\n      else {\n        pop();\n        genop_2(s, OP_ARYPUSH, cursp(), 1);\n      }\n      s->sp = call;\n      if (mid == MRB_OPSYM_2(s->mrb, aref) && n == 2) {\n        genop_1(s, OP_SETIDX, cursp());\n      }\n      else {\n        genop_3(s, noself ? OP_SSEND : OP_SEND, cursp(), new_sym(s, attrsym(s, mid)), n);\n      }\n      if (safe) {\n        dispatch(s, skip);\n      }\n      s->sp = top;\n    }\n    break;\n\n  case NODE_MASGN:\n    gen_massignment(s, tree->car, sp, val);\n    break;\n\n  /* splat without assignment */\n  case NODE_NIL:\n    break;\n\n  default:\n    codegen_error(s, \"unknown lhs\");\n    break;\n  }\n  if (val) push();\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "codegen.c",
        "method_name": "fixed_function",
        "raw_code": "gen_assignment(codegen_scope *s, node *tree, node *rhs, int sp, int val)\n{\n  int idx;\n  int type = nint(tree->car);\n\n  switch (type) {\n  case NODE_GVAR:\n  case NODE_ARG:\n  case NODE_LVAR:\n  case NODE_IVAR:\n  case NODE_CVAR:\n  case NODE_CONST:\n  case NODE_NIL:\n  case NODE_MASGN:\n    if (rhs) {\n      codegen(s, rhs, VAL);\n      pop();\n      sp = cursp();\n    }\n    break;\n\n  case NODE_COLON2:\n  case NODE_CALL:\n  case NODE_SCALL:\n    /* keep evaluation order */\n    break;\n\n  case NODE_NVAR:\n    codegen_error(s, \"Can't assign to numbered parameter\");\n    break;\n\n  default:\n    codegen_error(s, \"unknown lhs\");\n    break;\n  }\n\n  tree = tree->cdr;\n  switch (type) {\n  case NODE_GVAR:\n    gen_setxv(s, OP_SETGV, sp, nsym(tree), val);\n    break;\n  case NODE_ARG:\n  case NODE_LVAR:\n    idx = lv_idx(s, nsym(tree));\n    if (idx > 0) {\n      if (idx != sp) {\n        gen_move(s, idx, sp, val);\n      }\n      break;\n    }\n    else {                      /* upvar */\n      gen_setupvar(s, sp, nsym(tree));\n    }\n    break;\n  case NODE_IVAR:\n    gen_setxv(s, OP_SETIV, sp, nsym(tree), val);\n    break;\n  case NODE_CVAR:\n    gen_setxv(s, OP_SETCV, sp, nsym(tree), val);\n    break;\n  case NODE_CONST:\n    gen_setxv(s, OP_SETCONST, sp, nsym(tree), val);\n    break;\n  case NODE_COLON2:\n    if (sp) {\n      gen_move(s, cursp(), sp, 0);\n    }\n    sp = cursp();\n    push();\n    codegen(s, tree->car, VAL);\n    if (rhs) {\n      codegen(s, rhs, VAL); pop();\n      gen_move(s, sp, cursp(), 0);\n    }\n    pop_n(2);\n    idx = new_sym(s, nsym(tree->cdr));\n    genop_2(s, OP_SETMCNST, sp, idx);\n    break;\n\n  case NODE_CALL:\n  case NODE_SCALL:\n    {\n      int noself = 0, safe = (type == NODE_SCALL), skip = 0, top, call, n = 0;\n      mrb_sym mid = nsym(tree->cdr->car);\n\n      top = cursp();\n      if (val || sp == cursp()) {\n        push();                   /* room for retval */\n      }\n      call = cursp();\n      if (!tree->car) {\n        noself = 1;\n        push();\n      }\n      else {\n        codegen(s, tree->car, VAL); /* receiver */\n      }\n      if (safe) {\n        int recv = cursp()-1;\n        gen_move(s, cursp(), recv, 1);\n        skip = genjmp2_0(s, OP_JMPNIL, cursp(), val);\n      }\n      tree = tree->cdr->cdr->car;\n      if (tree) {\n        if (tree->car) {            /* positional arguments */\n          n = gen_values(s, tree->car, VAL, (tree->cdr->car)?13:14);\n          if (n < 0) {              /* variable length */\n            n = 15;\n            push();\n          }\n        }\n        if (tree->cdr->car) {       /* keyword arguments */\n          if (n == 13 || n == 14) {\n            pop_n(n);\n            genop_2(s, OP_ARRAY, cursp(), n);\n            push();\n            n = 15;\n          }\n          gen_hash(s, tree->cdr->car->cdr, VAL, 0);\n          if (n < 14) {\n            n++;\n          }\n          else {\n            pop_n(2);\n            genop_2(s, OP_ARYPUSH, cursp(), 1);\n          }\n          push();\n        }\n      }\n      if (rhs) {\n        codegen(s, rhs, VAL);\n        pop();\n      }\n      else {\n        gen_move(s, cursp(), sp, 0);\n      }\n      if (val) {\n        gen_move(s, top, cursp(), 1);\n      }\n      if (n < 15) {\n        n++;\n        if (n == 15) {\n          pop_n(14);\n          genop_2(s, OP_ARRAY, cursp(), 15);\n        }\n      }\n      else {\n        pop();\n        genop_2(s, OP_ARYPUSH, cursp(), 1);\n      }\n      s->sp = call;\n      if (mid == MRB_OPSYM_2(s->mrb, aref) && n == 2) {\n        genop_1(s, OP_SETIDX, cursp());\n      }\n      else {\n        genop_3(s, noself ? OP_SSEND : OP_SEND, cursp(), new_sym(s, attrsym(s, mid)), n);\n      }\n      if (safe) {\n        dispatch(s, skip);\n      }\n      s->sp = top;\n    }\n    break;\n\n  case NODE_MASGN:\n    gen_massignment(s, tree->car, sp, val);\n    break;\n\n  /* splat without assignment */\n  case NODE_NIL:\n    break;\n\n  default:\n    codegen_error(s, \"unknown lhs\");\n    break;\n  }\n  if (val) push();\n}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "linux",
    "cve_id": "CVE-2022-0322",
    "cwe_list": [
      "CWE-704"
    ],
    "commit_hash": "a2d859e3fc97e79d907761550dbc03ff1b36479c",
    "short_hash": "a2d859e3",
    "vulnerableMethods_before": [
      {
        "filename": "sm_make_chunk.c",
        "method_name": "vulnerable_function",
        "raw_code": "struct sctp_chunk *sctp_make_strreset_req(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\t__u16 stream_num, __be16 *stream_list,\n\t\t\t\t\tbool out, bool in)\n{\n\t__u16 stream_len = stream_num * sizeof(__u16);\n\tstruct sctp_strreset_outreq outreq;\n\tstruct sctp_strreset_inreq inreq;\n\tstruct sctp_chunk *retval;\n\t__u16 outlen, inlen;\n\n\toutlen = (sizeof(outreq) + stream_len) * out;\n\tinlen = (sizeof(inreq) + stream_len) * in;\n\n\tretval = sctp_make_reconf(asoc, outlen + inlen);\n\tif (!retval)\n\t\treturn NULL;\n\n\tif (outlen) {\n\t\toutreq.param_hdr.type = SCTP_PARAM_RESET_OUT_REQUEST;\n\t\toutreq.param_hdr.length = htons(outlen);\n\t\toutreq.request_seq = htonl(asoc->strreset_outseq);\n\t\toutreq.response_seq = htonl(asoc->strreset_inseq - 1);\n\t\toutreq.send_reset_at_tsn = htonl(asoc->next_tsn - 1);\n\n\t\tsctp_addto_chunk(retval, sizeof(outreq), &outreq);\n\n\t\tif (stream_len)\n\t\t\tsctp_addto_chunk(retval, stream_len, stream_list);\n\t}\n\n\tif (inlen) {\n\t\tinreq.param_hdr.type = SCTP_PARAM_RESET_IN_REQUEST;\n\t\tinreq.param_hdr.length = htons(inlen);\n\t\tinreq.request_seq = htonl(asoc->strreset_outseq + out);\n\n\t\tsctp_addto_chunk(retval, sizeof(inreq), &inreq);\n\n\t\tif (stream_len)\n\t\t\tsctp_addto_chunk(retval, stream_len, stream_list);\n\t}\n\n\treturn retval;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "sm_make_chunk.c",
        "method_name": "fixed_function",
        "raw_code": "struct sctp_chunk *sctp_make_strreset_req(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\t__u16 stream_num, __be16 *stream_list,\n\t\t\t\t\tbool out, bool in)\n{\n\t__u16 stream_len = stream_num * sizeof(__u16);\n\tstruct sctp_strreset_outreq outreq;\n\tstruct sctp_strreset_inreq inreq;\n\tstruct sctp_chunk *retval;\n\t__u16 outlen, inlen;\n\n\toutlen = (sizeof(outreq) + stream_len) * out;\n\tinlen = (sizeof(inreq) + stream_len) * in;\n\n\tretval = sctp_make_reconf(asoc, SCTP_PAD4(outlen) + SCTP_PAD4(inlen));\n\tif (!retval)\n\t\treturn NULL;\n\n\tif (outlen) {\n\t\toutreq.param_hdr.type = SCTP_PARAM_RESET_OUT_REQUEST;\n\t\toutreq.param_hdr.length = htons(outlen);\n\t\toutreq.request_seq = htonl(asoc->strreset_outseq);\n\t\toutreq.response_seq = htonl(asoc->strreset_inseq - 1);\n\t\toutreq.send_reset_at_tsn = htonl(asoc->next_tsn - 1);\n\n\t\tsctp_addto_chunk(retval, sizeof(outreq), &outreq);\n\n\t\tif (stream_len)\n\t\t\tsctp_addto_chunk(retval, stream_len, stream_list);\n\t}\n\n\tif (inlen) {\n\t\tinreq.param_hdr.type = SCTP_PARAM_RESET_IN_REQUEST;\n\t\tinreq.param_hdr.length = htons(inlen);\n\t\tinreq.request_seq = htonl(asoc->strreset_outseq + out);\n\n\t\tsctp_addto_chunk(retval, sizeof(inreq), &inreq);\n\n\t\tif (stream_len)\n\t\t\tsctp_addto_chunk(retval, stream_len, stream_list);\n\t}\n\n\treturn retval;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <net/sctp/sctp.h>\n#include <linux/net.h>\n#include <linux/inet.h>\n#include <linux/kernel.h>\n#include <linux/ip.h>\n#include <linux/types.h>\n#include <crypto/hash.h>\n#include <net/sock.h>\n#include <net/sctp/sm.h>\n#include <linux/ipv6.h>\n#include <linux/slab.h>\n#include <linux/skbuff.h>\n#include <linux/scatterlist.h>\n#include <linux/random.h>\n\n// Type Definitions:\n// sctp_chunk:\nstatic struct sctp_chunk\n\n// sctp_chunk:\nstruct sctp_chunk {\n\tstruct list_head list;\n\n\trefcount_t refcnt;\n\n\t/* How many times this chunk have been sent, for prsctp RTX policy */\n\tint sent_count;\n\n\tunion {\n\t\t/* This is our link to the per-transport transmitted list.  */\n\t\tstruct list_head transmitted_list;\n\t\t/* List in specific stream outq */\n\t\tstruct list_head stream_list;\n\t};\n\n\t/* This field is used by chunks that hold fragmented data.\n\t * For the first fragment this is the list that holds the rest of\n\t * fragments. For the remaining fragments, this is the link to the\n\t * frag_list maintained in the first fragment.\n\t */\n\tstruct list_head frag_list;\n\n\t/* This points to the sk_buff containing the actual data.  */\n\tstruct sk_buff *skb;\n\n\tunion {\n\t\t/* In case of GSO packets, this will store the head one */\n\t\tstruct sk_buff *head_skb;\n\t\t/* In case of auth enabled, this will point to the shkey */\n\t\tstruct sctp_shared_key *shkey;\n\t};\n\n\t/* These are the SCTP headers by reverse order in a packet.\n\t * Note that some of these may ha...\n\n// sctp_association:\nstatic struct sctp_association\n\n// sctp_association:\nstruct sctp_association {\n\n\t/* A base structure common to endpoint and association.\n\t * In this context, it represents the associations's view\n\t * of the local endpoint of the association.\n\t */\n\tstruct sctp_ep_common base;\n\n\t/* Associations on the same socket. */\n\tstruct list_head asocs;\n\n\t/* association id. */\n\tsctp_assoc_t assoc_id;\n\n\t/* This is our parent endpoint.\t */\n\tstruct sctp_endpoint *ep;\n\n\t/* These are those association elements needed in the cookie.  */\n\tstruct sctp_cookie c;\n\n\t/* This is all information about our peer.  */\n\tstruct {\n\t\t/* transport_addr_list\n\t\t *\n\t\t * Peer\t       : A list of SCTP transport addresses that the\n\t\t * Transport   : peer is bound to. This information is derived\n\t\t * Address     : from the INIT or INIT ACK and is used to\n\t\t * List\t       : associate an inbound packet with a given\n\t\t *\t       : association. Normally this information is\n\t\t *\t       : hashed or keyed for quick lookup and access\n\t\t *\t       : of the TCB.\n\t\t *\t       : The list is a...\n\n// Called Methods (top 10):\n// _sctp_make_chunk from net/sctp/sm_make_chunk.c:\nstatic struct sctp_chunk *_sctp_make_chunk(const struct sctp_association *asoc, /* <=== _sctp_make_chunk */ \n\t\t\t\t\t   __u8 type, __u8 flags, int paylen,\n\t\t\t\t\t   gfp_t gfp)\n{\n\tstruct sctp_chunkhdr *chunk_hdr;\n\tstruct sctp_chunk *retval;\n\tstruct sk_buff *skb;\n\tstruct sock *sk;\n\tint chunklen;\n\n\tchunklen = SCTP_PAD4(sizeof(*chunk_hdr) + paylen);\n\tif (chunklen > SCTP_MAX_CHUNK_LEN)\n\t\tgoto nodata;\n\n\t/* No need to allocate LL here, as this is only a chunk. */\n\tskb = alloc_skb(chunklen, gfp);\n\tif (!skb)\n\t\tgoto nodata;\n\n\t/* Make room for the chunk header.  */\n\tchunk_hdr = (struct sctp_chunkhdr *)skb_put(skb, sizeof(*chunk_hdr));\n\tchunk_hdr->type\t  = type;\n\tchunk_hdr->flags  = flags;\n\tchunk_hdr->length = htons(sizeof(*chunk_hdr));\n\n\tsk = asoc ? asoc->base.sk : NULL;\n\tretval = sctp_chunkify(skb, asoc, sk, gfp);\n\tif (!retval) {\n\t\tkfree_skb(skb);\n\t\tgoto nodata;\n\t}\n\n\tretval->chunk_hdr = chunk_hdr;\n\tretval->chunk_end = ((__u8 *)chunk_hdr) + sizeof(*chunk_hdr);\n\n\t/* Determine if the chunk needs to be authenticated */\n\tif (sctp_auth_send_cid(type, asoc))\n\t\tretval->auth = 1;\n\n\treturn retval;\nnodata:\n\treturn NULL;\n}\n\n// sctp_make_control from net/sctp/sm_make_chunk.c:\nstatic struct sctp_chunk *sctp_make_control(const struct sctp_association *asoc, /* <=== sctp_make_control */ \n\t\t\t\t\t    __u8 type, __u8 flags, int paylen,\n\t\t\t\t\t    gfp_t gfp)\n{\n\tstruct sctp_chunk *chunk;\n\n\tchunk = _sctp_make_chunk(asoc, type, flags, paylen, gfp);\n\tif (chunk)\n\t\tsctp_control_set_owner_w(chunk);\n\n\treturn chunk;\n}\n\n// sctp_addto_chunk from net/sctp/sm_make_chunk.c:\nvoid *sctp_addto_chunk(struct sctp_chunk *chunk, int len, const void *data) /* <=== sctp_addto_chunk */ \n{\n\tint chunklen = ntohs(chunk->chunk_hdr->length);\n\tint padlen = SCTP_PAD4(chunklen) - chunklen;\n\tvoid *target;\n\n\tskb_put_zero(chunk->skb, padlen);\n\ttarget = skb_put_data(chunk->skb, data, len);\n\n\t/* Adjust the chunk length field.  */\n\tchunk->chunk_hdr->length = htons(chunklen + padlen + len);\n\tchunk->chunk_end = skb_tail_pointer(chunk->skb);\n\n\treturn target;\n}\n\n// sctp_make_reconf from net/sctp/sm_make_chunk.c:\nstatic struct sctp_chunk *sctp_make_reconf(const struct sctp_association *asoc, /* <=== sctp_make_reconf */ \n\t\t\t\t\t   int length)\n{\n\tstruct sctp_reconf_chunk *reconf;\n\tstruct sctp_chunk *retval;\n\n\tretval = sctp_make_control(asoc, SCTP_CID_RECONF, 0, length,\n\t\t\t\t   GFP_ATOMIC);\n\tif (!retval)\n\t\treturn NULL;\n\n\treconf = (struct sctp_reconf_chunk *)retval->chunk_hdr;\n\tretval->param_hdr.v = reconf->params;\n\n\treturn retval;\n}\n\n// sctp_control_set_owner_w from net/sctp/sm_make_chunk.c:\nstatic void sctp_control_set_owner_w(struct sctp_chunk *chunk) /* <=== sctp_control_set_owner_w */ \n{\n\tstruct sctp_association *asoc = chunk->asoc;\n\tstruct sk_buff *skb = chunk->skb;\n\n\t/* TODO: properly account for control chunks.\n\t * To do it right we'll need:\n\t *  1) endpoint if association isn't known.\n\t *  2) proper memory accounting.\n\t *\n\t *  For now don't do anything for now.\n\t */\n\tif (chunk->auth) {\n\t\tchunk->shkey = asoc->shkey;\n\t\tsctp_auth_shkey_hold(chunk->shkey);\n\t}\n\tskb->sk = asoc ? asoc->base.sk : NULL;\n\tskb_shinfo(skb)->destructor_arg = chunk;\n\tskb->destructor = sctp_control_release_owner;\n}\n"
  },
  {
    "repository": "qemu",
    "cve_id": "CVE-2021-3416",
    "cwe_list": [
      "CWE-835"
    ],
    "commit_hash": "8c92060d3c0248bd4d515719a35922cd2391b9b4",
    "short_hash": "8c92060d",
    "vulnerableMethods_before": [
      {
        "filename": "sungem.c",
        "method_name": "vulnerable_function",
        "raw_code": "static void sungem_send_packet(SunGEMState *s, const uint8_t *buf,\n                               int size)\n{\n    NetClientState *nc = qemu_get_queue(s->nic);\n\n    if (s->macregs[MAC_XIFCFG >> 2] & MAC_XIFCFG_LBCK) {\n        nc->info->receive(nc, buf, size);\n    } else {\n        qemu_send_packet(nc, buf, size);\n    }\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "sungem.c",
        "method_name": "fixed_function",
        "raw_code": "static void sungem_send_packet(SunGEMState *s, const uint8_t *buf,\n                               int size)\n{\n    NetClientState *nc = qemu_get_queue(s->nic);\n\n    if (s->macregs[MAC_XIFCFG >> 2] & MAC_XIFCFG_LBCK) {\n        qemu_receive_packet(nc, buf, size);\n    } else {\n        qemu_send_packet(nc, buf, size);\n    }\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"hw/net/mii.h\"\n#include \"hw/pci/pci.h\"\n#include \"net/eth.h\"\n#include \"qemu/module.h\"\n#include \"net/net.h\"\n#include \"hw/qdev-properties.h\"\n#include \"migration/vmstate.h\"\n#include \"net/checksum.h\"\n#include \"sysemu/sysemu.h\"\n#include \"qemu/log.h\"\n#include \"trace.h\"\n#include \"qom/object.h\"\n#include \"qemu/osdep.h\"\n\n// Type Definitions:\n// SunGEMState:\nstruct SunGEMState {\n    PCIDevice pdev;\n\n    MemoryRegion sungem;\n    MemoryRegion greg;\n    MemoryRegion txdma;\n    MemoryRegion rxdma;\n    MemoryRegion mac;\n    MemoryRegion mif;\n    MemoryRegion pcs;\n    NICState *nic;\n    NICConf conf;\n    uint32_t phy_addr;\n\n    uint32_t gregs[SUNGEM_MMIO_GREG_SIZE >> 2];\n    uint32_t txdmaregs[SUNGEM_MMIO_TXDMA_SIZE >> 2];\n    uint32_t rxdmaregs[SUNGEM_MMIO_RXDMA_SIZE >> 2];\n    uint32_t macregs[SUNGEM_MMIO_MAC_SIZE >> 2];\n    uint32_t mifregs[SUNGEM_MMIO_MIF_SIZE >> 2];\n    uint32_t pcsregs[SUNGEM_MMIO_PCS_SIZE >> 2];\n\n    /* Cache some useful things */\n    uint32_t rx_mask;\n    uint32_t tx_mask;\n\n    /* Current tx packet */\n    uint8_t tx_data[MAX_PACKET_SIZE];\n    uint32_t tx_size;\n    uint64_t tx_first_ctl;\n}\n\n// Called Methods (top 10):\n// MAC_XIFCFG_LBCK from hw/net/sungem.c:\n<empty>\n\n// MAC_XIFCFG from hw/net/sungem.c:\n<empty>\n"
  },
  {
    "repository": "crun",
    "cve_id": "CVE-2022-27650",
    "cwe_list": [
      "CWE-276"
    ],
    "commit_hash": "1aeeed2e4fdeffb4875c0d0b439915894594c8c6",
    "short_hash": "1aeeed2e",
    "vulnerableMethods_before": [
      {
        "filename": "exec.c",
        "method_name": "vulnerable_function",
        "raw_code": "crun_command_exec (struct crun_global_arguments *global_args, int argc, char **argv, libcrun_error_t *err)\n{\n  int first_arg = 0, ret = 0;\n  libcrun_context_t crun_context = {\n    0,\n  };\n  cleanup_process_schema runtime_spec_schema_config_schema_process *process = NULL;\n  struct libcrun_container_exec_options_s exec_opts;\n\n  memset (&exec_opts, 0, sizeof (exec_opts));\n  exec_opts.struct_size = sizeof (exec_opts);\n\n  crun_context.preserve_fds = 0;\n  crun_context.listen_fds = 0;\n\n  argp_parse (&run_argp, argc, argv, ARGP_IN_ORDER, &first_arg, &exec_options);\n  crun_assert_n_args (argc - first_arg, exec_options.process ? 1 : 2, -1);\n\n  ret = init_libcrun_context (&crun_context, argv[first_arg], global_args, err);\n  if (UNLIKELY (ret < 0))\n    return ret;\n\n  crun_context.detach = exec_options.detach;\n  crun_context.console_socket = exec_options.console_socket;\n  crun_context.pid_file = exec_options.pid_file;\n  crun_context.preserve_fds = exec_options.preserve_fds;\n\n  if (getenv (\"LISTEN_FDS\"))\n    {\n      crun_context.listen_fds = strtoll (getenv (\"LISTEN_FDS\"), NULL, 10);\n      crun_context.preserve_fds += crun_context.listen_fds;\n    }\n\n  if (exec_options.process)\n    exec_opts.path = exec_options.process;\n  else\n    {\n      process = xmalloc0 (sizeof (*process));\n      int i;\n\n      process->args_len = argc;\n      process->args = xmalloc0 ((argc + 1) * sizeof (*process->args));\n      for (i = 0; i < argc - first_arg; i++)\n        process->args[i] = xstrdup (argv[first_arg + i + 1]);\n      process->args[i] = NULL;\n      if (exec_options.cwd)\n        process->cwd = exec_options.cwd;\n      process->terminal = exec_options.tty;\n      process->env = exec_options.env;\n      process->env_len = exec_options.env_size;\n      process->user = make_oci_process_user (exec_options.user);\n\n      if (exec_options.process_label != NULL)\n        process->selinux_label = exec_options.process_label;\n\n      if (exec_options.apparmor != NULL)\n        process->apparmor_profile = exec_options.apparmor;\n\n      if (exec_options.cap_size > 0)\n        {\n          runtime_spec_schema_config_schema_process_capabilities *capabilities\n              = xmalloc (sizeof (runtime_spec_schema_config_schema_process_capabilities));\n\n          capabilities->effective = exec_options.cap;\n          capabilities->effective_len = exec_options.cap_size;\n\n          capabilities->inheritable = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->inheritable_len = exec_options.cap_size;\n\n          capabilities->bounding = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->bounding_len = exec_options.cap_size;\n\n          capabilities->ambient = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->ambient_len = exec_options.cap_size;\n\n          capabilities->permitted = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->permitted_len = exec_options.cap_size;\n\n          process->capabilities = capabilities;\n        }\n\n      // noNewPriviledges will remain `false` if basespec has `false` unless specified\n      // Default is always `true` in generated basespec config\n      if (exec_options.no_new_privs)\n        process->no_new_privileges = 1;\n\n      exec_opts.process = process;\n    }\n\n  exec_opts.cgroup = exec_options.cgroup;\n\n  return libcrun_container_exec_with_options (&crun_context, argv[first_arg], &exec_opts, err);\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "exec.c",
        "method_name": "fixed_function",
        "raw_code": "crun_command_exec (struct crun_global_arguments *global_args, int argc, char **argv, libcrun_error_t *err)\n{\n  int first_arg = 0, ret = 0;\n  libcrun_context_t crun_context = {\n    0,\n  };\n  cleanup_process_schema runtime_spec_schema_config_schema_process *process = NULL;\n  struct libcrun_container_exec_options_s exec_opts;\n\n  memset (&exec_opts, 0, sizeof (exec_opts));\n  exec_opts.struct_size = sizeof (exec_opts);\n\n  crun_context.preserve_fds = 0;\n  crun_context.listen_fds = 0;\n\n  argp_parse (&run_argp, argc, argv, ARGP_IN_ORDER, &first_arg, &exec_options);\n  crun_assert_n_args (argc - first_arg, exec_options.process ? 1 : 2, -1);\n\n  ret = init_libcrun_context (&crun_context, argv[first_arg], global_args, err);\n  if (UNLIKELY (ret < 0))\n    return ret;\n\n  crun_context.detach = exec_options.detach;\n  crun_context.console_socket = exec_options.console_socket;\n  crun_context.pid_file = exec_options.pid_file;\n  crun_context.preserve_fds = exec_options.preserve_fds;\n\n  if (getenv (\"LISTEN_FDS\"))\n    {\n      crun_context.listen_fds = strtoll (getenv (\"LISTEN_FDS\"), NULL, 10);\n      crun_context.preserve_fds += crun_context.listen_fds;\n    }\n\n  if (exec_options.process)\n    exec_opts.path = exec_options.process;\n  else\n    {\n      process = xmalloc0 (sizeof (*process));\n      int i;\n\n      process->args_len = argc;\n      process->args = xmalloc0 ((argc + 1) * sizeof (*process->args));\n      for (i = 0; i < argc - first_arg; i++)\n        process->args[i] = xstrdup (argv[first_arg + i + 1]);\n      process->args[i] = NULL;\n      if (exec_options.cwd)\n        process->cwd = exec_options.cwd;\n      process->terminal = exec_options.tty;\n      process->env = exec_options.env;\n      process->env_len = exec_options.env_size;\n      process->user = make_oci_process_user (exec_options.user);\n\n      if (exec_options.process_label != NULL)\n        process->selinux_label = exec_options.process_label;\n\n      if (exec_options.apparmor != NULL)\n        process->apparmor_profile = exec_options.apparmor;\n\n      if (exec_options.cap_size > 0)\n        {\n          runtime_spec_schema_config_schema_process_capabilities *capabilities\n              = xmalloc (sizeof (runtime_spec_schema_config_schema_process_capabilities));\n\n          capabilities->effective = exec_options.cap;\n          capabilities->effective_len = exec_options.cap_size;\n\n          capabilities->inheritable = NULL;\n          capabilities->inheritable_len = 0;\n\n          capabilities->bounding = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->bounding_len = exec_options.cap_size;\n\n          capabilities->ambient = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->ambient_len = exec_options.cap_size;\n\n          capabilities->permitted = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->permitted_len = exec_options.cap_size;\n\n          process->capabilities = capabilities;\n        }\n\n      // noNewPriviledges will remain `false` if basespec has `false` unless specified\n      // Default is always `true` in generated basespec config\n      if (exec_options.no_new_privs)\n        process->no_new_privileges = 1;\n\n      exec_opts.process = process;\n    }\n\n  exec_opts.cgroup = exec_options.cgroup;\n\n  return libcrun_container_exec_with_options (&crun_context, argv[first_arg], &exec_opts, err);\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"libcrun/utils.h\"\n#include <argp.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"libcrun/linux.h\"\n#include <errno.h>\n#include <stdio.h>\n#include \"libcrun/container.h\"\n#include <config.h>\n#include <unistd.h>\n#include \"crun.h\"\n\n// Type Definitions:\n// crun_global_arguments:\nstatic struct crun_global_arguments\n\n// libcrun_error_t:\ntypedef struct libcrun_error_s *libcrun_error_t;\n\n// libcrun_container_exec_options_s:\nstruct libcrun_container_exec_options_s\n{\n  size_t struct_size;\n  runtime_spec_schema_config_schema_process *process;\n  const char *path;\n  const char *cgroup;\n}\n\n// libcrun_context_t:\ntypedef struct libcrun_context_s libcrun_context_t;\n\n// argp:\nstatic struct argp\n\n// exec_options_s:\nstruct exec_options_s\n{\n  bool tty;\n  bool detach;\n  bool no_new_privs;\n  int preserve_fds;\n  const char *process;\n  const char *console_socket;\n  const char *pid_file;\n  char *process_label;\n  char *apparmor;\n  char *cwd;\n  char *user;\n  char **env;\n  char **cap;\n  size_t cap_size;\n  size_t env_size;\n  char *cgroup;\n}\n\n// Called Methods (top 10):\n// join_process_namespaces from src/libcrun/linux.c:\nstatic int /* <=== join_process_namespaces */ \njoin_process_namespaces (libcrun_container_t *container, pid_t pid_to_join, libcrun_container_status_t *status, libcrun_error_t *err)\n{\n  runtime_spec_schema_config_schema *def = container->container_def;\n  int fds_joined[MAX_NAMESPACES] = {\n    0,\n  };\n  int fds[MAX_NAMESPACES] = {\n    -1,\n  };\n  size_t i;\n  int ret;\n\n  /* Try to join all namespaces in one shot with setns and pidfd.  */\n  ret = try_setns_with_pidfd (pid_to_join, container, status, err);\n  if (UNLIKELY (ret < 0))\n    return ret;\n  /* Nothing left to do if the namespaces were joined.  */\n  if (LIKELY (ret > 0))\n    return 0;\n\n  /* If setns with the target pidfd, fall-back to join each namespace individually.  */\n\n  if (def->linux->namespaces_len >= MAX_NAMESPACES)\n    return crun_make_error (err, 0, \"invalid configuration\");\n\n  for (i = 0; namespaces[i].ns_file; i++)\n    {\n      cleanup_free char *ns_join = NULL;\n\n      xasprintf (&ns_join, \"/proc/%d/ns/%s\", pid_to_join, namespaces[i].ns_file);\n      fds[i] = open (ns_join, O_RDONLY);\n      if (UNLIKELY (fds[i] < 0))\n        {\n          /* If the namespace doesn't exist, just ignore it.  */\n          if (errno == ENOENT)\n            continue;\n\n          crun_make_error (err, errno, \"open `%s`\", ns_join);\n          goto exit;\n        }\n    }\n\n  for (i = 0; namespaces[i].ns_file; i++)\n    {\n      if (namespaces[i].value == CLONE_NEWUSER)\n        continue;\n\n      ret = setns (fds[i], 0);\n      if (ret == 0)\n        fds_joined[i] = 1;\n    }\n  for (i = 0; namespaces[i].ns_file; i++)\n    {\n      ret = setns (fds[i], 0);\n      if (ret == 0)\n        fds_joined[i] = 1;\n    }\n  for (i = 0; namespaces[i].ns_file; i++)\n    {\n      if (fds_joined[i])\n        continue;\n      ret = setns (fds[i], 0);\n      if (UNLIKELY (ret < 0 && errno != EINVAL))\n        {\n          size_t j;\n          bool found = false;\n\n          for (j = 0; j < def->linux->namespaces_len; j++)\n            {\n              if (strcmp (namespaces[i].name, def->linux->namespaces[j]->type) == 0)\n                {\n                  found = true;\n                  break;\n                }\n            }\n          if (! found)\n            {\n              /* It was not requested to create this ns, so just ignore it.  */\n              fds_joined[i] = 1;\n              continue;\n            }\n\n          ret = crun_make_error (err, errno, \"setns `%s`\", namespaces[i].ns_file);\n          goto exit;\n        }\n      fds_joined[i] = 1;\n    }\n\n  ret = 0;\n\nexit:\n  for (i = 0; namespaces[i].ns_file; i++)\n    close_and_reset (&fds[i]);\n\n  return ret;\n}\n\n// LIKELY from src/libcrun/utils.h:\n#define LIKELY(x) __builtin_expect ((x), 1) /* <=== src/libcrun/utils.h:54:54:LIKELY:1 */ \n\n// libcrun_container_setgroups from src/libcrun/linux.c:\nint /* <=== libcrun_container_setgroups */ \nlibcrun_container_setgroups (libcrun_container_t *container,\n                             runtime_spec_schema_config_schema_process *process,\n                             libcrun_error_t *err)\n{\n  gid_t *additional_gids = NULL;\n  size_t additional_gids_len = 0;\n  int can_do_setgroups;\n  int ret;\n\n  if (process != NULL && process->user != NULL)\n    {\n      additional_gids = process->user->additional_gids;\n      additional_gids_len = process->user->additional_gids_len;\n    }\n\n  can_do_setgroups = can_setgroups (container, err);\n  if (UNLIKELY (can_do_setgroups < 0))\n    return can_do_setgroups;\n\n  if (can_do_setgroups == 0)\n    return 0;\n\n  ret = setgroups (additional_gids_len, additional_gids);\n  if (UNLIKELY (ret < 0))\n    return crun_make_error (err, errno, \"setgroups\");\n\n  return 0;\n}\n\n// OOM from src/libcrun/error.h:\n#define OOM()                            \\ /* <=== src/libcrun/error.h:51:56:OOM:0 */ \n  do                                     \\\n    {                                    \\\n      fprintf (stderr, \"out of memory\"); \\\n      _exit (EXIT_FAILURE);              \\\n  } while (0)\n\n// libcrun_read_container_status from src/libcrun/status.c:\nint /* <=== libcrun_read_container_status */ \nlibcrun_read_container_status (libcrun_container_status_t *status, const char *state_root, const char *id,\n                               libcrun_error_t *err)\n{\n  cleanup_free char *buffer = NULL;\n  char err_buffer[256];\n  int ret;\n  cleanup_free char *file = get_state_directory_status_file (state_root, id);\n  yajl_val tree, tmp;\n\n  ret = read_all_file (file, &buffer, NULL, err);\n  if (UNLIKELY (ret < 0))\n    return ret;\n\n  tree = yajl_tree_parse (buffer, err_buffer, sizeof (err_buffer));\n  if (UNLIKELY (tree == NULL))\n    return crun_make_error (err, 0, \"cannot parse status file: %s\", err_buffer);\n\n  {\n    const char *pid_path[] = { \"pid\", NULL };\n    tmp = yajl_tree_get (tree, pid_path, yajl_t_number);\n    if (UNLIKELY (tmp == NULL))\n      return crun_make_error (err, 0, \"'pid' missing in %s\", file);\n    status->pid = strtoull (YAJL_GET_NUMBER (tmp), NULL, 10);\n  }\n  {\n    const char *process_start_time_path[] = { \"process-start-time\", NULL };\n    tmp = yajl_tree_get (tree, process_start_time_path, yajl_t_number);\n    if (UNLIKELY (tmp == NULL))\n      status->process_start_time = 0; /* backwards compatibility */\n    else\n      status->process_start_time = strtoull (YAJL_GET_NUMBER (tmp), NULL, 10);\n  }\n  {\n    const char *cgroup_path[] = { \"cgroup-path\", NULL };\n    tmp = yajl_tree_get (tree, cgroup_path, yajl_t_string);\n    if (UNLIKELY (tmp == NULL))\n      return crun_make_error (err, 0, \"'cgroup-path' missing in %s\", file);\n    status->cgroup_path = xstrdup (YAJL_GET_STRING (tmp));\n  }\n  {\n    const char *scope[] = { \"scope\", NULL };\n    tmp = yajl_tree_get (tree, scope, yajl_t_string);\n    status->scope = tmp ? xstrdup (YAJL_GET_STRING (tmp)) : NULL;\n  }\n  {\n    const char *rootfs[] = { \"rootfs\", NULL };\n    tmp = yajl_tree_get (tree, rootfs, yajl_t_string);\n    if (UNLIKELY (tmp == NULL))\n      return crun_make_error (err, 0, \"'rootfs' missing in %s\", file);\n    status->rootfs = xstrdup (YAJL_GET_STRING (tmp));\n  }\n  {\n    const char *systemd_cgroup[] = { \"systemd-cgroup\", NULL };\n    status->systemd_cgroup = YAJL_IS_TRUE (yajl_tree_get (tree, systemd_cgroup, yajl_t_true));\n  }\n  {\n    const char *bundle[] = { \"bundle\", NULL };\n    tmp = yajl_tree_get (tree, bundle, yajl_t_string);\n    if (UNLIKELY (tmp == NULL))\n      return crun_make_error (err, 0, \"'bundle' missing in %s\", file);\n    status->bundle = xstrdup (YAJL_GET_STRING (tmp));\n  }\n  {\n    const char *created[] = { \"created\", NULL };\n    tmp = yajl_tree_get (tree, created, yajl_t_string);\n    if (UNLIKELY (tmp == NULL))\n      return crun_make_error (err, 0, \"'created' missing in %s\", file);\n    status->created = xstrdup (YAJL_GET_STRING (tmp));\n  }\n  {\n    const char *owner[] = { \"owner\", NULL };\n    tmp = yajl_tree_get (tree, owner, yajl_t_string);\n    status->owner = tmp ? xstrdup (YAJL_GET_STRING (tmp)) : NULL;\n  }\n  {\n    const char *detached[] = { \"detached\", NULL };\n    status->detached = YAJL_IS_TRUE (yajl_tree_get (tree, detached, yajl_t_true));\n  }\n  {\n    const char *external_descriptors[] = { \"external_descriptors\", NULL };\n    tmp = yajl_tree_get (tree, external_descriptors, yajl_t_string);\n    status->external_descriptors = tmp ? xstrdup (YAJL_GET_STRING (tmp)) : NULL;\n  }\n  yajl_tree_free (tree);\n  return 0;\n}\n\n// libcrun_get_state_directory from src/libcrun/status.c:\nchar * /* <=== libcrun_get_state_directory */ \nlibcrun_get_state_directory (const char *state_root, const char *id)\n{\n  int ret;\n  char *path;\n  libcrun_error_t *err = NULL;\n  cleanup_free char *root = get_run_directory (state_root);\n\n  ret = append_paths (&path, err, root, id, NULL);\n  if (UNLIKELY (ret < 0))\n    {\n      crun_error_release (err);\n      return NULL;\n    }\n\n  return path;\n}\n\n// crun_error_release from src/libcrun/error.c:\nint /* <=== crun_error_release */ \ncrun_error_release (libcrun_error_t *err)\n{\n  libcrun_error_t ptr;\n  if (err == NULL)\n    return 0;\n\n  ptr = *err;\n  if (ptr == NULL)\n    return 0;\n\n  free (ptr->msg);\n  free (ptr);\n  *err = NULL;\n  return 0;\n}\n\n// UNLIKELY from src/libcrun/utils.h:\n#define UNLIKELY(x) __builtin_expect ((x), 0) /* <=== src/libcrun/utils.h:55:55:UNLIKELY:1 */ \n\n// libcrun_apply_seccomp from src/libcrun/seccomp.c:\nint /* <=== libcrun_apply_seccomp */ \nlibcrun_apply_seccomp (int infd, int listener_receiver_fd, const char *receiver_fd_payload,\n                       size_t receiver_fd_payload_len, char **seccomp_flags, size_t seccomp_flags_len,\n                       libcrun_error_t *err)\n{\n#ifdef HAVE_SECCOMP\n  int ret;\n  struct sock_fprog seccomp_filter;\n  cleanup_free char *bpf = NULL;\n  unsigned int flags = 0;\n  size_t len;\n\n  if (infd < 0)\n    return 0;\n\n  if (UNLIKELY (lseek (infd, 0, SEEK_SET) == (off_t) -1))\n    return crun_make_error (err, errno, \"lseek\");\n\n  /* if no seccomp flag was specified use a sane default.  */\n  if (seccomp_flags == NULL)\n    flags = SECCOMP_FILTER_FLAG_SPEC_ALLOW;\n  else\n    {\n      size_t i = 0;\n      for (i = 0; i < seccomp_flags_len; i++)\n        {\n          if (strcmp (seccomp_flags[i], \"SECCOMP_FILTER_FLAG_TSYNC\") == 0)\n            flags |= SECCOMP_FILTER_FLAG_TSYNC;\n          else if (strcmp (seccomp_flags[i], \"SECCOMP_FILTER_FLAG_SPEC_ALLOW\") == 0)\n            flags |= SECCOMP_FILTER_FLAG_SPEC_ALLOW;\n          else if (strcmp (seccomp_flags[i], \"SECCOMP_FILTER_FLAG_LOG\") == 0)\n            flags |= SECCOMP_FILTER_FLAG_LOG;\n          else\n            return crun_make_error (err, 0, \"unknown seccomp option %s\", seccomp_flags[i]);\n        }\n    }\n\n  ret = read_all_fd (infd, \"seccomp.bpf\", &bpf, &len, err);\n  if (UNLIKELY (ret < 0))\n    return ret;\n\n  seccomp_filter.len = len / 8;\n  seccomp_filter.filter = (struct sock_filter *) bpf;\n\n  if (listener_receiver_fd >= 0)\n    {\n#  ifdef SECCOMP_FILTER_FLAG_NEW_LISTENER\n      flags |= SECCOMP_FILTER_FLAG_NEW_LISTENER;\n#  else\n      return crun_make_error (err, 0, \"SECCOMP_FILTER_FLAG_NEW_LISTENER not supported\");\n#  endif\n    }\n\n  ret = syscall_seccomp (SECCOMP_SET_MODE_FILTER, flags, &seccomp_filter);\n  if (UNLIKELY (ret < 0))\n    {\n      /* If any of the flags is not supported, try again without specifying them:  */\n      if (errno == EINVAL)\n        ret = syscall_seccomp (SECCOMP_SET_MODE_FILTER, 0, &seccomp_filter);\n      if (UNLIKELY (ret < 0))\n        return crun_make_error (err, errno, \"seccomp (SECCOMP_SET_MODE_FILTER)\");\n    }\n\n  if (listener_receiver_fd >= 0)\n    {\n      int fd = ret;\n\n      ret = send_fd_to_socket_with_payload (listener_receiver_fd, fd,\n                                            receiver_fd_payload, receiver_fd_payload_len, err);\n      if (UNLIKELY (ret < 0))\n        return crun_error_wrap (err, \"send listener fd `%d` to receiver\", fd);\n    }\n  return 0;\n#else\n  return 0;\n#endif\n}\n\n// init_libcrun_context from src/crun.c:\nint /* <=== init_libcrun_context */ \ninit_libcrun_context (libcrun_context_t *con, const char *id, struct crun_global_arguments *glob, libcrun_error_t *err)\n{\n  int ret;\n\n  con->id = id;\n  con->state_root = glob->root;\n  con->systemd_cgroup = glob->option_systemd_cgroup;\n  con->force_no_cgroup = glob->option_force_no_cgroup;\n  con->notify_socket = getenv (\"NOTIFY_SOCKET\");\n  con->fifo_exec_wait_fd = -1;\n\n  ret = libcrun_init_logging (&con->output_handler, &con->output_handler_arg, id, glob->log, err);\n  if (UNLIKELY (ret < 0))\n    return ret;\n\n  if (glob->log_format)\n    {\n      ret = libcrun_set_log_format (glob->log_format, err);\n      if (UNLIKELY (ret < 0))\n        return ret;\n    }\n\n  if (con->bundle == NULL)\n    con->bundle = \".\";\n\n  if (con->config_file == NULL)\n    con->config_file = \"./config.json\";\n\n  con->handler_manager = libcrun_get_handler_manager ();\n\n  return 0;\n}\n"
  },
  {
    "repository": "mruby",
    "cve_id": "CVE-2022-1427",
    "cwe_list": [
      "CWE-703"
    ],
    "commit_hash": "a4d97934d51cb88954cc49161dc1d151f64afb6b",
    "short_hash": "a4d97934",
    "vulnerableMethods_before": [
      {
        "filename": "vm.c",
        "method_name": "vulnerable_function",
        "raw_code": "mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)\n{\n  /* mrb_assert(MRB_PROC_CFUNC_P(proc)) */\n  const mrb_irep *irep = proc->body.irep;\n  const mrb_pool_value *pool = irep->pool;\n  const mrb_sym *syms = irep->syms;\n  mrb_code insn;\n  int ai = mrb_gc_arena_save(mrb);\n  struct mrb_jmpbuf *prev_jmp = mrb->jmp;\n  struct mrb_jmpbuf c_jmp;\n  uint32_t a;\n  uint16_t b;\n  uint16_t c;\n  mrb_sym mid;\n  const struct mrb_irep_catch_handler *ch;\n\n#ifdef DIRECT_THREADED\n  static const void * const optable[] = {\n#define OPCODE(x,_) &&L_OP_ ## x,\n#include \"mruby/ops.h\"\n#undef OPCODE\n  };\n#endif\n\n  mrb_bool exc_catched = FALSE;\nRETRY_TRY_BLOCK:\n\n  MRB_TRY(&c_jmp) {\n\n  if (exc_catched) {\n    exc_catched = FALSE;\n    mrb_gc_arena_restore(mrb, ai);\n    if (mrb->exc && mrb->exc->tt == MRB_TT_BREAK)\n      goto L_BREAK;\n    goto L_RAISE;\n  }\n  mrb->jmp = &c_jmp;\n  mrb_vm_ci_proc_set(mrb->c->ci, proc);\n\n#define regs (mrb->c->ci->stack)\n  INIT_DISPATCH {\n    CASE(OP_NOP, Z) {\n      /* do nothing */\n      NEXT;\n    }\n\n    CASE(OP_MOVE, BB) {\n      regs[a] = regs[b];\n      NEXT;\n    }\n\n    CASE(OP_LOADL, BB) {\n      switch (pool[b].tt) {   /* number */\n      case IREP_TT_INT32:\n        regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i32);\n        break;\n      case IREP_TT_INT64:\n#if defined(MRB_INT64)\n        regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);\n        break;\n#else\n#if defined(MRB_64BIT)\n        if (INT32_MIN <= pool[b].u.i64 && pool[b].u.i64 <= INT32_MAX) {\n          regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);\n          break;\n        }\n#endif\n        goto L_INT_OVERFLOW;\n#endif\n      case IREP_TT_BIGINT:\n#ifdef MRB_USE_BIGINT\n        {\n          const char *s = pool[b].u.str;\n          regs[a] = mrb_bint_new_str(mrb, s+2, (mrb_int)s[0], (mrb_int)s[1]);\n        }\n        break;\n#else\n        goto L_INT_OVERFLOW;\n#endif\n#ifndef MRB_NO_FLOAT\n      case IREP_TT_FLOAT:\n        regs[a] = mrb_float_value(mrb, pool[b].u.f);\n        break;\n#endif\n      default:\n        /* should not happen (tt:string) */\n        regs[a] = mrb_nil_value();\n        break;\n      }\n      NEXT;\n    }\n\n    CASE(OP_LOADI, BB) {\n      SET_FIXNUM_VALUE(regs[a], b);\n      NEXT;\n    }\n\n    CASE(OP_LOADINEG, BB) {\n      SET_FIXNUM_VALUE(regs[a], -b);\n      NEXT;\n    }\n\n    CASE(OP_LOADI__1,B) goto L_LOADI;\n    CASE(OP_LOADI_0,B) goto L_LOADI;\n    CASE(OP_LOADI_1,B) goto L_LOADI;\n    CASE(OP_LOADI_2,B) goto L_LOADI;\n    CASE(OP_LOADI_3,B) goto L_LOADI;\n    CASE(OP_LOADI_4,B) goto L_LOADI;\n    CASE(OP_LOADI_5,B) goto L_LOADI;\n    CASE(OP_LOADI_6,B) goto L_LOADI;\n    CASE(OP_LOADI_7, B) {\n    L_LOADI:\n      SET_FIXNUM_VALUE(regs[a], (mrb_int)insn - (mrb_int)OP_LOADI_0);\n      NEXT;\n    }\n\n    CASE(OP_LOADI16, BS) {\n      SET_FIXNUM_VALUE(regs[a], (mrb_int)(int16_t)b);\n      NEXT;\n    }\n\n    CASE(OP_LOADI32, BSS) {\n      SET_INT_VALUE(mrb, regs[a], (int32_t)(((uint32_t)b<<16)+c));\n      NEXT;\n    }\n\n    CASE(OP_LOADSYM, BB) {\n      SET_SYM_VALUE(regs[a], syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_LOADNIL, B) {\n      SET_NIL_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADSELF, B) {\n      regs[a] = regs[0];\n      NEXT;\n    }\n\n    CASE(OP_LOADT, B) {\n      SET_TRUE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADF, B) {\n      SET_FALSE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETGV, BB) {\n      mrb_value val = mrb_gv_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETGV, BB) {\n      mrb_gv_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETSV, BB) {\n      mrb_value val = mrb_vm_special_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETSV, BB) {\n      mrb_vm_special_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIV, BB) {\n      regs[a] = mrb_iv_get(mrb, regs[0], syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_SETIV, BB) {\n      mrb_iv_set(mrb, regs[0], syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETCV, BB) {\n      mrb_value val;\n      val = mrb_vm_cv_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETCV, BB) {\n      mrb_vm_cv_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIDX, B) {\n      mrb_value va = regs[a], vb = regs[a+1];\n      switch (mrb_type(va)) {\n      case MRB_TT_ARRAY:\n        if (!mrb_integer_p(vb)) goto getidx_fallback;\n        regs[a] = mrb_ary_entry(va, mrb_integer(vb));\n        break;\n      case MRB_TT_HASH:\n        va = mrb_hash_get(mrb, va, vb);\n        regs[a] = va;\n        break;\n      case MRB_TT_STRING:\n        switch (mrb_type(vb)) {\n        case MRB_TT_INTEGER:\n        case MRB_TT_STRING:\n        case MRB_TT_RANGE:\n          va = mrb_str_aref(mrb, va, vb, mrb_undef_value());\n          regs[a] = va;\n          break;\n        default:\n          goto getidx_fallback;\n        }\n        break;\n      default:\n      getidx_fallback:\n        mid = MRB_OPSYM(aref);\n        goto L_SEND_SYM;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SETIDX, B) {\n      c = 2;\n      mid = MRB_OPSYM(aset);\n      SET_NIL_VALUE(regs[a+3]);\n      goto L_SENDB_SYM;\n    }\n\n    CASE(OP_GETCONST, BB) {\n      mrb_value v = mrb_vm_const_get(mrb, syms[b]);\n      regs[a] = v;\n      NEXT;\n    }\n\n    CASE(OP_SETCONST, BB) {\n      mrb_vm_const_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETMCNST, BB) {\n      mrb_value v = mrb_const_get(mrb, regs[a], syms[b]);\n      regs[a] = v;\n      NEXT;\n    }\n\n    CASE(OP_SETMCNST, BB) {\n      mrb_const_set(mrb, regs[a+1], syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETUPVAR, BBB) {\n      mrb_value *regs_a = regs + a;\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e && b < MRB_ENV_LEN(e)) {\n        *regs_a = e->stack[b];\n      }\n      else {\n        *regs_a = mrb_nil_value();\n      }\n      NEXT;\n    }\n\n    CASE(OP_SETUPVAR, BBB) {\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e) {\n        mrb_value *regs_a = regs + a;\n\n        if (b < MRB_ENV_LEN(e)) {\n          e->stack[b] = *regs_a;\n          mrb_write_barrier(mrb, (struct RBasic*)e);\n        }\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMP, S) {\n      pc += (int16_t)a;\n      JUMP;\n    }\n    CASE(OP_JMPIF, BS) {\n      if (mrb_test(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n    CASE(OP_JMPNOT, BS) {\n      if (!mrb_test(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n    CASE(OP_JMPNIL, BS) {\n      if (mrb_nil_p(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMPUW, S) {\n      a = (uint32_t)((pc - irep->iseq) + (int16_t)a);\n      CHECKPOINT_RESTORE(RBREAK_TAG_JUMP) {\n        struct RBreak *brk = (struct RBreak*)mrb->exc;\n        mrb_value target = mrb_break_value_get(brk);\n        mrb_assert(mrb_integer_p(target));\n        a = (uint32_t)mrb_integer(target);\n        mrb_assert(a >= 0 && a < irep->ilen);\n      }\n      CHECKPOINT_MAIN(RBREAK_TAG_JUMP) {\n        ch = catch_handler_find(mrb, mrb->c->ci, pc, MRB_CATCH_FILTER_ENSURE);\n        if (ch) {\n          /* avoiding a jump from a catch handler into the same handler */\n          if (a < mrb_irep_catch_handler_unpack(ch->begin) || a >= mrb_irep_catch_handler_unpack(ch->end)) {\n            THROW_TAGGED_BREAK(mrb, RBREAK_TAG_JUMP, proc, mrb_fixnum_value(a));\n          }\n        }\n      }\n      CHECKPOINT_END(RBREAK_TAG_JUMP);\n\n      mrb->exc = NULL; /* clear break object */\n      pc = irep->iseq + a;\n      JUMP;\n    }\n\n    CASE(OP_EXCEPT, B) {\n      mrb_value exc;\n\n      if (mrb->exc == NULL) {\n        exc = mrb_nil_value();\n      }\n      else {\n        switch (mrb->exc->tt) {\n        case MRB_TT_BREAK:\n        case MRB_TT_EXCEPTION:\n          exc = mrb_obj_value(mrb->exc);\n          break;\n        default:\n          mrb_assert(!\"bad mrb_type\");\n          exc = mrb_nil_value();\n          break;\n        }\n        mrb->exc = NULL;\n      }\n      regs[a] = exc;\n      NEXT;\n    }\n    CASE(OP_RESCUE, BB) {\n      mrb_value exc = regs[a];  /* exc on stack */\n      mrb_value e = regs[b];\n      struct RClass *ec;\n\n      switch (mrb_type(e)) {\n      case MRB_TT_CLASS:\n      case MRB_TT_MODULE:\n        break;\n      default:\n        {\n          mrb_value exc;\n\n          exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                    \"class or module required for rescue clause\");\n          mrb_exc_set(mrb, exc);\n          goto L_RAISE;\n        }\n      }\n      ec = mrb_class_ptr(e);\n      regs[b] = mrb_bool_value(mrb_obj_is_kind_of(mrb, exc, ec));\n      NEXT;\n    }\n\n    CASE(OP_RAISEIF, B) {\n      mrb_value exc = regs[a];\n      if (mrb_break_p(exc)) {\n        mrb->exc = mrb_obj_ptr(exc);\n        goto L_BREAK;\n      }\n      mrb_exc_set(mrb, exc);\n      if (mrb->exc) {\n        goto L_RAISE;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SSEND, BBB) {\n      regs[a] = regs[0];\n      insn = OP_SEND;\n    }\n    goto L_SENDB;\n\n    CASE(OP_SSENDB, BBB) {\n      regs[a] = regs[0];\n    }\n    goto L_SENDB;\n\n    CASE(OP_SEND, BBB)\n    goto L_SENDB;\n\n    L_SEND_SYM:\n    c = 1;\n    /* push nil after arguments */\n    SET_NIL_VALUE(regs[a+2]);\n    goto L_SENDB_SYM;\n\n    CASE(OP_SENDB, BBB)\n    L_SENDB:\n    mid = syms[b];\n    L_SENDB_SYM:\n    {\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_method_t m;\n      struct RClass *cls;\n      mrb_value recv, blk;\n\n      ARGUMENT_NORMALIZE(a, &c, insn);\n\n      recv = regs[a];\n      cls = mrb_class(mrb, recv);\n      m = mrb_method_search_vm(mrb, &cls, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        m = prepare_missing(mrb, recv, mid, &cls, a, &c, blk, 0);\n        mid = MRB_SYM(method_missing);\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb, a, 0, cls, NULL, mid, c);\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        if (MRB_METHOD_PROC_P(m)) {\n          struct RProc *p = MRB_METHOD_PROC(m);\n\n          mrb_vm_ci_proc_set(ci, p);\n          recv = p->body.func(mrb, recv);\n        }\n        else {\n          if (MRB_METHOD_NOARG_P(m)) {\n            check_method_noarg(mrb, ci);\n          }\n          recv = MRB_METHOD_FUNC(m)(mrb, recv);\n        }\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        if (mrb_proc_p(blk)) {\n          struct RProc *p = mrb_proc_ptr(blk);\n          if (p && !MRB_PROC_STRICT_P(p) && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n        if (!ci->u.target_class) { /* return from context modifying method (resume/yield) */\n          if (ci->cci == CINFO_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return recv;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        ci->stack[0] = recv;\n        /* pop stackpos */\n        ci = cipop(mrb);\n        pc = ci->pc;\n      }\n      else {\n        /* setup environment for calling method */\n        mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);\n        pc = irep->iseq;\n      }\n    }\n    JUMP;\n\n    CASE(OP_CALL, Z) {\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv = ci->stack[0];\n      struct RProc *m = mrb_proc_ptr(recv);\n\n      /* replace callinfo */\n      ci->u.target_class = MRB_PROC_TARGET_CLASS(m);\n      mrb_vm_ci_proc_set(ci, m);\n      if (MRB_PROC_ENV_P(m)) {\n        ci->mid = MRB_PROC_ENV(m)->mid;\n      }\n\n      /* prepare stack */\n      if (MRB_PROC_CFUNC_P(m)) {\n        recv = MRB_PROC_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        /* pop stackpos */\n        ci = cipop(mrb);\n        pc = ci->pc;\n        ci[1].stack[0] = recv;\n        irep = mrb->c->ci->proc->body.irep;\n      }\n      else {\n        /* setup environment for calling method */\n        proc = m;\n        irep = m->body.irep;\n        if (!irep) {\n          mrb->c->ci->stack[0] = mrb_nil_value();\n          a = 0;\n          c = OP_R_NORMAL;\n          goto L_OP_RETURN_BODY;\n        }\n        mrb_int nargs = mrb_ci_bidx(ci)+1;\n        if (nargs < irep->nregs) {\n          mrb_stack_extend(mrb, irep->nregs);\n          stack_clear(regs+nargs, irep->nregs-nargs);\n        }\n        if (MRB_PROC_ENV_P(m)) {\n          regs[0] = MRB_PROC_ENV(m)->stack[0];\n        }\n        pc = irep->iseq;\n      }\n      pool = irep->pool;\n      syms = irep->syms;\n      JUMP;\n    }\n\n    CASE(OP_SUPER, BB) {\n      mrb_method_t m;\n      struct RClass *cls;\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv, blk;\n      const struct RProc *p = ci->proc;\n      mrb_sym mid = ci->mid;\n      struct RClass* target_class = MRB_PROC_TARGET_CLASS(p);\n\n      if (MRB_PROC_ENV_P(p) && p->e.env->mid && p->e.env->mid != mid) { /* alias support */\n        mid = p->e.env->mid;    /* restore old mid */\n      }\n\n      if (mid == 0 || !target_class) {\n        mrb_value exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (target_class->flags & MRB_FL_CLASS_IS_PREPENDED) {\n        target_class = mrb_vm_ci_target_class(ci);\n      }\n      else if (target_class->tt == MRB_TT_MODULE) {\n        target_class = mrb_vm_ci_target_class(ci);\n        if (!target_class || target_class->tt != MRB_TT_ICLASS) {\n          goto super_typeerror;\n        }\n      }\n      recv = regs[0];\n      if (!mrb_obj_is_kind_of(mrb, recv, target_class)) {\n      super_typeerror: ;\n        mrb_value exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                            \"self has wrong type to call super in this context\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n\n      ARGUMENT_NORMALIZE(a, &b, OP_SUPER);\n\n      cls = target_class->super;\n      m = mrb_method_search_vm(mrb, &cls, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        m = prepare_missing(mrb, recv, mid, &cls, a, &b, blk, 1);\n        mid = MRB_SYM(method_missing);\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb, a, 0, cls, NULL, mid, b);\n\n      /* prepare stack */\n      ci->stack[0] = recv;\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        mrb_value v;\n\n        if (MRB_METHOD_PROC_P(m)) {\n          mrb_vm_ci_proc_set(ci, MRB_METHOD_PROC(m));\n        }\n        v = MRB_METHOD_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_restore(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        mrb_assert(!mrb_break_p(v));\n        if (!mrb_vm_ci_target_class(ci)) { /* return from context modifying method (resume/yield) */\n          if (ci->cci == CINFO_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return v;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        mrb->c->ci->stack[0] = v;\n        ci = cipop(mrb);\n        pc = ci->pc;\n      }\n      else {\n        /* setup environment for calling method */\n        mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);\n        pc = irep->iseq;\n      }\n      JUMP;\n    }\n\n    CASE(OP_ARGARY, BS) {\n      mrb_int m1 = (b>>11)&0x3f;\n      mrb_int r  = (b>>10)&0x1;\n      mrb_int m2 = (b>>5)&0x1f;\n      mrb_int kd = (b>>4)&0x1;\n      mrb_int lv = (b>>0)&0xf;\n      mrb_value *stack;\n\n      if (mrb->c->ci->mid == 0 || mrb_vm_ci_target_class(mrb->c->ci) == NULL) {\n        mrb_value exc;\n\n      L_NOSUPER:\n        exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e) goto L_NOSUPER;\n        if (MRB_ENV_LEN(e) <= m1+r+m2+1)\n          goto L_NOSUPER;\n        stack = e->stack + 1;\n      }\n      if (r == 0) {\n        regs[a] = mrb_ary_new_from_values(mrb, m1+m2, stack);\n      }\n      else {\n        mrb_value *pp = NULL;\n        struct RArray *rest;\n        mrb_int len = 0;\n\n        if (mrb_array_p(stack[m1])) {\n          struct RArray *ary = mrb_ary_ptr(stack[m1]);\n\n          pp = ARY_PTR(ary);\n          len = ARY_LEN(ary);\n        }\n        regs[a] = mrb_ary_new_capa(mrb, m1+len+m2);\n        rest = mrb_ary_ptr(regs[a]);\n        if (m1 > 0) {\n          stack_copy(ARY_PTR(rest), stack, m1);\n        }\n        if (len > 0) {\n          stack_copy(ARY_PTR(rest)+m1, pp, len);\n        }\n        if (m2 > 0) {\n          stack_copy(ARY_PTR(rest)+m1+len, stack+m1+1, m2);\n        }\n        ARY_SET_LEN(rest, m1+len+m2);\n      }\n      if (kd) {\n        regs[a+1] = stack[m1+r+m2];\n        regs[a+2] = stack[m1+r+m2+1];\n      }\n      else {\n        regs[a+1] = stack[m1+r+m2];\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ENTER, W) {\n      mrb_int m1 = MRB_ASPEC_REQ(a);\n      mrb_int o  = MRB_ASPEC_OPT(a);\n      mrb_int r  = MRB_ASPEC_REST(a);\n      mrb_int m2 = MRB_ASPEC_POST(a);\n      mrb_int kd = (MRB_ASPEC_KEY(a) > 0 || MRB_ASPEC_KDICT(a))? 1 : 0;\n      /* unused\n      int b  = MRB_ASPEC_BLOCK(a);\n      */\n      mrb_int const len = m1 + o + r + m2;\n\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_int argc = ci->n;\n      mrb_value *argv = regs+1;\n      mrb_value * const argv0 = argv;\n      mrb_int const kw_pos = len + kd;    /* where kwhash should be */\n      mrb_int const blk_pos = kw_pos + 1; /* where block should be */\n      mrb_value blk = regs[mrb_ci_bidx(ci)];\n      mrb_value kdict = mrb_nil_value();\n\n      /* keyword arguments */\n      if (ci->nk > 0) {\n        mrb_int kidx = mrb_ci_kidx(ci);\n        kdict = regs[kidx];\n        if (!mrb_hash_p(kdict) || mrb_hash_size(mrb, kdict) == 0) {\n          kdict = mrb_nil_value();\n          ci->nk = 0;\n        }\n      }\n      if (!kd && !mrb_nil_p(kdict)) {\n        if (argc < 14) {\n          ci->n++;\n          argc++;    /* include kdict in normal arguments */\n        }\n        else if (argc == 14) {\n          /* pack arguments and kdict */\n          regs[1] = mrb_ary_new_from_values(mrb, argc+1, &regs[1]);\n          argc = ci->n = 15;\n        }\n        else {/* argc == 15 */\n          /* push kdict to packed arguments */\n          mrb_ary_push(mrb, regs[1], regs[2]);\n        }\n        ci->nk = 0;\n      }\n      if (kd && MRB_ASPEC_KEY(a) > 0 && mrb_hash_p(kdict)) {\n        kdict = mrb_hash_dup(mrb, kdict);\n      }\n\n      /* arguments is passed with Array */\n      if (argc == 15) {\n        struct RArray *ary = mrb_ary_ptr(regs[1]);\n        argv = ARY_PTR(ary);\n        argc = (int)ARY_LEN(ary);\n        mrb_gc_protect(mrb, regs[1]);\n      }\n\n      /* strict argument check */\n      if (ci->proc && MRB_PROC_STRICT_P(ci->proc)) {\n        if (argc < m1 + m2 || (r == 0 && argc > len)) {\n          argnum_error(mrb, m1+m2);\n          goto L_RAISE;\n        }\n      }\n      /* extract first argument array to arguments */\n      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {\n        mrb_gc_protect(mrb, argv[0]);\n        argc = (int)RARRAY_LEN(argv[0]);\n        argv = RARRAY_PTR(argv[0]);\n      }\n\n      /* rest arguments */\n      mrb_value rest = mrb_nil_value();\n      if (argc < len) {\n        mrb_int mlen = m2;\n        if (argc < m1+m2) {\n          mlen = m1 < argc ? argc - m1 : 0;\n        }\n\n        /* copy mandatory and optional arguments */\n        if (argv0 != argv && argv) {\n          value_move(&regs[1], argv, argc-mlen); /* m1 + o */\n        }\n        if (argc < m1) {\n          stack_clear(&regs[argc+1], m1-argc);\n        }\n        /* copy post mandatory arguments */\n        if (mlen) {\n          value_move(&regs[len-m2+1], &argv[argc-mlen], mlen);\n        }\n        if (mlen < m2) {\n          stack_clear(&regs[len-m2+mlen+1], m2-mlen);\n        }\n        /* initialize rest arguments with empty Array */\n        if (r) {\n          rest = mrb_ary_new_capa(mrb, 0);\n          regs[m1+o+1] = rest;\n        }\n        /* skip initializer of passed arguments */\n        if (o > 0 && argc > m1+m2)\n          pc += (argc - m1 - m2)*3;\n      }\n      else {\n        mrb_int rnum = 0;\n        if (argv0 != argv) {\n          value_move(&regs[1], argv, m1+o);\n        }\n        if (r) {\n          rnum = argc-m1-o-m2;\n          rest = mrb_ary_new_from_values(mrb, rnum, argv+m1+o);\n          regs[m1+o+1] = rest;\n        }\n        if (m2 > 0 && argc-m2 > m1) {\n          value_move(&regs[m1+o+r+1], &argv[m1+o+rnum], m2);\n        }\n        pc += o*3;\n      }\n\n      /* need to be update blk first to protect blk from GC */\n      regs[blk_pos] = blk;              /* move block */\n      if (kd) {\n        if (mrb_nil_p(kdict))\n          kdict = mrb_hash_new_capa(mrb, 0);\n        regs[kw_pos] = kdict;           /* set kwhash */\n      }\n\n      /* format arguments for generated code */\n      mrb->c->ci->n = (uint8_t)len;\n\n      /* clear local (but non-argument) variables */\n      if (irep->nlocals-blk_pos-1 > 0) {\n        stack_clear(&regs[blk_pos+1], irep->nlocals-blk_pos-1);\n      }\n      JUMP;\n    }\n\n    CASE(OP_KARG, BB) {\n      mrb_value k = mrb_symbol_value(syms[b]);\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict, v;\n\n      if (kidx < 0 || !mrb_hash_p(kdict=regs[kidx]) || !mrb_hash_key_p(mrb, kdict, k)) {\n        mrb_value str = mrb_format(mrb, \"missing keyword: %v\", k);\n        mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));\n        goto L_RAISE;\n      }\n      v = mrb_hash_get(mrb, kdict, k);\n      regs[a] = v;\n      mrb_hash_delete_key(mrb, kdict, k);\n      NEXT;\n    }\n\n    CASE(OP_KEY_P, BB) {\n      mrb_value k = mrb_symbol_value(syms[b]);\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict;\n      mrb_bool key_p = FALSE;\n\n      if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx])) {\n        key_p = mrb_hash_key_p(mrb, kdict, k);\n      }\n      regs[a] = mrb_bool_value(key_p);\n      NEXT;\n    }\n\n    CASE(OP_KEYEND, Z) {\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict;\n\n      if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx]) && !mrb_hash_empty_p(mrb, kdict)) {\n        mrb_value keys = mrb_hash_keys(mrb, kdict);\n        mrb_value key1 = RARRAY_PTR(keys)[0];\n        mrb_value str = mrb_format(mrb, \"unknown keyword: %v\", key1);\n        mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));\n        goto L_RAISE;\n      }\n      NEXT;\n    }\n\n    CASE(OP_BREAK, B) {\n      c = OP_R_BREAK;\n      goto L_RETURN;\n    }\n    CASE(OP_RETURN_BLK, B) {\n      c = OP_R_RETURN;\n      goto L_RETURN;\n    }\n    CASE(OP_RETURN, B)\n    c = OP_R_NORMAL;\n    L_RETURN:\n    {\n      mrb_callinfo *ci;\n\n      ci = mrb->c->ci;\n      if (ci->mid) {\n        mrb_value blk = regs[mrb_ci_bidx(ci)];\n\n        if (mrb_proc_p(blk)) {\n          struct RProc *p = mrb_proc_ptr(blk);\n\n          if (!MRB_PROC_STRICT_P(p) &&\n              ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n      }\n\n      if (mrb->exc) {\n      L_RAISE:\n        ci = mrb->c->ci;\n        if (ci == mrb->c->cibase) {\n          ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);\n          if (ch == NULL) goto L_FTOP;\n          goto L_CATCH;\n        }\n        while ((ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL)) == NULL) {\n          ci = cipop(mrb);\n          if (ci[1].cci == CINFO_SKIP && prev_jmp) {\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          pc = ci[0].pc;\n          if (ci == mrb->c->cibase) {\n            ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);\n            if (ch == NULL) {\n            L_FTOP:             /* fiber top */\n              if (mrb->c == mrb->root_c) {\n                mrb->c->ci->stack = mrb->c->stbase;\n                goto L_STOP;\n              }\n              else {\n                struct mrb_context *c = mrb->c;\n\n                c->status = MRB_FIBER_TERMINATED;\n                mrb->c = c->prev;\n                c->prev = NULL;\n                goto L_RAISE;\n              }\n            }\n            break;\n          }\n        }\n      L_CATCH:\n        if (ch == NULL) goto L_STOP;\n        if (FALSE) {\n        L_CATCH_TAGGED_BREAK: /* from THROW_TAGGED_BREAK() or UNWIND_ENSURE() */\n          ci = mrb->c->ci;\n        }\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, irep->nregs);\n        pc = irep->iseq + mrb_irep_catch_handler_unpack(ch->target);\n      }\n      else {\n        mrb_int acc;\n        mrb_value v;\n\n        ci = mrb->c->ci;\n        v = regs[a];\n        mrb_gc_protect(mrb, v);\n        switch (c) {\n        case OP_R_RETURN:\n          /* Fall through to OP_R_NORMAL otherwise */\n          if (ci->cci == CINFO_NONE && MRB_PROC_ENV_P(proc) && !MRB_PROC_STRICT_P(proc)) {\n            const struct RProc *dst;\n            mrb_callinfo *cibase;\n            cibase = mrb->c->cibase;\n            dst = top_proc(mrb, proc);\n\n            if (MRB_PROC_ENV_P(dst)) {\n              struct REnv *e = MRB_PROC_ENV(dst);\n\n              if (!MRB_ENV_ONSTACK_P(e) || (e->cxt && e->cxt != mrb->c)) {\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n            }\n            /* check jump destination */\n            while (cibase <= ci && ci->proc != dst) {\n              if (ci->cci > CINFO_NONE) { /* jump cross C boundary */\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n              ci--;\n            }\n            if (ci <= cibase) { /* no jump destination */\n              localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n              goto L_RAISE;\n            }\n            ci = mrb->c->ci;\n            while (cibase <= ci && ci->proc != dst) {\n              CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_BLOCK) {\n                cibase = mrb->c->cibase;\n                dst = top_proc(mrb, proc);\n              }\n              CHECKPOINT_MAIN(RBREAK_TAG_RETURN_BLOCK) {\n                UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_BLOCK, proc, v);\n              }\n              CHECKPOINT_END(RBREAK_TAG_RETURN_BLOCK);\n              ci = cipop(mrb);\n              pc = ci->pc;\n            }\n            proc = ci->proc;\n            mrb->exc = NULL; /* clear break object */\n            break;\n          }\n          /* fallthrough */\n        case OP_R_NORMAL:\n        NORMAL_RETURN:\n          if (ci == mrb->c->cibase) {\n            struct mrb_context *c;\n            c = mrb->c;\n\n            if (!c->prev) { /* toplevel return */\n              regs[irep->nlocals] = v;\n              goto CHECKPOINT_LABEL_MAKE(RBREAK_TAG_STOP);\n            }\n            if (!c->vmexec && c->prev->ci == c->prev->cibase) {\n              mrb_value exc = mrb_exc_new_lit(mrb, E_FIBER_ERROR, \"double resume\");\n              mrb_exc_set(mrb, exc);\n              goto L_RAISE;\n            }\n            CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_TOPLEVEL) {\n              c = mrb->c;\n            }\n            CHECKPOINT_MAIN(RBREAK_TAG_RETURN_TOPLEVEL) {\n              UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_TOPLEVEL, proc, v);\n            }\n            CHECKPOINT_END(RBREAK_TAG_RETURN_TOPLEVEL);\n            /* automatic yield at the end */\n            c->status = MRB_FIBER_TERMINATED;\n            mrb->c = c->prev;\n            mrb->c->status = MRB_FIBER_RUNNING;\n            c->prev = NULL;\n            if (c->vmexec) {\n              mrb_gc_arena_restore(mrb, ai);\n              c->vmexec = FALSE;\n              mrb->jmp = prev_jmp;\n              return v;\n            }\n            ci = mrb->c->ci;\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_RETURN) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_RETURN) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_RETURN);\n          mrb->exc = NULL; /* clear break object */\n          break;\n        case OP_R_BREAK:\n          if (MRB_PROC_STRICT_P(proc)) goto NORMAL_RETURN;\n          if (MRB_PROC_ORPHAN_P(proc)) {\n            mrb_value exc;\n\n          L_BREAK_ERROR:\n            exc = mrb_exc_new_lit(mrb, E_LOCALJUMP_ERROR,\n                                      \"break from proc-closure\");\n            mrb_exc_set(mrb, exc);\n            goto L_RAISE;\n          }\n          if (!MRB_PROC_ENV_P(proc) || !MRB_ENV_ONSTACK_P(MRB_PROC_ENV(proc))) {\n            goto L_BREAK_ERROR;\n          }\n          else {\n            struct REnv *e = MRB_PROC_ENV(proc);\n\n            if (e->cxt != mrb->c) {\n              goto L_BREAK_ERROR;\n            }\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_BREAK) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_BREAK);\n          /* break from fiber block */\n          if (ci == mrb->c->cibase && ci->pc) {\n            struct mrb_context *c = mrb->c;\n\n            mrb->c = c->prev;\n            c->prev = NULL;\n            ci = mrb->c->ci;\n          }\n          if (ci->cci > CINFO_NONE) {\n            ci = cipop(mrb);\n            mrb->exc = (struct RObject*)break_new(mrb, RBREAK_TAG_BREAK, proc, v);\n            mrb_gc_arena_restore(mrb, ai);\n            mrb->c->vmexec = FALSE;\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          if (FALSE) {\n            struct RBreak *brk;\n\n          L_BREAK:\n            brk = (struct RBreak*)mrb->exc;\n            proc = mrb_break_proc_get(brk);\n            v = mrb_break_value_get(brk);\n            ci = mrb->c->ci;\n\n            switch (mrb_break_tag_get(brk)) {\n#define DISPATCH_CHECKPOINTS(n, i) case n: goto CHECKPOINT_LABEL_MAKE(n);\n              RBREAK_TAG_FOREACH(DISPATCH_CHECKPOINTS)\n#undef DISPATCH_CHECKPOINTS\n              default:\n                mrb_assert(!\"wrong break tag\");\n            }\n          }\n          while (mrb->c->cibase < ci && ci[-1].proc != proc->upper) {\n            if (ci[-1].cci == CINFO_SKIP) {\n              goto L_BREAK_ERROR;\n            }\n            CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_UPPER) {\n              /* do nothing */\n            }\n            CHECKPOINT_MAIN(RBREAK_TAG_BREAK_UPPER) {\n              UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_UPPER, proc, v);\n            }\n            CHECKPOINT_END(RBREAK_TAG_BREAK_UPPER);\n            ci = cipop(mrb);\n            pc = ci->pc;\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_INTARGET) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_BREAK_INTARGET) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_INTARGET, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_BREAK_INTARGET);\n          if (ci == mrb->c->cibase) {\n            goto L_BREAK_ERROR;\n          }\n          mrb->exc = NULL; /* clear break object */\n          break;\n        default:\n          /* cannot happen */\n          break;\n        }\n        mrb_assert(ci == mrb->c->ci);\n        mrb_assert(mrb->exc == NULL);\n\n        if (mrb->c->vmexec && !mrb_vm_ci_target_class(ci)) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->c->vmexec = FALSE;\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        acc = ci->cci;\n        ci = cipop(mrb);\n        if (acc == CINFO_SKIP || acc == CINFO_DIRECT) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        pc = ci->pc;\n        DEBUG(fprintf(stderr, \"from :%s\\n\", mrb_sym_name(mrb, ci->mid)));\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n\n        ci[1].stack[0] = v;\n        mrb_gc_arena_restore(mrb, ai);\n      }\n      JUMP;\n    }\n\n    CASE(OP_BLKPUSH, BS) {\n      int m1 = (b>>11)&0x3f;\n      int r  = (b>>10)&0x1;\n      int m2 = (b>>5)&0x1f;\n      int kd = (b>>4)&0x1;\n      int lv = (b>>0)&0xf;\n      mrb_value *stack;\n\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e || (!MRB_ENV_ONSTACK_P(e) && e->mid == 0) ||\n            MRB_ENV_LEN(e) <= m1+r+m2+1) {\n          localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n          goto L_RAISE;\n        }\n        stack = e->stack + 1;\n      }\n      if (mrb_nil_p(stack[m1+r+m2+kd])) {\n        localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n        goto L_RAISE;\n      }\n      regs[a] = stack[m1+r+m2+kd];\n      NEXT;\n    }\n\n#if !defined(MRB_USE_BIGINT) || defined(MRB_INT32)\n  L_INT_OVERFLOW:\n    {\n      mrb_value exc = mrb_exc_new_lit(mrb, E_RANGE_ERROR, \"integer overflow\");\n      mrb_exc_set(mrb, exc);\n    }\n    goto L_RAISE;\n#endif\n\n#define TYPES2(a,b) ((((uint16_t)(a))<<8)|(((uint16_t)(b))&0xff))\n#define OP_MATH(op_name)                                                    \\\n  /* need to check if op is overridden */                                   \\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {                  \\\n    OP_MATH_CASE_INTEGER(op_name);                                          \\\n    OP_MATH_CASE_FLOAT(op_name, integer, float);                            \\\n    OP_MATH_CASE_FLOAT(op_name, float,  integer);                           \\\n    OP_MATH_CASE_FLOAT(op_name, float,  float);                             \\\n    OP_MATH_CASE_STRING_##op_name();                                        \\\n    default:                                                                \\\n      mid = MRB_OPSYM(op_name);                                             \\\n      goto L_SEND_SYM;                                                      \\\n  }                                                                         \\\n  NEXT;\n#define OP_MATH_CASE_INTEGER(op_name)                                       \\\n  case TYPES2(MRB_TT_INTEGER, MRB_TT_INTEGER):                              \\\n    {                                                                       \\\n      mrb_int x = mrb_integer(regs[a]), y = mrb_integer(regs[a+1]), z;      \\\n      if (mrb_int_##op_name##_overflow(x, y, &z)) {                         \\\n        OP_MATH_OVERFLOW_INT(op_name,x,y);                                  \\\n      }                                                                     \\\n      else                                                                  \\\n        SET_INT_VALUE(mrb,regs[a], z);                                      \\\n    }                                                                       \\\n    break\n#ifdef MRB_NO_FLOAT\n#define OP_MATH_CASE_FLOAT(op_name, t1, t2) (void)0\n#else\n#define OP_MATH_CASE_FLOAT(op_name, t1, t2)                                     \\\n  case TYPES2(OP_MATH_TT_##t1, OP_MATH_TT_##t2):                                \\\n    {                                                                           \\\n      mrb_float z = mrb_##t1(regs[a]) OP_MATH_OP_##op_name mrb_##t2(regs[a+1]); \\\n      SET_FLOAT_VALUE(mrb, regs[a], z);                                         \\\n    }                                                                           \\\n    break\n#endif\n#ifdef MRB_USE_BIGINT\n#define OP_MATH_OVERFLOW_INT(op,x,y) regs[a] = mrb_bint_##op##_ii(mrb,x,y)\n#else\n#define OP_MATH_OVERFLOW_INT(op,x,y) goto L_INT_OVERFLOW\n#endif\n#define OP_MATH_CASE_STRING_add()                                           \\\n  case TYPES2(MRB_TT_STRING, MRB_TT_STRING):                                \\\n    regs[a] = mrb_str_plus(mrb, regs[a], regs[a+1]);                        \\\n    mrb_gc_arena_restore(mrb, ai);                                          \\\n    break\n#define OP_MATH_CASE_STRING_sub() (void)0\n#define OP_MATH_CASE_STRING_mul() (void)0\n#define OP_MATH_OP_add +\n#define OP_MATH_OP_sub -\n#define OP_MATH_OP_mul *\n#define OP_MATH_TT_integer MRB_TT_INTEGER\n#define OP_MATH_TT_float   MRB_TT_FLOAT\n\n    CASE(OP_ADD, B) {\n      OP_MATH(add);\n    }\n\n    CASE(OP_SUB, B) {\n      OP_MATH(sub);\n    }\n\n    CASE(OP_MUL, B) {\n      OP_MATH(mul);\n    }\n\n    CASE(OP_DIV, B) {\n#ifndef MRB_NO_FLOAT\n      mrb_float x, y, f;\n#endif\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\n        {\n          mrb_int x = mrb_integer(regs[a]);\n          mrb_int y = mrb_integer(regs[a+1]);\n          mrb_int div = mrb_div_int(mrb, x, y);\n          SET_INT_VALUE(mrb, regs[a], div);\n        }\n        NEXT;\n#ifndef MRB_NO_FLOAT\n      case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\n        x = (mrb_float)mrb_integer(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\n        x = mrb_float(regs[a]);\n        y = (mrb_float)mrb_integer(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n        x = mrb_float(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n#endif\n      default:\n        mid = MRB_OPSYM(div);\n        goto L_SEND_SYM;\n      }\n\n#ifndef MRB_NO_FLOAT\n      f = mrb_div_float(x, y);\n      SET_FLOAT_VALUE(mrb, regs[a], f);\n#endif\n      NEXT;\n    }\n\n#define OP_MATHI(op_name)                                                   \\\n  /* need to check if op is overridden */                                   \\\n  switch (mrb_type(regs[a])) {                                              \\\n    OP_MATHI_CASE_INTEGER(op_name);                                         \\\n    OP_MATHI_CASE_FLOAT(op_name);                                           \\\n    default:                                                                \\\n      SET_INT_VALUE(mrb,regs[a+1], b);                                      \\\n      mid = MRB_OPSYM(op_name);                                             \\\n      goto L_SEND_SYM;                                                      \\\n  }                                                                         \\\n  NEXT;\n#define OP_MATHI_CASE_INTEGER(op_name)                                      \\\n  case MRB_TT_INTEGER:                                                      \\\n    {                                                                       \\\n      mrb_int x = mrb_integer(regs[a]), y = (mrb_int)b, z;                  \\\n      if (mrb_int_##op_name##_overflow(x, y, &z)) {                         \\\n        OP_MATH_OVERFLOW_INT(op_name,x,y);                                  \\\n      }                                                                     \\\n      else                                                                  \\\n        SET_INT_VALUE(mrb,regs[a], z);                                      \\\n    }                                                                       \\\n    break\n#ifdef MRB_NO_FLOAT\n#define OP_MATHI_CASE_FLOAT(op_name) (void)0\n#else\n#define OP_MATHI_CASE_FLOAT(op_name)                                        \\\n  case MRB_TT_FLOAT:                                                        \\\n    {                                                                       \\\n      mrb_float z = mrb_float(regs[a]) OP_MATH_OP_##op_name b;              \\\n      SET_FLOAT_VALUE(mrb, regs[a], z);                                     \\\n    }                                                                       \\\n    break\n#endif\n\n    CASE(OP_ADDI, BB) {\n      OP_MATHI(add);\n    }\n\n    CASE(OP_SUBI, BB) {\n      OP_MATHI(sub);\n    }\n\n#define OP_CMP_BODY(op,v1,v2) (v1(regs[a]) op v2(regs[a+1]))\n\n#ifdef MRB_NO_FLOAT\n#define OP_CMP(op,sym) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  default:\\\n    mid = MRB_OPSYM(sym);\\\n    goto L_SEND_SYM;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#else\n#define OP_CMP(op, sym) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_float);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_float);\\\n    break;\\\n  default:\\\n    mid = MRB_OPSYM(sym);\\\n    goto L_SEND_SYM;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#endif\n\n    CASE(OP_EQ, B) {\n      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {\n        SET_TRUE_VALUE(regs[a]);\n      }\n      else {\n        OP_CMP(==,eq);\n      }\n      NEXT;\n    }\n\n    CASE(OP_LT, B) {\n      OP_CMP(<,lt);\n      NEXT;\n    }\n\n    CASE(OP_LE, B) {\n      OP_CMP(<=,le);\n      NEXT;\n    }\n\n    CASE(OP_GT, B) {\n      OP_CMP(>,gt);\n      NEXT;\n    }\n\n    CASE(OP_GE, B) {\n      OP_CMP(>=,ge);\n      NEXT;\n    }\n\n    CASE(OP_ARRAY, BB) {\n      regs[a] = mrb_ary_new_from_values(mrb, b, &regs[a]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_ARRAY2, BBB) {\n      regs[a] = mrb_ary_new_from_values(mrb, c, &regs[b]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYCAT, B) {\n      mrb_value splat = mrb_ary_splat(mrb, regs[a+1]);\n      if (mrb_nil_p(regs[a])) {\n        regs[a] = splat;\n      }\n      else {\n        mrb_assert(mrb_array_p(regs[a]));\n        mrb_ary_concat(mrb, regs[a], splat);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYPUSH, BB) {\n      mrb_assert(mrb_array_p(regs[a]));\n      for (mrb_int i=0; i<b; i++) {\n        mrb_ary_push(mrb, regs[a], regs[a+i+1]);\n      }\n      NEXT;\n    }\n\n    CASE(OP_ARYDUP, B) {\n      mrb_value ary = regs[a];\n      if (mrb_array_p(ary)) {\n        ary = mrb_ary_new_from_values(mrb, RARRAY_LEN(ary), RARRAY_PTR(ary));\n      }\n      else {\n        ary = mrb_ary_new_from_values(mrb, 1, &ary);\n      }\n      regs[a] = ary;\n      NEXT;\n    }\n\n    CASE(OP_AREF, BBB) {\n      mrb_value v = regs[b];\n\n      if (!mrb_array_p(v)) {\n        if (c == 0) {\n          regs[a] = v;\n        }\n        else {\n          SET_NIL_VALUE(regs[a]);\n        }\n      }\n      else {\n        v = mrb_ary_ref(mrb, v, c);\n        regs[a] = v;\n      }\n      NEXT;\n    }\n\n    CASE(OP_ASET, BBB) {\n      mrb_assert(mrb_array_p(regs[a]));\n      mrb_ary_set(mrb, regs[b], c, regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_APOST, BBB) {\n      mrb_value v = regs[a];\n      int pre  = b;\n      int post = c;\n      struct RArray *ary;\n      int len, idx;\n\n      if (!mrb_array_p(v)) {\n        v = mrb_ary_new_from_values(mrb, 1, &regs[a]);\n      }\n      ary = mrb_ary_ptr(v);\n      len = (int)ARY_LEN(ary);\n      if (len > pre + post) {\n        v = mrb_ary_new_from_values(mrb, len - pre - post, ARY_PTR(ary)+pre);\n        regs[a++] = v;\n        while (post--) {\n          regs[a++] = ARY_PTR(ary)[len-post-1];\n        }\n      }\n      else {\n        v = mrb_ary_new_capa(mrb, 0);\n        regs[a++] = v;\n        for (idx=0; idx+pre<len; idx++) {\n          regs[a+idx] = ARY_PTR(ary)[pre+idx];\n        }\n        while (idx < post) {\n          SET_NIL_VALUE(regs[a+idx]);\n          idx++;\n        }\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_INTERN, B) {\n      mrb_assert(mrb_string_p(regs[a]));\n      mrb_sym sym = mrb_intern_str(mrb, regs[a]);\n      regs[a] = mrb_symbol_value(sym);\n      NEXT;\n    }\n\n    CASE(OP_SYMBOL, BB) {\n      size_t len;\n      mrb_sym sym;\n\n      mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);\n      len = pool[b].tt >> 2;\n      if (pool[b].tt & IREP_TT_SFLAG) {\n        sym = mrb_intern_static(mrb, pool[b].u.str, len);\n      }\n      else {\n        sym  = mrb_intern(mrb, pool[b].u.str, len);\n      }\n      regs[a] = mrb_symbol_value(sym);\n      NEXT;\n    }\n\n    CASE(OP_STRING, BB) {\n      mrb_int len;\n\n      mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);\n      len = pool[b].tt >> 2;\n      if (pool[b].tt & IREP_TT_SFLAG) {\n        regs[a] = mrb_str_new_static(mrb, pool[b].u.str, len);\n      }\n      else {\n        regs[a] = mrb_str_new(mrb, pool[b].u.str, len);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_STRCAT, B) {\n      mrb_assert(mrb_string_p(regs[a]));\n      mrb_str_concat(mrb, regs[a], regs[a+1]);\n      NEXT;\n    }\n\n    CASE(OP_HASH, BB) {\n      mrb_value hash = mrb_hash_new_capa(mrb, b);\n      int i;\n      int lim = a+b*2;\n\n      for (i=a; i<lim; i+=2) {\n        mrb_hash_set(mrb, hash, regs[i], regs[i+1]);\n      }\n      regs[a] = hash;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_HASHADD, BB) {\n      mrb_value hash;\n      int i;\n      int lim = a+b*2+1;\n\n      hash = regs[a];\n      mrb_ensure_hash_type(mrb, hash);\n      for (i=a+1; i<lim; i+=2) {\n        mrb_hash_set(mrb, hash, regs[i], regs[i+1]);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_HASHCAT, B) {\n      mrb_value hash = regs[a];\n\n      mrb_assert(mrb_hash_p(hash));\n      mrb_hash_merge(mrb, hash, regs[a+1]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_LAMBDA, BB)\n    c = OP_L_LAMBDA;\n    L_MAKE_LAMBDA:\n    {\n      struct RProc *p;\n      const mrb_irep *nirep = irep->reps[b];\n\n      if (c & OP_L_CAPTURE) {\n        p = mrb_closure_new(mrb, nirep);\n      }\n      else {\n        p = mrb_proc_new(mrb, nirep);\n        p->flags |= MRB_PROC_SCOPE;\n      }\n      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;\n      regs[a] = mrb_obj_value(p);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_BLOCK, BB) {\n      c = OP_L_BLOCK;\n      goto L_MAKE_LAMBDA;\n    }\n    CASE(OP_METHOD, BB) {\n      c = OP_L_METHOD;\n      goto L_MAKE_LAMBDA;\n    }\n\n    CASE(OP_RANGE_INC, B) {\n      mrb_value v = mrb_range_new(mrb, regs[a], regs[a+1], FALSE);\n      regs[a] = v;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_RANGE_EXC, B) {\n      mrb_value v = mrb_range_new(mrb, regs[a], regs[a+1], TRUE);\n      regs[a] = v;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_OCLASS, B) {\n      regs[a] = mrb_obj_value(mrb->object_class);\n      NEXT;\n    }\n\n    CASE(OP_CLASS, BB) {\n      struct RClass *c = 0, *baseclass;\n      mrb_value base, super;\n      mrb_sym id = syms[b];\n\n      base = regs[a];\n      super = regs[a+1];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        if (!baseclass) baseclass = mrb->object_class;\n        base = mrb_obj_value(baseclass);\n      }\n      c = mrb_vm_define_class(mrb, base, super, id);\n      regs[a] = mrb_obj_value(c);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_MODULE, BB) {\n      struct RClass *cls = 0, *baseclass;\n      mrb_value base;\n      mrb_sym id = syms[b];\n\n      base = regs[a];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        if (!baseclass) baseclass = mrb->object_class;\n        base = mrb_obj_value(baseclass);\n      }\n      cls = mrb_vm_define_module(mrb, base, id);\n      regs[a] = mrb_obj_value(cls);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_EXEC, BB)\n    {\n      mrb_value recv = regs[a];\n      struct RProc *p;\n      const mrb_irep *nirep = irep->reps[b];\n\n      /* prepare closure */\n      p = mrb_proc_new(mrb, nirep);\n      p->c = NULL;\n      mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)proc);\n      MRB_PROC_SET_TARGET_CLASS(p, mrb_class_ptr(recv));\n      p->flags |= MRB_PROC_SCOPE;\n\n      /* prepare call stack */\n      cipush(mrb, a, 0, mrb_class_ptr(recv), p, 0, 0);\n\n      irep = p->body.irep;\n      pool = irep->pool;\n      syms = irep->syms;\n      mrb_stack_extend(mrb, irep->nregs);\n      stack_clear(regs+1, irep->nregs-1);\n      pc = irep->iseq;\n      JUMP;\n    }\n\n    CASE(OP_DEF, BB) {\n      struct RClass *target = mrb_class_ptr(regs[a]);\n      struct RProc *p = mrb_proc_ptr(regs[a+1]);\n      mrb_method_t m;\n      mrb_sym mid = syms[b];\n\n      MRB_METHOD_FROM_PROC(m, p);\n      mrb_define_method_raw(mrb, target, mid, m);\n      mrb_method_added(mrb, target, mid);\n      mrb_gc_arena_restore(mrb, ai);\n      regs[a] = mrb_symbol_value(mid);\n      NEXT;\n    }\n\n    CASE(OP_SCLASS, B) {\n      regs[a] = mrb_singleton_class(mrb, regs[a]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_TCLASS, B) {\n      struct RClass *target = check_target_class(mrb);\n      if (!target) goto L_RAISE;\n      regs[a] = mrb_obj_value(target);\n      NEXT;\n    }\n\n    CASE(OP_ALIAS, BB) {\n      struct RClass *target = check_target_class(mrb);\n\n      if (!target) goto L_RAISE;\n      mrb_alias_method(mrb, target, syms[a], syms[b]);\n      mrb_method_added(mrb, target, syms[a]);\n      NEXT;\n    }\n    CASE(OP_UNDEF, B) {\n      struct RClass *target = check_target_class(mrb);\n\n      if (!target) goto L_RAISE;\n      mrb_undef_method_id(mrb, target, syms[a]);\n      NEXT;\n    }\n\n    CASE(OP_DEBUG, Z) {\n      FETCH_BBB();\n#ifdef MRB_USE_DEBUG_HOOK\n      mrb->debug_op_hook(mrb, irep, pc, regs);\n#else\n#ifndef MRB_NO_STDIO\n      printf(\"OP_DEBUG %d %d %d\\n\", a, b, c);\n#else\n      abort();\n#endif\n#endif\n      NEXT;\n    }\n\n    CASE(OP_ERR, B) {\n      size_t len = pool[a].tt >> 2;\n      mrb_value exc;\n\n      mrb_assert((pool[a].tt&IREP_TT_NFLAG)==0);\n      exc = mrb_exc_new(mrb, E_LOCALJUMP_ERROR, pool[a].u.str, len);\n      mrb_exc_set(mrb, exc);\n      goto L_RAISE;\n    }\n\n    CASE(OP_EXT1, Z) {\n      insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _1(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n    CASE(OP_EXT2, Z) {\n      insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _2(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n    CASE(OP_EXT3, Z) {\n      uint8_t insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _3(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n\n    CASE(OP_STOP, Z) {\n      /*        stop VM */\n      CHECKPOINT_RESTORE(RBREAK_TAG_STOP) {\n        /* do nothing */\n      }\n      CHECKPOINT_MAIN(RBREAK_TAG_STOP) {\n        UNWIND_ENSURE(mrb, mrb->c->ci, pc, RBREAK_TAG_STOP, proc, mrb_nil_value());\n      }\n      CHECKPOINT_END(RBREAK_TAG_STOP);\n    L_STOP:\n      mrb->jmp = prev_jmp;\n      if (mrb->exc) {\n        mrb_assert(mrb->exc->tt == MRB_TT_EXCEPTION);\n        return mrb_obj_value(mrb->exc);\n      }\n      return regs[irep->nlocals];\n    }\n  }\n  END_DISPATCH;\n#undef regs\n  }\n  MRB_CATCH(&c_jmp) {\n    mrb_callinfo *ci = mrb->c->ci;\n    while (ci > mrb->c->cibase && ci->cci == CINFO_DIRECT) {\n      ci = cipop(mrb);\n    }\n    exc_catched = TRUE;\n    pc = ci->pc;\n    goto RETRY_TRY_BLOCK;\n  }\n  MRB_END_EXC(&c_jmp);\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "vm.c",
        "method_name": "fixed_function",
        "raw_code": "mrb_vm_exec(mrb_state *mrb, const struct RProc *proc, const mrb_code *pc)\n{\n  /* mrb_assert(MRB_PROC_CFUNC_P(proc)) */\n  const mrb_irep *irep = proc->body.irep;\n  const mrb_pool_value *pool = irep->pool;\n  const mrb_sym *syms = irep->syms;\n  mrb_code insn;\n  int ai = mrb_gc_arena_save(mrb);\n  struct mrb_jmpbuf *prev_jmp = mrb->jmp;\n  struct mrb_jmpbuf c_jmp;\n  uint32_t a;\n  uint16_t b;\n  uint16_t c;\n  mrb_sym mid;\n  const struct mrb_irep_catch_handler *ch;\n\n#ifdef DIRECT_THREADED\n  static const void * const optable[] = {\n#define OPCODE(x,_) &&L_OP_ ## x,\n#include \"mruby/ops.h\"\n#undef OPCODE\n  };\n#endif\n\n  mrb_bool exc_catched = FALSE;\nRETRY_TRY_BLOCK:\n\n  MRB_TRY(&c_jmp) {\n\n  if (exc_catched) {\n    exc_catched = FALSE;\n    mrb_gc_arena_restore(mrb, ai);\n    if (mrb->exc && mrb->exc->tt == MRB_TT_BREAK)\n      goto L_BREAK;\n    goto L_RAISE;\n  }\n  mrb->jmp = &c_jmp;\n  mrb_vm_ci_proc_set(mrb->c->ci, proc);\n\n#define regs (mrb->c->ci->stack)\n  INIT_DISPATCH {\n    CASE(OP_NOP, Z) {\n      /* do nothing */\n      NEXT;\n    }\n\n    CASE(OP_MOVE, BB) {\n      regs[a] = regs[b];\n      NEXT;\n    }\n\n    CASE(OP_LOADL, BB) {\n      switch (pool[b].tt) {   /* number */\n      case IREP_TT_INT32:\n        regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i32);\n        break;\n      case IREP_TT_INT64:\n#if defined(MRB_INT64)\n        regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);\n        break;\n#else\n#if defined(MRB_64BIT)\n        if (INT32_MIN <= pool[b].u.i64 && pool[b].u.i64 <= INT32_MAX) {\n          regs[a] = mrb_int_value(mrb, (mrb_int)pool[b].u.i64);\n          break;\n        }\n#endif\n        goto L_INT_OVERFLOW;\n#endif\n      case IREP_TT_BIGINT:\n#ifdef MRB_USE_BIGINT\n        {\n          const char *s = pool[b].u.str;\n          regs[a] = mrb_bint_new_str(mrb, s+2, (mrb_int)s[0], (mrb_int)s[1]);\n        }\n        break;\n#else\n        goto L_INT_OVERFLOW;\n#endif\n#ifndef MRB_NO_FLOAT\n      case IREP_TT_FLOAT:\n        regs[a] = mrb_float_value(mrb, pool[b].u.f);\n        break;\n#endif\n      default:\n        /* should not happen (tt:string) */\n        regs[a] = mrb_nil_value();\n        break;\n      }\n      NEXT;\n    }\n\n    CASE(OP_LOADI, BB) {\n      SET_FIXNUM_VALUE(regs[a], b);\n      NEXT;\n    }\n\n    CASE(OP_LOADINEG, BB) {\n      SET_FIXNUM_VALUE(regs[a], -b);\n      NEXT;\n    }\n\n    CASE(OP_LOADI__1,B) goto L_LOADI;\n    CASE(OP_LOADI_0,B) goto L_LOADI;\n    CASE(OP_LOADI_1,B) goto L_LOADI;\n    CASE(OP_LOADI_2,B) goto L_LOADI;\n    CASE(OP_LOADI_3,B) goto L_LOADI;\n    CASE(OP_LOADI_4,B) goto L_LOADI;\n    CASE(OP_LOADI_5,B) goto L_LOADI;\n    CASE(OP_LOADI_6,B) goto L_LOADI;\n    CASE(OP_LOADI_7, B) {\n    L_LOADI:\n      SET_FIXNUM_VALUE(regs[a], (mrb_int)insn - (mrb_int)OP_LOADI_0);\n      NEXT;\n    }\n\n    CASE(OP_LOADI16, BS) {\n      SET_FIXNUM_VALUE(regs[a], (mrb_int)(int16_t)b);\n      NEXT;\n    }\n\n    CASE(OP_LOADI32, BSS) {\n      SET_INT_VALUE(mrb, regs[a], (int32_t)(((uint32_t)b<<16)+c));\n      NEXT;\n    }\n\n    CASE(OP_LOADSYM, BB) {\n      SET_SYM_VALUE(regs[a], syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_LOADNIL, B) {\n      SET_NIL_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADSELF, B) {\n      regs[a] = regs[0];\n      NEXT;\n    }\n\n    CASE(OP_LOADT, B) {\n      SET_TRUE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_LOADF, B) {\n      SET_FALSE_VALUE(regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETGV, BB) {\n      mrb_value val = mrb_gv_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETGV, BB) {\n      mrb_gv_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETSV, BB) {\n      mrb_value val = mrb_vm_special_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETSV, BB) {\n      mrb_vm_special_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIV, BB) {\n      regs[a] = mrb_iv_get(mrb, regs[0], syms[b]);\n      NEXT;\n    }\n\n    CASE(OP_SETIV, BB) {\n      mrb_iv_set(mrb, regs[0], syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETCV, BB) {\n      mrb_value val;\n      val = mrb_vm_cv_get(mrb, syms[b]);\n      regs[a] = val;\n      NEXT;\n    }\n\n    CASE(OP_SETCV, BB) {\n      mrb_vm_cv_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETIDX, B) {\n      mrb_value va = regs[a], vb = regs[a+1];\n      switch (mrb_type(va)) {\n      case MRB_TT_ARRAY:\n        if (!mrb_integer_p(vb)) goto getidx_fallback;\n        regs[a] = mrb_ary_entry(va, mrb_integer(vb));\n        break;\n      case MRB_TT_HASH:\n        va = mrb_hash_get(mrb, va, vb);\n        regs[a] = va;\n        break;\n      case MRB_TT_STRING:\n        switch (mrb_type(vb)) {\n        case MRB_TT_INTEGER:\n        case MRB_TT_STRING:\n        case MRB_TT_RANGE:\n          va = mrb_str_aref(mrb, va, vb, mrb_undef_value());\n          regs[a] = va;\n          break;\n        default:\n          goto getidx_fallback;\n        }\n        break;\n      default:\n      getidx_fallback:\n        mid = MRB_OPSYM(aref);\n        goto L_SEND_SYM;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SETIDX, B) {\n      c = 2;\n      mid = MRB_OPSYM(aset);\n      SET_NIL_VALUE(regs[a+3]);\n      goto L_SENDB_SYM;\n    }\n\n    CASE(OP_GETCONST, BB) {\n      mrb_value v = mrb_vm_const_get(mrb, syms[b]);\n      regs[a] = v;\n      NEXT;\n    }\n\n    CASE(OP_SETCONST, BB) {\n      mrb_vm_const_set(mrb, syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETMCNST, BB) {\n      mrb_value v = mrb_const_get(mrb, regs[a], syms[b]);\n      regs[a] = v;\n      NEXT;\n    }\n\n    CASE(OP_SETMCNST, BB) {\n      mrb_const_set(mrb, regs[a+1], syms[b], regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_GETUPVAR, BBB) {\n      mrb_value *regs_a = regs + a;\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e && b < MRB_ENV_LEN(e)) {\n        *regs_a = e->stack[b];\n      }\n      else {\n        *regs_a = mrb_nil_value();\n      }\n      NEXT;\n    }\n\n    CASE(OP_SETUPVAR, BBB) {\n      struct REnv *e = uvenv(mrb, c);\n\n      if (e) {\n        mrb_value *regs_a = regs + a;\n\n        if (b < MRB_ENV_LEN(e)) {\n          e->stack[b] = *regs_a;\n          mrb_write_barrier(mrb, (struct RBasic*)e);\n        }\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMP, S) {\n      pc += (int16_t)a;\n      JUMP;\n    }\n    CASE(OP_JMPIF, BS) {\n      if (mrb_test(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n    CASE(OP_JMPNOT, BS) {\n      if (!mrb_test(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n    CASE(OP_JMPNIL, BS) {\n      if (mrb_nil_p(regs[a])) {\n        pc += (int16_t)b;\n        JUMP;\n      }\n      NEXT;\n    }\n\n    CASE(OP_JMPUW, S) {\n      a = (uint32_t)((pc - irep->iseq) + (int16_t)a);\n      CHECKPOINT_RESTORE(RBREAK_TAG_JUMP) {\n        struct RBreak *brk = (struct RBreak*)mrb->exc;\n        mrb_value target = mrb_break_value_get(brk);\n        mrb_assert(mrb_integer_p(target));\n        a = (uint32_t)mrb_integer(target);\n        mrb_assert(a >= 0 && a < irep->ilen);\n      }\n      CHECKPOINT_MAIN(RBREAK_TAG_JUMP) {\n        ch = catch_handler_find(mrb, mrb->c->ci, pc, MRB_CATCH_FILTER_ENSURE);\n        if (ch) {\n          /* avoiding a jump from a catch handler into the same handler */\n          if (a < mrb_irep_catch_handler_unpack(ch->begin) || a >= mrb_irep_catch_handler_unpack(ch->end)) {\n            THROW_TAGGED_BREAK(mrb, RBREAK_TAG_JUMP, proc, mrb_fixnum_value(a));\n          }\n        }\n      }\n      CHECKPOINT_END(RBREAK_TAG_JUMP);\n\n      mrb->exc = NULL; /* clear break object */\n      pc = irep->iseq + a;\n      JUMP;\n    }\n\n    CASE(OP_EXCEPT, B) {\n      mrb_value exc;\n\n      if (mrb->exc == NULL) {\n        exc = mrb_nil_value();\n      }\n      else {\n        switch (mrb->exc->tt) {\n        case MRB_TT_BREAK:\n        case MRB_TT_EXCEPTION:\n          exc = mrb_obj_value(mrb->exc);\n          break;\n        default:\n          mrb_assert(!\"bad mrb_type\");\n          exc = mrb_nil_value();\n          break;\n        }\n        mrb->exc = NULL;\n      }\n      regs[a] = exc;\n      NEXT;\n    }\n    CASE(OP_RESCUE, BB) {\n      mrb_value exc = regs[a];  /* exc on stack */\n      mrb_value e = regs[b];\n      struct RClass *ec;\n\n      switch (mrb_type(e)) {\n      case MRB_TT_CLASS:\n      case MRB_TT_MODULE:\n        break;\n      default:\n        {\n          mrb_value exc;\n\n          exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                    \"class or module required for rescue clause\");\n          mrb_exc_set(mrb, exc);\n          goto L_RAISE;\n        }\n      }\n      ec = mrb_class_ptr(e);\n      regs[b] = mrb_bool_value(mrb_obj_is_kind_of(mrb, exc, ec));\n      NEXT;\n    }\n\n    CASE(OP_RAISEIF, B) {\n      mrb_value exc = regs[a];\n      if (mrb_break_p(exc)) {\n        mrb->exc = mrb_obj_ptr(exc);\n        goto L_BREAK;\n      }\n      mrb_exc_set(mrb, exc);\n      if (mrb->exc) {\n        goto L_RAISE;\n      }\n      NEXT;\n    }\n\n    CASE(OP_SSEND, BBB) {\n      regs[a] = regs[0];\n      insn = OP_SEND;\n    }\n    goto L_SENDB;\n\n    CASE(OP_SSENDB, BBB) {\n      regs[a] = regs[0];\n    }\n    goto L_SENDB;\n\n    CASE(OP_SEND, BBB)\n    goto L_SENDB;\n\n    L_SEND_SYM:\n    c = 1;\n    /* push nil after arguments */\n    SET_NIL_VALUE(regs[a+2]);\n    goto L_SENDB_SYM;\n\n    CASE(OP_SENDB, BBB)\n    L_SENDB:\n    mid = syms[b];\n    L_SENDB_SYM:\n    {\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_method_t m;\n      struct RClass *cls;\n      mrb_value recv, blk;\n\n      ARGUMENT_NORMALIZE(a, &c, insn);\n\n      recv = regs[a];\n      cls = mrb_class(mrb, recv);\n      m = mrb_method_search_vm(mrb, &cls, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        m = prepare_missing(mrb, recv, mid, &cls, a, &c, blk, 0);\n        mid = MRB_SYM(method_missing);\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb, a, 0, cls, NULL, mid, c);\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        if (MRB_METHOD_PROC_P(m)) {\n          struct RProc *p = MRB_METHOD_PROC(m);\n\n          mrb_vm_ci_proc_set(ci, p);\n          recv = p->body.func(mrb, recv);\n        }\n        else {\n          if (MRB_METHOD_NOARG_P(m)) {\n            check_method_noarg(mrb, ci);\n          }\n          recv = MRB_METHOD_FUNC(m)(mrb, recv);\n        }\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        if (mrb_proc_p(blk)) {\n          struct RProc *p = mrb_proc_ptr(blk);\n          if (p && !MRB_PROC_STRICT_P(p) && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n        if (!ci->u.target_class) { /* return from context modifying method (resume/yield) */\n          if (ci->cci == CINFO_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return recv;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        ci->stack[0] = recv;\n        /* pop stackpos */\n        ci = cipop(mrb);\n        pc = ci->pc;\n      }\n      else {\n        /* setup environment for calling method */\n        mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);\n        pc = irep->iseq;\n      }\n    }\n    JUMP;\n\n    CASE(OP_CALL, Z) {\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv = ci->stack[0];\n      struct RProc *m = mrb_proc_ptr(recv);\n\n      /* replace callinfo */\n      ci->u.target_class = MRB_PROC_TARGET_CLASS(m);\n      mrb_vm_ci_proc_set(ci, m);\n      if (MRB_PROC_ENV_P(m)) {\n        ci->mid = MRB_PROC_ENV(m)->mid;\n      }\n\n      /* prepare stack */\n      if (MRB_PROC_CFUNC_P(m)) {\n        recv = MRB_PROC_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_shrink(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        /* pop stackpos */\n        ci = cipop(mrb);\n        pc = ci->pc;\n        ci[1].stack[0] = recv;\n        irep = mrb->c->ci->proc->body.irep;\n      }\n      else {\n        /* setup environment for calling method */\n        proc = m;\n        irep = m->body.irep;\n        if (!irep) {\n          mrb->c->ci->stack[0] = mrb_nil_value();\n          a = 0;\n          c = OP_R_NORMAL;\n          goto L_OP_RETURN_BODY;\n        }\n        mrb_int nargs = mrb_ci_bidx(ci)+1;\n        if (nargs < irep->nregs) {\n          mrb_stack_extend(mrb, irep->nregs);\n          stack_clear(regs+nargs, irep->nregs-nargs);\n        }\n        if (MRB_PROC_ENV_P(m)) {\n          regs[0] = MRB_PROC_ENV(m)->stack[0];\n        }\n        pc = irep->iseq;\n      }\n      pool = irep->pool;\n      syms = irep->syms;\n      JUMP;\n    }\n\n    CASE(OP_SUPER, BB) {\n      mrb_method_t m;\n      struct RClass *cls;\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_value recv, blk;\n      const struct RProc *p = ci->proc;\n      mrb_sym mid = ci->mid;\n      struct RClass* target_class = MRB_PROC_TARGET_CLASS(p);\n\n      if (MRB_PROC_ENV_P(p) && p->e.env->mid && p->e.env->mid != mid) { /* alias support */\n        mid = p->e.env->mid;    /* restore old mid */\n      }\n\n      if (mid == 0 || !target_class) {\n        mrb_value exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if ((target_class->flags & MRB_FL_CLASS_IS_PREPENDED) || target_class->tt == MRB_TT_MODULE) {\n        target_class = mrb_vm_ci_target_class(ci);\n        if (!target_class || target_class->tt != MRB_TT_ICLASS) {\n          goto super_typeerror;\n        }\n      }\n      recv = regs[0];\n      if (!mrb_obj_is_kind_of(mrb, recv, target_class)) {\n      super_typeerror: ;\n        mrb_value exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                            \"self has wrong type to call super in this context\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n\n      ARGUMENT_NORMALIZE(a, &b, OP_SUPER);\n\n      cls = target_class->super;\n      m = mrb_method_search_vm(mrb, &cls, mid);\n      if (MRB_METHOD_UNDEF_P(m)) {\n        m = prepare_missing(mrb, recv, mid, &cls, a, &b, blk, 1);\n        mid = MRB_SYM(method_missing);\n      }\n\n      /* push callinfo */\n      ci = cipush(mrb, a, 0, cls, NULL, mid, b);\n\n      /* prepare stack */\n      ci->stack[0] = recv;\n\n      if (MRB_METHOD_CFUNC_P(m)) {\n        mrb_value v;\n\n        if (MRB_METHOD_PROC_P(m)) {\n          mrb_vm_ci_proc_set(ci, MRB_METHOD_PROC(m));\n        }\n        v = MRB_METHOD_CFUNC(m)(mrb, recv);\n        mrb_gc_arena_restore(mrb, ai);\n        if (mrb->exc) goto L_RAISE;\n        ci = mrb->c->ci;\n        mrb_assert(!mrb_break_p(v));\n        if (!mrb_vm_ci_target_class(ci)) { /* return from context modifying method (resume/yield) */\n          if (ci->cci == CINFO_RESUMED) {\n            mrb->jmp = prev_jmp;\n            return v;\n          }\n          else {\n            mrb_assert(!MRB_PROC_CFUNC_P(ci[-1].proc));\n            proc = ci[-1].proc;\n            irep = proc->body.irep;\n            pool = irep->pool;\n            syms = irep->syms;\n          }\n        }\n        mrb->c->ci->stack[0] = v;\n        ci = cipop(mrb);\n        pc = ci->pc;\n      }\n      else {\n        /* setup environment for calling method */\n        mrb_vm_ci_proc_set(ci, (proc = MRB_METHOD_PROC(m)));\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, (irep->nregs < 4) ? 4 : irep->nregs);\n        pc = irep->iseq;\n      }\n      JUMP;\n    }\n\n    CASE(OP_ARGARY, BS) {\n      mrb_int m1 = (b>>11)&0x3f;\n      mrb_int r  = (b>>10)&0x1;\n      mrb_int m2 = (b>>5)&0x1f;\n      mrb_int kd = (b>>4)&0x1;\n      mrb_int lv = (b>>0)&0xf;\n      mrb_value *stack;\n\n      if (mrb->c->ci->mid == 0 || mrb_vm_ci_target_class(mrb->c->ci) == NULL) {\n        mrb_value exc;\n\n      L_NOSUPER:\n        exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e) goto L_NOSUPER;\n        if (MRB_ENV_LEN(e) <= m1+r+m2+1)\n          goto L_NOSUPER;\n        stack = e->stack + 1;\n      }\n      if (r == 0) {\n        regs[a] = mrb_ary_new_from_values(mrb, m1+m2, stack);\n      }\n      else {\n        mrb_value *pp = NULL;\n        struct RArray *rest;\n        mrb_int len = 0;\n\n        if (mrb_array_p(stack[m1])) {\n          struct RArray *ary = mrb_ary_ptr(stack[m1]);\n\n          pp = ARY_PTR(ary);\n          len = ARY_LEN(ary);\n        }\n        regs[a] = mrb_ary_new_capa(mrb, m1+len+m2);\n        rest = mrb_ary_ptr(regs[a]);\n        if (m1 > 0) {\n          stack_copy(ARY_PTR(rest), stack, m1);\n        }\n        if (len > 0) {\n          stack_copy(ARY_PTR(rest)+m1, pp, len);\n        }\n        if (m2 > 0) {\n          stack_copy(ARY_PTR(rest)+m1+len, stack+m1+1, m2);\n        }\n        ARY_SET_LEN(rest, m1+len+m2);\n      }\n      if (kd) {\n        regs[a+1] = stack[m1+r+m2];\n        regs[a+2] = stack[m1+r+m2+1];\n      }\n      else {\n        regs[a+1] = stack[m1+r+m2];\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ENTER, W) {\n      mrb_int m1 = MRB_ASPEC_REQ(a);\n      mrb_int o  = MRB_ASPEC_OPT(a);\n      mrb_int r  = MRB_ASPEC_REST(a);\n      mrb_int m2 = MRB_ASPEC_POST(a);\n      mrb_int kd = (MRB_ASPEC_KEY(a) > 0 || MRB_ASPEC_KDICT(a))? 1 : 0;\n      /* unused\n      int b  = MRB_ASPEC_BLOCK(a);\n      */\n      mrb_int const len = m1 + o + r + m2;\n\n      mrb_callinfo *ci = mrb->c->ci;\n      mrb_int argc = ci->n;\n      mrb_value *argv = regs+1;\n      mrb_value * const argv0 = argv;\n      mrb_int const kw_pos = len + kd;    /* where kwhash should be */\n      mrb_int const blk_pos = kw_pos + 1; /* where block should be */\n      mrb_value blk = regs[mrb_ci_bidx(ci)];\n      mrb_value kdict = mrb_nil_value();\n\n      /* keyword arguments */\n      if (ci->nk > 0) {\n        mrb_int kidx = mrb_ci_kidx(ci);\n        kdict = regs[kidx];\n        if (!mrb_hash_p(kdict) || mrb_hash_size(mrb, kdict) == 0) {\n          kdict = mrb_nil_value();\n          ci->nk = 0;\n        }\n      }\n      if (!kd && !mrb_nil_p(kdict)) {\n        if (argc < 14) {\n          ci->n++;\n          argc++;    /* include kdict in normal arguments */\n        }\n        else if (argc == 14) {\n          /* pack arguments and kdict */\n          regs[1] = mrb_ary_new_from_values(mrb, argc+1, &regs[1]);\n          argc = ci->n = 15;\n        }\n        else {/* argc == 15 */\n          /* push kdict to packed arguments */\n          mrb_ary_push(mrb, regs[1], regs[2]);\n        }\n        ci->nk = 0;\n      }\n      if (kd && MRB_ASPEC_KEY(a) > 0 && mrb_hash_p(kdict)) {\n        kdict = mrb_hash_dup(mrb, kdict);\n      }\n\n      /* arguments is passed with Array */\n      if (argc == 15) {\n        struct RArray *ary = mrb_ary_ptr(regs[1]);\n        argv = ARY_PTR(ary);\n        argc = (int)ARY_LEN(ary);\n        mrb_gc_protect(mrb, regs[1]);\n      }\n\n      /* strict argument check */\n      if (ci->proc && MRB_PROC_STRICT_P(ci->proc)) {\n        if (argc < m1 + m2 || (r == 0 && argc > len)) {\n          argnum_error(mrb, m1+m2);\n          goto L_RAISE;\n        }\n      }\n      /* extract first argument array to arguments */\n      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {\n        mrb_gc_protect(mrb, argv[0]);\n        argc = (int)RARRAY_LEN(argv[0]);\n        argv = RARRAY_PTR(argv[0]);\n      }\n\n      /* rest arguments */\n      mrb_value rest = mrb_nil_value();\n      if (argc < len) {\n        mrb_int mlen = m2;\n        if (argc < m1+m2) {\n          mlen = m1 < argc ? argc - m1 : 0;\n        }\n\n        /* copy mandatory and optional arguments */\n        if (argv0 != argv && argv) {\n          value_move(&regs[1], argv, argc-mlen); /* m1 + o */\n        }\n        if (argc < m1) {\n          stack_clear(&regs[argc+1], m1-argc);\n        }\n        /* copy post mandatory arguments */\n        if (mlen) {\n          value_move(&regs[len-m2+1], &argv[argc-mlen], mlen);\n        }\n        if (mlen < m2) {\n          stack_clear(&regs[len-m2+mlen+1], m2-mlen);\n        }\n        /* initialize rest arguments with empty Array */\n        if (r) {\n          rest = mrb_ary_new_capa(mrb, 0);\n          regs[m1+o+1] = rest;\n        }\n        /* skip initializer of passed arguments */\n        if (o > 0 && argc > m1+m2)\n          pc += (argc - m1 - m2)*3;\n      }\n      else {\n        mrb_int rnum = 0;\n        if (argv0 != argv) {\n          value_move(&regs[1], argv, m1+o);\n        }\n        if (r) {\n          rnum = argc-m1-o-m2;\n          rest = mrb_ary_new_from_values(mrb, rnum, argv+m1+o);\n          regs[m1+o+1] = rest;\n        }\n        if (m2 > 0 && argc-m2 > m1) {\n          value_move(&regs[m1+o+r+1], &argv[m1+o+rnum], m2);\n        }\n        pc += o*3;\n      }\n\n      /* need to be update blk first to protect blk from GC */\n      regs[blk_pos] = blk;              /* move block */\n      if (kd) {\n        if (mrb_nil_p(kdict))\n          kdict = mrb_hash_new_capa(mrb, 0);\n        regs[kw_pos] = kdict;           /* set kwhash */\n      }\n\n      /* format arguments for generated code */\n      mrb->c->ci->n = (uint8_t)len;\n\n      /* clear local (but non-argument) variables */\n      if (irep->nlocals-blk_pos-1 > 0) {\n        stack_clear(&regs[blk_pos+1], irep->nlocals-blk_pos-1);\n      }\n      JUMP;\n    }\n\n    CASE(OP_KARG, BB) {\n      mrb_value k = mrb_symbol_value(syms[b]);\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict, v;\n\n      if (kidx < 0 || !mrb_hash_p(kdict=regs[kidx]) || !mrb_hash_key_p(mrb, kdict, k)) {\n        mrb_value str = mrb_format(mrb, \"missing keyword: %v\", k);\n        mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));\n        goto L_RAISE;\n      }\n      v = mrb_hash_get(mrb, kdict, k);\n      regs[a] = v;\n      mrb_hash_delete_key(mrb, kdict, k);\n      NEXT;\n    }\n\n    CASE(OP_KEY_P, BB) {\n      mrb_value k = mrb_symbol_value(syms[b]);\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict;\n      mrb_bool key_p = FALSE;\n\n      if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx])) {\n        key_p = mrb_hash_key_p(mrb, kdict, k);\n      }\n      regs[a] = mrb_bool_value(key_p);\n      NEXT;\n    }\n\n    CASE(OP_KEYEND, Z) {\n      mrb_int kidx = mrb_ci_kidx(mrb->c->ci);\n      mrb_value kdict;\n\n      if (kidx >= 0 && mrb_hash_p(kdict=regs[kidx]) && !mrb_hash_empty_p(mrb, kdict)) {\n        mrb_value keys = mrb_hash_keys(mrb, kdict);\n        mrb_value key1 = RARRAY_PTR(keys)[0];\n        mrb_value str = mrb_format(mrb, \"unknown keyword: %v\", key1);\n        mrb_exc_set(mrb, mrb_exc_new_str(mrb, E_ARGUMENT_ERROR, str));\n        goto L_RAISE;\n      }\n      NEXT;\n    }\n\n    CASE(OP_BREAK, B) {\n      c = OP_R_BREAK;\n      goto L_RETURN;\n    }\n    CASE(OP_RETURN_BLK, B) {\n      c = OP_R_RETURN;\n      goto L_RETURN;\n    }\n    CASE(OP_RETURN, B)\n    c = OP_R_NORMAL;\n    L_RETURN:\n    {\n      mrb_callinfo *ci;\n\n      ci = mrb->c->ci;\n      if (ci->mid) {\n        mrb_value blk = regs[mrb_ci_bidx(ci)];\n\n        if (mrb_proc_p(blk)) {\n          struct RProc *p = mrb_proc_ptr(blk);\n\n          if (!MRB_PROC_STRICT_P(p) &&\n              ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb_vm_ci_env(&ci[-1])) {\n            p->flags |= MRB_PROC_ORPHAN;\n          }\n        }\n      }\n\n      if (mrb->exc) {\n      L_RAISE:\n        ci = mrb->c->ci;\n        if (ci == mrb->c->cibase) {\n          ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);\n          if (ch == NULL) goto L_FTOP;\n          goto L_CATCH;\n        }\n        while ((ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL)) == NULL) {\n          ci = cipop(mrb);\n          if (ci[1].cci == CINFO_SKIP && prev_jmp) {\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          pc = ci[0].pc;\n          if (ci == mrb->c->cibase) {\n            ch = catch_handler_find(mrb, ci, pc, MRB_CATCH_FILTER_ALL);\n            if (ch == NULL) {\n            L_FTOP:             /* fiber top */\n              if (mrb->c == mrb->root_c) {\n                mrb->c->ci->stack = mrb->c->stbase;\n                goto L_STOP;\n              }\n              else {\n                struct mrb_context *c = mrb->c;\n\n                c->status = MRB_FIBER_TERMINATED;\n                mrb->c = c->prev;\n                c->prev = NULL;\n                goto L_RAISE;\n              }\n            }\n            break;\n          }\n        }\n      L_CATCH:\n        if (ch == NULL) goto L_STOP;\n        if (FALSE) {\n        L_CATCH_TAGGED_BREAK: /* from THROW_TAGGED_BREAK() or UNWIND_ENSURE() */\n          ci = mrb->c->ci;\n        }\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n        mrb_stack_extend(mrb, irep->nregs);\n        pc = irep->iseq + mrb_irep_catch_handler_unpack(ch->target);\n      }\n      else {\n        mrb_int acc;\n        mrb_value v;\n\n        ci = mrb->c->ci;\n        v = regs[a];\n        mrb_gc_protect(mrb, v);\n        switch (c) {\n        case OP_R_RETURN:\n          /* Fall through to OP_R_NORMAL otherwise */\n          if (ci->cci == CINFO_NONE && MRB_PROC_ENV_P(proc) && !MRB_PROC_STRICT_P(proc)) {\n            const struct RProc *dst;\n            mrb_callinfo *cibase;\n            cibase = mrb->c->cibase;\n            dst = top_proc(mrb, proc);\n\n            if (MRB_PROC_ENV_P(dst)) {\n              struct REnv *e = MRB_PROC_ENV(dst);\n\n              if (!MRB_ENV_ONSTACK_P(e) || (e->cxt && e->cxt != mrb->c)) {\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n            }\n            /* check jump destination */\n            while (cibase <= ci && ci->proc != dst) {\n              if (ci->cci > CINFO_NONE) { /* jump cross C boundary */\n                localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n                goto L_RAISE;\n              }\n              ci--;\n            }\n            if (ci <= cibase) { /* no jump destination */\n              localjump_error(mrb, LOCALJUMP_ERROR_RETURN);\n              goto L_RAISE;\n            }\n            ci = mrb->c->ci;\n            while (cibase <= ci && ci->proc != dst) {\n              CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_BLOCK) {\n                cibase = mrb->c->cibase;\n                dst = top_proc(mrb, proc);\n              }\n              CHECKPOINT_MAIN(RBREAK_TAG_RETURN_BLOCK) {\n                UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_BLOCK, proc, v);\n              }\n              CHECKPOINT_END(RBREAK_TAG_RETURN_BLOCK);\n              ci = cipop(mrb);\n              pc = ci->pc;\n            }\n            proc = ci->proc;\n            mrb->exc = NULL; /* clear break object */\n            break;\n          }\n          /* fallthrough */\n        case OP_R_NORMAL:\n        NORMAL_RETURN:\n          if (ci == mrb->c->cibase) {\n            struct mrb_context *c;\n            c = mrb->c;\n\n            if (!c->prev) { /* toplevel return */\n              regs[irep->nlocals] = v;\n              goto CHECKPOINT_LABEL_MAKE(RBREAK_TAG_STOP);\n            }\n            if (!c->vmexec && c->prev->ci == c->prev->cibase) {\n              mrb_value exc = mrb_exc_new_lit(mrb, E_FIBER_ERROR, \"double resume\");\n              mrb_exc_set(mrb, exc);\n              goto L_RAISE;\n            }\n            CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_TOPLEVEL) {\n              c = mrb->c;\n            }\n            CHECKPOINT_MAIN(RBREAK_TAG_RETURN_TOPLEVEL) {\n              UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN_TOPLEVEL, proc, v);\n            }\n            CHECKPOINT_END(RBREAK_TAG_RETURN_TOPLEVEL);\n            /* automatic yield at the end */\n            c->status = MRB_FIBER_TERMINATED;\n            mrb->c = c->prev;\n            mrb->c->status = MRB_FIBER_RUNNING;\n            c->prev = NULL;\n            if (c->vmexec) {\n              mrb_gc_arena_restore(mrb, ai);\n              c->vmexec = FALSE;\n              mrb->jmp = prev_jmp;\n              return v;\n            }\n            ci = mrb->c->ci;\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_RETURN) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_RETURN) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_RETURN, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_RETURN);\n          mrb->exc = NULL; /* clear break object */\n          break;\n        case OP_R_BREAK:\n          if (MRB_PROC_STRICT_P(proc)) goto NORMAL_RETURN;\n          if (MRB_PROC_ORPHAN_P(proc)) {\n            mrb_value exc;\n\n          L_BREAK_ERROR:\n            exc = mrb_exc_new_lit(mrb, E_LOCALJUMP_ERROR,\n                                      \"break from proc-closure\");\n            mrb_exc_set(mrb, exc);\n            goto L_RAISE;\n          }\n          if (!MRB_PROC_ENV_P(proc) || !MRB_ENV_ONSTACK_P(MRB_PROC_ENV(proc))) {\n            goto L_BREAK_ERROR;\n          }\n          else {\n            struct REnv *e = MRB_PROC_ENV(proc);\n\n            if (e->cxt != mrb->c) {\n              goto L_BREAK_ERROR;\n            }\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_BREAK) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_BREAK);\n          /* break from fiber block */\n          if (ci == mrb->c->cibase && ci->pc) {\n            struct mrb_context *c = mrb->c;\n\n            mrb->c = c->prev;\n            c->prev = NULL;\n            ci = mrb->c->ci;\n          }\n          if (ci->cci > CINFO_NONE) {\n            ci = cipop(mrb);\n            mrb->exc = (struct RObject*)break_new(mrb, RBREAK_TAG_BREAK, proc, v);\n            mrb_gc_arena_restore(mrb, ai);\n            mrb->c->vmexec = FALSE;\n            mrb->jmp = prev_jmp;\n            MRB_THROW(prev_jmp);\n          }\n          if (FALSE) {\n            struct RBreak *brk;\n\n          L_BREAK:\n            brk = (struct RBreak*)mrb->exc;\n            proc = mrb_break_proc_get(brk);\n            v = mrb_break_value_get(brk);\n            ci = mrb->c->ci;\n\n            switch (mrb_break_tag_get(brk)) {\n#define DISPATCH_CHECKPOINTS(n, i) case n: goto CHECKPOINT_LABEL_MAKE(n);\n              RBREAK_TAG_FOREACH(DISPATCH_CHECKPOINTS)\n#undef DISPATCH_CHECKPOINTS\n              default:\n                mrb_assert(!\"wrong break tag\");\n            }\n          }\n          while (mrb->c->cibase < ci && ci[-1].proc != proc->upper) {\n            if (ci[-1].cci == CINFO_SKIP) {\n              goto L_BREAK_ERROR;\n            }\n            CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_UPPER) {\n              /* do nothing */\n            }\n            CHECKPOINT_MAIN(RBREAK_TAG_BREAK_UPPER) {\n              UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_UPPER, proc, v);\n            }\n            CHECKPOINT_END(RBREAK_TAG_BREAK_UPPER);\n            ci = cipop(mrb);\n            pc = ci->pc;\n          }\n          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_INTARGET) {\n            /* do nothing */\n          }\n          CHECKPOINT_MAIN(RBREAK_TAG_BREAK_INTARGET) {\n            UNWIND_ENSURE(mrb, ci, pc, RBREAK_TAG_BREAK_INTARGET, proc, v);\n          }\n          CHECKPOINT_END(RBREAK_TAG_BREAK_INTARGET);\n          if (ci == mrb->c->cibase) {\n            goto L_BREAK_ERROR;\n          }\n          mrb->exc = NULL; /* clear break object */\n          break;\n        default:\n          /* cannot happen */\n          break;\n        }\n        mrb_assert(ci == mrb->c->ci);\n        mrb_assert(mrb->exc == NULL);\n\n        if (mrb->c->vmexec && !mrb_vm_ci_target_class(ci)) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->c->vmexec = FALSE;\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        acc = ci->cci;\n        ci = cipop(mrb);\n        if (acc == CINFO_SKIP || acc == CINFO_DIRECT) {\n          mrb_gc_arena_restore(mrb, ai);\n          mrb->jmp = prev_jmp;\n          return v;\n        }\n        pc = ci->pc;\n        DEBUG(fprintf(stderr, \"from :%s\\n\", mrb_sym_name(mrb, ci->mid)));\n        proc = ci->proc;\n        irep = proc->body.irep;\n        pool = irep->pool;\n        syms = irep->syms;\n\n        ci[1].stack[0] = v;\n        mrb_gc_arena_restore(mrb, ai);\n      }\n      JUMP;\n    }\n\n    CASE(OP_BLKPUSH, BS) {\n      int m1 = (b>>11)&0x3f;\n      int r  = (b>>10)&0x1;\n      int m2 = (b>>5)&0x1f;\n      int kd = (b>>4)&0x1;\n      int lv = (b>>0)&0xf;\n      mrb_value *stack;\n\n      if (lv == 0) stack = regs + 1;\n      else {\n        struct REnv *e = uvenv(mrb, lv-1);\n        if (!e || (!MRB_ENV_ONSTACK_P(e) && e->mid == 0) ||\n            MRB_ENV_LEN(e) <= m1+r+m2+1) {\n          localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n          goto L_RAISE;\n        }\n        stack = e->stack + 1;\n      }\n      if (mrb_nil_p(stack[m1+r+m2+kd])) {\n        localjump_error(mrb, LOCALJUMP_ERROR_YIELD);\n        goto L_RAISE;\n      }\n      regs[a] = stack[m1+r+m2+kd];\n      NEXT;\n    }\n\n#if !defined(MRB_USE_BIGINT) || defined(MRB_INT32)\n  L_INT_OVERFLOW:\n    {\n      mrb_value exc = mrb_exc_new_lit(mrb, E_RANGE_ERROR, \"integer overflow\");\n      mrb_exc_set(mrb, exc);\n    }\n    goto L_RAISE;\n#endif\n\n#define TYPES2(a,b) ((((uint16_t)(a))<<8)|(((uint16_t)(b))&0xff))\n#define OP_MATH(op_name)                                                    \\\n  /* need to check if op is overridden */                                   \\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {                  \\\n    OP_MATH_CASE_INTEGER(op_name);                                          \\\n    OP_MATH_CASE_FLOAT(op_name, integer, float);                            \\\n    OP_MATH_CASE_FLOAT(op_name, float,  integer);                           \\\n    OP_MATH_CASE_FLOAT(op_name, float,  float);                             \\\n    OP_MATH_CASE_STRING_##op_name();                                        \\\n    default:                                                                \\\n      mid = MRB_OPSYM(op_name);                                             \\\n      goto L_SEND_SYM;                                                      \\\n  }                                                                         \\\n  NEXT;\n#define OP_MATH_CASE_INTEGER(op_name)                                       \\\n  case TYPES2(MRB_TT_INTEGER, MRB_TT_INTEGER):                              \\\n    {                                                                       \\\n      mrb_int x = mrb_integer(regs[a]), y = mrb_integer(regs[a+1]), z;      \\\n      if (mrb_int_##op_name##_overflow(x, y, &z)) {                         \\\n        OP_MATH_OVERFLOW_INT(op_name,x,y);                                  \\\n      }                                                                     \\\n      else                                                                  \\\n        SET_INT_VALUE(mrb,regs[a], z);                                      \\\n    }                                                                       \\\n    break\n#ifdef MRB_NO_FLOAT\n#define OP_MATH_CASE_FLOAT(op_name, t1, t2) (void)0\n#else\n#define OP_MATH_CASE_FLOAT(op_name, t1, t2)                                     \\\n  case TYPES2(OP_MATH_TT_##t1, OP_MATH_TT_##t2):                                \\\n    {                                                                           \\\n      mrb_float z = mrb_##t1(regs[a]) OP_MATH_OP_##op_name mrb_##t2(regs[a+1]); \\\n      SET_FLOAT_VALUE(mrb, regs[a], z);                                         \\\n    }                                                                           \\\n    break\n#endif\n#ifdef MRB_USE_BIGINT\n#define OP_MATH_OVERFLOW_INT(op,x,y) regs[a] = mrb_bint_##op##_ii(mrb,x,y)\n#else\n#define OP_MATH_OVERFLOW_INT(op,x,y) goto L_INT_OVERFLOW\n#endif\n#define OP_MATH_CASE_STRING_add()                                           \\\n  case TYPES2(MRB_TT_STRING, MRB_TT_STRING):                                \\\n    regs[a] = mrb_str_plus(mrb, regs[a], regs[a+1]);                        \\\n    mrb_gc_arena_restore(mrb, ai);                                          \\\n    break\n#define OP_MATH_CASE_STRING_sub() (void)0\n#define OP_MATH_CASE_STRING_mul() (void)0\n#define OP_MATH_OP_add +\n#define OP_MATH_OP_sub -\n#define OP_MATH_OP_mul *\n#define OP_MATH_TT_integer MRB_TT_INTEGER\n#define OP_MATH_TT_float   MRB_TT_FLOAT\n\n    CASE(OP_ADD, B) {\n      OP_MATH(add);\n    }\n\n    CASE(OP_SUB, B) {\n      OP_MATH(sub);\n    }\n\n    CASE(OP_MUL, B) {\n      OP_MATH(mul);\n    }\n\n    CASE(OP_DIV, B) {\n#ifndef MRB_NO_FLOAT\n      mrb_float x, y, f;\n#endif\n\n      /* need to check if op is overridden */\n      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\n      case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\n        {\n          mrb_int x = mrb_integer(regs[a]);\n          mrb_int y = mrb_integer(regs[a+1]);\n          mrb_int div = mrb_div_int(mrb, x, y);\n          SET_INT_VALUE(mrb, regs[a], div);\n        }\n        NEXT;\n#ifndef MRB_NO_FLOAT\n      case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\n        x = (mrb_float)mrb_integer(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\n        x = mrb_float(regs[a]);\n        y = (mrb_float)mrb_integer(regs[a+1]);\n        break;\n      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\n        x = mrb_float(regs[a]);\n        y = mrb_float(regs[a+1]);\n        break;\n#endif\n      default:\n        mid = MRB_OPSYM(div);\n        goto L_SEND_SYM;\n      }\n\n#ifndef MRB_NO_FLOAT\n      f = mrb_div_float(x, y);\n      SET_FLOAT_VALUE(mrb, regs[a], f);\n#endif\n      NEXT;\n    }\n\n#define OP_MATHI(op_name)                                                   \\\n  /* need to check if op is overridden */                                   \\\n  switch (mrb_type(regs[a])) {                                              \\\n    OP_MATHI_CASE_INTEGER(op_name);                                         \\\n    OP_MATHI_CASE_FLOAT(op_name);                                           \\\n    default:                                                                \\\n      SET_INT_VALUE(mrb,regs[a+1], b);                                      \\\n      mid = MRB_OPSYM(op_name);                                             \\\n      goto L_SEND_SYM;                                                      \\\n  }                                                                         \\\n  NEXT;\n#define OP_MATHI_CASE_INTEGER(op_name)                                      \\\n  case MRB_TT_INTEGER:                                                      \\\n    {                                                                       \\\n      mrb_int x = mrb_integer(regs[a]), y = (mrb_int)b, z;                  \\\n      if (mrb_int_##op_name##_overflow(x, y, &z)) {                         \\\n        OP_MATH_OVERFLOW_INT(op_name,x,y);                                  \\\n      }                                                                     \\\n      else                                                                  \\\n        SET_INT_VALUE(mrb,regs[a], z);                                      \\\n    }                                                                       \\\n    break\n#ifdef MRB_NO_FLOAT\n#define OP_MATHI_CASE_FLOAT(op_name) (void)0\n#else\n#define OP_MATHI_CASE_FLOAT(op_name)                                        \\\n  case MRB_TT_FLOAT:                                                        \\\n    {                                                                       \\\n      mrb_float z = mrb_float(regs[a]) OP_MATH_OP_##op_name b;              \\\n      SET_FLOAT_VALUE(mrb, regs[a], z);                                     \\\n    }                                                                       \\\n    break\n#endif\n\n    CASE(OP_ADDI, BB) {\n      OP_MATHI(add);\n    }\n\n    CASE(OP_SUBI, BB) {\n      OP_MATHI(sub);\n    }\n\n#define OP_CMP_BODY(op,v1,v2) (v1(regs[a]) op v2(regs[a+1]))\n\n#ifdef MRB_NO_FLOAT\n#define OP_CMP(op,sym) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  default:\\\n    mid = MRB_OPSYM(sym);\\\n    goto L_SEND_SYM;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#else\n#define OP_CMP(op, sym) do {\\\n  int result;\\\n  /* need to check if - is overridden */\\\n  switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_fixnum,mrb_float);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_fixnum);\\\n    break;\\\n  case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\\\n    result = OP_CMP_BODY(op,mrb_float,mrb_float);\\\n    break;\\\n  default:\\\n    mid = MRB_OPSYM(sym);\\\n    goto L_SEND_SYM;\\\n  }\\\n  if (result) {\\\n    SET_TRUE_VALUE(regs[a]);\\\n  }\\\n  else {\\\n    SET_FALSE_VALUE(regs[a]);\\\n  }\\\n} while(0)\n#endif\n\n    CASE(OP_EQ, B) {\n      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {\n        SET_TRUE_VALUE(regs[a]);\n      }\n      else {\n        OP_CMP(==,eq);\n      }\n      NEXT;\n    }\n\n    CASE(OP_LT, B) {\n      OP_CMP(<,lt);\n      NEXT;\n    }\n\n    CASE(OP_LE, B) {\n      OP_CMP(<=,le);\n      NEXT;\n    }\n\n    CASE(OP_GT, B) {\n      OP_CMP(>,gt);\n      NEXT;\n    }\n\n    CASE(OP_GE, B) {\n      OP_CMP(>=,ge);\n      NEXT;\n    }\n\n    CASE(OP_ARRAY, BB) {\n      regs[a] = mrb_ary_new_from_values(mrb, b, &regs[a]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_ARRAY2, BBB) {\n      regs[a] = mrb_ary_new_from_values(mrb, c, &regs[b]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYCAT, B) {\n      mrb_value splat = mrb_ary_splat(mrb, regs[a+1]);\n      if (mrb_nil_p(regs[a])) {\n        regs[a] = splat;\n      }\n      else {\n        mrb_assert(mrb_array_p(regs[a]));\n        mrb_ary_concat(mrb, regs[a], splat);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_ARYPUSH, BB) {\n      mrb_assert(mrb_array_p(regs[a]));\n      for (mrb_int i=0; i<b; i++) {\n        mrb_ary_push(mrb, regs[a], regs[a+i+1]);\n      }\n      NEXT;\n    }\n\n    CASE(OP_ARYDUP, B) {\n      mrb_value ary = regs[a];\n      if (mrb_array_p(ary)) {\n        ary = mrb_ary_new_from_values(mrb, RARRAY_LEN(ary), RARRAY_PTR(ary));\n      }\n      else {\n        ary = mrb_ary_new_from_values(mrb, 1, &ary);\n      }\n      regs[a] = ary;\n      NEXT;\n    }\n\n    CASE(OP_AREF, BBB) {\n      mrb_value v = regs[b];\n\n      if (!mrb_array_p(v)) {\n        if (c == 0) {\n          regs[a] = v;\n        }\n        else {\n          SET_NIL_VALUE(regs[a]);\n        }\n      }\n      else {\n        v = mrb_ary_ref(mrb, v, c);\n        regs[a] = v;\n      }\n      NEXT;\n    }\n\n    CASE(OP_ASET, BBB) {\n      mrb_assert(mrb_array_p(regs[a]));\n      mrb_ary_set(mrb, regs[b], c, regs[a]);\n      NEXT;\n    }\n\n    CASE(OP_APOST, BBB) {\n      mrb_value v = regs[a];\n      int pre  = b;\n      int post = c;\n      struct RArray *ary;\n      int len, idx;\n\n      if (!mrb_array_p(v)) {\n        v = mrb_ary_new_from_values(mrb, 1, &regs[a]);\n      }\n      ary = mrb_ary_ptr(v);\n      len = (int)ARY_LEN(ary);\n      if (len > pre + post) {\n        v = mrb_ary_new_from_values(mrb, len - pre - post, ARY_PTR(ary)+pre);\n        regs[a++] = v;\n        while (post--) {\n          regs[a++] = ARY_PTR(ary)[len-post-1];\n        }\n      }\n      else {\n        v = mrb_ary_new_capa(mrb, 0);\n        regs[a++] = v;\n        for (idx=0; idx+pre<len; idx++) {\n          regs[a+idx] = ARY_PTR(ary)[pre+idx];\n        }\n        while (idx < post) {\n          SET_NIL_VALUE(regs[a+idx]);\n          idx++;\n        }\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_INTERN, B) {\n      mrb_assert(mrb_string_p(regs[a]));\n      mrb_sym sym = mrb_intern_str(mrb, regs[a]);\n      regs[a] = mrb_symbol_value(sym);\n      NEXT;\n    }\n\n    CASE(OP_SYMBOL, BB) {\n      size_t len;\n      mrb_sym sym;\n\n      mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);\n      len = pool[b].tt >> 2;\n      if (pool[b].tt & IREP_TT_SFLAG) {\n        sym = mrb_intern_static(mrb, pool[b].u.str, len);\n      }\n      else {\n        sym  = mrb_intern(mrb, pool[b].u.str, len);\n      }\n      regs[a] = mrb_symbol_value(sym);\n      NEXT;\n    }\n\n    CASE(OP_STRING, BB) {\n      mrb_int len;\n\n      mrb_assert((pool[b].tt&IREP_TT_NFLAG)==0);\n      len = pool[b].tt >> 2;\n      if (pool[b].tt & IREP_TT_SFLAG) {\n        regs[a] = mrb_str_new_static(mrb, pool[b].u.str, len);\n      }\n      else {\n        regs[a] = mrb_str_new(mrb, pool[b].u.str, len);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_STRCAT, B) {\n      mrb_assert(mrb_string_p(regs[a]));\n      mrb_str_concat(mrb, regs[a], regs[a+1]);\n      NEXT;\n    }\n\n    CASE(OP_HASH, BB) {\n      mrb_value hash = mrb_hash_new_capa(mrb, b);\n      int i;\n      int lim = a+b*2;\n\n      for (i=a; i<lim; i+=2) {\n        mrb_hash_set(mrb, hash, regs[i], regs[i+1]);\n      }\n      regs[a] = hash;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_HASHADD, BB) {\n      mrb_value hash;\n      int i;\n      int lim = a+b*2+1;\n\n      hash = regs[a];\n      mrb_ensure_hash_type(mrb, hash);\n      for (i=a+1; i<lim; i+=2) {\n        mrb_hash_set(mrb, hash, regs[i], regs[i+1]);\n      }\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_HASHCAT, B) {\n      mrb_value hash = regs[a];\n\n      mrb_assert(mrb_hash_p(hash));\n      mrb_hash_merge(mrb, hash, regs[a+1]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_LAMBDA, BB)\n    c = OP_L_LAMBDA;\n    L_MAKE_LAMBDA:\n    {\n      struct RProc *p;\n      const mrb_irep *nirep = irep->reps[b];\n\n      if (c & OP_L_CAPTURE) {\n        p = mrb_closure_new(mrb, nirep);\n      }\n      else {\n        p = mrb_proc_new(mrb, nirep);\n        p->flags |= MRB_PROC_SCOPE;\n      }\n      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;\n      regs[a] = mrb_obj_value(p);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n    CASE(OP_BLOCK, BB) {\n      c = OP_L_BLOCK;\n      goto L_MAKE_LAMBDA;\n    }\n    CASE(OP_METHOD, BB) {\n      c = OP_L_METHOD;\n      goto L_MAKE_LAMBDA;\n    }\n\n    CASE(OP_RANGE_INC, B) {\n      mrb_value v = mrb_range_new(mrb, regs[a], regs[a+1], FALSE);\n      regs[a] = v;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_RANGE_EXC, B) {\n      mrb_value v = mrb_range_new(mrb, regs[a], regs[a+1], TRUE);\n      regs[a] = v;\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_OCLASS, B) {\n      regs[a] = mrb_obj_value(mrb->object_class);\n      NEXT;\n    }\n\n    CASE(OP_CLASS, BB) {\n      struct RClass *c = 0, *baseclass;\n      mrb_value base, super;\n      mrb_sym id = syms[b];\n\n      base = regs[a];\n      super = regs[a+1];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        if (!baseclass) baseclass = mrb->object_class;\n        base = mrb_obj_value(baseclass);\n      }\n      c = mrb_vm_define_class(mrb, base, super, id);\n      regs[a] = mrb_obj_value(c);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_MODULE, BB) {\n      struct RClass *cls = 0, *baseclass;\n      mrb_value base;\n      mrb_sym id = syms[b];\n\n      base = regs[a];\n      if (mrb_nil_p(base)) {\n        baseclass = MRB_PROC_TARGET_CLASS(mrb->c->ci->proc);\n        if (!baseclass) baseclass = mrb->object_class;\n        base = mrb_obj_value(baseclass);\n      }\n      cls = mrb_vm_define_module(mrb, base, id);\n      regs[a] = mrb_obj_value(cls);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_EXEC, BB)\n    {\n      mrb_value recv = regs[a];\n      struct RProc *p;\n      const mrb_irep *nirep = irep->reps[b];\n\n      /* prepare closure */\n      p = mrb_proc_new(mrb, nirep);\n      p->c = NULL;\n      mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)proc);\n      MRB_PROC_SET_TARGET_CLASS(p, mrb_class_ptr(recv));\n      p->flags |= MRB_PROC_SCOPE;\n\n      /* prepare call stack */\n      cipush(mrb, a, 0, mrb_class_ptr(recv), p, 0, 0);\n\n      irep = p->body.irep;\n      pool = irep->pool;\n      syms = irep->syms;\n      mrb_stack_extend(mrb, irep->nregs);\n      stack_clear(regs+1, irep->nregs-1);\n      pc = irep->iseq;\n      JUMP;\n    }\n\n    CASE(OP_DEF, BB) {\n      struct RClass *target = mrb_class_ptr(regs[a]);\n      struct RProc *p = mrb_proc_ptr(regs[a+1]);\n      mrb_method_t m;\n      mrb_sym mid = syms[b];\n\n      MRB_METHOD_FROM_PROC(m, p);\n      mrb_define_method_raw(mrb, target, mid, m);\n      mrb_method_added(mrb, target, mid);\n      mrb_gc_arena_restore(mrb, ai);\n      regs[a] = mrb_symbol_value(mid);\n      NEXT;\n    }\n\n    CASE(OP_SCLASS, B) {\n      regs[a] = mrb_singleton_class(mrb, regs[a]);\n      mrb_gc_arena_restore(mrb, ai);\n      NEXT;\n    }\n\n    CASE(OP_TCLASS, B) {\n      struct RClass *target = check_target_class(mrb);\n      if (!target) goto L_RAISE;\n      regs[a] = mrb_obj_value(target);\n      NEXT;\n    }\n\n    CASE(OP_ALIAS, BB) {\n      struct RClass *target = check_target_class(mrb);\n\n      if (!target) goto L_RAISE;\n      mrb_alias_method(mrb, target, syms[a], syms[b]);\n      mrb_method_added(mrb, target, syms[a]);\n      NEXT;\n    }\n    CASE(OP_UNDEF, B) {\n      struct RClass *target = check_target_class(mrb);\n\n      if (!target) goto L_RAISE;\n      mrb_undef_method_id(mrb, target, syms[a]);\n      NEXT;\n    }\n\n    CASE(OP_DEBUG, Z) {\n      FETCH_BBB();\n#ifdef MRB_USE_DEBUG_HOOK\n      mrb->debug_op_hook(mrb, irep, pc, regs);\n#else\n#ifndef MRB_NO_STDIO\n      printf(\"OP_DEBUG %d %d %d\\n\", a, b, c);\n#else\n      abort();\n#endif\n#endif\n      NEXT;\n    }\n\n    CASE(OP_ERR, B) {\n      size_t len = pool[a].tt >> 2;\n      mrb_value exc;\n\n      mrb_assert((pool[a].tt&IREP_TT_NFLAG)==0);\n      exc = mrb_exc_new(mrb, E_LOCALJUMP_ERROR, pool[a].u.str, len);\n      mrb_exc_set(mrb, exc);\n      goto L_RAISE;\n    }\n\n    CASE(OP_EXT1, Z) {\n      insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _1(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n    CASE(OP_EXT2, Z) {\n      insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _2(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n    CASE(OP_EXT3, Z) {\n      uint8_t insn = READ_B();\n      switch (insn) {\n#define OPCODE(insn,ops) case OP_ ## insn: FETCH_ ## ops ## _3(); mrb->c->ci->pc = pc; goto L_OP_ ## insn ## _BODY;\n#include \"mruby/ops.h\"\n#undef OPCODE\n      }\n      pc--;\n      NEXT;\n    }\n\n    CASE(OP_STOP, Z) {\n      /*        stop VM */\n      CHECKPOINT_RESTORE(RBREAK_TAG_STOP) {\n        /* do nothing */\n      }\n      CHECKPOINT_MAIN(RBREAK_TAG_STOP) {\n        UNWIND_ENSURE(mrb, mrb->c->ci, pc, RBREAK_TAG_STOP, proc, mrb_nil_value());\n      }\n      CHECKPOINT_END(RBREAK_TAG_STOP);\n    L_STOP:\n      mrb->jmp = prev_jmp;\n      if (mrb->exc) {\n        mrb_assert(mrb->exc->tt == MRB_TT_EXCEPTION);\n        return mrb_obj_value(mrb->exc);\n      }\n      return regs[irep->nlocals];\n    }\n  }\n  END_DISPATCH;\n#undef regs\n  }\n  MRB_CATCH(&c_jmp) {\n    mrb_callinfo *ci = mrb->c->ci;\n    while (ci > mrb->c->cibase && ci->cci == CINFO_DIRECT) {\n      ci = cipop(mrb);\n    }\n    exc_catched = TRUE;\n    pc = ci->pc;\n    goto RETRY_TRY_BLOCK;\n  }\n  MRB_END_EXC(&c_jmp);\n}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "rizin",
    "cve_id": "CVE-2021-43814",
    "cwe_list": [
      "CWE-787"
    ],
    "commit_hash": "aa6917772d2f32e5a7daab25a46c72df0b5ea406",
    "short_hash": "aa691777",
    "vulnerableMethods_before": [
      {
        "filename": "dwarf.c",
        "method_name": "vulnerable_function",
        "raw_code": "static const ut8 *parse_die(const ut8 *buf, const ut8 *buf_end, RzBinDwarfDebugInfo *info, RzBinDwarfAbbrevDecl *abbrev,\n\tRzBinDwarfCompUnitHdr *hdr, RzBinDwarfDie *die, const ut8 *debug_str, size_t debug_str_len, bool big_endian) {\n\tsize_t i;\n\tconst char *comp_dir = NULL;\n\tut64 line_info_offset = UT64_MAX;\n\tfor (i = 0; i < abbrev->count - 1; i++) {\n\t\tmemset(&die->attr_values[i], 0, sizeof(die->attr_values[i]));\n\n\t\tbuf = parse_attr_value(buf, buf_end - buf, &abbrev->defs[i],\n\t\t\t&die->attr_values[i], hdr, debug_str, debug_str_len, big_endian);\n\n\t\tRzBinDwarfAttrValue *attribute = &die->attr_values[i];\n\n\t\tif (attribute->attr_name == DW_AT_comp_dir && (attribute->attr_form == DW_FORM_strp || attribute->attr_form == DW_FORM_string) && attribute->string.content) {\n\t\t\tcomp_dir = attribute->string.content;\n\t\t}\n\t\tif (attribute->attr_name == DW_AT_stmt_list) {\n\t\t\tif (attribute->kind == DW_AT_KIND_CONSTANT) {\n\t\t\t\tline_info_offset = attribute->uconstant;\n\t\t\t} else if (attribute->kind == DW_AT_KIND_REFERENCE) {\n\t\t\t\tline_info_offset = attribute->reference;\n\t\t\t}\n\t\t}\n\t\tdie->count++;\n\t}\n\n\t// If this is a compilation unit dir attribute, we want to cache it so the line info parsing\n\t// which will need this info can quickly look it up.\n\tif (comp_dir && line_info_offset != UT64_MAX) {\n\t\tchar *name = strdup(comp_dir);\n\t\tif (name) {\n\t\t\tif (!ht_up_insert(info->line_info_offset_comp_dir, line_info_offset, name)) {\n\t\t\t\tfree(name);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn buf;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "dwarf.c",
        "method_name": "fixed_function",
        "raw_code": "static const ut8 *parse_die(const ut8 *buf, const ut8 *buf_end, RzBinDwarfDebugInfo *info, RzBinDwarfAbbrevDecl *abbrev,\n\tRzBinDwarfCompUnitHdr *hdr, RzBinDwarfDie *die, const ut8 *debug_str, size_t debug_str_len, bool big_endian) {\n\tsize_t i;\n\tconst char *comp_dir = NULL;\n\tut64 line_info_offset = UT64_MAX;\n\tif (abbrev->count) {\n\t\tfor (i = 0; i < abbrev->count - 1; i++) {\n\t\t\tmemset(&die->attr_values[i], 0, sizeof(die->attr_values[i]));\n\n\t\t\tbuf = parse_attr_value(buf, buf_end - buf, &abbrev->defs[i],\n\t\t\t\t&die->attr_values[i], hdr, debug_str, debug_str_len, big_endian);\n\n\t\t\tRzBinDwarfAttrValue *attribute = &die->attr_values[i];\n\n\t\t\tif (attribute->attr_name == DW_AT_comp_dir && (attribute->attr_form == DW_FORM_strp || attribute->attr_form == DW_FORM_string) && attribute->string.content) {\n\t\t\t\tcomp_dir = attribute->string.content;\n\t\t\t}\n\t\t\tif (attribute->attr_name == DW_AT_stmt_list) {\n\t\t\t\tif (attribute->kind == DW_AT_KIND_CONSTANT) {\n\t\t\t\t\tline_info_offset = attribute->uconstant;\n\t\t\t\t} else if (attribute->kind == DW_AT_KIND_REFERENCE) {\n\t\t\t\t\tline_info_offset = attribute->reference;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdie->count++;\n\t\t}\n\t}\n\n\t// If this is a compilation unit dir attribute, we want to cache it so the line info parsing\n\t// which will need this info can quickly look it up.\n\tif (comp_dir && line_info_offset != UT64_MAX) {\n\t\tchar *name = strdup(comp_dir);\n\t\tif (name) {\n\t\t\tif (!ht_up_insert(info->line_info_offset_comp_dir, line_info_offset, name)) {\n\t\t\t\tfree(name);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn buf;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <errno.h>\n#include <rz_core.h>\n#include <rz_bin.h>\n#include <rz_bin_dwarf.h>\n\n// Type Definitions:\n// RzBinDwarfDie:\ntypedef struct {\n\tut64 tag;\n\tut64 abbrev_code;\n\tsize_t count;\n\tsize_t capacity;\n\tut64 offset; // important for parsing types\n\tbool has_children; // important for parsing types\n\tRzBinDwarfAttrValue *attr_values;\n}\n\n// RzBinDwarfDebugInfo:\ntypedef struct {\n\tsize_t count;\n\tsize_t capacity;\n\tRzBinDwarfCompUnit *comp_units;\n\tHtUP /*<ut64 offset, DwarfDie *die>*/ *lookup_table;\n\n\t/**\n\t * Cache mapping from an offset in the debug_line section to a string\n\t * representing the DW_AT_comp_dir attribute of the compilation unit\n\t * that references this particular line information.\n\t */\n\tHtUP /*<ut64, char *>*/ *line_info_offset_comp_dir;\n}\n\n// RzBinDwarfAbbrevDecl:\ntypedef struct {\n\tut64 code;\n\tut64 tag;\n\tut64 offset;\n\tut8 has_children;\n\tsize_t count;\n\tsize_t capacity;\n\tRzBinDwarfAttrDef *defs;\n}\n\n// RzBinDwarfAttrValue:\ntypedef struct dwarf_attr_kind {\n\tut64 attr_name;\n\tut64 attr_form;\n\tRzBinDwarfAttrKind kind;\n\t/* This is subideal, as dw_form_data can be anything\n\t   we could lose information example: encoding signed\n\t   2 byte int into ut64 and then interpreting it as st64 TODO*/\n\tunion {\n\t\tut64 address;\n\t\tRzBinDwarfBlock block;\n\t\tut64 uconstant;\n\t\tst64 sconstant;\n\t\tut8 flag;\n\t\tut64 reference;\n\t\tstruct {\n\t\t\tconst char *content;\n\t\t\tut64 offset;\n\t\t} string;\n\t};\n} RzBinDwarfAttrValue;\n\n// RzBinDwarfCompUnitHdr:\ntypedef struct {\n\t// A 4-byte (or 8 byte for 64bit dwarf) unsigned length of the .debug_info contribution\n\t// for that compilation unit, not including the length field itself.\n\tut64 length;\n\tut16 version;\n\t// A 4-byte unsigned offset into the .debug_abbrev section.\n\tut64 abbrev_offset;\n\t// A 1 - byte size of an address on the target architecture.If the system uses\n\t//  segmented addressing, this value represents the size of the offset portion of an address.\n\tut8 address_size;\n\tut8 unit_type; // DWARF 5 addition\n\tut8 dwo_id; // DWARF 5 addition\n\tut64 type_sig; // DWARF 5 addition\n\tut64 type_offset; // DWARF 5 addition\n\tut64 header_size; // excluding length field\n\tut64 unit_offset;\n\tbool is_64bit;\n}\n\n// Called Methods (top 10):\n// READ32 from librz/bin/dwarf.c:\n\n\n// READ8 from librz/bin/dwarf.c:\n\n\n// READ16 from librz/bin/dwarf.c:\n\n\n// READ64 from librz/bin/dwarf.c:\n\n\n// dwarf_read_offset from librz/bin/dwarf.c:\n\n\n// fill_block_data from librz/bin/dwarf.c:\n\n\n// parse_attr_value from librz/bin/dwarf.c:\n\n"
  },
  {
    "repository": "flatpak",
    "cve_id": "CVE-2021-41133",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "462fca2c666e0cd2b60d6d2593a7216a83047aaf",
    "short_hash": "462fca2c",
    "vulnerableMethods_before": [
      {
        "filename": "flatpak-run.c",
        "method_name": "vulnerable_function",
        "raw_code": "setup_seccomp (FlatpakBwrap   *bwrap,\n               const char     *arch,\n               gulong          allowed_personality,\n               FlatpakRunFlags run_flags,\n               GError        **error)\n{\n  gboolean multiarch = (run_flags & FLATPAK_RUN_FLAG_MULTIARCH) != 0;\n  gboolean devel = (run_flags & FLATPAK_RUN_FLAG_DEVEL) != 0;\n\n  __attribute__((cleanup (cleanup_seccomp))) scmp_filter_ctx seccomp = NULL;\n\n  /**** BEGIN NOTE ON CODE SHARING\n   *\n   * There are today a number of different Linux container\n   * implementations.  That will likely continue for long into the\n   * future.  But we can still try to share code, and it's important\n   * to do so because it affects what library and application writers\n   * can do, and we should support code portability between different\n   * container tools.\n   *\n   * This syscall blocklist is copied from linux-user-chroot, which was in turn\n   * clearly influenced by the Sandstorm.io blocklist.\n   *\n   * If you make any changes here, I suggest sending the changes along\n   * to other sandbox maintainers.  Using the libseccomp list is also\n   * an appropriate venue:\n   * https://groups.google.com/forum/#!forum/libseccomp\n   *\n   * A non-exhaustive list of links to container tooling that might\n   * want to share this blocklist:\n   *\n   *  https://github.com/sandstorm-io/sandstorm\n   *    in src/sandstorm/supervisor.c++\n   *  https://github.com/flatpak/flatpak.git\n   *    in common/flatpak-run.c\n   *  https://git.gnome.org/browse/linux-user-chroot\n   *    in src/setup-seccomp.c\n   *\n   * Other useful resources:\n   * https://github.com/systemd/systemd/blob/HEAD/src/shared/seccomp-util.c\n   * https://github.com/moby/moby/blob/HEAD/profiles/seccomp/default.json\n   *\n   **** END NOTE ON CODE SHARING\n   */\n  struct\n  {\n    int                  scall;\n    int                  errnum;\n    struct scmp_arg_cmp *arg;\n  } syscall_blocklist[] = {\n    /* Block dmesg */\n    {SCMP_SYS (syslog), EPERM},\n    /* Useless old syscall */\n    {SCMP_SYS (uselib), EPERM},\n    /* Don't allow disabling accounting */\n    {SCMP_SYS (acct), EPERM},\n    /* 16-bit code is unnecessary in the sandbox, and modify_ldt is a\n       historic source of interesting information leaks. */\n    {SCMP_SYS (modify_ldt), EPERM},\n    /* Don't allow reading current quota use */\n    {SCMP_SYS (quotactl), EPERM},\n\n    /* Don't allow access to the kernel keyring */\n    {SCMP_SYS (add_key), EPERM},\n    {SCMP_SYS (keyctl), EPERM},\n    {SCMP_SYS (request_key), EPERM},\n\n    /* Scary VM/NUMA ops */\n    {SCMP_SYS (move_pages), EPERM},\n    {SCMP_SYS (mbind), EPERM},\n    {SCMP_SYS (get_mempolicy), EPERM},\n    {SCMP_SYS (set_mempolicy), EPERM},\n    {SCMP_SYS (migrate_pages), EPERM},\n\n    /* Don't allow subnamespace setups: */\n    {SCMP_SYS (unshare), EPERM},\n    {SCMP_SYS (setns), EPERM},\n    {SCMP_SYS (mount), EPERM},\n    {SCMP_SYS (umount), EPERM},\n    {SCMP_SYS (umount2), EPERM},\n    {SCMP_SYS (pivot_root), EPERM},\n#if defined(__s390__) || defined(__s390x__) || defined(__CRIS__)\n    /* Architectures with CONFIG_CLONE_BACKWARDS2: the child stack\n     * and flags arguments are reversed so the flags come second */\n    {SCMP_SYS (clone), EPERM, &SCMP_A1 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)},\n#else\n    /* Normally the flags come first */\n    {SCMP_SYS (clone), EPERM, &SCMP_A0 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)},\n#endif\n\n    /* Don't allow faking input to the controlling tty (CVE-2017-5226) */\n    {SCMP_SYS (ioctl), EPERM, &SCMP_A1 (SCMP_CMP_MASKED_EQ, 0xFFFFFFFFu, (int) TIOCSTI)},\n\n    /* seccomp can't look into clone3()'s struct clone_args to check whether\n     * the flags are OK, so we have no choice but to block clone3().\n     * Return ENOSYS so user-space will fall back to clone().\n     * (GHSA-67h7-w3jq-vh4q; see also https://github.com/moby/moby/commit/9f6b562d) */\n    {SCMP_SYS (clone3), ENOSYS},\n\n    /* New mount manipulation APIs can also change our VFS. There's no\n     * legitimate reason to do these in the sandbox, so block all of them\n     * rather than thinking about which ones might be dangerous.\n     * (GHSA-67h7-w3jq-vh4q) */\n    {SCMP_SYS (open_tree), ENOSYS},\n    {SCMP_SYS (move_mount), ENOSYS},\n    {SCMP_SYS (fsopen), ENOSYS},\n    {SCMP_SYS (fsconfig), ENOSYS},\n    {SCMP_SYS (fsmount), ENOSYS},\n    {SCMP_SYS (fspick), ENOSYS},\n    {SCMP_SYS (mount_setattr), ENOSYS},\n  };\n\n  struct\n  {\n    int                  scall;\n    int                  errnum;\n    struct scmp_arg_cmp *arg;\n  } syscall_nondevel_blocklist[] = {\n    /* Profiling operations; we expect these to be done by tools from outside\n     * the sandbox.  In particular perf has been the source of many CVEs.\n     */\n    {SCMP_SYS (perf_event_open), EPERM},\n    /* Don't allow you to switch to bsd emulation or whatnot */\n    {SCMP_SYS (personality), EPERM, &SCMP_A0 (SCMP_CMP_NE, allowed_personality)},\n    {SCMP_SYS (ptrace), EPERM}\n  };\n  /* Blocklist all but unix, inet, inet6 and netlink */\n  struct\n  {\n    int             family;\n    FlatpakRunFlags flags_mask;\n  } socket_family_allowlist[] = {\n    /* NOTE: Keep in numerical order */\n    { AF_UNSPEC, 0 },\n    { AF_LOCAL, 0 },\n    { AF_INET, 0 },\n    { AF_INET6, 0 },\n    { AF_NETLINK, 0 },\n    { AF_CAN, FLATPAK_RUN_FLAG_CANBUS },\n    { AF_BLUETOOTH, FLATPAK_RUN_FLAG_BLUETOOTH },\n  };\n  int last_allowed_family;\n  int i, r;\n  g_auto(GLnxTmpfile) seccomp_tmpf  = { 0, };\n\n  seccomp = seccomp_init (SCMP_ACT_ALLOW);\n  if (!seccomp)\n    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Initialize seccomp failed\"));\n\n  if (arch != NULL)\n    {\n      uint32_t arch_id = 0;\n      const uint32_t *extra_arches = NULL;\n\n      if (strcmp (arch, \"i386\") == 0)\n        {\n          arch_id = SCMP_ARCH_X86;\n        }\n      else if (strcmp (arch, \"x86_64\") == 0)\n        {\n          arch_id = SCMP_ARCH_X86_64;\n          extra_arches = seccomp_x86_64_extra_arches;\n        }\n      else if (strcmp (arch, \"arm\") == 0)\n        {\n          arch_id = SCMP_ARCH_ARM;\n        }\n#ifdef SCMP_ARCH_AARCH64\n      else if (strcmp (arch, \"aarch64\") == 0)\n        {\n          arch_id = SCMP_ARCH_AARCH64;\n          extra_arches = seccomp_aarch64_extra_arches;\n        }\n#endif\n\n      /* We only really need to handle arches on multiarch systems.\n       * If only one arch is supported the default is fine */\n      if (arch_id != 0)\n        {\n          /* This *adds* the target arch, instead of replacing the\n             native one. This is not ideal, because we'd like to only\n             allow the target arch, but we can't really disallow the\n             native arch at this point, because then bubblewrap\n             couldn't continue running. */\n          r = seccomp_arch_add (seccomp, arch_id);\n          if (r < 0 && r != -EEXIST)\n            return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to add architecture to seccomp filter\"));\n\n          if (multiarch && extra_arches != NULL)\n            {\n              for (i = 0; extra_arches[i] != 0; i++)\n                {\n                  r = seccomp_arch_add (seccomp, extra_arches[i]);\n                  if (r < 0 && r != -EEXIST)\n                    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to add multiarch architecture to seccomp filter\"));\n                }\n            }\n        }\n    }\n\n  /* TODO: Should we filter the kernel keyring syscalls in some way?\n   * We do want them to be used by desktop apps, but they could also perhaps\n   * leak system stuff or secrets from other apps.\n   */\n\n  for (i = 0; i < G_N_ELEMENTS (syscall_blocklist); i++)\n    {\n      int scall = syscall_blocklist[i].scall;\n      int errnum = syscall_blocklist[i].errnum;\n\n      g_return_val_if_fail (errnum == EPERM || errnum == ENOSYS, FALSE);\n\n      if (syscall_blocklist[i].arg)\n        r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 1, *syscall_blocklist[i].arg);\n      else\n        r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 0);\n      if (r < 0 && r == -EFAULT /* unknown syscall */)\n        return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to block syscall %d\"), scall);\n    }\n\n  if (!devel)\n    {\n      for (i = 0; i < G_N_ELEMENTS (syscall_nondevel_blocklist); i++)\n        {\n          int scall = syscall_nondevel_blocklist[i].scall;\n          int errnum = syscall_nondevel_blocklist[i].errnum;\n\n          g_return_val_if_fail (errnum == EPERM || errnum == ENOSYS, FALSE);\n\n          if (syscall_nondevel_blocklist[i].arg)\n            r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 1, *syscall_nondevel_blocklist[i].arg);\n          else\n            r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 0);\n\n          if (r < 0 && r == -EFAULT /* unknown syscall */)\n            return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to block syscall %d\"), scall);\n        }\n    }\n\n  /* Socket filtering doesn't work on e.g. i386, so ignore failures here\n   * However, we need to user seccomp_rule_add_exact to avoid libseccomp doing\n   * something else: https://github.com/seccomp/libseccomp/issues/8 */\n  last_allowed_family = -1;\n  for (i = 0; i < G_N_ELEMENTS (socket_family_allowlist); i++)\n    {\n      int family = socket_family_allowlist[i].family;\n      int disallowed;\n\n      if (socket_family_allowlist[i].flags_mask != 0 &&\n          (socket_family_allowlist[i].flags_mask & run_flags) != socket_family_allowlist[i].flags_mask)\n        continue;\n\n      for (disallowed = last_allowed_family + 1; disallowed < family; disallowed++)\n        {\n          /* Blocklist the in-between valid families */\n          seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_EQ, disallowed));\n        }\n      last_allowed_family = family;\n    }\n  /* Blocklist the rest */\n  seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_GE, last_allowed_family + 1));\n\n  if (!glnx_open_anonymous_tmpfile_full (O_RDWR | O_CLOEXEC, \"/tmp\", &seccomp_tmpf, error))\n    return FALSE;\n\n  if (seccomp_export_bpf (seccomp, seccomp_tmpf.fd) != 0)\n    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to export bpf\"));\n\n  lseek (seccomp_tmpf.fd, 0, SEEK_SET);\n\n  flatpak_bwrap_add_args_data_fd (bwrap,\n                                  \"--seccomp\", glnx_steal_fd (&seccomp_tmpf.fd), NULL);\n\n  return TRUE;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "flatpak-run.c",
        "method_name": "fixed_function",
        "raw_code": "setup_seccomp (FlatpakBwrap   *bwrap,\n               const char     *arch,\n               gulong          allowed_personality,\n               FlatpakRunFlags run_flags,\n               GError        **error)\n{\n  gboolean multiarch = (run_flags & FLATPAK_RUN_FLAG_MULTIARCH) != 0;\n  gboolean devel = (run_flags & FLATPAK_RUN_FLAG_DEVEL) != 0;\n\n  __attribute__((cleanup (cleanup_seccomp))) scmp_filter_ctx seccomp = NULL;\n\n  /**** BEGIN NOTE ON CODE SHARING\n   *\n   * There are today a number of different Linux container\n   * implementations.  That will likely continue for long into the\n   * future.  But we can still try to share code, and it's important\n   * to do so because it affects what library and application writers\n   * can do, and we should support code portability between different\n   * container tools.\n   *\n   * This syscall blocklist is copied from linux-user-chroot, which was in turn\n   * clearly influenced by the Sandstorm.io blocklist.\n   *\n   * If you make any changes here, I suggest sending the changes along\n   * to other sandbox maintainers.  Using the libseccomp list is also\n   * an appropriate venue:\n   * https://groups.google.com/forum/#!forum/libseccomp\n   *\n   * A non-exhaustive list of links to container tooling that might\n   * want to share this blocklist:\n   *\n   *  https://github.com/sandstorm-io/sandstorm\n   *    in src/sandstorm/supervisor.c++\n   *  https://github.com/flatpak/flatpak.git\n   *    in common/flatpak-run.c\n   *  https://git.gnome.org/browse/linux-user-chroot\n   *    in src/setup-seccomp.c\n   *\n   * Other useful resources:\n   * https://github.com/systemd/systemd/blob/HEAD/src/shared/seccomp-util.c\n   * https://github.com/moby/moby/blob/HEAD/profiles/seccomp/default.json\n   *\n   **** END NOTE ON CODE SHARING\n   */\n  struct\n  {\n    int                  scall;\n    int                  errnum;\n    struct scmp_arg_cmp *arg;\n  } syscall_blocklist[] = {\n    /* Block dmesg */\n    {SCMP_SYS (syslog), EPERM},\n    /* Useless old syscall */\n    {SCMP_SYS (uselib), EPERM},\n    /* Don't allow disabling accounting */\n    {SCMP_SYS (acct), EPERM},\n    /* 16-bit code is unnecessary in the sandbox, and modify_ldt is a\n       historic source of interesting information leaks. */\n    {SCMP_SYS (modify_ldt), EPERM},\n    /* Don't allow reading current quota use */\n    {SCMP_SYS (quotactl), EPERM},\n\n    /* Don't allow access to the kernel keyring */\n    {SCMP_SYS (add_key), EPERM},\n    {SCMP_SYS (keyctl), EPERM},\n    {SCMP_SYS (request_key), EPERM},\n\n    /* Scary VM/NUMA ops */\n    {SCMP_SYS (move_pages), EPERM},\n    {SCMP_SYS (mbind), EPERM},\n    {SCMP_SYS (get_mempolicy), EPERM},\n    {SCMP_SYS (set_mempolicy), EPERM},\n    {SCMP_SYS (migrate_pages), EPERM},\n\n    /* Don't allow subnamespace setups: */\n    {SCMP_SYS (unshare), EPERM},\n    {SCMP_SYS (setns), EPERM},\n    {SCMP_SYS (mount), EPERM},\n    {SCMP_SYS (umount), EPERM},\n    {SCMP_SYS (umount2), EPERM},\n    {SCMP_SYS (pivot_root), EPERM},\n    {SCMP_SYS (chroot), EPERM},\n#if defined(__s390__) || defined(__s390x__) || defined(__CRIS__)\n    /* Architectures with CONFIG_CLONE_BACKWARDS2: the child stack\n     * and flags arguments are reversed so the flags come second */\n    {SCMP_SYS (clone), EPERM, &SCMP_A1 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)},\n#else\n    /* Normally the flags come first */\n    {SCMP_SYS (clone), EPERM, &SCMP_A0 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)},\n#endif\n\n    /* Don't allow faking input to the controlling tty (CVE-2017-5226) */\n    {SCMP_SYS (ioctl), EPERM, &SCMP_A1 (SCMP_CMP_MASKED_EQ, 0xFFFFFFFFu, (int) TIOCSTI)},\n\n    /* seccomp can't look into clone3()'s struct clone_args to check whether\n     * the flags are OK, so we have no choice but to block clone3().\n     * Return ENOSYS so user-space will fall back to clone().\n     * (GHSA-67h7-w3jq-vh4q; see also https://github.com/moby/moby/commit/9f6b562d) */\n    {SCMP_SYS (clone3), ENOSYS},\n\n    /* New mount manipulation APIs can also change our VFS. There's no\n     * legitimate reason to do these in the sandbox, so block all of them\n     * rather than thinking about which ones might be dangerous.\n     * (GHSA-67h7-w3jq-vh4q) */\n    {SCMP_SYS (open_tree), ENOSYS},\n    {SCMP_SYS (move_mount), ENOSYS},\n    {SCMP_SYS (fsopen), ENOSYS},\n    {SCMP_SYS (fsconfig), ENOSYS},\n    {SCMP_SYS (fsmount), ENOSYS},\n    {SCMP_SYS (fspick), ENOSYS},\n    {SCMP_SYS (mount_setattr), ENOSYS},\n  };\n\n  struct\n  {\n    int                  scall;\n    int                  errnum;\n    struct scmp_arg_cmp *arg;\n  } syscall_nondevel_blocklist[] = {\n    /* Profiling operations; we expect these to be done by tools from outside\n     * the sandbox.  In particular perf has been the source of many CVEs.\n     */\n    {SCMP_SYS (perf_event_open), EPERM},\n    /* Don't allow you to switch to bsd emulation or whatnot */\n    {SCMP_SYS (personality), EPERM, &SCMP_A0 (SCMP_CMP_NE, allowed_personality)},\n    {SCMP_SYS (ptrace), EPERM}\n  };\n  /* Blocklist all but unix, inet, inet6 and netlink */\n  struct\n  {\n    int             family;\n    FlatpakRunFlags flags_mask;\n  } socket_family_allowlist[] = {\n    /* NOTE: Keep in numerical order */\n    { AF_UNSPEC, 0 },\n    { AF_LOCAL, 0 },\n    { AF_INET, 0 },\n    { AF_INET6, 0 },\n    { AF_NETLINK, 0 },\n    { AF_CAN, FLATPAK_RUN_FLAG_CANBUS },\n    { AF_BLUETOOTH, FLATPAK_RUN_FLAG_BLUETOOTH },\n  };\n  int last_allowed_family;\n  int i, r;\n  g_auto(GLnxTmpfile) seccomp_tmpf  = { 0, };\n\n  seccomp = seccomp_init (SCMP_ACT_ALLOW);\n  if (!seccomp)\n    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Initialize seccomp failed\"));\n\n  if (arch != NULL)\n    {\n      uint32_t arch_id = 0;\n      const uint32_t *extra_arches = NULL;\n\n      if (strcmp (arch, \"i386\") == 0)\n        {\n          arch_id = SCMP_ARCH_X86;\n        }\n      else if (strcmp (arch, \"x86_64\") == 0)\n        {\n          arch_id = SCMP_ARCH_X86_64;\n          extra_arches = seccomp_x86_64_extra_arches;\n        }\n      else if (strcmp (arch, \"arm\") == 0)\n        {\n          arch_id = SCMP_ARCH_ARM;\n        }\n#ifdef SCMP_ARCH_AARCH64\n      else if (strcmp (arch, \"aarch64\") == 0)\n        {\n          arch_id = SCMP_ARCH_AARCH64;\n          extra_arches = seccomp_aarch64_extra_arches;\n        }\n#endif\n\n      /* We only really need to handle arches on multiarch systems.\n       * If only one arch is supported the default is fine */\n      if (arch_id != 0)\n        {\n          /* This *adds* the target arch, instead of replacing the\n             native one. This is not ideal, because we'd like to only\n             allow the target arch, but we can't really disallow the\n             native arch at this point, because then bubblewrap\n             couldn't continue running. */\n          r = seccomp_arch_add (seccomp, arch_id);\n          if (r < 0 && r != -EEXIST)\n            return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to add architecture to seccomp filter\"));\n\n          if (multiarch && extra_arches != NULL)\n            {\n              for (i = 0; extra_arches[i] != 0; i++)\n                {\n                  r = seccomp_arch_add (seccomp, extra_arches[i]);\n                  if (r < 0 && r != -EEXIST)\n                    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to add multiarch architecture to seccomp filter\"));\n                }\n            }\n        }\n    }\n\n  /* TODO: Should we filter the kernel keyring syscalls in some way?\n   * We do want them to be used by desktop apps, but they could also perhaps\n   * leak system stuff or secrets from other apps.\n   */\n\n  for (i = 0; i < G_N_ELEMENTS (syscall_blocklist); i++)\n    {\n      int scall = syscall_blocklist[i].scall;\n      int errnum = syscall_blocklist[i].errnum;\n\n      g_return_val_if_fail (errnum == EPERM || errnum == ENOSYS, FALSE);\n\n      if (syscall_blocklist[i].arg)\n        r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 1, *syscall_blocklist[i].arg);\n      else\n        r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 0);\n      if (r < 0 && r == -EFAULT /* unknown syscall */)\n        return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to block syscall %d\"), scall);\n    }\n\n  if (!devel)\n    {\n      for (i = 0; i < G_N_ELEMENTS (syscall_nondevel_blocklist); i++)\n        {\n          int scall = syscall_nondevel_blocklist[i].scall;\n          int errnum = syscall_nondevel_blocklist[i].errnum;\n\n          g_return_val_if_fail (errnum == EPERM || errnum == ENOSYS, FALSE);\n\n          if (syscall_nondevel_blocklist[i].arg)\n            r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 1, *syscall_nondevel_blocklist[i].arg);\n          else\n            r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (errnum), scall, 0);\n\n          if (r < 0 && r == -EFAULT /* unknown syscall */)\n            return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to block syscall %d\"), scall);\n        }\n    }\n\n  /* Socket filtering doesn't work on e.g. i386, so ignore failures here\n   * However, we need to user seccomp_rule_add_exact to avoid libseccomp doing\n   * something else: https://github.com/seccomp/libseccomp/issues/8 */\n  last_allowed_family = -1;\n  for (i = 0; i < G_N_ELEMENTS (socket_family_allowlist); i++)\n    {\n      int family = socket_family_allowlist[i].family;\n      int disallowed;\n\n      if (socket_family_allowlist[i].flags_mask != 0 &&\n          (socket_family_allowlist[i].flags_mask & run_flags) != socket_family_allowlist[i].flags_mask)\n        continue;\n\n      for (disallowed = last_allowed_family + 1; disallowed < family; disallowed++)\n        {\n          /* Blocklist the in-between valid families */\n          seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_EQ, disallowed));\n        }\n      last_allowed_family = family;\n    }\n  /* Blocklist the rest */\n  seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_GE, last_allowed_family + 1));\n\n  if (!glnx_open_anonymous_tmpfile_full (O_RDWR | O_CLOEXEC, \"/tmp\", &seccomp_tmpf, error))\n    return FALSE;\n\n  if (seccomp_export_bpf (seccomp, seccomp_tmpf.fd) != 0)\n    return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to export bpf\"));\n\n  lseek (seccomp_tmpf.fd, 0, SEEK_SET);\n\n  flatpak_bwrap_add_args_data_fd (bwrap,\n                                  \"--seccomp\", glnx_steal_fd (&seccomp_tmpf.fd), NULL);\n\n  return TRUE;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <sys/personality.h>\n#include \"config.h\"\n#include \"libglnx/libglnx.h\"\n#include \"flatpak-run-private.h\"\n#include <gio/gdesktopappinfo.h>\n#include <string.h>\n#include <ctype.h>\n#include <glib/gi18n-lib.h>\n#include <stdio.h>\n#include \"session-helper/flatpak-session-helper.h\"\n#include \"flatpak-systemd-dbus-generated.h\"\n#include <gio/gio.h>\n#include \"flatpak-proxy.h\"\n#include <sys/socket.h>\n#include <X11/Xauth.h>\n#include <unistd.h>\n#include <sys/vfs.h>\n#include \"flatpak-instance-private.h\"\n#include <fcntl.h>\n#include <libmalcontent/malcontent.h>\n#include \"flatpak-error.h\"\n#include \"flatpak-document-dbus-generated.h\"\n#include \"flatpak-dir-private.h\"\n#include <sys/utsname.h>\n#include <dconf/dconf.h>\n#include <seccomp.h>\n#include \"flatpak-syscalls-private.h\"\n#include <grp.h>\n#include <gio/gunixfdlist.h>\n#include \"flatpak-utils-base-private.h\"\n#include <sys/ioctl.h>\n"
  },
  {
    "repository": "tensorflow",
    "cve_id": "CVE-2021-41216",
    "cwe_list": [
      "CWE-703"
    ],
    "commit_hash": "c79ba87153ee343401dbe9d1954d7f79e521eb14",
    "short_hash": "c79ba871",
    "vulnerableMethods_before": [
      {
        "filename": "array_ops.cc",
        "method_name": "vulnerable_function",
        "raw_code": "Status TransposeShapeFn(InferenceContext* c) {\n  ShapeHandle input = c->input(0);\n  ShapeHandle perm_shape = c->input(1);\n  const Tensor* perm = c->input_tensor(1);\n  DimensionHandle perm_elems = c->NumElements(perm_shape);\n  // If we don't have rank information on the input or value information on\n  // perm we can't return any shape information, otherwise we have enough\n  // information to at least find the rank of the output.\n  if (!c->RankKnown(input) && !c->ValueKnown(perm_elems) && perm == nullptr) {\n    c->set_output(0, c->UnknownShape());\n    return Status::OK();\n  }\n\n  // Find our value of the rank.\n  int64_t rank;\n  if (c->RankKnown(input)) {\n    rank = c->Rank(input);\n  } else if (c->ValueKnown(perm_elems)) {\n    rank = c->Value(perm_elems);\n  } else {\n    rank = perm->NumElements();\n  }\n  if (!c->RankKnown(input) && rank < 2) {\n    // A permutation array containing a single element is ambiguous. It could\n    // indicate either a scalar or a 1-dimensional array, both of which the\n    // transpose op returns unchanged.\n    c->set_output(0, input);\n    return Status::OK();\n  }\n\n  std::vector<DimensionHandle> dims;\n  dims.resize(rank);\n  TF_RETURN_IF_ERROR(c->WithRank(input, rank, &input));\n  // Ensure that perm is a vector and has rank elements.\n  TF_RETURN_IF_ERROR(c->WithRank(perm_shape, 1, &perm_shape));\n  TF_RETURN_IF_ERROR(c->WithValue(perm_elems, rank, &perm_elems));\n\n  // If we know the rank of the input and the value of perm, we can return\n  // all shape information, otherwise we can only return rank information,\n  // but no information for the dimensions.\n  if (perm != nullptr) {\n    std::vector<int64_t> data;\n    if (perm->dtype() == DT_INT32) {\n      data = AsInt64<int32>(perm, rank);\n    } else {\n      data = AsInt64<int64_t>(perm, rank);\n    }\n\n    for (int32_t i = 0; i < rank; ++i) {\n      int64_t in_idx = data[i];\n      if (in_idx >= rank) {\n        return errors::InvalidArgument(\"perm dim \", in_idx,\n                                       \" is out of range of input rank \", rank);\n      }\n      dims[i] = c->Dim(input, in_idx);\n    }\n  } else {\n    for (int i = 0; i < rank; ++i) {\n      dims[i] = c->UnknownDim();\n    }\n  }\n\n  c->set_output(0, c->MakeShape(dims));\n  return Status::OK();\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "array_ops.cc",
        "method_name": "fixed_function",
        "raw_code": "Status TransposeShapeFn(InferenceContext* c) {\n  ShapeHandle input = c->input(0);\n  ShapeHandle perm_shape = c->input(1);\n  const Tensor* perm = c->input_tensor(1);\n  DimensionHandle perm_elems = c->NumElements(perm_shape);\n  // If we don't have rank information on the input or value information on\n  // perm we can't return any shape information, otherwise we have enough\n  // information to at least find the rank of the output.\n  if (!c->RankKnown(input) && !c->ValueKnown(perm_elems) && perm == nullptr) {\n    c->set_output(0, c->UnknownShape());\n    return Status::OK();\n  }\n\n  // Find our value of the rank.\n  int64_t rank;\n  if (c->RankKnown(input)) {\n    rank = c->Rank(input);\n  } else if (c->ValueKnown(perm_elems)) {\n    rank = c->Value(perm_elems);\n  } else {\n    rank = perm->NumElements();\n  }\n  if (!c->RankKnown(input) && rank < 2) {\n    // A permutation array containing a single element is ambiguous. It could\n    // indicate either a scalar or a 1-dimensional array, both of which the\n    // transpose op returns unchanged.\n    c->set_output(0, input);\n    return Status::OK();\n  }\n\n  std::vector<DimensionHandle> dims;\n  dims.resize(rank);\n  TF_RETURN_IF_ERROR(c->WithRank(input, rank, &input));\n  // Ensure that perm is a vector and has rank elements.\n  TF_RETURN_IF_ERROR(c->WithRank(perm_shape, 1, &perm_shape));\n  TF_RETURN_IF_ERROR(c->WithValue(perm_elems, rank, &perm_elems));\n\n  // If we know the rank of the input and the value of perm, we can return\n  // all shape information, otherwise we can only return rank information,\n  // but no information for the dimensions.\n  if (perm != nullptr) {\n    std::vector<int64_t> data;\n    if (perm->dtype() == DT_INT32) {\n      data = AsInt64<int32>(perm, rank);\n    } else {\n      data = AsInt64<int64_t>(perm, rank);\n    }\n\n    for (int32_t i = 0; i < rank; ++i) {\n      int64_t in_idx = data[i];\n      if (in_idx >= rank || in_idx <= -rank) {\n        return errors::InvalidArgument(\"perm dim \", in_idx,\n                                       \" is out of range of input rank \", rank);\n      }\n      dims[i] = c->Dim(input, in_idx);\n    }\n  } else {\n    for (int i = 0; i < rank; ++i) {\n      dims[i] = c->UnknownDim();\n    }\n  }\n\n  c->set_output(0, c->MakeShape(dims));\n  return Status::OK();\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"tensorflow/core/framework/kernel_shape_util.h\"\n#include \"tensorflow/core/framework/types.pb.h\"\n#include <algorithm>\n#include \"tensorflow/core/util/padding.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/framework/tensor.pb.h\"\n#include \"tensorflow/core/util/tensor_format.h\"\n#include \"tensorflow/core/framework/common_shape_fns.h\"\n#include \"tensorflow/core/framework/shape_inference.h\"\n#include \"tensorflow/core/util/strided_slice_op.h\"\n#include \"tensorflow/core/framework/op.h\"\n#include <ostream>\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/util/mirror_pad_mode.h\"\n\n// Type Definitions:\n// DimensionHandle:\nclass DimensionHandle {\n public:\n  DimensionHandle() {}\n  bool SameHandle(DimensionHandle d) const { return ptr_ == d.ptr_; }\n  std::size_t Handle() const { return reinterpret_cast<std::size_t>(ptr_); }\n\n private:\n  DimensionHandle(const Dimension* dim) { ptr_ = dim; }\n\n  const Dimension* operator->() const { return ptr_; }\n  bool IsSet() const { return ptr_ != nullptr; }\n\n  const Dimension* ptr_ = nullptr;\n\n  friend struct DimensionOrConstant;\n  friend class InferenceContext;\n  friend class ShapeInferenceTest;\n  friend class ShapeInferenceTestutil;\n  friend class ::tensorflow::grappler::GraphProperties;\n  friend class ::tensorflow::grappler::SymbolicShapeManager;\n\n  // Intentionally copyable.\n}\n\n// InferenceContext:\nclass InferenceContext {\n public:\n  static constexpr int64_t kUnknownDim = -1;\n  static constexpr int32_t kUnknownRank = -1;\n\n  // <input_tensors> is NULL-padded to be the same size as <input_shapes>.\n  //\n  // Elements of <input_tensors_as_shapes> are used for when a shape function\n  // makes a call to MakeShapeFromShapeTensor; in particular, when the\n  // input_tensors[i] is nullptr but the shape represented by it is partially\n  // known from analysis of the graph.\n  // <input_tensors_as_shapes> can have fewer elements than <input_shapes>.\n  // Values of <input_tensors_as_shapes> do not need to outlive the context.\n  InferenceContext(int graph_def_version, const AttrSlice& attrs,\n                   const OpDef& op_def,\n                   const std::vector<ShapeHandle>& input_shapes,\n                   const std::vector<const Tensor*>& input_tensors,\n                   const std::vector<ShapeHandle>& input_tensors_as_shapes,\n                   std::vector<std::unique_ptr<std::vecto...\n\n// InferenceContext:\nInferenceContext.InferenceContext:ANY(int,AttrSlice&,OpDef&,std.vector&,std.vector&,std.vector&,std.vector&)\n\n// Status:\nclass Status\n\n// Tensor:\ntensorflow.TensorHandle.Tensor:tensorflow.Status(tensorflow.Tensor**)<const>\n\n// ShapeHandle:\nclass ShapeHandle {\n public:\n  ShapeHandle() {}\n  bool SameHandle(ShapeHandle s) const { return ptr_ == s.ptr_; }\n  std::size_t Handle() const { return reinterpret_cast<std::size_t>(ptr_); }\n\n private:\n  ShapeHandle(const Shape* shape) { ptr_ = shape; }\n  const Shape* operator->() const { return ptr_; }\n  bool IsSet() const { return ptr_ != nullptr; }\n\n  const Shape* ptr_ = nullptr;\n\n  friend class InferenceContext;\n  friend class ShapeInferenceTest;\n  friend class ShapeInferenceTestutil;\n  friend class ::tensorflow::grappler::SymbolicShapeManager;\n\n  // Intentionally copyable.\n}\n\n// Status:\nclass Status {\n public:\n  /// Create a success status.\n  Status() {}\n\n  /// \\brief Create a status with the specified error code and msg as a\n  /// human-readable string containing more detailed information.\n  Status(tensorflow::error::Code code, tensorflow::StringPiece msg)\n      : Status(code, msg, {}) {}\n\n  /// \\brief Create a status with the specified error code, msg, and stack trace\n  /// as a human-readable string containing more detailed information.\n#ifndef SWIG\n  Status(tensorflow::error::Code code, tensorflow::StringPiece msg,\n         std::vector<StackFrame>&& stack_trace);\n#endif\n\n  /// Copy the specified status.\n  Status(const Status& s);\n  Status& operator=(const Status& s);\n#ifndef SWIG\n  Status(Status&& s) noexcept;\n  Status& operator=(Status&& s) noexcept;\n#endif  // SWIG\n\n  static Status OK() { return Status(); }\n\n  /// Returns true iff the status indicates success.\n  bool ok() const { return (state_ == nullptr); }\n\n  tensorflow::error::Code code() const {\n    retu...\n\n// Called Methods (top 10):\n// OK from tensorflow/core/platform/status.h:\n  static Status OK() { return Status(); } /* <=== tensorflow.Status.OK:tensorflow.Status() */ \n\n// request_input_tensor from tensorflow/core/framework/shape_inference.h:\n  void request_input_tensor(int idx) { requested_input_tensor_[idx] = true; } /* <=== tensorflow.shape_inference.InferenceContext.request_input_tensor:void(int) */ \n\n// IsSet from tensorflow/core/framework/shape_inference.h:\n  bool IsSet() const { return ptr_ != nullptr; } /* <=== tensorflow.shape_inference.ShapeHandle.IsSet:bool()<const> */ \n\n// input_tensor from tensorflow/core/framework/shape_inference.h:\n  const Tensor* input_tensor(int idx) { /* <=== tensorflow.shape_inference.InferenceContext.input_tensor:tensorflow.Tensor*(int) */ \n    // Mark that this idx was requested.\n    request_input_tensor(idx);\n    return input_tensors_[idx];\n  }\n\n// ok from tensorflow/core/platform/status.h:\n  bool ok() const { return (state_ == nullptr); } /* <=== tensorflow.Status.ok:bool()<const> */ \n\n// ValueKnown from tensorflow/core/framework/shape_inference.h:\n  static inline bool ValueKnown(DimensionOrConstant d) { /* <=== tensorflow.shape_inference.InferenceContext.ValueKnown:bool(tensorflow.shape_inference.DimensionOrConstant) */ \n    return Value(d) != kUnknownDim;\n  }\n\n// NumElements from tensorflow/core/framework/shape_inference.h:\n  DimensionHandle NumElements(ShapeHandle s); /* <=== tensorflow.shape_inference.InferenceContext.NumElements:tensorflow.shape_inference.DimensionHandle(tensorflow.shape_inference.ShapeHandle) */ \n\n// RankKnown from tensorflow/core/framework/shape_inference.h:\n  static bool RankKnown(ShapeHandle s) { /* <=== tensorflow.shape_inference.InferenceContext.RankKnown:bool(tensorflow.shape_inference.ShapeHandle) */ \n    return (s.IsSet() && (Rank(s) != kUnknownRank));\n  }\n\n// TF_RETURN_IF_ERROR from tensorflow/core/ops/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/common_runtime/eager/tensorflow/core/framework/tensorflow/core/platform/errors.h:\n\n"
  },
  {
    "repository": "server",
    "cve_id": "CVE-2022-27383",
    "cwe_list": [
      "CWE-416"
    ],
    "commit_hash": "c05fd700970ad45735caed3a6f9930d4ce19a3bd",
    "short_hash": "c05fd700",
    "vulnerableMethods_before": [
      {
        "filename": "None",
        "method_name": "vulnerable_function",
        "raw_code": "static void fix_dl_name(MEM_ROOT *root, LEX_STRING *dl)\n{\n  const size_t so_ext_len= sizeof(SO_EXT) - 1;\n  if (my_strcasecmp(&my_charset_latin1, dl->str + dl->length - so_ext_len,\n                    SO_EXT))\n  {\n    char *s= (char*)alloc_root(root, dl->length + so_ext_len + 1);\n    memcpy(s, dl->str, dl->length);\n    strcpy(s + dl->length, SO_EXT);\n    dl->str= s;\n    dl->length+= so_ext_len;\n  }\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "None",
        "method_name": "fixed_function",
        "raw_code": "static void fix_dl_name(MEM_ROOT *root, LEX_STRING *dl)\n{\n  const size_t so_ext_len= sizeof(SO_EXT) - 1;\n  if (dl->length < so_ext_len ||\n      my_strcasecmp(&my_charset_latin1, dl->str + dl->length - so_ext_len,\n                    SO_EXT))\n  {\n    char *s= (char*)alloc_root(root, dl->length + so_ext_len + 1);\n    memcpy(s, dl->str, dl->length);\n    strcpy(s + dl->length, SO_EXT);\n    dl->str= s;\n    dl->length+= so_ext_len;\n  }\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"sys_vars_shared.h\"\n#include \"sql_audit.h\"\n#include <link.h>\n#include \"sql_class.h\"\n#include \"sql_locale.h\"\n#include \"sql_priv.h\"\n#include <my_pthread.h>\n#include <my_getopt.h>\n#include \"key.h\"\n#include \"sql_table.h\"\n#include \"sql_acl.h\"\n#include \"lock.h\"\n#include \"sql_plugin_services.inl\"\n#include \"records.h\"\n#include \"unireg.h\"\n#include \"sql_plugin_compat.h\"\n#include <mysql/plugin_encryption.h>\n#include \"sql_show.h\"\n#include \"sql_base.h\"\n#include \"sql_parse.h\"\n#include <mysql/plugin_auth.h>\n#include \"sql_plugin.h\"\n#include <mysql/plugin_password_validation.h>\n#include \"strfunc.h\"\n\n// Type Definitions:\n// MEM_ROOT:\ntypedef struct st_mem_root MEM_ROOT;\n"
  },
  {
    "repository": "tensorflow",
    "cve_id": "CVE-2021-41204",
    "cwe_list": [
      "CWE-824"
    ],
    "commit_hash": "7731e8dfbe4a56773be5dc94d631611211156659",
    "short_hash": "7731e8df",
    "vulnerableMethods_before": [
      {
        "filename": "constant_folding.cc",
        "method_name": "vulnerable_function",
        "raw_code": "bool IsConstantFoldable(\n    const Node* n,\n    const std::unordered_map<string, std::vector<PartialTensorShape>>*\n        shape_map,\n    const std::function<bool(const Node*)>& consider,\n    int64_t max_constant_size_in_bytes,\n    std::unordered_map<const Node*, std::vector<Tensor>>*\n        shape_replacement_map) {\n  if (n->IsConstant()) {\n    return true;\n  }\n  if (MaybeReplaceShapeOp(n, shape_map, shape_replacement_map)) {\n    return true;\n  }\n  if (n->op_def().is_stateful()) {\n    return false;\n  }\n  if (consider && !consider(n)) {\n    return false;\n  }\n  if (shape_map != nullptr) {\n    // We can skip the node if an output is known to be oversized.\n    auto shape_it = shape_map->find(n->name());\n    if (shape_it != shape_map->end()) {\n      for (int64_t i = 0; i < shape_it->second.size(); ++i) {\n        const auto& out_shape = shape_it->second[i];\n        if (out_shape.IsFullyDefined() &&\n            out_shape.num_elements() * DataTypeSize(n->output_type(i)) >\n                max_constant_size_in_bytes) {\n          return false;\n        }\n      }\n    }\n  }\n  if (n->IsControlFlow() || n->IsSend() || n->IsRecv()) {\n    return false;\n  }\n  // TODO(yuanbyu): For now disable these session handle operations.\n  if (n->IsGetSessionHandle() || n->IsGetSessionTensor() ||\n      n->IsDeleteSessionTensor()) {\n    return false;\n  }\n  if (n->IsSource()) {\n    return false;\n  }\n  if (n->IsSink()) {\n    return false;\n  }\n  if (n->IsFakeParam()) {\n    return false;\n  }\n  // Since constant-folding runs on the CPU, do not attempt to constant-fold\n  // operators that have no CPU kernel. Also implies that we will not\n  // constant-fold functions.\n  // TODO(phawkins): allow constant-folding for functions; functions may\n  // be arbitrarily expensive to execute.\n  if (!KernelDefAvailable(DeviceType(DEVICE_CPU), n->def())) {\n    return false;\n  }\n  // Do not constant fold nodes which will be allocated by ScopedAllocator.\n  // This is because the constant-folding graph will not contain the\n  // `_ScopedAllocator` node, and that is necessary to be able to run a node\n  // that will use this allocator.\n  if (n->attrs().Find(kScopedAllocatorAttrName) != nullptr) {\n    VLOG(2) << \"Skip node [\" << n->DebugString()\n            << \"] for constant folding due to scoped allocator\";\n    return false;\n  }\n  return true;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "constant_folding.cc",
        "method_name": "fixed_function",
        "raw_code": "bool IsConstantFoldable(\n    const Node* n,\n    const std::unordered_map<string, std::vector<PartialTensorShape>>*\n        shape_map,\n    const std::function<bool(const Node*)>& consider,\n    int64_t max_constant_size_in_bytes,\n    std::unordered_map<const Node*, std::vector<Tensor>>*\n        shape_replacement_map) {\n  if (n->IsConstant()) {\n    // Skip constant folding resources as they cannot be deep copied.\n    return n->output_type(0) != DT_RESOURCE;\n  }\n  if (MaybeReplaceShapeOp(n, shape_map, shape_replacement_map)) {\n    return true;\n  }\n  if (n->op_def().is_stateful()) {\n    return false;\n  }\n  if (consider && !consider(n)) {\n    return false;\n  }\n  if (shape_map != nullptr) {\n    // We can skip the node if an output is known to be oversized.\n    auto shape_it = shape_map->find(n->name());\n    if (shape_it != shape_map->end()) {\n      for (int64_t i = 0; i < shape_it->second.size(); ++i) {\n        const auto& out_shape = shape_it->second[i];\n        if (out_shape.IsFullyDefined() &&\n            out_shape.num_elements() * DataTypeSize(n->output_type(i)) >\n                max_constant_size_in_bytes) {\n          return false;\n        }\n      }\n    }\n  }\n  if (n->IsControlFlow() || n->IsSend() || n->IsRecv()) {\n    return false;\n  }\n  // TODO(yuanbyu): For now disable these session handle operations.\n  if (n->IsGetSessionHandle() || n->IsGetSessionTensor() ||\n      n->IsDeleteSessionTensor()) {\n    return false;\n  }\n  if (n->IsSource()) {\n    return false;\n  }\n  if (n->IsSink()) {\n    return false;\n  }\n  if (n->IsFakeParam()) {\n    return false;\n  }\n  // Since constant-folding runs on the CPU, do not attempt to constant-fold\n  // operators that have no CPU kernel. Also implies that we will not\n  // constant-fold functions.\n  // TODO(phawkins): allow constant-folding for functions; functions may\n  // be arbitrarily expensive to execute.\n  if (!KernelDefAvailable(DeviceType(DEVICE_CPU), n->def())) {\n    return false;\n  }\n  // Do not constant fold nodes which will be allocated by ScopedAllocator.\n  // This is because the constant-folding graph will not contain the\n  // `_ScopedAllocator` node, and that is necessary to be able to run a node\n  // that will use this allocator.\n  if (n->attrs().Find(kScopedAllocatorAttrName) != nullptr) {\n    VLOG(2) << \"Skip node [\" << n->DebugString()\n            << \"] for constant folding due to scoped allocator\";\n    return false;\n  }\n  return true;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <unordered_map>\n#include <algorithm>\n#include \"tensorflow/core/lib/strings/strcat.h\"\n#include \"tensorflow/core/common_runtime/function_utils.h\"\n#include \"tensorflow/core/common_runtime/device_factory.h\"\n#include <atomic>\n#include \"tensorflow/core/common_runtime/rendezvous_mgr.h\"\n#include \"tensorflow/core/lib/core/threadpool.h\"\n#include \"tensorflow/core/framework/types.pb.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/graph/algorithm.h\"\n#include \"tensorflow/core/platform/setround.h\"\n#include \"tensorflow/core/common_runtime/executor.h\"\n#include \"tensorflow/core/common_runtime/memory_types.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include <set>\n#include \"tensorflow/core/graph/node_builder.h\"\n#include \"tensorflow/core/graph/subgraph.h\"\n#include \"tensorflow/core/framework/log_memory.h\"\n#include \"tensorflow/core/common_runtime/constant_folding.h\"\n#include <vector>\n#include \"tensorflow/core/common_runtime/graph_runner.h\"\n#include \"tensorflow/core/public/session_options.h\"\n#include \"tensorflow/core/lib/gtl/flatset.h\"\n#include \"tensorflow/core/lib/gtl/cleanup.h\"\n#include \"tensorflow/core/platform/denormal.h\"\n\n// Type Definitions:\n// Node:\nclass Node {\n public:\n  // Arguments for `Node` constructor.\n  struct Args {\n    int64_t id;\n    string name;\n    std::shared_ptr<Node> output;\n  };\n\n  using Factory = std::function<std::shared_ptr<Node>(Args)>;\n  using NodeVector = std::vector<std::shared_ptr<Node>>;\n  using NodePairList =\n      std::list<std::pair<std::shared_ptr<Node>, std::shared_ptr<Node>>>;\n  using ModelParameters =\n      std::vector<std::pair<string, std::shared_ptr<Parameter>>>;\n  using NodeValues = absl::flat_hash_map<string, double>;\n  using ParameterGradients =\n      absl::flat_hash_map<std::pair<string, string>, double>;\n\n  explicit Node(Args args)\n      : id_(args.id),\n        name_(std::move(args.name)),\n        autotune_(true),\n        buffered_bytes_(0),\n        buffered_elements_(0),\n        bytes_consumed_(0),\n        bytes_produced_(0),\n        num_elements_(0),\n        processing_time_(0),\n        record_metrics_(true),\n        metrics_(name_),\n        output_(args.output.get()) {}\n\n  virtual ~No...\n\n// Node:\nclass Node\n"
  },
  {
    "repository": "glewlwyd",
    "cve_id": "CVE-2021-45379",
    "cwe_list": [
      "CWE-287"
    ],
    "commit_hash": "125281f1c0d4b6a8b49f7e55a757205a2ef01fbe",
    "short_hash": "125281f1",
    "vulnerableMethods_before": [
      {
        "filename": "webservice.c",
        "method_name": "vulnerable_function",
        "raw_code": "int callback_glewlwyd_user_auth (const struct _u_request * request, struct _u_response * response, void * user_data) {\n  struct config_elements * config = (struct config_elements *)user_data;\n  json_t * j_param = ulfius_get_json_body_request(request, NULL), * j_result = NULL;\n  const char * ip_source = get_ip_source(request);\n  char * issued_for = get_client_hostname(request);\n  char * session_uid, expires[129];\n  time_t now;\n  struct tm ts;\n  \n  time(&now);\n  now += GLEWLWYD_DEFAULT_SESSION_EXPIRATION_COOKIE;\n  gmtime_r(&now, &ts);\n  strftime(expires, 128, \"%a, %d %b %Y %T %Z\", &ts);\n  if (j_param != NULL) {\n    if (json_string_length(json_object_get(j_param, \"username\"))) {\n      if (json_object_get(j_param, \"scheme_type\") == NULL || 0 == o_strcmp(json_string_value(json_object_get(j_param, \"scheme_type\")), \"password\")) {\n        if (json_string_length(json_object_get(j_param, \"password\"))) {\n          j_result = auth_check_user_credentials(config, json_string_value(json_object_get(j_param, \"username\")), json_string_value(json_object_get(j_param, \"password\")));\n          if (check_result_value(j_result, G_OK)) {\n            if ((session_uid = get_session_id(config, request)) == NULL) {\n              session_uid = generate_session_id();\n            }\n            if (user_session_update(config, session_uid, u_map_get_case(request->map_header, \"user-agent\"), issued_for, json_string_value(json_object_get(j_param, \"username\")), NULL, 1) != G_OK) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error user_session_update (1)\");\n              response->status = 500;\n            } else {\n              ulfius_add_cookie_to_response(response, config->session_key, session_uid, expires, 0, config->cookie_domain, \"/\", config->cookie_secure, 0);\n              y_log_message(Y_LOG_LEVEL_INFO, \"Event - User '%s' authenticated with password\", json_string_value(json_object_get(j_param, \"username\")));\n            }\n            o_free(session_uid);\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_VALID, 1, NULL);\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_VALID_SCHEME, 1, \"scheme_type\", \"password\", NULL);\n          } else {\n            if (check_result_value(j_result, G_ERROR_UNAUTHORIZED)) {\n              y_log_message(Y_LOG_LEVEL_WARNING, \"Security - Authorization invalid for username %s at IP Address %s\", json_string_value(json_object_get(j_param, \"username\")), ip_source);\n            }\n            if ((session_uid = get_session_id(config, request)) != NULL && user_session_update(config, session_uid, u_map_get_case(request->map_header, \"user-agent\"), issued_for, json_string_value(json_object_get(j_param, \"username\")), NULL, 1) != G_OK) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error user_session_update (2)\");\n            }\n            o_free(session_uid);\n            response->status = 401;\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_INVALID, 1, NULL);\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_INVALID_SCHEME, 1, \"scheme_type\", \"password\", NULL);\n          }\n          json_decref(j_result);\n        } else if (json_object_get(j_param, \"password\") != NULL && !json_is_string(json_object_get(j_param, \"password\"))) {\n          ulfius_set_string_body_response(response, 400, \"password must be a string\");\n        } else {\n          session_uid = get_session_id(config, request);\n          j_result = get_users_for_session(config, session_uid);\n          if (check_result_value(j_result, G_OK)) {\n            // Refresh username to set as default\n            if (user_session_update(config, u_map_get(request->map_cookie, config->session_key), u_map_get_case(request->map_header, \"user-agent\"), issued_for, json_string_value(json_object_get(j_param, \"username\")), NULL, 0) != G_OK) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error user_session_update (3)\");\n              response->status = 500;\n            } else {\n              ulfius_add_cookie_to_response(response, config->session_key, session_uid, expires, 0, config->cookie_domain, \"/\", config->cookie_secure, 0);\n            }\n          } else if (check_result_value(j_result, G_ERROR_NOT_FOUND)) {\n            response->status = 401;\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error get_users_for_session\");\n            response->status = 500;\n          }\n          o_free(session_uid);\n          json_decref(j_result);\n        }\n      } else {\n        if (json_string_length(json_object_get(j_param, \"scheme_type\")) && json_string_length(json_object_get(j_param, \"scheme_name\")) && json_is_object(json_object_get(j_param, \"value\"))) {\n          j_result = auth_check_user_scheme(config, json_string_value(json_object_get(j_param, \"scheme_type\")), json_string_value(json_object_get(j_param, \"scheme_name\")), json_string_value(json_object_get(j_param, \"username\")), json_object_get(j_param, \"value\"), request);\n          if (check_result_value(j_result, G_ERROR_PARAM)) {\n            ulfius_set_string_body_response(response, 400, \"bad scheme response\");\n          } else if (check_result_value(j_result, G_ERROR_UNAUTHORIZED)) {\n            y_log_message(Y_LOG_LEVEL_WARNING, \"Security - Authorization invalid for username %s at IP Address %s\", json_string_value(json_object_get(j_param, \"username\")), ip_source);\n            response->status = 401;\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_INVALID, 1, NULL);\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_INVALID_SCHEME, 1, \"scheme_type\", json_string_value(json_object_get(j_param, \"scheme_type\")), \"scheme_name\", json_string_value(json_object_get(j_param, \"scheme_name\")), NULL);\n          } else if (check_result_value(j_result, G_ERROR_NOT_FOUND)) {\n            response->status = 404;\n          } else if (check_result_value(j_result, G_OK)) {\n            if ((session_uid = get_session_id(config, request)) == NULL) {\n              session_uid = generate_session_id();\n            }\n            if (user_session_update(config, session_uid, u_map_get_case(request->map_header, \"user-agent\"), issued_for, json_string_value(json_object_get(j_param, \"username\")), json_string_value(json_object_get(j_param, \"scheme_name\")), 1) != G_OK) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error user_session_update (4)\");\n              response->status = 500;\n            } else {\n              ulfius_add_cookie_to_response(response, config->session_key, session_uid, expires, 0, config->cookie_domain, \"/\", config->cookie_secure, 0);\n              y_log_message(Y_LOG_LEVEL_INFO, \"Event - User '%s' authenticated with scheme '%s/%s'\", json_string_value(json_object_get(j_param, \"username\")), json_string_value(json_object_get(j_param, \"scheme_type\")), json_string_value(json_object_get(j_param, \"scheme_name\")));\n            }\n            o_free(session_uid);\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_VALID, 1, NULL);\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_VALID_SCHEME, 1, \"scheme_type\", json_string_value(json_object_get(j_param, \"scheme_type\")), \"scheme_name\", json_string_value(json_object_get(j_param, \"scheme_name\")), NULL);\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error auth_check_user_scheme\");\n            response->status = 500;\n          }\n          json_decref(j_result);\n        } else {\n          ulfius_set_string_body_response(response, 400, \"scheme_type, scheme_name and value are mandatory\");\n        }\n      }\n    } else {\n      if (json_string_length(json_object_get(j_param, \"scheme_type\")) && json_string_length(json_object_get(j_param, \"scheme_name\")) && json_is_object(json_object_get(j_param, \"value\"))) {\n        j_result = auth_check_identify_scheme(config, json_string_value(json_object_get(j_param, \"scheme_type\")), json_string_value(json_object_get(j_param, \"scheme_name\")), json_object_get(j_param, \"value\"), request);\n        if (check_result_value(j_result, G_ERROR_PARAM)) {\n          ulfius_set_string_body_response(response, 400, \"bad scheme response\");\n        } else if (check_result_value(j_result, G_ERROR_UNAUTHORIZED)) {\n          y_log_message(Y_LOG_LEVEL_WARNING, \"Security - Authorization invalid for username <UNKNOWN> at IP Address %s\", ip_source);\n          response->status = 401;\n        } else if (check_result_value(j_result, G_ERROR_NOT_FOUND)) {\n          response->status = 404;\n        } else if (check_result_value(j_result, G_OK)) {\n          if ((session_uid = get_session_id(config, request)) == NULL) {\n            session_uid = generate_session_id();\n          }\n          if (user_session_update(config, session_uid, u_map_get_case(request->map_header, \"user-agent\"), issued_for, json_string_value(json_object_get(j_result, \"username\")), json_string_value(json_object_get(j_param, \"scheme_name\")), 1) != G_OK) {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error user_session_update (4)\");\n            response->status = 500;\n          } else {\n            ulfius_add_cookie_to_response(response, config->session_key, session_uid, expires, 0, config->cookie_domain, \"/\", config->cookie_secure, 0);\n            y_log_message(Y_LOG_LEVEL_INFO, \"Event - User '%s' authenticated with scheme '%s/%s'\", json_string_value(json_object_get(j_result, \"username\")), json_string_value(json_object_get(j_param, \"scheme_type\")), json_string_value(json_object_get(j_param, \"scheme_name\")));\n          }\n          o_free(session_uid);\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error auth_check_user_scheme\");\n          response->status = 500;\n        }\n        json_decref(j_result);\n      } else {\n        ulfius_set_string_body_response(response, 400, \"username is mandatory\");\n      }\n    }\n  } else {\n    ulfius_set_string_body_response(response, 400, \"Input parameters must be in JSON format\");\n  }\n  json_decref(j_param);\n  o_free(issued_for);\n\n  return U_CALLBACK_CONTINUE;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "webservice.c",
        "method_name": "fixed_function",
        "raw_code": "int callback_glewlwyd_user_auth (const struct _u_request * request, struct _u_response * response, void * user_data) {\n  struct config_elements * config = (struct config_elements *)user_data;\n  json_t * j_param = ulfius_get_json_body_request(request, NULL), * j_result = NULL;\n  const char * ip_source = get_ip_source(request);\n  char * issued_for = get_client_hostname(request);\n  char * session_uid, expires[129];\n  time_t now;\n  struct tm ts;\n  \n  time(&now);\n  now += GLEWLWYD_DEFAULT_SESSION_EXPIRATION_COOKIE;\n  gmtime_r(&now, &ts);\n  strftime(expires, 128, \"%a, %d %b %Y %T %Z\", &ts);\n  if (j_param != NULL) {\n    if (json_string_length(json_object_get(j_param, \"username\"))) {\n      if (json_object_get(j_param, \"scheme_type\") == NULL || 0 == o_strcmp(json_string_value(json_object_get(j_param, \"scheme_type\")), \"password\")) {\n        if (json_string_length(json_object_get(j_param, \"password\"))) {\n          j_result = auth_check_user_credentials(config, json_string_value(json_object_get(j_param, \"username\")), json_string_value(json_object_get(j_param, \"password\")));\n          if (check_result_value(j_result, G_OK)) {\n            if ((session_uid = get_session_id(config, request)) == NULL) {\n              session_uid = generate_session_id();\n            }\n            if (user_session_update(config, session_uid, u_map_get_case(request->map_header, \"user-agent\"), issued_for, json_string_value(json_object_get(j_param, \"username\")), NULL, 1) != G_OK) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error user_session_update (1)\");\n              response->status = 500;\n            } else {\n              ulfius_add_cookie_to_response(response, config->session_key, session_uid, expires, 0, config->cookie_domain, \"/\", config->cookie_secure, 0);\n              y_log_message(Y_LOG_LEVEL_INFO, \"Event - User '%s' authenticated with password\", json_string_value(json_object_get(j_param, \"username\")));\n            }\n            o_free(session_uid);\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_VALID, 1, NULL);\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_VALID_SCHEME, 1, \"scheme_type\", \"password\", NULL);\n          } else {\n            if (check_result_value(j_result, G_ERROR_UNAUTHORIZED)) {\n              y_log_message(Y_LOG_LEVEL_WARNING, \"Security - Authorization invalid for username %s at IP Address %s\", json_string_value(json_object_get(j_param, \"username\")), ip_source);\n            }\n            response->status = 401;\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_INVALID, 1, NULL);\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_INVALID_SCHEME, 1, \"scheme_type\", \"password\", NULL);\n          }\n          json_decref(j_result);\n        } else if (json_object_get(j_param, \"password\") != NULL && !json_is_string(json_object_get(j_param, \"password\"))) {\n          ulfius_set_string_body_response(response, 400, \"password must be a string\");\n        } else {\n          session_uid = get_session_id(config, request);\n          j_result = get_users_for_session(config, session_uid);\n          if (check_result_value(j_result, G_OK)) {\n            // Refresh username to set as default\n            if (user_session_update(config, u_map_get(request->map_cookie, config->session_key), u_map_get_case(request->map_header, \"user-agent\"), issued_for, json_string_value(json_object_get(j_param, \"username\")), NULL, 0) != G_OK) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error user_session_update (3)\");\n              response->status = 500;\n            } else {\n              ulfius_add_cookie_to_response(response, config->session_key, session_uid, expires, 0, config->cookie_domain, \"/\", config->cookie_secure, 0);\n            }\n          } else if (check_result_value(j_result, G_ERROR_NOT_FOUND)) {\n            response->status = 401;\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error get_users_for_session\");\n            response->status = 500;\n          }\n          o_free(session_uid);\n          json_decref(j_result);\n        }\n      } else {\n        if (json_string_length(json_object_get(j_param, \"scheme_type\")) && json_string_length(json_object_get(j_param, \"scheme_name\")) && json_is_object(json_object_get(j_param, \"value\"))) {\n          j_result = auth_check_user_scheme(config, json_string_value(json_object_get(j_param, \"scheme_type\")), json_string_value(json_object_get(j_param, \"scheme_name\")), json_string_value(json_object_get(j_param, \"username\")), json_object_get(j_param, \"value\"), request);\n          if (check_result_value(j_result, G_ERROR_PARAM)) {\n            ulfius_set_string_body_response(response, 400, \"bad scheme response\");\n          } else if (check_result_value(j_result, G_ERROR_UNAUTHORIZED)) {\n            y_log_message(Y_LOG_LEVEL_WARNING, \"Security - Authorization invalid for username %s at IP Address %s\", json_string_value(json_object_get(j_param, \"username\")), ip_source);\n            response->status = 401;\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_INVALID, 1, NULL);\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_INVALID_SCHEME, 1, \"scheme_type\", json_string_value(json_object_get(j_param, \"scheme_type\")), \"scheme_name\", json_string_value(json_object_get(j_param, \"scheme_name\")), NULL);\n          } else if (check_result_value(j_result, G_ERROR_NOT_FOUND)) {\n            response->status = 404;\n          } else if (check_result_value(j_result, G_OK)) {\n            if ((session_uid = get_session_id(config, request)) == NULL) {\n              session_uid = generate_session_id();\n            }\n            if (user_session_update(config, session_uid, u_map_get_case(request->map_header, \"user-agent\"), issued_for, json_string_value(json_object_get(j_param, \"username\")), json_string_value(json_object_get(j_param, \"scheme_name\")), 1) != G_OK) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error user_session_update (4)\");\n              response->status = 500;\n            } else {\n              ulfius_add_cookie_to_response(response, config->session_key, session_uid, expires, 0, config->cookie_domain, \"/\", config->cookie_secure, 0);\n              y_log_message(Y_LOG_LEVEL_INFO, \"Event - User '%s' authenticated with scheme '%s/%s'\", json_string_value(json_object_get(j_param, \"username\")), json_string_value(json_object_get(j_param, \"scheme_type\")), json_string_value(json_object_get(j_param, \"scheme_name\")));\n            }\n            o_free(session_uid);\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_VALID, 1, NULL);\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_VALID_SCHEME, 1, \"scheme_type\", json_string_value(json_object_get(j_param, \"scheme_type\")), \"scheme_name\", json_string_value(json_object_get(j_param, \"scheme_name\")), NULL);\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error auth_check_user_scheme\");\n            response->status = 500;\n          }\n          json_decref(j_result);\n        } else {\n          ulfius_set_string_body_response(response, 400, \"scheme_type, scheme_name and value are mandatory\");\n        }\n      }\n    } else {\n      if (json_string_length(json_object_get(j_param, \"scheme_type\")) && json_string_length(json_object_get(j_param, \"scheme_name\")) && json_is_object(json_object_get(j_param, \"value\"))) {\n        j_result = auth_check_identify_scheme(config, json_string_value(json_object_get(j_param, \"scheme_type\")), json_string_value(json_object_get(j_param, \"scheme_name\")), json_object_get(j_param, \"value\"), request);\n        if (check_result_value(j_result, G_ERROR_PARAM)) {\n          ulfius_set_string_body_response(response, 400, \"bad scheme response\");\n        } else if (check_result_value(j_result, G_ERROR_UNAUTHORIZED)) {\n          y_log_message(Y_LOG_LEVEL_WARNING, \"Security - Authorization invalid for username <UNKNOWN> at IP Address %s\", ip_source);\n          response->status = 401;\n        } else if (check_result_value(j_result, G_ERROR_NOT_FOUND)) {\n          response->status = 404;\n        } else if (check_result_value(j_result, G_OK)) {\n          if ((session_uid = get_session_id(config, request)) == NULL) {\n            session_uid = generate_session_id();\n          }\n          if (user_session_update(config, session_uid, u_map_get_case(request->map_header, \"user-agent\"), issued_for, json_string_value(json_object_get(j_result, \"username\")), json_string_value(json_object_get(j_param, \"scheme_name\")), 1) != G_OK) {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error user_session_update (4)\");\n            response->status = 500;\n          } else {\n            ulfius_add_cookie_to_response(response, config->session_key, session_uid, expires, 0, config->cookie_domain, \"/\", config->cookie_secure, 0);\n            y_log_message(Y_LOG_LEVEL_INFO, \"Event - User '%s' authenticated with scheme '%s/%s'\", json_string_value(json_object_get(j_result, \"username\")), json_string_value(json_object_get(j_param, \"scheme_type\")), json_string_value(json_object_get(j_param, \"scheme_name\")));\n          }\n          o_free(session_uid);\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error auth_check_user_scheme\");\n          response->status = 500;\n        }\n        json_decref(j_result);\n      } else {\n        ulfius_set_string_body_response(response, 400, \"username is mandatory\");\n      }\n    }\n  } else {\n    ulfius_set_string_body_response(response, 400, \"Input parameters must be in JSON format\");\n  }\n  json_decref(j_param);\n  o_free(issued_for);\n\n  return U_CALLBACK_CONTINUE;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"glewlwyd.h\"\n#include <string.h>\n\n// Type Definitions:\n// config_elements:\nstruct config_elements\n\n// config_elements:\nstruct config_elements {\n  char *                                         config_file;\n  unsigned int                                   port;\n  char *                                         bind_address;\n  char *                                         bind_address_metrics;\n  char *                                         external_url;\n  char *                                         api_prefix;\n  char *                                         cookie_domain;\n  unsigned int                                   cookie_secure;\n  unsigned short                                 log_mode_args;\n  unsigned short                                 log_level_args;\n  unsigned long                                  log_mode;\n  unsigned long                                  log_level;\n  char *                                         log_file;\n  struct _u_compressed_inmemory_website_config * static_file_config;\n  char *                                         admin_scope;\n  char *                       ...\n\n// Called Methods (top 10):\n// glewlwyd_metrics_build_label from src/metrics.c:\nchar * glewlwyd_metrics_build_label(va_list vl_label) { /* <=== glewlwyd_metrics_build_label */ \n  const char * label_arg;\n  char * label = NULL;\n  int flag = 0;\n\n  for (label_arg = va_arg(vl_label, const char *); label_arg != NULL; label_arg = va_arg(vl_label, const char *)) {\n    if (!flag) {\n      if (label == NULL) {\n        label = msprintf(\"%s=\", label_arg);\n      } else {\n        label = mstrcatf(label, \", %s=\", label_arg);\n      }\n    } else {\n      label = mstrcatf(label, \"\\\"%s\\\"\", label_arg);\n    }\n    flag = !flag;\n  }\n  return label;\n}\n\n// check_result_value from docs/resources/ulfius/glewlwyd_resource.c:\nstatic int check_result_value(json_t * result, const int value) { /* <=== check_result_value */ \n  return (result != NULL && \n          json_is_object(result) && \n          json_object_get(result, \"result\") != NULL && \n          json_is_integer(json_object_get(result, \"result\")) && \n          json_integer_value(json_object_get(result, \"result\")) == value);\n}\n\n// auth_check_user_credentials from src/user.c:\njson_t * auth_check_user_credentials(struct config_elements * config, const char * username, const char * password) { /* <=== auth_check_user_credentials */ \n  int res;\n  json_t * j_return = NULL, * j_module_list = get_user_module_list(config), * j_module, * j_user;\n  struct _user_module_instance * user_module;\n  size_t index;\n  \n  if (check_result_value(j_module_list, G_OK)) {\n    json_array_foreach(json_object_get(j_module_list, \"module\"), index, j_module) {\n      if (j_return == NULL) {\n        user_module = get_user_module_instance(config, json_string_value(json_object_get(j_module, \"name\")));\n        if (user_module != NULL) {\n          if (user_module->enabled) {\n            j_user = user_module->module->user_module_get(config->config_m, username, user_module->cls);\n            if (check_result_value(j_user, G_OK) && json_object_get(json_object_get(j_user, \"user\"), \"enabled\") == json_true()) {\n              res = user_module->module->user_module_check_password(config->config_m, username, password, user_module->cls);\n              if (res == G_OK) {\n                j_return = json_pack(\"{si}\", \"result\", G_OK);\n              } else if (res == G_ERROR_UNAUTHORIZED) {\n                j_return = json_pack(\"{si}\", \"result\", G_ERROR_UNAUTHORIZED);\n              } else if (res != G_ERROR_NOT_FOUND) {\n                y_log_message(Y_LOG_LEVEL_ERROR, \"auth_check_user_credentials - Error, user_module_check_password for module '%s', skip\", user_module->name);\n              }\n            } else if (!check_result_value(j_user, G_ERROR_NOT_FOUND)) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"auth_check_user_credentials - Error, user_module_get for module '%s', skip\", user_module->name);\n            }\n            json_decref(j_user);\n          }\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"auth_check_user_credentials - Error, user_module_instance %s is NULL\", json_string_value(json_object_get(j_module, \"name\")));\n        }\n      }\n    }\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"auth_check_user_credentials - Error get_user_module_list\");\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n  }\n  if (j_return == NULL) {\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR_UNAUTHORIZED);\n  }\n  json_decref(j_module_list);\n  return j_return;\n}\n\n// generate_digest from src/misc.c:\nint generate_digest(digest_algorithm digest, const char * data, int use_salt, char * out_digest) { /* <=== generate_digest */ \n  unsigned int res = 0;\n  int alg, dig_res;\n  gnutls_datum_t key_data;\n  char * intermediate = NULL, salt[GLEWLWYD_DEFAULT_SALT_LENGTH + 1] = {0};\n  unsigned char encoded_key[128 + GLEWLWYD_DEFAULT_SALT_LENGTH + 1] = {0};\n  size_t encoded_key_size = (128 + GLEWLWYD_DEFAULT_SALT_LENGTH), encoded_key_size_base64;\n\n  if (data != NULL && out_digest != NULL) {\n    switch (digest) {\n      case digest_SHA1:\n        alg = GNUTLS_DIG_SHA1;\n        break;\n      case digest_SHA224:\n        alg = GNUTLS_DIG_SHA224;\n        break;\n      case digest_SHA256:\n        alg = GNUTLS_DIG_SHA256;\n        break;\n      case digest_SHA384:\n        alg = GNUTLS_DIG_SHA384;\n        break;\n      case digest_SHA512:\n        alg = GNUTLS_DIG_SHA512;\n        break;\n      case digest_MD5:\n        alg = GNUTLS_DIG_MD5;\n        break;\n      default:\n        alg = GNUTLS_DIG_UNKNOWN;\n        break;\n    }\n    \n    if(alg != GNUTLS_DIG_UNKNOWN) {\n      if (o_strlen(data) > 0) {\n        if (use_salt) {\n          rand_string_nonce(salt, GLEWLWYD_DEFAULT_SALT_LENGTH);\n          intermediate = msprintf(\"%s%s\", data, salt);\n        } else {\n          intermediate = o_strdup(data);\n        }\n        key_data.data = (unsigned char*)intermediate;\n        key_data.size = o_strlen(intermediate);\n        if (key_data.data != NULL && (dig_res = gnutls_fingerprint(alg, &key_data, encoded_key, &encoded_key_size)) == GNUTLS_E_SUCCESS) {\n          if (use_salt) {\n            memcpy(encoded_key+encoded_key_size, salt, GLEWLWYD_DEFAULT_SALT_LENGTH);\n            encoded_key_size += GLEWLWYD_DEFAULT_SALT_LENGTH;\n          }\n          if (o_base64_encode(encoded_key, encoded_key_size, (unsigned char *)out_digest, &encoded_key_size_base64)) {\n            res = 1;\n          } else{\n            res = 0;\n          }\n        } else {\n          res = 0;\n        }\n        o_free(intermediate);\n      } else {\n        // No data, then out_digest becomes an empty string\n        out_digest[0] = '\\0';\n        res = 1;\n      }\n    } else {\n      res = 0;\n    }\n  } else {\n    res = 0;\n  }\n  return res;\n}\n\n// get_user_module_instance from src/glewlwyd.c:\nstruct _user_module_instance * get_user_module_instance(struct config_elements * config, const char * name) { /* <=== get_user_module_instance */ \n  size_t i;\n  struct _user_module_instance * cur_instance;\n\n  for (i=0; i<pointer_list_size(config->user_module_instance_list); i++) {\n    cur_instance = (struct _user_module_instance *)pointer_list_get_at(config->user_module_instance_list, i);\n    if (cur_instance != NULL && 0 == o_strcmp(cur_instance->name, name)) {\n      return cur_instance;\n    }\n  }\n  return NULL;\n}\n\n// get_session_for_username from src/session.c:\njson_t * get_session_for_username(struct config_elements * config, const char * session_uid, const char * username) { /* <=== get_session_for_username */ \n  json_t * j_query, * j_result, * j_return, * j_session_scheme;\n  int res;\n  char * expire_clause;\n  char * session_uid_hash = generate_hash(config->hash_algorithm, session_uid);\n\n  if (config->conn->type==HOEL_DB_TYPE_MARIADB) {\n    expire_clause = o_strdup(\"> NOW()\");\n  } else if (config->conn->type==HOEL_DB_TYPE_PGSQL) {\n    expire_clause = o_strdup(\"> NOW()\");\n  } else { // HOEL_DB_TYPE_SQLITE\n    expire_clause = o_strdup(\"> (strftime('%s','now'))\");\n  }\n  if (session_uid_hash != NULL) {\n    j_query = json_pack(\"{sss[ss]s{sssssis{ssss}}}\",\n                        \"table\",\n                        GLEWLWYD_TABLE_USER_SESSION,\n                        \"columns\",\n                          \"gus_id\",\n                          SWITCH_DB_TYPE(config->conn->type, \"UNIX_TIMESTAMP(gus_expiration) AS expiration\", \"gus_expiration AS expiration\", \"EXTRACT(EPOCH FROM gus_expiration)::integer AS expiration\"),\n                        \"where\",\n                          \"gus_session_hash\",\n                          session_uid_hash,\n                          \"gus_username\",\n                          username,\n                          \"gus_enabled\",\n                          1,\n                          \"gus_expiration\",\n                            \"operator\",\n                            \"raw\",\n                            \"value\",\n                            expire_clause);\n    o_free(expire_clause);\n    res = h_select(config->conn, j_query, &j_result, NULL);\n    json_decref(j_query);\n    if (res == H_OK) {\n      if (json_array_size(j_result) > 0) {\n        j_session_scheme = get_session_scheme(config, json_integer_value(json_object_get(json_array_get(j_result, 0), \"gus_id\")));\n        if (check_result_value(j_session_scheme, G_OK)) {\n          j_return = json_pack(\"{sis{sssOsOsI}}\", \n                                \"result\", \n                                G_OK, \n                                \"session\", \n                                  \"username\", \n                                  username, \n                                  \"expiration\", \n                                  json_object_get(json_array_get(j_result, 0), \"expiration\"),\n                                  \"scheme\",\n                                  json_object_get(j_session_scheme, \"scheme\"),\n                                  \"gus_id\",\n                                  json_integer_value(json_object_get(json_array_get(j_result, 0), \"gus_id\")));\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"get_session_for_username - Error get_session_scheme\");\n          j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n        }\n        json_decref(j_session_scheme);\n      } else {\n        j_return = json_pack(\"{si}\", \"result\", G_ERROR_NOT_FOUND);\n      }\n      json_decref(j_result);\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"get_session_for_username - Error executing j_query\");\n      glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_DATABSE_ERROR, 1, NULL);\n      j_return = json_pack(\"{si}\", \"result\", G_ERROR_DB);\n    }\n    o_free(session_uid_hash);\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"get_session_for_username - Error generate_hash\");\n    j_return = json_pack(\"{si}\", \"result\", G_ERROR);\n  }\n  return j_return;\n}\n\n// G_ERROR_DB from src/glewlwyd-common.h:\n#define G_ERROR_DB           4 /* <=== src/glewlwyd-common.h:57:57:G_ERROR_DB:0 */ \n\n// get_client_hostname from src/misc.c:\nchar * get_client_hostname(const struct _u_request * request) { /* <=== get_client_hostname */ \n  const char * ip_source = get_ip_source(request);\n  struct addrinfo hints;\n  struct addrinfo * lookup = NULL;\n  char * hostname = NULL;\n  \n  memset(&hints, 0, sizeof(struct addrinfo));\n  hints.ai_family = AF_UNSPEC;\n  hints.ai_flags = AI_CANONNAME;\n  hints.ai_canonname = NULL;\n  if (ip_source != NULL) {\n    hostname = o_strdup(ip_source);\n    if (!getaddrinfo(ip_source, NULL, &hints, &lookup)) {\n      if (o_strlen(lookup->ai_canonname)) {\n        hostname = mstrcatf(hostname, \" - %s\", lookup->ai_canonname);\n      }\n      freeaddrinfo(lookup);\n      lookup = NULL;\n    }\n  }\n  \n  return hostname;\n}\n\n// GLWD_METRICS_DATABSE_ERROR from src/glewlwyd-common.h:\n#define GLWD_METRICS_DATABSE_ERROR            \"glewlwyd_database_error\" /* <=== src/glewlwyd-common.h:312:312:GLWD_METRICS_DATABSE_ERROR:0 */ \n\n// GLEWLWYD_TABLE_USER_MODULE_INSTANCE from src/glewlwyd.h:\n#define GLEWLWYD_TABLE_USER_MODULE_INSTANCE                    \"g_user_module_instance\" /* <=== src/glewlwyd.h:84:84:GLEWLWYD_TABLE_USER_MODULE_INSTANCE:0 */ \n"
  },
  {
    "repository": "squashfs-tools",
    "cve_id": "CVE-2021-40153",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "79b5a555058eef4e1e7ff220c344d39f8cd09646",
    "short_hash": "79b5a555",
    "vulnerableMethods_before": [
      {
        "filename": "None",
        "method_name": "vulnerable_function",
        "raw_code": "static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,\n\tstruct inode **i)\n{\n\tstruct squashfs_dir_header dirh;\n\tchar buffer[sizeof(struct squashfs_dir_entry) + SQUASHFS_NAME_LEN + 1]\n\t\t__attribute__((aligned));\n\tstruct squashfs_dir_entry *dire = (struct squashfs_dir_entry *) buffer;\n\tlong long start;\n\tlong long bytes;\n\tint dir_count, size;\n\tstruct dir_ent *new_dir;\n\tstruct dir *dir;\n\n\tTRACE(\"squashfs_opendir: inode start block %d, offset %d\\n\",\n\t\tblock_start, offset);\n\n\t*i = read_inode(block_start, offset);\n\n\tdir = malloc(sizeof(struct dir));\n\tif(dir == NULL)\n\t\tEXIT_UNSQUASH(\"squashfs_opendir: malloc failed!\\n\");\n\n\tdir->dir_count = 0;\n\tdir->cur_entry = 0;\n\tdir->mode = (*i)->mode;\n\tdir->uid = (*i)->uid;\n\tdir->guid = (*i)->gid;\n\tdir->mtime = (*i)->time;\n\tdir->xattr = (*i)->xattr;\n\tdir->dirs = NULL;\n\n\tif ((*i)->data == 3)\n\t\t/*\n\t\t * if the directory is empty, skip the unnecessary\n\t\t * lookup_entry, this fixes the corner case with\n\t\t * completely empty filesystems where lookup_entry correctly\n\t\t * returning -1 is incorrectly treated as an error\n\t\t */\n\t\treturn dir;\n\n\tstart = sBlk.s.directory_table_start + (*i)->start;\n\tbytes = lookup_entry(directory_table_hash, start);\n\n\tif(bytes == -1)\n\t\tEXIT_UNSQUASH(\"squashfs_opendir: directory block %lld not \"\n\t\t\t\"found!\\n\", start);\n\n\tbytes += (*i)->offset;\n\tsize = (*i)->data + bytes - 3;\n\n\twhile(bytes < size) {\t\t\t\n\t\tSQUASHFS_SWAP_DIR_HEADER(directory_table + bytes, &dirh);\n\t\n\t\tdir_count = dirh.count + 1;\n\t\tTRACE(\"squashfs_opendir: Read directory header @ byte position \"\n\t\t\t\"%d, %d directory entries\\n\", bytes, dir_count);\n\t\tbytes += sizeof(dirh);\n\n\t\t/* dir_count should never be larger than SQUASHFS_DIR_COUNT */\n\t\tif(dir_count > SQUASHFS_DIR_COUNT) {\n\t\t\tERROR(\"File system corrupted: too many entries in directory\\n\");\n\t\t\tgoto corrupted;\n\t\t}\n\n\t\twhile(dir_count--) {\n\t\t\tSQUASHFS_SWAP_DIR_ENTRY(directory_table + bytes, dire);\n\n\t\t\tbytes += sizeof(*dire);\n\n\t\t\t/* size should never be SQUASHFS_NAME_LEN or larger */\n\t\t\tif(dire->size >= SQUASHFS_NAME_LEN) {\n\t\t\t\tERROR(\"File system corrupted: filename too long\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tmemcpy(dire->name, directory_table + bytes,\n\t\t\t\tdire->size + 1);\n\t\t\tdire->name[dire->size + 1] = '\\0';\n\t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n\t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n\t\t\t\tdirh.start_block, dire->offset, dire->type);\n\t\t\tif((dir->dir_count % DIR_ENT_SIZE) == 0) {\n\t\t\t\tnew_dir = realloc(dir->dirs, (dir->dir_count +\n\t\t\t\t\tDIR_ENT_SIZE) * sizeof(struct dir_ent));\n\t\t\t\tif(new_dir == NULL)\n\t\t\t\t\tEXIT_UNSQUASH(\"squashfs_opendir: \"\n\t\t\t\t\t\t\"realloc failed!\\n\");\n\t\t\t\tdir->dirs = new_dir;\n\t\t\t}\n\t\t\tstrcpy(dir->dirs[dir->dir_count].name, dire->name);\n\t\t\tdir->dirs[dir->dir_count].start_block =\n\t\t\t\tdirh.start_block;\n\t\t\tdir->dirs[dir->dir_count].offset = dire->offset;\n\t\t\tdir->dirs[dir->dir_count].type = dire->type;\n\t\t\tdir->dir_count ++;\n\t\t\tbytes += dire->size + 1;\n\t\t}\n\t}\n\n\treturn dir;\n\ncorrupted:\n\tfree(dir->dirs);\n\tfree(dir);\n\treturn NULL;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "None",
        "method_name": "fixed_function",
        "raw_code": "static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,\n\tstruct inode **i)\n{\n\tstruct squashfs_dir_header dirh;\n\tchar buffer[sizeof(struct squashfs_dir_entry) + SQUASHFS_NAME_LEN + 1]\n\t\t__attribute__((aligned));\n\tstruct squashfs_dir_entry *dire = (struct squashfs_dir_entry *) buffer;\n\tlong long start;\n\tlong long bytes;\n\tint dir_count, size;\n\tstruct dir_ent *new_dir;\n\tstruct dir *dir;\n\n\tTRACE(\"squashfs_opendir: inode start block %d, offset %d\\n\",\n\t\tblock_start, offset);\n\n\t*i = read_inode(block_start, offset);\n\n\tdir = malloc(sizeof(struct dir));\n\tif(dir == NULL)\n\t\tEXIT_UNSQUASH(\"squashfs_opendir: malloc failed!\\n\");\n\n\tdir->dir_count = 0;\n\tdir->cur_entry = 0;\n\tdir->mode = (*i)->mode;\n\tdir->uid = (*i)->uid;\n\tdir->guid = (*i)->gid;\n\tdir->mtime = (*i)->time;\n\tdir->xattr = (*i)->xattr;\n\tdir->dirs = NULL;\n\n\tif ((*i)->data == 3)\n\t\t/*\n\t\t * if the directory is empty, skip the unnecessary\n\t\t * lookup_entry, this fixes the corner case with\n\t\t * completely empty filesystems where lookup_entry correctly\n\t\t * returning -1 is incorrectly treated as an error\n\t\t */\n\t\treturn dir;\n\n\tstart = sBlk.s.directory_table_start + (*i)->start;\n\tbytes = lookup_entry(directory_table_hash, start);\n\n\tif(bytes == -1)\n\t\tEXIT_UNSQUASH(\"squashfs_opendir: directory block %lld not \"\n\t\t\t\"found!\\n\", start);\n\n\tbytes += (*i)->offset;\n\tsize = (*i)->data + bytes - 3;\n\n\twhile(bytes < size) {\t\t\t\n\t\tSQUASHFS_SWAP_DIR_HEADER(directory_table + bytes, &dirh);\n\t\n\t\tdir_count = dirh.count + 1;\n\t\tTRACE(\"squashfs_opendir: Read directory header @ byte position \"\n\t\t\t\"%d, %d directory entries\\n\", bytes, dir_count);\n\t\tbytes += sizeof(dirh);\n\n\t\t/* dir_count should never be larger than SQUASHFS_DIR_COUNT */\n\t\tif(dir_count > SQUASHFS_DIR_COUNT) {\n\t\t\tERROR(\"File system corrupted: too many entries in directory\\n\");\n\t\t\tgoto corrupted;\n\t\t}\n\n\t\twhile(dir_count--) {\n\t\t\tSQUASHFS_SWAP_DIR_ENTRY(directory_table + bytes, dire);\n\n\t\t\tbytes += sizeof(*dire);\n\n\t\t\t/* size should never be SQUASHFS_NAME_LEN or larger */\n\t\t\tif(dire->size >= SQUASHFS_NAME_LEN) {\n\t\t\t\tERROR(\"File system corrupted: filename too long\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tmemcpy(dire->name, directory_table + bytes,\n\t\t\t\tdire->size + 1);\n\t\t\tdire->name[dire->size + 1] = '\\0';\n\n\t\t\t/* check name for invalid characters (i.e /, ., ..) */\n\t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {\n\t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n\t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n\t\t\t\tdirh.start_block, dire->offset, dire->type);\n\t\t\tif((dir->dir_count % DIR_ENT_SIZE) == 0) {\n\t\t\t\tnew_dir = realloc(dir->dirs, (dir->dir_count +\n\t\t\t\t\tDIR_ENT_SIZE) * sizeof(struct dir_ent));\n\t\t\t\tif(new_dir == NULL)\n\t\t\t\t\tEXIT_UNSQUASH(\"squashfs_opendir: \"\n\t\t\t\t\t\t\"realloc failed!\\n\");\n\t\t\t\tdir->dirs = new_dir;\n\t\t\t}\n\t\t\tstrcpy(dir->dirs[dir->dir_count].name, dire->name);\n\t\t\tdir->dirs[dir->dir_count].start_block =\n\t\t\t\tdirh.start_block;\n\t\t\tdir->dirs[dir->dir_count].offset = dire->offset;\n\t\t\tdir->dirs[dir->dir_count].type = dire->type;\n\t\t\tdir->dir_count ++;\n\t\t\tbytes += dire->size + 1;\n\t\t}\n\t}\n\n\treturn dir;\n\ncorrupted:\n\tfree(dir->dirs);\n\tfree(dir);\n\treturn NULL;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"unsquashfs.h\"\n#include \"squashfs_compat.h\"\n\n// Type Definitions:\n// dir:\nstruct dir\n\n// dir:\nstruct dir {\n\tint\t\tdir_count;\n\tint \t\tcur_entry;\n\tunsigned int\tmode;\n\tuid_t\t\tuid;\n\tgid_t\t\tguid;\n\tunsigned int\tmtime;\n\tunsigned int xattr;\n\tstruct dir_ent\t*dirs;\n}\n\n// dir_ent:\nstruct dir_ent {\n\tchar\t\t\t*name;\n\tchar\t\t\t*source_name;\n\tchar\t\t\t*nonstandard_pathname;\n\tstruct inode_info\t*inode;\n\tstruct dir_info\t\t*dir;\n\tstruct dir_info\t\t*our_dir;\n\tstruct dir_ent\t\t*next;\n}\n\n// inode:\nstatic struct inode\n\n// squashfs_dir_header_2:\nstruct squashfs_dir_header_2 {\n\tunsigned int\t\tcount:8;\n\tunsigned int\t\tstart_block:24;\n} __attribute__ ((packed))\n\n// dir_ent:\nstatic struct dir_ent\n\n// squashfs_dir_entry_2:\nstruct squashfs_dir_entry_2 {\n\tunsigned int\t\toffset:13;\n\tunsigned int\t\ttype:3;\n\tunsigned int\t\tsize:8;\n\tchar\t\t\tname[0];\n} __attribute__ ((packed))\n\n// Called Methods (top 10):\n// SQUASHFS_SWAP_REG_INODE_HEADER_1 from squashfs-tools/squashfs_compat.h:\n\n\n// SQUASHFS_SWAP_IPC_INODE_HEADER_1 from squashfs-tools/squashfs_compat.h:\n\n\n// SQUASHFS_CHRDEV_TYPE from squashfs-tools/squashfs_fs.h:\n\n\n// FALSE from squashfs-tools/unsquash-1234.c:\n\n\n// progressbar_error from squashfs-tools/progressbar.c:\nvoid progressbar_error(char *fmt, ...)\n{\n\tva_list ap;\n\n\tpthread_cleanup_push((void *) pthread_mutex_unlock, &progress_mutex);\n\tpthread_mutex_lock(&progress_mutex);\n\n\tif(display_progress_bar && !temp_disabled)\n\t\tfprintf(stderr, \"\\n\");\n\n\tva_start(ap, fmt);\n\tvfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\n\tpthread_cleanup_pop(1);\n}\n\n// SQUASHFS_DIR_TYPE from squashfs-tools/squashfs_fs.h:\n\n\n// SQUASHFS_INVALID_XATTR from squashfs-tools/squashfs_fs.h:\n\n\n// SQUASHFS_SWAP_DIR_INODE_HEADER_1 from squashfs-tools/squashfs_compat.h:\n\n\n// SQUASHFS_SWAP_SYMLINK_INODE_HEADER_1 from squashfs-tools/squashfs_compat.h:\n\n\n// SQUASHFS_NAME_LEN from squashfs-tools/squashfs_fs.h:\n<empty>\n"
  },
  {
    "repository": "gpac",
    "cve_id": "CVE-2020-35981",
    "cwe_list": [
      "CWE-476"
    ],
    "commit_hash": "dae9900580a8888969481cd72035408091edb11b",
    "short_hash": "dae99005",
    "vulnerableMethods_before": [
      {
        "filename": "isom_store.c",
        "method_name": "vulnerable_function",
        "raw_code": "GF_Err SetupWriters(MovieWriter *mw, GF_List *writers, u8 interleaving)\n{\n\tu32 i, trackCount;\n\tTrackWriter *writer;\n\tGF_TrackBox *trak;\n\tGF_ISOFile *movie = mw->movie;\n\n\tmw->total_samples = mw->nb_done = 0;\n\tif (!movie->moov) return GF_OK;\n\n\ttrackCount = gf_list_count(movie->moov->trackList);\n\tfor (i = 0; i < trackCount; i++) {\n\t\ttrak = gf_isom_get_track(movie->moov, i+1);\n\n\t\tGF_SAFEALLOC(writer, TrackWriter);\n\t\tif (!writer) goto exit;\n\t\twriter->sampleNumber = 1;\n\t\twriter->mdia = trak->Media;\n\t\twriter->stbl = trak->Media->information->sampleTable;\n\t\twriter->timeScale = trak->Media->mediaHeader->timeScale;\n\t\twriter->all_dref_mode = Media_SelfContainedType(writer->mdia);\n\n\t\tif (trak->sample_encryption)\n\t\t\twriter->prevent_dispatch = GF_TRUE;\n\n\t\twriter->isDone = 0;\n\t\twriter->DTSprev = 0;\n\t\twriter->chunkDur = 0;\n\t\twriter->chunkSize = 0;\n\t\twriter->constant_size = writer->constant_dur = 0;\n\t\tif (writer->stbl->SampleSize->sampleSize)\n\t\t\twriter->constant_size = writer->stbl->SampleSize->sampleSize;\n\t\tif (writer->stbl->TimeToSample->nb_entries==1) {\n\t\t\twriter->constant_dur = writer->stbl->TimeToSample->entries[0].sampleDelta;\n\t\t\tif (writer->constant_dur>1) writer->constant_dur = 0;\n\t\t}\n\t\tif (!writer->constant_dur || !writer->constant_size || (writer->constant_size>=10))\n\t\t\twriter->constant_size = writer->constant_dur = 0;\n\n\t\twriter->stsc = (GF_SampleToChunkBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_STSC);\n\t\tif (!writer->stsc) return GF_OUT_OF_MEM;\n\t\tif (writer->stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\t\twriter->stco = gf_isom_box_new(GF_ISOM_BOX_TYPE_STCO);\n\t\t} else {\n\t\t\twriter->stco = gf_isom_box_new(GF_ISOM_BOX_TYPE_CO64);\n\t\t}\n\t\tif (!writer->stco) return GF_OUT_OF_MEM;\n\t\t/*stops from chunk escape*/\n\t\tif (interleaving) writer->stbl->MaxSamplePerChunk = 0;\n\t\t/*for progress, assume only one descIndex*/\n\t\tif (Media_IsSelfContained(writer->mdia, 1))\n\t\t\tmw->total_samples += writer->stbl->SampleSize->sampleCount;\n\t\t/*optimization for interleaving: put audio last (this can be overridden by priorities)*/\n\t\tif (movie->storageMode != GF_ISOM_STORE_INTERLEAVED) {\n\t\t\tgf_list_add(writers, writer);\n\t\t} else {\n\t\t\tif (writer->mdia->information->InfoHeader && writer->mdia->information->InfoHeader->type == GF_ISOM_BOX_TYPE_SMHD) {\n\t\t\t\tgf_list_add(writers, writer);\n\t\t\t} else {\n\t\t\t\tgf_list_insert(writers, writer, 0);\n\t\t\t}\n\t\t}\n\t\tif (movie->sample_groups_in_traf && trak->Media->information->sampleTable) {\n\t\t\tgf_isom_box_array_del_parent(&trak->Media->information->sampleTable->child_boxes, trak->Media->information->sampleTable->sampleGroupsDescription);\n\t\t\ttrak->Media->information->sampleTable->sampleGroupsDescription = NULL;\n\t\t}\n\t}\n\treturn GF_OK;\n\nexit:\n\tCleanWriters(writers);\n\treturn GF_OUT_OF_MEM;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "isom_store.c",
        "method_name": "fixed_function",
        "raw_code": "GF_Err SetupWriters(MovieWriter *mw, GF_List *writers, u8 interleaving)\n{\n\tu32 i, trackCount;\n\tTrackWriter *writer;\n\tGF_TrackBox *trak;\n\tGF_ISOFile *movie = mw->movie;\n\n\tmw->total_samples = mw->nb_done = 0;\n\tif (!movie->moov) return GF_OK;\n\n\ttrackCount = gf_list_count(movie->moov->trackList);\n\tfor (i = 0; i < trackCount; i++) {\n\t\tGF_SampleTableBox *stbl;\n\t\ttrak = gf_isom_get_track(movie->moov, i+1);\n\n\t\tstbl = (trak->Media && trak->Media->information) ? trak->Media->information->sampleTable : NULL;\n\t\tif (!stbl || !stbl->SampleSize || !stbl->ChunkOffset || !stbl->SampleToChunk) {\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\tGF_SAFEALLOC(writer, TrackWriter);\n\t\tif (!writer) goto exit;\n\t\twriter->sampleNumber = 1;\n\t\twriter->mdia = trak->Media;\n\t\twriter->stbl = trak->Media->information->sampleTable;\n\t\twriter->timeScale = trak->Media->mediaHeader->timeScale;\n\t\twriter->all_dref_mode = Media_SelfContainedType(writer->mdia);\n\n\t\tif (trak->sample_encryption)\n\t\t\twriter->prevent_dispatch = GF_TRUE;\n\n\t\twriter->isDone = 0;\n\t\twriter->DTSprev = 0;\n\t\twriter->chunkDur = 0;\n\t\twriter->chunkSize = 0;\n\t\twriter->constant_size = writer->constant_dur = 0;\n\t\tif (writer->stbl->SampleSize->sampleSize)\n\t\t\twriter->constant_size = writer->stbl->SampleSize->sampleSize;\n\t\tif (writer->stbl->TimeToSample->nb_entries==1) {\n\t\t\twriter->constant_dur = writer->stbl->TimeToSample->entries[0].sampleDelta;\n\t\t\tif (writer->constant_dur>1) writer->constant_dur = 0;\n\t\t}\n\t\tif (!writer->constant_dur || !writer->constant_size || (writer->constant_size>=10))\n\t\t\twriter->constant_size = writer->constant_dur = 0;\n\n\t\twriter->stsc = (GF_SampleToChunkBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_STSC);\n\t\tif (!writer->stsc) return GF_OUT_OF_MEM;\n\t\tif (writer->stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) {\n\t\t\twriter->stco = gf_isom_box_new(GF_ISOM_BOX_TYPE_STCO);\n\t\t} else {\n\t\t\twriter->stco = gf_isom_box_new(GF_ISOM_BOX_TYPE_CO64);\n\t\t}\n\t\tif (!writer->stco) return GF_OUT_OF_MEM;\n\t\t/*stops from chunk escape*/\n\t\tif (interleaving) writer->stbl->MaxSamplePerChunk = 0;\n\t\t/*for progress, assume only one descIndex*/\n\t\tif (Media_IsSelfContained(writer->mdia, 1))\n\t\t\tmw->total_samples += writer->stbl->SampleSize->sampleCount;\n\t\t/*optimization for interleaving: put audio last (this can be overridden by priorities)*/\n\t\tif (movie->storageMode != GF_ISOM_STORE_INTERLEAVED) {\n\t\t\tgf_list_add(writers, writer);\n\t\t} else {\n\t\t\tif (writer->mdia->information->InfoHeader && writer->mdia->information->InfoHeader->type == GF_ISOM_BOX_TYPE_SMHD) {\n\t\t\t\tgf_list_add(writers, writer);\n\t\t\t} else {\n\t\t\t\tgf_list_insert(writers, writer, 0);\n\t\t\t}\n\t\t}\n\t\tif (movie->sample_groups_in_traf && trak->Media->information->sampleTable) {\n\t\t\tgf_isom_box_array_del_parent(&trak->Media->information->sampleTable->child_boxes, trak->Media->information->sampleTable->sampleGroupsDescription);\n\t\t\ttrak->Media->information->sampleTable->sampleGroupsDescription = NULL;\n\t\t}\n\t}\n\treturn GF_OK;\n\nexit:\n\tCleanWriters(writers);\n\treturn GF_OUT_OF_MEM;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <gpac/revision.h>\n#include <gpac/internal/isomedia_dev.h>\n\n// Type Definitions:\n// MovieWriter:\ntypedef struct\n{\n\tchar *buffer;\n\tu32 alloc_size;\n\tGF_ISOFile *movie;\n\tu32 total_samples, nb_done;\n}\n\n// GF_SampleTableBox:\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_TimeToSampleBox *TimeToSample;\n\tGF_CompositionOffsetBox *CompositionOffset;\n\tGF_CompositionToDecodeBox *CompositionToDecode;\n\tGF_SyncSampleBox *SyncSample;\n\tGF_SampleDescriptionBox *SampleDescription;\n\tGF_SampleSizeBox *SampleSize;\n\tGF_SampleToChunkBox *SampleToChunk;\n\t/*untyped, to handle 32 bits and 64 bits chunkOffsets*/\n\tGF_Box *ChunkOffset;\n\tGF_ShadowSyncBox *ShadowSync;\n\tGF_DegradationPriorityBox *DegradationPriority;\n\tGF_PaddingBitsBox *PaddingBits;\n\tGF_SampleDependencyTypeBox *SampleDep;\n\n\tGF_TrafToSampleMap *traf_map;\n\n\tGF_List *sub_samples;\n\n\tGF_List *sampleGroups;\n\tGF_List *compactSampleGroups;\n\tGF_List *sampleGroupsDescription;\n\tu32 nb_sgpd_in_stbl;\n\tu32 nb_stbl_boxes;\n\n\tGF_List *sai_sizes;\n\tGF_List *sai_offsets;\n\n\tu32 MaxSamplePerChunk, MaxChunkSize;\n\tu16 groupID;\n\tu16 trackPriority;\n\tu32 currentEntryIndex;\n\n\tBool no_sync_found;\n\n\tu32 r_last_chunk_num, r_last_sample_num, r_last_offset_in_chunk;\n}\n\n// GF_List:\ntypedef struct _tag_array GF_List;\n\n// GF_ISOFile:\ntypedef struct __tag_isom GF_ISOFile;\n\n// u32:\ntypedef unsigned int u32;\n\n// GF_TrackBox:\ntypedef struct\n{\n\tGF_ISOM_BOX\n\tGF_UserDataBox *udta;\n\tGF_TrackHeaderBox *Header;\n\tstruct __tag_media_box *Media;\n\tGF_EditBox *editBox;\n\tGF_TrackReferenceBox *References;\n\t/*meta box if any*/\n\tstruct __tag_meta_box *meta;\n\tGF_TrackGroupBox *groups;\n\n\tGF_Box *Aperture;\n\t\n\tGF_MovieBox *moov;\n\t/*private for media padding*/\n\tu32 padding_bytes;\n\t/*private for editing*/\n\tBool is_unpacked;\n\t/*private for checking dependency*/\n\tu32 originalFile;\n\tu32 originalID;\n\n\t//not sure about piff (not supposed to be stored in moov), but senc is in track according to CENC\n\tstruct __sample_encryption_box *sample_encryption;\n\n\t/*private for SVC/MVC extractors resolution*/\n\tGF_ISONaluExtractMode extractor_mode;\n\tBool has_base_layer;\n\tu32 pack_num_samples;\n\n\tu64 magic;\n\tu32 index;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tu64 first_dts_chunk;\n\tu32 nb_samples_in_cache;\n\tu32 chunk_stsd_idx;\n\tu32 chunk_cache_size;\n\tGF_BitStream *chunk_cache;\n#endif\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tu64 dts_at_seg_start;\n\tu32 sampl...\n\n// u8:\ntypedef unsigned char u8;\n\n// TrackWriter:\ntypedef struct\n{\n\tGF_FilterPid *ipid;\n\tu32 track_num, track_id;\n\tGF_ISOSample sample;\n\n\tu32 src_timescale;\n\tu32 tk_timescale;\n\tu32 stream_type;\n\tu32 codecid;\n\tBool is_encrypted;\n\n\tu32 cfg_crc, enh_cfg_crc;\n\tu32 dep_id;\n\tu32 stsd_idx;\n\tu32 clear_stsd_idx;\n\n\tBool use_dref;\n\tBool aborted;\n\tBool suspended;\n\tBool has_append;\n\tBool has_ctts;\n\ts64 min_neg_ctts;\n\tu32 nb_samples, samples_in_stsd;\n\tu32 nb_frames_per_sample;\n\tu64 ts_shift;\n\n\tBool skip_bitrate_update;\n\tBool has_open_gop;\n\tGF_FilterSAPType gdr_type;\n\n\tBool next_is_first_sample;\n\n\tu32 media_profile_level;\n\n\tBool import_msg_header_done;\n\n\tu32 nal_unit_size;\n\n\tGF_AVCConfig *avcc, *svcc;\n\tGF_HEVCConfig *hvcc, *lvcc;\n\tGF_VVCConfig *vvcc;\n\n\tu8 *inband_hdr;\n\tu32 inband_hdr_size;\n\tu32 is_nalu;\n\tBool is_av1, is_vpx;\n\tBool fragment_done;\n\ts32 ts_delay, negctts_shift;\n\tBool insert_tfdt, probe_min_ctts;\n\tu64 first_dts_in_seg, next_seg_cts, cts_next;\n\tu64 offset_dts;\n\tu32 samples_in_frag;\n\n\t//0: not cenc, 1: needs setup of stsd entry, 2: set...\n\n// Called Methods (top 10):\n// gf_isom_get_track from src/isomedia/track.c:\nGF_TrackBox *gf_isom_get_track(GF_MovieBox *moov, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tif (!moov || !trackNumber || (trackNumber > gf_list_count(moov->trackList))) return NULL;\n\ttrak = (GF_TrackBox*)gf_list_get(moov->trackList, trackNumber - 1);\n\treturn trak;\n\n}\n\n// Media_IsSelfContained from src/isomedia/media.c:\nBool Media_IsSelfContained(GF_MediaBox *mdia, u32 StreamDescIndex)\n{\n\tu32 drefIndex=0;\n\tGF_FullBox *a=NULL;\n\tGF_SampleEntryBox *se = NULL;\n\n\tMedia_GetSampleDesc(mdia, StreamDescIndex, &se, &drefIndex);\n\tif (!drefIndex) return 0;\n\tif (mdia\n\t\t&& mdia->information\n\t\t&& mdia->information->dataInformation\n\t\t&& mdia->information->dataInformation->dref\n\t) {\n\t\ta = (GF_FullBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, drefIndex - 1);\n\t}\n\tif (!a) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] broken file: Data reference index set to %d but no data reference entry found\\n\", drefIndex));\n\t\treturn 0;\n\t}\n\tif (a->flags & 1) return 1;\n\t/*QT specific*/\n\tif (a->type == GF_QT_BOX_TYPE_ALIS) return 1;\n\treturn 0;\n}\n\n// gf_isom_box_array_del_parent from src/isomedia/box_funcs.c:\nvoid gf_isom_box_array_del_parent(GF_List **child_boxes, GF_List *boxlist)\n{\n\tif (!boxlist) return;\n\tgf_isom_box_array_reset_parent(child_boxes, boxlist);\n\tgf_list_del(boxlist);\n}\n\n// gf_isom_box_new from src/isomedia/box_funcs.c:\nGF_Box *gf_isom_box_new(u32 boxType)\n{\n\treturn gf_isom_box_new_ex(boxType, 0, 0, GF_FALSE);\n}\n\n// gf_list_insert from src/utils/list.c:\nGF_Err gf_list_insert(GF_List *ptr, void *item, u32 position)\n{\n\tu32 i;\n\tItemSlot *tmp, *tmp2;\n\n\tif (!ptr || !item) return GF_BAD_PARAM;\n\t/*if last entry or first of an empty array...*/\n\tif (position >= ptr->entryCount) return gf_list_add(ptr, item);\n\n\ttmp2 = (ItemSlot *) gf_malloc(sizeof(ItemSlot));\n\ttmp2->data = item;\n\ttmp2->next = NULL;\n\t/*special case for the head*/\n\tif (position == 0) {\n\t\ttmp2->next = ptr->head;\n\t\tptr->head = tmp2;\n\t\tptr->entryCount ++;\n\t\tptr->foundEntry = tmp2;\n\t\tptr->foundEntryNumber = 0;\n\t\treturn GF_OK;\n\t}\n\ttmp = ptr->head;\n\tfor (i = 1; i < position; i++) {\n\t\ttmp = tmp->next;\n\t\tif (!tmp)\n\t\t\tbreak;\n\t}\n\ttmp2->next = tmp->next;\n\ttmp->next = tmp2;\n\tptr->entryCount ++;\n\tptr->foundEntry = tmp2;\n\tptr->foundEntryNumber = i;\n\treturn GF_OK;\n}\n\n// Media_SelfContainedType from src/isomedia/media.c:\nGF_ISOMDataRefAllType Media_SelfContainedType(GF_MediaBox *mdia)\n{\n\tu32 nb_ext, nb_self;\n\tu32 i, count;\n\n\tnb_ext = nb_self = 0;\n\tcount = gf_list_count(mdia->information->sampleTable->SampleDescription->child_boxes);\n\tfor (i=0; i<count; i++) {\n\t\tif (Media_IsSelfContained(mdia, i+1)) nb_self++;\n\t\telse nb_ext++;\n\t}\n\tif (nb_ext==count) return ISOM_DREF_EXT;\n\tif (nb_self==count) return ISOM_DREF_SELF;\n\treturn ISOM_DREF_MIXED;\n}\n\n// gf_list_add from src/utils/list.c:\nGF_Err gf_list_add(GF_List *ptr, void* item)\n{\n\tItemSlot *entry;\n\tif (! ptr) return GF_BAD_PARAM;\n\tentry = (ItemSlot *) gf_malloc(sizeof(ItemSlot));\n\tif (!entry) return GF_OUT_OF_MEM;\n\tentry->data = item;\n\tentry->next = NULL;\n\tif (! ptr->head) {\n\t\tptr->head = entry;\n\t\tptr->entryCount = 1;\n\t} else {\n\t\tptr->entryCount += 1;\n\t\tptr->tail->next = entry;\n\t}\n\tptr->tail = entry;\n\tptr->foundEntryNumber = ptr->entryCount - 1;\n\tptr->foundEntry = entry;\n\treturn GF_OK;\n}\n\n// gf_list_count from src/utils/list.c:\nu32 gf_list_count(const GF_List *ptr)\n{\n\tif (!ptr) return 0;\n\treturn ptr->entryCount;\n}\n\n// CleanWriters from src/isomedia/isom_store.c:\nvoid CleanWriters(GF_List *writers)\n{\n\twhile (gf_list_count(writers)) {\n\t\tTrackWriter *writer = (TrackWriter*)gf_list_get(writers, 0);\n\t\tgf_isom_box_del(writer->stco);\n\t\tgf_isom_box_del((GF_Box *)writer->stsc);\n\t\tgf_free(writer);\n\t\tgf_list_rem(writers, 0);\n\t}\n}\n"
  },
  {
    "repository": "tensorflow",
    "cve_id": "CVE-2021-29552",
    "cwe_list": [
      "CWE-703"
    ],
    "commit_hash": "704866eabe03a9aeda044ec91a8d0c83fc1ebdbe",
    "short_hash": "704866ea",
    "vulnerableMethods_before": [
      {
        "filename": "unsorted_segment_join_op.cc",
        "method_name": "vulnerable_function",
        "raw_code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const TensorShape& input_shape = input.shape();\n    const int32 input_dims = input_shape.dims();\n\n    const Tensor& segment_id = context->input(1);\n    const TensorShape& segment_id_shape = segment_id.shape();\n    const int32 segment_dims = segment_id_shape.dims();\n\n    const Tensor& num_segments_tensor = context->input(2);\n    auto num_segments = num_segments_tensor.scalar<NUM_SEGMENTS_TYPE>()();\n\n    OP_REQUIRES(context, segment_dims != 0,\n                errors::InvalidArgument(\"Segment_id cannot have rank 0\"));\n\n    OP_REQUIRES(\n        context, segment_dims <= input_dims,\n        errors::OutOfRange(\"Invalid segment_id rank \", segment_dims,\n                           \" for input with \", input_dims, \" dimension(s)\"));\n    for (auto i = 0; i < segment_dims; i++) {\n      OP_REQUIRES(\n          context, segment_id_shape.dim_size(i) == input_shape.dim_size(i),\n          errors::InvalidArgument(\n              \"Segment dimension is \", segment_id_shape.dim_size(i),\n              \" while input dimension is \", input_dims, \" in rank \", i));\n    }\n\n    // Making output tensor.\n    Tensor* output_tensor = nullptr;\n    TensorShape output_shape =\n        GetOutputShape(input_shape, segment_id_shape, num_segments);\n    OP_REQUIRES_OK(context, context->allocate_output(\"output\", output_shape,\n                                                     &output_tensor));\n\n    // Preparating flat tensors.\n    auto output_flat = output_tensor->flat<tstring>();\n    auto flat_segment_id = segment_id.flat<INDICES_TYPE>();\n    auto flat_input = input.flat<tstring>();\n\n    for (int i = 0; i < flat_segment_id.size(); i++) {\n      OP_REQUIRES(\n          context,\n          ((flat_segment_id(i) < num_segments) && (flat_segment_id(i) >= 0)),\n          errors::InvalidArgument(\n              \"segment_ids are not allowed to exceed num_segments or\"\n              \" to have negative values.\"));\n    }\n\n    int64 big_stride;\n    int64 small_stride;\n    std::tie(big_stride, small_stride) =\n        GetStrides<INDICES_TYPE>(input_shape, segment_id_shape);\n    auto relative_offset_set =\n        GetFlattenedRelativeOffsets<INDICES_TYPE>(small_stride, big_stride);\n    for (auto start_offset = 0; start_offset < big_stride; start_offset++) {\n      for (auto i = 0; i < relative_offset_set.size(); i++) {\n        auto output_index = start_offset + flat_segment_id(i) * big_stride;\n        auto offset = start_offset + relative_offset_set[i];\n        if (output_flat(output_index).length() != 0)\n          output_flat(output_index).append(separator_.c_str());\n        output_flat(output_index).append(flat_input(offset));\n      }\n    }\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "unsorted_segment_join_op.cc",
        "method_name": "fixed_function",
        "raw_code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const TensorShape& input_shape = input.shape();\n    const int32 input_dims = input_shape.dims();\n\n    const Tensor& segment_id = context->input(1);\n    const TensorShape& segment_id_shape = segment_id.shape();\n    const int32 segment_dims = segment_id_shape.dims();\n\n    const Tensor& num_segments_tensor = context->input(2);\n    OP_REQUIRES(context, num_segments_tensor.NumElements() != 0,\n                errors::InvalidArgument(\"Number of segments cannot be empty.\"));\n    auto num_segments = num_segments_tensor.scalar<NUM_SEGMENTS_TYPE>()();\n\n    OP_REQUIRES(context, segment_dims != 0,\n                errors::InvalidArgument(\"Segment_id cannot have rank 0\"));\n\n    OP_REQUIRES(\n        context, segment_dims <= input_dims,\n        errors::OutOfRange(\"Invalid segment_id rank \", segment_dims,\n                           \" for input with \", input_dims, \" dimension(s)\"));\n    for (auto i = 0; i < segment_dims; i++) {\n      OP_REQUIRES(\n          context, segment_id_shape.dim_size(i) == input_shape.dim_size(i),\n          errors::InvalidArgument(\n              \"Segment dimension is \", segment_id_shape.dim_size(i),\n              \" while input dimension is \", input_dims, \" in rank \", i));\n    }\n\n    // Making output tensor.\n    Tensor* output_tensor = nullptr;\n    TensorShape output_shape =\n        GetOutputShape(input_shape, segment_id_shape, num_segments);\n    OP_REQUIRES_OK(context, context->allocate_output(\"output\", output_shape,\n                                                     &output_tensor));\n\n    // Preparating flat tensors.\n    auto output_flat = output_tensor->flat<tstring>();\n    auto flat_segment_id = segment_id.flat<INDICES_TYPE>();\n    auto flat_input = input.flat<tstring>();\n\n    for (int i = 0; i < flat_segment_id.size(); i++) {\n      OP_REQUIRES(\n          context,\n          ((flat_segment_id(i) < num_segments) && (flat_segment_id(i) >= 0)),\n          errors::InvalidArgument(\n              \"segment_ids are not allowed to exceed num_segments or\"\n              \" to have negative values.\"));\n    }\n\n    int64 big_stride;\n    int64 small_stride;\n    std::tie(big_stride, small_stride) =\n        GetStrides<INDICES_TYPE>(input_shape, segment_id_shape);\n    auto relative_offset_set =\n        GetFlattenedRelativeOffsets<INDICES_TYPE>(small_stride, big_stride);\n    for (auto start_offset = 0; start_offset < big_stride; start_offset++) {\n      for (auto i = 0; i < relative_offset_set.size(); i++) {\n        auto output_index = start_offset + flat_segment_id(i) * big_stride;\n        auto offset = start_offset + relative_offset_set[i];\n        if (output_flat(output_index).length() != 0)\n          output_flat(output_index).append(separator_.c_str());\n        output_flat(output_index).append(flat_input(offset));\n      }\n    }\n  }",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"tensorflow/core/lib/core/errors.h\"\n#include <string>\n#include \"tensorflow/core/lib/gtl/inlined_vector.h\"\n#include \"tensorflow/core/lib/strings/str_util.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/lib/core/status.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/lib/core/stringpiece.h\"\n#include \"tensorflow/core/framework/kernel_def_builder.h\"\n#include <utility>\n\n// Type Definitions:\n// Tensor:\nclass Tensor {\n public:\n  /// \\brief Creates a 1-dimensional, 0-element float tensor.\n  ///\n  /// The returned Tensor is not a scalar (shape {}), but is instead\n  /// an empty one-dimensional Tensor (shape {0}, NumElements() ==\n  /// 0). Since it has no elements, it does not need to be assigned a\n  /// value and is initialized by default (IsInitialized() is\n  /// true). If this is undesirable, consider creating a one-element\n  /// scalar which does require initialization:\n  ///\n  /// ```c++\n  ///\n  ///     Tensor(DT_FLOAT, TensorShape({}))\n  ///\n  /// ```\n  Tensor();\n\n  /// \\brief Creates a Tensor of the given `type` and `shape`.  If\n  /// LogMemory::IsEnabled() the allocation is logged as coming from\n  /// an unknown kernel and step. Calling the Tensor constructor\n  /// directly from within an Op is deprecated: use the\n  /// OpKernelConstruction/OpKernelContext allocate_* methods to\n  /// allocate a new tensor, which record the kernel and step.\n  ///\n  /// The underlying buffer is ...\n\n// OpKernelContext:\ntensorflow.OpKernelContext.OpKernelContext:ANY(tensorflow.OpKernelContext.Params*)\n\n// int32:\ntypedef int int32;\n\n// Status:\nclass Status\n\n// Tensor:\ntensorflow.TensorHandle.Tensor:tensorflow.Status(tensorflow.Tensor**)<const>\n\n// TensorShape:\nclass TensorShape : public TensorShapeBase<TensorShape> {\n public:\n  using TensorShapeBase<TensorShape>::TensorShapeBase;\n\n  /// Allow a TensorShape to be used as a PartialTensorShape without copying\n  operator const PartialTensorShape&() const;  // NOLINT(runtime/explicit)\n\n  /// Returns true if `*this` and `b` have the same sizes. Ignores\n  /// dimension names.\n  bool IsSameSize(const TensorShape& b) const;\n  bool operator==(const TensorShape& b) const { return IsSameSize(b); }\n  bool operator!=(const TensorShape& b) const { return !IsSameSize(b); }\n\n  /// Fill `*dsizes` from `*this`.\n  /// Notice: Using IndexType=int32 in combination with To32Bit() can\n  /// significantly improve performance on GPU.\n  template <int NDIMS, typename IndexType = Eigen::DenseIndex>\n  Eigen::DSizes<IndexType, NDIMS> AsEigenDSizes() const;\n\n  // Same as `AsEigenDSizes()` but returns a `Status` instead.\n  // Use this method to surface error to user instead of crashing if `NDMIS` is\n  // not equal to `di...\n\n// UnsortedSegmentJoinOp:\nclass UnsortedSegmentJoinOp : public OpKernel {\n public:\n  using OpKernel::OpKernel;\n\n  explicit UnsortedSegmentJoinOp(OpKernelConstruction* ctx) : OpKernel(ctx) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"separator\", &separator_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const TensorShape& input_shape = input.shape();\n    const int32 input_dims = input_shape.dims();\n\n    const Tensor& segment_id = context->input(1);\n    const TensorShape& segment_id_shape = segment_id.shape();\n    const int32 segment_dims = segment_id_shape.dims();\n\n    const Tensor& num_segments_tensor = context->input(2);\n    OP_REQUIRES(context, num_segments_tensor.NumElements() != 0,\n                errors::InvalidArgument(\"Number of segments cannot be empty.\"));\n    auto num_segments = num_segments_tensor.scalar<NUM_SEGMENTS_TYPE>()();\n\n    OP_REQUIRES(context, segment_dims != 0,\n                errors::InvalidArgument(\"Segment_id cannot have rank 0...\n\n// OpKernelContext:\nclass OpKernelContext {\n public:\n  // The first element of a WrappedAllocator is a \"base\" Allocator and\n  // the second element is that Allocator wrapped by a\n  // TrackingAllocator\n  typedef std::pair<Allocator*, TrackingAllocator*> WrappedAllocator;\n\n  // TODO(zhifengc): Do some cleanup of Params.\n  // The Params struct is passed in to initialize an OpKernelContext,\n  // and must outlive the OpKernelContext.\n  struct Params {\n    ~Params() { delete eigen_gpu_device; }\n\n    // The step being executed.\n    int64 step_id = 0;\n\n    // The op kernel being computed.\n    OpKernel* op_kernel = nullptr;\n\n    // The device on which the kernel is running.\n    DeviceBase* device = nullptr;\n\n    // The Eigen GPU device wrapper, which may include a per-op\n    // wrapped allocator. The concrete type of this object depends on\n    // the type of this->device, so eigen_gpu_device can't be an\n    // inline member and must be heap allocated. However, we don't\n    // want to allocate a new eigen_gpu_d...\n\n// int64:\ntypedef std::int64_t int64;\n\n// Status:\nclass Status {\n public:\n  /// Create a success status.\n  Status() {}\n\n  /// \\brief Create a status with the specified error code and msg as a\n  /// human-readable string containing more detailed information.\n  Status(tensorflow::error::Code code, tensorflow::StringPiece msg)\n      : Status(code, msg, {}) {}\n\n  /// \\brief Create a status with the specified error code, msg, and stack trace\n  /// as a human-readable string containing more detailed information.\n#ifndef SWIG\n  Status(tensorflow::error::Code code, tensorflow::StringPiece msg,\n         std::vector<StackFrame>&& stack_trace);\n#endif\n\n  /// Copy the specified status.\n  Status(const Status& s);\n  Status& operator=(const Status& s);\n#ifndef SWIG\n  Status(Status&& s) noexcept;\n  Status& operator=(Status&& s) noexcept;\n#endif  // SWIG\n\n  static Status OK() { return Status(); }\n\n  /// Returns true iff the status indicates success.\n  bool ok() const { return (state_ == nullptr); }\n\n  tensorflow::error::Code code() const {\n    retu...\n\n// Called Methods (top 10):\n// OK from tensorflow/core/platform/status.h:\n  static Status OK() { return Status(); } /* <=== tensorflow.Status.OK:tensorflow.Status() */ \n\n// OP_REQUIRES_OK from tensorflow/core/kernels/tensorflow/core/framework/tensorflow/core/framework/op_requires.h:\n\n\n// Update from tensorflow/core/platform/status.h:\n  void Update(const Status& new_status); /* <=== tensorflow.Status.Update:void(tensorflow.Status&) */ \n\n// ok from tensorflow/core/platform/status.h:\n  bool ok() const { return (state_ == nullptr); } /* <=== tensorflow.Status.ok:bool()<const> */ \n\n// CHECK from tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/platform/tensorflow/core/platform/logging.h:\n\n\n// CHECK_GE from tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/platform/tensorflow/core/platform/logging.h:\n\n\n// CHECK_EQ from tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/platform/tensorflow/core/platform/logging.h:\n\n\n// CtxFailure from tensorflow/core/framework/op_kernel.cc:\nvoid OpKernelContext::CtxFailure(const char* file, int line, const Status& s) { /* <=== tensorflow.OpKernelContext.CtxFailure:void(char*,int,tensorflow.Status&) */ \n  VLOG(1) << \"OP_REQUIRES failed at \" << io::Basename(file) << \":\" << line\n          << \" : \" << s;\n  SetStatus(s);\n}\n\n// name from tensorflow/core/framework/op_kernel.h:\n  const std::string& name() const { return props_->node_def.name(); } /* <=== tensorflow.OpKernel.name:ANY()<const> */ \n\n// OP_REQUIRES from tensorflow/core/kernels/tensorflow/core/framework/tensorflow/core/framework/op_requires.h:\n\n"
  },
  {
    "repository": "openssl",
    "cve_id": "CVE-2021-3712",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "94d23fcff9b2a7a8368dfe52214d5c2569882c11",
    "short_hash": "94d23fcf",
    "vulnerableMethods_before": [
      {
        "filename": "None",
        "method_name": "vulnerable_function",
        "raw_code": "EC_GROUP *EC_GROUP_new_from_ecparameters(const ECPARAMETERS *params)\n{\n    int ok = 0, tmp;\n    EC_GROUP *ret = NULL, *dup = NULL;\n    BIGNUM *p = NULL, *a = NULL, *b = NULL;\n    EC_POINT *point = NULL;\n    long field_bits;\n    int curve_name = NID_undef;\n    BN_CTX *ctx = NULL;\n\n    if (!params->fieldID || !params->fieldID->fieldType ||\n        !params->fieldID->p.ptr) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n        goto err;\n    }\n\n    /*\n     * Now extract the curve parameters a and b. Note that, although SEC 1\n     * specifies the length of their encodings, historical versions of OpenSSL\n     * encoded them incorrectly, so we must accept any length for backwards\n     * compatibility.\n     */\n    if (!params->curve || !params->curve->a ||\n        !params->curve->a->data || !params->curve->b ||\n        !params->curve->b->data) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n        goto err;\n    }\n    a = BN_bin2bn(params->curve->a->data, params->curve->a->length, NULL);\n    if (a == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_BN_LIB);\n        goto err;\n    }\n    b = BN_bin2bn(params->curve->b->data, params->curve->b->length, NULL);\n    if (b == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_BN_LIB);\n        goto err;\n    }\n\n    /* get the field parameters */\n    tmp = OBJ_obj2nid(params->fieldID->fieldType);\n    if (tmp == NID_X9_62_characteristic_two_field)\n#ifdef OPENSSL_NO_EC2M\n    {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_GF2M_NOT_SUPPORTED);\n        goto err;\n    }\n#else\n    {\n        X9_62_CHARACTERISTIC_TWO *char_two;\n\n        char_two = params->fieldID->p.char_two;\n\n        field_bits = char_two->m;\n        if (field_bits > OPENSSL_ECC_MAX_FIELD_BITS) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_FIELD_TOO_LARGE);\n            goto err;\n        }\n\n        if ((p = BN_new()) == NULL) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n\n        /* get the base type */\n        tmp = OBJ_obj2nid(char_two->type);\n\n        if (tmp == NID_X9_62_tpBasis) {\n            long tmp_long;\n\n            if (!char_two->p.tpBasis) {\n                ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n                goto err;\n            }\n\n            tmp_long = ASN1_INTEGER_get(char_two->p.tpBasis);\n\n            if (!(char_two->m > tmp_long && tmp_long > 0)) {\n                ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS,\n                      EC_R_INVALID_TRINOMIAL_BASIS);\n                goto err;\n            }\n\n            /* create the polynomial */\n            if (!BN_set_bit(p, (int)char_two->m))\n                goto err;\n            if (!BN_set_bit(p, (int)tmp_long))\n                goto err;\n            if (!BN_set_bit(p, 0))\n                goto err;\n        } else if (tmp == NID_X9_62_ppBasis) {\n            X9_62_PENTANOMIAL *penta;\n\n            penta = char_two->p.ppBasis;\n            if (!penta) {\n                ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n                goto err;\n            }\n\n            if (!\n                (char_two->m > penta->k3 && penta->k3 > penta->k2\n                 && penta->k2 > penta->k1 && penta->k1 > 0)) {\n                ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS,\n                      EC_R_INVALID_PENTANOMIAL_BASIS);\n                goto err;\n            }\n\n            /* create the polynomial */\n            if (!BN_set_bit(p, (int)char_two->m))\n                goto err;\n            if (!BN_set_bit(p, (int)penta->k1))\n                goto err;\n            if (!BN_set_bit(p, (int)penta->k2))\n                goto err;\n            if (!BN_set_bit(p, (int)penta->k3))\n                goto err;\n            if (!BN_set_bit(p, 0))\n                goto err;\n        } else if (tmp == NID_X9_62_onBasis) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_NOT_IMPLEMENTED);\n            goto err;\n        } else {                /* error */\n\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n            goto err;\n        }\n\n        /* create the EC_GROUP structure */\n        ret = EC_GROUP_new_curve_GF2m(p, a, b, NULL);\n    }\n#endif\n    else if (tmp == NID_X9_62_prime_field) {\n        /* we have a curve over a prime field */\n        /* extract the prime number */\n        if (!params->fieldID->p.prime) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n            goto err;\n        }\n        p = ASN1_INTEGER_to_BN(params->fieldID->p.prime, NULL);\n        if (p == NULL) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_ASN1_LIB);\n            goto err;\n        }\n\n        if (BN_is_negative(p) || BN_is_zero(p)) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_FIELD);\n            goto err;\n        }\n\n        field_bits = BN_num_bits(p);\n        if (field_bits > OPENSSL_ECC_MAX_FIELD_BITS) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_FIELD_TOO_LARGE);\n            goto err;\n        }\n\n        /* create the EC_GROUP structure */\n        ret = EC_GROUP_new_curve_GFp(p, a, b, NULL);\n    } else {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_FIELD);\n        goto err;\n    }\n\n    if (ret == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);\n        goto err;\n    }\n\n    /* extract seed (optional) */\n    if (params->curve->seed != NULL) {\n        OPENSSL_free(ret->seed);\n        if ((ret->seed = OPENSSL_malloc(params->curve->seed->length)) == NULL) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        memcpy(ret->seed, params->curve->seed->data,\n               params->curve->seed->length);\n        ret->seed_len = params->curve->seed->length;\n    }\n\n    if (!params->order || !params->base || !params->base->data) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n        goto err;\n    }\n\n    if ((point = EC_POINT_new(ret)) == NULL)\n        goto err;\n\n    /* set the point conversion form */\n    EC_GROUP_set_point_conversion_form(ret, (point_conversion_form_t)\n                                       (params->base->data[0] & ~0x01));\n\n    /* extract the ec point */\n    if (!EC_POINT_oct2point(ret, point, params->base->data,\n                            params->base->length, NULL)) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);\n        goto err;\n    }\n\n    /* extract the order */\n    if ((a = ASN1_INTEGER_to_BN(params->order, a)) == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_ASN1_LIB);\n        goto err;\n    }\n    if (BN_is_negative(a) || BN_is_zero(a)) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_GROUP_ORDER);\n        goto err;\n    }\n    if (BN_num_bits(a) > (int)field_bits + 1) { /* Hasse bound */\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_GROUP_ORDER);\n        goto err;\n    }\n\n    /* extract the cofactor (optional) */\n    if (params->cofactor == NULL) {\n        BN_free(b);\n        b = NULL;\n    } else if ((b = ASN1_INTEGER_to_BN(params->cofactor, b)) == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_ASN1_LIB);\n        goto err;\n    }\n    /* set the generator, order and cofactor (if present) */\n    if (!EC_GROUP_set_generator(ret, point, a, b)) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);\n        goto err;\n    }\n\n    /*\n     * Check if the explicit parameters group just created matches one of the\n     * built-in curves.\n     *\n     * We create a copy of the group just built, so that we can remove optional\n     * fields for the lookup: we do this to avoid the possibility that one of\n     * the optional parameters is used to force the library into using a less\n     * performant and less secure EC_METHOD instead of the specialized one.\n     * In any case, `seed` is not really used in any computation, while a\n     * cofactor different from the one in the built-in table is just\n     * mathematically wrong anyway and should not be used.\n     */\n    if ((ctx = BN_CTX_new()) == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_BN_LIB);\n        goto err;\n    }\n    if ((dup = EC_GROUP_dup(ret)) == NULL\n            || EC_GROUP_set_seed(dup, NULL, 0) != 1\n            || !EC_GROUP_set_generator(dup, point, a, NULL)) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);\n        goto err;\n    }\n    if ((curve_name = ec_curve_nid_from_params(dup, ctx)) != NID_undef) {\n        /*\n         * The input explicit parameters successfully matched one of the\n         * built-in curves: often for built-in curves we have specialized\n         * methods with better performance and hardening.\n         *\n         * In this case we replace the `EC_GROUP` created through explicit\n         * parameters with one created from a named group.\n         */\n        EC_GROUP *named_group = NULL;\n\n#ifndef OPENSSL_NO_EC_NISTP_64_GCC_128\n        /*\n         * NID_wap_wsg_idm_ecid_wtls12 and NID_secp224r1 are both aliases for\n         * the same curve, we prefer the SECP nid when matching explicit\n         * parameters as that is associated with a specialized EC_METHOD.\n         */\n        if (curve_name == NID_wap_wsg_idm_ecid_wtls12)\n            curve_name = NID_secp224r1;\n#endif /* !def(OPENSSL_NO_EC_NISTP_64_GCC_128) */\n\n        if ((named_group = EC_GROUP_new_by_curve_name(curve_name)) == NULL) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);\n            goto err;\n        }\n        EC_GROUP_free(ret);\n        ret = named_group;\n\n        /*\n         * Set the flag so that EC_GROUPs created from explicit parameters are\n         * serialized using explicit parameters by default.\n         */\n        EC_GROUP_set_asn1_flag(ret, OPENSSL_EC_EXPLICIT_CURVE);\n\n        /*\n         * If the input params do not contain the optional seed field we make\n         * sure it is not added to the returned group.\n         *\n         * The seed field is not really used inside libcrypto anyway, and\n         * adding it to parsed explicit parameter keys would alter their DER\n         * encoding output (because of the extra field) which could impact\n         * applications fingerprinting keys by their DER encoding.\n         */\n        if (params->curve->seed == NULL) {\n            if (EC_GROUP_set_seed(ret, NULL, 0) != 1)\n                goto err;\n        }\n    }\n\n    ok = 1;\n\n err:\n    if (!ok) {\n        EC_GROUP_free(ret);\n        ret = NULL;\n    }\n    EC_GROUP_free(dup);\n\n    BN_free(p);\n    BN_free(a);\n    BN_free(b);\n    EC_POINT_free(point);\n\n    BN_CTX_free(ctx);\n\n    return ret;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "None",
        "method_name": "fixed_function",
        "raw_code": "EC_GROUP *EC_GROUP_new_from_ecparameters(const ECPARAMETERS *params)\n{\n    int ok = 0, tmp;\n    EC_GROUP *ret = NULL, *dup = NULL;\n    BIGNUM *p = NULL, *a = NULL, *b = NULL;\n    EC_POINT *point = NULL;\n    long field_bits;\n    int curve_name = NID_undef;\n    BN_CTX *ctx = NULL;\n\n    if (!params->fieldID || !params->fieldID->fieldType ||\n        !params->fieldID->p.ptr) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n        goto err;\n    }\n\n    /*\n     * Now extract the curve parameters a and b. Note that, although SEC 1\n     * specifies the length of their encodings, historical versions of OpenSSL\n     * encoded them incorrectly, so we must accept any length for backwards\n     * compatibility.\n     */\n    if (!params->curve || !params->curve->a ||\n        !params->curve->a->data || !params->curve->b ||\n        !params->curve->b->data) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n        goto err;\n    }\n    a = BN_bin2bn(params->curve->a->data, params->curve->a->length, NULL);\n    if (a == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_BN_LIB);\n        goto err;\n    }\n    b = BN_bin2bn(params->curve->b->data, params->curve->b->length, NULL);\n    if (b == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_BN_LIB);\n        goto err;\n    }\n\n    /* get the field parameters */\n    tmp = OBJ_obj2nid(params->fieldID->fieldType);\n    if (tmp == NID_X9_62_characteristic_two_field)\n#ifdef OPENSSL_NO_EC2M\n    {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_GF2M_NOT_SUPPORTED);\n        goto err;\n    }\n#else\n    {\n        X9_62_CHARACTERISTIC_TWO *char_two;\n\n        char_two = params->fieldID->p.char_two;\n\n        field_bits = char_two->m;\n        if (field_bits > OPENSSL_ECC_MAX_FIELD_BITS) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_FIELD_TOO_LARGE);\n            goto err;\n        }\n\n        if ((p = BN_new()) == NULL) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n\n        /* get the base type */\n        tmp = OBJ_obj2nid(char_two->type);\n\n        if (tmp == NID_X9_62_tpBasis) {\n            long tmp_long;\n\n            if (!char_two->p.tpBasis) {\n                ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n                goto err;\n            }\n\n            tmp_long = ASN1_INTEGER_get(char_two->p.tpBasis);\n\n            if (!(char_two->m > tmp_long && tmp_long > 0)) {\n                ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS,\n                      EC_R_INVALID_TRINOMIAL_BASIS);\n                goto err;\n            }\n\n            /* create the polynomial */\n            if (!BN_set_bit(p, (int)char_two->m))\n                goto err;\n            if (!BN_set_bit(p, (int)tmp_long))\n                goto err;\n            if (!BN_set_bit(p, 0))\n                goto err;\n        } else if (tmp == NID_X9_62_ppBasis) {\n            X9_62_PENTANOMIAL *penta;\n\n            penta = char_two->p.ppBasis;\n            if (!penta) {\n                ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n                goto err;\n            }\n\n            if (!\n                (char_two->m > penta->k3 && penta->k3 > penta->k2\n                 && penta->k2 > penta->k1 && penta->k1 > 0)) {\n                ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS,\n                      EC_R_INVALID_PENTANOMIAL_BASIS);\n                goto err;\n            }\n\n            /* create the polynomial */\n            if (!BN_set_bit(p, (int)char_two->m))\n                goto err;\n            if (!BN_set_bit(p, (int)penta->k1))\n                goto err;\n            if (!BN_set_bit(p, (int)penta->k2))\n                goto err;\n            if (!BN_set_bit(p, (int)penta->k3))\n                goto err;\n            if (!BN_set_bit(p, 0))\n                goto err;\n        } else if (tmp == NID_X9_62_onBasis) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_NOT_IMPLEMENTED);\n            goto err;\n        } else {                /* error */\n\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n            goto err;\n        }\n\n        /* create the EC_GROUP structure */\n        ret = EC_GROUP_new_curve_GF2m(p, a, b, NULL);\n    }\n#endif\n    else if (tmp == NID_X9_62_prime_field) {\n        /* we have a curve over a prime field */\n        /* extract the prime number */\n        if (!params->fieldID->p.prime) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n            goto err;\n        }\n        p = ASN1_INTEGER_to_BN(params->fieldID->p.prime, NULL);\n        if (p == NULL) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_ASN1_LIB);\n            goto err;\n        }\n\n        if (BN_is_negative(p) || BN_is_zero(p)) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_FIELD);\n            goto err;\n        }\n\n        field_bits = BN_num_bits(p);\n        if (field_bits > OPENSSL_ECC_MAX_FIELD_BITS) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_FIELD_TOO_LARGE);\n            goto err;\n        }\n\n        /* create the EC_GROUP structure */\n        ret = EC_GROUP_new_curve_GFp(p, a, b, NULL);\n    } else {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_FIELD);\n        goto err;\n    }\n\n    if (ret == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);\n        goto err;\n    }\n\n    /* extract seed (optional) */\n    if (params->curve->seed != NULL) {\n        OPENSSL_free(ret->seed);\n        if ((ret->seed = OPENSSL_malloc(params->curve->seed->length)) == NULL) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        memcpy(ret->seed, params->curve->seed->data,\n               params->curve->seed->length);\n        ret->seed_len = params->curve->seed->length;\n    }\n\n    if (params->order == NULL\n            || params->base == NULL\n            || params->base->data == NULL\n            || params->base->length == 0) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);\n        goto err;\n    }\n\n    if ((point = EC_POINT_new(ret)) == NULL)\n        goto err;\n\n    /* set the point conversion form */\n    EC_GROUP_set_point_conversion_form(ret, (point_conversion_form_t)\n                                       (params->base->data[0] & ~0x01));\n\n    /* extract the ec point */\n    if (!EC_POINT_oct2point(ret, point, params->base->data,\n                            params->base->length, NULL)) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);\n        goto err;\n    }\n\n    /* extract the order */\n    if ((a = ASN1_INTEGER_to_BN(params->order, a)) == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_ASN1_LIB);\n        goto err;\n    }\n    if (BN_is_negative(a) || BN_is_zero(a)) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_GROUP_ORDER);\n        goto err;\n    }\n    if (BN_num_bits(a) > (int)field_bits + 1) { /* Hasse bound */\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_GROUP_ORDER);\n        goto err;\n    }\n\n    /* extract the cofactor (optional) */\n    if (params->cofactor == NULL) {\n        BN_free(b);\n        b = NULL;\n    } else if ((b = ASN1_INTEGER_to_BN(params->cofactor, b)) == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_ASN1_LIB);\n        goto err;\n    }\n    /* set the generator, order and cofactor (if present) */\n    if (!EC_GROUP_set_generator(ret, point, a, b)) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);\n        goto err;\n    }\n\n    /*\n     * Check if the explicit parameters group just created matches one of the\n     * built-in curves.\n     *\n     * We create a copy of the group just built, so that we can remove optional\n     * fields for the lookup: we do this to avoid the possibility that one of\n     * the optional parameters is used to force the library into using a less\n     * performant and less secure EC_METHOD instead of the specialized one.\n     * In any case, `seed` is not really used in any computation, while a\n     * cofactor different from the one in the built-in table is just\n     * mathematically wrong anyway and should not be used.\n     */\n    if ((ctx = BN_CTX_new()) == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_BN_LIB);\n        goto err;\n    }\n    if ((dup = EC_GROUP_dup(ret)) == NULL\n            || EC_GROUP_set_seed(dup, NULL, 0) != 1\n            || !EC_GROUP_set_generator(dup, point, a, NULL)) {\n        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);\n        goto err;\n    }\n    if ((curve_name = ec_curve_nid_from_params(dup, ctx)) != NID_undef) {\n        /*\n         * The input explicit parameters successfully matched one of the\n         * built-in curves: often for built-in curves we have specialized\n         * methods with better performance and hardening.\n         *\n         * In this case we replace the `EC_GROUP` created through explicit\n         * parameters with one created from a named group.\n         */\n        EC_GROUP *named_group = NULL;\n\n#ifndef OPENSSL_NO_EC_NISTP_64_GCC_128\n        /*\n         * NID_wap_wsg_idm_ecid_wtls12 and NID_secp224r1 are both aliases for\n         * the same curve, we prefer the SECP nid when matching explicit\n         * parameters as that is associated with a specialized EC_METHOD.\n         */\n        if (curve_name == NID_wap_wsg_idm_ecid_wtls12)\n            curve_name = NID_secp224r1;\n#endif /* !def(OPENSSL_NO_EC_NISTP_64_GCC_128) */\n\n        if ((named_group = EC_GROUP_new_by_curve_name(curve_name)) == NULL) {\n            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);\n            goto err;\n        }\n        EC_GROUP_free(ret);\n        ret = named_group;\n\n        /*\n         * Set the flag so that EC_GROUPs created from explicit parameters are\n         * serialized using explicit parameters by default.\n         */\n        EC_GROUP_set_asn1_flag(ret, OPENSSL_EC_EXPLICIT_CURVE);\n\n        /*\n         * If the input params do not contain the optional seed field we make\n         * sure it is not added to the returned group.\n         *\n         * The seed field is not really used inside libcrypto anyway, and\n         * adding it to parsed explicit parameter keys would alter their DER\n         * encoding output (because of the extra field) which could impact\n         * applications fingerprinting keys by their DER encoding.\n         */\n        if (params->curve->seed == NULL) {\n            if (EC_GROUP_set_seed(ret, NULL, 0) != 1)\n                goto err;\n        }\n    }\n\n    ok = 1;\n\n err:\n    if (!ok) {\n        EC_GROUP_free(ret);\n        ret = NULL;\n    }\n    EC_GROUP_free(dup);\n\n    BN_free(p);\n    BN_free(a);\n    BN_free(b);\n    EC_POINT_free(point);\n\n    BN_CTX_free(ctx);\n\n    return ret;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <openssl/err.h>\n#include <openssl/objects.h>\n#include \"ec_local.h\"\n#include <string.h>\n#include <openssl/asn1t.h>\n#include \"internal/nelem.h\"\n\n// Type Definitions:\n// EC_GROUP:\ntypedef struct ec_group_st EC_GROUP;\n\n// EC_POINT:\ntypedef struct ec_point_st EC_POINT;\n\n// X9_62_CHARACTERISTIC_TWO:\ntypedef struct x9_62_characteristic_two_st {\n    int32_t m;\n    ASN1_OBJECT *type;\n    union {\n        char *ptr;\n        /* NID_X9_62_onBasis */\n        ASN1_NULL *onBasis;\n        /* NID_X9_62_tpBasis */\n        ASN1_INTEGER *tpBasis;\n        /* NID_X9_62_ppBasis */\n        X9_62_PENTANOMIAL *ppBasis;\n        /* anything else */\n        ASN1_TYPE *other;\n    } p;\n} X9_62_CHARACTERISTIC_TWO;\n\n// X9_62_PENTANOMIAL:\ntypedef struct x9_62_pentanomial_st {\n    int32_t k1;\n    int32_t k2;\n    int32_t k3;\n} X9_62_PENTANOMIAL;\n\n// BN_CTX:\ntypedef struct bignum_ctx BN_CTX;\n\n// BIGNUM:\ntypedef struct bignum_st BIGNUM;\n\n// ECPARAMETERS:\ntypedef struct ec_parameters_st ECPARAMETERS;\n\n// Called Methods (top 10):\n// asn1_string_to_bn from crypto/asn1/a_int.c:\nstatic BIGNUM *asn1_string_to_bn(const ASN1_INTEGER *ai, BIGNUM *bn, /* <=== asn1_string_to_bn */ \n                                 int itype)\n{\n    BIGNUM *ret;\n\n    if ((ai->type & ~V_ASN1_NEG) != itype) {\n        ASN1err(ASN1_F_ASN1_STRING_TO_BN, ASN1_R_WRONG_INTEGER_TYPE);\n        return NULL;\n    }\n\n    ret = BN_bin2bn(ai->data, ai->length, bn);\n    if (ret == NULL) {\n        ASN1err(ASN1_F_ASN1_STRING_TO_BN, ASN1_R_BN_LIB);\n        return NULL;\n    }\n    if (ai->type & V_ASN1_NEG)\n        BN_set_negative(ret, 1);\n    return ret;\n}\n\n// BN_set_negative from crypto/bn/bn_lib.c:\nvoid BN_set_negative(BIGNUM *a, int b) /* <=== BN_set_negative */ \n{\n    if (b && !BN_is_zero(a))\n        a->neg = 1;\n    else\n        a->neg = 0;\n}\n\n// EC_GROUP_get0_generator from crypto/ec/ec_lib.c:\nconst EC_POINT *EC_GROUP_get0_generator(const EC_GROUP *group) /* <=== EC_GROUP_get0_generator */ \n{\n    return group->generator;\n}\n\n// EC_GROUP_set_seed from crypto/ec/ec_lib.c:\nsize_t EC_GROUP_set_seed(EC_GROUP *group, const unsigned char *p, size_t len)\n{\n    OPENSSL_free(group->seed);\n    group->seed = NULL;\n    group->seed_len = 0;\n\n    if (!len || !p)\n        return 1;\n\n    if ((group->seed = OPENSSL_malloc(len)) == NULL) {\n        ECerr(EC_F_EC_GROUP_SET_SEED, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n    memcpy(group->seed, p, len);\n    group->seed_len = len;\n\n    return len;\n}\n\n// BN_POOL_init from crypto/bn/bn_ctx.c:\nstatic void BN_POOL_init(BN_POOL *p) /* <=== BN_POOL_init */ \n{\n    p->head = p->current = p->tail = NULL;\n    p->used = p->size = 0;\n}\n\n// BN_nist_mod_func from crypto/bn/bn_nist.c:\nint (*BN_nist_mod_func(const BIGNUM *p)) (BIGNUM *r, const BIGNUM *a, /* <=== BN_nist_mod_func */ \n                                          const BIGNUM *field, BN_CTX *ctx) {\n    if (BN_ucmp(&_bignum_nist_p_192, p) == 0)\n        return BN_nist_mod_192;\n    if (BN_ucmp(&_bignum_nist_p_224, p) == 0)\n        return BN_nist_mod_224;\n    if (BN_ucmp(&_bignum_nist_p_256, p) == 0)\n        return BN_nist_mod_256;\n    if (BN_ucmp(&_bignum_nist_p_384, p) == 0)\n        return BN_nist_mod_384;\n    if (BN_ucmp(&_bignum_nist_p_521, p) == 0)\n        return BN_nist_mod_521;\n    return 0;\n}\n\n// BN_is_zero from crypto/bn/bn_lib.c:\nint BN_is_zero(const BIGNUM *a)\n{\n    return a->top == 0;\n}\n\n// BN_new from crypto/bn/bn_lib.c:\nBIGNUM *BN_new(void)\n{\n    BIGNUM *ret;\n\n    if ((ret = OPENSSL_zalloc(sizeof(*ret))) == NULL) {\n        BNerr(BN_F_BN_NEW, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n    ret->flags = BN_FLG_MALLOCED;\n    bn_check_top(ret);\n    return ret;\n}\n\n// EC_GROUP_dup from crypto/ec/ec_lib.c:\nEC_GROUP *EC_GROUP_dup(const EC_GROUP *a)\n{\n    EC_GROUP *t = NULL;\n    int ok = 0;\n\n    if (a == NULL)\n        return NULL;\n\n    if ((t = EC_GROUP_new(a->meth)) == NULL)\n        return NULL;\n    if (!EC_GROUP_copy(t, a))\n        goto err;\n\n    ok = 1;\n\n err:\n    if (!ok) {\n        EC_GROUP_free(t);\n        return NULL;\n    }\n        return t;\n}\n\n// EC_POINT_new from crypto/ec/ec_lib.c:\nEC_POINT *EC_POINT_new(const EC_GROUP *group)\n{\n    EC_POINT *ret;\n\n    if (group == NULL) {\n        ECerr(EC_F_EC_POINT_NEW, ERR_R_PASSED_NULL_PARAMETER);\n        return NULL;\n    }\n    if (group->meth->point_init == NULL) {\n        ECerr(EC_F_EC_POINT_NEW, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return NULL;\n    }\n\n    ret = OPENSSL_zalloc(sizeof(*ret));\n    if (ret == NULL) {\n        ECerr(EC_F_EC_POINT_NEW, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n\n    ret->meth = group->meth;\n    ret->curve_name = group->curve_name;\n\n    if (!ret->meth->point_init(ret)) {\n        OPENSSL_free(ret);\n        return NULL;\n    }\n\n    return ret;\n}\n"
  },
  {
    "repository": "chafa",
    "cve_id": "CVE-2022-1507",
    "cwe_list": [
      "CWE-476"
    ],
    "commit_hash": "e4b777c7b7c144cd16a0ea96108267b1004fe6c9",
    "short_hash": "e4b777c7",
    "vulnerableMethods_before": [
      {
        "filename": "libnsgif.c",
        "method_name": "vulnerable_function",
        "raw_code": "gif_internal_decode_frame(gif_animation *gif,\n                          unsigned int frame,\n                          bool clear_image)\n{\n        unsigned int index = 0;\n        const unsigned char *gif_data, *gif_end;\n        ssize_t gif_bytes;\n        unsigned int width, height, offset_x, offset_y;\n        unsigned int flags, colour_table_size, interlace;\n        unsigned int *colour_table;\n        unsigned int *frame_data = 0;\t// Set to 0 for no warnings\n        unsigned int *frame_scanline;\n        ssize_t save_buffer_position;\n        unsigned int return_value = 0;\n        unsigned int x, y, decode_y, burst_bytes;\n        register unsigned char colour;\n\n        /* Ensure this frame is supposed to be decoded */\n        if (gif->frames[frame].display == false) {\n                return GIF_OK;\n        }\n\n        /* Ensure the frame is in range to decode */\n        if (frame > gif->frame_count_partial) {\n                return GIF_INSUFFICIENT_DATA;\n        }\n\n        /* done if frame is already decoded */\n        if ((!clear_image) &&\n            ((int)frame == gif->decoded_frame)) {\n                return GIF_OK;\n        }\n\n        /* Get the start of our frame data and the end of the GIF data */\n        gif_data = gif->gif_data + gif->frames[frame].frame_pointer;\n        gif_end = gif->gif_data + gif->buffer_size;\n        gif_bytes = (gif_end - gif_data);\n\n        /*\n         * Ensure there is a minimal amount of data to proceed.  The shortest\n         * block of data is a 10-byte image descriptor + 1-byte gif trailer\n         */\n        if (gif_bytes < 12) {\n                return GIF_INSUFFICIENT_FRAME_DATA;\n        }\n\n        /* Save the buffer position */\n        save_buffer_position = gif->buffer_position;\n        gif->buffer_position = gif_data - gif->gif_data;\n\n        /* Skip any extensions because they have allready been processed */\n        if ((return_value = gif_skip_frame_extensions(gif)) != GIF_OK) {\n                goto gif_decode_frame_exit;\n        }\n        gif_data = (gif->gif_data + gif->buffer_position);\n        gif_bytes = (gif_end - gif_data);\n\n        /* Ensure we have enough data for the 10-byte image descriptor + 1-byte\n         * gif trailer\n         */\n        if (gif_bytes < 12) {\n                return_value = GIF_INSUFFICIENT_FRAME_DATA;\n                goto gif_decode_frame_exit;\n        }\n\n        /* 10-byte Image Descriptor is:\n         *\n         *\t+0\tCHAR\tImage Separator (0x2c)\n         *\t+1\tSHORT\tImage Left Position\n         *\t+3\tSHORT\tImage Top Position\n         *\t+5\tSHORT\tWidth\n         *\t+7\tSHORT\tHeight\n         *\t+9\tCHAR\t__Packed Fields__\n         *\t\t\t1BIT\tLocal Colour Table Flag\n         *\t\t\t1BIT\tInterlace Flag\n         *\t\t\t1BIT\tSort Flag\n         *\t\t\t2BITS\tReserved\n         *\t\t\t3BITS\tSize of Local Colour Table\n         */\n        if (gif_data[0] != GIF_IMAGE_SEPARATOR) {\n                return_value = GIF_DATA_ERROR;\n                goto gif_decode_frame_exit;\n        }\n        offset_x = gif_data[1] | (gif_data[2] << 8);\n        offset_y = gif_data[3] | (gif_data[4] << 8);\n        width = gif_data[5] | (gif_data[6] << 8);\n        height = gif_data[7] | (gif_data[8] << 8);\n\n        /* Boundary checking - shouldn't ever happen except unless the data has\n         * been modified since initialisation.\n         */\n        if ((offset_x + width > gif->width) ||\n            (offset_y + height > gif->height)) {\n                return_value = GIF_DATA_ERROR;\n                goto gif_decode_frame_exit;\n        }\n\n        /* Decode the flags */\n        flags = gif_data[9];\n        colour_table_size = 2 << (flags & GIF_COLOUR_TABLE_SIZE_MASK);\n        interlace = flags & GIF_INTERLACE_MASK;\n\n        /* Advance data pointer to next block either colour table or image\n         * data.\n         */\n        gif_data += 10;\n        gif_bytes = (gif_end - gif_data);\n\n        /* Set up the colour table */\n        if (flags & GIF_COLOUR_TABLE_MASK) {\n                if (gif_bytes < (int)(3 * colour_table_size)) {\n                        return_value = GIF_INSUFFICIENT_FRAME_DATA;\n                        goto gif_decode_frame_exit;\n                }\n                colour_table = gif->local_colour_table;\n                if (!clear_image) {\n                        for (index = 0; index < colour_table_size; index++) {\n                                /* Gif colour map contents are r,g,b.\n                                 *\n                                 * We want to pack them bytewise into the\n                                 * colour table, such that the red component\n                                 * is in byte 0 and the alpha component is in\n                                 * byte 3.\n                                 */\n                                unsigned char *entry =\n                                        (unsigned char *) &colour_table[index];\n\n                                entry[0] = gif_data[0];\t/* r */\n                                entry[1] = gif_data[1];\t/* g */\n                                entry[2] = gif_data[2];\t/* b */\n                                entry[3] = 0xff;\t/* a */\n\n                                gif_data += 3;\n                        }\n                } else {\n                        gif_data += 3 * colour_table_size;\n                }\n                gif_bytes = (gif_end - gif_data);\n        } else {\n                colour_table = gif->global_colour_table;\n        }\n\n        /* Ensure sufficient data remains */\n        if (gif_bytes < 1) {\n                return_value = GIF_INSUFFICIENT_FRAME_DATA;\n                goto gif_decode_frame_exit;\n        }\n\n        /* check for an end marker */\n        if (gif_data[0] == GIF_TRAILER) {\n                return_value = GIF_OK;\n                goto gif_decode_frame_exit;\n        }\n\n        /* Get the frame data */\n        assert(gif->bitmap_callbacks.bitmap_get_buffer);\n        frame_data = (void *)gif->bitmap_callbacks.bitmap_get_buffer(gif->frame_image);\n        if (!frame_data) {\n                return GIF_INSUFFICIENT_MEMORY;\n        }\n\n        /* If we are clearing the image we just clear, if not decode */\n        if (!clear_image) {\n                lzw_result res;\n                const uint8_t *stack_base;\n                const uint8_t *stack_pos;\n\n                /* Ensure we have enough data for a 1-byte LZW code size +\n                 * 1-byte gif trailer\n                 */\n                if (gif_bytes < 2) {\n                        return_value = GIF_INSUFFICIENT_FRAME_DATA;\n                        goto gif_decode_frame_exit;\n                }\n\n                /* If we only have a 1-byte LZW code size + 1-byte gif trailer,\n                 * we're finished\n                 */\n                if ((gif_bytes == 2) && (gif_data[1] == GIF_TRAILER)) {\n                        return_value = GIF_OK;\n                        goto gif_decode_frame_exit;\n                }\n\n                /* If the previous frame's disposal method requires we restore\n                 * the background colour or this is the first frame, clear\n                 * the frame data\n                 */\n                if ((frame == 0) || (gif->decoded_frame == GIF_INVALID_FRAME)) {\n                        memset((char*)frame_data,\n                               GIF_TRANSPARENT_COLOUR,\n                               gif->width * gif->height * sizeof(int));\n                        gif->decoded_frame = frame;\n                        /* The line below would fill the image with its\n                         * background color, but because GIFs support\n                         * transparency we likely wouldn't want to do that. */\n                        /* memset((char*)frame_data, colour_table[gif->background_index], gif->width * gif->height * sizeof(int)); */\n                } else if ((frame != 0) &&\n                           (gif->frames[frame - 1].disposal_method == GIF_FRAME_CLEAR)) {\n                        return_value = gif_internal_decode_frame(gif,\n                                                                 (frame - 1),\n                                                                 true);\n                        if (return_value != GIF_OK) {\n                                goto gif_decode_frame_exit;\n                        }\n\n                } else if ((frame != 0) &&\n                           (gif->frames[frame - 1].disposal_method == GIF_FRAME_RESTORE)) {\n                        /*\n                         * If the previous frame's disposal method requires we\n                         * restore the previous image, find the last image set\n                         * to \"do not dispose\" and get that frame data\n                         */\n                        int last_undisposed_frame = frame - 2;\n                        while ((last_undisposed_frame >= 0) &&\n                               (gif->frames[last_undisposed_frame].disposal_method == GIF_FRAME_RESTORE)) {\n                                last_undisposed_frame--;\n                        }\n\n                        /* If we don't find one, clear the frame data */\n                        if (last_undisposed_frame == -1) {\n                                /* see notes above on transparency\n                                 * vs. background color\n                                 */\n                                memset((char*)frame_data,\n                                       GIF_TRANSPARENT_COLOUR,\n                                       gif->width * gif->height * sizeof(int));\n                        } else {\n                                return_value = gif_internal_decode_frame(gif, last_undisposed_frame, false);\n                                if (return_value != GIF_OK) {\n                                        goto gif_decode_frame_exit;\n                                }\n                                /* Get this frame's data */\n                                assert(gif->bitmap_callbacks.bitmap_get_buffer);\n                                frame_data = (void *)gif->bitmap_callbacks.bitmap_get_buffer(gif->frame_image);\n                                if (!frame_data) {\n                                        return GIF_INSUFFICIENT_MEMORY;\n                                }\n                        }\n                }\n                gif->decoded_frame = frame;\n                gif->buffer_position = (gif_data - gif->gif_data) + 1;\n\n                /* Initialise the LZW decoding */\n                res = lzw_decode_init(gif->lzw_ctx, gif->gif_data,\n                                gif->buffer_size, gif->buffer_position,\n                                gif_data[0], &stack_base, &stack_pos);\n                if (res != LZW_OK) {\n                        return gif_error_from_lzw(res);\n                }\n\n                /* Decompress the data */\n                for (y = 0; y < height; y++) {\n                        if (interlace) {\n                                decode_y = gif_interlaced_line(height, y) + offset_y;\n                        } else {\n                                decode_y = y + offset_y;\n                        }\n                        frame_scanline = frame_data + offset_x + (decode_y * gif->width);\n\n                        /* Rather than decoding pixel by pixel, we try to burst\n                         * out streams of data to remove the need for end-of\n                         * data checks every pixel.\n                         */\n                        x = width;\n                        while (x > 0) {\n                                burst_bytes = (stack_pos - stack_base);\n                                if (burst_bytes > 0) {\n                                        if (burst_bytes > x) {\n                                                burst_bytes = x;\n                                        }\n                                        x -= burst_bytes;\n                                        while (burst_bytes-- > 0) {\n                                                colour = *--stack_pos;\n                                                if (((gif->frames[frame].transparency) &&\n                                                     (colour != gif->frames[frame].transparency_index)) ||\n                                                    (!gif->frames[frame].transparency)) {\n                                                        *frame_scanline = colour_table[colour];\n                                                }\n                                                frame_scanline++;\n                                        }\n                                } else {\n                                        res = lzw_decode(gif->lzw_ctx, &stack_pos);\n                                        if (res != LZW_OK) {\n                                                /* Unexpected end of frame, try to recover */\n                                                if (res == LZW_OK_EOD) {\n                                                        return_value = GIF_OK;\n                                                } else {\n                                                        return_value = gif_error_from_lzw(res);\n                                                }\n                                                goto gif_decode_frame_exit;\n                                        }\n                                }\n                        }\n                }\n        } else {\n                /* Clear our frame */\n                if (gif->frames[frame].disposal_method == GIF_FRAME_CLEAR) {\n                        for (y = 0; y < height; y++) {\n                                frame_scanline = frame_data + offset_x + ((offset_y + y) * gif->width);\n                                if (gif->frames[frame].transparency) {\n                                        memset(frame_scanline,\n                                               GIF_TRANSPARENT_COLOUR,\n                                               width * 4);\n                                } else {\n                                        memset(frame_scanline,\n                                               colour_table[gif->background_index],\n                                               width * 4);\n                                }\n                        }\n                }\n        }\ngif_decode_frame_exit:\n\n        /* Check if we should test for optimisation */\n        if (gif->frames[frame].virgin) {\n                if (gif->bitmap_callbacks.bitmap_test_opaque) {\n                        gif->frames[frame].opaque = gif->bitmap_callbacks.bitmap_test_opaque(gif->frame_image);\n                } else {\n                        gif->frames[frame].opaque = false;\n                }\n                gif->frames[frame].virgin = false;\n        }\n\n        if (gif->bitmap_callbacks.bitmap_set_opaque) {\n                gif->bitmap_callbacks.bitmap_set_opaque(gif->frame_image, gif->frames[frame].opaque);\n        }\n\n        if (gif->bitmap_callbacks.bitmap_modified) {\n                gif->bitmap_callbacks.bitmap_modified(gif->frame_image);\n        }\n\n        /* Restore the buffer position */\n        gif->buffer_position = save_buffer_position;\n\n        return return_value;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "libnsgif.c",
        "method_name": "fixed_function",
        "raw_code": "gif_internal_decode_frame(gif_animation *gif,\n                          unsigned int frame,\n                          bool clear_image)\n{\n        unsigned int index = 0;\n        const unsigned char *gif_data, *gif_end;\n        ssize_t gif_bytes;\n        unsigned int width, height, offset_x, offset_y;\n        unsigned int flags, colour_table_size, interlace;\n        unsigned int *colour_table;\n        unsigned int *frame_data = 0;\t// Set to 0 for no warnings\n        unsigned int *frame_scanline;\n        ssize_t save_buffer_position;\n        unsigned int return_value = 0;\n        unsigned int x, y, decode_y, burst_bytes;\n        register unsigned char colour;\n\n        /* If the GIF has no frame data, frame holders will not be allocated in\n         * gif_initialise() */\n        if (gif->frames == NULL) {\n                return GIF_INSUFFICIENT_DATA;\n        }\n\n        /* Ensure this frame is supposed to be decoded */\n        if (gif->frames[frame].display == false) {\n                return GIF_OK;\n        }\n\n        /* Ensure the frame is in range to decode */\n        if (frame > gif->frame_count_partial) {\n                return GIF_INSUFFICIENT_DATA;\n        }\n\n        /* done if frame is already decoded */\n        if ((!clear_image) &&\n            ((int)frame == gif->decoded_frame)) {\n                return GIF_OK;\n        }\n\n        /* Get the start of our frame data and the end of the GIF data */\n        gif_data = gif->gif_data + gif->frames[frame].frame_pointer;\n        gif_end = gif->gif_data + gif->buffer_size;\n        gif_bytes = (gif_end - gif_data);\n\n        /*\n         * Ensure there is a minimal amount of data to proceed.  The shortest\n         * block of data is a 10-byte image descriptor + 1-byte gif trailer\n         */\n        if (gif_bytes < 12) {\n                return GIF_INSUFFICIENT_FRAME_DATA;\n        }\n\n        /* Save the buffer position */\n        save_buffer_position = gif->buffer_position;\n        gif->buffer_position = gif_data - gif->gif_data;\n\n        /* Skip any extensions because they have allready been processed */\n        if ((return_value = gif_skip_frame_extensions(gif)) != GIF_OK) {\n                goto gif_decode_frame_exit;\n        }\n        gif_data = (gif->gif_data + gif->buffer_position);\n        gif_bytes = (gif_end - gif_data);\n\n        /* Ensure we have enough data for the 10-byte image descriptor + 1-byte\n         * gif trailer\n         */\n        if (gif_bytes < 12) {\n                return_value = GIF_INSUFFICIENT_FRAME_DATA;\n                goto gif_decode_frame_exit;\n        }\n\n        /* 10-byte Image Descriptor is:\n         *\n         *\t+0\tCHAR\tImage Separator (0x2c)\n         *\t+1\tSHORT\tImage Left Position\n         *\t+3\tSHORT\tImage Top Position\n         *\t+5\tSHORT\tWidth\n         *\t+7\tSHORT\tHeight\n         *\t+9\tCHAR\t__Packed Fields__\n         *\t\t\t1BIT\tLocal Colour Table Flag\n         *\t\t\t1BIT\tInterlace Flag\n         *\t\t\t1BIT\tSort Flag\n         *\t\t\t2BITS\tReserved\n         *\t\t\t3BITS\tSize of Local Colour Table\n         */\n        if (gif_data[0] != GIF_IMAGE_SEPARATOR) {\n                return_value = GIF_DATA_ERROR;\n                goto gif_decode_frame_exit;\n        }\n        offset_x = gif_data[1] | (gif_data[2] << 8);\n        offset_y = gif_data[3] | (gif_data[4] << 8);\n        width = gif_data[5] | (gif_data[6] << 8);\n        height = gif_data[7] | (gif_data[8] << 8);\n\n        /* Boundary checking - shouldn't ever happen except unless the data has\n         * been modified since initialisation.\n         */\n        if ((offset_x + width > gif->width) ||\n            (offset_y + height > gif->height)) {\n                return_value = GIF_DATA_ERROR;\n                goto gif_decode_frame_exit;\n        }\n\n        /* Decode the flags */\n        flags = gif_data[9];\n        colour_table_size = 2 << (flags & GIF_COLOUR_TABLE_SIZE_MASK);\n        interlace = flags & GIF_INTERLACE_MASK;\n\n        /* Advance data pointer to next block either colour table or image\n         * data.\n         */\n        gif_data += 10;\n        gif_bytes = (gif_end - gif_data);\n\n        /* Set up the colour table */\n        if (flags & GIF_COLOUR_TABLE_MASK) {\n                if (gif_bytes < (int)(3 * colour_table_size)) {\n                        return_value = GIF_INSUFFICIENT_FRAME_DATA;\n                        goto gif_decode_frame_exit;\n                }\n                colour_table = gif->local_colour_table;\n                if (!clear_image) {\n                        for (index = 0; index < colour_table_size; index++) {\n                                /* Gif colour map contents are r,g,b.\n                                 *\n                                 * We want to pack them bytewise into the\n                                 * colour table, such that the red component\n                                 * is in byte 0 and the alpha component is in\n                                 * byte 3.\n                                 */\n                                unsigned char *entry =\n                                        (unsigned char *) &colour_table[index];\n\n                                entry[0] = gif_data[0];\t/* r */\n                                entry[1] = gif_data[1];\t/* g */\n                                entry[2] = gif_data[2];\t/* b */\n                                entry[3] = 0xff;\t/* a */\n\n                                gif_data += 3;\n                        }\n                } else {\n                        gif_data += 3 * colour_table_size;\n                }\n                gif_bytes = (gif_end - gif_data);\n        } else {\n                colour_table = gif->global_colour_table;\n        }\n\n        /* Ensure sufficient data remains */\n        if (gif_bytes < 1) {\n                return_value = GIF_INSUFFICIENT_FRAME_DATA;\n                goto gif_decode_frame_exit;\n        }\n\n        /* check for an end marker */\n        if (gif_data[0] == GIF_TRAILER) {\n                return_value = GIF_OK;\n                goto gif_decode_frame_exit;\n        }\n\n        /* Get the frame data */\n        assert(gif->bitmap_callbacks.bitmap_get_buffer);\n        frame_data = (void *)gif->bitmap_callbacks.bitmap_get_buffer(gif->frame_image);\n        if (!frame_data) {\n                return GIF_INSUFFICIENT_MEMORY;\n        }\n\n        /* If we are clearing the image we just clear, if not decode */\n        if (!clear_image) {\n                lzw_result res;\n                const uint8_t *stack_base;\n                const uint8_t *stack_pos;\n\n                /* Ensure we have enough data for a 1-byte LZW code size +\n                 * 1-byte gif trailer\n                 */\n                if (gif_bytes < 2) {\n                        return_value = GIF_INSUFFICIENT_FRAME_DATA;\n                        goto gif_decode_frame_exit;\n                }\n\n                /* If we only have a 1-byte LZW code size + 1-byte gif trailer,\n                 * we're finished\n                 */\n                if ((gif_bytes == 2) && (gif_data[1] == GIF_TRAILER)) {\n                        return_value = GIF_OK;\n                        goto gif_decode_frame_exit;\n                }\n\n                /* If the previous frame's disposal method requires we restore\n                 * the background colour or this is the first frame, clear\n                 * the frame data\n                 */\n                if ((frame == 0) || (gif->decoded_frame == GIF_INVALID_FRAME)) {\n                        memset((char*)frame_data,\n                               GIF_TRANSPARENT_COLOUR,\n                               gif->width * gif->height * sizeof(int));\n                        gif->decoded_frame = frame;\n                        /* The line below would fill the image with its\n                         * background color, but because GIFs support\n                         * transparency we likely wouldn't want to do that. */\n                        /* memset((char*)frame_data, colour_table[gif->background_index], gif->width * gif->height * sizeof(int)); */\n                } else if ((frame != 0) &&\n                           (gif->frames[frame - 1].disposal_method == GIF_FRAME_CLEAR)) {\n                        return_value = gif_internal_decode_frame(gif,\n                                                                 (frame - 1),\n                                                                 true);\n                        if (return_value != GIF_OK) {\n                                goto gif_decode_frame_exit;\n                        }\n\n                } else if ((frame != 0) &&\n                           (gif->frames[frame - 1].disposal_method == GIF_FRAME_RESTORE)) {\n                        /*\n                         * If the previous frame's disposal method requires we\n                         * restore the previous image, find the last image set\n                         * to \"do not dispose\" and get that frame data\n                         */\n                        int last_undisposed_frame = frame - 2;\n                        while ((last_undisposed_frame >= 0) &&\n                               (gif->frames[last_undisposed_frame].disposal_method == GIF_FRAME_RESTORE)) {\n                                last_undisposed_frame--;\n                        }\n\n                        /* If we don't find one, clear the frame data */\n                        if (last_undisposed_frame == -1) {\n                                /* see notes above on transparency\n                                 * vs. background color\n                                 */\n                                memset((char*)frame_data,\n                                       GIF_TRANSPARENT_COLOUR,\n                                       gif->width * gif->height * sizeof(int));\n                        } else {\n                                return_value = gif_internal_decode_frame(gif, last_undisposed_frame, false);\n                                if (return_value != GIF_OK) {\n                                        goto gif_decode_frame_exit;\n                                }\n                                /* Get this frame's data */\n                                assert(gif->bitmap_callbacks.bitmap_get_buffer);\n                                frame_data = (void *)gif->bitmap_callbacks.bitmap_get_buffer(gif->frame_image);\n                                if (!frame_data) {\n                                        return GIF_INSUFFICIENT_MEMORY;\n                                }\n                        }\n                }\n                gif->decoded_frame = frame;\n                gif->buffer_position = (gif_data - gif->gif_data) + 1;\n\n                /* Initialise the LZW decoding */\n                res = lzw_decode_init(gif->lzw_ctx, gif->gif_data,\n                                gif->buffer_size, gif->buffer_position,\n                                gif_data[0], &stack_base, &stack_pos);\n                if (res != LZW_OK) {\n                        return gif_error_from_lzw(res);\n                }\n\n                /* Decompress the data */\n                for (y = 0; y < height; y++) {\n                        if (interlace) {\n                                decode_y = gif_interlaced_line(height, y) + offset_y;\n                        } else {\n                                decode_y = y + offset_y;\n                        }\n                        frame_scanline = frame_data + offset_x + (decode_y * gif->width);\n\n                        /* Rather than decoding pixel by pixel, we try to burst\n                         * out streams of data to remove the need for end-of\n                         * data checks every pixel.\n                         */\n                        x = width;\n                        while (x > 0) {\n                                burst_bytes = (stack_pos - stack_base);\n                                if (burst_bytes > 0) {\n                                        if (burst_bytes > x) {\n                                                burst_bytes = x;\n                                        }\n                                        x -= burst_bytes;\n                                        while (burst_bytes-- > 0) {\n                                                colour = *--stack_pos;\n                                                if (((gif->frames[frame].transparency) &&\n                                                     (colour != gif->frames[frame].transparency_index)) ||\n                                                    (!gif->frames[frame].transparency)) {\n                                                        *frame_scanline = colour_table[colour];\n                                                }\n                                                frame_scanline++;\n                                        }\n                                } else {\n                                        res = lzw_decode(gif->lzw_ctx, &stack_pos);\n                                        if (res != LZW_OK) {\n                                                /* Unexpected end of frame, try to recover */\n                                                if (res == LZW_OK_EOD) {\n                                                        return_value = GIF_OK;\n                                                } else {\n                                                        return_value = gif_error_from_lzw(res);\n                                                }\n                                                goto gif_decode_frame_exit;\n                                        }\n                                }\n                        }\n                }\n        } else {\n                /* Clear our frame */\n                if (gif->frames[frame].disposal_method == GIF_FRAME_CLEAR) {\n                        for (y = 0; y < height; y++) {\n                                frame_scanline = frame_data + offset_x + ((offset_y + y) * gif->width);\n                                if (gif->frames[frame].transparency) {\n                                        memset(frame_scanline,\n                                               GIF_TRANSPARENT_COLOUR,\n                                               width * 4);\n                                } else {\n                                        memset(frame_scanline,\n                                               colour_table[gif->background_index],\n                                               width * 4);\n                                }\n                        }\n                }\n        }\ngif_decode_frame_exit:\n\n        /* Check if we should test for optimisation */\n        if (gif->frames[frame].virgin) {\n                if (gif->bitmap_callbacks.bitmap_test_opaque) {\n                        gif->frames[frame].opaque = gif->bitmap_callbacks.bitmap_test_opaque(gif->frame_image);\n                } else {\n                        gif->frames[frame].opaque = false;\n                }\n                gif->frames[frame].virgin = false;\n        }\n\n        if (gif->bitmap_callbacks.bitmap_set_opaque) {\n                gif->bitmap_callbacks.bitmap_set_opaque(gif->frame_image, gif->frames[frame].opaque);\n        }\n\n        if (gif->bitmap_callbacks.bitmap_modified) {\n                gif->bitmap_callbacks.bitmap_modified(gif->frame_image);\n        }\n\n        /* Restore the buffer position */\n        gif->buffer_position = save_buffer_position;\n\n        return return_value;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <stdbool.h>\n#include <stdlib.h>\n#include \"lzw.h\"\n#include \"log.h\"\n#include \"libnsgif.h\"\n#include <string.h>\n#include <stdint.h>\n#include <assert.h>\n#include <stdio.h>\n\n// Type Definitions:\n// lzw_result:\ntypedef enum lzw_result {\n\tLZW_OK,        /**< Success */\n\tLZW_OK_EOD,    /**< Success; reached zero-length sub-block */\n\tLZW_NO_MEM,    /**< Error: Out of memory */\n\tLZW_NO_DATA,   /**< Error: Out of data */\n\tLZW_EOI_CODE,  /**< Error: End of Information code */\n\tLZW_BAD_ICODE, /**< Error: Bad initial LZW code */\n\tLZW_BAD_CODE,  /**< Error: Bad LZW code */\n} lzw_result;\n\n// gif_result:\ntypedef enum {\n        GIF_WORKING = 1,\n        GIF_OK = 0,\n        GIF_INSUFFICIENT_FRAME_DATA = -1,\n        GIF_FRAME_DATA_ERROR = -2,\n        GIF_INSUFFICIENT_DATA = -3,\n        GIF_DATA_ERROR = -4,\n        GIF_INSUFFICIENT_MEMORY = -5,\n        GIF_FRAME_NO_DISPLAY = -6,\n        GIF_END_OF_FRAME = -7\n}\n\n// gif_animation:\ntypedef struct gif_animation {\n        /** LZW decode context */\n        void *lzw_ctx;\n        /** callbacks for bitmap functions */\n        gif_bitmap_callback_vt bitmap_callbacks;\n        /** pointer to GIF data */\n        unsigned char *gif_data;\n        /** width of GIF (may increase during decoding) */\n        unsigned int width;\n        /** heigth of GIF (may increase during decoding) */\n        unsigned int height;\n        /** number of frames decoded */\n        unsigned int frame_count;\n        /** number of frames partially decoded */\n        unsigned int frame_count_partial;\n        /** decoded frames */\n        gif_frame *frames;\n        /** current frame decoded to bitmap */\n        int decoded_frame;\n        /** currently decoded image; stored as bitmap from bitmap_create callback */\n        void *frame_image;\n        /** number of times to loop animation */\n        int loop_count;\n\n        /* Internal members are listed below */\n\n        /** current index into GIF dat...\n\n// Called Methods (top 10):\n// GIF_TRAILER from libnsgif/libnsgif.c:\n<empty>\n\n// GIF_IMAGE_SEPARATOR from libnsgif/libnsgif.c:\n<empty>\n\n// GIF_COLOUR_TABLE_MASK from libnsgif/libnsgif.c:\n<empty>\n\n// GIF_FRAME_RESTORE from libnsgif/libnsgif.c:\n<empty>\n\n// gif_internal_decode_frame from libnsgif/libnsgif.c:\nstatic gif_result\ngif_internal_decode_frame(gif_animation *gif,\n                          unsigned int frame,\n                          bool clear_image)\n{\n        unsigned int index = 0;\n        const unsigned char *gif_data, *gif_end;\n        ssize_t gif_bytes;\n        unsigned int width, height, offset_x, offset_y;\n        unsigned int flags, colour_table_size, interlace;\n        unsigned int *colour_table;\n        unsigned int *frame_data = 0;\t// Set to 0 for no warnings\n        unsigned int *frame_scanline;\n        ssize_t save_buffer_position;\n        unsigned int return_value = 0;\n        unsigned int x, y, decode_y, burst_bytes;\n        register unsigned char colour;\n\n        /* If the GIF has no frame data, frame holders will not be allocated in\n         * gif_initialise() */\n        if (gif->frames == NULL) {\n                return GIF_INSUFFICIENT_DATA;\n        }\n\n        /* Ensure this frame is supposed to be decoded */\n        if (gif->frames[frame].display == false) {\n...\n\n// GIF_FRAME_CLEAR from libnsgif/libnsgif.c:\n<empty>\n\n// gif_interlaced_line from libnsgif/libnsgif.c:\nstatic unsigned int gif_interlaced_line(int height, int y) {\n        if ((y << 3) < height) {\n                return (y << 3);\n        }\n        y -= ((height + 7) >> 3);\n        if ((y << 3) < (height - 4)) {\n                return (y << 3) + 4;\n        }\n        y -= ((height + 3) >> 3);\n        if ((y << 2) < (height - 2)) {\n                return (y << 2) + 2;\n        }\n        y -= ((height + 1) >> 2);\n        return (y << 1) + 1;\n}\n\n// GIF_TRANSPARENT_COLOUR from libnsgif/libnsgif.c:\n<empty>\n\n// lzw_decode_init from libnsgif/lzw.c:\nlzw_result lzw_decode_init(\n\t\tstruct lzw_ctx *ctx,\n\t\tconst uint8_t *compressed_data,\n\t\tuint64_t compressed_data_len,\n\t\tuint64_t compressed_data_pos,\n\t\tuint8_t code_size,\n\t\tconst uint8_t ** const stack_base_out,\n\t\tconst uint8_t ** const stack_pos_out)\n{\n\tstruct lzw_dictionary_entry *table = ctx->table;\n\n\t/* Initialise the input reading context */\n\tctx->input.data = compressed_data;\n\tctx->input.data_len = compressed_data_len;\n\tctx->input.data_sb_next = compressed_data_pos;\n\n\tctx->input.sb_bit = 0;\n\tctx->input.sb_bit_count = 0;\n\n\t/* Initialise the dictionary building context */\n\tctx->initial_code_size = code_size;\n\n\tctx->clear_code = (1 << code_size) + 0;\n\tctx->eoi_code   = (1 << code_size) + 1;\n\n\t/* Initialise the standard dictionary entries */\n\tfor (uint32_t i = 0; i < ctx->clear_code; ++i) {\n\t\ttable[i].first_value = i;\n\t\ttable[i].last_value  = i;\n\t}\n\n\t*stack_base_out = ctx->stack_base;\n\treturn lzw__clear_codes(ctx, stack_pos_out);\n}\n\n// lzw_decode from libnsgif/lzw.c:\nlzw_result lzw_decode(struct lzw_ctx *ctx,\n\t\tconst uint8_t ** const stack_pos_out)\n{\n\tlzw_result res;\n\tuint32_t code_new;\n\tuint32_t code_out;\n\tuint8_t last_value;\n\tuint8_t *stack_pos = ctx->stack_base;\n\tuint32_t clear_code = ctx->clear_code;\n\tuint32_t current_entry = ctx->current_entry;\n\tstruct lzw_dictionary_entry * const table = ctx->table;\n\n\t/* Get a new code from the input */\n\tres = lzw__next_code(&ctx->input, ctx->current_code_size, &code_new);\n\tif (res != LZW_OK) {\n\t\treturn res;\n\t}\n\n\t/* Handle the new code */\n\tif (code_new == clear_code) {\n\t\t/* Got Clear code */\n\t\treturn lzw__clear_codes(ctx, stack_pos_out);\n\n\t} else if (code_new == ctx->eoi_code) {\n\t\t/* Got End of Information code */\n\t\treturn LZW_EOI_CODE;\n\n\t} else if (code_new > current_entry) {\n\t\t/* Code is invalid */\n\t\treturn LZW_BAD_CODE;\n\n\t} else if (code_new < current_entry) {\n\t\t/* Code is in table */\n\t\tcode_out = code_new;\n\t\tlast_value = table[code_new].first_value;\n\t} else {\n\t\t/* Code not in table */\n\t\t*stack_pos++ = ...\n"
  },
  {
    "repository": "ntp",
    "cve_id": "CVE-2015-7852",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "07a5b8141e354a998a52994c3c9cd547927e56ce",
    "short_hash": "07a5b814",
    "vulnerableMethods_before": [
      {
        "filename": "ntpq.c",
        "method_name": "vulnerable_function",
        "raw_code": "cookedprint(\n\tint datatype,\n\tint length,\n\tconst char *data,\n\tint status,\n\tint quiet,\n\tFILE *fp\n\t)\n{\n\tchar *name;\n\tchar *value;\n\tchar output_raw;\n\tint fmt;\n\tl_fp lfp;\n\tsockaddr_u hval;\n\tu_long uval;\n\tint narr;\n\tsize_t len;\n\tl_fp lfparr[8];\n\tchar b[12];\n\tchar bn[2 * MAXVARLEN];\n\tchar bv[2 * MAXVALLEN];\n\n\tUNUSED_ARG(datatype);\n\n\tif (!quiet)\n\t\tfprintf(fp, \"status=%04x %s,\\n\", status,\n\t\t\tstatustoa(datatype, status));\n\n\tstartoutput();\n\twhile (nextvar(&length, &data, &name, &value)) {\n\t\tfmt = varfmt(name);\n\t\toutput_raw = 0;\n\t\tswitch (fmt) {\n\n\t\tcase PADDING:\n\t\t\toutput_raw = '*';\n\t\t\tbreak;\n\n\t\tcase TS:\n\t\t\tif (!decodets(value, &lfp))\n\t\t\t\toutput_raw = '?';\n\t\t\telse\n\t\t\t\toutput(fp, name, prettydate(&lfp));\n\t\t\tbreak;\n\n\t\tcase HA:\t/* fallthru */\n\t\tcase NA:\n\t\t\tif (!decodenetnum(value, &hval)) {\n\t\t\t\toutput_raw = '?';\n\t\t\t} else if (fmt == HA){\n\t\t\t\toutput(fp, name, nntohost(&hval));\n\t\t\t} else {\n\t\t\t\toutput(fp, name, stoa(&hval));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase RF:\n\t\t\tif (decodenetnum(value, &hval)) {\n\t\t\t\tif (ISREFCLOCKADR(&hval))\n\t\t\t\t\toutput(fp, name,\n\t\t\t\t\t       refnumtoa(&hval));\n\t\t\t\telse\n\t\t\t\t\toutput(fp, name, stoa(&hval));\n\t\t\t} else if (strlen(value) <= 4) {\n\t\t\t\toutput(fp, name, value);\n\t\t\t} else {\n\t\t\t\toutput_raw = '?';\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase LP:\n\t\t\tif (!decodeuint(value, &uval) || uval > 3) {\n\t\t\t\toutput_raw = '?';\n\t\t\t} else {\n\t\t\t\tb[0] = (0x2 & uval)\n\t\t\t\t\t   ? '1'\n\t\t\t\t\t   : '0';\n\t\t\t\tb[1] = (0x1 & uval)\n\t\t\t\t\t   ? '1'\n\t\t\t\t\t   : '0';\n\t\t\t\tb[2] = '\\0';\n\t\t\t\toutput(fp, name, b);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase OC:\n\t\t\tif (!decodeuint(value, &uval)) {\n\t\t\t\toutput_raw = '?';\n\t\t\t} else {\n\t\t\t\tsnprintf(b, sizeof(b), \"%03lo\", uval);\n\t\t\t\toutput(fp, name, b);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase AR:\n\t\t\tif (!decodearr(value, &narr, lfparr))\n\t\t\t\toutput_raw = '?';\n\t\t\telse\n\t\t\t\toutputarr(fp, name, narr, lfparr);\n\t\t\tbreak;\n\n\t\tcase FX:\n\t\t\tif (!decodeuint(value, &uval))\n\t\t\t\toutput_raw = '?';\n\t\t\telse\n\t\t\t\toutput(fp, name, tstflags(uval));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Internal error in cookedprint, %s=%s, fmt %d\\n\",\n\t\t\t\tname, value, fmt);\n\t\t\toutput_raw = '?';\n\t\t\tbreak;\n\t\t}\n\n\t\tif (output_raw != 0) {\n\t\t\tatoascii(name, MAXVARLEN, bn, sizeof(bn));\n\t\t\tatoascii(value, MAXVALLEN, bv, sizeof(bv));\n\t\t\tif (output_raw != '*') {\n\t\t\t\tlen = strlen(bv);\n\t\t\t\tbv[len] = output_raw;\n\t\t\t\tbv[len+1] = '\\0';\n\t\t\t}\n\t\t\toutput(fp, bn, bv);\n\t\t}\n\t}\n\tendoutput(fp);\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ntpq.c",
        "method_name": "fixed_function",
        "raw_code": "cookedprint(\n\tint datatype,\n\tint length,\n\tconst char *data,\n\tint status,\n\tint quiet,\n\tFILE *fp\n\t)\n{\n\tchar *name;\n\tchar *value;\n\tchar output_raw;\n\tint fmt;\n\tl_fp lfp;\n\tsockaddr_u hval;\n\tu_long uval;\n\tint narr;\n\tsize_t len;\n\tl_fp lfparr[8];\n\tchar b[12];\n\tchar bn[2 * MAXVARLEN];\n\tchar bv[2 * MAXVALLEN];\n\n\tUNUSED_ARG(datatype);\n\n\tif (!quiet)\n\t\tfprintf(fp, \"status=%04x %s,\\n\", status,\n\t\t\tstatustoa(datatype, status));\n\n\tstartoutput();\n\twhile (nextvar(&length, &data, &name, &value)) {\n\t\tfmt = varfmt(name);\n\t\toutput_raw = 0;\n\t\tswitch (fmt) {\n\n\t\tcase PADDING:\n\t\t\toutput_raw = '*';\n\t\t\tbreak;\n\n\t\tcase TS:\n\t\t\tif (!decodets(value, &lfp))\n\t\t\t\toutput_raw = '?';\n\t\t\telse\n\t\t\t\toutput(fp, name, prettydate(&lfp));\n\t\t\tbreak;\n\n\t\tcase HA:\t/* fallthru */\n\t\tcase NA:\n\t\t\tif (!decodenetnum(value, &hval)) {\n\t\t\t\toutput_raw = '?';\n\t\t\t} else if (fmt == HA){\n\t\t\t\toutput(fp, name, nntohost(&hval));\n\t\t\t} else {\n\t\t\t\toutput(fp, name, stoa(&hval));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase RF:\n\t\t\tif (decodenetnum(value, &hval)) {\n\t\t\t\tif (ISREFCLOCKADR(&hval))\n\t\t\t\t\toutput(fp, name,\n\t\t\t\t\t       refnumtoa(&hval));\n\t\t\t\telse\n\t\t\t\t\toutput(fp, name, stoa(&hval));\n\t\t\t} else if (strlen(value) <= 4) {\n\t\t\t\toutput(fp, name, value);\n\t\t\t} else {\n\t\t\t\toutput_raw = '?';\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase LP:\n\t\t\tif (!decodeuint(value, &uval) || uval > 3) {\n\t\t\t\toutput_raw = '?';\n\t\t\t} else {\n\t\t\t\tb[0] = (0x2 & uval)\n\t\t\t\t\t   ? '1'\n\t\t\t\t\t   : '0';\n\t\t\t\tb[1] = (0x1 & uval)\n\t\t\t\t\t   ? '1'\n\t\t\t\t\t   : '0';\n\t\t\t\tb[2] = '\\0';\n\t\t\t\toutput(fp, name, b);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase OC:\n\t\t\tif (!decodeuint(value, &uval)) {\n\t\t\t\toutput_raw = '?';\n\t\t\t} else {\n\t\t\t\tsnprintf(b, sizeof(b), \"%03lo\", uval);\n\t\t\t\toutput(fp, name, b);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase AR:\n\t\t\tif (!decodearr(value, &narr, lfparr))\n\t\t\t\toutput_raw = '?';\n\t\t\telse\n\t\t\t\toutputarr(fp, name, narr, lfparr);\n\t\t\tbreak;\n\n\t\tcase FX:\n\t\t\tif (!decodeuint(value, &uval))\n\t\t\t\toutput_raw = '?';\n\t\t\telse\n\t\t\t\toutput(fp, name, tstflags(uval));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Internal error in cookedprint, %s=%s, fmt %d\\n\",\n\t\t\t\tname, value, fmt);\n\t\t\toutput_raw = '?';\n\t\t\tbreak;\n\t\t}\n\n\t\tif (output_raw != 0) {\n\t\t\t/* TALOS-CAN-0063: avoid buffer overrun */\n\t\t\tatoascii(name, MAXVARLEN, bn, sizeof(bn));\n\t\t\tif (output_raw != '*') {\n\t\t\t\tatoascii(value, MAXVALLEN,\n\t\t\t\t\t bv, sizeof(bv) - 1);\n\t\t\t\tlen = strlen(bv);\n\t\t\t\tbv[len] = output_raw;\n\t\t\t\tbv[len+1] = '\\0';\n\t\t\t} else {\n\t\t\t\tatoascii(value, MAXVALLEN,\n\t\t\t\t\t bv, sizeof(bv));\n\t\t\t}\n\t\t\toutput(fp, bn, bv);\n\t\t}\n\t}\n\tendoutput(fp);\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"ntpq-opts.h\"\n#include \"ntpq.h\"\n# include <unistd.h>\n#include \"openssl/err.h\"\n# include <mswsock.h>\n#include \"ntp_select.h\"\n#include \"ntp_libopts.h\"\n#include <isc/result.h>\n#include \"lib_strbuf.h\"\n#include \"ntp_stdlib.h\"\n#include <sys/types.h>\n#include <ctype.h>\n#include \"ntp_lineedit.h\"\n#include <sys/time.h>\n#include <stdio.h>\n#include <setjmp.h>\n#include \"ntp_assert.h\"\n#include <isc/net.h>\n#include <ssl_applink.c>\n#include \"ntp_calendar.h\"\n#include \"ntp_unixtime.h\"\n#include \"openssl/objects.h\"\n#include <signal.h>\n#include \"openssl/evp.h\"\n# include <fcntl.h>\n#include \"ntp_debug.h\"\n#include <config.h>\n\n// Type Definitions:\n// sockaddr_u:\ntypedef union {\n\tstruct sockaddr\t\tsa;\n\tstruct sockaddr_in\tsa4;\n\tstruct sockaddr_in6\tsa6;\n}\n\n// l_fp:\ntypedef struct {\n\tunion {\n\t\tu_int32 Xl_ui;\n\t\tint32 Xl_i;\n\t} Ul_i;\n\tu_int32\tl_uf;\n}\n\n// size_t:\ntypedef unsigned int          size_t;\n\n// Called Methods (top 10):\n// refnumtoa from libntp/refnumtoa.c:\nconst char *\nrefnumtoa(\n\tsockaddr_u *num\n\t)\n{\n\tu_int32 netnum;\n\tchar *buf;\n\tconst char *rclock;\n\n\tif (!ISREFCLOCKADR(num))\n\t\treturn socktoa(num);\n\n\tLIB_GETBUF(buf);\n\tnetnum = SRCADR(num);\n\trclock = clockname((int)((u_long)netnum >> 8) & 0xff);\n\n\tif (rclock != NULL)\n\t\tsnprintf(buf, LIB_BUFLENGTH, \"%s(%lu)\",\n\t\t\t rclock, (u_long)netnum & 0xff);\n\telse\n\t\tsnprintf(buf, LIB_BUFLENGTH, \"REFCLK(%lu,%lu)\",\n\t\t\t ((u_long)netnum >> 8) & 0xff,\n\t\t\t (u_long)netnum & 0xff);\n\n\treturn buf;\n}\n\n// fprintf from include/l_stdlib.h:\nextern\tint\tfprintf\t\t(FILE *, const char *, ...);\n\n// socktoa from libntp/socktoa.c:\nconst char *\nsocktoa(\n\tconst sockaddr_u *sock\n\t)\n{\n\tint\t\tsaved_errno;\n\tchar *\t\tres;\n\tchar *\t\taddr;\n\tu_long\t\tscope;\n\n\tsaved_errno = socket_errno();\n\tLIB_GETBUF(res);\n\n\tif (NULL == sock) {\n\t\tstrlcpy(res, \"(null)\", LIB_BUFLENGTH);\n\t} else {\n\t\tswitch(AF(sock)) {\n\n\t\tcase AF_INET:\n\t\tcase AF_UNSPEC:\n\t\t\tinet_ntop(AF_INET, PSOCK_ADDR4(sock), res,\n\t\t\t\t  LIB_BUFLENGTH);\n\t\t\tbreak;\n\n\t\tcase AF_INET6:\n\t\t\tinet_ntop(AF_INET6, PSOCK_ADDR6(sock), res,\n\t\t\t\t  LIB_BUFLENGTH);\n\t\t\tscope = SCOPE_VAR(sock);\n\t\t\tif (0 != scope && !strchr(res, '%')) {\n\t\t\t\taddr = res;\n\t\t\t\tLIB_GETBUF(res);\n\t\t\t\tsnprintf(res, LIB_BUFLENGTH, \"%s%%%lu\",\n\t\t\t\t\t addr, scope);\n\t\t\t\tres[LIB_BUFLENGTH - 1] = '\\0';\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tsnprintf(res, LIB_BUFLENGTH, \n\t\t\t\t \"(socktoa unknown family %d)\", \n\t\t\t\t AF(sock));\n\t\t}\n\t}\n\terrno = saved_errno;\n\n\treturn res;\n}\n\n// AR from ntpq/ntpq.c:\n<empty>\n\n// decodenetnum from libntp/decodenetnum.c:\nint\ndecodenetnum(\n\tconst char *num,\n\tsockaddr_u *netnum\n\t)\n{\n\tstruct addrinfo hints, *ai = NULL;\n\tint err;\n\tu_short port;\n\tconst char *cp;\n\tconst char *port_str;\n\tchar *pp;\n\tchar *np;\n\tchar name[80];\n\n\tREQUIRE(num != NULL);\n\tREQUIRE(strlen(num) < sizeof(name));\n\n\tport_str = NULL;\n\tif ('[' != num[0]) {\n\t\t/*\n\t\t * to distinguish IPv6 embedded colons from a port\n\t\t * specification on an IPv4 address, assume all \n\t\t * legal IPv6 addresses have at least two colons.\n\t\t */\n\t\tpp = strchr(num, ':');\n\t\tif (NULL == pp)\n\t\t\tcp = num;\t/* no colons */\n\t\telse if (NULL != strchr(pp + 1, ':'))\n\t\t\tcp = num;\t/* two or more colons */\n\t\telse {\t\t\t/* one colon */\n\t\t\tstrlcpy(name, num, sizeof(name));\n\t\t\tcp = name;\n\t\t\tpp = strchr(cp, ':');\n\t\t\t*pp = '\\0';\n\t\t\tport_str = pp + 1;\n\t\t}\n\t} else {\n\t\tcp = num + 1;\n\t\tnp = name; \n\t\twhile (*cp && ']' != *cp)\n\t\t\t*np++ = *cp++;\n\t\t*np = 0;\n\t\tif (']' == cp[0] && ':' == cp[1] && '\\0' != cp[2])\n\t\t\tport_str = &cp[2];\n\t\tcp = name; \n\t}\n\tZERO(hints);\n\thints.ai_flags = Z_AI_NUMERIC...\n\n// atoascii from ntpq/ntpq.c:\nstatic void\natoascii(\n\tconst char *in,\n\tsize_t in_octets,\n\tchar *out,\n\tsize_t out_octets\n\t)\n{\n\tconst u_char *\tpchIn;\n\tconst u_char *\tpchInLimit;\n\tu_char *\tpchOut;\n\tu_char\t\tc;\n\n\tpchIn = (const u_char *)in;\n\tpchInLimit = pchIn + in_octets;\n\tpchOut = (u_char *)out;\n\n\tif (NULL == pchIn) {\n\t\tif (0 < out_octets)\n\t\t\t*pchOut = '\\0';\n\t\treturn;\n\t}\n\n#define\tONEOUT(c)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\\\n\tif (0 == --out_octets) {\t\t\t\\\n\t\t*pchOut = '\\0';\t\t\t\t\\\n\t\treturn;\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\\\n\t*pchOut++ = (c);\t\t\t\t\\\n} while (0)\n\n\tfor (\t; pchIn < pchInLimit; pchIn++) {\n\t\tc = *pchIn;\n\t\tif ('\\0' == c)\n\t\t\tbreak;\n\t\tif (c & 0x80) {\n\t\t\tONEOUT('M');\n\t\t\tONEOUT('-');\n\t\t\tc &= 0x7f;\n\t\t}\n\t\tif (c < ' ') {\n\t\t\tONEOUT('^');\n\t\t\tONEOUT((u_char)(c + '@'));\n\t\t} else if (0x7f == c) {\n\t\t\tONEOUT('^');\n\t\t\tONEOUT('?');\n\t\t} else\n\t\t\tONEOUT(c);\n\t}\n\tONEOUT('\\0');\n\n#undef ONEOUT\n}\n\n// rpl_snprintf from libntp/snprintf.c:\nint\nrpl_snprintf(char *str, size_t size, const char *format, ...);\n\n// outputarr from ntpq/ntpq.c:\nstatic void\noutputarr(\n\tFILE *fp,\n\tchar *name,\n\tint narr,\n\tl_fp *lfp\n\t)\n{\n\tregister char *bp;\n\tregister char *cp;\n\tregister int i;\n\tregister int len;\n\tchar buf[256];\n\n\tbp = buf;\n\t/*\n\t * Hack to align delay and offset values\n\t */\n\tfor (i = (int)strlen(name); i < 11; i++)\n\t    *bp++ = ' ';\n\n\tfor (i = narr; i > 0; i--) {\n\t\tif (i != narr)\n\t\t    *bp++ = ' ';\n\t\tcp = lfptoms(lfp, 2);\n\t\tlen = strlen(cp);\n\t\tif (len > 7) {\n\t\t\tcp[7] = '\\0';\n\t\t\tlen = 7;\n\t\t}\n\t\twhile (len < 7) {\n\t\t\t*bp++ = ' ';\n\t\t\tlen++;\n\t\t}\n\t\twhile (*cp != '\\0')\n\t\t    *bp++ = *cp++;\n\t\tlfp++;\n\t}\n\t*bp = '\\0';\n\toutput(fp, name, buf);\n}\n\n// decodearr from ntpq/ntpq.c:\nstatic int\ndecodearr(\n\tchar *str,\n\tint *narr,\n\tl_fp *lfparr\n\t)\n{\n\tregister char *cp, *bp;\n\tregister l_fp *lfp;\n\tchar buf[60];\n\n\tlfp = lfparr;\n\tcp = str;\n\t*narr = 0;\n\n\twhile (*narr < 8) {\n\t\twhile (isspace((int)*cp))\n\t\t    cp++;\n\t\tif (*cp == '\\0')\n\t\t    break;\n\n\t\tbp = buf;\n\t\twhile (!isspace((int)*cp) && *cp != '\\0')\n\t\t    *bp++ = *cp++;\n\t\t*bp++ = '\\0';\n\n\t\tif (!decodetime(buf, lfp))\n\t\t    return 0;\n\t\t(*narr)++;\n\t\tlfp++;\n\t}\n\treturn 1;\n}\n\n// TS from ntpq/ntpq.c:\n<empty>\n"
  },
  {
    "repository": "gerbv",
    "cve_id": "CVE-2021-40391",
    "cwe_list": [
      "CWE-787"
    ],
    "commit_hash": "672214abb47a802fc000125996e6e0a46c623a4e",
    "short_hash": "672214ab",
    "vulnerableMethods_before": [
      {
        "filename": "drill.c",
        "method_name": "vulnerable_function",
        "raw_code": "drill_parse_T_code(gerb_file_t *fd, drill_state_t *state,\n\t\t\tgerbv_image_t *image, ssize_t file_line)\n{\n    int tool_num;\n    gboolean done = FALSE;\n    int temp;\n    double size;\n    gerbv_drill_stats_t *stats = image->drill_stats;\n    gerbv_aperture_t *apert;\n    gchar *tmps;\n    gchar *string;\n\n    dprintf(\"---> entering %s()...\\n\", __FUNCTION__);\n\n    /* Sneak a peek at what's hiding after the 'T'. Ugly fix for\n       broken headers from Orcad, which is crap */\n    temp = gerb_fgetc(fd);\n    dprintf(\"  Found a char '%s' (0x%02x) after the T\\n\",\n\t    gerbv_escape_char(temp), temp);\n    \n    /* might be a tool tool change stop switch on/off*/\n    if((temp == 'C') && ((fd->ptr + 2) < fd->datalen)){\n    \tif(gerb_fgetc(fd) == 'S'){\n    \t    if (gerb_fgetc(fd) == 'T' ){\n    \t  \tfd->ptr -= 4;\n    \t  \ttmps = get_line(fd++);\n    \t  \tgerbv_stats_printf(stats->error_list, GERBV_MESSAGE_NOTE, -1,\n\t\t\t_(\"Tool change stop switch found \\\"%s\\\" \"\n\t\t\t    \"at line %ld in file \\\"%s\\\"\"),\n\t\t\ttmps, file_line, fd->filename);\n\t  \tg_free (tmps);\n\n\t  \treturn -1;\n\t    }\n\t    gerb_ungetc(fd);\n\t}\n\tgerb_ungetc(fd);\n    }\n\n    if( !(isdigit(temp) != 0 || temp == '+' || temp =='-') ) {\n\tif(temp != EOF) {\n\t    gerbv_stats_printf(stats->error_list, GERBV_MESSAGE_ERROR, -1,\n\t\t   _(\"OrCAD bug: Junk text found in place of tool definition\"));\n\t    tmps = get_line(fd);\n\t    gerbv_stats_printf(stats->error_list, GERBV_MESSAGE_WARNING, -1,\n\t\t    _(\"Junk text \\\"%s\\\" \"\n\t\t\t\"at line %ld in file \\\"%s\\\"\"),\n\t\t    tmps, file_line, fd->filename);\n\t    g_free (tmps);\n\t    gerbv_stats_printf(stats->error_list, GERBV_MESSAGE_WARNING, -1,\n\t\t\t\t  _(\"Ignoring junk text\"));\n\t}\n\treturn -1;\n    }\n    gerb_ungetc(fd);\n\n    tool_num = (int) gerb_fgetint(fd, NULL);\n    dprintf (\"  Handling tool T%d at line %ld\\n\", tool_num, file_line);\n\n    if (tool_num == 0) \n\treturn tool_num; /* T00 is a command to unload the drill */\n\n    if (tool_num < TOOL_MIN || tool_num >= TOOL_MAX) {\n\tgerbv_stats_printf(stats->error_list, GERBV_MESSAGE_ERROR, -1,\n\t\t_(\"Out of bounds drill number %d \"\n\t\t    \"at line %ld in file \\\"%s\\\"\"),\n\t\ttool_num, file_line, fd->filename);\n    }\n\n    /* Set the current tool to the correct one */\n    state->current_tool = tool_num;\n    apert = image->aperture[tool_num];\n\n    /* Check for a size definition */\n    temp = gerb_fgetc(fd);\n\n    /* This bit of code looks for a tool definition by scanning for strings\n     * of form TxxC, TxxF, TxxS.  */\n    while (!done) {\n\tswitch((char)temp) {\n\tcase 'C':\n\t    size = read_double(fd, state->header_number_format, GERBV_OMIT_ZEROS_TRAILING, state->decimals);\n\t    dprintf (\"  Read a size of %g\\n\", size);\n\n\t    if (state->unit == GERBV_UNIT_MM) {\n\t\tsize /= 25.4;\n\t    } else if(size >= 4.0) {\n\t\t/* If the drill size is >= 4 inches, assume that this\n\t\t   must be wrong and that the units are mils.\n\t\t   The limit being 4 inches is because the smallest drill\n\t\t   I've ever seen used is 0,3mm(about 12mil). Half of that\n\t\t   seemed a bit too small a margin, so a third it is */\n\n\t\tgerbv_stats_printf(stats->error_list, GERBV_MESSAGE_ERROR, -1,\n\t\t\t_(\"Read a drill of diameter %g inches \"\n\t\t\t    \"at line %ld in file \\\"%s\\\"\"),\n\t\t\t    size, file_line, fd->filename);\n\t\tgerbv_stats_printf(stats->error_list, GERBV_MESSAGE_WARNING, -1,\n\t\t\t_(\"Assuming units are mils\"));\n\t\tsize /= 1000.0;\n\t    }\n\n\t    if (size <= 0. || size >= 10000.) {\n\t\tgerbv_stats_printf(stats->error_list, GERBV_MESSAGE_ERROR, -1,\n\t\t\t_(\"Unreasonable drill size %g found for drill %d \"\n\t\t\t    \"at line %ld in file \\\"%s\\\"\"),\n\t\t\t    size, tool_num, file_line, fd->filename);\n\t    } else {\n\t\tif (apert != NULL) {\n\t\t    /* allow a redefine of a tool only if the new definition is exactly the same.\n\t\t     * This avoid lots of spurious complaints with the output of some cad\n\t\t     * tools while keeping complaints if there is a true problem\n\t\t     */\n\t\t    if (apert->parameter[0] != size\n\t\t    ||  apert->type != GERBV_APTYPE_CIRCLE\n\t\t    ||  apert->nuf_parameters != 1\n\t\t    ||  apert->unit != GERBV_UNIT_INCH) {\n\n\t\t\tgerbv_stats_printf(stats->error_list,\n\t\t\t\tGERBV_MESSAGE_ERROR, -1,\n\t\t\t\t_(\"Found redefinition of drill %d \"\n\t\t\t\t\"at line %ld in file \\\"%s\\\"\"),\n\t\t\t\ttool_num, file_line, fd->filename);\n\t\t    }\n\t\t} else {\n\t\t    apert = image->aperture[tool_num] =\n\t\t\t\t\t\tg_new0(gerbv_aperture_t, 1);\n\t\t    if (apert == NULL)\n\t\t\tGERB_FATAL_ERROR(\"malloc tool failed in %s()\",\n\t\t\t\t\t__FUNCTION__);\n\n\t\t    /* There's really no way of knowing what unit the tools\n\t\t       are defined in without sneaking a peek in the rest of\n\t\t       the file first. That's done in drill_guess_format() */\n\t\t    apert->parameter[0] = size;\n\t\t    apert->type = GERBV_APTYPE_CIRCLE;\n\t\t    apert->nuf_parameters = 1;\n\t\t    apert->unit = GERBV_UNIT_INCH;\n\t\t}\n\t    }\n\t    \n\t    /* Add the tool whose definition we just found into the list\n\t     * of tools for this layer used to generate statistics. */\n\t    stats = image->drill_stats;\n\t    string = g_strdup_printf(\"%s\", (state->unit == GERBV_UNIT_MM ? _(\"mm\") : _(\"inch\")));\n\t    drill_stats_add_to_drill_list(stats->drill_list, \n\t\t\t\t\t  tool_num, \n\t\t\t\t\t  state->unit == GERBV_UNIT_MM ? size*25.4 : size, \n\t\t\t\t\t  string);\n\t    g_free(string);\n\t    break;\n\n\tcase 'F':\n\tcase 'S' :\n\t    /* Silently ignored. They're not important. */\n\t    gerb_fgetint(fd, NULL);\n\t    break;\n\n\tdefault:\n\t    /* Stop when finding anything but what's expected\n\t       (and put it back) */\n\t    gerb_ungetc(fd);\n\t    done = TRUE;\n\t    break;\n\t}  /* switch((char)temp) */\n\n\ttemp = gerb_fgetc(fd);\n\tif (EOF == temp) {\n\t    gerbv_stats_printf(stats->error_list, GERBV_MESSAGE_ERROR, -1,\n\t\t    _(\"Unexpected EOF encountered in header of \"\n\t\t\t\"drill file \\\"%s\\\"\"), fd->filename);\n\n\t/* Restore new line character for processing */\n\tif ('\\n' == temp || '\\r' == temp)\n\t    gerb_ungetc(fd);\n\t}\n    }   /* while(!done) */  /* Done looking at tool definitions */\n\n    /* Catch the tools that aren't defined.\n       This isn't strictly a good thing, but at least something is shown */\n    if (apert == NULL) {\n        double dia;\n\n\tapert = image->aperture[tool_num] = g_new0(gerbv_aperture_t, 1);\n\tif (apert == NULL)\n\t    GERB_FATAL_ERROR(\"malloc tool failed in %s()\", __FUNCTION__);\n\n        /* See if we have the tool table */\n        dia = gerbv_get_tool_diameter(tool_num);\n        if (dia <= 0) {\n            /*\n             * There is no tool. So go out and make some.\n             * This size calculation is, of course, totally bogus.\n             */\n            dia = (double)(16 + 8 * tool_num) / 1000;\n            /*\n             * Oooh, this is sooo ugly. But some CAD systems seem to always\n             * use T00 at the end of the file while others that don't have\n             * tool definitions inside the file never seem to use T00 at all.\n             */\n            if (tool_num != 0) {\n\t\tgerbv_stats_printf(stats->error_list, GERBV_MESSAGE_ERROR, -1,\n\t\t\t_(\"Tool %02d used without being defined \"\n\t\t\t    \"at line %ld in file \\\"%s\\\"\"),\n\t\t\ttool_num, file_line, fd->filename);\n\t\tgerbv_stats_printf(stats->error_list, GERBV_MESSAGE_WARNING, -1,\n\t\t\t_(\"Setting a default size of %g\\\"\"), dia);\n            }\n\t}\n\n\tapert->type = GERBV_APTYPE_CIRCLE;\n\tapert->nuf_parameters = 1;\n\tapert->parameter[0] = dia;\n\n\t/* Add the tool whose definition we just found into the list\n\t * of tools for this layer used to generate statistics. */\n\tif (tool_num != 0) {  /* Only add non-zero tool nums.  \n\t\t\t       * Zero = unload command. */\n\t    stats = image->drill_stats;\n\t    string = g_strdup_printf(\"%s\", \n\t\t\t\t     (state->unit == GERBV_UNIT_MM ? _(\"mm\") : _(\"inch\")));\n\t    drill_stats_add_to_drill_list(stats->drill_list, \n\t\t\t\t\t  tool_num, \n\t\t\t\t\t  state->unit == GERBV_UNIT_MM ? dia*25.4 : dia,\n\t\t\t\t\t  string);\n\t    g_free(string);\n\t}\n    } /* if(image->aperture[tool_num] == NULL) */\t\n    \n    dprintf(\"<----  ...leaving %s()\\n\", __FUNCTION__);\n\n    return tool_num;\n} /* drill_parse_T_code() */",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "drill.c",
        "method_name": "fixed_function",
        "raw_code": "drill_parse_T_code(gerb_file_t *fd, drill_state_t *state,\n\t\t\tgerbv_image_t *image, ssize_t file_line)\n{\n    int tool_num;\n    gboolean done = FALSE;\n    int temp;\n    double size;\n    gerbv_drill_stats_t *stats = image->drill_stats;\n    gerbv_aperture_t *apert;\n    gchar *tmps;\n    gchar *string;\n\n    dprintf(\"---> entering %s()...\\n\", __FUNCTION__);\n\n    /* Sneak a peek at what's hiding after the 'T'. Ugly fix for\n       broken headers from Orcad, which is crap */\n    temp = gerb_fgetc(fd);\n    dprintf(\"  Found a char '%s' (0x%02x) after the T\\n\",\n\t    gerbv_escape_char(temp), temp);\n    \n    /* might be a tool tool change stop switch on/off*/\n    if((temp == 'C') && ((fd->ptr + 2) < fd->datalen)){\n    \tif(gerb_fgetc(fd) == 'S'){\n    \t    if (gerb_fgetc(fd) == 'T' ){\n    \t  \tfd->ptr -= 4;\n    \t  \ttmps = get_line(fd++);\n    \t  \tgerbv_stats_printf(stats->error_list, GERBV_MESSAGE_NOTE, -1,\n\t\t\t_(\"Tool change stop switch found \\\"%s\\\" \"\n\t\t\t    \"at line %ld in file \\\"%s\\\"\"),\n\t\t\ttmps, file_line, fd->filename);\n\t  \tg_free (tmps);\n\n\t  \treturn -1;\n\t    }\n\t    gerb_ungetc(fd);\n\t}\n\tgerb_ungetc(fd);\n    }\n\n    if( !(isdigit(temp) != 0 || temp == '+' || temp =='-') ) {\n\tif(temp != EOF) {\n\t    gerbv_stats_printf(stats->error_list, GERBV_MESSAGE_ERROR, -1,\n\t\t   _(\"OrCAD bug: Junk text found in place of tool definition\"));\n\t    tmps = get_line(fd);\n\t    gerbv_stats_printf(stats->error_list, GERBV_MESSAGE_WARNING, -1,\n\t\t    _(\"Junk text \\\"%s\\\" \"\n\t\t\t\"at line %ld in file \\\"%s\\\"\"),\n\t\t    tmps, file_line, fd->filename);\n\t    g_free (tmps);\n\t    gerbv_stats_printf(stats->error_list, GERBV_MESSAGE_WARNING, -1,\n\t\t\t\t  _(\"Ignoring junk text\"));\n\t}\n\treturn -1;\n    }\n    gerb_ungetc(fd);\n\n    tool_num = (int) gerb_fgetint(fd, NULL);\n    dprintf (\"  Handling tool T%d at line %ld\\n\", tool_num, file_line);\n\n    if (tool_num == 0) \n\treturn tool_num; /* T00 is a command to unload the drill */\n\n    if (tool_num < TOOL_MIN || tool_num >= TOOL_MAX) {\n\tgerbv_stats_printf(stats->error_list, GERBV_MESSAGE_ERROR, -1,\n\t\t_(\"Out of bounds drill number %d \"\n\t\t    \"at line %ld in file \\\"%s\\\"\"),\n\t\ttool_num, file_line, fd->filename);\n\treturn -1;\n    }\n\n    /* Set the current tool to the correct one */\n    state->current_tool = tool_num;\n    apert = image->aperture[tool_num];\n\n    /* Check for a size definition */\n    temp = gerb_fgetc(fd);\n\n    /* This bit of code looks for a tool definition by scanning for strings\n     * of form TxxC, TxxF, TxxS.  */\n    while (!done) {\n\tswitch((char)temp) {\n\tcase 'C':\n\t    size = read_double(fd, state->header_number_format, GERBV_OMIT_ZEROS_TRAILING, state->decimals);\n\t    dprintf (\"  Read a size of %g\\n\", size);\n\n\t    if (state->unit == GERBV_UNIT_MM) {\n\t\tsize /= 25.4;\n\t    } else if(size >= 4.0) {\n\t\t/* If the drill size is >= 4 inches, assume that this\n\t\t   must be wrong and that the units are mils.\n\t\t   The limit being 4 inches is because the smallest drill\n\t\t   I've ever seen used is 0,3mm(about 12mil). Half of that\n\t\t   seemed a bit too small a margin, so a third it is */\n\n\t\tgerbv_stats_printf(stats->error_list, GERBV_MESSAGE_ERROR, -1,\n\t\t\t_(\"Read a drill of diameter %g inches \"\n\t\t\t    \"at line %ld in file \\\"%s\\\"\"),\n\t\t\t    size, file_line, fd->filename);\n\t\tgerbv_stats_printf(stats->error_list, GERBV_MESSAGE_WARNING, -1,\n\t\t\t_(\"Assuming units are mils\"));\n\t\tsize /= 1000.0;\n\t    }\n\n\t    if (size <= 0. || size >= 10000.) {\n\t\tgerbv_stats_printf(stats->error_list, GERBV_MESSAGE_ERROR, -1,\n\t\t\t_(\"Unreasonable drill size %g found for drill %d \"\n\t\t\t    \"at line %ld in file \\\"%s\\\"\"),\n\t\t\t    size, tool_num, file_line, fd->filename);\n\t    } else {\n\t\tif (apert != NULL) {\n\t\t    /* allow a redefine of a tool only if the new definition is exactly the same.\n\t\t     * This avoid lots of spurious complaints with the output of some cad\n\t\t     * tools while keeping complaints if there is a true problem\n\t\t     */\n\t\t    if (apert->parameter[0] != size\n\t\t    ||  apert->type != GERBV_APTYPE_CIRCLE\n\t\t    ||  apert->nuf_parameters != 1\n\t\t    ||  apert->unit != GERBV_UNIT_INCH) {\n\n\t\t\tgerbv_stats_printf(stats->error_list,\n\t\t\t\tGERBV_MESSAGE_ERROR, -1,\n\t\t\t\t_(\"Found redefinition of drill %d \"\n\t\t\t\t\"at line %ld in file \\\"%s\\\"\"),\n\t\t\t\ttool_num, file_line, fd->filename);\n\t\t    }\n\t\t} else {\n\t\t    apert = image->aperture[tool_num] =\n\t\t\t\t\t\tg_new0(gerbv_aperture_t, 1);\n\t\t    if (apert == NULL)\n\t\t\tGERB_FATAL_ERROR(\"malloc tool failed in %s()\",\n\t\t\t\t\t__FUNCTION__);\n\n\t\t    /* There's really no way of knowing what unit the tools\n\t\t       are defined in without sneaking a peek in the rest of\n\t\t       the file first. That's done in drill_guess_format() */\n\t\t    apert->parameter[0] = size;\n\t\t    apert->type = GERBV_APTYPE_CIRCLE;\n\t\t    apert->nuf_parameters = 1;\n\t\t    apert->unit = GERBV_UNIT_INCH;\n\t\t}\n\t    }\n\t    \n\t    /* Add the tool whose definition we just found into the list\n\t     * of tools for this layer used to generate statistics. */\n\t    stats = image->drill_stats;\n\t    string = g_strdup_printf(\"%s\", (state->unit == GERBV_UNIT_MM ? _(\"mm\") : _(\"inch\")));\n\t    drill_stats_add_to_drill_list(stats->drill_list, \n\t\t\t\t\t  tool_num, \n\t\t\t\t\t  state->unit == GERBV_UNIT_MM ? size*25.4 : size, \n\t\t\t\t\t  string);\n\t    g_free(string);\n\t    break;\n\n\tcase 'F':\n\tcase 'S' :\n\t    /* Silently ignored. They're not important. */\n\t    gerb_fgetint(fd, NULL);\n\t    break;\n\n\tdefault:\n\t    /* Stop when finding anything but what's expected\n\t       (and put it back) */\n\t    gerb_ungetc(fd);\n\t    done = TRUE;\n\t    break;\n\t}  /* switch((char)temp) */\n\n\ttemp = gerb_fgetc(fd);\n\tif (EOF == temp) {\n\t    gerbv_stats_printf(stats->error_list, GERBV_MESSAGE_ERROR, -1,\n\t\t    _(\"Unexpected EOF encountered in header of \"\n\t\t\t\"drill file \\\"%s\\\"\"), fd->filename);\n\n\t/* Restore new line character for processing */\n\tif ('\\n' == temp || '\\r' == temp)\n\t    gerb_ungetc(fd);\n\t}\n    }   /* while(!done) */  /* Done looking at tool definitions */\n\n    /* Catch the tools that aren't defined.\n       This isn't strictly a good thing, but at least something is shown */\n    if (apert == NULL) {\n        double dia;\n\n\tapert = image->aperture[tool_num] = g_new0(gerbv_aperture_t, 1);\n\tif (apert == NULL)\n\t    GERB_FATAL_ERROR(\"malloc tool failed in %s()\", __FUNCTION__);\n\n        /* See if we have the tool table */\n        dia = gerbv_get_tool_diameter(tool_num);\n        if (dia <= 0) {\n            /*\n             * There is no tool. So go out and make some.\n             * This size calculation is, of course, totally bogus.\n             */\n            dia = (double)(16 + 8 * tool_num) / 1000;\n            /*\n             * Oooh, this is sooo ugly. But some CAD systems seem to always\n             * use T00 at the end of the file while others that don't have\n             * tool definitions inside the file never seem to use T00 at all.\n             */\n            if (tool_num != 0) {\n\t\tgerbv_stats_printf(stats->error_list, GERBV_MESSAGE_ERROR, -1,\n\t\t\t_(\"Tool %02d used without being defined \"\n\t\t\t    \"at line %ld in file \\\"%s\\\"\"),\n\t\t\ttool_num, file_line, fd->filename);\n\t\tgerbv_stats_printf(stats->error_list, GERBV_MESSAGE_WARNING, -1,\n\t\t\t_(\"Setting a default size of %g\\\"\"), dia);\n            }\n\t}\n\n\tapert->type = GERBV_APTYPE_CIRCLE;\n\tapert->nuf_parameters = 1;\n\tapert->parameter[0] = dia;\n\n\t/* Add the tool whose definition we just found into the list\n\t * of tools for this layer used to generate statistics. */\n\tif (tool_num != 0) {  /* Only add non-zero tool nums.  \n\t\t\t       * Zero = unload command. */\n\t    stats = image->drill_stats;\n\t    string = g_strdup_printf(\"%s\", \n\t\t\t\t     (state->unit == GERBV_UNIT_MM ? _(\"mm\") : _(\"inch\")));\n\t    drill_stats_add_to_drill_list(stats->drill_list, \n\t\t\t\t\t  tool_num, \n\t\t\t\t\t  state->unit == GERBV_UNIT_MM ? dia*25.4 : dia,\n\t\t\t\t\t  string);\n\t    g_free(string);\n\t}\n    } /* if(image->aperture[tool_num] == NULL) */\t\n    \n    dprintf(\"<----  ...leaving %s()\\n\", __FUNCTION__);\n\n    return tool_num;\n} /* drill_parse_T_code() */",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <ctype.h>\n#include <stdlib.h>\n#include \"gerbv.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <math.h>\n#include <string.h>\n#include \"drill.h\"\n#include \"drill_stats.h\"\n#include \"common.h\"\n#include \"attribute.h\"\n#include <sys/stat.h>\n\n// Type Definitions:\n// gerb_file_t:\ntypedef struct file {\n    FILE *fd;     /* File descriptor */\n    int   fileno; /* The integer version of fd */\n    char *data;   /* Pointer to data mmaped in. May not be changed, use ptr */\n    int   datalen;/* Length of mmaped data ie file length */\n    int   ptr;    /* Index in data where we are reading */\n    char *filename;  /* File name */\n} gerb_file_t;\n\n// Called Methods (top 10):\n// gerbv_escape_char_return_int from src/gerb_stats.c:\nint\ngerbv_escape_char_return_int(char c)\n{\n\tint i = 0;\n\tchar *ec = (char *)&i;\n\n\tec[0] = '\\\\';\n\n\tswitch (c) {\n\tcase '\\0':\n\t\tec[1] = '0';\n\t\tbreak;\n\tcase '\\a':\n\t\tec[1] = 'a';\n\t\tbreak;\n\tcase '\\b':\n\t\tec[1] = 'b';\n\t\tbreak;\n\tcase '\\f':\n\t\tec[1] = 'f';\n\t\tbreak;\n\tcase '\\n':\n\t\tec[1] = 'n';\n\t\tbreak;\n\tcase '\\r':\n\t\tec[1] = 'r';\n\t\tbreak;\n\tcase '\\t':\n\t\tec[1] = 't';\n\t\tbreak;\n\tcase '\\v':\n\t\tec[1] = 'v';\n\t\tbreak;\n\tcase '\\\\':\n\t\tec[1] = '\\\\';\n\t\tbreak;\n\tcase '\"':\n\t\tec[1] = '\"';\n\t\tbreak;\n\tdefault:\n\t\tec[0] = c;\n\t}\n\n\treturn i;\n}\n\n// TOOL_MAX from src/drill.h:\n<empty>\n\n// gerbv_escape_char from src/gerb_stats.h:\n<empty>\n\n// gerb_fgetc from src/gerb_file.c:\nint\ngerb_fgetc(gerb_file_t *fd)\n{\n\n    if (fd->ptr >= fd->datalen)\n\treturn EOF;\n\n    return (int) fd->data[fd->ptr++];\n}\n\n// gerb_fgetint from src/gerb_file.c:\nint\ngerb_fgetint(gerb_file_t *fd, int *len)\n{\n    long int result;\n    char *end;\n    \n    errno = 0;\n    result = strtol(fd->data + fd->ptr, &end, 10);\n    if (errno) {\n\tGERB_COMPILE_ERROR(_(\"Failed to read integer\"));\n\treturn 0;\n    }\n\n    if (len) {\n\t*len = end - (fd->data + fd->ptr);\n    }\n\n    fd->ptr = end - fd->data;\n\n    if (len && (result < 0))\n\t*len -= 1;\n\n    return (int)result;\n}\n\n// TOOL_MIN from src/drill.h:\n<empty>\n\n// dprintf from src/drill.c:\n<empty>\n"
  },
  {
    "repository": "php-src",
    "cve_id": "CVE-2014-9426",
    "cwe_list": [
      "CWE-17"
    ],
    "commit_hash": "a72cd07f2983dc43a6bb35209dc4687852e53c09",
    "short_hash": "a72cd07f",
    "vulnerableMethods_before": [
      {
        "filename": "apprentice.c",
        "method_name": "vulnerable_function",
        "raw_code": "apprentice_load(struct magic_set *ms, const char *fn, int action)\n{\n\tint errs = 0;\n\tuint32_t i, j;\n\tsize_t files = 0, maxfiles = 0;\n\tchar **filearr = NULL;\n\tstruct stat st;\n\tstruct magic_map *map;\n\tstruct magic_entry_set mset[MAGIC_SETS];\n\tphp_stream *dir;\n\tphp_stream_dirent d;\n \n\tTSRMLS_FETCH();\n\n\tmemset(mset, 0, sizeof(mset));\n\tms->flags |= MAGIC_CHECK;\t/* Enable checks for parsed files */\n\n\n\tif ((map = CAST(struct magic_map *, ecalloc(1, sizeof(*map)))) == NULL)\n\t{\n\t\tfile_oomem(ms, sizeof(*map));\n\t\treturn NULL;\n\t}\n\n\t/* print silly verbose header for USG compat. */\n\tif (action == FILE_CHECK)\n\t\t(void)fprintf(stderr, \"%s\\n\", usg_hdr);\n\n\t/* load directory or file */\n\t/* FIXME: Read file names and sort them to prevent\n\t   non-determinism. See Debian bug #488562. */\n\tif (php_sys_stat(fn, &st) == 0 && S_ISDIR(st.st_mode)) {\n\t\tint mflen;\n\t\tchar mfn[MAXPATHLEN];\n\n\t\tdir = php_stream_opendir((char *)fn, REPORT_ERRORS, NULL);\n\t\tif (!dir) {\n\t\t\terrs++;\n\t\t\tgoto out;\n\t\t}\n\t\twhile (php_stream_readdir(dir, &d)) {\n\t\t\tif ((mflen = snprintf(mfn, sizeof(mfn), \"%s/%s\", fn, d.d_name)) < 0) {\n\t\t\t\tfile_oomem(ms,\n\t\t\t\tstrlen(fn) + strlen(d.d_name) + 2);\n\t\t\t\terrs++;\n\t\t\t\tphp_stream_closedir(dir);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (stat(mfn, &st) == -1 || !S_ISREG(st.st_mode)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (files >= maxfiles) {\n\t\t\t\tsize_t mlen;\n\t\t\t\tmaxfiles = (maxfiles + 1) * 2;\n\t\t\t\tmlen = maxfiles * sizeof(*filearr);\n\t\t\t\tif ((filearr = CAST(char **,\n\t\t\t\t    erealloc(filearr, mlen))) == NULL) {\n\t\t\t\t\tfile_oomem(ms, mlen);\n\t\t\t\t\tefree(mfn);\n\t\t\t\t\tphp_stream_closedir(dir);\n\t\t\t\t\terrs++;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfilearr[files++] = estrndup(mfn, (mflen > sizeof(mfn) - 1)? sizeof(mfn) - 1: mflen);\n\t\t}\n\t\tphp_stream_closedir(dir);\n\t\tqsort(filearr, files, sizeof(*filearr), cmpstrp);\n\t\tfor (i = 0; i < files; i++) {\n\t\t\tload_1(ms, action, filearr[i], &errs, mset);\n\t\t\tefree(filearr[i]);\n\t\t}\n\t\tefree(filearr);\n\t} else\n\t\tload_1(ms, action, fn, &errs, mset);\n\tif (errs)\n\t\tgoto out;\n\n\tfor (j = 0; j < MAGIC_SETS; j++) {\n\t\t/* Set types of tests */\n\t\tfor (i = 0; i < mset[j].count; ) {\n\t\t\tif (mset[j].me[i].mp->cont_level != 0) {\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti = set_text_binary(ms, mset[j].me, mset[j].count, i);\n\t\t}\n\t\tqsort(mset[j].me, mset[j].count, sizeof(*mset[j].me),\n\t\t    apprentice_sort);\n\n\t\t/*\n\t\t * Make sure that any level 0 \"default\" line is last\n\t\t * (if one exists).\n\t\t */\n\t\tset_last_default(ms, mset[j].me, mset[j].count);\n\n\t\t/* coalesce per file arrays into a single one */\n\t\tif (coalesce_entries(ms, mset[j].me, mset[j].count,\n\t\t    &map->magic[j], &map->nmagic[j]) == -1) {\n\t\t\terrs++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfor (j = 0; j < MAGIC_SETS; j++)\n\t\tmagic_entry_free(mset[j].me, mset[j].count);\n\n\tif (errs) {\n\t\tfor (j = 0; j < MAGIC_SETS; j++) {\n\t\t\tif (map->magic[j])\n\t\t\t\tefree(map->magic[j]);\n\t\t}\n\t\tefree(map);\n\t\treturn NULL;\n\t}\n\treturn map;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "apprentice.c",
        "method_name": "fixed_function",
        "raw_code": "apprentice_load(struct magic_set *ms, const char *fn, int action)\n{\n\tint errs = 0;\n\tuint32_t i, j;\n\tsize_t files = 0, maxfiles = 0;\n\tchar **filearr = NULL;\n\tstruct stat st;\n\tstruct magic_map *map;\n\tstruct magic_entry_set mset[MAGIC_SETS];\n\tphp_stream *dir;\n\tphp_stream_dirent d;\n \n\tTSRMLS_FETCH();\n\n\tmemset(mset, 0, sizeof(mset));\n\tms->flags |= MAGIC_CHECK;\t/* Enable checks for parsed files */\n\n\n\tif ((map = CAST(struct magic_map *, ecalloc(1, sizeof(*map)))) == NULL)\n\t{\n\t\tfile_oomem(ms, sizeof(*map));\n\t\treturn NULL;\n\t}\n\n\t/* print silly verbose header for USG compat. */\n\tif (action == FILE_CHECK)\n\t\t(void)fprintf(stderr, \"%s\\n\", usg_hdr);\n\n\t/* load directory or file */\n\t/* FIXME: Read file names and sort them to prevent\n\t   non-determinism. See Debian bug #488562. */\n\tif (php_sys_stat(fn, &st) == 0 && S_ISDIR(st.st_mode)) {\n\t\tint mflen;\n\t\tchar mfn[MAXPATHLEN];\n\n\t\tdir = php_stream_opendir((char *)fn, REPORT_ERRORS, NULL);\n\t\tif (!dir) {\n\t\t\terrs++;\n\t\t\tgoto out;\n\t\t}\n\t\twhile (php_stream_readdir(dir, &d)) {\n\t\t\tif ((mflen = snprintf(mfn, sizeof(mfn), \"%s/%s\", fn, d.d_name)) < 0) {\n\t\t\t\tfile_oomem(ms,\n\t\t\t\tstrlen(fn) + strlen(d.d_name) + 2);\n\t\t\t\terrs++;\n\t\t\t\tphp_stream_closedir(dir);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (stat(mfn, &st) == -1 || !S_ISREG(st.st_mode)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (files >= maxfiles) {\n\t\t\t\tsize_t mlen;\n\t\t\t\tmaxfiles = (maxfiles + 1) * 2;\n\t\t\t\tmlen = maxfiles * sizeof(*filearr);\n\t\t\t\tif ((filearr = CAST(char **,\n\t\t\t\t    erealloc(filearr, mlen))) == NULL) {\n\t\t\t\t\tfile_oomem(ms, mlen);\n\t\t\t\t\tphp_stream_closedir(dir);\n\t\t\t\t\terrs++;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfilearr[files++] = estrndup(mfn, (mflen > sizeof(mfn) - 1)? sizeof(mfn) - 1: mflen);\n\t\t}\n\t\tphp_stream_closedir(dir);\n\t\tqsort(filearr, files, sizeof(*filearr), cmpstrp);\n\t\tfor (i = 0; i < files; i++) {\n\t\t\tload_1(ms, action, filearr[i], &errs, mset);\n\t\t\tefree(filearr[i]);\n\t\t}\n\t\tefree(filearr);\n\t} else\n\t\tload_1(ms, action, fn, &errs, mset);\n\tif (errs)\n\t\tgoto out;\n\n\tfor (j = 0; j < MAGIC_SETS; j++) {\n\t\t/* Set types of tests */\n\t\tfor (i = 0; i < mset[j].count; ) {\n\t\t\tif (mset[j].me[i].mp->cont_level != 0) {\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti = set_text_binary(ms, mset[j].me, mset[j].count, i);\n\t\t}\n\t\tqsort(mset[j].me, mset[j].count, sizeof(*mset[j].me),\n\t\t    apprentice_sort);\n\n\t\t/*\n\t\t * Make sure that any level 0 \"default\" line is last\n\t\t * (if one exists).\n\t\t */\n\t\tset_last_default(ms, mset[j].me, mset[j].count);\n\n\t\t/* coalesce per file arrays into a single one */\n\t\tif (coalesce_entries(ms, mset[j].me, mset[j].count,\n\t\t    &map->magic[j], &map->nmagic[j]) == -1) {\n\t\t\terrs++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tfor (j = 0; j < MAGIC_SETS; j++)\n\t\tmagic_entry_free(mset[j].me, mset[j].count);\n\n\tif (errs) {\n\t\tfor (j = 0; j < MAGIC_SETS; j++) {\n\t\t\tif (map->magic[j])\n\t\t\t\tefree(map->magic[j]);\n\t\t}\n\t\tefree(map);\n\t\treturn NULL;\n\t}\n\treturn map;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <assert.h>\n#include <fcntl.h>\n#include \"win32/unistd.h\"\n#include <string.h>\n#include \"patchlevel.h\"\n#include <stdlib.h>\n# include \"win32/php_strtoi64.h\"\n#include \"magic.h\"\n#include \"php.h\"\n#include <ctype.h>\n#include <unistd.h>\n#include \"../data_file.c\"\n#include \"file.h\"\n\n// Type Definitions:\n// _php_stream_dirent:\ntypedef struct _php_stream_dirent {\n\tchar d_name[MAXPATHLEN];\n}\n\n// php_stream:\ntypedef struct _php_stream php_stream;\n\n// php_stream_dirent:\ntypedef struct _php_stream_dirent {\n\tchar d_name[MAXPATHLEN];\n} php_stream_dirent;\n\n// stat:\nstruct stat\n\n// magic_map:\nstruct magic_map {\n\tvoid *p;\n\tsize_t len;\n\tstruct magic *magic[MAGIC_SETS];\n\tuint32_t nmagic[MAGIC_SETS];\n}\n\n// Called Methods (top 10):\n// _php_stream_read from main/streams/streams.c:\nPHPAPI size_t _php_stream_read(php_stream *stream, char *buf, size_t size TSRMLS_DC) /* <=== _php_stream_read */ \n{\n\tsize_t toread = 0, didread = 0;\n\n\twhile (size > 0) {\n\n\t\t/* take from the read buffer first.\n\t\t * It is possible that a buffered stream was switched to non-buffered, so we\n\t\t * drain the remainder of the buffer before using the \"raw\" read mode for\n\t\t * the excess */\n\t\tif (stream->writepos > stream->readpos) {\n\n\t\t\ttoread = stream->writepos - stream->readpos;\n\t\t\tif (toread > size) {\n\t\t\t\ttoread = size;\n\t\t\t}\n\n\t\t\tmemcpy(buf, stream->readbuf + stream->readpos, toread);\n\t\t\tstream->readpos += toread;\n\t\t\tsize -= toread;\n\t\t\tbuf += toread;\n\t\t\tdidread += toread;\n\t\t}\n\n\t\t/* ignore eof here; the underlying state might have changed */\n\t\tif (size == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!stream->readfilters.head && (stream->flags & PHP_STREAM_FLAG_NO_BUFFER || stream->chunk_size == 1)) {\n\t\t\ttoread = stream->ops->read(stream, buf, size TSRMLS_CC);\n\t\t\tif (toread == (size_t) -1) {\n\t\t\t\t/* e.g. underlying read(2) returned -1 */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tphp_stream_fill_read_buffer(stream, size TSRMLS_CC);\n\n\t\t\ttoread = stream->writepos - stream->readpos;\n\t\t\tif (toread > size) {\n\t\t\t\ttoread = size;\n\t\t\t}\n\n\t\t\tif (toread > 0) {\n\t\t\t\tmemcpy(buf, stream->readbuf + stream->readpos, toread);\n\t\t\t\tstream->readpos += toread;\n\t\t\t}\n\t\t}\n\t\tif (toread > 0) {\n\t\t\tdidread += toread;\n\t\t\tbuf += toread;\n\t\t\tsize -= toread;\n\t\t} else {\n\t\t\t/* EOF, or temporary end of data (for non-blocking mode). */\n\t\t\tbreak;\n\t\t}\n\n\t\t/* just break anyway, to avoid greedy read */\n\t\tif (stream->wrapper != &php_plain_files_wrapper) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (didread > 0) {\n\t\tstream->position += didread;\n\t}\n\n\treturn didread;\n}\n\n// ZEND_MM_BLOCK from Zend/zend_alloc.c:\n#define ZEND_MM_BLOCK(b, type, size)\tdo { \\ /* <=== Zend/zend_alloc.c:502:507:ZEND_MM_BLOCK:3 */ \n\t\t\t\t\t\t\t\t\t\t\tsize_t _size = (size); \\\n\t\t\t\t\t\t\t\t\t\t\t(b)->info._size = (type) | _size; \\\n\t\t\t\t\t\t\t\t\t\t\tZEND_MM_BLOCK_AT(b, _size)->info._prev = (type) | _size; \\\n\t\t\t\t\t\t\t\t\t\t\tZEND_MM_SET_COOKIE(b); \\\n\t\t\t\t\t\t\t\t\t\t} while (0);\n\n// HANDLE_UNBLOCK_INTERRUPTIONS from Zend/zend.h:\n#define HANDLE_UNBLOCK_INTERRUPTIONS()\t\tif (zend_unblock_interruptions) { zend_unblock_interruptions(); } /* <=== Zend/zend.h:727:727:HANDLE_UNBLOCK_INTERRUPTIONS:0 */ \n\n// ZEND_MM_PREV_BLOCK from Zend/zend_alloc.c:\n#define ZEND_MM_PREV_BLOCK(b)\t\t\tZEND_MM_BLOCK_AT(b, -(ssize_t)((b)->info._prev & ~ZEND_MM_TYPE_MASK)) /* <=== Zend/zend_alloc.c:518:518:ZEND_MM_PREV_BLOCK:1 */ \n\n// ZEND_MM_BLOCK_AT from Zend/zend_alloc.c:\n#define ZEND_MM_BLOCK_AT(blk, offset)\t((zend_mm_block *) (((char *) (blk))+(offset))) /* <=== Zend/zend_alloc.c:546:546:ZEND_MM_BLOCK_AT:2 */ \n\n// UNEXPECTED from Zend/zend.h:\n# define UNEXPECTED(condition) (condition) /* <=== Zend/zend.h:395:395:UNEXPECTED:1 */ \n\n// ZEND_MM_IS_GUARD_BLOCK from Zend/zend_alloc.c:\n#define ZEND_MM_IS_GUARD_BLOCK(b)\t\t(((b)->info._size & ZEND_MM_TYPE_MASK) == ZEND_MM_GUARD_BLOCK) /* <=== Zend/zend_alloc.c:515:515:ZEND_MM_IS_GUARD_BLOCK:1 */ \n\n// php_stream_readdir from ext/fileinfo/libmagic/php_streams.h:\n<empty>\n\n// _efree from Zend/zend_alloc.c:\nvoid _efree(void *ptr ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC)\n{\n\tTSRMLS_FETCH();\n\n\tif (UNEXPECTED(!AG(mm_heap)->use_zend_alloc)) {\n\t\tAG(mm_heap)->_free(ptr);\n\t\treturn;\n\t}\n\t_zend_mm_free_int(AG(mm_heap), ptr ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);\n}\n\n// php_stream_fill_read_buffer from main/streams/streams.c:\nstatic void php_stream_fill_read_buffer(php_stream *stream, size_t size TSRMLS_DC) /* <=== php_stream_fill_read_buffer */ \n{\n\t/* allocate/fill the buffer */\n\n\tif (stream->readfilters.head) {\n\t\tchar *chunk_buf;\n\t\tint err_flag = 0;\n\t\tphp_stream_bucket_brigade brig_in = { NULL, NULL }, brig_out = { NULL, NULL };\n\t\tphp_stream_bucket_brigade *brig_inp = &brig_in, *brig_outp = &brig_out, *brig_swap;\n\n\t\t/* Invalidate the existing cache, otherwise reads can fail, see note in\n\t\t   main/streams/filter.c::_php_stream_filter_append */\n\t\tstream->writepos = stream->readpos = 0;\n\n\t\t/* allocate a buffer for reading chunks */\n\t\tchunk_buf = emalloc(stream->chunk_size);\n\n\t\twhile (!stream->eof && !err_flag && (stream->writepos - stream->readpos < (off_t)size)) {\n\t\t\tsize_t justread = 0;\n\t\t\tint flags;\n\t\t\tphp_stream_bucket *bucket;\n\t\t\tphp_stream_filter_status_t status = PSFS_ERR_FATAL;\n\t\t\tphp_stream_filter *filter;\n\n\t\t\t/* read a chunk into a bucket */\n\t\t\tjustread = stream->ops->read(stream, chunk_buf, stream->chunk_size TSRMLS_CC);\n\t\t\tif (justread && justread != (size_t)-1) {\n\t\t\t\tbucket = php_stream_bucket_new(stream, chunk_buf, justread, 0, 0 TSRMLS_CC);\n\n\t\t\t\t/* after this call, bucket is owned by the brigade */\n\t\t\t\tphp_stream_bucket_append(brig_inp, bucket TSRMLS_CC);\n\n\t\t\t\tflags = PSFS_FLAG_NORMAL;\n\t\t\t} else {\n\t\t\t\tflags = stream->eof ? PSFS_FLAG_FLUSH_CLOSE : PSFS_FLAG_FLUSH_INC;\n\t\t\t}\n\n\t\t\t/* wind the handle... */\n\t\t\tfor (filter = stream->readfilters.head; filter; filter = filter->next) {\n\t\t\t\tstatus = filter->fops->filter(stream, filter, brig_inp, brig_outp, NULL, flags TSRMLS_CC);\n\n\t\t\t\tif (status != PSFS_PASS_ON) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* brig_out becomes brig_in.\n\t\t\t\t * brig_in will always be empty here, as the filter MUST attach any un-consumed buckets\n\t\t\t\t * to its own brigade */\n\t\t\t\tbrig_swap = brig_inp;\n\t\t\t\tbrig_inp = brig_outp;\n\t\t\t\tbrig_outp = brig_swap;\n\t\t\t\tmemset(brig_outp, 0, sizeof(*brig_outp));\n\t\t\t}\n\n\t\t\tswitch (status) {\n\t\t\t\tcase PSFS_PASS_ON:\n\t\t\t\t\t/* we get here when the last filter in the chain has data to pass on.\n\t\t\t\t\t * in this situation, we are passing the brig_in brigade into the\n\t\t\t\t\t * stream read buffer */\n\t\t\t\t\twhile (brig_inp->head) {\n\t\t\t\t\t\tbucket = brig_inp->head;\n\t\t\t\t\t\t/* grow buffer to hold this bucket\n\t\t\t\t\t\t * TODO: this can fail for persistent streams */\n\t\t\t\t\t\tif (stream->readbuflen - stream->writepos < bucket->buflen) {\n\t\t\t\t\t\t\tstream->readbuflen += bucket->buflen;\n\t\t\t\t\t\t\tstream->readbuf = perealloc(stream->readbuf, stream->readbuflen,\n\t\t\t\t\t\t\t\t\tstream->is_persistent);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemcpy(stream->readbuf + stream->writepos, bucket->buf, bucket->buflen);\n\t\t\t\t\t\tstream->writepos += bucket->buflen;\n\n\t\t\t\t\t\tphp_stream_bucket_unlink(bucket TSRMLS_CC);\n\t\t\t\t\t\tphp_stream_bucket_delref(bucket TSRMLS_CC);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PSFS_FEED_ME:\n\t\t\t\t\t/* when a filter needs feeding, there is no brig_out to deal with.\n\t\t\t\t\t * we simply continue the loop; if the caller needs more data,\n\t\t\t\t\t * we will read again, otherwise out job is done here */\n\t\t\t\t\tif (justread == 0) {\n\t\t\t\t\t\t/* there is no data */\n\t\t\t\t\t\terr_flag = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcase PSFS_ERR_FATAL:\n\t\t\t\t\t/* some fatal error. Theoretically, the stream is borked, so all\n\t\t\t\t\t * further reads should fail. */\n\t\t\t\t\terr_flag = 1;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (justread == 0 || justread == (size_t)-1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tefree(chunk_buf);\n\n\t} else {\n\t\t/* is there enough data in the buffer ? */\n\t\tif (stream->writepos - stream->readpos < (off_t)size) {\n\t\t\tsize_t justread = 0;\n\n\t\t\t/* reduce buffer memory consumption if possible, to avoid a realloc */\n\t\t\tif (stream->readbuf && stream->readbuflen - stream->writepos < stream->chunk_size) {\n\t\t\t\tmemmove(stream->readbuf, stream->readbuf + stream->readpos, stream->readbuflen - stream->readpos);\n\t\t\t\tstream->writepos -= stream->readpos;\n\t\t\t\tstream->readpos = 0;\n\t\t\t}\n\n\t\t\t/* grow the buffer if required\n\t\t\t * TODO: this can fail for persistent streams */\n\t\t\tif (stream->readbuflen - stream->writepos < stream->chunk_size) {\n\t\t\t\tstream->readbuflen += stream->chunk_size;\n\t\t\t\tstream->readbuf = perealloc(stream->readbuf, stream->readbuflen,\n\t\t\t\t\t\tstream->is_persistent);\n\t\t\t}\n\n\t\t\tjustread = stream->ops->read(stream, stream->readbuf + stream->writepos,\n\t\t\t\t\tstream->readbuflen - stream->writepos\n\t\t\t\t\tTSRMLS_CC);\n\n\t\t\tif (justread != (size_t)-1) {\n\t\t\t\tstream->writepos += justread;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "repository": "admesh",
    "cve_id": "CVE-2018-25033",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "e84d8353f1347e1f26f0a95770d92ba14e6ede38",
    "short_hash": "e84d8353",
    "vulnerableMethods_before": [
      {
        "filename": "connect.c",
        "method_name": "vulnerable_function",
        "raw_code": "stl_update_connects_remove_1(stl_file *stl, int facet_num) {\n  int j;\n\n  if (stl->error) return;\n  /* Update list of connected edges */\n  j = ((stl->neighbors_start[facet_num].neighbor[0] == -1) +\n       (stl->neighbors_start[facet_num].neighbor[1] == -1) +\n       (stl->neighbors_start[facet_num].neighbor[2] == -1));\n  if(j == 0) {\t\t       /* Facet has 3 neighbors */\n    stl->stats.connected_facets_3_edge -= 1;\n  } else if(j == 1) {\t     /* Facet has 2 neighbors */\n    stl->stats.connected_facets_2_edge -= 1;\n  } else if(j == 2) {\t     /* Facet has 1 neighbor  */\n    stl->stats.connected_facets_1_edge -= 1;\n  }\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "connect.c",
        "method_name": "fixed_function",
        "raw_code": "stl_update_connects_remove_1(stl_file *stl, int facet_num) {\n  int j;\n\n  if (\n    stl->error ||\n    facet_num < 0\n  ) return;\n\n  /* Update list of connected edges */\n  j = ((stl->neighbors_start[facet_num].neighbor[0] == -1) +\n       (stl->neighbors_start[facet_num].neighbor[1] == -1) +\n       (stl->neighbors_start[facet_num].neighbor[2] == -1));\n  if(j == 0) {\t\t       /* Facet has 3 neighbors */\n    stl->stats.connected_facets_3_edge -= 1;\n  } else if(j == 1) {\t     /* Facet has 2 neighbors */\n    stl->stats.connected_facets_2_edge -= 1;\n  } else if(j == 2) {\t     /* Facet has 1 neighbor  */\n    stl->stats.connected_facets_1_edge -= 1;\n  }\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <math.h>\n#include \"stl.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Type Definitions:\n// stl_vertex:\ntypedef struct {\n  float x;\n  float y;\n  float z;\n}\n\n// stl_file:\ntypedef struct {\n  FILE          *fp;\n  stl_facet     *facet_start;\n  stl_edge      *edge_start;\n  stl_hash_edge **heads;\n  stl_hash_edge *tail;\n  int           M;\n  stl_neighbors *neighbors_start;\n  v_indices_struct *v_indices;\n  stl_vertex    *v_shared;\n  stl_stats     stats;\n  char          error;\n}\n\n// Called Methods (top 10):\n// stl_update_connects_remove_1 from src/connect.c:\nvoid /* <=== stl_update_connects_remove_1 */ \nstl_update_connects_remove_1(stl_file *stl, int facet_num) {\n  int j;\n\n  if (\n    stl->error ||\n    facet_num < 0\n  ) return;\n\n  /* Update list of connected edges */\n  j = ((stl->neighbors_start[facet_num].neighbor[0] == -1) +\n       (stl->neighbors_start[facet_num].neighbor[1] == -1) +\n       (stl->neighbors_start[facet_num].neighbor[2] == -1));\n  if(j == 0) {\t\t       /* Facet has 3 neighbors */\n    stl->stats.connected_facets_3_edge -= 1;\n  } else if(j == 1) {\t     /* Facet has 2 neighbors */\n    stl->stats.connected_facets_2_edge -= 1;\n  } else if(j == 2) {\t     /* Facet has 1 neighbor  */\n    stl->stats.connected_facets_1_edge -= 1;\n  }\n}\n\n// stl_remove_facet from src/connect.c:\nstatic void /* <=== stl_remove_facet */ \nstl_remove_facet(stl_file *stl, int facet_number) {\n  int neighbor[3];\n  int vnot[3];\n  int i;\n  int j;\n\n  if (stl->error) return;\n\n  stl->stats.facets_removed += 1;\n  /* Update list of connected edges */\n  j = ((stl->neighbors_start[facet_number].neighbor[0] == -1) +\n       (stl->neighbors_start[facet_number].neighbor[1] == -1) +\n       (stl->neighbors_start[facet_number].neighbor[2] == -1));\n  if(j == 2) {\n    stl->stats.connected_facets_1_edge -= 1;\n  } else if(j == 1) {\n    stl->stats.connected_facets_2_edge -= 1;\n    stl->stats.connected_facets_1_edge -= 1;\n  } else if(j == 0) {\n    stl->stats.connected_facets_3_edge -= 1;\n    stl->stats.connected_facets_2_edge -= 1;\n    stl->stats.connected_facets_1_edge -= 1;\n  }\n\n  stl->facet_start[facet_number] =\n    stl->facet_start[stl->stats.number_of_facets - 1];\n  /* I could reallocate at this point, but it is not really necessary. */\n  stl->neighbors_start[facet_number] =\n    stl->neighbors_start[stl->stats.number_of_facets - 1];\n  stl->stats.number_of_facets -= 1;\n\n  for(i = 0; i < 3; i++) {\n    neighbor[i] = stl->neighbors_start[facet_number].neighbor[i];\n    vnot[i] = stl->neighbors_start[facet_number].which_vertex_not[i];\n  }\n\n  for(i = 0; i < 3; i++) {\n    if(neighbor[i] != -1) {\n      if(stl->neighbors_start[neighbor[i]].neighbor[(vnot[i] + 1)% 3] !=\n          stl->stats.number_of_facets) {\n        printf(\"\\\nin stl_remove_facet: neighbor = %d numfacets = %d this is wrong\\n\",\n               stl->neighbors_start[neighbor[i]].neighbor[(vnot[i] + 1)% 3],\n               stl->stats.number_of_facets);\n        return;\n      }\n      stl->neighbors_start[neighbor[i]].neighbor[(vnot[i] + 1)% 3]\n        = facet_number;\n    }\n  }\n}\n\n// stl_update_connects_remove_1 from src/connect.c:\nvoid /* <=== stl_update_connects_remove_1 */ \nstl_update_connects_remove_1(stl_file *stl, int facet_num) {\n  int j;\n\n  if (stl->error) return;\n  /* Update list of connected edges */\n  j = ((stl->neighbors_start[facet_num].neighbor[0] == -1) +\n       (stl->neighbors_start[facet_num].neighbor[1] == -1) +\n       (stl->neighbors_start[facet_num].neighbor[2] == -1));\n  if(j == 0) {\t\t       /* Facet has 3 neighbors */\n    stl->stats.connected_facets_3_edge -= 1;\n  } else if(j == 1) {\t     /* Facet has 2 neighbors */\n    stl->stats.connected_facets_2_edge -= 1;\n  } else if(j == 2) {\t     /* Facet has 1 neighbor  */\n    stl->stats.connected_facets_1_edge -= 1;\n  }\n}\n"
  },
  {
    "repository": "tensorflow",
    "cve_id": "CVE-2021-37665",
    "cwe_list": [
      "CWE-703"
    ],
    "commit_hash": "9e62869465573cb2d9b5053f1fa02a81fce21d69",
    "short_hash": "9e628694",
    "vulnerableMethods_before": [
      {
        "filename": "mkl_requantization_range_per_channel_op.cc",
        "method_name": "vulnerable_function",
        "raw_code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& input = ctx->input(kInputTensorIndex);\n    const Tensor& input_min = ctx->input(kInputMinIndex);\n    const Tensor& input_max = ctx->input(kInputMaxIndex);\n\n    const size_t depth = input_max.NumElements();\n    OP_REQUIRES(\n        ctx, input_min.dim_size(0) == depth,\n        errors::InvalidArgument(\"input_min has incorrect size, expected \",\n                                depth, \" was \", input_min.dim_size(0)));\n    OP_REQUIRES(\n        ctx, input_max.dim_size(0) == depth,\n        errors::InvalidArgument(\"input_max has incorrect size, expected \",\n                                depth, \" was \", input_max.dim_size(0)));\n\n    const float* input_min_data = input_min.flat<float>().data();\n    const float* input_max_data = input_max.flat<float>().data();\n    std::vector<float> ranges(depth);\n    bool is_non_negative = true;\n    Eigen::array<int, 2> shuffling({1, 0});\n    auto input_matrix = input.flat_inner_dims<qint32>();\n\n    // TODO: verify performance of not transposing and finding the min max\n    // directly from input_matrix vs the one presented below of transposing and\n    // using the transposed matrix as the transposing operation in itself might\n    // be more costly.\n    // Note that this operation is a calibration step for quantization and will\n    // cease to exist in the final inference graph(will exist as a const node).\n    auto transposed_input = input_matrix.shuffle(shuffling);\n\n    // Find the ranges of each channel in parallel.\n    float out_min_max = std::numeric_limits<float>::min();\n\n#ifdef ENABLE_ONEDNN_OPENMP\n#ifdef _MSC_VER\n#pragma omp parallel for\n#else\n#pragma omp parallel for reduction(max : out_min_max)\n#endif\n#endif  // ENABLE_ONEDNN_OPENMP\n    // TODO: Add eigen parallel_for\n    for (int64_t i = 0; i < depth; ++i) {\n      Eigen::Tensor<qint32, 0, Eigen::RowMajor> min =\n          transposed_input.chip<0>(i).minimum();\n      Eigen::Tensor<qint32, 0, Eigen::RowMajor> max =\n          transposed_input.chip<0>(i).maximum();\n      const int32_t min_per_channel = min();\n      const int32_t max_per_channel = max();\n      const int32_t abs_max =\n          std::max(std::abs(min_per_channel), std::abs(max_per_channel));\n      float scale =\n          std::max(std::abs(input_min_data[i]), std::abs(input_max_data[i]));\n      ranges[i] =\n          scale * static_cast<float>(abs_max) / static_cast<float>(1L << 31);\n      if (min_per_channel < 0) is_non_negative = false;\n\n      // Thread-local out_min_max.\n      out_min_max = std::max(out_min_max, ranges[i]);\n    }\n\n    // All local out_min_max gets max-reduced into one global out_min_max at\n    // the end of the loop by specifying reduction(max:out_min_max) along with\n    // omp parallel for.\n\n    // Fixing max to clip_value_max_ (example 6.0 to support relu6)\n    if (out_min_max > clip_value_max_) out_min_max = clip_value_max_;\n\n    Tensor* output_min = nullptr;\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(kOutputMinIndex, {}, &output_min));\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(kOutputMaxIndex, {}, &output_max));\n    output_min->flat<float>()(0) = is_non_negative ? 0.0f : -out_min_max;\n    output_max->flat<float>()(0) = out_min_max;\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "mkl_requantization_range_per_channel_op.cc",
        "method_name": "fixed_function",
        "raw_code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& input = ctx->input(kInputTensorIndex);\n    const Tensor& input_min = ctx->input(kInputMinIndex);\n    const Tensor& input_max = ctx->input(kInputMaxIndex);\n\n    const size_t depth = input_max.NumElements();\n    OP_REQUIRES(\n        ctx, input_min.dim_size(0) == depth,\n        errors::InvalidArgument(\"input_min has incorrect size, expected \",\n                                depth, \" was \", input_min.dim_size(0)));\n    OP_REQUIRES(\n        ctx, input_max.dim_size(0) == depth,\n        errors::InvalidArgument(\"input_max has incorrect size, expected \",\n                                depth, \" was \", input_max.dim_size(0)));\n    OP_REQUIRES(\n        ctx, input_min.NumElements() == depth,\n        errors::InvalidArgument(\"input_min must have the same number of \"\n                                \"elements as input_max, got \",\n                                input_min.NumElements(), \" and \", depth));\n    OP_REQUIRES(ctx, input.NumElements() > 0,\n                errors::InvalidArgument(\"input must not be empty\"));\n    OP_REQUIRES(ctx, input.dims() == 4,\n                errors::InvalidArgument(\"input must be in NHWC format\"));\n    OP_REQUIRES(\n        ctx, input.dim_size(3) == depth,\n        errors::InvalidArgument(\n            \"input must have same number of channels as length of input_min: \",\n            input.dim_size(3), \" vs \", depth));\n\n    const float* input_min_data = input_min.flat<float>().data();\n    const float* input_max_data = input_max.flat<float>().data();\n    std::vector<float> ranges(depth);\n    bool is_non_negative = true;\n    Eigen::array<int, 2> shuffling({1, 0});\n    auto input_matrix = input.flat_inner_dims<qint32>();\n\n    // TODO: verify performance of not transposing and finding the min max\n    // directly from input_matrix vs the one presented below of transposing and\n    // using the transposed matrix as the transposing operation in itself might\n    // be more costly.\n    // Note that this operation is a calibration step for quantization and will\n    // cease to exist in the final inference graph(will exist as a const node).\n    auto transposed_input = input_matrix.shuffle(shuffling);\n\n    // Find the ranges of each channel in parallel.\n    float out_min_max = std::numeric_limits<float>::min();\n\n#ifdef ENABLE_ONEDNN_OPENMP\n#ifdef _MSC_VER\n#pragma omp parallel for\n#else\n#pragma omp parallel for reduction(max : out_min_max)\n#endif\n#endif  // ENABLE_ONEDNN_OPENMP\n    // TODO: Add eigen parallel_for\n    for (int64_t i = 0; i < depth; ++i) {\n      Eigen::Tensor<qint32, 0, Eigen::RowMajor> min =\n          transposed_input.chip<0>(i).minimum();\n      Eigen::Tensor<qint32, 0, Eigen::RowMajor> max =\n          transposed_input.chip<0>(i).maximum();\n      const int32_t min_per_channel = min();\n      const int32_t max_per_channel = max();\n      const int32_t abs_max =\n          std::max(std::abs(min_per_channel), std::abs(max_per_channel));\n      float scale =\n          std::max(std::abs(input_min_data[i]), std::abs(input_max_data[i]));\n      ranges[i] =\n          scale * static_cast<float>(abs_max) / static_cast<float>(1L << 31);\n      if (min_per_channel < 0) is_non_negative = false;\n\n      // Thread-local out_min_max.\n      out_min_max = std::max(out_min_max, ranges[i]);\n    }\n\n    // All local out_min_max gets max-reduced into one global out_min_max at\n    // the end of the loop by specifying reduction(max:out_min_max) along with\n    // omp parallel for.\n\n    // Fixing max to clip_value_max_ (example 6.0 to support relu6)\n    if (out_min_max > clip_value_max_) out_min_max = clip_value_max_;\n\n    Tensor* output_min = nullptr;\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(kOutputMinIndex, {}, &output_min));\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(kOutputMaxIndex, {}, &output_max));\n    output_min->flat<float>()(0) = is_non_negative ? 0.0f : -out_min_max;\n    output_max->flat<float>()(0) = out_min_max;\n  }",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <limits>\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/kernels/no_op.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/util/mkl_util.h\"\n#include \"tensorflow/core/kernels/meta_support.h\"\n#include \"tensorflow/core/framework/op.h\"\n#include \"tensorflow/core/framework/type_traits.h\"\n#include <math.h>\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/util/mkl_threadpool.h\"\n"
  },
  {
    "repository": "vim",
    "cve_id": "CVE-2022-2923",
    "cwe_list": [
      "CWE-787"
    ],
    "commit_hash": "6669de1b235843968e88844ca6d3c8dec4b01a9e",
    "short_hash": "6669de1b",
    "vulnerableMethods_before": [
      {
        "filename": "spellfile.c",
        "method_name": "vulnerable_function",
        "raw_code": "sug_filltree(spellinfo_T *spin, slang_T *slang)\n{\n    char_u\t*byts;\n    idx_T\t*idxs;\n    int\t\tdepth;\n    idx_T\tarridx[MAXWLEN];\n    int\t\tcuri[MAXWLEN];\n    char_u\ttword[MAXWLEN];\n    char_u\ttsalword[MAXWLEN];\n    int\t\tc;\n    idx_T\tn;\n    unsigned\twords_done = 0;\n    int\t\twordcount[MAXWLEN];\n\n    // We use si_foldroot for the soundfolded trie.\n    spin->si_foldroot = wordtree_alloc(spin);\n    if (spin->si_foldroot == NULL)\n\treturn FAIL;\n\n    // let tree_add_word() know we're adding to the soundfolded tree\n    spin->si_sugtree = TRUE;\n\n    /*\n     * Go through the whole case-folded tree, soundfold each word and put it\n     * in the trie.\n     */\n    byts = slang->sl_fbyts;\n    idxs = slang->sl_fidxs;\n\n    arridx[0] = 0;\n    curi[0] = 1;\n    wordcount[0] = 0;\n\n    depth = 0;\n    while (depth >= 0 && !got_int)\n    {\n\tif (curi[depth] > byts[arridx[depth]])\n\t{\n\t    // Done all bytes at this node, go up one level.\n\t    idxs[arridx[depth]] = wordcount[depth];\n\t    if (depth > 0)\n\t\twordcount[depth - 1] += wordcount[depth];\n\n\t    --depth;\n\t    line_breakcheck();\n\t}\n\telse\n\t{\n\n\t    // Do one more byte at this node.\n\t    n = arridx[depth] + curi[depth];\n\t    ++curi[depth];\n\n\t    c = byts[n];\n\t    if (c == 0)\n\t    {\n\t\t// Sound-fold the word.\n\t\ttword[depth] = NUL;\n\t\tspell_soundfold(slang, tword, TRUE, tsalword);\n\n\t\t// We use the \"flags\" field for the MSB of the wordnr,\n\t\t// \"region\" for the LSB of the wordnr.\n\t\tif (tree_add_word(spin, tsalword, spin->si_foldroot,\n\t\t\t\twords_done >> 16, words_done & 0xffff,\n\t\t\t\t\t\t\t   0) == FAIL)\n\t\t    return FAIL;\n\n\t\t++words_done;\n\t\t++wordcount[depth];\n\n\t\t// Reset the block count each time to avoid compression\n\t\t// kicking in.\n\t\tspin->si_blocks_cnt = 0;\n\n\t\t// Skip over any other NUL bytes (same word with different\n\t\t// flags).  But don't go over the end.\n\t\twhile (n + 1 < slang->sl_fbyts_len && byts[n + 1] == 0)\n\t\t{\n\t\t    ++n;\n\t\t    ++curi[depth];\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// Normal char, go one level deeper.\n\t\ttword[depth++] = c;\n\t\tarridx[depth] = idxs[n];\n\t\tcuri[depth] = 1;\n\t\twordcount[depth] = 0;\n\t    }\n\t}\n    }\n\n    smsg(_(\"Total number of words: %d\"), words_done);\n\n    return OK;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "spellfile.c",
        "method_name": "fixed_function",
        "raw_code": "sug_filltree(spellinfo_T *spin, slang_T *slang)\n{\n    char_u\t*byts;\n    idx_T\t*idxs;\n    int\t\tdepth;\n    idx_T\tarridx[MAXWLEN];\n    int\t\tcuri[MAXWLEN];\n    char_u\ttword[MAXWLEN];\n    char_u\ttsalword[MAXWLEN];\n    int\t\tc;\n    idx_T\tn;\n    unsigned\twords_done = 0;\n    int\t\twordcount[MAXWLEN];\n\n    // We use si_foldroot for the soundfolded trie.\n    spin->si_foldroot = wordtree_alloc(spin);\n    if (spin->si_foldroot == NULL)\n\treturn FAIL;\n\n    // let tree_add_word() know we're adding to the soundfolded tree\n    spin->si_sugtree = TRUE;\n\n    /*\n     * Go through the whole case-folded tree, soundfold each word and put it\n     * in the trie.  Bail out if the tree is empty.\n     */\n    byts = slang->sl_fbyts;\n    idxs = slang->sl_fidxs;\n    if (byts == NULL || idxs == NULL)\n\treturn FAIL;\n\n    arridx[0] = 0;\n    curi[0] = 1;\n    wordcount[0] = 0;\n\n    depth = 0;\n    while (depth >= 0 && !got_int)\n    {\n\tif (curi[depth] > byts[arridx[depth]])\n\t{\n\t    // Done all bytes at this node, go up one level.\n\t    idxs[arridx[depth]] = wordcount[depth];\n\t    if (depth > 0)\n\t\twordcount[depth - 1] += wordcount[depth];\n\n\t    --depth;\n\t    line_breakcheck();\n\t}\n\telse\n\t{\n\n\t    // Do one more byte at this node.\n\t    n = arridx[depth] + curi[depth];\n\t    ++curi[depth];\n\n\t    c = byts[n];\n\t    if (c == 0)\n\t    {\n\t\t// Sound-fold the word.\n\t\ttword[depth] = NUL;\n\t\tspell_soundfold(slang, tword, TRUE, tsalword);\n\n\t\t// We use the \"flags\" field for the MSB of the wordnr,\n\t\t// \"region\" for the LSB of the wordnr.\n\t\tif (tree_add_word(spin, tsalword, spin->si_foldroot,\n\t\t\t\twords_done >> 16, words_done & 0xffff,\n\t\t\t\t\t\t\t   0) == FAIL)\n\t\t    return FAIL;\n\n\t\t++words_done;\n\t\t++wordcount[depth];\n\n\t\t// Reset the block count each time to avoid compression\n\t\t// kicking in.\n\t\tspin->si_blocks_cnt = 0;\n\n\t\t// Skip over any other NUL bytes (same word with different\n\t\t// flags).  But don't go over the end.\n\t\twhile (n + 1 < slang->sl_fbyts_len && byts[n + 1] == 0)\n\t\t{\n\t\t    ++n;\n\t\t    ++curi[depth];\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// Normal char, go one level deeper.\n\t\ttword[depth++] = c;\n\t\tarridx[depth] = idxs[n];\n\t\tcuri[depth] = 1;\n\t\twordcount[depth] = 0;\n\t    }\n\t}\n    }\n\n    smsg(_(\"Total number of words: %d\"), words_done);\n\n    return OK;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n# include <time.h>\n#include \"vim.h\"\n\n// Type Definitions:\n// slang_T:\ntypedef struct slang_S slang_T;\n\n// wordnode_S:\nstruct wordnode_S\n{\n    union   // shared to save space\n    {\n\tchar_u\thashkey[6];\t// the hash key, only used while compressing\n\tint\tindex;\t\t// index in written nodes (valid after first\n\t\t\t\t// round)\n    } wn_u1;\n    union   // shared to save space\n    {\n\twordnode_T *next;\t// next node with same hash key\n\twordnode_T *wnode;\t// parent node that will write this node\n    } wn_u2;\n    wordnode_T\t*wn_child;\t// child (next byte in word)\n    wordnode_T  *wn_sibling;\t// next sibling (alternate byte in word,\n\t\t\t\t// always sorted)\n    int\t\twn_refs;\t// Nr. of references to this node.  Only\n\t\t\t\t// relevant for first node in a list of\n\t\t\t\t// siblings, in following siblings it is\n\t\t\t\t// always one.\n    char_u\twn_byte;\t// Byte for this node. NUL for word end\n\n    // Info for when \"wn_byte\" is NUL.\n    // In PREFIXTREE \"wn_region\" is used for the prefcondnr.\n    // In the soundfolded word tree \"wn_flags\" has the MSW of the wordnr and\n    // \"wn_region\" the LSW of the wordnr.\n    char_u\twn_affixID;\t/...\n\n// spellinfo_T:\ntypedef struct spellinfo_S\n{\n    wordnode_T\t*si_foldroot;\t// tree with case-folded words\n    long\tsi_foldwcount;\t// nr of words in si_foldroot\n\n    wordnode_T\t*si_keeproot;\t// tree with keep-case words\n    long\tsi_keepwcount;\t// nr of words in si_keeproot\n\n    wordnode_T\t*si_prefroot;\t// tree with postponed prefixes\n\n    long\tsi_sugtree;\t// creating the soundfolding trie\n\n    sblock_T\t*si_blocks;\t// memory blocks used\n    long\tsi_blocks_cnt;\t// memory blocks allocated\n    int\t\tsi_did_emsg;\t// TRUE when ran out of memory\n\n    long\tsi_compress_cnt;    // words to add before lowering\n\t\t\t\t    // compression limit\n    wordnode_T\t*si_first_free; // List of nodes that have been freed during\n\t\t\t\t// compression, linked by \"wn_child\" field.\n    long\tsi_free_count;\t// number of nodes in si_first_free\n#ifdef SPELL_PRINTTREE\n    int\t\tsi_wordnode_nr;\t// sequence nr for nodes\n#endif\n    buf_T\t*si_spellbuf;\t// buffer used to store soundfold word table\n\n    int\t\tsi_ascii;\t// handling only ASCII word...\n\n// char_u:\ntypedef unsigned char\tchar_u;\n\n// idx_T:\ntypedef int idx_T;\n\n// Called Methods (top 10):\n// STRMOVE from src/vim.h:\n#define STRMOVE(d, s)\t    mch_memmove((d), (s), STRLEN(s) + 1) /* <=== src/vim.h:1682:1682:STRMOVE:2 */ \n\n// utf_class from src/mbyte.c:\n    int /* <=== utf_class */ \nutf_class(int c)\n{\n    return utf_class_buf(c, curbuf);\n}\n\n// SBLOCKSIZE from src/spellfile.c:\n#define  SBLOCKSIZE 16000\t// size of sb_data /* <=== src/spellfile.c:1857:1857:SBLOCKSIZE:0 */ \n\n// BREAKCHECK_SKIP from src/misc1.c:\n# define BREAKCHECK_SKIP 1000 /* <=== src/misc1.c:2261:2261:BREAKCHECK_SKIP:0 */ \n\n// FALSE from src/vim.h:\n# define FALSE\t0\t    // note: this is an int, not a long! /* <=== src/vim.h:1484:1484:FALSE:0 */ \n\n// vim_vsnprintf_typval from src/strings.c:\n    int /* <=== vim_vsnprintf_typval */ \nvim_vsnprintf_typval(\n    char\t*str,\n    size_t\tstr_m,\n    const char\t*fmt,\n    va_list\tap,\n    typval_T\t*tvs)\n{\n    size_t\tstr_l = 0;\n    const char\t*p = fmt;\n    int\t\targ_idx = 1;\n\n    if (p == NULL)\n\tp = \"\";\n    while (*p != NUL)\n    {\n\tif (*p != '%')\n\t{\n\t    char    *q = strchr(p + 1, '%');\n\t    size_t  n = (q == NULL) ? STRLEN(p) : (size_t)(q - p);\n\n\t    // Copy up to the next '%' or NUL without any changes.\n\t    if (str_l < str_m)\n\t    {\n\t\tsize_t avail = str_m - str_l;\n\n\t\tmch_memmove(str + str_l, p, n > avail ? avail : n);\n\t    }\n\t    p += n;\n\t    str_l += n;\n\t}\n\telse\n\t{\n\t    size_t  min_field_width = 0, precision = 0;\n\t    int\t    zero_padding = 0, precision_specified = 0, justify_left = 0;\n\t    int\t    alternate_form = 0, force_sign = 0;\n\n\t    // If both the ' ' and '+' flags appear, the ' ' flag should be\n\t    // ignored.\n\t    int\t    space_for_positive = 1;\n\n\t    // allowed values: \\0, h, l, L\n\t    char    length_modifier = '\\0';\n\n\t    // temporary buffer for simple numeric->string conversion\n# if defined(FEAT_FLOAT)\n#  define TMP_LEN 350\t// On my system 1e308 is the biggest number possible.\n\t\t\t// That sounds reasonable to use as the maximum\n\t\t\t// printable.\n# else\n#  define TMP_LEN 66\n# endif\n\t    char    tmp[TMP_LEN];\n\n\t    // string address in case of string argument\n\t    const char  *str_arg = NULL;\n\n\t    // natural field width of arg without padding and sign\n\t    size_t  str_arg_l;\n\n\t    // unsigned char argument value - only defined for c conversion.\n\t    // N.B. standard explicitly states the char argument for the c\n\t    // conversion is unsigned\n\t    unsigned char uchar_arg;\n\n\t    // number of zeros to be inserted for numeric conversions as\n\t    // required by the precision or minimal field width\n\t    size_t  number_of_zeros_to_pad = 0;\n\n\t    // index into tmp where zero padding is to be inserted\n\t    size_t  zero_padding_insertion_ind = 0;\n\n\t    // current conversion specifier character\n\t    char    fmt_spec = '\\0';\n\n\t    // buffer for 's' and 'S' specs\n\t    char_u  *tofree = NULL;\n\n\n\t    p++;  // skip '%'\n\n\t    // parse flags\n\t    while (*p == '0' || *p == '-' || *p == '+' || *p == ' '\n\t\t\t\t\t\t   || *p == '#' || *p == '\\'')\n\t    {\n\t\tswitch (*p)\n\t\t{\n\t\t    case '0': zero_padding = 1; break;\n\t\t    case '-': justify_left = 1; break;\n\t\t    case '+': force_sign = 1; space_for_positive = 0; break;\n\t\t    case ' ': force_sign = 1;\n\t\t\t      // If both the ' ' and '+' flags appear, the ' '\n\t\t\t      // flag should be ignored\n\t\t\t      break;\n\t\t    case '#': alternate_form = 1; break;\n\t\t    case '\\'': break;\n\t\t}\n\t\tp++;\n\t    }\n\t    // If the '0' and '-' flags both appear, the '0' flag should be\n\t    // ignored.\n\n\t    // parse field width\n\t    if (*p == '*')\n\t    {\n\t\tint j;\n\n\t\tp++;\n\t\tj =\n# if defined(FEAT_EVAL)\n\t\t    tvs != NULL ? tv_nr(tvs, &arg_idx) :\n# endif\n\t\t\tva_arg(ap, int);\n\t\tif (j >= 0)\n\t\t    min_field_width = j;\n\t\telse\n\t\t{\n\t\t    min_field_width = -j;\n\t\t    justify_left = 1;\n\t\t}\n\t    }\n\t    else if (VIM_ISDIGIT((int)(*p)))\n\t    {\n\t\t// size_t could be wider than unsigned int; make sure we treat\n\t\t// argument like common implementations do\n\t\tunsigned int uj = *p++ - '0';\n\n\t\twhile (VIM_ISDIGIT((int)(*p)))\n\t\t    uj = 10 * uj + (unsigned int)(*p++ - '0');\n\t\tmin_field_width = uj;\n\t    }\n\n\t    // parse precision\n\t    if (*p == '.')\n\t    {\n\t\tp++;\n\t\tprecision_specified = 1;\n\t\tif (*p == '*')\n\t\t{\n\t\t    int j;\n\n\t\t    j =\n# if defined(FEAT_EVAL)\n\t\t\ttvs != NULL ? tv_nr(tvs, &arg_idx) :\n# endif\n\t\t\t    va_arg(ap, int);\n\t\t    p++;\n\t\t    if (j >= 0)\n\t\t\tprecision = j;\n\t\t    else\n\t\t    {\n\t\t\tprecision_specified = 0;\n\t\t\tprecision = 0;\n\t\t    }\n\t\t}\n\t\telse if (VIM_ISDIGIT((int)(*p)))\n\t\t{\n\t\t    // size_t could be wider than unsigned int; make sure we\n\t\t    // treat argument like common implementations do\n\t\t    unsigned int uj = *p++ - '0';\n\n\t\t    while (VIM_ISDIGIT((int)(*p)))\n\t\t\tuj = 10 * uj + (unsigned int)(*p++ - '0');\n\t\t    precision = uj;\n\t\t}\n\t    }\n\n\t    // parse 'h', 'l' and 'll' length modifiers\n\t    if (*p == 'h' || *p == 'l')\n\t    {\n\t\tlength_modifier = *p;\n\t\tp++;\n\t\tif (length_modifier == 'l' && *p == 'l')\n\t\t{\n\t\t    // double l = __int64 / varnumber_T\n\t\t    length_modifier = 'L';\n\t\t    p++;\n\t\t}\n\t    }\n\t    fmt_spec = *p;\n\n\t    // common synonyms:\n\t    switch (fmt_spec)\n\t    {\n\t\tcase 'i': fmt_spec = 'd'; break;\n\t\tcase 'D': fmt_spec = 'd'; length_modifier = 'l'; break;\n\t\tcase 'U': fmt_spec = 'u'; length_modifier = 'l'; break;\n\t\tcase 'O': fmt_spec = 'o'; length_modifier = 'l'; break;\n\t\tdefault: break;\n\t    }\n\n# if defined(FEAT_EVAL)\n\t    switch (fmt_spec)\n\t    {\n\t\tcase 'd': case 'u': case 'o': case 'x': case 'X':\n\t\t    if (tvs != NULL && length_modifier == '\\0')\n\t\t\tlength_modifier = 'L';\n\t    }\n# endif\n\n\t    // get parameter value, do initial processing\n\t    switch (fmt_spec)\n\t    {\n\t\t// '%' and 'c' behave similar to 's' regarding flags and field\n\t\t// widths\n\t    case '%':\n\t    case 'c':\n\t    case 's':\n\t    case 'S':\n\t\tstr_arg_l = 1;\n\t\tswitch (fmt_spec)\n\t\t{\n\t\tcase '%':\n\t\t    str_arg = p;\n\t\t    break;\n\n\t\tcase 'c':\n\t\t    {\n\t\t\tint j;\n\n\t\t\tj =\n# if defined(FEAT_EVAL)\n\t\t\t    tvs != NULL ? tv_nr(tvs, &arg_idx) :\n# endif\n\t\t\t\tva_arg(ap, int);\n\t\t\t// standard demands unsigned char\n\t\t\tuchar_arg = (unsigned char)j;\n\t\t\tstr_arg = (char *)&uchar_arg;\n\t\t\tbreak;\n\t\t    }\n\n\t\tcase 's':\n\t\tcase 'S':\n\t\t    str_arg =\n# if defined(FEAT_EVAL)\n\t\t\t\ttvs != NULL ? tv_str(tvs, &arg_idx, &tofree) :\n# endif\n\t\t\t\t    va_arg(ap, char *);\n\t\t    if (str_arg == NULL)\n\t\t    {\n\t\t\tstr_arg = \"[NULL]\";\n\t\t\tstr_arg_l = 6;\n\t\t    }\n\t\t    // make sure not to address string beyond the specified\n\t\t    // precision !!!\n\t\t    else if (!precision_specified)\n\t\t\tstr_arg_l = strlen(str_arg);\n\t\t    // truncate string if necessary as requested by precision\n\t\t    else if (precision == 0)\n\t\t\tstr_arg_l = 0;\n\t\t    else\n\t\t    {\n\t\t\t// Don't put the #if inside memchr(), it can be a\n\t\t\t// macro.\n\t\t\t// memchr on HP does not like n > 2^31  !!!\n\t\t\tchar *q = memchr(str_arg, '\\0',\n\t\t\t\t  precision <= (size_t)0x7fffffffL ? precision\n\t\t\t\t\t\t       : (size_t)0x7fffffffL);\n\n\t\t\tstr_arg_l = (q == NULL) ? precision\n\t\t\t\t\t\t      : (size_t)(q - str_arg);\n\t\t    }\n\t\t    if (fmt_spec == 'S')\n\t\t    {\n\t\t\tchar_u\t*p1;\n\t\t\tsize_t\ti;\n\t\t\tint\tcell;\n\n\t\t\tfor (i = 0, p1 = (char_u *)str_arg; *p1;\n\t\t\t\t\t\t\t  p1 += mb_ptr2len(p1))\n\t\t\t{\n\t\t\t    cell = mb_ptr2cells(p1);\n\t\t\t    if (precision_specified && i + cell > precision)\n\t\t\t\tbreak;\n\t\t\t    i += cell;\n\t\t\t}\n\n\t\t\tstr_arg_l = p1 - (char_u *)str_arg;\n\t\t\tif (min_field_width != 0)\n\t\t\t    min_field_width += str_arg_l - i;\n\t\t    }\n\t\t    break;\n\n\t\tdefault:\n\t\t    break;\n\t\t}\n\t\tbreak;\n\n\t    case 'd': case 'u':\n\t    case 'b': case 'B':\n\t    case 'o':\n\t    case 'x': case 'X':\n\t    case 'p':\n\t\t{\n\t\t    // NOTE: the u, b, o, x, X and p conversion specifiers\n\t\t    // imply the value is unsigned;  d implies a signed\n\t\t    // value\n\n\t\t    // 0 if numeric argument is zero (or if pointer is\n\t\t    // NULL for 'p'), +1 if greater than zero (or nonzero\n\t\t    // for unsigned arguments), -1 if negative (unsigned\n\t\t    // argument is never negative)\n\t\t    int arg_sign = 0;\n\n\t\t    // only set for length modifier h, or for no length\n\t\t    // modifiers\n\t\t    int int_arg = 0;\n\t\t    unsigned int uint_arg = 0;\n\n\t\t    // only set for length modifier l\n\t\t    long int long_arg = 0;\n\t\t    unsigned long int ulong_arg = 0;\n\n\t\t    // only set for length modifier ll\n\t\t    varnumber_T llong_arg = 0;\n\t\t    uvarnumber_T ullong_arg = 0;\n\n\t\t    // only set for b conversion\n\t\t    uvarnumber_T bin_arg = 0;\n\n\t\t    // pointer argument value -only defined for p\n\t\t    // conversion\n\t\t    void *ptr_arg = NULL;\n\n\t\t    if (fmt_spec == 'p')\n\t\t    {\n\t\t\tlength_modifier = '\\0';\n\t\t\tptr_arg =\n# if defined(FEAT_EVAL)\n\t\t\t\t tvs != NULL ? (void *)tv_str(tvs, &arg_idx,\n\t\t\t\t\t\t\t\t\tNULL) :\n# endif\n\t\t\t\t\tva_arg(ap, void *);\n\t\t\tif (ptr_arg != NULL)\n\t\t\t    arg_sign = 1;\n\t\t    }\n\t\t    else if (fmt_spec == 'b' || fmt_spec == 'B')\n\t\t    {\n\t\t\tbin_arg =\n# if defined(FEAT_EVAL)\n\t\t\t\t    tvs != NULL ?\n\t\t\t\t\t   (uvarnumber_T)tv_nr(tvs, &arg_idx) :\n# endif\n\t\t\t\t\tva_arg(ap, uvarnumber_T);\n\t\t\tif (bin_arg != 0)\n\t\t\t    arg_sign = 1;\n\t\t    }\n\t\t    else if (fmt_spec == 'd')\n\t\t    {\n\t\t\t// signed\n\t\t\tswitch (length_modifier)\n\t\t\t{\n\t\t\tcase '\\0':\n\t\t\tcase 'h':\n\t\t\t    // char and short arguments are passed as int.\n\t\t\t    int_arg =\n# if defined(FEAT_EVAL)\n\t\t\t\t\ttvs != NULL ? tv_nr(tvs, &arg_idx) :\n# endif\n\t\t\t\t\t    va_arg(ap, int);\n\t\t\t    if (int_arg > 0)\n\t\t\t\targ_sign =  1;\n\t\t\t    else if (int_arg < 0)\n\t\t\t\targ_sign = -1;\n\t\t\t    break;\n\t\t\tcase 'l':\n\t\t\t    long_arg =\n# if defined(FEAT_EVAL)\n\t\t\t\t\ttvs != NULL ? tv_nr(tvs, &arg_idx) :\n# endif\n\t\t\t\t\t    va_arg(ap, long int);\n\t\t\t    if (long_arg > 0)\n\t\t\t\targ_sign =  1;\n\t\t\t    else if (long_arg < 0)\n\t\t\t\targ_sign = -1;\n\t\t\t    break;\n\t\t\tcase 'L':\n\t\t\t    llong_arg =\n# if defined(FEAT_EVAL)\n\t\t\t\t\ttvs != NULL ? tv_nr(tvs, &arg_idx) :\n# endif\n\t\t\t\t\t    va_arg(ap, varnumber_T);\n\t\t\t    if (llong_arg > 0)\n\t\t\t\targ_sign =  1;\n\t\t\t    else if (llong_arg < 0)\n\t\t\t\targ_sign = -1;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// unsigned\n\t\t\tswitch (length_modifier)\n\t\t\t{\n\t\t\t    case '\\0':\n\t\t\t    case 'h':\n\t\t\t\tuint_arg =\n# if defined(FEAT_EVAL)\n\t\t\t\t\t    tvs != NULL ? (unsigned)\n\t\t\t\t\t\t\ttv_nr(tvs, &arg_idx) :\n# endif\n\t\t\t\t\t\tva_arg(ap, unsigned int);\n\t\t\t\tif (uint_arg != 0)\n\t\t\t\t    arg_sign = 1;\n\t\t\t\tbreak;\n\t\t\t    case 'l':\n\t\t\t\tulong_arg =\n# if defined(FEAT_EVAL)\n\t\t\t\t\t    tvs != NULL ? (unsigned long)\n\t\t\t\t\t\t\ttv_nr(tvs, &arg_idx) :\n# endif\n\t\t\t\t\t\tva_arg(ap, unsigned long int);\n\t\t\t\tif (ulong_arg != 0)\n\t\t\t\t    arg_sign = 1;\n\t\t\t\tbreak;\n\t\t\t    case 'L':\n\t\t\t\tullong_arg =\n# if defined(FEAT_EVAL)\n\t\t\t\t\t    tvs != NULL ? (uvarnumber_T)\n\t\t\t\t\t\t\ttv_nr(tvs, &arg_idx) :\n# endif\n\t\t\t\t\t\tva_arg(ap, uvarnumber_T);\n\t\t\t\tif (ullong_arg != 0)\n\t\t\t\t    arg_sign = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t    }\n\n\t\t    str_arg = tmp;\n\t\t    str_arg_l = 0;\n\n\t\t    // NOTE:\n\t\t    //   For d, i, u, o, x, and X conversions, if precision is\n\t\t    //   specified, the '0' flag should be ignored. This is so\n\t\t    //   with Solaris 2.6, Digital UNIX 4.0, HPUX 10, Linux,\n\t\t    //   FreeBSD, NetBSD; but not with Perl.\n\t\t    if (precision_specified)\n\t\t\tzero_padding = 0;\n\t\t    if (fmt_spec == 'd')\n\t\t    {\n\t\t\tif (force_sign && arg_sign >= 0)\n\t\t\t    tmp[str_arg_l++] = space_for_positive ? ' ' : '+';\n\t\t\t// leave negative numbers for sprintf to handle, to\n\t\t\t// avoid handling tricky cases like (short int)-32768\n\t\t    }\n\t\t    else if (alternate_form)\n\t\t    {\n\t\t\tif (arg_sign != 0\n\t\t\t\t     && (fmt_spec == 'b' || fmt_spec == 'B'\n\t\t\t\t      || fmt_spec == 'x' || fmt_spec == 'X') )\n\t\t\t{\n\t\t\t    tmp[str_arg_l++] = '0';\n\t\t\t    tmp[str_arg_l++] = fmt_spec;\n\t\t\t}\n\t\t\t// alternate form should have no effect for p\n\t\t\t// conversion, but ...\n\t\t    }\n\n\t\t    zero_padding_insertion_ind = str_arg_l;\n\t\t    if (!precision_specified)\n\t\t\tprecision = 1;   // default precision is 1\n\t\t    if (precision == 0 && arg_sign == 0)\n\t\t    {\n\t\t\t// When zero value is formatted with an explicit\n\t\t\t// precision 0, the resulting formatted string is\n\t\t\t// empty (d, i, u, b, B, o, x, X, p).\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tchar\tf[6];\n\t\t\tint\tf_l = 0;\n\n\t\t\t// construct a simple format string for sprintf\n\t\t\tf[f_l++] = '%';\n\t\t\tif (!length_modifier)\n\t\t\t    ;\n\t\t\telse if (length_modifier == 'L')\n\t\t\t{\n# ifdef MSWIN\n\t\t\t    f[f_l++] = 'I';\n\t\t\t    f[f_l++] = '6';\n\t\t\t    f[f_l++] = '4';\n# else\n\t\t\t    f[f_l++] = 'l';\n\t\t\t    f[f_l++] = 'l';\n# endif\n\t\t\t}\n\t\t\telse\n\t\t\t    f[f_l++] = length_modifier;\n\t\t\tf[f_l++] = fmt_spec;\n\t\t\tf[f_l++] = '\\0';\n\n\t\t\tif (fmt_spec == 'p')\n\t\t\t    str_arg_l += sprintf(tmp + str_arg_l, f, ptr_arg);\n\t\t\telse if (fmt_spec == 'b' || fmt_spec == 'B')\n\t\t\t{\n\t\t\t    char\t    b[8 * sizeof(uvarnumber_T)];\n\t\t\t    size_t\t    b_l = 0;\n\t\t\t    uvarnumber_T    bn = bin_arg;\n\n\t\t\t    do\n\t\t\t    {\n\t\t\t\tb[sizeof(b) - ++b_l] = '0' + (bn & 0x1);\n\t\t\t\tbn >>= 1;\n\t\t\t    }\n\t\t\t    while (bn != 0);\n\n\t\t\t    memcpy(tmp + str_arg_l, b + sizeof(b) - b_l, b_l);\n\t\t\t    str_arg_l += b_l;\n\t\t\t}\n\t\t\telse if (fmt_spec == 'd')\n\t\t\t{\n\t\t\t    // signed\n\t\t\t    switch (length_modifier)\n\t\t\t    {\n\t\t\t    case '\\0': str_arg_l += sprintf(\n\t\t\t\t\t\t tmp + str_arg_l, f,\n\t\t\t\t\t\t int_arg);\n\t\t\t\t       break;\n\t\t\t    case 'h': str_arg_l += sprintf(\n\t\t\t\t\t\t tmp + str_arg_l, f,\n\t\t\t\t\t\t (short)int_arg);\n\t\t\t\t      break;\n\t\t\t    case 'l': str_arg_l += sprintf(\n\t\t\t\t\t\ttmp + str_arg_l, f, long_arg);\n\t\t\t\t      break;\n\t\t\t    case 'L': str_arg_l += sprintf(\n\t\t\t\t\t       tmp + str_arg_l, f, llong_arg);\n\t\t\t\t      break;\n\t\t\t    }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // unsigned\n\t\t\t    switch (length_modifier)\n\t\t\t    {\n\t\t\t    case '\\0': str_arg_l += sprintf(\n\t\t\t\t\t\ttmp + str_arg_l, f,\n\t\t\t\t\t\tuint_arg);\n\t\t\t\t       break;\n\t\t\t    case 'h': str_arg_l += sprintf(\n\t\t\t\t\t\ttmp + str_arg_l, f,\n\t\t\t\t\t\t(unsigned short)uint_arg);\n\t\t\t\t      break;\n\t\t\t    case 'l': str_arg_l += sprintf(\n\t\t\t\t\t       tmp + str_arg_l, f, ulong_arg);\n\t\t\t\t      break;\n\t\t\t    case 'L': str_arg_l += sprintf(\n\t\t\t\t\t      tmp + str_arg_l, f, ullong_arg);\n\t\t\t\t      break;\n\t\t\t    }\n\t\t\t}\n\n\t\t\t// include the optional minus sign and possible\n\t\t\t// \"0x\" in the region before the zero padding\n\t\t\t// insertion point\n\t\t\tif (zero_padding_insertion_ind < str_arg_l\n\t\t\t\t&& tmp[zero_padding_insertion_ind] == '-')\n\t\t\t    zero_padding_insertion_ind++;\n\t\t\tif (zero_padding_insertion_ind + 1 < str_arg_l\n\t\t\t\t&& tmp[zero_padding_insertion_ind]   == '0'\n\t\t\t\t&& (tmp[zero_padding_insertion_ind + 1] == 'x'\n\t\t\t\t || tmp[zero_padding_insertion_ind + 1] == 'X'))\n\t\t\t    zero_padding_insertion_ind += 2;\n\t\t    }\n\n\t\t    {\n\t\t\tsize_t num_of_digits = str_arg_l\n\t\t\t\t\t\t - zero_padding_insertion_ind;\n\n\t\t\tif (alternate_form && fmt_spec == 'o'\n\t\t\t\t// unless zero is already the first\n\t\t\t\t// character\n\t\t\t\t&& !(zero_padding_insertion_ind < str_arg_l\n\t\t\t\t    && tmp[zero_padding_insertion_ind] == '0'))\n\t\t\t{\n\t\t\t    // assure leading zero for alternate-form\n\t\t\t    // octal numbers\n\t\t\t    if (!precision_specified\n\t\t\t\t\t     || precision < num_of_digits + 1)\n\t\t\t    {\n\t\t\t\t// precision is increased to force the\n\t\t\t\t// first character to be zero, except if a\n\t\t\t\t// zero value is formatted with an\n\t\t\t\t// explicit precision of zero\n\t\t\t\tprecision = num_of_digits + 1;\n\t\t\t    }\n\t\t\t}\n\t\t\t// zero padding to specified precision?\n\t\t\tif (num_of_digits < precision)\n\t\t\t    number_of_zeros_to_pad = precision - num_of_digits;\n\t\t    }\n\t\t    // zero padding to specified minimal field width?\n\t\t    if (!justify_left && zero_padding)\n\t\t    {\n\t\t\tint n = (int)(min_field_width - (str_arg_l\n\t\t\t\t\t\t    + number_of_zeros_to_pad));\n\t\t\tif (n > 0)\n\t\t\t    number_of_zeros_to_pad += n;\n\t\t    }\n\t\t    break;\n\t\t}\n\n# ifdef FEAT_FLOAT\n\t    case 'f':\n\t    case 'F':\n\t    case 'e':\n\t    case 'E':\n\t    case 'g':\n\t    case 'G':\n\t\t{\n\t\t    // Floating point.\n\t\t    double\tf;\n\t\t    double\tabs_f;\n\t\t    char\tformat[40];\n\t\t    int\t\tl;\n\t\t    int\t\tremove_trailing_zeroes = FALSE;\n\n\t\t    f =\n#  if defined(FEAT_EVAL)\n\t\t\ttvs != NULL ? tv_float(tvs, &arg_idx) :\n#  endif\n\t\t\t    va_arg(ap, double);\n\t\t    abs_f = f < 0 ? -f : f;\n\n\t\t    if (fmt_spec == 'g' || fmt_spec == 'G')\n\t\t    {\n\t\t\t// Would be nice to use %g directly, but it prints\n\t\t\t// \"1.0\" as \"1\", we don't want that.\n\t\t\tif ((abs_f >= 0.001 && abs_f < 10000000.0)\n\t\t\t\t\t\t\t      || abs_f == 0.0)\n\t\t\t    fmt_spec = ASCII_ISUPPER(fmt_spec) ? 'F' : 'f';\n\t\t\telse\n\t\t\t    fmt_spec = fmt_spec == 'g' ? 'e' : 'E';\n\t\t\tremove_trailing_zeroes = TRUE;\n\t\t    }\n\n\t\t    if ((fmt_spec == 'f' || fmt_spec == 'F') &&\n#  ifdef VAX\n\t\t\t    abs_f > 1.0e38\n#  else\n\t\t\t    abs_f > 1.0e307\n#  endif\n\t\t\t    )\n\t\t    {\n\t\t\t// Avoid a buffer overflow\n\t\t\tSTRCPY(tmp, infinity_str(f > 0.0, fmt_spec,\n\t\t\t\t\t      force_sign, space_for_positive));\n\t\t\tstr_arg_l = STRLEN(tmp);\n\t\t\tzero_padding = 0;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (isnan(f))\n\t\t\t{\n\t\t\t    // Not a number: nan or NAN\n\t\t\t    STRCPY(tmp, ASCII_ISUPPER(fmt_spec) ? \"NAN\"\n\t\t\t\t\t\t\t\t      : \"nan\");\n\t\t\t    str_arg_l = 3;\n\t\t\t    zero_padding = 0;\n\t\t\t}\n\t\t\telse if (isinf(f))\n\t\t\t{\n\t\t\t    STRCPY(tmp, infinity_str(f > 0.0, fmt_spec,\n\t\t\t\t\t      force_sign, space_for_positive));\n\t\t\t    str_arg_l = STRLEN(tmp);\n\t\t\t    zero_padding = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // Regular float number\n\t\t\t    format[0] = '%';\n\t\t\t    l = 1;\n\t\t\t    if (force_sign)\n\t\t\t\tformat[l++] = space_for_positive ? ' ' : '+';\n\t\t\t    if (precision_specified)\n\t\t\t    {\n\t\t\t\tsize_t max_prec = TMP_LEN - 10;\n\n\t\t\t\t// Make sure we don't get more digits than we\n\t\t\t\t// have room for.\n\t\t\t\tif ((fmt_spec == 'f' || fmt_spec == 'F')\n\t\t\t\t\t\t\t\t&& abs_f > 1.0)\n\t\t\t\t    max_prec -= (size_t)log10(abs_f);\n\t\t\t\tif (precision > max_prec)\n\t\t\t\t    precision = max_prec;\n\t\t\t\tl += sprintf(format + l, \".%d\", (int)precision);\n\t\t\t    }\n\t\t\t    format[l] = fmt_spec == 'F' ? 'f' : fmt_spec;\n\t\t\t    format[l + 1] = NUL;\n\n\t\t\t    str_arg_l = sprintf(tmp, format, f);\n\t\t\t}\n\n\t\t\tif (remove_trailing_zeroes)\n\t\t\t{\n\t\t\t    int i;\n\t\t\t    char *tp;\n\n\t\t\t    // Using %g or %G: remove superfluous zeroes.\n\t\t\t    if (fmt_spec == 'f' || fmt_spec == 'F')\n\t\t\t\ttp = tmp + str_arg_l - 1;\n\t\t\t    else\n\t\t\t    {\n\t\t\t\ttp = (char *)vim_strchr((char_u *)tmp,\n\t\t\t\t\t\t fmt_spec == 'e' ? 'e' : 'E');\n\t\t\t\tif (tp != NULL)\n\t\t\t\t{\n\t\t\t\t    // Remove superfluous '+' and leading\n\t\t\t\t    // zeroes from the exponent.\n\t\t\t\t    if (tp[1] == '+')\n\t\t\t\t    {\n\t\t\t\t\t// Change \"1.0e+07\" to \"1.0e07\"\n\t\t\t\t\tSTRMOVE(tp + 1, tp + 2);\n\t\t\t\t\t--str_arg_l;\n\t\t\t\t    }\n\t\t\t\t    i = (tp[1] == '-') ? 2 : 1;\n\t\t\t\t    while (tp[i] == '0')\n\t\t\t\t    {\n\t\t\t\t\t// Change \"1.0e07\" to \"1.0e7\"\n\t\t\t\t\tSTRMOVE(tp + i, tp + i + 1);\n\t\t\t\t\t--str_arg_l;\n\t\t\t\t    }\n\t\t\t\t    --tp;\n\t\t\t\t}\n\t\t\t    }\n\n\t\t\t    if (tp != NULL && !precision_specified)\n\t\t\t\t// Remove trailing zeroes, but keep the one\n\t\t\t\t// just after a dot.\n\t\t\t\twhile (tp > tmp + 2 && *tp == '0'\n\t\t\t\t\t\t\t     && tp[-1] != '.')\n\t\t\t\t{\n\t\t\t\t    STRMOVE(tp, tp + 1);\n\t\t\t\t    --tp;\n\t\t\t\t    --str_arg_l;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    char *tp;\n\n\t\t\t    // Be consistent: some printf(\"%e\") use 1.0e+12\n\t\t\t    // and some 1.0e+012.  Remove one zero in the last\n\t\t\t    // case.\n\t\t\t    tp = (char *)vim_strchr((char_u *)tmp,\n\t\t\t\t\t\t fmt_spec == 'e' ? 'e' : 'E');\n\t\t\t    if (tp != NULL && (tp[1] == '+' || tp[1] == '-')\n\t\t\t\t\t  && tp[2] == '0'\n\t\t\t\t\t  && vim_isdigit(tp[3])\n\t\t\t\t\t  && vim_isdigit(tp[4]))\n\t\t\t    {\n\t\t\t\tSTRMOVE(tp + 2, tp + 3);\n\t\t\t\t--str_arg_l;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    if (zero_padding && min_field_width > str_arg_l\n\t\t\t\t\t      && (tmp[0] == '-' || force_sign))\n\t\t    {\n\t\t\t// padding 0's should be inserted after the sign\n\t\t\tnumber_of_zeros_to_pad = min_field_width - str_arg_l;\n\t\t\tzero_padding_insertion_ind = 1;\n\t\t    }\n\t\t    str_arg = tmp;\n\t\t    break;\n\t\t}\n# endif\n\n\t    default:\n\t\t// unrecognized conversion specifier, keep format string\n\t\t// as-is\n\t\tzero_padding = 0;  // turn zero padding off for non-numeric\n\t\t\t\t   // conversion\n\t\tjustify_left = 1;\n\t\tmin_field_width = 0;\t\t    // reset flags\n\n\t\t// discard the unrecognized conversion, just keep *\n\t\t// the unrecognized conversion character\n\t\tstr_arg = p;\n\t\tstr_arg_l = 0;\n\t\tif (*p != NUL)\n\t\t    str_arg_l++;  // include invalid conversion specifier\n\t\t\t\t  // unchanged if not at end-of-string\n\t\tbreak;\n\t    }\n\n\t    if (*p != NUL)\n\t\tp++;     // step over the just processed conversion specifier\n\n\t    // insert padding to the left as requested by min_field_width;\n\t    // this does not include the zero padding in case of numerical\n\t    // conversions\n\t    if (!justify_left)\n\t    {\n\t\t// left padding with blank or zero\n\t\tint pn = (int)(min_field_width - (str_arg_l + number_of_zeros_to_pad));\n\n\t\tif (pn > 0)\n\t\t{\n\t\t    if (str_l < str_m)\n\t\t    {\n\t\t\tsize_t avail = str_m - str_l;\n\n\t\t\tvim_memset(str + str_l, zero_padding ? '0' : ' ',\n\t\t\t\t\t     (size_t)pn > avail ? avail\n\t\t\t\t\t\t\t\t: (size_t)pn);\n\t\t    }\n\t\t    str_l += pn;\n\t\t}\n\t    }\n\n\t    // zero padding as requested by the precision or by the minimal\n\t    // field width for numeric conversions required?\n\t    if (number_of_zeros_to_pad == 0)\n\t    {\n\t\t// will not copy first part of numeric right now, *\n\t\t// force it to be copied later in its entirety\n\t\tzero_padding_insertion_ind = 0;\n\t    }\n\t    else\n\t    {\n\t\t// insert first part of numerics (sign or '0x') before zero\n\t\t// padding\n\t\tint zn = (int)zero_padding_insertion_ind;\n\n\t\tif (zn > 0)\n\t\t{\n\t\t    if (str_l < str_m)\n\t\t    {\n\t\t\tsize_t avail = str_m - str_l;\n\n\t\t\tmch_memmove(str + str_l, str_arg,\n\t\t\t\t\t     (size_t)zn > avail ? avail\n\t\t\t\t\t\t\t\t: (size_t)zn);\n\t\t    }\n\t\t    str_l += zn;\n\t\t}\n\n\t\t// insert zero padding as requested by the precision or min\n\t\t// field width\n\t\tzn = (int)number_of_zeros_to_pad;\n\t\tif (zn > 0)\n\t\t{\n\t\t    if (str_l < str_m)\n\t\t    {\n\t\t\tsize_t avail = str_m - str_l;\n\n\t\t\tvim_memset(str + str_l, '0',\n\t\t\t\t\t     (size_t)zn > avail ? avail\n\t\t\t\t\t\t\t\t: (size_t)zn);\n\t\t    }\n\t\t    str_l += zn;\n\t\t}\n\t    }\n\n\t    // insert formatted string\n\t    // (or as-is conversion specifier for unknown conversions)\n\t    {\n\t\tint sn = (int)(str_arg_l - zero_padding_insertion_ind);\n\n\t\tif (sn > 0)\n\t\t{\n\t\t    if (str_l < str_m)\n\t\t    {\n\t\t\tsize_t avail = str_m - str_l;\n\n\t\t\tmch_memmove(str + str_l,\n\t\t\t\tstr_arg + zero_padding_insertion_ind,\n\t\t\t\t(size_t)sn > avail ? avail : (size_t)sn);\n\t\t    }\n\t\t    str_l += sn;\n\t\t}\n\t    }\n\n\t    // insert right padding\n\t    if (justify_left)\n\t    {\n\t\t// right blank padding to the field width\n\t\tint pn = (int)(min_field_width\n\t\t\t\t      - (str_arg_l + number_of_zeros_to_pad));\n\n\t\tif (pn > 0)\n\t\t{\n\t\t    if (str_l < str_m)\n\t\t    {\n\t\t\tsize_t avail = str_m - str_l;\n\n\t\t\tvim_memset(str + str_l, ' ',\n\t\t\t\t\t     (size_t)pn > avail ? avail\n\t\t\t\t\t\t\t\t: (size_t)pn);\n\t\t    }\n\t\t    str_l += pn;\n\t\t}\n\t    }\n\t    vim_free(tofree);\n\t}\n    }\n\n    if (str_m > 0)\n    {\n\t// make sure the string is nul-terminated even at the expense of\n\t// overwriting the last character (shouldn't happen, but just in case)\n\t//\n\tstr[str_l <= str_m - 1 ? str_l : str_m - 1] = '\\0';\n    }\n\n    if (tvs != NULL && tvs[arg_idx - 1].v_type != VAR_UNKNOWN)\n\temsg(_(e_too_many_arguments_to_printf));\n\n    // Return the number of characters formatted (excluding trailing nul\n    // character), that is, the number of characters that would have been\n    // written to the buffer if it were large enough.\n    return (int)str_l;\n}\n\n// smsg from src/message.c:\n    int /* <=== smsg */ \nsmsg(const char *s, ...)\n{\n    if (IObuff == NULL)\n    {\n\t// Very early in initialisation and already something wrong, just\n\t// give the raw message so the user at least gets a hint.\n\treturn msg((char *)s);\n    }\n    else\n    {\n\tva_list arglist;\n\n\tva_start(arglist, s);\n\tvim_vsnprintf((char *)IObuff, IOSIZE, s, arglist);\n\tva_end(arglist);\n\treturn msg((char *)IObuff);\n    }\n}\n\n// msg_clr_eos_force from src/message.c:\n    void /* <=== msg_clr_eos_force */ \nmsg_clr_eos_force(void)\n{\n    if (msg_use_printf())\n    {\n\tif (full_screen)\t// only when termcap codes are valid\n\t{\n\t    if (*T_CD)\n\t\tout_str(T_CD);\t// clear to end of display\n\t    else if (*T_CE)\n\t\tout_str(T_CE);\t// clear to end of line\n\t}\n    }\n    else if (p_ch > 0)\n    {\n#ifdef FEAT_RIGHTLEFT\n\tif (cmdmsg_rl)\n\t{\n\t    screen_fill(msg_row, msg_row + 1, 0, msg_col + 1, ' ', ' ', 0);\n\t    screen_fill(msg_row + 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);\n\t}\n\telse\n#endif\n\t{\n\t    screen_fill(msg_row, msg_row + 1, msg_col, (int)Columns,\n\t\t\t\t\t\t\t\t ' ', ' ', 0);\n\t    screen_fill(msg_row + 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);\n\t}\n    }\n}\n\n// vim_snprintf from src/strings.c:\n    int /* <=== vim_snprintf */ \nvim_snprintf(char *str, size_t str_m, const char *fmt, ...)\n{\n    va_list\tap;\n    int\t\tstr_l;\n\n    va_start(ap, fmt);\n    str_l = vim_vsnprintf(str, str_m, fmt, ap);\n    va_end(ap);\n    return str_l;\n}\n\n// vim_strchr from src/strings.c:\n    char_u  * /* <=== vim_strchr */ \nvim_strchr(char_u *string, int c)\n{\n    char_u\t*p;\n    int\t\tb;\n\n    p = string;\n    if (enc_utf8 && c >= 0x80)\n    {\n\twhile (*p != NUL)\n\t{\n\t    int l = utfc_ptr2len(p);\n\n\t    // Avoid matching an illegal byte here.\n\t    if (utf_ptr2char(p) == c && l > 1)\n\t\treturn p;\n\t    p += l;\n\t}\n\treturn NULL;\n    }\n    if (enc_dbcs != 0 && c > 255)\n    {\n\tint\tn2 = c & 0xff;\n\n\tc = ((unsigned)c >> 8) & 0xff;\n\twhile ((b = *p) != NUL)\n\t{\n\t    if (b == c && p[1] == n2)\n\t\treturn p;\n\t    p += (*mb_ptr2len)(p);\n\t}\n\treturn NULL;\n    }\n    if (has_mbyte)\n    {\n\twhile ((b = *p) != NUL)\n\t{\n\t    if (b == c)\n\t\treturn p;\n\t    p += (*mb_ptr2len)(p);\n\t}\n\treturn NULL;\n    }\n    while ((b = *p) != NUL)\n    {\n\tif (b == c)\n\t    return p;\n\t++p;\n    }\n    return NULL;\n}\n"
  },
  {
    "repository": "gdk-pixbuf",
    "cve_id": "CVE-2012-2370",
    "cwe_list": [
      "CWE-189"
    ],
    "commit_hash": "4f0f465f991cd454d03189497f923eb40c170c22",
    "short_hash": "4f0f465f",
    "vulnerableMethods_before": [
      {
        "filename": "io-xbm.c",
        "method_name": "vulnerable_function",
        "raw_code": "read_bitmap_file_data (FILE    *fstream,\n\t\t       guint   *width, \n\t\t       guint   *height,\n\t\t       guchar **data,\n\t\t       int     *x_hot, \n\t\t       int     *y_hot)\n{\n\tguchar *bits = NULL;\t\t/* working variable */\n\tchar line[MAX_SIZE];\t\t/* input line from file */\n\tint size;\t\t\t/* number of bytes of data */\n\tchar name_and_type[MAX_SIZE];\t/* an input line */\n\tchar *type;\t\t\t/* for parsing */\n\tint value;\t\t\t/* from an input line */\n\tint version10p;\t\t\t/* boolean, old format */\n\tint padding;\t\t\t/* to handle alignment */\n\tint bytes_per_line;\t\t/* per scanline of data */\n\tguint ww = 0;\t\t\t/* width */\n\tguint hh = 0;\t\t\t/* height */\n\tint hx = -1;\t\t\t/* x hotspot */\n\tint hy = -1;\t\t\t/* y hotspot */\n\n\t/* first time initialization */\n\tif (!initialized) {\n\t\tinit_hex_table ();\n\t}\n\n\t/* error cleanup and return macro */\n#define\tRETURN(code) { g_free (bits); return code; }\n\n\twhile (fgets (line, MAX_SIZE, fstream)) {\n\t\tif (strlen (line) == MAX_SIZE-1)\n\t\t\tRETURN (FALSE);\n\t\tif (sscanf (line,\"#define %s %d\",name_and_type,&value) == 2) {\n\t\t\tif (!(type = strrchr (name_and_type, '_')))\n\t\t\t\ttype = name_and_type;\n\t\t\telse {\n\t\t\t\ttype++;\n\t\t\t}\n\n\t\t\tif (!strcmp (\"width\", type))\n\t\t\t\tww = (unsigned int) value;\n\t\t\tif (!strcmp (\"height\", type))\n\t\t\t\thh = (unsigned int) value;\n\t\t\tif (!strcmp (\"hot\", type)) {\n\t\t\t\tif (type-- == name_and_type\n\t\t\t\t    || type-- == name_and_type)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!strcmp (\"x_hot\", type))\n\t\t\t\t\thx = value;\n\t\t\t\tif (!strcmp (\"y_hot\", type))\n\t\t\t\t\thy = value;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n    \n\t\tif (sscanf (line, \"static short %s = {\", name_and_type) == 1)\n\t\t\tversion10p = 1;\n\t\telse if (sscanf (line,\"static const unsigned char %s = {\",name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse if (sscanf (line,\"static unsigned char %s = {\",name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse if (sscanf (line, \"static const char %s = {\", name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse if (sscanf (line, \"static char %s = {\", name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse\n\t\t\tcontinue;\n\n\t\tif (!(type = strrchr (name_and_type, '_')))\n\t\t\ttype = name_and_type;\n\t\telse\n\t\t\ttype++;\n\n\t\tif (strcmp (\"bits[]\", type))\n\t\t\tcontinue;\n    \n\t\tif (!ww || !hh)\n\t\t\tRETURN (FALSE);\n\n\t\tif ((ww % 16) && ((ww % 16) < 9) && version10p)\n\t\t\tpadding = 1;\n\t\telse\n\t\t\tpadding = 0;\n\n\t\tbytes_per_line = (ww+7)/8 + padding;\n\n\t\tsize = bytes_per_line * hh;\n\t\tbits = g_malloc (size);\n\n\t\tif (version10p) {\n\t\t\tunsigned char *ptr;\n\t\t\tint bytes;\n\n\t\t\tfor (bytes = 0, ptr = bits; bytes < size; (bytes += 2)) {\n\t\t\t\tif ((value = next_int (fstream)) < 0)\n\t\t\t\t\tRETURN (FALSE);\n\t\t\t\t*(ptr++) = value;\n\t\t\t\tif (!padding || ((bytes+2) % bytes_per_line))\n\t\t\t\t\t*(ptr++) = value >> 8;\n\t\t\t}\n\t\t} else {\n\t\t\tunsigned char *ptr;\n\t\t\tint bytes;\n\n\t\t\tfor (bytes = 0, ptr = bits; bytes < size; bytes++, ptr++) {\n\t\t\t\tif ((value = next_int (fstream)) < 0) \n\t\t\t\t\tRETURN (FALSE);\n\t\t\t\t*ptr=value;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (!bits)\n\t\tRETURN (FALSE);\n\n\t*data = bits;\n\t*width = ww;\n\t*height = hh;\n\tif (x_hot)\n\t\t*x_hot = hx;\n\tif (y_hot)\n\t\t*y_hot = hy;\n\n\treturn TRUE;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "io-xbm.c",
        "method_name": "fixed_function",
        "raw_code": "read_bitmap_file_data (FILE    *fstream,\n\t\t       guint   *width, \n\t\t       guint   *height,\n\t\t       guchar **data,\n\t\t       int     *x_hot, \n\t\t       int     *y_hot)\n{\n\tguchar *bits = NULL;\t\t/* working variable */\n\tchar line[MAX_SIZE];\t\t/* input line from file */\n\tint size;\t\t\t/* number of bytes of data */\n\tchar name_and_type[MAX_SIZE];\t/* an input line */\n\tchar *type;\t\t\t/* for parsing */\n\tint value;\t\t\t/* from an input line */\n\tint version10p;\t\t\t/* boolean, old format */\n\tint padding;\t\t\t/* to handle alignment */\n\tint bytes_per_line;\t\t/* per scanline of data */\n\tguint ww = 0;\t\t\t/* width */\n\tguint hh = 0;\t\t\t/* height */\n\tint hx = -1;\t\t\t/* x hotspot */\n\tint hy = -1;\t\t\t/* y hotspot */\n\n\t/* first time initialization */\n\tif (!initialized) {\n\t\tinit_hex_table ();\n\t}\n\n\t/* error cleanup and return macro */\n#define\tRETURN(code) { g_free (bits); return code; }\n\n\twhile (fgets (line, MAX_SIZE, fstream)) {\n\t\tif (strlen (line) == MAX_SIZE-1)\n\t\t\tRETURN (FALSE);\n\t\tif (sscanf (line,\"#define %s %d\",name_and_type,&value) == 2) {\n\t\t\tif (!(type = strrchr (name_and_type, '_')))\n\t\t\t\ttype = name_and_type;\n\t\t\telse {\n\t\t\t\ttype++;\n\t\t\t}\n\n\t\t\tif (!strcmp (\"width\", type)) {\n                                if (value <= 0)\n                                        RETURN (FALSE);\n\t\t\t\tww = (unsigned int) value;\n                        }\n\t\t\tif (!strcmp (\"height\", type)) {\n                                if (value <= 0)\n                                        RETURN (FALSE);\n\t\t\t\thh = (unsigned int) value;\n                        }\n\t\t\tif (!strcmp (\"hot\", type)) {\n\t\t\t\tif (type-- == name_and_type\n\t\t\t\t    || type-- == name_and_type)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!strcmp (\"x_hot\", type))\n\t\t\t\t\thx = value;\n\t\t\t\tif (!strcmp (\"y_hot\", type))\n\t\t\t\t\thy = value;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n    \n\t\tif (sscanf (line, \"static short %s = {\", name_and_type) == 1)\n\t\t\tversion10p = 1;\n\t\telse if (sscanf (line,\"static const unsigned char %s = {\",name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse if (sscanf (line,\"static unsigned char %s = {\",name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse if (sscanf (line, \"static const char %s = {\", name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse if (sscanf (line, \"static char %s = {\", name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse\n\t\t\tcontinue;\n\n\t\tif (!(type = strrchr (name_and_type, '_')))\n\t\t\ttype = name_and_type;\n\t\telse\n\t\t\ttype++;\n\n\t\tif (strcmp (\"bits[]\", type))\n\t\t\tcontinue;\n    \n\t\tif (!ww || !hh)\n\t\t\tRETURN (FALSE);\n\n\t\tif ((ww % 16) && ((ww % 16) < 9) && version10p)\n\t\t\tpadding = 1;\n\t\telse\n\t\t\tpadding = 0;\n\n\t\tbytes_per_line = (ww+7)/8 + padding;\n\n\t\tsize = bytes_per_line * hh;\n                if (size / bytes_per_line != hh) /* overflow */\n                        RETURN (FALSE);\n\t\tbits = g_malloc (size);\n\n\t\tif (version10p) {\n\t\t\tunsigned char *ptr;\n\t\t\tint bytes;\n\n\t\t\tfor (bytes = 0, ptr = bits; bytes < size; (bytes += 2)) {\n\t\t\t\tif ((value = next_int (fstream)) < 0)\n\t\t\t\t\tRETURN (FALSE);\n\t\t\t\t*(ptr++) = value;\n\t\t\t\tif (!padding || ((bytes+2) % bytes_per_line))\n\t\t\t\t\t*(ptr++) = value >> 8;\n\t\t\t}\n\t\t} else {\n\t\t\tunsigned char *ptr;\n\t\t\tint bytes;\n\n\t\t\tfor (bytes = 0, ptr = bits; bytes < size; bytes++, ptr++) {\n\t\t\t\tif ((value = next_int (fstream)) < 0) \n\t\t\t\t\tRETURN (FALSE);\n\t\t\t\t*ptr=value;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (!bits)\n\t\tRETURN (FALSE);\n\n\t*data = bits;\n\t*width = ww;\n\t*height = hh;\n\tif (x_hot)\n\t\t*x_hot = hx;\n\tif (y_hot)\n\t\t*y_hot = hy;\n\n\treturn TRUE;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <stdio.h>\n#include \"gdk-pixbuf-private.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include \"config.h\"\n#include <glib/gstdio.h>\n\n// Called Methods (top 10):\n// next_int from gdk-pixbuf/io-xbm.c:\nstatic int\nnext_int (FILE *fstream)\n{\n\tint ch;\n\tint value = 0;\n\tint gotone = 0;\n\tint done = 0;\n    \n\t/* loop, accumulate hex value until find delimiter \n\t   skip any initial delimiters found in read stream */\n\n\twhile (!done) {\n\t\tch = getc (fstream);\n\t\tif (ch == EOF) {\n\t\t\tvalue = -1;\n\t\t\tdone++;\n\t\t} else {\n\t\t\t/* trim high bits, check type and accumulate */\n\t\t\tch &= 0xff;\n\t\t\tif (g_ascii_isxdigit (ch)) {\n\t\t\t\tvalue = (value << 4) + g_ascii_xdigit_value (ch);\n\t\t\t\tgotone++;\n\t\t\t} else if ((hex_table[ch]) < 0 && gotone) {\n\t\t\t\tdone++;\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n}\n\n// MAX_SIZE from gdk-pixbuf/io-xbm.c:\n<empty>\n"
  },
  {
    "repository": "lsquic",
    "cve_id": "CVE-2022-30592",
    "cwe_list": [
      "CWE-269"
    ],
    "commit_hash": "a74702c630e108125e71898398737baec8f02238",
    "short_hash": "a74702c6",
    "vulnerableMethods_before": [
      {
        "filename": "None",
        "method_name": "vulnerable_function",
        "raw_code": "lsquic_qeh_settings (struct qpack_enc_hdl *qeh, unsigned max_table_size,\n             unsigned dyn_table_size, unsigned max_risked_streams, int server)\n{\n    enum lsqpack_enc_opts enc_opts;\n\n    assert(qeh->qeh_flags & QEH_INITIALIZED);\n\n    if (qeh->qeh_flags & QEH_HAVE_SETTINGS)\n    {\n        LSQ_WARN(\"settings already set\");\n        return -1;\n    }\n\n    enc_opts = LSQPACK_ENC_OPT_STAGE_2\n             | (server ? LSQPACK_ENC_OPT_SERVER : 0);\n    qeh->qeh_tsu_sz = sizeof(qeh->qeh_tsu_buf);\n    if (0 != lsqpack_enc_init(&qeh->qeh_encoder, (void *) qeh->qeh_conn,\n                max_table_size, dyn_table_size, max_risked_streams, enc_opts,\n                qeh->qeh_tsu_buf, &qeh->qeh_tsu_sz))\n    {\n        LSQ_INFO(\"could not initialize QPACK encoder\");\n        return -1;\n    }\n    LSQ_DEBUG(\"%zu-byte post-init TSU\", qeh->qeh_tsu_sz);\n    qeh->qeh_flags |= QEH_HAVE_SETTINGS;\n    qeh->qeh_max_prefix_size =\n                        lsqpack_enc_header_block_prefix_size(&qeh->qeh_encoder);\n    LSQ_DEBUG(\"have settings: max table size=%u; dyn table size=%u; max risked \"\n        \"streams=%u\", max_table_size, dyn_table_size, max_risked_streams);\n    if (qeh->qeh_enc_sm_out)\n        qeh_begin_out(qeh);\n    return 0;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "None",
        "method_name": "fixed_function",
        "raw_code": "lsquic_qeh_settings (struct qpack_enc_hdl *qeh, unsigned max_table_size,\n             unsigned dyn_table_size, unsigned max_risked_streams, int server)\n{\n    enum lsqpack_enc_opts enc_opts;\n\n    assert(qeh->qeh_flags & QEH_INITIALIZED);\n\n    if (qeh->qeh_flags & QEH_HAVE_SETTINGS)\n    {\n        LSQ_WARN(\"settings already set\");\n        return -1;\n    }\n\n    enc_opts = LSQPACK_ENC_OPT_STAGE_2\n             | (server ? LSQPACK_ENC_OPT_SERVER : 0);\n    qeh->qeh_tsu_sz = sizeof(qeh->qeh_tsu_buf);\n    if (QENC_MIN_DYN_TABLE_SIZE > dyn_table_size)\n        dyn_table_size = 0;\n    if (0 != lsqpack_enc_init(&qeh->qeh_encoder, (void *) qeh->qeh_conn,\n                max_table_size, dyn_table_size, max_risked_streams, enc_opts,\n                qeh->qeh_tsu_buf, &qeh->qeh_tsu_sz))\n    {\n        LSQ_INFO(\"could not initialize QPACK encoder\");\n        return -1;\n    }\n    LSQ_DEBUG(\"%zu-byte post-init TSU\", qeh->qeh_tsu_sz);\n    qeh->qeh_flags |= QEH_HAVE_SETTINGS;\n    qeh->qeh_max_prefix_size =\n                        lsqpack_enc_header_block_prefix_size(&qeh->qeh_encoder);\n    LSQ_DEBUG(\"have settings: max table size=%u; dyn table size=%u; max risked \"\n        \"streams=%u\", max_table_size, dyn_table_size, max_risked_streams);\n    if (qeh->qeh_enc_sm_out)\n        qeh_begin_out(qeh);\n    return 0;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <sys/uio.h>\n#include <lsquic_types.h>\n#include <time.h>\n#include <stdarg.h>\n#include <vc_compat.h>\n"
  },
  {
    "repository": "qemu",
    "cve_id": "CVE-2014-0142",
    "cwe_list": [
      "CWE-369"
    ],
    "commit_hash": "9302e863aa8baa5d932fc078967050c055fa1a7f",
    "short_hash": "9302e863",
    "vulnerableMethods_before": [
      {
        "filename": "None",
        "method_name": "vulnerable_function",
        "raw_code": "static int parallels_open(BlockDriverState *bs, QDict *options, int flags,\n                          Error **errp)\n{\n    BDRVParallelsState *s = bs->opaque;\n    int i;\n    struct parallels_header ph;\n    int ret;\n\n    bs->read_only = 1; // no write support yet\n\n    ret = bdrv_pread(bs->file, 0, &ph, sizeof(ph));\n    if (ret < 0) {\n        goto fail;\n    }\n\n    if (memcmp(ph.magic, HEADER_MAGIC, 16) ||\n        (le32_to_cpu(ph.version) != HEADER_VERSION)) {\n        error_setg(errp, \"Image not in Parallels format\");\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    bs->total_sectors = le32_to_cpu(ph.nb_sectors);\n\n    s->tracks = le32_to_cpu(ph.tracks);\n\n    s->catalog_size = le32_to_cpu(ph.catalog_entries);\n    if (s->catalog_size > INT_MAX / 4) {\n        error_setg(errp, \"Catalog too large\");\n        ret = -EFBIG;\n        goto fail;\n    }\n    s->catalog_bitmap = g_malloc(s->catalog_size * 4);\n\n    ret = bdrv_pread(bs->file, 64, s->catalog_bitmap, s->catalog_size * 4);\n    if (ret < 0) {\n        goto fail;\n    }\n\n    for (i = 0; i < s->catalog_size; i++)\n\tle32_to_cpus(&s->catalog_bitmap[i]);\n\n    qemu_co_mutex_init(&s->lock);\n    return 0;\n\nfail:\n    g_free(s->catalog_bitmap);\n    return ret;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "None",
        "method_name": "fixed_function",
        "raw_code": "static int parallels_open(BlockDriverState *bs, QDict *options, int flags,\n                          Error **errp)\n{\n    BDRVParallelsState *s = bs->opaque;\n    int i;\n    struct parallels_header ph;\n    int ret;\n\n    bs->read_only = 1; // no write support yet\n\n    ret = bdrv_pread(bs->file, 0, &ph, sizeof(ph));\n    if (ret < 0) {\n        goto fail;\n    }\n\n    if (memcmp(ph.magic, HEADER_MAGIC, 16) ||\n        (le32_to_cpu(ph.version) != HEADER_VERSION)) {\n        error_setg(errp, \"Image not in Parallels format\");\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    bs->total_sectors = le32_to_cpu(ph.nb_sectors);\n\n    s->tracks = le32_to_cpu(ph.tracks);\n    if (s->tracks == 0) {\n        error_setg(errp, \"Invalid image: Zero sectors per track\");\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    s->catalog_size = le32_to_cpu(ph.catalog_entries);\n    if (s->catalog_size > INT_MAX / 4) {\n        error_setg(errp, \"Catalog too large\");\n        ret = -EFBIG;\n        goto fail;\n    }\n    s->catalog_bitmap = g_malloc(s->catalog_size * 4);\n\n    ret = bdrv_pread(bs->file, 64, s->catalog_bitmap, s->catalog_size * 4);\n    if (ret < 0) {\n        goto fail;\n    }\n\n    for (i = 0; i < s->catalog_size; i++)\n\tle32_to_cpus(&s->catalog_bitmap[i]);\n\n    qemu_co_mutex_init(&s->lock);\n    return 0;\n\nfail:\n    g_free(s->catalog_bitmap);\n    return ret;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"qemu/module.h\"\n#include \"qemu-common.h\"\n#include \"block/block_int.h\"\n\n// Type Definitions:\n// BDRVParallelsState:\ntypedef struct BDRVParallelsState {\n    CoMutex lock;\n\n    uint32_t *catalog_bitmap;\n    unsigned int catalog_size;\n\n    unsigned int tracks;\n} BDRVParallelsState;\n\n// BDRVParallelsState:\ntypedef struct BDRVParallelsState {\n    CoMutex lock;\n\n    uint32_t *catalog_bitmap;\n    unsigned int catalog_size;\n\n    unsigned int tracks;\n}\n\n// parallels_header:\nstruct parallels_header {\n    char magic[16]; // \"WithoutFreeSpace\"\n    uint32_t version;\n    uint32_t heads;\n    uint32_t cylinders;\n    uint32_t tracks;\n    uint32_t catalog_entries;\n    uint32_t nb_sectors;\n    char padding[24];\n}\n\n// Called Methods (top 10):\n// HEADER_VERSION from block/parallels.c:\n<empty>\n\n// HEADER_MAGIC from block/parallels.c:\n<empty>\n"
  },
  {
    "repository": "tensorflow",
    "cve_id": "CVE-2022-23592",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "c99d98cd189839dcf51aee94e7437b54b31f8abd",
    "short_hash": "c99d98cd",
    "vulnerableMethods_before": [
      {
        "filename": "graph.cc",
        "method_name": "vulnerable_function",
        "raw_code": "void Node::RunForwardTypeInference() {\n  VLOG(4) << \"Forward type inference: \" << props_->node_def.DebugString();\n\n  if (props_->fwd_type_fn == nullptr) {\n    return;\n  }\n\n  std::vector<Node*> input_nodes(props_->input_types.size(), nullptr);\n  std::vector<int> input_idx(props_->input_types.size(), 0);\n  for (const auto& edge : in_edges_) {\n    if (edge->IsControlEdge()) {\n      continue;\n    }\n    DCHECK(edge->dst_input() < input_nodes.size()) << DebugString();\n    int i = edge->dst_input();\n    input_nodes.at(i) = edge->src();\n    input_idx.at(i) = edge->src_output();\n  }\n\n  // Note: technically, we could use a very generic type when some of the inputs\n  // are unknown. But there is an expectation that a node will have complete\n  // inputs soon, so updating intermediate types is largely unnecessary.\n\n  for (const auto* node : input_nodes) {\n    if (node == nullptr) {\n      // Incomplete inputs, bail.\n      ClearTypeInfo();\n      return;\n    }\n  }\n\n  static FullTypeDef* no_type = new FullTypeDef();\n\n  std::vector<std::reference_wrapper<const FullTypeDef>> input_types;\n  for (int i = 0; i < input_nodes.size(); i++) {\n    const auto* node = input_nodes[i];\n    if (node->def().has_experimental_type()) {\n      const auto& node_t = node->def().experimental_type();\n      if (node_t.type_id() != TFT_UNSET) {\n        int ix = input_idx[i];\n        DCHECK(ix < node_t.args_size())\n            << \"input \" << i << \" should have an output \" << ix\n            << \" but instead only has \" << node_t.args_size()\n            << \" outputs: \" << node_t.DebugString();\n        input_types.emplace_back(node_t.args(ix));\n      } else {\n        input_types.emplace_back(*no_type);\n      }\n    } else {\n      // Incomplete inputs, bail.\n      ClearTypeInfo();\n      return;\n    }\n  }\n\n  const auto infer_type = props_->fwd_type_fn(input_types);\n  const FullTypeDef infer_typedef = infer_type.ValueOrDie();\n  if (infer_typedef.type_id() != TFT_UNSET) {\n    MaybeCopyOnWrite();\n    *(props_->node_def.mutable_experimental_type()) = infer_typedef;\n  }\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "graph.cc",
        "method_name": "fixed_function",
        "raw_code": "void Node::RunForwardTypeInference() {\n  VLOG(4) << \"Forward type inference: \" << props_->node_def.DebugString();\n\n  if (props_->fwd_type_fn == nullptr) {\n    return;\n  }\n\n  std::vector<Node*> input_nodes(props_->input_types.size(), nullptr);\n  std::vector<int> input_idx(props_->input_types.size(), 0);\n  for (const auto& edge : in_edges_) {\n    if (edge->IsControlEdge()) {\n      continue;\n    }\n    DCHECK(edge->dst_input() < input_nodes.size()) << DebugString();\n    int i = edge->dst_input();\n    input_nodes.at(i) = edge->src();\n    input_idx.at(i) = edge->src_output();\n  }\n\n  // Note: technically, we could use a very generic type when some of the inputs\n  // are unknown. But there is an expectation that a node will have complete\n  // inputs soon, so updating intermediate types is largely unnecessary.\n\n  for (const auto* node : input_nodes) {\n    if (node == nullptr) {\n      // Incomplete inputs, bail.\n      ClearTypeInfo();\n      return;\n    }\n  }\n\n  static FullTypeDef* no_type = new FullTypeDef();\n\n  std::vector<std::reference_wrapper<const FullTypeDef>> input_types;\n  for (int i = 0; i < input_nodes.size(); i++) {\n    const auto* node = input_nodes[i];\n    if (node->def().has_experimental_type()) {\n      const auto& node_t = node->def().experimental_type();\n      if (node_t.type_id() != TFT_UNSET) {\n        int ix = input_idx[i];\n        if (ix >= node_t.args_size()) {\n          LOG(WARNING) << name() << \" has bad type information: input \" << i\n                       << \" should have an output \" << ix\n                       << \" but instead only has \" << node_t.args_size()\n                       << \" outputs: \" << node_t.DebugString()\n                       << \"\\nThis indicates either \"\n                          \"a bug in op registration or a corrupted graph.\";\n          ClearTypeInfo();\n          return;\n        }\n        input_types.emplace_back(node_t.args(ix));\n      } else {\n        input_types.emplace_back(*no_type);\n      }\n    } else {\n      // Incomplete inputs, bail.\n      ClearTypeInfo();\n      return;\n    }\n  }\n\n  const auto infer_type = props_->fwd_type_fn(input_types);\n  const FullTypeDef infer_typedef = infer_type.ValueOrDie();\n  if (infer_typedef.type_id() != TFT_UNSET) {\n    MaybeCopyOnWrite();\n    *(props_->node_def.mutable_experimental_type()) = infer_typedef;\n  }\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"tensorflow/core/framework/node_properties.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/framework/op_def_builder.h\"\n#include \"tensorflow/core/lib/gtl/map_util.h\"\n#include \"tensorflow/core/platform/errors.h\"\n#include <memory>\n#include \"absl/container/flat_hash_map.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/graph.pb.h\"\n#include \"tensorflow/core/public/version.h\"\n#include \"tensorflow/core/graph/while_context.h\"\n#include \"tensorflow/core/graph/graph.h\"\n#include <vector>\n#include \"tensorflow/core/lib/strings/stringprintf.h\"\n#include \"tensorflow/core/framework/versions.pb.h\"\n#include \"tensorflow/core/framework/full_type.pb.h\"\n#include \"tensorflow/core/framework/node_def.pb.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/graph/graph_node_util.h\"\n#include \"tensorflow/core/lib/hash/hash.h\"\n#include \"tensorflow/core/lib/strings/strcat.h\"\n\n// Type Definitions:\n// Node:\nclass Node {\n public:\n  // Arguments for `Node` constructor.\n  struct Args {\n    int64_t id;\n    string name;\n    std::shared_ptr<Node> output;\n  };\n\n  using Factory = std::function<std::shared_ptr<Node>(Args)>;\n  using NodeVector = std::vector<std::shared_ptr<Node>>;\n  using NodePairList =\n      std::list<std::pair<std::shared_ptr<Node>, std::shared_ptr<Node>>>;\n  using ModelParameters =\n      std::vector<std::pair<string, std::shared_ptr<Parameter>>>;\n  using NodeValues = absl::flat_hash_map<string, double>;\n  using ParameterGradients =\n      absl::flat_hash_map<std::pair<string, string>, double>;\n\n  explicit Node(Args args)\n      : id_(args.id),\n        name_(std::move(args.name)),\n        autotune_(true),\n        buffered_bytes_(0),\n        buffered_elements_(0),\n        bytes_consumed_(0),\n        bytes_produced_(0),\n        num_elements_(0),\n        processing_time_(0),\n        record_metrics_(true),\n        metrics_(name_),\n        output_(args.output.get()) {}\n\n  virtual ~No...\n\n// Node:\ntensorflow.Node.Node:ANY()\n\n// EdgeSet:\nclass EdgeSet {\n public:\n  EdgeSet();\n  ~EdgeSet();\n\n  typedef const Edge* key_type;\n  typedef const Edge* value_type;\n  typedef size_t size_type;\n  typedef ptrdiff_t difference_type;\n\n  class const_iterator;\n  typedef const_iterator iterator;\n\n  bool empty() const;\n  size_type size() const;\n  void clear();\n  std::pair<iterator, bool> insert(value_type value);\n  size_type erase(key_type key);\n  void reserve(size_type new_size) {\n    if (new_size > kInline) {\n      auto s = new gtl::FlatSet<const Edge*>(new_size);\n      s->insert(reinterpret_cast<const Edge**>(std::begin(ptrs_)),\n                reinterpret_cast<const Edge**>(&ptrs_[0] + size()));\n      ptrs_[0] = this;\n      ptrs_[1] = s;\n    }\n  }\n\n  // Caller is not allowed to mutate the EdgeSet while iterating.\n  const_iterator begin() const;\n  const_iterator end() const;\n\n private:\n  // Up to kInline elements are stored directly in ptrs_ (nullptr means none).\n  // If ptrs_[0] == this then ptrs_[1] points to a set<const Edge*>.\n ...\n\n// iterator:\ntypedef const_iterator iterator;\n\n// Called Methods (top 10):\n// dst_input from tensorflow/core/graph/graph.h:\n  int dst_input() const { return dst_input_; } /* <=== tensorflow.Edge.dst_input:int()<const> */ \n\n// DCHECK from tensorflow/core/graph/tensorflow/core/graph/tensorflow/core/framework/absl/types/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/platform/logging.h:\n\n\n// ClearTypeInfo from tensorflow/core/graph/graph.cc:\nvoid Node::ClearTypeInfo() { /* <=== tensorflow.Node.ClearTypeInfo:void() */ \n  if (props_->node_def.has_experimental_type()) {\n    MaybeCopyOnWrite();\n    props_->node_def.clear_experimental_type();\n  }\n}\n\n// MaybeCopyOnWrite from tensorflow/core/graph/graph.cc:\nvoid Node::MaybeCopyOnWrite() { /* <=== tensorflow.Node.MaybeCopyOnWrite:void() */ \n  // TODO(mdan): As nodes become more dynamic, this may not be worth the cost.\n  // NodeProperties may be shared between Nodes. Make a copy if so.\n  if (!props_.unique()) {\n    props_ = std::make_shared<NodeProperties>(*props_);\n  }\n}\n\n// IsControlEdge from tensorflow/core/graph/graph.h:\ninline bool Edge::IsControlEdge() const { /* <=== tensorflow.Edge.IsControlEdge:bool()<const> */ \n  // Note that if either src_output_ or dst_input_ is kControlSlot,\n  // so is the other one (AddEdge checks this).\n  return src_output_ == Graph::kControlSlot;\n}\n\n// LOG from tensorflow/core/graph/tensorflow/core/graph/tensorflow/core/framework/absl/types/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/framework/tensorflow/core/framework/tensorflow/core/platform/tensorflow/core/platform/logging.h:\n\n"
  },
  {
    "repository": "u-boot",
    "cve_id": "CVE-2022-34835",
    "cwe_list": [
      "CWE-787"
    ],
    "commit_hash": "8f8c04bf1ebbd2f72f1643e7ad9617dafa6e5409",
    "short_hash": "8f8c04bf",
    "vulnerableMethods_before": [
      {
        "filename": "i2c.c",
        "method_name": "vulnerable_function",
        "raw_code": "static int do_i2c_md(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t     char *const argv[])\n{\n\tuint\tchip;\n\tuint\taddr, length;\n\tint alen;\n\tint\tj, nbytes, linebytes;\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\n\t/* We use the last specified parameters, unless new ones are\n\t * entered.\n\t */\n\tchip   = i2c_dp_last_chip;\n\taddr   = i2c_dp_last_addr;\n\talen   = i2c_dp_last_alen;\n\tlength = i2c_dp_last_length;\n\n\tif (argc < 3)\n\t\treturn CMD_RET_USAGE;\n\n\tif ((flag & CMD_FLAG_REPEAT) == 0) {\n\t\t/*\n\t\t * New command specified.\n\t\t */\n\n\t\t/*\n\t\t * I2C chip address\n\t\t */\n\t\tchip = hextoul(argv[1], NULL);\n\n\t\t/*\n\t\t * I2C data address within the chip.  This can be 1 or\n\t\t * 2 bytes long.  Some day it might be 3 bytes long :-).\n\t\t */\n\t\taddr = hextoul(argv[2], NULL);\n\t\talen = get_alen(argv[2], DEFAULT_ADDR_LEN);\n\t\tif (alen > 3)\n\t\t\treturn CMD_RET_USAGE;\n\n\t\t/*\n\t\t * If another parameter, it is the length to display.\n\t\t * Length is the number of objects, not number of bytes.\n\t\t */\n\t\tif (argc > 3)\n\t\t\tlength = hextoul(argv[3], NULL);\n\t}\n\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n#endif\n\n\t/*\n\t * Print the lines.\n\t *\n\t * We buffer all read data, so we can make sure data is read only\n\t * once.\n\t */\n\tnbytes = length;\n\tdo {\n\t\tunsigned char\tlinebuf[DISP_LINE_LEN];\n\t\tunsigned char\t*cp;\n\n\t\tlinebytes = (nbytes > DISP_LINE_LEN) ? DISP_LINE_LEN : nbytes;\n\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tret = dm_i2c_read(dev, addr, linebuf, linebytes);\n#else\n\t\tret = i2c_read(chip, addr, alen, linebuf, linebytes);\n#endif\n\t\tif (ret)\n\t\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n\t\telse {\n\t\t\tprintf(\"%04x:\", addr);\n\t\t\tcp = linebuf;\n\t\t\tfor (j=0; j<linebytes; j++) {\n\t\t\t\tprintf(\" %02x\", *cp++);\n\t\t\t\taddr++;\n\t\t\t}\n\t\t\tputs (\"    \");\n\t\t\tcp = linebuf;\n\t\t\tfor (j=0; j<linebytes; j++) {\n\t\t\t\tif ((*cp < 0x20) || (*cp > 0x7e))\n\t\t\t\t\tputs (\".\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%c\", *cp);\n\t\t\t\tcp++;\n\t\t\t}\n\t\t\tputc ('\\n');\n\t\t}\n\t\tnbytes -= linebytes;\n\t} while (nbytes > 0);\n\n\ti2c_dp_last_chip   = chip;\n\ti2c_dp_last_addr   = addr;\n\ti2c_dp_last_alen   = alen;\n\ti2c_dp_last_length = length;\n\n\treturn 0;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "i2c.c",
        "method_name": "fixed_function",
        "raw_code": "static int do_i2c_md(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t     char *const argv[])\n{\n\tuint\tchip;\n\tuint\taddr, length;\n\tuint\talen;\n\tuint\tj, nbytes, linebytes;\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\n\t/* We use the last specified parameters, unless new ones are\n\t * entered.\n\t */\n\tchip   = i2c_dp_last_chip;\n\taddr   = i2c_dp_last_addr;\n\talen   = i2c_dp_last_alen;\n\tlength = i2c_dp_last_length;\n\n\tif (argc < 3)\n\t\treturn CMD_RET_USAGE;\n\n\tif ((flag & CMD_FLAG_REPEAT) == 0) {\n\t\t/*\n\t\t * New command specified.\n\t\t */\n\n\t\t/*\n\t\t * I2C chip address\n\t\t */\n\t\tchip = hextoul(argv[1], NULL);\n\n\t\t/*\n\t\t * I2C data address within the chip.  This can be 1 or\n\t\t * 2 bytes long.  Some day it might be 3 bytes long :-).\n\t\t */\n\t\taddr = hextoul(argv[2], NULL);\n\t\talen = get_alen(argv[2], DEFAULT_ADDR_LEN);\n\t\tif (alen > 3)\n\t\t\treturn CMD_RET_USAGE;\n\n\t\t/*\n\t\t * If another parameter, it is the length to display.\n\t\t * Length is the number of objects, not number of bytes.\n\t\t */\n\t\tif (argc > 3)\n\t\t\tlength = hextoul(argv[3], NULL);\n\t}\n\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n#endif\n\n\t/*\n\t * Print the lines.\n\t *\n\t * We buffer all read data, so we can make sure data is read only\n\t * once.\n\t */\n\tnbytes = length;\n\tdo {\n\t\tunsigned char\tlinebuf[DISP_LINE_LEN];\n\t\tunsigned char\t*cp;\n\n\t\tlinebytes = (nbytes > DISP_LINE_LEN) ? DISP_LINE_LEN : nbytes;\n\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tret = dm_i2c_read(dev, addr, linebuf, linebytes);\n#else\n\t\tret = i2c_read(chip, addr, alen, linebuf, linebytes);\n#endif\n\t\tif (ret)\n\t\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n\t\telse {\n\t\t\tprintf(\"%04x:\", addr);\n\t\t\tcp = linebuf;\n\t\t\tfor (j=0; j<linebytes; j++) {\n\t\t\t\tprintf(\" %02x\", *cp++);\n\t\t\t\taddr++;\n\t\t\t}\n\t\t\tputs (\"    \");\n\t\t\tcp = linebuf;\n\t\t\tfor (j=0; j<linebytes; j++) {\n\t\t\t\tif ((*cp < 0x20) || (*cp > 0x7e))\n\t\t\t\t\tputs (\".\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%c\", *cp);\n\t\t\t\tcp++;\n\t\t\t}\n\t\t\tputc ('\\n');\n\t\t}\n\t\tnbytes -= linebytes;\n\t} while (nbytes > 0);\n\n\ti2c_dp_last_chip   = chip;\n\ti2c_dp_last_addr   = addr;\n\ti2c_dp_last_alen   = alen;\n\ti2c_dp_last_length = length;\n\n\treturn 0;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <dm.h>\n#include <malloc.h>\n#include <asm/byteorder.h>\n#include <linux/compiler.h>\n#include <linux/delay.h>\n#include <edid.h>\n#include <console.h>\n#include <errno.h>\n#include <log.h>\n#include <bootretry.h>\n#include <cli.h>\n#include <common.h>\n#include <u-boot/crc.h>\n#include <i2c.h>\n#include <command.h>\n\n// Type Definitions:\n// uint:\ntypedef unsigned int uint;\n\n// uint:\ntypedef unsigned int\t\tuint;\n"
  },
  {
    "repository": "tensorflow",
    "cve_id": "CVE-2022-23573",
    "cwe_list": [
      "CWE-908"
    ],
    "commit_hash": "ef1d027be116f25e25bb94a60da491c2cf55bd0b",
    "short_hash": "ef1d027b",
    "vulnerableMethods_before": [
      {
        "filename": "assign_op.h",
        "method_name": "vulnerable_function",
        "raw_code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& rhs = context->input(1);\n\n    // We always return the input ref.\n    context->forward_ref_input_to_ref_output(0, 0);\n\n    // We can't always know how this value will be used downstream, so make\n    // conservative assumptions in specifying constraints on the memory\n    // allocation attributes, unless the Grappler graph analysis determined that\n    // it was safe not to.\n    AllocatorAttributes attr;\n    if (!relax_constraints_) {\n      attr.set_gpu_compatible(true);\n      attr.set_nic_compatible(true);\n    }\n\n    {\n      mutex_lock l(*context->input_ref_mutex(0));\n      const Tensor& old_lhs = context->mutable_input(0, /* lock_held */ true);\n      const bool same_shape = old_lhs.shape().IsSameSize(rhs.shape());\n      if (validate_shape_) {\n        OP_REQUIRES(context, same_shape,\n                    errors::InvalidArgument(\n                        \"Assign requires shapes of both tensors to match. \"\n                        \"lhs shape= \",\n                        old_lhs.shape().DebugString(),\n                        \" rhs shape= \", rhs.shape().DebugString()));\n      }\n\n      // In the code below we try to minimize the amount of memory allocation\n      // and copying by trying the following two shortcuts:\n      // 1. If the lhs is initialized and has the same number of elements as\n      //    the rhs we can avoid a memory allocation.\n      // 2. If we can reuse the rhs buffer we avoid both a memory allocation\n      //    and copying.\n\n      // 1. Try to copy into an existing buffer.\n      if (old_lhs.IsInitialized() &&\n          old_lhs.shape().num_elements() == rhs.shape().num_elements()) {\n        // The existing lhs tensor has already been initialized and the right\n        // hand side can fit in the underlying buffer.\n        Tensor reshaped_old_lhs;\n        if (same_shape) {\n          reshaped_old_lhs = old_lhs;\n        } else {\n          CHECK(reshaped_old_lhs.CopyFrom(old_lhs, rhs.shape()));\n          context->replace_ref_input(0, reshaped_old_lhs,\n                                     /* lock_held */ true);\n        }\n        if (use_exclusive_lock_) {\n          Copy(context, &reshaped_old_lhs, rhs);\n          return;\n        }\n      } else {\n        // 2. Try to reuse the rhs.\n        std::unique_ptr<Tensor> input_alias = context->forward_input(\n            1, OpKernelContext::Params::kNoReservation /*output_index*/,\n            rhs.dtype(), rhs.shape(), DEVICE_MEMORY, attr);\n        if (input_alias != nullptr) {\n          // Update the ref to point to the new buffer.\n          context->replace_ref_input(0, *input_alias, /* lock_held */ true);\n          return;\n        }\n\n        // Otherwise, create a new tensor whose shape matches the\n        // right hand side, hand off to lhs and copy the rhs into it.\n        Tensor copy_tensor;\n        OP_REQUIRES_OK(context,\n                       context->allocate_temp(old_lhs.dtype(), rhs.shape(),\n                                              &copy_tensor, attr));\n        // We track memory of variables in variable ops instead of in this\n        // assign op.\n        context->clear_recorded_memory();\n        context->replace_ref_input(0, copy_tensor, /* lock_held */ true);\n        if (use_exclusive_lock_) {\n          Copy(context, &copy_tensor, rhs);\n          return;\n        }\n      }\n    }\n\n    // The tensor has already been initialized and the right hand side\n    // matches the left hand side's shape. We have been told to do the\n    // copy outside the lock.\n    Tensor old_unlocked_lhs = context->mutable_input(0, /* lock_held */ false);\n    Copy(context, &old_unlocked_lhs, rhs);\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "assign_op.h",
        "method_name": "fixed_function",
        "raw_code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& rhs = context->input(1);\n\n    // We always return the input ref.\n    context->forward_ref_input_to_ref_output(0, 0);\n\n    // Prevent copying uninitialized data, to solve harder to debug undefined\n    // behaviors that cannot be traced back to the original tensor.\n    OP_REQUIRES(\n        context, rhs.IsInitialized(),\n        errors::Internal(\"Right hand side of AssignOp is not initialized\"));\n\n    // We can't always know how this value will be used downstream, so make\n    // conservative assumptions in specifying constraints on the memory\n    // allocation attributes, unless the Grappler graph analysis determined that\n    // it was safe not to.\n    AllocatorAttributes attr;\n    if (!relax_constraints_) {\n      attr.set_gpu_compatible(true);\n      attr.set_nic_compatible(true);\n    }\n\n    {\n      mutex_lock l(*context->input_ref_mutex(0));\n      const Tensor& old_lhs = context->mutable_input(0, /* lock_held */ true);\n      const bool same_shape = old_lhs.shape().IsSameSize(rhs.shape());\n      if (validate_shape_) {\n        OP_REQUIRES(context, same_shape,\n                    errors::InvalidArgument(\n                        \"Assign requires shapes of both tensors to match. \"\n                        \"lhs shape= \",\n                        old_lhs.shape().DebugString(),\n                        \" rhs shape= \", rhs.shape().DebugString()));\n      }\n\n      // In the code below we try to minimize the amount of memory allocation\n      // and copying by trying the following two shortcuts:\n      // 1. If the lhs is initialized and has the same number of elements as\n      //    the rhs we can avoid a memory allocation.\n      // 2. If we can reuse the rhs buffer we avoid both a memory allocation\n      //    and copying.\n\n      // 1. Try to copy into an existing buffer.\n      if (old_lhs.IsInitialized() &&\n          old_lhs.shape().num_elements() == rhs.shape().num_elements()) {\n        // The existing lhs tensor has already been initialized and the right\n        // hand side can fit in the underlying buffer.\n        Tensor reshaped_old_lhs;\n        if (same_shape) {\n          reshaped_old_lhs = old_lhs;\n        } else {\n          CHECK(reshaped_old_lhs.CopyFrom(old_lhs, rhs.shape()));\n          context->replace_ref_input(0, reshaped_old_lhs,\n                                     /* lock_held */ true);\n        }\n        if (use_exclusive_lock_) {\n          Copy(context, &reshaped_old_lhs, rhs);\n          return;\n        }\n      } else {\n        // 2. Try to reuse the rhs.\n        std::unique_ptr<Tensor> input_alias = context->forward_input(\n            1, OpKernelContext::Params::kNoReservation /*output_index*/,\n            rhs.dtype(), rhs.shape(), DEVICE_MEMORY, attr);\n        if (input_alias != nullptr) {\n          // Update the ref to point to the new buffer.\n          context->replace_ref_input(0, *input_alias, /* lock_held */ true);\n          return;\n        }\n\n        // Otherwise, create a new tensor whose shape matches the\n        // right hand side, hand off to lhs and copy the rhs into it.\n        Tensor copy_tensor;\n        OP_REQUIRES_OK(context,\n                       context->allocate_temp(old_lhs.dtype(), rhs.shape(),\n                                              &copy_tensor, attr));\n        // We track memory of variables in variable ops instead of in this\n        // assign op.\n        context->clear_recorded_memory();\n        context->replace_ref_input(0, copy_tensor, /* lock_held */ true);\n        if (use_exclusive_lock_) {\n          Copy(context, &copy_tensor, rhs);\n          return;\n        }\n      }\n    }\n\n    // The tensor has already been initialized and the right hand side\n    // matches the left hand side's shape. We have been told to do the\n    // copy outside the lock.\n    Tensor old_unlocked_lhs = context->mutable_input(0, /* lock_held */ false);\n    Copy(context, &old_unlocked_lhs, rhs);\n  }",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include \"tensorflow/core/framework/tensor_types.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n"
  },
  {
    "repository": "radare2",
    "cve_id": "CVE-2022-1452",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "ecc44b6a2f18ee70ac133365de0e509d26d5e168",
    "short_hash": "ecc44b6a",
    "vulnerableMethods_before": [
      {
        "filename": "class.c",
        "method_name": "vulnerable_function",
        "raw_code": "R_API RBinJavaAttrInfo *r_bin_java_bootstrap_methods_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tRBinJavaBootStrapMethod *bsm = NULL;\n\tut64 offset = 0;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tif (attr) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_BOOTSTRAP_METHODS_ATTR;\n\t\tattr->info.bootstrap_methods_attr.num_bootstrap_methods = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tattr->info.bootstrap_methods_attr.bootstrap_methods = r_list_newf (r_bin_java_bootstrap_method_free);\n\t\tfor (i = 0; i < attr->info.bootstrap_methods_attr.num_bootstrap_methods; i++) {\n\t\t\t// bsm = r_bin_java_bootstrap_method_new (bin, bin->b->cur);\n\t\t\tif (offset >= sz) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbsm = r_bin_java_bootstrap_method_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tif (bsm) {\n\t\t\t\toffset += bsm->size;\n\t\t\t\tr_list_append (attr->info.bootstrap_methods_attr.bootstrap_methods, (void *) bsm);\n\t\t\t} else {\n\t\t\t\t// TODO eprintf Failed to read the %d boot strap method.\n\t\t\t}\n\t\t}\n\t\tattr->size = offset;\n\t}\n\treturn attr;\n}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "class.c",
        "method_name": "fixed_function",
        "raw_code": "R_API RBinJavaAttrInfo *r_bin_java_bootstrap_methods_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tRBinJavaBootStrapMethod *bsm = NULL;\n\tut64 offset = 0;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tif (attr) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_BOOTSTRAP_METHODS_ATTR;\n\t\tif (offset + 8 > sz)  {\n\t\t\tfree (attr);\n\t\t\treturn NULL;\n\t\t}\n\t\tattr->info.bootstrap_methods_attr.num_bootstrap_methods = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tattr->info.bootstrap_methods_attr.bootstrap_methods = r_list_newf (r_bin_java_bootstrap_method_free);\n\t\tfor (i = 0; i < attr->info.bootstrap_methods_attr.num_bootstrap_methods; i++) {\n\t\t\t// bsm = r_bin_java_bootstrap_method_new (bin, bin->b->cur);\n\t\t\tif (offset >= sz) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbsm = r_bin_java_bootstrap_method_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tif (bsm) {\n\t\t\t\toffset += bsm->size;\n\t\t\t\tr_list_append (attr->info.bootstrap_methods_attr.bootstrap_methods, (void *) bsm);\n\t\t\t} else {\n\t\t\t\t// TODO eprintf Failed to read the %d boot strap method.\n\t\t\t}\n\t\t}\n\t\tattr->size = offset;\n\t}\n\treturn attr;\n}",
        "start_line": 1
      }
    ],
    "code_context": "// Import Context:\n#include <stdlib.h>\n#include <sdb.h>\n#include <math.h>\n#include <stdarg.h>\n#include \"class.h\"\n#include <string.h>\n#include <r_types.h>\n#include <r_bin.h>\n#include <stdio.h>\n#include <r_util.h>\n\n// Type Definitions:\n// RBinJavaAttrInfo:\ntypedef struct r_bin_java_attr_t {\n\tut8 *bytes;\n\tut64 pos;\n\tut64 size;\n\tchar *name;\n\tut64 file_offset;\n\tRBinJavaMetaInfo *metas;\n\tint type;\n\tut16 name_idx; //\tut16 attribute_name_idx;\n\tut32 length;   //ut16 attribute_length;\n\tut64 loadaddr;\n\tbool is_attr_in_old_format;\n\tunion {\n\t\tRBinJavaAnnotationDefaultAttr annotation_default_attr;\n\t\tRBinJavaBootstrapMethodsAttr bootstrap_methods_attr;\n\t\tRBinJavaCodeAttr code_attr;\n\t\tRBinJavaConstantValueAttr constant_value_attr;\n\t\tRBinJavaEnclosingMethodAttr enclosing_method_attr;\n\t\tRBinJavaExceptionsAttr exceptions_attr;\n\t\tRBinJavaLineNumberTableAttribute line_number_table_attr;\n\t\tRBinJavaLocalVariableTableAttribute local_variable_table_attr;\n\t\tRBinJavaLocalVariableTypeTableAttribute local_variable_type_table_attr;\n\t\tRBinJavaInnerClassesAttribute inner_classes_attr;\n\n\t\tRBinJavaAnnotationsArray annotation_array;\n\t\tRBinJavaRuntimeVisibleAnnotationsAttr rtv_annotations_attr;\n\t\tRBinJavaRuntimeInvisibleAnnotationsAttr rti_annotations_attr;\n\n\t\tRBinJav...\n\n// r_bin_java_boot_strap_method_t:\ntypedef struct r_bin_java_boot_strap_method_t{\n\tut64 file_offset;\n\tut64 size;\n\tut16 bootstrap_method_ref;\n\tut16 num_bootstrap_arguments;\n\t// List of RBinJavaCodeAttribute\n\tRList *bootstrap_arguments;\n}\n\n// r_bin_java_attr_t:\ntypedef struct r_bin_java_attr_t {\n\tut8 *bytes;\n\tut64 pos;\n\tut64 size;\n\tchar *name;\n\tut64 file_offset;\n\tRBinJavaMetaInfo *metas;\n\tint type;\n\tut16 name_idx; //\tut16 attribute_name_idx;\n\tut32 length;   //ut16 attribute_length;\n\tut64 loadaddr;\n\tbool is_attr_in_old_format;\n\tunion {\n\t\tRBinJavaAnnotationDefaultAttr annotation_default_attr;\n\t\tRBinJavaBootstrapMethodsAttr bootstrap_methods_attr;\n\t\tRBinJavaCodeAttr code_attr;\n\t\tRBinJavaConstantValueAttr constant_value_attr;\n\t\tRBinJavaEnclosingMethodAttr enclosing_method_attr;\n\t\tRBinJavaExceptionsAttr exceptions_attr;\n\t\tRBinJavaLineNumberTableAttribute line_number_table_attr;\n\t\tRBinJavaLocalVariableTableAttribute local_variable_table_attr;\n\t\tRBinJavaLocalVariableTypeTableAttribute local_variable_type_table_attr;\n\t\tRBinJavaInnerClassesAttribute inner_classes_attr;\n\n\t\tRBinJavaAnnotationsArray annotation_array;\n\t\tRBinJavaRuntimeVisibleAnnotationsAttr rtv_annotations_attr;\n\t\tRBinJavaRuntimeInvisibleAnnotationsAttr rti_annotations_attr;\n\n\t\tRBinJav...\n\n// RBinJavaBootStrapMethod:\ntypedef struct r_bin_java_boot_strap_method_t{\n\tut64 file_offset;\n\tut64 size;\n\tut16 bootstrap_method_ref;\n\tut16 num_bootstrap_arguments;\n\t// List of RBinJavaCodeAttribute\n\tRList *bootstrap_arguments;\n} RBinJavaBootStrapMethod;\n\n// RBinJavaObj:\ntypedef struct r_bin_java_obj_t {\n\tstruct r_bin_java_classfile_t cf;\n\tRBinJavaClass2 cf2;\n\tconst char *lang;\n\n\tut64 cp_offset, fields_offset, interfaces_offset;\n\tut64 classes_offset, methods_offset, attrs_offset;\n\tut32 cp_size, cp_count;\n\tut32 fields_size, fields_count;\n\tut32 interfaces_size, interfaces_count;\n\tut32 methods_size, methods_count;\n\tut32 classes_size, classes_count;\n\tut32 attrs_size, attrs_count;\n\n\tut64 loadaddr; // load address that is used to calc actual offset\n\t\t\t\t// when multiple bins are loaded at once\n\tint size;\n\tint calc_size;\n\tchar* file;\n\tRBinJavaLines lines;\n\n\t// These state variables are used for parsing the appropriate number of bytes\n\t// when readin uoffset, ustack, ulocalvar values\n\tut8 ulocalvar_sz;\n\tut8 ustack_sz;\n\tut8 offset_sz;\n\tut32 cur_method_code_length;\n\tRBinJavaAttrInfo *current_code_attr;\n\n\tut32 attr_idx;\n\tut32 method_idx;\n\tut32 field_idx;\n\tut32 cp_idx;\n\tut32 interface_idx;\n\tut32 attributes_idx;\n\n\t//ut32 classes_idx; //TODO: when classes list is ...\n\n// Called Methods (top 10):\n// r_bin_java_default_attr_new from shlr/java/class.c:\nRBinJavaAttrInfo *r_bin_java_default_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\t// NOTE: this function receives the buffer offset in the original buffer,\n\t// but the buffer is already point to that particular offset.\n\t// XXX - all the code that relies on this function should probably be modified\n\t// so that the original buffer pointer is passed in and then the buffer+buf_offset\n\t// points to the correct location.\n\tRBinJavaAttrInfo *attr = R_NEW0 (RBinJavaAttrInfo);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\tRBinJavaAttrMetas *type_info = NULL;\n\tattr->metas = R_NEW0 (RBinJavaMetaInfo);\n\tif (!attr->metas) {\n\t\tfree (attr);\n\t\treturn NULL;\n\t}\n\tattr->is_attr_in_old_format = r_bin_java_is_old_format(bin);\n\tattr->file_offset = buf_offset;\n\tattr->name_idx = R_BIN_JAVA_USHORT (buffer, 0);\n\tattr->length = R_BIN_JAVA_UINT (buffer, 2);\n\tattr->size = R_BIN_JAVA_UINT (buffer, 2) + 6;\n\tattr->name = r_bin_java_get_utf8_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, attr->name_idx);\n\tif (!a...\n\n// r_bin_java_bootstrap_method_new from shlr/java/class.c:\nRBinJavaBootStrapMethod *r_bin_java_bootstrap_method_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tRBinJavaBootStrapArgument *bsm_arg = NULL;\n\tut32 i = 0;\n\tut64 offset = 0;\n\tRBinJavaBootStrapMethod *bsm = R_NEW0 (RBinJavaBootStrapMethod);\n\tif (!bsm) {\n\t\t// TODO eprintf failed to allocate bytes for bootstrap_method.\n\t\treturn bsm;\n\t}\n\tmemset (bsm, 0, sizeof (RBinJavaBootStrapMethod));\n\tbsm->file_offset = buf_offset;\n\tbsm->bootstrap_method_ref = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tbsm->num_bootstrap_arguments = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tbsm->bootstrap_arguments = r_list_new ();\n\tfor (i = 0; i < bsm->num_bootstrap_arguments; i++) {\n\t\tif (offset >= sz) {\n\t\t\tbreak;\n\t\t}\n\t\t// bsm_arg = r_bin_java_bootstrap_method_argument_new (bin, bin->b->cur);\n\t\tbsm_arg = r_bin_java_bootstrap_method_argument_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\tif (bsm_arg) {\n\t\t\toffset += bsm_arg->size;\n\t\t\tr_list_append (bsm->bootstrap_arguments, (void *) bsm_a...\n\n// R_BIN_JAVA_USHORT from shlr/java/class.h:\n<empty>\n"
  },
  {
    "repository": "vim",
    "cve_id": "CVE-2022-1154",
    "cwe_list": [
      "CWE-416"
    ],
    "commit_hash": "b55986c52d4cd88a22d0b0b0e8a79547ba13e1d5",
    "short_hash": "b55986c5",
    "vulnerableMethods_before": [
      {
        "filename": "regexp_bt.c",
        "method_name": "vulnerable_function",
        "raw_code": "regmatch(\n    char_u\t*scan,\t\t    // Current node.\n    proftime_T\t*tm UNUSED,\t    // timeout limit or NULL\n    int\t\t*timed_out UNUSED)  // flag set on timeout or NULL\n{\n  char_u\t*next;\t\t// Next node.\n  int\t\top;\n  int\t\tc;\n  regitem_T\t*rp;\n  int\t\tno;\n  int\t\tstatus;\t\t// one of the RA_ values:\n#ifdef FEAT_RELTIME\n  int\t\ttm_count = 0;\n#endif\n\n  // Make \"regstack\" and \"backpos\" empty.  They are allocated and freed in\n  // bt_regexec_both() to reduce malloc()/free() calls.\n  regstack.ga_len = 0;\n  backpos.ga_len = 0;\n\n  // Repeat until \"regstack\" is empty.\n  for (;;)\n  {\n    // Some patterns may take a long time to match, e.g., \"\\([a-z]\\+\\)\\+Q\".\n    // Allow interrupting them with CTRL-C.\n    fast_breakcheck();\n\n#ifdef DEBUG\n    if (scan != NULL && regnarrate)\n    {\n\tmch_errmsg((char *)regprop(scan));\n\tmch_errmsg(\"(\\n\");\n    }\n#endif\n\n    // Repeat for items that can be matched sequentially, without using the\n    // regstack.\n    for (;;)\n    {\n\tif (got_int || scan == NULL)\n\t{\n\t    status = RA_FAIL;\n\t    break;\n\t}\n#ifdef FEAT_RELTIME\n\t// Check for timeout once in a 100 times to avoid overhead.\n\tif (tm != NULL && ++tm_count == 100)\n\t{\n\t    tm_count = 0;\n\t    if (profile_passed_limit(tm))\n\t    {\n\t\tif (timed_out != NULL)\n\t\t    *timed_out = TRUE;\n\t\tstatus = RA_FAIL;\n\t\tbreak;\n\t    }\n\t}\n#endif\n\tstatus = RA_CONT;\n\n#ifdef DEBUG\n\tif (regnarrate)\n\t{\n\t    mch_errmsg((char *)regprop(scan));\n\t    mch_errmsg(\"...\\n\");\n# ifdef FEAT_SYN_HL\n\t    if (re_extmatch_in != NULL)\n\t    {\n\t\tint i;\n\n\t\tmch_errmsg(_(\"External submatches:\\n\"));\n\t\tfor (i = 0; i < NSUBEXP; i++)\n\t\t{\n\t\t    mch_errmsg(\"    \\\"\");\n\t\t    if (re_extmatch_in->matches[i] != NULL)\n\t\t\tmch_errmsg((char *)re_extmatch_in->matches[i]);\n\t\t    mch_errmsg(\"\\\"\\n\");\n\t\t}\n\t    }\n# endif\n\t}\n#endif\n\tnext = regnext(scan);\n\n\top = OP(scan);\n\t// Check for character class with NL added.\n\tif (!rex.reg_line_lbr && WITH_NL(op) && REG_MULTI\n\t\t\t     && *rex.input == NUL && rex.lnum <= rex.reg_maxline)\n\t{\n\t    reg_nextline();\n\t}\n\telse if (rex.reg_line_lbr && WITH_NL(op) && *rex.input == '\\n')\n\t{\n\t    ADVANCE_REGINPUT();\n\t}\n\telse\n\t{\n\t  if (WITH_NL(op))\n\t      op -= ADD_NL;\n\t  if (has_mbyte)\n\t      c = (*mb_ptr2char)(rex.input);\n\t  else\n\t      c = *rex.input;\n\t  switch (op)\n\t  {\n\t  case BOL:\n\t    if (rex.input != rex.line)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case EOL:\n\t    if (c != NUL)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case RE_BOF:\n\t    // We're not at the beginning of the file when below the first\n\t    // line where we started, not at the start of the line or we\n\t    // didn't start at the first line of the buffer.\n\t    if (rex.lnum != 0 || rex.input != rex.line\n\t\t\t\t       || (REG_MULTI && rex.reg_firstlnum > 1))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case RE_EOF:\n\t    if (rex.lnum != rex.reg_maxline || c != NUL)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case CURSOR:\n\t    // Check if the buffer is in a window and compare the\n\t    // rex.reg_win->w_cursor position to the match position.\n\t    if (rex.reg_win == NULL\n\t\t    || (rex.lnum + rex.reg_firstlnum\n\t\t\t\t\t\t != rex.reg_win->w_cursor.lnum)\n\t\t    || ((colnr_T)(rex.input - rex.line)\n\t\t\t\t\t\t != rex.reg_win->w_cursor.col))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case RE_MARK:\n\t    // Compare the mark position to the match position.\n\t    {\n\t\tint\tmark = OPERAND(scan)[0];\n\t\tint\tcmp = OPERAND(scan)[1];\n\t\tpos_T\t*pos;\n\n\t\tpos = getmark_buf(rex.reg_buf, mark, FALSE);\n\t\tif (pos == NULL\t\t     // mark doesn't exist\n\t\t\t|| pos->lnum <= 0)   // mark isn't set in reg_buf\n\t\t{\n\t\t    status = RA_NOMATCH;\n\t\t}\n\t\telse\n\t\t{\n\t\t    colnr_T pos_col = pos->lnum == rex.lnum + rex.reg_firstlnum\n\t\t\t\t\t\t\t  && pos->col == MAXCOL\n\t\t\t\t      ? (colnr_T)STRLEN(reg_getline(\n\t\t\t\t\t\tpos->lnum - rex.reg_firstlnum))\n\t\t\t\t      : pos->col;\n\n\t\t    if ((pos->lnum == rex.lnum + rex.reg_firstlnum\n\t\t\t\t? (pos_col == (colnr_T)(rex.input - rex.line)\n\t\t\t\t    ? (cmp == '<' || cmp == '>')\n\t\t\t\t    : (pos_col < (colnr_T)(rex.input - rex.line)\n\t\t\t\t\t? cmp != '>'\n\t\t\t\t\t: cmp != '<'))\n\t\t\t\t: (pos->lnum < rex.lnum + rex.reg_firstlnum\n\t\t\t\t    ? cmp != '>'\n\t\t\t\t    : cmp != '<')))\n\t\t    status = RA_NOMATCH;\n\t\t}\n\t    }\n\t    break;\n\n\t  case RE_VISUAL:\n\t    if (!reg_match_visual())\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case RE_LNUM:\n\t    if (!REG_MULTI || !re_num_cmp((long_u)(rex.lnum + rex.reg_firstlnum),\n\t\t\t\t\t\t\t\t\tscan))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case RE_COL:\n\t    if (!re_num_cmp((long_u)(rex.input - rex.line) + 1, scan))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case RE_VCOL:\n\t    if (!re_num_cmp((long_u)win_linetabsize(\n\t\t\t    rex.reg_win == NULL ? curwin : rex.reg_win,\n\t\t\t    rex.line, (colnr_T)(rex.input - rex.line)) + 1, scan))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case BOW:\t// \\<word; rex.input points to w\n\t    if (c == NUL)\t// Can't match at end of line\n\t\tstatus = RA_NOMATCH;\n\t    else if (has_mbyte)\n\t    {\n\t\tint this_class;\n\n\t\t// Get class of current and previous char (if it exists).\n\t\tthis_class = mb_get_class_buf(rex.input, rex.reg_buf);\n\t\tif (this_class <= 1)\n\t\t    status = RA_NOMATCH;  // not on a word at all\n\t\telse if (reg_prev_class() == this_class)\n\t\t    status = RA_NOMATCH;  // previous char is in same word\n\t    }\n\t    else\n\t    {\n\t\tif (!vim_iswordc_buf(c, rex.reg_buf) || (rex.input > rex.line\n\t\t\t\t&& vim_iswordc_buf(rex.input[-1], rex.reg_buf)))\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    break;\n\n\t  case EOW:\t// word\\>; rex.input points after d\n\t    if (rex.input == rex.line)    // Can't match at start of line\n\t\tstatus = RA_NOMATCH;\n\t    else if (has_mbyte)\n\t    {\n\t\tint this_class, prev_class;\n\n\t\t// Get class of current and previous char (if it exists).\n\t\tthis_class = mb_get_class_buf(rex.input, rex.reg_buf);\n\t\tprev_class = reg_prev_class();\n\t\tif (this_class == prev_class\n\t\t\t|| prev_class == 0 || prev_class == 1)\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    else\n\t    {\n\t\tif (!vim_iswordc_buf(rex.input[-1], rex.reg_buf)\n\t\t\t|| (rex.input[0] != NUL\n\t\t\t\t\t   && vim_iswordc_buf(c, rex.reg_buf)))\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    break; // Matched with EOW\n\n\t  case ANY:\n\t    // ANY does not match new lines.\n\t    if (c == NUL)\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case IDENT:\n\t    if (!vim_isIDc(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case SIDENT:\n\t    if (VIM_ISDIGIT(*rex.input) || !vim_isIDc(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case KWORD:\n\t    if (!vim_iswordp_buf(rex.input, rex.reg_buf))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case SKWORD:\n\t    if (VIM_ISDIGIT(*rex.input)\n\t\t\t\t    || !vim_iswordp_buf(rex.input, rex.reg_buf))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case FNAME:\n\t    if (!vim_isfilec(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case SFNAME:\n\t    if (VIM_ISDIGIT(*rex.input) || !vim_isfilec(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case PRINT:\n\t    if (!vim_isprintc(PTR2CHAR(rex.input)))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case SPRINT:\n\t    if (VIM_ISDIGIT(*rex.input) || !vim_isprintc(PTR2CHAR(rex.input)))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case WHITE:\n\t    if (!VIM_ISWHITE(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NWHITE:\n\t    if (c == NUL || VIM_ISWHITE(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case DIGIT:\n\t    if (!ri_digit(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NDIGIT:\n\t    if (c == NUL || ri_digit(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case HEX:\n\t    if (!ri_hex(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NHEX:\n\t    if (c == NUL || ri_hex(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case OCTAL:\n\t    if (!ri_octal(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NOCTAL:\n\t    if (c == NUL || ri_octal(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case WORD:\n\t    if (!ri_word(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NWORD:\n\t    if (c == NUL || ri_word(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case HEAD:\n\t    if (!ri_head(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NHEAD:\n\t    if (c == NUL || ri_head(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case ALPHA:\n\t    if (!ri_alpha(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NALPHA:\n\t    if (c == NUL || ri_alpha(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case LOWER:\n\t    if (!ri_lower(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NLOWER:\n\t    if (c == NUL || ri_lower(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case UPPER:\n\t    if (!ri_upper(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NUPPER:\n\t    if (c == NUL || ri_upper(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case EXACTLY:\n\t    {\n\t\tint\tlen;\n\t\tchar_u\t*opnd;\n\n\t\topnd = OPERAND(scan);\n\t\t// Inline the first byte, for speed.\n\t\tif (*opnd != *rex.input\n\t\t\t&& (!rex.reg_ic\n\t\t\t    || (!enc_utf8\n\t\t\t      && MB_TOLOWER(*opnd) != MB_TOLOWER(*rex.input))))\n\t\t    status = RA_NOMATCH;\n\t\telse if (*opnd == NUL)\n\t\t{\n\t\t    // match empty string always works; happens when \"~\" is\n\t\t    // empty.\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (opnd[1] == NUL && !(enc_utf8 && rex.reg_ic))\n\t\t    {\n\t\t\tlen = 1;\t// matched a single byte above\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Need to match first byte again for multi-byte.\n\t\t\tlen = (int)STRLEN(opnd);\n\t\t\tif (cstrncmp(opnd, rex.input, &len) != 0)\n\t\t\t    status = RA_NOMATCH;\n\t\t    }\n\t\t    // Check for following composing character, unless %C\n\t\t    // follows (skips over all composing chars).\n\t\t    if (status != RA_NOMATCH\n\t\t\t    && enc_utf8\n\t\t\t    && UTF_COMPOSINGLIKE(rex.input, rex.input + len)\n\t\t\t    && !rex.reg_icombine\n\t\t\t    && OP(next) != RE_COMPOSING)\n\t\t    {\n\t\t\t// raaron: This code makes a composing character get\n\t\t\t// ignored, which is the correct behavior (sometimes)\n\t\t\t// for voweled Hebrew texts.\n\t\t\tstatus = RA_NOMATCH;\n\t\t    }\n\t\t    if (status != RA_NOMATCH)\n\t\t\trex.input += len;\n\t\t}\n\t    }\n\t    break;\n\n\t  case ANYOF:\n\t  case ANYBUT:\n\t    if (c == NUL)\n\t\tstatus = RA_NOMATCH;\n\t    else if ((cstrchr(OPERAND(scan), c) == NULL) == (op == ANYOF))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case MULTIBYTECODE:\n\t    if (has_mbyte)\n\t    {\n\t\tint\ti, len;\n\t\tchar_u\t*opnd;\n\t\tint\topndc = 0, inpc;\n\n\t\topnd = OPERAND(scan);\n\t\t// Safety check (just in case 'encoding' was changed since\n\t\t// compiling the program).\n\t\tif ((len = (*mb_ptr2len)(opnd)) < 2)\n\t\t{\n\t\t    status = RA_NOMATCH;\n\t\t    break;\n\t\t}\n\t\tif (enc_utf8)\n\t\t    opndc = utf_ptr2char(opnd);\n\t\tif (enc_utf8 && utf_iscomposing(opndc))\n\t\t{\n\t\t    // When only a composing char is given match at any\n\t\t    // position where that composing char appears.\n\t\t    status = RA_NOMATCH;\n\t\t    for (i = 0; rex.input[i] != NUL;\n\t\t\t\t\t\ti += utf_ptr2len(rex.input + i))\n\t\t    {\n\t\t\tinpc = utf_ptr2char(rex.input + i);\n\t\t\tif (!utf_iscomposing(inpc))\n\t\t\t{\n\t\t\t    if (i > 0)\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (opndc == inpc)\n\t\t\t{\n\t\t\t    // Include all following composing chars.\n\t\t\t    len = i + utfc_ptr2len(rex.input + i);\n\t\t\t    status = RA_MATCH;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t    for (i = 0; i < len; ++i)\n\t\t\tif (opnd[i] != rex.input[i])\n\t\t\t{\n\t\t\t    status = RA_NOMATCH;\n\t\t\t    break;\n\t\t\t}\n\t\trex.input += len;\n\t    }\n\t    else\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_COMPOSING:\n\t    if (enc_utf8)\n\t    {\n\t\t// Skip composing characters.\n\t\twhile (utf_iscomposing(utf_ptr2char(rex.input)))\n\t\t    MB_CPTR_ADV(rex.input);\n\t    }\n\t    break;\n\n\t  case NOTHING:\n\t    break;\n\n\t  case BACK:\n\t    {\n\t\tint\t\ti;\n\t\tbackpos_T\t*bp;\n\n\t\t// When we run into BACK we need to check if we don't keep\n\t\t// looping without matching any input.  The second and later\n\t\t// times a BACK is encountered it fails if the input is still\n\t\t// at the same position as the previous time.\n\t\t// The positions are stored in \"backpos\" and found by the\n\t\t// current value of \"scan\", the position in the RE program.\n\t\tbp = (backpos_T *)backpos.ga_data;\n\t\tfor (i = 0; i < backpos.ga_len; ++i)\n\t\t    if (bp[i].bp_scan == scan)\n\t\t\tbreak;\n\t\tif (i == backpos.ga_len)\n\t\t{\n\t\t    // First time at this BACK, make room to store the pos.\n\t\t    if (ga_grow(&backpos, 1) == FAIL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t    {\n\t\t\t// get \"ga_data\" again, it may have changed\n\t\t\tbp = (backpos_T *)backpos.ga_data;\n\t\t\tbp[i].bp_scan = scan;\n\t\t\t++backpos.ga_len;\n\t\t    }\n\t\t}\n\t\telse if (reg_save_equal(&bp[i].bp_pos))\n\t\t    // Still at same position as last time, fail.\n\t\t    status = RA_NOMATCH;\n\n\t\tif (status != RA_FAIL && status != RA_NOMATCH)\n\t\t    reg_save(&bp[i].bp_pos, &backpos);\n\t    }\n\t    break;\n\n\t  case MOPEN + 0:   // Match start: \\zs\n\t  case MOPEN + 1:   // \\(\n\t  case MOPEN + 2:\n\t  case MOPEN + 3:\n\t  case MOPEN + 4:\n\t  case MOPEN + 5:\n\t  case MOPEN + 6:\n\t  case MOPEN + 7:\n\t  case MOPEN + 8:\n\t  case MOPEN + 9:\n\t    {\n\t\tno = op - MOPEN;\n\t\tcleanup_subexpr();\n\t\trp = regstack_push(RS_MOPEN, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &rex.reg_startpos[no],\n\t\t\t\t\t\t\t  &rex.reg_startp[no]);\n\t\t    // We simply continue and handle the result when done.\n\t\t}\n\t    }\n\t    break;\n\n\t  case NOPEN:\t    // \\%(\n\t  case NCLOSE:\t    // \\) after \\%(\n\t\tif (regstack_push(RS_NOPEN, scan) == NULL)\n\t\t    status = RA_FAIL;\n\t\t// We simply continue and handle the result when done.\n\t\tbreak;\n\n#ifdef FEAT_SYN_HL\n\t  case ZOPEN + 1:\n\t  case ZOPEN + 2:\n\t  case ZOPEN + 3:\n\t  case ZOPEN + 4:\n\t  case ZOPEN + 5:\n\t  case ZOPEN + 6:\n\t  case ZOPEN + 7:\n\t  case ZOPEN + 8:\n\t  case ZOPEN + 9:\n\t    {\n\t\tno = op - ZOPEN;\n\t\tcleanup_zsubexpr();\n\t\trp = regstack_push(RS_ZOPEN, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &reg_startzpos[no],\n\t\t\t\t\t\t\t     &reg_startzp[no]);\n\t\t    // We simply continue and handle the result when done.\n\t\t}\n\t    }\n\t    break;\n#endif\n\n\t  case MCLOSE + 0:  // Match end: \\ze\n\t  case MCLOSE + 1:  // \\)\n\t  case MCLOSE + 2:\n\t  case MCLOSE + 3:\n\t  case MCLOSE + 4:\n\t  case MCLOSE + 5:\n\t  case MCLOSE + 6:\n\t  case MCLOSE + 7:\n\t  case MCLOSE + 8:\n\t  case MCLOSE + 9:\n\t    {\n\t\tno = op - MCLOSE;\n\t\tcleanup_subexpr();\n\t\trp = regstack_push(RS_MCLOSE, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &rex.reg_endpos[no],\n\t\t\t\t\t\t\t    &rex.reg_endp[no]);\n\t\t    // We simply continue and handle the result when done.\n\t\t}\n\t    }\n\t    break;\n\n#ifdef FEAT_SYN_HL\n\t  case ZCLOSE + 1:  // \\) after \\z(\n\t  case ZCLOSE + 2:\n\t  case ZCLOSE + 3:\n\t  case ZCLOSE + 4:\n\t  case ZCLOSE + 5:\n\t  case ZCLOSE + 6:\n\t  case ZCLOSE + 7:\n\t  case ZCLOSE + 8:\n\t  case ZCLOSE + 9:\n\t    {\n\t\tno = op - ZCLOSE;\n\t\tcleanup_zsubexpr();\n\t\trp = regstack_push(RS_ZCLOSE, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &reg_endzpos[no],\n\t\t\t\t\t\t\t      &reg_endzp[no]);\n\t\t    // We simply continue and handle the result when done.\n\t\t}\n\t    }\n\t    break;\n#endif\n\n\t  case BACKREF + 1:\n\t  case BACKREF + 2:\n\t  case BACKREF + 3:\n\t  case BACKREF + 4:\n\t  case BACKREF + 5:\n\t  case BACKREF + 6:\n\t  case BACKREF + 7:\n\t  case BACKREF + 8:\n\t  case BACKREF + 9:\n\t    {\n\t\tint\t\tlen;\n\n\t\tno = op - BACKREF;\n\t\tcleanup_subexpr();\n\t\tif (!REG_MULTI)\t\t// Single-line regexp\n\t\t{\n\t\t    if (rex.reg_startp[no] == NULL || rex.reg_endp[no] == NULL)\n\t\t    {\n\t\t\t// Backref was not set: Match an empty string.\n\t\t\tlen = 0;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Compare current input with back-ref in the same\n\t\t\t// line.\n\t\t\tlen = (int)(rex.reg_endp[no] - rex.reg_startp[no]);\n\t\t\tif (cstrncmp(rex.reg_startp[no], rex.input, &len) != 0)\n\t\t\t    status = RA_NOMATCH;\n\t\t    }\n\t\t}\n\t\telse\t\t\t\t// Multi-line regexp\n\t\t{\n\t\t    if (rex.reg_startpos[no].lnum < 0\n\t\t\t\t\t\t|| rex.reg_endpos[no].lnum < 0)\n\t\t    {\n\t\t\t// Backref was not set: Match an empty string.\n\t\t\tlen = 0;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (rex.reg_startpos[no].lnum == rex.lnum\n\t\t\t\t&& rex.reg_endpos[no].lnum == rex.lnum)\n\t\t\t{\n\t\t\t    // Compare back-ref within the current line.\n\t\t\t    len = rex.reg_endpos[no].col\n\t\t\t\t\t\t    - rex.reg_startpos[no].col;\n\t\t\t    if (cstrncmp(rex.line + rex.reg_startpos[no].col,\n\t\t\t\t\t\t\t  rex.input, &len) != 0)\n\t\t\t\tstatus = RA_NOMATCH;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // Messy situation: Need to compare between two\n\t\t\t    // lines.\n\t\t\t    int r = match_with_backref(\n\t\t\t\t\t    rex.reg_startpos[no].lnum,\n\t\t\t\t\t    rex.reg_startpos[no].col,\n\t\t\t\t\t    rex.reg_endpos[no].lnum,\n\t\t\t\t\t    rex.reg_endpos[no].col,\n\t\t\t\t\t    &len);\n\n\t\t\t    if (r != RA_MATCH)\n\t\t\t\tstatus = r;\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t\t// Matched the backref, skip over it.\n\t\trex.input += len;\n\t    }\n\t    break;\n\n#ifdef FEAT_SYN_HL\n\t  case ZREF + 1:\n\t  case ZREF + 2:\n\t  case ZREF + 3:\n\t  case ZREF + 4:\n\t  case ZREF + 5:\n\t  case ZREF + 6:\n\t  case ZREF + 7:\n\t  case ZREF + 8:\n\t  case ZREF + 9:\n\t    {\n\t\tint\tlen;\n\n\t\tcleanup_zsubexpr();\n\t\tno = op - ZREF;\n\t\tif (re_extmatch_in != NULL\n\t\t\t&& re_extmatch_in->matches[no] != NULL)\n\t\t{\n\t\t    len = (int)STRLEN(re_extmatch_in->matches[no]);\n\t\t    if (cstrncmp(re_extmatch_in->matches[no],\n\t\t\t\t\t\t\t  rex.input, &len) != 0)\n\t\t\tstatus = RA_NOMATCH;\n\t\t    else\n\t\t\trex.input += len;\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Backref was not set: Match an empty string.\n\t\t}\n\t    }\n\t    break;\n#endif\n\n\t  case BRANCH:\n\t    {\n\t\tif (OP(next) != BRANCH) // No choice.\n\t\t    next = OPERAND(scan);\t// Avoid recursion.\n\t\telse\n\t\t{\n\t\t    rp = regstack_push(RS_BRANCH, scan);\n\t\t    if (rp == NULL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t\tstatus = RA_BREAK;\t// rest is below\n\t\t}\n\t    }\n\t    break;\n\n\t  case BRACE_LIMITS:\n\t    {\n\t\tif (OP(next) == BRACE_SIMPLE)\n\t\t{\n\t\t    bl_minval = OPERAND_MIN(scan);\n\t\t    bl_maxval = OPERAND_MAX(scan);\n\t\t}\n\t\telse if (OP(next) >= BRACE_COMPLEX\n\t\t\t&& OP(next) < BRACE_COMPLEX + 10)\n\t\t{\n\t\t    no = OP(next) - BRACE_COMPLEX;\n\t\t    brace_min[no] = OPERAND_MIN(scan);\n\t\t    brace_max[no] = OPERAND_MAX(scan);\n\t\t    brace_count[no] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    internal_error(\"BRACE_LIMITS\");\n\t\t    status = RA_FAIL;\n\t\t}\n\t    }\n\t    break;\n\n\t  case BRACE_COMPLEX + 0:\n\t  case BRACE_COMPLEX + 1:\n\t  case BRACE_COMPLEX + 2:\n\t  case BRACE_COMPLEX + 3:\n\t  case BRACE_COMPLEX + 4:\n\t  case BRACE_COMPLEX + 5:\n\t  case BRACE_COMPLEX + 6:\n\t  case BRACE_COMPLEX + 7:\n\t  case BRACE_COMPLEX + 8:\n\t  case BRACE_COMPLEX + 9:\n\t    {\n\t\tno = op - BRACE_COMPLEX;\n\t\t++brace_count[no];\n\n\t\t// If not matched enough times yet, try one more\n\t\tif (brace_count[no] <= (brace_min[no] <= brace_max[no]\n\t\t\t\t\t     ? brace_min[no] : brace_max[no]))\n\t\t{\n\t\t    rp = regstack_push(RS_BRCPLX_MORE, scan);\n\t\t    if (rp == NULL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t    {\n\t\t\trp->rs_no = no;\n\t\t\treg_save(&rp->rs_un.regsave, &backpos);\n\t\t\tnext = OPERAND(scan);\n\t\t\t// We continue and handle the result when done.\n\t\t    }\n\t\t    break;\n\t\t}\n\n\t\t// If matched enough times, may try matching some more\n\t\tif (brace_min[no] <= brace_max[no])\n\t\t{\n\t\t    // Range is the normal way around, use longest match\n\t\t    if (brace_count[no] <= brace_max[no])\n\t\t    {\n\t\t\trp = regstack_push(RS_BRCPLX_LONG, scan);\n\t\t\tif (rp == NULL)\n\t\t\t    status = RA_FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    rp->rs_no = no;\n\t\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t\t    next = OPERAND(scan);\n\t\t\t    // We continue and handle the result when done.\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Range is backwards, use shortest match first\n\t\t    if (brace_count[no] <= brace_min[no])\n\t\t    {\n\t\t\trp = regstack_push(RS_BRCPLX_SHORT, scan);\n\t\t\tif (rp == NULL)\n\t\t\t    status = RA_FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t\t    // We continue and handle the result when done.\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\n\t  case BRACE_SIMPLE:\n\t  case STAR:\n\t  case PLUS:\n\t    {\n\t\tregstar_T\trst;\n\n\t\t// Lookahead to avoid useless match attempts when we know\n\t\t// what character comes next.\n\t\tif (OP(next) == EXACTLY)\n\t\t{\n\t\t    rst.nextb = *OPERAND(next);\n\t\t    if (rex.reg_ic)\n\t\t    {\n\t\t\tif (MB_ISUPPER(rst.nextb))\n\t\t\t    rst.nextb_ic = MB_TOLOWER(rst.nextb);\n\t\t\telse\n\t\t\t    rst.nextb_ic = MB_TOUPPER(rst.nextb);\n\t\t    }\n\t\t    else\n\t\t\trst.nextb_ic = rst.nextb;\n\t\t}\n\t\telse\n\t\t{\n\t\t    rst.nextb = NUL;\n\t\t    rst.nextb_ic = NUL;\n\t\t}\n\t\tif (op != BRACE_SIMPLE)\n\t\t{\n\t\t    rst.minval = (op == STAR) ? 0 : 1;\n\t\t    rst.maxval = MAX_LIMIT;\n\t\t}\n\t\telse\n\t\t{\n\t\t    rst.minval = bl_minval;\n\t\t    rst.maxval = bl_maxval;\n\t\t}\n\n\t\t// When maxval > minval, try matching as much as possible, up\n\t\t// to maxval.  When maxval < minval, try matching at least the\n\t\t// minimal number (since the range is backwards, that's also\n\t\t// maxval!).\n\t\trst.count = regrepeat(OPERAND(scan), rst.maxval);\n\t\tif (got_int)\n\t\t{\n\t\t    status = RA_FAIL;\n\t\t    break;\n\t\t}\n\t\tif (rst.minval <= rst.maxval\n\t\t\t  ? rst.count >= rst.minval : rst.count >= rst.maxval)\n\t\t{\n\t\t    // It could match.  Prepare for trying to match what\n\t\t    // follows.  The code is below.  Parameters are stored in\n\t\t    // a regstar_T on the regstack.\n\t\t    if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp)\n\t\t    {\n\t\t\temsg(_(e_pattern_uses_more_memory_than_maxmempattern));\n\t\t\tstatus = RA_FAIL;\n\t\t    }\n\t\t    else if (ga_grow(&regstack, sizeof(regstar_T)) == FAIL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t    {\n\t\t\tregstack.ga_len += sizeof(regstar_T);\n\t\t\trp = regstack_push(rst.minval <= rst.maxval\n\t\t\t\t\t? RS_STAR_LONG : RS_STAR_SHORT, scan);\n\t\t\tif (rp == NULL)\n\t\t\t    status = RA_FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    *(((regstar_T *)rp) - 1) = rst;\n\t\t\t    status = RA_BREAK;\t    // skip the restore bits\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t    status = RA_NOMATCH;\n\n\t    }\n\t    break;\n\n\t  case NOMATCH:\n\t  case MATCH:\n\t  case SUBPAT:\n\t    rp = regstack_push(RS_NOMATCH, scan);\n\t    if (rp == NULL)\n\t\tstatus = RA_FAIL;\n\t    else\n\t    {\n\t\trp->rs_no = op;\n\t\treg_save(&rp->rs_un.regsave, &backpos);\n\t\tnext = OPERAND(scan);\n\t\t// We continue and handle the result when done.\