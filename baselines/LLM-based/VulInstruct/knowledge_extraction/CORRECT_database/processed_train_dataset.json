[
  {
    "repository": "bonzini/qemu",
    "cve_id": "CVE-2007-1320",
    "cwe_list": [
      "CWE-787"
    ],
    "commit_hash": "65d35a09979e63541afc5bfc595b9f1b1b4ae069",
    "short_hash": "65d35a09",
    "vulnerableMethods_before": [
      {
        "filename": "hw/cirrus_vga.c",
        "method_name": "cirrus_bitblt_videotovideo_copy",
        "raw_code": "static int cirrus_bitblt_videotovideo_copy(CirrusVGAState * s) /* <=== cirrus_bitblt_videotovideo_copy */ \n{\n    if (s->ds->dpy_copy) {\n\tcirrus_do_copy(s, s->cirrus_blt_dstaddr - s->start_addr,\n\t\t       s->cirrus_blt_srcaddr - s->start_addr,\n\t\t       s->cirrus_blt_width, s->cirrus_blt_height);\n    } else {\n\n    if (BLTUNSAFE(s))\n        return 0;\n\n\t(*s->cirrus_rop) (s, s->vram_ptr +\n                (s->cirrus_blt_dstaddr & s->cirrus_addr_mask),\n\t\t\t  s->vram_ptr +\n                (s->cirrus_blt_srcaddr & s->cirrus_addr_mask),\n\t\t\t  s->cirrus_blt_dstpitch, s->cirrus_blt_srcpitch,\n\t\t\t  s->cirrus_blt_width, s->cirrus_blt_height);\n\n\tcirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\t\t\t\t s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\t\t\t\t s->cirrus_blt_height);\n    }\n\n    return 1;\n}",
        "start_line": 786
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "hw/cirrus_vga.c",
        "method_name": "cirrus_bitblt_videotovideo_copy",
        "raw_code": "static int cirrus_bitblt_videotovideo_copy(CirrusVGAState * s) /* <=== cirrus_bitblt_videotovideo_copy */ \n{\n    if (BLTUNSAFE(s))\n        return 0;\n\n    if (s->ds->dpy_copy) {\n\tcirrus_do_copy(s, s->cirrus_blt_dstaddr - s->start_addr,\n\t\t       s->cirrus_blt_srcaddr - s->start_addr,\n\t\t       s->cirrus_blt_width, s->cirrus_blt_height);\n    } else {\n\t(*s->cirrus_rop) (s, s->vram_ptr +\n                (s->cirrus_blt_dstaddr & s->cirrus_addr_mask),\n\t\t\t  s->vram_ptr +\n                (s->cirrus_blt_srcaddr & s->cirrus_addr_mask),\n\t\t\t  s->cirrus_blt_dstpitch, s->cirrus_blt_srcpitch,\n\t\t\t  s->cirrus_blt_width, s->cirrus_blt_height);\n\n\tcirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\t\t\t\t s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\t\t\t\t s->cirrus_blt_height);\n    }\n\n    return 1;\n}",
        "start_line": 786
      }
    ],
    "code_context": "Called Methods:\n- vga_hw_update: void vga_hw_update(void) /* <=== vga_hw_update */ \n{\n    if (active_console && active_console->hw_update)\n        active_console->hw_update(active_console->hw);\n}\n- BLTUNSAFE: #define BLTUNSAFE(s) \\ /* <=== hw/cirrus_vga.c:223:235:BLTUNSAFE:1 */ \n    ( \\\n        ( /* check dst is within bounds */ \\\n            (s)->cirrus_blt_height * (s)->cirrus_blt_dstpitch \\\n                + ((s)->cirrus_blt_dstaddr & (s)->cirrus_addr_mask) > \\\n                    (s)->vram_size \\\n        ) || \\\n        ( /* check src is within bounds */ \\\n            (s)->cirrus_blt_height * (s)->cirrus_blt_srcpitch \\\n                + ((s)->cirrus_blt_srcaddr & (s)->cirrus_addr_mask) > \\\n                    (s)->vram_size \\\n        ) \\\n    )\n- cirrus_do_copy: static void cirrus_do_copy(CirrusVGAState *s, int dst, int src, int w, int h) /* <=== cirrus_do_copy */ \n{\n    int sx, sy;\n    int dx, dy;\n    int width, height;\n    int depth;\n    int notify = 0;\n\n    depth = s->get_bpp((VGAState *)s) / 8;\n    s->get_resolution((VGAState *)s, &width, &height);\n\n    /* extra x, y */\n    sx = (src % (width * depth)) / depth;\n    sy = (src / (width * depth));\n    dx = (dst % (width *depth)) / depth;\n    dy = (dst / (width * depth));\n\n    /* normalize width */\n    w /= depth;\n\n    /* if we're doing a backward copy, we have to adjust\n       our x/y to be the upper left corner (instead of the lower\n       right corner) */\n    if (s->cirrus_blt_dstpitch < 0) {\n\tsx -= (s->cirrus_blt_width / depth) - 1;\n\tdx -= (s->cirrus_blt_width / depth) - 1;\n\tsy -= s->cirrus_blt_height - 1;\n\tdy -= s->cirrus_blt_height - 1;\n    }\n\n    /* are we in the visible portion of memory? */\n    if (sx >= 0 && sy >= 0 && dx >= 0 && dy >= 0 &&\n\t(sx + w) <= width && (sy + h) <= height &&\n\t(dx + w) <= width && (dy + h) <= height) {\n\tnotify = 1;\n    }\n\n    /* make to sure only copy if it's a plain copy ROP */\n    if (*s->cirrus_rop != cirrus_bitblt_rop_fwd_src &&\n\t*s->cirrus_rop != cirrus_bitblt_rop_bkwd_src)\n\tnotify = 0;\n\n    /* we have to flush all pending changes so that the copy\n       is generated at the appropriate moment in time */\n    if (notify)\n\tvga_hw_update();\n\n    (*s->cirrus_rop) (s, s->vram_ptr +\n\t\t      (s->cirrus_blt_dstaddr & s->cirrus_addr_mask),\n\t\t      s->vram_ptr +\n\t\t      (s->cirrus_blt_srcaddr & s->cirrus_addr_mask),\n\t\t      s->cirrus_blt_dstpitch, s->cirrus_blt_srcpitch,\n\t\t      s->cirrus_blt_width, s->cirrus_blt_height);\n\n    if (notify)\n\tqemu_console_copy(s->console,\n\t\t\t  sx, sy, dx, dy,\n\t\t\t  s->cirrus_blt_width / depth,\n\t\t\t  s->cirrus_blt_height);\n\n    /* we don't have to notify the display that this portion has\n       changed since qemu_console_copy implies this */\n\n    if (!notify)\n\tcirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\t\t\t\t s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\t\t\t\t s->cirrus_blt_height);\n}\n- cirrus_invalidate_region: static void cirrus_invalidate_region(CirrusVGAState * s, int off_begin, /* <=== cirrus_invalidate_region */ \n\t\t\t\t     int off_pitch, int bytesperline,\n\t\t\t\t     int lines)\n{\n    int y;\n    int off_cur;\n    int off_cur_end;\n\n    for (y = 0; y < lines; y++) {\n\toff_cur = off_begin;\n\toff_cur_end = (off_cur + bytesperline) & s->cirrus_addr_mask;\n\toff_cur &= TARGET_PAGE_MASK;\n\twhile (off_cur < off_cur_end) {\n\t    cpu_physical_memory_set_dirty(s->vram_offset + off_cur);\n\t    off_cur += TARGET_PAGE_SIZE;\n\t}\n\toff_begin += off_pitch;\n    }\n}\n- qemu_console_copy: void qemu_console_copy(QEMUConsole *console, int src_x, int src_y, /* <=== qemu_console_copy */ \n                int dst_x, int dst_y, int w, int h)\n{\n    if (active_console == console) {\n        if (console->ds->dpy_copy)\n            console->ds->dpy_copy(console->ds,\n                            src_x, src_y, dst_x, dst_y, w, h);\n        else {\n            /* TODO */\n            console->ds->dpy_update(console->ds, dst_x, dst_y, w, h);\n        }\n    }\n}\n\nType Definitions:\n- CirrusVGAState: typedef struct CirrusVGAState {\n    VGA_STATE_COMMON\n\n    int cirrus_linear_io_addr;\n    int cirrus_linear_bitblt_io_addr;\n    int cirrus_mmio_io_addr;\n    uint32_t cirrus_addr_mask;\n    uint32_t linear_mmio_mask;\n    uint8_t cirrus_shadow_gr0;\n    uint8_t cirrus_shadow_gr1;\n    uint8_t cirrus_hidden_dac_lockindex;\n    uint8_t cirrus_hidden_dac_data;\n    uint32_t cirrus_bank_base[2];\n    uint32_t cirrus_bank_limit[2];\n    uint8_t cirrus_hidden_palette[48];\n    uint32_t hw_cursor_x;\n    uint32_t hw_cursor_y;\n    int cirrus_blt_pixelwidth;\n    int cirrus_blt_width;\n    int cirrus_blt_height;\n    int cirrus_blt_dstpitch;\n    int cirrus_blt_srcpitch;\n    uint32_t cirrus_blt_fgcol;\n    uint32_t cirrus_blt_bgcol;\n    uint32_t cirrus_blt_dstaddr;\n    uint32_t cirrus_blt_srcaddr;\n    uint8_t cirrus_blt_mode;\n    uint8_t cirrus_blt_modeext;\n    cirrus_bitblt_rop_t cirrus_rop;\n#define CIRRUS_BLTBUFSIZE (2048 * 4) /* one line width */\n    uint8_t cirrus_bltbuf[CIRRUS_BLTBUFSIZE];\n    uint8_t *cirrus_srcptr;\n    uint8_t *cirrus_srcptr_end;\n    uint32_t cirrus_srccounter;\n    /* hwcursor display state */\n    int last_hw_cursor_size;\n    int last_hw_cursor_x;\n    int last_hw_cursor_y;\n    int last_hw_cursor_y_start;\n    int last_hw_cursor_y_end;\n    int real_vram_size; /* XXX: suppress that */\n    CPUWriteMemoryFunc **cirrus_linear_write;\n}\n- CirrusVGAState: struct CirrusVGAState\n\nImports:\n- #include \"vga_int.h\"\n- #include \"cirrus_vga_rop.h\"\n- #include \"pc.h\"\n- #include \"hw.h\"\n- #include \"console.h\"\n- #include \"pci.h\"",
    "commit_msg": "CVE-2008-4539: fix a heap overflow in Cirrus emulation\n\nThe code in hw/cirrus_vga.c has changed a lot between CVE-2007-1320 has\nbeen announced and the patch has been applied. As a consequence it has\nwrongly applied and QEMU is still vulnerable to this bug if using VNC.\n\n(noticed by Jan Niehusmann)\n\nSigned-off-by: Aurelien Jarno <aurelien@aurel32.net>\n\ngit-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@5587 c046a42c-6fe2-441c-8c8c-71466251a162",
    "cve_desc": "Multiple heap-based buffer overflows in the cirrus_invalidate_region function in the Cirrus VGA extension in QEMU 0.8.2, as used in Xen and possibly other products, might allow local users to execute arbitrary code via unspecified vectors related to \"attempting to mark non-existent regions as dirty,\" aka the \"bitblt\" heap overflow.",
    "year": 2008,
    "filename": "cirrus_vga.c",
    "commit_url": "\"https://github.com/bonzini/qemu/commit/65d35a09979e63541afc5bfc595b9f1b1b4ae069\""
  },
  {
    "repository": "torvalds/linux",
    "cve_id": "CVE-2007-6761",
    "cwe_list": [
      "CWE-119"
    ],
    "commit_hash": "0b29669c065f60501e7289e1950fa2a618962358",
    "short_hash": "0b29669c",
    "vulnerableMethods_before": [
      {
        "filename": "drivers/media/video/videobuf-vmalloc.c",
        "method_name": "videobuf_vm_open",
        "raw_code": "static void /* <=== videobuf_vm_open */ \nvideobuf_vm_open(struct vm_area_struct *vma)\n{\n\tstruct videobuf_mapping *map = vma->vm_private_data;\n\n\tdprintk(2,\"vm_open %p [count=%d,vma=%08lx-%08lx]\\n\",map,\n\t\tmap->count,vma->vm_start,vma->vm_end);\n\n\tmap->count++;\n}",
        "start_line": 49
      },
      {
        "filename": "drivers/media/video/videobuf-vmalloc.c",
        "method_name": "videobuf_vm_close",
        "raw_code": "static void /* <=== videobuf_vm_close */ \nvideobuf_vm_close(struct vm_area_struct *vma)\n{\n\tstruct videobuf_mapping *map = vma->vm_private_data;\n\tstruct videobuf_queue *q = map->q;\n\tint i;\n\n\tdprintk(2,\"vm_close %p [count=%d,vma=%08lx-%08lx]\\n\",map,\n\t\tmap->count,vma->vm_start,vma->vm_end);\n\n\tmap->count--;\n\tif (0 == map->count) {\n\t\tdprintk(1,\"munmap %p q=%p\\n\",map,q);\n\t\tmutex_lock(&q->lock);\n\t\tfor (i = 0; i < VIDEO_MAX_FRAME; i++) {\n\t\t\tif (NULL == q->bufs[i])\n\t\t\t\tcontinue;\n\n\t\t\tif (q->bufs[i]->map != map)\n\t\t\t\tcontinue;\n\n\t\t\tq->ops->buf_release(q,q->bufs[i]);\n\n\t\t\tq->bufs[i]->map   = NULL;\n\t\t\tq->bufs[i]->baddr = 0;\n\t\t}\n\t\tmutex_unlock(&q->lock);\n\t\tkfree(map);\n\t}\n\treturn;\n}",
        "start_line": 60
      },
      {
        "filename": "drivers/media/video/videobuf-vmalloc.c",
        "method_name": "__videobuf_mmap_mapper",
        "raw_code": "static int __videobuf_mmap_mapper(struct videobuf_queue *q, /* <=== __videobuf_mmap_mapper */ \n\t\t\t struct vm_area_struct *vma)\n{\n\tstruct videbuf_vmalloc_memory *mem;\n\tstruct videobuf_mapping *map;\n\tunsigned int first;\n\tint retval;\n\tunsigned long offset = vma->vm_pgoff << PAGE_SHIFT;\n\n\tif (! (vma->vm_flags & VM_WRITE) || ! (vma->vm_flags & VM_SHARED))\n\t\treturn -EINVAL;\n\n\t/* look for first buffer to map */\n\tfor (first = 0; first < VIDEO_MAX_FRAME; first++) {\n\t\tif (NULL == q->bufs[first])\n\t\t\tcontinue;\n\n\t\tif (V4L2_MEMORY_MMAP != q->bufs[first]->memory)\n\t\t\tcontinue;\n\t\tif (q->bufs[first]->boff == offset)\n\t\t\tbreak;\n\t}\n\tif (VIDEO_MAX_FRAME == first) {\n\t\tdprintk(1,\"mmap app bug: offset invalid [offset=0x%lx]\\n\",\n\t\t\t(vma->vm_pgoff << PAGE_SHIFT));\n\t\treturn -EINVAL;\n\t}\n\n\t/* create mapping + update buffer list */\n\tmap = q->bufs[first]->map = kmalloc(sizeof(struct videobuf_mapping),GFP_KERNEL);\n\tif (NULL == map)\n\t\treturn -ENOMEM;\n\n\tmap->start = vma->vm_start;\n\tmap->end   = vma->vm_end;\n\tmap->q     = q;\n\n\tq->bufs[first]->baddr = vma->vm_start;\n\n\tvma->vm_ops          = &videobuf_vm_ops;\n\tvma->vm_flags       |= VM_DONTEXPAND | VM_RESERVED;\n\tvma->vm_private_data = map;\n\n\tmem=q->bufs[first]->priv;\n\tBUG_ON (!mem);\n\tMAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);\n\n\t/* Try to remap memory */\n\tretval=remap_vmalloc_range(vma, mem->vmalloc,0);\n\tif (retval<0) {\n\t\tdprintk(1,\"mmap: postponing remap_vmalloc_range\\n\");\n\n\t\tmem->vma=kmalloc(sizeof(*vma),GFP_KERNEL);\n\t\tif (!mem->vma) {\n\t\t\tkfree(map);\n\t\t\tq->bufs[first]->map=NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemcpy(mem->vma,vma,sizeof(*vma));\n\t}\n\n\tdprintk(1,\"mmap %p: q=%p %08lx-%08lx (%lx) pgoff %08lx buf %d\\n\",\n\t\tmap,q,vma->vm_start,vma->vm_end,\n\t\t(long int) q->bufs[first]->bsize,\n\t\tvma->vm_pgoff,first);\n\n\tvideobuf_vm_open(vma);\n\n\treturn (0);\n}",
        "start_line": 195
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "drivers/media/video/videobuf-vmalloc.c",
        "method_name": "videobuf_vm_open",
        "raw_code": "static void /* <=== videobuf_vm_open */ \nvideobuf_vm_open(struct vm_area_struct *vma)\n{\n\tstruct videobuf_mapping *map = vma->vm_private_data;\n\n\tdprintk(2,\"vm_open %p [count=%u,vma=%08lx-%08lx]\\n\",map,\n\t\tmap->count,vma->vm_start,vma->vm_end);\n\n\tmap->count++;\n}",
        "start_line": 49
      },
      {
        "filename": "drivers/media/video/videobuf-vmalloc.c",
        "method_name": "videobuf_vm_close",
        "raw_code": "static void /* <=== videobuf_vm_close */ \nvideobuf_vm_close(struct vm_area_struct *vma)\n{\n\tstruct videobuf_mapping *map = vma->vm_private_data;\n\tstruct videobuf_queue *q = map->q;\n\tint i;\n\n\tdprintk(2,\"vm_close %p [count=%u,vma=%08lx-%08lx]\\n\",map,\n\t\tmap->count,vma->vm_start,vma->vm_end);\n\n\tmap->count--;\n\tif (0 == map->count) {\n\t\tdprintk(1,\"munmap %p q=%p\\n\",map,q);\n\t\tmutex_lock(&q->lock);\n\t\tfor (i = 0; i < VIDEO_MAX_FRAME; i++) {\n\t\t\tif (NULL == q->bufs[i])\n\t\t\t\tcontinue;\n\n\t\t\tif (q->bufs[i]->map != map)\n\t\t\t\tcontinue;\n\n\t\t\tq->ops->buf_release(q,q->bufs[i]);\n\n\t\t\tq->bufs[i]->map   = NULL;\n\t\t\tq->bufs[i]->baddr = 0;\n\t\t}\n\t\tmutex_unlock(&q->lock);\n\t\tkfree(map);\n\t}\n\treturn;\n}",
        "start_line": 60
      },
      {
        "filename": "drivers/media/video/videobuf-vmalloc.c",
        "method_name": "__videobuf_mmap_mapper",
        "raw_code": "static int __videobuf_mmap_mapper(struct videobuf_queue *q, /* <=== __videobuf_mmap_mapper */ \n\t\t\t struct vm_area_struct *vma)\n{\n\tstruct videbuf_vmalloc_memory *mem;\n\tstruct videobuf_mapping *map;\n\tunsigned int first;\n\tint retval;\n\tunsigned long offset = vma->vm_pgoff << PAGE_SHIFT;\n\n\tif (! (vma->vm_flags & VM_WRITE) || ! (vma->vm_flags & VM_SHARED))\n\t\treturn -EINVAL;\n\n\t/* look for first buffer to map */\n\tfor (first = 0; first < VIDEO_MAX_FRAME; first++) {\n\t\tif (NULL == q->bufs[first])\n\t\t\tcontinue;\n\n\t\tif (V4L2_MEMORY_MMAP != q->bufs[first]->memory)\n\t\t\tcontinue;\n\t\tif (q->bufs[first]->boff == offset)\n\t\t\tbreak;\n\t}\n\tif (VIDEO_MAX_FRAME == first) {\n\t\tdprintk(1,\"mmap app bug: offset invalid [offset=0x%lx]\\n\",\n\t\t\t(vma->vm_pgoff << PAGE_SHIFT));\n\t\treturn -EINVAL;\n\t}\n\n\t/* create mapping + update buffer list */\n\tmap = q->bufs[first]->map = kzalloc(sizeof(struct videobuf_mapping),GFP_KERNEL);\n\tif (NULL == map)\n\t\treturn -ENOMEM;\n\n\tmap->start = vma->vm_start;\n\tmap->end   = vma->vm_end;\n\tmap->q     = q;\n\n\tq->bufs[first]->baddr = vma->vm_start;\n\n\tvma->vm_ops          = &videobuf_vm_ops;\n\tvma->vm_flags       |= VM_DONTEXPAND | VM_RESERVED;\n\tvma->vm_private_data = map;\n\n\tmem=q->bufs[first]->priv;\n\tBUG_ON (!mem);\n\tMAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);\n\n\t/* Try to remap memory */\n\tretval=remap_vmalloc_range(vma, mem->vmalloc,0);\n\tif (retval<0) {\n\t\tdprintk(1,\"mmap: postponing remap_vmalloc_range\\n\");\n\n\t\tmem->vma=kmalloc(sizeof(*vma),GFP_KERNEL);\n\t\tif (!mem->vma) {\n\t\t\tkfree(map);\n\t\t\tq->bufs[first]->map=NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemcpy(mem->vma,vma,sizeof(*vma));\n\t}\n\n\tdprintk(1,\"mmap %p: q=%p %08lx-%08lx (%lx) pgoff %08lx buf %d\\n\",\n\t\tmap,q,vma->vm_start,vma->vm_end,\n\t\t(long int) q->bufs[first]->bsize,\n\t\tvma->vm_pgoff,first);\n\n\tvideobuf_vm_open(vma);\n\n\treturn (0);\n}",
        "start_line": 195
      }
    ],
    "code_context": "Called Methods:\n- slob_free: static void slob_free(void *block, int size) /* <=== slob_free */ \n{\n\tstruct slob_page *sp;\n\tslob_t *prev, *next, *b = (slob_t *)block;\n\tslobidx_t units;\n\tunsigned long flags;\n\n\tif (unlikely(ZERO_OR_NULL_PTR(block)))\n\t\treturn;\n\tBUG_ON(!size);\n\n\tsp = (struct slob_page *)virt_to_page(block);\n\tunits = SLOB_UNITS(size);\n\n\tspin_lock_irqsave(&slob_lock, flags);\n\n\tif (sp->units + units == SLOB_UNITS(PAGE_SIZE)) {\n\t\t/* Go directly to page allocator. Do not pass slob allocator */\n\t\tif (slob_page_free(sp))\n\t\t\tclear_slob_page_free(sp);\n\t\tclear_slob_page(sp);\n\t\tfree_slob_page(sp);\n\t\tfree_page((unsigned long)b);\n\t\tgoto out;\n\t}\n\n\tif (!slob_page_free(sp)) {\n\t\t/* This slob page is about to become partially free. Easy! */\n\t\tsp->units = units;\n\t\tsp->free = b;\n\t\tset_slob(b, units,\n\t\t\t(void *)((unsigned long)(b +\n\t\t\t\t\tSLOB_UNITS(PAGE_SIZE)) & PAGE_MASK));\n\t\tset_slob_page_free(sp);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Otherwise the page is already partially free, so find reinsertion\n\t * point.\n\t */\n\tsp->units += units;\n\n\tif (b < sp->free) {\n\t\tset_slob(b, units, sp->free);\n\t\tsp->free = b;\n\t} else {\n\t\tprev = sp->free;\n\t\tnext = slob_next(prev);\n\t\twhile (b > next) {\n\t\t\tprev = next;\n\t\t\tnext = slob_next(prev);\n\t\t}\n\n\t\tif (!slob_last(prev) && b + units == next) {\n\t\t\tunits += slob_units(next);\n\t\t\tset_slob(b, units, slob_next(next));\n\t\t} else\n\t\t\tset_slob(b, units, next);\n\n\t\tif (prev + slob_units(prev) == b) {\n\t\t\tunits = slob_units(b) + slob_units(prev);\n\t\t\tset_slob(prev, units, slob_next(b));\n\t\t} else\n\t\t\tset_slob(prev, slob_units(prev), b);\n\t}\nout:\n\tspin_unlock_irqrestore(&slob_lock, flags);\n}\n- kfree: void kfree(const void *x) /* <=== kfree */ \n{\n\tstruct page *page;\n\n\tif (unlikely(ZERO_OR_NULL_PTR(x)))\n\t\treturn;\n\n\tpage = virt_to_head_page(x);\n\tif (unlikely(!PageSlab(page))) {\n\t\tput_page(page);\n\t\treturn;\n\t}\n\tslab_free(page->slab, page, (void *)x, __builtin_return_address(0));\n}\n- videobuf_vm_open: static void /* <=== videobuf_vm_open */ \nvideobuf_vm_open(struct vm_area_struct *vma)\n{\n\tstruct videobuf_mapping *map = vma->vm_private_data;\n\n\tdprintk(2,\"vm_open %p [count=%d,vma=%08lx-%08lx]\\n\",map,\n\t\tmap->count,vma->vm_start,vma->vm_end);\n\tmap->count++;\n}\n- slob_page: static inline int slob_page(struct slob_page *sp) /* <=== slob_page */ \n{\n\treturn test_bit(PG_active, &sp->flags);\n}\n- dprintk: #define dprintk(level, fmt, arg...)\tif (debug >= level) \\ /* <=== drivers/media/video/videobuf-vmalloc.c:43:44:dprintk:3 */ \n\tprintk(KERN_DEBUG \"vbuf-sg: \" fmt , ## arg)\n- __you_cannot_kmalloc_that_much: \t\t\textern void __you_cannot_kmalloc_that_much(void); /* <=== __you_cannot_kmalloc_that_much */ \n- __kmalloc: void *__kmalloc(size_t size, gfp_t flags) /* <=== __kmalloc */ \n{\n\tstruct kmem_cache *s;\n\n\tif (unlikely(size > PAGE_SIZE / 2))\n\t\treturn (void *)__get_free_pages(flags | __GFP_COMP,\n\t\t\t\t\t\t\tget_order(size));\n\n\ts = get_slab(size, flags);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(s)))\n\t\treturn s;\n\n\treturn slab_alloc(s, flags, -1, __builtin_return_address(0));\n}\n- kmalloc: static inline void *kmalloc(size_t size, gfp_t flags) /* <=== kmalloc */ \n{\n\tif (__builtin_constant_p(size)) {\n\t\tint i = 0;\n\n\t\tif (!size)\n\t\t\treturn ZERO_SIZE_PTR;\n\n#define CACHE(x) \\\n\t\tif (size <= x) \\\n\t\t\tgoto found; \\\n\t\telse \\\n\t\t\ti++;\n#include \"kmalloc_sizes.h\"\n#undef CACHE\n\t\t{\n\t\t\textern void __you_cannot_kmalloc_that_much(void);\n\t\t\t__you_cannot_kmalloc_that_much();\n\t\t}\nfound:\n#ifdef CONFIG_ZONE_DMA\n\t\tif (flags & GFP_DMA)\n\t\t\treturn kmem_cache_alloc(malloc_sizes[i].cs_dmacachep,\n\t\t\t\t\t\tflags);\n#endif\n\t\treturn kmem_cache_alloc(malloc_sizes[i].cs_cachep, flags);\n\t}\n\treturn __kmalloc(size, flags);\n}\n- kmem_cache_alloc: void *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags) /* <=== kmem_cache_alloc */ \n{\n\treturn __cache_alloc(cachep, flags, __builtin_return_address(0));\n}\n- dprintk: #define dprintk(level, fmt, arg...)\tif (debug >= level) \\ /* <=== drivers/media/video/videobuf-dma-sg.c:49:50:dprintk:3 */ \n\tprintk(KERN_DEBUG \"vbuf-sg: \" fmt , ## arg)\n- kfree: void kfree(const void *objp) /* <=== kfree */ \n{\n\tstruct kmem_cache *c;\n\tunsigned long flags;\n\n\tif (unlikely(ZERO_OR_NULL_PTR(objp)))\n\t\treturn;\n\tlocal_irq_save(flags);\n\tkfree_debugcheck(objp);\n\tc = virt_to_cache(objp);\n\tdebug_check_no_locks_freed(objp, obj_size(c));\n\t__cache_free(c, (void *)objp);\n\tlocal_irq_restore(flags);\n}\n- ARCH_SLAB_MINALIGN: #define ARCH_SLAB_MINALIGN __alignof__(unsigned long) /* <=== mm/slob.c:436:436:ARCH_SLAB_MINALIGN:0 */ \n- MAGIC_CHECK: #define MAGIC_CHECK(is,should)\tif (unlikely((is) != (should))) \\ /* <=== drivers/media/video/videobuf-vmalloc.c:33:34:MAGIC_CHECK:2 */ \n\t{ printk(KERN_ERR \"magic mismatch: %x (expected %x)\\n\",is,should); BUG(); }\n- kmalloc: static inline void *kmalloc(size_t size, gfp_t flags) /* <=== kmalloc */ \n{\n\treturn __kmalloc_node(size, flags, -1);\n}\n- kmem_cache_alloc: void *kmem_cache_alloc(struct kmem_cache *s, gfp_t gfpflags) /* <=== kmem_cache_alloc */ \n{\n\treturn slab_alloc(s, gfpflags, -1, __builtin_return_address(0));\n}\n- kmem_cache_alloc: static inline void *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags) /* <=== kmem_cache_alloc */ \n{\n\treturn kmem_cache_alloc_node(cachep, flags, -1);\n}\n- ARCH_KMALLOC_MINALIGN: #define ARCH_KMALLOC_MINALIGN __alignof__(unsigned long) /* <=== mm/slob.c:432:432:ARCH_KMALLOC_MINALIGN:0 */ \n- __kmalloc_node: void *__kmalloc_node(size_t size, gfp_t gfp, int node) /* <=== __kmalloc_node */ \n{\n\tunsigned int *m;\n\tint align = max(ARCH_KMALLOC_MINALIGN, ARCH_SLAB_MINALIGN);\n\n\tif (size < PAGE_SIZE - align) {\n\t\tif (!size)\n\t\t\treturn ZERO_SIZE_PTR;\n\n\t\tm = slob_alloc(size + align, gfp, align, node);\n\t\tif (m)\n\t\t\t*m = size;\n\t\treturn (void *)m + align;\n\t} else {\n\t\tvoid *ret;\n\n\t\tret = slob_new_page(gfp | __GFP_COMP, get_order(size), node);\n\t\tif (ret) {\n\t\t\tstruct page *page;\n\t\t\tpage = virt_to_page(ret);\n\t\t\tpage->private = size;\n\t\t}\n\t\treturn ret;\n\t}\n}\n- __kmalloc: static inline void *__kmalloc(size_t size, gfp_t flags) /* <=== __kmalloc */ \n{\n\treturn kmalloc(size, flags);\n}\n- __kmalloc: void *__kmalloc(size_t size, gfp_t flags) /* <=== __kmalloc */ \n{\n\treturn __do_kmalloc(size, flags, NULL);\n}\n- virt_to_cache: static inline struct kmem_cache *virt_to_cache(const void *obj) /* <=== virt_to_cache */ \n{\n\tstruct page *page = virt_to_head_page(obj);\n\treturn page_get_cache(page);\n}\n- obj_size: #define obj_size(cachep)\t\t(cachep->buffer_size) /* <=== mm/slab.c:564:564:obj_size:1 */ \n- remap_vmalloc_range: extern int remap_vmalloc_range(struct vm_area_struct *vma, void *addr, /* <=== remap_vmalloc_range */ \n\t\t\t\t\t\t\tunsigned long pgoff);\n- __cache_free: static inline void __cache_free(struct kmem_cache *cachep, void *objp) /* <=== __cache_free */ \n{\n\tstruct array_cache *ac = cpu_cache_get(cachep);\n\n\tcheck_irq_off();\n\tobjp = cache_free_debugcheck(cachep, objp, __builtin_return_address(0));\n\n\t/*\n\t * Skip calling cache_free_alien() when the platform is not numa.\n\t * This will avoid cache misses that happen while accessing slabp (which\n\t * is per page memory  reference) to get nodeid. Instead use a global\n\t * variable to skip the call, which is mostly likely to be present in\n\t * the cache.\n\t */\n\tif (numa_platform && cache_free_alien(cachep, objp))\n\t\treturn;\n\n\tif (likely(ac->avail < ac->limit)) {\n\t\tSTATS_INC_FREEHIT(cachep);\n\t\tac->entry[ac->avail++] = objp;\n\t\treturn;\n\t} else {\n\t\tSTATS_INC_FREEMISS(cachep);\n\t\tcache_flusharray(cachep, ac);\n\t\tac->entry[ac->avail++] = objp;\n\t}\n}\n- kfree: void kfree(const void *block) /* <=== kfree */ \n{\n\tstruct slob_page *sp;\n\n\tif (unlikely(ZERO_OR_NULL_PTR(block)))\n\t\treturn;\n\n\tsp = (struct slob_page *)virt_to_page(block);\n\tif (slob_page(sp)) {\n\t\tint align = max(ARCH_KMALLOC_MINALIGN, ARCH_SLAB_MINALIGN);\n\t\tunsigned int *m = (unsigned int *)(block - align);\n\t\tslob_free(m, *m + align);\n\t} else\n\t\tput_page(&sp->page);\n}\n- CACHE: #define CACHE(x) \\ /* <=== include/linux/slab_def.h:39:43:CACHE:1 */ \n\t\tif (size <= x) \\\n\t\t\tgoto found; \\\n\t\telse \\\n\t\t\ti++;\n- kfree_debugcheck: #define kfree_debugcheck(x) do { } while(0) /* <=== mm/slab.c:2952:2952:kfree_debugcheck:1 */ \n\nType Definitions:\n- videobuf_queue: struct videobuf_queue\n- vm_operations_struct: static struct vm_operations_struct\n- videbuf_vmalloc_memory: struct videbuf_vmalloc_memory\n{\n\tu32                 magic;\n\n\tvoid                *vmalloc;\n\n\t/* remap_vmalloc_range seems to need to run after mmap() on some cases */\n\tstruct vm_area_struct *vma;\n}\n- videobuf_mapping: struct videobuf_mapping {\n\tunsigned int count;\n\tunsigned long start;\n\tunsigned long end;\n\tstruct videobuf_queue *q;\n}\n- videobuf_queue: struct videobuf_queue {\n\tstruct mutex               lock;\n\tspinlock_t                 *irqlock;\n\tvoid\t\t\t   *dev; /* on pci, points to struct pci_dev */\n\n\tenum v4l2_buf_type         type;\n\tunsigned int               inputs; /* for V4L2_BUF_FLAG_INPUT */\n\tunsigned int               msize;\n\tenum v4l2_field            field;\n\tenum v4l2_field            last;   /* for field=V4L2_FIELD_ALTERNATE */\n\tstruct videobuf_buffer     *bufs[VIDEO_MAX_FRAME];\n\tstruct videobuf_queue_ops  *ops;\n\tstruct videobuf_qtype_ops  *int_ops;\n\n\t/* capture via mmap() + ioctl(QBUF/DQBUF) */\n\tunsigned int               streaming;\n\tstruct list_head           stream;\n\n\t/* capture via read() */\n\tunsigned int               reading;\n\tunsigned int               read_off;\n\tstruct videobuf_buffer     *read_buf;\n\n\t/* driver private data */\n\tvoid                       *priv_data;\n}\n- vm_area_struct: struct vm_area_struct\n\nGlobal Variables:\n- struct vm_operations_struct videobuf_vm_ops\n\nImports:\n- #include <linux/moduleparam.h>\n- #include <media/videobuf-vmalloc.h>\n- #include <linux/interrupt.h>\n- #include <linux/pci.h>\n- #include <linux/vmalloc.h>\n- #include <linux/pagemap.h>\n- #include <linux/module.h>\n- #include <asm/page.h>\n- #include <linux/init.h>\n- #include <linux/slab.h>\n- #include <asm/pgtable.h>",
    "commit_msg": "V4L/DVB (6751): V4L: Memory leak!  Fix count in videobuf-vmalloc mmap\n\nThis is pretty serious bug.  map->count is never initialized after the\ncall to kmalloc making the count start at some random trash value.  The\nend result is leaking videobufs.\n\nAlso, fix up the debug statements to print unsigned values.\n\nPushed to http://ifup.org/hg/v4l-dvb too\n\nSigned-off-by: Brandon Philips <bphilips@suse.de>\nSigned-off-by: Mauro Carvalho Chehab <mchehab@infradead.org>",
    "cve_desc": "[{'lang': 'en', 'value': 'drivers/media/video/videobuf-vmalloc.c in the Linux kernel before 2.6.24 does not initialize videobuf_mapping data structures, which allows local users to trigger an incorrect count value and videobuf leak via unspecified vectors, a different vulnerability than CVE-2010-5321.'}]",
    "year": 2007,
    "filename": "videobuf-vmalloc.c",
    "commit_url": "\"https://github.com/torvalds/linux/commit/0b29669c065f60501e7289e1950fa2a618962358\""
  },
  {
    "repository": "torvalds/linux",
    "cve_id": "CVE-2007-6762",
    "cwe_list": [
      "CWE-119"
    ],
    "commit_hash": "2a2f11c227bdf292b3a2900ad04139d301b56ac4",
    "short_hash": "2a2f11c2",
    "vulnerableMethods_before": [
      {
        "filename": "net/netlabel/netlabel_cipso_v4.c",
        "method_name": "netlbl_cipsov4_add_common",
        "raw_code": "static int netlbl_cipsov4_add_common(struct genl_info *info, /* <=== netlbl_cipsov4_add_common */ \n\t\t\t\t     struct cipso_v4_doi *doi_def)\n{\n\tstruct nlattr *nla;\n\tint nla_rem;\n\tu32 iter = 0;\n\n\tdoi_def->doi = nla_get_u32(info->attrs[NLBL_CIPSOV4_A_DOI]);\n\n\tif (nla_validate_nested(info->attrs[NLBL_CIPSOV4_A_TAGLST],\n\t\t\t\tNLBL_CIPSOV4_A_MAX,\n\t\t\t\tnetlbl_cipsov4_genl_policy) != 0)\n\t\treturn -EINVAL;\n\n\tnla_for_each_nested(nla, info->attrs[NLBL_CIPSOV4_A_TAGLST], nla_rem)\n\t\tif (nla->nla_type == NLBL_CIPSOV4_A_TAG) {\n\t\t\tif (iter > CIPSO_V4_TAG_MAXCNT)\n\t\t\t\treturn -EINVAL;\n\t\t\tdoi_def->tags[iter++] = nla_get_u8(nla);\n\t\t}\n\tif (iter < CIPSO_V4_TAG_MAXCNT)\n\t\tdoi_def->tags[iter] = CIPSO_V4_TAG_INVALID;\n\n\treturn 0;\n}",
        "start_line": 117
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "net/netlabel/netlabel_cipso_v4.c",
        "method_name": "netlbl_cipsov4_add_common",
        "raw_code": "static int netlbl_cipsov4_add_common(struct genl_info *info, /* <=== netlbl_cipsov4_add_common */ \n\t\t\t\t     struct cipso_v4_doi *doi_def)\n{\n\tstruct nlattr *nla;\n\tint nla_rem;\n\tu32 iter = 0;\n\n\tdoi_def->doi = nla_get_u32(info->attrs[NLBL_CIPSOV4_A_DOI]);\n\n\tif (nla_validate_nested(info->attrs[NLBL_CIPSOV4_A_TAGLST],\n\t\t\t\tNLBL_CIPSOV4_A_MAX,\n\t\t\t\tnetlbl_cipsov4_genl_policy) != 0)\n\t\treturn -EINVAL;\n\n\tnla_for_each_nested(nla, info->attrs[NLBL_CIPSOV4_A_TAGLST], nla_rem)\n\t\tif (nla->nla_type == NLBL_CIPSOV4_A_TAG) {\n\t\t\tif (iter >= CIPSO_V4_TAG_MAXCNT)\n\t\t\t\treturn -EINVAL;\n\t\t\tdoi_def->tags[iter++] = nla_get_u8(nla);\n\t\t}\n\twhile (iter < CIPSO_V4_TAG_MAXCNT)\n\t\tdoi_def->tags[iter++] = CIPSO_V4_TAG_INVALID;\n\n\treturn 0;\n}",
        "start_line": 117
      }
    ],
    "code_context": "Called Methods:\n- NLBL_CIPSOV4_A_MAX: #define NLBL_CIPSOV4_A_MAX (__NLBL_CIPSOV4_A_MAX - 1) /* <=== net/netlabel/netlabel_cipso_v4.h:161:161:NLBL_CIPSOV4_A_MAX:0 */ \n- nla_validate: extern int\t\tnla_validate(struct nlattr *head, int len, int maxtype, /* <=== nla_validate */ \n\t\t\t\t     struct nla_policy *policy);\n- nla_get_u8: static inline u8 nla_get_u8(struct nlattr *nla) /* <=== nla_get_u8 */ \n{\n\treturn *(u8 *) nla_data(nla);\n}\n- nla_validate_nested: static inline int nla_validate_nested(struct nlattr *start, int maxtype, /* <=== nla_validate_nested */ \n\t\t\t\t      struct nla_policy *policy)\n{\n\treturn nla_validate(nla_data(start), nla_len(start), maxtype, policy);\n}\n- nla_get_u32: static inline u32 nla_get_u32(struct nlattr *nla) /* <=== nla_get_u32 */ \n{\n\treturn *(u32 *) nla_data(nla);\n}\n- nla_len: static inline int nla_len(const struct nlattr *nla) /* <=== nla_len */ \n{\n\treturn nla->nla_len - NLA_HDRLEN;\n}\n- nla_data: static inline void *nla_data(const struct nlattr *nla) /* <=== nla_data */ \n{\n\treturn (char *) nla + NLA_HDRLEN;\n}\n\nType Definitions:\n- cipso_v4_doi: struct cipso_v4_doi {\n\tu32 doi;\n\tu32 type;\n\tunion {\n\t\tstruct cipso_v4_std_map_tbl *std;\n\t} map;\n\tu8 tags[CIPSO_V4_TAG_MAXCNT];\n\n\tu32 valid;\n\tstruct list_head list;\n\tstruct rcu_head rcu;\n\tstruct list_head dom_list;\n}\n- genl_info: struct genl_info\n{\n\tu32\t\t\tsnd_seq;\n\tu32\t\t\tsnd_pid;\n\tstruct nlmsghdr *\tnlhdr;\n\tstruct genlmsghdr *\tgenlhdr;\n\tvoid *\t\t\tuserhdr;\n\tstruct nlattr **\tattrs;\n}\n- nlattr: struct nlattr\n{\n\t__u16           nla_len;\n\t__u16           nla_type;\n}\n\nGlobal Variables:\n- static nla_policy[NLBL_CIPSOV4_A_MAX + 1] netlbl_cipsov4_genl_policy\n\nImports:\n- #include <net/netlabel.h>\n- #include <linux/skbuff.h>\n- #include <net/netlink.h>\n- #include <net/cipso_ipv4.h>\n- #include <linux/socket.h>\n- #include <linux/types.h>\n- #include <linux/audit.h>\n- #include <net/sock.h>\n- #include <linux/string.h>\n- #include \"netlabel_user.h\"\n- #include <net/genetlink.h>\n- #include \"netlabel_cipso_v4.h\"",
    "commit_msg": "NetLabel: correct CIPSO tag handling when adding new DOI definitions\n\nThe current netlbl_cipsov4_add_common() function has two problems which are\nfixed with this patch.  The first is an off-by-one bug where it is possibile to\noverflow the doi_def->tags[] array.  The second is a bug where the same\ndoi_def->tags[] array was not always fully initialized, which caused sporadic\nfailures.\n\nSigned-off-by: Paul Moore <paul.moore@hp.com>\nSigned-off-by: James Morris <jmorris@namei.org>",
    "cve_desc": "[{'lang': 'en', 'value': 'In the Linux kernel before 2.6.20, there is an off-by-one bug in net/netlabel/netlabel_cipso_v4.c where it is possible to overflow the doi_def->tags[] array.'}]",
    "year": 2007,
    "filename": "netlabel_cipso_v4.c",
    "commit_url": "\"https://github.com/torvalds/linux/commit/2a2f11c227bdf292b3a2900ad04139d301b56ac4\""
  },
  {
    "repository": "mdadams/jasper",
    "cve_id": "CVE-2008-3522",
    "cwe_list": [
      "CWE-119"
    ],
    "commit_hash": "d678ccd27b8a062e3bfd4c80d8ce2676a8166a27",
    "short_hash": "d678ccd2",
    "vulnerableMethods_before": [
      {
        "filename": "src/libjasper/base/jas_stream.c",
        "method_name": "jas_stream_printf",
        "raw_code": "int jas_stream_printf(jas_stream_t *stream, const char *fmt, ...) /* <=== jas_stream_printf */ \n{\n\tva_list ap;\n\tchar buf[4096];\n\tint ret;\n\n\tva_start(ap, fmt);\n\tret = vsprintf(buf, fmt, ap);\n\tjas_stream_puts(stream, buf);\n\tva_end(ap);\n\treturn ret;\n}",
        "start_line": 549
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "src/libjasper/base/jas_stream.c",
        "method_name": "jas_stream_printf",
        "raw_code": "int jas_stream_printf(jas_stream_t *stream, const char *fmt, ...) /* <=== jas_stream_printf */ \n{\n\tva_list ap;\n\tchar buf[4096];\n\tint ret;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(buf, sizeof buf, fmt, ap);\n\tjas_stream_puts(stream, buf);\n\tva_end(ap);\n\treturn ret;\n}",
        "start_line": 549
      }
    ],
    "code_context": "Called Methods:\n- jas_stream_putc_macro: #define jas_stream_putc_macro(stream, c) \\ /* <=== src/libjasper/include/jasper/jas_stream.h:442:447:jas_stream_putc_macro:2 */ \n\t((!((stream)->flags_ & (JAS_STREAM_ERR | JAS_STREAM_EOF | \\\n\t  JAS_STREAM_RWLIMIT))) ? \\\n\t  (((stream)->rwlimit_ >= 0 && (stream)->rwcnt_ >= (stream)->rwlimit_) ? \\\n\t  (stream->flags_ |= JAS_STREAM_RWLIMIT, EOF) : \\\n\t  jas_stream_putc2(stream, c)) : EOF)\n- jas_stream_flushbuf: int jas_stream_flushbuf(jas_stream_t *stream, int c) /* <=== jas_stream_flushbuf */ \n{\n\tint len;\n\tint n;\n\n\t/* The stream should not be in an error or EOF state. */\n\tif ((stream->flags_ & (JAS_STREAM_ERRMASK)) != 0) {\n\t\treturn EOF;\n\t}\n\n\t/* The stream must be open for writing. */\n\tif ((stream->openmode_ & (JAS_STREAM_WRITE | JAS_STREAM_APPEND)) == 0) {\n\t\treturn EOF;\n\t}\n\n\t/* The buffer should not currently be in use for reading. */\n\tassert(!(stream->bufmode_ & JAS_STREAM_RDBUF));\n\n\t/* Note: Do not use the quantity stream->cnt to determine the number\n\tof characters in the buffer!  Depending on how this function was\n\tcalled, the stream->cnt value may be \"off-by-one\". */\n\tlen = stream->ptr_ - stream->bufstart_;\n\tif (len > 0) {\n\t\tn = (*stream->ops_->write_)(stream->obj_, (char *)\n\t\t  stream->bufstart_, len);\n\t\tif (n != len) {\n\t\t\tstream->flags_ |= JAS_STREAM_ERR;\n\t\t\treturn EOF;\n\t\t}\n\t}\n\tstream->cnt_ = stream->bufsize_;\n\tstream->ptr_ = stream->bufstart_;\n\n\tstream->bufmode_ |= JAS_STREAM_WRBUF;\n\n\tif (c != EOF) {\n\t\tassert(stream->cnt_ > 0);\n\t\treturn jas_stream_putc2(stream, c);\n\t}\n\n\treturn 0;\n}\n- jas_stream_puts: int jas_stream_puts(jas_stream_t *stream, const char *s) /* <=== jas_stream_puts */ \n{\n\twhile (*s != '\\0') {\n\t\tif (jas_stream_putc_macro(stream, *s) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\t++s;\n\t}\n\treturn 0;\n}\n\nType Definitions:\n- jas_stream_t: typedef struct {\n\n\t/* The mode in which the stream was opened. */\n\tint openmode_;\n\n\t/* The buffering mode. */\n\tint bufmode_;\n\n\t/* The stream status. */\n\tint flags_;\n\n\t/* The start of the buffer area to use for reading/writing. */\n\tuchar *bufbase_;\n\n\t/* The start of the buffer area excluding the extra initial space for\n\t  character putback. */\n\tuchar *bufstart_;\n\n\t/* The buffer size. */\n\tint bufsize_;\n\n\t/* The current position in the buffer. */\n\tuchar *ptr_;\n\n\t/* The number of characters that must be read/written before\n\tthe buffer needs to be filled/flushed. */\n\tint cnt_;\n\n\t/* A trivial buffer to be used for unbuffered operation. */\n\tuchar tinybuf_[JAS_STREAM_MAXPUTBACK + 1];\n\n\t/* The operations for the underlying stream file object. */\n\tjas_stream_ops_t *ops_;\n\n\t/* The underlying stream file object. */\n\tjas_stream_obj_t *obj_;\n\n\t/* The number of characters read/written. */\n\tlong rwcnt_;\n\n\t/* The maximum number of characters that may be read/written. */\n\tlong rwlimit_;\n\n}\n\nImports:\n- #include \"jasper/jas_types.h\"\n- #include <assert.h>\n- #include <io.h>\n- #include <ctype.h>\n- #include <stdlib.h>\n- #include <fcntl.h>\n- #include \"jasper/jas_malloc.h\"\n- #include <stdio.h>\n- #include \"jasper/jas_stream.h\"\n- #include \"jasper/jas_math.h\"\n- #include <unistd.h>\n- #include <stdarg.h>",
    "commit_msg": "CVE-2008-3522",
    "cve_desc": "Buffer overflow in the jas_stream_printf function in libjasper/base/jas_stream.c in JasPer 1.900.1 might allow context-dependent attackers to have an unknown impact via vectors related to the mif_hdr_put function and use of vsprintf.",
    "year": 2016,
    "filename": "jas_stream.c",
    "commit_url": "\"https://github.com/mdadams/jasper/commit/d678ccd27b8a062e3bfd4c80d8ce2676a8166a27\""
  },
  {
    "repository": "torvalds/linux",
    "cve_id": "CVE-2008-7316",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "124d3b7041f9a0ca7c43a6293e1cae4576c32fd5",
    "short_hash": "124d3b70",
    "vulnerableMethods_before": [
      {
        "filename": "mm/filemap.c",
        "method_name": "__iov_iter_advance_iov",
        "raw_code": "static void __iov_iter_advance_iov(struct iov_iter *i, size_t bytes) /* <=== __iov_iter_advance_iov */ \n{\n\tif (likely(i->nr_segs == 1)) {\n\t\ti->iov_offset += bytes;\n\t} else {\n\t\tconst struct iovec *iov = i->iov;\n\t\tsize_t base = i->iov_offset;\n\n\t\twhile (bytes) {\n\t\t\tint copy = min(bytes, iov->iov_len - base);\n\n\t\t\tbytes -= copy;\n\t\t\tbase += copy;\n\t\t\tif (iov->iov_len == base) {\n\t\t\t\tiov++;\n\t\t\t\tbase = 0;\n\t\t\t}\n\t\t}\n\t\ti->iov = iov;\n\t\ti->iov_offset = base;\n\t}\n}",
        "start_line": 1745
      },
      {
        "filename": "mm/filemap.c",
        "method_name": "generic_perform_write",
        "raw_code": "static ssize_t generic_perform_write(struct file *file, /* <=== generic_perform_write */ \n\t\t\t\tstruct iov_iter *i, loff_t pos)\n{\n\tstruct address_space *mapping = file->f_mapping;\n\tconst struct address_space_operations *a_ops = mapping->a_ops;\n\tlong status = 0;\n\tssize_t written = 0;\n\tunsigned int flags = 0;\n\n\t/*\n\t * Copies from kernel address space cannot fail (NFSD is a big user).\n\t */\n\tif (segment_eq(get_fs(), KERNEL_DS))\n\t\tflags |= AOP_FLAG_UNINTERRUPTIBLE;\n\n\tdo {\n\t\tstruct page *page;\n\t\tpgoff_t index;\t\t/* Pagecache index for current page */\n\t\tunsigned long offset;\t/* Offset into pagecache page */\n\t\tunsigned long bytes;\t/* Bytes to write to page */\n\t\tsize_t copied;\t\t/* Bytes copied from user */\n\t\tvoid *fsdata;\n\n\t\toffset = (pos & (PAGE_CACHE_SIZE - 1));\n\t\tindex = pos >> PAGE_CACHE_SHIFT;\n\t\tbytes = min_t(unsigned long, PAGE_CACHE_SIZE - offset,\n\t\t\t\t\t\tiov_iter_count(i));\n\nagain:\n\n\t\t/*\n\t\t * Bring in the user page that we will copy from _first_.\n\t\t * Otherwise there's a nasty deadlock on copying from the\n\t\t * same page as we're writing to, without it being marked\n\t\t * up-to-date.\n\t\t *\n\t\t * Not only is this an optimisation, but it is also required\n\t\t * to check that the address is actually valid, when atomic\n\t\t * usercopies are used, below.\n\t\t */\n\t\tif (unlikely(iov_iter_fault_in_readable(i, bytes))) {\n\t\t\tstatus = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tstatus = a_ops->write_begin(file, mapping, pos, bytes, flags,\n\t\t\t\t\t\t&page, &fsdata);\n\t\tif (unlikely(status))\n\t\t\tbreak;\n\n\t\tpagefault_disable();\n\t\tcopied = iov_iter_copy_from_user_atomic(page, i, offset, bytes);\n\t\tpagefault_enable();\n\t\tflush_dcache_page(page);\n\n\t\tstatus = a_ops->write_end(file, mapping, pos, bytes, copied,\n\t\t\t\t\t\tpage, fsdata);\n\t\tif (unlikely(status < 0))\n\t\t\tbreak;\n\t\tcopied = status;\n\n\t\tcond_resched();\n\n\t\tif (unlikely(copied == 0)) {\n\t\t\t/*\n\t\t\t * If we were unable to copy any data at all, we must\n\t\t\t * fall back to a single segment length write.\n\t\t\t *\n\t\t\t * If we didn't fallback here, we could livelock\n\t\t\t * because not all segments in the iov can be copied at\n\t\t\t * once without a pagefault.\n\t\t\t */\n\t\t\tbytes = min_t(unsigned long, PAGE_CACHE_SIZE - offset,\n\t\t\t\t\t\tiov_iter_single_seg_count(i));\n\t\t\tgoto again;\n\t\t}\n\t\tiov_iter_advance(i, copied);\n\t\tpos += copied;\n\t\twritten += copied;\n\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\n\t} while (iov_iter_count(i));\n\n\treturn written ? written : status;\n}",
        "start_line": 2208
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "mm/filemap.c",
        "method_name": "__iov_iter_advance_iov",
        "raw_code": "static void __iov_iter_advance_iov(struct iov_iter *i, size_t bytes) /* <=== __iov_iter_advance_iov */ \n{\n\tif (likely(i->nr_segs == 1)) {\n\t\ti->iov_offset += bytes;\n\t} else {\n\t\tconst struct iovec *iov = i->iov;\n\t\tsize_t base = i->iov_offset;\n\n\t\t/*\n\t\t * The !iov->iov_len check ensures we skip over unlikely\n\t\t * zero-length segments.\n\t\t */\n\t\twhile (bytes || !iov->iov_len) {\n\t\t\tint copy = min(bytes, iov->iov_len - base);\n\n\t\t\tbytes -= copy;\n\t\t\tbase += copy;\n\t\t\tif (iov->iov_len == base) {\n\t\t\t\tiov++;\n\t\t\t\tbase = 0;\n\t\t\t}\n\t\t}\n\t\ti->iov = iov;\n\t\ti->iov_offset = base;\n\t}\n}",
        "start_line": 1745
      },
      {
        "filename": "mm/filemap.c",
        "method_name": "generic_perform_write",
        "raw_code": "static ssize_t generic_perform_write(struct file *file, /* <=== generic_perform_write */ \n\t\t\t\tstruct iov_iter *i, loff_t pos)\n{\n\tstruct address_space *mapping = file->f_mapping;\n\tconst struct address_space_operations *a_ops = mapping->a_ops;\n\tlong status = 0;\n\tssize_t written = 0;\n\tunsigned int flags = 0;\n\n\t/*\n\t * Copies from kernel address space cannot fail (NFSD is a big user).\n\t */\n\tif (segment_eq(get_fs(), KERNEL_DS))\n\t\tflags |= AOP_FLAG_UNINTERRUPTIBLE;\n\n\tdo {\n\t\tstruct page *page;\n\t\tpgoff_t index;\t\t/* Pagecache index for current page */\n\t\tunsigned long offset;\t/* Offset into pagecache page */\n\t\tunsigned long bytes;\t/* Bytes to write to page */\n\t\tsize_t copied;\t\t/* Bytes copied from user */\n\t\tvoid *fsdata;\n\n\t\toffset = (pos & (PAGE_CACHE_SIZE - 1));\n\t\tindex = pos >> PAGE_CACHE_SHIFT;\n\t\tbytes = min_t(unsigned long, PAGE_CACHE_SIZE - offset,\n\t\t\t\t\t\tiov_iter_count(i));\n\nagain:\n\n\t\t/*\n\t\t * Bring in the user page that we will copy from _first_.\n\t\t * Otherwise there's a nasty deadlock on copying from the\n\t\t * same page as we're writing to, without it being marked\n\t\t * up-to-date.\n\t\t *\n\t\t * Not only is this an optimisation, but it is also required\n\t\t * to check that the address is actually valid, when atomic\n\t\t * usercopies are used, below.\n\t\t */\n\t\tif (unlikely(iov_iter_fault_in_readable(i, bytes))) {\n\t\t\tstatus = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tstatus = a_ops->write_begin(file, mapping, pos, bytes, flags,\n\t\t\t\t\t\t&page, &fsdata);\n\t\tif (unlikely(status))\n\t\t\tbreak;\n\n\t\tpagefault_disable();\n\t\tcopied = iov_iter_copy_from_user_atomic(page, i, offset, bytes);\n\t\tpagefault_enable();\n\t\tflush_dcache_page(page);\n\n\t\tstatus = a_ops->write_end(file, mapping, pos, bytes, copied,\n\t\t\t\t\t\tpage, fsdata);\n\t\tif (unlikely(status < 0))\n\t\t\tbreak;\n\t\tcopied = status;\n\n\t\tcond_resched();\n\n\t\tiov_iter_advance(i, copied);\n\t\tif (unlikely(copied == 0)) {\n\t\t\t/*\n\t\t\t * If we were unable to copy any data at all, we must\n\t\t\t * fall back to a single segment length write.\n\t\t\t *\n\t\t\t * If we didn't fallback here, we could livelock\n\t\t\t * because not all segments in the iov can be copied at\n\t\t\t * once without a pagefault.\n\t\t\t */\n\t\t\tbytes = min_t(unsigned long, PAGE_CACHE_SIZE - offset,\n\t\t\t\t\t\tiov_iter_single_seg_count(i));\n\t\t\tgoto again;\n\t\t}\n\t\tpos += copied;\n\t\twritten += copied;\n\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\n\t} while (iov_iter_count(i));\n\n\treturn written ? written : status;\n}",
        "start_line": 2212
      }
    ],
    "code_context": "Called Methods:\n- kmap_atomic: static inline void *kmap_atomic(struct page *page, enum km_type idx) /* <=== kmap_atomic */ \n{\n\tpagefault_disable();\n\treturn page_address(page);\n}\n- iov_iter_copy_from_user_atomic: size_t iov_iter_copy_from_user_atomic(struct page *page, /* <=== iov_iter_copy_from_user_atomic */ \n\t\tstruct iov_iter *i, unsigned long offset, size_t bytes)\n{\n\tchar *kaddr;\n\tsize_t copied;\n\n\tBUG_ON(!in_atomic());\n\tkaddr = kmap_atomic(page, KM_USER0);\n\tif (likely(i->nr_segs == 1)) {\n\t\tint left;\n\t\tchar __user *buf = i->iov->iov_base + i->iov_offset;\n\t\tleft = __copy_from_user_inatomic_nocache(kaddr + offset,\n\t\t\t\t\t\t\tbuf, bytes);\n\t\tcopied = bytes - left;\n\t} else {\n\t\tcopied = __iovec_copy_from_user_inatomic(kaddr + offset,\n\t\t\t\t\t\ti->iov, i->iov_offset, bytes);\n\t}\n\tkunmap_atomic(kaddr, KM_USER0);\n\n\treturn copied;\n}\n- __iovec_copy_from_user_inatomic: static size_t __iovec_copy_from_user_inatomic(char *vaddr, /* <=== __iovec_copy_from_user_inatomic */ \n\t\t\tconst struct iovec *iov, size_t base, size_t bytes)\n{\n\tsize_t copied = 0, left = 0;\n\n\twhile (bytes) {\n\t\tchar __user *buf = iov->iov_base + base;\n\t\tint copy = min(bytes, iov->iov_len - base);\n\n\t\tbase = 0;\n\t\tleft = __copy_from_user_inatomic_nocache(vaddr, buf, copy);\n\t\tcopied += copy;\n\t\tbytes -= copy;\n\t\tvaddr += copy;\n\t\tiov++;\n\n\t\tif (unlikely(left))\n\t\t\tbreak;\n\t}\n\treturn copied - left;\n}\n- iov_iter_fault_in_readable: int iov_iter_fault_in_readable(struct iov_iter *i, size_t bytes) /* <=== iov_iter_fault_in_readable */ \n{\n\tchar __user *buf = i->iov->iov_base + i->iov_offset;\n\tbytes = min(bytes, i->iov->iov_len - i->iov_offset);\n\treturn fault_in_pages_readable(buf, bytes);\n}\n\nType Definitions:\n- address_space: struct address_space\n- file: struct file\n- size_t: typedef __kernel_size_t\t\tsize_t;\n- ssize_t: typedef __kernel_ssize_t\tssize_t;\n- page: struct page\n- iovec: struct iovec\n- iovec: struct iovec\n{\n\tvoid __user *iov_base;\t/* BSD uses caddr_t (1003.1g requires void *) */\n\t__kernel_size_t iov_len; /* Must be size_t (1003.1g) */\n}\n\nImports:\n- #include <linux/pagevec.h>\n- #include <linux/hash.h>\n- #include <linux/aio.h>\n- #include <asm/mman.h>\n- #include <linux/kernel_stat.h>\n- #include <linux/slab.h>\n- #include <linux/mm.h>\n- #include <linux/mman.h>\n- #include <linux/cpuset.h>\n- #include <linux/uaccess.h>\n- #include <linux/capability.h>\n- #include <linux/pagemap.h>\n- #include <linux/module.h>\n- #include \"internal.h\"\n- #include <linux/file.h>\n- #include <linux/buffer_head.h>\n- #include <linux/hardirq.h>\n- #include <linux/security.h>\n- #include <linux/syscalls.h>\n- #include <linux/uio.h>\n- #include <linux/fs.h>\n- #include <linux/backing-dev.h>\n- #include <linux/blkdev.h>\n- #include <linux/compiler.h>\n- #include <linux/writeback.h>\n- #include <linux/swap.h>",
    "commit_msg": "fix writev regression: pan hanging unkillable and un-straceable\n\nFrederik Himpe reported an unkillable and un-straceable pan process.\n\nZero length iovecs can go into an infinite loop in writev, because the\niovec iterator does not always advance over them.\n\nThe sequence required to trigger this is not trivial. I think it\nrequires that a zero-length iovec be followed by a non-zero-length iovec\nwhich causes a pagefault in the atomic usercopy. This causes the writev\ncode to drop back into single-segment copy mode, which then tries to\ncopy the 0 bytes of the zero-length iovec; a zero length copy looks like\na failure though, so it loops.\n\nPut a test into iov_iter_advance to catch zero-length iovecs. We could\njust put the test in the fallback path, but I feel it is more robust to\nskip over zero-length iovecs throughout the code (iovec iterator may be\nused in filesystems too, so it should be robust).\n\nSigned-off-by: Nick Piggin <npiggin@suse.de>\nSigned-off-by: Ingo Molnar <mingo@elte.hu>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "cve_desc": "[{'lang': 'en', 'value': 'mm/filemap.c in the Linux kernel before 2.6.25 allows local users to cause a denial of service (infinite loop) via a writev system call that triggers an iovec of zero length, followed by a page fault for an iovec of nonzero length.'}]",
    "year": 2008,
    "filename": "filemap.c",
    "commit_url": "\"https://github.com/torvalds/linux/commit/124d3b7041f9a0ca7c43a6293e1cae4576c32fd5\""
  },
  {
    "repository": "GStreamer/gstreamer",
    "cve_id": "CVE-2009-0397",
    "cwe_list": [
      "CWE-119"
    ],
    "commit_hash": "bdc20b9baf13564d9a061343416395f8f9a92b53",
    "short_hash": "bdc20b9b",
    "vulnerableMethods_before": [
      {
        "filename": "gst/qtdemux/qtdemux.c",
        "method_name": "qtdemux_parse_samples",
        "raw_code": "static gboolean /* <=== qtdemux_parse_samples */ \nqtdemux_parse_samples (GstQTDemux * qtdemux, QtDemuxStream * stream,\n    GNode * stbl)\n{\n  int offset;\n  GNode *stsc;\n  GNode *stsz;\n  GNode *stco;\n  GNode *co64;\n  GNode *stts;\n  GNode *stss;\n  GNode *ctts;\n  const guint8 *stsc_data, *stsz_data, *stco_data;\n  int sample_size;\n  int sample_index;\n  int n_samples;\n  int n_samples_per_chunk;\n  int n_sample_times;\n  QtDemuxSample *samples;\n  gint i, j, k;\n  int index;\n  guint64 timestamp, time;\n\n  /* sample to chunk */\n  if (!(stsc = qtdemux_tree_get_child_by_type (stbl, FOURCC_stsc)))\n    goto corrupt_file;\n  stsc_data = (const guint8 *) stsc->data;\n  /* sample size */\n  if (!(stsz = qtdemux_tree_get_child_by_type (stbl, FOURCC_stsz)))\n    goto corrupt_file;\n  stsz_data = (const guint8 *) stsz->data;\n  /* chunk offsets */\n  stco = qtdemux_tree_get_child_by_type (stbl, FOURCC_stco);\n  co64 = qtdemux_tree_get_child_by_type (stbl, FOURCC_co64);\n  if (stco) {\n    stco_data = (const guint8 *) stco->data;\n  } else {\n    stco_data = NULL;\n    if (co64 == NULL)\n      goto corrupt_file;\n  }\n  /* sample time */\n  if (!(stts = qtdemux_tree_get_child_by_type (stbl, FOURCC_stts)))\n    goto corrupt_file;\n\n  /* sample sync, can be NULL */\n  stss = qtdemux_tree_get_child_by_type (stbl, FOURCC_stss);\n\n  sample_size = QT_UINT32 (stsz_data + 12);\n  if (sample_size == 0 || stream->sampled) {\n    n_samples = QT_UINT32 (stsz_data + 16);\n    GST_DEBUG_OBJECT (qtdemux, \"stsz sample_size 0, allocating n_samples %d\",\n        n_samples);\n    stream->n_samples = n_samples;\n    samples = g_new0 (QtDemuxSample, n_samples);\n    stream->samples = samples;\n\n    for (i = 0; i < n_samples; i++) {\n      if (sample_size == 0)\n        samples[i].size = QT_UINT32 (stsz_data + i * 4 + 20);\n      else\n        samples[i].size = sample_size;\n\n      GST_LOG_OBJECT (qtdemux, \"sample %d has size %d\", i, samples[i].size);\n      /* init other fields to defaults for this sample */\n      samples[i].keyframe = FALSE;\n    }\n    n_samples_per_chunk = QT_UINT32 (stsc_data + 12);\n    index = 0;\n    for (i = 0; i < n_samples_per_chunk; i++) {\n      guint32 first_chunk, last_chunk;\n      guint32 samples_per_chunk;\n\n      first_chunk = QT_UINT32 (stsc_data + 16 + i * 12 + 0) - 1;\n      if (i == n_samples_per_chunk - 1) {\n        last_chunk = G_MAXUINT32;\n      } else {\n        last_chunk = QT_UINT32 (stsc_data + 16 + i * 12 + 12) - 1;\n      }\n      samples_per_chunk = QT_UINT32 (stsc_data + 16 + i * 12 + 4);\n\n      for (j = first_chunk; j < last_chunk; j++) {\n        guint64 chunk_offset;\n\n        if (stco) {\n          chunk_offset = QT_UINT32 (stco_data + 16 + j * 4);\n        } else {\n          chunk_offset = QT_UINT64 ((guint8 *) co64->data + 16 + j * 8);\n        }\n        for (k = 0; k < samples_per_chunk; k++) {\n          GST_LOG_OBJECT (qtdemux, \"Creating entry %d with offset %lld\",\n              index, chunk_offset);\n          samples[index].chunk = j;\n          samples[index].offset = chunk_offset;\n          chunk_offset += samples[index].size;\n          index++;\n          if (index >= n_samples)\n            goto done2;\n        }\n      }\n    }\n  done2:\n\n    n_sample_times = QT_UINT32 ((guint8 *) stts->data + 12);\n    timestamp = 0;\n    stream->min_duration = 0;\n    time = 0;\n    index = 0;\n    for (i = 0; i < n_sample_times; i++) {\n      guint32 n;\n      guint32 duration;\n\n      n = QT_UINT32 ((guint8 *) stts->data + 16 + 8 * i);\n      duration = QT_UINT32 ((guint8 *) stts->data + 16 + 8 * i + 4);\n      for (j = 0; j < n; j++) {\n        GST_DEBUG_OBJECT (qtdemux, \"sample %d: timestamp %\" GST_TIME_FORMAT,\n            index, GST_TIME_ARGS (timestamp));\n\n        samples[index].timestamp = timestamp;\n        /* take first duration for fps */\n        if (stream->min_duration == 0)\n          stream->min_duration = duration;\n        /* add non-scaled values to avoid rounding errors */\n        time += duration;\n        timestamp = gst_util_uint64_scale (time, GST_SECOND, stream->timescale);\n        samples[index].duration = timestamp - samples[index].timestamp;\n\n        index++;\n      }\n    }\n    if (stss) {\n      /* mark keyframes */\n      guint32 n_sample_syncs;\n\n      n_sample_syncs = QT_UINT32 ((guint8 *) stss->data + 12);\n      if (n_sample_syncs == 0) {\n        stream->all_keyframe = TRUE;\n      } else {\n        offset = 16;\n        for (i = 0; i < n_sample_syncs; i++) {\n          /* note that the first sample is index 1, not 0 */\n          index = QT_UINT32 ((guint8 *) stss->data + offset);\n          if (index > 0) {\n            samples[index - 1].keyframe = TRUE;\n            offset += 4;\n          }\n        }\n      }\n    } else {\n      /* no stss, all samples are keyframes */\n      stream->all_keyframe = TRUE;\n    }\n  } else {\n    GST_DEBUG_OBJECT (qtdemux,\n        \"stsz sample_size %d != 0, treating chunks as samples\", sample_size);\n\n    /* treat chunks as samples */\n    if (stco) {\n      n_samples = QT_UINT32 (stco_data + 12);\n    } else {\n      n_samples = QT_UINT32 ((guint8 *) co64->data + 12);\n    }\n    stream->n_samples = n_samples;\n    GST_DEBUG_OBJECT (qtdemux, \"allocating n_samples %d\", n_samples);\n    samples = g_new0 (QtDemuxSample, n_samples);\n    stream->samples = samples;\n\n    n_samples_per_chunk = QT_UINT32 (stsc_data + 12);\n    GST_DEBUG_OBJECT (qtdemux, \"n_samples_per_chunk %d\", n_samples_per_chunk);\n    sample_index = 0;\n    timestamp = 0;\n    for (i = 0; i < n_samples_per_chunk; i++) {\n      guint32 first_chunk, last_chunk;\n      guint32 samples_per_chunk;\n\n      first_chunk = QT_UINT32 (stsc_data + 16 + i * 12 + 0) - 1;\n      /* the last chunk of each entry is calculated by taking the first chunk\n       * of the next entry; except if there is no next, where we fake it with\n       * INT_MAX */\n      if (i == n_samples_per_chunk - 1) {\n        last_chunk = G_MAXUINT32;\n      } else {\n        last_chunk = QT_UINT32 (stsc_data + 16 + i * 12 + 12) - 1;\n      }\n      samples_per_chunk = QT_UINT32 (stsc_data + 16 + i * 12 + 4);\n\n      GST_LOG_OBJECT (qtdemux,\n          \"entry %d has first_chunk %d, last_chunk %d, samples_per_chunk %d\", i,\n          first_chunk, last_chunk, samples_per_chunk);\n\n      for (j = first_chunk; j < last_chunk; j++) {\n        guint64 chunk_offset;\n\n        if (j >= n_samples)\n          goto done;\n\n        if (stco) {\n          chunk_offset = QT_UINT32 (stco_data + 16 + j * 4);\n        } else {\n          chunk_offset = QT_UINT64 ((guint8 *) co64->data + 16 + j * 8);\n        }\n        GST_LOG_OBJECT (qtdemux,\n            \"Creating entry %d with offset %\" G_GUINT64_FORMAT, j,\n            chunk_offset);\n\n        samples[j].chunk = j;\n        samples[j].offset = chunk_offset;\n\n        if (stream->samples_per_frame * stream->bytes_per_frame) {\n          samples[j].size = (samples_per_chunk * stream->n_channels) /\n              stream->samples_per_frame * stream->bytes_per_frame;\n        } else {\n          samples[j].size = samples_per_chunk;\n        }\n\n        GST_DEBUG_OBJECT (qtdemux, \"sample %d: timestamp %\" GST_TIME_FORMAT\n            \", size %u\", j, GST_TIME_ARGS (timestamp), samples[j].size);\n\n        samples[j].timestamp = timestamp;\n        sample_index += samples_per_chunk;\n\n        timestamp = gst_util_uint64_scale (sample_index,\n            GST_SECOND, stream->timescale);\n        samples[j].duration = timestamp - samples[j].timestamp;\n\n        samples[j].keyframe = TRUE;\n      }\n    }\n  }\n\n  /* composition time to sample */\n  if ((ctts = qtdemux_tree_get_child_by_type (stbl, FOURCC_ctts))) {\n    const guint8 *ctts_data = (const guint8 *) ctts->data;\n    guint32 n_entries = QT_UINT32 (ctts_data + 12);\n    guint32 count;\n    gint32 soffset;\n\n    /* Fill in the pts_offsets */\n    for (i = 0, j = 0; (j < stream->n_samples) && (i < n_entries); i++) {\n      count = QT_UINT32 (ctts_data + 16 + i * 8);\n      soffset = QT_UINT32 (ctts_data + 20 + i * 8);\n      for (k = 0; k < count; k++, j++) {\n        /* we operate with very small soffset values here, it shouldn't overflow */\n        samples[j].pts_offset = soffset * GST_SECOND / stream->timescale;\n      }\n    }\n  }\ndone:\n  return TRUE;\n\n/* ERRORS */\ncorrupt_file:\n  {\n    GST_ELEMENT_ERROR (qtdemux, STREAM, DECODE,\n        (_(\"This file is corrupt and cannot be played.\")), (NULL));\n    return FALSE;\n  }\n}",
        "start_line": 2953
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "gst/qtdemux/qtdemux.c",
        "method_name": "qtdemux_parse_samples",
        "raw_code": "static gboolean /* <=== qtdemux_parse_samples */ \nqtdemux_parse_samples (GstQTDemux * qtdemux, QtDemuxStream * stream,\n    GNode * stbl)\n{\n  int offset;\n  GNode *stsc;\n  GNode *stsz;\n  GNode *stco;\n  GNode *co64;\n  GNode *stts;\n  GNode *stss;\n  GNode *ctts;\n  const guint8 *stsc_data, *stsz_data, *stco_data;\n  int sample_size;\n  int sample_index;\n  int n_samples;\n  int n_samples_per_chunk;\n  int n_sample_times;\n  QtDemuxSample *samples;\n  gint i, j, k;\n  int index;\n  guint64 timestamp, time;\n\n  /* sample to chunk */\n  if (!(stsc = qtdemux_tree_get_child_by_type (stbl, FOURCC_stsc)))\n    goto corrupt_file;\n  stsc_data = (const guint8 *) stsc->data;\n  /* sample size */\n  if (!(stsz = qtdemux_tree_get_child_by_type (stbl, FOURCC_stsz)))\n    goto corrupt_file;\n  stsz_data = (const guint8 *) stsz->data;\n  /* chunk offsets */\n  stco = qtdemux_tree_get_child_by_type (stbl, FOURCC_stco);\n  co64 = qtdemux_tree_get_child_by_type (stbl, FOURCC_co64);\n  if (stco) {\n    stco_data = (const guint8 *) stco->data;\n  } else {\n    stco_data = NULL;\n    if (co64 == NULL)\n      goto corrupt_file;\n  }\n  /* sample time */\n  if (!(stts = qtdemux_tree_get_child_by_type (stbl, FOURCC_stts)))\n    goto corrupt_file;\n\n  /* sample sync, can be NULL */\n  stss = qtdemux_tree_get_child_by_type (stbl, FOURCC_stss);\n\n  sample_size = QT_UINT32 (stsz_data + 12);\n  if (sample_size == 0 || stream->sampled) {\n    n_samples = QT_UINT32 (stsz_data + 16);\n    GST_DEBUG_OBJECT (qtdemux, \"stsz sample_size 0, allocating n_samples %d\",\n        n_samples);\n    stream->n_samples = n_samples;\n    samples = g_new0 (QtDemuxSample, n_samples);\n    stream->samples = samples;\n\n    for (i = 0; i < n_samples; i++) {\n      if (sample_size == 0)\n        samples[i].size = QT_UINT32 (stsz_data + i * 4 + 20);\n      else\n        samples[i].size = sample_size;\n\n      GST_LOG_OBJECT (qtdemux, \"sample %d has size %d\", i, samples[i].size);\n      /* init other fields to defaults for this sample */\n      samples[i].keyframe = FALSE;\n    }\n    n_samples_per_chunk = QT_UINT32 (stsc_data + 12);\n    index = 0;\n    for (i = 0; i < n_samples_per_chunk; i++) {\n      guint32 first_chunk, last_chunk;\n      guint32 samples_per_chunk;\n\n      first_chunk = QT_UINT32 (stsc_data + 16 + i * 12 + 0) - 1;\n      if (i == n_samples_per_chunk - 1) {\n        last_chunk = G_MAXUINT32;\n      } else {\n        last_chunk = QT_UINT32 (stsc_data + 16 + i * 12 + 12) - 1;\n      }\n      samples_per_chunk = QT_UINT32 (stsc_data + 16 + i * 12 + 4);\n\n      for (j = first_chunk; j < last_chunk; j++) {\n        guint64 chunk_offset;\n\n        if (stco) {\n          chunk_offset = QT_UINT32 (stco_data + 16 + j * 4);\n        } else {\n          chunk_offset = QT_UINT64 ((guint8 *) co64->data + 16 + j * 8);\n        }\n        for (k = 0; k < samples_per_chunk; k++) {\n          GST_LOG_OBJECT (qtdemux, \"Creating entry %d with offset %lld\",\n              index, chunk_offset);\n          samples[index].chunk = j;\n          samples[index].offset = chunk_offset;\n          chunk_offset += samples[index].size;\n          index++;\n          if (index >= n_samples)\n            goto done2;\n        }\n      }\n    }\n  done2:\n\n    n_sample_times = QT_UINT32 ((guint8 *) stts->data + 12);\n    timestamp = 0;\n    stream->min_duration = 0;\n    time = 0;\n    index = 0;\n    for (i = 0; (i < n_sample_times) && (index < stream->n_samples); i++) {\n      guint32 n;\n      guint32 duration;\n\n      n = QT_UINT32 ((guint8 *) stts->data + 16 + 8 * i);\n      duration = QT_UINT32 ((guint8 *) stts->data + 16 + 8 * i + 4);\n      for (j = 0; (j < n) && (index < stream->n_samples); j++) {\n        GST_DEBUG_OBJECT (qtdemux, \"sample %d: timestamp %\" GST_TIME_FORMAT,\n            index, GST_TIME_ARGS (timestamp));\n\n        samples[index].timestamp = timestamp;\n        /* take first duration for fps */\n        if (stream->min_duration == 0)\n          stream->min_duration = duration;\n        /* add non-scaled values to avoid rounding errors */\n        time += duration;\n        timestamp = gst_util_uint64_scale (time, GST_SECOND, stream->timescale);\n        samples[index].duration = timestamp - samples[index].timestamp;\n\n        index++;\n      }\n    }\n    if (stss) {\n      /* mark keyframes */\n      guint32 n_sample_syncs;\n\n      n_sample_syncs = QT_UINT32 ((guint8 *) stss->data + 12);\n      if (n_sample_syncs == 0) {\n        stream->all_keyframe = TRUE;\n      } else {\n        offset = 16;\n        for (i = 0; i < n_sample_syncs; i++) {\n          /* note that the first sample is index 1, not 0 */\n          index = QT_UINT32 ((guint8 *) stss->data + offset);\n          if (index > 0 && index <= stream->n_samples) {\n            samples[index - 1].keyframe = TRUE;\n            offset += 4;\n          }\n        }\n      }\n    } else {\n      /* no stss, all samples are keyframes */\n      stream->all_keyframe = TRUE;\n    }\n  } else {\n    GST_DEBUG_OBJECT (qtdemux,\n        \"stsz sample_size %d != 0, treating chunks as samples\", sample_size);\n\n    /* treat chunks as samples */\n    if (stco) {\n      n_samples = QT_UINT32 (stco_data + 12);\n    } else {\n      n_samples = QT_UINT32 ((guint8 *) co64->data + 12);\n    }\n    stream->n_samples = n_samples;\n    GST_DEBUG_OBJECT (qtdemux, \"allocating n_samples %d\", n_samples);\n    samples = g_new0 (QtDemuxSample, n_samples);\n    stream->samples = samples;\n\n    n_samples_per_chunk = QT_UINT32 (stsc_data + 12);\n    GST_DEBUG_OBJECT (qtdemux, \"n_samples_per_chunk %d\", n_samples_per_chunk);\n    sample_index = 0;\n    timestamp = 0;\n    for (i = 0; i < n_samples_per_chunk; i++) {\n      guint32 first_chunk, last_chunk;\n      guint32 samples_per_chunk;\n\n      first_chunk = QT_UINT32 (stsc_data + 16 + i * 12 + 0) - 1;\n      /* the last chunk of each entry is calculated by taking the first chunk\n       * of the next entry; except if there is no next, where we fake it with\n       * INT_MAX */\n      if (i == n_samples_per_chunk - 1) {\n        last_chunk = G_MAXUINT32;\n      } else {\n        last_chunk = QT_UINT32 (stsc_data + 16 + i * 12 + 12) - 1;\n      }\n      samples_per_chunk = QT_UINT32 (stsc_data + 16 + i * 12 + 4);\n\n      GST_LOG_OBJECT (qtdemux,\n          \"entry %d has first_chunk %d, last_chunk %d, samples_per_chunk %d\", i,\n          first_chunk, last_chunk, samples_per_chunk);\n\n      for (j = first_chunk; j < last_chunk; j++) {\n        guint64 chunk_offset;\n\n        if (j >= n_samples)\n          goto done;\n\n        if (stco) {\n          chunk_offset = QT_UINT32 (stco_data + 16 + j * 4);\n        } else {\n          chunk_offset = QT_UINT64 ((guint8 *) co64->data + 16 + j * 8);\n        }\n        GST_LOG_OBJECT (qtdemux,\n            \"Creating entry %d with offset %\" G_GUINT64_FORMAT, j,\n            chunk_offset);\n\n        samples[j].chunk = j;\n        samples[j].offset = chunk_offset;\n\n        if (stream->samples_per_frame * stream->bytes_per_frame) {\n          samples[j].size = (samples_per_chunk * stream->n_channels) /\n              stream->samples_per_frame * stream->bytes_per_frame;\n        } else {\n          samples[j].size = samples_per_chunk;\n        }\n\n        GST_DEBUG_OBJECT (qtdemux, \"sample %d: timestamp %\" GST_TIME_FORMAT\n            \", size %u\", j, GST_TIME_ARGS (timestamp), samples[j].size);\n\n        samples[j].timestamp = timestamp;\n        sample_index += samples_per_chunk;\n\n        timestamp = gst_util_uint64_scale (sample_index,\n            GST_SECOND, stream->timescale);\n        samples[j].duration = timestamp - samples[j].timestamp;\n\n        samples[j].keyframe = TRUE;\n      }\n    }\n  }\n\n  /* composition time to sample */\n  if ((ctts = qtdemux_tree_get_child_by_type (stbl, FOURCC_ctts))) {\n    const guint8 *ctts_data = (const guint8 *) ctts->data;\n    guint32 n_entries = QT_UINT32 (ctts_data + 12);\n    guint32 count;\n    gint32 soffset;\n\n    /* Fill in the pts_offsets */\n    for (i = 0, j = 0; (j < stream->n_samples) && (i < n_entries); i++) {\n      count = QT_UINT32 (ctts_data + 16 + i * 8);\n      soffset = QT_UINT32 (ctts_data + 20 + i * 8);\n      for (k = 0; (k < count) && (j < stream->n_samples); k++, j++) {\n        /* we operate with very small soffset values here, it shouldn't overflow */\n        samples[j].pts_offset = soffset * GST_SECOND / stream->timescale;\n      }\n    }\n  }\ndone:\n  return TRUE;\n\n/* ERRORS */\ncorrupt_file:\n  {\n    GST_ELEMENT_ERROR (qtdemux, STREAM, DECODE,\n        (_(\"This file is corrupt and cannot be played.\")), (NULL));\n    return FALSE;\n  }\n}",
        "start_line": 2953
      }
    ],
    "code_context": "Called Methods:\n- FOURCC_co64: #define FOURCC_co64     GST_MAKE_FOURCC('c','o','6','4') /* <=== gst/qtdemux/qtdemux_fourcc.h:66:66:FOURCC_co64:0 */ \n- FOURCC_ctts: #define FOURCC_ctts     GST_MAKE_FOURCC('c','t','t','s') /* <=== gst/qtdemux/qtdemux_fourcc.h:135:135:FOURCC_ctts:0 */ \n- FOURCC_stts: #define FOURCC_stts     GST_MAKE_FOURCC('s','t','t','s') /* <=== gst/qtdemux/qtdemux_fourcc.h:57:57:FOURCC_stts:0 */ \n- QT_UINT32: #define QT_UINT32(a)  (GST_READ_UINT32_BE(a)) /* <=== gst/qtdemux/qtdemux_types.h:33:33:QT_UINT32:1 */ \n- QT_UINT64: #define QT_UINT64(a)  ((((guint64)QT_UINT32(a))<<32)|QT_UINT32(((guint8 *)a)+4)) /* <=== gst/qtdemux/qtdemux_types.h:40:40:QT_UINT64:1 */ \n- FOURCC_stsc: #define FOURCC_stsc     GST_MAKE_FOURCC('s','t','s','c') /* <=== gst/qtdemux/qtdemux_fourcc.h:59:59:FOURCC_stsc:0 */ \n- FOURCC_stsz: #define FOURCC_stsz     GST_MAKE_FOURCC('s','t','s','z') /* <=== gst/qtdemux/qtdemux_fourcc.h:60:60:FOURCC_stsz:0 */ \n- qtdemux_tree_get_child_by_type: static GNode * /* <=== qtdemux_tree_get_child_by_type */ \nqtdemux_tree_get_child_by_type (GNode * node, guint32 fourcc)\n{\n  GNode *child;\n  guint8 *buffer;\n  guint32 child_fourcc;\n\n  for (child = g_node_first_child (node); child;\n      child = g_node_next_sibling (child)) {\n    buffer = (guint8 *) child->data;\n\n    child_fourcc = QT_FOURCC (buffer + 4);\n\n    if (child_fourcc == fourcc) {\n      return child;\n    }\n  }\n  return NULL;\n}\n- QT_FOURCC: #define QT_FOURCC(a)  (GST_READ_UINT32_LE(a)) /* <=== gst/qtdemux/qtdemux_types.h:39:39:QT_FOURCC:1 */ \n\nType Definitions:\n- QtDemuxSample: typedef struct _QtDemuxSample QtDemuxSample;\n- QtDemuxStream: typedef struct _QtDemuxStream QtDemuxStream;\n- ANY: static const struct\n{\n  const gchar *gst_tag;\n  const GstId3v2MuxAddTagFunc func;\n  const gchar data[5];\n}\n- GstQTDemux: typedef struct _GstQTDemux GstQTDemux;\n\nImports:\n- # include <zlib.h>\n- #include \"gst/gst-i18n-plugin.h\"\n- #include <gst/tag/tag.h>\n- #include \"qtdemux.h\"\n- #include <string.h>\n- #include \"qtdemux_fourcc.h\"\n- #include \"qtpalette.h\"\n- #include <stdlib.h>\n- #include \"qtdemux_types.h\"\n- #include \"config.h\"\n- #include \"qtdemux_dump.h\"",
    "commit_msg": "Fix for security advisory TKADV2009-0xx\n\nFix potential buffer overflows while reading quicktime headers.\nSecurity issue noticed by Tobias Klein.",
    "cve_desc": "Heap-based buffer overflow in the qtdemux_parse_samples function in gst/qtdemux/qtdemux.c in GStreamer Good Plug-ins (aka gst-plugins-good) 0.10.9 through 0.10.11, and GStreamer Plug-ins (aka gstreamer-plugins) 0.8.5, might allow remote attackers to execute arbitrary code via crafted Time-to-sample (aka stts) atom data in a malformed QuickTime media .mov file.",
    "year": 2009,
    "filename": "qtdemux.c",
    "commit_url": "\"https://github.com/GStreamer/gstreamer/commit/bdc20b9baf13564d9a061343416395f8f9a92b53\""
  },
  {
    "repository": "GStreamer/gstreamer",
    "cve_id": "CVE-2009-0586",
    "cwe_list": [
      "CWE-189"
    ],
    "commit_hash": "566583e87147f774e7fc4c78b5f7e61d427e40a9",
    "short_hash": "566583e8",
    "vulnerableMethods_before": [
      {
        "filename": "gst-libs/gst/tag/gstvorbistag.c",
        "method_name": "gst_vorbis_tag_add_coverart",
        "raw_code": "static void /* <=== gst_vorbis_tag_add_coverart */ \ngst_vorbis_tag_add_coverart (GstTagList * tags, const gchar * img_data_base64,\n    gint base64_len)\n{\n  GstBuffer *img;\n  guchar *img_data;\n  gsize img_len;\n  guint save = 0;\n  gint state = 0;\n\n  if (base64_len < 2)\n    goto not_enough_data;\n\n  img_data = g_try_malloc0 (base64_len * 3 / 4);\n\n  if (img_data == NULL)\n    goto alloc_failed;\n\n  img_len = g_base64_decode_step (img_data_base64, base64_len, img_data,\n      &state, &save);\n\n  if (img_len == 0)\n    goto decode_failed;\n\n  img = gst_tag_image_data_to_image_buffer (img_data, img_len,\n      GST_TAG_IMAGE_TYPE_NONE);\n\n  if (img == NULL)\n    goto convert_failed;\n\n  gst_tag_list_add (tags, GST_TAG_MERGE_APPEND,\n      GST_TAG_PREVIEW_IMAGE, img, NULL);\n\n  gst_buffer_unref (img);\n  g_free (img_data);\n  return;\n\n/* ERRORS */\nnot_enough_data:\n  {\n    GST_WARNING (\"COVERART tag with too little base64-encoded data\");\n    return;\n  }\nalloc_failed:\n  {\n    GST_WARNING (\"Couldn't allocate enough memory to decode COVERART tag\");\n    return;\n  }\ndecode_failed:\n  {\n    GST_WARNING (\"Couldn't decode bas64 image data from COVERART tag\");\n    g_free (img_data);\n    return;\n  }\nconvert_failed:\n  {\n    GST_WARNING (\"Couldn't extract image or image type from COVERART tag\");\n    g_free (img_data);\n    return;\n  }\n}",
        "start_line": 307
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "gst-libs/gst/tag/gstvorbistag.c",
        "method_name": "gst_vorbis_tag_add_coverart",
        "raw_code": "static void /* <=== gst_vorbis_tag_add_coverart */ \ngst_vorbis_tag_add_coverart (GstTagList * tags, gchar * img_data_base64,\n    gint base64_len)\n{\n  GstBuffer *img;\n  gsize img_len;\n  guchar *out;\n  guint save = 0;\n  gint state = 0;\n\n  if (base64_len < 2)\n    goto not_enough_data;\n\n  /* img_data_base64 points to a temporary copy of the base64 encoded data, so\n   * it's safe to do inpace decoding here\n   * TODO: glib 2.20 and later provides g_base64_decode_inplace, so change this\n   * to use glib's API instead once it's in wider use:\n   *  http://bugzilla.gnome.org/show_bug.cgi?id=564728\n   *  http://svn.gnome.org/viewvc/glib?view=revision&revision=7807 */\n  out = (guchar *) img_data_base64;\n  img_len = g_base64_decode_step (img_data_base64, base64_len,\n      out, &state, &save);\n\n  if (img_len == 0)\n    goto decode_failed;\n\n  img = gst_tag_image_data_to_image_buffer (out, img_len,\n      GST_TAG_IMAGE_TYPE_NONE);\n\n  if (img == NULL)\n    goto convert_failed;\n\n  gst_tag_list_add (tags, GST_TAG_MERGE_APPEND,\n      GST_TAG_PREVIEW_IMAGE, img, NULL);\n\n  gst_buffer_unref (img);\n  return;\n\n/* ERRORS */\nnot_enough_data:\n  {\n    GST_WARNING (\"COVERART tag with too little base64-encoded data\");\n    return;\n  }\ndecode_failed:\n  {\n    GST_WARNING (\"Couldn't decode base64 image data from COVERART tag\");\n    return;\n  }\nconvert_failed:\n  {\n    GST_WARNING (\"Couldn't extract image or image type from COVERART tag\");\n    return;\n  }\n}",
        "start_line": 307
      }
    ],
    "code_context": "Called Methods:\n- gst_tag_image_type_is_valid: static inline gboolean /* <=== gst_tag_image_type_is_valid */ \ngst_tag_image_type_is_valid (GstTagImageType type)\n{\n  GEnumClass *klass;\n\n  gboolean res;\n\n  klass = g_type_class_ref (gst_tag_image_type_get_type ());\n  res = (g_enum_get_value (klass, type) != NULL);\n  g_type_class_unref (klass);\n\n  return res;\n}\n- GST_TYPE_TAG_IMAGE_TYPE: #define GST_TYPE_TAG_IMAGE_TYPE  (gst_tag_image_type_get_type ()) /* <=== gst-libs/gst/tag/tag.h:181:181:GST_TYPE_TAG_IMAGE_TYPE:0 */ \n- gst_tag_image_type_get_type: GType /* <=== gst_tag_image_type_get_type */ \ngst_tag_image_type_get_type (void)\n{\n  static GType id;\n\n  static GOnce once = G_ONCE_INIT;\n\n  g_once (&once, (GThreadFunc) register_tag_image_type_enum, &id);\n  return id;\n}\n- gst_tag_image_data_to_image_buffer: GstBuffer * /* <=== gst_tag_image_data_to_image_buffer */ \ngst_tag_image_data_to_image_buffer (const guint8 * image_data,\n    guint image_data_len, GstTagImageType image_type)\n{\n  const gchar *name;\n\n  GstBuffer *image;\n\n  GstCaps *caps;\n\n  g_return_val_if_fail (image_data != NULL, NULL);\n  g_return_val_if_fail (image_data_len > 0, NULL);\n  g_return_val_if_fail (gst_tag_image_type_is_valid (image_type), NULL);\n\n  GST_DEBUG (\"image data len: %u bytes\", image_data_len);\n\n  /* allocate space for a NUL terminator for an uri too */\n  image = gst_buffer_try_new_and_alloc (image_data_len + 1);\n  if (image == NULL) {\n    GST_WARNING (\"failed to allocate buffer of %d for image\", image_data_len);\n    return NULL;\n  }\n\n  memcpy (GST_BUFFER_DATA (image), image_data, image_data_len);\n  GST_BUFFER_DATA (image)[image_data_len] = '\\0';\n\n  /* Find GStreamer media type, can't trust declared type */\n  caps = gst_type_find_helper_for_buffer (NULL, image, NULL);\n\n  if (caps == NULL)\n    goto no_type;\n\n  GST_DEBUG (\"Found GStreamer media type: %\" GST_PTR_FORMAT, caps);\n\n  /* sanity check: make sure typefound/declared caps are either URI or image */\n  name = gst_structure_get_name (gst_caps_get_structure (caps, 0));\n\n  if (!g_str_has_prefix (name, \"image/\") &&\n      !g_str_has_prefix (name, \"video/\") &&\n      !g_str_equal (name, \"text/uri-list\")) {\n    GST_DEBUG (\"Unexpected image type '%s', ignoring image frame\", name);\n    goto error;\n  }\n\n  /* Decrease size by 1 if we don't have an URI list\n   * to keep the original size of the image\n   */\n  if (!g_str_equal (name, \"text/uri-list\"))\n    GST_BUFFER_SIZE (image) = image_data_len;\n\n  if (image_type != GST_TAG_IMAGE_TYPE_NONE) {\n    GST_LOG (\"Setting image type: %d\", image_type);\n    caps = gst_caps_make_writable (caps);\n    gst_caps_set_simple (caps, \"image-type\", GST_TYPE_TAG_IMAGE_TYPE,\n        image_type, NULL);\n  }\n\n  gst_buffer_set_caps (image, caps);\n  gst_caps_unref (caps);\n  return image;\n\n/* ERRORS */\nno_type:\n  {\n    GST_DEBUG (\"Could not determine GStreamer media type, ignoring image\");\n    /* fall through */\n  }\nerror:\n  {\n    if (image)\n      gst_buffer_unref (image);\n    if (caps)\n      gst_caps_unref (caps);\n    return NULL;\n  }\n}\n\nImports:\n- #include <gst/gsttagsetter.h>\n- #include \"gsttageditingprivate.h\"\n- #include <stdlib.h>\n- #include <string.h>\n- #include \"config.h\"",
    "commit_msg": "vorbistag: Protect memory allocation calculation from overflow.\n\nPatch by: Tomas Hoger <thoger@redhat.com> Fixes CVE-2009-0586",
    "cve_desc": "Integer overflow in the gst_vorbis_tag_add_coverart function (gst-libs/gst/tag/gstvorbistag.c) in vorbistag in gst-plugins-base (aka gstreamer-plugins-base) before 0.10.23 in GStreamer allows context-dependent attackers to execute arbitrary code via a crafted COVERART tag that is converted from a base64 representation, which triggers a heap-based buffer overflow.",
    "year": 2009,
    "filename": "gstvorbistag.c",
    "commit_url": "\"https://github.com/GStreamer/gstreamer/commit/566583e87147f774e7fc4c78b5f7e61d427e40a9\""
  },
  {
    "repository": "bratsche/pango",
    "cve_id": "CVE-2009-1194",
    "cwe_list": [
      "CWE-189"
    ],
    "commit_hash": "4de30e5500eaeb49f4bf0b7a07f718e149a2ed5e",
    "short_hash": "4de30e55",
    "vulnerableMethods_before": [
      {
        "filename": "pango/glyphstring.c",
        "method_name": "pango_glyph_string_set_size",
        "raw_code": "void /* <=== pango_glyph_string_set_size */ \npango_glyph_string_set_size (PangoGlyphString *string, gint new_len)\n{\n  g_return_if_fail (new_len >= 0);\n\n  while (new_len > string->space)\n    {\n      if (string->space == 0)\n\tstring->space = 1;\n      else\n\tstring->space *= 2;\n\n      if (string->space < 0)\n\t{\n\t  g_warning (\"glyph string length overflows maximum integer size, truncated\");\n\t  new_len = string->space = G_MAXINT - 8;\n\t}\n    }\n\n  string->glyphs = g_realloc (string->glyphs, string->space * sizeof (PangoGlyphInfo));\n  string->log_clusters = g_realloc (string->log_clusters, string->space * sizeof (gint));\n  string->num_glyphs = new_len;\n}",
        "start_line": 56
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "pango/glyphstring.c",
        "method_name": "pango_glyph_string_set_size",
        "raw_code": "void /* <=== pango_glyph_string_set_size */ \npango_glyph_string_set_size (PangoGlyphString *string, gint new_len)\n{\n  g_return_if_fail (new_len >= 0);\n\n  while (new_len > string->space)\n    {\n      if (string->space == 0)\n\t{\n\t  string->space = 4;\n\t}\n      else\n\t{\n\t  const guint max_space =\n\t    MIN (G_MAXINT, G_MAXSIZE / MAX (sizeof(PangoGlyphInfo), sizeof(gint)));\n\n\t  guint more_space = (guint)string->space * 2;\n\n\t  if (more_space > max_space)\n\t    {\n\t      more_space = max_space;\n\n\t      if ((guint)new_len > max_space)\n\t\t{\n\t\t  g_error (\"%s: failed to allocate glyph string of length %i\\n\",\n\t\t\t   G_STRLOC, new_len);\n\t\t}\n\t    }\n\n\t  string->space = more_space;\n\t}\n    }\n\n  string->glyphs = g_realloc (string->glyphs, string->space * sizeof (PangoGlyphInfo));\n  string->log_clusters = g_realloc (string->log_clusters, string->space * sizeof (gint));\n  string->num_glyphs = new_len;\n}",
        "start_line": 56
      }
    ],
    "code_context": "Type Definitions:\n- PangoGlyphInfo: typedef struct _PangoGlyphInfo PangoGlyphInfo;\n- PangoGlyphString: typedef struct _PangoGlyphString PangoGlyphString;\n\nImports:\n- #include \"config.h\"\n- #include <glib.h>\n- #include \"pango-font.h\"\n- #include \"pango-impl-utils.h\"\n- #include \"pango-glyph.h\"",
    "commit_msg": "[glyphstring] Handle overflow with very long glyphstrings",
    "cve_desc": "Integer overflow in the pango_glyph_string_set_size function in pango/glyphstring.c in Pango before 1.24 allows context-dependent attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a long glyph string that triggers a heap-based buffer overflow, as demonstrated by a long document.location value in Firefox.",
    "year": 2009,
    "filename": "glyphstring.c",
    "commit_url": "\"https://github.com/bratsche/pango/commit/4de30e5500eaeb49f4bf0b7a07f718e149a2ed5e\""
  },
  {
    "repository": "GNOME/gimp",
    "cve_id": "CVE-2009-1570",
    "cwe_list": [
      "CWE-190"
    ],
    "commit_hash": "e3afc99b2fa7aeddf0dba4778663160a5bc682d3",
    "short_hash": "e3afc99b",
    "vulnerableMethods_before": [
      {
        "filename": "plug-ins/file-bmp/bmp-read.c",
        "method_name": "ReadBMP",
        "raw_code": "gint32 /* <=== ReadBMP */ \nReadBMP (const gchar  *name,\n         GError      **error)\n{\n  FILE     *fd;\n  guchar    buffer[64];\n  gint      ColormapSize, rowbytes, Maps;\n  gboolean  Grey = FALSE;\n  guchar    ColorMap[256][3];\n  gint32    image_ID;\n  gchar     magick[2];\n  Bitmap_Channel masks[4];\n\n  filename = name;\n  fd = g_fopen (filename, \"rb\");\n\n  if (!fd)\n    {\n      g_set_error (error, G_FILE_ERROR, g_file_error_from_errno (errno),\n                   _(\"Could not open '%s' for reading: %s\"),\n                   gimp_filename_to_utf8 (filename), g_strerror (errno));\n      return -1;\n    }\n\n  gimp_progress_init_printf (_(\"Opening '%s'\"),\n                             gimp_filename_to_utf8 (name));\n\n  /* It is a File. Now is it a Bitmap? Read the shortest possible header */\n\n  if (!ReadOK (fd, magick, 2) || !(!strncmp (magick, \"BA\", 2) ||\n     !strncmp (magick, \"BM\", 2) || !strncmp (magick, \"IC\", 2) ||\n     !strncmp (magick, \"PI\", 2) || !strncmp (magick, \"CI\", 2) ||\n     !strncmp (magick, \"CP\", 2)))\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  while (!strncmp (magick, \"BA\", 2))\n    {\n      if (!ReadOK (fd, buffer, 12))\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"'%s' is not a valid BMP file\"),\n                       gimp_filename_to_utf8 (filename));\n          return -1;\n        }\n      if (!ReadOK (fd, magick, 2))\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"'%s' is not a valid BMP file\"),\n                       gimp_filename_to_utf8 (filename));\n          return -1;\n        }\n    }\n\n  if (!ReadOK (fd, buffer, 12))\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  /* bring them to the right byteorder. Not too nice, but it should work */\n\n  Bitmap_File_Head.bfSize    = ToL (&buffer[0x00]);\n  Bitmap_File_Head.zzHotX    = ToS (&buffer[0x04]);\n  Bitmap_File_Head.zzHotY    = ToS (&buffer[0x06]);\n  Bitmap_File_Head.bfOffs    = ToL (&buffer[0x08]);\n\n  if (!ReadOK (fd, buffer, 4))\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  Bitmap_File_Head.biSize    = ToL (&buffer[0x00]);\n\n  /* What kind of bitmap is it? */\n\n  if (Bitmap_File_Head.biSize == 12) /* OS/2 1.x ? */\n    {\n      if (!ReadOK (fd, buffer, 8))\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"Error reading BMP file header from '%s'\"),\n                       gimp_filename_to_utf8 (filename));\n          return -1;\n        }\n\n      Bitmap_Head.biWidth   = ToS (&buffer[0x00]);       /* 12 */\n      Bitmap_Head.biHeight  = ToS (&buffer[0x02]);       /* 14 */\n      Bitmap_Head.biPlanes  = ToS (&buffer[0x04]);       /* 16 */\n      Bitmap_Head.biBitCnt  = ToS (&buffer[0x06]);       /* 18 */\n      Bitmap_Head.biCompr   = 0;\n      Bitmap_Head.biSizeIm  = 0;\n      Bitmap_Head.biXPels   = Bitmap_Head.biYPels = 0;\n      Bitmap_Head.biClrUsed = 0;\n      Bitmap_Head.biClrImp  = 0;\n      Bitmap_Head.masks[0]  = 0;\n      Bitmap_Head.masks[1]  = 0;\n      Bitmap_Head.masks[2]  = 0;\n      Bitmap_Head.masks[3]  = 0;\n\n      memset(masks, 0, sizeof(masks));\n      Maps = 3;\n    }\n  else if (Bitmap_File_Head.biSize == 40) /* Windows 3.x */\n    {\n      if (!ReadOK (fd, buffer, 36))\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"Error reading BMP file header from '%s'\"),\n                       gimp_filename_to_utf8 (filename));\n          return -1;\n        }\n\n      Bitmap_Head.biWidth   = ToL (&buffer[0x00]);      /* 12 */\n      Bitmap_Head.biHeight  = ToL (&buffer[0x04]);      /* 16 */\n      Bitmap_Head.biPlanes  = ToS (&buffer[0x08]);       /* 1A */\n      Bitmap_Head.biBitCnt  = ToS (&buffer[0x0A]);      /* 1C */\n      Bitmap_Head.biCompr   = ToL (&buffer[0x0C]);      /* 1E */\n      Bitmap_Head.biSizeIm  = ToL (&buffer[0x10]);      /* 22 */\n      Bitmap_Head.biXPels   = ToL (&buffer[0x14]);      /* 26 */\n      Bitmap_Head.biYPels   = ToL (&buffer[0x18]);      /* 2A */\n      Bitmap_Head.biClrUsed = ToL (&buffer[0x1C]);      /* 2E */\n      Bitmap_Head.biClrImp  = ToL (&buffer[0x20]);      /* 32 */\n      Bitmap_Head.masks[0]  = 0;\n      Bitmap_Head.masks[1]  = 0;\n      Bitmap_Head.masks[2]  = 0;\n      Bitmap_Head.masks[3]  = 0;\n\n      Maps = 4;\n      memset(masks, 0, sizeof(masks));\n\n      if (Bitmap_Head.biCompr == BI_BITFIELDS)\n        {\n          if (!ReadOK (fd, buffer, 3 * sizeof (guint32)))\n            {\n              g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                           _(\"Error reading BMP file header from '%s'\"),\n                           gimp_filename_to_utf8 (filename));\n              return -1;\n            }\n\n          Bitmap_Head.masks[0] = ToL(&buffer[0x00]);\n          Bitmap_Head.masks[1] = ToL(&buffer[0x04]);\n          Bitmap_Head.masks[2] = ToL(&buffer[0x08]);\n         ReadChannelMasks (&Bitmap_Head.masks[0], masks, 3);\n        }\n      else\n        switch (Bitmap_Head.biBitCnt)\n          {\n          case 32:\n            masks[0].mask     = 0x00ff0000;\n            masks[0].shiftin  = 16;\n            masks[0].max_value= (gfloat)255.0;\n            masks[1].mask     = 0x0000ff00;\n            masks[1].shiftin  = 8;\n            masks[1].max_value= (gfloat)255.0;\n            masks[2].mask     = 0x000000ff;\n            masks[2].shiftin  = 0;\n            masks[2].max_value= (gfloat)255.0;\n            masks[3].mask     = 0xff000000;\n            masks[3].shiftin  = 24;\n            masks[3].max_value= (gfloat)255.0;\n            break;\n         case 24:\n            masks[0].mask     = 0xff0000;\n            masks[0].shiftin  = 16;\n            masks[0].max_value= (gfloat)255.0;\n            masks[1].mask     = 0x00ff00;\n            masks[1].shiftin  = 8;\n            masks[1].max_value= (gfloat)255.0;\n            masks[2].mask     = 0x0000ff;\n            masks[2].shiftin  = 0;\n            masks[2].max_value= (gfloat)255.0;\n            masks[3].mask     = 0x0;\n            masks[3].shiftin  = 0;\n            masks[3].max_value= (gfloat)0.0;\n            break;\n         case 16:\n            masks[0].mask     = 0x7c00;\n            masks[0].shiftin  = 10;\n            masks[0].max_value= (gfloat)31.0;\n            masks[1].mask     = 0x03e0;\n            masks[1].shiftin  = 5;\n            masks[1].max_value= (gfloat)31.0;\n            masks[2].mask     = 0x001f;\n            masks[2].shiftin  = 0;\n            masks[2].max_value= (gfloat)31.0;\n            masks[3].mask     = 0x0;\n            masks[3].shiftin  = 0;\n            masks[3].max_value= (gfloat)0.0;\n            break;\n         default:\n            break;\n         }\n    }\n  else if (Bitmap_File_Head.biSize >= 56 && Bitmap_File_Head.biSize <= 64)\n    /* enhanced Windows format with bit masks */\n    {\n      if (!ReadOK (fd, buffer, Bitmap_File_Head.biSize - 4))\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"Error reading BMP file header from '%s'\"),\n                       gimp_filename_to_utf8 (filename));\n          return -1;\n        }\n\n      Bitmap_Head.biWidth   =ToL (&buffer[0x00]);       /* 12 */\n      Bitmap_Head.biHeight  =ToL (&buffer[0x04]);       /* 16 */\n      Bitmap_Head.biPlanes  =ToS (&buffer[0x08]);       /* 1A */\n      Bitmap_Head.biBitCnt  =ToS (&buffer[0x0A]);       /* 1C */\n      Bitmap_Head.biCompr   =ToL (&buffer[0x0C]);       /* 1E */\n      Bitmap_Head.biSizeIm  =ToL (&buffer[0x10]);       /* 22 */\n      Bitmap_Head.biXPels   =ToL (&buffer[0x14]);       /* 26 */\n      Bitmap_Head.biYPels   =ToL (&buffer[0x18]);       /* 2A */\n      Bitmap_Head.biClrUsed =ToL (&buffer[0x1C]);       /* 2E */\n      Bitmap_Head.biClrImp  =ToL (&buffer[0x20]);       /* 32 */\n      Bitmap_Head.masks[0]  =ToL (&buffer[0x24]);       /* 36 */\n      Bitmap_Head.masks[1]  =ToL (&buffer[0x28]);       /* 3A */\n      Bitmap_Head.masks[2]  =ToL (&buffer[0x2C]);       /* 3E */\n      Bitmap_Head.masks[3]  =ToL (&buffer[0x30]);       /* 42 */\n\n      Maps = 4;\n      ReadChannelMasks (&Bitmap_Head.masks[0], masks, 4);\n    }\n  else\n    {\n      GdkPixbuf* pixbuf = gdk_pixbuf_new_from_file(filename, NULL);\n\n      if (pixbuf)\n        {\n          gint32 layer_ID;\n\n          image_ID = gimp_image_new (gdk_pixbuf_get_width (pixbuf),\n                                     gdk_pixbuf_get_height (pixbuf),\n                                     GIMP_RGB);\n\n          layer_ID = gimp_layer_new_from_pixbuf (image_ID, _(\"Background\"),\n                                                 pixbuf,\n                                                 100.,\n                                                 GIMP_NORMAL_MODE, 0, 0);\n          g_object_unref (pixbuf);\n\n          gimp_image_set_filename (image_ID, filename);\n          gimp_image_add_layer (image_ID, layer_ID, -1);\n\n          return image_ID;\n        }\n      else\n        {\n\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"Error reading BMP file header from '%s'\"),\n                       gimp_filename_to_utf8 (filename));\n          return -1;\n        }\n    }\n\n  /* Valid bitpdepthis 1, 4, 8, 16, 24, 32 */\n  /* 16 is awful, we should probably shoot whoever invented it */\n\n  /* There should be some colors used! */\n\n  ColormapSize =\n    (Bitmap_File_Head.bfOffs - Bitmap_File_Head.biSize - 14) / Maps;\n\n  if ((Bitmap_Head.biClrUsed == 0) && (Bitmap_Head.biBitCnt <= 8))\n    ColormapSize = Bitmap_Head.biClrUsed = 1 << Bitmap_Head.biBitCnt;\n\n  if (ColormapSize > 256)\n    ColormapSize = 256;\n\n  /* Sanity checks */\n\n  if (Bitmap_Head.biHeight == 0 || Bitmap_Head.biWidth == 0)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  if (Bitmap_Head.biWidth < 0)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  if (Bitmap_Head.biPlanes != 1)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  if (Bitmap_Head.biClrUsed > 256)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  /* Windows and OS/2 declare filler so that rows are a multiple of\n   * word length (32 bits == 4 bytes)\n   */\n\n  rowbytes= ((Bitmap_Head.biWidth * Bitmap_Head.biBitCnt - 1) / 32) * 4 + 4;\n\n#ifdef DEBUG\n  printf (\"\\nSize: %u, Colors: %u, Bits: %u, Width: %u, Height: %u, \"\n          \"Comp: %u, Zeile: %u\\n\",\n          Bitmap_File_Head.bfSize,\n          Bitmap_Head.biClrUsed,\n          Bitmap_Head.biBitCnt,\n          Bitmap_Head.biWidth,\n          Bitmap_Head.biHeight,\n          Bitmap_Head.biCompr,\n          rowbytes);\n#endif\n\n  if (Bitmap_Head.biBitCnt <= 8)\n    {\n#ifdef DEBUG\n      printf (\"Colormap read\\n\");\n#endif\n      /* Get the Colormap */\n      if (!ReadColorMap (fd, ColorMap, ColormapSize, Maps, &Grey))\n        return -1;\n    }\n\n  fseek (fd, Bitmap_File_Head.bfOffs, SEEK_SET);\n\n  /* Get the Image and return the ID or -1 on error*/\n  image_ID = ReadImage (fd,\n                        Bitmap_Head.biWidth,\n                        ABS (Bitmap_Head.biHeight),\n                        ColorMap,\n                        Bitmap_Head.biClrUsed,\n                        Bitmap_Head.biBitCnt,\n                        Bitmap_Head.biCompr,\n                        rowbytes,\n                        Grey,\n                        masks,\n                        error);\n\n  if (image_ID < 0)\n    return -1;\n\n  if (Bitmap_Head.biXPels > 0 && Bitmap_Head.biYPels > 0)\n    {\n      /* Fixed up from scott@asofyet's changes last year, njl195 */\n      gdouble xresolution;\n      gdouble yresolution;\n\n      /* I don't agree with scott's feeling that Gimp should be\n       * trying to \"fix\" metric resolution translations, in the\n       * long term Gimp should be SI (metric) anyway, but we\n       * haven't told the Americans that yet  */\n\n      xresolution = Bitmap_Head.biXPels * 0.0254;\n      yresolution = Bitmap_Head.biYPels * 0.0254;\n\n      gimp_image_set_resolution (image_ID, xresolution, yresolution);\n    }\n\n  if (Bitmap_Head.biHeight < 0)\n    gimp_image_flip (image_ID, GIMP_ORIENTATION_VERTICAL);\n\n  return image_ID;\n}",
        "start_line": 136
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "plug-ins/file-bmp/bmp-read.c",
        "method_name": "ReadBMP",
        "raw_code": "gint32 /* <=== ReadBMP */ \nReadBMP (const gchar  *name,\n         GError      **error)\n{\n  FILE     *fd;\n  guchar    buffer[64];\n  gint      ColormapSize, rowbytes, Maps;\n  gboolean  Grey = FALSE;\n  guchar    ColorMap[256][3];\n  gint32    image_ID;\n  gchar     magick[2];\n  Bitmap_Channel masks[4];\n\n  filename = name;\n  fd = g_fopen (filename, \"rb\");\n\n  if (!fd)\n    {\n      g_set_error (error, G_FILE_ERROR, g_file_error_from_errno (errno),\n                   _(\"Could not open '%s' for reading: %s\"),\n                   gimp_filename_to_utf8 (filename), g_strerror (errno));\n      return -1;\n    }\n\n  gimp_progress_init_printf (_(\"Opening '%s'\"),\n                             gimp_filename_to_utf8 (name));\n\n  /* It is a File. Now is it a Bitmap? Read the shortest possible header */\n\n  if (!ReadOK (fd, magick, 2) || !(!strncmp (magick, \"BA\", 2) ||\n     !strncmp (magick, \"BM\", 2) || !strncmp (magick, \"IC\", 2) ||\n     !strncmp (magick, \"PI\", 2) || !strncmp (magick, \"CI\", 2) ||\n     !strncmp (magick, \"CP\", 2)))\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  while (!strncmp (magick, \"BA\", 2))\n    {\n      if (!ReadOK (fd, buffer, 12))\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"'%s' is not a valid BMP file\"),\n                       gimp_filename_to_utf8 (filename));\n          return -1;\n        }\n      if (!ReadOK (fd, magick, 2))\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"'%s' is not a valid BMP file\"),\n                       gimp_filename_to_utf8 (filename));\n          return -1;\n        }\n    }\n\n  if (!ReadOK (fd, buffer, 12))\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  /* bring them to the right byteorder. Not too nice, but it should work */\n\n  Bitmap_File_Head.bfSize    = ToL (&buffer[0x00]);\n  Bitmap_File_Head.zzHotX    = ToS (&buffer[0x04]);\n  Bitmap_File_Head.zzHotY    = ToS (&buffer[0x06]);\n  Bitmap_File_Head.bfOffs    = ToL (&buffer[0x08]);\n\n  if (!ReadOK (fd, buffer, 4))\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  Bitmap_File_Head.biSize    = ToL (&buffer[0x00]);\n\n  /* What kind of bitmap is it? */\n\n  if (Bitmap_File_Head.biSize == 12) /* OS/2 1.x ? */\n    {\n      if (!ReadOK (fd, buffer, 8))\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"Error reading BMP file header from '%s'\"),\n                       gimp_filename_to_utf8 (filename));\n          return -1;\n        }\n\n      Bitmap_Head.biWidth   = ToS (&buffer[0x00]);       /* 12 */\n      Bitmap_Head.biHeight  = ToS (&buffer[0x02]);       /* 14 */\n      Bitmap_Head.biPlanes  = ToS (&buffer[0x04]);       /* 16 */\n      Bitmap_Head.biBitCnt  = ToS (&buffer[0x06]);       /* 18 */\n      Bitmap_Head.biCompr   = 0;\n      Bitmap_Head.biSizeIm  = 0;\n      Bitmap_Head.biXPels   = Bitmap_Head.biYPels = 0;\n      Bitmap_Head.biClrUsed = 0;\n      Bitmap_Head.biClrImp  = 0;\n      Bitmap_Head.masks[0]  = 0;\n      Bitmap_Head.masks[1]  = 0;\n      Bitmap_Head.masks[2]  = 0;\n      Bitmap_Head.masks[3]  = 0;\n\n      memset(masks, 0, sizeof(masks));\n      Maps = 3;\n    }\n  else if (Bitmap_File_Head.biSize == 40) /* Windows 3.x */\n    {\n      if (!ReadOK (fd, buffer, 36))\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"Error reading BMP file header from '%s'\"),\n                       gimp_filename_to_utf8 (filename));\n          return -1;\n        }\n\n      Bitmap_Head.biWidth   = ToL (&buffer[0x00]);      /* 12 */\n      Bitmap_Head.biHeight  = ToL (&buffer[0x04]);      /* 16 */\n      Bitmap_Head.biPlanes  = ToS (&buffer[0x08]);       /* 1A */\n      Bitmap_Head.biBitCnt  = ToS (&buffer[0x0A]);      /* 1C */\n      Bitmap_Head.biCompr   = ToL (&buffer[0x0C]);      /* 1E */\n      Bitmap_Head.biSizeIm  = ToL (&buffer[0x10]);      /* 22 */\n      Bitmap_Head.biXPels   = ToL (&buffer[0x14]);      /* 26 */\n      Bitmap_Head.biYPels   = ToL (&buffer[0x18]);      /* 2A */\n      Bitmap_Head.biClrUsed = ToL (&buffer[0x1C]);      /* 2E */\n      Bitmap_Head.biClrImp  = ToL (&buffer[0x20]);      /* 32 */\n      Bitmap_Head.masks[0]  = 0;\n      Bitmap_Head.masks[1]  = 0;\n      Bitmap_Head.masks[2]  = 0;\n      Bitmap_Head.masks[3]  = 0;\n\n      Maps = 4;\n      memset(masks, 0, sizeof(masks));\n\n      if (Bitmap_Head.biCompr == BI_BITFIELDS)\n        {\n          if (!ReadOK (fd, buffer, 3 * sizeof (guint32)))\n            {\n              g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                           _(\"Error reading BMP file header from '%s'\"),\n                           gimp_filename_to_utf8 (filename));\n              return -1;\n            }\n\n          Bitmap_Head.masks[0] = ToL(&buffer[0x00]);\n          Bitmap_Head.masks[1] = ToL(&buffer[0x04]);\n          Bitmap_Head.masks[2] = ToL(&buffer[0x08]);\n         ReadChannelMasks (&Bitmap_Head.masks[0], masks, 3);\n        }\n      else\n        switch (Bitmap_Head.biBitCnt)\n          {\n          case 32:\n            masks[0].mask     = 0x00ff0000;\n            masks[0].shiftin  = 16;\n            masks[0].max_value= (gfloat)255.0;\n            masks[1].mask     = 0x0000ff00;\n            masks[1].shiftin  = 8;\n            masks[1].max_value= (gfloat)255.0;\n            masks[2].mask     = 0x000000ff;\n            masks[2].shiftin  = 0;\n            masks[2].max_value= (gfloat)255.0;\n            masks[3].mask     = 0xff000000;\n            masks[3].shiftin  = 24;\n            masks[3].max_value= (gfloat)255.0;\n            break;\n         case 24:\n            masks[0].mask     = 0xff0000;\n            masks[0].shiftin  = 16;\n            masks[0].max_value= (gfloat)255.0;\n            masks[1].mask     = 0x00ff00;\n            masks[1].shiftin  = 8;\n            masks[1].max_value= (gfloat)255.0;\n            masks[2].mask     = 0x0000ff;\n            masks[2].shiftin  = 0;\n            masks[2].max_value= (gfloat)255.0;\n            masks[3].mask     = 0x0;\n            masks[3].shiftin  = 0;\n            masks[3].max_value= (gfloat)0.0;\n            break;\n         case 16:\n            masks[0].mask     = 0x7c00;\n            masks[0].shiftin  = 10;\n            masks[0].max_value= (gfloat)31.0;\n            masks[1].mask     = 0x03e0;\n            masks[1].shiftin  = 5;\n            masks[1].max_value= (gfloat)31.0;\n            masks[2].mask     = 0x001f;\n            masks[2].shiftin  = 0;\n            masks[2].max_value= (gfloat)31.0;\n            masks[3].mask     = 0x0;\n            masks[3].shiftin  = 0;\n            masks[3].max_value= (gfloat)0.0;\n            break;\n         default:\n            break;\n         }\n    }\n  else if (Bitmap_File_Head.biSize >= 56 && Bitmap_File_Head.biSize <= 64)\n    /* enhanced Windows format with bit masks */\n    {\n      if (!ReadOK (fd, buffer, Bitmap_File_Head.biSize - 4))\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"Error reading BMP file header from '%s'\"),\n                       gimp_filename_to_utf8 (filename));\n          return -1;\n        }\n\n      Bitmap_Head.biWidth   =ToL (&buffer[0x00]);       /* 12 */\n      Bitmap_Head.biHeight  =ToL (&buffer[0x04]);       /* 16 */\n      Bitmap_Head.biPlanes  =ToS (&buffer[0x08]);       /* 1A */\n      Bitmap_Head.biBitCnt  =ToS (&buffer[0x0A]);       /* 1C */\n      Bitmap_Head.biCompr   =ToL (&buffer[0x0C]);       /* 1E */\n      Bitmap_Head.biSizeIm  =ToL (&buffer[0x10]);       /* 22 */\n      Bitmap_Head.biXPels   =ToL (&buffer[0x14]);       /* 26 */\n      Bitmap_Head.biYPels   =ToL (&buffer[0x18]);       /* 2A */\n      Bitmap_Head.biClrUsed =ToL (&buffer[0x1C]);       /* 2E */\n      Bitmap_Head.biClrImp  =ToL (&buffer[0x20]);       /* 32 */\n      Bitmap_Head.masks[0]  =ToL (&buffer[0x24]);       /* 36 */\n      Bitmap_Head.masks[1]  =ToL (&buffer[0x28]);       /* 3A */\n      Bitmap_Head.masks[2]  =ToL (&buffer[0x2C]);       /* 3E */\n      Bitmap_Head.masks[3]  =ToL (&buffer[0x30]);       /* 42 */\n\n      Maps = 4;\n      ReadChannelMasks (&Bitmap_Head.masks[0], masks, 4);\n    }\n  else\n    {\n      GdkPixbuf* pixbuf = gdk_pixbuf_new_from_file(filename, NULL);\n\n      if (pixbuf)\n        {\n          gint32 layer_ID;\n\n          image_ID = gimp_image_new (gdk_pixbuf_get_width (pixbuf),\n                                     gdk_pixbuf_get_height (pixbuf),\n                                     GIMP_RGB);\n\n          layer_ID = gimp_layer_new_from_pixbuf (image_ID, _(\"Background\"),\n                                                 pixbuf,\n                                                 100.,\n                                                 GIMP_NORMAL_MODE, 0, 0);\n          g_object_unref (pixbuf);\n\n          gimp_image_set_filename (image_ID, filename);\n          gimp_image_add_layer (image_ID, layer_ID, -1);\n\n          return image_ID;\n        }\n      else\n        {\n\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"Error reading BMP file header from '%s'\"),\n                       gimp_filename_to_utf8 (filename));\n          return -1;\n        }\n    }\n\n  /* Valid bitpdepthis 1, 4, 8, 16, 24, 32 */\n  /* 16 is awful, we should probably shoot whoever invented it */\n\n  /* There should be some colors used! */\n\n  ColormapSize =\n    (Bitmap_File_Head.bfOffs - Bitmap_File_Head.biSize - 14) / Maps;\n\n  if ((Bitmap_Head.biClrUsed == 0) && (Bitmap_Head.biBitCnt <= 8))\n    ColormapSize = Bitmap_Head.biClrUsed = 1 << Bitmap_Head.biBitCnt;\n\n  if (ColormapSize > 256)\n    ColormapSize = 256;\n\n  /* Sanity checks */\n\n  if (Bitmap_Head.biHeight == 0 || Bitmap_Head.biWidth == 0)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  if (Bitmap_Head.biWidth < 0 ||\n      ABS (Bitmap_Head.biHeight) < 0)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  if (Bitmap_Head.biPlanes != 1)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  if (Bitmap_Head.biClrUsed > 256)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  /* protect against integer overflows caused by malicious BMPs */\n\n  if (((guint64) Bitmap_Head.biWidth) * Bitmap_Head.biBitCnt > G_MAXINT32 ||\n      ((guint64) Bitmap_Head.biWidth) * ABS (Bitmap_Head.biHeight) > G_MAXINT32 ||\n      ((guint64) Bitmap_Head.biWidth) * ABS (Bitmap_Head.biHeight) * 4 > G_MAXINT32)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a valid BMP file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  /* Windows and OS/2 declare filler so that rows are a multiple of\n   * word length (32 bits == 4 bytes)\n   */\n\n  rowbytes= ((Bitmap_Head.biWidth * Bitmap_Head.biBitCnt - 1) / 32) * 4 + 4;\n\n#ifdef DEBUG\n  printf (\"\\nSize: %u, Colors: %u, Bits: %u, Width: %u, Height: %u, \"\n          \"Comp: %u, Zeile: %u\\n\",\n          Bitmap_File_Head.bfSize,\n          Bitmap_Head.biClrUsed,\n          Bitmap_Head.biBitCnt,\n          Bitmap_Head.biWidth,\n          Bitmap_Head.biHeight,\n          Bitmap_Head.biCompr,\n          rowbytes);\n#endif\n\n  if (Bitmap_Head.biBitCnt <= 8)\n    {\n#ifdef DEBUG\n      printf (\"Colormap read\\n\");\n#endif\n      /* Get the Colormap */\n      if (!ReadColorMap (fd, ColorMap, ColormapSize, Maps, &Grey))\n        return -1;\n    }\n\n  fseek (fd, Bitmap_File_Head.bfOffs, SEEK_SET);\n\n  /* Get the Image and return the ID or -1 on error*/\n  image_ID = ReadImage (fd,\n                        Bitmap_Head.biWidth,\n                        ABS (Bitmap_Head.biHeight),\n                        ColorMap,\n                        Bitmap_Head.biClrUsed,\n                        Bitmap_Head.biBitCnt,\n                        Bitmap_Head.biCompr,\n                        rowbytes,\n                        Grey,\n                        masks,\n                        error);\n\n  if (image_ID < 0)\n    return -1;\n\n  if (Bitmap_Head.biXPels > 0 && Bitmap_Head.biYPels > 0)\n    {\n      /* Fixed up from scott@asofyet's changes last year, njl195 */\n      gdouble xresolution;\n      gdouble yresolution;\n\n      /* I don't agree with scott's feeling that Gimp should be\n       * trying to \"fix\" metric resolution translations, in the\n       * long term Gimp should be SI (metric) anyway, but we\n       * haven't told the Americans that yet  */\n\n      xresolution = Bitmap_Head.biXPels * 0.0254;\n      yresolution = Bitmap_Head.biYPels * 0.0254;\n\n      gimp_image_set_resolution (image_ID, xresolution, yresolution);\n    }\n\n  if (Bitmap_Head.biHeight < 0)\n    gimp_image_flip (image_ID, GIMP_ORIENTATION_VERTICAL);\n\n  return image_ID;\n}",
        "start_line": 136
      }
    ],
    "code_context": "Called Methods:\n- gimp_pixel_rgn_set_rect: void      gimp_pixel_rgn_set_rect   (GimpPixelRgn  *pr, /* <=== gimp_pixel_rgn_set_rect */ \n                                     const guchar  *buf,\n                                     gint           x,\n                                     gint           y,\n                                     gint           width,\n                                     gint           height);\n- gimp_image_size_changed_detailed: void /* <=== gimp_image_size_changed_detailed */ \ngimp_image_size_changed_detailed (GimpImage *image,\n                                  gint       previous_origin_x,\n                                  gint       previous_origin_y,\n                                  gint       previous_width,\n                                  gint       previous_height)\n{\n  g_return_if_fail (GIMP_IS_IMAGE (image));\n\n  g_signal_emit (image, gimp_image_signals[SIZE_CHANGED_DETAILED], 0,\n                 previous_origin_x,\n                 previous_origin_y,\n                 previous_width,\n                 previous_height);\n}\n- gimp_drawable_get: GimpDrawable * gimp_drawable_get                    (gint32         drawable_ID); /* <=== gimp_drawable_get */ \n- gimp_layer_new: GimpLayer * /* <=== gimp_layer_new */ \ngimp_layer_new (GimpImage            *image,\n                gint                  width,\n                gint                  height,\n                GimpImageType         type,\n                const gchar          *name,\n                gdouble               opacity,\n                GimpLayerModeEffects  mode)\n{\n  GimpLayer *layer;\n\n  g_return_val_if_fail (GIMP_IS_IMAGE (image), NULL);\n  g_return_val_if_fail (width > 0, NULL);\n  g_return_val_if_fail (height > 0, NULL);\n\n  layer = g_object_new (GIMP_TYPE_LAYER, NULL);\n\n  gimp_drawable_configure (GIMP_DRAWABLE (layer),\n                           image,\n                           0, 0, width, height,\n                           type,\n                           name);\n\n  opacity = CLAMP (opacity, GIMP_OPACITY_TRANSPARENT, GIMP_OPACITY_OPAQUE);\n\n  layer->opacity = opacity;\n  layer->mode    = mode;\n\n  return layer;\n}\n- CM_GREEN: #define CM_GREEN         1 /* <=== plug-ins/common/file-gif-load.c:265:265:CM_GREEN:0 */ \n- BI_RLE4: #define BI_RLE4         2 /* <=== plug-ins/file-bmp/bmp-read.c:42:42:BI_RLE4:0 */ \n- gimp_drawable_flush: void           gimp_drawable_flush                  (GimpDrawable  *drawable); /* <=== gimp_drawable_flush */ \n- ReadImage: static gint32 /* <=== ReadImage */ \nReadImage (FILE        *fd,\n           const gchar *filename,\n           gint         len,\n           gint         height,\n           CMap         cmap,\n           gint         ncols,\n           gint         format,\n           gint         interlace,\n           gint         number,\n           guint        leftpos,\n           guint        toppos,\n           guint        screenwidth,\n           guint        screenheight)\n{\n  static gint32 image_ID   = -1;\n  static gint   frame_number = 1;\n\n  gint32        layer_ID;\n  GimpPixelRgn  pixel_rgn;\n  GimpDrawable *drawable;\n  guchar       *dest, *temp;\n  guchar        c;\n  gint          xpos = 0, ypos = 0, pass = 0;\n  gint          cur_progress, max_progress;\n  gint          v;\n  gint          i, j;\n  gchar        *framename;\n  gchar        *framename_ptr;\n  gboolean      alpha_frame = FALSE;\n  static gint   previous_disposal;\n\n  /* Guard against bogus frame size */\n  if (len < 1 || height < 1)\n    {\n      g_message (\"Bogus frame dimensions\");\n      return -1;\n    }\n\n  /*\n   **  Initialize the Compression routines\n   */\n  if (! ReadOK (fd, &c, 1))\n    {\n      g_message (\"EOF / read error on image data\");\n      return -1;\n    }\n\n  if (LZWReadByte (fd, TRUE, c) < 0)\n    {\n      g_message (\"Error while reading\");\n      return -1;\n    }\n\n  if (frame_number == 1)\n    {\n      /* Guard against bogus logical screen size values */\n      if (screenwidth == 0)\n        screenwidth = len;\n\n      if (screenheight == 0)\n        screenheight = height;\n\n      image_ID = gimp_image_new (screenwidth, screenheight, GIMP_INDEXED);\n      gimp_image_set_filename (image_ID, filename);\n\n      for (i = 0, j = 0; i < ncols; i++)\n        {\n          used_cmap[0][i] = gimp_cmap[j++] = cmap[0][i];\n          used_cmap[1][i] = gimp_cmap[j++] = cmap[1][i];\n          used_cmap[2][i] = gimp_cmap[j++] = cmap[2][i];\n        }\n\n      gimp_image_set_colormap (image_ID, gimp_cmap, ncols);\n\n      if (Gif89.delayTime < 0)\n        framename = g_strdup (_(\"Background\"));\n      else\n        framename = g_strdup_printf (_(\"Background (%d%s)\"),\n                                     10 * Gif89.delayTime, \"ms\");\n\n      previous_disposal = Gif89.disposal;\n\n      if (Gif89.transparent == -1)\n        {\n          layer_ID = gimp_layer_new (image_ID, framename,\n                                     len, height,\n                                     GIMP_INDEXED_IMAGE, 100, GIMP_NORMAL_MODE);\n        }\n      else\n        {\n          layer_ID = gimp_layer_new (image_ID, framename,\n                                     len, height,\n                                     GIMP_INDEXEDA_IMAGE, 100, GIMP_NORMAL_MODE);\n          alpha_frame=TRUE;\n        }\n\n      g_free (framename);\n    }\n  else /* NOT FIRST FRAME */\n    {\n      gimp_progress_set_text_printf (_(\"Opening '%s' (frame %d)\"),\n                                     gimp_filename_to_utf8 (filename),\n                                     frame_number);\n      gimp_progress_pulse ();\n\n       /* If the colourmap is now different, we have to promote to RGB! */\n      if (! promote_to_rgb)\n        {\n          for (i = 0; i < ncols; i++)\n            {\n              if ((used_cmap[0][i] != cmap[0][i]) ||\n                  (used_cmap[1][i] != cmap[1][i]) ||\n                  (used_cmap[2][i] != cmap[2][i]))\n                {\n                  /* Everything is RGB(A) from now on... sigh. */\n                  promote_to_rgb = TRUE;\n\n                  /* Promote everything we have so far into RGB(A) */\n#ifdef GIFDEBUG\n                  g_print (\"GIF: Promoting image to RGB...\\n\");\n#endif\n                  gimp_image_convert_rgb (image_ID);\n\n                  break;\n                }\n            }\n        }\n\n      if (Gif89.delayTime < 0)\n        framename = g_strdup_printf (_(\"Frame %d\"), frame_number);\n      else\n        framename = g_strdup_printf (_(\"Frame %d (%d%s)\"),\n                                     frame_number, 10 * Gif89.delayTime, \"ms\");\n\n      switch (previous_disposal)\n        {\n        case 0x00:\n          break; /* 'don't care' */\n        case 0x01:\n          framename_ptr = framename;\n          framename = g_strconcat (framename, \" (combine)\", NULL);\n          g_free (framename_ptr);\n          break;\n        case 0x02:\n          framename_ptr = framename;\n          framename = g_strconcat (framename, \" (replace)\", NULL);\n          g_free (framename_ptr);\n          break;\n        case 0x03:  /* Rarely-used, and unhandled by many\n                       loaders/players (including GIMP: we treat as\n                       'combine' mode). */\n          framename_ptr = framename;\n          framename = g_strconcat (framename, \" (combine) (!)\", NULL);\n          g_free (framename_ptr);\n          break;\n        case 0x04: /* I've seen a composite of this type. stvo_online_banner2.gif */\n        case 0x05:\n        case 0x06: /* I've seen a composite of this type. bn31.Gif */\n        case 0x07:\n          framename_ptr = framename;\n          framename = g_strconcat (framename, \" (unknown disposal)\", NULL);\n          g_free (framename_ptr);\n          g_message (_(\"GIF: Undocumented GIF composite type %d is \"\n                       \"not handled.  Animation might not play or \"\n                       \"re-save perfectly.\"),\n                     previous_disposal);\n          break;\n        default:\n          g_message (\"Disposal word got corrupted.  Bug.\");\n          break;\n        }\n      previous_disposal = Gif89.disposal;\n\n      layer_ID = gimp_layer_new (image_ID, framename,\n                                 len, height,\n                                 promote_to_rgb ?\n                                 GIMP_RGBA_IMAGE : GIMP_INDEXEDA_IMAGE,\n                                 100, GIMP_NORMAL_MODE);\n      alpha_frame = TRUE;\n      g_free (framename);\n    }\n\n  frame_number++;\n\n  gimp_image_add_layer (image_ID, layer_ID, 0);\n  gimp_layer_translate (layer_ID, (gint) leftpos, (gint) toppos);\n\n  drawable = gimp_drawable_get (layer_ID);\n\n  cur_progress = 0;\n  max_progress = height;\n\n  if (alpha_frame)\n    dest = (guchar *) g_malloc (len * height * (promote_to_rgb ? 4 : 2));\n  else\n    dest = (guchar *) g_malloc (len * height);\n\n#ifdef GIFDEBUG\n    g_print (\"GIF: reading %d by %d%s GIF image, ncols=%d\\n\",\n             len, height, interlace ? \" interlaced\" : \"\", ncols);\n#endif\n\n  if (! alpha_frame && promote_to_rgb)\n    {\n      /* I don't see how one would easily construct a GIF in which\n         this could happen, but it's a mad mad world. */\n      g_message (\"Ouch!  Can't handle non-alpha RGB frames.\\n\"\n                 \"Please file a bug report in GIMP's bugzilla.\");\n      gimp_quit ();\n    }\n\n  while ((v = LZWReadByte (fd, FALSE, c)) >= 0)\n    {\n      if (alpha_frame)\n        {\n          if (((guchar) v > highest_used_index) && !(v == Gif89.transparent))\n            highest_used_index = (guchar) v;\n\n          if (promote_to_rgb)\n            {\n              temp = dest + ( (ypos * len) + xpos ) * 4;\n              *(temp  ) = (guchar) cmap[0][v];\n              *(temp+1) = (guchar) cmap[1][v];\n              *(temp+2) = (guchar) cmap[2][v];\n              *(temp+3) = (guchar) ((v == Gif89.transparent) ? 0 : 255);\n            }\n          else\n            {\n              temp = dest + ( (ypos * len) + xpos ) * 2;\n              *temp = (guchar) v;\n              *(temp+1) = (guchar) ((v == Gif89.transparent) ? 0 : 255);\n            }\n        }\n      else\n        {\n          if ((guchar) v > highest_used_index)\n            highest_used_index = (guchar) v;\n\n          temp = dest + (ypos * len) + xpos;\n          *temp = (guchar) v;\n        }\n\n      xpos++;\n      if (xpos == len)\n        {\n          xpos = 0;\n          if (interlace)\n            {\n              switch (pass)\n                {\n                case 0:\n                case 1:\n                  ypos += 8;\n                  break;\n                case 2:\n                  ypos += 4;\n                  break;\n                case 3:\n                  ypos += 2;\n                  break;\n                }\n\n              if (ypos >= height)\n                {\n                  pass++;\n                  switch (pass)\n                    {\n                    case 1:\n                      ypos = 4;\n                      break;\n                    case 2:\n                      ypos = 2;\n                      break;\n                    case 3:\n                      ypos = 1;\n                      break;\n                    default:\n                      goto fini;\n                    }\n                }\n            }\n          else\n            {\n              ypos++;\n            }\n\n          if (frame_number == 1)\n            {\n              cur_progress++;\n              if ((cur_progress % 16) == 0)\n                gimp_progress_update ((gdouble) cur_progress /\n                                      (gdouble) max_progress);\n            }\n        }\n\n      if (ypos >= height)\n        break;\n    }\n\n fini:\n  if (LZWReadByte (fd, FALSE, c) >= 0)\n    g_print (\"GIF: too much input data, ignoring extra...\\n\");\n\n  gimp_pixel_rgn_init (&pixel_rgn, drawable,\n                       0, 0, drawable->width, drawable->height, TRUE, FALSE);\n  gimp_pixel_rgn_set_rect (&pixel_rgn, dest,\n                           0, 0, drawable->width, drawable->height);\n\n  g_free (dest);\n\n  gimp_drawable_flush (drawable);\n  gimp_drawable_detach (drawable);\n\n  return image_ID;\n}\n- gimp_image_get_width: gint /* <=== gimp_image_get_width */ \ngimp_image_get_width (const GimpImage *image)\n{\n  g_return_val_if_fail (GIMP_IS_IMAGE (image), 0);\n\n  return image->width;\n}\n- gimp_image_set_filename: void /* <=== gimp_image_set_filename */ \ngimp_image_set_filename (GimpImage   *image,\n                         const gchar *filename)\n{\n  g_return_if_fail (GIMP_IS_IMAGE (image));\n\n  if (filename && strlen (filename))\n    {\n      gimp_image_take_uri (image,\n                           file_utils_filename_to_uri (image->gimp,\n                                                       filename,\n                                                       NULL));\n    }\n  else\n    {\n      gimp_image_set_uri (image, NULL);\n    }\n}\n- gimp_filename_to_utf8: const gchar * /* <=== gimp_filename_to_utf8 */ \ngimp_filename_to_utf8 (const gchar *filename)\n{\n  /* Simpleminded implementation, but at least allocates just one copy\n   * of each translation. Could check if already UTF-8, and if so\n   * return filename as is. Could perhaps (re)use a suitably large\n   * cyclic buffer, but then would have to verify that all calls\n   * really need the return value just for a \"short\" time.\n   */\n\n  static GHashTable *ht = NULL;\n  gchar             *filename_utf8;\n\n  if (! filename)\n    return NULL;\n\n  if (! ht)\n    ht = g_hash_table_new (g_str_hash, g_str_equal);\n\n  filename_utf8 = g_hash_table_lookup (ht, filename);\n\n  if (! filename_utf8)\n    {\n      filename_utf8 = g_filename_display_name (filename);\n      g_hash_table_insert (ht, g_strdup (filename), filename_utf8);\n    }\n\n  return filename_utf8;\n}\n- gimp_destroy_params: void /* <=== gimp_destroy_params */ \ngimp_destroy_params (GimpParam *params,\n                     gint       n_params)\n{\n  gp_params_destroy ((GPParam *) params, n_params);\n}\n- BI_BITFIELDS: #define BI_BITFIELDS    3 /* <=== plug-ins/file-bmp/bmp-read.c:43:43:BI_BITFIELDS:0 */ \n- gimp_image_set_resolution: void /* <=== gimp_image_set_resolution */ \ngimp_image_set_resolution (GimpImage *image,\n                           gdouble    xresolution,\n                           gdouble    yresolution)\n{\n  g_return_if_fail (GIMP_IS_IMAGE (image));\n\n  /* don't allow to set the resolution out of bounds */\n  if (xresolution < GIMP_MIN_RESOLUTION || xresolution > GIMP_MAX_RESOLUTION ||\n      yresolution < GIMP_MIN_RESOLUTION || yresolution > GIMP_MAX_RESOLUTION)\n    return;\n\n  if ((ABS (image->xresolution - xresolution) >= 1e-5) ||\n      (ABS (image->yresolution - yresolution) >= 1e-5))\n    {\n      gimp_image_undo_push_image_resolution (image,\n                                             _(\"Change Image Resolution\"));\n\n      image->xresolution = xresolution;\n      image->yresolution = yresolution;\n\n      gimp_image_resolution_changed (image);\n      gimp_image_size_changed_detailed (image,\n                                        0,\n                                        0,\n                                        gimp_image_get_width (image),\n                                        gimp_image_get_height (image));\n    }\n}\n- gimp_progress_update: gboolean /* <=== gimp_progress_update */ \ngimp_progress_update (gdouble percentage)\n{\n  gboolean changed;\n\n  if (percentage <= 0.0)\n    {\n      changed = (gimp_progress_current != 0.0);\n      percentage = 0.0;\n    }\n  else if (percentage >= 1.0)\n    {\n      changed = (gimp_progress_current != 1.0);\n      percentage = 1.0;\n    }\n  else\n    {\n      changed =\n        (fabs (gimp_progress_current - percentage) > gimp_progress_step);\n\n#ifdef GIMP_UNSTABLE\n      if (! changed)\n        {\n          static gboolean warned = FALSE;\n          static gint     count  = 0;\n\n          count++;\n\n          if (count > 3 && ! warned)\n            {\n              g_printerr (\"%s is updating the progress too often\\n\",\n                          g_get_prgname ());\n              warned = TRUE;\n            }\n        }\n#endif\n    }\n\n  /*  Suppress the update if the change was only marginal.  */\n  if (! changed)\n    return TRUE;\n\n  gimp_progress_current = percentage;\n\n  return _gimp_progress_update (gimp_progress_current);\n}\n- COLOR: #define COLOR            2 /* <=== plug-ins/common/file-gif-load.c:278:278:COLOR:0 */ \n- gimp_image_resolution_changed: void /* <=== gimp_image_resolution_changed */ \ngimp_image_resolution_changed (GimpImage *image)\n{\n  g_return_if_fail (GIMP_IS_IMAGE (image));\n\n  g_signal_emit (image, gimp_image_signals[RESOLUTION_CHANGED], 0);\n}\n- gimp_run_procedure: GimpParam * /* <=== gimp_run_procedure */ \ngimp_run_procedure (const gchar *name,\n                    gint        *n_return_vals,\n                    ...)\n{\n  GimpPDBArgType  param_type;\n  GimpParam      *return_vals;\n  GimpParam      *params   = NULL;\n  gint            n_params = 0;\n  va_list         args;\n  gint            i;\n\n  g_return_val_if_fail (name != NULL, NULL);\n  g_return_val_if_fail (n_return_vals != NULL, NULL);\n\n  va_start (args, n_return_vals);\n  param_type = va_arg (args, GimpPDBArgType);\n\n  while (param_type != GIMP_PDB_END)\n    {\n      switch (param_type)\n        {\n        case GIMP_PDB_INT32:\n        case GIMP_PDB_DISPLAY:\n        case GIMP_PDB_IMAGE:\n        case GIMP_PDB_LAYER:\n        case GIMP_PDB_CHANNEL:\n        case GIMP_PDB_DRAWABLE:\n        case GIMP_PDB_SELECTION:\n        case GIMP_PDB_VECTORS:\n        case GIMP_PDB_STATUS:\n          (void) va_arg (args, gint);\n          break;\n        case GIMP_PDB_INT16:\n          (void) va_arg (args, gint);\n          break;\n        case GIMP_PDB_INT8:\n          (void) va_arg (args, gint);\n          break;\n        case GIMP_PDB_FLOAT:\n          (void) va_arg (args, gdouble);\n          break;\n        case GIMP_PDB_STRING:\n          (void) va_arg (args, gchar *);\n          break;\n        case GIMP_PDB_INT32ARRAY:\n          (void) va_arg (args, gint32 *);\n          break;\n        case GIMP_PDB_INT16ARRAY:\n          (void) va_arg (args, gint16 *);\n          break;\n        case GIMP_PDB_INT8ARRAY:\n          (void) va_arg (args, gint8 *);\n          break;\n        case GIMP_PDB_FLOATARRAY:\n          (void) va_arg (args, gdouble *);\n          break;\n        case GIMP_PDB_STRINGARRAY:\n          (void) va_arg (args, gchar **);\n          break;\n        case GIMP_PDB_COLOR:\n\tcase GIMP_PDB_COLORARRAY:\n          (void) va_arg (args, GimpRGB *);\n          break;\n        case GIMP_PDB_PARASITE:\n          (void) va_arg (args, GimpParasite *);\n          break;\n        case GIMP_PDB_REGION:\n          break;\n        case GIMP_PDB_END:\n          break;\n        }\n\n      n_params++;\n\n      param_type = va_arg (args, GimpPDBArgType);\n    }\n\n  va_end (args);\n\n  params = g_new0 (GimpParam, n_params);\n\n  va_start (args, n_return_vals);\n\n  for (i = 0; i < n_params; i++)\n    {\n      params[i].type = va_arg (args, GimpPDBArgType);\n\n      switch (params[i].type)\n        {\n        case GIMP_PDB_INT32:\n          params[i].data.d_int32 = (gint32) va_arg (args, gint);\n          break;\n        case GIMP_PDB_INT16:\n          params[i].data.d_int16 = (gint16) va_arg (args, gint);\n          break;\n        case GIMP_PDB_INT8:\n          params[i].data.d_int8 = (guint8) va_arg (args, gint);\n          break;\n        case GIMP_PDB_FLOAT:\n          params[i].data.d_float = (gdouble) va_arg (args, gdouble);\n          break;\n        case GIMP_PDB_STRING:\n          params[i].data.d_string = va_arg (args, gchar *);\n          break;\n        case GIMP_PDB_INT32ARRAY:\n          params[i].data.d_int32array = va_arg (args, gint32 *);\n          break;\n        case GIMP_PDB_INT16ARRAY:\n          params[i].data.d_int16array = va_arg (args, gint16 *);\n          break;\n        case GIMP_PDB_INT8ARRAY:\n          params[i].data.d_int8array = va_arg (args, guint8 *);\n          break;\n        case GIMP_PDB_FLOATARRAY:\n          params[i].data.d_floatarray = va_arg (args, gdouble *);\n          break;\n        case GIMP_PDB_STRINGARRAY:\n          params[i].data.d_stringarray = va_arg (args, gchar **);\n          break;\n        case GIMP_PDB_COLOR:\n          params[i].data.d_color = *va_arg (args, GimpRGB *);\n          break;\n        case GIMP_PDB_REGION:\n          break;\n        case GIMP_PDB_DISPLAY:\n          params[i].data.d_display = va_arg (args, gint32);\n          break;\n        case GIMP_PDB_IMAGE:\n          params[i].data.d_image = va_arg (args, gint32);\n          break;\n        case GIMP_PDB_LAYER:\n          params[i].data.d_layer = va_arg (args, gint32);\n          break;\n        case GIMP_PDB_CHANNEL:\n          params[i].data.d_channel = va_arg (args, gint32);\n          break;\n        case GIMP_PDB_DRAWABLE:\n          params[i].data.d_drawable = va_arg (args, gint32);\n          break;\n        case GIMP_PDB_SELECTION:\n          params[i].data.d_selection = va_arg (args, gint32);\n          break;\n        case GIMP_PDB_COLORARRAY:\n          params[i].data.d_colorarray = va_arg (args, GimpRGB *);\n          break;\n        case GIMP_PDB_VECTORS:\n          params[i].data.d_vectors = va_arg (args, gint32);\n          break;\n        case GIMP_PDB_PARASITE:\n          {\n            GimpParasite *parasite = va_arg (args, GimpParasite *);\n\n            if (parasite == NULL)\n              {\n                params[i].data.d_parasite.name = NULL;\n                params[i].data.d_parasite.data = NULL;\n              }\n            else\n              {\n                params[i].data.d_parasite.name  = parasite->name;\n                params[i].data.d_parasite.flags = parasite->flags;\n                params[i].data.d_parasite.size  = parasite->size;\n                params[i].data.d_parasite.data  = parasite->data;\n              }\n          }\n          break;\n        case GIMP_PDB_STATUS:\n          params[i].data.d_status = va_arg (args, gint32);\n          break;\n        case GIMP_PDB_END:\n          break;\n        }\n    }\n\n  va_end (args);\n\n  return_vals = gimp_run_procedure2 (name, n_return_vals, n_params, params);\n\n  g_free (params);\n\n  return return_vals;\n}\n- ReadColorMap: static gboolean /* <=== ReadColorMap */ \nReadColorMap (FILE *fd,\n              gint  number,\n              CMap  buffer,\n              gint *format)\n{\n  guchar rgb[3];\n  gint   flag;\n  gint   i;\n\n  flag = TRUE;\n\n  for (i = 0; i < number; ++i)\n    {\n      if (! ReadOK (fd, rgb, sizeof (rgb)))\n        return FALSE;\n\n      buffer[CM_RED][i] = rgb[0];\n      buffer[CM_GREEN][i] = rgb[1];\n      buffer[CM_BLUE][i] = rgb[2];\n\n      flag &= (rgb[0] == rgb[1] && rgb[1] == rgb[2]);\n    }\n\n  *format = (flag) ? GRAYSCALE : COLOR;\n\n  return TRUE;\n}\n- LZWReadByte: static gint /* <=== LZWReadByte */ \nLZWReadByte (FILE *fd,\n             gint  just_reset_LZW,\n             gint  input_code_size)\n{\n  static gint fresh = FALSE;\n  gint        code, incode;\n  static gint code_size, set_code_size;\n  static gint max_code, max_code_size;\n  static gint firstcode, oldcode;\n  static gint clear_code, end_code;\n  static gint table[2][(1 << MAX_LZW_BITS)];\n  static gint stack[(1 << (MAX_LZW_BITS)) * 2], *sp;\n  gint        i;\n\n  if (just_reset_LZW)\n    {\n      if (input_code_size > MAX_LZW_BITS)\n        {\n          g_message (\"Value out of range for code size (corrupted file?)\");\n          return -1;\n        }\n\n      set_code_size = input_code_size;\n      code_size     = set_code_size + 1;\n      clear_code    = 1 << set_code_size;\n      end_code      = clear_code + 1;\n      max_code_size = 2 * clear_code;\n      max_code      = clear_code + 2;\n\n      GetCode (fd, 0, TRUE);\n\n      fresh = TRUE;\n\n      sp = stack;\n\n      for (i = 0; i < clear_code; ++i)\n        {\n          table[0][i] = 0;\n          table[1][i] = i;\n        }\n      for (; i < (1 << MAX_LZW_BITS); ++i)\n        {\n          table[0][i] = 0;\n          table[1][i] = 0;\n        }\n\n      return 0;\n    }\n  else if (fresh)\n    {\n      fresh = FALSE;\n      do\n        {\n          firstcode = oldcode = GetCode (fd, code_size, FALSE);\n        }\n      while (firstcode == clear_code);\n\n      return firstcode;\n    }\n\n  if (sp > stack)\n    return *--sp;\n\n  while ((code = GetCode (fd, code_size, FALSE)) >= 0)\n    {\n      if (code == clear_code)\n        {\n          for (i = 0; i < clear_code; ++i)\n            {\n              table[0][i] = 0;\n              table[1][i] = i;\n            }\n          for (; i < (1 << MAX_LZW_BITS); ++i)\n            {\n              table[0][i] = 0;\n              table[1][i] = 0;\n            }\n\n          code_size     = set_code_size + 1;\n          max_code_size = 2 * clear_code;\n          max_code      = clear_code + 2;\n          sp            = stack;\n          firstcode     = oldcode = GetCode (fd, code_size, FALSE);\n\n          return firstcode;\n        }\n      else if (code == end_code)\n        {\n          gint   count;\n          guchar buf[260];\n\n          if (ZeroDataBlock)\n            return -2;\n\n          while ((count = GetDataBlock (fd, buf)) > 0)\n            ;\n\n          if (count != 0)\n            g_print (\"GIF: missing EOD in data stream (common occurence)\");\n\n          return -2;\n        }\n\n      incode = code;\n\n      if (code >= max_code)\n        {\n          *sp++ = firstcode;\n          code = oldcode;\n        }\n\n      while (code >= clear_code)\n        {\n          *sp++ = table[1][code];\n          if (code == table[0][code])\n            {\n              g_message (\"Circular table entry.  Corrupt file.\");\n              gimp_quit ();\n            }\n          code = table[0][code];\n        }\n\n      *sp++ = firstcode = table[1][code];\n\n      if ((code = max_code) < (1 << MAX_LZW_BITS))\n        {\n          table[0][code] = oldcode;\n          table[1][code] = firstcode;\n          ++max_code;\n          if ((max_code >= max_code_size) &&\n              (max_code_size < (1 << MAX_LZW_BITS)))\n            {\n              max_code_size *= 2;\n              ++code_size;\n            }\n        }\n\n      oldcode = incode;\n\n      if (sp > stack)\n        return *--sp;\n    }\n\n  return code;\n}\n- GRAYSCALE: #define GRAYSCALE        1 /* <=== plug-ins/common/file-gif-load.c:277:277:GRAYSCALE:0 */ \n- gimp_image_get_height: gint /* <=== gimp_image_get_height */ \ngimp_image_get_height (const GimpImage *image)\n{\n  g_return_val_if_fail (GIMP_IS_IMAGE (image), 0);\n\n  return image->height;\n}\n- gimp_quit: void /* <=== gimp_quit */ \ngimp_quit (void)\n{\n  gimp_close ();\n\n  exit (EXIT_SUCCESS);\n}\n- GIMP_IS_PROGRESS: #define GIMP_IS_PROGRESS(obj)            (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_PROGRESS)) /* <=== app/core/gimpprogress.h:26:26:GIMP_IS_PROGRESS:1 */ \n- gimp_image_get_vectors_iter: GList * /* <=== gimp_image_get_vectors_iter */ \ngimp_image_get_vectors_iter (const GimpImage *image)\n{\n  g_return_val_if_fail (GIMP_IS_IMAGE (image), NULL);\n\n  return gimp_item_stack_get_item_iter (GIMP_ITEM_STACK (image->vectors));\n}\n- gimp_image_flip: void /* <=== gimp_image_flip */ \ngimp_image_flip (GimpImage           *image,\n                 GimpContext         *context,\n                 GimpOrientationType  flip_type,\n                 GimpProgress        *progress)\n{\n  GList   *list;\n  gdouble  axis;\n  gdouble  progress_max;\n  gdouble  progress_current = 1.0;\n\n  g_return_if_fail (GIMP_IS_IMAGE (image));\n  g_return_if_fail (GIMP_IS_CONTEXT (context));\n  g_return_if_fail (progress == NULL || GIMP_IS_PROGRESS (progress));\n\n  gimp_set_busy (image->gimp);\n\n  switch (flip_type)\n    {\n    case GIMP_ORIENTATION_HORIZONTAL:\n      axis = (gdouble) gimp_image_get_width (image) / 2.0;\n      break;\n\n    case GIMP_ORIENTATION_VERTICAL:\n      axis = (gdouble) gimp_image_get_height (image) / 2.0;\n      break;\n\n    default:\n      g_warning (\"%s: unknown flip_type\", G_STRFUNC);\n      return;\n    }\n\n  progress_max = (gimp_container_get_n_children (image->channels) +\n                  gimp_container_get_n_children (image->layers)   +\n                  gimp_container_get_n_children (image->vectors)  +\n                  1 /* selection */);\n\n  gimp_image_undo_group_start (image, GIMP_UNDO_GROUP_IMAGE_FLIP, NULL);\n\n  /*  Flip all channels  */\n  for (list = gimp_image_get_channel_iter (image);\n       list;\n       list = g_list_next (list))\n    {\n      GimpItem *item = list->data;\n\n      gimp_item_flip (item, context, flip_type, axis, TRUE);\n\n      if (progress)\n        gimp_progress_set_value (progress, progress_current++ / progress_max);\n    }\n\n  /*  Flip all vectors  */\n  for (list = gimp_image_get_vectors_iter (image);\n       list;\n       list = g_list_next (list))\n    {\n      GimpItem *item = list->data;\n\n      gimp_item_flip (item, context, flip_type, axis, FALSE);\n\n      if (progress)\n        gimp_progress_set_value (progress, progress_current++ / progress_max);\n    }\n\n  /*  Don't forget the selection mask!  */\n  gimp_item_flip (GIMP_ITEM (gimp_image_get_mask (image)), context,\n                  flip_type, axis, TRUE);\n\n  if (progress)\n    gimp_progress_set_value (progress, progress_current++ / progress_max);\n\n  /*  Flip all layers  */\n  for (list = gimp_image_get_layer_iter (image);\n       list;\n       list = g_list_next (list))\n    {\n      GimpItem *item = list->data;\n\n      gimp_item_flip (item, context, flip_type, axis, FALSE);\n\n      if (progress)\n        gimp_progress_set_value (progress, progress_current++ / progress_max);\n    }\n\n  /*  Flip all Guides  */\n  for (list = gimp_image_get_guides (image);\n       list;\n       list = g_list_next (list))\n    {\n      GimpGuide *guide    = list->data;\n      gint       position = gimp_guide_get_position (guide);\n\n      switch (gimp_guide_get_orientation (guide))\n        {\n        case GIMP_ORIENTATION_HORIZONTAL:\n          if (flip_type == GIMP_ORIENTATION_VERTICAL)\n            gimp_image_move_guide (image, guide,\n                                   gimp_image_get_height (image) - position,\n                                   TRUE);\n          break;\n\n        case GIMP_ORIENTATION_VERTICAL:\n          if (flip_type == GIMP_ORIENTATION_HORIZONTAL)\n            gimp_image_move_guide (image, guide,\n                                   gimp_image_get_width (image) - position,\n                                   TRUE);\n          break;\n\n        default:\n          break;\n        }\n    }\n\n  /*  Flip all sample points  */\n  for (list = gimp_image_get_sample_points (image);\n       list;\n       list = g_list_next (list))\n    {\n      GimpSamplePoint *sample_point = list->data;\n\n      if (flip_type == GIMP_ORIENTATION_VERTICAL)\n        gimp_image_move_sample_point (image, sample_point,\n                                      sample_point->x,\n                                      gimp_image_get_height (image) -\n                                      sample_point->y,\n                                      TRUE);\n\n      if (flip_type == GIMP_ORIENTATION_HORIZONTAL)\n        gimp_image_move_sample_point (image, sample_point,\n                                      gimp_image_get_width (image) -\n                                      sample_point->x,\n                                      sample_point->y,\n                                      TRUE);\n    }\n\n  gimp_image_undo_group_end (image);\n\n  gimp_unset_busy (image->gimp);\n}\n- CM_RED: #define CM_RED           0 /* <=== plug-ins/common/file-gif-load.c:264:264:CM_RED:0 */ \n- ReadColorMap: static gboolean /* <=== ReadColorMap */ \nReadColorMap (FILE     *fd,\n              guchar    buffer[256][3],\n              gint      number,\n              gint      size,\n              gboolean *grey)\n{\n  gint   i;\n  guchar rgb[4];\n\n  *grey = (number > 2);\n\n  for (i = 0; i < number ; i++)\n    {\n      if (!ReadOK (fd, rgb, size))\n        {\n          g_message (_(\"Bad colormap\"));\n          return FALSE;\n        }\n\n      /* Bitmap save the colors in another order! But change only once! */\n\n      buffer[i][0] = rgb[2];\n      buffer[i][1] = rgb[1];\n      buffer[i][2] = rgb[0];\n      *grey = ((*grey) && (rgb[0]==rgb[1]) && (rgb[1]==rgb[2]));\n    }\n\n  return TRUE;\n}\n- BI_RGB: #define BI_RGB          0 /* <=== plug-ins/file-bmp/bmp-read.c:40:40:BI_RGB:0 */ \n- gimp_drawable_detach: void           gimp_drawable_detach                 (GimpDrawable  *drawable); /* <=== gimp_drawable_detach */ \n- ReadOK: #define ReadOK(file,buffer,len) (fread(buffer, len, 1, file) != 0) /* <=== plug-ins/common/file-gif-load.c:274:274:ReadOK:3 */ \n- BI_RLE8: #define BI_RLE8         1 /* <=== plug-ins/file-bmp/bmp-read.c:41:41:BI_RLE8:0 */ \n- ToS: static gint16 /* <=== ToS */ \nToS (const guchar *puffer)\n{\n  return (puffer[0] | puffer[1] << 8);\n}\n- GIMP_IS_IMAGE: #define GIMP_IS_IMAGE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_IMAGE)) /* <=== app/core/gimpimage.h:95:95:GIMP_IS_IMAGE:1 */ \n- gimp_pixel_rgn_init: void      gimp_pixel_rgn_init       (GimpPixelRgn  *pr, /* <=== gimp_pixel_rgn_init */ \n                                     GimpDrawable  *drawable,\n                                     gint           x,\n                                     gint           y,\n                                     gint           width,\n                                     gint           height,\n                                     gint           dirty,\n                                     gint           shadow);\n- gimp_image_get_channel_iter: GList * /* <=== gimp_image_get_channel_iter */ \ngimp_image_get_channel_iter (const GimpImage *image)\n{\n  g_return_val_if_fail (GIMP_IS_IMAGE (image), NULL);\n\n  return gimp_item_stack_get_item_iter (GIMP_ITEM_STACK (image->channels));\n}\n- gimp_image_add_layer: gboolean /* <=== gimp_image_add_layer */ \ngimp_image_add_layer (gint32 image_ID,\n                      gint32 layer_ID,\n                      gint   position)\n{\n  GimpParam *return_vals;\n  gint nreturn_vals;\n  gboolean success = TRUE;\n\n  return_vals = gimp_run_procedure (\"gimp-image-add-layer\",\n                                    &nreturn_vals,\n                                    GIMP_PDB_IMAGE, image_ID,\n                                    GIMP_PDB_LAYER, layer_ID,\n                                    GIMP_PDB_INT32, position,\n                                    GIMP_PDB_END);\n\n  success = return_vals[0].data.d_status == GIMP_PDB_SUCCESS;\n\n  gimp_destroy_params (return_vals, nreturn_vals);\n\n  return success;\n}\n- gimp_image_set_filename: gboolean /* <=== gimp_image_set_filename */ \ngimp_image_set_filename (gint32       image_ID,\n                         const gchar *filename)\n{\n  GimpParam *return_vals;\n  gint nreturn_vals;\n  gboolean success = TRUE;\n\n  return_vals = gimp_run_procedure (\"gimp-image-set-filename\",\n                                    &nreturn_vals,\n                                    GIMP_PDB_IMAGE, image_ID,\n                                    GIMP_PDB_STRING, filename,\n                                    GIMP_PDB_END);\n\n  success = return_vals[0].data.d_status == GIMP_PDB_SUCCESS;\n\n  gimp_destroy_params (return_vals, nreturn_vals);\n\n  return success;\n}\n- gimp_image_new: gint32 /* <=== gimp_image_new */ \ngimp_image_new (gint              width,\n                gint              height,\n                GimpImageBaseType type)\n{\n  GimpParam *return_vals;\n  gint nreturn_vals;\n  gint32 image_ID = -1;\n\n  return_vals = gimp_run_procedure (\"gimp-image-new\",\n                                    &nreturn_vals,\n                                    GIMP_PDB_INT32, width,\n                                    GIMP_PDB_INT32, height,\n                                    GIMP_PDB_INT32, type,\n                                    GIMP_PDB_END);\n\n  if (return_vals[0].data.d_status == GIMP_PDB_SUCCESS)\n    image_ID = return_vals[1].data.d_image;\n\n  gimp_destroy_params (return_vals, nreturn_vals);\n\n  return image_ID;\n}\n- gimp_image_add_layer: gboolean /* <=== gimp_image_add_layer */ \ngimp_image_add_layer (GimpImage *image,\n                      GimpLayer *layer,\n                      GimpLayer *parent,\n                      gint       position,\n                      gboolean   push_undo)\n{\n  GimpLayer     *active_layer;\n  GimpContainer *container;\n  GimpLayer     *floating_sel;\n  gboolean       old_has_alpha;\n\n  g_return_val_if_fail (GIMP_IS_IMAGE (image), FALSE);\n  g_return_val_if_fail (GIMP_IS_LAYER (layer), FALSE);\n  g_return_val_if_fail (! gimp_item_is_attached (GIMP_ITEM (layer)), FALSE);\n  g_return_val_if_fail (gimp_item_get_image (GIMP_ITEM (layer)) == image,\n                        FALSE);\n  g_return_val_if_fail (parent == NULL ||\n                        parent == GIMP_IMAGE_ACTIVE_PARENT ||\n                        GIMP_IS_LAYER (parent), FALSE);\n  g_return_val_if_fail (parent == NULL ||\n                        parent == GIMP_IMAGE_ACTIVE_PARENT ||\n                        gimp_item_is_attached (GIMP_ITEM (parent)), FALSE);\n  g_return_val_if_fail (parent == NULL ||\n                        parent == GIMP_IMAGE_ACTIVE_PARENT ||\n                        gimp_item_get_image (GIMP_ITEM (parent)) == image,\n                        FALSE);\n  g_return_val_if_fail (parent == NULL ||\n                        parent == GIMP_IMAGE_ACTIVE_PARENT ||\n                        gimp_viewable_get_children (GIMP_VIEWABLE (parent)),\n                        FALSE);\n\n  active_layer = gimp_image_get_active_layer (image);\n\n  parent = GIMP_LAYER (gimp_image_get_insert_pos ((GimpItem *) parent,\n                                                  &position,\n                                                  GIMP_ITEM (active_layer),\n                                                  image->layers,\n                                                  &container));\n\n  floating_sel = gimp_image_get_floating_selection (image);\n\n  /*  If there is a floating selection (and this isn't it!),\n   *  make sure the insert position is greater than 0\n   */\n  if (position == 0 && container == image->layers && floating_sel)\n    position = 1;\n\n  old_has_alpha = gimp_image_has_alpha (image);\n\n  if (push_undo)\n    gimp_image_undo_push_layer_add (image, _(\"Add Layer\"),\n                                    layer, active_layer);\n\n  if (parent)\n    gimp_viewable_set_parent (GIMP_VIEWABLE (layer),\n                              GIMP_VIEWABLE (parent));\n\n  gimp_container_insert (container, GIMP_OBJECT (layer), position);\n\n  /*  notify the layers dialog of the currently active layer  */\n  gimp_image_set_active_layer (image, layer);\n\n  /*  If the layer is a floating selection, attach it to the drawable  */\n  if (gimp_layer_is_floating_sel (layer))\n    gimp_drawable_attach_floating_sel (gimp_layer_get_floating_sel_drawable (layer),\n                                       layer);\n\n  if (old_has_alpha != gimp_image_has_alpha (image))\n    image->flush_accum.alpha_changed = TRUE;\n\n  return TRUE;\n}\n- gimp_layer_translate: static void /* <=== gimp_layer_translate */ \ngimp_layer_translate (GimpItem *item,\n                      gint      offset_x,\n                      gint      offset_y,\n                      gboolean  push_undo)\n{\n  GimpLayer *layer = GIMP_LAYER (item);\n\n  if (push_undo)\n    gimp_image_undo_push_item_displace (gimp_item_get_image (item), NULL, item);\n\n  /*  update the old region  */\n  gimp_drawable_update (GIMP_DRAWABLE (layer),\n                        0, 0,\n                        gimp_item_get_width  (item),\n                        gimp_item_get_height (item));\n\n  /*  invalidate the selection boundary because of a layer modification  */\n  gimp_drawable_invalidate_boundary (GIMP_DRAWABLE (layer));\n\n  GIMP_ITEM_CLASS (parent_class)->translate (item, offset_x, offset_y,\n                                             push_undo);\n\n  /*  update the new region  */\n  gimp_drawable_update (GIMP_DRAWABLE (layer),\n                        0, 0,\n                        gimp_item_get_width  (item),\n                        gimp_item_get_height (item));\n\n  if (layer->mask)\n    {\n      gint off_x, off_y;\n\n      gimp_item_get_offset (item, &off_x, &off_y);\n      gimp_item_set_offset (GIMP_ITEM (layer->mask), off_x, off_y);\n\n      gimp_viewable_invalidate_preview (GIMP_VIEWABLE (layer->mask));\n    }\n}\n- gimp_progress_set_text_printf: gboolean /* <=== gimp_progress_set_text_printf */ \ngimp_progress_set_text_printf (const gchar *format,\n                               ...)\n{\n  gchar    *text;\n  gboolean  retval;\n  va_list   args;\n\n  g_return_val_if_fail (format != NULL, FALSE);\n\n  va_start (args, format);\n  text = g_strdup_vprintf (format, args);\n  va_end (args);\n\n  retval = gimp_progress_set_text (text);\n\n  g_free (text);\n\n  return retval;\n}\n- gimp_image_flip: gboolean /* <=== gimp_image_flip */ \ngimp_image_flip (gint32              image_ID,\n                 GimpOrientationType flip_type)\n{\n  GimpParam *return_vals;\n  gint nreturn_vals;\n  gboolean success = TRUE;\n\n  return_vals = gimp_run_procedure (\"gimp-image-flip\",\n                                    &nreturn_vals,\n                                    GIMP_PDB_IMAGE, image_ID,\n                                    GIMP_PDB_INT32, flip_type,\n                                    GIMP_PDB_END);\n\n  success = return_vals[0].data.d_status == GIMP_PDB_SUCCESS;\n\n  gimp_destroy_params (return_vals, nreturn_vals);\n\n  return success;\n}\n- GIMP_IS_CONTEXT: #define GIMP_IS_CONTEXT(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_CONTEXT)) /* <=== app/core/gimpcontext.h:31:31:GIMP_IS_CONTEXT:1 */ \n- ReadImage: static gint32 /* <=== ReadImage */ \nReadImage (FILE                  *fd,\n           gint                   width,\n           gint                   height,\n           guchar                 cmap[256][3],\n           gint                   ncols,\n           gint                   bpp,\n           gint                   compression,\n           gint                   rowbytes,\n           gboolean               grey,\n           const Bitmap_Channel  *masks,\n           GError               **error)\n{\n  guchar             v, n;\n  GimpPixelRgn       pixel_rgn;\n  gint               xpos = 0;\n  gint               ypos = 0;\n  gint32             image;\n  gint32             layer;\n  GimpDrawable      *drawable;\n  guchar            *dest, *temp, *buffer;\n  guchar             gimp_cmap[768];\n  gushort            rgb;\n  glong              rowstride, channels;\n  gint               i, i_max, j, cur_progress, max_progress;\n  gint               total_bytes_read;\n  GimpImageBaseType  base_type;\n  GimpImageType      image_type;\n  guint32            px32;\n\n  if (! (compression == BI_RGB ||\n      (bpp == 8 && compression == BI_RLE8) ||\n      (bpp == 4 && compression == BI_RLE4) ||\n      (bpp == 16 && compression == BI_BITFIELDS) ||\n      (bpp == 32 && compression == BI_BITFIELDS)))\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   \"%s\",\n                   _(\"Unrecognized or invalid BMP compression format.\"));\n      return -1;\n    }\n\n  /* Make a new image in GIMP */\n\n  switch (bpp)\n    {\n    case 32:\n    case 24:\n    case 16:\n      base_type = GIMP_RGB;\n      if (masks[3].mask != 0)\n      {\n         image_type = GIMP_RGBA_IMAGE;\n         channels = 4;\n      }\n      else\n      {\n         image_type = GIMP_RGB_IMAGE;\n         channels = 3;\n      }\n      break;\n\n    case 8:\n    case 4:\n    case 1:\n      if (grey)\n        {\n          base_type = GIMP_GRAY;\n          image_type = GIMP_GRAY_IMAGE;\n        }\n      else\n        {\n          base_type = GIMP_INDEXED;\n          image_type = GIMP_INDEXED_IMAGE;\n        }\n\n      channels = 1;\n      break;\n\n    default:\n      g_message (_(\"Unsupported or invalid bitdepth.\"));\n      return -1;\n    }\n\n  if ((width < 0) || (width > GIMP_MAX_IMAGE_SIZE))\n    {\n      g_message (_(\"Unsupported or invalid image width: %d\"), width);\n      return -1;\n    }\n\n  if ((height < 0) || (height > GIMP_MAX_IMAGE_SIZE))\n    {\n      g_message (_(\"Unsupported or invalid image height: %d\"), height);\n      return -1;\n    }\n\n  image = gimp_image_new (width, height, base_type);\n  layer = gimp_layer_new (image, _(\"Background\"),\n                          width, height,\n                          image_type, 100, GIMP_NORMAL_MODE);\n\n  gimp_image_set_filename (image, filename);\n\n  gimp_image_add_layer (image, layer, 0);\n  drawable = gimp_drawable_get (layer);\n\n  /* use g_malloc0 to initialize the dest buffer so that unspecified\n     pixels in RLE bitmaps show up as the zeroth element in the palette.\n  */\n  dest      = g_malloc0 (drawable->width * drawable->height * channels);\n  buffer    = g_malloc (rowbytes);\n  rowstride = drawable->width * channels;\n\n  ypos = height - 1;  /* Bitmaps begin in the lower left corner */\n  cur_progress = 0;\n  max_progress = height;\n\n  switch (bpp)\n    {\n    case 32:\n      {\n        while (ReadOK (fd, buffer, rowbytes))\n          {\n            temp = dest + (ypos * rowstride);\n            for (xpos= 0; xpos < width; ++xpos)\n              {\n                px32 = ToL(&buffer[xpos*4]);\n                *(temp++)= (guchar)((px32 & masks[0].mask) >> masks[0].shiftin);\n                *(temp++)= (guchar)((px32 & masks[1].mask) >> masks[1].shiftin);\n                *(temp++)= (guchar)((px32 & masks[2].mask) >> masks[2].shiftin);\n                if (channels > 3)\n                  *(temp++)= (guchar)((px32 & masks[3].mask) >> masks[3].shiftin);\n              }\n            if (ypos == 0)\n              break;\n            --ypos; /* next line */\n            cur_progress++;\n            if ((cur_progress % 5) == 0)\n              gimp_progress_update ((gdouble) cur_progress /\n                                    (gdouble) max_progress);\n          }\n\n\tif (channels == 4)\n\t  {\n\t    gboolean  has_alpha = FALSE;\n\n\t    /* at least one pixel should have nonzero alpha */\n\t    for (ypos = 0; ypos < height; ypos++)\n\t      {\n\t\ttemp = dest + (ypos * rowstride);\n\t\tfor (xpos = 0; xpos < width; xpos++)\n\t\t  {\n\t\t    if (temp[3])\n\t\t      {\n\t\t\thas_alpha = TRUE;\n\t\t\tbreak;\n\t\t      }\n\t\t    temp += 4;\n\t\t  }\n\t\tif (has_alpha)\n\t\t  break;\n\t      }\n\n\t    /* workaround unwanted behaviour when all alpha pixels are zero */\n\t    if (!has_alpha)\n\t      {\n\t\tfor (ypos = 0; ypos < height; ypos++)\n\t\t  {\n\t\t    temp = dest + (ypos * rowstride);\n\t\t    for (xpos = 0; xpos < width; xpos++)\n\t\t      {\n\t\t\ttemp[3] = 255;\n\t\t\ttemp += 4;\n\t\t      }\n\t\t  }\n\t      }\n\t  }\n      }\n      break;\n\n    case 24:\n      {\n        while (ReadOK (fd, buffer, rowbytes))\n          {\n            temp = dest + (ypos * rowstride);\n            for (xpos= 0; xpos < width; ++xpos)\n              {\n                *(temp++)= buffer[xpos * 3 + 2];\n                *(temp++)= buffer[xpos * 3 + 1];\n                *(temp++)= buffer[xpos * 3];\n              }\n            if (ypos == 0)\n              break;\n            --ypos; /* next line */\n            cur_progress++;\n            if ((cur_progress % 5) == 0)\n              gimp_progress_update ((gdouble) cur_progress /\n                                    (gdouble) max_progress);\n          }\n      }\n      break;\n\n    case 16:\n      {\n        while (ReadOK (fd, buffer, rowbytes))\n          {\n            temp = dest + (ypos * rowstride);\n            for (xpos= 0; xpos < width; ++xpos)\n              {\n                rgb= ToS(&buffer[xpos * 2]);\n                *(temp++) = (guchar)(((rgb & masks[0].mask) >> masks[0].shiftin) * 255.0 / masks[0].max_value + 0.5);\n                *(temp++) = (guchar)(((rgb & masks[1].mask) >> masks[1].shiftin) * 255.0 / masks[1].max_value + 0.5);\n                *(temp++) = (guchar)(((rgb & masks[2].mask) >> masks[2].shiftin) * 255.0 / masks[2].max_value + 0.5);\n                if (channels > 3)\n                  *(temp++) = (guchar)(((rgb & masks[3].mask) >> masks[3].shiftin) * 255.0 / masks[3].max_value + 0.5);\n              }\n            if (ypos == 0)\n              break;\n            --ypos; /* next line */\n            cur_progress++;\n            if ((cur_progress % 5) == 0)\n              gimp_progress_update ((gdouble) cur_progress /\n                                    (gdouble) max_progress);\n          }\n      }\n      break;\n\n    case 8:\n    case 4:\n    case 1:\n      {\n        if (compression == 0)\n          /* no compression */\n          {\n            while (ReadOK (fd, &v, 1))\n              {\n                for (i = 1; (i <= (8 / bpp)) && (xpos < width); i++, xpos++)\n                  {\n                    temp = dest + (ypos * rowstride) + (xpos * channels);\n                    *temp=( v & ( ((1<<bpp)-1) << (8-(i*bpp)) ) ) >> (8-(i*bpp));\n                    if (grey)\n                      *temp = cmap[*temp][0];\n                  }\n                if (xpos == width)\n                  {\n                    fread(buffer, rowbytes - 1 - (width * bpp - 1) / 8, 1, fd);\n                    if (ypos == 0)\n                      break;\n                    ypos--;\n                    xpos = 0;\n\n                    cur_progress++;\n                    if ((cur_progress % 5) == 0)\n                      gimp_progress_update ((gdouble) cur_progress /\n                                            (gdouble) max_progress);\n                  }\n                if (ypos < 0)\n                  break;\n              }\n            break;\n          }\n        else\n          {\n            /* compressed image (either RLE8 or RLE4) */\n            while (ypos >= 0 && xpos <= width)\n              {\n                if (!ReadOK (fd, buffer, 2))\n                  {\n                    g_message (_(\"The bitmap ends unexpectedly.\"));\n                    break;\n                  }\n\n                if ((guchar) buffer[0] != 0)\n                  /* Count + Color - record */\n                  {\n                    /* encoded mode run -\n                         buffer[0] == run_length\n                         buffer[1] == pixel data\n                    */\n                    for (j = 0;\n                         ((guchar) j < (guchar) buffer[0]) && (xpos < width);)\n                      {\n#ifdef DEBUG2\n                        printf(\"%u %u | \",xpos,width);\n#endif\n                        for (i = 1;\n                             ((i <= (8 / bpp)) &&\n                              (xpos < width) &&\n                              ((guchar) j < (unsigned char) buffer[0]));\n                             i++, xpos++, j++)\n                          {\n                            temp = dest + (ypos * rowstride) + (xpos * channels);\n                            *temp = (buffer[1] &\n                                     (((1<<bpp)-1) << (8 - (i * bpp)))) >> (8 - (i * bpp));\n                            if (grey)\n                              *temp = cmap[*temp][0];\n                          }\n                      }\n                  }\n                if (((guchar) buffer[0] == 0) && ((guchar) buffer[1] > 2))\n                  /* uncompressed record */\n                  {\n                    n = buffer[1];\n                    total_bytes_read = 0;\n                    for (j = 0; j < n; j += (8 / bpp))\n                      {\n                        /* read the next byte in the record */\n                        if (!ReadOK (fd, &v, 1))\n                          {\n                            g_message (_(\"The bitmap ends unexpectedly.\"));\n                            break;\n                          }\n                        total_bytes_read++;\n\n                        /* read all pixels from that byte */\n                        i_max = 8 / bpp;\n                        if (n - j < i_max)\n                          {\n                            i_max = n - j;\n                          }\n\n                        i = 1;\n                        while ((i <= i_max) && (xpos < width))\n                          {\n                            temp =\n                              dest + (ypos * rowstride) + (xpos * channels);\n                            *temp = (v >> (8-(i*bpp))) & ((1<<bpp)-1);\n                            if (grey)\n                              *temp = cmap[*temp][0];\n                            i++;\n                            xpos++;\n                          }\n                      }\n\n                    /* absolute mode runs are padded to 16-bit alignment */\n                    if (total_bytes_read % 2)\n                      fread(&v, 1, 1, fd);\n                  }\n                if (((guchar) buffer[0] == 0) && ((guchar) buffer[1]==0))\n                  /* Line end */\n                  {\n                    ypos--;\n                    xpos = 0;\n\n                    cur_progress++;\n                    if ((cur_progress % 5) == 0)\n                      gimp_progress_update ((gdouble) cur_progress /\n                                            (gdouble)  max_progress);\n                  }\n                if (((guchar) buffer[0]==0) && ((guchar) buffer[1]==1))\n                  /* Bitmap end */\n                  {\n                    break;\n                  }\n                if (((guchar) buffer[0]==0) && ((guchar) buffer[1]==2))\n                  /* Deltarecord */\n                  {\n                    if (!ReadOK (fd, buffer, 2))\n                      {\n                        g_message (_(\"The bitmap ends unexpectedly.\"));\n                        break;\n                      }\n                    xpos += (guchar) buffer[0];\n                    ypos -= (guchar) buffer[1];\n                  }\n              }\n            break;\n          }\n      }\n      break;\n\n    default:\n      g_assert_not_reached ();\n      break;\n    }\n\n  fclose (fd);\n  if (bpp <= 8)\n    for (i = 0, j = 0; i < ncols; i++)\n      {\n        gimp_cmap[j++] = cmap[i][0];\n        gimp_cmap[j++] = cmap[i][1];\n        gimp_cmap[j++] = cmap[i][2];\n      }\n\n  gimp_progress_update (1);\n\n  gimp_pixel_rgn_init (&pixel_rgn, drawable,\n                       0, 0, drawable->width, drawable->height, TRUE, FALSE);\n  gimp_pixel_rgn_set_rect (&pixel_rgn, dest,\n                           0, 0, drawable->width, drawable->height);\n\n  if ((!grey) && (bpp<= 8))\n    gimp_image_set_colormap (image, gimp_cmap, ncols);\n\n  gimp_drawable_flush (drawable);\n  gimp_drawable_detach (drawable);\n  g_free (dest);\n\n  return image;\n}\n- gimp_image_set_resolution: gboolean /* <=== gimp_image_set_resolution */ \ngimp_image_set_resolution (gint32  image_ID,\n                           gdouble xresolution,\n                           gdouble yresolution)\n{\n  GimpParam *return_vals;\n  gint nreturn_vals;\n  gboolean success = TRUE;\n\n  return_vals = gimp_run_procedure (\"gimp-image-set-resolution\",\n                                    &nreturn_vals,\n                                    GIMP_PDB_IMAGE, image_ID,\n                                    GIMP_PDB_FLOAT, xresolution,\n                                    GIMP_PDB_FLOAT, yresolution,\n                                    GIMP_PDB_END);\n\n  success = return_vals[0].data.d_status == GIMP_PDB_SUCCESS;\n\n  gimp_destroy_params (return_vals, nreturn_vals);\n\n  return success;\n}\n- gimp_image_set_colormap: gboolean   gimp_image_set_colormap        (gint32          image_ID, /* <=== gimp_image_set_colormap */ \n                                           const guchar   *colormap,\n                                           gint            num_colors);\n- CM_BLUE: #define CM_BLUE          2 /* <=== plug-ins/common/file-gif-load.c:266:266:CM_BLUE:0 */ \n- gimp_image_get_mask: GimpChannel * /* <=== gimp_image_get_mask */ \ngimp_image_get_mask (const GimpImage *image)\n{\n  g_return_val_if_fail (GIMP_IS_IMAGE (image), NULL);\n\n  return image->selection_mask;\n}\n- ReadOK: #define ReadOK(file,buffer,len)  (fread(buffer, len, 1, file) != 0) /* <=== plug-ins/file-bmp/bmp.h:30:30:ReadOK:3 */ \n- GIMP_ITEM: #define GIMP_ITEM(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_ITEM, GimpItem)) /* <=== app/core/gimpitem.h:26:26:GIMP_ITEM:1 */ \n- gimp_image_new: GimpImage * /* <=== gimp_image_new */ \ngimp_image_new (Gimp              *gimp,\n                gint               width,\n                gint               height,\n                GimpImageBaseType  base_type)\n{\n  g_return_val_if_fail (GIMP_IS_GIMP (gimp), NULL);\n\n  return g_object_new (GIMP_TYPE_IMAGE,\n                       \"gimp\",      gimp,\n                       \"width\",     width,\n                       \"height\",    height,\n                       \"base-type\", base_type,\n                       NULL);\n}\n- ToL: static gint32 /* <=== ToL */ \nToL (const guchar *puffer)\n{\n  return (puffer[0] | puffer[1] << 8 | puffer[2] << 16 | puffer[3] << 24);\n}\n- gimp_image_get_layer_iter: GList * /* <=== gimp_image_get_layer_iter */ \ngimp_image_get_layer_iter (const GimpImage *image)\n{\n  g_return_val_if_fail (GIMP_IS_IMAGE (image), NULL);\n\n  return gimp_item_stack_get_item_iter (GIMP_ITEM_STACK (image->layers));\n}\n\nImports:\n- #include \"bmp.h\"\n- #include \"config.h\"\n- #include \"libgimp/stdplugins-intl.h\"\n- #include <errno.h>\n- #include <glib/gstdio.h>\n- #include <gdk-pixbuf/gdk-pixbuf.h>\n- #include <libgimp/gimppixbuf.h>\n- #include <string.h>\n- #include <libgimp/gimp.h>",
    "commit_msg": "Harden the BMP plugin against integer overflows.\n\nIssues discovered by Stefan Cornelius, Secunia Research, advisory SA37232\nand CVE identifier CVE-2009-1570. Fixes bug #600484.",
    "cve_desc": "Integer overflow in the ReadImage function in plug-ins/file-bmp/bmp-read.c in GIMP 2.6.7 might allow remote attackers to execute arbitrary code via a BMP file with crafted width and height values that trigger a heap-based buffer overflow.",
    "year": 2009,
    "filename": "bmp-read.c",
    "commit_url": "\"https://github.com/GNOME/gimp/commit/e3afc99b2fa7aeddf0dba4778663160a5bc682d3\""
  },
  {
    "repository": "samba-team/samba",
    "cve_id": "CVE-2009-1888",
    "cwe_list": [
      "CWE-264"
    ],
    "commit_hash": "d6c28913f3109d1327a3d1369b6eafd3874b2dca",
    "short_hash": "d6c28913",
    "vulnerableMethods_before": [
      {
        "filename": "source/smbd/posix_acls.c",
        "method_name": "acl_group_override",
        "raw_code": "static bool acl_group_override(connection_struct *conn, /* <=== acl_group_override */ \n\t\t\t\tgid_t prim_gid,\n\t\t\t\tconst char *fname)\n{\n\tSMB_STRUCT_STAT sbuf;\n\n\tif ((errno != EPERM) && (errno != EACCES)) {\n\t\treturn false;\n\t}\n\n\t/* file primary group == user primary or supplementary group */\n\tif (lp_acl_group_control(SNUM(conn)) &&\n\t\t\tcurrent_user_in_group(prim_gid)) {\n\t\treturn true;\n\t}\n\n\t/* user has writeable permission */\n\tif (lp_dos_filemode(SNUM(conn)) &&\n\t\t\tcan_write_to_file(conn, fname, &sbuf)) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
        "start_line": 2386
      },
      {
        "filename": "source/smbd/posix_acls.c",
        "method_name": "set_canon_ace_list",
        "raw_code": "static bool set_canon_ace_list(files_struct *fsp, canon_ace *the_ace, bool default_ace, gid_t prim_gid, bool *pacl_set_support) /* <=== set_canon_ace_list */ \n{\n\tconnection_struct *conn = fsp->conn;\n\tbool ret = False;\n\tSMB_ACL_T the_acl = SMB_VFS_SYS_ACL_INIT(conn, (int)count_canon_ace_list(the_ace) + 1);\n\tcanon_ace *p_ace;\n\tint i;\n\tSMB_ACL_ENTRY_T mask_entry;\n\tbool got_mask_entry = False;\n\tSMB_ACL_PERMSET_T mask_permset;\n\tSMB_ACL_TYPE_T the_acl_type = (default_ace ? SMB_ACL_TYPE_DEFAULT : SMB_ACL_TYPE_ACCESS);\n\tbool needs_mask = False;\n\tmode_t mask_perms = 0;\n\n#if defined(POSIX_ACL_NEEDS_MASK)\n\t/* HP-UX always wants to have a mask (called \"class\" there). */\n\tneeds_mask = True;\n#endif\n\n\tif (the_acl == NULL) {\n\n\t\tif (!no_acl_syscall_error(errno)) {\n\t\t\t/*\n\t\t\t * Only print this error message if we have some kind of ACL\n\t\t\t * support that's not working. Otherwise we would always get this.\n\t\t\t */\n\t\t\tDEBUG(0,(\"set_canon_ace_list: Unable to init %s ACL. (%s)\\n\",\n\t\t\t\tdefault_ace ? \"default\" : \"file\", strerror(errno) ));\n\t\t}\n\t\t*pacl_set_support = False;\n\t\treturn False;\n\t}\n\n\tif( DEBUGLVL( 10 )) {\n\t\tdbgtext(\"set_canon_ace_list: setting ACL:\\n\");\n\t\tfor (i = 0, p_ace = the_ace; p_ace; p_ace = p_ace->next, i++ ) {\n\t\t\tprint_canon_ace( p_ace, i);\n\t\t}\n\t}\n\n\tfor (i = 0, p_ace = the_ace; p_ace; p_ace = p_ace->next, i++ ) {\n\t\tSMB_ACL_ENTRY_T the_entry;\n\t\tSMB_ACL_PERMSET_T the_permset;\n\n\t\t/*\n\t\t * ACLs only \"need\" an ACL_MASK entry if there are any named user or\n\t\t * named group entries. But if there is an ACL_MASK entry, it applies\n\t\t * to ACL_USER, ACL_GROUP, and ACL_GROUP_OBJ entries. Set the mask\n\t\t * so that it doesn't deny (i.e., mask off) any permissions.\n\t\t */\n\n\t\tif (p_ace->type == SMB_ACL_USER || p_ace->type == SMB_ACL_GROUP) {\n\t\t\tneeds_mask = True;\n\t\t\tmask_perms |= p_ace->perms;\n\t\t} else if (p_ace->type == SMB_ACL_GROUP_OBJ) {\n\t\t\tmask_perms |= p_ace->perms;\n\t\t}\n\n\t\t/*\n\t\t * Get the entry for this ACE.\n\t\t */\n\n\t\tif (SMB_VFS_SYS_ACL_CREATE_ENTRY(conn, &the_acl, &the_entry) == -1) {\n\t\t\tDEBUG(0,(\"set_canon_ace_list: Failed to create entry %d. (%s)\\n\",\n\t\t\t\ti, strerror(errno) ));\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (p_ace->type == SMB_ACL_MASK) {\n\t\t\tmask_entry = the_entry;\n\t\t\tgot_mask_entry = True;\n\t\t}\n\n\t\t/*\n\t\t * Ok - we now know the ACL calls should be working, don't\n\t\t * allow fallback to chmod.\n\t\t */\n\n\t\t*pacl_set_support = True;\n\n\t\t/*\n\t\t * Initialise the entry from the canon_ace.\n\t\t */\n\n\t\t/*\n\t\t * First tell the entry what type of ACE this is.\n\t\t */\n\n\t\tif (SMB_VFS_SYS_ACL_SET_TAG_TYPE(conn, the_entry, p_ace->type) == -1) {\n\t\t\tDEBUG(0,(\"set_canon_ace_list: Failed to set tag type on entry %d. (%s)\\n\",\n\t\t\t\ti, strerror(errno) ));\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/*\n\t\t * Only set the qualifier (user or group id) if the entry is a user\n\t\t * or group id ACE.\n\t\t */\n\n\t\tif ((p_ace->type == SMB_ACL_USER) || (p_ace->type == SMB_ACL_GROUP)) {\n\t\t\tif (SMB_VFS_SYS_ACL_SET_QUALIFIER(conn, the_entry,(void *)&p_ace->unix_ug.uid) == -1) {\n\t\t\t\tDEBUG(0,(\"set_canon_ace_list: Failed to set qualifier on entry %d. (%s)\\n\",\n\t\t\t\t\ti, strerror(errno) ));\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Convert the mode_t perms in the canon_ace to a POSIX permset.\n\t\t */\n\n\t\tif (SMB_VFS_SYS_ACL_GET_PERMSET(conn, the_entry, &the_permset) == -1) {\n\t\t\tDEBUG(0,(\"set_canon_ace_list: Failed to get permset on entry %d. (%s)\\n\",\n\t\t\t\ti, strerror(errno) ));\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (map_acl_perms_to_permset(conn, p_ace->perms, &the_permset) == -1) {\n\t\t\tDEBUG(0,(\"set_canon_ace_list: Failed to create permset for mode (%u) on entry %d. (%s)\\n\",\n\t\t\t\t(unsigned int)p_ace->perms, i, strerror(errno) ));\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/*\n\t\t * ..and apply them to the entry.\n\t\t */\n\n\t\tif (SMB_VFS_SYS_ACL_SET_PERMSET(conn, the_entry, the_permset) == -1) {\n\t\t\tDEBUG(0,(\"set_canon_ace_list: Failed to add permset on entry %d. (%s)\\n\",\n\t\t\t\ti, strerror(errno) ));\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif( DEBUGLVL( 10 ))\n\t\t\tprint_canon_ace( p_ace, i);\n\n\t}\n\n\tif (needs_mask && !got_mask_entry) {\n\t\tif (SMB_VFS_SYS_ACL_CREATE_ENTRY(conn, &the_acl, &mask_entry) == -1) {\n\t\t\tDEBUG(0,(\"set_canon_ace_list: Failed to create mask entry. (%s)\\n\", strerror(errno) ));\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (SMB_VFS_SYS_ACL_SET_TAG_TYPE(conn, mask_entry, SMB_ACL_MASK) == -1) {\n\t\t\tDEBUG(0,(\"set_canon_ace_list: Failed to set tag type on mask entry. (%s)\\n\",strerror(errno) ));\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (SMB_VFS_SYS_ACL_GET_PERMSET(conn, mask_entry, &mask_permset) == -1) {\n\t\t\tDEBUG(0,(\"set_canon_ace_list: Failed to get mask permset. (%s)\\n\", strerror(errno) ));\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (map_acl_perms_to_permset(conn, S_IRUSR|S_IWUSR|S_IXUSR, &mask_permset) == -1) {\n\t\t\tDEBUG(0,(\"set_canon_ace_list: Failed to create mask permset. (%s)\\n\", strerror(errno) ));\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (SMB_VFS_SYS_ACL_SET_PERMSET(conn, mask_entry, mask_permset) == -1) {\n\t\t\tDEBUG(0,(\"set_canon_ace_list: Failed to add mask permset. (%s)\\n\", strerror(errno) ));\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t/*\n\t * Finally apply it to the file or directory.\n\t */\n\n\tif(default_ace || fsp->is_directory || fsp->fh->fd == -1) {\n\t\tif (SMB_VFS_SYS_ACL_SET_FILE(conn, fsp->fsp_name, the_acl_type, the_acl) == -1) {\n\t\t\t/*\n\t\t\t * Some systems allow all the above calls and only fail with no ACL support\n\t\t\t * when attempting to apply the acl. HPUX with HFS is an example of this. JRA.\n\t\t\t */\n\t\t\tif (no_acl_syscall_error(errno)) {\n\t\t\t\t*pacl_set_support = False;\n\t\t\t}\n\n\t\t\tif (acl_group_override(conn, prim_gid, fsp->fsp_name)) {\n\t\t\t\tint sret;\n\n\t\t\t\tDEBUG(5,(\"set_canon_ace_list: acl group control on and current user in file %s primary group.\\n\",\n\t\t\t\t\tfsp->fsp_name ));\n\n\t\t\t\tbecome_root();\n\t\t\t\tsret = SMB_VFS_SYS_ACL_SET_FILE(conn, fsp->fsp_name, the_acl_type, the_acl);\n\t\t\t\tunbecome_root();\n\t\t\t\tif (sret == 0) {\n\t\t\t\t\tret = True;\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ret == False) {\n\t\t\t\tDEBUG(2,(\"set_canon_ace_list: sys_acl_set_file type %s failed for file %s (%s).\\n\",\n\t\t\t\t\t\tthe_acl_type == SMB_ACL_TYPE_DEFAULT ? \"directory default\" : \"file\",\n\t\t\t\t\t\tfsp->fsp_name, strerror(errno) ));\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (SMB_VFS_SYS_ACL_SET_FD(fsp, the_acl) == -1) {\n\t\t\t/*\n\t\t\t * Some systems allow all the above calls and only fail with no ACL support\n\t\t\t * when attempting to apply the acl. HPUX with HFS is an example of this. JRA.\n\t\t\t */\n\t\t\tif (no_acl_syscall_error(errno)) {\n\t\t\t\t*pacl_set_support = False;\n\t\t\t}\n\n\t\t\tif (acl_group_override(conn, prim_gid, fsp->fsp_name)) {\n\t\t\t\tint sret;\n\n\t\t\t\tDEBUG(5,(\"set_canon_ace_list: acl group control on and current user in file %s primary group.\\n\",\n\t\t\t\t\tfsp->fsp_name ));\n\n\t\t\t\tbecome_root();\n\t\t\t\tsret = SMB_VFS_SYS_ACL_SET_FD(fsp, the_acl);\n\t\t\t\tunbecome_root();\n\t\t\t\tif (sret == 0) {\n\t\t\t\t\tret = True;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ret == False) {\n\t\t\t\tDEBUG(2,(\"set_canon_ace_list: sys_acl_set_file failed for file %s (%s).\\n\",\n\t\t\t\t\t\tfsp->fsp_name, strerror(errno) ));\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = True;\n\n  fail:\n\n\tif (the_acl != NULL) {\n\t\tSMB_VFS_SYS_ACL_FREE_ACL(conn, the_acl);\n\t}\n\n\treturn ret;\n}",
        "start_line": 2415
      },
      {
        "filename": "source/smbd/posix_acls.c",
        "method_name": "set_nt_acl",
        "raw_code": "NTSTATUS set_nt_acl(files_struct *fsp, uint32 security_info_sent, SEC_DESC *psd) /* <=== set_nt_acl */ \n{\n\tconnection_struct *conn = fsp->conn;\n\tuid_t user = (uid_t)-1;\n\tgid_t grp = (gid_t)-1;\n\tSMB_STRUCT_STAT sbuf;\n\tDOM_SID file_owner_sid;\n\tDOM_SID file_grp_sid;\n\tcanon_ace *file_ace_list = NULL;\n\tcanon_ace *dir_ace_list = NULL;\n\tbool acl_perms = False;\n\tmode_t orig_mode = (mode_t)0;\n\tNTSTATUS status;\n\tbool set_acl_as_root = false;\n\tbool acl_set_support = false;\n\tbool ret = false;\n\n\tDEBUG(10,(\"set_nt_acl: called for file %s\\n\", fsp->fsp_name ));\n\n\tif (!CAN_WRITE(conn)) {\n\t\tDEBUG(10,(\"set acl rejected on read-only share\\n\"));\n\t\treturn NT_STATUS_MEDIA_WRITE_PROTECTED;\n\t}\n\n\t/*\n\t * Get the current state of the file.\n\t */\n\n\tif(fsp->is_directory || fsp->fh->fd == -1) {\n\t\tif(SMB_VFS_STAT(fsp->conn,fsp->fsp_name, &sbuf) != 0)\n\t\t\treturn map_nt_error_from_unix(errno);\n\t} else {\n\t\tif(SMB_VFS_FSTAT(fsp, &sbuf) != 0)\n\t\t\treturn map_nt_error_from_unix(errno);\n\t}\n\n\t/* Save the original element we check against. */\n\torig_mode = sbuf.st_mode;\n\n\t/*\n\t * Unpack the user/group/world id's.\n\t */\n\n\tstatus = unpack_nt_owners( SNUM(conn), &user, &grp, security_info_sent, psd);\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\treturn status;\n\t}\n\n\t/*\n\t * Do we need to chown ? If so this must be done first as the incoming\n\t * CREATOR_OWNER acl will be relative to the *new* owner, not the old.\n\t * Noticed by Simo.\n\t */\n\n\tif (((user != (uid_t)-1) && (sbuf.st_uid != user)) || (( grp != (gid_t)-1) && (sbuf.st_gid != grp))) {\n\n\t\tDEBUG(3,(\"set_nt_acl: chown %s. uid = %u, gid = %u.\\n\",\n\t\t\t\tfsp->fsp_name, (unsigned int)user, (unsigned int)grp ));\n\n\t\tif(try_chown( fsp->conn, fsp->fsp_name, user, grp) == -1) {\n\t\t\tDEBUG(3,(\"set_nt_acl: chown %s, %u, %u failed. Error = %s.\\n\",\n\t\t\t\tfsp->fsp_name, (unsigned int)user, (unsigned int)grp, strerror(errno) ));\n\t\t\tif (errno == EPERM) {\n\t\t\t\treturn NT_STATUS_INVALID_OWNER;\n\t\t\t}\n\t\t\treturn map_nt_error_from_unix(errno);\n\t\t}\n\n\t\t/*\n\t\t * Recheck the current state of the file, which may have changed.\n\t\t * (suid/sgid bits, for instance)\n\t\t */\n\n\t\tif(fsp->is_directory) {\n\t\t\tif(SMB_VFS_STAT(fsp->conn, fsp->fsp_name, &sbuf) != 0) {\n\t\t\t\treturn map_nt_error_from_unix(errno);\n\t\t\t}\n\t\t} else {\n\n\t\t\tint sret;\n\n\t\t\tif(fsp->fh->fd == -1)\n\t\t\t\tsret = SMB_VFS_STAT(fsp->conn, fsp->fsp_name, &sbuf);\n\t\t\telse\n\t\t\t\tsret = SMB_VFS_FSTAT(fsp, &sbuf);\n\n\t\t\tif(sret != 0)\n\t\t\t\treturn map_nt_error_from_unix(errno);\n\t\t}\n\n\t\t/* Save the original element we check against. */\n\t\torig_mode = sbuf.st_mode;\n\n\t\t/* If we successfully chowned, we know we must\n \t\t * be able to set the acl, so do it as root.\n \t\t */\n\t\tset_acl_as_root = true;\n\t}\n\n\tcreate_file_sids(&sbuf, &file_owner_sid, &file_grp_sid);\n\n\tacl_perms = unpack_canon_ace( fsp, &sbuf, &file_owner_sid, &file_grp_sid,\n\t\t\t\t\t&file_ace_list, &dir_ace_list, security_info_sent, psd);\n\n\t/* Ignore W2K traverse DACL set. */\n\tif (!file_ace_list && !dir_ace_list) {\n\t\treturn NT_STATUS_OK;\n\t}\n\n\tif (!acl_perms) {\n\t\tDEBUG(3,(\"set_nt_acl: cannot set permissions\\n\"));\n\t\tfree_canon_ace_list(file_ace_list);\n\t\tfree_canon_ace_list(dir_ace_list);\n\t\treturn NT_STATUS_ACCESS_DENIED;\n\t}\n\n\t/*\n\t * Only change security if we got a DACL.\n\t */\n\n\tif(!(security_info_sent & DACL_SECURITY_INFORMATION) || (psd->dacl == NULL)) {\n\t\tfree_canon_ace_list(file_ace_list);\n\t\tfree_canon_ace_list(dir_ace_list);\n\t\treturn NT_STATUS_OK;\n\t}\n\n\t/*\n\t * Try using the POSIX ACL set first. Fall back to chmod if\n\t * we have no ACL support on this filesystem.\n\t */\n\n\tif (acl_perms && file_ace_list) {\n\t\tif (set_acl_as_root) {\n\t\t\tbecome_root();\n\t\t}\n\t\tret = set_canon_ace_list(fsp, file_ace_list, False, sbuf.st_gid, &acl_set_support);\n\t\tif (set_acl_as_root) {\n\t\t\tunbecome_root();\n\t\t}\n\t\tif (acl_set_support && ret == false) {\n\t\t\tDEBUG(3,(\"set_nt_acl: failed to set file acl on file %s (%s).\\n\", fsp->fsp_name, strerror(errno) ));\n\t\t\tfree_canon_ace_list(file_ace_list);\n\t\t\tfree_canon_ace_list(dir_ace_list);\n\t\t\treturn map_nt_error_from_unix(errno);\n\t\t}\n\t}\n\n\tif (acl_perms && acl_set_support && fsp->is_directory) {\n\t\tif (dir_ace_list) {\n\t\t\tif (set_acl_as_root) {\n\t\t\t\tbecome_root();\n\t\t\t}\n\t\t\tret = set_canon_ace_list(fsp, dir_ace_list, True, sbuf.st_gid, &acl_set_support);\n\t\t\tif (set_acl_as_root) {\n\t\t\t\tunbecome_root();\n\t\t\t}\n\t\t\tif (ret == false) {\n\t\t\t\tDEBUG(3,(\"set_nt_acl: failed to set default acl on directory %s (%s).\\n\", fsp->fsp_name, strerror(errno) ));\n\t\t\t\tfree_canon_ace_list(file_ace_list);\n\t\t\t\tfree_canon_ace_list(dir_ace_list);\n\t\t\t\treturn map_nt_error_from_unix(errno);\n\t\t\t}\n\t\t} else {\n\t\t\tint sret = -1;\n\n\t\t\t/*\n\t\t\t * No default ACL - delete one if it exists.\n\t\t\t */\n\n\t\t\tif (set_acl_as_root) {\n\t\t\t\tbecome_root();\n\t\t\t}\n\t\t\tsret = SMB_VFS_SYS_ACL_DELETE_DEF_FILE(conn, fsp->fsp_name);\n\t\t\tif (set_acl_as_root) {\n\t\t\t\tunbecome_root();\n\t\t\t}\n\t\t\tif (sret == -1) {\n\t\t\t\tif (acl_group_override(conn, sbuf.st_gid, fsp->fsp_name)) {\n\t\t\t\t\tDEBUG(5,(\"set_nt_acl: acl group control on and \"\n\t\t\t\t\t\t\"current user in file %s primary group. Override delete_def_acl\\n\",\n\t\t\t\t\t\tfsp->fsp_name ));\n\n\t\t\t\t\tbecome_root();\n\t\t\t\t\tsret = SMB_VFS_SYS_ACL_DELETE_DEF_FILE(conn, fsp->fsp_name);\n\t\t\t\t\tunbecome_root();\n\t\t\t\t}\n\n\t\t\t\tif (sret == -1) {\n\t\t\t\t\tDEBUG(3,(\"set_nt_acl: sys_acl_delete_def_file failed (%s)\\n\", strerror(errno)));\n\t\t\t\t\tfree_canon_ace_list(file_ace_list);\n\t\t\t\t\tfree_canon_ace_list(dir_ace_list);\n\t\t\t\t\treturn map_nt_error_from_unix(errno);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (acl_set_support) {\n\t\tif (set_acl_as_root) {\n\t\t\tbecome_root();\n\t\t}\n\t\tstore_inheritance_attributes(fsp, file_ace_list, dir_ace_list,\n\t\t\t\t(psd->type & SE_DESC_DACL_PROTECTED) ? True : False);\n\t\tif (set_acl_as_root) {\n\t\t\tunbecome_root();\n\t\t}\n\t}\n\n\t/*\n\t * If we cannot set using POSIX ACLs we fall back to checking if we need to chmod.\n\t */\n\n\tif(!acl_set_support && acl_perms) {\n\t\tmode_t posix_perms;\n\n\t\tif (!convert_canon_ace_to_posix_perms( fsp, file_ace_list, &posix_perms)) {\n\t\t\tfree_canon_ace_list(file_ace_list);\n\t\t\tfree_canon_ace_list(dir_ace_list);\n\t\t\tDEBUG(3,(\"set_nt_acl: failed to convert file acl to posix permissions for file %s.\\n\",\n\t\t\t\tfsp->fsp_name ));\n\t\t\treturn NT_STATUS_ACCESS_DENIED;\n\t\t}\n\n\t\tif (orig_mode != posix_perms) {\n\t\t\tint sret = -1;\n\n\t\t\tDEBUG(3,(\"set_nt_acl: chmod %s. perms = 0%o.\\n\",\n\t\t\t\tfsp->fsp_name, (unsigned int)posix_perms ));\n\n\t\t\tif (set_acl_as_root) {\n\t\t\t\tbecome_root();\n\t\t\t}\n\t\t\tsret = SMB_VFS_CHMOD(conn,fsp->fsp_name, posix_perms);\n\t\t\tif (set_acl_as_root) {\n\t\t\t\tunbecome_root();\n\t\t\t}\n\t\t\tif(sret == -1) {\n\t\t\t\tif (acl_group_override(conn, sbuf.st_gid, fsp->fsp_name)) {\n\t\t\t\t\tDEBUG(5,(\"set_nt_acl: acl group control on and \"\n\t\t\t\t\t\t\"current user in file %s primary group. Override chmod\\n\",\n\t\t\t\t\t\tfsp->fsp_name ));\n\n\t\t\t\t\tbecome_root();\n\t\t\t\t\tsret = SMB_VFS_CHMOD(conn,fsp->fsp_name, posix_perms);\n\t\t\t\t\tunbecome_root();\n\t\t\t\t}\n\n\t\t\t\tif (sret == -1) {\n\t\t\t\t\tDEBUG(3,(\"set_nt_acl: chmod %s, 0%o failed. Error = %s.\\n\",\n\t\t\t\t\t\tfsp->fsp_name, (unsigned int)posix_perms, strerror(errno) ));\n\t\t\t\t\tfree_canon_ace_list(file_ace_list);\n\t\t\t\t\tfree_canon_ace_list(dir_ace_list);\n\t\t\t\t\treturn map_nt_error_from_unix(errno);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfree_canon_ace_list(file_ace_list);\n\tfree_canon_ace_list(dir_ace_list);\n\treturn NT_STATUS_OK;\n}",
        "start_line": 3495
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "source/smbd/posix_acls.c",
        "method_name": "acl_group_override",
        "raw_code": "static bool acl_group_override(connection_struct *conn, /* <=== acl_group_override */ \n\t\t\t\tSMB_STRUCT_STAT *psbuf,\n\t\t\t\tconst char *fname)\n{\n\tif ((errno != EPERM) && (errno != EACCES)) {\n\t\treturn false;\n\t}\n\n\t/* file primary group == user primary or supplementary group */\n\tif (lp_acl_group_control(SNUM(conn)) &&\n\t\t\tcurrent_user_in_group(psbuf->st_gid)) {\n\t\treturn true;\n\t}\n\n\t/* user has writeable permission */\n\tif (lp_dos_filemode(SNUM(conn)) &&\n\t\t\tcan_write_to_file(conn, fname, psbuf)) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
        "start_line": 2386
      },
      {
        "filename": "source/smbd/posix_acls.c",
        "method_name": "set_canon_ace_list",
        "raw_code": "static bool set_canon_ace_list(files_struct *fsp, canon_ace *the_ace, bool default_ace, SMB_STRUCT_STAT *psbuf, bool *pacl_set_support) /* <=== set_canon_ace_list */ \n{\n\tconnection_struct *conn = fsp->conn;\n\tbool ret = False;\n\tSMB_ACL_T the_acl = SMB_VFS_SYS_ACL_INIT(conn, (int)count_canon_ace_list(the_ace) + 1);\n\tcanon_ace *p_ace;\n\tint i;\n\tSMB_ACL_ENTRY_T mask_entry;\n\tbool got_mask_entry = False;\n\tSMB_ACL_PERMSET_T mask_permset;\n\tSMB_ACL_TYPE_T the_acl_type = (default_ace ? SMB_ACL_TYPE_DEFAULT : SMB_ACL_TYPE_ACCESS);\n\tbool needs_mask = False;\n\tmode_t mask_perms = 0;\n\n#if defined(POSIX_ACL_NEEDS_MASK)\n\t/* HP-UX always wants to have a mask (called \"class\" there). */\n\tneeds_mask = True;\n#endif\n\n\tif (the_acl == NULL) {\n\n\t\tif (!no_acl_syscall_error(errno)) {\n\t\t\t/*\n\t\t\t * Only print this error message if we have some kind of ACL\n\t\t\t * support that's not working. Otherwise we would always get this.\n\t\t\t */\n\t\t\tDEBUG(0,(\"set_canon_ace_list: Unable to init %s ACL. (%s)\\n\",\n\t\t\t\tdefault_ace ? \"default\" : \"file\", strerror(errno) ));\n\t\t}\n\t\t*pacl_set_support = False;\n\t\treturn False;\n\t}\n\n\tif( DEBUGLVL( 10 )) {\n\t\tdbgtext(\"set_canon_ace_list: setting ACL:\\n\");\n\t\tfor (i = 0, p_ace = the_ace; p_ace; p_ace = p_ace->next, i++ ) {\n\t\t\tprint_canon_ace( p_ace, i);\n\t\t}\n\t}\n\n\tfor (i = 0, p_ace = the_ace; p_ace; p_ace = p_ace->next, i++ ) {\n\t\tSMB_ACL_ENTRY_T the_entry;\n\t\tSMB_ACL_PERMSET_T the_permset;\n\n\t\t/*\n\t\t * ACLs only \"need\" an ACL_MASK entry if there are any named user or\n\t\t * named group entries. But if there is an ACL_MASK entry, it applies\n\t\t * to ACL_USER, ACL_GROUP, and ACL_GROUP_OBJ entries. Set the mask\n\t\t * so that it doesn't deny (i.e., mask off) any permissions.\n\t\t */\n\n\t\tif (p_ace->type == SMB_ACL_USER || p_ace->type == SMB_ACL_GROUP) {\n\t\t\tneeds_mask = True;\n\t\t\tmask_perms |= p_ace->perms;\n\t\t} else if (p_ace->type == SMB_ACL_GROUP_OBJ) {\n\t\t\tmask_perms |= p_ace->perms;\n\t\t}\n\n\t\t/*\n\t\t * Get the entry for this ACE.\n\t\t */\n\n\t\tif (SMB_VFS_SYS_ACL_CREATE_ENTRY(conn, &the_acl, &the_entry) == -1) {\n\t\t\tDEBUG(0,(\"set_canon_ace_list: Failed to create entry %d. (%s)\\n\",\n\t\t\t\ti, strerror(errno) ));\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (p_ace->type == SMB_ACL_MASK) {\n\t\t\tmask_entry = the_entry;\n\t\t\tgot_mask_entry = True;\n\t\t}\n\n\t\t/*\n\t\t * Ok - we now know the ACL calls should be working, don't\n\t\t * allow fallback to chmod.\n\t\t */\n\n\t\t*pacl_set_support = True;\n\n\t\t/*\n\t\t * Initialise the entry from the canon_ace.\n\t\t */\n\n\t\t/*\n\t\t * First tell the entry what type of ACE this is.\n\t\t */\n\n\t\tif (SMB_VFS_SYS_ACL_SET_TAG_TYPE(conn, the_entry, p_ace->type) == -1) {\n\t\t\tDEBUG(0,(\"set_canon_ace_list: Failed to set tag type on entry %d. (%s)\\n\",\n\t\t\t\ti, strerror(errno) ));\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/*\n\t\t * Only set the qualifier (user or group id) if the entry is a user\n\t\t * or group id ACE.\n\t\t */\n\n\t\tif ((p_ace->type == SMB_ACL_USER) || (p_ace->type == SMB_ACL_GROUP)) {\n\t\t\tif (SMB_VFS_SYS_ACL_SET_QUALIFIER(conn, the_entry,(void *)&p_ace->unix_ug.uid) == -1) {\n\t\t\t\tDEBUG(0,(\"set_canon_ace_list: Failed to set qualifier on entry %d. (%s)\\n\",\n\t\t\t\t\ti, strerror(errno) ));\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Convert the mode_t perms in the canon_ace to a POSIX permset.\n\t\t */\n\n\t\tif (SMB_VFS_SYS_ACL_GET_PERMSET(conn, the_entry, &the_permset) == -1) {\n\t\t\tDEBUG(0,(\"set_canon_ace_list: Failed to get permset on entry %d. (%s)\\n\",\n\t\t\t\ti, strerror(errno) ));\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (map_acl_perms_to_permset(conn, p_ace->perms, &the_permset) == -1) {\n\t\t\tDEBUG(0,(\"set_canon_ace_list: Failed to create permset for mode (%u) on entry %d. (%s)\\n\",\n\t\t\t\t(unsigned int)p_ace->perms, i, strerror(errno) ));\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/*\n\t\t * ..and apply them to the entry.\n\t\t */\n\n\t\tif (SMB_VFS_SYS_ACL_SET_PERMSET(conn, the_entry, the_permset) == -1) {\n\t\t\tDEBUG(0,(\"set_canon_ace_list: Failed to add permset on entry %d. (%s)\\n\",\n\t\t\t\ti, strerror(errno) ));\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif( DEBUGLVL( 10 ))\n\t\t\tprint_canon_ace( p_ace, i);\n\n\t}\n\n\tif (needs_mask && !got_mask_entry) {\n\t\tif (SMB_VFS_SYS_ACL_CREATE_ENTRY(conn, &the_acl, &mask_entry) == -1) {\n\t\t\tDEBUG(0,(\"set_canon_ace_list: Failed to create mask entry. (%s)\\n\", strerror(errno) ));\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (SMB_VFS_SYS_ACL_SET_TAG_TYPE(conn, mask_entry, SMB_ACL_MASK) == -1) {\n\t\t\tDEBUG(0,(\"set_canon_ace_list: Failed to set tag type on mask entry. (%s)\\n\",strerror(errno) ));\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (SMB_VFS_SYS_ACL_GET_PERMSET(conn, mask_entry, &mask_permset) == -1) {\n\t\t\tDEBUG(0,(\"set_canon_ace_list: Failed to get mask permset. (%s)\\n\", strerror(errno) ));\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (map_acl_perms_to_permset(conn, S_IRUSR|S_IWUSR|S_IXUSR, &mask_permset) == -1) {\n\t\t\tDEBUG(0,(\"set_canon_ace_list: Failed to create mask permset. (%s)\\n\", strerror(errno) ));\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (SMB_VFS_SYS_ACL_SET_PERMSET(conn, mask_entry, mask_permset) == -1) {\n\t\t\tDEBUG(0,(\"set_canon_ace_list: Failed to add mask permset. (%s)\\n\", strerror(errno) ));\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t/*\n\t * Finally apply it to the file or directory.\n\t */\n\n\tif(default_ace || fsp->is_directory || fsp->fh->fd == -1) {\n\t\tif (SMB_VFS_SYS_ACL_SET_FILE(conn, fsp->fsp_name, the_acl_type, the_acl) == -1) {\n\t\t\t/*\n\t\t\t * Some systems allow all the above calls and only fail with no ACL support\n\t\t\t * when attempting to apply the acl. HPUX with HFS is an example of this. JRA.\n\t\t\t */\n\t\t\tif (no_acl_syscall_error(errno)) {\n\t\t\t\t*pacl_set_support = False;\n\t\t\t}\n\n\t\t\tif (acl_group_override(conn, psbuf, fsp->fsp_name)) {\n\t\t\t\tint sret;\n\n\t\t\t\tDEBUG(5,(\"set_canon_ace_list: acl group control on and current user in file %s primary group.\\n\",\n\t\t\t\t\tfsp->fsp_name ));\n\n\t\t\t\tbecome_root();\n\t\t\t\tsret = SMB_VFS_SYS_ACL_SET_FILE(conn, fsp->fsp_name, the_acl_type, the_acl);\n\t\t\t\tunbecome_root();\n\t\t\t\tif (sret == 0) {\n\t\t\t\t\tret = True;\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ret == False) {\n\t\t\t\tDEBUG(2,(\"set_canon_ace_list: sys_acl_set_file type %s failed for file %s (%s).\\n\",\n\t\t\t\t\t\tthe_acl_type == SMB_ACL_TYPE_DEFAULT ? \"directory default\" : \"file\",\n\t\t\t\t\t\tfsp->fsp_name, strerror(errno) ));\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (SMB_VFS_SYS_ACL_SET_FD(fsp, the_acl) == -1) {\n\t\t\t/*\n\t\t\t * Some systems allow all the above calls and only fail with no ACL support\n\t\t\t * when attempting to apply the acl. HPUX with HFS is an example of this. JRA.\n\t\t\t */\n\t\t\tif (no_acl_syscall_error(errno)) {\n\t\t\t\t*pacl_set_support = False;\n\t\t\t}\n\n\t\t\tif (acl_group_override(conn, psbuf, fsp->fsp_name)) {\n\t\t\t\tint sret;\n\n\t\t\t\tDEBUG(5,(\"set_canon_ace_list: acl group control on and current user in file %s primary group.\\n\",\n\t\t\t\t\tfsp->fsp_name ));\n\n\t\t\t\tbecome_root();\n\t\t\t\tsret = SMB_VFS_SYS_ACL_SET_FD(fsp, the_acl);\n\t\t\t\tunbecome_root();\n\t\t\t\tif (sret == 0) {\n\t\t\t\t\tret = True;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ret == False) {\n\t\t\t\tDEBUG(2,(\"set_canon_ace_list: sys_acl_set_file failed for file %s (%s).\\n\",\n\t\t\t\t\t\tfsp->fsp_name, strerror(errno) ));\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = True;\n\n  fail:\n\n\tif (the_acl != NULL) {\n\t\tSMB_VFS_SYS_ACL_FREE_ACL(conn, the_acl);\n\t}\n\n\treturn ret;\n}",
        "start_line": 2413
      },
      {
        "filename": "source/smbd/posix_acls.c",
        "method_name": "set_nt_acl",
        "raw_code": "NTSTATUS set_nt_acl(files_struct *fsp, uint32 security_info_sent, SEC_DESC *psd) /* <=== set_nt_acl */ \n{\n\tconnection_struct *conn = fsp->conn;\n\tuid_t user = (uid_t)-1;\n\tgid_t grp = (gid_t)-1;\n\tSMB_STRUCT_STAT sbuf;\n\tDOM_SID file_owner_sid;\n\tDOM_SID file_grp_sid;\n\tcanon_ace *file_ace_list = NULL;\n\tcanon_ace *dir_ace_list = NULL;\n\tbool acl_perms = False;\n\tmode_t orig_mode = (mode_t)0;\n\tNTSTATUS status;\n\tbool set_acl_as_root = false;\n\tbool acl_set_support = false;\n\tbool ret = false;\n\n\tDEBUG(10,(\"set_nt_acl: called for file %s\\n\", fsp->fsp_name ));\n\n\tif (!CAN_WRITE(conn)) {\n\t\tDEBUG(10,(\"set acl rejected on read-only share\\n\"));\n\t\treturn NT_STATUS_MEDIA_WRITE_PROTECTED;\n\t}\n\n\t/*\n\t * Get the current state of the file.\n\t */\n\n\tif(fsp->is_directory || fsp->fh->fd == -1) {\n\t\tif(SMB_VFS_STAT(fsp->conn,fsp->fsp_name, &sbuf) != 0)\n\t\t\treturn map_nt_error_from_unix(errno);\n\t} else {\n\t\tif(SMB_VFS_FSTAT(fsp, &sbuf) != 0)\n\t\t\treturn map_nt_error_from_unix(errno);\n\t}\n\n\t/* Save the original element we check against. */\n\torig_mode = sbuf.st_mode;\n\n\t/*\n\t * Unpack the user/group/world id's.\n\t */\n\n\tstatus = unpack_nt_owners( SNUM(conn), &user, &grp, security_info_sent, psd);\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\treturn status;\n\t}\n\n\t/*\n\t * Do we need to chown ? If so this must be done first as the incoming\n\t * CREATOR_OWNER acl will be relative to the *new* owner, not the old.\n\t * Noticed by Simo.\n\t */\n\n\tif (((user != (uid_t)-1) && (sbuf.st_uid != user)) || (( grp != (gid_t)-1) && (sbuf.st_gid != grp))) {\n\n\t\tDEBUG(3,(\"set_nt_acl: chown %s. uid = %u, gid = %u.\\n\",\n\t\t\t\tfsp->fsp_name, (unsigned int)user, (unsigned int)grp ));\n\n\t\tif(try_chown( fsp->conn, fsp->fsp_name, user, grp) == -1) {\n\t\t\tDEBUG(3,(\"set_nt_acl: chown %s, %u, %u failed. Error = %s.\\n\",\n\t\t\t\tfsp->fsp_name, (unsigned int)user, (unsigned int)grp, strerror(errno) ));\n\t\t\tif (errno == EPERM) {\n\t\t\t\treturn NT_STATUS_INVALID_OWNER;\n\t\t\t}\n\t\t\treturn map_nt_error_from_unix(errno);\n\t\t}\n\n\t\t/*\n\t\t * Recheck the current state of the file, which may have changed.\n\t\t * (suid/sgid bits, for instance)\n\t\t */\n\n\t\tif(fsp->is_directory) {\n\t\t\tif(SMB_VFS_STAT(fsp->conn, fsp->fsp_name, &sbuf) != 0) {\n\t\t\t\treturn map_nt_error_from_unix(errno);\n\t\t\t}\n\t\t} else {\n\n\t\t\tint sret;\n\n\t\t\tif(fsp->fh->fd == -1)\n\t\t\t\tsret = SMB_VFS_STAT(fsp->conn, fsp->fsp_name, &sbuf);\n\t\t\telse\n\t\t\t\tsret = SMB_VFS_FSTAT(fsp, &sbuf);\n\n\t\t\tif(sret != 0)\n\t\t\t\treturn map_nt_error_from_unix(errno);\n\t\t}\n\n\t\t/* Save the original element we check against. */\n\t\torig_mode = sbuf.st_mode;\n\n\t\t/* If we successfully chowned, we know we must\n \t\t * be able to set the acl, so do it as root.\n \t\t */\n\t\tset_acl_as_root = true;\n\t}\n\n\tcreate_file_sids(&sbuf, &file_owner_sid, &file_grp_sid);\n\n\tacl_perms = unpack_canon_ace( fsp, &sbuf, &file_owner_sid, &file_grp_sid,\n\t\t\t\t\t&file_ace_list, &dir_ace_list, security_info_sent, psd);\n\n\t/* Ignore W2K traverse DACL set. */\n\tif (!file_ace_list && !dir_ace_list) {\n\t\treturn NT_STATUS_OK;\n\t}\n\n\tif (!acl_perms) {\n\t\tDEBUG(3,(\"set_nt_acl: cannot set permissions\\n\"));\n\t\tfree_canon_ace_list(file_ace_list);\n\t\tfree_canon_ace_list(dir_ace_list);\n\t\treturn NT_STATUS_ACCESS_DENIED;\n\t}\n\n\t/*\n\t * Only change security if we got a DACL.\n\t */\n\n\tif(!(security_info_sent & DACL_SECURITY_INFORMATION) || (psd->dacl == NULL)) {\n\t\tfree_canon_ace_list(file_ace_list);\n\t\tfree_canon_ace_list(dir_ace_list);\n\t\treturn NT_STATUS_OK;\n\t}\n\n\t/*\n\t * Try using the POSIX ACL set first. Fall back to chmod if\n\t * we have no ACL support on this filesystem.\n\t */\n\n\tif (acl_perms && file_ace_list) {\n\t\tif (set_acl_as_root) {\n\t\t\tbecome_root();\n\t\t}\n\t\tret = set_canon_ace_list(fsp, file_ace_list, False, &sbuf, &acl_set_support);\n\t\tif (set_acl_as_root) {\n\t\t\tunbecome_root();\n\t\t}\n\t\tif (acl_set_support && ret == false) {\n\t\t\tDEBUG(3,(\"set_nt_acl: failed to set file acl on file %s (%s).\\n\", fsp->fsp_name, strerror(errno) ));\n\t\t\tfree_canon_ace_list(file_ace_list);\n\t\t\tfree_canon_ace_list(dir_ace_list);\n\t\t\treturn map_nt_error_from_unix(errno);\n\t\t}\n\t}\n\n\tif (acl_perms && acl_set_support && fsp->is_directory) {\n\t\tif (dir_ace_list) {\n\t\t\tif (set_acl_as_root) {\n\t\t\t\tbecome_root();\n\t\t\t}\n\t\t\tret = set_canon_ace_list(fsp, dir_ace_list, True, &sbuf, &acl_set_support);\n\t\t\tif (set_acl_as_root) {\n\t\t\t\tunbecome_root();\n\t\t\t}\n\t\t\tif (ret == false) {\n\t\t\t\tDEBUG(3,(\"set_nt_acl: failed to set default acl on directory %s (%s).\\n\", fsp->fsp_name, strerror(errno) ));\n\t\t\t\tfree_canon_ace_list(file_ace_list);\n\t\t\t\tfree_canon_ace_list(dir_ace_list);\n\t\t\t\treturn map_nt_error_from_unix(errno);\n\t\t\t}\n\t\t} else {\n\t\t\tint sret = -1;\n\n\t\t\t/*\n\t\t\t * No default ACL - delete one if it exists.\n\t\t\t */\n\n\t\t\tif (set_acl_as_root) {\n\t\t\t\tbecome_root();\n\t\t\t}\n\t\t\tsret = SMB_VFS_SYS_ACL_DELETE_DEF_FILE(conn, fsp->fsp_name);\n\t\t\tif (set_acl_as_root) {\n\t\t\t\tunbecome_root();\n\t\t\t}\n\t\t\tif (sret == -1) {\n\t\t\t\tif (acl_group_override(conn, &sbuf, fsp->fsp_name)) {\n\t\t\t\t\tDEBUG(5,(\"set_nt_acl: acl group control on and \"\n\t\t\t\t\t\t\"current user in file %s primary group. Override delete_def_acl\\n\",\n\t\t\t\t\t\tfsp->fsp_name ));\n\n\t\t\t\t\tbecome_root();\n\t\t\t\t\tsret = SMB_VFS_SYS_ACL_DELETE_DEF_FILE(conn, fsp->fsp_name);\n\t\t\t\t\tunbecome_root();\n\t\t\t\t}\n\n\t\t\t\tif (sret == -1) {\n\t\t\t\t\tDEBUG(3,(\"set_nt_acl: sys_acl_delete_def_file failed (%s)\\n\", strerror(errno)));\n\t\t\t\t\tfree_canon_ace_list(file_ace_list);\n\t\t\t\t\tfree_canon_ace_list(dir_ace_list);\n\t\t\t\t\treturn map_nt_error_from_unix(errno);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (acl_set_support) {\n\t\tif (set_acl_as_root) {\n\t\t\tbecome_root();\n\t\t}\n\t\tstore_inheritance_attributes(fsp, file_ace_list, dir_ace_list,\n\t\t\t\t(psd->type & SE_DESC_DACL_PROTECTED) ? True : False);\n\t\tif (set_acl_as_root) {\n\t\t\tunbecome_root();\n\t\t}\n\t}\n\n\t/*\n\t * If we cannot set using POSIX ACLs we fall back to checking if we need to chmod.\n\t */\n\n\tif(!acl_set_support && acl_perms) {\n\t\tmode_t posix_perms;\n\n\t\tif (!convert_canon_ace_to_posix_perms( fsp, file_ace_list, &posix_perms)) {\n\t\t\tfree_canon_ace_list(file_ace_list);\n\t\t\tfree_canon_ace_list(dir_ace_list);\n\t\t\tDEBUG(3,(\"set_nt_acl: failed to convert file acl to posix permissions for file %s.\\n\",\n\t\t\t\tfsp->fsp_name ));\n\t\t\treturn NT_STATUS_ACCESS_DENIED;\n\t\t}\n\n\t\tif (orig_mode != posix_perms) {\n\t\t\tint sret = -1;\n\n\t\t\tDEBUG(3,(\"set_nt_acl: chmod %s. perms = 0%o.\\n\",\n\t\t\t\tfsp->fsp_name, (unsigned int)posix_perms ));\n\n\t\t\tif (set_acl_as_root) {\n\t\t\t\tbecome_root();\n\t\t\t}\n\t\t\tsret = SMB_VFS_CHMOD(conn,fsp->fsp_name, posix_perms);\n\t\t\tif (set_acl_as_root) {\n\t\t\t\tunbecome_root();\n\t\t\t}\n\t\t\tif(sret == -1) {\n\t\t\t\tif (acl_group_override(conn, &sbuf, fsp->fsp_name)) {\n\t\t\t\t\tDEBUG(5,(\"set_nt_acl: acl group control on and \"\n\t\t\t\t\t\t\"current user in file %s primary group. Override chmod\\n\",\n\t\t\t\t\t\tfsp->fsp_name ));\n\n\t\t\t\t\tbecome_root();\n\t\t\t\t\tsret = SMB_VFS_CHMOD(conn,fsp->fsp_name, posix_perms);\n\t\t\t\t\tunbecome_root();\n\t\t\t\t}\n\n\t\t\t\tif (sret == -1) {\n\t\t\t\t\tDEBUG(3,(\"set_nt_acl: chmod %s, 0%o failed. Error = %s.\\n\",\n\t\t\t\t\t\tfsp->fsp_name, (unsigned int)posix_perms, strerror(errno) ));\n\t\t\t\t\tfree_canon_ace_list(file_ace_list);\n\t\t\t\t\tfree_canon_ace_list(dir_ace_list);\n\t\t\t\t\treturn map_nt_error_from_unix(errno);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfree_canon_ace_list(file_ace_list);\n\tfree_canon_ace_list(dir_ace_list);\n\treturn NT_STATUS_OK;\n}",
        "start_line": 3493
      }
    ],
    "code_context": "Called Methods:\n- SNUM: #define SNUM(conn)         \t((conn)?(conn)->params->service:GLOBAL_SECTION_SNUM) /* <=== source/include/smb_macros.h:108:108:SNUM:1 */ \n- ensure_canon_entry_valid: static bool ensure_canon_entry_valid(canon_ace **pp_ace, /* <=== ensure_canon_entry_valid */ \n\t\t\t\t     const struct share_params *params,\n\t\t\t\t     const bool is_directory,\n\t\t\t\t\t\t\tconst DOM_SID *pfile_owner_sid,\n\t\t\t\t\t\t\tconst DOM_SID *pfile_grp_sid,\n\t\t\t\t\t\t\tconst SMB_STRUCT_STAT *pst,\n\t\t\t\t\t\t\tbool setting_acl)\n{\n\tcanon_ace *pace;\n\tbool got_user = False;\n\tbool got_grp = False;\n\tbool got_other = False;\n\tcanon_ace *pace_other = NULL;\n\n\tfor (pace = *pp_ace; pace; pace = pace->next) {\n\t\tif (pace->type == SMB_ACL_USER_OBJ) {\n\n\t\t\tif (setting_acl)\n\t\t\t\tapply_default_perms(params, is_directory, pace, S_IRUSR);\n\t\t\tgot_user = True;\n\n\t\t} else if (pace->type == SMB_ACL_GROUP_OBJ) {\n\n\t\t\t/*\n\t\t\t * Ensure create mask/force create mode is respected on set.\n\t\t\t */\n\n\t\t\tif (setting_acl)\n\t\t\t\tapply_default_perms(params, is_directory, pace, S_IRGRP);\n\t\t\tgot_grp = True;\n\n\t\t} else if (pace->type == SMB_ACL_OTHER) {\n\n\t\t\t/*\n\t\t\t * Ensure create mask/force create mode is respected on set.\n\t\t\t */\n\n\t\t\tif (setting_acl)\n\t\t\t\tapply_default_perms(params, is_directory, pace, S_IROTH);\n\t\t\tgot_other = True;\n\t\t\tpace_other = pace;\n\t\t}\n\t}\n\n\tif (!got_user) {\n\t\tif ((pace = SMB_MALLOC_P(canon_ace)) == NULL) {\n\t\t\tDEBUG(0,(\"ensure_canon_entry_valid: malloc fail.\\n\"));\n\t\t\treturn False;\n\t\t}\n\n\t\tZERO_STRUCTP(pace);\n\t\tpace->type = SMB_ACL_USER_OBJ;\n\t\tpace->owner_type = UID_ACE;\n\t\tpace->unix_ug.uid = pst->st_uid;\n\t\tpace->trustee = *pfile_owner_sid;\n\t\tpace->attr = ALLOW_ACE;\n\n\t\tif (setting_acl) {\n\t\t\t/* See if the owning user is in any of the other groups in\n\t\t\t   the ACE. If so, OR in the permissions from that group. */\n\n\t\t\tbool group_matched = False;\n\t\t\tcanon_ace *pace_iter;\n\n\t\t\tfor (pace_iter = *pp_ace; pace_iter; pace_iter = pace_iter->next) {\n\t\t\t\tif (pace_iter->type == SMB_ACL_GROUP_OBJ || pace_iter->type == SMB_ACL_GROUP) {\n\t\t\t\t\tif (uid_entry_in_group(pace, pace_iter)) {\n\t\t\t\t\t\tpace->perms |= pace_iter->perms;\n\t\t\t\t\t\tgroup_matched = True;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* If we only got an \"everyone\" perm, just use that. */\n\t\t\tif (!group_matched) {\n\t\t\t\tif (got_other)\n\t\t\t\t\tpace->perms = pace_other->perms;\n\t\t\t\telse\n\t\t\t\t\tpace->perms = 0;\n\t\t\t}\n\n\t\t\tapply_default_perms(params, is_directory, pace, S_IRUSR);\n\t\t} else {\n\t\t\tpace->perms = unix_perms_to_acl_perms(pst->st_mode, S_IRUSR, S_IWUSR, S_IXUSR);\n\t\t}\n\n\t\tDLIST_ADD(*pp_ace, pace);\n\t}\n\n\tif (!got_grp) {\n\t\tif ((pace = SMB_MALLOC_P(canon_ace)) == NULL) {\n\t\t\tDEBUG(0,(\"ensure_canon_entry_valid: malloc fail.\\n\"));\n\t\t\treturn False;\n\t\t}\n\n\t\tZERO_STRUCTP(pace);\n\t\tpace->type = SMB_ACL_GROUP_OBJ;\n\t\tpace->owner_type = GID_ACE;\n\t\tpace->unix_ug.uid = pst->st_gid;\n\t\tpace->trustee = *pfile_grp_sid;\n\t\tpace->attr = ALLOW_ACE;\n\t\tif (setting_acl) {\n\t\t\t/* If we only got an \"everyone\" perm, just use that. */\n\t\t\tif (got_other)\n\t\t\t\tpace->perms = pace_other->perms;\n\t\t\telse\n\t\t\t\tpace->perms = 0;\n\t\t\tapply_default_perms(params, is_directory, pace, S_IRGRP);\n\t\t} else {\n\t\t\tpace->perms = unix_perms_to_acl_perms(pst->st_mode, S_IRGRP, S_IWGRP, S_IXGRP);\n\t\t}\n\n\t\tDLIST_ADD(*pp_ace, pace);\n\t}\n\n\tif (!got_other) {\n\t\tif ((pace = SMB_MALLOC_P(canon_ace)) == NULL) {\n\t\t\tDEBUG(0,(\"ensure_canon_entry_valid: malloc fail.\\n\"));\n\t\t\treturn False;\n\t\t}\n\n\t\tZERO_STRUCTP(pace);\n\t\tpace->type = SMB_ACL_OTHER;\n\t\tpace->owner_type = WORLD_ACE;\n\t\tpace->unix_ug.world = -1;\n\t\tpace->trustee = global_sid_World;\n\t\tpace->attr = ALLOW_ACE;\n\t\tif (setting_acl) {\n\t\t\tpace->perms = 0;\n\t\t\tapply_default_perms(params, is_directory, pace, S_IROTH);\n\t\t} else\n\t\t\tpace->perms = unix_perms_to_acl_perms(pst->st_mode, S_IROTH, S_IWOTH, S_IXOTH);\n\n\t\tDLIST_ADD(*pp_ace, pace);\n\t}\n\n\treturn True;\n}\n- push_conn_ctx: static void push_conn_ctx(void) /* <=== push_conn_ctx */ \n{\n\tstruct conn_ctx *ctx_p;\n \n\t/* Check we don't overflow our stack */\n \n\tif (conn_ctx_stack_ndx == MAX_SEC_CTX_DEPTH) {\n\t\tDEBUG(0, (\"Connection context stack overflow!\\n\"));\n\t\tsmb_panic(\"Connection context stack overflow!\\n\");\n\t}\n \n\t/* Store previous user context */\n\tctx_p = &conn_ctx_stack[conn_ctx_stack_ndx];\n \n\tctx_p->conn = current_user.conn;\n\tctx_p->vuid = current_user.vuid;\n \n\tDEBUG(3, (\"push_conn_ctx(%u) : conn_ctx_stack_ndx = %d\\n\",\n\t\t(unsigned int)ctx_p->vuid, conn_ctx_stack_ndx ));\n\n\tconn_ctx_stack_ndx++;\n}\n- map_acl_perms_to_permset: static int map_acl_perms_to_permset(connection_struct *conn, mode_t mode, SMB_ACL_PERMSET_T *p_permset) /* <=== map_acl_perms_to_permset */ \n{\n\tif (SMB_VFS_SYS_ACL_CLEAR_PERMS(conn, *p_permset) ==  -1)\n\t\treturn -1;\n\tif (mode & S_IRUSR) {\n\t\tif (SMB_VFS_SYS_ACL_ADD_PERM(conn, *p_permset, SMB_ACL_READ) == -1)\n\t\t\treturn -1;\n\t}\n\tif (mode & S_IWUSR) {\n\t\tif (SMB_VFS_SYS_ACL_ADD_PERM(conn, *p_permset, SMB_ACL_WRITE) == -1)\n\t\t\treturn -1;\n\t}\n\tif (mode & S_IXUSR) {\n\t\tif (SMB_VFS_SYS_ACL_ADD_PERM(conn, *p_permset, SMB_ACL_EXECUTE) == -1)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n- SMB_VFS_SYS_ACL_ADD_PERM: #define SMB_VFS_SYS_ACL_ADD_PERM(conn, permset, perm) ((conn)->vfs.ops.sys_acl_add_perm((conn)->vfs.handles.sys_acl_add_perm, (permset), (perm))) /* <=== source/include/vfs_macros.h:105:105:SMB_VFS_SYS_ACL_ADD_PERM:3 */ \n- SMB_VFS_FREMOVEXATTR: #define SMB_VFS_FREMOVEXATTR(fsp,name) ((fsp)->conn->vfs.ops.fremovexattr((fsp)->conn->vfs.handles.fremovexattr,(fsp),(name))) /* <=== source/include/vfs_macros.h:130:130:SMB_VFS_FREMOVEXATTR:2 */ \n- rep_snprintf: int rep_snprintf(char *,size_t ,const char *, ...) PRINTF_ATTRIBUTE(3,4); /* <=== rep_snprintf */ \n- store_inheritance_attributes: static void store_inheritance_attributes(files_struct *fsp, canon_ace *file_ace_list, /* <=== store_inheritance_attributes */ \n\t\t\t\t\tcanon_ace *dir_ace_list, bool pai_protected)\n{\n\tint ret;\n\tsize_t store_size;\n\tchar *pai_buf;\n\n\tif (!lp_map_acl_inherit(SNUM(fsp->conn)))\n\t\treturn;\n\n\t/*\n\t * Don't store if this ACL isn't protected and\n\t * none of the entries in it are marked as inherited.\n\t */\n\n\tif (!pai_protected && num_inherited_entries(file_ace_list) == 0 && num_inherited_entries(dir_ace_list) == 0) {\n\t\t/* Instead just remove the attribute if it exists. */\n\t\tif (fsp->fh->fd != -1)\n\t\t\tSMB_VFS_FREMOVEXATTR(fsp, SAMBA_POSIX_INHERITANCE_EA_NAME);\n\t\telse\n\t\t\tSMB_VFS_REMOVEXATTR(fsp->conn, fsp->fsp_name, SAMBA_POSIX_INHERITANCE_EA_NAME);\n\t\treturn;\n\t}\n\n\tpai_buf = create_pai_buf(file_ace_list, dir_ace_list, pai_protected, &store_size);\n\n\tif (fsp->fh->fd != -1)\n\t\tret = SMB_VFS_FSETXATTR(fsp, SAMBA_POSIX_INHERITANCE_EA_NAME,\n\t\t\t\tpai_buf, store_size, 0);\n\telse\n\t\tret = SMB_VFS_SETXATTR(fsp->conn,fsp->fsp_name, SAMBA_POSIX_INHERITANCE_EA_NAME,\n\t\t\t\tpai_buf, store_size, 0);\n\n\tSAFE_FREE(pai_buf);\n\n\tDEBUG(10,(\"store_inheritance_attribute:%s for file %s\\n\", pai_protected ? \" (protected)\" : \"\", fsp->fsp_name));\n\tif (ret == -1 && !no_acl_syscall_error(errno))\n\t\tDEBUG(1,(\"store_inheritance_attribute: Error %s\\n\", strerror(errno) ));\n}\n- count_canon_ace_list: static size_t count_canon_ace_list( canon_ace *list_head ) /* <=== count_canon_ace_list */ \n{\n\tsize_t count = 0;\n\tcanon_ace *ace;\n\n\tfor (ace = list_head; ace; ace = ace->next)\n\t\tcount++;\n\n\treturn count;\n}\n- NT_STATUS_OK: #define NT_STATUS_OK NT_STATUS(0x0000) /* <=== source/include/nterr.h:62:62:NT_STATUS_OK:0 */ \n- SMB_VFS_CHOWN: #define SMB_VFS_CHOWN(conn, path, uid, gid) ((conn)->vfs.ops.chown((conn)->vfs.handles.chown, (path), (uid), (gid))) /* <=== source/include/vfs_macros.h:67:67:SMB_VFS_CHOWN:4 */ \n- pop_conn_ctx: static void pop_conn_ctx(void) /* <=== pop_conn_ctx */ \n{\n\tstruct conn_ctx *ctx_p;\n \n\t/* Check for stack underflow. */\n\n\tif (conn_ctx_stack_ndx == 0) {\n\t\tDEBUG(0, (\"Connection context stack underflow!\\n\"));\n\t\tsmb_panic(\"Connection context stack underflow!\\n\");\n\t}\n\n\tconn_ctx_stack_ndx--;\n\tctx_p = &conn_ctx_stack[conn_ctx_stack_ndx];\n\n\tcurrent_user.conn = ctx_p->conn;\n\tcurrent_user.vuid = ctx_p->vuid;\n\n\tctx_p->conn = NULL;\n\tctx_p->vuid = UID_FIELD_INVALID;\n}\n- SMB_VFS_SETXATTR: #define SMB_VFS_SETXATTR(conn,path,name,value,size,flags) ((conn)->vfs.ops.setxattr((conn)->vfs.handles.setxattr,(path),(name),(value),(size),(flags))) /* <=== source/include/vfs_macros.h:131:131:SMB_VFS_SETXATTR:6 */ \n- SMB_VFS_FCHOWN: #define SMB_VFS_FCHOWN(fsp, uid, gid) ((fsp)->conn->vfs.ops.fchown((fsp)->conn->vfs.handles.fchown, (fsp), (uid), (gid))) /* <=== source/include/vfs_macros.h:68:68:SMB_VFS_FCHOWN:3 */ \n- unbecome_root: void unbecome_root(void) /* <=== unbecome_root */ \n{\n\tpop_sec_ctx();\n\tpop_conn_ctx();\n}\n- False: #define False false /* <=== source/include/smb.h:49:49:False:0 */ \n- NT_STATUS_IS_OK: #define NT_STATUS_IS_OK(x) (NT_STATUS_V(x) == 0) /* <=== source/include/nt_status.h:56:56:NT_STATUS_IS_OK:1 */ \n- free_canon_ace_list: static void free_canon_ace_list( canon_ace *list_head ) /* <=== free_canon_ace_list */ \n{\n\tcanon_ace *list, *next;\n\n\tfor (list = list_head; list; list = next) {\n\t\tnext = list->next;\n\t\tDLIST_REMOVE(list_head, list);\n\t\tSAFE_FREE(list);\n\t}\n}\n- True: #define True true /* <=== source/include/smb.h:50:50:True:0 */ \n- try_chown: int try_chown(connection_struct *conn, const char *fname, uid_t uid, gid_t gid) /* <=== try_chown */ \n{\n\tint ret;\n\tfiles_struct *fsp;\n\tSMB_STRUCT_STAT st;\n\n\tif(!CAN_WRITE(conn)) {\n\t\treturn -1;\n\t}\n\n\t/* Case (1). */\n\t/* try the direct way first */\n\tret = SMB_VFS_CHOWN(conn, fname, uid, gid);\n\tif (ret == 0)\n\t\treturn 0;\n\n\t/* Case (2) / (3) */\n\tif (lp_enable_privileges()) {\n\n\t\tbool has_take_ownership_priv = user_has_privileges(current_user.nt_user_token,\n\t\t\t\t\t\t\t      &se_take_ownership);\n\t\tbool has_restore_priv = user_has_privileges(current_user.nt_user_token,\n\t\t\t\t\t\t       &se_restore);\n\n\t\t/* Case (2) */\n\t\tif ( ( has_take_ownership_priv && ( uid == current_user.ut.uid ) ) ||\n\t\t/* Case (3) */\n\t\t     ( has_restore_priv ) ) {\n\n\t\t\tbecome_root();\n\t\t\t/* Keep the current file gid the same - take ownership doesn't imply group change. */\n\t\t\tret = SMB_VFS_CHOWN(conn, fname, uid, (gid_t)-1);\n\t\t\tunbecome_root();\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* Case (4). */\n\tif (!lp_dos_filemode(SNUM(conn))) {\n\t\terrno = EPERM;\n\t\treturn -1;\n\t}\n\n\t/* only allow chown to the current user. This is more secure,\n\t   and also copes with the case where the SID in a take ownership ACL is\n\t   a local SID on the users workstation\n\t*/\n\tif (uid != current_user.ut.uid) {\n\t\terrno = EPERM;\n\t\treturn -1;\n\t}\n\n\tif (SMB_VFS_STAT(conn,fname,&st)) {\n\t\treturn -1;\n\t}\n\n\tif (!NT_STATUS_IS_OK(open_file_fchmod(conn,fname,&st,&fsp))) {\n\t\treturn -1;\n\t}\n\n\tbecome_root();\n\t/* Keep the current file gid the same. */\n\tret = SMB_VFS_FCHOWN(fsp, uid, (gid_t)-1);\n\tunbecome_root();\n\n\tclose_file_fchmod(fsp);\n\n\treturn ret;\n}\n- unpack_canon_ace: static bool unpack_canon_ace(files_struct *fsp,  /* <=== unpack_canon_ace */ \n\t\t\t\t\t\t\tSMB_STRUCT_STAT *pst,\n\t\t\t\t\t\t\tDOM_SID *pfile_owner_sid,\n\t\t\t\t\t\t\tDOM_SID *pfile_grp_sid,\n\t\t\t\t\t\t\tcanon_ace **ppfile_ace, canon_ace **ppdir_ace,\n\t\t\t\t\t\t\tuint32 security_info_sent, SEC_DESC *psd)\n{\n\tcanon_ace *file_ace = NULL;\n\tcanon_ace *dir_ace = NULL;\n\n\t*ppfile_ace = NULL;\n\t*ppdir_ace = NULL;\n\n\tif(security_info_sent == 0) {\n\t\tDEBUG(0,(\"unpack_canon_ace: no security info sent !\\n\"));\n\t\treturn False;\n\t}\n\n\t/*\n\t * If no DACL then this is a chown only security descriptor.\n\t */\n\n\tif(!(security_info_sent & DACL_SECURITY_INFORMATION) || !psd->dacl)\n\t\treturn True;\n\n\t/*\n\t * Now go through the DACL and create the canon_ace lists.\n\t */\n\n\tif (!create_canon_ace_lists( fsp, pst, pfile_owner_sid, pfile_grp_sid,\n\t\t\t\t\t\t\t\t&file_ace, &dir_ace, psd->dacl))\n\t\treturn False;\n\n\tif ((file_ace == NULL) && (dir_ace == NULL)) {\n\t\t/* W2K traverse DACL set - ignore. */\n\t\treturn True;\n\t}\n\n\t/*\n\t * Go through the canon_ace list and merge entries\n\t * belonging to identical users of identical allow or deny type.\n\t * We can do this as all deny entries come first, followed by\n\t * all allow entries (we have mandated this before accepting this acl).\n\t */\n\n\tprint_canon_ace_list( \"file ace - before merge\", file_ace);\n\tmerge_aces( &file_ace );\n\n\tprint_canon_ace_list( \"dir ace - before merge\", dir_ace);\n\tmerge_aces( &dir_ace );\n\n\t/*\n\t * NT ACLs are order dependent. Go through the acl lists and\n\t * process DENY entries by masking the allow entries.\n\t */\n\n\tprint_canon_ace_list( \"file ace - before deny\", file_ace);\n\tprocess_deny_list( &file_ace);\n\n\tprint_canon_ace_list( \"dir ace - before deny\", dir_ace);\n\tprocess_deny_list( &dir_ace);\n\n\t/*\n\t * A well formed POSIX file or default ACL has at least 3 entries, a \n\t * SMB_ACL_USER_OBJ, SMB_ACL_GROUP_OBJ, SMB_ACL_OTHER_OBJ\n\t * and optionally a mask entry. Ensure this is the case.\n\t */\n\n\tprint_canon_ace_list( \"file ace - before valid\", file_ace);\n\n\t/*\n\t * A default 3 element mode entry for a file should be r-- --- ---.\n\t * A default 3 element mode entry for a directory should be rwx --- ---.\n\t */\n\n\tpst->st_mode = create_default_mode(fsp, False);\n\n\tif (!ensure_canon_entry_valid(&file_ace, fsp->conn->params, fsp->is_directory, pfile_owner_sid, pfile_grp_sid, pst, True)) {\n\t\tfree_canon_ace_list(file_ace);\n\t\tfree_canon_ace_list(dir_ace);\n\t\treturn False;\n\t}\n\n\tprint_canon_ace_list( \"dir ace - before valid\", dir_ace);\n\n\t/*\n\t * A default inheritable 3 element mode entry for a directory should be the\n\t * mode Samba will use to create a file within. Ensure user rwx bits are set if\n\t * it's a directory.\n\t */\n\n\tpst->st_mode = create_default_mode(fsp, True);\n\n\tif (dir_ace && !ensure_canon_entry_valid(&dir_ace, fsp->conn->params, fsp->is_directory, pfile_owner_sid, pfile_grp_sid, pst, True)) {\n\t\tfree_canon_ace_list(file_ace);\n\t\tfree_canon_ace_list(dir_ace);\n\t\treturn False;\n\t}\n\n\tprint_canon_ace_list( \"file ace - return\", file_ace);\n\tprint_canon_ace_list( \"dir ace - return\", dir_ace);\n\n\t*ppfile_ace = file_ace;\n\t*ppdir_ace = dir_ace;\n\treturn True;\n\n}\n- MAP_PERM: #define MAP_PERM(p,mask,result) (((p) & (mask)) ? (result) : 0 ) /* <=== source/smbd/posix_acls.c:2695:2695:MAP_PERM:3 */ \n- MAP_PERM: #define MAP_PERM(p,mask,result) (((p) & (mask)) ? (result) : 0 ) /* <=== source/smbd/posix_acls.c:2693:2693:MAP_PERM:3 */ \n- SMB_ACL_TYPE_ACCESS: #define SMB_ACL_TYPE_ACCESS\t\t\t0 /* <=== source/include/smb_acls.h:62:62:SMB_ACL_TYPE_ACCESS:0 */ \n- dbgtext:  bool dbgtext( const char *format_str, ... ) /* <=== dbgtext */ \n{\n\tva_list ap;\n\tchar *msgbuf = NULL;\n\tbool ret = true;\n\tint res;\n\n\tva_start(ap, format_str);\n\tres = vasprintf(&msgbuf, format_str, ap);\n\tva_end(ap);\n\n\tif (res != -1) {\n\t\tformat_debug_text(msgbuf);\n\t} else {\n\t\tret = false;\n\t}\n\tSAFE_FREE(msgbuf);\n\treturn ret;\n}\n- DEBUGLVL: #define DEBUGLVL( level ) \\ /* <=== source/include/debug.h:193:195:DEBUGLVL:1 */ \n  ( CHECK_DEBUGLVL(level) \\\n   && dbghdr( level, DBGC_CLASS, __FILE__, FUNCTION_MACRO, (__LINE__) ) )\n- SMB_VFS_REMOVEXATTR: #define SMB_VFS_REMOVEXATTR(conn,path,name) ((conn)->vfs.ops.removexattr((conn)->vfs.handles.removexattr,(path),(name))) /* <=== source/include/vfs_macros.h:128:128:SMB_VFS_REMOVEXATTR:3 */ \n- SMB_VFS_CHMOD: #define SMB_VFS_CHMOD(conn, path, mode) ((conn)->vfs.ops.chmod((conn)->vfs.handles.chmod, (path), (mode))) /* <=== source/include/vfs_macros.h:65:65:SMB_VFS_CHMOD:3 */ \n- create_pai_buf: static char *create_pai_buf(canon_ace *file_ace_list, canon_ace *dir_ace_list, bool pai_protected, size_t *store_size) /* <=== create_pai_buf */ \n{\n\tchar *pai_buf = NULL;\n\tcanon_ace *ace_list = NULL;\n\tchar *entry_offset = NULL;\n\tunsigned int num_entries = 0;\n\tunsigned int num_def_entries = 0;\n\n\tfor (ace_list = file_ace_list; ace_list; ace_list = ace_list->next)\n\t\tif (ace_list->inherited)\n\t\t\tnum_entries++;\n\n\tfor (ace_list = dir_ace_list; ace_list; ace_list = ace_list->next)\n\t\tif (ace_list->inherited)\n\t\t\tnum_def_entries++;\n\n\tDEBUG(10,(\"create_pai_buf: num_entries = %u, num_def_entries = %u\\n\", num_entries, num_def_entries ));\n\n\t*store_size = PAI_ENTRIES_BASE + ((num_entries + num_def_entries)*PAI_ENTRY_LENGTH);\n\n\tpai_buf = (char *)SMB_MALLOC(*store_size);\n\tif (!pai_buf) {\n\t\treturn NULL;\n\t}\n\n\t/* Set up the header. */\n\tmemset(pai_buf, '\\0', PAI_ENTRIES_BASE);\n\tSCVAL(pai_buf,PAI_VERSION_OFFSET,PAI_VERSION);\n\tSCVAL(pai_buf,PAI_FLAG_OFFSET,(pai_protected ? PAI_ACL_FLAG_PROTECTED : 0));\n\tSSVAL(pai_buf,PAI_NUM_ENTRIES_OFFSET,num_entries);\n\tSSVAL(pai_buf,PAI_NUM_DEFAULT_ENTRIES_OFFSET,num_def_entries);\n\n\tentry_offset = pai_buf + PAI_ENTRIES_BASE;\n\n\tfor (ace_list = file_ace_list; ace_list; ace_list = ace_list->next) {\n\t\tif (ace_list->inherited) {\n\t\t\tuint8 type_val = (unsigned char)ace_list->owner_type;\n\t\t\tuint32 entry_val = get_entry_val(ace_list);\n\n\t\t\tSCVAL(entry_offset,0,type_val);\n\t\t\tSIVAL(entry_offset,1,entry_val);\n\t\t\tentry_offset += PAI_ENTRY_LENGTH;\n\t\t}\n\t}\n\n\tfor (ace_list = dir_ace_list; ace_list; ace_list = ace_list->next) {\n\t\tif (ace_list->inherited) {\n\t\t\tuint8 type_val = (unsigned char)ace_list->owner_type;\n\t\t\tuint32 entry_val = get_entry_val(ace_list);\n\n\t\t\tSCVAL(entry_offset,0,type_val);\n\t\t\tSIVAL(entry_offset,1,entry_val);\n\t\t\tentry_offset += PAI_ENTRY_LENGTH;\n\t\t}\n\t}\n\n\treturn pai_buf;\n}\n- SE_DESC_DACL_PROTECTED: #define SE_DESC_DACL_PROTECTED\t\t0x1000 /* <=== source/include/rpc_secdes.h:52:52:SE_DESC_DACL_PROTECTED:0 */ \n- dbghdr: bool dbghdr(int level, int cls, const char *file, const char *func, int line) /* <=== dbghdr */ \n{\n\t/* Ensure we don't lose any real errno value. */\n\tint old_errno = errno;\n\n\tif( format_pos ) {\n\t\t/* This is a fudge.  If there is stuff sitting in the format_bufr, then\n\t\t * the *right* thing to do is to call\n\t\t *   format_debug_text( \"\\n\" );\n\t\t * to write the remainder, and then proceed with the new header.\n\t\t * Unfortunately, there are several places in the code at which\n\t\t * the DEBUG() macro is used to build partial lines.  That in mind,\n\t\t * we'll work under the assumption that an incomplete line indicates\n\t\t * that a new header is *not* desired.\n\t\t */\n\t\treturn( True );\n\t}\n\n#ifdef WITH_SYSLOG\n\t/* Set syslog_level. */\n\tsyslog_level = level;\n#endif\n\n\t/* Don't print a header if we're logging to stdout. */\n\tif( stdout_logging )\n\t\treturn( True );\n\n\t/* Print the header if timestamps are turned on.  If parameters are\n\t * not yet loaded, then default to timestamps on.\n\t */\n\tif( lp_timestamp_logs() || lp_debug_prefix_timestamp() || !(lp_loaded()) ) {\n\t\tchar header_str[200];\n\n\t\theader_str[0] = '\\0';\n\n\t\tif( lp_debug_pid())\n\t\t\tslprintf(header_str,sizeof(header_str)-1,\", pid=%u\",(unsigned int)sys_getpid());\n\n\t\tif( lp_debug_uid()) {\n\t\t\tsize_t hs_len = strlen(header_str);\n\t\t\tslprintf(header_str + hs_len,\n\t\t\tsizeof(header_str) - 1 - hs_len,\n\t\t\t\t\", effective(%u, %u), real(%u, %u)\",\n\t\t\t\t(unsigned int)geteuid(), (unsigned int)getegid(),\n\t\t\t\t(unsigned int)getuid(), (unsigned int)getgid()); \n\t\t}\n\n\t\tif (lp_debug_class() && (cls != DBGC_ALL)) {\n\t\t\tsize_t hs_len = strlen(header_str);\n\t\t\tslprintf(header_str + hs_len,\n\t\t\t\t sizeof(header_str) -1 - hs_len,\n\t\t\t\t \", class=%s\",\n\t\t\t\t default_classname_table[cls]);\n\t\t}\n  \n\t\t/* Print it all out at once to prevent split syslog output. */\n\t\tif( lp_debug_prefix_timestamp() ) {\n\t\t    (void)Debug1( \"[%s, %2d%s] \",\n\t\t\tcurrent_timestring(debug_ctx(),\n\t\t\t\t\t   lp_debug_hires_timestamp()),\n\t\t\tlevel, header_str);\n\t\t} else {\n\t\t    (void)Debug1( \"[%s, %2d%s] %s:%s(%d)\\n\",\n\t\t\tcurrent_timestring(debug_ctx(),\n\t\t\t\t\t   lp_debug_hires_timestamp()),\n\t\t\tlevel, header_str, file, func, line );\n\t\t}\n\t}\n\n\terrno = old_errno;\n\treturn( True );\n}\n- create_canon_ace_lists: static bool create_canon_ace_lists(files_struct *fsp, SMB_STRUCT_STAT *pst, /* <=== create_canon_ace_lists */ \n\t\t\t\t\t\t\tDOM_SID *pfile_owner_sid,\n\t\t\t\t\t\t\tDOM_SID *pfile_grp_sid,\n\t\t\t\t\t\t\tcanon_ace **ppfile_ace, canon_ace **ppdir_ace,\n\t\t\t\t\t\t\tSEC_ACL *dacl)\n{\n\tbool all_aces_are_inherit_only = (fsp->is_directory ? True : False);\n\tcanon_ace *file_ace = NULL;\n\tcanon_ace *dir_ace = NULL;\n\tcanon_ace *current_ace = NULL;\n\tbool got_dir_allow = False;\n\tbool got_file_allow = False;\n\tint i, j;\n\n\t*ppfile_ace = NULL;\n\t*ppdir_ace = NULL;\n\n\t/*\n\t * Convert the incoming ACL into a more regular form.\n\t */\n\n\tfor(i = 0; i < dacl->num_aces; i++) {\n\t\tSEC_ACE *psa = &dacl->aces[i];\n\n\t\tif((psa->type != SEC_ACE_TYPE_ACCESS_ALLOWED) && (psa->type != SEC_ACE_TYPE_ACCESS_DENIED)) {\n\t\t\tDEBUG(3,(\"create_canon_ace_lists: unable to set anything but an ALLOW or DENY ACE.\\n\"));\n\t\t\treturn False;\n\t\t}\n\n\t\tif (nt4_compatible_acls()) {\n\t\t\t/*\n\t\t\t * The security mask may be UNIX_ACCESS_NONE which should map into\n\t\t\t * no permissions (we overload the WRITE_OWNER bit for this) or it\n\t\t\t * should be one of the ALL/EXECUTE/READ/WRITE bits. Arrange for this\n\t\t\t * to be so. Any other bits override the UNIX_ACCESS_NONE bit.\n\t\t\t */\n\n\t\t\t/*\n\t\t\t * Convert GENERIC bits to specific bits.\n\t\t\t */\n \n\t\t\tse_map_generic(&psa->access_mask, &file_generic_mapping);\n\n\t\t\tpsa->access_mask &= (UNIX_ACCESS_NONE|FILE_ALL_ACCESS);\n\n\t\t\tif(psa->access_mask != UNIX_ACCESS_NONE)\n\t\t\t\tpsa->access_mask &= ~UNIX_ACCESS_NONE;\n\t\t}\n\t}\n\n\t/*\n\t * Deal with the fact that NT 4.x re-writes the canonical format\n\t * that we return for default ACLs. If a directory ACE is identical\n\t * to a inherited directory ACE then NT changes the bits so that the\n\t * first ACE is set to OI|IO and the second ACE for this SID is set\n\t * to CI. We need to repair this. JRA.\n\t */\n\n\tfor(i = 0; i < dacl->num_aces; i++) {\n\t\tSEC_ACE *psa1 = &dacl->aces[i];\n\n\t\tfor (j = i + 1; j < dacl->num_aces; j++) {\n\t\t\tSEC_ACE *psa2 = &dacl->aces[j];\n\n\t\t\tif (psa1->access_mask != psa2->access_mask)\n\t\t\t\tcontinue;\n\n\t\t\tif (!sid_equal(&psa1->trustee, &psa2->trustee))\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * Ok - permission bits and SIDs are equal.\n\t\t\t * Check if flags were re-written.\n\t\t\t */\n\n\t\t\tif (psa1->flags & SEC_ACE_FLAG_INHERIT_ONLY) {\n\n\t\t\t\tpsa1->flags |= (psa2->flags & (SEC_ACE_FLAG_CONTAINER_INHERIT|SEC_ACE_FLAG_OBJECT_INHERIT));\n\t\t\t\tpsa2->flags &= ~(SEC_ACE_FLAG_CONTAINER_INHERIT|SEC_ACE_FLAG_OBJECT_INHERIT);\n\n\t\t\t} else if (psa2->flags & SEC_ACE_FLAG_INHERIT_ONLY) {\n\n\t\t\t\tpsa2->flags |= (psa1->flags & (SEC_ACE_FLAG_CONTAINER_INHERIT|SEC_ACE_FLAG_OBJECT_INHERIT));\n\t\t\t\tpsa1->flags &= ~(SEC_ACE_FLAG_CONTAINER_INHERIT|SEC_ACE_FLAG_OBJECT_INHERIT);\n\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(i = 0; i < dacl->num_aces; i++) {\n\t\tSEC_ACE *psa = &dacl->aces[i];\n\n\t\t/*\n\t\t * Create a cannon_ace entry representing this NT DACL ACE.\n\t\t */\n\n\t\tif ((current_ace = SMB_MALLOC_P(canon_ace)) == NULL) {\n\t\t\tfree_canon_ace_list(file_ace);\n\t\t\tfree_canon_ace_list(dir_ace);\n\t\t\tDEBUG(0,(\"create_canon_ace_lists: malloc fail.\\n\"));\n\t\t\treturn False;\n\t\t}\n\n\t\tZERO_STRUCTP(current_ace);\n\n\t\tsid_copy(&current_ace->trustee, &psa->trustee);\n\n\t\t/*\n\t\t * Try and work out if the SID is a user or group\n\t\t * as we need to flag these differently for POSIX.\n\t\t * Note what kind of a POSIX ACL this should map to.\n\t\t */\n\n\t\tif( sid_equal(&current_ace->trustee, &global_sid_World)) {\n\t\t\tcurrent_ace->owner_type = WORLD_ACE;\n\t\t\tcurrent_ace->unix_ug.world = -1;\n\t\t\tcurrent_ace->type = SMB_ACL_OTHER;\n\t\t} else if (sid_equal(&current_ace->trustee, &global_sid_Creator_Owner)) {\n\t\t\tcurrent_ace->owner_type = UID_ACE;\n\t\t\tcurrent_ace->unix_ug.uid = pst->st_uid;\n\t\t\tcurrent_ace->type = SMB_ACL_USER_OBJ;\n\n\t\t\t/*\n\t\t\t * The Creator Owner entry only specifies inheritable permissions,\n\t\t\t * never access permissions. WinNT doesn't always set the ACE to\n\t\t\t *INHERIT_ONLY, though.\n\t\t\t */\n\n\t\t\tif (nt4_compatible_acls())\n\t\t\t\tpsa->flags |= SEC_ACE_FLAG_INHERIT_ONLY;\n\t\t} else if (sid_equal(&current_ace->trustee, &global_sid_Creator_Group)) {\n\t\t\tcurrent_ace->owner_type = GID_ACE;\n\t\t\tcurrent_ace->unix_ug.gid = pst->st_gid;\n\t\t\tcurrent_ace->type = SMB_ACL_GROUP_OBJ;\n\n\t\t\t/*\n\t\t\t * The Creator Group entry only specifies inheritable permissions,\n\t\t\t * never access permissions. WinNT doesn't always set the ACE to\n\t\t\t *INHERIT_ONLY, though.\n\t\t\t */\n\t\t\tif (nt4_compatible_acls())\n\t\t\t\tpsa->flags |= SEC_ACE_FLAG_INHERIT_ONLY;\n\n\t\t} else if (sid_to_uid( &current_ace->trustee, &current_ace->unix_ug.uid)) {\n\t\t\tcurrent_ace->owner_type = UID_ACE;\n\t\t\t/* If it's the owning user, this is a user_obj, not\n\t\t\t * a user. */\n\t\t\tif (current_ace->unix_ug.uid == pst->st_uid) {\n\t\t\t\tcurrent_ace->type = SMB_ACL_USER_OBJ;\n\t\t\t} else {\n\t\t\t\tcurrent_ace->type = SMB_ACL_USER;\n\t\t\t}\n\t\t} else if (sid_to_gid( &current_ace->trustee, &current_ace->unix_ug.gid)) {\n\t\t\tcurrent_ace->owner_type = GID_ACE;\n\t\t\t/* If it's the primary group, this is a group_obj, not\n\t\t\t * a group. */\n\t\t\tif (current_ace->unix_ug.gid == pst->st_gid) {\n\t\t\t\tcurrent_ace->type = SMB_ACL_GROUP_OBJ;\n\t\t\t} else {\n\t\t\t\tcurrent_ace->type = SMB_ACL_GROUP;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Silently ignore map failures in non-mappable SIDs (NT Authority, BUILTIN etc).\n\t\t\t */\n\n\t\t\tif (non_mappable_sid(&psa->trustee)) {\n\t\t\t\tDEBUG(10, (\"create_canon_ace_lists: ignoring \"\n\t\t\t\t\t   \"non-mappable SID %s\\n\",\n\t\t\t\t\t   sid_string_dbg(&psa->trustee)));\n\t\t\t\tSAFE_FREE(current_ace);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfree_canon_ace_list(file_ace);\n\t\t\tfree_canon_ace_list(dir_ace);\n\t\t\tDEBUG(0, (\"create_canon_ace_lists: unable to map SID \"\n\t\t\t\t  \"%s to uid or gid.\\n\",\n\t\t\t\t  sid_string_dbg(&current_ace->trustee)));\n\t\t\tSAFE_FREE(current_ace);\n\t\t\treturn False;\n\t\t}\n\n\t\t/*\n\t\t * Map the given NT permissions into a UNIX mode_t containing only\n\t\t * S_I(R|W|X)USR bits.\n\t\t */\n\n\t\tcurrent_ace->perms |= map_nt_perms( &psa->access_mask, S_IRUSR);\n\t\tcurrent_ace->attr = (psa->type == SEC_ACE_TYPE_ACCESS_ALLOWED) ? ALLOW_ACE : DENY_ACE;\n\t\tcurrent_ace->inherited = ((psa->flags & SEC_ACE_FLAG_INHERITED_ACE) ? True : False);\n\n\t\t/*\n\t\t * Now add the created ace to either the file list, the directory\n\t\t * list, or both. We *MUST* preserve the order here (hence we use\n\t\t * DLIST_ADD_END) as NT ACLs are order dependent.\n\t\t */\n\n\t\tif (fsp->is_directory) {\n\n\t\t\t/*\n\t\t\t * We can only add to the default POSIX ACE list if the ACE is\n\t\t\t * designed to be inherited by both files and directories.\n\t\t\t */\n\n\t\t\tif ((psa->flags & (SEC_ACE_FLAG_OBJECT_INHERIT|SEC_ACE_FLAG_CONTAINER_INHERIT)) ==\n\t\t\t\t(SEC_ACE_FLAG_OBJECT_INHERIT|SEC_ACE_FLAG_CONTAINER_INHERIT)) {\n\n\t\t\t\tDLIST_ADD_END(dir_ace, current_ace, canon_ace *);\n\n\t\t\t\t/*\n\t\t\t\t * Note if this was an allow ace. We can't process\n\t\t\t\t * any further deny ace's after this.\n\t\t\t\t */\n\n\t\t\t\tif (current_ace->attr == ALLOW_ACE)\n\t\t\t\t\tgot_dir_allow = True;\n\n\t\t\t\tif ((current_ace->attr == DENY_ACE) && got_dir_allow) {\n\t\t\t\t\tDEBUG(0,(\"create_canon_ace_lists: malformed ACL in inheritable ACL ! \\\nDeny entry after Allow entry. Failing to set on file %s.\\n\", fsp->fsp_name ));\n\t\t\t\t\tfree_canon_ace_list(file_ace);\n\t\t\t\t\tfree_canon_ace_list(dir_ace);\n\t\t\t\t\treturn False;\n\t\t\t\t}\t\n\n\t\t\t\tif( DEBUGLVL( 10 )) {\n\t\t\t\t\tdbgtext(\"create_canon_ace_lists: adding dir ACL:\\n\");\n\t\t\t\t\tprint_canon_ace( current_ace, 0);\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * If this is not an inherit only ACE we need to add a duplicate\n\t\t\t\t * to the file acl.\n\t\t\t\t */\n\n\t\t\t\tif (!(psa->flags & SEC_ACE_FLAG_INHERIT_ONLY)) {\n\t\t\t\t\tcanon_ace *dup_ace = dup_canon_ace(current_ace);\n\n\t\t\t\t\tif (!dup_ace) {\n\t\t\t\t\t\tDEBUG(0,(\"create_canon_ace_lists: malloc fail !\\n\"));\n\t\t\t\t\t\tfree_canon_ace_list(file_ace);\n\t\t\t\t\t\tfree_canon_ace_list(dir_ace);\n\t\t\t\t\t\treturn False;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * We must not free current_ace here as its\n\t\t\t\t\t * pointer is now owned by the dir_ace list.\n\t\t\t\t\t */\n\t\t\t\t\tcurrent_ace = dup_ace;\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * We must not free current_ace here as its\n\t\t\t\t\t * pointer is now owned by the dir_ace list.\n\t\t\t\t\t */\n\t\t\t\t\tcurrent_ace = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Only add to the file ACL if not inherit only.\n\t\t */\n\n\t\tif (current_ace && !(psa->flags & SEC_ACE_FLAG_INHERIT_ONLY)) {\n\t\t\tDLIST_ADD_END(file_ace, current_ace, canon_ace *);\n\n\t\t\t/*\n\t\t\t * Note if this was an allow ace. We can't process\n\t\t\t * any further deny ace's after this.\n\t\t\t */\n\n\t\t\tif (current_ace->attr == ALLOW_ACE)\n\t\t\t\tgot_file_allow = True;\n\n\t\t\tif ((current_ace->attr == DENY_ACE) && got_file_allow) {\n\t\t\t\tDEBUG(0,(\"create_canon_ace_lists: malformed ACL in file ACL ! \\\nDeny entry after Allow entry. Failing to set on file %s.\\n\", fsp->fsp_name ));\n\t\t\t\tfree_canon_ace_list(file_ace);\n\t\t\t\tfree_canon_ace_list(dir_ace);\n\t\t\t\treturn False;\n\t\t\t}\t\n\n\t\t\tif( DEBUGLVL( 10 )) {\n\t\t\t\tdbgtext(\"create_canon_ace_lists: adding file ACL:\\n\");\n\t\t\t\tprint_canon_ace( current_ace, 0);\n\t\t\t}\n\t\t\tall_aces_are_inherit_only = False;\n\t\t\t/*\n\t\t\t * We must not free current_ace here as its\n\t\t\t * pointer is now owned by the file_ace list.\n\t\t\t */\n\t\t\tcurrent_ace = NULL;\n\t\t}\n\n\t\t/*\n\t\t * Free if ACE was not added.\n\t\t */\n\n\t\tSAFE_FREE(current_ace);\n\t}\n\n\tif (fsp->is_directory && all_aces_are_inherit_only) {\n\t\t/*\n\t\t * Windows 2000 is doing one of these weird 'inherit acl'\n\t\t * traverses to conserve NTFS ACL resources. Just pretend\n\t\t * there was no DACL sent. JRA.\n\t\t */\n\n\t\tDEBUG(10,(\"create_canon_ace_lists: Win2k inherit acl traverse. Ignoring DACL.\\n\"));\n\t\tfree_canon_ace_list(file_ace);\n\t\tfree_canon_ace_list(dir_ace);\n\t\tfile_ace = NULL;\n\t\tdir_ace = NULL;\n\t} else {\n\t\t/*\n\t\t * Check if we have SMB_ACL_USER_OBJ and SMB_ACL_GROUP_OBJ entries in each\n\t\t * ACL. If we don't have them, check if any SMB_ACL_USER/SMB_ACL_GROUP\n\t\t * entries can be converted to *_OBJ. Usually we will already have these\n\t\t * entries in the Default ACL, and the Access ACL will not have them.\n\t\t */\n\t\tif (file_ace) {\n\t\t\tcheck_owning_objs(file_ace, pfile_owner_sid, pfile_grp_sid);\n\t\t}\n\t\tif (dir_ace) {\n\t\t\tcheck_owning_objs(dir_ace, pfile_owner_sid, pfile_grp_sid);\n\t\t}\n\t}\n\n\t*ppfile_ace = file_ace;\n\t*ppdir_ace = dir_ace;\n\n\treturn True;\n}\n- SMB_VFS_SYS_ACL_SET_TAG_TYPE: #define SMB_VFS_SYS_ACL_SET_TAG_TYPE(conn, entry, tagtype) ((conn)->vfs.ops.sys_acl_set_tag_type((conn)->vfs.handles.sys_acl_set_tag_type, (entry), (tagtype))) /* <=== source/include/vfs_macros.h:109:109:SMB_VFS_SYS_ACL_SET_TAG_TYPE:3 */ \n- convert_canon_ace_to_posix_perms: static bool convert_canon_ace_to_posix_perms( files_struct *fsp, canon_ace *file_ace_list, mode_t *posix_perms) /* <=== convert_canon_ace_to_posix_perms */ \n{\n\tint snum = SNUM(fsp->conn);\n\tsize_t ace_count = count_canon_ace_list(file_ace_list);\n\tcanon_ace *ace_p;\n\tcanon_ace *owner_ace = NULL;\n\tcanon_ace *group_ace = NULL;\n\tcanon_ace *other_ace = NULL;\n\tmode_t and_bits;\n\tmode_t or_bits;\n\n\tif (ace_count != 3) {\n\t\tDEBUG(3,(\"convert_canon_ace_to_posix_perms: Too many ACE entries for file %s to convert to \\\nposix perms.\\n\", fsp->fsp_name ));\n\t\treturn False;\n\t}\n\n\tfor (ace_p = file_ace_list; ace_p; ace_p = ace_p->next) {\n\t\tif (ace_p->owner_type == UID_ACE)\n\t\t\towner_ace = ace_p;\n\t\telse if (ace_p->owner_type == GID_ACE)\n\t\t\tgroup_ace = ace_p;\n\t\telse if (ace_p->owner_type == WORLD_ACE)\n\t\t\tother_ace = ace_p;\n\t}\n\n\tif (!owner_ace || !group_ace || !other_ace) {\n\t\tDEBUG(3,(\"convert_canon_ace_to_posix_perms: Can't get standard entries for file %s.\\n\",\n\t\t\t\tfsp->fsp_name ));\n\t\treturn False;\n\t}\n\n\t*posix_perms = (mode_t)0;\n\n\t*posix_perms |= owner_ace->perms;\n\t*posix_perms |= MAP_PERM(group_ace->perms, S_IRUSR, S_IRGRP);\n\t*posix_perms |= MAP_PERM(group_ace->perms, S_IWUSR, S_IWGRP);\n\t*posix_perms |= MAP_PERM(group_ace->perms, S_IXUSR, S_IXGRP);\n\t*posix_perms |= MAP_PERM(other_ace->perms, S_IRUSR, S_IROTH);\n\t*posix_perms |= MAP_PERM(other_ace->perms, S_IWUSR, S_IWOTH);\n\t*posix_perms |= MAP_PERM(other_ace->perms, S_IXUSR, S_IXOTH);\n\n\t/* The owner must have at least read access. */\n\n\t*posix_perms |= S_IRUSR;\n\tif (fsp->is_directory)\n\t\t*posix_perms |= (S_IWUSR|S_IXUSR);\n\n\t/* If requested apply the masks. */\n\n\t/* Get the initial bits to apply. */\n\n\tif (fsp->is_directory) {\n\t\tand_bits = lp_dir_security_mask(snum);\n\t\tor_bits = lp_force_dir_security_mode(snum);\n\t} else {\n\t\tand_bits = lp_security_mask(snum);\n\t\tor_bits = lp_force_security_mode(snum);\n\t}\n\n\t*posix_perms = (((*posix_perms) & and_bits)|or_bits);\n\n\tDEBUG(10,(\"convert_canon_ace_to_posix_perms: converted u=%o,g=%o,w=%o to perm=0%o for file %s.\\n\",\n\t\t(int)owner_ace->perms, (int)group_ace->perms, (int)other_ace->perms, (int)*posix_perms,\n\t\tfsp->fsp_name ));\n\n\treturn True;\n}\n- S_IWUSR: #define S_IWUSR 00200           /* write permission: owner */ /* <=== source/lib/replace/system/filesys.h:140:140:S_IWUSR:0 */ \n- SMB_VFS_SYS_ACL_DELETE_DEF_FILE: #define SMB_VFS_SYS_ACL_DELETE_DEF_FILE(conn, path) ((conn)->vfs.ops.sys_acl_delete_def_file((conn)->vfs.handles.sys_acl_delete_def_file, (path))) /* <=== source/include/vfs_macros.h:115:115:SMB_VFS_SYS_ACL_DELETE_DEF_FILE:2 */ \n- create_default_mode: static mode_t create_default_mode(files_struct *fsp, bool interitable_mode) /* <=== create_default_mode */ \n{\n\tint snum = SNUM(fsp->conn);\n\tmode_t and_bits = (mode_t)0;\n\tmode_t or_bits = (mode_t)0;\n\tmode_t mode = interitable_mode\n\t\t? unix_mode( fsp->conn, FILE_ATTRIBUTE_ARCHIVE, fsp->fsp_name,\n\t\t\t     NULL )\n\t\t: S_IRUSR;\n\n\tif (fsp->is_directory)\n\t\tmode |= (S_IWUSR|S_IXUSR);\n\n\t/*\n\t * Now AND with the create mode/directory mode bits then OR with the\n\t * force create mode/force directory mode bits.\n\t */\n\n\tif (fsp->is_directory) {\n\t\tand_bits = lp_dir_security_mask(snum);\n\t\tor_bits = lp_force_dir_security_mode(snum);\n\t} else {\n\t\tand_bits = lp_security_mask(snum);\n\t\tor_bits = lp_force_security_mode(snum);\n\t}\n\n\treturn ((mode & and_bits)|or_bits);\n}\n- DACL_SECURITY_INFORMATION: #define DACL_SECURITY_INFORMATION\t0x00000004 /* <=== source/include/rpc_secdes.h:58:58:DACL_SECURITY_INFORMATION:0 */ \n- SMB_VFS_SYS_ACL_SET_PERMSET: #define SMB_VFS_SYS_ACL_SET_PERMSET(conn, entry, permset) ((conn)->vfs.ops.sys_acl_set_permset((conn)->vfs.handles.sys_acl_set_permset, (entry), (permset))) /* <=== source/include/vfs_macros.h:111:111:SMB_VFS_SYS_ACL_SET_PERMSET:3 */ \n- SMB_VFS_SYS_ACL_CREATE_ENTRY: #define SMB_VFS_SYS_ACL_CREATE_ENTRY(conn, pacl, pentry) ((conn)->vfs.ops.sys_acl_create_entry((conn)->vfs.handles.sys_acl_create_entry, (pacl), (pentry))) /* <=== source/include/vfs_macros.h:108:108:SMB_VFS_SYS_ACL_CREATE_ENTRY:3 */ \n- S_IRUSR: #define S_IRUSR 00400           /* read permission: owner */ /* <=== source/lib/replace/system/filesys.h:137:137:S_IRUSR:0 */ \n- CAN_WRITE: #define CAN_WRITE(conn)    (!conn->read_only) /* <=== source/include/smb_macros.h:114:114:CAN_WRITE:1 */ \n- SMB_VFS_SYS_ACL_FREE_ACL: #define SMB_VFS_SYS_ACL_FREE_ACL(conn, posix_acl) ((conn)->vfs.ops.sys_acl_free_acl((conn)->vfs.handles.sys_acl_free_acl, (posix_acl))) /* <=== source/include/vfs_macros.h:118:118:SMB_VFS_SYS_ACL_FREE_ACL:2 */ \n- true: #define true (1) /* <=== source/lib/replace/replace.h:466:466:true:0 */ \n- SMB_VFS_SYS_ACL_GET_PERMSET: #define SMB_VFS_SYS_ACL_GET_PERMSET(conn, entry_d, permset_p) ((conn)->vfs.ops.sys_acl_get_permset((conn)->vfs.handles.sys_acl_get_permset, (entry_d), (permset_p))) /* <=== source/include/vfs_macros.h:100:100:SMB_VFS_SYS_ACL_GET_PERMSET:3 */ \n- merge_aces: static void merge_aces( canon_ace **pp_list_head ) /* <=== merge_aces */ \n{\n\tcanon_ace *list_head = *pp_list_head;\n\tcanon_ace *curr_ace_outer;\n\tcanon_ace *curr_ace_outer_next;\n\n\t/*\n\t * First, merge allow entries with identical SIDs, and deny entries\n\t * with identical SIDs.\n\t */\n\n\tfor (curr_ace_outer = list_head; curr_ace_outer; curr_ace_outer = curr_ace_outer_next) {\n\t\tcanon_ace *curr_ace;\n\t\tcanon_ace *curr_ace_next;\n\n\t\tcurr_ace_outer_next = curr_ace_outer->next; /* Save the link in case we delete. */\n\n\t\tfor (curr_ace = curr_ace_outer->next; curr_ace; curr_ace = curr_ace_next) {\n\n\t\t\tcurr_ace_next = curr_ace->next; /* Save the link in case of delete. */\n\n\t\t\tif (identity_in_ace_equal(curr_ace, curr_ace_outer) &&\n\t\t\t\t(curr_ace->attr == curr_ace_outer->attr)) {\n\n\t\t\t\tif( DEBUGLVL( 10 )) {\n\t\t\t\t\tdbgtext(\"merge_aces: Merging ACE's\\n\");\n\t\t\t\t\tprint_canon_ace( curr_ace_outer, 0);\n\t\t\t\t\tprint_canon_ace( curr_ace, 0);\n\t\t\t\t}\n\n\t\t\t\t/* Merge two allow or two deny ACE's. */\n\n\t\t\t\tcurr_ace_outer->perms |= curr_ace->perms;\n\t\t\t\tDLIST_REMOVE(list_head, curr_ace);\n\t\t\t\tSAFE_FREE(curr_ace);\n\t\t\t\tcurr_ace_outer_next = curr_ace_outer->next; /* We may have deleted the link. */\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Now go through and mask off allow permissions with deny permissions.\n\t * We can delete either the allow or deny here as we know that each SID\n\t * appears only once in the list.\n\t */\n\n\tfor (curr_ace_outer = list_head; curr_ace_outer; curr_ace_outer = curr_ace_outer_next) {\n\t\tcanon_ace *curr_ace;\n\t\tcanon_ace *curr_ace_next;\n\n\t\tcurr_ace_outer_next = curr_ace_outer->next; /* Save the link in case we delete. */\n\n\t\tfor (curr_ace = curr_ace_outer->next; curr_ace; curr_ace = curr_ace_next) {\n\n\t\t\tcurr_ace_next = curr_ace->next; /* Save the link in case of delete. */\n\n\t\t\t/*\n\t\t\t * Subtract ACE's with different entries. Due to the ordering constraints\n\t\t\t * we've put on the ACL, we know the deny must be the first one.\n\t\t\t */\n\n\t\t\tif (identity_in_ace_equal(curr_ace, curr_ace_outer) &&\n\t\t\t\t(curr_ace_outer->attr == DENY_ACE) && (curr_ace->attr == ALLOW_ACE)) {\n\n\t\t\t\tif( DEBUGLVL( 10 )) {\n\t\t\t\t\tdbgtext(\"merge_aces: Masking ACE's\\n\");\n\t\t\t\t\tprint_canon_ace( curr_ace_outer, 0);\n\t\t\t\t\tprint_canon_ace( curr_ace, 0);\n\t\t\t\t}\n\n\t\t\t\tcurr_ace->perms &= ~curr_ace_outer->perms;\n\n\t\t\t\tif (curr_ace->perms == 0) {\n\n\t\t\t\t\t/*\n\t\t\t\t\t * The deny overrides the allow. Remove the allow.\n\t\t\t\t\t */\n\n\t\t\t\t\tDLIST_REMOVE(list_head, curr_ace);\n\t\t\t\t\tSAFE_FREE(curr_ace);\n\t\t\t\t\tcurr_ace_outer_next = curr_ace_outer->next; /* We may have deleted the link. */\n\n\t\t\t\t} else {\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Even after removing permissions, there\n\t\t\t\t\t * are still allow permissions - delete the deny.\n\t\t\t\t\t * It is safe to delete the deny here,\n\t\t\t\t\t * as we are guarenteed by the deny first\n\t\t\t\t\t * ordering that all the deny entries for\n\t\t\t\t\t * this SID have already been merged into one\n\t\t\t\t\t * before we can get to an allow ace.\n\t\t\t\t\t */\n\n\t\t\t\t\tDLIST_REMOVE(list_head, curr_ace_outer);\n\t\t\t\t\tSAFE_FREE(curr_ace_outer);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} /* end for curr_ace */\n\t} /* end for curr_ace_outer */\n\n\t/* We may have modified the list. */\n\n\t*pp_list_head = list_head;\n}\n- Debug1:  int Debug1( const char *format_str, ... ) /* <=== Debug1 */ \n{\n\tva_list ap;\n\tint old_errno = errno;\n\n\tdebug_count++;\n\n\tif( stdout_logging ) {\n\t\tva_start( ap, format_str );\n\t\tif(dbf)\n\t\t\t(void)x_vfprintf( dbf, format_str, ap );\n\t\tva_end( ap );\n\t\terrno = old_errno;\n\t\tgoto done;\n\t}\n\n\t/* prevent recursion by checking if reopen_logs() has temporaily\n\t   set the debugf string to NULL */\n\tif( debugf == NULL)\n\t\tgoto done;\n\n#ifdef WITH_SYSLOG\n\tif( !lp_syslog_only() )\n#endif\n\t{\n\t\tif( !dbf ) {\n\t\t\tmode_t oldumask = umask( 022 );\n\n\t\t\tdbf = x_fopen( debugf, O_WRONLY|O_APPEND|O_CREAT, 0644 );\n\t\t\t(void)umask( oldumask );\n\t\t\tif( dbf ) {\n\t\t\t\tx_setbuf( dbf, NULL );\n\t\t\t} else {\n\t\t\t\terrno = old_errno;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef WITH_SYSLOG\n\tif( syslog_level < lp_syslog() ) {\n\t\t/* map debug levels to syslog() priorities\n\t\t * note that not all DEBUG(0, ...) calls are\n\t\t * necessarily errors */\n\t\tstatic int priority_map[] = {\n\t\t\tLOG_ERR,     /* 0 */\n\t\t\tLOG_WARNING, /* 1 */\n\t\t\tLOG_NOTICE,  /* 2 */\n\t\t\tLOG_INFO,    /* 3 */\n\t\t};\n\t\tint     priority;\n\t\tchar *msgbuf = NULL;\n\t\tint ret;\n\n\t\tif( syslog_level >= ( sizeof(priority_map) / sizeof(priority_map[0]) ) || syslog_level < 0)\n\t\t\tpriority = LOG_DEBUG;\n\t\telse\n\t\t\tpriority = priority_map[syslog_level];\n\n\t\tva_start(ap, format_str);\n\t\tret = vasprintf(&msgbuf, format_str, ap);\n\t\tva_end(ap);\n\n\t\tif (ret != -1) {\n\t\t\tsyslog(priority, \"%s\", msgbuf);\n\t\t}\n\t\tSAFE_FREE(msgbuf);\n\t}\n#endif\n\n\tcheck_log_size();\n\n#ifdef WITH_SYSLOG\n\tif( !lp_syslog_only() )\n#endif\n\t{\n\t\tva_start( ap, format_str );\n\t\tif(dbf)\n\t\t\t(void)x_vfprintf( dbf, format_str, ap );\n\t\tva_end( ap );\n\t\tif(dbf)\n\t\t\t(void)x_fflush( dbf );\n\t}\n\n done:\n\tTALLOC_FREE(tmp_debug_ctx);\n\n\terrno = old_errno;\n\n\treturn( 0 );\n}\n- SMB_VFS_FSETXATTR: #define SMB_VFS_FSETXATTR(fsp,name,value,size,flags) ((fsp)->conn->vfs.ops.fsetxattr((fsp)->conn->vfs.handles.fsetxattr,(fsp),(name),(value),(size),(flags))) /* <=== source/include/vfs_macros.h:133:133:SMB_VFS_FSETXATTR:5 */ \n- FILE_WRITE_DATA: #define FILE_WRITE_DATA       0x00000002 /* <=== source/include/smb.h:1240:1240:FILE_WRITE_DATA:0 */ \n- format_debug_text: static void format_debug_text( const char *msg ) /* <=== format_debug_text */ \n{\n\tsize_t i;\n\tbool timestamp = (!stdout_logging && (lp_timestamp_logs() || !(lp_loaded())));\n\n\tif (!format_bufr) {\n\t\tdebug_init();\n\t}\n\n\tfor( i = 0; msg[i]; i++ ) {\n\t\t/* Indent two spaces at each new line. */\n\t\tif(timestamp && 0 == format_pos) {\n\t\t\tformat_bufr[0] = format_bufr[1] = ' ';\n\t\t\tformat_pos = 2;\n\t\t}\n\n\t\t/* If there's room, copy the character to the format buffer. */\n\t\tif( format_pos < FORMAT_BUFR_MAX )\n\t\t\tformat_bufr[format_pos++] = msg[i];\n\n\t\t/* If a newline is encountered, print & restart. */\n\t\tif( '\\n' == msg[i] )\n\t\t\tbufr_print();\n\n\t\t/* If the buffer is full dump it out, reset it, and put out a line\n\t\t * continuation indicator.\n\t\t */\n\t\tif( format_pos >= FORMAT_BUFR_MAX ) {\n\t\t\tbufr_print();\n\t\t\t(void)Debug1( \" +>\\n\" );\n\t\t}\n\t}\n\n\t/* Just to be safe... */\n\tformat_bufr[format_pos] = '\\0';\n}\n- print_canon_ace: static void print_canon_ace(canon_ace *pace, int num) /* <=== print_canon_ace */ \n{\n\tdbgtext( \"canon_ace index %d. Type = %s \", num, pace->attr == ALLOW_ACE ? \"allow\" : \"deny\" );\n\tdbgtext( \"SID = %s \", sid_string_dbg(&pace->trustee));\n\tif (pace->owner_type == UID_ACE) {\n\t\tconst char *u_name = uidtoname(pace->unix_ug.uid);\n\t\tdbgtext( \"uid %u (%s) \", (unsigned int)pace->unix_ug.uid, u_name );\n\t} else if (pace->owner_type == GID_ACE) {\n\t\tchar *g_name = gidtoname(pace->unix_ug.gid);\n\t\tdbgtext( \"gid %u (%s) \", (unsigned int)pace->unix_ug.gid, g_name );\n\t} else\n\t\tdbgtext( \"other \");\n\tswitch (pace->type) {\n\t\tcase SMB_ACL_USER:\n\t\t\tdbgtext( \"SMB_ACL_USER \");\n\t\t\tbreak;\n\t\tcase SMB_ACL_USER_OBJ:\n\t\t\tdbgtext( \"SMB_ACL_USER_OBJ \");\n\t\t\tbreak;\n\t\tcase SMB_ACL_GROUP:\n\t\t\tdbgtext( \"SMB_ACL_GROUP \");\n\t\t\tbreak;\n\t\tcase SMB_ACL_GROUP_OBJ:\n\t\t\tdbgtext( \"SMB_ACL_GROUP_OBJ \");\n\t\t\tbreak;\n\t\tcase SMB_ACL_OTHER:\n\t\t\tdbgtext( \"SMB_ACL_OTHER \");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdbgtext( \"MASK \" );\n\t\t\tbreak;\n\t}\n\tif (pace->inherited)\n\t\tdbgtext( \"(inherited) \");\n\tdbgtext( \"perms \");\n\tdbgtext( \"%c\", pace->perms & S_IRUSR ? 'r' : '-');\n\tdbgtext( \"%c\", pace->perms & S_IWUSR ? 'w' : '-');\n\tdbgtext( \"%c\\n\", pace->perms & S_IXUSR ? 'x' : '-');\n}\n- SMB_VFS_FSTAT: #define SMB_VFS_FSTAT(fsp, sbuf) ((fsp)->conn->vfs.ops.fstat((fsp)->conn->vfs.handles.fstat, (fsp), (sbuf))) /* <=== source/include/vfs_macros.h:62:62:SMB_VFS_FSTAT:2 */ \n- SMB_VFS_SYS_ACL_SET_QUALIFIER: #define SMB_VFS_SYS_ACL_SET_QUALIFIER(conn, entry, qual) ((conn)->vfs.ops.sys_acl_set_qualifier((conn)->vfs.handles.sys_acl_set_qualifier, (entry), (qual))) /* <=== source/include/vfs_macros.h:110:110:SMB_VFS_SYS_ACL_SET_QUALIFIER:3 */ \n- DLIST_REMOVE: #define DLIST_REMOVE(list, p) \\ /* <=== source/include/dlinklist.h:42:52:DLIST_REMOVE:2 */ \ndo { \\\n\tif ((p) == (list)) { \\\n\t\t(list) = (p)->next; \\\n\t\tif (list) (list)->prev = NULL; \\\n\t} else { \\\n\t\tif ((p)->prev) (p)->prev->next = (p)->next; \\\n\t\tif ((p)->next) (p)->next->prev = (p)->prev; \\\n\t} \\\n\tif ((p) != (list)) (p)->next = (p)->prev = NULL; \\\n} while (0)\n- DEBUG: #define DEBUG( level, body ) \\ /* <=== source/include/debug.h:206:212:DEBUG:2 */ \n  (void)( ((level) <= MAX_DEBUG_LEVEL) && \\\n           unlikely((DEBUGLEVEL_CLASS[ DBGC_CLASS ] >= (level))||  \\\n           (!DEBUGLEVEL_CLASS_ISSET[ DBGC_CLASS ] && \\\n            DEBUGLEVEL_CLASS[ DBGC_ALL   ] >= (level))  ) \\\n       && (dbghdr( level, DBGC_CLASS, __FILE__, FUNCTION_MACRO, (__LINE__) )) \\\n       && (dbgtext body) )\n- OWNER_SECURITY_INFORMATION: #define OWNER_SECURITY_INFORMATION\t0x00000001 /* <=== source/include/rpc_secdes.h:56:56:OWNER_SECURITY_INFORMATION:0 */ \n- NT_STATUS_ACCESS_DENIED: #define NT_STATUS_ACCESS_DENIED NT_STATUS(0xC0000000 | 0x0022) /* <=== source/include/nterr.h:96:96:NT_STATUS_ACCESS_DENIED:0 */ \n- SMB_VFS_STAT: #define SMB_VFS_STAT(conn, fname, sbuf) ((conn)->vfs.ops.stat((conn)->vfs.handles.stat, (fname), (sbuf))) /* <=== source/include/vfs_macros.h:61:61:SMB_VFS_STAT:3 */ \n- current_user_in_group: static bool current_user_in_group(gid_t gid) /* <=== current_user_in_group */ \n{\n\tint i;\n\n\tfor (i = 0; i < current_user.ut.ngroups; i++) {\n\t\tif (current_user.ut.groups[i] == gid) {\n\t\t\treturn True;\n\t\t}\n\t}\n\n\treturn False;\n}\n- debug_ctx: TALLOC_CTX *debug_ctx(void) /* <=== debug_ctx */ \n{\n        if (tmp_debug_ctx == NULL) {\n                tmp_debug_ctx = talloc_named_const(NULL, 0, \"debug_ctx\");\n        }\n        return tmp_debug_ctx;\n}\n- num_inherited_entries: static unsigned int num_inherited_entries(canon_ace *ace_list) /* <=== num_inherited_entries */ \n{\n\tunsigned int num_entries = 0;\n\n\tfor (; ace_list; ace_list = ace_list->next)\n\t\tif (ace_list->inherited)\n\t\t\tnum_entries++;\n\treturn num_entries;\n}\n- unpack_nt_owners: NTSTATUS unpack_nt_owners(int snum, uid_t *puser, gid_t *pgrp, uint32 security_info_sent, SEC_DESC *psd) /* <=== unpack_nt_owners */ \n{\n\tDOM_SID owner_sid;\n\tDOM_SID grp_sid;\n\n\t*puser = (uid_t)-1;\n\t*pgrp = (gid_t)-1;\n\n\tif(security_info_sent == 0) {\n\t\tDEBUG(0,(\"unpack_nt_owners: no security info sent !\\n\"));\n\t\treturn NT_STATUS_OK;\n\t}\n\n\t/*\n\t * Validate the owner and group SID's.\n\t */\n\n\tmemset(&owner_sid, '\\0', sizeof(owner_sid));\n\tmemset(&grp_sid, '\\0', sizeof(grp_sid));\n\n\tDEBUG(5,(\"unpack_nt_owners: validating owner_sids.\\n\"));\n\n\t/*\n\t * Don't immediately fail if the owner sid cannot be validated.\n\t * This may be a group chown only set.\n\t */\n\n\tif (security_info_sent & OWNER_SECURITY_INFORMATION) {\n\t\tsid_copy(&owner_sid, psd->owner_sid);\n\t\tif (!sid_to_uid(&owner_sid, puser)) {\n\t\t\tif (lp_force_unknown_acl_user(snum)) {\n\t\t\t\t/* this allows take ownership to work\n\t\t\t\t * reasonably */\n\t\t\t\t*puser = current_user.ut.uid;\n\t\t\t} else {\n\t\t\t\tDEBUG(3,(\"unpack_nt_owners: unable to validate\"\n\t\t\t\t\t \" owner sid for %s\\n\",\n\t\t\t\t\t sid_string_dbg(&owner_sid)));\n\t\t\t\treturn NT_STATUS_INVALID_OWNER;\n\t\t\t}\n\t\t}\n\t\tDEBUG(3,(\"unpack_nt_owners: owner sid mapped to uid %u\\n\",\n\t\t\t (unsigned int)*puser ));\n \t}\n\n\t/*\n\t * Don't immediately fail if the group sid cannot be validated.\n\t * This may be an owner chown only set.\n\t */\n\n\tif (security_info_sent & GROUP_SECURITY_INFORMATION) {\n\t\tsid_copy(&grp_sid, psd->group_sid);\n\t\tif (!sid_to_gid( &grp_sid, pgrp)) {\n\t\t\tif (lp_force_unknown_acl_user(snum)) {\n\t\t\t\t/* this allows take group ownership to work\n\t\t\t\t * reasonably */\n\t\t\t\t*pgrp = current_user.ut.gid;\n\t\t\t} else {\n\t\t\t\tDEBUG(3,(\"unpack_nt_owners: unable to validate\"\n\t\t\t\t\t \" group sid.\\n\"));\n\t\t\t\treturn NT_STATUS_INVALID_OWNER;\n\t\t\t}\n\t\t}\n\t\tDEBUG(3,(\"unpack_nt_owners: group sid mapped to gid %u\\n\",\n\t\t\t (unsigned int)*pgrp));\n \t}\n\n\tDEBUG(5,(\"unpack_nt_owners: owner_sids validated.\\n\"));\n\n\treturn NT_STATUS_OK;\n}\n- DBGC_ALL: #define DBGC_ALL\t\t0 /* index equivalent to DEBUGLEVEL */ /* <=== source/include/debug.h:84:84:DBGC_ALL:0 */ \n- NT_STATUS_INVALID_OWNER: #define NT_STATUS_INVALID_OWNER NT_STATUS(0xC0000000 | 0x005a) /* <=== source/include/nterr.h:152:152:NT_STATUS_INVALID_OWNER:0 */ \n- can_access_file: bool can_access_file(connection_struct *conn, const char *fname, SMB_STRUCT_STAT *psbuf, uint32 access_mask) /* <=== can_access_file */ \n{\n\tif (!(access_mask & (FILE_READ_DATA|FILE_WRITE_DATA))) {\n\t\treturn False;\n\t}\n\taccess_mask &= (FILE_READ_DATA|FILE_WRITE_DATA);\n\n\t/* some fast paths first */\n\n\tDEBUG(10,(\"can_access_file: requesting 0x%x on file %s\\n\",\n\t\t(unsigned int)access_mask, fname ));\n\n\tif (current_user.ut.uid == 0 || conn->admin_user) {\n\t\t/* I'm sorry sir, I didn't know you were root... */\n\t\treturn True;\n\t}\n\n\tif (!VALID_STAT(*psbuf)) {\n\t\t/* Get the file permission mask and owners. */\n\t\tif(SMB_VFS_STAT(conn, fname, psbuf) != 0) {\n\t\t\treturn False;\n\t\t}\n\t}\n\n\t/* Check primary owner access. */\n\tif (current_user.ut.uid == psbuf->st_uid) {\n\t\tswitch (access_mask) {\n\t\t\tcase FILE_READ_DATA:\n\t\t\t\treturn (psbuf->st_mode & S_IRUSR) ? True : False;\n\n\t\t\tcase FILE_WRITE_DATA:\n\t\t\t\treturn (psbuf->st_mode & S_IWUSR) ? True : False;\n\n\t\t\tdefault: /* FILE_READ_DATA|FILE_WRITE_DATA */\n\n\t\t\t\tif ((psbuf->st_mode & (S_IWUSR|S_IRUSR)) == (S_IWUSR|S_IRUSR)) {\n\t\t\t\t\treturn True;\n\t\t\t\t} else {\n\t\t\t\t\treturn False;\n\t\t\t\t}\n\t\t}\n\t}\n\n\t/* now for ACL checks */\n\n\treturn can_access_file_acl(conn, fname, psbuf, access_mask);\n}\n- SMB_VFS_SYS_ACL_SET_FILE: #define SMB_VFS_SYS_ACL_SET_FILE(conn, name, acltype, theacl) ((conn)->vfs.ops.sys_acl_set_file((conn)->vfs.handles.sys_acl_set_file, (name), (acltype), (theacl))) /* <=== source/include/vfs_macros.h:113:113:SMB_VFS_SYS_ACL_SET_FILE:4 */ \n- SMB_VFS_SYS_ACL_CLEAR_PERMS: #define SMB_VFS_SYS_ACL_CLEAR_PERMS(conn, permset) ((conn)->vfs.ops.sys_acl_clear_perms((conn)->vfs.handles.sys_acl_clear_perms, (permset))) /* <=== source/include/vfs_macros.h:104:104:SMB_VFS_SYS_ACL_CLEAR_PERMS:2 */ \n- rep_vasprintf: int rep_vasprintf(char **ptr, const char *format, va_list ap) PRINTF_ATTRIBUTE(2,0); /* <=== rep_vasprintf */ \n- slprintf: #define slprintf snprintf /* <=== source/include/includes.h:1093:1093:slprintf:0 */ \n- can_write_to_file: bool can_write_to_file(connection_struct *conn, const char *fname, SMB_STRUCT_STAT *psbuf) /* <=== can_write_to_file */ \n{\n\treturn can_access_file(conn, fname, psbuf, FILE_WRITE_DATA);\n}\n- false: #define false (0) /* <=== source/lib/replace/replace.h:469:469:false:0 */ \n- SAFE_FREE: #define SAFE_FREE(x) do { if ((x) != NULL) {free(x); x=NULL;} } while(0) /* <=== source/include/smb_macros.h:45:45:SAFE_FREE:1 */ \n- become_root: void become_root(void) /* <=== become_root */ \n{\n\t /*\n\t  * no good way to handle push_sec_ctx() failing without changing\n\t  * the prototype of become_root()\n\t  */\n\tif (!push_sec_ctx()) {\n\t\tsmb_panic(\"become_root: push_sec_ctx failed\");\n\t}\n\tpush_conn_ctx();\n\tset_root_sec_ctx();\n}\n- SMB_VFS_SYS_ACL_SET_FD: #define SMB_VFS_SYS_ACL_SET_FD(fsp, theacl) ((fsp)->conn->vfs.ops.sys_acl_set_fd((fsp)->conn->vfs.handles.sys_acl_set_fd, (fsp), (theacl))) /* <=== source/include/vfs_macros.h:114:114:SMB_VFS_SYS_ACL_SET_FD:2 */ \n- S_IXUSR: #define S_IXUSR 00100           /* execute permission: owner */ /* <=== source/lib/replace/system/filesys.h:143:143:S_IXUSR:0 */ \n- vasprintf: #define vasprintf rep_vasprintf /* <=== source/lib/replace/replace.h:249:249:vasprintf:0 */ \n- process_deny_list: static void process_deny_list( canon_ace **pp_ace_list ) /* <=== process_deny_list */ \n{\n\tcanon_ace *ace_list = *pp_ace_list;\n\tcanon_ace *curr_ace = NULL;\n\tcanon_ace *curr_ace_next = NULL;\n\n\t/* Pass 1 above - look for an Everyone, deny entry. */\n\n\tfor (curr_ace = ace_list; curr_ace; curr_ace = curr_ace_next) {\n\t\tcanon_ace *allow_ace_p;\n\n\t\tcurr_ace_next = curr_ace->next; /* So we can't lose the link. */\n\n\t\tif (curr_ace->attr != DENY_ACE)\n\t\t\tcontinue;\n\n\t\tif (curr_ace->perms == (mode_t)0) {\n\n\t\t\t/* Deny nothing entry - delete. */\n\n\t\t\tDLIST_REMOVE(ace_list, curr_ace);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!sid_equal(&curr_ace->trustee, &global_sid_World))\n\t\t\tcontinue;\n\n\t\t/* JRATEST - assert. */\n\t\tSMB_ASSERT(curr_ace->owner_type == WORLD_ACE);\n\n\t\tif (curr_ace->perms == ALL_ACE_PERMS) {\n\n\t\t\t/*\n\t\t\t * Optimisation. This is a DENY_ALL to Everyone. Truncate the\n\t\t\t * list at this point including this entry.\n\t\t\t */\n\n\t\t\tcanon_ace *prev_entry = curr_ace->prev;\n\n\t\t\tfree_canon_ace_list( curr_ace );\n\t\t\tif (prev_entry)\n\t\t\t\tprev_entry->next = NULL;\n\t\t\telse {\n\t\t\t\t/* We deleted the entire list. */\n\t\t\t\tace_list = NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (allow_ace_p = curr_ace->next; allow_ace_p; allow_ace_p = allow_ace_p->next) {\n\n\t\t\t/* \n\t\t\t * Only mask off allow entries.\n\t\t\t */\n\n\t\t\tif (allow_ace_p->attr != ALLOW_ACE)\n\t\t\t\tcontinue;\n\n\t\t\tallow_ace_p->perms &= ~curr_ace->perms;\n\t\t}\n\n\t\t/*\n\t\t * Now it's been applied, remove it.\n\t\t */\n\n\t\tDLIST_REMOVE(ace_list, curr_ace);\n\t}\n\n\t/* Pass 2 above - deal with deny user entries. */\n\n\tfor (curr_ace = ace_list; curr_ace; curr_ace = curr_ace_next) {\n\t\tmode_t new_perms = (mode_t)0;\n\t\tcanon_ace *allow_ace_p;\n\n\t\tcurr_ace_next = curr_ace->next; /* So we can't lose the link. */\n\n\t\tif (curr_ace->attr != DENY_ACE)\n\t\t\tcontinue;\n\n\t\tif (curr_ace->owner_type != UID_ACE)\n\t\t\tcontinue;\n\n\t\tif (curr_ace->perms == ALL_ACE_PERMS) {\n\n\t\t\t/*\n\t\t\t * Optimisation - this is a deny everything to this user.\n\t\t\t * Convert to an allow nothing and push to the end of the list.\n\t\t\t */\n\n\t\t\tcurr_ace->attr = ALLOW_ACE;\n\t\t\tcurr_ace->perms = (mode_t)0;\n\t\t\tDLIST_DEMOTE(ace_list, curr_ace, canon_ace *);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (allow_ace_p = curr_ace->next; allow_ace_p; allow_ace_p = allow_ace_p->next) {\n\n\t\t\tif (allow_ace_p->attr != ALLOW_ACE)\n\t\t\t\tcontinue;\n\n\t\t\t/* We process GID_ACE and WORLD_ACE entries only. */\n\n\t\t\tif (allow_ace_p->owner_type == UID_ACE)\n\t\t\t\tcontinue;\n\n\t\t\tif (uid_entry_in_group( curr_ace, allow_ace_p))\n\t\t\t\tnew_perms |= allow_ace_p->perms;\n\t\t}\n\n\t\t/*\n\t\t * Convert to a allow entry, modify the perms and push to the end\n\t\t * of the list.\n\t\t */\n\n\t\tcurr_ace->attr = ALLOW_ACE;\n\t\tcurr_ace->perms = (new_perms & ~curr_ace->perms);\n\t\tDLIST_DEMOTE(ace_list, curr_ace, canon_ace *);\n\t}\n\n\t/* Pass 3 above - deal with deny group entries. */\n\n\tfor (curr_ace = ace_list; curr_ace; curr_ace = curr_ace_next) {\n\t\tcanon_ace *allow_ace_p;\n\t\tcanon_ace *allow_everyone_p = NULL;\n\n\t\tcurr_ace_next = curr_ace->next; /* So we can't lose the link. */\n\n\t\tif (curr_ace->attr != DENY_ACE)\n\t\t\tcontinue;\n\n\t\tif (curr_ace->owner_type != GID_ACE)\n\t\t\tcontinue;\n\n\t\tfor (allow_ace_p = curr_ace->next; allow_ace_p; allow_ace_p = allow_ace_p->next) {\n\n\t\t\tif (allow_ace_p->attr != ALLOW_ACE)\n\t\t\t\tcontinue;\n\n\t\t\t/* Store a pointer to the Everyone allow, if it exists. */\n\t\t\tif (allow_ace_p->owner_type == WORLD_ACE)\n\t\t\t\tallow_everyone_p = allow_ace_p;\n\n\t\t\t/* We process UID_ACE entries only. */\n\n\t\t\tif (allow_ace_p->owner_type != UID_ACE)\n\t\t\t\tcontinue;\n\n\t\t\t/* Mask off the deny group perms. */\n\n\t\t\tif (uid_entry_in_group( allow_ace_p, curr_ace))\n\t\t\t\tallow_ace_p->perms &= ~curr_ace->perms;\n\t\t}\n\n\t\t/*\n\t\t * Convert the deny to an allow with the correct perms and\n\t\t * push to the end of the list.\n\t\t */\n\n\t\tcurr_ace->attr = ALLOW_ACE;\n\t\tif (allow_everyone_p)\n\t\t\tcurr_ace->perms = allow_everyone_p->perms & ~curr_ace->perms;\n\t\telse\n\t\t\tcurr_ace->perms = (mode_t)0;\n\t\tDLIST_DEMOTE(ace_list, curr_ace, canon_ace *);\n\t}\n\n\t/* Doing this fourth pass allows Windows semantics to be layered\n\t * on top of POSIX semantics. I'm not sure if this is desirable.\n\t * For example, in W2K ACLs there is no way to say, \"Group X no\n\t * access, user Y full access\" if user Y is a member of group X.\n\t * This seems completely broken semantics to me.... JRA.\n\t */\n\n#if 0\n\t/* Pass 4 above - deal with allow entries. */\n\n\tfor (curr_ace = ace_list; curr_ace; curr_ace = curr_ace_next) {\n\t\tcanon_ace *allow_ace_p;\n\n\t\tcurr_ace_next = curr_ace->next; /* So we can't lose the link. */\n\n\t\tif (curr_ace->attr != ALLOW_ACE)\n\t\t\tcontinue;\n\n\t\tif (curr_ace->owner_type != UID_ACE)\n\t\t\tcontinue;\n\n\t\tfor (allow_ace_p = ace_list; allow_ace_p; allow_ace_p = allow_ace_p->next) {\n\n\t\t\tif (allow_ace_p->attr != ALLOW_ACE)\n\t\t\t\tcontinue;\n\n\t\t\t/* We process GID_ACE entries only. */\n\n\t\t\tif (allow_ace_p->owner_type != GID_ACE)\n\t\t\t\tcontinue;\n\n\t\t\t/* OR in the group perms. */\n\n\t\t\tif (uid_entry_in_group( curr_ace, allow_ace_p))\n\t\t\t\tcurr_ace->perms |= allow_ace_p->perms;\n\t\t}\n\t}\n#endif\n\n\t*pp_ace_list = ace_list;\n}\n- SMB_ACL_TYPE_DEFAULT: #define SMB_ACL_TYPE_DEFAULT\t\t1 /* <=== source/include/smb_acls.h:63:63:SMB_ACL_TYPE_DEFAULT:0 */ \n- smb_panic: void smb_panic( const char *why ) NORETURN_ATTRIBUTE ; /* <=== smb_panic */ \n- GROUP_SECURITY_INFORMATION: #define GROUP_SECURITY_INFORMATION\t0x00000002 /* <=== source/include/rpc_secdes.h:57:57:GROUP_SECURITY_INFORMATION:0 */ \n- print_canon_ace_list: static void print_canon_ace_list(const char *name, canon_ace *ace_list) /* <=== print_canon_ace_list */ \n{\n\tint count = 0;\n\n\tif( DEBUGLVL( 10 )) {\n\t\tdbgtext( \"print_canon_ace_list: %s\\n\", name );\n\t\tfor (;ace_list; ace_list = ace_list->next, count++)\n\t\t\tprint_canon_ace(ace_list, count );\n\t}\n}\n- SMB_VFS_SYS_ACL_INIT: #define SMB_VFS_SYS_ACL_INIT(conn, count) ((conn)->vfs.ops.sys_acl_init((conn)->vfs.handles.sys_acl_init, (count))) /* <=== source/include/vfs_macros.h:107:107:SMB_VFS_SYS_ACL_INIT:2 */ \n\nType Definitions:\n- canon_ace: typedef struct canon_ace {\n\tstruct canon_ace *next, *prev;\n\tSMB_ACL_TAG_T type;\n\tmode_t perms; /* Only use S_I(R|W|X)USR mode bits here. */\n\tDOM_SID trustee;\n\tenum ace_owner owner_type;\n\tenum ace_attribute attr;\n\tposix_id unix_ug;\n\tbool inherited;\n}\n- SEC_DESC: typedef struct security_descriptor SEC_DESC;\n- connection_struct: typedef struct connection_struct {\n\tstruct connection_struct *next, *prev;\n\tTALLOC_CTX *mem_ctx; /* long-lived memory context for things hanging off this struct. */\n\tunsigned cnum; /* an index passed over the wire */\n\tstruct share_params *params;\n\tbool force_user;\n\tbool force_group;\n\tstruct vuid_cache vuid_cache;\n\tstruct dptr_struct *dirptr;\n\tbool printer;\n\tbool ipc;\n\tbool read_only; /* Attributes for the current user of the share. */\n\tbool admin_user; /* Attributes for the current user of the share. */\n\tchar *dirpath;\n\tchar *connectpath;\n\tchar *origpath;\n\n\tstruct vfs_ops vfs;                   /* Filesystem operations */\n\tstruct vfs_ops vfs_opaque;\t\t\t/* OPAQUE Filesystem operations */\n\tstruct vfs_handle_struct *vfs_handles;\t\t/* for the new plugins */\n\n\tchar *user; /* name of user who *opened* this connection */\n\tuid_t uid; /* uid of user who *opened* this connection */\n\tgid_t gid; /* gid of user who *opened* this connection */\n\tchar client_address[INET6_ADDRSTRLEN]; /* String version of client IP address. */\n\n\tuint16 vuid; /* vuid of user who *opened* this connection, or UID_FIELD_INVALID */\n\n\t/* following groups stuff added by ih */\n\n\t/* This groups info is valid for the user that *opened* the connection */\n\tsize_t ngroups;\n\tgid_t *groups;\n\tNT_USER_TOKEN *nt_user_token;\n\t\n\ttime_t lastused;\n\ttime_t lastused_count;\n\tbool used;\n\tint num_files_open;\n\tunsigned int num_smb_operations; /* Count of smb operations on this tree. */\n\tint encrypt_level;\n\tbool encrypted_tid;\n\n\t/* Semantics requested by the client or forced by the server config. */\n\tbool case_sensitive;\n\tbool case_preserve;\n\tbool short_case_preserve;\n\n\t/* Semantics provided by the underlying filesystem. */\n\tint fs_capabilities;\n\n\tname_compare_entry *hide_list; /* Per-share list of files to return as hidden. */\n\tname_compare_entry *veto_list; /* Per-share list of files to veto (never show). */\n\tname_compare_entry *veto_oplock_list; /* Per-share list of files to refuse oplocks on. */       \n\tname_compare_entry *aio_write_behind_list; /* Per-share list of files to use aio write behind on. */       \n\tstruct dfree_cached_info *dfree_info;\n\tstruct trans_state *pending_trans;\n\tstruct notify_context *notify_ctx;\n}\n- bool: typedef int bool;\n- NTSTATUS: typedef uint32 NTSTATUS;\n- DOM_SID: typedef struct dom_sid {\n\tuint8  sid_rev_num;             /**< SID revision number */\n\tuint8  num_auths;               /**< Number of sub-authorities */\n\tuint8  id_auth[6];              /**< Identifier Authority */\n\t/*\n\t *  Pointer to sub-authorities.\n\t *\n\t * @note The values in these uint32's are in *native* byteorder, not\n\t * neccessarily little-endian...... JRA.\n\t */\n\tuint32 sub_auths[MAXSUBAUTHS];  \n} DOM_SID;\n- files_struct: struct files_struct\n- files_struct: typedef struct files_struct {\n\tstruct files_struct *next, *prev;\n\tint fnum;\n\tstruct connection_struct *conn;\n\tstruct fd_handle *fh;\n\tunsigned int num_smb_operations;\n\tuint16 rap_print_jobid;\n\tstruct file_id file_id;\n\tSMB_BIG_UINT initial_allocation_size; /* Faked up initial allocation on disk. */\n\tmode_t mode;\n\tuint16 file_pid;\n\tuint16 vuid;\n\twrite_cache *wcp;\n\tstruct timeval open_time;\n\tuint32 access_mask;\t\t/* NTCreateX access bits (FILE_READ_DATA etc.) */\n\tuint32 share_access;\t\t/* NTCreateX share constants (FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE). */\n\n\tbool update_write_time_triggered;\n\tstruct timed_event *update_write_time_event;\n\tbool update_write_time_on_close;\n\tstruct timespec close_write_time;\n\tbool write_time_forced;\n\n\tint oplock_type;\n\tint sent_oplock_break;\n\tstruct timed_event *oplock_timeout;\n\tstruct lock_struct last_lock_failure;\n\tint current_lock_count; /* Count the number of outstanding locks and pending locks. */\n\n\tstruct share_mode_entry *pending_break_messages;\n\tint num_pending_break_messages;\n\n\tbool can_lock;\n\tbool can_read;\n\tbool can_write;\n\tbool print_file;\n\tbool modified;\n\tbool is_directory;\n\tbool is_stat;\n\tbool aio_write_behind;\n\tbool lockdb_clean;\n\tbool initial_delete_on_close; /* Only set at NTCreateX if file was created. */\n\tbool posix_open;\n\tchar *fsp_name;\n\n\tstruct vfs_fsp_data *vfs_extension;\n \tFAKE_FILE_HANDLE *fake_file_handle;\n\n\tstruct notify_change_buf *notify;\n\n\tstruct files_struct *base_fsp; /* placeholder for delete on close */\n}\n- connection_struct: struct connection_struct\n- canon_ace: typedef struct canon_ace {\n\tstruct canon_ace *next, *prev;\n\tSMB_ACL_TAG_T type;\n\tmode_t perms; /* Only use S_I(R|W|X)USR mode bits here. */\n\tDOM_SID trustee;\n\tenum ace_owner owner_type;\n\tenum ace_attribute attr;\n\tposix_id unix_ug;\n\tbool inherited;\n} canon_ace;\n\nImports:\n- #include \"includes.h\"",
    "commit_msg": "Bug 6488: acl_group_override() call in posix acls references an uninitialized variable.\n(cherry picked from commit f92195e3a1baaddda47a5d496f9488c8445b41ad)",
    "cve_desc": "The acl_group_override function in smbd/posix_acls.c in smbd in Samba 3.0.x before 3.0.35, 3.1.x and 3.2.x before 3.2.13, and 3.3.x before 3.3.6, when dos filemode is enabled, allows remote attackers to modify access control lists for files via vectors related to read access to uninitialized memory.",
    "year": 2009,
    "filename": "posix_acls.c",
    "commit_url": "\"https://github.com/samba-team/samba/commit/d6c28913f3109d1327a3d1369b6eafd3874b2dca\""
  },
  {
    "repository": "GNOME/gimp",
    "cve_id": "CVE-2009-3909",
    "cwe_list": [
      "CWE-190"
    ],
    "commit_hash": "88eccea84aa375197cc04a2a0e2e29debb56bfa5",
    "short_hash": "88eccea8",
    "vulnerableMethods_before": [
      {
        "filename": "plug-ins/file-psd/psd-load.c",
        "method_name": "read_header_block",
        "raw_code": "static gint /* <=== read_header_block */ \nread_header_block (PSDimage  *img_a,\n                   FILE      *f,\n                   GError   **error)\n{\n  guint16  version;\n  gchar    sig[4];\n  gchar    buf[6];\n\n  if (fread (sig, 4, 1, f) < 1\n      || fread (&version, 2, 1, f) < 1\n      || fread (buf, 6, 1, f) < 1\n      || fread (&img_a->channels, 2, 1, f) < 1\n      || fread (&img_a->rows, 4, 1, f) < 1\n      || fread (&img_a->columns, 4, 1, f) < 1\n      || fread (&img_a->bps, 2, 1, f) < 1\n      || fread (&img_a->color_mode, 2, 1, f) < 1)\n    {\n      psd_set_error (feof (f), errno, error);\n      return -1;\n    }\n  version = GUINT16_FROM_BE (version);\n  img_a->channels = GUINT16_FROM_BE (img_a->channels);\n  img_a->rows = GUINT32_FROM_BE (img_a->rows);\n  img_a->columns = GUINT32_FROM_BE (img_a->columns);\n  img_a->bps = GUINT16_FROM_BE (img_a->bps);\n  img_a->color_mode = GUINT16_FROM_BE (img_a->color_mode);\n\n  IFDBG(1) g_debug (\"\\n\\n\\tSig: %.4s\\n\\tVer: %d\\n\\tChannels: \"\n                    \"%d\\n\\tSize: %dx%d\\n\\tBPS: %d\\n\\tMode: %d\\n\",\n                    sig, version, img_a->channels,\n                    img_a->columns, img_a->rows,\n                    img_a->bps, img_a->color_mode);\n\n  if (memcmp (sig, \"8BPS\", 4) != 0)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                  _(\"Not a valid photoshop document file\"));\n      return -1;\n    }\n\n  if (version != 1)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                  _(\"Unsupported file format version: %d\"), version);\n      return -1;\n    }\n\n  if (img_a->channels > MAX_CHANNELS)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                  _(\"Too many channels in file: %d\"), img_a->channels);\n      return -1;\n    }\n\n    /* Photoshop CS (version 8) supports 300000 x 300000, but this\n       is currently larger than GIMP_MAX_IMAGE_SIZE */\n\n  if (img_a->rows < 1 || img_a->rows > GIMP_MAX_IMAGE_SIZE)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                  _(\"Unsupported or invalid image height: %d\"),\n                  img_a->rows);\n      return -1;\n    }\n\n  if (img_a->columns < 1 || img_a->columns > GIMP_MAX_IMAGE_SIZE)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                  _(\"Unsupported or invalid image width: %d\"),\n                  img_a->columns);\n      return -1;\n    }\n\n  if (img_a->color_mode != PSD_BITMAP\n      && img_a->color_mode != PSD_GRAYSCALE\n      && img_a->color_mode != PSD_INDEXED\n      && img_a->color_mode != PSD_RGB\n      && img_a->color_mode != PSD_DUOTONE)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"Unsupported color mode: %s\"),\n                   get_psd_color_mode_name (img_a->color_mode));\n      return -1;\n    }\n\n  /* Warnings for format conversions */\n  switch (img_a->bps)\n    {\n      case 16:\n        IFDBG(3) g_debug (\"16 Bit Data\");\n        if (CONVERSION_WARNINGS)\n          g_message (_(\"Warning:\\n\"\n                       \"The image you are loading has 16 bits per channel. GIMP \"\n                       \"can only handle 8 bit, so it will be converted for you. \"\n                       \"Information will be lost because of this conversion.\"));\n        break;\n\n      case 8:\n        IFDBG(3) g_debug (\"8 Bit Data\");\n        break;\n\n      case 1:\n        IFDBG(3) g_debug (\"1 Bit Data\");\n        break;\n\n      default:\n        g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                    _(\"Unsupported bit depth: %d\"), img_a->bps);\n        return -1;\n        break;\n    }\n\n  return 0;\n}",
        "start_line": 233
      },
      {
        "filename": "plug-ins/file-psd/psd-load.c",
        "method_name": "read_layer_block",
        "raw_code": "static PSDlayer ** /* <=== read_layer_block */ \nread_layer_block (PSDimage  *img_a,\n                  FILE      *f,\n                  GError   **error)\n{\n  PSDlayer **lyr_a;\n  guint32    block_len;\n  guint32    block_end;\n  guint32    block_rem;\n  gint32     read_len;\n  gint32     write_len;\n  gint       lidx;                  /* Layer index */\n  gint       cidx;                  /* Channel index */\n\n  if (fread (&block_len, 4, 1, f) < 1)\n    {\n      psd_set_error (feof (f), errno, error);\n      img_a->num_layers = -1;\n      return NULL;\n    }\n  img_a->mask_layer_len = GUINT32_FROM_BE (block_len);\n\n  IFDBG(1) g_debug (\"Layer and mask block size = %d\", img_a->mask_layer_len);\n\n  img_a->transparency = FALSE;\n  img_a->layer_data_len = 0;\n\n  if (!img_a->mask_layer_len)\n    {\n      img_a->num_layers = 0;\n      return NULL;\n    }\n  else\n    {\n      img_a->mask_layer_start = ftell (f);\n      block_end = img_a->mask_layer_start + img_a->mask_layer_len;\n\n      /* Get number of layers */\n      if (fread (&block_len, 4, 1, f) < 1\n          || fread (&img_a->num_layers, 2, 1, f) < 1)\n        {\n          psd_set_error (feof (f), errno, error);\n          img_a->num_layers = -1;\n          return NULL;\n        }\n      img_a->num_layers = GINT16_FROM_BE (img_a->num_layers);\n      IFDBG(2) g_debug (\"Number of layers: %d\", img_a->num_layers);\n\n      if (img_a->num_layers < 0)\n        {\n          img_a->transparency = TRUE;\n          img_a->num_layers = -img_a->num_layers;\n        }\n\n      if (img_a->num_layers)\n        {\n          /* Read layer records */\n          PSDlayerres           res_a;\n\n          /* Create pointer array for the layer records */\n          lyr_a = g_new (PSDlayer *, img_a->num_layers);\n          for (lidx = 0; lidx < img_a->num_layers; ++lidx)\n            {\n              /* Allocate layer record */\n              lyr_a[lidx] = (PSDlayer *) g_malloc (sizeof (PSDlayer) );\n\n              /* Initialise record */\n              lyr_a[lidx]->drop = FALSE;\n              lyr_a[lidx]->id = 0;\n\n              if (fread (&lyr_a[lidx]->top, 4, 1, f) < 1\n                  || fread (&lyr_a[lidx]->left, 4, 1, f) < 1\n                  || fread (&lyr_a[lidx]->bottom, 4, 1, f) < 1\n                  || fread (&lyr_a[lidx]->right, 4, 1, f) < 1\n                  || fread (&lyr_a[lidx]->num_channels, 2, 1, f) < 1)\n                {\n                  psd_set_error (feof (f), errno, error);\n                  return NULL;\n                }\n              lyr_a[lidx]->top = GINT32_FROM_BE (lyr_a[lidx]->top);\n              lyr_a[lidx]->left = GINT32_FROM_BE (lyr_a[lidx]->left);\n              lyr_a[lidx]->bottom = GINT32_FROM_BE (lyr_a[lidx]->bottom);\n              lyr_a[lidx]->right = GINT32_FROM_BE (lyr_a[lidx]->right);\n              lyr_a[lidx]->num_channels = GUINT16_FROM_BE (lyr_a[lidx]->num_channels);\n\n              if (lyr_a[lidx]->num_channels > MAX_CHANNELS)\n                {\n                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                              _(\"Too many channels in layer: %d\"),\n                              lyr_a[lidx]->num_channels);\n                  return NULL;\n                }\n              if (lyr_a[lidx]->bottom - lyr_a[lidx]->top > GIMP_MAX_IMAGE_SIZE)\n                {\n                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                              _(\"Unsupported or invalid layer height: %d\"),\n                              lyr_a[lidx]->bottom - lyr_a[lidx]->top);\n                  return NULL;\n                }\n              if (lyr_a[lidx]->right - lyr_a[lidx]->left > GIMP_MAX_IMAGE_SIZE)\n                {\n                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                              _(\"Unsupported or invalid layer width: %d\"),\n                              lyr_a[lidx]->right - lyr_a[lidx]->left);\n                  return NULL;\n                }\n\n              IFDBG(2) g_debug (\"Layer %d, Coords %d %d %d %d, channels %d, \",\n                                 lidx, lyr_a[lidx]->left, lyr_a[lidx]->top,\n                                 lyr_a[lidx]->right, lyr_a[lidx]->bottom,\n                                 lyr_a[lidx]->num_channels);\n\n              lyr_a[lidx]->chn_info = g_new (ChannelLengthInfo, lyr_a[lidx]->num_channels);\n              for (cidx = 0; cidx < lyr_a[lidx]->num_channels; ++cidx)\n                {\n                  if (fread (&lyr_a[lidx]->chn_info[cidx].channel_id, 2, 1, f) < 1\n                      || fread (&lyr_a[lidx]->chn_info[cidx].data_len, 4, 1, f) < 1)\n                    {\n                      psd_set_error (feof (f), errno, error);\n                      return NULL;\n                    }\n                  lyr_a[lidx]->chn_info[cidx].channel_id =\n                    GINT16_FROM_BE (lyr_a[lidx]->chn_info[cidx].channel_id);\n                  lyr_a[lidx]->chn_info[cidx].data_len =\n                    GUINT32_FROM_BE (lyr_a[lidx]->chn_info[cidx].data_len);\n                  img_a->layer_data_len += lyr_a[lidx]->chn_info[cidx].data_len;\n                  IFDBG(3) g_debug (\"Channel ID %d, data len %d\",\n                                     lyr_a[lidx]->chn_info[cidx].channel_id,\n                                     lyr_a[lidx]->chn_info[cidx].data_len);\n                }\n\n              if (fread (lyr_a[lidx]->mode_key, 4, 1, f) < 1\n                  || fread (lyr_a[lidx]->blend_mode, 4, 1, f) < 1\n                  || fread (&lyr_a[lidx]->opacity, 1, 1, f) < 1\n                  || fread (&lyr_a[lidx]->clipping, 1, 1, f) < 1\n                  || fread (&lyr_a[lidx]->flags, 1, 1, f) < 1\n                  || fread (&lyr_a[lidx]->filler, 1, 1, f) < 1\n                  || fread (&lyr_a[lidx]->extra_len, 4, 1, f) < 1)\n                {\n                  psd_set_error (feof (f), errno, error);\n                  return NULL;\n                }\n              if (memcmp (lyr_a[lidx]->mode_key, \"8BIM\", 4) != 0)\n                {\n                  IFDBG(1) g_debug (\"Incorrect layer mode signature %.4s\",\n                                    lyr_a[lidx]->mode_key);\n                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                              _(\"The file is corrupt!\"));\n                  return NULL;\n                }\n\n              lyr_a[lidx]->layer_flags.trans_prot = lyr_a[lidx]->flags & 1 ? TRUE : FALSE;\n              lyr_a[lidx]->layer_flags.visible = lyr_a[lidx]->flags & 2 ? FALSE : TRUE;\n              if (lyr_a[lidx]->flags & 8)\n                lyr_a[lidx]->layer_flags.irrelevant = lyr_a[lidx]->flags & 16 ? TRUE : FALSE;\n              else\n                lyr_a[lidx]->layer_flags.irrelevant = FALSE;\n\n              lyr_a[lidx]->extra_len = GUINT32_FROM_BE (lyr_a[lidx]->extra_len);\n              block_rem = lyr_a[lidx]->extra_len;\n              IFDBG(2) g_debug (\"\\n\\tLayer mode sig: %.4s\\n\\tBlend mode: %.4s\\n\\t\"\n                                \"Opacity: %d\\n\\tClipping: %d\\n\\tExtra data len: %d\\n\\t\"\n                                \"Alpha lock: %d\\n\\tVisible: %d\\n\\tIrrelevant: %d\",\n                                    lyr_a[lidx]->mode_key,\n                                    lyr_a[lidx]->blend_mode,\n                                    lyr_a[lidx]->opacity,\n                                    lyr_a[lidx]->clipping,\n                                    lyr_a[lidx]->extra_len,\n                                    lyr_a[lidx]->layer_flags.trans_prot,\n                                    lyr_a[lidx]->layer_flags.visible,\n                                    lyr_a[lidx]->layer_flags.irrelevant);\n              IFDBG(3) g_debug (\"Remaining length %d\", block_rem);\n\n              /* Layer mask data */\n              if (fread (&block_len, 4, 1, f) < 1)\n                {\n                  psd_set_error (feof (f), errno, error);\n                  return NULL;\n                }\n              block_len = GUINT32_FROM_BE (block_len);\n              block_rem -= (block_len + 4);\n              IFDBG(3) g_debug (\"Remaining length %d\", block_rem);\n\n              lyr_a[lidx]->layer_mask_extra.top = 0;\n              lyr_a[lidx]->layer_mask_extra.left = 0;\n              lyr_a[lidx]->layer_mask_extra.bottom = 0;\n              lyr_a[lidx]->layer_mask_extra.right = 0;\n              lyr_a[lidx]->layer_mask.top = 0;\n              lyr_a[lidx]->layer_mask.left = 0;\n              lyr_a[lidx]->layer_mask.bottom = 0;\n              lyr_a[lidx]->layer_mask.right = 0;\n              lyr_a[lidx]->layer_mask.def_color = 0;\n              lyr_a[lidx]->layer_mask.extra_def_color = 0;\n              lyr_a[lidx]->layer_mask.mask_flags.relative_pos = FALSE;\n              lyr_a[lidx]->layer_mask.mask_flags.disabled = FALSE;\n              lyr_a[lidx]->layer_mask.mask_flags.invert = FALSE;\n\n              switch (block_len)\n                {\n                  case 0:\n                    break;\n\n                  case 20:\n                    if (fread (&lyr_a[lidx]->layer_mask.top, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.left, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.bottom, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.right, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.def_color, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.flags, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.extra_def_color, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.extra_flags, 1, 1, f) < 1)\n                      {\n                        psd_set_error (feof (f), errno, error);\n                        return NULL;\n                      }\n                    lyr_a[lidx]->layer_mask.top =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.top);\n                    lyr_a[lidx]->layer_mask.left =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.left);\n                    lyr_a[lidx]->layer_mask.bottom =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.bottom);\n                    lyr_a[lidx]->layer_mask.right =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.right);\n                    lyr_a[lidx]->layer_mask.mask_flags.relative_pos =\n                      lyr_a[lidx]->layer_mask.flags & 1 ? TRUE : FALSE;\n                    lyr_a[lidx]->layer_mask.mask_flags.disabled =\n                      lyr_a[lidx]->layer_mask.flags & 2 ? TRUE : FALSE;\n                    lyr_a[lidx]->layer_mask.mask_flags.invert =\n                      lyr_a[lidx]->layer_mask.flags & 4 ? TRUE : FALSE;\n                    break;\n                  case 36: /* If we have a 36 byte mask record assume second data set is correct */\n                    if (fread (&lyr_a[lidx]->layer_mask_extra.top, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask_extra.left, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask_extra.bottom, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask_extra.right, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.extra_def_color, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.extra_flags, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.def_color, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.flags, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.top, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.left, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.bottom, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.right, 4, 1, f) < 1)\n                      {\n                        psd_set_error (feof (f), errno, error);\n                        return NULL;\n                      }\n                    lyr_a[lidx]->layer_mask_extra.top =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask_extra.top);\n                    lyr_a[lidx]->layer_mask_extra.left =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask_extra.left);\n                    lyr_a[lidx]->layer_mask_extra.bottom =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask_extra.bottom);\n                    lyr_a[lidx]->layer_mask_extra.right =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask_extra.right);\n                    lyr_a[lidx]->layer_mask.top =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.top);\n                    lyr_a[lidx]->layer_mask.left =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.left);\n                    lyr_a[lidx]->layer_mask.bottom =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.bottom);\n                    lyr_a[lidx]->layer_mask.right =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.right);\n                    lyr_a[lidx]->layer_mask.mask_flags.relative_pos =\n                      lyr_a[lidx]->layer_mask.flags & 1 ? TRUE : FALSE;\n                    lyr_a[lidx]->layer_mask.mask_flags.disabled =\n                      lyr_a[lidx]->layer_mask.flags & 2 ? TRUE : FALSE;\n                    lyr_a[lidx]->layer_mask.mask_flags.invert =\n                      lyr_a[lidx]->layer_mask.flags & 4 ? TRUE : FALSE;\n                    break;\n\n                  default:\n                    IFDBG(1) g_debug (\"Unknown layer mask record size ... skipping\");\n                    if (fseek (f, block_len, SEEK_CUR) < 0)\n                      {\n                        psd_set_error (feof (f), errno, error);\n                        return NULL;\n                      }\n                }\n\n              IFDBG(2) g_debug (\"Layer mask coords %d %d %d %d, Rel pos %d\",\n                                lyr_a[lidx]->layer_mask.left,\n                                lyr_a[lidx]->layer_mask.top,\n                                lyr_a[lidx]->layer_mask.right,\n                                lyr_a[lidx]->layer_mask.bottom,\n                                lyr_a[lidx]->layer_mask.mask_flags.relative_pos);\n\n              IFDBG(3) g_debug (\"Default mask color, %d, %d\",\n                                lyr_a[lidx]->layer_mask.def_color,\n                                lyr_a[lidx]->layer_mask.extra_def_color);\n\n              /* Layer blending ranges */           /* FIXME  */\n              if (fread (&block_len, 4, 1, f) < 1)\n                {\n                  psd_set_error (feof (f), errno, error);\n                  return NULL;\n                }\n              block_len = GUINT32_FROM_BE (block_len);\n              block_rem -= (block_len + 4);\n              IFDBG(3) g_debug (\"Remaining length %d\", block_rem);\n              if (block_len > 0)\n                {\n                  if (fseek (f, block_len, SEEK_CUR) < 0)\n                    {\n                      psd_set_error (feof (f), errno, error);\n                      return NULL;\n                    }\n                }\n\n              lyr_a[lidx]->name = fread_pascal_string (&read_len, &write_len,\n                                                       4, f, error);\n              if (*error)\n                return NULL;\n              block_rem -= read_len;\n              IFDBG(3) g_debug (\"Remaining length %d\", block_rem);\n\n              /* Adjustment layer info */           /* FIXME */\n\n              while (block_rem > 7)\n                {\n                  if (get_layer_resource_header (&res_a, f, error) < 0)\n                    return NULL;\n                  block_rem -= 12;\n\n                  if (res_a.data_len > block_rem)\n                    {\n                      IFDBG(1) g_debug (\"Unexpected end of layer resource data\");\n                      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                                  _(\"The file is corrupt!\"));\n                      return NULL;\n                    }\n\n                  if (load_layer_resource (&res_a, lyr_a[lidx], f, error) < 0)\n                    return NULL;\n                  block_rem -= res_a.data_len;\n                }\n              if (block_rem > 0)\n                {\n                  if (fseek (f, block_rem, SEEK_CUR) < 0)\n                    {\n                      psd_set_error (feof (f), errno, error);\n                      return NULL;\n                    }\n                }\n            }\n\n          img_a->layer_data_start = ftell(f);\n          if (fseek (f, img_a->layer_data_len, SEEK_CUR) < 0)\n            {\n              psd_set_error (feof (f), errno, error);\n              return NULL;\n            }\n\n          IFDBG(1) g_debug (\"Layer image data block size %d\",\n                             img_a->layer_data_len);\n        }\n      else\n        lyr_a = NULL;\n\n      /* Read global layer mask record */       /* FIXME */\n\n      /* Skip to end of block */\n      if (fseek (f, block_end, SEEK_SET) < 0)\n        {\n          psd_set_error (feof (f), errno, error);\n          return NULL;\n        }\n    }\n\n  return lyr_a;\n}",
        "start_line": 457
      },
      {
        "filename": "plug-ins/file-psd/psd-load.c",
        "method_name": "add_layers",
        "raw_code": "static gint /* <=== add_layers */ \nadd_layers (const gint32  image_id,\n            PSDimage     *img_a,\n            PSDlayer    **lyr_a,\n            FILE         *f,\n            GError      **error)\n{\n  PSDchannel          **lyr_chn;\n  guchar               *pixels;\n  guint16               alpha_chn;\n  guint16               user_mask_chn;\n  guint16               layer_channels;\n  guint16               channel_idx[MAX_CHANNELS];\n  guint16              *rle_pack_len;\n  gint32                l_x;                   /* Layer x */\n  gint32                l_y;                   /* Layer y */\n  gint32                l_w;                   /* Layer width */\n  gint32                l_h;                   /* Layer height */\n  gint32                lm_x;                  /* Layer mask x */\n  gint32                lm_y;                  /* Layer mask y */\n  gint32                lm_w;                  /* Layer mask width */\n  gint32                lm_h;                  /* Layer mask height */\n  gint32                layer_size;\n  gint32                layer_id = -1;\n  gint32                mask_id = -1;\n  gint                  lidx;                  /* Layer index */\n  gint                  cidx;                  /* Channel index */\n  gint                  rowi;                  /* Row index */\n  gint                  coli;                  /* Column index */\n  gint                  i;\n  gboolean              alpha;\n  gboolean              user_mask;\n  gboolean              empty;\n  gboolean              empty_mask;\n  GimpDrawable         *drawable;\n  GimpPixelRgn          pixel_rgn;\n  GimpImageType         image_type;\n  GimpLayerModeEffects  layer_mode;\n\n\n  IFDBG(2) g_debug (\"Number of layers: %d\", img_a->num_layers);\n\n  if (img_a->num_layers == 0)\n    {\n      IFDBG(2) g_debug (\"No layers to process\");\n      return 0;\n    }\n\n  /* Layered image - Photoshop 3 style */\n  if (fseek (f, img_a->layer_data_start, SEEK_SET) < 0)\n    {\n      psd_set_error (feof (f), errno, error);\n      return -1;\n    }\n\n  for (lidx = 0; lidx < img_a->num_layers; ++lidx)\n    {\n      IFDBG(2) g_debug (\"Process Layer No %d.\", lidx);\n\n      if (lyr_a[lidx]->drop)\n        {\n          IFDBG(2) g_debug (\"Drop layer %d\", lidx);\n\n          /* Step past layer data */\n          for (cidx = 0; cidx < lyr_a[lidx]->num_channels; ++cidx)\n            {\n              if (fseek (f, lyr_a[lidx]->chn_info[cidx].data_len, SEEK_CUR) < 0)\n                {\n                  psd_set_error (feof (f), errno, error);\n                  return -1;\n                }\n            }\n          g_free (lyr_a[lidx]->chn_info);\n          g_free (lyr_a[lidx]->name);\n        }\n\n      else\n        {\n          /* Empty layer */\n          if (lyr_a[lidx]->bottom - lyr_a[lidx]->top == 0\n              || lyr_a[lidx]->right - lyr_a[lidx]->left == 0)\n              empty = TRUE;\n          else\n              empty = FALSE;\n\n          /* Empty mask */\n          if (lyr_a[lidx]->layer_mask.bottom - lyr_a[lidx]->layer_mask.top == 0\n              || lyr_a[lidx]->layer_mask.right - lyr_a[lidx]->layer_mask.left == 0)\n              empty_mask = TRUE;\n          else\n              empty_mask = FALSE;\n\n          IFDBG(3) g_debug (\"Empty mask %d, size %d %d\", empty_mask,\n                            lyr_a[lidx]->layer_mask.bottom - lyr_a[lidx]->layer_mask.top,\n                            lyr_a[lidx]->layer_mask.right - lyr_a[lidx]->layer_mask.left);\n\n          /* Load layer channel data */\n          IFDBG(2) g_debug (\"Number of channels: %d\", lyr_a[lidx]->num_channels);\n          /* Create pointer array for the channel records */\n          lyr_chn = g_new (PSDchannel *, lyr_a[lidx]->num_channels);\n          for (cidx = 0; cidx < lyr_a[lidx]->num_channels; ++cidx)\n            {\n              guint16 comp_mode = PSD_COMP_RAW;\n\n              /* Allocate channel record */\n              lyr_chn[cidx] = g_malloc (sizeof (PSDchannel) );\n\n              lyr_chn[cidx]->id = lyr_a[lidx]->chn_info[cidx].channel_id;\n              lyr_chn[cidx]->rows = lyr_a[lidx]->bottom - lyr_a[lidx]->top;\n              lyr_chn[cidx]->columns = lyr_a[lidx]->right - lyr_a[lidx]->left;\n\n              if (lyr_chn[cidx]->id == PSD_CHANNEL_MASK)\n                {\n                  /* Works around a bug in panotools psd files where the layer mask\n                     size is given as 0 but data exists. Set mask size to layer size.\n                  */\n                  if (empty_mask && lyr_a[lidx]->chn_info[cidx].data_len - 2 > 0)\n                    {\n                      empty_mask = FALSE;\n                      if (lyr_a[lidx]->layer_mask.top == lyr_a[lidx]->layer_mask.bottom)\n                        {\n                          lyr_a[lidx]->layer_mask.top = lyr_a[lidx]->top;\n                          lyr_a[lidx]->layer_mask.bottom = lyr_a[lidx]->bottom;\n                        }\n                      if (lyr_a[lidx]->layer_mask.right == lyr_a[lidx]->layer_mask.left)\n                        {\n                          lyr_a[lidx]->layer_mask.right = lyr_a[lidx]->right;\n                          lyr_a[lidx]->layer_mask.left = lyr_a[lidx]->left;\n                        }\n                    }\n                  lyr_chn[cidx]->rows = (lyr_a[lidx]->layer_mask.bottom -\n                                        lyr_a[lidx]->layer_mask.top);\n                  lyr_chn[cidx]->columns = (lyr_a[lidx]->layer_mask.right -\n                                           lyr_a[lidx]->layer_mask.left);\n                }\n\n              IFDBG(3) g_debug (\"Channel id %d, %dx%d\",\n                                lyr_chn[cidx]->id,\n                                lyr_chn[cidx]->columns,\n                                lyr_chn[cidx]->rows);\n\n              /* Only read channel data if there is any channel\n               * data. Note that the channel data can contain a\n               * compression method but no actual data.\n               */\n              if (lyr_a[lidx]->chn_info[cidx].data_len >= COMP_MODE_SIZE)\n                {\n                  if (fread (&comp_mode, COMP_MODE_SIZE, 1, f) < 1)\n                    {\n                      psd_set_error (feof (f), errno, error);\n                      return -1;\n                    }\n                  comp_mode = GUINT16_FROM_BE (comp_mode);\n                  IFDBG(3) g_debug (\"Compression mode: %d\", comp_mode);\n                }\n              if (lyr_a[lidx]->chn_info[cidx].data_len > COMP_MODE_SIZE)\n                {\n                  switch (comp_mode)\n                    {\n                      case PSD_COMP_RAW:        /* Planar raw data */\n                        IFDBG(3) g_debug (\"Raw data length: %d\",\n                                          lyr_a[lidx]->chn_info[cidx].data_len - 2);\n                        if (read_channel_data (lyr_chn[cidx], img_a->bps,\n                            PSD_COMP_RAW, NULL, f, error) < 1)\n                          return -1;\n                        break;\n\n                      case PSD_COMP_RLE:        /* Packbits */\n                        IFDBG(3) g_debug (\"RLE channel length %d, RLE length data: %d, \"\n                                          \"RLE data block: %d\",\n                                          lyr_a[lidx]->chn_info[cidx].data_len - 2,\n                                          lyr_chn[cidx]->rows * 2,\n                                          (lyr_a[lidx]->chn_info[cidx].data_len - 2 -\n                                           lyr_chn[cidx]->rows * 2));\n                        rle_pack_len = g_malloc (lyr_chn[cidx]->rows * 2);\n                        for (rowi = 0; rowi < lyr_chn[cidx]->rows; ++rowi)\n                          {\n                            if (fread (&rle_pack_len[rowi], 2, 1, f) < 1)\n                              {\n                                psd_set_error (feof (f), errno, error);\n                                return -1;\n                              }\n                                rle_pack_len[rowi] = GUINT16_FROM_BE (rle_pack_len[rowi]);\n                          }\n\n                        IFDBG(3) g_debug (\"RLE decode - data\");\n                        if (read_channel_data (lyr_chn[cidx], img_a->bps,\n                            PSD_COMP_RLE, rle_pack_len, f, error) < 1)\n                          return -1;\n\n                        g_free (rle_pack_len);\n                        break;\n\n                      case PSD_COMP_ZIP:                 /* ? */\n                      case PSD_COMP_ZIP_PRED:\n                      default:\n                        g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                                    _(\"Unsupported compression mode: %d\"), comp_mode);\n                        return -1;\n                        break;\n                    }\n                }\n            }\n          g_free (lyr_a[lidx]->chn_info);\n\n          /* Draw layer */\n\n          alpha = FALSE;\n          alpha_chn = -1;\n          user_mask = FALSE;\n          user_mask_chn = -1;\n          layer_channels = 0;\n          l_x = 0;\n          l_y = 0;\n          l_w = img_a->columns;\n          l_h = img_a->rows;\n\n          IFDBG(3) g_debug (\"Re-hash channel indices\");\n          for (cidx = 0; cidx < lyr_a[lidx]->num_channels; ++cidx)\n            {\n              if (lyr_chn[cidx]->id == PSD_CHANNEL_MASK)\n                {\n                  user_mask = TRUE;\n                  user_mask_chn = cidx;\n                }\n              else if (lyr_chn[cidx]->id == PSD_CHANNEL_ALPHA)\n                {\n                  alpha = TRUE;\n                  alpha_chn = cidx;\n                }\n              else\n                {\n                  channel_idx[layer_channels] = cidx;   /* Assumes in sane order */\n                  layer_channels++;                     /* RGB, Lab, CMYK etc.   */\n                }\n            }\n          if (alpha)\n            {\n              channel_idx[layer_channels] = alpha_chn;\n              layer_channels++;\n            }\n\n          if (empty)\n            {\n              IFDBG(2) g_debug (\"Create blank layer\");\n              image_type = get_gimp_image_type (img_a->base_type, TRUE);\n              layer_id = gimp_layer_new (image_id, lyr_a[lidx]->name,\n                                         img_a->columns, img_a->rows,\n                                         image_type, 0, GIMP_NORMAL_MODE);\n              g_free (lyr_a[lidx]->name);\n              gimp_image_add_layer (image_id, layer_id, -1);\n              drawable = gimp_drawable_get (layer_id);\n              gimp_drawable_fill (drawable->drawable_id, GIMP_TRANSPARENT_FILL);\n              gimp_drawable_set_visible (drawable->drawable_id, lyr_a[lidx]->layer_flags.visible);\n              if (lyr_a[lidx]->id)\n                gimp_drawable_set_tattoo (drawable->drawable_id, lyr_a[lidx]->id);\n              if (lyr_a[lidx]->layer_flags.irrelevant)\n                gimp_drawable_set_visible (drawable->drawable_id, FALSE);\n              gimp_drawable_flush (drawable);\n              gimp_drawable_detach (drawable);\n            }\n          else\n            {\n              l_x = lyr_a[lidx]->left;\n              l_y = lyr_a[lidx]->top;\n              l_w = lyr_a[lidx]->right - lyr_a[lidx]->left;\n              l_h = lyr_a[lidx]->bottom - lyr_a[lidx]->top;\n\n              IFDBG(3) g_debug (\"Draw layer\");\n              image_type = get_gimp_image_type (img_a->base_type, alpha);\n              IFDBG(3) g_debug (\"Layer type %d\", image_type);\n              layer_size = l_w * l_h;\n              pixels = g_malloc (layer_size * layer_channels);\n              for (cidx = 0; cidx < layer_channels; ++cidx)\n                {\n                  IFDBG(3) g_debug (\"Start channel %d\", channel_idx[cidx]);\n                  for (i = 0; i < layer_size; ++i)\n                    pixels[(i * layer_channels) + cidx] = lyr_chn[channel_idx[cidx]]->data[i];\n                  g_free (lyr_chn[channel_idx[cidx]]->data);\n                }\n\n              layer_mode = psd_to_gimp_blend_mode (lyr_a[lidx]->blend_mode);\n              layer_id = gimp_layer_new (image_id, lyr_a[lidx]->name, l_w, l_h,\n                                         image_type, lyr_a[lidx]->opacity * 100 / 255,\n                                         layer_mode);\n              IFDBG(3) g_debug (\"Layer tattoo: %d\", layer_id);\n              g_free (lyr_a[lidx]->name);\n              gimp_image_add_layer (image_id, layer_id, -1);\n              gimp_layer_set_offsets (layer_id, l_x, l_y);\n              gimp_layer_set_lock_alpha  (layer_id, lyr_a[lidx]->layer_flags.trans_prot);\n              drawable = gimp_drawable_get (layer_id);\n              gimp_pixel_rgn_init (&pixel_rgn, drawable, 0, 0,\n                                   drawable->width, drawable->height, TRUE, FALSE);\n              gimp_pixel_rgn_set_rect (&pixel_rgn, pixels,\n                                       0, 0, drawable->width, drawable->height);\n              gimp_drawable_set_visible (drawable->drawable_id, lyr_a[lidx]->layer_flags.visible);\n              if (lyr_a[lidx]->id)\n                gimp_drawable_set_tattoo (drawable->drawable_id, lyr_a[lidx]->id);\n              gimp_drawable_flush (drawable);\n              gimp_drawable_detach (drawable);\n              g_free (pixels);\n            }\n\n          /* Layer mask */\n          if (user_mask)\n            {\n              if (empty_mask)\n                {\n                  IFDBG(3) g_debug (\"Create empty mask\");\n                  if (lyr_a[lidx]->layer_mask.def_color == 255)\n                    mask_id = gimp_layer_create_mask (layer_id, GIMP_ADD_WHITE_MASK);\n                  else\n                    mask_id = gimp_layer_create_mask (layer_id, GIMP_ADD_BLACK_MASK);\n                  gimp_layer_add_mask (layer_id, mask_id);\n                  gimp_layer_set_apply_mask (layer_id,\n                    ! lyr_a[lidx]->layer_mask.mask_flags.disabled);\n                }\n              else\n                {\n                  /* Load layer mask data */\n                  if (lyr_a[lidx]->layer_mask.mask_flags.relative_pos)\n                    {\n                      lm_x = lyr_a[lidx]->layer_mask.left;\n                      lm_y = lyr_a[lidx]->layer_mask.top;\n                      lm_w = lyr_a[lidx]->layer_mask.right - lyr_a[lidx]->layer_mask.left;\n                      lm_h = lyr_a[lidx]->layer_mask.bottom - lyr_a[lidx]->layer_mask.top;\n                    }\n                  else\n                    {\n                      lm_x = lyr_a[lidx]->layer_mask.left - l_x;\n                      lm_y = lyr_a[lidx]->layer_mask.top - l_y;\n                      lm_w = lyr_a[lidx]->layer_mask.right - lyr_a[lidx]->layer_mask.left;\n                      lm_h = lyr_a[lidx]->layer_mask.bottom - lyr_a[lidx]->layer_mask.top;\n                    }\n                  IFDBG(3) g_debug (\"Mask channel index %d\", user_mask_chn);\n                  IFDBG(3) g_debug (\"Relative pos %d\",\n                                    lyr_a[lidx]->layer_mask.mask_flags.relative_pos);\n                  layer_size = lm_w * lm_h;\n                  pixels = g_malloc (layer_size);\n                  IFDBG(3) g_debug (\"Allocate Pixels %d\", layer_size);\n                  /* Crop mask at layer boundry */\n                  IFDBG(3) g_debug (\"Original Mask %d %d %d %d\", lm_x, lm_y, lm_w, lm_h);\n                  if (lm_x < 0\n                      || lm_y < 0\n                      || lm_w + lm_x > l_w\n                      || lm_h + lm_y > l_h)\n                    {\n                      if (CONVERSION_WARNINGS)\n                        g_message (\"Warning\\n\"\n                                   \"The layer mask is partly outside the \"\n                                   \"layer boundary. The mask will be \"\n                                   \"cropped which may result in data loss.\");\n                      i = 0;\n                      for (rowi = 0; rowi < lm_h; ++rowi)\n                        {\n                          if (rowi + lm_y >= 0 && rowi + lm_y < l_h)\n                            {\n                              for (coli = 0; coli < lm_w; ++coli)\n                                {\n                                  if (coli + lm_x >= 0 && coli + lm_x < l_w)\n                                    {\n                                      pixels[i] =\n                                        lyr_chn[user_mask_chn]->data[(rowi * lm_w) + coli];\n                                      i++;\n                                    }\n                                }\n                            }\n                        }\n                      if (lm_x < 0)\n                        {\n                          lm_w += lm_x;\n                          lm_x = 0;\n                        }\n                      if (lm_y < 0)\n                        {\n                          lm_h += lm_y;\n                          lm_y = 0;\n                        }\n                      if (lm_w + lm_x > l_w)\n                        lm_w = l_w - lm_x;\n                      if (lm_h + lm_y > l_h)\n                        lm_h = l_h - lm_y;\n                    }\n                  else\n                    memcpy (pixels, lyr_chn[user_mask_chn]->data, layer_size);\n                  g_free (lyr_chn[user_mask_chn]->data);\n                  /* Draw layer mask data */\n                  IFDBG(3) g_debug (\"Layer %d %d %d %d\", l_x, l_y, l_w, l_h);\n                  IFDBG(3) g_debug (\"Mask %d %d %d %d\", lm_x, lm_y, lm_w, lm_h);\n\n                  if (lyr_a[lidx]->layer_mask.def_color == 255)\n                    mask_id = gimp_layer_create_mask (layer_id, GIMP_ADD_WHITE_MASK);\n                  else\n                    mask_id = gimp_layer_create_mask (layer_id, GIMP_ADD_BLACK_MASK);\n\n                  IFDBG(3) g_debug (\"New layer mask %d\", mask_id);\n                  gimp_layer_add_mask (layer_id, mask_id);\n                  drawable = gimp_drawable_get (mask_id);\n                  gimp_pixel_rgn_init (&pixel_rgn, drawable, 0 , 0,\n                                       drawable->width, drawable->height, TRUE, FALSE);\n                  gimp_pixel_rgn_set_rect (&pixel_rgn, pixels, lm_x, lm_y, lm_w, lm_h);\n                  gimp_drawable_flush (drawable);\n                  gimp_drawable_detach (drawable);\n                  gimp_layer_set_apply_mask (layer_id,\n                    ! lyr_a[lidx]->layer_mask.mask_flags.disabled);\n                  g_free (pixels);\n                }\n            }\n          for (cidx = 0; cidx < lyr_a[lidx]->num_channels; ++cidx)\n            if (lyr_chn[cidx])\n              g_free (lyr_chn[cidx]);\n          g_free (lyr_chn);\n        }\n      g_free (lyr_a[lidx]);\n    }\n  g_free (lyr_a);\n\n  return 0;\n}",
        "start_line": 956
      },
      {
        "filename": "plug-ins/file-psd/psd-load.c",
        "method_name": "read_channel_data",
        "raw_code": "static gint /* <=== read_channel_data */ \nread_channel_data (PSDchannel     *channel,\n                   const guint16   bps,\n                   const guint16   compression,\n                   const guint16  *rle_pack_len,\n                   FILE           *f,\n                   GError        **error)\n{\n  gchar    *raw_data;\n  gchar    *src;\n  gchar    *dst;\n  guint32   readline_len;\n  gint      i;\n\n  if (bps == 1)\n    readline_len = ((channel->columns + 7) >> 3);\n  else\n    readline_len = (channel->columns * bps >> 3);\n\n  IFDBG(3) g_debug (\"raw data size %d x %d = %d\", readline_len,\n                    channel->rows, readline_len * channel->rows);\n  raw_data = g_malloc (readline_len * channel->rows);\n  switch (compression)\n    {\n      case PSD_COMP_RAW:\n        if (fread (raw_data, readline_len, channel->rows, f) < 1)\n          {\n            psd_set_error (feof (f), errno, error);\n            return -1;\n          }\n        break;\n\n      case PSD_COMP_RLE:\n        for (i = 0; i < channel->rows; ++i)\n          {\n            src = g_malloc (rle_pack_len[i]);\n            dst = g_malloc (readline_len);\n/*      FIXME check for over-run\n            if (ftell (f) + rle_pack_len[i] > block_end)\n              {\n                psd_set_error (TRUE, errno, error);\n                return -1;\n              }\n*/\n            if (fread (src, rle_pack_len[i], 1, f) < 1)\n              {\n                psd_set_error (feof (f), errno, error);\n                return -1;\n              }\n            /* FIXME check for errors returned from decode packbits */\n            decode_packbits (src, dst, rle_pack_len[i], readline_len);\n            g_free (src);\n            memcpy (raw_data + i * readline_len, dst, readline_len);\n            g_free (dst);\n          }\n        break;\n    }\n\n  /* Convert channel data to GIMP format */\n  switch (bps)\n    {\n      case 16:\n        channel->data = (gchar *) g_malloc (channel->rows * channel->columns);\n        convert_16_bit (raw_data, channel->data, (channel->rows * channel->columns) << 1);\n        break;\n\n      case 8:\n        channel->data = (gchar *) g_malloc (channel->rows * channel->columns);\n        memcpy (channel->data, raw_data, (channel->rows * channel->columns));\n        break;\n\n      case 1:\n        channel->data = (gchar *) g_malloc (channel->rows * channel->columns);\n        convert_1_bit (raw_data, channel->data, channel->rows, channel->columns);\n        break;\n    }\n\n  g_free (raw_data);\n\n  return 1;\n}",
        "start_line": 1743
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "plug-ins/file-psd/psd-load.c",
        "method_name": "read_header_block",
        "raw_code": "static gint /* <=== read_header_block */ \nread_header_block (PSDimage  *img_a,\n                   FILE      *f,\n                   GError   **error)\n{\n  guint16  version;\n  gchar    sig[4];\n  gchar    buf[6];\n\n  if (fread (sig, 4, 1, f) < 1\n      || fread (&version, 2, 1, f) < 1\n      || fread (buf, 6, 1, f) < 1\n      || fread (&img_a->channels, 2, 1, f) < 1\n      || fread (&img_a->rows, 4, 1, f) < 1\n      || fread (&img_a->columns, 4, 1, f) < 1\n      || fread (&img_a->bps, 2, 1, f) < 1\n      || fread (&img_a->color_mode, 2, 1, f) < 1)\n    {\n      psd_set_error (feof (f), errno, error);\n      return -1;\n    }\n  version = GUINT16_FROM_BE (version);\n  img_a->channels = GUINT16_FROM_BE (img_a->channels);\n  img_a->rows = GUINT32_FROM_BE (img_a->rows);\n  img_a->columns = GUINT32_FROM_BE (img_a->columns);\n  img_a->bps = GUINT16_FROM_BE (img_a->bps);\n  img_a->color_mode = GUINT16_FROM_BE (img_a->color_mode);\n\n  IFDBG(1) g_debug (\"\\n\\n\\tSig: %.4s\\n\\tVer: %d\\n\\tChannels: \"\n                    \"%d\\n\\tSize: %dx%d\\n\\tBPS: %d\\n\\tMode: %d\\n\",\n                    sig, version, img_a->channels,\n                    img_a->columns, img_a->rows,\n                    img_a->bps, img_a->color_mode);\n\n  if (memcmp (sig, \"8BPS\", 4) != 0)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                  _(\"Not a valid photoshop document file\"));\n      return -1;\n    }\n\n  if (version != 1)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                  _(\"Unsupported file format version: %d\"), version);\n      return -1;\n    }\n\n  if (img_a->channels > MAX_CHANNELS)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                  _(\"Too many channels in file: %d\"), img_a->channels);\n      return -1;\n    }\n\n    /* Photoshop CS (version 8) supports 300000 x 300000, but this\n       is currently larger than GIMP_MAX_IMAGE_SIZE */\n\n  if (img_a->rows < 1 || img_a->rows > GIMP_MAX_IMAGE_SIZE)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                  _(\"Unsupported or invalid image height: %d\"),\n                  img_a->rows);\n      return -1;\n    }\n\n  if (img_a->columns < 1 || img_a->columns > GIMP_MAX_IMAGE_SIZE)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                  _(\"Unsupported or invalid image width: %d\"),\n                  img_a->columns);\n      return -1;\n    }\n\n  /* img_a->rows is sanitized above, so a division by zero is avoided here */\n  if (img_a->columns > G_MAXINT32 / img_a->rows)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"Unsupported or invalid image size: %dx%d\"),\n                   img_a->columns, img_a->rows);\n      return -1;\n    }\n\n  if (img_a->color_mode != PSD_BITMAP\n      && img_a->color_mode != PSD_GRAYSCALE\n      && img_a->color_mode != PSD_INDEXED\n      && img_a->color_mode != PSD_RGB\n      && img_a->color_mode != PSD_DUOTONE)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"Unsupported color mode: %s\"),\n                   get_psd_color_mode_name (img_a->color_mode));\n      return -1;\n    }\n\n  /* Warnings for format conversions */\n  switch (img_a->bps)\n    {\n      case 16:\n        IFDBG(3) g_debug (\"16 Bit Data\");\n        if (CONVERSION_WARNINGS)\n          g_message (_(\"Warning:\\n\"\n                       \"The image you are loading has 16 bits per channel. GIMP \"\n                       \"can only handle 8 bit, so it will be converted for you. \"\n                       \"Information will be lost because of this conversion.\"));\n        break;\n\n      case 8:\n        IFDBG(3) g_debug (\"8 Bit Data\");\n        break;\n\n      case 1:\n        IFDBG(3) g_debug (\"1 Bit Data\");\n        break;\n\n      default:\n        g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                    _(\"Unsupported bit depth: %d\"), img_a->bps);\n        return -1;\n        break;\n    }\n\n  return 0;\n}",
        "start_line": 233
      },
      {
        "filename": "plug-ins/file-psd/psd-load.c",
        "method_name": "read_layer_block",
        "raw_code": "static PSDlayer ** /* <=== read_layer_block */ \nread_layer_block (PSDimage  *img_a,\n                  FILE      *f,\n                  GError   **error)\n{\n  PSDlayer **lyr_a;\n  guint32    block_len;\n  guint32    block_end;\n  guint32    block_rem;\n  gint32     read_len;\n  gint32     write_len;\n  gint       lidx;                  /* Layer index */\n  gint       cidx;                  /* Channel index */\n\n  if (fread (&block_len, 4, 1, f) < 1)\n    {\n      psd_set_error (feof (f), errno, error);\n      img_a->num_layers = -1;\n      return NULL;\n    }\n  img_a->mask_layer_len = GUINT32_FROM_BE (block_len);\n\n  IFDBG(1) g_debug (\"Layer and mask block size = %d\", img_a->mask_layer_len);\n\n  img_a->transparency = FALSE;\n  img_a->layer_data_len = 0;\n\n  if (!img_a->mask_layer_len)\n    {\n      img_a->num_layers = 0;\n      return NULL;\n    }\n  else\n    {\n      img_a->mask_layer_start = ftell (f);\n      block_end = img_a->mask_layer_start + img_a->mask_layer_len;\n\n      /* Get number of layers */\n      if (fread (&block_len, 4, 1, f) < 1\n          || fread (&img_a->num_layers, 2, 1, f) < 1)\n        {\n          psd_set_error (feof (f), errno, error);\n          img_a->num_layers = -1;\n          return NULL;\n        }\n      img_a->num_layers = GINT16_FROM_BE (img_a->num_layers);\n      IFDBG(2) g_debug (\"Number of layers: %d\", img_a->num_layers);\n\n      if (img_a->num_layers < 0)\n        {\n          img_a->transparency = TRUE;\n          img_a->num_layers = -img_a->num_layers;\n        }\n\n      if (img_a->num_layers)\n        {\n          /* Read layer records */\n          PSDlayerres           res_a;\n\n          /* Create pointer array for the layer records */\n          lyr_a = g_new (PSDlayer *, img_a->num_layers);\n          for (lidx = 0; lidx < img_a->num_layers; ++lidx)\n            {\n              /* Allocate layer record */\n              lyr_a[lidx] = (PSDlayer *) g_malloc (sizeof (PSDlayer) );\n\n              /* Initialise record */\n              lyr_a[lidx]->drop = FALSE;\n              lyr_a[lidx]->id = 0;\n\n              if (fread (&lyr_a[lidx]->top, 4, 1, f) < 1\n                  || fread (&lyr_a[lidx]->left, 4, 1, f) < 1\n                  || fread (&lyr_a[lidx]->bottom, 4, 1, f) < 1\n                  || fread (&lyr_a[lidx]->right, 4, 1, f) < 1\n                  || fread (&lyr_a[lidx]->num_channels, 2, 1, f) < 1)\n                {\n                  psd_set_error (feof (f), errno, error);\n                  return NULL;\n                }\n              lyr_a[lidx]->top = GINT32_FROM_BE (lyr_a[lidx]->top);\n              lyr_a[lidx]->left = GINT32_FROM_BE (lyr_a[lidx]->left);\n              lyr_a[lidx]->bottom = GINT32_FROM_BE (lyr_a[lidx]->bottom);\n              lyr_a[lidx]->right = GINT32_FROM_BE (lyr_a[lidx]->right);\n              lyr_a[lidx]->num_channels = GUINT16_FROM_BE (lyr_a[lidx]->num_channels);\n\n              if (lyr_a[lidx]->num_channels > MAX_CHANNELS)\n                {\n                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                              _(\"Too many channels in layer: %d\"),\n                              lyr_a[lidx]->num_channels);\n                  return NULL;\n                }\n              if (lyr_a[lidx]->bottom < lyr_a[lidx]->top ||\n                  lyr_a[lidx]->bottom - lyr_a[lidx]->top > GIMP_MAX_IMAGE_SIZE)\n                {\n                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                              _(\"Unsupported or invalid layer height: %d\"),\n                              lyr_a[lidx]->bottom - lyr_a[lidx]->top);\n                  return NULL;\n                }\n              if (lyr_a[lidx]->right < lyr_a[lidx]->left ||\n                  lyr_a[lidx]->right - lyr_a[lidx]->left > GIMP_MAX_IMAGE_SIZE)\n                {\n                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                              _(\"Unsupported or invalid layer width: %d\"),\n                              lyr_a[lidx]->right - lyr_a[lidx]->left);\n                  return NULL;\n                }\n\n              if ((lyr_a[lidx]->right - lyr_a[lidx]->left) >\n                  G_MAXINT32 / MAX (lyr_a[lidx]->bottom - lyr_a[lidx]->top, 1))\n                {\n                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                               _(\"Unsupported or invalid layer size: %dx%d\"),\n                               lyr_a[lidx]->right - lyr_a[lidx]->left,\n                               lyr_a[lidx]->bottom - lyr_a[lidx]->top);\n                  return NULL;\n                }\n\n              IFDBG(2) g_debug (\"Layer %d, Coords %d %d %d %d, channels %d, \",\n                                 lidx, lyr_a[lidx]->left, lyr_a[lidx]->top,\n                                 lyr_a[lidx]->right, lyr_a[lidx]->bottom,\n                                 lyr_a[lidx]->num_channels);\n\n              lyr_a[lidx]->chn_info = g_new (ChannelLengthInfo, lyr_a[lidx]->num_channels);\n              for (cidx = 0; cidx < lyr_a[lidx]->num_channels; ++cidx)\n                {\n                  if (fread (&lyr_a[lidx]->chn_info[cidx].channel_id, 2, 1, f) < 1\n                      || fread (&lyr_a[lidx]->chn_info[cidx].data_len, 4, 1, f) < 1)\n                    {\n                      psd_set_error (feof (f), errno, error);\n                      return NULL;\n                    }\n                  lyr_a[lidx]->chn_info[cidx].channel_id =\n                    GINT16_FROM_BE (lyr_a[lidx]->chn_info[cidx].channel_id);\n                  lyr_a[lidx]->chn_info[cidx].data_len =\n                    GUINT32_FROM_BE (lyr_a[lidx]->chn_info[cidx].data_len);\n                  img_a->layer_data_len += lyr_a[lidx]->chn_info[cidx].data_len;\n                  IFDBG(3) g_debug (\"Channel ID %d, data len %d\",\n                                     lyr_a[lidx]->chn_info[cidx].channel_id,\n                                     lyr_a[lidx]->chn_info[cidx].data_len);\n                }\n\n              if (fread (lyr_a[lidx]->mode_key, 4, 1, f) < 1\n                  || fread (lyr_a[lidx]->blend_mode, 4, 1, f) < 1\n                  || fread (&lyr_a[lidx]->opacity, 1, 1, f) < 1\n                  || fread (&lyr_a[lidx]->clipping, 1, 1, f) < 1\n                  || fread (&lyr_a[lidx]->flags, 1, 1, f) < 1\n                  || fread (&lyr_a[lidx]->filler, 1, 1, f) < 1\n                  || fread (&lyr_a[lidx]->extra_len, 4, 1, f) < 1)\n                {\n                  psd_set_error (feof (f), errno, error);\n                  return NULL;\n                }\n              if (memcmp (lyr_a[lidx]->mode_key, \"8BIM\", 4) != 0)\n                {\n                  IFDBG(1) g_debug (\"Incorrect layer mode signature %.4s\",\n                                    lyr_a[lidx]->mode_key);\n                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                              _(\"The file is corrupt!\"));\n                  return NULL;\n                }\n\n              lyr_a[lidx]->layer_flags.trans_prot = lyr_a[lidx]->flags & 1 ? TRUE : FALSE;\n              lyr_a[lidx]->layer_flags.visible = lyr_a[lidx]->flags & 2 ? FALSE : TRUE;\n              if (lyr_a[lidx]->flags & 8)\n                lyr_a[lidx]->layer_flags.irrelevant = lyr_a[lidx]->flags & 16 ? TRUE : FALSE;\n              else\n                lyr_a[lidx]->layer_flags.irrelevant = FALSE;\n\n              lyr_a[lidx]->extra_len = GUINT32_FROM_BE (lyr_a[lidx]->extra_len);\n              block_rem = lyr_a[lidx]->extra_len;\n              IFDBG(2) g_debug (\"\\n\\tLayer mode sig: %.4s\\n\\tBlend mode: %.4s\\n\\t\"\n                                \"Opacity: %d\\n\\tClipping: %d\\n\\tExtra data len: %d\\n\\t\"\n                                \"Alpha lock: %d\\n\\tVisible: %d\\n\\tIrrelevant: %d\",\n                                    lyr_a[lidx]->mode_key,\n                                    lyr_a[lidx]->blend_mode,\n                                    lyr_a[lidx]->opacity,\n                                    lyr_a[lidx]->clipping,\n                                    lyr_a[lidx]->extra_len,\n                                    lyr_a[lidx]->layer_flags.trans_prot,\n                                    lyr_a[lidx]->layer_flags.visible,\n                                    lyr_a[lidx]->layer_flags.irrelevant);\n              IFDBG(3) g_debug (\"Remaining length %d\", block_rem);\n\n              /* Layer mask data */\n              if (fread (&block_len, 4, 1, f) < 1)\n                {\n                  psd_set_error (feof (f), errno, error);\n                  return NULL;\n                }\n              block_len = GUINT32_FROM_BE (block_len);\n              block_rem -= (block_len + 4);\n              IFDBG(3) g_debug (\"Remaining length %d\", block_rem);\n\n              lyr_a[lidx]->layer_mask_extra.top = 0;\n              lyr_a[lidx]->layer_mask_extra.left = 0;\n              lyr_a[lidx]->layer_mask_extra.bottom = 0;\n              lyr_a[lidx]->layer_mask_extra.right = 0;\n              lyr_a[lidx]->layer_mask.top = 0;\n              lyr_a[lidx]->layer_mask.left = 0;\n              lyr_a[lidx]->layer_mask.bottom = 0;\n              lyr_a[lidx]->layer_mask.right = 0;\n              lyr_a[lidx]->layer_mask.def_color = 0;\n              lyr_a[lidx]->layer_mask.extra_def_color = 0;\n              lyr_a[lidx]->layer_mask.mask_flags.relative_pos = FALSE;\n              lyr_a[lidx]->layer_mask.mask_flags.disabled = FALSE;\n              lyr_a[lidx]->layer_mask.mask_flags.invert = FALSE;\n\n              switch (block_len)\n                {\n                  case 0:\n                    break;\n\n                  case 20:\n                    if (fread (&lyr_a[lidx]->layer_mask.top, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.left, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.bottom, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.right, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.def_color, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.flags, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.extra_def_color, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.extra_flags, 1, 1, f) < 1)\n                      {\n                        psd_set_error (feof (f), errno, error);\n                        return NULL;\n                      }\n                    lyr_a[lidx]->layer_mask.top =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.top);\n                    lyr_a[lidx]->layer_mask.left =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.left);\n                    lyr_a[lidx]->layer_mask.bottom =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.bottom);\n                    lyr_a[lidx]->layer_mask.right =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.right);\n                    lyr_a[lidx]->layer_mask.mask_flags.relative_pos =\n                      lyr_a[lidx]->layer_mask.flags & 1 ? TRUE : FALSE;\n                    lyr_a[lidx]->layer_mask.mask_flags.disabled =\n                      lyr_a[lidx]->layer_mask.flags & 2 ? TRUE : FALSE;\n                    lyr_a[lidx]->layer_mask.mask_flags.invert =\n                      lyr_a[lidx]->layer_mask.flags & 4 ? TRUE : FALSE;\n                    break;\n                  case 36: /* If we have a 36 byte mask record assume second data set is correct */\n                    if (fread (&lyr_a[lidx]->layer_mask_extra.top, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask_extra.left, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask_extra.bottom, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask_extra.right, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.extra_def_color, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.extra_flags, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.def_color, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.flags, 1, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.top, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.left, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.bottom, 4, 1, f) < 1\n                        || fread (&lyr_a[lidx]->layer_mask.right, 4, 1, f) < 1)\n                      {\n                        psd_set_error (feof (f), errno, error);\n                        return NULL;\n                      }\n                    lyr_a[lidx]->layer_mask_extra.top =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask_extra.top);\n                    lyr_a[lidx]->layer_mask_extra.left =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask_extra.left);\n                    lyr_a[lidx]->layer_mask_extra.bottom =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask_extra.bottom);\n                    lyr_a[lidx]->layer_mask_extra.right =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask_extra.right);\n                    lyr_a[lidx]->layer_mask.top =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.top);\n                    lyr_a[lidx]->layer_mask.left =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.left);\n                    lyr_a[lidx]->layer_mask.bottom =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.bottom);\n                    lyr_a[lidx]->layer_mask.right =\n                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.right);\n                    lyr_a[lidx]->layer_mask.mask_flags.relative_pos =\n                      lyr_a[lidx]->layer_mask.flags & 1 ? TRUE : FALSE;\n                    lyr_a[lidx]->layer_mask.mask_flags.disabled =\n                      lyr_a[lidx]->layer_mask.flags & 2 ? TRUE : FALSE;\n                    lyr_a[lidx]->layer_mask.mask_flags.invert =\n                      lyr_a[lidx]->layer_mask.flags & 4 ? TRUE : FALSE;\n                    break;\n\n                  default:\n                    IFDBG(1) g_debug (\"Unknown layer mask record size ... skipping\");\n                    if (fseek (f, block_len, SEEK_CUR) < 0)\n                      {\n                        psd_set_error (feof (f), errno, error);\n                        return NULL;\n                      }\n                }\n\n              /* sanity checks */\n              if (lyr_a[lidx]->layer_mask.bottom < lyr_a[lidx]->layer_mask.top ||\n                  lyr_a[lidx]->layer_mask.bottom - lyr_a[lidx]->layer_mask.top > GIMP_MAX_IMAGE_SIZE)\n                {\n                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                               _(\"Unsupported or invalid layer mask height: %d\"),\n                               lyr_a[lidx]->layer_mask.bottom - lyr_a[lidx]->layer_mask.top);\n                  return NULL;\n                }\n              if (lyr_a[lidx]->layer_mask.right < lyr_a[lidx]->layer_mask.left ||\n                  lyr_a[lidx]->layer_mask.right - lyr_a[lidx]->layer_mask.left > GIMP_MAX_IMAGE_SIZE)\n                {\n                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                               _(\"Unsupported or invalid layer mask width: %d\"),\n                               lyr_a[lidx]->layer_mask.right - lyr_a[lidx]->layer_mask.left);\n                  return NULL;\n                }\n\n              if ((lyr_a[lidx]->layer_mask.right - lyr_a[lidx]->layer_mask.left) >\n                  G_MAXINT32 / MAX (lyr_a[lidx]->layer_mask.bottom - lyr_a[lidx]->layer_mask.top, 1))\n                {\n                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                               _(\"Unsupported or invalid layer mask size: %dx%d\"),\n                               lyr_a[lidx]->layer_mask.right - lyr_a[lidx]->layer_mask.left,\n                               lyr_a[lidx]->layer_mask.bottom - lyr_a[lidx]->layer_mask.top);\n                  return NULL;\n                }\n\n              IFDBG(2) g_debug (\"Layer mask coords %d %d %d %d, Rel pos %d\",\n                                lyr_a[lidx]->layer_mask.left,\n                                lyr_a[lidx]->layer_mask.top,\n                                lyr_a[lidx]->layer_mask.right,\n                                lyr_a[lidx]->layer_mask.bottom,\n                                lyr_a[lidx]->layer_mask.mask_flags.relative_pos);\n\n              IFDBG(3) g_debug (\"Default mask color, %d, %d\",\n                                lyr_a[lidx]->layer_mask.def_color,\n                                lyr_a[lidx]->layer_mask.extra_def_color);\n\n              /* Layer blending ranges */           /* FIXME  */\n              if (fread (&block_len, 4, 1, f) < 1)\n                {\n                  psd_set_error (feof (f), errno, error);\n                  return NULL;\n                }\n              block_len = GUINT32_FROM_BE (block_len);\n              block_rem -= (block_len + 4);\n              IFDBG(3) g_debug (\"Remaining length %d\", block_rem);\n              if (block_len > 0)\n                {\n                  if (fseek (f, block_len, SEEK_CUR) < 0)\n                    {\n                      psd_set_error (feof (f), errno, error);\n                      return NULL;\n                    }\n                }\n\n              lyr_a[lidx]->name = fread_pascal_string (&read_len, &write_len,\n                                                       4, f, error);\n              if (*error)\n                return NULL;\n              block_rem -= read_len;\n              IFDBG(3) g_debug (\"Remaining length %d\", block_rem);\n\n              /* Adjustment layer info */           /* FIXME */\n\n              while (block_rem > 7)\n                {\n                  if (get_layer_resource_header (&res_a, f, error) < 0)\n                    return NULL;\n                  block_rem -= 12;\n\n                  if (res_a.data_len > block_rem)\n                    {\n                      IFDBG(1) g_debug (\"Unexpected end of layer resource data\");\n                      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                                  _(\"The file is corrupt!\"));\n                      return NULL;\n                    }\n\n                  if (load_layer_resource (&res_a, lyr_a[lidx], f, error) < 0)\n                    return NULL;\n                  block_rem -= res_a.data_len;\n                }\n              if (block_rem > 0)\n                {\n                  if (fseek (f, block_rem, SEEK_CUR) < 0)\n                    {\n                      psd_set_error (feof (f), errno, error);\n                      return NULL;\n                    }\n                }\n            }\n\n          img_a->layer_data_start = ftell(f);\n          if (fseek (f, img_a->layer_data_len, SEEK_CUR) < 0)\n            {\n              psd_set_error (feof (f), errno, error);\n              return NULL;\n            }\n\n          IFDBG(1) g_debug (\"Layer image data block size %d\",\n                             img_a->layer_data_len);\n        }\n      else\n        lyr_a = NULL;\n\n      /* Read global layer mask record */       /* FIXME */\n\n      /* Skip to end of block */\n      if (fseek (f, block_end, SEEK_SET) < 0)\n        {\n          psd_set_error (feof (f), errno, error);\n          return NULL;\n        }\n    }\n\n  return lyr_a;\n}",
        "start_line": 466
      },
      {
        "filename": "plug-ins/file-psd/psd-load.c",
        "method_name": "add_layers",
        "raw_code": "static gint /* <=== add_layers */ \nadd_layers (const gint32  image_id,\n            PSDimage     *img_a,\n            PSDlayer    **lyr_a,\n            FILE         *f,\n            GError      **error)\n{\n  PSDchannel          **lyr_chn;\n  guchar               *pixels;\n  guint16               alpha_chn;\n  guint16               user_mask_chn;\n  guint16               layer_channels;\n  guint16               channel_idx[MAX_CHANNELS];\n  guint16              *rle_pack_len;\n  gint32                l_x;                   /* Layer x */\n  gint32                l_y;                   /* Layer y */\n  gint32                l_w;                   /* Layer width */\n  gint32                l_h;                   /* Layer height */\n  gint32                lm_x;                  /* Layer mask x */\n  gint32                lm_y;                  /* Layer mask y */\n  gint32                lm_w;                  /* Layer mask width */\n  gint32                lm_h;                  /* Layer mask height */\n  gint32                layer_size;\n  gint32                layer_id = -1;\n  gint32                mask_id = -1;\n  gint                  lidx;                  /* Layer index */\n  gint                  cidx;                  /* Channel index */\n  gint                  rowi;                  /* Row index */\n  gint                  coli;                  /* Column index */\n  gint                  i;\n  gboolean              alpha;\n  gboolean              user_mask;\n  gboolean              empty;\n  gboolean              empty_mask;\n  GimpDrawable         *drawable;\n  GimpPixelRgn          pixel_rgn;\n  GimpImageType         image_type;\n  GimpLayerModeEffects  layer_mode;\n\n\n  IFDBG(2) g_debug (\"Number of layers: %d\", img_a->num_layers);\n\n  if (img_a->num_layers == 0)\n    {\n      IFDBG(2) g_debug (\"No layers to process\");\n      return 0;\n    }\n\n  /* Layered image - Photoshop 3 style */\n  if (fseek (f, img_a->layer_data_start, SEEK_SET) < 0)\n    {\n      psd_set_error (feof (f), errno, error);\n      return -1;\n    }\n\n  for (lidx = 0; lidx < img_a->num_layers; ++lidx)\n    {\n      IFDBG(2) g_debug (\"Process Layer No %d.\", lidx);\n\n      if (lyr_a[lidx]->drop)\n        {\n          IFDBG(2) g_debug (\"Drop layer %d\", lidx);\n\n          /* Step past layer data */\n          for (cidx = 0; cidx < lyr_a[lidx]->num_channels; ++cidx)\n            {\n              if (fseek (f, lyr_a[lidx]->chn_info[cidx].data_len, SEEK_CUR) < 0)\n                {\n                  psd_set_error (feof (f), errno, error);\n                  return -1;\n                }\n            }\n          g_free (lyr_a[lidx]->chn_info);\n          g_free (lyr_a[lidx]->name);\n        }\n\n      else\n        {\n          /* Empty layer */\n          if (lyr_a[lidx]->bottom - lyr_a[lidx]->top == 0\n              || lyr_a[lidx]->right - lyr_a[lidx]->left == 0)\n              empty = TRUE;\n          else\n              empty = FALSE;\n\n          /* Empty mask */\n          if (lyr_a[lidx]->layer_mask.bottom - lyr_a[lidx]->layer_mask.top == 0\n              || lyr_a[lidx]->layer_mask.right - lyr_a[lidx]->layer_mask.left == 0)\n              empty_mask = TRUE;\n          else\n              empty_mask = FALSE;\n\n          IFDBG(3) g_debug (\"Empty mask %d, size %d %d\", empty_mask,\n                            lyr_a[lidx]->layer_mask.bottom - lyr_a[lidx]->layer_mask.top,\n                            lyr_a[lidx]->layer_mask.right - lyr_a[lidx]->layer_mask.left);\n\n          /* Load layer channel data */\n          IFDBG(2) g_debug (\"Number of channels: %d\", lyr_a[lidx]->num_channels);\n          /* Create pointer array for the channel records */\n          lyr_chn = g_new (PSDchannel *, lyr_a[lidx]->num_channels);\n          for (cidx = 0; cidx < lyr_a[lidx]->num_channels; ++cidx)\n            {\n              guint16 comp_mode = PSD_COMP_RAW;\n\n              /* Allocate channel record */\n              lyr_chn[cidx] = g_malloc (sizeof (PSDchannel) );\n\n              lyr_chn[cidx]->id = lyr_a[lidx]->chn_info[cidx].channel_id;\n              lyr_chn[cidx]->rows = lyr_a[lidx]->bottom - lyr_a[lidx]->top;\n              lyr_chn[cidx]->columns = lyr_a[lidx]->right - lyr_a[lidx]->left;\n\n              if (lyr_chn[cidx]->id == PSD_CHANNEL_MASK)\n                {\n                  /* Works around a bug in panotools psd files where the layer mask\n                     size is given as 0 but data exists. Set mask size to layer size.\n                  */\n                  if (empty_mask && lyr_a[lidx]->chn_info[cidx].data_len - 2 > 0)\n                    {\n                      empty_mask = FALSE;\n                      if (lyr_a[lidx]->layer_mask.top == lyr_a[lidx]->layer_mask.bottom)\n                        {\n                          lyr_a[lidx]->layer_mask.top = lyr_a[lidx]->top;\n                          lyr_a[lidx]->layer_mask.bottom = lyr_a[lidx]->bottom;\n                        }\n                      if (lyr_a[lidx]->layer_mask.right == lyr_a[lidx]->layer_mask.left)\n                        {\n                          lyr_a[lidx]->layer_mask.right = lyr_a[lidx]->right;\n                          lyr_a[lidx]->layer_mask.left = lyr_a[lidx]->left;\n                        }\n                    }\n                  lyr_chn[cidx]->rows = (lyr_a[lidx]->layer_mask.bottom -\n                                        lyr_a[lidx]->layer_mask.top);\n                  lyr_chn[cidx]->columns = (lyr_a[lidx]->layer_mask.right -\n                                           lyr_a[lidx]->layer_mask.left);\n                }\n\n              IFDBG(3) g_debug (\"Channel id %d, %dx%d\",\n                                lyr_chn[cidx]->id,\n                                lyr_chn[cidx]->columns,\n                                lyr_chn[cidx]->rows);\n\n              /* Only read channel data if there is any channel\n               * data. Note that the channel data can contain a\n               * compression method but no actual data.\n               */\n              if (lyr_a[lidx]->chn_info[cidx].data_len >= COMP_MODE_SIZE)\n                {\n                  if (fread (&comp_mode, COMP_MODE_SIZE, 1, f) < 1)\n                    {\n                      psd_set_error (feof (f), errno, error);\n                      return -1;\n                    }\n                  comp_mode = GUINT16_FROM_BE (comp_mode);\n                  IFDBG(3) g_debug (\"Compression mode: %d\", comp_mode);\n                }\n              if (lyr_a[lidx]->chn_info[cidx].data_len > COMP_MODE_SIZE)\n                {\n                  switch (comp_mode)\n                    {\n                      case PSD_COMP_RAW:        /* Planar raw data */\n                        IFDBG(3) g_debug (\"Raw data length: %d\",\n                                          lyr_a[lidx]->chn_info[cidx].data_len - 2);\n                        if (read_channel_data (lyr_chn[cidx], img_a->bps,\n                            PSD_COMP_RAW, NULL, f, error) < 1)\n                          return -1;\n                        break;\n\n                      case PSD_COMP_RLE:        /* Packbits */\n                        IFDBG(3) g_debug (\"RLE channel length %d, RLE length data: %d, \"\n                                          \"RLE data block: %d\",\n                                          lyr_a[lidx]->chn_info[cidx].data_len - 2,\n                                          lyr_chn[cidx]->rows * 2,\n                                          (lyr_a[lidx]->chn_info[cidx].data_len - 2 -\n                                           lyr_chn[cidx]->rows * 2));\n                        rle_pack_len = g_malloc (lyr_chn[cidx]->rows * 2);\n                        for (rowi = 0; rowi < lyr_chn[cidx]->rows; ++rowi)\n                          {\n                            if (fread (&rle_pack_len[rowi], 2, 1, f) < 1)\n                              {\n                                psd_set_error (feof (f), errno, error);\n                                return -1;\n                              }\n                            rle_pack_len[rowi] = GUINT16_FROM_BE (rle_pack_len[rowi]);\n                          }\n\n                        IFDBG(3) g_debug (\"RLE decode - data\");\n                        if (read_channel_data (lyr_chn[cidx], img_a->bps,\n                            PSD_COMP_RLE, rle_pack_len, f, error) < 1)\n                          return -1;\n\n                        g_free (rle_pack_len);\n                        break;\n\n                      case PSD_COMP_ZIP:                 /* ? */\n                      case PSD_COMP_ZIP_PRED:\n                      default:\n                        g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                                    _(\"Unsupported compression mode: %d\"), comp_mode);\n                        return -1;\n                        break;\n                    }\n                }\n            }\n          g_free (lyr_a[lidx]->chn_info);\n\n          /* Draw layer */\n\n          alpha = FALSE;\n          alpha_chn = -1;\n          user_mask = FALSE;\n          user_mask_chn = -1;\n          layer_channels = 0;\n          l_x = 0;\n          l_y = 0;\n          l_w = img_a->columns;\n          l_h = img_a->rows;\n\n          IFDBG(3) g_debug (\"Re-hash channel indices\");\n          for (cidx = 0; cidx < lyr_a[lidx]->num_channels; ++cidx)\n            {\n              if (lyr_chn[cidx]->id == PSD_CHANNEL_MASK)\n                {\n                  user_mask = TRUE;\n                  user_mask_chn = cidx;\n                }\n              else if (lyr_chn[cidx]->id == PSD_CHANNEL_ALPHA)\n                {\n                  alpha = TRUE;\n                  alpha_chn = cidx;\n                }\n              else\n                {\n                  channel_idx[layer_channels] = cidx;   /* Assumes in sane order */\n                  layer_channels++;                     /* RGB, Lab, CMYK etc.   */\n                }\n            }\n          if (alpha)\n            {\n              channel_idx[layer_channels] = alpha_chn;\n              layer_channels++;\n            }\n\n          if (empty)\n            {\n              IFDBG(2) g_debug (\"Create blank layer\");\n              image_type = get_gimp_image_type (img_a->base_type, TRUE);\n              layer_id = gimp_layer_new (image_id, lyr_a[lidx]->name,\n                                         img_a->columns, img_a->rows,\n                                         image_type, 0, GIMP_NORMAL_MODE);\n              g_free (lyr_a[lidx]->name);\n              gimp_image_add_layer (image_id, layer_id, -1);\n              drawable = gimp_drawable_get (layer_id);\n              gimp_drawable_fill (drawable->drawable_id, GIMP_TRANSPARENT_FILL);\n              gimp_drawable_set_visible (drawable->drawable_id, lyr_a[lidx]->layer_flags.visible);\n              if (lyr_a[lidx]->id)\n                gimp_drawable_set_tattoo (drawable->drawable_id, lyr_a[lidx]->id);\n              if (lyr_a[lidx]->layer_flags.irrelevant)\n                gimp_drawable_set_visible (drawable->drawable_id, FALSE);\n              gimp_drawable_flush (drawable);\n              gimp_drawable_detach (drawable);\n            }\n          else\n            {\n              l_x = lyr_a[lidx]->left;\n              l_y = lyr_a[lidx]->top;\n              l_w = lyr_a[lidx]->right - lyr_a[lidx]->left;\n              l_h = lyr_a[lidx]->bottom - lyr_a[lidx]->top;\n\n              IFDBG(3) g_debug (\"Draw layer\");\n              image_type = get_gimp_image_type (img_a->base_type, alpha);\n              IFDBG(3) g_debug (\"Layer type %d\", image_type);\n              layer_size = l_w * l_h;\n              pixels = g_malloc (layer_size * layer_channels);\n              for (cidx = 0; cidx < layer_channels; ++cidx)\n                {\n                  IFDBG(3) g_debug (\"Start channel %d\", channel_idx[cidx]);\n                  for (i = 0; i < layer_size; ++i)\n                    pixels[(i * layer_channels) + cidx] = lyr_chn[channel_idx[cidx]]->data[i];\n                  g_free (lyr_chn[channel_idx[cidx]]->data);\n                }\n\n              layer_mode = psd_to_gimp_blend_mode (lyr_a[lidx]->blend_mode);\n              layer_id = gimp_layer_new (image_id, lyr_a[lidx]->name, l_w, l_h,\n                                         image_type, lyr_a[lidx]->opacity * 100 / 255,\n                                         layer_mode);\n              IFDBG(3) g_debug (\"Layer tattoo: %d\", layer_id);\n              g_free (lyr_a[lidx]->name);\n              gimp_image_add_layer (image_id, layer_id, -1);\n              gimp_layer_set_offsets (layer_id, l_x, l_y);\n              gimp_layer_set_lock_alpha  (layer_id, lyr_a[lidx]->layer_flags.trans_prot);\n              drawable = gimp_drawable_get (layer_id);\n              gimp_pixel_rgn_init (&pixel_rgn, drawable, 0, 0,\n                                   drawable->width, drawable->height, TRUE, FALSE);\n              gimp_pixel_rgn_set_rect (&pixel_rgn, pixels,\n                                       0, 0, drawable->width, drawable->height);\n              gimp_drawable_set_visible (drawable->drawable_id, lyr_a[lidx]->layer_flags.visible);\n              if (lyr_a[lidx]->id)\n                gimp_drawable_set_tattoo (drawable->drawable_id, lyr_a[lidx]->id);\n              gimp_drawable_flush (drawable);\n              gimp_drawable_detach (drawable);\n              g_free (pixels);\n            }\n\n          /* Layer mask */\n          if (user_mask)\n            {\n              if (empty_mask)\n                {\n                  IFDBG(3) g_debug (\"Create empty mask\");\n                  if (lyr_a[lidx]->layer_mask.def_color == 255)\n                    mask_id = gimp_layer_create_mask (layer_id, GIMP_ADD_WHITE_MASK);\n                  else\n                    mask_id = gimp_layer_create_mask (layer_id, GIMP_ADD_BLACK_MASK);\n                  gimp_layer_add_mask (layer_id, mask_id);\n                  gimp_layer_set_apply_mask (layer_id,\n                    ! lyr_a[lidx]->layer_mask.mask_flags.disabled);\n                }\n              else\n                {\n                  /* Load layer mask data */\n                  if (lyr_a[lidx]->layer_mask.mask_flags.relative_pos)\n                    {\n                      lm_x = lyr_a[lidx]->layer_mask.left;\n                      lm_y = lyr_a[lidx]->layer_mask.top;\n                      lm_w = lyr_a[lidx]->layer_mask.right - lyr_a[lidx]->layer_mask.left;\n                      lm_h = lyr_a[lidx]->layer_mask.bottom - lyr_a[lidx]->layer_mask.top;\n                    }\n                  else\n                    {\n                      lm_x = lyr_a[lidx]->layer_mask.left - l_x;\n                      lm_y = lyr_a[lidx]->layer_mask.top - l_y;\n                      lm_w = lyr_a[lidx]->layer_mask.right - lyr_a[lidx]->layer_mask.left;\n                      lm_h = lyr_a[lidx]->layer_mask.bottom - lyr_a[lidx]->layer_mask.top;\n                    }\n                  IFDBG(3) g_debug (\"Mask channel index %d\", user_mask_chn);\n                  IFDBG(3) g_debug (\"Relative pos %d\",\n                                    lyr_a[lidx]->layer_mask.mask_flags.relative_pos);\n                  layer_size = lm_w * lm_h;\n                  pixels = g_malloc (layer_size);\n                  IFDBG(3) g_debug (\"Allocate Pixels %d\", layer_size);\n                  /* Crop mask at layer boundry */\n                  IFDBG(3) g_debug (\"Original Mask %d %d %d %d\", lm_x, lm_y, lm_w, lm_h);\n                  if (lm_x < 0\n                      || lm_y < 0\n                      || lm_w + lm_x > l_w\n                      || lm_h + lm_y > l_h)\n                    {\n                      if (CONVERSION_WARNINGS)\n                        g_message (\"Warning\\n\"\n                                   \"The layer mask is partly outside the \"\n                                   \"layer boundary. The mask will be \"\n                                   \"cropped which may result in data loss.\");\n                      i = 0;\n                      for (rowi = 0; rowi < lm_h; ++rowi)\n                        {\n                          if (rowi + lm_y >= 0 && rowi + lm_y < l_h)\n                            {\n                              for (coli = 0; coli < lm_w; ++coli)\n                                {\n                                  if (coli + lm_x >= 0 && coli + lm_x < l_w)\n                                    {\n                                      pixels[i] =\n                                        lyr_chn[user_mask_chn]->data[(rowi * lm_w) + coli];\n                                      i++;\n                                    }\n                                }\n                            }\n                        }\n                      if (lm_x < 0)\n                        {\n                          lm_w += lm_x;\n                          lm_x = 0;\n                        }\n                      if (lm_y < 0)\n                        {\n                          lm_h += lm_y;\n                          lm_y = 0;\n                        }\n                      if (lm_w + lm_x > l_w)\n                        lm_w = l_w - lm_x;\n                      if (lm_h + lm_y > l_h)\n                        lm_h = l_h - lm_y;\n                    }\n                  else\n                    memcpy (pixels, lyr_chn[user_mask_chn]->data, layer_size);\n                  g_free (lyr_chn[user_mask_chn]->data);\n                  /* Draw layer mask data */\n                  IFDBG(3) g_debug (\"Layer %d %d %d %d\", l_x, l_y, l_w, l_h);\n                  IFDBG(3) g_debug (\"Mask %d %d %d %d\", lm_x, lm_y, lm_w, lm_h);\n\n                  if (lyr_a[lidx]->layer_mask.def_color == 255)\n                    mask_id = gimp_layer_create_mask (layer_id, GIMP_ADD_WHITE_MASK);\n                  else\n                    mask_id = gimp_layer_create_mask (layer_id, GIMP_ADD_BLACK_MASK);\n\n                  IFDBG(3) g_debug (\"New layer mask %d\", mask_id);\n                  gimp_layer_add_mask (layer_id, mask_id);\n                  drawable = gimp_drawable_get (mask_id);\n                  gimp_pixel_rgn_init (&pixel_rgn, drawable, 0 , 0,\n                                       drawable->width, drawable->height, TRUE, FALSE);\n                  gimp_pixel_rgn_set_rect (&pixel_rgn, pixels, lm_x, lm_y, lm_w, lm_h);\n                  gimp_drawable_flush (drawable);\n                  gimp_drawable_detach (drawable);\n                  gimp_layer_set_apply_mask (layer_id,\n                    ! lyr_a[lidx]->layer_mask.mask_flags.disabled);\n                  g_free (pixels);\n                }\n            }\n          for (cidx = 0; cidx < lyr_a[lidx]->num_channels; ++cidx)\n            if (lyr_chn[cidx])\n              g_free (lyr_chn[cidx]);\n          g_free (lyr_chn);\n        }\n      g_free (lyr_a[lidx]);\n    }\n  g_free (lyr_a);\n\n  return 0;\n}",
        "start_line": 1005
      },
      {
        "filename": "plug-ins/file-psd/psd-load.c",
        "method_name": "read_channel_data",
        "raw_code": "static gint /* <=== read_channel_data */ \nread_channel_data (PSDchannel     *channel,\n                   const guint16   bps,\n                   const guint16   compression,\n                   const guint16  *rle_pack_len,\n                   FILE           *f,\n                   GError        **error)\n{\n  gchar    *raw_data;\n  gchar    *src;\n  gchar    *dst;\n  guint32   readline_len;\n  gint      i;\n\n  if (bps == 1)\n    readline_len = ((channel->columns + 7) >> 3);\n  else\n    readline_len = (channel->columns * bps >> 3);\n\n  IFDBG(3) g_debug (\"raw data size %d x %d = %d\", readline_len,\n                    channel->rows, readline_len * channel->rows);\n\n  /* sanity check, int overflow check (avoid divisions by zero) */\n  if ((channel->rows == 0) || (channel->columns == 0) ||\n      (channel->rows > G_MAXINT32 / channel->columns / MAX (bps >> 3, 1)))\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"Unsupported or invalid channel size\"));\n      return -1;\n    }\n\n  raw_data = g_malloc (readline_len * channel->rows);\n  switch (compression)\n    {\n      case PSD_COMP_RAW:\n        if (fread (raw_data, readline_len, channel->rows, f) < 1)\n          {\n            psd_set_error (feof (f), errno, error);\n            return -1;\n          }\n        break;\n\n      case PSD_COMP_RLE:\n        for (i = 0; i < channel->rows; ++i)\n          {\n            src = g_malloc (rle_pack_len[i]);\n            dst = g_malloc (readline_len);\n/*      FIXME check for over-run\n            if (ftell (f) + rle_pack_len[i] > block_end)\n              {\n                psd_set_error (TRUE, errno, error);\n                return -1;\n              }\n*/\n            if (fread (src, rle_pack_len[i], 1, f) < 1)\n              {\n                psd_set_error (feof (f), errno, error);\n                return -1;\n              }\n            /* FIXME check for errors returned from decode packbits */\n            decode_packbits (src, dst, rle_pack_len[i], readline_len);\n            g_free (src);\n            memcpy (raw_data + i * readline_len, dst, readline_len);\n            g_free (dst);\n          }\n        break;\n    }\n\n  /* Convert channel data to GIMP format */\n  switch (bps)\n    {\n      case 16:\n        channel->data = (gchar *) g_malloc (channel->rows * channel->columns);\n        convert_16_bit (raw_data, channel->data, (channel->rows * channel->columns) << 1);\n        break;\n\n      case 8:\n        channel->data = (gchar *) g_malloc (channel->rows * channel->columns);\n        memcpy (channel->data, raw_data, (channel->rows * channel->columns));\n        break;\n\n      case 1:\n        channel->data = (gchar *) g_malloc (channel->rows * channel->columns);\n        convert_1_bit (raw_data, channel->data, channel->rows, channel->columns);\n        break;\n    }\n\n  g_free (raw_data);\n\n  return 1;\n}",
        "start_line": 1792
      }
    ],
    "code_context": "Called Methods:\n- gimp_pixel_rgn_init: void /* <=== gimp_pixel_rgn_init */ \ngimp_pixel_rgn_init (GimpPixelRgn *pr,\n                     GimpDrawable *drawable,\n                     gint          x,\n                     gint          y,\n                     gint          width,\n                     gint          height,\n                     gboolean      dirty,\n                     gboolean      shadow)\n{\n  g_return_if_fail (pr != NULL);\n  g_return_if_fail (drawable != NULL);\n  g_return_if_fail (x >= 0 && x + width  <= drawable->width);\n  g_return_if_fail (y >= 0 && y + height <= drawable->height);\n\n  pr->data      = NULL;\n  pr->drawable  = drawable;\n  pr->bpp       = drawable->bpp;\n  pr->rowstride = 0;\n  pr->x         = x;\n  pr->y         = y;\n  pr->w         = width;\n  pr->h         = height;\n  pr->dirty     = dirty;\n  pr->shadow    = shadow;\n}\n- decode_packbits: gint /* <=== decode_packbits */ \ndecode_packbits (const gchar *src,\n                 gchar       *dst,\n                 guint16      packed_len,\n                 guint32      unpacked_len)\n{\n/*\n *  Decode a PackBits chunk.\n */\n  gint      n;\n  gchar     dat;\n  gint32    unpack_left = unpacked_len;\n  gint32    pack_left = packed_len;\n  gint32    error_code = 0;\n  gint32    return_val = 0;\n\n  while (unpack_left > 0 && pack_left > 0)\n    {\n      n = *src;\n      src++;\n      pack_left--;\n\n      if (n == 128)     /* nop */\n        continue;\n      else if (n > 128)\n        n -= 256;\n\n      if (n < 0)        /* replicate next gchar |n|+ 1 times */\n        {\n          n  = 1 - n;\n          if (! pack_left)\n            {\n              IFDBG(2) g_debug (\"Input buffer exhausted in replicate\");\n              error_code = 1;\n              break;\n            }\n          if (n > unpack_left)\n            {\n              IFDBG(2) g_debug (\"Overrun in packbits replicate of %d chars\", n - unpack_left);\n              error_code = 2;\n            }\n          dat = *src;\n          for (; n > 0; --n)\n            {\n              if (! unpack_left)\n                break;\n              *dst = dat;\n              dst++;\n              unpack_left--;\n            }\n          if (unpack_left)\n            {\n              src++;\n              pack_left--;\n            }\n        }\n      else              /* copy next n+1 gchars literally */\n        {\n          n++;\n          for (; n > 0; --n)\n            {\n              if (! pack_left)\n                {\n                  IFDBG(2) g_debug (\"Input buffer exhausted in copy\");\n                  error_code = 3;\n                  break;\n                }\n              if (! unpack_left)\n                {\n                  IFDBG(2) g_debug (\"Output buffer exhausted in copy\");\n                  error_code = 4;\n                  break;\n                }\n              *dst = *src;\n              dst++;\n              unpack_left--;\n              src++;\n              pack_left--;\n            }\n        }\n    }\n\n  if (unpack_left > 0)\n    {\n      /* Pad with zeros to end of output buffer */\n      for (n = 0; n < pack_left; ++n)\n        {\n          *dst = 0;\n          dst++;\n        }\n    }\n\n  if (unpack_left)\n    {\n      IFDBG(2) g_debug (\"Packbits decode - unpack left %d\", unpack_left);\n      return_val -= unpack_left;\n    }\n  if (pack_left)\n    {\n      /* Some images seem to have a pad byte at the end of the packed data */\n      if (error_code || pack_left != 1)\n        {\n          IFDBG(2) g_debug (\"Packbits decode - pack left %d\", pack_left);\n          return_val = pack_left;\n        }\n    }\n\n  IFDBG(2)\n    if (error_code)\n      g_debug (\"Error code %d\", error_code);\n\n  return return_val;\n}\n- gimp_drawable_detach: void /* <=== gimp_drawable_detach */ \ngimp_drawable_detach (GimpDrawable *drawable)\n{\n  g_return_if_fail (drawable != NULL);\n\n  gimp_drawable_flush (drawable);\n\n  if (drawable->tiles)\n    g_free (drawable->tiles);\n\n  if (drawable->shadow_tiles)\n    g_free (drawable->shadow_tiles);\n\n  g_slice_free (GimpDrawable, drawable);\n}\n- gimp_drawable_push_undo: void /* <=== gimp_drawable_push_undo */ \ngimp_drawable_push_undo (GimpDrawable *drawable,\n                         const gchar  *undo_desc,\n                         gint          x1,\n                         gint          y1,\n                         gint          x2,\n                         gint          y2,\n                         TileManager  *tiles,\n                         gboolean      sparse)\n{\n  GimpItem *item;\n  gint      x, y;\n  gint      width, height;\n\n  g_return_if_fail (GIMP_IS_DRAWABLE (drawable));\n  g_return_if_fail (sparse == FALSE || tiles != NULL);\n\n  item = GIMP_ITEM (drawable);\n\n  g_return_if_fail (gimp_item_is_attached (item));\n  g_return_if_fail (sparse == FALSE ||\n                    tile_manager_width (tiles) == gimp_item_width (item));\n  g_return_if_fail (sparse == FALSE ||\n                    tile_manager_height (tiles) == gimp_item_height (item));\n\n#if 0\n  g_printerr (\"gimp_drawable_push_undo (%s, %d, %d, %d, %d)\\n\",\n              sparse ? \"TRUE\" : \"FALSE\", x1, y1, x2 - x1, y2 - y1);\n#endif\n\n  if (! gimp_rectangle_intersect (x1, y1,\n                                  x2 - x1, y2 - y1,\n                                  0, 0,\n                                  gimp_item_width (item),\n                                  gimp_item_height (item),\n                                  &x, &y, &width, &height))\n    {\n      g_warning (\"%s: tried to push empty region\", G_STRFUNC);\n      return;\n    }\n\n  GIMP_DRAWABLE_GET_CLASS (drawable)->push_undo (drawable, undo_desc,\n                                                 tiles, sparse,\n                                                 x, y, width, height);\n}\n- PSD_LADJ_PHOTO_FILT: #define PSD_LADJ_PHOTO_FILT     \"phfl\"          /* Adjustment layer - photo filter (PS9) */ /* <=== plug-ins/file-psd/psd.h:81:81:PSD_LADJ_PHOTO_FILT:0 */ \n- fread_pascal_string: gchar * /* <=== fread_pascal_string */ \nfread_pascal_string (gint32         *bytes_read,\n                     gint32         *bytes_written,\n                     const guint16   mod_len,\n                     FILE           *f,\n                     GError        **error)\n{\n  /*\n   * Reads a pascal string from the file padded to a multiple of mod_len\n   * and returns a utf-8 string.\n   */\n\n  gchar        *str;\n  gchar        *utf8_str;\n  guchar        len;\n  gint32        padded_len;\n\n  *bytes_read = 0;\n  *bytes_written = -1;\n\n  if (fread (&len, 1, 1, f) < 1)\n    {\n      psd_set_error (feof (f), errno, error);\n      return NULL;\n    }\n  (*bytes_read)++;\n  IFDBG(3) g_debug (\"Pascal string length %d\", len);\n\n  if (len == 0)\n    {\n      if (fseek (f, mod_len - 1, SEEK_CUR) < 0)\n        {\n          psd_set_error (feof (f), errno, error);\n          return NULL;\n        }\n      *bytes_read += (mod_len - 1);\n      *bytes_written = 0;\n      return NULL;\n    }\n\n  str = g_malloc (len);\n  if (fread (str, len, 1, f) < 1)\n    {\n      psd_set_error (feof (f), errno, error);\n      return NULL;\n    }\n  *bytes_read += len;\n\n  if (mod_len > 0)\n    {\n      padded_len = len + 1;\n      while (padded_len % mod_len != 0)\n        {\n          if (fseek (f, 1, SEEK_CUR) < 0)\n            {\n              psd_set_error (feof (f), errno, error);\n              return NULL;\n            }\n          (*bytes_read)++;\n          padded_len++;\n        }\n    }\n\n  utf8_str = gimp_any_to_utf8 (str, len, NULL);\n  *bytes_written = strlen (utf8_str);\n  g_free (str);\n\n  IFDBG(3) g_debug (\"Pascal string: %s, bytes_read: %d, bytes_written: %d\",\n                    utf8_str, *bytes_read, *bytes_written);\n\n  return utf8_str;\n}\n- load_resource_ladj: static gint /* <=== load_resource_ladj */ \nload_resource_ladj (const PSDlayerres  *res_a,\n                    PSDlayer           *lyr_a,\n                    FILE               *f,\n                    GError            **error)\n{\n  /* Load adjustment layer */\n  static gboolean   msg_flag = FALSE;\n\n  IFDBG(2) g_debug (\"Process layer resource block %.4s: Adjustment layer\", res_a->key);\n  lyr_a->drop = TRUE;\n  if (! msg_flag && CONVERSION_WARNINGS)\n    {\n      g_message (\"Warning:\\n\"\n                 \"The image file contains adjustment layers. \"\n                 \"These are not supported by the GIMP and will \"\n                 \"be dropped.\");\n      msg_flag = TRUE;\n    }\n\n  return 0;\n}\n- gimp_layer_set_apply_mask: gboolean /* <=== gimp_layer_set_apply_mask */ \ngimp_layer_set_apply_mask (gint32   layer_ID,\n                           gboolean apply_mask)\n{\n  GimpParam *return_vals;\n  gint nreturn_vals;\n  gboolean success = TRUE;\n\n  return_vals = gimp_run_procedure (\"gimp-layer-set-apply-mask\",\n                                    &nreturn_vals,\n                                    GIMP_PDB_LAYER, layer_ID,\n                                    GIMP_PDB_INT32, apply_mask,\n                                    GIMP_PDB_END);\n\n  success = return_vals[0].data.d_status == GIMP_PDB_SUCCESS;\n\n  gimp_destroy_params (return_vals, nreturn_vals);\n\n  return success;\n}\n- ALPHA_PIX: #define ALPHA_PIX        3 /* <=== app/base/base-types.h:43:43:ALPHA_PIX:0 */ \n- BLUE_PIX: #define BLUE_PIX         2 /* <=== app/base/base-types.h:42:42:BLUE_PIX:0 */ \n- gimp_layer_is_floating_sel: gboolean /* <=== gimp_layer_is_floating_sel */ \ngimp_layer_is_floating_sel (const GimpLayer *layer)\n{\n  g_return_val_if_fail (GIMP_IS_LAYER (layer), FALSE);\n\n  return (layer->fs.drawable != NULL);\n}\n- GIMP_IS_IMAGE: #define GIMP_IS_IMAGE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_IMAGE)) /* <=== app/core/gimpimage.h:92:92:GIMP_IS_IMAGE:1 */ \n- PSD_LTYP_TYPE2: #define PSD_LTYP_TYPE2          \"TySh\"          /* Type tool object setting (PS6) */ /* <=== plug-ins/file-psd/psd.h:98:98:PSD_LTYP_TYPE2:0 */ \n- gimp_drawable_update: gboolean /* <=== gimp_drawable_update */ \ngimp_drawable_update (gint32 drawable_ID,\n                      gint   x,\n                      gint   y,\n                      gint   width,\n                      gint   height)\n{\n  GimpParam *return_vals;\n  gint nreturn_vals;\n  gboolean success = TRUE;\n\n  return_vals = gimp_run_procedure (\"gimp-drawable-update\",\n                                    &nreturn_vals,\n                                    GIMP_PDB_DRAWABLE, drawable_ID,\n                                    GIMP_PDB_INT32, x,\n                                    GIMP_PDB_INT32, y,\n                                    GIMP_PDB_INT32, width,\n                                    GIMP_PDB_INT32, height,\n                                    GIMP_PDB_END);\n\n  success = return_vals[0].data.d_status == GIMP_PDB_SUCCESS;\n\n  gimp_destroy_params (return_vals, nreturn_vals);\n\n  return success;\n}\n- COMP_MODE_SIZE: #define COMP_MODE_SIZE sizeof(guint16) /* <=== plug-ins/file-psd/psd-load.c:39:39:COMP_MODE_SIZE:0 */ \n- gimp_drawable_width: gint /* <=== gimp_drawable_width */ \ngimp_drawable_width (gint32 drawable_ID)\n{\n  GimpParam *return_vals;\n  gint nreturn_vals;\n  gint width = 0;\n\n  return_vals = gimp_run_procedure (\"gimp-drawable-width\",\n                                    &nreturn_vals,\n                                    GIMP_PDB_DRAWABLE, drawable_ID,\n                                    GIMP_PDB_END);\n\n  if (return_vals[0].data.d_status == GIMP_PDB_SUCCESS)\n    width = return_vals[1].data.d_int32;\n\n  gimp_destroy_params (return_vals, nreturn_vals);\n\n  return width;\n}\n- TILE_WIDTH: #define TILE_WIDTH  gimp_tile_width() /* <=== libgimp/gimpdrawable.c:27:27:TILE_WIDTH:0 */ \n- PSD_LFIL_SOLID: #define PSD_LFIL_SOLID          \"SoCo\"          /* Solid color sheet setting (PS6) */ /* <=== plug-ins/file-psd/psd.h:88:88:PSD_LFIL_SOLID:0 */ \n- gimp_drawable_flush: void /* <=== gimp_drawable_flush */ \ngimp_drawable_flush (GimpDrawable *drawable)\n{\n  GimpTile *tiles;\n  gint      n_tiles;\n  gint      i;\n\n  g_return_if_fail (drawable != NULL);\n\n  if (drawable->tiles)\n    {\n      tiles   = drawable->tiles;\n      n_tiles = drawable->ntile_rows * drawable->ntile_cols;\n\n      for (i = 0; i < n_tiles; i++)\n        if ((tiles[i].ref_count > 0) && tiles[i].dirty)\n          gimp_tile_flush (&tiles[i]);\n    }\n\n  if (drawable->shadow_tiles)\n    {\n      tiles   = drawable->shadow_tiles;\n      n_tiles = drawable->ntile_rows * drawable->ntile_cols;\n\n      for (i = 0; i < n_tiles; i++)\n        if ((tiles[i].ref_count > 0) && tiles[i].dirty)\n          gimp_tile_flush (&tiles[i]);\n    }\n\n  /*  nuke all references to this drawable from the cache  */\n  _gimp_tile_cache_flush_drawable (drawable);\n}\n- GIMP_IMAGE_TYPE_BYTES: #define GIMP_IMAGE_TYPE_BYTES(t)           ((t) == GIMP_RGBA_IMAGE     ? 4 : \\ /* <=== app/core/gimpimage.h:55:60:GIMP_IMAGE_TYPE_BYTES:1 */ \n                                            (t) == GIMP_RGB_IMAGE      ? 3 : \\\n                                            (t) == GIMP_GRAYA_IMAGE    ? 2 : \\\n                                            (t) == GIMP_GRAY_IMAGE     ? 1 : \\\n                                            (t) == GIMP_INDEXEDA_IMAGE ? 2 : \\\n                                            (t) == GIMP_INDEXED_IMAGE  ? 1 : -1)\n- PSD_LADJ_BLACK_WHITE: #define PSD_LADJ_BLACK_WHITE    \"blwh\"          /* Adjustment layer - black & white (PS10) */ /* <=== plug-ins/file-psd/psd.h:75:75:PSD_LADJ_BLACK_WHITE:0 */ \n- gimp_image_set_active_layer: GimpLayer * /* <=== gimp_image_set_active_layer */ \ngimp_image_set_active_layer (GimpImage *image,\n                             GimpLayer *layer)\n{\n  GimpLayer *floating_sel;\n\n  g_return_val_if_fail (GIMP_IS_IMAGE (image), NULL);\n  g_return_val_if_fail (layer == NULL || GIMP_IS_LAYER (layer), NULL);\n  g_return_val_if_fail (layer == NULL ||\n                        gimp_container_have (image->layers,\n                                             GIMP_OBJECT (layer)), NULL);\n\n  floating_sel = gimp_image_floating_sel (image);\n\n  /*  Make sure the floating_sel always is the active layer  */\n  if (floating_sel && layer != floating_sel)\n    return floating_sel;\n\n  if (layer != image->active_layer)\n    {\n      if (layer)\n        {\n          /*  Configure the layer stack to reflect this change  */\n          image->layer_stack = g_slist_remove (image->layer_stack, layer);\n          image->layer_stack = g_slist_prepend (image->layer_stack, layer);\n        }\n\n      /*  Don't cache selection info for the previous active layer  */\n      if (image->active_layer)\n        gimp_drawable_invalidate_boundary (GIMP_DRAWABLE (image->active_layer));\n\n      image->active_layer = layer;\n\n      g_signal_emit (image, gimp_image_signals[ACTIVE_LAYER_CHANGED], 0);\n\n      if (layer && image->active_channel)\n        gimp_image_set_active_channel (image, NULL);\n    }\n\n  return image->active_layer;\n}\n- GIMP_IS_LAYER: #define GIMP_IS_LAYER(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_LAYER)) /* <=== app/core/gimplayer.h:29:29:GIMP_IS_LAYER:1 */ \n- load_resource_unknown: static gint /* <=== load_resource_unknown */ \nload_resource_unknown (const PSDimageres  *res_a,\n                       const gint32        image_id,\n                       FILE               *f,\n                       GError            **error)\n{\n  /* Unknown image resources attached as parasites to re-save later */\n  GimpParasite  *parasite;\n  gchar         *data;\n  gchar         *name;\n\n  IFDBG(2) g_debug (\"Process unknown image resource block: %d\", res_a->id);\n\n  data = g_malloc (res_a->data_len);\n  if (fread (data, res_a->data_len, 1, f) < 1)\n    {\n      psd_set_error (feof (f), errno, error);\n      return -1;\n    }\n\n  name = g_strdup_printf (\"psd-image-resource-%.4s-%.4x\",\n                            res_a->type, res_a->id);\n  IFDBG(2) g_debug (\"Parasite name: %s\", name);\n\n  parasite = gimp_parasite_new (name, 0, res_a->data_len, data);\n  gimp_image_parasite_attach (image_id, parasite);\n  gimp_parasite_free (parasite);\n  g_free (data);\n  g_free (name);\n\n  return 0;\n}\n- PSD_LADJ_MIXER: #define PSD_LADJ_MIXER          \"mixr\"          /* Adjustment layer - channel mixer (PS9) */ /* <=== plug-ins/file-psd/psd.h:79:79:PSD_LADJ_MIXER:0 */ \n- gimp_layer_set_lock_alpha: void /* <=== gimp_layer_set_lock_alpha */ \ngimp_layer_set_lock_alpha (GimpLayer *layer,\n                           gboolean   lock_alpha,\n                           gboolean   push_undo)\n{\n  g_return_if_fail (GIMP_IS_LAYER (layer));\n\n  lock_alpha = lock_alpha ? TRUE : FALSE;\n\n  if (layer->lock_alpha != lock_alpha)\n    {\n      if (push_undo && gimp_item_is_attached (GIMP_ITEM (layer)))\n        {\n          GimpImage *image = gimp_item_get_image (GIMP_ITEM (layer));\n\n          gimp_image_undo_push_layer_lock_alpha (image, NULL, layer);\n        }\n\n      layer->lock_alpha = lock_alpha;\n\n      g_signal_emit (layer, layer_signals[LOCK_ALPHA_CHANGED], 0);\n      g_object_notify (G_OBJECT (layer), \"lock-alpha\");\n    }\n}\n- PSD_LADJ_HUE: #define PSD_LADJ_HUE            \"hue \"          /* Adjustment layer - old hue/saturation (PS4) */ /* <=== plug-ins/file-psd/psd.h:76:76:PSD_LADJ_HUE:0 */ \n- gimp_tile_flush: void    gimp_tile_flush        (GimpTile  *tile); /* <=== gimp_tile_flush */ \n- gimp_drawable_bpp: gint /* <=== gimp_drawable_bpp */ \ngimp_drawable_bpp (gint32 drawable_ID)\n{\n  GimpParam *return_vals;\n  gint nreturn_vals;\n  gint bpp = 0;\n\n  return_vals = gimp_run_procedure (\"gimp-drawable-bpp\",\n                                    &nreturn_vals,\n                                    GIMP_PDB_DRAWABLE, drawable_ID,\n                                    GIMP_PDB_END);\n\n  if (return_vals[0].data.d_status == GIMP_PDB_SUCCESS)\n    bpp = return_vals[1].data.d_int32;\n\n  gimp_destroy_params (return_vals, nreturn_vals);\n\n  return bpp;\n}\n- convert_16_bit: static void /* <=== convert_16_bit */ \nconvert_16_bit (const gchar *src,\n                gchar       *dst,\n                guint32     len)\n{\n/* Convert 16 bit to 8 bit dropping low byte\n*/\n  gint      i;\n\n  IFDBG(3)  g_debug (\"Start 16 bit conversion\");\n\n  for (i = 0; i < len >> 1; ++i)\n    {\n      *dst = *src;\n      dst++;\n      src += 2;\n    }\n\n  IFDBG(3)  g_debug (\"End 16 bit conversion\");\n}\n- PSD_LADJ_BALANCE: #define PSD_LADJ_BALANCE        \"blnc\"          /* Adjustment layer - color balance (PS4) */ /* <=== plug-ins/file-psd/psd.h:74:74:PSD_LADJ_BALANCE:0 */ \n- PSD_LADJ_BRIGHTNESS: #define PSD_LADJ_BRIGHTNESS     \"brit\"          /* Adjustment layer - brightness/contrast (PS4) */ /* <=== plug-ins/file-psd/psd.h:73:73:PSD_LADJ_BRIGHTNESS:0 */ \n- GIMP_ITEM: #define GIMP_ITEM(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_ITEM, GimpItem)) /* <=== app/core/gimpitem.h:27:27:GIMP_ITEM:1 */ \n- load_resource_lsct: static gint /* <=== load_resource_lsct */ \nload_resource_lsct (const PSDlayerres  *res_a,\n                    PSDlayer           *lyr_a,\n                    FILE               *f,\n                    GError            **error)\n{\n  /* Load adjustment layer */\n  static gboolean   msg_flag = FALSE;\n  guint32           type;\n\n  IFDBG(2) g_debug (\"Process layer resource block %.4s: Section divider\", res_a->key);\n  if (fread (&type, 4, 1, f) < 1)\n    {\n      psd_set_error (feof (f), errno, error);\n      return -1;\n    }\n  type = GUINT32_FROM_BE (type);\n  IFDBG(3) g_debug (\"Section divider type: %i\", type);\n\n  if (type == 1 ||      /* Layer group start - open folder */\n      type == 2)        /* Layer group start - closed folder */\n    {\n      lyr_a->drop = TRUE;\n      if (! msg_flag && CONVERSION_WARNINGS)\n        {\n          g_message (\"Warning:\\n\"\n                     \"The image file contains layer groups. \"\n                     \"These are not supported by the GIMP and will \"\n                     \"be dropped.\");\n          msg_flag = TRUE;\n        }\n    }\n\n  if (type == 3)        /* End of layer group - hidden in UI */\n      lyr_a->drop = TRUE;\n\n\n  return 0;\n}\n- PSD_LADJ_SELECTIVE: #define PSD_LADJ_SELECTIVE      \"selc\"          /* Adjustment layer - selective color (PS4) */ /* <=== plug-ins/file-psd/psd.h:78:78:PSD_LADJ_SELECTIVE:0 */ \n- TILE_HEIGHT: #define TILE_HEIGHT gimp_tile_height() /* <=== libgimp/gimpdrawable.c:28:28:TILE_HEIGHT:0 */ \n- gimp_image_set_active_layer: gboolean /* <=== gimp_image_set_active_layer */ \ngimp_image_set_active_layer (gint32 image_ID,\n                             gint32 active_layer_ID)\n{\n  GimpParam *return_vals;\n  gint nreturn_vals;\n  gboolean success = TRUE;\n\n  return_vals = gimp_run_procedure (\"gimp-image-set-active-layer\",\n                                    &nreturn_vals,\n                                    GIMP_PDB_IMAGE, image_ID,\n                                    GIMP_PDB_LAYER, active_layer_ID,\n                                    GIMP_PDB_END);\n\n  success = return_vals[0].data.d_status == GIMP_PDB_SUCCESS;\n\n  gimp_destroy_params (return_vals, nreturn_vals);\n\n  return success;\n}\n- GIMP_CHANNEL: #define GIMP_CHANNEL(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_CHANNEL, GimpChannel)) /* <=== app/core/gimpchannel.h:26:26:GIMP_CHANNEL:1 */ \n- gimp_pixel_rgn_set_rect: void /* <=== gimp_pixel_rgn_set_rect */ \ngimp_pixel_rgn_set_rect (GimpPixelRgn *pr,\n                         const guchar *buf,\n                         gint          x,\n                         gint          y,\n                         gint          width,\n                         gint          height)\n{\n  gulong  bufstride;\n  gint    xstart, ystart;\n  gint    xend, yend;\n  gint    xboundary;\n  gint    yboundary;\n  gint    xstep, ystep;\n  gint    ty, bpp;\n\n  g_return_if_fail (pr != NULL && pr->drawable != NULL);\n  g_return_if_fail (buf != NULL);\n  g_return_if_fail (x >= 0 && x + width  <= pr->drawable->width);\n  g_return_if_fail (y >= 0 && y + height <= pr->drawable->height);\n  g_return_if_fail (width >= 0);\n  g_return_if_fail (height >= 0);\n\n  bpp = pr->bpp;\n  bufstride = bpp * width;\n\n  xstart = x;\n  ystart = y;\n  xend = x + width;\n  yend = y + height;\n  ystep = 0;\n\n  while (y < yend)\n    {\n      x = xstart;\n\n      while (x < xend)\n        {\n          GimpTile *tile;\n\n          tile = gimp_drawable_get_tile2 (pr->drawable, pr->shadow, x, y);\n          gimp_tile_ref (tile);\n\n          xstep = tile->ewidth - (x % TILE_WIDTH);\n          ystep = tile->eheight - (y % TILE_HEIGHT);\n          xboundary = x + xstep;\n          yboundary = y + ystep;\n          xboundary = MIN (xboundary, xend);\n          yboundary = MIN (yboundary, yend);\n\n          for (ty = y; ty < yboundary; ty++)\n            {\n              const guchar *src;\n              guchar       *dest;\n\n              src = buf + bufstride * (ty - ystart) + bpp * (x - xstart);\n              dest = tile->data + tile->bpp * (tile->ewidth *\n                                               (ty % TILE_HEIGHT) + (x % TILE_WIDTH));\n\n              memcpy (dest, src, (xboundary - x) * bpp);\n            }\n\n          gimp_tile_unref (tile, TRUE);\n          x += xstep;\n        }\n\n      y += ystep;\n    }\n}\n- psd_set_error: void /* <=== psd_set_error */ \npsd_set_error (const gboolean   file_eof,\n               const gint       err_no,\n               GError         **error)\n{\n  if (file_eof)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   \"%s\", _(\"Unexpected end of file\"));\n    }\n  else\n    {\n      g_set_error (error, G_FILE_ERROR, g_file_error_from_errno (err_no),\n                   \"%s\", g_strerror (err_no));\n    }\n\n  return;\n}\n- TILE_WIDTH: #define TILE_WIDTH  gimp_tile_width() /* <=== libgimp/gimppixelrgn.c:30:30:TILE_WIDTH:0 */ \n- get_layer_resource_header: gint /* <=== get_layer_resource_header */ \nget_layer_resource_header (PSDlayerres  *res_a,\n                           FILE         *f,\n                           GError      **error)\n{\n  if (fread (res_a->sig, 4, 1, f) < 1\n      || fread (res_a->key, 4, 1, f) < 1\n      || fread (&res_a->data_len, 4, 1, f) < 1)\n    {\n      psd_set_error (feof (f), errno, error);\n      return -1;\n    }\n  res_a->data_len = GUINT32_FROM_BE (res_a->data_len);\n  res_a->data_start = ftell (f);\n\n  IFDBG(2) g_debug (\"Sig: %.4s, key: %.4s, start: %d, len: %d\",\n                     res_a->sig, res_a->key, res_a->data_start, res_a->data_len);\n\n  return 0;\n}\n- PSD_LADJ_CURVE: #define PSD_LADJ_CURVE          \"curv\"          /* Adjustment layer - curves (PS4) */ /* <=== plug-ins/file-psd/psd.h:72:72:PSD_LADJ_CURVE:0 */ \n- gimp_layer_create_mask: GimpLayerMask * /* <=== gimp_layer_create_mask */ \ngimp_layer_create_mask (const GimpLayer *layer,\n                        GimpAddMaskType  add_mask_type,\n                        GimpChannel     *channel)\n{\n  GimpDrawable  *drawable;\n  GimpItem      *item;\n  PixelRegion    srcPR;\n  PixelRegion    destPR;\n  GimpLayerMask *mask;\n  GimpImage     *image;\n  gchar         *mask_name;\n  GimpRGB        black = { 0.0, 0.0, 0.0, GIMP_OPACITY_OPAQUE };\n\n  g_return_val_if_fail (GIMP_IS_LAYER (layer), NULL);\n  g_return_val_if_fail (add_mask_type != GIMP_ADD_CHANNEL_MASK ||\n                        GIMP_IS_CHANNEL (channel), NULL);\n\n  drawable = GIMP_DRAWABLE (layer);\n  item     = GIMP_ITEM (layer);\n  image    = gimp_item_get_image (item);\n\n  mask_name = g_strdup_printf (_(\"%s mask\"),\n                               gimp_object_get_name (GIMP_OBJECT (layer)));\n\n  mask = gimp_layer_mask_new (image,\n                              gimp_item_width  (item),\n                              gimp_item_height (item),\n                              mask_name, &black);\n\n  g_free (mask_name);\n\n  switch (add_mask_type)\n    {\n    case GIMP_ADD_WHITE_MASK:\n      gimp_channel_all (GIMP_CHANNEL (mask), FALSE);\n      return mask;\n\n    case GIMP_ADD_BLACK_MASK:\n      gimp_channel_clear (GIMP_CHANNEL (mask), NULL, FALSE);\n      return mask;\n\n    default:\n      break;\n    }\n\n  pixel_region_init (&destPR, gimp_drawable_get_tiles (GIMP_DRAWABLE (mask)),\n                     0, 0,\n                     gimp_item_width  (GIMP_ITEM (mask)),\n                     gimp_item_height (GIMP_ITEM (mask)),\n                     TRUE);\n\n  switch (add_mask_type)\n    {\n    case GIMP_ADD_WHITE_MASK:\n    case GIMP_ADD_BLACK_MASK:\n      break;\n\n    case GIMP_ADD_ALPHA_MASK:\n    case GIMP_ADD_ALPHA_TRANSFER_MASK:\n      if (gimp_drawable_has_alpha (drawable))\n        {\n          pixel_region_init (&srcPR, gimp_drawable_get_tiles (drawable),\n                             0, 0,\n                             gimp_item_width  (item),\n                             gimp_item_height (item),\n                             FALSE);\n\n          extract_alpha_region (&srcPR, NULL, &destPR);\n\n          if (add_mask_type == GIMP_ADD_ALPHA_TRANSFER_MASK)\n            {\n              void   *pr;\n              gint    w, h;\n              guchar *alpha_ptr;\n\n              gimp_drawable_push_undo (drawable,\n                                       _(\"Transfer Alpha to Mask\"),\n                                       0, 0,\n                                       gimp_item_width  (item),\n                                       gimp_item_height (item),\n                                       NULL, FALSE);\n\n              pixel_region_init (&srcPR, gimp_drawable_get_tiles (drawable),\n                                 0, 0,\n                                 gimp_item_width  (item),\n                                 gimp_item_height (item),\n                                 TRUE);\n\n              for (pr = pixel_regions_register (1, &srcPR);\n                   pr != NULL;\n                   pr = pixel_regions_process (pr))\n                {\n                  h = srcPR.h;\n\n                  while (h--)\n                    {\n                      w = srcPR.w;\n                      alpha_ptr = (srcPR.data + h * srcPR.rowstride +\n                                   srcPR.bytes - 1);\n\n                      while (w--)\n                        {\n                          *alpha_ptr = OPAQUE_OPACITY;\n                          alpha_ptr += srcPR.bytes;\n                        }\n                    }\n                }\n            }\n        }\n      break;\n\n    case GIMP_ADD_SELECTION_MASK:\n    case GIMP_ADD_CHANNEL_MASK:\n      {\n        gboolean channel_empty;\n        gint     copy_x, copy_y;\n        gint     copy_width, copy_height;\n\n        if (add_mask_type == GIMP_ADD_SELECTION_MASK)\n          channel = GIMP_CHANNEL (gimp_image_get_mask (image));\n\n        channel_empty = gimp_channel_is_empty (channel);\n\n        gimp_rectangle_intersect (0, 0,\n                                  gimp_image_get_width  (image),\n                                  gimp_image_get_height (image),\n                                  item->offset_x, item->offset_y,\n                                  gimp_item_width  (item),\n                                  gimp_item_height (item),\n                                  &copy_x, &copy_y,\n                                  &copy_width, &copy_height);\n\n        if (copy_width  < gimp_item_width  (item) ||\n            copy_height < gimp_item_height (item) ||\n            channel_empty)\n          gimp_channel_clear (GIMP_CHANNEL (mask), NULL, FALSE);\n\n        if ((copy_width || copy_height) && ! channel_empty)\n          {\n            pixel_region_init (&srcPR,\n                               gimp_drawable_get_tiles (GIMP_DRAWABLE (channel)),\n                               copy_x, copy_y,\n                               copy_width, copy_height,\n                               FALSE);\n            pixel_region_init (&destPR,\n                               gimp_drawable_get_tiles (GIMP_DRAWABLE (mask)),\n                               copy_x - item->offset_x, copy_y - item->offset_y,\n                               copy_width, copy_height,\n                               TRUE);\n\n            copy_region (&srcPR, &destPR);\n\n            GIMP_CHANNEL (mask)->bounds_known = FALSE;\n          }\n      }\n      break;\n\n    case GIMP_ADD_COPY_MASK:\n      {\n        TileManager   *copy_tiles = NULL;\n        GimpImageType  layer_type;\n\n        layer_type = drawable->type;\n\n        if (GIMP_IMAGE_TYPE_BASE_TYPE (layer_type) != GIMP_GRAY)\n          {\n            GimpImageType copy_type;\n\n            copy_type = (GIMP_IMAGE_TYPE_HAS_ALPHA (layer_type) ?\n                         GIMP_GRAYA_IMAGE : GIMP_GRAY_IMAGE);\n\n            copy_tiles = tile_manager_new (gimp_item_width  (item),\n                                           gimp_item_height (item),\n                                           GIMP_IMAGE_TYPE_BYTES (copy_type));\n\n            gimp_drawable_convert_grayscale (drawable,\n                                             copy_tiles,\n                                             GIMP_IMAGE_TYPE_BASE_TYPE (layer_type));\n\n            pixel_region_init (&srcPR, copy_tiles,\n                               0, 0,\n                               gimp_item_width  (item),\n                               gimp_item_height (item),\n                               FALSE);\n          }\n        else\n          {\n            pixel_region_init (&srcPR, gimp_drawable_get_tiles (drawable),\n                               0, 0,\n                               gimp_item_width  (item),\n                               gimp_item_height (item),\n                               FALSE);\n          }\n\n        if (gimp_drawable_has_alpha (drawable))\n          {\n            guchar black_uchar[] = { 0, 0, 0, 0 };\n\n            flatten_region (&srcPR, &destPR, black_uchar);\n          }\n        else\n          {\n            copy_region (&srcPR, &destPR);\n          }\n\n        if (copy_tiles)\n          tile_manager_unref (copy_tiles);\n      }\n\n      GIMP_CHANNEL (mask)->bounds_known = FALSE;\n      break;\n    }\n\n  return mask;\n}\n- MAX_CHANNELS: #define MAX_CHANNELS     4 /* <=== app/base/base-types.h:36:36:MAX_CHANNELS:0 */ \n- load_resource_lyid: static gint /* <=== load_resource_lyid */ \nload_resource_lyid (const PSDlayerres  *res_a,\n                    PSDlayer           *lyr_a,\n                    FILE               *f,\n                    GError            **error)\n{\n  /* Load layer id (tattoo) */\n\n  IFDBG(2) g_debug (\"Process layer resource block lyid: Layer ID\");\n  if (fread (&lyr_a->id, 4, 1, f) < 1)\n    {\n      psd_set_error (feof (f), errno, error);\n      return -1;\n    }\n  lyr_a->id = GUINT32_FROM_BE (lyr_a->id);\n  IFDBG(3) g_debug (\"Layer id: %i\", lyr_a->id);\n\n  return 0;\n}\n- gimp_tile_ref: void    gimp_tile_ref          (GimpTile  *tile); /* <=== gimp_tile_ref */ \n- gimp_drawable_has_alpha: gboolean /* <=== gimp_drawable_has_alpha */ \ngimp_drawable_has_alpha (gint32 drawable_ID)\n{\n  GimpParam *return_vals;\n  gint nreturn_vals;\n  gboolean has_alpha = FALSE;\n\n  return_vals = gimp_run_procedure (\"gimp-drawable-has-alpha\",\n                                    &nreturn_vals,\n                                    GIMP_PDB_DRAWABLE, drawable_ID,\n                                    GIMP_PDB_END);\n\n  if (return_vals[0].data.d_status == GIMP_PDB_SUCCESS)\n    has_alpha = return_vals[1].data.d_int32;\n\n  gimp_destroy_params (return_vals, nreturn_vals);\n\n  return has_alpha;\n}\n- gimp_destroy_params: void /* <=== gimp_destroy_params */ \ngimp_destroy_params (GimpParam *params,\n                     gint       n_params)\n{\n  gp_params_destroy ((GPParam *) params, n_params);\n}\n- PSD_LFIL_GRADIENT: #define PSD_LFIL_GRADIENT       \"GdFl\"          /* Gradient fill setting (PS6) */ /* <=== plug-ins/file-psd/psd.h:90:90:PSD_LFIL_GRADIENT:0 */ \n- gimp_image_floating_selection_changed: void /* <=== gimp_image_floating_selection_changed */ \ngimp_image_floating_selection_changed (GimpImage *image)\n{\n  g_return_if_fail (GIMP_IS_IMAGE (image));\n\n  g_signal_emit (image, gimp_image_signals[FLOATING_SELECTION_CHANGED], 0);\n}\n- gimp_layer_set_lock_alpha: gboolean /* <=== gimp_layer_set_lock_alpha */ \ngimp_layer_set_lock_alpha (gint32   layer_ID,\n                           gboolean lock_alpha)\n{\n  GimpParam *return_vals;\n  gint nreturn_vals;\n  gboolean success = TRUE;\n\n  return_vals = gimp_run_procedure (\"gimp-layer-set-lock-alpha\",\n                                    &nreturn_vals,\n                                    GIMP_PDB_LAYER, layer_ID,\n                                    GIMP_PDB_INT32, lock_alpha,\n                                    GIMP_PDB_END);\n\n  success = return_vals[0].data.d_status == GIMP_PDB_SUCCESS;\n\n  gimp_destroy_params (return_vals, nreturn_vals);\n\n  return success;\n}\n- gimp_drawable_get: GimpDrawable * /* <=== gimp_drawable_get */ \ngimp_drawable_get (gint32 drawable_ID)\n{\n  GimpDrawable *drawable;\n  gint          width;\n  gint          height;\n  gint          bpp;\n\n  width  = gimp_drawable_width  (drawable_ID);\n  height = gimp_drawable_height (drawable_ID);\n  bpp    = gimp_drawable_bpp    (drawable_ID);\n\n  g_return_val_if_fail (width > 0 && height > 0 && bpp > 0, NULL);\n\n  drawable = g_slice_new0 (GimpDrawable);\n\n  drawable->drawable_id  = drawable_ID;\n  drawable->width        = width;\n  drawable->height       = height;\n  drawable->bpp          = bpp;\n  drawable->ntile_rows   = (height + TILE_HEIGHT - 1) / TILE_HEIGHT;\n  drawable->ntile_cols   = (width  + TILE_WIDTH  - 1) / TILE_WIDTH;\n\n  return drawable;\n}\n- gimp_drawable_fill: void /* <=== gimp_drawable_fill */ \ngimp_drawable_fill (GimpDrawable      *drawable,\n                    const GimpRGB     *color,\n                    const GimpPattern *pattern)\n{\n  GimpItem      *item;\n  GimpImage     *image;\n  GimpImageType  drawable_type;\n  PixelRegion    destPR;\n\n  g_return_if_fail (GIMP_IS_DRAWABLE (drawable));\n  g_return_if_fail (color != NULL || pattern != NULL);\n  g_return_if_fail (pattern == NULL || GIMP_IS_PATTERN (pattern));\n\n  item  = GIMP_ITEM (drawable);\n  image = gimp_item_get_image (item);\n\n  drawable_type = gimp_drawable_type (drawable);\n\n  pixel_region_init (&destPR, gimp_drawable_get_tiles (drawable),\n                     0, 0, gimp_item_width  (item), gimp_item_height (item),\n                     TRUE);\n\n  if (color)\n    {\n      guchar tmp[MAX_CHANNELS];\n      guchar c[MAX_CHANNELS];\n\n      gimp_rgba_get_uchar (color,\n                           &tmp[RED_PIX],\n                           &tmp[GREEN_PIX],\n                           &tmp[BLUE_PIX],\n                           &tmp[ALPHA_PIX]);\n\n      gimp_image_transform_color (image, drawable_type, c, GIMP_RGB, tmp);\n\n      if (GIMP_IMAGE_TYPE_HAS_ALPHA (drawable_type))\n        c[GIMP_IMAGE_TYPE_BYTES (drawable_type) - 1] = tmp[ALPHA_PIX];\n      else\n        c[GIMP_IMAGE_TYPE_BYTES (drawable_type)] = OPAQUE_OPACITY;\n\n      color_region (&destPR, c);\n    }\n  else\n    {\n      TempBuf  *pat_buf;\n      gboolean  new_buf;\n\n      pat_buf = gimp_image_transform_temp_buf (image, drawable_type,\n                                               pattern->mask, &new_buf);\n\n      pattern_region (&destPR, NULL, pat_buf, 0, 0);\n\n      if (new_buf)\n        temp_buf_free (pat_buf);\n    }\n\n  gimp_drawable_update (drawable,\n                        0, 0,\n                        gimp_item_width  (item),\n                        gimp_item_height (item));\n}\n- gimp_drawable_type: GimpImageType /* <=== gimp_drawable_type */ \ngimp_drawable_type (const GimpDrawable *drawable)\n{\n  g_return_val_if_fail (GIMP_IS_DRAWABLE (drawable), -1);\n\n  return drawable->type;\n}\n- gimp_drawable_fill: gboolean /* <=== gimp_drawable_fill */ \ngimp_drawable_fill (gint32       drawable_ID,\n                    GimpFillType fill_type)\n{\n  GimpParam *return_vals;\n  gint nreturn_vals;\n  gboolean success = TRUE;\n\n  return_vals = gimp_run_procedure (\"gimp-drawable-fill\",\n                                    &nreturn_vals,\n                                    GIMP_PDB_DRAWABLE, drawable_ID,\n                                    GIMP_PDB_INT32, fill_type,\n                                    GIMP_PDB_END);\n\n  success = return_vals[0].data.d_status == GIMP_PDB_SUCCESS;\n\n  gimp_destroy_params (return_vals, nreturn_vals);\n\n  return success;\n}\n- GIMP_OPACITY_TRANSPARENT: #define GIMP_OPACITY_TRANSPARENT      0.0 /* <=== app/core/core-types.h:33:33:GIMP_OPACITY_TRANSPARENT:0 */ \n- GIMP_IS_LAYER_MASK: #define GIMP_IS_LAYER_MASK(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_LAYER_MASK)) /* <=== app/core/gimplayermask.h:29:29:GIMP_IS_LAYER_MASK:1 */ \n- gimp_layer_set_offsets: gboolean /* <=== gimp_layer_set_offsets */ \ngimp_layer_set_offsets (gint32 layer_ID,\n                        gint   offx,\n                        gint   offy)\n{\n  GimpParam *return_vals;\n  gint nreturn_vals;\n  gboolean success = TRUE;\n\n  return_vals = gimp_run_procedure (\"gimp-layer-set-offsets\",\n                                    &nreturn_vals,\n                                    GIMP_PDB_LAYER, layer_ID,\n                                    GIMP_PDB_INT32, offx,\n                                    GIMP_PDB_INT32, offy,\n                                    GIMP_PDB_END);\n\n  success = return_vals[0].data.d_status == GIMP_PDB_SUCCESS;\n\n  gimp_destroy_params (return_vals, nreturn_vals);\n\n  return success;\n}\n- gimp_image_get_mask: GimpChannel * /* <=== gimp_image_get_mask */ \ngimp_image_get_mask (const GimpImage *image)\n{\n  g_return_val_if_fail (GIMP_IS_IMAGE (image), NULL);\n\n  return image->selection_mask;\n}\n- get_gimp_image_type: static GimpImageType /* <=== get_gimp_image_type */ \nget_gimp_image_type (const GimpImageBaseType image_base_type,\n                     const gboolean          alpha)\n{\n  GimpImageType image_type;\n\n  switch (image_base_type)\n    {\n      case GIMP_GRAY:\n        image_type = (alpha) ? GIMP_GRAYA_IMAGE : GIMP_GRAY_IMAGE;\n        break;\n\n      case GIMP_INDEXED:\n        image_type = (alpha) ? GIMP_INDEXEDA_IMAGE : GIMP_INDEXED_IMAGE;\n        break;\n\n      case GIMP_RGB:\n        image_type = (alpha) ? GIMP_RGBA_IMAGE : GIMP_RGB_IMAGE;\n        break;\n\n      default:\n        image_type = -1;\n        break;\n    }\n\n  return image_type;\n}\n- CONVERSION_WARNINGS: #define CONVERSION_WARNINGS             FALSE /* <=== plug-ins/file-psd/psd.h:39:39:CONVERSION_WARNINGS:0 */ \n- PSD_LFX_FX: #define PSD_LFX_FX              \"lrFX\"          /* Effects layer info (PS5) */ /* <=== plug-ins/file-psd/psd.h:93:93:PSD_LFX_FX:0 */ \n- load_resource_ltyp: static gint /* <=== load_resource_ltyp */ \nload_resource_ltyp (const PSDlayerres  *res_a,\n                    PSDlayer           *lyr_a,\n                    FILE               *f,\n                    GError            **error)\n{\n  /* Load type tool layer */\n  gint16            version;\n  gint16            text_desc_vers;\n  gint32            desc_version;\n  guint64           t_xx;\n  guint64           t_xy;\n  guint64           t_yx;\n  guint64           t_yy;\n  guint64           t_tx;\n  guint64           t_ty;\n  gdouble           transform_xx;\n  gdouble           transform_xy;\n  gdouble           transform_yx;\n  gdouble           transform_yy;\n  gdouble           transform_tx;\n  gdouble           transform_ty;\n\n  static gboolean   msg_flag = FALSE;\n\n  IFDBG(2) g_debug (\"Process layer resource block %.4s: Type tool layer\", res_a->key);\n  if (! msg_flag && CONVERSION_WARNINGS)\n    {\n      g_message (\"Warning:\\n\"\n                 \"The image file contains type tool layers. \"\n                 \"These are not supported by the GIMP and will \"\n                 \"be dropped.\");\n      msg_flag = TRUE;\n    }\n\n  /* New style type tool layers (ps6) */\n  if (memcmp (res_a->key, PSD_LTYP_TYPE2, 4) == 0)\n    {\n      if (fread (&version, 2, 1, f) < 1\n          || fread (&t_xx, 8, 1, f) < 1\n          || fread (&t_xy, 8, 1, f) < 1\n          || fread (&t_yx, 8, 1, f) < 1\n          || fread (&t_yy, 8, 1, f) < 1\n          || fread (&t_tx, 8, 1, f) < 1\n          || fread (&t_ty, 8, 1, f) < 1\n          || fread (&text_desc_vers, 2, 1, f) < 1\n          || fread (&desc_version, 4, 1, f) < 1)\n        {\n          psd_set_error (feof (f), errno, error);\n          return -1;\n        }\n\n      version = GINT16_FROM_BE (version);\n      text_desc_vers = GINT16_FROM_BE (text_desc_vers);\n      desc_version = GINT32_FROM_BE (desc_version);\n//      t_xx = GUINT64_FROM_BE (t_xx);\n//      t_xy = GUINT64_FROM_BE (t_xy);\n//      t_yx = GUINT64_FROM_BE (t_yx);\n//      t_yy = GUINT64_FROM_BE (t_yy);\n//      t_tx = GUINT64_FROM_BE (t_tx);\n//      t_ty = GUINT64_FROM_BE (t_ty);\n\n      transform_xx = t_xx >> 11;\n      transform_xy = t_xy >> 11;\n      transform_yx = t_yx >> 11;\n      transform_yy = t_yy >> 11;\n      transform_tx = t_tx >> 11;\n      transform_ty = t_ty >> 11;\n\n      IFDBG(2) g_debug (\"Version: %d, Text desc. vers.: %d, Desc. vers.: %d\",\n                        version, text_desc_vers, desc_version);\n\n      IFDBG(2) g_debug (\"Transform\\n\\txx: %f\\n\\txy: %f\\n\\tyx: %f\"\n                        \"\\n\\tyy: %f\\n\\ttx: %f\\n\\tty: %f\",\n                        transform_xx, transform_xy, transform_yx,\n                        transform_yy, transform_tx, transform_ty);\n\n//      classID = fread_unicode_string (&read_len, &write_len, 4, f);\n//      IFDBG(2) g_debug (\"Unicode name: %s\", classID);\n\n    }\n\n  return 0;\n}\n- GIMP_TYPE_LAYER: #define GIMP_TYPE_LAYER            (gimp_layer_get_type ()) /* <=== app/core/gimplayer.h:26:26:GIMP_TYPE_LAYER:0 */ \n- PSD_LADJ_EXPOSURE: #define PSD_LADJ_EXPOSURE       \"expA\"          /* Adjustment layer - exposure (PS10) */ /* <=== plug-ins/file-psd/psd.h:82:82:PSD_LADJ_EXPOSURE:0 */ \n- convert_1_bit: static void /* <=== convert_1_bit */ \nconvert_1_bit (const gchar *src,\n               gchar       *dst,\n               guint32      rows,\n               guint32      columns)\n{\n/* Convert bits to bytes left to right by row.\n   Rows are padded out to a byte boundry.\n*/\n  guint32 row_pos = 0;\n  gint    i, j;\n\n  IFDBG(3)  g_debug (\"Start 1 bit conversion\");\n\n  for (i = 0; i < rows * ((columns + 7) >> 3); ++i)\n    {\n      guchar    mask = 0x80;\n      for (j = 0; j < 8 && row_pos < columns; ++j)\n        {\n          *dst = (*src & mask) ? 0 : 1;\n          IFDBG(3) g_debug (\"byte %d, bit %d, offset %d, src %d, dst %d\",\n            i , j, row_pos, *src, *dst);\n          dst++;\n          mask >>= 1;\n          row_pos++;\n        }\n      if (row_pos >= columns)\n        row_pos = 0;\n      src++;\n    }\n  IFDBG(3)  g_debug (\"End 1 bit conversion\");\n}\n- gimp_layer_add_mask: GimpLayerMask * /* <=== gimp_layer_add_mask */ \ngimp_layer_add_mask (GimpLayer      *layer,\n                     GimpLayerMask  *mask,\n                     gboolean        push_undo,\n                     GError        **error)\n{\n  GimpImage *image;\n\n  g_return_val_if_fail (GIMP_IS_LAYER (layer), NULL);\n  g_return_val_if_fail (GIMP_IS_LAYER_MASK (mask), NULL);\n  g_return_val_if_fail (gimp_item_get_image (GIMP_ITEM (layer)) ==\n                        gimp_item_get_image (GIMP_ITEM (mask)), NULL);\n  g_return_val_if_fail (error == NULL || *error == NULL, NULL);\n\n  if (! gimp_item_is_attached (GIMP_ITEM (layer)))\n    push_undo = FALSE;\n\n  image = gimp_item_get_image (GIMP_ITEM (layer));\n\n  if (layer->mask)\n    {\n      g_set_error (error, 0, 0,\n                   _(\"Unable to add a layer mask since \"\n                     \"the layer already has one.\"));\n      return NULL;\n    }\n\n  if ((gimp_item_width (GIMP_ITEM (layer)) !=\n       gimp_item_width (GIMP_ITEM (mask))) ||\n      (gimp_item_height (GIMP_ITEM (layer)) !=\n       gimp_item_height (GIMP_ITEM (mask))))\n    {\n      g_set_error (error, 0, 0,\n                   _(\"Cannot add layer mask of different \"\n                     \"dimensions than specified layer.\"));\n      return NULL;\n    }\n\n  if (push_undo)\n    gimp_image_undo_push_layer_mask_add (image, _(\"Add Layer Mask\"),\n                                         layer, mask);\n\n  layer->mask = g_object_ref_sink (mask);\n\n  gimp_layer_mask_set_layer (mask, layer);\n\n  if (gimp_layer_mask_get_apply (mask) ||\n      gimp_layer_mask_get_show (mask))\n    {\n      gimp_drawable_update (GIMP_DRAWABLE (layer),\n                            0, 0,\n                            gimp_item_width  (GIMP_ITEM (layer)),\n                            gimp_item_height (GIMP_ITEM (layer)));\n    }\n\n  g_signal_connect (mask, \"update\",\n                    G_CALLBACK (gimp_layer_layer_mask_update),\n                    layer);\n\n  g_signal_emit (layer, layer_signals[MASK_CHANGED], 0);\n\n  return layer->mask;\n}\n- gimp_drawable_type: GimpImageType /* <=== gimp_drawable_type */ \ngimp_drawable_type (gint32 drawable_ID)\n{\n  GimpParam *return_vals;\n  gint nreturn_vals;\n  GimpImageType type = 0;\n\n  return_vals = gimp_run_procedure (\"gimp-drawable-type\",\n                                    &nreturn_vals,\n                                    GIMP_PDB_DRAWABLE, drawable_ID,\n                                    GIMP_PDB_END);\n\n  if (return_vals[0].data.d_status == GIMP_PDB_SUCCESS)\n    type = return_vals[1].data.d_int32;\n\n  gimp_destroy_params (return_vals, nreturn_vals);\n\n  return type;\n}\n- gimp_image_get_height: gint /* <=== gimp_image_get_height */ \ngimp_image_get_height (const GimpImage *image)\n{\n  g_return_val_if_fail (GIMP_IS_IMAGE (image), 0);\n\n  return image->height;\n}\n- gimp_drawable_height: gint /* <=== gimp_drawable_height */ \ngimp_drawable_height (gint32 drawable_ID)\n{\n  GimpParam *return_vals;\n  gint nreturn_vals;\n  gint height = 0;\n\n  return_vals = gimp_run_procedure (\"gimp-drawable-height\",\n                                    &nreturn_vals,\n                                    GIMP_PDB_DRAWABLE, drawable_ID,\n                                    GIMP_PDB_END);\n\n  if (return_vals[0].data.d_status == GIMP_PDB_SUCCESS)\n    height = return_vals[1].data.d_int32;\n\n  gimp_destroy_params (return_vals, nreturn_vals);\n\n  return height;\n}\n- gimp_drawable_configure: void /* <=== gimp_drawable_configure */ \ngimp_drawable_configure (GimpDrawable  *drawable,\n                         GimpImage     *image,\n                         gint           offset_x,\n                         gint           offset_y,\n                         gint           width,\n                         gint           height,\n                         GimpImageType  type,\n                         const gchar   *name)\n{\n  g_return_if_fail (GIMP_IS_DRAWABLE (drawable));\n  g_return_if_fail (GIMP_IS_IMAGE (image));\n  g_return_if_fail (width > 0 && height > 0);\n\n  gimp_item_configure (GIMP_ITEM (drawable), image,\n                       offset_x, offset_y, width, height, name);\n\n  drawable->type      = type;\n  drawable->bytes     = GIMP_IMAGE_TYPE_BYTES (type);\n  drawable->has_alpha = GIMP_IMAGE_TYPE_HAS_ALPHA (type);\n\n  if (drawable->tiles)\n    tile_manager_unref (drawable->tiles);\n\n  drawable->tiles = tile_manager_new (width, height, drawable->bytes);\n\n  /*  preview variables  */\n  drawable->preview_cache = NULL;\n  drawable->preview_valid = FALSE;\n}\n- GIMP_OBJECT: #define GIMP_OBJECT(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_OBJECT, GimpObject)) /* <=== app/core/gimpobject.h:24:24:GIMP_OBJECT:1 */ \n- gimp_image_get_active_layer: gint32 /* <=== gimp_image_get_active_layer */ \ngimp_image_get_active_layer (gint32 image_ID)\n{\n  GimpParam *return_vals;\n  gint nreturn_vals;\n  gint32 active_layer_ID = -1;\n\n  return_vals = gimp_run_procedure (\"gimp-image-get-active-layer\",\n                                    &nreturn_vals,\n                                    GIMP_PDB_IMAGE, image_ID,\n                                    GIMP_PDB_END);\n\n  if (return_vals[0].data.d_status == GIMP_PDB_SUCCESS)\n    active_layer_ID = return_vals[1].data.d_layer;\n\n  gimp_destroy_params (return_vals, nreturn_vals);\n\n  return active_layer_ID;\n}\n- decode_packbits: gint /* <=== decode_packbits */ \ndecode_packbits (const gchar *src,\n                 gchar       *dst,\n                 guint16      packed_len,\n                 guint32      unpacked_len)\n{\n/*\n *  Decode a PackBits chunk.\n */\n  gint      n;\n  gchar     dat;\n  gint32    unpack_left = unpacked_len;\n  gint32    pack_left = packed_len;\n  gint32    error_code = 0;\n  gint32    return_val = 0;\n\n  while (unpack_left > 0 && pack_left > 0)\n    {\n      n = *src;\n      src++;\n      pack_left--;\n\n      if (n == 128)     /* nop */\n        continue;\n      else if (n > 128)\n        n -= 256;\n\n      if (n < 0)        /* replicate next gchar |n|+ 1 times */\n        {\n          n  = 1 - n;\n          if (! pack_left)\n            {\n              IFDBG(2) g_debug (\"Input buffer exhausted in replicate\");\n              error_code = 1;\n              break;\n            }\n          if (n > unpack_left)\n            {\n              IFDBG(2) g_debug (\"Overrun in packbits replicate of %d chars\", n - unpack_left);\n              error_code = 2;\n            }\n          dat = *src;\n          for (; n > 0; --n)\n            {\n              if (! unpack_left)\n                break;\n              *dst = dat;\n              dst++;\n              unpack_left--;\n            }\n          if (unpack_left)\n            {\n              src++;\n              pack_left--;\n            }\n        }\n      else              /* copy next n+1 gchars literally */\n        {\n          n++;\n          for (; n > 0; --n)\n            {\n              if (! pack_left)\n                {\n                  IFDBG(2) g_debug (\"Input buffer exhausted in copy\");\n                  error_code = 3;\n                  break;\n                }\n              if (! unpack_left)\n                {\n                  IFDBG(2) g_debug (\"Output buffer exhausted in copy\");\n                  error_code = 4;\n                  break;\n                }\n              *dst = *src;\n              dst++;\n              unpack_left--;\n              src++;\n              pack_left--;\n            }\n        }\n    }\n\n  if (unpack_left > 0)\n    {\n      /* Pad with zeros to end of output buffer */\n      for (n = 0; n < pack_left; ++n)\n        {\n          *dst = 0;\n          dst++;\n        }\n    }\n\n  if (unpack_left)\n    {\n      IFDBG(2) g_debug (\"Packbits decode - unpack left %d\", unpack_left);\n      return_val -= unpack_left;\n    }\n  if (pack_left)\n    {\n      /* Some images seem to have a pad byte at the end of the packed data */\n      if (error_code || pack_left != 1)\n        {\n          IFDBG(2) g_debug (\"Packbits decode - pack left %d\", pack_left);\n          return_val = pack_left;\n        }\n    }\n\n  IFDBG(2)\n    if (error_code)\n      g_debug (\"Error code %d\", error_code);\n\n  return return_val;\n}\n- gimp_drawable_get_tile2: GimpTile * /* <=== gimp_drawable_get_tile2 */ \ngimp_drawable_get_tile2 (GimpDrawable *drawable,\n                         gboolean      shadow,\n                         gint          x,\n                         gint          y)\n{\n  gint row;\n  gint col;\n\n  g_return_val_if_fail (drawable != NULL, NULL);\n\n  col = x / TILE_WIDTH;\n  row = y / TILE_HEIGHT;\n\n  return gimp_drawable_get_tile (drawable, shadow, row, col);\n}\n- PSD_LFX_FX2: #define PSD_LFX_FX2             \"lfx2\"          /* Object based effects layer info (PS6) */ /* <=== plug-ins/file-psd/psd.h:94:94:PSD_LFX_FX2:0 */ \n- gimp_tile_width: guint /* <=== gimp_tile_width */ \ngimp_tile_width (void)\n{\n  return _tile_width;\n}\n- PSD_LFIL_PATTERN: #define PSD_LFIL_PATTERN        \"PtFl\"          /* Pattern fill setting (PS6) */ /* <=== plug-ins/file-psd/psd.h:89:89:PSD_LFIL_PATTERN:0 */ \n- GIMP_OPACITY_OPAQUE: #define GIMP_OPACITY_OPAQUE           1.0 /* <=== app/core/core-types.h:34:34:GIMP_OPACITY_OPAQUE:0 */ \n- load_resource_lfx: static gint /* <=== load_resource_lfx */ \nload_resource_lfx (const PSDlayerres  *res_a,\n                   PSDlayer           *lyr_a,\n                   FILE               *f,\n                   GError            **error)\n{\n  /* Load layer effects */\n  static gboolean   msg_flag = FALSE;\n\n  IFDBG(2) g_debug (\"Process layer resource block %.4s: Layer effects\", res_a->key);\n  if (! msg_flag && CONVERSION_WARNINGS)\n    {\n      g_message (\"Warning:\\n\"\n                 \"The image file contains layer effects. \"\n                 \"These are not supported by the GIMP and will \"\n                 \"be dropped.\");\n      msg_flag = TRUE;\n    }\n\n  return 0;\n}\n- convert_16_bit: static void /* <=== convert_16_bit */ \nconvert_16_bit (const gchar *src,\n                gchar       *dst,\n                guint32     len)\n{\n/* Convert 16 bit to 8 bit dropping low byte\n*/\n  gint      i;\n\n  IFDBG(3)  g_debug (\"Start 16 bit conversion\");\n\n  for (i = 0; i < len >> 1; ++i)\n    {\n      *dst = *src;\n      dst++;\n      src += 2;\n    }\n\n  IFDBG(3)  g_debug (\"End 16 bit conversion\");\n}\n- gimp_drawable_set_visible: gboolean /* <=== gimp_drawable_set_visible */ \ngimp_drawable_set_visible (gint32   drawable_ID,\n                           gboolean visible)\n{\n  GimpParam *return_vals;\n  gint nreturn_vals;\n  gboolean success = TRUE;\n\n  return_vals = gimp_run_procedure (\"gimp-drawable-set-visible\",\n                                    &nreturn_vals,\n                                    GIMP_PDB_DRAWABLE, drawable_ID,\n                                    GIMP_PDB_INT32, visible,\n                                    GIMP_PDB_END);\n\n  success = return_vals[0].data.d_status == GIMP_PDB_SUCCESS;\n\n  gimp_destroy_params (return_vals, nreturn_vals);\n\n  return success;\n}\n- PSD_LADJ_HUE2: #define PSD_LADJ_HUE2           \"hue2\"          /* Adjustment layer - hue/saturation (PS5) */ /* <=== plug-ins/file-psd/psd.h:77:77:PSD_LADJ_HUE2:0 */ \n- gimp_tile_unref: void    gimp_tile_unref        (GimpTile  *tile, /* <=== gimp_tile_unref */ \n                                gboolean   dirty);\n- GIMP_IS_PATTERN: #define GIMP_IS_PATTERN(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_PATTERN)) /* <=== app/core/gimppattern.h:29:29:GIMP_IS_PATTERN:1 */ \n- IFDBG: #define IFDBG(level) if (PSD_DEBUG >= level) /* <=== plug-ins/file-psd/psd.h:36:36:IFDBG:1 */ \n- gimp_image_transform_color: void /* <=== gimp_image_transform_color */ \ngimp_image_transform_color (const GimpImage    *dest_image,\n                            GimpImageType       dest_type,\n                            guchar             *dest,\n                            GimpImageBaseType   src_type,\n                            const guchar       *src)\n{\n  g_return_if_fail (GIMP_IS_IMAGE (dest_image));\n  g_return_if_fail (src_type != GIMP_INDEXED);\n\n  switch (src_type)\n    {\n    case GIMP_RGB:\n      switch (dest_type)\n        {\n        case GIMP_RGB_IMAGE:\n        case GIMP_RGBA_IMAGE:\n          /*  Straight copy  */\n          *dest++ = *src++;\n          *dest++ = *src++;\n          *dest++ = *src++;\n          break;\n\n        case GIMP_GRAY_IMAGE:\n        case GIMP_GRAYA_IMAGE:\n          /*  NTSC conversion  */\n          *dest = GIMP_RGB_LUMINANCE (src[RED_PIX],\n                                      src[GREEN_PIX],\n                                      src[BLUE_PIX]) + 0.5;\n          break;\n\n        case GIMP_INDEXED_IMAGE:\n        case GIMP_INDEXEDA_IMAGE:\n          /*  Least squares method  */\n          *dest = gimp_image_color_hash_rgb_to_indexed (dest_image,\n                                                        src[RED_PIX],\n                                                        src[GREEN_PIX],\n                                                        src[BLUE_PIX]);\n          break;\n        }\n      break;\n\n    case GIMP_GRAY:\n      switch (dest_type)\n        {\n        case GIMP_RGB_IMAGE:\n        case GIMP_RGBA_IMAGE:\n          /*  Gray to RG&B */\n          *dest++ = *src;\n          *dest++ = *src;\n          *dest++ = *src;\n          break;\n\n        case GIMP_GRAY_IMAGE:\n        case GIMP_GRAYA_IMAGE:\n          /*  Straight copy  */\n          *dest = *src;\n          break;\n\n        case GIMP_INDEXED_IMAGE:\n        case GIMP_INDEXEDA_IMAGE:\n          /*  Least squares method  */\n          *dest = gimp_image_color_hash_rgb_to_indexed (dest_image,\n                                                        src[GRAY_PIX],\n                                                        src[GRAY_PIX],\n                                                        src[GRAY_PIX]);\n          break;\n        }\n      break;\n\n    default:\n      break;\n    }\n}\n- gimp_drawable_set_tattoo: gboolean /* <=== gimp_drawable_set_tattoo */ \ngimp_drawable_set_tattoo (gint32 drawable_ID,\n                          gint   tattoo)\n{\n  GimpParam *return_vals;\n  gint nreturn_vals;\n  gboolean success = TRUE;\n\n  return_vals = gimp_run_procedure (\"gimp-drawable-set-tattoo\",\n                                    &nreturn_vals,\n                                    GIMP_PDB_DRAWABLE, drawable_ID,\n                                    GIMP_PDB_INT32, tattoo,\n                                    GIMP_PDB_END);\n\n  success = return_vals[0].data.d_status == GIMP_PDB_SUCCESS;\n\n  gimp_destroy_params (return_vals, nreturn_vals);\n\n  return success;\n}\n- PSD_LADJ_GRAD_MAP: #define PSD_LADJ_GRAD_MAP       \"grdm\"          /* Adjustment layer - gradient map (PS9) */ /* <=== plug-ins/file-psd/psd.h:80:80:PSD_LADJ_GRAD_MAP:0 */ \n- gimp_image_get_width: gint /* <=== gimp_image_get_width */ \ngimp_image_get_width (const GimpImage *image)\n{\n  g_return_val_if_fail (GIMP_IS_IMAGE (image), 0);\n\n  return image->width;\n}\n- PSD_LPRP_UNICODE: #define PSD_LPRP_UNICODE        \"luni\"          /* Unicode layer name (PS5) */ /* <=== plug-ins/file-psd/psd.h:101:101:PSD_LPRP_UNICODE:0 */ \n- PSD_LTYP_TYPE: #define PSD_LTYP_TYPE           \"tySh\"          /* Type tool layer (PS5) */ /* <=== plug-ins/file-psd/psd.h:97:97:PSD_LTYP_TYPE:0 */ \n- gimp_drawable_has_alpha: gboolean /* <=== gimp_drawable_has_alpha */ \ngimp_drawable_has_alpha (const GimpDrawable *drawable)\n{\n  g_return_val_if_fail (GIMP_IS_DRAWABLE (drawable), FALSE);\n\n  return drawable->has_alpha;\n}\n- RED_PIX: #define RED_PIX          0 /* <=== app/base/base-types.h:40:40:RED_PIX:0 */ \n- gimp_tile_height: guint /* <=== gimp_tile_height */ \ngimp_tile_height (void)\n{\n  return _tile_height;\n}\n- gimp_layer_add_mask: gboolean /* <=== gimp_layer_add_mask */ \ngimp_layer_add_mask (gint32 layer_ID,\n                     gint32 mask_ID)\n{\n  GimpParam *return_vals;\n  gint nreturn_vals;\n  gboolean success = TRUE;\n\n  return_vals = gimp_run_procedure (\"gimp-layer-add-mask\",\n                                    &nreturn_vals,\n                                    GIMP_PDB_LAYER, layer_ID,\n                                    GIMP_PDB_CHANNEL, mask_ID,\n                                    GIMP_PDB_END);\n\n  success = return_vals[0].data.d_status == GIMP_PDB_SUCCESS;\n\n  gimp_destroy_params (return_vals, nreturn_vals);\n\n  return success;\n}\n- gimp_image_get_active_layer: GimpLayer * /* <=== gimp_image_get_active_layer */ \ngimp_image_get_active_layer (const GimpImage *image)\n{\n  g_return_val_if_fail (GIMP_IS_IMAGE (image), NULL);\n\n  return image->active_layer;\n}\n- PSD_LOTH_SECTION: #define PSD_LOTH_SECTION        \"lsct\"          /* Section divider setting - Layer goups (PS6) */ /* <=== plug-ins/file-psd/psd.h:118:118:PSD_LOTH_SECTION:0 */ \n- PSD_LADJ_POSTERIZE: #define PSD_LADJ_POSTERIZE      \"post\"          /* Adjustment layer - posterize (PS4) */ /* <=== plug-ins/file-psd/psd.h:85:85:PSD_LADJ_POSTERIZE:0 */ \n- OPAQUE_OPACITY: #define OPAQUE_OPACITY             255 /* <=== app/paint-funcs/paint-funcs-types.h:28:28:OPAQUE_OPACITY:0 */ \n- PSD_LADJ_LEVEL: #define PSD_LADJ_LEVEL          \"levl\"          /* Adjustment layer - levels (PS4) */ /* <=== plug-ins/file-psd/psd.h:71:71:PSD_LADJ_LEVEL:0 */ \n- GIMP_IMAGE_TYPE_HAS_ALPHA: #define GIMP_IMAGE_TYPE_HAS_ALPHA(t)       ((t) == GIMP_RGBA_IMAGE  ||       \\ /* <=== app/core/gimpimage.h:33:35:GIMP_IMAGE_TYPE_HAS_ALPHA:1 */ \n                                            (t) == GIMP_GRAYA_IMAGE ||       \\\n                                            (t) == GIMP_INDEXEDA_IMAGE)\n- PSD_LADJ_THRESHOLD: #define PSD_LADJ_THRESHOLD      \"thrs\"          /* Adjustment layer - threshold (PS4) */ /* <=== plug-ins/file-psd/psd.h:84:84:PSD_LADJ_THRESHOLD:0 */ \n- load_resource_lfil: static gint /* <=== load_resource_lfil */ \nload_resource_lfil (const PSDlayerres  *res_a,\n                    PSDlayer           *lyr_a,\n                    FILE               *f,\n                    GError            **error)\n{\n  /* Load fill layer */\n  static gboolean   msg_flag = FALSE;\n\n  IFDBG(2) g_debug (\"Process layer resource block %.4s: Fill layer\", res_a->key);\n  if (! msg_flag && CONVERSION_WARNINGS)\n    {\n      g_message (\"Warning:\\n\"\n                 \"The image file contains fill layers. \"\n                 \"These are not supported by the GIMP and will \"\n                 \"be rasterized.\");\n      msg_flag = TRUE;\n    }\n\n  return 0;\n}\n- gimp_image_floating_sel: GimpLayer * /* <=== gimp_image_floating_sel */ \ngimp_image_floating_sel (const GimpImage *image)\n{\n  g_return_val_if_fail (GIMP_IS_IMAGE (image), NULL);\n\n  return image->floating_sel;\n}\n- _gimp_tile_cache_flush_drawable: G_GNUC_INTERNAL void _gimp_tile_cache_flush_drawable (GimpDrawable *drawable); /* <=== _gimp_tile_cache_flush_drawable */ \n- gimp_image_add_layer: gboolean /* <=== gimp_image_add_layer */ \ngimp_image_add_layer (gint32 image_ID,\n                      gint32 layer_ID,\n                      gint   position)\n{\n  GimpParam *return_vals;\n  gint nreturn_vals;\n  gboolean success = TRUE;\n\n  return_vals = gimp_run_procedure (\"gimp-image-add-layer\",\n                                    &nreturn_vals,\n                                    GIMP_PDB_IMAGE, image_ID,\n                                    GIMP_PDB_LAYER, layer_ID,\n                                    GIMP_PDB_INT32, position,\n                                    GIMP_PDB_END);\n\n  success = return_vals[0].data.d_status == GIMP_PDB_SUCCESS;\n\n  gimp_destroy_params (return_vals, nreturn_vals);\n\n  return success;\n}\n- gimp_image_transform_temp_buf: TempBuf * /* <=== gimp_image_transform_temp_buf */ \ngimp_image_transform_temp_buf (const GimpImage *dest_image,\n                               GimpImageType    dest_type,\n                               TempBuf         *temp_buf,\n                               gboolean        *new_buf)\n{\n  TempBuf       *ret_buf;\n  GimpImageType  ret_buf_type;\n  gboolean       has_alpha;\n  gboolean       is_rgb;\n  gint           in_bytes;\n  gint           out_bytes;\n\n  g_return_val_if_fail (GIMP_IMAGE (dest_image), NULL);\n  g_return_val_if_fail (temp_buf != NULL, NULL);\n  g_return_val_if_fail (new_buf != NULL, NULL);\n\n  in_bytes  = temp_buf->bytes;\n\n  has_alpha = (in_bytes == 2 || in_bytes == 4);\n  is_rgb    = (in_bytes == 3 || in_bytes == 4);\n\n  if (has_alpha)\n    ret_buf_type = GIMP_IMAGE_TYPE_WITH_ALPHA (dest_type);\n  else\n    ret_buf_type = GIMP_IMAGE_TYPE_WITHOUT_ALPHA (dest_type);\n\n  out_bytes = GIMP_IMAGE_TYPE_BYTES (ret_buf_type);\n\n  /*  If the pattern doesn't match the image in terms of color type,\n   *  transform it.  (ie  pattern is RGB, image is indexed)\n   */\n  if (in_bytes != out_bytes || GIMP_IMAGE_TYPE_IS_INDEXED (dest_type))\n    {\n      guchar *src;\n      guchar *dest;\n      gint    size;\n\n      ret_buf = temp_buf_new (temp_buf->width, temp_buf->height,\n                              out_bytes, 0, 0, NULL);\n\n      src  = temp_buf_data (temp_buf);\n      dest = temp_buf_data (ret_buf);\n\n      size = temp_buf->width * temp_buf->height;\n\n      while (size--)\n        {\n          gimp_image_transform_color (dest_image, dest_type, dest,\n                                      is_rgb ? GIMP_RGB : GIMP_GRAY, src);\n\n          /* Handle alpha */\n          if (has_alpha)\n            dest[out_bytes - 1] = src[in_bytes - 1];\n\n          src  += in_bytes;\n          dest += out_bytes;\n        }\n\n      *new_buf = TRUE;\n    }\n  else\n    {\n      ret_buf = temp_buf;\n      *new_buf = FALSE;\n    }\n\n  return ret_buf;\n}\n- gimp_image_alpha_changed: void /* <=== gimp_image_alpha_changed */ \ngimp_image_alpha_changed (GimpImage *image)\n{\n  g_return_if_fail (GIMP_IS_IMAGE (image));\n\n  g_signal_emit (image, gimp_image_signals[ALPHA_CHANGED], 0);\n}\n- MAX_CHANNELS: #define MAX_CHANNELS    56              /* Photoshop CS to CS3 support 56 channels */ /* <=== plug-ins/file-psd/psd.h:64:64:MAX_CHANNELS:0 */ \n- load_layer_resource: gint /* <=== load_layer_resource */ \nload_layer_resource (PSDlayerres  *res_a,\n                     PSDlayer     *lyr_a,\n                     FILE         *f,\n                     GError      **error)\n{\n  /* Set file position to start of layer resource data block */\n  if (fseek (f, res_a->data_start, SEEK_SET) < 0)\n    {\n      psd_set_error (feof (f), errno, error);\n      return -1;\n    }\n\n   /* Process layer resource blocks */\n  if (memcmp (res_a->sig, \"8BIM\", 4) != 0)\n    {\n      IFDBG(1) g_debug (\"Unknown layer resource signature %.4s\", res_a->sig);\n    }\n  else\n    {\n      if (memcmp (res_a->key, PSD_LADJ_LEVEL, 4) == 0\n          || memcmp (res_a->key, PSD_LADJ_CURVE, 4) == 0\n          || memcmp (res_a->key, PSD_LADJ_BRIGHTNESS, 4) == 0\n          || memcmp (res_a->key, PSD_LADJ_BALANCE, 4) == 0\n          || memcmp (res_a->key, PSD_LADJ_BLACK_WHITE, 4) == 0\n          || memcmp (res_a->key, PSD_LADJ_HUE, 4) == 0\n          || memcmp (res_a->key, PSD_LADJ_HUE2, 4) == 0\n          || memcmp (res_a->key, PSD_LADJ_SELECTIVE, 4) == 0\n          || memcmp (res_a->key, PSD_LADJ_MIXER, 4) == 0\n          || memcmp (res_a->key, PSD_LADJ_GRAD_MAP, 4) == 0\n          || memcmp (res_a->key, PSD_LADJ_PHOTO_FILT, 4) == 0\n          || memcmp (res_a->key, PSD_LADJ_EXPOSURE, 4) == 0\n          || memcmp (res_a->key, PSD_LADJ_THRESHOLD, 4) == 0\n          || memcmp (res_a->key, PSD_LADJ_INVERT, 4) == 0\n          || memcmp (res_a->key, PSD_LADJ_POSTERIZE, 4) == 0)\n            load_resource_ladj (res_a, lyr_a, f, error);\n\n      else if (memcmp (res_a->key, PSD_LFIL_SOLID, 4) == 0\n          || memcmp (res_a->key, PSD_LFIL_PATTERN, 4) == 0\n          || memcmp (res_a->key, PSD_LFIL_GRADIENT, 4) == 0)\n            load_resource_lfil (res_a, lyr_a, f, error);\n\n      else if (memcmp (res_a->key, PSD_LFX_FX, 4) == 0\n          || memcmp (res_a->key, PSD_LFX_FX2, 4) == 0)\n            load_resource_lfx (res_a, lyr_a, f, error);\n\n      else if (memcmp (res_a->key, PSD_LTYP_TYPE, 4) == 0\n          || memcmp (res_a->key, PSD_LTYP_TYPE2, 4) == 0)\n            load_resource_ltyp (res_a, lyr_a, f, error);\n\n      else if (memcmp (res_a->key, PSD_LPRP_UNICODE, 4) == 0)\n            load_resource_luni (res_a, lyr_a, f, error);\n\n      else if (memcmp (res_a->key, PSD_LPRP_ID, 4) == 0)\n            load_resource_lyid (res_a, lyr_a, f, error);\n\n      else if (memcmp (res_a->key, PSD_LOTH_SECTION, 4) == 0)\n            load_resource_lsct (res_a, lyr_a, f, error);\n\n      else\n        load_resource_unknown (res_a, lyr_a, f, error);\n    }\n\n  /* Set file position to end of layer resource block */\n  if (fseek (f, res_a->data_start + res_a->data_len, SEEK_SET) < 0)\n    {\n      psd_set_error (feof (f), errno, error);\n      return -1;\n    }\n\n  return 0;\n}\n- gimp_image_has_alpha: gboolean /* <=== gimp_image_has_alpha */ \ngimp_image_has_alpha (const GimpImage *image)\n{\n  GimpLayer *layer;\n\n  g_return_val_if_fail (GIMP_IS_IMAGE (image), TRUE);\n\n  layer = (GimpLayer *) gimp_container_get_child_by_index (image->layers, 0);\n\n  return ((gimp_container_num_children (image->layers) > 1) ||\n          (layer && gimp_drawable_has_alpha (GIMP_DRAWABLE (layer))));\n}\n- PSD_LADJ_INVERT: #define PSD_LADJ_INVERT         \"nvrt\"          /* Adjustment layer - invert (PS4) */ /* <=== plug-ins/file-psd/psd.h:83:83:PSD_LADJ_INVERT:0 */ \n- gimp_layer_new: GimpLayer * /* <=== gimp_layer_new */ \ngimp_layer_new (GimpImage            *image,\n                gint                  width,\n                gint                  height,\n                GimpImageType         type,\n                const gchar          *name,\n                gdouble               opacity,\n                GimpLayerModeEffects  mode)\n{\n  GimpLayer *layer;\n\n  g_return_val_if_fail (GIMP_IS_IMAGE (image), NULL);\n  g_return_val_if_fail (width > 0, NULL);\n  g_return_val_if_fail (height > 0, NULL);\n\n  layer = g_object_new (GIMP_TYPE_LAYER, NULL);\n\n  gimp_drawable_configure (GIMP_DRAWABLE (layer),\n                           image,\n                           0, 0, width, height,\n                           type,\n                           name);\n\n  opacity = CLAMP (opacity, GIMP_OPACITY_TRANSPARENT, GIMP_OPACITY_OPAQUE);\n\n  layer->opacity = opacity;\n  layer->mode    = mode;\n\n  return layer;\n}\n- GIMP_IMAGE_TYPE_BASE_TYPE: #define GIMP_IMAGE_TYPE_BASE_TYPE(t)      (((t) == GIMP_RGB_IMAGE ||         \\ /* <=== app/core/gimpimage.h:61:69:GIMP_IMAGE_TYPE_BASE_TYPE:1 */ \n                                            (t) == GIMP_RGBA_IMAGE) ?        \\\n                                           GIMP_RGB :                        \\\n                                           ((t) == GIMP_GRAY_IMAGE ||        \\\n                                            (t) == GIMP_GRAYA_IMAGE) ?       \\\n                                           GIMP_GRAY :                       \\\n                                           ((t) == GIMP_INDEXED_IMAGE ||     \\\n                                            (t) == GIMP_INDEXEDA_IMAGE) ?    \\\n                                           GIMP_INDEXED : -1)\n- load_resource_unknown: static gint /* <=== load_resource_unknown */ \nload_resource_unknown (const PSDlayerres  *res_a,\n                       PSDlayer           *lyr_a,\n                       FILE               *f,\n                       GError            **error)\n{\n  IFDBG(2) g_debug (\"Process unknown layer resource block: %.4s\", res_a->key);\n\n  return 0;\n}\n- GIMP_DRAWABLE: #define GIMP_DRAWABLE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), GIMP_TYPE_DRAWABLE, GimpDrawable)) /* <=== app/core/gimpdrawable.h:27:27:GIMP_DRAWABLE:1 */ \n- psd_to_gimp_blend_mode: GimpLayerModeEffects /* <=== psd_to_gimp_blend_mode */ \npsd_to_gimp_blend_mode (const gchar *psd_mode)\n{\n  if (g_ascii_strncasecmp (psd_mode, \"norm\", 4) == 0)           /* Normal (ps3) */\n    return GIMP_NORMAL_MODE;\n  if (g_ascii_strncasecmp (psd_mode, \"dark\", 4) == 0)           /* Darken (ps3) */\n    return GIMP_DARKEN_ONLY_MODE;\n  if (g_ascii_strncasecmp (psd_mode, \"lite\", 4) == 0)           /* Lighten (ps3) */\n      return GIMP_LIGHTEN_ONLY_MODE;\n  if (g_ascii_strncasecmp (psd_mode, \"hue \", 4) == 0)           /* Hue (ps3) */\n    return GIMP_HUE_MODE;\n  if (g_ascii_strncasecmp (psd_mode, \"sat \", 4) == 0)           /* Saturation (ps3) */\n    {\n      if (CONVERSION_WARNINGS)\n        {\n          static gchar  *mode_name = \"SATURATION\";\n          g_message (\"Gimp uses a different equation to photoshop for \"\n                     \"blend mode: %s. Results will differ.\",\n                     mode_name);\n        }\n      return GIMP_SATURATION_MODE;\n    }\n  if (g_ascii_strncasecmp (psd_mode, \"colr\", 4) == 0)           /* Color (ps3) */\n    return GIMP_COLOR_MODE;\n  if (g_ascii_strncasecmp (psd_mode, \"lum \", 4) == 0)           /* Luminosity (ps3) */\n    {\n      if (CONVERSION_WARNINGS)\n        {\n          static gchar  *mode_name = \"LUMINOSITY (VALUE)\";\n          g_message (\"Gimp uses a different equation to photoshop for \"\n                     \"blend mode: %s. Results will differ.\",\n                     mode_name);\n        }\n      return GIMP_VALUE_MODE;\n    }\n  if (g_ascii_strncasecmp (psd_mode, \"mul \", 4) == 0)           /* Multiply (ps3) */\n    return GIMP_MULTIPLY_MODE;\n  if (g_ascii_strncasecmp (psd_mode, \"scrn\", 4) == 0)           /* Screen (ps3) */\n    return GIMP_SCREEN_MODE;\n  if (g_ascii_strncasecmp (psd_mode, \"diss\", 4) == 0)           /* Dissolve (ps3) */\n    return GIMP_DISSOLVE_MODE;\n  if (g_ascii_strncasecmp (psd_mode, \"over\", 4) == 0)           /* Overlay (ps3) */\n    {\n      if (CONVERSION_WARNINGS)\n        {\n          static gchar  *mode_name = \"OVERLAY\";\n          g_message (\"Gimp uses a different equation to photoshop for \"\n                     \"blend mode: %s. Results will differ.\",\n                     mode_name);\n        }\n      return GIMP_OVERLAY_MODE;\n    }\n  if (g_ascii_strncasecmp (psd_mode, \"hLit\", 4) == 0)           /* Hard light (ps3) */\n    return GIMP_HARDLIGHT_MODE;\n  if (g_ascii_strncasecmp (psd_mode, \"sLit\", 4) == 0)           /* Soft light (ps3) */\n    {\n      if (CONVERSION_WARNINGS)\n        {\n          static gchar  *mode_name = \"SOFT LIGHT\";\n          g_message (\"Gimp uses a different equation to photoshop for \"\n                     \"blend mode: %s. Results will differ.\",\n                     mode_name);\n        }\n    return GIMP_SOFTLIGHT_MODE;\n    }\n  if (g_ascii_strncasecmp (psd_mode, \"diff\", 4) == 0)           /* Difference (ps3) */\n    return GIMP_DIFFERENCE_MODE;\n  if (g_ascii_strncasecmp (psd_mode, \"smud\", 4) == 0)           /* Exclusion (ps6) */\n    {\n      if (CONVERSION_WARNINGS)\n        {\n          static gchar  *mode_name = \"EXCLUSION\";\n          g_message (\"Unsupported blend mode: %s. Mode reverts to normal\",\n                     mode_name);\n        }\n      return GIMP_NORMAL_MODE;\n    }\n  if (g_ascii_strncasecmp (psd_mode, \"div \", 4) == 0)           /* Color dodge (ps6) */\n      return GIMP_DODGE_MODE;\n  if (g_ascii_strncasecmp (psd_mode, \"idiv\", 4) == 0)           /* Color burn (ps6) */\n      return GIMP_BURN_MODE;\n  if (g_ascii_strncasecmp (psd_mode, \"lbrn\", 4) == 0)           /* Linear burn (ps7)*/\n    {\n      if (CONVERSION_WARNINGS)\n        {\n          static gchar  *mode_name = \"LINEAR BURN\";\n          g_message (\"Unsupported blend mode: %s. Mode reverts to normal\",\n                     mode_name);\n        }\n      return GIMP_NORMAL_MODE;\n    }\n  if (g_ascii_strncasecmp (psd_mode, \"lddg\", 4) == 0)           /* Linear dodge (ps7)*/\n    return GIMP_ADDITION_MODE;\n  if (g_ascii_strncasecmp (psd_mode, \"lLit\", 4) == 0)           /* Linear light (ps7)*/\n    {\n      if (CONVERSION_WARNINGS)\n        {\n          static gchar  *mode_name = \"LINEAR LIGHT\";\n          g_message (\"Unsupported blend mode: %s. Mode reverts to normal\",\n                     mode_name);\n        }\n      return GIMP_NORMAL_MODE;\n    }\n  if (g_ascii_strncasecmp (psd_mode, \"pLit\", 4) == 0)           /* Pin light (ps7)*/\n    {\n      if (CONVERSION_WARNINGS)\n        {\n          static gchar  *mode_name = \"PIN LIGHT\";\n          g_message (\"Unsupported blend mode: %s. Mode reverts to normal\",\n                     mode_name);\n        }\n      return GIMP_NORMAL_MODE;\n    }\n  if (g_ascii_strncasecmp (psd_mode, \"vLit\", 4) == 0)           /* Vivid light (ps7)*/\n    {\n      if (CONVERSION_WARNINGS)\n        {\n          static gchar  *mode_name = \"VIVID LIGHT\";\n          g_message (\"Unsupported blend mode: %s. Mode reverts to normal\",\n                     mode_name);\n        }\n      return GIMP_NORMAL_MODE;\n    }\n  if (g_ascii_strncasecmp (psd_mode, \"hMix\", 4) == 0)           /* Hard Mix (CS)*/\n    {\n      if (CONVERSION_WARNINGS)\n        {\n          static gchar  *mode_name = \"HARD MIX\";\n          g_message (\"Unsupported blend mode: %s. Mode reverts to normal\",\n                     mode_name);\n        }\n      return GIMP_NORMAL_MODE;\n    }\n\n  if (CONVERSION_WARNINGS)\n    {\n      gchar  *mode_name = g_strndup (psd_mode, 4);\n      g_message (\"Unsupported blend mode: %s. Mode reverts to normal\",\n                 mode_name);\n      g_free (mode_name);\n    }\n  return GIMP_NORMAL_MODE;\n}\n- gimp_run_procedure: GimpParam * /* <=== gimp_run_procedure */ \ngimp_run_procedure (const gchar *name,\n                    gint        *n_return_vals,\n                    ...)\n{\n  GimpPDBArgType  param_type;\n  GimpParam      *return_vals;\n  GimpParam      *params   = NULL;\n  gint            n_params = 0;\n  va_list         args;\n  gint            i;\n\n  g_return_val_if_fail (name != NULL, NULL);\n  g_return_val_if_fail (n_return_vals != NULL, NULL);\n\n  va_start (args, n_return_vals);\n  param_type = va_arg (args, GimpPDBArgType);\n\n  while (param_type != GIMP_PDB_END)\n    {\n      switch (param_type)\n        {\n        case GIMP_PDB_INT32:\n        case GIMP_PDB_DISPLAY:\n        case GIMP_PDB_IMAGE:\n        case GIMP_PDB_LAYER:\n        case GIMP_PDB_CHANNEL:\n        case GIMP_PDB_DRAWABLE:\n        case GIMP_PDB_SELECTION:\n        case GIMP_PDB_VECTORS:\n        case GIMP_PDB_STATUS:\n          (void) va_arg (args, gint);\n          break;\n        case GIMP_PDB_INT16:\n          (void) va_arg (args, gint);\n          break;\n        case GIMP_PDB_INT8:\n          (void) va_arg (args, gint);\n          break;\n        case GIMP_PDB_FLOAT:\n          (void) va_arg (args, gdouble);\n          break;\n        case GIMP_PDB_STRING:\n          (void) va_arg (args, gchar *);\n          break;\n        case GIMP_PDB_INT32ARRAY:\n          (void) va_arg (args, gint32 *);\n          break;\n        case GIMP_PDB_INT16ARRAY:\n          (void) va_arg (args, gint16 *);\n          break;\n        case GIMP_PDB_INT8ARRAY:\n          (void) va_arg (args, gint8 *);\n          break;\n        case GIMP_PDB_FLOATARRAY:\n          (void) va_arg (args, gdouble *);\n          break;\n        case GIMP_PDB_STRINGARRAY:\n          (void) va_arg (args, gchar **);\n          break;\n        case GIMP_PDB_COLOR:\n\tcase GIMP_PDB_COLORARRAY:\n          (void) va_arg (args, GimpRGB *);\n          break;\n        case GIMP_PDB_PARASITE:\n          (void) va_arg (args, GimpParasite *);\n          break;\n        case GIMP_PDB_REGION:\n          break;\n        case GIMP_PDB_END:\n          break;\n        }\n\n      n_params++;\n\n      param_type = va_arg (args, GimpPDBArgType);\n    }\n\n  va_end (args);\n\n  params = g_new0 (GimpParam, n_params);\n\n  va_start (args, n_return_vals);\n\n  for (i = 0; i < n_params; i++)\n    {\n      params[i].type = va_arg (args, GimpPDBArgType);\n\n      switch (params[i].type)\n        {\n        case GIMP_PDB_INT32:\n          params[i].data.d_int32 = (gint32) va_arg (args, gint);\n          break;\n        case GIMP_PDB_INT16:\n          params[i].data.d_int16 = (gint16) va_arg (args, gint);\n          break;\n        case GIMP_PDB_INT8:\n          params[i].data.d_int8 = (guint8) va_arg (args, gint);\n          break;\n        case GIMP_PDB_FLOAT:\n          params[i].data.d_float = (gdouble) va_arg (args, gdouble);\n          break;\n        case GIMP_PDB_STRING:\n          params[i].data.d_string = va_arg (args, gchar *);\n          break;\n        case GIMP_PDB_INT32ARRAY:\n          params[i].data.d_int32array = va_arg (args, gint32 *);\n          break;\n        case GIMP_PDB_INT16ARRAY:\n          params[i].data.d_int16array = va_arg (args, gint16 *);\n          break;\n        case GIMP_PDB_INT8ARRAY:\n          params[i].data.d_int8array = va_arg (args, guint8 *);\n          break;\n        case GIMP_PDB_FLOATARRAY:\n          params[i].data.d_floatarray = va_arg (args, gdouble *);\n          break;\n        case GIMP_PDB_STRINGARRAY:\n          params[i].data.d_stringarray = va_arg (args, gchar **);\n          break;\n        case GIMP_PDB_COLOR:\n          params[i].data.d_color = *va_arg (args, GimpRGB *);\n          break;\n        case GIMP_PDB_REGION:\n          break;\n        case GIMP_PDB_DISPLAY:\n          params[i].data.d_display = va_arg (args, gint32);\n          break;\n        case GIMP_PDB_IMAGE:\n          params[i].data.d_image = va_arg (args, gint32);\n          break;\n        case GIMP_PDB_LAYER:\n          params[i].data.d_layer = va_arg (args, gint32);\n          break;\n        case GIMP_PDB_CHANNEL:\n          params[i].data.d_channel = va_arg (args, gint32);\n          break;\n        case GIMP_PDB_DRAWABLE:\n          params[i].data.d_drawable = va_arg (args, gint32);\n          break;\n        case GIMP_PDB_SELECTION:\n          params[i].data.d_selection = va_arg (args, gint32);\n          break;\n        case GIMP_PDB_COLORARRAY:\n          params[i].data.d_colorarray = va_arg (args, GimpRGB *);\n          break;\n        case GIMP_PDB_VECTORS:\n          params[i].data.d_vectors = va_arg (args, gint32);\n          break;\n        case GIMP_PDB_PARASITE:\n          {\n            GimpParasite *parasite = va_arg (args, GimpParasite *);\n\n            if (parasite == NULL)\n              {\n                params[i].data.d_parasite.name = NULL;\n                params[i].data.d_parasite.data = NULL;\n              }\n            else\n              {\n                params[i].data.d_parasite.name  = parasite->name;\n                params[i].data.d_parasite.flags = parasite->flags;\n                params[i].data.d_parasite.size  = parasite->size;\n                params[i].data.d_parasite.data  = parasite->data;\n              }\n          }\n          break;\n        case GIMP_PDB_STATUS:\n          params[i].data.d_status = va_arg (args, gint32);\n          break;\n        case GIMP_PDB_END:\n          break;\n        }\n    }\n\n  va_end (args);\n\n  return_vals = gimp_run_procedure2 (name, n_return_vals, n_params, params);\n\n  g_free (params);\n\n  return return_vals;\n}\n- get_psd_color_mode_name: static gchar * /* <=== get_psd_color_mode_name */ \nget_psd_color_mode_name (PSDColorMode mode)\n{\n  static gchar * const psd_color_mode_names[] =\n  {\n    \"BITMAP\",\n    \"GRAYSCALE\",\n    \"INDEXED\",\n    \"RGB\",\n    \"CMYK\",\n    \"UNKNOWN (5)\",\n    \"UNKNOWN (6)\",\n    \"MULTICHANNEL\",\n    \"DUOTONE\",\n    \"LAB\"\n  };\n\n  static gchar *err_name = NULL;\n\n  if (mode >= PSD_BITMAP && mode <= PSD_LAB)\n    return psd_color_mode_names[mode];\n\n  g_free (err_name);\n  err_name = g_strdup_printf (\"UNKNOWN (%d)\", mode);\n\n  return err_name;\n}\n- gimp_layer_create_mask: gint32 /* <=== gimp_layer_create_mask */ \ngimp_layer_create_mask (gint32          layer_ID,\n                        GimpAddMaskType mask_type)\n{\n  GimpParam *return_vals;\n  gint nreturn_vals;\n  gint32 mask_ID = -1;\n\n  return_vals = gimp_run_procedure (\"gimp-layer-create-mask\",\n                                    &nreturn_vals,\n                                    GIMP_PDB_LAYER, layer_ID,\n                                    GIMP_PDB_INT32, mask_type,\n                                    GIMP_PDB_END);\n\n  if (return_vals[0].data.d_status == GIMP_PDB_SUCCESS)\n    mask_ID = return_vals[1].data.d_layer_mask;\n\n  gimp_destroy_params (return_vals, nreturn_vals);\n\n  return mask_ID;\n}\n- TILE_HEIGHT: #define TILE_HEIGHT gimp_tile_height() /* <=== libgimp/gimppixelrgn.c:31:31:TILE_HEIGHT:0 */ \n- GIMP_IS_DRAWABLE: #define GIMP_IS_DRAWABLE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_DRAWABLE)) /* <=== app/core/gimpdrawable.h:29:29:GIMP_IS_DRAWABLE:1 */ \n- gimp_layer_is_floating_sel: gboolean /* <=== gimp_layer_is_floating_sel */ \ngimp_layer_is_floating_sel (gint32 layer_ID)\n{\n  GimpParam *return_vals;\n  gint nreturn_vals;\n  gboolean is_floating_sel = FALSE;\n\n  return_vals = gimp_run_procedure (\"gimp-layer-is-floating-sel\",\n                                    &nreturn_vals,\n                                    GIMP_PDB_LAYER, layer_ID,\n                                    GIMP_PDB_END);\n\n  if (return_vals[0].data.d_status == GIMP_PDB_SUCCESS)\n    is_floating_sel = return_vals[1].data.d_int32;\n\n  gimp_destroy_params (return_vals, nreturn_vals);\n\n  return is_floating_sel;\n}\n- PSD_LPRP_ID: #define PSD_LPRP_ID             \"lyid\"          /* Layer ID (PS5) */ /* <=== plug-ins/file-psd/psd.h:103:103:PSD_LPRP_ID:0 */ \n- gimp_drawable_update: void /* <=== gimp_drawable_update */ \ngimp_drawable_update (GimpDrawable *drawable,\n                      gint          x,\n                      gint          y,\n                      gint          width,\n                      gint          height)\n{\n  g_return_if_fail (GIMP_IS_DRAWABLE (drawable));\n\n  g_signal_emit (drawable, gimp_drawable_signals[UPDATE], 0,\n                 x, y, width, height);\n}\n- GREEN_PIX: #define GREEN_PIX        1 /* <=== app/base/base-types.h:41:41:GREEN_PIX:0 */ \n- load_resource_luni: static gint /* <=== load_resource_luni */ \nload_resource_luni (const PSDlayerres  *res_a,\n                    PSDlayer           *lyr_a,\n                    FILE               *f,\n                    GError            **error)\n{\n  /* Load layer name in unicode (length padded to multiple of 4 bytes) */\n  gint32        read_len;\n  gint32        write_len;\n\n  IFDBG(2) g_debug (\"Process layer resource block luni: Unicode Name\");\n  if (lyr_a->name)\n    g_free (lyr_a->name);\n\n  lyr_a->name = fread_unicode_string (&read_len, &write_len, 4, f, error);\n  if (*error)\n    return -1;\n  IFDBG(3) g_debug (\"Unicode name: %s\", lyr_a->name);\n\n  return 0;\n}\n- gimp_drawable_get_tiles: TileManager * /* <=== gimp_drawable_get_tiles */ \ngimp_drawable_get_tiles (GimpDrawable *drawable)\n{\n  g_return_val_if_fail (GIMP_IS_DRAWABLE (drawable), NULL);\n\n  return GIMP_DRAWABLE_GET_CLASS (drawable)->get_tiles (drawable);\n}\n- convert_1_bit: static void /* <=== convert_1_bit */ \nconvert_1_bit (const gchar *src,\n               gchar       *dst,\n               guint32      rows,\n               guint32      columns)\n{\n/* Convert bits to bytes left to right by row.\n   Rows are padded out to a byte boundry.\n*/\n  guint32 row_pos = 0;\n  gint    i, j;\n\n  IFDBG(3)  g_debug (\"Start 1 bit conversion\");\n\n  for (i = 0; i < rows * ((columns + 7) >> 3); ++i)\n    {\n      guchar    mask = 0x80;\n      for (j = 0; j < 8 && row_pos < columns; ++j)\n        {\n          *dst = (*src & mask) ? 0 : 1;\n          IFDBG(3) g_debug (\"byte %d, bit %d, offset %d, src %d, dst %d\",\n            i , j, row_pos, *src, *dst);\n          dst++;\n          mask >>= 1;\n          row_pos++;\n        }\n      if (row_pos >= columns)\n        row_pos = 0;\n      src++;\n    }\n  IFDBG(3)  g_debug (\"End 1 bit conversion\");\n}\n- GIMP_IS_CHANNEL: #define GIMP_IS_CHANNEL(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_CHANNEL)) /* <=== app/core/gimpchannel.h:28:28:GIMP_IS_CHANNEL:1 */ \n- gimp_image_add_layer: gboolean /* <=== gimp_image_add_layer */ \ngimp_image_add_layer (GimpImage *image,\n                      GimpLayer *layer,\n                      gint       position)\n{\n  GimpLayer *active_layer;\n  GimpLayer *floating_sel;\n  gboolean   old_has_alpha;\n\n  g_return_val_if_fail (GIMP_IS_IMAGE (image), FALSE);\n  g_return_val_if_fail (GIMP_IS_LAYER (layer), FALSE);\n  g_return_val_if_fail (g_object_is_floating (layer), FALSE);\n  g_return_val_if_fail (gimp_item_get_image (GIMP_ITEM (layer)) == image,\n                        FALSE);\n\n  floating_sel = gimp_image_floating_sel (image);\n\n  active_layer = gimp_image_get_active_layer (image);\n\n  old_has_alpha = gimp_image_has_alpha (image);\n\n  gimp_image_undo_push_layer_add (image, _(\"Add Layer\"),\n                                  layer, active_layer);\n\n  /*  If the layer is a floating selection, set the ID  */\n  if (gimp_layer_is_floating_sel (layer))\n    image->floating_sel = layer;\n\n  /*  add the layer to the list at the specified position  */\n  if (position == -1)\n    {\n      if (active_layer)\n        position = gimp_container_get_child_index (image->layers,\n                                                   GIMP_OBJECT (active_layer));\n      else\n        position = 0;\n    }\n\n  /*  If there is a floating selection (and this isn't it!),\n   *  make sure the insert position is greater than 0\n   */\n  if (position == 0 && floating_sel)\n    position = 1;\n\n  /*  Don't add at a non-existing index  */\n  if (position > gimp_container_num_children (image->layers))\n    position = gimp_container_num_children (image->layers);\n\n  g_object_ref_sink (layer);\n  gimp_container_insert (image->layers, GIMP_OBJECT (layer), position);\n  g_object_unref (layer);\n\n  /*  notify the layers dialog of the currently active layer  */\n  gimp_image_set_active_layer (image, layer);\n\n  if (old_has_alpha != gimp_image_has_alpha (image))\n    gimp_image_alpha_changed (image);\n\n  if (gimp_layer_is_floating_sel (layer))\n    gimp_image_floating_selection_changed (image);\n\n  return TRUE;\n}\n\nType Definitions:\n- GimpLayerModeEffects: typedef enum\n{\n  GIMP_NORMAL_MODE,\n  GIMP_DISSOLVE_MODE,\n  GIMP_BEHIND_MODE,\n  GIMP_MULTIPLY_MODE,\n  GIMP_SCREEN_MODE,\n  GIMP_OVERLAY_MODE,\n  GIMP_DIFFERENCE_MODE,\n  GIMP_ADDITION_MODE,\n  GIMP_SUBTRACT_MODE,\n  GIMP_DARKEN_ONLY_MODE,\n  GIMP_LIGHTEN_ONLY_MODE,\n  GIMP_HUE_MODE,\n  GIMP_SATURATION_MODE,\n  GIMP_COLOR_MODE,\n  GIMP_VALUE_MODE,\n  GIMP_DIVIDE_MODE,\n  GIMP_DODGE_MODE,\n  GIMP_BURN_MODE,\n  GIMP_HARDLIGHT_MODE,\n  GIMP_SOFTLIGHT_MODE,\n  GIMP_GRAIN_EXTRACT_MODE,\n  GIMP_GRAIN_MERGE_MODE,\n  GIMP_COLOR_ERASE_MODE\n}\n- PSDlayer: typedef struct\n{\n  gboolean              drop;                   /* Do not add layer to GIMP image */\n  gint32                top;                    /* Layer top */\n  gint32                left;                   /* Layer left */\n  gint32                bottom;                 /* Layer bottom */\n  gint32                right;                  /* Layer right */\n  guint16               num_channels;           /* Number of channels */\n  ChannelLengthInfo    *chn_info;               /* Channel length info */\n  gchar                 mode_key[4];            /* Blend mode key */\n  gchar                 blend_mode[4];          /* Blend mode */\n  guchar                opacity;                /* Opacity - 0 = transparent ... 255 = opaque */\n  guchar                clipping;               /* Clipping */\n  guchar                flags;                  /* Layer flags */\n  guchar                filler;                 /* Filler */\n  guint32               extra_len;              /* Extra data length */\n  gchar                *name;                   /* Layer name */\n  guint32               mask_len;               /* Layer mask data length */\n  LayerMask             layer_mask;             /* Layer mask data */\n  LayerMaskExtra        layer_mask_extra;       /* Layer mask extra data */\n  LayerFlags            layer_flags;            /* Layer flags */\n  guint32               id;                     /* Layer ID (Tattoo) */\n}\n- PSDchannel: typedef struct\n{\n  gint16        id;                     /* Channel ID */\n  gchar        *name;                   /* Channel name */\n  gchar        *data;                   /* Channel image data */\n  guint32       rows;                   /* Channel rows */\n  guint32       columns;                /* Channel columns */\n}\n- PSDimage: typedef struct\n{\n  guint16               channels;               /* Number of channels: 1- 56 */\n  gboolean              transparency;           /* Image has merged transparency alpha channel */\n  guint32               rows;                   /* Number of rows: 1 - 30000 */\n  guint32               columns;                /* Number of columns: 1 - 30000 */\n  guint16               bps;                    /* Bits per channel: 1, 8 or 16 */\n  guint16               color_mode;             /* Image colour mode: {PSDColorMode} */\n  GimpImageBaseType     base_type;              /* Image base colour mode: (GIMP) */\n  guint16               comp_mode;              /* Merged image compression mode */\n  guchar               *color_map;              /* Colour map data */\n  guint32               color_map_len;          /* Colour map data length */\n  guint32               color_map_entries;      /* Colour map number of entries */\n  guint32               image_res_start;        /* Image resource block start address */\n  guint32               image_res_len;          /* Image resource block length */\n  guint32               mask_layer_start;       /* Mask & layer block start address */\n  guint32               mask_layer_len;         /* Mask & layer block length */\n  gint16                num_layers;             /* Number of layers */\n  guint32               layer_data_start;       /* Layer pixel data start */\n  guint32               layer_data_len;         /* Layer pixel data length */\n  guint32               merged_image_start;     /* Merged image pixel data block start address */\n  guint32               merged_image_len;       /* Merged image pixel data block length */\n  gboolean              no_icc;                 /* Do not use ICC profile */\n  guint16               layer_state;            /* Active layer number counting from bottom up */\n  GPtrArray            *alpha_names;            /* Alpha channel names */\n  PSDchanneldata      **alpha_display_info;     /* Alpha channel display info */\n  guint16               alpha_display_count;    /* Number of alpha channel display info recs */\n  guint32              *alpha_id;               /* Alpha channel ids (tattoos) */\n  guint16               alpha_id_count;         /* Number of alpha channel id items */\n  guint16               quick_mask_id;          /* Channel number containing quick mask */\n}\n- GimpDrawable: typedef struct _GimpDrawable    GimpDrawable;\n- PSDlayerres: typedef struct\n{\n  gchar         sig[4];                 /* Layer resource signature */\n  gchar         key[4];                 /* Layer resource key */\n  gint32        data_start;             /* Layer resource data start */\n  gint32        data_len;               /* Layer resource data length */\n}\n- GimpPixelRgn: typedef struct _GimpPixelRgn    GimpPixelRgn;\n\nImports:\n- #include <errno.h>\n- #include \"psd-layer-res-load.h\"\n- #include <string.h>\n- #include \"psd-util.h\"\n- #include <libgimp/gimp.h>\n- #include <glib/gstdio.h>\n- #include \"psd-load.h\"\n- #include \"libgimp/stdplugins-intl.h\"\n- #include \"psd.h\"\n- #include \"psd-image-res-load.h\"\n- #include \"config.h\"",
    "commit_msg": "Harden the PSD plugin against integer overflows.\n\nIssues discovered by Stefan Cornelius, Secunia Research, advisory SA37232\nand CVE identifier CVE-2009-3909. Fixes bug #600741.\n(cherry picked from commit 9cc8d78ff33b7a36852b74e64b427489cad44d0e)",
    "cve_desc": "Integer overflow in the read_channel_data function in plug-ins/file-psd/psd-load.c in GIMP 2.6.7 might allow remote attackers to execute arbitrary code via a crafted PSD file that triggers a heap-based buffer overflow.",
    "year": 2009,
    "filename": "psd-load.c",
    "commit_url": "\"https://github.com/GNOME/gimp/commit/88eccea84aa375197cc04a2a0e2e29debb56bfa5\""
  },
  {
    "repository": "ruby/ruby",
    "cve_id": "CVE-2009-4124",
    "cwe_list": [
      "CWE-119"
    ],
    "commit_hash": "1c2ef610358af33f9ded3086aa2d70aac03dcac5",
    "short_hash": "1c2ef610",
    "vulnerableMethods_before": [
      {
        "filename": "string.c",
        "method_name": "rb_str_justify",
        "raw_code": "static VALUE /* <=== rb_str_justify */ \nrb_str_justify(int argc, VALUE *argv, VALUE str, char jflag)\n{\n    rb_encoding *enc;\n    VALUE w;\n    long width, len, flen = 1, fclen = 1;\n    VALUE res;\n    char *p;\n    const char *f = \" \";\n    long n, llen, rlen;\n    volatile VALUE pad;\n    int singlebyte = 1, cr;\n\n    rb_scan_args(argc, argv, \"11\", &w, &pad);\n    enc = STR_ENC_GET(str);\n    width = NUM2LONG(w);\n    if (argc == 2) {\n\tStringValue(pad);\n\tenc = rb_enc_check(str, pad);\n\tf = RSTRING_PTR(pad);\n\tflen = RSTRING_LEN(pad);\n\tfclen = str_strlen(pad, enc);\n\tsinglebyte = single_byte_optimizable(pad);\n\tif (flen == 0 || fclen == 0) {\n\t    rb_raise(rb_eArgError, \"zero width padding\");\n\t}\n    }\n    len = str_strlen(str, enc);\n    if (width < 0 || len >= width) return rb_str_dup(str);\n    n = width - len;\n    llen = (jflag == 'l') ? 0 : ((jflag == 'r') ? n : n/2);\n    rlen = n - llen;\n    cr = ENC_CODERANGE(str);\n    res = rb_str_new5(str, 0, RSTRING_LEN(str)+n*flen/fclen+2);\n    p = RSTRING_PTR(res);\n    while (llen) {\n\tif (flen <= 1) {\n\t    *p++ = *f;\n\t    llen--;\n\t}\n\telse if (llen > fclen) {\n\t    memcpy(p,f,flen);\n\t    p += flen;\n\t    llen -= fclen;\n\t}\n\telse {\n\t    char *fp = str_nth(f, f+flen, llen, enc, singlebyte);\n\t    n = fp - f;\n\t    memcpy(p,f,n);\n\t    p+=n;\n\t    break;\n\t}\n    }\n    memcpy(p, RSTRING_PTR(str), RSTRING_LEN(str));\n    p+=RSTRING_LEN(str);\n    while (rlen) {\n\tif (flen <= 1) {\n\t    *p++ = *f;\n\t    rlen--;\n\t}\n\telse if (rlen > fclen) {\n\t    memcpy(p,f,flen);\n\t    p += flen;\n\t    rlen -= fclen;\n\t}\n\telse {\n\t    char *fp = str_nth(f, f+flen, rlen, enc, singlebyte);\n\t    n = fp - f;\n\t    memcpy(p,f,n);\n\t    p+=n;\n\t    break;\n\t}\n    }\n    *p = '\\0';\n    STR_SET_LEN(res, p-RSTRING_PTR(res));\n    OBJ_INFECT(res, str);\n    if (!NIL_P(pad)) OBJ_INFECT(res, pad);\n    rb_enc_associate(res, enc);\n    if (argc == 2)\n\tcr = ENC_CODERANGE_AND(cr, ENC_CODERANGE(pad));\n    if (cr != ENC_CODERANGE_BROKEN)\n\tENC_CODERANGE_SET(res, cr);\n    return res;\n}",
        "start_line": 6587
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "string.c",
        "method_name": "rb_str_justify",
        "raw_code": "static VALUE /* <=== rb_str_justify */ \nrb_str_justify(int argc, VALUE *argv, VALUE str, char jflag)\n{\n    rb_encoding *enc;\n    VALUE w;\n    long width, len, flen = 1, fclen = 1;\n    VALUE res;\n    char *p;\n    const char *f = \" \";\n    long n, size, llen, rlen, llen2 = 0, rlen2 = 0;\n    volatile VALUE pad;\n    int singlebyte = 1, cr;\n\n    rb_scan_args(argc, argv, \"11\", &w, &pad);\n    enc = STR_ENC_GET(str);\n    width = NUM2LONG(w);\n    if (argc == 2) {\n\tStringValue(pad);\n\tenc = rb_enc_check(str, pad);\n\tf = RSTRING_PTR(pad);\n\tflen = RSTRING_LEN(pad);\n\tfclen = str_strlen(pad, enc);\n\tsinglebyte = single_byte_optimizable(pad);\n\tif (flen == 0 || fclen == 0) {\n\t    rb_raise(rb_eArgError, \"zero width padding\");\n\t}\n    }\n    len = str_strlen(str, enc);\n    if (width < 0 || len >= width) return rb_str_dup(str);\n    n = width - len;\n    llen = (jflag == 'l') ? 0 : ((jflag == 'r') ? n : n/2);\n    rlen = n - llen;\n    cr = ENC_CODERANGE(str);\n    if (flen > 1) {\n       llen2 = str_offset(f, f + flen, llen % fclen, enc, singlebyte);\n       rlen2 = str_offset(f, f + flen, rlen % fclen, enc, singlebyte);\n    }\n    size = RSTRING_LEN(str);\n    if ((len = llen / fclen + rlen / fclen) >= LONG_MAX / flen ||\n       (len *= flen) >= LONG_MAX - llen2 - rlen2 ||\n       (len += llen2 + rlen2) >= LONG_MAX - size) {\n       rb_raise(rb_eArgError, \"argument too big\");\n    }\n    len += size;\n    res = rb_str_new5(str, 0, len);\n    p = RSTRING_PTR(res);\n    if (flen <= 1) {\n       memset(p, *f, llen);\n       p += llen;\n    }\n    else {\n       while (llen > fclen) {\n\t    memcpy(p,f,flen);\n\t    p += flen;\n\t    llen -= fclen;\n\t}\n       if (llen > 0) {\n           memcpy(p, f, llen2);\n           p += llen2;\n\t}\n    }\n    memcpy(p, RSTRING_PTR(str), size);\n    p += size;\n    if (flen <= 1) {\n       memset(p, *f, rlen);\n       p += rlen;\n    }\n    else {\n       while (rlen > fclen) {\n\t    memcpy(p,f,flen);\n\t    p += flen;\n\t    rlen -= fclen;\n\t}\n       if (rlen > 0) {\n           memcpy(p, f, rlen2);\n           p += rlen2;\n\t}\n    }\n    *p = '\\0';\n    STR_SET_LEN(res, p-RSTRING_PTR(res));\n    OBJ_INFECT(res, str);\n    if (!NIL_P(pad)) OBJ_INFECT(res, pad);\n    rb_enc_associate(res, enc);\n    if (argc == 2)\n\tcr = ENC_CODERANGE_AND(cr, ENC_CODERANGE(pad));\n    if (cr != ENC_CODERANGE_BROKEN)\n\tENC_CODERANGE_SET(res, cr);\n    return res;\n}",
        "start_line": 6587
      }
    ],
    "code_context": "Called Methods:\n- RSTRING_LEN: #define RSTRING_LEN(str) \\ /* <=== include/ruby/ruby.h:614:618:RSTRING_LEN:1 */ \n    (!(RBASIC(str)->flags & RSTRING_NOEMBED) ? \\\n     (long)((RBASIC(str)->flags >> RSTRING_EMBED_LEN_SHIFT) & \\\n            (RSTRING_EMBED_LEN_MASK >> RSTRING_EMBED_LEN_SHIFT)) : \\\n     RSTRING(str)->as.heap.len)\n- rb_vsprintf: VALUE rb_vsprintf(const char*, va_list); /* <=== rb_vsprintf */ \n- str_strlen: static long /* <=== str_strlen */ \nstr_strlen(VALUE str, rb_encoding *enc)\n{\n    const char *p, *e;\n    long n;\n    int cr;\n\n    if (single_byte_optimizable(str)) return RSTRING_LEN(str);\n    if (!enc) enc = STR_ENC_GET(str);\n    p = RSTRING_PTR(str);\n    e = RSTRING_END(str);\n    cr = ENC_CODERANGE(str);\n#ifdef NONASCII_MASK\n    if (ENC_CODERANGE(str) == ENC_CODERANGE_VALID &&\n        enc == rb_utf8_encoding()) {\n\n\tVALUE len = 0;\n\tif ((int)sizeof(VALUE) * 2 < e - p) {\n\t    const VALUE *s, *t;\n\t    const VALUE lowbits = sizeof(VALUE) - 1;\n\t    s = (const VALUE*)(~lowbits & ((VALUE)p + lowbits));\n\t    t = (const VALUE*)(~lowbits & (VALUE)e);\n\t    while (p < (const char *)s) {\n\t\tif (is_utf8_lead_byte(*p)) len++;\n\t\tp++;\n\t    }\n\t    while (s < t) {\n\t\tlen += count_utf8_lead_bytes_with_word(s);\n\t\ts++;\n\t    }\n\t    p = (const char *)s;\n\t}\n\twhile (p < e) {\n\t    if (is_utf8_lead_byte(*p)) len++;\n\t    p++;\n\t}\n\treturn (long)len;\n    }\n#endif\n    n = rb_enc_strlen_cr(p, e, enc, &cr);\n    if (cr) {\n        ENC_CODERANGE_SET(str, cr);\n    }\n    return n;\n}\n- rb_enc_get: rb_encoding* /* <=== rb_enc_get */ \nrb_enc_get(VALUE obj)\n{\n    return rb_enc_from_index(rb_enc_get_index(obj));\n}\n- StringValue: #define StringValue(v) rb_string_value(&(v)) /* <=== include/ruby/ruby.h:406:406:StringValue:1 */ \n- NUM2LONG_internal: #define NUM2LONG_internal(x) (FIXNUM_P(x) ? FIX2LONG(x) : rb_num2long(x)) /* <=== include/ruby/ruby.h:444:444:NUM2LONG_internal:1 */ \n- rb_enc_compatible: rb_encoding* /* <=== rb_enc_compatible */ \nrb_enc_compatible(VALUE str1, VALUE str2)\n{\n    int idx1, idx2;\n    rb_encoding *enc1, *enc2;\n\n    idx1 = rb_enc_get_index(str1);\n    idx2 = rb_enc_get_index(str2);\n\n    if (idx1 < 0 || idx2 < 0)\n        return 0;\n\n    if (idx1 == idx2) {\n\treturn rb_enc_from_index(idx1);\n    }\n    enc1 = rb_enc_from_index(idx1);\n    enc2 = rb_enc_from_index(idx2);\n\n    if (TYPE(str2) == T_STRING && RSTRING_LEN(str2) == 0)\n\treturn (idx1 == ENCINDEX_US_ASCII && rb_enc_asciicompat(enc2)) ? enc2 : enc1;\n    if (TYPE(str1) == T_STRING && RSTRING_LEN(str1) == 0)\n\treturn (idx2 == ENCINDEX_US_ASCII && rb_enc_asciicompat(enc1)) ? enc1 : enc2;\n    if (!rb_enc_asciicompat(enc1) || !rb_enc_asciicompat(enc2)) {\n\treturn 0;\n    }\n\n    /* objects whose encoding is the same of contents */\n    if (BUILTIN_TYPE(str2) != T_STRING && idx2 == ENCINDEX_US_ASCII)\n\treturn enc1;\n    if (BUILTIN_TYPE(str1) != T_STRING && idx1 == ENCINDEX_US_ASCII)\n\treturn enc2;\n\n    if (BUILTIN_TYPE(str1) != T_STRING) {\n\tVALUE tmp = str1;\n\tint idx0 = idx1;\n\tstr1 = str2;\n\tstr2 = tmp;\n\tidx1 = idx2;\n\tidx2 = idx0;\n    }\n    if (BUILTIN_TYPE(str1) == T_STRING) {\n\tint cr1, cr2;\n\n\tcr1 = rb_enc_str_coderange(str1);\n\tif (BUILTIN_TYPE(str2) == T_STRING) {\n\t    cr2 = rb_enc_str_coderange(str2);\n\t    if (cr1 != cr2) {\n\t\t/* may need to handle ENC_CODERANGE_BROKEN */\n\t\tif (cr1 == ENC_CODERANGE_7BIT) return enc2;\n\t\tif (cr2 == ENC_CODERANGE_7BIT) return enc1;\n\t    }\n\t    if (cr2 == ENC_CODERANGE_7BIT) {\n\t\tif (idx1 == ENCINDEX_ASCII) return enc2;\n\t\treturn enc1;\n\t    }\n\t}\n\tif (cr1 == ENC_CODERANGE_7BIT)\n\t    return enc2;\n    }\n    return 0;\n}\n- RSTRING_PTR: #define RSTRING_PTR(str) \\ /* <=== include/ruby/ruby.h:619:622:RSTRING_PTR:1 */ \n    (!(RBASIC(str)->flags & RSTRING_NOEMBED) ? \\\n     RSTRING(str)->as.ary : \\\n     RSTRING(str)->as.heap.ptr)\n- rb_enc_from_index: rb_encoding * /* <=== rb_enc_from_index */ \nrb_enc_from_index(int index)\n{\n    if (!enc_table.list) {\n\trb_enc_init();\n    }\n    if (index < 0 || enc_table.count <= index) {\n\treturn 0;\n    }\n    return enc_table.list[index].enc;\n}\n- str_offset: static long /* <=== str_offset */ \nstr_offset(const char *p, const char *e, long nth, rb_encoding *enc, int singlebyte)\n{\n    const char *pp = str_nth(p, e, nth, enc, singlebyte);\n    if (!pp) return e - p;\n    return pp - p;\n}\n- rb_obj_class: VALUE rb_obj_class(VALUE); /* <=== rb_obj_class */ \n- rb_enc_mbmaxlen: #define rb_enc_mbmaxlen(enc) (enc)->max_enc_len /* <=== include/ruby/encoding.h:110:110:rb_enc_mbmaxlen:1 */ \n- STR_SET_LEN: #define STR_SET_LEN(str, n) do { \\ /* <=== string.c:77:84:STR_SET_LEN:2 */ \n    if (STR_EMBED_P(str)) {\\\n\tSTR_SET_EMBED_LEN(str, n);\\\n    }\\\n    else {\\\n\tRSTRING(str)->as.heap.len = (n);\\\n    }\\\n} while (0)\n- STR_ENC_GET: #define STR_ENC_GET(str) rb_enc_from_index(ENCODING_GET(str)) /* <=== string.c:118:118:STR_ENC_GET:1 */ \n- rb_enc_nth: char* /* <=== rb_enc_nth */ \nrb_enc_nth(const char *p, const char *e, long nth, rb_encoding *enc)\n{\n    if (rb_enc_mbmaxlen(enc) == 1) {\n        p += nth;\n    }\n    else if (rb_enc_mbmaxlen(enc) == rb_enc_mbminlen(enc)) {\n        p += nth * rb_enc_mbmaxlen(enc);\n    }\n    else if (rb_enc_asciicompat(enc)) {\n        const char *p2, *e2;\n        int n;\n\n        while (p < e && 0 < nth) {\n            e2 = p + nth;\n            if (e < e2)\n                return (char *)e;\n            if (ISASCII(*p)) {\n                p2 = search_nonascii(p, e2);\n                if (!p2)\n                    return (char *)e2;\n                nth -= p2 - p;\n                p = p2;\n            }\n            n = rb_enc_mbclen(p, e, enc);\n            p += n;\n            nth--;\n        }\n        if (nth != 0)\n            return (char *)e;\n        return (char *)p;\n    }\n    else {\n        while (p<e && nth--) {\n            p += rb_enc_mbclen(p, e, enc);\n        }\n    }\n    if (p > e) p = e;\n    return (char*)p;\n}\n- rb_enc_associate: VALUE /* <=== rb_enc_associate */ \nrb_enc_associate(VALUE obj, rb_encoding *enc)\n{\n    return rb_enc_associate_index(obj, rb_enc_to_index(enc));\n}\n- rb_raise: void /* <=== rb_raise */ \nrb_raise(VALUE exc, const char *fmt, ...)\n{\n    va_list args;\n    VALUE mesg;\n\n    va_start(args, fmt);\n    mesg = rb_vsprintf(fmt, args);\n    va_end(args);\n    rb_exc_raise(rb_exc_new3(exc, mesg));\n}\n- rb_num2long: SIGNED_VALUE rb_num2long(VALUE); /* <=== rb_num2long */ \n- rb_str_new5: #define rb_str_new5 rb_str_new_with_class /* <=== string.c:727:727:rb_str_new5:0 */ \n- str_new: static VALUE /* <=== str_new */ \nstr_new(VALUE klass, const char *ptr, long len)\n{\n    VALUE str;\n\n    if (len < 0) {\n\trb_raise(rb_eArgError, \"negative string size (or size too big)\");\n    }\n\n    str = str_alloc(klass);\n    if (len > RSTRING_EMBED_LEN_MAX) {\n\tRSTRING(str)->as.heap.aux.capa = len;\n\tRSTRING(str)->as.heap.ptr = ALLOC_N(char,len+1);\n\tSTR_SET_NOEMBED(str);\n    }\n    else if (len == 0) {\n\tENC_CODERANGE_SET(str, ENC_CODERANGE_7BIT);\n    }\n    if (ptr) {\n\tmemcpy(RSTRING_PTR(str), ptr, len);\n    }\n    STR_SET_LEN(str, len);\n    RSTRING_PTR(str)[len] = '\\0';\n    return str;\n}\n- rb_enc_strlen_cr: long /* <=== rb_enc_strlen_cr */ \nrb_enc_strlen_cr(const char *p, const char *e, rb_encoding *enc, int *cr)\n{\n    long c;\n    const char *q;\n    int ret;\n\n    *cr = 0;\n    if (rb_enc_mbmaxlen(enc) == rb_enc_mbminlen(enc)) {\n\treturn (e - p + rb_enc_mbminlen(enc) - 1) / rb_enc_mbminlen(enc);\n    }\n    else if (rb_enc_asciicompat(enc)) {\n\tc = 0;\n\twhile (p < e) {\n\t    if (ISASCII(*p)) {\n\t\tq = search_nonascii(p, e);\n\t\tif (!q) {\n\t\t    if (!*cr) *cr = ENC_CODERANGE_7BIT;\n\t\t    return c + (e - p);\n\t\t}\n\t\tc += q - p;\n\t\tp = q;\n\t    }\n\t    ret = rb_enc_precise_mbclen(p, e, enc);\n\t    if (MBCLEN_CHARFOUND_P(ret)) {\n\t\t*cr |= ENC_CODERANGE_VALID;\n\t\tp += MBCLEN_CHARFOUND_LEN(ret);\n\t    }\n\t    else {\n\t\t*cr = ENC_CODERANGE_BROKEN;\n\t\tp++;\n\t    }\n\t    c++;\n\t}\n\tif (!*cr) *cr = ENC_CODERANGE_7BIT;\n\treturn c;\n    }\n\n    for (c=0; p<e; c++) {\n\tret = rb_enc_precise_mbclen(p, e, enc);\n\tif (MBCLEN_CHARFOUND_P(ret)) {\n\t    *cr |= ENC_CODERANGE_VALID;\n\t    p += MBCLEN_CHARFOUND_LEN(ret);\n\t}\n\telse {\n\t    *cr = ENC_CODERANGE_BROKEN;\n\t    p++;\n\t}\n    }\n    if (!*cr) *cr = ENC_CODERANGE_7BIT;\n    return c;\n}\n- ENC_CODERANGE_7BIT: #define ENC_CODERANGE_7BIT\t((int)FL_USER8) /* <=== include/ruby/encoding.h:47:47:ENC_CODERANGE_7BIT:0 */ \n- OBJ_INFECT: #define OBJ_INFECT(x,s) do {if (FL_ABLE(x) && FL_ABLE(s)) RBASIC(x)->flags |= RBASIC(s)->flags & (FL_TAINT | FL_UNTRUSTED);} while (0) /* <=== include/ruby/ruby.h:909:909:OBJ_INFECT:2 */ \n- rb_enc_get_index: int /* <=== rb_enc_get_index */ \nrb_enc_get_index(VALUE obj)\n{\n    int i = -1;\n    VALUE tmp;\n\n    if (SPECIAL_CONST_P(obj)) {\n\tif (!SYMBOL_P(obj)) return -1;\n\tobj = rb_id2str(SYM2ID(obj));\n    }\n    switch (BUILTIN_TYPE(obj)) {\n      as_default:\n      default:\n      case T_STRING:\n      case T_REGEXP:\n\ti = ENCODING_GET_INLINED(obj);\n\tif (i == ENCODING_INLINE_MAX) {\n\t    VALUE iv;\n\n\t    iv = rb_ivar_get(obj, rb_id_encoding());\n\t    i = NUM2INT(iv);\n\t}\n\tbreak;\n      case T_FILE:\n\ttmp = rb_funcall(obj, rb_intern(\"internal_encoding\"), 0, 0);\n\tif (NIL_P(tmp)) obj = rb_funcall(obj, rb_intern(\"external_encoding\"), 0, 0);\n\telse obj = tmp;\n\tif (NIL_P(obj)) break;\n      case T_DATA:\n\tif (is_data_encoding(obj)) {\n\t    i = enc_check_encoding(obj);\n\t}\n\telse {\n\t    goto as_default;\n\t}\n\tbreak;\n    }\n    return i;\n}\n- rb_enc_associate_index: VALUE /* <=== rb_enc_associate_index */ \nrb_enc_associate_index(VALUE obj, int idx)\n{\n/*    enc_check_capable(obj);*/\n    if (rb_enc_get_index(obj) == idx)\n\treturn obj;\n    if (SPECIAL_CONST_P(obj)) {\n\trb_raise(rb_eArgError, \"cannot set encoding\");\n    }\n    if (!ENC_CODERANGE_ASCIIONLY(obj) ||\n\t!rb_enc_asciicompat(rb_enc_from_index(idx))) {\n\tENC_CODERANGE_CLEAR(obj);\n    }\n    rb_enc_set_index(obj, idx);\n    return obj;\n}\n- str_nth: static char* /* <=== str_nth */ \nstr_nth(const char *p, const char *e, long nth, rb_encoding *enc, int singlebyte)\n{\n    if (singlebyte)\n\tp += nth;\n    else {\n\tp = rb_enc_nth(p, e, nth, enc);\n    }\n    if (!p) return 0;\n    if (p > e) p = e;\n    return (char *)p;\n}\n- ENC_CODERANGE: #define ENC_CODERANGE(obj) ((int)RBASIC(obj)->flags & ENC_CODERANGE_MASK) /* <=== include/ruby/encoding.h:50:50:ENC_CODERANGE:1 */ \n- single_byte_optimizable: static inline int /* <=== single_byte_optimizable */ \nsingle_byte_optimizable(VALUE str)\n{\n    rb_encoding *enc;\n\n    /* Conservative.  It may be ENC_CODERANGE_UNKNOWN. */\n    if (ENC_CODERANGE(str) == ENC_CODERANGE_7BIT)\n        return 1;\n\n    enc = STR_ENC_GET(str);\n    if (rb_enc_mbmaxlen(enc) == 1)\n        return 1;\n\n    /* Conservative.  Possibly single byte.\n     * \"\\xa1\" in Shift_JIS for example. */\n    return 0;\n}\n- rb_enc_name: #define rb_enc_name(enc) (enc)->name /* <=== include/ruby/encoding.h:106:106:rb_enc_name:1 */ \n- rb_str_new_with_class: VALUE /* <=== rb_str_new_with_class */ \nrb_str_new_with_class(VALUE obj, const char *ptr, long len)\n{\n    return str_new(rb_obj_class(obj), ptr, len);\n}\n- rb_enc_check: rb_encoding* /* <=== rb_enc_check */ \nrb_enc_check(VALUE str1, VALUE str2)\n{\n    rb_encoding *enc = rb_enc_compatible(str1, str2);\n    if (!enc)\n\trb_raise(rb_eEncCompatError, \"incompatible character encodings: %s and %s\",\n\t\t rb_enc_name(rb_enc_get(str1)),\n\t\t rb_enc_name(rb_enc_get(str2)));\n    return enc;\n}\n- RSTRING_END: #define RSTRING_END(str) \\ /* <=== include/ruby/ruby.h:623:628:RSTRING_END:1 */ \n    (!(RBASIC(str)->flags & RSTRING_NOEMBED) ? \\\n     (RSTRING(str)->as.ary + \\\n      ((RBASIC(str)->flags >> RSTRING_EMBED_LEN_SHIFT) & \\\n       (RSTRING_EMBED_LEN_MASK >> RSTRING_EMBED_LEN_SHIFT))) : \\\n     (RSTRING(str)->as.heap.ptr + RSTRING(str)->as.heap.len))\n- rb_exc_new3: VALUE /* <=== rb_exc_new3 */ \nrb_exc_new3(VALUE etype, VALUE str)\n{\n    StringValue(str);\n    return rb_funcall(etype, rb_intern(\"new\"), 1, str);\n}\n- NUM2LONG: static inline long /* <=== NUM2LONG */ \nNUM2LONG(VALUE x)\n{\n    return NUM2LONG_internal(x);\n}\n- rb_raise: void /* <=== rb_raise */ \nrb_raise(VALUE exc, const char *fmt, ...)\n{\n    va_list args;\n    VALUE mesg;\n\n    va_start(args, fmt);\n    mesg = rb_vsprintf(fmt, args);\n    va_end(args);\n    rb_exc_raise(rb_exc_new3(exc, mesg));\n}\n- rb_enc_to_index: #define rb_enc_to_index(enc) ((enc) ? ENC_TO_ENCINDEX(enc) : 0) /* <=== include/ruby/encoding.h:73:73:rb_enc_to_index:1 */ \n- ENC_CODERANGE_SET: #define ENC_CODERANGE_SET(obj,cr) (RBASIC(obj)->flags = \\ /* <=== include/ruby/encoding.h:52:53:ENC_CODERANGE_SET:2 */ \n\t\t\t\t   (RBASIC(obj)->flags & ~ENC_CODERANGE_MASK) | (cr))\n- str_nth: static char* /* <=== str_nth */ \nstr_nth(const char *p, const char *e, long nth, rb_encoding *enc, int singlebyte)\n{\n    if (singlebyte)\n\tp += nth;\n    else {\n\tp = rb_enc_nth(p, e, nth, enc);\n    }\n    if (!p) return 0;\n    if (p > e) p = e;\n    return (char *)p;\n}\n\nType Definitions:\n- VALUE: typedef unsigned long VALUE;\n- OnigEncodingTypeST: typedef struct OnigEncodingTypeST {\n  int    (*precise_mbc_enc_len)(const OnigUChar* p,const OnigUChar* e, struct OnigEncodingTypeST* enc);\n  const char*   name;\n  int           max_enc_len;\n  int           min_enc_len;\n  int    (*is_mbc_newline)(const OnigUChar* p, const OnigUChar* end, struct OnigEncodingTypeST* enc);\n  OnigCodePoint (*mbc_to_code)(const OnigUChar* p, const OnigUChar* end, struct OnigEncodingTypeST* enc);\n  int    (*code_to_mbclen)(OnigCodePoint code, struct OnigEncodingTypeST* enc);\n  int    (*code_to_mbc)(OnigCodePoint code, OnigUChar *buf, struct OnigEncodingTypeST* enc);\n  int    (*mbc_case_fold)(OnigCaseFoldType flag, const OnigUChar** pp, const OnigUChar* end, OnigUChar* to, struct OnigEncodingTypeST* enc);\n  int    (*apply_all_case_fold)(OnigCaseFoldType flag, OnigApplyAllCaseFoldFunc f, void* arg, struct OnigEncodingTypeST* enc);\n  int    (*get_case_fold_codes_by_str)(OnigCaseFoldType flag, const OnigUChar* p, const OnigUChar* end, OnigCaseFoldCodeItem acs[], struct OnigEncodingTypeST* enc);\n  int    (*property_name_to_ctype)(struct OnigEncodingTypeST* enc, OnigUChar* p, OnigUChar* end);\n  int    (*is_code_ctype)(OnigCodePoint code, OnigCtype ctype, struct OnigEncodingTypeST* enc);\n  int    (*get_ctype_code_range)(OnigCtype ctype, OnigCodePoint* sb_out, const OnigCodePoint* ranges[], struct OnigEncodingTypeST* enc);\n  OnigUChar* (*left_adjust_char_head)(const OnigUChar* start, const OnigUChar* p, const OnigUChar* end, struct OnigEncodingTypeST* enc);\n  int    (*is_allowed_reverse_match)(const OnigUChar* p, const OnigUChar* end, struct OnigEncodingTypeST* enc);\n  int ruby_encoding_index;\n}\n- rb_encoding: typedef OnigEncodingType rb_encoding;\n\nImports:\n- #include \"ruby/encoding.h\"\n- #include \"ruby/ruby.h\"\n- #include <assert.h>\n- #include <ctype.h>\n- #include <math.h>\n- #include <unistd.h>\n- #include \"ruby/re.h\"",
    "commit_msg": "* string.c (rb_str_justify): CVE-2009-4124.\n  Fixes a bug reported by \n  Emmanouel Kellinis <Emmanouel.Kellinis AT kpmg.co.uk>, KPMG London;\n  Patch by nobu.\n\n\ngit-svn-id: svn+ssh://ci.ruby-lang.org/ruby/trunk@26038 b2dd03c8-39d4-4d8f-98ff-823fe69b080e",
    "cve_desc": "Heap-based buffer overflow in the rb_str_justify function in string.c in Ruby 1.9.1 before 1.9.1-p376 allows context-dependent attackers to execute arbitrary code via unspecified vectors involving (1) String#ljust, (2) String#center, or (3) String#rjust.  NOTE: some of these details are obtained from third party information.",
    "year": 2009,
    "filename": "string.c",
    "commit_url": "\"https://github.com/ruby/ruby/commit/1c2ef610358af33f9ded3086aa2d70aac03dcac5\""
  },
  {
    "repository": "coreutils/gnulib",
    "cve_id": "CVE-2009-5155",
    "cwe_list": [
      "CWE-19"
    ],
    "commit_hash": "5513b40999149090987a0341c018d05d3eea1272",
    "short_hash": "5513b409",
    "vulnerableMethods_before": [
      {
        "filename": "lib/regcomp.c",
        "method_name": "parse_reg_exp",
        "raw_code": "static bin_tree_t * /* <=== parse_reg_exp */ \nparse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree, *branch = NULL;\n  tree = parse_branch (regexp, preg, token, syntax, nest, err);\n  if (BE (*err != REG_NOERROR && tree == NULL, 0))\n    return NULL;\n\n  while (token->type == OP_ALT)\n    {\n      fetch_token (token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n      if (token->type != OP_ALT && token->type != END_OF_RE\n\t  && (nest == 0 || token->type != OP_CLOSE_SUBEXP))\n\t{\n\t  branch = parse_branch (regexp, preg, token, syntax, nest, err);\n\t  if (BE (*err != REG_NOERROR && branch == NULL, 0))\n\t    {\n\t      if (tree != NULL)\n\t\tpostorder (tree, free_tree, NULL);\n\t      return NULL;\n\t    }\n\t}\n      else\n\tbranch = NULL;\n      tree = create_tree (dfa, tree, branch, OP_ALT);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n    }\n  return tree;\n}",
        "start_line": 2188
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "lib/regcomp.c",
        "method_name": "parse_reg_exp",
        "raw_code": "static bin_tree_t * /* <=== parse_reg_exp */ \nparse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree, *branch = NULL;\n  bitset_word_t initial_bkref_map = dfa->completed_bkref_map;\n  tree = parse_branch (regexp, preg, token, syntax, nest, err);\n  if (BE (*err != REG_NOERROR && tree == NULL, 0))\n    return NULL;\n\n  while (token->type == OP_ALT)\n    {\n      fetch_token (token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n      if (token->type != OP_ALT && token->type != END_OF_RE\n\t  && (nest == 0 || token->type != OP_CLOSE_SUBEXP))\n\t{\n\t  bitset_word_t accumulated_bkref_map = dfa->completed_bkref_map;\n\t  dfa->completed_bkref_map = initial_bkref_map;\n\t  branch = parse_branch (regexp, preg, token, syntax, nest, err);\n\t  if (BE (*err != REG_NOERROR && branch == NULL, 0))\n\t    {\n\t      if (tree != NULL)\n\t\tpostorder (tree, free_tree, NULL);\n\t      return NULL;\n\t    }\n\t  dfa->completed_bkref_map |= accumulated_bkref_map;\n\t}\n      else\n\tbranch = NULL;\n      tree = create_tree (dfa, tree, branch, OP_ALT);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n    }\n  return tree;\n}",
        "start_line": 2188
      }
    ],
    "code_context": "Called Methods:\n- fetch_token: internal_function /* <=== fetch_token */ \nfetch_token (re_token_t *result, re_string_t *input, reg_syntax_t syntax)\n{\n  re_string_skip_bytes (input, peek_token (result, input, syntax));\n}\n- parse_expression: static bin_tree_t * /* <=== parse_expression */ \nparse_expression (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t\t  reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree;\n  switch (token->type)\n    {\n    case CHARACTER:\n      tree = create_token_tree (dfa, NULL, NULL, token);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n#ifdef RE_ENABLE_I18N\n      if (dfa->mb_cur_max > 1)\n\t{\n\t  while (!re_string_eoi (regexp)\n\t\t && !re_string_first_byte (regexp, re_string_cur_idx (regexp)))\n\t    {\n\t      bin_tree_t *mbc_remain;\n\t      fetch_token (token, regexp, syntax);\n\t      mbc_remain = create_token_tree (dfa, NULL, NULL, token);\n\t      tree = create_tree (dfa, tree, mbc_remain, CONCAT);\n\t      if (BE (mbc_remain == NULL || tree == NULL, 0))\n\t\t{\n\t\t  *err = REG_ESPACE;\n\t\t  return NULL;\n\t\t}\n\t    }\n\t}\n#endif\n      break;\n    case OP_OPEN_SUBEXP:\n      tree = parse_sub_exp (regexp, preg, token, syntax, nest + 1, err);\n      if (BE (*err != REG_NOERROR && tree == NULL, 0))\n\treturn NULL;\n      break;\n    case OP_OPEN_BRACKET:\n      tree = parse_bracket_exp (regexp, dfa, token, syntax, err);\n      if (BE (*err != REG_NOERROR && tree == NULL, 0))\n\treturn NULL;\n      break;\n    case OP_BACK_REF:\n      if (!BE (dfa->completed_bkref_map & (1 << token->opr.idx), 1))\n\t{\n\t  *err = REG_ESUBREG;\n\t  return NULL;\n\t}\n      dfa->used_bkref_map |= 1 << token->opr.idx;\n      tree = create_token_tree (dfa, NULL, NULL, token);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n      ++dfa->nbackref;\n      dfa->has_mb_node = 1;\n      break;\n    case OP_OPEN_DUP_NUM:\n      if (syntax & RE_CONTEXT_INVALID_DUP)\n\t{\n\t  *err = REG_BADRPT;\n\t  return NULL;\n\t}\n      /* FALLTHROUGH */\n    case OP_DUP_ASTERISK:\n    case OP_DUP_PLUS:\n    case OP_DUP_QUESTION:\n      if (syntax & RE_CONTEXT_INVALID_OPS)\n\t{\n\t  *err = REG_BADRPT;\n\t  return NULL;\n\t}\n      else if (syntax & RE_CONTEXT_INDEP_OPS)\n\t{\n\t  fetch_token (token, regexp, syntax);\n\t  return parse_expression (regexp, preg, token, syntax, nest, err);\n\t}\n      /* else fall through  */\n    case OP_CLOSE_SUBEXP:\n      if ((token->type == OP_CLOSE_SUBEXP) &&\n\t  !(syntax & RE_UNMATCHED_RIGHT_PAREN_ORD))\n\t{\n\t  *err = REG_ERPAREN;\n\t  return NULL;\n\t}\n      /* else fall through  */\n    case OP_CLOSE_DUP_NUM:\n      /* We treat it as a normal character.  */\n\n      /* Then we can these characters as normal characters.  */\n      token->type = CHARACTER;\n      /* mb_partial and word_char bits should be initialized already\n\t by peek_token.  */\n      tree = create_token_tree (dfa, NULL, NULL, token);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n      break;\n    case ANCHOR:\n      if ((token->opr.ctx_type\n\t   & (WORD_DELIM | NOT_WORD_DELIM | WORD_FIRST | WORD_LAST))\n\t  && dfa->word_ops_used == 0)\n\tinit_word_char (dfa);\n      if (token->opr.ctx_type == WORD_DELIM\n\t  || token->opr.ctx_type == NOT_WORD_DELIM)\n\t{\n\t  bin_tree_t *tree_first, *tree_last;\n\t  if (token->opr.ctx_type == WORD_DELIM)\n\t    {\n\t      token->opr.ctx_type = WORD_FIRST;\n\t      tree_first = create_token_tree (dfa, NULL, NULL, token);\n\t      token->opr.ctx_type = WORD_LAST;\n\t    }\n\t  else\n\t    {\n\t      token->opr.ctx_type = INSIDE_WORD;\n\t      tree_first = create_token_tree (dfa, NULL, NULL, token);\n\t      token->opr.ctx_type = INSIDE_NOTWORD;\n\t    }\n\t  tree_last = create_token_tree (dfa, NULL, NULL, token);\n\t  tree = create_tree (dfa, tree_first, tree_last, OP_ALT);\n\t  if (BE (tree_first == NULL || tree_last == NULL || tree == NULL, 0))\n\t    {\n\t      *err = REG_ESPACE;\n\t      return NULL;\n\t    }\n\t}\n      else\n\t{\n\t  tree = create_token_tree (dfa, NULL, NULL, token);\n\t  if (BE (tree == NULL, 0))\n\t    {\n\t      *err = REG_ESPACE;\n\t      return NULL;\n\t    }\n\t}\n      /* We must return here, since ANCHORs can't be followed\n\t by repetition operators.\n\t eg. RE\"^*\" is invalid or \"<ANCHOR(^)><CHAR(*)>\",\n\t     it must not be \"<ANCHOR(^)><REPEAT(*)>\".  */\n      fetch_token (token, regexp, syntax);\n      return tree;\n    case OP_PERIOD:\n      tree = create_token_tree (dfa, NULL, NULL, token);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n      if (dfa->mb_cur_max > 1)\n\tdfa->has_mb_node = 1;\n      break;\n    case OP_WORD:\n    case OP_NOTWORD:\n      tree = build_charclass_op (dfa, regexp->trans,\n\t\t\t\t \"alnum\",\n\t\t\t\t \"_\",\n\t\t\t\t token->type == OP_NOTWORD, err);\n      if (BE (*err != REG_NOERROR && tree == NULL, 0))\n\treturn NULL;\n      break;\n    case OP_SPACE:\n    case OP_NOTSPACE:\n      tree = build_charclass_op (dfa, regexp->trans,\n\t\t\t\t \"space\",\n\t\t\t\t \"\",\n\t\t\t\t token->type == OP_NOTSPACE, err);\n      if (BE (*err != REG_NOERROR && tree == NULL, 0))\n\treturn NULL;\n      break;\n    case OP_ALT:\n    case END_OF_RE:\n      return NULL;\n    case BACK_SLASH:\n      *err = REG_EESCAPE;\n      return NULL;\n    default:\n      /* Must not happen?  */\n#ifdef DEBUG\n      assert (0);\n#endif\n      return NULL;\n    }\n  fetch_token (token, regexp, syntax);\n\n  while (token->type == OP_DUP_ASTERISK || token->type == OP_DUP_PLUS\n\t || token->type == OP_DUP_QUESTION || token->type == OP_OPEN_DUP_NUM)\n    {\n      bin_tree_t *dup_tree = parse_dup_op (tree, regexp, dfa, token,\n\t\t\t\t\t   syntax, err);\n      if (BE (*err != REG_NOERROR && dup_tree == NULL, 0))\n\t{\n\t  if (tree != NULL)\n\t    postorder (tree, free_tree, NULL);\n\t  return NULL;\n\t}\n      tree = dup_tree;\n      /* In BRE consecutive duplications are not allowed.  */\n      if ((syntax & RE_CONTEXT_INVALID_DUP)\n\t  && (token->type == OP_DUP_ASTERISK\n\t      || token->type == OP_OPEN_DUP_NUM))\n\t{\n\t  if (tree != NULL)\n\t    postorder (tree, free_tree, NULL);\n\t  *err = REG_BADRPT;\n\t  return NULL;\n\t}\n    }\n\n  return tree;\n}\n- peek_token: internal_function /* <=== peek_token */ \npeek_token (re_token_t *token, re_string_t *input, reg_syntax_t syntax)\n{\n  unsigned char c;\n\n  if (re_string_eoi (input))\n    {\n      token->type = END_OF_RE;\n      return 0;\n    }\n\n  c = re_string_peek_byte (input, 0);\n  token->opr.c = c;\n\n  token->word_char = 0;\n#ifdef RE_ENABLE_I18N\n  token->mb_partial = 0;\n  if (input->mb_cur_max > 1 &&\n      !re_string_first_byte (input, re_string_cur_idx (input)))\n    {\n      token->type = CHARACTER;\n      token->mb_partial = 1;\n      return 1;\n    }\n#endif\n  if (c == '\\\\')\n    {\n      unsigned char c2;\n      if (re_string_cur_idx (input) + 1 >= re_string_length (input))\n\t{\n\t  token->type = BACK_SLASH;\n\t  return 1;\n\t}\n\n      c2 = re_string_peek_byte_case (input, 1);\n      token->opr.c = c2;\n      token->type = CHARACTER;\n#ifdef RE_ENABLE_I18N\n      if (input->mb_cur_max > 1)\n\t{\n\t  wint_t wc = re_string_wchar_at (input,\n\t\t\t\t\t  re_string_cur_idx (input) + 1);\n\t  token->word_char = IS_WIDE_WORD_CHAR (wc) != 0;\n\t}\n      else\n#endif\n\ttoken->word_char = IS_WORD_CHAR (c2) != 0;\n\n      switch (c2)\n\t{\n\tcase '|':\n\t  if (!(syntax & RE_LIMITED_OPS) && !(syntax & RE_NO_BK_VBAR))\n\t    token->type = OP_ALT;\n\t  break;\n\tcase '1': case '2': case '3': case '4': case '5':\n\tcase '6': case '7': case '8': case '9':\n\t  if (!(syntax & RE_NO_BK_REFS))\n\t    {\n\t      token->type = OP_BACK_REF;\n\t      token->opr.idx = c2 - '1';\n\t    }\n\t  break;\n\tcase '<':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = WORD_FIRST;\n\t    }\n\t  break;\n\tcase '>':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = WORD_LAST;\n\t    }\n\t  break;\n\tcase 'b':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = WORD_DELIM;\n\t    }\n\t  break;\n\tcase 'B':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = NOT_WORD_DELIM;\n\t    }\n\t  break;\n\tcase 'w':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    token->type = OP_WORD;\n\t  break;\n\tcase 'W':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    token->type = OP_NOTWORD;\n\t  break;\n\tcase 's':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    token->type = OP_SPACE;\n\t  break;\n\tcase 'S':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    token->type = OP_NOTSPACE;\n\t  break;\n\tcase '`':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = BUF_FIRST;\n\t    }\n\t  break;\n\tcase '\\'':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = BUF_LAST;\n\t    }\n\t  break;\n\tcase '(':\n\t  if (!(syntax & RE_NO_BK_PARENS))\n\t    token->type = OP_OPEN_SUBEXP;\n\t  break;\n\tcase ')':\n\t  if (!(syntax & RE_NO_BK_PARENS))\n\t    token->type = OP_CLOSE_SUBEXP;\n\t  break;\n\tcase '+':\n\t  if (!(syntax & RE_LIMITED_OPS) && (syntax & RE_BK_PLUS_QM))\n\t    token->type = OP_DUP_PLUS;\n\t  break;\n\tcase '?':\n\t  if (!(syntax & RE_LIMITED_OPS) && (syntax & RE_BK_PLUS_QM))\n\t    token->type = OP_DUP_QUESTION;\n\t  break;\n\tcase '{':\n\t  if ((syntax & RE_INTERVALS) && (!(syntax & RE_NO_BK_BRACES)))\n\t    token->type = OP_OPEN_DUP_NUM;\n\t  break;\n\tcase '}':\n\t  if ((syntax & RE_INTERVALS) && (!(syntax & RE_NO_BK_BRACES)))\n\t    token->type = OP_CLOSE_DUP_NUM;\n\t  break;\n\tdefault:\n\t  break;\n\t}\n      return 2;\n    }\n\n  token->type = CHARACTER;\n#ifdef RE_ENABLE_I18N\n  if (input->mb_cur_max > 1)\n    {\n      wint_t wc = re_string_wchar_at (input, re_string_cur_idx (input));\n      token->word_char = IS_WIDE_WORD_CHAR (wc) != 0;\n    }\n  else\n#endif\n    token->word_char = IS_WORD_CHAR (token->opr.c);\n\n  switch (c)\n    {\n    case '\\n':\n      if (syntax & RE_NEWLINE_ALT)\n\ttoken->type = OP_ALT;\n      break;\n    case '|':\n      if (!(syntax & RE_LIMITED_OPS) && (syntax & RE_NO_BK_VBAR))\n\ttoken->type = OP_ALT;\n      break;\n    case '*':\n      token->type = OP_DUP_ASTERISK;\n      break;\n    case '+':\n      if (!(syntax & RE_LIMITED_OPS) && !(syntax & RE_BK_PLUS_QM))\n\ttoken->type = OP_DUP_PLUS;\n      break;\n    case '?':\n      if (!(syntax & RE_LIMITED_OPS) && !(syntax & RE_BK_PLUS_QM))\n\ttoken->type = OP_DUP_QUESTION;\n      break;\n    case '{':\n      if ((syntax & RE_INTERVALS) && (syntax & RE_NO_BK_BRACES))\n\ttoken->type = OP_OPEN_DUP_NUM;\n      break;\n    case '}':\n      if ((syntax & RE_INTERVALS) && (syntax & RE_NO_BK_BRACES))\n\ttoken->type = OP_CLOSE_DUP_NUM;\n      break;\n    case '(':\n      if (syntax & RE_NO_BK_PARENS)\n\ttoken->type = OP_OPEN_SUBEXP;\n      break;\n    case ')':\n      if (syntax & RE_NO_BK_PARENS)\n\ttoken->type = OP_CLOSE_SUBEXP;\n      break;\n    case '[':\n      token->type = OP_OPEN_BRACKET;\n      break;\n    case '.':\n      token->type = OP_PERIOD;\n      break;\n    case '^':\n      if (!(syntax & (RE_CONTEXT_INDEP_ANCHORS | RE_CARET_ANCHORS_HERE)) &&\n\t  re_string_cur_idx (input) != 0)\n\t{\n\t  char prev = re_string_peek_byte (input, -1);\n\t  if (!(syntax & RE_NEWLINE_ALT) || prev != '\\n')\n\t    break;\n\t}\n      token->type = ANCHOR;\n      token->opr.ctx_type = LINE_FIRST;\n      break;\n    case '$':\n      if (!(syntax & RE_CONTEXT_INDEP_ANCHORS) &&\n\t  re_string_cur_idx (input) + 1 != re_string_length (input))\n\t{\n\t  re_token_t next;\n\t  re_string_skip_bytes (input, 1);\n\t  peek_token (&next, input, syntax);\n\t  re_string_skip_bytes (input, -1);\n\t  if (next.type != OP_ALT && next.type != OP_CLOSE_SUBEXP)\n\t    break;\n\t}\n      token->type = ANCHOR;\n      token->opr.ctx_type = LINE_LAST;\n      break;\n    default:\n      break;\n    }\n  return 1;\n}\n- create_token_tree: static bin_tree_t * /* <=== create_token_tree */ \ncreate_token_tree (re_dfa_t *dfa, bin_tree_t *left, bin_tree_t *right,\n\t\t   const re_token_t *token)\n{\n  bin_tree_t *tree;\n  if (BE (dfa->str_tree_storage_idx == BIN_TREE_STORAGE_SIZE, 0))\n    {\n      bin_tree_storage_t *storage = re_malloc (bin_tree_storage_t, 1);\n\n      if (storage == NULL)\n\treturn NULL;\n      storage->next = dfa->str_tree_storage;\n      dfa->str_tree_storage = storage;\n      dfa->str_tree_storage_idx = 0;\n    }\n  tree = &dfa->str_tree_storage->data[dfa->str_tree_storage_idx++];\n\n  tree->parent = NULL;\n  tree->left = left;\n  tree->right = right;\n  tree->token = *token;\n  tree->token.duplicated = 0;\n  tree->token.opt_subexp = 0;\n  tree->first = NULL;\n  tree->next = NULL;\n  tree->node_idx = REG_MISSING;\n\n  if (left != NULL)\n    left->parent = tree;\n  if (right != NULL)\n    right->parent = tree;\n  return tree;\n}\n- postorder: static reg_errcode_t /* <=== postorder */ \npostorder (bin_tree_t *root, reg_errcode_t (fn (void *, bin_tree_t *)),\n\t   void *extra)\n{\n  bin_tree_t *node, *prev;\n\n  for (node = root; ; )\n    {\n      /* Descend down the tree, preferably to the left (or to the right\n\t if that's the only child).  */\n      while (node->left || node->right)\n\tif (node->left)\n\t  node = node->left;\n\telse\n\t  node = node->right;\n\n      do\n\t{\n\t  reg_errcode_t err = fn (extra, node);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t  if (node->parent == NULL)\n\t    return REG_NOERROR;\n\t  prev = node;\n\t  node = node->parent;\n\t}\n      /* Go up while we have a node that is reached from the right.  */\n      while (node->right == prev || node->right == NULL);\n      node = node->right;\n    }\n}\n- create_tree: static bin_tree_t * /* <=== create_tree */ \ncreate_tree (re_dfa_t *dfa, bin_tree_t *left, bin_tree_t *right,\n\t     re_token_type_t type)\n{\n  re_token_t t;\n  t.type = type;\n  return create_token_tree (dfa, left, right, &t);\n}\n- parse_branch: static bin_tree_t * /* <=== parse_branch */ \nparse_branch (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t      reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  bin_tree_t *tree, *expr;\n  re_dfa_t *dfa = preg->buffer;\n  tree = parse_expression (regexp, preg, token, syntax, nest, err);\n  if (BE (*err != REG_NOERROR && tree == NULL, 0))\n    return NULL;\n\n  while (token->type != OP_ALT && token->type != END_OF_RE\n\t && (nest == 0 || token->type != OP_CLOSE_SUBEXP))\n    {\n      expr = parse_expression (regexp, preg, token, syntax, nest, err);\n      if (BE (*err != REG_NOERROR && expr == NULL, 0))\n\t{\n\t  if (tree != NULL)\n\t    postorder (tree, free_tree, NULL);\n\t  return NULL;\n\t}\n      if (tree != NULL && expr != NULL)\n\t{\n\t  bin_tree_t *newtree = create_tree (dfa, tree, expr, CONCAT);\n\t  if (newtree == NULL)\n\t    {\n\t      postorder (expr, free_tree, NULL);\n\t      postorder (tree, free_tree, NULL);\n\t      *err = REG_ESPACE;\n\t      return NULL;\n\t    }\n\t  tree = newtree;\n\t}\n      else if (tree == NULL)\n\ttree = expr;\n      /* Otherwise expr == NULL, we don't need to create new tree.  */\n    }\n  return tree;\n}\n\nType Definitions:\n- Idx: static Idx\n- reg_errcode_t: static reg_errcode_t\n\nImports:\n- # include <locale/weight.h>",
    "commit_msg": "Diagnose ERE '()|\\1'\n\nProblem reported by Hanno Bck in: http://bugs.gnu.org/21513\n* lib/regcomp.c (parse_reg_exp): While parsing alternatives, keep\ntrack of the set of previously-completed subexpressions available\nbefore the first alternative, and restore this set just before\nparsing each subsequent alternative.  This lets us diagnose the\ninvalid back-reference in the ERE '()|\\1'.",
    "cve_desc": "In the GNU C Library (aka glibc or libc6) before 2.28, parse_reg_exp in posix/regcomp.c misparses alternatives, which allows attackers to cause a denial of service (assertion failure and application exit) or trigger an incorrect result by attempting a regular-expression match.",
    "year": 2015,
    "filename": "regcomp.c",
    "commit_url": "\"https://github.com/coreutils/gnulib/commit/5513b40999149090987a0341c018d05d3eea1272\""
  },
  {
    "repository": "bonzini/qemu",
    "cve_id": "CVE-2010-0297",
    "cwe_list": [
      "CWE-119"
    ],
    "commit_hash": "babd03fde68093482528010a5435c14ce9128e3f",
    "short_hash": "babd03fd",
    "vulnerableMethods_before": [
      {
        "filename": "usb-linux.c",
        "method_name": "usb_host_handle_control",
        "raw_code": "static int usb_host_handle_control(USBHostDevice *s, USBPacket *p) /* <=== usb_host_handle_control */ \n{\n    struct usbdevfs_urb *urb;\n    AsyncURB *aurb;\n    int ret, value, index;\n\n    /* \n     * Process certain standard device requests.\n     * These are infrequent and are processed synchronously.\n     */\n    value = le16_to_cpu(s->ctrl.req.wValue);\n    index = le16_to_cpu(s->ctrl.req.wIndex);\n\n    dprintf(\"husb: ctrl type 0x%x req 0x%x val 0x%x index %u len %u\\n\",\n        s->ctrl.req.bRequestType, s->ctrl.req.bRequest, value, index, \n        s->ctrl.len);\n\n    if (s->ctrl.req.bRequestType == 0) {\n        switch (s->ctrl.req.bRequest) {\n        case USB_REQ_SET_ADDRESS:\n            return usb_host_set_address(s, value);\n\n        case USB_REQ_SET_CONFIGURATION:\n            return usb_host_set_config(s, value & 0xff);\n        }\n    }\n\n    if (s->ctrl.req.bRequestType == 1 &&\n                  s->ctrl.req.bRequest == USB_REQ_SET_INTERFACE)\n        return usb_host_set_interface(s, index, value);\n\n    /* The rest are asynchronous */\n\n    aurb = async_alloc();\n    aurb->hdev   = s;\n    aurb->packet = p;\n\n    /* \n     * Setup ctrl transfer.\n     *\n     * s->ctrl is layed out such that data buffer immediately follows\n     * 'req' struct which is exactly what usbdevfs expects.\n     */ \n    urb = &aurb->urb;\n\n    urb->type     = USBDEVFS_URB_TYPE_CONTROL;\n    urb->endpoint = p->devep;\n\n    urb->buffer        = &s->ctrl.req;\n    urb->buffer_length = 8 + s->ctrl.len;\n\n    urb->usercontext = s;\n\n    ret = ioctl(s->fd, USBDEVFS_SUBMITURB, urb);\n\n    dprintf(\"husb: submit ctrl. len %u aurb %p\\n\", urb->buffer_length, aurb);\n\n    if (ret < 0) {\n        dprintf(\"husb: submit failed. errno %d\\n\", errno);\n        async_free(aurb);\n\n        switch(errno) {\n        case ETIMEDOUT:\n            return USB_RET_NAK;\n        case EPIPE:\n        default:\n            return USB_RET_STALL;\n        }\n    }\n\n    usb_defer_packet(p, async_cancel, aurb);\n    return USB_RET_ASYNC;\n}",
        "start_line": 550
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "usb-linux.c",
        "method_name": "usb_host_handle_control",
        "raw_code": "static int usb_host_handle_control(USBHostDevice *s, USBPacket *p) /* <=== usb_host_handle_control */ \n{\n    struct usbdevfs_urb *urb;\n    AsyncURB *aurb;\n    int ret, value, index;\n    int buffer_len;\n\n    /* \n     * Process certain standard device requests.\n     * These are infrequent and are processed synchronously.\n     */\n    value = le16_to_cpu(s->ctrl.req.wValue);\n    index = le16_to_cpu(s->ctrl.req.wIndex);\n\n    dprintf(\"husb: ctrl type 0x%x req 0x%x val 0x%x index %u len %u\\n\",\n        s->ctrl.req.bRequestType, s->ctrl.req.bRequest, value, index, \n        s->ctrl.len);\n\n    if (s->ctrl.req.bRequestType == 0) {\n        switch (s->ctrl.req.bRequest) {\n        case USB_REQ_SET_ADDRESS:\n            return usb_host_set_address(s, value);\n\n        case USB_REQ_SET_CONFIGURATION:\n            return usb_host_set_config(s, value & 0xff);\n        }\n    }\n\n    if (s->ctrl.req.bRequestType == 1 &&\n                  s->ctrl.req.bRequest == USB_REQ_SET_INTERFACE)\n        return usb_host_set_interface(s, index, value);\n\n    /* The rest are asynchronous */\n\n    buffer_len = 8 + s->ctrl.len;\n    if (buffer_len > sizeof(s->ctrl.buffer)) {\n\t    fprintf(stderr, \"husb: ctrl buffer too small (%u > %lu)\\n\",\n\t\t    buffer_len, sizeof(s->ctrl.buffer));\n\t    return USB_RET_STALL;\n    }\n\n    aurb = async_alloc();\n    aurb->hdev   = s;\n    aurb->packet = p;\n\n    /* \n     * Setup ctrl transfer.\n     *\n     * s->ctrl is layed out such that data buffer immediately follows\n     * 'req' struct which is exactly what usbdevfs expects.\n     */ \n    urb = &aurb->urb;\n\n    urb->type     = USBDEVFS_URB_TYPE_CONTROL;\n    urb->endpoint = p->devep;\n\n    urb->buffer        = &s->ctrl.req;\n    urb->buffer_length = buffer_len;\n\n    urb->usercontext = s;\n\n    ret = ioctl(s->fd, USBDEVFS_SUBMITURB, urb);\n\n    dprintf(\"husb: submit ctrl. len %u aurb %p\\n\", urb->buffer_length, aurb);\n\n    if (ret < 0) {\n        dprintf(\"husb: submit failed. errno %d\\n\", errno);\n        async_free(aurb);\n\n        switch(errno) {\n        case ETIMEDOUT:\n            return USB_RET_NAK;\n        case EPIPE:\n        default:\n            return USB_RET_STALL;\n        }\n    }\n\n    usb_defer_packet(p, async_cancel, aurb);\n    return USB_RET_ASYNC;\n}",
        "start_line": 550
      }
    ],
    "code_context": "Called Methods:\n- async_alloc: static AsyncURB *async_alloc(void) /* <=== async_alloc */ \n{\n    return (AsyncURB *) qemu_mallocz(sizeof(AsyncURB));\n}\n- qemu_mallocz: void *qemu_mallocz(size_t size); /* <=== qemu_mallocz */ \n- qemu_free: void qemu_free(void *ptr); /* <=== qemu_free */ \n- async_free: static void async_free(AsyncURB *aurb) /* <=== async_free */ \n{\n    qemu_free(aurb);\n}\n- usb_defer_packet: static inline void usb_defer_packet(USBPacket *p, USBCallback *cancel, /* <=== usb_defer_packet */ \n                                    void * opaque)\n{\n    p->cancel_cb = cancel;\n    p->cancel_opaque = opaque;\n}\n- USB_RET_STALL: #define USB_RET_STALL  (-3) /* <=== hw/usb.h:38:38:USB_RET_STALL:0 */ \n- USB_REQ_SET_INTERFACE: #define USB_REQ_SET_INTERFACE\t\t0x0B /* <=== hw/usb.h:102:102:USB_REQ_SET_INTERFACE:0 */ \n- USB_RET_NAK: #define USB_RET_NAK    (-2) /* <=== hw/usb.h:37:37:USB_RET_NAK:0 */ \n- USB_RET_ASYNC: #define USB_RET_ASYNC  (-5) /* <=== hw/usb.h:40:40:USB_RET_ASYNC:0 */ \n\nType Definitions:\n- USBHostDevice: typedef struct USBHostDevice {\n    USBDevice dev;\n    int       fd;\n\n    uint8_t   descr[1024];\n    int       descr_len;\n    int       configuration;\n    int       ninterfaces;\n    int       closing;\n\n    struct ctrl_struct ctrl;\n    struct endp_data endp_table[MAX_ENDPOINTS];\n\n    /* Host side address */\n    int bus_num;\n    int addr;\n\n    struct USBHostDevice *next;\n} USBHostDevice;\n- usbdevfs_urb: struct usbdevfs_urb\n- AsyncURB: typedef struct AsyncURB\n{\n    struct usbdevfs_urb urb;\n    struct usbdevfs_iso_packet_desc isocpd;\n\n    USBPacket     *packet;\n    USBHostDevice *hdev;\n} AsyncURB;\n- USBPacket: typedef struct USBPacket\n- USBHostDevice: typedef struct USBHostDevice {\n    USBDevice dev;\n    int       fd;\n\n    uint8_t   descr[1024];\n    int       descr_len;\n    int       configuration;\n    int       ninterfaces;\n    int       closing;\n\n    struct ctrl_struct ctrl;\n    struct endp_data endp_table[MAX_ENDPOINTS];\n\n    /* Host side address */\n    int bus_num;\n    int addr;\n\n    struct USBHostDevice *next;\n}\n- USBPacket: struct USBPacket {\n    /* Data fields for use by the driver.  */\n    int pid;\n    uint8_t devaddr;\n    uint8_t devep;\n    uint8_t *data;\n    int len;\n    /* Internal use by the USB layer.  */\n    USBCallback *complete_cb;\n    void *complete_opaque;\n    USBCallback *cancel_cb;\n    void *cancel_opaque;\n}\n- AsyncURB: typedef struct AsyncURB\n{\n    struct usbdevfs_urb urb;\n    struct usbdevfs_iso_packet_desc isocpd;\n\n    USBPacket     *packet;\n    USBHostDevice *hdev;\n}\n\nImports:\n- #include <dirent.h>\n- #include <linux/usbdevice_fs.h>\n- #include \"qemu-common.h\"\n- #include \"hw/usb.h\"\n- #include <sys/ioctl.h>\n- #include \"qemu-timer.h\"\n- #include <linux/version.h>\n- #include \"monitor.h\"\n- #include <signal.h>",
    "commit_msg": "usb-linux.c: fix buffer overflow\n\nIn usb-linux.c:usb_host_handle_control, we pass a 1024-byte buffer and\nlength to the kernel.  However, the length was provided by the caller\nof dev->handle_packet, and is not checked, so the kernel might provide\ntoo much data and overflow our buffer.\n\nFor example, hw/usb-uhci.c could set the length to 2047.\nhw/usb-ohci.c looks like it might go up to 4096 or 8192.\n\nThis causes a qemu crash, as reported here:\n  http://www.mail-archive.com/kvm@vger.kernel.org/msg18447.html\n\nThis patch increases the usb-linux.c buffer size to 2048 to fix the\nspecific device reported, and adds a check to avoid the overflow in\nany case.\n\nSigned-off-by: Jim Paris <jim@jtan.com>\nSigned-off-by: Anthony Liguori <aliguori@us.ibm.com>",
    "cve_desc": "Buffer overflow in the usb_host_handle_control function in the USB passthrough handling implementation in usb-linux.c in QEMU before 0.11.1 allows guest OS users to cause a denial of service (guest OS crash or hang) or possibly execute arbitrary code on the host OS via a crafted USB packet.",
    "year": 2009,
    "filename": "usb-linux.c",
    "commit_url": "\"https://github.com/bonzini/qemu/commit/babd03fde68093482528010a5435c14ce9128e3f\""
  },
  {
    "repository": "vrtadmin/clamav-devel",
    "cve_id": "CVE-2010-0405",
    "cwe_list": [
      "CWE-189"
    ],
    "commit_hash": "fcd8091474d12592d509adcfd0bdd0b0dc8835f5",
    "short_hash": "fcd80914",
    "vulnerableMethods_before": [
      {
        "filename": "libclamav/nsis/bzlib.c",
        "method_name": "BZ2_decompress",
        "raw_code": "static Int32 BZ2_decompress ( DState* s ) /* <=== BZ2_decompress */ \n{\n   UChar      uc;\n   Int32      retVal;\n   Int32      minLen, maxLen;\n   nsis_bzstream* strm = s->strm;\n\n   /* stuff that needs to be saved/restored */\n   Int32  i;\n   Int32  j;\n   Int32  t;\n   Int32  alphaSize;\n   Int32  nGroups;\n   Int32  nSelectors;\n   Int32  EOB;\n   Int32  groupNo;\n   Int32  groupPos;\n   Int32  nextSym;\n   Int32  nblockMAX;\n   Int32  nblock;\n   Int32  es;\n   Int32  N;\n   Int32  curr;\n   Int32  zt;\n   Int32  zn; \n   Int32  zvec;\n   Int32  zj;\n   Int32  gSel;\n   Int32  gMinlen;\n   Int32* gLimit;\n   Int32* gBase;\n   Int32* gPerm;\n\n   if (s->state == BZ_X_MAGIC_1) {\n      /*initialise the save area*/\n      s->save_i           = 0;\n      s->save_j           = 0;\n      s->save_t           = 0;\n      s->save_alphaSize   = 0;\n      s->save_nGroups     = 0;\n      s->save_nSelectors  = 0;\n      s->save_EOB         = 0;\n      s->save_groupNo     = 0;\n      s->save_groupPos    = 0;\n      s->save_nextSym     = 0;\n      s->save_nblockMAX   = 0;\n      s->save_nblock      = 0;\n      s->save_es          = 0;\n      s->save_N           = 0;\n      s->save_curr        = 0;\n      s->save_zt          = 0;\n      s->save_zn          = 0;\n      s->save_zvec        = 0;\n      s->save_zj          = 0;\n      s->save_gSel        = 0;\n      s->save_gMinlen     = 0;\n      s->save_gLimit      = NULL;\n      s->save_gBase       = NULL;\n      s->save_gPerm       = NULL;\n   }\n\n   /*restore from the save area*/\n   i           = s->save_i;\n   j           = s->save_j;\n   t           = s->save_t;\n   alphaSize   = s->save_alphaSize;\n   nGroups     = s->save_nGroups;\n   nSelectors  = s->save_nSelectors;\n   EOB         = s->save_EOB;\n   groupNo     = s->save_groupNo;\n   groupPos    = s->save_groupPos;\n   nextSym     = s->save_nextSym;\n   nblockMAX   = s->save_nblockMAX;\n   nblock      = s->save_nblock;\n   es          = s->save_es;\n   N           = s->save_N;\n   curr        = s->save_curr;\n   zt          = s->save_zt;\n   zn          = s->save_zn; \n   zvec        = s->save_zvec;\n   zj          = s->save_zj;\n   gSel        = s->save_gSel;\n   gMinlen     = s->save_gMinlen;\n   gLimit      = s->save_gLimit;\n   gBase       = s->save_gBase;\n   gPerm       = s->save_gPerm;\n\n   retVal = BZ_OK;\n\n   switch (s->state) {\n\n     /* aCaB\n      GET_UCHAR(BZ_X_MAGIC_1, uc);\n      if (uc != BZ_HDR_B) RETURN(BZ_DATA_ERROR_MAGIC);\n\n      GET_UCHAR(BZ_X_MAGIC_2, uc);\n      if (uc != BZ_HDR_Z) RETURN(BZ_DATA_ERROR_MAGIC);\n\n      GET_UCHAR(BZ_X_MAGIC_3, uc)\n      if (uc != BZ_HDR_h) RETURN(BZ_DATA_ERROR_MAGIC);\n\n      GET_BITS(BZ_X_MAGIC_4, s->blockSize100k, 8)\n      if (s->blockSize100k < (BZ_HDR_0 + 1) || \n          s->blockSize100k > (BZ_HDR_0 + 9)) RETURN(BZ_DATA_ERROR_MAGIC);\n      s->blockSize100k -= BZ_HDR_0;\n     */\n\n   case BZ_X_MAGIC_1:\n\n      s->blockSize100k = 9;\n\n      if (s->smallDecompress) {\n         s->ll16 = BZALLOC( s->blockSize100k * 100000 * sizeof(UInt16) );\n         s->ll4  = BZALLOC( \n                      ((1 + s->blockSize100k * 100000) >> 1) * sizeof(UChar) \n                   );\n         if (s->ll16 == NULL || s->ll4 == NULL) RETURN(BZ_MEM_ERROR);\n      } else {\n         s->tt  = BZALLOC( s->blockSize100k * 100000 * sizeof(Int32) );\n         if (s->tt == NULL) RETURN(BZ_MEM_ERROR);\n      }\n\n      GET_UCHAR(BZ_X_BLKHDR_1, uc);\n\n      if (uc == 0x17) goto endhdr_2;\n      if (uc != 0x31) RETURN(BZ_DATA_ERROR);\n\n      /* aCaB\n      GET_UCHAR(BZ_X_BLKHDR_2, uc);\n      if (uc != 0x41) RETURN(BZ_DATA_ERROR);\n      GET_UCHAR(BZ_X_BLKHDR_3, uc);\n      if (uc != 0x59) RETURN(BZ_DATA_ERROR);\n      GET_UCHAR(BZ_X_BLKHDR_4, uc);\n      if (uc != 0x26) RETURN(BZ_DATA_ERROR);\n      GET_UCHAR(BZ_X_BLKHDR_5, uc);\n      if (uc != 0x53) RETURN(BZ_DATA_ERROR);\n      GET_UCHAR(BZ_X_BLKHDR_6, uc);\n      if (uc != 0x59) RETURN(BZ_DATA_ERROR);\n\n      s->currBlockNo++;\n      if (s->verbosity >= 2)\n         VPrintf1 ( \"\\n    [%d: huff+mtf \", s->currBlockNo );\n \n      s->storedBlockCRC = 0;\n      GET_UCHAR(BZ_X_BCRC_1, uc);\n      s->storedBlockCRC = (s->storedBlockCRC << 8) | ((UInt32)uc);\n      GET_UCHAR(BZ_X_BCRC_2, uc);\n      s->storedBlockCRC = (s->storedBlockCRC << 8) | ((UInt32)uc);\n      GET_UCHAR(BZ_X_BCRC_3, uc);\n      s->storedBlockCRC = (s->storedBlockCRC << 8) | ((UInt32)uc);\n      GET_UCHAR(BZ_X_BCRC_4, uc);\n      s->storedBlockCRC = (s->storedBlockCRC << 8) | ((UInt32)uc);\n\n\n      GET_BITS(BZ_X_RANDBIT, s->blockRandomised, 1);\n      */\n\n      s->origPtr = 0;\n      GET_UCHAR(BZ_X_ORIGPTR_1, uc);\n      s->origPtr = (s->origPtr << 8) | ((Int32)uc);\n      GET_UCHAR(BZ_X_ORIGPTR_2, uc);\n      s->origPtr = (s->origPtr << 8) | ((Int32)uc);\n      GET_UCHAR(BZ_X_ORIGPTR_3, uc);\n      s->origPtr = (s->origPtr << 8) | ((Int32)uc);\n\n      if (s->origPtr < 0)\n         RETURN(BZ_DATA_ERROR);\n      if (s->origPtr > 10 + 100000*s->blockSize100k) \n         RETURN(BZ_DATA_ERROR);\n\n      /*--- Receive the mapping table ---*/\n      for (i = 0; i < 16; i++) {\n         GET_BIT(BZ_X_MAPPING_1, uc);\n         if (uc == 1) \n            s->inUse16[i] = True; else \n            s->inUse16[i] = False;\n      }\n\n      for (i = 0; i < 256; i++) s->inUse[i] = False;\n\n      for (i = 0; i < 16; i++)\n         if (s->inUse16[i])\n            for (j = 0; j < 16; j++) {\n               GET_BIT(BZ_X_MAPPING_2, uc);\n               if (uc == 1) s->inUse[i * 16 + j] = True;\n            }\n      makeMaps_d ( s );\n      if (s->nInUse == 0) RETURN(BZ_DATA_ERROR);\n      alphaSize = s->nInUse+2;\n\n      /*--- Now the selectors ---*/\n      GET_BITS(BZ_X_SELECTOR_1, nGroups, 3);\n      if (nGroups < 2 || nGroups > 6) RETURN(BZ_DATA_ERROR);\n      GET_BITS(BZ_X_SELECTOR_2, nSelectors, 15);\n      if (nSelectors < 1) RETURN(BZ_DATA_ERROR);\n      for (i = 0; i < nSelectors; i++) {\n         j = 0;\n         while (True) {\n            GET_BIT(BZ_X_SELECTOR_3, uc);\n            if (uc == 0) break;\n            j++;\n            if (j >= nGroups) RETURN(BZ_DATA_ERROR);\n         }\n         s->selectorMtf[i] = j;\n      }\n\n      /*--- Undo the MTF values for the selectors. ---*/\n      {\n         UChar pos[BZ_N_GROUPS], tmp, v;\n         for (v = 0; v < nGroups; v++) pos[v] = v;\n   \n         for (i = 0; i < nSelectors; i++) {\n            v = s->selectorMtf[i];\n            tmp = pos[v];\n            while (v > 0) { pos[v] = pos[v-1]; v--; }\n            pos[0] = tmp;\n            s->selector[i] = tmp;\n         }\n      }\n\n      /*--- Now the coding tables ---*/\n      for (t = 0; t < nGroups; t++) {\n         GET_BITS(BZ_X_CODING_1, curr, 5);\n         for (i = 0; i < alphaSize; i++) {\n            while (True) {\n               if (curr < 1 || curr > 20) RETURN(BZ_DATA_ERROR);\n               GET_BIT(BZ_X_CODING_2, uc);\n               if (uc == 0) break;\n               GET_BIT(BZ_X_CODING_3, uc);\n               if (uc == 0) curr++; else curr--;\n            }\n            s->len[t][i] = curr;\n         }\n      }\n\n      /*--- Create the Huffman decoding tables ---*/\n      for (t = 0; t < nGroups; t++) {\n         minLen = 32;\n         maxLen = 0;\n         for (i = 0; i < alphaSize; i++) {\n            if (s->len[t][i] > maxLen) maxLen = s->len[t][i];\n            if (s->len[t][i] < minLen) minLen = s->len[t][i];\n         }\n         CreateDecodeTables ( \n            &(s->limit[t][0]), \n            &(s->base[t][0]), \n            &(s->perm[t][0]), \n            &(s->len[t][0]),\n            minLen, maxLen, alphaSize\n         );\n         s->minLens[t] = minLen;\n      }\n\n      /*--- Now the MTF values ---*/\n\n      EOB      = s->nInUse+1;\n      nblockMAX = 100000 * s->blockSize100k;\n      groupNo  = -1;\n      groupPos = 0;\n\n      for (i = 0; i <= 255; i++) s->unzftab[i] = 0;\n\n      /*-- MTF init --*/\n      {\n         Int32 ii, jj, kk;\n         kk = MTFA_SIZE-1;\n         for (ii = 256 / MTFL_SIZE - 1; ii >= 0; ii--) {\n            for (jj = MTFL_SIZE-1; jj >= 0; jj--) {\n               s->mtfa[kk] = (UChar)(ii * MTFL_SIZE + jj);\n               kk--;\n            }\n            s->mtfbase[ii] = kk + 1;\n         }\n      }\n      /*-- end MTF init --*/\n\n      nblock = 0;\n      GET_MTF_VAL(BZ_X_MTF_1, BZ_X_MTF_2, nextSym);\n\n      while (True) {\n\n         if (nextSym == EOB) break;\n\n         if (nextSym == BZ_RUNA || nextSym == BZ_RUNB) {\n\n            es = -1;\n            N = 1;\n            do {\n               if (nextSym == BZ_RUNA) es = es + (0+1) * N; else\n               if (nextSym == BZ_RUNB) es = es + (1+1) * N;\n               N = N * 2;\n               GET_MTF_VAL(BZ_X_MTF_3, BZ_X_MTF_4, nextSym);\n            }\n               while (nextSym == BZ_RUNA || nextSym == BZ_RUNB);\n\n            es++;\n            uc = s->seqToUnseq[ s->mtfa[s->mtfbase[0]] ];\n            s->unzftab[uc] += es;\n\n            if (s->smallDecompress)\n               while (es > 0) {\n                  if (nblock >= nblockMAX) RETURN(BZ_DATA_ERROR);\n                  s->ll16[nblock] = (UInt16)uc;\n                  nblock++;\n                  es--;\n               }\n            else\n               while (es > 0) {\n                  if (nblock >= nblockMAX) RETURN(BZ_DATA_ERROR);\n                  s->tt[nblock] = (UInt32)uc;\n                  nblock++;\n                  es--;\n               };\n\n            continue;\n\n         } else {\n\n            if (nblock >= nblockMAX) RETURN(BZ_DATA_ERROR);\n\n            /*-- uc = MTF ( nextSym-1 ) --*/\n            {\n               Int32 ii, jj, kk, pp, lno, off;\n               UInt32 nn;\n               nn = (UInt32)(nextSym - 1);\n\n               if (nn < MTFL_SIZE) {\n                  /* avoid general-case expense */\n                  pp = s->mtfbase[0];\n                  uc = s->mtfa[pp+nn];\n                  while (nn > 3) {\n                     Int32 z = pp+nn;\n                     s->mtfa[(z)  ] = s->mtfa[(z)-1];\n                     s->mtfa[(z)-1] = s->mtfa[(z)-2];\n                     s->mtfa[(z)-2] = s->mtfa[(z)-3];\n                     s->mtfa[(z)-3] = s->mtfa[(z)-4];\n                     nn -= 4;\n                  }\n                  while (nn > 0) { \n                     s->mtfa[(pp+nn)] = s->mtfa[(pp+nn)-1]; nn--; \n                  };\n                  s->mtfa[pp] = uc;\n               } else { \n                  /* general case */\n                  lno = nn / MTFL_SIZE;\n                  off = nn % MTFL_SIZE;\n                  pp = s->mtfbase[lno] + off;\n                  uc = s->mtfa[pp];\n                  while (pp > s->mtfbase[lno]) { \n                     s->mtfa[pp] = s->mtfa[pp-1]; pp--; \n                  };\n                  s->mtfbase[lno]++;\n                  while (lno > 0) {\n                     s->mtfbase[lno]--;\n                     s->mtfa[s->mtfbase[lno]] \n                        = s->mtfa[s->mtfbase[lno-1] + MTFL_SIZE - 1];\n                     lno--;\n                  }\n                  s->mtfbase[0]--;\n                  s->mtfa[s->mtfbase[0]] = uc;\n                  if (s->mtfbase[0] == 0) {\n                     kk = MTFA_SIZE-1;\n                     for (ii = 256 / MTFL_SIZE-1; ii >= 0; ii--) {\n                        for (jj = MTFL_SIZE-1; jj >= 0; jj--) {\n                           s->mtfa[kk] = s->mtfa[s->mtfbase[ii] + jj];\n                           kk--;\n                        }\n                        s->mtfbase[ii] = kk + 1;\n                     }\n                  }\n               }\n            }\n            /*-- end uc = MTF ( nextSym-1 ) --*/\n\n            s->unzftab[s->seqToUnseq[uc]]++;\n            if (s->smallDecompress)\n               s->ll16[nblock] = (UInt16)(s->seqToUnseq[uc]); else\n               s->tt[nblock]   = (UInt32)(s->seqToUnseq[uc]);\n            nblock++;\n\n            GET_MTF_VAL(BZ_X_MTF_5, BZ_X_MTF_6, nextSym);\n            continue;\n         }\n      }\n\n      /* Now we know what nblock is, we can do a better sanity\n         check on s->origPtr.\n      */\n      if (s->origPtr < 0 || s->origPtr >= nblock)\n         RETURN(BZ_DATA_ERROR);\n\n      /*-- Set up cftab to facilitate generation of T^(-1) --*/\n      s->cftab[0] = 0;\n      for (i = 1; i <= 256; i++) s->cftab[i] = s->unzftab[i-1];\n      for (i = 1; i <= 256; i++) s->cftab[i] += s->cftab[i-1];\n      for (i = 0; i <= 256; i++) {\n         if (s->cftab[i] < 0 || s->cftab[i] > nblock) {\n            RETURN(BZ_DATA_ERROR);\n         }\n      }\n      s->state_out_len = 0;\n      s->state_out_ch  = 0;\n      /* BZ_INITIALISE_CRC ( s->calculatedBlockCRC ); */\n      s->state = BZ_X_OUTPUT;\n      if (s->verbosity >= 2) VPrintf0 ( \"rt+rld\" );\n\n      if (s->smallDecompress) {\n\n         /*-- Make a copy of cftab, used in generation of T --*/\n         for (i = 0; i <= 256; i++) s->cftabCopy[i] = s->cftab[i];\n\n         /*-- compute the T vector --*/\n         for (i = 0; i < nblock; i++) {\n            uc = (UChar)(s->ll16[i]);\n            SET_LL(i, s->cftabCopy[uc]);\n            s->cftabCopy[uc]++;\n         }\n\n         /*-- Compute T^(-1) by pointer reversal on T --*/\n         i = s->origPtr;\n         j = GET_LL(i);\n         do {\n            Int32 tmp = GET_LL(j);\n            SET_LL(j, i);\n            i = j;\n            j = tmp;\n         }\n            while (i != s->origPtr);\n\n         s->tPos = s->origPtr;\n         s->nblock_used = 0;\n\t /* aCaB\n         if (s->blockRandomised) {\n            BZ_RAND_INIT_MASK;\n            BZ_GET_SMALL(s->k0); s->nblock_used++;\n            BZ_RAND_UPD_MASK; s->k0 ^= BZ_RAND_MASK; \n\t    } else */{\n            BZ_GET_SMALL(s->k0); s->nblock_used++;\n         }\n\n      } else {\n\n         /*-- compute the T^(-1) vector --*/\n         for (i = 0; i < nblock; i++) {\n            uc = (UChar)(s->tt[i] & 0xff);\n            s->tt[s->cftab[uc]] |= (i << 8);\n            s->cftab[uc]++;\n         }\n\n         s->tPos = s->tt[s->origPtr] >> 8;\n         s->nblock_used = 0;\n\t /* aCaB\n         if (s->blockRandomised) {\n            BZ_RAND_INIT_MASK;\n            BZ_GET_FAST(s->k0); s->nblock_used++;\n            BZ_RAND_UPD_MASK; s->k0 ^= BZ_RAND_MASK; \n\t    } else */{\n            BZ_GET_FAST(s->k0); s->nblock_used++;\n         }\n\n      }\n\n      RETURN(BZ_OK);\n\n\n\n    endhdr_2:\n      /* aCaB\n      GET_UCHAR(BZ_X_ENDHDR_2, uc);\n      if (uc != 0x72) RETURN(BZ_DATA_ERROR);\n      GET_UCHAR(BZ_X_ENDHDR_3, uc);\n      if (uc != 0x45) RETURN(BZ_DATA_ERROR);\n      GET_UCHAR(BZ_X_ENDHDR_4, uc);\n      if (uc != 0x38) RETURN(BZ_DATA_ERROR);\n      GET_UCHAR(BZ_X_ENDHDR_5, uc);\n      if (uc != 0x50) RETURN(BZ_DATA_ERROR);\n      GET_UCHAR(BZ_X_ENDHDR_6, uc);\n      if (uc != 0x90) RETURN(BZ_DATA_ERROR);\n\n      s->storedCombinedCRC = 0;\n      GET_UCHAR(BZ_X_CCRC_1, uc);\n      s->storedCombinedCRC = (s->storedCombinedCRC << 8) | ((UInt32)uc);\n      GET_UCHAR(BZ_X_CCRC_2, uc);\n      s->storedCombinedCRC = (s->storedCombinedCRC << 8) | ((UInt32)uc);\n      GET_UCHAR(BZ_X_CCRC_3, uc);\n      s->storedCombinedCRC = (s->storedCombinedCRC << 8) | ((UInt32)uc);\n      GET_UCHAR(BZ_X_CCRC_4, uc);\n      s->storedCombinedCRC = (s->storedCombinedCRC << 8) | ((UInt32)uc);\n      */\n      s->state = BZ_X_IDLE;\n      RETURN(BZ_STREAM_END);\n\n   default: /* aCaB AssertH ( False, 4001 ); */\n     RETURN(BZ_DATA_ERROR);\n   }\n\n   /* aCaB AssertH ( False, 4002 ); */\n   RETURN(BZ_DATA_ERROR);\n\n   save_state_and_return:\n\n   s->save_i           = i;\n   s->save_j           = j;\n   s->save_t           = t;\n   s->save_alphaSize   = alphaSize;\n   s->save_nGroups     = nGroups;\n   s->save_nSelectors  = nSelectors;\n   s->save_EOB         = EOB;\n   s->save_groupNo     = groupNo;\n   s->save_groupPos    = groupPos;\n   s->save_nextSym     = nextSym;\n   s->save_nblockMAX   = nblockMAX;\n   s->save_nblock      = nblock;\n   s->save_es          = es;\n   s->save_N           = N;\n   s->save_curr        = curr;\n   s->save_zt          = zt;\n   s->save_zn          = zn;\n   s->save_zvec        = zvec;\n   s->save_zj          = zj;\n   s->save_gSel        = gSel;\n   s->save_gMinlen     = gMinlen;\n   s->save_gLimit      = gLimit;\n   s->save_gBase       = gBase;\n   s->save_gPerm       = gPerm;\n\n   return retVal;   \n}",
        "start_line": 481
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "libclamav/nsis/bzlib.c",
        "method_name": "BZ2_decompress",
        "raw_code": "static Int32 BZ2_decompress ( DState* s ) /* <=== BZ2_decompress */ \n{\n   UChar      uc;\n   Int32      retVal;\n   Int32      minLen, maxLen;\n   nsis_bzstream* strm = s->strm;\n\n   /* stuff that needs to be saved/restored */\n   Int32  i;\n   Int32  j;\n   Int32  t;\n   Int32  alphaSize;\n   Int32  nGroups;\n   Int32  nSelectors;\n   Int32  EOB;\n   Int32  groupNo;\n   Int32  groupPos;\n   Int32  nextSym;\n   Int32  nblockMAX;\n   Int32  nblock;\n   Int32  es;\n   Int32  N;\n   Int32  curr;\n   Int32  zt;\n   Int32  zn; \n   Int32  zvec;\n   Int32  zj;\n   Int32  gSel;\n   Int32  gMinlen;\n   Int32* gLimit;\n   Int32* gBase;\n   Int32* gPerm;\n\n   if (s->state == BZ_X_MAGIC_1) {\n      /*initialise the save area*/\n      s->save_i           = 0;\n      s->save_j           = 0;\n      s->save_t           = 0;\n      s->save_alphaSize   = 0;\n      s->save_nGroups     = 0;\n      s->save_nSelectors  = 0;\n      s->save_EOB         = 0;\n      s->save_groupNo     = 0;\n      s->save_groupPos    = 0;\n      s->save_nextSym     = 0;\n      s->save_nblockMAX   = 0;\n      s->save_nblock      = 0;\n      s->save_es          = 0;\n      s->save_N           = 0;\n      s->save_curr        = 0;\n      s->save_zt          = 0;\n      s->save_zn          = 0;\n      s->save_zvec        = 0;\n      s->save_zj          = 0;\n      s->save_gSel        = 0;\n      s->save_gMinlen     = 0;\n      s->save_gLimit      = NULL;\n      s->save_gBase       = NULL;\n      s->save_gPerm       = NULL;\n   }\n\n   /*restore from the save area*/\n   i           = s->save_i;\n   j           = s->save_j;\n   t           = s->save_t;\n   alphaSize   = s->save_alphaSize;\n   nGroups     = s->save_nGroups;\n   nSelectors  = s->save_nSelectors;\n   EOB         = s->save_EOB;\n   groupNo     = s->save_groupNo;\n   groupPos    = s->save_groupPos;\n   nextSym     = s->save_nextSym;\n   nblockMAX   = s->save_nblockMAX;\n   nblock      = s->save_nblock;\n   es          = s->save_es;\n   N           = s->save_N;\n   curr        = s->save_curr;\n   zt          = s->save_zt;\n   zn          = s->save_zn; \n   zvec        = s->save_zvec;\n   zj          = s->save_zj;\n   gSel        = s->save_gSel;\n   gMinlen     = s->save_gMinlen;\n   gLimit      = s->save_gLimit;\n   gBase       = s->save_gBase;\n   gPerm       = s->save_gPerm;\n\n   retVal = BZ_OK;\n\n   switch (s->state) {\n\n     /* aCaB\n      GET_UCHAR(BZ_X_MAGIC_1, uc);\n      if (uc != BZ_HDR_B) RETURN(BZ_DATA_ERROR_MAGIC);\n\n      GET_UCHAR(BZ_X_MAGIC_2, uc);\n      if (uc != BZ_HDR_Z) RETURN(BZ_DATA_ERROR_MAGIC);\n\n      GET_UCHAR(BZ_X_MAGIC_3, uc)\n      if (uc != BZ_HDR_h) RETURN(BZ_DATA_ERROR_MAGIC);\n\n      GET_BITS(BZ_X_MAGIC_4, s->blockSize100k, 8)\n      if (s->blockSize100k < (BZ_HDR_0 + 1) || \n          s->blockSize100k > (BZ_HDR_0 + 9)) RETURN(BZ_DATA_ERROR_MAGIC);\n      s->blockSize100k -= BZ_HDR_0;\n     */\n\n   case BZ_X_MAGIC_1:\n\n      s->blockSize100k = 9;\n\n      if (s->smallDecompress) {\n         s->ll16 = BZALLOC( s->blockSize100k * 100000 * sizeof(UInt16) );\n         s->ll4  = BZALLOC( \n                      ((1 + s->blockSize100k * 100000) >> 1) * sizeof(UChar) \n                   );\n         if (s->ll16 == NULL || s->ll4 == NULL) RETURN(BZ_MEM_ERROR);\n      } else {\n         s->tt  = BZALLOC( s->blockSize100k * 100000 * sizeof(Int32) );\n         if (s->tt == NULL) RETURN(BZ_MEM_ERROR);\n      }\n\n      GET_UCHAR(BZ_X_BLKHDR_1, uc);\n\n      if (uc == 0x17) goto endhdr_2;\n      if (uc != 0x31) RETURN(BZ_DATA_ERROR);\n\n      /* aCaB\n      GET_UCHAR(BZ_X_BLKHDR_2, uc);\n      if (uc != 0x41) RETURN(BZ_DATA_ERROR);\n      GET_UCHAR(BZ_X_BLKHDR_3, uc);\n      if (uc != 0x59) RETURN(BZ_DATA_ERROR);\n      GET_UCHAR(BZ_X_BLKHDR_4, uc);\n      if (uc != 0x26) RETURN(BZ_DATA_ERROR);\n      GET_UCHAR(BZ_X_BLKHDR_5, uc);\n      if (uc != 0x53) RETURN(BZ_DATA_ERROR);\n      GET_UCHAR(BZ_X_BLKHDR_6, uc);\n      if (uc != 0x59) RETURN(BZ_DATA_ERROR);\n\n      s->currBlockNo++;\n      if (s->verbosity >= 2)\n         VPrintf1 ( \"\\n    [%d: huff+mtf \", s->currBlockNo );\n \n      s->storedBlockCRC = 0;\n      GET_UCHAR(BZ_X_BCRC_1, uc);\n      s->storedBlockCRC = (s->storedBlockCRC << 8) | ((UInt32)uc);\n      GET_UCHAR(BZ_X_BCRC_2, uc);\n      s->storedBlockCRC = (s->storedBlockCRC << 8) | ((UInt32)uc);\n      GET_UCHAR(BZ_X_BCRC_3, uc);\n      s->storedBlockCRC = (s->storedBlockCRC << 8) | ((UInt32)uc);\n      GET_UCHAR(BZ_X_BCRC_4, uc);\n      s->storedBlockCRC = (s->storedBlockCRC << 8) | ((UInt32)uc);\n\n\n      GET_BITS(BZ_X_RANDBIT, s->blockRandomised, 1);\n      */\n\n      s->origPtr = 0;\n      GET_UCHAR(BZ_X_ORIGPTR_1, uc);\n      s->origPtr = (s->origPtr << 8) | ((Int32)uc);\n      GET_UCHAR(BZ_X_ORIGPTR_2, uc);\n      s->origPtr = (s->origPtr << 8) | ((Int32)uc);\n      GET_UCHAR(BZ_X_ORIGPTR_3, uc);\n      s->origPtr = (s->origPtr << 8) | ((Int32)uc);\n\n      if (s->origPtr < 0)\n         RETURN(BZ_DATA_ERROR);\n      if (s->origPtr > 10 + 100000*s->blockSize100k) \n         RETURN(BZ_DATA_ERROR);\n\n      /*--- Receive the mapping table ---*/\n      for (i = 0; i < 16; i++) {\n         GET_BIT(BZ_X_MAPPING_1, uc);\n         if (uc == 1) \n            s->inUse16[i] = True; else \n            s->inUse16[i] = False;\n      }\n\n      for (i = 0; i < 256; i++) s->inUse[i] = False;\n\n      for (i = 0; i < 16; i++)\n         if (s->inUse16[i])\n            for (j = 0; j < 16; j++) {\n               GET_BIT(BZ_X_MAPPING_2, uc);\n               if (uc == 1) s->inUse[i * 16 + j] = True;\n            }\n      makeMaps_d ( s );\n      if (s->nInUse == 0) RETURN(BZ_DATA_ERROR);\n      alphaSize = s->nInUse+2;\n\n      /*--- Now the selectors ---*/\n      GET_BITS(BZ_X_SELECTOR_1, nGroups, 3);\n      if (nGroups < 2 || nGroups > 6) RETURN(BZ_DATA_ERROR);\n      GET_BITS(BZ_X_SELECTOR_2, nSelectors, 15);\n      if (nSelectors < 1) RETURN(BZ_DATA_ERROR);\n      for (i = 0; i < nSelectors; i++) {\n         j = 0;\n         while (True) {\n            GET_BIT(BZ_X_SELECTOR_3, uc);\n            if (uc == 0) break;\n            j++;\n            if (j >= nGroups) RETURN(BZ_DATA_ERROR);\n         }\n         s->selectorMtf[i] = j;\n      }\n\n      /*--- Undo the MTF values for the selectors. ---*/\n      {\n         UChar pos[BZ_N_GROUPS], tmp, v;\n         for (v = 0; v < nGroups; v++) pos[v] = v;\n   \n         for (i = 0; i < nSelectors; i++) {\n            v = s->selectorMtf[i];\n            tmp = pos[v];\n            while (v > 0) { pos[v] = pos[v-1]; v--; }\n            pos[0] = tmp;\n            s->selector[i] = tmp;\n         }\n      }\n\n      /*--- Now the coding tables ---*/\n      for (t = 0; t < nGroups; t++) {\n         GET_BITS(BZ_X_CODING_1, curr, 5);\n         for (i = 0; i < alphaSize; i++) {\n            while (True) {\n               if (curr < 1 || curr > 20) RETURN(BZ_DATA_ERROR);\n               GET_BIT(BZ_X_CODING_2, uc);\n               if (uc == 0) break;\n               GET_BIT(BZ_X_CODING_3, uc);\n               if (uc == 0) curr++; else curr--;\n            }\n            s->len[t][i] = curr;\n         }\n      }\n\n      /*--- Create the Huffman decoding tables ---*/\n      for (t = 0; t < nGroups; t++) {\n         minLen = 32;\n         maxLen = 0;\n         for (i = 0; i < alphaSize; i++) {\n            if (s->len[t][i] > maxLen) maxLen = s->len[t][i];\n            if (s->len[t][i] < minLen) minLen = s->len[t][i];\n         }\n         CreateDecodeTables ( \n            &(s->limit[t][0]), \n            &(s->base[t][0]), \n            &(s->perm[t][0]), \n            &(s->len[t][0]),\n            minLen, maxLen, alphaSize\n         );\n         s->minLens[t] = minLen;\n      }\n\n      /*--- Now the MTF values ---*/\n\n      EOB      = s->nInUse+1;\n      nblockMAX = 100000 * s->blockSize100k;\n      groupNo  = -1;\n      groupPos = 0;\n\n      for (i = 0; i <= 255; i++) s->unzftab[i] = 0;\n\n      /*-- MTF init --*/\n      {\n         Int32 ii, jj, kk;\n         kk = MTFA_SIZE-1;\n         for (ii = 256 / MTFL_SIZE - 1; ii >= 0; ii--) {\n            for (jj = MTFL_SIZE-1; jj >= 0; jj--) {\n               s->mtfa[kk] = (UChar)(ii * MTFL_SIZE + jj);\n               kk--;\n            }\n            s->mtfbase[ii] = kk + 1;\n         }\n      }\n      /*-- end MTF init --*/\n\n      nblock = 0;\n      GET_MTF_VAL(BZ_X_MTF_1, BZ_X_MTF_2, nextSym);\n\n      while (True) {\n\n         if (nextSym == EOB) break;\n\n         if (nextSym == BZ_RUNA || nextSym == BZ_RUNB) {\n\n            es = -1;\n            N = 1;\n            do {\n               /* Check that N doesn't get too big, so that es doesn't\n                  go negative.  The maximum value that can be\n                  RUNA/RUNB encoded is equal to the block size (post\n                  the initial RLE), viz, 900k, so bounding N at 2\n                  million should guard against overflow without\n                  rejecting any legitimate inputs. */\n\t       if (N >= 2*1024*1024) RETURN(BZ_DATA_ERROR);\n               if (nextSym == BZ_RUNA) es = es + (0+1) * N; else\n               if (nextSym == BZ_RUNB) es = es + (1+1) * N;\n               N = N * 2;\n               GET_MTF_VAL(BZ_X_MTF_3, BZ_X_MTF_4, nextSym);\n            }\n               while (nextSym == BZ_RUNA || nextSym == BZ_RUNB);\n\n            es++;\n            uc = s->seqToUnseq[ s->mtfa[s->mtfbase[0]] ];\n            s->unzftab[uc] += es;\n\n            if (s->smallDecompress)\n               while (es > 0) {\n                  if (nblock >= nblockMAX) RETURN(BZ_DATA_ERROR);\n                  s->ll16[nblock] = (UInt16)uc;\n                  nblock++;\n                  es--;\n               }\n            else\n               while (es > 0) {\n                  if (nblock >= nblockMAX) RETURN(BZ_DATA_ERROR);\n                  s->tt[nblock] = (UInt32)uc;\n                  nblock++;\n                  es--;\n               };\n\n            continue;\n\n         } else {\n\n            if (nblock >= nblockMAX) RETURN(BZ_DATA_ERROR);\n\n            /*-- uc = MTF ( nextSym-1 ) --*/\n            {\n               Int32 ii, jj, kk, pp, lno, off;\n               UInt32 nn;\n               nn = (UInt32)(nextSym - 1);\n\n               if (nn < MTFL_SIZE) {\n                  /* avoid general-case expense */\n                  pp = s->mtfbase[0];\n                  uc = s->mtfa[pp+nn];\n                  while (nn > 3) {\n                     Int32 z = pp+nn;\n                     s->mtfa[(z)  ] = s->mtfa[(z)-1];\n                     s->mtfa[(z)-1] = s->mtfa[(z)-2];\n                     s->mtfa[(z)-2] = s->mtfa[(z)-3];\n                     s->mtfa[(z)-3] = s->mtfa[(z)-4];\n                     nn -= 4;\n                  }\n                  while (nn > 0) { \n                     s->mtfa[(pp+nn)] = s->mtfa[(pp+nn)-1]; nn--; \n                  };\n                  s->mtfa[pp] = uc;\n               } else { \n                  /* general case */\n                  lno = nn / MTFL_SIZE;\n                  off = nn % MTFL_SIZE;\n                  pp = s->mtfbase[lno] + off;\n                  uc = s->mtfa[pp];\n                  while (pp > s->mtfbase[lno]) { \n                     s->mtfa[pp] = s->mtfa[pp-1]; pp--; \n                  };\n                  s->mtfbase[lno]++;\n                  while (lno > 0) {\n                     s->mtfbase[lno]--;\n                     s->mtfa[s->mtfbase[lno]] \n                        = s->mtfa[s->mtfbase[lno-1] + MTFL_SIZE - 1];\n                     lno--;\n                  }\n                  s->mtfbase[0]--;\n                  s->mtfa[s->mtfbase[0]] = uc;\n                  if (s->mtfbase[0] == 0) {\n                     kk = MTFA_SIZE-1;\n                     for (ii = 256 / MTFL_SIZE-1; ii >= 0; ii--) {\n                        for (jj = MTFL_SIZE-1; jj >= 0; jj--) {\n                           s->mtfa[kk] = s->mtfa[s->mtfbase[ii] + jj];\n                           kk--;\n                        }\n                        s->mtfbase[ii] = kk + 1;\n                     }\n                  }\n               }\n            }\n            /*-- end uc = MTF ( nextSym-1 ) --*/\n\n            s->unzftab[s->seqToUnseq[uc]]++;\n            if (s->smallDecompress)\n               s->ll16[nblock] = (UInt16)(s->seqToUnseq[uc]); else\n               s->tt[nblock]   = (UInt32)(s->seqToUnseq[uc]);\n            nblock++;\n\n            GET_MTF_VAL(BZ_X_MTF_5, BZ_X_MTF_6, nextSym);\n            continue;\n         }\n      }\n\n      /* Now we know what nblock is, we can do a better sanity\n         check on s->origPtr.\n      */\n      if (s->origPtr < 0 || s->origPtr >= nblock)\n         RETURN(BZ_DATA_ERROR);\n\n      /*-- Set up cftab to facilitate generation of T^(-1) --*/\n      /* Check: unzftab entries in range. */\n      for (i = 0; i <= 255; i++) {\n         if (s->unzftab[i] < 0 || s->unzftab[i] > nblock)\n            RETURN(BZ_DATA_ERROR);\n      }\n      /* Actually generate cftab. */\n      s->cftab[0] = 0;\n      for (i = 1; i <= 256; i++) s->cftab[i] = s->unzftab[i-1];\n      for (i = 1; i <= 256; i++) s->cftab[i] += s->cftab[i-1];\n      /* Check: cftab entries in range. */\n      for (i = 0; i <= 256; i++) {\n         if (s->cftab[i] < 0 || s->cftab[i] > nblock) {\n            RETURN(BZ_DATA_ERROR);\n         }\n      }\n      /* Check: cftab entries non-descending. */\n      for (i = 1; i <= 256; i++) {\n         if (s->cftab[i-1] > s->cftab[i]) {\n            RETURN(BZ_DATA_ERROR);\n         }\n      }\n\n      s->state_out_len = 0;\n      s->state_out_ch  = 0;\n      /* BZ_INITIALISE_CRC ( s->calculatedBlockCRC ); */\n      s->state = BZ_X_OUTPUT;\n      if (s->verbosity >= 2) VPrintf0 ( \"rt+rld\" );\n\n      if (s->smallDecompress) {\n\n         /*-- Make a copy of cftab, used in generation of T --*/\n         for (i = 0; i <= 256; i++) s->cftabCopy[i] = s->cftab[i];\n\n         /*-- compute the T vector --*/\n         for (i = 0; i < nblock; i++) {\n            uc = (UChar)(s->ll16[i]);\n            SET_LL(i, s->cftabCopy[uc]);\n            s->cftabCopy[uc]++;\n         }\n\n         /*-- Compute T^(-1) by pointer reversal on T --*/\n         i = s->origPtr;\n         j = GET_LL(i);\n         do {\n            Int32 tmp = GET_LL(j);\n            SET_LL(j, i);\n            i = j;\n            j = tmp;\n         }\n            while (i != s->origPtr);\n\n         s->tPos = s->origPtr;\n         s->nblock_used = 0;\n\t /* aCaB\n         if (s->blockRandomised) {\n            BZ_RAND_INIT_MASK;\n            BZ_GET_SMALL(s->k0); s->nblock_used++;\n            BZ_RAND_UPD_MASK; s->k0 ^= BZ_RAND_MASK; \n\t    } else */{\n            BZ_GET_SMALL(s->k0); s->nblock_used++;\n         }\n\n      } else {\n\n         /*-- compute the T^(-1) vector --*/\n         for (i = 0; i < nblock; i++) {\n            uc = (UChar)(s->tt[i] & 0xff);\n            s->tt[s->cftab[uc]] |= (i << 8);\n            s->cftab[uc]++;\n         }\n\n         s->tPos = s->tt[s->origPtr] >> 8;\n         s->nblock_used = 0;\n\t /* aCaB\n         if (s->blockRandomised) {\n            BZ_RAND_INIT_MASK;\n            BZ_GET_FAST(s->k0); s->nblock_used++;\n            BZ_RAND_UPD_MASK; s->k0 ^= BZ_RAND_MASK; \n\t    } else */{\n            BZ_GET_FAST(s->k0); s->nblock_used++;\n         }\n\n      }\n\n      RETURN(BZ_OK);\n\n\n\n    endhdr_2:\n      /* aCaB\n      GET_UCHAR(BZ_X_ENDHDR_2, uc);\n      if (uc != 0x72) RETURN(BZ_DATA_ERROR);\n      GET_UCHAR(BZ_X_ENDHDR_3, uc);\n      if (uc != 0x45) RETURN(BZ_DATA_ERROR);\n      GET_UCHAR(BZ_X_ENDHDR_4, uc);\n      if (uc != 0x38) RETURN(BZ_DATA_ERROR);\n      GET_UCHAR(BZ_X_ENDHDR_5, uc);\n      if (uc != 0x50) RETURN(BZ_DATA_ERROR);\n      GET_UCHAR(BZ_X_ENDHDR_6, uc);\n      if (uc != 0x90) RETURN(BZ_DATA_ERROR);\n\n      s->storedCombinedCRC = 0;\n      GET_UCHAR(BZ_X_CCRC_1, uc);\n      s->storedCombinedCRC = (s->storedCombinedCRC << 8) | ((UInt32)uc);\n      GET_UCHAR(BZ_X_CCRC_2, uc);\n      s->storedCombinedCRC = (s->storedCombinedCRC << 8) | ((UInt32)uc);\n      GET_UCHAR(BZ_X_CCRC_3, uc);\n      s->storedCombinedCRC = (s->storedCombinedCRC << 8) | ((UInt32)uc);\n      GET_UCHAR(BZ_X_CCRC_4, uc);\n      s->storedCombinedCRC = (s->storedCombinedCRC << 8) | ((UInt32)uc);\n      */\n      s->state = BZ_X_IDLE;\n      RETURN(BZ_STREAM_END);\n\n   default: /* aCaB AssertH ( False, 4001 ); */\n     RETURN(BZ_DATA_ERROR);\n   }\n\n   /* aCaB AssertH ( False, 4002 ); */\n   RETURN(BZ_DATA_ERROR);\n\n   save_state_and_return:\n\n   s->save_i           = i;\n   s->save_j           = j;\n   s->save_t           = t;\n   s->save_alphaSize   = alphaSize;\n   s->save_nGroups     = nGroups;\n   s->save_nSelectors  = nSelectors;\n   s->save_EOB         = EOB;\n   s->save_groupNo     = groupNo;\n   s->save_groupPos    = groupPos;\n   s->save_nextSym     = nextSym;\n   s->save_nblockMAX   = nblockMAX;\n   s->save_nblock      = nblock;\n   s->save_es          = es;\n   s->save_N           = N;\n   s->save_curr        = curr;\n   s->save_zt          = zt;\n   s->save_zn          = zn;\n   s->save_zvec        = zvec;\n   s->save_zj          = zj;\n   s->save_gSel        = gSel;\n   s->save_gMinlen     = gMinlen;\n   s->save_gLimit      = gLimit;\n   s->save_gBase       = gBase;\n   s->save_gPerm       = gPerm;\n\n   return retVal;   \n}",
        "start_line": 481
      }
    ],
    "code_context": "Called Methods:\n- BZ_RUNA: #define BZ_RUNA 0 /* <=== libclamav/nsis/bzlib_private.h:120:120:BZ_RUNA:0 */ \n- True: #define True  ((Bool)1) /* <=== libclamav/nsis/bzlib_private.h:51:51:True:0 */ \n- MTFA_SIZE: #define MTFA_SIZE 4096 /* <=== libclamav/nsis/bzlib_private.h:320:320:MTFA_SIZE:0 */ \n- VPrintf0: #define VPrintf0(zf)                     do { } while (0) /* <=== libclamav/nsis/bzlib_private.h:95:95:VPrintf0:1 */ \n- BZALLOC: #define BZALLOC(nnn) (strm->bzalloc)(strm->opaque,(nnn),1) /* <=== libclamav/nsis/bzlib_private.h:104:104:BZALLOC:1 */ \n- indexIntoF: inline static Int32 indexIntoF ( Int32 indx, Int32 *cftab ) /* <=== indexIntoF */ \n{\n   Int32 nb, na, mid;\n   nb = 0;\n   na = 256;\n   do {\n      mid = (nb + na) >> 1;\n      if (indx >= cftab[mid]) nb = mid; else na = mid;\n   }\n   while (na - nb != 1);\n   return nb;\n}\n- BZ_GET_FAST: #define BZ_GET_FAST(cccc)                     \\ /* <=== libclamav/nsis/bzlib_private.h:424:429:BZ_GET_FAST:1 */ \n    /* c_tPos is unsigned, hence test < 0 is pointless. */ \\\n    if (s->tPos >= (UInt32)100000 * (UInt32)s->blockSize100k) return True; \\\n    s->tPos = s->tt[s->tPos];                 \\\n    cccc = (UChar)(s->tPos & 0xff);           \\\n    s->tPos >>= 8;\n- MTFL_SIZE: #define MTFL_SIZE 16 /* <=== libclamav/nsis/bzlib_private.h:321:321:MTFL_SIZE:0 */ \n- BZ_N_GROUPS: #define BZ_N_GROUPS 6 /* <=== libclamav/nsis/bzlib_private.h:123:123:BZ_N_GROUPS:0 */ \n- BZ_X_MAGIC_1: #define BZ_X_MAGIC_1     10 /* <=== libclamav/nsis/bzlib_private.h:274:274:BZ_X_MAGIC_1:0 */ \n- BZ_GET_SMALL: #define BZ_GET_SMALL(cccc)                            \\ /* <=== libclamav/nsis/bzlib_private.h:455:459:BZ_GET_SMALL:1 */ \n      /* c_tPos is unsigned, hence test < 0 is pointless. */ \\\n      if (s->tPos >= (UInt32)100000 * (UInt32)s->blockSize100k) return True; \\\n      cccc = indexIntoF ( s->tPos, s->cftab );    \\\n      s->tPos = GET_LL(s->tPos);\n- BZ_X_IDLE: #define BZ_X_IDLE        1 /* <=== libclamav/nsis/bzlib_private.h:271:271:BZ_X_IDLE:0 */ \n- BZ_X_OUTPUT: #define BZ_X_OUTPUT      2 /* <=== libclamav/nsis/bzlib_private.h:272:272:BZ_X_OUTPUT:0 */ \n- SET_LL: #define SET_LL(i,n)                          \\ /* <=== libclamav/nsis/bzlib_private.h:447:450:SET_LL:2 */ \n   { s->ll16[i] = (UInt16)(n & 0x0000ffff);  \\\n     SET_LL4(i, n >> 16);                    \\\n   }\n- BZ_RUNB: #define BZ_RUNB 1 /* <=== libclamav/nsis/bzlib_private.h:121:121:BZ_RUNB:0 */ \n- GET_MTF_VAL: #define GET_MTF_VAL(label1,label2,lval)           \\ /* <=== libclamav/nsis/bzlib.c:140:168:GET_MTF_VAL:3 */ \n{                                                 \\\n   if (groupPos == 0) {                           \\\n      groupNo++;                                  \\\n      if (groupNo >= nSelectors)                  \\\n         RETURN(BZ_DATA_ERROR);                   \\\n      groupPos = BZ_G_SIZE;                       \\\n      gSel = s->selector[groupNo];                \\\n      gMinlen = s->minLens[gSel];                 \\\n      gLimit = &(s->limit[gSel][0]);              \\\n      gPerm = &(s->perm[gSel][0]);                \\\n      gBase = &(s->base[gSel][0]);                \\\n   }                                              \\\n   groupPos--;                                    \\\n   zn = gMinlen;                                  \\\n   GET_BITS(label1, zvec, zn);                    \\\n   while (1) {                                    \\\n      if (zn > 20 /* the longest code */)         \\\n         RETURN(BZ_DATA_ERROR);                   \\\n      if (zvec <= gLimit[zn]) break;              \\\n      zn++;                                       \\\n      GET_BIT(label2, zj);                        \\\n      zvec = (zvec << 1) | zj;                    \\\n   };                                             \\\n   if (zvec - gBase[zn] < 0                       \\\n       || zvec - gBase[zn] >= BZ_MAX_ALPHA_SIZE)  \\\n      RETURN(BZ_DATA_ERROR);                      \\\n   lval = gPerm[zvec - gBase[zn]];                \\\n}\n- False: #define False ((Bool)0) /* <=== libclamav/nsis/bzlib_private.h:52:52:False:0 */ \n- GET_LL: #define GET_LL(i) \\ /* <=== libclamav/nsis/bzlib_private.h:452:453:GET_LL:1 */ \n   (((UInt32)s->ll16[i]) | (GET_LL4(i) << 16))\n- RETURN: #define RETURN(rrr)                               \\ /* <=== libclamav/nsis/bzlib.c:106:107:RETURN:1 */ \n   { retVal = rrr; goto save_state_and_return; };\n\nType Definitions:\n- ANY: typedef struct {\n\tMD5_u32plus lo, hi;\n\tMD5_u32plus a, b, c, d;\n\tunsigned char buffer[64];\n\tMD5_u32plus block[16];\n}\n- UInt32: typedef unsigned int    UInt32;\n- Int32: typedef int             Int32;\n- DState: typedef\n   struct {\n      /* pointer back to the struct nsis_bzstream */\n      nsis_bzstream* strm;\n\n      /* state indicator for this stream */\n      Int32    state;\n\n      /* for doing the final run-length decoding */\n      UChar    state_out_ch;\n      Int32    state_out_len;\n      Bool     blockRandomised;\n      BZ_RAND_DECLS;\n\n      /* the buffer for bit stream reading */\n      UInt32   bsBuff;\n      Int32    bsLive;\n\n      /* misc administratium */\n      Int32    blockSize100k;\n      Bool     smallDecompress;\n      Int32    currBlockNo;\n      Int32    verbosity;\n\n      /* for undoing the Burrows-Wheeler transform */\n      Int32    origPtr;\n      UInt32   tPos;\n      Int32    k0;\n      Int32    unzftab[256];\n      Int32    nblock_used;\n      Int32    cftab[257];\n      Int32    cftabCopy[257];\n\n      /* for undoing the Burrows-Wheeler transform (FAST) */\n      UInt32   *tt;\n\n      /* for undoing the Burrows-Wheeler transform (SMALL) */\n      UInt16   *ll16;\n      UChar    *ll4;\n\n      /* stored and calculated CRCs */\n      UInt32   storedBlockCRC;\n      UInt32   storedCombinedCRC;\n      UInt32   calculatedBlockCRC;\n      UInt32   calculatedCombinedCRC;\n\n      /* map of bytes used in block */\n      Int32    nInUse;\n      Bool     inUse[256];\n      Bool     inUse16[16];\n      UChar    seqToUnseq[256];\n\n      /* for decoding the MTF values */\n      UChar    mtfa   [MTFA_SIZE];\n      Int32    mtfbase[256 / MTFL_SIZE];\n      UChar    selector   [BZ_MAX_SELECTORS];\n      UChar    selectorMtf[BZ_MAX_SELECTORS];\n      UChar    len  [BZ_N_GROUPS][BZ_MAX_ALPHA_SIZE];\n\n      Int32    limit  [BZ_N_GROUPS][BZ_MAX_ALPHA_SIZE];\n      Int32    base   [BZ_N_GROUPS][BZ_MAX_ALPHA_SIZE];\n      Int32    perm   [BZ_N_GROUPS][BZ_MAX_ALPHA_SIZE];\n      Int32    minLens[BZ_N_GROUPS];\n\n      /* save area for scalars in the main decompress code */\n      Int32    save_i;\n      Int32    save_j;\n      Int32    save_t;\n      Int32    save_alphaSize;\n      Int32    save_nGroups;\n      Int32    save_nSelectors;\n      Int32    save_EOB;\n      Int32    save_groupNo;\n      Int32    save_groupPos;\n      Int32    save_nextSym;\n      Int32    save_nblockMAX;\n      Int32    save_nblock;\n      Int32    save_es;\n      Int32    save_N;\n      Int32    save_curr;\n      Int32    save_zt;\n      Int32    save_zn; \n      Int32    save_zvec;\n      Int32    save_zj;\n      Int32    save_gSel;\n      Int32    save_gMinlen;\n      Int32*   save_gLimit;\n      Int32*   save_gBase;\n      Int32*   save_gPerm;\n\n   }\n- UChar: typedef unsigned char   UChar;\n\nImports:\n- #include \"clamav-config.h\"\n- #include \"bzlib_private.h\"\n- #include \"others.h\"",
    "commit_msg": "bb#2230-2231",
    "cve_desc": "Integer overflow in the BZ2_decompress function in decompress.c in bzip2 and libbzip2 before 1.0.6 allows context-dependent attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted compressed file.",
    "year": 2010,
    "filename": "bzlib.c",
    "commit_url": "\"https://github.com/vrtadmin/clamav-devel/commit/fcd8091474d12592d509adcfd0bdd0b0dc8835f5\""
  },
  {
    "repository": "samba-team/samba",
    "cve_id": "CVE-2010-0788",
    "cwe_list": [
      "CWE-59"
    ],
    "commit_hash": "a065c177dfc8f968775593ba00dffafeebb2e054",
    "short_hash": "a065c177",
    "vulnerableMethods_before": [
      {
        "filename": "client/mount.cifs.c",
        "method_name": "main",
        "raw_code": "int main(int argc, char ** argv) /* <=== main */ \n{\n\tint c;\n\tunsigned long flags = MS_MANDLOCK;\n\tchar * orgoptions = NULL;\n\tchar * share_name = NULL;\n\tconst char * ipaddr = NULL;\n\tchar * uuid = NULL;\n\tchar * mountpoint = NULL;\n\tchar * options = NULL;\n\tchar * optionstail;\n\tchar * resolved_path = NULL;\n\tchar * temp;\n\tchar * dev_name;\n\tint rc = 0;\n\tint rsize = 0;\n\tint wsize = 0;\n\tint nomtab = 0;\n\tint uid = 0;\n\tint gid = 0;\n\tint optlen = 0;\n\tint orgoptlen = 0;\n\tsize_t options_size = 0;\n\tsize_t current_len;\n\tint retry = 0; /* set when we have to retry mount with uppercase */\n\tstruct addrinfo *addrhead = NULL, *addr;\n\tstruct utsname sysinfo;\n\tstruct mntent mountent;\n\tstruct sockaddr_in *addr4;\n\tstruct sockaddr_in6 *addr6;\n\tFILE * pmntfile;\n\n\t/* setlocale(LC_ALL, \"\");\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE); */\n\n\tif(argc && argv)\n\t\tthisprogram = argv[0];\n\telse\n\t\tmount_cifs_usage(stderr);\n\n\tif(thisprogram == NULL)\n\t\tthisprogram = \"mount.cifs\";\n\n\tuname(&sysinfo);\n\t/* BB add workstation name and domain and pass down */\n\n/* #ifdef _GNU_SOURCE\n\tfprintf(stderr, \" node: %s machine: %s sysname %s domain %s\\n\", sysinfo.nodename,sysinfo.machine,sysinfo.sysname,sysinfo.domainname);\n#endif */\n\tif(argc > 2) {\n\t\tdev_name = argv[1];\n\t\tshare_name = strndup(argv[1], MAX_UNC_LEN);\n\t\tif (share_name == NULL) {\n\t\t\tfprintf(stderr, \"%s: %s\", argv[0], strerror(ENOMEM));\n\t\t\texit(EX_SYSERR);\n\t\t}\n\t\tmountpoint = argv[2];\n\t} else if (argc == 2) {\n\t\tif ((strcmp(argv[1], \"-V\") == 0) ||\n\t\t    (strcmp(argv[1], \"--version\") == 0))\n\t\t{\n\t\t\tprint_cifs_mount_version();\n\t\t\texit(0);\n\t\t}\n\n\t\tif ((strcmp(argv[1], \"-h\") == 0) ||\n\t\t    (strcmp(argv[1], \"-?\") == 0) ||\n\t\t    (strcmp(argv[1], \"--help\") == 0))\n\t\t\tmount_cifs_usage(stdout);\n\n\t\tmount_cifs_usage(stderr);\n\t} else {\n\t\tmount_cifs_usage(stderr);\n\t}\n\n\n\t/* add sharename in opts string as unc= parm */\n\twhile ((c = getopt_long (argc, argv, \"afFhilL:no:O:rsSU:vVwt:\",\n\t\t\t longopts, NULL)) != -1) {\n\t\tswitch (c) {\n/* No code to do the following  options yet */\n/*\tcase 'l':\n\t\tlist_with_volumelabel = 1;\n\t\tbreak;\n\tcase 'L':\n\t\tvolumelabel = optarg;\n\t\tbreak; */\n/*\tcase 'a':\t       \n\t\t++mount_all;\n\t\tbreak; */\n\n\t\tcase '?':\n\t\tcase 'h':\t /* help */\n\t\t\tmount_cifs_usage(stdout);\n\t\tcase 'n':\n\t\t\t++nomtab;\n\t\t\tbreak;\n\t\tcase 'b':\n#ifdef MS_BIND\n\t\t\tflags |= MS_BIND;\n#else\n\t\t\tfprintf(stderr,\n\t\t\t\t\"option 'b' (MS_BIND) not supported\\n\");\n#endif\n\t\t\tbreak;\n\t\tcase 'm':\n#ifdef MS_MOVE\t\t      \n\t\t\tflags |= MS_MOVE;\n#else\n\t\t\tfprintf(stderr,\n\t\t\t\t\"option 'm' (MS_MOVE) not supported\\n\");\n#endif\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\torgoptions = strdup(optarg);\n\t\t    break;\n\t\tcase 'r':  /* mount readonly */\n\t\t\tflags |= MS_RDONLY;\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tuuid = optarg;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\t++verboseflag;\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tprint_cifs_mount_version();\n\t\t\texit (0);\n\t\tcase 'w':\n\t\t\tflags &= ~MS_RDONLY;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\trsize = atoi(optarg) ;\n\t\t\tbreak;\n\t\tcase 'W':\n\t\t\twsize = atoi(optarg);\n\t\t\tbreak;\n\t\tcase '1':\n\t\t\tif (isdigit(*optarg)) {\n\t\t\t\tchar *ep;\n\n\t\t\t\tuid = strtoul(optarg, &ep, 10);\n\t\t\t\tif (*ep) {\n\t\t\t\t\tfprintf(stderr, \"bad uid value \\\"%s\\\"\\n\", optarg);\n\t\t\t\t\texit(EX_USAGE);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstruct passwd *pw;\n\n\t\t\t\tif (!(pw = getpwnam(optarg))) {\n\t\t\t\t\tfprintf(stderr, \"bad user name \\\"%s\\\"\\n\", optarg);\n\t\t\t\t\texit(EX_USAGE);\n\t\t\t\t}\n\t\t\t\tuid = pw->pw_uid;\n\t\t\t\tendpwent();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '2':\n\t\t\tif (isdigit(*optarg)) {\n\t\t\t\tchar *ep;\n\n\t\t\t\tgid = strtoul(optarg, &ep, 10);\n\t\t\t\tif (*ep) {\n\t\t\t\t\tfprintf(stderr, \"bad gid value \\\"%s\\\"\\n\", optarg);\n\t\t\t\t\texit(EX_USAGE);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstruct group *gr;\n\n\t\t\t\tif (!(gr = getgrnam(optarg))) {\n\t\t\t\t\tfprintf(stderr, \"bad user name \\\"%s\\\"\\n\", optarg);\n\t\t\t\t\texit(EX_USAGE);\n\t\t\t\t}\n\t\t\t\tgid = gr->gr_gid;\n\t\t\t\tendpwent();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tgot_user = 1;\n\t\t\tuser_name = optarg;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdomain_name = optarg; /* BB fix this - currently ignored */\n\t\t\tgot_domain = 1;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tif(mountpassword == NULL)\n\t\t\t\tmountpassword = (char *)calloc(MOUNT_PASSWD_SIZE+1,1);\n\t\t\tif(mountpassword) {\n\t\t\t\tgot_password = 1;\n\t\t\t\tstrlcpy(mountpassword,optarg,MOUNT_PASSWD_SIZE+1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tget_password_from_file(0 /* stdin */,NULL);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\t++fakemnt;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"unknown mount option %c\\n\",c);\n\t\t\tmount_cifs_usage(stderr);\n\t\t}\n\t}\n\n\tif((argc < 3) || (dev_name == NULL) || (mountpoint == NULL)) {\n\t\tmount_cifs_usage(stderr);\n\t}\n\n\t/* make sure mountpoint is legit */\n\trc = chdir(mountpoint);\n\tif (rc) {\n\t\tfprintf(stderr, \"Couldn't chdir to %s: %s\\n\", mountpoint,\n\t\t\t\tstrerror(errno));\n\t\trc = EX_USAGE;\n\t\tgoto mount_exit;\n\t}\n\n\trc = check_mountpoint(thisprogram, mountpoint);\n\tif (rc)\n\t\tgoto mount_exit;\n\n\t/* sanity check for unprivileged mounts */\n\tif (getuid()) {\n\t\trc = check_fstab(thisprogram, mountpoint, dev_name,\n\t\t\t\t &orgoptions);\n\t\tif (rc)\n\t\t\tgoto mount_exit;\n\n\t\t/* enable any default user mount flags */\n\t\tflags |= CIFS_SETUID_FLAGS;\n\t}\n\n\tif (getenv(\"PASSWD\")) {\n\t\tif(mountpassword == NULL)\n\t\t\tmountpassword = (char *)calloc(MOUNT_PASSWD_SIZE+1,1);\n\t\tif(mountpassword) {\n\t\t\tstrlcpy(mountpassword,getenv(\"PASSWD\"),MOUNT_PASSWD_SIZE+1);\n\t\t\tgot_password = 1;\n\t\t}\n\t} else if (getenv(\"PASSWD_FD\")) {\n\t\tget_password_from_file(atoi(getenv(\"PASSWD_FD\")),NULL);\n\t} else if (getenv(\"PASSWD_FILE\")) {\n\t\tget_password_from_file(0, getenv(\"PASSWD_FILE\"));\n\t}\n\n        if (orgoptions && parse_options(&orgoptions, &flags)) {\n                rc = EX_USAGE;\n\t\tgoto mount_exit;\n\t}\n\n\tif (getuid()) {\n#if !CIFS_LEGACY_SETUID_CHECK\n\t\tif (!(flags & (MS_USERS|MS_USER))) {\n\t\t\tfprintf(stderr, \"%s: permission denied\\n\", thisprogram);\n\t\t\trc = EX_USAGE;\n\t\t\tgoto mount_exit;\n\t\t}\n#endif /* !CIFS_LEGACY_SETUID_CHECK */\n\t\t\n\t\tif (geteuid()) {\n\t\t\tfprintf(stderr, \"%s: not installed setuid - \\\"user\\\" \"\n\t\t\t\t\t\"CIFS mounts not supported.\",\n\t\t\t\t\tthisprogram);\n\t\t\trc = EX_FAIL;\n\t\t\tgoto mount_exit;\n\t\t}\n\t}\n\n\tflags &= ~(MS_USERS|MS_USER);\n\n\taddrhead = addr = parse_server(&share_name);\n\tif((addrhead == NULL) && (got_ip == 0)) {\n\t\tfprintf(stderr, \"No ip address specified and hostname not found\\n\");\n\t\trc = EX_USAGE;\n\t\tgoto mount_exit;\n\t}\n\t\n\t/* BB save off path and pop after mount returns? */\n\tresolved_path = (char *)malloc(PATH_MAX+1);\n\tif (!resolved_path) {\n\t\tfprintf(stderr, \"Unable to allocate memory.\\n\");\n\t\trc = EX_SYSERR;\n\t\tgoto mount_exit;\n\t}\n\n\t/* Note that if we can not canonicalize the name, we get\n\t   another chance to see if it is valid when we chdir to it */\n\tif(!realpath(\".\", resolved_path)) {\n\t\tfprintf(stderr, \"Unable to resolve %s to canonical path: %s\\n\",\n\t\t\t\tmountpoint, strerror(errno));\n\t\trc = EX_SYSERR;\n\t\tgoto mount_exit;\n\t}\n\n\tmountpoint = resolved_path; \n\n\tif(got_user == 0) {\n\t\t/* Note that the password will not be retrieved from the\n\t\t   USER env variable (ie user%password form) as there is\n\t\t   already a PASSWD environment varaible */\n\t\tif (getenv(\"USER\"))\n\t\t\tuser_name = strdup(getenv(\"USER\"));\n\t\tif (user_name == NULL)\n\t\t\tuser_name = getusername();\n\t\tgot_user = 1;\n\t}\n       \n\tif(got_password == 0) {\n\t\tchar *tmp_pass = getpass(\"Password: \"); /* BB obsolete sys call but\n\t\t\t\t\t\t\t   no good replacement yet. */\n\t\tmountpassword = (char *)calloc(MOUNT_PASSWD_SIZE+1,1);\n\t\tif (!tmp_pass || !mountpassword) {\n\t\t\tfprintf(stderr, \"Password not entered, exiting\\n\");\n\t\t\texit(EX_USAGE);\n\t\t}\n\t\tstrlcpy(mountpassword, tmp_pass, MOUNT_PASSWD_SIZE+1);\n\t\tgot_password = 1;\n\t}\n\t/* FIXME launch daemon (handles dfs name resolution and credential change) \n\t   remember to clear parms and overwrite password field before launching */\n\tif(orgoptions) {\n\t\toptlen = strlen(orgoptions);\n\t\torgoptlen = optlen;\n\t} else\n\t\toptlen = 0;\n\tif(share_name)\n\t\toptlen += strlen(share_name) + 4;\n\telse {\n\t\tfprintf(stderr, \"No server share name specified\\n\");\n\t\tfprintf(stderr, \"\\nMounting the DFS root for server not implemented yet\\n\");\n                exit(EX_USAGE);\n\t}\n\tif(user_name)\n\t\toptlen += strlen(user_name) + 6;\n\toptlen += MAX_ADDRESS_LEN + 4;\n\tif(mountpassword)\n\t\toptlen += strlen(mountpassword) + 6;\nmount_retry:\n\tSAFE_FREE(options);\n\toptions_size = optlen + 10 + DOMAIN_SIZE;\n\toptions = (char *)malloc(options_size /* space for commas in password */ + 8 /* space for domain=  , domain name itself was counted as part of the length username string above */);\n\n\tif(options == NULL) {\n\t\tfprintf(stderr, \"Could not allocate memory for mount options\\n\");\n\t\texit(EX_SYSERR);\n\t}\n\n\tstrlcpy(options, \"unc=\", options_size);\n\tstrlcat(options,share_name,options_size);\n\t/* scan backwards and reverse direction of slash */\n\ttemp = strrchr(options, '/');\n\tif(temp > options + 6)\n\t\t*temp = '\\\\';\n\tif(user_name) {\n\t\t/* check for syntax like user=domain\\user */\n\t\tif(got_domain == 0)\n\t\t\tdomain_name = check_for_domain(&user_name);\n\t\tstrlcat(options,\",user=\",options_size);\n\t\tstrlcat(options,user_name,options_size);\n\t}\n\tif(retry == 0) {\n\t\tif(domain_name) {\n\t\t\t/* extra length accounted for in option string above */\n\t\t\tstrlcat(options,\",domain=\",options_size);\n\t\t\tstrlcat(options,domain_name,options_size);\n\t\t}\n\t}\n\n\tstrlcat(options,\",ver=\",options_size);\n\tstrlcat(options,MOUNT_CIFS_VERSION_MAJOR,options_size);\n\n\tif(orgoptions) {\n\t\tstrlcat(options,\",\",options_size);\n\t\tstrlcat(options,orgoptions,options_size);\n\t}\n\tif(prefixpath) {\n\t\tstrlcat(options,\",prefixpath=\",options_size);\n\t\tstrlcat(options,prefixpath,options_size); /* no need to cat the / */\n\t}\n\n\t/* convert all '\\\\' to '/' in share portion so that /proc/mounts looks pretty */\n\treplace_char(dev_name, '\\\\', '/', strlen(share_name));\n\n\tif (!got_ip && addr) {\n\t\tstrlcat(options, \",ip=\", options_size);\n\t\tcurrent_len = strnlen(options, options_size);\n\t\toptionstail = options + current_len;\n\t\tswitch (addr->ai_addr->sa_family) {\n\t\tcase AF_INET6:\n\t\t\taddr6 = (struct sockaddr_in6 *) addr->ai_addr;\n\t\t\tipaddr = inet_ntop(AF_INET6, &addr6->sin6_addr, optionstail,\n\t\t\t\t\t   options_size - current_len);\n\t\t\tbreak;\n\t\tcase AF_INET:\n\t\t\taddr4 = (struct sockaddr_in *) addr->ai_addr;\n\t\t\tipaddr = inet_ntop(AF_INET, &addr4->sin_addr, optionstail,\n\t\t\t\t\t   options_size - current_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tipaddr = NULL;\n\t\t}\n\n\t\t/* if the address looks bogus, try the next one */\n\t\tif (!ipaddr) {\n\t\t\taddr = addr->ai_next;\n\t\t\tif (addr)\n\t\t\t\tgoto mount_retry;\n\t\t\trc = EX_SYSERR;\n\t\t\tgoto mount_exit;\n\t\t}\n\t}\n\n\tif (addr->ai_addr->sa_family == AF_INET6 && addr6->sin6_scope_id) {\n\t\tstrlcat(options, \"%\", options_size);\n\t\tcurrent_len = strnlen(options, options_size);\n\t\toptionstail = options + current_len;\n\t\tsnprintf(optionstail, options_size - current_len, \"%u\",\n\t\t\t addr6->sin6_scope_id);\n\t}\n\n\tif(verboseflag)\n\t\tfprintf(stderr, \"\\nmount.cifs kernel mount options: %s\", options);\n\n\tif (mountpassword) {\n\t\t/*\n\t\t * Commas have to be doubled, or else they will\n\t\t * look like the parameter separator\n\t\t */\n\t\tif(retry == 0)\n\t\t\tcheck_for_comma(&mountpassword);\n\t\tstrlcat(options,\",pass=\",options_size);\n\t\tstrlcat(options,mountpassword,options_size);\n\t\tif (verboseflag)\n\t\t\tfprintf(stderr, \",pass=********\");\n\t}\n\n\tif (verboseflag)\n\t\tfprintf(stderr, \"\\n\");\n\n\tif (!fakemnt && mount(dev_name, \".\", cifs_fstype, flags, options)) {\n\t\tswitch (errno) {\n\t\tcase ECONNREFUSED:\n\t\tcase EHOSTUNREACH:\n\t\t\tif (addr) {\n\t\t\t\taddr = addr->ai_next;\n\t\t\t\tif (addr)\n\t\t\t\t\tgoto mount_retry;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ENODEV:\n\t\t\tfprintf(stderr, \"mount error: cifs filesystem not supported by the system\\n\");\n\t\t\tbreak;\n\t\tcase ENXIO:\n\t\t\tif(retry == 0) {\n\t\t\t\tretry = 1;\n\t\t\t\tif (uppercase_string(dev_name) &&\n\t\t\t\t    uppercase_string(share_name) &&\n\t\t\t\t    uppercase_string(prefixpath)) {\n\t\t\t\t\tfprintf(stderr, \"retrying with upper case share name\\n\");\n\t\t\t\t\tgoto mount_retry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfprintf(stderr, \"mount error(%d): %s\\n\", errno, strerror(errno));\n\t\tfprintf(stderr, \"Refer to the mount.cifs(8) manual page (e.g. man \"\n\t\t       \"mount.cifs)\\n\");\n\t\trc = EX_FAIL;\n\t\tgoto mount_exit;\n\t}\n\n\tif (nomtab)\n\t\tgoto mount_exit;\n\tatexit(unlock_mtab);\n\trc = lock_mtab();\n\tif (rc) {\n\t\tfprintf(stderr, \"cannot lock mtab\");\n\t\tgoto mount_exit;\n\t}\n\tpmntfile = setmntent(MOUNTED, \"a+\");\n\tif (!pmntfile) {\n\t\tfprintf(stderr, \"could not update mount table\\n\");\n\t\tunlock_mtab();\n\t\trc = EX_FILEIO;\n\t\tgoto mount_exit;\n\t}\n\tmountent.mnt_fsname = dev_name;\n\tmountent.mnt_dir = mountpoint;\n\tmountent.mnt_type = (char *)(void *)cifs_fstype;\n\tmountent.mnt_opts = (char *)malloc(220);\n\tif(mountent.mnt_opts) {\n\t\tchar * mount_user = getusername();\n\t\tmemset(mountent.mnt_opts,0,200);\n\t\tif(flags & MS_RDONLY)\n\t\t\tstrlcat(mountent.mnt_opts,\"ro\",220);\n\t\telse\n\t\t\tstrlcat(mountent.mnt_opts,\"rw\",220);\n\t\tif(flags & MS_MANDLOCK)\n\t\t\tstrlcat(mountent.mnt_opts,\",mand\",220);\n\t\tif(flags & MS_NOEXEC)\n\t\t\tstrlcat(mountent.mnt_opts,\",noexec\",220);\n\t\tif(flags & MS_NOSUID)\n\t\t\tstrlcat(mountent.mnt_opts,\",nosuid\",220);\n\t\tif(flags & MS_NODEV)\n\t\t\tstrlcat(mountent.mnt_opts,\",nodev\",220);\n\t\tif(flags & MS_SYNCHRONOUS)\n\t\t\tstrlcat(mountent.mnt_opts,\",sync\",220);\n\t\tif(mount_user) {\n\t\t\tif(getuid() != 0) {\n\t\t\t\tstrlcat(mountent.mnt_opts,\n\t\t\t\t\t\",user=\", 220);\n\t\t\t\tstrlcat(mountent.mnt_opts,\n\t\t\t\t\tmount_user, 220);\n\t\t\t}\n\t\t}\n\t}\n\tmountent.mnt_freq = 0;\n\tmountent.mnt_passno = 0;\n\trc = addmntent(pmntfile,&mountent);\n\tendmntent(pmntfile);\n\tunlock_mtab();\n\tSAFE_FREE(mountent.mnt_opts);\n\tif (rc)\n\t\trc = EX_FILEIO;\nmount_exit:\n\tif(mountpassword) {\n\t\tint len = strlen(mountpassword);\n\t\tmemset(mountpassword,0,len);\n\t\tSAFE_FREE(mountpassword);\n\t}\n\n\tif (addrhead)\n\t\tfreeaddrinfo(addrhead);\n\tSAFE_FREE(options);\n\tSAFE_FREE(orgoptions);\n\tSAFE_FREE(resolved_path);\n\tSAFE_FREE(share_name);\n\texit(rc);\n}",
        "start_line": 1167
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "client/mount.cifs.c",
        "method_name": "check_newline",
        "raw_code": "static int check_newline(const char *progname, const char *name) /* <=== check_newline */ \n{\n    char *s;\n    for (s = \"\\n\"; *s; s++) {\n        if (strchr(name, *s)) {\n            fprintf(stderr, \"%s: illegal character 0x%02x in mount entry\\n\",\n                    progname, *s);\n            return EX_USAGE;\n        }\n    }\n    return 0;\n}",
        "start_line": 1174
      },
      {
        "filename": "client/mount.cifs.c",
        "method_name": "check_mtab",
        "raw_code": "static int check_mtab(const char *progname, const char *devname, /* <=== check_mtab */ \n\t\t\tconst char *dir)\n{\n\tif (check_newline(progname, devname) == -1 ||\n\t    check_newline(progname, dir) == -1)\n\t\treturn EX_USAGE;\n\treturn 0;\n}",
        "start_line": 1187
      },
      {
        "filename": "client/mount.cifs.c",
        "method_name": "main",
        "raw_code": "int main(int argc, char ** argv) /* <=== main */ \n{\n\tint c;\n\tunsigned long flags = MS_MANDLOCK;\n\tchar * orgoptions = NULL;\n\tchar * share_name = NULL;\n\tconst char * ipaddr = NULL;\n\tchar * uuid = NULL;\n\tchar * mountpoint = NULL;\n\tchar * options = NULL;\n\tchar * optionstail;\n\tchar * resolved_path = NULL;\n\tchar * temp;\n\tchar * dev_name;\n\tint rc = 0;\n\tint rsize = 0;\n\tint wsize = 0;\n\tint nomtab = 0;\n\tint uid = 0;\n\tint gid = 0;\n\tint optlen = 0;\n\tint orgoptlen = 0;\n\tsize_t options_size = 0;\n\tsize_t current_len;\n\tint retry = 0; /* set when we have to retry mount with uppercase */\n\tstruct addrinfo *addrhead = NULL, *addr;\n\tstruct utsname sysinfo;\n\tstruct mntent mountent;\n\tstruct sockaddr_in *addr4;\n\tstruct sockaddr_in6 *addr6;\n\tFILE * pmntfile;\n\n\t/* setlocale(LC_ALL, \"\");\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE); */\n\n\tif(argc && argv)\n\t\tthisprogram = argv[0];\n\telse\n\t\tmount_cifs_usage(stderr);\n\n\tif(thisprogram == NULL)\n\t\tthisprogram = \"mount.cifs\";\n\n\tuname(&sysinfo);\n\t/* BB add workstation name and domain and pass down */\n\n/* #ifdef _GNU_SOURCE\n\tfprintf(stderr, \" node: %s machine: %s sysname %s domain %s\\n\", sysinfo.nodename,sysinfo.machine,sysinfo.sysname,sysinfo.domainname);\n#endif */\n\tif(argc > 2) {\n\t\tdev_name = argv[1];\n\t\tshare_name = strndup(argv[1], MAX_UNC_LEN);\n\t\tif (share_name == NULL) {\n\t\t\tfprintf(stderr, \"%s: %s\", argv[0], strerror(ENOMEM));\n\t\t\texit(EX_SYSERR);\n\t\t}\n\t\tmountpoint = argv[2];\n\t} else if (argc == 2) {\n\t\tif ((strcmp(argv[1], \"-V\") == 0) ||\n\t\t    (strcmp(argv[1], \"--version\") == 0))\n\t\t{\n\t\t\tprint_cifs_mount_version();\n\t\t\texit(0);\n\t\t}\n\n\t\tif ((strcmp(argv[1], \"-h\") == 0) ||\n\t\t    (strcmp(argv[1], \"-?\") == 0) ||\n\t\t    (strcmp(argv[1], \"--help\") == 0))\n\t\t\tmount_cifs_usage(stdout);\n\n\t\tmount_cifs_usage(stderr);\n\t} else {\n\t\tmount_cifs_usage(stderr);\n\t}\n\n\n\t/* add sharename in opts string as unc= parm */\n\twhile ((c = getopt_long (argc, argv, \"afFhilL:no:O:rsSU:vVwt:\",\n\t\t\t longopts, NULL)) != -1) {\n\t\tswitch (c) {\n/* No code to do the following  options yet */\n/*\tcase 'l':\n\t\tlist_with_volumelabel = 1;\n\t\tbreak;\n\tcase 'L':\n\t\tvolumelabel = optarg;\n\t\tbreak; */\n/*\tcase 'a':\t       \n\t\t++mount_all;\n\t\tbreak; */\n\n\t\tcase '?':\n\t\tcase 'h':\t /* help */\n\t\t\tmount_cifs_usage(stdout);\n\t\tcase 'n':\n\t\t\t++nomtab;\n\t\t\tbreak;\n\t\tcase 'b':\n#ifdef MS_BIND\n\t\t\tflags |= MS_BIND;\n#else\n\t\t\tfprintf(stderr,\n\t\t\t\t\"option 'b' (MS_BIND) not supported\\n\");\n#endif\n\t\t\tbreak;\n\t\tcase 'm':\n#ifdef MS_MOVE\t\t      \n\t\t\tflags |= MS_MOVE;\n#else\n\t\t\tfprintf(stderr,\n\t\t\t\t\"option 'm' (MS_MOVE) not supported\\n\");\n#endif\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\torgoptions = strdup(optarg);\n\t\t    break;\n\t\tcase 'r':  /* mount readonly */\n\t\t\tflags |= MS_RDONLY;\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tuuid = optarg;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\t++verboseflag;\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tprint_cifs_mount_version();\n\t\t\texit (0);\n\t\tcase 'w':\n\t\t\tflags &= ~MS_RDONLY;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\trsize = atoi(optarg) ;\n\t\t\tbreak;\n\t\tcase 'W':\n\t\t\twsize = atoi(optarg);\n\t\t\tbreak;\n\t\tcase '1':\n\t\t\tif (isdigit(*optarg)) {\n\t\t\t\tchar *ep;\n\n\t\t\t\tuid = strtoul(optarg, &ep, 10);\n\t\t\t\tif (*ep) {\n\t\t\t\t\tfprintf(stderr, \"bad uid value \\\"%s\\\"\\n\", optarg);\n\t\t\t\t\texit(EX_USAGE);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstruct passwd *pw;\n\n\t\t\t\tif (!(pw = getpwnam(optarg))) {\n\t\t\t\t\tfprintf(stderr, \"bad user name \\\"%s\\\"\\n\", optarg);\n\t\t\t\t\texit(EX_USAGE);\n\t\t\t\t}\n\t\t\t\tuid = pw->pw_uid;\n\t\t\t\tendpwent();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '2':\n\t\t\tif (isdigit(*optarg)) {\n\t\t\t\tchar *ep;\n\n\t\t\t\tgid = strtoul(optarg, &ep, 10);\n\t\t\t\tif (*ep) {\n\t\t\t\t\tfprintf(stderr, \"bad gid value \\\"%s\\\"\\n\", optarg);\n\t\t\t\t\texit(EX_USAGE);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstruct group *gr;\n\n\t\t\t\tif (!(gr = getgrnam(optarg))) {\n\t\t\t\t\tfprintf(stderr, \"bad user name \\\"%s\\\"\\n\", optarg);\n\t\t\t\t\texit(EX_USAGE);\n\t\t\t\t}\n\t\t\t\tgid = gr->gr_gid;\n\t\t\t\tendpwent();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tgot_user = 1;\n\t\t\tuser_name = optarg;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdomain_name = optarg; /* BB fix this - currently ignored */\n\t\t\tgot_domain = 1;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tif(mountpassword == NULL)\n\t\t\t\tmountpassword = (char *)calloc(MOUNT_PASSWD_SIZE+1,1);\n\t\t\tif(mountpassword) {\n\t\t\t\tgot_password = 1;\n\t\t\t\tstrlcpy(mountpassword,optarg,MOUNT_PASSWD_SIZE+1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tget_password_from_file(0 /* stdin */,NULL);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\t++fakemnt;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"unknown mount option %c\\n\",c);\n\t\t\tmount_cifs_usage(stderr);\n\t\t}\n\t}\n\n\tif((argc < 3) || (dev_name == NULL) || (mountpoint == NULL)) {\n\t\tmount_cifs_usage(stderr);\n\t}\n\n\t/* make sure mountpoint is legit */\n\trc = chdir(mountpoint);\n\tif (rc) {\n\t\tfprintf(stderr, \"Couldn't chdir to %s: %s\\n\", mountpoint,\n\t\t\t\tstrerror(errno));\n\t\trc = EX_USAGE;\n\t\tgoto mount_exit;\n\t}\n\n\trc = check_mountpoint(thisprogram, mountpoint);\n\tif (rc)\n\t\tgoto mount_exit;\n\n\t/* sanity check for unprivileged mounts */\n\tif (getuid()) {\n\t\trc = check_fstab(thisprogram, mountpoint, dev_name,\n\t\t\t\t &orgoptions);\n\t\tif (rc)\n\t\t\tgoto mount_exit;\n\n\t\t/* enable any default user mount flags */\n\t\tflags |= CIFS_SETUID_FLAGS;\n\t}\n\n\tif (getenv(\"PASSWD\")) {\n\t\tif(mountpassword == NULL)\n\t\t\tmountpassword = (char *)calloc(MOUNT_PASSWD_SIZE+1,1);\n\t\tif(mountpassword) {\n\t\t\tstrlcpy(mountpassword,getenv(\"PASSWD\"),MOUNT_PASSWD_SIZE+1);\n\t\t\tgot_password = 1;\n\t\t}\n\t} else if (getenv(\"PASSWD_FD\")) {\n\t\tget_password_from_file(atoi(getenv(\"PASSWD_FD\")),NULL);\n\t} else if (getenv(\"PASSWD_FILE\")) {\n\t\tget_password_from_file(0, getenv(\"PASSWD_FILE\"));\n\t}\n\n        if (orgoptions && parse_options(&orgoptions, &flags)) {\n                rc = EX_USAGE;\n\t\tgoto mount_exit;\n\t}\n\n\tif (getuid()) {\n#if !CIFS_LEGACY_SETUID_CHECK\n\t\tif (!(flags & (MS_USERS|MS_USER))) {\n\t\t\tfprintf(stderr, \"%s: permission denied\\n\", thisprogram);\n\t\t\trc = EX_USAGE;\n\t\t\tgoto mount_exit;\n\t\t}\n#endif /* !CIFS_LEGACY_SETUID_CHECK */\n\t\t\n\t\tif (geteuid()) {\n\t\t\tfprintf(stderr, \"%s: not installed setuid - \\\"user\\\" \"\n\t\t\t\t\t\"CIFS mounts not supported.\",\n\t\t\t\t\tthisprogram);\n\t\t\trc = EX_FAIL;\n\t\t\tgoto mount_exit;\n\t\t}\n\t}\n\n\tflags &= ~(MS_USERS|MS_USER);\n\n\taddrhead = addr = parse_server(&share_name);\n\tif((addrhead == NULL) && (got_ip == 0)) {\n\t\tfprintf(stderr, \"No ip address specified and hostname not found\\n\");\n\t\trc = EX_USAGE;\n\t\tgoto mount_exit;\n\t}\n\t\n\t/* BB save off path and pop after mount returns? */\n\tresolved_path = (char *)malloc(PATH_MAX+1);\n\tif (!resolved_path) {\n\t\tfprintf(stderr, \"Unable to allocate memory.\\n\");\n\t\trc = EX_SYSERR;\n\t\tgoto mount_exit;\n\t}\n\n\t/* Note that if we can not canonicalize the name, we get\n\t   another chance to see if it is valid when we chdir to it */\n\tif(!realpath(\".\", resolved_path)) {\n\t\tfprintf(stderr, \"Unable to resolve %s to canonical path: %s\\n\",\n\t\t\t\tmountpoint, strerror(errno));\n\t\trc = EX_SYSERR;\n\t\tgoto mount_exit;\n\t}\n\n\tmountpoint = resolved_path; \n\n\tif(got_user == 0) {\n\t\t/* Note that the password will not be retrieved from the\n\t\t   USER env variable (ie user%password form) as there is\n\t\t   already a PASSWD environment varaible */\n\t\tif (getenv(\"USER\"))\n\t\t\tuser_name = strdup(getenv(\"USER\"));\n\t\tif (user_name == NULL)\n\t\t\tuser_name = getusername();\n\t\tgot_user = 1;\n\t}\n       \n\tif(got_password == 0) {\n\t\tchar *tmp_pass = getpass(\"Password: \"); /* BB obsolete sys call but\n\t\t\t\t\t\t\t   no good replacement yet. */\n\t\tmountpassword = (char *)calloc(MOUNT_PASSWD_SIZE+1,1);\n\t\tif (!tmp_pass || !mountpassword) {\n\t\t\tfprintf(stderr, \"Password not entered, exiting\\n\");\n\t\t\texit(EX_USAGE);\n\t\t}\n\t\tstrlcpy(mountpassword, tmp_pass, MOUNT_PASSWD_SIZE+1);\n\t\tgot_password = 1;\n\t}\n\t/* FIXME launch daemon (handles dfs name resolution and credential change) \n\t   remember to clear parms and overwrite password field before launching */\n\tif(orgoptions) {\n\t\toptlen = strlen(orgoptions);\n\t\torgoptlen = optlen;\n\t} else\n\t\toptlen = 0;\n\tif(share_name)\n\t\toptlen += strlen(share_name) + 4;\n\telse {\n\t\tfprintf(stderr, \"No server share name specified\\n\");\n\t\tfprintf(stderr, \"\\nMounting the DFS root for server not implemented yet\\n\");\n                exit(EX_USAGE);\n\t}\n\tif(user_name)\n\t\toptlen += strlen(user_name) + 6;\n\toptlen += MAX_ADDRESS_LEN + 4;\n\tif(mountpassword)\n\t\toptlen += strlen(mountpassword) + 6;\nmount_retry:\n\tSAFE_FREE(options);\n\toptions_size = optlen + 10 + DOMAIN_SIZE;\n\toptions = (char *)malloc(options_size /* space for commas in password */ + 8 /* space for domain=  , domain name itself was counted as part of the length username string above */);\n\n\tif(options == NULL) {\n\t\tfprintf(stderr, \"Could not allocate memory for mount options\\n\");\n\t\texit(EX_SYSERR);\n\t}\n\n\tstrlcpy(options, \"unc=\", options_size);\n\tstrlcat(options,share_name,options_size);\n\t/* scan backwards and reverse direction of slash */\n\ttemp = strrchr(options, '/');\n\tif(temp > options + 6)\n\t\t*temp = '\\\\';\n\tif(user_name) {\n\t\t/* check for syntax like user=domain\\user */\n\t\tif(got_domain == 0)\n\t\t\tdomain_name = check_for_domain(&user_name);\n\t\tstrlcat(options,\",user=\",options_size);\n\t\tstrlcat(options,user_name,options_size);\n\t}\n\tif(retry == 0) {\n\t\tif(domain_name) {\n\t\t\t/* extra length accounted for in option string above */\n\t\t\tstrlcat(options,\",domain=\",options_size);\n\t\t\tstrlcat(options,domain_name,options_size);\n\t\t}\n\t}\n\n\tstrlcat(options,\",ver=\",options_size);\n\tstrlcat(options,MOUNT_CIFS_VERSION_MAJOR,options_size);\n\n\tif(orgoptions) {\n\t\tstrlcat(options,\",\",options_size);\n\t\tstrlcat(options,orgoptions,options_size);\n\t}\n\tif(prefixpath) {\n\t\tstrlcat(options,\",prefixpath=\",options_size);\n\t\tstrlcat(options,prefixpath,options_size); /* no need to cat the / */\n\t}\n\n\t/* convert all '\\\\' to '/' in share portion so that /proc/mounts looks pretty */\n\treplace_char(dev_name, '\\\\', '/', strlen(share_name));\n\n\tif (!got_ip && addr) {\n\t\tstrlcat(options, \",ip=\", options_size);\n\t\tcurrent_len = strnlen(options, options_size);\n\t\toptionstail = options + current_len;\n\t\tswitch (addr->ai_addr->sa_family) {\n\t\tcase AF_INET6:\n\t\t\taddr6 = (struct sockaddr_in6 *) addr->ai_addr;\n\t\t\tipaddr = inet_ntop(AF_INET6, &addr6->sin6_addr, optionstail,\n\t\t\t\t\t   options_size - current_len);\n\t\t\tbreak;\n\t\tcase AF_INET:\n\t\t\taddr4 = (struct sockaddr_in *) addr->ai_addr;\n\t\t\tipaddr = inet_ntop(AF_INET, &addr4->sin_addr, optionstail,\n\t\t\t\t\t   options_size - current_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tipaddr = NULL;\n\t\t}\n\n\t\t/* if the address looks bogus, try the next one */\n\t\tif (!ipaddr) {\n\t\t\taddr = addr->ai_next;\n\t\t\tif (addr)\n\t\t\t\tgoto mount_retry;\n\t\t\trc = EX_SYSERR;\n\t\t\tgoto mount_exit;\n\t\t}\n\t}\n\n\tif (addr->ai_addr->sa_family == AF_INET6 && addr6->sin6_scope_id) {\n\t\tstrlcat(options, \"%\", options_size);\n\t\tcurrent_len = strnlen(options, options_size);\n\t\toptionstail = options + current_len;\n\t\tsnprintf(optionstail, options_size - current_len, \"%u\",\n\t\t\t addr6->sin6_scope_id);\n\t}\n\n\tif(verboseflag)\n\t\tfprintf(stderr, \"\\nmount.cifs kernel mount options: %s\", options);\n\n\tif (mountpassword) {\n\t\t/*\n\t\t * Commas have to be doubled, or else they will\n\t\t * look like the parameter separator\n\t\t */\n\t\tif(retry == 0)\n\t\t\tcheck_for_comma(&mountpassword);\n\t\tstrlcat(options,\",pass=\",options_size);\n\t\tstrlcat(options,mountpassword,options_size);\n\t\tif (verboseflag)\n\t\t\tfprintf(stderr, \",pass=********\");\n\t}\n\n\tif (verboseflag)\n\t\tfprintf(stderr, \"\\n\");\n\n\trc = check_mtab(thisprogram, dev_name, mountpoint);\n\tif (rc)\n\t\tgoto mount_exit;\n\n\tif (!fakemnt && mount(dev_name, \".\", cifs_fstype, flags, options)) {\n\t\tswitch (errno) {\n\t\tcase ECONNREFUSED:\n\t\tcase EHOSTUNREACH:\n\t\t\tif (addr) {\n\t\t\t\taddr = addr->ai_next;\n\t\t\t\tif (addr)\n\t\t\t\t\tgoto mount_retry;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ENODEV:\n\t\t\tfprintf(stderr, \"mount error: cifs filesystem not supported by the system\\n\");\n\t\t\tbreak;\n\t\tcase ENXIO:\n\t\t\tif(retry == 0) {\n\t\t\t\tretry = 1;\n\t\t\t\tif (uppercase_string(dev_name) &&\n\t\t\t\t    uppercase_string(share_name) &&\n\t\t\t\t    uppercase_string(prefixpath)) {\n\t\t\t\t\tfprintf(stderr, \"retrying with upper case share name\\n\");\n\t\t\t\t\tgoto mount_retry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfprintf(stderr, \"mount error(%d): %s\\n\", errno, strerror(errno));\n\t\tfprintf(stderr, \"Refer to the mount.cifs(8) manual page (e.g. man \"\n\t\t       \"mount.cifs)\\n\");\n\t\trc = EX_FAIL;\n\t\tgoto mount_exit;\n\t}\n\n\tif (nomtab)\n\t\tgoto mount_exit;\n\tatexit(unlock_mtab);\n\trc = lock_mtab();\n\tif (rc) {\n\t\tfprintf(stderr, \"cannot lock mtab\");\n\t\tgoto mount_exit;\n\t}\n\tpmntfile = setmntent(MOUNTED, \"a+\");\n\tif (!pmntfile) {\n\t\tfprintf(stderr, \"could not update mount table\\n\");\n\t\tunlock_mtab();\n\t\trc = EX_FILEIO;\n\t\tgoto mount_exit;\n\t}\n\tmountent.mnt_fsname = dev_name;\n\tmountent.mnt_dir = mountpoint;\n\tmountent.mnt_type = (char *)(void *)cifs_fstype;\n\tmountent.mnt_opts = (char *)malloc(220);\n\tif(mountent.mnt_opts) {\n\t\tchar * mount_user = getusername();\n\t\tmemset(mountent.mnt_opts,0,200);\n\t\tif(flags & MS_RDONLY)\n\t\t\tstrlcat(mountent.mnt_opts,\"ro\",220);\n\t\telse\n\t\t\tstrlcat(mountent.mnt_opts,\"rw\",220);\n\t\tif(flags & MS_MANDLOCK)\n\t\t\tstrlcat(mountent.mnt_opts,\",mand\",220);\n\t\tif(flags & MS_NOEXEC)\n\t\t\tstrlcat(mountent.mnt_opts,\",noexec\",220);\n\t\tif(flags & MS_NOSUID)\n\t\t\tstrlcat(mountent.mnt_opts,\",nosuid\",220);\n\t\tif(flags & MS_NODEV)\n\t\t\tstrlcat(mountent.mnt_opts,\",nodev\",220);\n\t\tif(flags & MS_SYNCHRONOUS)\n\t\t\tstrlcat(mountent.mnt_opts,\",sync\",220);\n\t\tif(mount_user) {\n\t\t\tif(getuid() != 0) {\n\t\t\t\tstrlcat(mountent.mnt_opts,\n\t\t\t\t\t\",user=\", 220);\n\t\t\t\tstrlcat(mountent.mnt_opts,\n\t\t\t\t\tmount_user, 220);\n\t\t\t}\n\t\t}\n\t}\n\tmountent.mnt_freq = 0;\n\tmountent.mnt_passno = 0;\n\trc = addmntent(pmntfile,&mountent);\n\tendmntent(pmntfile);\n\tunlock_mtab();\n\tSAFE_FREE(mountent.mnt_opts);\n\tif (rc)\n\t\trc = EX_FILEIO;\nmount_exit:\n\tif(mountpassword) {\n\t\tint len = strlen(mountpassword);\n\t\tmemset(mountpassword,0,len);\n\t\tSAFE_FREE(mountpassword);\n\t}\n\n\tif (addrhead)\n\t\tfreeaddrinfo(addrhead);\n\tSAFE_FREE(options);\n\tSAFE_FREE(orgoptions);\n\tSAFE_FREE(resolved_path);\n\tSAFE_FREE(share_name);\n\texit(rc);\n}",
        "start_line": 1197
      }
    ],
    "code_context": "Called Methods:\n- MS_USER: #define MS_USER\t\t0x80000000 /* <=== client/mount.cifs.c:75:75:MS_USER:0 */ \n- unlink: int unlink(const char *name) /* <=== unlink */ \n{\n        check_init(\"unlink\");\n        \n\tif (smbw_path((char *) name)) {\n\t\treturn smbw_unlink((char *) name);\n\t}\n        \n        return (* smbw_libc.unlink)((char *) name);\n}\n- vasprintf: #define vasprintf rep_vasprintf /* <=== lib/replace/replace.h:360:360:vasprintf:0 */ \n- close: int close(int fd) /* <=== close */ \n{\n        check_init(\"close\");\n        return closex(fd, smbw_libc.close);\n}\n- replace_char: static void replace_char(char *string, char from, char to, int maxlen) /* <=== replace_char */ \n{\n\tchar *lastchar = string + maxlen;\n\twhile (string) {\n\t\tstring = strchr(string, from);\n\t\tif (string) {\n\t\t\t*string = to;\n\t\t\tif (string >= lastchar)\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n- lock_mtab: int /* <=== lock_mtab */ \nlock_mtab (void) {\n\tint i;\n\tstruct timespec waittime;\n\tstruct timeval maxtime;\n\tchar linktargetfile[MOUNTLOCK_LINKTARGET_LTH];\n\n\tif (!signals_have_been_setup) {\n\t\tint sig = 0;\n\t\tstruct sigaction sa;\n\n\t\tsa.sa_handler = handler;\n\t\tsa.sa_flags = 0;\n\t\tsigfillset (&sa.sa_mask);\n\n\t\twhile (sigismember (&sa.sa_mask, ++sig) != -1\n\t\t       && sig != SIGCHLD) {\n\t\t\tif (sig == SIGALRM)\n\t\t\t\tsa.sa_handler = setlkw_timeout;\n\t\t\telse\n\t\t\t\tsa.sa_handler = handler;\n\t\t\tsigaction (sig, &sa, (struct sigaction *) 0);\n\t\t}\n\t\tsignals_have_been_setup = 1;\n\t}\n\n\tsprintf(linktargetfile, MOUNTLOCK_LINKTARGET, getpid ());\n\n\ti = open (linktargetfile, O_WRONLY|O_CREAT, S_IRUSR|S_IWUSR);\n\tif (i < 0) {\n\t\t/* linktargetfile does not exist (as a file)\n\t\t   and we cannot create it. Read-only filesystem?\n\t\t   Too many files open in the system?\n\t\t   Filesystem full? */\n\t\treturn EX_FILEIO;\n\t}\n\tclose(i);\n\n\tgettimeofday(&maxtime, NULL);\n\tmaxtime.tv_sec += MOUNTLOCK_MAXTIME;\n\n\twaittime.tv_sec = 0;\n\twaittime.tv_nsec = (1000 * MOUNTLOCK_WAITTIME);\n\n\t/* Repeat until it was us who made the link */\n\twhile (!we_created_lockfile) {\n\t\tstruct timeval now;\n\t\tstruct flock flock;\n\t\tint errsv, j;\n\n\t\tj = link(linktargetfile, _PATH_MOUNTED_LOCK);\n\t\terrsv = errno;\n\n\t\tif (j == 0)\n\t\t\twe_created_lockfile = 1;\n\n\t\tif (j < 0 && errsv != EEXIST) {\n\t\t\t(void) unlink(linktargetfile);\n\t\t\treturn EX_FILEIO;\n\t\t}\n\n\t\tlockfile_fd = open (_PATH_MOUNTED_LOCK, O_WRONLY);\n\n\t\tif (lockfile_fd < 0) {\n\t\t\t/* Strange... Maybe the file was just deleted? */\n\t\t\tgettimeofday(&now, NULL);\n\t\t\tif (errno == ENOENT && now.tv_sec < maxtime.tv_sec) {\n\t\t\t\twe_created_lockfile = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t(void) unlink(linktargetfile);\n\t\t\treturn EX_FILEIO;\n\t\t}\n\n\t\tflock.l_type = F_WRLCK;\n\t\tflock.l_whence = SEEK_SET;\n\t\tflock.l_start = 0;\n\t\tflock.l_len = 0;\n\n\t\tif (j == 0) {\n\t\t\t/* We made the link. Now claim the lock. If we can't\n\t\t\t * get it, continue anyway\n\t\t\t */\n\t\t\tfcntl (lockfile_fd, F_SETLK, &flock);\n\t\t\t(void) unlink(linktargetfile);\n\t\t} else {\n\t\t\t/* Someone else made the link. Wait. */\n\t\t\tgettimeofday(&now, NULL);\n\t\t\tif (now.tv_sec < maxtime.tv_sec) {\n\t\t\t\talarm(maxtime.tv_sec - now.tv_sec);\n\t\t\t\tif (fcntl (lockfile_fd, F_SETLKW, &flock) == -1) {\n\t\t\t\t\t(void) unlink(linktargetfile);\n\t\t\t\t\treturn EX_FILEIO;\n\t\t\t\t}\n\t\t\t\talarm(0);\n\t\t\t\tnanosleep(&waittime, NULL);\n\t\t\t} else {\n\t\t\t\t(void) unlink(linktargetfile);\n\t\t\t\treturn EX_FILEIO;\n\t\t\t}\n\t\t\tclose(lockfile_fd);\n\t\t}\n\t}\n\treturn 0;\n}\n- unlock_mtab: void /* <=== unlock_mtab */ \nunlock_mtab (void) {\n\tif (we_created_lockfile) {\n\t\tclose(lockfile_fd);\n\t\tlockfile_fd = -1;\n\t\tunlink (_PATH_MOUNTED_LOCK);\n\t\twe_created_lockfile = 0;\n\t}\n}\n- EAFNOSUPPORT: #define EAFNOSUPPORT EINVAL /* <=== lib/replace/system/network.h:280:280:EAFNOSUPPORT:0 */ \n- EX_USAGE: #define EX_USAGE\t1\t/* incorrect invocation or permission */ /* <=== client/mount.h:24:24:EX_USAGE:0 */ \n- fprintf:  int fprintf(FILE *stream, const char *fmt, ...) /* <=== fprintf */ \n{\n\tva_list ap;\n\tint ret;\n\tchar *s;\n\n\ts = NULL;\n\tva_start(ap, fmt);\n\tret = vasprintf(&s, fmt, ap);\n\tva_end(ap);\n\n\tif (s) {\n\t\tfwrite(s, 1, strlen(s), stream);\n\t}\n\tfree(s);\n\n\treturn ret;\n}\n- __libc_malloc:         void *__libc_malloc(size_t size); /* <=== __libc_malloc */ \n- __libc_free:         void __libc_free(void *ptr); /* <=== __libc_free */ \n- strlcpy: static size_t strlcpy(char *d, const char *s, size_t bufsize) /* <=== strlcpy */ \n{\n\tsize_t len = strlen(s);\n\tsize_t ret = len;\n\tif (bufsize <= 0) return 0;\n\tif (len >= bufsize) len = bufsize-1;\n\tmemcpy(d, s, len);\n\td[len] = 0;\n\treturn ret;\n}\n- EX_SYSERR: #define EX_SYSERR\t2\t/* out of memory, cannot fork, ... */ /* <=== client/mount.h:25:25:EX_SYSERR:0 */ \n- inet_ntop: const char * ROKEN_LIB_FUNCTION /* <=== inet_ntop */ \ninet_ntop(int af, const void *src, char *dst, size_t size)\n{\n    switch (af) {\n    case AF_INET :\n\treturn inet_ntop_v4 (src, dst, size);\n#ifdef HAVE_IPV6\n    case AF_INET6 :\n\treturn inet_ntop_v6 (src, dst, size);\n#endif\n    default :\n\terrno = EAFNOSUPPORT;\n\treturn NULL;\n    }\n}\n- realloc: void *realloc(void *ptr, size_t size) /* <=== realloc */ \n{\n        void *__libc_realloc(void *ptr, size_t size);\n        return __libc_realloc(ptr, size);\n}\n- EX_FILEIO: #define EX_FILEIO      16\t/* problems writing, locking, ... mtab/fstab */ /* <=== client/mount.h:28:28:EX_FILEIO:0 */ \n- MOUNT_CIFS_VERSION_MAJOR: #define MOUNT_CIFS_VERSION_MAJOR \"1\" /* <=== client/mount.cifs.c:45:45:MOUNT_CIFS_VERSION_MAJOR:0 */ \n- check_for_comma: static void check_for_comma(char ** ppasswrd) /* <=== check_for_comma */ \n{\n\tchar *new_pass_buf;\n\tchar *pass;\n\tint i,j;\n\tint number_of_commas = 0;\n\tint len;\n\n\tif(ppasswrd == NULL)\n\t\treturn;\n\telse \n\t\t(pass = *ppasswrd);\n\n\tlen = strlen(pass);\n\n\tfor(i=0;i<len;i++)  {\n\t\tif(pass[i] == ',')\n\t\t\tnumber_of_commas++;\n\t}\n\n\tif(number_of_commas == 0)\n\t\treturn;\n\tif(number_of_commas > MOUNT_PASSWD_SIZE) {\n\t\t/* would otherwise overflow the mount options buffer */\n\t\tfprintf(stderr, \"\\nInvalid password. Password contains too many commas.\\n\");\n\t\treturn;\n\t}\n\n\tnew_pass_buf = (char *)malloc(len+number_of_commas+1);\n\tif(new_pass_buf == NULL)\n\t\treturn;\n\n\tfor(i=0,j=0;i<len;i++,j++) {\n\t\tnew_pass_buf[j] = pass[i];\n\t\tif(pass[i] == ',') {\n\t\t\tj++;\n\t\t\tnew_pass_buf[j] = pass[i];\n\t\t}\n\t}\n\tnew_pass_buf[len+number_of_commas] = 0;\n\n\tSAFE_FREE(*ppasswrd);\n\t*ppasswrd = new_pass_buf;\n\t\n\treturn;\n}\n- __libc_calloc:         void *__libc_calloc(size_t nmemb, size_t size); /* <=== __libc_calloc */ \n- strerror: static char * strerror(int errno) { /* <=== strerror */ \n    extern int sys_nerr;\n    extern char * sys_errlist[];\n\n    if ((0 <= errno) && (errno < sys_nerr))\n\treturn sys_errlist[errno];\n    else\n\treturn POPT_(\"unknown errno\");\n}\n- POPT_: #define POPT_(foo) foo /* <=== lib/popt/poptint.h:111:111:POPT_:1 */ \n- MOUNTLOCK_MAXTIME: #define MOUNTLOCK_MAXTIME\t\t30 /* <=== client/mtab.c:110:110:MOUNTLOCK_MAXTIME:0 */ \n- inet_ntop_v4: static const char * /* <=== inet_ntop_v4 */ \ninet_ntop_v4 (const void *src, char *dst, size_t size)\n{\n    const char digits[] = \"0123456789\";\n    int i;\n    struct in_addr *addr = (struct in_addr *)src;\n    u_long a = ntohl(addr->s_addr);\n    const char *orig_dst = dst;\n\n    if (size < INET_ADDRSTRLEN) {\n\terrno = ENOSPC;\n\treturn NULL;\n    }\n    for (i = 0; i < 4; ++i) {\n\tint n = (a >> (24 - i * 8)) & 0xFF;\n\tint non_zerop = 0;\n\n\tif (non_zerop || n / 100 > 0) {\n\t    *dst++ = digits[n / 100];\n\t    n %= 100;\n\t    non_zerop = 1;\n\t}\n\tif (non_zerop || n / 10 > 0) {\n\t    *dst++ = digits[n / 10];\n\t    n %= 10;\n\t    non_zerop = 1;\n\t}\n\t*dst++ = digits[n];\n\tif (i != 3)\n\t    *dst++ = '.';\n    }\n    *dst++ = '\\0';\n    return orig_dst;\n}\n- EX_FAIL: #define EX_FAIL\t       32\t/* mount failure */ /* <=== client/mount.h:29:29:EX_FAIL:0 */ \n- calloc: void *calloc(size_t nmemb, size_t size) /* <=== calloc */ \n{\n        void *__libc_calloc(size_t nmemb, size_t size);\n        return __libc_calloc(nmemb, size);\n}\n- getusername: static char * getusername(void) { /* <=== getusername */ \n\tchar *username = NULL;\n\tstruct passwd *password = getpwuid(getuid());\n\n\tif (password) {\n\t\tusername = password->pw_name;\n\t}\n\treturn username;\n}\n- free: void free(void *ptr) /* <=== free */ \n{\n        static int      in_progress = 0;\n        void __libc_free(void *ptr);\n        \n        if (in_progress) return;\n        in_progress = 1;\n        __libc_free(ptr);\n        in_progress = 0;\n}\n- MS_MOVE: #define MS_MOVE 8192  /* <=== client/mount.cifs.c:66:66:MS_MOVE:0 */ \n- parse_options: static int parse_options(char ** optionsp, unsigned long * filesys_flags) /* <=== parse_options */ \n{\n\tconst char * data;\n\tchar * percent_char = NULL;\n\tchar * value = NULL;\n\tchar * next_keyword = NULL;\n\tchar * out = NULL;\n\tint out_len = 0;\n\tint word_len;\n\tint rc = 0;\n\tchar user[32];\n\tchar group[32];\n\n\tif (!optionsp || !*optionsp)\n\t\treturn 1;\n\tdata = *optionsp;\n\n\t/* BB fixme check for separator override BB */\n\n\tif (getuid()) {\n\t\tgot_uid = 1;\n\t\tsnprintf(user,sizeof(user),\"%u\",getuid());\n\t\tgot_gid = 1;\n\t\tsnprintf(group,sizeof(group),\"%u\",getgid());\n\t}\n\n/* while ((data = strsep(&options, \",\")) != NULL) { */\n\twhile(data != NULL) {\n\t\t/*  check if ends with trailing comma */\n\t\tif(*data == 0)\n\t\t\tbreak;\n\n\t\t/* format is keyword=value,keyword2=value2,keyword3=value3 etc.) */\n\t\t/* data  = next keyword */\n\t\t/* value = next value ie stuff after equal sign */\n\n\t\tnext_keyword = strchr(data,','); /* BB handle sep= */\n\t\n\t\t/* temporarily null terminate end of keyword=value pair */\n\t\tif(next_keyword)\n\t\t\t*next_keyword++ = 0;\n\n\t\t/* temporarily null terminate keyword to make keyword and value distinct */\n\t\tif ((value = strchr(data, '=')) != NULL) {\n\t\t\t*value = '\\0';\n\t\t\tvalue++;\n\t\t}\n\n\t\tif (strncmp(data, \"users\",5) == 0) {\n\t\t\tif(!value || !*value) {\n\t\t\t\t*filesys_flags |= MS_USERS;\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\t\t} else if (strncmp(data, \"user_xattr\",10) == 0) {\n\t\t   /* do nothing - need to skip so not parsed as user name */\n\t\t} else if (strncmp(data, \"user\", 4) == 0) {\n\n\t\t\tif (!value || !*value) {\n\t\t\t\tif(data[4] == '\\0') {\n\t\t\t\t\t*filesys_flags |= MS_USER;\n\t\t\t\t\tgoto nocopy;\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"username specified with no parameter\\n\");\n\t\t\t\t\tSAFE_FREE(out);\n\t\t\t\t\treturn 1;\t/* needs_arg; */\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (strnlen(value, 260) < 260) {\n\t\t\t\t\tgot_user=1;\n\t\t\t\t\tpercent_char = strchr(value,'%');\n\t\t\t\t\tif(percent_char) {\n\t\t\t\t\t\t*percent_char = ',';\n\t\t\t\t\t\tif(mountpassword == NULL)\n\t\t\t\t\t\t\tmountpassword = (char *)calloc(MOUNT_PASSWD_SIZE+1,1);\n\t\t\t\t\t\tif(mountpassword) {\n\t\t\t\t\t\t\tif(got_password)\n\t\t\t\t\t\t\t\tfprintf(stderr, \"\\nmount.cifs warning - password specified twice\\n\");\n\t\t\t\t\t\t\tgot_password = 1;\n\t\t\t\t\t\t\tpercent_char++;\n\t\t\t\t\t\t\tstrlcpy(mountpassword, percent_char,MOUNT_PASSWD_SIZE+1);\n\t\t\t\t\t\t/*  remove password from username */\n\t\t\t\t\t\t\twhile(*percent_char != 0) {\n\t\t\t\t\t\t\t\t*percent_char = ',';\n\t\t\t\t\t\t\t\tpercent_char++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/* this is only case in which the user\n\t\t\t\t\tname buf is not malloc - so we have to\n\t\t\t\t\tcheck for domain name embedded within\n\t\t\t\t\tthe user name here since the later\n\t\t\t\t\tcall to check_for_domain will not be\n\t\t\t\t\tinvoked */\n\t\t\t\t\tdomain_name = check_for_domain(&value);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"username too long\\n\");\n\t\t\t\t\tSAFE_FREE(out);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (strncmp(data, \"pass\", 4) == 0) {\n\t\t\tif (!value || !*value) {\n\t\t\t\tif(got_password) {\n\t\t\t\t\tfprintf(stderr, \"\\npassword specified twice, ignoring second\\n\");\n\t\t\t\t} else\n\t\t\t\t\tgot_password = 1;\n\t\t\t} else if (strnlen(value, MOUNT_PASSWD_SIZE) < MOUNT_PASSWD_SIZE) {\n\t\t\t\tif (got_password) {\n\t\t\t\t\tfprintf(stderr, \"\\nmount.cifs warning - password specified twice\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tmountpassword = strndup(value, MOUNT_PASSWD_SIZE);\n\t\t\t\t\tif (!mountpassword) {\n\t\t\t\t\t\tfprintf(stderr, \"mount.cifs error: %s\", strerror(ENOMEM));\n\t\t\t\t\t\tSAFE_FREE(out);\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t\tgot_password = 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"password too long\\n\");\n\t\t\t\tSAFE_FREE(out);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tgoto nocopy;\n\t\t} else if (strncmp(data, \"sec\", 3) == 0) {\n\t\t\tif (value) {\n\t\t\t\tif (!strncmp(value, \"none\", 4) ||\n\t\t\t\t    !strncmp(value, \"krb5\", 4))\n\t\t\t\t\tgot_password = 1;\n\t\t\t}\n\t\t} else if (strncmp(data, \"ip\", 2) == 0) {\n\t\t\tif (!value || !*value) {\n\t\t\t\tfprintf(stderr, \"target ip address argument missing\");\n\t\t\t} else if (strnlen(value, MAX_ADDRESS_LEN) <= MAX_ADDRESS_LEN) {\n\t\t\t\tif(verboseflag)\n\t\t\t\t\tfprintf(stderr, \"ip address %s override specified\\n\",value);\n\t\t\t\tgot_ip = 1;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"ip address too long\\n\");\n\t\t\t\tSAFE_FREE(out);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else if ((strncmp(data, \"unc\", 3) == 0)\n\t\t   || (strncmp(data, \"target\", 6) == 0)\n\t\t   || (strncmp(data, \"path\", 4) == 0)) {\n\t\t\tif (!value || !*value) {\n\t\t\t\tfprintf(stderr, \"invalid path to network resource\\n\");\n\t\t\t\tSAFE_FREE(out);\n\t\t\t\treturn 1;  /* needs_arg; */\n\t\t\t} else if(strnlen(value,5) < 5) {\n\t\t\t\tfprintf(stderr, \"UNC name too short\");\n\t\t\t}\n\n\t\t\tif (strnlen(value, 300) < 300) {\n\t\t\t\tgot_unc = 1;\n\t\t\t\tif (strncmp(value, \"//\", 2) == 0) {\n\t\t\t\t\tif(got_unc)\n\t\t\t\t\t\tfprintf(stderr, \"unc name specified twice, ignoring second\\n\");\n\t\t\t\t\telse\n\t\t\t\t\t\tgot_unc = 1;\n\t\t\t\t} else if (strncmp(value, \"\\\\\\\\\", 2) != 0) {\t                   \n\t\t\t\t\tfprintf(stderr, \"UNC Path does not begin with // or \\\\\\\\ \\n\");\n\t\t\t\t\tSAFE_FREE(out);\n\t\t\t\t\treturn 1;\n\t\t\t\t} else {\n\t\t\t\t\tif(got_unc)\n\t\t\t\t\t\tfprintf(stderr, \"unc name specified twice, ignoring second\\n\");\n\t\t\t\t\telse\n\t\t\t\t\t\tgot_unc = 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"CIFS: UNC name too long\\n\");\n\t\t\t\tSAFE_FREE(out);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else if ((strncmp(data, \"dom\" /* domain */, 3) == 0)\n\t\t\t   || (strncmp(data, \"workg\", 5) == 0)) {\n\t\t\t/* note this allows for synonyms of \"domain\"\n\t\t\t   such as \"DOM\" and \"dom\" and \"workgroup\"\n\t\t\t   and \"WORKGRP\" etc. */\n\t\t\tif (!value || !*value) {\n\t\t\t\tfprintf(stderr, \"CIFS: invalid domain name\\n\");\n\t\t\t\tSAFE_FREE(out);\n\t\t\t\treturn 1;\t/* needs_arg; */\n\t\t\t}\n\t\t\tif (strnlen(value, DOMAIN_SIZE+1) < DOMAIN_SIZE+1) {\n\t\t\t\tgot_domain = 1;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"domain name too long\\n\");\n\t\t\t\tSAFE_FREE(out);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else if (strncmp(data, \"cred\", 4) == 0) {\n\t\t\tif (value && *value) {\n\t\t\t\trc = open_cred_file(value);\n\t\t\t\tif(rc) {\n\t\t\t\t\tfprintf(stderr, \"error %d (%s) opening credential file %s\\n\",\n\t\t\t\t\t\trc, strerror(rc), value);\n\t\t\t\t\tSAFE_FREE(out);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"invalid credential file name specified\\n\");\n\t\t\t\tSAFE_FREE(out);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else if (strncmp(data, \"uid\", 3) == 0) {\n\t\t\tif (value && *value) {\n\t\t\t\tgot_uid = 1;\n\t\t\t\tif (!isdigit(*value)) {\n\t\t\t\t\tstruct passwd *pw;\n\n\t\t\t\t\tif (!(pw = getpwnam(value))) {\n\t\t\t\t\t\tfprintf(stderr, \"bad user name \\\"%s\\\"\\n\", value);\n\t\t\t\t\t\texit(EX_USAGE);\n\t\t\t\t\t}\n\t\t\t\t\tsnprintf(user, sizeof(user), \"%u\", pw->pw_uid);\n\t\t\t\t} else {\n\t\t\t\t\tstrlcpy(user,value,sizeof(user));\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto nocopy;\n\t\t} else if (strncmp(data, \"gid\", 3) == 0) {\n\t\t\tif (value && *value) {\n\t\t\t\tgot_gid = 1;\n\t\t\t\tif (!isdigit(*value)) {\n\t\t\t\t\tstruct group *gr;\n\n\t\t\t\t\tif (!(gr = getgrnam(value))) {\n\t\t\t\t\t\tfprintf(stderr, \"bad group name \\\"%s\\\"\\n\", value);\n\t\t\t\t\t\texit(EX_USAGE);\n\t\t\t\t\t}\n\t\t\t\t\tsnprintf(group, sizeof(group), \"%u\", gr->gr_gid);\n\t\t\t\t} else {\n\t\t\t\t\tstrlcpy(group,value,sizeof(group));\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto nocopy;\n       /* fmask and dmask synonyms for people used to smbfs syntax */\n\t\t} else if (strcmp(data, \"file_mode\") == 0 || strcmp(data, \"fmask\")==0) {\n\t\t\tif (!value || !*value) {\n\t\t\t\tfprintf(stderr, \"Option '%s' requires a numerical argument\\n\", data);\n\t\t\t\tSAFE_FREE(out);\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif (value[0] != '0') {\n\t\t\t\tfprintf(stderr, \"WARNING: '%s' not expressed in octal.\\n\", data);\n\t\t\t}\n\n\t\t\tif (strcmp (data, \"fmask\") == 0) {\n\t\t\t\tfprintf(stderr, \"WARNING: CIFS mount option 'fmask' is deprecated. Use 'file_mode' instead.\\n\");\n\t\t\t\tdata = \"file_mode\"; /* BB fix this */\n\t\t\t}\n\t\t} else if (strcmp(data, \"dir_mode\") == 0 || strcmp(data, \"dmask\")==0) {\n\t\t\tif (!value || !*value) {\n\t\t\t\tfprintf(stderr, \"Option '%s' requires a numerical argument\\n\", data);\n\t\t\t\tSAFE_FREE(out);\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif (value[0] != '0') {\n\t\t\t\tfprintf(stderr, \"WARNING: '%s' not expressed in octal.\\n\", data);\n\t\t\t}\n\n\t\t\tif (strcmp (data, \"dmask\") == 0) {\n\t\t\t\tfprintf(stderr, \"WARNING: CIFS mount option 'dmask' is deprecated. Use 'dir_mode' instead.\\n\");\n\t\t\t\tdata = \"dir_mode\";\n\t\t\t}\n\t\t\t/* the following eight mount options should be\n\t\t\tstripped out from what is passed into the kernel\n\t\t\tsince these eight options are best passed as the\n\t\t\tmount flags rather than redundantly to the kernel \n\t\t\tand could generate spurious warnings depending on the\n\t\t\tlevel of the corresponding cifs vfs kernel code */\n\t\t} else if (strncmp(data, \"nosuid\", 6) == 0) {\n\t\t\t*filesys_flags |= MS_NOSUID;\n\t\t} else if (strncmp(data, \"suid\", 4) == 0) {\n\t\t\t*filesys_flags &= ~MS_NOSUID;\n\t\t} else if (strncmp(data, \"nodev\", 5) == 0) {\n\t\t\t*filesys_flags |= MS_NODEV;\n\t\t} else if ((strncmp(data, \"nobrl\", 5) == 0) || \n\t\t\t   (strncmp(data, \"nolock\", 6) == 0)) {\n\t\t\t*filesys_flags &= ~MS_MANDLOCK;\n\t\t} else if (strncmp(data, \"dev\", 3) == 0) {\n\t\t\t*filesys_flags &= ~MS_NODEV;\n\t\t} else if (strncmp(data, \"noexec\", 6) == 0) {\n\t\t\t*filesys_flags |= MS_NOEXEC;\n\t\t} else if (strncmp(data, \"exec\", 4) == 0) {\n\t\t\t*filesys_flags &= ~MS_NOEXEC;\n\t\t} else if (strncmp(data, \"guest\", 5) == 0) {\n\t\t\tuser_name = (char *)calloc(1, 1);\n\t\t\tgot_user = 1;\n\t\t\tgot_password = 1;\n\t\t} else if (strncmp(data, \"ro\", 2) == 0) {\n\t\t\t*filesys_flags |= MS_RDONLY;\n\t\t\tgoto nocopy;\n\t\t} else if (strncmp(data, \"rw\", 2) == 0) {\n\t\t\t*filesys_flags &= ~MS_RDONLY;\n\t\t\tgoto nocopy;\n                } else if (strncmp(data, \"remount\", 7) == 0) {\n                        *filesys_flags |= MS_REMOUNT;\n\t\t} /* else if (strnicmp(data, \"port\", 4) == 0) {\n\t\t\tif (value && *value) {\n\t\t\t\tvol->port =\n\t\t\t\t\tsimple_strtoul(value, &value, 0);\n\t\t\t}\n\t\t} else if (strnicmp(data, \"rsize\", 5) == 0) {\n\t\t\tif (value && *value) {\n\t\t\t\tvol->rsize =\n\t\t\t\t\tsimple_strtoul(value, &value, 0);\n\t\t\t}\n\t\t} else if (strnicmp(data, \"wsize\", 5) == 0) {\n\t\t\tif (value && *value) {\n\t\t\t\tvol->wsize =\n\t\t\t\t\tsimple_strtoul(value, &value, 0);\n\t\t\t}\n\t\t} else if (strnicmp(data, \"version\", 3) == 0) {\n\t\t} else {\n\t\t\tfprintf(stderr, \"CIFS: Unknown mount option %s\\n\",data);\n\t\t} */ /* nothing to do on those four mount options above.\n\t\t\tJust pass to kernel and ignore them here */\n\n\t\t/* Copy (possibly modified) option to out */\n\t\tword_len = strlen(data);\n\t\tif (value)\n\t\t\tword_len += 1 + strlen(value);\n\n\t\tout = (char *)realloc(out, out_len + word_len + 2);\n\t\tif (out == NULL) {\n\t\t\tperror(\"malloc\");\n\t\t\texit(EX_SYSERR);\n\t\t}\n\n\t\tif (out_len) {\n\t\t\tstrlcat(out, \",\", out_len + word_len + 2);\n\t\t\tout_len++;\n\t\t}\n\n\t\tif (value)\n\t\t\tsnprintf(out + out_len, word_len + 1, \"%s=%s\", data, value);\n\t\telse\n\t\t\tsnprintf(out + out_len, word_len + 1, \"%s\", data);\n\t\tout_len = strlen(out);\n\nnocopy:\n\t\tdata = next_keyword;\n\t}\n\n\t/* special-case the uid and gid */\n\tif (got_uid) {\n\t\tword_len = strlen(user);\n\n\t\tout = (char *)realloc(out, out_len + word_len + 6);\n\t\tif (out == NULL) {\n\t\t\tperror(\"malloc\");\n\t\t\texit(EX_SYSERR);\n\t\t}\n\n\t\tif (out_len) {\n\t\t\tstrlcat(out, \",\", out_len + word_len + 6);\n\t\t\tout_len++;\n\t\t}\n\t\tsnprintf(out + out_len, word_len + 5, \"uid=%s\", user);\n\t\tout_len = strlen(out);\n\t}\n\tif (got_gid) {\n\t\tword_len = strlen(group);\n\n\t\tout = (char *)realloc(out, out_len + 1 + word_len + 6);\n\t\tif (out == NULL) {\n\t\tperror(\"malloc\");\n\t\t\texit(EX_SYSERR);\n\t\t}\n\n\t\tif (out_len) {\n\t\t\tstrlcat(out, \",\", out_len + word_len + 6);\n\t\t\tout_len++;\n\t\t}\n\t\tsnprintf(out + out_len, word_len + 5, \"gid=%s\", group);\n\t\tout_len = strlen(out);\n\t}\n\n\tSAFE_FREE(*optionsp);\n\t*optionsp = out;\n\treturn 0;\n}\n- MS_BIND: #define MS_BIND 4096 /* <=== client/mount.cifs.c:70:70:MS_BIND:0 */ \n- DOMAIN_SIZE: #define DOMAIN_SIZE 64 /* <=== client/mount.cifs.c:84:84:DOMAIN_SIZE:0 */ \n- strlcat: static size_t strlcat(char *d, const char *s, size_t bufsize) /* <=== strlcat */ \n{\n\tsize_t len1 = strlen(d);\n\tsize_t len2 = strlen(s);\n\tsize_t ret = len1 + len2;\n\n\tif (len1+len2 >= bufsize) {\n\t\tif (bufsize < (len1+1)) {\n\t\t\treturn ret;\n\t\t}\n\t\tlen2 = bufsize - (len1+1);\n\t}\n\tif (len2 > 0) {\n\t\tmemcpy(d+len1, s, len2);\n\t\td[len1+len2] = 0;\n\t}\n\treturn ret;\n}\n- open_cred_file: static int open_cred_file(char * file_name) /* <=== open_cred_file */ \n{\n\tchar * line_buf;\n\tchar * temp_val;\n\tFILE * fs;\n\tint i, length;\n\n\ti = access(file_name, R_OK);\n\tif (i)\n\t\treturn i;\n\n\tfs = fopen(file_name,\"r\");\n\tif(fs == NULL)\n\t\treturn errno;\n\tline_buf = (char *)malloc(4096);\n\tif(line_buf == NULL) {\n\t\tfclose(fs);\n\t\treturn ENOMEM;\n\t}\n\n\twhile(fgets(line_buf,4096,fs)) {\n\t\t/* parse line from credential file */\n\n\t\t/* eat leading white space */\n\t\tfor(i=0;i<4086;i++) {\n\t\t\tif((line_buf[i] != ' ') && (line_buf[i] != '\\t'))\n\t\t\t\tbreak;\n\t\t\t/* if whitespace - skip past it */\n\t\t}\n\t\tif (strncasecmp(\"username\",line_buf+i,8) == 0) {\n\t\t\ttemp_val = strchr(line_buf + i,'=');\n\t\t\tif(temp_val) {\n\t\t\t\t/* go past equals sign */\n\t\t\t\ttemp_val++;\n\t\t\t\tfor(length = 0;length<4087;length++) {\n\t\t\t\t\tif ((temp_val[length] == '\\n')\n\t\t\t\t\t    || (temp_val[length] == '\\0')) {\n\t\t\t\t\t\ttemp_val[length] = '\\0';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(length > 4086) {\n\t\t\t\t\tfprintf(stderr, \"mount.cifs failed due to malformed username in credentials file\\n\");\n\t\t\t\t\tmemset(line_buf,0,4096);\n\t\t\t\t\texit(EX_USAGE);\n\t\t\t\t} else {\n\t\t\t\t\tgot_user = 1;\n\t\t\t\t\tuser_name = (char *)calloc(1 + length,1);\n\t\t\t\t\t/* BB adding free of user_name string before exit,\n\t\t\t\t\t\tnot really necessary but would be cleaner */\n\t\t\t\t\tstrlcpy(user_name,temp_val, length+1);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (strncasecmp(\"password\",line_buf+i,8) == 0) {\n\t\t\ttemp_val = strchr(line_buf+i,'=');\n\t\t\tif(temp_val) {\n\t\t\t\t/* go past equals sign */\n\t\t\t\ttemp_val++;\n\t\t\t\tfor(length = 0;length<MOUNT_PASSWD_SIZE+1;length++) {\n\t\t\t\t\tif ((temp_val[length] == '\\n')\n\t\t\t\t\t    || (temp_val[length] == '\\0')) {\n\t\t\t\t\t\ttemp_val[length] = '\\0';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(length > MOUNT_PASSWD_SIZE) {\n\t\t\t\t\tfprintf(stderr, \"mount.cifs failed: password in credentials file too long\\n\");\n\t\t\t\t\tmemset(line_buf,0, 4096);\n\t\t\t\t\texit(EX_USAGE);\n\t\t\t\t} else {\n\t\t\t\t\tif(mountpassword == NULL) {\n\t\t\t\t\t\tmountpassword = (char *)calloc(MOUNT_PASSWD_SIZE+1,1);\n\t\t\t\t\t} else\n\t\t\t\t\t\tmemset(mountpassword,0,MOUNT_PASSWD_SIZE);\n\t\t\t\t\tif(mountpassword) {\n\t\t\t\t\t\tstrlcpy(mountpassword,temp_val,MOUNT_PASSWD_SIZE+1);\n\t\t\t\t\t\tgot_password = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n                } else if (strncasecmp(\"domain\",line_buf+i,6) == 0) {\n                        temp_val = strchr(line_buf+i,'=');\n                        if(temp_val) {\n                                /* go past equals sign */\n                                temp_val++;\n\t\t\t\tif(verboseflag)\n\t\t\t\t\tfprintf(stderr, \"\\nDomain %s\\n\",temp_val);\n                                for(length = 0;length<DOMAIN_SIZE+1;length++) {\n\t\t\t\t\tif ((temp_val[length] == '\\n')\n\t\t\t\t\t    || (temp_val[length] == '\\0')) {\n\t\t\t\t\t\ttemp_val[length] = '\\0';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n                                }\n                                if(length > DOMAIN_SIZE) {\n                                        fprintf(stderr, \"mount.cifs failed: domain in credentials file too long\\n\");\n                                        exit(EX_USAGE);\n                                } else {\n                                        if(domain_name == NULL) {\n                                                domain_name = (char *)calloc(DOMAIN_SIZE+1,1);\n                                        } else\n                                                memset(domain_name,0,DOMAIN_SIZE);\n                                        if(domain_name) {\n                                                strlcpy(domain_name,temp_val,DOMAIN_SIZE+1);\n                                                got_domain = 1;\n                                        }\n                                }\n                        }\n                }\n\n\t}\n\tfclose(fs);\n\tSAFE_FREE(line_buf);\n\treturn 0;\n}\n- parse_server: static struct addrinfo * /* <=== parse_server */ \nparse_server(char ** punc_name)\n{\n\tchar * unc_name = *punc_name;\n\tint length = strnlen(unc_name, MAX_UNC_LEN);\n\tchar * share;\n\tstruct addrinfo *addrlist;\n\tint rc;\n\n\tif(length > (MAX_UNC_LEN - 1)) {\n\t\tfprintf(stderr, \"mount error: UNC name too long\");\n\t\treturn NULL;\n\t}\n\tif ((strncasecmp(\"cifs://\", unc_name, 7) == 0) ||\n\t    (strncasecmp(\"smb://\", unc_name, 6) == 0)) {\n\t\tfprintf(stderr, \"\\nMounting cifs URL not implemented yet. Attempt to mount %s\\n\", unc_name);\n\t\treturn NULL;\n\t}\n\n\tif(length < 3) {\n\t\t/* BB add code to find DFS root here */\n\t\tfprintf(stderr, \"\\nMounting the DFS root for domain not implemented yet\\n\");\n\t\treturn NULL;\n\t} else {\n\t\tif(strncmp(unc_name,\"//\",2) && strncmp(unc_name,\"\\\\\\\\\",2)) {\n\t\t\t/* check for nfs syntax ie server:share */\n\t\t\tshare = strchr(unc_name,':');\n\t\t\tif(share) {\n\t\t\t\t*punc_name = (char *)malloc(length+3);\n\t\t\t\tif(*punc_name == NULL) {\n\t\t\t\t\t/* put the original string back  if \n\t\t\t\t\t   no memory left */\n\t\t\t\t\t*punc_name = unc_name;\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\t*share = '/';\n\t\t\t\tstrlcpy((*punc_name)+2,unc_name,length+1);\n\t\t\t\tSAFE_FREE(unc_name);\n\t\t\t\tunc_name = *punc_name;\n\t\t\t\tunc_name[length+2] = 0;\n\t\t\t\tgoto continue_unc_parsing;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"mount error: improperly formatted UNC name.\");\n\t\t\t\tfprintf(stderr, \" %s does not begin with \\\\\\\\ or //\\n\",unc_name);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\ncontinue_unc_parsing:\n\t\t\tunc_name[0] = '/';\n\t\t\tunc_name[1] = '/';\n\t\t\tunc_name += 2;\n\n\t\t\t/* allow for either delimiter between host and sharename */\n\t\t\tif ((share = strpbrk(unc_name, \"/\\\\\"))) {\n\t\t\t\t*share = 0;  /* temporarily terminate the string */\n\t\t\t\tshare += 1;\n\t\t\t\tif(got_ip == 0) {\n\t\t\t\t\trc = getaddrinfo(unc_name, NULL, NULL, &addrlist);\n\t\t\t\t\tif (rc != 0) {\n\t\t\t\t\t\tfprintf(stderr, \"mount error: could not resolve address for %s: %s\\n\",\n\t\t\t\t\t\t\tunc_name, gai_strerror(rc));\n\t\t\t\t\t\taddrlist = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t*(share - 1) = '/'; /* put delimiter back */\n\n\t\t\t\t/* we don't convert the prefixpath delimiters since '\\\\' is a valid char in posix paths */\n\t\t\t\tif ((prefixpath = strpbrk(share, \"/\\\\\"))) {\n\t\t\t\t\t*prefixpath = 0;  /* permanently terminate the string */\n\t\t\t\t\tif (!strlen(++prefixpath))\n\t\t\t\t\t\tprefixpath = NULL; /* this needs to be done explicitly */\n\t\t\t\t}\n\t\t\t\tif(got_ip) {\n\t\t\t\t\tif(verboseflag)\n\t\t\t\t\t\tfprintf(stderr, \"ip address specified explicitly\\n\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\t/* BB should we pass an alternate version of the share name as Unicode */\n\n\t\t\t\treturn addrlist; \n\t\t\t} else {\n\t\t\t\t/* BB add code to find DFS root (send null path on get DFS Referral to specified server here */\n\t\t\t\tfprintf(stderr, \"Mounting the DFS root for a particular server not implemented yet\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n}\n- check_for_domain: static char * check_for_domain(char **ppuser) /* <=== check_for_domain */ \n{\n\tchar * original_string;\n\tchar * usernm;\n\tchar * domainnm;\n\tint    original_len;\n\tint    len;\n\tint    i;\n\n\tif(ppuser == NULL)\n\t\treturn NULL;\n\n\toriginal_string = *ppuser;\n\n\tif (original_string == NULL)\n\t\treturn NULL;\n\t\n\toriginal_len = strlen(original_string);\n\n\tusernm = strchr(*ppuser,'/');\n\tif (usernm == NULL) {\n\t\tusernm = strchr(*ppuser,'\\\\');\n\t\tif (usernm == NULL)\n\t\t\treturn NULL;\n\t}\n\n\tif(got_domain) {\n\t\tfprintf(stderr, \"Domain name specified twice. Username probably malformed\\n\");\n\t\treturn NULL;\n\t}\n\n\tusernm[0] = 0;\n\tdomainnm = *ppuser;\n\tif (domainnm[0] != 0) {\n\t\tgot_domain = 1;\n\t} else {\n\t\tfprintf(stderr, \"null domain\\n\");\n\t}\n\tlen = strlen(domainnm);\n\t/* reset domainm to new buffer, and copy\n\tdomain name into it */\n\tdomainnm = (char *)malloc(len+1);\n\tif(domainnm == NULL)\n\t\treturn NULL;\n\n\tstrlcpy(domainnm,*ppuser,len+1);\n\n/*\tmove_string(*ppuser, usernm+1) */\n\tlen = strlen(usernm+1);\n\n\tif(len >= original_len) {\n\t\t/* should not happen */\n\t\treturn domainnm;\n\t}\n\n\tfor(i=0;i<original_len;i++) {\n\t\tif(i<len)\n\t\t\toriginal_string[i] = usernm[i+1];\n\t\telse /* stuff with commas to remove last parm */\n\t\t\toriginal_string[i] = ',';\n\t}\n\n\t/* BB add check for more than one slash? \n\t  strchr(*ppuser,'/');\n\t  strchr(*ppuser,'\\\\') \n\t*/\n\t\n\treturn domainnm;\n}\n- CIFS_SETUID_FLAGS: #define CIFS_SETUID_FLAGS (MS_NOSUID|MS_NODEV) /* <=== client/mount.cifs.c:108:108:CIFS_SETUID_FLAGS:0 */ \n- uppercase_string: static int /* <=== uppercase_string */ \nuppercase_string(char *string)\n{\n\tif (!string)\n\t\treturn 1;\n\n\twhile (*string) {\n\t\t/* check for unicode */\n\t\tif ((unsigned char) string[0] & 0x80)\n\t\t\treturn 0;\n\t\t*string = toupper((unsigned char) *string);\n\t\tstring++;\n\t}\n\n\treturn 1;\n}\n- malloc: void *malloc(size_t size) /* <=== malloc */ \n{\n        void *__libc_malloc(size_t size);\n        return __libc_malloc(size);\n}\n- MS_USERS: #define MS_USERS\t0x40000000 /* <=== client/mount.cifs.c:74:74:MS_USERS:0 */ \n- MOUNTLOCK_WAITTIME: #define MOUNTLOCK_WAITTIME\t\t5000 /* <=== client/mtab.c:113:113:MOUNTLOCK_WAITTIME:0 */ \n- open: int open(__const char *name, int flags, ...) /* <=== open */ \n{\n        va_list ap;\n        mode_t mode;\n        \n        va_start(ap, flags);\n        mode = va_arg(ap, mode_t);\n        va_end(ap);\n        \n        check_init(\"open\");\n        \n        return openx((char *) name, flags, mode, smbw_libc.open);\n}\n- MAX_ADDRESS_LEN: #define MAX_ADDRESS_LEN INET6_ADDRSTRLEN /* <=== client/mount.cifs.c:87:87:MAX_ADDRESS_LEN:0 */ \n- MOUNT_PASSWD_SIZE: #define MOUNT_PASSWD_SIZE 128 /* <=== client/mount.cifs.c:83:83:MOUNT_PASSWD_SIZE:0 */ \n- SAFE_FREE: #define SAFE_FREE(x) do { if ((x) != NULL) {free(x); x=NULL;} } while(0) /* <=== client/mount.cifs.c:80:80:SAFE_FREE:1 */ \n- fcntl: int fcntl (int fd, int cmd, ...) /* <=== fcntl */ \n{\n        va_list ap;\n        long arg;\n        \n        va_start(ap, cmd);\n        arg = va_arg(ap, long);\n        va_end(ap);\n        \n        check_init(\"fcntl\");\n        return fcntlx(fd, cmd, arg, smbw_libc.fcntl);\n}\n- rep_vasprintf:  int vasprintf(char **ptr, const char *format, va_list ap) /* <=== rep_vasprintf */ \n{\n\tint ret;\n\tva_list ap2;\n\n\tVA_COPY(ap2, ap);\n\tret = vsnprintf(NULL, 0, format, ap2);\n\tva_end(ap2);\n\tif (ret < 0) return ret;\n\n\t(*ptr) = (char *)malloc(ret+1);\n\tif (!*ptr) return -1;\n\n\tVA_COPY(ap2, ap);\n\tret = vsnprintf(*ptr, ret+1, format, ap2);\n\tva_end(ap2);\n\n\treturn ret;\n}\n- MAX_UNC_LEN: #define MAX_UNC_LEN 1024 /* <=== client/mount.cifs.c:77:77:MAX_UNC_LEN:0 */ \n\nType Definitions:\n- sockaddr_in: static struct sockaddr_storage\n\nGlobal Variables:\n- static int got_ip\n- static option[] longopts\n- static int got_domain\n- const char* cifs_fstype\n- char* prefixpath\n- int verboseflag\n- static char* user_name\n- static int got_password\n- static char* mountpassword\n- const char* thisprogram\n- char* domain_name\n- static int got_user\n- int fakemnt\n\nImports:\n- #include <arpa/inet.h>\n- #include <sys/socket.h>\n- #include <fstab.h>\n- #include <unistd.h>\n- #include <mntent.h>\n- #include <sys/stat.h>\n- #include <limits.h>\n- #include <errno.h>\n- #include <sys/mount.h>\n- #include <getopt.h>\n- #include \"version.h\"\n- #include <string.h>\n- #include \"include/config.h\"\n- #include <sys/utsname.h>\n- #include <stdio.h>\n- #include <sys/types.h>\n- #include <pwd.h>\n- #include <netdb.h>\n- #include <stdlib.h>\n- #include \"mount.h\"\n- #include <grp.h>\n- #include <fcntl.h>\n- #include <ctype.h>",
    "commit_msg": "mount.cifs: check for invalid characters in device name and mountpoint\n\nIt's apparently possible to corrupt the mtab if you pass embedded\nnewlines to addmntent. Apparently tabs are also a problem with certain\nearlier glibc versions. Backslashes are also a minor issue apparently,\nbut we can't reasonably filter those.\n\nMake sure that neither the devname or mountpoint contain any problematic\ncharacters before allowing the mount to proceed.\n\nSigned-off-by: Jeff Layton <jlayton@redhat.com>",
    "cve_desc": "ncpfs 2.2.6 allows local users to cause a denial of service, obtain sensitive information, or possibly gain privileges via symlink attacks involving the (1) ncpmount and (2) ncpumount programs.",
    "year": 2010,
    "filename": "mount.cifs.c",
    "commit_url": "\"https://github.com/samba-team/samba/commit/a065c177dfc8f968775593ba00dffafeebb2e054\""
  },
  {
    "repository": "memcached/memcached",
    "cve_id": "CVE-2010-1152",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "d9cd01ede97f4145af9781d448c62a3318952719",
    "short_hash": "d9cd01ed",
    "vulnerableMethods_before": [
      {
        "filename": "memcached.c",
        "method_name": "try_read_command",
        "raw_code": "static int try_read_command(conn *c) { /* <=== try_read_command */ \n    assert(c != NULL);\n    assert(c->rcurr <= (c->rbuf + c->rsize));\n    assert(c->rbytes > 0);\n\n    if (c->protocol == negotiating_prot || c->transport == udp_transport)  {\n        if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {\n            c->protocol = binary_prot;\n        } else {\n            c->protocol = ascii_prot;\n        }\n\n        if (settings.verbose > 1) {\n            fprintf(stderr, \"%d: Client using the %s protocol\\n\", c->sfd,\n                    prot_text(c->protocol));\n        }\n    }\n\n    if (c->protocol == binary_prot) {\n        /* Do we have the complete packet header? */\n        if (c->rbytes < sizeof(c->binary_header)) {\n            /* need more data! */\n            return 0;\n        } else {\n#ifdef NEED_ALIGN\n            if (((long)(c->rcurr)) % 8 != 0) {\n                /* must realign input buffer */\n                memmove(c->rbuf, c->rcurr, c->rbytes);\n                c->rcurr = c->rbuf;\n                if (settings.verbose > 1) {\n                    fprintf(stderr, \"%d: Realign input buffer\\n\", c->sfd);\n                }\n            }\n#endif\n            protocol_binary_request_header* req;\n            req = (protocol_binary_request_header*)c->rcurr;\n\n            if (settings.verbose > 1) {\n                /* Dump the packet before we convert it to host order */\n                int ii;\n                fprintf(stderr, \"<%d Read binary protocol data:\", c->sfd);\n                for (ii = 0; ii < sizeof(req->bytes); ++ii) {\n                    if (ii % 4 == 0) {\n                        fprintf(stderr, \"\\n<%d   \", c->sfd);\n                    }\n                    fprintf(stderr, \" 0x%02x\", req->bytes[ii]);\n                }\n                fprintf(stderr, \"\\n\");\n            }\n\n            c->binary_header = *req;\n            c->binary_header.request.keylen = ntohs(req->request.keylen);\n            c->binary_header.request.bodylen = ntohl(req->request.bodylen);\n            c->binary_header.request.cas = ntohll(req->request.cas);\n\n            if (c->binary_header.request.magic != PROTOCOL_BINARY_REQ) {\n                if (settings.verbose) {\n                    fprintf(stderr, \"Invalid magic:  %x\\n\",\n                            c->binary_header.request.magic);\n                }\n                conn_set_state(c, conn_closing);\n                return -1;\n            }\n\n            c->msgcurr = 0;\n            c->msgused = 0;\n            c->iovused = 0;\n            if (add_msghdr(c) != 0) {\n                out_string(c, \"SERVER_ERROR out of memory\");\n                return 0;\n            }\n\n            c->cmd = c->binary_header.request.opcode;\n            c->keylen = c->binary_header.request.keylen;\n            c->opaque = c->binary_header.request.opaque;\n            /* clear the returned cas value */\n            c->cas = 0;\n\n            dispatch_bin_command(c);\n\n            c->rbytes -= sizeof(c->binary_header);\n            c->rcurr += sizeof(c->binary_header);\n        }\n    } else {\n        char *el, *cont;\n\n        if (c->rbytes == 0)\n            return 0;\n\n        el = memchr(c->rcurr, '\\n', c->rbytes);\n        if (!el) {\n            if (c->rbytes > 1024) {\n                /*\n                 * We didn't have a '\\n' in the first k. This _has_ to be a\n                 * large multiget, if not we should just nuke the connection.\n                 */\n                char *ptr = c->rcurr;\n                while (*ptr == ' ') { /* ignore leading whitespaces */\n                    ++ptr;\n                }\n\n                if (strcmp(ptr, \"get \") && strcmp(ptr, \"gets \")) {\n                    conn_set_state(c, conn_closing);\n                    return 1;\n                }\n            }\n\n            return 0;\n        }\n        cont = el + 1;\n        if ((el - c->rcurr) > 1 && *(el - 1) == '\\r') {\n            el--;\n        }\n        *el = '\\0';\n\n        assert(cont <= (c->rcurr + c->rbytes));\n\n        process_command(c, c->rcurr);\n\n        c->rbytes -= (cont - c->rcurr);\n        c->rcurr = cont;\n\n        assert(c->rcurr <= (c->rbuf + c->rsize));\n    }\n\n    return 1;\n}",
        "start_line": 3050
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "memcached.c",
        "method_name": "try_read_command",
        "raw_code": "static int try_read_command(conn *c) { /* <=== try_read_command */ \n    assert(c != NULL);\n    assert(c->rcurr <= (c->rbuf + c->rsize));\n    assert(c->rbytes > 0);\n\n    if (c->protocol == negotiating_prot || c->transport == udp_transport)  {\n        if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {\n            c->protocol = binary_prot;\n        } else {\n            c->protocol = ascii_prot;\n        }\n\n        if (settings.verbose > 1) {\n            fprintf(stderr, \"%d: Client using the %s protocol\\n\", c->sfd,\n                    prot_text(c->protocol));\n        }\n    }\n\n    if (c->protocol == binary_prot) {\n        /* Do we have the complete packet header? */\n        if (c->rbytes < sizeof(c->binary_header)) {\n            /* need more data! */\n            return 0;\n        } else {\n#ifdef NEED_ALIGN\n            if (((long)(c->rcurr)) % 8 != 0) {\n                /* must realign input buffer */\n                memmove(c->rbuf, c->rcurr, c->rbytes);\n                c->rcurr = c->rbuf;\n                if (settings.verbose > 1) {\n                    fprintf(stderr, \"%d: Realign input buffer\\n\", c->sfd);\n                }\n            }\n#endif\n            protocol_binary_request_header* req;\n            req = (protocol_binary_request_header*)c->rcurr;\n\n            if (settings.verbose > 1) {\n                /* Dump the packet before we convert it to host order */\n                int ii;\n                fprintf(stderr, \"<%d Read binary protocol data:\", c->sfd);\n                for (ii = 0; ii < sizeof(req->bytes); ++ii) {\n                    if (ii % 4 == 0) {\n                        fprintf(stderr, \"\\n<%d   \", c->sfd);\n                    }\n                    fprintf(stderr, \" 0x%02x\", req->bytes[ii]);\n                }\n                fprintf(stderr, \"\\n\");\n            }\n\n            c->binary_header = *req;\n            c->binary_header.request.keylen = ntohs(req->request.keylen);\n            c->binary_header.request.bodylen = ntohl(req->request.bodylen);\n            c->binary_header.request.cas = ntohll(req->request.cas);\n\n            if (c->binary_header.request.magic != PROTOCOL_BINARY_REQ) {\n                if (settings.verbose) {\n                    fprintf(stderr, \"Invalid magic:  %x\\n\",\n                            c->binary_header.request.magic);\n                }\n                conn_set_state(c, conn_closing);\n                return -1;\n            }\n\n            c->msgcurr = 0;\n            c->msgused = 0;\n            c->iovused = 0;\n            if (add_msghdr(c) != 0) {\n                out_string(c, \"SERVER_ERROR out of memory\");\n                return 0;\n            }\n\n            c->cmd = c->binary_header.request.opcode;\n            c->keylen = c->binary_header.request.keylen;\n            c->opaque = c->binary_header.request.opaque;\n            /* clear the returned cas value */\n            c->cas = 0;\n\n            dispatch_bin_command(c);\n\n            c->rbytes -= sizeof(c->binary_header);\n            c->rcurr += sizeof(c->binary_header);\n        }\n    } else {\n        char *el, *cont;\n\n        if (c->rbytes == 0)\n            return 0;\n\n        el = memchr(c->rcurr, '\\n', c->rbytes);\n        if (!el) {\n            if (c->rbytes > 1024) {\n                /*\n                 * We didn't have a '\\n' in the first k. This _has_ to be a\n                 * large multiget, if not we should just nuke the connection.\n                 */\n                char *ptr = c->rcurr;\n                while (*ptr == ' ') { /* ignore leading whitespaces */\n                    ++ptr;\n                }\n\n                if (ptr - c->rcurr > 100 ||\n                    (strncmp(ptr, \"get \", 4) && strncmp(ptr, \"gets \", 5))) {\n\n                    conn_set_state(c, conn_closing);\n                    return 1;\n                }\n            }\n\n            return 0;\n        }\n        cont = el + 1;\n        if ((el - c->rcurr) > 1 && *(el - 1) == '\\r') {\n            el--;\n        }\n        *el = '\\0';\n\n        assert(cont <= (c->rcurr + c->rbytes));\n\n        process_command(c, c->rcurr);\n\n        c->rbytes -= (cont - c->rcurr);\n        c->rcurr = cont;\n\n        assert(c->rcurr <= (c->rbuf + c->rsize));\n    }\n\n    return 1;\n}",
        "start_line": 3050
      }
    ],
    "code_context": "Called Methods:\n- prot_text: static const char *prot_text(enum protocol prot) { /* <=== prot_text */ \n    char *rv = \"unknown\";\n    switch(prot) {\n        case ascii_prot:\n            rv = \"ascii\";\n            break;\n        case binary_prot:\n            rv = \"binary\";\n            break;\n        case negotiating_prot:\n            rv = \"auto-negotiate\";\n            break;\n    }\n    return rv;\n}\n- conn_set_state: static void conn_set_state(conn *c, enum conn_states state) { /* <=== conn_set_state */ \n    assert(c != NULL);\n    assert(state >= conn_listening && state < conn_max_state);\n\n    if (state != c->state) {\n        if (settings.verbose > 2) {\n            fprintf(stderr, \"%d: going from %s to %s\\n\",\n                    c->sfd, state_text(c->state),\n                    state_text(state));\n        }\n\n        c->state = state;\n\n        if (state == conn_write || state == conn_mwrite) {\n            MEMCACHED_PROCESS_COMMAND_END(c->sfd, c->wbuf, c->wbytes);\n        }\n    }\n}\n- state_text: static const char *state_text(enum conn_states state) { /* <=== state_text */ \n    const char* const statenames[] = { \"conn_listening\",\n                                       \"conn_new_cmd\",\n                                       \"conn_waiting\",\n                                       \"conn_read\",\n                                       \"conn_parse_cmd\",\n                                       \"conn_write\",\n                                       \"conn_nread\",\n                                       \"conn_swallow\",\n                                       \"conn_closing\",\n                                       \"conn_mwrite\" };\n    return statenames[state];\n}\n\nType Definitions:\n- conn: typedef struct conn\n- settings: struct settings\n- conn: struct conn {\n    int    sfd;\n    sasl_conn_t *sasl_conn;\n    enum conn_states  state;\n    enum bin_substates substate;\n    struct event event;\n    short  ev_flags;\n    short  which;   /** which events were just triggered */\n\n    char   *rbuf;   /** buffer to read commands into */\n    char   *rcurr;  /** but if we parsed some already, this is where we stopped */\n    int    rsize;   /** total allocated size of rbuf */\n    int    rbytes;  /** how much data, starting from rcur, do we have unparsed */\n\n    char   *wbuf;\n    char   *wcurr;\n    int    wsize;\n    int    wbytes;\n    /** which state to go into after finishing current write */\n    enum conn_states  write_and_go;\n    void   *write_and_free; /** free this memory after finishing writing */\n\n    char   *ritem;  /** when we read in an item's value, it goes here */\n    int    rlbytes;\n\n    /* data for the nread state */\n\n    /**\n     * item is used to hold an item structure created after reading the command\n     * line of set/add/replace commands, but before we finished reading the actual\n     * data. The data is read into ITEM_data(item) to avoid extra copying.\n     */\n\n    void   *item;     /* for commands set/add/replace  */\n\n    /* data for the swallow state */\n    int    sbytes;    /* how many bytes to swallow */\n\n    /* data for the mwrite state */\n    struct iovec *iov;\n    int    iovsize;   /* number of elements allocated in iov[] */\n    int    iovused;   /* number of elements used in iov[] */\n\n    struct msghdr *msglist;\n    int    msgsize;   /* number of elements allocated in msglist[] */\n    int    msgused;   /* number of elements used in msglist[] */\n    int    msgcurr;   /* element in msglist[] being transmitted now */\n    int    msgbytes;  /* number of bytes in current msg */\n\n    item   **ilist;   /* list of items to write out */\n    int    isize;\n    item   **icurr;\n    int    ileft;\n\n    char   **suffixlist;\n    int    suffixsize;\n    char   **suffixcurr;\n    int    suffixleft;\n\n    enum protocol protocol;   /* which protocol this connection speaks */\n    enum network_transport transport; /* what transport is used by this connection */\n\n    /* data for UDP clients */\n    int    request_id; /* Incoming UDP request ID, if this is a UDP \"connection\" */\n    struct sockaddr request_addr; /* Who sent the most recent request */\n    socklen_t request_addr_size;\n    unsigned char *hdrbuf; /* udp packet headers */\n    int    hdrsize;   /* number of headers' worth of space is allocated */\n\n    bool   noreply;   /* True if the reply should not be sent. */\n    /* current stats command */\n    struct {\n        char *buffer;\n        size_t size;\n        size_t offset;\n    } stats;\n\n    /* Binary protocol stuff */\n    /* This is where the binary header goes */\n    protocol_binary_request_header binary_header;\n    uint64_t cas; /* the cas to return */\n    short cmd; /* current command being processed */\n    int opaque;\n    int keylen;\n    conn   *next;     /* Used for generating a list of conn structures */\n    LIBEVENT_THREAD *thread; /* Pointer to the thread object serving this connection */\n}\n\nGlobal Variables:\n- struct settings settings\n\nImports:\n- #include <pwd.h>\n- #include <time.h>\n- #include <assert.h>\n- #include <arpa/inet.h>\n- #include <sys/mman.h>\n- #include <sys/uio.h>\n- #include <sys/resource.h>\n- #include <sys/un.h>\n- #include <stdio.h>\n- #include <netinet/tcp.h>\n- #include <sysexits.h>\n- #include <sys/socket.h>\n- #include <stddef.h>\n- #include \"memcached.h\"\n- #include <stdlib.h>\n- #include <stdarg.h>\n- #include <signal.h>\n- #include <limits.h>\n- #include <errno.h>\n- #include <ctype.h>\n- #include <sys/stat.h>\n- #include <string.h>\n- #include <fcntl.h>",
    "commit_msg": "Use strncmp when checking for large ascii multigets.",
    "cve_desc": "memcached.c in memcached before 1.4.3 allows remote attackers to cause a denial of service (daemon hang or crash) via a long line that triggers excessive memory allocation.  NOTE: some of these details are obtained from third party information.",
    "year": 2009,
    "filename": "memcached.c",
    "commit_url": "\"https://github.com/memcached/memcached/commit/d9cd01ede97f4145af9781d448c62a3318952719\""
  },
  {
    "repository": "vrtadmin/clamav-devel",
    "cve_id": "CVE-2010-1311",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "224fee54dd6cd8933d7007331ec2bfca0398d4b4",
    "short_hash": "224fee54",
    "vulnerableMethods_before": [
      {
        "filename": "libclamav/mspack.c",
        "method_name": "qtm_decompress",
        "raw_code": "int qtm_decompress(struct qtm_stream *qtm, off_t out_bytes) { /* <=== qtm_decompress */ \n  unsigned int frame_start, frame_end, window_posn, match_offset, range;\n  unsigned char *window, *i_ptr, *i_end, *runsrc, *rundest;\n  int i, j, selector, extra, sym, match_length, ret;\n  unsigned short H, L, C, symf;\n\n  register unsigned int bit_buffer;\n  register unsigned char bits_left;\n  unsigned char bits_needed, bit_run;\n\n  /* easy answers */\n  if (!qtm || (out_bytes < 0)) return CL_ENULLARG;\n  if (qtm->error) return qtm->error;\n\n  /* flush out any stored-up bytes before we begin */\n  i = qtm->o_end - qtm->o_ptr;\n  if ((off_t) i > out_bytes) i = (int) out_bytes;\n  if (i) {\n    if (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {\n      return qtm->error = ret;\n    }\n    qtm->o_ptr  += i;\n    out_bytes   -= i;\n  }\n  if (out_bytes == 0) return CL_SUCCESS;\n\n  /* restore local state */\n  QTM_RESTORE_BITS;\n  window = qtm->window;\n  window_posn = qtm->window_posn;\n  frame_start = qtm->frame_start;\n  H = qtm->H;\n  L = qtm->L;\n  C = qtm->C;\n\n  /* while we do not have enough decoded bytes in reserve: */\n  while ((qtm->o_end - qtm->o_ptr) < out_bytes) {\n\n    /* read header if necessary. Initialises H, L and C */\n    if (!qtm->header_read) {\n      H = 0xFFFF; L = 0; QTM_READ_BITS(C, 16);\n      qtm->header_read = 1;\n    }\n\n    /* decode more, at most up to to frame boundary */\n    frame_end = window_posn + (out_bytes - (qtm->o_end - qtm->o_ptr));\n    if ((frame_start + QTM_FRAME_SIZE) < frame_end) {\n      frame_end = frame_start + QTM_FRAME_SIZE;\n    }\n\n    while (window_posn < frame_end) {\n      QTM_GET_SYMBOL(qtm->model7, selector);\n      if (selector < 4) {\n\tstruct qtm_model *mdl = (selector == 0) ? &qtm->model0 :\n\t                        ((selector == 1) ? &qtm->model1 :\n\t\t\t\t((selector == 2) ? &qtm->model2 :\n                                                   &qtm->model3));\n\tQTM_GET_SYMBOL((*mdl), sym);\n\twindow[window_posn++] = sym;\n      }\n      else {\n\tswitch (selector) {\n\tcase 4: /* selector 4 = fixed length match (3 bytes) */\n\t  QTM_GET_SYMBOL(qtm->model4, sym);\n\t  QTM_READ_BITS(extra, qtm->extra_bits[sym]);\n\t  match_offset = qtm->position_base[sym] + extra + 1;\n\t  match_length = 3;\n\t  break;\n\n\tcase 5: /* selector 5 = fixed length match (4 bytes) */\n\t  QTM_GET_SYMBOL(qtm->model5, sym);\n\t  QTM_READ_BITS(extra, qtm->extra_bits[sym]);\n\t  match_offset = qtm->position_base[sym] + extra + 1;\n\t  match_length = 4;\n\t  break;\n\n\tcase 6: /* selector 6 = variable length match */\n\t  QTM_GET_SYMBOL(qtm->model6len, sym);\n\t  QTM_READ_BITS(extra, qtm->length_extra[sym]);\n\t  match_length = qtm->length_base[sym] + extra + 5;\n\n\t  QTM_GET_SYMBOL(qtm->model6, sym);\n\t  QTM_READ_BITS(extra, qtm->extra_bits[sym]);\n\t  match_offset = qtm->position_base[sym] + extra + 1;\n\t  break;\n\n\tdefault:\n\t  /* should be impossible, model7 can only return 0-6 */\n\t  return qtm->error = CL_EFORMAT;\n\t}\n\n\trundest = &window[window_posn];\n\ti = match_length;\n\t/* does match offset wrap the window? */\n\tif (match_offset > window_posn) {\n\t  /* j = length from match offset to end of window */\n\t  j = match_offset - window_posn;\n\t  if (j > (int) qtm->window_size) {\n\t    cli_dbgmsg(\"qtm_decompress: match offset beyond window boundaries\\n\");\n\t    return qtm->error = CL_EFORMAT;\n\t  }\n\t  runsrc = &window[qtm->window_size - j];\n\t  if (j < i) {\n\t    /* if match goes over the window edge, do two copy runs */\n\t    i -= j; while (j-- > 0) *rundest++ = *runsrc++;\n\t    runsrc = window;\n\t  }\n\t  while (i-- > 0) *rundest++ = *runsrc++;\n\t}\n\telse {\n\t  runsrc = rundest - match_offset;\n\t  if(i > (int) (qtm->window_size - window_posn))\n\t    i = qtm->window_size - window_posn;\n\t  while (i-- > 0) *rundest++ = *runsrc++;\n\t}\n\twindow_posn += match_length;\n      }\n    } /* while (window_posn < frame_end) */\n\n    qtm->o_end = &window[window_posn];\n\n    /* another frame completed? */\n    if ((window_posn - frame_start) >= QTM_FRAME_SIZE) {\n      if ((window_posn - frame_start) != QTM_FRAME_SIZE) {\n\tcli_dbgmsg(\"qtm_decompress: overshot frame alignment\\n\");\n\treturn qtm->error = CL_EFORMAT;\n      }\n\n      /* re-align input */\n      if (bits_left & 7) QTM_REMOVE_BITS(bits_left & 7);\n      do { QTM_READ_BITS(i, 8); } while (i != 0xFF);\n      qtm->header_read = 0;\n\n      /* window wrap? */\n      if (window_posn == qtm->window_size) {\n\t/* flush all currently stored data */\n\ti = (qtm->o_end - qtm->o_ptr);\n\tif (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {\n\t  return qtm->error = ret;\n\t}\n\tout_bytes -= i;\n\tqtm->o_ptr = &window[0];\n\tqtm->o_end = &window[0];\n\twindow_posn = 0;\n      }\n\n      frame_start = window_posn;\n    }\n\n  } /* while (more bytes needed) */\n\n  if (out_bytes) {\n    i = (int) out_bytes;\n    if (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {\n      return qtm->error = ret;\n    }\n    qtm->o_ptr += i;\n  }\n\n  /* store local state */\n  QTM_STORE_BITS;\n  qtm->window_posn = window_posn;\n  qtm->frame_start = frame_start;\n  qtm->H = H;\n  qtm->L = L;\n  qtm->C = C;\n\n  return CL_SUCCESS;\n}",
        "start_line": 1808
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "libclamav/mspack.c",
        "method_name": "qtm_decompress",
        "raw_code": "int qtm_decompress(struct qtm_stream *qtm, off_t out_bytes) { /* <=== qtm_decompress */ \n  unsigned int frame_start, frame_end, window_posn, match_offset, range;\n  unsigned char *window, *i_ptr, *i_end, *runsrc, *rundest;\n  int i, j, selector, extra, sym, match_length, ret;\n  unsigned short H, L, C, symf;\n\n  register unsigned int bit_buffer;\n  register unsigned char bits_left;\n  unsigned char bits_needed, bit_run;\n\n  /* easy answers */\n  if (!qtm || (out_bytes < 0)) return CL_ENULLARG;\n  if (qtm->error) return qtm->error;\n\n  /* flush out any stored-up bytes before we begin */\n  i = qtm->o_end - qtm->o_ptr;\n  if ((off_t) i > out_bytes) i = (int) out_bytes;\n  if (i) {\n    if (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {\n      return qtm->error = ret;\n    }\n    qtm->o_ptr  += i;\n    out_bytes   -= i;\n  }\n  if (out_bytes == 0) return CL_SUCCESS;\n\n  /* restore local state */\n  QTM_RESTORE_BITS;\n  window = qtm->window;\n  window_posn = qtm->window_posn;\n  frame_start = qtm->frame_start;\n  H = qtm->H;\n  L = qtm->L;\n  C = qtm->C;\n\n  /* while we do not have enough decoded bytes in reserve: */\n  while ((qtm->o_end - qtm->o_ptr) < out_bytes) {\n\n    /* read header if necessary. Initialises H, L and C */\n    if (!qtm->header_read) {\n      H = 0xFFFF; L = 0; QTM_READ_BITS(C, 16);\n      qtm->header_read = 1;\n    }\n\n    /* decode more, at most up to to frame boundary */\n    frame_end = window_posn + (out_bytes - (qtm->o_end - qtm->o_ptr));\n    if ((frame_start + QTM_FRAME_SIZE) < frame_end) {\n      frame_end = frame_start + QTM_FRAME_SIZE;\n    }\n\n    while (window_posn < frame_end) {\n      QTM_GET_SYMBOL(qtm->model7, selector);\n      if (selector < 4) {\n\tstruct qtm_model *mdl = (selector == 0) ? &qtm->model0 :\n\t                        ((selector == 1) ? &qtm->model1 :\n\t\t\t\t((selector == 2) ? &qtm->model2 :\n                                                   &qtm->model3));\n\tQTM_GET_SYMBOL((*mdl), sym);\n\twindow[window_posn++] = sym;\n      }\n      else {\n\tswitch (selector) {\n\tcase 4: /* selector 4 = fixed length match (3 bytes) */\n\t  QTM_GET_SYMBOL(qtm->model4, sym);\n\t  QTM_READ_BITS(extra, qtm->extra_bits[sym]);\n\t  match_offset = qtm->position_base[sym] + extra + 1;\n\t  match_length = 3;\n\t  break;\n\n\tcase 5: /* selector 5 = fixed length match (4 bytes) */\n\t  QTM_GET_SYMBOL(qtm->model5, sym);\n\t  QTM_READ_BITS(extra, qtm->extra_bits[sym]);\n\t  match_offset = qtm->position_base[sym] + extra + 1;\n\t  match_length = 4;\n\t  break;\n\n\tcase 6: /* selector 6 = variable length match */\n\t  QTM_GET_SYMBOL(qtm->model6len, sym);\n\t  QTM_READ_BITS(extra, qtm->length_extra[sym]);\n\t  match_length = qtm->length_base[sym] + extra + 5;\n\n\t  QTM_GET_SYMBOL(qtm->model6, sym);\n\t  QTM_READ_BITS(extra, qtm->extra_bits[sym]);\n\t  match_offset = qtm->position_base[sym] + extra + 1;\n\t  break;\n\n\tdefault:\n\t  /* should be impossible, model7 can only return 0-6 */\n\t  return qtm->error = CL_EFORMAT;\n\t}\n\n\tif (window_posn + match_length > qtm->window_size) {\n\t  cli_dbgmsg(\"qtm_decompress: match ran over window wrap\\n\");\n\t  return qtm->error = CL_EFORMAT;\n\t}\n\n\trundest = &window[window_posn];\n\ti = match_length;\n\t/* does match offset wrap the window? */\n\tif (match_offset > window_posn) {\n\t  /* j = length from match offset to end of window */\n\t  j = match_offset - window_posn;\n\t  if (j > (int) qtm->window_size) {\n\t    cli_dbgmsg(\"qtm_decompress: match offset beyond window boundaries\\n\");\n\t    return qtm->error = CL_EFORMAT;\n\t  }\n\t  runsrc = &window[qtm->window_size - j];\n\t  if (j < i) {\n\t    /* if match goes over the window edge, do two copy runs */\n\t    i -= j; while (j-- > 0) *rundest++ = *runsrc++;\n\t    runsrc = window;\n\t  }\n\t  while (i-- > 0) *rundest++ = *runsrc++;\n\t}\n\telse {\n\t  runsrc = rundest - match_offset;\n\t  if(i > (int) (qtm->window_size - window_posn))\n\t    i = qtm->window_size - window_posn;\n\t  while (i-- > 0) *rundest++ = *runsrc++;\n\t}\n\twindow_posn += match_length;\n      }\n    } /* while (window_posn < frame_end) */\n\n    qtm->o_end = &window[window_posn];\n\n    /* another frame completed? */\n    if ((window_posn - frame_start) >= QTM_FRAME_SIZE) {\n      if ((window_posn - frame_start) != QTM_FRAME_SIZE) {\n\tcli_dbgmsg(\"qtm_decompress: overshot frame alignment\\n\");\n\treturn qtm->error = CL_EFORMAT;\n      }\n\n      /* re-align input */\n      if (bits_left & 7) QTM_REMOVE_BITS(bits_left & 7);\n      do { QTM_READ_BITS(i, 8); } while (i != 0xFF);\n      qtm->header_read = 0;\n\n      /* window wrap? */\n      if (window_posn == qtm->window_size) {\n\t/* flush all currently stored data */\n\ti = (qtm->o_end - qtm->o_ptr);\n\tif (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {\n\t  return qtm->error = ret;\n\t}\n\tout_bytes -= i;\n\tqtm->o_ptr = &window[0];\n\tqtm->o_end = &window[0];\n\twindow_posn = 0;\n      }\n\n      frame_start = window_posn;\n    }\n\n  } /* while (more bytes needed) */\n\n  if (out_bytes) {\n    i = (int) out_bytes;\n    if (qtm->wflag && (ret = mspack_write(qtm->ofd, qtm->o_ptr, i, qtm->file)) != CL_SUCCESS) {\n      return qtm->error = ret;\n    }\n    qtm->o_ptr += i;\n  }\n\n  /* store local state */\n  QTM_STORE_BITS;\n  qtm->window_posn = window_posn;\n  qtm->frame_start = frame_start;\n  qtm->H = H;\n  qtm->L = L;\n  qtm->C = C;\n\n  return CL_SUCCESS;\n}",
        "start_line": 1808
      }
    ],
    "code_context": "Called Methods:\n- cli_writen: int cli_writen(int fd, const void *buff, unsigned int count) /* <=== cli_writen */ \n{\n        int retval;\n        unsigned int todo;\n        const unsigned char *current;\n\n\n        todo = count;\n        current = (const unsigned char *) buff;\n\n        do {\n                retval = write(fd, current, todo);\n                if (retval < 0) {\n\t\t\tchar err[128];\n\t\t\tif (errno == EINTR) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcli_errmsg(\"cli_writen: write error: %s\\n\", cli_strerror(errno, err, sizeof(err)));\n                        return -1;\n                }\n                todo -= retval;\n                current += retval;\n        } while (todo > 0);\n\n\n        return count;\n}\n- MSGCODE: #define MSGCODE(x)\t\t\t\t\t    \\ /* <=== libclamav/others_common.c:81:91:MSGCODE:1 */ \n\tva_list args;\t\t\t\t\t    \\\n\tint len = sizeof(x) - 1;\t\t\t    \\\n\tchar buff[BUFSIZ];\t\t\t\t    \\\n    strncpy(buff, x, len);\t\t\t\t    \\\n    buff[BUFSIZ-1]='\\0';\t\t\t\t    \\\n    va_start(args, str);\t\t\t\t    \\\n    vsnprintf(buff + len, sizeof(buff) - len, str, args);   \\\n    buff[sizeof(buff) - 1] = '\\0';\t\t\t    \\\n    fputs(buff, stderr);\t\t\t\t    \\\n    va_end(args)\n- QTM_FRAME_SIZE: #define QTM_FRAME_SIZE (32768) /* <=== libclamav/mspack.h:109:109:QTM_FRAME_SIZE:0 */ \n- QTM_REMOVE_BITS: #define QTM_REMOVE_BITS(n) ((bit_buffer <<= (n)), (bits_left -= (n))) /* <=== libclamav/mspack.c:1592:1592:QTM_REMOVE_BITS:1 */ \n- cli_readn: int cli_readn(int fd, void *buff, unsigned int count) /* <=== cli_readn */ \n{\n        int retval;\n        unsigned int todo;\n        unsigned char *current;\n\n\n        todo = count;\n        current = (unsigned char *) buff;\n\n        do {\n                retval = read(fd, current, todo);\n                if (retval == 0) {\n                        return (count - todo);\n                }\n                if (retval < 0) {\n\t\t\tchar err[128];\n\t\t\tif (errno == EINTR) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcli_errmsg(\"cli_readn: read error: %s\\n\", cli_strerror(errno, err, sizeof(err)));\n                        return -1;\n                }\n                todo -= retval;\n                current += retval;\n        } while (todo > 0);\n\n\n        return count;\n}\n- QTM_RESTORE_BITS: #define QTM_RESTORE_BITS do {                                               \\ /* <=== libclamav/mspack.c:1569:1574:QTM_RESTORE_BITS:0 */ \n  i_ptr      = qtm->i_ptr;                                              \\\n  i_end      = qtm->i_end;                                              \\\n  bit_buffer = qtm->bit_buffer;                                         \\\n  bits_left  = qtm->bits_left;                                          \\\n} while (0)\n- qtm_read_input: static int qtm_read_input(struct qtm_stream *qtm) { /* <=== qtm_read_input */ \n  int nread = qtm->read_cb ? qtm->read_cb(qtm->file, &qtm->inbuf[0], (int)qtm->inbuf_size) : cli_readn(qtm->fd, &qtm->inbuf[0], (int)qtm->inbuf_size);\n  if (nread < 0) {\n    if (qtm->file->error == CL_BREAK)\n      return qtm->error = CL_BREAK;\n    else\n      return qtm->error = CL_EFORMAT;\n  }\n\n  qtm->i_ptr = &qtm->inbuf[0];\n  qtm->i_end = &qtm->inbuf[nread];\n  return CL_SUCCESS;\n}\n- QTM_READ_BITS: #define QTM_READ_BITS(val, bits) do {                                       \\ /* <=== libclamav/mspack.c:1594:1602:QTM_READ_BITS:2 */ \n  (val) = 0;                                                            \\\n  for (bits_needed = (bits); bits_needed > 0; bits_needed -= bit_run) { \\\n    QTM_FILL_BUFFER;                                                        \\\n    bit_run = (bits_left < bits_needed) ? bits_left : bits_needed;      \\\n    (val) = ((val) << bit_run) | QTM_PEEK_BITS(bit_run);                    \\\n    QTM_REMOVE_BITS(bit_run);                                               \\\n  }                                                                     \\\n} while (0)\n- cli_dbgmsg: #define cli_dbgmsg (!UNLIKELY(cli_debug_flag)) ? (void)0 : cli_dbgmsg_internal /* <=== libclamav/others.h:435:435:cli_dbgmsg:0 */ \n- mspack_write: static int mspack_write(int fd, const void *buff, unsigned int count, struct cab_file *file) /* <=== mspack_write */ \n{\n\tint ret;\n\n    if(file->max_size) {\n\tif(file->written_size >= file->max_size)\n\t    return CL_BREAK;\n\n\tif(file->written_size + count > file->max_size)\n\t    count = file->max_size - file->written_size;\n    }\n    if((ret = cli_writen(fd, buff, count)) > 0)\n\tfile->written_size += ret;\n\n    return (ret == -1) ? CL_EWRITE : CL_SUCCESS;\n}\n- QTM_GET_SYMBOL: #define QTM_GET_SYMBOL(model, var) do {                                     \\ /* <=== libclamav/mspack.c:1625:1655:QTM_GET_SYMBOL:2 */ \n  range = ((H - L) & 0xFFFF) + 1;                                       \\\n  symf = ((((C - L + 1) * model.syms[0].cumfreq)-1) / range) & 0xFFFF;  \\\n                                                                        \\\n  for (i = 1; i < model.entries; i++) {                                 \\\n    if (model.syms[i].cumfreq <= symf) break;                           \\\n  }                                                                     \\\n  (var) = model.syms[i-1].sym;                                          \\\n                                                                        \\\n  range = (H - L) + 1;                                                  \\\n  symf = model.syms[0].cumfreq;                                         \\\n  H = L + ((model.syms[i-1].cumfreq * range) / symf) - 1;               \\\n  L = L + ((model.syms[i].cumfreq   * range) / symf);                   \\\n                                                                        \\\n  do { model.syms[--i].cumfreq += 8; } while (i > 0);                   \\\n  if (model.syms[0].cumfreq > 3800) qtm_update_model(&model);          \\\n                                                                        \\\n  while (1) {                                                           \\\n    if ((L & 0x8000) != (H & 0x8000)) {                                 \\\n      if ((L & 0x4000) && !(H & 0x4000)) {                              \\\n        /* underflow case */                                            \\\n        C ^= 0x4000; L &= 0x3FFF; H |= 0x4000;                          \\\n      }                                                                 \\\n      else break;                                                       \\\n    }                                                                   \\\n    L <<= 1; H = (H << 1) | 1;                                          \\\n    QTM_FILL_BUFFER;                                                        \\\n    C  = (C << 1) | QTM_PEEK_BITS(1);                                       \\\n    QTM_REMOVE_BITS(1);                                                     \\\n  }                                                                     \\\n} while (0)\n- qtm_update_model: static void qtm_update_model(struct qtm_model *model) { /* <=== qtm_update_model */ \n  struct qtm_modelsym tmp;\n  int i, j;\n\n  if (--model->shiftsleft) {\n    for (i = model->entries - 1; i >= 0; i--) {\n      /* -1, not -2; the 0 entry saves this */\n      model->syms[i].cumfreq >>= 1;\n      if (model->syms[i].cumfreq <= model->syms[i+1].cumfreq) {\n\tmodel->syms[i].cumfreq = model->syms[i+1].cumfreq + 1;\n      }\n    }\n  }\n  else {\n    model->shiftsleft = 50;\n    for (i = 0; i < model->entries; i++) {\n      /* no -1, want to include the 0 entry */\n      /* this converts cumfreqs into frequencies, then shifts right */\n      model->syms[i].cumfreq -= model->syms[i+1].cumfreq;\n      model->syms[i].cumfreq++; /* avoid losing things entirely */\n      model->syms[i].cumfreq >>= 1;\n    }\n\n    /* now sort by frequencies, decreasing order -- this must be an\n     * inplace selection sort, or a sort with the same (in)stability\n     * characteristics */\n    for (i = 0; i < model->entries - 1; i++) {\n      for (j = i + 1; j < model->entries; j++) {\n\tif (model->syms[i].cumfreq < model->syms[j].cumfreq) {\n\t  tmp = model->syms[i];\n\t  model->syms[i] = model->syms[j];\n\t  model->syms[j] = tmp;\n\t}\n      }\n    }\n\n    /* then convert frequencies back to cumfreq */\n    for (i = model->entries - 1; i >= 0; i--) {\n      model->syms[i].cumfreq += model->syms[i+1].cumfreq;\n    }\n  }\n}\n- cli_dbgmsg_internal: void cli_dbgmsg_internal(const char *str, ...) /* <=== cli_dbgmsg_internal */ \n{\n    MSGCODE(\"LibClamAV debug: \");\n}\n- QTM_STORE_BITS: #define QTM_STORE_BITS do {                                                 \\ /* <=== libclamav/mspack.c:1562:1567:QTM_STORE_BITS:0 */ \n  qtm->i_ptr      = i_ptr;                                              \\\n  qtm->i_end      = i_end;                                              \\\n  qtm->bit_buffer = bit_buffer;                                         \\\n  qtm->bits_left  = bits_left;                                          \\\n} while (0)\n\nType Definitions:\n- qtm_stream: struct qtm_stream {\n  int fd;                   /* input file descriptor */\n  int ofd;                  /* output file descriptor */\n\n  unsigned char *window;          /* decoding window                         */\n  unsigned int window_size;       /* window size                             */\n  unsigned int window_posn;       /* decompression offset within window      */\n  unsigned int frame_start;       /* start of current frame within window    */\n\n  unsigned short H, L, C;         /* high/low/current: arith coding state    */\n  unsigned char header_read;      /* have we started decoding a new frame?   */\n  unsigned char wflag;\t    /* write flag */\n\n  int error;\n\n  /* data tables */\n  unsigned int  position_base[42];\n  unsigned char extra_bits[42], length_base[27], length_extra[27];\n\n  /* four literal models, each representing 64 symbols\n   * model0 for literals from   0 to  63 (selector = 0)\n   * model1 for literals from  64 to 127 (selector = 1)\n   * model2 for literals from 128 to 191 (selector = 2)\n   * model3 for literals from 129 to 255 (selector = 3) */\n  struct qtm_model model0, model1, model2, model3;\n\n  /* three match models.\n   * model4 for match with fixed length of 3 bytes\n   * model5 for match with fixed length of 4 bytes\n   * model6 for variable length match, encoded with model6len model */\n  struct qtm_model model4, model5, model6, model6len;\n\n  /* selector model. 0-6 to say literal (0,1,2,3) or match (4,5,6) */\n  struct qtm_model model7;\n\n  /* symbol arrays for all models */\n  struct qtm_modelsym m0sym[64 + 1];\n  struct qtm_modelsym m1sym[64 + 1];\n  struct qtm_modelsym m2sym[64 + 1];\n  struct qtm_modelsym m3sym[64 + 1];\n  struct qtm_modelsym m4sym[24 + 1];\n  struct qtm_modelsym m5sym[36 + 1];\n  struct qtm_modelsym m6sym[42 + 1], m6lsym[27 + 1];\n  struct qtm_modelsym m7sym[7 + 1];\n\n  /* I/O buffers - 1*/\n  unsigned int  bit_buffer;\n\n  /* cabinet related stuff */\n  struct cab_file *file;\n  int (*read_cb)(struct cab_file *, unsigned char *, int);\n\n  /* I/O buffers - 2*/\n  unsigned char *inbuf, *i_ptr, *i_end, *o_ptr, *o_end;\n  unsigned int  inbuf_size;\n  unsigned char bits_left;\n\n}\n- qtm_model: struct qtm_model {\n  int shiftsleft, entries;\n  struct qtm_modelsym *syms;\n}\n- ANY: typedef struct {\n\tMD5_u32plus lo, hi;\n\tMD5_u32plus a, b, c, d;\n\tunsigned char buffer[64];\n\tMD5_u32plus block[16];\n}\n\nImports:\n- #include \"clamav.h\"\n- #include \"others.h\"\n- #include \"clamav-config.h\"\n- # include <limits.h>\n- #include <string.h>\n- #include \"mspack.h\"\n- #include <stdio.h>",
    "commit_msg": "libclamav/mspack.c: fix Quantum decompressor (bb#1771)",
    "cve_desc": "The qtm_decompress function in libclamav/mspack.c in ClamAV before 0.96 allows remote attackers to cause a denial of service (memory corruption and application crash) via a crafted CAB archive that uses the Quantum (aka .Q) compression format.  NOTE: some of these details are obtained from third party information.",
    "year": 2010,
    "filename": "mspack.c",
    "commit_url": "\"https://github.com/vrtadmin/clamav-devel/commit/224fee54dd6cd8933d7007331ec2bfca0398d4b4\""
  },
  {
    "repository": "samba-team/samba",
    "cve_id": "CVE-2010-1642",
    "cwe_list": [
      "CWE-119"
    ],
    "commit_hash": "9280051bfba337458722fb157f3082f93cbd9f2b",
    "short_hash": "9280051b",
    "vulnerableMethods_before": [
      {
        "filename": "source3/smbd/sesssetup.c",
        "method_name": "reply_sesssetup_and_X_spnego",
        "raw_code": "static void reply_sesssetup_and_X_spnego(struct smb_request *req) /* <=== reply_sesssetup_and_X_spnego */ \n{\n\tconst uint8 *p;\n\tDATA_BLOB blob1;\n\tsize_t bufrem;\n\tchar *tmp;\n\tconst char *native_os;\n\tconst char *native_lanman;\n\tconst char *primary_domain;\n\tconst char *p2;\n\tuint16 data_blob_len = SVAL(req->vwv+7, 0);\n\tenum remote_arch_types ra_type = get_remote_arch();\n\tint vuid = req->vuid;\n\tuser_struct *vuser = NULL;\n\tNTSTATUS status = NT_STATUS_OK;\n\tuint16 smbpid = req->smbpid;\n\tstruct smbd_server_connection *sconn = smbd_server_conn;\n\n\tDEBUG(3,(\"Doing spnego session setup\\n\"));\n\n\tif (global_client_caps == 0) {\n\t\tglobal_client_caps = IVAL(req->vwv+10, 0);\n\n\t\tif (!(global_client_caps & CAP_STATUS32)) {\n\t\t\tremove_from_common_flags2(FLAGS2_32_BIT_ERROR_CODES);\n\t\t}\n\n\t}\n\n\tp = req->buf;\n\n\tif (data_blob_len == 0) {\n\t\t/* an invalid request */\n\t\treply_nterror(req, nt_status_squash(NT_STATUS_LOGON_FAILURE));\n\t\treturn;\n\t}\n\n\tbufrem = smbreq_bufrem(req, p);\n\t/* pull the spnego blob */\n\tblob1 = data_blob(p, MIN(bufrem, data_blob_len));\n\n#if 0\n\tfile_save(\"negotiate.dat\", blob1.data, blob1.length);\n#endif\n\n\tp2 = (char *)req->buf + data_blob_len;\n\n\tp2 += srvstr_pull_req_talloc(talloc_tos(), req, &tmp, p2,\n\t\t\t\t     STR_TERMINATE);\n\tnative_os = tmp ? tmp : \"\";\n\n\tp2 += srvstr_pull_req_talloc(talloc_tos(), req, &tmp, p2,\n\t\t\t\t     STR_TERMINATE);\n\tnative_lanman = tmp ? tmp : \"\";\n\n\tp2 += srvstr_pull_req_talloc(talloc_tos(), req, &tmp, p2,\n\t\t\t\t     STR_TERMINATE);\n\tprimary_domain = tmp ? tmp : \"\";\n\n\tDEBUG(3,(\"NativeOS=[%s] NativeLanMan=[%s] PrimaryDomain=[%s]\\n\",\n\t\tnative_os, native_lanman, primary_domain));\n\n\tif ( ra_type == RA_WIN2K ) {\n\t\t/* Vista sets neither the OS or lanman strings */\n\n\t\tif ( !strlen(native_os) && !strlen(native_lanman) )\n\t\t\tset_remote_arch(RA_VISTA);\n\n\t\t/* Windows 2003 doesn't set the native lanman string,\n\t\t   but does set primary domain which is a bug I think */\n\n\t\tif ( !strlen(native_lanman) ) {\n\t\t\tra_lanman_string( primary_domain );\n\t\t} else {\n\t\t\tra_lanman_string( native_lanman );\n\t\t}\n\t}\n\n\t/* Did we get a valid vuid ? */\n\tif (!is_partial_auth_vuid(sconn, vuid)) {\n\t\t/* No, then try and see if this is an intermediate sessionsetup\n\t\t * for a large SPNEGO packet. */\n\t\tstruct pending_auth_data *pad;\n\t\tpad = get_pending_auth_data(sconn, smbpid);\n\t\tif (pad) {\n\t\t\tDEBUG(10,(\"reply_sesssetup_and_X_spnego: found \"\n\t\t\t\t\"pending vuid %u\\n\",\n\t\t\t\t(unsigned int)pad->vuid ));\n\t\t\tvuid = pad->vuid;\n\t\t}\n\t}\n\n\t/* Do we have a valid vuid now ? */\n\tif (!is_partial_auth_vuid(sconn, vuid)) {\n\t\t/* No, start a new authentication setup. */\n\t\tvuid = register_initial_vuid(sconn);\n\t\tif (vuid == UID_FIELD_INVALID) {\n\t\t\tdata_blob_free(&blob1);\n\t\t\treply_nterror(req, nt_status_squash(\n\t\t\t\t\t      NT_STATUS_INVALID_PARAMETER));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tvuser = get_partial_auth_user_struct(sconn, vuid);\n\t/* This MUST be valid. */\n\tif (!vuser) {\n\t\tsmb_panic(\"reply_sesssetup_and_X_spnego: invalid vuid.\");\n\t}\n\n\t/* Large (greater than 4k) SPNEGO blobs are split into multiple\n\t * sessionsetup requests as the Windows limit on the security blob\n\t * field is 4k. Bug #4400. JRA.\n\t */\n\n\tstatus = check_spnego_blob_complete(sconn, smbpid, vuid, &blob1);\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\tif (!NT_STATUS_EQUAL(status,\n\t\t\t\tNT_STATUS_MORE_PROCESSING_REQUIRED)) {\n\t\t\t/* Real error - kill the intermediate vuid */\n\t\t\tinvalidate_vuid(sconn, vuid);\n\t\t}\n\t\tdata_blob_free(&blob1);\n\t\treply_nterror(req, nt_status_squash(status));\n\t\treturn;\n\t}\n\n\tif (blob1.data[0] == ASN1_APPLICATION(0)) {\n\n\t\t/* its a negTokenTarg packet */\n\n\t\treply_spnego_negotiate(req, vuid, blob1,\n\t\t\t\t       &vuser->auth_ntlmssp_state);\n\t\tdata_blob_free(&blob1);\n\t\treturn;\n\t}\n\n\tif (blob1.data[0] == ASN1_CONTEXT(1)) {\n\n\t\t/* its a auth packet */\n\n\t\treply_spnego_auth(req, vuid, blob1,\n\t\t\t\t  &vuser->auth_ntlmssp_state);\n\t\tdata_blob_free(&blob1);\n\t\treturn;\n\t}\n\n\tif (strncmp((char *)(blob1.data), \"NTLMSSP\", 7) == 0) {\n\t\tDATA_BLOB chal;\n\n\t\tif (!vuser->auth_ntlmssp_state) {\n\t\t\tstatus = auth_ntlmssp_start(&vuser->auth_ntlmssp_state);\n\t\t\tif (!NT_STATUS_IS_OK(status)) {\n\t\t\t\t/* Kill the intermediate vuid */\n\t\t\t\tinvalidate_vuid(sconn, vuid);\n\t\t\t\tdata_blob_free(&blob1);\n\t\t\t\treply_nterror(req, nt_status_squash(status));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tstatus = auth_ntlmssp_update(vuser->auth_ntlmssp_state,\n\t\t\t\t\t\tblob1, &chal);\n\n\t\tdata_blob_free(&blob1);\n\n\t\treply_spnego_ntlmssp(req, vuid,\n\t\t\t\t     &vuser->auth_ntlmssp_state,\n\t\t\t\t     &chal, status, OID_NTLMSSP, false);\n\t\tdata_blob_free(&chal);\n\t\treturn;\n\t}\n\n\t/* what sort of packet is this? */\n\tDEBUG(1,(\"Unknown packet in reply_sesssetup_and_X_spnego\\n\"));\n\n\tdata_blob_free(&blob1);\n\n\treply_nterror(req, nt_status_squash(NT_STATUS_LOGON_FAILURE));\n}",
        "start_line": 1171
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "source3/smbd/sesssetup.c",
        "method_name": "reply_sesssetup_and_X_spnego",
        "raw_code": "static void reply_sesssetup_and_X_spnego(struct smb_request *req) /* <=== reply_sesssetup_and_X_spnego */ \n{\n\tconst uint8 *p;\n\tDATA_BLOB blob1;\n\tsize_t bufrem;\n\tchar *tmp;\n\tconst char *native_os;\n\tconst char *native_lanman;\n\tconst char *primary_domain;\n\tconst char *p2;\n\tuint16 data_blob_len = SVAL(req->vwv+7, 0);\n\tenum remote_arch_types ra_type = get_remote_arch();\n\tint vuid = req->vuid;\n\tuser_struct *vuser = NULL;\n\tNTSTATUS status = NT_STATUS_OK;\n\tuint16 smbpid = req->smbpid;\n\tstruct smbd_server_connection *sconn = smbd_server_conn;\n\n\tDEBUG(3,(\"Doing spnego session setup\\n\"));\n\n\tif (global_client_caps == 0) {\n\t\tglobal_client_caps = IVAL(req->vwv+10, 0);\n\n\t\tif (!(global_client_caps & CAP_STATUS32)) {\n\t\t\tremove_from_common_flags2(FLAGS2_32_BIT_ERROR_CODES);\n\t\t}\n\n\t}\n\n\tp = req->buf;\n\n\tif (data_blob_len == 0) {\n\t\t/* an invalid request */\n\t\treply_nterror(req, nt_status_squash(NT_STATUS_LOGON_FAILURE));\n\t\treturn;\n\t}\n\n\tbufrem = smbreq_bufrem(req, p);\n\t/* pull the spnego blob */\n\tblob1 = data_blob(p, MIN(bufrem, data_blob_len));\n\n#if 0\n\tfile_save(\"negotiate.dat\", blob1.data, blob1.length);\n#endif\n\n\tp2 = (char *)req->buf + blob1.length;\n\n\tp2 += srvstr_pull_req_talloc(talloc_tos(), req, &tmp, p2,\n\t\t\t\t     STR_TERMINATE);\n\tnative_os = tmp ? tmp : \"\";\n\n\tp2 += srvstr_pull_req_talloc(talloc_tos(), req, &tmp, p2,\n\t\t\t\t     STR_TERMINATE);\n\tnative_lanman = tmp ? tmp : \"\";\n\n\tp2 += srvstr_pull_req_talloc(talloc_tos(), req, &tmp, p2,\n\t\t\t\t     STR_TERMINATE);\n\tprimary_domain = tmp ? tmp : \"\";\n\n\tDEBUG(3,(\"NativeOS=[%s] NativeLanMan=[%s] PrimaryDomain=[%s]\\n\",\n\t\tnative_os, native_lanman, primary_domain));\n\n\tif ( ra_type == RA_WIN2K ) {\n\t\t/* Vista sets neither the OS or lanman strings */\n\n\t\tif ( !strlen(native_os) && !strlen(native_lanman) )\n\t\t\tset_remote_arch(RA_VISTA);\n\n\t\t/* Windows 2003 doesn't set the native lanman string,\n\t\t   but does set primary domain which is a bug I think */\n\n\t\tif ( !strlen(native_lanman) ) {\n\t\t\tra_lanman_string( primary_domain );\n\t\t} else {\n\t\t\tra_lanman_string( native_lanman );\n\t\t}\n\t}\n\n\t/* Did we get a valid vuid ? */\n\tif (!is_partial_auth_vuid(sconn, vuid)) {\n\t\t/* No, then try and see if this is an intermediate sessionsetup\n\t\t * for a large SPNEGO packet. */\n\t\tstruct pending_auth_data *pad;\n\t\tpad = get_pending_auth_data(sconn, smbpid);\n\t\tif (pad) {\n\t\t\tDEBUG(10,(\"reply_sesssetup_and_X_spnego: found \"\n\t\t\t\t\"pending vuid %u\\n\",\n\t\t\t\t(unsigned int)pad->vuid ));\n\t\t\tvuid = pad->vuid;\n\t\t}\n\t}\n\n\t/* Do we have a valid vuid now ? */\n\tif (!is_partial_auth_vuid(sconn, vuid)) {\n\t\t/* No, start a new authentication setup. */\n\t\tvuid = register_initial_vuid(sconn);\n\t\tif (vuid == UID_FIELD_INVALID) {\n\t\t\tdata_blob_free(&blob1);\n\t\t\treply_nterror(req, nt_status_squash(\n\t\t\t\t\t      NT_STATUS_INVALID_PARAMETER));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tvuser = get_partial_auth_user_struct(sconn, vuid);\n\t/* This MUST be valid. */\n\tif (!vuser) {\n\t\tsmb_panic(\"reply_sesssetup_and_X_spnego: invalid vuid.\");\n\t}\n\n\t/* Large (greater than 4k) SPNEGO blobs are split into multiple\n\t * sessionsetup requests as the Windows limit on the security blob\n\t * field is 4k. Bug #4400. JRA.\n\t */\n\n\tstatus = check_spnego_blob_complete(sconn, smbpid, vuid, &blob1);\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\tif (!NT_STATUS_EQUAL(status,\n\t\t\t\tNT_STATUS_MORE_PROCESSING_REQUIRED)) {\n\t\t\t/* Real error - kill the intermediate vuid */\n\t\t\tinvalidate_vuid(sconn, vuid);\n\t\t}\n\t\tdata_blob_free(&blob1);\n\t\treply_nterror(req, nt_status_squash(status));\n\t\treturn;\n\t}\n\n\tif (blob1.data[0] == ASN1_APPLICATION(0)) {\n\n\t\t/* its a negTokenTarg packet */\n\n\t\treply_spnego_negotiate(req, vuid, blob1,\n\t\t\t\t       &vuser->auth_ntlmssp_state);\n\t\tdata_blob_free(&blob1);\n\t\treturn;\n\t}\n\n\tif (blob1.data[0] == ASN1_CONTEXT(1)) {\n\n\t\t/* its a auth packet */\n\n\t\treply_spnego_auth(req, vuid, blob1,\n\t\t\t\t  &vuser->auth_ntlmssp_state);\n\t\tdata_blob_free(&blob1);\n\t\treturn;\n\t}\n\n\tif (strncmp((char *)(blob1.data), \"NTLMSSP\", 7) == 0) {\n\t\tDATA_BLOB chal;\n\n\t\tif (!vuser->auth_ntlmssp_state) {\n\t\t\tstatus = auth_ntlmssp_start(&vuser->auth_ntlmssp_state);\n\t\t\tif (!NT_STATUS_IS_OK(status)) {\n\t\t\t\t/* Kill the intermediate vuid */\n\t\t\t\tinvalidate_vuid(sconn, vuid);\n\t\t\t\tdata_blob_free(&blob1);\n\t\t\t\treply_nterror(req, nt_status_squash(status));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tstatus = auth_ntlmssp_update(vuser->auth_ntlmssp_state,\n\t\t\t\t\t\tblob1, &chal);\n\n\t\tdata_blob_free(&blob1);\n\n\t\treply_spnego_ntlmssp(req, vuid,\n\t\t\t\t     &vuser->auth_ntlmssp_state,\n\t\t\t\t     &chal, status, OID_NTLMSSP, false);\n\t\tdata_blob_free(&chal);\n\t\treturn;\n\t}\n\n\t/* what sort of packet is this? */\n\tDEBUG(1,(\"Unknown packet in reply_sesssetup_and_X_spnego\\n\"));\n\n\tdata_blob_free(&blob1);\n\n\treply_nterror(req, nt_status_squash(NT_STATUS_LOGON_FAILURE));\n}",
        "start_line": 1171
      }
    ],
    "code_context": "Called Methods:\n- spnego_gen_auth_response: DATA_BLOB spnego_gen_auth_response(DATA_BLOB *reply, NTSTATUS nt_status, /* <=== spnego_gen_auth_response */ \n\t\t\t\t   const char *mechOID);\n- increment_next_vuid: static void increment_next_vuid(uint16_t *vuid) /* <=== increment_next_vuid */ \n{\n\t*vuid += 1;\n\n\t/* Check for vuid wrap. */\n\tif (*vuid == UID_FIELD_INVALID) {\n\t\t*vuid = VUID_OFFSET;\n\t}\n}\n- session_yield: void session_yield(user_struct *vuser); /* <=== session_yield */ \n- ra_lanman_string: void ra_lanman_string( const char *native_lanman ) /* <=== ra_lanman_string */ \n{\n\tif ( strcmp( native_lanman, \"Windows 2002 5.1\" ) == 0 )\n\t\tset_remote_arch( RA_WINXP );\n\telse if ( strcmp( native_lanman, \"Windows XP 5.2\" ) == 0 )\n\t\tset_remote_arch( RA_WINXP64 );\n\telse if ( strcmp( native_lanman, \"Windows Server 2003 5.2\" ) == 0 )\n\t\tset_remote_arch( RA_WIN2K3 );\n}\n- parse_spnego_mechanisms: NTSTATUS parse_spnego_mechanisms(DATA_BLOB blob_in, /* <=== parse_spnego_mechanisms */ \n\t\tDATA_BLOB *pblob_out,\n\t\tchar **kerb_mechOID)\n{\n\tchar *OIDs[ASN1_MAX_OIDS];\n\tint i;\n\tNTSTATUS ret = NT_STATUS_OK;\n\n\t*kerb_mechOID = NULL;\n\n\t/* parse out the OIDs and the first sec blob */\n\tif (!parse_negTokenTarg(blob_in, OIDs, pblob_out)) {\n\t\treturn NT_STATUS_LOGON_FAILURE;\n\t}\n\n\t/* only look at the first OID for determining the mechToken --\n\t   according to RFC2478, we should choose the one we want\n\t   and renegotiate, but i smell a client bug here..\n\n\t   Problem observed when connecting to a member (samba box)\n\t   of an AD domain as a user in a Samba domain.  Samba member\n\t   server sent back krb5/mskrb5/ntlmssp as mechtypes, but the\n\t   client (2ksp3) replied with ntlmssp/mskrb5/krb5 and an\n\t   NTLMSSP mechtoken.                 --jerry              */\n\n#ifdef HAVE_KRB5\n\tif (strcmp(OID_KERBEROS5, OIDs[0]) == 0 ||\n\t    strcmp(OID_KERBEROS5_OLD, OIDs[0]) == 0) {\n\t\t*kerb_mechOID = SMB_STRDUP(OIDs[0]);\n\t\tif (*kerb_mechOID == NULL) {\n\t\t\tret = NT_STATUS_NO_MEMORY;\n\t\t}\n\t}\n#endif\n\n\tfor (i=0;OIDs[i];i++) {\n\t\tDEBUG(5,(\"parse_spnego_mechanisms: Got OID %s\\n\", OIDs[i]));\n\t\ttalloc_free(OIDs[i]);\n\t}\n\treturn ret;\n}\n- nt_status_squash: NTSTATUS nt_status_squash(NTSTATUS nt_status) /* <=== nt_status_squash */ \n{\n\tif NT_STATUS_IS_OK(nt_status) {\n\t\treturn nt_status;\t\t\n\t} else if NT_STATUS_EQUAL(nt_status, NT_STATUS_NO_SUCH_USER) {\n\t\t/* Match WinXP and don't give the game away */\n\t\treturn NT_STATUS_LOGON_FAILURE;\n\t\t\n\t} else if NT_STATUS_EQUAL(nt_status, NT_STATUS_WRONG_PASSWORD) {\n\t\t/* Match WinXP and don't give the game away */\n\t\treturn NT_STATUS_LOGON_FAILURE;\n\t} else {\n\t\treturn nt_status;\n\t}  \n}\n- set_remote_arch: void set_remote_arch(enum remote_arch_types type) /* <=== set_remote_arch */ \n{\n\tra_type = type;\n\tswitch( type ) {\n\tcase RA_WFWG:\n\t\tremote_arch_str = \"WfWg\";\n\t\tbreak;\n\tcase RA_OS2:\n\t\tremote_arch_str = \"OS2\";\n\t\tbreak;\n\tcase RA_WIN95:\n\t\tremote_arch_str = \"Win95\";\n\t\tbreak;\n\tcase RA_WINNT:\n\t\tremote_arch_str = \"WinNT\";\n\t\tbreak;\n\tcase RA_WIN2K:\n\t\tremote_arch_str = \"Win2K\";\n\t\tbreak;\n\tcase RA_WINXP:\n\t\tremote_arch_str = \"WinXP\";\n\t\tbreak;\n\tcase RA_WINXP64:\n\t\tremote_arch_str = \"WinXP64\";\n\t\tbreak;\n\tcase RA_WIN2K3:\n\t\tremote_arch_str = \"Win2K3\";\n\t\tbreak;\n\tcase RA_VISTA:\n\t\tremote_arch_str = \"Vista\";\n\t\tbreak;\n\tcase RA_SAMBA:\n\t\tremote_arch_str = \"Samba\";\n\t\tbreak;\n\tcase RA_CIFSFS:\n\t\tremote_arch_str = \"CIFSFS\";\n\t\tbreak;\n\tdefault:\n\t\tra_type = RA_UNKNOWN;\n\t\tremote_arch_str = \"UNKNOWN\";\n\t\tbreak;\n\t}\n\n\tDEBUG(10,(\"set_remote_arch: Client arch is \\'%s\\'\\n\",\n\t\t\t\tremote_arch_str));\n}\n- ASN1_APPLICATION: #define ASN1_APPLICATION(x) ((x)+0x60) /* <=== lib/util/asn1.h:39:39:ASN1_APPLICATION:1 */ \n- VUID_OFFSET: #define VUID_OFFSET 100 /* Amount to bias returned vuid numbers */ /* <=== source3/include/smb.h:1609:1609:VUID_OFFSET:0 */ \n- _talloc_free: int _talloc_free(void *ptr, const char *location); /* <=== _talloc_free */ \n- SMB_MALLOC_P: #define SMB_MALLOC_P(type) (type *)malloc(sizeof(type)) /* <=== source3/include/smb_macros.h:312:312:SMB_MALLOC_P:1 */ \n- IVAL: #define IVAL(buf,pos) (SVAL(buf,pos)|SVAL(buf,(pos)+2)<<16) /* <=== lib/util/byteorder.h:167:167:IVAL:2 */ \n- lp_panic_action: char *lp_panic_action(void); /* <=== lp_panic_action */ \n- SMB_THREAD_GET_TLS: #define SMB_THREAD_GET_TLS(key) \\ /* <=== lib/util/smb_threads_internal.h:63:64:SMB_THREAD_GET_TLS:1 */ \n\t(global_tfp ? global_tfp->get_tls((key), __location__) : (key))\n- reply_spnego_downgrade_to_ntlmssp: static void reply_spnego_downgrade_to_ntlmssp(struct smb_request *req, /* <=== reply_spnego_downgrade_to_ntlmssp */ \n\t\t\t\t\t\tuint16 vuid)\n{\n\tDATA_BLOB response;\n\n\treply_outbuf(req, 4, 0);\n        SSVAL(req->outbuf,smb_uid,vuid);\n\n\tDEBUG(3,(\"reply_spnego_downgrade_to_ntlmssp: Got krb5 ticket in SPNEGO \"\n\t\t\"but set to downgrade to NTLMSSP\\n\"));\n\n\tresponse = spnego_gen_auth_response(NULL,\n\t\t\tNT_STATUS_MORE_PROCESSING_REQUIRED,\n\t\t\tOID_NTLMSSP);\n\treply_sesssetup_blob(req, response, NT_STATUS_MORE_PROCESSING_REQUIRED);\n\tdata_blob_free(&response);\n}\n- reply_nterror: #define reply_nterror(req,status) reply_nt_error(req,status,__LINE__,__FILE__) /* <=== source3/include/smb_macros.h:114:114:reply_nterror:2 */ \n- smbreq_bufrem: #define smbreq_bufrem(req, p) (req->buflen - PTR_DIFF(p, req->buf)) /* <=== source3/include/smb_macros.h:132:132:smbreq_bufrem:2 */ \n- false: #define false (0) /* <=== lib/replace/replace.h:579:579:false:0 */ \n- reply_outbuf: void reply_outbuf(struct smb_request *req, uint8 num_words, uint32 num_bytes); /* <=== reply_outbuf */ \n- UID_FIELD_INVALID: #define UID_FIELD_INVALID 0 /* <=== source3/include/smb.h:1608:1608:UID_FIELD_INVALID:0 */ \n- data_blob: #define data_blob(ptr, size) data_blob_named(ptr, size, \"DATA_BLOB: \"__location__) /* <=== lib/util/data_blob.h:48:48:data_blob:2 */ \n- get_partial_auth_user_struct: user_struct *get_partial_auth_user_struct(struct smbd_server_connection *sconn, /* <=== get_partial_auth_user_struct */ \n\t\t\t\t\t  uint16 vuid)\n{\n\treturn get_valid_user_struct_internal(sconn, vuid,\n\t\t\tSERVER_ALLOCATED_REQUIRED_NO);\n}\n- NT_STATUS_EQUAL: #define NT_STATUS_EQUAL(x,y) (NT_STATUS_V(x) == NT_STATUS_V(y)) /* <=== libcli/util/ntstatus.h:647:647:NT_STATUS_EQUAL:2 */ \n- register_existing_vuid: int register_existing_vuid(struct smbd_server_connection *sconn, /* <=== register_existing_vuid */ \n\t\t\tuint16 vuid,\n\t\t\tauth_serversupplied_info *server_info,\n\t\t\tDATA_BLOB response_blob,\n\t\t\tconst char *smb_name)\n{\n\tfstring tmp;\n\tuser_struct *vuser;\n\n\tvuser = get_partial_auth_user_struct(sconn, vuid);\n\tif (!vuser) {\n\t\tgoto fail;\n\t}\n\n\t/* Use this to keep tabs on all our info from the authentication */\n\tvuser->server_info = talloc_move(vuser, &server_info);\n\n\t/* This is a potentially untrusted username */\n\talpha_strcpy(tmp, smb_name, \". _-$\", sizeof(tmp));\n\n\tvuser->server_info->sanitized_username = talloc_strdup(\n\t\tvuser->server_info, tmp);\n\n\tDEBUG(10,(\"register_existing_vuid: (%u,%u) %s %s %s guest=%d\\n\",\n\t\t  (unsigned int)vuser->server_info->utok.uid,\n\t\t  (unsigned int)vuser->server_info->utok.gid,\n\t\t  vuser->server_info->unix_name,\n\t\t  vuser->server_info->sanitized_username,\n\t\t  pdb_get_domain(vuser->server_info->sam_account),\n\t\t  vuser->server_info->guest ));\n\n\tDEBUG(3, (\"register_existing_vuid: User name: %s\\t\"\n\t\t  \"Real name: %s\\n\", vuser->server_info->unix_name,\n\t\t  pdb_get_fullname(vuser->server_info->sam_account)));\n\n\tif (!vuser->server_info->ptok) {\n\t\tDEBUG(1, (\"register_existing_vuid: server_info does not \"\n\t\t\t\"contain a user_token - cannot continue\\n\"));\n\t\tgoto fail;\n\t}\n\n\tDEBUG(3,(\"register_existing_vuid: UNIX uid %d is UNIX user %s, \"\n\t\t\"and will be vuid %u\\n\", (int)vuser->server_info->utok.uid,\n\t\t vuser->server_info->unix_name, vuser->vuid));\n\n\tif (!session_claim(vuser)) {\n\t\tDEBUG(1, (\"register_existing_vuid: Failed to claim session \"\n\t\t\t\"for vuid=%d\\n\",\n\t\t\tvuser->vuid));\n\t\tgoto fail;\n\t}\n\n\t/* Register a home dir service for this user if\n\t(a) This is not a guest connection,\n\t(b) we have a home directory defined\n\t(c) there s not an existing static share by that name\n\tIf a share exists by this name (autoloaded or not) reuse it . */\n\n\tvuser->homes_snum = -1;\n\n\tif (!vuser->server_info->guest) {\n\t\tvuser->homes_snum = register_homes_share(\n\t\t\tvuser->server_info->unix_name);\n\t}\n\n\tif (srv_is_signing_negotiated(smbd_server_conn) &&\n\t    !vuser->server_info->guest) {\n\t\t/* Try and turn on server signing on the first non-guest\n\t\t * sessionsetup. */\n\t\tsrv_set_signing(smbd_server_conn,\n\t\t\t\tvuser->server_info->user_session_key,\n\t\t\t\tresponse_blob);\n\t}\n\n\t/* fill in the current_user_info struct */\n\tset_current_user_info(\n\t\tvuser->server_info->sanitized_username,\n\t\tvuser->server_info->unix_name,\n\t\tpdb_get_domain(vuser->server_info->sam_account));\n\n\treturn vuser->vuid;\n\n  fail:\n\n\tif (vuser) {\n\t\tinvalidate_vuid(sconn, vuid);\n\t}\n\treturn UID_FIELD_INVALID;\n}\n- reply_sesssetup_blob: static void reply_sesssetup_blob(struct smb_request *req, /* <=== reply_sesssetup_blob */ \n\t\t\t\t DATA_BLOB blob,\n\t\t\t\t NTSTATUS nt_status)\n{\n\tif (!NT_STATUS_IS_OK(nt_status) &&\n\t    !NT_STATUS_EQUAL(nt_status, NT_STATUS_MORE_PROCESSING_REQUIRED)) {\n\t\treply_nterror(req, nt_status_squash(nt_status));\n\t\treturn;\n\t}\n\n\tnt_status = nt_status_squash(nt_status);\n\tSIVAL(req->outbuf, smb_rcls, NT_STATUS_V(nt_status));\n\tSSVAL(req->outbuf, smb_vwv0, 0xFF); /* no chaining possible */\n\tSSVAL(req->outbuf, smb_vwv3, blob.length);\n\n\tif ((message_push_blob(&req->outbuf, blob) == -1)\n\t    || (push_signature(&req->outbuf) == -1)) {\n\t\treply_nterror(req, NT_STATUS_NO_MEMORY);\n\t}\n}\n- NT_STATUS_OK: #define NT_STATUS_OK NT_STATUS(0x0000) /* <=== libcli/util/ntstatus.h:86:86:NT_STATUS_OK:0 */ \n- pull_string_talloc_fn: size_t pull_string_talloc_fn(const char *function, /* <=== pull_string_talloc_fn */ \n\t\t\tunsigned int line,\n\t\t\tTALLOC_CTX *ctx,\n\t\t\tconst void *base_ptr,\n\t\t\tuint16 smb_flags2,\n\t\t\tchar **ppdest,\n\t\t\tconst void *src,\n\t\t\tsize_t src_len,\n\t\t\tint flags);\n- talloc_destroy: #define talloc_destroy(ctx) talloc_free(ctx) /* <=== source3/include/smb_macros.h:256:256:talloc_destroy:1 */ \n- data_blob_talloc: #define data_blob_talloc(ctx, ptr, size) data_blob_talloc_named(ctx, ptr, size, \"DATA_BLOB: \"__location__) /* <=== lib/util/data_blob.h:49:49:data_blob_talloc:3 */ \n- data_blob_talloc_named: _PUBLIC_ DATA_BLOB data_blob_talloc_named(TALLOC_CTX *mem_ctx, const void *p, size_t length, const char *name) /* <=== data_blob_talloc_named */ \n{\n\tDATA_BLOB ret = data_blob_named(p, length, name);\n\n\tif (ret.data) {\n\t\ttalloc_steal(mem_ctx, ret.data);\n\t}\n\treturn ret;\n}\n- get_valid_user_struct_internal: static user_struct *get_valid_user_struct_internal( /* <=== get_valid_user_struct_internal */ \n\t\t\tstruct smbd_server_connection *sconn,\n\t\t\tuint16 vuid,\n\t\t\tenum server_allocated_state server_allocated)\n{\n\tuser_struct *usp;\n\tint count=0;\n\n\tif (vuid == UID_FIELD_INVALID)\n\t\treturn NULL;\n\n\tusp=sconn->smb1.sessions.validated_users;\n\tfor (;usp;usp=usp->next,count++) {\n\t\tif (vuid == usp->vuid) {\n\t\t\tswitch (server_allocated) {\n\t\t\t\tcase SERVER_ALLOCATED_REQUIRED_YES:\n\t\t\t\t\tif (usp->server_info == NULL) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SERVER_ALLOCATED_REQUIRED_NO:\n\t\t\t\t\tif (usp->server_info != NULL) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\tcase SERVER_ALLOCATED_REQUIRED_ANY:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (count > 10) {\n\t\t\t\tDLIST_PROMOTE(sconn->smb1.sessions.validated_users,\n\t\t\t\t\t      usp);\n\t\t\t}\n\t\t\treturn usp;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n- reply_nt_error: void reply_nt_error(struct smb_request *req, NTSTATUS ntstatus, /* <=== reply_nt_error */ \n\t\t    int line, const char *file);\n- lp_security: int lp_security(void); /* <=== lp_security */ \n- dbghdrclass: bool dbghdrclass(int level, int cls, const char *location, const char *func); /* <=== dbghdrclass */ \n- True: #define True true /* <=== source3/include/smb.h:50:50:True:0 */ \n- ASN1_CONTEXT: #define ASN1_CONTEXT(x) ((x)+0xa0) /* <=== lib/util/asn1.h:42:42:ASN1_CONTEXT:1 */ \n- ntlmssp_update: NTSTATUS ntlmssp_update(NTLMSSP_STATE *ntlmssp_state,  /* <=== ntlmssp_update */ \n\t\t\tconst DATA_BLOB in, DATA_BLOB *out) ;\n- MIN: #define MIN(a,b) ((a)<(b)?(a):(b)) /* <=== lib/replace/replace.h:599:599:MIN:2 */ \n- do_map_to_guest: static NTSTATUS do_map_to_guest(NTSTATUS status, /* <=== do_map_to_guest */ \n\t\t\t\tauth_serversupplied_info **server_info,\n\t\t\t\tconst char *user, const char *domain)\n{\n\tif (NT_STATUS_EQUAL(status, NT_STATUS_NO_SUCH_USER)) {\n\t\tif ((lp_map_to_guest() == MAP_TO_GUEST_ON_BAD_USER) ||\n\t\t    (lp_map_to_guest() == MAP_TO_GUEST_ON_BAD_PASSWORD)) {\n\t\t\tDEBUG(3,(\"No such user %s [%s] - using guest account\\n\",\n\t\t\t\t user, domain));\n\t\t\tstatus = make_server_info_guest(NULL, server_info);\n\t\t}\n\t}\n\n\tif (NT_STATUS_EQUAL(status, NT_STATUS_WRONG_PASSWORD)) {\n\t\tif (lp_map_to_guest() == MAP_TO_GUEST_ON_BAD_PASSWORD) {\n\t\t\tDEBUG(3,(\"Registered username %s for guest access\\n\",\n\t\t\t\tuser));\n\t\t\tstatus = make_server_info_guest(NULL, server_info);\n\t\t}\n\t}\n\n\treturn status;\n}\n- talloc_zero: #define talloc_zero(ctx, type) (type *)_talloc_zero(ctx, sizeof(type), #type) /* <=== lib/talloc/talloc.h:96:96:talloc_zero:2 */ \n- reply_spnego_negotiate: static void reply_spnego_negotiate(struct smb_request *req, /* <=== reply_spnego_negotiate */ \n\t\t\t\t   uint16 vuid,\n\t\t\t\t   DATA_BLOB blob1,\n\t\t\t\t   AUTH_NTLMSSP_STATE **auth_ntlmssp_state)\n{\n\tDATA_BLOB secblob;\n\tDATA_BLOB chal;\n\tchar *kerb_mech = NULL;\n\tNTSTATUS status;\n\tstruct smbd_server_connection *sconn = smbd_server_conn;\n\n\tstatus = parse_spnego_mechanisms(blob1, &secblob, &kerb_mech);\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\t/* Kill the intermediate vuid */\n\t\tinvalidate_vuid(sconn, vuid);\n\t\treply_nterror(req, nt_status_squash(status));\n\t\treturn;\n\t}\n\n\tDEBUG(3,(\"reply_spnego_negotiate: Got secblob of size %lu\\n\",\n\t\t\t\t(unsigned long)secblob.length));\n\n#ifdef HAVE_KRB5\n\tif (kerb_mech && ((lp_security()==SEC_ADS) ||\n\t\t\t\tUSE_KERBEROS_KEYTAB) ) {\n\t\tbool destroy_vuid = True;\n\t\treply_spnego_kerberos(req, &secblob, kerb_mech,\n\t\t\t\t      vuid, &destroy_vuid);\n\t\tdata_blob_free(&secblob);\n\t\tif (destroy_vuid) {\n\t\t\t/* Kill the intermediate vuid */\n\t\t\tinvalidate_vuid(sconn, vuid);\n\t\t}\n\t\tSAFE_FREE(kerb_mech);\n\t\treturn;\n\t}\n#endif\n\n\tif (*auth_ntlmssp_state) {\n\t\tauth_ntlmssp_end(auth_ntlmssp_state);\n\t}\n\n\tif (kerb_mech) {\n\t\tdata_blob_free(&secblob);\n\t\t/* The mechtoken is a krb5 ticket, but\n\t\t * we need to fall back to NTLM. */\n\t\treply_spnego_downgrade_to_ntlmssp(req, vuid);\n\t\tSAFE_FREE(kerb_mech);\n\t\treturn;\n\t}\n\n\tstatus = auth_ntlmssp_start(auth_ntlmssp_state);\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\t/* Kill the intermediate vuid */\n\t\tinvalidate_vuid(sconn, vuid);\n\t\treply_nterror(req, nt_status_squash(status));\n\t\treturn;\n\t}\n\n\tstatus = auth_ntlmssp_update(*auth_ntlmssp_state,\n\t\t\t\t\tsecblob, &chal);\n\n\tdata_blob_free(&secblob);\n\n\treply_spnego_ntlmssp(req, vuid, auth_ntlmssp_state,\n\t\t\t     &chal, status, OID_NTLMSSP, true);\n\n\tdata_blob_free(&chal);\n\n\t/* already replied */\n\treturn;\n}\n- NT_STATUS_LOGON_FAILURE: #define NT_STATUS_LOGON_FAILURE NT_STATUS(0xC0000000 | 0x006d) /* <=== libcli/util/ntstatus.h:205:205:NT_STATUS_LOGON_FAILURE:0 */ \n- ntlmssp_server_start: NTSTATUS ntlmssp_server_start(NTLMSSP_STATE **ntlmssp_state); /* <=== ntlmssp_server_start */ \n- check_spnego_blob_complete: static NTSTATUS check_spnego_blob_complete(struct smbd_server_connection *sconn, /* <=== check_spnego_blob_complete */ \n\t\t\t\t\t   uint16 smbpid, uint16 vuid,\n\t\t\t\t\t   DATA_BLOB *pblob)\n{\n\tstruct pending_auth_data *pad = NULL;\n\tASN1_DATA *data;\n\tsize_t needed_len = 0;\n\n\tpad = get_pending_auth_data(sconn, smbpid);\n\n\t/* Ensure we have some data. */\n\tif (pblob->length == 0) {\n\t\t/* Caller can cope. */\n\t\tDEBUG(2,(\"check_spnego_blob_complete: zero blob length !\\n\"));\n\t\tdelete_partial_auth(sconn, pad);\n\t\treturn NT_STATUS_OK;\n\t}\n\n\t/* Were we waiting for more data ? */\n\tif (pad) {\n\t\tDATA_BLOB tmp_blob;\n\t\tsize_t copy_len = MIN(65536, pblob->length);\n\n\t\t/* Integer wrap paranoia.... */\n\n\t\tif (pad->partial_data.length + copy_len <\n\t\t\t\tpad->partial_data.length ||\n\t\t    pad->partial_data.length + copy_len < copy_len) {\n\n\t\t\tDEBUG(2,(\"check_spnego_blob_complete: integer wrap \"\n\t\t\t\t\"pad->partial_data.length = %u, \"\n\t\t\t\t\"copy_len = %u\\n\",\n\t\t\t\t(unsigned int)pad->partial_data.length,\n\t\t\t\t(unsigned int)copy_len ));\n\n\t\t\tdelete_partial_auth(sconn, pad);\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\n\t\tDEBUG(10,(\"check_spnego_blob_complete: \"\n\t\t\t\"pad->partial_data.length = %u, \"\n\t\t\t\"pad->needed_len = %u, \"\n\t\t\t\"copy_len = %u, \"\n\t\t\t\"pblob->length = %u,\\n\",\n\t\t\t(unsigned int)pad->partial_data.length,\n\t\t\t(unsigned int)pad->needed_len,\n\t\t\t(unsigned int)copy_len,\n\t\t\t(unsigned int)pblob->length ));\n\n\t\ttmp_blob = data_blob(NULL,\n\t\t\t\tpad->partial_data.length + copy_len);\n\n\t\t/* Concatenate the two (up to copy_len) bytes. */\n\t\tmemcpy(tmp_blob.data,\n\t\t\tpad->partial_data.data,\n\t\t\tpad->partial_data.length);\n\t\tmemcpy(tmp_blob.data + pad->partial_data.length,\n\t\t\tpblob->data,\n\t\t\tcopy_len);\n\n\t\t/* Replace the partial data. */\n\t\tdata_blob_free(&pad->partial_data);\n\t\tpad->partial_data = tmp_blob;\n\t\tZERO_STRUCT(tmp_blob);\n\n\t\t/* Are we done ? */\n\t\tif (pblob->length >= pad->needed_len) {\n\t\t\t/* Yes, replace pblob. */\n\t\t\tdata_blob_free(pblob);\n\t\t\t*pblob = pad->partial_data;\n\t\t\tZERO_STRUCT(pad->partial_data);\n\t\t\tdelete_partial_auth(sconn, pad);\n\t\t\treturn NT_STATUS_OK;\n\t\t}\n\n\t\t/* Still need more data. */\n\t\tpad->needed_len -= copy_len;\n\t\treturn NT_STATUS_MORE_PROCESSING_REQUIRED;\n\t}\n\n\tif ((pblob->data[0] != ASN1_APPLICATION(0)) &&\n\t    (pblob->data[0] != ASN1_CONTEXT(1))) {\n\t\t/* Not something we can determine the\n\t\t * length of.\n\t\t */\n\t\treturn NT_STATUS_OK;\n\t}\n\n\t/* This is a new SPNEGO sessionsetup - see if\n\t * the data given in this blob is enough.\n\t */\n\n\tdata = asn1_init(NULL);\n\tif (data == NULL) {\n\t\treturn NT_STATUS_NO_MEMORY;\n\t}\n\n\tasn1_load(data, *pblob);\n\tasn1_start_tag(data, pblob->data[0]);\n\tif (data->has_error || data->nesting == NULL) {\n\t\tasn1_free(data);\n\t\t/* Let caller catch. */\n\t\treturn NT_STATUS_OK;\n\t}\n\n\t/* Integer wrap paranoia.... */\n\n\tif (data->nesting->taglen + data->nesting->start < data->nesting->taglen ||\n\t    data->nesting->taglen + data->nesting->start < data->nesting->start) {\n\n\t\tDEBUG(2,(\"check_spnego_blob_complete: integer wrap \"\n\t\t\t\"data.nesting->taglen = %u, \"\n\t\t\t\"data.nesting->start = %u\\n\",\n\t\t\t(unsigned int)data->nesting->taglen,\n\t\t\t(unsigned int)data->nesting->start ));\n\n\t\tasn1_free(data);\n\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t}\n\n\t/* Total length of the needed asn1 is the tag length\n\t * plus the current offset. */\n\n\tneeded_len = data->nesting->taglen + data->nesting->start;\n\tasn1_free(data);\n\n\tDEBUG(10,(\"check_spnego_blob_complete: needed_len = %u, \"\n\t\t\"pblob->length = %u\\n\",\n\t\t(unsigned int)needed_len,\n\t\t(unsigned int)pblob->length ));\n\n\tif (needed_len <= pblob->length) {\n\t\t/* Nothing to do - blob is complete. */\n\t\treturn NT_STATUS_OK;\n\t}\n\n\t/* Refuse the blob if it's bigger than 64k. */\n\tif (needed_len > 65536) {\n\t\tDEBUG(2,(\"check_spnego_blob_complete: needed_len \"\n\t\t\t\"too large (%u)\\n\",\n\t\t\t(unsigned int)needed_len ));\n\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t}\n\n\t/* We must store this blob until complete. */\n\tif (!(pad = SMB_MALLOC_P(struct pending_auth_data))) {\n\t\treturn NT_STATUS_NO_MEMORY;\n\t}\n\tpad->needed_len = needed_len - pblob->length;\n\tpad->partial_data = data_blob(pblob->data, pblob->length);\n\tif (pad->partial_data.data == NULL) {\n\t\tSAFE_FREE(pad);\n\t\treturn NT_STATUS_NO_MEMORY;\n\t}\n\tpad->smbpid = smbpid;\n\tpad->vuid = vuid;\n\tDLIST_ADD(sconn->smb1.pd_list, pad);\n\n\treturn NT_STATUS_MORE_PROCESSING_REQUIRED;\n}\n- data_blob_free: _PUBLIC_ void data_blob_free(DATA_BLOB *d) /* <=== data_blob_free */ \n{\n\tif (d) {\n\t\ttalloc_free(d->data);\n\t\td->data = NULL;\n\t\td->length = 0;\n\t}\n}\n- NT_STATUS_IS_OK: #define NT_STATUS_IS_OK(x) (likely(NT_STATUS_V(x) == 0)) /* <=== libcli/util/ntstatus.h:640:640:NT_STATUS_IS_OK:1 */ \n- data_blob_named: _PUBLIC_ DATA_BLOB data_blob_named(const void *p, size_t length, const char *name) /* <=== data_blob_named */ \n{\n\tDATA_BLOB ret;\n\n\tif (p == NULL && length == 0) {\n\t\tZERO_STRUCT(ret);\n\t\treturn ret;\n\t}\n\n\tif (p) {\n\t\tret.data = (uint8_t *)talloc_memdup(NULL, p, length);\n\t} else {\n\t\tret.data = talloc_array(NULL, uint8_t, length);\n\t}\n\tif (ret.data == NULL) {\n\t\tret.length = 0;\n\t\treturn ret;\n\t}\n\ttalloc_set_name_const(ret.data, name);\n\tret.length = length;\n\treturn ret;\n}\n- true: #define true (1) /* <=== lib/replace/replace.h:576:576:true:0 */ \n- _talloc_zero: void *_talloc_zero(const void *ctx, size_t size, const char *name); /* <=== _talloc_zero */ \n- uint16: #  define uint16 uint16_t /* <=== source3/include/includes.h:308:308:uint16:0 */ \n- is_partial_auth_vuid: bool is_partial_auth_vuid(struct smbd_server_connection *sconn, uint16 vuid) /* <=== is_partial_auth_vuid */ \n{\n\treturn (get_partial_auth_user_struct(sconn, vuid) != NULL);\n}\n- DEBUG: #define DEBUG( level, body ) \\ /* <=== source3/include/debug.h:208:214:DEBUG:2 */ \n  (void)( ((level) <= MAX_DEBUG_LEVEL) && \\\n           unlikely((DEBUGLEVEL_CLASS[ DBGC_CLASS ] >= (level))||  \\\n           (!DEBUGLEVEL_CLASS_ISSET[ DBGC_CLASS ] && \\\n            DEBUGLEVEL_CLASS[ DBGC_ALL   ] >= (level))  ) \\\n       && (dbghdrclass( level, DBGC_CLASS, __location__, FUNCTION_MACRO )) \\\n       && (dbgtext body) )\n- delete_partial_auth: static void delete_partial_auth(struct smbd_server_connection *sconn, /* <=== delete_partial_auth */ \n\t\t\t\tstruct pending_auth_data *pad)\n{\n\tif (!pad) {\n\t\treturn;\n\t}\n\tDLIST_REMOVE(sconn->smb1.pd_list, pad);\n\tdata_blob_free(&pad->partial_data);\n\tSAFE_FREE(pad);\n}\n- auth_ntlmssp_start: NTSTATUS auth_ntlmssp_start(AUTH_NTLMSSP_STATE **auth_ntlmssp_state) /* <=== auth_ntlmssp_start */ \n{\n\tNTSTATUS nt_status;\n\tTALLOC_CTX *mem_ctx;\n\n\tmem_ctx = talloc_init(\"AUTH NTLMSSP context\");\n\t\n\t*auth_ntlmssp_state = TALLOC_ZERO_P(mem_ctx, AUTH_NTLMSSP_STATE);\n\tif (!*auth_ntlmssp_state) {\n\t\tDEBUG(0,(\"auth_ntlmssp_start: talloc failed!\\n\"));\n\t\ttalloc_destroy(mem_ctx);\n\t\treturn NT_STATUS_NO_MEMORY;\n\t}\n\n\tZERO_STRUCTP(*auth_ntlmssp_state);\n\n\t(*auth_ntlmssp_state)->mem_ctx = mem_ctx;\n\n\tif (!NT_STATUS_IS_OK(nt_status = ntlmssp_server_start(&(*auth_ntlmssp_state)->ntlmssp_state))) {\n\t\treturn nt_status;\n\t}\n\n\tif (!NT_STATUS_IS_OK(nt_status = make_auth_context_subsystem(&(*auth_ntlmssp_state)->auth_context))) {\n\t\treturn nt_status;\n\t}\n\n\t(*auth_ntlmssp_state)->ntlmssp_state->auth_context = (*auth_ntlmssp_state);\n\t(*auth_ntlmssp_state)->ntlmssp_state->get_challenge = auth_ntlmssp_get_challenge;\n\t(*auth_ntlmssp_state)->ntlmssp_state->may_set_challenge = auth_ntlmssp_may_set_challenge;\n\t(*auth_ntlmssp_state)->ntlmssp_state->set_challenge = auth_ntlmssp_set_challenge;\n\t(*auth_ntlmssp_state)->ntlmssp_state->check_password = auth_ntlmssp_check_password;\n\t(*auth_ntlmssp_state)->ntlmssp_state->server_role = (enum server_types)lp_server_role();\n\n\treturn NT_STATUS_OK;\n}\n- reply_spnego_auth: static void reply_spnego_auth(struct smb_request *req, /* <=== reply_spnego_auth */ \n\t\t\t      uint16 vuid,\n\t\t\t      DATA_BLOB blob1,\n\t\t\t      AUTH_NTLMSSP_STATE **auth_ntlmssp_state)\n{\n\tDATA_BLOB auth = data_blob_null;\n\tDATA_BLOB auth_reply = data_blob_null;\n\tDATA_BLOB secblob = data_blob_null;\n\tNTSTATUS status = NT_STATUS_LOGON_FAILURE;\n\tstruct smbd_server_connection *sconn = smbd_server_conn;\n\n\tif (!spnego_parse_auth(blob1, &auth)) {\n#if 0\n\t\tfile_save(\"auth.dat\", blob1.data, blob1.length);\n#endif\n\t\t/* Kill the intermediate vuid */\n\t\tinvalidate_vuid(sconn, vuid);\n\n\t\treply_nterror(req, nt_status_squash(\n\t\t\t\t      NT_STATUS_LOGON_FAILURE));\n\t\treturn;\n\t}\n\n\tif (auth.data[0] == ASN1_APPLICATION(0)) {\n\t\t/* Might be a second negTokenTarg packet */\n\t\tchar *kerb_mech = NULL;\n\n\t\tstatus = parse_spnego_mechanisms(auth, &secblob, &kerb_mech);\n\n\t\tif (!NT_STATUS_IS_OK(status)) {\n\t\t\t/* Kill the intermediate vuid */\n\t\t\tinvalidate_vuid(sconn, vuid);\n\t\t\treply_nterror(req, nt_status_squash(status));\n\t\t\treturn;\n\t\t}\n\n\t\tDEBUG(3,(\"reply_spnego_auth: Got secblob of size %lu\\n\",\n\t\t\t\t(unsigned long)secblob.length));\n#ifdef HAVE_KRB5\n\t\tif (kerb_mech && ((lp_security()==SEC_ADS) ||\n\t\t\t\t\tUSE_KERBEROS_KEYTAB)) {\n\t\t\tbool destroy_vuid = True;\n\t\t\treply_spnego_kerberos(req, &secblob, kerb_mech,\n\t\t\t\t\t      vuid, &destroy_vuid);\n\t\t\tdata_blob_free(&secblob);\n\t\t\tdata_blob_free(&auth);\n\t\t\tif (destroy_vuid) {\n\t\t\t\t/* Kill the intermediate vuid */\n\t\t\t\tinvalidate_vuid(sconn, vuid);\n\t\t\t}\n\t\t\tSAFE_FREE(kerb_mech);\n\t\t\treturn;\n\t\t}\n#endif\n\t\t/* Can't blunder into NTLMSSP auth if we have\n\t\t * a krb5 ticket. */\n\n\t\tif (kerb_mech) {\n\t\t\t/* Kill the intermediate vuid */\n\t\t\tinvalidate_vuid(sconn, vuid);\n\t\t\tDEBUG(3,(\"reply_spnego_auth: network \"\n\t\t\t\t\"misconfiguration, client sent us a \"\n\t\t\t\t\"krb5 ticket and kerberos security \"\n\t\t\t\t\"not enabled\\n\"));\n\t\t\treply_nterror(req, nt_status_squash(\n\t\t\t\t\tNT_STATUS_LOGON_FAILURE));\n\t\t\tSAFE_FREE(kerb_mech);\n\t\t}\n\t}\n\n\t/* If we get here it wasn't a negTokenTarg auth packet. */\n\tdata_blob_free(&secblob);\n\n\tif (!*auth_ntlmssp_state) {\n\t\tstatus = auth_ntlmssp_start(auth_ntlmssp_state);\n\t\tif (!NT_STATUS_IS_OK(status)) {\n\t\t\t/* Kill the intermediate vuid */\n\t\t\tinvalidate_vuid(sconn, vuid);\n\t\t\treply_nterror(req, nt_status_squash(status));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tstatus = auth_ntlmssp_update(*auth_ntlmssp_state,\n\t\t\t\t\tauth, &auth_reply);\n\n\tdata_blob_free(&auth);\n\n\t/* Don't send the mechid as we've already sent this (RFC4178). */\n\n\treply_spnego_ntlmssp(req, vuid,\n\t\t\t     auth_ntlmssp_state,\n\t\t\t     &auth_reply, status, NULL, true);\n\n\tdata_blob_free(&auth_reply);\n\n\t/* and tell smbd that we have already replied to this packet */\n\treturn;\n}\n- TALLOC_ZERO_P: #define TALLOC_ZERO_P(ctx, type) (type *)_talloc_zero(ctx, sizeof(type), #type) /* <=== source3/include/smb_macros.h:247:247:TALLOC_ZERO_P:2 */ \n- srvstr_pull_req_talloc: #define srvstr_pull_req_talloc(ctx, req_, dest, src, flags) \\ /* <=== source3/include/srvstr.h:28:30:srvstr_pull_req_talloc:5 */ \n    pull_string_talloc(ctx, req_->inbuf, req_->flags2, dest, src, \\\n\t\t       smbreq_bufrem(req_, src), flags)\n- spnego_parse_auth: bool spnego_parse_auth(DATA_BLOB blob, DATA_BLOB *auth); /* <=== spnego_parse_auth */ \n- reply_spnego_ntlmssp: static void reply_spnego_ntlmssp(struct smb_request *req, /* <=== reply_spnego_ntlmssp */ \n\t\t\t\t uint16 vuid,\n\t\t\t\t AUTH_NTLMSSP_STATE **auth_ntlmssp_state,\n\t\t\t\t DATA_BLOB *ntlmssp_blob, NTSTATUS nt_status,\n\t\t\t\t const char *OID,\n\t\t\t\t bool wrap)\n{\n\tDATA_BLOB response;\n\tstruct auth_serversupplied_info *server_info = NULL;\n\tstruct smbd_server_connection *sconn = smbd_server_conn;\n\n\tif (NT_STATUS_IS_OK(nt_status)) {\n\t\tserver_info = (*auth_ntlmssp_state)->server_info;\n\t} else {\n\t\tnt_status = do_map_to_guest(nt_status,\n\t\t\t    &server_info,\n\t\t\t    (*auth_ntlmssp_state)->ntlmssp_state->user,\n\t\t\t    (*auth_ntlmssp_state)->ntlmssp_state->domain);\n\t}\n\n\treply_outbuf(req, 4, 0);\n\n\tSSVAL(req->outbuf, smb_uid, vuid);\n\n\tif (NT_STATUS_IS_OK(nt_status)) {\n\t\tDATA_BLOB nullblob = data_blob_null;\n\n\t\tif (!is_partial_auth_vuid(sconn, vuid)) {\n\t\t\tnt_status = NT_STATUS_LOGON_FAILURE;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdata_blob_free(&server_info->user_session_key);\n\t\tserver_info->user_session_key =\n\t\t\tdata_blob_talloc(\n\t\t\tserver_info,\n\t\t\t(*auth_ntlmssp_state)->ntlmssp_state->session_key.data,\n\t\t\t(*auth_ntlmssp_state)->ntlmssp_state->session_key.length);\n\n\t\t/* register_existing_vuid keeps the server info */\n\t\tif (register_existing_vuid(sconn, vuid,\n\t\t\t\tserver_info, nullblob,\n\t\t\t\t(*auth_ntlmssp_state)->ntlmssp_state->user) !=\n\t\t\t\t\tvuid) {\n\t\t\tnt_status = NT_STATUS_LOGON_FAILURE;\n\t\t\tgoto out;\n\t\t}\n\n\t\t(*auth_ntlmssp_state)->server_info = NULL;\n\n\t\t/* current_user_info is changed on new vuid */\n\t\treload_services( True );\n\n\t\tSSVAL(req->outbuf, smb_vwv3, 0);\n\n\t\tif (server_info->guest) {\n\t\t\tSSVAL(req->outbuf,smb_vwv2,1);\n\t\t}\n\t}\n\n  out:\n\n\tif (wrap) {\n\t\tresponse = spnego_gen_auth_response(ntlmssp_blob,\n\t\t\t\tnt_status, OID);\n\t} else {\n\t\tresponse = *ntlmssp_blob;\n\t}\n\n\treply_sesssetup_blob(req, response, nt_status);\n\tif (wrap) {\n\t\tdata_blob_free(&response);\n\t}\n\n\t/* NT_STATUS_MORE_PROCESSING_REQUIRED from our NTLMSSP code tells us,\n\t   and the other end, that we are not finished yet. */\n\n\tif (!NT_STATUS_EQUAL(nt_status, NT_STATUS_MORE_PROCESSING_REQUIRED)) {\n\t\t/* NB. This is *NOT* an error case. JRA */\n\t\tauth_ntlmssp_end(auth_ntlmssp_state);\n\t\tif (!NT_STATUS_IS_OK(nt_status)) {\n\t\t\t/* Kill the intermediate vuid */\n\t\t\tinvalidate_vuid(sconn, vuid);\n\t\t}\n\t}\n}\n- reload_services: bool reload_services(bool test); /* <=== reload_services */ \n- NT_STATUS_NO_MEMORY: #define NT_STATUS_NO_MEMORY NT_STATUS(0xC0000000 | 0x0017) /* <=== libcli/util/ntstatus.h:113:113:NT_STATUS_NO_MEMORY:0 */ \n- DLIST_ADD: #define DLIST_ADD(list, p) \\ /* <=== source3/lib/ldb/include/dlinklist.h:28:39:DLIST_ADD:2 */ \ndo { \\\n        if (!(list)) { \\\n\t\t(list) = (p); \\\n\t\t(p)->next = (p)->prev = NULL; \\\n\t} else { \\\n\t\t(list)->prev = (p); \\\n\t\t(p)->next = (list); \\\n\t\t(p)->prev = NULL; \\\n\t\t(list) = (p); \\\n\t}\\\n} while (0)\n- SSVAL: #define SSVAL(buf,pos,val) SSVALX((buf),(pos),((uint16_t)(val))) /* <=== lib/util/byteorder.h:172:172:SSVAL:3 */ \n- log_stack_trace: void log_stack_trace(void) /* <=== log_stack_trace */ \n{\n#ifdef HAVE_LIBUNWIND\n\t/* Try to use libunwind before any other technique since on ia64\n\t * libunwind correctly walks the stack in more circumstances than\n\t * backtrace.\n\t */ \n\tunw_cursor_t cursor;\n\tunw_context_t uc;\n\tunsigned i = 0;\n\n\tchar procname[256];\n\tunw_word_t ip, sp, off;\n\n\tprocname[sizeof(procname) - 1] = '\\0';\n\n\tif (unw_getcontext(&uc) != 0) {\n\t\tgoto libunwind_failed;\n\t}\n\n\tif (unw_init_local(&cursor, &uc) != 0) {\n\t\tgoto libunwind_failed;\n\t}\n\n\tDEBUG(0, (\"BACKTRACE:\\n\"));\n\n\tdo {\n\t    ip = sp = 0;\n\t    unw_get_reg(&cursor, UNW_REG_IP, &ip);\n\t    unw_get_reg(&cursor, UNW_REG_SP, &sp);\n\n\t    switch (unw_get_proc_name(&cursor,\n\t\t\tprocname, sizeof(procname) - 1, &off) ) {\n\t    case 0:\n\t\t    /* Name found. */\n\t    case -UNW_ENOMEM:\n\t\t    /* Name truncated. */\n\t\t    DEBUGADD(0, (\" #%u %s + %#llx [ip=%#llx] [sp=%#llx]\\n\",\n\t\t\t    i, procname, (long long)off,\n\t\t\t    (long long)ip, (long long) sp));\n\t\t    break;\n\t    default:\n\t    /* case -UNW_ENOINFO: */\n\t    /* case -UNW_EUNSPEC: */\n\t\t    /* No symbol name found. */\n\t\t    DEBUGADD(0, (\" #%u %s [ip=%#llx] [sp=%#llx]\\n\",\n\t\t\t    i, \"<unknown symbol>\",\n\t\t\t    (long long)ip, (long long) sp));\n\t    }\n\t    ++i;\n\t} while (unw_step(&cursor) > 0);\n\n\treturn;\n\nlibunwind_failed:\n\tDEBUG(0, (\"unable to produce a stack trace with libunwind\\n\"));\n\n#elif HAVE_BACKTRACE_SYMBOLS\n\tvoid *backtrace_stack[BACKTRACE_STACK_SIZE];\n\tsize_t backtrace_size;\n\tchar **backtrace_strings;\n\n\t/* get the backtrace (stack frames) */\n\tbacktrace_size = backtrace(backtrace_stack,BACKTRACE_STACK_SIZE);\n\tbacktrace_strings = backtrace_symbols(backtrace_stack, backtrace_size);\n\n\tDEBUG(0, (\"BACKTRACE: %lu stack frames:\\n\", \n\t\t  (unsigned long)backtrace_size));\n\t\n\tif (backtrace_strings) {\n\t\tint i;\n\n\t\tfor (i = 0; i < backtrace_size; i++)\n\t\t\tDEBUGADD(0, (\" #%u %s\\n\", i, backtrace_strings[i]));\n\n\t\t/* Leak the backtrace_strings, rather than risk what free() might do */\n\t}\n\n#elif HAVE_LIBEXC\n\n\t/* The IRIX libexc library provides an API for unwinding the stack. See\n\t * libexc(3) for details. Apparantly trace_back_stack leaks memory, but\n\t * since we are about to abort anyway, it hardly matters.\n\t */\n\n#define NAMESIZE 32 /* Arbitrary */\n\n\t__uint64_t\taddrs[BACKTRACE_STACK_SIZE];\n\tchar *      \tnames[BACKTRACE_STACK_SIZE];\n\tchar\t\tnamebuf[BACKTRACE_STACK_SIZE * NAMESIZE];\n\n\tint\t\ti;\n\tint\t\tlevels;\n\n\tZERO_ARRAY(addrs);\n\tZERO_ARRAY(names);\n\tZERO_ARRAY(namebuf);\n\n\t/* We need to be root so we can open our /proc entry to walk\n\t * our stack. It also helps when we want to dump core.\n\t */\n\tbecome_root();\n\n\tfor (i = 0; i < BACKTRACE_STACK_SIZE; i++) {\n\t\tnames[i] = namebuf + (i * NAMESIZE);\n\t}\n\n\tlevels = trace_back_stack(0, addrs, names,\n\t\t\tBACKTRACE_STACK_SIZE, NAMESIZE - 1);\n\n\tDEBUG(0, (\"BACKTRACE: %d stack frames:\\n\", levels));\n\tfor (i = 0; i < levels; i++) {\n\t\tDEBUGADD(0, (\" #%d 0x%llx %s\\n\", i, addrs[i], names[i]));\n\t}\n#undef NAMESIZE\n\n#else\n\tDEBUG(0, (\"unable to produce a stack trace on this platform\\n\"));\n#endif\n}\n- OID_NTLMSSP: #define OID_NTLMSSP \"1.3.6.1.4.1.311.2.2.10\" /* <=== libcli/auth/spnego.h:24:24:OID_NTLMSSP:0 */ \n- register_initial_vuid: int register_initial_vuid(struct smbd_server_connection *sconn) /* <=== register_initial_vuid */ \n{\n\tuser_struct *vuser;\n\n\t/* Paranoia check. */\n\tif(lp_security() == SEC_SHARE) {\n\t\tsmb_panic(\"register_initial_vuid: \"\n\t\t\t\"Tried to register uid in security=share\");\n\t}\n\n\t/* Limit allowed vuids to 16bits - VUID_OFFSET. */\n\tif (sconn->smb1.sessions.num_validated_vuids >= 0xFFFF-VUID_OFFSET) {\n\t\treturn UID_FIELD_INVALID;\n\t}\n\n\tif((vuser = talloc_zero(NULL, user_struct)) == NULL) {\n\t\tDEBUG(0,(\"register_initial_vuid: \"\n\t\t\t\t\"Failed to talloc users struct!\\n\"));\n\t\treturn UID_FIELD_INVALID;\n\t}\n\n\t/* Allocate a free vuid. Yes this is a linear search... */\n\twhile( get_valid_user_struct_internal(sconn,\n\t\t\tsconn->smb1.sessions.next_vuid,\n\t\t\tSERVER_ALLOCATED_REQUIRED_ANY) != NULL ) {\n\t\tincrement_next_vuid(&sconn->smb1.sessions.next_vuid);\n\t}\n\n\tDEBUG(10,(\"register_initial_vuid: allocated vuid = %u\\n\",\n\t\t(unsigned int)sconn->smb1.sessions.next_vuid ));\n\n\tvuser->vuid = sconn->smb1.sessions.next_vuid;\n\n\t/*\n\t * This happens in an unfinished NTLMSSP session setup. We\n\t * need to allocate a vuid between the first and second calls\n\t * to NTLMSSP.\n\t */\n\tincrement_next_vuid(&sconn->smb1.sessions.next_vuid);\n\tsconn->smb1.sessions.num_validated_vuids++;\n\n\tDLIST_ADD(sconn->smb1.sessions.validated_users, vuser);\n\treturn vuser->vuid;\n}\n- ZERO_STRUCT: #define ZERO_STRUCT(x) memset((char *)&(x), 0, sizeof(x)) /* <=== lib/replace/replace.h:652:652:ZERO_STRUCT:1 */ \n- invalidate_vuid: void invalidate_vuid(struct smbd_server_connection *sconn, uint16 vuid) /* <=== invalidate_vuid */ \n{\n\tuser_struct *vuser = NULL;\n\n\tvuser = get_valid_user_struct_internal(sconn, vuid,\n\t\t\tSERVER_ALLOCATED_REQUIRED_ANY);\n\tif (vuser == NULL) {\n\t\treturn;\n\t}\n\n\tsession_yield(vuser);\n\n\tif (vuser->auth_ntlmssp_state) {\n\t\tauth_ntlmssp_end(&vuser->auth_ntlmssp_state);\n\t}\n\n\tDLIST_REMOVE(sconn->smb1.sessions.validated_users, vuser);\n\n\t/* clear the vuid from the 'cache' on each connection, and\n\t   from the vuid 'owner' of connections */\n\tconn_clear_vuid_caches(sconn, vuid);\n\n\tTALLOC_FREE(vuser);\n\tsconn->smb1.sessions.num_validated_vuids--;\n}\n- auth_ntlmssp_update: NTSTATUS auth_ntlmssp_update(AUTH_NTLMSSP_STATE *auth_ntlmssp_state,  /* <=== auth_ntlmssp_update */ \n\t\t\t     const DATA_BLOB request, DATA_BLOB *reply) \n{\n\treturn ntlmssp_update(auth_ntlmssp_state->ntlmssp_state, request, reply);\n}\n- conn_clear_vuid_caches: void conn_clear_vuid_caches(struct smbd_server_connection *sconn, uint16 vuid); /* <=== conn_clear_vuid_caches */ \n- get_pending_auth_data: static struct pending_auth_data *get_pending_auth_data( /* <=== get_pending_auth_data */ \n\t\tstruct smbd_server_connection *sconn,\n\t\tuint16_t smbpid)\n{\n\tstruct pending_auth_data *pad;\n/*\n * NOTE: using the smbpid here is completely wrong...\n *       see [MS-SMB]\n *       3.3.5.3 Receiving an SMB_COM_SESSION_SETUP_ANDX Request\n */\n\tfor (pad = sconn->smb1.pd_list; pad; pad = pad->next) {\n\t\tif (pad->smbpid == smbpid) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn pad;\n}\n- DLIST_REMOVE: #define DLIST_REMOVE(list, p) \\ /* <=== source3/lib/ldb/include/dlinklist.h:42:52:DLIST_REMOVE:2 */ \ndo { \\\n\tif ((p) == (list)) { \\\n\t\t(list) = (p)->next; \\\n\t\tif (list) (list)->prev = NULL; \\\n\t} else { \\\n\t\tif ((p)->prev) (p)->prev->next = (p)->next; \\\n\t\tif ((p)->next) (p)->next->prev = (p)->prev; \\\n\t} \\\n\tif ((p) && ((p) != (list))) (p)->next = (p)->prev = NULL; \\\n} while (0)\n- NT_STATUS_INVALID_PARAMETER: #define NT_STATUS_INVALID_PARAMETER NT_STATUS(0xC0000000 | 0x000d) /* <=== libcli/util/ntstatus.h:99:99:NT_STATUS_INVALID_PARAMETER:0 */ \n- SVAL: #define SVAL(buf,pos) (PVAL(buf,pos)|PVAL(buf,(pos)+1)<<8) /* <=== lib/util/byteorder.h:166:166:SVAL:2 */ \n- make_auth_context_subsystem: NTSTATUS make_auth_context_subsystem(struct auth_context **auth_context) ; /* <=== make_auth_context_subsystem */ \n- dump_core: void dump_core(void) _NORETURN_; /* <=== dump_core */ \n- talloc_stackframe: TALLOC_CTX *talloc_stackframe(void) /* <=== talloc_stackframe */ \n{\n\treturn talloc_stackframe_internal(0);\n}\n- talloc_tos: TALLOC_CTX *talloc_tos(void) /* <=== talloc_tos */ \n{\n\tstruct talloc_stackframe *ts =\n\t\t(struct talloc_stackframe *)SMB_THREAD_GET_TLS(global_ts);\n\n\tif (ts == NULL || ts->talloc_stacksize == 0) {\n\t\ttalloc_stackframe();\n\t\tts = (struct talloc_stackframe *)SMB_THREAD_GET_TLS(global_ts);\n\t\tDEBUG(0, (\"no talloc stackframe around, leaking memory\\n\"));\n\t}\n\n\treturn ts->talloc_stack[ts->talloc_stacksize-1];\n}\n- talloc_free: #define talloc_free(ctx) _talloc_free(ctx, __location__) /* <=== lib/talloc/talloc.h:115:115:talloc_free:1 */ \n- SAFE_FREE: #define SAFE_FREE(x) do { if ((x) != NULL) {free(discard_const_p(void *, (x))); (x)=NULL;} } while(0) /* <=== lib/util/memory.h:31:31:SAFE_FREE:1 */ \n- ZERO_STRUCTP: #define ZERO_STRUCTP(x) do { if ((x) != NULL) memset((char *)(x), 0, sizeof(*(x))); } while(0) /* <=== lib/replace/replace.h:657:657:ZERO_STRUCTP:1 */ \n- NT_STATUS_MORE_PROCESSING_REQUIRED: #define NT_STATUS_MORE_PROCESSING_REQUIRED NT_STATUS(0xC0000000 | 0x0016) /* <=== libcli/util/ntstatus.h:108:108:NT_STATUS_MORE_PROCESSING_REQUIRED:0 */ \n- smb_panic: void smb_panic(const char *const why) /* <=== smb_panic */ \n{\n\tchar *cmd;\n\tint result;\n\n#ifdef DEVELOPER\n\t{\n\n\t\tif (global_clobber_region_function) {\n\t\t\tDEBUG(0,(\"smb_panic: clobber_region() last called from [%s(%u)]\\n\",\n\t\t\t\t\t global_clobber_region_function,\n\t\t\t\t\t global_clobber_region_line));\n\t\t} \n\t}\n#endif\n\n\tDEBUG(0,(\"PANIC (pid %llu): %s\\n\",\n\t\t    (unsigned long long)sys_getpid(), why));\n\tlog_stack_trace();\n\n\tcmd = lp_panic_action();\n\tif (cmd && *cmd) {\n\t\tDEBUG(0, (\"smb_panic(): calling panic action [%s]\\n\", cmd));\n\t\tresult = system(cmd);\n\n\t\tif (result == -1)\n\t\t\tDEBUG(0, (\"smb_panic(): fork failed in panic action: %s\\n\",\n\t\t\t\t\t  strerror(errno)));\n\t\telse\n\t\t\tDEBUG(0, (\"smb_panic(): action returned status %d\\n\",\n\t\t\t\t\t  WEXITSTATUS(result)));\n\t}\n\n\tdump_core();\n}\n- TALLOC_FREE: #define TALLOC_FREE(ctx) do { talloc_free(ctx); ctx=NULL; } while(0) /* <=== lib/talloc/talloc.h:127:127:TALLOC_FREE:1 */ \n- lp_server_role: int lp_server_role(void); /* <=== lp_server_role */ \n- auth_ntlmssp_end: void auth_ntlmssp_end(AUTH_NTLMSSP_STATE **auth_ntlmssp_state) /* <=== auth_ntlmssp_end */ \n{\n\tTALLOC_CTX *mem_ctx;\n\n\tif (*auth_ntlmssp_state == NULL) {\n\t\treturn;\n\t}\n\n\tmem_ctx = (*auth_ntlmssp_state)->mem_ctx;\n\tif ((*auth_ntlmssp_state)->ntlmssp_state) {\n\t\tntlmssp_end(&(*auth_ntlmssp_state)->ntlmssp_state);\n\t}\n\tif ((*auth_ntlmssp_state)->auth_context) {\n\t\t((*auth_ntlmssp_state)->auth_context->free)(&(*auth_ntlmssp_state)->auth_context);\n\t}\n\tif ((*auth_ntlmssp_state)->server_info) {\n\t\tTALLOC_FREE((*auth_ntlmssp_state)->server_info);\n\t}\n\ttalloc_destroy(mem_ctx);\n\t*auth_ntlmssp_state = NULL;\n}\n- talloc_init: void *talloc_init(const char *fmt, ...) PRINTF_ATTRIBUTE(1,2); /* <=== talloc_init */ \n\nType Definitions:\n- smbd_server_connection: struct smbd_server_connection {\n\tstruct {\n\t\tbool got_session;\n\t} nbt;\n\tbool allow_smb2;\n\tstruct {\n\t\tstruct fd_event *fde;\n\t\tuint64_t num_requests;\n\t\tstruct {\n\t\t\tbool encrypted_passwords;\n\t\t\tbool spnego;\n\t\t\tstruct auth_context *auth_context;\n\t\t\tbool done;\n\t\t\t/*\n\t\t\t * Size of the data we can receive. Set by us.\n\t\t\t * Can be modified by the max xmit parameter.\n\t\t\t */\n\t\t\tint max_recv;\n\t\t} negprot;\n\n\t\tstruct {\n\t\t\tbool done_sesssetup;\n\t\t\t/*\n\t\t\t * Size of data we can send to client. Set\n\t\t\t *  by the client for all protocols above CORE.\n\t\t\t *  Set by us for CORE protocol.\n\t\t\t */\n\t\t\tint max_send;\n\t\t\tuint16_t last_session_tag;\n\n\t\t\t/* users from session setup */\n\t\t\tchar *session_userlist;\n\t\t\t/* workgroup from session setup. */\n\t\t\tchar *session_workgroup;\n\t\t\t/*\n\t\t\t * this holds info on user ids that are already\n\t\t\t * validated for this VC\n\t\t\t */\n\t\t\tuser_struct *validated_users;\n\t\t\tuint16_t next_vuid;\n\t\t\tint num_validated_vuids;\n#ifdef HAVE_NETGROUP\n\t\t\tchar *my_yp_domain;\n#endif\n\t\t} sessions;\n\t\tstruct {\n\t\t\tconnection_struct *Connections;\n\t\t\t/* number of open connections */\n\t\t\tstruct bitmap *bmap;\n\t\t\tint num_open;\n\t\t} tcons;\n\t\tstruct smb_signing_state *signing_state;\n\t\t/* List to store partial SPNEGO auth fragments. */\n\t\tstruct pending_auth_data *pd_list;\n\n\t\tstruct notify_mid_map *notify_mid_maps;\n\n\t\tstruct {\n\t\t\tstruct bitmap *dptr_bmap;\n\t\t\tstruct dptr_struct *dirptrs;\n\t\t\tint dirhandles_open;\n\t\t} searches;\n\t} smb1;\n\tstruct {\n\t\tstruct tevent_context *event_ctx;\n\t\tstruct tevent_queue *recv_queue;\n\t\tstruct tevent_queue *send_queue;\n\t\tstruct tstream_context *stream;\n\t\tstruct {\n\t\t\t/* an id tree used to allocate vuids */\n\t\t\t/* this holds info on session vuids that are already\n\t\t\t * validated for this VC */\n\t\t\tstruct idr_context *idtree;\n\n\t\t\t/* this is the limit of vuid values for this connection */\n\t\t\tuint64_t limit;\n\n\t\t\tstruct smbd_smb2_session *list;\n\t\t} sessions;\n\t\tstruct smbd_smb2_request *requests;\n\t} smb2;\n}\n- smb_request: struct smb_request {\n\tuint8_t cmd;\n\tuint16 flags2;\n\tuint16 smbpid;\n\tuint16 mid;\n\tuint32_t seqnum;\n\tuint16 vuid;\n\tuint16 tid;\n\tuint8  wct;\n\tuint16_t *vwv;\n\tuint16_t buflen;\n\tconst uint8_t *buf;\n\tconst uint8 *inbuf;\n\n\t/*\n\t * Async handling in the main smb processing loop is directed by\n\t * outbuf: reply_xxx routines indicate sync behaviour by putting their\n\t * reply into \"outbuf\". If they leave it as NULL, they take of it\n\t * themselves, possibly later.\n\t *\n\t * If async handling is wanted, the reply_xxx routine must make sure\n\t * that it talloc_move()s the smb_req somewhere else.\n\t */\n\tuint8 *outbuf;\n\n\tsize_t unread_bytes;\n\tbool encrypted;\n\tconnection_struct *conn;\n\tstruct smb_perfcount_data pcd;\n\n\t/*\n\t * Chained request handling\n\t */\n\tstruct files_struct *chain_fsp;\n\n\t/*\n\t * Here we collect the outbufs from the chain handlers\n\t */\n\tuint8_t *chain_outbuf;\n\n\t/*\n\t * state information for async smb handling\n\t */\n\tvoid *async_priv;\n\n\tbool done;\n}\n- smb_request: struct smb_request\n- user_struct: typedef struct user_struct {\n\tstruct user_struct *next, *prev;\n\tuint16 vuid; /* Tag for this entry. */\n\n\tchar *session_keystr; /* used by utmp and pam session code.  \n\t\t\t\t TDB key string */\n\tint homes_snum;\n\n\tstruct auth_serversupplied_info *server_info;\n\n\tstruct auth_ntlmssp_state *auth_ntlmssp_state;\n} user_struct;\n- pending_auth_data: struct pending_auth_data {\n\tstruct pending_auth_data *prev, *next;\n\tuint16 vuid; /* Tag for this entry. */\n\tuint16 smbpid; /* Alternate tag for this entry. */\n\tsize_t needed_len;\n\tDATA_BLOB partial_data;\n}\n\nImports:\n- #include \"smbd/globals.h\"\n- #include \"../libcli/auth/spnego.h\"\n- #include \"includes.h\"",
    "commit_msg": "s3: Fix an uninitialized variable read\n\nFound by Laurent Gaffie <laurent.gaffie@gmail.com>\n\nThanks for that,\n\nVolker\n\nFix bug #7254 (An uninitialized variable read could cause an smbd crash).",
    "cve_desc": "The reply_sesssetup_and_X_spnego function in sesssetup.c in smbd in Samba before 3.4.8 and 3.5.x before 3.5.2 allows remote attackers to trigger an out-of-bounds read, and cause a denial of service (process crash), via a \\xff\\xff security blob length in a Session Setup AndX request.",
    "year": 2010,
    "filename": "sesssetup.c",
    "commit_url": "\"https://github.com/samba-team/samba/commit/9280051bfba337458722fb157f3082f93cbd9f2b\""
  },
  {
    "repository": "git/git",
    "cve_id": "CVE-2010-2542",
    "cwe_list": [
      "CWE-787"
    ],
    "commit_hash": "3c9d0414ed2db0167e6c828b547be8fc9f88fccc",
    "short_hash": "3c9d0414",
    "vulnerableMethods_before": [
      {
        "filename": "setup.c",
        "method_name": "is_git_directory",
        "raw_code": "static int is_git_directory(const char *suspect) /* <=== is_git_directory */ \n{\n\tchar path[PATH_MAX];\n\tsize_t len = strlen(suspect);\n\n\tstrcpy(path, suspect);\n\tif (getenv(DB_ENVIRONMENT)) {\n\t\tif (access(getenv(DB_ENVIRONMENT), X_OK))\n\t\t\treturn 0;\n\t}\n\telse {\n\t\tstrcpy(path + len, \"/objects\");\n\t\tif (access(path, X_OK))\n\t\t\treturn 0;\n\t}\n\n\tstrcpy(path + len, \"/refs\");\n\tif (access(path, X_OK))\n\t\treturn 0;\n\n\tstrcpy(path + len, \"/HEAD\");\n\tif (validate_headref(path))\n\t\treturn 0;\n\n\treturn 1;\n}",
        "start_line": 168
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "setup.c",
        "method_name": "is_git_directory",
        "raw_code": "static int is_git_directory(const char *suspect) /* <=== is_git_directory */ \n{\n\tchar path[PATH_MAX];\n\tsize_t len = strlen(suspect);\n\n\tif (PATH_MAX <= len + strlen(\"/objects\"))\n\t\tdie(\"Too long path: %.*s\", 60, suspect);\n\tstrcpy(path, suspect);\n\tif (getenv(DB_ENVIRONMENT)) {\n\t\tif (access(getenv(DB_ENVIRONMENT), X_OK))\n\t\t\treturn 0;\n\t}\n\telse {\n\t\tstrcpy(path + len, \"/objects\");\n\t\tif (access(path, X_OK))\n\t\t\treturn 0;\n\t}\n\n\tstrcpy(path + len, \"/refs\");\n\tif (access(path, X_OK))\n\t\treturn 0;\n\n\tstrcpy(path + len, \"/HEAD\");\n\tif (validate_headref(path))\n\t\treturn 0;\n\n\treturn 1;\n}",
        "start_line": 168
      }
    ],
    "code_context": "Called Methods:\n- die: void die(const char *err, ...) /* <=== die */ \n{\n\tva_list params;\n\n\tva_start(params, err);\n\tdie_routine(err, params);\n\tva_end(params);\n}\n- read_in_full: ssize_t read_in_full(int fd, void *buf, size_t count) /* <=== read_in_full */ \n{\n\tchar *p = buf;\n\tssize_t total = 0;\n\n\twhile (count > 0) {\n\t\tssize_t loaded = xread(fd, p, count);\n\t\tif (loaded <= 0)\n\t\t\treturn total ? total : loaded;\n\t\tcount -= loaded;\n\t\tp += loaded;\n\t\ttotal += loaded;\n\t}\n\n\treturn total;\n}\n- PATH_MAX: #define PATH_MAX 4096 /* <=== git-compat-util.h:148:148:PATH_MAX:0 */ \n- isspace: #define isspace(x) sane_istest(x,GIT_SPACE) /* <=== git-compat-util.h:412:412:isspace:1 */ \n- validate_headref: int validate_headref(const char *path) /* <=== validate_headref */ \n{\n\tstruct stat st;\n\tchar *buf, buffer[256];\n\tunsigned char sha1[20];\n\tint fd;\n\tssize_t len;\n\n\tif (lstat(path, &st) < 0)\n\t\treturn -1;\n\n\t/* Make sure it is a \"refs/..\" symlink */\n\tif (S_ISLNK(st.st_mode)) {\n\t\tlen = readlink(path, buffer, sizeof(buffer)-1);\n\t\tif (len >= 5 && !memcmp(\"refs/\", buffer, 5))\n\t\t\treturn 0;\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Anything else, just open it and try to see if it is a symbolic ref.\n\t */\n\tfd = open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn -1;\n\tlen = read_in_full(fd, buffer, sizeof(buffer)-1);\n\tclose(fd);\n\n\t/*\n\t * Is it a symbolic ref?\n\t */\n\tif (len < 4)\n\t\treturn -1;\n\tif (!memcmp(\"ref:\", buffer, 4)) {\n\t\tbuf = buffer + 4;\n\t\tlen -= 4;\n\t\twhile (len && isspace(*buf))\n\t\t\tbuf++, len--;\n\t\tif (len >= 5 && !memcmp(\"refs/\", buf, 5))\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * Is this a detached HEAD?\n\t */\n\tif (!get_sha1_hex(buffer, sha1))\n\t\treturn 0;\n\n\treturn -1;\n}\n- get_sha1_hex: extern int get_sha1_hex(const char *hex, unsigned char *sha1); /* <=== get_sha1_hex */ \n\nImports:\n- #include \"cache.h\"\n- #include \"dir.h\"",
    "commit_msg": "Check size of path buffer before writing into it\n\nThis prevents a buffer overrun that could otherwise be triggered by\ncreating a file called '.git' with contents\n\n  gitdir: (something really long)\n\nSigned-off-by: Greg Brockman <gdb@mit.edu>\nSigned-off-by: Junio C Hamano <gitster@pobox.com>",
    "cve_desc": "Stack-based buffer overflow in the is_git_directory function in setup.c in Git before 1.7.2.1 allows local users to gain privileges via a long gitdir: field in a .git file in a working copy.",
    "year": 2010,
    "filename": "setup.c",
    "commit_url": "\"https://github.com/git/git/commit/3c9d0414ed2db0167e6c828b547be8fc9f88fccc\""
  },
  {
    "repository": "alandekok/freeradius-server",
    "cve_id": "CVE-2010-3697",
    "cwe_list": [
      "CWE-399"
    ],
    "commit_hash": "ff94dd35673bba1476594299d31ce8293b8bd223",
    "short_hash": "ff94dd35",
    "vulnerableMethods_before": [
      {
        "filename": "src/main/event.c",
        "method_name": "wait_a_bit",
        "raw_code": "static void wait_a_bit(void *ctx) /* <=== wait_a_bit */ \n{\n\tstruct timeval when;\n\tREQUEST *request = ctx;\n\tfr_event_callback_t callback = NULL;\n\n\trad_assert(request->magic == REQUEST_MAGIC);\n\n#ifdef WITH_COA\n\t/*\n\t *\tThe CoA request is a new (internally generated)\n\t *\trequest, created in a child thread.  We therefore need\n\t *\tsome way to tie its events back into the main event\n\t *\thandler.\n\t */\n\tif (request->coa && !request->coa->proxy_reply &&\n\t    request->coa->next_callback) {\n\t\trequest->coa->when = request->coa->next_when;\n\t\tINSERT_EVENT(request->coa->next_callback, request->coa);\n\t\trequest->coa->next_callback = NULL;\n\t\trequest->coa->parent = NULL;\n\t\trequest->coa = NULL;\n\t}\n#endif\n\n\tswitch (request->child_state) {\n\tcase REQUEST_QUEUED:\n\tcase REQUEST_RUNNING:\n\t\twhen = request->received;\n\t\twhen.tv_sec += request->root->max_request_time;\n\n\t\t/*\n\t\t *\tNormally called from the event loop with the\n\t\t *\tproper event loop time.  Otherwise, called from\n\t\t *\tpost proxy fail handler, which sets \"now\", and\n\t\t *\tthis call won't re-set it, because we're not\n\t\t *\tin the event loop.\n\t\t */\n\t\tfr_event_now(el, &now);\n\n\t\t/*\n\t\t *\tRequest still has more time.  Continue\n\t\t *\twaiting.\n\t\t */\n\t\tif (timercmp(&now, &when, <) ||\n\t\t    ((request->listener->type == RAD_LISTEN_DETAIL) &&\n\t\t     (request->child_state == REQUEST_QUEUED))) {\n\t\t\tif (request->delay < (USEC / 10)) {\n\t\t\t\trequest->delay = USEC / 10;\n\t\t\t}\n\t\t\trequest->delay += request->delay >> 1;\n\n#ifdef WITH_DETAIL\n\t\t\t/*\n\t\t\t *\tCap wait at some sane value for detail\n\t\t\t *\tfiles.\n\t\t\t */\n\t\t\tif ((request->listener->type == RAD_LISTEN_DETAIL) &&\n\t\t\t    (request->delay > (request->root->max_request_time * USEC))) {\n\t\t\t\trequest->delay = request->root->max_request_time * USEC;\n\t\t\t}\n#endif\n\n\t\t\trequest->when = now;\n\t\t\ttv_add(&request->when, request->delay);\n\t\t\tcallback = wait_a_bit;\n\t\t\tbreak;\n\t\t}\n\n#if defined(HAVE_PTHREAD_H)\n\t\t/*\n\t\t *\tA child thread MAY still be running on the\n\t\t *\trequest.  Ask the thread to stop working on\n\t\t *\tthe request.\n\t\t */\n\t\tif (have_children &&\n\t\t    (pthread_equal(request->child_pid, NO_SUCH_CHILD_PID) == 0)) {\n\t\t\trequest->master_state = REQUEST_STOP_PROCESSING;\n\n\t\t\tradlog(L_ERR, \"WARNING: Unresponsive child for request %u, in module %s component %s\",\n\t\t\t       request->number,\n\t\t\t       request->module ? request->module : \"<server core>\",\n\t\t\t       request->component ? request->component : \"<server core>\");\n\t\t\t\n\t\t\trequest->delay = USEC / 4;\n\t\t\ttv_add(&request->when, request->delay);\n\t\t\tcallback = wait_for_child_to_die;\n\t\t\tbreak;\n\t\t}\n#endif\n\n\t\t/*\n\t\t *\tElse no child thread is processing the\n\t\t *\trequest.  We probably should have just marked\n\t\t *\tthe request as 'done' elsewhere, like in the\n\t\t *\tpost-proxy-fail handler.  But doing that would\n\t\t *\tinvolve checking for max_request_time in\n\t\t *\tmultiple places, so this may be simplest.\n\t\t */\n\t\trequest->child_state = REQUEST_DONE;\n\t\t/* FALL-THROUGH */\n\n\t\t/*\n\t\t *\tMark the request as no longer running,\n\t\t *\tand clean it up.\n\t\t */\n\tcase REQUEST_DONE:\n#ifdef HAVE_PTHREAD_H\n\t\trequest->child_pid = NO_SUCH_CHILD_PID;\n#endif\n\n#ifdef WITH_COA\n\t\t/*\n\t\t *\tThis is a CoA request.  It's been divorced\n\t\t *\tfrom everything else, so we clean it up now.\n\t\t */\n\t\tif (!request->in_request_hash &&\n\t\t    request->proxy &&\n\t\t    (request->packet->code != request->proxy->code) &&\n\t\t    ((request->proxy->code == PW_COA_REQUEST) ||\n\t\t     (request->proxy->code == PW_DISCONNECT_REQUEST))) {\n\t\t\t/*\n\t\t\t *\tFIXME: Do CoA MIBs\n\t\t\t */\n\t\t\tev_request_free(&request);\n\t\t\treturn;\n\t\t}\n#endif\n\t\trequest_stats_final(request);\n\t\tcleanup_delay(request);\n\t\treturn;\n\n\tcase REQUEST_REJECT_DELAY:\n\tcase REQUEST_CLEANUP_DELAY:\n#ifdef HAVE_PTHREAD_H\n\t\trequest->child_pid = NO_SUCH_CHILD_PID;\n#endif\n\t\trequest_stats_final(request);\n\n\tcase REQUEST_PROXIED:\n\t\trad_assert(request->next_callback != NULL);\n\t\trad_assert(request->next_callback != wait_a_bit);\n\n\t\trequest->when = request->next_when;\n\t\tcallback = request->next_callback;\n\t\trequest->next_callback = NULL;\n\t\tbreak;\n\n\tdefault:\n\t\trad_panic(\"Internal sanity check failure\");\n\t\treturn;\n\t}\n\n\t/*\n\t *\tSomething major went wrong.  Discard the request, and\n\t *\tkeep running.\n\t *\n\t *\tFIXME: No idea why this happens or how to fix it...\n\t *\tIt seems to happen *only* when requests are proxied,\n\t *\tand where the home server doesn't respond.  So it looks\n\t *\tlike a race condition above, but it happens in debug\n\t *\tmode, with no threads...\n\t */\n\tif (!callback) {\n\t\tRDEBUG(\"WARNING: Internal sanity check failed in event handler for request %u: Discarding the request!\", request->number);\n\t\tev_request_free(&request);\n\t\treturn;\n\t}\n\n\tINSERT_EVENT(callback, request);\n}",
        "start_line": 1115
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "src/main/event.c",
        "method_name": "wait_a_bit",
        "raw_code": "static void wait_a_bit(void *ctx) /* <=== wait_a_bit */ \n{\n\tstruct timeval when;\n\tREQUEST *request = ctx;\n\tfr_event_callback_t callback = NULL;\n\n\trad_assert(request->magic == REQUEST_MAGIC);\n\n#ifdef WITH_COA\n\t/*\n\t *\tThe CoA request is a new (internally generated)\n\t *\trequest, created in a child thread.  We therefore need\n\t *\tsome way to tie its events back into the main event\n\t *\thandler.\n\t */\n\tif (request->coa && !request->coa->proxy_reply &&\n\t    request->coa->next_callback) {\n\t\trequest->coa->when = request->coa->next_when;\n\t\tINSERT_EVENT(request->coa->next_callback, request->coa);\n\t\trequest->coa->next_callback = NULL;\n\t\trequest->coa->parent = NULL;\n\t\trequest->coa = NULL;\n\t}\n#endif\n\n\tswitch (request->child_state) {\n\tcase REQUEST_QUEUED:\n\tcase REQUEST_RUNNING:\n\t\t/*\n\t\t *\tIf we're not thread-capable, OR we're capable,\n\t\t *\tbut have been told to run without threads,\n\t\t *\tcomplain when the requests is queued for a\n\t\t *\tthread, or running in a child thread.\n\t\t */\n#ifdef HAVE_PTHREAD_H\n\t\tif (!have_children)\n#endif\n\t\t{\n\t\t\trad_assert(\"We do not have threads, but the request is marked as queued or running in a child thread\" == NULL);\n\t\t\tbreak;\n\t\t}\n\n#ifdef HAVE_PTHREAD_H\n\t\t/*\n\t\t *\tIf we have threads, wait for the child thread\n\t\t *\tto stop.\n\t\t */\n\t\twhen = request->received;\n\t\twhen.tv_sec += request->root->max_request_time;\n\n\t\t/*\n\t\t *\tNormally called from the event loop with the\n\t\t *\tproper event loop time.  Otherwise, called from\n\t\t *\tpost proxy fail handler, which sets \"now\", and\n\t\t *\tthis call won't re-set it, because we're not\n\t\t *\tin the event loop.\n\t\t */\n\t\tfr_event_now(el, &now);\n\n\t\t/*\n\t\t *\tRequest still has more time.  Continue\n\t\t *\twaiting.\n\t\t */\n\t\tif (timercmp(&now, &when, <)) {\n\t\t\tif (request->delay < (USEC / 10)) {\n\t\t\t\trequest->delay = USEC / 10;\n\t\t\t}\n\t\t\trequest->delay += request->delay >> 1;\n\n\t\t\t/*\n\t\t\t *\tCap delays at something reasonable.\n\t\t\t */\n\t\t\tif (request->delay > (request->root->max_request_time * USEC)) {\n\t\t\t\trequest->delay = request->root->max_request_time * USEC;\n\t\t\t}\n\n\t\t\trequest->when = now;\n\t\t\ttv_add(&request->when, request->delay);\n\t\t\tcallback = wait_a_bit;\n\t\t\tbreak;\n\t\t}\n\n\t\trequest->master_state = REQUEST_STOP_PROCESSING;\n\n\t\t/*\n\t\t *\tA child thread MAY still be running on the\n\t\t *\trequest.  Ask the thread to stop working on\n\t\t *\tthe request.\n\t\t */\n\t\tif (have_children &&\n\t\t    (pthread_equal(request->child_pid, NO_SUCH_CHILD_PID) == 0)) {\n\t\t\tradlog(L_ERR, \"WARNING: Unresponsive child for request %u, in module %s component %s\",\n\t\t\t       request->number,\n\t\t\t       request->module ? request->module : \"<server core>\",\n\t\t\t       request->component ? request->component : \"<server core>\");\n\t\t}\n\t\t\t\n\t\trequest->delay = USEC;\n\t\ttv_add(&request->when, request->delay);\n\t\tcallback = wait_for_child_to_die;\n\t\tbreak;\n#endif\n\n\t\t/*\n\t\t *\tMark the request as no longer running,\n\t\t *\tand clean it up.\n\t\t */\n\tcase REQUEST_DONE:\n#ifdef HAVE_PTHREAD_H\n\t\trequest->child_pid = NO_SUCH_CHILD_PID;\n#endif\n\n#ifdef WITH_COA\n\t\t/*\n\t\t *\tThis is a CoA request.  It's been divorced\n\t\t *\tfrom everything else, so we clean it up now.\n\t\t */\n\t\tif (!request->in_request_hash &&\n\t\t    request->proxy &&\n\t\t    (request->packet->code != request->proxy->code) &&\n\t\t    ((request->proxy->code == PW_COA_REQUEST) ||\n\t\t     (request->proxy->code == PW_DISCONNECT_REQUEST))) {\n\t\t\t/*\n\t\t\t *\tFIXME: Do CoA MIBs\n\t\t\t */\n\t\t\tev_request_free(&request);\n\t\t\treturn;\n\t\t}\n#endif\n\t\trequest_stats_final(request);\n\t\tcleanup_delay(request);\n\t\treturn;\n\n\tcase REQUEST_REJECT_DELAY:\n\tcase REQUEST_CLEANUP_DELAY:\n#ifdef HAVE_PTHREAD_H\n\t\trequest->child_pid = NO_SUCH_CHILD_PID;\n#endif\n\t\trequest_stats_final(request);\n\n\tcase REQUEST_PROXIED:\n\t\trad_assert(request->next_callback != NULL);\n\t\trad_assert(request->next_callback != wait_a_bit);\n\n\t\trequest->when = request->next_when;\n\t\tcallback = request->next_callback;\n\t\trequest->next_callback = NULL;\n\t\tbreak;\n\n\tdefault:\n\t\trad_panic(\"Internal sanity check failure\");\n\t\treturn;\n\t}\n\n\t/*\n\t *\tSomething major went wrong.  Discard the request, and\n\t *\tkeep running.\n\t *\n\t *\tFIXME: No idea why this happens or how to fix it...\n\t *\tIt seems to happen *only* when requests are proxied,\n\t *\tand where the home server doesn't respond.  So it looks\n\t *\tlike a race condition above, but it happens in debug\n\t *\tmode, with no threads...\n\t */\n\tif (!callback) {\n\t\tRDEBUG(\"WARNING: Internal sanity check failed in event handler for request %u: Discarding the request!\", request->number);\n\t\tev_request_free(&request);\n\t\treturn;\n\t}\n\n\tINSERT_EVENT(callback, request);\n}",
        "start_line": 1116
      }
    ],
    "code_context": "Called Methods:\n- cleanup_delay: static void cleanup_delay(void *ctx) /* <=== cleanup_delay */ \n{\n\tREQUEST *request = ctx;\n\n\trad_assert(request->magic == REQUEST_MAGIC);\n\trad_assert((request->child_state == REQUEST_CLEANUP_DELAY) ||\n\t\t   (request->child_state == REQUEST_DONE));\n\n\tremove_from_request_hash(request);\n\n#ifdef WITH_PROXY\n\tif (request->proxy && request->in_proxy_hash) {\n\t\twait_for_proxy_id_to_expire(request);\n\t\treturn;\n\t}\n#endif\n\n\tRDEBUG2(\"Cleaning up request %u ID %d with timestamp +%d\",\n\t       request->number, request->packet->id,\n\t       (unsigned int) (request->timestamp - fr_start_time));\n\n\tev_request_free(&request);\n}\n- ev_request_free: static void ev_request_free(REQUEST **prequest) /* <=== ev_request_free */ \n{\n\tREQUEST *request;\n\t\n\tif (!prequest || !*prequest) return;\n\n\trequest = *prequest;\n\n#ifdef WITH_COA\n\tif (request->coa) {\n\t\t/*\n\t\t *\tDivorce the child from the parent first,\n\t\t *\tthen clean up the child.\n\t\t */\n\t\trequest->coa->parent = NULL;\n\t\tev_request_free(&request->coa);\n\t}\n\n\t/*\n\t *\tDivorce the parent from the child, and leave the\n\t *\tparent still alive.\n\t */\n\tif (request->parent && (request->parent->coa == request)) {\n\t\trequest->parent->coa = NULL;\n\t}\n#endif\n\n\tif (request->ev) fr_event_delete(el, &request->ev);\n#ifdef WITH_PROXY\n\tif (request->in_proxy_hash) remove_from_proxy_hash(request);\n#endif\n\tif (request->in_request_hash) remove_from_request_hash(request);\n\n\trequest_free(prequest);\n}\n- remove_from_request_hash: static void remove_from_request_hash(REQUEST *request) /* <=== remove_from_request_hash */ \n{\n\tif (!request->in_request_hash) return;\n\n\tfr_packet_list_yank(pl, request->packet);\n\trequest->in_request_hash = FALSE;\n\n\trequest_stats_final(request);\n}\n\nImports:\n- #include <signal.h>\n- #\tinclude <sys/wait.h>\n- #include <fcntl.h>\n- #include <freeradius-devel/detail.h>\n- #include <freeradius-devel/radiusd.h>\n- #include <freeradius-devel/rad_assert.h>\n- #include <freeradius-devel/modules.h>\n- #include <freeradius-devel/ident.h>\n- #include <freeradius-devel/event.h>",
    "commit_msg": "Do not delete \"old\" requests until they are free.\n\nIf the request is in the queue for 30+ seconds, do NOT delete it.\nInstead, mark it as \"STOP PROCESSING\", and do \"wait_for_child_to_die\",\nwhich waits for a child thread to pick it up, and acknowledge that it's\ndone.  Once it's marked done, we can finally clean it up.\n\nThis may be the underlying issue behind bug #35",
    "cve_desc": "The wait_for_child_to_die function in main/event.c in FreeRADIUS 2.1.x before 2.1.10, in certain circumstances involving long-term database outages, does not properly handle long queue times for requests, which allows remote attackers to cause a denial of service (daemon crash) by sending many requests.",
    "year": 2010,
    "filename": "event.c",
    "commit_url": "\"https://github.com/alandekok/freeradius-server/commit/ff94dd35673bba1476594299d31ce8293b8bd223\""
  },
  {
    "repository": "Exim/exim",
    "cve_id": "CVE-2010-4345",
    "cwe_list": [
      "CWE-264"
    ],
    "commit_hash": "fa32850be0d9e605da1b33305c122f7a59a24650",
    "short_hash": "fa32850b",
    "vulnerableMethods_before": [
      {
        "filename": "src/src/daemon.c",
        "method_name": "handle_smtp_call",
        "raw_code": "static void /* <=== handle_smtp_call */ \nhandle_smtp_call(int *listen_sockets, int listen_socket_count,\n  int accept_socket, struct sockaddr *accepted)\n{\npid_t pid;\nunion sockaddr_46 interface_sockaddr;\nEXIM_SOCKLEN_T ifsize = sizeof(interface_sockaddr);\nint dup_accept_socket = -1;\nint max_for_this_host = 0;\nint wfsize = 0;\nint wfptr = 0;\nint use_log_write_selector = log_write_selector;\nuschar *whofrom = NULL;\n\nvoid *reset_point = store_get(0);\n\n/* Make the address available in ASCII representation, and also fish out\nthe remote port. */\n\nsender_host_address = host_ntoa(-1, accepted, NULL, &sender_host_port);\nDEBUG(D_any) debug_printf(\"Connection request from %s port %d\\n\",\n  sender_host_address, sender_host_port);\n\n/* Set up the output stream, check the socket has duplicated, and set up the\ninput stream. These operations fail only the exceptional circumstances. Note\nthat never_error() won't use smtp_out if it is NULL. */\n\nsmtp_out = fdopen(accept_socket, \"wb\");\nif (smtp_out == NULL)\n  {\n  never_error(US\"daemon: fdopen() for smtp_out failed\", US\"\", errno);\n  goto ERROR_RETURN;\n  }\n\ndup_accept_socket = dup(accept_socket);\nif (dup_accept_socket < 0)\n  {\n  never_error(US\"daemon: couldn't dup socket descriptor\",\n    US\"Connection setup failed\", errno);\n  goto ERROR_RETURN;\n  }\n\nsmtp_in = fdopen(dup_accept_socket, \"rb\");\nif (smtp_in == NULL)\n  {\n  never_error(US\"daemon: fdopen() for smtp_in failed\",\n    US\"Connection setup failed\", errno);\n  goto ERROR_RETURN;\n  }\n\n/* Get the data for the local interface address. Panic for most errors, but\n\"connection reset by peer\" just means the connection went away. */\n\nif (getsockname(accept_socket, (struct sockaddr *)(&interface_sockaddr),\n     &ifsize) < 0)\n  {\n  log_write(0, LOG_MAIN | ((errno == ECONNRESET)? 0 : LOG_PANIC),\n    \"getsockname() failed: %s\", strerror(errno));\n  smtp_printf(\"421 Local problem: getsockname() failed; please try again later\\r\\n\");\n  goto ERROR_RETURN;\n  }\n\ninterface_address = host_ntoa(-1, &interface_sockaddr, NULL, &interface_port);\nDEBUG(D_interface) debug_printf(\"interface address=%s port=%d\\n\",\n  interface_address, interface_port);\n\n/* Build a string identifying the remote host and, if requested, the port and\nthe local interface data. This is for logging; at the end of this function the\nmemory is reclaimed. */\n\nwhofrom = string_append(whofrom, &wfsize, &wfptr, 3, \"[\", sender_host_address, \"]\");\n\nif ((log_extra_selector & LX_incoming_port) != 0)\n  whofrom = string_append(whofrom, &wfsize, &wfptr, 2, \":\", string_sprintf(\"%d\",\n    sender_host_port));\n\nif ((log_extra_selector & LX_incoming_interface) != 0)\n  whofrom = string_append(whofrom, &wfsize, &wfptr, 4, \" I=[\",\n    interface_address, \"]:\", string_sprintf(\"%d\", interface_port));\n\nwhofrom[wfptr] = 0;    /* Terminate the newly-built string */\n\n/* Check maximum number of connections. We do not check for reserved\nconnections or unacceptable hosts here. That is done in the subprocess because\nit might take some time. */\n\nif (smtp_accept_max > 0 && smtp_accept_count >= smtp_accept_max)\n  {\n  DEBUG(D_any) debug_printf(\"rejecting SMTP connection: count=%d max=%d\\n\",\n    smtp_accept_count, smtp_accept_max);\n  smtp_printf(\"421 Too many concurrent SMTP connections; \"\n    \"please try again later.\\r\\n\");\n  log_write(L_connection_reject,\n            LOG_MAIN, \"Connection from %s refused: too many connections\",\n    whofrom);\n  goto ERROR_RETURN;\n  }\n\n/* If a load limit above which only reserved hosts are acceptable is defined,\nget the load average here, and if there are in fact no reserved hosts, do\nthe test right away (saves a fork). If there are hosts, do the check in the\nsubprocess because it might take time. */\n\nif (smtp_load_reserve >= 0)\n  {\n  load_average = OS_GETLOADAVG();\n  if (smtp_reserve_hosts == NULL && load_average > smtp_load_reserve)\n    {\n    DEBUG(D_any) debug_printf(\"rejecting SMTP connection: load average = %.2f\\n\",\n      (double)load_average/1000.0);\n    smtp_printf(\"421 Too much load; please try again later.\\r\\n\");\n    log_write(L_connection_reject,\n              LOG_MAIN, \"Connection from %s refused: load average = %.2f\",\n      whofrom, (double)load_average/1000.0);\n    goto ERROR_RETURN;\n    }\n  }\n\n/* Check that one specific host (strictly, IP address) is not hogging\nresources. This is done here to prevent a denial of service attack by someone\nforcing you to fork lots of times before denying service. The value of\nsmtp_accept_max_per_host is a string which is expanded. This makes it possible\nto provide host-specific limits according to $sender_host address, but because\nthis is in the daemon mainline, only fast expansions (such as inline address\nchecks) should be used. The documentation is full of warnings. */\n\nif (smtp_accept_max_per_host != NULL)\n  {\n  uschar *expanded = expand_string(smtp_accept_max_per_host);\n  if (expanded == NULL)\n    {\n    if (!expand_string_forcedfail)\n      log_write(0, LOG_MAIN|LOG_PANIC, \"expansion of smtp_accept_max_per_host \"\n        \"failed for %s: %s\", whofrom, expand_string_message);\n    }\n  /* For speed, interpret a decimal number inline here */\n  else\n    {\n    uschar *s = expanded;\n    while (isdigit(*s))\n      max_for_this_host = max_for_this_host * 10 + *s++ - '0';\n    if (*s != 0)\n      log_write(0, LOG_MAIN|LOG_PANIC, \"expansion of smtp_accept_max_per_host \"\n        \"for %s contains non-digit: %s\", whofrom, expanded);\n    }\n  }\n\n/* If we have fewer connections than max_for_this_host, we can skip the tedious\nper host_address checks. Note that at this stage smtp_accept_count contains the\ncount of *other* connections, not including this one. */\n\nif ((max_for_this_host > 0) &&\n    (smtp_accept_count >= max_for_this_host))\n  {\n  int i;\n  int host_accept_count = 0;\n  int other_host_count = 0;    /* keep a count of non matches to optimise */\n\n  for (i = 0; i < smtp_accept_max; ++i)\n    {\n    if (smtp_slots[i].host_address != NULL)\n      {\n      if (Ustrcmp(sender_host_address, smtp_slots[i].host_address) == 0)\n       host_accept_count++;\n      else\n       other_host_count++;\n\n      /* Testing all these strings is expensive - see if we can drop out\n      early, either by hitting the target, or finding there are not enough\n      connections left to make the target. */\n\n      if ((host_accept_count >= max_for_this_host) ||\n         ((smtp_accept_count - other_host_count) < max_for_this_host))\n       break;\n      }\n    }\n\n  if (host_accept_count >= max_for_this_host)\n    {\n    DEBUG(D_any) debug_printf(\"rejecting SMTP connection: too many from this \"\n      \"IP address: count=%d max=%d\\n\",\n      host_accept_count, max_for_this_host);\n    smtp_printf(\"421 Too many concurrent SMTP connections \"\n      \"from this IP address; please try again later.\\r\\n\");\n    log_write(L_connection_reject,\n              LOG_MAIN, \"Connection from %s refused: too many connections \"\n      \"from that IP address\", whofrom);\n    goto ERROR_RETURN;\n    }\n  }\n\n/* OK, the connection count checks have been passed. Before we can fork the\naccepting process, we must first log the connection if requested. This logging\nused to happen in the subprocess, but doing that means that the value of\nsmtp_accept_count can be out of step by the time it is logged. So we have to do\nthe logging here and accept the performance cost. Note that smtp_accept_count\nhasn't yet been incremented to take account of this connection.\n\nIn order to minimize the cost (because this is going to happen for every\nconnection), do a preliminary selector test here. This saves ploughing through\nthe generalized logging code each time when the selector is false. If the\nselector is set, check whether the host is on the list for logging. If not,\narrange to unset the selector in the subprocess. */\n\nif ((log_write_selector & L_smtp_connection) != 0)\n  {\n  uschar *list = hosts_connection_nolog;\n  if (list != NULL && verify_check_host(&list) == OK)\n    use_log_write_selector &= ~L_smtp_connection;\n  else\n    log_write(L_smtp_connection, LOG_MAIN, \"SMTP connection from %s \"\n      \"(TCP/IP connection count = %d)\", whofrom, smtp_accept_count + 1);\n  }\n\n/* Now we can fork the accepting process; do a lookup tidy, just in case any\nexpansion above did a lookup. */\n\nsearch_tidyup();\npid = fork();\n\n/* Handle the child process */\n\nif (pid == 0)\n  {\n  int i;\n  int queue_only_reason = 0;\n  int old_pool = store_pool;\n  int save_debug_selector = debug_selector;\n  BOOL local_queue_only;\n  BOOL session_local_queue_only;\n  #ifdef SA_NOCLDWAIT\n  struct sigaction act;\n  #endif\n\n  smtp_accept_count++;    /* So that it includes this process */\n\n  /* May have been modified for the subprocess */\n\n  log_write_selector = use_log_write_selector;\n\n  /* Get the local interface address into permanent store */\n\n  store_pool = POOL_PERM;\n  interface_address = string_copy(interface_address);\n  store_pool = old_pool;\n\n  /* Check for a tls-on-connect port */\n\n  if (host_is_tls_on_connect_port(interface_port)) tls_on_connect = TRUE;\n\n  /* Expand smtp_active_hostname if required. We do not do this any earlier,\n  because it may depend on the local interface address (indeed, that is most\n  likely what it depends on.) */\n\n  smtp_active_hostname = primary_hostname;\n  if (raw_active_hostname != NULL)\n    {\n    uschar *nah = expand_string(raw_active_hostname);\n    if (nah == NULL)\n      {\n      if (!expand_string_forcedfail)\n        {\n        log_write(0, LOG_MAIN|LOG_PANIC, \"failed to expand \\\"%s\\\" \"\n          \"(smtp_active_hostname): %s\", raw_active_hostname,\n          expand_string_message);\n        smtp_printf(\"421 Local configuration error; \"\n          \"please try again later.\\r\\n\");\n        mac_smtp_fflush();\n        search_tidyup();\n        _exit(EXIT_FAILURE);\n        }\n      }\n    else if (nah[0] != 0) smtp_active_hostname = nah;\n    }\n\n  /* Initialize the queueing flags */\n\n  queue_check_only();\n  session_local_queue_only = queue_only;\n\n  /* Close the listening sockets, and set the SIGCHLD handler to SIG_IGN.\n  We also attempt to set things up so that children are automatically reaped,\n  but just in case this isn't available, there's a paranoid waitpid() in the\n  loop too (except for systems where we are sure it isn't needed). See the more\n  extensive comment before the reception loop in exim.c for a fuller\n  explanation of this logic. */\n\n  for (i = 0; i < listen_socket_count; i++) (void)close(listen_sockets[i]);\n\n  #ifdef SA_NOCLDWAIT\n  act.sa_handler = SIG_IGN;\n  sigemptyset(&(act.sa_mask));\n  act.sa_flags = SA_NOCLDWAIT;\n  sigaction(SIGCHLD, &act, NULL);\n  #else\n  signal(SIGCHLD, SIG_IGN);\n  #endif\n\n  /* Attempt to get an id from the sending machine via the RFC 1413\n  protocol. We do this in the sub-process in order not to hold up the\n  main process if there is any delay. Then set up the fullhost information\n  in case there is no HELO/EHLO.\n\n  If debugging is enabled only for the daemon, we must turn if off while\n  finding the id, but turn it on again afterwards so that information about the\n  incoming connection is output. */\n\n  if (debug_daemon) debug_selector = 0;\n  verify_get_ident(IDENT_PORT);\n  host_build_sender_fullhost();\n  debug_selector = save_debug_selector;\n\n  DEBUG(D_any)\n    debug_printf(\"Process %d is handling incoming connection from %s\\n\",\n      (int)getpid(), sender_fullhost);\n\n  /* Now disable debugging permanently if it's required only for the daemon\n  process. */\n\n  if (debug_daemon) debug_selector = 0;\n\n  /* If there are too many child processes for immediate delivery,\n  set the session_local_queue_only flag, which is initialized from the\n  configured value and may therefore already be TRUE. Leave logging\n  till later so it will have a message id attached. Note that there is no\n  possibility of re-calculating this per-message, because the value of\n  smtp_accept_count does not change in this subprocess. */\n\n  if (smtp_accept_queue > 0 && smtp_accept_count > smtp_accept_queue)\n    {\n    session_local_queue_only = TRUE;\n    queue_only_reason = 1;\n    }\n\n  /* Handle the start of the SMTP session, then loop, accepting incoming\n  messages from the SMTP connection. The end will come at the QUIT command,\n  when smtp_setup_msg() returns 0. A break in the connection causes the\n  process to die (see accept.c).\n\n  NOTE: We do *not* call smtp_log_no_mail() if smtp_start_session() fails,\n  because a log line has already been written for all its failure exists\n  (usually \"connection refused: <reason>\") and writing another one is\n  unnecessary clutter. */\n\n  if (!smtp_start_session())\n    {\n    mac_smtp_fflush();\n    search_tidyup();\n    _exit(EXIT_SUCCESS);\n    }\n\n  for (;;)\n    {\n    int rc;\n    message_id[0] = 0;            /* Clear out any previous message_id */\n    reset_point = store_get(0);   /* Save current store high water point */\n\n    DEBUG(D_any)\n      debug_printf(\"Process %d is ready for new message\\n\", (int)getpid());\n\n    /* Smtp_setup_msg() returns 0 on QUIT or if the call is from an\n    unacceptable host or if an ACL \"drop\" command was triggered, -1 on\n    connection lost, and +1 on validly reaching DATA. Receive_msg() almost\n    always returns TRUE when smtp_input is true; just retry if no message was\n    accepted (can happen for invalid message parameters). However, it can yield\n    FALSE if the connection was forcibly dropped by the DATA ACL. */\n\n    if ((rc = smtp_setup_msg()) > 0)\n      {\n      BOOL ok = receive_msg(FALSE);\n      search_tidyup();                    /* Close cached databases */\n      if (!ok)                            /* Connection was dropped */\n        {\n        mac_smtp_fflush();\n        smtp_log_no_mail();               /* Log no mail if configured */\n        _exit(EXIT_SUCCESS);\n        }\n      if (message_id[0] == 0) continue;   /* No message was accepted */\n      }\n    else\n      {\n      mac_smtp_fflush();\n      search_tidyup();\n      smtp_log_no_mail();                 /* Log no mail if configured */\n      _exit((rc == 0)? EXIT_SUCCESS : EXIT_FAILURE);\n      }\n\n    /* Show the recipients when debugging */\n\n    DEBUG(D_receive)\n      {\n      int i;\n      if (sender_address != NULL)\n        debug_printf(\"Sender: %s\\n\", sender_address);\n      if (recipients_list != NULL)\n        {\n        debug_printf(\"Recipients:\\n\");\n        for (i = 0; i < recipients_count; i++)\n          debug_printf(\"  %s\\n\", recipients_list[i].address);\n        }\n      }\n\n    /* A message has been accepted. Clean up any previous delivery processes\n    that have completed and are defunct, on systems where they don't go away\n    by themselves (see comments when setting SIG_IGN above). On such systems\n    (if any) these delivery processes hang around after termination until\n    the next message is received. */\n\n    #ifndef SIG_IGN_WORKS\n    while (waitpid(-1, NULL, WNOHANG) > 0);\n    #endif\n\n    /* Reclaim up the store used in accepting this message */\n\n    store_reset(reset_point);\n\n    /* If queue_only is set or if there are too many incoming connections in\n    existence, session_local_queue_only will be TRUE. If it is not, check\n    whether we have received too many messages in this session for immediate\n    delivery. */\n\n    if (!session_local_queue_only &&\n        smtp_accept_queue_per_connection > 0 &&\n        receive_messagecount > smtp_accept_queue_per_connection)\n      {\n      session_local_queue_only = TRUE;\n      queue_only_reason = 2;\n      }\n\n    /* Initialize local_queue_only from session_local_queue_only. If it is not\n    true, and queue_only_load is set, check that the load average is below it.\n    If local_queue_only is set by this means, we also set if for the session if\n    queue_only_load_latch is true (the default). This means that, once set,\n    local_queue_only remains set for any subsequent messages on the same SMTP\n    connection. This is a deliberate choice; even though the load average may\n    fall, it doesn't seem right to deliver later messages on the same call when\n    not delivering earlier ones. However, the are special circumstances such as\n    very long-lived connections from scanning appliances where this is not the\n    best strategy. In such cases, queue_only_load_latch should be set false. */\n\n    local_queue_only = session_local_queue_only;\n    if (!local_queue_only && queue_only_load >= 0)\n      {\n      local_queue_only = (load_average = OS_GETLOADAVG()) > queue_only_load;\n      if (local_queue_only)\n        {\n        queue_only_reason = 3;\n        if (queue_only_load_latch) session_local_queue_only = TRUE;\n        }\n      }\n\n    /* Log the queueing here, when it will get a message id attached, but\n    not if queue_only is set (case 0). */\n\n    if (local_queue_only) switch(queue_only_reason)\n      {\n      case 1:\n      log_write(L_delay_delivery,\n                LOG_MAIN, \"no immediate delivery: too many connections \"\n                \"(%d, max %d)\", smtp_accept_count, smtp_accept_queue);\n      break;\n\n      case 2:\n      log_write(L_delay_delivery,\n                LOG_MAIN, \"no immediate delivery: more than %d messages \"\n                \"received in one connection\", smtp_accept_queue_per_connection);\n      break;\n\n      case 3:\n      log_write(L_delay_delivery,\n                LOG_MAIN, \"no immediate delivery: load average %.2f\",\n                (double)load_average/1000.0);\n      break;\n      }\n\n    /* If a delivery attempt is required, spin off a new process to handle it.\n    If we are not root, we have to re-exec exim unless deliveries are being\n    done unprivileged. */\n\n    else if (!queue_only_policy && !deliver_freeze)\n      {\n      pid_t dpid;\n\n      /* Before forking, ensure that the C output buffer is flushed. Otherwise\n      anything that it in it will get duplicated, leading to duplicate copies\n      of the pending output. */\n\n      mac_smtp_fflush();\n\n      if ((dpid = fork()) == 0)\n        {\n        (void)fclose(smtp_in);\n        (void)fclose(smtp_out);\n\n        /* Don't ever molest the parent's SSL connection, but do clean up\n        the data structures if necessary. */\n\n        #ifdef SUPPORT_TLS\n        tls_close(FALSE);\n        #endif\n\n        /* Reset SIGHUP and SIGCHLD in the child in both cases. */\n\n        signal(SIGHUP,  SIG_DFL);\n        signal(SIGCHLD, SIG_DFL);\n\n        if (geteuid() != root_uid && !deliver_drop_privilege)\n          {\n          signal(SIGALRM, SIG_DFL);\n          (void)child_exec_exim(CEE_EXEC_PANIC, FALSE, NULL, FALSE, 2, US\"-Mc\",\n            message_id);\n          /* Control does not return here. */\n          }\n\n        /* No need to re-exec; SIGALRM remains set to the default handler */\n\n        (void)deliver_message(message_id, FALSE, FALSE);\n        search_tidyup();\n        _exit(EXIT_SUCCESS);\n        }\n\n      if (dpid > 0)\n        {\n        DEBUG(D_any) debug_printf(\"forked delivery process %d\\n\", (int)dpid);\n        }\n      else\n        {\n        log_write(0, LOG_MAIN|LOG_PANIC, \"daemon: delivery process fork \"\n          \"failed: %s\", strerror(errno));\n        }\n      }\n    }\n  }\n\n\n/* Carrying on in the parent daemon process... Can't do much if the fork\nfailed. Otherwise, keep count of the number of accepting processes and\nremember the pid for ticking off when the child completes. */\n\nif (pid < 0)\n  {\n  never_error(US\"daemon: accept process fork failed\", US\"Fork failed\", errno);\n  }\nelse\n  {\n  int i;\n  for (i = 0; i < smtp_accept_max; ++i)\n    {\n    if (smtp_slots[i].pid <= 0)\n      {\n      smtp_slots[i].pid = pid;\n      if (smtp_accept_max_per_host != NULL)\n        smtp_slots[i].host_address = string_copy_malloc(sender_host_address);\n      smtp_accept_count++;\n      break;\n      }\n    }\n  DEBUG(D_any) debug_printf(\"%d SMTP accept process%s running\\n\",\n    smtp_accept_count, (smtp_accept_count == 1)? \"\" : \"es\");\n  }\n\n/* Get here via goto in error cases */\n\nERROR_RETURN:\n\n/* Close the streams associated with the socket which will also close the\nsocket fds in this process. We can't do anything if fclose() fails, but\nlogging brings it to someone's attention. However, \"connection reset by peer\"\nisn't really a problem, so skip that one. On Solaris, a dropped connection can\nmanifest itself as a broken pipe, so drop that one too. If the streams don't\nexist, something went wrong while setting things up. Make sure the socket\ndescriptors are closed, in order to drop the connection. */\n\nif (smtp_out != NULL)\n  {\n  if (fclose(smtp_out) != 0 && errno != ECONNRESET && errno != EPIPE)\n    log_write(0, LOG_MAIN|LOG_PANIC, \"daemon: fclose(smtp_out) failed: %s\",\n      strerror(errno));\n  smtp_out = NULL;\n  }\nelse (void)close(accept_socket);\n\nif (smtp_in != NULL)\n  {\n  if (fclose(smtp_in) != 0 && errno != ECONNRESET && errno != EPIPE)\n    log_write(0, LOG_MAIN|LOG_PANIC, \"daemon: fclose(smtp_in) failed: %s\",\n      strerror(errno));\n  smtp_in = NULL;\n  }\nelse (void)close(dup_accept_socket);\n\n/* Release any store used in this process, including the store used for holding\nthe incoming host address and an expanded active_hostname. */\n\nstore_reset(reset_point);\nsender_host_address = NULL;\n}",
        "start_line": 139
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "src/src/daemon.c",
        "method_name": "handle_smtp_call",
        "raw_code": "static void /* <=== handle_smtp_call */ \nhandle_smtp_call(int *listen_sockets, int listen_socket_count,\n  int accept_socket, struct sockaddr *accepted)\n{\npid_t pid;\nunion sockaddr_46 interface_sockaddr;\nEXIM_SOCKLEN_T ifsize = sizeof(interface_sockaddr);\nint dup_accept_socket = -1;\nint max_for_this_host = 0;\nint wfsize = 0;\nint wfptr = 0;\nint use_log_write_selector = log_write_selector;\nuschar *whofrom = NULL;\n\nvoid *reset_point = store_get(0);\n\n/* Make the address available in ASCII representation, and also fish out\nthe remote port. */\n\nsender_host_address = host_ntoa(-1, accepted, NULL, &sender_host_port);\nDEBUG(D_any) debug_printf(\"Connection request from %s port %d\\n\",\n  sender_host_address, sender_host_port);\n\n/* Set up the output stream, check the socket has duplicated, and set up the\ninput stream. These operations fail only the exceptional circumstances. Note\nthat never_error() won't use smtp_out if it is NULL. */\n\nsmtp_out = fdopen(accept_socket, \"wb\");\nif (smtp_out == NULL)\n  {\n  never_error(US\"daemon: fdopen() for smtp_out failed\", US\"\", errno);\n  goto ERROR_RETURN;\n  }\n\ndup_accept_socket = dup(accept_socket);\nif (dup_accept_socket < 0)\n  {\n  never_error(US\"daemon: couldn't dup socket descriptor\",\n    US\"Connection setup failed\", errno);\n  goto ERROR_RETURN;\n  }\n\nsmtp_in = fdopen(dup_accept_socket, \"rb\");\nif (smtp_in == NULL)\n  {\n  never_error(US\"daemon: fdopen() for smtp_in failed\",\n    US\"Connection setup failed\", errno);\n  goto ERROR_RETURN;\n  }\n\n/* Get the data for the local interface address. Panic for most errors, but\n\"connection reset by peer\" just means the connection went away. */\n\nif (getsockname(accept_socket, (struct sockaddr *)(&interface_sockaddr),\n     &ifsize) < 0)\n  {\n  log_write(0, LOG_MAIN | ((errno == ECONNRESET)? 0 : LOG_PANIC),\n    \"getsockname() failed: %s\", strerror(errno));\n  smtp_printf(\"421 Local problem: getsockname() failed; please try again later\\r\\n\");\n  goto ERROR_RETURN;\n  }\n\ninterface_address = host_ntoa(-1, &interface_sockaddr, NULL, &interface_port);\nDEBUG(D_interface) debug_printf(\"interface address=%s port=%d\\n\",\n  interface_address, interface_port);\n\n/* Build a string identifying the remote host and, if requested, the port and\nthe local interface data. This is for logging; at the end of this function the\nmemory is reclaimed. */\n\nwhofrom = string_append(whofrom, &wfsize, &wfptr, 3, \"[\", sender_host_address, \"]\");\n\nif ((log_extra_selector & LX_incoming_port) != 0)\n  whofrom = string_append(whofrom, &wfsize, &wfptr, 2, \":\", string_sprintf(\"%d\",\n    sender_host_port));\n\nif ((log_extra_selector & LX_incoming_interface) != 0)\n  whofrom = string_append(whofrom, &wfsize, &wfptr, 4, \" I=[\",\n    interface_address, \"]:\", string_sprintf(\"%d\", interface_port));\n\nwhofrom[wfptr] = 0;    /* Terminate the newly-built string */\n\n/* Check maximum number of connections. We do not check for reserved\nconnections or unacceptable hosts here. That is done in the subprocess because\nit might take some time. */\n\nif (smtp_accept_max > 0 && smtp_accept_count >= smtp_accept_max)\n  {\n  DEBUG(D_any) debug_printf(\"rejecting SMTP connection: count=%d max=%d\\n\",\n    smtp_accept_count, smtp_accept_max);\n  smtp_printf(\"421 Too many concurrent SMTP connections; \"\n    \"please try again later.\\r\\n\");\n  log_write(L_connection_reject,\n            LOG_MAIN, \"Connection from %s refused: too many connections\",\n    whofrom);\n  goto ERROR_RETURN;\n  }\n\n/* If a load limit above which only reserved hosts are acceptable is defined,\nget the load average here, and if there are in fact no reserved hosts, do\nthe test right away (saves a fork). If there are hosts, do the check in the\nsubprocess because it might take time. */\n\nif (smtp_load_reserve >= 0)\n  {\n  load_average = OS_GETLOADAVG();\n  if (smtp_reserve_hosts == NULL && load_average > smtp_load_reserve)\n    {\n    DEBUG(D_any) debug_printf(\"rejecting SMTP connection: load average = %.2f\\n\",\n      (double)load_average/1000.0);\n    smtp_printf(\"421 Too much load; please try again later.\\r\\n\");\n    log_write(L_connection_reject,\n              LOG_MAIN, \"Connection from %s refused: load average = %.2f\",\n      whofrom, (double)load_average/1000.0);\n    goto ERROR_RETURN;\n    }\n  }\n\n/* Check that one specific host (strictly, IP address) is not hogging\nresources. This is done here to prevent a denial of service attack by someone\nforcing you to fork lots of times before denying service. The value of\nsmtp_accept_max_per_host is a string which is expanded. This makes it possible\nto provide host-specific limits according to $sender_host address, but because\nthis is in the daemon mainline, only fast expansions (such as inline address\nchecks) should be used. The documentation is full of warnings. */\n\nif (smtp_accept_max_per_host != NULL)\n  {\n  uschar *expanded = expand_string(smtp_accept_max_per_host);\n  if (expanded == NULL)\n    {\n    if (!expand_string_forcedfail)\n      log_write(0, LOG_MAIN|LOG_PANIC, \"expansion of smtp_accept_max_per_host \"\n        \"failed for %s: %s\", whofrom, expand_string_message);\n    }\n  /* For speed, interpret a decimal number inline here */\n  else\n    {\n    uschar *s = expanded;\n    while (isdigit(*s))\n      max_for_this_host = max_for_this_host * 10 + *s++ - '0';\n    if (*s != 0)\n      log_write(0, LOG_MAIN|LOG_PANIC, \"expansion of smtp_accept_max_per_host \"\n        \"for %s contains non-digit: %s\", whofrom, expanded);\n    }\n  }\n\n/* If we have fewer connections than max_for_this_host, we can skip the tedious\nper host_address checks. Note that at this stage smtp_accept_count contains the\ncount of *other* connections, not including this one. */\n\nif ((max_for_this_host > 0) &&\n    (smtp_accept_count >= max_for_this_host))\n  {\n  int i;\n  int host_accept_count = 0;\n  int other_host_count = 0;    /* keep a count of non matches to optimise */\n\n  for (i = 0; i < smtp_accept_max; ++i)\n    {\n    if (smtp_slots[i].host_address != NULL)\n      {\n      if (Ustrcmp(sender_host_address, smtp_slots[i].host_address) == 0)\n       host_accept_count++;\n      else\n       other_host_count++;\n\n      /* Testing all these strings is expensive - see if we can drop out\n      early, either by hitting the target, or finding there are not enough\n      connections left to make the target. */\n\n      if ((host_accept_count >= max_for_this_host) ||\n         ((smtp_accept_count - other_host_count) < max_for_this_host))\n       break;\n      }\n    }\n\n  if (host_accept_count >= max_for_this_host)\n    {\n    DEBUG(D_any) debug_printf(\"rejecting SMTP connection: too many from this \"\n      \"IP address: count=%d max=%d\\n\",\n      host_accept_count, max_for_this_host);\n    smtp_printf(\"421 Too many concurrent SMTP connections \"\n      \"from this IP address; please try again later.\\r\\n\");\n    log_write(L_connection_reject,\n              LOG_MAIN, \"Connection from %s refused: too many connections \"\n      \"from that IP address\", whofrom);\n    goto ERROR_RETURN;\n    }\n  }\n\n/* OK, the connection count checks have been passed. Before we can fork the\naccepting process, we must first log the connection if requested. This logging\nused to happen in the subprocess, but doing that means that the value of\nsmtp_accept_count can be out of step by the time it is logged. So we have to do\nthe logging here and accept the performance cost. Note that smtp_accept_count\nhasn't yet been incremented to take account of this connection.\n\nIn order to minimize the cost (because this is going to happen for every\nconnection), do a preliminary selector test here. This saves ploughing through\nthe generalized logging code each time when the selector is false. If the\nselector is set, check whether the host is on the list for logging. If not,\narrange to unset the selector in the subprocess. */\n\nif ((log_write_selector & L_smtp_connection) != 0)\n  {\n  uschar *list = hosts_connection_nolog;\n  if (list != NULL && verify_check_host(&list) == OK)\n    use_log_write_selector &= ~L_smtp_connection;\n  else\n    log_write(L_smtp_connection, LOG_MAIN, \"SMTP connection from %s \"\n      \"(TCP/IP connection count = %d)\", whofrom, smtp_accept_count + 1);\n  }\n\n/* Now we can fork the accepting process; do a lookup tidy, just in case any\nexpansion above did a lookup. */\n\nsearch_tidyup();\npid = fork();\n\n/* Handle the child process */\n\nif (pid == 0)\n  {\n  int i;\n  int queue_only_reason = 0;\n  int old_pool = store_pool;\n  int save_debug_selector = debug_selector;\n  BOOL local_queue_only;\n  BOOL session_local_queue_only;\n  #ifdef SA_NOCLDWAIT\n  struct sigaction act;\n  #endif\n\n  smtp_accept_count++;    /* So that it includes this process */\n\n  /* May have been modified for the subprocess */\n\n  log_write_selector = use_log_write_selector;\n\n  /* Get the local interface address into permanent store */\n\n  store_pool = POOL_PERM;\n  interface_address = string_copy(interface_address);\n  store_pool = old_pool;\n\n  /* Check for a tls-on-connect port */\n\n  if (host_is_tls_on_connect_port(interface_port)) tls_on_connect = TRUE;\n\n  /* Expand smtp_active_hostname if required. We do not do this any earlier,\n  because it may depend on the local interface address (indeed, that is most\n  likely what it depends on.) */\n\n  smtp_active_hostname = primary_hostname;\n  if (raw_active_hostname != NULL)\n    {\n    uschar *nah = expand_string(raw_active_hostname);\n    if (nah == NULL)\n      {\n      if (!expand_string_forcedfail)\n        {\n        log_write(0, LOG_MAIN|LOG_PANIC, \"failed to expand \\\"%s\\\" \"\n          \"(smtp_active_hostname): %s\", raw_active_hostname,\n          expand_string_message);\n        smtp_printf(\"421 Local configuration error; \"\n          \"please try again later.\\r\\n\");\n        mac_smtp_fflush();\n        search_tidyup();\n        _exit(EXIT_FAILURE);\n        }\n      }\n    else if (nah[0] != 0) smtp_active_hostname = nah;\n    }\n\n  /* Initialize the queueing flags */\n\n  queue_check_only();\n  session_local_queue_only = queue_only;\n\n  /* Close the listening sockets, and set the SIGCHLD handler to SIG_IGN.\n  We also attempt to set things up so that children are automatically reaped,\n  but just in case this isn't available, there's a paranoid waitpid() in the\n  loop too (except for systems where we are sure it isn't needed). See the more\n  extensive comment before the reception loop in exim.c for a fuller\n  explanation of this logic. */\n\n  for (i = 0; i < listen_socket_count; i++) (void)close(listen_sockets[i]);\n\n  /* Set FD_CLOEXEC on the SMTP socket. We don't want any rogue child processes\n  to be able to communicate with them, under any circumstances. */\n  (void)fcntl(accept_socket, F_SETFD,\n              fcntl(accept_socket, F_GETFD) | FD_CLOEXEC);\n  (void)fcntl(dup_accept_socket, F_SETFD,\n              fcntl(dup_accept_socket, F_GETFD) | FD_CLOEXEC);\n\n  #ifdef SA_NOCLDWAIT\n  act.sa_handler = SIG_IGN;\n  sigemptyset(&(act.sa_mask));\n  act.sa_flags = SA_NOCLDWAIT;\n  sigaction(SIGCHLD, &act, NULL);\n  #else\n  signal(SIGCHLD, SIG_IGN);\n  #endif\n\n  /* Attempt to get an id from the sending machine via the RFC 1413\n  protocol. We do this in the sub-process in order not to hold up the\n  main process if there is any delay. Then set up the fullhost information\n  in case there is no HELO/EHLO.\n\n  If debugging is enabled only for the daemon, we must turn if off while\n  finding the id, but turn it on again afterwards so that information about the\n  incoming connection is output. */\n\n  if (debug_daemon) debug_selector = 0;\n  verify_get_ident(IDENT_PORT);\n  host_build_sender_fullhost();\n  debug_selector = save_debug_selector;\n\n  DEBUG(D_any)\n    debug_printf(\"Process %d is handling incoming connection from %s\\n\",\n      (int)getpid(), sender_fullhost);\n\n  /* Now disable debugging permanently if it's required only for the daemon\n  process. */\n\n  if (debug_daemon) debug_selector = 0;\n\n  /* If there are too many child processes for immediate delivery,\n  set the session_local_queue_only flag, which is initialized from the\n  configured value and may therefore already be TRUE. Leave logging\n  till later so it will have a message id attached. Note that there is no\n  possibility of re-calculating this per-message, because the value of\n  smtp_accept_count does not change in this subprocess. */\n\n  if (smtp_accept_queue > 0 && smtp_accept_count > smtp_accept_queue)\n    {\n    session_local_queue_only = TRUE;\n    queue_only_reason = 1;\n    }\n\n  /* Handle the start of the SMTP session, then loop, accepting incoming\n  messages from the SMTP connection. The end will come at the QUIT command,\n  when smtp_setup_msg() returns 0. A break in the connection causes the\n  process to die (see accept.c).\n\n  NOTE: We do *not* call smtp_log_no_mail() if smtp_start_session() fails,\n  because a log line has already been written for all its failure exists\n  (usually \"connection refused: <reason>\") and writing another one is\n  unnecessary clutter. */\n\n  if (!smtp_start_session())\n    {\n    mac_smtp_fflush();\n    search_tidyup();\n    _exit(EXIT_SUCCESS);\n    }\n\n  for (;;)\n    {\n    int rc;\n    message_id[0] = 0;            /* Clear out any previous message_id */\n    reset_point = store_get(0);   /* Save current store high water point */\n\n    DEBUG(D_any)\n      debug_printf(\"Process %d is ready for new message\\n\", (int)getpid());\n\n    /* Smtp_setup_msg() returns 0 on QUIT or if the call is from an\n    unacceptable host or if an ACL \"drop\" command was triggered, -1 on\n    connection lost, and +1 on validly reaching DATA. Receive_msg() almost\n    always returns TRUE when smtp_input is true; just retry if no message was\n    accepted (can happen for invalid message parameters). However, it can yield\n    FALSE if the connection was forcibly dropped by the DATA ACL. */\n\n    if ((rc = smtp_setup_msg()) > 0)\n      {\n      BOOL ok = receive_msg(FALSE);\n      search_tidyup();                    /* Close cached databases */\n      if (!ok)                            /* Connection was dropped */\n        {\n        mac_smtp_fflush();\n        smtp_log_no_mail();               /* Log no mail if configured */\n        _exit(EXIT_SUCCESS);\n        }\n      if (message_id[0] == 0) continue;   /* No message was accepted */\n      }\n    else\n      {\n      mac_smtp_fflush();\n      search_tidyup();\n      smtp_log_no_mail();                 /* Log no mail if configured */\n      _exit((rc == 0)? EXIT_SUCCESS : EXIT_FAILURE);\n      }\n\n    /* Show the recipients when debugging */\n\n    DEBUG(D_receive)\n      {\n      int i;\n      if (sender_address != NULL)\n        debug_printf(\"Sender: %s\\n\", sender_address);\n      if (recipients_list != NULL)\n        {\n        debug_printf(\"Recipients:\\n\");\n        for (i = 0; i < recipients_count; i++)\n          debug_printf(\"  %s\\n\", recipients_list[i].address);\n        }\n      }\n\n    /* A message has been accepted. Clean up any previous delivery processes\n    that have completed and are defunct, on systems where they don't go away\n    by themselves (see comments when setting SIG_IGN above). On such systems\n    (if any) these delivery processes hang around after termination until\n    the next message is received. */\n\n    #ifndef SIG_IGN_WORKS\n    while (waitpid(-1, NULL, WNOHANG) > 0);\n    #endif\n\n    /* Reclaim up the store used in accepting this message */\n\n    store_reset(reset_point);\n\n    /* If queue_only is set or if there are too many incoming connections in\n    existence, session_local_queue_only will be TRUE. If it is not, check\n    whether we have received too many messages in this session for immediate\n    delivery. */\n\n    if (!session_local_queue_only &&\n        smtp_accept_queue_per_connection > 0 &&\n        receive_messagecount > smtp_accept_queue_per_connection)\n      {\n      session_local_queue_only = TRUE;\n      queue_only_reason = 2;\n      }\n\n    /* Initialize local_queue_only from session_local_queue_only. If it is not\n    true, and queue_only_load is set, check that the load average is below it.\n    If local_queue_only is set by this means, we also set if for the session if\n    queue_only_load_latch is true (the default). This means that, once set,\n    local_queue_only remains set for any subsequent messages on the same SMTP\n    connection. This is a deliberate choice; even though the load average may\n    fall, it doesn't seem right to deliver later messages on the same call when\n    not delivering earlier ones. However, the are special circumstances such as\n    very long-lived connections from scanning appliances where this is not the\n    best strategy. In such cases, queue_only_load_latch should be set false. */\n\n    local_queue_only = session_local_queue_only;\n    if (!local_queue_only && queue_only_load >= 0)\n      {\n      local_queue_only = (load_average = OS_GETLOADAVG()) > queue_only_load;\n      if (local_queue_only)\n        {\n        queue_only_reason = 3;\n        if (queue_only_load_latch) session_local_queue_only = TRUE;\n        }\n      }\n\n    /* Log the queueing here, when it will get a message id attached, but\n    not if queue_only is set (case 0). */\n\n    if (local_queue_only) switch(queue_only_reason)\n      {\n      case 1:\n      log_write(L_delay_delivery,\n                LOG_MAIN, \"no immediate delivery: too many connections \"\n                \"(%d, max %d)\", smtp_accept_count, smtp_accept_queue);\n      break;\n\n      case 2:\n      log_write(L_delay_delivery,\n                LOG_MAIN, \"no immediate delivery: more than %d messages \"\n                \"received in one connection\", smtp_accept_queue_per_connection);\n      break;\n\n      case 3:\n      log_write(L_delay_delivery,\n                LOG_MAIN, \"no immediate delivery: load average %.2f\",\n                (double)load_average/1000.0);\n      break;\n      }\n\n    /* If a delivery attempt is required, spin off a new process to handle it.\n    If we are not root, we have to re-exec exim unless deliveries are being\n    done unprivileged. */\n\n    else if (!queue_only_policy && !deliver_freeze)\n      {\n      pid_t dpid;\n\n      /* Before forking, ensure that the C output buffer is flushed. Otherwise\n      anything that it in it will get duplicated, leading to duplicate copies\n      of the pending output. */\n\n      mac_smtp_fflush();\n\n      if ((dpid = fork()) == 0)\n        {\n        (void)fclose(smtp_in);\n        (void)fclose(smtp_out);\n\n        /* Don't ever molest the parent's SSL connection, but do clean up\n        the data structures if necessary. */\n\n        #ifdef SUPPORT_TLS\n        tls_close(FALSE);\n        #endif\n\n        /* Reset SIGHUP and SIGCHLD in the child in both cases. */\n\n        signal(SIGHUP,  SIG_DFL);\n        signal(SIGCHLD, SIG_DFL);\n\n        if (geteuid() != root_uid && !deliver_drop_privilege)\n          {\n          signal(SIGALRM, SIG_DFL);\n          (void)child_exec_exim(CEE_EXEC_PANIC, FALSE, NULL, FALSE, 2, US\"-Mc\",\n            message_id);\n          /* Control does not return here. */\n          }\n\n        /* No need to re-exec; SIGALRM remains set to the default handler */\n\n        (void)deliver_message(message_id, FALSE, FALSE);\n        search_tidyup();\n        _exit(EXIT_SUCCESS);\n        }\n\n      if (dpid > 0)\n        {\n        DEBUG(D_any) debug_printf(\"forked delivery process %d\\n\", (int)dpid);\n        }\n      else\n        {\n        log_write(0, LOG_MAIN|LOG_PANIC, \"daemon: delivery process fork \"\n          \"failed: %s\", strerror(errno));\n        }\n      }\n    }\n  }\n\n\n/* Carrying on in the parent daemon process... Can't do much if the fork\nfailed. Otherwise, keep count of the number of accepting processes and\nremember the pid for ticking off when the child completes. */\n\nif (pid < 0)\n  {\n  never_error(US\"daemon: accept process fork failed\", US\"Fork failed\", errno);\n  }\nelse\n  {\n  int i;\n  for (i = 0; i < smtp_accept_max; ++i)\n    {\n    if (smtp_slots[i].pid <= 0)\n      {\n      smtp_slots[i].pid = pid;\n      if (smtp_accept_max_per_host != NULL)\n        smtp_slots[i].host_address = string_copy_malloc(sender_host_address);\n      smtp_accept_count++;\n      break;\n      }\n    }\n  DEBUG(D_any) debug_printf(\"%d SMTP accept process%s running\\n\",\n    smtp_accept_count, (smtp_accept_count == 1)? \"\" : \"es\");\n  }\n\n/* Get here via goto in error cases */\n\nERROR_RETURN:\n\n/* Close the streams associated with the socket which will also close the\nsocket fds in this process. We can't do anything if fclose() fails, but\nlogging brings it to someone's attention. However, \"connection reset by peer\"\nisn't really a problem, so skip that one. On Solaris, a dropped connection can\nmanifest itself as a broken pipe, so drop that one too. If the streams don't\nexist, something went wrong while setting things up. Make sure the socket\ndescriptors are closed, in order to drop the connection. */\n\nif (smtp_out != NULL)\n  {\n  if (fclose(smtp_out) != 0 && errno != ECONNRESET && errno != EPIPE)\n    log_write(0, LOG_MAIN|LOG_PANIC, \"daemon: fclose(smtp_out) failed: %s\",\n      strerror(errno));\n  smtp_out = NULL;\n  }\nelse (void)close(accept_socket);\n\nif (smtp_in != NULL)\n  {\n  if (fclose(smtp_in) != 0 && errno != ECONNRESET && errno != EPIPE)\n    log_write(0, LOG_MAIN|LOG_PANIC, \"daemon: fclose(smtp_in) failed: %s\",\n      strerror(errno));\n  smtp_in = NULL;\n  }\nelse (void)close(dup_accept_socket);\n\n/* Release any store used in this process, including the store used for holding\nthe incoming host address and an expanded active_hostname. */\n\nstore_reset(reset_point);\nsender_host_address = NULL;\n}",
        "start_line": 139
      }
    ],
    "code_context": "Called Methods:\n- EXIM_SOCKLEN_T: #define EXIM_SOCKLEN_T socklen_t /* <=== src/src/exim.h:132:132:EXIM_SOCKLEN_T:0 */ \n\nImports:\n- #include \"exim.h\"",
    "commit_msg": "Set FD_CLOEXEC on SMTP sockets after forking to handle the connection.",
    "cve_desc": "Exim 4.72 and earlier allows local users to gain privileges by leveraging the ability of the exim user account to specify an alternate configuration file with a directive that contains arbitrary commands, as demonstrated by the spool_directory directive.",
    "year": 2010,
    "filename": "daemon.c",
    "commit_url": "\"https://github.com/Exim/exim/commit/fa32850be0d9e605da1b33305c122f7a59a24650\""
  },
  {
    "repository": "torvalds/linux",
    "cve_id": "CVE-2010-4650",
    "cwe_list": [
      "CWE-119"
    ],
    "commit_hash": "7572777eef78ebdee1ecb7c258c0ef94d35bad16",
    "short_hash": "7572777e",
    "vulnerableMethods_before": [
      {
        "filename": "fs/fuse/file.c",
        "method_name": "fuse_do_ioctl",
        "raw_code": "long fuse_do_ioctl(struct file *file, unsigned int cmd, unsigned long arg, /* <=== fuse_do_ioctl */ \n\t\t   unsigned int flags)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tstruct fuse_ioctl_in inarg = {\n\t\t.fh = ff->fh,\n\t\t.cmd = cmd,\n\t\t.arg = arg,\n\t\t.flags = flags\n\t};\n\tstruct fuse_ioctl_out outarg;\n\tstruct fuse_req *req = NULL;\n\tstruct page **pages = NULL;\n\tstruct page *iov_page = NULL;\n\tstruct iovec *in_iov = NULL, *out_iov = NULL;\n\tunsigned int in_iovs = 0, out_iovs = 0, num_pages = 0, max_pages;\n\tsize_t in_size, out_size, transferred;\n\tint err;\n\n\t/* assume all the iovs returned by client always fits in a page */\n\tBUILD_BUG_ON(sizeof(struct iovec) * FUSE_IOCTL_MAX_IOV > PAGE_SIZE);\n\n\terr = -ENOMEM;\n\tpages = kzalloc(sizeof(pages[0]) * FUSE_MAX_PAGES_PER_REQ, GFP_KERNEL);\n\tiov_page = alloc_page(GFP_KERNEL);\n\tif (!pages || !iov_page)\n\t\tgoto out;\n\n\t/*\n\t * If restricted, initialize IO parameters as encoded in @cmd.\n\t * RETRY from server is not allowed.\n\t */\n\tif (!(flags & FUSE_IOCTL_UNRESTRICTED)) {\n\t\tstruct iovec *iov = page_address(iov_page);\n\n\t\tiov->iov_base = (void __user *)arg;\n\t\tiov->iov_len = _IOC_SIZE(cmd);\n\n\t\tif (_IOC_DIR(cmd) & _IOC_WRITE) {\n\t\t\tin_iov = iov;\n\t\t\tin_iovs = 1;\n\t\t}\n\n\t\tif (_IOC_DIR(cmd) & _IOC_READ) {\n\t\t\tout_iov = iov;\n\t\t\tout_iovs = 1;\n\t\t}\n\t}\n\n retry:\n\tinarg.in_size = in_size = iov_length(in_iov, in_iovs);\n\tinarg.out_size = out_size = iov_length(out_iov, out_iovs);\n\n\t/*\n\t * Out data can be used either for actual out data or iovs,\n\t * make sure there always is at least one page.\n\t */\n\tout_size = max_t(size_t, out_size, PAGE_SIZE);\n\tmax_pages = DIV_ROUND_UP(max(in_size, out_size), PAGE_SIZE);\n\n\t/* make sure there are enough buffer pages and init request with them */\n\terr = -ENOMEM;\n\tif (max_pages > FUSE_MAX_PAGES_PER_REQ)\n\t\tgoto out;\n\twhile (num_pages < max_pages) {\n\t\tpages[num_pages] = alloc_page(GFP_KERNEL | __GFP_HIGHMEM);\n\t\tif (!pages[num_pages])\n\t\t\tgoto out;\n\t\tnum_pages++;\n\t}\n\n\treq = fuse_get_req(fc);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\treq = NULL;\n\t\tgoto out;\n\t}\n\tmemcpy(req->pages, pages, sizeof(req->pages[0]) * num_pages);\n\treq->num_pages = num_pages;\n\n\t/* okay, let's send it to the client */\n\treq->in.h.opcode = FUSE_IOCTL;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(inarg);\n\treq->in.args[0].value = &inarg;\n\tif (in_size) {\n\t\treq->in.numargs++;\n\t\treq->in.args[1].size = in_size;\n\t\treq->in.argpages = 1;\n\n\t\terr = fuse_ioctl_copy_user(pages, in_iov, in_iovs, in_size,\n\t\t\t\t\t   false);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\treq->out.numargs = 2;\n\treq->out.args[0].size = sizeof(outarg);\n\treq->out.args[0].value = &outarg;\n\treq->out.args[1].size = out_size;\n\treq->out.argpages = 1;\n\treq->out.argvar = 1;\n\n\tfuse_request_send(fc, req);\n\terr = req->out.h.error;\n\ttransferred = req->out.args[1].size;\n\tfuse_put_request(fc, req);\n\treq = NULL;\n\tif (err)\n\t\tgoto out;\n\n\t/* did it ask for retry? */\n\tif (outarg.flags & FUSE_IOCTL_RETRY) {\n\t\tchar *vaddr;\n\n\t\t/* no retry if in restricted mode */\n\t\terr = -EIO;\n\t\tif (!(flags & FUSE_IOCTL_UNRESTRICTED))\n\t\t\tgoto out;\n\n\t\tin_iovs = outarg.in_iovs;\n\t\tout_iovs = outarg.out_iovs;\n\n\t\t/*\n\t\t * Make sure things are in boundary, separate checks\n\t\t * are to protect against overflow.\n\t\t */\n\t\terr = -ENOMEM;\n\t\tif (in_iovs > FUSE_IOCTL_MAX_IOV ||\n\t\t    out_iovs > FUSE_IOCTL_MAX_IOV ||\n\t\t    in_iovs + out_iovs > FUSE_IOCTL_MAX_IOV)\n\t\t\tgoto out;\n\n\t\tvaddr = kmap_atomic(pages[0], KM_USER0);\n\t\terr = fuse_copy_ioctl_iovec(page_address(iov_page), vaddr,\n\t\t\t\t\t    transferred, in_iovs + out_iovs,\n\t\t\t\t\t    (flags & FUSE_IOCTL_COMPAT) != 0);\n\t\tkunmap_atomic(vaddr, KM_USER0);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tin_iov = page_address(iov_page);\n\t\tout_iov = in_iov + in_iovs;\n\n\t\tgoto retry;\n\t}\n\n\terr = -EIO;\n\tif (transferred > inarg.out_size)\n\t\tgoto out;\n\n\terr = fuse_ioctl_copy_user(pages, out_iov, out_iovs, transferred, true);\n out:\n\tif (req)\n\t\tfuse_put_request(fc, req);\n\tif (iov_page)\n\t\t__free_page(iov_page);\n\twhile (num_pages)\n\t\t__free_page(pages[--num_pages]);\n\tkfree(pages);\n\n\treturn err ? err : outarg.result;\n}",
        "start_line": 1715
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "fs/fuse/file.c",
        "method_name": "fuse_verify_ioctl_iov",
        "raw_code": "static int fuse_verify_ioctl_iov(struct iovec *iov, size_t count) /* <=== fuse_verify_ioctl_iov */ \n{\n\tsize_t n;\n\tu32 max = FUSE_MAX_PAGES_PER_REQ << PAGE_SHIFT;\n\n\tfor (n = 0; n < count; n++) {\n\t\tif (iov->iov_len > (size_t) max)\n\t\t\treturn -ENOMEM;\n\t\tmax -= iov->iov_len;\n\t}\n\treturn 0;\n}",
        "start_line": 1670
      },
      {
        "filename": "fs/fuse/file.c",
        "method_name": "fuse_do_ioctl",
        "raw_code": "long fuse_do_ioctl(struct file *file, unsigned int cmd, unsigned long arg, /* <=== fuse_do_ioctl */ \n\t\t   unsigned int flags)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tstruct fuse_ioctl_in inarg = {\n\t\t.fh = ff->fh,\n\t\t.cmd = cmd,\n\t\t.arg = arg,\n\t\t.flags = flags\n\t};\n\tstruct fuse_ioctl_out outarg;\n\tstruct fuse_req *req = NULL;\n\tstruct page **pages = NULL;\n\tstruct page *iov_page = NULL;\n\tstruct iovec *in_iov = NULL, *out_iov = NULL;\n\tunsigned int in_iovs = 0, out_iovs = 0, num_pages = 0, max_pages;\n\tsize_t in_size, out_size, transferred;\n\tint err;\n\n\t/* assume all the iovs returned by client always fits in a page */\n\tBUILD_BUG_ON(sizeof(struct iovec) * FUSE_IOCTL_MAX_IOV > PAGE_SIZE);\n\n\terr = -ENOMEM;\n\tpages = kzalloc(sizeof(pages[0]) * FUSE_MAX_PAGES_PER_REQ, GFP_KERNEL);\n\tiov_page = alloc_page(GFP_KERNEL);\n\tif (!pages || !iov_page)\n\t\tgoto out;\n\n\t/*\n\t * If restricted, initialize IO parameters as encoded in @cmd.\n\t * RETRY from server is not allowed.\n\t */\n\tif (!(flags & FUSE_IOCTL_UNRESTRICTED)) {\n\t\tstruct iovec *iov = page_address(iov_page);\n\n\t\tiov->iov_base = (void __user *)arg;\n\t\tiov->iov_len = _IOC_SIZE(cmd);\n\n\t\tif (_IOC_DIR(cmd) & _IOC_WRITE) {\n\t\t\tin_iov = iov;\n\t\t\tin_iovs = 1;\n\t\t}\n\n\t\tif (_IOC_DIR(cmd) & _IOC_READ) {\n\t\t\tout_iov = iov;\n\t\t\tout_iovs = 1;\n\t\t}\n\t}\n\n retry:\n\tinarg.in_size = in_size = iov_length(in_iov, in_iovs);\n\tinarg.out_size = out_size = iov_length(out_iov, out_iovs);\n\n\t/*\n\t * Out data can be used either for actual out data or iovs,\n\t * make sure there always is at least one page.\n\t */\n\tout_size = max_t(size_t, out_size, PAGE_SIZE);\n\tmax_pages = DIV_ROUND_UP(max(in_size, out_size), PAGE_SIZE);\n\n\t/* make sure there are enough buffer pages and init request with them */\n\terr = -ENOMEM;\n\tif (max_pages > FUSE_MAX_PAGES_PER_REQ)\n\t\tgoto out;\n\twhile (num_pages < max_pages) {\n\t\tpages[num_pages] = alloc_page(GFP_KERNEL | __GFP_HIGHMEM);\n\t\tif (!pages[num_pages])\n\t\t\tgoto out;\n\t\tnum_pages++;\n\t}\n\n\treq = fuse_get_req(fc);\n\tif (IS_ERR(req)) {\n\t\terr = PTR_ERR(req);\n\t\treq = NULL;\n\t\tgoto out;\n\t}\n\tmemcpy(req->pages, pages, sizeof(req->pages[0]) * num_pages);\n\treq->num_pages = num_pages;\n\n\t/* okay, let's send it to the client */\n\treq->in.h.opcode = FUSE_IOCTL;\n\treq->in.h.nodeid = ff->nodeid;\n\treq->in.numargs = 1;\n\treq->in.args[0].size = sizeof(inarg);\n\treq->in.args[0].value = &inarg;\n\tif (in_size) {\n\t\treq->in.numargs++;\n\t\treq->in.args[1].size = in_size;\n\t\treq->in.argpages = 1;\n\n\t\terr = fuse_ioctl_copy_user(pages, in_iov, in_iovs, in_size,\n\t\t\t\t\t   false);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\treq->out.numargs = 2;\n\treq->out.args[0].size = sizeof(outarg);\n\treq->out.args[0].value = &outarg;\n\treq->out.args[1].size = out_size;\n\treq->out.argpages = 1;\n\treq->out.argvar = 1;\n\n\tfuse_request_send(fc, req);\n\terr = req->out.h.error;\n\ttransferred = req->out.args[1].size;\n\tfuse_put_request(fc, req);\n\treq = NULL;\n\tif (err)\n\t\tgoto out;\n\n\t/* did it ask for retry? */\n\tif (outarg.flags & FUSE_IOCTL_RETRY) {\n\t\tchar *vaddr;\n\n\t\t/* no retry if in restricted mode */\n\t\terr = -EIO;\n\t\tif (!(flags & FUSE_IOCTL_UNRESTRICTED))\n\t\t\tgoto out;\n\n\t\tin_iovs = outarg.in_iovs;\n\t\tout_iovs = outarg.out_iovs;\n\n\t\t/*\n\t\t * Make sure things are in boundary, separate checks\n\t\t * are to protect against overflow.\n\t\t */\n\t\terr = -ENOMEM;\n\t\tif (in_iovs > FUSE_IOCTL_MAX_IOV ||\n\t\t    out_iovs > FUSE_IOCTL_MAX_IOV ||\n\t\t    in_iovs + out_iovs > FUSE_IOCTL_MAX_IOV)\n\t\t\tgoto out;\n\n\t\tvaddr = kmap_atomic(pages[0], KM_USER0);\n\t\terr = fuse_copy_ioctl_iovec(page_address(iov_page), vaddr,\n\t\t\t\t\t    transferred, in_iovs + out_iovs,\n\t\t\t\t\t    (flags & FUSE_IOCTL_COMPAT) != 0);\n\t\tkunmap_atomic(vaddr, KM_USER0);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tin_iov = page_address(iov_page);\n\t\tout_iov = in_iov + in_iovs;\n\n\t\terr = fuse_verify_ioctl_iov(in_iov, in_iovs);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = fuse_verify_ioctl_iov(out_iov, out_iovs);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tgoto retry;\n\t}\n\n\terr = -EIO;\n\tif (transferred > inarg.out_size)\n\t\tgoto out;\n\n\terr = fuse_ioctl_copy_user(pages, out_iov, out_iovs, transferred, true);\n out:\n\tif (req)\n\t\tfuse_put_request(fc, req);\n\tif (iov_page)\n\t\t__free_page(iov_page);\n\twhile (num_pages)\n\t\t__free_page(pages[--num_pages]);\n\tkfree(pages);\n\n\treturn err ? err : outarg.result;\n}",
        "start_line": 1729
      }
    ],
    "code_context": "Called Methods:\n- atomic_dec_and_test: static __inline__ int atomic_dec_and_test(atomic_t *v) /* <=== atomic_dec_and_test */ \n{\n\tunsigned long flags;\n\tint ret;\n\tlocal_irq_save(flags);\n\t--v->counter;\n\tret = v->counter;\n\tlocal_irq_restore(flags);\n\treturn ret == 0;\n}\n- __memcpy_asm: extern unsigned long __memcpy_asm(void *to, const void *from, unsigned long n); /* <=== __memcpy_asm */ \n- fuse_request_alloc: struct fuse_req *fuse_request_alloc(void) /* <=== fuse_request_alloc */ \n{\n\tstruct fuse_req *req = kmem_cache_alloc(fuse_req_cachep, GFP_KERNEL);\n\tif (req)\n\t\tfuse_request_init(req);\n\treturn req;\n}\n- kfree: void kfree(const void *x) /* <=== kfree */ \n{\n\tstruct page *page;\n\tvoid *object = (void *)x;\n\n\ttrace_kfree(_RET_IP_, x);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(x)))\n\t\treturn;\n\n\tpage = virt_to_head_page(x);\n\tif (unlikely(!PageSlab(page))) {\n\t\tBUG_ON(!PageCompound(page));\n\t\tkmemleak_free(x);\n\t\tput_page(page);\n\t\treturn;\n\t}\n\tslab_free(page->slab, page, object, _RET_IP_);\n}\n- atomic_inc: static inline void atomic_inc(atomic_t *v) /* <=== atomic_inc */ \n{\n\tasm volatile(LOCK_PREFIX \"incl %0\"\n\t\t     : \"+m\" (v->counter));\n}\n- kmap: void *kmap(struct page *page) /* <=== kmap */ \n{\n\tmight_sleep();\n\tif (!PageHighMem(page))\n\t\treturn page_address(page);\n\treturn kmap_high(page);\n}\n- queue_request: static void queue_request(struct fuse_conn *fc, struct fuse_req *req) /* <=== queue_request */ \n{\n\treq->in.h.len = sizeof(struct fuse_in_header) +\n\t\tlen_args(req->in.numargs, (struct fuse_arg *) req->in.args);\n\tlist_add_tail(&req->list, &fc->pending);\n\treq->state = FUSE_REQ_PENDING;\n\tif (!req->waiting) {\n\t\treq->waiting = 1;\n\t\tatomic_inc(&fc->num_waiting);\n\t}\n\twake_up(&fc->waitq);\n\tkill_fasync(&fc->fasync, SIGIO, POLL_IN);\n}\n- put_page: void put_page(struct page *page) /* <=== put_page */ \n{\n\tif (unlikely(PageCompound(page)))\n\t\tput_compound_page(page);\n\telse if (put_page_testzero(page))\n\t\t__page_cache_release(page);\n}\n- __cache_free: static inline void __cache_free(struct kmem_cache *cachep, void *objp) /* <=== __cache_free */ \n{\n\tstruct array_cache *ac = cpu_cache_get(cachep);\n\n\tcheck_irq_off();\n\tkmemleak_free_recursive(objp, cachep->flags);\n\tobjp = cache_free_debugcheck(cachep, objp, __builtin_return_address(0));\n\n\tkmemcheck_slab_free(cachep, objp, obj_size(cachep));\n\n\t/*\n\t * Skip calling cache_free_alien() when the platform is not numa.\n\t * This will avoid cache misses that happen while accessing slabp (which\n\t * is per page memory  reference) to get nodeid. Instead use a global\n\t * variable to skip the call, which is mostly likely to be present in\n\t * the cache.\n\t */\n\tif (nr_online_nodes > 1 && cache_free_alien(cachep, objp))\n\t\treturn;\n\n\tif (likely(ac->avail < ac->limit)) {\n\t\tSTATS_INC_FREEHIT(cachep);\n\t\tac->entry[ac->avail++] = objp;\n\t\treturn;\n\t} else {\n\t\tSTATS_INC_FREEMISS(cachep);\n\t\tcache_flusharray(cachep, ac);\n\t\tac->entry[ac->avail++] = objp;\n\t}\n}\n- atomic_dec: static inline void atomic_dec(volatile atomic_t *v) /* <=== atomic_dec */ \n{\n\tunsigned long flags;\n\tcris_atomic_save(v, flags);\n\t(v->counter)--;\n\tcris_atomic_restore(v, flags);\n}\n- kunmap: void kunmap(struct page *page) /* <=== kunmap */ \n{\n\tif (in_interrupt())\n\t\tBUG();\n\tif (!PageHighMem(page))\n\t\treturn;\n\tkunmap_high(page);\n}\n- kmap: void *kmap(struct page *page) /* <=== kmap */ \n{\n\tvoid *addr;\n\n\tmight_sleep();\n\tif (!PageHighMem(page))\n\t\treturn page_address(page);\n\taddr = kmap_high(page);\n\tflush_tlb_one((unsigned long)addr);\n\n\treturn addr;\n}\n- kfree: void kfree(const void *objp) /* <=== kfree */ \n{\n\tstruct kmem_cache *c;\n\tunsigned long flags;\n\n\ttrace_kfree(_RET_IP_, objp);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(objp)))\n\t\treturn;\n\tlocal_irq_save(flags);\n\tkfree_debugcheck(objp);\n\tc = virt_to_cache(objp);\n\tdebug_check_no_locks_freed(objp, obj_size(c));\n\tdebug_check_no_obj_freed(objp, obj_size(c));\n\t__cache_free(c, (void *)objp);\n\tlocal_irq_restore(flags);\n}\n- atomic_dec: static inline void atomic_dec(atomic_t *v) /* <=== atomic_dec */ \n{\n\tatomic_sub_return(1, v);\n}\n- is_slob_page: static inline int is_slob_page(struct slob_page *sp) /* <=== is_slob_page */ \n{\n\treturn PageSlab((struct page *)sp);\n}\n- fuse_get_unique: static u64 fuse_get_unique(struct fuse_conn *fc) /* <=== fuse_get_unique */ \n{\n\tfc->reqctr++;\n\t/* zero is special */\n\tif (fc->reqctr == 0)\n\t\tfc->reqctr = 1;\n\n\treturn fc->reqctr;\n}\n- fuse_request_free: void fuse_request_free(struct fuse_req *req) /* <=== fuse_request_free */ \n{\n\tkmem_cache_free(fuse_req_cachep, req);\n}\n- request_wait_answer: static void request_wait_answer(struct fuse_conn *fc, struct fuse_req *req) /* <=== request_wait_answer */ \n- fuse_req_init_context: static void fuse_req_init_context(struct fuse_req *req) /* <=== fuse_req_init_context */ \n{\n\treq->in.h.uid = current_fsuid();\n\treq->in.h.gid = current_fsgid();\n\treq->in.h.pid = current->pid;\n}\n- atomic_inc: static inline void atomic_inc(volatile atomic_t *v) /* <=== atomic_inc */ \n{\n\tunsigned long flags;\n\tcris_atomic_save(v, flags);\n\t(v->counter)++;\n\tcris_atomic_restore(v, flags);\n}\n- atomic_dec_and_test: static inline int atomic_dec_and_test(volatile atomic_t *v) /* <=== atomic_dec_and_test */ \n{\n\tint retval;\n\tunsigned long flags;\n\tcris_atomic_save(v, flags);\n\tretval = --(v->counter) == 0;\n\tcris_atomic_restore(v, flags);\n\treturn retval;\n}\n- kmap: static inline void *kmap(struct page *page) /* <=== kmap */ \n{\n\tmight_sleep();\n\treturn page_address(page);\n}\n- spin_unlock: static inline void spin_unlock(spinlock_t *lock) /* <=== spin_unlock */ \n{\n\traw_spin_unlock(&lock->rlock);\n}\n- LARGE_COPY_CUTOFF: #define LARGE_COPY_CUTOFF 2048 /* <=== arch/tile/lib/memcpy_tile64.c:40:40:LARGE_COPY_CUTOFF:0 */ \n- fuse_copy_ioctl_iovec: static int fuse_copy_ioctl_iovec(struct iovec *dst, void *src, /* <=== fuse_copy_ioctl_iovec */ \n\t\t\t\t size_t transferred, unsigned count,\n\t\t\t\t bool is_compat)\n{\n#ifdef CONFIG_COMPAT\n\tif (count * sizeof(struct compat_iovec) == transferred) {\n\t\tstruct compat_iovec *ciov = src;\n\t\tunsigned i;\n\n\t\t/*\n\t\t * With this interface a 32bit server cannot support\n\t\t * non-compat (i.e. ones coming from 64bit apps) ioctl\n\t\t * requests\n\t\t */\n\t\tif (!is_compat)\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tdst[i].iov_base = compat_ptr(ciov[i].iov_base);\n\t\t\tdst[i].iov_len = ciov[i].iov_len;\n\t\t}\n\t\treturn 0;\n\t}\n#endif\n\n\tif (count * sizeof(struct iovec) != transferred)\n\t\treturn -EIO;\n\n\tmemcpy(dst, src, transferred);\n\treturn 0;\n}\n- kmap: void *kmap(struct page *page) /* <=== kmap */ \n{\n\tmight_sleep();\n\tif (!PageHighMem(page))\n\t\treturn page_address(page);\n\treturn kmap_high(page);\n}\n- kunmap: void kunmap(struct page *page) /* <=== kunmap */ \n{\n\tBUG_ON(in_interrupt());\n\tif (!PageHighMem(page))\n\t\treturn;\n\tkunmap_high(page);\n}\n- slob_free: static void slob_free(void *block, int size) /* <=== slob_free */ \n{\n\tstruct slob_page *sp;\n\tslob_t *prev, *next, *b = (slob_t *)block;\n\tslobidx_t units;\n\tunsigned long flags;\n\tstruct list_head *slob_list;\n\n\tif (unlikely(ZERO_OR_NULL_PTR(block)))\n\t\treturn;\n\tBUG_ON(!size);\n\n\tsp = slob_page(block);\n\tunits = SLOB_UNITS(size);\n\n\tspin_lock_irqsave(&slob_lock, flags);\n\n\tif (sp->units + units == SLOB_UNITS(PAGE_SIZE)) {\n\t\t/* Go directly to page allocator. Do not pass slob allocator */\n\t\tif (slob_page_free(sp))\n\t\t\tclear_slob_page_free(sp);\n\t\tspin_unlock_irqrestore(&slob_lock, flags);\n\t\tclear_slob_page(sp);\n\t\tfree_slob_page(sp);\n\t\tslob_free_pages(b, 0);\n\t\treturn;\n\t}\n\n\tif (!slob_page_free(sp)) {\n\t\t/* This slob page is about to become partially free. Easy! */\n\t\tsp->units = units;\n\t\tsp->free = b;\n\t\tset_slob(b, units,\n\t\t\t(void *)((unsigned long)(b +\n\t\t\t\t\tSLOB_UNITS(PAGE_SIZE)) & PAGE_MASK));\n\t\tif (size < SLOB_BREAK1)\n\t\t\tslob_list = &free_slob_small;\n\t\telse if (size < SLOB_BREAK2)\n\t\t\tslob_list = &free_slob_medium;\n\t\telse\n\t\t\tslob_list = &free_slob_large;\n\t\tset_slob_page_free(sp, slob_list);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Otherwise the page is already partially free, so find reinsertion\n\t * point.\n\t */\n\tsp->units += units;\n\n\tif (b < sp->free) {\n\t\tif (b + units == sp->free) {\n\t\t\tunits += slob_units(sp->free);\n\t\t\tsp->free = slob_next(sp->free);\n\t\t}\n\t\tset_slob(b, units, sp->free);\n\t\tsp->free = b;\n\t} else {\n\t\tprev = sp->free;\n\t\tnext = slob_next(prev);\n\t\twhile (b > next) {\n\t\t\tprev = next;\n\t\t\tnext = slob_next(prev);\n\t\t}\n\n\t\tif (!slob_last(prev) && b + units == next) {\n\t\t\tunits += slob_units(next);\n\t\t\tset_slob(b, units, slob_next(next));\n\t\t} else\n\t\t\tset_slob(b, units, next);\n\n\t\tif (prev + slob_units(prev) == b) {\n\t\t\tunits = slob_units(b) + slob_units(prev);\n\t\t\tset_slob(prev, units, slob_next(b));\n\t\t} else\n\t\t\tset_slob(prev, slob_units(prev), b);\n\t}\nout:\n\tspin_unlock_irqrestore(&slob_lock, flags);\n}\n- FUSE_MAX_PAGES_PER_REQ: #define FUSE_MAX_PAGES_PER_REQ 32 /* <=== fs/fuse/fuse_i.h:26:26:FUSE_MAX_PAGES_PER_REQ:0 */ \n- kunmap: void kunmap(struct page *page) /* <=== kunmap */ \n{\n\tif (in_interrupt())\n\t\tBUG();\n\tif (!PageHighMem(page))\n\t\treturn;\n\tkunmap_high(page);\n}\n- kzalloc: static inline void *kzalloc(size_t size, gfp_t flags) /* <=== kzalloc */ \n{\n\treturn kmalloc(size, flags | __GFP_ZERO);\n}\n- __fuse_get_request: static void __fuse_get_request(struct fuse_req *req) /* <=== __fuse_get_request */ \n{\n\tatomic_inc(&req->count);\n}\n- block_sigs: static void block_sigs(sigset_t *oldset) /* <=== block_sigs */ \n{\n\tsigset_t mask;\n\n\tsiginitsetinv(&mask, sigmask(SIGKILL));\n\tsigprocmask(SIG_BLOCK, &mask, oldset);\n}\n- kunmap: static inline void kunmap(struct page *page) /* <=== kunmap */ \n{\n}\n- PageSlab: __PAGEFLAG(Slab, slab) /* <=== PageSlab */ \n- atomic_dec: static inline void atomic_dec(atomic_t *v) /* <=== atomic_dec */ \n{\n\tasm volatile(LOCK_PREFIX \"decl %0\"\n\t\t     : \"+m\" (v->counter));\n}\n- fuse_get_req: struct fuse_req *fuse_get_req(struct fuse_conn *fc) /* <=== fuse_get_req */ \n{\n\tstruct fuse_req *req;\n\tsigset_t oldset;\n\tint intr;\n\tint err;\n\n\tatomic_inc(&fc->num_waiting);\n\tblock_sigs(&oldset);\n\tintr = wait_event_interruptible(fc->blocked_waitq, !fc->blocked);\n\trestore_sigs(&oldset);\n\terr = -EINTR;\n\tif (intr)\n\t\tgoto out;\n\n\terr = -ENOTCONN;\n\tif (!fc->connected)\n\t\tgoto out;\n\n\treq = fuse_request_alloc();\n\terr = -ENOMEM;\n\tif (!req)\n\t\tgoto out;\n\n\tfuse_req_init_context(req);\n\treq->waiting = 1;\n\treturn req;\n\n out:\n\tatomic_dec(&fc->num_waiting);\n\treturn ERR_PTR(err);\n}\n- kmap: void *kmap(struct page *page) /* <=== kmap */ \n{\n\tvoid *kva;\n\tunsigned long flags;\n\tpte_t *ptep;\n\n\tmight_sleep();\n\tif (!PageHighMem(page))\n\t\treturn page_address(page);\n\tkva = kmap_high(page);\n\n\t/*\n\t * Rewrite the PTE under the lock.  This ensures that the page\n\t * is not currently migrating.\n\t */\n\tptep = kmap_get_pte((unsigned long)kva);\n\tflags = homecache_kpte_lock();\n\tset_pte_at(&init_mm, kva, ptep, mk_pte(page, page_to_kpgprot(page)));\n\thomecache_kpte_unlock(flags);\n\n\treturn kva;\n}\n- kfree_debugcheck: #define kfree_debugcheck(x) do { } while(0) /* <=== mm/slab.c:3000:3000:kfree_debugcheck:1 */ \n- atomic_dec_and_test: static inline int atomic_dec_and_test(atomic_t *v) /* <=== atomic_dec_and_test */ \n{\n\tunsigned char c;\n\n\tasm volatile(LOCK_PREFIX \"decl %0; sete %1\"\n\t\t     : \"+m\" (v->counter), \"=qm\" (c)\n\t\t     : : \"memory\");\n\treturn c != 0;\n}\n- atomic_inc: static inline void atomic_inc(atomic_t *v) /* <=== atomic_inc */ \n{\n\tatomic_add_return(1, v);\n}\n- memcpy: void *memcpy(void *dest, const void *src, size_t n) /* <=== memcpy */ \n{\n\tlong d0, d1, d2;\n\tasm volatile(\n\t\t\"rep ; movsq\\n\\t\"\n\t\t\"movq %4,%%rcx\\n\\t\"\n\t\t\"rep ; movsb\\n\\t\"\n\t\t: \"=&c\" (d0), \"=&D\" (d1), \"=&S\" (d2)\n\t\t: \"0\" (n >> 3), \"g\" (n & 7), \"1\" (dest), \"2\" (src)\n\t\t: \"memory\");\n\n\treturn dest;\n}\n- memcpy: void *memcpy(void *to, const void *from, __kernel_size_t n) /* <=== memcpy */ \n{\n\tif (n < LARGE_COPY_CUTOFF)\n\t\treturn (void *)__memcpy_asm(to, from, n);\n\telse\n\t\treturn (void *)fast_copy(to, from, n, __memcpy_asm);\n}\n- fuse_request_send: void fuse_request_send(struct fuse_conn *fc, struct fuse_req *req) /* <=== fuse_request_send */ \n{\n\treq->isreply = 1;\n\tspin_lock(&fc->lock);\n\tif (!fc->connected)\n\t\treq->out.h.error = -ENOTCONN;\n\telse if (fc->conn_error)\n\t\treq->out.h.error = -ECONNREFUSED;\n\telse {\n\t\treq->in.h.unique = fuse_get_unique(fc);\n\t\tqueue_request(fc, req);\n\t\t/* acquire extra reference, since request is still needed\n\t\t   after request_end() */\n\t\t__fuse_get_request(req);\n\n\t\trequest_wait_answer(fc, req);\n\t}\n\tspin_unlock(&fc->lock);\n}\n- fast_copy: static unsigned long fast_copy(void *dest, const void *source, int len, /* <=== fast_copy */ \n\t\t\t       memcpy_t func)\n{\n\t/*\n\t * Check if it's big enough to bother with.  We may end up doing a\n\t * small copy via TLB manipulation if we're near a page boundary,\n\t * but presumably we'll make it up when we hit the second page.\n\t */\n\twhile (len >= LARGE_COPY_CUTOFF) {\n\t\tint copy_size, bytes_left_on_page;\n\t\tpte_t *src_ptep, *dst_ptep;\n\t\tpte_t src_pte, dst_pte;\n\t\tstruct page *src_page, *dst_page;\n\n\t\t/* Is the source page oloc'ed to a remote cpu? */\nretry_source:\n\t\tsrc_ptep = virt_to_pte(current->mm, (unsigned long)source);\n\t\tif (src_ptep == NULL)\n\t\t\tbreak;\n\t\tsrc_pte = *src_ptep;\n\t\tif (!hv_pte_get_present(src_pte) ||\n\t\t    !hv_pte_get_readable(src_pte) ||\n\t\t    hv_pte_get_mode(src_pte) != HV_PTE_MODE_CACHE_TILE_L3)\n\t\t\tbreak;\n\t\tif (get_remote_cache_cpu(src_pte) == smp_processor_id())\n\t\t\tbreak;\n\t\tsrc_page = pfn_to_page(hv_pte_get_pfn(src_pte));\n\t\tget_page(src_page);\n\t\tif (pte_val(src_pte) != pte_val(*src_ptep)) {\n\t\t\tput_page(src_page);\n\t\t\tgoto retry_source;\n\t\t}\n\t\tif (pte_huge(src_pte)) {\n\t\t\t/* Adjust the PTE to correspond to a small page */\n\t\t\tint pfn = hv_pte_get_pfn(src_pte);\n\t\t\tpfn += (((unsigned long)source & (HPAGE_SIZE-1))\n\t\t\t\t>> PAGE_SHIFT);\n\t\t\tsrc_pte = pfn_pte(pfn, src_pte);\n\t\t\tsrc_pte = pte_mksmall(src_pte);\n\t\t}\n\n\t\t/* Is the destination page writable? */\nretry_dest:\n\t\tdst_ptep = virt_to_pte(current->mm, (unsigned long)dest);\n\t\tif (dst_ptep == NULL) {\n\t\t\tput_page(src_page);\n\t\t\tbreak;\n\t\t}\n\t\tdst_pte = *dst_ptep;\n\t\tif (!hv_pte_get_present(dst_pte) ||\n\t\t    !hv_pte_get_writable(dst_pte)) {\n\t\t\tput_page(src_page);\n\t\t\tbreak;\n\t\t}\n\t\tdst_page = pfn_to_page(hv_pte_get_pfn(dst_pte));\n\t\tif (dst_page == src_page) {\n\t\t\t/*\n\t\t\t * Source and dest are on the same page; this\n\t\t\t * potentially exposes us to incoherence if any\n\t\t\t * part of src and dest overlap on a cache line.\n\t\t\t * Just give up rather than trying to be precise.\n\t\t\t */\n\t\t\tput_page(src_page);\n\t\t\tbreak;\n\t\t}\n\t\tget_page(dst_page);\n\t\tif (pte_val(dst_pte) != pte_val(*dst_ptep)) {\n\t\t\tput_page(dst_page);\n\t\t\tgoto retry_dest;\n\t\t}\n\t\tif (pte_huge(dst_pte)) {\n\t\t\t/* Adjust the PTE to correspond to a small page */\n\t\t\tint pfn = hv_pte_get_pfn(dst_pte);\n\t\t\tpfn += (((unsigned long)dest & (HPAGE_SIZE-1))\n\t\t\t\t>> PAGE_SHIFT);\n\t\t\tdst_pte = pfn_pte(pfn, dst_pte);\n\t\t\tdst_pte = pte_mksmall(dst_pte);\n\t\t}\n\n\t\t/* All looks good: create a cachable PTE and copy from it */\n\t\tcopy_size = len;\n\t\tbytes_left_on_page =\n\t\t\tPAGE_SIZE - (((int)source) & (PAGE_SIZE-1));\n\t\tif (copy_size > bytes_left_on_page)\n\t\t\tcopy_size = bytes_left_on_page;\n\t\tbytes_left_on_page =\n\t\t\tPAGE_SIZE - (((int)dest) & (PAGE_SIZE-1));\n\t\tif (copy_size > bytes_left_on_page)\n\t\t\tcopy_size = bytes_left_on_page;\n\t\tmemcpy_multicache(dest, source, dst_pte, src_pte, copy_size);\n\n\t\t/* Release the pages */\n\t\tput_page(dst_page);\n\t\tput_page(src_page);\n\n\t\t/* Continue on the next page */\n\t\tdest += copy_size;\n\t\tsource += copy_size;\n\t\tlen -= copy_size;\n\t}\n\n\treturn func(dest, source, len);\n}\n- obj_size: #define obj_size(cachep)\t\t(cachep->buffer_size) /* <=== mm/slab.c:462:462:obj_size:1 */ \n- kunmap: void kunmap(struct page *page) /* <=== kunmap */ \n{\n\tBUG_ON(in_interrupt());\n\tif (!PageHighMem(page))\n\t\treturn;\n\tkunmap_high(page);\n}\n- spin_lock: static inline void spin_lock(spinlock_t *lock) /* <=== spin_lock */ \n{\n\traw_spin_lock(&lock->rlock);\n}\n- PageCompound: TESTPAGEFLAG(Compound, compound) /* <=== PageCompound */ \n- put_reserved_req: static void put_reserved_req(struct fuse_conn *fc, struct fuse_req *req) /* <=== put_reserved_req */ \n{\n\tstruct file *file = req->stolen_file;\n\tstruct fuse_file *ff = file->private_data;\n\n\tspin_lock(&fc->lock);\n\tfuse_request_init(req);\n\tBUG_ON(ff->reserved_req);\n\tff->reserved_req = req;\n\twake_up_all(&fc->reserved_req_waitq);\n\tspin_unlock(&fc->lock);\n\tfput(file);\n}\n- copy_from_user: static inline unsigned long /* <=== copy_from_user */ \ncopy_from_user(void *to, const void *from, unsigned long len)\n{\n\tunsigned long over;\n\n\tif (access_ok(VERIFY_READ, from, len))\n\t\treturn __copy_tofrom_user(to, from, len);\n\n\tif ((unsigned long)from < TASK_SIZE) {\n\t\tover = (unsigned long)from + len - TASK_SIZE;\n\t\treturn __copy_tofrom_user(to, from, len - over) + over;\n\t}\n\treturn len;\n}\n- kfree: void kfree(const void *block) /* <=== kfree */ \n{\n\tstruct slob_page *sp;\n\n\ttrace_kfree(_RET_IP_, block);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(block)))\n\t\treturn;\n\tkmemleak_free(block);\n\n\tsp = slob_page(block);\n\tif (is_slob_page(sp)) {\n\t\tint align = max(ARCH_KMALLOC_MINALIGN, ARCH_SLAB_MINALIGN);\n\t\tunsigned int *m = (unsigned int *)(block - align);\n\t\tslob_free(m, *m + align);\n\t} else\n\t\tput_page(&sp->page);\n}\n- kunmap: void kunmap(struct page *page) /* <=== kunmap */ \n{\n\tif (in_interrupt())\n\t\tBUG();\n\tif (!PageHighMem(page))\n\t\treturn;\n\tkunmap_high(page);\n}\n- kmap: void *kmap(struct page *page) /* <=== kmap */ \n{\n\tmight_sleep();\n\tif (!PageHighMem(page))\n\t\treturn page_address(page);\n\treturn kmap_high(page);\n}\n- fuse_put_request: void fuse_put_request(struct fuse_conn *fc, struct fuse_req *req) /* <=== fuse_put_request */ \n{\n\tif (atomic_dec_and_test(&req->count)) {\n\t\tif (req->waiting)\n\t\t\tatomic_dec(&fc->num_waiting);\n\n\t\tif (req->stolen_file)\n\t\t\tput_reserved_req(fc, req);\n\t\telse\n\t\t\tfuse_request_free(req);\n\t}\n}\n- slob_page: static inline struct slob_page *slob_page(const void *addr) /* <=== slob_page */ \n{\n\treturn (struct slob_page *)virt_to_page(addr);\n}\n- restore_sigs: static void restore_sigs(sigset_t *oldset) /* <=== restore_sigs */ \n{\n\tsigprocmask(SIG_SETMASK, oldset, NULL);\n}\n- iov_iter_advance: void iov_iter_advance(struct iov_iter *i, size_t bytes) /* <=== iov_iter_advance */ \n{\n\tBUG_ON(i->count < bytes);\n\n\tif (likely(i->nr_segs == 1)) {\n\t\ti->iov_offset += bytes;\n\t\ti->count -= bytes;\n\t} else {\n\t\tconst struct iovec *iov = i->iov;\n\t\tsize_t base = i->iov_offset;\n\n\t\t/*\n\t\t * The !iov->iov_len check ensures we skip over unlikely\n\t\t * zero-length segments (without overruning the iovec).\n\t\t */\n\t\twhile (bytes || unlikely(i->count && !iov->iov_len)) {\n\t\t\tint copy;\n\n\t\t\tcopy = min(bytes, iov->iov_len - base);\n\t\t\tBUG_ON(!i->count || i->count < copy);\n\t\t\ti->count -= copy;\n\t\t\tbytes -= copy;\n\t\t\tbase += copy;\n\t\t\tif (iov->iov_len == base) {\n\t\t\t\tiov++;\n\t\t\t\tbase = 0;\n\t\t\t}\n\t\t}\n\t\ti->iov = iov;\n\t\ti->iov_offset = base;\n\t}\n}\n- copy_to_user: static inline unsigned long /* <=== copy_to_user */ \ncopy_to_user(void *to, const void *from, unsigned long len)\n{\n\tunsigned long over;\n\n\tif (access_ok(VERIFY_WRITE, to, len))\n\t\treturn __copy_tofrom_user(to, from, len);\n\n\tif ((unsigned long)to < TASK_SIZE) {\n\t\tover = (unsigned long)to + len - TASK_SIZE;\n\t\treturn __copy_tofrom_user(to, from, len - over) + over;\n\t}\n\treturn len;\n}\n- virt_to_cache: static inline struct kmem_cache *virt_to_cache(const void *obj) /* <=== virt_to_cache */ \n{\n\tstruct page *page = virt_to_head_page(obj);\n\treturn page_get_cache(page);\n}\n- fuse_ioctl_copy_user: static int fuse_ioctl_copy_user(struct page **pages, struct iovec *iov, /* <=== fuse_ioctl_copy_user */ \n\t\t\tunsigned int nr_segs, size_t bytes, bool to_user)\n{\n\tstruct iov_iter ii;\n\tint page_idx = 0;\n\n\tif (!bytes)\n\t\treturn 0;\n\n\tiov_iter_init(&ii, iov, nr_segs, bytes, 0);\n\n\twhile (iov_iter_count(&ii)) {\n\t\tstruct page *page = pages[page_idx++];\n\t\tsize_t todo = min_t(size_t, PAGE_SIZE, iov_iter_count(&ii));\n\t\tvoid *kaddr;\n\n\t\tkaddr = kmap(page);\n\n\t\twhile (todo) {\n\t\t\tchar __user *uaddr = ii.iov->iov_base + ii.iov_offset;\n\t\t\tsize_t iov_len = ii.iov->iov_len - ii.iov_offset;\n\t\t\tsize_t copy = min(todo, iov_len);\n\t\t\tsize_t left;\n\n\t\t\tif (!to_user)\n\t\t\t\tleft = copy_from_user(kaddr, uaddr, copy);\n\t\t\telse\n\t\t\t\tleft = copy_to_user(uaddr, kaddr, copy);\n\n\t\t\tif (unlikely(left))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tiov_iter_advance(&ii, copy);\n\t\t\ttodo -= copy;\n\t\t\tkaddr += copy;\n\t\t}\n\n\t\tkunmap(page);\n\t}\n\n\treturn 0;\n}\n\nType Definitions:\n- fuse_req: struct fuse_req {\n\t/** This can be on either pending processing or io lists in\n\t    fuse_conn */\n\tstruct list_head list;\n\n\t/** Entry on the interrupts list  */\n\tstruct list_head intr_entry;\n\n\t/** refcount */\n\tatomic_t count;\n\n\t/** Unique ID for the interrupt request */\n\tu64 intr_unique;\n\n\t/*\n\t * The following bitfields are either set once before the\n\t * request is queued or setting/clearing them is protected by\n\t * fuse_conn->lock\n\t */\n\n\t/** True if the request has reply */\n\tunsigned isreply:1;\n\n\t/** Force sending of the request even if interrupted */\n\tunsigned force:1;\n\n\t/** The request was aborted */\n\tunsigned aborted:1;\n\n\t/** Request is sent in the background */\n\tunsigned background:1;\n\n\t/** The request has been interrupted */\n\tunsigned interrupted:1;\n\n\t/** Data is being copied to/from the request */\n\tunsigned locked:1;\n\n\t/** Request is counted as \"waiting\" */\n\tunsigned waiting:1;\n\n\t/** State of the request */\n\tenum fuse_req_state state;\n\n\t/** The request input */\n\tstruct fuse_in in;\n\n\t/** The request output */\n\tstruct fuse_out out;\n\n\t/** Used to wake up the task waiting for completion of request*/\n\twait_queue_head_t waitq;\n\n\t/** Data for asynchronous requests */\n\tunion {\n\t\tstruct fuse_forget_in forget_in;\n\t\tstruct {\n\t\t\tstruct fuse_release_in in;\n\t\t\tstruct path path;\n\t\t} release;\n\t\tstruct fuse_init_in init_in;\n\t\tstruct fuse_init_out init_out;\n\t\tstruct cuse_init_in cuse_init_in;\n\t\tstruct cuse_init_out cuse_init_out;\n\t\tstruct {\n\t\t\tstruct fuse_read_in in;\n\t\t\tu64 attr_ver;\n\t\t} read;\n\t\tstruct {\n\t\t\tstruct fuse_write_in in;\n\t\t\tstruct fuse_write_out out;\n\t\t} write;\n\t\tstruct fuse_notify_retrieve_in retrieve_in;\n\t\tstruct fuse_lk_in lk_in;\n\t} misc;\n\n\t/** page vector */\n\tstruct page *pages[FUSE_MAX_PAGES_PER_REQ];\n\n\t/** number of pages in vector */\n\tunsigned num_pages;\n\n\t/** offset of data on first page */\n\tunsigned page_offset;\n\n\t/** File used in the request (or NULL) */\n\tstruct fuse_file *ff;\n\n\t/** Inode used in the request or NULL */\n\tstruct inode *inode;\n\n\t/** Link on fi->writepages */\n\tstruct list_head writepages_entry;\n\n\t/** Request completion callback */\n\tvoid (*end)(struct fuse_conn *, struct fuse_req *);\n\n\t/** Request is stolen from fuse_file->reserved_req */\n\tstruct file *stolen_file;\n}\n- fuse_ioctl_in: struct fuse_ioctl_in {\n\t__u64\tfh;\n\t__u32\tflags;\n\t__u32\tcmd;\n\t__u64\targ;\n\t__u32\tin_size;\n\t__u32\tout_size;\n}\n- iovec: const struct iovec\n- fuse_file: struct fuse_file {\n\t/** Fuse connection for this file */\n\tstruct fuse_conn *fc;\n\n\t/** Request reserved for flush and release */\n\tstruct fuse_req *reserved_req;\n\n\t/** Kernel file handle guaranteed to be unique */\n\tu64 kh;\n\n\t/** File handle used by userspace */\n\tu64 fh;\n\n\t/** Node id of this file */\n\tu64 nodeid;\n\n\t/** Refcount */\n\tatomic_t count;\n\n\t/** FOPEN_* flags returned by open */\n\tu32 open_flags;\n\n\t/** Entry on inode's write_files list */\n\tstruct list_head write_entry;\n\n\t/** RB node to be linked on fuse_conn->polled_files */\n\tstruct rb_node polled_node;\n\n\t/** Wait queue head for poll */\n\twait_queue_head_t poll_wait;\n}\n- file: struct file\n- page: struct page {\n\tunsigned long flags;\t\t/* Atomic flags, some possibly\n\t\t\t\t\t * updated asynchronously */\n\tatomic_t _count;\t\t/* Usage count, see below. */\n\tunion {\n\t\tatomic_t _mapcount;\t/* Count of ptes mapped in mms,\n\t\t\t\t\t * to show when page is mapped\n\t\t\t\t\t * & limit reverse map searches.\n\t\t\t\t\t */\n\t\tstruct {\t\t/* SLUB */\n\t\t\tu16 inuse;\n\t\t\tu16 objects;\n\t\t};\n\t};\n\tunion {\n\t    struct {\n\t\tunsigned long private;\t\t/* Mapping-private opaque data:\n\t\t\t\t\t \t * usually used for buffer_heads\n\t\t\t\t\t\t * if PagePrivate set; used for\n\t\t\t\t\t\t * swp_entry_t if PageSwapCache;\n\t\t\t\t\t\t * indicates order in the buddy\n\t\t\t\t\t\t * system if PG_buddy is set.\n\t\t\t\t\t\t */\n\t\tstruct address_space *mapping;\t/* If low bit clear, points to\n\t\t\t\t\t\t * inode address_space, or NULL.\n\t\t\t\t\t\t * If page mapped as anonymous\n\t\t\t\t\t\t * memory, low bit is set, and\n\t\t\t\t\t\t * it points to anon_vma object:\n\t\t\t\t\t\t * see PAGE_MAPPING_ANON below.\n\t\t\t\t\t\t */\n\t    };\n#if USE_SPLIT_PTLOCKS\n\t    spinlock_t ptl;\n#endif\n\t    struct kmem_cache *slab;\t/* SLUB: Pointer to slab */\n\t    struct page *first_page;\t/* Compound tail pages */\n\t};\n\tunion {\n\t\tpgoff_t index;\t\t/* Our offset within mapping. */\n\t\tvoid *freelist;\t\t/* SLUB: freelist req. slab lock */\n\t};\n\tstruct list_head lru;\t\t/* Pageout list, eg. active_list\n\t\t\t\t\t * protected by zone->lru_lock !\n\t\t\t\t\t */\n\t/*\n\t * On machines where all RAM is mapped into kernel address space,\n\t * we can simply calculate the virtual address. On machines with\n\t * highmem some memory is mapped into kernel virtual memory\n\t * dynamically, so we need a place to store that address.\n\t * Note that this field could be 16 bits on x86 ... ;)\n\t *\n\t * Architectures with slow multiplication can define\n\t * WANT_PAGE_VIRTUAL in asm/page.h\n\t */\n#if defined(WANT_PAGE_VIRTUAL)\n\tvoid *virtual;\t\t\t/* Kernel virtual address (NULL if\n\t\t\t\t\t   not kmapped, ie. highmem) */\n#endif /* WANT_PAGE_VIRTUAL */\n#ifdef CONFIG_WANT_PAGE_DEBUG_FLAGS\n\tunsigned long debug_flags;\t/* Use atomic bitops on this */\n#endif\n\n#ifdef CONFIG_KMEMCHECK\n\t/*\n\t * kmemcheck wants to track the status of each byte in a page; this\n\t * is a pointer to such a status block. NULL if not tracked.\n\t */\n\tvoid *shadow;\n#endif\n}\n- fuse_conn: struct fuse_conn {\n\t/** Lock protecting accessess to  members of this structure */\n\tspinlock_t lock;\n\n\t/** Mutex protecting against directory alias creation */\n\tstruct mutex inst_mutex;\n\n\t/** Refcount */\n\tatomic_t count;\n\n\t/** The user id for this mount */\n\tuid_t user_id;\n\n\t/** The group id for this mount */\n\tgid_t group_id;\n\n\t/** The fuse mount flags for this mount */\n\tunsigned flags;\n\n\t/** Maximum read size */\n\tunsigned max_read;\n\n\t/** Maximum write size */\n\tunsigned max_write;\n\n\t/** Readers of the connection are waiting on this */\n\twait_queue_head_t waitq;\n\n\t/** The list of pending requests */\n\tstruct list_head pending;\n\n\t/** The list of requests being processed */\n\tstruct list_head processing;\n\n\t/** The list of requests under I/O */\n\tstruct list_head io;\n\n\t/** The next unique kernel file handle */\n\tu64 khctr;\n\n\t/** rbtree of fuse_files waiting for poll events indexed by ph */\n\tstruct rb_root polled_files;\n\n\t/** Maximum number of outstanding background requests */\n\tunsigned max_background;\n\n\t/** Number of background requests at which congestion starts */\n\tunsigned congestion_threshold;\n\n\t/** Number of requests currently in the background */\n\tunsigned num_background;\n\n\t/** Number of background requests currently queued for userspace */\n\tunsigned active_background;\n\n\t/** The list of background requests set aside for later queuing */\n\tstruct list_head bg_queue;\n\n\t/** Pending interrupts */\n\tstruct list_head interrupts;\n\n\t/** Flag indicating if connection is blocked.  This will be\n\t    the case before the INIT reply is received, and if there\n\t    are too many outstading backgrounds requests */\n\tint blocked;\n\n\t/** waitq for blocked connection */\n\twait_queue_head_t blocked_waitq;\n\n\t/** waitq for reserved requests */\n\twait_queue_head_t reserved_req_waitq;\n\n\t/** The next unique request id */\n\tu64 reqctr;\n\n\t/** Connection established, cleared on umount, connection\n\t    abort and device release */\n\tunsigned connected;\n\n\t/** Connection failed (version mismatch).  Cannot race with\n\t    setting other bitfields since it is only set once in INIT\n\t    reply, before any other request, and never cleared */\n\tunsigned conn_error:1;\n\n\t/** Connection successful.  Only set in INIT */\n\tunsigned conn_init:1;\n\n\t/** Do readpages asynchronously?  Only set in INIT */\n\tunsigned async_read:1;\n\n\t/** Do not send separate SETATTR request before open(O_TRUNC)  */\n\tunsigned atomic_o_trunc:1;\n\n\t/** Filesystem supports NFS exporting.  Only set in INIT */\n\tunsigned export_support:1;\n\n\t/** Set if bdi is valid */\n\tunsigned bdi_initialized:1;\n\n\t/*\n\t * The following bitfields are only for optimization purposes\n\t * and hence races in setting them will not cause malfunction\n\t */\n\n\t/** Is fsync not implemented by fs? */\n\tunsigned no_fsync:1;\n\n\t/** Is fsyncdir not implemented by fs? */\n\tunsigned no_fsyncdir:1;\n\n\t/** Is flush not implemented by fs? */\n\tunsigned no_flush:1;\n\n\t/** Is setxattr not implemented by fs? */\n\tunsigned no_setxattr:1;\n\n\t/** Is getxattr not implemented by fs? */\n\tunsigned no_getxattr:1;\n\n\t/** Is listxattr not implemented by fs? */\n\tunsigned no_listxattr:1;\n\n\t/** Is removexattr not implemented by fs? */\n\tunsigned no_removexattr:1;\n\n\t/** Are file locking primitives not implemented by fs? */\n\tunsigned no_lock:1;\n\n\t/** Is access not implemented by fs? */\n\tunsigned no_access:1;\n\n\t/** Is create not implemented by fs? */\n\tunsigned no_create:1;\n\n\t/** Is interrupt not implemented by fs? */\n\tunsigned no_interrupt:1;\n\n\t/** Is bmap not implemented by fs? */\n\tunsigned no_bmap:1;\n\n\t/** Is poll not implemented by fs? */\n\tunsigned no_poll:1;\n\n\t/** Do multi-page cached writes */\n\tunsigned big_writes:1;\n\n\t/** Don't apply umask to creation modes */\n\tunsigned dont_mask:1;\n\n\t/** The number of requests waiting for completion */\n\tatomic_t num_waiting;\n\n\t/** Negotiated minor version */\n\tunsigned minor;\n\n\t/** Backing dev info */\n\tstruct backing_dev_info bdi;\n\n\t/** Entry on the fuse_conn_list */\n\tstruct list_head entry;\n\n\t/** Device ID from super block */\n\tdev_t dev;\n\n\t/** Dentries in the control filesystem */\n\tstruct dentry *ctl_dentry[FUSE_CTL_NUM_DENTRIES];\n\n\t/** number of dentries used in the above array */\n\tint ctl_ndents;\n\n\t/** O_ASYNC requests */\n\tstruct fasync_struct *fasync;\n\n\t/** Key for lock owner ID scrambling */\n\tu32 scramble_key[4];\n\n\t/** Reserved request for the DESTROY message */\n\tstruct fuse_req *destroy_req;\n\n\t/** Version counter for attribute changes */\n\tu64 attr_version;\n\n\t/** Called on final put */\n\tvoid (*release)(struct fuse_conn *);\n\n\t/** Super block for this connection. */\n\tstruct super_block *sb;\n\n\t/** Read/write semaphore to hold when accessing sb. */\n\tstruct rw_semaphore killsb;\n}\n- fuse_ioctl_out: struct fuse_ioctl_out {\n\t__s32\tresult;\n\t__u32\tflags;\n\t__u32\tin_iovs;\n\t__u32\tout_iovs;\n}\n\nImports:\n- #include <linux/kernel.h>\n- #include <linux/compat.h>\n- #include <linux/slab.h>\n- #include <linux/pagemap.h>\n- #include <linux/module.h>\n- #include \"fuse_i.h\"\n- #include <linux/sched.h>",
    "commit_msg": "fuse: verify ioctl retries\n\nVerify that the total length of the iovec returned in FUSE_IOCTL_RETRY\ndoesn't overflow iov_length().\n\nSigned-off-by: Miklos Szeredi <mszeredi@suse.cz>\nCC: Tejun Heo <tj@kernel.org>\nCC: <stable@kernel.org>         [2.6.31+]",
    "cve_desc": "[{'lang': 'en', 'value': 'Buffer overflow in the fuse_do_ioctl function in fs/fuse/file.c in the Linux kernel before 2.6.37 allows local users to cause a denial of service or possibly have unspecified other impact by leveraging the ability to operate a CUSE server.'}]",
    "year": 2010,
    "filename": "file.c",
    "commit_url": "\"https://github.com/torvalds/linux/commit/7572777eef78ebdee1ecb7c258c0ef94d35bad16\""
  },
  {
    "repository": "torvalds/linux",
    "cve_id": "CVE-2010-5313",
    "cwe_list": [
      "CWE-362"
    ],
    "commit_hash": "fc3a9157d3148ab91039c75423da8ef97be3e105",
    "short_hash": "fc3a9157",
    "vulnerableMethods_before": [
      {
        "filename": "arch/x86/kvm/x86.c",
        "method_name": "handle_emulation_failure",
        "raw_code": "static int handle_emulation_failure(struct kvm_vcpu *vcpu) /* <=== handle_emulation_failure */ \n{\n\t++vcpu->stat.insn_emulation_fail;\n\ttrace_kvm_emulate_insn_failed(vcpu);\n\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n\tvcpu->run->internal.ndata = 0;\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\treturn EMULATE_FAIL;\n}",
        "start_line": 4315
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "arch/x86/kvm/x86.c",
        "method_name": "handle_emulation_failure",
        "raw_code": "static int handle_emulation_failure(struct kvm_vcpu *vcpu) /* <=== handle_emulation_failure */ \n{\n\tint r = EMULATE_DONE;\n\n\t++vcpu->stat.insn_emulation_fail;\n\ttrace_kvm_emulate_insn_failed(vcpu);\n\tif (!is_guest_mode(vcpu)) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n\t\tvcpu->run->internal.ndata = 0;\n\t\tr = EMULATE_FAIL;\n\t}\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\n\treturn r;\n}",
        "start_line": 4315
      }
    ],
    "code_context": "Called Methods:\n- is_guest_mode: static inline bool is_guest_mode(struct kvm_vcpu *vcpu) /* <=== is_guest_mode */ \n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}\n- trace_kvm_emulate_insn_failed: #define trace_kvm_emulate_insn_failed(vcpu) trace_kvm_emulate_insn(vcpu, 1) /* <=== arch/x86/kvm/trace.h:699:699:trace_kvm_emulate_insn_failed:1 */ \n- kvm_multiple_exception: static void kvm_multiple_exception(struct kvm_vcpu *vcpu, /* <=== kvm_multiple_exception */ \n\t\tunsigned nr, bool has_error, u32 error_code,\n\t\tbool reinject)\n{\n\tu32 prev_nr;\n\tint class1, class2;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\tif (!vcpu->arch.exception.pending) {\n\tqueue:\n\t\tvcpu->arch.exception.pending = true;\n\t\tvcpu->arch.exception.has_error_code = has_error;\n\t\tvcpu->arch.exception.nr = nr;\n\t\tvcpu->arch.exception.error_code = error_code;\n\t\tvcpu->arch.exception.reinject = reinject;\n\t\treturn;\n\t}\n\n\t/* to check exception */\n\tprev_nr = vcpu->arch.exception.nr;\n\tif (prev_nr == DF_VECTOR) {\n\t\t/* triple fault -> shutdown */\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\treturn;\n\t}\n\tclass1 = exception_class(prev_nr);\n\tclass2 = exception_class(nr);\n\tif ((class1 == EXCPT_CONTRIBUTORY && class2 == EXCPT_CONTRIBUTORY)\n\t\t|| (class1 == EXCPT_PF && class2 != EXCPT_BENIGN)) {\n\t\t/* generate double fault per SDM Table 5-5 */\n\t\tvcpu->arch.exception.pending = true;\n\t\tvcpu->arch.exception.has_error_code = true;\n\t\tvcpu->arch.exception.nr = DF_VECTOR;\n\t\tvcpu->arch.exception.error_code = 0;\n\t} else\n\t\t/* replace previous exception with a new one in a hope\n\t\t   that instruction re-execution will regenerate lost\n\t\t   exception */\n\t\tgoto queue;\n}\n- kvm_queue_exception: void kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr) /* <=== kvm_queue_exception */ \n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false);\n}\n\nType Definitions:\n- kvm_vcpu: struct kvm_vcpu {\n\tstruct kvm *kvm;\n#ifdef CONFIG_PREEMPT_NOTIFIERS\n\tstruct preempt_notifier preempt_notifier;\n#endif\n\tint vcpu_id;\n\tstruct mutex mutex;\n\tint   cpu;\n\tatomic_t guest_mode;\n\tstruct kvm_run *run;\n\tunsigned long requests;\n\tunsigned long guest_debug;\n\tint srcu_idx;\n\n\tint fpu_active;\n\tint guest_fpu_loaded, guest_xcr0_loaded;\n\twait_queue_head_t wq;\n\tint sigset_active;\n\tsigset_t sigset;\n\tstruct kvm_vcpu_stat stat;\n\n#ifdef CONFIG_HAS_IOMEM\n\tint mmio_needed;\n\tint mmio_read_completed;\n\tint mmio_is_write;\n\tint mmio_size;\n\tunsigned char mmio_data[8];\n\tgpa_t mmio_phys_addr;\n#endif\n\n#ifdef CONFIG_KVM_ASYNC_PF\n\tstruct {\n\t\tu32 queued;\n\t\tstruct list_head queue;\n\t\tstruct list_head done;\n\t\tspinlock_t lock;\n\t} async_pf;\n#endif\n\n\tstruct kvm_vcpu_arch arch;\n}\n- kvm_vcpu: struct kvm_vcpu\n\nImports:\n- #include <linux/hash.h>\n- #include <asm/div64.h>\n- #include \"i8254.h\"\n- #include <asm/debugreg.h>\n- #include \"mmu.h\"\n- #include <asm/pvclock.h>\n- #include <linux/slab.h>\n- #include \"kvm_cache_regs.h\"\n- #include <linux/srcu.h>\n- #include <linux/intel-iommu.h>\n- #include <linux/mman.h>\n- #include <linux/perf_event.h>\n- #include <asm/mce.h>\n- #include <linux/uaccess.h>\n- #include <linux/kvm_host.h>\n- #include \"trace.h\"\n- #include <linux/module.h>\n- #include <linux/cpufreq.h>\n- #include \"irq.h\"\n- #include <trace/events/kvm.h>\n- #include \"x86.h\"\n- #include <linux/clocksource.h>\n- #include <asm/i387.h>\n- #include <asm/mtrr.h>\n- #include <linux/interrupt.h>\n- #include <linux/vmalloc.h>\n- #include <linux/user-return-notifier.h>\n- #include <linux/highmem.h>\n- #include <asm/desc.h>\n- #include <linux/iommu.h>\n- #include <asm/msr.h>\n- #include <linux/fs.h>\n- #include \"tss.h\"\n- #include <asm/xcr.h>\n- #include <linux/kvm.h>",
    "commit_msg": "KVM: X86: Don't report L2 emulation failures to user-space\n\nThis patch prevents that emulation failures which result\nfrom emulating an instruction for an L2-Guest results in\nbeing reported to userspace.\nWithout this patch a malicious L2-Guest would be able to\nkill the L1 by triggering a race-condition between an vmexit\nand the instruction emulator.\nWith this patch the L2 will most likely only kill itself in\nthis situation.\n\nSigned-off-by: Joerg Roedel <joerg.roedel@amd.com>\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>",
    "cve_desc": "[{'lang': 'en', 'value': 'Race condition in arch/x86/kvm/x86.c in the Linux kernel before 2.6.38 allows L2 guest OS users to cause a denial of service (L1 guest OS crash) via a crafted instruction that triggers an L2 emulation failure report, a similar issue to CVE-2014-7842.'}]",
    "year": 2011,
    "filename": "x86.c",
    "commit_url": "\"https://github.com/torvalds/linux/commit/fc3a9157d3148ab91039c75423da8ef97be3e105\""
  },
  {
    "repository": "torvalds/linux",
    "cve_id": "CVE-2010-5332",
    "cwe_list": [
      "CWE-119"
    ],
    "commit_hash": "0926f91083f34d047abc74f1ca4fa6a9c161f7db",
    "short_hash": "0926f910",
    "vulnerableMethods_before": [
      {
        "filename": "drivers/net/mlx4/port.c",
        "method_name": "mlx4_register_mac",
        "raw_code": "int mlx4_register_mac(struct mlx4_dev *dev, u8 port, u64 mac, int *index) /* <=== mlx4_register_mac */ \n{\n\tstruct mlx4_mac_table *table = &mlx4_priv(dev)->port[port].mac_table;\n\tint i, err = 0;\n\tint free = -1;\n\n\tmlx4_dbg(dev, \"Registering MAC: 0x%llx\\n\", (unsigned long long) mac);\n\tmutex_lock(&table->mutex);\n\tfor (i = 0; i < MLX4_MAX_MAC_NUM - 1; i++) {\n\t\tif (free < 0 && !table->refs[i]) {\n\t\t\tfree = i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (mac == (MLX4_MAC_MASK & be64_to_cpu(table->entries[i]))) {\n\t\t\t/* MAC already registered, increase refernce count */\n\t\t\t*index = i;\n\t\t\t++table->refs[i];\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmlx4_dbg(dev, \"Free MAC index is %d\\n\", free);\n\n\tif (table->total == table->max) {\n\t\t/* No free mac entries */\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/* Register new MAC */\n\ttable->refs[free] = 1;\n\ttable->entries[free] = cpu_to_be64(mac | MLX4_MAC_VALID);\n\n\terr = mlx4_set_port_mac_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_err(dev, \"Failed adding MAC: 0x%llx\\n\", (unsigned long long) mac);\n\t\ttable->refs[free] = 0;\n\t\ttable->entries[free] = 0;\n\t\tgoto out;\n\t}\n\n\t*index = free;\n\t++table->total;\nout:\n\tmutex_unlock(&table->mutex);\n\treturn err;\n}",
        "start_line": 93
      },
      {
        "filename": "drivers/net/mlx4/port.c",
        "method_name": "mlx4_register_vlan",
        "raw_code": "int mlx4_register_vlan(struct mlx4_dev *dev, u8 port, u16 vlan, int *index) /* <=== mlx4_register_vlan */ \n{\n\tstruct mlx4_vlan_table *table = &mlx4_priv(dev)->port[port].vlan_table;\n\tint i, err = 0;\n\tint free = -1;\n\n\tmutex_lock(&table->mutex);\n\tfor (i = MLX4_VLAN_REGULAR; i < MLX4_MAX_VLAN_NUM; i++) {\n\t\tif (free < 0 && (table->refs[i] == 0)) {\n\t\t\tfree = i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (table->refs[i] &&\n\t\t    (vlan == (MLX4_VLAN_MASK &\n\t\t\t      be32_to_cpu(table->entries[i])))) {\n\t\t\t/* Vlan already registered, increase refernce count */\n\t\t\t*index = i;\n\t\t\t++table->refs[i];\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (table->total == table->max) {\n\t\t/* No free vlan entries */\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/* Register new MAC */\n\ttable->refs[free] = 1;\n\ttable->entries[free] = cpu_to_be32(vlan | MLX4_VLAN_VALID);\n\n\terr = mlx4_set_port_vlan_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_warn(dev, \"Failed adding vlan: %u\\n\", vlan);\n\t\ttable->refs[free] = 0;\n\t\ttable->entries[free] = 0;\n\t\tgoto out;\n\t}\n\n\t*index = free;\n\t++table->total;\nout:\n\tmutex_unlock(&table->mutex);\n\treturn err;\n}",
        "start_line": 185
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "drivers/net/mlx4/port.c",
        "method_name": "mlx4_register_mac",
        "raw_code": "int mlx4_register_mac(struct mlx4_dev *dev, u8 port, u64 mac, int *index) /* <=== mlx4_register_mac */ \n{\n\tstruct mlx4_mac_table *table = &mlx4_priv(dev)->port[port].mac_table;\n\tint i, err = 0;\n\tint free = -1;\n\n\tmlx4_dbg(dev, \"Registering MAC: 0x%llx\\n\", (unsigned long long) mac);\n\tmutex_lock(&table->mutex);\n\tfor (i = 0; i < MLX4_MAX_MAC_NUM - 1; i++) {\n\t\tif (free < 0 && !table->refs[i]) {\n\t\t\tfree = i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (mac == (MLX4_MAC_MASK & be64_to_cpu(table->entries[i]))) {\n\t\t\t/* MAC already registered, increase refernce count */\n\t\t\t*index = i;\n\t\t\t++table->refs[i];\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (free < 0) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmlx4_dbg(dev, \"Free MAC index is %d\\n\", free);\n\n\tif (table->total == table->max) {\n\t\t/* No free mac entries */\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/* Register new MAC */\n\ttable->refs[free] = 1;\n\ttable->entries[free] = cpu_to_be64(mac | MLX4_MAC_VALID);\n\n\terr = mlx4_set_port_mac_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_err(dev, \"Failed adding MAC: 0x%llx\\n\", (unsigned long long) mac);\n\t\ttable->refs[free] = 0;\n\t\ttable->entries[free] = 0;\n\t\tgoto out;\n\t}\n\n\t*index = free;\n\t++table->total;\nout:\n\tmutex_unlock(&table->mutex);\n\treturn err;\n}",
        "start_line": 93
      },
      {
        "filename": "drivers/net/mlx4/port.c",
        "method_name": "mlx4_register_vlan",
        "raw_code": "int mlx4_register_vlan(struct mlx4_dev *dev, u8 port, u16 vlan, int *index) /* <=== mlx4_register_vlan */ \n{\n\tstruct mlx4_vlan_table *table = &mlx4_priv(dev)->port[port].vlan_table;\n\tint i, err = 0;\n\tint free = -1;\n\n\tmutex_lock(&table->mutex);\n\tfor (i = MLX4_VLAN_REGULAR; i < MLX4_MAX_VLAN_NUM; i++) {\n\t\tif (free < 0 && (table->refs[i] == 0)) {\n\t\t\tfree = i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (table->refs[i] &&\n\t\t    (vlan == (MLX4_VLAN_MASK &\n\t\t\t      be32_to_cpu(table->entries[i])))) {\n\t\t\t/* Vlan already registered, increase refernce count */\n\t\t\t*index = i;\n\t\t\t++table->refs[i];\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (free < 0) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (table->total == table->max) {\n\t\t/* No free vlan entries */\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/* Register new MAC */\n\ttable->refs[free] = 1;\n\ttable->entries[free] = cpu_to_be32(vlan | MLX4_VLAN_VALID);\n\n\terr = mlx4_set_port_vlan_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_warn(dev, \"Failed adding vlan: %u\\n\", vlan);\n\t\ttable->refs[free] = 0;\n\t\ttable->entries[free] = 0;\n\t\tgoto out;\n\t}\n\n\t*index = free;\n\t++table->total;\nout:\n\tmutex_unlock(&table->mutex);\n\treturn err;\n}",
        "start_line": 191
      }
    ],
    "code_context": "Called Methods:\n- MLX4_VLAN_MASK: #define MLX4_VLAN_MASK\t\t0xfff /* <=== drivers/net/mlx4/port.c:44:44:MLX4_VLAN_MASK:0 */ \n- MLX4_MAC_MASK: #define MLX4_MAC_MASK\t\t0xffffffffffffULL /* <=== drivers/net/mlx4/port.c:41:41:MLX4_MAC_MASK:0 */ \n- memcpy: void *memcpy(void *dest, const void *src, size_t n) /* <=== memcpy */ \n{\n\tlong d0, d1, d2;\n\tasm volatile(\n\t\t\"rep ; movsq\\n\\t\"\n\t\t\"movq %4,%%rcx\\n\\t\"\n\t\t\"rep ; movsb\\n\\t\"\n\t\t: \"=&c\" (d0), \"=&D\" (d1), \"=&S\" (d2)\n\t\t: \"0\" (n >> 3), \"g\" (n & 7), \"1\" (dest), \"2\" (src)\n\t\t: \"memory\");\n\n\treturn dest;\n}\n- mlx4_err: #define mlx4_err(mdev, format, arg...) \\ /* <=== drivers/net/mlx4/mlx4.h:95:96:mlx4_err:3 */ \n\tdev_err(&mdev->pdev->dev, format, ##arg)\n- mlx4_alloc_cmd_mailbox: struct mlx4_cmd_mailbox *mlx4_alloc_cmd_mailbox(struct mlx4_dev *dev) /* <=== mlx4_alloc_cmd_mailbox */ \n{\n\tstruct mlx4_cmd_mailbox *mailbox;\n\n\tmailbox = kmalloc(sizeof *mailbox, GFP_KERNEL);\n\tif (!mailbox)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmailbox->buf = pci_pool_alloc(mlx4_priv(dev)->cmd.pool, GFP_KERNEL,\n\t\t\t\t      &mailbox->dma);\n\tif (!mailbox->buf) {\n\t\tkfree(mailbox);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn mailbox;\n}\n- mlx4_set_port_vlan_table: static int mlx4_set_port_vlan_table(struct mlx4_dev *dev, u8 port, /* <=== mlx4_set_port_vlan_table */ \n\t\t\t\t    __be32 *entries)\n{\n\tstruct mlx4_cmd_mailbox *mailbox;\n\tu32 in_mod;\n\tint err;\n\n\tmailbox = mlx4_alloc_cmd_mailbox(dev);\n\tif (IS_ERR(mailbox))\n\t\treturn PTR_ERR(mailbox);\n\n\tmemcpy(mailbox->buf, entries, MLX4_VLAN_TABLE_SIZE);\n\tin_mod = MLX4_SET_PORT_VLAN_TABLE << 8 | port;\n\terr = mlx4_cmd(dev, mailbox->dma, in_mod, 1, MLX4_CMD_SET_PORT,\n\t\t       MLX4_CMD_TIME_CLASS_B);\n\n\tmlx4_free_cmd_mailbox(dev, mailbox);\n\n\treturn err;\n}\n- MLX4_MAC_VALID: #define MLX4_MAC_VALID\t\t(1ull << 63) /* <=== drivers/net/mlx4/port.c:40:40:MLX4_MAC_VALID:0 */ \n- mlx4_set_port_mac_table: static int mlx4_set_port_mac_table(struct mlx4_dev *dev, u8 port, /* <=== mlx4_set_port_mac_table */ \n\t\t\t\t   __be64 *entries)\n{\n\tstruct mlx4_cmd_mailbox *mailbox;\n\tu32 in_mod;\n\tint err;\n\n\tmailbox = mlx4_alloc_cmd_mailbox(dev);\n\tif (IS_ERR(mailbox))\n\t\treturn PTR_ERR(mailbox);\n\n\tmemcpy(mailbox->buf, entries, MLX4_MAC_TABLE_SIZE);\n\n\tin_mod = MLX4_SET_PORT_MAC_TABLE << 8 | port;\n\terr = mlx4_cmd(dev, mailbox->dma, in_mod, 1, MLX4_CMD_SET_PORT,\n\t\t       MLX4_CMD_TIME_CLASS_B);\n\n\tmlx4_free_cmd_mailbox(dev, mailbox);\n\treturn err;\n}\n- MLX4_VLAN_VALID: #define MLX4_VLAN_VALID\t\t(1u << 31) /* <=== drivers/net/mlx4/port.c:43:43:MLX4_VLAN_VALID:0 */ \n- mlx4_cmd: static inline int mlx4_cmd(struct mlx4_dev *dev, u64 in_param, u32 in_modifier, /* <=== mlx4_cmd */ \n\t\t\t   u8 op_modifier, u16 op, unsigned long timeout)\n{\n\treturn __mlx4_cmd(dev, in_param, NULL, 0, in_modifier,\n\t\t\t  op_modifier, op, timeout);\n}\n- mlx4_warn: #define mlx4_warn(mdev, format, arg...) \\ /* <=== drivers/net/mlx4/mlx4.h:99:100:mlx4_warn:3 */ \n\tdev_warn(&mdev->pdev->dev, format, ##arg)\n- mlx4_priv: static inline struct mlx4_priv *mlx4_priv(struct mlx4_dev *dev) /* <=== mlx4_priv */ \n{\n\treturn container_of(dev, struct mlx4_priv, dev);\n}\n- MLX4_MAX_MAC_NUM: #define MLX4_MAX_MAC_NUM\t128 /* <=== drivers/net/mlx4/mlx4.h:246:246:MLX4_MAX_MAC_NUM:0 */ \n- memcpy: void *memcpy(void *to, const void *from, __kernel_size_t n) /* <=== memcpy */ \n{\n\tif (n < LARGE_COPY_CUTOFF)\n\t\treturn (void *)__memcpy_asm(to, from, n);\n\telse\n\t\treturn (void *)fast_copy(to, from, n, __memcpy_asm);\n}\n- MLX4_VLAN_TABLE_SIZE: #define MLX4_VLAN_TABLE_SIZE\t(MLX4_MAX_VLAN_NUM << 2) /* <=== drivers/net/mlx4/mlx4.h:258:258:MLX4_VLAN_TABLE_SIZE:0 */ \n- MLX4_MAC_TABLE_SIZE: #define MLX4_MAC_TABLE_SIZE\t(MLX4_MAX_MAC_NUM << 3) /* <=== drivers/net/mlx4/mlx4.h:247:247:MLX4_MAC_TABLE_SIZE:0 */ \n- mlx4_free_cmd_mailbox: void mlx4_free_cmd_mailbox(struct mlx4_dev *dev, struct mlx4_cmd_mailbox *mailbox) /* <=== mlx4_free_cmd_mailbox */ \n{\n\tif (!mailbox)\n\t\treturn;\n\n\tpci_pool_free(mlx4_priv(dev)->cmd.pool, mailbox->buf, mailbox->dma);\n\tkfree(mailbox);\n}\n- mlx4_dbg: #define mlx4_dbg(mdev, format, arg...)\t\t\t\t\t\\ /* <=== drivers/net/mlx4/mlx4.h:89:93:mlx4_dbg:3 */ \ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (mlx4_debug_level)\t\t\t\t\t\t\\\n\t\tdev_printk(KERN_DEBUG, &mdev->pdev->dev, format, ##arg); \\\n} while (0)\n- MLX4_MAX_VLAN_NUM: #define MLX4_MAX_VLAN_NUM\t128 /* <=== drivers/net/mlx4/mlx4.h:257:257:MLX4_MAX_VLAN_NUM:0 */ \n\nType Definitions:\n- mlx4_dev: struct mlx4_dev {\n\tstruct pci_dev\t       *pdev;\n\tunsigned long\t\tflags;\n\tstruct mlx4_caps\tcaps;\n\tstruct radix_tree_root\tqp_table_tree;\n\tu32\t\t\trev_id;\n\tchar\t\t\tboard_id[MLX4_BOARD_ID_LEN];\n}\n- mlx4_priv: struct mlx4_priv {\n\tstruct mlx4_dev\t\tdev;\n\n\tstruct list_head\tdev_list;\n\tstruct list_head\tctx_list;\n\tspinlock_t\t\tctx_lock;\n\n\tstruct list_head        pgdir_list;\n\tstruct mutex            pgdir_mutex;\n\n\tstruct mlx4_fw\t\tfw;\n\tstruct mlx4_cmd\t\tcmd;\n\n\tstruct mlx4_bitmap\tpd_bitmap;\n\tstruct mlx4_uar_table\tuar_table;\n\tstruct mlx4_mr_table\tmr_table;\n\tstruct mlx4_cq_table\tcq_table;\n\tstruct mlx4_eq_table\teq_table;\n\tstruct mlx4_srq_table\tsrq_table;\n\tstruct mlx4_qp_table\tqp_table;\n\tstruct mlx4_mcg_table\tmcg_table;\n\n\tstruct mlx4_catas_err\tcatas_err;\n\n\tvoid __iomem\t       *clr_base;\n\n\tstruct mlx4_uar\t\tdriver_uar;\n\tvoid __iomem\t       *kar;\n\tstruct mlx4_port_info\tport[MLX4_MAX_PORTS + 1];\n\tstruct mlx4_sense       sense;\n\tstruct mutex\t\tport_mutex;\n}\n- mlx4_mac_table: struct mlx4_mac_table {\n\t__be64\t\t\tentries[MLX4_MAX_MAC_NUM];\n\tint\t\t\trefs[MLX4_MAX_MAC_NUM];\n\tstruct mutex\t\tmutex;\n\tint\t\t\ttotal;\n\tint\t\t\tmax;\n}\n- mlx4_vlan_table: struct mlx4_vlan_table {\n\t__be32\t\t\tentries[MLX4_MAX_VLAN_NUM];\n\tint\t\t\trefs[MLX4_MAX_VLAN_NUM];\n\tstruct mutex\t\tmutex;\n\tint\t\t\ttotal;\n\tint\t\t\tmax;\n}\n\nImports:\n- #include \"mlx4.h\"\n- #include <linux/if_ether.h>\n- #include <linux/mlx4/cmd.h>\n- #include <linux/errno.h>",
    "commit_msg": "mlx4_en: Fix out of bounds array access\n\nWhen searching for a free entry in either mlx4_register_vlan() or\nmlx4_register_mac(), and there is no free entry, the loop terminates without\nupdating the local variable free thus causing out of array bounds access. Fix\nthis by adding a proper check outside the loop.\n\nSigned-off-by: Eli Cohen <eli@mellanox.co.il>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "cve_desc": "[{'lang': 'en', 'value': 'In the Linux kernel before 2.6.37, an out of bounds array access happened in drivers/net/mlx4/port.c. When searching for a free entry in either mlx4_register_vlan() or mlx4_register_mac(), and there is no free entry, the loop terminates without updating the local variable free thus causing out of array bounds access.'}]",
    "year": 2010,
    "filename": "port.c",
    "commit_url": "\"https://github.com/torvalds/linux/commit/0926f91083f34d047abc74f1ca4fa6a9c161f7db\""
  },
  {
    "repository": "yoe/nbd",
    "cve_id": "CVE-2011-0530",
    "cwe_list": [
      "CWE-119"
    ],
    "commit_hash": "3ef52043861ab16352d49af89e048ba6339d6df8",
    "short_hash": "3ef52043",
    "vulnerableMethods_before": [
      {
        "filename": "nbd-server.c",
        "method_name": "mainloop",
        "raw_code": "int mainloop(CLIENT *client) { /* <=== mainloop */ \n\tstruct nbd_request request;\n\tstruct nbd_reply reply;\n\tgboolean go_on=TRUE;\n#ifdef DODBG\n\tint i = 0;\n#endif\n\tnegotiate(client->net, client, NULL);\n\tDEBUG(\"Entering request loop!\\n\");\n\treply.magic = htonl(NBD_REPLY_MAGIC);\n\treply.error = 0;\n\twhile (go_on) {\n\t\tchar buf[BUFSIZE];\n\t\tsize_t len;\n#ifdef DODBG\n\t\ti++;\n\t\tprintf(\"%d: \", i);\n#endif\n\t\treadit(client->net, &request, sizeof(request));\n\t\trequest.from = ntohll(request.from);\n\t\trequest.type = ntohl(request.type);\n\n\t\tif (request.type==NBD_CMD_DISC) {\n\t\t\tmsg2(LOG_INFO, \"Disconnect request received.\");\n                \tif (client->server->flags & F_COPYONWRITE) { \n\t\t\t\tif (client->difmap) g_free(client->difmap) ;\n                \t\tclose(client->difffile);\n\t\t\t\tunlink(client->difffilename);\n\t\t\t\tfree(client->difffilename);\n\t\t\t}\n\t\t\tgo_on=FALSE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlen = ntohl(request.len);\n\n\t\tif (request.magic != htonl(NBD_REQUEST_MAGIC))\n\t\t\terr(\"Not enough magic.\");\n\t\tif (len > BUFSIZE + sizeof(struct nbd_reply))\n\t\t\terr(\"Request too big!\");\n#ifdef DODBG\n\t\tprintf(\"%s from %llu (%llu) len %d, \", request.type ? \"WRITE\" :\n\t\t\t\t\"READ\", (unsigned long long)request.from,\n\t\t\t\t(unsigned long long)request.from / 512, len);\n#endif\n\t\tmemcpy(reply.handle, request.handle, sizeof(reply.handle));\n\t\tif ((request.from + len) > (OFFT_MAX)) {\n\t\t\tDEBUG(\"[Number too large!]\");\n\t\t\tERROR(client, reply, EINVAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (((ssize_t)((off_t)request.from + len) > client->exportsize)) {\n\t\t\tDEBUG(\"[RANGE!]\");\n\t\t\tERROR(client, reply, EINVAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (request.type==NBD_CMD_WRITE) {\n\t\t\tDEBUG(\"wr: net->buf, \");\n\t\t\treadit(client->net, buf, len);\n\t\t\tDEBUG(\"buf->exp, \");\n\t\t\tif ((client->server->flags & F_READONLY) ||\n\t\t\t    (client->server->flags & F_AUTOREADONLY)) {\n\t\t\t\tDEBUG(\"[WRITE to READONLY!]\");\n\t\t\t\tERROR(client, reply, EPERM);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (expwrite(request.from, buf, len, client)) {\n\t\t\t\tDEBUG(\"Write failed: %m\" );\n\t\t\t\tERROR(client, reply, errno);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSEND(client->net, reply);\n\t\t\tDEBUG(\"OK!\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t/* READ */\n\n\t\tDEBUG(\"exp->buf, \");\n\t\tif (expread(request.from, buf + sizeof(struct nbd_reply), len, client)) {\n\t\t\tDEBUG(\"Read failed: %m\");\n\t\t\tERROR(client, reply, errno);\n\t\t\tcontinue;\n\t\t}\n\n\t\tDEBUG(\"buf->net, \");\n\t\tmemcpy(buf, &reply, sizeof(struct nbd_reply));\n\t\twriteit(client->net, buf, len + sizeof(struct nbd_reply));\n\t\tDEBUG(\"OK!\\n\");\n\t}\n\treturn 0;\n}",
        "start_line": 1354
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "nbd-server.c",
        "method_name": "mainloop",
        "raw_code": "int mainloop(CLIENT *client) { /* <=== mainloop */ \n\tstruct nbd_request request;\n\tstruct nbd_reply reply;\n\tgboolean go_on=TRUE;\n#ifdef DODBG\n\tint i = 0;\n#endif\n\tnegotiate(client->net, client, NULL);\n\tDEBUG(\"Entering request loop!\\n\");\n\treply.magic = htonl(NBD_REPLY_MAGIC);\n\treply.error = 0;\n\twhile (go_on) {\n\t\tchar buf[BUFSIZE];\n\t\tsize_t len;\n#ifdef DODBG\n\t\ti++;\n\t\tprintf(\"%d: \", i);\n#endif\n\t\treadit(client->net, &request, sizeof(request));\n\t\trequest.from = ntohll(request.from);\n\t\trequest.type = ntohl(request.type);\n\n\t\tif (request.type==NBD_CMD_DISC) {\n\t\t\tmsg2(LOG_INFO, \"Disconnect request received.\");\n                \tif (client->server->flags & F_COPYONWRITE) { \n\t\t\t\tif (client->difmap) g_free(client->difmap) ;\n                \t\tclose(client->difffile);\n\t\t\t\tunlink(client->difffilename);\n\t\t\t\tfree(client->difffilename);\n\t\t\t}\n\t\t\tgo_on=FALSE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlen = ntohl(request.len);\n\n\t\tif (request.magic != htonl(NBD_REQUEST_MAGIC))\n\t\t\terr(\"Not enough magic.\");\n\t\tif (len > BUFSIZE - sizeof(struct nbd_reply))\n\t\t\terr(\"Request too big!\");\n#ifdef DODBG\n\t\tprintf(\"%s from %llu (%llu) len %d, \", request.type ? \"WRITE\" :\n\t\t\t\t\"READ\", (unsigned long long)request.from,\n\t\t\t\t(unsigned long long)request.from / 512, len);\n#endif\n\t\tmemcpy(reply.handle, request.handle, sizeof(reply.handle));\n\t\tif ((request.from + len) > (OFFT_MAX)) {\n\t\t\tDEBUG(\"[Number too large!]\");\n\t\t\tERROR(client, reply, EINVAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (((ssize_t)((off_t)request.from + len) > client->exportsize)) {\n\t\t\tDEBUG(\"[RANGE!]\");\n\t\t\tERROR(client, reply, EINVAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (request.type==NBD_CMD_WRITE) {\n\t\t\tDEBUG(\"wr: net->buf, \");\n\t\t\treadit(client->net, buf, len);\n\t\t\tDEBUG(\"buf->exp, \");\n\t\t\tif ((client->server->flags & F_READONLY) ||\n\t\t\t    (client->server->flags & F_AUTOREADONLY)) {\n\t\t\t\tDEBUG(\"[WRITE to READONLY!]\");\n\t\t\t\tERROR(client, reply, EPERM);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (expwrite(request.from, buf, len, client)) {\n\t\t\t\tDEBUG(\"Write failed: %m\" );\n\t\t\t\tERROR(client, reply, errno);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSEND(client->net, reply);\n\t\t\tDEBUG(\"OK!\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t/* READ */\n\n\t\tDEBUG(\"exp->buf, \");\n\t\tif (expread(request.from, buf + sizeof(struct nbd_reply), len, client)) {\n\t\t\tDEBUG(\"Read failed: %m\");\n\t\t\tERROR(client, reply, errno);\n\t\t\tcontinue;\n\t\t}\n\n\t\tDEBUG(\"buf->net, \");\n\t\tmemcpy(buf, &reply, sizeof(struct nbd_reply));\n\t\twriteit(client->net, buf, len + sizeof(struct nbd_reply));\n\t\tDEBUG(\"OK!\\n\");\n\t}\n\treturn 0;\n}",
        "start_line": 1354
      }
    ],
    "code_context": "Called Methods:\n- rawexpread_fully: int rawexpread_fully(off_t a, char *buf, size_t len, CLIENT *client) { /* <=== rawexpread_fully */ \n\tssize_t ret=0;\n\n\twhile(len > 0 && (ret=rawexpread(a, buf, len, client)) > 0 ) {\n\t\ta += ret;\n\t\tbuf += ret;\n\t\tlen -= ret;\n\t}\n\treturn (ret < 0 || len != 0);\n}\n- expwrite: int expwrite(off_t a, char *buf, size_t len, CLIENT *client) { /* <=== expwrite */ \n\tchar pagebuf[DIFFPAGESIZE];\n\toff_t mapcnt,mapl,maph;\n\toff_t wrlen,rdlen; \n\toff_t pagestart;\n\toff_t offset;\n\n\tif (!(client->server->flags & F_COPYONWRITE))\n\t\treturn(rawexpwrite_fully(a, buf, len, client)); \n\tDEBUG3(\"Asked to write %d bytes at %llu.\\n\", len, (unsigned long long)a);\n\n\tmapl=a/DIFFPAGESIZE ; maph=(a+len-1)/DIFFPAGESIZE ;\n\n\tfor (mapcnt=mapl;mapcnt<=maph;mapcnt++) {\n\t\tpagestart=mapcnt*DIFFPAGESIZE ;\n\t\toffset=a-pagestart ;\n\t\twrlen=(0<DIFFPAGESIZE-offset && len<(size_t)(DIFFPAGESIZE-offset)) ?\n\t\t\tlen : (size_t)DIFFPAGESIZE-offset;\n\n\t\tif (client->difmap[mapcnt]!=(u32)(-1)) { /* the block is already there */\n\t\t\tDEBUG3(\"Page %llu is at %lu\\n\", (unsigned long long)mapcnt,\n\t\t\t       (unsigned long)(client->difmap[mapcnt])) ;\n\t\t\tmyseek(client->difffile,\n\t\t\t\t\tclient->difmap[mapcnt]*DIFFPAGESIZE+offset);\n\t\t\tif (write(client->difffile, buf, wrlen) != wrlen) return -1 ;\n\t\t} else { /* the block is not there */\n\t\t\tmyseek(client->difffile,client->difffilelen*DIFFPAGESIZE) ;\n\t\t\tclient->difmap[mapcnt]=(client->server->flags&F_SPARSE)?mapcnt:client->difffilelen++;\n\t\t\tDEBUG3(\"Page %llu is not here, we put it at %lu\\n\",\n\t\t\t       (unsigned long long)mapcnt,\n\t\t\t       (unsigned long)(client->difmap[mapcnt]));\n\t\t\trdlen=DIFFPAGESIZE ;\n\t\t\tif (rawexpread_fully(pagestart, pagebuf, rdlen, client))\n\t\t\t\treturn -1;\n\t\t\tmemcpy(pagebuf+offset,buf,wrlen) ;\n\t\t\tif (write(client->difffile, pagebuf, DIFFPAGESIZE) !=\n\t\t\t\t\tDIFFPAGESIZE)\n\t\t\t\treturn -1;\n\t\t}\t\t\t\t\t\t    \n\t\tlen-=wrlen ; a+=wrlen ; buf+=wrlen ;\n\t}\n\treturn 0;\n}\n- BUFSIZE: #define BUFSIZE (1024*1024) /**< Size of buffer that can hold requests */ /* <=== nbd-server.c:153:153:BUFSIZE:0 */ \n- ntohll: u64 ntohll(u64 a) { /* <=== ntohll */ \n\tu32 lo = a & 0xffffffff;\n\tu32 hi = a >> 32U;\n\tlo = ntohl(lo);\n\thi = ntohl(hi);\n\treturn ((u64) lo) << 32U | hi;\n}\n- NBD_REQUEST_MAGIC: #define NBD_REQUEST_MAGIC 0x25609513 /* <=== nbd.h:43:43:NBD_REQUEST_MAGIC:0 */ \n- ERROR: #define ERROR(client,reply,errcode) { reply.error = htonl(errcode); SEND(client->net,reply); reply.error = 0; } /* <=== nbd-server.c:1344:1344:ERROR:3 */ \n- msg2: #define msg2(a,b) g_message(b) /* <=== nbd-server.c:125:125:msg2:2 */ \n- BUFSIZE: #define BUFSIZE ((1024*1024)+sizeof(struct nbd_reply)) /**< Size of buffer that can hold requests */ /* <=== nbd-server.c:153:153:BUFSIZE:0 */ \n- rawexpwrite_fully: int rawexpwrite_fully(off_t a, char *buf, size_t len, CLIENT *client) { /* <=== rawexpwrite_fully */ \n\tssize_t ret=0;\n\n\twhile(len > 0 && (ret=rawexpwrite(a, buf, len, client)) > 0 ) {\n\t\ta += ret;\n\t\tbuf += ret;\n\t\tlen -= ret;\n\t}\n\treturn (ret < 0 || len != 0);\n}\n- err: void err(const char *s) { /* <=== err */ \n\terr_nonfatal(s);\n\texit(EXIT_FAILURE);\n}\n- F_SPARSE: #define F_SPARSE 16\t  /**< flag to tell us copyronwrite should use a sparse file */ /* <=== nbd-server.c:160:160:F_SPARSE:0 */ \n- SEND: #define SEND(net,reply) writeit( net, &reply, sizeof( reply )); /* <=== nbd-server.c:1342:1342:SEND:2 */ \n- F_AUTOREADONLY: #define F_AUTOREADONLY 8  /**< flag to tell us a file is set to autoreadonly */ /* <=== nbd-server.c:159:159:F_AUTOREADONLY:0 */ \n- OFFT_MAX: #define OFFT_MAX ~((off_t)1<<(sizeof(off_t)*8-1)) /* <=== nbd-server.c:150:150:OFFT_MAX:0 */ \n- expread: int expread(off_t a, char *buf, size_t len, CLIENT *client) { /* <=== expread */ \n\toff_t rdlen, offset;\n\toff_t mapcnt, mapl, maph, pagestart;\n\n\tif (!(client->server->flags & F_COPYONWRITE))\n\t\treturn(rawexpread_fully(a, buf, len, client));\n\tDEBUG3(\"Asked to read %d bytes at %llu.\\n\", len, (unsigned long long)a);\n\n\tmapl=a/DIFFPAGESIZE; maph=(a+len-1)/DIFFPAGESIZE;\n\n\tfor (mapcnt=mapl;mapcnt<=maph;mapcnt++) {\n\t\tpagestart=mapcnt*DIFFPAGESIZE;\n\t\toffset=a-pagestart;\n\t\trdlen=(0<DIFFPAGESIZE-offset && len<(size_t)(DIFFPAGESIZE-offset)) ?\n\t\t\tlen : (size_t)DIFFPAGESIZE-offset;\n\t\tif (client->difmap[mapcnt]!=(u32)(-1)) { /* the block is already there */\n\t\t\tDEBUG3(\"Page %llu is at %lu\\n\", (unsigned long long)mapcnt,\n\t\t\t       (unsigned long)(client->difmap[mapcnt]));\n\t\t\tmyseek(client->difffile, client->difmap[mapcnt]*DIFFPAGESIZE+offset);\n\t\t\tif (read(client->difffile, buf, rdlen) != rdlen) return -1;\n\t\t} else { /* the block is not there */\n\t\t\tDEBUG2(\"Page %llu is not here, we read the original one\\n\",\n\t\t\t       (unsigned long long)mapcnt);\n\t\t\tif(rawexpread_fully(a, buf, rdlen, client)) return -1;\n\t\t}\n\t\tlen-=rdlen; a+=rdlen; buf+=rdlen;\n\t}\n\treturn 0;\n}\n- writeit: inline void writeit(int f, void *buf, size_t len) { /* <=== writeit */ \n\tssize_t res;\n\twhile (len > 0) {\n\t\tDEBUG(\"+\");\n\t\tif ((res = write(f, buf, len)) <= 0)\n\t\t\terr(\"Send failed: %m\");\n\t\tlen -= res;\n\t\tbuf += res;\n\t}\n}\n- F_COPYONWRITE: #define F_COPYONWRITE 4\t  /**< flag to tell us a file is exported using /* <=== nbd-server.c:157:157:F_COPYONWRITE:0 */ \n- NBD_REPLY_MAGIC: #define NBD_REPLY_MAGIC 0x67446698 /* <=== nbd.h:44:44:NBD_REPLY_MAGIC:0 */ \n- myseek: void myseek(int handle,off_t a) { /* <=== myseek */ \n\tif (lseek(handle, a, SEEK_SET) < 0) {\n\t\terr(\"Can not seek locally!\\n\");\n\t}\n}\n- err_nonfatal: void err_nonfatal(const char *s) { /* <=== err_nonfatal */ \n\tchar s1[150], *s2;\n\n\tstrncpy(s1, s, sizeof(s1));\n\tif ((s2 = strstr(s, \"%m\"))) {\n\t\tstrcpy(s1 + (s2 - s), strerror(errno));\n\t\ts2 += 2;\n\t\tstrcpy(s1 + strlen(s1), s2);\n\t}\n#ifndef\tsun\n\t/* Solaris doesn't have %h in syslog */\n\telse if ((s2 = strstr(s, \"%h\"))) {\n\t\tstrcpy(s1 + (s2 - s), hstrerror(h_errno));\n\t\ts2 += 2;\n\t\tstrcpy(s1 + strlen(s1), s2);\n\t}\n#endif\n\n\ts1[sizeof(s1)-1] = '\\0';\n#ifdef ISSERVER\n\tsyslog(LOG_ERR, \"%s\", s1);\n\tsyslog(LOG_ERR, \"Exiting.\");\n#endif\n\tfprintf(stderr, \"Error: %s\\nExiting.\\n\", s1);\n}\n- readit: inline void readit(int f, void *buf, size_t len) { /* <=== readit */ \n\tssize_t res;\n\twhile (len > 0) {\n\t\tDEBUG(\"*\");\n\t\tif ((res = read(f, buf, len)) <= 0) {\n\t\t\tif(errno != EAGAIN) {\n\t\t\t\terr(\"Read failed: %m\");\n\t\t\t}\n\t\t} else {\n\t\t\tlen -= res;\n\t\t\tbuf += res;\n\t\t}\n\t}\n}\n- DIFFPAGESIZE: #define DIFFPAGESIZE 4096 /**< diff file uses those chunks */ /* <=== nbd-server.c:154:154:DIFFPAGESIZE:0 */ \n- F_READONLY: #define F_READONLY 1      /**< flag to tell us a file is readonly */ /* <=== nbd-server.c:155:155:F_READONLY:0 */ \n\nType Definitions:\n- CLIENT: typedef struct {\n\toff_t exportsize;    /**< size of the file we're exporting */\n\tchar *clientname;    /**< peer */\n\tchar *exportname;    /**< (processed) filename of the file we're exporting */\n\tGArray *export;    /**< array of FILE_INFO of exported files;\n\t\t\t       array size is always 1 unless we're\n\t\t\t       doing the multiple file option */\n\tint net;\t     /**< The actual client socket */\n\tSERVER *server;\t     /**< The server this client is getting data from */\n\tchar* difffilename;  /**< filename of the copy-on-write file, if any */\n\tint difffile;\t     /**< filedescriptor of copyonwrite file. @todo\n\t\t\t       shouldn't this be an array too? (cfr export) Or\n\t\t\t       make -m and -c mutually exclusive */\n\tu32 difffilelen;     /**< number of pages in difffile */\n\tu32 *difmap;\t     /**< see comment on the global difmap for this one */\n\tgboolean modern;     /**< client was negotiated using modern negotiation protocol */\n}\n- nbd_request: struct nbd_request {\n\t__be32 magic;\n\t__be32 type;\t/* == READ || == WRITE \t*/\n\tchar handle[8];\n\t__be64 from;\n\t__be32 len;\n} __attribute__ ((packed))\n- nbd_reply: struct nbd_reply {\n\t__be32 magic;\n\t__be32 error;\t\t/* 0 = ok, else error\t*/\n\tchar handle[8];\t\t/* handle you got from request\t*/\n}\n\nImports:\n- #include <netinet/tcp.h>\n- #include <arpa/inet.h>\n- #include <strings.h>\n- #include <unistd.h>\n- #include <pwd.h>\n- #include <glib.h>\n- #include <sys/socket.h>\n- #include <getopt.h>\n- #include <sys/param.h>\n- #include <sys/stat.h>\n- #include <grp.h>\n- #include <signal.h>\n- #include <sdp_inet.h>\n- #include <sys/types.h>\n- #include <errno.h>\n- #include <string.h>\n- #include <fcntl.h>\n- #include <dirent.h>\n- #include <sys/ioctl.h>\n- #include <sys/mount.h>\n- #include \"lfs.h\"\n- #include \"cliserv.h\"\n- #include <stdlib.h>\n- #include <syslog.h>\n- #include <stdio.h>\n- #include <sys/select.h>\n- #include <sys/wait.h>\n- #include <netinet/in.h>\n- #include <netdb.h>",
    "commit_msg": "Fix buffer size checking\n\nYes, this means we've re-introduced CVE-2005-3534. Sigh.",
    "cve_desc": "Buffer overflow in the mainloop function in nbd-server.c in the server in Network Block Device (nbd) before 2.9.20 might allow remote attackers to execute arbitrary code via a long request.  NOTE: this issue exists because of a CVE-2005-3534 regression.",
    "year": 2011,
    "filename": "nbd-server.c",
    "commit_url": "\"https://github.com/yoe/nbd/commit/3ef52043861ab16352d49af89e048ba6339d6df8\""
  },
  {
    "repository": "yoe/nbd",
    "cve_id": "CVE-2011-0530",
    "cwe_list": [
      "CWE-119"
    ],
    "commit_hash": "4ed24fe0d64c7cc9963c57b52cad1555ad7c6b60",
    "short_hash": "4ed24fe0",
    "vulnerableMethods_before": [
      {
        "filename": "nbd-server.c",
        "method_name": "mainloop",
        "raw_code": "int mainloop(CLIENT *client) { /* <=== mainloop */ \n\tstruct nbd_request request;\n\tstruct nbd_reply reply;\n\tgboolean go_on=TRUE;\n#ifdef DODBG\n\tint i = 0;\n#endif\n\tnegotiate(client);\n\tDEBUG(\"Entering request loop!\\n\");\n\treply.magic = htonl(NBD_REPLY_MAGIC);\n\treply.error = 0;\n\twhile (go_on) {\n\t\tchar buf[BUFSIZE];\n\t\tsize_t len;\n#ifdef DODBG\n\t\ti++;\n\t\tprintf(\"%d: \", i);\n#endif\n\t\tif (client->server->timeout) \n\t\t\talarm(client->server->timeout);\n\t\treadit(client->net, &request, sizeof(request));\n\t\trequest.from = ntohll(request.from);\n\t\trequest.type = ntohl(request.type);\n\n\t\tif (request.type==NBD_CMD_DISC) {\n\t\t\tmsg2(LOG_INFO, \"Disconnect request received.\");\n\t\t\tif (client->difmap) g_free(client->difmap) ;\n                \tif (client->difffile>=0) { \n                \t\tclose(client->difffile);\n\t\t\t\tunlink(client->difffilename);\n\t\t\t\tfree(client->difffilename);\n\t\t\t}\n\t\t\tgo_on=FALSE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlen = ntohl(request.len);\n\n\t\tif (request.magic != htonl(NBD_REQUEST_MAGIC))\n\t\t\terr(\"Not enough magic.\");\n\t\tif (len > BUFSIZE)\n\t\t\terr(\"Request too big!\");\n#ifdef DODBG\n\t\tprintf(\"%s from %Lu (%Lu) len %d, \", request.type ? \"WRITE\" :\n\t\t\t\t\"READ\", (unsigned long long)request.from,\n\t\t\t\t(unsigned long long)request.from / 512, len);\n#endif\n\t\tmemcpy(reply.handle, request.handle, sizeof(reply.handle));\n\t\tif ((request.from + len) > (OFFT_MAX)) {\n\t\t\tDEBUG(\"[Number too large!]\");\n\t\t\tERROR(client, reply);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (((ssize_t)((off_t)request.from + len) > client->exportsize) ||\n\t\t    ((client->server->flags & F_READONLY) && request.type)) {\n\t\t\tDEBUG(\"[RANGE!]\");\n\t\t\tERROR(client, reply);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (request.type==NBD_CMD_WRITE) {\n\t\t\tDEBUG(\"wr: net->buf, \");\n\t\t\treadit(client->net, buf, len);\n\t\t\tDEBUG(\"buf->exp, \");\n\t\t\tif ((client->server->flags & F_AUTOREADONLY) ||\n\t\t\t\t\texpwrite(request.from, buf, len,\n\t\t\t\t\t\tclient)) {\n\t\t\t\tDEBUG(\"Write failed: %m\" );\n\t\t\t\tERROR(client, reply);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSEND(client->net, reply);\n\t\t\tDEBUG(\"OK!\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t/* READ */\n\n\t\tDEBUG(\"exp->buf, \");\n\t\tif (expread(request.from, buf + sizeof(struct nbd_reply), len, client)) {\n\t\t\tDEBUG(\"Read failed: %m\");\n\t\t\tERROR(client, reply);\n\t\t\tcontinue;\n\t\t}\n\n\t\tDEBUG(\"buf->net, \");\n\t\tmemcpy(buf, &reply, sizeof(struct nbd_reply));\n\t\twriteit(client->net, buf, len + sizeof(struct nbd_reply));\n\t\tDEBUG(\"OK!\\n\");\n\t}\n\treturn 0;\n}",
        "start_line": 650
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "nbd-server.c",
        "method_name": "mainloop",
        "raw_code": "int mainloop(CLIENT *client) { /* <=== mainloop */ \n\tstruct nbd_request request;\n\tstruct nbd_reply reply;\n\tgboolean go_on=TRUE;\n#ifdef DODBG\n\tint i = 0;\n#endif\n\tnegotiate(client);\n\tDEBUG(\"Entering request loop!\\n\");\n\treply.magic = htonl(NBD_REPLY_MAGIC);\n\treply.error = 0;\n\twhile (go_on) {\n\t\tchar buf[BUFSIZE];\n\t\tsize_t len;\n#ifdef DODBG\n\t\ti++;\n\t\tprintf(\"%d: \", i);\n#endif\n\t\tif (client->server->timeout) \n\t\t\talarm(client->server->timeout);\n\t\treadit(client->net, &request, sizeof(request));\n\t\trequest.from = ntohll(request.from);\n\t\trequest.type = ntohl(request.type);\n\n\t\tif (request.type==NBD_CMD_DISC) {\n\t\t\tmsg2(LOG_INFO, \"Disconnect request received.\");\n\t\t\tif (client->difmap) g_free(client->difmap) ;\n                \tif (client->difffile>=0) { \n                \t\tclose(client->difffile);\n\t\t\t\tunlink(client->difffilename);\n\t\t\t\tfree(client->difffilename);\n\t\t\t}\n\t\t\tgo_on=FALSE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlen = ntohl(request.len);\n\n\t\tif (request.magic != htonl(NBD_REQUEST_MAGIC))\n\t\t\terr(\"Not enough magic.\");\n\t\tif (len > BUFSIZE-sizeof(struct nbd_reply))\n\t\t\terr(\"Request too big!\");\n#ifdef DODBG\n\t\tprintf(\"%s from %Lu (%Lu) len %d, \", request.type ? \"WRITE\" :\n\t\t\t\t\"READ\", (unsigned long long)request.from,\n\t\t\t\t(unsigned long long)request.from / 512, len);\n#endif\n\t\tmemcpy(reply.handle, request.handle, sizeof(reply.handle));\n\t\tif ((request.from + len) > (OFFT_MAX)) {\n\t\t\tDEBUG(\"[Number too large!]\");\n\t\t\tERROR(client, reply);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (((ssize_t)((off_t)request.from + len) > client->exportsize) ||\n\t\t    ((client->server->flags & F_READONLY) && request.type)) {\n\t\t\tDEBUG(\"[RANGE!]\");\n\t\t\tERROR(client, reply);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (request.type==NBD_CMD_WRITE) {\n\t\t\tDEBUG(\"wr: net->buf, \");\n\t\t\treadit(client->net, buf, len);\n\t\t\tDEBUG(\"buf->exp, \");\n\t\t\tif ((client->server->flags & F_AUTOREADONLY) ||\n\t\t\t\t\texpwrite(request.from, buf, len,\n\t\t\t\t\t\tclient)) {\n\t\t\t\tDEBUG(\"Write failed: %m\" );\n\t\t\t\tERROR(client, reply);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSEND(client->net, reply);\n\t\t\tDEBUG(\"OK!\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t/* READ */\n\n\t\tDEBUG(\"exp->buf, \");\n\t\tif (expread(request.from, buf + sizeof(struct nbd_reply), len, client)) {\n\t\t\tDEBUG(\"Read failed: %m\");\n\t\t\tERROR(client, reply);\n\t\t\tcontinue;\n\t\t}\n\n\t\tDEBUG(\"buf->net, \");\n\t\tmemcpy(buf, &reply, sizeof(struct nbd_reply));\n\t\twriteit(client->net, buf, len + sizeof(struct nbd_reply));\n\t\tDEBUG(\"OK!\\n\");\n\t}\n\treturn 0;\n}",
        "start_line": 650
      }
    ],
    "code_context": "Called Methods:\n- expread: int expread(off_t a, char *buf, size_t len, CLIENT *client) { /* <=== expread */ \n\toff_t rdlen, offset;\n\toff_t mapcnt, mapl, maph, pagestart;\n\n\tif (!(client->server->flags & F_COPYONWRITE))\n\t\treturn rawexpread(a, buf, len, client);\n\tDEBUG3(\"Asked to read %d bytes at %Lu.\\n\", len, (unsigned long long)a);\n\n\tmapl=a/DIFFPAGESIZE; maph=(a+len-1)/DIFFPAGESIZE;\n\n\tfor (mapcnt=mapl;mapcnt<=maph;mapcnt++) {\n\t\tpagestart=mapcnt*DIFFPAGESIZE;\n\t\toffset=a-pagestart;\n\t\trdlen=(0<DIFFPAGESIZE-offset && len<(size_t)(DIFFPAGESIZE-offset)) ?\n\t\t\tlen : (size_t)DIFFPAGESIZE-offset;\n\t\tif (client->difmap[mapcnt]!=(u32)(-1)) { /* the block is already there */\n\t\t\tDEBUG3(\"Page %Lu is at %lu\\n\", (unsigned long long)mapcnt,\n\t\t\t       (unsigned long)(client->difmap[mapcnt]));\n\t\t\tmyseek(client->difffile, client->difmap[mapcnt]*DIFFPAGESIZE+offset);\n\t\t\tif (read(client->difffile, buf, rdlen) != rdlen) return -1;\n\t\t} else { /* the block is not there */\n\t\t\tDEBUG2(\"Page %Lu is not here, we read the original one\\n\",\n\t\t\t       (unsigned long long)mapcnt);\n\t\t\tif(rawexpread(a, buf, rdlen, client)) return -1;\n\t\t}\n\t\tlen-=rdlen; a+=rdlen; buf+=rdlen;\n\t}\n\treturn 0;\n}\n- rawexpwrite: int rawexpwrite(off_t a, char *buf, size_t len, CLIENT *client) { /* <=== rawexpwrite */ \n\tssize_t res;\n\n\tmyseek(g_array_index(client->export, int, (int)(a/client->server->hunksize)), a%client->server->hunksize);\n\t;\n\tres = write(g_array_index(client->export, int, (int)((off_t)a/(off_t)(client->server->hunksize))), buf, len);\n\treturn (res < 0 || (size_t)res != len);\n}\n- msg2: #define msg2(a,b) g_message(b) /* <=== nbd-server.c:102:102:msg2:2 */ \n- ntohll: u64 ntohll(u64 a) /* <=== ntohll */ \n{\n\tu32 lo = a & 0xffffffff;\n\tu32 hi = a >> 32U;\n\tlo = ntohl(lo);\n\thi = ntohl(hi);\n\treturn ((u64) lo) << 32U | hi;\n}\n- expwrite: int expwrite(off_t a, char *buf, size_t len, CLIENT *client) { /* <=== expwrite */ \n\tchar pagebuf[DIFFPAGESIZE];\n\toff_t mapcnt,mapl,maph;\n\toff_t wrlen,rdlen; \n\toff_t pagestart;\n\toff_t offset;\n\n\tif (!(client->server->flags & F_COPYONWRITE))\n\t\treturn(rawexpwrite(a,buf,len, client)); \n\tDEBUG3(\"Asked to write %d bytes at %Lu.\\n\", len, (unsigned long long)a);\n\n\tmapl=a/DIFFPAGESIZE ; maph=(a+len-1)/DIFFPAGESIZE ;\n\n\tfor (mapcnt=mapl;mapcnt<=maph;mapcnt++) {\n\t\tpagestart=mapcnt*DIFFPAGESIZE ;\n\t\toffset=a-pagestart ;\n\t\twrlen=(0<DIFFPAGESIZE-offset && len<(size_t)(DIFFPAGESIZE-offset)) ?\n\t\t\tlen : (size_t)DIFFPAGESIZE-offset;\n\n\t\tif (client->difmap[mapcnt]!=(u32)(-1)) { /* the block is already there */\n\t\t\tDEBUG3(\"Page %Lu is at %lu\\n\", (unsigned long long)mapcnt,\n\t\t\t       (unsigned long)(client->difmap[mapcnt])) ;\n\t\t\tmyseek(client->difffile,\n\t\t\t\t\tclient->difmap[mapcnt]*DIFFPAGESIZE+offset);\n\t\t\tif (write(client->difffile, buf, wrlen) != wrlen) return -1 ;\n\t\t} else { /* the block is not there */\n\t\t\tmyseek(client->difffile,client->difffilelen*DIFFPAGESIZE) ;\n\t\t\tclient->difmap[mapcnt]=client->difffilelen++ ;\n\t\t\tDEBUG3(\"Page %Lu is not here, we put it at %lu\\n\",\n\t\t\t       (unsigned long long)mapcnt,\n\t\t\t       (unsigned long)(client->difmap[mapcnt]));\n\t\t\trdlen=DIFFPAGESIZE ;\n\t\t\tif (rdlen+pagestart%(client->server->hunksize) >\n\t\t\t\t\t(client->server->hunksize)) \n\t\t\t\trdlen=client->server->hunksize -\n\t\t\t\t\t(pagestart%client->server->hunksize);\n\t\t\tif (rawexpread(pagestart, pagebuf, rdlen, client))\n\t\t\t\treturn -1;\n\t\t\tmemcpy(pagebuf+offset,buf,wrlen) ;\n\t\t\tif (write(client->difffile, pagebuf, DIFFPAGESIZE) !=\n\t\t\t\t\tDIFFPAGESIZE)\n\t\t\t\treturn -1;\n\t\t}\t\t\t\t\t\t    \n\t\tlen-=wrlen ; a+=wrlen ; buf+=wrlen ;\n\t}\n\treturn 0;\n}\n- F_READONLY: #define F_READONLY 1      /**< flag to tell us a file is readonly */ /* <=== nbd-server.c:141:141:F_READONLY:0 */ \n- myseek: void myseek(int handle,off_t a) { /* <=== myseek */ \n\tif (lseek(handle, a, SEEK_SET) < 0) {\n\t\terr(\"Can not seek locally!\\n\");\n\t}\n}\n- BUFSIZE: #define BUFSIZE (1024*1024) /**< Size of buffer that can hold requests */ /* <=== nbd-server.c:136:136:BUFSIZE:0 */ \n- F_AUTOREADONLY: #define F_AUTOREADONLY 8  /**< flag to tell us a file is set to autoreadonly */ /* <=== nbd-server.c:145:145:F_AUTOREADONLY:0 */ \n- readit: inline void readit(int f, void *buf, size_t len) { /* <=== readit */ \n\tssize_t res;\n\twhile (len > 0) {\n\t\tDEBUG(\"*\");\n\t\tif ((res = read(f, buf, len)) <= 0)\n\t\t\terr(\"Read failed: %m\");\n\t\tlen -= res;\n\t\tbuf += res;\n\t}\n}\n- rawexpread: int rawexpread(off_t a, char *buf, size_t len, CLIENT *client) { /* <=== rawexpread */ \n\tssize_t res;\n\n\tmyseek(g_array_index(client->export,int,(int)a/client->server->hunksize),\n\t\t\ta%client->server->hunksize);\n\tres = read(g_array_index(client->export,int,(int)a/client->server->hunksize), buf, len);\n\treturn (res < 0 || (size_t)res != len);\n}\n- DIFFPAGESIZE: #define DIFFPAGESIZE 4096 /**< diff file uses those chunks */ /* <=== nbd-server.c:140:140:DIFFPAGESIZE:0 */ \n- F_COPYONWRITE: #define F_COPYONWRITE 4\t  /**< flag to tell us a file is exported using /* <=== nbd-server.c:143:143:F_COPYONWRITE:0 */ \n- writeit: inline void writeit(int f, void *buf, size_t len) { /* <=== writeit */ \n\tssize_t res;\n\twhile (len > 0) {\n\t\tDEBUG(\"+\");\n\t\tif ((res = write(f, buf, len)) <= 0)\n\t\t\terr(\"Send failed: %m\");\n\t\tlen -= res;\n\t\tbuf += res;\n\t}\n}\n- OFFT_MAX: #define OFFT_MAX (((((off_t)1)<<((sizeof(off_t)-1)*8))-1)<<7)+127 /* <=== nbd-server.c:133:133:OFFT_MAX:0 */ \n- err: void err(const char *s) /* <=== err */ \n{\n\tconst int maxlen = 150;\n\tchar s1[maxlen], *s2;\n\n\tstrncpy(s1, s, maxlen);\n\tif ((s2 = strstr(s, \"%m\"))) {\n\t\tstrcpy(s1 + (s2 - s), strerror(errno));\n\t\ts2 += 2;\n\t\tstrcpy(s1 + strlen(s1), s2);\n\t}\n#ifndef\tsun\n\t/* Solaris doesn't have %h in syslog */\n\telse if ((s2 = strstr(s, \"%h\"))) {\n\t\tstrcpy(s1 + (s2 - s), hstrerror(h_errno));\n\t\ts2 += 2;\n\t\tstrcpy(s1 + strlen(s1), s2);\n\t}\n#endif\n\n\ts1[maxlen-1] = '\\0';\n#ifdef ISSERVER\n\tsyslog(LOG_ERR, \"%s\", s1);\n#else\n\tfprintf(stderr, \"Error: %s\\n\", s1);\n#endif\n\texit(1);\n}\n- SEND: #define SEND(net,reply) writeit( net, &reply, sizeof( reply )); /* <=== nbd-server.c:638:638:SEND:2 */ \n- ERROR: #define ERROR(client,reply) { reply.error = htonl(-1); SEND(client->net,reply); reply.error = 0; } /* <=== nbd-server.c:640:640:ERROR:2 */ \n\nType Definitions:\n- CLIENT: typedef struct {\n\toff_t exportsize;    /**< size of the file we're exporting */\n\tchar *clientname;    /**< peer */\n\tchar *exportname;    /**< (processed) filename of the file we're exporting */\n\tGArray *export;    /**< array of filedescriptors of exported files;\n\t\t\t       only the first is actually used unless we're\n\t\t\t       doing the multiple file option */\n\tint net;\t     /**< The actual client socket */\n\tSERVER *server;\t     /**< The server this client is getting data from */\n\tchar* difffilename;  /**< filename of the copy-on-write file, if any */\n\tint difffile;\t     /**< filedescriptor of copyonwrite file. @todo\n\t\t\t       shouldn't this be an array too? (cfr export) Or\n\t\t\t       make -m and -c mutually exclusive */\n\tu32 difffilelen;     /**< number of pages in difffile */\n\tu32 *difmap;\t     /**< see comment on the global difmap for this one */\n}\n\nImports:\n- #include <dirent.h>\n- #include <glib.h>\n- #include <sys/types.h>\n- #include \"lfs.h\"\n- #include <stdio.h>\n- #include <sys/stat.h>\n- #include <stdlib.h>\n- #include <string.h>\n- #include <sys/mount.h>\n- #include <strings.h>\n- #include <sys/wait.h>\n- #include <netinet/tcp.h>\n- #include <sys/param.h>\n- #include <unistd.h>\n- #include <sys/ioctl.h>\n- #include <signal.h>\n- #include <arpa/inet.h>\n- #include <syslog.h>\n- #include <getopt.h>\n- #include <netinet/in.h>\n- #include <netdb.h>\n- #include <sys/socket.h>\n- #include \"cliserv.h\"\n- #include <fcntl.h>",
    "commit_msg": "r134: CVE-2005-3534",
    "cve_desc": "Buffer overflow in the mainloop function in nbd-server.c in the server in Network Block Device (nbd) before 2.9.20 might allow remote attackers to execute arbitrary code via a long request.  NOTE: this issue exists because of a CVE-2005-3534 regression.",
    "year": 2005,
    "filename": "nbd-server.c",
    "commit_url": "\"https://github.com/yoe/nbd/commit/4ed24fe0d64c7cc9963c57b52cad1555ad7c6b60\""
  },
  {
    "repository": "mono/mono",
    "cve_id": "CVE-2011-0989",
    "cwe_list": [
      "CWE-264"
    ],
    "commit_hash": "035c8587c0d8d307e45f1b7171a0d337bb451f1e",
    "short_hash": "035c8587",
    "vulnerableMethods_before": [
      {
        "filename": "mono/metadata/icall.c",
        "method_name": "ves_icall_System_Runtime_CompilerServices_RuntimeHelpers_InitializeArray",
        "raw_code": "static void /* <=== ves_icall_System_Runtime_CompilerServices_RuntimeHelpers_InitializeArray */ \nves_icall_System_Runtime_CompilerServices_RuntimeHelpers_InitializeArray (MonoArray *array, MonoClassField *field_handle)\n{\n\tMonoClass *klass = array->obj.vtable->klass;\n\tguint32 size = mono_array_element_size (klass);\n\tMonoType *type = mono_type_get_underlying_type (&klass->element_class->byval_arg);\n\tint align;\n\tconst char *field_data;\n\n\tif (MONO_TYPE_IS_REFERENCE (type) ||\n\t\t\t(type->type == MONO_TYPE_VALUETYPE &&\n\t\t\t\t(!mono_type_get_class (type) ||\n\t\t\t\tmono_type_get_class (type)->has_references))) {\n\t\tMonoException *exc = mono_get_exception_argument(\"array\",\n\t\t\t\"Cannot initialize array containing references\");\n\t\tmono_raise_exception (exc);\n\t}\n\n\tif (!(field_handle->type->attrs & FIELD_ATTRIBUTE_HAS_FIELD_RVA)) {\n\t\tMonoException *exc = mono_get_exception_argument(\"field_handle\",\n\t\t\t\"Field doesn't have an RVA\");\n\t\tmono_raise_exception (exc);\n\t}\n\n\tsize *= array->max_length;\n\tfield_data = mono_field_get_data (field_handle);\n\n\tif (size > mono_type_size (field_handle->type, &align)) {\n\t\tMonoException *exc = mono_get_exception_argument(\"field_handle\",\n\t\t\t\"Field not large enough to fill array\");\n\t\tmono_raise_exception (exc);\n\t}\n\n#if G_BYTE_ORDER != G_LITTLE_ENDIAN\n#define SWAP(n) {\\\n\tguint ## n *data = (guint ## n *) mono_array_addr (array, char, 0); \\\n\tguint ## n *src = (guint ## n *) field_data; \\\n\tguint ## n *end = (guint ## n *)((char*)src + size); \\\n\\\n\tfor (; src < end; data++, src++) { \\\n\t\t*data = read ## n (src); \\\n\t} \\\n}\n\n\t/* printf (\"Initialize array with elements of %s type\\n\", klass->element_class->name); */\n\n\tswitch (type->type) {\n\tcase MONO_TYPE_CHAR:\n\tcase MONO_TYPE_I2:\n\tcase MONO_TYPE_U2:\n\t\tSWAP (16);\n\t\tbreak;\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_U4:\n\tcase MONO_TYPE_R4:\n\t\tSWAP (32);\n\t\tbreak;\n\tcase MONO_TYPE_I8:\n\tcase MONO_TYPE_U8:\n\tcase MONO_TYPE_R8:\n\t\tSWAP (64);\n\t\tbreak;\n\tdefault:\n\t\tmemcpy (mono_array_addr (array, char, 0), field_data, size);\n\t\tbreak;\n\t}\n#else\n\tmemcpy (mono_array_addr (array, char, 0), field_data, size);\n#ifdef ARM_FPU_FPA\n\tif (klass->element_class->byval_arg.type == MONO_TYPE_R8) {\n\t\tgint i;\n\t\tdouble tmp;\n\t\tdouble *data = (double*)mono_array_addr (array, double, 0);\n\n\t\tfor (i = 0; i < size; i++, data++) {\n\t\t\treadr8 (data, &tmp);\n\t\t\t*data = tmp;\n\t\t}\n\t}\n#endif\n#endif\n}",
        "start_line": 848
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "mono/metadata/icall.c",
        "method_name": "ves_icall_System_Runtime_CompilerServices_RuntimeHelpers_InitializeArray",
        "raw_code": "static void /* <=== ves_icall_System_Runtime_CompilerServices_RuntimeHelpers_InitializeArray */ \nves_icall_System_Runtime_CompilerServices_RuntimeHelpers_InitializeArray (MonoArray *array, MonoClassField *field_handle)\n{\n\tMonoClass *klass = array->obj.vtable->klass;\n\tguint32 size = mono_array_element_size (klass);\n\tMonoType *type = mono_type_get_underlying_type (&klass->element_class->byval_arg);\n\tint align;\n\tconst char *field_data;\n\n\tif (MONO_TYPE_IS_REFERENCE (type) || type->type == MONO_TYPE_VALUETYPE) {\n\t\tMonoException *exc = mono_get_exception_argument(\"array\",\n\t\t\t\"Cannot initialize array of non-primitive type.\");\n\t\tmono_raise_exception (exc);\n\t}\n\n\tif (!(field_handle->type->attrs & FIELD_ATTRIBUTE_HAS_FIELD_RVA)) {\n\t\tMonoException *exc = mono_get_exception_argument(\"field_handle\",\n\t\t\t\"Field doesn't have an RVA\");\n\t\tmono_raise_exception (exc);\n\t}\n\n\tsize *= array->max_length;\n\tfield_data = mono_field_get_data (field_handle);\n\n\tif (size > mono_type_size (field_handle->type, &align)) {\n\t\tMonoException *exc = mono_get_exception_argument(\"field_handle\",\n\t\t\t\"Field not large enough to fill array\");\n\t\tmono_raise_exception (exc);\n\t}\n\n#if G_BYTE_ORDER != G_LITTLE_ENDIAN\n#define SWAP(n) {\\\n\tguint ## n *data = (guint ## n *) mono_array_addr (array, char, 0); \\\n\tguint ## n *src = (guint ## n *) field_data; \\\n\tguint ## n *end = (guint ## n *)((char*)src + size); \\\n\\\n\tfor (; src < end; data++, src++) { \\\n\t\t*data = read ## n (src); \\\n\t} \\\n}\n\n\t/* printf (\"Initialize array with elements of %s type\\n\", klass->element_class->name); */\n\n\tswitch (type->type) {\n\tcase MONO_TYPE_CHAR:\n\tcase MONO_TYPE_I2:\n\tcase MONO_TYPE_U2:\n\t\tSWAP (16);\n\t\tbreak;\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_U4:\n\tcase MONO_TYPE_R4:\n\t\tSWAP (32);\n\t\tbreak;\n\tcase MONO_TYPE_I8:\n\tcase MONO_TYPE_U8:\n\tcase MONO_TYPE_R8:\n\t\tSWAP (64);\n\t\tbreak;\n\tdefault:\n\t\tmemcpy (mono_array_addr (array, char, 0), field_data, size);\n\t\tbreak;\n\t}\n#else\n\tmemcpy (mono_array_addr (array, char, 0), field_data, size);\n#ifdef ARM_FPU_FPA\n\tif (klass->element_class->byval_arg.type == MONO_TYPE_R8) {\n\t\tgint i;\n\t\tdouble tmp;\n\t\tdouble *data = (double*)mono_array_addr (array, double, 0);\n\n\t\tfor (i = 0; i < size; i++, data++) {\n\t\t\treadr8 (data, &tmp);\n\t\t\t*data = tmp;\n\t\t}\n\t}\n#endif\n#endif\n}",
        "start_line": 848
      }
    ],
    "code_context": "Called Methods:\n- mono_gc_wbarrier_set_field: void mono_gc_wbarrier_set_field     (MonoObject *obj, gpointer field_ptr, MonoObject* value); /* <=== mono_gc_wbarrier_set_field */ \n- mono_type_get_underlying_type: MonoType* /* <=== mono_type_get_underlying_type */ \nmono_type_get_underlying_type (MonoType *type)\n{\n\tif (type->type == MONO_TYPE_VALUETYPE && type->data.klass->enumtype && !type->byref)\n\t\treturn mono_class_enum_basetype (type->data.klass);\n\tif (type->type == MONO_TYPE_GENERICINST && type->data.generic_class->container_class->enumtype && !type->byref)\n\t\treturn mono_class_enum_basetype (type->data.generic_class->container_class);\n\treturn type;\n}\n- MONO_OBJECT_SETREF: #define MONO_OBJECT_SETREF(obj,fieldname,value) do {\t\\ /* <=== mono/metadata/object.h:71:74:MONO_OBJECT_SETREF:3 */ \n\t\tmono_gc_wbarrier_set_field ((MonoObject*)(obj), &((obj)->fieldname), (MonoObject*)value);\t\\\n\t\t/*(obj)->fieldname = (value);*/\t\\\n\t} while (0)\n- mono_thread_current: MonoThread * /* <=== mono_thread_current */ \nmono_thread_current (void)\n{\n\tMonoThread *res = GET_CURRENT_OBJECT ();\n\tTHREAD_DEBUG (g_message (\"%s: returning %p\", __func__, res));\n\treturn res;\n}\n- mono_type_get_class: MonoClass* /* <=== mono_type_get_class */ \nmono_type_get_class      (MonoType *type);\n- mono_class_enum_basetype: MonoType* /* <=== mono_class_enum_basetype */ \nmono_class_enum_basetype (MonoClass *klass)\n{\n\tif (klass->element_class == klass)\n\t\t/* SRE or broken types */\n\t\treturn NULL;\n\telse\n\t\treturn &klass->element_class->byval_arg;\n}\n- mono_raise_exception: void /* <=== mono_raise_exception */ \nmono_raise_exception (MonoException *ex) \n{\n\t/*\n\t * NOTE: Do NOT annotate this function with G_GNUC_NORETURN, since\n\t * that will cause gcc to omit the function epilog, causing problems when\n\t * the JIT tries to walk the stack, since the return address on the stack\n\t * will point into the next function in the executable, not this one.\n\t */\n\n\tif (((MonoObject*)ex)->vtable->klass == mono_defaults.threadabortexception_class) {\n\t\tMonoThread *thread = mono_thread_current ();\n\t\tg_assert (ex->object.vtable->domain == mono_domain_get ());\n\t\tMONO_OBJECT_SETREF (thread, abort_exc, ex);\n\t}\n\t\n\tex_handler (ex);\n}\n- mono_get_exception_argument: MonoException * /* <=== mono_get_exception_argument */ \nmono_get_exception_argument (const char *arg, const char *msg)\n{\n\tMonoException *ex;\n\n\tex = mono_exception_from_name_msg (\n\t\tmono_get_corlib (), \"System\", \"ArgumentException\", msg);\n\n\tif (arg) {\n\t\tMonoArgumentException *argex = (MonoArgumentException *)ex;\n\t\tMONO_OBJECT_SETREF (argex, param_name, mono_string_new (mono_object_get_domain ((MonoObject*)ex), arg));\n\t}\n\t\n\treturn ex;\n}\n- mono_string_new: MonoString* /* <=== mono_string_new */ \nmono_string_new (MonoDomain *domain, const char *text)\n{\n    GError *error = NULL;\n    MonoString *o = NULL;\n    guint16 *ut;\n    glong items_written;\n    int l;\n\n    l = strlen (text);\n   \n    ut = g_utf8_to_utf16 (text, l, NULL, &items_written, &error);\n\n    if (!error)\n        o = mono_string_new_utf16 (domain, ut, items_written);\n    else\n        g_error_free (error);\n\n    g_free (ut);\n/*FIXME g_utf8_get_char, g_utf8_next_char and g_utf8_validate are not part of eglib.*/\n#if 0\n\tgunichar2 *str;\n\tconst gchar *end;\n\tint len;\n\tMonoString *o = NULL;\n\n\tif (!g_utf8_validate (text, -1, &end))\n\t\treturn NULL;\n\n\tlen = g_utf8_strlen (text, -1);\n\to = mono_string_new_size (domain, len);\n\tstr = mono_string_chars (o);\n\n\twhile (text < end) {\n\t\t*str++ = g_utf8_get_char (text);\n\t\ttext = g_utf8_next_char (text);\n\t}\n#endif\n\treturn o;\n}\n- mono_get_corlib: MonoImage* /* <=== mono_get_corlib */ \nmono_get_corlib            (void);\n- mono_exception_from_name_msg: MonoException * /* <=== mono_exception_from_name_msg */ \nmono_exception_from_name_msg (MonoImage *image, const char *name_space,\n\t\t\t      const char *name, const char *msg)\n{\n\tMonoException *ex;\n\n\tex = mono_exception_from_name (image, name_space, name);\n\n\tif (msg)\n\t\tMONO_OBJECT_SETREF (ex, message, mono_string_new (mono_object_get_domain ((MonoObject*)ex), msg));\n\n\treturn ex;\n}\n- mono_object_get_domain: MonoDomain* /* <=== mono_object_get_domain */ \nmono_object_get_domain (MonoObject *obj)\n{\n\treturn mono_object_domain (obj);\n}\n- mono_domain_get: MonoDomain * /* <=== mono_domain_get */ \nmono_domain_get            (void);\n\nType Definitions:\n- MonoException: typedef struct _MonoException MonoException;\n- MonoClass: typedef struct _MonoClass MonoClass;\n- MonoType: typedef struct _MonoType MonoType;\n- MonoArray: typedef struct {\n\tMonoObject obj;\n\t/* bounds is NULL for szarrays */\n\tMonoArrayBounds *bounds;\n\t/* total number of elements of the array */\n\tmono_array_size_t max_length; \n\t/* we use double to ensure proper alignment on platforms that need it */\n\tdouble vector [MONO_ZERO_LEN_ARRAY];\n}\n\nImports:\n- #include <mono/metadata/monitor.h>\n- #include <mono/utils/mono-proclib.h>\n- #include <mono/utils/strtod.h>\n- #include <mono/metadata/reflection.h>\n- #include <mono/metadata/string-icalls.h>\n- #include <mono/metadata/assembly.h>\n- #include <mono/metadata/number-formatter.h>\n- #include <mono/metadata/tokentype.h>\n- #include <mono/metadata/marshal.h>\n- #include <sys/time.h>\n- #include <mono/metadata/profiler-private.h>\n- #include <mono/metadata/verify-internals.h>\n- #include <mono/metadata/security-manager.h>\n- #include <mono/metadata/filewatcher.h>\n- #include <mono/metadata/object.h>\n- #include <mono/metadata/environment.h>\n- #include <unistd.h>\n- #include <string.h>\n- #include <mono/metadata/sysmath.h>\n- #include <mono/metadata/cil-coff.h>\n- #include <mono/metadata/threadpool.h>\n- #include <mono/metadata/char-conversions.h>\n- #include <mono/utils/mono-error-internals.h>\n- #include <stdlib.h>\n- #include <mono/metadata/metadata-internals.h>\n- #include <mono/utils/mono-time.h>\n- #include \"mono/utils/mono-membar.h\"\n- #include <mono/utils/mono-string.h>\n- #include <stdarg.h>\n- #include <mono/metadata/console-io.h>\n- #include <mono/metadata/mono-gc.h>\n- #include <glib.h>\n- #include <mono/metadata/process.h>\n- #include <mono/metadata/security.h>\n- #include <mono/metadata/socket-io.h>\n- #include <mono/metadata/mono-endian.h>\n- #include <mono/metadata/mono-perfcounters.h>\n- #include <shlobj.h>\n- #include <mono/metadata/domain-internals.h>\n- #include <mono/utils/monobitset.h>\n- #include <mono/metadata/rand.h>\n- #include <mono/metadata/locales.h>\n- #include <mono/metadata/mono-config.h>\n- #include <windows.h>\n- #include <mono/io-layer/io-layer.h>\n- #include <mono/metadata/exception.h>\n- #include <mono/metadata/gc-internal.h>\n- #include <mono/metadata/threads-types.h>\n- #include <alloca.h>\n- #include <mono/metadata/file-io.h>\n- #include <mono/metadata/class-internals.h>\n- #include <ctype.h>\n- #include <config.h>\n- #include <mono/metadata/threads.h>\n- #include \"metadata/icall-def.h\"\n- #include <mono/metadata/security-core-clr.h>\n- #include <mono/metadata/mono-debug.h>\n- #include \"decimal.h\"\n- #include <mono/metadata/debug-helpers.h>\n- #include <mono/metadata/tabledefs.h>",
    "commit_msg": "Allow only primitive types/enums in RuntimeHelpers.InitializeArray ().",
    "cve_desc": "The RuntimeHelpers.InitializeArray method in metadata/icall.c in Mono, when Moonlight 2.x before 2.4.1 or 3.x before 3.99.3 is used, does not properly restrict data types, which allows remote attackers to modify internal read-only data structures, and cause a denial of service (plugin crash) or corrupt the internal state of the security manager, via a crafted media file, as demonstrated by modifying a C# struct.",
    "year": 2011,
    "filename": "icall.c",
    "commit_url": "\"https://github.com/mono/mono/commit/035c8587c0d8d307e45f1b7171a0d337bb451f1e\""
  },
  {
    "repository": "mono/mono",
    "cve_id": "CVE-2011-0989",
    "cwe_list": [
      "CWE-264"
    ],
    "commit_hash": "722f9890f09aadfc37ae479e7d946d5fc5ef7b91",
    "short_hash": "722f9890",
    "vulnerableMethods_before": [
      {
        "filename": "mono/metadata/threads.c",
        "method_name": "ves_icall_System_Threading_InternalThread_Thread_free_internal",
        "raw_code": "void ves_icall_System_Threading_InternalThread_Thread_free_internal (MonoInternalThread *this, HANDLE thread) /* <=== ves_icall_System_Threading_InternalThread_Thread_free_internal */ \n{\n\tMONO_ARCH_SAVE_REGS;\n\n\tTHREAD_DEBUG (g_message (\"%s: Closing thread %p, handle %p\", __func__, this, thread));\n\n\tif (thread)\n\t\tCloseHandle (thread);\n\n\tif (this->synch_cs) {\n\t\tDeleteCriticalSection (this->synch_cs);\n\t\tg_free (this->synch_cs);\n\t\tthis->synch_cs = NULL;\n\t}\n\n\tg_free (this->name);\n}",
        "start_line": 1029
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "mono/metadata/threads.c",
        "method_name": "ves_icall_System_Threading_InternalThread_Thread_free_internal",
        "raw_code": "void ves_icall_System_Threading_InternalThread_Thread_free_internal (MonoInternalThread *this, HANDLE thread) /* <=== ves_icall_System_Threading_InternalThread_Thread_free_internal */ \n{\n\tMONO_ARCH_SAVE_REGS;\n\n\tTHREAD_DEBUG (g_message (\"%s: Closing thread %p, handle %p\", __func__, this, thread));\n\n\tif (thread)\n\t\tCloseHandle (thread);\n\n\tif (this->synch_cs) {\n\t\tCRITICAL_SECTION *synch_cs = this->synch_cs;\n\t\tthis->synch_cs = NULL;\n\t\tDeleteCriticalSection (synch_cs);\n\t\tg_free (synch_cs);\n\t}\n\n\tif (this->name) {\n\t\tvoid *name = this->name;\n\t\tthis->name = NULL;\n\t\tg_free (name);\n\t}\n}",
        "start_line": 1029
      }
    ],
    "code_context": "Called Methods:\n- DeleteCriticalSection: void DeleteCriticalSection(WapiCriticalSection *section) /* <=== DeleteCriticalSection */ \n{\n\tint ret;\n\t\n\tret = mono_mutex_destroy(&section->mutex);\n\tg_assert (ret == 0);\n}\n- g_free: void /* <=== g_free */ \ng_free (void *ptr)\n{\n\tif (ptr != NULL)\n\t\tfree (ptr);\n}\n- mono_mutex_destroy: #define mono_mutex_destroy(mutex) pthread_mutex_destroy (mutex) /* <=== mono/io-layer/mono-mutex.h:143:143:mono_mutex_destroy:1 */ \n\nType Definitions:\n- MonoInternalThread: typedef struct _MonoInternalThread MonoInternalThread;\n- CRITICAL_SECTION: typedef WapiCriticalSection CRITICAL_SECTION;\n\nImports:\n- #include <mono/utils/mono-membar.h>\n- #include <mono/metadata/domain-internals.h>\n- #include <pthread.h>\n- #include <pthread_np.h>\n- #include <mono/metadata/gc-internal.h>\n- #include <mono/metadata/threads.h>\n- #include <mono/io-layer/io-layer.h>\n- #include <mono/metadata/profiler-private.h>\n- #include <mono/metadata/object.h>\n- #include <mono/metadata/environment.h>\n- #include <mono/utils/mono-time.h>\n- #include <config.h>\n- #include <mono/metadata/threads-types.h>\n- #include <mono/metadata/mono-debug-debugger.h>\n- #include <mono/metadata/threadpool.h>\n- #include <string.h>\n- #include <mono/metadata/monitor.h>\n- #include <mono/metadata/object-internals.h>\n- #include <mono/utils/mono-mmap.h>\n- #include <mono/io-layer/threads.h>\n- #include <mono/utils/mono-compiler.h>\n- #include <mono/utils/hazard-pointer.h>\n- #include <mono/metadata/exception.h>\n- #include <signal.h>\n- #include <glib.h>\n- #include <errno.h>\n- #include <mono/metadata/marshal.h>",
    "commit_msg": "Fix access to freed members of a dead thread\n\n* threads.c: Fix access to freed members of a dead thread. Found\nand fixed by Rodrigo Kumpera <rkumpera@novell.com>\nRef: CVE-2011-0992",
    "cve_desc": "The RuntimeHelpers.InitializeArray method in metadata/icall.c in Mono, when Moonlight 2.x before 2.4.1 or 3.x before 3.99.3 is used, does not properly restrict data types, which allows remote attackers to modify internal read-only data structures, and cause a denial of service (plugin crash) or corrupt the internal state of the security manager, via a crafted media file, as demonstrated by modifying a C# struct.",
    "year": 2011,
    "filename": "threads.c",
    "commit_url": "\"https://github.com/mono/mono/commit/722f9890f09aadfc37ae479e7d946d5fc5ef7b91\""
  },
  {
    "repository": "mono/mono",
    "cve_id": "CVE-2011-0990",
    "cwe_list": [
      "CWE-362"
    ],
    "commit_hash": "2f00e4bbb2137130845afb1b2a1e678552fc8e5c",
    "short_hash": "2f00e4bb",
    "vulnerableMethods_before": [
      {
        "filename": "mono/metadata/icall.c",
        "method_name": "ves_icall_System_Array_FastCopy",
        "raw_code": "static gboolean /* <=== ves_icall_System_Array_FastCopy */ \nves_icall_System_Array_FastCopy (MonoArray *source, int source_idx, MonoArray* dest, int dest_idx, int length)\n{\n\tint element_size;\n\tvoid * dest_addr;\n\tvoid * source_addr;\n\tMonoClass *src_class;\n\tMonoClass *dest_class;\n\tint i;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (source->obj.vtable->klass->rank != dest->obj.vtable->klass->rank)\n\t\treturn FALSE;\n\n\tif (source->bounds || dest->bounds)\n\t\treturn FALSE;\n\n\t/* there's no integer overflow since mono_array_length returns an unsigned integer */\n\tif ((dest_idx + length > mono_array_length (dest)) ||\n\t\t(source_idx + length > mono_array_length (source)))\n\t\treturn FALSE;\n\n\tsrc_class = source->obj.vtable->klass->element_class;\n\tdest_class = dest->obj.vtable->klass->element_class;\n\n\t/*\n\t * Handle common cases.\n\t */\n\n\t/* Case1: object[] -> valuetype[] (ArrayList::ToArray) */\n\tif (src_class == mono_defaults.object_class && dest_class->valuetype) {\n\t\tint has_refs = dest_class->has_references;\n\t\tfor (i = source_idx; i < source_idx + length; ++i) {\n\t\t\tMonoObject *elem = mono_array_get (source, MonoObject*, i);\n\t\t\tif (elem && !mono_object_isinst (elem, dest_class))\n\t\t\t\treturn FALSE;\n\t\t}\n\n\t\telement_size = mono_array_element_size (dest->obj.vtable->klass);\n\t\tmemset (mono_array_addr_with_size (dest, element_size, dest_idx), 0, element_size * length);\n\t\tfor (i = 0; i < length; ++i) {\n\t\t\tMonoObject *elem = mono_array_get (source, MonoObject*, source_idx + i);\n\t\t\tvoid *addr = mono_array_addr_with_size (dest, element_size, dest_idx + i);\n\t\t\tif (!elem)\n\t\t\t\tcontinue;\n\t\t\tif (has_refs)\n\t\t\t\tmono_value_copy (addr, (char *)elem + sizeof (MonoObject), dest_class);\n\t\t\telse\n\t\t\t\tmemcpy (addr, (char *)elem + sizeof (MonoObject), element_size);\n\t\t}\n\t\treturn TRUE;\n\t}\n\n\t/* Check if we're copying a char[] <==> (u)short[] */\n\tif (src_class != dest_class) {\n\t\tif (dest_class->valuetype || dest_class->enumtype || src_class->valuetype || src_class->enumtype)\n\t\t\treturn FALSE;\n\n\t\tif (mono_class_is_subclass_of (src_class, dest_class, FALSE))\n\t\t\t;\n\t\t/* Case2: object[] -> reftype[] (ArrayList::ToArray) */\n\t\telse if (mono_class_is_subclass_of (dest_class, src_class, FALSE))\n\t\t\tfor (i = source_idx; i < source_idx + length; ++i) {\n\t\t\t\tMonoObject *elem = mono_array_get (source, MonoObject*, i);\n\t\t\t\tif (elem && !mono_object_isinst (elem, dest_class))\n\t\t\t\t\treturn FALSE;\n\t\t\t}\n\t\telse\n\t\t\treturn FALSE;\n\t}\n\n\tif (dest_class->valuetype) {\n\t\telement_size = mono_array_element_size (source->obj.vtable->klass);\n\t\tsource_addr = mono_array_addr_with_size (source, element_size, source_idx);\n\t\tif (dest_class->has_references) {\n\t\t\tmono_value_copy_array (dest, dest_idx, source_addr, length);\n\t\t} else {\n\t\t\tdest_addr = mono_array_addr_with_size (dest, element_size, dest_idx);\n\t\t\tmemmove (dest_addr, source_addr, element_size * length);\n\t\t}\n\t} else {\n\t\tmono_array_memcpy_refs (dest, dest_idx, source, source_idx, length);\n\t}\n\n\treturn TRUE;\n}",
        "start_line": 713
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "mono/metadata/icall.c",
        "method_name": "ves_icall_System_Array_FastCopy",
        "raw_code": "static gboolean /* <=== ves_icall_System_Array_FastCopy */ \nves_icall_System_Array_FastCopy (MonoArray *source, int source_idx, MonoArray* dest, int dest_idx, int length)\n{\n\tint element_size;\n\tvoid * dest_addr;\n\tvoid * source_addr;\n\tMonoClass *src_class;\n\tMonoClass *dest_class;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (source->obj.vtable->klass->rank != dest->obj.vtable->klass->rank)\n\t\treturn FALSE;\n\n\tif (source->bounds || dest->bounds)\n\t\treturn FALSE;\n\n\t/* there's no integer overflow since mono_array_length returns an unsigned integer */\n\tif ((dest_idx + length > mono_array_length (dest)) ||\n\t\t(source_idx + length > mono_array_length (source)))\n\t\treturn FALSE;\n\n\tsrc_class = source->obj.vtable->klass->element_class;\n\tdest_class = dest->obj.vtable->klass->element_class;\n\n\t/*\n\t * Handle common cases.\n\t */\n\n\t/* Case1: object[] -> valuetype[] (ArrayList::ToArray) */\n\tif (src_class == mono_defaults.object_class && dest_class->valuetype) {\n\t\t// FIXME: This is racy\n\t\treturn FALSE;\n\t\t/*\n\t\t  int i;\n\t\tint has_refs = dest_class->has_references;\n\t\tfor (i = source_idx; i < source_idx + length; ++i) {\n\t\t\tMonoObject *elem = mono_array_get (source, MonoObject*, i);\n\t\t\tif (elem && !mono_object_isinst (elem, dest_class))\n\t\t\t\treturn FALSE;\n\t\t}\n\n\t\telement_size = mono_array_element_size (dest->obj.vtable->klass);\n\t\tmemset (mono_array_addr_with_size (dest, element_size, dest_idx), 0, element_size * length);\n\t\tfor (i = 0; i < length; ++i) {\n\t\t\tMonoObject *elem = mono_array_get (source, MonoObject*, source_idx + i);\n\t\t\tvoid *addr = mono_array_addr_with_size (dest, element_size, dest_idx + i);\n\t\t\tif (!elem)\n\t\t\t\tcontinue;\n\t\t\tif (has_refs)\n\t\t\t\tmono_value_copy (addr, (char *)elem + sizeof (MonoObject), dest_class);\n\t\t\telse\n\t\t\t\tmemcpy (addr, (char *)elem + sizeof (MonoObject), element_size);\n\t\t}\n\t\treturn TRUE;\n\t\t*/\n\t}\n\n\t/* Check if we're copying a char[] <==> (u)short[] */\n\tif (src_class != dest_class) {\n\t\tif (dest_class->valuetype || dest_class->enumtype || src_class->valuetype || src_class->enumtype)\n\t\t\treturn FALSE;\n\n\t\tif (mono_class_is_subclass_of (src_class, dest_class, FALSE))\n\t\t\t;\n\t\t/* Case2: object[] -> reftype[] (ArrayList::ToArray) */\n\t\telse if (mono_class_is_subclass_of (dest_class, src_class, FALSE)) {\n\t\t\t// FIXME: This is racy\n\t\t\treturn FALSE;\n\t\t\t/*\n\t\t\t  int i;\n\t\t\tfor (i = source_idx; i < source_idx + length; ++i) {\n\t\t\t\tMonoObject *elem = mono_array_get (source, MonoObject*, i);\n\t\t\t\tif (elem && !mono_object_isinst (elem, dest_class))\n\t\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\t*/\n\t\t} else\n\t\t\treturn FALSE;\n\t}\n\n\tif (dest_class->valuetype) {\n\t\telement_size = mono_array_element_size (source->obj.vtable->klass);\n\t\tsource_addr = mono_array_addr_with_size (source, element_size, source_idx);\n\t\tif (dest_class->has_references) {\n\t\t\tmono_value_copy_array (dest, dest_idx, source_addr, length);\n\t\t} else {\n\t\t\tdest_addr = mono_array_addr_with_size (dest, element_size, dest_idx);\n\t\t\tmemmove (dest_addr, source_addr, element_size * length);\n\t\t}\n\t} else {\n\t\tmono_array_memcpy_refs (dest, dest_idx, source, source_idx, length);\n\t}\n\n\treturn TRUE;\n}",
        "start_line": 713
      }
    ],
    "code_context": "Called Methods:\n- mono_array_addr_with_size: #define mono_array_addr_with_size(array,size,index) ( ((char*)(array)->vector) + (size) * (index) ) /* <=== mono/metadata/object.h:83:83:mono_array_addr_with_size:3 */ \n- mono_class_is_assignable_from: gboolean /* <=== mono_class_is_assignable_from */ \nmono_class_is_assignable_from (MonoClass *klass, MonoClass *oklass)\n{\n\tif (!klass->inited)\n\t\tmono_class_init (klass);\n\n\tif (!oklass->inited)\n\t\tmono_class_init (oklass);\n\n\tif ((klass->byval_arg.type == MONO_TYPE_VAR) || (klass->byval_arg.type == MONO_TYPE_MVAR))\n\t\treturn klass == oklass;\n\n\tif (MONO_CLASS_IS_INTERFACE (klass)) {\n\t\tif ((oklass->byval_arg.type == MONO_TYPE_VAR) || (oklass->byval_arg.type == MONO_TYPE_MVAR))\n\t\t\treturn FALSE;\n\n\t\t/* interface_offsets might not be set for dynamic classes */\n\t\tif (oklass->reflection_info && !oklass->interface_bitmap)\n\t\t\t/* \n\t\t\t * oklass might be a generic type parameter but they have \n\t\t\t * interface_offsets set.\n\t\t\t */\n \t\t\treturn mono_reflection_call_is_assignable_to (oklass, klass);\n\t\tif (!oklass->interface_bitmap)\n\t\t\t/* Happens with generic instances of not-yet created dynamic types */\n\t\t\treturn FALSE;\n\t\tif (MONO_CLASS_IMPLEMENTS_INTERFACE (oklass, klass->interface_id))\n\t\t\treturn TRUE;\n\n\t\tif (mono_class_has_variant_generic_params (klass)) {\n\t\t\tif (oklass->generic_class) {\n\t\t\t\tint i;\n\t\t\t\tgboolean match = FALSE;\n\t\t\t\tMonoClass *container_class1 = klass->generic_class->container_class;\n\t\t\t\tMonoClass *container_class2 = oklass->generic_class->container_class;\n\n\t\t\t\t/* \n\t\t\t\t * Check whenever the generic definition of oklass implements the \n\t\t\t\t * generic definition of klass. The IMPLEMENTS_INTERFACE stuff is not usable\n\t\t\t\t * here since the relevant tables are not set up.\n\t\t\t\t */\n\t\t\t\tfor (i = 0; i < container_class2->interface_offsets_count; ++i)\n\t\t\t\t\tif ((container_class2->interfaces_packed [i] == container_class1) || (container_class2->interfaces_packed [i]->generic_class && (container_class2->interfaces_packed [i]->generic_class->container_class == container_class1)))\n\t\t\t\t\t\tmatch = TRUE;\n\n\t\t\t\tif (match) {\n\t\t\t\t\tMonoGenericContainer *container;\n\n\t\t\t\t\tcontainer = klass->generic_class->container_class->generic_container;\n\n\t\t\t\t\tmatch = TRUE;\n\t\t\t\t\tfor (i = 0; i < container->type_argc; ++i) {\n\t\t\t\t\t\tMonoClass *param1_class = mono_class_from_mono_type (klass->generic_class->context.class_inst->type_argv [i]);\n\t\t\t\t\t\tMonoClass *param2_class = mono_class_from_mono_type (oklass->generic_class->context.class_inst->type_argv [i]);\n\n\t\t\t\t\t\tif (param1_class->valuetype != param2_class->valuetype) {\n\t\t\t\t\t\t\tmatch = FALSE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * The _VARIANT and _COVARIANT constants should read _COVARIANT and\n\t\t\t\t\t\t * _CONTRAVARIANT, but they are in a public header so we can't fix it.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (param1_class != param2_class) {\n\t\t\t\t\t\t\tif ((mono_generic_container_get_param_info (container, i)->flags & MONO_GEN_PARAM_VARIANT) && mono_class_is_assignable_from (param1_class, param2_class))\n\t\t\t\t\t\t\t\t;\n\t\t\t\t\t\t\telse if (((mono_generic_container_get_param_info (container, i)->flags & MONO_GEN_PARAM_COVARIANT) && mono_class_is_assignable_from (param2_class, param1_class)))\n\t\t\t\t\t\t\t\t;\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tmatch = FALSE;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (match)\n\t\t\t\t\t\treturn TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (klass->rank) {\n\t\tMonoClass *eclass, *eoclass;\n\n\t\tif (oklass->rank != klass->rank)\n\t\t\treturn FALSE;\n\n\t\t/* vectors vs. one dimensional arrays */\n\t\tif (oklass->byval_arg.type != klass->byval_arg.type)\n\t\t\treturn FALSE;\n\n\t\teclass = klass->cast_class;\n\t\teoclass = oklass->cast_class;\n\n\t\t/* \n\t\t * a is b does not imply a[] is b[] when a is a valuetype, and\n\t\t * b is a reference type.\n\t\t */\n\n\t\tif (eoclass->valuetype) {\n\t\t\tif ((eclass == mono_defaults.enum_class) || \n\t\t\t\t(eclass == mono_defaults.enum_class->parent) ||\n\t\t\t\t(eclass == mono_defaults.object_class))\n\t\t\t\treturn FALSE;\n\t\t}\n\n\t\treturn mono_class_is_assignable_from (klass->cast_class, oklass->cast_class);\n\t} else if (mono_class_is_nullable (klass)) {\n\t\tif (mono_class_is_nullable (oklass))\n\t\t\treturn mono_class_is_assignable_from (klass->cast_class, oklass->cast_class);\n\t\telse\n\t\t\treturn mono_class_is_assignable_from (klass->cast_class, oklass);\n\t} else if (klass == mono_defaults.object_class)\n\t\treturn TRUE;\n\n\treturn mono_class_has_parent (oklass, klass);\n}\t\n- mono_array_memcpy_refs: #define mono_array_memcpy_refs(dest,destidx,src,srcidx,count)\t\\ /* <=== mono/metadata/object.h:96:101:mono_array_memcpy_refs:5 */ \n\tdo {\t\\\n\t\tgpointer *__p = (gpointer *) mono_array_addr ((dest), gpointer, (destidx));\t\\\n\t\tmono_gc_wbarrier_arrayref_copy ((dest), __p, (count));\t\\\n\t\tmemmove (__p, mono_array_addr ((src), gpointer, (srcidx)), (count) * sizeof (gpointer));\t\\\n\t} while (0)\n- mono_object_isinst_mbyref: MonoObject * /* <=== mono_object_isinst_mbyref */ \nmono_object_isinst_mbyref (MonoObject *obj, MonoClass *klass)\n{\n\tMonoVTable *vt;\n\n\tif (!obj)\n\t\treturn NULL;\n\n\tvt = obj->vtable;\n\t\n\tif (klass->flags & TYPE_ATTRIBUTE_INTERFACE) {\n\t\tif (MONO_VTABLE_IMPLEMENTS_INTERFACE (vt, klass->interface_id)) {\n\t\t\treturn obj;\n\t\t}\n\t} else {\n\t\tMonoClass *oklass = vt->klass;\n\t\tif ((oklass == mono_defaults.transparent_proxy_class))\n\t\t\toklass = ((MonoTransparentProxy *)obj)->remote_class->proxy_class;\n\t\n\t\tif ((oklass->idepth >= klass->idepth) && (oklass->supertypes [klass->idepth - 1] == klass))\n\t\t\treturn obj;\n\t}\n\n\tif (vt->klass == mono_defaults.transparent_proxy_class && ((MonoTransparentProxy *)obj)->custom_type_info) \n\t{\n\t\tMonoDomain *domain = mono_domain_get ();\n\t\tMonoObject *res;\n\t\tMonoObject *rp = (MonoObject *)((MonoTransparentProxy *)obj)->rp;\n\t\tMonoClass *rpklass = mono_defaults.iremotingtypeinfo_class;\n\t\tMonoMethod *im = NULL;\n\t\tgpointer pa [2];\n\n\t\tim = mono_class_get_method_from_name (rpklass, \"CanCastTo\", -1);\n\t\tim = mono_object_get_virtual_method (rp, im);\n\t\tg_assert (im);\n\t\n\t\tpa [0] = mono_type_get_object (domain, &klass->byval_arg);\n\t\tpa [1] = obj;\n\n\t\tres = mono_runtime_invoke (im, rp, pa, NULL);\n\t\n\t\tif (*(MonoBoolean *) mono_object_unbox(res)) {\n\t\t\t/* Update the vtable of the remote type, so it can safely cast to this new type */\n\t\t\tmono_upgrade_remote_class (domain, obj, klass);\n\t\t\treturn obj;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n- mono_object_class: #define mono_object_class(obj) (((MonoObject*)(obj))->vtable->klass) /* <=== mono/metadata/object.h:68:68:mono_object_class:1 */ \n- mono_gc_wbarrier_arrayref_copy: void mono_gc_wbarrier_arrayref_copy (MonoArray *arr, gpointer slot_ptr, int count); /* <=== mono_gc_wbarrier_arrayref_copy */ \n- mono_array_element_size: gint32 /* <=== mono_array_element_size */ \nmono_array_element_size (MonoClass *ac)\n{\n\tg_assert (ac->rank);\n\treturn ac->sizes.element_size;\n}\n- TYPE_ATTRIBUTE_INTERFACE: #define TYPE_ATTRIBUTE_INTERFACE             0x00000020 /* <=== mono/metadata/tabledefs.h:121:121:TYPE_ATTRIBUTE_INTERFACE:0 */ \n- mono_class_init: gboolean /* <=== mono_class_init */ \nmono_class_init (MonoClass *class)\n{\n\tint i;\n\tMonoCachedClassInfo cached_info;\n\tgboolean has_cached_info;\n\t\n\tg_assert (class);\n\n\t/* Double-checking locking pattern */\n\tif (class->inited)\n\t\treturn class->exception_type == MONO_EXCEPTION_NONE;\n\n\t/*g_print (\"Init class %s\\n\", class->name);*/\n\n\t/* We do everything inside the lock to prevent races */\n\tmono_loader_lock ();\n\n\tif (class->inited) {\n\t\tmono_loader_unlock ();\n\t\t/* Somebody might have gotten in before us */\n\t\treturn class->exception_type == MONO_EXCEPTION_NONE;\n\t}\n\n\tif (class->init_pending) {\n\t\tmono_loader_unlock ();\n\t\t/* this indicates a cyclic dependency */\n\t\tg_error (\"pending init %s.%s\\n\", class->name_space, class->name);\n\t}\n\n\tclass->init_pending = 1;\n\n\tif (mono_verifier_is_enabled_for_class (class) && !mono_verifier_verify_class (class)) {\n\t\tmono_class_set_failure (class, MONO_EXCEPTION_TYPE_LOAD, concat_two_strings_with_zero (class->image, class->name, class->image->assembly_name));\n\t\tgoto leave;\n\t}\n\n\n\tif (class->byval_arg.type == MONO_TYPE_ARRAY || class->byval_arg.type == MONO_TYPE_SZARRAY) {\n\t\tMonoClass *element_class = class->element_class;\n\t\tif (!element_class->inited) \n\t\t\tmono_class_init (element_class);\n\t\tif (element_class->exception_type != MONO_EXCEPTION_NONE) {\n\t\t\tmono_class_set_failure (class, MONO_EXCEPTION_TYPE_LOAD, NULL);\n\t\t\tgoto leave;\n\t\t}\n\t}\n\n\t/* CAS - SecurityAction.InheritanceDemand */\n\tif (mono_is_security_manager_active () && class->parent && (class->parent->flags & TYPE_ATTRIBUTE_HAS_SECURITY)) {\n\t\tmono_secman_inheritancedemand_class (class, class->parent);\n\t}\n\n\tif (mono_security_get_mode () == MONO_SECURITY_MODE_CORE_CLR)\n\t\tmono_security_core_clr_check_inheritance (class);\n\n\tmono_stats.initialized_class_count++;\n\n\tif (class->generic_class && !class->generic_class->is_dynamic) {\n\t\tMonoClass *gklass = class->generic_class->container_class;\n\n\t\tmono_stats.generic_class_count++;\n\n\t\tclass->method = gklass->method;\n\t\tclass->field = gklass->field;\n\n\t\tmono_class_init (gklass);\n\t\t// FIXME: Why is this needed ?\n\t\tif (!gklass->exception_type)\n\t\t\tmono_class_setup_methods (gklass);\n\t\tif (gklass->exception_type) {\n\t\t\tmono_class_set_failure (class, MONO_EXCEPTION_TYPE_LOAD, g_strdup_printf (\"Generic Type Defintion failed to init\"));\n\t\t\tgoto leave;\n\t\t}\n\n\t\tif (MONO_CLASS_IS_INTERFACE (class))\n\t\t\tclass->interface_id = mono_get_unique_iid (class);\n\t}\n\n\tif (class->parent && !class->parent->inited)\n\t\tmono_class_init (class->parent);\n\n\thas_cached_info = mono_class_get_cached_class_info (class, &cached_info);\n\n\tif (class->generic_class || class->image->dynamic || !class->type_token || (has_cached_info && !cached_info.has_nested_classes))\n\t\tclass->nested_classes_inited = TRUE;\n\n\t/*\n\t * Computes the size used by the fields, and their locations\n\t */\n\tif (has_cached_info) {\n\t\tclass->instance_size = cached_info.instance_size;\n\t\tclass->sizes.class_size = cached_info.class_size;\n\t\tclass->packing_size = cached_info.packing_size;\n\t\tclass->min_align = cached_info.min_align;\n\t\tclass->blittable = cached_info.blittable;\n\t\tclass->has_references = cached_info.has_references;\n\t\tclass->has_static_refs = cached_info.has_static_refs;\n\t\tclass->no_special_static_fields = cached_info.no_special_static_fields;\n\t}\n\telse\n\t\tif (!class->size_inited){\n\t\t\tmono_class_setup_fields (class);\n\t\t\tif (class->exception_type || mono_loader_get_last_error ())\n\t\t\t\tgoto leave;\n\t\t}\n\t\t\t\t\n\t/* Initialize arrays */\n\tif (class->rank) {\n\t\tclass->method.count = 3 + (class->rank > 1? 2: 1);\n\n\t\tif (class->interface_count) {\n\t\t\tint count_generic = generic_array_methods (class);\n\t\t\tclass->method.count += class->interface_count * count_generic;\n\t\t}\n\t}\n\n\tmono_class_setup_supertypes (class);\n\n\tif (!default_ghc)\n\t\tinitialize_object_slots (class);\n\n\t/* \n\t * Initialize the rest of the data without creating a generic vtable if possible.\n\t * If possible, also compute vtable_size, so mono_class_create_runtime_vtable () can\n\t * also avoid computing a generic vtable.\n\t */\n\tif (has_cached_info) {\n\t\t/* AOT case */\n\t\tclass->vtable_size = cached_info.vtable_size;\n\t\tclass->has_finalize = cached_info.has_finalize;\n\t\tclass->ghcimpl = cached_info.ghcimpl;\n\t\tclass->has_cctor = cached_info.has_cctor;\n\t} else if (class->rank == 1 && class->byval_arg.type == MONO_TYPE_SZARRAY) {\n\t\tstatic int szarray_vtable_size = 0;\n\n\t\t/* SZARRAY case */\n\t\tif (!szarray_vtable_size) {\n\t\t\tmono_class_setup_vtable (class);\n\t\t\tszarray_vtable_size = class->vtable_size;\n\t\t} else {\n\t\t\tclass->vtable_size = szarray_vtable_size;\n\t\t}\n\t} else if (class->generic_class && !MONO_CLASS_IS_INTERFACE (class)) {\n\t\tMonoClass *gklass = class->generic_class->container_class;\n\n\t\t/* Generic instance case */\n\t\tclass->ghcimpl = gklass->ghcimpl;\n\t\tclass->has_finalize = gklass->has_finalize;\n\t\tclass->has_cctor = gklass->has_cctor;\n\n\t\tmono_class_setup_vtable (gklass);\n\t\tif (gklass->exception_type) {\n\t\t\tmono_class_set_failure (class, MONO_EXCEPTION_TYPE_LOAD, NULL);\n\t\t\tgoto leave;\n\t\t}\n\n\t\tclass->vtable_size = gklass->vtable_size;\n\t} else {\n\t\t/* General case */\n\n\t\t/* ghcimpl is not currently used\n\t\tclass->ghcimpl = 1;\n\t\tif (class->parent) { \n\t\t\tMonoMethod *cmethod = class->vtable [ghc_slot];\n\t\t\tif (cmethod->is_inflated)\n\t\t\t\tcmethod = ((MonoMethodInflated*)cmethod)->declaring;\n\t\t\tif (cmethod == default_ghc) {\n\t\t\t\tclass->ghcimpl = 0;\n\t\t\t}\n\t\t}\n\t\t*/\n\n\t\t/* Interfaces and valuetypes are not supposed to have finalizers */\n\t\tif (!(MONO_CLASS_IS_INTERFACE (class) || class->valuetype)) {\n\t\t\tMonoMethod *cmethod = NULL;\n\n\t\t\tif (class->parent && class->parent->has_finalize) {\n\t\t\t\tclass->has_finalize = 1;\n\t\t\t} else {\n\t\t\t\tif (class->type_token) {\n\t\t\t\t\tcmethod = find_method_in_metadata (class, \"Finalize\", 0, METHOD_ATTRIBUTE_VIRTUAL);\n\t\t\t\t} else if (class->parent) {\n\t\t\t\t\t/* FIXME: Optimize this */\n\t\t\t\t\tmono_class_setup_vtable (class);\n\t\t\t\t\tif (class->exception_type || mono_loader_get_last_error ())\n\t\t\t\t\t\tgoto leave;\n\t\t\t\t\tcmethod = class->vtable [finalize_slot];\n\t\t\t\t}\n\n\t\t\t\tif (cmethod) {\n\t\t\t\t\t/* Check that this is really the finalizer method */\n\t\t\t\t\tmono_class_setup_vtable (class);\n\t\t\t\t\tif (class->exception_type || mono_loader_get_last_error ())\n\t\t\t\t\t\tgoto leave;\n\n\t\t\t\t\tg_assert (class->vtable_size > finalize_slot);\n\n\t\t\t\t\tclass->has_finalize = 0;\n\t\t\t\t\tif (class->parent) { \n\t\t\t\t\t\tcmethod = class->vtable [finalize_slot];\n\t\t\t\t\t\tg_assert (cmethod);\n\t\t\t\t\t\tif (cmethod->is_inflated)\n\t\t\t\t\t\t\tcmethod = ((MonoMethodInflated*)cmethod)->declaring;\n\t\t\t\t\t\tif (cmethod != default_finalize) {\n\t\t\t\t\t\t\tclass->has_finalize = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* C# doesn't allow interfaces to have cctors */\n\t\tif (!MONO_CLASS_IS_INTERFACE (class) || class->image != mono_defaults.corlib) {\n\t\t\tMonoMethod *cmethod = NULL;\n\n\t\t\tif (class->type_token) {\n\t\t\t\tcmethod = find_method_in_metadata (class, \".cctor\", 0, METHOD_ATTRIBUTE_SPECIAL_NAME);\n\t\t\t\t/* The find_method function ignores the 'flags' argument */\n\t\t\t\tif (cmethod && (cmethod->flags & METHOD_ATTRIBUTE_SPECIAL_NAME))\n\t\t\t\t\tclass->has_cctor = 1;\n\t\t\t} else {\n\t\t\t\tmono_class_setup_methods (class);\n\t\t\t\tif (class->exception_type)\n\t\t\t\t\tgoto leave;\n\n\t\t\t\tfor (i = 0; i < class->method.count; ++i) {\n\t\t\t\t\tMonoMethod *method = class->methods [i];\n\t\t\t\t\tif ((method->flags & METHOD_ATTRIBUTE_SPECIAL_NAME) && \n\t\t\t\t\t\t(strcmp (\".cctor\", method->name) == 0)) {\n\t\t\t\t\t\tclass->has_cctor = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!mono_setup_vtable_in_class_init) {\n\t\t/*\n\t\t * This is an embedding API break, since the caller might assume that \n\t\t * mono_class_init () constructs a generic vtable, so vtable construction errors\n\t\t * are visible right after the mono_class_init (), and not after \n\t\t * mono_class_vtable ().\n\t\t */\n\t\tif (class->parent) {\n\t\t\t/* This will compute class->parent->vtable_size for some classes */\n\t\t\tmono_class_init (class->parent);\n\t\t\tif (class->parent->exception_type) {\n\t\t\t\tmono_class_set_failure (class, MONO_EXCEPTION_TYPE_LOAD, NULL);\n\t\t\t\tgoto leave;\n\t\t\t}\n\t\t\tif (mono_loader_get_last_error ())\n\t\t\t\tgoto leave;\n\t\t\tif (!class->parent->vtable_size) {\n\t\t\t\t/* FIXME: Get rid of this somehow */\n\t\t\t\tmono_class_setup_vtable (class->parent);\n\t\t\t\tif (class->parent->exception_type) {\n\t\t\t\t\tmono_class_set_failure (class, MONO_EXCEPTION_TYPE_LOAD, NULL);\n\t\t\t\t\tgoto leave;\n\t\t\t\t}\n\t\t\t\tif (mono_loader_get_last_error ())\n\t\t\t\t\tgoto leave;\n\t\t\t}\n\t\t\tsetup_interface_offsets (class, class->parent->vtable_size);\n\t\t} else {\n\t\t\tsetup_interface_offsets (class, 0);\n\t\t}\n\t} else {\n\t\tmono_class_setup_vtable (class);\n\n\t\tif (MONO_CLASS_IS_INTERFACE (class))\n\t\t\tsetup_interface_offsets (class, 0);\n\t}\n\n\tif (class->generic_class && !mono_verifier_class_is_valid_generic_instantiation (class))\n\t\tmono_class_set_failure (class, MONO_EXCEPTION_TYPE_LOAD, g_strdup (\"Invalid generic instantiation\"));\n\n\tgoto leave;\n\n leave:\n\t/* Because of the double-checking locking pattern */\n\tmono_memory_barrier ();\n\tclass->inited = 1;\n\tclass->init_pending = 0;\n\n\tif (mono_loader_get_last_error ()) {\n\t\tif (class->exception_type == MONO_EXCEPTION_NONE) {\n\t\t\tset_failure_from_loader_error (class, mono_loader_get_last_error ());\n\t\t}\n\t\tmono_loader_clear_error ();\n\t}\n\n\tmono_loader_unlock ();\n\n\tif (mono_debugger_class_init_func)\n\t\tmono_debugger_class_init_func (class);\n\n\treturn class->exception_type == MONO_EXCEPTION_NONE;\n}\n- mono_gc_wbarrier_value_copy: void mono_gc_wbarrier_value_copy    (gpointer dest, gpointer src, int count, MonoClass *klass); /* <=== mono_gc_wbarrier_value_copy */ \n- mono_array_get: #define mono_array_get(array,type,index) ( *(type*)mono_array_addr ((array), type, (index)) )  /* <=== mono/metadata/object.h:84:84:mono_array_get:3 */ \n- mono_class_is_subclass_of: gboolean /* <=== mono_class_is_subclass_of */ \nmono_class_is_subclass_of (MonoClass *klass, MonoClass *klassc, \n\t\t\t   gboolean check_interfaces)\n{\n\tg_assert (klassc->idepth > 0);\n\tif (check_interfaces && MONO_CLASS_IS_INTERFACE (klassc) && !MONO_CLASS_IS_INTERFACE (klass)) {\n\t\tif (MONO_CLASS_IMPLEMENTS_INTERFACE (klass, klassc->interface_id))\n\t\t\treturn TRUE;\n\t} else if (check_interfaces && MONO_CLASS_IS_INTERFACE (klassc) && MONO_CLASS_IS_INTERFACE (klass)) {\n\t\tint i;\n\n\t\tfor (i = 0; i < klass->interface_count; i ++) {\n\t\t\tMonoClass *ic =  klass->interfaces [i];\n\t\t\tif (ic == klassc)\n\t\t\t\treturn TRUE;\n\t\t}\n\t} else {\n\t\tif (!MONO_CLASS_IS_INTERFACE (klass) && mono_class_has_parent (klass, klassc))\n\t\t\treturn TRUE;\n\t}\n\n\t/* \n\t * MS.NET thinks interfaces are a subclass of Object, so we think it as\n\t * well.\n\t */\n\tif (klassc == mono_defaults.object_class)\n\t\treturn TRUE;\n\n\treturn FALSE;\n}\n- mono_object_isinst: MonoObject * /* <=== mono_object_isinst */ \nmono_object_isinst (MonoObject *obj, MonoClass *klass)\n{\n\tif (!klass->inited)\n\t\tmono_class_init (klass);\n\n\tif (klass->marshalbyref || klass->flags & TYPE_ATTRIBUTE_INTERFACE) \n\t\treturn mono_object_isinst_mbyref (obj, klass);\n\n\tif (!obj)\n\t\treturn NULL;\n\n\treturn mono_class_is_assignable_from (klass, obj->vtable->klass) ? obj : NULL;\n}\n- mono_value_copy_array: void /* <=== mono_value_copy_array */ \nmono_value_copy_array (MonoArray *dest, int dest_idx, gpointer src, int count)\n{\n\tint size = mono_array_element_size (dest->obj.vtable->klass);\n\tchar *d = mono_array_addr_with_size (dest, size, dest_idx);\n\tmono_gc_wbarrier_value_copy (d, src, count, mono_object_class (dest)->element_class);\n\tmemmove (d, src, size * count);\n}\n- mono_array_length: #define mono_array_length(array) ((array)->max_length) /* <=== mono/metadata/object.h:81:81:mono_array_length:1 */ \n\nType Definitions:\n- MonoArray: typedef struct {\n\tMonoObject obj;\n\t/* bounds is NULL for szarrays */\n\tMonoArrayBounds *bounds;\n\t/* total number of elements of the array */\n\tmono_array_size_t max_length; \n\t/* we use double to ensure proper alignment on platforms that need it */\n\tdouble vector [MONO_ZERO_LEN_ARRAY];\n}\n- MonoObject: typedef struct {\n\tMonoVTable *vtable;\n\tMonoThreadsSync *synchronisation;\n}\n- gpointer: typedef void *         gpointer;\n- MonoClass: typedef struct _MonoClass MonoClass;\n\nImports:\n- #include <alloca.h>\n- #include <mono/metadata/monitor.h>\n- #include <mono/metadata/debug-helpers.h>\n- #include <mono/metadata/environment.h>\n- #include <mono/utils/mono-proclib.h>\n- #include <mono/utils/monobitset.h>\n- #include \"mono/utils/mono-membar.h\"\n- #include <mono/metadata/socket-io.h>\n- #include <mono/metadata/tabledefs.h>\n- #include <ctype.h>\n- #include <mono/utils/strtod.h>\n- #include <shlobj.h>\n- #include <mono/metadata/process.h>\n- #include <mono/metadata/mono-debug.h>\n- #include <mono/metadata/sysmath.h>\n- #include <mono/metadata/filewatcher.h>\n- #include <mono/metadata/verify-internals.h>\n- #include <config.h>\n- #include <glib.h>\n- #include <sys/time.h>\n- #include <mono/metadata/class-internals.h>\n- #include <mono/metadata/gc-internal.h>\n- #include <mono/metadata/threads-types.h>\n- #include <mono/utils/mono-error-internals.h>\n- #include <mono/metadata/domain-internals.h>\n- #include <mono/utils/mono-string.h>\n- #include <windows.h>\n- #include <mono/metadata/locales.h>\n- #include <mono/metadata/number-formatter.h>\n- #include <mono/metadata/security-core-clr.h>\n- #include <mono/metadata/security.h>\n- #include <stdarg.h>\n- #include <mono/metadata/char-conversions.h>\n- #include <mono/io-layer/io-layer.h>\n- #include <unistd.h>\n- #include <mono/metadata/profiler-private.h>\n- #include <mono/metadata/assembly.h>\n- #include \"decimal.h\"\n- #include \"metadata/icall-def.h\"\n- #include <mono/metadata/mono-gc.h>\n- #include <mono/utils/mono-time.h>\n- #include <mono/metadata/marshal.h>\n- #include <mono/metadata/mono-endian.h>\n- #include <mono/metadata/metadata-internals.h>\n- #include <mono/metadata/object.h>\n- #include <mono/metadata/mono-config.h>\n- #include <string.h>\n- #include <mono/metadata/threads.h>\n- #include <mono/metadata/security-manager.h>\n- #include <mono/metadata/mono-perfcounters.h>\n- #include <mono/metadata/threadpool.h>\n- #include <mono/metadata/exception.h>\n- #include <mono/metadata/tokentype.h>\n- #include <mono/metadata/reflection.h>\n- #include <mono/metadata/file-io.h>\n- #include <stdlib.h>\n- #include <mono/metadata/rand.h>\n- #include <mono/metadata/cil-coff.h>\n- #include <mono/metadata/string-icalls.h>\n- #include <mono/metadata/console-io.h>",
    "commit_msg": "Disable some of the FastCopy fast paths since they are racy.",
    "cve_desc": "[{'lang': 'en', 'value': 'Race condition in the FastCopy optimization in the Array.Copy method in metadata/icall.c in Mono, when Moonlight 2.x before 2.4.1 or 3.x before 3.99.3 is used, allows remote attackers to trigger a buffer overflow and modify internal data structures, and cause a denial of service (plugin crash) or corrupt the internal state of the security manager, via a crafted media file in which a thread makes a change after a type check but before a copy action.'}]",
    "year": 2011,
    "filename": "icall.c",
    "commit_url": "\"https://github.com/mono/mono/commit/2f00e4bbb2137130845afb1b2a1e678552fc8e5c\""
  },
  {
    "repository": "vrtadmin/clamav-devel",
    "cve_id": "CVE-2011-1003",
    "cwe_list": [
      "CWE-399"
    ],
    "commit_hash": "d21fb8d975f8c9688894a8cef4d50d977022e09f",
    "short_hash": "d21fb8d9",
    "vulnerableMethods_before": [
      {
        "filename": "libclamav/vba_extract.c",
        "method_name": "vba_read_project_strings",
        "raw_code": "static int /* <=== vba_read_project_strings */ \nvba_read_project_strings(int fd, int big_endian)\n{\n\tunsigned char *buf = NULL;\n\tuint16_t buflen = 0;\n\tint ret = 0;\n\n\tfor(;;) {\n\t\toff_t offset;\n\t\tuint16_t length;\n\t\tchar *name;\n\n\t\tif(!read_uint16(fd, &length, big_endian))\n\t\t\tbreak;\n\n\t\tif (length < 6) {\n\t\t\tlseek(fd, -2, SEEK_CUR);\n\t\t\tbreak;\n\t\t}\n\t\tif(length > buflen) {\n\t\t\tunsigned char *newbuf = (unsigned char *)cli_realloc(buf, length);\n\t\t\tif(newbuf == NULL) {\n\t\t\t\tif(buf)\n\t\t\t\t\tfree(buf);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbuflen = length;\n\t\t\tbuf = newbuf;\n\t\t}\n\n\t\toffset = lseek(fd, 0, SEEK_CUR);\n\n\t\tif(cli_readn(fd, buf, length) != (int)length) {\n\t\t\tcli_dbgmsg(\"read name failed - rewinding\\n\");\n\t\t\tlseek(fd, offset, SEEK_SET);\n\t\t\tbreak;\n\t\t}\n\t\tname = get_unicode_name((const char *)buf, length, big_endian);\n\t\tcli_dbgmsg(\"length: %d, name: %s\\n\", length, (name) ? name : \"[null]\");\n\n\t\tif((name == NULL) || (memcmp(\"*\\\\\", name, 2) != 0) ||\n\t\t   (strchr(\"ghcd\", name[2]) == NULL)) {\n\t\t\t/* Not a string */\n\t\t\tlseek(fd, -(length+2), SEEK_CUR);\n\t\t\tif(name)\n\t\t\t\tfree(name);\n\t\t\tbreak;\n\t\t}\n\t\tfree(name);\n\n\t\tif(!read_uint16(fd, &length, big_endian)) {\n\t\t\tif(buf)\n\t\t\t\tfree(buf);\n\t\t\tbreak;\n\t\t}\n\n\t\tret++;\n\n\t\tif ((length != 0) && (length != 65535)) {\n\t\t\tlseek(fd, -2, SEEK_CUR);\n\t\t\tcontinue;\n\t\t}\n\t\toffset = lseek(fd, 10, SEEK_CUR);\n\t\tcli_dbgmsg(\"offset: %lu\\n\", (unsigned long)offset);\n\t\tvba56_test_middle(fd);\n\t}\n\tif(buf)\n\t\tfree(buf);\n\treturn ret;\n}",
        "start_line": 173
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "libclamav/vba_extract.c",
        "method_name": "vba_read_project_strings",
        "raw_code": "static int /* <=== vba_read_project_strings */ \nvba_read_project_strings(int fd, int big_endian)\n{\n\tunsigned char *buf = NULL;\n\tuint16_t buflen = 0;\n\tint ret = 0;\n\n\tfor(;;) {\n\t\toff_t offset;\n\t\tuint16_t length;\n\t\tchar *name;\n\n\t\tif(!read_uint16(fd, &length, big_endian))\n\t\t\tbreak;\n\n\t\tif (length < 6) {\n\t\t\tlseek(fd, -2, SEEK_CUR);\n\t\t\tbreak;\n\t\t}\n\t\tif(length > buflen) {\n\t\t\tunsigned char *newbuf = (unsigned char *)cli_realloc(buf, length);\n\t\t\tif(newbuf == NULL) {\n\t\t\t\tif(buf)\n\t\t\t\t\tfree(buf);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbuflen = length;\n\t\t\tbuf = newbuf;\n\t\t}\n\n\t\toffset = lseek(fd, 0, SEEK_CUR);\n\n\t\tif(cli_readn(fd, buf, length) != (int)length) {\n\t\t\tcli_dbgmsg(\"read name failed - rewinding\\n\");\n\t\t\tlseek(fd, offset, SEEK_SET);\n\t\t\tbreak;\n\t\t}\n\t\tname = get_unicode_name((const char *)buf, length, big_endian);\n\t\tcli_dbgmsg(\"length: %d, name: %s\\n\", length, (name) ? name : \"[null]\");\n\n\t\tif((name == NULL) || (memcmp(\"*\\\\\", name, 2) != 0) ||\n\t\t   (strchr(\"ghcd\", name[2]) == NULL)) {\n\t\t\t/* Not a string */\n\t\t\tlseek(fd, -(length+2), SEEK_CUR);\n\t\t\tif(name)\n\t\t\t\tfree(name);\n\t\t\tbreak;\n\t\t}\n\t\tfree(name);\n\n\t\tif(!read_uint16(fd, &length, big_endian)) {\n\t\t\tif(buf) {\n\t\t\t\tfree(buf);\n\t\t\t\tbuf = NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tret++;\n\n\t\tif ((length != 0) && (length != 65535)) {\n\t\t\tlseek(fd, -2, SEEK_CUR);\n\t\t\tcontinue;\n\t\t}\n\t\toffset = lseek(fd, 10, SEEK_CUR);\n\t\tcli_dbgmsg(\"offset: %lu\\n\", (unsigned long)offset);\n\t\tvba56_test_middle(fd);\n\t}\n\tif(buf)\n\t\tfree(buf);\n\treturn ret;\n}",
        "start_line": 173
      }
    ],
    "code_context": "Called Methods:\n- cli_errmsg: void cli_errmsg(const char *str, ...) /* <=== cli_errmsg */ \n{\n    MSGCODE(buff, len, \"LibClamAV Error: \");\n    msg_callback(CL_MSG_ERROR, buff, buff+len, cli_getctx());\n}\n- get_unicode_name: static char *get_unicode_name (char *name, int size) /* <=== get_unicode_name */ \n{\n    int i, j;\n    char *newname;\n\n    if (*name == 0 || size <= 0) {\n\treturn NULL;\n    }\n\n    newname = (char *) malloc (size * 2);\n    if (!newname) {\n\treturn NULL;\n    }\n    j = 0;\n    for (i = 0; i < size; i = i + 2) {\n\tif (isprint (name[i])) {\n\t    newname[j++] = name[i];\n\t} else {\n\t    if (name[i] < 10 && name[i] >= 0) {\n\t\tnewname[j++] = '_';\n\t\tnewname[j++] = name[i] + '0';\n\t    }\n\t    newname[j++] = '_';\n\t}\n    }\n    newname[j] = '\\0';\n    return newname;\n}\n- vba_endian_convert_16: static uint16_t /* <=== vba_endian_convert_16 */ \nvba_endian_convert_16(uint16_t value, int big_endian)\n{\n\tif (big_endian)\n\t\treturn (uint16_t)be16_to_host(value);\n\telse\n\t\treturn le16_to_host(value);\n}\n- cli_dbgmsg_internal: void cli_dbgmsg_internal(const char *str, ...) /* <=== cli_dbgmsg_internal */ \n{\n    MSGCODE(buff, len, \"LibClamAV debug: \");\n    fputs(buff, stderr);\n}\n- CLI_MAX_ALLOCATION: #define CLI_MAX_ALLOCATION (182*1024*1024) /* <=== libclamav/others.h:79:79:CLI_MAX_ALLOCATION:0 */ \n- cli_realloc: void *cli_realloc(void *ptr, size_t size) /* <=== cli_realloc */ \n{\n\tvoid *alloc;\n\n\n    if(!size || size > CLI_MAX_ALLOCATION) {\n\tcli_errmsg(\"cli_realloc(): Attempt to allocate %lu bytes. Please report to http://bugs.clamav.net\\n\", (unsigned long int) size);\n\treturn NULL;\n    }\n\n    alloc = realloc(ptr, size);\n\n    if(!alloc) {\n\tcli_errmsg(\"cli_realloc(): Can't re-allocate memory to %lu bytes.\\n\", (unsigned long int) size);\n\tperror(\"realloc_problem\");\n\treturn NULL;\n    } else return alloc;\n}\n- cli_dbgmsg: #define cli_dbgmsg (!UNLIKELY(cli_debug_flag)) ? (void)0 : cli_dbgmsg_internal /* <=== libclamav/others.h:474:474:cli_dbgmsg:0 */ \n- cli_strerror: const char* cli_strerror(int errnum, char *buf, size_t len) /* <=== cli_strerror */ \n{\n    char *err;\n# ifdef CL_THREAD_SAFE\n    pthread_mutex_lock(&cli_strerror_mutex);\n#endif\n    err = strerror(errnum);\n    strncpy(buf, err, len);\n# ifdef CL_THREAD_SAFE\n    pthread_mutex_unlock(&cli_strerror_mutex);\n#endif\n    return buf;\n}\n- cli_malloc: void *cli_malloc(size_t size) /* <=== cli_malloc */ \n{\n\tvoid *alloc;\n\n\n    if(!size || size > CLI_MAX_ALLOCATION) {\n\tcli_errmsg(\"cli_malloc(): Attempt to allocate %lu bytes. Please report to http://bugs.clamav.net\\n\", (unsigned long int) size);\n\treturn NULL;\n    }\n\n    alloc = malloc(size);\n\n    if(!alloc) {\n\tcli_errmsg(\"cli_malloc(): Can't allocate memory (%lu bytes).\\n\", (unsigned long int) size);\n\tperror(\"malloc_problem\");\n\treturn NULL;\n    } else return alloc;\n}\n- get_unicode_name: static char * /* <=== get_unicode_name */ \nget_unicode_name(const char *name, int size, int big_endian)\n{\n\tint i, increment;\n\tchar *newname, *ret;\n\n\tif((name == NULL) || (*name == '\\0') || (size <= 0))\n\t\treturn NULL;\n\n\tnewname = (char *)cli_malloc(size * 7 + 1);\n\tif(newname == NULL)\n\t\treturn NULL;\n\n\tif((!big_endian) && (size & 0x1)) {\n\t\tcli_dbgmsg(\"get_unicode_name: odd number of bytes %d\\n\", size);\n\t\t--size;\n\t}\n\n\tincrement = (big_endian) ? 1 : 2;\n\tret = newname;\n\n\tfor(i = 0; i < size; i += increment) {\n\t\tif((!(name[i]&0x80)) && isprint(name[i])) {\n\t\t        *ret++ = tolower(name[i]);\n\t\t} else {\n\t\t\tif((name[i] < 10) && (name[i] >= 0)) {\n\t\t\t\t*ret++ = '_';\n\t\t\t\t*ret++ = (char)(name[i] + '0');\n\t\t\t} else {\n\t\t\t\tconst uint16_t x = (uint16_t)((name[i] << 8) | name[i + 1]);\n\n\t\t\t\t*ret++ = '_';\n\t\t\t\t*ret++ = (char)('a'+((x&0xF)));\n\t\t\t\t*ret++ = (char)('a'+((x>>4)&0xF));\n\t\t\t\t*ret++ = (char)('a'+((x>>8)&0xF));\n\t\t\t\t*ret++ = 'a';\n\t\t\t\t*ret++ = 'a';\n\t\t\t}\n\t\t\t*ret++ = '_';\n\t\t}\n\t}\n\n\t*ret = '\\0';\n\n\t/* Saves a lot of memory */\n\tret = cli_realloc(newname, (ret - newname) + 1);\n\treturn ret ? ret : newname;\n}\n- read_uint16: static int /* <=== read_uint16 */ \nread_uint16(int fd, uint16_t *u, int big_endian)\n{\n\tif(cli_readn(fd, u, sizeof(uint16_t)) != sizeof(uint16_t))\n\t\treturn FALSE;\n\n\t*u = vba_endian_convert_16(*u, big_endian);\n\n\treturn TRUE;\n}\n- cli_readn: int cli_readn(int fd, void *buff, unsigned int count) /* <=== cli_readn */ \n{\n        int retval;\n        unsigned int todo;\n        unsigned char *current;\n\n\n        todo = count;\n        current = (unsigned char *) buff;\n\n        do {\n                retval = read(fd, current, todo);\n                if (retval == 0) {\n                        return (count - todo);\n                }\n                if (retval < 0) {\n\t\t\tchar err[128];\n\t\t\tif (errno == EINTR) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcli_errmsg(\"cli_readn: read error: %s\\n\", cli_strerror(errno, err, sizeof(err)));\n                        return -1;\n                }\n                todo -= retval;\n                current += retval;\n        } while (todo > 0);\n\n\n        return count;\n}\n\nType Definitions:\n- ANY: typedef struct {\n\n   struct {\n       void (*finish_pass)(j_decompress_ptr);\n       void (*color_quantize)(j_decompress_ptr, JSAMPARRAY, JSAMPARRAY, int);\n       void (*start_pass)(j_decompress_ptr, bool);\n       void (*new_color_map)(j_decompress_ptr);\n   } pub;\n\n  /* Space for the eventually created colormap is stashed here */\n  JSAMPARRAY sv_colormap;   /* colormap allocated at init time */\n  int desired;          /* desired # of colors = size of colormap */\n\n  /* Variables for accumulating image statistics */\n  hist3d histogram;     /* pointer to the histogram */\n\n  bool needs_zeroed;        /* true if next pass must zero histogram */\n\n  /* Variables for Floyd-Steinberg dithering */\n  FSERRPTR fserrors;        /* accumulated errors */\n  bool on_odd_row;      /* flag to remember which row we are on */\n  int * error_limiter;      /* table for clamping the applied error */\n}\n- ANY: typedef struct {\n\tMD5_u32plus lo, hi;\n\tMD5_u32plus a, b, c, d;\n\tunsigned char buffer[64];\n\tMD5_u32plus block[16];\n}\n\nImports:\n- #include <fcntl.h>\n- #include \"vba_extract.h\"\n- #include <stdio.h>\n- #include <stdlib.h>\n- #include \"scanners.h\"\n- #include \"clamav-config.h\"\n- #include <string.h>\n- #include \"mbox.h\"\n- #include \"blob.h\"\n- #include \"others.h\"\n- #include <unistd.h>\n- #include \"clamav.h\"\n- #include <zlib.h>\n- #include <ctype.h>",
    "commit_msg": "libclamav/vba_extract.c: fix error path double free (bb#2486)",
    "cve_desc": "Double free vulnerability in the vba_read_project_strings function in vba_extract.c in libclamav in ClamAV before 0.97 might allow remote attackers to execute arbitrary code via crafted Visual Basic for Applications (VBA) data in a Microsoft Office document.  NOTE: some of these details are obtained from third party information.",
    "year": 2011,
    "filename": "vba_extract.c",
    "commit_url": "\"https://github.com/vrtadmin/clamav-devel/commit/d21fb8d975f8c9688894a8cef4d50d977022e09f\""
  },
  {
    "repository": "torvalds/linux",
    "cve_id": "CVE-2011-1079",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "43629f8f5ea32a998d06d1bb41eefa0e821ff573",
    "short_hash": "43629f8f",
    "vulnerableMethods_before": [
      {
        "filename": "net/bluetooth/bnep/sock.c",
        "method_name": "bnep_sock_ioctl",
        "raw_code": "static int bnep_sock_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg) /* <=== bnep_sock_ioctl */ \n{\n\tstruct bnep_connlist_req cl;\n\tstruct bnep_connadd_req  ca;\n\tstruct bnep_conndel_req  cd;\n\tstruct bnep_conninfo ci;\n\tstruct socket *nsock;\n\tvoid __user *argp = (void __user *)arg;\n\tint err;\n\n\tBT_DBG(\"cmd %x arg %lx\", cmd, arg);\n\n\tswitch (cmd) {\n\tcase BNEPCONNADD:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EACCES;\n\n\t\tif (copy_from_user(&ca, argp, sizeof(ca)))\n\t\t\treturn -EFAULT;\n\n\t\tnsock = sockfd_lookup(ca.sock, &err);\n\t\tif (!nsock)\n\t\t\treturn err;\n\n\t\tif (nsock->sk->sk_state != BT_CONNECTED) {\n\t\t\tsockfd_put(nsock);\n\t\t\treturn -EBADFD;\n\t\t}\n\n\t\terr = bnep_add_connection(&ca, nsock);\n\t\tif (!err) {\n\t\t\tif (copy_to_user(argp, &ca, sizeof(ca)))\n\t\t\t\terr = -EFAULT;\n\t\t} else\n\t\t\tsockfd_put(nsock);\n\n\t\treturn err;\n\n\tcase BNEPCONNDEL:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EACCES;\n\n\t\tif (copy_from_user(&cd, argp, sizeof(cd)))\n\t\t\treturn -EFAULT;\n\n\t\treturn bnep_del_connection(&cd);\n\n\tcase BNEPGETCONNLIST:\n\t\tif (copy_from_user(&cl, argp, sizeof(cl)))\n\t\t\treturn -EFAULT;\n\n\t\tif (cl.cnum <= 0)\n\t\t\treturn -EINVAL;\n\n\t\terr = bnep_get_connlist(&cl);\n\t\tif (!err && copy_to_user(argp, &cl, sizeof(cl)))\n\t\t\treturn -EFAULT;\n\n\t\treturn err;\n\n\tcase BNEPGETCONNINFO:\n\t\tif (copy_from_user(&ci, argp, sizeof(ci)))\n\t\t\treturn -EFAULT;\n\n\t\terr = bnep_get_conninfo(&ci);\n\t\tif (!err && copy_to_user(argp, &ci, sizeof(ci)))\n\t\t\treturn -EFAULT;\n\n\t\treturn err;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
        "start_line": 63
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "net/bluetooth/bnep/sock.c",
        "method_name": "bnep_sock_ioctl",
        "raw_code": "static int bnep_sock_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg) /* <=== bnep_sock_ioctl */ \n{\n\tstruct bnep_connlist_req cl;\n\tstruct bnep_connadd_req  ca;\n\tstruct bnep_conndel_req  cd;\n\tstruct bnep_conninfo ci;\n\tstruct socket *nsock;\n\tvoid __user *argp = (void __user *)arg;\n\tint err;\n\n\tBT_DBG(\"cmd %x arg %lx\", cmd, arg);\n\n\tswitch (cmd) {\n\tcase BNEPCONNADD:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EACCES;\n\n\t\tif (copy_from_user(&ca, argp, sizeof(ca)))\n\t\t\treturn -EFAULT;\n\n\t\tnsock = sockfd_lookup(ca.sock, &err);\n\t\tif (!nsock)\n\t\t\treturn err;\n\n\t\tif (nsock->sk->sk_state != BT_CONNECTED) {\n\t\t\tsockfd_put(nsock);\n\t\t\treturn -EBADFD;\n\t\t}\n\t\tca.device[sizeof(ca.device)-1] = 0;\n\n\t\terr = bnep_add_connection(&ca, nsock);\n\t\tif (!err) {\n\t\t\tif (copy_to_user(argp, &ca, sizeof(ca)))\n\t\t\t\terr = -EFAULT;\n\t\t} else\n\t\t\tsockfd_put(nsock);\n\n\t\treturn err;\n\n\tcase BNEPCONNDEL:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EACCES;\n\n\t\tif (copy_from_user(&cd, argp, sizeof(cd)))\n\t\t\treturn -EFAULT;\n\n\t\treturn bnep_del_connection(&cd);\n\n\tcase BNEPGETCONNLIST:\n\t\tif (copy_from_user(&cl, argp, sizeof(cl)))\n\t\t\treturn -EFAULT;\n\n\t\tif (cl.cnum <= 0)\n\t\t\treturn -EINVAL;\n\n\t\terr = bnep_get_connlist(&cl);\n\t\tif (!err && copy_to_user(argp, &cl, sizeof(cl)))\n\t\t\treturn -EFAULT;\n\n\t\treturn err;\n\n\tcase BNEPGETCONNINFO:\n\t\tif (copy_from_user(&ci, argp, sizeof(ci)))\n\t\t\treturn -EFAULT;\n\n\t\terr = bnep_get_conninfo(&ci);\n\t\tif (!err && copy_to_user(argp, &ci, sizeof(ci)))\n\t\t\treturn -EFAULT;\n\n\t\treturn err;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
        "start_line": 63
      }
    ],
    "code_context": "Called Methods:\n- __copy_tofrom_user: extern int __copy_tofrom_user(void *to, const void *from, unsigned long len); /* <=== __copy_tofrom_user */ \n- copy_from_user: static inline unsigned long /* <=== copy_from_user */ \ncopy_from_user(void *to, const void *from, unsigned long len)\n{\n\tunsigned long over;\n\n\tif (access_ok(VERIFY_READ, from, len))\n\t\treturn __copy_tofrom_user(to, from, len);\n\n\tif ((unsigned long)from < TASK_SIZE) {\n\t\tover = (unsigned long)from + len - TASK_SIZE;\n\t\treturn __copy_tofrom_user(to, from, len - over) + over;\n\t}\n\treturn len;\n}\n- access_ok: #define access_ok(type, addr, size)\t\t\t\t\\ /* <=== arch/score/include/asm/uaccess.h:56:57:access_ok:3 */ \n\tlikely(__access_ok((unsigned long)(addr), (size)))\n\nType Definitions:\n- socket: struct socket\n- bnep_connadd_req: struct bnep_connadd_req {\n\tint   sock;       // Connected socket\n\t__u32 flags;\n\t__u16 role;\n\tchar  device[16]; // Name of the Ethernet device\n}\n\nImports:\n- #include <linux/file.h>\n- #include <linux/compat.h>\n- #include <asm/uaccess.h>\n- #include <linux/errno.h>\n- #include <linux/skbuff.h>\n- #include \"bnep.h\"\n- #include <linux/fcntl.h>\n- #include <linux/module.h>\n- #include <linux/kernel.h>\n- #include <linux/poll.h>\n- #include <linux/socket.h>\n- #include <linux/ioctl.h>\n- #include <asm/system.h>\n- #include <linux/gfp.h>\n- #include <linux/types.h>\n- #include <linux/capability.h>\n- #include <net/sock.h>\n- #include <linux/init.h>",
    "commit_msg": "Bluetooth: bnep: fix buffer overflow\n\nStruct ca is copied from userspace.  It is not checked whether the \"device\"\nfield is NULL terminated.  This potentially leads to BUG() inside of\nalloc_netdev_mqs() and/or information leak by creating a device with a name\nmade of contents of kernel stack.\n\nSigned-off-by: Vasiliy Kulikov <segoon@openwall.com>\nSigned-off-by: Gustavo F. Padovan <padovan@profusion.mobi>",
    "cve_desc": "[{'lang': 'en', 'value': \"The bnep_sock_ioctl function in net/bluetooth/bnep/sock.c in the Linux kernel before 2.6.39 does not ensure that a certain device field ends with a '\\\\0' character, which allows local users to obtain potentially sensitive information from kernel stack memory, or cause a denial of service (BUG and system crash), via a BNEPCONNADD command.\"}]",
    "year": 2011,
    "filename": "sock.c",
    "commit_url": "\"https://github.com/torvalds/linux/commit/43629f8f5ea32a998d06d1bb41eefa0e821ff573\""
  },
  {
    "repository": "torvalds/linux",
    "cve_id": "CVE-2011-1160",
    "cwe_list": [
      "CWE-200"
    ],
    "commit_hash": "1309d7afbed112f0e8e90be9af975550caa0076b",
    "short_hash": "1309d7af",
    "vulnerableMethods_before": [
      {
        "filename": "drivers/char/tpm/tpm.c",
        "method_name": "tpm_open",
        "raw_code": "int tpm_open(struct inode *inode, struct file *file) /* <=== tpm_open */ \n{\n\tint minor = iminor(inode);\n\tstruct tpm_chip *chip = NULL, *pos;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pos, &tpm_chip_list, list) {\n\t\tif (pos->vendor.miscdev.minor == minor) {\n\t\t\tchip = pos;\n\t\t\tget_device(chip->dev);\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (!chip)\n\t\treturn -ENODEV;\n\n\tif (test_and_set_bit(0, &chip->is_open)) {\n\t\tdev_dbg(chip->dev, \"Another process owns this TPM\\n\");\n\t\tput_device(chip->dev);\n\t\treturn -EBUSY;\n\t}\n\n\tchip->data_buffer = kmalloc(TPM_BUFSIZE * sizeof(u8), GFP_KERNEL);\n\tif (chip->data_buffer == NULL) {\n\t\tclear_bit(0, &chip->is_open);\n\t\tput_device(chip->dev);\n\t\treturn -ENOMEM;\n\t}\n\n\tatomic_set(&chip->data_pending, 0);\n\n\tfile->private_data = chip;\n\treturn 0;\n}",
        "start_line": 959
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "drivers/char/tpm/tpm.c",
        "method_name": "tpm_open",
        "raw_code": "int tpm_open(struct inode *inode, struct file *file) /* <=== tpm_open */ \n{\n\tint minor = iminor(inode);\n\tstruct tpm_chip *chip = NULL, *pos;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pos, &tpm_chip_list, list) {\n\t\tif (pos->vendor.miscdev.minor == minor) {\n\t\t\tchip = pos;\n\t\t\tget_device(chip->dev);\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (!chip)\n\t\treturn -ENODEV;\n\n\tif (test_and_set_bit(0, &chip->is_open)) {\n\t\tdev_dbg(chip->dev, \"Another process owns this TPM\\n\");\n\t\tput_device(chip->dev);\n\t\treturn -EBUSY;\n\t}\n\n\tchip->data_buffer = kzalloc(TPM_BUFSIZE, GFP_KERNEL);\n\tif (chip->data_buffer == NULL) {\n\t\tclear_bit(0, &chip->is_open);\n\t\tput_device(chip->dev);\n\t\treturn -ENOMEM;\n\t}\n\n\tatomic_set(&chip->data_pending, 0);\n\n\tfile->private_data = chip;\n\treturn 0;\n}",
        "start_line": 959
      }
    ],
    "code_context": "Called Methods:\n- test_and_set_bit: static __inline__ int test_and_set_bit(int nr, volatile unsigned long * addr) /* <=== test_and_set_bit */ \n{\n\tunsigned long mask = 1UL << CHOP_SHIFTCOUNT(nr);\n\tunsigned long old;\n\tunsigned long flags;\n\tint set;\n\n\taddr += (nr >> SHIFT_PER_LONG);\n\t_atomic_spin_lock_irqsave(addr, flags);\n\told = *addr;\n\tset = (old & mask) ? 1 : 0;\n\tif (!set)\n\t\t*addr = old | mask;\n\t_atomic_spin_unlock_irqrestore(addr, flags);\n\n\treturn set;\n}\n- test_and_set_bit: static __inline__ int test_and_set_bit(int nr, volatile void * addr) /* <=== test_and_set_bit */ \n{\n\t__u32 mask, oldbit;\n\tvolatile __u32 *a = addr;\n\tunsigned long flags;\n\tunsigned long tmp;\n\n\ta += (nr >> 5);\n\tmask = (1 << (nr & 0x1F));\n\n\tlocal_irq_save(flags);\n\t__asm__ __volatile__ (\n\t\tDCACHE_CLEAR(\"%0\", \"%1\", \"%2\")\n\t\tM32R_LOCK\" %0, @%2;\t\t\\n\\t\"\n\t\t\"mv\t%1, %0;\t\t\t\\n\\t\"\n\t\t\"and\t%0, %3;\t\t\t\\n\\t\"\n\t\t\"or\t%1, %3;\t\t\t\\n\\t\"\n\t\tM32R_UNLOCK\" %1, @%2;\t\t\\n\\t\"\n\t\t: \"=&r\" (oldbit), \"=&r\" (tmp)\n\t\t: \"r\" (a), \"r\" (mask)\n\t\t: \"memory\"\n\t);\n\tlocal_irq_restore(flags);\n\n\treturn (oldbit != 0);\n}\n- atomic_set: static inline void atomic_set(atomic_t *v, int i) /* <=== atomic_set */ \n{\n\tasm volatile(\n\t\t\"\tst\t%1,%0\\n\"\n\t\t: \"=Q\" (v->counter) : \"d\" (i));\n}\n- test_and_set_bit: static inline int test_and_set_bit(int nr, volatile unsigned long *addr) /* <=== test_and_set_bit */ \n{\n\tunsigned long mask = BIT_MASK(nr);\n\tunsigned long *p = ((unsigned long *)addr) + BIT_WORD(nr);\n\tunsigned long old;\n\tunsigned long flags;\n\n\t_atomic_spin_lock_irqsave(p, flags);\n\told = *p;\n\t*p = old | mask;\n\t_atomic_spin_unlock_irqrestore(p, flags);\n\n\treturn (old & mask) != 0;\n}\n- _atomic_spin_lock_irqsave: #  define _atomic_spin_lock_irqsave(l,f) do { local_irq_save(f); } while (0) /* <=== include/asm-generic/bitops/atomic.h:36:36:_atomic_spin_lock_irqsave:2 */ \n- atomic_set: static __inline__ void atomic_set(atomic_t *v, int i)  /* <=== atomic_set */ \n{\n\tunsigned long flags;\n\t_atomic_spin_lock_irqsave(v, flags);\n\n\tv->counter = i;\n\n\t_atomic_spin_unlock_irqrestore(v, flags);\n}\n- _atomic_andn: unsigned long _atomic_andn(volatile unsigned long *p, unsigned long mask); /* <=== _atomic_andn */ \n- CHOP_SHIFTCOUNT: #define CHOP_SHIFTCOUNT(x) (((unsigned long) (x)) & (BITS_PER_LONG - 1)) /* <=== arch/parisc/include/asm/bitops.h:19:19:CHOP_SHIFTCOUNT:1 */ \n- clear_bit: static inline void clear_bit(unsigned long nr, volatile unsigned long *addr) /* <=== clear_bit */ \n{\n\tunsigned long *m = ((unsigned long *) addr) + (nr >> SZLONG_LOG);\n\tunsigned short bit = nr & SZLONG_MASK;\n\tunsigned long temp;\n\n\tif (kernel_uses_llsc && R10000_LLSC_WAR) {\n\t\t__asm__ __volatile__(\n\t\t\"\t.set\tmips3\t\t\t\t\t\\n\"\n\t\t\"1:\t\" __LL \"%0, %1\t\t\t# clear_bit\t\\n\"\n\t\t\"\tand\t%0, %2\t\t\t\t\t\\n\"\n\t\t\"\t\" __SC \"%0, %1\t\t\t\t\t\\n\"\n\t\t\"\tbeqzl\t%0, 1b\t\t\t\t\t\\n\"\n\t\t\"\t.set\tmips0\t\t\t\t\t\\n\"\n\t\t: \"=&r\" (temp), \"+m\" (*m)\n\t\t: \"ir\" (~(1UL << bit)));\n#ifdef CONFIG_CPU_MIPSR2\n\t} else if (kernel_uses_llsc && __builtin_constant_p(bit)) {\n\t\tdo {\n\t\t\t__asm__ __volatile__(\n\t\t\t\"\t\" __LL \"%0, %1\t\t# clear_bit\t\\n\"\n\t\t\t\"\t\" __INS \"%0, $0, %2, 1\t\t\t\\n\"\n\t\t\t\"\t\" __SC \"%0, %1\t\t\t\t\\n\"\n\t\t\t: \"=&r\" (temp), \"+m\" (*m)\n\t\t\t: \"ir\" (bit));\n\t\t} while (unlikely(!temp));\n#endif /* CONFIG_CPU_MIPSR2 */\n\t} else if (kernel_uses_llsc) {\n\t\tdo {\n\t\t\t__asm__ __volatile__(\n\t\t\t\"\t.set\tmips3\t\t\t\t\\n\"\n\t\t\t\"\t\" __LL \"%0, %1\t\t# clear_bit\t\\n\"\n\t\t\t\"\tand\t%0, %2\t\t\t\t\\n\"\n\t\t\t\"\t\" __SC \"%0, %1\t\t\t\t\\n\"\n\t\t\t\"\t.set\tmips0\t\t\t\t\\n\"\n\t\t\t: \"=&r\" (temp), \"+m\" (*m)\n\t\t\t: \"ir\" (~(1UL << bit)));\n\t\t} while (unlikely(!temp));\n\t} else {\n\t\tvolatile unsigned long *a = addr;\n\t\tunsigned long mask;\n\t\tunsigned long flags;\n\n\t\ta += nr >> SZLONG_LOG;\n\t\tmask = 1UL << bit;\n\t\traw_local_irq_save(flags);\n\t\t*a &= ~mask;\n\t\traw_local_irq_restore(flags);\n\t}\n}\n- clear_bit: static __inline__ void /* <=== clear_bit */ \nclear_bit (int nr, volatile void *addr)\n{\n\t__u32 mask, old, new;\n\tvolatile __u32 *m;\n\tCMPXCHG_BUGCHECK_DECL\n\n\tm = (volatile __u32 *) addr + (nr >> 5);\n\tmask = ~(1 << (nr & 31));\n\tdo {\n\t\tCMPXCHG_BUGCHECK(m);\n\t\told = *m;\n\t\tnew = old & mask;\n\t} while (cmpxchg_acq(m, old, new) != old);\n}\n- test_and_set_bit: static inline int test_and_set_bit(int nr, volatile unsigned long *addr) /* <=== test_and_set_bit */ \n{\n\tint oldbit;\n\n\tasm volatile(LOCK_PREFIX \"bts %2,%1\\n\\t\"\n\t\t     \"sbb %0,%0\" : \"=r\" (oldbit), ADDR : \"Ir\" (nr) : \"memory\");\n\n\treturn oldbit;\n}\n- atomic_set: static inline void atomic_set(atomic_t *v, int i) /* <=== atomic_set */ \n{\n\tv->counter = i;\n}\n- _atomic_spin_unlock_irqrestore: #  define _atomic_spin_unlock_irqrestore(l,f) do { local_irq_restore(f); } while (0) /* <=== arch/parisc/include/asm/atomic.h:49:49:_atomic_spin_unlock_irqrestore:2 */ \n- _atomic_spin_unlock_irqrestore: #  define _atomic_spin_unlock_irqrestore(l,f) do { local_irq_restore(f); } while (0) /* <=== include/asm-generic/bitops/atomic.h:37:37:_atomic_spin_unlock_irqrestore:2 */ \n- clear_bit: static inline void clear_bit(unsigned nr, volatile unsigned long *addr) /* <=== clear_bit */ \n{\n\t_atomic_andn(addr + BIT_WORD(nr), BIT_MASK(nr));\n}\n- _atomic_spin_lock_irqsave: #  define _atomic_spin_lock_irqsave(l,f) do { local_irq_save(f); } while (0) /* <=== arch/parisc/include/asm/atomic.h:48:48:_atomic_spin_lock_irqsave:2 */ \n- spin_unlock_irqrestore: static inline void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags) /* <=== spin_unlock_irqrestore */ \n{\n\traw_spin_unlock_irqrestore(&lock->rlock, flags);\n}\n- kmalloc: static inline void *kmalloc(size_t s, gfp_t gfp) /* <=== kmalloc */ \n{\n\treturn malloc(s);\n}\n- put_device: void put_device(struct device *dev) /* <=== put_device */ \n{\n\t/* might_sleep(); */\n\tif (dev)\n\t\tkobject_put(&dev->kobj);\n}\n- _atomic_or: unsigned long _atomic_or(volatile unsigned long *p, unsigned long mask); /* <=== _atomic_or */ \n- clear_bit: static __inline__ void clear_bit(int nr, volatile unsigned long * addr) /* <=== clear_bit */ \n{\n\tunsigned long mask = ~(1UL << CHOP_SHIFTCOUNT(nr));\n\tunsigned long flags;\n\n\taddr += (nr >> SHIFT_PER_LONG);\n\t_atomic_spin_lock_irqsave(addr, flags);\n\t*addr &= mask;\n\t_atomic_spin_unlock_irqrestore(addr, flags);\n}\n- test_and_set_bit: static inline int test_and_set_bit(unsigned long nr, /* <=== test_and_set_bit */ \n\tvolatile unsigned long *addr)\n{\n\tunsigned short bit = nr & SZLONG_MASK;\n\tunsigned long res;\n\n\tsmp_mb__before_llsc();\n\n\tif (kernel_uses_llsc && R10000_LLSC_WAR) {\n\t\tunsigned long *m = ((unsigned long *) addr) + (nr >> SZLONG_LOG);\n\t\tunsigned long temp;\n\n\t\t__asm__ __volatile__(\n\t\t\"\t.set\tmips3\t\t\t\t\t\\n\"\n\t\t\"1:\t\" __LL \"%0, %1\t\t# test_and_set_bit\t\\n\"\n\t\t\"\tor\t%2, %0, %3\t\t\t\t\\n\"\n\t\t\"\t\" __SC\t\"%2, %1\t\t\t\t\t\\n\"\n\t\t\"\tbeqzl\t%2, 1b\t\t\t\t\t\\n\"\n\t\t\"\tand\t%2, %0, %3\t\t\t\t\\n\"\n\t\t\"\t.set\tmips0\t\t\t\t\t\\n\"\n\t\t: \"=&r\" (temp), \"+m\" (*m), \"=&r\" (res)\n\t\t: \"r\" (1UL << bit)\n\t\t: \"memory\");\n\t} else if (kernel_uses_llsc) {\n\t\tunsigned long *m = ((unsigned long *) addr) + (nr >> SZLONG_LOG);\n\t\tunsigned long temp;\n\n\t\tdo {\n\t\t\t__asm__ __volatile__(\n\t\t\t\"\t.set\tmips3\t\t\t\t\\n\"\n\t\t\t\"\t\" __LL \"%0, %1\t# test_and_set_bit\t\\n\"\n\t\t\t\"\tor\t%2, %0, %3\t\t\t\\n\"\n\t\t\t\"\t\" __SC\t\"%2, %1\t\t\t\t\\n\"\n\t\t\t\"\t.set\tmips0\t\t\t\t\\n\"\n\t\t\t: \"=&r\" (temp), \"+m\" (*m), \"=&r\" (res)\n\t\t\t: \"r\" (1UL << bit)\n\t\t\t: \"memory\");\n\t\t} while (unlikely(!res));\n\n\t\tres = temp & (1UL << bit);\n\t} else {\n\t\tvolatile unsigned long *a = addr;\n\t\tunsigned long mask;\n\t\tunsigned long flags;\n\n\t\ta += nr >> SZLONG_LOG;\n\t\tmask = 1UL << bit;\n\t\traw_local_irq_save(flags);\n\t\tres = (mask & *a);\n\t\t*a |= mask;\n\t\traw_local_irq_restore(flags);\n\t}\n\n\tsmp_llsc_mb();\n\n\treturn res != 0;\n}\n- clear_bit: static __inline__ void clear_bit(int nr, volatile void * addr) /* <=== clear_bit */ \n{\n\t__u32 mask;\n\tvolatile __u32 *a = addr;\n\tunsigned long flags;\n\tunsigned long tmp;\n\n\ta += (nr >> 5);\n\tmask = (1 << (nr & 0x1F));\n\n\tlocal_irq_save(flags);\n\n\t__asm__ __volatile__ (\n\t\tDCACHE_CLEAR(\"%0\", \"r6\", \"%1\")\n\t\tM32R_LOCK\" %0, @%1;\t\t\\n\\t\"\n\t\t\"and\t%0, %2;\t\t\t\\n\\t\"\n\t\tM32R_UNLOCK\" %0, @%1;\t\t\\n\\t\"\n\t\t: \"=&r\" (tmp)\n\t\t: \"r\" (a), \"r\" (~mask)\n\t\t: \"memory\"\n#ifdef CONFIG_CHIP_M32700_TS1\n\t\t, \"r6\"\n#endif\t/* CONFIG_CHIP_M32700_TS1 */\n\t);\n\tlocal_irq_restore(flags);\n}\n- clear_bit: static inline void clear_bit(int nr, volatile unsigned long *addr) /* <=== clear_bit */ \n{\n\tunsigned long mask = BIT_MASK(nr);\n\tunsigned long *p = ((unsigned long *)addr) + BIT_WORD(nr);\n\n\t*p &= ~mask;\n}\n- test_and_set_bit: static __inline__ int /* <=== test_and_set_bit */ \ntest_and_set_bit (int nr, volatile void *addr)\n{\n\t__u32 bit, old, new;\n\tvolatile __u32 *m;\n\tCMPXCHG_BUGCHECK_DECL\n\n\tm = (volatile __u32 *) addr + (nr >> 5);\n\tbit = 1 << (nr & 31);\n\tdo {\n\t\tCMPXCHG_BUGCHECK(m);\n\t\told = *m;\n\t\tnew = old | bit;\n\t} while (cmpxchg_acq(m, old, new) != old);\n\treturn (old & bit) != 0;\n}\n- kzalloc: static inline void *kzalloc(size_t size, gfp_t flags) /* <=== kzalloc */ \n{\n\treturn kmalloc(size, flags | __GFP_ZERO);\n}\n- test_and_set_bit: static inline int test_and_set_bit(unsigned nr, volatile unsigned long *addr) /* <=== test_and_set_bit */ \n{\n\tunsigned long mask = BIT_MASK(nr);\n\taddr += BIT_WORD(nr);\n\tsmp_mb();  /* barrier for proper semantics */\n\treturn (_atomic_or(addr, mask) & mask) != 0;\n}\n- test_and_set_bit: static inline int test_and_set_bit(int nr, volatile void * addr) /* <=== test_and_set_bit */ \n{\n\tunsigned long *p = ((unsigned long *)addr) + nr / BITS_PER_LONG;\n\tunsigned long mask = 1UL << (nr % BITS_PER_LONG);\n\tunsigned long tmp, old;\n\n\tif (__builtin_constant_p(nr)) {\n\t\tasm volatile(\n\t\t\t\"1:\tssrf\t5\\n\"\n\t\t\t\"\tld.w\t%0, %3\\n\"\n\t\t\t\"\tmov\t%2, %0\\n\"\n\t\t\t\"\tsbr\t%0, %4\\n\"\n\t\t\t\"\tstcond\t%1, %0\\n\"\n\t\t\t\"\tbrne\t1b\"\n\t\t\t: \"=&r\"(tmp), \"=o\"(*p), \"=&r\"(old)\n\t\t\t: \"m\"(*p), \"i\"(nr)\n\t\t\t: \"memory\", \"cc\");\n\t} else {\n\t\tasm volatile(\n\t\t\t\"1:\tssrf\t5\\n\"\n\t\t\t\"\tld.w\t%2, %3\\n\"\n\t\t\t\"\tor\t%0, %2, %4\\n\"\n\t\t\t\"\tstcond\t%1, %0\\n\"\n\t\t\t\"\tbrne\t1b\"\n\t\t\t: \"=&r\"(tmp), \"=o\"(*p), \"=&r\"(old)\n\t\t\t: \"m\"(*p), \"r\"(mask)\n\t\t\t: \"memory\", \"cc\");\n\t}\n\n\treturn (old & mask) != 0;\n}\n- kmalloc: static inline void *kmalloc(size_t s, gfp_t gfp) /* <=== kmalloc */ \n{\n\treturn malloc(s);\n}\n- ATOMIC_HASH: #define ATOMIC_HASH(a)\t\t(&dummy) /* <=== arch/sparc/lib/atomic32.c:26:26:ATOMIC_HASH:1 */ \n- BIT_WORD: #define BIT_WORD(nr)\t\t((nr) / BITS_PER_LONG) /* <=== tools/virtio/linux/virtio.h:130:130:BIT_WORD:1 */ \n- clear_bit: static inline void clear_bit(int nr, volatile unsigned long *addr) /* <=== clear_bit */ \n{\n\tunsigned long mask = BIT_MASK(nr);\n\tunsigned long *p = ((unsigned long *)addr) + BIT_WORD(nr);\n\tunsigned long flags;\n\n\t_atomic_spin_lock_irqsave(p, flags);\n\t*p &= ~mask;\n\t_atomic_spin_unlock_irqrestore(p, flags);\n}\n- clear_bit: static inline void clear_bit(int nr, volatile void * addr) /* <=== clear_bit */ \n{\n\tunsigned long *p = ((unsigned long *)addr) + nr / BITS_PER_LONG;\n\tunsigned long tmp;\n\n\tif (__builtin_constant_p(nr)) {\n\t\tasm volatile(\n\t\t\t\"1:\tssrf\t5\\n\"\n\t\t\t\"\tld.w\t%0, %2\\n\"\n\t\t\t\"\tcbr\t%0, %3\\n\"\n\t\t\t\"\tstcond\t%1, %0\\n\"\n\t\t\t\"\tbrne\t1b\"\n\t\t\t: \"=&r\"(tmp), \"=o\"(*p)\n\t\t\t: \"m\"(*p), \"i\"(nr)\n\t\t\t: \"cc\");\n\t} else {\n\t\tunsigned long mask = 1UL << (nr % BITS_PER_LONG);\n\t\tasm volatile(\n\t\t\t\"1:\tssrf\t5\\n\"\n\t\t\t\"\tld.w\t%0, %2\\n\"\n\t\t\t\"\tandn\t%0, %3\\n\"\n\t\t\t\"\tstcond\t%1, %0\\n\"\n\t\t\t\"\tbrne\t1b\"\n\t\t\t: \"=&r\"(tmp), \"=o\"(*p)\n\t\t\t: \"m\"(*p), \"r\"(mask)\n\t\t\t: \"cc\");\n\t}\n}\n- BIT_MASK: #define BIT_MASK(nr)\t\t(1UL << ((nr) % BITS_PER_LONG)) /* <=== tools/virtio/linux/virtio.h:133:133:BIT_MASK:1 */ \n- atomic_set: void atomic_set(atomic_t *v, int i) /* <=== atomic_set */ \n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(ATOMIC_HASH(v), flags);\n\tv->counter = i;\n\tspin_unlock_irqrestore(ATOMIC_HASH(v), flags);\n}\n\nType Definitions:\n- tpm_chip: struct tpm_chip {\n\tstruct device *dev;\t/* Device stuff */\n\n\tint dev_num;\t\t/* /dev/tpm# */\n\tunsigned long is_open;\t/* only one allowed */\n\tint time_expired;\n\n\t/* Data passed to and from the tpm via the read/write calls */\n\tu8 *data_buffer;\n\tatomic_t data_pending;\n\tstruct mutex buffer_mutex;\n\n\tstruct timer_list user_read_timer;\t/* user needs to claim result */\n\tstruct work_struct work;\n\tstruct mutex tpm_mutex;\t/* tpm is processing */\n\n\tstruct tpm_vendor_specific vendor;\n\n\tstruct dentry **bios_dir;\n\n\tstruct list_head list;\n\tvoid (*release) (struct device *);\n}\n- tpm_chip: struct tpm_chip\n\nImports:\n- #include <linux/poll.h>\n- #include \"tpm.h\"\n- #include <linux/spinlock.h>\n- #include <linux/slab.h>\n- #include <linux/mutex.h>",
    "commit_msg": "char/tpm: Fix unitialized usage of data buffer\n\nThis patch fixes information leakage to the userspace by initializing\nthe data buffer to zero.\n\nReported-by: Peter Huewe <huewe.external@infineon.com>\nSigned-off-by: Peter Huewe <huewe.external@infineon.com>\nSigned-off-by: Marcel Selhorst <m.selhorst@sirrix.com>\n[ Also removed the silly \"* sizeof(u8)\".  If that isn't 1, we have way\n  deeper problems than a simple multiplication can fix.   - Linus ]\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "cve_desc": "[{'lang': 'en', 'value': 'The tpm_open function in drivers/char/tpm/tpm.c in the Linux kernel before 2.6.39 does not initialize a certain buffer, which allows local users to obtain potentially sensitive information from kernel memory via unspecified vectors.'}]",
    "year": 2011,
    "filename": "tpm.c",
    "commit_url": "\"https://github.com/torvalds/linux/commit/1309d7afbed112f0e8e90be9af975550caa0076b\""
  },
  {
    "repository": "GNOME/gimp",
    "cve_id": "CVE-2011-1178",
    "cwe_list": [
      "CWE-190"
    ],
    "commit_hash": "a9671395f6573e90316a9d748588c5435216f6ce",
    "short_hash": "a9671395",
    "vulnerableMethods_before": [
      {
        "filename": "plug-ins/common/file-pcx.c",
        "method_name": "load_image",
        "raw_code": "static gint32 /* <=== load_image */ \nload_image (const gchar  *filename,\n            GError      **error)\n{\n  FILE         *fd;\n  GimpDrawable *drawable;\n  GimpPixelRgn  pixel_rgn;\n  guint16       offset_x, offset_y, bytesperline;\n  gint32        width, height;\n  gint32        image, layer;\n  guchar       *dest, cmap[768];\n  guint8        header_buf[128];\n\n  fd = g_fopen (filename, \"rb\");\n\n  if (! fd)\n    {\n      g_set_error (error, G_FILE_ERROR, g_file_error_from_errno (errno),\n                   _(\"Could not open '%s' for reading: %s\"),\n                   gimp_filename_to_utf8 (filename), g_strerror (errno));\n      return -1;\n    }\n\n  gimp_progress_init_printf (_(\"Opening '%s'\"),\n                             gimp_filename_to_utf8 (filename));\n\n  if (fread (header_buf, 128, 1, fd) == 0)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"Could not read header from '%s'\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  pcx_header_from_buffer (header_buf);\n\n  if (pcx_header.manufacturer != 10)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a PCX file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  offset_x     = GUINT16_FROM_LE (pcx_header.x1);\n  offset_y     = GUINT16_FROM_LE (pcx_header.y1);\n  width        = GUINT16_FROM_LE (pcx_header.x2) - offset_x + 1;\n  height       = GUINT16_FROM_LE (pcx_header.y2) - offset_y + 1;\n  bytesperline = GUINT16_FROM_LE (pcx_header.bytesperline);\n\n  if ((width < 0) || (width > GIMP_MAX_IMAGE_SIZE))\n    {\n      g_message (_(\"Unsupported or invalid image width: %d\"), width);\n      return -1;\n    }\n  if ((height < 0) || (height > GIMP_MAX_IMAGE_SIZE))\n    {\n      g_message (_(\"Unsupported or invalid image height: %d\"), height);\n      return -1;\n    }\n  if (bytesperline < (width * pcx_header.bpp) / 8)\n    {\n      g_message (_(\"Invalid number of bytes per line in PCX header\"));\n      return -1;\n    }\n\n  /* Shield against potential buffer overflows in load_*() functions. */\n  if (G_MAXSIZE / width / height < 3)\n    {\n      g_message (_(\"Image dimensions too large: width %d x height %d\"), width, height);\n      return -1;\n    }\n\n  if (pcx_header.planes == 3 && pcx_header.bpp == 8)\n    {\n      image= gimp_image_new (width, height, GIMP_RGB);\n      layer= gimp_layer_new (image, _(\"Background\"), width, height,\n                             GIMP_RGB_IMAGE, 100, GIMP_NORMAL_MODE);\n    }\n  else\n    {\n      image= gimp_image_new (width, height, GIMP_INDEXED);\n      layer= gimp_layer_new (image, _(\"Background\"), width, height,\n                             GIMP_INDEXED_IMAGE, 100, GIMP_NORMAL_MODE);\n    }\n  gimp_image_set_filename (image, filename);\n  gimp_image_add_layer (image, layer, 0);\n  gimp_layer_set_offsets (layer, offset_x, offset_y);\n  drawable = gimp_drawable_get (layer);\n\n  if (pcx_header.planes == 1 && pcx_header.bpp == 1)\n    {\n      dest = g_new (guchar, width * height);\n      load_1 (fd, width, height, dest, bytesperline);\n      gimp_image_set_colormap (image, mono, 2);\n    }\n  else if (pcx_header.planes == 4 && pcx_header.bpp == 1)\n    {\n      dest = g_new (guchar, width * height);\n      load_4 (fd, width, height, dest, bytesperline);\n      gimp_image_set_colormap (image, pcx_header.colormap, 16);\n    }\n  else if (pcx_header.planes == 1 && pcx_header.bpp == 8)\n    {\n      dest = g_new (guchar, width * height);\n      load_8 (fd, width, height, dest, bytesperline);\n      fseek (fd, -768L, SEEK_END);\n      fread (cmap, 768, 1, fd);\n      gimp_image_set_colormap (image, cmap, 256);\n    }\n  else if (pcx_header.planes == 3 && pcx_header.bpp == 8)\n    {\n      dest = g_new (guchar, width * height * 3);\n      load_24 (fd, width, height, dest, bytesperline);\n    }\n  else\n    {\n      g_message (_(\"Unusual PCX flavour, giving up\"));\n      return -1;\n    }\n\n  gimp_pixel_rgn_init (&pixel_rgn, drawable, 0, 0, width, height, TRUE, FALSE);\n  gimp_pixel_rgn_set_rect (&pixel_rgn, dest, 0, 0, width, height);\n\n  g_free (dest);\n\n  gimp_drawable_flush (drawable);\n  gimp_drawable_detach (drawable);\n\n  return image;\n}",
        "start_line": 342
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "plug-ins/common/file-pcx.c",
        "method_name": "load_image",
        "raw_code": "static gint32 /* <=== load_image */ \nload_image (const gchar  *filename,\n            GError      **error)\n{\n  FILE         *fd;\n  GimpDrawable *drawable;\n  GimpPixelRgn  pixel_rgn;\n  guint16       offset_x, offset_y, bytesperline;\n  gint32        width, height;\n  gint32        image, layer;\n  guchar       *dest, cmap[768];\n  guint8        header_buf[128];\n\n  fd = g_fopen (filename, \"rb\");\n\n  if (! fd)\n    {\n      g_set_error (error, G_FILE_ERROR, g_file_error_from_errno (errno),\n                   _(\"Could not open '%s' for reading: %s\"),\n                   gimp_filename_to_utf8 (filename), g_strerror (errno));\n      return -1;\n    }\n\n  gimp_progress_init_printf (_(\"Opening '%s'\"),\n                             gimp_filename_to_utf8 (filename));\n\n  if (fread (header_buf, 128, 1, fd) == 0)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"Could not read header from '%s'\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  pcx_header_from_buffer (header_buf);\n\n  if (pcx_header.manufacturer != 10)\n    {\n      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                   _(\"'%s' is not a PCX file\"),\n                   gimp_filename_to_utf8 (filename));\n      return -1;\n    }\n\n  offset_x     = GUINT16_FROM_LE (pcx_header.x1);\n  offset_y     = GUINT16_FROM_LE (pcx_header.y1);\n  width        = GUINT16_FROM_LE (pcx_header.x2) - offset_x + 1;\n  height       = GUINT16_FROM_LE (pcx_header.y2) - offset_y + 1;\n  bytesperline = GUINT16_FROM_LE (pcx_header.bytesperline);\n\n  if ((width < 0) || (width > GIMP_MAX_IMAGE_SIZE))\n    {\n      g_message (_(\"Unsupported or invalid image width: %d\"), width);\n      return -1;\n    }\n  if ((height < 0) || (height > GIMP_MAX_IMAGE_SIZE))\n    {\n      g_message (_(\"Unsupported or invalid image height: %d\"), height);\n      return -1;\n    }\n  if (bytesperline < (width * pcx_header.bpp) / 8)\n    {\n      g_message (_(\"Invalid number of bytes per line in PCX header\"));\n      return -1;\n    }\n\n  /* Shield against potential buffer overflows in load_*() functions. */\n  if (G_MAXSIZE / width / height < 3)\n    {\n      g_message (_(\"Image dimensions too large: width %d x height %d\"), width, height);\n      return -1;\n    }\n\n  if (pcx_header.planes == 3 && pcx_header.bpp == 8)\n    {\n      image= gimp_image_new (width, height, GIMP_RGB);\n      layer= gimp_layer_new (image, _(\"Background\"), width, height,\n                             GIMP_RGB_IMAGE, 100, GIMP_NORMAL_MODE);\n    }\n  else\n    {\n      image= gimp_image_new (width, height, GIMP_INDEXED);\n      layer= gimp_layer_new (image, _(\"Background\"), width, height,\n                             GIMP_INDEXED_IMAGE, 100, GIMP_NORMAL_MODE);\n    }\n  gimp_image_set_filename (image, filename);\n  gimp_image_add_layer (image, layer, 0);\n  gimp_layer_set_offsets (layer, offset_x, offset_y);\n  drawable = gimp_drawable_get (layer);\n\n  if (pcx_header.planes == 1 && pcx_header.bpp == 1)\n    {\n      dest = g_new (guchar, ((gsize) width) * height);\n      load_1 (fd, width, height, dest, bytesperline);\n      gimp_image_set_colormap (image, mono, 2);\n    }\n  else if (pcx_header.planes == 4 && pcx_header.bpp == 1)\n    {\n      dest = g_new (guchar, ((gsize) width) * height);\n      load_4 (fd, width, height, dest, bytesperline);\n      gimp_image_set_colormap (image, pcx_header.colormap, 16);\n    }\n  else if (pcx_header.planes == 1 && pcx_header.bpp == 8)\n    {\n      dest = g_new (guchar, ((gsize) width) * height);\n      load_8 (fd, width, height, dest, bytesperline);\n      fseek (fd, -768L, SEEK_END);\n      fread (cmap, 768, 1, fd);\n      gimp_image_set_colormap (image, cmap, 256);\n    }\n  else if (pcx_header.planes == 3 && pcx_header.bpp == 8)\n    {\n      dest = g_new (guchar, ((gsize) width) * height * 3);\n      load_24 (fd, width, height, dest, bytesperline);\n    }\n  else\n    {\n      g_message (_(\"Unusual PCX flavour, giving up\"));\n      return -1;\n    }\n\n  gimp_pixel_rgn_init (&pixel_rgn, drawable, 0, 0, width, height, TRUE, FALSE);\n  gimp_pixel_rgn_set_rect (&pixel_rgn, dest, 0, 0, width, height);\n\n  g_free (dest);\n\n  gimp_drawable_flush (drawable);\n  gimp_drawable_detach (drawable);\n\n  return image;\n}",
        "start_line": 342
      }
    ],
    "code_context": "Called Methods:\n- readline: static void /* <=== readline */ \nreadline (FILE   *fp,\n          guchar *buffer,\n          gint    bytes)\n{\n  static guchar count = 0, value = 0;\n\n  if (pcx_header.compression)\n    {\n      while (bytes--)\n        {\n          if (count == 0)\n            {\n              value = fgetc (fp);\n              if (value < 0xc0)\n                {\n                  count = 1;\n                }\n              else\n                {\n                  count = value - 0xc0;\n                  value = fgetc (fp);\n                }\n            }\n          count--;\n          *(buffer++) = value;\n        }\n    }\n  else\n    {\n      fread (buffer, bytes, 1, fp);\n    }\n}\n- gimp_pixel_rgn_init: void /* <=== gimp_pixel_rgn_init */ \ngimp_pixel_rgn_init (GimpPixelRgn *pr,\n                     GimpDrawable *drawable,\n                     gint          x,\n                     gint          y,\n                     gint          width,\n                     gint          height,\n                     gboolean      dirty,\n                     gboolean      shadow)\n{\n  g_return_if_fail (pr != NULL);\n  g_return_if_fail (drawable != NULL);\n  g_return_if_fail (x >= 0 && x + width  <= drawable->width);\n  g_return_if_fail (y >= 0 && y + height <= drawable->height);\n\n  pr->data      = NULL;\n  pr->drawable  = drawable;\n  pr->bpp       = drawable->bpp;\n  pr->rowstride = 0;\n  pr->x         = x;\n  pr->y         = y;\n  pr->w         = width;\n  pr->h         = height;\n  pr->dirty     = dirty;\n  pr->shadow    = shadow;\n}\n- GIMP_IMAGE_COLORMAP_SIZE: #define GIMP_IMAGE_COLORMAP_SIZE 768 /* <=== app/core/gimpimage-colormap.h:22:22:GIMP_IMAGE_COLORMAP_SIZE:0 */ \n- gimp_tile_unref: void    gimp_tile_unref        (GimpTile  *tile, /* <=== gimp_tile_unref */ \n                                gboolean   dirty);\n- gimp_progress_update: gboolean /* <=== gimp_progress_update */ \ngimp_progress_update (gdouble percentage)\n{\n  gboolean changed;\n\n  if (percentage <= 0.0)\n    {\n      changed = (gimp_progress_current != 0.0);\n      percentage = 0.0;\n    }\n  else if (percentage >= 1.0)\n    {\n      changed = (gimp_progress_current != 1.0);\n      percentage = 1.0;\n    }\n  else\n    {\n      changed =\n        (fabs (gimp_progress_current - percentage) > gimp_progress_step);\n\n#ifdef GIMP_UNSTABLE\n      if (! changed)\n        {\n          static gboolean warned = FALSE;\n          static gint     count  = 0;\n\n          count++;\n\n          if (count > 3 && ! warned)\n            {\n              g_printerr (\"%s is updating the progress too often\\n\",\n                          g_get_prgname ());\n              warned = TRUE;\n            }\n        }\n#endif\n    }\n\n  /*  Suppress the update if the change was only marginal.  */\n  if (! changed)\n    return TRUE;\n\n  gimp_progress_current = percentage;\n\n  return _gimp_progress_update (gimp_progress_current);\n}\n- gimp_pixel_rgn_set_rect: void /* <=== gimp_pixel_rgn_set_rect */ \ngimp_pixel_rgn_set_rect (GimpPixelRgn *pr,\n                         const guchar *buf,\n                         gint          x,\n                         gint          y,\n                         gint          width,\n                         gint          height)\n{\n  gulong  bufstride;\n  gint    xstart, ystart;\n  gint    xend, yend;\n  gint    xboundary;\n  gint    yboundary;\n  gint    xstep, ystep;\n  gint    ty, bpp;\n\n  g_return_if_fail (pr != NULL && pr->drawable != NULL);\n  g_return_if_fail (buf != NULL);\n  g_return_if_fail (x >= 0 && x + width  <= pr->drawable->width);\n  g_return_if_fail (y >= 0 && y + height <= pr->drawable->height);\n  g_return_if_fail (width >= 0);\n  g_return_if_fail (height >= 0);\n\n  bpp = pr->bpp;\n  bufstride = bpp * width;\n\n  xstart = x;\n  ystart = y;\n  xend = x + width;\n  yend = y + height;\n  ystep = 0;\n\n  while (y < yend)\n    {\n      x = xstart;\n\n      while (x < xend)\n        {\n          GimpTile *tile;\n\n          tile = gimp_drawable_get_tile2 (pr->drawable, pr->shadow, x, y);\n          gimp_tile_ref (tile);\n\n          xstep = tile->ewidth - (x % TILE_WIDTH);\n          ystep = tile->eheight - (y % TILE_HEIGHT);\n          xboundary = x + xstep;\n          yboundary = y + ystep;\n          xboundary = MIN (xboundary, xend);\n          yboundary = MIN (yboundary, yend);\n\n          for (ty = y; ty < yboundary; ty++)\n            {\n              const guchar *src;\n              guchar       *dest;\n\n              src = buf + bufstride * (ty - ystart) + bpp * (x - xstart);\n              dest = tile->data + tile->bpp * (tile->ewidth *\n                                               (ty % TILE_HEIGHT) + (x % TILE_WIDTH));\n\n              memcpy (dest, src, (xboundary - x) * bpp);\n            }\n\n          gimp_tile_unref (tile, TRUE);\n          x += xstep;\n        }\n\n      y += ystep;\n    }\n}\n- gimp_image_base_type: GimpImageBaseType /* <=== gimp_image_base_type */ \ngimp_image_base_type (gint32 image_ID)\n{\n  GimpParam *return_vals;\n  gint nreturn_vals;\n  GimpImageBaseType base_type = 0;\n\n  return_vals = gimp_run_procedure (\"gimp-image-base-type\",\n                                    &nreturn_vals,\n                                    GIMP_PDB_IMAGE, image_ID,\n                                    GIMP_PDB_END);\n\n  if (return_vals[0].data.d_status == GIMP_PDB_SUCCESS)\n    base_type = return_vals[1].data.d_int32;\n\n  gimp_destroy_params (return_vals, nreturn_vals);\n\n  return base_type;\n}\n- gimp_image_set_colormap: void /* <=== gimp_image_set_colormap */ \ngimp_image_set_colormap (GimpImage    *image,\n                         const guchar *colormap,\n                         gint          n_colors,\n                         gboolean      push_undo)\n{\n  g_return_if_fail (GIMP_IS_IMAGE (image));\n  g_return_if_fail (colormap != NULL || n_colors == 0);\n  g_return_if_fail (n_colors >= 0 && n_colors <= 256);\n\n  if (push_undo)\n    gimp_image_undo_push_image_colormap (image, _(\"Set Colormap\"));\n\n  if (image->colormap)\n    memset (image->colormap, 0, GIMP_IMAGE_COLORMAP_SIZE);\n\n  if (colormap)\n    {\n      if (! image->colormap)\n        image->colormap = g_new0 (guchar, GIMP_IMAGE_COLORMAP_SIZE);\n\n      memcpy (image->colormap, colormap, n_colors * 3);\n    }\n  else if (! gimp_image_base_type (image) == GIMP_INDEXED)\n    {\n      if (image->colormap)\n        g_free (image->colormap);\n\n      image->colormap = NULL;\n    }\n\n  image->n_colors = n_colors;\n\n  gimp_image_colormap_changed (image, -1);\n}\n- gimp_image_colormap_changed: void /* <=== gimp_image_colormap_changed */ \ngimp_image_colormap_changed (GimpImage *image,\n                             gint       color_index)\n{\n  g_return_if_fail (GIMP_IS_IMAGE (image));\n  g_return_if_fail (color_index >= -1 && color_index < image->n_colors);\n\n  g_signal_emit (image, gimp_image_signals[COLORMAP_CHANGED], 0,\n                 color_index);\n}\n- gimp_tile_ref: void    gimp_tile_ref          (GimpTile  *tile); /* <=== gimp_tile_ref */ \n- gimp_tile_height: guint /* <=== gimp_tile_height */ \ngimp_tile_height (void)\n{\n  return _tile_height;\n}\n- gimp_drawable_get_tile2: GimpTile * /* <=== gimp_drawable_get_tile2 */ \ngimp_drawable_get_tile2 (GimpDrawable *drawable,\n                         gboolean      shadow,\n                         gint          x,\n                         gint          y)\n{\n  gint row;\n  gint col;\n\n  g_return_val_if_fail (drawable != NULL, NULL);\n\n  col = x / TILE_WIDTH;\n  row = y / TILE_HEIGHT;\n\n  return gimp_drawable_get_tile (drawable, shadow, row, col);\n}\n- _gimp_tile_cache_flush_drawable: G_GNUC_INTERNAL void _gimp_tile_cache_flush_drawable (GimpDrawable *drawable); /* <=== _gimp_tile_cache_flush_drawable */ \n- gimp_tile_width: guint /* <=== gimp_tile_width */ \ngimp_tile_width (void)\n{\n  return _tile_width;\n}\n- TILE_HEIGHT: #define TILE_HEIGHT gimp_tile_height() /* <=== libgimp/gimppixelrgn.c:30:30:TILE_HEIGHT:0 */ \n- load_24: static void /* <=== load_24 */ \nload_24 (FILE    *fp,\n         gint     width,\n         gint     height,\n         guchar  *buffer,\n         guint16  bytes)\n{\n  gint    x, y, c;\n  guchar *line = g_new (guchar, bytes);\n\n  for (y = 0; y < height; buffer += width * 3, ++y)\n    {\n      for (c = 0; c < 3; ++c)\n        {\n          readline (fp, line, bytes);\n          for (x = 0; x < width; ++x)\n            {\n              buffer[x * 3 + c] = line[x];\n            }\n        }\n      gimp_progress_update ((double) y / (double) height);\n    }\n\n  g_free (line);\n}\n- load_1: static void /* <=== load_1 */ \nload_1 (FILE    *fp,\n        gint     width,\n        gint     height,\n        guchar  *buffer,\n        guint16  bytes)\n{\n  gint    x, y;\n  guchar *line = g_new (guchar, bytes);\n\n  for (y = 0; y < height; buffer += width, ++y)\n    {\n      readline (fp, line, bytes);\n      for (x = 0; x < width; ++x)\n        {\n          if (line[x / 8] & (128 >> (x % 8)))\n            buffer[x] = 1;\n          else\n            buffer[x] = 0;\n        }\n      gimp_progress_update ((double) y / (double) height);\n    }\n\n  g_free (line);\n}\n- TILE_WIDTH: #define TILE_WIDTH  gimp_tile_width() /* <=== libgimp/gimppixelrgn.c:29:29:TILE_WIDTH:0 */ \n- gimp_image_base_type: GimpImageBaseType /* <=== gimp_image_base_type */ \ngimp_image_base_type (const GimpImage *image)\n{\n  g_return_val_if_fail (GIMP_IS_IMAGE (image), -1);\n\n  return image->base_type;\n}\n- gimp_drawable_flush: void /* <=== gimp_drawable_flush */ \ngimp_drawable_flush (GimpDrawable *drawable)\n{\n  GimpTile *tiles;\n  gint      n_tiles;\n  gint      i;\n\n  g_return_if_fail (drawable != NULL);\n\n  if (drawable->tiles)\n    {\n      tiles   = drawable->tiles;\n      n_tiles = drawable->ntile_rows * drawable->ntile_cols;\n\n      for (i = 0; i < n_tiles; i++)\n        if ((tiles[i].ref_count > 0) && tiles[i].dirty)\n          gimp_tile_flush (&tiles[i]);\n    }\n\n  if (drawable->shadow_tiles)\n    {\n      tiles   = drawable->shadow_tiles;\n      n_tiles = drawable->ntile_rows * drawable->ntile_cols;\n\n      for (i = 0; i < n_tiles; i++)\n        if ((tiles[i].ref_count > 0) && tiles[i].dirty)\n          gimp_tile_flush (&tiles[i]);\n    }\n\n  /*  nuke all references to this drawable from the cache  */\n  _gimp_tile_cache_flush_drawable (drawable);\n}\n- gimp_tile_flush: void    gimp_tile_flush        (GimpTile  *tile); /* <=== gimp_tile_flush */ \n- load_4: static void /* <=== load_4 */ \nload_4 (FILE    *fp,\n        gint     width,\n        gint     height,\n        guchar  *buffer,\n        guint16  bytes)\n{\n  gint    x, y, c;\n  guchar *line = g_new (guchar, bytes);\n\n  for (y = 0; y < height; buffer += width, ++y)\n    {\n      for (x = 0; x < width; ++x)\n        buffer[x] = 0;\n      for (c = 0; c < 4; ++c)\n        {\n          readline(fp, line, bytes);\n          for (x = 0; x < width; ++x)\n            {\n              if (line[x / 8] & (128 >> (x % 8)))\n                buffer[x] += (1 << c);\n            }\n        }\n      gimp_progress_update ((double) y / (double) height);\n    }\n\n  g_free (line);\n}\n- GIMP_IS_IMAGE: #define GIMP_IS_IMAGE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GIMP_TYPE_IMAGE)) /* <=== app/core/gimpimage.h:95:95:GIMP_IS_IMAGE:1 */ \n- load_8: static void /* <=== load_8 */ \nload_8 (FILE    *fp,\n        gint     width,\n        gint     height,\n        guchar  *buffer,\n        guint16  bytes)\n{\n  gint    row;\n  guchar *line = g_new (guchar, bytes);\n\n  for (row = 0; row < height; buffer += width, ++row)\n    {\n      readline (fp, line, bytes);\n      memcpy (buffer, line, width);\n      gimp_progress_update ((double) row / (double) height);\n    }\n\n  g_free (line);\n}\n- gimp_drawable_detach: void /* <=== gimp_drawable_detach */ \ngimp_drawable_detach (GimpDrawable *drawable)\n{\n  g_return_if_fail (drawable != NULL);\n\n  gimp_drawable_flush (drawable);\n\n  if (drawable->tiles)\n    g_free (drawable->tiles);\n\n  if (drawable->shadow_tiles)\n    g_free (drawable->shadow_tiles);\n\n  g_slice_free (GimpDrawable, drawable);\n}\n\nType Definitions:\n- GimpPixelRgn: typedef struct _GimpPixelRgn    GimpPixelRgn;\n- GimpDrawable: typedef struct _GimpDrawable    GimpDrawable;\n\nGlobal Variables:\n- struct pcx_header\n\nImports:\n- #include <libgimp/gimpui.h>\n- #include <errno.h>\n- #include \"libgimp/stdplugins-intl.h\"\n- #include \"config.h\"\n- #include <glib/gstdio.h>\n- #include <libgimp/gimp.h>\n- #include <string.h>",
    "commit_msg": "PCX: Avoid allocation overflows.\n\nMultiplying gint values may overflow unless cast into a larger type.",
    "cve_desc": "Multiple integer overflows in the load_image function in file-pcx.c in the Personal Computer Exchange (PCX) plugin in GIMP 2.6.x and earlier allow remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted PCX image that triggers a heap-based buffer overflow.",
    "year": 2009,
    "filename": "file-pcx.c",
    "commit_url": "\"https://github.com/GNOME/gimp/commit/a9671395f6573e90316a9d748588c5435216f6ce\""
  },
  {
    "repository": "torvalds/linux",
    "cve_id": "CVE-2011-1477",
    "cwe_list": [
      "CWE-119"
    ],
    "commit_hash": "4d00135a680727f6c3be78f8befaac009030e4df",
    "short_hash": "4d00135a",
    "vulnerableMethods_before": [
      {
        "filename": "sound/oss/opl3.c",
        "method_name": "opl3_panning",
        "raw_code": "static void opl3_panning(int dev, int voice, int value) /* <=== opl3_panning */ \n{\n\tdevc->voc[voice].panning = value;\n}",
        "start_line": 846
      },
      {
        "filename": "sound/oss/opl3.c",
        "method_name": "opl3_setup_voice",
        "raw_code": "static void opl3_setup_voice(int dev, int voice, int chn) /* <=== opl3_setup_voice */ \n{\n\tstruct channel_info *info =\n\t&synth_devs[dev]->chn_info[chn];\n\n\topl3_set_instr(dev, voice, info->pgm_num);\n\n\tdevc->voc[voice].bender = 0;\n\tdevc->voc[voice].bender_range = info->bender_range;\n\tdevc->voc[voice].volume = info->controllers[CTL_MAIN_VOLUME];\n\tdevc->voc[voice].panning = (info->controllers[CTL_PAN] * 2) - 128;\n}",
        "start_line": 1063
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "sound/oss/opl3.c",
        "method_name": "opl3_panning",
        "raw_code": "static void opl3_panning(int dev, int voice, int value) /* <=== opl3_panning */ \n{\n\n\tif (voice < 0 || voice >= devc->nr_voice)\n\t\treturn;\n\n\tdevc->voc[voice].panning = value;\n}",
        "start_line": 846
      },
      {
        "filename": "sound/oss/opl3.c",
        "method_name": "opl3_setup_voice",
        "raw_code": "static void opl3_setup_voice(int dev, int voice, int chn) /* <=== opl3_setup_voice */ \n{\n\tstruct channel_info *info;\n\n\tif (voice < 0 || voice >= devc->nr_voice)\n\t\treturn;\n\n\tif (chn < 0 || chn > 15)\n\t\treturn;\n\n\tinfo = &synth_devs[dev]->chn_info[chn];\n\n\topl3_set_instr(dev, voice, info->pgm_num);\n\n\tdevc->voc[voice].bender = 0;\n\tdevc->voc[voice].bender_range = info->bender_range;\n\tdevc->voc[voice].volume = info->controllers[CTL_MAIN_VOLUME];\n\tdevc->voc[voice].panning = (info->controllers[CTL_PAN] * 2) - 128;\n}",
        "start_line": 1067
      }
    ],
    "code_context": "Called Methods:\n- opl3_set_instr: static int opl3_set_instr  (int dev, int voice, int instr_no) /* <=== opl3_set_instr */ \n{\n\tif (voice < 0 || voice >= devc->nr_voice)\n\t\treturn 0;\n\tif (instr_no < 0 || instr_no >= SBFM_MAXINSTR)\n\t\tinstr_no = 0;\t/* Acoustic piano (usually) */\n\n\tdevc->act_i[voice] = &devc->i_map[instr_no];\n\treturn 0;\n}\n- SBFM_MAXINSTR: #define SBFM_MAXINSTR\t\t(256)\t/* Size of the FM Instrument bank */ /* <=== sound/oss/sound_config.h:52:52:SBFM_MAXINSTR:0 */ \n\nType Definitions:\n- opl_devinfo: typedef struct opl_devinfo\n{\n\tint             base;\n\tint             left_io, right_io;\n\tint             nr_voice;\n\tint             lv_map[MAX_VOICE];\n\n\tstruct voice_info voc[MAX_VOICE];\n\tstruct voice_alloc_info *v_alloc;\n\tstruct channel_info *chn_info;\n\n\tstruct sbi_instrument i_map[SBFM_MAXINSTR];\n\tstruct sbi_instrument *act_i[MAX_VOICE];\n\n\tstruct synth_info fm_info;\n\n\tint             busy;\n\tint             model;\n\tunsigned char   cmask;\n\n\tint             is_opl4;\n}\n- channel_info: struct channel_info\n- opl_devinfo: typedef struct opl_devinfo\n{\n\tint             base;\n\tint             left_io, right_io;\n\tint             nr_voice;\n\tint             lv_map[MAX_VOICE];\n\n\tstruct voice_info voc[MAX_VOICE];\n\tstruct voice_alloc_info *v_alloc;\n\tstruct channel_info *chn_info;\n\n\tstruct sbi_instrument i_map[SBFM_MAXINSTR];\n\tstruct sbi_instrument *act_i[MAX_VOICE];\n\n\tstruct synth_info fm_info;\n\n\tint             busy;\n\tint             model;\n\tunsigned char   cmask;\n\n\tint             is_opl4;\n} opl_devinfo;\n- channel_info: struct channel_info {\n\t\tint pgm_num;\n\t\tint bender_value;\n\t\tint bender_range;\n\t\tunsigned char controllers[128];\n\t}\n\nGlobal Variables:\n- struct opl_devinfo* devc\n\nImports:\n- #include <linux/module.h>\n- #include \"opl3_hw.h\"\n- #include <linux/init.h>\n- #include <linux/slab.h>\n- #include \"sound_config.h\"\n- #include <linux/delay.h>",
    "commit_msg": "sound/oss/opl3: validate voice and channel indexes\n\nUser-controllable indexes for voice and channel values may cause reading\nand writing beyond the bounds of their respective arrays, leading to\npotentially exploitable memory corruption.  Validate these indexes.\n\nSigned-off-by: Dan Rosenberg <drosenberg@vsecurity.com>\nCc: stable@kernel.org\nSigned-off-by: Takashi Iwai <tiwai@suse.de>",
    "cve_desc": "[{'lang': 'en', 'value': 'Multiple array index errors in sound/oss/opl3.c in the Linux kernel before 2.6.39 allow local users to cause a denial of service (heap memory corruption) or possibly gain privileges by leveraging write access to /dev/sequencer.'}]",
    "year": 2011,
    "filename": "opl3.c",
    "commit_url": "\"https://github.com/torvalds/linux/commit/4d00135a680727f6c3be78f8befaac009030e4df\""
  },
  {
    "repository": "rsyslog/rsyslog",
    "cve_id": "CVE-2011-1488",
    "cwe_list": [
      "CWE-772"
    ],
    "commit_hash": "8083bd1433449fd2b1b79bf759f782e0f64c0cd2",
    "short_hash": "8083bd14",
    "vulnerableMethods_before": [
      {
        "filename": "runtime/msg.c",
        "method_name": "MsgDup",
        "raw_code": "msg_t* MsgDup(msg_t* pOld) /* <=== MsgDup */ \n{\n\tmsg_t* pNew;\n\trsRetVal localRet;\n\n\tassert(pOld != NULL);\n\n\tBEGINfunc\n\tif(msgConstructWithTime(&pNew, &pOld->tTIMESTAMP, pOld->ttGenTime) != RS_RET_OK) {\n\t\treturn NULL;\n\t}\n\n\t/* now copy the message properties */\n\tpNew->iRefCount = 1;\n\tpNew->iSeverity = pOld->iSeverity;\n\tpNew->iFacility = pOld->iFacility;\n\tpNew->msgFlags = pOld->msgFlags;\n\tpNew->iProtocolVersion = pOld->iProtocolVersion;\n\tpNew->ttGenTime = pOld->ttGenTime;\n\tpNew->offMSG = pOld->offMSG;\n\tpNew->iLenRawMsg = pOld->iLenRawMsg;\n\tpNew->iLenMSG = pOld->iLenMSG;\n\tpNew->iLenTAG = pOld->iLenTAG;\n\tpNew->iLenHOSTNAME = pOld->iLenHOSTNAME;\n\tif((pOld->msgFlags & NEEDS_DNSRESOL) == 1) {\n\t\t\tlocalRet = msgSetFromSockinfo(pNew, pOld->rcvFrom.pfrominet);\n\t\t\tif(localRet != RS_RET_OK) {\n\t\t\t\t/* if something fails, we accept loss of this property, it is\n\t\t\t\t * better than losing the whole message.\n\t\t\t\t */\n\t\t\t\tpNew->msgFlags &= ~NEEDS_DNSRESOL;\n\t\t\t}\n\t} else {\n\t\tif(pOld->rcvFrom.pRcvFrom != NULL) {\n\t\t\tpNew->rcvFrom.pRcvFrom = pOld->rcvFrom.pRcvFrom;\n\t\t\tprop.AddRef(pNew->rcvFrom.pRcvFrom);\n\t\t}\n\t}\n\tif(pOld->pRcvFromIP != NULL) {\n\t\tpNew->pRcvFromIP = pOld->pRcvFromIP;\n\t\tprop.AddRef(pNew->pRcvFromIP);\n\t}\n\tif(pOld->pInputName != NULL) {\n\t\tpNew->pInputName = pOld->pInputName;\n\t\tprop.AddRef(pNew->pInputName);\n\t}\n\t/* enable this, if someone actually uses UxTradMsg, delete after some time has\n\t * passed and nobody complained -- rgerhards, 2009-06-16\n\tpNew->offAfterPRI = pOld->offAfterPRI;\n\t*/\n\tif(pOld->iLenTAG > 0) {\n\t\tif(pOld->iLenTAG < CONF_TAG_BUFSIZE) {\n\t\t\tmemcpy(pNew->TAG.szBuf, pOld->TAG.szBuf, pOld->iLenTAG);\n\t\t} else {\n\t\t\tif((pNew->TAG.pszTAG = srUtilStrDup(pOld->TAG.pszTAG, pOld->iLenTAG)) == NULL) {\n\t\t\t\tmsgDestruct(&pNew);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tpNew->iLenTAG = pOld->iLenTAG;\n\t\t}\n\t}\n\tif(pOld->iLenRawMsg < CONF_RAWMSG_BUFSIZE) {\n\t\tmemcpy(pNew->szRawMsg, pOld->szRawMsg, pOld->iLenRawMsg + 1);\n\t\tpNew->pszRawMsg = pNew->szRawMsg;\n\t} else {\n\t\ttmpCOPYSZ(RawMsg);\n\t}\n\tif(pOld->iLenHOSTNAME < CONF_HOSTNAME_BUFSIZE) {\n\t\tmemcpy(pNew->szHOSTNAME, pOld->szHOSTNAME, pOld->iLenHOSTNAME + 1);\n\t\tpNew->pszHOSTNAME = pNew->szHOSTNAME;\n\t} else {\n\t\ttmpCOPYSZ(HOSTNAME);\n\t}\n\n\ttmpCOPYCSTR(ProgName);\n\ttmpCOPYCSTR(StrucData);\n\ttmpCOPYCSTR(APPNAME);\n\ttmpCOPYCSTR(PROCID);\n\ttmpCOPYCSTR(MSGID);\n\n\t/* we do not copy all other cache properties, as we do not even know\n\t * if they are needed once again. So we let them re-create if needed.\n\t */\n\n\tENDfunc\n\treturn pNew;\n}",
        "start_line": 901
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "runtime/msg.c",
        "method_name": "MsgDup",
        "raw_code": "msg_t* MsgDup(msg_t* pOld) /* <=== MsgDup */ \n{\n\tmsg_t* pNew;\n\trsRetVal localRet;\n\n\tassert(pOld != NULL);\n\n\tBEGINfunc\n\tif(msgConstructWithTime(&pNew, &pOld->tTIMESTAMP, pOld->ttGenTime) != RS_RET_OK) {\n\t\treturn NULL;\n\t}\n\n\t/* now copy the message properties */\n\tpNew->iRefCount = 1;\n\tpNew->iSeverity = pOld->iSeverity;\n\tpNew->iFacility = pOld->iFacility;\n\tpNew->msgFlags = pOld->msgFlags;\n\tpNew->iProtocolVersion = pOld->iProtocolVersion;\n\tpNew->ttGenTime = pOld->ttGenTime;\n\tpNew->offMSG = pOld->offMSG;\n\tpNew->iLenRawMsg = pOld->iLenRawMsg;\n\tpNew->iLenMSG = pOld->iLenMSG;\n\tpNew->iLenTAG = pOld->iLenTAG;\n\tpNew->iLenHOSTNAME = pOld->iLenHOSTNAME;\n\tif((pOld->msgFlags & NEEDS_DNSRESOL)) {\n\t\t\tlocalRet = msgSetFromSockinfo(pNew, pOld->rcvFrom.pfrominet);\n\t\t\tif(localRet != RS_RET_OK) {\n\t\t\t\t/* if something fails, we accept loss of this property, it is\n\t\t\t\t * better than losing the whole message.\n\t\t\t\t */\n\t\t\t\tpNew->msgFlags &= ~NEEDS_DNSRESOL;\n\t\t\t\tpNew->rcvFrom.pRcvFrom = NULL; /* make sure no dangling values */\n\t\t\t}\n\t} else {\n\t\tif(pOld->rcvFrom.pRcvFrom != NULL) {\n\t\t\tpNew->rcvFrom.pRcvFrom = pOld->rcvFrom.pRcvFrom;\n\t\t\tprop.AddRef(pNew->rcvFrom.pRcvFrom);\n\t\t}\n\t}\n\tif(pOld->pRcvFromIP != NULL) {\n\t\tpNew->pRcvFromIP = pOld->pRcvFromIP;\n\t\tprop.AddRef(pNew->pRcvFromIP);\n\t}\n\tif(pOld->pInputName != NULL) {\n\t\tpNew->pInputName = pOld->pInputName;\n\t\tprop.AddRef(pNew->pInputName);\n\t}\n\t/* enable this, if someone actually uses UxTradMsg, delete after some time has\n\t * passed and nobody complained -- rgerhards, 2009-06-16\n\tpNew->offAfterPRI = pOld->offAfterPRI;\n\t*/\n\tif(pOld->iLenTAG > 0) {\n\t\tif(pOld->iLenTAG < CONF_TAG_BUFSIZE) {\n\t\t\tmemcpy(pNew->TAG.szBuf, pOld->TAG.szBuf, pOld->iLenTAG);\n\t\t} else {\n\t\t\tif((pNew->TAG.pszTAG = srUtilStrDup(pOld->TAG.pszTAG, pOld->iLenTAG)) == NULL) {\n\t\t\t\tmsgDestruct(&pNew);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tpNew->iLenTAG = pOld->iLenTAG;\n\t\t}\n\t}\n\tif(pOld->iLenRawMsg < CONF_RAWMSG_BUFSIZE) {\n\t\tmemcpy(pNew->szRawMsg, pOld->szRawMsg, pOld->iLenRawMsg + 1);\n\t\tpNew->pszRawMsg = pNew->szRawMsg;\n\t} else {\n\t\ttmpCOPYSZ(RawMsg);\n\t}\n\tif(pOld->iLenHOSTNAME < CONF_HOSTNAME_BUFSIZE) {\n\t\tmemcpy(pNew->szHOSTNAME, pOld->szHOSTNAME, pOld->iLenHOSTNAME + 1);\n\t\tpNew->pszHOSTNAME = pNew->szHOSTNAME;\n\t} else {\n\t\ttmpCOPYSZ(HOSTNAME);\n\t}\n\n\ttmpCOPYCSTR(ProgName);\n\ttmpCOPYCSTR(StrucData);\n\ttmpCOPYCSTR(APPNAME);\n\ttmpCOPYCSTR(PROCID);\n\ttmpCOPYCSTR(MSGID);\n\n\t/* we do not copy all other cache properties, as we do not even know\n\t * if they are needed once again. So we let them re-create if needed.\n\t */\n\n\tENDfunc\n\treturn pNew;\n}",
        "start_line": 901
      }
    ],
    "code_context": "Called Methods:\n- CONF_HOSTNAME_BUFSIZE: #define CONF_HOSTNAME_BUFSIZE\t\t32 /* <=== runtime/rsyslog.h:48:48:CONF_HOSTNAME_BUFSIZE:0 */ \n- MALLOC: #\tdefine MALLOC(x) malloc(x) /* <=== runtime/debug.h:138:138:MALLOC:1 */ \n- ABORT_FINALIZE: #define ABORT_FINALIZE(errCode)\t\t\t\\ /* <=== runtime/rsyslog.h:365:369:ABORT_FINALIZE:1 */ \n\tdo {\t\t\t\t\t\\\n\t\tiRet = errCode;\t\t\t\\\n\t\tgoto finalize_it;\t\t\\\n\t} while (0)\n- msgConstructWithTime: rsRetVal msgConstructWithTime(msg_t **ppThis, struct syslogTime *stTime, time_t ttGenTime) /* <=== msgConstructWithTime */ \n{\n\tDEFiRet;\n\n\tCHKiRet(msgBaseConstruct(ppThis));\n\t(*ppThis)->ttGenTime = ttGenTime;\n\tmemcpy(&(*ppThis)->tRcvdAt, stTime, sizeof(struct syslogTime));\n\tmemcpy(&(*ppThis)->tTIMESTAMP, stTime, sizeof(struct syslogTime));\n\nfinalize_it:\n\tRETiRet;\n}\n- rsCHECKVALIDOBJECT: #define rsCHECKVALIDOBJECT(x, type) {assert(x != NULL); assert(x->OID == type);} /* <=== runtime/rsyslog.h:401:401:rsCHECKVALIDOBJECT:2 */ \n- cstrConstruct: rsRetVal cstrConstruct(cstr_t **ppThis) /* <=== cstrConstruct */ \n{\n\tDEFiRet;\n\tcstr_t *pThis;\n\n\tASSERT(ppThis != NULL);\n\n\tCHKmalloc(pThis = (cstr_t*) calloc(1, sizeof(cstr_t)));\n\n\trsSETOBJTYPE(pThis, OIDrsCStr);\n\tpThis->pBuf = NULL;\n\tpThis->pszBuf = NULL;\n\tpThis->iBufSize = 0;\n\tpThis->iStrLen = 0;\n\t*ppThis = pThis;\n\nfinalize_it:\n\tRETiRet;\n}\n- srUtilStrDup: uchar *srUtilStrDup(uchar *pOld, size_t len) /* <=== srUtilStrDup */ \n{\n\tuchar *pNew;\n\n\tassert(pOld != NULL);\n\t\n\tif((pNew = MALLOC(len + 1)) != NULL)\n\t\tmemcpy(pNew, pOld, len + 1);\n\n\treturn pNew;\n}\n- msgBaseConstruct: static inline rsRetVal msgBaseConstruct(msg_t **ppThis) /* <=== msgBaseConstruct */ \n{\n\tDEFiRet;\n\tmsg_t *pM;\n\n\tassert(ppThis != NULL);\n\tCHKmalloc(pM = MALLOC(sizeof(msg_t)));\n\tobjConstructSetObjInfo(pM); /* intialize object helper entities */\n\n\t/* initialize members in ORDER they appear in structure (think \"cache line\"!) */\n\tpM->flowCtlType = 0;\n\tpM->bDoLock = 0;\n\tpM->iRefCount = 1;\n\tpM->iSeverity = -1;\n\tpM->iFacility = -1;\n\tpM->offAfterPRI = 0;\n\tpM->offMSG = -1;\n\tpM->iProtocolVersion = 0;\n\tpM->msgFlags = 0;\n\tpM->iLenRawMsg = 0;\n\tpM->iLenMSG = 0;\n\tpM->iLenTAG = 0;\n\tpM->iLenHOSTNAME = 0;\n\tpM->pszRawMsg = NULL;\n\tpM->pszHOSTNAME = NULL;\n\tpM->pszRcvdAt3164 = NULL;\n\tpM->pszRcvdAt3339 = NULL;\n\tpM->pszRcvdAt_MySQL = NULL;\n        pM->pszRcvdAt_PgSQL = NULL;\n\tpM->pszTIMESTAMP3164 = NULL;\n\tpM->pszTIMESTAMP3339 = NULL;\n\tpM->pszTIMESTAMP_MySQL = NULL;\n        pM->pszTIMESTAMP_PgSQL = NULL;\n\tpM->pCSProgName = NULL;\n\tpM->pCSStrucData = NULL;\n\tpM->pCSAPPNAME = NULL;\n\tpM->pCSPROCID = NULL;\n\tpM->pCSMSGID = NULL;\n\tpM->pInputName = NULL;\n\tpM->pRcvFromIP = NULL;\n\tpM->rcvFrom.pRcvFrom = NULL;\n\tpM->pRuleset = NULL;\n\tmemset(&pM->tRcvdAt, 0, sizeof(pM->tRcvdAt));\n\tmemset(&pM->tTIMESTAMP, 0, sizeof(pM->tTIMESTAMP));\n\tpM->TAG.pszTAG = NULL;\n\tpM->pszTimestamp3164[0] = '\\0';\n\tpM->pszTimestamp3339[0] = '\\0';\n\tpM->pszTIMESTAMP_SecFrac[0] = '\\0';\n\tpM->pszRcvdAt_SecFrac[0] = '\\0';\n\n\t/* DEV debugging only! dbgprintf(\"msgConstruct\\t0x%x, ref 1\\n\", (int)pM);*/\n\n\t*ppThis = pM;\n\nfinalize_it:\n\tRETiRet;\n}\n- MsgLock: #define MsgLock(pMsg) \tfuncLock(pMsg) /* <=== runtime/msg.c:567:567:MsgLock:1 */ \n- RSFREEOBJ: #define RSFREEOBJ(x) {(x)->OID = OIDrsFreed; free(x);} /* <=== runtime/rsyslog.h:411:411:RSFREEOBJ:1 */ \n- rsCStrConstructFromCStr: rsRetVal rsCStrConstructFromCStr(cstr_t **ppThis, cstr_t *pFrom) /* <=== rsCStrConstructFromCStr */ \n{\n\tDEFiRet;\n\tcstr_t *pThis;\n\n\tassert(ppThis != NULL);\n\trsCHECKVALIDOBJECT(pFrom, OIDrsCStr);\n\n\tCHKiRet(rsCStrConstruct(&pThis));\n\n\tpThis->iBufSize = pThis->iStrLen = pFrom->iStrLen;\n\tif((pThis->pBuf = (uchar*) MALLOC(sizeof(uchar) * pThis->iStrLen)) == NULL) {\n\t\tRSFREEOBJ(pThis);\n\t\tABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);\n\t}\n\n\t/* copy properties */\n\tmemcpy(pThis->pBuf, pFrom->pBuf, pThis->iStrLen);\n\n\t*ppThis = pThis;\nfinalize_it:\n\tRETiRet;\n}\n- NEEDS_DNSRESOL: #define NEEDS_DNSRESOL\t0x040\t/* fromhost address is unresolved and must be locked up via DNS reverse lookup first */ /* <=== runtime/msg.h:131:131:NEEDS_DNSRESOL:0 */ \n- freeTAG: static inline void freeTAG(msg_t *pThis) /* <=== freeTAG */ \n{\n\tif(pThis->iLenTAG >= CONF_TAG_BUFSIZE)\n\t\tfree(pThis->TAG.pszTAG);\n}\n- rsCStrDestruct: void rsCStrDestruct(cstr_t **ppThis) /* <=== rsCStrDestruct */ \n{\n\tcstr_t *pThis = *ppThis;\n\n\tfree(pThis->pBuf);\n\tfree(pThis->pszBuf);\n\tRSFREEOBJ(pThis);\n\t*ppThis = NULL;\n}\n- msgSetFromSockinfo: rsRetVal /* <=== msgSetFromSockinfo */ \nmsgSetFromSockinfo(msg_t *pThis, struct sockaddr_storage *sa){ \n\tDEFiRet;\n\tassert(pThis->rcvFrom.pRcvFrom == NULL);\n\n\tCHKmalloc(pThis->rcvFrom.pfrominet = malloc(sizeof(struct sockaddr_storage)));\n\tmemcpy(pThis->rcvFrom.pfrominet, sa, sizeof(struct sockaddr_storage));\n\nfinalize_it:\n\tRETiRet;\n}\n- DEFiRet: #define DEFiRet BEGINfunc rsRetVal iRet = RS_RET_OK /* <=== runtime/rsyslog.h:362:362:DEFiRet:0 */ \n- CHKmalloc: #define CHKmalloc(operation) if((operation) == NULL) ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY) /* <=== runtime/rsyslog.h:359:359:CHKmalloc:1 */ \n- MsgUnlock: #define MsgUnlock(pMsg) funcUnlock(pMsg) /* <=== runtime/msg.c:568:568:MsgUnlock:1 */ \n- dbgprintf: void /* <=== dbgprintf */ \ndbgprintf(char *fmt, ...)\n{\n\tva_list ap;\n\tchar pszWriteBuf[32*1024];\n\tsize_t lenWriteBuf;\n\n\tif(!(Debug && debugging_on))\n\t\treturn;\n\t\n\tva_start(ap, fmt);\n\tlenWriteBuf = vsnprintf(pszWriteBuf, sizeof(pszWriteBuf), fmt, ap);\n\tva_end(ap);\n\tif(lenWriteBuf >= sizeof(pszWriteBuf)) {\n\t\t/* prevent buffer overrruns and garbagge display */\n\t\tpszWriteBuf[sizeof(pszWriteBuf) - 5] = '.';\n\t\tpszWriteBuf[sizeof(pszWriteBuf) - 4] = '.';\n\t\tpszWriteBuf[sizeof(pszWriteBuf) - 3] = '.';\n\t\tpszWriteBuf[sizeof(pszWriteBuf) - 2] = '\\n';\n\t\tpszWriteBuf[sizeof(pszWriteBuf) - 1] = '\\0';\n\t\tlenWriteBuf = sizeof(pszWriteBuf);\n\t}\n\tdbgprint(NULL, pszWriteBuf, lenWriteBuf);\n}\n- RETiRet: #define RETiRet do{ ENDfuncIRet return iRet; }while(0) /* <=== runtime/rsyslog.h:363:363:RETiRet:0 */ \n- CONF_RAWMSG_BUFSIZE: #define CONF_RAWMSG_BUFSIZE\t\t101 /* <=== runtime/rsyslog.h:46:46:CONF_RAWMSG_BUFSIZE:0 */ \n- CHKiRet: #define CHKiRet(code) if((iRet = code) != RS_RET_OK) goto finalize_it /* <=== runtime/rsyslog.h:355:355:CHKiRet:1 */ \n- msgDestruct: BEGINobjDestruct(msg) /* be sure to specify the object type also in END and CODESTART macros! */ /* <=== msgDestruct */ \n\tint currRefCount;\n#\tif HAVE_MALLOC_TRIM\n\tint currCnt;\n#\tendif\nCODESTARTobjDestruct(msg)\n\t/* DEV Debugging only ! dbgprintf(\"msgDestruct\\t0x%lx, Ref now: %d\\n\", (unsigned long)pThis, pThis->iRefCount - 1); */\n#\tifdef HAVE_ATOMIC_BUILTINS\n\t\tcurrRefCount = ATOMIC_DEC_AND_FETCH(&pThis->iRefCount, NULL);\n#\telse\n\t\tMsgLock(pThis);\n\t\tcurrRefCount = --pThis->iRefCount;\n# \tendif\n\tif(currRefCount == 0)\n\t{\n\t\t/* DEV Debugging Only! dbgprintf(\"msgDestruct\\t0x%lx, RefCount now 0, doing DESTROY\\n\", (unsigned long)pThis); */\n\t\tif(pThis->pszRawMsg != pThis->szRawMsg)\n\t\t\tfree(pThis->pszRawMsg);\n\t\tfreeTAG(pThis);\n\t\tfreeHOSTNAME(pThis);\n\t\tif(pThis->pInputName != NULL)\n\t\t\tprop.Destruct(&pThis->pInputName);\n\t\tif((pThis->msgFlags & NEEDS_DNSRESOL) == 0) {\n\t\t\tif(pThis->rcvFrom.pRcvFrom != NULL)\n\t\t\t\tprop.Destruct(&pThis->rcvFrom.pRcvFrom);\n\t\t} else {\n\t\t\tfree(pThis->rcvFrom.pfrominet);\n\t\t}\n\t\tif(pThis->pRcvFromIP != NULL)\n\t\t\tprop.Destruct(&pThis->pRcvFromIP);\n\t\tfree(pThis->pszRcvdAt3164);\n\t\tfree(pThis->pszRcvdAt3339);\n\t\tfree(pThis->pszRcvdAt_MySQL);\n\t\tfree(pThis->pszRcvdAt_PgSQL);\n\t\tfree(pThis->pszTIMESTAMP_MySQL);\n\t\tfree(pThis->pszTIMESTAMP_PgSQL);\n\t\tif(pThis->pCSProgName != NULL)\n\t\t\trsCStrDestruct(&pThis->pCSProgName);\n\t\tif(pThis->pCSStrucData != NULL)\n\t\t\trsCStrDestruct(&pThis->pCSStrucData);\n\t\tif(pThis->pCSAPPNAME != NULL)\n\t\t\trsCStrDestruct(&pThis->pCSAPPNAME);\n\t\tif(pThis->pCSPROCID != NULL)\n\t\t\trsCStrDestruct(&pThis->pCSPROCID);\n\t\tif(pThis->pCSMSGID != NULL)\n\t\t\trsCStrDestruct(&pThis->pCSMSGID);\n#\tifndef HAVE_ATOMIC_BUILTINS\n\t\tMsgUnlock(pThis);\n# \tendif\n\t\tfuncDeleteMutex(pThis);\n\t\t/* now we need to do our own optimization. Testing has shown that at least the glibc\n\t\t * malloc() subsystem returns memory to the OS far too late in our case. So we need\n\t\t * to help it a bit, by calling malloc_trim(), which will tell the alloc subsystem\n\t\t * to consolidate and return to the OS. We keep 128K for our use, as a safeguard\n\t\t * to too-frequent reallocs. But more importantly, we call this hook only every\n\t\t * 100,000 messages (which is an approximation, as we do not work with atomic\n\t\t * operations on the counter. --- rgerhards, 2009-06-22.\n\t\t */\n#\t\tif HAVE_MALLOC_TRIM\n\t\t{\t/* standard C requires a new block for a new variable definition!\n\t\t\t * To simplify matters, we use modulo arithmetic and live with the fact\n\t\t\t * that we trim too often when the counter wraps.\n\t\t\t */\n\t\t\tstatic unsigned iTrimCtr = 1;\n\t\t\tcurrCnt = ATOMIC_INC_AND_FETCH_unsigned(&iTrimCtr, &mutTrimCtr);\n\t\t\tif(currCnt % 100000 == 0) {\n\t\t\t\tmalloc_trim(128*1024);\n\t\t\t}\n\t\t}\n#\t\tendif\n\t} else {\n#\tifndef HAVE_ATOMIC_BUILTINS\n\t\tMsgUnlock(pThis);\n# \tendif\n\t\tpThis = NULL; /* tell framework not to destructing the object! */\n\t}\nENDobjDestruct(msg)\n- ENDobjDestruct: #define ENDobjDestruct(OBJ) \\ /* <=== runtime/obj-types.h:305:316:ENDobjDestruct:1 */ \n\t \tgoto finalize_it; /* prevent compiler warning ;) */ \\\n\t \t/* no more code here! */ \\\n\tfinalize_it: \\\n\t\tif(pThis != NULL) { \\\n\t\t\tobj.DestructObjSelf((obj_t*) pThis); \\\n\t\t\tfree(pThis); \\\n\t\t} \\\n\t\t*ppThis = NULL; \\\n\t\tpthread_setcancelstate(iCancelStateSave, NULL); \\\n\t\tRETiRet; \\\n\t} \n- tmpCOPYSZ: #define tmpCOPYSZ(name) \\ /* <=== runtime/msg.c:873:880:tmpCOPYSZ:1 */ \n\tif(pOld->psz##name != NULL) { \\\n\t\tif((pNew->psz##name = srUtilStrDup(pOld->psz##name, pOld->iLen##name)) == NULL) {\\\n\t\t\tmsgDestruct(&pNew);\\\n\t\t\treturn NULL;\\\n\t\t}\\\n\t\tpNew->iLen##name = pOld->iLen##name;\\\n\t}\n- tmpCOPYCSTR: #define tmpCOPYCSTR(name) \\ /* <=== runtime/msg.c:886:892:tmpCOPYCSTR:1 */ \n\tif(pOld->pCS##name != NULL) {\\\n\t\tif(rsCStrConstructFromCStr(&(pNew->pCS##name), pOld->pCS##name) != RS_RET_OK) {\\\n\t\t\tmsgDestruct(&pNew);\\\n\t\t\treturn NULL;\\\n\t\t}\\\n\t}\n- CODESTARTobjDestruct: #define CODESTARTobjDestruct(OBJ) \\ /* <=== runtime/obj-types.h:290:294:CODESTARTobjDestruct:1 */ \n\t\tASSERT(ppThis != NULL); \\\n\t\tpThis = *ppThis; \\\n\t\tISOBJ_TYPE_assert(pThis, OBJ); \\\n\t\tpthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &iCancelStateSave);\n- freeHOSTNAME: static inline void freeHOSTNAME(msg_t *pThis) /* <=== freeHOSTNAME */ \n{\n\tif(pThis->iLenHOSTNAME >= CONF_HOSTNAME_BUFSIZE)\n\t\tfree(pThis->pszHOSTNAME);\n}\n\nType Definitions:\n- rsRetVal_: enum rsRetVal_\t\t\t\t/** return value. All methods return this if not specified otherwise */\n{\n\t/* the first two define are for errmsg.logError(), so that we can use the rsRetVal \n\t * as an rsyslog error code. -- rgerhards, 20080-06-27\n\t */\n\tRS_RET_NO_ERRCODE = -1,\t\t/**< RESERVED for NO_ERRCODE errmsg.logError status name */\n\tRS_RET_INCLUDE_ERRNO = 1073741824, /* 2**30  - do NOT use error codes above this! */\n\t/* begin regular error codes */\n\tRS_RET_NOT_IMPLEMENTED = -7,\t/**< implementation is missing (probably internal error or lazyness ;)) */\n\tRS_RET_OUT_OF_MEMORY = -6,\t/**< memory allocation failed */\n\tRS_RET_PROVIDED_BUFFER_TOO_SMALL = -50,/**< the caller provided a buffer, but the called function sees the size of this buffer is too small - operation not carried out */\n\tRS_RET_TRUE = -3,\t\t/**< to indicate a true state (can be used as TRUE, legacy) */\n\tRS_RET_FALSE = -2,\t\t/**< to indicate a false state (can be used as FALSE, legacy) */\n\tRS_RET_NO_IRET = -8,\t/**< This is a trick for the debuging system - it means no iRet is provided  */\n\tRS_RET_VALIDATION_RUN = -9,\t/**< indicates a (config) validation run, processing not carried out */\n\tRS_RET_ERR = -3000,\t/**< generic failure */\n\tRS_TRUNCAT_TOO_LARGE = -3001, /**< truncation operation where too many chars should be truncated */\n\tRS_RET_FOUND_AT_STRING_END = -3002, /**< some value found, but at the last pos of string */\n\tRS_RET_NOT_FOUND = -3003, /**< some requested value not found */\n\tRS_RET_MISSING_TRAIL_QUOTE = -3004, /**< an expected trailing quote is missing */\n\tRS_RET_NO_DIGIT = -3005,\t/**< an digit was expected, but none found (mostly parsing) */\n\tRS_RET_NO_MORE_DATA = -3006,\t/**< insufficient data, e.g. end of string during parsing */\n\tRS_RET_INVALID_IP = -3007,\t/**< invalid ip found where valid was expected */\n\tRS_RET_OBJ_CREATION_FAILED = - 3008, /**< the creation of an object failed (no details available) */\n\tRS_RET_PARAM_ERROR = -1000,\t/**< invalid parameter in call to function */\n\tRS_RET_MISSING_INTERFACE = -1001,/**< interface version mismatch, required missing */\n\tRS_RET_INVALID_CORE_INTERFACE = -1002,/**< interface provided by host invalid, can not be used */\n\tRS_RET_ENTRY_POINT_NOT_FOUND = -1003,/**< a requested entry point was not found */\n\tRS_RET_MODULE_ENTRY_POINT_NOT_FOUND = -1004,/**< a entry point requested from a module was not present in it */\n\tRS_RET_OBJ_NOT_AVAILABLE = -1005,/**< something could not be completed because the required object is not available*/\n\tRS_RET_LOAD_ERROR = -1006,/**< we had an error loading the object/interface and can not continue */\n\tRS_RET_MODULE_STILL_REFERENCED = -1007,/**< module could not be unloaded because it still is referenced by someone */\n\tRS_RET_OBJ_UNKNOWN = -1008,/**< object is unknown where required */\n\tRS_RET_OBJ_NOT_REGISTERED = -1009,/**< tried to unregister an object that is not registered */\n\t/* return states for config file processing */\n\tRS_RET_NONE = -2000,\t\t/**< some value is not available - not necessarily an error */\n\tRS_RET_CONFLINE_UNPROCESSED = -2001,/**< config line was not processed, pass to other module */\n\tRS_RET_DISCARDMSG = -2002,\t/**< discard message (no error state, processing request!) */\n\tRS_RET_INCOMPATIBLE = -2003,\t/**< function not compatible with requested feature */\n\tRS_RET_NOENTRY = -2004,\t\t/**< do not create an entry for (whatever) - not necessary an error */\n\tRS_RET_NO_SQL_STRING = -2005,\t/**< string is not suitable for use as SQL */\n\tRS_RET_DISABLE_ACTION = -2006,  /**< action requests that it be disabled */\n\tRS_RET_SUSPENDED = -2007,  /**< something was suspended, not neccesarily an error */\n\tRS_RET_RQD_TPLOPT_MISSING = -2008,/**< a required template option is missing */\n\tRS_RET_INVALID_VALUE = -2009,/**< some value is invalid (e.g. user-supplied data) */\n\tRS_RET_INVALID_INT = -2010,/**< invalid integer */\n\tRS_RET_INVALID_CMD = -2011,/**< invalid command */\n\tRS_RET_VAL_OUT_OF_RANGE = -2012, /**< value out of range */\n\tRS_RET_FOPEN_FAILURE = -2013,\t/**< failure during fopen, for example file not found - see errno */\n\tRS_RET_END_OF_LINKEDLIST = -2014,\t/**< end of linked list, not an error, but a status */\n\tRS_RET_CHAIN_NOT_PERMITTED = -2015, /**< chaining (e.g. of config command handlers) not permitted */\n\tRS_RET_INVALID_PARAMS = -2016,/**< supplied parameters are invalid */\n\tRS_RET_EMPTY_LIST = -2017, /**< linked list is empty */\n\tRS_RET_FINISHED = -2018, /**< some opertion is finished, not an error state */\n\tRS_RET_INVALID_SOURCE = -2019, /**< source (address) invalid for some reason */\n\tRS_RET_ADDRESS_UNKNOWN = -2020, /**< an address is unknown - not necessarily an error */\n\tRS_RET_MALICIOUS_ENTITY = -2021, /**< there is an malicious entity involved */\n\tRS_RET_NO_KERNEL_LOGSRC = -2022, /**< no source for kernel logs can be obtained */\n\tRS_RET_TCP_SEND_ERROR = -2023, /**< error during TCP send process */\n\tRS_RET_GSS_SEND_ERROR = -2024, /**< error during GSS (via TCP) send process */\n\tRS_RET_TCP_SOCKCREATE_ERR = -2025, /**< error during creation of TCP socket */\n\tRS_RET_GSS_SENDINIT_ERROR = -2024, /**< error during GSS (via TCP) send initialization process */\n\tRS_RET_EOF = -2026, /**< end of file reached, not necessarily an error */\n\tRS_RET_IO_ERROR = -2027, /**< some kind of IO error happened */\n\tRS_RET_INVALID_OID = -2028, /**< invalid object ID */\n\tRS_RET_INVALID_HEADER = -2029, /**< invalid header */\n\tRS_RET_INVALID_HEADER_VERS = -2030, /**< invalid header version */\n\tRS_RET_INVALID_DELIMITER = -2031, /**< invalid delimiter, e.g. between params */\n\tRS_RET_INVALID_PROPFRAME = -2032, /**< invalid framing in serialized property */\n\tRS_RET_NO_PROPLINE = -2033, /**< line is not a property line */\n\tRS_RET_INVALID_TRAILER = -2034, /**< invalid trailer */\n\tRS_RET_VALUE_TOO_LOW = -2035, /**< a provided value is too low */\n\tRS_RET_FILE_PREFIX_MISSING = -2036, /**< a required file prefix (parameter?) is missing */\n\tRS_RET_INVALID_HEADER_RECTYPE = -2037, /**< invalid record type in header or invalid header */\n\tRS_RET_QTYPE_MISMATCH = -2038, /**< different qType when reading back a property type */\n\tRS_RET_NO_FILE_ACCESS = -2039, /**< covers EACCES error on file open() */\n\tRS_RET_FILE_NOT_FOUND = -2040, /**< file not found */\n\tRS_RET_TIMED_OUT = -2041, /**< timeout occured (not necessarily an error) */\n\tRS_RET_QSIZE_ZERO = -2042, /**< queue size is zero where this is not supported */\n\tRS_RET_ALREADY_STARTING = -2043, /**< something (a thread?) is already starting - not necessarily an error */\n\tRS_RET_NO_MORE_THREADS = -2044, /**< no more threads available, not necessarily an error */\n\tRS_RET_NO_FILEPREFIX = -2045, /**< file prefix is not specified where one is needed */\n\tRS_RET_CONFIG_ERROR = -2046, /**< there is a problem with the user-provided config settigs */\n\tRS_RET_OUT_OF_DESRIPTORS = -2047, /**< a descriptor table's space has been exhausted */\n\tRS_RET_NO_DRIVERS = -2048, /**< a required drivers missing */\n\tRS_RET_NO_DRIVERNAME = -2049, /**< driver name missing where one was required */\n\tRS_RET_EOS = -2050, /**< end of stream (of whatever) */\n\tRS_RET_SYNTAX_ERROR = -2051, /**< syntax error, eg. during parsing */\n\tRS_RET_INVALID_OCTAL_DIGIT = -2052, /**< invalid octal digit during parsing */\n\tRS_RET_INVALID_HEX_DIGIT = -2053, /**< invalid hex digit during parsing */\n\tRS_RET_INTERFACE_NOT_SUPPORTED = -2054, /**< interface not supported */\n\tRS_RET_OUT_OF_STACKSPACE = -2055, /**< a stack data structure is exhausted and can not be grown */\n\tRS_RET_STACK_EMPTY = -2056, /**< a pop was requested on a stack, but the stack was already empty */\n\tRS_RET_INVALID_VMOP = -2057, /**< invalid virtual machine instruction */\n\tRS_RET_INVALID_VAR = -2058, /**< a var_t or its content is unsuitable, eg. VARTYPE_NONE */\n\tRS_RET_INVALID_NUMBER = -2059, /**< number invalid during parsing */\n\tRS_RET_NOT_A_NUMBER = -2060, /**< e.g. conversion impossible because the string is not a number */\n\tRS_RET_OBJ_ALREADY_REGISTERED = -2061, /**< object (name) is already registered */\n\tRS_RET_OBJ_REGISTRY_OUT_OF_SPACE = -2062, /**< the object registry has run out of space */\n\tRS_RET_HOST_NOT_PERMITTED = -2063, /**< a host is not permitted to perform an action it requested */\n\tRS_RET_MODULE_LOAD_ERR = -2064, /**< module could not be loaded */\n\tRS_RET_MODULE_LOAD_ERR_PATHLEN = -2065, /**< module could not be loaded - path to long */\n\tRS_RET_MODULE_LOAD_ERR_DLOPEN = -2066, /**< module could not be loaded - problem in dlopen() */\n\tRS_RET_MODULE_LOAD_ERR_NO_INIT = -2067, /**< module could not be loaded - init() missing */\n\tRS_RET_MODULE_LOAD_ERR_INIT_FAILED = -2068, /**< module could not be loaded - init() failed */\n\tRS_RET_NO_SOCKET = -2069, /**< socket could not be obtained or was not provided */\n\tRS_RET_SMTP_ERROR = -2070, /**< error during SMTP transation */\n\tRS_RET_MAIL_NO_TO = -2071, /**< recipient for mail destination is missing */\n\tRS_RET_MAIL_NO_FROM = -2072, /**< sender for mail destination is missing */\n\tRS_RET_INVALID_PRI = -2073, /**< PRI value is invalid */\n\tRS_RET_MALICIOUS_HNAME = -2074, /**< remote peer is trying malicious things with its hostname */\n\tRS_RET_INVALID_HNAME = -2075, /**< remote peer's hostname invalid or unobtainable */\n\tRS_RET_INVALID_PORT = -2076, /**< invalid port value */\n\tRS_RET_COULD_NOT_BIND = -2077, /**< could not bind socket, defunct */\n\tRS_RET_GNUTLS_ERR = -2078, /**< (unexpected) error in GnuTLS call */\n\tRS_RET_MAX_SESS_REACHED = -2079, /**< max nbr of sessions reached, can not create more */\n\tRS_RET_MAX_LSTN_REACHED = -2080, /**< max nbr of listeners reached, can not create more */\n\tRS_RET_INVALID_DRVR_MODE = -2081, /**< tried to set mode not supported by driver */\n\tRS_RET_DRVRNAME_TOO_LONG = -2082, /**< driver name too long - should never happen */\n\tRS_RET_TLS_HANDSHAKE_ERR = -2083, /**< TLS handshake failed */\n\tRS_RET_TLS_CERT_ERR = -2084, /**< generic TLS certificate error */\n\tRS_RET_TLS_NO_CERT = -2085, /**< no TLS certificate available where one was expected */\n\tRS_RET_VALUE_NOT_SUPPORTED = -2086, /**< a provided value is not supported */\n\tRS_RET_VALUE_NOT_I...\n- msg_t: typedef struct msg msg_t;\n- rsRetVal: typedef enum rsRetVal_ rsRetVal;\n\nGlobal Variables:\n- prop_if_t prop\n\nImports:\n- #include \"datetime.h\"\n- #include \"glbl.h\"\n- #include \"atomic.h\"\n- #include <sys/socket.h>\n- #include \"rsyslog.h\"\n- #include \"unicode-helper.h\"\n- #  include <malloc.h>\n- #include \"net.h\"\n- #include \"regexp.h\"\n- #include \"srUtils.h\"\n- #include \"msg.h\"\n- #include <string.h>\n- #include \"prop.h\"\n- #include <netdb.h>\n- #include \"var.h\"\n- #include \"template.h\"\n- #include <stdarg.h>\n- #include <ctype.h>\n- #include \"stringbuf.h\"\n- #include \"config.h\"\n- #include <assert.h>\n- #include \"ruleset.h\"\n- #include <stdio.h>\n- #include <stdlib.h>",
    "commit_msg": "backporting abort condition fix from 5.7.7",
    "cve_desc": "A memory leak in rsyslog before 5.7.6 was found in the way deamon processed log messages are logged when $RepeatedMsgReduction was enabled. A local attacker could use this flaw to cause a denial of the rsyslogd daemon service by crashing the service via a sequence of repeated log messages sent within short periods of time.",
    "year": 2011,
    "filename": "msg.c",
    "commit_url": "\"https://github.com/rsyslog/rsyslog/commit/8083bd1433449fd2b1b79bf759f782e0f64c0cd2\""
  },
  {
    "repository": "rsyslog/rsyslog",
    "cve_id": "CVE-2011-1488",
    "cwe_list": [
      "CWE-772"
    ],
    "commit_hash": "dfa88369d4ca4290db56b843f9eabdae1bfe0fd5",
    "short_hash": "dfa88369",
    "vulnerableMethods_before": [
      {
        "filename": "runtime/queue.c",
        "method_name": "qAddDirect",
        "raw_code": "static rsRetVal qAddDirect(qqueue_t *pThis, void* pUsr) /* <=== qAddDirect */ \n{\n\tbatch_t singleBatch;\n\tbatch_obj_t batchObj;\n\tDEFiRet;\n\n\t//TODO: init batchObj (states _OK and new fields -- CHECK)\n\tASSERT(pThis != NULL);\n\n\t/* calling the consumer is quite different here than it is from a worker thread */\n\t/* we need to provide the consumer's return value back to the caller because in direct\n\t * mode the consumer probably has a lot to convey (which get's lost in the other modes\n\t * because they are asynchronous. But direct mode is deliberately synchronous.\n\t * rgerhards, 2008-02-12\n\t * We use our knowledge about the batch_t structure below, but without that, we\n\t * pay a too-large performance toll... -- rgerhards, 2009-04-22\n\t */\n\tmemset(&batchObj, 0, sizeof(batch_obj_t));\n\tmemset(&singleBatch, 0, sizeof(batch_t));\n\tbatchObj.state = BATCH_STATE_RDY;\n\tbatchObj.pUsrp = (obj_t*) pUsr;\n\tbatchObj.bFilterOK = 1;\n\tsingleBatch.nElem = 1; /* there always is only one in direct mode */\n\tsingleBatch.pElem = &batchObj;\n\tiRet = pThis->pConsumer(pThis->pUsr, &singleBatch, &pThis->bShutdownImmediate);\n\tobjDestruct(pUsr);\n\n\tRETiRet;\n}",
        "start_line": 838
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "runtime/queue.c",
        "method_name": "qAddDirect",
        "raw_code": "static rsRetVal qAddDirect(qqueue_t *pThis, void* pUsr) /* <=== qAddDirect */ \n{\n\tbatch_t singleBatch;\n\tbatch_obj_t batchObj;\n\tint i;\n\tDEFiRet;\n\n\t//TODO: init batchObj (states _OK and new fields -- CHECK)\n\tASSERT(pThis != NULL);\n\n\t/* calling the consumer is quite different here than it is from a worker thread */\n\t/* we need to provide the consumer's return value back to the caller because in direct\n\t * mode the consumer probably has a lot to convey (which get's lost in the other modes\n\t * because they are asynchronous. But direct mode is deliberately synchronous.\n\t * rgerhards, 2008-02-12\n\t * We use our knowledge about the batch_t structure below, but without that, we\n\t * pay a too-large performance toll... -- rgerhards, 2009-04-22\n\t */\n\tmemset(&batchObj, 0, sizeof(batch_obj_t));\n\tmemset(&singleBatch, 0, sizeof(batch_t));\n\tbatchObj.state = BATCH_STATE_RDY;\n\tbatchObj.pUsrp = (obj_t*) pUsr;\n\tbatchObj.bFilterOK = 1;\n\tsingleBatch.nElem = 1; /* there always is only one in direct mode */\n\tsingleBatch.pElem = &batchObj;\n\tiRet = pThis->pConsumer(pThis->pUsr, &singleBatch, &pThis->bShutdownImmediate);\n\t/* delete the batch string params: TODO: create its own \"class\" for this */\n\tfor(i = 0 ; i < CONF_OMOD_NUMSTRINGS_MAXSIZE ; ++i) {\n\t\tfree(batchObj.staticActStrings[i]);\n\t}\n\tobjDestruct(pUsr);\n\n\tRETiRet;\n}",
        "start_line": 838
      }
    ],
    "code_context": "Called Methods:\n- CONF_OMOD_NUMSTRINGS_MAXSIZE: #define CONF_OMOD_NUMSTRINGS_MAXSIZE\t2\t/* cache for pointers to output module buffer pointers. All /* <=== runtime/rsyslog.h:62:62:CONF_OMOD_NUMSTRINGS_MAXSIZE:0 */ \n\nType Definitions:\n- batch_obj_t: typedef struct batch_obj_s batch_obj_t;\n- rsRetVal: typedef enum rsRetVal_ rsRetVal;\n\nImports:\n- #include \"srUtils.h\"\n- #include <unistd.h>\n- #include \"atomic.h\"\n- #include <fcntl.h>\n- #include <string.h>\n- #include \"wti.h\"\n- #include \"unicode-helper.h\"\n- #include <stdio.h>\n- #include \"rsyslog.h\"\n- #\tinclude <sched.h>\n- #include <stdlib.h>\n- #include \"wtp.h\"\n- #include \"obj.h\"\n- #include \"errmsg.h\"\n- #include \"msg.h\"\n- #include <errno.h>\n- #include <signal.h>\n- #include <pthread.h>\n- #include <assert.h>\n- #include <sys/stat.h>\n- #include \"stringbuf.h\"\n- #include \"datetime.h\"\n- #include <time.h>\n- #include \"queue.h\"\n- #include \"config.h\"",
    "commit_msg": "bugfix: memory leak when $RepeatedMsgReduction on was used\n\nbug tracker: http://bugzilla.adiscon.com/show_bug.cgi?id=225",
    "cve_desc": "A memory leak in rsyslog before 5.7.6 was found in the way deamon processed log messages are logged when $RepeatedMsgReduction was enabled. A local attacker could use this flaw to cause a denial of the rsyslogd daemon service by crashing the service via a sequence of repeated log messages sent within short periods of time.",
    "year": 2011,
    "filename": "queue.c",
    "commit_url": "\"https://github.com/rsyslog/rsyslog/commit/dfa88369d4ca4290db56b843f9eabdae1bfe0fd5\""
  },
  {
    "repository": "xfce-mirror/thunar",
    "cve_id": "CVE-2011-1588",
    "cwe_list": [
      "CWE-134"
    ],
    "commit_hash": "03dd312e157d4fa8a11d5fa402706ae5b05806fa",
    "short_hash": "03dd312e",
    "vulnerableMethods_before": [
      {
        "filename": "thunar/thunar-transfer-job.c",
        "method_name": "thunar_transfer_job_copy_node",
        "raw_code": "static void /* <=== thunar_transfer_job_copy_node */ \nthunar_transfer_job_copy_node (ThunarTransferJob  *job,\n                               ThunarTransferNode *node,\n                               GFile              *target_file,\n                               GFile              *target_parent_file,\n                               GList             **target_file_list_return,\n                               GError            **error)\n{\n  ThunarThumbnailCache *thumbnail_cache;\n  ThunarApplication    *application;\n  ThunarJobResponse     response;\n  GFileInfo            *info;\n  GError               *err = NULL;\n  GFile                *real_target_file = NULL;\n  gchar                *base_name;\n\n  _thunar_return_if_fail (THUNAR_IS_TRANSFER_JOB (job));\n  _thunar_return_if_fail (node != NULL && G_IS_FILE (node->source_file));\n  _thunar_return_if_fail (target_file == NULL || node->next == NULL);\n  _thunar_return_if_fail ((target_file == NULL && target_parent_file != NULL) || (target_file != NULL && target_parent_file == NULL));\n  _thunar_return_if_fail (error == NULL || *error == NULL);\n\n  /* The caller can either provide a target_file or a target_parent_file, but not both. The toplevel\n   * transfer_nodes (for which next is NULL) should be called with target_file, to get proper behavior\n   * wrt restoring files from the trash. Other transfer_nodes will be called with target_parent_file.\n   */\n\n  /* take a reference on the thumbnail cache */\n  application = thunar_application_get ();\n  thumbnail_cache = thunar_application_get_thumbnail_cache (application);\n  g_object_unref (application);\n\n  for (; err == NULL && node != NULL; node = node->next)\n    {\n      /* guess the target file for this node (unless already provided) */\n      if (G_LIKELY (target_file == NULL))\n        {\n          base_name = g_file_get_basename (node->source_file);\n          target_file = g_file_get_child (target_parent_file, base_name);\n          g_free (base_name);\n        }\n      else\n        target_file = g_object_ref (target_file);\n\n      /* query file info */\n      info = g_file_query_info (node->source_file,\n                                G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME,\n                                G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                exo_job_get_cancellable (EXO_JOB (job)),\n                                &err);\n\n      /* abort on error or cancellation */\n      if (info == NULL)\n        {\n          g_object_unref (target_file);\n          break;\n        }\n\n      /* update progress information */\n      exo_job_info_message (EXO_JOB (job), g_file_info_get_display_name (info));\n\nretry_copy:\n      /* copy the item specified by this node (not recursively) */\n      real_target_file = thunar_transfer_job_copy_file (job, node->source_file, \n                                                        target_file, &err);\n      if (G_LIKELY (real_target_file != NULL))\n        {\n          /* node->source_file == real_target_file means to skip the file */\n          if (G_LIKELY (node->source_file != real_target_file))\n            {\n              /* notify the thumbnail cache of the copy operation */\n              thunar_thumbnail_cache_copy_file (thumbnail_cache, \n                                                node->source_file, \n                                                real_target_file);\n\n              /* check if we have children to copy */\n              if (node->children != NULL)\n                {\n                  /* copy all children of this node */\n                  thunar_transfer_job_copy_node (job, node->children, NULL, real_target_file, NULL, &err);\n\n                  /* free resources allocted for the children */\n                  thunar_transfer_node_free (node->children);\n                  node->children = NULL;\n                }\n\n              /* check if the child copy failed */\n              if (G_UNLIKELY (err != NULL))\n                {\n                  /* outa here, freeing the target paths */\n                  g_object_unref (real_target_file);\n                  g_object_unref (target_file);\n                  break;\n                }\n\n              /* add the real target file to the return list */\n              if (G_LIKELY (target_file_list_return != NULL))\n                {\n                  *target_file_list_return = \n                    thunar_g_file_list_prepend (*target_file_list_return, \n                                                real_target_file);\n                }\n\nretry_remove:\n              /* try to remove the source directory if we are on copy+remove fallback for move */\n              if (job->type == THUNAR_TRANSFER_JOB_MOVE)\n                {\n                  if (g_file_delete (node->source_file, \n                                     exo_job_get_cancellable (EXO_JOB (job)), \n                                     &err))\n                    {\n                      /* notify the thumbnail cache of the delete operation */\n                      thunar_thumbnail_cache_delete_file (thumbnail_cache, \n                                                          node->source_file);\n                    }\n                  else\n                    {\n                      /* ask the user to retry */\n                      response = thunar_job_ask_skip (THUNAR_JOB (job), \"%s\", \n                                                      err->message);\n\n                      /* reset the error */\n                      g_clear_error (&err);\n\n                      /* check whether to retry */\n                      if (G_UNLIKELY (response == THUNAR_JOB_RESPONSE_RETRY))\n                        goto retry_remove;\n                    }\n                }\n            }\n\n          g_object_unref (real_target_file);\n        }\n      else if (err != NULL)\n        { \n          /* we can only skip if there is space left on the device */\n          if (err->domain != G_IO_ERROR || err->code != G_IO_ERROR_NO_SPACE) \n            {\n              /* ask the user to skip this node and all subnodes */\n              response = thunar_job_ask_skip (THUNAR_JOB (job), \"%s\", err->message);\n\n              /* reset the error */\n              g_clear_error (&err);\n\n              /* check whether to retry */\n              if (G_UNLIKELY (response == THUNAR_JOB_RESPONSE_RETRY))\n                goto retry_copy;\n            }\n        }\n\n      /* release the guessed target file */\n      g_object_unref (target_file);\n      target_file = NULL;\n\n      /* release file info */\n      g_object_unref (info);\n    }\n\n  /* release the thumbnail cache */\n  g_object_unref (thumbnail_cache);\n\n  /* propagate error if we failed or the job was cancelled */\n  if (G_UNLIKELY (err != NULL))\n    g_propagate_error (error, err);\n}",
        "start_line": 478
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "thunar/thunar-transfer-job.c",
        "method_name": "thunar_transfer_job_copy_node",
        "raw_code": "static void /* <=== thunar_transfer_job_copy_node */ \nthunar_transfer_job_copy_node (ThunarTransferJob  *job,\n                               ThunarTransferNode *node,\n                               GFile              *target_file,\n                               GFile              *target_parent_file,\n                               GList             **target_file_list_return,\n                               GError            **error)\n{\n  ThunarThumbnailCache *thumbnail_cache;\n  ThunarApplication    *application;\n  ThunarJobResponse     response;\n  GFileInfo            *info;\n  GError               *err = NULL;\n  GFile                *real_target_file = NULL;\n  gchar                *base_name;\n\n  _thunar_return_if_fail (THUNAR_IS_TRANSFER_JOB (job));\n  _thunar_return_if_fail (node != NULL && G_IS_FILE (node->source_file));\n  _thunar_return_if_fail (target_file == NULL || node->next == NULL);\n  _thunar_return_if_fail ((target_file == NULL && target_parent_file != NULL) || (target_file != NULL && target_parent_file == NULL));\n  _thunar_return_if_fail (error == NULL || *error == NULL);\n\n  /* The caller can either provide a target_file or a target_parent_file, but not both. The toplevel\n   * transfer_nodes (for which next is NULL) should be called with target_file, to get proper behavior\n   * wrt restoring files from the trash. Other transfer_nodes will be called with target_parent_file.\n   */\n\n  /* take a reference on the thumbnail cache */\n  application = thunar_application_get ();\n  thumbnail_cache = thunar_application_get_thumbnail_cache (application);\n  g_object_unref (application);\n\n  for (; err == NULL && node != NULL; node = node->next)\n    {\n      /* guess the target file for this node (unless already provided) */\n      if (G_LIKELY (target_file == NULL))\n        {\n          base_name = g_file_get_basename (node->source_file);\n          target_file = g_file_get_child (target_parent_file, base_name);\n          g_free (base_name);\n        }\n      else\n        target_file = g_object_ref (target_file);\n\n      /* query file info */\n      info = g_file_query_info (node->source_file,\n                                G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME,\n                                G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                exo_job_get_cancellable (EXO_JOB (job)),\n                                &err);\n\n      /* abort on error or cancellation */\n      if (info == NULL)\n        {\n          g_object_unref (target_file);\n          break;\n        }\n\n      /* update progress information */\n      exo_job_info_message (EXO_JOB (job), \"%s\", g_file_info_get_display_name (info));\n\nretry_copy:\n      /* copy the item specified by this node (not recursively) */\n      real_target_file = thunar_transfer_job_copy_file (job, node->source_file, \n                                                        target_file, &err);\n      if (G_LIKELY (real_target_file != NULL))\n        {\n          /* node->source_file == real_target_file means to skip the file */\n          if (G_LIKELY (node->source_file != real_target_file))\n            {\n              /* notify the thumbnail cache of the copy operation */\n              thunar_thumbnail_cache_copy_file (thumbnail_cache, \n                                                node->source_file, \n                                                real_target_file);\n\n              /* check if we have children to copy */\n              if (node->children != NULL)\n                {\n                  /* copy all children of this node */\n                  thunar_transfer_job_copy_node (job, node->children, NULL, real_target_file, NULL, &err);\n\n                  /* free resources allocted for the children */\n                  thunar_transfer_node_free (node->children);\n                  node->children = NULL;\n                }\n\n              /* check if the child copy failed */\n              if (G_UNLIKELY (err != NULL))\n                {\n                  /* outa here, freeing the target paths */\n                  g_object_unref (real_target_file);\n                  g_object_unref (target_file);\n                  break;\n                }\n\n              /* add the real target file to the return list */\n              if (G_LIKELY (target_file_list_return != NULL))\n                {\n                  *target_file_list_return = \n                    thunar_g_file_list_prepend (*target_file_list_return, \n                                                real_target_file);\n                }\n\nretry_remove:\n              /* try to remove the source directory if we are on copy+remove fallback for move */\n              if (job->type == THUNAR_TRANSFER_JOB_MOVE)\n                {\n                  if (g_file_delete (node->source_file, \n                                     exo_job_get_cancellable (EXO_JOB (job)), \n                                     &err))\n                    {\n                      /* notify the thumbnail cache of the delete operation */\n                      thunar_thumbnail_cache_delete_file (thumbnail_cache, \n                                                          node->source_file);\n                    }\n                  else\n                    {\n                      /* ask the user to retry */\n                      response = thunar_job_ask_skip (THUNAR_JOB (job), \"%s\", \n                                                      err->message);\n\n                      /* reset the error */\n                      g_clear_error (&err);\n\n                      /* check whether to retry */\n                      if (G_UNLIKELY (response == THUNAR_JOB_RESPONSE_RETRY))\n                        goto retry_remove;\n                    }\n                }\n            }\n\n          g_object_unref (real_target_file);\n        }\n      else if (err != NULL)\n        { \n          /* we can only skip if there is space left on the device */\n          if (err->domain != G_IO_ERROR || err->code != G_IO_ERROR_NO_SPACE) \n            {\n              /* ask the user to skip this node and all subnodes */\n              response = thunar_job_ask_skip (THUNAR_JOB (job), \"%s\", err->message);\n\n              /* reset the error */\n              g_clear_error (&err);\n\n              /* check whether to retry */\n              if (G_UNLIKELY (response == THUNAR_JOB_RESPONSE_RETRY))\n                goto retry_copy;\n            }\n        }\n\n      /* release the guessed target file */\n      g_object_unref (target_file);\n      target_file = NULL;\n\n      /* release file info */\n      g_object_unref (info);\n    }\n\n  /* release the thumbnail cache */\n  g_object_unref (thumbnail_cache);\n\n  /* propagate error if we failed or the job was cancelled */\n  if (G_UNLIKELY (err != NULL))\n    g_propagate_error (error, err);\n}",
        "start_line": 478
      }
    ],
    "code_context": "Called Methods:\n- thunar_thumbnail_cache_copy_file: void /* <=== thunar_thumbnail_cache_copy_file */ \nthunar_thumbnail_cache_copy_file (ThunarThumbnailCache *cache,\n                                  GFile                *source_file,\n                                  GFile                *target_file)\n{\n  _thunar_return_if_fail (THUNAR_IS_THUMBNAIL_CACHE (cache));\n  _thunar_return_if_fail (G_IS_FILE (source_file));\n  _thunar_return_if_fail (G_IS_FILE (target_file));\n\n#ifdef HAVE_DBUS\n  /* acquire a cache lock */\n  g_mutex_lock (cache->lock);\n\n  /* check if we have a valid proxy for the cache service */\n  if (cache->cache_proxy != NULL)\n    {\n      /* cancel any pending timeout to process the copy queue */\n      if (cache->copy_queue_idle_id > 0)\n        {\n          g_source_remove (cache->copy_queue_idle_id);\n          cache->copy_queue_idle_id = 0;\n        }\n\n      /* add the files to the copy queues */\n      cache->copy_source_queue = g_list_prepend (cache->copy_source_queue, \n                                                 g_object_ref (source_file));\n      cache->copy_target_queue = g_list_prepend (cache->copy_target_queue,\n                                                 g_object_ref (target_file));\n\n      /* process the copy queue in a 250ms timeout */\n      cache->copy_queue_idle_id =\n        g_timeout_add (500, (GSourceFunc) thunar_thumbnail_cache_process_copy_queue,\n                       cache);\n    }\n\n  /* release the cache lock */\n  g_mutex_unlock (cache->lock);\n#endif\n}\n- _thunar_job_ask_valist: static ThunarJobResponse /* <=== _thunar_job_ask_valist */ \n_thunar_job_ask_valist (ThunarJob        *job,\n                        const gchar      *format,\n                        va_list           var_args,\n                        const gchar      *question,\n                        ThunarJobResponse choices)\n{\n  ThunarJobResponse response;\n  gchar            *text;\n  gchar            *message;\n\n  _thunar_return_val_if_fail (THUNAR_IS_JOB (job), THUNAR_JOB_RESPONSE_CANCEL);\n  _thunar_return_val_if_fail (g_utf8_validate (format, -1, NULL), THUNAR_JOB_RESPONSE_CANCEL);\n  \n  /* generate the dialog message */\n  text = g_strdup_vprintf (format, var_args);\n  message = (question != NULL) \n            ? g_strconcat (text, \".\\n\\n\", question, NULL) \n            : g_strconcat (text, \".\", NULL);\n  g_free (text);  \n\n  /* send the question and wait for the answer */\n  exo_job_emit (EXO_JOB (job), job_signals[ASK], 0, message, choices, &response);\n  g_free (message);\n\n  /* cancel the job as per users request */\n  if (G_UNLIKELY (response == THUNAR_JOB_RESPONSE_CANCEL))\n    exo_job_cancel (EXO_JOB (job));\n\n  return response;\n}\n- thunar_job_ask_replace: ThunarJobResponse  /* <=== thunar_job_ask_replace */ \nthunar_job_ask_replace (ThunarJob *job,\n                        GFile     *source_path,\n                        GFile     *target_path,\n                        GError   **error)\n{\n  ThunarJobResponse response;\n  ThunarFile       *source_file;\n  ThunarFile       *target_file;\n\n  _thunar_return_val_if_fail (THUNAR_IS_JOB (job), THUNAR_JOB_RESPONSE_CANCEL);\n  _thunar_return_val_if_fail (G_IS_FILE (source_path), THUNAR_JOB_RESPONSE_CANCEL);\n  _thunar_return_val_if_fail (G_IS_FILE (target_path), THUNAR_JOB_RESPONSE_CANCEL);\n\n  if (G_UNLIKELY (exo_job_set_error_if_cancelled (EXO_JOB (job), error)))\n    return THUNAR_JOB_RESPONSE_CANCEL;\n\n  /* check if the user said \"Overwrite All\" earlier */\n  if (G_UNLIKELY (job->priv->earlier_ask_overwrite_response == THUNAR_JOB_RESPONSE_YES_ALL))\n    return THUNAR_JOB_RESPONSE_YES;\n\n  /* check if the user said \"Overwrite None\" earlier */\n  if (G_UNLIKELY (job->priv->earlier_ask_overwrite_response == THUNAR_JOB_RESPONSE_NO_ALL))\n    return THUNAR_JOB_RESPONSE_NO;\n\n  source_file = thunar_file_get (source_path, error);\n\n  if (G_UNLIKELY (source_file == NULL))\n    return THUNAR_JOB_RESPONSE_NO;\n\n  target_file = thunar_file_get (target_path, error);\n\n  if (G_UNLIKELY (target_file == NULL))\n    {\n      g_object_unref (source_file);\n      return THUNAR_JOB_RESPONSE_NO;\n    }\n\n  exo_job_emit (EXO_JOB (job), job_signals[ASK_REPLACE], 0, \n                source_file, target_file, &response);\n\n  g_object_unref (source_file);\n  g_object_unref (target_file);\n\n  /* remember the response for later */\n  job->priv->earlier_ask_overwrite_response = response;\n\n  /* translate the response */\n  if (response == THUNAR_JOB_RESPONSE_YES_ALL)\n    response = THUNAR_JOB_RESPONSE_YES;\n  else if (response == THUNAR_JOB_RESPONSE_NO_ALL)\n    response = THUNAR_JOB_RESPONSE_NO;\n  else if (response == THUNAR_JOB_RESPONSE_CANCEL)\n    exo_job_cancel (EXO_JOB (job));\n\n  return response;\n}\n- thunar_transfer_job_copy_file: static GFile * /* <=== thunar_transfer_job_copy_file */ \nthunar_transfer_job_copy_file (ThunarTransferJob *job,\n                               GFile             *source_file,\n                               GFile             *target_file,\n                               GError           **error)\n{\n  ThunarJobResponse response;\n  GFileCopyFlags    copy_flags = G_FILE_COPY_NOFOLLOW_SYMLINKS;\n  GError           *err = NULL;\n  gint              n;\n\n  _thunar_return_val_if_fail (THUNAR_IS_TRANSFER_JOB (job), NULL);\n  _thunar_return_val_if_fail (G_IS_FILE (source_file), NULL);\n  _thunar_return_val_if_fail (G_IS_FILE (target_file), NULL);\n  _thunar_return_val_if_fail (error == NULL || *error == NULL, NULL);\n\n  /* abort on cancellation */\n  if (exo_job_set_error_if_cancelled (EXO_JOB (job), error))\n    return NULL;\n\n  /* various attempts to copy the file */\n  while (err == NULL)\n    {\n      if (G_LIKELY (!g_file_equal (source_file, target_file)))\n        {\n          /* try to copy the file from source_file to the target_file */\n          if (ttj_copy_file (job, source_file, target_file, copy_flags, TRUE, &err))\n            {\n              /* return the real target file */\n              return g_object_ref (target_file);\n            }\n        }\n      else\n        {\n          for (n = 1; err == NULL; ++n)\n            {\n              GFile *duplicate_file = thunar_io_jobs_util_next_duplicate_file (THUNAR_JOB (job),\n                                                                               source_file, \n                                                                               TRUE, n, \n                                                                               &err);\n\n              if (err == NULL)\n                {\n                  /* try to copy the file from source file to the duplicate file */\n                  if (ttj_copy_file (job, source_file, duplicate_file, copy_flags, TRUE, &err))\n                    {\n                      /* return the real target file */\n                      return duplicate_file;\n                    }\n                  \n                  g_object_unref (duplicate_file);\n                }\n\n              if (err != NULL && err->domain == G_IO_ERROR && err->code == G_IO_ERROR_EXISTS)\n                {\n                  /* this duplicate already exists => clear the error to try the next alternative */\n                  g_clear_error (&err);\n                }\n            }\n        }\n\n      /* check if we can recover from this error */\n      if (err->domain == G_IO_ERROR && err->code == G_IO_ERROR_EXISTS)\n        {\n          /* reset the error */\n          g_clear_error (&err);\n\n          /* ask the user whether to replace the target file */\n          response = thunar_job_ask_replace (THUNAR_JOB (job), source_file, \n                                             target_file, &err);\n\n          if (err != NULL)\n            break;\n\n          /* check if we should retry */\n          if (response == THUNAR_JOB_RESPONSE_RETRY)\n            continue;\n\n          /* add overwrite flag and retry if we should overwrite */\n          if (response == THUNAR_JOB_RESPONSE_YES)\n            {\n              copy_flags |= G_FILE_COPY_OVERWRITE;\n              continue;\n            }\n\n          /* tell the caller we skipped the file if the user \n           * doesn't want to retry/overwrite */\n          if (response == THUNAR_JOB_RESPONSE_NO)\n            return g_object_ref (source_file);\n        }\n    }\n\n  _thunar_assert (err != NULL);\n\n  g_propagate_error (error, err);\n  return NULL;\n}\n- thunar_g_file_list_prepend: GList * /* <=== thunar_g_file_list_prepend */ \nthunar_g_file_list_prepend (GList *list,\n                            GFile *file)\n{\n  return g_list_prepend (list, g_object_ref (file));\n}\n- thunar_application_get: ThunarApplication* /* <=== thunar_application_get */ \nthunar_application_get (void)\n{\n  static ThunarApplication *application = NULL;\n\n  if (G_UNLIKELY (application == NULL))\n    {\n      application = g_object_new (THUNAR_TYPE_APPLICATION, NULL);\n      g_object_add_weak_pointer (G_OBJECT (application), (gpointer) &application);\n    }\n  else\n    {\n      g_object_ref (G_OBJECT (application));\n    }\n\n  return application;\n}\n- thunar_thumbnail_cache_delete_file: void /* <=== thunar_thumbnail_cache_delete_file */ \nthunar_thumbnail_cache_delete_file (ThunarThumbnailCache *cache,\n                                    GFile                *file)\n{\n  _thunar_return_if_fail (THUNAR_IS_THUMBNAIL_CACHE (cache));\n  _thunar_return_if_fail (G_IS_FILE (file));\n\n#ifdef HAVE_DBUS\n  /* acquire a cache lock */\n  g_mutex_lock (cache->lock);\n\n  /* check if we have a valid proxy for the cache service */\n  if (cache->cache_proxy)\n    {\n      /* cancel any pending timeout to process the delete queue */\n      if (cache->delete_queue_idle_id > 0)\n        {\n          g_source_remove (cache->delete_queue_idle_id);\n          cache->delete_queue_idle_id = 0;\n        }\n\n      /* add the file to the delete queue */\n      cache->delete_queue = g_list_prepend (cache->delete_queue, g_object_ref (file));\n\n      /* process the delete queue in a 250ms timeout */\n      cache->delete_queue_idle_id = \n        g_timeout_add (500, (GSourceFunc) thunar_thumbnail_cache_process_delete_queue, \n                       cache);\n    }\n\n  /* release the cache lock */\n  g_mutex_unlock (cache->lock);\n#endif\n}\n- thunar_io_jobs_util_next_duplicate_file: GFile * /* <=== thunar_io_jobs_util_next_duplicate_file */ \nthunar_io_jobs_util_next_duplicate_file (ThunarJob *job,\n                                         GFile     *file,\n                                         gboolean   copy,\n                                         guint      n,\n                                         GError   **error)\n{\n  GFileInfo *info;\n  GError    *err = NULL;\n  GFile     *duplicate_file = NULL;\n  GFile     *parent_file = NULL;\n  gchar     *display_name;\n  gint       type_index;\n  gint       name_index;\n  \n  _thunar_return_val_if_fail (THUNAR_IS_JOB (job), NULL);\n  _thunar_return_val_if_fail (G_IS_FILE (file), NULL);\n  _thunar_return_val_if_fail (0 < n, NULL);\n  _thunar_return_val_if_fail (error == NULL || *error == NULL, NULL);\n  _thunar_return_val_if_fail (!thunar_g_file_is_root (file), NULL);\n\n  /* abort on cancellation */\n  if (exo_job_set_error_if_cancelled (EXO_JOB (job), error))\n    return NULL;\n\n  /* query the source file info / display name */\n  info = g_file_query_info (file, G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME, \n                            G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                            exo_job_get_cancellable (EXO_JOB (job)), &err);\n\n  /* abort on error */\n  if (info == NULL)\n    {\n      g_propagate_error (error, err);\n      return NULL;\n    }\n\n  /* determine the type index (copy = 0, link = 1) */\n  type_index = (copy ? 0 : 1);\n\n  /* make sure the name index is not out of bounds */\n  name_index = MIN (n-1, G_N_ELEMENTS (duplicate_names)-1);\n  \n  /* generate the display name for the nth copy/link of the source file */\n  if (name_index < (gint) G_N_ELEMENTS (duplicate_names)-1)\n    {\n      display_name = g_strdup_printf (gettext (duplicate_names[name_index][type_index]),\n                                      g_file_info_get_display_name (info));\n    }\n  else\n    {\n      display_name = g_strdup_printf (gettext (duplicate_names[name_index][type_index]),\n                                      n, g_file_info_get_display_name (info));\n    }\n\n  /* create the GFile for the copy/link */\n  parent_file = g_file_get_parent (file);\n  duplicate_file = g_file_get_child (parent_file, display_name);\n  g_object_unref (parent_file);\n\n  /* free resources */\n  g_object_unref (info);\n  g_free (display_name);\n\n  return duplicate_file;\n}\n- thunar_job_ask_skip: ThunarJobResponse  /* <=== thunar_job_ask_skip */ \nthunar_job_ask_skip (ThunarJob   *job,\n                     const gchar *format,\n                     ...)\n{\n  ThunarJobResponse response;\n  va_list           var_args;\n  \n  _thunar_return_val_if_fail (THUNAR_IS_JOB (job), THUNAR_JOB_RESPONSE_CANCEL);\n  _thunar_return_val_if_fail (format != NULL, THUNAR_JOB_RESPONSE_CANCEL);\n\n  /* check if the user already cancelled the job */\n  if (G_UNLIKELY (exo_job_is_cancelled (EXO_JOB (job))))\n    return THUNAR_JOB_RESPONSE_CANCEL;\n\n  /* check if the user said \"Skip All\" earlier */\n  if (G_UNLIKELY (job->priv->earlier_ask_skip_response == THUNAR_JOB_RESPONSE_YES_ALL))\n    return THUNAR_JOB_RESPONSE_YES;\n\n  /* ask the user what he wants to do */\n  va_start (var_args, format);\n  response = _thunar_job_ask_valist (job, format, var_args,\n                                     _(\"Do you want to skip it?\"),\n                                     THUNAR_JOB_RESPONSE_YES \n                                     | THUNAR_JOB_RESPONSE_YES_ALL\n                                     | THUNAR_JOB_RESPONSE_CANCEL\n                                     | THUNAR_JOB_RESPONSE_RETRY);\n  va_end (var_args);\n\n  /* remember the response */\n  job->priv->earlier_ask_skip_response = response;\n\n  /* translate the response */\n  switch (response)\n    {\n    case THUNAR_JOB_RESPONSE_YES_ALL:\n      response = THUNAR_JOB_RESPONSE_YES;\n      break;\n\n    case THUNAR_JOB_RESPONSE_YES:\n    case THUNAR_JOB_RESPONSE_CANCEL:\n    case THUNAR_JOB_RESPONSE_RETRY:\n      break;\n\n    default:\n      _thunar_assert_not_reached ();\n    }\n\n  return response;\n}\n- thunar_transfer_node_free: static void /* <=== thunar_transfer_node_free */ \nthunar_transfer_node_free (ThunarTransferNode *node)\n{\n  ThunarTransferNode *next;\n\n  /* free all nodes in a row */\n  while (node != NULL)\n    {\n      /* free all children of this node */\n      thunar_transfer_node_free (node->children);\n\n      /* determine the next node */\n      next = node->next;\n\n      /* drop the source file of this node */\n      g_object_unref (node->source_file);\n\n      /* release the resources of this node */\n      g_slice_free (ThunarTransferNode, node);\n\n      /* continue with the next node */\n      node = next;\n    }\n}\n- ttj_copy_file: static gboolean /* <=== ttj_copy_file */ \nttj_copy_file (ThunarTransferJob *job,\n               GFile             *source_file,\n               GFile             *target_file,\n               GFileCopyFlags     copy_flags,\n               gboolean           merge_directories,\n               GError           **error)\n{\n  GFileType source_type;\n  GFileType target_type;\n  gboolean  target_exists;\n  GError   *err = NULL;\n\n  _thunar_return_val_if_fail (THUNAR_IS_TRANSFER_JOB (job), FALSE);\n  _thunar_return_val_if_fail (G_IS_FILE (source_file), FALSE);\n  _thunar_return_val_if_fail (G_IS_FILE (target_file), FALSE);\n  _thunar_return_val_if_fail (error == NULL || *error == NULL, FALSE);\n\n  /* reset the file progress */\n  job->file_progress = 0;\n\n  if (exo_job_set_error_if_cancelled (EXO_JOB (job), error))\n    return FALSE;\n\n  source_type = g_file_query_file_type (source_file, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                        exo_job_get_cancellable (EXO_JOB (job)));\n\n  if (exo_job_set_error_if_cancelled (EXO_JOB (job), error))\n    return FALSE;\n\n  target_type = g_file_query_file_type (target_file, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                        exo_job_get_cancellable (EXO_JOB (job)));\n\n  if (exo_job_set_error_if_cancelled (EXO_JOB (job), error))\n    return FALSE;\n\n  /* check if the target is a symlink and we are in overwrite mode */\n  if (target_type == G_FILE_TYPE_SYMBOLIC_LINK && (copy_flags & G_FILE_COPY_OVERWRITE) != 0)\n    {\n      /* try to delete the symlink */\n      if (!g_file_delete (target_file, exo_job_get_cancellable (EXO_JOB (job)), &err))\n        {\n          g_propagate_error (error, err);\n          return FALSE;\n        }\n    }\n\n  /* try to copy the file */\n  g_file_copy (source_file, target_file, copy_flags,\n               exo_job_get_cancellable (EXO_JOB (job)),\n               thunar_transfer_job_progress, job, &err);\n\n  /* check if there were errors */\n  if (G_UNLIKELY (err != NULL && err->domain == G_IO_ERROR))\n    {\n      if (err->code == G_IO_ERROR_WOULD_MERGE \n          || (err->code == G_IO_ERROR_EXISTS \n              && source_type == G_FILE_TYPE_DIRECTORY\n              && target_type == G_FILE_TYPE_DIRECTORY))\n        {\n          /* we tried to overwrite a directory with a directory. this normally results \n           * in a merge. ignore the error if we actually *want* to merge */\n          if (merge_directories)\n            g_clear_error (&err);\n        }\n      else if (err->code == G_IO_ERROR_WOULD_RECURSE)\n        {\n          g_clear_error (&err);\n\n          /* we tried to copy a directory and either \n           *\n           * - the target did not exist which means we simple have to \n           *   create the target directory\n           *\n           * or\n           *\n           * - the target is not a directory and we tried to overwrite it in \n           *   which case we have to delete it first and then create the target\n           *   directory\n           */\n\n          /* check if the target file exists */\n          target_exists = g_file_query_exists (target_file,\n                                               exo_job_get_cancellable (EXO_JOB (job)));\n\n          /* abort on cancellation, continue otherwise */\n          if (!exo_job_set_error_if_cancelled (EXO_JOB (job), &err))\n            {\n              if (target_exists)\n                {\n                  /* the target still exists and thus is not a directory. try to remove it */\n                  g_file_delete (target_file, \n                                 exo_job_get_cancellable (EXO_JOB (job)), \n                                 &err);\n                }\n\n              /* abort on error or cancellation, continue otherwise */\n              if (err == NULL)\n                {\n                  /* now try to create the directory */\n                  g_file_make_directory (target_file, \n                                         exo_job_get_cancellable (EXO_JOB (job)), \n                                         &err);\n                }\n            }\n        }\n    }\n\n  if (G_UNLIKELY (err != NULL))\n    {\n      g_propagate_error (error, err);\n      return FALSE;\n    }\n  else\n    {\n      return TRUE;\n    }\n}\n- thunar_application_get_thumbnail_cache: ThunarThumbnailCache * /* <=== thunar_application_get_thumbnail_cache */ \nthunar_application_get_thumbnail_cache (ThunarApplication *application)\n{\n  _thunar_return_val_if_fail (THUNAR_IS_APPLICATION (application), NULL);\n  return g_object_ref (application->thumbnail_cache);\n}\n\nType Definitions:\n- ThunarTransferNode: typedef struct _ThunarTransferNode ThunarTransferNode;\n- ThunarJobResponse: typedef enum /*< flags >*/\n{\n  THUNAR_JOB_RESPONSE_YES     = 1 << 0,\n  THUNAR_JOB_RESPONSE_YES_ALL = 1 << 1,\n  THUNAR_JOB_RESPONSE_NO      = 1 << 2,\n  THUNAR_JOB_RESPONSE_CANCEL  = 1 << 3,\n  THUNAR_JOB_RESPONSE_NO_ALL  = 1 << 4,\n  THUNAR_JOB_RESPONSE_RETRY   = 1 << 5,\n}\n- ThunarThumbnailCache: typedef struct _ThunarThumbnailCache        ThunarThumbnailCache;\n- ThunarTransferJob: typedef struct _ThunarTransferJob        ThunarTransferJob;\n\nImports:\n- #include <thunar/thunar-thumbnail-cache.h>\n- #include <config.h>\n- #include <thunar/thunar-private.h>\n- #include <thunar/thunar-application.h>\n- #include <thunar/thunar-io-scan-directory.h>\n- #include <thunar/thunar-transfer-job.h>\n- #include <thunar/thunar-job.h>\n- #include <thunar/thunar-io-jobs-util.h>\n- #include <gio/gio.h>\n- #include <thunar/thunar-gio-extensions.h>",
    "commit_msg": "Don't interpret file display names as format strings\n\nThis avoids a segfault when copying/moving files containing \"%\" formatters\nin their name.\n\nSigned-off-by: Jannis Pohlmann <jannis@xfce.org>",
    "cve_desc": "[{'lang': 'en', 'value': 'Thunar before 1.3.1 could crash when copy and pasting a file name with % format characters due to a format string error.'}]",
    "year": 2011,
    "filename": "thunar-transfer-job.c",
    "commit_url": "\"https://github.com/xfce-mirror/thunar/commit/03dd312e157d4fa8a11d5fa402706ae5b05806fa\""
  },
  {
    "repository": "karelzak/util-linux",
    "cve_id": "CVE-2011-1675",
    "cwe_list": [
      "CWE-399"
    ],
    "commit_hash": "11b51a46bfd3c340df251b2d20fe9d04d077a88e",
    "short_hash": "11b51a46",
    "vulnerableMethods_before": [
      {
        "filename": "mount/umount.c",
        "method_name": "umount_one",
        "raw_code": "static int /* <=== umount_one */ \numount_one (const char *spec, const char *node, const char *type,\n\t    const char *opts, struct mntentchn *mc) {\n\tint umnt_err = 0;\n\tint isroot;\n\tint res = 0;\n\tint status;\n\tint extra_flags = 0;\n\tconst char *loopdev, *target = node;\n\tchar *targetbuf = NULL;\n\tint myloop = 0;\n\n\t/* Special case for root.  As of 0.99pl10 we can (almost) unmount root;\n\t   the kernel will remount it readonly so that we can carry on running\n\t   afterwards.  The readonly remount is illegal if any files are opened\n\t   for writing at the time, so we can't update mtab for an unmount of\n\t   root.  As it is only really a remount, this doesn't matter too\n\t   much.  [sct May 29, 1993] */\n\tisroot = (streq (node, \"/\") || streq (node, \"root\")\n\t\t  || streq (node, \"rootfs\"));\n\tif (isroot)\n\t\tnomtab++;\n\n\t/*\n\t * Call umount.TYPE for types that require a separate umount program.\n\t * All such special things must occur isolated in the types string.\n\t */\n\tif (check_special_umountprog(spec, node, type, &status))\n\t\treturn status;\n\n\t/* Skip the actual umounting for --fake */\n\tif (fake)\n\t\tgoto writemtab;\n\t/*\n\t * Ignore the option \"-d\" for non-loop devices and loop devices with\n\t * LO_FLAGS_AUTOCLEAR flag.\n\t */\n\tif (delloop && is_loop_device(spec))\n\t\tmyloop = 1;\n\n\tif (restricted) {\n\t\tif (umount_nofollow_support())\n\t\t\textra_flags |= UMOUNT_NOFOLLOW;\n\n\t\t/* call umount(2) with relative path to avoid races */\n\t\ttarget = chdir_to_parent(node, &targetbuf);\n\t}\n\n\tif (lazy) {\n\t\tres = umount2 (target, MNT_DETACH | extra_flags);\n\t\tif (res < 0)\n\t\t\tumnt_err = errno;\n\t\tgoto writemtab;\n\t}\n\n\tif (force) {\t\t/* only supported for NFS */\n\t\tres = umount2 (target, MNT_FORCE | extra_flags);\n\t\tif (res == -1) {\n\t\t\tint errsv = errno;\n\t\t\tperror(\"umount2\");\n\t\t\terrno = errsv;\n\t\t\tif (errno == ENOSYS) {\n\t\t\t\tif (verbose)\n\t\t\t\t\tprintf(_(\"no umount2, trying umount...\\n\"));\n\t\t\t\tres = umount (target);\n\t\t\t}\n\t\t}\n\t} else if (extra_flags)\n\t\tres = umount2 (target, extra_flags);\n\telse\n\t\tres = umount (target);\n\n\tfree(targetbuf);\n\n\tif (res < 0)\n\t\tumnt_err = errno;\n\n\tif (res < 0 && remount && umnt_err == EBUSY) {\n\t\t/* Umount failed - let us try a remount */\n\t\tres = mount(spec, node, NULL,\n\t\t\t    MS_MGC_VAL | MS_REMOUNT | MS_RDONLY, NULL);\n\t\tif (res == 0) {\n\t\t\tfprintf(stderr,\n\t\t\t\t_(\"umount: %s busy - remounted read-only\\n\"),\n\t\t\t\tspec);\n\t\t\tif (mc && !nomtab) {\n\t\t\t\t/* update mtab if the entry is there */\n\t\t\t\tstruct my_mntent remnt;\n\t\t\t\tremnt.mnt_fsname = mc->m.mnt_fsname;\n\t\t\t\tremnt.mnt_dir = mc->m.mnt_dir;\n\t\t\t\tremnt.mnt_type = mc->m.mnt_type;\n\t\t\t\tremnt.mnt_opts = \"ro\";\n\t\t\t\tremnt.mnt_freq = 0;\n\t\t\t\tremnt.mnt_passno = 0;\n\t\t\t\tupdate_mtab(node, &remnt);\n\t\t\t}\n\t\t\treturn 0;\n\t\t} else if (errno != EBUSY) { \t/* hmm ... */\n\t\t\tperror(\"remount\");\n\t\t\tfprintf(stderr,\n\t\t\t\t_(\"umount: could not remount %s read-only\\n\"),\n\t\t\t\tspec);\n\t\t}\n\t}\n\n\tloopdev = 0;\n\tif (res >= 0) {\n\t\t/* Umount succeeded */\n\t\tif (verbose)\n\t\t\tprintf (_(\"%s has been unmounted\\n\"), spec);\n\n\t\t/* Free any loop devices that we allocated ourselves */\n\t\tif (mc) {\n\t\t\tchar *optl;\n\n\t\t\t/* old style mtab line? */\n\t\t\tif (streq(mc->m.mnt_type, \"loop\")) {\n\t\t\t\tloopdev = spec;\n\t\t\t\tgoto gotloop;\n\t\t\t}\n\n\t\t\t/* new style mtab line? */\n\t\t\toptl = mc->m.mnt_opts ? xstrdup(mc->m.mnt_opts) : \"\";\n\t\t\tfor (optl = strtok (optl, \",\"); optl;\n\t\t\t     optl = strtok (NULL, \",\")) {\n\t\t\t\tif (!strncmp(optl, \"loop=\", 5)) {\n\t\t\t\t\tloopdev = optl+5;\n\t\t\t\t\tgoto gotloop;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * If option \"-o loop=spec\" occurs in mtab,\n\t\t\t * note the mount point, and delete mtab line.\n\t\t\t */\n\t\t\tif ((mc = getmntoptfile (spec)) != NULL)\n\t\t\t\tnode = mc->m.mnt_dir;\n\t\t}\n\n\t\t/* Also free loop devices when -d flag is given */\n\t\tif (myloop)\n\t\t\tloopdev = spec;\n\t}\n gotloop:\n\tif (loopdev && !is_loop_autoclear(loopdev))\n\t\tdel_loop(loopdev);\n\n writemtab:\n\tif (!nomtab &&\n\t    (umnt_err == 0 || umnt_err == EINVAL || umnt_err == ENOENT)) {\n#ifdef HAVE_LIBMOUNT_MOUNT\n\t\tstruct libmnt_update *upd = mnt_new_update();\n\n\t\tif (upd && !mnt_update_set_fs(upd, 0, node, NULL)) {\n\t\t\tstruct libmnt_lock *lc = init_libmount_lock(\n\t\t\t\t\t\tmnt_update_get_filename(upd));\n\t\t\tmnt_update_table(upd, lc);\n\t\t\tinit_libmount_lock(NULL);\n\t\t}\n\t\tmnt_free_update(upd);\n#else\n\t\tupdate_mtab (node, NULL);\n#endif\n\t}\n\n\tif (res >= 0)\n\t\treturn 0;\n\tif (umnt_err)\n\t\tcomplain(umnt_err, node);\n\treturn 1;\n}",
        "start_line": 264
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "mount/umount.c",
        "method_name": "umount_one",
        "raw_code": "static int /* <=== umount_one */ \numount_one (const char *spec, const char *node, const char *type,\n\t    const char *opts, struct mntentchn *mc) {\n\tint umnt_err = 0;\n\tint isroot;\n\tint res = 0;\n\tint status;\n\tint extra_flags = 0;\n\tconst char *loopdev, *target = node;\n\tchar *targetbuf = NULL;\n\tint myloop = 0;\n\n\t/* Special case for root.  As of 0.99pl10 we can (almost) unmount root;\n\t   the kernel will remount it readonly so that we can carry on running\n\t   afterwards.  The readonly remount is illegal if any files are opened\n\t   for writing at the time, so we can't update mtab for an unmount of\n\t   root.  As it is only really a remount, this doesn't matter too\n\t   much.  [sct May 29, 1993] */\n\tisroot = (streq (node, \"/\") || streq (node, \"root\")\n\t\t  || streq (node, \"rootfs\"));\n\tif (isroot)\n\t\tnomtab++;\n\n\t/*\n\t * Call umount.TYPE for types that require a separate umount program.\n\t * All such special things must occur isolated in the types string.\n\t */\n\tif (check_special_umountprog(spec, node, type, &status))\n\t\treturn status;\n\n\tblock_signals(SIG_BLOCK);\n\n\t/* Skip the actual umounting for --fake */\n\tif (fake)\n\t\tgoto writemtab;\n\t/*\n\t * Ignore the option \"-d\" for non-loop devices and loop devices with\n\t * LO_FLAGS_AUTOCLEAR flag.\n\t */\n\tif (delloop && is_loop_device(spec))\n\t\tmyloop = 1;\n\n\tif (restricted) {\n\t\tif (umount_nofollow_support())\n\t\t\textra_flags |= UMOUNT_NOFOLLOW;\n\n\t\t/* call umount(2) with relative path to avoid races */\n\t\ttarget = chdir_to_parent(node, &targetbuf);\n\t}\n\n\tif (lazy) {\n\t\tres = umount2 (target, MNT_DETACH | extra_flags);\n\t\tif (res < 0)\n\t\t\tumnt_err = errno;\n\t\tgoto writemtab;\n\t}\n\n\tif (force) {\t\t/* only supported for NFS */\n\t\tres = umount2 (target, MNT_FORCE | extra_flags);\n\t\tif (res == -1) {\n\t\t\tint errsv = errno;\n\t\t\tperror(\"umount2\");\n\t\t\terrno = errsv;\n\t\t\tif (errno == ENOSYS) {\n\t\t\t\tif (verbose)\n\t\t\t\t\tprintf(_(\"no umount2, trying umount...\\n\"));\n\t\t\t\tres = umount (target);\n\t\t\t}\n\t\t}\n\t} else if (extra_flags)\n\t\tres = umount2 (target, extra_flags);\n\telse\n\t\tres = umount (target);\n\n\tfree(targetbuf);\n\n\tif (res < 0)\n\t\tumnt_err = errno;\n\n\tif (res < 0 && remount && umnt_err == EBUSY) {\n\t\t/* Umount failed - let us try a remount */\n\t\tres = mount(spec, node, NULL,\n\t\t\t    MS_MGC_VAL | MS_REMOUNT | MS_RDONLY, NULL);\n\t\tif (res == 0) {\n\t\t\tfprintf(stderr,\n\t\t\t\t_(\"umount: %s busy - remounted read-only\\n\"),\n\t\t\t\tspec);\n\t\t\tif (mc && !nomtab) {\n\t\t\t\t/* update mtab if the entry is there */\n\t\t\t\tstruct my_mntent remnt;\n\t\t\t\tremnt.mnt_fsname = mc->m.mnt_fsname;\n\t\t\t\tremnt.mnt_dir = mc->m.mnt_dir;\n\t\t\t\tremnt.mnt_type = mc->m.mnt_type;\n\t\t\t\tremnt.mnt_opts = \"ro\";\n\t\t\t\tremnt.mnt_freq = 0;\n\t\t\t\tremnt.mnt_passno = 0;\n\t\t\t\tupdate_mtab(node, &remnt);\n\t\t\t}\n\t\t\tblock_signals(SIG_UNBLOCK);\n\t\t\treturn 0;\n\t\t} else if (errno != EBUSY) { \t/* hmm ... */\n\t\t\tperror(\"remount\");\n\t\t\tfprintf(stderr,\n\t\t\t\t_(\"umount: could not remount %s read-only\\n\"),\n\t\t\t\tspec);\n\t\t}\n\t}\n\n\tloopdev = 0;\n\tif (res >= 0) {\n\t\t/* Umount succeeded */\n\t\tif (verbose)\n\t\t\tprintf (_(\"%s has been unmounted\\n\"), spec);\n\n\t\t/* Free any loop devices that we allocated ourselves */\n\t\tif (mc) {\n\t\t\tchar *optl;\n\n\t\t\t/* old style mtab line? */\n\t\t\tif (streq(mc->m.mnt_type, \"loop\")) {\n\t\t\t\tloopdev = spec;\n\t\t\t\tgoto gotloop;\n\t\t\t}\n\n\t\t\t/* new style mtab line? */\n\t\t\toptl = mc->m.mnt_opts ? xstrdup(mc->m.mnt_opts) : \"\";\n\t\t\tfor (optl = strtok (optl, \",\"); optl;\n\t\t\t     optl = strtok (NULL, \",\")) {\n\t\t\t\tif (!strncmp(optl, \"loop=\", 5)) {\n\t\t\t\t\tloopdev = optl+5;\n\t\t\t\t\tgoto gotloop;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * If option \"-o loop=spec\" occurs in mtab,\n\t\t\t * note the mount point, and delete mtab line.\n\t\t\t */\n\t\t\tif ((mc = getmntoptfile (spec)) != NULL)\n\t\t\t\tnode = mc->m.mnt_dir;\n\t\t}\n\n\t\t/* Also free loop devices when -d flag is given */\n\t\tif (myloop)\n\t\t\tloopdev = spec;\n\t}\n gotloop:\n\tif (loopdev && !is_loop_autoclear(loopdev))\n\t\tdel_loop(loopdev);\n\n writemtab:\n\tif (!nomtab &&\n\t    (umnt_err == 0 || umnt_err == EINVAL || umnt_err == ENOENT)) {\n#ifdef HAVE_LIBMOUNT_MOUNT\n\t\tstruct libmnt_update *upd = mnt_new_update();\n\n\t\tif (upd && !mnt_update_set_fs(upd, 0, node, NULL)) {\n\t\t\tstruct libmnt_lock *lc = init_libmount_lock(\n\t\t\t\t\t\tmnt_update_get_filename(upd));\n\t\t\tmnt_update_table(upd, lc);\n\t\t\tinit_libmount_lock(NULL);\n\t\t}\n\t\tmnt_free_update(upd);\n#else\n\t\tupdate_mtab (node, NULL);\n#endif\n\t}\n\n\tblock_signals(SIG_UNBLOCK);\n\n\tif (res >= 0)\n\t\treturn 0;\n\tif (umnt_err)\n\t\tcomplain(umnt_err, node);\n\treturn 1;\n}",
        "start_line": 264
      }
    ],
    "code_context": "Called Methods:\n- MS_MGC_VAL: #define MS_MGC_VAL 0xC0ED0000\t/* magic flag number to indicate \"new\" flags */ /* <=== mount/mount_constants.h:69:69:MS_MGC_VAL:0 */ \n- umount2: static int /* <=== umount2 */ \numount2(const char *path, int flags) {\n\tfprintf(stderr, _(\"umount: compiled without support for -f\\n\"));\n\terrno = ENOSYS;\n\treturn -1;\n}\n- die: static void /* <=== die */ \ndie(char *str) {\n\tfprintf(stderr, \"%s: \", program_name);\n\tfprintf(stderr, str, device_name);\n\tfprintf(stderr, \"\\n\");\n\texit(8);\n}\n- MNT_FORCE: # define MNT_FORCE        0x00000001\t/* Attempt to forcibily umount */ /* <=== mount/umount.c:49:49:MNT_FORCE:0 */ \n- error: void /* <=== error */ \nerror (const char *fmt, ...) {\n     va_list args;\n\n     if (mount_quiet)\n\t  return;\n     va_start (args, fmt);\n     vfprintf (stderr, fmt, args);\n     va_end (args);\n     fputc('\\n', stderr);\n}\n- error: void /* <=== error */ \nerror(const char *fmt, ...) {\n    va_list ap;\n#ifndef\tUSE_SYSLOG\n    int     fd;\n#endif\n    char    buf[BUFSIZ];\n    char   *bp;\n\n    /*\n     * If the diagnostic is reported via syslog(3), the process name is\n     * automatically prepended to the message. If we write directly to\n     * /dev/console, we must prepend the process name ourselves.\n     */\n\n#ifdef USE_SYSLOG\n    buf[0] = '\\0';\n    bp = buf;\n#else\n    (void) str2cpy(buf, progname, \": \");\n    bp = buf + strlen(buf);\n#endif\n\n    /*\n     * %s expansion is done by hand. On a System V Release 2 system without\n     * shared libraries and without syslog(3), linking with the the stdio\n     * library would make the program three times as big...\n     *\n     * %m expansion is done here as well. Too bad syslog(3) does not have a\n     * vsprintf() like interface.\n     */\n\n    va_start(ap, fmt);\n    while (*fmt && bp < &buf[BUFSIZ-1]) {\n\tif (strncmp(fmt, \"%s\", 2) == 0) {\n\t    xstrncpy(bp, va_arg(ap, char *), &buf[BUFSIZ-1] - bp);\n\t    bp += strlen(bp);\n\t    fmt += 2;\n\t} else if (strncmp(fmt, \"%m\", 2) == 0) {\n\t    xstrncpy(bp, strerror(errno), &buf[BUFSIZ-1] - bp);\n\t    bp += strlen(bp);\n\t    fmt += 2;\n\t} else {\n\t    *bp++ = *fmt++;\n\t}\n    }\n    *bp = 0;\n    va_end(ap);\n\n    /*\n     * Write the diagnostic directly to /dev/console if we do not use the\n     * syslog(3) facility.\n     */\n\n#ifdef\tUSE_SYSLOG\n    (void) openlog(progname, LOG_PID, LOG_AUTHPRIV);\n    (void) syslog(LOG_ERR, \"%s\", buf);\n    closelog();\n#else\n    /* Terminate with CR-LF since the console mode is unknown. */\n    (void) strcat(bp, \"\\r\\n\");\n    if ((fd = open(\"/dev/console\", 1)) >= 0) {\n\tignore_result( write(fd, buf, strlen(buf)) );\n\t(void) close(fd);\n    }\n#endif\n    (void) sleep((unsigned) 10);\t\t/* be kind to init(8) */\n    exit(1);\n}\n- _: # define _(Text) (Text) /* <=== include/nls.h:30:30:_:1 */ \n- xstrdup: static inline char *xstrdup(const char *str) /* <=== xstrdup */ \n{\n\tchar *ret = strdup(str);\n\n\tif (!ret && str)\n\t\terr(XALLOC_EXIT_CODE, \"cannot duplicate string\");\n\treturn ret;\n}\n- umount2: static int /* <=== umount2 */ \numount2(const char *path, int flags) {\n\tfprintf(stderr, _(\"umount: compiled without support for -f\\n\"));\n\terrno = ENOSYS;\n\treturn -1;\n}\n- check_special_umountprog: static int /* <=== check_special_umountprog */ \ncheck_special_umountprog(const char *spec, const char *node,\n\t\t\t const char *type, int *status) {\n\tchar umountprog[120];\n\tstruct stat statbuf;\n\tint res;\n\n\tif (!external_allowed)\n\t\treturn 0;\n\n\tif (type == NULL || strcmp(type, \"none\") == 0)\n\t\treturn 0;\n\n\tif (strlen(type) < 100) {\n\t\tint type_opt = 0;\n\n\t\tsprintf(umountprog, \"/sbin/umount.%s\", type);\n\t\tres = stat(umountprog, &statbuf);\n\t\tif (res == -1 && errno == ENOENT && strchr(type, '.')) {\n\t\t\t/* If type ends with \".subtype\" try without it */\n\t\t\t*strrchr(umountprog, '.') = '\\0';\n\t\t\ttype_opt = 1;\n\t\t\tres = stat(umountprog, &statbuf);\n\t\t}\n\t\tif (res == 0) {\n\t\t\tres = fork();\n\t\t\tif (res == 0) {\n\t\t\t\tchar *umountargs[10];\n\t\t\t\tint i = 0;\n\n\t\t\t\tif(setgid(getgid()) < 0)\n\t\t\t\t\tdie(EX_FAIL, _(\"umount: cannot set group id: %s\"), strerror(errno));\n\n\t\t\t\tif(setuid(getuid()) < 0)\n\t\t\t\t\tdie(EX_FAIL, _(\"umount: cannot set user id: %s\"), strerror(errno));\n\n\t\t\t\tumountargs[i++] = umountprog;\n\t\t\t\tumountargs[i++] = xstrdup(node);\n\t\t\t\tif (nomtab)\n\t\t\t\t\tumountargs[i++] = \"-n\";\n\t\t\t\tif (lazy)\n\t\t\t\t\tumountargs[i++] = \"-l\";\n\t\t\t\tif (force)\n\t\t\t\t\tumountargs[i++] = \"-f\";\n\t\t\t\tif (verbose)\n\t\t\t\t\tumountargs[i++] = \"-v\";\n\t\t\t\tif (remount)\n\t\t\t\t\tumountargs[i++] = \"-r\";\n\t\t\t\tif (type_opt) {\n\t\t\t\t\tumountargs[i++] = \"-t\";\n\t\t\t\t\tumountargs[i++] = (char *) type;\n\t\t\t\t}\n\t\t\t\tumountargs[i] = NULL;\n\t\t\t\texecv(umountprog, umountargs);\n\t\t\t\texit(1);\t/* exec failed */\n\t\t\t} else if (res != -1) {\n\t\t\t\tint st;\n\t\t\t\twait(&st);\n\t\t\t\t*status = (WIFEXITED(st) ? WEXITSTATUS(st)\n\t\t\t\t\t   : EX_SYSERR);\n\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t\tint errsv = errno;\n\t\t\t\terror(_(\"umount: cannot fork: %s\"),\n\t\t\t\t      strerror(errsv));\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n- MS_RDONLY: #define MS_RDONLY\t 1\t/* Mount read-only */ /* <=== mount/mount_constants.h:2:2:MS_RDONLY:0 */ \n- die: void __attribute__ ((noreturn)) die(int err, const char *fmt, ...) /* <=== die */ \n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvfprintf(stderr, fmt, args);\n\tfprintf(stderr, \"\\n\");\n\tva_end(args);\n\n\texit(err);\n}\n- xstrdup: static char * /* <=== xstrdup */ \nxstrdup(const char *str)\n{\n\tchar *s = strdup(str);\n\tif (!s)\n\t\terr(EXIT_FAILURE, _(\"error: strdup failed\"));\n\treturn s;\n}\n- block_signals: void /* <=== block_signals */ \nblock_signals (int how) {\n     sigset_t sigs;\n\n     sigfillset (&sigs);\n     sigdelset(&sigs, SIGTRAP);\n     sigdelset(&sigs, SIGSEGV);\n     sigprocmask (how, &sigs, (sigset_t *) 0);\n}\n- error: void error (char *mess) /* <=== error */ \n{\n    if (clreol)\n\tcleareol ();\n    else\n\tkill_line ();\n    promptlen += strlen (mess);\n    if (Senter && Sexit) {\n\tmy_putstring (Senter);\n\tputsout(mess);\n\tmy_putstring (Sexit);\n    }\n    else\n\tputsout(mess);\n    fflush(stdout);\n    errors++;\n    siglongjmp (restore, 1);\n}\n- error: static void /* <=== error */ \nerror(char *s, ...) {\n    va_list p;\n\n    va_start(p, s);\n    fflush(stdout);\n    fprintf(stderr, \"\\n\" PROGNAME \": \");\n    vfprintf(stderr, s, p);\n    fflush(stderr);\n    va_end(p);\n}\n- die: static void die(int status, int syserr, const char *fmt, ...) /* <=== die */ \n{\n\tva_list arg_ptr;\n\tint save = errno;\n\n\tfflush(0);\n\tva_start(arg_ptr, fmt);\n\tfprintf(stderr, \"%s: \", progname);\n\tvfprintf(stderr, fmt, arg_ptr);\n\tif (syserr) {\n\t\tfprintf(stderr, \": %s\", strerror(save));\n\t}\n\tfprintf(stderr, \"\\n\");\n\tva_end(arg_ptr);\n\texit(status);\n}\n- EX_SYSERR: #define EX_SYSERR\t2\t/* out of memory, cannot fork, ... */ /* <=== mount/sundries.h:46:46:EX_SYSERR:0 */ \n- EX_FAIL: #define EX_FAIL\t       32\t/* mount failure */ /* <=== mount/sundries.h:50:50:EX_FAIL:0 */ \n- die: static void die(const char *msg) /* <=== die */ \n{\n\tperror(msg);\n\texit(1);\n}\n- umount_nofollow_support: static int umount_nofollow_support(void) /* <=== umount_nofollow_support */ \n{\n\tint res = umount2(\"\", UMOUNT_UNUSED);\n\tif (res != -1 || errno != EINVAL)\n\t\treturn 0;\n\n\tres = umount2(\"\", UMOUNT_NOFOLLOW);\n\tif (res != -1 || errno != ENOENT)\n\t\treturn 0;\n\n\treturn 1;\n}\n- die: static void /* <=== die */ \ndie(const char *fmt, ...) {\n\tva_list ap;\n\n\tfprintf(stderr, \"%s: \", program_name);\n\tva_start(ap, fmt);\n\tvfprintf(stderr, fmt, ap);\n\tva_end (ap);\n\tfputc('\\n', stderr);\n\tleave(8);\n}\n- streq: #define streq(s, t)\t(strcmp ((s), (t)) == 0) /* <=== mount/sundries.h:22:22:streq:2 */ \n- UMOUNT_UNUSED: # define UMOUNT_UNUSED    0x80000000\t/* Flag guaranteed to be unused */ /* <=== mount/umount.c:63:63:UMOUNT_UNUSED:0 */ \n- chdir_to_parent: static const char *chdir_to_parent(const char *node, char **resbuf) /* <=== chdir_to_parent */ \n{\n\tchar *tmp, *res;\n\tconst char *parent;\n\tchar buf[65536];\n\n\t*resbuf = xstrdup(node);\n\n\ttmp = strrchr(*resbuf, '/');\n\tif (!tmp)\n\t\tdie (2, _(\"umount: internal error: invalid abs path: %s\"), node);\n\n\tif (tmp != *resbuf) {\n\t\t*tmp = '\\0';\n\t\tres = tmp + 1;\n\t\tparent = *resbuf;\n\t} else if (tmp[1] != '\\0') {\n\t\tres = tmp + 1;\n\t\tparent = \"/\";\n\t} else {\n\t\tres = \".\";\n\t\tparent = \"/\";\n\t}\n\n\tif (chdir(parent) == -1)\n\t\tdie (2, _(\"umount: failed to chdir to %s: %s\"),\n\t\t\t\t\tparent, strerror(errno));\n\n\tif (!getcwd(buf, sizeof(buf)))\n\t\tdie (2, _(\"umount: failed to obtain current directory: %s\"),\n\t\t\tstrerror(errno));\n\n\tif (strcmp(buf, parent) != 0)\n\t\tdie (2, _(\"umount: mountpoint moved (%s -> %s)\"), parent, buf);\n\n\tif (verbose)\n\t\tprintf(_(\"current directory moved to %s\\n\"), res);\n\n\treturn res;\n}\n- MS_REMOUNT: #define MS_REMOUNT\t32\t/* Alter flags of a mounted FS */ /* <=== mount/mount_constants.h:17:17:MS_REMOUNT:0 */ \n- xstrdup: char * /* <=== xstrdup */ \nxstrdup (const char *s) {\n\tchar *t;\n\n\tif (s == NULL)\n\t\treturn NULL;\n\n\tt = strdup(s);\n\tdie_if_null(t);\n\n\treturn t;\n}\n- die: static void /* <=== die */ \ndie(const char *str) {\n\tfprintf(stderr, \"%s: %s\\n\", program_name, str);\n\texit(1);\n}\n- UMOUNT_NOFOLLOW: # define UMOUNT_NOFOLLOW  0x00000008\t/* Don't follow symlink on umount */ /* <=== mount/umount.c:59:59:UMOUNT_NOFOLLOW:0 */ \n\nGlobal Variables:\n- static int fake\n- int force\n- int lazy\n- int restricted\n- int delloop\n- int remount\n\nImports:\n- #include <sys/wait.h>\n- #include <sys/stat.h>\n- #include \"loop.h\"\n- #include \"env.h\"\n- #include <ctype.h>\n- #include <string.h>\n- #include <sys/mount.h>\n- #include \"getusername.h\"\n- #include \"nls.h\"\n- #include <errno.h>\n- #include \"sundries.h\"\n- #include <unistd.h>\n- #include <linux/unistd.h>\n- #include \"pathnames.h\"\n- #include \"lomount.h\"\n- #include \"strutils.h\"\n- #include \"fstab.h\"\n- #include \"mount_constants.h\"\n- #include <getopt.h>\n- #include <stdio.h>",
    "commit_msg": "umount: block signals when umounting and updating mtab (CVE-2011-1676, CVE-2011-1677)\n\nhttp://thread.gmane.org/gmane.comp.security.oss.general/4374\n\nBased on CVE-2011-1089.\n\nSigned-off-by: Karel Zak <kzak@redhat.com>",
    "cve_desc": "mount in util-linux 2.19 and earlier attempts to append to the /etc/mtab.tmp file without first checking whether resource limits would interfere, which allows local users to trigger corruption of the /etc/mtab file via a process with a small RLIMIT_FSIZE value, a related issue to CVE-2011-1089.",
    "year": 2011,
    "filename": "umount.c",
    "commit_url": "\"https://github.com/karelzak/util-linux/commit/11b51a46bfd3c340df251b2d20fe9d04d077a88e\""
  },
  {
    "repository": "Exim/exim",
    "cve_id": "CVE-2011-1764",
    "cwe_list": [
      "CWE-134"
    ],
    "commit_hash": "337e3505b0e6cd4309db6bf6062b33fa56e06cf8",
    "short_hash": "337e3505",
    "vulnerableMethods_before": [
      {
        "filename": "src/src/dkim.c",
        "method_name": "dkim_exim_verify_finish",
        "raw_code": "void dkim_exim_verify_finish(void) { /* <=== dkim_exim_verify_finish */ \n  pdkim_signature *sig = NULL;\n  int dkim_signers_size = 0;\n  int dkim_signers_ptr = 0;\n  dkim_signers = NULL;\n\n  /* Delete eventual previous signature chain */\n  dkim_signatures = NULL;\n\n  /* If we have arrived here with dkim_collect_input == FALSE, it\n     means there was a processing error somewhere along the way.\n     Log the incident and disable futher verification. */\n  if (!dkim_collect_input) {\n    log_write(0, LOG_MAIN, \"DKIM: Error while running this message through validation, disabling signature verification.\");\n    dkim_disable_verify = TRUE;\n    return;\n  }\n  dkim_collect_input = FALSE;\n\n  /* Finish DKIM operation and fetch link to signatures chain */\n  if (pdkim_feed_finish(dkim_verify_ctx,&dkim_signatures) != PDKIM_OK) return;\n\n  sig = dkim_signatures;\n  while (sig != NULL) {\n    int size = 0;\n    int ptr = 0;\n    /* Log a line for each signature */\n    uschar *logmsg = string_append(NULL, &size, &ptr, 5,\n\n      string_sprintf( \"DKIM: d=%s s=%s c=%s/%s a=%s \",\n                      sig->domain,\n                      sig->selector,\n                      (sig->canon_headers == PDKIM_CANON_SIMPLE)?\"simple\":\"relaxed\",\n                      (sig->canon_body    == PDKIM_CANON_SIMPLE)?\"simple\":\"relaxed\",\n                      (sig->algo          == PDKIM_ALGO_RSA_SHA256)?\"rsa-sha256\":\"rsa-sha1\"\n                    ),\n      ((sig->identity != NULL)?\n        string_sprintf(\"i=%s \", sig->identity)\n        :\n        US\"\"\n      ),\n      ((sig->created > 0)?\n        string_sprintf(\"t=%lu \", sig->created)\n        :\n        US\"\"\n      ),\n      ((sig->expires > 0)?\n        string_sprintf(\"x=%lu \", sig->expires)\n        :\n        US\"\"\n      ),\n      ((sig->bodylength > -1)?\n        string_sprintf(\"l=%lu \", sig->bodylength)\n        :\n        US\"\"\n      )\n    );\n\n    switch(sig->verify_status) {\n      case PDKIM_VERIFY_NONE:\n        logmsg = string_append(logmsg, &size, &ptr, 1, \"[not verified]\");\n      break;\n      case PDKIM_VERIFY_INVALID:\n        logmsg = string_append(logmsg, &size, &ptr, 1, \"[invalid - \");\n        switch (sig->verify_ext_status) {\n          case PDKIM_VERIFY_INVALID_PUBKEY_UNAVAILABLE:\n            logmsg = string_append(logmsg, &size, &ptr, 1, \"public key record (currently?) unavailable]\");\n          break;\n          case PDKIM_VERIFY_INVALID_BUFFER_SIZE:\n            logmsg = string_append(logmsg, &size, &ptr, 1, \"overlong public key record]\");\n          break;\n          case PDKIM_VERIFY_INVALID_PUBKEY_PARSING:\n            logmsg = string_append(logmsg, &size, &ptr, 1, \"syntax error in public key record]\");\n          break;\n          default:\n            logmsg = string_append(logmsg, &size, &ptr, 1, \"unspecified problem]\");\n        }\n      break;\n      case PDKIM_VERIFY_FAIL:\n        logmsg = string_append(logmsg, &size, &ptr, 1, \"[verification failed - \");\n        switch (sig->verify_ext_status) {\n          case PDKIM_VERIFY_FAIL_BODY:\n            logmsg = string_append(logmsg, &size, &ptr, 1, \"body hash mismatch (body probably modified in transit)]\");\n          break;\n          case PDKIM_VERIFY_FAIL_MESSAGE:\n            logmsg = string_append(logmsg, &size, &ptr, 1, \"signature did not verify (headers probably modified in transit)]\");\n          break;\n          default:\n            logmsg = string_append(logmsg, &size, &ptr, 1, \"unspecified reason]\");\n        }\n      break;\n      case PDKIM_VERIFY_PASS:\n        logmsg = string_append(logmsg, &size, &ptr, 1, \"[verification succeeded]\");\n      break;\n    }\n\n    logmsg[ptr] = '\\0';\n    log_write(0, LOG_MAIN, (char *)logmsg);\n\n    /* Build a colon-separated list of signing domains (and identities, if present) in dkim_signers */\n    dkim_signers = string_append(dkim_signers,\n                                 &dkim_signers_size,\n                                 &dkim_signers_ptr,\n                                 2,\n                                 sig->domain,\n                                 \":\"\n                                );\n\n    if (sig->identity != NULL) {\n      dkim_signers = string_append(dkim_signers,\n                                   &dkim_signers_size,\n                                   &dkim_signers_ptr,\n                                   2,\n                                   sig->identity,\n                                   \":\"\n                                  );\n    }\n\n    /* Process next signature */\n    sig = sig->next;\n  }\n\n  /* NULL-terminate and chop the last colon from the domain list */\n  if (dkim_signers != NULL) {\n    dkim_signers[dkim_signers_ptr] = '\\0';\n    if (Ustrlen(dkim_signers) > 0)\n      dkim_signers[Ustrlen(dkim_signers)-1] = '\\0';\n  }\n}",
        "start_line": 82
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "src/src/dkim.c",
        "method_name": "dkim_exim_verify_finish",
        "raw_code": "void dkim_exim_verify_finish(void) { /* <=== dkim_exim_verify_finish */ \n  pdkim_signature *sig = NULL;\n  int dkim_signers_size = 0;\n  int dkim_signers_ptr = 0;\n  dkim_signers = NULL;\n\n  /* Delete eventual previous signature chain */\n  dkim_signatures = NULL;\n\n  /* If we have arrived here with dkim_collect_input == FALSE, it\n     means there was a processing error somewhere along the way.\n     Log the incident and disable futher verification. */\n  if (!dkim_collect_input) {\n    log_write(0, LOG_MAIN, \"DKIM: Error while running this message through validation, disabling signature verification.\");\n    dkim_disable_verify = TRUE;\n    return;\n  }\n  dkim_collect_input = FALSE;\n\n  /* Finish DKIM operation and fetch link to signatures chain */\n  if (pdkim_feed_finish(dkim_verify_ctx,&dkim_signatures) != PDKIM_OK) return;\n\n  sig = dkim_signatures;\n  while (sig != NULL) {\n    int size = 0;\n    int ptr = 0;\n    /* Log a line for each signature */\n    uschar *logmsg = string_append(NULL, &size, &ptr, 5,\n\n      string_sprintf( \"d=%s s=%s c=%s/%s a=%s \",\n                      sig->domain,\n                      sig->selector,\n                      (sig->canon_headers == PDKIM_CANON_SIMPLE)?\"simple\":\"relaxed\",\n                      (sig->canon_body    == PDKIM_CANON_SIMPLE)?\"simple\":\"relaxed\",\n                      (sig->algo          == PDKIM_ALGO_RSA_SHA256)?\"rsa-sha256\":\"rsa-sha1\"\n                    ),\n      ((sig->identity != NULL)?\n        string_sprintf(\"i=%s \", sig->identity)\n        :\n        US\"\"\n      ),\n      ((sig->created > 0)?\n        string_sprintf(\"t=%lu \", sig->created)\n        :\n        US\"\"\n      ),\n      ((sig->expires > 0)?\n        string_sprintf(\"x=%lu \", sig->expires)\n        :\n        US\"\"\n      ),\n      ((sig->bodylength > -1)?\n        string_sprintf(\"l=%lu \", sig->bodylength)\n        :\n        US\"\"\n      )\n    );\n\n    switch(sig->verify_status) {\n      case PDKIM_VERIFY_NONE:\n        logmsg = string_append(logmsg, &size, &ptr, 1, \"[not verified]\");\n      break;\n      case PDKIM_VERIFY_INVALID:\n        logmsg = string_append(logmsg, &size, &ptr, 1, \"[invalid - \");\n        switch (sig->verify_ext_status) {\n          case PDKIM_VERIFY_INVALID_PUBKEY_UNAVAILABLE:\n            logmsg = string_append(logmsg, &size, &ptr, 1, \"public key record (currently?) unavailable]\");\n          break;\n          case PDKIM_VERIFY_INVALID_BUFFER_SIZE:\n            logmsg = string_append(logmsg, &size, &ptr, 1, \"overlong public key record]\");\n          break;\n          case PDKIM_VERIFY_INVALID_PUBKEY_PARSING:\n            logmsg = string_append(logmsg, &size, &ptr, 1, \"syntax error in public key record]\");\n          break;\n          default:\n            logmsg = string_append(logmsg, &size, &ptr, 1, \"unspecified problem]\");\n        }\n      break;\n      case PDKIM_VERIFY_FAIL:\n        logmsg = string_append(logmsg, &size, &ptr, 1, \"[verification failed - \");\n        switch (sig->verify_ext_status) {\n          case PDKIM_VERIFY_FAIL_BODY:\n            logmsg = string_append(logmsg, &size, &ptr, 1, \"body hash mismatch (body probably modified in transit)]\");\n          break;\n          case PDKIM_VERIFY_FAIL_MESSAGE:\n            logmsg = string_append(logmsg, &size, &ptr, 1, \"signature did not verify (headers probably modified in transit)]\");\n          break;\n          default:\n            logmsg = string_append(logmsg, &size, &ptr, 1, \"unspecified reason]\");\n        }\n      break;\n      case PDKIM_VERIFY_PASS:\n        logmsg = string_append(logmsg, &size, &ptr, 1, \"[verification succeeded]\");\n      break;\n    }\n\n    logmsg[ptr] = '\\0';\n    log_write(0, LOG_MAIN, \"DKIM: %s\", logmsg);\n\n    /* Build a colon-separated list of signing domains (and identities, if present) in dkim_signers */\n    dkim_signers = string_append(dkim_signers,\n                                 &dkim_signers_size,\n                                 &dkim_signers_ptr,\n                                 2,\n                                 sig->domain,\n                                 \":\"\n                                );\n\n    if (sig->identity != NULL) {\n      dkim_signers = string_append(dkim_signers,\n                                   &dkim_signers_size,\n                                   &dkim_signers_ptr,\n                                   2,\n                                   sig->identity,\n                                   \":\"\n                                  );\n    }\n\n    /* Process next signature */\n    sig = sig->next;\n  }\n\n  /* NULL-terminate and chop the last colon from the domain list */\n  if (dkim_signers != NULL) {\n    dkim_signers[dkim_signers_ptr] = '\\0';\n    if (Ustrlen(dkim_signers) > 0)\n      dkim_signers[Ustrlen(dkim_signers)-1] = '\\0';\n  }\n}",
        "start_line": 82
      }
    ],
    "code_context": "Called Methods:\n- pdkim_quoteprint: void pdkim_quoteprint(FILE *stream, const char *data, int len, int lf) { /* <=== pdkim_quoteprint */ \n  int i;\n  const unsigned char *p = (const unsigned char *)data;\n\n  for (i=0;i<len;i++) {\n    const int c = p[i];\n    switch (c) {\n      case ' ' : fprintf(stream,\"{SP}\"); break;\n      case '\\t': fprintf(stream,\"{TB}\"); break;\n      case '\\r': fprintf(stream,\"{CR}\"); break;\n      case '\\n': fprintf(stream,\"{LF}\"); break;\n      case '{' : fprintf(stream,\"{BO}\"); break;\n      case '}' : fprintf(stream,\"{BC}\"); break;\n      default:\n        if ( (c < 32) || (c > 127) )\n          fprintf(stream,\"{%02x}\",c);\n        else\n          fputc(c,stream);\n      break;\n    }\n  }\n  if (lf)\n    fputc('\\n',stream);\n}\n- rsa_pkcs1_verify: int rsa_pkcs1_verify( rsa_context *ctx, /* <=== rsa_pkcs1_verify */ \n                      int mode,\n                      int hash_id,\n                      int hashlen,\n                      const unsigned char *hash,\n                      unsigned char *sig )\n{\n    int ret, len, siglen;\n    unsigned char *p, c;\n    unsigned char buf[1024];\n\n    siglen = ctx->len;\n\n    if( siglen < 16 || siglen > (int) sizeof( buf ) )\n        return( POLARSSL_ERR_RSA_BAD_INPUT_DATA );\n\n    ret = ( mode == RSA_PUBLIC )\n          ? rsa_public(  ctx, sig, buf )\n          : rsa_private( ctx, sig, buf );\n\n    if( ret != 0 )\n        return( ret );\n\n    p = buf;\n\n    switch( ctx->padding )\n    {\n        case RSA_PKCS_V15:\n\n            if( *p++ != 0 || *p++ != RSA_SIGN )\n                return( POLARSSL_ERR_RSA_INVALID_PADDING );\n\n            while( *p != 0 )\n            {\n                if( p >= buf + siglen - 1 || *p != 0xFF )\n                    return( POLARSSL_ERR_RSA_INVALID_PADDING );\n                p++;\n            }\n            p++;\n            break;\n\n        default:\n\n            return( POLARSSL_ERR_RSA_INVALID_PADDING );\n    }\n\n    len = siglen - (int)( p - buf );\n\n    if( len == 34 )\n    {\n        c = p[13];\n        p[13] = 0;\n\n        if( memcmp( p, ASN1_HASH_MDX, 18 ) != 0 )\n            return( POLARSSL_ERR_RSA_VERIFY_FAILED );\n\n        if( ( c == 2 && hash_id == SIG_RSA_MD2 ) ||\n            ( c == 4 && hash_id == SIG_RSA_MD4 ) ||\n            ( c == 5 && hash_id == SIG_RSA_MD5 ) )\n        {\n            if( memcmp( p + 18, hash, 16 ) == 0 )\n                return( 0 );\n            else\n                return( POLARSSL_ERR_RSA_VERIFY_FAILED );\n        }\n    }\n\n    if( len == 35 && hash_id == SIG_RSA_SHA1 )\n    {\n        if( memcmp( p, ASN1_HASH_SHA1, 15 ) == 0 &&\n            memcmp( p + 15, hash, 20 ) == 0 )\n            return( 0 );\n        else\n            return( POLARSSL_ERR_RSA_VERIFY_FAILED );\n    }\n    if( ( len == 19 + 28 && p[14] == 4 && hash_id == SIG_RSA_SHA224 ) ||\n        ( len == 19 + 32 && p[14] == 1 && hash_id == SIG_RSA_SHA256 ) ||\n        ( len == 19 + 48 && p[14] == 2 && hash_id == SIG_RSA_SHA384 ) ||\n        ( len == 19 + 64 && p[14] == 3 && hash_id == SIG_RSA_SHA512 ) )\n    {\n        c = p[1] - 17;\n        p[1] = 17;\n        p[14] = 0;\n\n        if( p[18] == c &&\n                memcmp( p, ASN1_HASH_SHA2X, 18 ) == 0 &&\n                memcmp( p + 19, hash, c ) == 0 )\n            return( 0 );\n        else\n            return( POLARSSL_ERR_RSA_VERIFY_FAILED );\n    }\n\n    if( len == hashlen && hash_id == SIG_RSA_RAW )\n    {\n        if( memcmp( p, hash, hashlen ) == 0 )\n            return( 0 );\n        else\n            return( POLARSSL_ERR_RSA_VERIFY_FAILED );\n    }\n\n    return( POLARSSL_ERR_RSA_INVALID_PADDING );\n}\n- PDKIM_VERIFY_INVALID: #define PDKIM_VERIFY_INVALID   1 /* <=== src/src/pdkim/pdkim.h:48:48:PDKIM_VERIFY_INVALID:0 */ \n- RSA_PRIVATE: #define RSA_PRIVATE     1 /* <=== src/src/pdkim/rsa.h:126:126:RSA_PRIVATE:0 */ \n- pdkim_header_complete: int pdkim_header_complete(pdkim_ctx *ctx) { /* <=== pdkim_header_complete */ \n  pdkim_signature *sig = ctx->sig;\n\n  /* Special case: The last header can have an extra \\r appended */\n  if ( (ctx->cur_header->len > 1) &&\n       (ctx->cur_header->str[(ctx->cur_header->len)-1] == '\\r') ) {\n    ctx->cur_header->str[(ctx->cur_header->len)-1] = '\\0';\n    ctx->cur_header->len--;\n  }\n\n  ctx->num_headers++;\n  if (ctx->num_headers > PDKIM_MAX_HEADERS) goto BAIL;\n\n  /* Traverse all signatures */\n  while (sig != NULL) {\n    pdkim_stringlist *list;\n\n    /* SIGNING -------------------------------------------------------------- */\n    if (ctx->mode == PDKIM_MODE_SIGN) {\n      if (header_name_match(ctx->cur_header->str,\n                            sig->sign_headers?\n                              sig->sign_headers:\n                              PDKIM_DEFAULT_SIGN_HEADERS, 0) != PDKIM_OK) goto NEXT_SIG;\n    }\n    /* VERIFICATION --------------------------------------------------------- */\n    else {\n      /* Header is not included or all instances were already 'ticked off' */\n      if (header_name_match(ctx->cur_header->str,\n                            sig->hnames_check, 1) != PDKIM_OK) goto NEXT_SIG;\n    }\n\n    /* Add header to the signed headers list (in reverse order) */\n    list = pdkim_prepend_stringlist(sig->headers,\n                                    ctx->cur_header->str);\n    if (list == NULL) return PDKIM_ERR_OOM;\n    sig->headers = list;\n\n    NEXT_SIG:\n    sig = sig->next;\n  }\n\n  /* DKIM-Signature: headers are added to the verification list */\n  if ( (ctx->mode == PDKIM_MODE_VERIFY) &&\n       (strncasecmp(ctx->cur_header->str,\n                    DKIM_SIGNATURE_HEADERNAME,\n                    strlen(DKIM_SIGNATURE_HEADERNAME)) == 0) ) {\n     pdkim_signature *new_sig;\n    /* Create and chain new signature block */\n    #ifdef PDKIM_DEBUG\n    if (ctx->debug_stream)\n      fprintf(ctx->debug_stream,\n        \"PDKIM >> Found sig, trying to parse >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\\n\");\n    #endif\n    new_sig = pdkim_parse_sig_header(ctx, ctx->cur_header->str);\n    if (new_sig != NULL) {\n      pdkim_signature *last_sig = ctx->sig;\n      if (last_sig == NULL) {\n        ctx->sig = new_sig;\n      }\n      else {\n        while (last_sig->next != NULL) { last_sig = last_sig->next; }\n        last_sig->next = new_sig;\n      }\n    }\n    else {\n      #ifdef PDKIM_DEBUG\n      if (ctx->debug_stream) {\n        fprintf(ctx->debug_stream,\"Error while parsing signature header\\n\");\n        fprintf(ctx->debug_stream,\n          \"PDKIM <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\\n\");\n      }\n      #endif\n    }\n  }\n\n  BAIL:\n  pdkim_strclear(ctx->cur_header); /* Re-use existing pdkim_str */\n  return PDKIM_OK;\n}\n- rsa_parse_key: int rsa_parse_key( rsa_context *rsa, unsigned char *buf, int buflen, /* <=== rsa_parse_key */ \n                                     unsigned char *pwd, int pwdlen )\n{\n    int ret, len, enc;\n    unsigned char *s1, *s2;\n    unsigned char *p, *end;\n\n    s1 = (unsigned char *) strstr( (char *) buf,\n        \"-----BEGIN RSA PRIVATE KEY-----\" );\n\n    if( s1 != NULL )\n    {\n        s2 = (unsigned char *) strstr( (char *) buf,\n            \"-----END RSA PRIVATE KEY-----\" );\n\n        if( s2 == NULL || s2 <= s1 )\n            return( POLARSSL_ERR_X509_KEY_INVALID_PEM );\n\n        s1 += 31;\n        if( *s1 == '\\r' ) s1++;\n        if( *s1 == '\\n' ) s1++;\n            else return( POLARSSL_ERR_X509_KEY_INVALID_PEM );\n\n        enc = 0;\n\n        if( memcmp( s1, \"Proc-Type: 4,ENCRYPTED\", 22 ) == 0 )\n        {\n            return( POLARSSL_ERR_X509_FEATURE_UNAVAILABLE );\n        }\n\n        len = 0;\n        ret = base64_decode( NULL, &len, s1, s2 - s1 );\n\n        if( ret == POLARSSL_ERR_BASE64_INVALID_CHARACTER )\n            return( ret | POLARSSL_ERR_X509_KEY_INVALID_PEM );\n\n        if( ( buf = (unsigned char *) malloc( len ) ) == NULL )\n            return( 1 );\n\n        if( ( ret = base64_decode( buf, &len, s1, s2 - s1 ) ) != 0 )\n        {\n            free( buf );\n            return( ret | POLARSSL_ERR_X509_KEY_INVALID_PEM );\n        }\n\n        buflen = len;\n\n        if( enc != 0 )\n        {\n            return( POLARSSL_ERR_X509_FEATURE_UNAVAILABLE );\n        }\n    }\n\n    memset( rsa, 0, sizeof( rsa_context ) );\n\n    p = buf;\n    end = buf + buflen;\n\n    /*\n     *  RSAPrivateKey ::= SEQUENCE {\n     *      version           Version,\n     *      modulus           INTEGER,  -- n\n     *      publicExponent    INTEGER,  -- e\n     *      privateExponent   INTEGER,  -- d\n     *      prime1            INTEGER,  -- p\n     *      prime2            INTEGER,  -- q\n     *      exponent1         INTEGER,  -- d mod (p-1)\n     *      exponent2         INTEGER,  -- d mod (q-1)\n     *      coefficient       INTEGER,  -- (inverse of q) mod p\n     *      otherPrimeInfos   OtherPrimeInfos OPTIONAL\n     *  }\n     */\n    if( ( ret = asn1_get_tag( &p, end, &len,\n            ASN1_CONSTRUCTED | ASN1_SEQUENCE ) ) != 0 )\n    {\n        if( s1 != NULL )\n            free( buf );\n\n        rsa_free( rsa );\n        return( POLARSSL_ERR_X509_KEY_INVALID_FORMAT | ret );\n    }\n\n    end = p + len;\n\n    if( ( ret = asn1_get_int( &p, end, &rsa->ver ) ) != 0 )\n    {\n        if( s1 != NULL )\n            free( buf );\n\n        rsa_free( rsa );\n        return( POLARSSL_ERR_X509_KEY_INVALID_FORMAT | ret );\n    }\n\n    if( rsa->ver != 0 )\n    {\n        if( s1 != NULL )\n            free( buf );\n\n        rsa_free( rsa );\n        return( ret | POLARSSL_ERR_X509_KEY_INVALID_VERSION );\n    }\n\n    if( ( ret = asn1_get_mpi( &p, end, &rsa->N  ) ) != 0 ||\n        ( ret = asn1_get_mpi( &p, end, &rsa->E  ) ) != 0 ||\n        ( ret = asn1_get_mpi( &p, end, &rsa->D  ) ) != 0 ||\n        ( ret = asn1_get_mpi( &p, end, &rsa->P  ) ) != 0 ||\n        ( ret = asn1_get_mpi( &p, end, &rsa->Q  ) ) != 0 ||\n        ( ret = asn1_get_mpi( &p, end, &rsa->DP ) ) != 0 ||\n        ( ret = asn1_get_mpi( &p, end, &rsa->DQ ) ) != 0 ||\n        ( ret = asn1_get_mpi( &p, end, &rsa->QP ) ) != 0 )\n    {\n        if( s1 != NULL )\n            free( buf );\n\n        rsa_free( rsa );\n        return( ret | POLARSSL_ERR_X509_KEY_INVALID_FORMAT );\n    }\n\n    rsa->len = mpi_size( &rsa->N );\n\n    if( p != end )\n    {\n        if( s1 != NULL )\n            free( buf );\n\n        rsa_free( rsa );\n        return( POLARSSL_ERR_X509_KEY_INVALID_FORMAT |\n                POLARSSL_ERR_ASN1_LENGTH_MISMATCH );\n    }\n\n    if( ( ret = rsa_check_privkey( rsa ) ) != 0 )\n    {\n        if( s1 != NULL )\n            free( buf );\n\n        rsa_free( rsa );\n        return( ret );\n    }\n\n    if( s1 != NULL )\n        free( buf );\n\n    return( 0 );\n}\n- PDKIM_OK: #define PDKIM_OK                      0 /* <=== src/src/pdkim/pdkim.h:37:37:PDKIM_OK:0 */ \n- PDKIM_ERR_RSA_PRIVKEY: #define PDKIM_ERR_RSA_PRIVKEY      -101 /* <=== src/src/pdkim/pdkim.h:40:40:PDKIM_ERR_RSA_PRIVKEY:0 */ \n- string_append: extern uschar *string_append(uschar *, int *, int *, int, ...); /* <=== string_append */ \n- PDKIM_VERIFY_FAIL: #define PDKIM_VERIFY_FAIL      2 /* <=== src/src/pdkim/pdkim.h:49:49:PDKIM_VERIFY_FAIL:0 */ \n- rsa_parse_public_key: int rsa_parse_public_key( rsa_context *rsa, unsigned char *buf, int buflen ) /* <=== rsa_parse_public_key */ \n{\n    unsigned char *p, *end;\n    int ret, len;\n\n    p = buf;\n    end = buf+buflen;\n\n    if( ( ret = asn1_get_tag( &p, end, &len,\n            ASN1_CONSTRUCTED | ASN1_SEQUENCE ) ) != 0 ) {\n        return( POLARSSL_ERR_X509_KEY_INVALID_FORMAT | ret );\n    }\n\n    if( ( ret = asn1_get_tag( &p, end, &len,\n            ASN1_CONSTRUCTED | ASN1_SEQUENCE ) ) == 0 ) {\n        /* Skip over embedded rsaEncryption Object */\n        p+=len;\n\n        /* The RSAPublicKey ASN1 container is wrapped in a BIT STRING */\n        if( ( ret = asn1_get_tag( &p, end, &len,\n                ASN1_BIT_STRING ) ) != 0 ) {\n            return( POLARSSL_ERR_X509_KEY_INVALID_FORMAT | ret );\n        }\n\n        /* Limit range to that BIT STRING */\n        end = p + len;\n        p++;\n\n        if( ( ret = asn1_get_tag( &p, end, &len,\n                ASN1_CONSTRUCTED | ASN1_SEQUENCE ) ) != 0 ) {\n            return( POLARSSL_ERR_X509_KEY_INVALID_FORMAT | ret );\n        }\n    }\n\n    if ( ( ( ret = asn1_get_mpi( &p, end, &(rsa->N)  ) ) == 0 ) &&\n         ( ( ret = asn1_get_mpi( &p, end, &(rsa->E)  ) ) == 0 ) ) {\n        rsa->len = mpi_size( &rsa->N );\n        return 0;\n    }\n\n    return( POLARSSL_ERR_X509_KEY_INVALID_FORMAT | ret );\n}\n- pdkim_hexprint: void pdkim_hexprint(FILE *stream, const char *data, int len, int lf) { /* <=== pdkim_hexprint */ \n  int i;\n  const unsigned char *p = (const unsigned char *)data;\n\n  for (i=0;i<len;i++) {\n    const int c = p[i];\n    fprintf(stream,\"%02x\",c);\n  }\n  if (lf)\n    fputc('\\n',stream);\n}\n- PDKIM_ALGO_RSA_SHA1: #define PDKIM_ALGO_RSA_SHA1       1 /* <=== src/src/pdkim/pdkim.h:63:63:PDKIM_ALGO_RSA_SHA1:0 */ \n- rsa_pkcs1_sign: int rsa_pkcs1_sign( rsa_context *ctx, /* <=== rsa_pkcs1_sign */ \n                    int mode,\n                    int hash_id,\n                    int hashlen,\n                    const unsigned char *hash,\n                    unsigned char *sig )\n{\n    int nb_pad, olen;\n    unsigned char *p = sig;\n\n    olen = ctx->len;\n\n    switch( ctx->padding )\n    {\n        case RSA_PKCS_V15:\n\n            switch( hash_id )\n            {\n                case SIG_RSA_RAW:\n                    nb_pad = olen - 3 - hashlen;\n                    break;\n\n                case SIG_RSA_MD2:\n                case SIG_RSA_MD4:\n                case SIG_RSA_MD5:\n                    nb_pad = olen - 3 - 34;\n                    break;\n\n                case SIG_RSA_SHA1:\n                    nb_pad = olen - 3 - 35;\n                    break;\n\n                case SIG_RSA_SHA224:\n                    nb_pad = olen - 3 - 47;\n                    break;\n\n                case SIG_RSA_SHA256:\n                    nb_pad = olen - 3 - 51;\n                    break;\n\n                case SIG_RSA_SHA384:\n                    nb_pad = olen - 3 - 67;\n                    break;\n\n                case SIG_RSA_SHA512:\n                    nb_pad = olen - 3 - 83;\n                    break;\n\n\n                default:\n                    return( POLARSSL_ERR_RSA_BAD_INPUT_DATA );\n            }\n\n            if( nb_pad < 8 )\n                return( POLARSSL_ERR_RSA_BAD_INPUT_DATA );\n\n            *p++ = 0;\n            *p++ = RSA_SIGN;\n            memset( p, 0xFF, nb_pad );\n            p += nb_pad;\n            *p++ = 0;\n            break;\n\n        default:\n\n            return( POLARSSL_ERR_RSA_INVALID_PADDING );\n    }\n\n    switch( hash_id )\n    {\n        case SIG_RSA_RAW:\n            memcpy( p, hash, hashlen );\n            break;\n\n        case SIG_RSA_MD2:\n            memcpy( p, ASN1_HASH_MDX, 18 );\n            memcpy( p + 18, hash, 16 );\n            p[13] = 2; break;\n\n        case SIG_RSA_MD4:\n            memcpy( p, ASN1_HASH_MDX, 18 );\n            memcpy( p + 18, hash, 16 );\n            p[13] = 4; break;\n\n        case SIG_RSA_MD5:\n            memcpy( p, ASN1_HASH_MDX, 18 );\n            memcpy( p + 18, hash, 16 );\n            p[13] = 5; break;\n\n        case SIG_RSA_SHA1:\n            memcpy( p, ASN1_HASH_SHA1, 15 );\n            memcpy( p + 15, hash, 20 );\n            break;\n\n        case SIG_RSA_SHA224:\n            memcpy( p, ASN1_HASH_SHA2X, 19 );\n            memcpy( p + 19, hash, 28 );\n            p[1] += 28; p[14] = 4; p[18] += 28; break;\n\n        case SIG_RSA_SHA256:\n            memcpy( p, ASN1_HASH_SHA2X, 19 );\n            memcpy( p + 19, hash, 32 );\n            p[1] += 32; p[14] = 1; p[18] += 32; break;\n\n        case SIG_RSA_SHA384:\n            memcpy( p, ASN1_HASH_SHA2X, 19 );\n            memcpy( p + 19, hash, 48 );\n            p[1] += 48; p[14] = 2; p[18] += 48; break;\n\n        case SIG_RSA_SHA512:\n            memcpy( p, ASN1_HASH_SHA2X, 19 );\n            memcpy( p + 19, hash, 64 );\n            p[1] += 64; p[14] = 3; p[18] += 64; break;\n\n        default:\n            return( POLARSSL_ERR_RSA_BAD_INPUT_DATA );\n    }\n\n    return( ( mode == RSA_PUBLIC )\n            ? rsa_public(  ctx, sig, sig )\n            : rsa_private( ctx, sig, sig ) );\n}\n- sha1_starts: void sha1_starts( sha1_context *ctx ) /* <=== sha1_starts */ \n{\n    ctx->total[0] = 0;\n    ctx->total[1] = 0;\n\n    ctx->state[0] = 0x67452301;\n    ctx->state[1] = 0xEFCDAB89;\n    ctx->state[2] = 0x98BADCFE;\n    ctx->state[3] = 0x10325476;\n    ctx->state[4] = 0xC3D2E1F0;\n}\n- pdkim_strnew: pdkim_str *pdkim_strnew (const char *cstr) { /* <=== pdkim_strnew */ \n  unsigned int len = cstr?strlen(cstr):0;\n  pdkim_str *p = malloc(sizeof(pdkim_str));\n  if (p == NULL) return NULL;\n  memset(p,0,sizeof(pdkim_str));\n  p->str = malloc(len+1);\n  if (p->str == NULL) {\n    free(p);\n    return NULL;\n  }\n  p->allocated=(len+1);\n  p->len=len;\n  if (cstr) strcpy(p->str,cstr);\n  else p->str[p->len] = '\\0';\n  return p;\n}\n- rsa_free: void rsa_free( rsa_context *ctx ) /* <=== rsa_free */ \n{\n    mpi_free( &ctx->RQ, &ctx->RP, &ctx->RN,\n              &ctx->QP, &ctx->DQ, &ctx->DP,\n              &ctx->Q,  &ctx->P,  &ctx->D,\n              &ctx->E,  &ctx->N,  NULL );\n}\n- SIG_RSA_SHA1: #define SIG_RSA_SHA1    5 /* <=== src/src/pdkim/rsa.h:119:119:SIG_RSA_SHA1:0 */ \n- PDKIM_VERIFY_FAIL_BODY: #define PDKIM_VERIFY_FAIL_BODY                  1 /* <=== src/src/pdkim/pdkim.h:52:52:PDKIM_VERIFY_FAIL_BODY:0 */ \n- pdkim_relax_header: char *pdkim_relax_header (char *header, int crlf) { /* <=== pdkim_relax_header */ \n  int past_field_name = 0;\n  int seen_wsp = 0;\n  char *p = header;\n  char *q;\n  char *relaxed = malloc(strlen(header)+3);\n  if (relaxed == NULL) return NULL;\n  q = relaxed;\n  while (*p != '\\0') {\n    int c = *p;\n    /* Ignore CR & LF */\n    if ( (c == '\\r') || (c == '\\n') ) {\n      p++;\n      continue;\n    }\n    if ( (c == '\\t') || (c == ' ') ) {\n      c = ' '; /* Turns WSP into SP */\n      if (seen_wsp) {\n        p++;\n        continue;\n      }\n      else seen_wsp = 1;\n    }\n    else {\n      if ( (!past_field_name) && (c == ':') ) {\n        if (seen_wsp) q--;   /* This removes WSP before the colon */\n        seen_wsp = 1;        /* This removes WSP after the colon */\n        past_field_name = 1;\n      }\n      else seen_wsp = 0;\n    }\n    /* Lowercase header name */\n    if (!past_field_name) c = tolower(c);\n    *q = c;\n    p++;\n    q++;\n  }\n  if (seen_wsp) q--;\n  *q = '\\0';\n  if (crlf) strcat(relaxed,\"\\r\\n\");\n  return relaxed;\n}\n- pdkim_verify_ext_status_str: const char *pdkim_verify_ext_status_str(int ext_status) { /* <=== pdkim_verify_ext_status_str */ \n  switch(ext_status) {\n    case PDKIM_VERIFY_FAIL_BODY: return \"PDKIM_VERIFY_FAIL_BODY\";\n    case PDKIM_VERIFY_FAIL_MESSAGE: return \"PDKIM_VERIFY_FAIL_MESSAGE\";\n    case PDKIM_VERIFY_INVALID_PUBKEY_UNAVAILABLE: return \"PDKIM_VERIFY_INVALID_PUBKEY_UNAVAILABLE\";\n    case PDKIM_VERIFY_INVALID_BUFFER_SIZE: return \"PDKIM_VERIFY_INVALID_BUFFER_SIZE\";\n    case PDKIM_VERIFY_INVALID_PUBKEY_PARSING: return \"PDKIM_VERIFY_INVALID_PUBKEY_PARSING\";\n    default: return \"PDKIM_VERIFY_UNKNOWN\";\n  }\n}\n- pdkim_strfree: void pdkim_strfree(pdkim_str *str) { /* <=== pdkim_strfree */ \n  if (str == NULL) return;\n  if (str->str != NULL) free(str->str);\n  free(str);\n}\n- pdkim_feed_finish: DLLEXPORT int pdkim_feed_finish(pdkim_ctx *ctx, pdkim_signature **return_signatures) { /* <=== pdkim_feed_finish */ \n  pdkim_signature *sig = ctx->sig;\n  pdkim_str *headernames = NULL;             /* Collected signed header names */\n\n  /* Check if we must still flush a (partial) header. If that is the\n     case, the message has no body, and we must compute a body hash\n     out of '<CR><LF>' */\n  if (ctx->cur_header && ctx->cur_header->len) {\n    int rc = pdkim_header_complete(ctx);\n    if (rc != PDKIM_OK) return rc;\n    pdkim_update_bodyhash(ctx,\"\\r\\n\",2);\n  }\n  else {\n    /* For non-smtp input, check if there's an unfinished line in the\n       body line buffer. If that is the case, we must add a CRLF to the\n       hash to properly terminate the message. */\n    if ((ctx->input_mode == PDKIM_INPUT_NORMAL) && ctx->linebuf_offset) {\n      pdkim_update_bodyhash(ctx, ctx->linebuf, ctx->linebuf_offset);\n      pdkim_update_bodyhash(ctx,\"\\r\\n\",2);\n    }\n    #ifdef PDKIM_DEBUG\n    if (ctx->debug_stream)\n      fprintf(ctx->debug_stream,\n        \"PDKIM <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\\n\");\n    #endif\n  }\n\n  /* Build (and/or evaluate) body hash */\n  if (pdkim_finish_bodyhash(ctx) != PDKIM_OK) return PDKIM_ERR_OOM;\n\n  /* SIGNING -------------------------------------------------------------- */\n  if (ctx->mode == PDKIM_MODE_SIGN) {\n    headernames = pdkim_strnew(NULL);\n    if (headernames == NULL) return PDKIM_ERR_OOM;\n  }\n  /* ---------------------------------------------------------------------- */\n\n  while (sig != NULL) {\n    sha1_context sha1_headers;\n    sha2_context sha2_headers;\n    char *sig_hdr;\n    char headerhash[32];\n\n    if (sig->algo == PDKIM_ALGO_RSA_SHA1)\n      sha1_starts(&sha1_headers);\n    else\n      sha2_starts(&sha2_headers,0);\n\n    #ifdef PDKIM_DEBUG\n    if (ctx->debug_stream)\n      fprintf(ctx->debug_stream,\n              \"PDKIM >> Hashed header data, canonicalized, in sequence >>>>>>>>>>>>>>\\n\");\n    #endif\n\n    /* SIGNING ---------------------------------------------------------------- */\n    /* When signing, walk through our header list and add them to the hash. As we\n       go, construct a list of the header's names to use for the h= parameter. */\n    if (ctx->mode == PDKIM_MODE_SIGN) {\n      pdkim_stringlist *p = sig->headers;\n      while (p != NULL) {\n        char *rh = NULL;\n        /* Collect header names (Note: colon presence is guaranteed here) */\n        char *q = strchr(p->value,':');\n        if (pdkim_strncat(headernames, p->value,\n                          (q-(p->value))+((p->next==NULL)?0:1)) == NULL)\n          return PDKIM_ERR_OOM;\n\n        if (sig->canon_headers == PDKIM_CANON_RELAXED)\n          rh = pdkim_relax_header(p->value,1); /* cook header for relaxed canon */\n        else\n          rh = strdup(p->value);               /* just copy it for simple canon */\n\n        if (rh == NULL) return PDKIM_ERR_OOM;\n\n        /* Feed header to the hash algorithm */\n        if (sig->algo == PDKIM_ALGO_RSA_SHA1)\n          sha1_update(&(sha1_headers),(unsigned char *)rh,strlen(rh));\n        else\n          sha2_update(&(sha2_headers),(unsigned char *)rh,strlen(rh));\n        #ifdef PDKIM_DEBUG\n        if (ctx->debug_stream)\n          pdkim_quoteprint(ctx->debug_stream, rh, strlen(rh), 1);\n        #endif\n        free(rh);\n        p = p->next;\n      }\n    }\n    /* VERIFICATION ----------------------------------------------------------- */\n    /* When verifying, walk through the header name list in the h= parameter and\n       add the headers to the hash in that order. */\n    else {\n      char *b = strdup(sig->headernames);\n      char *p = b;\n      char *q = NULL;\n      if (b == NULL) return PDKIM_ERR_OOM;\n\n      while(1) {\n        pdkim_stringlist *hdrs = sig->headers;\n        q = strchr(p,':');\n        if (q != NULL) *q = '\\0';\n        while (hdrs != NULL) {\n          if ( (strncasecmp(hdrs->value,p,strlen(p)) == 0) &&\n               ((hdrs->value)[strlen(p)] == ':') ) {\n            char *rh = NULL;\n            if (sig->canon_headers == PDKIM_CANON_RELAXED)\n              rh = pdkim_relax_header(hdrs->value,1); /* cook header for relaxed canon */\n            else\n              rh = strdup(hdrs->value);               /* just copy it for simple canon */\n            if (rh == NULL) return PDKIM_ERR_OOM;\n            /* Feed header to the hash algorithm */\n            if (sig->algo == PDKIM_ALGO_RSA_SHA1)\n              sha1_update(&(sha1_headers),(unsigned char *)rh,strlen(rh));\n            else\n              sha2_update(&(sha2_headers),(unsigned char *)rh,strlen(rh));\n            #ifdef PDKIM_DEBUG\n            if (ctx->debug_stream)\n              pdkim_quoteprint(ctx->debug_stream, rh, strlen(rh), 1);\n            #endif\n            free(rh);\n            (hdrs->value)[0] = '_';\n            break;\n          }\n          hdrs = hdrs->next;\n        }\n        if (q == NULL) break;\n        p = q+1;\n      }\n      free(b);\n    }\n\n    #ifdef PDKIM_DEBUG\n    if (ctx->debug_stream)\n      fprintf(ctx->debug_stream,\n              \"PDKIM <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\\n\");\n    #endif\n\n    /* SIGNING ---------------------------------------------------------------- */\n    if (ctx->mode == PDKIM_MODE_SIGN) {\n      /* Copy headernames to signature struct */\n      sig->headernames = strdup(headernames->str);\n      pdkim_strfree(headernames);\n\n      /* Create signature header with b= omitted */\n      sig_hdr = pdkim_create_header(ctx->sig,0);\n    }\n    /* VERIFICATION ----------------------------------------------------------- */\n    else {\n      sig_hdr = strdup(sig->rawsig_no_b_val);\n    }\n    /* ------------------------------------------------------------------------ */\n\n    if (sig_hdr == NULL) return PDKIM_ERR_OOM;\n\n    /* Relax header if necessary */\n    if (sig->canon_headers == PDKIM_CANON_RELAXED) {\n      char *relaxed_hdr = pdkim_relax_header(sig_hdr,0);\n      free(sig_hdr);\n      if (relaxed_hdr == NULL) return PDKIM_ERR_OOM;\n      sig_hdr = relaxed_hdr;\n    }\n\n    #ifdef PDKIM_DEBUG\n    if (ctx->debug_stream) {\n      fprintf(ctx->debug_stream,\n              \"PDKIM >> Signed DKIM-Signature header, canonicalized >>>>>>>>>>>>>>>>>\\n\");\n      pdkim_quoteprint(ctx->debug_stream, sig_hdr, strlen(sig_hdr), 1);\n      fprintf(ctx->debug_stream,\n              \"PDKIM <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\\n\");\n    }\n    #endif\n\n    /* Finalize header hash */\n    if (sig->algo == PDKIM_ALGO_RSA_SHA1) {\n      sha1_update(&(sha1_headers),(unsigned char *)sig_hdr,strlen(sig_hdr));\n      sha1_finish(&(sha1_headers),(unsigned char *)headerhash);\n      #ifdef PDKIM_DEBUG\n      if (ctx->debug_stream) {\n        fprintf(ctx->debug_stream, \"PDKIM [%s] hh computed: \", sig->domain);\n        pdkim_hexprint(ctx->debug_stream, headerhash, 20, 1);\n      }\n      #endif\n    }\n    else {\n      sha2_update(&(sha2_headers),(unsigned char *)sig_hdr,strlen(sig_hdr));\n      sha2_finish(&(sha2_headers),(unsigned char *)headerhash);\n      #ifdef PDKIM_DEBUG\n      if (ctx->debug_stream) {\n        fprintf(ctx->debug_stream, \"PDKIM [%s] hh computed: \", sig->domain);\n        pdkim_hexprint(ctx->debug_stream, headerhash, 32, 1);\n      }\n      #endif\n    }\n\n    free(sig_hdr);\n\n    /* SIGNING ---------------------------------------------------------------- */\n    if (ctx->mode == PDKIM_MODE_SIGN) {\n      rsa_context rsa;\n\n      rsa_init(&rsa,RSA_PKCS_V15,0);\n\n      /* Perform private key operation */\n      if (rsa_parse_key(&rsa, (unsigned char *)sig->rsa_privkey,\n                        strlen(sig->rsa_privkey), NULL, 0) != 0) {\n        return PDKIM_ERR_RSA_PRIVKEY;\n      }\n\n      sig->sigdata_len = mpi_size(&(rsa.N));\n      sig->sigdata = malloc(sig->sigdata_len);\n      if (sig->sigdata == NULL) return PDKIM_ERR_OOM;\n\n      if (rsa_pkcs1_sign( &rsa, RSA_PRIVATE,\n                          ((sig->algo == PDKIM_ALGO_RSA_SHA1)?\n                             SIG_RSA_SHA1:SIG_RSA_SHA256),\n                          0,\n                          (unsigned char *)headerhash,\n                          (unsigned char *)sig->sigdata ) != 0) {\n        return PDKIM_ERR_RSA_SIGNING;\n      }\n\n      rsa_free(&rsa);\n\n      #ifdef PDKIM_DEBUG\n      if (ctx->debug_stream) {\n        fprintf(ctx->debug_stream, \"PDKIM [%s] b computed: \",\n                sig->domain);\n        pdkim_hexprint(ctx->debug_stream, sig->sigdata, sig->sigdata_len, 1);\n      }\n      #endif\n\n      sig->signature_header = pdkim_create_header(ctx->sig,1);\n      if (sig->signature_header == NULL) return PDKIM_ERR_OOM;\n    }\n    /* VERIFICATION ----------------------------------------------------------- */\n    else {\n      rsa_context rsa;\n      char *dns_txt_name, *dns_txt_reply;\n\n      rsa_init(&rsa,RSA_PKCS_V15,0);\n\n      dns_txt_name  = malloc(PDKIM_DNS_TXT_MAX_NAMELEN);\n      if (dns_txt_name == NULL) return PDKIM_ERR_OOM;\n      dns_txt_reply = malloc(PDKIM_DNS_TXT_MAX_RECLEN);\n      if (dns_txt_reply == NULL) {\n        free(dns_txt_name);\n        return PDKIM_ERR_OOM;\n      }\n      memset(dns_txt_reply,0,PDKIM_DNS_TXT_MAX_RECLEN);\n      memset(dns_txt_name ,0,PDKIM_DNS_TXT_MAX_NAMELEN);\n\n      if (snprintf(dns_txt_name,PDKIM_DNS_TXT_MAX_NAMELEN,\n                   \"%s._domainkey.%s.\",\n                   sig->selector,sig->domain) >= PDKIM_DNS_TXT_MAX_NAMELEN) {\n        sig->verify_status =      PDKIM_VERIFY_INVALID;\n        sig->verify_ext_status =  PDKIM_VERIFY_INVALID_BUFFER_SIZE;\n        goto NEXT_VERIFY;\n      }\n\n      if ((ctx->dns_txt_callback(dns_txt_name, dns_txt_reply) != PDKIM_OK) ||\n          (dns_txt_reply[0] == '\\0')) {\n        sig->verify_status =      PDKIM_VERIFY_INVALID;\n        sig->verify_ext_status =  PDKIM_VERIFY_INVALID_PUBKEY_UNAVAILABLE;\n        goto NEXT_VERIFY;\n      }\n\n      #ifdef PDKIM_DEBUG\n      if (ctx->debug_stream) {\n        fprintf(ctx->debug_stream,\n                \"PDKIM >> Parsing public key record >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\\n\");\n        fprintf(ctx->debug_stream,\"Raw record: \");\n        pdkim_quoteprint(ctx->debug_stream, dns_txt_reply, strlen(dns_txt_reply), 1);\n      }\n      #endif\n\n      sig->pubkey = pdkim_parse_pubkey_record(ctx,dns_txt_reply);\n      if (sig->pubkey == NULL) {\n        sig->verify_status =      PDKIM_VERIFY_INVALID;\n        sig->verify_ext_status =  PDKIM_VERIFY_INVALID_PUBKEY_PARSING;\n        #ifdef PDKIM_DEBUG\n        if (ctx->debug_stream) {\n          fprintf(ctx->debug_stream,\"Error while parsing public key record\\n\");\n          fprintf(ctx->debug_stream,\n            \"PDKIM <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\\n\");\n        }\n        #endif\n        goto NEXT_VERIFY;\n      }\n\n      #ifdef PDKIM_DEBUG\n      if (ctx->debug_stream) {\n        fprintf(ctx->debug_stream,\n          \"PDKIM <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\\n\");\n      }\n      #endif\n\n      if (rsa_parse_public_key(&rsa,\n                              (unsigned char *)sig->pubkey->key,\n                               sig->pubkey->key_len) != 0) {\n        sig->verify_status =      PDKIM_VERIFY_INVALID;\n        sig->verify_ext_status =  PDKIM_VERIFY_INVALID_PUBKEY_PARSING;\n        goto NEXT_VERIFY;\n      }\n\n      /* Check the signature */\n      if (rsa_pkcs1_verify(&rsa,\n                        RSA_PUBLIC,\n                        ((sig->algo == PDKIM_ALGO_RSA_SHA1)?\n                             SIG_RSA_SHA1:SIG_RSA_SHA256),\n                        0,\n                        (unsigned char *)headerhash,\n                        (unsigned char *)sig->sigdata) != 0) {\n        sig->verify_status =      PDKIM_VERIFY_FAIL;\n        sig->verify_ext_status =  PDKIM_VERIFY_FAIL_MESSAGE;\n        goto NEXT_VERIFY;\n      }\n\n      /* We have a winner! (if bodydhash was correct earlier) */\n      if (sig->verify_status == PDKIM_VERIFY_NONE) {\n        sig->verify_status = PDKIM_VERIFY_PASS;\n      }\n\n      NEXT_VERIFY:\n\n      #ifdef PDKIM_DEBUG\n      if (ctx->debug_stream) {\n        fprintf(ctx->debug_stream, \"PDKIM [%s] signature status: %s\",\n                sig->domain, pdkim_verify_status_str(sig->verify_status));\n        if (sig->verify_ext_status > 0) {\n          fprintf(ctx->debug_stream, \" (%s)\\n\",\n                  pdkim_verify_ext_status_str(sig->verify_ext_status));\n        }\n        else {\n          fprintf(ctx->debug_stream, \"\\n\");\n        }\n      }\n      #endif\n\n      rsa_free(&rsa);\n      free(dns_txt_name);\n      free(dns_txt_reply);\n    }\n\n    sig = sig->next;\n  }\n\n  /* If requested, set return pointer to signature(s) */\n  if (return_signatures != NULL) {\n    *return_signatures = ctx->sig;\n  }\n\n  return PDKIM_OK;\n}\n- sha2_starts: void sha2_starts( sha2_context *ctx, int is224 ) /* <=== sha2_starts */ \n{\n    ctx->total[0] = 0;\n    ctx->total[1] = 0;\n\n    if( is224 == 0 )\n    {\n        /* SHA-256 */\n        ctx->state[0] = 0x6A09E667;\n        ctx->state[1] = 0xBB67AE85;\n        ctx->state[2] = 0x3C6EF372;\n        ctx->state[3] = 0xA54FF53A;\n        ctx->state[4] = 0x510E527F;\n        ctx->state[5] = 0x9B05688C;\n        ctx->state[6] = 0x1F83D9AB;\n        ctx->state[7] = 0x5BE0CD19;\n    }\n    else\n    {\n        /* SHA-224 */\n        ctx->state[0] = 0xC1059ED8;\n        ctx->state[1] = 0x367CD507;\n        ctx->state[2] = 0x3070DD17;\n        ctx->state[3] = 0xF70E5939;\n        ctx->state[4] = 0xFFC00B31;\n        ctx->state[5] = 0x68581511;\n        ctx->state[6] = 0x64F98FA7;\n        ctx->state[7] = 0xBEFA4FA4;\n    }\n\n    ctx->is224 = is224;\n}\n- PDKIM_INPUT_NORMAL: #define PDKIM_INPUT_NORMAL  0 /* <=== src/src/pdkim/pdkim.h:254:254:PDKIM_INPUT_NORMAL:0 */ \n- RSA_PUBLIC: #define RSA_PUBLIC      0 /* <=== src/src/pdkim/rsa.h:125:125:RSA_PUBLIC:0 */ \n- PDKIM_VERIFY_INVALID_BUFFER_SIZE: #define PDKIM_VERIFY_INVALID_BUFFER_SIZE        4 /* <=== src/src/pdkim/pdkim.h:55:55:PDKIM_VERIFY_INVALID_BUFFER_SIZE:0 */ \n- PDKIM_VERIFY_NONE: #define PDKIM_VERIFY_NONE      0 /* <=== src/src/pdkim/pdkim.h:47:47:PDKIM_VERIFY_NONE:0 */ \n- sha2_update: void sha2_update( sha2_context *ctx, const unsigned char *input, int ilen ) /* <=== sha2_update */ \n{\n    int fill;\n    unsigned long left;\n\n    if( ilen <= 0 )\n        return;\n\n    left = ctx->total[0] & 0x3F;\n    fill = 64 - left;\n\n    ctx->total[0] += ilen;\n    ctx->total[0] &= 0xFFFFFFFF;\n\n    if( ctx->total[0] < (unsigned long) ilen )\n        ctx->total[1]++;\n\n    if( left && ilen >= fill )\n    {\n        memcpy( (void *) (ctx->buffer + left),\n                (void *) input, fill );\n        sha2_process( ctx, ctx->buffer );\n        input += fill;\n        ilen  -= fill;\n        left = 0;\n    }\n\n    while( ilen >= 64 )\n    {\n        sha2_process( ctx, input );\n        input += 64;\n        ilen  -= 64;\n    }\n\n    if( ilen > 0 )\n    {\n        memcpy( (void *) (ctx->buffer + left),\n                (void *) input, ilen );\n    }\n}\n- PDKIM_DNS_TXT_MAX_NAMELEN: #define PDKIM_DNS_TXT_MAX_NAMELEN   1024 /* <=== src/src/pdkim/pdkim.c:43:43:PDKIM_DNS_TXT_MAX_NAMELEN:0 */ \n- PDKIM_VERIFY_INVALID_PUBKEY_UNAVAILABLE: #define PDKIM_VERIFY_INVALID_PUBKEY_UNAVAILABLE 3 /* <=== src/src/pdkim/pdkim.h:54:54:PDKIM_VERIFY_INVALID_PUBKEY_UNAVAILABLE:0 */ \n- PDKIM_VERIFY_INVALID_PUBKEY_PARSING: #define PDKIM_VERIFY_INVALID_PUBKEY_PARSING     5 /* <=== src/src/pdkim/pdkim.h:56:56:PDKIM_VERIFY_INVALID_PUBKEY_PARSING:0 */ \n- PDKIM_ERR_OOM: #define PDKIM_ERR_OOM              -100 /* <=== src/src/pdkim/pdkim.h:39:39:PDKIM_ERR_OOM:0 */ \n- pdkim_create_header: char *pdkim_create_header(pdkim_signature *sig, int final) { /* <=== pdkim_create_header */ \n  char *rc = NULL;\n  char *base64_bh = NULL;\n  char *base64_b  = NULL;\n  pdkim_str *hdr = pdkim_strnew(\"DKIM-Signature: v=\"PDKIM_SIGNATURE_VERSION);\n  if (hdr == NULL) return NULL;\n\n  base64_bh = pdkim_encode_base64(sig->bodyhash, sig->bodyhash_len);\n  if (base64_bh == NULL) goto BAIL;\n\n  /* Required and static bits */\n  if (\n        pdkim_strcat(hdr,\"; a=\")                                &&\n        pdkim_strcat(hdr,pdkim_algos[sig->algo])                &&\n        pdkim_strcat(hdr,\"; q=\")                                &&\n        pdkim_strcat(hdr,pdkim_querymethods[sig->querymethod])  &&\n        pdkim_strcat(hdr,\"; c=\")                                &&\n        pdkim_strcat(hdr,pdkim_canons[sig->canon_headers])      &&\n        pdkim_strcat(hdr,\"/\")                                   &&\n        pdkim_strcat(hdr,pdkim_canons[sig->canon_body])         &&\n        pdkim_strcat(hdr,\"; d=\")                                &&\n        pdkim_strcat(hdr,sig->domain)                           &&\n        pdkim_strcat(hdr,\"; s=\")                                &&\n        pdkim_strcat(hdr,sig->selector)                         &&\n        pdkim_strcat(hdr,\";\\r\\n\\th=\")                           &&\n        pdkim_strcat(hdr,sig->headernames)                      &&\n        pdkim_strcat(hdr,\"; bh=\")                               &&\n        pdkim_strcat(hdr,base64_bh)                             &&\n        pdkim_strcat(hdr,\";\\r\\n\\t\")\n     ) {\n    /* Optional bits */\n    if (sig->identity != NULL) {\n      if (!( pdkim_strcat(hdr,\"i=\")                             &&\n             pdkim_strcat(hdr,sig->identity)                    &&\n             pdkim_strcat(hdr,\";\") ) ) {\n        goto BAIL;\n      }\n    }\n    if (sig->created > 0) {\n      if (!( pdkim_strcat(hdr,\"t=\")                             &&\n             pdkim_numcat(hdr,sig->created)                     &&\n             pdkim_strcat(hdr,\";\") ) ) {\n        goto BAIL;\n      }\n    }\n    if (sig->expires > 0) {\n      if (!( pdkim_strcat(hdr,\"x=\")                             &&\n             pdkim_numcat(hdr,sig->expires)                     &&\n             pdkim_strcat(hdr,\";\") ) ) {\n        goto BAIL;\n      }\n    }\n    if (sig->bodylength >= 0) {\n      if (!( pdkim_strcat(hdr,\"l=\")                             &&\n             pdkim_numcat(hdr,sig->bodylength)                  &&\n             pdkim_strcat(hdr,\";\") ) ) {\n        goto BAIL;\n      }\n    }\n    /* Extra linebreak */\n    if (hdr->str[(hdr->len)-1] == ';') {\n      if (!pdkim_strcat(hdr,\" \\r\\n\\t\")) goto BAIL;\n    }\n    /* Preliminary or final version? */\n    if (final) {\n      base64_b = pdkim_encode_base64(sig->sigdata, sig->sigdata_len);\n      if (base64_b == NULL) goto BAIL;\n      if (\n            pdkim_strcat(hdr,\"b=\")                              &&\n            pdkim_strcat(hdr,base64_b)                          &&\n            pdkim_strcat(hdr,\";\")\n         ) goto DONE;\n    }\n    else {\n      if (pdkim_strcat(hdr,\"b=;\")) goto DONE;\n    }\n\n    goto BAIL;\n  }\n\n  DONE:\n  rc = strdup(hdr->str);\n\n  BAIL:\n  pdkim_strfree(hdr);\n  if (base64_bh != NULL) free(base64_bh);\n  if (base64_b  != NULL) free(base64_b);\n  return rc;\n}\n- sha2_finish: void sha2_finish( sha2_context *ctx, unsigned char output[32] ) /* <=== sha2_finish */ \n{\n    unsigned long last, padn;\n    unsigned long high, low;\n    unsigned char msglen[8];\n\n    high = ( ctx->total[0] >> 29 )\n         | ( ctx->total[1] <<  3 );\n    low  = ( ctx->total[0] <<  3 );\n\n    PUT_ULONG_BE( high, msglen, 0 );\n    PUT_ULONG_BE( low,  msglen, 4 );\n\n    last = ctx->total[0] & 0x3F;\n    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );\n\n    sha2_update( ctx, (unsigned char *) sha2_padding, padn );\n    sha2_update( ctx, msglen, 8 );\n\n    PUT_ULONG_BE( ctx->state[0], output,  0 );\n    PUT_ULONG_BE( ctx->state[1], output,  4 );\n    PUT_ULONG_BE( ctx->state[2], output,  8 );\n    PUT_ULONG_BE( ctx->state[3], output, 12 );\n    PUT_ULONG_BE( ctx->state[4], output, 16 );\n    PUT_ULONG_BE( ctx->state[5], output, 20 );\n    PUT_ULONG_BE( ctx->state[6], output, 24 );\n\n    if( ctx->is224 == 0 )\n        PUT_ULONG_BE( ctx->state[7], output, 28 );\n}\n- log_write: void /* <=== log_write */ \nlog_write(unsigned int selector, int flags, char *format, ...)\n{\nva_list ap;\nva_start(ap, format);\nvfprintf(stderr, format, ap);\nfprintf(stderr, \"\\n\");\nva_end(ap);\nselector = selector;     /* Keep picky compilers happy */\nflags = flags;\n}\n- US: #define US   (unsigned char *) /* <=== src/src/mytypes.h:60:60:US:0 */ \n- sha1_finish: void sha1_finish( sha1_context *ctx, unsigned char output[20] ) /* <=== sha1_finish */ \n{\n    unsigned long last, padn;\n    unsigned long high, low;\n    unsigned char msglen[8];\n\n    high = ( ctx->total[0] >> 29 )\n         | ( ctx->total[1] <<  3 );\n    low  = ( ctx->total[0] <<  3 );\n\n    PUT_ULONG_BE( high, msglen, 0 );\n    PUT_ULONG_BE( low,  msglen, 4 );\n\n    last = ctx->total[0] & 0x3F;\n    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );\n\n    sha1_update( ctx, (unsigned char *) sha1_padding, padn );\n    sha1_update( ctx, msglen, 8 );\n\n    PUT_ULONG_BE( ctx->state[0], output,  0 );\n    PUT_ULONG_BE( ctx->state[1], output,  4 );\n    PUT_ULONG_BE( ctx->state[2], output,  8 );\n    PUT_ULONG_BE( ctx->state[3], output, 12 );\n    PUT_ULONG_BE( ctx->state[4], output, 16 );\n}\n- Ustrlen: #define Ustrlen(s)         (int)strlen(CCS(s)) /* <=== src/src/mytypes.h:95:95:Ustrlen:1 */ \n- LOG_MAIN: #define LOG_MAIN           1      /* Write to the main log */ /* <=== src/src/macros.h:700:700:LOG_MAIN:0 */ \n- PDKIM_ERR_RSA_SIGNING: #define PDKIM_ERR_RSA_SIGNING      -102 /* <=== src/src/pdkim/pdkim.h:41:41:PDKIM_ERR_RSA_SIGNING:0 */ \n- PDKIM_ALGO_RSA_SHA256: #define PDKIM_ALGO_RSA_SHA256     0 /* <=== src/src/pdkim/pdkim.h:62:62:PDKIM_ALGO_RSA_SHA256:0 */ \n- PDKIM_CANON_RELAXED: #define PDKIM_CANON_RELAXED       1 /* <=== src/src/pdkim/pdkim.h:66:66:PDKIM_CANON_RELAXED:0 */ \n- pdkim_finish_bodyhash: int pdkim_finish_bodyhash(pdkim_ctx *ctx) { /* <=== pdkim_finish_bodyhash */ \n  pdkim_signature *sig = ctx->sig;\n\n  /* Traverse all signatures */\n  while (sig != NULL) {\n\n    /* Finish hashes */\n    unsigned char bh[32]; /* SHA-256 = 32 Bytes,  SHA-1 = 20 Bytes */\n    if (sig->algo == PDKIM_ALGO_RSA_SHA1)\n      sha1_finish(sig->sha1_body,bh);\n    else\n      sha2_finish(sig->sha2_body,bh);\n\n    #ifdef PDKIM_DEBUG\n    if (ctx->debug_stream) {\n      fprintf(ctx->debug_stream, \"PDKIM [%s] Body bytes hashed: %lu\\n\",\n        sig->domain, sig->signed_body_bytes);\n      fprintf(ctx->debug_stream, \"PDKIM [%s] bh  computed: \", sig->domain);\n      pdkim_hexprint(ctx->debug_stream, (char *)bh,\n                     (sig->algo == PDKIM_ALGO_RSA_SHA1)?20:32,1);\n    }\n    #endif\n\n    /* SIGNING -------------------------------------------------------------- */\n    if (ctx->mode == PDKIM_MODE_SIGN) {\n      sig->bodyhash_len = (sig->algo == PDKIM_ALGO_RSA_SHA1)?20:32;\n      sig->bodyhash = malloc(sig->bodyhash_len);\n      if (sig->bodyhash == NULL) return PDKIM_ERR_OOM;\n      memcpy(sig->bodyhash,bh,sig->bodyhash_len);\n\n      /* If bodylength limit is set, and we have received less bytes\n         than the requested amount, effectively remove the limit tag. */\n      if (sig->signed_body_bytes < sig->bodylength) sig->bodylength = -1;\n    }\n    /* VERIFICATION --------------------------------------------------------- */\n    else {\n      /* Compare bodyhash */\n      if (memcmp(bh,sig->bodyhash,\n                 (sig->algo == PDKIM_ALGO_RSA_SHA1)?20:32) == 0) {\n        #ifdef PDKIM_DEBUG\n        if (ctx->debug_stream)\n          fprintf(ctx->debug_stream, \"PDKIM [%s] Body hash verified OK\\n\",\n                  sig->domain);\n        #endif\n      }\n      else {\n        #ifdef PDKIM_DEBUG\n        if (ctx->debug_stream) {\n          fprintf(ctx->debug_stream, \"PDKIM [%s] Body hash did NOT verify\\n\",\n                  sig->domain);\n          fprintf(ctx->debug_stream, \"PDKIM [%s] bh signature: \", sig->domain);\n          pdkim_hexprint(ctx->debug_stream, sig->bodyhash,\n                           (sig->algo == PDKIM_ALGO_RSA_SHA1)?20:32,1);\n        }\n        #endif\n        sig->verify_status     = PDKIM_VERIFY_FAIL;\n        sig->verify_ext_status = PDKIM_VERIFY_FAIL_BODY;\n      }\n    }\n\n    sig = sig->next;\n  }\n\n  return PDKIM_OK;\n}\n- SIG_RSA_SHA256: #define SIG_RSA_SHA256  11 /* <=== src/src/pdkim/rsa.h:121:121:SIG_RSA_SHA256:0 */ \n- PDKIM_VERIFY_PASS: #define PDKIM_VERIFY_PASS      3 /* <=== src/src/pdkim/pdkim.h:50:50:PDKIM_VERIFY_PASS:0 */ \n- PDKIM_VERIFY_FAIL_MESSAGE: #define PDKIM_VERIFY_FAIL_MESSAGE               2 /* <=== src/src/pdkim/pdkim.h:53:53:PDKIM_VERIFY_FAIL_MESSAGE:0 */ \n- PDKIM_CANON_SIMPLE: #define PDKIM_CANON_SIMPLE        0 /* <=== src/src/pdkim/pdkim.h:65:65:PDKIM_CANON_SIMPLE:0 */ \n- string_sprintf: extern uschar *string_sprintf(const char *, ...); /* <=== string_sprintf */ \n- sha1_update: void sha1_update( sha1_context *ctx, const unsigned char *input, int ilen ) /* <=== sha1_update */ \n{\n    int fill;\n    unsigned long left;\n\n    if( ilen <= 0 )\n        return;\n\n    left = ctx->total[0] & 0x3F;\n    fill = 64 - left;\n\n    ctx->total[0] += ilen;\n    ctx->total[0] &= 0xFFFFFFFF;\n\n    if( ctx->total[0] < (unsigned long) ilen )\n        ctx->total[1]++;\n\n    if( left && ilen >= fill )\n    {\n        memcpy( (void *) (ctx->buffer + left),\n                (void *) input, fill );\n        sha1_process( ctx, ctx->buffer );\n        input += fill;\n        ilen  -= fill;\n        left = 0;\n    }\n\n    while( ilen >= 64 )\n    {\n        sha1_process( ctx, input );\n        input += 64;\n        ilen  -= 64;\n    }\n\n    if( ilen > 0 )\n    {\n        memcpy( (void *) (ctx->buffer + left),\n                (void *) input, ilen );\n    }\n}\n- PDKIM_DNS_TXT_MAX_RECLEN: #define PDKIM_DNS_TXT_MAX_RECLEN    4096 /* <=== src/src/pdkim/pdkim.h:33:33:PDKIM_DNS_TXT_MAX_RECLEN:0 */ \n- PDKIM_MODE_SIGN: #define PDKIM_MODE_SIGN     0 /* <=== src/src/pdkim/pdkim.h:252:252:PDKIM_MODE_SIGN:0 */ \n- pdkim_parse_pubkey_record: pdkim_pubkey *pdkim_parse_pubkey_record(pdkim_ctx *ctx, char *raw_record) { /* <=== pdkim_parse_pubkey_record */ \n  pdkim_pubkey *pub ;\n  char *p;\n  pdkim_str *cur_tag = NULL;\n  pdkim_str *cur_val = NULL;\n  int where = PDKIM_HDR_LIMBO;\n\n  pub = malloc(sizeof(pdkim_pubkey));\n  if (pub == NULL) return NULL;\n  memset(pub,0,sizeof(pdkim_pubkey));\n\n  p = raw_record;\n\n  while (1) {\n\n    /* Ignore FWS */\n    if ( (*p == '\\r') || (*p == '\\n') )\n      goto NEXT_CHAR;\n\n    if (where == PDKIM_HDR_LIMBO) {\n      /* In limbo, just wait for a tag-char to appear */\n      if (!((*p >= 'a') && (*p <= 'z')))\n        goto NEXT_CHAR;\n\n      where = PDKIM_HDR_TAG;\n    }\n\n    if (where == PDKIM_HDR_TAG) {\n      if (cur_tag == NULL)\n        cur_tag = pdkim_strnew(NULL);\n\n      if ((*p >= 'a') && (*p <= 'z'))\n        pdkim_strncat(cur_tag,p,1);\n\n      if (*p == '=') {\n        where = PDKIM_HDR_VALUE;\n        goto NEXT_CHAR;\n      }\n    }\n\n    if (where == PDKIM_HDR_VALUE) {\n      if (cur_val == NULL)\n        cur_val = pdkim_strnew(NULL);\n\n      if ( (*p == '\\r') || (*p == '\\n') )\n        goto NEXT_CHAR;\n\n      if ( (*p == ';') || (*p == '\\0') ) {\n        if (cur_tag->len > 0) {\n          pdkim_strtrim(cur_val);\n          #ifdef PDKIM_DEBUG\n          if (ctx->debug_stream)\n            fprintf(ctx->debug_stream, \"%s=%s\\n\", cur_tag->str, cur_val->str);\n          #endif\n          switch (cur_tag->str[0]) {\n            case 'v':\n              /* This tag isn't evaluated because:\n                 - We only support version DKIM1.\n                 - Which is the default for this value (set below)\n                 - Other versions are currently not specified.      */\n            break;\n            case 'h':\n              pub->hashes = strdup(cur_val->str);\n            break;\n            case 'g':\n              pub->granularity = strdup(cur_val->str);\n            break;\n            case 'n':\n              pub->notes = pdkim_decode_qp(cur_val->str);\n            break;\n            case 'p':\n              pub->key = pdkim_decode_base64(cur_val->str,&(pub->key_len));\n            break;\n            case 'k':\n              pub->hashes = strdup(cur_val->str);\n            break;\n            case 's':\n              pub->srvtype = strdup(cur_val->str);\n            break;\n            case 't':\n              if (strchr(cur_val->str,'y') != NULL) pub->testing = 1;\n              if (strchr(cur_val->str,'s') != NULL) pub->no_subdomaining = 1;\n            break;\n            default:\n              #ifdef PDKIM_DEBUG\n              if (ctx->debug_stream)\n                fprintf(ctx->debug_stream, \"Unknown tag encountered\\n\");\n              #endif\n            break;\n          }\n        }\n        pdkim_strclear(cur_tag);\n        pdkim_strclear(cur_val);\n        where = PDKIM_HDR_LIMBO;\n        goto NEXT_CHAR;\n      }\n      else pdkim_strncat(cur_val,p,1);\n    }\n\n    NEXT_CHAR:\n    if (*p == '\\0') break;\n    p++;\n  }\n\n  /* Set fallback defaults */\n  if (pub->version     == NULL) pub->version     = strdup(PDKIM_PUB_RECORD_VERSION);\n  if (pub->granularity == NULL) pub->granularity = strdup(\"*\");\n  if (pub->keytype     == NULL) pub->keytype     = strdup(\"rsa\");\n  if (pub->srvtype     == NULL) pub->srvtype     = strdup(\"*\");\n\n  /* p= is required */\n  if (pub->key == NULL) {\n    pdkim_free_pubkey(pub);\n    return NULL;\n  }\n\n  return pub;\n}\n- rsa_init: void rsa_init( rsa_context *ctx, /* <=== rsa_init */ \n               int padding,\n               int hash_id )\n{\n    memset( ctx, 0, sizeof( rsa_context ) );\n\n    ctx->padding = padding;\n    ctx->hash_id = hash_id;\n}\n- RSA_PKCS_V15: #define RSA_PKCS_V15    0 /* <=== src/src/pdkim/rsa.h:128:128:RSA_PKCS_V15:0 */ \n- pdkim_verify_status_str: const char *pdkim_verify_status_str(int status) { /* <=== pdkim_verify_status_str */ \n  switch(status) {\n    case PDKIM_VERIFY_NONE:    return \"PDKIM_VERIFY_NONE\";\n    case PDKIM_VERIFY_INVALID: return \"PDKIM_VERIFY_INVALID\";\n    case PDKIM_VERIFY_FAIL:    return \"PDKIM_VERIFY_FAIL\";\n    case PDKIM_VERIFY_PASS:    return \"PDKIM_VERIFY_PASS\";\n    default:                   return \"PDKIM_VERIFY_UNKNOWN\";\n  }\n}\n- pdkim_update_bodyhash: int pdkim_update_bodyhash(pdkim_ctx *ctx, const char *data, int len) { /* <=== pdkim_update_bodyhash */ \n  pdkim_signature *sig = ctx->sig;\n  /* Cache relaxed version of data */\n  char *relaxed_data = NULL;\n  int   relaxed_len  = 0;\n\n  /* Traverse all signatures, updating their hashes. */\n  while (sig != NULL) {\n    /* Defaults to simple canon (no further treatment necessary) */\n    const char *canon_data = data;\n    int         canon_len = len;\n\n    if (sig->canon_body == PDKIM_CANON_RELAXED) {\n      /* Relax the line if not done already */\n      if (relaxed_data == NULL) {\n        int seen_wsp = 0;\n        const char *p = data;\n        int q = 0;\n        relaxed_data = malloc(len+1);\n        if (relaxed_data == NULL) return PDKIM_ERR_OOM;\n        while (*p != '\\0') {\n          char c = *p;\n          if (c == '\\r') {\n            if ( (q > 0) && (relaxed_data[q-1] == ' ') ) q--;\n          }\n          else if ( (c == '\\t') || (c == ' ') ) {\n            c = ' '; /* Turns WSP into SP */\n            if (seen_wsp) {\n              p++;\n              continue;\n            }\n            else seen_wsp = 1;\n          }\n          else seen_wsp = 0;\n          relaxed_data[q++] = c;\n          p++;\n        }\n        relaxed_data[q] = '\\0';\n        relaxed_len = q;\n      }\n      canon_data = relaxed_data;\n      canon_len  = relaxed_len;\n    }\n\n    /* Make sure we don't exceed the to-be-signed body length */\n    if ((sig->bodylength >= 0) &&\n        ((sig->signed_body_bytes+(unsigned long)canon_len) > sig->bodylength))\n      canon_len = (sig->bodylength - sig->signed_body_bytes);\n\n    if (canon_len > 0) {\n      if (sig->algo == PDKIM_ALGO_RSA_SHA1)\n        sha1_update(sig->sha1_body,(unsigned char *)canon_data,canon_len);\n      else\n        sha2_update(sig->sha2_body,(unsigned char *)canon_data,canon_len);\n      sig->signed_body_bytes += canon_len;\n#ifdef PDKIM_DEBUG\n      if (ctx->debug_stream!=NULL)\n        pdkim_quoteprint(ctx->debug_stream,canon_data,canon_len,0);\n#endif\n    }\n\n    sig = sig->next;\n  }\n\n  if (relaxed_data != NULL) free(relaxed_data);\n  return PDKIM_OK;\n}\n- pdkim_strncat: char *pdkim_strncat(pdkim_str *str, const char *data, int len) { /* <=== pdkim_strncat */ \n  if ((str->allocated - str->len) < (len+1)) {\n    /* Extend the buffer */\n    int num_frags = ((len+1)/PDKIM_STR_ALLOC_FRAG)+1;\n    char *n = realloc(str->str,\n                      (str->allocated+(num_frags*PDKIM_STR_ALLOC_FRAG)));\n    if (n == NULL) return NULL;\n    str->str = n;\n    str->allocated += (num_frags*PDKIM_STR_ALLOC_FRAG);\n  }\n  strncpy(&(str->str[str->len]),data,len);\n  str->len+=len;\n  str->str[str->len] = '\\0';\n  return str->str;\n}\n\nType Definitions:\n- pdkim_ctx: typedef struct pdkim_ctx {\n\n  /* PDKIM_MODE_VERIFY or PDKIM_MODE_SIGN */\n  int mode;\n\n  /* PDKIM_INPUT_SMTP or PDKIM_INPUT_NORMAL */\n  int input_mode;\n\n  /* One (signing) or several chained (verification) signatures */\n  pdkim_signature *sig;\n\n  /* Callback for dns/txt query method (verification only) */\n  int(*dns_txt_callback)(char *, char *);\n\n  /* Coder's little helpers */\n  pdkim_str *cur_header;\n  char      *linebuf;\n  int        linebuf_offset;\n  int        seen_lf;\n  int        seen_eod;\n  int        past_headers;\n  int        num_buffered_crlf;\n  int        num_headers;\n\n#ifdef PDKIM_DEBUG\n  /* A FILE pointer. When not NULL, debug output will be generated\n    and sent to this stream */\n  FILE *debug_stream;\n#endif\n\n}\n- pdkim_signature: typedef struct pdkim_signature {\n\n  /* Bits stored in a DKIM signature header --------------------------- */\n\n  /* (v=) The version, as an integer. Currently, always \"1\" */\n  int version;\n\n  /* (a=) The signature algorithm. Either PDKIM_ALGO_RSA_SHA256\n     or PDKIM_ALGO_RSA_SHA1 */\n  int algo;\n\n  /* (c=x/) Header canonicalization method. Either PDKIM_CANON_SIMPLE\n     or PDKIM_CANON_RELAXED */\n  int canon_headers;\n\n  /* (c=/x) Body canonicalization method. Either PDKIM_CANON_SIMPLE\n     or PDKIM_CANON_RELAXED */\n  int canon_body;\n\n  /* (q=) Query Method. Currently, only PDKIM_QUERYMETHOD_DNS_TXT\n     is specified */\n  int querymethod;\n\n  /* (s=) The selector string as given in the signature */\n  char *selector;\n\n  /* (d=) The domain as given in the signature */\n  char *domain;\n\n  /* (i=) The identity as given in the signature */\n  char *identity;\n\n  /* (t=) Timestamp of signature creation */\n  unsigned long created;\n\n  /* (x=) Timestamp of expiry of signature */\n  unsigned long expires;\n\n  /* (l=) Amount of hashed body bytes (after canonicalization). Default\n     is -1. Note: a value of 0 means that the body is unsigned! */\n  long bodylength;\n\n  /* (h=) Colon-separated list of header names that are included in the\n     signature */\n  char *headernames;\n\n  /* (z=) */\n  char *copiedheaders;\n\n  /* (b=) Raw signature data, along with its length in bytes */\n  char *sigdata;\n  int   sigdata_len;\n\n  /* (bh=) Raw body hash data, along with its length in bytes */\n  char *bodyhash;\n  int   bodyhash_len;\n\n  /* Folded DKIM-Signature: header. Singing only, NULL for verifying.\n     Ready for insertion into the message. Note: Folded using CRLFTB,\n     but final line terminator is NOT included. Note2: This buffer is\n     free()d when you call pdkim_free_ctx(). */\n  char *signature_header;\n\n  /* The main verification status. Verification only. One of:\n\n     PDKIM_VERIFY_NONE      Verification was not attempted. This status\n                            should not appear.\n\n     PDKIM_VERIFY_INVALID   There was an error while trying to verify\n                            the signature. A more precise description\n                            is available in verify_ext_status.\n\n     PDKIM_VERIFY_FAIL      Verification failed because either the body\n                            hash did not match, or the signature verification\n                            failed. This means the message was modified.\n                            Check verify_ext_status for the exact reason.\n\n     PDKIM_VERIFY_PASS      Verification succeeded.\n  */\n  int verify_status;\n\n  /* Extended verification status. Verification only. Depending on the value\n     of verify_status, it can contain:\n\n     For verify_status == PDKIM_VERIFY_INVALID:\n\n        PDKIM_VERIFY_INVALID_PUBKEY_UNAVAILABLE\n          Unable to retrieve a public key container.\n\n        PDKIM_VERIFY_INVALID_BUFFER_SIZE\n          Either the DNS name constructed to retrieve the public key record\n          does not fit into PDKIM_DNS_TXT_MAX_NAMELEN bytes, or the retrieved\n          record is longer than PDKIM_DNS_TXT_MAX_RECLEN bytes.\n\n        PDKIM_VERIFY_INVALID_PUBKEY_PARSING\n          (Syntax) error while parsing the retrieved public key record.\n\n\n     For verify_status == PDKIM_VERIFY_FAIL:\n\n        PDKIM_VERIFY_FAIL_BODY\n          The calculated body hash does not match the advertised body hash\n          from the bh= tag of the signature.\n\n        PDKIM_VERIFY_FAIL_MESSAGE\n          RSA verification of the signature (b= tag) failed.\n  */\n  int verify_ext_status;\n\n  /* Pointer to a public key record that was used to verify the signature.\n     See pdkim_pubkey declaration above for more information.\n     Caution: is NULL if signing or if no record was retrieved. */\n  pdkim_pubkey *pubkey;\n\n  /* Pointer to the next pdkim_signature signature. NULL if signing or if\n     this is the last signature. */\n  void *next;\n\n  /* Properties below this point are used internally only ------------- */\n\n  /* Per-signature helper variables ----------------------------------- */\n  sha1_context *sha1_body; /* SHA1 block                                */\n  sha2_context *sha2_body; /* SHA256 block                              */\n  unsigned long signed_body_bytes; /* How many body bytes we hashed     */\n  pdkim_stringlist *headers; /* Raw headers included in the sig         */\n  /* Signing specific ------------------------------------------------- */\n  char *rsa_privkey;     /* Private RSA key                             */\n  char *sign_headers;    /* To-be-signed header names                   */\n  /* Verification specific -------------------------------------------- */\n  char *hnames_check;    /* Tick-off header list that we use to keep\n                            track of header names that we have already\n                            added to the signature candidates.          */\n  char *rawsig_no_b_val; /* Original signature header w/o b= tag value. */\n}\n\nGlobal Variables:\n- pdkim_signature* dkim_signatures\n- pdkim_ctx* dkim_verify_ctx\n\nImports:\n- #include \"pdkim/pdkim.h\"\n- #include \"exim.h\"",
    "commit_msg": "Bugzilla #1106: Don't pass DKIM compound log line as format string",
    "cve_desc": "Format string vulnerability in the dkim_exim_verify_finish function in src/dkim.c in Exim before 4.76 might allow remote attackers to execute arbitrary code or cause a denial of service (daemon crash) via format string specifiers in data used in DKIM logging, as demonstrated by an identity field containing a % (percent) character.",
    "year": 2011,
    "filename": "dkim.c",
    "commit_url": "\"https://github.com/Exim/exim/commit/337e3505b0e6cd4309db6bf6062b33fa56e06cf8\""
  },
  {
    "repository": "GNOME/gimp",
    "cve_id": "CVE-2011-1782",
    "cwe_list": [
      "CWE-787"
    ],
    "commit_hash": "48ec15890e1751dede061f6d1f469b6508c13439",
    "short_hash": "48ec1589",
    "vulnerableMethods_before": [
      {
        "filename": "plug-ins/common/file-psp.c",
        "method_name": "read_channel_data",
        "raw_code": "static int /* <=== read_channel_data */ \nread_channel_data (FILE       *f,\n                   PSPimage   *ia,\n                   guchar    **pixels,\n                   guint       bytespp,\n                   guint       offset,\n                   GimpDrawable  *drawable,\n                   guint32     compressed_len)\n{\n  gint i, y, width = drawable->width, height = drawable->height;\n  gint npixels = width * height;\n  guchar *buf, *p, *q, *endq;\n  guchar *buf2 = NULL;  /* please the compiler */\n  guchar runcount, byte;\n  z_stream zstream;\n\n  switch (ia->compression)\n    {\n    case PSP_COMP_NONE:\n      if (bytespp == 1)\n        {\n          if ((width % 4) == 0)\n            fread (pixels[0], height * width, 1, f);\n          else\n            {\n              for (y = 0; y < height; y++)\n                {\n                  fread (pixels[y], width, 1, f);\n                  fseek (f, 4 - (width % 4), SEEK_CUR);\n                }\n            }\n        }\n      else\n        {\n          buf = g_malloc (width);\n          for (y = 0; y < height; y++)\n            {\n              fread (buf, width, 1, f);\n              if (width % 4)\n                fseek (f, 4 - (width % 4), SEEK_CUR);\n              p = buf;\n              q = pixels[y] + offset;\n              for (i = 0; i < width; i++)\n                {\n                  *q = *p++;\n                  q += bytespp;\n                }\n            }\n          g_free (buf);\n        }\n      break;\n\n    case PSP_COMP_RLE:\n      q = pixels[0] + offset;\n      endq = q + npixels * bytespp;\n      buf = g_malloc (127);\n      while (q < endq)\n        {\n          p = buf;\n          fread (&runcount, 1, 1, f);\n          if (runcount > 128)\n            {\n              runcount -= 128;\n              fread (&byte, 1, 1, f);\n              memset (buf, byte, runcount);\n            }\n          else\n            fread (buf, runcount, 1, f);\n          if (bytespp == 1)\n            {\n              memmove (q, buf, runcount);\n              q += runcount;\n            }\n          else\n            {\n              p = buf;\n              for (i = 0; i < runcount; i++)\n                {\n                  *q = *p++;\n                  q += bytespp;\n                }\n            }\n        }\n      g_free (buf);\n      break;\n\n    case PSP_COMP_LZ77:\n      buf = g_malloc (compressed_len);\n      fread (buf, compressed_len, 1, f);\n      zstream.next_in = buf;\n      zstream.avail_in = compressed_len;\n      zstream.zalloc = psp_zalloc;\n      zstream.zfree = psp_zfree;\n      zstream.opaque = f;\n      if (inflateInit (&zstream) != Z_OK)\n        {\n          g_message (\"zlib error\");\n          return -1;\n        }\n      if (bytespp == 1)\n        zstream.next_out = pixels[0];\n      else\n        {\n          buf2 = g_malloc (npixels);\n          zstream.next_out = buf2;\n        }\n      zstream.avail_out = npixels;\n      if (inflate (&zstream, Z_FINISH) != Z_STREAM_END)\n        {\n          g_message (\"zlib error\");\n          inflateEnd (&zstream);\n          return -1;\n        }\n      inflateEnd (&zstream);\n      g_free (buf);\n\n      if (bytespp > 1)\n        {\n          p = buf2;\n          q = pixels[0] + offset;\n          for (i = 0; i < npixels; i++)\n            {\n              *q = *p++;\n              q += bytespp;\n            }\n          g_free (buf2);\n        }\n      break;\n    }\n\n  return 0;\n}",
        "start_line": 1132
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "plug-ins/common/file-psp.c",
        "method_name": "read_channel_data",
        "raw_code": "static int /* <=== read_channel_data */ \nread_channel_data (FILE       *f,\n                   PSPimage   *ia,\n                   guchar    **pixels,\n                   guint       bytespp,\n                   guint       offset,\n                   GimpDrawable  *drawable,\n                   guint32     compressed_len)\n{\n  gint i, y, width = drawable->width, height = drawable->height;\n  gint npixels = width * height;\n  guchar *buf, *p, *q, *endq;\n  guchar *buf2 = NULL;  /* please the compiler */\n  guchar runcount, byte;\n  z_stream zstream;\n\n  switch (ia->compression)\n    {\n    case PSP_COMP_NONE:\n      if (bytespp == 1)\n        {\n          if ((width % 4) == 0)\n            fread (pixels[0], height * width, 1, f);\n          else\n            {\n              for (y = 0; y < height; y++)\n                {\n                  fread (pixels[y], width, 1, f);\n                  fseek (f, 4 - (width % 4), SEEK_CUR);\n                }\n            }\n        }\n      else\n        {\n          buf = g_malloc (width);\n          for (y = 0; y < height; y++)\n            {\n              fread (buf, width, 1, f);\n              if (width % 4)\n                fseek (f, 4 - (width % 4), SEEK_CUR);\n              p = buf;\n              q = pixels[y] + offset;\n              for (i = 0; i < width; i++)\n                {\n                  *q = *p++;\n                  q += bytespp;\n                }\n            }\n          g_free (buf);\n        }\n      break;\n\n    case PSP_COMP_RLE:\n      q = pixels[0] + offset;\n      endq = q + npixels * bytespp;\n      buf = g_malloc (127);\n      while (q < endq)\n        {\n          p = buf;\n          fread (&runcount, 1, 1, f);\n          if (runcount > 128)\n            {\n              runcount -= 128;\n              fread (&byte, 1, 1, f);\n              memset (buf, byte, runcount);\n            }\n          else\n            fread (buf, runcount, 1, f);\n\n          /* prevent buffer overflow for bogus data */\n          runcount = MIN (runcount, endq - q);\n\n          if (bytespp == 1)\n            {\n              memmove (q, buf, runcount);\n              q += runcount;\n            }\n          else\n            {\n              p = buf;\n              for (i = 0; i < runcount; i++)\n                {\n                  *q = *p++;\n                  q += bytespp;\n                }\n            }\n        }\n      g_free (buf);\n      break;\n\n    case PSP_COMP_LZ77:\n      buf = g_malloc (compressed_len);\n      fread (buf, compressed_len, 1, f);\n      zstream.next_in = buf;\n      zstream.avail_in = compressed_len;\n      zstream.zalloc = psp_zalloc;\n      zstream.zfree = psp_zfree;\n      zstream.opaque = f;\n      if (inflateInit (&zstream) != Z_OK)\n        {\n          g_message (\"zlib error\");\n          return -1;\n        }\n      if (bytespp == 1)\n        zstream.next_out = pixels[0];\n      else\n        {\n          buf2 = g_malloc (npixels);\n          zstream.next_out = buf2;\n        }\n      zstream.avail_out = npixels;\n      if (inflate (&zstream, Z_FINISH) != Z_STREAM_END)\n        {\n          g_message (\"zlib error\");\n          inflateEnd (&zstream);\n          return -1;\n        }\n      inflateEnd (&zstream);\n      g_free (buf);\n\n      if (bytespp > 1)\n        {\n          p = buf2;\n          q = pixels[0] + offset;\n          for (i = 0; i < npixels; i++)\n            {\n              *q = *p++;\n              q += bytespp;\n            }\n          g_free (buf2);\n        }\n      break;\n    }\n\n  return 0;\n}",
        "start_line": 1132
      }
    ],
    "code_context": "Type Definitions:\n- GimpDrawable: typedef struct _GimpDrawable    GimpDrawable;\n- PSPimage: typedef struct\n{\n  guint32 width, height;\n  gdouble resolution;\n  guchar metric;\n  guint16 compression;\n  guint16 depth;\n  guchar greyscale;\n  guint32 active_layer;\n  guint16 layer_count;\n}\n\nImports:\n- #include \"config.h\"\n- #include <zlib.h>\n- #include <errno.h>\n- #include <string.h>\n- #include <libgimp/gimp.h>\n- #include <libgimpbase/gimpparasiteio.h>\n- #include \"libgimp/stdplugins-intl.h\"\n- #include <glib/gstdio.h>\n- #include <libgimp/gimpui.h>",
    "commit_msg": "file-psp: fix for bogus input data. Fixes bug #639203",
    "cve_desc": "Heap-based buffer overflow in the read_channel_data function in file-psp.c in the Paint Shop Pro (PSP) plugin in GIMP 2.6.11 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a PSP_COMP_RLE (aka RLE compression) image file that begins a long run count at the end of the image.  NOTE: some of these details are obtained from third party information.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2010-4543.",
    "year": 2011,
    "filename": "file-psp.c",
    "commit_url": "\"https://github.com/GNOME/gimp/commit/48ec15890e1751dede061f6d1f469b6508c13439\""
  },
  {
    "repository": "torvalds/linux",
    "cve_id": "CVE-2011-1833",
    "cwe_list": [
      "CWE-362"
    ],
    "commit_hash": "764355487ea220fdc2faf128d577d7f679b91f97",
    "short_hash": "76435548",
    "vulnerableMethods_before": [
      {
        "filename": "fs/ecryptfs/main.c",
        "method_name": "ecryptfs_parse_options",
        "raw_code": "static int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options) /* <=== ecryptfs_parse_options */ \n{\n\tchar *p;\n\tint rc = 0;\n\tint sig_set = 0;\n\tint cipher_name_set = 0;\n\tint fn_cipher_name_set = 0;\n\tint cipher_key_bytes;\n\tint cipher_key_bytes_set = 0;\n\tint fn_cipher_key_bytes;\n\tint fn_cipher_key_bytes_set = 0;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\n\t\t&sbi->mount_crypt_stat;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint token;\n\tchar *sig_src;\n\tchar *cipher_name_dst;\n\tchar *cipher_name_src;\n\tchar *fn_cipher_name_dst;\n\tchar *fn_cipher_name_src;\n\tchar *fnek_dst;\n\tchar *fnek_src;\n\tchar *cipher_key_bytes_src;\n\tchar *fn_cipher_key_bytes_src;\n\n\tif (!options) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tecryptfs_init_mount_crypt_stat(mount_crypt_stat);\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase ecryptfs_opt_sig:\n\t\tcase ecryptfs_opt_ecryptfs_sig:\n\t\t\tsig_src = args[0].from;\n\t\t\trc = ecryptfs_add_global_auth_tok(mount_crypt_stat,\n\t\t\t\t\t\t\t  sig_src, 0);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"Error attempting to register \"\n\t\t\t\t       \"global sig; rc = [%d]\\n\", rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsig_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_cipher:\n\t\tcase ecryptfs_opt_ecryptfs_cipher:\n\t\t\tcipher_name_src = args[0].from;\n\t\t\tcipher_name_dst =\n\t\t\t\tmount_crypt_stat->\n\t\t\t\tglobal_default_cipher_name;\n\t\t\tstrncpy(cipher_name_dst, cipher_name_src,\n\t\t\t\tECRYPTFS_MAX_CIPHER_NAME_SIZE);\n\t\t\tcipher_name_dst[ECRYPTFS_MAX_CIPHER_NAME_SIZE] = '\\0';\n\t\t\tcipher_name_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_ecryptfs_key_bytes:\n\t\t\tcipher_key_bytes_src = args[0].from;\n\t\t\tcipher_key_bytes =\n\t\t\t\t(int)simple_strtol(cipher_key_bytes_src,\n\t\t\t\t\t\t   &cipher_key_bytes_src, 0);\n\t\t\tmount_crypt_stat->global_default_cipher_key_size =\n\t\t\t\tcipher_key_bytes;\n\t\t\tcipher_key_bytes_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_passthrough:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_PLAINTEXT_PASSTHROUGH_ENABLED;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_xattr_metadata:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_XATTR_METADATA_ENABLED;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_encrypted_view:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_XATTR_METADATA_ENABLED;\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_ENCRYPTED_VIEW_ENABLED;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_fnek_sig:\n\t\t\tfnek_src = args[0].from;\n\t\t\tfnek_dst =\n\t\t\t\tmount_crypt_stat->global_default_fnek_sig;\n\t\t\tstrncpy(fnek_dst, fnek_src, ECRYPTFS_SIG_SIZE_HEX);\n\t\t\tmount_crypt_stat->global_default_fnek_sig[\n\t\t\t\tECRYPTFS_SIG_SIZE_HEX] = '\\0';\n\t\t\trc = ecryptfs_add_global_auth_tok(\n\t\t\t\tmount_crypt_stat,\n\t\t\t\tmount_crypt_stat->global_default_fnek_sig,\n\t\t\t\tECRYPTFS_AUTH_TOK_FNEK);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"Error attempting to register \"\n\t\t\t\t       \"global fnek sig [%s]; rc = [%d]\\n\",\n\t\t\t\t       mount_crypt_stat->global_default_fnek_sig,\n\t\t\t\t       rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\t(ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES\n\t\t\t\t | ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK);\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_fn_cipher:\n\t\t\tfn_cipher_name_src = args[0].from;\n\t\t\tfn_cipher_name_dst =\n\t\t\t\tmount_crypt_stat->global_default_fn_cipher_name;\n\t\t\tstrncpy(fn_cipher_name_dst, fn_cipher_name_src,\n\t\t\t\tECRYPTFS_MAX_CIPHER_NAME_SIZE);\n\t\t\tmount_crypt_stat->global_default_fn_cipher_name[\n\t\t\t\tECRYPTFS_MAX_CIPHER_NAME_SIZE] = '\\0';\n\t\t\tfn_cipher_name_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_fn_cipher_key_bytes:\n\t\t\tfn_cipher_key_bytes_src = args[0].from;\n\t\t\tfn_cipher_key_bytes =\n\t\t\t\t(int)simple_strtol(fn_cipher_key_bytes_src,\n\t\t\t\t\t\t   &fn_cipher_key_bytes_src, 0);\n\t\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes =\n\t\t\t\tfn_cipher_key_bytes;\n\t\t\tfn_cipher_key_bytes_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_unlink_sigs:\n\t\t\tmount_crypt_stat->flags |= ECRYPTFS_UNLINK_SIGS;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_mount_auth_tok_only:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_err:\n\t\tdefault:\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"%s: eCryptfs: unrecognized option [%s]\\n\",\n\t\t\t       __func__, p);\n\t\t}\n\t}\n\tif (!sig_set) {\n\t\trc = -EINVAL;\n\t\tecryptfs_printk(KERN_ERR, \"You must supply at least one valid \"\n\t\t\t\t\"auth tok signature as a mount \"\n\t\t\t\t\"parameter; see the eCryptfs README\\n\");\n\t\tgoto out;\n\t}\n\tif (!cipher_name_set) {\n\t\tint cipher_name_len = strlen(ECRYPTFS_DEFAULT_CIPHER);\n\n\t\tBUG_ON(cipher_name_len >= ECRYPTFS_MAX_CIPHER_NAME_SIZE);\n\t\tstrcpy(mount_crypt_stat->global_default_cipher_name,\n\t\t       ECRYPTFS_DEFAULT_CIPHER);\n\t}\n\tif ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)\n\t    && !fn_cipher_name_set)\n\t\tstrcpy(mount_crypt_stat->global_default_fn_cipher_name,\n\t\t       mount_crypt_stat->global_default_cipher_name);\n\tif (!cipher_key_bytes_set)\n\t\tmount_crypt_stat->global_default_cipher_key_size = 0;\n\tif ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)\n\t    && !fn_cipher_key_bytes_set)\n\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes =\n\t\t\tmount_crypt_stat->global_default_cipher_key_size;\n\tmutex_lock(&key_tfm_list_mutex);\n\tif (!ecryptfs_tfm_exists(mount_crypt_stat->global_default_cipher_name,\n\t\t\t\t NULL)) {\n\t\trc = ecryptfs_add_new_key_tfm(\n\t\t\tNULL, mount_crypt_stat->global_default_cipher_name,\n\t\t\tmount_crypt_stat->global_default_cipher_key_size);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Error attempting to initialize \"\n\t\t\t       \"cipher with name = [%s] and key size = [%td]; \"\n\t\t\t       \"rc = [%d]\\n\",\n\t\t\t       mount_crypt_stat->global_default_cipher_name,\n\t\t\t       mount_crypt_stat->global_default_cipher_key_size,\n\t\t\t       rc);\n\t\t\trc = -EINVAL;\n\t\t\tmutex_unlock(&key_tfm_list_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)\n\t    && !ecryptfs_tfm_exists(\n\t\t    mount_crypt_stat->global_default_fn_cipher_name, NULL)) {\n\t\trc = ecryptfs_add_new_key_tfm(\n\t\t\tNULL, mount_crypt_stat->global_default_fn_cipher_name,\n\t\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Error attempting to initialize \"\n\t\t\t       \"cipher with name = [%s] and key size = [%td]; \"\n\t\t\t       \"rc = [%d]\\n\",\n\t\t\t       mount_crypt_stat->global_default_fn_cipher_name,\n\t\t\t       mount_crypt_stat->global_default_fn_cipher_key_bytes,\n\t\t\t       rc);\n\t\t\trc = -EINVAL;\n\t\t\tmutex_unlock(&key_tfm_list_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmutex_unlock(&key_tfm_list_mutex);\n\trc = ecryptfs_init_global_auth_toks(mount_crypt_stat);\n\tif (rc)\n\t\tprintk(KERN_WARNING \"One or more global auth toks could not \"\n\t\t       \"properly register; rc = [%d]\\n\", rc);\nout:\n\treturn rc;\n}",
        "start_line": 254
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "fs/ecryptfs/main.c",
        "method_name": "ecryptfs_parse_options",
        "raw_code": "static int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options, /* <=== ecryptfs_parse_options */ \n\t\t\t\t  uid_t *check_ruid)\n{\n\tchar *p;\n\tint rc = 0;\n\tint sig_set = 0;\n\tint cipher_name_set = 0;\n\tint fn_cipher_name_set = 0;\n\tint cipher_key_bytes;\n\tint cipher_key_bytes_set = 0;\n\tint fn_cipher_key_bytes;\n\tint fn_cipher_key_bytes_set = 0;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\n\t\t&sbi->mount_crypt_stat;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint token;\n\tchar *sig_src;\n\tchar *cipher_name_dst;\n\tchar *cipher_name_src;\n\tchar *fn_cipher_name_dst;\n\tchar *fn_cipher_name_src;\n\tchar *fnek_dst;\n\tchar *fnek_src;\n\tchar *cipher_key_bytes_src;\n\tchar *fn_cipher_key_bytes_src;\n\n\t*check_ruid = 0;\n\n\tif (!options) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tecryptfs_init_mount_crypt_stat(mount_crypt_stat);\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase ecryptfs_opt_sig:\n\t\tcase ecryptfs_opt_ecryptfs_sig:\n\t\t\tsig_src = args[0].from;\n\t\t\trc = ecryptfs_add_global_auth_tok(mount_crypt_stat,\n\t\t\t\t\t\t\t  sig_src, 0);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"Error attempting to register \"\n\t\t\t\t       \"global sig; rc = [%d]\\n\", rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsig_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_cipher:\n\t\tcase ecryptfs_opt_ecryptfs_cipher:\n\t\t\tcipher_name_src = args[0].from;\n\t\t\tcipher_name_dst =\n\t\t\t\tmount_crypt_stat->\n\t\t\t\tglobal_default_cipher_name;\n\t\t\tstrncpy(cipher_name_dst, cipher_name_src,\n\t\t\t\tECRYPTFS_MAX_CIPHER_NAME_SIZE);\n\t\t\tcipher_name_dst[ECRYPTFS_MAX_CIPHER_NAME_SIZE] = '\\0';\n\t\t\tcipher_name_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_ecryptfs_key_bytes:\n\t\t\tcipher_key_bytes_src = args[0].from;\n\t\t\tcipher_key_bytes =\n\t\t\t\t(int)simple_strtol(cipher_key_bytes_src,\n\t\t\t\t\t\t   &cipher_key_bytes_src, 0);\n\t\t\tmount_crypt_stat->global_default_cipher_key_size =\n\t\t\t\tcipher_key_bytes;\n\t\t\tcipher_key_bytes_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_passthrough:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_PLAINTEXT_PASSTHROUGH_ENABLED;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_xattr_metadata:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_XATTR_METADATA_ENABLED;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_encrypted_view:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_XATTR_METADATA_ENABLED;\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_ENCRYPTED_VIEW_ENABLED;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_fnek_sig:\n\t\t\tfnek_src = args[0].from;\n\t\t\tfnek_dst =\n\t\t\t\tmount_crypt_stat->global_default_fnek_sig;\n\t\t\tstrncpy(fnek_dst, fnek_src, ECRYPTFS_SIG_SIZE_HEX);\n\t\t\tmount_crypt_stat->global_default_fnek_sig[\n\t\t\t\tECRYPTFS_SIG_SIZE_HEX] = '\\0';\n\t\t\trc = ecryptfs_add_global_auth_tok(\n\t\t\t\tmount_crypt_stat,\n\t\t\t\tmount_crypt_stat->global_default_fnek_sig,\n\t\t\t\tECRYPTFS_AUTH_TOK_FNEK);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR \"Error attempting to register \"\n\t\t\t\t       \"global fnek sig [%s]; rc = [%d]\\n\",\n\t\t\t\t       mount_crypt_stat->global_default_fnek_sig,\n\t\t\t\t       rc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\t(ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES\n\t\t\t\t | ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK);\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_fn_cipher:\n\t\t\tfn_cipher_name_src = args[0].from;\n\t\t\tfn_cipher_name_dst =\n\t\t\t\tmount_crypt_stat->global_default_fn_cipher_name;\n\t\t\tstrncpy(fn_cipher_name_dst, fn_cipher_name_src,\n\t\t\t\tECRYPTFS_MAX_CIPHER_NAME_SIZE);\n\t\t\tmount_crypt_stat->global_default_fn_cipher_name[\n\t\t\t\tECRYPTFS_MAX_CIPHER_NAME_SIZE] = '\\0';\n\t\t\tfn_cipher_name_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_fn_cipher_key_bytes:\n\t\t\tfn_cipher_key_bytes_src = args[0].from;\n\t\t\tfn_cipher_key_bytes =\n\t\t\t\t(int)simple_strtol(fn_cipher_key_bytes_src,\n\t\t\t\t\t\t   &fn_cipher_key_bytes_src, 0);\n\t\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes =\n\t\t\t\tfn_cipher_key_bytes;\n\t\t\tfn_cipher_key_bytes_set = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_unlink_sigs:\n\t\t\tmount_crypt_stat->flags |= ECRYPTFS_UNLINK_SIGS;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_mount_auth_tok_only:\n\t\t\tmount_crypt_stat->flags |=\n\t\t\t\tECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_check_dev_ruid:\n\t\t\t*check_ruid = 1;\n\t\t\tbreak;\n\t\tcase ecryptfs_opt_err:\n\t\tdefault:\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"%s: eCryptfs: unrecognized option [%s]\\n\",\n\t\t\t       __func__, p);\n\t\t}\n\t}\n\tif (!sig_set) {\n\t\trc = -EINVAL;\n\t\tecryptfs_printk(KERN_ERR, \"You must supply at least one valid \"\n\t\t\t\t\"auth tok signature as a mount \"\n\t\t\t\t\"parameter; see the eCryptfs README\\n\");\n\t\tgoto out;\n\t}\n\tif (!cipher_name_set) {\n\t\tint cipher_name_len = strlen(ECRYPTFS_DEFAULT_CIPHER);\n\n\t\tBUG_ON(cipher_name_len >= ECRYPTFS_MAX_CIPHER_NAME_SIZE);\n\t\tstrcpy(mount_crypt_stat->global_default_cipher_name,\n\t\t       ECRYPTFS_DEFAULT_CIPHER);\n\t}\n\tif ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)\n\t    && !fn_cipher_name_set)\n\t\tstrcpy(mount_crypt_stat->global_default_fn_cipher_name,\n\t\t       mount_crypt_stat->global_default_cipher_name);\n\tif (!cipher_key_bytes_set)\n\t\tmount_crypt_stat->global_default_cipher_key_size = 0;\n\tif ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)\n\t    && !fn_cipher_key_bytes_set)\n\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes =\n\t\t\tmount_crypt_stat->global_default_cipher_key_size;\n\tmutex_lock(&key_tfm_list_mutex);\n\tif (!ecryptfs_tfm_exists(mount_crypt_stat->global_default_cipher_name,\n\t\t\t\t NULL)) {\n\t\trc = ecryptfs_add_new_key_tfm(\n\t\t\tNULL, mount_crypt_stat->global_default_cipher_name,\n\t\t\tmount_crypt_stat->global_default_cipher_key_size);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Error attempting to initialize \"\n\t\t\t       \"cipher with name = [%s] and key size = [%td]; \"\n\t\t\t       \"rc = [%d]\\n\",\n\t\t\t       mount_crypt_stat->global_default_cipher_name,\n\t\t\t       mount_crypt_stat->global_default_cipher_key_size,\n\t\t\t       rc);\n\t\t\trc = -EINVAL;\n\t\t\tmutex_unlock(&key_tfm_list_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif ((mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)\n\t    && !ecryptfs_tfm_exists(\n\t\t    mount_crypt_stat->global_default_fn_cipher_name, NULL)) {\n\t\trc = ecryptfs_add_new_key_tfm(\n\t\t\tNULL, mount_crypt_stat->global_default_fn_cipher_name,\n\t\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Error attempting to initialize \"\n\t\t\t       \"cipher with name = [%s] and key size = [%td]; \"\n\t\t\t       \"rc = [%d]\\n\",\n\t\t\t       mount_crypt_stat->global_default_fn_cipher_name,\n\t\t\t       mount_crypt_stat->global_default_fn_cipher_key_bytes,\n\t\t\t       rc);\n\t\t\trc = -EINVAL;\n\t\t\tmutex_unlock(&key_tfm_list_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmutex_unlock(&key_tfm_list_mutex);\n\trc = ecryptfs_init_global_auth_toks(mount_crypt_stat);\n\tif (rc)\n\t\tprintk(KERN_WARNING \"One or more global auth toks could not \"\n\t\t       \"properly register; rc = [%d]\\n\", rc);\nout:\n\treturn rc;\n}",
        "start_line": 257
      }
    ],
    "code_context": "Called Methods:\n- strlen: size_t strlen(const char *s) /* <=== strlen */ \n{\n\tconst char *sc;\n\n\tfor (sc = s; *sc != '\\0'; ++sc)\n\t\t/* nothing */;\n\treturn sc - s;\n}\n- ECRYPTFS_XATTR_METADATA_ENABLED: #define ECRYPTFS_XATTR_METADATA_ENABLED        0x00000002 /* <=== fs/ecryptfs/ecryptfs_kernel.h:305:305:ECRYPTFS_XATTR_METADATA_ENABLED:0 */ \n- kmem_cache_free: void kmem_cache_free(struct kmem_cache *, void *); /* <=== kmem_cache_free */ \n- INIT_LIST_HEAD: static inline void INIT_LIST_HEAD(struct list_head *list) /* <=== INIT_LIST_HEAD */ \n{\n\tlist->next = list;\n\tlist->prev = list;\n}\n- strcmp: int strcmp(const char *cs, const char *ct) /* <=== strcmp */ \n{\n\tunsigned char c1, c2;\n\n\twhile (1) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n- kmem_cache_alloc: void *kmem_cache_alloc(struct kmem_cache *, gfp_t); /* <=== kmem_cache_alloc */ \n- ecryptfs_add_global_auth_tok: int /* <=== ecryptfs_add_global_auth_tok */ \necryptfs_add_global_auth_tok(struct ecryptfs_mount_crypt_stat *mount_crypt_stat,\n\t\t\t     char *sig, u32 global_auth_tok_flags)\n{\n\tstruct ecryptfs_global_auth_tok *new_auth_tok;\n\tint rc = 0;\n\n\tnew_auth_tok = kmem_cache_zalloc(ecryptfs_global_auth_tok_cache,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!new_auth_tok) {\n\t\trc = -ENOMEM;\n\t\tprintk(KERN_ERR \"Error allocating from \"\n\t\t       \"ecryptfs_global_auth_tok_cache\\n\");\n\t\tgoto out;\n\t}\n\tmemcpy(new_auth_tok->sig, sig, ECRYPTFS_SIG_SIZE_HEX);\n\tnew_auth_tok->flags = global_auth_tok_flags;\n\tnew_auth_tok->sig[ECRYPTFS_SIG_SIZE_HEX] = '\\0';\n\tmutex_lock(&mount_crypt_stat->global_auth_tok_list_mutex);\n\tlist_add(&new_auth_tok->mount_crypt_stat_list,\n\t\t &mount_crypt_stat->global_auth_tok_list);\n\tmutex_unlock(&mount_crypt_stat->global_auth_tok_list_mutex);\nout:\n\treturn rc;\n}\n- kmem_cache_alloc: void *kmem_cache_alloc(struct kmem_cache *, gfp_t); /* <=== kmem_cache_alloc */ \n- strcpy: char *strcpy(char *dest, const char *src) /* <=== strcpy */ \n{\n\tchar *tmp = dest;\n\n\twhile ((*dest++ = *src++) != '\\0')\n\t\t/* nothing */;\n\treturn tmp;\n}\n- ecryptfs_printk: #define ecryptfs_printk(type, fmt, arg...) \\ /* <=== fs/ecryptfs/ecryptfs_kernel.h:515:516:ecryptfs_printk:3 */ \n        __ecryptfs_printk(type \"%s: \" fmt, __func__, ## arg);\n- strncpy: char *strncpy(char *dest, const char *src, size_t n) /* <=== strncpy */ \n{\n\tsize_t len = __strnend(src, n) - src;\n\t__builtin_memset(dest + len, 0, n - len);\n\t__builtin_memcpy(dest, src, len);\n\treturn dest;\n}\n- ECRYPTFS_PLAINTEXT_PASSTHROUGH_ENABLED: #define ECRYPTFS_PLAINTEXT_PASSTHROUGH_ENABLED 0x00000001 /* <=== fs/ecryptfs/ecryptfs_kernel.h:304:304:ECRYPTFS_PLAINTEXT_PASSTHROUGH_ENABLED:0 */ \n- simple_strtol: long simple_strtol(const char *cp, char **endp, unsigned int base) /* <=== simple_strtol */ \n{\n\tif (*cp == '-')\n\t\treturn -simple_strtoul(cp + 1, endp, base);\n\n\treturn simple_strtoul(cp, endp, base);\n}\n- memset: void *memset(void *s, int c, size_t count) /* <=== memset */ \n{\n\tchar *xs = s;\n\n\twhile (count--)\n\t\t*xs++ = c;\n\treturn s;\n}\n- ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK: #define ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK   0x00000020 /* <=== fs/ecryptfs/ecryptfs_kernel.h:309:309:ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK:0 */ \n- strpbrk: char *strpbrk(const char *cs, const char *ct) /* <=== strpbrk */ \n{\n\tconst char *sc1, *sc2;\n\n\tfor (sc1 = cs; *sc1 != '\\0'; ++sc1) {\n\t\tfor (sc2 = ct; *sc2 != '\\0'; ++sc2) {\n\t\t\tif (*sc1 == *sc2)\n\t\t\t\treturn (char *)sc1;\n\t\t}\n\t}\n\treturn NULL;\n}\n- strcmp: static inline int strcmp(const char *cs, const char *ct) /* <=== strcmp */ \n{\n\tchar res;\n\n\tasm (\"\\n\"\n\t\t\"1:\tmove.b\t(%0)+,%2\\n\"\t/* get *cs */\n\t\t\"\tcmp.b\t(%1)+,%2\\n\"\t/* compare a byte */\n\t\t\"\tjne\t2f\\n\"\t\t/* not equal, break out */\n\t\t\"\ttst.b\t%2\\n\"\t\t/* at end of cs? */\n\t\t\"\tjne\t1b\\n\"\t\t/* no, keep going */\n\t\t\"\tjra\t3f\\n\"\t\t/* strings are equal */\n\t\t\"2:\tsub.b\t-(%1),%2\\n\"\t/* *cs - *ct */\n\t\t\"3:\"\n\t\t: \"+a\" (cs), \"+a\" (ct), \"=d\" (res));\n\treturn res;\n}\n- strsep: char *strsep(char **s, const char *ct) /* <=== strsep */ \n{\n\tchar *sbegin = *s;\n\tchar *end;\n\n\tif (sbegin == NULL)\n\t\treturn NULL;\n\n\tend = strpbrk(sbegin, ct);\n\tif (end)\n\t\t*end++ = '\\0';\n\t*s = end;\n\treturn sbegin;\n}\n- ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY: #define ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY    0x00000080 /* <=== fs/ecryptfs/ecryptfs_kernel.h:311:311:ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY:0 */ \n- ecryptfs_add_new_key_tfm: int /* <=== ecryptfs_add_new_key_tfm */ \necryptfs_add_new_key_tfm(struct ecryptfs_key_tfm **key_tfm, char *cipher_name,\n\t\t\t size_t key_size)\n{\n\tstruct ecryptfs_key_tfm *tmp_tfm;\n\tint rc = 0;\n\n\tBUG_ON(!mutex_is_locked(&key_tfm_list_mutex));\n\n\ttmp_tfm = kmem_cache_alloc(ecryptfs_key_tfm_cache, GFP_KERNEL);\n\tif (key_tfm != NULL)\n\t\t(*key_tfm) = tmp_tfm;\n\tif (!tmp_tfm) {\n\t\trc = -ENOMEM;\n\t\tprintk(KERN_ERR \"Error attempting to allocate from \"\n\t\t       \"ecryptfs_key_tfm_cache\\n\");\n\t\tgoto out;\n\t}\n\tmutex_init(&tmp_tfm->key_tfm_mutex);\n\tstrncpy(tmp_tfm->cipher_name, cipher_name,\n\t\tECRYPTFS_MAX_CIPHER_NAME_SIZE);\n\ttmp_tfm->cipher_name[ECRYPTFS_MAX_CIPHER_NAME_SIZE] = '\\0';\n\ttmp_tfm->key_size = key_size;\n\trc = ecryptfs_process_key_cipher(&tmp_tfm->key_tfm,\n\t\t\t\t\t tmp_tfm->cipher_name,\n\t\t\t\t\t &tmp_tfm->key_size);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error attempting to initialize key TFM \"\n\t\t       \"cipher with name = [%s]; rc = [%d]\\n\",\n\t\t       tmp_tfm->cipher_name, rc);\n\t\tkmem_cache_free(ecryptfs_key_tfm_cache, tmp_tfm);\n\t\tif (key_tfm != NULL)\n\t\t\t(*key_tfm) = NULL;\n\t\tgoto out;\n\t}\n\tlist_add(&tmp_tfm->key_tfm_list, &key_tfm_list);\nout:\n\treturn rc;\n}\n- ecryptfs_init_global_auth_toks: static int ecryptfs_init_global_auth_toks( /* <=== ecryptfs_init_global_auth_toks */ \n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tstruct ecryptfs_global_auth_tok *global_auth_tok;\n\tstruct ecryptfs_auth_tok *auth_tok;\n\tint rc = 0;\n\n\tlist_for_each_entry(global_auth_tok,\n\t\t\t    &mount_crypt_stat->global_auth_tok_list,\n\t\t\t    mount_crypt_stat_list) {\n\t\trc = ecryptfs_keyring_auth_tok_for_sig(\n\t\t\t&global_auth_tok->global_auth_tok_key, &auth_tok,\n\t\t\tglobal_auth_tok->sig);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Could not find valid key in user \"\n\t\t\t       \"session keyring for sig specified in mount \"\n\t\t\t       \"option: [%s]\\n\", global_auth_tok->sig);\n\t\t\tglobal_auth_tok->flags |= ECRYPTFS_AUTH_TOK_INVALID;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tglobal_auth_tok->flags &= ~ECRYPTFS_AUTH_TOK_INVALID;\n\t\t\tup_write(&(global_auth_tok->global_auth_tok_key)->sem);\n\t\t}\n\t}\nout:\n\treturn rc;\n}\n- ECRYPTFS_MOUNT_CRYPT_STAT_INITIALIZED: #define ECRYPTFS_MOUNT_CRYPT_STAT_INITIALIZED  0x00000008 /* <=== fs/ecryptfs/ecryptfs_kernel.h:307:307:ECRYPTFS_MOUNT_CRYPT_STAT_INITIALIZED:0 */ \n- memcpy: void *memcpy(void *dest, const void *src, size_t count) /* <=== memcpy */ \n{\n\tchar *tmp = dest;\n\tconst char *s = src;\n\n\twhile (count--)\n\t\t*tmp++ = *s++;\n\treturn dest;\n}\n- memset: void *memset(void *s, int c, size_t n) /* <=== memset */ \n{\n\tchar *xs;\n\n\tif (c == 0)\n\t\treturn __builtin_memset(s, 0, n);\n\n\txs = (char *) s;\n\tif (n > 0)\n\t\tdo {\n\t\t\t*xs++ = c;\n\t\t} while (--n > 0);\n\treturn s;\n}\n- __strend: static inline char *__strend(const char *s) /* <=== __strend */ \n{\n\tregister unsigned long r0 asm(\"0\") = 0;\n\n\tasm volatile (\"0: srst  %0,%1\\n\"\n\t\t      \"   jo    0b\"\n\t\t      : \"+d\" (r0), \"+a\" (s) :  : \"cc\" );\n\treturn (char *) r0;\n}\n- simple_strtoul: static inline unsigned long /* <=== simple_strtoul */ \nsimple_strtoul(const char *nptr, char **endptr, int base)\n{\n\treturn strtoul(nptr, endptr, base);\n}\n- simple_strtoul: unsigned long simple_strtoul(const char *cp, char **endp, unsigned int base) /* <=== simple_strtoul */ \n{\n\treturn simple_strtoull(cp, endp, base);\n}\n- ecryptfs_process_key_cipher: static int /* <=== ecryptfs_process_key_cipher */ \necryptfs_process_key_cipher(struct crypto_blkcipher **key_tfm,\n\t\t\t    char *cipher_name, size_t *key_size)\n{\n\tchar dummy_key[ECRYPTFS_MAX_KEY_BYTES];\n\tchar *full_alg_name = NULL;\n\tint rc;\n\n\t*key_tfm = NULL;\n\tif (*key_size > ECRYPTFS_MAX_KEY_BYTES) {\n\t\trc = -EINVAL;\n\t\tprintk(KERN_ERR \"Requested key size is [%zd] bytes; maximum \"\n\t\t      \"allowable is [%d]\\n\", *key_size, ECRYPTFS_MAX_KEY_BYTES);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_crypto_api_algify_cipher_name(&full_alg_name, cipher_name,\n\t\t\t\t\t\t    \"ecb\");\n\tif (rc)\n\t\tgoto out;\n\t*key_tfm = crypto_alloc_blkcipher(full_alg_name, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(*key_tfm)) {\n\t\trc = PTR_ERR(*key_tfm);\n\t\tprintk(KERN_ERR \"Unable to allocate crypto cipher with name \"\n\t\t       \"[%s]; rc = [%d]\\n\", full_alg_name, rc);\n\t\tgoto out;\n\t}\n\tcrypto_blkcipher_set_flags(*key_tfm, CRYPTO_TFM_REQ_WEAK_KEY);\n\tif (*key_size == 0) {\n\t\tstruct blkcipher_alg *alg = crypto_blkcipher_alg(*key_tfm);\n\n\t\t*key_size = alg->max_keysize;\n\t}\n\tget_random_bytes(dummy_key, *key_size);\n\trc = crypto_blkcipher_setkey(*key_tfm, dummy_key, *key_size);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error attempting to set key of size [%zd] for \"\n\t\t       \"cipher [%s]; rc = [%d]\\n\", *key_size, full_alg_name,\n\t\t       rc);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\tkfree(full_alg_name);\n\treturn rc;\n}\n- strcpy: char *strcpy(char *dest, const char *src) /* <=== strcpy */ \n{\n#if __GNUC__ < 4\n\tregister int r0 asm(\"0\") = 0;\n\tchar *ret = dest;\n\n\tasm volatile (\"0: mvst  %0,%1\\n\"\n\t\t      \"   jo    0b\"\n\t\t      : \"+&a\" (dest), \"+&a\" (src) : \"d\" (r0)\n\t\t      : \"cc\", \"memory\" );\n\treturn ret;\n#else\n\treturn __builtin_strcpy(dest, src);\n#endif\n}\n- ECRYPTFS_AUTH_TOK_INVALID: #define ECRYPTFS_AUTH_TOK_INVALID 0x00000001 /* <=== fs/ecryptfs/ecryptfs_kernel.h:264:264:ECRYPTFS_AUTH_TOK_INVALID:0 */ \n- ecryptfs_tfm_exists: int ecryptfs_tfm_exists(char *cipher_name, struct ecryptfs_key_tfm **key_tfm) /* <=== ecryptfs_tfm_exists */ \n{\n\tstruct ecryptfs_key_tfm *tmp_key_tfm;\n\n\tBUG_ON(!mutex_is_locked(&key_tfm_list_mutex));\n\n\tlist_for_each_entry(tmp_key_tfm, &key_tfm_list, key_tfm_list) {\n\t\tif (strcmp(tmp_key_tfm->cipher_name, cipher_name) == 0) {\n\t\t\tif (key_tfm)\n\t\t\t\t(*key_tfm) = tmp_key_tfm;\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif (key_tfm)\n\t\t(*key_tfm) = NULL;\n\treturn 0;\n}\n- strcmp: int strcmp(const char *cs, const char *ct) /* <=== strcmp */ \n{\n\tregister int r0 asm(\"0\") = 0;\n\tint ret = 0;\n\n\tasm volatile (\"0: clst %2,%3\\n\"\n\t\t      \"   jo   0b\\n\"\n\t\t      \"   je   1f\\n\"\n\t\t      \"   ic   %0,0(%2)\\n\"\n\t\t      \"   ic   %1,0(%3)\\n\"\n\t\t      \"   sr   %0,%1\\n\"\n\t\t      \"1:\"\n\t\t      : \"+d\" (ret), \"+d\" (r0), \"+a\" (cs), \"+a\" (ct)\n\t\t      : : \"cc\" );\n\treturn ret;\n}\n- ECRYPTFS_ENCRYPTED_VIEW_ENABLED: #define ECRYPTFS_ENCRYPTED_VIEW_ENABLED        0x00000004 /* <=== fs/ecryptfs/ecryptfs_kernel.h:306:306:ECRYPTFS_ENCRYPTED_VIEW_ENABLED:0 */ \n- ecryptfs_init_mount_crypt_stat: static void ecryptfs_init_mount_crypt_stat( /* <=== ecryptfs_init_mount_crypt_stat */ \n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n\tmemset((void *)mount_crypt_stat, 0,\n\t       sizeof(struct ecryptfs_mount_crypt_stat));\n\tINIT_LIST_HEAD(&mount_crypt_stat->global_auth_tok_list);\n\tmutex_init(&mount_crypt_stat->global_auth_tok_list_mutex);\n\tmount_crypt_stat->flags |= ECRYPTFS_MOUNT_CRYPT_STAT_INITIALIZED;\n}\n- kmem_cache_zalloc: static inline void *kmem_cache_zalloc(struct kmem_cache *k, gfp_t flags) /* <=== kmem_cache_zalloc */ \n{\n\treturn kmem_cache_alloc(k, flags | __GFP_ZERO);\n}\n- strncpy: static inline char *strncpy(char *dest, const char *src, size_t n) /* <=== strncpy */ \n{\n\tchar *xdest = dest;\n\n\tasm volatile (\"\\n\"\n\t\t\"\tjra\t2f\\n\"\n\t\t\"1:\tmove.b\t(%1),(%0)+\\n\"\n\t\t\"\tjeq\t2f\\n\"\n\t\t\"\taddq.l\t#1,%1\\n\"\n\t\t\"2:\tsubq.l\t#1,%2\\n\"\n\t\t\"\tjcc\t1b\\n\"\n\t\t: \"+a\" (dest), \"+a\" (src), \"+d\" (n)\n\t\t: : \"memory\");\n\treturn xdest;\n}\n- ECRYPTFS_MAX_CIPHER_NAME_SIZE: #define ECRYPTFS_MAX_CIPHER_NAME_SIZE 32 /* <=== fs/ecryptfs/ecryptfs_kernel.h:126:126:ECRYPTFS_MAX_CIPHER_NAME_SIZE:0 */ \n- __strnend: static inline char *__strnend(const char *s, size_t n) /* <=== __strnend */ \n{\n\tregister unsigned long r0 asm(\"0\") = 0;\n\tconst char *p = s + n;\n\n\tasm volatile (\"0: srst  %0,%1\\n\"\n\t\t      \"   jo    0b\"\n\t\t      : \"+d\" (p), \"+a\" (s) : \"d\" (r0) : \"cc\" );\n\treturn (char *) p;\n}\n- match_token: int match_token(char *, const match_table_t table, substring_t args[]); /* <=== match_token */ \n- ecryptfs_keyring_auth_tok_for_sig: int ecryptfs_keyring_auth_tok_for_sig(struct key **auth_tok_key, /* <=== ecryptfs_keyring_auth_tok_for_sig */ \n\t\t\t\t      struct ecryptfs_auth_tok **auth_tok,\n\t\t\t\t      char *sig)\n{\n\tint rc = 0;\n\n\t(*auth_tok_key) = request_key(&key_type_user, sig, NULL);\n\tif (!(*auth_tok_key) || IS_ERR(*auth_tok_key)) {\n\t\t(*auth_tok_key) = ecryptfs_get_encrypted_key(sig);\n\t\tif (!(*auth_tok_key) || IS_ERR(*auth_tok_key)) {\n\t\t\tprintk(KERN_ERR \"Could not find key with description: [%s]\\n\",\n\t\t\t      sig);\n\t\t\trc = process_request_key_err(PTR_ERR(*auth_tok_key));\n\t\t\t(*auth_tok_key) = NULL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tdown_write(&(*auth_tok_key)->sem);\n\trc = ecryptfs_verify_auth_tok_from_key(*auth_tok_key, auth_tok);\n\tif (rc) {\n\t\tup_write(&(*auth_tok_key)->sem);\n\t\tkey_put(*auth_tok_key);\n\t\t(*auth_tok_key) = NULL;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}\n- list_add: static inline void list_add(struct list_head *new, struct list_head *head) /* <=== list_add */ \n{\n\t__list_add(new, head, head->next);\n}\n- ECRYPTFS_AUTH_TOK_FNEK: #define ECRYPTFS_AUTH_TOK_FNEK    0x00000002 /* <=== fs/ecryptfs/ecryptfs_kernel.h:265:265:ECRYPTFS_AUTH_TOK_FNEK:0 */ \n- up_write: extern void up_write(struct rw_semaphore *sem); /* <=== up_write */ \n- ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES: #define ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES      0x00000010 /* <=== fs/ecryptfs/ecryptfs_kernel.h:308:308:ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES:0 */ \n- ECRYPTFS_UNLINK_SIGS: #define ECRYPTFS_UNLINK_SIGS          0x00002000 /* <=== fs/ecryptfs/ecryptfs_kernel.h:203:203:ECRYPTFS_UNLINK_SIGS:0 */ \n- memcpy: void *memcpy(void *dest, const void *src, size_t n) /* <=== memcpy */ \n{\n\treturn __builtin_memcpy(dest, src, n);\n}\n- ECRYPTFS_DEFAULT_CIPHER: #define ECRYPTFS_DEFAULT_CIPHER \"aes\" /* <=== fs/ecryptfs/ecryptfs_kernel.h:135:135:ECRYPTFS_DEFAULT_CIPHER:0 */ \n- strncpy: char *strncpy(char *dest, const char *src, size_t count) /* <=== strncpy */ \n{\n\tchar *tmp = dest;\n\n\twhile (count) {\n\t\tif ((*tmp = *src) != 0)\n\t\t\tsrc++;\n\t\ttmp++;\n\t\tcount--;\n\t}\n\treturn dest;\n}\n- strlen: size_t strlen(const char *s) /* <=== strlen */ \n{\n#if __GNUC__ < 4\n\treturn __strend(s) - s;\n#else\n\treturn __builtin_strlen(s);\n#endif\n}\n\nType Definitions:\n- ecryptfs_sb_info: struct ecryptfs_sb_info {\n\tstruct super_block *wsi_sb;\n\tstruct ecryptfs_mount_crypt_stat mount_crypt_stat;\n\tstruct backing_dev_info bdi;\n}\n- ecryptfs_mount_crypt_stat: struct ecryptfs_mount_crypt_stat {\n\t/* Pointers to memory we do not own, do not free these */\n#define ECRYPTFS_PLAINTEXT_PASSTHROUGH_ENABLED 0x00000001\n#define ECRYPTFS_XATTR_METADATA_ENABLED        0x00000002\n#define ECRYPTFS_ENCRYPTED_VIEW_ENABLED        0x00000004\n#define ECRYPTFS_MOUNT_CRYPT_STAT_INITIALIZED  0x00000008\n#define ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES      0x00000010\n#define ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK   0x00000020\n#define ECRYPTFS_GLOBAL_ENCFN_USE_FEK          0x00000040\n#define ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY    0x00000080\n\tu32 flags;\n\tstruct list_head global_auth_tok_list;\n\tstruct mutex global_auth_tok_list_mutex;\n\tsize_t global_default_cipher_key_size;\n\tsize_t global_default_fn_cipher_key_bytes;\n\tunsigned char global_default_cipher_name[ECRYPTFS_MAX_CIPHER_NAME_SIZE\n\t\t\t\t\t\t + 1];\n\tunsigned char global_default_fn_cipher_name[\n\t\tECRYPTFS_MAX_CIPHER_NAME_SIZE + 1];\n\tchar global_default_fnek_sig[ECRYPTFS_SIG_SIZE_HEX + 1];\n}\n- match_table_t: typedef struct match_token match_table_t[];\n\nGlobal Variables:\n- const match_table_t tokens\n\nImports:\n- #include <linux/module.h>\n- #include <linux/namei.h>\n- #include <linux/skbuff.h>\n- #include <linux/magic.h>\n- #include <linux/dcache.h>\n- #include <linux/key.h>\n- #include <linux/fs_stack.h>\n- #include \"ecryptfs_kernel.h\"\n- #include <linux/mount.h>\n- #include <linux/pagemap.h>\n- #include <linux/slab.h>\n- #include <linux/parser.h>\n- #include <linux/crypto.h>\n- #include <linux/file.h>",
    "commit_msg": "Ecryptfs: Add mount option to check uid of device being mounted = expect uid\n\nClose a TOCTOU race for mounts done via ecryptfs-mount-private.  The mount\nsource (device) can be raced when the ownership test is done in userspace.\nProvide Ecryptfs a means to force the uid check at mount time.\n\nSigned-off-by: John Johansen <john.johansen@canonical.com>\nCc: <stable@kernel.org>\nSigned-off-by: Tyler Hicks <tyhicks@linux.vnet.ibm.com>",
    "cve_desc": "[{'lang': 'en', 'value': 'Race condition in the ecryptfs_mount function in fs/ecryptfs/main.c in the eCryptfs subsystem in the Linux kernel before 3.1 allows local users to bypass intended file permissions via a mount.ecryptfs_private mount with a mismatched uid.'}]",
    "year": 2011,
    "filename": "main.c",
    "commit_url": "\"https://github.com/torvalds/linux/commit/764355487ea220fdc2faf128d577d7f679b91f97\""
  },
  {
    "repository": "torproject/tor",
    "cve_id": "CVE-2011-1924",
    "cwe_list": [
      "CWE-119"
    ],
    "commit_hash": "43414eb98821d3b5c6c65181d7545ce938f82c8e",
    "short_hash": "43414eb9",
    "vulnerableMethods_before": [
      {
        "filename": "src/or/policies.c",
        "method_name": "policy_summarize",
        "raw_code": "char * /* <=== policy_summarize */ \npolicy_summarize(smartlist_t *policy)\n{\n  smartlist_t *summary = policy_summary_create();\n  smartlist_t *accepts, *rejects;\n  int i, last, start_prt;\n  size_t accepts_len, rejects_len, shorter_len, final_size;\n  char *accepts_str = NULL, *rejects_str = NULL, *shorter_str, *result;\n  const char *prefix;\n\n  tor_assert(policy);\n\n  /* Create the summary list */\n  SMARTLIST_FOREACH(policy, addr_policy_t *, p, {\n    policy_summary_add_item(summary, p);\n  });\n\n  /* Now create two lists of strings, one for accepted and one\n   * for rejected ports.  We take care to merge ranges so that\n   * we avoid getting stuff like \"1-4,5-9,10\", instead we want\n   * \"1-10\"\n   */\n  i = 0;\n  start_prt = 1;\n  accepts = smartlist_create();\n  rejects = smartlist_create();\n  while (1) {\n    last = i == smartlist_len(summary)-1;\n    if (last ||\n        AT(i)->accepted != AT(i+1)->accepted) {\n      char buf[POLICY_BUF_LEN];\n\n      if (start_prt == AT(i)->prt_max)\n        tor_snprintf(buf, sizeof(buf), \"%d\", start_prt);\n      else\n        tor_snprintf(buf, sizeof(buf), \"%d-%d\", start_prt, AT(i)->prt_max);\n\n      if (AT(i)->accepted)\n        smartlist_add(accepts, tor_strdup(buf));\n      else\n        smartlist_add(rejects, tor_strdup(buf));\n\n      if (last)\n        break;\n\n      start_prt = AT(i+1)->prt_min;\n    };\n    i++;\n  };\n\n  /* Figure out which of the two stringlists will be shorter and use\n   * that to build the result\n   */\n  if (smartlist_len(accepts) == 0) { /* no exits at all */\n    result = tor_strdup(\"reject 1-65535\");\n    goto cleanup;\n  }\n  if (smartlist_len(rejects) == 0) { /* no rejects at all */\n    result = tor_strdup(\"accept 1-65535\");\n    goto cleanup;\n  }\n\n  accepts_str = smartlist_join_strings(accepts, \",\", 0, &accepts_len);\n  rejects_str = smartlist_join_strings(rejects, \",\", 0, &rejects_len);\n\n  if (rejects_len > MAX_EXITPOLICY_SUMMARY_LEN &&\n      accepts_len > MAX_EXITPOLICY_SUMMARY_LEN) {\n    char *c;\n    shorter_str = accepts_str;\n    prefix = \"accept\";\n\n    c = shorter_str + (MAX_EXITPOLICY_SUMMARY_LEN-strlen(prefix)-1);\n    while (*c != ',' && c >= shorter_str)\n      c--;\n    tor_assert(c >= shorter_str);\n    tor_assert(*c == ',');\n    *c = '\\0';\n\n    shorter_len = strlen(shorter_str);\n  } else if (rejects_len < accepts_len) {\n    shorter_str = rejects_str;\n    shorter_len = rejects_len;\n    prefix = \"reject\";\n  } else {\n    shorter_str = accepts_str;\n    shorter_len = accepts_len;\n    prefix = \"accept\";\n  }\n\n  final_size = strlen(prefix)+1+shorter_len+1;\n  tor_assert(final_size <= MAX_EXITPOLICY_SUMMARY_LEN+1);\n  result = tor_malloc(final_size);\n  tor_snprintf(result, final_size, \"%s %s\", prefix, shorter_str);\n\ncleanup:\n  /* cleanup */\n  SMARTLIST_FOREACH(summary, policy_summary_item_t *, s, tor_free(s));\n  smartlist_free(summary);\n\n  tor_free(accepts_str);\n  SMARTLIST_FOREACH(accepts, char *, s, tor_free(s));\n  smartlist_free(accepts);\n\n  tor_free(rejects_str);\n  SMARTLIST_FOREACH(rejects, char *, s, tor_free(s));\n  smartlist_free(rejects);\n\n  return result;\n}",
        "start_line": 1147
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "src/or/policies.c",
        "method_name": "policy_summarize",
        "raw_code": "char * /* <=== policy_summarize */ \npolicy_summarize(smartlist_t *policy)\n{\n  smartlist_t *summary = policy_summary_create();\n  smartlist_t *accepts, *rejects;\n  int i, last, start_prt;\n  size_t accepts_len, rejects_len, shorter_len, final_size;\n  char *accepts_str = NULL, *rejects_str = NULL, *shorter_str, *result;\n  const char *prefix;\n\n  tor_assert(policy);\n\n  /* Create the summary list */\n  SMARTLIST_FOREACH(policy, addr_policy_t *, p, {\n    policy_summary_add_item(summary, p);\n  });\n\n  /* Now create two lists of strings, one for accepted and one\n   * for rejected ports.  We take care to merge ranges so that\n   * we avoid getting stuff like \"1-4,5-9,10\", instead we want\n   * \"1-10\"\n   */\n  i = 0;\n  start_prt = 1;\n  accepts = smartlist_create();\n  rejects = smartlist_create();\n  while (1) {\n    last = i == smartlist_len(summary)-1;\n    if (last ||\n        AT(i)->accepted != AT(i+1)->accepted) {\n      char buf[POLICY_BUF_LEN];\n\n      if (start_prt == AT(i)->prt_max)\n        tor_snprintf(buf, sizeof(buf), \"%d\", start_prt);\n      else\n        tor_snprintf(buf, sizeof(buf), \"%d-%d\", start_prt, AT(i)->prt_max);\n\n      if (AT(i)->accepted)\n        smartlist_add(accepts, tor_strdup(buf));\n      else\n        smartlist_add(rejects, tor_strdup(buf));\n\n      if (last)\n        break;\n\n      start_prt = AT(i+1)->prt_min;\n    };\n    i++;\n  };\n\n  /* Figure out which of the two stringlists will be shorter and use\n   * that to build the result\n   */\n  if (smartlist_len(accepts) == 0) { /* no exits at all */\n    result = tor_strdup(\"reject 1-65535\");\n    goto cleanup;\n  }\n  if (smartlist_len(rejects) == 0) { /* no rejects at all */\n    result = tor_strdup(\"accept 1-65535\");\n    goto cleanup;\n  }\n\n  accepts_str = smartlist_join_strings(accepts, \",\", 0, &accepts_len);\n  rejects_str = smartlist_join_strings(rejects, \",\", 0, &rejects_len);\n\n  if (rejects_len > MAX_EXITPOLICY_SUMMARY_LEN-strlen(\"reject\")-1 &&\n      accepts_len > MAX_EXITPOLICY_SUMMARY_LEN-strlen(\"accept\")-1) {\n    char *c;\n    shorter_str = accepts_str;\n    prefix = \"accept\";\n\n    c = shorter_str + (MAX_EXITPOLICY_SUMMARY_LEN-strlen(prefix)-1);\n    while (*c != ',' && c >= shorter_str)\n      c--;\n    tor_assert(c >= shorter_str);\n    tor_assert(*c == ',');\n    *c = '\\0';\n\n    shorter_len = strlen(shorter_str);\n  } else if (rejects_len < accepts_len) {\n    shorter_str = rejects_str;\n    shorter_len = rejects_len;\n    prefix = \"reject\";\n  } else {\n    shorter_str = accepts_str;\n    shorter_len = accepts_len;\n    prefix = \"accept\";\n  }\n\n  final_size = strlen(prefix)+1+shorter_len+1;\n  tor_assert(final_size <= MAX_EXITPOLICY_SUMMARY_LEN+1);\n  result = tor_malloc(final_size);\n  tor_snprintf(result, final_size, \"%s %s\", prefix, shorter_str);\n\ncleanup:\n  /* cleanup */\n  SMARTLIST_FOREACH(summary, policy_summary_item_t *, s, tor_free(s));\n  smartlist_free(summary);\n\n  tor_free(accepts_str);\n  SMARTLIST_FOREACH(accepts, char *, s, tor_free(s));\n  smartlist_free(accepts);\n\n  tor_free(rejects_str);\n  SMARTLIST_FOREACH(rejects, char *, s, tor_free(s));\n  smartlist_free(rejects);\n\n  return result;\n}",
        "start_line": 1147
      }
    ],
    "code_context": "Called Methods:\n- smartlist_free: void /* <=== smartlist_free */ \nsmartlist_free(smartlist_t *sl)\n{\n  tor_assert(sl != NULL);\n  tor_free(sl->list);\n  tor_free(sl);\n}\n- smartlist_add: void /* <=== smartlist_add */ \nsmartlist_add(smartlist_t *sl, void *element)\n{\n  smartlist_ensure_capacity(sl, sl->num_used+1);\n  sl->list[sl->num_used++] = element;\n}\n- tor_malloc: #define tor_malloc(size)       _tor_malloc(size DMALLOC_ARGS) /* <=== src/common/util.h:107:107:tor_malloc:1 */ \n- SMARTLIST_FOREACH: #define SMARTLIST_FOREACH(sl, type, var, cmd)                   \\ /* <=== src/common/container.h:207:210:SMARTLIST_FOREACH:4 */ \n  SMARTLIST_FOREACH_BEGIN(sl,type,var) {                        \\\n    cmd;                                                        \\\n  } SMARTLIST_FOREACH_END(var)\n- _tor_malloc_zero: void *_tor_malloc_zero(size_t size DMALLOC_PARAMS) ATTR_MALLOC; /* <=== _tor_malloc_zero */ \n- tor_free: #define tor_free(p) STMT_BEGIN                                 \\ /* <=== src/common/util.h:99:104:tor_free:1 */ \n    if (PREDICT_LIKELY((p)!=NULL)) {                           \\\n      free(p);                                                 \\\n      (p)=NULL;                                                \\\n    }                                                          \\\n  STMT_END\n- smartlist_create: smartlist_t * /* <=== smartlist_create */ \nsmartlist_create(void)\n{\n  smartlist_t *sl = tor_malloc(sizeof(smartlist_t));\n  sl->num_used = 0;\n  sl->capacity = SMARTLIST_DEFAULT_CAPACITY;\n  sl->list = tor_malloc(sizeof(void *) * sl->capacity);\n  return sl;\n}\n- tor_malloc_zero: #define tor_malloc_zero(size)  _tor_malloc_zero(size DMALLOC_ARGS) /* <=== src/common/util.h:108:108:tor_malloc_zero:1 */ \n- tor_snprintf: int /* <=== tor_snprintf */ \ntor_snprintf(char *str, size_t size, const char *format, ...)\n{\n  va_list ap;\n  int r;\n  va_start(ap,format);\n  r = tor_vsnprintf(str,size,format,ap);\n  va_end(ap);\n  return r;\n}\n- _tor_malloc: void *_tor_malloc(size_t size DMALLOC_PARAMS) ATTR_MALLOC; /* <=== _tor_malloc */ \n- policy_summary_create: static smartlist_t * /* <=== policy_summary_create */ \npolicy_summary_create(void)\n{\n  smartlist_t *summary;\n  policy_summary_item_t* item;\n\n  item = tor_malloc_zero(sizeof(policy_summary_item_t));\n  item->prt_min = 1;\n  item->prt_max = 65535;\n  item->reject_count = 0;\n  item->accepted = 0;\n\n  summary = smartlist_create();\n  smartlist_add(summary, item);\n\n  return summary;\n}\n- _log: void _log(int severity, log_domain_mask_t domain, const char *format, ...) /* <=== _log */ \n- SMARTLIST_DEFAULT_CAPACITY: #define SMARTLIST_DEFAULT_CAPACITY 16 /* <=== src/common/container.c:27:27:SMARTLIST_DEFAULT_CAPACITY:0 */ \n- AT: #define AT(x) ((policy_summary_item_t*)smartlist_get(summary, x)) /* <=== src/or/policies.c:1031:1031:AT:1 */ \n- MAX_EXITPOLICY_SUMMARY_LEN: #define MAX_EXITPOLICY_SUMMARY_LEN (1000) /* <=== src/or/or.h:3414:3414:MAX_EXITPOLICY_SUMMARY_LEN:0 */ \n- smartlist_len: #define smartlist_len(sl) ((sl)->num_used) /* <=== src/common/container.h:75:75:smartlist_len:1 */ \n- tor_assert: #define tor_assert(expr) STMT_BEGIN                                     \\ /* <=== src/common/util.h:44:51:tor_assert:1 */ \n    if (PREDICT_UNLIKELY(!(expr))) {                                    \\\n      log(LOG_ERR, LD_BUG, \"%s:%d: %s: Assertion %s failed; aborting.\", \\\n          _SHORT_FILE_, __LINE__, __func__, #expr);                     \\\n      fprintf(stderr,\"%s:%d %s: Assertion %s failed; aborting.\\n\",      \\\n              _SHORT_FILE_, __LINE__, __func__, #expr);                 \\\n      abort();                                                          \\\n    } STMT_END\n- tor_fix_source_file: const char * /* <=== tor_fix_source_file */ \ntor_fix_source_file(const char *fname)\n{\n  const char *cp1, *cp2, *r;\n  cp1 = strrchr(fname, '/');\n  cp2 = strrchr(fname, '\\\\');\n  if (cp1 && cp2) {\n    r = (cp1<cp2)?(cp2+1):(cp1+1);\n  } else if (cp1) {\n    r = cp1+1;\n  } else if (cp2) {\n    r = cp2+1;\n  } else {\n    r = fname;\n  }\n  return r;\n}\n- tor_vsnprintf: int /* <=== tor_vsnprintf */ \ntor_vsnprintf(char *str, size_t size, const char *format, va_list args)\n{\n  int r;\n  if (size == 0)\n    return -1; /* no place for the NUL */\n  if (size > SIZE_T_CEILING)\n    return -1;\n#ifdef MS_WINDOWS\n  r = _vsnprintf(str, size, format, args);\n#else\n  r = vsnprintf(str, size, format, args);\n#endif\n  str[size-1] = '\\0';\n  if (r < 0 || r >= (ssize_t)size)\n    return -1;\n  return r;\n}\n\nType Definitions:\n- policy_summary_item_t: typedef struct policy_summary_item_t {\n    uint16_t prt_min; /**< Lowest port number to accept/reject. */\n    uint16_t prt_max; /**< Highest port number to accept/reject. */\n    uint64_t reject_count; /**< Number of IP-Addresses that are rejected to\n                                this port range. */\n    int accepted:1; /** Has this port already been accepted */\n}\n- smartlist_t: typedef struct smartlist_t {\n  /** <b>list</b> has enough capacity to store exactly <b>capacity</b> elements\n   * before it needs to be resized.  Only the first <b>num_used</b> (\\<=\n   * capacity) elements point to valid data.\n   */\n  void **list;\n  int num_used;\n  int capacity;\n} smartlist_t;\n- smartlist_t: typedef struct smartlist_t {\n  /** <b>list</b> has enough capacity to store exactly <b>capacity</b> elements\n   * before it needs to be resized.  Only the first <b>num_used</b> (\\<=\n   * capacity) elements point to valid data.\n   */\n  void **list;\n  int num_used;\n  int capacity;\n}\n\nImports:\n- #include \"or.h\"\n- #include \"ht.h\"",
    "commit_msg": "Fix bounds-checking in policy_summarize\n\nFound by piebeer.",
    "cve_desc": "Buffer overflow in the policy_summarize function in or/policies.c in Tor before 0.2.1.30 allows remote attackers to cause a denial of service (directory authority crash) via a crafted policy that triggers creation of a long port list.",
    "year": 2011,
    "filename": "policies.c",
    "commit_url": "\"https://github.com/torproject/tor/commit/43414eb98821d3b5c6c65181d7545ce938f82c8e\""
  },
  {
    "repository": "torvalds/linux",
    "cve_id": "CVE-2011-1927",
    "cwe_list": [
      "CWE-703"
    ],
    "commit_hash": "64f3b9e203bd06855072e295557dca1485a2ecba",
    "short_hash": "64f3b9e2",
    "vulnerableMethods_before": [
      {
        "filename": "net/ipv4/ip_fragment.c",
        "method_name": "ip_expire",
        "raw_code": "static void ip_expire(unsigned long arg) /* <=== ip_expire */ \n{\n\tstruct ipq *qp;\n\tstruct net *net;\n\n\tqp = container_of((struct inet_frag_queue *) arg, struct ipq, q);\n\tnet = container_of(qp->q.net, struct net, ipv4.frags);\n\n\tspin_lock(&qp->q.lock);\n\n\tif (qp->q.last_in & INET_FRAG_COMPLETE)\n\t\tgoto out;\n\n\tipq_kill(qp);\n\n\tIP_INC_STATS_BH(net, IPSTATS_MIB_REASMTIMEOUT);\n\tIP_INC_STATS_BH(net, IPSTATS_MIB_REASMFAILS);\n\n\tif ((qp->q.last_in & INET_FRAG_FIRST_IN) && qp->q.fragments != NULL) {\n\t\tstruct sk_buff *head = qp->q.fragments;\n\n\t\trcu_read_lock();\n\t\thead->dev = dev_get_by_index_rcu(net, qp->iif);\n\t\tif (!head->dev)\n\t\t\tgoto out_rcu_unlock;\n\n\t\t/*\n\t\t * Only search router table for the head fragment,\n\t\t * when defraging timeout at PRE_ROUTING HOOK.\n\t\t */\n\t\tif (qp->user == IP_DEFRAG_CONNTRACK_IN && !skb_dst(head)) {\n\t\t\tconst struct iphdr *iph = ip_hdr(head);\n\t\t\tint err = ip_route_input(head, iph->daddr, iph->saddr,\n\t\t\t\t\t\t iph->tos, head->dev);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto out_rcu_unlock;\n\n\t\t\t/*\n\t\t\t * Only an end host needs to send an ICMP\n\t\t\t * \"Fragment Reassembly Timeout\" message, per RFC792.\n\t\t\t */\n\t\t\tif (skb_rtable(head)->rt_type != RTN_LOCAL)\n\t\t\t\tgoto out_rcu_unlock;\n\n\t\t}\n\n\t\t/* Send an ICMP \"Fragment Reassembly Timeout\" message. */\n\t\ticmp_send(head, ICMP_TIME_EXCEEDED, ICMP_EXC_FRAGTIME, 0);\nout_rcu_unlock:\n\t\trcu_read_unlock();\n\t}\nout:\n\tspin_unlock(&qp->q.lock);\n\tipq_put(qp);\n}",
        "start_line": 206
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "net/ipv4/ip_fragment.c",
        "method_name": "ip_expire",
        "raw_code": "static void ip_expire(unsigned long arg) /* <=== ip_expire */ \n{\n\tstruct ipq *qp;\n\tstruct net *net;\n\n\tqp = container_of((struct inet_frag_queue *) arg, struct ipq, q);\n\tnet = container_of(qp->q.net, struct net, ipv4.frags);\n\n\tspin_lock(&qp->q.lock);\n\n\tif (qp->q.last_in & INET_FRAG_COMPLETE)\n\t\tgoto out;\n\n\tipq_kill(qp);\n\n\tIP_INC_STATS_BH(net, IPSTATS_MIB_REASMTIMEOUT);\n\tIP_INC_STATS_BH(net, IPSTATS_MIB_REASMFAILS);\n\n\tif ((qp->q.last_in & INET_FRAG_FIRST_IN) && qp->q.fragments != NULL) {\n\t\tstruct sk_buff *head = qp->q.fragments;\n\t\tconst struct iphdr *iph;\n\t\tint err;\n\n\t\trcu_read_lock();\n\t\thead->dev = dev_get_by_index_rcu(net, qp->iif);\n\t\tif (!head->dev)\n\t\t\tgoto out_rcu_unlock;\n\n\t\t/* skb dst is stale, drop it, and perform route lookup again */\n\t\tskb_dst_drop(head);\n\t\tiph = ip_hdr(head);\n\t\terr = ip_route_input_noref(head, iph->daddr, iph->saddr,\n\t\t\t\t\t   iph->tos, head->dev);\n\t\tif (err)\n\t\t\tgoto out_rcu_unlock;\n\n\t\t/*\n\t\t * Only an end host needs to send an ICMP\n\t\t * \"Fragment Reassembly Timeout\" message, per RFC792.\n\t\t */\n\t\tif (qp->user == IP_DEFRAG_CONNTRACK_IN &&\n\t\t    skb_rtable(head)->rt_type != RTN_LOCAL)\n\t\t\tgoto out_rcu_unlock;\n\n\n\t\t/* Send an ICMP \"Fragment Reassembly Timeout\" message. */\n\t\ticmp_send(head, ICMP_TIME_EXCEEDED, ICMP_EXC_FRAGTIME, 0);\nout_rcu_unlock:\n\t\trcu_read_unlock();\n\t}\nout:\n\tspin_unlock(&qp->q.lock);\n\tipq_put(qp);\n}",
        "start_line": 206
      }
    ],
    "code_context": "Called Methods:\n- rcu_read_unlock: static inline void rcu_read_unlock(void) /* <=== rcu_read_unlock */ \n{\n\trcu_read_release();\n\t__release(RCU);\n\t__rcu_read_unlock();\n}\n- icmp_send: void icmp_send(struct sk_buff *skb_in, int type, int code, __be32 info) /* <=== icmp_send */ \n{\n\tstruct iphdr *iph;\n\tint room;\n\tstruct icmp_bxm icmp_param;\n\tstruct rtable *rt = skb_rtable(skb_in);\n\tstruct ipcm_cookie ipc;\n\t__be32 saddr;\n\tu8  tos;\n\tstruct net *net;\n\tstruct sock *sk;\n\n\tif (!rt)\n\t\tgoto out;\n\tnet = dev_net(rt->dst.dev);\n\n\t/*\n\t *\tFind the original header. It is expected to be valid, of course.\n\t *\tCheck this, icmp_send is called from the most obscure devices\n\t *\tsometimes.\n\t */\n\tiph = ip_hdr(skb_in);\n\n\tif ((u8 *)iph < skb_in->head ||\n\t    (skb_in->network_header + sizeof(*iph)) > skb_in->tail)\n\t\tgoto out;\n\n\t/*\n\t *\tNo replies to physical multicast/broadcast\n\t */\n\tif (skb_in->pkt_type != PACKET_HOST)\n\t\tgoto out;\n\n\t/*\n\t *\tNow check at the protocol level\n\t */\n\tif (rt->rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST))\n\t\tgoto out;\n\n\t/*\n\t *\tOnly reply to fragment 0. We byte re-order the constant\n\t *\tmask for efficiency.\n\t */\n\tif (iph->frag_off & htons(IP_OFFSET))\n\t\tgoto out;\n\n\t/*\n\t *\tIf we send an ICMP error to an ICMP error a mess would result..\n\t */\n\tif (icmp_pointers[type].error) {\n\t\t/*\n\t\t *\tWe are an error, check if we are replying to an\n\t\t *\tICMP error\n\t\t */\n\t\tif (iph->protocol == IPPROTO_ICMP) {\n\t\t\tu8 _inner_type, *itp;\n\n\t\t\titp = skb_header_pointer(skb_in,\n\t\t\t\t\t\t skb_network_header(skb_in) +\n\t\t\t\t\t\t (iph->ihl << 2) +\n\t\t\t\t\t\t offsetof(struct icmphdr,\n\t\t\t\t\t\t\t  type) -\n\t\t\t\t\t\t skb_in->data,\n\t\t\t\t\t\t sizeof(_inner_type),\n\t\t\t\t\t\t &_inner_type);\n\t\t\tif (itp == NULL)\n\t\t\t\tgoto out;\n\n\t\t\t/*\n\t\t\t *\tAssume any unknown ICMP type is an error. This\n\t\t\t *\tisn't specified by the RFC, but think about it..\n\t\t\t */\n\t\t\tif (*itp > NR_ICMP_TYPES ||\n\t\t\t    icmp_pointers[*itp].error)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tsk = icmp_xmit_lock(net);\n\tif (sk == NULL)\n\t\treturn;\n\n\t/*\n\t *\tConstruct source address and options.\n\t */\n\n\tsaddr = iph->daddr;\n\tif (!(rt->rt_flags & RTCF_LOCAL)) {\n\t\tstruct net_device *dev = NULL;\n\n\t\trcu_read_lock();\n\t\tif (rt_is_input_route(rt) &&\n\t\t    net->ipv4.sysctl_icmp_errors_use_inbound_ifaddr)\n\t\t\tdev = dev_get_by_index_rcu(net, rt->rt_iif);\n\n\t\tif (dev)\n\t\t\tsaddr = inet_select_addr(dev, 0, RT_SCOPE_LINK);\n\t\telse\n\t\t\tsaddr = 0;\n\t\trcu_read_unlock();\n\t}\n\n\ttos = icmp_pointers[type].error ? ((iph->tos & IPTOS_TOS_MASK) |\n\t\t\t\t\t   IPTOS_PREC_INTERNETCONTROL) :\n\t\t\t\t\t  iph->tos;\n\n\tif (ip_options_echo(&icmp_param.replyopts, skb_in))\n\t\tgoto out_unlock;\n\n\n\t/*\n\t *\tPrepare data for ICMP header.\n\t */\n\n\ticmp_param.data.icmph.type\t = type;\n\ticmp_param.data.icmph.code\t = code;\n\ticmp_param.data.icmph.un.gateway = info;\n\ticmp_param.data.icmph.checksum\t = 0;\n\ticmp_param.skb\t  = skb_in;\n\ticmp_param.offset = skb_network_offset(skb_in);\n\tinet_sk(sk)->tos = tos;\n\tipc.addr = iph->saddr;\n\tipc.opt = &icmp_param.replyopts;\n\tipc.tx_flags = 0;\n\n\trt = icmp_route_lookup(net, skb_in, iph, saddr, tos,\n\t\t\t       type, code, &icmp_param);\n\tif (IS_ERR(rt))\n\t\tgoto out_unlock;\n\n\tif (!icmpv4_xrlim_allow(net, rt, type, code))\n\t\tgoto ende;\n\n\t/* RFC says return as much as we can without exceeding 576 bytes. */\n\n\troom = dst_mtu(&rt->dst);\n\tif (room > 576)\n\t\troom = 576;\n\troom -= sizeof(struct iphdr) + icmp_param.replyopts.optlen;\n\troom -= sizeof(struct icmphdr);\n\n\ticmp_param.data_len = skb_in->len - icmp_param.offset;\n\tif (icmp_param.data_len > room)\n\t\ticmp_param.data_len = room;\n\ticmp_param.head_len = sizeof(struct icmphdr);\n\n\ticmp_push_reply(&icmp_param, &ipc, &rt);\nende:\n\tip_rt_put(rt);\nout_unlock:\n\ticmp_xmit_unlock(sk);\nout:;\n}\n- icmp_route_lookup: static struct rtable *icmp_route_lookup(struct net *net, struct sk_buff *skb_in, /* <=== icmp_route_lookup */ \n\t\t\t\t\tstruct iphdr *iph,\n\t\t\t\t\t__be32 saddr, u8 tos,\n\t\t\t\t\tint type, int code,\n\t\t\t\t\tstruct icmp_bxm *param)\n{\n\tstruct flowi4 fl4 = {\n\t\t.daddr = (param->replyopts.srr ?\n\t\t\t  param->replyopts.faddr : iph->saddr),\n\t\t.saddr = saddr,\n\t\t.flowi4_tos = RT_TOS(tos),\n\t\t.flowi4_proto = IPPROTO_ICMP,\n\t\t.fl4_icmp_type = type,\n\t\t.fl4_icmp_code = code,\n\t};\n\tstruct rtable *rt, *rt2;\n\tint err;\n\n\tsecurity_skb_classify_flow(skb_in, flowi4_to_flowi(&fl4));\n\trt = __ip_route_output_key(net, &fl4);\n\tif (IS_ERR(rt))\n\t\treturn rt;\n\n\t/* No need to clone since we're just using its address. */\n\trt2 = rt;\n\n\tif (!fl4.saddr)\n\t\tfl4.saddr = rt->rt_src;\n\n\trt = (struct rtable *) xfrm_lookup(net, &rt->dst,\n\t\t\t\t\t   flowi4_to_flowi(&fl4), NULL, 0);\n\tif (!IS_ERR(rt)) {\n\t\tif (rt != rt2)\n\t\t\treturn rt;\n\t} else if (PTR_ERR(rt) == -EPERM) {\n\t\trt = NULL;\n\t} else\n\t\treturn rt;\n\n\terr = xfrm_decode_session_reverse(skb_in, flowi4_to_flowi(&fl4), AF_INET);\n\tif (err)\n\t\tgoto relookup_failed;\n\n\tif (inet_addr_type(net, fl4.saddr) == RTN_LOCAL) {\n\t\trt2 = __ip_route_output_key(net, &fl4);\n\t\tif (IS_ERR(rt2))\n\t\t\terr = PTR_ERR(rt2);\n\t} else {\n\t\tstruct flowi4 fl4_2 = {};\n\t\tunsigned long orefdst;\n\n\t\tfl4_2.daddr = fl4.saddr;\n\t\trt2 = ip_route_output_key(net, &fl4_2);\n\t\tif (IS_ERR(rt2)) {\n\t\t\terr = PTR_ERR(rt2);\n\t\t\tgoto relookup_failed;\n\t\t}\n\t\t/* Ugh! */\n\t\torefdst = skb_in->_skb_refdst; /* save old refdst */\n\t\terr = ip_route_input(skb_in, fl4.daddr, fl4.saddr,\n\t\t\t\t     RT_TOS(tos), rt2->dst.dev);\n\n\t\tdst_release(&rt2->dst);\n\t\trt2 = skb_rtable(skb_in);\n\t\tskb_in->_skb_refdst = orefdst; /* restore old refdst */\n\t}\n\n\tif (err)\n\t\tgoto relookup_failed;\n\n\trt2 = (struct rtable *) xfrm_lookup(net, &rt2->dst,\n\t\t\t\t\t    flowi4_to_flowi(&fl4), NULL,\n\t\t\t\t\t    XFRM_LOOKUP_ICMP);\n\tif (!IS_ERR(rt2)) {\n\t\tdst_release(&rt->dst);\n\t\trt = rt2;\n\t} else if (PTR_ERR(rt2) == -EPERM) {\n\t\tif (rt)\n\t\t\tdst_release(&rt->dst);\n\t\treturn rt2;\n\t} else {\n\t\terr = PTR_ERR(rt2);\n\t\tgoto relookup_failed;\n\t}\n\treturn rt;\n\nrelookup_failed:\n\tif (rt)\n\t\treturn rt;\n\treturn ERR_PTR(err);\n}\n- ip_route_input_noref: static inline int ip_route_input_noref(struct sk_buff *skb, __be32 dst, __be32 src, /* <=== ip_route_input_noref */ \n\t\t\t\t       u8 tos, struct net_device *devin)\n{\n\treturn ip_route_input_common(skb, dst, src, tos, devin, true);\n}\n- inet_sk: static inline struct inet_sock *inet_sk(const struct sock *sk) /* <=== inet_sk */ \n{\n\treturn (struct inet_sock *)sk;\n}\n- ip_route_input: static inline int ip_route_input(struct sk_buff *skb, __be32 dst, __be32 src, /* <=== ip_route_input */ \n\t\t\t\t u8 tos, struct net_device *devin)\n{\n\treturn ip_route_input_common(skb, dst, src, tos, devin, false);\n}\n- rt_is_input_route: static inline bool rt_is_input_route(struct rtable *rt) /* <=== rt_is_input_route */ \n{\n\treturn rt->rt_route_iif != 0;\n}\n- ipq_put: static __inline__ void ipq_put(struct ipq *ipq) /* <=== ipq_put */ \n{\n\tinet_frag_put(&ipq->q, &ip4_frags);\n}\n- icmp_push_reply: static void icmp_push_reply(struct icmp_bxm *icmp_param, /* <=== icmp_push_reply */ \n\t\t\t    struct ipcm_cookie *ipc, struct rtable **rt)\n{\n\tstruct sock *sk;\n\tstruct sk_buff *skb;\n\n\tsk = icmp_sk(dev_net((*rt)->dst.dev));\n\tif (ip_append_data(sk, icmp_glue_bits, icmp_param,\n\t\t\t   icmp_param->data_len+icmp_param->head_len,\n\t\t\t   icmp_param->head_len,\n\t\t\t   ipc, rt, MSG_DONTWAIT) < 0) {\n\t\tICMP_INC_STATS_BH(sock_net(sk), ICMP_MIB_OUTERRORS);\n\t\tip_flush_pending_frames(sk);\n\t} else if ((skb = skb_peek(&sk->sk_write_queue)) != NULL) {\n\t\tstruct icmphdr *icmph = icmp_hdr(skb);\n\t\t__wsum csum = 0;\n\t\tstruct sk_buff *skb1;\n\n\t\tskb_queue_walk(&sk->sk_write_queue, skb1) {\n\t\t\tcsum = csum_add(csum, skb1->csum);\n\t\t}\n\t\tcsum = csum_partial_copy_nocheck((void *)&icmp_param->data,\n\t\t\t\t\t\t (char *)icmph,\n\t\t\t\t\t\t icmp_param->head_len, csum);\n\t\ticmph->checksum = csum_fold(csum);\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\tip_push_pending_frames(sk);\n\t}\n}\n- dev_get_by_index_rcu: struct net_device *dev_get_by_index_rcu(struct net *net, int ifindex) /* <=== dev_get_by_index_rcu */ \n{\n\tstruct hlist_node *p;\n\tstruct net_device *dev;\n\tstruct hlist_head *head = dev_index_hash(net, ifindex);\n\n\thlist_for_each_entry_rcu(dev, p, head, index_hlist)\n\t\tif (dev->ifindex == ifindex)\n\t\t\treturn dev;\n\n\treturn NULL;\n}\n- ip_rt_put: static inline void ip_rt_put(struct rtable * rt) /* <=== ip_rt_put */ \n{\n\tif (rt)\n\t\tdst_release(&rt->dst);\n}\n- icmp_xmit_lock: static inline struct sock *icmp_xmit_lock(struct net *net) /* <=== icmp_xmit_lock */ \n{\n\tstruct sock *sk;\n\n\tlocal_bh_disable();\n\n\tsk = icmp_sk(net);\n\n\tif (unlikely(!spin_trylock(&sk->sk_lock.slock))) {\n\t\t/* This can happen if the output path signals a\n\t\t * dst_link_failure() for an outgoing ICMP packet.\n\t\t */\n\t\tlocal_bh_enable();\n\t\treturn NULL;\n\t}\n\treturn sk;\n}\n- dev_index_hash: static inline struct hlist_head *dev_index_hash(struct net *net, int ifindex) /* <=== dev_index_hash */ \n{\n\treturn &net->dev_index_head[ifindex & (NETDEV_HASHENTRIES - 1)];\n}\n- icmp_xmit_unlock: static inline void icmp_xmit_unlock(struct sock *sk) /* <=== icmp_xmit_unlock */ \n{\n\tspin_unlock_bh(&sk->sk_lock.slock);\n}\n- inet_frag_put: static inline void inet_frag_put(struct inet_frag_queue *q, struct inet_frags *f) /* <=== inet_frag_put */ \n{\n\tif (atomic_dec_and_test(&q->refcnt))\n\t\tinet_frag_destroy(q, f, NULL);\n}\n- rcu_read_lock: static inline void rcu_read_lock(void) /* <=== rcu_read_lock */ \n{\n\t__rcu_read_lock();\n\t__acquire(RCU);\n\trcu_read_acquire();\n}\n- ip_options_echo: extern int ip_options_echo(struct ip_options *dopt, struct sk_buff *skb); /* <=== ip_options_echo */ \n- ip_route_input_common: extern int ip_route_input_common(struct sk_buff *skb, __be32 dst, __be32 src, /* <=== ip_route_input_common */ \n\t\t\t\t u8 tos, struct net_device *devin, bool noref);\n- icmpv4_xrlim_allow: static inline bool icmpv4_xrlim_allow(struct net *net, struct rtable *rt, /* <=== icmpv4_xrlim_allow */ \n\t\tint type, int code)\n{\n\tstruct dst_entry *dst = &rt->dst;\n\tbool rc = true;\n\n\tif (type > NR_ICMP_TYPES)\n\t\tgoto out;\n\n\t/* Don't limit PMTU discovery. */\n\tif (type == ICMP_DEST_UNREACH && code == ICMP_FRAG_NEEDED)\n\t\tgoto out;\n\n\t/* No rate limit on loopback */\n\tif (dst->dev && (dst->dev->flags&IFF_LOOPBACK))\n\t\tgoto out;\n\n\t/* Limit if icmp type is enabled in ratemask. */\n\tif ((1 << type) & net->ipv4.sysctl_icmp_ratemask) {\n\t\tif (!rt->peer)\n\t\t\trt_bind_peer(rt, 1);\n\t\trc = inet_peer_xrlim_allow(rt->peer,\n\t\t\t\t\t   net->ipv4.sysctl_icmp_ratelimit);\n\t}\nout:\n\treturn rc;\n}\n\nType Definitions:\n- net: struct net\n- ipq: struct ipq {\n\tstruct inet_frag_queue q;\n\n\tu32\t\tuser;\n\t__be32\t\tsaddr;\n\t__be32\t\tdaddr;\n\t__be16\t\tid;\n\tu8\t\tprotocol;\n\tu8\t\tecn; /* RFC3168 support */\n\tint             iif;\n\tunsigned int    rid;\n\tstruct inet_peer *peer;\n}\n- sk_buff: struct sk_buff {\n\t/* These two members must be first. */\n\tstruct sk_buff\t\t*next;\n\tstruct sk_buff\t\t*prev;\n\n\tktime_t\t\t\ttstamp;\n\n\tstruct sock\t\t*sk;\n\tstruct net_device\t*dev;\n\n\t/*\n\t * This is the control buffer. It is free to use for every\n\t * layer. Please put your private variables there. If you\n\t * want to keep them across layers you have to do a skb_clone()\n\t * first. This is owned by whoever has the skb queued ATM.\n\t */\n\tchar\t\t\tcb[48] __aligned(8);\n\n\tunsigned long\t\t_skb_refdst;\n#ifdef CONFIG_XFRM\n\tstruct\tsec_path\t*sp;\n#endif\n\tunsigned int\t\tlen,\n\t\t\t\tdata_len;\n\t__u16\t\t\tmac_len,\n\t\t\t\thdr_len;\n\tunion {\n\t\t__wsum\t\tcsum;\n\t\tstruct {\n\t\t\t__u16\tcsum_start;\n\t\t\t__u16\tcsum_offset;\n\t\t};\n\t};\n\t__u32\t\t\tpriority;\n\tkmemcheck_bitfield_begin(flags1);\n\t__u8\t\t\tlocal_df:1,\n\t\t\t\tcloned:1,\n\t\t\t\tip_summed:2,\n\t\t\t\tnohdr:1,\n\t\t\t\tnfctinfo:3;\n\t__u8\t\t\tpkt_type:3,\n\t\t\t\tfclone:2,\n\t\t\t\tipvs_property:1,\n\t\t\t\tpeeked:1,\n\t\t\t\tnf_trace:1;\n\tkmemcheck_bitfield_end(flags1);\n\t__be16\t\t\tprotocol;\n\n\tvoid\t\t\t(*destructor)(struct sk_buff *skb);\n#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)\n\tstruct nf_conntrack\t*nfct;\n#endif\n#ifdef NET_SKBUFF_NF_DEFRAG_NEEDED\n\tstruct sk_buff\t\t*nfct_reasm;\n#endif\n#ifdef CONFIG_BRIDGE_NETFILTER\n\tstruct nf_bridge_info\t*nf_bridge;\n#endif\n\n\tint\t\t\tskb_iif;\n#ifdef CONFIG_NET_SCHED\n\t__u16\t\t\ttc_index;\t/* traffic control index */\n#ifdef CONFIG_NET_CLS_ACT\n\t__u16\t\t\ttc_verd;\t/* traffic control verdict */\n#endif\n#endif\n\n\t__u32\t\t\trxhash;\n\n\tkmemcheck_bitfield_begin(flags2);\n\t__u16\t\t\tqueue_mapping:16;\n#ifdef CONFIG_IPV6_NDISC_NODETYPE\n\t__u8\t\t\tndisc_nodetype:2;\n#endif\n\t__u8\t\t\tooo_okay:1;\n\tkmemcheck_bitfield_end(flags2);\n\n\t/* 0/13 bit hole */\n\n#ifdef CONFIG_NET_DMA\n\tdma_cookie_t\t\tdma_cookie;\n#endif\n#ifdef CONFIG_NETWORK_SECMARK\n\t__u32\t\t\tsecmark;\n#endif\n\tunion {\n\t\t__u32\t\tmark;\n\t\t__u32\t\tdropcount;\n\t};\n\n\t__u16\t\t\tvlan_tci;\n\n\tsk_buff_data_t\t\ttransport_header;\n\tsk_buff_data_t\t\tnetwork_header;\n\tsk_buff_data_t\t\tmac_header;\n\t/* These elements must be at the end, see alloc_skb() for details.  */\n\tsk_buff_data_t\t\ttail;\n\tsk_buff_data_t\t\tend;\n\tunsigned char\t\t*head,\n\t\t\t\t*data;\n\tunsigned int\t\ttruesize;\n\tatomic_t\t\tusers;\n}\n- sk_buff: struct sk_buff\n- iphdr: struct iphdr {\n#if defined(__LITTLE_ENDIAN_BITFIELD)\n\t__u8\tihl:4,\n\t\tversion:4;\n#elif defined (__BIG_ENDIAN_BITFIELD)\n\t__u8\tversion:4,\n  \t\tihl:4;\n#else\n#error\t\"Please fix <asm/byteorder.h>\"\n#endif\n\t__u8\ttos;\n\t__be16\ttot_len;\n\t__be16\tid;\n\t__be16\tfrag_off;\n\t__u8\tttl;\n\t__u8\tprotocol;\n\t__sum16\tcheck;\n\t__be32\tsaddr;\n\t__be32\tdaddr;\n\t/*The options start here. */\n}\n\nImports:\n- #include <net/inet_frag.h>\n- #include <net/inet_ecn.h>\n- #include <linux/jhash.h>\n- #include <net/route.h>\n- #include <linux/jiffies.h>\n- #include <net/dst.h>\n- #include <linux/random.h>\n- #include <linux/udp.h>\n- #include <linux/compiler.h>\n- #include <linux/slab.h>\n- #include <linux/skbuff.h>\n- #include <linux/netfilter_ipv4.h>\n- #include <linux/icmp.h>\n- #include <linux/types.h>\n- #include <net/checksum.h>\n- #include <linux/module.h>\n- #include <linux/ip.h>\n- #include <linux/list.h>\n- #include <net/inetpeer.h>\n- #include <net/icmp.h>\n- #include <linux/mm.h>\n- #include <linux/inet.h>\n- #include <linux/tcp.h>\n- #include <net/ip.h>\n- #include <linux/netdevice.h>\n- #include <net/sock.h>",
    "commit_msg": "net: ip_expire() must revalidate route\n\nCommit 4a94445c9a5c (net: Use ip_route_input_noref() in input path)\nadded a bug in IP defragmentation handling, in case timeout is fired.\n\nWhen a frame is defragmented, we use last skb dst field when building\nfinal skb. Its dst is valid, since we are in rcu read section.\n\nBut if a timeout occurs, we take first queued fragment to build one ICMP\nTIME EXCEEDED message. Problem is all queued skb have weak dst pointers,\nsince we escaped RCU critical section after their queueing. icmp_send()\nmight dereference a now freed (and possibly reused) part of memory.\n\nCalling skb_dst_drop() and ip_route_input_noref() to revalidate route is\nthe only possible choice.\n\nReported-by: Denys Fedoryshchenko <denys@visp.net.lb>\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "cve_desc": "The ip_expire function in net/ipv4/ip_fragment.c in the Linux kernel before 2.6.39 does not properly construct ICMP_TIME_EXCEEDED packets after a timeout, which allows remote attackers to cause a denial of service (invalid pointer dereference) via crafted fragmented packets.",
    "year": 2011,
    "filename": "ip_fragment.c",
    "commit_url": "\"https://github.com/torvalds/linux/commit/64f3b9e203bd06855072e295557dca1485a2ecba\""
  },
  {
    "repository": "FFmpeg/FFmpeg",
    "cve_id": "CVE-2011-2161",
    "cwe_list": [
      "CWE-399"
    ],
    "commit_hash": "8312e3fc9041027a33c8bc667bb99740fdf41dd5",
    "short_hash": "8312e3fc",
    "vulnerableMethods_before": [
      {
        "filename": "libavformat/ape.c",
        "method_name": "ape_read_header",
        "raw_code": "static int ape_read_header(AVFormatContext * s, AVFormatParameters * ap) /* <=== ape_read_header */ \n{\n    AVIOContext *pb = s->pb;\n    APEContext *ape = s->priv_data;\n    AVStream *st;\n    uint32_t tag;\n    int i;\n    int total_blocks;\n    int64_t pts;\n\n    /* TODO: Skip any leading junk such as id3v2 tags */\n    ape->junklength = 0;\n\n    tag = avio_rl32(pb);\n    if (tag != MKTAG('M', 'A', 'C', ' '))\n        return -1;\n\n    ape->fileversion = avio_rl16(pb);\n\n    if (ape->fileversion < APE_MIN_VERSION || ape->fileversion > APE_MAX_VERSION) {\n        av_log(s, AV_LOG_ERROR, \"Unsupported file version - %d.%02d\\n\", ape->fileversion / 1000, (ape->fileversion % 1000) / 10);\n        return -1;\n    }\n\n    if (ape->fileversion >= 3980) {\n        ape->padding1             = avio_rl16(pb);\n        ape->descriptorlength     = avio_rl32(pb);\n        ape->headerlength         = avio_rl32(pb);\n        ape->seektablelength      = avio_rl32(pb);\n        ape->wavheaderlength      = avio_rl32(pb);\n        ape->audiodatalength      = avio_rl32(pb);\n        ape->audiodatalength_high = avio_rl32(pb);\n        ape->wavtaillength        = avio_rl32(pb);\n        avio_read(pb, ape->md5, 16);\n\n        /* Skip any unknown bytes at the end of the descriptor.\n           This is for future compatibility */\n        if (ape->descriptorlength > 52)\n            avio_seek(pb, ape->descriptorlength - 52, SEEK_CUR);\n\n        /* Read header data */\n        ape->compressiontype      = avio_rl16(pb);\n        ape->formatflags          = avio_rl16(pb);\n        ape->blocksperframe       = avio_rl32(pb);\n        ape->finalframeblocks     = avio_rl32(pb);\n        ape->totalframes          = avio_rl32(pb);\n        ape->bps                  = avio_rl16(pb);\n        ape->channels             = avio_rl16(pb);\n        ape->samplerate           = avio_rl32(pb);\n    } else {\n        ape->descriptorlength = 0;\n        ape->headerlength = 32;\n\n        ape->compressiontype      = avio_rl16(pb);\n        ape->formatflags          = avio_rl16(pb);\n        ape->channels             = avio_rl16(pb);\n        ape->samplerate           = avio_rl32(pb);\n        ape->wavheaderlength      = avio_rl32(pb);\n        ape->wavtaillength        = avio_rl32(pb);\n        ape->totalframes          = avio_rl32(pb);\n        ape->finalframeblocks     = avio_rl32(pb);\n\n        if (ape->formatflags & MAC_FORMAT_FLAG_HAS_PEAK_LEVEL) {\n            avio_seek(pb, 4, SEEK_CUR); /* Skip the peak level */\n            ape->headerlength += 4;\n        }\n\n        if (ape->formatflags & MAC_FORMAT_FLAG_HAS_SEEK_ELEMENTS) {\n            ape->seektablelength = avio_rl32(pb);\n            ape->headerlength += 4;\n            ape->seektablelength *= sizeof(int32_t);\n        } else\n            ape->seektablelength = ape->totalframes * sizeof(int32_t);\n\n        if (ape->formatflags & MAC_FORMAT_FLAG_8_BIT)\n            ape->bps = 8;\n        else if (ape->formatflags & MAC_FORMAT_FLAG_24_BIT)\n            ape->bps = 24;\n        else\n            ape->bps = 16;\n\n        if (ape->fileversion >= 3950)\n            ape->blocksperframe = 73728 * 4;\n        else if (ape->fileversion >= 3900 || (ape->fileversion >= 3800  && ape->compressiontype >= 4000))\n            ape->blocksperframe = 73728;\n        else\n            ape->blocksperframe = 9216;\n\n        /* Skip any stored wav header */\n        if (!(ape->formatflags & MAC_FORMAT_FLAG_CREATE_WAV_HEADER))\n            avio_seek(pb, ape->wavheaderlength, SEEK_CUR);\n    }\n\n    if(ape->totalframes > UINT_MAX / sizeof(APEFrame)){\n        av_log(s, AV_LOG_ERROR, \"Too many frames: %d\\n\", ape->totalframes);\n        return -1;\n    }\n    ape->frames       = av_malloc(ape->totalframes * sizeof(APEFrame));\n    if(!ape->frames)\n        return AVERROR(ENOMEM);\n    ape->firstframe   = ape->junklength + ape->descriptorlength + ape->headerlength + ape->seektablelength + ape->wavheaderlength;\n    ape->currentframe = 0;\n\n\n    ape->totalsamples = ape->finalframeblocks;\n    if (ape->totalframes > 1)\n        ape->totalsamples += ape->blocksperframe * (ape->totalframes - 1);\n\n    if (ape->seektablelength > 0) {\n        ape->seektable = av_malloc(ape->seektablelength);\n        for (i = 0; i < ape->seektablelength / sizeof(uint32_t); i++)\n            ape->seektable[i] = avio_rl32(pb);\n    }\n\n    ape->frames[0].pos     = ape->firstframe;\n    ape->frames[0].nblocks = ape->blocksperframe;\n    ape->frames[0].skip    = 0;\n    for (i = 1; i < ape->totalframes; i++) {\n        ape->frames[i].pos      = ape->seektable[i]; //ape->frames[i-1].pos + ape->blocksperframe;\n        ape->frames[i].nblocks  = ape->blocksperframe;\n        ape->frames[i - 1].size = ape->frames[i].pos - ape->frames[i - 1].pos;\n        ape->frames[i].skip     = (ape->frames[i].pos - ape->frames[0].pos) & 3;\n    }\n    ape->frames[ape->totalframes - 1].size    = ape->finalframeblocks * 4;\n    ape->frames[ape->totalframes - 1].nblocks = ape->finalframeblocks;\n\n    for (i = 0; i < ape->totalframes; i++) {\n        if(ape->frames[i].skip){\n            ape->frames[i].pos  -= ape->frames[i].skip;\n            ape->frames[i].size += ape->frames[i].skip;\n        }\n        ape->frames[i].size = (ape->frames[i].size + 3) & ~3;\n    }\n\n\n    ape_dumpinfo(s, ape);\n\n    /* try to read APE tags */\n    if (!url_is_streamed(pb)) {\n        ff_ape_parse_tag(s);\n        avio_seek(pb, 0, SEEK_SET);\n    }\n\n    av_log(s, AV_LOG_DEBUG, \"Decoding file - v%d.%02d, compression level %d\\n\", ape->fileversion / 1000, (ape->fileversion % 1000) / 10, ape->compressiontype);\n\n    /* now we are ready: build format streams */\n    st = av_new_stream(s, 0);\n    if (!st)\n        return -1;\n\n    total_blocks = (ape->totalframes == 0) ? 0 : ((ape->totalframes - 1) * ape->blocksperframe) + ape->finalframeblocks;\n\n    st->codec->codec_type      = AVMEDIA_TYPE_AUDIO;\n    st->codec->codec_id        = CODEC_ID_APE;\n    st->codec->codec_tag       = MKTAG('A', 'P', 'E', ' ');\n    st->codec->channels        = ape->channels;\n    st->codec->sample_rate     = ape->samplerate;\n    st->codec->bits_per_coded_sample = ape->bps;\n    st->codec->frame_size      = MAC_SUBFRAME_SIZE;\n\n    st->nb_frames = ape->totalframes;\n    st->start_time = 0;\n    st->duration  = total_blocks / MAC_SUBFRAME_SIZE;\n    av_set_pts_info(st, 64, MAC_SUBFRAME_SIZE, ape->samplerate);\n\n    st->codec->extradata = av_malloc(APE_EXTRADATA_SIZE);\n    st->codec->extradata_size = APE_EXTRADATA_SIZE;\n    AV_WL16(st->codec->extradata + 0, ape->fileversion);\n    AV_WL16(st->codec->extradata + 2, ape->compressiontype);\n    AV_WL16(st->codec->extradata + 4, ape->formatflags);\n\n    pts = 0;\n    for (i = 0; i < ape->totalframes; i++) {\n        ape->frames[i].pts = pts;\n        av_add_index_entry(st, ape->frames[i].pos, ape->frames[i].pts, 0, 0, AVINDEX_KEYFRAME);\n        pts += ape->blocksperframe / MAC_SUBFRAME_SIZE;\n    }\n\n    return 0;\n}",
        "start_line": 152
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "libavformat/ape.c",
        "method_name": "ape_read_header",
        "raw_code": "static int ape_read_header(AVFormatContext * s, AVFormatParameters * ap) /* <=== ape_read_header */ \n{\n    AVIOContext *pb = s->pb;\n    APEContext *ape = s->priv_data;\n    AVStream *st;\n    uint32_t tag;\n    int i;\n    int total_blocks;\n    int64_t pts;\n\n    /* TODO: Skip any leading junk such as id3v2 tags */\n    ape->junklength = 0;\n\n    tag = avio_rl32(pb);\n    if (tag != MKTAG('M', 'A', 'C', ' '))\n        return -1;\n\n    ape->fileversion = avio_rl16(pb);\n\n    if (ape->fileversion < APE_MIN_VERSION || ape->fileversion > APE_MAX_VERSION) {\n        av_log(s, AV_LOG_ERROR, \"Unsupported file version - %d.%02d\\n\", ape->fileversion / 1000, (ape->fileversion % 1000) / 10);\n        return -1;\n    }\n\n    if (ape->fileversion >= 3980) {\n        ape->padding1             = avio_rl16(pb);\n        ape->descriptorlength     = avio_rl32(pb);\n        ape->headerlength         = avio_rl32(pb);\n        ape->seektablelength      = avio_rl32(pb);\n        ape->wavheaderlength      = avio_rl32(pb);\n        ape->audiodatalength      = avio_rl32(pb);\n        ape->audiodatalength_high = avio_rl32(pb);\n        ape->wavtaillength        = avio_rl32(pb);\n        avio_read(pb, ape->md5, 16);\n\n        /* Skip any unknown bytes at the end of the descriptor.\n           This is for future compatibility */\n        if (ape->descriptorlength > 52)\n            avio_seek(pb, ape->descriptorlength - 52, SEEK_CUR);\n\n        /* Read header data */\n        ape->compressiontype      = avio_rl16(pb);\n        ape->formatflags          = avio_rl16(pb);\n        ape->blocksperframe       = avio_rl32(pb);\n        ape->finalframeblocks     = avio_rl32(pb);\n        ape->totalframes          = avio_rl32(pb);\n        ape->bps                  = avio_rl16(pb);\n        ape->channels             = avio_rl16(pb);\n        ape->samplerate           = avio_rl32(pb);\n    } else {\n        ape->descriptorlength = 0;\n        ape->headerlength = 32;\n\n        ape->compressiontype      = avio_rl16(pb);\n        ape->formatflags          = avio_rl16(pb);\n        ape->channels             = avio_rl16(pb);\n        ape->samplerate           = avio_rl32(pb);\n        ape->wavheaderlength      = avio_rl32(pb);\n        ape->wavtaillength        = avio_rl32(pb);\n        ape->totalframes          = avio_rl32(pb);\n        ape->finalframeblocks     = avio_rl32(pb);\n\n        if (ape->formatflags & MAC_FORMAT_FLAG_HAS_PEAK_LEVEL) {\n            avio_seek(pb, 4, SEEK_CUR); /* Skip the peak level */\n            ape->headerlength += 4;\n        }\n\n        if (ape->formatflags & MAC_FORMAT_FLAG_HAS_SEEK_ELEMENTS) {\n            ape->seektablelength = avio_rl32(pb);\n            ape->headerlength += 4;\n            ape->seektablelength *= sizeof(int32_t);\n        } else\n            ape->seektablelength = ape->totalframes * sizeof(int32_t);\n\n        if (ape->formatflags & MAC_FORMAT_FLAG_8_BIT)\n            ape->bps = 8;\n        else if (ape->formatflags & MAC_FORMAT_FLAG_24_BIT)\n            ape->bps = 24;\n        else\n            ape->bps = 16;\n\n        if (ape->fileversion >= 3950)\n            ape->blocksperframe = 73728 * 4;\n        else if (ape->fileversion >= 3900 || (ape->fileversion >= 3800  && ape->compressiontype >= 4000))\n            ape->blocksperframe = 73728;\n        else\n            ape->blocksperframe = 9216;\n\n        /* Skip any stored wav header */\n        if (!(ape->formatflags & MAC_FORMAT_FLAG_CREATE_WAV_HEADER))\n            avio_seek(pb, ape->wavheaderlength, SEEK_CUR);\n    }\n\n    if(!ape->totalframes){\n        av_log(s, AV_LOG_ERROR, \"No frames in the file!\\n\");\n        return AVERROR(EINVAL);\n    }\n    if(ape->totalframes > UINT_MAX / sizeof(APEFrame)){\n        av_log(s, AV_LOG_ERROR, \"Too many frames: %d\\n\", ape->totalframes);\n        return -1;\n    }\n    ape->frames       = av_malloc(ape->totalframes * sizeof(APEFrame));\n    if(!ape->frames)\n        return AVERROR(ENOMEM);\n    ape->firstframe   = ape->junklength + ape->descriptorlength + ape->headerlength + ape->seektablelength + ape->wavheaderlength;\n    ape->currentframe = 0;\n\n\n    ape->totalsamples = ape->finalframeblocks;\n    if (ape->totalframes > 1)\n        ape->totalsamples += ape->blocksperframe * (ape->totalframes - 1);\n\n    if (ape->seektablelength > 0) {\n        ape->seektable = av_malloc(ape->seektablelength);\n        for (i = 0; i < ape->seektablelength / sizeof(uint32_t); i++)\n            ape->seektable[i] = avio_rl32(pb);\n    }\n\n    ape->frames[0].pos     = ape->firstframe;\n    ape->frames[0].nblocks = ape->blocksperframe;\n    ape->frames[0].skip    = 0;\n    for (i = 1; i < ape->totalframes; i++) {\n        ape->frames[i].pos      = ape->seektable[i]; //ape->frames[i-1].pos + ape->blocksperframe;\n        ape->frames[i].nblocks  = ape->blocksperframe;\n        ape->frames[i - 1].size = ape->frames[i].pos - ape->frames[i - 1].pos;\n        ape->frames[i].skip     = (ape->frames[i].pos - ape->frames[0].pos) & 3;\n    }\n    ape->frames[ape->totalframes - 1].size    = ape->finalframeblocks * 4;\n    ape->frames[ape->totalframes - 1].nblocks = ape->finalframeblocks;\n\n    for (i = 0; i < ape->totalframes; i++) {\n        if(ape->frames[i].skip){\n            ape->frames[i].pos  -= ape->frames[i].skip;\n            ape->frames[i].size += ape->frames[i].skip;\n        }\n        ape->frames[i].size = (ape->frames[i].size + 3) & ~3;\n    }\n\n\n    ape_dumpinfo(s, ape);\n\n    /* try to read APE tags */\n    if (!url_is_streamed(pb)) {\n        ff_ape_parse_tag(s);\n        avio_seek(pb, 0, SEEK_SET);\n    }\n\n    av_log(s, AV_LOG_DEBUG, \"Decoding file - v%d.%02d, compression level %d\\n\", ape->fileversion / 1000, (ape->fileversion % 1000) / 10, ape->compressiontype);\n\n    /* now we are ready: build format streams */\n    st = av_new_stream(s, 0);\n    if (!st)\n        return -1;\n\n    total_blocks = (ape->totalframes == 0) ? 0 : ((ape->totalframes - 1) * ape->blocksperframe) + ape->finalframeblocks;\n\n    st->codec->codec_type      = AVMEDIA_TYPE_AUDIO;\n    st->codec->codec_id        = CODEC_ID_APE;\n    st->codec->codec_tag       = MKTAG('A', 'P', 'E', ' ');\n    st->codec->channels        = ape->channels;\n    st->codec->sample_rate     = ape->samplerate;\n    st->codec->bits_per_coded_sample = ape->bps;\n    st->codec->frame_size      = MAC_SUBFRAME_SIZE;\n\n    st->nb_frames = ape->totalframes;\n    st->start_time = 0;\n    st->duration  = total_blocks / MAC_SUBFRAME_SIZE;\n    av_set_pts_info(st, 64, MAC_SUBFRAME_SIZE, ape->samplerate);\n\n    st->codec->extradata = av_malloc(APE_EXTRADATA_SIZE);\n    st->codec->extradata_size = APE_EXTRADATA_SIZE;\n    AV_WL16(st->codec->extradata + 0, ape->fileversion);\n    AV_WL16(st->codec->extradata + 2, ape->compressiontype);\n    AV_WL16(st->codec->extradata + 4, ape->formatflags);\n\n    pts = 0;\n    for (i = 0; i < ape->totalframes; i++) {\n        ape->frames[i].pts = pts;\n        av_add_index_entry(st, ape->frames[i].pos, ape->frames[i].pts, 0, 0, AVINDEX_KEYFRAME);\n        pts += ape->blocksperframe / MAC_SUBFRAME_SIZE;\n    }\n\n    return 0;\n}",
        "start_line": 152
      }
    ],
    "code_context": "Called Methods:\n- SHORT_SEEK_THRESHOLD: #define SHORT_SEEK_THRESHOLD 4096 /* <=== libavformat/aviobuf.c:37:37:SHORT_SEEK_THRESHOLD:0 */ \n- ape_dumpinfo: static void ape_dumpinfo(AVFormatContext * s, APEContext * ape_ctx) /* <=== ape_dumpinfo */ \n{\n#if ENABLE_DEBUG\n    int i;\n\n    av_log(s, AV_LOG_DEBUG, \"Descriptor Block:\\n\\n\");\n    av_log(s, AV_LOG_DEBUG, \"magic                = \\\"%c%c%c%c\\\"\\n\", ape_ctx->magic[0], ape_ctx->magic[1], ape_ctx->magic[2], ape_ctx->magic[3]);\n    av_log(s, AV_LOG_DEBUG, \"fileversion          = %d\\n\", ape_ctx->fileversion);\n    av_log(s, AV_LOG_DEBUG, \"descriptorlength     = %d\\n\", ape_ctx->descriptorlength);\n    av_log(s, AV_LOG_DEBUG, \"headerlength         = %d\\n\", ape_ctx->headerlength);\n    av_log(s, AV_LOG_DEBUG, \"seektablelength      = %d\\n\", ape_ctx->seektablelength);\n    av_log(s, AV_LOG_DEBUG, \"wavheaderlength      = %d\\n\", ape_ctx->wavheaderlength);\n    av_log(s, AV_LOG_DEBUG, \"audiodatalength      = %d\\n\", ape_ctx->audiodatalength);\n    av_log(s, AV_LOG_DEBUG, \"audiodatalength_high = %d\\n\", ape_ctx->audiodatalength_high);\n    av_log(s, AV_LOG_DEBUG, \"wavtaillength        = %d\\n\", ape_ctx->wavtaillength);\n    av_log(s, AV_LOG_DEBUG, \"md5                  = \");\n    for (i = 0; i < 16; i++)\n         av_log(s, AV_LOG_DEBUG, \"%02x\", ape_ctx->md5[i]);\n    av_log(s, AV_LOG_DEBUG, \"\\n\");\n\n    av_log(s, AV_LOG_DEBUG, \"\\nHeader Block:\\n\\n\");\n\n    av_log(s, AV_LOG_DEBUG, \"compressiontype      = %d\\n\", ape_ctx->compressiontype);\n    av_log(s, AV_LOG_DEBUG, \"formatflags          = %d\\n\", ape_ctx->formatflags);\n    av_log(s, AV_LOG_DEBUG, \"blocksperframe       = %d\\n\", ape_ctx->blocksperframe);\n    av_log(s, AV_LOG_DEBUG, \"finalframeblocks     = %d\\n\", ape_ctx->finalframeblocks);\n    av_log(s, AV_LOG_DEBUG, \"totalframes          = %d\\n\", ape_ctx->totalframes);\n    av_log(s, AV_LOG_DEBUG, \"bps                  = %d\\n\", ape_ctx->bps);\n    av_log(s, AV_LOG_DEBUG, \"channels             = %d\\n\", ape_ctx->channels);\n    av_log(s, AV_LOG_DEBUG, \"samplerate           = %d\\n\", ape_ctx->samplerate);\n\n    av_log(s, AV_LOG_DEBUG, \"\\nSeektable\\n\\n\");\n    if ((ape_ctx->seektablelength / sizeof(uint32_t)) != ape_ctx->totalframes) {\n        av_log(s, AV_LOG_DEBUG, \"No seektable\\n\");\n    } else {\n        for (i = 0; i < ape_ctx->seektablelength / sizeof(uint32_t); i++) {\n            if (i < ape_ctx->totalframes - 1) {\n                av_log(s, AV_LOG_DEBUG, \"%8d   %d (%d bytes)\\n\", i, ape_ctx->seektable[i], ape_ctx->seektable[i + 1] - ape_ctx->seektable[i]);\n            } else {\n                av_log(s, AV_LOG_DEBUG, \"%8d   %d\\n\", i, ape_ctx->seektable[i]);\n            }\n        }\n    }\n\n    av_log(s, AV_LOG_DEBUG, \"\\nFrames\\n\\n\");\n    for (i = 0; i < ape_ctx->totalframes; i++)\n        av_log(s, AV_LOG_DEBUG, \"%8d   %8lld %8d (%d samples)\\n\", i, ape_ctx->frames[i].pos, ape_ctx->frames[i].size, ape_ctx->frames[i].nblocks);\n\n    av_log(s, AV_LOG_DEBUG, \"\\nCalculated information:\\n\\n\");\n    av_log(s, AV_LOG_DEBUG, \"junklength           = %d\\n\", ape_ctx->junklength);\n    av_log(s, AV_LOG_DEBUG, \"firstframe           = %d\\n\", ape_ctx->firstframe);\n    av_log(s, AV_LOG_DEBUG, \"totalsamples         = %d\\n\", ape_ctx->totalsamples);\n#endif\n}\n- av_vlog: void av_vlog(void* avcl, int level, const char *fmt, va_list vl) /* <=== av_vlog */ \n{\n    av_log_callback(avcl, level, fmt, vl);\n}\n- av_free: void av_free(void *ptr) /* <=== av_free */ \n{\n#if CONFIG_MEMALIGN_HACK\n    if (ptr)\n        free((char*)ptr - ((char*)ptr)[-1]);\n#else\n    free(ptr);\n#endif\n}\n- MKTAG: #define MKTAG(a,b,c,d) ((a) | ((b) << 8) | ((c) << 16) | ((d) << 24)) /* <=== libavutil/common.h:209:209:MKTAG:4 */ \n- MAC_FORMAT_FLAG_8_BIT: #define MAC_FORMAT_FLAG_8_BIT                 1 // is 8-bit [OBSOLETE] /* <=== libavformat/ape.c:35:35:MAC_FORMAT_FLAG_8_BIT:0 */ \n- av_add_index_entry: int av_add_index_entry(AVStream *st, /* <=== av_add_index_entry */ \n                       int64_t pos, int64_t timestamp, int size, int distance, int flags)\n{\n    return ff_add_index_entry(&st->index_entries, &st->nb_index_entries,\n                              &st->index_entries_allocated_size, pos,\n                              timestamp, size, distance, flags);\n}\n- AVSEEK_FORCE: #define AVSEEK_FORCE 0x20000 /* <=== libavformat/avio.h:282:282:AVSEEK_FORCE:0 */ \n- APE_MAX_VERSION: #define APE_MAX_VERSION 3990 /* <=== libavformat/ape.c:33:33:APE_MAX_VERSION:0 */ \n- av_malloc: void *av_malloc(FF_INTERNAL_MEM_TYPE size) /* <=== av_malloc */ \n{\n    void *ptr = NULL;\n#if CONFIG_MEMALIGN_HACK\n    long diff;\n#endif\n\n    /* let's disallow possible ambiguous cases */\n    if(size > (INT_MAX-16) )\n        return NULL;\n\n#if CONFIG_MEMALIGN_HACK\n    ptr = malloc(size+16);\n    if(!ptr)\n        return ptr;\n    diff= ((-(long)ptr - 1)&15) + 1;\n    ptr = (char*)ptr + diff;\n    ((char*)ptr)[-1]= diff;\n#elif HAVE_POSIX_MEMALIGN\n    if (posix_memalign(&ptr,16,size))\n        ptr = NULL;\n#elif HAVE_MEMALIGN\n    ptr = memalign(16,size);\n    /* Why 64?\n       Indeed, we should align it:\n         on 4 for 386\n         on 16 for 486\n         on 32 for 586, PPro - K6-III\n         on 64 for K7 (maybe for P3 too).\n       Because L1 and L2 caches are aligned on those values.\n       But I don't want to code such logic here!\n     */\n     /* Why 16?\n        Because some CPUs need alignment, for example SSE2 on P4, & most RISC CPUs\n        it will just trigger an exception and the unaligned load will be done in the\n        exception handler or it will just segfault (SSE2 on P4).\n        Why not larger? Because I did not see a difference in benchmarks ...\n     */\n     /* benchmarks with P3\n        memalign(64)+1          3071,3051,3032\n        memalign(64)+2          3051,3032,3041\n        memalign(64)+4          2911,2896,2915\n        memalign(64)+8          2545,2554,2550\n        memalign(64)+16         2543,2572,2563\n        memalign(64)+32         2546,2545,2571\n        memalign(64)+64         2570,2533,2558\n\n        BTW, malloc seems to do 8-byte alignment by default here.\n     */\n#else\n    ptr = malloc(size);\n#endif\n    return ptr;\n}\n- AVERROR_EOF: #define AVERROR_EOF         AVERROR(EPIPE)   ///< End of file /* <=== libavutil/error.h:51:51:AVERROR_EOF:0 */ \n- MAX_PROBE_PACKETS: #define MAX_PROBE_PACKETS 2500 /* <=== libavformat/avformat.h:611:611:MAX_PROBE_PACKETS:0 */ \n- AV_LOG_WARNING: #define AV_LOG_WARNING  24 /* <=== libavutil/log.h:101:101:AV_LOG_WARNING:0 */ \n- AV_LOG_ERROR: #define AV_LOG_ERROR    16 /* <=== libavutil/log.h:95:95:AV_LOG_ERROR:0 */ \n- APE_EXTRADATA_SIZE: #define APE_EXTRADATA_SIZE 6 /* <=== libavformat/ape.c:44:44:APE_EXTRADATA_SIZE:0 */ \n- avio_rl16: unsigned int avio_rl16(AVIOContext *s) /* <=== avio_rl16 */ \n{\n    unsigned int val;\n    val = avio_r8(s);\n    val |= avio_r8(s) << 8;\n    return val;\n}\n- APE_TAG_FOOTER_BYTES: #define APE_TAG_FOOTER_BYTES          32 /* <=== libavformat/apetag.c:30:30:APE_TAG_FOOTER_BYTES:0 */ \n- avio_rl32: unsigned int avio_rl32(AVIOContext *s) /* <=== avio_rl32 */ \n{\n    unsigned int val;\n    val = avio_rl16(s);\n    val |= avio_rl16(s) << 16;\n    return val;\n}\n- av_new_stream: AVStream *av_new_stream(AVFormatContext *s, int id) /* <=== av_new_stream */ \n{\n    AVStream *st;\n    int i;\n\n#if FF_API_MAX_STREAMS\n    if (s->nb_streams >= MAX_STREAMS){\n        av_log(s, AV_LOG_ERROR, \"Too many streams\\n\");\n        return NULL;\n    }\n#else\n    AVStream **streams;\n\n    if (s->nb_streams >= INT_MAX/sizeof(*streams))\n        return NULL;\n    streams = av_realloc(s->streams, (s->nb_streams + 1) * sizeof(*streams));\n    if (!streams)\n        return NULL;\n    s->streams = streams;\n#endif\n\n    st = av_mallocz(sizeof(AVStream));\n    if (!st)\n        return NULL;\n    if (!(st->info = av_mallocz(sizeof(*st->info)))) {\n        av_free(st);\n        return NULL;\n    }\n\n    st->codec= avcodec_alloc_context();\n    if (s->iformat) {\n        /* no default bitrate if decoding */\n        st->codec->bit_rate = 0;\n    }\n    st->index = s->nb_streams;\n    st->id = id;\n    st->start_time = AV_NOPTS_VALUE;\n    st->duration = AV_NOPTS_VALUE;\n        /* we set the current DTS to 0 so that formats without any timestamps\n           but durations get some timestamps, formats with some unknown\n           timestamps have their first few packets buffered and the\n           timestamps corrected before they are returned to the user */\n    st->cur_dts = 0;\n    st->first_dts = AV_NOPTS_VALUE;\n    st->probe_packets = MAX_PROBE_PACKETS;\n\n    /* default pts setting is MPEG-like */\n    av_set_pts_info(st, 33, 1, 90000);\n    st->last_IP_pts = AV_NOPTS_VALUE;\n    for(i=0; i<MAX_REORDER_DELAY+1; i++)\n        st->pts_buffer[i]= AV_NOPTS_VALUE;\n    st->reference_dts = AV_NOPTS_VALUE;\n\n    st->sample_aspect_ratio = (AVRational){0,1};\n\n    s->streams[s->nb_streams++] = st;\n    return st;\n}\n- AVERROR: #define AVERROR(e) (e) /* <=== libavutil/error.h:36:36:AVERROR:1 */ \n- avio_read: int avio_read(AVIOContext *s, unsigned char *buf, int size) /* <=== avio_read */ \n{\n    int len, size1;\n\n    size1 = size;\n    while (size > 0) {\n        len = s->buf_end - s->buf_ptr;\n        if (len > size)\n            len = size;\n        if (len == 0) {\n            if(size > s->buffer_size && !s->update_checksum){\n                if(s->read_packet)\n                    len = s->read_packet(s->opaque, buf, size);\n                if (len <= 0) {\n                    /* do not modify buffer if EOF reached so that a seek back can\n                    be done without rereading data */\n                    s->eof_reached = 1;\n                    if(len<0)\n                        s->error= len;\n                    break;\n                } else {\n                    s->pos += len;\n                    size -= len;\n                    buf += len;\n                    s->buf_ptr = s->buffer;\n                    s->buf_end = s->buffer/* + len*/;\n                }\n            }else{\n                fill_buffer(s);\n                len = s->buf_end - s->buf_ptr;\n                if (len == 0)\n                    break;\n            }\n        } else {\n            memcpy(buf, s->buf_ptr, len);\n            buf += len;\n            s->buf_ptr += len;\n            size -= len;\n        }\n    }\n    if (size1 == size) {\n        if (s->error)         return s->error;\n        if (s->eof_reached)   return AVERROR_EOF;\n    }\n    return size1 - size;\n}\n- AV_NOPTS_VALUE: #define AV_NOPTS_VALUE          INT64_C(0x8000000000000000) /* <=== libavutil/avutil.h:96:96:AV_NOPTS_VALUE:0 */ \n- avcodec_alloc_context: AVCodecContext *avcodec_alloc_context(void); /* <=== avcodec_alloc_context */ \n- MAC_FORMAT_FLAG_HAS_SEEK_ELEMENTS: #define MAC_FORMAT_FLAG_HAS_SEEK_ELEMENTS    16 // has the number of seek elements after the peak level /* <=== libavformat/ape.c:39:39:MAC_FORMAT_FLAG_HAS_SEEK_ELEMENTS:0 */ \n- av_log: void av_log(void* avcl, int level, const char *fmt, ...) /* <=== av_log */ \n{\n    AVClass* avc= avcl ? *(AVClass**)avcl : NULL;\n    va_list vl;\n    va_start(vl, fmt);\n    if(avc && avc->version >= (50<<16 | 15<<8 | 2) && avc->log_level_offset_offset && level>=AV_LOG_FATAL)\n        level += *(int*)(((uint8_t*)avcl) + avc->log_level_offset_offset);\n    av_vlog(avcl, level, fmt, vl);\n    va_end(vl);\n}\n- AV_LOG_FATAL: #define AV_LOG_FATAL     8 /* <=== libavutil/log.h:89:89:AV_LOG_FATAL:0 */ \n- url_is_streamed: static inline int url_is_streamed(AVIOContext *s) /* <=== url_is_streamed */ \n{\n    return s->is_streamed;\n}\n- avio_size: int64_t avio_size(AVIOContext *s) /* <=== avio_size */ \n{\n    int64_t size;\n\n    if(!s)\n        return AVERROR(EINVAL);\n\n    if (!s->seek)\n        return AVERROR(ENOSYS);\n    size = s->seek(s->opaque, 0, AVSEEK_SIZE);\n    if(size<0){\n        if ((size = s->seek(s->opaque, -1, SEEK_END)) < 0)\n            return size;\n        size++;\n        s->seek(s->opaque, s->pos, SEEK_SET);\n    }\n    return size;\n}\n- av_set_pts_info: void av_set_pts_info(AVStream *s, int pts_wrap_bits, /* <=== av_set_pts_info */ \n                     unsigned int pts_num, unsigned int pts_den)\n{\n    AVRational new_tb;\n    if(av_reduce(&new_tb.num, &new_tb.den, pts_num, pts_den, INT_MAX)){\n        if(new_tb.num != pts_num)\n            av_log(NULL, AV_LOG_DEBUG, \"st:%d removing common factor %d from timebase\\n\", s->index, pts_num/new_tb.num);\n    }else\n        av_log(NULL, AV_LOG_WARNING, \"st:%d has too large timebase, reducing\\n\", s->index);\n\n    if(new_tb.num <= 0 || new_tb.den <= 0) {\n        av_log(NULL, AV_LOG_ERROR, \"Ignoring attempt to set invalid timebase for st:%d\\n\", s->index);\n        return;\n    }\n    s->time_base = new_tb;\n    s->pts_wrap_bits = pts_wrap_bits;\n}\n- av_mallocz: void *av_mallocz(FF_INTERNAL_MEM_TYPE size) /* <=== av_mallocz */ \n{\n    void *ptr = av_malloc(size);\n    if (ptr)\n        memset(ptr, 0, size);\n    return ptr;\n}\n- MAX_REORDER_DELAY: #define MAX_REORDER_DELAY 16 /* <=== libavformat/avformat.h:579:579:MAX_REORDER_DELAY:0 */ \n- avio_seek: int64_t avio_seek(AVIOContext *s, int64_t offset, int whence) /* <=== avio_seek */ \n{\n    int64_t offset1;\n    int64_t pos;\n    int force = whence & AVSEEK_FORCE;\n    whence &= ~AVSEEK_FORCE;\n\n    if(!s)\n        return AVERROR(EINVAL);\n\n    pos = s->pos - (s->write_flag ? 0 : (s->buf_end - s->buffer));\n\n    if (whence != SEEK_CUR && whence != SEEK_SET)\n        return AVERROR(EINVAL);\n\n    if (whence == SEEK_CUR) {\n        offset1 = pos + (s->buf_ptr - s->buffer);\n        if (offset == 0)\n            return offset1;\n        offset += offset1;\n    }\n    offset1 = offset - pos;\n    if (!s->must_flush &&\n        offset1 >= 0 && offset1 <= (s->buf_end - s->buffer)) {\n        /* can do the seek inside the buffer */\n        s->buf_ptr = s->buffer + offset1;\n    } else if ((s->is_streamed ||\n               offset1 <= s->buf_end + SHORT_SEEK_THRESHOLD - s->buffer) &&\n               !s->write_flag && offset1 >= 0 &&\n              (whence != SEEK_END || force)) {\n        while(s->pos < offset && !s->eof_reached)\n            fill_buffer(s);\n        if (s->eof_reached)\n            return AVERROR_EOF;\n        s->buf_ptr = s->buf_end + offset - s->pos;\n    } else {\n        int64_t res;\n\n#if CONFIG_MUXERS || CONFIG_NETWORK\n        if (s->write_flag) {\n            flush_buffer(s);\n            s->must_flush = 1;\n        }\n#endif /* CONFIG_MUXERS || CONFIG_NETWORK */\n        if (!s->seek)\n            return AVERROR(EPIPE);\n        if ((res = s->seek(s->opaque, offset, SEEK_SET)) < 0)\n            return res;\n        if (!s->write_flag)\n            s->buf_end = s->buffer;\n        s->buf_ptr = s->buffer;\n        s->pos = offset;\n    }\n    s->eof_reached = 0;\n    return offset;\n}\n- APE_MIN_VERSION: #define APE_MIN_VERSION 3950 /* <=== libavformat/ape.c:32:32:APE_MIN_VERSION:0 */ \n- MAC_FORMAT_FLAG_HAS_PEAK_LEVEL: #define MAC_FORMAT_FLAG_HAS_PEAK_LEVEL        4 // uint32 nPeakLevel after the header [OBSOLETE] /* <=== libavformat/ape.c:37:37:MAC_FORMAT_FLAG_HAS_PEAK_LEVEL:0 */ \n- AV_LOG_DEBUG: #define AV_LOG_DEBUG    48 /* <=== libavutil/log.h:109:109:AV_LOG_DEBUG:0 */ \n- APE_TAG_FLAG_IS_HEADER: #define APE_TAG_FLAG_IS_HEADER        (1 << 29) /* <=== libavformat/apetag.c:32:32:APE_TAG_FLAG_IS_HEADER:0 */ \n- MAX_STREAMS: #define MAX_STREAMS 20 /* <=== libavformat/avformat.h:678:678:MAX_STREAMS:0 */ \n- AVINDEX_KEYFRAME: #define AVINDEX_KEYFRAME 0x0001 /* <=== libavformat/avformat.h:459:459:AVINDEX_KEYFRAME:0 */ \n- ape_tag_read_field: static int ape_tag_read_field(AVFormatContext *s) /* <=== ape_tag_read_field */ \n{\n    AVIOContext *pb = s->pb;\n    uint8_t key[1024], *value;\n    uint32_t size, flags;\n    int i, c;\n\n    size = avio_rl32(pb);  /* field size */\n    flags = avio_rl32(pb); /* field flags */\n    for (i = 0; i < sizeof(key) - 1; i++) {\n        c = avio_r8(pb);\n        if (c < 0x20 || c > 0x7E)\n            break;\n        else\n            key[i] = c;\n    }\n    key[i] = 0;\n    if (c != 0) {\n        av_log(s, AV_LOG_WARNING, \"Invalid APE tag key '%s'.\\n\", key);\n        return -1;\n    }\n    if (size >= UINT_MAX)\n        return -1;\n    value = av_malloc(size+1);\n    if (!value)\n        return AVERROR(ENOMEM);\n    avio_read(pb, value, size);\n    value[size] = 0;\n    av_metadata_set2(&s->metadata, key, value, AV_METADATA_DONT_STRDUP_VAL);\n    return 0;\n}\n- ff_add_index_entry: int ff_add_index_entry(AVIndexEntry **index_entries, /* <=== ff_add_index_entry */ \n                       int *nb_index_entries,\n                       unsigned int *index_entries_allocated_size,\n                       int64_t pos, int64_t timestamp, int size, int distance, int flags)\n{\n    AVIndexEntry *entries, *ie;\n    int index;\n\n    if((unsigned)*nb_index_entries + 1 >= UINT_MAX / sizeof(AVIndexEntry))\n        return -1;\n\n    entries = av_fast_realloc(*index_entries,\n                              index_entries_allocated_size,\n                              (*nb_index_entries + 1) *\n                              sizeof(AVIndexEntry));\n    if(!entries)\n        return -1;\n\n    *index_entries= entries;\n\n    index= ff_index_search_timestamp(*index_entries, *nb_index_entries, timestamp, AVSEEK_FLAG_ANY);\n\n    if(index<0){\n        index= (*nb_index_entries)++;\n        ie= &entries[index];\n        assert(index==0 || ie[-1].timestamp < timestamp);\n    }else{\n        ie= &entries[index];\n        if(ie->timestamp != timestamp){\n            if(ie->timestamp <= timestamp)\n                return -1;\n            memmove(entries + index + 1, entries + index, sizeof(AVIndexEntry)*(*nb_index_entries - index));\n            (*nb_index_entries)++;\n        }else if(ie->pos == pos && distance < ie->min_distance) //do not reduce the distance\n            distance= ie->min_distance;\n    }\n\n    ie->pos = pos;\n    ie->timestamp = timestamp;\n    ie->min_distance= distance;\n    ie->size= size;\n    ie->flags = flags;\n\n    return index;\n}\n- APE_TAG_VERSION: #define APE_TAG_VERSION               2000 /* <=== libavformat/apetag.c:29:29:APE_TAG_VERSION:0 */ \n- MAC_FORMAT_FLAG_CREATE_WAV_HEADER: #define MAC_FORMAT_FLAG_CREATE_WAV_HEADER    32 // create the wave header on decompression (not stored) /* <=== libavformat/ape.c:40:40:MAC_FORMAT_FLAG_CREATE_WAV_HEADER:0 */ \n- MAC_SUBFRAME_SIZE: #define MAC_SUBFRAME_SIZE 4608 /* <=== libavformat/ape.c:42:42:MAC_SUBFRAME_SIZE:0 */ \n- MAC_FORMAT_FLAG_24_BIT: #define MAC_FORMAT_FLAG_24_BIT                8 // is 24-bit [OBSOLETE] /* <=== libavformat/ape.c:38:38:MAC_FORMAT_FLAG_24_BIT:0 */ \n- fill_buffer: static void fill_buffer(AVIOContext *s) /* <=== fill_buffer */ \n{\n    uint8_t *dst= !s->max_packet_size && s->buf_end - s->buffer < s->buffer_size ? s->buf_end : s->buffer;\n    int len= s->buffer_size - (dst - s->buffer);\n    int max_buffer_size = s->max_packet_size ? s->max_packet_size : IO_BUFFER_SIZE;\n\n    /* no need to do anything if EOF already reached */\n    if (s->eof_reached)\n        return;\n\n    if(s->update_checksum && dst == s->buffer){\n        if(s->buf_end > s->checksum_ptr)\n            s->checksum= s->update_checksum(s->checksum, s->checksum_ptr, s->buf_end - s->checksum_ptr);\n        s->checksum_ptr= s->buffer;\n    }\n\n    /* make buffer smaller in case it ended up large after probing */\n    if (s->buffer_size > max_buffer_size) {\n        url_setbufsize(s, max_buffer_size);\n\n        s->checksum_ptr = dst = s->buffer;\n        len = s->buffer_size;\n    }\n\n    if(s->read_packet)\n        len = s->read_packet(s->opaque, dst, len);\n    else\n        len = 0;\n    if (len <= 0) {\n        /* do not modify buffer if EOF reached so that a seek back can\n           be done without rereading data */\n        s->eof_reached = 1;\n        if(len<0)\n            s->error= len;\n    } else {\n        s->pos += len;\n        s->buf_ptr = dst;\n        s->buf_end = dst + len;\n    }\n}\n- ff_ape_parse_tag: void ff_ape_parse_tag(AVFormatContext *s) /* <=== ff_ape_parse_tag */ \n{\n    AVIOContext *pb = s->pb;\n    int file_size = avio_size(pb);\n    uint32_t val, fields, tag_bytes;\n    uint8_t buf[8];\n    int i;\n\n    if (file_size < APE_TAG_FOOTER_BYTES)\n        return;\n\n    avio_seek(pb, file_size - APE_TAG_FOOTER_BYTES, SEEK_SET);\n\n    avio_read(pb, buf, 8);     /* APETAGEX */\n    if (strncmp(buf, \"APETAGEX\", 8)) {\n        return;\n    }\n\n    val = avio_rl32(pb);       /* APE tag version */\n    if (val > APE_TAG_VERSION) {\n        av_log(s, AV_LOG_ERROR, \"Unsupported tag version. (>=%d)\\n\", APE_TAG_VERSION);\n        return;\n    }\n\n    tag_bytes = avio_rl32(pb); /* tag size */\n    if (tag_bytes - APE_TAG_FOOTER_BYTES > (1024 * 1024 * 16)) {\n        av_log(s, AV_LOG_ERROR, \"Tag size is way too big\\n\");\n        return;\n    }\n\n    fields = avio_rl32(pb);    /* number of fields */\n    if (fields > 65536) {\n        av_log(s, AV_LOG_ERROR, \"Too many tag fields (%d)\\n\", fields);\n        return;\n    }\n\n    val = avio_rl32(pb);       /* flags */\n    if (val & APE_TAG_FLAG_IS_HEADER) {\n        av_log(s, AV_LOG_ERROR, \"APE Tag is a header\\n\");\n        return;\n    }\n\n    avio_seek(pb, file_size - tag_bytes, SEEK_SET);\n\n    for (i=0; i<fields; i++)\n        if (ape_tag_read_field(s) < 0) break;\n}\n- avio_r8: int avio_r8(AVIOContext *s) /* <=== avio_r8 */ \n{\n    if (s->buf_ptr >= s->buf_end)\n        fill_buffer(s);\n    if (s->buf_ptr < s->buf_end)\n        return *s->buf_ptr++;\n    return 0;\n}\n\nType Definitions:\n- AVIOContext: typedef struct {\n    unsigned char *buffer;\n    int buffer_size;\n    unsigned char *buf_ptr, *buf_end;\n    void *opaque;\n    int (*read_packet)(void *opaque, uint8_t *buf, int buf_size);\n    int (*write_packet)(void *opaque, uint8_t *buf, int buf_size);\n    int64_t (*seek)(void *opaque, int64_t offset, int whence);\n    int64_t pos; /**< position in the file of the current buffer */\n    int must_flush; /**< true if the next seek should flush */\n    int eof_reached; /**< true if eof reached */\n    int write_flag;  /**< true if open for writing */\n    int is_streamed;\n    int max_packet_size;\n    unsigned long checksum;\n    unsigned char *checksum_ptr;\n    unsigned long (*update_checksum)(unsigned long checksum, const uint8_t *buf, unsigned int size);\n    int error;         ///< contains the error code or 0 if no error happened\n    int (*read_pause)(void *opaque, int pause);\n    int64_t (*read_seek)(void *opaque, int stream_index,\n                         int64_t timestamp, int flags);\n}\n- APEContext: typedef struct {\n    /* Derived fields */\n    uint32_t junklength;\n    uint32_t firstframe;\n    uint32_t totalsamples;\n    int currentframe;\n    APEFrame *frames;\n\n    /* Info from Descriptor Block */\n    char magic[4];\n    int16_t fileversion;\n    int16_t padding1;\n    uint32_t descriptorlength;\n    uint32_t headerlength;\n    uint32_t seektablelength;\n    uint32_t wavheaderlength;\n    uint32_t audiodatalength;\n    uint32_t audiodatalength_high;\n    uint32_t wavtaillength;\n    uint8_t md5[16];\n\n    /* Info from Header Block */\n    uint16_t compressiontype;\n    uint16_t formatflags;\n    uint32_t blocksperframe;\n    uint32_t finalframeblocks;\n    uint32_t totalframes;\n    uint16_t bps;\n    uint16_t channels;\n    uint32_t samplerate;\n\n    /* Seektable */\n    uint32_t *seektable;\n}\n- AVStream: typedef struct AVStream {\n    int index;    /**< stream index in AVFormatContext */\n    int id;       /**< format-specific stream ID */\n    AVCodecContext *codec; /**< codec context */\n    /**\n     * Real base framerate of the stream.\n     * This is the lowest framerate with which all timestamps can be\n     * represented accurately (it is the least common multiple of all\n     * framerates in the stream). Note, this value is just a guess!\n     * For example, if the time base is 1/90000 and all frames have either\n     * approximately 3600 or 1800 timer ticks, then r_frame_rate will be 50/1.\n     */\n    AVRational r_frame_rate;\n    void *priv_data;\n\n    /* internal data used in av_find_stream_info() */\n    int64_t first_dts;\n\n    /**\n     * encoding: pts generation when outputting stream\n     */\n    struct AVFrac pts;\n\n    /**\n     * This is the fundamental unit of time (in seconds) in terms\n     * of which frame timestamps are represented. For fixed-fps content,\n     * time base should be 1/framerate and timestamp increments should be 1.\n     * decoding: set by libavformat\n     * encoding: set by libavformat in av_write_header\n     */\n    AVRational time_base;\n    int pts_wrap_bits; /**< number of bits in pts (used for wrapping control) */\n    /* ffmpeg.c private use */\n    int stream_copy; /**< If set, just copy stream. */\n    enum AVDiscard discard; ///< Selects which packets can be discarded at will and do not need to be demuxed.\n\n    //FIXME move stuff to a flags field?\n    /**\n     * Quality, as it has been removed from AVCodecContext and put in AVVideoFrame.\n     * MN: dunno if that is the right place for it\n     */\n    float quality;\n\n    /**\n     * Decoding: pts of the first frame of the stream, in stream time base.\n     * Only set this if you are absolutely 100% sure that the value you set\n     * it to really is the pts of the first frame.\n     * This may be undefined (AV_NOPTS_VALUE).\n     * @note The ASF header does NOT contain a correct start_time the ASF\n     * demuxer must NOT set this.\n     */\n    int64_t start_time;\n\n    /**\n     * Decoding: duration of the stream, in stream time base.\n     * If a source file does not specify a duration, but does specify\n     * a bitrate, this value will be estimated from bitrate and file size.\n     */\n    int64_t duration;\n\n#if FF_API_OLD_METADATA\n    attribute_deprecated char language[4]; /**< ISO 639-2/B 3-letter language code (empty string if undefined) */\n#endif\n\n    /* av_read_frame() support */\n    enum AVStreamParseType need_parsing;\n    struct AVCodecParserContext *parser;\n\n    int64_t cur_dts;\n    int last_IP_duration;\n    int64_t last_IP_pts;\n    /* av_seek_frame() support */\n    AVIndexEntry *index_entries; /**< Only used if the format does not\n                                    support seeking natively. */\n    int nb_index_entries;\n    unsigned int index_entries_allocated_size;\n\n    int64_t nb_frames;                 ///< number of frames in this stream if known or 0\n\n#if FF_API_LAVF_UNUSED\n    attribute_deprecated int64_t unused[4+1];\n#endif\n\n#if FF_API_OLD_METADATA\n    attribute_deprecated char *filename; /**< source filename of the stream */\n#endif\n\n    int disposition; /**< AV_DISPOSITION_* bit field */\n\n    AVProbeData probe_data;\n#define MAX_REORDER_DELAY 16\n    int64_t pts_buffer[MAX_REORDER_DELAY+1];\n\n    /**\n     * sample aspect ratio (0 if unknown)\n     * - encoding: Set by user.\n     * - decoding: Set by libavformat.\n     */\n    AVRational sample_aspect_ratio;\n\n    AVMetadata *metadata;\n\n    /* Intended mostly for av_read_frame() support. Not supposed to be used by */\n    /* external applications; try to use something else if at all possible.    */\n    const uint8_t *cur_ptr;\n    int cur_len;\n    AVPacket cur_pkt;\n\n    // Timestamp generation support:\n    /**\n     * Timestamp corresponding to the last dts sync point.\n     *\n     * Initialized when AVCodecParserContext.dts_sync_point >= 0 and\n     * a DTS is received from the underlying container. Otherwise set to\n     * AV_NOPTS_VALUE by default.\n     */\n    int64_t reference_dts;\n\n    /**\n     * Number of packets to buffer for codec probing\n     * NOT PART OF PUBLIC API\n     */\n#define MAX_PROBE_PACKETS 2500\n    int probe_packets;\n\n    /**\n     * last packet in packet_buffer for this stream when muxing.\n     * used internally, NOT PART OF PUBLIC API, dont read or write from outside of libav*\n     */\n    struct AVPacketList *last_in_packet_buffer;\n\n    /**\n     * Average framerate\n     */\n    AVRational avg_frame_rate;\n\n    /**\n     * Number of frames that have been demuxed during av_find_stream_info()\n     */\n    int codec_info_nb_frames;\n\n    /**\n     * Stream informations used internally by av_find_stream_info()\n     */\n#define MAX_STD_TIMEBASES (60*12+5)\n    struct {\n        int64_t last_dts;\n        int64_t duration_gcd;\n        int duration_count;\n        double duration_error[MAX_STD_TIMEBASES];\n        int64_t codec_info_duration;\n    } *info;\n}\n- AVFormatContext: typedef struct AVFormatContext {\n    const AVClass *av_class; /**< Set by avformat_alloc_context. */\n    /* Can only be iformat or oformat, not both at the same time. */\n    struct AVInputFormat *iformat;\n    struct AVOutputFormat *oformat;\n    void *priv_data;\n    AVIOContext *pb;\n    unsigned int nb_streams;\n#if FF_API_MAX_STREAMS\n    AVStream *streams[MAX_STREAMS];\n#else\n    AVStream **streams;\n#endif\n    char filename[1024]; /**< input or output filename */\n    /* stream info */\n    int64_t timestamp;\n#if FF_API_OLD_METADATA\n    attribute_deprecated char title[512];\n    attribute_deprecated char author[512];\n    attribute_deprecated char copyright[512];\n    attribute_deprecated char comment[512];\n    attribute_deprecated char album[512];\n    attribute_deprecated int year;  /**< ID3 year, 0 if none */\n    attribute_deprecated int track; /**< track number, 0 if none */\n    attribute_deprecated char genre[32]; /**< ID3 genre */\n#endif\n\n    int ctx_flags; /**< Format-specific flags, see AVFMTCTX_xx */\n    /* private data for pts handling (do not modify directly). */\n    /**\n     * This buffer is only needed when packets were already buffered but\n     * not decoded, for example to get the codec parameters in MPEG\n     * streams.\n     */\n    struct AVPacketList *packet_buffer;\n\n    /**\n     * Decoding: position of the first frame of the component, in\n     * AV_TIME_BASE fractional seconds. NEVER set this value directly:\n     * It is deduced from the AVStream values.\n     */\n    int64_t start_time;\n\n    /**\n     * Decoding: duration of the stream, in AV_TIME_BASE fractional\n     * seconds. Only set this value if you know none of the individual stream\n     * durations and also dont set any of them. This is deduced from the\n     * AVStream values if not set.\n     */\n    int64_t duration;\n\n    /**\n     * decoding: total file size, 0 if unknown\n     */\n    int64_t file_size;\n\n    /**\n     * Decoding: total stream bitrate in bit/s, 0 if not\n     * available. Never set it directly if the file_size and the\n     * duration are known as FFmpeg can compute it automatically.\n     */\n    int bit_rate;\n\n    /* av_read_frame() support */\n    AVStream *cur_st;\n#if FF_API_LAVF_UNUSED\n    const uint8_t *cur_ptr_deprecated;\n    int cur_len_deprecated;\n    AVPacket cur_pkt_deprecated;\n#endif\n\n    /* av_seek_frame() support */\n    int64_t data_offset; /**< offset of the first packet */\n#if FF_API_INDEX_BUILT\n    attribute_deprecated int index_built;\n#endif\n\n    int mux_rate;\n    unsigned int packet_size;\n    int preload;\n    int max_delay;\n\n#define AVFMT_NOOUTPUTLOOP -1\n#define AVFMT_INFINITEOUTPUTLOOP 0\n    /**\n     * number of times to loop output in formats that support it\n     */\n    int loop_output;\n\n    int flags;\n#define AVFMT_FLAG_GENPTS       0x0001 ///< Generate missing pts even if it requires parsing future frames.\n#define AVFMT_FLAG_IGNIDX       0x0002 ///< Ignore index.\n#define AVFMT_FLAG_NONBLOCK     0x0004 ///< Do not block when reading packets from input.\n#define AVFMT_FLAG_IGNDTS       0x0008 ///< Ignore DTS on frames that contain both DTS & PTS\n#define AVFMT_FLAG_NOFILLIN     0x0010 ///< Do not infer any values from other values, just return what is stored in the container\n#define AVFMT_FLAG_NOPARSE      0x0020 ///< Do not use AVParsers, you also must set AVFMT_FLAG_NOFILLIN as the fillin code works on frames and no parsing -> no frames. Also seeking to frames can not work if parsing to find frame boundaries has been disabled\n#define AVFMT_FLAG_RTP_HINT     0x0040 ///< Add RTP hinting to the output file\n\n    int loop_input;\n\n    /**\n     * decoding: size of data to probe; encoding: unused.\n     */\n    unsigned int probesize;\n\n    /**\n     * Maximum time (in AV_TIME_BASE units) during which the input should\n     * be analyzed in av_find_stream_info().\n     */\n    int max_analyze_duration;\n\n    const uint8_t *key;\n    int keylen;\n\n    unsigned int nb_programs;\n    AVProgram **programs;\n\n    /**\n     * Forced video codec_id.\n     * Demuxing: Set by user.\n     */\n    enum CodecID video_codec_id;\n\n    /**\n     * Forced audio codec_id.\n     * Demuxing: Set by user.\n     */\n    enum CodecID audio_codec_id;\n\n    /**\n     * Forced subtitle codec_id.\n     * Demuxing: Set by user.\n     */\n    enum CodecID subtitle_codec_id;\n\n    /**\n     * Maximum amount of memory in bytes to use for the index of each stream.\n     * If the index exceeds this size, entries will be discarded as\n     * needed to maintain a smaller size. This can lead to slower or less\n     * accurate seeking (depends on demuxer).\n     * Demuxers for which a full in-memory index is mandatory will ignore\n     * this.\n     * muxing  : unused\n     * demuxing: set by user\n     */\n    unsigned int max_index_size;\n\n    /**\n     * Maximum amount of memory in bytes to use for buffering frames\n     * obtained from realtime capture devices.\n     */\n    unsigned int max_picture_buffer;\n\n    unsigned int nb_chapters;\n    AVChapter **chapters;\n\n    /**\n     * Flags to enable debugging.\n     */\n    int debug;\n#define FF_FDEBUG_TS        0x0001\n\n    /**\n     * Raw packets from the demuxer, prior to parsing and decoding.\n     * This buffer is used for buffering packets until the codec can\n     * be identified, as parsing cannot be done without knowing the\n     * codec.\n     */\n    struct AVPacketList *raw_packet_buffer;\n    struct AVPacketList *raw_packet_buffer_end;\n\n    struct AVPacketList *packet_buffer_end;\n\n    AVMetadata *metadata;\n\n    /**\n     * Remaining size available for raw_packet_buffer, in bytes.\n     * NOT PART OF PUBLIC API\n     */\n#define RAW_PACKET_BUFFER_SIZE 2500000\n    int raw_packet_buffer_remaining_size;\n\n    /**\n     * Start time of the stream in real world time, in microseconds\n     * since the unix epoch (00:00 1st January 1970). That is, pts=0\n     * in the stream was captured at this real world time.\n     * - encoding: Set by user.\n     * - decoding: Unused.\n     */\n    int64_t start_time_realtime;\n}\n\nGlobal Variables:\n- struct APEFrame\n\nImports:\n- #include <stdio.h>\n- #include \"libavutil/intreadwrite.h\"\n- #include \"avformat.h\"\n- #include \"apetag.h\"",
    "commit_msg": "Do not attempt to decode APE file with no frames\n\nThis fixes invalid reads/writes with this sample:\nhttp://packetstorm.linuxsecurity.com/1103-exploits/vlc105-dos.txt",
    "cve_desc": "The ape_read_header function in ape.c in libavformat in FFmpeg before 0.5.4, as used in MPlayer, VideoLAN VLC media player, and other products, allows remote attackers to cause a denial of service (application crash) via an APE (aka Monkey's Audio) file that contains a header but no frames.",
    "year": 2011,
    "filename": "ape.c",
    "commit_url": "\"https://github.com/FFmpeg/FFmpeg/commit/8312e3fc9041027a33c8bc667bb99740fdf41dd5\""
  },
  {
    "repository": "torvalds/linux",
    "cve_id": "CVE-2011-2182",
    "cwe_list": [
      "CWE-119"
    ],
    "commit_hash": "cae13fe4cc3f24820ffb990c09110626837e85d4",
    "short_hash": "cae13fe4",
    "vulnerableMethods_before": [
      {
        "filename": "fs/partitions/ldm.c",
        "method_name": "ldm_frag_add",
        "raw_code": "static bool ldm_frag_add (const u8 *data, int size, struct list_head *frags) /* <=== ldm_frag_add */ \n{\n\tstruct frag *f;\n\tstruct list_head *item;\n\tint rec, num, group;\n\n\tBUG_ON (!data || !frags);\n\n\tif (size < 2 * VBLK_SIZE_HEAD) {\n\t\tldm_error(\"Value of size is to small.\");\n\t\treturn false;\n\t}\n\n\tgroup = get_unaligned_be32(data + 0x08);\n\trec   = get_unaligned_be16(data + 0x0C);\n\tnum   = get_unaligned_be16(data + 0x0E);\n\tif ((num < 1) || (num > 4)) {\n\t\tldm_error (\"A VBLK claims to have %d parts.\", num);\n\t\treturn false;\n\t}\n\tif (rec >= num) {\n\t\tldm_error(\"REC value (%d) exceeds NUM value (%d)\", rec, num);\n\t\treturn false;\n\t}\n\n\tlist_for_each (item, frags) {\n\t\tf = list_entry (item, struct frag, list);\n\t\tif (f->group == group)\n\t\t\tgoto found;\n\t}\n\n\tf = kmalloc (sizeof (*f) + size*num, GFP_KERNEL);\n\tif (!f) {\n\t\tldm_crit (\"Out of memory.\");\n\t\treturn false;\n\t}\n\n\tf->group = group;\n\tf->num   = num;\n\tf->rec   = rec;\n\tf->map   = 0xFF << num;\n\n\tlist_add_tail (&f->list, frags);\nfound:\n\tif (f->map & (1 << rec)) {\n\t\tldm_error (\"Duplicate VBLK, part %d.\", rec);\n\t\tf->map &= 0x7F;\t\t\t/* Mark the group as broken */\n\t\treturn false;\n\t}\n\n\tf->map |= (1 << rec);\n\n\tdata += VBLK_SIZE_HEAD;\n\tsize -= VBLK_SIZE_HEAD;\n\n\tmemcpy (f->data+rec*(size-VBLK_SIZE_HEAD)+VBLK_SIZE_HEAD, data, size);\n\n\treturn true;\n}",
        "start_line": 1294
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "fs/partitions/ldm.c",
        "method_name": "ldm_frag_add",
        "raw_code": "static bool ldm_frag_add (const u8 *data, int size, struct list_head *frags) /* <=== ldm_frag_add */ \n{\n\tstruct frag *f;\n\tstruct list_head *item;\n\tint rec, num, group;\n\n\tBUG_ON (!data || !frags);\n\n\tif (size < 2 * VBLK_SIZE_HEAD) {\n\t\tldm_error(\"Value of size is to small.\");\n\t\treturn false;\n\t}\n\n\tgroup = get_unaligned_be32(data + 0x08);\n\trec   = get_unaligned_be16(data + 0x0C);\n\tnum   = get_unaligned_be16(data + 0x0E);\n\tif ((num < 1) || (num > 4)) {\n\t\tldm_error (\"A VBLK claims to have %d parts.\", num);\n\t\treturn false;\n\t}\n\tif (rec >= num) {\n\t\tldm_error(\"REC value (%d) exceeds NUM value (%d)\", rec, num);\n\t\treturn false;\n\t}\n\n\tlist_for_each (item, frags) {\n\t\tf = list_entry (item, struct frag, list);\n\t\tif (f->group == group)\n\t\t\tgoto found;\n\t}\n\n\tf = kmalloc (sizeof (*f) + size*num, GFP_KERNEL);\n\tif (!f) {\n\t\tldm_crit (\"Out of memory.\");\n\t\treturn false;\n\t}\n\n\tf->group = group;\n\tf->num   = num;\n\tf->rec   = rec;\n\tf->map   = 0xFF << num;\n\n\tlist_add_tail (&f->list, frags);\nfound:\n\tif (rec >= f->num) {\n\t\tldm_error(\"REC value (%d) exceeds NUM value (%d)\", rec, f->num);\n\t\treturn false;\n\t}\n\n\tif (f->map & (1 << rec)) {\n\t\tldm_error (\"Duplicate VBLK, part %d.\", rec);\n\t\tf->map &= 0x7F;\t\t\t/* Mark the group as broken */\n\t\treturn false;\n\t}\n\n\tf->map |= (1 << rec);\n\n\tdata += VBLK_SIZE_HEAD;\n\tsize -= VBLK_SIZE_HEAD;\n\n\tmemcpy (f->data+rec*(size-VBLK_SIZE_HEAD)+VBLK_SIZE_HEAD, data, size);\n\n\treturn true;\n}",
        "start_line": 1294
      }
    ],
    "code_context": "Called Methods:\n- LARGE_COPY_CUTOFF: #define LARGE_COPY_CUTOFF 2048 /* <=== arch/tile/lib/memcpy_tile64.c:40:40:LARGE_COPY_CUTOFF:0 */ \n- memcpy: void *memcpy(void *dest, const void *src, size_t count) /* <=== memcpy */ \n{\n\tchar *tmp = dest;\n\tconst char *s = src;\n\n\twhile (count--)\n\t\t*tmp++ = *s++;\n\treturn dest;\n}\n- kmalloc: static inline void *kmalloc(size_t s, gfp_t gfp) /* <=== kmalloc */ \n{\n\treturn malloc(s);\n}\n- get_unaligned_be16: static inline u16 get_unaligned_be16(const void *p) /* <=== get_unaligned_be16 */ \n{\n\treturn be16_to_cpu(sh4a_get_unaligned_cpu16(p));\n}\n- __memcpy_asm: extern unsigned long __memcpy_asm(void *to, const void *from, unsigned long n); /* <=== __memcpy_asm */ \n- get_unaligned_be32: static inline u32 get_unaligned_be32(const void *p) /* <=== get_unaligned_be32 */ \n{\n\treturn be32_to_cpup((__be32 *)p);\n}\n- VBLK_SIZE_HEAD: #define VBLK_SIZE_HEAD\t\t16 /* <=== fs/partitions/ldm.h:64:64:VBLK_SIZE_HEAD:0 */ \n- get_unaligned_be16: static inline u16 get_unaligned_be16(const void *p) /* <=== get_unaligned_be16 */ \n{\n\treturn be16_to_cpup((__be16 *)p);\n}\n- printk: asmlinkage int printk(const char *fmt, ...) /* <=== printk */ \n{\n\tstruct kvm_vcpu *vcpu = current_vcpu;\n\tva_list args;\n\tint r;\n\n\tmemset(vcpu->arch.log_buf, 0, VMM_LOG_LEN);\n\tva_start(args, fmt);\n\tr = vsnprintf(vcpu->arch.log_buf, VMM_LOG_LEN, fmt, args);\n\tva_end(args);\n\tvcpu_debug_exit(vcpu);\n\treturn r;\n}\n- printk: int printk(const char *s, ...) /* <=== printk */ \n{\n\treturn 0;\n}\n- memcpy: void *memcpy(void *to, const void *from, __kernel_size_t n) /* <=== memcpy */ \n{\n\tif (n < LARGE_COPY_CUTOFF)\n\t\treturn (void *)__memcpy_asm(to, from, n);\n\telse\n\t\treturn (void *)fast_copy(to, from, n, __memcpy_asm);\n}\n- ldm_error: #define ldm_error(f, a...) _ldm_printk (KERN_ERR,   __func__, f, ##a) /* <=== fs/partitions/ldm.c:49:49:ldm_error:2 */ \n- sh4a_get_unaligned_cpu16: static inline u16 sh4a_get_unaligned_cpu16(const u8 *p) /* <=== sh4a_get_unaligned_cpu16 */ \n{\n#ifdef __LITTLE_ENDIAN\n\treturn p[0] | p[1] << 8;\n#else\n\treturn p[0] << 8 | p[1];\n#endif\n}\n- _ldm_printk: __attribute__ ((format (printf, 3, 4))) /* <=== _ldm_printk */ \nstatic void _ldm_printk (const char *level, const char *function,\n\t\t\t const char *fmt, ...)\n{\n\tstatic char buf[128];\n\tva_list args;\n\n\tva_start (args, fmt);\n\tvsnprintf (buf, sizeof (buf), fmt, args);\n\tva_end (args);\n\n\tprintk (\"%s%s(): %s\\n\", level, function, buf);\n}\n- fast_copy: static unsigned long fast_copy(void *dest, const void *source, int len, /* <=== fast_copy */ \n\t\t\t       memcpy_t func)\n{\n\t/*\n\t * Check if it's big enough to bother with.  We may end up doing a\n\t * small copy via TLB manipulation if we're near a page boundary,\n\t * but presumably we'll make it up when we hit the second page.\n\t */\n\twhile (len >= LARGE_COPY_CUTOFF) {\n\t\tint copy_size, bytes_left_on_page;\n\t\tpte_t *src_ptep, *dst_ptep;\n\t\tpte_t src_pte, dst_pte;\n\t\tstruct page *src_page, *dst_page;\n\n\t\t/* Is the source page oloc'ed to a remote cpu? */\nretry_source:\n\t\tsrc_ptep = virt_to_pte(current->mm, (unsigned long)source);\n\t\tif (src_ptep == NULL)\n\t\t\tbreak;\n\t\tsrc_pte = *src_ptep;\n\t\tif (!hv_pte_get_present(src_pte) ||\n\t\t    !hv_pte_get_readable(src_pte) ||\n\t\t    hv_pte_get_mode(src_pte) != HV_PTE_MODE_CACHE_TILE_L3)\n\t\t\tbreak;\n\t\tif (get_remote_cache_cpu(src_pte) == smp_processor_id())\n\t\t\tbreak;\n\t\tsrc_page = pfn_to_page(hv_pte_get_pfn(src_pte));\n\t\tget_page(src_page);\n\t\tif (pte_val(src_pte) != pte_val(*src_ptep)) {\n\t\t\tput_page(src_page);\n\t\t\tgoto retry_source;\n\t\t}\n\t\tif (pte_huge(src_pte)) {\n\t\t\t/* Adjust the PTE to correspond to a small page */\n\t\t\tint pfn = hv_pte_get_pfn(src_pte);\n\t\t\tpfn += (((unsigned long)source & (HPAGE_SIZE-1))\n\t\t\t\t>> PAGE_SHIFT);\n\t\t\tsrc_pte = pfn_pte(pfn, src_pte);\n\t\t\tsrc_pte = pte_mksmall(src_pte);\n\t\t}\n\n\t\t/* Is the destination page writable? */\nretry_dest:\n\t\tdst_ptep = virt_to_pte(current->mm, (unsigned long)dest);\n\t\tif (dst_ptep == NULL) {\n\t\t\tput_page(src_page);\n\t\t\tbreak;\n\t\t}\n\t\tdst_pte = *dst_ptep;\n\t\tif (!hv_pte_get_present(dst_pte) ||\n\t\t    !hv_pte_get_writable(dst_pte)) {\n\t\t\tput_page(src_page);\n\t\t\tbreak;\n\t\t}\n\t\tdst_page = pfn_to_page(hv_pte_get_pfn(dst_pte));\n\t\tif (dst_page == src_page) {\n\t\t\t/*\n\t\t\t * Source and dest are on the same page; this\n\t\t\t * potentially exposes us to incoherence if any\n\t\t\t * part of src and dest overlap on a cache line.\n\t\t\t * Just give up rather than trying to be precise.\n\t\t\t */\n\t\t\tput_page(src_page);\n\t\t\tbreak;\n\t\t}\n\t\tget_page(dst_page);\n\t\tif (pte_val(dst_pte) != pte_val(*dst_ptep)) {\n\t\t\tput_page(dst_page);\n\t\t\tgoto retry_dest;\n\t\t}\n\t\tif (pte_huge(dst_pte)) {\n\t\t\t/* Adjust the PTE to correspond to a small page */\n\t\t\tint pfn = hv_pte_get_pfn(dst_pte);\n\t\t\tpfn += (((unsigned long)dest & (HPAGE_SIZE-1))\n\t\t\t\t>> PAGE_SHIFT);\n\t\t\tdst_pte = pfn_pte(pfn, dst_pte);\n\t\t\tdst_pte = pte_mksmall(dst_pte);\n\t\t}\n\n\t\t/* All looks good: create a cachable PTE and copy from it */\n\t\tcopy_size = len;\n\t\tbytes_left_on_page =\n\t\t\tPAGE_SIZE - (((int)source) & (PAGE_SIZE-1));\n\t\tif (copy_size > bytes_left_on_page)\n\t\t\tcopy_size = bytes_left_on_page;\n\t\tbytes_left_on_page =\n\t\t\tPAGE_SIZE - (((int)dest) & (PAGE_SIZE-1));\n\t\tif (copy_size > bytes_left_on_page)\n\t\t\tcopy_size = bytes_left_on_page;\n\t\tmemcpy_multicache(dest, source, dst_pte, src_pte, copy_size);\n\n\t\t/* Release the pages */\n\t\tput_page(dst_page);\n\t\tput_page(src_page);\n\n\t\t/* Continue on the next page */\n\t\tdest += copy_size;\n\t\tsource += copy_size;\n\t\tlen -= copy_size;\n\t}\n\n\treturn func(dest, source, len);\n}\n- get_unaligned_be32: static inline u32 get_unaligned_be32(const void *p) /* <=== get_unaligned_be32 */ \n{\n\treturn be32_to_cpu(sh4a_get_unaligned_cpu32(p));\n}\n- memcpy: void *memcpy(void *dest, const void *src, size_t n) /* <=== memcpy */ \n{\n\treturn __builtin_memcpy(dest, src, n);\n}\n- memcpy: void *memcpy(void *dest, const void *src, size_t n) /* <=== memcpy */ \n{\n\tlong d0, d1, d2;\n\tasm volatile(\n\t\t\"rep ; movsq\\n\\t\"\n\t\t\"movq %4,%%rcx\\n\\t\"\n\t\t\"rep ; movsb\\n\\t\"\n\t\t: \"=&c\" (d0), \"=&D\" (d1), \"=&S\" (d2)\n\t\t: \"0\" (n >> 3), \"g\" (n & 7), \"1\" (dest), \"2\" (src)\n\t\t: \"memory\");\n\n\treturn dest;\n}\n\nType Definitions:\n- frag: struct frag {\t\t\t\t/* VBLK Fragment handling */\n\tstruct list_head list;\n\tu32\t\tgroup;\n\tu8\t\tnum;\t\t/* Total number of records */\n\tu8\t\trec;\t\t/* This is record number n */\n\tu8\t\tmap;\t\t/* Which portions are in use */\n\tu8\t\tdata[0];\n}\n\nImports:\n- #include <linux/stringify.h>\n- #include <linux/pagemap.h>\n- #include \"check.h\"\n- #include \"msdos.h\"\n- #include <linux/kernel.h>\n- #include <linux/slab.h>\n- #include \"ldm.h\"",
    "commit_msg": "Fix for buffer overflow in ldm_frag_add not sufficient\n\nAs Ben Hutchings discovered [1], the patch for CVE-2011-1017 (buffer\noverflow in ldm_frag_add) is not sufficient.  The original patch in\ncommit c340b1d64000 (\"fs/partitions/ldm.c: fix oops caused by corrupted\npartition table\") does not consider that, for subsequent fragments,\npreviously allocated memory is used.\n\n[1] http://lkml.org/lkml/2011/5/6/407\n\nReported-by: Ben Hutchings <ben@decadent.org.uk>\nSigned-off-by: Timo Warns <warns@pre-sense.de>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "cve_desc": "[{'lang': 'en', 'value': 'The ldm_frag_add function in fs/partitions/ldm.c in the Linux kernel before 2.6.39.1 does not properly handle memory allocation for non-initial fragments, which might allow local users to conduct buffer overflow attacks, and gain privileges or obtain sensitive information, via a crafted LDM partition table.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2011-1017.'}]",
    "year": 2011,
    "filename": "ldm.c",
    "commit_url": "\"https://github.com/torvalds/linux/commit/cae13fe4cc3f24820ffb990c09110626837e85d4\""
  },
  {
    "repository": "torvalds/linux",
    "cve_id": "CVE-2011-2203",
    "cwe_list": [
      "CWE-264"
    ],
    "commit_hash": "434a964daa14b9db083ce20404a4a2add54d037a",
    "short_hash": "434a964d",
    "vulnerableMethods_before": [
      {
        "filename": "fs/hfs/btree.c",
        "method_name": "hfs_btree_open",
        "raw_code": "struct hfs_btree *hfs_btree_open(struct super_block *sb, u32 id, btree_keycmp keycmp) /* <=== hfs_btree_open */ \n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_btree_header_rec *head;\n\tstruct address_space *mapping;\n\tstruct page *page;\n\tunsigned int size;\n\n\ttree = kzalloc(sizeof(*tree), GFP_KERNEL);\n\tif (!tree)\n\t\treturn NULL;\n\n\tmutex_init(&tree->tree_lock);\n\tspin_lock_init(&tree->hash_lock);\n\t/* Set the correct compare function */\n\ttree->sb = sb;\n\ttree->cnid = id;\n\ttree->keycmp = keycmp;\n\n\ttree->inode = iget_locked(sb, id);\n\tif (!tree->inode)\n\t\tgoto free_tree;\n\tBUG_ON(!(tree->inode->i_state & I_NEW));\n\t{\n\tstruct hfs_mdb *mdb = HFS_SB(sb)->mdb;\n\tHFS_I(tree->inode)->flags = 0;\n\tmutex_init(&HFS_I(tree->inode)->extents_lock);\n\tswitch (id) {\n\tcase HFS_EXT_CNID:\n\t\thfs_inode_read_fork(tree->inode, mdb->drXTExtRec, mdb->drXTFlSize,\n\t\t\t\t    mdb->drXTFlSize, be32_to_cpu(mdb->drXTClpSiz));\n\t\ttree->inode->i_mapping->a_ops = &hfs_btree_aops;\n\t\tbreak;\n\tcase HFS_CAT_CNID:\n\t\thfs_inode_read_fork(tree->inode, mdb->drCTExtRec, mdb->drCTFlSize,\n\t\t\t\t    mdb->drCTFlSize, be32_to_cpu(mdb->drCTClpSiz));\n\t\ttree->inode->i_mapping->a_ops = &hfs_btree_aops;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\t}\n\tunlock_new_inode(tree->inode);\n\n\tif (!HFS_I(tree->inode)->first_blocks) {\n\t\tprintk(KERN_ERR \"hfs: invalid btree extent records (0 size).\\n\");\n\t\tgoto free_inode;\n\t}\n\n\tmapping = tree->inode->i_mapping;\n\tpage = read_mapping_page(mapping, 0, NULL);\n\tif (IS_ERR(page))\n\t\tgoto free_inode;\n\n\t/* Load the header */\n\thead = (struct hfs_btree_header_rec *)(kmap(page) + sizeof(struct hfs_bnode_desc));\n\ttree->root = be32_to_cpu(head->root);\n\ttree->leaf_count = be32_to_cpu(head->leaf_count);\n\ttree->leaf_head = be32_to_cpu(head->leaf_head);\n\ttree->leaf_tail = be32_to_cpu(head->leaf_tail);\n\ttree->node_count = be32_to_cpu(head->node_count);\n\ttree->free_nodes = be32_to_cpu(head->free_nodes);\n\ttree->attributes = be32_to_cpu(head->attributes);\n\ttree->node_size = be16_to_cpu(head->node_size);\n\ttree->max_key_len = be16_to_cpu(head->max_key_len);\n\ttree->depth = be16_to_cpu(head->depth);\n\n\tsize = tree->node_size;\n\tif (!is_power_of_2(size))\n\t\tgoto fail_page;\n\tif (!tree->node_count)\n\t\tgoto fail_page;\n\tswitch (id) {\n\tcase HFS_EXT_CNID:\n\t\tif (tree->max_key_len != HFS_MAX_EXT_KEYLEN) {\n\t\t\tprintk(KERN_ERR \"hfs: invalid extent max_key_len %d\\n\",\n\t\t\t\ttree->max_key_len);\n\t\t\tgoto fail_page;\n\t\t}\n\t\tbreak;\n\tcase HFS_CAT_CNID:\n\t\tif (tree->max_key_len != HFS_MAX_CAT_KEYLEN) {\n\t\t\tprintk(KERN_ERR \"hfs: invalid catalog max_key_len %d\\n\",\n\t\t\t\ttree->max_key_len);\n\t\t\tgoto fail_page;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\ttree->node_size_shift = ffs(size) - 1;\n\ttree->pages_per_bnode = (tree->node_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n\n\tkunmap(page);\n\tpage_cache_release(page);\n\treturn tree;\n\nfail_page:\n\tpage_cache_release(page);\nfree_inode:\n\ttree->inode->i_mapping->a_ops = &hfs_aops;\n\tiput(tree->inode);\nfree_tree:\n\tkfree(tree);\n\treturn NULL;\n}",
        "start_line": 18
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "fs/hfs/btree.c",
        "method_name": "hfs_btree_open",
        "raw_code": "struct hfs_btree *hfs_btree_open(struct super_block *sb, u32 id, btree_keycmp keycmp) /* <=== hfs_btree_open */ \n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_btree_header_rec *head;\n\tstruct address_space *mapping;\n\tstruct page *page;\n\tunsigned int size;\n\n\ttree = kzalloc(sizeof(*tree), GFP_KERNEL);\n\tif (!tree)\n\t\treturn NULL;\n\n\tmutex_init(&tree->tree_lock);\n\tspin_lock_init(&tree->hash_lock);\n\t/* Set the correct compare function */\n\ttree->sb = sb;\n\ttree->cnid = id;\n\ttree->keycmp = keycmp;\n\n\ttree->inode = iget_locked(sb, id);\n\tif (!tree->inode)\n\t\tgoto free_tree;\n\tBUG_ON(!(tree->inode->i_state & I_NEW));\n\t{\n\tstruct hfs_mdb *mdb = HFS_SB(sb)->mdb;\n\tHFS_I(tree->inode)->flags = 0;\n\tmutex_init(&HFS_I(tree->inode)->extents_lock);\n\tswitch (id) {\n\tcase HFS_EXT_CNID:\n\t\thfs_inode_read_fork(tree->inode, mdb->drXTExtRec, mdb->drXTFlSize,\n\t\t\t\t    mdb->drXTFlSize, be32_to_cpu(mdb->drXTClpSiz));\n\t\tif (HFS_I(tree->inode)->alloc_blocks >\n\t\t\t\t\tHFS_I(tree->inode)->first_blocks) {\n\t\t\tprintk(KERN_ERR \"hfs: invalid btree extent records\\n\");\n\t\t\tunlock_new_inode(tree->inode);\n\t\t\tgoto free_inode;\n\t\t}\n\n\t\ttree->inode->i_mapping->a_ops = &hfs_btree_aops;\n\t\tbreak;\n\tcase HFS_CAT_CNID:\n\t\thfs_inode_read_fork(tree->inode, mdb->drCTExtRec, mdb->drCTFlSize,\n\t\t\t\t    mdb->drCTFlSize, be32_to_cpu(mdb->drCTClpSiz));\n\n\t\tif (!HFS_I(tree->inode)->first_blocks) {\n\t\t\tprintk(KERN_ERR \"hfs: invalid btree extent records \"\n\t\t\t\t\t\t\t\t\"(0 size).\\n\");\n\t\t\tunlock_new_inode(tree->inode);\n\t\t\tgoto free_inode;\n\t\t}\n\n\t\ttree->inode->i_mapping->a_ops = &hfs_btree_aops;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\t}\n\tunlock_new_inode(tree->inode);\n\n\tmapping = tree->inode->i_mapping;\n\tpage = read_mapping_page(mapping, 0, NULL);\n\tif (IS_ERR(page))\n\t\tgoto free_inode;\n\n\t/* Load the header */\n\thead = (struct hfs_btree_header_rec *)(kmap(page) + sizeof(struct hfs_bnode_desc));\n\ttree->root = be32_to_cpu(head->root);\n\ttree->leaf_count = be32_to_cpu(head->leaf_count);\n\ttree->leaf_head = be32_to_cpu(head->leaf_head);\n\ttree->leaf_tail = be32_to_cpu(head->leaf_tail);\n\ttree->node_count = be32_to_cpu(head->node_count);\n\ttree->free_nodes = be32_to_cpu(head->free_nodes);\n\ttree->attributes = be32_to_cpu(head->attributes);\n\ttree->node_size = be16_to_cpu(head->node_size);\n\ttree->max_key_len = be16_to_cpu(head->max_key_len);\n\ttree->depth = be16_to_cpu(head->depth);\n\n\tsize = tree->node_size;\n\tif (!is_power_of_2(size))\n\t\tgoto fail_page;\n\tif (!tree->node_count)\n\t\tgoto fail_page;\n\tswitch (id) {\n\tcase HFS_EXT_CNID:\n\t\tif (tree->max_key_len != HFS_MAX_EXT_KEYLEN) {\n\t\t\tprintk(KERN_ERR \"hfs: invalid extent max_key_len %d\\n\",\n\t\t\t\ttree->max_key_len);\n\t\t\tgoto fail_page;\n\t\t}\n\t\tbreak;\n\tcase HFS_CAT_CNID:\n\t\tif (tree->max_key_len != HFS_MAX_CAT_KEYLEN) {\n\t\t\tprintk(KERN_ERR \"hfs: invalid catalog max_key_len %d\\n\",\n\t\t\t\ttree->max_key_len);\n\t\t\tgoto fail_page;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\ttree->node_size_shift = ffs(size) - 1;\n\ttree->pages_per_bnode = (tree->node_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n\n\tkunmap(page);\n\tpage_cache_release(page);\n\treturn tree;\n\nfail_page:\n\tpage_cache_release(page);\nfree_inode:\n\ttree->inode->i_mapping->a_ops = &hfs_aops;\n\tiput(tree->inode);\nfree_tree:\n\tkfree(tree);\n\treturn NULL;\n}",
        "start_line": 18
      }
    ],
    "code_context": "Called Methods:\n- read_mapping_page: static inline struct page *read_mapping_page(struct address_space *mapping, /* <=== read_mapping_page */ \n\t\t\t\tpgoff_t index, void *data)\n{\n\tfiller_t *filler = (filler_t *)mapping->a_ops->readpage;\n\treturn read_cache_page(mapping, index, filler, data);\n}\n- kfree: void kfree(const void *x) /* <=== kfree */ \n{\n\tstruct page *page;\n\tvoid *object = (void *)x;\n\n\ttrace_kfree(_RET_IP_, x);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(x)))\n\t\treturn;\n\n\tpage = virt_to_head_page(x);\n\tif (unlikely(!PageSlab(page))) {\n\t\tBUG_ON(!PageCompound(page));\n\t\tkmemleak_free(x);\n\t\tput_page(page);\n\t\treturn;\n\t}\n\tslab_free(page->slab, page, object, _RET_IP_);\n}\n- kmap_get_pte: #define kmap_get_pte(vaddr) \\ /* <=== arch/tile/mm/highmem.c:20:22:kmap_get_pte:1 */ \n\tpte_offset_kernel(pmd_offset(pud_offset(pgd_offset_k(vaddr), (vaddr)),\\\n\t\t(vaddr)), (vaddr))\n- obj_size: #define obj_size(cachep)\t\t(cachep->buffer_size) /* <=== mm/slab.c:466:466:obj_size:1 */ \n- HFS_CAT_CNID: #define HFS_CAT_CNID\t\t4\t/* CATalog B-tree */ /* <=== fs/hfs/hfs.h:44:44:HFS_CAT_CNID:0 */ \n- kmalloc: static inline void *kmalloc(size_t s, gfp_t gfp) /* <=== kmalloc */ \n{\n\treturn malloc(s);\n}\n- kmap: static inline void *kmap(struct page *page) /* <=== kmap */ \n{\n\tmight_sleep();\n\treturn page_address(page);\n}\n- kfree: void kfree(const void *objp) /* <=== kfree */ \n{\n\tstruct kmem_cache *c;\n\tunsigned long flags;\n\n\ttrace_kfree(_RET_IP_, objp);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(objp)))\n\t\treturn;\n\tlocal_irq_save(flags);\n\tkfree_debugcheck(objp);\n\tc = virt_to_cache(objp);\n\tdebug_check_no_locks_freed(objp, obj_size(c));\n\tdebug_check_no_obj_freed(objp, obj_size(c));\n\t__cache_free(c, (void *)objp, __builtin_return_address(0));\n\tlocal_irq_restore(flags);\n}\n- inode_sb_list_add: void inode_sb_list_add(struct inode *inode) /* <=== inode_sb_list_add */ \n{\n\tspin_lock(&inode_sb_list_lock);\n\tlist_add(&inode->i_sb_list, &inode->i_sb->s_inodes);\n\tspin_unlock(&inode_sb_list_lock);\n}\n- fls: static inline int fls(int x) /* <=== fls */ \n{\n\tint r;\n\n\tif (__builtin_constant_p(cpu_has_clo_clz) && cpu_has_clo_clz) {\n\t\t__asm__(\"clz %0, %1\" : \"=r\" (x) : \"r\" (x));\n\n\t\treturn 32 - x;\n\t}\n\n\tr = 32;\n\tif (!x)\n\t\treturn 0;\n\tif (!(x & 0xffff0000u)) {\n\t\tx <<= 16;\n\t\tr -= 16;\n\t}\n\tif (!(x & 0xff000000u)) {\n\t\tx <<= 8;\n\t\tr -= 8;\n\t}\n\tif (!(x & 0xf0000000u)) {\n\t\tx <<= 4;\n\t\tr -= 4;\n\t}\n\tif (!(x & 0xc0000000u)) {\n\t\tx <<= 2;\n\t\tr -= 2;\n\t}\n\tif (!(x & 0x80000000u)) {\n\t\tx <<= 1;\n\t\tr -= 1;\n\t}\n\treturn r;\n}\n- find_inode_fast: static struct inode *find_inode_fast(struct super_block *sb, /* <=== find_inode_fast */ \n\t\t\t\tstruct hlist_head *head, unsigned long ino)\n{\n\tstruct hlist_node *node;\n\tstruct inode *inode = NULL;\n\nrepeat:\n\thlist_for_each_entry(inode, node, head, i_hash) {\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_ino != ino) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (inode->i_sb != sb) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (inode->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t__wait_on_freeing_inode(inode);\n\t\t\tgoto repeat;\n\t\t}\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn inode;\n\t}\n\treturn NULL;\n}\n- slob_page: static inline struct slob_page *slob_page(const void *addr) /* <=== slob_page */ \n{\n\treturn (struct slob_page *)virt_to_page(addr);\n}\n- ffs: static inline int ffs(int word) /* <=== ffs */ \n{\n\tif (!word)\n\t\treturn 0;\n\n\treturn fls(word & -word);\n}\n- kfree_debugcheck: #define kfree_debugcheck(x) do { } while(0) /* <=== mm/slab.c:3049:3049:kfree_debugcheck:1 */ \n- kunmap: void kunmap(struct page *page) /* <=== kunmap */ \n{\n\tBUG_ON(in_interrupt());\n\tif (!PageHighMem(page))\n\t\treturn;\n\tkunmap_high(page);\n}\n- is_slob_page: static inline int is_slob_page(struct slob_page *sp) /* <=== is_slob_page */ \n{\n\treturn PageSlab((struct page *)sp);\n}\n- HFS_I: #define HFS_I(inode)\t(list_entry(inode, struct hfs_inode_info, vfs_inode)) /* <=== fs/hfs/hfs_fs.h:241:241:HFS_I:1 */ \n- slob_free: static void slob_free(void *block, int size) /* <=== slob_free */ \n{\n\tstruct slob_page *sp;\n\tslob_t *prev, *next, *b = (slob_t *)block;\n\tslobidx_t units;\n\tunsigned long flags;\n\tstruct list_head *slob_list;\n\n\tif (unlikely(ZERO_OR_NULL_PTR(block)))\n\t\treturn;\n\tBUG_ON(!size);\n\n\tsp = slob_page(block);\n\tunits = SLOB_UNITS(size);\n\n\tspin_lock_irqsave(&slob_lock, flags);\n\n\tif (sp->units + units == SLOB_UNITS(PAGE_SIZE)) {\n\t\t/* Go directly to page allocator. Do not pass slob allocator */\n\t\tif (slob_page_free(sp))\n\t\t\tclear_slob_page_free(sp);\n\t\tspin_unlock_irqrestore(&slob_lock, flags);\n\t\tclear_slob_page(sp);\n\t\tfree_slob_page(sp);\n\t\tslob_free_pages(b, 0);\n\t\treturn;\n\t}\n\n\tif (!slob_page_free(sp)) {\n\t\t/* This slob page is about to become partially free. Easy! */\n\t\tsp->units = units;\n\t\tsp->free = b;\n\t\tset_slob(b, units,\n\t\t\t(void *)((unsigned long)(b +\n\t\t\t\t\tSLOB_UNITS(PAGE_SIZE)) & PAGE_MASK));\n\t\tif (size < SLOB_BREAK1)\n\t\t\tslob_list = &free_slob_small;\n\t\telse if (size < SLOB_BREAK2)\n\t\t\tslob_list = &free_slob_medium;\n\t\telse\n\t\t\tslob_list = &free_slob_large;\n\t\tset_slob_page_free(sp, slob_list);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Otherwise the page is already partially free, so find reinsertion\n\t * point.\n\t */\n\tsp->units += units;\n\n\tif (b < sp->free) {\n\t\tif (b + units == sp->free) {\n\t\t\tunits += slob_units(sp->free);\n\t\t\tsp->free = slob_next(sp->free);\n\t\t}\n\t\tset_slob(b, units, sp->free);\n\t\tsp->free = b;\n\t} else {\n\t\tprev = sp->free;\n\t\tnext = slob_next(prev);\n\t\twhile (b > next) {\n\t\t\tprev = next;\n\t\t\tnext = slob_next(prev);\n\t\t}\n\n\t\tif (!slob_last(prev) && b + units == next) {\n\t\t\tunits += slob_units(next);\n\t\t\tset_slob(b, units, slob_next(next));\n\t\t} else\n\t\t\tset_slob(b, units, next);\n\n\t\tif (prev + slob_units(prev) == b) {\n\t\t\tunits = slob_units(b) + slob_units(prev);\n\t\t\tset_slob(prev, units, slob_next(b));\n\t\t} else\n\t\t\tset_slob(prev, slob_units(prev), b);\n\t}\nout:\n\tspin_unlock_irqrestore(&slob_lock, flags);\n}\n- kmap: void *kmap(struct page *page) /* <=== kmap */ \n{\n\tmight_sleep();\n\tif (!PageHighMem(page))\n\t\treturn page_address(page);\n\treturn kmap_high(page);\n}\n- hash: static unsigned long hash(struct super_block *sb, unsigned long hashval) /* <=== hash */ \n{\n\tunsigned long tmp;\n\n\ttmp = (hashval * (unsigned long)sb) ^ (GOLDEN_RATIO_PRIME + hashval) /\n\t\t\tL1_CACHE_BYTES;\n\ttmp = tmp ^ ((tmp ^ GOLDEN_RATIO_PRIME) >> i_hash_shift);\n\treturn tmp & i_hash_mask;\n}\n- destroy_inode: static void destroy_inode(struct inode *inode) /* <=== destroy_inode */ \n{\n\tBUG_ON(!list_empty(&inode->i_lru));\n\t__destroy_inode(inode);\n\tif (inode->i_sb->s_op->destroy_inode)\n\t\tinode->i_sb->s_op->destroy_inode(inode);\n\telse\n\t\tcall_rcu(&inode->i_rcu, i_callback);\n}\n- kmap: void *kmap(struct page *page) /* <=== kmap */ \n{\n\tmight_sleep();\n\tif (!PageHighMem(page))\n\t\treturn page_address(page);\n\treturn kmap_high(page);\n}\n- is_power_of_2: static inline __attribute__((const)) /* <=== is_power_of_2 */ \nbool is_power_of_2(unsigned long n)\n{\n\treturn (n != 0 && ((n & (n - 1)) == 0));\n}\n- kfree: void kfree(const void *block) /* <=== kfree */ \n{\n\tstruct slob_page *sp;\n\n\ttrace_kfree(_RET_IP_, block);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(block)))\n\t\treturn;\n\tkmemleak_free(block);\n\n\tsp = slob_page(block);\n\tif (is_slob_page(sp)) {\n\t\tint align = max(ARCH_KMALLOC_MINALIGN, ARCH_SLAB_MINALIGN);\n\t\tunsigned int *m = (unsigned int *)(block - align);\n\t\tslob_free(m, *m + align);\n\t} else\n\t\tput_page(&sp->page);\n}\n- __cache_free: static inline void __cache_free(struct kmem_cache *cachep, void *objp, /* <=== __cache_free */ \n    void *caller)\n{\n\tstruct array_cache *ac = cpu_cache_get(cachep);\n\n\tcheck_irq_off();\n\tkmemleak_free_recursive(objp, cachep->flags);\n\tobjp = cache_free_debugcheck(cachep, objp, caller);\n\n\tkmemcheck_slab_free(cachep, objp, obj_size(cachep));\n\n\t/*\n\t * Skip calling cache_free_alien() when the platform is not numa.\n\t * This will avoid cache misses that happen while accessing slabp (which\n\t * is per page memory  reference) to get nodeid. Instead use a global\n\t * variable to skip the call, which is mostly likely to be present in\n\t * the cache.\n\t */\n\tif (nr_online_nodes > 1 && cache_free_alien(cachep, objp))\n\t\treturn;\n\n\tif (likely(ac->avail < ac->limit)) {\n\t\tSTATS_INC_FREEHIT(cachep);\n\t\tac->entry[ac->avail++] = objp;\n\t\treturn;\n\t} else {\n\t\tSTATS_INC_FREEMISS(cachep);\n\t\tcache_flusharray(cachep, ac);\n\t\tac->entry[ac->avail++] = objp;\n\t}\n}\n- kmap: void *kmap(struct page *page) /* <=== kmap */ \n{\n\tvoid *addr;\n\n\tmight_sleep();\n\tif (!PageHighMem(page))\n\t\treturn page_address(page);\n\taddr = kmap_high(page);\n\tflush_tlb_one((unsigned long)addr);\n\n\treturn addr;\n}\n- kunmap: void kunmap(struct page *page) /* <=== kunmap */ \n{\n\tif (in_interrupt())\n\t\tBUG();\n\tif (!PageHighMem(page))\n\t\treturn;\n\tkunmap_high(page);\n}\n- HFS_MAX_EXT_KEYLEN: #define HFS_MAX_EXT_KEYLEN\t(sizeof(struct hfs_ext_key) - sizeof(u8)) /* <=== fs/hfs/hfs.h:171:171:HFS_MAX_EXT_KEYLEN:0 */ \n- HFS_EXT_CNID: #define HFS_EXT_CNID\t\t3\t/* EXTents B-tree */ /* <=== fs/hfs/hfs.h:43:43:HFS_EXT_CNID:0 */ \n- HFS_MAX_CAT_KEYLEN: #define HFS_MAX_CAT_KEYLEN\t(sizeof(struct hfs_cat_key) - sizeof(u8)) /* <=== fs/hfs/hfs.h:170:170:HFS_MAX_CAT_KEYLEN:0 */ \n- kunmap: void kunmap(struct page *page) /* <=== kunmap */ \n{\n\tif (in_interrupt())\n\t\tBUG();\n\tif (!PageHighMem(page))\n\t\treturn;\n\tkunmap_high(page);\n}\n- iput: void iput(struct inode *inode) /* <=== iput */ \n{\n\tif (inode) {\n\t\tBUG_ON(inode->i_state & I_CLEAR);\n\n\t\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock))\n\t\t\tiput_final(inode);\n\t}\n}\n- virt_to_cache: static inline struct kmem_cache *virt_to_cache(const void *obj) /* <=== virt_to_cache */ \n{\n\tstruct page *page = virt_to_head_page(obj);\n\treturn page_get_cache(page);\n}\n- kunmap: static inline void kunmap(struct page *page) /* <=== kunmap */ \n{\n}\n- kunmap: void kunmap(struct page *page) /* <=== kunmap */ \n{\n\tBUG_ON(in_interrupt());\n\tif (!PageHighMem(page))\n\t\treturn;\n\tkunmap_high(page);\n}\n- kzalloc: static inline void *kzalloc(size_t size, gfp_t flags) /* <=== kzalloc */ \n{\n\treturn kmalloc(size, flags | __GFP_ZERO);\n}\n- iget_locked: struct inode *iget_locked(struct super_block *sb, unsigned long ino) /* <=== iget_locked */ \n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}\n- kmap: void *kmap(struct page *page) /* <=== kmap */ \n{\n\tmight_sleep();\n\tif (!PageHighMem(page))\n\t\treturn page_address(page);\n\treturn kmap_high(page);\n}\n- kfree: static inline void kfree(void *p) /* <=== kfree */ \n{\n\tfree(p);\n}\n- iput_final: static void iput_final(struct inode *inode) /* <=== iput_final */ \n{\n\tstruct super_block *sb = inode->i_sb;\n\tconst struct super_operations *op = inode->i_sb->s_op;\n\tint drop;\n\n\tWARN_ON(inode->i_state & I_NEW);\n\n\tif (op->drop_inode)\n\t\tdrop = op->drop_inode(inode);\n\telse\n\t\tdrop = generic_drop_inode(inode);\n\n\tif (!drop && (sb->s_flags & MS_ACTIVE)) {\n\t\tinode->i_state |= I_REFERENCED;\n\t\tif (!(inode->i_state & (I_DIRTY|I_SYNC)))\n\t\t\tinode_lru_list_add(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn;\n\t}\n\n\tif (!drop) {\n\t\tinode->i_state |= I_WILL_FREE;\n\t\tspin_unlock(&inode->i_lock);\n\t\twrite_inode_now(inode, 1);\n\t\tspin_lock(&inode->i_lock);\n\t\tWARN_ON(inode->i_state & I_NEW);\n\t\tinode->i_state &= ~I_WILL_FREE;\n\t}\n\n\tinode->i_state |= I_FREEING;\n\tif (!list_empty(&inode->i_lru))\n\t\tinode_lru_list_del(inode);\n\tspin_unlock(&inode->i_lock);\n\n\tevict(inode);\n}\n- kunmap: void kunmap(struct page *page) /* <=== kunmap */ \n{\n\tif (in_interrupt())\n\t\tBUG();\n\tif (!PageHighMem(page))\n\t\treturn;\n\tkunmap_high(page);\n}\n- unlock_new_inode: void unlock_new_inode(struct inode *inode) /* <=== unlock_new_inode */ \n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}\n- kmap: void *kmap(struct page *page) /* <=== kmap */ \n{\n\tvoid *kva;\n\tunsigned long flags;\n\tpte_t *ptep;\n\n\tmight_sleep();\n\tif (!PageHighMem(page))\n\t\treturn page_address(page);\n\tkva = kmap_high(page);\n\n\t/*\n\t * Rewrite the PTE under the lock.  This ensures that the page\n\t * is not currently migrating.\n\t */\n\tptep = kmap_get_pte((unsigned long)kva);\n\tflags = homecache_kpte_lock();\n\tset_pte_at(&init_mm, kva, ptep, mk_pte(page, page_to_kpgprot(page)));\n\thomecache_kpte_unlock(flags);\n\n\treturn kva;\n}\n- alloc_inode: static struct inode *alloc_inode(struct super_block *sb) /* <=== alloc_inode */ \n{\n\tstruct inode *inode;\n\n\tif (sb->s_op->alloc_inode)\n\t\tinode = sb->s_op->alloc_inode(sb);\n\telse\n\t\tinode = kmem_cache_alloc(inode_cachep, GFP_KERNEL);\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tif (unlikely(inode_init_always(sb, inode))) {\n\t\tif (inode->i_sb->s_op->destroy_inode)\n\t\t\tinode->i_sb->s_op->destroy_inode(inode);\n\t\telse\n\t\t\tkmem_cache_free(inode_cachep, inode);\n\t\treturn NULL;\n\t}\n\n\treturn inode;\n}\n- hlist_add_head: static inline void hlist_add_head(struct hlist_node *n, struct hlist_head *h) /* <=== hlist_add_head */ \n{\n\tstruct hlist_node *first = h->first;\n\tn->next = first;\n\tif (first)\n\t\tfirst->pprev = &n->next;\n\th->first = n;\n\tn->pprev = &h->first;\n}\n\nType Definitions:\n- hfs_bnode_desc: struct hfs_bnode_desc {\n\t__be32 next;\t\t/* (V) Number of the next node at this level */\n\t__be32 prev;\t\t/* (V) Number of the prev node at this level */\n\tu8 type;\t\t/* (F) The type of node */\n\tu8 height;\t\t/* (F) The level of this node (leaves=1) */\n\t__be16 num_recs;\t/* (V) The number of records in this node */\n\tu16 reserved;\n}\n- page: struct page {\n\tunsigned long long dummy;\n}\n- hfs_cat_key: struct hfs_cat_key\n- hfs_btree: struct hfs_btree {\n\tstruct super_block *sb;\n\tstruct inode *inode;\n\tbtree_keycmp keycmp;\n\n\tu32 cnid;\n\tu32 root;\n\tu32 leaf_count;\n\tu32 leaf_head;\n\tu32 leaf_tail;\n\tu32 node_count;\n\tu32 free_nodes;\n\tu32 attributes;\n\n\tunsigned int node_size;\n\tunsigned int node_size_shift;\n\tunsigned int max_key_len;\n\tunsigned int depth;\n\n\t//unsigned int map1_size, map_size;\n\tstruct mutex tree_lock;\n\n\tunsigned int pages_per_bnode;\n\tspinlock_t hash_lock;\n\tstruct hfs_bnode *node_hash[NODE_HASH_SIZE];\n\tint node_hash_cnt;\n}\n- super_block: struct super_block\n- hfs_btree_header_rec: struct hfs_btree_header_rec {\n\t__be16 depth;\t\t/* (V) The number of levels in this B-tree */\n\t__be32 root;\t\t/* (V) The node number of the root node */\n\t__be32 leaf_count;\t/* (V) The number of leaf records */\n\t__be32 leaf_head;\t/* (V) The number of the first leaf node */\n\t__be32 leaf_tail;\t/* (V) The number of the last leaf node */\n\t__be16 node_size;\t/* (F) The number of bytes in a node (=512) */\n\t__be16 max_key_len;\t/* (F) The length of a key in an index node */\n\t__be32 node_count;\t/* (V) The total number of nodes */\n\t__be32 free_nodes;\t/* (V) The number of unused nodes */\n\tu16 reserved1;\n\t__be32 clump_size;\t/* (F) clump size. not usually used. */\n\tu8 btree_type;\t\t/* (F) BTree type */\n\tu8 reserved2;\n\t__be32 attributes;\t/* (F) attributes */\n\tu32 reserved3[16];\n}\n\nImports:\n- #include \"btree.h\"\n- #include <linux/log2.h>\n- #include <linux/pagemap.h>\n- #include <linux/slab.h>",
    "commit_msg": "hfs: fix hfs_find_init() sb->ext_tree NULL ptr oops\n\nClement Lecigne reports a filesystem which causes a kernel oops in\nhfs_find_init() trying to dereference sb->ext_tree which is NULL.\n\nThis proves to be because the filesystem has a corrupted MDB extent\nrecord, where the extents file does not fit into the first three extents\nin the file record (the first blocks).\n\nIn hfs_get_block() when looking up the blocks for the extent file\n(HFS_EXT_CNID), it fails the first blocks special case, and falls\nthrough to the extent code (which ultimately calls hfs_find_init())\nwhich is in the process of being initialised.\n\nHfs avoids this scenario by always having the extents b-tree fitting\ninto the first blocks (the extents B-tree can't have overflow extents).\n\nThe fix is to check at mount time that the B-tree fits into first\nblocks, i.e.  fail if HFS_I(inode)->alloc_blocks >=\nHFS_I(inode)->first_blocks\n\nNote, the existing commit 47f365eb57573 (\"hfs: fix oops on mount with\ncorrupted btree extent records\") becomes subsumed into this as a special\ncase, but only for the extents B-tree (HFS_EXT_CNID), it is perfectly\nacceptable for the catalog B-Tree file to grow beyond three extents,\nwith the remaining extent descriptors in the extents overfow.\n\nThis fixes CVE-2011-2203\n\nReported-by: Clement LECIGNE <clement.lecigne@netasq.com>\nSigned-off-by: Phillip Lougher <plougher@redhat.com>\nCc: Jeff Mahoney <jeffm@suse.com>\nCc: Christoph Hellwig <hch@lst.de>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "cve_desc": "The hfs_find_init function in the Linux kernel 2.6 allows local users to cause a denial of service (NULL pointer dereference and Oops) by mounting an HFS file system with a malformed MDB extent record.",
    "year": 2011,
    "filename": "btree.c",
    "commit_url": "\"https://github.com/torvalds/linux/commit/434a964daa14b9db083ce20404a4a2add54d037a\""
  },
  {
    "repository": "torvalds/linux",
    "cve_id": "CVE-2011-2482",
    "cwe_list": [
      "CWE-476"
    ],
    "commit_hash": "ea2bc483ff5caada7c4aa0d5fbf87d3a6590273d",
    "short_hash": "ea2bc483",
    "vulnerableMethods_before": [
      {
        "filename": "net/sctp/socket.c",
        "method_name": "sctp_sock_migrate",
        "raw_code": "static void sctp_sock_migrate(struct sock *oldsk, struct sock *newsk, /* <=== sctp_sock_migrate */ \n\t\t\t      struct sctp_association *assoc,\n\t\t\t      sctp_socket_type_t type)\n{\n\tstruct sctp_sock *oldsp = sctp_sk(oldsk);\n\tstruct sctp_sock *newsp = sctp_sk(newsk);\n\tstruct sctp_bind_bucket *pp; /* hash list port iterator */\n\tstruct sctp_endpoint *newep = newsp->ep;\n\tstruct sk_buff *skb, *tmp;\n\tstruct sctp_ulpevent *event;\n\tint flags = 0;\n\n\t/* Migrate socket buffer sizes and all the socket level options to the\n\t * new socket.\n\t */\n\tnewsk->sk_sndbuf = oldsk->sk_sndbuf;\n\tnewsk->sk_rcvbuf = oldsk->sk_rcvbuf;\n\t/* Brute force copy old sctp opt. */\n\tinet_sk_copy_descendant(newsk, oldsk);\n\n\t/* Restore the ep value that was overwritten with the above structure\n\t * copy.\n\t */\n\tnewsp->ep = newep;\n\tnewsp->hmac = NULL;\n\n\t/* Hook this new socket in to the bind_hash list. */\n\tpp = sctp_sk(oldsk)->bind_hash;\n\tsk_add_bind_node(newsk, &pp->owner);\n\tsctp_sk(newsk)->bind_hash = pp;\n\tinet_sk(newsk)->num = inet_sk(oldsk)->num;\n\n\t/* Copy the bind_addr list from the original endpoint to the new\n\t * endpoint so that we can handle restarts properly\n\t */\n\tif (PF_INET6 == assoc->base.sk->sk_family)\n\t\tflags = SCTP_ADDR6_ALLOWED;\n\tif (assoc->peer.ipv4_address)\n\t\tflags |= SCTP_ADDR4_PEERSUPP;\n\tif (assoc->peer.ipv6_address)\n\t\tflags |= SCTP_ADDR6_PEERSUPP;\n\tsctp_bind_addr_copy(&newsp->ep->base.bind_addr,\n\t\t\t     &oldsp->ep->base.bind_addr,\n\t\t\t     SCTP_SCOPE_GLOBAL, GFP_KERNEL, flags);\n\n\t/* Move any messages in the old socket's receive queue that are for the\n\t * peeled off association to the new socket's receive queue.\n\t */\n\tsctp_skb_for_each(skb, &oldsk->sk_receive_queue, tmp) {\n\t\tevent = sctp_skb2event(skb);\n\t\tif (event->asoc == assoc) {\n\t\t\tsctp_sock_rfree(skb);\n\t\t\t__skb_unlink(skb, &oldsk->sk_receive_queue);\n\t\t\t__skb_queue_tail(&newsk->sk_receive_queue, skb);\n\t\t\tsctp_skb_set_owner_r(skb, newsk);\n\t\t}\n\t}\n\n\t/* Clean up any messages pending delivery due to partial\n\t * delivery.   Three cases:\n\t * 1) No partial deliver;  no work.\n\t * 2) Peeling off partial delivery; keep pd_lobby in new pd_lobby.\n\t * 3) Peeling off non-partial delivery; move pd_lobby to receive_queue.\n\t */\n\tskb_queue_head_init(&newsp->pd_lobby);\n\tsctp_sk(newsk)->pd_mode = assoc->ulpq.pd_mode;\n\n\tif (sctp_sk(oldsk)->pd_mode) {\n\t\tstruct sk_buff_head *queue;\n\n\t\t/* Decide which queue to move pd_lobby skbs to. */\n\t\tif (assoc->ulpq.pd_mode) {\n\t\t\tqueue = &newsp->pd_lobby;\n\t\t} else\n\t\t\tqueue = &newsk->sk_receive_queue;\n\n\t\t/* Walk through the pd_lobby, looking for skbs that\n\t\t * need moved to the new socket.\n\t\t */\n\t\tsctp_skb_for_each(skb, &oldsp->pd_lobby, tmp) {\n\t\t\tevent = sctp_skb2event(skb);\n\t\t\tif (event->asoc == assoc) {\n\t\t\t\tsctp_sock_rfree(skb);\n\t\t\t\t__skb_unlink(skb, &oldsp->pd_lobby);\n\t\t\t\t__skb_queue_tail(queue, skb);\n\t\t\t\tsctp_skb_set_owner_r(skb, newsk);\n\t\t\t}\n\t\t}\n\n\t\t/* Clear up any skbs waiting for the partial\n\t\t * delivery to finish.\n\t\t */\n\t\tif (assoc->ulpq.pd_mode)\n\t\t\tsctp_clear_pd(oldsk);\n\n\t}\n\n\t/* Set the type of socket to indicate that it is peeled off from the\n\t * original UDP-style socket or created with the accept() call on a\n\t * TCP-style socket..\n\t */\n\tnewsp->type = type;\n\n\t/* Mark the new socket \"in-use\" by the user so that any packets\n\t * that may arrive on the association after we've moved it are\n\t * queued to the backlog.  This prevents a potential race between\n\t * backlog processing on the old socket and new-packet processing\n\t * on the new socket.\n\t */\n\tsctp_lock_sock(newsk);\n\tsctp_assoc_migrate(assoc, newsk);\n\n\t/* If the association on the newsk is already closed before accept()\n\t * is called, set RCV_SHUTDOWN flag.\n\t */\n\tif (sctp_state(assoc, CLOSED) && sctp_style(newsk, TCP))\n\t\tnewsk->sk_shutdown |= RCV_SHUTDOWN;\n\n\tnewsk->sk_state = SCTP_SS_ESTABLISHED;\n\tsctp_release_sock(newsk);\n}",
        "start_line": 5644
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "net/sctp/socket.c",
        "method_name": "sctp_sock_rfree_frag",
        "raw_code": "static void sctp_sock_rfree_frag(struct sk_buff *skb) /* <=== sctp_sock_rfree_frag */ \n{\n\tstruct sk_buff *frag;\n\n\tif (!skb->data_len)\n\t\tgoto done;\n\n\t/* Don't forget the fragments. */\n\tfor (frag = skb_shinfo(skb)->frag_list; frag; frag = frag->next)\n\t\tsctp_sock_rfree_frag(frag);\n\ndone:\n\tsctp_sock_rfree(skb);\n}",
        "start_line": 5641
      },
      {
        "filename": "net/sctp/socket.c",
        "method_name": "sctp_skb_set_owner_r_frag",
        "raw_code": "static void sctp_skb_set_owner_r_frag(struct sk_buff *skb, struct sock *sk) /* <=== sctp_skb_set_owner_r_frag */ \n{\n\tstruct sk_buff *frag;\n\n\tif (!skb->data_len)\n\t\tgoto done;\n\n\t/* Don't forget the fragments. */\n\tfor (frag = skb_shinfo(skb)->frag_list; frag; frag = frag->next)\n\t\tsctp_skb_set_owner_r_frag(frag, sk);\n\ndone:\n\tsctp_skb_set_owner_r(skb, sk);\n}",
        "start_line": 5656
      },
      {
        "filename": "net/sctp/socket.c",
        "method_name": "sctp_sock_migrate",
        "raw_code": "static void sctp_sock_migrate(struct sock *oldsk, struct sock *newsk, /* <=== sctp_sock_migrate */ \n\t\t\t      struct sctp_association *assoc,\n\t\t\t      sctp_socket_type_t type)\n{\n\tstruct sctp_sock *oldsp = sctp_sk(oldsk);\n\tstruct sctp_sock *newsp = sctp_sk(newsk);\n\tstruct sctp_bind_bucket *pp; /* hash list port iterator */\n\tstruct sctp_endpoint *newep = newsp->ep;\n\tstruct sk_buff *skb, *tmp;\n\tstruct sctp_ulpevent *event;\n\tint flags = 0;\n\n\t/* Migrate socket buffer sizes and all the socket level options to the\n\t * new socket.\n\t */\n\tnewsk->sk_sndbuf = oldsk->sk_sndbuf;\n\tnewsk->sk_rcvbuf = oldsk->sk_rcvbuf;\n\t/* Brute force copy old sctp opt. */\n\tinet_sk_copy_descendant(newsk, oldsk);\n\n\t/* Restore the ep value that was overwritten with the above structure\n\t * copy.\n\t */\n\tnewsp->ep = newep;\n\tnewsp->hmac = NULL;\n\n\t/* Hook this new socket in to the bind_hash list. */\n\tpp = sctp_sk(oldsk)->bind_hash;\n\tsk_add_bind_node(newsk, &pp->owner);\n\tsctp_sk(newsk)->bind_hash = pp;\n\tinet_sk(newsk)->num = inet_sk(oldsk)->num;\n\n\t/* Copy the bind_addr list from the original endpoint to the new\n\t * endpoint so that we can handle restarts properly\n\t */\n\tif (PF_INET6 == assoc->base.sk->sk_family)\n\t\tflags = SCTP_ADDR6_ALLOWED;\n\tif (assoc->peer.ipv4_address)\n\t\tflags |= SCTP_ADDR4_PEERSUPP;\n\tif (assoc->peer.ipv6_address)\n\t\tflags |= SCTP_ADDR6_PEERSUPP;\n\tsctp_bind_addr_copy(&newsp->ep->base.bind_addr,\n\t\t\t     &oldsp->ep->base.bind_addr,\n\t\t\t     SCTP_SCOPE_GLOBAL, GFP_KERNEL, flags);\n\n\t/* Move any messages in the old socket's receive queue that are for the\n\t * peeled off association to the new socket's receive queue.\n\t */\n\tsctp_skb_for_each(skb, &oldsk->sk_receive_queue, tmp) {\n\t\tevent = sctp_skb2event(skb);\n\t\tif (event->asoc == assoc) {\n\t\t\tsctp_sock_rfree_frag(skb);\n\t\t\t__skb_unlink(skb, &oldsk->sk_receive_queue);\n\t\t\t__skb_queue_tail(&newsk->sk_receive_queue, skb);\n\t\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\t\t}\n\t}\n\n\t/* Clean up any messages pending delivery due to partial\n\t * delivery.   Three cases:\n\t * 1) No partial deliver;  no work.\n\t * 2) Peeling off partial delivery; keep pd_lobby in new pd_lobby.\n\t * 3) Peeling off non-partial delivery; move pd_lobby to receive_queue.\n\t */\n\tskb_queue_head_init(&newsp->pd_lobby);\n\tsctp_sk(newsk)->pd_mode = assoc->ulpq.pd_mode;\n\n\tif (sctp_sk(oldsk)->pd_mode) {\n\t\tstruct sk_buff_head *queue;\n\n\t\t/* Decide which queue to move pd_lobby skbs to. */\n\t\tif (assoc->ulpq.pd_mode) {\n\t\t\tqueue = &newsp->pd_lobby;\n\t\t} else\n\t\t\tqueue = &newsk->sk_receive_queue;\n\n\t\t/* Walk through the pd_lobby, looking for skbs that\n\t\t * need moved to the new socket.\n\t\t */\n\t\tsctp_skb_for_each(skb, &oldsp->pd_lobby, tmp) {\n\t\t\tevent = sctp_skb2event(skb);\n\t\t\tif (event->asoc == assoc) {\n\t\t\t\tsctp_sock_rfree_frag(skb);\n\t\t\t\t__skb_unlink(skb, &oldsp->pd_lobby);\n\t\t\t\t__skb_queue_tail(queue, skb);\n\t\t\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\t\t\t}\n\t\t}\n\n\t\t/* Clear up any skbs waiting for the partial\n\t\t * delivery to finish.\n\t\t */\n\t\tif (assoc->ulpq.pd_mode)\n\t\t\tsctp_clear_pd(oldsk);\n\n\t}\n\n\tsctp_skb_for_each(skb, &assoc->ulpq.reasm, tmp) {\n\t\tsctp_sock_rfree_frag(skb);\n\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\t}\n\n\tsctp_skb_for_each(skb, &assoc->ulpq.lobby, tmp) {\n\t\tsctp_sock_rfree_frag(skb);\n\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\t}\n\n\t/* Set the type of socket to indicate that it is peeled off from the\n\t * original UDP-style socket or created with the accept() call on a\n\t * TCP-style socket..\n\t */\n\tnewsp->type = type;\n\n\t/* Mark the new socket \"in-use\" by the user so that any packets\n\t * that may arrive on the association after we've moved it are\n\t * queued to the backlog.  This prevents a potential race between\n\t * backlog processing on the old socket and new-packet processing\n\t * on the new socket.\n\t */\n\tsctp_lock_sock(newsk);\n\tsctp_assoc_migrate(assoc, newsk);\n\n\t/* If the association on the newsk is already closed before accept()\n\t * is called, set RCV_SHUTDOWN flag.\n\t */\n\tif (sctp_state(assoc, CLOSED) && sctp_style(newsk, TCP))\n\t\tnewsk->sk_shutdown |= RCV_SHUTDOWN;\n\n\tnewsk->sk_state = SCTP_SS_ESTABLISHED;\n\tsctp_release_sock(newsk);\n}",
        "start_line": 5674
      }
    ],
    "code_context": "Called Methods:\n- sctp_endpoint_put: void sctp_endpoint_put(struct sctp_endpoint *); /* <=== sctp_endpoint_put */ \n- sctp_assoc_migrate: void sctp_assoc_migrate(struct sctp_association *assoc, struct sock *newsk) /* <=== sctp_assoc_migrate */ \n{\n\tstruct sctp_sock *newsp = sctp_sk(newsk);\n\tstruct sock *oldsk = assoc->base.sk;\n\n\t/* Delete the association from the old endpoint's list of\n\t * associations.\n\t */\n\tlist_del_init(&assoc->asocs);\n\n\t/* Decrement the backlog value for a TCP-style socket. */\n\tif (sctp_style(oldsk, TCP))\n\t\toldsk->sk_ack_backlog--;\n\n\t/* Release references to the old endpoint and the sock.  */\n\tsctp_endpoint_put(assoc->ep);\n\tsock_put(assoc->base.sk);\n\n\t/* Get a reference to the new endpoint.  */\n\tassoc->ep = newsp->ep;\n\tsctp_endpoint_hold(assoc->ep);\n\n\t/* Get a reference to the new sock.  */\n\tassoc->base.sk = newsk;\n\tsock_hold(assoc->base.sk);\n\n\t/* Add the association to the new endpoint's list of associations.  */\n\tsctp_endpoint_add_asoc(newsp->ep, assoc);\n}\n- sctp_sock_rfree: void sctp_sock_rfree(struct sk_buff *skb) /* <=== sctp_sock_rfree */ \n{\n\tstruct sock *sk = skb->sk;\n\tstruct sctp_ulpevent *event = sctp_skb2event(skb);\n\n\tatomic_sub(event->rmem_len, &sk->sk_rmem_alloc);\n}\n- sock_hold: static inline void sock_hold(struct sock *sk) /* <=== sock_hold */ \n{\n\tatomic_inc(&sk->sk_refcnt);\n}\n- sock_put: static inline void sock_put(struct sock *sk) /* <=== sock_put */ \n{\n\tif (atomic_dec_and_test(&sk->sk_refcnt))\n\t\tsk_free(sk);\n}\n- sctp_skb_list_tail: static inline void sctp_skb_list_tail(struct sk_buff_head *list, /* <=== sctp_skb_list_tail */ \n\t\t\t\t      struct sk_buff_head *head)\n{\n\tunsigned long flags;\n\n\tsctp_spin_lock_irqsave(&head->lock, flags);\n\tsctp_spin_lock(&list->lock);\n\n\tlist_splice((struct list_head *)list, (struct list_head *)head->prev);\n\n\thead->qlen += list->qlen;\n\tlist->qlen = 0;\n\n\tsctp_spin_unlock(&list->lock);\n\tsctp_spin_unlock_irqrestore(&head->lock, flags);\n}\n- sctp_sk: static inline struct sctp_sock *sctp_sk(const struct sock *sk) /* <=== sctp_sk */ \n{\n       return (struct sctp_sock *)sk;\n}\n- sctp_clear_pd: int sctp_clear_pd(struct sock *sk) /* <=== sctp_clear_pd */ \n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\tsp->pd_mode = 0;\n\tif (!skb_queue_empty(&sp->pd_lobby)) {\n\t\tstruct list_head *list;\n\t\tsctp_skb_list_tail(&sp->pd_lobby, &sk->sk_receive_queue);\n\t\tlist = (struct list_head *)&sctp_sk(sk)->pd_lobby;\n\t\tINIT_LIST_HEAD(list);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n- sctp_endpoint_hold: void sctp_endpoint_hold(struct sctp_endpoint *); /* <=== sctp_endpoint_hold */ \n- sctp_endpoint_add_asoc: void sctp_endpoint_add_asoc(struct sctp_endpoint *, struct sctp_association *); /* <=== sctp_endpoint_add_asoc */ \n- sctp_skb_set_owner_r: static inline void sctp_skb_set_owner_r(struct sk_buff *skb, struct sock *sk) /* <=== sctp_skb_set_owner_r */ \n{\n\tstruct sctp_ulpevent *event = sctp_skb2event(skb);\n\n\tskb->sk = sk;\n\tskb->destructor = sctp_sock_rfree;\n\tatomic_add(event->rmem_len, &sk->sk_rmem_alloc);\n}\n\nType Definitions:\n- sctp_ulpevent: struct sctp_ulpevent\n- sctp_sock: struct sctp_sock {\n\t/* inet_sock has to be the first member of sctp_sock */\n\tstruct inet_sock inet;\n\t/* What kind of a socket is this? */\n\tsctp_socket_type_t type;\n\n\t/* PF_ family specific functions.  */\n\tstruct sctp_pf *pf;\n\n\t/* Access to HMAC transform. */\n\tstruct crypto_hash *hmac;\n\n\t/* What is our base endpointer? */\n\tstruct sctp_endpoint *ep;\n\n\tstruct sctp_bind_bucket *bind_hash;\n\t/* Various Socket Options.  */\n\t__u16 default_stream;\n\t__u32 default_ppid;\n\t__u16 default_flags;\n\t__u32 default_context;\n\t__u32 default_timetolive;\n\t__u32 default_rcv_context;\n\n\t/* Heartbeat interval: The endpoint sends out a Heartbeat chunk to\n\t * the destination address every heartbeat interval. This value\n\t * will be inherited by all new associations.\n\t */\n\t__u32 hbinterval;\n\n\t/* This is the max_retrans value for new associations. */\n\t__u16 pathmaxrxt;\n\n\t/* The initial Path MTU to use for new associations. */\n\t__u32 pathmtu;\n\n\t/* The default SACK delay timeout for new associations. */\n\t__u32 sackdelay;\n\n\t/* Flags controling Heartbeat, SACK delay, and Path MTU Discovery. */\n\t__u32 param_flags;\n\n\tstruct sctp_initmsg initmsg;\n\tstruct sctp_rtoinfo rtoinfo;\n\tstruct sctp_paddrparams paddrparam;\n\tstruct sctp_event_subscribe subscribe;\n\tstruct sctp_assocparams assocparams;\n\tint user_frag;\n\t__u32 autoclose;\n\t__u8 nodelay;\n\t__u8 disable_fragments;\n\t__u8 pd_mode;\n\t__u8 v4mapped;\n\t__u32 adaptation_ind;\n\n\t/* Receive to here while partial delivery is in effect. */\n\tstruct sk_buff_head pd_lobby;\n}\n- sk_buff_head: struct sk_buff_head {\n\t/* These two members must be first. */\n\tstruct sk_buff\t*next;\n\tstruct sk_buff\t*prev;\n\n\t__u32\t\tqlen;\n\tspinlock_t\tlock;\n}\n- sctp_endpoint: struct sctp_endpoint\n- sk_buff: struct sk_buff\n- sctp_association: struct sctp_association\n- sock: struct sock\n- sock: struct sock {\n\t/*\n\t * Now struct inet_timewait_sock also uses sock_common, so please just\n\t * don't add nothing before this first member (__sk_common) --acme\n\t */\n\tstruct sock_common\t__sk_common;\n#define sk_family\t\t__sk_common.skc_family\n#define sk_state\t\t__sk_common.skc_state\n#define sk_reuse\t\t__sk_common.skc_reuse\n#define sk_bound_dev_if\t\t__sk_common.skc_bound_dev_if\n#define sk_node\t\t\t__sk_common.skc_node\n#define sk_bind_node\t\t__sk_common.skc_bind_node\n#define sk_refcnt\t\t__sk_common.skc_refcnt\n#define sk_hash\t\t\t__sk_common.skc_hash\n#define sk_prot\t\t\t__sk_common.skc_prot\n\tunsigned char\t\tsk_shutdown : 2,\n\t\t\t\tsk_no_check : 2,\n\t\t\t\tsk_userlocks : 4;\n\tunsigned char\t\tsk_protocol;\n\tunsigned short\t\tsk_type;\n\tint\t\t\tsk_rcvbuf;\n\tsocket_lock_t\t\tsk_lock;\n\twait_queue_head_t\t*sk_sleep;\n\tstruct dst_entry\t*sk_dst_cache;\n\tstruct xfrm_policy\t*sk_policy[2];\n\trwlock_t\t\tsk_dst_lock;\n\tatomic_t\t\tsk_rmem_alloc;\n\tatomic_t\t\tsk_wmem_alloc;\n\tatomic_t\t\tsk_omem_alloc;\n\tstruct sk_buff_head\tsk_receive_queue;\n\tstruct sk_buff_head\tsk_write_queue;\n\tstruct sk_buff_head\tsk_async_wait_queue;\n\tint\t\t\tsk_wmem_queued;\n\tint\t\t\tsk_forward_alloc;\n\tgfp_t\t\t\tsk_allocation;\n\tint\t\t\tsk_sndbuf;\n\tint\t\t\tsk_route_caps;\n\tint\t\t\tsk_gso_type;\n\tint\t\t\tsk_rcvlowat;\n\tunsigned long \t\tsk_flags;\n\tunsigned long\t        sk_lingertime;\n\t/*\n\t * The backlog queue is special, it is always used with\n\t * the per-socket spinlock held and requires low latency\n\t * access. Therefore we special case it's implementation.\n\t */\n\tstruct {\n\t\tstruct sk_buff *head;\n\t\tstruct sk_buff *tail;\n\t} sk_backlog;\n\tstruct sk_buff_head\tsk_error_queue;\n\tstruct proto\t\t*sk_prot_creator;\n\trwlock_t\t\tsk_callback_lock;\n\tint\t\t\tsk_err,\n\t\t\t\tsk_err_soft;\n\tunsigned short\t\tsk_ack_backlog;\n\tunsigned short\t\tsk_max_ack_backlog;\n\t__u32\t\t\tsk_priority;\n\tstruct ucred\t\tsk_peercred;\n\tlong\t\t\tsk_rcvtimeo;\n\tlong\t\t\tsk_sndtimeo;\n\tstruct sk_filter      \t*sk_filter;\n\tvoid\t\t\t*sk_protinfo;\n\tstruct timer_list\tsk_timer;\n\tstruct timeval\t\tsk_stamp;\n\tstruct socket\t\t*sk_socket;\n\tvoid\t\t\t*sk_user_data;\n\tstruct page\t\t*sk_sndmsg_page;\n\tstruct sk_buff\t\t*sk_send_head;\n\t__u32\t\t\tsk_sndmsg_off;\n\tint\t\t\tsk_write_pending;\n\tvoid\t\t\t*sk_security;\n\tvoid\t\t\t(*sk_state_change)(struct sock *sk);\n\tvoid\t\t\t(*sk_data_ready)(struct sock *sk, int bytes);\n\tvoid\t\t\t(*sk_write_space)(struct sock *sk);\n\tvoid\t\t\t(*sk_error_report)(struct sock *sk);\n  \tint\t\t\t(*sk_backlog_rcv)(struct sock *sk,\n\t\t\t\t\t\t  struct sk_buff *skb);  \n\tvoid                    (*sk_destruct)(struct sock *sk);\n}\n- sctp_association: struct sctp_association {\n\n\t/* A base structure common to endpoint and association.\n\t * In this context, it represents the associations's view\n\t * of the local endpoint of the association.\n\t */\n\tstruct sctp_ep_common base;\n\n\t/* Associations on the same socket. */\n\tstruct list_head asocs;\n\n\t/* association id. */\n\tsctp_assoc_t assoc_id;\n\n\t/* This is our parent endpoint.\t */\n\tstruct sctp_endpoint *ep;\n\n\t/* These are those association elements needed in the cookie.  */\n\tstruct sctp_cookie c;\n\n\t/* This is all information about our peer.  */\n\tstruct {\n\t\t/* rwnd\n\t\t *\n\t\t * Peer Rwnd   : Current calculated value of the peer's rwnd.\n\t\t */\n\t\t__u32 rwnd;\n\n\t\t/* transport_addr_list\n\t\t *\n\t\t * Peer\t       : A list of SCTP transport addresses that the\n\t\t * Transport   : peer is bound to. This information is derived\n\t\t * Address     : from the INIT or INIT ACK and is used to\n\t\t * List\t       : associate an inbound packet with a given\n\t\t *\t       : association. Normally this information is\n\t\t *\t       : hashed or keyed for quick lookup and access\n\t\t *\t       : of the TCB.\n\t\t *\t       : The list is also initialized with the list\n\t\t *\t       : of addresses passed with the sctp_connectx()\n\t\t *\t       : call.\n\t\t *\n\t\t * It is a list of SCTP_transport's.\n\t\t */\n\t\tstruct list_head transport_addr_list;\n\n\t\t/* transport_count\n\t\t *\n\t\t * Peer        : A count of the number of peer addresses\n\t\t * Transport   : in the Peer Transport Address List.\n\t\t * Address     :\n\t\t * Count       :\n\t\t */\n\t\t__u16 transport_count;\n\n\t\t/* port\n\t\t *   The transport layer port number.\n\t\t */\n\t\t__u16 port;\n\n\t\t/* primary_path\n\t\t *\n\t\t * Primary     : This is the current primary destination\n\t\t * Path\t       : transport address of the peer endpoint.  It\n\t\t *\t       : may also specify a source transport address\n\t\t *\t       : on this endpoint.\n\t\t *\n\t\t * All of these paths live on transport_addr_list.\n\t\t *\n\t\t * At the bakeoffs, we discovered that the intent of\n\t\t * primaryPath is that it only changes when the ULP\n\t\t * asks to have it changed.  We add the activePath to\n\t\t * designate the connection we are currently using to\n\t\t * transmit new data and most control chunks.\n\t\t */\n\t\tstruct sctp_transport *primary_path;\n\n\t\t/* Cache the primary path address here, when we\n\t\t * need a an address for msg_name.\n\t\t */\n\t\tunion sctp_addr primary_addr;\n\n\t\t/* active_path\n\t\t *   The path that we are currently using to\n\t\t *   transmit new data and most control chunks.\n\t\t */\n\t\tstruct sctp_transport *active_path;\n\n\t\t/* retran_path\n\t\t *\n\t\t * RFC2960 6.4 Multi-homed SCTP Endpoints\n\t\t * ...\n\t\t * Furthermore, when its peer is multi-homed, an\n\t\t * endpoint SHOULD try to retransmit a chunk to an\n\t\t * active destination transport address that is\n\t\t * different from the last destination address to\n\t\t * which the DATA chunk was sent.\n\t\t */\n\t\tstruct sctp_transport *retran_path;\n\n\t\t/* Pointer to last transport I have sent on.  */\n\t\tstruct sctp_transport *last_sent_to;\n\n\t\t/* This is the last transport I have received DATA on.\t*/\n\t\tstruct sctp_transport *last_data_from;\n\n\t\t/*\n\t\t * Mapping  An array of bits or bytes indicating which out of\n\t\t * Array    order TSN's have been received (relative to the\n\t\t *\t    Last Rcvd TSN). If no gaps exist, i.e. no out of\n\t\t *\t    order packets have been received, this array\n\t\t *\t    will be set to all zero. This structure may be\n\t\t *\t    in the form of a circular buffer or bit array.\n\t\t *\n\t\t * Last Rcvd   : This is the last TSN received in\n\t\t * TSN\t       : sequence. This value is set initially by\n\t\t *\t       : taking the peer's Initial TSN, received in\n\t\t *\t       : the INIT or INIT ACK chunk, and subtracting\n\t\t *\t       : one from it.\n\t\t *\n\t\t * Throughout most of the specification this is called the\n\t\t * \"Cumulative TSN ACK Point\".\tIn this case, we\n\t\t * ignore the advice in 12.2 in favour of the term\n\t\t * used in the bulk of the text.  This value is hidden\n\t\t * in tsn_map--we get it by calling sctp_tsnmap_get_ctsn().\n\t\t */\n\t\tstruct sctp_tsnmap tsn_map;\n\t\t__u8 _map[sctp_tsnmap_storage_size(SCTP_TSN_MAP_SIZE)];\n\n\t\t/* Ack State   : This flag indicates if the next received\n\t\t *             : packet is to be responded to with a\n\t\t *             : SACK. This is initializedto 0.  When a packet\n\t\t *             : is received it is incremented. If this value\n\t\t *             : reaches 2 or more, a SACK is sent and the\n\t\t *             : value is reset to 0. Note: This is used only\n\t\t *             : when no DATA chunks are received out of\n\t\t *             : order.  When DATA chunks are out of order,\n\t\t *             : SACK's are not delayed (see Section 6).\n\t\t */\n\t\t__u8    sack_needed;     /* Do we need to sack the peer? */\n\n\t\t/* These are capabilities which our peer advertised.  */\n\t\t__u8\tecn_capable;\t /* Can peer do ECN? */\n\t\t__u8\tipv4_address;\t /* Peer understands IPv4 addresses? */\n\t\t__u8\tipv6_address;\t /* Peer understands IPv6 addresses? */\n\t\t__u8\thostname_address;/* Peer understands DNS addresses? */\n\t\t__u8    asconf_capable;  /* Does peer support ADDIP? */\n\t\t__u8    prsctp_capable;  /* Can peer do PR-SCTP? */\n\n\t\t__u32   adaptation_ind;\t /* Adaptation Code point. */\n\n\t\t/* This mask is used to disable sending the ASCONF chunk\n\t\t * with specified parameter to peer.\n\t\t */\n\t\t__be16 addip_disabled_mask;\n\n\t\tstruct sctp_inithdr_host i;\n\t\tint cookie_len;\n\t\tvoid *cookie;\n\n\t\t/* ADDIP Section 4.2 Upon reception of an ASCONF Chunk.\n\t\t * C1) ... \"Peer-Serial-Number'. This value MUST be initialized to the\n\t\t * Initial TSN Value minus 1\n\t\t */\n\t\t__u32 addip_serial;\n\t} peer;\n\n\t/* State       : A state variable indicating what state the\n\t *\t       : association is in, i.e. COOKIE-WAIT,\n\t *\t       : COOKIE-ECHOED, ESTABLISHED, SHUTDOWN-PENDING,\n\t *\t       : SHUTDOWN-SENT, SHUTDOWN-RECEIVED, SHUTDOWN-ACK-SENT.\n\t *\n\t *\t\tNote: No \"CLOSED\" state is illustrated since if a\n\t *\t\tassociation is \"CLOSED\" its TCB SHOULD be removed.\n\t *\n\t *\t\tIn this implementation we DO have a CLOSED\n\t *\t\tstate which is used during initiation and shutdown.\n\t *\n\t *\t\tState takes values from SCTP_STATE_*.\n\t */\n\tsctp_state_t state;\n\n\t/* The cookie life I award for any cookie.  */\n\tstruct timeval cookie_life;\n\n\t/* Overall     : The overall association error count.\n\t * Error Count : [Clear this any time I get something.]\n\t */\n\tint overall_error_count;\n\n\t/* These are the association's initial, max, and min RTO values.\n\t * These values will be initialized by system defaults, but can\n\t * be modified via the SCTP_RTOINFO socket option.\n\t */\n\tunsigned long rto_initial;\n\tunsigned long rto_max;\n\tunsigned long rto_min;\n\n\t/* Maximum number of new data packets that can be sent in a burst.  */\n\tint max_burst;\n\n\t/* This is the max_retrans value for the association.  This value will\n\t * be initialized initialized from system defaults, but can be\n\t * modified by the SCTP_ASSOCINFO socket option.\n\t */\n\tint max_retrans;\n\n\t/* Maximum number of times the endpoint will retransmit INIT  */\n\t__u16 max_init_attempts;\n\n\t/* How many times have we resent an INIT? */\n\t__u16 init_retries;\n\n\t/* The largest timeout or RTO value to use in attempting an INIT */\n\tunsigned long max_init_timeo;\n\n\t/* Heartbeat interval: The endpoint sends out a Heartbeat chunk to\n\t * the destination address every heartbeat interval. This value\n\t * will be inherited by all new transports.\n\t */\n\tunsigned long hbinterval;\n\n\t/* This is the max_retrans value for new transports in the\n\t * association.\n\t */\n\t__u16 pathmaxrxt;\n\n\t/* Association : The smallest PMTU discovered for all of the\n\t * PMTU\t       : peer's transport addresses.\n\t */\n\t__u32 pathmtu;\n\n\t/* Flags controling Heartbeat, SACK delay, and Path MTU Discovery. */\n\t__u32 param_flags;\n\n\t/* SACK delay timeout */\n\tunsigned long sackdelay;\n\n\n\tunsigned long timeouts[SCTP_NUM_TIMEOUT_TYPES];\n\tstruct timer_list timers[SCTP_NUM_TIMEOUT_TYPES];\n\n\t/* Transport to which SHUTDOWN chunk was last sent.  */\n\tstruct sctp_transport *shutdown_last_sent_to;\n\n\t/* Transport to which INIT chunk was last sent.  */\n\tstruct sctp_transport *init_last_sent_to;\n\n\t/* Next TSN    : The next TSN number to be assigned to a new\n\t *\t       : DATA chunk.  This is sent in the INIT or INIT\n\t *\t       : ACK chunk to the peer and incremented each\n\t *\t       : time a DATA chunk is assigned a TSN\n\t *\t       : (normally just prior to transmit or during\n\t *\t       : fragmentation).\n\t */\n\t__u32 next_tsn;\n\n\t/*\n\t * Last Rcvd   : This is the last TSN received in sequence.  This value\n\t * TSN\t       : is set initially by taking the peer's Initial TSN,\n\t *\t       : received in the INIT or INIT ACK chunk, and\n\t *\t       : subtracting one from it.\n\t *\n\t * Most of RFC 2960 refers to this as the Cumulative TSN Ack Point.\n\t */\n\n\t__u32 ctsn_ack_point;\n\n\t/* PR-SCTP Advanced.Peer.Ack.Point */\n\t__u32 adv_peer_ack_point;\n\n\t/* Highest TSN that is acknowledged by incoming SACKs. */\n\t__u32 highest_sacked;\n\n\t/* The number of unacknowledged data chunks.  Reported through\n\t * the SCTP_STATUS sockopt.\n\t */\n\t__u16 unack_data;\n\n\t/* This is the association's receive buffer space.  This value is used\n\t * to set a_rwnd field in an INIT or a SACK chunk.\n\t */\n\t__u32 rwnd;\n\n\t/* This is the last advertised value of rwnd over a SACK chunk. */\n\t__u32 a_rwnd;\n\n\t/* Number of bytes by which the rwnd has slopped.  The rwnd is allowed\n\t * to slop over a maximum of the association's frag_point.\n\t */\n\t__u32 rwnd_over;\n\n\t/* This is the sndbuf size in use for the association.\n\t * This corresponds to the sndbuf size for the association,\n\t * as specified in the sk->sndbuf.\n\t */\n\tint sndbuf_used;\n\n\t/* This is the amount of memory that this association has allocated\n\t * in the receive path at any given time.\n\t */\n\tatomic_t rmem_alloc;\n\n\t/* This is the wait queue head for send requests waiting on\n\t * the association sndbuf space.\n\t */\n\twait_queue_head_t\twait;\n\n\t/* The message size at which SCTP fragmentation will occur. */\n\t__u32 frag_point;\n\n\t/* Counter used to count INIT errors. */\n\tint init_err_counter;\n\n\t/* Count the number of INIT cycles (for doubling timeout). */\n\tint init_cycle;\n\n\t/* Default send pa...\n- sk_buff: struct sk_buff {\n\t/* These two members must be first. */\n\tstruct sk_buff\t\t*next;\n\tstruct sk_buff\t\t*prev;\n\n\tstruct sock\t\t*sk;\n\tstruct skb_timeval\ttstamp;\n\tstruct net_device\t*dev;\n\tint\t\t\tiif;\n\t/* 4 byte hole on 64 bit*/\n\n\tunion {\n\t\tstruct tcphdr\t*th;\n\t\tstruct udphdr\t*uh;\n\t\tstruct icmphdr\t*icmph;\n\t\tstruct igmphdr\t*igmph;\n\t\tstruct iphdr\t*ipiph;\n\t\tstruct ipv6hdr\t*ipv6h;\n\t\tunsigned char\t*raw;\n\t} h;\n\n\tunion {\n\t\tstruct iphdr\t*iph;\n\t\tstruct ipv6hdr\t*ipv6h;\n\t\tstruct arphdr\t*arph;\n\t\tunsigned char\t*raw;\n\t} nh;\n\n\tunion {\n\t  \tunsigned char \t*raw;\n\t} mac;\n\n\tstruct  dst_entry\t*dst;\n\tstruct\tsec_path\t*sp;\n\n\t/*\n\t * This is the control buffer. It is free to use for every\n\t * layer. Please put your private variables there. If you\n\t * want to keep them across layers you have to do a skb_clone()\n\t * first. This is owned by whoever has the skb queued ATM.\n\t */\n\tchar\t\t\tcb[48];\n\n\tunsigned int\t\tlen,\n\t\t\t\tdata_len,\n\t\t\t\tmac_len;\n\tunion {\n\t\t__wsum\t\tcsum;\n\t\t__u32\t\tcsum_offset;\n\t};\n\t__u32\t\t\tpriority;\n\t__u8\t\t\tlocal_df:1,\n\t\t\t\tcloned:1,\n\t\t\t\tip_summed:2,\n\t\t\t\tnohdr:1,\n\t\t\t\tnfctinfo:3;\n\t__u8\t\t\tpkt_type:3,\n\t\t\t\tfclone:2,\n\t\t\t\tipvs_property:1;\n\t__be16\t\t\tprotocol;\n\n\tvoid\t\t\t(*destructor)(struct sk_buff *skb);\n#ifdef CONFIG_NETFILTER\n\tstruct nf_conntrack\t*nfct;\n#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)\n\tstruct sk_buff\t\t*nfct_reasm;\n#endif\n#ifdef CONFIG_BRIDGE_NETFILTER\n\tstruct nf_bridge_info\t*nf_bridge;\n#endif\n#endif /* CONFIG_NETFILTER */\n#ifdef CONFIG_NET_SCHED\n\t__u16\t\t\ttc_index;\t/* traffic control index */\n#ifdef CONFIG_NET_CLS_ACT\n\t__u16\t\t\ttc_verd;\t/* traffic control verdict */\n#endif\n#endif\n#ifdef CONFIG_NET_DMA\n\tdma_cookie_t\t\tdma_cookie;\n#endif\n#ifdef CONFIG_NETWORK_SECMARK\n\t__u32\t\t\tsecmark;\n#endif\n\n\t__u32\t\t\tmark;\n\n\t/* These elements must be at the end, see alloc_skb() for details.  */\n\tunsigned int\t\ttruesize;\n\tatomic_t\t\tusers;\n\tunsigned char\t\t*head,\n\t\t\t\t*data,\n\t\t\t\t*tail,\n\t\t\t\t*end;\n}\n- sctp_ulpevent: static struct sctp_ulpevent\n\nImports:\n- #include <linux/poll.h>\n- #include <net/ipv6.h>\n- #include <net/sctp/sctp.h>\n- #include <linux/init.h>\n- #include <net/ip.h>\n- #include <linux/capability.h>\n- #include <linux/ip.h>\n- #include <linux/types.h>\n- #include <net/route.h>\n- #include <net/sock.h>\n- #include <linux/wait.h>\n- #include <linux/crypto.h>\n- #include <linux/time.h>\n- #include <linux/socket.h>\n- #include <net/icmp.h>\n- #include <linux/fcntl.h>\n- #include <net/inet_common.h>\n- #include <net/sctp/sm.h>\n- #include <linux/kernel.h>",
    "commit_msg": "[SCTP]: Fix assertion (!atomic_read(&sk->sk_rmem_alloc)) failed message\n\nIn current implementation, LKSCTP does receive buffer accounting for\ndata in sctp_receive_queue and pd_lobby. However, LKSCTP don't do\naccounting for data in frag_list when data is fragmented. In addition,\nLKSCTP doesn't do accounting for data in reasm and lobby queue in\nstructure sctp_ulpq.\nWhen there are date in these queue, assertion failed message is printed\nin inet_sock_destruct because sk_rmem_alloc of oldsk does not become 0\nwhen socket is destroyed.\n\nSigned-off-by: Tsutomu Fujii <t-fujii@nb.jp.nec.com>\nSigned-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "cve_desc": "[{'lang': 'en', 'value': 'A certain Red Hat patch to the sctp_sock_migrate function in net/sctp/socket.c in the Linux kernel before 2.6.21, as used in Red Hat Enterprise Linux (RHEL) 5, allows remote attackers to cause a denial of service (NULL pointer dereference and OOPS) via a crafted SCTP packet.'}]",
    "year": 2007,
    "filename": "socket.c",
    "commit_url": "\"https://github.com/torvalds/linux/commit/ea2bc483ff5caada7c4aa0d5fbf87d3a6590273d\""
  },
  {
    "repository": "torvalds/linux",
    "cve_id": "CVE-2011-2493",
    "cwe_list": [
      "CWE-703"
    ],
    "commit_hash": "0449641130f5652b344ef6fa39fa019d7e94660a",
    "short_hash": "04496411",
    "vulnerableMethods_before": [
      {
        "filename": "fs/ext4/super.c",
        "method_name": "__acquires",
        "raw_code": "__acquires(bitlock) /* <=== __acquires */ \n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tes->s_last_error_ino = cpu_to_le32(ino);\n\tes->s_last_error_block = cpu_to_le64(block);\n\t__save_error_info(sb, function, line);\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: group %u, \",\n\t       sb->s_id, function, line, grp);\n\tif (ino)\n\t\tprintk(KERN_CONT \"inode %lu: \", ino);\n\tif (block)\n\t\tprintk(KERN_CONT \"block %llu:\", (unsigned long long) block);\n\tprintk(KERN_CONT \"%pV\\n\", &vaf);\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_CONT)) {\n\t\text4_commit_super(sb, 0);\n\t\treturn;\n\t}\n\n\text4_unlock_group(sb, grp);\n\text4_handle_error(sb);\n\t/*\n\t * We only get here in the ERRORS_RO case; relocking the group\n\t * may be dangerous, but nothing bad will happen since the\n\t * filesystem will have already been marked read/only and the\n\t * journal has been aborted.  We return 1 as a hint to callers\n\t * who might what to use the return value from\n\t * ext4_grp_locked_error() to distinguish beween the\n\t * ERRORS_CONT and ERRORS_RO case, and perhaps return more\n\t * aggressively from the ext4 function in question, with a\n\t * more appropriate error code.\n\t */\n\text4_lock_group(sb, grp);\n\treturn;\n}",
        "start_line": 584
      },
      {
        "filename": "fs/ext4/super.c",
        "method_name": "__acquires",
        "raw_code": "\t\t\t\t__acquires(kernel_lock) /* <=== __acquires */ \n{\n\tchar *orig_data = kstrdup(data, GFP_KERNEL);\n\tstruct buffer_head *bh;\n\tstruct ext4_super_block *es = NULL;\n\tstruct ext4_sb_info *sbi;\n\text4_fsblk_t block;\n\text4_fsblk_t sb_block = get_sb_block(&data);\n\text4_fsblk_t logical_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tchar *cp;\n\tconst char *descr;\n\tint ret = -ENOMEM;\n\tint blocksize;\n\tunsigned int db_count;\n\tunsigned int i;\n\tint needs_recovery, has_huge_files;\n\t__u64 blocks_count;\n\tint err;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\text4_group_t first_not_zeroed;\n\n\tsbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\tif (!sbi)\n\t\tgoto out_free_orig;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock) {\n\t\tkfree(sbi);\n\t\tgoto out_free_orig;\n\t}\n\tsb->s_fs_info = sbi;\n\tsbi->s_mount_opt = 0;\n\tsbi->s_resuid = EXT4_DEF_RESUID;\n\tsbi->s_resgid = EXT4_DEF_RESGID;\n\tsbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;\n\tsbi->s_sb_block = sb_block;\n\tif (sb->s_bdev->bd_part)\n\t\tsbi->s_sectors_written_start =\n\t\t\tpart_stat_read(sb->s_bdev->bd_part, sectors[1]);\n\n\t/* Cleanup superblock name */\n\tfor (cp = sb->s_id; (cp = strchr(cp, '/'));)\n\t\t*cp = '!';\n\n\tret = -EINVAL;\n\tblocksize = sb_min_blocksize(sb, EXT4_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text4_msg(sb, KERN_ERR, \"unable to set blocksize\");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext4 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT4_MIN_BLOCK_SIZE) {\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t} else {\n\t\tlogical_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread(sb, logical_sb_block))) {\n\t\text4_msg(sb, KERN_ERR, \"unable to read superblock\");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext4 macro-instructions depend on its value\n\t */\n\tes = (struct ext4_super_block *) (((char *)bh->b_data) + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT4_SUPER_MAGIC)\n\t\tgoto cantfind_ext4;\n\tsbi->s_kbytes_written = le64_to_cpu(es->s_kbytes_written);\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tset_opt(sb, INIT_INODE_TABLE);\n\tif (def_mount_opts & EXT4_DEFM_DEBUG)\n\t\tset_opt(sb, DEBUG);\n\tif (def_mount_opts & EXT4_DEFM_BSDGROUPS) {\n\t\text4_msg(sb, KERN_WARNING, deprecated_msg, \"bsdgroups\",\n\t\t\t\"2.6.38\");\n\t\tset_opt(sb, GRPID);\n\t}\n\tif (def_mount_opts & EXT4_DEFM_UID16)\n\t\tset_opt(sb, NO_UID32);\n\t/* xattr user namespace & acls are now defaulted on */\n#ifdef CONFIG_EXT4_FS_XATTR\n\tset_opt(sb, XATTR_USER);\n#endif\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tset_opt(sb, POSIX_ACL);\n#endif\n\tset_opt(sb, MBLK_IO_SUBMIT);\n\tif ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)\n\t\tset_opt(sb, JOURNAL_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)\n\t\tset_opt(sb, ORDERED_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)\n\t\tset_opt(sb, WRITEBACK_DATA);\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_PANIC)\n\t\tset_opt(sb, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_CONTINUE)\n\t\tset_opt(sb, ERRORS_CONT);\n\telse\n\t\tset_opt(sb, ERRORS_RO);\n\tif (def_mount_opts & EXT4_DEFM_BLOCK_VALIDITY)\n\t\tset_opt(sb, BLOCK_VALIDITY);\n\tif (def_mount_opts & EXT4_DEFM_DISCARD)\n\t\tset_opt(sb, DISCARD);\n\n\tsbi->s_resuid = le16_to_cpu(es->s_def_resuid);\n\tsbi->s_resgid = le16_to_cpu(es->s_def_resgid);\n\tsbi->s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ;\n\tsbi->s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;\n\tsbi->s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;\n\n\tif ((def_mount_opts & EXT4_DEFM_NOBARRIER) == 0)\n\t\tset_opt(sb, BARRIER);\n\n\t/*\n\t * enable delayed allocation by default\n\t * Use -o nodelalloc to turn it off\n\t */\n\tif (!IS_EXT3_SB(sb) &&\n\t    ((def_mount_opts & EXT4_DEFM_NODELALLOC) == 0))\n\t\tset_opt(sb, DELALLOC);\n\n\tif (!parse_options((char *) sbi->s_es->s_mount_opts, sb,\n\t\t\t   &journal_devnum, &journal_ioprio, NULL, 0)) {\n\t\text4_msg(sb, KERN_WARNING,\n\t\t\t \"failed to parse options in superblock: %s\",\n\t\t\t sbi->s_es->s_mount_opts);\n\t}\n\tif (!parse_options((char *) data, sb, &journal_devnum,\n\t\t\t   &journal_ioprio, NULL, 0))\n\t\tgoto failed_mount;\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV &&\n\t    (EXT4_HAS_COMPAT_FEATURE(sb, ~0U) ||\n\t     EXT4_HAS_RO_COMPAT_FEATURE(sb, ~0U) ||\n\t     EXT4_HAS_INCOMPAT_FEATURE(sb, ~0U)))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t       \"feature flags set on rev 0 fs, \"\n\t\t       \"running e2fsck is recommended\");\n\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tif (!ext4_feature_set_ok(sb, (sb->s_flags & MS_RDONLY)))\n\t\tgoto failed_mount;\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\n\tif (blocksize < EXT4_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT4_MAX_BLOCK_SIZE) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"Unsupported filesystem blocksize %d\", blocksize);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sb->s_blocksize != blocksize) {\n\t\t/* Validate the filesystem blocksize */\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR, \"bad block size %d\",\n\t\t\t\t\tblocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t\tbh = sb_bread(sb, logical_sb_block);\n\t\tif (!bh) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Can't read superblock on 2nd try\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext4_super_block *)(((char *)bh->b_data) + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT4_SUPER_MAGIC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Magic mismatch, very weird!\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\thas_huge_files = EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\tEXT4_FEATURE_RO_COMPAT_HUGE_FILE);\n\tsbi->s_bitmap_maxbytes = ext4_max_bitmap_size(sb->s_blocksize_bits,\n\t\t\t\t\t\t      has_huge_files);\n\tsb->s_maxbytes = ext4_max_size(sb->s_blocksize_bits, has_huge_files);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported inode size: %d\",\n\t\t\t       sbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE)\n\t\t\tsb->s_time_gran = 1 << (EXT4_EPOCH_BITS - 2);\n\t}\n\n\tsbi->s_desc_size = le16_to_cpu(es->s_desc_size);\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_64BIT)) {\n\t\tif (sbi->s_desc_size < EXT4_MIN_DESC_SIZE_64BIT ||\n\t\t    sbi->s_desc_size > EXT4_MAX_DESC_SIZE ||\n\t\t    !is_power_of_2(sbi->s_desc_size)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported descriptor size %lu\",\n\t\t\t       sbi->s_desc_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else\n\t\tsbi->s_desc_size = EXT4_MIN_DESC_SIZE;\n\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\tif (EXT4_INODE_SIZE(sb) == 0 || EXT4_INODES_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\tsbi->s_inodes_per_block = blocksize / EXT4_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext4;\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / EXT4_DESC_SIZE(sb);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT4_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT4_DESC_PER_BLOCK(sb));\n\n\tfor (i = 0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\ti = le32_to_cpu(es->s_flags);\n\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\tsbi->s_hash_unsigned = 3;\n\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\tes->s_flags |= cpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\tes->s_flags |= cpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t\tsb->s_dirt = 1;\n\t}\n\n\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"#blocks per group too big: %lu\",\n\t\t       sbi->s_blocks_per_group);\n\t\tgoto failed_mount;\n\t}\n\tif (sbi->s_inodes_per_group > blocksize * 8) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"#inodes per group too big: %lu\",\n\t\t       sbi->s_inodes_per_group);\n\t\tgoto failed_mount;\n\t}\n\n\t/*\n\t * Test whether we have more sectors than will fit in sector_t,\n\t * and whether the max offset is addressable by the page cache.\n\t */\n\terr = generic_check_addressable(sb->s_blocksize_bits,\n\t\t\t\t\text4_blocks_count(es));\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"filesystem\"\n\t\t\t \" too large to mount safely on this system\");\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text4_msg(sb, KERN_WARNING, \"CONFIG_LBDAF not enabled\");\n\t\tret = err;\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT4_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\t/* check blocks count against device size */\n\tblocks_count = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\tif (blocks_count && ext4_blocks_count(es) > blocks_count) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: block count %llu \"\n\t\t       \"exceeds size of device (%llu blocks)\",\n\t\t       ext4_blocks_count(es), blocks_count);\n\t\tgoto failed_mount;\n\t}\n\n\t/*\n\t * It makes no sense for the first data block to be beyond the end\n\t * of the filesystem.\n\t */\n\tif (le32_to_cpu(es->s_first_data_block) >= ext4_blocks_count(es)) {\n                ext4_msg(sb, KERN_WARNING, \"bad geometry: first data\"\n\t\t\t \"block %u is beyond end of filesystem (%llu)\",\n\t\t\t le32_to_cpu(es->s_first_data_block),\n\t\t\t ext4_blocks_count(es));\n\t\tgoto failed_mount;\n\t}\n\tblocks_count = (ext4_blocks_count(es) -\n\t\t\tle32_to_cpu(es->s_first_data_block) +\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb) - 1);\n\tdo_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));\n\tif (blocks_count > ((uint64_t)1<<32) - EXT4_DESC_PER_BLOCK(sb)) {\n\t\text4_msg(sb, KERN_WARNING, \"groups count too large: %u \"\n\t\t       \"(block count %llu, first data block %u, \"\n\t\t       \"blocks per group %lu)\", sbi->s_groups_count,\n\t\t       ext4_blocks_count(es),\n\t\t       le32_to_cpu(es->s_first_data_block),\n\t\t       EXT4_BLOCKS_PER_GROUP(sb));\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_groups_count = blocks_count;\n\tsbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,\n\t\t\t(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));\n\tdb_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT4_DESC_PER_BLOCK(sb);\n\tsbi->s_group_desc = kmalloc(db_count * sizeof(struct buffer_head *),\n\t\t\t\t    GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory\");\n\t\tgoto failed_mount;\n\t}\n\n#ifdef CONFIG_PROC_FS\n\tif (ext4_proc_root)\n\t\tsbi->s_proc = proc_mkdir(sb->s_id, ext4_proc_root);\n#endif\n\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logical_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"can't read group descriptor %d\", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext4_check_descriptors(sb, &first_not_zeroed)) {\n\t\text4_msg(sb, KERN_ERR, \"group descriptors corrupted!\");\n\t\tgoto failed_mount2;\n\t}\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_FLEX_BG))\n\t\tif (!ext4_fill_flex_info(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unable to initialize \"\n\t\t\t       \"flex_bg meta info!\");\n\t\t\tgoto failed_mount2;\n\t\t}\n\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\terr = percpu_counter_init(&sbi->s_freeblocks_counter,\n\t\t\text4_count_free_blocks(sb));\n\tif (!err) {\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter,\n\t\t\t\text4_count_free_inodes(sb));\n\t}\n\tif (!err) {\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\text4_count_dirs(sb));\n\t}\n\tif (!err) {\n\t\terr = percpu_counter_init(&sbi->s_dirtyblocks_counter, 0);\n\t}\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"insufficient memory\");\n\t\tgoto failed_mount3;\n\t}\n\n\tsbi->s_stripe = ext4_get_stripe_size(sbi);\n\tsbi->s_max_writeback_mb_bump = 128;\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tif (!test_opt(sb, NOLOAD) &&\n\t    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL))\n\t\tsb->s_op = &ext4_sops;\n\telse\n\t\tsb->s_op = &ext4_nojournal_sops;\n\tsb->s_export_op = &ext4_export_ops;\n\tsb->s_xattr = ext4_xattr_handlers;\n#ifdef CONFIG_QUOTA\n\tsb->s_qcop = &ext4_qctl_operations;\n\tsb->dq_op = &ext4_quota_operations;\n#endif\n\tmemcpy(sb->s_uuid, es->s_uuid, sizeof(es->s_uuid));\n\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\tmutex_init(&sbi->s_orphan_lock);\n\tmutex_init(&sbi->s_resize_lock);\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  EXT4_HAS_INCOMPAT_FEATURE(sb,\n\t\t\t\t    EXT4_FEATURE_INCOMPAT_RECOVER));\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) &&\n\t    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL)) {\n\t\tif (ext4_load_journal(sb, es, journal_devnum))\n\t\t\tgoto failed_mount3;\n\t} else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&\n\t      EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER)) {\n\t\text4_msg(sb, KERN_ERR, \"required journal recovery \"\n\t\t       \"suppressed and not mounted read-only\");\n\t\tgoto failed_mount_wq;\n\t} else {\n\t\tclear_opt(sb, DATA_FLAGS);\n\t\tset_opt(sb, WRITEBACK_DATA);\n\t\tsbi->s_journal = NULL;\n\t\tneeds_recovery = 0;\n\t\tgoto no_journal;\n\t}\n\n\tif (ext4_blocks_count(es) > 0xffffffffULL &&\n\t    !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set 64-bit journal feature\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\tjbd2_journal_set_features(sbi->s_journal,\n\t\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\t} else if (test_opt(sb, JOURNAL_CHECKSUM)) {\n\t\tjbd2_journal_set_features(sbi->s_journal,\n\t\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM, 0, 0);\n\t\tjbd2_journal_clear_features(sbi->s_journal, 0, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\t} else {\n\t\tjbd2_journal_clear_features(sbi->s_journal,\n\t\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n\t\t * capabilities: ORDERED_DATA if the journal can\n\t\t * cope, else JOURNAL_DATA\n\t\t */\n\t\tif (jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sb, ORDERED_DATA);\n\t\telse\n\t\t\tset_opt(sb, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT4_MOUNT_ORDERED_DATA:\n\tcase EXT4_MOUNT_WRITEBACK_DATA:\n\t\tif (!jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Journal does not support \"\n\t\t\t       \"requested data journaling mode\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n\n\t/*\n\t * The journal may have updated the bg summary counts, so we\n\t * need to update the global counters.\n\t */\n\tpercpu_counter_set(&sbi->s_freeblocks_counter,\n\t\t\t   ext4_count_free_blocks(sb));\n\tpercpu_counter_set(&sbi->s_freeinodes_counter,\n\t\t\t   ext4_count_free_inodes(sb));\n\tpercpu_counter_set(&sbi->s_dirs_counter,\n\t\t\t   ext4_count_dirs(sb));\n\tpercpu_counter_set(&sbi->s_dirtyblocks_counter, 0);\n\nno_journal:\n\t/*\n\t * The maximum number of concurrent works can be high and\n\t * concurrency isn't really necessary.  Limit it to 1.\n\t */\n\tEXT4_SB(sb)->dio_unwritten_wq =\n\t\talloc_workqueue(\"ext4-dio-unwritten\", WQ_MEM_RECLAIM | WQ_UNBOUND, 1);\n\tif (!EXT4_SB(sb)->dio_unwritten_wq) {\n\t\tprintk(KERN_ERR \"EXT4-fs: failed to create DIO workqueue\\n\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\t/*\n\t * The jbd2_journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext4_iget(sb, EXT4_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\text4_msg(sb, KERN_ERR, \"get root inode failed\");\n\t\tret = PTR_ERR(root);\n\t\troot = NULL;\n\t\tgoto failed_mount4;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\text4_msg(sb, KERN_ERR, \"corrupt root inode, run e2fsck\");\n\t\tgoto failed_mount4;\n\t}\n\tsb->s_root = d_alloc_root(root);\n\tif (!sb->s_root) {\n\t\text4_msg(sb, KERN_ERR, \"get root dentry failed\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\text4_setup_super(sb, es, sb->s_flags & MS_RDONLY);\n\n\t/* determine the minimum size of new large inodes, if present */\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t       EXT4_FEATURE_RO_COMPAT_EXTRA_ISIZE)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\t/* Check if enough inode space is available */\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO, \"required extra inode space not\"\n\t\t\t \"available\");\n\t}\n\n\tif (test_opt(sb, DELALLOC) &&\n\t    (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)) {\n\t\text4_msg(sb, KERN_WARNING, \"Ignoring delalloc option - \"\n\t\t\t \"requested data journaling mode\");\n\t\tclear_opt(sb, DELALLOC);\n\t}\n\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\t\text4_msg(sb, KERN_WARNING, \"Ignoring dioread_nolock \"\n\t\t\t\t\"option - requested data journaling mode\");\n\t\t\tclear_opt(sb, DIOREAD_NOLOCK);\n\t\t}\n\t\tif (sb->s_blocksize < PAGE_SIZE) {\n\t\t\text4_msg(sb, KERN_WARNING, \"Ignoring dioread_nolock \"\n\t\t\t\t\"option - block size is too small\");\n\t\t\tclear_opt(sb, DIOREAD_NOLOCK);\n\t\t}\n\t}\n\n\terr = ext4_setup_system_zone(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize system \"\n\t\t\t \"zone (%d)\", err);\n\t\tgoto failed_mount4;\n\t}\n\n\text4_ext_init(sb);\n\terr = ext4_mb_init(sb, needs_recovery);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize mballoc (%d)\",\n\t\t\t err);\n\t\tgoto failed_mount4;\n\t}\n\n\terr = ext4_register_li_request(sb, first_not_zeroed);\n\tif (err)\n\t\tgoto failed_mount4;\n\n\tsbi->s_kobj.kset = ext4_kset;\n\tinit_completion(&sbi->s_kobj_unregister);\n\terr = kobject_init_and_add(&sbi->s_kobj, &ext4_ktype, NULL,\n\t\t\t\t   \"%s\", sb->s_id);\n\tif (err) {\n\t\text4_mb_release(sb);\n\t\text4_ext_release(sb);\n\t\tgoto failed_mount4;\n\t};\n\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ORPHAN_FS;\n\text4_orphan_cleanup(sb, es);\n\tEXT4_SB(sb)->s_mount_state &= ~EXT4_ORPHAN_FS;\n\tif (needs_recovery) {\n\t\text4_msg(sb, KERN_INFO, \"recovery complete\");\n\t\text4_mark_recovery_complete(sb, es);\n\t}\n\tif (EXT4_SB(sb)->s_journal) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tdescr = \" journalled data mode\";\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tdescr = \" ordered data mode\";\n\t\telse\n\t\t\tdescr = \" writeback data mode\";\n\t} else\n\t\tdescr = \"out journal\";\n\n\text4_msg(sb, KERN_INFO, \"mounted filesystem with%s. \"\n\t\t \"Opts: %s%s%s\", descr, sbi->s_es->s_mount_opts,\n\t\t *sbi->s_es->s_mount_opts ? \"; \" : \"\", orig_data);\n\n\tinit_timer(&sbi->s_err_report);\n\tsbi->s_err_report.function = print_daily_error_info;\n\tsbi->s_err_report.data = (unsigned long) sb;\n\tif (es->s_error_count)\n\t\tmod_timer(&sbi->s_err_report, jiffies + 300*HZ); /* 5 minutes */\n\n\tkfree(orig_data);\n\treturn 0;\n\ncantfind_ext4:\n\tif (!silent)\n\t\text4_msg(sb, KERN_ERR, \"VFS: Can't find ext4 filesystem\");\n\tgoto failed_mount;\n\nfailed_mount4:\n\tiput(root);\n\tsb->s_root = NULL;\n\text4_msg(sb, KERN_ERR, \"mount failed\");\n\tdestroy_workqueue(EXT4_SB(sb)->dio_unwritten_wq);\nfailed_mount_wq:\n\text4_release_system_zone(sb);\n\tif (sbi->s_journal) {\n\t\tjbd2_journal_destroy(sbi->s_journal);\n\t\tsbi->s_journal = NULL;\n\t}\nfailed_mount3:\n\tif (sbi->s_flex_groups) {\n\t\tif (is_vmalloc_addr(sbi->s_flex_groups))\n\t\t\tvfree(sbi->s_flex_groups);\n\t\telse\n\t\t\tkfree(sbi->s_flex_groups);\n\t}\n\tpercpu_counter_destroy(&sbi->s_freeblocks_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyblocks_counter);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkfree(sbi->s_group_desc);\nfailed_mount:\n\tif (sbi->s_proc) {\n\t\tremove_proc_entry(sb->s_id, ext4_proc_root);\n\t}\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\text4_blkdev_remove(sbi);\n\tbrelse(bh);\nout_fail:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\n\tkfree(sbi);\nout_free_orig:\n\tkfree(orig_data);\n\treturn ret;\n}",
        "start_line": 3015
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "fs/ext4/super.c",
        "method_name": "__acquires",
        "raw_code": "__acquires(bitlock) /* <=== __acquires */ \n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tes->s_last_error_ino = cpu_to_le32(ino);\n\tes->s_last_error_block = cpu_to_le64(block);\n\t__save_error_info(sb, function, line);\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: group %u, \",\n\t       sb->s_id, function, line, grp);\n\tif (ino)\n\t\tprintk(KERN_CONT \"inode %lu: \", ino);\n\tif (block)\n\t\tprintk(KERN_CONT \"block %llu:\", (unsigned long long) block);\n\tprintk(KERN_CONT \"%pV\\n\", &vaf);\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_CONT)) {\n\t\text4_commit_super(sb, 0);\n\t\treturn;\n\t}\n\n\text4_unlock_group(sb, grp);\n\text4_handle_error(sb);\n\t/*\n\t * We only get here in the ERRORS_RO case; relocking the group\n\t * may be dangerous, but nothing bad will happen since the\n\t * filesystem will have already been marked read/only and the\n\t * journal has been aborted.  We return 1 as a hint to callers\n\t * who might what to use the return value from\n\t * ext4_grp_locked_error() to distinguish beween the\n\t * ERRORS_CONT and ERRORS_RO case, and perhaps return more\n\t * aggressively from the ext4 function in question, with a\n\t * more appropriate error code.\n\t */\n\text4_lock_group(sb, grp);\n\treturn;\n}",
        "start_line": 584
      },
      {
        "filename": "fs/ext4/super.c",
        "method_name": "__acquires",
        "raw_code": "\t\t\t\t__acquires(kernel_lock) /* <=== __acquires */ \n{\n\tchar *orig_data = kstrdup(data, GFP_KERNEL);\n\tstruct buffer_head *bh;\n\tstruct ext4_super_block *es = NULL;\n\tstruct ext4_sb_info *sbi;\n\text4_fsblk_t block;\n\text4_fsblk_t sb_block = get_sb_block(&data);\n\text4_fsblk_t logical_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long journal_devnum = 0;\n\tunsigned long def_mount_opts;\n\tstruct inode *root;\n\tchar *cp;\n\tconst char *descr;\n\tint ret = -ENOMEM;\n\tint blocksize;\n\tunsigned int db_count;\n\tunsigned int i;\n\tint needs_recovery, has_huge_files;\n\t__u64 blocks_count;\n\tint err;\n\tunsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;\n\text4_group_t first_not_zeroed;\n\n\tsbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\tif (!sbi)\n\t\tgoto out_free_orig;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock) {\n\t\tkfree(sbi);\n\t\tgoto out_free_orig;\n\t}\n\tsb->s_fs_info = sbi;\n\tsbi->s_mount_opt = 0;\n\tsbi->s_resuid = EXT4_DEF_RESUID;\n\tsbi->s_resgid = EXT4_DEF_RESGID;\n\tsbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;\n\tsbi->s_sb_block = sb_block;\n\tif (sb->s_bdev->bd_part)\n\t\tsbi->s_sectors_written_start =\n\t\t\tpart_stat_read(sb->s_bdev->bd_part, sectors[1]);\n\n\t/* Cleanup superblock name */\n\tfor (cp = sb->s_id; (cp = strchr(cp, '/'));)\n\t\t*cp = '!';\n\n\tret = -EINVAL;\n\tblocksize = sb_min_blocksize(sb, EXT4_MIN_BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text4_msg(sb, KERN_ERR, \"unable to set blocksize\");\n\t\tgoto out_fail;\n\t}\n\n\t/*\n\t * The ext4 superblock will not be buffer aligned for other than 1kB\n\t * block sizes.  We need to calculate the offset from buffer start.\n\t */\n\tif (blocksize != EXT4_MIN_BLOCK_SIZE) {\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t} else {\n\t\tlogical_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread(sb, logical_sb_block))) {\n\t\text4_msg(sb, KERN_ERR, \"unable to read superblock\");\n\t\tgoto out_fail;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext4 macro-instructions depend on its value\n\t */\n\tes = (struct ext4_super_block *) (((char *)bh->b_data) + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\tif (sb->s_magic != EXT4_SUPER_MAGIC)\n\t\tgoto cantfind_ext4;\n\tsbi->s_kbytes_written = le64_to_cpu(es->s_kbytes_written);\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tset_opt(sb, INIT_INODE_TABLE);\n\tif (def_mount_opts & EXT4_DEFM_DEBUG)\n\t\tset_opt(sb, DEBUG);\n\tif (def_mount_opts & EXT4_DEFM_BSDGROUPS) {\n\t\text4_msg(sb, KERN_WARNING, deprecated_msg, \"bsdgroups\",\n\t\t\t\"2.6.38\");\n\t\tset_opt(sb, GRPID);\n\t}\n\tif (def_mount_opts & EXT4_DEFM_UID16)\n\t\tset_opt(sb, NO_UID32);\n\t/* xattr user namespace & acls are now defaulted on */\n#ifdef CONFIG_EXT4_FS_XATTR\n\tset_opt(sb, XATTR_USER);\n#endif\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\tset_opt(sb, POSIX_ACL);\n#endif\n\tset_opt(sb, MBLK_IO_SUBMIT);\n\tif ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)\n\t\tset_opt(sb, JOURNAL_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)\n\t\tset_opt(sb, ORDERED_DATA);\n\telse if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)\n\t\tset_opt(sb, WRITEBACK_DATA);\n\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_PANIC)\n\t\tset_opt(sb, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_CONTINUE)\n\t\tset_opt(sb, ERRORS_CONT);\n\telse\n\t\tset_opt(sb, ERRORS_RO);\n\tif (def_mount_opts & EXT4_DEFM_BLOCK_VALIDITY)\n\t\tset_opt(sb, BLOCK_VALIDITY);\n\tif (def_mount_opts & EXT4_DEFM_DISCARD)\n\t\tset_opt(sb, DISCARD);\n\n\tsbi->s_resuid = le16_to_cpu(es->s_def_resuid);\n\tsbi->s_resgid = le16_to_cpu(es->s_def_resgid);\n\tsbi->s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ;\n\tsbi->s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;\n\tsbi->s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;\n\n\tif ((def_mount_opts & EXT4_DEFM_NOBARRIER) == 0)\n\t\tset_opt(sb, BARRIER);\n\n\t/*\n\t * enable delayed allocation by default\n\t * Use -o nodelalloc to turn it off\n\t */\n\tif (!IS_EXT3_SB(sb) &&\n\t    ((def_mount_opts & EXT4_DEFM_NODELALLOC) == 0))\n\t\tset_opt(sb, DELALLOC);\n\n\tif (!parse_options((char *) sbi->s_es->s_mount_opts, sb,\n\t\t\t   &journal_devnum, &journal_ioprio, NULL, 0)) {\n\t\text4_msg(sb, KERN_WARNING,\n\t\t\t \"failed to parse options in superblock: %s\",\n\t\t\t sbi->s_es->s_mount_opts);\n\t}\n\tif (!parse_options((char *) data, sb, &journal_devnum,\n\t\t\t   &journal_ioprio, NULL, 0))\n\t\tgoto failed_mount;\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV &&\n\t    (EXT4_HAS_COMPAT_FEATURE(sb, ~0U) ||\n\t     EXT4_HAS_RO_COMPAT_FEATURE(sb, ~0U) ||\n\t     EXT4_HAS_INCOMPAT_FEATURE(sb, ~0U)))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t       \"feature flags set on rev 0 fs, \"\n\t\t       \"running e2fsck is recommended\");\n\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tif (!ext4_feature_set_ok(sb, (sb->s_flags & MS_RDONLY)))\n\t\tgoto failed_mount;\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n\n\tif (blocksize < EXT4_MIN_BLOCK_SIZE ||\n\t    blocksize > EXT4_MAX_BLOCK_SIZE) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"Unsupported filesystem blocksize %d\", blocksize);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sb->s_blocksize != blocksize) {\n\t\t/* Validate the filesystem blocksize */\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR, \"bad block size %d\",\n\t\t\t\t\tblocksize);\n\t\t\tgoto failed_mount;\n\t\t}\n\n\t\tbrelse(bh);\n\t\tlogical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;\n\t\toffset = do_div(logical_sb_block, blocksize);\n\t\tbh = sb_bread(sb, logical_sb_block);\n\t\tif (!bh) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Can't read superblock on 2nd try\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tes = (struct ext4_super_block *)(((char *)bh->b_data) + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT4_SUPER_MAGIC)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Magic mismatch, very weird!\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\thas_huge_files = EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\tEXT4_FEATURE_RO_COMPAT_HUGE_FILE);\n\tsbi->s_bitmap_maxbytes = ext4_max_bitmap_size(sb->s_blocksize_bits,\n\t\t\t\t\t\t      has_huge_files);\n\tsb->s_maxbytes = ext4_max_size(sb->s_blocksize_bits, has_huge_files);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||\n\t\t    (!is_power_of_2(sbi->s_inode_size)) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported inode size: %d\",\n\t\t\t       sbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE)\n\t\t\tsb->s_time_gran = 1 << (EXT4_EPOCH_BITS - 2);\n\t}\n\n\tsbi->s_desc_size = le16_to_cpu(es->s_desc_size);\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_64BIT)) {\n\t\tif (sbi->s_desc_size < EXT4_MIN_DESC_SIZE_64BIT ||\n\t\t    sbi->s_desc_size > EXT4_MAX_DESC_SIZE ||\n\t\t    !is_power_of_2(sbi->s_desc_size)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unsupported descriptor size %lu\",\n\t\t\t       sbi->s_desc_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t} else\n\t\tsbi->s_desc_size = EXT4_MIN_DESC_SIZE;\n\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\tif (EXT4_INODE_SIZE(sb) == 0 || EXT4_INODES_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\tsbi->s_inodes_per_block = blocksize / EXT4_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0)\n\t\tgoto cantfind_ext4;\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = blocksize / EXT4_DESC_SIZE(sb);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits = ilog2(EXT4_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits = ilog2(EXT4_DESC_PER_BLOCK(sb));\n\n\tfor (i = 0; i < 4; i++)\n\t\tsbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n\tsbi->s_def_hash_version = es->s_def_hash_version;\n\ti = le32_to_cpu(es->s_flags);\n\tif (i & EXT2_FLAGS_UNSIGNED_HASH)\n\t\tsbi->s_hash_unsigned = 3;\n\telse if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n\t\tes->s_flags |= cpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n\t\tsbi->s_hash_unsigned = 3;\n#else\n\t\tes->s_flags |= cpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n\t\tsb->s_dirt = 1;\n\t}\n\n\tif (sbi->s_blocks_per_group > blocksize * 8) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"#blocks per group too big: %lu\",\n\t\t       sbi->s_blocks_per_group);\n\t\tgoto failed_mount;\n\t}\n\tif (sbi->s_inodes_per_group > blocksize * 8) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t       \"#inodes per group too big: %lu\",\n\t\t       sbi->s_inodes_per_group);\n\t\tgoto failed_mount;\n\t}\n\n\t/*\n\t * Test whether we have more sectors than will fit in sector_t,\n\t * and whether the max offset is addressable by the page cache.\n\t */\n\terr = generic_check_addressable(sb->s_blocksize_bits,\n\t\t\t\t\text4_blocks_count(es));\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"filesystem\"\n\t\t\t \" too large to mount safely on this system\");\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text4_msg(sb, KERN_WARNING, \"CONFIG_LBDAF not enabled\");\n\t\tret = err;\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT4_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext4;\n\n\t/* check blocks count against device size */\n\tblocks_count = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;\n\tif (blocks_count && ext4_blocks_count(es) > blocks_count) {\n\t\text4_msg(sb, KERN_WARNING, \"bad geometry: block count %llu \"\n\t\t       \"exceeds size of device (%llu blocks)\",\n\t\t       ext4_blocks_count(es), blocks_count);\n\t\tgoto failed_mount;\n\t}\n\n\t/*\n\t * It makes no sense for the first data block to be beyond the end\n\t * of the filesystem.\n\t */\n\tif (le32_to_cpu(es->s_first_data_block) >= ext4_blocks_count(es)) {\n                ext4_msg(sb, KERN_WARNING, \"bad geometry: first data\"\n\t\t\t \"block %u is beyond end of filesystem (%llu)\",\n\t\t\t le32_to_cpu(es->s_first_data_block),\n\t\t\t ext4_blocks_count(es));\n\t\tgoto failed_mount;\n\t}\n\tblocks_count = (ext4_blocks_count(es) -\n\t\t\tle32_to_cpu(es->s_first_data_block) +\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb) - 1);\n\tdo_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));\n\tif (blocks_count > ((uint64_t)1<<32) - EXT4_DESC_PER_BLOCK(sb)) {\n\t\text4_msg(sb, KERN_WARNING, \"groups count too large: %u \"\n\t\t       \"(block count %llu, first data block %u, \"\n\t\t       \"blocks per group %lu)\", sbi->s_groups_count,\n\t\t       ext4_blocks_count(es),\n\t\t       le32_to_cpu(es->s_first_data_block),\n\t\t       EXT4_BLOCKS_PER_GROUP(sb));\n\t\tgoto failed_mount;\n\t}\n\tsbi->s_groups_count = blocks_count;\n\tsbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,\n\t\t\t(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));\n\tdb_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT4_DESC_PER_BLOCK(sb);\n\tsbi->s_group_desc = kmalloc(db_count * sizeof(struct buffer_head *),\n\t\t\t\t    GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory\");\n\t\tgoto failed_mount;\n\t}\n\n#ifdef CONFIG_PROC_FS\n\tif (ext4_proc_root)\n\t\tsbi->s_proc = proc_mkdir(sb->s_id, ext4_proc_root);\n#endif\n\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logical_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"can't read group descriptor %d\", i);\n\t\t\tdb_count = i;\n\t\t\tgoto failed_mount2;\n\t\t}\n\t}\n\tif (!ext4_check_descriptors(sb, &first_not_zeroed)) {\n\t\text4_msg(sb, KERN_ERR, \"group descriptors corrupted!\");\n\t\tgoto failed_mount2;\n\t}\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_FLEX_BG))\n\t\tif (!ext4_fill_flex_info(sb)) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"unable to initialize \"\n\t\t\t       \"flex_bg meta info!\");\n\t\t\tgoto failed_mount2;\n\t\t}\n\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\tinit_timer(&sbi->s_err_report);\n\tsbi->s_err_report.function = print_daily_error_info;\n\tsbi->s_err_report.data = (unsigned long) sb;\n\n\terr = percpu_counter_init(&sbi->s_freeblocks_counter,\n\t\t\text4_count_free_blocks(sb));\n\tif (!err) {\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter,\n\t\t\t\text4_count_free_inodes(sb));\n\t}\n\tif (!err) {\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\text4_count_dirs(sb));\n\t}\n\tif (!err) {\n\t\terr = percpu_counter_init(&sbi->s_dirtyblocks_counter, 0);\n\t}\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"insufficient memory\");\n\t\tgoto failed_mount3;\n\t}\n\n\tsbi->s_stripe = ext4_get_stripe_size(sbi);\n\tsbi->s_max_writeback_mb_bump = 128;\n\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tif (!test_opt(sb, NOLOAD) &&\n\t    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL))\n\t\tsb->s_op = &ext4_sops;\n\telse\n\t\tsb->s_op = &ext4_nojournal_sops;\n\tsb->s_export_op = &ext4_export_ops;\n\tsb->s_xattr = ext4_xattr_handlers;\n#ifdef CONFIG_QUOTA\n\tsb->s_qcop = &ext4_qctl_operations;\n\tsb->dq_op = &ext4_quota_operations;\n#endif\n\tmemcpy(sb->s_uuid, es->s_uuid, sizeof(es->s_uuid));\n\n\tINIT_LIST_HEAD(&sbi->s_orphan); /* unlinked but open files */\n\tmutex_init(&sbi->s_orphan_lock);\n\tmutex_init(&sbi->s_resize_lock);\n\n\tsb->s_root = NULL;\n\n\tneeds_recovery = (es->s_last_orphan != 0 ||\n\t\t\t  EXT4_HAS_INCOMPAT_FEATURE(sb,\n\t\t\t\t    EXT4_FEATURE_INCOMPAT_RECOVER));\n\n\t/*\n\t * The first inode we look at is the journal inode.  Don't try\n\t * root first: it may be modified in the journal!\n\t */\n\tif (!test_opt(sb, NOLOAD) &&\n\t    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL)) {\n\t\tif (ext4_load_journal(sb, es, journal_devnum))\n\t\t\tgoto failed_mount3;\n\t} else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&\n\t      EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER)) {\n\t\text4_msg(sb, KERN_ERR, \"required journal recovery \"\n\t\t       \"suppressed and not mounted read-only\");\n\t\tgoto failed_mount_wq;\n\t} else {\n\t\tclear_opt(sb, DATA_FLAGS);\n\t\tset_opt(sb, WRITEBACK_DATA);\n\t\tsbi->s_journal = NULL;\n\t\tneeds_recovery = 0;\n\t\tgoto no_journal;\n\t}\n\n\tif (ext4_blocks_count(es) > 0xffffffffULL &&\n\t    !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_64BIT)) {\n\t\text4_msg(sb, KERN_ERR, \"Failed to set 64-bit journal feature\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\tif (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {\n\t\tjbd2_journal_set_features(sbi->s_journal,\n\t\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\t} else if (test_opt(sb, JOURNAL_CHECKSUM)) {\n\t\tjbd2_journal_set_features(sbi->s_journal,\n\t\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM, 0, 0);\n\t\tjbd2_journal_clear_features(sbi->s_journal, 0, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\t} else {\n\t\tjbd2_journal_clear_features(sbi->s_journal,\n\t\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM, 0,\n\t\t\t\tJBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);\n\t}\n\n\t/* We have now updated the journal if required, so we can\n\t * validate the data journaling mode. */\n\tswitch (test_opt(sb, DATA_FLAGS)) {\n\tcase 0:\n\t\t/* No mode set, assume a default based on the journal\n\t\t * capabilities: ORDERED_DATA if the journal can\n\t\t * cope, else JOURNAL_DATA\n\t\t */\n\t\tif (jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE))\n\t\t\tset_opt(sb, ORDERED_DATA);\n\t\telse\n\t\t\tset_opt(sb, JOURNAL_DATA);\n\t\tbreak;\n\n\tcase EXT4_MOUNT_ORDERED_DATA:\n\tcase EXT4_MOUNT_WRITEBACK_DATA:\n\t\tif (!jbd2_journal_check_available_features\n\t\t    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Journal does not support \"\n\t\t\t       \"requested data journaling mode\");\n\t\t\tgoto failed_mount_wq;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tset_task_ioprio(sbi->s_journal->j_task, journal_ioprio);\n\n\t/*\n\t * The journal may have updated the bg summary counts, so we\n\t * need to update the global counters.\n\t */\n\tpercpu_counter_set(&sbi->s_freeblocks_counter,\n\t\t\t   ext4_count_free_blocks(sb));\n\tpercpu_counter_set(&sbi->s_freeinodes_counter,\n\t\t\t   ext4_count_free_inodes(sb));\n\tpercpu_counter_set(&sbi->s_dirs_counter,\n\t\t\t   ext4_count_dirs(sb));\n\tpercpu_counter_set(&sbi->s_dirtyblocks_counter, 0);\n\nno_journal:\n\t/*\n\t * The maximum number of concurrent works can be high and\n\t * concurrency isn't really necessary.  Limit it to 1.\n\t */\n\tEXT4_SB(sb)->dio_unwritten_wq =\n\t\talloc_workqueue(\"ext4-dio-unwritten\", WQ_MEM_RECLAIM | WQ_UNBOUND, 1);\n\tif (!EXT4_SB(sb)->dio_unwritten_wq) {\n\t\tprintk(KERN_ERR \"EXT4-fs: failed to create DIO workqueue\\n\");\n\t\tgoto failed_mount_wq;\n\t}\n\n\t/*\n\t * The jbd2_journal_load will have done any necessary log recovery,\n\t * so we can safely mount the rest of the filesystem now.\n\t */\n\n\troot = ext4_iget(sb, EXT4_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\text4_msg(sb, KERN_ERR, \"get root inode failed\");\n\t\tret = PTR_ERR(root);\n\t\troot = NULL;\n\t\tgoto failed_mount4;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\text4_msg(sb, KERN_ERR, \"corrupt root inode, run e2fsck\");\n\t\tgoto failed_mount4;\n\t}\n\tsb->s_root = d_alloc_root(root);\n\tif (!sb->s_root) {\n\t\text4_msg(sb, KERN_ERR, \"get root dentry failed\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount4;\n\t}\n\n\text4_setup_super(sb, es, sb->s_flags & MS_RDONLY);\n\n\t/* determine the minimum size of new large inodes, if present */\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t       EXT4_FEATURE_RO_COMPAT_EXTRA_ISIZE)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\t/* Check if enough inode space is available */\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO, \"required extra inode space not\"\n\t\t\t \"available\");\n\t}\n\n\tif (test_opt(sb, DELALLOC) &&\n\t    (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)) {\n\t\text4_msg(sb, KERN_WARNING, \"Ignoring delalloc option - \"\n\t\t\t \"requested data journaling mode\");\n\t\tclear_opt(sb, DELALLOC);\n\t}\n\tif (test_opt(sb, DIOREAD_NOLOCK)) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {\n\t\t\text4_msg(sb, KERN_WARNING, \"Ignoring dioread_nolock \"\n\t\t\t\t\"option - requested data journaling mode\");\n\t\t\tclear_opt(sb, DIOREAD_NOLOCK);\n\t\t}\n\t\tif (sb->s_blocksize < PAGE_SIZE) {\n\t\t\text4_msg(sb, KERN_WARNING, \"Ignoring dioread_nolock \"\n\t\t\t\t\"option - block size is too small\");\n\t\t\tclear_opt(sb, DIOREAD_NOLOCK);\n\t\t}\n\t}\n\n\terr = ext4_setup_system_zone(sb);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize system \"\n\t\t\t \"zone (%d)\", err);\n\t\tgoto failed_mount4;\n\t}\n\n\text4_ext_init(sb);\n\terr = ext4_mb_init(sb, needs_recovery);\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"failed to initialize mballoc (%d)\",\n\t\t\t err);\n\t\tgoto failed_mount4;\n\t}\n\n\terr = ext4_register_li_request(sb, first_not_zeroed);\n\tif (err)\n\t\tgoto failed_mount4;\n\n\tsbi->s_kobj.kset = ext4_kset;\n\tinit_completion(&sbi->s_kobj_unregister);\n\terr = kobject_init_and_add(&sbi->s_kobj, &ext4_ktype, NULL,\n\t\t\t\t   \"%s\", sb->s_id);\n\tif (err) {\n\t\text4_mb_release(sb);\n\t\text4_ext_release(sb);\n\t\tgoto failed_mount4;\n\t};\n\n\tEXT4_SB(sb)->s_mount_state |= EXT4_ORPHAN_FS;\n\text4_orphan_cleanup(sb, es);\n\tEXT4_SB(sb)->s_mount_state &= ~EXT4_ORPHAN_FS;\n\tif (needs_recovery) {\n\t\text4_msg(sb, KERN_INFO, \"recovery complete\");\n\t\text4_mark_recovery_complete(sb, es);\n\t}\n\tif (EXT4_SB(sb)->s_journal) {\n\t\tif (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)\n\t\t\tdescr = \" journalled data mode\";\n\t\telse if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)\n\t\t\tdescr = \" ordered data mode\";\n\t\telse\n\t\t\tdescr = \" writeback data mode\";\n\t} else\n\t\tdescr = \"out journal\";\n\n\text4_msg(sb, KERN_INFO, \"mounted filesystem with%s. \"\n\t\t \"Opts: %s%s%s\", descr, sbi->s_es->s_mount_opts,\n\t\t *sbi->s_es->s_mount_opts ? \"; \" : \"\", orig_data);\n\n\tif (es->s_error_count)\n\t\tmod_timer(&sbi->s_err_report, jiffies + 300*HZ); /* 5 minutes */\n\n\tkfree(orig_data);\n\treturn 0;\n\ncantfind_ext4:\n\tif (!silent)\n\t\text4_msg(sb, KERN_ERR, \"VFS: Can't find ext4 filesystem\");\n\tgoto failed_mount;\n\nfailed_mount4:\n\tiput(root);\n\tsb->s_root = NULL;\n\text4_msg(sb, KERN_ERR, \"mount failed\");\n\tdestroy_workqueue(EXT4_SB(sb)->dio_unwritten_wq);\nfailed_mount_wq:\n\text4_release_system_zone(sb);\n\tif (sbi->s_journal) {\n\t\tjbd2_journal_destroy(sbi->s_journal);\n\t\tsbi->s_journal = NULL;\n\t}\nfailed_mount3:\n\tdel_timer(&sbi->s_err_report);\n\tif (sbi->s_flex_groups) {\n\t\tif (is_vmalloc_addr(sbi->s_flex_groups))\n\t\t\tvfree(sbi->s_flex_groups);\n\t\telse\n\t\t\tkfree(sbi->s_flex_groups);\n\t}\n\tpercpu_counter_destroy(&sbi->s_freeblocks_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tpercpu_counter_destroy(&sbi->s_dirtyblocks_counter);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\n\tkfree(sbi->s_group_desc);\nfailed_mount:\n\tif (sbi->s_proc) {\n\t\tremove_proc_entry(sb->s_id, ext4_proc_root);\n\t}\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\text4_blkdev_remove(sbi);\n\tbrelse(bh);\nout_fail:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\n\tkfree(sbi);\nout_free_orig:\n\tkfree(orig_data);\n\treturn ret;\n}",
        "start_line": 3015
      }
    ],
    "code_context": "Called Methods:\n- EXT4_MIN_BLOCK_SIZE: #define EXT4_MIN_BLOCK_SIZE\t\t1024 /* <=== fs/ext4/ext4.h:228:228:EXT4_MIN_BLOCK_SIZE:0 */ \n- ext4_setup_super: static int ext4_setup_super(struct super_block *sb, struct ext4_super_block *es, /* <=== ext4_setup_super */ \n\t\t\t    int read_only)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tint res = 0;\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT4_MAX_SUPP_REV) {\n\t\text4_msg(sb, KERN_ERR, \"revision level too high, \"\n\t\t\t \"forcing read-only mode\");\n\t\tres = MS_RDONLY;\n\t}\n\tif (read_only)\n\t\treturn res;\n\tif (!(sbi->s_mount_state & EXT4_VALID_FS))\n\t\text4_msg(sb, KERN_WARNING, \"warning: mounting unchecked fs, \"\n\t\t\t \"running e2fsck is recommended\");\n\telse if ((sbi->s_mount_state & EXT4_ERROR_FS))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t\t \"warning: mounting fs with errors, \"\n\t\t\t \"running e2fsck is recommended\");\n\telse if ((__s16) le16_to_cpu(es->s_max_mnt_count) >= 0 &&\n\t\t le16_to_cpu(es->s_mnt_count) >=\n\t\t (unsigned short) (__s16) le16_to_cpu(es->s_max_mnt_count))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t\t \"warning: maximal mount count reached, \"\n\t\t\t \"running e2fsck is recommended\");\n\telse if (le32_to_cpu(es->s_checkinterval) &&\n\t\t(le32_to_cpu(es->s_lastcheck) +\n\t\t\tle32_to_cpu(es->s_checkinterval) <= get_seconds()))\n\t\text4_msg(sb, KERN_WARNING,\n\t\t\t \"warning: checktime reached, \"\n\t\t\t \"running e2fsck is recommended\");\n\tif (!sbi->s_journal)\n\t\tes->s_state &= cpu_to_le16(~EXT4_VALID_FS);\n\tif (!(__s16) le16_to_cpu(es->s_max_mnt_count))\n\t\tes->s_max_mnt_count = cpu_to_le16(EXT4_DFL_MAX_MNT_COUNT);\n\tle16_add_cpu(&es->s_mnt_count, 1);\n\tes->s_mtime = cpu_to_le32(get_seconds());\n\text4_update_dynamic_rev(sb);\n\tif (sbi->s_journal)\n\t\tEXT4_SET_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER);\n\n\text4_commit_super(sb, 1);\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_INFO \"[EXT4 FS bs=%lu, gc=%u, \"\n\t\t\t\t\"bpg=%lu, ipg=%lu, mo=%04x, mo2=%04x]\\n\",\n\t\t\tsb->s_blocksize,\n\t\t\tsbi->s_groups_count,\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb),\n\t\t\tEXT4_INODES_PER_GROUP(sb),\n\t\t\tsbi->s_mount_opt, sbi->s_mount_opt2);\n\n\treturn res;\n}\n- ext4_get_journal: static journal_t *ext4_get_journal(struct super_block *sb, /* <=== ext4_get_journal */ \n\t\t\t\t   unsigned int journal_inum)\n{\n\tstruct inode *journal_inode;\n\tjournal_t *journal;\n\n\tBUG_ON(!EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL));\n\n\t/* First, test for the existence of a valid inode on disk.  Bad\n\t * things happen if we iget() an unused inode, as the subsequent\n\t * iput() will try to delete it. */\n\n\tjournal_inode = ext4_iget(sb, journal_inum);\n\tif (IS_ERR(journal_inode)) {\n\t\text4_msg(sb, KERN_ERR, \"no journal found\");\n\t\treturn NULL;\n\t}\n\tif (!journal_inode->i_nlink) {\n\t\tmake_bad_inode(journal_inode);\n\t\tiput(journal_inode);\n\t\text4_msg(sb, KERN_ERR, \"journal inode is deleted\");\n\t\treturn NULL;\n\t}\n\n\tjbd_debug(2, \"Journal inode found at %p: %lld bytes\\n\",\n\t\t  journal_inode, journal_inode->i_size);\n\tif (!S_ISREG(journal_inode->i_mode)) {\n\t\text4_msg(sb, KERN_ERR, \"invalid journal inode\");\n\t\tiput(journal_inode);\n\t\treturn NULL;\n\t}\n\n\tjournal = jbd2_journal_init_inode(journal_inode);\n\tif (!journal) {\n\t\text4_msg(sb, KERN_ERR, \"Could not load journal inode\");\n\t\tiput(journal_inode);\n\t\treturn NULL;\n\t}\n\tjournal->j_private = sb;\n\text4_init_journal_params(sb, journal);\n\treturn journal;\n}\n- ext4_commit_super: static int ext4_commit_super(struct super_block *sb, int sync) /* <=== ext4_commit_super */ \n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\tstruct buffer_head *sbh = EXT4_SB(sb)->s_sbh;\n\tint error = 0;\n\n\tif (!sbh)\n\t\treturn error;\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text4_msg(sb, KERN_ERR, \"previous I/O error to \"\n\t\t       \"superblock detected\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n\t/*\n\t * If the file system is mounted read-only, don't update the\n\t * superblock write time.  This avoids updating the superblock\n\t * write time when we are mounting the root file system\n\t * read/only but we need to replay the journal; at that point,\n\t * for people who are east of GMT and who make their clock\n\t * tick in localtime for Windows bug-for-bug compatibility,\n\t * the clock is set in the future, and this will cause e2fsck\n\t * to complain and force a full file system check.\n\t */\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tes->s_wtime = cpu_to_le32(get_seconds());\n\tif (sb->s_bdev->bd_part)\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written +\n\t\t\t    ((part_stat_read(sb->s_bdev->bd_part, sectors[1]) -\n\t\t\t      EXT4_SB(sb)->s_sectors_written_start) >> 1));\n\telse\n\t\tes->s_kbytes_written =\n\t\t\tcpu_to_le64(EXT4_SB(sb)->s_kbytes_written);\n\text4_free_blocks_count_set(es, percpu_counter_sum_positive(\n\t\t\t\t\t   &EXT4_SB(sb)->s_freeblocks_counter));\n\tes->s_free_inodes_count =\n\t\tcpu_to_le32(percpu_counter_sum_positive(\n\t\t\t\t&EXT4_SB(sb)->s_freeinodes_counter));\n\tsb->s_dirt = 0;\n\tBUFFER_TRACE(sbh, \"marking dirty\");\n\tmark_buffer_dirty(sbh);\n\tif (sync) {\n\t\terror = sync_dirty_buffer(sbh);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = buffer_write_io_error(sbh);\n\t\tif (error) {\n\t\t\text4_msg(sb, KERN_ERR, \"I/O error while writing \"\n\t\t\t       \"superblock\");\n\t\t\tclear_buffer_write_io_error(sbh);\n\t\t\tset_buffer_uptodate(sbh);\n\t\t}\n\t}\n\treturn error;\n}\n- ext4_inode_table: ext4_fsblk_t ext4_inode_table(struct super_block *sb, /* <=== ext4_inode_table */ \n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_table_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_table_hi) << 32 : 0);\n}\n- ext4_msg: void ext4_msg(struct super_block *sb, const char *prefix, const char *fmt, ...) /* <=== ext4_msg */ \n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}\n- parse_options: static int parse_options(char *options, struct super_block *sb, /* <=== parse_options */ \n\t\t\t unsigned long *journal_devnum,\n\t\t\t unsigned int *journal_ioprio,\n\t\t\t ext4_fsblk_t *n_blocks_count, int is_remount)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint data_opt = 0;\n\tint option;\n#ifdef CONFIG_QUOTA\n\tint qfmt;\n#endif\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Initialize args struct so we know whether arg was\n\t\t * found; some options take optional arguments.\n\t\t */\n\t\targs[0].to = args[0].from = NULL;\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_bsd_df:\n\t\t\text4_msg(sb, KERN_WARNING, deprecated_msg, p, \"2.6.38\");\n\t\t\tclear_opt(sb, MINIX_DF);\n\t\t\tbreak;\n\t\tcase Opt_minix_df:\n\t\t\text4_msg(sb, KERN_WARNING, deprecated_msg, p, \"2.6.38\");\n\t\t\tset_opt(sb, MINIX_DF);\n\n\t\t\tbreak;\n\t\tcase Opt_grpid:\n\t\t\text4_msg(sb, KERN_WARNING, deprecated_msg, p, \"2.6.38\");\n\t\t\tset_opt(sb, GRPID);\n\n\t\t\tbreak;\n\t\tcase Opt_nogrpid:\n\t\t\text4_msg(sb, KERN_WARNING, deprecated_msg, p, \"2.6.38\");\n\t\t\tclear_opt(sb, GRPID);\n\n\t\t\tbreak;\n\t\tcase Opt_resuid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tsbi->s_resuid = option;\n\t\t\tbreak;\n\t\tcase Opt_resgid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tsbi->s_resgid = option;\n\t\t\tbreak;\n\t\tcase Opt_sb:\n\t\t\t/* handled by get_sb_block() instead of here */\n\t\t\t/* *sb_block = match_int(&args[0]); */\n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\tclear_opt(sb, ERRORS_CONT);\n\t\t\tclear_opt(sb, ERRORS_RO);\n\t\t\tset_opt(sb, ERRORS_PANIC);\n\t\t\tbreak;\n\t\tcase Opt_err_ro:\n\t\t\tclear_opt(sb, ERRORS_CONT);\n\t\t\tclear_opt(sb, ERRORS_PANIC);\n\t\t\tset_opt(sb, ERRORS_RO);\n\t\t\tbreak;\n\t\tcase Opt_err_cont:\n\t\t\tclear_opt(sb, ERRORS_RO);\n\t\t\tclear_opt(sb, ERRORS_PANIC);\n\t\t\tset_opt(sb, ERRORS_CONT);\n\t\t\tbreak;\n\t\tcase Opt_nouid32:\n\t\t\tset_opt(sb, NO_UID32);\n\t\t\tbreak;\n\t\tcase Opt_debug:\n\t\t\tset_opt(sb, DEBUG);\n\t\t\tbreak;\n\t\tcase Opt_oldalloc:\n\t\t\tset_opt(sb, OLDALLOC);\n\t\t\tbreak;\n\t\tcase Opt_orlov:\n\t\t\tclear_opt(sb, OLDALLOC);\n\t\t\tbreak;\n#ifdef CONFIG_EXT4_FS_XATTR\n\t\tcase Opt_user_xattr:\n\t\t\tset_opt(sb, XATTR_USER);\n\t\t\tbreak;\n\t\tcase Opt_nouser_xattr:\n\t\t\tclear_opt(sb, XATTR_USER);\n\t\t\tbreak;\n#else\n\t\tcase Opt_user_xattr:\n\t\tcase Opt_nouser_xattr:\n\t\t\text4_msg(sb, KERN_ERR, \"(no)user_xattr options not supported\");\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\t\tcase Opt_acl:\n\t\t\tset_opt(sb, POSIX_ACL);\n\t\t\tbreak;\n\t\tcase Opt_noacl:\n\t\t\tclear_opt(sb, POSIX_ACL);\n\t\t\tbreak;\n#else\n\t\tcase Opt_acl:\n\t\tcase Opt_noacl:\n\t\t\text4_msg(sb, KERN_ERR, \"(no)acl options not supported\");\n\t\t\tbreak;\n#endif\n\t\tcase Opt_journal_update:\n\t\t\t/* @@@ FIXME */\n\t\t\t/* Eventually we will want to be able to create\n\t\t\t   a journal file here.  For now, only allow the\n\t\t\t   user to specify an existing inode to be the\n\t\t\t   journal file. */\n\t\t\tif (is_remount) {\n\t\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t\t \"Cannot specify journal on remount\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tset_opt(sb, UPDATE_JOURNAL);\n\t\t\tbreak;\n\t\tcase Opt_journal_dev:\n\t\t\tif (is_remount) {\n\t\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t\t\"Cannot specify journal on remount\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\t*journal_devnum = option;\n\t\t\tbreak;\n\t\tcase Opt_journal_checksum:\n\t\t\tset_opt(sb, JOURNAL_CHECKSUM);\n\t\t\tbreak;\n\t\tcase Opt_journal_async_commit:\n\t\t\tset_opt(sb, JOURNAL_ASYNC_COMMIT);\n\t\t\tset_opt(sb, JOURNAL_CHECKSUM);\n\t\t\tbreak;\n\t\tcase Opt_noload:\n\t\t\tset_opt(sb, NOLOAD);\n\t\t\tbreak;\n\t\tcase Opt_commit:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tif (option < 0)\n\t\t\t\treturn 0;\n\t\t\tif (option == 0)\n\t\t\t\toption = JBD2_DEFAULT_MAX_COMMIT_AGE;\n\t\t\tsbi->s_commit_interval = HZ * option;\n\t\t\tbreak;\n\t\tcase Opt_max_batch_time:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tif (option < 0)\n\t\t\t\treturn 0;\n\t\t\tif (option == 0)\n\t\t\t\toption = EXT4_DEF_MAX_BATCH_TIME;\n\t\t\tsbi->s_max_batch_time = option;\n\t\t\tbreak;\n\t\tcase Opt_min_batch_time:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tif (option < 0)\n\t\t\t\treturn 0;\n\t\t\tsbi->s_min_batch_time = option;\n\t\t\tbreak;\n\t\tcase Opt_data_journal:\n\t\t\tdata_opt = EXT4_MOUNT_JOURNAL_DATA;\n\t\t\tgoto datacheck;\n\t\tcase Opt_data_ordered:\n\t\t\tdata_opt = EXT4_MOUNT_ORDERED_DATA;\n\t\t\tgoto datacheck;\n\t\tcase Opt_data_writeback:\n\t\t\tdata_opt = EXT4_MOUNT_WRITEBACK_DATA;\n\t\tdatacheck:\n\t\t\tif (is_remount) {\n\t\t\t\tif (test_opt(sb, DATA_FLAGS) != data_opt) {\n\t\t\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t\t\t\"Cannot change data mode on remount\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tclear_opt(sb, DATA_FLAGS);\n\t\t\t\tsbi->s_mount_opt |= data_opt;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_data_err_abort:\n\t\t\tset_opt(sb, DATA_ERR_ABORT);\n\t\t\tbreak;\n\t\tcase Opt_data_err_ignore:\n\t\t\tclear_opt(sb, DATA_ERR_ABORT);\n\t\t\tbreak;\n#ifdef CONFIG_QUOTA\n\t\tcase Opt_usrjquota:\n\t\t\tif (!set_qf_name(sb, USRQUOTA, &args[0]))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_grpjquota:\n\t\t\tif (!set_qf_name(sb, GRPQUOTA, &args[0]))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_offusrjquota:\n\t\t\tif (!clear_qf_name(sb, USRQUOTA))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_offgrpjquota:\n\t\t\tif (!clear_qf_name(sb, GRPQUOTA))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\n\t\tcase Opt_jqfmt_vfsold:\n\t\t\tqfmt = QFMT_VFS_OLD;\n\t\t\tgoto set_qf_format;\n\t\tcase Opt_jqfmt_vfsv0:\n\t\t\tqfmt = QFMT_VFS_V0;\n\t\t\tgoto set_qf_format;\n\t\tcase Opt_jqfmt_vfsv1:\n\t\t\tqfmt = QFMT_VFS_V1;\nset_qf_format:\n\t\t\tif (sb_any_quota_loaded(sb) &&\n\t\t\t    sbi->s_jquota_fmt != qfmt) {\n\t\t\t\text4_msg(sb, KERN_ERR, \"Cannot change \"\n\t\t\t\t\t\"journaled quota options when \"\n\t\t\t\t\t\"quota turned on\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsbi->s_jquota_fmt = qfmt;\n\t\t\tbreak;\n\t\tcase Opt_quota:\n\t\tcase Opt_usrquota:\n\t\t\tset_opt(sb, QUOTA);\n\t\t\tset_opt(sb, USRQUOTA);\n\t\t\tbreak;\n\t\tcase Opt_grpquota:\n\t\t\tset_opt(sb, QUOTA);\n\t\t\tset_opt(sb, GRPQUOTA);\n\t\t\tbreak;\n\t\tcase Opt_noquota:\n\t\t\tif (sb_any_quota_loaded(sb)) {\n\t\t\t\text4_msg(sb, KERN_ERR, \"Cannot change quota \"\n\t\t\t\t\t\"options when quota turned on\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tclear_opt(sb, QUOTA);\n\t\t\tclear_opt(sb, USRQUOTA);\n\t\t\tclear_opt(sb, GRPQUOTA);\n\t\t\tbreak;\n#else\n\t\tcase Opt_quota:\n\t\tcase Opt_usrquota:\n\t\tcase Opt_grpquota:\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t\"quota options not supported\");\n\t\t\tbreak;\n\t\tcase Opt_usrjquota:\n\t\tcase Opt_grpjquota:\n\t\tcase Opt_offusrjquota:\n\t\tcase Opt_offgrpjquota:\n\t\tcase Opt_jqfmt_vfsold:\n\t\tcase Opt_jqfmt_vfsv0:\n\t\tcase Opt_jqfmt_vfsv1:\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t\"journaled quota options not supported\");\n\t\t\tbreak;\n\t\tcase Opt_noquota:\n\t\t\tbreak;\n#endif\n\t\tcase Opt_abort:\n\t\t\tsbi->s_mount_flags |= EXT4_MF_FS_ABORTED;\n\t\t\tbreak;\n\t\tcase Opt_nobarrier:\n\t\t\tclear_opt(sb, BARRIER);\n\t\t\tbreak;\n\t\tcase Opt_barrier:\n\t\t\tif (args[0].from) {\n\t\t\t\tif (match_int(&args[0], &option))\n\t\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\toption = 1;\t/* No argument, default to 1 */\n\t\t\tif (option)\n\t\t\t\tset_opt(sb, BARRIER);\n\t\t\telse\n\t\t\t\tclear_opt(sb, BARRIER);\n\t\t\tbreak;\n\t\tcase Opt_ignore:\n\t\t\tbreak;\n\t\tcase Opt_resize:\n\t\t\tif (!is_remount) {\n\t\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t\t\"resize option only available \"\n\t\t\t\t\t\"for remount\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (match_int(&args[0], &option) != 0)\n\t\t\t\treturn 0;\n\t\t\t*n_blocks_count = option;\n\t\t\tbreak;\n\t\tcase Opt_nobh:\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"Ignoring deprecated nobh option\");\n\t\t\tbreak;\n\t\tcase Opt_bh:\n\t\t\text4_msg(sb, KERN_WARNING,\n\t\t\t\t \"Ignoring deprecated bh option\");\n\t\t\tbreak;\n\t\tcase Opt_i_version:\n\t\t\tset_opt(sb, I_VERSION);\n\t\t\tsb->s_flags |= MS_I_VERSION;\n\t\t\tbreak;\n\t\tcase Opt_nodelalloc:\n\t\t\tclear_opt(sb, DELALLOC);\n\t\t\tbreak;\n\t\tcase Opt_mblk_io_submit:\n\t\t\tset_opt(sb, MBLK_IO_SUBMIT);\n\t\t\tbreak;\n\t\tcase Opt_nomblk_io_submit:\n\t\t\tclear_opt(sb, MBLK_IO_SUBMIT);\n\t\t\tbreak;\n\t\tcase Opt_stripe:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tif (option < 0)\n\t\t\t\treturn 0;\n\t\t\tsbi->s_stripe = option;\n\t\t\tbreak;\n\t\tcase Opt_delalloc:\n\t\t\tset_opt(sb, DELALLOC);\n\t\t\tbreak;\n\t\tcase Opt_block_validity:\n\t\t\tset_opt(sb, BLOCK_VALIDITY);\n\t\t\tbreak;\n\t\tcase Opt_noblock_validity:\n\t\t\tclear_opt(sb, BLOCK_VALIDITY);\n\t\t\tbreak;\n\t\tcase Opt_inode_readahead_blks:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tif (option < 0 || option > (1 << 30))\n\t\t\t\treturn 0;\n\t\t\tif (option && !is_power_of_2(option)) {\n\t\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t\t \"EXT4-fs: inode_readahead_blks\"\n\t\t\t\t\t \" must be a power of 2\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsbi->s_inode_readahead_blks = option;\n\t\t\tbreak;\n\t\tcase Opt_journal_ioprio:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tif (option < 0 || option > 7)\n\t\t\t\tbreak;\n\t\t\t*journal_ioprio = IOPRIO_PRIO_VALUE(IOPRIO_CLASS_BE,\n\t\t\t\t\t\t\t    option);\n\t\t\tbreak;\n\t\tcase Opt_noauto_da_alloc:\n\t\t\tset_opt(sb, NO_AUTO_DA_ALLOC);\n\t\t\tbreak;\n\t\tcase Opt_auto_da_alloc:\n\t\t\tif (args[0].from) {\n\t\t\t\tif (match_int(&args[0], &option))\n\t\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\toption = 1;\t/* No argument, default to 1 */\n\t\t\tif (option)\n\t\t\t\tclear_opt(sb, NO_AUTO_DA_ALLOC);\n\t\t\telse\n\t\t\t\tset_opt(sb,NO_AUTO_DA_ALLOC);\n\t\t\tbreak;\n\t\tcase Opt_discard:\n\t\t\tset_opt(sb, DISCARD);\n\t\t\tbreak;\n\t\tcase Opt_nodiscard:\n\t\t\tclear_opt(sb, DISCARD);\n\t\t\tbreak;\n\t\tcase Opt_dioread_nolock:\n\t\t\tset_opt(sb, DIOREAD_NOLOCK);\n\t\t\tbreak;\n\t\tcase Opt_dioread_lock:\n\t\t\tclear_opt(sb, DIOREAD_NOLOCK);\n\t\t\tbreak;\n\t\tcase Opt_init_inode_table:\n\t\t\tset_opt(sb, INIT_INODE_TABLE);\n\t\t\tif (args[0].from) {\n\t\t\t\tif (match_int(&args[0], &option))\n\t\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\toption = EXT4_DEF_LI_WAIT_MULT;\n\t\t\tif (option < 0)\n\t\t\t\treturn 0;\n\t\t\tsbi->s_li_wait_mult = option;\n\t\t\tbreak;\n\t\tcase Opt_noinit_inode_table:\n\t\t\tclear_opt(sb, INIT_INODE_TABLE);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t       \"Unrecognized mount option \\\"%s\\\" \"\n\t\t\t       \"or missing value\", p);\n\t\t\treturn 0;\n\t\t}\n\t}\n#ifdef CONFIG_QUOTA\n\tif (sbi->s_qf_names[USRQUOTA] || sbi->s_qf_names[GRPQUOTA]) {\n\t\tif (test_opt(sb, USRQUOTA) && sbi->s_qf_names[USRQUOTA])\n\t\t\tclear_opt(sb, USRQUOTA);\n\n\t\tif (test_opt(sb, GRPQUOTA) && sbi->s_qf_names[GRPQUOTA])\n\t\t\tclear_opt(sb, GRPQUOTA);\n\n\t\tif (test_opt(sb, GRPQUOTA) || test_opt(sb, USRQUOTA)) {\n\t\t\text4_msg(sb, KERN_ERR, \"old and new quota \"\n\t\t\t\t\t\"format mixing\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!sbi->s_jquota_fmt) {\n\t\t\text4_msg(sb, KERN_ERR, \"journaled quota format \"\n\t\t\t\t\t\"not specified\");\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (sbi->s_jquota_fmt) {\n\t\t\text4_msg(sb, KERN_ERR, \"journaled quota format \"\n\t\t\t\t\t\"specified with no journaling \"\n\t\t\t\t\t\"enabled\");\n\t\t\treturn 0;\n\t\t}\n\t}\n#endif\n\treturn 1;\n}\n- ext4_used_dirs_count: __u32 ext4_used_dirs_count(struct super_block *sb, /* <=== ext4_used_dirs_count */ \n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le16_to_cpu(bg->bg_used_dirs_count_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (__u32)le16_to_cpu(bg->bg_used_dirs_count_hi) << 16 : 0);\n}\n- EXT4_DEF_MIN_BATCH_TIME: #define EXT4_DEF_MIN_BATCH_TIME\t0 /* <=== fs/ext4/ext4.h:1397:1397:EXT4_DEF_MIN_BATCH_TIME:0 */ \n- EXT4_SB: #define EXT4_SB(sb)\t(sb) /* <=== fs/ext4/ext4.h:1279:1279:EXT4_SB:1 */ \n- ext4_update_dynamic_rev: void ext4_update_dynamic_rev(struct super_block *sb) /* <=== ext4_update_dynamic_rev */ \n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT4_GOOD_OLD_REV)\n\t\treturn;\n\n\text4_warning(sb,\n\t\t     \"updating to rev %d because of new feature flag, \"\n\t\t     \"running e2fsck is recommended\",\n\t\t     EXT4_DYNAMIC_REV);\n\n\tes->s_first_ino = cpu_to_le32(EXT4_GOOD_OLD_FIRST_INO);\n\tes->s_inode_size = cpu_to_le16(EXT4_GOOD_OLD_INODE_SIZE);\n\tes->s_rev_level = cpu_to_le32(EXT4_DYNAMIC_REV);\n\t/* leave es->s_feature_*compat flags alone */\n\t/* es->s_uuid will be set by e2fsck if empty */\n\n\t/*\n\t * The rest of the superblock fields should be zero, and if not it\n\t * means they are likely already in use, so leave them alone.  We\n\t * can leave it up to e2fsck to clean up any inconsistencies there.\n\t */\n}\n- EXT4_GOOD_OLD_REV: #define EXT4_GOOD_OLD_REV\t0\t/* The good old (original) format */ /* <=== fs/ext4/ext4.h:1296:1296:EXT4_GOOD_OLD_REV:0 */ \n- EXT4_DEF_INODE_READAHEAD_BLKS: #define EXT4_DEF_INODE_READAHEAD_BLKS\t32 /* <=== fs/ext4/ext4.h:1375:1375:EXT4_DEF_INODE_READAHEAD_BLKS:0 */ \n- ext4_fill_flex_info: static int ext4_fill_flex_info(struct super_block *sb) /* <=== ext4_fill_flex_info */ \n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_group_desc *gdp = NULL;\n\text4_group_t flex_group_count;\n\text4_group_t flex_group;\n\tint groups_per_flex = 0;\n\tsize_t size;\n\tint i;\n\n\tsbi->s_log_groups_per_flex = sbi->s_es->s_log_groups_per_flex;\n\tgroups_per_flex = 1 << sbi->s_log_groups_per_flex;\n\n\tif (groups_per_flex < 2) {\n\t\tsbi->s_log_groups_per_flex = 0;\n\t\treturn 1;\n\t}\n\n\t/* We allocate both existing and potentially added groups */\n\tflex_group_count = ((sbi->s_groups_count + groups_per_flex - 1) +\n\t\t\t((le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) + 1) <<\n\t\t\t      EXT4_DESC_PER_BLOCK_BITS(sb))) / groups_per_flex;\n\tsize = flex_group_count * sizeof(struct flex_groups);\n\tsbi->s_flex_groups = kzalloc(size, GFP_KERNEL);\n\tif (sbi->s_flex_groups == NULL) {\n\t\tsbi->s_flex_groups = vzalloc(size);\n\t\tif (sbi->s_flex_groups == NULL) {\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"not enough memory for %u flex groups\",\n\t\t\t\t flex_group_count);\n\t\t\tgoto failed;\n\t\t}\n\t}\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\n\t\tflex_group = ext4_flex_group(sbi, i);\n\t\tatomic_add(ext4_free_inodes_count(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].free_inodes);\n\t\tatomic_add(ext4_free_blks_count(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].free_blocks);\n\t\tatomic_add(ext4_used_dirs_count(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].used_dirs);\n\t}\n\n\treturn 1;\nfailed:\n\treturn 0;\n}\n- MB_DEFAULT_STREAM_THRESHOLD: #define MB_DEFAULT_STREAM_THRESHOLD\t16\t/* 64K */ /* <=== fs/ext4/mballoc.h:85:85:MB_DEFAULT_STREAM_THRESHOLD:0 */ \n- atomic_add: static inline void atomic_add(int i, volatile atomic_t *v) /* <=== atomic_add */ \n{\n\tunsigned long flags;\n\tcris_atomic_save(v, flags);\n\tv->counter += i;\n\tcris_atomic_restore(v, flags);\n}\n- percpu_counter_init: static inline int percpu_counter_init(struct percpu_counter *fbc, s64 amount) /* <=== percpu_counter_init */ \n{\n\tfbc->count = amount;\n\treturn 0;\n}\n- EXT4_INODES_PER_GROUP: # define EXT4_INODES_PER_GROUP(s)\t((s)->s_inodes_per_group) /* <=== fs/ext4/ext4.h:311:311:EXT4_INODES_PER_GROUP:1 */ \n- memcpy: extern void *memcpy (void *, const void *, __kernel_size_t); /* <=== memcpy */ \n- EXT4_MAX_SUPP_REV: #define EXT4_MAX_SUPP_REV\tEXT4_DYNAMIC_REV /* <=== fs/ext4/ext4.h:1300:1300:EXT4_MAX_SUPP_REV:0 */ \n- EXT4_DEFM_NOBARRIER: #define EXT4_DEFM_NOBARRIER\t0x0100 /* <=== fs/ext4/ext4.h:1389:1389:EXT4_DEFM_NOBARRIER:0 */ \n- ext4_mb_release: int ext4_mb_release(struct super_block *sb) /* <=== ext4_mb_release */ \n{\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\text4_group_t i;\n\tint num_meta_group_infos;\n\tstruct ext4_group_info *grinfo;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct kmem_cache *cachep = get_groupinfo_cache(sb->s_blocksize_bits);\n\n\tif (sbi->s_group_info) {\n\t\tfor (i = 0; i < ngroups; i++) {\n\t\t\tgrinfo = ext4_get_group_info(sb, i);\n#ifdef DOUBLE_CHECK\n\t\t\tkfree(grinfo->bb_bitmap);\n#endif\n\t\t\text4_lock_group(sb, i);\n\t\t\text4_mb_cleanup_pa(grinfo);\n\t\t\text4_unlock_group(sb, i);\n\t\t\tkmem_cache_free(cachep, grinfo);\n\t\t}\n\t\tnum_meta_group_infos = (ngroups +\n\t\t\t\tEXT4_DESC_PER_BLOCK(sb) - 1) >>\n\t\t\tEXT4_DESC_PER_BLOCK_BITS(sb);\n\t\tfor (i = 0; i < num_meta_group_infos; i++)\n\t\t\tkfree(sbi->s_group_info[i]);\n\t\tkfree(sbi->s_group_info);\n\t}\n\tkfree(sbi->s_mb_offsets);\n\tkfree(sbi->s_mb_maxs);\n\tif (sbi->s_buddy_cache)\n\t\tiput(sbi->s_buddy_cache);\n\tif (sbi->s_mb_stats) {\n\t\tprintk(KERN_INFO\n\t\t       \"EXT4-fs: mballoc: %u blocks %u reqs (%u success)\\n\",\n\t\t\t\tatomic_read(&sbi->s_bal_allocated),\n\t\t\t\tatomic_read(&sbi->s_bal_reqs),\n\t\t\t\tatomic_read(&sbi->s_bal_success));\n\t\tprintk(KERN_INFO\n\t\t      \"EXT4-fs: mballoc: %u extents scanned, %u goal hits, \"\n\t\t\t\t\"%u 2^N hits, %u breaks, %u lost\\n\",\n\t\t\t\tatomic_read(&sbi->s_bal_ex_scanned),\n\t\t\t\tatomic_read(&sbi->s_bal_goals),\n\t\t\t\tatomic_read(&sbi->s_bal_2orders),\n\t\t\t\tatomic_read(&sbi->s_bal_breaks),\n\t\t\t\tatomic_read(&sbi->s_mb_lost_chunks));\n\t\tprintk(KERN_INFO\n\t\t       \"EXT4-fs: mballoc: %lu generated and it took %Lu\\n\",\n\t\t\t\tsbi->s_mb_buddies_generated++,\n\t\t\t\tsbi->s_mb_generation_time);\n\t\tprintk(KERN_INFO\n\t\t       \"EXT4-fs: mballoc: %u preallocated, %u discarded\\n\",\n\t\t\t\tatomic_read(&sbi->s_mb_preallocated),\n\t\t\t\tatomic_read(&sbi->s_mb_discarded));\n\t}\n\n\tfree_percpu(sbi->s_locality_groups);\n\tif (sbi->s_proc)\n\t\tremove_proc_entry(\"mb_groups\", sbi->s_proc);\n\n\treturn 0;\n}\n- ext4_groupinfo_create_slab: static int ext4_groupinfo_create_slab(size_t size) /* <=== ext4_groupinfo_create_slab */ \n{\n\tstatic DEFINE_MUTEX(ext4_grpinfo_slab_create_mutex);\n\tint slab_size;\n\tint blocksize_bits = order_base_2(size);\n\tint cache_index = blocksize_bits - EXT4_MIN_BLOCK_LOG_SIZE;\n\tstruct kmem_cache *cachep;\n\n\tif (cache_index >= NR_GRPINFO_CACHES)\n\t\treturn -EINVAL;\n\n\tif (unlikely(cache_index < 0))\n\t\tcache_index = 0;\n\n\tmutex_lock(&ext4_grpinfo_slab_create_mutex);\n\tif (ext4_groupinfo_caches[cache_index]) {\n\t\tmutex_unlock(&ext4_grpinfo_slab_create_mutex);\n\t\treturn 0;\t/* Already created */\n\t}\n\n\tslab_size = offsetof(struct ext4_group_info,\n\t\t\t\tbb_counters[blocksize_bits + 2]);\n\n\tcachep = kmem_cache_create(ext4_groupinfo_slab_names[cache_index],\n\t\t\t\t\tslab_size, 0, SLAB_RECLAIM_ACCOUNT,\n\t\t\t\t\tNULL);\n\n\tmutex_unlock(&ext4_grpinfo_slab_create_mutex);\n\tif (!cachep) {\n\t\tprintk(KERN_EMERG \"EXT4: no memory for groupinfo slab cache\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\text4_groupinfo_caches[cache_index] = cachep;\n\n\treturn 0;\n}\n- EXT4_GOOD_OLD_FIRST_INO: #define EXT4_GOOD_OLD_FIRST_INO\t11 /* <=== fs/ext4/ext4.h:218:218:EXT4_GOOD_OLD_FIRST_INO:0 */ \n- EXT4_DEF_RESUID: #define\tEXT4_DEF_RESUID\t\t0 /* <=== fs/ext4/ext4.h:1372:1372:EXT4_DEF_RESUID:0 */ \n- ext4_check_descriptors: static int ext4_check_descriptors(struct super_block *sb, /* <=== ext4_check_descriptors */ \n\t\t\t\t  ext4_group_t *first_not_zeroed)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_fsblk_t first_block = le32_to_cpu(sbi->s_es->s_first_data_block);\n\text4_fsblk_t last_block;\n\text4_fsblk_t block_bitmap;\n\text4_fsblk_t inode_bitmap;\n\text4_fsblk_t inode_table;\n\tint flexbg_flag = 0;\n\text4_group_t i, grp = sbi->s_groups_count;\n\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_FLEX_BG))\n\t\tflexbg_flag = 1;\n\n\text4_debug(\"Checking group descriptors\");\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tstruct ext4_group_desc *gdp = ext4_get_group_desc(sb, i, NULL);\n\n\t\tif (i == sbi->s_groups_count - 1 || flexbg_flag)\n\t\t\tlast_block = ext4_blocks_count(sbi->s_es) - 1;\n\t\telse\n\t\t\tlast_block = first_block +\n\t\t\t\t(EXT4_BLOCKS_PER_GROUP(sb) - 1);\n\n\t\tif ((grp == sbi->s_groups_count) &&\n\t\t   !(gdp->bg_flags & cpu_to_le16(EXT4_BG_INODE_ZEROED)))\n\t\t\tgrp = i;\n\n\t\tblock_bitmap = ext4_block_bitmap(sb, gdp);\n\t\tif (block_bitmap < first_block || block_bitmap > last_block) {\n\t\t\text4_msg(sb, KERN_ERR, \"ext4_check_descriptors: \"\n\t\t\t       \"Block bitmap for group %u not in group \"\n\t\t\t       \"(block %llu)!\", i, block_bitmap);\n\t\t\treturn 0;\n\t\t}\n\t\tinode_bitmap = ext4_inode_bitmap(sb, gdp);\n\t\tif (inode_bitmap < first_block || inode_bitmap > last_block) {\n\t\t\text4_msg(sb, KERN_ERR, \"ext4_check_descriptors: \"\n\t\t\t       \"Inode bitmap for group %u not in group \"\n\t\t\t       \"(block %llu)!\", i, inode_bitmap);\n\t\t\treturn 0;\n\t\t}\n\t\tinode_table = ext4_inode_table(sb, gdp);\n\t\tif (inode_table < first_block ||\n\t\t    inode_table + sbi->s_itb_per_group - 1 > last_block) {\n\t\t\text4_msg(sb, KERN_ERR, \"ext4_check_descriptors: \"\n\t\t\t       \"Inode table for group %u not in group \"\n\t\t\t       \"(block %llu)!\", i, inode_table);\n\t\t\treturn 0;\n\t\t}\n\t\text4_lock_group(sb, i);\n\t\tif (!ext4_group_desc_csum_verify(sbi, i, gdp)) {\n\t\t\text4_msg(sb, KERN_ERR, \"ext4_check_descriptors: \"\n\t\t\t\t \"Checksum for group %u failed (%u!=%u)\",\n\t\t\t\t i, le16_to_cpu(ext4_group_desc_csum(sbi, i,\n\t\t\t\t     gdp)), le16_to_cpu(gdp->bg_checksum));\n\t\t\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\t\t\text4_unlock_group(sb, i);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\text4_unlock_group(sb, i);\n\t\tif (!flexbg_flag)\n\t\t\tfirst_block += EXT4_BLOCKS_PER_GROUP(sb);\n\t}\n\tif (NULL != first_not_zeroed)\n\t\t*first_not_zeroed = grp;\n\n\text4_free_blocks_count_set(sbi->s_es, ext4_count_free_blocks(sb));\n\tsbi->s_es->s_free_inodes_count =cpu_to_le32(ext4_count_free_inodes(sb));\n\treturn 1;\n}\n- ext4_group_desc_csum: __le16 ext4_group_desc_csum(struct ext4_sb_info *sbi, __u32 block_group, /* <=== ext4_group_desc_csum */ \n\t\t\t    struct ext4_group_desc *gdp)\n{\n\t__u16 crc = 0;\n\n\tif (sbi->s_es->s_feature_ro_compat &\n\t    cpu_to_le32(EXT4_FEATURE_RO_COMPAT_GDT_CSUM)) {\n\t\tint offset = offsetof(struct ext4_group_desc, bg_checksum);\n\t\t__le32 le_group = cpu_to_le32(block_group);\n\n\t\tcrc = crc16(~0, sbi->s_es->s_uuid, sizeof(sbi->s_es->s_uuid));\n\t\tcrc = crc16(crc, (__u8 *)&le_group, sizeof(le_group));\n\t\tcrc = crc16(crc, (__u8 *)gdp, offset);\n\t\toffset += sizeof(gdp->bg_checksum); /* skip checksum */\n\t\t/* for checksum of struct ext4_group_desc do the rest...*/\n\t\tif ((sbi->s_es->s_feature_incompat &\n\t\t     cpu_to_le32(EXT4_FEATURE_INCOMPAT_64BIT)) &&\n\t\t    offset < le16_to_cpu(sbi->s_es->s_desc_size))\n\t\t\tcrc = crc16(crc, (__u8 *)gdp + offset,\n\t\t\t\t    le16_to_cpu(sbi->s_es->s_desc_size) -\n\t\t\t\t\toffset);\n\t}\n\n\treturn cpu_to_le16(crc);\n}\n- ext4_orphan_cleanup: static void ext4_orphan_cleanup(struct super_block *sb, /* <=== ext4_orphan_cleanup */ \n\t\t\t\tstruct ext4_super_block *es)\n{\n\tunsigned int s_flags = sb->s_flags;\n\tint nr_orphans = 0, nr_truncates = 0;\n#ifdef CONFIG_QUOTA\n\tint i;\n#endif\n\tif (!es->s_last_orphan) {\n\t\tjbd_debug(4, \"no orphan inodes to clean up\\n\");\n\t\treturn;\n\t}\n\n\tif (bdev_read_only(sb->s_bdev)) {\n\t\text4_msg(sb, KERN_ERR, \"write access \"\n\t\t\t\"unavailable, skipping orphan cleanup\");\n\t\treturn;\n\t}\n\n\t/* Check if feature set would not allow a r/w mount */\n\tif (!ext4_feature_set_ok(sb, 0)) {\n\t\text4_msg(sb, KERN_INFO, \"Skipping orphan cleanup due to \"\n\t\t\t \"unknown ROCOMPAT features\");\n\t\treturn;\n\t}\n\n\tif (EXT4_SB(sb)->s_mount_state & EXT4_ERROR_FS) {\n\t\tif (es->s_last_orphan)\n\t\t\tjbd_debug(1, \"Errors on filesystem, \"\n\t\t\t\t  \"clearing orphan list.\\n\");\n\t\tes->s_last_orphan = 0;\n\t\tjbd_debug(1, \"Skipping orphan recovery on fs with errors.\\n\");\n\t\treturn;\n\t}\n\n\tif (s_flags & MS_RDONLY) {\n\t\text4_msg(sb, KERN_INFO, \"orphan cleanup on readonly fs\");\n\t\tsb->s_flags &= ~MS_RDONLY;\n\t}\n#ifdef CONFIG_QUOTA\n\t/* Needed for iput() to work correctly and not trash data */\n\tsb->s_flags |= MS_ACTIVE;\n\t/* Turn on quotas so that they are updated correctly */\n\tfor (i = 0; i < MAXQUOTAS; i++) {\n\t\tif (EXT4_SB(sb)->s_qf_names[i]) {\n\t\t\tint ret = ext4_quota_on_mount(sb, i);\n\t\t\tif (ret < 0)\n\t\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t\t\"Cannot turn on journaled \"\n\t\t\t\t\t\"quota: error %d\", ret);\n\t\t}\n\t}\n#endif\n\n\twhile (es->s_last_orphan) {\n\t\tstruct inode *inode;\n\n\t\tinode = ext4_orphan_get(sb, le32_to_cpu(es->s_last_orphan));\n\t\tif (IS_ERR(inode)) {\n\t\t\tes->s_last_orphan = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_add(&EXT4_I(inode)->i_orphan, &EXT4_SB(sb)->s_orphan);\n\t\tdquot_initialize(inode);\n\t\tif (inode->i_nlink) {\n\t\t\text4_msg(sb, KERN_DEBUG,\n\t\t\t\t\"%s: truncating inode %lu to %lld bytes\",\n\t\t\t\t__func__, inode->i_ino, inode->i_size);\n\t\t\tjbd_debug(2, \"truncating inode %lu to %lld bytes\\n\",\n\t\t\t\t  inode->i_ino, inode->i_size);\n\t\t\text4_truncate(inode);\n\t\t\tnr_truncates++;\n\t\t} else {\n\t\t\text4_msg(sb, KERN_DEBUG,\n\t\t\t\t\"%s: deleting unreferenced inode %lu\",\n\t\t\t\t__func__, inode->i_ino);\n\t\t\tjbd_debug(2, \"deleting unreferenced inode %lu\\n\",\n\t\t\t\t  inode->i_ino);\n\t\t\tnr_orphans++;\n\t\t}\n\t\tiput(inode);  /* The delete magic happens here! */\n\t}\n\n#define PLURAL(x) (x), ((x) == 1) ? \"\" : \"s\"\n\n\tif (nr_orphans)\n\t\text4_msg(sb, KERN_INFO, \"%d orphan inode%s deleted\",\n\t\t       PLURAL(nr_orphans));\n\tif (nr_truncates)\n\t\text4_msg(sb, KERN_INFO, \"%d truncate%s cleaned up\",\n\t\t       PLURAL(nr_truncates));\n#ifdef CONFIG_QUOTA\n\t/* Turn quotas off */\n\tfor (i = 0; i < MAXQUOTAS; i++) {\n\t\tif (sb_dqopt(sb)->files[i])\n\t\t\tdquot_quota_off(sb, i);\n\t}\n#endif\n\tsb->s_flags = s_flags; /* Restore MS_RDONLY status */\n}\n- EXT4_DEFM_NODELALLOC: #define EXT4_DEFM_NODELALLOC\t0x0800 /* <=== fs/ext4/ext4.h:1392:1392:EXT4_DEFM_NODELALLOC:0 */ \n- get_sb_block: static ext4_fsblk_t get_sb_block(void **data) /* <=== get_sb_block */ \n{\n\text4_fsblk_t\tsb_block;\n\tchar\t\t*options = (char *) *data;\n\n\tif (!options || strncmp(options, \"sb=\", 3) != 0)\n\t\treturn 1;\t/* Default location */\n\n\toptions += 3;\n\t/* TODO: use simple_strtoll with >32bit ext4 */\n\tsb_block = simple_strtoul(options, &options, 0);\n\tif (*options && *options != ',') {\n\t\tprintk(KERN_ERR \"EXT4-fs: Invalid sb specification: %s\\n\",\n\t\t       (char *) *data);\n\t\treturn 1;\n\t}\n\tif (*options == ',')\n\t\toptions++;\n\t*data = (void *) options;\n\n\treturn sb_block;\n}\n- del_timer: extern int del_timer(struct timer_list * timer); /* <=== del_timer */ \n- set_opt: #define set_opt(sb, opt)\t\tEXT4_SB(sb)->s_mount_opt |= \\ /* <=== fs/ext4/ext4.h:914:915:set_opt:2 */ \n\t\t\t\t\t\tEXT4_MOUNT_##opt\n- mutex_lock: extern void mutex_lock(struct mutex *lock); /* <=== mutex_lock */ \n- EXT4_DEFM_DEBUG: #define EXT4_DEFM_DEBUG\t\t0x0001 /* <=== fs/ext4/ext4.h:1380:1380:EXT4_DEFM_DEBUG:0 */ \n- EXT4_CLEAR_INCOMPAT_FEATURE: #define EXT4_CLEAR_INCOMPAT_FEATURE(sb,mask)\t\t\t\\ /* <=== fs/ext4/ext4.h:1324:1325:EXT4_CLEAR_INCOMPAT_FEATURE:2 */ \n\tEXT4_SB(sb)->s_es->s_feature_incompat &= ~cpu_to_le32(mask)\n- EXT4_GOOD_OLD_INODE_SIZE: #define EXT4_GOOD_OLD_INODE_SIZE 128 /* <=== fs/ext4/ext4.h:1302:1302:EXT4_GOOD_OLD_INODE_SIZE:0 */ \n- ext4_clear_journal_err: static void ext4_clear_journal_err(struct super_block *sb, /* <=== ext4_clear_journal_err */ \n\t\t\t\t   struct ext4_super_block *es)\n{\n\tjournal_t *journal;\n\tint j_errno;\n\tconst char *errstr;\n\n\tBUG_ON(!EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL));\n\n\tjournal = EXT4_SB(sb)->s_journal;\n\n\t/*\n\t * Now check for any error status which may have been recorded in the\n\t * journal by a prior ext4_error() or ext4_abort()\n\t */\n\n\tj_errno = jbd2_journal_errno(journal);\n\tif (j_errno) {\n\t\tchar nbuf[16];\n\n\t\terrstr = ext4_decode_error(sb, j_errno, nbuf);\n\t\text4_warning(sb, \"Filesystem error recorded \"\n\t\t\t     \"from previous mount: %s\", errstr);\n\t\text4_warning(sb, \"Marking fs in need of filesystem check.\");\n\n\t\tEXT4_SB(sb)->s_mount_state |= EXT4_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT4_ERROR_FS);\n\t\text4_commit_super(sb, 1);\n\n\t\tjbd2_journal_clear_err(journal);\n\t}\n}\n- strncmp: static inline int strncmp(const char *__cs, const char *__ct, size_t __n) /* <=== strncmp */ \n{\n\tregister int __res;\n\tunsigned long __dummy;\n\n\t__asm__ __volatile__(\n\t\t\"mov\t%2, %3\\n\"\n\t\t\"1:\\n\\t\"\n\t\t\"beq\t%0, %6, 2f\\n\\t\"\n\t\t\"l8ui\t%3, %1, 0\\n\\t\"\n\t\t\"addi\t%1, %1, 1\\n\\t\"\n\t\t\"l8ui\t%2, %0, 0\\n\\t\"\n\t\t\"addi\t%0, %0, 1\\n\\t\"\n\t\t\"beqz\t%2, 2f\\n\\t\"\n\t\t\"beqz\t%3, 2f\\n\\t\"\n\t\t\"beq\t%2, %3, 1b\\n\"\n\t\t\"2:\\n\\t\"\n\t\t\"sub\t%2, %3, %2\"\n\t\t: \"=r\" (__cs), \"=r\" (__ct), \"=&r\" (__res), \"=&r\" (__dummy)\n\t\t: \"0\" (__cs), \"1\" (__ct), \"r\" (__cs+__n));\n\n\treturn __res;\n}\n- EXT4_HAS_INCOMPAT_FEATURE: #define EXT4_HAS_INCOMPAT_FEATURE(sb,mask)\t\t\t\\ /* <=== fs/ext4/ext4.h:1312:1313:EXT4_HAS_INCOMPAT_FEATURE:2 */ \n\t((EXT4_SB(sb)->s_es->s_feature_incompat & cpu_to_le32(mask)) != 0)\n- EXT4_DFL_MAX_MNT_COUNT: #define EXT4_DFL_MAX_MNT_COUNT\t\t20\t/* Allow 20 mounts */ /* <=== fs/ext4/ext4.h:938:938:EXT4_DFL_MAX_MNT_COUNT:0 */ \n- test_opt: #define test_opt(sb, opt)\t\t(EXT4_SB(sb)->s_mount_opt & \\ /* <=== fs/ext4/ext4.h:916:917:test_opt:2 */ \n\t\t\t\t\t EXT4_MOUNT_##opt)\n- EXT4_BG_INODE_ZEROED: #define EXT4_BG_INODE_ZEROED\t0x0004 /* On-disk itable initialized to zero */ /* <=== fs/ext4/ext4.h:294:294:EXT4_BG_INODE_ZEROED:0 */ \n- ext4_mb_init_backend: static int ext4_mb_init_backend(struct super_block *sb) /* <=== ext4_mb_init_backend */ \n{\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\text4_group_t i;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tint num_meta_group_infos;\n\tint num_meta_group_infos_max;\n\tint array_size;\n\tstruct ext4_group_desc *desc;\n\tstruct kmem_cache *cachep;\n\n\t/* This is the number of blocks used by GDT */\n\tnum_meta_group_infos = (ngroups + EXT4_DESC_PER_BLOCK(sb) -\n\t\t\t\t1) >> EXT4_DESC_PER_BLOCK_BITS(sb);\n\n\t/*\n\t * This is the total number of blocks used by GDT including\n\t * the number of reserved blocks for GDT.\n\t * The s_group_info array is allocated with this value\n\t * to allow a clean online resize without a complex\n\t * manipulation of pointer.\n\t * The drawback is the unused memory when no resize\n\t * occurs but it's very low in terms of pages\n\t * (see comments below)\n\t * Need to handle this properly when META_BG resizing is allowed\n\t */\n\tnum_meta_group_infos_max = num_meta_group_infos +\n\t\t\t\tle16_to_cpu(es->s_reserved_gdt_blocks);\n\n\t/*\n\t * array_size is the size of s_group_info array. We round it\n\t * to the next power of two because this approximation is done\n\t * internally by kmalloc so we can have some more memory\n\t * for free here (e.g. may be used for META_BG resize).\n\t */\n\tarray_size = 1;\n\twhile (array_size < sizeof(*sbi->s_group_info) *\n\t       num_meta_group_infos_max)\n\t\tarray_size = array_size << 1;\n\t/* An 8TB filesystem with 64-bit pointers requires a 4096 byte\n\t * kmalloc. A 128kb malloc should suffice for a 256TB filesystem.\n\t * So a two level scheme suffices for now. */\n\tsbi->s_group_info = kzalloc(array_size, GFP_KERNEL);\n\tif (sbi->s_group_info == NULL) {\n\t\tprintk(KERN_ERR \"EXT4-fs: can't allocate buddy meta group\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tsbi->s_buddy_cache = new_inode(sb);\n\tif (sbi->s_buddy_cache == NULL) {\n\t\tprintk(KERN_ERR \"EXT4-fs: can't get new inode\\n\");\n\t\tgoto err_freesgi;\n\t}\n\tsbi->s_buddy_cache->i_ino = get_next_ino();\n\tEXT4_I(sbi->s_buddy_cache)->i_disksize = 0;\n\tfor (i = 0; i < ngroups; i++) {\n\t\tdesc = ext4_get_group_desc(sb, i, NULL);\n\t\tif (desc == NULL) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"EXT4-fs: can't read descriptor %u\\n\", i);\n\t\t\tgoto err_freebuddy;\n\t\t}\n\t\tif (ext4_mb_add_groupinfo(sb, i, desc) != 0)\n\t\t\tgoto err_freebuddy;\n\t}\n\n\treturn 0;\n\nerr_freebuddy:\n\tcachep = get_groupinfo_cache(sb->s_blocksize_bits);\n\twhile (i-- > 0)\n\t\tkmem_cache_free(cachep, ext4_get_group_info(sb, i));\n\ti = num_meta_group_infos;\n\twhile (i-- > 0)\n\t\tkfree(sbi->s_group_info[i]);\n\tiput(sbi->s_buddy_cache);\nerr_freesgi:\n\tkfree(sbi->s_group_info);\n\treturn -ENOMEM;\n}\n- ext4_block_bitmap: ext4_fsblk_t ext4_block_bitmap(struct super_block *sb, /* <=== ext4_block_bitmap */ \n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_block_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_block_bitmap_hi) << 32 : 0);\n}\n- clear_opt: #define clear_opt(sb, opt)\t\tEXT4_SB(sb)->s_mount_opt &= \\ /* <=== fs/ext4/ext4.h:912:913:clear_opt:2 */ \n\t\t\t\t\t\t~EXT4_MOUNT_##opt\n- EXT4_ERROR_FS: #define\tEXT4_ERROR_FS\t\t\t0x0002\t/* Errors detected */ /* <=== fs/ext4/ext4.h:867:867:EXT4_ERROR_FS:0 */ \n- ext4_mb_cleanup_pa: static void ext4_mb_cleanup_pa(struct ext4_group_info *grp) /* <=== ext4_mb_cleanup_pa */ \n{\n\tstruct ext4_prealloc_space *pa;\n\tstruct list_head *cur, *tmp;\n\tint count = 0;\n\n\tlist_for_each_safe(cur, tmp, &grp->bb_prealloc_list) {\n\t\tpa = list_entry(cur, struct ext4_prealloc_space, pa_group_list);\n\t\tlist_del(&pa->pa_group_list);\n\t\tcount++;\n\t\tkmem_cache_free(ext4_pspace_cachep, pa);\n\t}\n\tif (count)\n\t\tmb_debug(1, \"mballoc: %u PAs left\\n\", count);\n\n}\n- EXT4_NDIR_BLOCKS: #define\tEXT4_NDIR_BLOCKS\t\t12 /* <=== fs/ext4/ext4.h:317:317:EXT4_NDIR_BLOCKS:0 */ \n- dquot_initialize: static inline void dquot_initialize(struct inode *inode) /* <=== dquot_initialize */ \n{\n}\n- ext4_feature_set_ok: static int ext4_feature_set_ok(struct super_block *sb, int readonly) /* <=== ext4_feature_set_ok */ \n{\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, ~EXT4_FEATURE_INCOMPAT_SUPP)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t\"Couldn't mount because of \"\n\t\t\t\"unsupported optional features (%x)\",\n\t\t\t(le32_to_cpu(EXT4_SB(sb)->s_es->s_feature_incompat) &\n\t\t\t~EXT4_FEATURE_INCOMPAT_SUPP));\n\t\treturn 0;\n\t}\n\n\tif (readonly)\n\t\treturn 1;\n\n\t/* Check that feature set is OK for a read-write mount */\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, ~EXT4_FEATURE_RO_COMPAT_SUPP)) {\n\t\text4_msg(sb, KERN_ERR, \"couldn't mount RDWR because of \"\n\t\t\t \"unsupported optional features (%x)\",\n\t\t\t (le32_to_cpu(EXT4_SB(sb)->s_es->s_feature_ro_compat) &\n\t\t\t\t~EXT4_FEATURE_RO_COMPAT_SUPP));\n\t\treturn 0;\n\t}\n\t/*\n\t * Large file size enabled file system can only be mounted\n\t * read-write on 32-bit systems if kernel is built with CONFIG_LBDAF\n\t */\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_HUGE_FILE)) {\n\t\tif (sizeof(blkcnt_t) < sizeof(u64)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Filesystem with huge files \"\n\t\t\t\t \"cannot be mounted RDWR without \"\n\t\t\t\t \"CONFIG_LBDAF\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n- ext4_inode_bitmap: ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb, /* <=== ext4_inode_bitmap */ \n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_bitmap_hi) << 32 : 0);\n}\n- EXT2_FLAGS_SIGNED_HASH: #define EXT2_FLAGS_SIGNED_HASH\t\t0x0001  /* Signed dirhash in use */ /* <=== fs/ext4/ext4.h:873:873:EXT2_FLAGS_SIGNED_HASH:0 */ \n- ext4_register_li_request: static int ext4_register_li_request(struct super_block *sb, /* <=== ext4_register_li_request */ \n\t\t\t\t    ext4_group_t first_not_zeroed)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_li_request *elr;\n\text4_group_t ngroups = EXT4_SB(sb)->s_groups_count;\n\tint ret = 0;\n\n\tif (sbi->s_li_request != NULL)\n\t\treturn 0;\n\n\tif (first_not_zeroed == ngroups ||\n\t    (sb->s_flags & MS_RDONLY) ||\n\t    !test_opt(sb, INIT_INODE_TABLE)) {\n\t\tsbi->s_li_request = NULL;\n\t\treturn 0;\n\t}\n\n\tif (first_not_zeroed == ngroups) {\n\t\tsbi->s_li_request = NULL;\n\t\treturn 0;\n\t}\n\n\telr = ext4_li_request_new(sb, first_not_zeroed);\n\tif (!elr)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&ext4_li_mtx);\n\n\tif (NULL == ext4_li_info) {\n\t\tret = ext4_li_info_new();\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tmutex_lock(&ext4_li_info->li_list_mtx);\n\tlist_add(&elr->lr_request, &ext4_li_info->li_request_list);\n\tmutex_unlock(&ext4_li_info->li_list_mtx);\n\n\tsbi->s_li_request = elr;\n\t/*\n\t * set elr to NULL here since it has been inserted to\n\t * the request_list and the removal and free of it is\n\t * handled by ext4_clear_request_list from now on.\n\t */\n\telr = NULL;\n\n\tif (!(ext4_li_info->li_state & EXT4_LAZYINIT_RUNNING)) {\n\t\tret = ext4_run_lazyinit_thread();\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&ext4_li_mtx);\n\tif (ret)\n\t\tkfree(elr);\n\treturn ret;\n}\n- ext4_blkdev_remove: static int ext4_blkdev_remove(struct ext4_sb_info *sbi) /* <=== ext4_blkdev_remove */ \n{\n\tstruct block_device *bdev;\n\tint ret = -ENODEV;\n\n\tbdev = sbi->journal_bdev;\n\tif (bdev) {\n\t\tret = ext4_blkdev_put(bdev);\n\t\tsbi->journal_bdev = NULL;\n\t}\n\treturn ret;\n}\n- EXT4_EPOCH_BITS: #define EXT4_EPOCH_BITS 2 /* <=== fs/ext4/ext4.h:638:638:EXT4_EPOCH_BITS:0 */ \n- EXT2_FLAGS_UNSIGNED_HASH: #define EXT2_FLAGS_UNSIGNED_HASH\t0x0002  /* Unsigned dirhash in use */ /* <=== fs/ext4/ext4.h:874:874:EXT2_FLAGS_UNSIGNED_HASH:0 */ \n- EXT4_SET_INCOMPAT_FEATURE: #define EXT4_SET_INCOMPAT_FEATURE(sb,mask)\t\t\t\\ /* <=== fs/ext4/ext4.h:1318:1319:EXT4_SET_INCOMPAT_FEATURE:2 */ \n\tEXT4_SB(sb)->s_es->s_feature_incompat |= cpu_to_le32(mask)\n- mod_timer: extern int mod_timer(struct timer_list *timer, unsigned long expires); /* <=== mod_timer */ \n- ext4_debug: #define ext4_debug(f, a...)\tdo {} while (0) /* <=== fs/ext4/ext4.h:56:56:ext4_debug:2 */ \n- ext4_li_request_new: static struct ext4_li_request *ext4_li_request_new(struct super_block *sb, /* <=== ext4_li_request_new */ \n\t\t\t\t\t    ext4_group_t start)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_li_request *elr;\n\tunsigned long rnd;\n\n\telr = kzalloc(sizeof(*elr), GFP_KERNEL);\n\tif (!elr)\n\t\treturn NULL;\n\n\telr->lr_super = sb;\n\telr->lr_sbi = sbi;\n\telr->lr_next_group = start;\n\n\t/*\n\t * Randomize first schedule time of the request to\n\t * spread the inode table initialization requests\n\t * better.\n\t */\n\tget_random_bytes(&rnd, sizeof(rnd));\n\telr->lr_next_sched = jiffies + (unsigned long)rnd %\n\t\t\t     (EXT4_DEF_LI_MAX_START_DELAY * HZ);\n\n\treturn elr;\n}\n- atomic_add: static inline void atomic_add(int i, atomic_t *v) /* <=== atomic_add */ \n{\n\tatomic_add_return(i, v);\n}\n- percpu_counter_set: static inline void percpu_counter_set(struct percpu_counter *fbc, s64 amount) /* <=== percpu_counter_set */ \n{\n\tfbc->count = amount;\n}\n- EXT4_DEFM_BLOCK_VALIDITY: #define EXT4_DEFM_BLOCK_VALIDITY 0x0200 /* <=== fs/ext4/ext4.h:1390:1390:EXT4_DEFM_BLOCK_VALIDITY:0 */ \n- memcpy: extern void *memcpy(void *to, const void *from, size_t len); /* <=== memcpy */ \n- EXT4_MIN_DESC_SIZE: #define EXT4_MIN_DESC_SIZE\t\t32 /* <=== fs/ext4/ext4.h:299:299:EXT4_MIN_DESC_SIZE:0 */ \n- EXT4_DEF_MAX_BATCH_TIME: #define EXT4_DEF_MAX_BATCH_TIME\t15000 /* 15ms */ /* <=== fs/ext4/ext4.h:1398:1398:EXT4_DEF_MAX_BATCH_TIME:0 */ \n- simple_strtoul: static inline unsigned long /* <=== simple_strtoul */ \nsimple_strtoul(const char *nptr, char **endptr, int base)\n{\n\treturn strtoul(nptr, endptr, base);\n}\n- ext4_free_inodes_count: __u32 ext4_free_inodes_count(struct super_block *sb, /* <=== ext4_free_inodes_count */ \n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le16_to_cpu(bg->bg_free_inodes_count_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (__u32)le16_to_cpu(bg->bg_free_inodes_count_hi) << 16 : 0);\n}\n- vzalloc: extern void *vzalloc(unsigned long size); /* <=== vzalloc */ \n- atomic_add: static inline void atomic_add(int i, atomic_t *v) /* <=== atomic_add */ \n{\n\t__asm__ __volatile__(\"addl %1,%0\" : \"+m\" (*v) : ASM_DI (i));\n}\n- IS_EXT3_SB: #define IS_EXT3_SB(sb) (0) /* <=== fs/ext4/super.c:93:93:IS_EXT3_SB:1 */ \n- EXT4_MIN_DESC_SIZE_64BIT: #define EXT4_MIN_DESC_SIZE_64BIT\t64 /* <=== fs/ext4/ext4.h:300:300:EXT4_MIN_DESC_SIZE_64BIT:0 */ \n- EXT4_MOUNT_JOURNAL_DATA: #define EXT4_MOUNT_JOURNAL_DATA\t\t0x00400\t/* Write data to journal */ /* <=== fs/ext4/ext4.h:889:889:EXT4_MOUNT_JOURNAL_DATA:0 */ \n- EXT4_ADDR_PER_BLOCK: #define\tEXT4_ADDR_PER_BLOCK(s)\t\t(EXT4_BLOCK_SIZE(s) / sizeof(__u32)) /* <=== fs/ext4/ext4.h:237:237:EXT4_ADDR_PER_BLOCK:1 */ \n- EXT4_DEFM_UID16: #define EXT4_DEFM_UID16\t\t0x0010 /* <=== fs/ext4/ext4.h:1384:1384:EXT4_DEFM_UID16:0 */ \n- kfree: void kfree(const void *); /* <=== kfree */ \n- EXT4_DEFM_DISCARD: #define EXT4_DEFM_DISCARD\t0x0400 /* <=== fs/ext4/ext4.h:1391:1391:EXT4_DEFM_DISCARD:0 */ \n- EXT4_ERRORS_PANIC: #define EXT4_ERRORS_PANIC\t\t3\t/* Panic */ /* <=== fs/ext4/ext4.h:946:946:EXT4_ERRORS_PANIC:0 */ \n- EXT4_MAX_DESC_SIZE: #define\tEXT4_MAX_DESC_SIZE\t\tEXT4_MIN_BLOCK_SIZE /* <=== fs/ext4/ext4.h:301:301:EXT4_MAX_DESC_SIZE:0 */ \n- kmem_cache_free: void kmem_cache_free(struct kmem_cache *, void *); /* <=== kmem_cache_free */ \n- EXT4_MOUNT_ORDERED_DATA: #define EXT4_MOUNT_ORDERED_DATA\t\t0x00800\t/* Flush data before commit */ /* <=== fs/ext4/ext4.h:890:890:EXT4_MOUNT_ORDERED_DATA:0 */ \n- EXT4_VALID_FS: #define\tEXT4_VALID_FS\t\t\t0x0001\t/* Unmounted cleanly */ /* <=== fs/ext4/ext4.h:866:866:EXT4_VALID_FS:0 */ \n- ext4_li_info_new: static int ext4_li_info_new(void) /* <=== ext4_li_info_new */ \n{\n\tstruct ext4_lazy_init *eli = NULL;\n\n\teli = kzalloc(sizeof(*eli), GFP_KERNEL);\n\tif (!eli)\n\t\treturn -ENOMEM;\n\n\teli->li_task = NULL;\n\tINIT_LIST_HEAD(&eli->li_request_list);\n\tmutex_init(&eli->li_list_mtx);\n\n\tinit_waitqueue_head(&eli->li_wait_daemon);\n\tinit_waitqueue_head(&eli->li_wait_task);\n\tinit_timer(&eli->li_timer);\n\teli->li_state |= EXT4_LAZYINIT_QUIT;\n\n\text4_li_info = eli;\n\n\treturn 0;\n}\n- ext4_group_desc_csum_verify: int ext4_group_desc_csum_verify(struct ext4_sb_info *sbi, __u32 block_group, /* <=== ext4_group_desc_csum_verify */ \n\t\t\t\tstruct ext4_group_desc *gdp)\n{\n\tif ((sbi->s_es->s_feature_ro_compat &\n\t     cpu_to_le32(EXT4_FEATURE_RO_COMPAT_GDT_CSUM)) &&\n\t    (gdp->bg_checksum != ext4_group_desc_csum(sbi, block_group, gdp)))\n\t\treturn 0;\n\n\treturn 1;\n}\n- descriptor_loc: static ext4_fsblk_t descriptor_loc(struct super_block *sb, /* <=== descriptor_loc */ \n\t\t\t\t   ext4_fsblk_t logical_sb_block, int nr)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_group_t bg, first_meta_bg;\n\tint has_super = 0;\n\n\tfirst_meta_bg = le32_to_cpu(sbi->s_es->s_first_meta_bg);\n\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_META_BG) ||\n\t    nr < first_meta_bg)\n\t\treturn logical_sb_block + nr + 1;\n\tbg = sbi->s_desc_per_block * nr;\n\tif (ext4_bg_has_super(sb, bg))\n\t\thas_super = 1;\n\n\treturn (has_super + ext4_group_first_block_no(sb, bg));\n}\n- ext4_mark_recovery_complete: static void ext4_mark_recovery_complete(struct super_block *sb, /* <=== ext4_mark_recovery_complete */ \n\t\t\t\t\tstruct ext4_super_block *es)\n{\n\tjournal_t *journal = EXT4_SB(sb)->s_journal;\n\n\tif (!EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL)) {\n\t\tBUG_ON(journal != NULL);\n\t\treturn;\n\t}\n\tjbd2_journal_lock_updates(journal);\n\tif (jbd2_journal_flush(journal) < 0)\n\t\tgoto out;\n\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER) &&\n\t    sb->s_flags & MS_RDONLY) {\n\t\tEXT4_CLEAR_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER);\n\t\text4_commit_super(sb, 1);\n\t}\n\nout:\n\tjbd2_journal_unlock_updates(journal);\n}\n- MB_DEFAULT_STATS: #define MB_DEFAULT_STATS\t\t0 /* <=== fs/ext4/mballoc.h:76:76:MB_DEFAULT_STATS:0 */ \n- ext4_get_dev_journal: static journal_t *ext4_get_dev_journal(struct super_block *sb, /* <=== ext4_get_dev_journal */ \n\t\t\t\t       dev_t j_dev)\n{\n\tstruct buffer_head *bh;\n\tjournal_t *journal;\n\text4_fsblk_t start;\n\text4_fsblk_t len;\n\tint hblock, blocksize;\n\text4_fsblk_t sb_block;\n\tunsigned long offset;\n\tstruct ext4_super_block *es;\n\tstruct block_device *bdev;\n\n\tBUG_ON(!EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL));\n\n\tbdev = ext4_blkdev_get(j_dev, sb);\n\tif (bdev == NULL)\n\t\treturn NULL;\n\n\tblocksize = sb->s_blocksize;\n\thblock = bdev_logical_block_size(bdev);\n\tif (blocksize < hblock) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t\"blocksize too small for journal device\");\n\t\tgoto out_bdev;\n\t}\n\n\tsb_block = EXT4_MIN_BLOCK_SIZE / blocksize;\n\toffset = EXT4_MIN_BLOCK_SIZE % blocksize;\n\tset_blocksize(bdev, blocksize);\n\tif (!(bh = __bread(bdev, sb_block, blocksize))) {\n\t\text4_msg(sb, KERN_ERR, \"couldn't read superblock of \"\n\t\t       \"external journal\");\n\t\tgoto out_bdev;\n\t}\n\n\tes = (struct ext4_super_block *) (((char *)bh->b_data) + offset);\n\tif ((le16_to_cpu(es->s_magic) != EXT4_SUPER_MAGIC) ||\n\t    !(le32_to_cpu(es->s_feature_incompat) &\n\t      EXT4_FEATURE_INCOMPAT_JOURNAL_DEV)) {\n\t\text4_msg(sb, KERN_ERR, \"external journal has \"\n\t\t\t\t\t\"bad superblock\");\n\t\tbrelse(bh);\n\t\tgoto out_bdev;\n\t}\n\n\tif (memcmp(EXT4_SB(sb)->s_es->s_journal_uuid, es->s_uuid, 16)) {\n\t\text4_msg(sb, KERN_ERR, \"journal UUID does not match\");\n\t\tbrelse(bh);\n\t\tgoto out_bdev;\n\t}\n\n\tlen = ext4_blocks_count(es);\n\tstart = sb_block + 1;\n\tbrelse(bh);\t/* we're done with the superblock */\n\n\tjournal = jbd2_journal_init_dev(bdev, sb->s_bdev,\n\t\t\t\t\tstart, len, blocksize);\n\tif (!journal) {\n\t\text4_msg(sb, KERN_ERR, \"failed to create device journal\");\n\t\tgoto out_bdev;\n\t}\n\tjournal->j_private = sb;\n\tll_rw_block(READ, 1, &journal->j_sb_buffer);\n\twait_on_buffer(journal->j_sb_buffer);\n\tif (!buffer_uptodate(journal->j_sb_buffer)) {\n\t\text4_msg(sb, KERN_ERR, \"I/O error on journal device\");\n\t\tgoto out_journal;\n\t}\n\tif (be32_to_cpu(journal->j_superblock->s_nr_users) != 1) {\n\t\text4_msg(sb, KERN_ERR, \"External journal has more than one \"\n\t\t\t\t\t\"user (unsupported) - %d\",\n\t\t\tbe32_to_cpu(journal->j_superblock->s_nr_users));\n\t\tgoto out_journal;\n\t}\n\tEXT4_SB(sb)->journal_bdev = bdev;\n\text4_init_journal_params(sb, journal);\n\treturn journal;\n\nout_journal:\n\tjbd2_journal_destroy(journal);\nout_bdev:\n\text4_blkdev_put(bdev);\n\treturn NULL;\n}\n- EXT4_DEFM_JMODE_DATA: #define EXT4_DEFM_JMODE_DATA\t0x0020 /* <=== fs/ext4/ext4.h:1386:1386:EXT4_DEFM_JMODE_DATA:0 */ \n- ext4_free_blks_count: __u32 ext4_free_blks_count(struct super_block *sb, /* <=== ext4_free_blks_count */ \n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le16_to_cpu(bg->bg_free_blocks_count_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (__u32)le16_to_cpu(bg->bg_free_blocks_count_hi) << 16 : 0);\n}\n- EXT4_HAS_COMPAT_FEATURE: #define EXT4_HAS_COMPAT_FEATURE(sb,mask)\t\t\t\\ /* <=== fs/ext4/ext4.h:1308:1309:EXT4_HAS_COMPAT_FEATURE:2 */ \n\t((EXT4_SB(sb)->s_es->s_feature_compat & cpu_to_le32(mask)) != 0)\n- MB_DEFAULT_MAX_TO_SCAN: #define MB_DEFAULT_MAX_TO_SCAN\t\t200 /* <=== fs/ext4/mballoc.h:60:60:MB_DEFAULT_MAX_TO_SCAN:0 */ \n- EXT4_FEATURE_RO_COMPAT_SUPP: #define EXT4_FEATURE_RO_COMPAT_SUPP\t(EXT4_FEATURE_RO_COMPAT_SPARSE_SUPER| \\ /* <=== fs/ext4/ext4.h:1361:1367:EXT4_FEATURE_RO_COMPAT_SUPP:0 */ \n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_LARGE_FILE| \\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_GDT_CSUM| \\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_DIR_NLINK | \\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_EXTRA_ISIZE | \\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_BTREE_DIR |\\\n\t\t\t\t\t EXT4_FEATURE_RO_COMPAT_HUGE_FILE)\n- EXT4_DEFM_JMODE_ORDERED: #define EXT4_DEFM_JMODE_ORDERED\t0x0040 /* <=== fs/ext4/ext4.h:1387:1387:EXT4_DEFM_JMODE_ORDERED:0 */ \n- EXT4_ORPHAN_FS: #define\tEXT4_ORPHAN_FS\t\t\t0x0004\t/* Orphans being recovered */ /* <=== fs/ext4/ext4.h:868:868:EXT4_ORPHAN_FS:0 */ \n- EXT4_DESC_PER_BLOCK: # define EXT4_DESC_PER_BLOCK(s)\t\t(EXT4_BLOCK_SIZE(s) / EXT4_DESC_SIZE(s)) /* <=== fs/ext4/ext4.h:310:310:EXT4_DESC_PER_BLOCK:1 */ \n- atomic_add: static __inline__ void atomic_add(int i, atomic_t * v) /* <=== atomic_add */ \n{\n\tunsigned long temp;\n\t__asm__ __volatile__(\n\t\"1:\tldl_l %0,%1\\n\"\n\t\"\taddl %0,%2,%0\\n\"\n\t\"\tstl_c %0,%1\\n\"\n\t\"\tbeq %0,2f\\n\"\n\t\".subsection 2\\n\"\n\t\"2:\tbr 1b\\n\"\n\t\".previous\"\n\t:\"=&r\" (temp), \"=m\" (v->counter)\n\t:\"Ir\" (i), \"m\" (v->counter));\n}\n- EXT4_DEFM_JMODE_WBACK: #define EXT4_DEFM_JMODE_WBACK\t0x0060 /* <=== fs/ext4/ext4.h:1388:1388:EXT4_DEFM_JMODE_WBACK:0 */ \n- proc_create_data: static inline struct proc_dir_entry *proc_create_data(const char *name, /* <=== proc_create_data */ \n\tmode_t mode, struct proc_dir_entry *parent,\n\tconst struct file_operations *proc_fops, void *data)\n{\n\treturn NULL;\n}\n- DEFAULT_JOURNAL_IOPRIO: #define DEFAULT_JOURNAL_IOPRIO (IOPRIO_PRIO_VALUE(IOPRIO_CLASS_BE, 3)) /* <=== fs/ext4/super.c:1364:1364:DEFAULT_JOURNAL_IOPRIO:0 */ \n- ext4_mb_init: int ext4_mb_init(struct super_block *sb, int needs_recovery) /* <=== ext4_mb_init */ \n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tunsigned i, j;\n\tunsigned offset;\n\tunsigned max;\n\tint ret;\n\n\ti = (sb->s_blocksize_bits + 2) * sizeof(*sbi->s_mb_offsets);\n\n\tsbi->s_mb_offsets = kmalloc(i, GFP_KERNEL);\n\tif (sbi->s_mb_offsets == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\ti = (sb->s_blocksize_bits + 2) * sizeof(*sbi->s_mb_maxs);\n\tsbi->s_mb_maxs = kmalloc(i, GFP_KERNEL);\n\tif (sbi->s_mb_maxs == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = ext4_groupinfo_create_slab(sb->s_blocksize);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* order 0 is regular bitmap */\n\tsbi->s_mb_maxs[0] = sb->s_blocksize << 3;\n\tsbi->s_mb_offsets[0] = 0;\n\n\ti = 1;\n\toffset = 0;\n\tmax = sb->s_blocksize << 2;\n\tdo {\n\t\tsbi->s_mb_offsets[i] = offset;\n\t\tsbi->s_mb_maxs[i] = max;\n\t\toffset += 1 << (sb->s_blocksize_bits - i);\n\t\tmax = max >> 1;\n\t\ti++;\n\t} while (i <= sb->s_blocksize_bits + 1);\n\n\t/* init file for buddy data */\n\tret = ext4_mb_init_backend(sb);\n\tif (ret != 0) {\n\t\tgoto out;\n\t}\n\n\tspin_lock_init(&sbi->s_md_lock);\n\tspin_lock_init(&sbi->s_bal_lock);\n\n\tsbi->s_mb_max_to_scan = MB_DEFAULT_MAX_TO_SCAN;\n\tsbi->s_mb_min_to_scan = MB_DEFAULT_MIN_TO_SCAN;\n\tsbi->s_mb_stats = MB_DEFAULT_STATS;\n\tsbi->s_mb_stream_request = MB_DEFAULT_STREAM_THRESHOLD;\n\tsbi->s_mb_order2_reqs = MB_DEFAULT_ORDER2_REQS;\n\tsbi->s_mb_group_prealloc = MB_DEFAULT_GROUP_PREALLOC;\n\n\tsbi->s_locality_groups = alloc_percpu(struct ext4_locality_group);\n\tif (sbi->s_locality_groups == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tfor_each_possible_cpu(i) {\n\t\tstruct ext4_locality_group *lg;\n\t\tlg = per_cpu_ptr(sbi->s_locality_groups, i);\n\t\tmutex_init(&lg->lg_mutex);\n\t\tfor (j = 0; j < PREALLOC_TB_SIZE; j++)\n\t\t\tINIT_LIST_HEAD(&lg->lg_prealloc_list[j]);\n\t\tspin_lock_init(&lg->lg_prealloc_lock);\n\t}\n\n\tif (sbi->s_proc)\n\t\tproc_create_data(\"mb_groups\", S_IRUGO, sbi->s_proc,\n\t\t\t\t &ext4_mb_seq_groups_fops, sb);\n\n\tif (sbi->s_journal)\n\t\tsbi->s_journal->j_commit_callback = release_blocks_on_commit;\nout:\n\tif (ret) {\n\t\tkfree(sbi->s_mb_offsets);\n\t\tkfree(sbi->s_mb_maxs);\n\t}\n\treturn ret;\n}\n- EXT4_HAS_RO_COMPAT_FEATURE: #define EXT4_HAS_RO_COMPAT_FEATURE(sb,mask)\t\t\t\\ /* <=== fs/ext4/ext4.h:1310:1311:EXT4_HAS_RO_COMPAT_FEATURE:2 */ \n\t((EXT4_SB(sb)->s_es->s_feature_ro_compat & cpu_to_le32(mask)) != 0)\n- EXT4_DEFM_BSDGROUPS: #define EXT4_DEFM_BSDGROUPS\t0x0002 /* <=== fs/ext4/ext4.h:1381:1381:EXT4_DEFM_BSDGROUPS:0 */ \n- INIT_LIST_HEAD: static inline void INIT_LIST_HEAD(struct list_head *list) /* <=== INIT_LIST_HEAD */ \n{\n\tlist->next = list;\n\tlist->prev = list;\n}\n- EXT4_MAX_BLOCK_FILE_PHYS: #define EXT4_MAX_BLOCK_FILE_PHYS\t0xFFFFFFFF /* <=== fs/ext4/ext4.h:565:565:EXT4_MAX_BLOCK_FILE_PHYS:0 */ \n- EXT4_DEFM_JMODE: #define EXT4_DEFM_JMODE\t\t0x0060 /* <=== fs/ext4/ext4.h:1385:1385:EXT4_DEFM_JMODE:0 */ \n- EXT4_DEF_RESGID: #define\tEXT4_DEF_RESGID\t\t0 /* <=== fs/ext4/ext4.h:1373:1373:EXT4_DEF_RESGID:0 */ \n- atomic_add: static inline void atomic_add(int i, atomic_t *v) /* <=== atomic_add */ \n{\n\tasm volatile(LOCK_PREFIX \"addl %1,%0\"\n\t\t     : \"+m\" (v->counter)\n\t\t     : \"ir\" (i));\n}\n- MB_DEFAULT_GROUP_PREALLOC: #define MB_DEFAULT_GROUP_PREALLOC\t512 /* <=== fs/ext4/mballoc.h:95:95:MB_DEFAULT_GROUP_PREALLOC:0 */ \n- match_token: int match_token(char *, const match_table_t table, substring_t args[]); /* <=== match_token */ \n- kzalloc: static inline void *kzalloc(size_t size, gfp_t flags) /* <=== kzalloc */ \n{\n\treturn kmalloc(size, flags | __GFP_ZERO);\n}\n- EXT4_INODE_SIZE: #define EXT4_INODE_SIZE(s)\t(((s)->s_rev_level == EXT4_GOOD_OLD_REV) ? \\ /* <=== fs/ext4/ext4.h:248:250:EXT4_INODE_SIZE:1 */ \n\t\t\t\t EXT4_GOOD_OLD_INODE_SIZE : \\\n\t\t\t\t (s)->s_inode_size)\n- ext4_run_lazyinit_thread: static int ext4_run_lazyinit_thread(void) /* <=== ext4_run_lazyinit_thread */ \n{\n\text4_lazyinit_task = kthread_run(ext4_lazyinit_thread,\n\t\t\t\t\t ext4_li_info, \"ext4lazyinit\");\n\tif (IS_ERR(ext4_lazyinit_task)) {\n\t\tint err = PTR_ERR(ext4_lazyinit_task);\n\t\text4_clear_request_list();\n\t\tdel_timer_sync(&ext4_li_info->li_timer);\n\t\tkfree(ext4_li_info);\n\t\text4_li_info = NULL;\n\t\tprintk(KERN_CRIT \"EXT4: error %d creating inode table \"\n\t\t\t\t \"initialization thread\\n\",\n\t\t\t\t err);\n\t\treturn err;\n\t}\n\text4_li_info->li_state |= EXT4_LAZYINIT_RUNNING;\n\n\twait_event(ext4_li_info->li_wait_task, ext4_li_info->li_task != NULL);\n\treturn 0;\n}\n- match_int: int match_int(substring_t *, int *result); /* <=== match_int */ \n- PLURAL: #define PLURAL(x) (x), ((x) == 1) ? \"\" : \"s\" /* <=== fs/ext4/super.c:2186:2186:PLURAL:1 */ \n- list_add: static inline void list_add(struct list_head *new, struct list_head *head) /* <=== list_add */ \n{\n\t__list_add(new, head, head->next);\n}\n- EXT4_MOUNT_WRITEBACK_DATA: #define EXT4_MOUNT_WRITEBACK_DATA\t0x00C00\t/* No data ordering */ /* <=== fs/ext4/ext4.h:891:891:EXT4_MOUNT_WRITEBACK_DATA:0 */ \n- get_groupinfo_cache: static struct kmem_cache *get_groupinfo_cache(int blocksize_bits) /* <=== get_groupinfo_cache */ \n{\n\tint cache_index = blocksize_bits - EXT4_MIN_BLOCK_LOG_SIZE;\n\tstruct kmem_cache *cachep = ext4_groupinfo_caches[cache_index];\n\n\tBUG_ON(!cachep);\n\treturn cachep;\n}\n- mutex_unlock: extern void mutex_unlock(struct mutex *lock); /* <=== mutex_unlock */ \n- MB_DEFAULT_ORDER2_REQS: #define MB_DEFAULT_ORDER2_REQS\t\t2 /* <=== fs/ext4/mballoc.h:90:90:MB_DEFAULT_ORDER2_REQS:0 */ \n- ext4_blkdev_put: static int ext4_blkdev_put(struct block_device *bdev) /* <=== ext4_blkdev_put */ \n{\n\treturn blkdev_put(bdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);\n}\n- EXT4_ERRORS_CONTINUE: #define EXT4_ERRORS_CONTINUE\t\t1\t/* Continue execution */ /* <=== fs/ext4/ext4.h:944:944:EXT4_ERRORS_CONTINUE:0 */ \n- atomic_add: static __inline__ void atomic_add(int i, atomic_t * v) /* <=== atomic_add */ \n{\n\tif (kernel_uses_llsc && R10000_LLSC_WAR) {\n\t\tint temp;\n\n\t\t__asm__ __volatile__(\n\t\t\"\t.set\tmips3\t\t\t\t\t\\n\"\n\t\t\"1:\tll\t%0, %1\t\t# atomic_add\t\t\\n\"\n\t\t\"\taddu\t%0, %2\t\t\t\t\t\\n\"\n\t\t\"\tsc\t%0, %1\t\t\t\t\t\\n\"\n\t\t\"\tbeqzl\t%0, 1b\t\t\t\t\t\\n\"\n\t\t\"\t.set\tmips0\t\t\t\t\t\\n\"\n\t\t: \"=&r\" (temp), \"=m\" (v->counter)\n\t\t: \"Ir\" (i), \"m\" (v->counter));\n\t} else if (kernel_uses_llsc) {\n\t\tint temp;\n\n\t\tdo {\n\t\t\t__asm__ __volatile__(\n\t\t\t\"\t.set\tmips3\t\t\t\t\\n\"\n\t\t\t\"\tll\t%0, %1\t\t# atomic_add\t\\n\"\n\t\t\t\"\taddu\t%0, %2\t\t\t\t\\n\"\n\t\t\t\"\tsc\t%0, %1\t\t\t\t\\n\"\n\t\t\t\"\t.set\tmips0\t\t\t\t\\n\"\n\t\t\t: \"=&r\" (temp), \"=m\" (v->counter)\n\t\t\t: \"Ir\" (i), \"m\" (v->counter));\n\t\t} while (unlikely(!temp));\n\t} else {\n\t\tunsigned long flags;\n\n\t\traw_local_irq_save(flags);\n\t\tv->counter += i;\n\t\traw_local_irq_restore(flags);\n\t}\n}\n- MB_DEFAULT_MIN_TO_SCAN: #define MB_DEFAULT_MIN_TO_SCAN\t\t10 /* <=== fs/ext4/mballoc.h:65:65:MB_DEFAULT_MIN_TO_SCAN:0 */ \n- EXT4_DESC_SIZE: #define EXT4_DESC_SIZE(s)\t\t(EXT4_SB(s)->s_desc_size) /* <=== fs/ext4/ext4.h:302:302:EXT4_DESC_SIZE:1 */ \n- is_power_of_2: static inline __attribute__((const)) /* <=== is_power_of_2 */ \nbool is_power_of_2(unsigned long n)\n{\n\treturn (n != 0 && ((n & (n - 1)) == 0));\n}\n- PREALLOC_TB_SIZE: #define PREALLOC_TB_SIZE 10 /* <=== fs/ext4/mballoc.h:155:155:PREALLOC_TB_SIZE:0 */ \n- vfree: extern void vfree(const void *addr); /* <=== vfree */ \n- percpu_counter_destroy: static inline void percpu_counter_destroy(struct percpu_counter *fbc) /* <=== percpu_counter_destroy */ \n{\n}\n- ext4_max_size: static loff_t ext4_max_size(int blkbits, int has_huge_files) /* <=== ext4_max_size */ \n{\n\tloff_t res;\n\tloff_t upper_limit = MAX_LFS_FILESIZE;\n\n\t/* small i_blocks in vfs inode? */\n\tif (!has_huge_files || sizeof(blkcnt_t) < sizeof(u64)) {\n\t\t/*\n\t\t * CONFIG_LBDAF is not enabled implies the inode\n\t\t * i_block represent total blocks in 512 bytes\n\t\t * 32 == size of vfs inode i_blocks * 8\n\t\t */\n\t\tupper_limit = (1LL << 32) - 1;\n\n\t\t/* total blocks in file system block size */\n\t\tupper_limit >>= (blkbits - 9);\n\t\tupper_limit <<= blkbits;\n\t}\n\n\t/* 32-bit extent-start container, ee_block */\n\tres = 1LL << 32;\n\tres <<= blkbits;\n\tres -= 1;\n\n\t/* Sanity check against vm- & vfs- imposed limits */\n\tif (res > upper_limit)\n\t\tres = upper_limit;\n\n\treturn res;\n}\n- ext4_max_bitmap_size: static loff_t ext4_max_bitmap_size(int bits, int has_huge_files) /* <=== ext4_max_bitmap_size */ \n{\n\tloff_t res = EXT4_NDIR_BLOCKS;\n\tint meta_blocks;\n\tloff_t upper_limit;\n\t/* This is calculated to be the largest file size for a dense, block\n\t * mapped file such that the file's total number of 512-byte sectors,\n\t * including data and all indirect blocks, does not exceed (2^48 - 1).\n\t *\n\t * __u32 i_blocks_lo and _u16 i_blocks_high represent the total\n\t * number of 512-byte sectors of the file.\n\t */\n\n\tif (!has_huge_files || sizeof(blkcnt_t) < sizeof(u64)) {\n\t\t/*\n\t\t * !has_huge_files or CONFIG_LBDAF not enabled implies that\n\t\t * the inode i_block field represents total file blocks in\n\t\t * 2^32 512-byte sectors == size of vfs inode i_blocks * 8\n\t\t */\n\t\tupper_limit = (1LL << 32) - 1;\n\n\t\t/* total blocks in file system block size */\n\t\tupper_limit >>= (bits - 9);\n\n\t} else {\n\t\t/*\n\t\t * We use 48 bit ext4_inode i_blocks\n\t\t * With EXT4_HUGE_FILE_FL set the i_blocks\n\t\t * represent total number of blocks in\n\t\t * file system block size\n\t\t */\n\t\tupper_limit = (1LL << 48) - 1;\n\n\t}\n\n\t/* indirect blocks */\n\tmeta_blocks = 1;\n\t/* double indirect blocks */\n\tmeta_blocks += 1 + (1LL << (bits-2));\n\t/* tripple indirect blocks */\n\tmeta_blocks += 1 + (1LL << (bits-2)) + (1LL << (2*(bits-2)));\n\n\tupper_limit -= meta_blocks;\n\tupper_limit <<= bits;\n\n\tres += 1LL << (bits-2);\n\tres += 1LL << (2*(bits-2));\n\tres += 1LL << (3*(bits-2));\n\tres <<= bits;\n\tif (res > upper_limit)\n\t\tres = upper_limit;\n\n\tif (res > MAX_LFS_FILESIZE)\n\t\tres = MAX_LFS_FILESIZE;\n\n\treturn res;\n}\n- EXT4_MAX_BLOCK_SIZE: #define\tEXT4_MAX_BLOCK_SIZE\t\t65536 /* <=== fs/ext4/ext4.h:229:229:EXT4_MAX_BLOCK_SIZE:0 */ \n- EXT4_ROOT_INO: #define EXT4_ROOT_INO\t\t 2\t/* Root inode */ /* <=== fs/ext4/ext4.h:211:211:EXT4_ROOT_INO:0 */ \n- EXT4_FEATURE_INCOMPAT_SUPP: #define EXT4_FEATURE_INCOMPAT_SUPP\t(EXT4_FEATURE_INCOMPAT_FILETYPE| \\ /* <=== fs/ext4/ext4.h:1355:1360:EXT4_FEATURE_INCOMPAT_SUPP:0 */ \n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_RECOVER| \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_META_BG| \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_EXTENTS| \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_64BIT| \\\n\t\t\t\t\t EXT4_FEATURE_INCOMPAT_FLEX_BG)\n- ext4_get_stripe_size: static unsigned long ext4_get_stripe_size(struct ext4_sb_info *sbi) /* <=== ext4_get_stripe_size */ \n{\n\tunsigned long stride = le16_to_cpu(sbi->s_es->s_raid_stride);\n\tunsigned long stripe_width =\n\t\t\tle32_to_cpu(sbi->s_es->s_raid_stripe_width);\n\n\tif (sbi->s_stripe && sbi->s_stripe <= sbi->s_blocks_per_group)\n\t\treturn sbi->s_stripe;\n\n\tif (stripe_width <= sbi->s_blocks_per_group)\n\t\treturn stripe_width;\n\n\tif (stride <= sbi->s_blocks_per_group)\n\t\treturn stride;\n\n\treturn 0;\n}\n- destroy_workqueue: extern void destroy_workqueue(struct workqueue_struct *wq); /* <=== destroy_workqueue */ \n- EXT4_BLOCKS_PER_GROUP: # define EXT4_BLOCKS_PER_GROUP(s)\t((s)->s_blocks_per_group) /* <=== fs/ext4/ext4.h:309:309:EXT4_BLOCKS_PER_GROUP:1 */ \n- ext4_load_journal: static int ext4_load_journal(struct super_block *sb, /* <=== ext4_load_journal */ \n\t\t\t     struct ext4_super_block *es,\n\t\t\t     unsigned long journal_devnum)\n{\n\tjournal_t *journal;\n\tunsigned int journal_inum = le32_to_cpu(es->s_journal_inum);\n\tdev_t journal_dev;\n\tint err = 0;\n\tint really_read_only;\n\n\tBUG_ON(!EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL));\n\n\tif (journal_devnum &&\n\t    journal_devnum != le32_to_cpu(es->s_journal_dev)) {\n\t\text4_msg(sb, KERN_INFO, \"external journal device major/minor \"\n\t\t\t\"numbers have changed\");\n\t\tjournal_dev = new_decode_dev(journal_devnum);\n\t} else\n\t\tjournal_dev = new_decode_dev(le32_to_cpu(es->s_journal_dev));\n\n\treally_read_only = bdev_read_only(sb->s_bdev);\n\n\t/*\n\t * Are we loading a blank journal or performing recovery after a\n\t * crash?  For recovery, we need to check in advance whether we\n\t * can get read-write access to the device.\n\t */\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER)) {\n\t\tif (sb->s_flags & MS_RDONLY) {\n\t\t\text4_msg(sb, KERN_INFO, \"INFO: recovery \"\n\t\t\t\t\t\"required on readonly filesystem\");\n\t\t\tif (really_read_only) {\n\t\t\t\text4_msg(sb, KERN_ERR, \"write access \"\n\t\t\t\t\t\"unavailable, cannot proceed\");\n\t\t\t\treturn -EROFS;\n\t\t\t}\n\t\t\text4_msg(sb, KERN_INFO, \"write access will \"\n\t\t\t       \"be enabled during recovery\");\n\t\t}\n\t}\n\n\tif (journal_inum && journal_dev) {\n\t\text4_msg(sb, KERN_ERR, \"filesystem has both journal \"\n\t\t       \"and inode journals!\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (journal_inum) {\n\t\tif (!(journal = ext4_get_journal(sb, journal_inum)))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (!(journal = ext4_get_dev_journal(sb, journal_dev)))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!(journal->j_flags & JBD2_BARRIER))\n\t\text4_msg(sb, KERN_INFO, \"barriers disabled\");\n\n\tif (!really_read_only && test_opt(sb, UPDATE_JOURNAL)) {\n\t\terr = jbd2_journal_update_format(journal);\n\t\tif (err)  {\n\t\t\text4_msg(sb, KERN_ERR, \"error updating journal\");\n\t\t\tjbd2_journal_destroy(journal);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (!EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER))\n\t\terr = jbd2_journal_wipe(journal, !really_read_only);\n\tif (!err) {\n\t\tchar *save = kmalloc(EXT4_S_ERR_LEN, GFP_KERNEL);\n\t\tif (save)\n\t\t\tmemcpy(save, ((char *) es) +\n\t\t\t       EXT4_S_ERR_START, EXT4_S_ERR_LEN);\n\t\terr = jbd2_journal_load(journal);\n\t\tif (save)\n\t\t\tmemcpy(((char *) es) + EXT4_S_ERR_START,\n\t\t\t       save, EXT4_S_ERR_LEN);\n\t\tkfree(save);\n\t}\n\n\tif (err) {\n\t\text4_msg(sb, KERN_ERR, \"error loading journal\");\n\t\tjbd2_journal_destroy(journal);\n\t\treturn err;\n\t}\n\n\tEXT4_SB(sb)->s_journal = journal;\n\text4_clear_journal_err(sb, es);\n\n\tif (!really_read_only && journal_devnum &&\n\t    journal_devnum != le32_to_cpu(es->s_journal_dev)) {\n\t\tes->s_journal_dev = cpu_to_le32(journal_devnum);\n\n\t\t/* Make sure we flush the recovery flag to disk. */\n\t\text4_commit_super(sb, 1);\n\t}\n\n\treturn 0;\n}\n\nType Definitions:\n- kobj_type: struct kobj_type {\n\tvoid (*release)(struct kobject *kobj);\n\tconst struct sysfs_ops *sysfs_ops;\n\tstruct attribute **default_attrs;\n\tconst struct kobj_ns_type_operations *(*child_ns_type)(struct kobject *kobj);\n\tconst void *(*namespace)(struct kobject *kobj);\n}\n- super_operations: static const struct super_operations\n- ext4_super_block: struct ext4_super_block {\n/*00*/\t__le32\ts_inodes_count;\t\t/* Inodes count */\n\t__le32\ts_blocks_count_lo;\t/* Blocks count */\n\t__le32\ts_r_blocks_count_lo;\t/* Reserved blocks count */\n\t__le32\ts_free_blocks_count_lo;\t/* Free blocks count */\n/*10*/\t__le32\ts_free_inodes_count;\t/* Free inodes count */\n\t__le32\ts_first_data_block;\t/* First Data Block */\n\t__le32\ts_log_block_size;\t/* Block size */\n\t__le32\ts_obso_log_frag_size;\t/* Obsoleted fragment size */\n/*20*/\t__le32\ts_blocks_per_group;\t/* # Blocks per group */\n\t__le32\ts_obso_frags_per_group;\t/* Obsoleted fragments per group */\n\t__le32\ts_inodes_per_group;\t/* # Inodes per group */\n\t__le32\ts_mtime;\t\t/* Mount time */\n/*30*/\t__le32\ts_wtime;\t\t/* Write time */\n\t__le16\ts_mnt_count;\t\t/* Mount count */\n\t__le16\ts_max_mnt_count;\t/* Maximal mount count */\n\t__le16\ts_magic;\t\t/* Magic signature */\n\t__le16\ts_state;\t\t/* File system state */\n\t__le16\ts_errors;\t\t/* Behaviour when detecting errors */\n\t__le16\ts_minor_rev_level;\t/* minor revision level */\n/*40*/\t__le32\ts_lastcheck;\t\t/* time of last check */\n\t__le32\ts_checkinterval;\t/* max. time between checks */\n\t__le32\ts_creator_os;\t\t/* OS */\n\t__le32\ts_rev_level;\t\t/* Revision level */\n/*50*/\t__le16\ts_def_resuid;\t\t/* Default uid for reserved blocks */\n\t__le16\ts_def_resgid;\t\t/* Default gid for reserved blocks */\n\t/*\n\t * These fields are for EXT4_DYNAMIC_REV superblocks only.\n\t *\n\t * Note: the difference between the compatible feature set and\n\t * the incompatible feature set is that if there is a bit set\n\t * in the incompatible feature set that the kernel doesn't\n\t * know about, it should refuse to mount the filesystem.\n\t *\n\t * e2fsck's requirements are more strict; if it doesn't know\n\t * about a feature in either the compatible or incompatible\n\t * feature set, it must abort and not try to meddle with\n\t * things it doesn't understand...\n\t */\n\t__le32\ts_first_ino;\t\t/* First non-reserved inode */\n\t__le16  s_inode_size;\t\t/* size of inode structure */\n\t__le16\ts_block_group_nr;\t/* block group # of this superblock */\n\t__le32\ts_feature_compat;\t/* compatible feature set */\n/*60*/\t__le32\ts_feature_incompat;\t/* incompatible feature set */\n\t__le32\ts_feature_ro_compat;\t/* readonly-compatible feature set */\n/*68*/\t__u8\ts_uuid[16];\t\t/* 128-bit uuid for volume */\n/*78*/\tchar\ts_volume_name[16];\t/* volume name */\n/*88*/\tchar\ts_last_mounted[64];\t/* directory where last mounted */\n/*C8*/\t__le32\ts_algorithm_usage_bitmap; /* For compression */\n\t/*\n\t * Performance hints.  Directory preallocation should only\n\t * happen if the EXT4_FEATURE_COMPAT_DIR_PREALLOC flag is on.\n\t */\n\t__u8\ts_prealloc_blocks;\t/* Nr of blocks to try to preallocate*/\n\t__u8\ts_prealloc_dir_blocks;\t/* Nr to preallocate for dirs */\n\t__le16\ts_reserved_gdt_blocks;\t/* Per group desc for online growth */\n\t/*\n\t * Journaling support valid if EXT4_FEATURE_COMPAT_HAS_JOURNAL set.\n\t */\n/*D0*/\t__u8\ts_journal_uuid[16];\t/* uuid of journal superblock */\n/*E0*/\t__le32\ts_journal_inum;\t\t/* inode number of journal file */\n\t__le32\ts_journal_dev;\t\t/* device number of journal file */\n\t__le32\ts_last_orphan;\t\t/* start of list of inodes to delete */\n\t__le32\ts_hash_seed[4];\t\t/* HTREE hash seed */\n\t__u8\ts_def_hash_version;\t/* Default hash version to use */\n\t__u8\ts_jnl_backup_type;\n\t__le16  s_desc_size;\t\t/* size of group descriptor */\n/*100*/\t__le32\ts_default_mount_opts;\n\t__le32\ts_first_meta_bg;\t/* First metablock block group */\n\t__le32\ts_mkfs_time;\t\t/* When the filesystem was created */\n\t__le32\ts_jnl_blocks[17];\t/* Backup of the journal inode */\n\t/* 64bit support valid if EXT4_FEATURE_COMPAT_64BIT */\n/*150*/\t__le32\ts_blocks_count_hi;\t/* Blocks count */\n\t__le32\ts_r_blocks_count_hi;\t/* Reserved blocks count */\n\t__le32\ts_free_blocks_count_hi;\t/* Free blocks count */\n\t__le16\ts_min_extra_isize;\t/* All inodes have at least # bytes */\n\t__le16\ts_want_extra_isize; \t/* New inodes should reserve # bytes */\n\t__le32\ts_flags;\t\t/* Miscellaneous flags */\n\t__le16  s_raid_stride;\t\t/* RAID stride */\n\t__le16  s_mmp_interval;         /* # seconds to wait in MMP checking */\n\t__le64  s_mmp_block;            /* Block for multi-mount protection */\n\t__le32  s_raid_stripe_width;    /* blocks on all data disks (N*stride)*/\n\t__u8\ts_log_groups_per_flex;  /* FLEX_BG group size */\n\t__u8\ts_reserved_char_pad;\n\t__le16  s_reserved_pad;\n\t__le64\ts_kbytes_written;\t/* nr of lifetime kilobytes written */\n\t__le32\ts_snapshot_inum;\t/* Inode number of active snapshot */\n\t__le32\ts_snapshot_id;\t\t/* sequential ID of active snapshot */\n\t__le64\ts_snapshot_r_blocks_count; /* reserved blocks for active\n\t\t\t\t\t      snapshot's future use */\n\t__le32\ts_snapshot_list;\t/* inode number of the head of the\n\t\t\t\t\t   on-disk snapshot list */\n#define EXT4_S_ERR_START offsetof(struct ext4_super_block, s_error_count)\n\t__le32\ts_error_count;\t\t/* number of fs errors */\n\t__le32\ts_first_error_time;\t/* first time an error happened */\n\t__le32\ts_first_error_ino;\t/* inode involved in first error */\n\t__le64\ts_first_error_block;\t/* block involved of first error */\n\t__u8\ts_first_error_func[32];\t/* function where the error happened */\n\t__le32\ts_first_error_line;\t/* line number where error happened */\n\t__le32\ts_last_error_time;\t/* most recent time of an error */\n\t__le32\ts_last_error_ino;\t/* inode involved in last error */\n\t__le32\ts_last_error_line;\t/* line number where error happened */\n\t__le64\ts_last_error_block;\t/* block involved of last error */\n\t__u8\ts_last_error_func[32];\t/* function where the error happened */\n#define EXT4_S_ERR_END offsetof(struct ext4_super_block, s_mount_opts)\n\t__u8\ts_mount_opts[64];\n\t__le32\ts_reserved[112];        /* Padding to the end of the block */\n}\n- proc_dir_entry: struct proc_dir_entry {\n\tunsigned int low_ino;\n\tunsigned int namelen;\n\tconst char *name;\n\tmode_t mode;\n\tnlink_t nlink;\n\tuid_t uid;\n\tgid_t gid;\n\tloff_t size;\n\tconst struct inode_operations *proc_iops;\n\t/*\n\t * NULL ->proc_fops means \"PDE is going away RSN\" or\n\t * \"PDE is just created\". In either case, e.g. ->read_proc won't be\n\t * called because it's too late or too early, respectively.\n\t *\n\t * If you're allocating ->proc_fops dynamically, save a pointer\n\t * somewhere.\n\t */\n\tconst struct file_operations *proc_fops;\n\tstruct proc_dir_entry *next, *parent, *subdir;\n\tvoid *data;\n\tread_proc_t *read_proc;\n\twrite_proc_t *write_proc;\n\tatomic_t count;\t\t/* use count */\n\tint pde_users;\t/* number of callers into module in progress */\n\tspinlock_t pde_unload_lock; /* proc_fops checks and pde_users bumps */\n\tstruct completion *pde_unload_completion;\n\tstruct list_head pde_openers;\t/* who did ->open, but not ->release */\n}\n- kset: struct kset {\n\tstruct list_head list;\n\tspinlock_t list_lock;\n\tstruct kobject kobj;\n\tconst struct kset_uevent_ops *uevent_ops;\n}\n- ext4_fsblk_t: typedef unsigned long long ext4_fsblk_t;\n- blockgroup_lock: struct blockgroup_lock {\n\tstruct bgl_lock locks[NR_BG_LOCKS];\n}\n- inode: struct inode\n- ext4_group_t: typedef unsigned int ext4_group_t;\n- buffer_head: static struct buffer_head\n- ext4_inode: struct ext4_inode {\n\t__le16\ti_mode;\t\t/* File mode */\n\t__le16\ti_uid;\t\t/* Low 16 bits of Owner Uid */\n\t__le32\ti_size_lo;\t/* Size in bytes */\n\t__le32\ti_atime;\t/* Access time */\n\t__le32\ti_ctime;\t/* Inode Change time */\n\t__le32\ti_mtime;\t/* Modification time */\n\t__le32\ti_dtime;\t/* Deletion Time */\n\t__le16\ti_gid;\t\t/* Low 16 bits of Group Id */\n\t__le16\ti_links_count;\t/* Links count */\n\t__le32\ti_blocks_lo;\t/* Blocks count */\n\t__le32\ti_flags;\t/* File flags */\n\tunion {\n\t\tstruct {\n\t\t\t__le32  l_i_version;\n\t\t} linux1;\n\t\tstruct {\n\t\t\t__u32  h_i_translator;\n\t\t} hurd1;\n\t\tstruct {\n\t\t\t__u32  m_i_reserved1;\n\t\t} masix1;\n\t} osd1;\t\t\t\t/* OS dependent 1 */\n\t__le32\ti_block[EXT4_N_BLOCKS];/* Pointers to blocks */\n\t__le32\ti_generation;\t/* File version (for NFS) */\n\t__le32\ti_file_acl_lo;\t/* File ACL */\n\t__le32\ti_size_high;\n\t__le32\ti_obso_faddr;\t/* Obsoleted fragment address */\n\tunion {\n\t\tstruct {\n\t\t\t__le16\tl_i_blocks_high; /* were l_i_reserved1 */\n\t\t\t__le16\tl_i_file_acl_high;\n\t\t\t__le16\tl_i_uid_high;\t/* these 2 fields */\n\t\t\t__le16\tl_i_gid_high;\t/* were reserved2[0] */\n\t\t\t__u32\tl_i_reserved2;\n\t\t} linux2;\n\t\tstruct {\n\t\t\t__le16\th_i_reserved1;\t/* Obsoleted fragment number/size which are removed in ext4 */\n\t\t\t__u16\th_i_mode_high;\n\t\t\t__u16\th_i_uid_high;\n\t\t\t__u16\th_i_gid_high;\n\t\t\t__u32\th_i_author;\n\t\t} hurd2;\n\t\tstruct {\n\t\t\t__le16\th_i_reserved1;\t/* Obsoleted fragment number/size which are removed in ext4 */\n\t\t\t__le16\tm_i_file_acl_high;\n\t\t\t__u32\tm_i_reserved2[2];\n\t\t} masix2;\n\t} osd2;\t\t\t\t/* OS dependent 2 */\n\t__le16\ti_extra_isize;\n\t__le16\ti_pad1;\n\t__le32  i_ctime_extra;  /* extra Change time      (nsec << 2 | epoch) */\n\t__le32  i_mtime_extra;  /* extra Modification time(nsec << 2 | epoch) */\n\t__le32  i_atime_extra;  /* extra Access time      (nsec << 2 | epoch) */\n\t__le32  i_crtime;       /* File Creation time */\n\t__le32  i_crtime_extra; /* extra FileCreationtime (nsec << 2 | epoch) */\n\t__le32  i_version_hi;\t/* high 32 bits for 64-bit version */\n}\n\nGlobal Variables:\n- struct kobj_type ext4_ktype\n- struct kset* ext4_kset\n- const struct super_operations ext4_sops\n- struct proc_dir_entry* ext4_proc_root\n- const struct super_operations ext4_nojournal_sops\n\nImports:\n- #include <linux/namei.h>\n- #include <linux/module.h>\n- #include <linux/blkdev.h>\n- #include \"xattr.h\"\n- #include <linux/ctype.h>\n- #include <linux/quotaops.h>\n- #include <linux/vfs.h>\n- #include <linux/seq_file.h>\n- #include <linux/slab.h>\n- #include <linux/log2.h>\n- #include <linux/string.h>\n- #include \"ext4.h\"\n- #include <linux/proc_fs.h>\n- #include <linux/random.h>\n- #include <linux/parser.h>\n- #include <linux/crc16.h>\n- #include <asm/uaccess.h>\n- #include <linux/time.h>\n- #include <trace/events/ext4.h>\n- #include \"mballoc.h\"\n- #include <linux/fs.h>\n- #include \"acl.h\"\n- #include <linux/init.h>\n- #include <linux/kthread.h>\n- #include <linux/buffer_head.h>\n- #include <linux/freezer.h>\n- #include <linux/vmalloc.h>\n- #include \"ext4_jbd2.h\"\n- #include <linux/jbd2.h>\n- #include <linux/exportfs.h>\n- #include <linux/mount.h>",
    "commit_msg": "ext4: init timer earlier to avoid a kernel panic in __save_error_info\n\nDuring mount, when we fail to open journal inode or root inode, the\n__save_error_info will mod_timer. But actually s_err_report isn't\ninitialized yet and the kernel oops. The detailed information can\nbe found https://bugzilla.kernel.org/show_bug.cgi?id=32082.\n\nThe best way is to check whether the timer s_err_report is initialized\nor not. But it seems that in include/linux/timer.h, we can't find a\ngood function to check the status of this timer, so this patch just\nmove the initializtion of s_err_report earlier so that we can avoid\nthe kernel panic. The corresponding del_timer is also added in the\nerror path.\n\nReported-by: Sami Liedes <sliedes@cc.hut.fi>\nSigned-off-by: Tao Ma <boyu.mt@taobao.com>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>",
    "cve_desc": "The ext4_fill_super function in fs/ext4/super.c in the Linux kernel before 2.6.39 does not properly initialize a certain error-report data structure, which allows local users to cause a denial of service (OOPS) by attempting to mount a crafted ext4 filesystem.",
    "year": 2011,
    "filename": "super.c",
    "commit_url": "\"https://github.com/torvalds/linux/commit/0449641130f5652b344ef6fa39fa019d7e94660a\""
  },
  {
    "repository": "torvalds/linux",
    "cve_id": "CVE-2011-2517",
    "cwe_list": [
      "CWE-119"
    ],
    "commit_hash": "208c72f4fe44fe09577e7975ba0e7fa0278f3d03",
    "short_hash": "208c72f4",
    "vulnerableMethods_before": [
      {
        "filename": "net/wireless/nl80211.c",
        "method_name": "nl80211_trigger_scan",
        "raw_code": "static int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info) /* <=== nl80211_trigger_scan */ \n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_scan_request *request;\n\tstruct nlattr *attr;\n\tstruct wiphy *wiphy;\n\tint err, tmp, n_ssids = 0, n_channels, i;\n\tenum ieee80211_band band;\n\tsize_t ie_len;\n\n\tif (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE]))\n\t\treturn -EINVAL;\n\n\twiphy = &rdev->wiphy;\n\n\tif (!rdev->ops->scan)\n\t\treturn -EOPNOTSUPP;\n\n\tif (rdev->scan_req)\n\t\treturn -EBUSY;\n\n\tif (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\tn_channels = validate_scan_freqs(\n\t\t\t\tinfo->attrs[NL80211_ATTR_SCAN_FREQUENCIES]);\n\t\tif (!n_channels)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tn_channels = 0;\n\n\t\tfor (band = 0; band < IEEE80211_NUM_BANDS; band++)\n\t\t\tif (wiphy->bands[band])\n\t\t\t\tn_channels += wiphy->bands[band]->n_channels;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_SCAN_SSIDS])\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS], tmp)\n\t\t\tn_ssids++;\n\n\tif (n_ssids > wiphy->max_scan_ssids)\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_IE])\n\t\tie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\telse\n\t\tie_len = 0;\n\n\tif (ie_len > wiphy->max_scan_ie_len)\n\t\treturn -EINVAL;\n\n\trequest = kzalloc(sizeof(*request)\n\t\t\t+ sizeof(*request->ssids) * n_ssids\n\t\t\t+ sizeof(*request->channels) * n_channels\n\t\t\t+ ie_len, GFP_KERNEL);\n\tif (!request)\n\t\treturn -ENOMEM;\n\n\tif (n_ssids)\n\t\trequest->ssids = (void *)&request->channels[n_channels];\n\trequest->n_ssids = n_ssids;\n\tif (ie_len) {\n\t\tif (request->ssids)\n\t\t\trequest->ie = (void *)(request->ssids + n_ssids);\n\t\telse\n\t\t\trequest->ie = (void *)(request->channels + n_channels);\n\t}\n\n\ti = 0;\n\tif (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\t/* user specified, bail out if channel not found */\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_FREQUENCIES], tmp) {\n\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\tchan = ieee80211_get_channel(wiphy, nla_get_u32(attr));\n\n\t\t\tif (!chan) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\t/* ignore disabled channels */\n\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\tcontinue;\n\n\t\t\trequest->channels[i] = chan;\n\t\t\ti++;\n\t\t}\n\t} else {\n\t\t/* all channels */\n\t\tfor (band = 0; band < IEEE80211_NUM_BANDS; band++) {\n\t\t\tint j;\n\t\t\tif (!wiphy->bands[band])\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < wiphy->bands[band]->n_channels; j++) {\n\t\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\t\tchan = &wiphy->bands[band]->channels[j];\n\n\t\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\t\tcontinue;\n\n\t\t\t\trequest->channels[i] = chan;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!i) {\n\t\terr = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\trequest->n_channels = i;\n\n\ti = 0;\n\tif (info->attrs[NL80211_ATTR_SCAN_SSIDS]) {\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS], tmp) {\n\t\t\tif (request->ssids[i].ssid_len > IEEE80211_MAX_SSID_LEN) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\tmemcpy(request->ssids[i].ssid, nla_data(attr), nla_len(attr));\n\t\t\trequest->ssids[i].ssid_len = nla_len(attr);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\trequest->ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t\tmemcpy((void *)request->ie,\n\t\t       nla_data(info->attrs[NL80211_ATTR_IE]),\n\t\t       request->ie_len);\n\t}\n\n\trequest->dev = dev;\n\trequest->wiphy = &rdev->wiphy;\n\n\trdev->scan_req = request;\n\terr = rdev->ops->scan(&rdev->wiphy, dev, request);\n\n\tif (!err) {\n\t\tnl80211_send_scan_start(rdev, dev);\n\t\tdev_hold(dev);\n\t} else {\n out_free:\n\t\trdev->scan_req = NULL;\n\t\tkfree(request);\n\t}\n\n\treturn err;\n}",
        "start_line": 3292
      },
      {
        "filename": "net/wireless/nl80211.c",
        "method_name": "nl80211_start_sched_scan",
        "raw_code": "static int nl80211_start_sched_scan(struct sk_buff *skb, /* <=== nl80211_start_sched_scan */ \n\t\t\t\t    struct genl_info *info)\n{\n\tstruct cfg80211_sched_scan_request *request;\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct nlattr *attr;\n\tstruct wiphy *wiphy;\n\tint err, tmp, n_ssids = 0, n_channels, i;\n\tu32 interval;\n\tenum ieee80211_band band;\n\tsize_t ie_len;\n\n\tif (!(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_SCHED_SCAN) ||\n\t    !rdev->ops->sched_scan_start)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE]))\n\t\treturn -EINVAL;\n\n\tif (rdev->sched_scan_req)\n\t\treturn -EINPROGRESS;\n\n\tif (!info->attrs[NL80211_ATTR_SCHED_SCAN_INTERVAL])\n\t\treturn -EINVAL;\n\n\tinterval = nla_get_u32(info->attrs[NL80211_ATTR_SCHED_SCAN_INTERVAL]);\n\tif (interval == 0)\n\t\treturn -EINVAL;\n\n\twiphy = &rdev->wiphy;\n\n\tif (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\tn_channels = validate_scan_freqs(\n\t\t\t\tinfo->attrs[NL80211_ATTR_SCAN_FREQUENCIES]);\n\t\tif (!n_channels)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tn_channels = 0;\n\n\t\tfor (band = 0; band < IEEE80211_NUM_BANDS; band++)\n\t\t\tif (wiphy->bands[band])\n\t\t\t\tn_channels += wiphy->bands[band]->n_channels;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_SCAN_SSIDS])\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS],\n\t\t\t\t    tmp)\n\t\t\tn_ssids++;\n\n\tif (n_ssids > wiphy->max_scan_ssids)\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_IE])\n\t\tie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\telse\n\t\tie_len = 0;\n\n\tif (ie_len > wiphy->max_scan_ie_len)\n\t\treturn -EINVAL;\n\n\trequest = kzalloc(sizeof(*request)\n\t\t\t+ sizeof(*request->ssids) * n_ssids\n\t\t\t+ sizeof(*request->channels) * n_channels\n\t\t\t+ ie_len, GFP_KERNEL);\n\tif (!request)\n\t\treturn -ENOMEM;\n\n\tif (n_ssids)\n\t\trequest->ssids = (void *)&request->channels[n_channels];\n\trequest->n_ssids = n_ssids;\n\tif (ie_len) {\n\t\tif (request->ssids)\n\t\t\trequest->ie = (void *)(request->ssids + n_ssids);\n\t\telse\n\t\t\trequest->ie = (void *)(request->channels + n_channels);\n\t}\n\n\ti = 0;\n\tif (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\t/* user specified, bail out if channel not found */\n\t\tnla_for_each_nested(attr,\n\t\t\t\t    info->attrs[NL80211_ATTR_SCAN_FREQUENCIES],\n\t\t\t\t    tmp) {\n\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\tchan = ieee80211_get_channel(wiphy, nla_get_u32(attr));\n\n\t\t\tif (!chan) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\t/* ignore disabled channels */\n\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\tcontinue;\n\n\t\t\trequest->channels[i] = chan;\n\t\t\ti++;\n\t\t}\n\t} else {\n\t\t/* all channels */\n\t\tfor (band = 0; band < IEEE80211_NUM_BANDS; band++) {\n\t\t\tint j;\n\t\t\tif (!wiphy->bands[band])\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < wiphy->bands[band]->n_channels; j++) {\n\t\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\t\tchan = &wiphy->bands[band]->channels[j];\n\n\t\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\t\tcontinue;\n\n\t\t\t\trequest->channels[i] = chan;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!i) {\n\t\terr = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\trequest->n_channels = i;\n\n\ti = 0;\n\tif (info->attrs[NL80211_ATTR_SCAN_SSIDS]) {\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS],\n\t\t\t\t    tmp) {\n\t\t\tif (request->ssids[i].ssid_len >\n\t\t\t    IEEE80211_MAX_SSID_LEN) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\tmemcpy(request->ssids[i].ssid, nla_data(attr),\n\t\t\t       nla_len(attr));\n\t\t\trequest->ssids[i].ssid_len = nla_len(attr);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\trequest->ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t\tmemcpy((void *)request->ie,\n\t\t       nla_data(info->attrs[NL80211_ATTR_IE]),\n\t\t       request->ie_len);\n\t}\n\n\trequest->dev = dev;\n\trequest->wiphy = &rdev->wiphy;\n\trequest->interval = interval;\n\n\terr = rdev->ops->sched_scan_start(&rdev->wiphy, dev, request);\n\tif (!err) {\n\t\trdev->sched_scan_req = request;\n\t\tnl80211_send_sched_scan(rdev, dev,\n\t\t\t\t\tNL80211_CMD_START_SCHED_SCAN);\n\t\tgoto out;\n\t}\n\nout_free:\n\tkfree(request);\nout:\n\treturn err;\n}",
        "start_line": 3444
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "net/wireless/nl80211.c",
        "method_name": "nl80211_trigger_scan",
        "raw_code": "static int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info) /* <=== nl80211_trigger_scan */ \n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_scan_request *request;\n\tstruct nlattr *attr;\n\tstruct wiphy *wiphy;\n\tint err, tmp, n_ssids = 0, n_channels, i;\n\tenum ieee80211_band band;\n\tsize_t ie_len;\n\n\tif (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE]))\n\t\treturn -EINVAL;\n\n\twiphy = &rdev->wiphy;\n\n\tif (!rdev->ops->scan)\n\t\treturn -EOPNOTSUPP;\n\n\tif (rdev->scan_req)\n\t\treturn -EBUSY;\n\n\tif (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\tn_channels = validate_scan_freqs(\n\t\t\t\tinfo->attrs[NL80211_ATTR_SCAN_FREQUENCIES]);\n\t\tif (!n_channels)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tn_channels = 0;\n\n\t\tfor (band = 0; band < IEEE80211_NUM_BANDS; band++)\n\t\t\tif (wiphy->bands[band])\n\t\t\t\tn_channels += wiphy->bands[band]->n_channels;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_SCAN_SSIDS])\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS], tmp)\n\t\t\tn_ssids++;\n\n\tif (n_ssids > wiphy->max_scan_ssids)\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_IE])\n\t\tie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\telse\n\t\tie_len = 0;\n\n\tif (ie_len > wiphy->max_scan_ie_len)\n\t\treturn -EINVAL;\n\n\trequest = kzalloc(sizeof(*request)\n\t\t\t+ sizeof(*request->ssids) * n_ssids\n\t\t\t+ sizeof(*request->channels) * n_channels\n\t\t\t+ ie_len, GFP_KERNEL);\n\tif (!request)\n\t\treturn -ENOMEM;\n\n\tif (n_ssids)\n\t\trequest->ssids = (void *)&request->channels[n_channels];\n\trequest->n_ssids = n_ssids;\n\tif (ie_len) {\n\t\tif (request->ssids)\n\t\t\trequest->ie = (void *)(request->ssids + n_ssids);\n\t\telse\n\t\t\trequest->ie = (void *)(request->channels + n_channels);\n\t}\n\n\ti = 0;\n\tif (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\t/* user specified, bail out if channel not found */\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_FREQUENCIES], tmp) {\n\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\tchan = ieee80211_get_channel(wiphy, nla_get_u32(attr));\n\n\t\t\tif (!chan) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\t/* ignore disabled channels */\n\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\tcontinue;\n\n\t\t\trequest->channels[i] = chan;\n\t\t\ti++;\n\t\t}\n\t} else {\n\t\t/* all channels */\n\t\tfor (band = 0; band < IEEE80211_NUM_BANDS; band++) {\n\t\t\tint j;\n\t\t\tif (!wiphy->bands[band])\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < wiphy->bands[band]->n_channels; j++) {\n\t\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\t\tchan = &wiphy->bands[band]->channels[j];\n\n\t\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\t\tcontinue;\n\n\t\t\t\trequest->channels[i] = chan;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!i) {\n\t\terr = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\trequest->n_channels = i;\n\n\ti = 0;\n\tif (info->attrs[NL80211_ATTR_SCAN_SSIDS]) {\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS], tmp) {\n\t\t\trequest->ssids[i].ssid_len = nla_len(attr);\n\t\t\tif (request->ssids[i].ssid_len > IEEE80211_MAX_SSID_LEN) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\tmemcpy(request->ssids[i].ssid, nla_data(attr), nla_len(attr));\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\trequest->ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t\tmemcpy((void *)request->ie,\n\t\t       nla_data(info->attrs[NL80211_ATTR_IE]),\n\t\t       request->ie_len);\n\t}\n\n\trequest->dev = dev;\n\trequest->wiphy = &rdev->wiphy;\n\n\trdev->scan_req = request;\n\terr = rdev->ops->scan(&rdev->wiphy, dev, request);\n\n\tif (!err) {\n\t\tnl80211_send_scan_start(rdev, dev);\n\t\tdev_hold(dev);\n\t} else {\n out_free:\n\t\trdev->scan_req = NULL;\n\t\tkfree(request);\n\t}\n\n\treturn err;\n}",
        "start_line": 3292
      },
      {
        "filename": "net/wireless/nl80211.c",
        "method_name": "nl80211_start_sched_scan",
        "raw_code": "static int nl80211_start_sched_scan(struct sk_buff *skb, /* <=== nl80211_start_sched_scan */ \n\t\t\t\t    struct genl_info *info)\n{\n\tstruct cfg80211_sched_scan_request *request;\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct nlattr *attr;\n\tstruct wiphy *wiphy;\n\tint err, tmp, n_ssids = 0, n_channels, i;\n\tu32 interval;\n\tenum ieee80211_band band;\n\tsize_t ie_len;\n\n\tif (!(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_SCHED_SCAN) ||\n\t    !rdev->ops->sched_scan_start)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE]))\n\t\treturn -EINVAL;\n\n\tif (rdev->sched_scan_req)\n\t\treturn -EINPROGRESS;\n\n\tif (!info->attrs[NL80211_ATTR_SCHED_SCAN_INTERVAL])\n\t\treturn -EINVAL;\n\n\tinterval = nla_get_u32(info->attrs[NL80211_ATTR_SCHED_SCAN_INTERVAL]);\n\tif (interval == 0)\n\t\treturn -EINVAL;\n\n\twiphy = &rdev->wiphy;\n\n\tif (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\tn_channels = validate_scan_freqs(\n\t\t\t\tinfo->attrs[NL80211_ATTR_SCAN_FREQUENCIES]);\n\t\tif (!n_channels)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tn_channels = 0;\n\n\t\tfor (band = 0; band < IEEE80211_NUM_BANDS; band++)\n\t\t\tif (wiphy->bands[band])\n\t\t\t\tn_channels += wiphy->bands[band]->n_channels;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_SCAN_SSIDS])\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS],\n\t\t\t\t    tmp)\n\t\t\tn_ssids++;\n\n\tif (n_ssids > wiphy->max_scan_ssids)\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_IE])\n\t\tie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\telse\n\t\tie_len = 0;\n\n\tif (ie_len > wiphy->max_scan_ie_len)\n\t\treturn -EINVAL;\n\n\trequest = kzalloc(sizeof(*request)\n\t\t\t+ sizeof(*request->ssids) * n_ssids\n\t\t\t+ sizeof(*request->channels) * n_channels\n\t\t\t+ ie_len, GFP_KERNEL);\n\tif (!request)\n\t\treturn -ENOMEM;\n\n\tif (n_ssids)\n\t\trequest->ssids = (void *)&request->channels[n_channels];\n\trequest->n_ssids = n_ssids;\n\tif (ie_len) {\n\t\tif (request->ssids)\n\t\t\trequest->ie = (void *)(request->ssids + n_ssids);\n\t\telse\n\t\t\trequest->ie = (void *)(request->channels + n_channels);\n\t}\n\n\ti = 0;\n\tif (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\t/* user specified, bail out if channel not found */\n\t\tnla_for_each_nested(attr,\n\t\t\t\t    info->attrs[NL80211_ATTR_SCAN_FREQUENCIES],\n\t\t\t\t    tmp) {\n\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\tchan = ieee80211_get_channel(wiphy, nla_get_u32(attr));\n\n\t\t\tif (!chan) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\t/* ignore disabled channels */\n\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\tcontinue;\n\n\t\t\trequest->channels[i] = chan;\n\t\t\ti++;\n\t\t}\n\t} else {\n\t\t/* all channels */\n\t\tfor (band = 0; band < IEEE80211_NUM_BANDS; band++) {\n\t\t\tint j;\n\t\t\tif (!wiphy->bands[band])\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < wiphy->bands[band]->n_channels; j++) {\n\t\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\t\tchan = &wiphy->bands[band]->channels[j];\n\n\t\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\t\tcontinue;\n\n\t\t\t\trequest->channels[i] = chan;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!i) {\n\t\terr = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\trequest->n_channels = i;\n\n\ti = 0;\n\tif (info->attrs[NL80211_ATTR_SCAN_SSIDS]) {\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS],\n\t\t\t\t    tmp) {\n\t\t\trequest->ssids[i].ssid_len = nla_len(attr);\n\t\t\tif (request->ssids[i].ssid_len >\n\t\t\t    IEEE80211_MAX_SSID_LEN) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\tmemcpy(request->ssids[i].ssid, nla_data(attr),\n\t\t\t       nla_len(attr));\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\trequest->ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t\tmemcpy((void *)request->ie,\n\t\t       nla_data(info->attrs[NL80211_ATTR_IE]),\n\t\t       request->ie_len);\n\t}\n\n\trequest->dev = dev;\n\trequest->wiphy = &rdev->wiphy;\n\trequest->interval = interval;\n\n\terr = rdev->ops->sched_scan_start(&rdev->wiphy, dev, request);\n\tif (!err) {\n\t\trdev->sched_scan_req = request;\n\t\tnl80211_send_sched_scan(rdev, dev,\n\t\t\t\t\tNL80211_CMD_START_SCHED_SCAN);\n\t\tgoto out;\n\t}\n\nout_free:\n\tkfree(request);\nout:\n\treturn err;\n}",
        "start_line": 3444
      }
    ],
    "code_context": "Called Methods:\n- nla_get_u32: static inline u32 nla_get_u32(const struct nlattr *nla) /* <=== nla_get_u32 */ \n{\n\treturn *(u32 *) nla_data(nla);\n}\n- kfree: static inline void kfree(void *p) /* <=== kfree */ \n{\n\tfree(p);\n}\n- kfree: void kfree(const void *x) /* <=== kfree */ \n{\n\tstruct page *page;\n\tvoid *object = (void *)x;\n\n\ttrace_kfree(_RET_IP_, x);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(x)))\n\t\treturn;\n\n\tpage = virt_to_head_page(x);\n\tif (unlikely(!PageSlab(page))) {\n\t\tBUG_ON(!PageCompound(page));\n\t\tkmemleak_free(x);\n\t\tput_page(page);\n\t\treturn;\n\t}\n\tslab_free(page->slab, page, object, _RET_IP_);\n}\n- slob_free: static void slob_free(void *block, int size) /* <=== slob_free */ \n{\n\tstruct slob_page *sp;\n\tslob_t *prev, *next, *b = (slob_t *)block;\n\tslobidx_t units;\n\tunsigned long flags;\n\tstruct list_head *slob_list;\n\n\tif (unlikely(ZERO_OR_NULL_PTR(block)))\n\t\treturn;\n\tBUG_ON(!size);\n\n\tsp = slob_page(block);\n\tunits = SLOB_UNITS(size);\n\n\tspin_lock_irqsave(&slob_lock, flags);\n\n\tif (sp->units + units == SLOB_UNITS(PAGE_SIZE)) {\n\t\t/* Go directly to page allocator. Do not pass slob allocator */\n\t\tif (slob_page_free(sp))\n\t\t\tclear_slob_page_free(sp);\n\t\tspin_unlock_irqrestore(&slob_lock, flags);\n\t\tclear_slob_page(sp);\n\t\tfree_slob_page(sp);\n\t\tslob_free_pages(b, 0);\n\t\treturn;\n\t}\n\n\tif (!slob_page_free(sp)) {\n\t\t/* This slob page is about to become partially free. Easy! */\n\t\tsp->units = units;\n\t\tsp->free = b;\n\t\tset_slob(b, units,\n\t\t\t(void *)((unsigned long)(b +\n\t\t\t\t\tSLOB_UNITS(PAGE_SIZE)) & PAGE_MASK));\n\t\tif (size < SLOB_BREAK1)\n\t\t\tslob_list = &free_slob_small;\n\t\telse if (size < SLOB_BREAK2)\n\t\t\tslob_list = &free_slob_medium;\n\t\telse\n\t\t\tslob_list = &free_slob_large;\n\t\tset_slob_page_free(sp, slob_list);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Otherwise the page is already partially free, so find reinsertion\n\t * point.\n\t */\n\tsp->units += units;\n\n\tif (b < sp->free) {\n\t\tif (b + units == sp->free) {\n\t\t\tunits += slob_units(sp->free);\n\t\t\tsp->free = slob_next(sp->free);\n\t\t}\n\t\tset_slob(b, units, sp->free);\n\t\tsp->free = b;\n\t} else {\n\t\tprev = sp->free;\n\t\tnext = slob_next(prev);\n\t\twhile (b > next) {\n\t\t\tprev = next;\n\t\t\tnext = slob_next(prev);\n\t\t}\n\n\t\tif (!slob_last(prev) && b + units == next) {\n\t\t\tunits += slob_units(next);\n\t\t\tset_slob(b, units, slob_next(next));\n\t\t} else\n\t\t\tset_slob(b, units, next);\n\n\t\tif (prev + slob_units(prev) == b) {\n\t\t\tunits = slob_units(b) + slob_units(prev);\n\t\t\tset_slob(prev, units, slob_next(b));\n\t\t} else\n\t\t\tset_slob(prev, slob_units(prev), b);\n\t}\nout:\n\tspin_unlock_irqrestore(&slob_lock, flags);\n}\n- slob_page: static inline struct slob_page *slob_page(const void *addr) /* <=== slob_page */ \n{\n\treturn (struct slob_page *)virt_to_page(addr);\n}\n- is_valid_ie_attr: static bool is_valid_ie_attr(const struct nlattr *attr) /* <=== is_valid_ie_attr */ \n{\n\tconst u8 *pos;\n\tint len;\n\n\tif (!attr)\n\t\treturn true;\n\n\tpos = nla_data(attr);\n\tlen = nla_len(attr);\n\n\twhile (len) {\n\t\tu8 elemlen;\n\n\t\tif (len < 2)\n\t\t\treturn false;\n\t\tlen -= 2;\n\n\t\telemlen = pos[1];\n\t\tif (elemlen > len)\n\t\t\treturn false;\n\n\t\tlen -= elemlen;\n\t\tpos += 2 + elemlen;\n\t}\n\n\treturn true;\n}\n- kzalloc: static inline void *kzalloc(size_t size, gfp_t flags) /* <=== kzalloc */ \n{\n\treturn kmalloc(size, flags | __GFP_ZERO);\n}\n- virt_to_cache: static inline struct kmem_cache *virt_to_cache(const void *obj) /* <=== virt_to_cache */ \n{\n\tstruct page *page = virt_to_head_page(obj);\n\treturn page_get_cache(page);\n}\n- memcpy: void *memcpy(void *dest, const void *src, size_t n) /* <=== memcpy */ \n{\n\tlong d0, d1, d2;\n\tasm volatile(\n\t\t\"rep ; movsq\\n\\t\"\n\t\t\"movq %4,%%rcx\\n\\t\"\n\t\t\"rep ; movsb\\n\\t\"\n\t\t: \"=&c\" (d0), \"=&D\" (d1), \"=&S\" (d2)\n\t\t: \"0\" (n >> 3), \"g\" (n & 7), \"1\" (dest), \"2\" (src)\n\t\t: \"memory\");\n\n\treturn dest;\n}\n- __cache_free: static inline void __cache_free(struct kmem_cache *cachep, void *objp) /* <=== __cache_free */ \n{\n\tstruct array_cache *ac = cpu_cache_get(cachep);\n\n\tcheck_irq_off();\n\tkmemleak_free_recursive(objp, cachep->flags);\n\tobjp = cache_free_debugcheck(cachep, objp, __builtin_return_address(0));\n\n\tkmemcheck_slab_free(cachep, objp, obj_size(cachep));\n\n\t/*\n\t * Skip calling cache_free_alien() when the platform is not numa.\n\t * This will avoid cache misses that happen while accessing slabp (which\n\t * is per page memory  reference) to get nodeid. Instead use a global\n\t * variable to skip the call, which is mostly likely to be present in\n\t * the cache.\n\t */\n\tif (nr_online_nodes > 1 && cache_free_alien(cachep, objp))\n\t\treturn;\n\n\tif (likely(ac->avail < ac->limit)) {\n\t\tSTATS_INC_FREEHIT(cachep);\n\t\tac->entry[ac->avail++] = objp;\n\t\treturn;\n\t} else {\n\t\tSTATS_INC_FREEMISS(cachep);\n\t\tcache_flusharray(cachep, ac);\n\t\tac->entry[ac->avail++] = objp;\n\t}\n}\n- kfree: void kfree(const void *objp) /* <=== kfree */ \n{\n\tstruct kmem_cache *c;\n\tunsigned long flags;\n\n\ttrace_kfree(_RET_IP_, objp);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(objp)))\n\t\treturn;\n\tlocal_irq_save(flags);\n\tkfree_debugcheck(objp);\n\tc = virt_to_cache(objp);\n\tdebug_check_no_locks_freed(objp, obj_size(c));\n\tdebug_check_no_obj_freed(objp, obj_size(c));\n\t__cache_free(c, (void *)objp);\n\tlocal_irq_restore(flags);\n}\n- nl80211_send_scan_msg: static int nl80211_send_scan_msg(struct sk_buff *msg, /* <=== nl80211_send_scan_msg */ \n\t\t\t\t struct cfg80211_registered_device *rdev,\n\t\t\t\t struct net_device *netdev,\n\t\t\t\t u32 pid, u32 seq, int flags,\n\t\t\t\t u32 cmd)\n{\n\tvoid *hdr;\n\n\thdr = nl80211hdr_put(msg, pid, seq, flags, cmd);\n\tif (!hdr)\n\t\treturn -1;\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);\n\n\t/* ignore errors and send incomplete event anyway */\n\tnl80211_add_scan_req(msg, rdev);\n\n\treturn genlmsg_end(msg, hdr);\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n- nla_data: static inline void *nla_data(const struct nlattr *nla) /* <=== nla_data */ \n{\n\treturn (char *) nla + NLA_HDRLEN;\n}\n- nlmsg_new: static inline struct sk_buff *nlmsg_new(size_t payload, gfp_t flags) /* <=== nlmsg_new */ \n{\n\treturn alloc_skb(nlmsg_total_size(payload), flags);\n}\n- genlmsg_multicast_netns: static inline int genlmsg_multicast_netns(struct net *net, struct sk_buff *skb, /* <=== genlmsg_multicast_netns */ \n\t\t\t\t\t  u32 pid, unsigned int group, gfp_t flags)\n{\n\treturn nlmsg_multicast(net->genl_sock, skb, pid, group, flags);\n}\n- obj_size: #define obj_size(cachep)\t\t(cachep->buffer_size) /* <=== mm/slab.c:465:465:obj_size:1 */ \n- validate_scan_freqs: static int validate_scan_freqs(struct nlattr *freqs) /* <=== validate_scan_freqs */ \n{\n\tstruct nlattr *attr1, *attr2;\n\tint n_channels = 0, tmp1, tmp2;\n\n\tnla_for_each_nested(attr1, freqs, tmp1) {\n\t\tn_channels++;\n\t\t/*\n\t\t * Some hardware has a limited channel list for\n\t\t * scanning, and it is pretty much nonsensical\n\t\t * to scan for a channel twice, so disallow that\n\t\t * and don't require drivers to check that the\n\t\t * channel list they get isn't longer than what\n\t\t * they can scan, as long as they can scan all\n\t\t * the channels they registered at once.\n\t\t */\n\t\tnla_for_each_nested(attr2, freqs, tmp2)\n\t\t\tif (attr1 != attr2 &&\n\t\t\t    nla_get_u32(attr1) == nla_get_u32(attr2))\n\t\t\t\treturn 0;\n\t}\n\n\treturn n_channels;\n}\n- __memcpy_asm: extern unsigned long __memcpy_asm(void *to, const void *from, unsigned long n); /* <=== __memcpy_asm */ \n- nla_len: static inline int nla_len(const struct nlattr *nla) /* <=== nla_len */ \n{\n\treturn nla->nla_len - NLA_HDRLEN;\n}\n- nlmsg_free: static inline void nlmsg_free(struct sk_buff *skb) /* <=== nlmsg_free */ \n{\n\tkfree_skb(skb);\n}\n- memcpy: void *memcpy(void *to, const void *from, __kernel_size_t n) /* <=== memcpy */ \n{\n\tif (n < LARGE_COPY_CUTOFF)\n\t\treturn (void *)__memcpy_asm(to, from, n);\n\telse\n\t\treturn (void *)fast_copy(to, from, n, __memcpy_asm);\n}\n- is_slob_page: static inline int is_slob_page(struct slob_page *sp) /* <=== is_slob_page */ \n{\n\treturn PageSlab((struct page *)sp);\n}\n- kfree: void kfree(const void *block) /* <=== kfree */ \n{\n\tstruct slob_page *sp;\n\n\ttrace_kfree(_RET_IP_, block);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(block)))\n\t\treturn;\n\tkmemleak_free(block);\n\n\tsp = slob_page(block);\n\tif (is_slob_page(sp)) {\n\t\tint align = max(ARCH_KMALLOC_MINALIGN, ARCH_SLAB_MINALIGN);\n\t\tunsigned int *m = (unsigned int *)(block - align);\n\t\tslob_free(m, *m + align);\n\t} else\n\t\tput_page(&sp->page);\n}\n- wiphy_net: static inline struct net *wiphy_net(struct wiphy *wiphy) /* <=== wiphy_net */ \n{\n\treturn read_pnet(&wiphy->_net);\n}\n- nl80211_send_sched_scan_msg: static int /* <=== nl80211_send_sched_scan_msg */ \nnl80211_send_sched_scan_msg(struct sk_buff *msg,\n\t\t\t    struct cfg80211_registered_device *rdev,\n\t\t\t    struct net_device *netdev,\n\t\t\t    u32 pid, u32 seq, int flags, u32 cmd)\n{\n\tvoid *hdr;\n\n\thdr = nl80211hdr_put(msg, pid, seq, flags, cmd);\n\tif (!hdr)\n\t\treturn -1;\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);\n\n\treturn genlmsg_end(msg, hdr);\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n- kmalloc: static inline void *kmalloc(size_t s, gfp_t gfp) /* <=== kmalloc */ \n{\n\treturn malloc(s);\n}\n- kfree_debugcheck: #define kfree_debugcheck(x) do { } while(0) /* <=== mm/slab.c:3001:3001:kfree_debugcheck:1 */ \n- LARGE_COPY_CUTOFF: #define LARGE_COPY_CUTOFF 2048 /* <=== arch/tile/lib/memcpy_tile64.c:40:40:LARGE_COPY_CUTOFF:0 */ \n- nla_data: static inline void *nla_data(const struct nlattr *nla) /* <=== nla_data */ \n{\n\treturn (char *) nla + NLA_HDRLEN;\n}\n- nl80211_send_sched_scan: void nl80211_send_sched_scan(struct cfg80211_registered_device *rdev, /* <=== nl80211_send_sched_scan */ \n\t\t\t     struct net_device *netdev, u32 cmd)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\tif (nl80211_send_sched_scan_msg(msg, rdev, netdev, 0, 0, 0, cmd) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_scan_mcgrp.id, GFP_KERNEL);\n}\n- ieee80211_get_channel: static inline struct ieee80211_channel * /* <=== ieee80211_get_channel */ \nieee80211_get_channel(struct wiphy *wiphy, int freq)\n{\n\treturn __ieee80211_get_channel(wiphy, freq);\n}\n- fast_copy: static unsigned long fast_copy(void *dest, const void *source, int len, /* <=== fast_copy */ \n\t\t\t       memcpy_t func)\n{\n\t/*\n\t * Check if it's big enough to bother with.  We may end up doing a\n\t * small copy via TLB manipulation if we're near a page boundary,\n\t * but presumably we'll make it up when we hit the second page.\n\t */\n\twhile (len >= LARGE_COPY_CUTOFF) {\n\t\tint copy_size, bytes_left_on_page;\n\t\tpte_t *src_ptep, *dst_ptep;\n\t\tpte_t src_pte, dst_pte;\n\t\tstruct page *src_page, *dst_page;\n\n\t\t/* Is the source page oloc'ed to a remote cpu? */\nretry_source:\n\t\tsrc_ptep = virt_to_pte(current->mm, (unsigned long)source);\n\t\tif (src_ptep == NULL)\n\t\t\tbreak;\n\t\tsrc_pte = *src_ptep;\n\t\tif (!hv_pte_get_present(src_pte) ||\n\t\t    !hv_pte_get_readable(src_pte) ||\n\t\t    hv_pte_get_mode(src_pte) != HV_PTE_MODE_CACHE_TILE_L3)\n\t\t\tbreak;\n\t\tif (get_remote_cache_cpu(src_pte) == smp_processor_id())\n\t\t\tbreak;\n\t\tsrc_page = pfn_to_page(hv_pte_get_pfn(src_pte));\n\t\tget_page(src_page);\n\t\tif (pte_val(src_pte) != pte_val(*src_ptep)) {\n\t\t\tput_page(src_page);\n\t\t\tgoto retry_source;\n\t\t}\n\t\tif (pte_huge(src_pte)) {\n\t\t\t/* Adjust the PTE to correspond to a small page */\n\t\t\tint pfn = hv_pte_get_pfn(src_pte);\n\t\t\tpfn += (((unsigned long)source & (HPAGE_SIZE-1))\n\t\t\t\t>> PAGE_SHIFT);\n\t\t\tsrc_pte = pfn_pte(pfn, src_pte);\n\t\t\tsrc_pte = pte_mksmall(src_pte);\n\t\t}\n\n\t\t/* Is the destination page writable? */\nretry_dest:\n\t\tdst_ptep = virt_to_pte(current->mm, (unsigned long)dest);\n\t\tif (dst_ptep == NULL) {\n\t\t\tput_page(src_page);\n\t\t\tbreak;\n\t\t}\n\t\tdst_pte = *dst_ptep;\n\t\tif (!hv_pte_get_present(dst_pte) ||\n\t\t    !hv_pte_get_writable(dst_pte)) {\n\t\t\tput_page(src_page);\n\t\t\tbreak;\n\t\t}\n\t\tdst_page = pfn_to_page(hv_pte_get_pfn(dst_pte));\n\t\tif (dst_page == src_page) {\n\t\t\t/*\n\t\t\t * Source and dest are on the same page; this\n\t\t\t * potentially exposes us to incoherence if any\n\t\t\t * part of src and dest overlap on a cache line.\n\t\t\t * Just give up rather than trying to be precise.\n\t\t\t */\n\t\t\tput_page(src_page);\n\t\t\tbreak;\n\t\t}\n\t\tget_page(dst_page);\n\t\tif (pte_val(dst_pte) != pte_val(*dst_ptep)) {\n\t\t\tput_page(dst_page);\n\t\t\tgoto retry_dest;\n\t\t}\n\t\tif (pte_huge(dst_pte)) {\n\t\t\t/* Adjust the PTE to correspond to a small page */\n\t\t\tint pfn = hv_pte_get_pfn(dst_pte);\n\t\t\tpfn += (((unsigned long)dest & (HPAGE_SIZE-1))\n\t\t\t\t>> PAGE_SHIFT);\n\t\t\tdst_pte = pfn_pte(pfn, dst_pte);\n\t\t\tdst_pte = pte_mksmall(dst_pte);\n\t\t}\n\n\t\t/* All looks good: create a cachable PTE and copy from it */\n\t\tcopy_size = len;\n\t\tbytes_left_on_page =\n\t\t\tPAGE_SIZE - (((int)source) & (PAGE_SIZE-1));\n\t\tif (copy_size > bytes_left_on_page)\n\t\t\tcopy_size = bytes_left_on_page;\n\t\tbytes_left_on_page =\n\t\t\tPAGE_SIZE - (((int)dest) & (PAGE_SIZE-1));\n\t\tif (copy_size > bytes_left_on_page)\n\t\t\tcopy_size = bytes_left_on_page;\n\t\tmemcpy_multicache(dest, source, dst_pte, src_pte, copy_size);\n\n\t\t/* Release the pages */\n\t\tput_page(dst_page);\n\t\tput_page(src_page);\n\n\t\t/* Continue on the next page */\n\t\tdest += copy_size;\n\t\tsource += copy_size;\n\t\tlen -= copy_size;\n\t}\n\n\treturn func(dest, source, len);\n}\n- nl80211_send_scan_start: void nl80211_send_scan_start(struct cfg80211_registered_device *rdev, /* <=== nl80211_send_scan_start */ \n\t\t\t     struct net_device *netdev)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\tif (nl80211_send_scan_msg(msg, rdev, netdev, 0, 0, 0,\n\t\t\t\t  NL80211_CMD_TRIGGER_SCAN) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_scan_mcgrp.id, GFP_KERNEL);\n}\n\nType Definitions:\n- wiphy: struct wiphy\n- nlattr: struct nlattr {\n\t__u16           nla_len;\n\t__u16           nla_type;\n}\n- cfg80211_scan_request: struct cfg80211_scan_request {\n\tstruct cfg80211_ssid *ssids;\n\tint n_ssids;\n\tu32 n_channels;\n\tconst u8 *ie;\n\tsize_t ie_len;\n\n\t/* internal */\n\tstruct wiphy *wiphy;\n\tstruct net_device *dev;\n\tbool aborted;\n\n\t/* keep last */\n\tstruct ieee80211_channel *channels[0];\n}\n- ieee80211_channel: struct ieee80211_channel {\n\tenum ieee80211_band band;\n\tu16 center_freq;\n\tu16 hw_value;\n\tu32 flags;\n\tint max_antenna_gain;\n\tint max_power;\n\tbool beacon_found;\n\tu32 orig_flags;\n\tint orig_mag, orig_mpwr;\n}\n- cfg80211_registered_device: struct cfg80211_registered_device {\n\tconst struct cfg80211_ops *ops;\n\tstruct list_head list;\n\t/* we hold this mutex during any call so that\n\t * we cannot do multiple calls at once, and also\n\t * to avoid the deregister call to proceed while\n\t * any call is in progress */\n\tstruct mutex mtx;\n\n\t/* rfkill support */\n\tstruct rfkill_ops rfkill_ops;\n\tstruct rfkill *rfkill;\n\tstruct work_struct rfkill_sync;\n\n\t/* ISO / IEC 3166 alpha2 for which this device is receiving\n\t * country IEs on, this can help disregard country IEs from APs\n\t * on the same alpha2 quickly. The alpha2 may differ from\n\t * cfg80211_regdomain's alpha2 when an intersection has occurred.\n\t * If the AP is reconfigured this can also be used to tell us if\n\t * the country on the country IE changed. */\n\tchar country_ie_alpha2[2];\n\n\t/* If a Country IE has been received this tells us the environment\n\t * which its telling us its in. This defaults to ENVIRON_ANY */\n\tenum environment_cap env;\n\n\t/* wiphy index, internal only */\n\tint wiphy_idx;\n\n\t/* associate netdev list */\n\tstruct mutex devlist_mtx;\n\t/* protected by devlist_mtx or RCU */\n\tstruct list_head netdev_list;\n\tint devlist_generation;\n\tint opencount; /* also protected by devlist_mtx */\n\twait_queue_head_t dev_wait;\n\n\t/* BSSes/scanning */\n\tspinlock_t bss_lock;\n\tstruct list_head bss_list;\n\tstruct rb_root bss_tree;\n\tu32 bss_generation;\n\tstruct cfg80211_scan_request *scan_req; /* protected by RTNL */\n\tstruct cfg80211_sched_scan_request *sched_scan_req;\n\tunsigned long suspend_at;\n\tstruct work_struct scan_done_wk;\n\tstruct work_struct sched_scan_results_wk;\n\n#ifdef CONFIG_NL80211_TESTMODE\n\tstruct genl_info *testmode_info;\n#endif\n\n\tstruct work_struct conn_work;\n\tstruct work_struct event_work;\n\n\tstruct cfg80211_wowlan *wowlan;\n\n\t/* must be last because of the way we do wiphy_priv(),\n\t * and it should at least be aligned to NETDEV_ALIGN */\n\tstruct wiphy wiphy __attribute__((__aligned__(NETDEV_ALIGN)));\n}\n- genl_info: struct genl_info {\n\tu32\t\t\tsnd_seq;\n\tu32\t\t\tsnd_pid;\n\tstruct nlmsghdr *\tnlhdr;\n\tstruct genlmsghdr *\tgenlhdr;\n\tvoid *\t\t\tuserhdr;\n\tstruct nlattr **\tattrs;\n#ifdef CONFIG_NET_NS\n\tstruct net *\t\t_net;\n#endif\n\tvoid *\t\t\tuser_ptr[2];\n}\n- genl_info: struct genl_info\n- ieee80211_band: enum ieee80211_band {\n\tIEEE80211_BAND_2GHZ = NL80211_BAND_2GHZ,\n\tIEEE80211_BAND_5GHZ = NL80211_BAND_5GHZ,\n\n\t/* keep last */\n\tIEEE80211_NUM_BANDS\n}\n- cfg80211_sched_scan_request: struct cfg80211_sched_scan_request {\n\tstruct cfg80211_ssid *ssids;\n\tint n_ssids;\n\tu32 n_channels;\n\tu32 interval;\n\tconst u8 *ie;\n\tsize_t ie_len;\n\n\t/* internal */\n\tstruct wiphy *wiphy;\n\tstruct net_device *dev;\n\n\t/* keep last */\n\tstruct ieee80211_channel *channels[0];\n}\n- net_device: struct net_device\n\nImports:\n- #include <net/net_namespace.h>\n- #include <linux/err.h>\n- #include <net/cfg80211.h>\n- #include \"reg.h\"\n- #include \"core.h\"\n- #include <linux/if_ether.h>\n- #include <linux/netlink.h>\n- #include <net/sock.h>\n- #include <linux/module.h>\n- #include <linux/ieee80211.h>\n- #include <linux/etherdevice.h>\n- #include <linux/list.h>\n- #include \"nl80211.h\"\n- #include <linux/slab.h>\n- #include <linux/nl80211.h>\n- #include <linux/if.h>\n- #include <net/genetlink.h>\n- #include <linux/rtnetlink.h>",
    "commit_msg": "nl80211: fix check for valid SSID size in scan operations\n\nIn both trigger_scan and sched_scan operations, we were checking for\nthe SSID length before assigning the value correctly.  Since the\nmemory was just kzalloc'ed, the check was always failing and SSID with\nover 32 characters were allowed to go through.\n\nThis was causing a buffer overflow when copying the actual SSID to the\nproper place.\n\nThis bug has been there since 2.6.29-rc4.\n\nCc: stable@kernel.org\nSigned-off-by: Luciano Coelho <coelho@ti.com>\nSigned-off-by: John W. Linville <linville@tuxdriver.com>",
    "cve_desc": "[{'lang': 'en', 'value': 'Multiple buffer overflows in net/wireless/nl80211.c in the Linux kernel before 2.6.39.2 allow local users to gain privileges by leveraging the CAP_NET_ADMIN capability during scan operations with a long SSID value.'}]",
    "year": 2011,
    "filename": "nl80211.c",
    "commit_url": "\"https://github.com/torvalds/linux/commit/208c72f4fe44fe09577e7975ba0e7fa0278f3d03\""
  },
  {
    "repository": "torvalds/linux",
    "cve_id": "CVE-2011-2518",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "4e78c724d47e2342aa8fde61f6b8536f662f795f",
    "short_hash": "4e78c724",
    "vulnerableMethods_before": [
      {
        "filename": "security/tomoyo/mount.c",
        "method_name": "tomoyo_mount_acl",
        "raw_code": "static int tomoyo_mount_acl(struct tomoyo_request_info *r, char *dev_name, /* <=== tomoyo_mount_acl */ \n\t\t\t    struct path *dir, char *type, unsigned long flags)\n{\n\tstruct path path;\n\tstruct file_system_type *fstype = NULL;\n\tconst char *requested_type = NULL;\n\tconst char *requested_dir_name = NULL;\n\tconst char *requested_dev_name = NULL;\n\tstruct tomoyo_path_info rtype;\n\tstruct tomoyo_path_info rdev;\n\tstruct tomoyo_path_info rdir;\n\tint need_dev = 0;\n\tint error = -ENOMEM;\n\n\t/* Get fstype. */\n\trequested_type = tomoyo_encode(type);\n\tif (!requested_type)\n\t\tgoto out;\n\trtype.name = requested_type;\n\ttomoyo_fill_path_info(&rtype);\n\n\t/* Get mount point. */\n\trequested_dir_name = tomoyo_realpath_from_path(dir);\n\tif (!requested_dir_name) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\trdir.name = requested_dir_name;\n\ttomoyo_fill_path_info(&rdir);\n\n\t/* Compare fs name. */\n\tif (!strcmp(type, TOMOYO_MOUNT_REMOUNT_KEYWORD)) {\n\t\t/* dev_name is ignored. */\n\t} else if (!strcmp(type, TOMOYO_MOUNT_MAKE_UNBINDABLE_KEYWORD) ||\n\t\t   !strcmp(type, TOMOYO_MOUNT_MAKE_PRIVATE_KEYWORD) ||\n\t\t   !strcmp(type, TOMOYO_MOUNT_MAKE_SLAVE_KEYWORD) ||\n\t\t   !strcmp(type, TOMOYO_MOUNT_MAKE_SHARED_KEYWORD)) {\n\t\t/* dev_name is ignored. */\n\t} else if (!strcmp(type, TOMOYO_MOUNT_BIND_KEYWORD) ||\n\t\t   !strcmp(type, TOMOYO_MOUNT_MOVE_KEYWORD)) {\n\t\tneed_dev = -1; /* dev_name is a directory */\n\t} else {\n\t\tfstype = get_fs_type(type);\n\t\tif (!fstype) {\n\t\t\terror = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\t\tif (fstype->fs_flags & FS_REQUIRES_DEV)\n\t\t\t/* dev_name is a block device file. */\n\t\t\tneed_dev = 1;\n\t}\n\tif (need_dev) {\n\t\t/* Get mount point or device file. */\n\t\tif (kern_path(dev_name, LOOKUP_FOLLOW, &path)) {\n\t\t\terror = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\trequested_dev_name = tomoyo_realpath_from_path(&path);\n\t\tpath_put(&path);\n\t\tif (!requested_dev_name) {\n\t\t\terror = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/* Map dev_name to \"<NULL>\" if no dev_name given. */\n\t\tif (!dev_name)\n\t\t\tdev_name = \"<NULL>\";\n\t\trequested_dev_name = tomoyo_encode(dev_name);\n\t\tif (!requested_dev_name) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\trdev.name = requested_dev_name;\n\ttomoyo_fill_path_info(&rdev);\n\tr->param_type = TOMOYO_TYPE_MOUNT_ACL;\n\tr->param.mount.need_dev = need_dev;\n\tr->param.mount.dev = &rdev;\n\tr->param.mount.dir = &rdir;\n\tr->param.mount.type = &rtype;\n\tr->param.mount.flags = flags;\n\tdo {\n\t\ttomoyo_check_acl(r, tomoyo_check_mount_acl);\n\t\terror = tomoyo_audit_mount_log(r);\n\t} while (error == TOMOYO_RETRY_REQUEST);\n out:\n\tkfree(requested_dev_name);\n\tkfree(requested_dir_name);\n\tif (fstype)\n\t\tput_filesystem(fstype);\n\tkfree(requested_type);\n\treturn error;\n}",
        "start_line": 88
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "security/tomoyo/mount.c",
        "method_name": "tomoyo_mount_acl",
        "raw_code": "static int tomoyo_mount_acl(struct tomoyo_request_info *r, char *dev_name, /* <=== tomoyo_mount_acl */ \n\t\t\t    struct path *dir, char *type, unsigned long flags)\n{\n\tstruct path path;\n\tstruct file_system_type *fstype = NULL;\n\tconst char *requested_type = NULL;\n\tconst char *requested_dir_name = NULL;\n\tconst char *requested_dev_name = NULL;\n\tstruct tomoyo_path_info rtype;\n\tstruct tomoyo_path_info rdev;\n\tstruct tomoyo_path_info rdir;\n\tint need_dev = 0;\n\tint error = -ENOMEM;\n\n\t/* Get fstype. */\n\trequested_type = tomoyo_encode(type);\n\tif (!requested_type)\n\t\tgoto out;\n\trtype.name = requested_type;\n\ttomoyo_fill_path_info(&rtype);\n\n\t/* Get mount point. */\n\trequested_dir_name = tomoyo_realpath_from_path(dir);\n\tif (!requested_dir_name) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\trdir.name = requested_dir_name;\n\ttomoyo_fill_path_info(&rdir);\n\n\t/* Compare fs name. */\n\tif (!strcmp(type, TOMOYO_MOUNT_REMOUNT_KEYWORD)) {\n\t\t/* dev_name is ignored. */\n\t} else if (!strcmp(type, TOMOYO_MOUNT_MAKE_UNBINDABLE_KEYWORD) ||\n\t\t   !strcmp(type, TOMOYO_MOUNT_MAKE_PRIVATE_KEYWORD) ||\n\t\t   !strcmp(type, TOMOYO_MOUNT_MAKE_SLAVE_KEYWORD) ||\n\t\t   !strcmp(type, TOMOYO_MOUNT_MAKE_SHARED_KEYWORD)) {\n\t\t/* dev_name is ignored. */\n\t} else if (!strcmp(type, TOMOYO_MOUNT_BIND_KEYWORD) ||\n\t\t   !strcmp(type, TOMOYO_MOUNT_MOVE_KEYWORD)) {\n\t\tneed_dev = -1; /* dev_name is a directory */\n\t} else {\n\t\tfstype = get_fs_type(type);\n\t\tif (!fstype) {\n\t\t\terror = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\t\tif (fstype->fs_flags & FS_REQUIRES_DEV)\n\t\t\t/* dev_name is a block device file. */\n\t\t\tneed_dev = 1;\n\t}\n\tif (need_dev) {\n\t\t/* Get mount point or device file. */\n\t\tif (!dev_name || kern_path(dev_name, LOOKUP_FOLLOW, &path)) {\n\t\t\terror = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\trequested_dev_name = tomoyo_realpath_from_path(&path);\n\t\tpath_put(&path);\n\t\tif (!requested_dev_name) {\n\t\t\terror = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/* Map dev_name to \"<NULL>\" if no dev_name given. */\n\t\tif (!dev_name)\n\t\t\tdev_name = \"<NULL>\";\n\t\trequested_dev_name = tomoyo_encode(dev_name);\n\t\tif (!requested_dev_name) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\trdev.name = requested_dev_name;\n\ttomoyo_fill_path_info(&rdev);\n\tr->param_type = TOMOYO_TYPE_MOUNT_ACL;\n\tr->param.mount.need_dev = need_dev;\n\tr->param.mount.dev = &rdev;\n\tr->param.mount.dir = &rdir;\n\tr->param.mount.type = &rtype;\n\tr->param.mount.flags = flags;\n\tdo {\n\t\ttomoyo_check_acl(r, tomoyo_check_mount_acl);\n\t\terror = tomoyo_audit_mount_log(r);\n\t} while (error == TOMOYO_RETRY_REQUEST);\n out:\n\tkfree(requested_dev_name);\n\tkfree(requested_dir_name);\n\tif (fstype)\n\t\tput_filesystem(fstype);\n\tkfree(requested_type);\n\treturn error;\n}",
        "start_line": 88
      }
    ],
    "code_context": "Called Methods:\n- tomoyo_pattern: const char *tomoyo_pattern(const struct tomoyo_path_info *filename); /* <=== tomoyo_pattern */ \n- TOMOYO_MOUNT_BIND_KEYWORD: #define TOMOYO_MOUNT_BIND_KEYWORD                        \"--bind\" /* <=== security/tomoyo/mount.c:13:13:TOMOYO_MOUNT_BIND_KEYWORD:0 */ \n- TOMOYO_RETRY_REQUEST: #define TOMOYO_RETRY_REQUEST 1 /* Retry this request. */ /* <=== security/tomoyo/common.h:217:217:TOMOYO_RETRY_REQUEST:0 */ \n- TOMOYO_MOUNT_MAKE_UNBINDABLE_KEYWORD: #define TOMOYO_MOUNT_MAKE_UNBINDABLE_KEYWORD             \"--make-unbindable\" /* <=== security/tomoyo/mount.c:19:19:TOMOYO_MOUNT_MAKE_UNBINDABLE_KEYWORD:0 */ \n- TOMOYO_MOUNT_REMOUNT_KEYWORD: #define TOMOYO_MOUNT_REMOUNT_KEYWORD                     \"--remount\" /* <=== security/tomoyo/mount.c:17:17:TOMOYO_MOUNT_REMOUNT_KEYWORD:0 */ \n- tomoyo_fill_path_info: void tomoyo_fill_path_info(struct tomoyo_path_info *ptr); /* <=== tomoyo_fill_path_info */ \n- TOMOYO_KEYWORD_ALLOW_MOUNT: #define TOMOYO_KEYWORD_ALLOW_MOUNT               \"allow_mount \" /* <=== security/tomoyo/common.h:73:73:TOMOYO_KEYWORD_ALLOW_MOUNT:0 */ \n- tomoyo_encode: char *tomoyo_encode(const char *str); /* <=== tomoyo_encode */ \n- tomoyo_check_acl: void tomoyo_check_acl(struct tomoyo_request_info *r, /* <=== tomoyo_check_acl */ \n\t\t      bool (*check_entry) (struct tomoyo_request_info *,\n\t\t\t\t\t   const struct tomoyo_acl_info *));\n- TOMOYO_MOUNT_MOVE_KEYWORD: #define TOMOYO_MOUNT_MOVE_KEYWORD                        \"--move\" /* <=== security/tomoyo/mount.c:15:15:TOMOYO_MOUNT_MOVE_KEYWORD:0 */ \n- kfree: void kfree(const void *); /* <=== kfree */ \n- kern_path: extern int kern_path(const char *, unsigned, struct path *); /* <=== kern_path */ \n- tomoyo_supervisor: int tomoyo_supervisor(struct tomoyo_request_info *r, const char *fmt, ...) /* <=== tomoyo_supervisor */ \n{\n\tva_list args;\n\tint error = -EPERM;\n\tint pos;\n\tint len;\n\tstatic unsigned int tomoyo_serial;\n\tstruct tomoyo_query *entry = NULL;\n\tbool quota_exceeded = false;\n\tchar *header;\n\tswitch (r->mode) {\n\t\tchar *buffer;\n\tcase TOMOYO_CONFIG_LEARNING:\n\t\tif (!tomoyo_domain_quota_is_ok(r))\n\t\t\treturn 0;\n\t\tva_start(args, fmt);\n\t\tlen = vsnprintf((char *) &pos, sizeof(pos) - 1, fmt, args) + 4;\n\t\tva_end(args);\n\t\tbuffer = kmalloc(len, GFP_NOFS);\n\t\tif (!buffer)\n\t\t\treturn 0;\n\t\tva_start(args, fmt);\n\t\tvsnprintf(buffer, len - 1, fmt, args);\n\t\tva_end(args);\n\t\ttomoyo_normalize_line(buffer);\n\t\ttomoyo_write_domain2(buffer, r->domain, false);\n\t\tkfree(buffer);\n\t\t/* fall through */\n\tcase TOMOYO_CONFIG_PERMISSIVE:\n\t\treturn 0;\n\t}\n\tif (!r->domain)\n\t\tr->domain = tomoyo_domain();\n\tif (!atomic_read(&tomoyo_query_observers))\n\t\treturn -EPERM;\n\tva_start(args, fmt);\n\tlen = vsnprintf((char *) &pos, sizeof(pos) - 1, fmt, args) + 32;\n\tva_end(args);\n\theader = tomoyo_init_audit_log(&len, r);\n\tif (!header)\n\t\tgoto out;\n\tentry = kzalloc(sizeof(*entry), GFP_NOFS);\n\tif (!entry)\n\t\tgoto out;\n\tentry->query = kzalloc(len, GFP_NOFS);\n\tif (!entry->query)\n\t\tgoto out;\n\tlen = ksize(entry->query);\n\tspin_lock(&tomoyo_query_list_lock);\n\tif (tomoyo_quota_for_query && tomoyo_query_memory_size + len +\n\t    sizeof(*entry) >= tomoyo_quota_for_query) {\n\t\tquota_exceeded = true;\n\t} else {\n\t\ttomoyo_query_memory_size += len + sizeof(*entry);\n\t\tentry->serial = tomoyo_serial++;\n\t}\n\tspin_unlock(&tomoyo_query_list_lock);\n\tif (quota_exceeded)\n\t\tgoto out;\n\tpos = snprintf(entry->query, len - 1, \"Q%u-%hu\\n%s\",\n\t\t       entry->serial, r->retry, header);\n\tkfree(header);\n\theader = NULL;\n\tva_start(args, fmt);\n\tvsnprintf(entry->query + pos, len - 1 - pos, fmt, args);\n\tentry->query_len = strlen(entry->query) + 1;\n\tva_end(args);\n\tspin_lock(&tomoyo_query_list_lock);\n\tlist_add_tail(&entry->list, &tomoyo_query_list);\n\tspin_unlock(&tomoyo_query_list_lock);\n\t/* Give 10 seconds for supervisor's opinion. */\n\tfor (entry->timer = 0;\n\t     atomic_read(&tomoyo_query_observers) && entry->timer < 100;\n\t     entry->timer++) {\n\t\twake_up(&tomoyo_query_wait);\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tschedule_timeout(HZ / 10);\n\t\tif (entry->answer)\n\t\t\tbreak;\n\t}\n\tspin_lock(&tomoyo_query_list_lock);\n\tlist_del(&entry->list);\n\ttomoyo_query_memory_size -= len + sizeof(*entry);\n\tspin_unlock(&tomoyo_query_list_lock);\n\tswitch (entry->answer) {\n\tcase 3: /* Asked to retry by administrator. */\n\t\terror = TOMOYO_RETRY_REQUEST;\n\t\tr->retry++;\n\t\tbreak;\n\tcase 1:\n\t\t/* Granted by administrator. */\n\t\terror = 0;\n\t\tbreak;\n\tcase 0:\n\t\t/* Timed out. */\n\t\tbreak;\n\tdefault:\n\t\t/* Rejected by administrator. */\n\t\tbreak;\n\t}\n out:\n\tif (entry)\n\t\tkfree(entry->query);\n\tkfree(entry);\n\tkfree(header);\n\treturn error;\n}\n- TOMOYO_MOUNT_MAKE_SHARED_KEYWORD: #define TOMOYO_MOUNT_MAKE_SHARED_KEYWORD                 \"--make-shared\" /* <=== security/tomoyo/mount.c:25:25:TOMOYO_MOUNT_MAKE_SHARED_KEYWORD:0 */ \n- tomoyo_warn_log: void tomoyo_warn_log(struct tomoyo_request_info *r, const char *fmt, ...) /* <=== tomoyo_warn_log */ \n- TOMOYO_MOUNT_MAKE_PRIVATE_KEYWORD: #define TOMOYO_MOUNT_MAKE_PRIVATE_KEYWORD                \"--make-private\" /* <=== security/tomoyo/mount.c:21:21:TOMOYO_MOUNT_MAKE_PRIVATE_KEYWORD:0 */ \n- TOMOYO_MOUNT_MAKE_SLAVE_KEYWORD: #define TOMOYO_MOUNT_MAKE_SLAVE_KEYWORD                  \"--make-slave\" /* <=== security/tomoyo/mount.c:23:23:TOMOYO_MOUNT_MAKE_SLAVE_KEYWORD:0 */ \n- tomoyo_audit_mount_log: static int tomoyo_audit_mount_log(struct tomoyo_request_info *r) /* <=== tomoyo_audit_mount_log */ \n{\n\tconst char *dev = r->param.mount.dev->name;\n\tconst char *dir = r->param.mount.dir->name;\n\tconst char *type = r->param.mount.type->name;\n\tconst unsigned long flags = r->param.mount.flags;\n\tif (r->granted)\n\t\treturn 0;\n\tif (!strcmp(type, TOMOYO_MOUNT_REMOUNT_KEYWORD))\n\t\ttomoyo_warn_log(r, \"mount -o remount %s 0x%lX\", dir, flags);\n\telse if (!strcmp(type, TOMOYO_MOUNT_BIND_KEYWORD)\n\t\t || !strcmp(type, TOMOYO_MOUNT_MOVE_KEYWORD))\n\t\ttomoyo_warn_log(r, \"mount %s %s %s 0x%lX\", type, dev, dir,\n\t\t\t\tflags);\n\telse if (!strcmp(type, TOMOYO_MOUNT_MAKE_UNBINDABLE_KEYWORD) ||\n\t\t !strcmp(type, TOMOYO_MOUNT_MAKE_PRIVATE_KEYWORD) ||\n\t\t !strcmp(type, TOMOYO_MOUNT_MAKE_SLAVE_KEYWORD) ||\n\t\t !strcmp(type, TOMOYO_MOUNT_MAKE_SHARED_KEYWORD))\n\t\ttomoyo_warn_log(r, \"mount %s %s 0x%lX\", type, dir, flags);\n\telse\n\t\ttomoyo_warn_log(r, \"mount -t %s %s %s 0x%lX\", type, dev, dir,\n\t\t\t\tflags);\n\treturn tomoyo_supervisor(r,\n\t\t\t\t TOMOYO_KEYWORD_ALLOW_MOUNT \"%s %s %s 0x%lX\\n\",\n\t\t\t\t tomoyo_pattern(r->param.mount.dev),\n\t\t\t\t tomoyo_pattern(r->param.mount.dir), type,\n\t\t\t\t flags);\n}\n- tomoyo_realpath_from_path: char *tomoyo_realpath_from_path(struct path *path); /* <=== tomoyo_realpath_from_path */ \n\nType Definitions:\n- tomoyo_request_info: struct tomoyo_request_info {\n\tstruct tomoyo_domain_info *domain;\n\t/* For holding parameters. */\n\tunion {\n\t\tstruct {\n\t\t\tconst struct tomoyo_path_info *filename;\n\t\t\t/* For using wildcards at tomoyo_find_next_domain(). */\n\t\t\tconst struct tomoyo_path_info *matched_path;\n\t\t\tu8 operation;\n\t\t} path;\n\t\tstruct {\n\t\t\tconst struct tomoyo_path_info *filename1;\n\t\t\tconst struct tomoyo_path_info *filename2;\n\t\t\tu8 operation;\n\t\t} path2;\n\t\tstruct {\n\t\t\tconst struct tomoyo_path_info *filename;\n\t\t\tunsigned int mode;\n\t\t\tunsigned int major;\n\t\t\tunsigned int minor;\n\t\t\tu8 operation;\n\t\t} mkdev;\n\t\tstruct {\n\t\t\tconst struct tomoyo_path_info *filename;\n\t\t\tunsigned long number;\n\t\t\tu8 operation;\n\t\t} path_number;\n\t\tstruct {\n\t\t\tconst struct tomoyo_path_info *type;\n\t\t\tconst struct tomoyo_path_info *dir;\n\t\t\tconst struct tomoyo_path_info *dev;\n\t\t\tunsigned long flags;\n\t\t\tint need_dev;\n\t\t} mount;\n\t} param;\n\tu8 param_type;\n\tbool granted;\n\tu8 retry;\n\tu8 profile;\n\tu8 mode; /* One of tomoyo_mode_index . */\n\tu8 type;\n}\n- file_system_type: struct file_system_type\n- path: struct path\n- tomoyo_path_info: struct tomoyo_path_info {\n\tconst char *name;\n\tu32 hash;          /* = full_name_hash(name, strlen(name)) */\n\tu16 const_len;     /* = tomoyo_const_part_length(name)     */\n\tbool is_dir;       /* = tomoyo_strendswith(name, \"/\")      */\n\tbool is_patterned; /* = tomoyo_path_contains_pattern(name) */\n}\n\nImports:\n- #include <linux/slab.h>\n- #include \"common.h\"",
    "commit_msg": "TOMOYO: Fix oops in tomoyo_mount_acl().\n\nIn tomoyo_mount_acl() since 2.6.36, kern_path() was called without checking\ndev_name != NULL. As a result, an unprivileged user can trigger oops by issuing\nmount(NULL, \"/\", \"ext3\", 0, NULL) request.\nFix this by checking dev_name != NULL before calling kern_path(dev_name).\n\nSigned-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>\nCc: stable@kernel.org\nSigned-off-by: James Morris <jmorris@namei.org>",
    "cve_desc": "[{'lang': 'en', 'value': 'The tomoyo_mount_acl function in security/tomoyo/mount.c in the Linux kernel before 2.6.39.2 calls the kern_path function with arguments taken directly from a mount system call, which allows local users to cause a denial of service (OOPS) or possibly have unspecified other impact via a NULL value for the device name.'}]",
    "year": 2011,
    "filename": "mount.c",
    "commit_url": "\"https://github.com/torvalds/linux/commit/4e78c724d47e2342aa8fde61f6b8536f662f795f\""
  },
  {
    "repository": "vrtadmin/clamav-devel",
    "cve_id": "CVE-2011-2721",
    "cwe_list": [
      "CWE-189"
    ],
    "commit_hash": "4842733eb3f09be61caeed83778bb6679141dbc5",
    "short_hash": "4842733e",
    "vulnerableMethods_before": [
      {
        "filename": "libclamav/matcher-hash.c",
        "method_name": "cli_hm_scan",
        "raw_code": "int cli_hm_scan(const unsigned char *digest, uint32_t size, const char **virname, const struct cli_matcher *root, enum CLI_HASH_TYPE type) { /* <=== cli_hm_scan */ \n    const struct cli_htu32_element *item;\n    unsigned int keylen;\n    struct cli_sz_hash *szh;\n    size_t l, r;\n\n    if(!digest || !size || size == 0xffffffff || !root || !root->hm.sizehashes[type].capacity)\n\treturn CL_CLEAN;\n\n    item = cli_htu32_find(&root->hm.sizehashes[type], size);\n    if(!item)\n\treturn CL_CLEAN;\n\n    szh = (struct cli_sz_hash *)item->data.as_ptr;\n    keylen = hashlen[type];\n\n    l = 0;\n    r = szh->items;\n    while(l <= r) {\n\tsize_t c = (l + r) / 2;\n\tint res = hm_cmp(digest, &szh->hash_array[keylen * c], keylen);\n\n\tif(res < 0) {\n\t    if(!c)\n\t\tbreak;\n\t    r = c - 1;\n\t} else if(res > 0)\n\t    l = c + 1;\n\telse {\n\t    if(virname)\n\t\t*virname = szh->virusnames[c];\n\t    return CL_VIRUS;\n\t}\n    }\n    return CL_CLEAN;\n}",
        "start_line": 205
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "libclamav/matcher-hash.c",
        "method_name": "cli_hm_scan",
        "raw_code": "int cli_hm_scan(const unsigned char *digest, uint32_t size, const char **virname, const struct cli_matcher *root, enum CLI_HASH_TYPE type) { /* <=== cli_hm_scan */ \n    const struct cli_htu32_element *item;\n    unsigned int keylen;\n    struct cli_sz_hash *szh;\n    size_t l, r;\n\n    if(!digest || !size || size == 0xffffffff || !root || !root->hm.sizehashes[type].capacity)\n\treturn CL_CLEAN;\n\n    item = cli_htu32_find(&root->hm.sizehashes[type], size);\n    if(!item)\n\treturn CL_CLEAN;\n\n    szh = (struct cli_sz_hash *)item->data.as_ptr;\n    keylen = hashlen[type];\n\n    l = 0;\n    r = szh->items - 1;\n    while(l <= r) {\n\tsize_t c = (l + r) / 2;\n\tint res = hm_cmp(digest, &szh->hash_array[keylen * c], keylen);\n\n\tif(res < 0) {\n\t    if(!c)\n\t\tbreak;\n\t    r = c - 1;\n\t} else if(res > 0)\n\t    l = c + 1;\n\telse {\n\t    if(virname)\n\t\t*virname = szh->virusnames[c];\n\t    return CL_VIRUS;\n\t}\n    }\n    return CL_CLEAN;\n}",
        "start_line": 205
      }
    ],
    "code_context": "Called Methods:\n- hm_cmp: static inline int hm_cmp(const uint8_t *itm, const uint8_t *ref, unsigned int keylen) { /* <=== hm_cmp */ \n    uint32_t i = *(uint32_t *)itm, r = *(uint32_t *)ref;\n    if(i!=r)\n\treturn (i<r) * 2 -1;\n    return memcmp(&itm[4], &ref[4], keylen - 4);\n}\n- hash_htu32: static inline size_t hash_htu32(uint32_t k, const size_t SIZE) /* <=== hash_htu32 */ \n{\n\t/* mixing function */\n\tsize_t Hash = hash32shift(k);\n\t/* SIZE is power of 2 */\n\treturn Hash & (SIZE - 1);\n}\n- cli_htu32_find: const struct cli_htu32_element *cli_htu32_find(const struct cli_htu32 *s, uint32_t key) /* <=== cli_htu32_find */ \n{\n\tstruct cli_htu32_element* element;\n\tsize_t tries = 1;\n\tsize_t idx;\n\n\tif(!s)\n\t\treturn NULL;\n\tPROFILE_CALC_HASH(s);\n\tPROFILE_FIND_ELEMENT(s);\n\tidx = hash_htu32(key, s->capacity);\n\telement = &s->htable[idx];\n\tdo {\n\t\tif(!element->key) {\n\t\t\tPROFILE_FIND_NOTFOUND(s, tries);\n\t\t\treturn NULL; /* element not found, place is empty */\n\t\t}\n\t\telse if(key == element->key) {\n\t\t\tPROFILE_FIND_FOUND(s, tries);\n\t\t\treturn element;/* found */\n\t\t}\n\t\telse {\n\t\t\tidx = (idx + tries++) & (s->capacity-1);\n\t\t\telement = &s->htable[idx];\n\t\t}\n\t} while (tries <= s->capacity);\n\tPROFILE_HASH_EXHAUSTED(s);\n\treturn NULL; /* not found */\n}\n\nType Definitions:\n- ANY: typedef struct {\n\n   struct {\n       void (*finish_pass)(j_decompress_ptr);\n       void (*color_quantize)(j_decompress_ptr, JSAMPARRAY, JSAMPARRAY, int);\n       void (*start_pass)(j_decompress_ptr, bool);\n       void (*new_color_map)(j_decompress_ptr);\n   } pub;\n\n  /* Space for the eventually created colormap is stashed here */\n  JSAMPARRAY sv_colormap;   /* colormap allocated at init time */\n  int desired;          /* desired # of colors = size of colormap */\n\n  /* Variables for accumulating image statistics */\n  hist3d histogram;     /* pointer to the histogram */\n\n  bool needs_zeroed;        /* true if next pass must zero histogram */\n\n  /* Variables for Floyd-Steinberg dithering */\n  FSERRPTR fserrors;        /* accumulated errors */\n  bool on_odd_row;      /* flag to remember which row we are on */\n  int * error_limiter;      /* table for clamping the applied error */\n}\n- cli_matcher: struct cli_matcher {\n    unsigned int type;\n\n    /* Extended Boyer-Moore */\n    uint8_t *bm_shift;\n    struct cli_bm_patt **bm_suffix, **bm_pattab;\n    uint32_t *soff, soff_len; /* for PE section sigs */\n    uint32_t bm_offmode, bm_patterns, bm_reloff_num, bm_absoff_num;\n\n    /* HASH */\n    struct cli_hash_patt hm;\n\n    /* Extended Aho-Corasick */\n    uint32_t ac_partsigs, ac_nodes, ac_patterns, ac_lsigs;\n    struct cli_ac_lsig **ac_lsigtable;\n    struct cli_ac_node *ac_root, **ac_nodetable;\n    struct cli_ac_patt **ac_pattable;\n    struct cli_ac_patt **ac_reloff;\n    uint32_t ac_reloff_num, ac_absoff_num;\n    uint8_t ac_mindepth, ac_maxdepth;\n    struct filter *filter;\n\n    uint16_t maxpatlen;\n    uint8_t ac_only;\n#ifdef USE_MPOOL\n    mpool_t *mempool;\n#endif\n}\n- ANY: typedef struct {\n\tMD5_u32plus lo, hi;\n\tMD5_u32plus a, b, c, d;\n\tunsigned char buffer[64];\n\tMD5_u32plus block[16];\n}\n- cli_sz_hash: struct cli_sz_hash {\n    uint8_t *hash_array;\n    const char **virusnames;\n    uint32_t items;\n}\n- CLI_HASH_TYPE: enum CLI_HASH_TYPE {\n    CLI_HASH_MD5,\n    CLI_HASH_SHA1,\n    CLI_HASH_SHA256,\n\n    /* new hash types go above this line */\n    CLI_HASH_AVAIL_TYPES\n}\n\nImports:\n- #include <string.h>\n- #include <stdlib.h>\n- #include \"matcher.h\"\n- #include \"str.h\"\n- #include \"others.h\"",
    "commit_msg": "bb#2818",
    "cve_desc": "Off-by-one error in the cli_hm_scan function in matcher-hash.c in libclamav in ClamAV before 0.97.2 allows remote attackers to cause a denial of service (daemon crash) via an e-mail message that is not properly handled during certain hash calculations.",
    "year": 2011,
    "filename": "matcher-hash.c",
    "commit_url": "\"https://github.com/vrtadmin/clamav-devel/commit/4842733eb3f09be61caeed83778bb6679141dbc5\""
  },
  {
    "repository": "torproject/tor",
    "cve_id": "CVE-2011-2768",
    "cwe_list": [
      "CWE-264"
    ],
    "commit_hash": "00fffbc1a15e2696a89c721d0c94dc333ff419ef",
    "short_hash": "00fffbc1",
    "vulnerableMethods_before": [
      {
        "filename": "src/or/dirserv.c",
        "method_name": "set_routerstatus_from_routerinfo",
        "raw_code": "void /* <=== set_routerstatus_from_routerinfo */ \nset_routerstatus_from_routerinfo(routerstatus_t *rs,\n                                 routerinfo_t *ri, time_t now,\n                                 int naming, int listbadexits,\n                                 int listbaddirs, int vote_on_hsdirs)\n{\n  int unstable_version =\n    !tor_version_as_new_as(ri->platform,\"0.1.1.16-rc-cvs\");\n  memset(rs, 0, sizeof(routerstatus_t));\n\n  rs->is_authority =\n    router_digest_is_trusted_dir(ri->cache_info.identity_digest);\n\n  /* Already set by compute_performance_thresholds. */\n  rs->is_exit = ri->is_exit;\n  rs->is_stable = ri->is_stable =\n    router_is_active(ri, now) &&\n    !dirserv_thinks_router_is_unreliable(now, ri, 1, 0) &&\n    !unstable_version;\n  rs->is_fast = ri->is_fast =\n    router_is_active(ri, now) &&\n    !dirserv_thinks_router_is_unreliable(now, ri, 0, 1);\n  rs->is_running = ri->is_running; /* computed above */\n\n  if (naming) {\n    uint32_t name_status = dirserv_get_name_status(\n                         ri->cache_info.identity_digest, ri->nickname);\n    rs->is_named = (naming && (name_status & FP_NAMED)) ? 1 : 0;\n    rs->is_unnamed = (naming && (name_status & FP_UNNAMED)) ? 1 : 0;\n  }\n  rs->is_valid = ri->is_valid;\n\n  if (rs->is_fast &&\n      (router_get_advertised_bandwidth(ri) >= BANDWIDTH_TO_GUARANTEE_GUARD ||\n       router_get_advertised_bandwidth(ri) >=\n                              MIN(guard_bandwidth_including_exits,\n                                  guard_bandwidth_excluding_exits))) {\n    long tk = rep_hist_get_weighted_time_known(\n                                      ri->cache_info.identity_digest, now);\n    double wfu = rep_hist_get_weighted_fractional_uptime(\n                                      ri->cache_info.identity_digest, now);\n    rs->is_possible_guard = (wfu >= guard_wfu && tk >= guard_tk) ? 1 : 0;\n  } else {\n    rs->is_possible_guard = 0;\n  }\n  rs->is_bad_directory = listbaddirs && ri->is_bad_directory;\n  rs->is_bad_exit = listbadexits && ri->is_bad_exit;\n  ri->is_hs_dir = dirserv_thinks_router_is_hs_dir(ri, now);\n  rs->is_hs_dir = vote_on_hsdirs && ri->is_hs_dir;\n  rs->is_v2_dir = ri->dir_port != 0;\n\n  if (!strcasecmp(ri->nickname, UNNAMED_ROUTER_NICKNAME))\n    rs->is_named = rs->is_unnamed = 0;\n\n  rs->published_on = ri->cache_info.published_on;\n  memcpy(rs->identity_digest, ri->cache_info.identity_digest, DIGEST_LEN);\n  memcpy(rs->descriptor_digest, ri->cache_info.signed_descriptor_digest,\n         DIGEST_LEN);\n  rs->addr = ri->addr;\n  strlcpy(rs->nickname, ri->nickname, sizeof(rs->nickname));\n  rs->or_port = ri->or_port;\n  rs->dir_port = ri->dir_port;\n}",
        "start_line": 2261
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "src/or/dirserv.c",
        "method_name": "is_router_version_good_for_possible_guard",
        "raw_code": "static int /* <=== is_router_version_good_for_possible_guard */ \nis_router_version_good_for_possible_guard(const char *platform)\n{\n  static int parsed_versions_initialized = 0;\n  static tor_version_t first_good_0_2_1_guard_version;\n  static tor_version_t first_good_0_2_2_guard_version;\n  static tor_version_t first_good_later_guard_version;\n\n  tor_version_t router_version;\n\n  /* XXX023 This block should be extracted into its own function. */\n  /* XXXX Begin code copied from tor_version_as_new_as (in routerparse.c) */\n  {\n    char *s, *s2, *start;\n    char tmp[128];\n\n    tor_assert(platform);\n\n    if (strcmpstart(platform,\"Tor \")) /* nonstandard Tor; be safe and say yes */\n      return 1;\n\n    start = (char *)eat_whitespace(platform+3);\n    if (!*start) return 0;\n    s = (char *)find_whitespace(start); /* also finds '\\0', which is fine */\n    s2 = (char*)eat_whitespace(s);\n    if (!strcmpstart(s2, \"(r\") || !strcmpstart(s2, \"(git-\"))\n      s = (char*)find_whitespace(s2);\n\n    if ((size_t)(s-start+1) >= sizeof(tmp)) /* too big, no */\n      return 0;\n    strlcpy(tmp, start, s-start+1);\n\n    if (tor_version_parse(tmp, &router_version)<0) {\n      log_info(LD_DIR,\"Router version '%s' unparseable.\",tmp);\n      return 1; /* be safe and say yes */\n    }\n  }\n  /* XXXX End code copied from tor_version_as_new_as (in routerparse.c) */\n\n  if (!parsed_versions_initialized) {\n    /* CVE-2011-2769 was fixed on the relay side in Tor versions\n     * 0.2.1.31, 0.2.2.34, and 0.2.3.6-alpha. */\n    tor_assert(tor_version_parse(\"0.2.1.31\",\n                                 &first_good_0_2_1_guard_version)>=0);\n    tor_assert(tor_version_parse(\"0.2.2.34\",\n                                 &first_good_0_2_2_guard_version)>=0);\n    tor_assert(tor_version_parse(\"0.2.3.6-alpha\",\n                                 &first_good_later_guard_version)>=0);\n\n    /* Don't parse these constant version strings once for every relay\n     * for every vote. */\n    parsed_versions_initialized = 1;\n  }\n\n  return ((tor_version_same_series(&first_good_0_2_1_guard_version,\n                                   &router_version) &&\n           tor_version_compare(&first_good_0_2_1_guard_version,\n                               &router_version) <= 0) ||\n          (tor_version_same_series(&first_good_0_2_2_guard_version,\n                                   &router_version) &&\n           tor_version_compare(&first_good_0_2_2_guard_version,\n                               &router_version) <= 0) ||\n          (tor_version_compare(&first_good_later_guard_version,\n                               &router_version) <= 0));\n}",
        "start_line": 2256
      },
      {
        "filename": "src/or/dirserv.c",
        "method_name": "set_routerstatus_from_routerinfo",
        "raw_code": "void /* <=== set_routerstatus_from_routerinfo */ \nset_routerstatus_from_routerinfo(routerstatus_t *rs,\n                                 routerinfo_t *ri, time_t now,\n                                 int naming, int listbadexits,\n                                 int listbaddirs, int vote_on_hsdirs)\n{\n  int unstable_version =\n    !tor_version_as_new_as(ri->platform,\"0.1.1.16-rc-cvs\");\n  memset(rs, 0, sizeof(routerstatus_t));\n\n  rs->is_authority =\n    router_digest_is_trusted_dir(ri->cache_info.identity_digest);\n\n  /* Already set by compute_performance_thresholds. */\n  rs->is_exit = ri->is_exit;\n  rs->is_stable = ri->is_stable =\n    router_is_active(ri, now) &&\n    !dirserv_thinks_router_is_unreliable(now, ri, 1, 0) &&\n    !unstable_version;\n  rs->is_fast = ri->is_fast =\n    router_is_active(ri, now) &&\n    !dirserv_thinks_router_is_unreliable(now, ri, 0, 1);\n  rs->is_running = ri->is_running; /* computed above */\n\n  if (naming) {\n    uint32_t name_status = dirserv_get_name_status(\n                         ri->cache_info.identity_digest, ri->nickname);\n    rs->is_named = (naming && (name_status & FP_NAMED)) ? 1 : 0;\n    rs->is_unnamed = (naming && (name_status & FP_UNNAMED)) ? 1 : 0;\n  }\n  rs->is_valid = ri->is_valid;\n\n  if (rs->is_fast &&\n      (router_get_advertised_bandwidth(ri) >= BANDWIDTH_TO_GUARANTEE_GUARD ||\n       router_get_advertised_bandwidth(ri) >=\n                              MIN(guard_bandwidth_including_exits,\n                                  guard_bandwidth_excluding_exits)) &&\n      is_router_version_good_for_possible_guard(ri->platform)) {\n    long tk = rep_hist_get_weighted_time_known(\n                                      ri->cache_info.identity_digest, now);\n    double wfu = rep_hist_get_weighted_fractional_uptime(\n                                      ri->cache_info.identity_digest, now);\n    rs->is_possible_guard = (wfu >= guard_wfu && tk >= guard_tk) ? 1 : 0;\n  } else {\n    rs->is_possible_guard = 0;\n  }\n  rs->is_bad_directory = listbaddirs && ri->is_bad_directory;\n  rs->is_bad_exit = listbadexits && ri->is_bad_exit;\n  ri->is_hs_dir = dirserv_thinks_router_is_hs_dir(ri, now);\n  rs->is_hs_dir = vote_on_hsdirs && ri->is_hs_dir;\n  rs->is_v2_dir = ri->dir_port != 0;\n\n  if (!strcasecmp(ri->nickname, UNNAMED_ROUTER_NICKNAME))\n    rs->is_named = rs->is_unnamed = 0;\n\n  rs->published_on = ri->cache_info.published_on;\n  memcpy(rs->identity_digest, ri->cache_info.identity_digest, DIGEST_LEN);\n  memcpy(rs->descriptor_digest, ri->cache_info.signed_descriptor_digest,\n         DIGEST_LEN);\n  rs->addr = ri->addr;\n  strlcpy(rs->nickname, ri->nickname, sizeof(rs->nickname));\n  rs->or_port = ri->or_port;\n  rs->dir_port = ri->dir_port;\n}",
        "start_line": 2329
      }
    ],
    "code_context": "Called Methods:\n- fast_memcmp: #define fast_memcmp(a,b,c) (memcmp((a),(b),(c))) /* <=== src/common/di_ops.h:26:26:fast_memcmp:3 */ \n- get_or_history: static or_history_t * /* <=== get_or_history */ \nget_or_history(const char* id)\n{\n  or_history_t *hist;\n\n  if (tor_digest_is_zero(id))\n    return NULL;\n\n  hist = digestmap_get(history_map, id);\n  if (!hist) {\n    hist = tor_malloc_zero(sizeof(or_history_t));\n    rephist_total_alloc += sizeof(or_history_t);\n    rephist_total_num++;\n    hist->link_history_map = digestmap_new();\n    hist->since = hist->changed = time(NULL);\n    tor_addr_make_unspec(&hist->last_reached_addr);\n    digestmap_set(history_map, id, hist);\n  }\n  return hist;\n}\n- base16_encode: void /* <=== base16_encode */ \nbase16_encode(char *dest, size_t destlen, const char *src, size_t srclen)\n{\n  const char *end;\n  char *cp;\n\n  tor_assert(destlen >= srclen*2+1);\n  tor_assert(destlen < SIZE_T_CEILING);\n\n  cp = dest;\n  end = src+srclen;\n  while (src<end) {\n    *cp++ = \"0123456789ABCDEF\"[ (*(const uint8_t*)src) >> 4 ];\n    *cp++ = \"0123456789ABCDEF\"[ (*(const uint8_t*)src) & 0xf ];\n    ++src;\n  }\n  *cp = '\\0';\n}\n- LD_BUG: #define LD_BUG      (1u<<12) /* <=== src/common/torlog.h:79:79:LD_BUG:0 */ \n- strcasecmp: #define strcasecmp _stricmp /* <=== src/common/compat.h:197:197:strcasecmp:0 */ \n- strmap_get_lc: void* strmap_get_lc(const strmap_t *map, const char *key); /* <=== strmap_get_lc */ \n- LD_DIR: #define LD_DIR      (1u<<13) /* <=== src/common/torlog.h:81:81:LD_DIR:0 */ \n- _log_info: void _log_info(log_domain_mask_t domain, const char *format, ...); /* <=== _log_info */ \n- FP_UNNAMED: #define FP_UNNAMED 32 /**< Another router has this name in fingerprint file. */ /* <=== src/or/dirserv.c:94:94:FP_UNNAMED:0 */ \n- tor_version_parse: int /* <=== tor_version_parse */ \ntor_version_parse(const char *s, tor_version_t *out)\n{\n  char *eos=NULL;\n  const char *cp=NULL;\n  /* Format is:\n   *   \"Tor \" ? NUM dot NUM dot NUM [ ( pre | rc | dot ) NUM [ - tag ] ]\n   */\n  tor_assert(s);\n  tor_assert(out);\n\n  memset(out, 0, sizeof(tor_version_t));\n\n  if (!strcasecmpstart(s, \"Tor \"))\n    s += 4;\n\n  /* Get major. */\n  out->major = (int)strtol(s,&eos,10);\n  if (!eos || eos==s || *eos != '.') return -1;\n  cp = eos+1;\n\n  /* Get minor */\n  out->minor = (int) strtol(cp,&eos,10);\n  if (!eos || eos==cp || *eos != '.') return -1;\n  cp = eos+1;\n\n  /* Get micro */\n  out->micro = (int) strtol(cp,&eos,10);\n  if (!eos || eos==cp) return -1;\n  if (!*eos) {\n    out->status = VER_RELEASE;\n    out->patchlevel = 0;\n    return 0;\n  }\n  cp = eos;\n\n  /* Get status */\n  if (*cp == '.') {\n    out->status = VER_RELEASE;\n    ++cp;\n  } else if (0==strncmp(cp, \"pre\", 3)) {\n    out->status = VER_PRE;\n    cp += 3;\n  } else if (0==strncmp(cp, \"rc\", 2)) {\n    out->status = VER_RC;\n    cp += 2;\n  } else {\n    return -1;\n  }\n\n  /* Get patchlevel */\n  out->patchlevel = (int) strtol(cp,&eos,10);\n  if (!eos || eos==cp) return -1;\n  cp = eos;\n\n  /* Get status tag. */\n  if (*cp == '-' || *cp == '.')\n    ++cp;\n  eos = (char*) find_whitespace(cp);\n  if (eos-cp >= (int)sizeof(out->status_tag))\n    strlcpy(out->status_tag, cp, sizeof(out->status_tag));\n  else {\n    memcpy(out->status_tag, cp, eos-cp);\n    out->status_tag[eos-cp] = 0;\n  }\n  cp = eat_whitespace(eos);\n\n  if (!strcmpstart(cp, \"(r\")) {\n    cp += 2;\n    out->svn_revision = (int) strtol(cp,&eos,10);\n  } else if (!strcmpstart(cp, \"(git-\")) {\n    char *close_paren = strchr(cp, ')');\n    int hexlen;\n    char digest[DIGEST_LEN];\n    if (! close_paren)\n      return -1;\n    cp += 5;\n    if (close_paren-cp > HEX_DIGEST_LEN)\n      return -1;\n    hexlen = (int)(close_paren-cp);\n    memset(digest, 0, sizeof(digest));\n    if ( hexlen == 0 || (hexlen % 2) == 1)\n      return -1;\n    if (base16_decode(digest, hexlen/2, cp, hexlen))\n      return -1;\n    memcpy(out->git_tag, digest, hexlen/2);\n    out->git_tag_len = hexlen/2;\n  }\n\n  return 0;\n}\n- rep_hist_get_uptime: long /* <=== rep_hist_get_uptime */ \nrep_hist_get_uptime(const char *id, time_t when)\n{\n  or_history_t *hist = get_or_history(id);\n  if (!hist)\n    return 0;\n  if (!hist->start_of_run || when < hist->start_of_run)\n    return 0;\n  return when - hist->start_of_run;\n}\n- rep_hist_get_stability: double /* <=== rep_hist_get_stability */ \nrep_hist_get_stability(const char *id, time_t when)\n{\n  or_history_t *hist = get_or_history(id);\n  if (!hist)\n    return 0.0;\n\n  return get_stability(hist, when);\n}\n- DIGEST_LEN: #define DIGEST_LEN 20 /* <=== src/common/crypto.h:20:20:DIGEST_LEN:0 */ \n- real_uptime: static INLINE long /* <=== real_uptime */ \nreal_uptime(routerinfo_t *router, time_t now)\n{\n  if (now < router->cache_info.published_on)\n    return router->uptime;\n  else\n    return router->uptime + (now - router->cache_info.published_on);\n}\n- dirserv_thinks_router_is_unreliable: static int /* <=== dirserv_thinks_router_is_unreliable */ \ndirserv_thinks_router_is_unreliable(time_t now,\n                                    routerinfo_t *router,\n                                    int need_uptime, int need_capacity)\n{\n  if (need_uptime) {\n    if (!enough_mtbf_info) {\n      /* XXX023 Once most authorities are on v3, we should change the rule from\n       * \"use uptime if we don't have mtbf data\" to \"don't advertise Stable on\n       * v3 if we don't have enough mtbf data.\"  Or maybe not, since if we ever\n       * hit a point where we need to reset a lot of authorities at once,\n       * none of them would be in a position to declare Stable.\n       */\n      long uptime = real_uptime(router, now);\n      if ((unsigned)uptime < stable_uptime &&\n          (unsigned)uptime < UPTIME_TO_GUARANTEE_STABLE)\n        return 1;\n    } else {\n      double mtbf =\n        rep_hist_get_stability(router->cache_info.identity_digest, now);\n      if (mtbf < stable_mtbf &&\n          mtbf < MTBF_TO_GUARANTEE_STABLE)\n        return 1;\n    }\n  }\n  if (need_capacity) {\n    uint32_t bw = router_get_advertised_bandwidth(router);\n    if (bw < fast_bandwidth)\n      return 1;\n  }\n  return 0;\n}\n- rep_hist_get_weighted_time_known: long /* <=== rep_hist_get_weighted_time_known */ \nrep_hist_get_weighted_time_known(const char *id, time_t when)\n{\n  or_history_t *hist = get_or_history(id);\n  if (!hist)\n    return 0;\n\n  return get_total_weighted_time(hist, when);\n}\n- get_total_weighted_time: static long /* <=== get_total_weighted_time */ \nget_total_weighted_time(or_history_t *hist, time_t when)\n{\n  long total = hist->total_weighted_time;\n  if (hist->start_of_run) {\n    total += (when - hist->start_of_run);\n  } else if (hist->start_of_downtime) {\n    total += (when - hist->start_of_downtime);\n  }\n  return total;\n}\n- get_options: or_options_t * /* <=== get_options */ \nget_options(void)\n{\n  tor_assert(global_options);\n  return global_options;\n}\n- eat_whitespace: const char * /* <=== eat_whitespace */ \neat_whitespace(const char *s)\n{\n  tor_assert(s);\n\n  while (1) {\n    switch (*s) {\n    case '\\0':\n    default:\n      return s;\n    case ' ':\n    case '\\t':\n    case '\\n':\n    case '\\r':\n      ++s;\n      break;\n    case '#':\n      ++s;\n      while (*s && *s != '\\n')\n        ++s;\n    }\n  }\n}\n- _log_warn: void _log_warn(log_domain_mask_t domain, const char *format, ...); /* <=== _log_warn */ \n- HEX_DIGEST_LEN: #define HEX_DIGEST_LEN 40 /* <=== src/common/crypto.h:56:56:HEX_DIGEST_LEN:0 */ \n- FP_NAMED: #define FP_NAMED   1  /**< Listed in fingerprint file. */ /* <=== src/or/dirserv.c:89:89:FP_NAMED:0 */ \n- strcasecmpstart: int /* <=== strcasecmpstart */ \nstrcasecmpstart(const char *s1, const char *s2)\n{\n  size_t n = strlen(s2);\n  return strncasecmp(s1, s2, n);\n}\n- rep_hist_get_weighted_fractional_uptime: double /* <=== rep_hist_get_weighted_fractional_uptime */ \nrep_hist_get_weighted_fractional_uptime(const char *id, time_t when)\n{\n  or_history_t *hist = get_or_history(id);\n  if (!hist)\n    return 0.0;\n\n  return get_weighted_fractional_uptime(hist, when);\n}\n- strcmpstart: int /* <=== strcmpstart */ \nstrcmpstart(const char *s1, const char *s2)\n{\n  size_t n = strlen(s2);\n  return strncmp(s1, s2, n);\n}\n- base16_decode: int /* <=== base16_decode */ \nbase16_decode(char *dest, size_t destlen, const char *src, size_t srclen)\n{\n  const char *end;\n\n  int v1,v2;\n  if ((srclen % 2) != 0)\n    return -1;\n  if (destlen < srclen/2 || destlen > SIZE_T_CEILING)\n    return -1;\n  end = src+srclen;\n  while (src<end) {\n    v1 = _hex_decode_digit(*src);\n    v2 = _hex_decode_digit(*(src+1));\n    if (v1<0||v2<0)\n      return -1;\n    *(uint8_t*)dest = (v1<<4)|v2;\n    ++dest;\n    src+=2;\n  }\n  return 0;\n}\n- get_weighted_fractional_uptime: static double /* <=== get_weighted_fractional_uptime */ \nget_weighted_fractional_uptime(or_history_t *hist, time_t when)\n{\n  long total = hist->total_weighted_time;\n  long up = hist->weighted_uptime;\n\n  if (hist->start_of_run) {\n    long run_length = (when - hist->start_of_run);\n    up += run_length;\n    total += run_length;\n  } else if (hist->start_of_downtime) {\n    total += (when - hist->start_of_downtime);\n  }\n\n  if (!total) {\n    /* Avoid calling anybody's uptime infinity (which should be impossible if\n     * the code is working), or NaN (which can happen for any router we haven't\n     * observed up or down yet). */\n    return 0.0;\n  }\n\n  return ((double) up) / total;\n}\n- dirserv_get_name_status: static uint32_t /* <=== dirserv_get_name_status */ \ndirserv_get_name_status(const char *id_digest, const char *nickname)\n{\n  char fp[HEX_DIGEST_LEN+1];\n  char *fp_by_name;\n\n  base16_encode(fp, sizeof(fp), id_digest, DIGEST_LEN);\n\n  if ((fp_by_name =\n       strmap_get_lc(fingerprint_list->fp_by_name, nickname))) {\n    if (!strcasecmp(fp, fp_by_name)) {\n      return FP_NAMED;\n    } else {\n      return FP_UNNAMED; /* Wrong fingerprint. */\n    }\n  }\n  return 0;\n}\n- UNNAMED_ROUTER_NICKNAME: #define UNNAMED_ROUTER_NICKNAME \"Unnamed\" /* <=== src/or/dirserv.h:55:55:UNNAMED_ROUTER_NICKNAME:0 */ \n- tor_version_as_new_as: int /* <=== tor_version_as_new_as */ \ntor_version_as_new_as(const char *platform, const char *cutoff)\n{\n  tor_version_t cutoff_version, router_version;\n  char *s, *s2, *start;\n  char tmp[128];\n\n  tor_assert(platform);\n\n  if (tor_version_parse(cutoff, &cutoff_version)<0) {\n    log_warn(LD_BUG,\"cutoff version '%s' unparseable.\",cutoff);\n    return 0;\n  }\n  if (strcmpstart(platform,\"Tor \")) /* nonstandard Tor; be safe and say yes */\n    return 1;\n\n  start = (char *)eat_whitespace(platform+3);\n  if (!*start) return 0;\n  s = (char *)find_whitespace(start); /* also finds '\\0', which is fine */\n  s2 = (char*)eat_whitespace(s);\n  if (!strcmpstart(s2, \"(r\") || !strcmpstart(s2, \"(git-\"))\n    s = (char*)find_whitespace(s2);\n\n  if ((size_t)(s-start+1) >= sizeof(tmp)) /* too big, no */\n    return 0;\n  strlcpy(tmp, start, s-start+1);\n\n  if (tor_version_parse(tmp, &router_version)<0) {\n    log_info(LD_DIR,\"Router version '%s' unparseable.\",tmp);\n    return 1; /* be safe and say yes */\n  }\n\n  /* Here's why we don't need to do any special handling for svn revisions:\n   * - If neither has an svn revision, we're fine.\n   * - If the router doesn't have an svn revision, we can't assume that it\n   *   is \"at least\" any svn revision, so we need to return 0.\n   * - If the target version doesn't have an svn revision, any svn revision\n   *   (or none at all) is good enough, so return 1.\n   * - If both target and router have an svn revision, we compare them.\n   */\n\n  return tor_version_compare(&router_version, &cutoff_version) >= 0;\n}\n- BANDWIDTH_TO_GUARANTEE_GUARD: #define BANDWIDTH_TO_GUARANTEE_GUARD (250*1024) /* <=== src/or/dirserv.c:1700:1700:BANDWIDTH_TO_GUARANTEE_GUARD:0 */ \n- MTBF_TO_GUARANTEE_STABLE: #define MTBF_TO_GUARANTEE_STABLE (60*60*24*5) /* <=== src/or/dirserv.c:1694:1694:MTBF_TO_GUARANTEE_STABLE:0 */ \n- ROUTER_MAX_AGE_TO_PUBLISH: #define ROUTER_MAX_AGE_TO_PUBLISH (60*60*20) /* <=== src/or/or.h:175:175:ROUTER_MAX_AGE_TO_PUBLISH:0 */ \n- UPTIME_TO_GUARANTEE_STABLE: #define UPTIME_TO_GUARANTEE_STABLE (3600*24*30) /* <=== src/or/dirserv.c:1691:1691:UPTIME_TO_GUARANTEE_STABLE:0 */ \n- MIN: #define MIN(a,b) ( ((a)>(b)) ? (b) : (a) ) /* <=== src/common/compat.h:645:645:MIN:2 */ \n- tor_version_same_series: int /* <=== tor_version_same_series */ \ntor_version_same_series(tor_version_t *a, tor_version_t *b)\n{\n  tor_assert(a);\n  tor_assert(b);\n  return ((a->major == b->major) &&\n          (a->minor == b->minor) &&\n          (a->micro == b->micro));\n}\n- router_is_active: static int /* <=== router_is_active */ \nrouter_is_active(routerinfo_t *ri, time_t now)\n{\n  time_t cutoff = now - ROUTER_MAX_AGE_TO_PUBLISH;\n  if (ri->cache_info.published_on < cutoff)\n    return 0;\n  if (!ri->is_running || !ri->is_valid || ri->is_hibernating)\n    return 0;\n  return 1;\n}\n- tor_version_compare: int /* <=== tor_version_compare */ \ntor_version_compare(tor_version_t *a, tor_version_t *b)\n{\n  int i;\n  tor_assert(a);\n  tor_assert(b);\n  if ((i = a->major - b->major))\n    return i;\n  else if ((i = a->minor - b->minor))\n    return i;\n  else if ((i = a->micro - b->micro))\n    return i;\n  else if ((i = a->status - b->status))\n    return i;\n  else if ((i = a->patchlevel - b->patchlevel))\n    return i;\n  else if ((i = strcmp(a->status_tag, b->status_tag)))\n    return i;\n  else if ((i = a->svn_revision - b->svn_revision))\n    return i;\n  else if ((i = a->git_tag_len - b->git_tag_len))\n    return i;\n  else if (a->git_tag_len)\n    return fast_memcmp(a->git_tag, b->git_tag, a->git_tag_len);\n  else\n    return 0;\n}\n- _log_err: void _log_err(log_domain_mask_t domain, const char *format, ...); /* <=== _log_err */ \n- router_get_advertised_bandwidth: uint32_t /* <=== router_get_advertised_bandwidth */ \nrouter_get_advertised_bandwidth(routerinfo_t *router)\n{\n  if (router->bandwidthcapacity < router->bandwidthrate)\n    return router->bandwidthcapacity;\n  return router->bandwidthrate;\n}\n- find_whitespace: const char * /* <=== find_whitespace */ \nfind_whitespace(const char *s)\n{\n  /* tor_assert(s); */\n  while (1) {\n    switch (*s)\n    {\n    case '\\0':\n    case '#':\n    case ' ':\n    case '\\r':\n    case '\\n':\n    case '\\t':\n      return s;\n    default:\n      ++s;\n    }\n  }\n}\n- strlcpy: size_t strlcpy(char *dst, const char *src, size_t siz) /* <=== strlcpy */ \n{\n\tregister char *d = dst;\n\tregister const char *s = src;\n\tregister size_t n = siz;\n\n\tif (n == 0)\n\t\treturn(strlen(s));\n\twhile (*s != '\\0') {\n\t\tif (n != 1) {\n\t\t\t*d++ = *s;\n\t\t\tn--;\n\t\t}\n\t\ts++;\n\t}\n\t*d = '\\0';\n\n\treturn(s - src);\t/* count does not include NUL */\n}\n- tor_assert: #define tor_assert(expr) STMT_BEGIN                                     \\ /* <=== src/common/util.h:45:52:tor_assert:1 */ \n    if (PREDICT_UNLIKELY(!(expr))) {                                    \\\n      log_err(LD_BUG, \"%s:%d: %s: Assertion %s failed; aborting.\",      \\\n          _SHORT_FILE_, __LINE__, __func__, #expr);                     \\\n      fprintf(stderr,\"%s:%d %s: Assertion %s failed; aborting.\\n\",      \\\n              _SHORT_FILE_, __LINE__, __func__, #expr);                 \\\n      abort();                                                          \\\n    } STMT_END\n- dirserv_thinks_router_is_hs_dir: static int /* <=== dirserv_thinks_router_is_hs_dir */ \ndirserv_thinks_router_is_hs_dir(routerinfo_t *router, time_t now)\n{\n\n  long uptime;\n\n  /* If we haven't been running for at least\n   * get_options()->MinUptimeHidServDirectoryV2 seconds, we can't\n   * have accurate data telling us a relay has been up for at least\n   * that long. We also want to allow a bit of slack: Reachability\n   * tests aren't instant. If we haven't been running long enough,\n   * trust the relay. */\n\n  if (stats_n_seconds_working >\n      get_options()->MinUptimeHidServDirectoryV2 * 1.1)\n    uptime = MIN(rep_hist_get_uptime(router->cache_info.identity_digest, now),\n                 real_uptime(router, now));\n  else\n    uptime = real_uptime(router, now);\n\n  /* XXX We shouldn't need to check dir_port, but we do because of\n   * bug 1693. In the future, once relays set wants_to_be_hs_dir\n   * correctly, we can revert to only checking dir_port if router's\n   * version is too old. */\n  /* XXX Unfortunately, we need to keep checking dir_port until all\n   * *clients* suffering from bug 2722 are obsolete.  The first version\n   * to fix the bug was 0.2.2.25-alpha. */\n  return (router->wants_to_be_hs_dir && router->dir_port &&\n          uptime > get_options()->MinUptimeHidServDirectoryV2 &&\n          router->is_running);\n}\n- router_digest_is_trusted_dir: #define router_digest_is_trusted_dir(d) \\ /* <=== src/or/routerlist.h:65:66:router_digest_is_trusted_dir:1 */ \n  router_digest_is_trusted_dir_type((d), NO_AUTHORITY)\n\nType Definitions:\n- routerinfo_t: typedef struct {\n  signed_descriptor_t cache_info;\n  char *address; /**< Location of OR: either a hostname or an IP address. */\n  char *nickname; /**< Human-readable OR name. */\n\n  uint32_t addr; /**< IPv4 address of OR, in host order. */\n  uint16_t or_port; /**< Port for TLS connections. */\n  uint16_t dir_port; /**< Port for HTTP directory connections. */\n\n  crypto_pk_env_t *onion_pkey; /**< Public RSA key for onions. */\n  crypto_pk_env_t *identity_pkey;  /**< Public RSA key for signing. */\n\n  char *platform; /**< What software/operating system is this OR using? */\n\n  /* link info */\n  uint32_t bandwidthrate; /**< How many bytes does this OR add to its token\n                           * bucket per second? */\n  uint32_t bandwidthburst; /**< How large is this OR's token bucket? */\n  /** How many bytes/s is this router known to handle? */\n  uint32_t bandwidthcapacity;\n  smartlist_t *exit_policy; /**< What streams will this OR permit\n                             * to exit?  NULL for 'reject *:*'. */\n  long uptime; /**< How many seconds the router claims to have been up */\n  smartlist_t *declared_family; /**< Nicknames of router which this router\n                                 * claims are its family. */\n  char *contact_info; /**< Declared contact info for this router. */\n  unsigned int is_hibernating:1; /**< Whether the router claims to be\n                                  * hibernating */\n  unsigned int has_old_dnsworkers:1; /**< Whether the router is using\n                                      * dnsworker code. */\n  unsigned int caches_extra_info:1; /**< Whether the router caches and serves\n                                     * extrainfo documents. */\n  unsigned int allow_single_hop_exits:1;  /**< Whether the router allows\n                                     * single hop exits. */\n\n  /* local info */\n  unsigned int is_running:1; /**< As far as we know, is this OR currently\n                              * running? */\n  unsigned int is_valid:1; /**< Has a trusted dirserver validated this OR?\n                               *  (For Authdir: Have we validated this OR?)\n                               */\n  unsigned int is_named:1; /**< Do we believe the nickname that this OR gives\n                            * us? */\n  unsigned int is_fast:1; /** Do we think this is a fast OR? */\n  unsigned int is_stable:1; /** Do we think this is a stable OR? */\n  unsigned int is_possible_guard:1; /**< Do we think this is an OK guard? */\n  unsigned int is_exit:1; /**< Do we think this is an OK exit? */\n  unsigned int is_bad_exit:1; /**< Do we think this exit is censored, borked,\n                               * or otherwise nasty? */\n  unsigned int is_bad_directory:1; /**< Do we think this directory is junky,\n                                    * underpowered, or otherwise useless? */\n  unsigned int wants_to_be_hs_dir:1; /**< True iff this router claims to be\n                                      * a hidden service directory. */\n  unsigned int is_hs_dir:1; /**< True iff this router is a hidden service\n                             * directory according to the authorities. */\n  unsigned int policy_is_reject_star:1; /**< True iff the exit policy for this\n                                         * router rejects everything. */\n  /** True if, after we have added this router, we should re-launch\n   * tests for it. */\n  unsigned int needs_retest_if_added:1;\n\n/** Tor can use this router for general positions in circuits. */\n#define ROUTER_PURPOSE_GENERAL 0\n/** Tor should avoid using this router for circuit-building. */\n#define ROUTER_PURPOSE_CONTROLLER 1\n/** Tor should use this router only for bridge positions in circuits. */\n#define ROUTER_PURPOSE_BRIDGE 2\n/** Tor should not use this router; it was marked in cached-descriptors with\n * a purpose we didn't recognize. */\n#define ROUTER_PURPOSE_UNKNOWN 255\n\n  uint8_t purpose; /** What positions in a circuit is this router good for? */\n\n  /* The below items are used only by authdirservers for\n   * reachability testing. */\n  /** When was the last time we could reach this OR? */\n  time_t last_reachable;\n  /** When did we start testing reachability for this OR? */\n  time_t testing_since;\n  /** According to the geoip db what country is this router in? */\n  country_t country;\n}\n- tor_version_t: typedef struct tor_version_t {\n  int major;\n  int minor;\n  int micro;\n  /** Release status.  For version in the post-0.1 format, this is always\n   * VER_RELEASE. */\n  enum { VER_PRE=0, VER_RC=1, VER_RELEASE=2, } status;\n  int patchlevel;\n  char status_tag[MAX_STATUS_TAG_LEN];\n  int svn_revision;\n\n  int git_tag_len;\n  char git_tag[DIGEST_LEN];\n} tor_version_t;\n- uint32_t: typedef unsigned int uint32_t;\n- routerstatus_t: typedef struct routerstatus_t {\n  time_t published_on; /**< When was this router published? */\n  char nickname[MAX_NICKNAME_LEN+1]; /**< The nickname this router says it\n                                      * has. */\n  char identity_digest[DIGEST_LEN]; /**< Digest of the router's identity\n                                     * key. */\n  char descriptor_digest[DIGEST_LEN]; /**< Digest of the router's most recent\n                                       * descriptor. */\n  uint32_t addr; /**< IPv4 address for this router. */\n  uint16_t or_port; /**< OR port for this router. */\n  uint16_t dir_port; /**< Directory port for this router. */\n  unsigned int is_authority:1; /**< True iff this router is an authority. */\n  unsigned int is_exit:1; /**< True iff this router is a good exit. */\n  unsigned int is_stable:1; /**< True iff this router stays up a long time. */\n  unsigned int is_fast:1; /**< True iff this router has good bandwidth. */\n  unsigned int is_running:1; /**< True iff this router is up. */\n  unsigned int is_named:1; /**< True iff \"nickname\" belongs to this router. */\n  unsigned int is_unnamed:1; /**< True iff \"nickname\" belongs to another\n                              * router. */\n  unsigned int is_valid:1; /**< True iff this router isn't invalid. */\n  unsigned int is_v2_dir:1; /**< True iff this router can serve directory\n                             * information with v2 of the directory\n                             * protocol. (All directory caches cache v1\n                             * directories.)  */\n  unsigned int is_possible_guard:1; /**< True iff this router would be a good\n                                     * choice as an entry guard. */\n  unsigned int is_bad_exit:1; /**< True iff this node is a bad choice for\n                               * an exit node. */\n  unsigned int is_bad_directory:1; /**< Do we think this directory is junky,\n                                    * underpowered, or otherwise useless? */\n  unsigned int is_hs_dir:1; /**< True iff this router is a v2-or-later hidden\n                             * service directory. */\n  /** True iff we know version info for this router. (i.e., a \"v\" entry was\n   * included.)  We'll replace all these with a big tor_version_t or a char[]\n   * if the number of traits we care about ever becomes incredibly big. */\n  unsigned int version_known:1;\n  /** True iff this router is a version that supports BEGIN_DIR cells. */\n  unsigned int version_supports_begindir:1;\n  /** True iff this router is a version that supports conditional consensus\n   *  downloads (signed by list of authorities). */\n  unsigned int version_supports_conditional_consensus:1;\n  /** True iff this router is a version that we can post extrainfo docs to. */\n  unsigned int version_supports_extrainfo_upload:1;\n  /** True iff this router is a version that, if it caches directory info,\n   * we can get v3 downloads from. */\n  unsigned int version_supports_v3_dir:1;\n\n  unsigned int has_bandwidth:1; /**< The vote/consensus had bw info */\n  unsigned int has_exitsummary:1; /**< The vote/consensus had exit summaries */\n  unsigned int has_measured_bw:1; /**< The vote/consensus had a measured bw */\n\n  uint32_t measured_bw; /**< Measured bandwidth (capacity) of the router */\n\n  uint32_t bandwidth; /**< Bandwidth (capacity) of the router as reported in\n                       * the vote/consensus, in kilobytes/sec. */\n  char *exitsummary; /**< exit policy summary -\n                      * XXX weasel: this probably should not stay a string. */\n\n  /* ---- The fields below aren't derived from the networkstatus; they\n   * hold local information only. */\n\n  /** True if we, as a directory mirror, want to download the corresponding\n   * routerinfo from the authority who gave us this routerstatus.  (That is,\n   * if we don't have the routerinfo, and if we haven't already tried to get it\n   * from this authority.)  Applies in v2 networkstatus document only.\n   */\n  unsigned int need_to_mirror:1;\n  unsigned int name_lookup_warned:1; /**< Have we warned the user for referring\n                                      * to this (unnamed) router by nickname?\n                                      */\n  time_t last_dir_503_at; /**< When did this router last tell us that it\n                           * was too busy to serve directory info? */\n  download_status_t dl_status;\n\n}\n\nGlobal Variables:\n- static double guard_wfu\n- uint32_t guard_bandwidth_including_exits\n- static long guard_tk\n- uint32_t guard_bandwidth_excluding_exits\n\nImports:\n- #include \"router.h\"\n- #include \"connection_or.h\"\n- #include \"rephist.h\"\n- #include \"buffers.h\"\n- #include \"routerparse.h\"\n- #include \"networkstatus.h\"\n- #include \"or.h\"\n- #include \"microdesc.h\"\n- #include \"hibernate.h\"\n- #include \"routerlist.h\"\n- #include \"config.h\"\n- #include \"directory.h\"\n- #include \"control.h\"\n- #include \"dirserv.h\"\n- #include \"policies.h\"\n- #include \"dirvote.h\"\n- #include \"connection.h\"",
    "commit_msg": "Don't give the Guard flag to relays without the CVE-2011-2768 fix",
    "cve_desc": "Tor before 0.2.2.34, when configured as a client or bridge, sends a TLS certificate chain as part of an outgoing OR connection, which allows remote relays to bypass intended anonymity properties by reading this chain and then determining the set of entry guards that the client or bridge had selected.",
    "year": 2011,
    "filename": "dirserv.c",
    "commit_url": "\"https://github.com/torproject/tor/commit/00fffbc1a15e2696a89c721d0c94dc333ff419ef\""
  },
  {
    "repository": "torproject/tor",
    "cve_id": "CVE-2011-2768",
    "cwe_list": [
      "CWE-264"
    ],
    "commit_hash": "a74e7fd40f1a77eb4000d8216bb5b80cdd8a6193",
    "short_hash": "a74e7fd4",
    "vulnerableMethods_before": [
      {
        "filename": "src/or/command.c",
        "method_name": "command_process_create_cell",
        "raw_code": "static void /* <=== command_process_create_cell */ \ncommand_process_create_cell(cell_t *cell, or_connection_t *conn)\n{\n  or_circuit_t *circ;\n  int id_is_high;\n\n  if (we_are_hibernating()) {\n    log_info(LD_OR,\n             \"Received create cell but we're shutting down. Sending back \"\n             \"destroy.\");\n    connection_or_send_destroy(cell->circ_id, conn,\n                               END_CIRC_REASON_HIBERNATING);\n    return;\n  }\n\n  if (!server_mode(get_options())) {\n    log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n           \"Received create cell (type %d) from %s:%d, but we're a client. \"\n           \"Sending back a destroy.\",\n           (int)cell->command, conn->_base.address, conn->_base.port);\n    connection_or_send_destroy(cell->circ_id, conn,\n                               END_CIRC_REASON_TORPROTOCOL);\n    return;\n  }\n\n  /* If the high bit of the circuit ID is not as expected, close the\n   * circ. */\n  id_is_high = cell->circ_id & (1<<15);\n  if ((id_is_high && conn->circ_id_type == CIRC_ID_TYPE_HIGHER) ||\n      (!id_is_high && conn->circ_id_type == CIRC_ID_TYPE_LOWER)) {\n    log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n           \"Received create cell with unexpected circ_id %d. Closing.\",\n           cell->circ_id);\n    connection_or_send_destroy(cell->circ_id, conn,\n                               END_CIRC_REASON_TORPROTOCOL);\n    return;\n  }\n\n  if (circuit_id_in_use_on_orconn(cell->circ_id, conn)) {\n    routerinfo_t *router = router_get_by_digest(conn->identity_digest);\n    log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n           \"Received CREATE cell (circID %d) for known circ. \"\n           \"Dropping (age %d).\",\n           cell->circ_id, (int)(time(NULL) - conn->_base.timestamp_created));\n    if (router)\n      log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n             \"Details: nickname \\\"%s\\\", platform %s.\",\n             router->nickname, escaped(router->platform));\n    return;\n  }\n\n  circ = or_circuit_new(cell->circ_id, conn);\n  circ->_base.purpose = CIRCUIT_PURPOSE_OR;\n  circuit_set_state(TO_CIRCUIT(circ), CIRCUIT_STATE_ONIONSKIN_PENDING);\n  if (cell->command == CELL_CREATE) {\n    char *onionskin = tor_malloc(ONIONSKIN_CHALLENGE_LEN);\n    memcpy(onionskin, cell->payload, ONIONSKIN_CHALLENGE_LEN);\n\n    /* hand it off to the cpuworkers, and then return. */\n    if (assign_onionskin_to_cpuworker(NULL, circ, onionskin) < 0) {\n      log_warn(LD_GENERAL,\"Failed to hand off onionskin. Closing.\");\n      circuit_mark_for_close(TO_CIRCUIT(circ), END_CIRC_REASON_INTERNAL);\n      return;\n    }\n    log_debug(LD_OR,\"success: handed off onionskin.\");\n  } else {\n    /* This is a CREATE_FAST cell; we can handle it immediately without using\n     * a CPU worker. */\n    char keys[CPATH_KEY_MATERIAL_LEN];\n    char reply[DIGEST_LEN*2];\n\n    tor_assert(cell->command == CELL_CREATE_FAST);\n\n    /* Make sure we never try to use the OR connection on which we\n     * received this cell to satisfy an EXTEND request,  */\n    conn->is_connection_with_client = 1;\n\n    if (fast_server_handshake(cell->payload, (uint8_t*)reply,\n                              (uint8_t*)keys, sizeof(keys))<0) {\n      log_warn(LD_OR,\"Failed to generate key material. Closing.\");\n      circuit_mark_for_close(TO_CIRCUIT(circ), END_CIRC_REASON_INTERNAL);\n      return;\n    }\n    if (onionskin_answer(circ, CELL_CREATED_FAST, reply, keys)<0) {\n      log_warn(LD_OR,\"Failed to reply to CREATE_FAST cell. Closing.\");\n      circuit_mark_for_close(TO_CIRCUIT(circ), END_CIRC_REASON_INTERNAL);\n      return;\n    }\n  }\n}",
        "start_line": 218
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "src/or/command.c",
        "method_name": "command_process_create_cell",
        "raw_code": "static void /* <=== command_process_create_cell */ \ncommand_process_create_cell(cell_t *cell, or_connection_t *conn)\n{\n  or_circuit_t *circ;\n  or_options_t *options = get_options();\n  int id_is_high;\n\n  if (we_are_hibernating()) {\n    log_info(LD_OR,\n             \"Received create cell but we're shutting down. Sending back \"\n             \"destroy.\");\n    connection_or_send_destroy(cell->circ_id, conn,\n                               END_CIRC_REASON_HIBERNATING);\n    return;\n  }\n\n  if (!server_mode(options) ||\n      (!public_server_mode(options) && conn->is_outgoing)) {\n    log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n           \"Received create cell (type %d) from %s:%d, but we're connected \"\n           \"to it as a client. \"\n           \"Sending back a destroy.\",\n           (int)cell->command, conn->_base.address, conn->_base.port);\n    connection_or_send_destroy(cell->circ_id, conn,\n                               END_CIRC_REASON_TORPROTOCOL);\n    return;\n  }\n\n  /* If the high bit of the circuit ID is not as expected, close the\n   * circ. */\n  id_is_high = cell->circ_id & (1<<15);\n  if ((id_is_high && conn->circ_id_type == CIRC_ID_TYPE_HIGHER) ||\n      (!id_is_high && conn->circ_id_type == CIRC_ID_TYPE_LOWER)) {\n    log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n           \"Received create cell with unexpected circ_id %d. Closing.\",\n           cell->circ_id);\n    connection_or_send_destroy(cell->circ_id, conn,\n                               END_CIRC_REASON_TORPROTOCOL);\n    return;\n  }\n\n  if (circuit_id_in_use_on_orconn(cell->circ_id, conn)) {\n    routerinfo_t *router = router_get_by_digest(conn->identity_digest);\n    log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n           \"Received CREATE cell (circID %d) for known circ. \"\n           \"Dropping (age %d).\",\n           cell->circ_id, (int)(time(NULL) - conn->_base.timestamp_created));\n    if (router)\n      log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,\n             \"Details: nickname \\\"%s\\\", platform %s.\",\n             router->nickname, escaped(router->platform));\n    return;\n  }\n\n  circ = or_circuit_new(cell->circ_id, conn);\n  circ->_base.purpose = CIRCUIT_PURPOSE_OR;\n  circuit_set_state(TO_CIRCUIT(circ), CIRCUIT_STATE_ONIONSKIN_PENDING);\n  if (cell->command == CELL_CREATE) {\n    char *onionskin = tor_malloc(ONIONSKIN_CHALLENGE_LEN);\n    memcpy(onionskin, cell->payload, ONIONSKIN_CHALLENGE_LEN);\n\n    /* hand it off to the cpuworkers, and then return. */\n    if (assign_onionskin_to_cpuworker(NULL, circ, onionskin) < 0) {\n      log_warn(LD_GENERAL,\"Failed to hand off onionskin. Closing.\");\n      circuit_mark_for_close(TO_CIRCUIT(circ), END_CIRC_REASON_INTERNAL);\n      return;\n    }\n    log_debug(LD_OR,\"success: handed off onionskin.\");\n  } else {\n    /* This is a CREATE_FAST cell; we can handle it immediately without using\n     * a CPU worker. */\n    char keys[CPATH_KEY_MATERIAL_LEN];\n    char reply[DIGEST_LEN*2];\n\n    tor_assert(cell->command == CELL_CREATE_FAST);\n\n    /* Make sure we never try to use the OR connection on which we\n     * received this cell to satisfy an EXTEND request,  */\n    conn->is_connection_with_client = 1;\n\n    if (fast_server_handshake(cell->payload, (uint8_t*)reply,\n                              (uint8_t*)keys, sizeof(keys))<0) {\n      log_warn(LD_OR,\"Failed to generate key material. Closing.\");\n      circuit_mark_for_close(TO_CIRCUIT(circ), END_CIRC_REASON_INTERNAL);\n      return;\n    }\n    if (onionskin_answer(circ, CELL_CREATED_FAST, reply, keys)<0) {\n      log_warn(LD_OR,\"Failed to reply to CREATE_FAST cell. Closing.\");\n      circuit_mark_for_close(TO_CIRCUIT(circ), END_CIRC_REASON_INTERNAL);\n      return;\n    }\n  }\n}",
        "start_line": 218
      }
    ],
    "code_context": "Called Methods:\n- circuit_set_state: void /* <=== circuit_set_state */ \ncircuit_set_state(circuit_t *circ, uint8_t state)\n{\n  tor_assert(circ);\n  if (state == circ->state)\n    return;\n  if (!circuits_pending_or_conns)\n    circuits_pending_or_conns = smartlist_create();\n  if (circ->state == CIRCUIT_STATE_OR_WAIT) {\n    /* remove from waiting-circuit list. */\n    smartlist_remove(circuits_pending_or_conns, circ);\n  }\n  if (state == CIRCUIT_STATE_OR_WAIT) {\n    /* add to waiting-circuit list. */\n    smartlist_add(circuits_pending_or_conns, circ);\n  }\n  if (state == CIRCUIT_STATE_OPEN)\n    tor_assert(!circ->n_conn_onionskin);\n  circ->state = state;\n}\n- DH_KEY_LEN: #define DH_KEY_LEN DH_BYTES /* <=== src/or/or.h:1872:1872:DH_KEY_LEN:0 */ \n- server_mode: int /* <=== server_mode */ \nserver_mode(or_options_t *options)\n{\n  if (options->ClientOnly) return 0;\n  return (options->ORPort != 0 || options->ORListenAddress);\n}\n- circuit_rep_hist_note_result: void /* <=== circuit_rep_hist_note_result */ \ncircuit_rep_hist_note_result(origin_circuit_t *circ)\n{\n  crypt_path_t *hop;\n  char *prev_digest = NULL;\n  routerinfo_t *router;\n  hop = circ->cpath;\n  if (!hop) /* circuit hasn't started building yet. */\n    return;\n  if (server_mode(get_options())) {\n    routerinfo_t *me = router_get_my_routerinfo();\n    if (!me)\n      return;\n    prev_digest = me->cache_info.identity_digest;\n  }\n  do {\n    router = router_get_by_digest(hop->extend_info->identity_digest);\n    if (router) {\n      if (prev_digest) {\n        if (hop->state == CPATH_STATE_OPEN)\n          rep_hist_note_extend_succeeded(prev_digest,\n                                         router->cache_info.identity_digest);\n        else {\n          rep_hist_note_extend_failed(prev_digest,\n                                      router->cache_info.identity_digest);\n          break;\n        }\n      }\n      prev_digest = router->cache_info.identity_digest;\n    } else {\n      prev_digest = NULL;\n    }\n    hop=hop->next;\n  } while (hop!=circ->cpath);\n}\n- circuit_mark_for_close: #define circuit_mark_for_close(c, reason)                               \\ /* <=== src/or/or.h:2827:2828:circuit_mark_for_close:2 */ \n  _circuit_mark_for_close((c), (reason), __LINE__, _SHORT_FILE_)\n- router_orport_found_reachable: void router_orport_found_reachable(void); /* <=== router_orport_found_reachable */ \n- CIRCUIT_PURPOSE_C_INTRODUCE_ACK_WAIT: #define CIRCUIT_PURPOSE_C_INTRODUCE_ACK_WAIT 7 /* <=== src/or/or.h:450:450:CIRCUIT_PURPOSE_C_INTRODUCE_ACK_WAIT:0 */ \n- _log_info: void _log_info(log_domain_mask_t domain, const char *format, ...); /* <=== _log_info */ \n- fast_server_handshake: int /* <=== fast_server_handshake */ \nfast_server_handshake(const uint8_t *key_in, /* DIGEST_LEN bytes */\n                      uint8_t *handshake_reply_out, /* DIGEST_LEN*2 bytes */\n                      uint8_t *key_out,\n                      size_t key_out_len)\n{\n  char tmp[DIGEST_LEN+DIGEST_LEN];\n  char *out = NULL;\n  size_t out_len;\n  int r = -1;\n\n  if (crypto_rand((char*)handshake_reply_out, DIGEST_LEN)<0)\n    return -1;\n\n  memcpy(tmp, key_in, DIGEST_LEN);\n  memcpy(tmp+DIGEST_LEN, handshake_reply_out, DIGEST_LEN);\n  out_len = key_out_len+DIGEST_LEN;\n  out = tor_malloc(out_len);\n  if (crypto_expand_key_material(tmp, sizeof(tmp), out, out_len)) {\n    goto done;\n  }\n  memcpy(handshake_reply_out+DIGEST_LEN, out, DIGEST_LEN);\n  memcpy(key_out, out+DIGEST_LEN, key_out_len);\n  r = 0;\n done:\n  memset(tmp, 0, sizeof(tmp));\n  memset(out, 0, out_len);\n  tor_free(out);\n  return r;\n}\n- LOG_WARN: #define LOG_WARN    4 /* <=== src/common/log.h:46:46:LOG_WARN:0 */ \n- LD_MM: #define LD_MM       (1u<<6) /* <=== src/common/log.h:67:67:LD_MM:0 */ \n- TO_OR_CIRCUIT: static INLINE or_circuit_t *TO_OR_CIRCUIT(circuit_t *x) /* <=== TO_OR_CIRCUIT */ \n{\n  tor_assert(x->magic == OR_CIRCUIT_MAGIC);\n  return DOWNCAST(or_circuit_t, x);\n}\n- CONN_TYPE_CPUWORKER: #define CONN_TYPE_CPUWORKER 10 /* <=== src/or/or.h:209:209:CONN_TYPE_CPUWORKER:0 */ \n- smartlist_create: smartlist_t *smartlist_create(void); /* <=== smartlist_create */ \n- _log_debug: void _log_debug(log_domain_mask_t domain, const char *format, ...); /* <=== _log_debug */ \n- esc_for_log: char * /* <=== esc_for_log */ \nesc_for_log(const char *s)\n{\n  const char *cp;\n  char *result, *outp;\n  size_t len = 3;\n  if (!s) {\n    return tor_strdup(\"\");\n  }\n\n  for (cp = s; *cp; ++cp) {\n    switch (*cp) {\n      case '\\\\':\n      case '\\\"':\n      case '\\'':\n        len += 2;\n        break;\n      default:\n        if (TOR_ISPRINT(*cp) && ((uint8_t)*cp)<127)\n          ++len;\n        else\n          len += 4;\n        break;\n    }\n  }\n\n  result = outp = tor_malloc(len);\n  *outp++ = '\\\"';\n  for (cp = s; *cp; ++cp) {\n    switch (*cp) {\n      case '\\\\':\n      case '\\\"':\n      case '\\'':\n        *outp++ = '\\\\';\n        *outp++ = *cp;\n        break;\n      case '\\n':\n        *outp++ = '\\\\';\n        *outp++ = 'n';\n        break;\n      case '\\t':\n        *outp++ = '\\\\';\n        *outp++ = 't';\n        break;\n      case '\\r':\n        *outp++ = '\\\\';\n        *outp++ = 'r';\n        break;\n      default:\n        if (TOR_ISPRINT(*cp) && ((uint8_t)*cp)<127) {\n          *outp++ = *cp;\n        } else {\n          tor_snprintf(outp, 5, \"\\\\%03o\", (int)(uint8_t) *cp);\n          outp += 4;\n        }\n        break;\n    }\n  }\n\n  *outp++ = '\\\"';\n  *outp++ = 0;\n\n  return result;\n}\n- smartlist_remove: void smartlist_remove(smartlist_t *sl, const void *element); /* <=== smartlist_remove */ \n- tor_malloc_zero: #define tor_malloc_zero(size)  _tor_malloc_zero(size DMALLOC_ARGS) /* <=== src/common/util.h:109:109:tor_malloc_zero:1 */ \n- _circuit_mark_for_close: void /* <=== _circuit_mark_for_close */ \n_circuit_mark_for_close(circuit_t *circ, int reason, int line,\n                        const char *file)\n{\n  int orig_reason = reason; /* Passed to the controller */\n  assert_circuit_ok(circ);\n  tor_assert(line);\n  tor_assert(file);\n\n  if (circ->marked_for_close) {\n    log(LOG_WARN,LD_BUG,\n        \"Duplicate call to circuit_mark_for_close at %s:%d\"\n        \" (first at %s:%d)\", file, line,\n        circ->marked_for_close_file, circ->marked_for_close);\n    return;\n  }\n  if (reason == END_CIRC_AT_ORIGIN) {\n    if (!CIRCUIT_IS_ORIGIN(circ)) {\n      log_warn(LD_BUG, \"Specified 'at-origin' non-reason for ending circuit, \"\n               \"but circuit was not at origin. (called %s:%d, purpose=%d)\",\n               file, line, circ->purpose);\n    }\n    reason = END_CIRC_REASON_NONE;\n  }\n  if (CIRCUIT_IS_ORIGIN(circ)) {\n    /* We don't send reasons when closing circuits at the origin. */\n    reason = END_CIRC_REASON_NONE;\n  }\n\n  if (reason & END_CIRC_REASON_FLAG_REMOTE)\n    reason &= ~END_CIRC_REASON_FLAG_REMOTE;\n\n  if (reason < _END_CIRC_REASON_MIN || reason > _END_CIRC_REASON_MAX) {\n    if (!(orig_reason & END_CIRC_REASON_FLAG_REMOTE))\n      log_warn(LD_BUG, \"Reason %d out of range at %s:%d\", reason, file, line);\n    reason = END_CIRC_REASON_NONE;\n  }\n\n  if (circ->state == CIRCUIT_STATE_ONIONSKIN_PENDING) {\n    onion_pending_remove(TO_OR_CIRCUIT(circ));\n  }\n  /* If the circuit ever became OPEN, we sent it to the reputation history\n   * module then.  If it isn't OPEN, we send it there now to remember which\n   * links worked and which didn't.\n   */\n  if (circ->state != CIRCUIT_STATE_OPEN) {\n    if (CIRCUIT_IS_ORIGIN(circ)) {\n      origin_circuit_t *ocirc = TO_ORIGIN_CIRCUIT(circ);\n      circuit_build_failed(ocirc); /* take actions if necessary */\n      circuit_rep_hist_note_result(ocirc);\n    }\n  }\n  if (circ->state == CIRCUIT_STATE_OR_WAIT) {\n    if (circuits_pending_or_conns)\n      smartlist_remove(circuits_pending_or_conns, circ);\n  }\n  if (CIRCUIT_IS_ORIGIN(circ)) {\n    control_event_circuit_status(TO_ORIGIN_CIRCUIT(circ),\n     (circ->state == CIRCUIT_STATE_OPEN)?CIRC_EVENT_CLOSED:CIRC_EVENT_FAILED,\n     orig_reason);\n  }\n  if (circ->purpose == CIRCUIT_PURPOSE_C_INTRODUCE_ACK_WAIT) {\n    origin_circuit_t *ocirc = TO_ORIGIN_CIRCUIT(circ);\n    tor_assert(circ->state == CIRCUIT_STATE_OPEN);\n    tor_assert(ocirc->build_state->chosen_exit);\n    tor_assert(ocirc->rend_data);\n    /* treat this like getting a nack from it */\n    log_info(LD_REND, \"Failed intro circ %s to %s (awaiting ack). \"\n             \"Removing from descriptor.\",\n             safe_str(ocirc->rend_data->onion_address),\n             safe_str(build_state_get_exit_nickname(ocirc->build_state)));\n    rend_client_remove_intro_point(ocirc->build_state->chosen_exit,\n                                   ocirc->rend_data);\n  }\n  if (circ->n_conn)\n    connection_or_send_destroy(circ->n_circ_id, circ->n_conn, reason);\n\n  if (! CIRCUIT_IS_ORIGIN(circ)) {\n    or_circuit_t *or_circ = TO_OR_CIRCUIT(circ);\n    edge_connection_t *conn;\n    for (conn=or_circ->n_streams; conn; conn=conn->next_stream)\n      connection_edge_destroy(or_circ->p_circ_id, conn);\n    or_circ->n_streams = NULL;\n\n    while (or_circ->resolving_streams) {\n      conn = or_circ->resolving_streams;\n      or_circ->resolving_streams = conn->next_stream;\n      if (!conn->_base.marked_for_close) {\n        /* The client will see a DESTROY, and infer that the connections\n         * are closing because the circuit is getting torn down.  No need\n         * to send an end cell. */\n        conn->edge_has_sent_end = 1;\n        conn->end_reason = END_STREAM_REASON_DESTROY;\n        conn->end_reason |= END_STREAM_REASON_FLAG_ALREADY_SENT_CLOSED;\n        connection_mark_for_close(TO_CONN(conn));\n      }\n      conn->on_circuit = NULL;\n    }\n\n    if (or_circ->p_conn)\n      connection_or_send_destroy(or_circ->p_circ_id, or_circ->p_conn, reason);\n  } else {\n    origin_circuit_t *ocirc = TO_ORIGIN_CIRCUIT(circ);\n    edge_connection_t *conn;\n    for (conn=ocirc->p_streams; conn; conn=conn->next_stream)\n      connection_edge_destroy(circ->n_circ_id, conn);\n    ocirc->p_streams = NULL;\n  }\n\n  circ->marked_for_close = line;\n  circ->marked_for_close_file = file;\n\n  if (!CIRCUIT_IS_ORIGIN(circ)) {\n    or_circuit_t *or_circ = TO_OR_CIRCUIT(circ);\n    if (or_circ->rend_splice) {\n      if (!or_circ->rend_splice->_base.marked_for_close) {\n        /* do this after marking this circuit, to avoid infinite recursion. */\n        circuit_mark_for_close(TO_CIRCUIT(or_circ->rend_splice), reason);\n      }\n      or_circ->rend_splice = NULL;\n    }\n  }\n}\n- connection_edge_destroy: int connection_edge_destroy(circid_t circ_id, edge_connection_t *conn); /* <=== connection_edge_destroy */ \n- tor_free: #define tor_free(p) STMT_BEGIN                                 \\ /* <=== src/common/util.h:100:105:tor_free:1 */ \n    if (PREDICT_LIKELY((p)!=NULL)) {                           \\\n      free(p);                                                 \\\n      (p)=NULL;                                                \\\n    }                                                          \\\n  STMT_END\n- END_STREAM_REASON_DESTROY: #define END_STREAM_REASON_DESTROY 5 /* <=== src/or/or.h:546:546:END_STREAM_REASON_DESTROY:0 */ \n- END_CIRC_REASON_FLAG_REMOTE: #define END_CIRC_REASON_FLAG_REMOTE     512 /* <=== src/or/or.h:635:635:END_CIRC_REASON_FLAG_REMOTE:0 */ \n- circuit_init_cpath_crypto: int /* <=== circuit_init_cpath_crypto */ \ncircuit_init_cpath_crypto(crypt_path_t *cpath, const char *key_data,\n                          int reverse)\n{\n  crypto_digest_env_t *tmp_digest;\n  crypto_cipher_env_t *tmp_crypto;\n\n  tor_assert(cpath);\n  tor_assert(key_data);\n  tor_assert(!(cpath->f_crypto || cpath->b_crypto ||\n             cpath->f_digest || cpath->b_digest));\n\n  cpath->f_digest = crypto_new_digest_env();\n  crypto_digest_add_bytes(cpath->f_digest, key_data, DIGEST_LEN);\n  cpath->b_digest = crypto_new_digest_env();\n  crypto_digest_add_bytes(cpath->b_digest, key_data+DIGEST_LEN, DIGEST_LEN);\n\n  if (!(cpath->f_crypto =\n        crypto_create_init_cipher(key_data+(2*DIGEST_LEN),1))) {\n    log_warn(LD_BUG,\"Forward cipher initialization failed.\");\n    return -1;\n  }\n  if (!(cpath->b_crypto =\n        crypto_create_init_cipher(key_data+(2*DIGEST_LEN)+CIPHER_KEY_LEN,0))) {\n    log_warn(LD_BUG,\"Backward cipher initialization failed.\");\n    return -1;\n  }\n\n  if (reverse) {\n    tmp_digest = cpath->f_digest;\n    cpath->f_digest = cpath->b_digest;\n    cpath->b_digest = tmp_digest;\n    tmp_crypto = cpath->f_crypto;\n    cpath->f_crypto = cpath->b_crypto;\n    cpath->b_crypto = tmp_crypto;\n  }\n\n  return 0;\n}\n- connection_or_nonopen_was_started_here: int /* <=== connection_or_nonopen_was_started_here */ \nconnection_or_nonopen_was_started_here(or_connection_t *conn)\n{\n  tor_assert(conn->_base.type == CONN_TYPE_OR);\n  if (!conn->tls)\n    return 1; /* it's still in proxy states or something */\n  if (conn->handshake_state)\n    return conn->handshake_state->started_here;\n  return !tor_tls_is_server(conn->tls);\n}\n- LD_BUG: #define LD_BUG      (1u<<12) /* <=== src/common/log.h:79:79:LD_BUG:0 */ \n- END_CIRC_REASON_TORPROTOCOL: #define END_CIRC_REASON_TORPROTOCOL     1 /* <=== src/or/or.h:618:618:END_CIRC_REASON_TORPROTOCOL:0 */ \n- CPUWORKER_STATE_BUSY_ONION: #define CPUWORKER_STATE_BUSY_ONION 2 /* <=== src/or/or.h:238:238:CPUWORKER_STATE_BUSY_ONION:0 */ \n- _END_CIRC_REASON_MIN: #define _END_CIRC_REASON_MIN            0 /* <=== src/or/or.h:616:616:_END_CIRC_REASON_MIN:0 */ \n- tor_malloc: #define tor_malloc(size)       _tor_malloc(size DMALLOC_ARGS) /* <=== src/common/util.h:108:108:tor_malloc:1 */ \n- TO_ORIGIN_CIRCUIT: static INLINE origin_circuit_t *TO_ORIGIN_CIRCUIT(circuit_t *x) /* <=== TO_ORIGIN_CIRCUIT */ \n{\n  tor_assert(x->magic == ORIGIN_CIRCUIT_MAGIC);\n  return DOWNCAST(origin_circuit_t, x);\n}\n- CPATH_KEY_MATERIAL_LEN: #define CPATH_KEY_MATERIAL_LEN (20*2+16*2) /* <=== src/or/or.h:1870:1870:CPATH_KEY_MATERIAL_LEN:0 */ \n- onionskin_answer: int /* <=== onionskin_answer */ \nonionskin_answer(or_circuit_t *circ, uint8_t cell_type, const char *payload,\n                 const char *keys)\n{\n  cell_t cell;\n  crypt_path_t *tmp_cpath;\n\n  tmp_cpath = tor_malloc_zero(sizeof(crypt_path_t));\n  tmp_cpath->magic = CRYPT_PATH_MAGIC;\n\n  memset(&cell, 0, sizeof(cell_t));\n  cell.command = cell_type;\n  cell.circ_id = circ->p_circ_id;\n\n  circuit_set_state(TO_CIRCUIT(circ), CIRCUIT_STATE_OPEN);\n\n  memcpy(cell.payload, payload,\n         cell_type == CELL_CREATED ? ONIONSKIN_REPLY_LEN : DIGEST_LEN*2);\n\n  log_debug(LD_CIRC,\"init digest forward 0x%.8x, backward 0x%.8x.\",\n            (unsigned int)*(uint32_t*)(keys),\n            (unsigned int)*(uint32_t*)(keys+20));\n  if (circuit_init_cpath_crypto(tmp_cpath, keys, 0)<0) {\n    log_warn(LD_BUG,\"Circuit initialization failed\");\n    tor_free(tmp_cpath);\n    return -1;\n  }\n  circ->n_digest = tmp_cpath->f_digest;\n  circ->n_crypto = tmp_cpath->f_crypto;\n  circ->p_digest = tmp_cpath->b_digest;\n  circ->p_crypto = tmp_cpath->b_crypto;\n  tmp_cpath->magic = 0;\n  tor_free(tmp_cpath);\n\n  if (cell_type == CELL_CREATED)\n    memcpy(circ->handshake_digest, cell.payload+DH_KEY_LEN, DIGEST_LEN);\n  else\n    memcpy(circ->handshake_digest, cell.payload+DIGEST_LEN, DIGEST_LEN);\n\n  circ->is_first_hop = (cell_type == CELL_CREATED_FAST);\n\n  append_cell_to_circuit_queue(TO_CIRCUIT(circ),\n                               circ->p_conn, &cell, CELL_DIRECTION_IN);\n  log_debug(LD_CIRC,\"Finished sending 'created' cell.\");\n\n  if (!is_local_addr(&circ->p_conn->_base.addr) &&\n      !connection_or_nonopen_was_started_here(circ->p_conn)) {\n    /* record that we could process create cells from a non-local conn\n     * that we didn't initiate; presumably this means that create cells\n     * can reach us too. */\n    router_orport_found_reachable();\n  }\n\n  return 0;\n}\n- connection_get_by_type_state: connection_t *connection_get_by_type_state(int type, int state); /* <=== connection_get_by_type_state */ \n- _tor_malloc_zero: void * /* <=== _tor_malloc_zero */ \n_tor_malloc_zero(size_t size DMALLOC_PARAMS)\n{\n  /* You may ask yourself, \"wouldn't it be smart to use calloc instead of\n   * malloc+memset?  Perhaps libc's calloc knows some nifty optimization trick\n   * we don't!\"  Indeed it does, but its optimizations are only a big win when\n   * we're allocating something very big (it knows if it just got the memory\n   * from the OS in a pre-zeroed state).  We don't want to use tor_malloc_zero\n   * for big stuff, so we don't bother with calloc. */\n  void *result = _tor_malloc(size DMALLOC_FN_ARGS);\n  memset(result, 0, size);\n  return result;\n}\n- crypto_expand_key_material: int crypto_expand_key_material(const char *key_in, size_t in_len, /* <=== crypto_expand_key_material */ \n                               char *key_out, size_t key_out_len);\n- CELL_CREATED_FAST: #define CELL_CREATED_FAST 6 /* <=== src/or/or.h:781:781:CELL_CREATED_FAST:0 */ \n- tor_assert: #define tor_assert(expr) STMT_BEGIN                                     \\ /* <=== src/common/util.h:45:52:tor_assert:1 */ \n    if (PREDICT_UNLIKELY(!(expr))) {                                    \\\n      log(LOG_ERR, LD_BUG, \"%s:%d: %s: Assertion %s failed; aborting.\", \\\n          _SHORT_FILE_, __LINE__, __func__, #expr);                     \\\n      fprintf(stderr,\"%s:%d %s: Assertion %s failed; aborting.\\n\",      \\\n              _SHORT_FILE_, __LINE__, __func__, #expr);                 \\\n      abort();                                                          \\\n    } STMT_END\n- public_server_mode: int /* <=== public_server_mode */ \npublic_server_mode(or_options_t *options)\n{\n  if (!server_mode(options)) return 0;\n  return (!options->BridgeRelay);\n}\n- append_cell_to_circuit_queue: void append_cell_to_circuit_queue(circuit_t *circ, or_connection_t *orconn, /* <=== append_cell_to_circuit_queue */ \n                                  cell_t *cell, cell_direction_t direction);\n- LD_CIRC: #define LD_CIRC     (1u<<10) /* <=== src/common/log.h:75:75:LD_CIRC:0 */ \n- CIRCUIT_PURPOSE_OR: #define CIRCUIT_PURPOSE_OR 1 /* <=== src/or/or.h:414:414:CIRCUIT_PURPOSE_OR:0 */ \n- _log_err: void _log_err(log_domain_mask_t domain, const char *format, ...); /* <=== _log_err */ \n- init_circuit_base: static void /* <=== init_circuit_base */ \ninit_circuit_base(circuit_t *circ)\n{\n  circ->timestamp_created = time(NULL);\n\n  circ->package_window = circuit_initial_package_window();\n  circ->deliver_window = CIRCWINDOW_START;\n\n  circuit_add(circ);\n}\n- router_orport_found_reachable: void /* <=== router_orport_found_reachable */ \nrouter_orport_found_reachable(void)\n{\n  routerinfo_t *me = router_get_my_routerinfo();\n  if (!can_reach_or_port && me) {\n    log_notice(LD_OR,\"Self-testing indicates your ORPort is reachable from \"\n               \"the outside. Excellent.%s\",\n               get_options()->_PublishServerDescriptor != NO_AUTHORITY ?\n                 \" Publishing server descriptor.\" : \"\");\n    can_reach_or_port = 1;\n    mark_my_descriptor_dirty();\n    control_event_server_status(LOG_NOTICE,\n                                \"REACHABILITY_SUCCEEDED ORADDRESS=%s:%d\",\n                                me->address, me->or_port);\n  }\n}\n- crypto_rand: int crypto_rand(char *to, size_t n); /* <=== crypto_rand */ \n- assert_circuit_ok: void /* <=== assert_circuit_ok */ \nassert_circuit_ok(const circuit_t *c)\n{\n  edge_connection_t *conn;\n  const or_circuit_t *or_circ = NULL;\n  const origin_circuit_t *origin_circ = NULL;\n\n  tor_assert(c);\n  tor_assert(c->magic == ORIGIN_CIRCUIT_MAGIC || c->magic == OR_CIRCUIT_MAGIC);\n  tor_assert(c->purpose >= _CIRCUIT_PURPOSE_MIN &&\n             c->purpose <= _CIRCUIT_PURPOSE_MAX);\n\n  {\n    /* Having a separate variable for this pleases GCC 4.2 in ways I hope I\n     * never understand. -NM. */\n    circuit_t *nonconst_circ = (circuit_t*) c;\n    if (CIRCUIT_IS_ORIGIN(c))\n      origin_circ = TO_ORIGIN_CIRCUIT(nonconst_circ);\n    else\n      or_circ = TO_OR_CIRCUIT(nonconst_circ);\n  }\n\n  if (c->n_conn) {\n    tor_assert(!c->n_hop);\n\n    if (c->n_circ_id) {\n      /* We use the _impl variant here to make sure we don't fail on marked\n       * circuits, which would not be returned by the regular function. */\n      circuit_t *c2 = circuit_get_by_circid_orconn_impl(c->n_circ_id,\n                                                        c->n_conn);\n      tor_assert(c == c2);\n    }\n  }\n  if (or_circ && or_circ->p_conn) {\n    if (or_circ->p_circ_id) {\n      /* ibid */\n      circuit_t *c2 = circuit_get_by_circid_orconn_impl(or_circ->p_circ_id,\n                                                        or_circ->p_conn);\n      tor_assert(c == c2);\n    }\n  }\n#if 0 /* false now that rendezvous exits are attached to p_streams */\n  if (origin_circ)\n    for (conn = origin_circ->p_streams; conn; conn = conn->next_stream)\n      tor_assert(conn->_base.type == CONN_TYPE_AP);\n#endif\n  if (or_circ)\n    for (conn = or_circ->n_streams; conn; conn = conn->next_stream)\n      tor_assert(conn->_base.type == CONN_TYPE_EXIT);\n\n  tor_assert(c->deliver_window >= 0);\n  tor_assert(c->package_window >= 0);\n  if (c->state == CIRCUIT_STATE_OPEN) {\n    tor_assert(!c->n_conn_onionskin);\n    if (or_circ) {\n      tor_assert(or_circ->n_crypto);\n      tor_assert(or_circ->p_crypto);\n      tor_assert(or_circ->n_digest);\n      tor_assert(or_circ->p_digest);\n    }\n  }\n  if (c->state == CIRCUIT_STATE_OR_WAIT && !c->marked_for_close) {\n    tor_assert(circuits_pending_or_conns &&\n               smartlist_isin(circuits_pending_or_conns, c));\n  } else {\n    tor_assert(!circuits_pending_or_conns ||\n               !smartlist_isin(circuits_pending_or_conns, c));\n  }\n  if (origin_circ && origin_circ->cpath) {\n    assert_cpath_ok(origin_circ->cpath);\n  }\n  if (c->purpose == CIRCUIT_PURPOSE_REND_ESTABLISHED) {\n    tor_assert(or_circ);\n    if (!c->marked_for_close) {\n      tor_assert(or_circ->rend_splice);\n      tor_assert(or_circ->rend_splice->rend_splice == or_circ);\n    }\n    tor_assert(or_circ->rend_splice != or_circ);\n  } else {\n    tor_assert(!or_circ || !or_circ->rend_splice);\n  }\n}\n- circuit_set_p_circid_orconn: void /* <=== circuit_set_p_circid_orconn */ \ncircuit_set_p_circid_orconn(or_circuit_t *circ, circid_t id,\n                            or_connection_t *conn)\n{\n  circuit_set_circid_orconn_helper(TO_CIRCUIT(circ), CELL_DIRECTION_IN,\n                                   id, conn);\n\n  if (conn)\n    tor_assert(bool_eq(circ->p_conn_cells.n, circ->next_active_on_p_conn));\n}\n- CPUWORKER_TASK_ONION: #define CPUWORKER_TASK_ONION CPUWORKER_STATE_BUSY_ONION /* <=== src/or/or.h:241:241:CPUWORKER_TASK_ONION:0 */ \n- LD_PROTOCOL: #define LD_PROTOCOL (1u<<5) /* <=== src/common/log.h:65:65:LD_PROTOCOL:0 */ \n- LD_OR: #define LD_OR       (1u<<15) /* <=== src/common/log.h:85:85:LD_OR:0 */ \n- LOG_PROTOCOL_WARN: #define LOG_PROTOCOL_WARN (get_options()->ProtocolWarnings ? \\ /* <=== src/or/or.h:2444:2445:LOG_PROTOCOL_WARN:0 */ \n                           LOG_WARN : LOG_INFO)\n- control_event_circuit_status: int control_event_circuit_status(origin_circuit_t *circ, /* <=== control_event_circuit_status */ \n                                 circuit_status_event_t e, int reason);\n- onion_pending_remove: void /* <=== onion_pending_remove */ \nonion_pending_remove(or_circuit_t *circ)\n{\n  onion_queue_t *tmpo, *victim;\n\n  if (!ol_list)\n    return; /* nothing here. */\n\n  /* first check to see if it's the first entry */\n  tmpo = ol_list;\n  if (tmpo->circ == circ) {\n    /* it's the first one. remove it from the list. */\n    ol_list = tmpo->next;\n    if (!ol_list)\n      ol_tail = NULL;\n    ol_length--;\n    victim = tmpo;\n  } else { /* we need to hunt through the rest of the list */\n    for ( ;tmpo->next && tmpo->next->circ != circ; tmpo=tmpo->next) ;\n    if (!tmpo->next) {\n      log_debug(LD_GENERAL,\n                \"circ (p_circ_id %d) not in list, probably at cpuworker.\",\n                circ->p_circ_id);\n      return;\n    }\n    /* now we know tmpo->next->circ == circ */\n    victim = tmpo->next;\n    tmpo->next = victim->next;\n    if (ol_tail == victim)\n      ol_tail = tmpo;\n    ol_length--;\n  }\n\n  /* now victim points to the element that needs to be removed */\n\n  tor_free(victim->onionskin);\n  tor_free(victim);\n}\n- circuit_get_by_circid_orconn_impl: static INLINE circuit_t * /* <=== circuit_get_by_circid_orconn_impl */ \ncircuit_get_by_circid_orconn_impl(circid_t circ_id, or_connection_t *conn)\n{\n  orconn_circid_circuit_map_t search;\n  orconn_circid_circuit_map_t *found;\n\n  if (_last_circid_orconn_ent &&\n      circ_id == _last_circid_orconn_ent->circ_id &&\n      conn == _last_circid_orconn_ent->or_conn) {\n    found = _last_circid_orconn_ent;\n  } else {\n    search.circ_id = circ_id;\n    search.or_conn = conn;\n    found = HT_FIND(orconn_circid_map, &orconn_circid_circuit_map, &search);\n    _last_circid_orconn_ent = found;\n  }\n  if (found && found->circuit)\n    return found->circuit;\n\n  return NULL;\n\n  /* The rest of this checks for bugs. Disabled by default. */\n  {\n    circuit_t *circ;\n    for (circ=global_circuitlist;circ;circ = circ->next) {\n      if (! CIRCUIT_IS_ORIGIN(circ)) {\n        or_circuit_t *or_circ = TO_OR_CIRCUIT(circ);\n        if (or_circ->p_conn == conn && or_circ->p_circ_id == circ_id) {\n          log_warn(LD_BUG,\n                   \"circuit matches p_conn, but not in hash table (Bug!)\");\n          return circ;\n        }\n      }\n      if (circ->n_conn == conn && circ->n_circ_id == circ_id) {\n        log_warn(LD_BUG,\n                 \"circuit matches n_conn, but not in hash table (Bug!)\");\n        return circ;\n      }\n    }\n    return NULL;\n  }\n}\n- we_are_hibernating: int we_are_hibernating(void); /* <=== we_are_hibernating */ \n- CIRCUIT_STATE_OPEN: #define CIRCUIT_STATE_OPEN 3 /* <=== src/or/or.h:407:407:CIRCUIT_STATE_OPEN:0 */ \n- onion_pending_add: int /* <=== onion_pending_add */ \nonion_pending_add(or_circuit_t *circ, char *onionskin)\n{\n  onion_queue_t *tmp;\n  time_t now = time(NULL);\n\n  tmp = tor_malloc_zero(sizeof(onion_queue_t));\n  tmp->circ = circ;\n  tmp->onionskin = onionskin;\n  tmp->when_added = now;\n\n  if (!ol_tail) {\n    tor_assert(!ol_list);\n    tor_assert(!ol_length);\n    ol_list = tmp;\n    ol_tail = tmp;\n    ol_length++;\n    return 0;\n  }\n\n  tor_assert(ol_list);\n  tor_assert(!ol_tail->next);\n\n  if (ol_length >= get_options()->MaxOnionsPending) {\n    log_warn(LD_GENERAL,\n             \"Your computer is too slow to handle this many circuit \"\n             \"creation requests! Please consider using the \"\n             \"MaxAdvertisedBandwidth config option or choosing a more \"\n             \"restricted exit policy.\");\n    tor_free(tmp);\n    return -1;\n  }\n\n  ol_length++;\n  ol_tail->next = tmp;\n  ol_tail = tmp;\n  while ((int)(now - ol_list->when_added) >= ONIONQUEUE_WAIT_CUTOFF) {\n    /* cull elderly requests. */\n    circ = ol_list->circ;\n    onion_pending_remove(ol_list->circ);\n    log_info(LD_CIRC,\n             \"Circuit create request is too old; canceling due to overload.\");\n    circuit_mark_for_close(TO_CIRCUIT(circ), END_CIRC_REASON_RESOURCELIMIT);\n  }\n  return 0;\n}\n- build_state_get_exit_nickname: const char * /* <=== build_state_get_exit_nickname */ \nbuild_state_get_exit_nickname(cpath_build_state_t *state)\n{\n  if (!state || !state->chosen_exit)\n    return NULL;\n  return state->chosen_exit->nickname;\n}\n- CRYPT_PATH_MAGIC: #define CRYPT_PATH_MAGIC 0x70127012u /* <=== src/or/or.h:1814:1814:CRYPT_PATH_MAGIC:0 */ \n- TO_CIRCUIT: #define TO_CIRCUIT(x)  (&((x)->_base)) /* <=== src/or/or.h:2112:2112:TO_CIRCUIT:1 */ \n- _connection_mark_for_close: void _connection_mark_for_close(connection_t *conn,int line, const char *file); /* <=== _connection_mark_for_close */ \n- escaped: const char * /* <=== escaped */ \nescaped(const char *s)\n{\n  static char *_escaped_val = NULL;\n  if (_escaped_val)\n    tor_free(_escaped_val);\n\n  if (s)\n    _escaped_val = esc_for_log(s);\n  else\n    _escaped_val = NULL;\n\n  return _escaped_val;\n}\n- ONIONSKIN_CHALLENGE_LEN: #define ONIONSKIN_CHALLENGE_LEN (PKCS1_OAEP_PADDING_OVERHEAD+\\ /* <=== src/or/or.h:1873:1875:ONIONSKIN_CHALLENGE_LEN:0 */ \n                                 CIPHER_KEY_LEN+\\\n                                 DH_KEY_LEN)\n- END_CIRC_REASON_NONE: #define END_CIRC_REASON_NONE            0 /* <=== src/or/or.h:617:617:END_CIRC_REASON_NONE:0 */ \n- _log_warn: void _log_warn(log_domain_mask_t domain, const char *format, ...); /* <=== _log_warn */ \n- CELL_CREATED: #define CELL_CREATED 2 /* <=== src/or/or.h:777:777:CELL_CREATED:0 */ \n- connection_or_send_destroy: int /* <=== connection_or_send_destroy */ \nconnection_or_send_destroy(circid_t circ_id, or_connection_t *conn, int reason)\n{\n  cell_t cell;\n\n  tor_assert(conn);\n\n  memset(&cell, 0, sizeof(cell_t));\n  cell.circ_id = circ_id;\n  cell.command = CELL_DESTROY;\n  cell.payload[0] = (uint8_t) reason;\n  log_debug(LD_OR,\"Sending destroy (circID %d).\", circ_id);\n\n  /* XXXX It's possible that under some circumstances, we want the destroy\n   * to take precedence over other data waiting on the circuit's cell queue.\n   */\n\n  connection_or_write_cell_to_buf(&cell, conn);\n  return 0;\n}\n- ONIONSKIN_REPLY_LEN: #define ONIONSKIN_REPLY_LEN (DH_KEY_LEN+DIGEST_LEN) /* <=== src/or/or.h:1876:1876:ONIONSKIN_REPLY_LEN:0 */ \n- get_options: or_options_t * /* <=== get_options */ \nget_options(void)\n{\n  tor_assert(global_options);\n  return global_options;\n}\n- LD_GENERAL: #define LD_GENERAL  (1u<<0) /* <=== src/common/log.h:55:55:LD_GENERAL:0 */ \n- OR_CIRCUIT_MAGIC: #define OR_CIRCUIT_MAGIC 0x98ABC04Fu /* <=== src/or/or.h:1903:1903:OR_CIRCUIT_MAGIC:0 */ \n- server_mode: int server_mode(or_options_t *options); /* <=== server_mode */ \n- connection_write_to_buf: static INLINE void /* <=== connection_write_to_buf */ \nconnection_write_to_buf(const char *string, size_t len, connection_t *conn)\n{\n  _connection_write_to_buf_impl(string, len, conn, 0);\n}\n- LD_REND: #define LD_REND     (1u<<11) /* <=== src/common/log.h:77:77:LD_REND:0 */ \n- _log_fn: void _log_fn(int severity, log_domain_mask_t domain, const char *format, ...); /* <=== _log_fn */ \n- connection_or_write_cell_to_buf: void /* <=== connection_or_write_cell_to_buf */ \nconnection_or_write_cell_to_buf(const cell_t *cell, or_connection_t *conn)\n{\n  packed_cell_t networkcell;\n\n  tor_assert(cell);\n  tor_assert(conn);\n\n  cell_pack(&networkcell, cell);\n\n  connection_write_to_buf(networkcell.body, CELL_NETWORK_SIZE, TO_CONN(conn));\n\n  if (cell->command != CELL_PADDING)\n    conn->timestamp_last_added_nonpadding = approx_time();\n}\n- MAX_RELAY_EARLY_CELLS_PER_CIRCUIT: #define MAX_RELAY_EARLY_CELLS_PER_CIRCUIT 8 /* <=== src/or/or.h:1991:1991:MAX_RELAY_EARLY_CELLS_PER_CIRCUIT:0 */ \n- tor_fix_source_file: const char *tor_fix_source_file(const char *fname); /* <=== tor_fix_source_file */ \n- is_local_addr: int /* <=== is_local_addr */ \nis_local_addr(const tor_addr_t *addr)\n{\n  if (tor_addr_is_internal(addr, 0))\n    return 1;\n  /* Check whether ip is on the same /24 as we are. */\n  if (get_options()->EnforceDistinctSubnets == 0)\n    return 0;\n  if (tor_addr_family(addr) == AF_INET) {\n    /*XXXX022 IP6 what corresponds to an /24? */\n    uint32_t ip = tor_addr_to_ipv4h(addr);\n\n    /* It's possible that this next check will hit before the first time\n     * resolve_my_address actually succeeds.  (For clients, it is likely that\n     * resolve_my_address will never be called at all).  In those cases,\n     * last_resolved_addr will be 0, and so checking to see whether ip is on\n     * the same /24 as last_resolved_addr will be the same as checking whether\n     * it was on net 0, which is already done by is_internal_IP.\n     */\n    if ((last_resolved_addr & (uint32_t)0xffffff00ul)\n        == (ip & (uint32_t)0xffffff00ul))\n      return 1;\n  }\n  return 0;\n}\n- CIRCUIT_IS_ORIGIN: #define CIRCUIT_IS_ORIGIN(c) (CIRCUIT_PURPOSE_IS_ORIGIN((c)->purpose)) /* <=== src/or/or.h:492:492:CIRCUIT_IS_ORIGIN:1 */ \n- DIGEST_LEN: #define DIGEST_LEN 20 /* <=== src/common/crypto.h:20:20:DIGEST_LEN:0 */ \n- CPUWORKER_STATE_IDLE: #define CPUWORKER_STATE_IDLE 1 /* <=== src/or/or.h:235:235:CPUWORKER_STATE_IDLE:0 */ \n- rimap_get: DECLARE_TYPED_DIGESTMAP_FNS(rimap_, digest_ri_map_t, routerinfo_t) /* <=== rimap_get */ \n- spawn_enough_cpuworkers: static void /* <=== spawn_enough_cpuworkers */ \nspawn_enough_cpuworkers(void)\n{\n  int num_cpuworkers_needed = get_options()->NumCpus;\n\n  if (num_cpuworkers_needed < MIN_CPUWORKERS)\n    num_cpuworkers_needed = MIN_CPUWORKERS;\n  if (num_cpuworkers_needed > MAX_CPUWORKERS)\n    num_cpuworkers_needed = MAX_CPUWORKERS;\n\n  while (num_cpuworkers < num_cpuworkers_needed) {\n    if (spawn_cpuworker() < 0) {\n      log_warn(LD_GENERAL,\"Cpuworker spawn failed. Will try again later.\");\n      return;\n    }\n    num_cpuworkers++;\n  }\n}\n- _log: void _log(int severity, log_domain_mask_t domain, const char *format, ...) /* <=== _log */ \n- CIRCUIT_STATE_OR_WAIT: #define CIRCUIT_STATE_OR_WAIT 2 /* <=== src/or/or.h:405:405:CIRCUIT_STATE_OR_WAIT:0 */ \n- CELL_CREATE: #define CELL_CREATE 1 /* <=== src/or/or.h:776:776:CELL_CREATE:0 */ \n- PREDICT_UNLIKELY: #define PREDICT_UNLIKELY(exp) (exp) /* <=== src/common/compat.h:158:158:PREDICT_UNLIKELY:1 */ \n- rend_client_remove_intro_point: int rend_client_remove_intro_point(extend_info_t *failed_intro, /* <=== rend_client_remove_intro_point */ \n                                   const rend_data_t *rend_query);\n- smartlist_add: void smartlist_add(smartlist_t *sl, void *element); /* <=== smartlist_add */ \n- safe_str: const char * /* <=== safe_str */ \nsafe_str(const char *address)\n{\n  tor_assert(address);\n  if (get_options()->SafeLogging)\n    return \"[scrubbed]\";\n  else\n    return address;\n}\n- _tor_malloc: void * /* <=== _tor_malloc */ \n_tor_malloc(size_t size DMALLOC_PARAMS)\n{\n  void *result;\n\n  tor_assert(size < SIZE_T_CEILING);\n\n#ifndef MALLOC_ZERO_WORKS\n  /* Some libc mallocs don't work when size==0. Override them. */\n  if (size==0) {\n    size=1;\n  }\n#endif\n\n#ifdef USE_DMALLOC\n  result = dmalloc_malloc(file, line, size, DMALLOC_FUNC_MALLOC, 0, 0);\n#else\n  result = malloc(size);\n#endif\n\n  if (PREDICT_UNLIKELY(result == NULL)) {\n    log_err(LD_MM,\"Out of memory on malloc(). Dying.\");\n    /* If these functions die within a worker process, they won't call\n     * spawn_exit, but that's ok, since the parent will run out of memory soon\n     * anyway. */\n    exit(1);\n  }\n  return result;\n}\n- _END_CIRC_REASON_MAX: #define _END_CIRC_REASON_MAX            12 /* <=== src/or/or.h:630:630:_END_CIRC_REASON_MAX:0 */ \n- TAG_LEN: #define TAG_LEN 10 /* <=== src/or/cpuworker.c:23:23:TAG_LEN:0 */ \n- or_circuit_new: or_circuit_t * /* <=== or_circuit_new */ \nor_circuit_new(circid_t p_circ_id, or_connection_t *p_conn)\n{\n  /* CircIDs */\n  or_circuit_t *circ;\n\n  circ = tor_malloc_zero(sizeof(or_circuit_t));\n  circ->_base.magic = OR_CIRCUIT_MAGIC;\n\n  if (p_conn)\n    circuit_set_p_circid_orconn(circ, p_circ_id, p_conn);\n\n  circ->remaining_relay_early_cells = MAX_RELAY_EARLY_CELLS_PER_CIRCUIT;\n\n  init_circuit_base(TO_CIRCUIT(circ));\n\n  return circ;\n}\n- assign_onionskin_to_cpuworker: int /* <=== assign_onionskin_to_cpuworker */ \nassign_onionskin_to_cpuworker(connection_t *cpuworker,\n                              or_circuit_t *circ, char *onionskin)\n{\n  char qbuf[1];\n  char tag[TAG_LEN];\n\n  cull_wedged_cpuworkers();\n  spawn_enough_cpuworkers();\n\n  if (1) {\n    if (num_cpuworkers_busy == num_cpuworkers) {\n      log_debug(LD_OR,\"No idle cpuworkers. Queuing.\");\n      if (onion_pending_add(circ, onionskin) < 0) {\n        tor_free(onionskin);\n        return -1;\n      }\n      return 0;\n    }\n\n    if (!cpuworker)\n      cpuworker = connection_get_by_type_state(CONN_TYPE_CPUWORKER,\n                                               CPUWORKER_STATE_IDLE);\n\n    tor_assert(cpuworker);\n\n    if (!circ->p_conn) {\n      log_info(LD_OR,\"circ->p_conn gone. Failing circ.\");\n      tor_free(onionskin);\n      return -1;\n    }\n    tag_pack(tag, circ->p_conn->_base.global_identifier,\n             circ->p_circ_id);\n\n    cpuworker->state = CPUWORKER_STATE_BUSY_ONION;\n    /* touch the lastwritten timestamp, since that's how we check to\n     * see how long it's been since we asked the question, and sometimes\n     * we check before the first call to connection_handle_write(). */\n    cpuworker->timestamp_lastwritten = time(NULL);\n    num_cpuworkers_busy++;\n\n    qbuf[0] = CPUWORKER_TASK_ONION;\n    connection_write_to_buf(qbuf, 1, cpuworker);\n    connection_write_to_buf(tag, sizeof(tag), cpuworker);\n    connection_write_to_buf(onionskin, ONIONSKIN_CHALLENGE_LEN, cpuworker);\n    tor_free(onionskin);\n  }\n  return 0;\n}\n- router_get_by_digest: routerinfo_t * /* <=== router_get_by_digest */ \nrouter_get_by_digest(const char *digest)\n{\n  tor_assert(digest);\n\n  if (!routerlist) return NULL;\n\n  // routerlist_assert_ok(routerlist);\n\n  return rimap_get(routerlist->identity_map, digest);\n}\n- circuit_build_failed: void circuit_build_failed(origin_circuit_t *circ); /* <=== circuit_build_failed */ \n- END_CIRC_AT_ORIGIN: #define END_CIRC_AT_ORIGIN              -1 /* <=== src/or/or.h:612:612:END_CIRC_AT_ORIGIN:0 */ \n- CIRCUIT_STATE_ONIONSKIN_PENDING: #define CIRCUIT_STATE_ONIONSKIN_PENDING 1 /* <=== src/or/or.h:402:402:CIRCUIT_STATE_ONIONSKIN_PENDING:0 */ \n- cull_wedged_cpuworkers: static void /* <=== cull_wedged_cpuworkers */ \ncull_wedged_cpuworkers(void)\n{\n  time_t now = time(NULL);\n  smartlist_t *conns = get_connection_array();\n  SMARTLIST_FOREACH(conns, connection_t *, conn,\n  {\n    if (!conn->marked_for_close &&\n        conn->type == CONN_TYPE_CPUWORKER &&\n        conn->state == CPUWORKER_STATE_BUSY_ONION &&\n        conn->timestamp_lastwritten + CPUWORKER_BUSY_TIMEOUT < now) {\n      log_notice(LD_BUG,\n                 \"closing wedged cpuworker. Can somebody find the bug?\");\n      num_cpuworkers_busy--;\n      num_cpuworkers--;\n      connection_mark_for_close(conn);\n    }\n  });\n}\n- END_STREAM_REASON_FLAG_ALREADY_SENT_CLOSED: #define END_STREAM_REASON_FLAG_ALREADY_SENT_CLOSED 1024 /* <=== src/or/or.h:587:587:END_STREAM_REASON_FLAG_ALREADY_SENT_CLOSED:0 */ \n- tag_pack: static void /* <=== tag_pack */ \ntag_pack(char *tag, uint64_t conn_id, circid_t circ_id)\n{\n  /*XXXX RETHINK THIS WHOLE MESS !!!! !NM NM NM NM*/\n  set_uint64(tag, conn_id);\n  set_uint16(tag+8, circ_id);\n}\n- circuit_id_in_use_on_orconn: int /* <=== circuit_id_in_use_on_orconn */ \ncircuit_id_in_use_on_orconn(circid_t circ_id, or_connection_t *conn)\n{\n  return circuit_get_by_circid_orconn_impl(circ_id, conn) != NULL;\n}\n- CELL_DESTROY: #define CELL_DESTROY 4 /* <=== src/or/or.h:779:779:CELL_DESTROY:0 */ \n- connection_mark_for_close: #define connection_mark_for_close(c) \\ /* <=== src/or/or.h:2971:2972:connection_mark_for_close:1 */ \n  _connection_mark_for_close((c), __LINE__, _SHORT_FILE_)\n\nType Definitions:\n- cell_t: typedef struct cell_t {\n  circid_t circ_id; /**< Circuit which received the cell. */\n  uint8_t command; /**< Type of the cell: one of CELL_PADDING, CELL_CREATE,\n                    * CELL_DESTROY, etc */\n  uint8_t payload[CELL_PAYLOAD_SIZE]; /**< Cell body. */\n} cell_t;\n- or_connection_t: typedef struct or_connection_t {\n  connection_t _base;\n\n  /** Hash of the public RSA key for the other side's identity key, or zeroes\n   * if the other side hasn't shown us a valid identity key. */\n  char identity_digest[DIGEST_LEN];\n  char *nickname; /**< Nickname of OR on other side (if any). */\n\n  tor_tls_t *tls; /**< TLS connection state. */\n  int tls_error; /**< Last tor_tls error code. */\n  /** When we last used this conn for any client traffic. If not\n   * recent, we can rate limit it further. */\n  time_t client_used;\n\n  tor_addr_t real_addr; /**< The actual address that this connection came from\n                       * or went to.  The <b>addr</b> field is prone to\n                       * getting overridden by the address from the router\n                       * descriptor matching <b>identity_digest</b>. */\n\n  circ_id_type_t circ_id_type:2; /**< When we send CREATE cells along this\n                                  * connection, which half of the space should\n                                  * we use? */\n  /** Should this connection be used for extending circuits to the server\n   * matching the <b>identity_digest</b> field?  Set to true if we're pretty\n   * sure we aren't getting MITMed, either because we're connected to an\n   * address listed in a server descriptor, or because an authenticated\n   * NETINFO cell listed the address we're connected to as recognized. */\n  unsigned int is_canonical:1;\n  /** True iff this connection shouldn't get any new circs attached to it,\n   * because the connection is too old, or because there's a better one, etc.\n   */\n  unsigned int is_bad_for_new_circs:1;\n  /** True iff we have decided that the other end of this connection\n   * is a client.  Connections with this flag set should never be used\n   * to satisfy an EXTEND request.  */\n  unsigned int is_connection_with_client:1;\n  /** True iff this is an outgoing connection. */\n  unsigned int is_outgoing:1;\n  uint8_t link_proto; /**< What protocol version are we using? 0 for\n                       * \"none negotiated yet.\" */\n  circid_t next_circ_id; /**< Which circ_id do we try to use next on\n                          * this connection?  This is always in the\n                          * range 0..1<<15-1. */\n\n  or_handshake_state_t *handshake_state; /**< If we are setting this connection\n                                          * up, state information to do so. */\n  time_t timestamp_lastempty; /**< When was the outbuf last completely empty?*/\n  time_t timestamp_last_added_nonpadding; /** When did we last add a\n                                           * non-padding cell to the outbuf? */\n\n  /* bandwidth* and read_bucket only used by ORs in OPEN state: */\n  int bandwidthrate; /**< Bytes/s added to the bucket. (OPEN ORs only.) */\n  int bandwidthburst; /**< Max bucket size for this conn. (OPEN ORs only.) */\n  int read_bucket; /**< When this hits 0, stop receiving. Every second we\n                    * add 'bandwidthrate' to this, capping it at\n                    * bandwidthburst. (OPEN ORs only) */\n  int n_circuits; /**< How many circuits use this connection as p_conn or\n                   * n_conn ? */\n\n  /** Double-linked ring of circuits with queued cells waiting for room to\n   * free up on this connection's outbuf.  Every time we pull cells from a\n   * circuit, we advance this pointer to the next circuit in the ring. */\n  struct circuit_t *active_circuits;\n  struct or_connection_t *next_with_same_id; /**< Next connection with same\n                                              * identity digest as this one. */\n}\n- or_circuit_t: typedef struct or_circuit_t {\n  circuit_t _base;\n\n  /** Next circuit in the doubly-linked ring of circuits waiting to add\n   * cells to p_conn.  NULL if we have no cells pending, or if we're not\n   * linked to an OR connection. */\n  struct circuit_t *next_active_on_p_conn;\n  /** Previous circuit in the doubly-linked ring of circuits waiting to add\n   * cells to p_conn.  NULL if we have no cells pending, or if we're not\n   * linked to an OR connection. */\n  struct circuit_t *prev_active_on_p_conn;\n\n  /** The circuit_id used in the previous (backward) hop of this circuit. */\n  circid_t p_circ_id;\n  /** Queue of cells waiting to be transmitted on p_conn. */\n  cell_queue_t p_conn_cells;\n  /** The OR connection that is previous in this circuit. */\n  or_connection_t *p_conn;\n  /** Linked list of Exit streams associated with this circuit. */\n  edge_connection_t *n_streams;\n  /** Linked list of Exit streams associated with this circuit that are\n   * still being resolved. */\n  edge_connection_t *resolving_streams;\n  /** The cipher used by intermediate hops for cells heading toward the\n   * OP. */\n  crypto_cipher_env_t *p_crypto;\n  /** The cipher used by intermediate hops for cells heading away from\n   * the OP. */\n  crypto_cipher_env_t *n_crypto;\n\n  /** The integrity-checking digest used by intermediate hops, for\n   * cells packaged here and heading towards the OP.\n   */\n  crypto_digest_env_t *p_digest;\n  /** The integrity-checking digest used by intermediate hops, for\n   * cells packaged at the OP and arriving here.\n   */\n  crypto_digest_env_t *n_digest;\n\n  /** Points to spliced circuit if purpose is REND_ESTABLISHED, and circuit\n   * is not marked for close. */\n  struct or_circuit_t *rend_splice;\n\n#if REND_COOKIE_LEN >= DIGEST_LEN\n#define REND_TOKEN_LEN REND_COOKIE_LEN\n#else\n#define REND_TOKEN_LEN DIGEST_LEN\n#endif\n\n  /** A hash of location-hidden service's PK if purpose is INTRO_POINT, or a\n   * rendezvous cookie if purpose is REND_POINT_WAITING. Filled with zeroes\n   * otherwise.\n   * ???? move to a subtype or adjunct structure? Wastes 20 bytes. -NM\n   */\n  char rend_token[REND_TOKEN_LEN];\n\n  /* ???? move to a subtype or adjunct structure? Wastes 20 bytes -NM */\n  char handshake_digest[DIGEST_LEN]; /**< Stores KH for the handshake. */\n\n  /** How many more relay_early cells can we send on this circuit, according\n   * to the specification? */\n  unsigned int remaining_relay_early_cells : 4;\n\n  /** True iff this circuit was made with a CREATE_FAST cell. */\n  unsigned int is_first_hop : 1;\n}\n- routerinfo_t: typedef struct {\n  signed_descriptor_t cache_info;\n  char *address; /**< Location of OR: either a hostname or an IP address. */\n  char *nickname; /**< Human-readable OR name. */\n\n  uint32_t addr; /**< IPv4 address of OR, in host order. */\n  uint16_t or_port; /**< Port for TLS connections. */\n  uint16_t dir_port; /**< Port for HTTP directory connections. */\n\n  crypto_pk_env_t *onion_pkey; /**< Public RSA key for onions. */\n  crypto_pk_env_t *identity_pkey;  /**< Public RSA key for signing. */\n\n  char *platform; /**< What software/operating system is this OR using? */\n\n  /* link info */\n  uint32_t bandwidthrate; /**< How many bytes does this OR add to its token\n                           * bucket per second? */\n  uint32_t bandwidthburst; /**< How large is this OR's token bucket? */\n  /** How many bytes/s is this router known to handle? */\n  uint32_t bandwidthcapacity;\n  smartlist_t *exit_policy; /**< What streams will this OR permit\n                             * to exit?  NULL for 'reject *:*'. */\n  long uptime; /**< How many seconds the router claims to have been up */\n  smartlist_t *declared_family; /**< Nicknames of router which this router\n                                 * claims are its family. */\n  char *contact_info; /**< Declared contact info for this router. */\n  unsigned int is_hibernating:1; /**< Whether the router claims to be\n                                  * hibernating */\n  unsigned int has_old_dnsworkers:1; /**< Whether the router is using\n                                      * dnsworker code. */\n  unsigned int caches_extra_info:1; /**< Whether the router caches and serves\n                                     * extrainfo documents. */\n  unsigned int allow_single_hop_exits:1;  /**< Whether the router allows\n                                     * single hop exits. */\n\n  /* local info */\n  unsigned int is_running:1; /**< As far as we know, is this OR currently\n                              * running? */\n  unsigned int is_valid:1; /**< Has a trusted dirserver validated this OR?\n                               *  (For Authdir: Have we validated this OR?)\n                               */\n  unsigned int is_named:1; /**< Do we believe the nickname that this OR gives\n                            * us? */\n  unsigned int is_fast:1; /** Do we think this is a fast OR? */\n  unsigned int is_stable:1; /** Do we think this is a stable OR? */\n  unsigned int is_possible_guard:1; /**< Do we think this is an OK guard? */\n  unsigned int is_exit:1; /**< Do we think this is an OK exit? */\n  unsigned int is_bad_exit:1; /**< Do we think this exit is censored, borked,\n                               * or otherwise nasty? */\n  unsigned int is_bad_directory:1; /**< Do we think this directory is junky,\n                                    * underpowered, or otherwise useless? */\n  unsigned int wants_to_be_hs_dir:1; /**< True iff this router claims to be\n                                      * a hidden service directory. */\n  unsigned int is_hs_dir:1; /**< True iff this router is a hidden service\n                             * directory according to the authorities. */\n  unsigned int policy_is_reject_star:1; /**< True iff the exit policy for this\n                                         * router rejects everything. */\n\n/** Tor can use this router for general positions in circuits. */\n#define ROUTER_PURPOSE_GENERAL 0\n/** Tor should avoid using this router for circuit-building. */\n#define ROUTER_PURPOSE_CONTROLLER 1\n/** Tor should use this router only for bridge positions in circuits. */\n#define ROUTER_PURPOSE_BRIDGE 2\n/** Tor should not use this router; it was marked in cached-descriptors with\n * a purpose we didn't recognize. */\n#define ROUTER_PURPOSE_UNKNOWN 255\n\n  uint8_t purpose; /** What positions in a circuit is this router good for? */\n\n  /* The below items are used only by authdirservers for\n   * reachability testing. */\n  /** When was the last time we could reach this OR? */\n  time_t last_reachable;\n  /** When did we start testing reachability for this OR? */\n  time_t testing_since;\n  /** According to the geoip db what country is this router in? */\n  country_t country;\n}\n- or_options_t: typedef struct {\n  uint32_t _magic;\n\n  /** What should the tor process actually do? */\n  enum {\n    CMD_RUN_TOR=0, CMD_LIST_FINGERPRINT, CMD_HASH_PASSWORD,\n    CMD_VERIFY_CONFIG, CMD_RUN_UNITTESTS\n  } command;\n  const char *command_arg; /**< Argument for command-line option. */\n\n  config_line_t *Logs; /**< New-style list of configuration lines\n                        * for logs */\n\n  char *DebugLogFile; /**< Where to send verbose log messages. */\n  char *DataDirectory; /**< OR only: where to store long-term data. */\n  char *Nickname; /**< OR only: nickname of this onion router. */\n  char *Address; /**< OR only: configured address for this onion router. */\n  char *PidFile; /**< Where to store PID of Tor process. */\n\n  routerset_t *ExitNodes; /**< Structure containing nicknames, digests,\n                           * country codes and IP address patterns of ORs to\n                           * consider as exits. */\n  routerset_t *EntryNodes;/**< Structure containing nicknames, digests,\n                           * country codes and IP address patterns of ORs to\n                           * consider as entry points. */\n  int StrictExitNodes; /**< Boolean: When none of our ExitNodes are up, do we\n                        * stop building circuits? */\n  int StrictEntryNodes; /**< Boolean: When none of our EntryNodes are up, do we\n                         * stop building circuits? */\n  routerset_t *ExcludeNodes;/**< Structure containing nicknames, digests,\n                             * country codes and IP address patterns of ORs\n                             * not to use in circuits. */\n  routerset_t *ExcludeExitNodes;/**< Structure containing nicknames, digests,\n                                 * country codes and IP address patterns of\n                                 * ORs not to consider as exits. */\n\n  /** Union of ExcludeNodes and ExcludeExitNodes */\n  struct routerset_t *_ExcludeExitNodesUnion;\n\n  /** List of \"entry\", \"middle\", \"exit\", \"introduction\", \"rendezvous\". */\n  smartlist_t *AllowInvalidNodes;\n  /** Bitmask; derived from AllowInvalidNodes. */\n  invalid_router_usage_t _AllowInvalid;\n  config_line_t *ExitPolicy; /**< Lists of exit policy components. */\n  int ExitPolicyRejectPrivate; /**< Should we not exit to local addresses? */\n  config_line_t *SocksPolicy; /**< Lists of socks policy components */\n  config_line_t *DirPolicy; /**< Lists of dir policy components */\n  /** Addresses to bind for listening for SOCKS connections. */\n  config_line_t *SocksListenAddress;\n  /** Addresses to bind for listening for transparent pf/netfilter\n   * connections. */\n  config_line_t *TransListenAddress;\n  /** Addresses to bind for listening for transparent natd connections */\n  config_line_t *NatdListenAddress;\n  /** Addresses to bind for listening for SOCKS connections. */\n  config_line_t *DNSListenAddress;\n  /** Addresses to bind for listening for OR connections. */\n  config_line_t *ORListenAddress;\n  /** Addresses to bind for listening for directory connections. */\n  config_line_t *DirListenAddress;\n  /** Addresses to bind for listening for control connections. */\n  config_line_t *ControlListenAddress;\n  /** Local address to bind outbound sockets */\n  char *OutboundBindAddress;\n  /** Directory server only: which versions of\n   * Tor should we tell users to run? */\n  config_line_t *RecommendedVersions;\n  config_line_t *RecommendedClientVersions;\n  config_line_t *RecommendedServerVersions;\n  /** Whether dirservers refuse router descriptors with private IPs. */\n  int DirAllowPrivateAddresses;\n  char *User; /**< Name of user to run Tor as. */\n  char *Group; /**< Name of group to run Tor as. */\n  int ORPort; /**< Port to listen on for OR connections. */\n  int SocksPort; /**< Port to listen on for SOCKS connections. */\n  /** Port to listen on for transparent pf/netfilter connections. */\n  int TransPort;\n  int NatdPort; /**< Port to listen on for transparent natd connections. */\n  int ControlPort; /**< Port to listen on for control connections. */\n  config_line_t *ControlSocket; /**< List of Unix Domain Sockets to listen on\n                                 * for control connections. */\n  int DirPort; /**< Port to listen on for directory connections. */\n  int DNSPort; /**< Port to listen on for DNS requests. */\n  int AssumeReachable; /**< Whether to publish our descriptor regardless. */\n  int AuthoritativeDir; /**< Boolean: is this an authoritative directory? */\n  int V1AuthoritativeDir; /**< Boolean: is this an authoritative directory\n                           * for version 1 directories? */\n  int V2AuthoritativeDir; /**< Boolean: is this an authoritative directory\n                           * for version 2 directories? */\n  int V3AuthoritativeDir; /**< Boolean: is this an authoritative directory\n                           * for version 3 directories? */\n  int HSAuthoritativeDir; /**< Boolean: does this an authoritative directory\n                           * handle hidden service requests? */\n  int HSAuthorityRecordStats; /**< Boolean: does this HS authoritative\n                               * directory record statistics? */\n  int NamingAuthoritativeDir; /**< Boolean: is this an authoritative directory\n                               * that's willing to bind names? */\n  int VersioningAuthoritativeDir; /**< Boolean: is this an authoritative\n                                   * directory that's willing to recommend\n                                   * versions? */\n  int BridgeAuthoritativeDir; /**< Boolean: is this an authoritative directory\n                               * that aggregates bridge descriptors? */\n\n  /** If set on a bridge authority, it will answer requests on its dirport\n   * for bridge statuses -- but only if the requests use this password.\n   * If set on a bridge user, request bridge statuses, and use this password\n   * when doing so. */\n  char *BridgePassword;\n\n  int UseBridges; /**< Boolean: should we start all circuits with a bridge? */\n  config_line_t *Bridges; /**< List of bootstrap bridge addresses. */\n\n  int BridgeRelay; /**< Boolean: are we acting as a bridge relay? We make\n                    * this explicit so we can change how we behave in the\n                    * future. */\n\n  /** Boolean: if we know the bridge's digest, should we get new\n   * descriptors from the bridge authorities or from the bridge itself? */\n  int UpdateBridgesFromAuthority;\n\n  int AvoidDiskWrites; /**< Boolean: should we never cache things to disk?\n                        * Not used yet. */\n  int ClientOnly; /**< Boolean: should we never evolve into a server role? */\n  /** Boolean: should we never publish a descriptor? Deprecated. */\n  int NoPublish;\n  /** To what authority types do we publish our descriptor? Choices are\n   * \"v1\", \"v2\", \"v3\", \"bridge\", or \"\". */\n  smartlist_t *PublishServerDescriptor;\n  /** An authority type, derived from PublishServerDescriptor. */\n  authority_type_t _PublishServerDescriptor;\n  /** Boolean: do we publish hidden service descriptors to the HS auths? */\n  int PublishHidServDescriptors;\n  int FetchServerDescriptors; /**< Do we fetch server descriptors as normal? */\n  int FetchHidServDescriptors; /** and hidden service descriptors? */\n  int HidServDirectoryV2; /**< Do we participate in the HS DHT? */\n\n  int MinUptimeHidServDirectoryV2; /**< As directory authority, accept hidden\n                                    * service directories after what time? */\n  int FetchUselessDescriptors; /**< Do we fetch non-running descriptors too? */\n  int AllDirActionsPrivate; /**< Should every directory action be sent\n                             * through a Tor circuit? */\n\n  int ConnLimit; /**< Demanded minimum number of simultaneous connections. */\n  int _ConnLimit; /**< Maximum allowed number of simultaneous connections. */\n  int RunAsDaemon; /**< If true, run in the background. (Unix only) */\n  int FascistFirewall; /**< Whether to prefer ORs reachable on open ports. */\n  smartlist_t *FirewallPorts; /**< Which ports our firewall allows\n                               * (strings). */\n  config_line_t *ReachableAddresses; /**< IP:ports our firewall allows. */\n  config_line_t *ReachableORAddresses; /**< IP:ports for OR conns. */\n  config_line_t *ReachableDirAddresses; /**< IP:ports for Dir conns. */\n\n  int ConstrainedSockets; /**< Shrink xmit and recv socket buffers. */\n  uint64_t ConstrainedSockSize; /**< Size of constrained buffers. */\n\n  /** Application ports that require all nodes in circ to have sufficient\n   * uptime. */\n  smartlist_t *LongLivedPorts;\n  /** Application ports that are likely to be unencrypted and\n   * unauthenticated; we reject requests for them to prevent the\n   * user from screwing up and leaking plaintext secrets to an\n   * observer somewhere on the Internet. */\n  smartlist_t *RejectPlaintextPorts;\n  /** Related to RejectPlaintextPorts above, except this config option\n   * controls whether we warn (in the log and via a controller status\n   * event) every time a risky connection is attempted. */\n  smartlist_t *WarnPlaintextPorts;\n  /** Should we try to reuse the same exit node for a given host */\n  smartlist_t *TrackHostExits;\n  int TrackHostExitsExpire; /**< Number of seconds until we expire an\n                             * addressmap */\n  config_line_t *AddressMap; /**< List of address map directives. */\n  int AutomapHostsOnResolve; /**< If true, when we get a resolve request for a\n                              * hostname ending with one of the suffixes in\n                              * <b>AutomapHostsSuffixes</b>, map it to a\n                              * virtual address. */\n  smartlist_t *AutomapHostsSuffixes; /**< List of suffixes for\n                                      * <b>AutomapHostsOnResolve</b>. */\n  int RendPostPeriod; /**< How often do we post each rendezvous service\n                       * descriptor? Remember to publish them independently. */\n  int KeepalivePeriod; /**< How often do we send padding cells to keep\n                        * connections alive? */\n  in...\n\nImports:\n- #include \"or.h\"",
    "commit_msg": "Reject create cells on outgoing OR connections from bridges",
    "cve_desc": "Tor before 0.2.2.34, when configured as a client or bridge, sends a TLS certificate chain as part of an outgoing OR connection, which allows remote relays to bypass intended anonymity properties by reading this chain and then determining the set of entry guards that the client or bridge had selected.",
    "year": 2011,
    "filename": "command.c",
    "commit_url": "\"https://github.com/torproject/tor/commit/a74e7fd40f1a77eb4000d8216bb5b80cdd8a6193\""
  },
  {
    "repository": "GNOME/gimp",
    "cve_id": "CVE-2011-2896",
    "cwe_list": [
      "CWE-787"
    ],
    "commit_hash": "376ad788c1a1c31d40f18494889c383f6909ebfc",
    "short_hash": "376ad788",
    "vulnerableMethods_before": [
      {
        "filename": "plug-ins/common/file-gif-load.c",
        "method_name": "LZWReadByte",
        "raw_code": "static gint /* <=== LZWReadByte */ \nLZWReadByte (FILE *fd,\n             gint  just_reset_LZW,\n             gint  input_code_size)\n{\n  static gint fresh = FALSE;\n  gint        code, incode;\n  static gint code_size, set_code_size;\n  static gint max_code, max_code_size;\n  static gint firstcode, oldcode;\n  static gint clear_code, end_code;\n  static gint table[2][(1 << MAX_LZW_BITS)];\n  static gint stack[(1 << (MAX_LZW_BITS)) * 2], *sp;\n  gint        i;\n\n  if (just_reset_LZW)\n    {\n      if (input_code_size > MAX_LZW_BITS)\n        {\n          g_message (\"Value out of range for code size (corrupted file?)\");\n          return -1;\n        }\n\n      set_code_size = input_code_size;\n      code_size     = set_code_size + 1;\n      clear_code    = 1 << set_code_size;\n      end_code      = clear_code + 1;\n      max_code_size = 2 * clear_code;\n      max_code      = clear_code + 2;\n\n      GetCode (fd, 0, TRUE);\n\n      fresh = TRUE;\n\n      sp = stack;\n\n      for (i = 0; i < clear_code; ++i)\n        {\n          table[0][i] = 0;\n          table[1][i] = i;\n        }\n      for (; i < (1 << MAX_LZW_BITS); ++i)\n        {\n          table[0][i] = 0;\n          table[1][i] = 0;\n        }\n\n      return 0;\n    }\n  else if (fresh)\n    {\n      fresh = FALSE;\n      do\n        {\n          firstcode = oldcode = GetCode (fd, code_size, FALSE);\n        }\n      while (firstcode == clear_code);\n\n      return firstcode & 255;\n    }\n\n  if (sp > stack)\n    return (*--sp) & 255;\n\n  while ((code = GetCode (fd, code_size, FALSE)) >= 0)\n    {\n      if (code == clear_code)\n        {\n          for (i = 0; i < clear_code; ++i)\n            {\n              table[0][i] = 0;\n              table[1][i] = i;\n            }\n          for (; i < (1 << MAX_LZW_BITS); ++i)\n            {\n              table[0][i] = 0;\n              table[1][i] = 0;\n            }\n\n          code_size     = set_code_size + 1;\n          max_code_size = 2 * clear_code;\n          max_code      = clear_code + 2;\n          sp            = stack;\n          firstcode     = oldcode = GetCode (fd, code_size, FALSE);\n\n          return firstcode & 255;\n        }\n      else if (code == end_code)\n        {\n          gint   count;\n          guchar buf[260];\n\n          if (ZeroDataBlock)\n            return -2;\n\n          while ((count = GetDataBlock (fd, buf)) > 0)\n            ;\n\n          if (count != 0)\n            g_print (\"GIF: missing EOD in data stream (common occurence)\");\n\n          return -2;\n        }\n\n      incode = code;\n\n      if (code >= max_code)\n        {\n          *sp++ = firstcode;\n          code = oldcode;\n        }\n\n      while (code >= clear_code)\n        {\n          *sp++ = table[1][code];\n          if (code == table[0][code])\n            {\n              g_message (\"Circular table entry.  Corrupt file.\");\n              gimp_quit ();\n            }\n          code = table[0][code];\n        }\n\n      *sp++ = firstcode = table[1][code];\n\n      if ((code = max_code) < (1 << MAX_LZW_BITS))\n        {\n          table[0][code] = oldcode;\n          table[1][code] = firstcode;\n          ++max_code;\n          if ((max_code >= max_code_size) &&\n              (max_code_size < (1 << MAX_LZW_BITS)))\n            {\n              max_code_size *= 2;\n              ++code_size;\n            }\n        }\n\n      oldcode = incode;\n\n      if (sp > stack)\n        return (*--sp) & 255;\n    }\n\n  return code & 255;\n}",
        "start_line": 704
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "plug-ins/common/file-gif-load.c",
        "method_name": "LZWReadByte",
        "raw_code": "static gint /* <=== LZWReadByte */ \nLZWReadByte (FILE *fd,\n             gint  just_reset_LZW,\n             gint  input_code_size)\n{\n  static gint fresh = FALSE;\n  gint        code, incode;\n  static gint code_size, set_code_size;\n  static gint max_code, max_code_size;\n  static gint firstcode, oldcode;\n  static gint clear_code, end_code;\n  static gint table[2][(1 << MAX_LZW_BITS)];\n#define STACK_SIZE ((1 << (MAX_LZW_BITS)) * 2)\n  static gint stack[STACK_SIZE], *sp;\n  gint        i;\n\n  if (just_reset_LZW)\n    {\n      if (input_code_size > MAX_LZW_BITS)\n        {\n          g_message (\"Value out of range for code size (corrupted file?)\");\n          return -1;\n        }\n\n      set_code_size = input_code_size;\n      code_size     = set_code_size + 1;\n      clear_code    = 1 << set_code_size;\n      end_code      = clear_code + 1;\n      max_code_size = 2 * clear_code;\n      max_code      = clear_code + 2;\n\n      GetCode (fd, 0, TRUE);\n\n      fresh = TRUE;\n\n      sp = stack;\n\n      for (i = 0; i < clear_code; ++i)\n        {\n          table[0][i] = 0;\n          table[1][i] = i;\n        }\n      for (; i < (1 << MAX_LZW_BITS); ++i)\n        {\n          table[0][i] = 0;\n          table[1][i] = 0;\n        }\n\n      return 0;\n    }\n  else if (fresh)\n    {\n      fresh = FALSE;\n      do\n        {\n          firstcode = oldcode = GetCode (fd, code_size, FALSE);\n        }\n      while (firstcode == clear_code);\n\n      return firstcode & 255;\n    }\n\n  if (sp > stack)\n    return (*--sp) & 255;\n\n  while ((code = GetCode (fd, code_size, FALSE)) >= 0)\n    {\n      if (code == clear_code)\n        {\n          for (i = 0; i < clear_code; ++i)\n            {\n              table[0][i] = 0;\n              table[1][i] = i;\n            }\n          for (; i < (1 << MAX_LZW_BITS); ++i)\n            {\n              table[0][i] = 0;\n              table[1][i] = 0;\n            }\n\n          code_size     = set_code_size + 1;\n          max_code_size = 2 * clear_code;\n          max_code      = clear_code + 2;\n          sp            = stack;\n          firstcode     = oldcode = GetCode (fd, code_size, FALSE);\n\n          return firstcode & 255;\n        }\n      else if (code == end_code || code > max_code)\n        {\n          gint   count;\n          guchar buf[260];\n\n          if (ZeroDataBlock)\n            return -2;\n\n          while ((count = GetDataBlock (fd, buf)) > 0)\n            ;\n\n          if (count != 0)\n            g_print (\"GIF: missing EOD in data stream (common occurence)\");\n\n          return -2;\n        }\n\n      incode = code;\n\n      if (code == max_code)\n        {\n          if (sp < &(stack[STACK_SIZE]))\n            *sp++ = firstcode;\n          code = oldcode;\n        }\n\n      while (code >= clear_code && sp < &(stack[STACK_SIZE]))\n        {\n          *sp++ = table[1][code];\n          if (code == table[0][code])\n            {\n              g_message (\"Circular table entry.  Corrupt file.\");\n              gimp_quit ();\n            }\n          code = table[0][code];\n        }\n\n      if (sp < &(stack[STACK_SIZE]))\n        *sp++ = firstcode = table[1][code];\n\n      if ((code = max_code) < (1 << MAX_LZW_BITS))\n        {\n          table[0][code] = oldcode;\n          table[1][code] = firstcode;\n          ++max_code;\n          if ((max_code >= max_code_size) &&\n              (max_code_size < (1 << MAX_LZW_BITS)))\n            {\n              max_code_size *= 2;\n              ++code_size;\n            }\n        }\n\n      oldcode = incode;\n\n      if (sp > stack)\n        return (*--sp) & 255;\n    }\n\n  return code & 255;\n}",
        "start_line": 704
      },
      {
        "filename": "plug-ins/common/file-gif-load.c",
        "method_name": "STACK_SIZE",
        "raw_code": "#define STACK_SIZE ((1 << (MAX_LZW_BITS)) * 2) /* <=== plug-ins/common/file-gif-load.c:716:716:STACK_SIZE:0 */ ",
        "start_line": 716
      }
    ],
    "code_context": "Called Methods:\n- MAX_LZW_BITS: #define MAX_LZW_BITS     12 /* <=== plug-ins/common/file-gif-load.c:268:268:MAX_LZW_BITS:0 */ \n- GetDataBlock: static gint /* <=== GetDataBlock */ \nGetDataBlock (FILE   *fd,\n              guchar *buf)\n{\n  guchar count;\n\n  if (! ReadOK (fd, &count, 1))\n    {\n      g_message (\"Error in getting DataBlock size\");\n      return -1;\n    }\n\n  ZeroDataBlock = count == 0;\n\n  if ((count != 0) && (! ReadOK (fd, buf, count)))\n    {\n      g_message (\"Error in reading DataBlock\");\n      return -1;\n    }\n\n  return count;\n}\n- ReadOK: #define ReadOK(file,buffer,len) (fread(buffer, len, 1, file) != 0) /* <=== plug-ins/common/file-gif-load.c:274:274:ReadOK:3 */ \n- gimp_close: static void /* <=== gimp_close */ \ngimp_close (void)\n{\n  if (gimp_debug_flags & GIMP_DEBUG_QUIT)\n    gimp_debug_stop ();\n\n  if (PLUG_IN_INFO.quit_proc)\n    (* PLUG_IN_INFO.quit_proc) ();\n\n#if defined(USE_SYSV_SHM)\n\n  if ((_shm_ID != -1) && _shm_addr)\n    shmdt ((char *) _shm_addr);\n\n#elif defined(USE_WIN32_SHM)\n\n  if (shm_handle)\n    CloseHandle (shm_handle);\n\n#elif defined(USE_POSIX_SHM)\n\n  if ((_shm_ID != -1) && (_shm_addr != MAP_FAILED))\n    munmap (_shm_addr, TILE_MAP_SIZE);\n\n#endif\n\n  gp_quit_write (_writechannel, NULL);\n}\n- gimp_quit: void /* <=== gimp_quit */ \ngimp_quit (void)\n{\n  gimp_close ();\n\n  exit (EXIT_SUCCESS);\n}\n- GetCode: static gint /* <=== GetCode */ \nGetCode (FILE     *fd,\n         gint      code_size,\n         gboolean  flag)\n{\n  static guchar buf[280];\n  static gint   curbit, lastbit, done, last_byte;\n  gint          i, j, ret, count;\n\n  if (flag)\n    {\n      curbit = 0;\n      lastbit = 0;\n      done = FALSE;\n      last_byte = 2;\n      return 0;\n    }\n\n  while ((curbit + code_size) >= lastbit)\n    {\n      if (done)\n        {\n          if (curbit >= lastbit)\n            g_message (\"Ran off the end of my bits\");\n\n          return -1;\n        }\n\n      buf[0] = buf[last_byte - 2];\n      buf[1] = buf[last_byte - 1];\n\n      if ((count = GetDataBlock (fd, &buf[2])) <= 0)\n        done = TRUE;\n\n      last_byte = 2 + count;\n      curbit = (curbit - lastbit) + 16;\n      lastbit = (2 + count) * 8;\n    }\n\n  ret = 0;\n  for (i = curbit, j = 0; j < code_size; ++i, ++j)\n    ret |= ((buf[i / 8] & (1 << (i % 8))) != 0) << j;\n\n  curbit += code_size;\n\n  return ret;\n}\n\nGlobal Variables:\n- gint ZeroDataBlock\n\nImports:\n- #include <glib/gstdio.h>\n- #include <libgimp/gimp.h>\n- #include \"config.h\"\n- #include \"libgimp/stdplugins-intl.h\"\n- #include <string.h>\n- #include <errno.h>",
    "commit_msg": "file-gif-load: fix heap corruption and buffer overflow (CVE-2011-2896)",
    "cve_desc": "The LZW decompressor in the LWZReadByte function in giftoppm.c in the David Koblas GIF decoder in PBMPLUS, as used in the gif_read_lzw function in filter/image-gif.c in CUPS before 1.4.7, the LZWReadByte function in plug-ins/common/file-gif-load.c in GIMP 2.6.11 and earlier, the LZWReadByte function in img/gifread.c in XPCE in SWI-Prolog 5.10.4 and earlier, and other products, does not properly handle code words that are absent from the decompression table when encountered, which allows remote attackers to trigger an infinite loop or a heap-based buffer overflow, and possibly execute arbitrary code, via a crafted compressed stream, a related issue to CVE-2006-1168 and CVE-2011-2895.",
    "year": 2011,
    "filename": "file-gif-load.c",
    "commit_url": "\"https://github.com/GNOME/gimp/commit/376ad788c1a1c31d40f18494889c383f6909ebfc\""
  },
  {
    "repository": "torvalds/linux",
    "cve_id": "CVE-2011-2906",
    "cwe_list": [
      "CWE-400"
    ],
    "commit_hash": "b5b515445f4f5a905c5dd27e6e682868ccd6c09d",
    "short_hash": "b5b51544",
    "vulnerableMethods_before": [
      {
        "filename": "drivers/scsi/pmcraid.c",
        "method_name": "pmcraid_ioctl_passthrough",
        "raw_code": "static long pmcraid_ioctl_passthrough( /* <=== pmcraid_ioctl_passthrough */ \n\tstruct pmcraid_instance *pinstance,\n\tunsigned int ioctl_cmd,\n\tunsigned int buflen,\n\tunsigned long arg\n)\n{\n\tstruct pmcraid_passthrough_ioctl_buffer *buffer;\n\tstruct pmcraid_ioarcb *ioarcb;\n\tstruct pmcraid_cmd *cmd;\n\tstruct pmcraid_cmd *cancel_cmd;\n\tunsigned long request_buffer;\n\tunsigned long request_offset;\n\tunsigned long lock_flags;\n\tvoid *ioasa;\n\tu32 ioasc;\n\tint request_size;\n\tint buffer_size;\n\tu8 access, direction;\n\tint rc = 0;\n\n\t/* If IOA reset is in progress, wait 10 secs for reset to complete */\n\tif (pinstance->ioa_reset_in_progress) {\n\t\trc = wait_event_interruptible_timeout(\n\t\t\t\tpinstance->reset_wait_q,\n\t\t\t\t!pinstance->ioa_reset_in_progress,\n\t\t\t\tmsecs_to_jiffies(10000));\n\n\t\tif (!rc)\n\t\t\treturn -ETIMEDOUT;\n\t\telse if (rc < 0)\n\t\t\treturn -ERESTARTSYS;\n\t}\n\n\t/* If adapter is not in operational state, return error */\n\tif (pinstance->ioa_state != IOA_STATE_OPERATIONAL) {\n\t\tpmcraid_err(\"IOA is not operational\\n\");\n\t\treturn -ENOTTY;\n\t}\n\n\tbuffer_size = sizeof(struct pmcraid_passthrough_ioctl_buffer);\n\tbuffer = kmalloc(buffer_size, GFP_KERNEL);\n\n\tif (!buffer) {\n\t\tpmcraid_err(\"no memory for passthrough buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\trequest_offset =\n\t    offsetof(struct pmcraid_passthrough_ioctl_buffer, request_buffer);\n\n\trequest_buffer = arg + request_offset;\n\n\trc = __copy_from_user(buffer,\n\t\t\t     (struct pmcraid_passthrough_ioctl_buffer *) arg,\n\t\t\t     sizeof(struct pmcraid_passthrough_ioctl_buffer));\n\n\tioasa =\n\t(void *)(arg +\n\t\toffsetof(struct pmcraid_passthrough_ioctl_buffer, ioasa));\n\n\tif (rc) {\n\t\tpmcraid_err(\"ioctl: can't copy passthrough buffer\\n\");\n\t\trc = -EFAULT;\n\t\tgoto out_free_buffer;\n\t}\n\n\trequest_size = buffer->ioarcb.data_transfer_length;\n\n\tif (buffer->ioarcb.request_flags0 & TRANSFER_DIR_WRITE) {\n\t\taccess = VERIFY_READ;\n\t\tdirection = DMA_TO_DEVICE;\n\t} else {\n\t\taccess = VERIFY_WRITE;\n\t\tdirection = DMA_FROM_DEVICE;\n\t}\n\n\tif (request_size > 0) {\n\t\trc = access_ok(access, arg, request_offset + request_size);\n\n\t\tif (!rc) {\n\t\t\trc = -EFAULT;\n\t\t\tgoto out_free_buffer;\n\t\t}\n\t} else if (request_size < 0) {\n\t\trc = -EINVAL;\n\t\tgoto out_free_buffer;\n\t}\n\n\t/* check if we have any additional command parameters */\n\tif (buffer->ioarcb.add_cmd_param_length > PMCRAID_ADD_CMD_PARAM_LEN) {\n\t\trc = -EINVAL;\n\t\tgoto out_free_buffer;\n\t}\n\n\tcmd = pmcraid_get_free_cmd(pinstance);\n\n\tif (!cmd) {\n\t\tpmcraid_err(\"free command block is not available\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out_free_buffer;\n\t}\n\n\tcmd->scsi_cmd = NULL;\n\tioarcb = &(cmd->ioa_cb->ioarcb);\n\n\t/* Copy the user-provided IOARCB stuff field by field */\n\tioarcb->resource_handle = buffer->ioarcb.resource_handle;\n\tioarcb->data_transfer_length = buffer->ioarcb.data_transfer_length;\n\tioarcb->cmd_timeout = buffer->ioarcb.cmd_timeout;\n\tioarcb->request_type = buffer->ioarcb.request_type;\n\tioarcb->request_flags0 = buffer->ioarcb.request_flags0;\n\tioarcb->request_flags1 = buffer->ioarcb.request_flags1;\n\tmemcpy(ioarcb->cdb, buffer->ioarcb.cdb, PMCRAID_MAX_CDB_LEN);\n\n\tif (buffer->ioarcb.add_cmd_param_length) {\n\t\tioarcb->add_cmd_param_length =\n\t\t\tbuffer->ioarcb.add_cmd_param_length;\n\t\tioarcb->add_cmd_param_offset =\n\t\t\tbuffer->ioarcb.add_cmd_param_offset;\n\t\tmemcpy(ioarcb->add_data.u.add_cmd_params,\n\t\t\tbuffer->ioarcb.add_data.u.add_cmd_params,\n\t\t\tbuffer->ioarcb.add_cmd_param_length);\n\t}\n\n\t/* set hrrq number where the IOA should respond to. Note that all cmds\n\t * generated internally uses hrrq_id 0, exception to this is the cmd\n\t * block of scsi_cmd which is re-used (e.g. cancel/abort), which uses\n\t * hrrq_id assigned here in queuecommand\n\t */\n\tioarcb->hrrq_id = atomic_add_return(1, &(pinstance->last_message_id)) %\n\t\t\t  pinstance->num_hrrq;\n\n\tif (request_size) {\n\t\trc = pmcraid_build_passthrough_ioadls(cmd,\n\t\t\t\t\t\t      request_size,\n\t\t\t\t\t\t      direction);\n\t\tif (rc) {\n\t\t\tpmcraid_err(\"couldn't build passthrough ioadls\\n\");\n\t\t\tgoto out_free_buffer;\n\t\t}\n\t}\n\n\t/* If data is being written into the device, copy the data from user\n\t * buffers\n\t */\n\tif (direction == DMA_TO_DEVICE && request_size > 0) {\n\t\trc = pmcraid_copy_sglist(cmd->sglist,\n\t\t\t\t\t request_buffer,\n\t\t\t\t\t request_size,\n\t\t\t\t\t direction);\n\t\tif (rc) {\n\t\t\tpmcraid_err(\"failed to copy user buffer\\n\");\n\t\t\tgoto out_free_sglist;\n\t\t}\n\t}\n\n\t/* passthrough ioctl is a blocking command so, put the user to sleep\n\t * until timeout. Note that a timeout value of 0 means, do timeout.\n\t */\n\tcmd->cmd_done = pmcraid_internal_done;\n\tinit_completion(&cmd->wait_for_completion);\n\tcmd->completion_req = 1;\n\n\tpmcraid_info(\"command(%d) (CDB[0] = %x) for %x\\n\",\n\t\t     le32_to_cpu(cmd->ioa_cb->ioarcb.response_handle) >> 2,\n\t\t     cmd->ioa_cb->ioarcb.cdb[0],\n\t\t     le32_to_cpu(cmd->ioa_cb->ioarcb.resource_handle));\n\n\tspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\n\t_pmcraid_fire_command(cmd);\n\tspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\n\n\t/* NOTE ! Remove the below line once abort_task is implemented\n\t * in firmware. This line disables ioctl command timeout handling logic\n\t * similar to IO command timeout handling, making ioctl commands to wait\n\t * until the command completion regardless of timeout value specified in\n\t * ioarcb\n\t */\n\tbuffer->ioarcb.cmd_timeout = 0;\n\n\t/* If command timeout is specified put caller to wait till that time,\n\t * otherwise it would be blocking wait. If command gets timed out, it\n\t * will be aborted.\n\t */\n\tif (buffer->ioarcb.cmd_timeout == 0) {\n\t\twait_for_completion(&cmd->wait_for_completion);\n\t} else if (!wait_for_completion_timeout(\n\t\t\t&cmd->wait_for_completion,\n\t\t\tmsecs_to_jiffies(buffer->ioarcb.cmd_timeout * 1000))) {\n\n\t\tpmcraid_info(\"aborting cmd %d (CDB[0] = %x) due to timeout\\n\",\n\t\t\tle32_to_cpu(cmd->ioa_cb->ioarcb.response_handle >> 2),\n\t\t\tcmd->ioa_cb->ioarcb.cdb[0]);\n\n\t\tspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\n\t\tcancel_cmd = pmcraid_abort_cmd(cmd);\n\t\tspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\n\n\t\tif (cancel_cmd) {\n\t\t\twait_for_completion(&cancel_cmd->wait_for_completion);\n\t\t\tioasc = cancel_cmd->ioa_cb->ioasa.ioasc;\n\t\t\tpmcraid_return_cmd(cancel_cmd);\n\n\t\t\t/* if abort task couldn't find the command i.e it got\n\t\t\t * completed prior to aborting, return good completion.\n\t\t\t * if command got aborted successfully or there was IOA\n\t\t\t * reset due to abort task itself getting timedout then\n\t\t\t * return -ETIMEDOUT\n\t\t\t */\n\t\t\tif (ioasc == PMCRAID_IOASC_IOA_WAS_RESET ||\n\t\t\t    PMCRAID_IOASC_SENSE_KEY(ioasc) == 0x00) {\n\t\t\t\tif (ioasc != PMCRAID_IOASC_GC_IOARCB_NOTFOUND)\n\t\t\t\t\trc = -ETIMEDOUT;\n\t\t\t\tgoto out_handle_response;\n\t\t\t}\n\t\t}\n\n\t\t/* no command block for abort task or abort task failed to abort\n\t\t * the IOARCB, then wait for 150 more seconds and initiate reset\n\t\t * sequence after timeout\n\t\t */\n\t\tif (!wait_for_completion_timeout(\n\t\t\t&cmd->wait_for_completion,\n\t\t\tmsecs_to_jiffies(150 * 1000))) {\n\t\t\tpmcraid_reset_bringup(cmd->drv_inst);\n\t\t\trc = -ETIMEDOUT;\n\t\t}\n\t}\n\nout_handle_response:\n\t/* copy entire IOASA buffer and return IOCTL success.\n\t * If copying IOASA to user-buffer fails, return\n\t * EFAULT\n\t */\n\tif (copy_to_user(ioasa, &cmd->ioa_cb->ioasa,\n\t\tsizeof(struct pmcraid_ioasa))) {\n\t\tpmcraid_err(\"failed to copy ioasa buffer to user\\n\");\n\t\trc = -EFAULT;\n\t}\n\n\t/* If the data transfer was from device, copy the data onto user\n\t * buffers\n\t */\n\telse if (direction == DMA_FROM_DEVICE && request_size > 0) {\n\t\trc = pmcraid_copy_sglist(cmd->sglist,\n\t\t\t\t\t request_buffer,\n\t\t\t\t\t request_size,\n\t\t\t\t\t direction);\n\t\tif (rc) {\n\t\t\tpmcraid_err(\"failed to copy user buffer\\n\");\n\t\t\trc = -EFAULT;\n\t\t}\n\t}\n\nout_free_sglist:\n\tpmcraid_release_passthrough_ioadls(cmd, request_size, direction);\n\tpmcraid_return_cmd(cmd);\n\nout_free_buffer:\n\tkfree(buffer);\n\n\treturn rc;\n}",
        "start_line": 3733
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "drivers/scsi/pmcraid.c",
        "method_name": "pmcraid_ioctl_passthrough",
        "raw_code": "static long pmcraid_ioctl_passthrough( /* <=== pmcraid_ioctl_passthrough */ \n\tstruct pmcraid_instance *pinstance,\n\tunsigned int ioctl_cmd,\n\tunsigned int buflen,\n\tunsigned long arg\n)\n{\n\tstruct pmcraid_passthrough_ioctl_buffer *buffer;\n\tstruct pmcraid_ioarcb *ioarcb;\n\tstruct pmcraid_cmd *cmd;\n\tstruct pmcraid_cmd *cancel_cmd;\n\tunsigned long request_buffer;\n\tunsigned long request_offset;\n\tunsigned long lock_flags;\n\tvoid *ioasa;\n\tu32 ioasc;\n\tint request_size;\n\tint buffer_size;\n\tu8 access, direction;\n\tint rc = 0;\n\n\t/* If IOA reset is in progress, wait 10 secs for reset to complete */\n\tif (pinstance->ioa_reset_in_progress) {\n\t\trc = wait_event_interruptible_timeout(\n\t\t\t\tpinstance->reset_wait_q,\n\t\t\t\t!pinstance->ioa_reset_in_progress,\n\t\t\t\tmsecs_to_jiffies(10000));\n\n\t\tif (!rc)\n\t\t\treturn -ETIMEDOUT;\n\t\telse if (rc < 0)\n\t\t\treturn -ERESTARTSYS;\n\t}\n\n\t/* If adapter is not in operational state, return error */\n\tif (pinstance->ioa_state != IOA_STATE_OPERATIONAL) {\n\t\tpmcraid_err(\"IOA is not operational\\n\");\n\t\treturn -ENOTTY;\n\t}\n\n\tbuffer_size = sizeof(struct pmcraid_passthrough_ioctl_buffer);\n\tbuffer = kmalloc(buffer_size, GFP_KERNEL);\n\n\tif (!buffer) {\n\t\tpmcraid_err(\"no memory for passthrough buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\trequest_offset =\n\t    offsetof(struct pmcraid_passthrough_ioctl_buffer, request_buffer);\n\n\trequest_buffer = arg + request_offset;\n\n\trc = __copy_from_user(buffer,\n\t\t\t     (struct pmcraid_passthrough_ioctl_buffer *) arg,\n\t\t\t     sizeof(struct pmcraid_passthrough_ioctl_buffer));\n\n\tioasa =\n\t(void *)(arg +\n\t\toffsetof(struct pmcraid_passthrough_ioctl_buffer, ioasa));\n\n\tif (rc) {\n\t\tpmcraid_err(\"ioctl: can't copy passthrough buffer\\n\");\n\t\trc = -EFAULT;\n\t\tgoto out_free_buffer;\n\t}\n\n\trequest_size = buffer->ioarcb.data_transfer_length;\n\n\tif (buffer->ioarcb.request_flags0 & TRANSFER_DIR_WRITE) {\n\t\taccess = VERIFY_READ;\n\t\tdirection = DMA_TO_DEVICE;\n\t} else {\n\t\taccess = VERIFY_WRITE;\n\t\tdirection = DMA_FROM_DEVICE;\n\t}\n\n\tif (request_size > 0) {\n\t\trc = access_ok(access, arg, request_offset + request_size);\n\n\t\tif (!rc) {\n\t\t\trc = -EFAULT;\n\t\t\tgoto out_free_buffer;\n\t\t}\n\t} else if (request_size < 0) {\n\t\trc = -EINVAL;\n\t\tgoto out_free_buffer;\n\t}\n\n\t/* check if we have any additional command parameters */\n\tif (buffer->ioarcb.add_cmd_param_length > PMCRAID_ADD_CMD_PARAM_LEN) {\n\t\trc = -EINVAL;\n\t\tgoto out_free_buffer;\n\t}\n\n\tcmd = pmcraid_get_free_cmd(pinstance);\n\n\tif (!cmd) {\n\t\tpmcraid_err(\"free command block is not available\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out_free_buffer;\n\t}\n\n\tcmd->scsi_cmd = NULL;\n\tioarcb = &(cmd->ioa_cb->ioarcb);\n\n\t/* Copy the user-provided IOARCB stuff field by field */\n\tioarcb->resource_handle = buffer->ioarcb.resource_handle;\n\tioarcb->data_transfer_length = buffer->ioarcb.data_transfer_length;\n\tioarcb->cmd_timeout = buffer->ioarcb.cmd_timeout;\n\tioarcb->request_type = buffer->ioarcb.request_type;\n\tioarcb->request_flags0 = buffer->ioarcb.request_flags0;\n\tioarcb->request_flags1 = buffer->ioarcb.request_flags1;\n\tmemcpy(ioarcb->cdb, buffer->ioarcb.cdb, PMCRAID_MAX_CDB_LEN);\n\n\tif (buffer->ioarcb.add_cmd_param_length) {\n\t\tioarcb->add_cmd_param_length =\n\t\t\tbuffer->ioarcb.add_cmd_param_length;\n\t\tioarcb->add_cmd_param_offset =\n\t\t\tbuffer->ioarcb.add_cmd_param_offset;\n\t\tmemcpy(ioarcb->add_data.u.add_cmd_params,\n\t\t\tbuffer->ioarcb.add_data.u.add_cmd_params,\n\t\t\tbuffer->ioarcb.add_cmd_param_length);\n\t}\n\n\t/* set hrrq number where the IOA should respond to. Note that all cmds\n\t * generated internally uses hrrq_id 0, exception to this is the cmd\n\t * block of scsi_cmd which is re-used (e.g. cancel/abort), which uses\n\t * hrrq_id assigned here in queuecommand\n\t */\n\tioarcb->hrrq_id = atomic_add_return(1, &(pinstance->last_message_id)) %\n\t\t\t  pinstance->num_hrrq;\n\n\tif (request_size) {\n\t\trc = pmcraid_build_passthrough_ioadls(cmd,\n\t\t\t\t\t\t      request_size,\n\t\t\t\t\t\t      direction);\n\t\tif (rc) {\n\t\t\tpmcraid_err(\"couldn't build passthrough ioadls\\n\");\n\t\t\tgoto out_free_buffer;\n\t\t}\n\t} else if (request_size < 0) {\n\t\trc = -EINVAL;\n\t\tgoto out_free_buffer;\n\t}\n\n\t/* If data is being written into the device, copy the data from user\n\t * buffers\n\t */\n\tif (direction == DMA_TO_DEVICE && request_size > 0) {\n\t\trc = pmcraid_copy_sglist(cmd->sglist,\n\t\t\t\t\t request_buffer,\n\t\t\t\t\t request_size,\n\t\t\t\t\t direction);\n\t\tif (rc) {\n\t\t\tpmcraid_err(\"failed to copy user buffer\\n\");\n\t\t\tgoto out_free_sglist;\n\t\t}\n\t}\n\n\t/* passthrough ioctl is a blocking command so, put the user to sleep\n\t * until timeout. Note that a timeout value of 0 means, do timeout.\n\t */\n\tcmd->cmd_done = pmcraid_internal_done;\n\tinit_completion(&cmd->wait_for_completion);\n\tcmd->completion_req = 1;\n\n\tpmcraid_info(\"command(%d) (CDB[0] = %x) for %x\\n\",\n\t\t     le32_to_cpu(cmd->ioa_cb->ioarcb.response_handle) >> 2,\n\t\t     cmd->ioa_cb->ioarcb.cdb[0],\n\t\t     le32_to_cpu(cmd->ioa_cb->ioarcb.resource_handle));\n\n\tspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\n\t_pmcraid_fire_command(cmd);\n\tspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\n\n\t/* NOTE ! Remove the below line once abort_task is implemented\n\t * in firmware. This line disables ioctl command timeout handling logic\n\t * similar to IO command timeout handling, making ioctl commands to wait\n\t * until the command completion regardless of timeout value specified in\n\t * ioarcb\n\t */\n\tbuffer->ioarcb.cmd_timeout = 0;\n\n\t/* If command timeout is specified put caller to wait till that time,\n\t * otherwise it would be blocking wait. If command gets timed out, it\n\t * will be aborted.\n\t */\n\tif (buffer->ioarcb.cmd_timeout == 0) {\n\t\twait_for_completion(&cmd->wait_for_completion);\n\t} else if (!wait_for_completion_timeout(\n\t\t\t&cmd->wait_for_completion,\n\t\t\tmsecs_to_jiffies(buffer->ioarcb.cmd_timeout * 1000))) {\n\n\t\tpmcraid_info(\"aborting cmd %d (CDB[0] = %x) due to timeout\\n\",\n\t\t\tle32_to_cpu(cmd->ioa_cb->ioarcb.response_handle >> 2),\n\t\t\tcmd->ioa_cb->ioarcb.cdb[0]);\n\n\t\tspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\n\t\tcancel_cmd = pmcraid_abort_cmd(cmd);\n\t\tspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\n\n\t\tif (cancel_cmd) {\n\t\t\twait_for_completion(&cancel_cmd->wait_for_completion);\n\t\t\tioasc = cancel_cmd->ioa_cb->ioasa.ioasc;\n\t\t\tpmcraid_return_cmd(cancel_cmd);\n\n\t\t\t/* if abort task couldn't find the command i.e it got\n\t\t\t * completed prior to aborting, return good completion.\n\t\t\t * if command got aborted successfully or there was IOA\n\t\t\t * reset due to abort task itself getting timedout then\n\t\t\t * return -ETIMEDOUT\n\t\t\t */\n\t\t\tif (ioasc == PMCRAID_IOASC_IOA_WAS_RESET ||\n\t\t\t    PMCRAID_IOASC_SENSE_KEY(ioasc) == 0x00) {\n\t\t\t\tif (ioasc != PMCRAID_IOASC_GC_IOARCB_NOTFOUND)\n\t\t\t\t\trc = -ETIMEDOUT;\n\t\t\t\tgoto out_handle_response;\n\t\t\t}\n\t\t}\n\n\t\t/* no command block for abort task or abort task failed to abort\n\t\t * the IOARCB, then wait for 150 more seconds and initiate reset\n\t\t * sequence after timeout\n\t\t */\n\t\tif (!wait_for_completion_timeout(\n\t\t\t&cmd->wait_for_completion,\n\t\t\tmsecs_to_jiffies(150 * 1000))) {\n\t\t\tpmcraid_reset_bringup(cmd->drv_inst);\n\t\t\trc = -ETIMEDOUT;\n\t\t}\n\t}\n\nout_handle_response:\n\t/* copy entire IOASA buffer and return IOCTL success.\n\t * If copying IOASA to user-buffer fails, return\n\t * EFAULT\n\t */\n\tif (copy_to_user(ioasa, &cmd->ioa_cb->ioasa,\n\t\tsizeof(struct pmcraid_ioasa))) {\n\t\tpmcraid_err(\"failed to copy ioasa buffer to user\\n\");\n\t\trc = -EFAULT;\n\t}\n\n\t/* If the data transfer was from device, copy the data onto user\n\t * buffers\n\t */\n\telse if (direction == DMA_FROM_DEVICE && request_size > 0) {\n\t\trc = pmcraid_copy_sglist(cmd->sglist,\n\t\t\t\t\t request_buffer,\n\t\t\t\t\t request_size,\n\t\t\t\t\t direction);\n\t\tif (rc) {\n\t\t\tpmcraid_err(\"failed to copy user buffer\\n\");\n\t\t\trc = -EFAULT;\n\t\t}\n\t}\n\nout_free_sglist:\n\tpmcraid_release_passthrough_ioadls(cmd, request_size, direction);\n\tpmcraid_return_cmd(cmd);\n\nout_free_buffer:\n\tkfree(buffer);\n\n\treturn rc;\n}",
        "start_line": 3733
      }
    ],
    "code_context": "Called Methods:\n- pmcraid_reset_reload: static int pmcraid_reset_reload( /* <=== pmcraid_reset_reload */ \n\tstruct pmcraid_instance *pinstance,\n\tu8 shutdown_type,\n\tu8 target_state\n)\n{\n\tstruct pmcraid_cmd *reset_cmd = NULL;\n\tunsigned long lock_flags;\n\tint reset = 1;\n\n\tspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\n\n\tif (pinstance->ioa_reset_in_progress) {\n\t\tpmcraid_info(\"reset_reload: reset is already in progress\\n\");\n\n\t\tspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\n\n\t\twait_event(pinstance->reset_wait_q,\n\t\t\t   !pinstance->ioa_reset_in_progress);\n\n\t\tspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\n\n\t\tif (pinstance->ioa_state == IOA_STATE_DEAD) {\n\t\t\tspin_unlock_irqrestore(pinstance->host->host_lock,\n\t\t\t\t\t       lock_flags);\n\t\t\tpmcraid_info(\"reset_reload: IOA is dead\\n\");\n\t\t\treturn reset;\n\t\t} else if (pinstance->ioa_state == target_state) {\n\t\t\treset = 0;\n\t\t}\n\t}\n\n\tif (reset) {\n\t\tpmcraid_info(\"reset_reload: proceeding with reset\\n\");\n\t\tscsi_block_requests(pinstance->host);\n\t\treset_cmd = pmcraid_get_free_cmd(pinstance);\n\n\t\tif (reset_cmd == NULL) {\n\t\t\tpmcraid_err(\"no free cmnd for reset_reload\\n\");\n\t\t\tspin_unlock_irqrestore(pinstance->host->host_lock,\n\t\t\t\t\t       lock_flags);\n\t\t\treturn reset;\n\t\t}\n\n\t\tif (shutdown_type == SHUTDOWN_NORMAL)\n\t\t\tpinstance->ioa_bringdown = 1;\n\n\t\tpinstance->ioa_shutdown_type = shutdown_type;\n\t\tpinstance->reset_cmd = reset_cmd;\n\t\tpinstance->force_ioa_reset = reset;\n\t\tpmcraid_info(\"reset_reload: initiating reset\\n\");\n\t\tpmcraid_ioa_reset(reset_cmd);\n\t\tspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\n\t\tpmcraid_info(\"reset_reload: waiting for reset to complete\\n\");\n\t\twait_event(pinstance->reset_wait_q,\n\t\t\t   !pinstance->ioa_reset_in_progress);\n\n\t\tpmcraid_info(\"reset_reload: reset is complete !!\\n\");\n\t\tscsi_unblock_requests(pinstance->host);\n\t\tif (pinstance->ioa_state == target_state)\n\t\t\treset = 0;\n\t}\n\n\treturn reset;\n}\n- access_ok: #define access_ok(type, addr, size)\t\t\t\t\\ /* <=== arch/score/include/asm/uaccess.h:56:57:access_ok:3 */ \n\tlikely(__access_ok((unsigned long)(addr), (size)))\n- kunmap: void kunmap(struct page *page) /* <=== kunmap */ \n{\n\tif (in_interrupt())\n\t\tBUG();\n\tif (!PageHighMem(page))\n\t\treturn;\n\tkunmap_high(page);\n}\n- pci_unmap_sg: static inline void /* <=== pci_unmap_sg */ \npci_unmap_sg(struct pci_dev *hwdev, struct scatterlist *sg,\n\t     int nents, int direction)\n{\n\tdma_unmap_sg(hwdev == NULL ? NULL : &hwdev->dev, sg, nents, (enum dma_data_direction)direction);\n}\n- kmap: void *kmap(struct page *page) /* <=== kmap */ \n{\n\tmight_sleep();\n\tif (!PageHighMem(page))\n\t\treturn page_address(page);\n\treturn kmap_high(page);\n}\n- kunmap: void kunmap(struct page *page) /* <=== kunmap */ \n{\n\tBUG_ON(in_interrupt());\n\tif (!PageHighMem(page))\n\t\treturn;\n\tkunmap_high(page);\n}\n- pmcraid_prepare_cancel_cmd: static void pmcraid_prepare_cancel_cmd( /* <=== pmcraid_prepare_cancel_cmd */ \n\tstruct pmcraid_cmd *cmd,\n\tstruct pmcraid_cmd *cmd_to_cancel\n)\n{\n\tstruct pmcraid_ioarcb *ioarcb = &cmd->ioa_cb->ioarcb;\n\t__be64 ioarcb_addr = cmd_to_cancel->ioa_cb->ioarcb.ioarcb_bus_addr;\n\n\t/* Get the resource handle to where the command to be aborted has been\n\t * sent.\n\t */\n\tioarcb->resource_handle = cmd_to_cancel->ioa_cb->ioarcb.resource_handle;\n\tioarcb->request_type = REQ_TYPE_IOACMD;\n\tmemset(ioarcb->cdb, 0, PMCRAID_MAX_CDB_LEN);\n\tioarcb->cdb[0] = PMCRAID_ABORT_CMD;\n\n\t/* IOARCB address of the command to be cancelled is given in\n\t * cdb[2]..cdb[9] is Big-Endian format. Note that length bits in\n\t * IOARCB address are not masked.\n\t */\n\tioarcb_addr = cpu_to_be64(ioarcb_addr);\n\tmemcpy(&(ioarcb->cdb[2]), &ioarcb_addr, sizeof(ioarcb_addr));\n}\n- pmcraid_err: #define pmcraid_err(...)  \\ /* <=== drivers/scsi/pmcraid.h:999:1000:pmcraid_err:1 */ \n\tprintk(KERN_ERR \"MaxRAID: \"__VA_ARGS__)\n- wait_for_common: wait_for_common(struct completion *x, long timeout, int state) /* <=== wait_for_common */ \n{\n\tmight_sleep();\n\n\tspin_lock_irq(&x->wait.lock);\n\ttimeout = do_wait_for_common(x, timeout, state);\n\tspin_unlock_irq(&x->wait.lock);\n\treturn timeout;\n}\n- kmap: void *kmap(struct page *page) /* <=== kmap */ \n{\n\tmight_sleep();\n\tif (!PageHighMem(page))\n\t\treturn page_address(page);\n\treturn kmap_high(page);\n}\n- kmap: void *kmap(struct page *page) /* <=== kmap */ \n{\n\tmight_sleep();\n\tif (!PageHighMem(page))\n\t\treturn page_address(page);\n\treturn kmap_high(page);\n}\n- kunmap: void kunmap(struct page *page) /* <=== kunmap */ \n{\n\tif (in_interrupt())\n\t\tBUG();\n\tif (!PageHighMem(page))\n\t\treturn;\n\tkunmap_high(page);\n}\n- atomic_inc: static inline void atomic_inc(volatile atomic_t *v) /* <=== atomic_inc */ \n{\n\tunsigned long flags;\n\tcris_atomic_save(v, flags);\n\t(v->counter)++;\n\tcris_atomic_restore(v, flags);\n}\n- pmcraid_return_cmd: void pmcraid_return_cmd(struct pmcraid_cmd *cmd) /* <=== pmcraid_return_cmd */ \n{\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tunsigned long lock_flags;\n\n\tspin_lock_irqsave(&pinstance->free_pool_lock, lock_flags);\n\tlist_add_tail(&cmd->free_list, &pinstance->free_cmd_pool);\n\tspin_unlock_irqrestore(&pinstance->free_pool_lock, lock_flags);\n}\n- PMCRAID_IOASC_IOA_WAS_RESET: #define PMCRAID_IOASC_IOA_WAS_RESET\t\t\t0x10000001 /* <=== drivers/scsi/pmcraid.h:190:190:PMCRAID_IOASC_IOA_WAS_RESET:0 */ \n- msecs_to_jiffies: unsigned long msecs_to_jiffies(const unsigned int m) /* <=== msecs_to_jiffies */ \n{\n\t/*\n\t * Negative value, means infinite timeout:\n\t */\n\tif ((int)m < 0)\n\t\treturn MAX_JIFFY_OFFSET;\n\n#if HZ <= MSEC_PER_SEC && !(MSEC_PER_SEC % HZ)\n\t/*\n\t * HZ is equal to or smaller than 1000, and 1000 is a nice\n\t * round multiple of HZ, divide with the factor between them,\n\t * but round upwards:\n\t */\n\treturn (m + (MSEC_PER_SEC / HZ) - 1) / (MSEC_PER_SEC / HZ);\n#elif HZ > MSEC_PER_SEC && !(HZ % MSEC_PER_SEC)\n\t/*\n\t * HZ is larger than 1000, and HZ is a nice round multiple of\n\t * 1000 - simply multiply with the factor between them.\n\t *\n\t * But first make sure the multiplication result cannot\n\t * overflow:\n\t */\n\tif (m > jiffies_to_msecs(MAX_JIFFY_OFFSET))\n\t\treturn MAX_JIFFY_OFFSET;\n\n\treturn m * (HZ / MSEC_PER_SEC);\n#else\n\t/*\n\t * Generic case - multiply, round and divide. But first\n\t * check that if we are doing a net multiplication, that\n\t * we wouldn't overflow:\n\t */\n\tif (HZ > MSEC_PER_SEC && m > jiffies_to_msecs(MAX_JIFFY_OFFSET))\n\t\treturn MAX_JIFFY_OFFSET;\n\n\treturn (MSEC_TO_HZ_MUL32 * m + MSEC_TO_HZ_ADJ32)\n\t\t>> MSEC_TO_HZ_SHR32;\n#endif\n}\n- __copy_tofrom_user: __copy_tofrom_user(void *to, const void *from, unsigned long size); /* <=== __copy_tofrom_user */ \n- PMC_DEVICE_EVENT_RESET_START: #define PMC_DEVICE_EVENT_RESET_START\t\t0x11000000 /* <=== drivers/scsi/pmcraid.h:651:651:PMC_DEVICE_EVENT_RESET_START:0 */ \n- wait_for_completion_timeout: wait_for_completion_timeout(struct completion *x, unsigned long timeout) /* <=== wait_for_completion_timeout */ \n{\n\treturn wait_for_common(x, timeout, TASK_UNINTERRUPTIBLE);\n}\n- PMCRAID_IOASC_SENSE_KEY: #define PMCRAID_IOASC_SENSE_KEY(ioasc)           ((ioasc) >> 24) /* <=== drivers/scsi/pmcraid.h:168:168:PMCRAID_IOASC_SENSE_KEY:1 */ \n- spin_unlock_irqrestore: static inline void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags) /* <=== spin_unlock_irqrestore */ \n{\n\traw_spin_unlock_irqrestore(&lock->rlock, flags);\n}\n- kmap: static inline void *kmap(struct page *page) /* <=== kmap */ \n{\n\tmight_sleep();\n\treturn page_address(page);\n}\n- list_empty: static inline int list_empty(const struct list_head *head) /* <=== list_empty */ \n{\n\treturn head->next == head;\n}\n- pmcraid_get_free_cmd: static struct pmcraid_cmd *pmcraid_get_free_cmd( /* <=== pmcraid_get_free_cmd */ \n\tstruct pmcraid_instance *pinstance\n)\n{\n\tstruct pmcraid_cmd *cmd = NULL;\n\tunsigned long lock_flags;\n\n\t/* free cmd block list is protected by free_pool_lock */\n\tspin_lock_irqsave(&pinstance->free_pool_lock, lock_flags);\n\n\tif (!list_empty(&pinstance->free_cmd_pool)) {\n\t\tcmd = list_entry(pinstance->free_cmd_pool.next,\n\t\t\t\t struct pmcraid_cmd, free_list);\n\t\tlist_del(&cmd->free_list);\n\t}\n\tspin_unlock_irqrestore(&pinstance->free_pool_lock, lock_flags);\n\n\t/* Initialize the command block before giving it the caller */\n\tif (cmd != NULL)\n\t\tpmcraid_reinit_cmdblk(cmd);\n\treturn cmd;\n}\n- pmcraid_reset_bringup: static int pmcraid_reset_bringup(struct pmcraid_instance *pinstance) /* <=== pmcraid_reset_bringup */ \n{\n\tpmcraid_notify_ioastate(pinstance, PMC_DEVICE_EVENT_RESET_START);\n\n\treturn pmcraid_reset_reload(pinstance,\n\t\t\t\t    SHUTDOWN_NONE,\n\t\t\t\t    IOA_STATE_OPERATIONAL);\n}\n- raw_spin_unlock_irqrestore: #define raw_spin_unlock_irqrestore(lock, flags)\t\t\\ /* <=== include/linux/spinlock.h:226:230:raw_spin_unlock_irqrestore:2 */ \n\tdo {\t\t\t\t\t\t\t\\\n\t\ttypecheck(unsigned long, flags);\t\t\\\n\t\t_raw_spin_unlock_irqrestore(lock, flags);\t\\\n\t} while (0)\n- pmcraid_copy_sglist: static int pmcraid_copy_sglist( /* <=== pmcraid_copy_sglist */ \n\tstruct pmcraid_sglist *sglist,\n\tunsigned long buffer,\n\tu32 len,\n\tint direction\n)\n{\n\tstruct scatterlist *scatterlist;\n\tvoid *kaddr;\n\tint bsize_elem;\n\tint i;\n\tint rc = 0;\n\n\t/* Determine the actual number of bytes per element */\n\tbsize_elem = PAGE_SIZE * (1 << sglist->order);\n\n\tscatterlist = sglist->scatterlist;\n\n\tfor (i = 0; i < (len / bsize_elem); i++, buffer += bsize_elem) {\n\t\tstruct page *page = sg_page(&scatterlist[i]);\n\n\t\tkaddr = kmap(page);\n\t\tif (direction == DMA_TO_DEVICE)\n\t\t\trc = __copy_from_user(kaddr,\n\t\t\t\t\t      (void *)buffer,\n\t\t\t\t\t      bsize_elem);\n\t\telse\n\t\t\trc = __copy_to_user((void *)buffer, kaddr, bsize_elem);\n\n\t\tkunmap(page);\n\n\t\tif (rc) {\n\t\t\tpmcraid_err(\"failed to copy user data into sg list\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tscatterlist[i].length = bsize_elem;\n\t}\n\n\tif (len % bsize_elem) {\n\t\tstruct page *page = sg_page(&scatterlist[i]);\n\n\t\tkaddr = kmap(page);\n\n\t\tif (direction == DMA_TO_DEVICE)\n\t\t\trc = __copy_from_user(kaddr,\n\t\t\t\t\t      (void *)buffer,\n\t\t\t\t\t      len % bsize_elem);\n\t\telse\n\t\t\trc = __copy_to_user((void *)buffer,\n\t\t\t\t\t    kaddr,\n\t\t\t\t\t    len % bsize_elem);\n\n\t\tkunmap(page);\n\n\t\tscatterlist[i].length = len % bsize_elem;\n\t}\n\n\tif (rc) {\n\t\tpmcraid_err(\"failed to copy user data into sg list\\n\");\n\t\trc = -EFAULT;\n\t}\n\n\treturn rc;\n}\n- atomic_inc: static inline void atomic_inc(atomic_t *v) /* <=== atomic_inc */ \n{\n\t__asm__ __volatile__(\"addql #1,%0\" : \"+m\" (*v));\n}\n- PMCRAID_IOASC_GC_IOARCB_NOTFOUND: #define PMCRAID_IOASC_GC_IOARCB_NOTFOUND\t\t0x005A0000 /* <=== drivers/scsi/pmcraid.h:174:174:PMCRAID_IOASC_GC_IOARCB_NOTFOUND:0 */ \n- atomic_inc: static inline void atomic_inc(atomic_t *v) /* <=== atomic_inc */ \n{\n\tasm volatile(LOCK_PREFIX \"incl %0\"\n\t\t     : \"+m\" (v->counter));\n}\n- PMCRAID_INTERNAL_TIMEOUT: #define PMCRAID_INTERNAL_TIMEOUT\t\t(60 * HZ) /* <=== drivers/scsi/pmcraid.h:204:204:PMCRAID_INTERNAL_TIMEOUT:0 */ \n- pmcraid_abort_cmd: static struct pmcraid_cmd *pmcraid_abort_cmd(struct pmcraid_cmd *cmd) /* <=== pmcraid_abort_cmd */ \n{\n\tstruct pmcraid_cmd *cancel_cmd;\n\tstruct pmcraid_instance *pinstance;\n\tstruct pmcraid_resource_entry *res;\n\n\tpinstance = (struct pmcraid_instance *)cmd->drv_inst;\n\tres = cmd->scsi_cmd->device->hostdata;\n\n\tcancel_cmd = pmcraid_get_free_cmd(pinstance);\n\n\tif (cancel_cmd == NULL) {\n\t\tpmcraid_err(\"%s: no cmd blocks are available\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tpmcraid_prepare_cancel_cmd(cancel_cmd, cmd);\n\n\tpmcraid_info(\"aborting command CDB[0]= %x with index = %d\\n\",\n\t\tcmd->ioa_cb->ioarcb.cdb[0],\n\t\tcmd->ioa_cb->ioarcb.response_handle >> 2);\n\n\tinit_completion(&cancel_cmd->wait_for_completion);\n\tcancel_cmd->completion_req = 1;\n\n\tpmcraid_info(\"command (%d) CDB[0] = %x for %x\\n\",\n\t\tle32_to_cpu(cancel_cmd->ioa_cb->ioarcb.response_handle) >> 2,\n\t\tcancel_cmd->ioa_cb->ioarcb.cdb[0],\n\t\tle32_to_cpu(cancel_cmd->ioa_cb->ioarcb.resource_handle));\n\n\tpmcraid_send_cmd(cancel_cmd,\n\t\t\t pmcraid_internal_done,\n\t\t\t PMCRAID_INTERNAL_TIMEOUT,\n\t\t\t pmcraid_timeout_handler);\n\treturn cancel_cmd;\n}\n- kmalloc: static inline void *kmalloc(size_t s, gfp_t gfp) /* <=== kmalloc */ \n{\n\treturn malloc(s);\n}\n- SHUTDOWN_NONE: #define SHUTDOWN_NONE               0x0 /* <=== drivers/scsi/pmcraid.h:802:802:SHUTDOWN_NONE:0 */ \n- kunmap: void kunmap(struct page *page) /* <=== kunmap */ \n{\n\tBUG_ON(in_interrupt());\n\tif (!PageHighMem(page))\n\t\treturn;\n\tkunmap_high(page);\n}\n- pmcraid_send_cmd: static void pmcraid_send_cmd( /* <=== pmcraid_send_cmd */ \n\tstruct pmcraid_cmd *cmd,\n\tvoid (*cmd_done) (struct pmcraid_cmd *),\n\tunsigned long timeout,\n\tvoid (*timeout_func) (struct pmcraid_cmd *)\n)\n{\n\t/* initialize done function */\n\tcmd->cmd_done = cmd_done;\n\n\tif (timeout_func) {\n\t\t/* setup timeout handler */\n\t\tcmd->timer.data = (unsigned long)cmd;\n\t\tcmd->timer.expires = jiffies + timeout;\n\t\tcmd->timer.function = (void (*)(unsigned long))timeout_func;\n\t\tadd_timer(&cmd->timer);\n\t}\n\n\t/* fire the command to IOA */\n\t_pmcraid_fire_command(cmd);\n}\n- access_ok: static inline int access_ok(int type, const void *addr, unsigned long size) /* <=== access_ok */ \n{\n\tunsigned long val = (unsigned long)addr;\n\n\treturn ((val >= memory_start) && ((val + size) < memory_end));\n}\n- atomic_inc: static inline void atomic_inc(atomic_t *v) /* <=== atomic_inc */ \n{\n\tatomic_add_return(1, v);\n}\n- kmap: void *kmap(struct page *page) /* <=== kmap */ \n{\n\tvoid *kva;\n\tunsigned long flags;\n\tpte_t *ptep;\n\n\tmight_sleep();\n\tif (!PageHighMem(page))\n\t\treturn page_address(page);\n\tkva = kmap_high(page);\n\n\t/*\n\t * Rewrite the PTE under the lock.  This ensures that the page\n\t * is not currently migrating.\n\t */\n\tptep = kmap_get_pte((unsigned long)kva);\n\tflags = homecache_kpte_lock();\n\tset_pte_at(&init_mm, kva, ptep, mk_pte(page, page_to_kpgprot(page)));\n\thomecache_kpte_unlock(flags);\n\n\treturn kva;\n}\n- copy_to_user: static inline unsigned long /* <=== copy_to_user */ \ncopy_to_user(void *to, const void *from, unsigned long len)\n{\n\tunsigned long over;\n\n\tif (access_ok(VERIFY_WRITE, to, len))\n\t\treturn __copy_tofrom_user(to, from, len);\n\n\tif ((unsigned long)to < TASK_SIZE) {\n\t\tover = (unsigned long)to + len - TASK_SIZE;\n\t\treturn __copy_tofrom_user(to, from, len - over) + over;\n\t}\n\treturn len;\n}\n- PMCRAID_ADD_CMD_PARAM_LEN: #define PMCRAID_ADD_CMD_PARAM_LEN\t\t48 /* <=== drivers/scsi/pmcraid.h:99:99:PMCRAID_ADD_CMD_PARAM_LEN:0 */ \n- kmap: void *kmap(struct page *page) /* <=== kmap */ \n{\n\tvoid *addr;\n\n\tmight_sleep();\n\tif (!PageHighMem(page))\n\t\treturn page_address(page);\n\taddr = kmap_high(page);\n\tflush_tlb_one((unsigned long)addr);\n\n\treturn addr;\n}\n- kunmap: void kunmap(struct page *page) /* <=== kunmap */ \n{\n\tif (in_interrupt())\n\t\tBUG();\n\tif (!PageHighMem(page))\n\t\treturn;\n\tkunmap_high(page);\n}\n- pmcraid_release_passthrough_ioadls: static void pmcraid_release_passthrough_ioadls( /* <=== pmcraid_release_passthrough_ioadls */ \n\tstruct pmcraid_cmd *cmd,\n\tint buflen,\n\tint direction\n)\n{\n\tstruct pmcraid_sglist *sglist = cmd->sglist;\n\n\tif (buflen > 0) {\n\t\tpci_unmap_sg(cmd->drv_inst->pdev,\n\t\t\t     sglist->scatterlist,\n\t\t\t     sglist->num_sg,\n\t\t\t     direction);\n\t\tpmcraid_free_sglist(sglist);\n\t\tcmd->sglist = NULL;\n\t}\n}\n- pmcraid_info: #define pmcraid_info(...) \\ /* <=== drivers/scsi/pmcraid.h:1002:1004:pmcraid_info:1 */ \n\tif (pmcraid_debug_log) \\\n\t\tprintk(KERN_INFO \"MaxRAID: \"__VA_ARGS__)\n- wait_for_completion: extern void wait_for_completion(struct completion *); /* <=== wait_for_completion */ \n- jiffies_to_msecs: inline unsigned int jiffies_to_msecs(const unsigned long j) /* <=== jiffies_to_msecs */ \n{\n#if HZ <= MSEC_PER_SEC && !(MSEC_PER_SEC % HZ)\n\treturn (MSEC_PER_SEC / HZ) * j;\n#elif HZ > MSEC_PER_SEC && !(HZ % MSEC_PER_SEC)\n\treturn (j + (HZ / MSEC_PER_SEC) - 1)/(HZ / MSEC_PER_SEC);\n#else\n# if BITS_PER_LONG == 32\n\treturn (HZ_TO_MSEC_MUL32 * j) >> HZ_TO_MSEC_SHR32;\n# else\n\treturn (j * HZ_TO_MSEC_NUM) / HZ_TO_MSEC_DEN;\n# endif\n#endif\n}\n- pmcraid_free_sglist: static void pmcraid_free_sglist(struct pmcraid_sglist *sglist) /* <=== pmcraid_free_sglist */ \n{\n\tint i;\n\n\tfor (i = 0; i < sglist->num_sg; i++)\n\t\t__free_pages(sg_page(&(sglist->scatterlist[i])),\n\t\t\t     sglist->order);\n\n\tkfree(sglist);\n}\n- pmcraid_notify_ioastate: static void pmcraid_notify_ioastate(struct pmcraid_instance *pinstance, u32 evt) /* <=== pmcraid_notify_ioastate */ \n{\n\tpinstance->scn.ioa_state = evt;\n\tpmcraid_notify_aen(pinstance,\n\t\t\t  &pinstance->scn.msg,\n\t\t\t  sizeof(u32));\n}\n- _pmcraid_fire_command: static void _pmcraid_fire_command(struct pmcraid_cmd *cmd) /* <=== _pmcraid_fire_command */ \n{\n\tstruct pmcraid_instance *pinstance = cmd->drv_inst;\n\tunsigned long lock_flags;\n\n\t/* Add this command block to pending cmd pool. We do this prior to\n\t * writting IOARCB to ioarrin because IOA might complete the command\n\t * by the time we are about to add it to the list. Response handler\n\t * (isr/tasklet) looks for cmd block in the pending pending list.\n\t */\n\tspin_lock_irqsave(&pinstance->pending_pool_lock, lock_flags);\n\tlist_add_tail(&cmd->free_list, &pinstance->pending_cmd_pool);\n\tspin_unlock_irqrestore(&pinstance->pending_pool_lock, lock_flags);\n\tatomic_inc(&pinstance->outstanding_cmds);\n\n\t/* driver writes lower 32-bit value of IOARCB address only */\n\tmb();\n\tiowrite32(le32_to_cpu(cmd->ioa_cb->ioarcb.ioarcb_bus_addr),\n\t\t  pinstance->ioarrin);\n}\n- TRANSFER_DIR_WRITE: #define TRANSFER_DIR_WRITE            PMC_BIT8(0) /* <=== drivers/scsi/pmcraid.h:273:273:TRANSFER_DIR_WRITE:0 */ \n- copy_to_user: static inline unsigned long /* <=== copy_to_user */ \ncopy_to_user(void *to, const void *from, unsigned long n)\n{\n\tunsigned long over;\n\n\tif (access_ok(VERIFY_WRITE, to, n))\n\t\treturn __copy_tofrom_user(to, from, n);\n\tif ((unsigned long)to < TASK_SIZE) {\n\t\tover = (unsigned long)to + n - TASK_SIZE;\n\t\treturn __copy_tofrom_user(to, from, n - over) + over;\n\t}\n\treturn n;\n}\n- list_add_tail: static inline void list_add_tail(struct list_head *new, struct list_head *head) /* <=== list_add_tail */ \n{\n\t__list_add(new, head->prev, head);\n}\n- IOA_STATE_OPERATIONAL: #define IOA_STATE_OPERATIONAL       0x0 /* <=== drivers/scsi/pmcraid.h:786:786:IOA_STATE_OPERATIONAL:0 */ \n- access_ok: #define access_ok(type, addr, size) \\ /* <=== arch/openrisc/include/asm/uaccess.h:66:67:access_ok:3 */ \n\t__range_ok((unsigned long)addr, (unsigned long)size)\n- sg_page: static inline struct page *sg_page(struct scatterlist *sg) /* <=== sg_page */ \n{\n#ifdef CONFIG_DEBUG_SG\n\tBUG_ON(sg->sg_magic != SG_MAGIC);\n\tBUG_ON(sg_is_chain(sg));\n#endif\n\treturn (struct page *)((sg)->page_link & ~0x3);\n}\n- list_del: static inline void list_del(struct list_head *entry) /* <=== list_del */ \n{\n\t__list_del(entry->prev, entry->next);\n\tentry->next = LIST_POISON1;\n\tentry->prev = LIST_POISON2;\n}\n- init_completion: static inline void init_completion(struct completion *x) /* <=== init_completion */ \n{\n\tx->done = 0;\n\tinit_waitqueue_head(&x->wait);\n}\n- kunmap: static inline void kunmap(struct page *page) /* <=== kunmap */ \n{\n}\n- pmcraid_reinit_cmdblk: static void pmcraid_reinit_cmdblk(struct pmcraid_cmd *cmd) /* <=== pmcraid_reinit_cmdblk */ \n{\n\tpmcraid_init_cmdblk(cmd, -1);\n}\n\nType Definitions:\n- pmcraid_ioasa: struct pmcraid_ioasa {\n\t__le32 ioasc;\n\t__le16 returned_status_length;\n\t__le16 available_status_length;\n\t__le32 residual_data_length;\n\t__le32 ilid;\n\t__le32 fd_ioasc;\n\t__le32 fd_res_address;\n\t__le32 fd_res_handle;\n\t__le32 reserved;\n\n\t/* resource specific sense information */\n\tunion {\n\t\tstruct pmcraid_ioasa_vset vset;\n\t} u;\n\n\t/* IOA autosense data */\n\t__le16 auto_sense_length;\n\t__le16 error_data_length;\n\t__u8  sense_data[PMCRAID_SENSE_DATA_LEN];\n} __attribute__((packed, aligned(4)))\n- pmcraid_cmd: struct pmcraid_cmd {\n\n\t/* Ptr and bus address of DMA.able control block for this command */\n\tstruct pmcraid_control_block *ioa_cb;\n\tdma_addr_t ioa_cb_bus_addr;\n\tdma_addr_t dma_handle;\n\n\t/* pointer to mid layer structure of SCSI commands */\n\tstruct scsi_cmnd *scsi_cmd;\n\n\tstruct list_head free_list;\n\tstruct completion wait_for_completion;\n\tstruct timer_list timer;\t/* needed for internal commands */\n\tu32 timeout;\t\t\t/* current timeout value */\n\tu32 index;\t\t\t/* index into the command list */\n\tu8 completion_req;\t\t/* for handling internal commands */\n\tu8 release;\t\t\t/* for handling completions */\n\n\tvoid (*cmd_done) (struct pmcraid_cmd *);\n\tstruct pmcraid_instance *drv_inst;\n\n\tstruct pmcraid_sglist *sglist; /* used for passthrough IOCTLs */\n\n\t/* scratch used */\n\tunion {\n\t\t/* during reset sequence */\n\t\tunsigned long time_left;\n\t\tstruct pmcraid_resource_entry *res;\n\t\tint hrrq_index;\n\n\t\t/* used during IO command error handling. Sense buffer\n\t\t * for REQUEST SENSE command if firmware is not sending\n\t\t * auto sense data\n\t\t */\n\t\tstruct  {\n\t\t\tu8 *sense_buffer;\n\t\t\tdma_addr_t sense_buffer_dma;\n\t\t};\n\t};\n}\n- pmcraid_instance: struct pmcraid_instance {\n\t/* Array of allowed-to-be-exposed resources, initialized from\n\t * Configutation Table, later updated with CCNs\n\t */\n\tstruct pmcraid_resource_entry *res_entries;\n\n\tstruct list_head free_res_q;\t/* res_entries lists for easy lookup */\n\tstruct list_head used_res_q;\t/* List of to be exposed resources */\n\tspinlock_t resource_lock;\t/* spinlock to protect resource list */\n\n\tvoid __iomem *mapped_dma_addr;\n\tvoid __iomem *ioa_status;\t/* Iomapped IOA status register */\n\tvoid __iomem *mailbox;\t\t/* Iomapped mailbox register */\n\tvoid __iomem *ioarrin;\t\t/* IOmapped IOARR IN register */\n\n\tstruct pmcraid_interrupts int_regs;\n\tstruct pmcraid_chip_details *chip_cfg;\n\n\t/* HostRCBs needed for HCAM */\n\tstruct pmcraid_hostrcb ldn;\n\tstruct pmcraid_hostrcb ccn;\n\tstruct pmcraid_state_msg scn;\t/* controller state change msg */\n\n\n\t/* Bus address of start of HRRQ */\n\tdma_addr_t hrrq_start_bus_addr[PMCRAID_NUM_MSIX_VECTORS];\n\n\t/* Pointer to 1st entry of HRRQ */\n\t__be32 *hrrq_start[PMCRAID_NUM_MSIX_VECTORS];\n\n\t/* Pointer to last entry of HRRQ */\n\t__be32 *hrrq_end[PMCRAID_NUM_MSIX_VECTORS];\n\n\t/* Pointer to current pointer of hrrq */\n\t__be32 *hrrq_curr[PMCRAID_NUM_MSIX_VECTORS];\n\n\t/* Lock for HRRQ access */\n\tspinlock_t hrrq_lock[PMCRAID_NUM_MSIX_VECTORS];\n\n\tstruct pmcraid_inquiry_data *inq_data;\n\tdma_addr_t  inq_data_baddr;\n\n\tstruct pmcraid_timestamp_data *timestamp_data;\n\tdma_addr_t  timestamp_data_baddr;\n\n\t/* size of configuration table entry, varies based on the firmware */\n\tu32\tconfig_table_entry_size;\n\n\t/* Expected toggle bit at host */\n\tu8 host_toggle_bit[PMCRAID_NUM_MSIX_VECTORS];\n\n\n\t/* Wait Q for  threads to wait for Reset IOA completion */\n\twait_queue_head_t reset_wait_q;\n\tstruct pmcraid_cmd *reset_cmd;\n\n\t/* structures for supporting SIGIO based AEN. */\n\tstruct fasync_struct *aen_queue;\n\tstruct mutex aen_queue_lock;\t/* lock for aen subscribers list */\n\tstruct cdev cdev;\n\n\tstruct Scsi_Host *host;\t/* mid layer interface structure handle */\n\tstruct pci_dev *pdev;\t/* PCI device structure handle */\n\n\t/* No of Reset IOA retries . IOA marked dead if threshold exceeds */\n\tu8 ioa_reset_attempts;\n#define PMCRAID_RESET_ATTEMPTS 3\n\n\tu8  current_log_level;\t/* default level for logging IOASC errors */\n\n\tu8  num_hrrq;\t\t/* Number of interrupt vectors allocated */\n\tu8  interrupt_mode;\t/* current interrupt mode legacy or msix */\n\tdev_t dev;\t\t/* Major-Minor numbers for Char device */\n\n\t/* Used as ISR handler argument */\n\tstruct pmcraid_isr_param hrrq_vector[PMCRAID_NUM_MSIX_VECTORS];\n\n\t/* Message id as filled in last fired IOARCB, used to identify HRRQ */\n\tatomic_t last_message_id;\n\n\t/* configuration table */\n\tstruct pmcraid_config_table *cfg_table;\n\tdma_addr_t cfg_table_bus_addr;\n\n\t/* structures related to command blocks */\n\tstruct kmem_cache *cmd_cachep;\t\t/* cache for cmd blocks */\n\tstruct pci_pool *control_pool;\t\t/* pool for control blocks */\n\tchar   cmd_pool_name[64];\t\t/* name of cmd cache */\n\tchar   ctl_pool_name[64];\t\t/* name of control cache */\n\n\tstruct pmcraid_cmd *cmd_list[PMCRAID_MAX_CMD];\n\n\tstruct list_head free_cmd_pool;\n\tstruct list_head pending_cmd_pool;\n\tspinlock_t free_pool_lock;\t\t/* free pool lock */\n\tspinlock_t pending_pool_lock;\t\t/* pending pool lock */\n\n\t/* Tasklet to handle deferred processing */\n\tstruct tasklet_struct isr_tasklet[PMCRAID_NUM_MSIX_VECTORS];\n\n\t/* Work-queue (Shared) for deferred reset processing */\n\tstruct work_struct worker_q;\n\n\t/* No of IO commands pending with FW */\n\tatomic_t outstanding_cmds;\n\n\t/* should add/delete resources to mid-layer now ?*/\n\tatomic_t expose_resources;\n\n\n\n\tu32 ioa_state:4;\t/* For IOA Reset sequence FSM */\n#define IOA_STATE_OPERATIONAL       0x0\n#define IOA_STATE_UNKNOWN           0x1\n#define IOA_STATE_DEAD              0x2\n#define IOA_STATE_IN_SOFT_RESET     0x3\n#define IOA_STATE_IN_HARD_RESET     0x4\n#define IOA_STATE_IN_RESET_ALERT    0x5\n#define IOA_STATE_IN_BRINGDOWN      0x6\n#define IOA_STATE_IN_BRINGUP        0x7\n\n\tu32 ioa_reset_in_progress:1; /* true if IOA reset is in progress */\n\tu32 ioa_hard_reset:1;\t/* TRUE if Hard Reset is needed */\n\tu32 ioa_unit_check:1;\t/* Indicates Unit Check condition */\n\tu32 ioa_bringdown:1;\t/* whether IOA needs to be brought down */\n\tu32 force_ioa_reset:1;  /* force adapter reset ? */\n\tu32 reinit_cfg_table:1; /* reinit config table due to lost CCN */\n\tu32 ioa_shutdown_type:2;/* shutdown type used during reset */\n#define SHUTDOWN_NONE               0x0\n#define SHUTDOWN_NORMAL             0x1\n#define SHUTDOWN_ABBREV             0x2\n\tu32 timestamp_error:1; /* indicate set timestamp for out of sync */\n\n}\n- pmcraid_passthrough_ioctl_buffer: struct pmcraid_passthrough_ioctl_buffer {\n\tstruct pmcraid_ioctl_header ioctl_header;\n\tstruct pmcraid_ioarcb ioarcb;\n\tstruct pmcraid_ioasa  ioasa;\n\tu8  request_buffer[1];\n} __attribute__ ((packed))\n\nImports:\n- #include <scsi/scsi_cmnd.h>\n- #include \"pmcraid.h\"\n- #include <linux/fs.h>\n- #include <asm/processor.h>\n- #include <linux/version.h>\n- #include <linux/module.h>\n- #include <linux/init.h>\n- #include <linux/moduleparam.h>\n- #include <scsi/scsi_host.h>\n- #include <linux/spinlock.h>\n- #include <linux/errno.h>\n- #include <asm/irq.h>\n- #include <linux/firmware.h>\n- #include <linux/sched.h>\n- #include <linux/slab.h>\n- #include <linux/wait.h>\n- #include <scsi/scsi_device.h>\n- #include <linux/types.h>\n- #include <scsi/scsi_tcq.h>\n- #include <linux/hdreg.h>\n- #include <linux/io.h>\n- #include <linux/blkdev.h>\n- #include <linux/interrupt.h>\n- #include <scsi/scsi_eh.h>\n- #include <linux/libata.h>\n- #include <scsi/scsi.h>\n- #include <linux/kernel.h>\n- #include <linux/pci.h>\n- #include <linux/delay.h>\n- #include <linux/mutex.h>\n- #include <scsi/scsicam.h>\n- #include <linux/ioport.h>",
    "commit_msg": "[SCSI] pmcraid: reject negative request size\n\nThere's a code path in pmcraid that can be reached via device ioctl that\ncauses all sorts of ugliness, including heap corruption or triggering the\nOOM killer due to consecutive allocation of large numbers of pages.\n\nFirst, the user can call pmcraid_chr_ioctl(), with a type\nPMCRAID_PASSTHROUGH_IOCTL.  This calls through to\npmcraid_ioctl_passthrough().  Next, a pmcraid_passthrough_ioctl_buffer\nis copied in, and the request_size variable is set to\nbuffer->ioarcb.data_transfer_length, which is an arbitrary 32-bit\nsigned value provided by the user.  If a negative value is provided\nhere, bad things can happen.  For example,\npmcraid_build_passthrough_ioadls() is called with this request_size,\nwhich immediately calls pmcraid_alloc_sglist() with a negative size.\nThe resulting math on allocating a scatter list can result in an\noverflow in the kzalloc() call (if num_elem is 0, the sglist will be\nsmaller than expected), or if num_elem is unexpectedly large the\nsubsequent loop will call alloc_pages() repeatedly, a high number of\npages will be allocated and the OOM killer might be invoked.\n\nIt looks like preventing this value from being negative in\npmcraid_ioctl_passthrough() would be sufficient.\n\nSigned-off-by: Dan Rosenberg <drosenberg@vsecurity.com>\nCc: <stable@kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: James Bottomley <JBottomley@Parallels.com>",
    "cve_desc": "[{'lang': 'en', 'value': 'Integer signedness error in the pmcraid_ioctl_passthrough function in drivers/scsi/pmcraid.c in the Linux kernel before 3.1 might allow local users to cause a denial of service (memory consumption or memory corruption) via a negative size value in an ioctl call. NOTE: this may be a vulnerability only in unusual environments that provide a privileged program for obtaining the required file descriptor.'}]",
    "year": 2011,
    "filename": "pmcraid.c",
    "commit_url": "\"https://github.com/torvalds/linux/commit/b5b515445f4f5a905c5dd27e6e682868ccd6c09d\""
  },
  {
    "repository": "torvalds/linux",
    "cve_id": "CVE-2011-3191",
    "cwe_list": [
      "CWE-119,CWE-189"
    ],
    "commit_hash": "9438fabb73eb48055b58b89fc51e0bc4db22fabd",
    "short_hash": "9438fabb",
    "vulnerableMethods_before": [
      {
        "filename": "fs/cifs/cifssmb.c",
        "method_name": "CIFSFindNext",
        "raw_code": "int CIFSFindNext(const int xid, struct cifs_tcon *tcon, /* <=== CIFSFindNext */ \n\t\t __u16 searchHandle, struct cifs_search_info *psrch_inf)\n{\n\tTRANSACTION2_FNEXT_REQ *pSMB = NULL;\n\tTRANSACTION2_FNEXT_RSP *pSMBr = NULL;\n\tT2_FNEXT_RSP_PARMS *parms;\n\tchar *response_data;\n\tint rc = 0;\n\tint bytes_returned, name_len;\n\t__u16 params, byte_count;\n\n\tcFYI(1, \"In FindNext\");\n\n\tif (psrch_inf->endOfSearch)\n\t\treturn -ENOENT;\n\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 14; /* includes 2 bytes of null string, converted to LE below*/\n\tbyte_count = 0;\n\tpSMB->TotalDataCount = 0;       /* no EAs */\n\tpSMB->MaxParameterCount = cpu_to_le16(8);\n\tpSMB->MaxDataCount =\n\t\tcpu_to_le16((tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE) &\n\t\t\t\t0xFFFFFF00);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset =  cpu_to_le16(\n\t      offsetof(struct smb_com_transaction2_fnext_req,SearchHandle) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_FIND_NEXT);\n\tpSMB->SearchHandle = searchHandle;      /* always kept as le */\n\tpSMB->SearchCount =\n\t\tcpu_to_le16(CIFSMaxBufSize / sizeof(FILE_UNIX_INFO));\n\tpSMB->InformationLevel = cpu_to_le16(psrch_inf->info_level);\n\tpSMB->ResumeKey = psrch_inf->resume_key;\n\tpSMB->SearchFlags =\n\t      cpu_to_le16(CIFS_SEARCH_CLOSE_AT_END | CIFS_SEARCH_RETURN_RESUME);\n\n\tname_len = psrch_inf->resume_name_len;\n\tparams += name_len;\n\tif (name_len < PATH_MAX) {\n\t\tmemcpy(pSMB->ResumeFileName, psrch_inf->presume_name, name_len);\n\t\tbyte_count += name_len;\n\t\t/* 14 byte parm len above enough for 2 byte null terminator */\n\t\tpSMB->ResumeFileName[name_len] = 0;\n\t\tpSMB->ResumeFileName[name_len+1] = 0;\n\t} else {\n\t\trc = -EINVAL;\n\t\tgoto FNext2_err_exit;\n\t}\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->num_fnext);\n\tif (rc) {\n\t\tif (rc == -EBADF) {\n\t\t\tpsrch_inf->endOfSearch = true;\n\t\t\tcifs_buf_release(pSMB);\n\t\t\trc = 0; /* search probably was closed at end of search*/\n\t\t} else\n\t\t\tcFYI(1, \"FindNext returned = %d\", rc);\n\t} else {                /* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc == 0) {\n\t\t\tunsigned int lnoff;\n\n\t\t\t/* BB fixme add lock for file (srch_info) struct here */\n\t\t\tif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\n\t\t\t\tpsrch_inf->unicode = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->unicode = false;\n\t\t\tresponse_data = (char *) &pSMBr->hdr.Protocol +\n\t\t\t       le16_to_cpu(pSMBr->t2.ParameterOffset);\n\t\t\tparms = (T2_FNEXT_RSP_PARMS *)response_data;\n\t\t\tresponse_data = (char *)&pSMBr->hdr.Protocol +\n\t\t\t\tle16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tif (psrch_inf->smallBuf)\n\t\t\t\tcifs_small_buf_release(\n\t\t\t\t\tpsrch_inf->ntwrk_buf_start);\n\t\t\telse\n\t\t\t\tcifs_buf_release(psrch_inf->ntwrk_buf_start);\n\t\t\tpsrch_inf->srch_entries_start = response_data;\n\t\t\tpsrch_inf->ntwrk_buf_start = (char *)pSMB;\n\t\t\tpsrch_inf->smallBuf = 0;\n\t\t\tif (parms->EndofSearch)\n\t\t\t\tpsrch_inf->endOfSearch = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->endOfSearch = false;\n\t\t\tpsrch_inf->entries_in_buffer =\n\t\t\t\t\t\tle16_to_cpu(parms->SearchCount);\n\t\t\tpsrch_inf->index_of_last_entry +=\n\t\t\t\tpsrch_inf->entries_in_buffer;\n\t\t\tlnoff = le16_to_cpu(parms->LastNameOffset);\n\t\t\tif (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE <\n\t\t\t      lnoff) {\n\t\t\t\tcERROR(1, \"ignoring corrupt resume name\");\n\t\t\t\tpsrch_inf->last_entry = NULL;\n\t\t\t\treturn rc;\n\t\t\t} else\n\t\t\t\tpsrch_inf->last_entry =\n\t\t\t\t\tpsrch_inf->srch_entries_start + lnoff;\n\n/*  cFYI(1, \"fnxt2 entries in buf %d index_of_last %d\",\n\t    psrch_inf->entries_in_buffer, psrch_inf->index_of_last_entry); */\n\n\t\t\t/* BB fixme add unlock here */\n\t\t}\n\n\t}\n\n\t/* BB On error, should we leave previous search buf (and count and\n\tlast entry fields) intact or free the previous one? */\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\tsince file handle passed in no longer valid */\nFNext2_err_exit:\n\tif (rc != 0)\n\t\tcifs_buf_release(pSMB);\n\treturn rc;\n}",
        "start_line": 4074
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "fs/cifs/cifssmb.c",
        "method_name": "CIFSFindNext",
        "raw_code": "int CIFSFindNext(const int xid, struct cifs_tcon *tcon, /* <=== CIFSFindNext */ \n\t\t __u16 searchHandle, struct cifs_search_info *psrch_inf)\n{\n\tTRANSACTION2_FNEXT_REQ *pSMB = NULL;\n\tTRANSACTION2_FNEXT_RSP *pSMBr = NULL;\n\tT2_FNEXT_RSP_PARMS *parms;\n\tchar *response_data;\n\tint rc = 0;\n\tint bytes_returned;\n\tunsigned int name_len;\n\t__u16 params, byte_count;\n\n\tcFYI(1, \"In FindNext\");\n\n\tif (psrch_inf->endOfSearch)\n\t\treturn -ENOENT;\n\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t(void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 14; /* includes 2 bytes of null string, converted to LE below*/\n\tbyte_count = 0;\n\tpSMB->TotalDataCount = 0;       /* no EAs */\n\tpSMB->MaxParameterCount = cpu_to_le16(8);\n\tpSMB->MaxDataCount =\n\t\tcpu_to_le16((tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE) &\n\t\t\t\t0xFFFFFF00);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tpSMB->ParameterOffset =  cpu_to_le16(\n\t      offsetof(struct smb_com_transaction2_fnext_req,SearchHandle) - 4);\n\tpSMB->DataCount = 0;\n\tpSMB->DataOffset = 0;\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_FIND_NEXT);\n\tpSMB->SearchHandle = searchHandle;      /* always kept as le */\n\tpSMB->SearchCount =\n\t\tcpu_to_le16(CIFSMaxBufSize / sizeof(FILE_UNIX_INFO));\n\tpSMB->InformationLevel = cpu_to_le16(psrch_inf->info_level);\n\tpSMB->ResumeKey = psrch_inf->resume_key;\n\tpSMB->SearchFlags =\n\t      cpu_to_le16(CIFS_SEARCH_CLOSE_AT_END | CIFS_SEARCH_RETURN_RESUME);\n\n\tname_len = psrch_inf->resume_name_len;\n\tparams += name_len;\n\tif (name_len < PATH_MAX) {\n\t\tmemcpy(pSMB->ResumeFileName, psrch_inf->presume_name, name_len);\n\t\tbyte_count += name_len;\n\t\t/* 14 byte parm len above enough for 2 byte null terminator */\n\t\tpSMB->ResumeFileName[name_len] = 0;\n\t\tpSMB->ResumeFileName[name_len+1] = 0;\n\t} else {\n\t\trc = -EINVAL;\n\t\tgoto FNext2_err_exit;\n\t}\n\tbyte_count = params + 1 /* pad */ ;\n\tpSMB->TotalParameterCount = cpu_to_le16(params);\n\tpSMB->ParameterCount = pSMB->TotalParameterCount;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t(struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tcifs_stats_inc(&tcon->num_fnext);\n\tif (rc) {\n\t\tif (rc == -EBADF) {\n\t\t\tpsrch_inf->endOfSearch = true;\n\t\t\tcifs_buf_release(pSMB);\n\t\t\trc = 0; /* search probably was closed at end of search*/\n\t\t} else\n\t\t\tcFYI(1, \"FindNext returned = %d\", rc);\n\t} else {                /* decode response */\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc == 0) {\n\t\t\tunsigned int lnoff;\n\n\t\t\t/* BB fixme add lock for file (srch_info) struct here */\n\t\t\tif (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)\n\t\t\t\tpsrch_inf->unicode = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->unicode = false;\n\t\t\tresponse_data = (char *) &pSMBr->hdr.Protocol +\n\t\t\t       le16_to_cpu(pSMBr->t2.ParameterOffset);\n\t\t\tparms = (T2_FNEXT_RSP_PARMS *)response_data;\n\t\t\tresponse_data = (char *)&pSMBr->hdr.Protocol +\n\t\t\t\tle16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tif (psrch_inf->smallBuf)\n\t\t\t\tcifs_small_buf_release(\n\t\t\t\t\tpsrch_inf->ntwrk_buf_start);\n\t\t\telse\n\t\t\t\tcifs_buf_release(psrch_inf->ntwrk_buf_start);\n\t\t\tpsrch_inf->srch_entries_start = response_data;\n\t\t\tpsrch_inf->ntwrk_buf_start = (char *)pSMB;\n\t\t\tpsrch_inf->smallBuf = 0;\n\t\t\tif (parms->EndofSearch)\n\t\t\t\tpsrch_inf->endOfSearch = true;\n\t\t\telse\n\t\t\t\tpsrch_inf->endOfSearch = false;\n\t\t\tpsrch_inf->entries_in_buffer =\n\t\t\t\t\t\tle16_to_cpu(parms->SearchCount);\n\t\t\tpsrch_inf->index_of_last_entry +=\n\t\t\t\tpsrch_inf->entries_in_buffer;\n\t\t\tlnoff = le16_to_cpu(parms->LastNameOffset);\n\t\t\tif (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE <\n\t\t\t      lnoff) {\n\t\t\t\tcERROR(1, \"ignoring corrupt resume name\");\n\t\t\t\tpsrch_inf->last_entry = NULL;\n\t\t\t\treturn rc;\n\t\t\t} else\n\t\t\t\tpsrch_inf->last_entry =\n\t\t\t\t\tpsrch_inf->srch_entries_start + lnoff;\n\n/*  cFYI(1, \"fnxt2 entries in buf %d index_of_last %d\",\n\t    psrch_inf->entries_in_buffer, psrch_inf->index_of_last_entry); */\n\n\t\t\t/* BB fixme add unlock here */\n\t\t}\n\n\t}\n\n\t/* BB On error, should we leave previous search buf (and count and\n\tlast entry fields) intact or free the previous one? */\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\tsince file handle passed in no longer valid */\nFNext2_err_exit:\n\tif (rc != 0)\n\t\tcifs_buf_release(pSMB);\n\treturn rc;\n}",
        "start_line": 4074
      }
    ],
    "code_context": "Imports:\n- #include <linux/posix_acl_xattr.h>\n- #include <linux/pagemap.h>\n- #include \"cifspdu.h\"\n- #include \"cifsglob.h\"\n- #include \"cifsacl.h\"\n- #include <linux/vfs.h>\n- #include <linux/slab.h>\n- #include \"cifsproto.h\"\n- #include \"cifs_unicode.h\"\n- #include <linux/kernel.h>\n- #include <linux/fs.h>\n- #include \"cifs_debug.h\"\n- #include <asm/uaccess.h>",
    "commit_msg": "cifs: fix possible memory corruption in CIFSFindNext\n\nThe name_len variable in CIFSFindNext is a signed int that gets set to\nthe resume_name_len in the cifs_search_info. The resume_name_len however\nis unsigned and for some infolevels is populated directly from a 32 bit\nvalue sent by the server.\n\nIf the server sends a very large value for this, then that value could\nlook negative when converted to a signed int. That would make that\nvalue pass the PATH_MAX check later in CIFSFindNext. The name_len would\nthen be used as a length value for a memcpy. It would then be treated\nas unsigned again, and the memcpy scribbles over a ton of memory.\n\nFix this by making the name_len an unsigned value in CIFSFindNext.\n\nCc: <stable@kernel.org>\nReported-by: Darren Lavender <dcl@hppine99.gbr.hp.com>\nSigned-off-by: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Steve French <sfrench@us.ibm.com>",
    "cve_desc": "[{'lang': 'en', 'value': 'Integer signedness error in the CIFSFindNext function in fs/cifs/cifssmb.c in the Linux kernel before 3.1 allows remote CIFS servers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a large length value in a response to a read request for a directory.'}]",
    "year": 2011,
    "filename": "cifssmb.c",
    "commit_url": "\"https://github.com/torvalds/linux/commit/9438fabb73eb48055b58b89fc51e0bc4db22fabd\""
  },
  {
    "repository": "rsyslog/rsyslog",
    "cve_id": "CVE-2011-3200",
    "cwe_list": [
      "CWE-119"
    ],
    "commit_hash": "1ca6cc236d1dabf1633238b873fb1c057e52f95e",
    "short_hash": "1ca6cc23",
    "vulnerableMethods_before": [
      {
        "filename": "tools/syslogd.c",
        "method_name": "parseLegacySyslogMsg",
        "raw_code": "int parseLegacySyslogMsg(msg_t *pMsg, int flags) /* <=== parseLegacySyslogMsg */ \n{\n\tuchar *p2parse;\n\tint lenMsg;\n\tint i;\t/* general index for parsing */\n\tuchar bufParseTAG[CONF_TAG_MAXSIZE];\n\tuchar bufParseHOSTNAME[CONF_HOSTNAME_MAXSIZE];\n\tBEGINfunc\n\n\tassert(pMsg != NULL);\n\tassert(pMsg->pszRawMsg != NULL);\n\tlenMsg = pMsg->iLenRawMsg - pMsg->offAfterPRI; /* note: offAfterPRI is already the number of PRI chars (do not add one!) */\n\tp2parse = pMsg->pszRawMsg + pMsg->offAfterPRI; /* point to start of text, after PRI */\n\n\t/* Check to see if msg contains a timestamp. We start by assuming\n\t * that the message timestamp is the time of reception (which we \n\t * generated ourselfs and then try to actually find one inside the\n\t * message. There we go from high-to low precison and are done\n\t * when we find a matching one. -- rgerhards, 2008-09-16\n\t */\n\tif(datetime.ParseTIMESTAMP3339(&(pMsg->tTIMESTAMP), &p2parse, &lenMsg) == RS_RET_OK) {\n\t\t/* we are done - parse pointer is moved by ParseTIMESTAMP3339 */;\n\t} else if(datetime.ParseTIMESTAMP3164(&(pMsg->tTIMESTAMP), &p2parse, &lenMsg) == RS_RET_OK) {\n\t\t/* we are done - parse pointer is moved by ParseTIMESTAMP3164 */;\n\t} else if(*p2parse == ' ' && lenMsg > 1) { /* try to see if it is slighly malformed - HP procurve seems to do that sometimes */\n\t\t++p2parse;\t/* move over space */\n\t\t--lenMsg;\n\t\tif(datetime.ParseTIMESTAMP3164(&(pMsg->tTIMESTAMP), &p2parse, &lenMsg) == RS_RET_OK) {\n\t\t\t/* indeed, we got it! */\n\t\t\t/* we are done - parse pointer is moved by ParseTIMESTAMP3164 */;\n\t\t} else {/* parse pointer needs to be restored, as we moved it off-by-one\n\t\t\t * for this try.\n\t\t\t */\n\t\t\t--p2parse;\n\t\t\t++lenMsg;\n\t\t}\n\t}\n\n\tif(flags & IGNDATE) {\n\t\t/* we need to ignore the msg data, so simply copy over reception date */\n\t\tmemcpy(&pMsg->tTIMESTAMP, &pMsg->tRcvdAt, sizeof(struct syslogTime));\n\t}\n\n\t/* rgerhards, 2006-03-13: next, we parse the hostname and tag. But we \n\t * do this only when the user has not forbidden this. I now introduce some\n\t * code that allows a user to configure rsyslogd to treat the rest of the\n\t * message as MSG part completely. In this case, the hostname will be the\n\t * machine that we received the message from and the tag will be empty. This\n\t * is meant to be an interim solution, but for now it is in the code.\n\t */\n\tif(bParseHOSTNAMEandTAG && !(flags & INTERNAL_MSG)) {\n\t\t/* parse HOSTNAME - but only if this is network-received!\n\t\t * rger, 2005-11-14: we still have a problem with BSD messages. These messages\n\t\t * do NOT include a host name. In most cases, this leads to the TAG to be treated\n\t\t * as hostname and the first word of the message as the TAG. Clearly, this is not\n\t\t * of advantage ;) I think I have now found a way to handle this situation: there\n\t\t * are certain characters which are frequently used in TAG (e.g. ':'), which are\n\t\t * *invalid* in host names. So while parsing the hostname, I check for these characters.\n\t\t * If I find them, I set a simple flag but continue. After parsing, I check the flag.\n\t\t * If it was set, then we most probably do not have a hostname but a TAG. Thus, I change\n\t\t * the fields. I think this logic shall work with any type of syslog message.\n\t\t * rgerhards, 2009-06-23: and I now have extended this logic to every character\n\t\t * that is not a valid hostname.\n\t\t */\n\t\tif(lenMsg > 0 && flags & PARSE_HOSTNAME) {\n\t\t\ti = 0;\n\t\t\twhile(i < lenMsg && (isalnum(p2parse[i]) || p2parse[i] == '.' || p2parse[i] == '.'\n\t\t\t\t|| p2parse[i] == '_' || p2parse[i] == '-') && i < (CONF_HOSTNAME_MAXSIZE - 1)) {\n\t\t\t\tbufParseHOSTNAME[i] = p2parse[i];\n\t\t\t\t++i;\n\t\t\t}\n\n\t\t\tif(i == lenMsg) {\n\t\t\t\t/* we have a message that is empty immediately after the hostname,\n\t\t\t\t * but the hostname thus is valid! -- rgerhards, 2010-02-22\n\t\t\t\t */\n\t\t\t\tp2parse += i;\n\t\t\t\tlenMsg -= i;\n\t\t\t\tbufParseHOSTNAME[i] = '\\0';\n\t\t\t\tMsgSetHOSTNAME(pMsg, bufParseHOSTNAME, i);\n\t\t\t} else if(i > 0 && p2parse[i] == ' ' && isalnum(p2parse[i-1])) {\n\t\t\t\t/* we got a hostname! */\n\t\t\t\tp2parse += i + 1; /* \"eat\" it (including SP delimiter) */\n\t\t\t\tlenMsg -= i + 1;\n\t\t\t\tbufParseHOSTNAME[i] = '\\0';\n\t\t\t\tMsgSetHOSTNAME(pMsg, bufParseHOSTNAME, i);\n\t\t\t}\n\t\t}\n\n\t\t/* now parse TAG - that should be present in message from all sources.\n\t\t * This code is somewhat not compliant with RFC 3164. As of 3164,\n\t\t * the TAG field is ended by any non-alphanumeric character. In\n\t\t * practice, however, the TAG often contains dashes and other things,\n\t\t * which would end the TAG. So it is not desirable. As such, we only\n\t\t * accept colon and SP to be terminators. Even there is a slight difference:\n\t\t * a colon is PART of the TAG, while a SP is NOT part of the tag\n\t\t * (it is CONTENT). Starting 2008-04-04, we have removed the 32 character\n\t\t * size limit (from RFC3164) on the tag. This had bad effects on existing\n\t\t * envrionments, as sysklogd didn't obey it either (probably another bug\n\t\t * in RFC3164...). We now receive the full size, but will modify the\n\t\t * outputs so that only 32 characters max are used by default.\n\t\t */\n\t\ti = 0;\n\t\twhile(lenMsg > 0 && *p2parse != ':' && *p2parse != ' ' && i < CONF_TAG_MAXSIZE) {\n\t\t\tbufParseTAG[i++] = *p2parse++;\n\t\t\t--lenMsg;\n\t\t}\n\t\tif(lenMsg > 0 && *p2parse == ':') {\n\t\t\t++p2parse; \n\t\t\t--lenMsg;\n\t\t\tbufParseTAG[i++] = ':';\n\t\t}\n\n\t\t/* no TAG can only be detected if the message immediatly ends, in which case an empty TAG\n\t\t * is considered OK. So we do not need to check for empty TAG. -- rgerhards, 2009-06-23\n\t\t */\n\t\tbufParseTAG[i] = '\\0';\t/* terminate string */\n\t\tMsgSetTAG(pMsg, bufParseTAG, i);\n\t} else {/* we enter this code area when the user has instructed rsyslog NOT\n\t\t * to parse HOSTNAME and TAG - rgerhards, 2006-03-13\n\t\t */\n\t\tif(!(flags & INTERNAL_MSG)) {\n\t\t\tDBGPRINTF(\"HOSTNAME and TAG not parsed by user configuraton.\\n\");\n\t\t}\n\t}\n\n\t/* The rest is the actual MSG */\n\tMsgSetMSGoffs(pMsg, p2parse - pMsg->pszRawMsg);\n\n\tENDfunc\n\treturn 0; /* all ok */\n}",
        "start_line": 1189
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "tools/syslogd.c",
        "method_name": "parseLegacySyslogMsg",
        "raw_code": "int parseLegacySyslogMsg(msg_t *pMsg, int flags) /* <=== parseLegacySyslogMsg */ \n{\n\tuchar *p2parse;\n\tint lenMsg;\n\tint i;\t/* general index for parsing */\n\tuchar bufParseTAG[CONF_TAG_MAXSIZE];\n\tuchar bufParseHOSTNAME[CONF_HOSTNAME_MAXSIZE];\n\tBEGINfunc\n\n\tassert(pMsg != NULL);\n\tassert(pMsg->pszRawMsg != NULL);\n\tlenMsg = pMsg->iLenRawMsg - pMsg->offAfterPRI; /* note: offAfterPRI is already the number of PRI chars (do not add one!) */\n\tp2parse = pMsg->pszRawMsg + pMsg->offAfterPRI; /* point to start of text, after PRI */\n\n\t/* Check to see if msg contains a timestamp. We start by assuming\n\t * that the message timestamp is the time of reception (which we \n\t * generated ourselfs and then try to actually find one inside the\n\t * message. There we go from high-to low precison and are done\n\t * when we find a matching one. -- rgerhards, 2008-09-16\n\t */\n\tif(datetime.ParseTIMESTAMP3339(&(pMsg->tTIMESTAMP), &p2parse, &lenMsg) == RS_RET_OK) {\n\t\t/* we are done - parse pointer is moved by ParseTIMESTAMP3339 */;\n\t} else if(datetime.ParseTIMESTAMP3164(&(pMsg->tTIMESTAMP), &p2parse, &lenMsg) == RS_RET_OK) {\n\t\t/* we are done - parse pointer is moved by ParseTIMESTAMP3164 */;\n\t} else if(*p2parse == ' ' && lenMsg > 1) { /* try to see if it is slighly malformed - HP procurve seems to do that sometimes */\n\t\t++p2parse;\t/* move over space */\n\t\t--lenMsg;\n\t\tif(datetime.ParseTIMESTAMP3164(&(pMsg->tTIMESTAMP), &p2parse, &lenMsg) == RS_RET_OK) {\n\t\t\t/* indeed, we got it! */\n\t\t\t/* we are done - parse pointer is moved by ParseTIMESTAMP3164 */;\n\t\t} else {/* parse pointer needs to be restored, as we moved it off-by-one\n\t\t\t * for this try.\n\t\t\t */\n\t\t\t--p2parse;\n\t\t\t++lenMsg;\n\t\t}\n\t}\n\n\tif(flags & IGNDATE) {\n\t\t/* we need to ignore the msg data, so simply copy over reception date */\n\t\tmemcpy(&pMsg->tTIMESTAMP, &pMsg->tRcvdAt, sizeof(struct syslogTime));\n\t}\n\n\t/* rgerhards, 2006-03-13: next, we parse the hostname and tag. But we \n\t * do this only when the user has not forbidden this. I now introduce some\n\t * code that allows a user to configure rsyslogd to treat the rest of the\n\t * message as MSG part completely. In this case, the hostname will be the\n\t * machine that we received the message from and the tag will be empty. This\n\t * is meant to be an interim solution, but for now it is in the code.\n\t */\n\tif(bParseHOSTNAMEandTAG && !(flags & INTERNAL_MSG)) {\n\t\t/* parse HOSTNAME - but only if this is network-received!\n\t\t * rger, 2005-11-14: we still have a problem with BSD messages. These messages\n\t\t * do NOT include a host name. In most cases, this leads to the TAG to be treated\n\t\t * as hostname and the first word of the message as the TAG. Clearly, this is not\n\t\t * of advantage ;) I think I have now found a way to handle this situation: there\n\t\t * are certain characters which are frequently used in TAG (e.g. ':'), which are\n\t\t * *invalid* in host names. So while parsing the hostname, I check for these characters.\n\t\t * If I find them, I set a simple flag but continue. After parsing, I check the flag.\n\t\t * If it was set, then we most probably do not have a hostname but a TAG. Thus, I change\n\t\t * the fields. I think this logic shall work with any type of syslog message.\n\t\t * rgerhards, 2009-06-23: and I now have extended this logic to every character\n\t\t * that is not a valid hostname.\n\t\t */\n\t\tif(lenMsg > 0 && flags & PARSE_HOSTNAME) {\n\t\t\ti = 0;\n\t\t\twhile(i < lenMsg && (isalnum(p2parse[i]) || p2parse[i] == '.' || p2parse[i] == '.'\n\t\t\t\t|| p2parse[i] == '_' || p2parse[i] == '-') && i < (CONF_HOSTNAME_MAXSIZE - 1)) {\n\t\t\t\tbufParseHOSTNAME[i] = p2parse[i];\n\t\t\t\t++i;\n\t\t\t}\n\n\t\t\tif(i == lenMsg) {\n\t\t\t\t/* we have a message that is empty immediately after the hostname,\n\t\t\t\t * but the hostname thus is valid! -- rgerhards, 2010-02-22\n\t\t\t\t */\n\t\t\t\tp2parse += i;\n\t\t\t\tlenMsg -= i;\n\t\t\t\tbufParseHOSTNAME[i] = '\\0';\n\t\t\t\tMsgSetHOSTNAME(pMsg, bufParseHOSTNAME, i);\n\t\t\t} else if(i > 0 && p2parse[i] == ' ' && isalnum(p2parse[i-1])) {\n\t\t\t\t/* we got a hostname! */\n\t\t\t\tp2parse += i + 1; /* \"eat\" it (including SP delimiter) */\n\t\t\t\tlenMsg -= i + 1;\n\t\t\t\tbufParseHOSTNAME[i] = '\\0';\n\t\t\t\tMsgSetHOSTNAME(pMsg, bufParseHOSTNAME, i);\n\t\t\t}\n\t\t}\n\n\t\t/* now parse TAG - that should be present in message from all sources.\n\t\t * This code is somewhat not compliant with RFC 3164. As of 3164,\n\t\t * the TAG field is ended by any non-alphanumeric character. In\n\t\t * practice, however, the TAG often contains dashes and other things,\n\t\t * which would end the TAG. So it is not desirable. As such, we only\n\t\t * accept colon and SP to be terminators. Even there is a slight difference:\n\t\t * a colon is PART of the TAG, while a SP is NOT part of the tag\n\t\t * (it is CONTENT). Starting 2008-04-04, we have removed the 32 character\n\t\t * size limit (from RFC3164) on the tag. This had bad effects on existing\n\t\t * envrionments, as sysklogd didn't obey it either (probably another bug\n\t\t * in RFC3164...). We now receive the full size, but will modify the\n\t\t * outputs so that only 32 characters max are used by default.\n\t\t */\n\t\ti = 0;\n\t\twhile(lenMsg > 0 && *p2parse != ':' && *p2parse != ' ' && i < CONF_TAG_MAXSIZE - 2) {\n\t\t\tbufParseTAG[i++] = *p2parse++;\n\t\t\t--lenMsg;\n\t\t}\n\t\tif(lenMsg > 0 && *p2parse == ':') {\n\t\t\t++p2parse; \n\t\t\t--lenMsg;\n\t\t\tbufParseTAG[i++] = ':';\n\t\t}\n\n\t\t/* no TAG can only be detected if the message immediatly ends, in which case an empty TAG\n\t\t * is considered OK. So we do not need to check for empty TAG. -- rgerhards, 2009-06-23\n\t\t */\n\t\tbufParseTAG[i] = '\\0';\t/* terminate string */\n\t\tMsgSetTAG(pMsg, bufParseTAG, i);\n\t} else {/* we enter this code area when the user has instructed rsyslog NOT\n\t\t * to parse HOSTNAME and TAG - rgerhards, 2006-03-13\n\t\t */\n\t\tif(!(flags & INTERNAL_MSG)) {\n\t\t\tDBGPRINTF(\"HOSTNAME and TAG not parsed by user configuraton.\\n\");\n\t\t}\n\t}\n\n\t/* The rest is the actual MSG */\n\tMsgSetMSGoffs(pMsg, p2parse - pMsg->pszRawMsg);\n\n\tENDfunc\n\treturn 0; /* all ok */\n}",
        "start_line": 1189
      }
    ],
    "code_context": "Called Methods:\n- CONF_TAG_BUFSIZE: #define CONF_TAG_BUFSIZE\t\t32 /* <=== runtime/rsyslog.h:40:40:CONF_TAG_BUFSIZE:0 */ \n- CONF_HOSTNAME_MAXSIZE: #define CONF_HOSTNAME_MAXSIZE\t\t512\t/* a value that is deemed far too large for any valid HOSTNAME */ /* <=== runtime/rsyslog.h:38:38:CONF_HOSTNAME_MAXSIZE:0 */ \n- MsgSetTAG: void MsgSetTAG(msg_t *pMsg, uchar* pszBuf, size_t lenBuf) /* <=== MsgSetTAG */ \n{\n\tuchar *pBuf;\n\tassert(pMsg != NULL);\n\n\tfreeTAG(pMsg);\n\n\tpMsg->iLenTAG = lenBuf;\n\tif(pMsg->iLenTAG < CONF_TAG_BUFSIZE) {\n\t\t/* small enough: use fixed buffer (faster!) */\n\t\tpBuf = pMsg->TAG.szBuf;\n\t} else {\n\t\tif((pBuf = (uchar*) malloc(pMsg->iLenTAG + 1)) == NULL) {\n\t\t\t/* truncate message, better than completely loosing it... */\n\t\t\tpBuf = pMsg->TAG.szBuf;\n\t\t\tpMsg->iLenTAG = CONF_TAG_BUFSIZE - 1;\n\t\t} else {\n\t\t\tpMsg->TAG.pszTAG = pBuf;\n\t\t}\n\t}\n\n\tmemcpy(pBuf, pszBuf, pMsg->iLenTAG);\n\tpBuf[pMsg->iLenTAG] = '\\0'; /* this also works with truncation! */\n}\n- IGNDATE: #define IGNDATE\t\t0x004\t/* ignore, if given, date in message and use date of reception as msg date */ /* <=== runtime/msg.h:129:129:IGNDATE:0 */ \n- CONF_TAG_MAXSIZE: #define CONF_TAG_MAXSIZE\t\t512\t/* a value that is deemed far too large for any valid TAG */ /* <=== runtime/rsyslog.h:37:37:CONF_TAG_MAXSIZE:0 */ \n- PARSE_HOSTNAME: #define PARSE_HOSTNAME\t0x020\t/* parse the hostname during message parsing */ /* <=== runtime/msg.h:132:132:PARSE_HOSTNAME:0 */ \n- INTERNAL_MSG: #define INTERNAL_MSG\t0x001\t/* msg generated by logmsgInternal() --> special handling */ /* <=== runtime/msg.h:127:127:INTERNAL_MSG:0 */ \n- freeTAG: static inline void freeTAG(msg_t *pThis) /* <=== freeTAG */ \n{\n\tif(pThis->iLenTAG >= CONF_TAG_BUFSIZE)\n\t\tfree(pThis->TAG.pszTAG);\n}\n- ISOBJ_TYPE_assert: #\tdefine ISOBJ_TYPE_assert(pObj, objType) \\ /* <=== runtime/obj-types.h:105:115:ISOBJ_TYPE_assert:2 */ \n\t\tdo { \\\n\t\tASSERT(pObj != NULL); \\\n\t\tif(strcmp((char*)(((obj_t*)pObj)->pObjInfo->pszID), #objType)) { \\\n\t\t\tdbgprintf(\"%s:%d ISOBJ assert failure: invalid object type, expected '%s' \" \\\n\t\t\t\t  \"actual '%s', cookie: %X\\n\", __FILE__, __LINE__, #objType, \\\n\t\t\t\t  (((obj_t*)pObj)->pObjInfo->pszID), ((obj_t*)(pObj))->iObjCooCKiE); \\\n\t\t\tassert(0); /* trigger assertion, messge we already have */ \\\n\t\t} \\\n\t\tASSERT((unsigned) ((obj_t*)(pObj))->iObjCooCKiE == (unsigned) 0xBADEFEE); \\\n\t\t} while(0)\n- MsgSetMSGoffs: void MsgSetMSGoffs(msg_t *pMsg, short offs) /* <=== MsgSetMSGoffs */ \n{\n\tISOBJ_TYPE_assert(pMsg, msg);\n\tpMsg->offMSG = offs;\n\tif(offs > pMsg->iLenRawMsg) {\n\t\tassert(offs - 1 == pMsg->iLenRawMsg);\n\t\tpMsg->iLenMSG = 0;\n\t} else {\n\t\tpMsg->iLenMSG = pMsg->iLenRawMsg - offs;\n\t}\n}\n- dbgprintf: void /* <=== dbgprintf */ \ndbgprintf(char *fmt, ...)\n{\n\tva_list ap;\n\tchar pszWriteBuf[20480];\n\tsize_t lenWriteBuf;\n\n\tif(!(Debug && debugging_on))\n\t\treturn;\n\t\n\tva_start(ap, fmt);\n\tlenWriteBuf = vsnprintf(pszWriteBuf, sizeof(pszWriteBuf), fmt, ap);\n\tva_end(ap);\n\tif(lenWriteBuf >= sizeof(pszWriteBuf)) {\n\t\t/* prevent buffer overrruns and garbagge display */\n\t\tpszWriteBuf[sizeof(pszWriteBuf) - 5] = '.';\n\t\tpszWriteBuf[sizeof(pszWriteBuf) - 4] = '.';\n\t\tpszWriteBuf[sizeof(pszWriteBuf) - 3] = '.';\n\t\tpszWriteBuf[sizeof(pszWriteBuf) - 2] = '\\n';\n\t\tpszWriteBuf[sizeof(pszWriteBuf) - 1] = '\\0';\n\t\tlenWriteBuf = sizeof(pszWriteBuf);\n\t}\n\tdbgprint(NULL, pszWriteBuf, lenWriteBuf);\n}\n\nType Definitions:\n- msg_t: typedef struct msg msg_t;\n- rsRetVal_: typedef enum rsRetVal_\n- uchar: typedef unsigned char uchar;\n\nGlobal Variables:\n- static int bParseHOSTNAMEandTAG\n\nImports:\n- # include <sys/timespec.h>\n- #include \"syslogd.h\"\n- #include <sys/ioctl.h>\n- #include \"pidfile.h\"\n- #include \"ruleset.h\"\n- #include \"ompipe.h\"\n- #include \"datetime.h\"\n- #include \"syslogd-types.h\"\n- #\tinclude <sys/stat.h>\n- #include \"modules.h\"\n- #\tinclude <fcntl.h>\n- #include <signal.h>\n- #include \"prop.h\"\n- #include <limits.h>\n- #include \"msg.h\"\n- #include <time.h>\n- #include \"omdiscard.h\"\n- #include <sys/file.h>\n- #include \"rule.h\"\n- #include \"conf.h\"\n- #include \"net.h\"\n- #include \"config.h\"\n- #\tinclude <sys/termios.h>\n- #\tinclude <libgen.h>\n- #include <sys/resource.h>\n- #include <unistd.h>\n- #include <assert.h>\n- #include \"template.h\"\n- #include \"iminternal.h\"\n- #\tinclude <sys/errno.h>\n- #include \"errmsg.h\"\n- #include \"outchannel.h\"\n- #include <stddef.h>\n- #include \"omfwd.h\"\n- #include \"cfsysline.h\"\n- #include <sys/wait.h>\n- #include \"omshell.h\"\n- #include \"queue.h\"\n- #include \"unicode-helper.h\"\n- #include <ctype.h>\n- #include \"stream.h\"\n- #\tinclude <sys/types.h>\n- #include <string.h>\n- #include <stdarg.h>\n- #include \"rsyslog.h\"\n- #include <paths.h>\n- #include <stdio.h>\n- #\tinclude <stropts.h>\n- #include \"omusrmsg.h\"\n- #include \"threads.h\"\n- #\tinclude <errno.h>\n- #include \"parser.h\"\n- #include <stdlib.h>\n- #include <zlib.h>\n- #include \"omfile.h\"\n- #include \"vm.h\"\n- #include \"stringbuf.h\"\n- #include \"action.h\"\n- #include \"srUtils.h\"\n- #include <grp.h>\n- #include <netdb.h>",
    "commit_msg": "bugfix: off-by-one(two) bug in legacy syslog parser",
    "cve_desc": "Stack-based buffer overflow in the parseLegacySyslogMsg function in tools/syslogd.c in rsyslogd in rsyslog 4.6.x before 4.6.8 and 5.2.0 through 5.8.4 might allow remote attackers to cause a denial of service (application exit) via a long TAG in a legacy syslog message.",
    "year": 2011,
    "filename": "syslogd.c",
    "commit_url": "\"https://github.com/rsyslog/rsyslog/commit/1ca6cc236d1dabf1633238b873fb1c057e52f95e\""
  },
  {
    "repository": "torvalds/linux",
    "cve_id": "CVE-2011-3353",
    "cwe_list": [
      "CWE-120"
    ],
    "commit_hash": "c2183d1e9b3f313dd8ba2b1b0197c8d9fb86a7ae",
    "short_hash": "c2183d1e",
    "vulnerableMethods_before": [
      {
        "filename": "fs/fuse/dev.c",
        "method_name": "fuse_notify_inval_entry",
        "raw_code": "static int fuse_notify_inval_entry(struct fuse_conn *fc, unsigned int size, /* <=== fuse_notify_inval_entry */ \n\t\t\t\t   struct fuse_copy_state *cs)\n{\n\tstruct fuse_notify_inval_entry_out outarg;\n\tint err = -ENOMEM;\n\tchar *buf;\n\tstruct qstr name;\n\n\tbuf = kzalloc(FUSE_NAME_MAX + 1, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto err;\n\n\terr = -EINVAL;\n\tif (size < sizeof(outarg))\n\t\tgoto err;\n\n\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));\n\tif (err)\n\t\tgoto err;\n\n\terr = -ENAMETOOLONG;\n\tif (outarg.namelen > FUSE_NAME_MAX)\n\t\tgoto err;\n\n\tname.name = buf;\n\tname.len = outarg.namelen;\n\terr = fuse_copy_one(cs, buf, outarg.namelen + 1);\n\tif (err)\n\t\tgoto err;\n\tfuse_copy_finish(cs);\n\tbuf[outarg.namelen] = 0;\n\tname.hash = full_name_hash(name.name, name.len);\n\n\tdown_read(&fc->killsb);\n\terr = -ENOENT;\n\tif (fc->sb)\n\t\terr = fuse_reverse_inval_entry(fc->sb, outarg.parent, &name);\n\tup_read(&fc->killsb);\n\tkfree(buf);\n\treturn err;\n\nerr:\n\tkfree(buf);\n\tfuse_copy_finish(cs);\n\treturn err;\n}",
        "start_line": 1337
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "fs/fuse/dev.c",
        "method_name": "fuse_notify_inval_entry",
        "raw_code": "static int fuse_notify_inval_entry(struct fuse_conn *fc, unsigned int size, /* <=== fuse_notify_inval_entry */ \n\t\t\t\t   struct fuse_copy_state *cs)\n{\n\tstruct fuse_notify_inval_entry_out outarg;\n\tint err = -ENOMEM;\n\tchar *buf;\n\tstruct qstr name;\n\n\tbuf = kzalloc(FUSE_NAME_MAX + 1, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto err;\n\n\terr = -EINVAL;\n\tif (size < sizeof(outarg))\n\t\tgoto err;\n\n\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));\n\tif (err)\n\t\tgoto err;\n\n\terr = -ENAMETOOLONG;\n\tif (outarg.namelen > FUSE_NAME_MAX)\n\t\tgoto err;\n\n\terr = -EINVAL;\n\tif (size != sizeof(outarg) + outarg.namelen + 1)\n\t\tgoto err;\n\n\tname.name = buf;\n\tname.len = outarg.namelen;\n\terr = fuse_copy_one(cs, buf, outarg.namelen + 1);\n\tif (err)\n\t\tgoto err;\n\tfuse_copy_finish(cs);\n\tbuf[outarg.namelen] = 0;\n\tname.hash = full_name_hash(name.name, name.len);\n\n\tdown_read(&fc->killsb);\n\terr = -ENOENT;\n\tif (fc->sb)\n\t\terr = fuse_reverse_inval_entry(fc->sb, outarg.parent, &name);\n\tup_read(&fc->killsb);\n\tkfree(buf);\n\treturn err;\n\nerr:\n\tkfree(buf);\n\tfuse_copy_finish(cs);\n\treturn err;\n}",
        "start_line": 1337
      }
    ],
    "code_context": "Called Methods:\n- FUSE_NAME_MAX: #define FUSE_NAME_MAX 1024 /* <=== fs/fuse/fuse_i.h:33:33:FUSE_NAME_MAX:0 */ \n- partial_name_hash: static inline unsigned long /* <=== partial_name_hash */ \npartial_name_hash(unsigned long c, unsigned long prevhash)\n{\n\treturn (prevhash + (c << 4) + (c >> 4)) * 11;\n}\n- kunmap: void kunmap(struct page *page) /* <=== kunmap */ \n{\n\tBUG_ON(in_interrupt());\n\tif (!PageHighMem(page))\n\t\treturn;\n\tkunmap_high(page);\n}\n- iput: void iput(struct inode *inode) /* <=== iput */ \n{\n\tif (inode) {\n\t\tBUG_ON(inode->i_state & I_CLEAR);\n\n\t\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock))\n\t\t\tiput_final(inode);\n\t}\n}\n- PageSlab: __PAGEFLAG(Slab, slab) /* <=== PageSlab */ \n- flush_dcache_page: void flush_dcache_page(struct page *page) /* <=== flush_dcache_page */ \n{\n\tunsigned long dampr2;\n\tvoid *vaddr;\n\n\tdampr2 = __get_DAMPR(2);\n\n\tvaddr = kmap_atomic_primary(page, __KM_CACHE);\n\n\tfrv_dcache_writeback((unsigned long) vaddr, (unsigned long) vaddr + PAGE_SIZE);\n\n\tkunmap_atomic_primary(vaddr, __KM_CACHE);\n\n\tif (dampr2) {\n\t\t__set_DAMPR(2, dampr2);\n\t\t__set_IAMPR(2, dampr2);\n\t}\n\n} /* end flush_dcache_page() */\n- kunmap: void kunmap(struct page *page) /* <=== kunmap */ \n{\n\tif (in_interrupt())\n\t\tBUG();\n\tif (!PageHighMem(page))\n\t\treturn;\n\tkunmap_high(page);\n}\n- end_name_hash: static inline unsigned long end_name_hash(unsigned long hash) /* <=== end_name_hash */ \n{\n\treturn (unsigned int) hash;\n}\n- set_page_dirty_lock: int set_page_dirty_lock(struct page *page) /* <=== set_page_dirty_lock */ \n{\n\tint ret;\n\n\tlock_page(page);\n\tret = set_page_dirty(page);\n\tunlock_page(page);\n\treturn ret;\n}\n- ilookup5: struct inode *ilookup5(struct super_block *sb, unsigned long hashval, /* <=== ilookup5 */ \n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct inode *inode = ilookup5_nowait(sb, hashval, test, data);\n\n\tif (inode)\n\t\twait_on_inode(inode);\n\treturn inode;\n}\n- kfree: void kfree(const void *block) /* <=== kfree */ \n{\n\tstruct slob_page *sp;\n\n\ttrace_kfree(_RET_IP_, block);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(block)))\n\t\treturn;\n\tkmemleak_free(block);\n\n\tsp = slob_page(block);\n\tif (is_slob_page(sp)) {\n\t\tint align = max(ARCH_KMALLOC_MINALIGN, ARCH_SLAB_MINALIGN);\n\t\tunsigned int *m = (unsigned int *)(block - align);\n\t\tslob_free(m, *m + align);\n\t} else\n\t\tput_page(&sp->page);\n}\n- flush_dcache_page: void flush_dcache_page(struct page *page) /* <=== flush_dcache_page */ \n{\n\tcacheop_on_each_cpu(local_flush_dcache_page, page, 1);\n}\n- fuse_reverse_inval_entry: int fuse_reverse_inval_entry(struct super_block *sb, u64 parent_nodeid, /* <=== fuse_reverse_inval_entry */ \n\t\t\t     struct qstr *name)\n{\n\tint err = -ENOTDIR;\n\tstruct inode *parent;\n\tstruct dentry *dir;\n\tstruct dentry *entry;\n\n\tparent = ilookup5(sb, parent_nodeid, fuse_inode_eq, &parent_nodeid);\n\tif (!parent)\n\t\treturn -ENOENT;\n\n\tmutex_lock(&parent->i_mutex);\n\tif (!S_ISDIR(parent->i_mode))\n\t\tgoto unlock;\n\n\terr = -ENOENT;\n\tdir = d_find_alias(parent);\n\tif (!dir)\n\t\tgoto unlock;\n\n\tentry = d_lookup(dir, name);\n\tdput(dir);\n\tif (!entry)\n\t\tgoto unlock;\n\n\tfuse_invalidate_attr(parent);\n\tfuse_invalidate_entry(entry);\n\tdput(entry);\n\terr = 0;\n\n unlock:\n\tmutex_unlock(&parent->i_mutex);\n\tiput(parent);\n\treturn err;\n}\n- slob_free: static void slob_free(void *block, int size) /* <=== slob_free */ \n{\n\tstruct slob_page *sp;\n\tslob_t *prev, *next, *b = (slob_t *)block;\n\tslobidx_t units;\n\tunsigned long flags;\n\tstruct list_head *slob_list;\n\n\tif (unlikely(ZERO_OR_NULL_PTR(block)))\n\t\treturn;\n\tBUG_ON(!size);\n\n\tsp = slob_page(block);\n\tunits = SLOB_UNITS(size);\n\n\tspin_lock_irqsave(&slob_lock, flags);\n\n\tif (sp->units + units == SLOB_UNITS(PAGE_SIZE)) {\n\t\t/* Go directly to page allocator. Do not pass slob allocator */\n\t\tif (slob_page_free(sp))\n\t\t\tclear_slob_page_free(sp);\n\t\tspin_unlock_irqrestore(&slob_lock, flags);\n\t\tclear_slob_page(sp);\n\t\tfree_slob_page(sp);\n\t\tslob_free_pages(b, 0);\n\t\treturn;\n\t}\n\n\tif (!slob_page_free(sp)) {\n\t\t/* This slob page is about to become partially free. Easy! */\n\t\tsp->units = units;\n\t\tsp->free = b;\n\t\tset_slob(b, units,\n\t\t\t(void *)((unsigned long)(b +\n\t\t\t\t\tSLOB_UNITS(PAGE_SIZE)) & PAGE_MASK));\n\t\tif (size < SLOB_BREAK1)\n\t\t\tslob_list = &free_slob_small;\n\t\telse if (size < SLOB_BREAK2)\n\t\t\tslob_list = &free_slob_medium;\n\t\telse\n\t\t\tslob_list = &free_slob_large;\n\t\tset_slob_page_free(sp, slob_list);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Otherwise the page is already partially free, so find reinsertion\n\t * point.\n\t */\n\tsp->units += units;\n\n\tif (b < sp->free) {\n\t\tif (b + units == sp->free) {\n\t\t\tunits += slob_units(sp->free);\n\t\t\tsp->free = slob_next(sp->free);\n\t\t}\n\t\tset_slob(b, units, sp->free);\n\t\tsp->free = b;\n\t} else {\n\t\tprev = sp->free;\n\t\tnext = slob_next(prev);\n\t\twhile (b > next) {\n\t\t\tprev = next;\n\t\t\tnext = slob_next(prev);\n\t\t}\n\n\t\tif (!slob_last(prev) && b + units == next) {\n\t\t\tunits += slob_units(next);\n\t\t\tset_slob(b, units, slob_next(next));\n\t\t} else\n\t\t\tset_slob(b, units, next);\n\n\t\tif (prev + slob_units(prev) == b) {\n\t\t\tunits = slob_units(b) + slob_units(prev);\n\t\t\tset_slob(prev, units, slob_next(b));\n\t\t} else\n\t\t\tset_slob(prev, slob_units(prev), b);\n\t}\nout:\n\tspin_unlock_irqrestore(&slob_lock, flags);\n}\n- fuse_copy_one: static int fuse_copy_one(struct fuse_copy_state *cs, void *val, unsigned size) /* <=== fuse_copy_one */ \n{\n\twhile (size) {\n\t\tif (!cs->len) {\n\t\t\tint err = fuse_copy_fill(cs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tfuse_copy_do(cs, &val, &size);\n\t}\n\treturn 0;\n}\n- flush_dcache_page: void flush_dcache_page(struct page *page) /* <=== flush_dcache_page */ \n{\n\tstruct address_space *mapping = page_mapping(page);\n\tunsigned long addr;\n\n\tif (PageHighMem(page))\n\t\treturn;\n\tif (mapping && !mapping_mapped(mapping)) {\n\t\tset_bit(PG_dcache_dirty, &(page)->flags);\n\t\treturn;\n\t}\n\n\t/*\n\t * We could delay the flush for the !page_mapping case too.  But that\n\t * case is for exec env/arg pages and those are %99 certainly going to\n\t * get faulted into the tlb (and thus flushed) anyways.\n\t */\n\taddr = (unsigned long) page_address(page);\n\tflush_data_cache_page(addr);\n}\n- PageCompound: TESTPAGEFLAG(Compound, compound) /* <=== PageCompound */ \n- dput: extern void dput(struct dentry *); /* <=== dput */ \n- flush_dcache_page: void flush_dcache_page(struct page *page) /* <=== flush_dcache_page */ \n{\n\tstruct address_space *mapping = page_mapping(page);\n\tstruct vm_area_struct *mpnt;\n\tstruct prio_tree_iter iter;\n\tunsigned long offset;\n\tunsigned long addr, old_addr = 0;\n\tpgoff_t pgoff;\n\n\tif (mapping && !mapping_mapped(mapping)) {\n\t\tset_bit(PG_dcache_dirty, &page->flags);\n\t\treturn;\n\t}\n\n\tflush_kernel_dcache_page(page);\n\n\tif (!mapping)\n\t\treturn;\n\n\tpgoff = page->index << (PAGE_CACHE_SHIFT - PAGE_SHIFT);\n\n\t/* We have carefully arranged in arch_get_unmapped_area() that\n\t * *any* mappings of a file are always congruently mapped (whether\n\t * declared as MAP_PRIVATE or MAP_SHARED), so we only need\n\t * to flush one address here for them all to become coherent */\n\n\tflush_dcache_mmap_lock(mapping);\n\tvma_prio_tree_foreach(mpnt, &iter, &mapping->i_mmap, pgoff, pgoff) {\n\t\toffset = (pgoff - mpnt->vm_pgoff) << PAGE_SHIFT;\n\t\taddr = mpnt->vm_start + offset;\n\n\t\t/* The TLB is the engine of coherence on parisc: The\n\t\t * CPU is entitled to speculate any page with a TLB\n\t\t * mapping, so here we kill the mapping then flush the\n\t\t * page along a special flush only alias mapping.\n\t\t * This guarantees that the page is no-longer in the\n\t\t * cache for any process and nor may it be\n\t\t * speculatively read in (until the user or kernel\n\t\t * specifically accesses it, of course) */\n\n\t\tflush_tlb_page(mpnt, addr);\n\t\tif (old_addr == 0 || (old_addr & (SHMLBA - 1)) != (addr & (SHMLBA - 1))) {\n\t\t\t__flush_cache_page(mpnt, addr, page_to_phys(page));\n\t\t\tif (old_addr)\n\t\t\t\tprintk(KERN_ERR \"INEQUIVALENT ALIASES 0x%lx and 0x%lx in file %s\\n\", old_addr, addr, mpnt->vm_file ? (char *)mpnt->vm_file->f_path.dentry->d_name.name : \"(null)\");\n\t\t\told_addr = addr;\n\t\t}\n\t}\n\tflush_dcache_mmap_unlock(mapping);\n}\n- kunmap: void kunmap(struct page *page) /* <=== kunmap */ \n{\n\tBUG_ON(in_interrupt());\n\tif (!PageHighMem(page))\n\t\treturn;\n\tkunmap_high(page);\n}\n- flush_dcache_page: static inline void flush_dcache_page(struct page *page) /* <=== flush_dcache_page */ \n{\n\tunsigned long addr = page_to_phys(page);\n\tfrv_dcache_writeback(addr, addr + PAGE_SIZE);\n}\n- fuse_copy_fill: static int fuse_copy_fill(struct fuse_copy_state *cs) /* <=== fuse_copy_fill */ \n{\n\tunsigned long offset;\n\tint err;\n\n\tunlock_request(cs->fc, cs->req);\n\tfuse_copy_finish(cs);\n\tif (cs->pipebufs) {\n\t\tstruct pipe_buffer *buf = cs->pipebufs;\n\n\t\tif (!cs->write) {\n\t\t\terr = buf->ops->confirm(cs->pipe, buf);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tBUG_ON(!cs->nr_segs);\n\t\t\tcs->currbuf = buf;\n\t\t\tcs->mapaddr = buf->ops->map(cs->pipe, buf, 0);\n\t\t\tcs->len = buf->len;\n\t\t\tcs->buf = cs->mapaddr + buf->offset;\n\t\t\tcs->pipebufs++;\n\t\t\tcs->nr_segs--;\n\t\t} else {\n\t\t\tstruct page *page;\n\n\t\t\tif (cs->nr_segs == cs->pipe->buffers)\n\t\t\t\treturn -EIO;\n\n\t\t\tpage = alloc_page(GFP_HIGHUSER);\n\t\t\tif (!page)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tbuf->page = page;\n\t\t\tbuf->offset = 0;\n\t\t\tbuf->len = 0;\n\n\t\t\tcs->currbuf = buf;\n\t\t\tcs->mapaddr = kmap(page);\n\t\t\tcs->buf = cs->mapaddr;\n\t\t\tcs->len = PAGE_SIZE;\n\t\t\tcs->pipebufs++;\n\t\t\tcs->nr_segs++;\n\t\t}\n\t} else {\n\t\tif (!cs->seglen) {\n\t\t\tBUG_ON(!cs->nr_segs);\n\t\t\tcs->seglen = cs->iov[0].iov_len;\n\t\t\tcs->addr = (unsigned long) cs->iov[0].iov_base;\n\t\t\tcs->iov++;\n\t\t\tcs->nr_segs--;\n\t\t}\n\t\terr = get_user_pages_fast(cs->addr, 1, cs->write, &cs->pg);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tBUG_ON(err != 1);\n\t\toffset = cs->addr % PAGE_SIZE;\n\t\tcs->mapaddr = kmap(cs->pg);\n\t\tcs->buf = cs->mapaddr + offset;\n\t\tcs->len = min(PAGE_SIZE - offset, cs->seglen);\n\t\tcs->seglen -= cs->len;\n\t\tcs->addr += cs->len;\n\t}\n\n\treturn lock_request(cs->fc, cs->req);\n}\n- kfree: static inline void kfree(void *p) /* <=== kfree */ \n{\n\tfree(p);\n}\n- fuse_invalidate_entry: static void fuse_invalidate_entry(struct dentry *entry) /* <=== fuse_invalidate_entry */ \n{\n\td_invalidate(entry);\n\tfuse_invalidate_entry_cache(entry);\n}\n- fuse_copy_do: static int fuse_copy_do(struct fuse_copy_state *cs, void **val, unsigned *size) /* <=== fuse_copy_do */ \n{\n\tunsigned ncpy = min(*size, cs->len);\n\tif (val) {\n\t\tif (cs->write)\n\t\t\tmemcpy(cs->buf, *val, ncpy);\n\t\telse\n\t\t\tmemcpy(*val, cs->buf, ncpy);\n\t\t*val += ncpy;\n\t}\n\t*size -= ncpy;\n\tcs->len -= ncpy;\n\tcs->buf += ncpy;\n\treturn ncpy;\n}\n- fuse_invalidate_attr: void fuse_invalidate_attr(struct inode *inode) /* <=== fuse_invalidate_attr */ \n{\n\tget_fuse_inode(inode)->i_time = 0;\n}\n- kzalloc: static inline void *kzalloc(size_t size, gfp_t flags) /* <=== kzalloc */ \n{\n\treturn kmalloc(size, flags | __GFP_ZERO);\n}\n- is_slob_page: static inline int is_slob_page(struct slob_page *sp) /* <=== is_slob_page */ \n{\n\treturn PageSlab((struct page *)sp);\n}\n- flush_dcache_page: void flush_dcache_page(struct page *page) /* <=== flush_dcache_page */ \n{\n\tstruct address_space *mapping;\n\tint this_cpu;\n\n\tif (tlb_type == hypervisor)\n\t\treturn;\n\n\t/* Do not bother with the expensive D-cache flush if it\n\t * is merely the zero page.  The 'bigcore' testcase in GDB\n\t * causes this case to run millions of times.\n\t */\n\tif (page == ZERO_PAGE(0))\n\t\treturn;\n\n\tthis_cpu = get_cpu();\n\n\tmapping = page_mapping(page);\n\tif (mapping && !mapping_mapped(mapping)) {\n\t\tint dirty = test_bit(PG_dcache_dirty, &page->flags);\n\t\tif (dirty) {\n\t\t\tint dirty_cpu = dcache_dirty_cpu(page);\n\n\t\t\tif (dirty_cpu == this_cpu)\n\t\t\t\tgoto out;\n\t\t\tsmp_flush_dcache_page_impl(page, dirty_cpu);\n\t\t}\n\t\tset_dcache_dirty(page, this_cpu);\n\t} else {\n\t\t/* We could delay the flush for the !page_mapping\n\t\t * case too.  But that case is for exec env/arg\n\t\t * pages and those are %99 certainly going to get\n\t\t * faulted into the tlb (and thus flushed) anyways.\n\t\t */\n\t\tflush_dcache_page_impl(page);\n\t}\n\nout:\n\tput_cpu();\n}\n- obj_size: #define obj_size(cachep)\t\t(cachep->buffer_size) /* <=== mm/slab.c:466:466:obj_size:1 */ \n- up_read: void up_read(struct rw_semaphore *sem) /* <=== up_read */ \n{\n\trwsem_release(&sem->dep_map, 1, _RET_IP_);\n\n\t__up_read(sem);\n}\n- init_name_hash: #define init_name_hash()\t\t0 /* <=== include/linux/dcache.h:73:73:init_name_hash:0 */ \n- flush_dcache_page: void flush_dcache_page(struct page *page) /* <=== flush_dcache_page */ \n{\n\t__cpuc_flush_dcache_area(page_address(page), PAGE_SIZE);\n}\n- kfree_debugcheck: #define kfree_debugcheck(x) do { } while(0) /* <=== mm/slab.c:3002:3002:kfree_debugcheck:1 */ \n- slob_page: static inline struct slob_page *slob_page(const void *addr) /* <=== slob_page */ \n{\n\treturn (struct slob_page *)virt_to_page(addr);\n}\n- full_name_hash: static inline unsigned int /* <=== full_name_hash */ \nfull_name_hash(const unsigned char *name, unsigned int len)\n{\n\tunsigned long hash = init_name_hash();\n\twhile (len--)\n\t\thash = partial_name_hash(*name++, hash);\n\treturn end_name_hash(hash);\n}\n- virt_to_cache: static inline struct kmem_cache *virt_to_cache(const void *obj) /* <=== virt_to_cache */ \n{\n\tstruct page *page = virt_to_head_page(obj);\n\treturn page_get_cache(page);\n}\n- flush_dcache_page: void flush_dcache_page(struct page *page) /* <=== flush_dcache_page */ \n{\n\tstruct address_space *mapping;\n\n\t/*\n\t * The zero page is never written to, so never has any dirty\n\t * cache lines, and therefore never needs to be flushed.\n\t */\n\tif (page == ZERO_PAGE(0))\n\t\treturn;\n\n\tmapping = page_mapping(page);\n\n\tif (mapping && !mapping_mapped(mapping))\n\t\tclear_bit(PG_dcache_clean, &page->flags);\n\telse {\n\t\t__flush_dcache_page(mapping, page);\n\t\tif (mapping)\n\t\t\t__flush_icache_all();\n\t\tset_bit(PG_dcache_clean, &page->flags);\n\t}\n}\n- kunmap: static inline void kunmap(struct page *page) /* <=== kunmap */ \n{\n}\n- mutex_lock: extern void mutex_lock(struct mutex *lock); /* <=== mutex_lock */ \n- mutex_unlock: extern void mutex_unlock(struct mutex *lock); /* <=== mutex_unlock */ \n- kfree: void kfree(const void *x) /* <=== kfree */ \n{\n\tstruct page *page;\n\tvoid *object = (void *)x;\n\n\ttrace_kfree(_RET_IP_, x);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(x)))\n\t\treturn;\n\n\tpage = virt_to_head_page(x);\n\tif (unlikely(!PageSlab(page))) {\n\t\tBUG_ON(!PageCompound(page));\n\t\tkmemleak_free(x);\n\t\tput_page(page);\n\t\treturn;\n\t}\n\tslab_free(page->slab, page, object, _RET_IP_);\n}\n- kunmap: void kunmap(struct page *page) /* <=== kunmap */ \n{\n\tif (in_interrupt())\n\t\tBUG();\n\tif (!PageHighMem(page))\n\t\treturn;\n\tkunmap_high(page);\n}\n- put_page: void put_page(struct page *page) /* <=== put_page */ \n{\n\tif (unlikely(PageCompound(page)))\n\t\tput_compound_page(page);\n\telse if (put_page_testzero(page))\n\t\t__put_single_page(page);\n}\n- kmalloc: static inline void *kmalloc(size_t s, gfp_t gfp) /* <=== kmalloc */ \n{\n\treturn malloc(s);\n}\n- down_read: extern void down_read(struct rw_semaphore *sem); /* <=== down_read */ \n- flush_dcache_page: void flush_dcache_page(struct page *page) /* <=== flush_dcache_page */ \n{\n\tif (cpu_has_feature(CPU_FTR_COHERENT_ICACHE))\n\t\treturn;\n\t/* avoid an atomic op if possible */\n\tif (test_bit(PG_arch_1, &page->flags))\n\t\tclear_bit(PG_arch_1, &page->flags);\n}\n- fuse_copy_finish: static void fuse_copy_finish(struct fuse_copy_state *cs) /* <=== fuse_copy_finish */ \n{\n\tif (cs->currbuf) {\n\t\tstruct pipe_buffer *buf = cs->currbuf;\n\n\t\tif (!cs->write) {\n\t\t\tbuf->ops->unmap(cs->pipe, buf, cs->mapaddr);\n\t\t} else {\n\t\t\tkunmap(buf->page);\n\t\t\tbuf->len = PAGE_SIZE - cs->len;\n\t\t}\n\t\tcs->currbuf = NULL;\n\t\tcs->mapaddr = NULL;\n\t} else if (cs->mapaddr) {\n\t\tkunmap(cs->pg);\n\t\tif (cs->write) {\n\t\t\tflush_dcache_page(cs->pg);\n\t\t\tset_page_dirty_lock(cs->pg);\n\t\t}\n\t\tput_page(cs->pg);\n\t\tcs->mapaddr = NULL;\n\t}\n}\n- flush_dcache_page: void flush_dcache_page(struct page *page) /* <=== flush_dcache_page */ \n{\n\tstruct address_space *mapping;\n\n\t/*\n\t * The zero page is never written to, so never has any dirty\n\t * cache lines, and therefore never needs to be flushed.\n\t */\n\tif (page == ZERO_PAGE(0))\n\t\treturn;\n\n\tmapping = page_mapping(page);\n\n\tif (!cache_ops_need_broadcast() &&\n\t    mapping && !mapping_mapped(mapping))\n\t\tclear_bit(PG_dcache_clean, &page->flags);\n\telse {\n\t\t__flush_dcache_page(mapping, page);\n\t\tif (mapping && cache_is_vivt())\n\t\t\t__flush_dcache_aliases(mapping, page);\n\t\telse if (mapping)\n\t\t\t__flush_icache_all();\n\t\tset_bit(PG_dcache_clean, &page->flags);\n\t}\n}\n- kunmap: void kunmap(struct page *page) /* <=== kunmap */ \n{\n\tif (in_interrupt())\n\t\tBUG();\n\tif (!PageHighMem(page))\n\t\treturn;\n\tkunmap_high(page);\n}\n- __cache_free: static inline void __cache_free(struct kmem_cache *cachep, void *objp) /* <=== __cache_free */ \n{\n\tstruct array_cache *ac = cpu_cache_get(cachep);\n\n\tcheck_irq_off();\n\tkmemleak_free_recursive(objp, cachep->flags);\n\tobjp = cache_free_debugcheck(cachep, objp, __builtin_return_address(0));\n\n\tkmemcheck_slab_free(cachep, objp, obj_size(cachep));\n\n\t/*\n\t * Skip calling cache_free_alien() when the platform is not numa.\n\t * This will avoid cache misses that happen while accessing slabp (which\n\t * is per page memory  reference) to get nodeid. Instead use a global\n\t * variable to skip the call, which is mostly likely to be present in\n\t * the cache.\n\t */\n\tif (nr_online_nodes > 1 && cache_free_alien(cachep, objp))\n\t\treturn;\n\n\tif (likely(ac->avail < ac->limit)) {\n\t\tSTATS_INC_FREEHIT(cachep);\n\t\tac->entry[ac->avail++] = objp;\n\t\treturn;\n\t} else {\n\t\tSTATS_INC_FREEMISS(cachep);\n\t\tcache_flusharray(cachep, ac);\n\t\tac->entry[ac->avail++] = objp;\n\t}\n}\n- kfree: void kfree(const void *objp) /* <=== kfree */ \n{\n\tstruct kmem_cache *c;\n\tunsigned long flags;\n\n\ttrace_kfree(_RET_IP_, objp);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(objp)))\n\t\treturn;\n\tlocal_irq_save(flags);\n\tkfree_debugcheck(objp);\n\tc = virt_to_cache(objp);\n\tdebug_check_no_locks_freed(objp, obj_size(c));\n\tdebug_check_no_obj_freed(objp, obj_size(c));\n\t__cache_free(c, (void *)objp);\n\tlocal_irq_restore(flags);\n}\n\nType Definitions:\n- qstr: struct qstr {\n\tunsigned int hash;\n\tunsigned int len;\n\tconst unsigned char *name;\n}\n- fuse_copy_state: struct fuse_copy_state {\n\tstruct fuse_conn *fc;\n\tint write;\n\tstruct fuse_req *req;\n\tconst struct iovec *iov;\n\tstruct pipe_buffer *pipebufs;\n\tstruct pipe_buffer *currbuf;\n\tstruct pipe_inode_info *pipe;\n\tunsigned long nr_segs;\n\tunsigned long seglen;\n\tunsigned long addr;\n\tstruct page *pg;\n\tvoid *mapaddr;\n\tvoid *buf;\n\tunsigned len;\n\tunsigned move_pages:1;\n}\n- fuse_conn: struct fuse_conn {\n\t/** Lock protecting accessess to  members of this structure */\n\tspinlock_t lock;\n\n\t/** Mutex protecting against directory alias creation */\n\tstruct mutex inst_mutex;\n\n\t/** Refcount */\n\tatomic_t count;\n\n\t/** The user id for this mount */\n\tuid_t user_id;\n\n\t/** The group id for this mount */\n\tgid_t group_id;\n\n\t/** The fuse mount flags for this mount */\n\tunsigned flags;\n\n\t/** Maximum read size */\n\tunsigned max_read;\n\n\t/** Maximum write size */\n\tunsigned max_write;\n\n\t/** Readers of the connection are waiting on this */\n\twait_queue_head_t waitq;\n\n\t/** The list of pending requests */\n\tstruct list_head pending;\n\n\t/** The list of requests being processed */\n\tstruct list_head processing;\n\n\t/** The list of requests under I/O */\n\tstruct list_head io;\n\n\t/** The next unique kernel file handle */\n\tu64 khctr;\n\n\t/** rbtree of fuse_files waiting for poll events indexed by ph */\n\tstruct rb_root polled_files;\n\n\t/** Maximum number of outstanding background requests */\n\tunsigned max_background;\n\n\t/** Number of background requests at which congestion starts */\n\tunsigned congestion_threshold;\n\n\t/** Number of requests currently in the background */\n\tunsigned num_background;\n\n\t/** Number of background requests currently queued for userspace */\n\tunsigned active_background;\n\n\t/** The list of background requests set aside for later queuing */\n\tstruct list_head bg_queue;\n\n\t/** Pending interrupts */\n\tstruct list_head interrupts;\n\n\t/** Queue of pending forgets */\n\tstruct fuse_forget_link forget_list_head;\n\tstruct fuse_forget_link *forget_list_tail;\n\n\t/** Batching of FORGET requests (positive indicates FORGET batch) */\n\tint forget_batch;\n\n\t/** Flag indicating if connection is blocked.  This will be\n\t    the case before the INIT reply is received, and if there\n\t    are too many outstading backgrounds requests */\n\tint blocked;\n\n\t/** waitq for blocked connection */\n\twait_queue_head_t blocked_waitq;\n\n\t/** waitq for reserved requests */\n\twait_queue_head_t reserved_req_waitq;\n\n\t/** The next unique request id */\n\tu64 reqctr;\n\n\t/** Connection established, cleared on umount, connection\n\t    abort and device release */\n\tunsigned connected;\n\n\t/** Connection failed (version mismatch).  Cannot race with\n\t    setting other bitfields since it is only set once in INIT\n\t    reply, before any other request, and never cleared */\n\tunsigned conn_error:1;\n\n\t/** Connection successful.  Only set in INIT */\n\tunsigned conn_init:1;\n\n\t/** Do readpages asynchronously?  Only set in INIT */\n\tunsigned async_read:1;\n\n\t/** Do not send separate SETATTR request before open(O_TRUNC)  */\n\tunsigned atomic_o_trunc:1;\n\n\t/** Filesystem supports NFS exporting.  Only set in INIT */\n\tunsigned export_support:1;\n\n\t/** Set if bdi is valid */\n\tunsigned bdi_initialized:1;\n\n\t/*\n\t * The following bitfields are only for optimization purposes\n\t * and hence races in setting them will not cause malfunction\n\t */\n\n\t/** Is fsync not implemented by fs? */\n\tunsigned no_fsync:1;\n\n\t/** Is fsyncdir not implemented by fs? */\n\tunsigned no_fsyncdir:1;\n\n\t/** Is flush not implemented by fs? */\n\tunsigned no_flush:1;\n\n\t/** Is setxattr not implemented by fs? */\n\tunsigned no_setxattr:1;\n\n\t/** Is getxattr not implemented by fs? */\n\tunsigned no_getxattr:1;\n\n\t/** Is listxattr not implemented by fs? */\n\tunsigned no_listxattr:1;\n\n\t/** Is removexattr not implemented by fs? */\n\tunsigned no_removexattr:1;\n\n\t/** Are posix file locking primitives not implemented by fs? */\n\tunsigned no_lock:1;\n\n\t/** Is access not implemented by fs? */\n\tunsigned no_access:1;\n\n\t/** Is create not implemented by fs? */\n\tunsigned no_create:1;\n\n\t/** Is interrupt not implemented by fs? */\n\tunsigned no_interrupt:1;\n\n\t/** Is bmap not implemented by fs? */\n\tunsigned no_bmap:1;\n\n\t/** Is poll not implemented by fs? */\n\tunsigned no_poll:1;\n\n\t/** Do multi-page cached writes */\n\tunsigned big_writes:1;\n\n\t/** Don't apply umask to creation modes */\n\tunsigned dont_mask:1;\n\n\t/** Are BSD file locking primitives not implemented by fs? */\n\tunsigned no_flock:1;\n\n\t/** The number of requests waiting for completion */\n\tatomic_t num_waiting;\n\n\t/** Negotiated minor version */\n\tunsigned minor;\n\n\t/** Backing dev info */\n\tstruct backing_dev_info bdi;\n\n\t/** Entry on the fuse_conn_list */\n\tstruct list_head entry;\n\n\t/** Device ID from super block */\n\tdev_t dev;\n\n\t/** Dentries in the control filesystem */\n\tstruct dentry *ctl_dentry[FUSE_CTL_NUM_DENTRIES];\n\n\t/** number of dentries used in the above array */\n\tint ctl_ndents;\n\n\t/** O_ASYNC requests */\n\tstruct fasync_struct *fasync;\n\n\t/** Key for lock owner ID scrambling */\n\tu32 scramble_key[4];\n\n\t/** Reserved request for the DESTROY message */\n\tstruct fuse_req *destroy_req;\n\n\t/** Version counter for attribute changes */\n\tu64 attr_version;\n\n\t/** Called on final put */\n\tvoid (*release)(struct fuse_conn *);\n\n\t/** Super block for this connection. */\n\tstruct super_block *sb;\n\n\t/** Read/write semaphore to hold when accessing sb. */\n\tstruct rw_semaphore killsb;\n}\n- fuse_notify_inval_entry_out: struct fuse_notify_inval_entry_out {\n\t__u64\tparent;\n\t__u32\tnamelen;\n\t__u32\tpadding;\n}\n\nImports:\n- #include <linux/splice.h>\n- #include <linux/init.h>\n- #include <linux/file.h>\n- #include <linux/poll.h>\n- #include <linux/pipe_fs_i.h>\n- #include <linux/miscdevice.h>\n- #include \"fuse_i.h\"\n- #include <linux/pagemap.h>\n- #include <linux/swap.h>\n- #include <linux/uio.h>\n- #include <linux/slab.h>\n- #include <linux/module.h>",
    "commit_msg": "fuse: check size of FUSE_NOTIFY_INVAL_ENTRY message\n\nFUSE_NOTIFY_INVAL_ENTRY didn't check the length of the write so the\nmessage processing could overrun and result in a \"kernel BUG at\nfs/fuse/dev.c:629!\"\n\nReported-by: Han-Wen Nienhuys <hanwenn@gmail.com>\nSigned-off-by: Miklos Szeredi <mszeredi@suse.cz>\nCC: stable@kernel.org",
    "cve_desc": "[{'lang': 'en', 'value': 'Buffer overflow in the fuse_notify_inval_entry function in fs/fuse/dev.c in the Linux kernel before 3.1 allows local users to cause a denial of service (BUG_ON and system crash) by leveraging the ability to mount a FUSE filesystem.'}]",
    "year": 2011,
    "filename": "dev.c",
    "commit_url": "\"https://github.com/torvalds/linux/commit/c2183d1e9b3f313dd8ba2b1b0197c8d9fb86a7ae\""
  },
  {
    "repository": "reubenhwk/radvd",
    "cve_id": "CVE-2011-3601",
    "cwe_list": [
      "CWE-119"
    ],
    "commit_hash": "9dfaaaf740ce784541e76e68de4ae04dce2c0921",
    "short_hash": "9dfaaaf7",
    "vulnerableMethods_before": [
      {
        "filename": "process.c",
        "method_name": "process_ra",
        "raw_code": "static void /* <=== process_ra */ \nprocess_ra(struct Interface *iface, unsigned char *msg, int len,\n\tstruct sockaddr_in6 *addr)\n{\n\tstruct nd_router_advert *radvert;\n\tchar addr_str[INET6_ADDRSTRLEN];\n\tuint8_t *opt_str;\n\n\tprint_addr(&addr->sin6_addr, addr_str);\n\n\tradvert = (struct nd_router_advert *) msg;\n\n\tif ((radvert->nd_ra_curhoplimit && iface->AdvCurHopLimit) &&\n\t   (radvert->nd_ra_curhoplimit != iface->AdvCurHopLimit))\n\t{\n\t\tflog(LOG_WARNING, \"our AdvCurHopLimit on %s doesn't agree with %s\",\n\t\t\tiface->Name, addr_str);\n\t}\n\n\tif ((radvert->nd_ra_flags_reserved & ND_RA_FLAG_MANAGED) && !iface->AdvManagedFlag)\n\t{\n\t\tflog(LOG_WARNING, \"our AdvManagedFlag on %s doesn't agree with %s\",\n\t\t\tiface->Name, addr_str);\n\t}\n\n\tif ((radvert->nd_ra_flags_reserved & ND_RA_FLAG_OTHER) && !iface->AdvOtherConfigFlag)\n\t{\n\t\tflog(LOG_WARNING, \"our AdvOtherConfigFlag on %s doesn't agree with %s\",\n\t\t\tiface->Name, addr_str);\n\t}\n\n\t/* note: we don't check the default router preference here, because they're likely different */\n\n\tif ((radvert->nd_ra_reachable && iface->AdvReachableTime) &&\n\t   (ntohl(radvert->nd_ra_reachable) != iface->AdvReachableTime))\n\t{\n\t\tflog(LOG_WARNING, \"our AdvReachableTime on %s doesn't agree with %s\",\n\t\t\tiface->Name, addr_str);\n\t}\n\n\tif ((radvert->nd_ra_retransmit && iface->AdvRetransTimer) &&\n\t   (ntohl(radvert->nd_ra_retransmit) != iface->AdvRetransTimer))\n\t{\n\t\tflog(LOG_WARNING, \"our AdvRetransTimer on %s doesn't agree with %s\",\n\t\t\tiface->Name, addr_str);\n\t}\n\n\tlen -= sizeof(struct nd_router_advert);\n\n\tif (len == 0)\n\t\treturn;\n\n\topt_str = (uint8_t *)(msg + sizeof(struct nd_router_advert));\n\n\twhile (len > 0)\n\t{\n\t\tint optlen;\n\t\tstruct nd_opt_prefix_info *pinfo;\n\t\tstruct nd_opt_rdnss_info_local *rdnssinfo;\n\t\tstruct nd_opt_dnssl_info_local *dnsslinfo;\n\t\tstruct nd_opt_mtu *mtu;\n\t\tstruct AdvPrefix *prefix;\n\t\tstruct AdvRDNSS *rdnss;\n\t\tchar prefix_str[INET6_ADDRSTRLEN];\n\t\tchar rdnss_str[INET6_ADDRSTRLEN];\n\t\tchar suffix[256];\n\t\tint offset, label_len;\n\t\tuint32_t preferred, valid, count;\n\n\t\tif (len < 2)\n\t\t{\n\t\t\tflog(LOG_ERR, \"trailing garbage in RA on %s from %s\",\n\t\t\t\tiface->Name, addr_str);\n\t\t\tbreak;\n\t\t}\n\n\t\toptlen = (opt_str[1] << 3);\n\n\t\tif (optlen == 0)\n\t\t{\n\t\t\tflog(LOG_ERR, \"zero length option in RA on %s from %s\",\n\t\t\t\tiface->Name, addr_str);\n\t\t\tbreak;\n\t\t}\n\t\telse if (optlen > len)\n\t\t{\n\t\t\tflog(LOG_ERR, \"option length greater than total\"\n\t\t\t\t\" length in RA on %s from %s\",\n\t\t\t\tiface->Name, addr_str);\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (*opt_str)\n\t\t{\n\t\tcase ND_OPT_MTU:\n\t\t\tmtu = (struct nd_opt_mtu *)opt_str;\n\n\t\t\tif (iface->AdvLinkMTU && (ntohl(mtu->nd_opt_mtu_mtu) != iface->AdvLinkMTU))\n\t\t\t{\n\t\t\t\tflog(LOG_WARNING, \"our AdvLinkMTU on %s doesn't agree with %s\",\n\t\t\t\t\tiface->Name, addr_str);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ND_OPT_PREFIX_INFORMATION:\n\t\t\tpinfo = (struct nd_opt_prefix_info *) opt_str;\n\t\t\tpreferred = ntohl(pinfo->nd_opt_pi_preferred_time);\n\t\t\tvalid = ntohl(pinfo->nd_opt_pi_valid_time);\n\n\t\t\tprefix = iface->AdvPrefixList;\n\t\t\twhile (prefix)\n\t\t\t{\n\t\t\t\tif (prefix->enabled &&\n\t\t\t\t    (prefix->PrefixLen == pinfo->nd_opt_pi_prefix_len) &&\n\t\t\t\t    addr_match(&prefix->Prefix, &pinfo->nd_opt_pi_prefix,\n\t\t\t\t    \t prefix->PrefixLen))\n\t\t\t\t{\n\t\t\t\t\tprint_addr(&prefix->Prefix, prefix_str);\n\n\t\t\t\t\tif (!prefix->DecrementLifetimesFlag && valid != prefix->AdvValidLifetime)\n\t\t\t\t\t{\n\t\t\t\t\t\tflog(LOG_WARNING, \"our AdvValidLifetime on\"\n\t\t\t\t\t\t \" %s for %s doesn't agree with %s\",\n\t\t\t\t\t\t iface->Name,\n\t\t\t\t\t\t prefix_str,\n\t\t\t\t\t\t addr_str\n\t\t\t\t\t\t );\n\t\t\t\t\t}\n\t\t\t\t\tif (!prefix->DecrementLifetimesFlag && preferred != prefix->AdvPreferredLifetime)\n\t\t\t\t\t{\n\t\t\t\t\t\tflog(LOG_WARNING, \"our AdvPreferredLifetime on\"\n\t\t\t\t\t\t \" %s for %s doesn't agree with %s\",\n\t\t\t\t\t\t iface->Name,\n\t\t\t\t\t\t prefix_str,\n\t\t\t\t\t\t addr_str\n\t\t\t\t\t\t );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tprefix = prefix->next;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ND_OPT_ROUTE_INFORMATION:\n\t\t\t/* not checked: these will very likely vary a lot */\n\t\t\tbreak;\n\t\tcase ND_OPT_SOURCE_LINKADDR:\n\t\t\t/* not checked */\n\t\t\tbreak;\n\t\tcase ND_OPT_TARGET_LINKADDR:\n\t\tcase ND_OPT_REDIRECTED_HEADER:\n\t\t\tflog(LOG_ERR, \"invalid option %d in RA on %s from %s\",\n\t\t\t\t(int)*opt_str, iface->Name, addr_str);\n\t\t\tbreak;\n\t\t/* Mobile IPv6 extensions */\n\t\tcase ND_OPT_RTR_ADV_INTERVAL:\n\t\tcase ND_OPT_HOME_AGENT_INFO:\n\t\t\t/* not checked */\n\t\t\tbreak;\n\t\tcase ND_OPT_RDNSS_INFORMATION:\n\t\t\trdnssinfo = (struct nd_opt_rdnss_info_local *) opt_str;\n\t\t\tcount = rdnssinfo->nd_opt_rdnssi_len;\n\n\t\t\t/* Check the RNDSS addresses received */\n\t\t\tswitch (count) {\n\t\t\t\tcase 7:\n\t\t\t\t\trdnss = iface->AdvRDNSSList;\n\t\t\t\t\tif (!check_rdnss_presence(rdnss, &rdnssinfo->nd_opt_rdnssi_addr3 )) {\n\t\t\t\t\t\t/* no match found in iface->AdvRDNSSList */\n\t\t\t\t\t\tprint_addr(&rdnssinfo->nd_opt_rdnssi_addr3, rdnss_str);\n\t\t\t\t\t\tflog(LOG_WARNING, \"RDNSS address %s received on %s from %s is not advertised by us\",\n\t\t\t\t\t\t\trdnss_str, iface->Name, addr_str);\n\t\t\t\t\t}\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase 5:\n\t\t\t\t\trdnss = iface->AdvRDNSSList;\n\t\t\t\t\tif (!check_rdnss_presence(rdnss, &rdnssinfo->nd_opt_rdnssi_addr2 )) {\n\t\t\t\t\t\t/* no match found in iface->AdvRDNSSList */\n\t\t\t\t\t\tprint_addr(&rdnssinfo->nd_opt_rdnssi_addr2, rdnss_str);\n\t\t\t\t\t\tflog(LOG_WARNING, \"RDNSS address %s received on %s from %s is not advertised by us\",\n\t\t\t\t\t\t\trdnss_str, iface->Name, addr_str);\n\t\t\t\t\t}\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase 3:\n\t\t\t\t\trdnss = iface->AdvRDNSSList;\n\t\t\t\t\tif (!check_rdnss_presence(rdnss, &rdnssinfo->nd_opt_rdnssi_addr1 )) {\n\t\t\t\t\t\t/* no match found in iface->AdvRDNSSList */\n\t\t\t\t\t\tprint_addr(&rdnssinfo->nd_opt_rdnssi_addr1, rdnss_str);\n\t\t\t\t\t\tflog(LOG_WARNING, \"RDNSS address %s received on %s from %s is not advertised by us\",\n\t\t\t\t\t\t\trdnss_str, iface->Name, addr_str);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tflog(LOG_ERR, \"invalid len %i in RDNSS option on %s from %s\",\n\t\t\t\t\t\t\tcount, iface->Name, addr_str);\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase ND_OPT_DNSSL_INFORMATION:\n\t\t\tdnsslinfo = (struct nd_opt_dnssl_info_local *) opt_str;\n\t\t\tsuffix[0] = '\\0';\n\t\t\tfor (offset = 0; offset < (dnsslinfo->nd_opt_dnssli_len-1)*8;) {\n\t\t\t\tlabel_len = dnsslinfo->nd_opt_dnssli_suffixes[offset++];\n\n\t\t\t\tif (label_len == 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Ignore empty suffixes. They're\n\t\t\t\t\t * probably just padding...\n\t\t\t\t\t */\n\t\t\t\t\tif (suffix[0] == '\\0')\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (!check_dnssl_presence(iface->AdvDNSSLList, suffix)) {\n\t\t\t\t\t\tflog(LOG_WARNING, \"DNSSL suffix %s received on %s from %s is not advertised by us\",\n\t\t\t\t\t\t\tsuffix, iface->Name, addr_str);\n\t\t\t\t\t}\n\n\t\t\t\t\tsuffix[0] = '\\0';\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif ((sizeof(suffix) - strlen(suffix)) < (label_len + 2)) {\n\t\t\t\t\tflog(LOG_ERR, \"oversized suffix in DNSSL option on %s from %s\",\n\t\t\t\t\t\t\tiface->Name, addr_str);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (suffix[0] != '\\0')\n\t\t\t\t\tstrcat(suffix, \".\");\n\t\t\t\tstrncat(suffix, &dnsslinfo->nd_opt_dnssli_suffixes[offset], label_len);\n\t\t\t\toffset += label_len;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdlog(LOG_DEBUG, 1, \"unknown option %d in RA on %s from %s\",\n\t\t\t\t(int)*opt_str, iface->Name, addr_str);\n\t\t\tbreak;\n\t\t}\n\n\t\tlen -= optlen;\n\t\topt_str += optlen;\n\t}\n}",
        "start_line": 217
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "process.c",
        "method_name": "process_ra",
        "raw_code": "static void /* <=== process_ra */ \nprocess_ra(struct Interface *iface, unsigned char *msg, int len,\n\tstruct sockaddr_in6 *addr)\n{\n\tstruct nd_router_advert *radvert;\n\tchar addr_str[INET6_ADDRSTRLEN];\n\tuint8_t *opt_str;\n\n\tprint_addr(&addr->sin6_addr, addr_str);\n\n\tradvert = (struct nd_router_advert *) msg;\n\n\tif ((radvert->nd_ra_curhoplimit && iface->AdvCurHopLimit) &&\n\t   (radvert->nd_ra_curhoplimit != iface->AdvCurHopLimit))\n\t{\n\t\tflog(LOG_WARNING, \"our AdvCurHopLimit on %s doesn't agree with %s\",\n\t\t\tiface->Name, addr_str);\n\t}\n\n\tif ((radvert->nd_ra_flags_reserved & ND_RA_FLAG_MANAGED) && !iface->AdvManagedFlag)\n\t{\n\t\tflog(LOG_WARNING, \"our AdvManagedFlag on %s doesn't agree with %s\",\n\t\t\tiface->Name, addr_str);\n\t}\n\n\tif ((radvert->nd_ra_flags_reserved & ND_RA_FLAG_OTHER) && !iface->AdvOtherConfigFlag)\n\t{\n\t\tflog(LOG_WARNING, \"our AdvOtherConfigFlag on %s doesn't agree with %s\",\n\t\t\tiface->Name, addr_str);\n\t}\n\n\t/* note: we don't check the default router preference here, because they're likely different */\n\n\tif ((radvert->nd_ra_reachable && iface->AdvReachableTime) &&\n\t   (ntohl(radvert->nd_ra_reachable) != iface->AdvReachableTime))\n\t{\n\t\tflog(LOG_WARNING, \"our AdvReachableTime on %s doesn't agree with %s\",\n\t\t\tiface->Name, addr_str);\n\t}\n\n\tif ((radvert->nd_ra_retransmit && iface->AdvRetransTimer) &&\n\t   (ntohl(radvert->nd_ra_retransmit) != iface->AdvRetransTimer))\n\t{\n\t\tflog(LOG_WARNING, \"our AdvRetransTimer on %s doesn't agree with %s\",\n\t\t\tiface->Name, addr_str);\n\t}\n\n\tlen -= sizeof(struct nd_router_advert);\n\n\tif (len == 0)\n\t\treturn;\n\n\topt_str = (uint8_t *)(msg + sizeof(struct nd_router_advert));\n\n\twhile (len > 0)\n\t{\n\t\tint optlen;\n\t\tstruct nd_opt_prefix_info *pinfo;\n\t\tstruct nd_opt_rdnss_info_local *rdnssinfo;\n\t\tstruct nd_opt_dnssl_info_local *dnsslinfo;\n\t\tstruct nd_opt_mtu *mtu;\n\t\tstruct AdvPrefix *prefix;\n\t\tstruct AdvRDNSS *rdnss;\n\t\tchar prefix_str[INET6_ADDRSTRLEN];\n\t\tchar rdnss_str[INET6_ADDRSTRLEN];\n\t\tchar suffix[256];\n\t\tunsigned int offset, label_len;\n\t\tuint32_t preferred, valid, count;\n\n\t\tif (len < 2)\n\t\t{\n\t\t\tflog(LOG_ERR, \"trailing garbage in RA on %s from %s\",\n\t\t\t\tiface->Name, addr_str);\n\t\t\tbreak;\n\t\t}\n\n\t\toptlen = (opt_str[1] << 3);\n\n\t\tif (optlen == 0)\n\t\t{\n\t\t\tflog(LOG_ERR, \"zero length option in RA on %s from %s\",\n\t\t\t\tiface->Name, addr_str);\n\t\t\tbreak;\n\t\t}\n\t\telse if (optlen > len)\n\t\t{\n\t\t\tflog(LOG_ERR, \"option length greater than total\"\n\t\t\t\t\" length in RA on %s from %s\",\n\t\t\t\tiface->Name, addr_str);\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (*opt_str)\n\t\t{\n\t\tcase ND_OPT_MTU:\n\t\t\tmtu = (struct nd_opt_mtu *)opt_str;\n\n\t\t\tif (iface->AdvLinkMTU && (ntohl(mtu->nd_opt_mtu_mtu) != iface->AdvLinkMTU))\n\t\t\t{\n\t\t\t\tflog(LOG_WARNING, \"our AdvLinkMTU on %s doesn't agree with %s\",\n\t\t\t\t\tiface->Name, addr_str);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ND_OPT_PREFIX_INFORMATION:\n\t\t\tpinfo = (struct nd_opt_prefix_info *) opt_str;\n\t\t\tpreferred = ntohl(pinfo->nd_opt_pi_preferred_time);\n\t\t\tvalid = ntohl(pinfo->nd_opt_pi_valid_time);\n\n\t\t\tprefix = iface->AdvPrefixList;\n\t\t\twhile (prefix)\n\t\t\t{\n\t\t\t\tif (prefix->enabled &&\n\t\t\t\t    (prefix->PrefixLen == pinfo->nd_opt_pi_prefix_len) &&\n\t\t\t\t    addr_match(&prefix->Prefix, &pinfo->nd_opt_pi_prefix,\n\t\t\t\t    \t prefix->PrefixLen))\n\t\t\t\t{\n\t\t\t\t\tprint_addr(&prefix->Prefix, prefix_str);\n\n\t\t\t\t\tif (!prefix->DecrementLifetimesFlag && valid != prefix->AdvValidLifetime)\n\t\t\t\t\t{\n\t\t\t\t\t\tflog(LOG_WARNING, \"our AdvValidLifetime on\"\n\t\t\t\t\t\t \" %s for %s doesn't agree with %s\",\n\t\t\t\t\t\t iface->Name,\n\t\t\t\t\t\t prefix_str,\n\t\t\t\t\t\t addr_str\n\t\t\t\t\t\t );\n\t\t\t\t\t}\n\t\t\t\t\tif (!prefix->DecrementLifetimesFlag && preferred != prefix->AdvPreferredLifetime)\n\t\t\t\t\t{\n\t\t\t\t\t\tflog(LOG_WARNING, \"our AdvPreferredLifetime on\"\n\t\t\t\t\t\t \" %s for %s doesn't agree with %s\",\n\t\t\t\t\t\t iface->Name,\n\t\t\t\t\t\t prefix_str,\n\t\t\t\t\t\t addr_str\n\t\t\t\t\t\t );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tprefix = prefix->next;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ND_OPT_ROUTE_INFORMATION:\n\t\t\t/* not checked: these will very likely vary a lot */\n\t\t\tbreak;\n\t\tcase ND_OPT_SOURCE_LINKADDR:\n\t\t\t/* not checked */\n\t\t\tbreak;\n\t\tcase ND_OPT_TARGET_LINKADDR:\n\t\tcase ND_OPT_REDIRECTED_HEADER:\n\t\t\tflog(LOG_ERR, \"invalid option %d in RA on %s from %s\",\n\t\t\t\t(int)*opt_str, iface->Name, addr_str);\n\t\t\tbreak;\n\t\t/* Mobile IPv6 extensions */\n\t\tcase ND_OPT_RTR_ADV_INTERVAL:\n\t\tcase ND_OPT_HOME_AGENT_INFO:\n\t\t\t/* not checked */\n\t\t\tbreak;\n\t\tcase ND_OPT_RDNSS_INFORMATION:\n\t\t\trdnssinfo = (struct nd_opt_rdnss_info_local *) opt_str;\n\t\t\tcount = rdnssinfo->nd_opt_rdnssi_len;\n\n\t\t\t/* Check the RNDSS addresses received */\n\t\t\tswitch (count) {\n\t\t\t\tcase 7:\n\t\t\t\t\trdnss = iface->AdvRDNSSList;\n\t\t\t\t\tif (!check_rdnss_presence(rdnss, &rdnssinfo->nd_opt_rdnssi_addr3 )) {\n\t\t\t\t\t\t/* no match found in iface->AdvRDNSSList */\n\t\t\t\t\t\tprint_addr(&rdnssinfo->nd_opt_rdnssi_addr3, rdnss_str);\n\t\t\t\t\t\tflog(LOG_WARNING, \"RDNSS address %s received on %s from %s is not advertised by us\",\n\t\t\t\t\t\t\trdnss_str, iface->Name, addr_str);\n\t\t\t\t\t}\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase 5:\n\t\t\t\t\trdnss = iface->AdvRDNSSList;\n\t\t\t\t\tif (!check_rdnss_presence(rdnss, &rdnssinfo->nd_opt_rdnssi_addr2 )) {\n\t\t\t\t\t\t/* no match found in iface->AdvRDNSSList */\n\t\t\t\t\t\tprint_addr(&rdnssinfo->nd_opt_rdnssi_addr2, rdnss_str);\n\t\t\t\t\t\tflog(LOG_WARNING, \"RDNSS address %s received on %s from %s is not advertised by us\",\n\t\t\t\t\t\t\trdnss_str, iface->Name, addr_str);\n\t\t\t\t\t}\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase 3:\n\t\t\t\t\trdnss = iface->AdvRDNSSList;\n\t\t\t\t\tif (!check_rdnss_presence(rdnss, &rdnssinfo->nd_opt_rdnssi_addr1 )) {\n\t\t\t\t\t\t/* no match found in iface->AdvRDNSSList */\n\t\t\t\t\t\tprint_addr(&rdnssinfo->nd_opt_rdnssi_addr1, rdnss_str);\n\t\t\t\t\t\tflog(LOG_WARNING, \"RDNSS address %s received on %s from %s is not advertised by us\",\n\t\t\t\t\t\t\trdnss_str, iface->Name, addr_str);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tflog(LOG_ERR, \"invalid len %i in RDNSS option on %s from %s\",\n\t\t\t\t\t\t\tcount, iface->Name, addr_str);\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase ND_OPT_DNSSL_INFORMATION:\n\t\t\tdnsslinfo = (struct nd_opt_dnssl_info_local *) opt_str;\n\t\t\tsuffix[0] = '\\0';\n\t\t\tfor (offset = 0; offset < (dnsslinfo->nd_opt_dnssli_len-1)*8;) {\n\t\t\t\tlabel_len = dnsslinfo->nd_opt_dnssli_suffixes[offset++];\n\n\t\t\t\tif (label_len == 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Ignore empty suffixes. They're\n\t\t\t\t\t * probably just padding...\n\t\t\t\t\t */\n\t\t\t\t\tif (suffix[0] == '\\0')\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (!check_dnssl_presence(iface->AdvDNSSLList, suffix)) {\n\t\t\t\t\t\tflog(LOG_WARNING, \"DNSSL suffix %s received on %s from %s is not advertised by us\",\n\t\t\t\t\t\t\tsuffix, iface->Name, addr_str);\n\t\t\t\t\t}\n\n\t\t\t\t\tsuffix[0] = '\\0';\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * 1) must not overflow int: label + 2, offset + label_len\n\t\t\t\t * 2) last byte of dnssli_suffix must not overflow opt_str + len\n\t\t\t\t */\n\t\t\t\tif ((sizeof(suffix) - strlen(suffix)) < (label_len + 2) ||\n\t\t\t\t    label_len > label_len + 2 ||\n\t\t\t\t    &dnsslinfo->nd_opt_dnssli_suffixes[offset+label_len] - (char*)opt_str >= len ||\n\t\t\t\t    offset + label_len < offset) {\n\t\t\t\t\tflog(LOG_ERR, \"oversized suffix in DNSSL option on %s from %s\",\n\t\t\t\t\t\t\tiface->Name, addr_str);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (suffix[0] != '\\0')\n\t\t\t\t\tstrcat(suffix, \".\");\n\t\t\t\tstrncat(suffix, &dnsslinfo->nd_opt_dnssli_suffixes[offset], label_len);\n\t\t\t\toffset += label_len;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdlog(LOG_DEBUG, 1, \"unknown option %d in RA on %s from %s\",\n\t\t\t\t(int)*opt_str, iface->Name, addr_str);\n\t\t\tbreak;\n\t\t}\n\n\t\tlen -= optlen;\n\t\topt_str += optlen;\n\t}\n}",
        "start_line": 217
      }
    ],
    "code_context": "Called Methods:\n- ND_OPT_RDNSS_INFORMATION: #define  ND_OPT_RDNSS_INFORMATION\t25 /* <=== defaults.h:172:172:ND_OPT_RDNSS_INFORMATION:0 */ \n- ND_OPT_HOME_AGENT_INFO: #define ND_OPT_HOME_AGENT_INFO          8 /* <=== defaults.h:148:148:ND_OPT_HOME_AGENT_INFO:0 */ \n- ND_OPT_RTR_ADV_INTERVAL: #define ND_OPT_RTR_ADV_INTERVAL         7 /* <=== defaults.h:145:145:ND_OPT_RTR_ADV_INTERVAL:0 */ \n- ND_OPT_DNSSL_INFORMATION: #define  ND_OPT_DNSSL_INFORMATION\t31 /* <=== defaults.h:194:194:ND_OPT_DNSSL_INFORMATION:0 */ \n- flog: void /* <=== flog */ \nflog(int prio, char *format, ...)\n{\n\tva_list ap;\n\tint res;\n\n\tva_start(ap, format);\n\tres = vlog(prio, format, ap);\n\tva_end(ap);\n\n\t/* XXX: should we do something if res < 0.. */\n}\n- ND_OPT_ROUTE_INFORMATION: #define  ND_OPT_ROUTE_INFORMATION\t24 /* <=== defaults.h:154:154:ND_OPT_ROUTE_INFORMATION:0 */ \n- check_dnssl_presence: int /* <=== check_dnssl_presence */ \ncheck_dnssl_presence(struct AdvDNSSL *dnssl, const char *suffix)\n{\n\tint i;\n\twhile (dnssl) {\n\t\tfor (i = 0; i < dnssl->AdvDNSSLNumber; i++) {\n\t\t\tif (strcmp(dnssl->AdvDNSSLSuffixes[i], suffix) == 0)\n\t\t\t\tbreak; /* suffix found in the list */\n\t\t}\n\t\tif (i != dnssl->AdvDNSSLNumber)\n\t\t\tbreak;\n\n\t\tdnssl = dnssl->next; /* no match */\n\t}\n\treturn (dnssl != NULL);\n}\n- addr_match: static int /* <=== addr_match */ \naddr_match(struct in6_addr *a1, struct in6_addr *a2, int prefixlen)\n{\n\tunsigned int pdw;\n\tunsigned int pbi;\n\n\tpdw = prefixlen >> 0x05;  /* num of whole uint32_t in prefix */\n\tpbi = prefixlen &  0x1f;  /* num of bits in incomplete uint32_t in prefix */\n\n\tif (pdw)\n\t{\n\t\tif (memcmp(a1, a2, pdw << 2))\n\t\t\treturn 0;\n\t}\n\n\tif (pbi)\n\t{\n\t\tuint32_t w1, w2;\n\t\tuint32_t mask;\n\n\t\tw1 = *((uint32_t *)a1 + pdw);\n\t\tw2 = *((uint32_t *)a2 + pdw);\n\n\t\tmask = htonl(((uint32_t) 0xffffffff) << (0x20 - pbi));\n\n\t\tif ((w1 ^ w2) & mask)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n- vlog: static int /* <=== vlog */ \nvlog(int prio, char *format, va_list ap)\n{\n\tchar tstamp[64], buff[1024];\n\tstruct tm *tm;\n\ttime_t current;\n\n\tvsnprintf(buff, sizeof(buff), format, ap);\n\n\tswitch (log_method) {\n\t\tcase L_NONE:\n\t\t\tbreak;\n\t\tcase L_SYSLOG:\n\t\t\tsyslog(prio, \"%s\", buff);\n\t\t\tbreak;\n\t\tcase L_STDERR_SYSLOG:\n\t\t\tsyslog(prio, \"%s\", buff);\n\t\t\tif (prio > LOG_ERR) /* fall through for messages with high priority */\n\t\t\t\tbreak;\n\t\tcase L_STDERR:\n\t\t\tcurrent = time(NULL);\n\t\t\ttm = localtime(&current);\n\t\t\t(void) strftime(tstamp, sizeof(tstamp), LOG_TIME_FORMAT, tm);\n\n\t\t\tfprintf(stderr, \"[%s] %s: %s\\n\", tstamp, log_ident, buff);\n    \t\t\tfflush(stderr);\n\t\t\tbreak;\n\t\tcase L_LOGFILE:\n\t\t\tcurrent = time(NULL);\n\t\t\ttm = localtime(&current);\n\t\t\t(void) strftime(tstamp, sizeof(tstamp), LOG_TIME_FORMAT, tm);\n\n\t\t\tfprintf(log_file_fd, \"[%s] %s: %s\\n\", tstamp, log_ident, buff);\n    \t\t\tfflush(log_file_fd);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"%s: unknown logging method: %d\\n\", log_ident, log_method);\n\t\t\tlog_method = L_NONE;\n\t\t\treturn (-1);\n\t}\n\treturn 0;\n}\n- print_addr: void /* <=== print_addr */ \nprint_addr(struct in6_addr *addr, char *str)\n{\n\tconst char *res;\n\n\t/* XXX: overflows 'str' if it isn't big enough */\n\tres = inet_ntop(AF_INET6, (void *)addr, str, INET6_ADDRSTRLEN);\n\n\tif (res == NULL)\n\t{\n\t\tflog(LOG_ERR, \"print_addr: inet_ntop: %s\", strerror(errno));\n\t\tstrcpy(str, \"[invalid address]\");\n\t}\n}\n- dlog: void /* <=== dlog */ \ndlog(int prio, int level, char *format, ...)\n{\n\tva_list ap;\n\tint res;\n\n\tif (debug_level < level)\n\t\treturn;\n\n\tva_start(ap, format);\n\tres = vlog(prio, format, ap);\n\tva_end(ap);\n\n\t/* XXX: should we do something if res < 0.. */\n}\n- check_rdnss_presence: int /* <=== check_rdnss_presence */ \ncheck_rdnss_presence(struct AdvRDNSS *rdnss, struct in6_addr *addr)\n{\n\twhile (rdnss) {\n\t\tif (    !memcmp(&rdnss->AdvRDNSSAddr1, addr, sizeof(struct in6_addr))\n\t\t     || !memcmp(&rdnss->AdvRDNSSAddr2, addr, sizeof(struct in6_addr))\n\t\t     || !memcmp(&rdnss->AdvRDNSSAddr3, addr, sizeof(struct in6_addr)) )\n\t\t\tbreak; /* rdnss address found in the list */\n\t\telse\n\t\t\trdnss = rdnss->next; /* no match */\n\t}\n\treturn (rdnss != NULL);\n}\n\nType Definitions:\n- nd_opt_dnssl_info_local: struct nd_opt_dnssl_info_local\n{\n\tuint8_t   \t\t\tnd_opt_dnssli_type;\n\tuint8_t   \t\t\tnd_opt_dnssli_len;\n\tuint16_t   \t\t\tnd_opt_dnssli_reserved;\n\tuint32_t\t\t\tnd_opt_dnssli_lifetime;\n\tchar\t\t\t\tnd_opt_dnssli_suffixes[];\n}\n- AdvRDNSS: struct AdvRDNSS {\n\tint \t\t\tAdvRDNSSNumber;\n\tuint32_t\t\tAdvRDNSSLifetime;\n\tint\t\t\tFlushRDNSSFlag;\n\tstruct in6_addr\t\tAdvRDNSSAddr1;\n\tstruct in6_addr\t\tAdvRDNSSAddr2;\n\tstruct in6_addr\t\tAdvRDNSSAddr3;\n\n\tstruct AdvRDNSS \t*next;\n}\n- nd_opt_rdnss_info_local: struct nd_opt_rdnss_info_local\n{\n\tuint8_t   \t\t\tnd_opt_rdnssi_type;\n\tuint8_t   \t\t\tnd_opt_rdnssi_len;\n\tuint16_t   \t\t\tnd_opt_rdnssi_pref_flag_reserved;\n\tuint32_t\t\t\tnd_opt_rdnssi_lifetime;\n\tstruct in6_addr\t\tnd_opt_rdnssi_addr1;\n\tstruct in6_addr\t\tnd_opt_rdnssi_addr2;\n\tstruct in6_addr\t\tnd_opt_rdnssi_addr3;\n}\n- AdvPrefix: struct AdvPrefix {\n\tstruct in6_addr\t\tPrefix;\n\tuint8_t\t\t\tPrefixLen;\n\n\tint\t\t\tAdvOnLinkFlag;\n\tint\t\t\tAdvAutonomousFlag;\n\tuint32_t\t\tAdvValidLifetime;\n\tuint32_t\t\tAdvPreferredLifetime;\n\tint\t\t\tDeprecatePrefixFlag;\n\tint\t\t\tDecrementLifetimesFlag;\n\n\tuint32_t\t\tcurr_validlft;\n\tuint32_t\t\tcurr_preferredlft;\n\n\t/* Mobile IPv6 extensions */\n\tint             \tAdvRouterAddr;\n\n\t/* 6to4 etc. extensions */\n\tchar\t\t\tif6to4[IFNAMSIZ];\n\tint\t\t\tenabled;\n\tint\t\t\tAutoSelected;\n\n\t/* Select prefixes from this interface. */\n\tchar\t\t\tif6[IFNAMSIZ];\n\n\tstruct AdvPrefix\t*next;\n}\n- AdvPrefix: struct AdvPrefix\n- AdvRDNSS: struct AdvRDNSS\n- Interface: struct Interface {\n\tchar\t\t\tName[IFNAMSIZ];\t/* interface name */\n\n\tstruct in6_addr\t\tif_addr;\n\tunsigned int\t\tif_index;\n\n\tuint8_t\t\t\tinit_racount;\t/* Initial RAs */\n\n\tuint8_t\t\t\tif_hwaddr[HWADDR_MAX];\n\tint\t\t\tif_hwaddr_len;\n\tint\t\t\tif_prefix_len;\n\tint\t\t\tif_maxmtu;\n\n\tint\t\t\tcease_adv;\n\n\tstruct timeval\t\tlast_ra_time;\n\n\tint\t\t\tIgnoreIfMissing;\n\tint\t\t\tAdvSendAdvert;\n\tdouble\t\t\tMaxRtrAdvInterval;\n\tdouble\t\t\tMinRtrAdvInterval;\n\tdouble\t\t\tMinDelayBetweenRAs;\n\tint\t\t\tAdvManagedFlag;\n\tint\t\t\tAdvOtherConfigFlag;\n\tuint32_t\t\tAdvLinkMTU;\n\tuint32_t\t\tAdvReachableTime;\n\tuint32_t\t\tAdvRetransTimer;\n\tuint8_t\t\t\tAdvCurHopLimit;\n\tint32_t\t\t\tAdvDefaultLifetime;   /* XXX: really uint16_t but we need to use -1 */\n\tint\t\t\tAdvDefaultPreference;\n\tint\t\t\tAdvSourceLLAddress;\n\tint\t\t\tUnicastOnly;\n\n\t/* Mobile IPv6 extensions */\n\tint\t\t\tAdvIntervalOpt;\n\tint\t\t\tAdvHomeAgentInfo;\n\tint\t\t\tAdvHomeAgentFlag;\n\tuint16_t\t\tHomeAgentPreference;\n\tint32_t\t\t\tHomeAgentLifetime;    /* XXX: really uint16_t but we need to use -1 */\n\n\t/* NEMO extensions */\n\tint\t\t\tAdvMobRtrSupportFlag;\n\n\tstruct AdvPrefix\t*AdvPrefixList;\n\tstruct AdvRoute\t\t*AdvRouteList;\n\tstruct AdvRDNSS\t\t*AdvRDNSSList;\n\tstruct AdvDNSSL\t\t*AdvDNSSLList;\n\tstruct Clients\t\t*ClientList;\n\tstruct timeval\t\tlast_multicast;\n\tstruct timeval\t\tnext_multicast;\n\n\t/* Info whether this interface has failed in the past (and may need to be reinitialized) */\n\tint\t\t\tHasFailed;\n\n\tstruct Interface\t*next;\n}\n- Interface: struct Interface\n\nImports:\n- #include \"radvd.h\"\n- #include \"includes.h\"\n- #include \"config.h\"",
    "commit_msg": "In process_ra() ND_OPT_DNSSL_INFORMATION option parsing \"label_len\"\nis not checked for negativeness;  it leads to \"suffix\" buffer overflow,\nwhich leads to privilege escalation (at least with -fno-stack-protector,\nI didn't discover whether it's possible with -fstack-protector).",
    "cve_desc": "Buffer overflow in the process_ra function in the router advertisement daemon (radvd) before 1.8.2 allows remote attackers to execute arbitrary code or cause a denial of service (crash) via a negative value in a label_len value.",
    "year": 2011,
    "filename": "process.c",
    "commit_url": "\"https://github.com/reubenhwk/radvd/commit/9dfaaaf740ce784541e76e68de4ae04dce2c0921\""
  },
  {
    "repository": "reubenhwk/radvd",
    "cve_id": "CVE-2011-3602",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "92e22ca23e52066da2258df8c76a2dca8a428bcc",
    "short_hash": "92e22ca2",
    "vulnerableMethods_before": [
      {
        "filename": "device-linux.c",
        "method_name": "set_interface_var",
        "raw_code": "int /* <=== set_interface_var */ \nset_interface_var(const char *iface,\n\t\t  const char *var, const char *name,\n\t\t  uint32_t val)\n{\n\tFILE *fp;\n\tchar spath[64+IFNAMSIZ];\t/* XXX: magic constant */\n\tif (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))\n\t\treturn -1;\n\n\tif (access(spath, F_OK) != 0)\n\t\treturn -1;\n\n\tfp = fopen(spath, \"w\");\n\tif (!fp) {\n\t\tif (name)\n\t\t\tflog(LOG_ERR, \"failed to set %s (%u) for %s: %s\",\n\t\t\t     name, val, iface, strerror(errno));\n\t\treturn -1;\n\t}\n\tfprintf(fp, \"%u\", val);\n\tfclose(fp);\n\n\treturn 0;\n}",
        "start_line": 236
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "device-linux.c",
        "method_name": "set_interface_var",
        "raw_code": "int /* <=== set_interface_var */ \nset_interface_var(const char *iface,\n\t\t  const char *var, const char *name,\n\t\t  uint32_t val)\n{\n\tFILE *fp;\n\tchar spath[64+IFNAMSIZ];\t/* XXX: magic constant */\n\tif (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))\n\t\treturn -1;\n\n\t/* No path traversal */\n\tif (strstr(name, \"..\") || strchr(name, '/'))\n\t\treturn -1;\n\n\tif (access(spath, F_OK) != 0)\n\t\treturn -1;\n\n\tfp = fopen(spath, \"w\");\n\tif (!fp) {\n\t\tif (name)\n\t\t\tflog(LOG_ERR, \"failed to set %s (%u) for %s: %s\",\n\t\t\t     name, val, iface, strerror(errno));\n\t\treturn -1;\n\t}\n\tfprintf(fp, \"%u\", val);\n\tfclose(fp);\n\n\treturn 0;\n}",
        "start_line": 236
      }
    ],
    "code_context": "Called Methods:\n- flog: void /* <=== flog */ \nflog(int prio, char *format, ...)\n{\n\tva_list ap;\n\tint res;\n\n\tva_start(ap, format);\n\tres = vlog(prio, format, ap);\n\tva_end(ap);\n\n\t/* XXX: should we do something if res < 0.. */\n}\n- vlog: static int /* <=== vlog */ \nvlog(int prio, char *format, va_list ap)\n{\n\tchar tstamp[64], buff[1024];\n\tstruct tm *tm;\n\ttime_t current;\n\n\tvsnprintf(buff, sizeof(buff), format, ap);\n\n\tswitch (log_method) {\n\t\tcase L_NONE:\n\t\t\tbreak;\n\t\tcase L_SYSLOG:\n\t\t\tsyslog(prio, \"%s\", buff);\n\t\t\tbreak;\n\t\tcase L_STDERR_SYSLOG:\n\t\t\tsyslog(prio, \"%s\", buff);\n\t\t\tif (prio > LOG_ERR) /* fall through for messages with high priority */\n\t\t\t\tbreak;\n\t\tcase L_STDERR:\n\t\t\tcurrent = time(NULL);\n\t\t\ttm = localtime(&current);\n\t\t\t(void) strftime(tstamp, sizeof(tstamp), LOG_TIME_FORMAT, tm);\n\n\t\t\tfprintf(stderr, \"[%s] %s: %s\\n\", tstamp, log_ident, buff);\n    \t\t\tfflush(stderr);\n\t\t\tbreak;\n\t\tcase L_LOGFILE:\n\t\t\tcurrent = time(NULL);\n\t\t\ttm = localtime(&current);\n\t\t\t(void) strftime(tstamp, sizeof(tstamp), LOG_TIME_FORMAT, tm);\n\n\t\t\tfprintf(log_file_fd, \"[%s] %s: %s\\n\", tstamp, log_ident, buff);\n    \t\t\tfflush(log_file_fd);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"%s: unknown logging method: %d\\n\", log_ident, log_method);\n\t\t\tlog_method = L_NONE;\n\t\t\treturn (-1);\n\t}\n\treturn 0;\n}\n\nImports:\n- #include \"config.h\"\n- #include \"defaults.h\"\n- #include \"pathnames.h\"\n- #include \"includes.h\"\n- #include \"radvd.h\"",
    "commit_msg": "set_interface_var() doesn't check interface name and blindly does\nfopen(path \"/\" ifname, \"w\") on it.  As \"ifname\" is an untrusted input, it\nshould be checked for \"..\" and/or \"/\" in it.  Otherwise, an infected\nunprivileged daemon may overwrite contents of file named \"mtu\",\n\"hoplimit\", etc. in arbitrary location with arbitrary 32-bit value in\ndecimal representation (\"%d\").  If an attacker has a local account or\nmay create arbitrary symlinks with these names in any location (e.g.\n/tmp), any file may be overwritten with a decimal value.",
    "cve_desc": "Directory traversal vulnerability in device-linux.c in the router advertisement daemon (radvd) before 1.8.2 allows local users to overwrite arbitrary files, and remote attackers to overwrite certain files, via a .. (dot dot) in an interface name.  NOTE: this can be leveraged with a symlink to overwrite arbitrary files.",
    "year": 2011,
    "filename": "device-linux.c",
    "commit_url": "\"https://github.com/reubenhwk/radvd/commit/92e22ca23e52066da2258df8c76a2dca8a428bcc\""
  },
  {
    "repository": "reubenhwk/radvd",
    "cve_id": "CVE-2011-3603",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "2c50375043186e133f15135f4c93ca964238ee60",
    "short_hash": "2c503750",
    "vulnerableMethods_before": [
      {
        "filename": "radvd.c",
        "method_name": "main",
        "raw_code": "int /* <=== main */ \nmain(int argc, char *argv[])\n{\n\tchar pidstr[16];\n\tssize_t ret;\n\tint c, log_method;\n\tchar *logfile, *pidfile;\n\tint facility, fd;\n\tchar *username = NULL;\n\tchar *chrootdir = NULL;\n\tint configtest = 0;\n\tint singleprocess = 0;\n#ifdef HAVE_GETOPT_LONG\n\tint opt_idx;\n#endif\n\n\tpname = ((pname=strrchr(argv[0],'/')) != NULL)?pname+1:argv[0];\n\n\tsrand((unsigned int)time(NULL));\n\n\tlog_method = L_STDERR_SYSLOG;\n\tlogfile = PATH_RADVD_LOG;\n\tconf_file = PATH_RADVD_CONF;\n\tfacility = LOG_FACILITY;\n\tpidfile = PATH_RADVD_PID;\n\n\t/* parse args */\n#define OPTIONS_STR \"d:C:l:m:p:t:u:vhcs\"\n#ifdef HAVE_GETOPT_LONG\n\twhile ((c = getopt_long(argc, argv, OPTIONS_STR, prog_opt, &opt_idx)) > 0)\n#else\n\twhile ((c = getopt(argc, argv, OPTIONS_STR)) > 0)\n#endif\n\t{\n\t\tswitch (c) {\n\t\tcase 'C':\n\t\t\tconf_file = optarg;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tset_debuglevel(atoi(optarg));\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tfacility = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlogfile = optarg;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tpidfile = optarg;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tif (!strcmp(optarg, \"syslog\"))\n\t\t\t{\n\t\t\t\tlog_method = L_SYSLOG;\n\t\t\t}\n\t\t\telse if (!strcmp(optarg, \"stderr_syslog\"))\n\t\t\t{\n\t\t\t\tlog_method = L_STDERR_SYSLOG;\n\t\t\t}\n\t\t\telse if (!strcmp(optarg, \"stderr\"))\n\t\t\t{\n\t\t\t\tlog_method = L_STDERR;\n\t\t\t}\n\t\t\telse if (!strcmp(optarg, \"logfile\"))\n\t\t\t{\n\t\t\t\tlog_method = L_LOGFILE;\n\t\t\t}\n\t\t\telse if (!strcmp(optarg, \"none\"))\n\t\t\t{\n\t\t\t\tlog_method = L_NONE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfprintf(stderr, \"%s: unknown log method: %s\\n\", pname, optarg);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tchrootdir = strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tusername = strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tversion();\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tconfigtest = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tsingleprocess = 1;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage();\n#ifdef HAVE_GETOPT_LONG\n\t\tcase ':':\n\t\t\tfprintf(stderr, \"%s: option %s: parameter expected\\n\", pname,\n\t\t\t\tprog_opt[opt_idx].name);\n\t\t\texit(1);\n#endif\n\t\tcase '?':\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (chrootdir) {\n\t\tif (!username) {\n\t\t\tfprintf(stderr, \"Chroot as root is not safe, exiting\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (chroot(chrootdir) == -1) {\n\t\t\tperror(\"chroot\");\n\t\t\texit (1);\n\t\t}\n\n\t\tif (chdir(\"/\") == -1) {\n\t\t\tperror(\"chdir\");\n\t\t\texit (1);\n\t\t}\n\t\t/* username will be switched later */\n\t}\n\n\tif (configtest) {\n\t\tlog_method = L_STDERR;\n\t}\n\n\tif (log_open(log_method, pname, logfile, facility) < 0) {\n\t\tperror(\"log_open\");\n\t\texit(1);\n\t}\n\n\tif (!configtest) {\n\t\tflog(LOG_INFO, \"version %s started\", VERSION);\n\t}\n\n\t/* get a raw socket for sending and receiving ICMPv6 messages */\n\tsock = open_icmpv6_socket();\n\tif (sock < 0) {\n\t\tperror(\"open_icmpv6_socket\");\n\t\texit(1);\n\t}\n\n\t/* check that 'other' cannot write the file\n         * for non-root, also that self/own group can't either\n         */\n\tif (check_conffile_perm(username, conf_file) < 0) {\n\t\tif (get_debuglevel() == 0) {\n\t\t\tflog(LOG_ERR, \"Exiting, permissions on conf_file invalid.\\n\");\n\t\t\texit(1);\n\t\t}\n\t\telse\n\t\t\tflog(LOG_WARNING, \"Insecure file permissions, but continuing anyway\");\n\t}\n\n\t/* if we know how to do it, check whether forwarding is enabled */\n\tif (check_ip6_forwarding()) {\n\t\tflog(LOG_WARNING, \"IPv6 forwarding seems to be disabled, but continuing anyway.\");\n\t}\n\n\t/* parse config file */\n\tif (readin_config(conf_file) < 0) {\n\t\tflog(LOG_ERR, \"Exiting, failed to read config file.\\n\");\n\t\texit(1);\n\t}\n\n\tif (configtest) {\n\t\tfprintf(stderr, \"Syntax OK\\n\");\n\t\texit(0);\n\t}\n\n\t/* drop root privileges if requested. */\n\tif (username) {\n\t\tif (!singleprocess) {\n\t\t \tdlog(LOG_DEBUG, 3, \"Initializing privsep\");\n\t\t \tif (privsep_init() < 0)\n\t\t\t\tflog(LOG_WARNING, \"Failed to initialize privsep.\");\n\t\t}\n\n\t\tif (drop_root_privileges(username) < 0) {\n\t\t\tperror(\"drop_root_privileges\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif ((fd = open(pidfile, O_RDONLY, 0)) > 0)\n\t{\n\t\tret = read(fd, pidstr, sizeof(pidstr) - 1);\n\t\tif (ret < 0)\n\t\t{\n\t\t\tflog(LOG_ERR, \"cannot read radvd pid file, terminating: %s\", strerror(errno));\n\t\t\texit(1);\n\t\t}\n\t\tpidstr[ret] = '\\0';\n\t\tif (!kill((pid_t)atol(pidstr), 0))\n\t\t{\n\t\t\tflog(LOG_ERR, \"radvd already running, terminating.\");\n\t\t\texit(1);\n\t\t}\n\t\tclose(fd);\n\t\tfd = open(pidfile, O_CREAT|O_TRUNC|O_WRONLY, 0644);\n\t}\n\telse\t/* FIXME: not atomic if pidfile is on an NFS mounted volume */\n\t\tfd = open(pidfile, O_CREAT|O_EXCL|O_WRONLY, 0644);\n\n\tif (fd < 0)\n\t{\n\t\tflog(LOG_ERR, \"cannot create radvd pid file, terminating: %s\", strerror(errno));\n\t\texit(1);\n\t}\n\n\t/*\n\t * okay, config file is read in, socket and stuff is setup, so\n\t * lets fork now...\n\t */\n\n\tif (get_debuglevel() == 0) {\n\n\t\t/* Detach from controlling terminal */\n\t\tif (daemon(0, 0) < 0)\n\t\t\tperror(\"daemon\");\n\n\t\t/* close old logfiles, including stderr */\n\t\tlog_close();\n\n\t\t/* reopen logfiles, but don't log to stderr unless explicitly requested */\n\t\tif (log_method == L_STDERR_SYSLOG)\n\t\t\tlog_method = L_SYSLOG;\n\t\tif (log_open(log_method, pname, logfile, facility) < 0) {\n\t\t\tperror(\"log_open\");\n\t\t\texit(1);\n\t\t}\n\n\t}\n\n\t/*\n\t *\tconfig signal handlers\n\t */\n\tsignal(SIGHUP, sighup_handler);\n\tsignal(SIGTERM, sigterm_handler);\n\tsignal(SIGINT, sigint_handler);\n\tsignal(SIGUSR1, sigusr1_handler);\n\n\tsnprintf(pidstr, sizeof(pidstr), \"%ld\\n\", (long)getpid());\n\n\tret = write(fd, pidstr, strlen(pidstr));\n\tif (ret != strlen(pidstr))\n\t{\n\t\tflog(LOG_ERR, \"cannot write radvd pid file, terminating: %s\", strerror(errno));\n\t\texit(1);\n\t}\n\n\tclose(fd);\n\n\tconfig_interface();\n\tkickoff_adverts();\n\tmain_loop();\n\tstop_adverts();\n\tunlink(pidfile);\n\n\treturn 0;\n}",
        "start_line": 98
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "radvd.c",
        "method_name": "main",
        "raw_code": "int /* <=== main */ \nmain(int argc, char *argv[])\n{\n\tchar pidstr[16];\n\tssize_t ret;\n\tint c, log_method;\n\tchar *logfile, *pidfile;\n\tint facility, fd;\n\tchar *username = NULL;\n\tchar *chrootdir = NULL;\n\tint configtest = 0;\n\tint singleprocess = 0;\n#ifdef HAVE_GETOPT_LONG\n\tint opt_idx;\n#endif\n\n\tpname = ((pname=strrchr(argv[0],'/')) != NULL)?pname+1:argv[0];\n\n\tsrand((unsigned int)time(NULL));\n\n\tlog_method = L_STDERR_SYSLOG;\n\tlogfile = PATH_RADVD_LOG;\n\tconf_file = PATH_RADVD_CONF;\n\tfacility = LOG_FACILITY;\n\tpidfile = PATH_RADVD_PID;\n\n\t/* parse args */\n#define OPTIONS_STR \"d:C:l:m:p:t:u:vhcs\"\n#ifdef HAVE_GETOPT_LONG\n\twhile ((c = getopt_long(argc, argv, OPTIONS_STR, prog_opt, &opt_idx)) > 0)\n#else\n\twhile ((c = getopt(argc, argv, OPTIONS_STR)) > 0)\n#endif\n\t{\n\t\tswitch (c) {\n\t\tcase 'C':\n\t\t\tconf_file = optarg;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tset_debuglevel(atoi(optarg));\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tfacility = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlogfile = optarg;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tpidfile = optarg;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tif (!strcmp(optarg, \"syslog\"))\n\t\t\t{\n\t\t\t\tlog_method = L_SYSLOG;\n\t\t\t}\n\t\t\telse if (!strcmp(optarg, \"stderr_syslog\"))\n\t\t\t{\n\t\t\t\tlog_method = L_STDERR_SYSLOG;\n\t\t\t}\n\t\t\telse if (!strcmp(optarg, \"stderr\"))\n\t\t\t{\n\t\t\t\tlog_method = L_STDERR;\n\t\t\t}\n\t\t\telse if (!strcmp(optarg, \"logfile\"))\n\t\t\t{\n\t\t\t\tlog_method = L_LOGFILE;\n\t\t\t}\n\t\t\telse if (!strcmp(optarg, \"none\"))\n\t\t\t{\n\t\t\t\tlog_method = L_NONE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfprintf(stderr, \"%s: unknown log method: %s\\n\", pname, optarg);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tchrootdir = strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tusername = strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tversion();\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tconfigtest = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tsingleprocess = 1;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage();\n#ifdef HAVE_GETOPT_LONG\n\t\tcase ':':\n\t\t\tfprintf(stderr, \"%s: option %s: parameter expected\\n\", pname,\n\t\t\t\tprog_opt[opt_idx].name);\n\t\t\texit(1);\n#endif\n\t\tcase '?':\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (chrootdir) {\n\t\tif (!username) {\n\t\t\tfprintf(stderr, \"Chroot as root is not safe, exiting\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (chroot(chrootdir) == -1) {\n\t\t\tperror(\"chroot\");\n\t\t\texit (1);\n\t\t}\n\n\t\tif (chdir(\"/\") == -1) {\n\t\t\tperror(\"chdir\");\n\t\t\texit (1);\n\t\t}\n\t\t/* username will be switched later */\n\t}\n\n\tif (configtest) {\n\t\tlog_method = L_STDERR;\n\t}\n\n\tif (log_open(log_method, pname, logfile, facility) < 0) {\n\t\tperror(\"log_open\");\n\t\texit(1);\n\t}\n\n\tif (!configtest) {\n\t\tflog(LOG_INFO, \"version %s started\", VERSION);\n\t}\n\n\t/* get a raw socket for sending and receiving ICMPv6 messages */\n\tsock = open_icmpv6_socket();\n\tif (sock < 0) {\n\t\tperror(\"open_icmpv6_socket\");\n\t\texit(1);\n\t}\n\n\t/* check that 'other' cannot write the file\n         * for non-root, also that self/own group can't either\n         */\n\tif (check_conffile_perm(username, conf_file) < 0) {\n\t\tif (get_debuglevel() == 0) {\n\t\t\tflog(LOG_ERR, \"Exiting, permissions on conf_file invalid.\\n\");\n\t\t\texit(1);\n\t\t}\n\t\telse\n\t\t\tflog(LOG_WARNING, \"Insecure file permissions, but continuing anyway\");\n\t}\n\n\t/* if we know how to do it, check whether forwarding is enabled */\n\tif (check_ip6_forwarding()) {\n\t\tflog(LOG_WARNING, \"IPv6 forwarding seems to be disabled, but continuing anyway.\");\n\t}\n\n\t/* parse config file */\n\tif (readin_config(conf_file) < 0) {\n\t\tflog(LOG_ERR, \"Exiting, failed to read config file.\\n\");\n\t\texit(1);\n\t}\n\n\tif (configtest) {\n\t\tfprintf(stderr, \"Syntax OK\\n\");\n\t\texit(0);\n\t}\n\n\t/* drop root privileges if requested. */\n\tif (username) {\n\t\tif (!singleprocess) {\n\t\t \tdlog(LOG_DEBUG, 3, \"Initializing privsep\");\n\t\t \tif (privsep_init() < 0)\n\t\t\t\tperror(\"Failed to initialize privsep.\");\n\t\t}\n\n\t\tif (drop_root_privileges(username) < 0) {\n\t\t\tperror(\"drop_root_privileges\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif ((fd = open(pidfile, O_RDONLY, 0)) > 0)\n\t{\n\t\tret = read(fd, pidstr, sizeof(pidstr) - 1);\n\t\tif (ret < 0)\n\t\t{\n\t\t\tflog(LOG_ERR, \"cannot read radvd pid file, terminating: %s\", strerror(errno));\n\t\t\texit(1);\n\t\t}\n\t\tpidstr[ret] = '\\0';\n\t\tif (!kill((pid_t)atol(pidstr), 0))\n\t\t{\n\t\t\tflog(LOG_ERR, \"radvd already running, terminating.\");\n\t\t\texit(1);\n\t\t}\n\t\tclose(fd);\n\t\tfd = open(pidfile, O_CREAT|O_TRUNC|O_WRONLY, 0644);\n\t}\n\telse\t/* FIXME: not atomic if pidfile is on an NFS mounted volume */\n\t\tfd = open(pidfile, O_CREAT|O_EXCL|O_WRONLY, 0644);\n\n\tif (fd < 0)\n\t{\n\t\tflog(LOG_ERR, \"cannot create radvd pid file, terminating: %s\", strerror(errno));\n\t\texit(1);\n\t}\n\n\t/*\n\t * okay, config file is read in, socket and stuff is setup, so\n\t * lets fork now...\n\t */\n\n\tif (get_debuglevel() == 0) {\n\n\t\t/* Detach from controlling terminal */\n\t\tif (daemon(0, 0) < 0)\n\t\t\tperror(\"daemon\");\n\n\t\t/* close old logfiles, including stderr */\n\t\tlog_close();\n\n\t\t/* reopen logfiles, but don't log to stderr unless explicitly requested */\n\t\tif (log_method == L_STDERR_SYSLOG)\n\t\t\tlog_method = L_SYSLOG;\n\t\tif (log_open(log_method, pname, logfile, facility) < 0) {\n\t\t\tperror(\"log_open\");\n\t\t\texit(1);\n\t\t}\n\n\t}\n\n\t/*\n\t *\tconfig signal handlers\n\t */\n\tsignal(SIGHUP, sighup_handler);\n\tsignal(SIGTERM, sigterm_handler);\n\tsignal(SIGINT, sigint_handler);\n\tsignal(SIGUSR1, sigusr1_handler);\n\n\tsnprintf(pidstr, sizeof(pidstr), \"%ld\\n\", (long)getpid());\n\n\tret = write(fd, pidstr, strlen(pidstr));\n\tif (ret != strlen(pidstr))\n\t{\n\t\tflog(LOG_ERR, \"cannot write radvd pid file, terminating: %s\", strerror(errno));\n\t\texit(1);\n\t}\n\n\tclose(fd);\n\n\tconfig_interface();\n\tkickoff_adverts();\n\tmain_loop();\n\tstop_adverts();\n\tunlink(pidfile);\n\n\treturn 0;\n}",
        "start_line": 98
      }
    ],
    "code_context": "Called Methods:\n- vlog: static int /* <=== vlog */ \nvlog(int prio, char *format, va_list ap)\n{\n\tchar tstamp[64], buff[1024];\n\tstruct tm *tm;\n\ttime_t current;\n\n\tvsnprintf(buff, sizeof(buff), format, ap);\n\n\tswitch (log_method) {\n\t\tcase L_NONE:\n\t\t\tbreak;\n\t\tcase L_SYSLOG:\n\t\t\tsyslog(prio, \"%s\", buff);\n\t\t\tbreak;\n\t\tcase L_STDERR_SYSLOG:\n\t\t\tsyslog(prio, \"%s\", buff);\n\t\t\tif (prio > LOG_ERR) /* fall through for messages with high priority */\n\t\t\t\tbreak;\n\t\tcase L_STDERR:\n\t\t\tcurrent = time(NULL);\n\t\t\ttm = localtime(&current);\n\t\t\t(void) strftime(tstamp, sizeof(tstamp), LOG_TIME_FORMAT, tm);\n\n\t\t\tfprintf(stderr, \"[%s] %s: %s\\n\", tstamp, log_ident, buff);\n    \t\t\tfflush(stderr);\n\t\t\tbreak;\n\t\tcase L_LOGFILE:\n\t\t\tcurrent = time(NULL);\n\t\t\ttm = localtime(&current);\n\t\t\t(void) strftime(tstamp, sizeof(tstamp), LOG_TIME_FORMAT, tm);\n\n\t\t\tfprintf(log_file_fd, \"[%s] %s: %s\\n\", tstamp, log_ident, buff);\n    \t\t\tfflush(log_file_fd);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"%s: unknown logging method: %d\\n\", log_ident, log_method);\n\t\t\tlog_method = L_NONE;\n\t\t\treturn (-1);\n\t}\n\treturn 0;\n}\n- flog: void /* <=== flog */ \nflog(int prio, char *format, ...)\n{\n\tva_list ap;\n\tint res;\n\n\tva_start(ap, format);\n\tres = vlog(prio, format, ap);\n\tva_end(ap);\n\n\t/* XXX: should we do something if res < 0.. */\n}\n- privsep_init: int /* <=== privsep_init */ \nprivsep_init(void)\n{\n\tint pipefds[2];\n\tpid_t pid;\n\n\tif (privsep_enabled())\n\t\treturn 0;\n\n\tif (pipe(pipefds) != 0) {\n\t\tflog(LOG_ERR, \"Couldn't create privsep pipe.\");\n\t\treturn (-1);\n\t}\n\n\tpid = fork();\n\tif (pid == -1) {\n\t\tflog(LOG_ERR, \"Couldn't fork for privsep.\");\n\t\treturn (-1);\n\t}\n\n\tif (pid == 0) {\n\t\tint nullfd;\n\n\t\t/* This will be the privileged child */\n\t\tclose(pipefds[1]);\n\t\tpfd = pipefds[0];\n\n\t\t/* Detach from stdio */\n\t\tnullfd = open(\"/dev/null\", O_RDONLY);\n\t\tif (nullfd < 0) {\n\t\t\tperror(\"/dev/null\");\n\t\t\tclose(pfd);\n\t\t\t_exit(1);\n\t\t}\n\t\tdup2(nullfd, 0);\n\t\tdup2(nullfd, 1);\n\t\t/* XXX: we'll keep stderr open in debug mode for better logging */\n\t\tif (get_debuglevel() == 0)\n\t\t\tdup2(nullfd, 2);\n\n\t\tprivsep_read_loop();\n\t\tclose(pfd);\n\t\tflog(LOG_ERR, \"Exiting, privsep_read_loop is complete.\\n\");\n\t\t_exit(0);\n\t}\n\n\t/* Continue execution (will drop privileges soon) */\n\tclose(pipefds[0]);\n\tpfd = pipefds[1];\n\n\treturn 0;\n}\n- PATH_RADVD_CONF: #define PATH_RADVD_CONF \"/etc/radvd.conf\" /* <=== pathnames.h:21:21:PATH_RADVD_CONF:0 */ \n- privsep_enabled: int /* <=== privsep_enabled */ \nprivsep_enabled(void)\n{\n\tif (pfd < 0)\n\t\treturn 0;\n\treturn 1;\n}\n- flog: void /* <=== flog */ \nflog(int prio, char *format, ...)\n{\n\tva_list ap;\n\tint res;\n\n\tva_start(ap, format);\n\tres = vlog(prio, format, ap);\n\tva_end(ap);\n\n\t/* XXX: should we do something if res < 0.. */\n}\n- get_debuglevel: int /* <=== get_debuglevel */ \nget_debuglevel(void)\n{\n\treturn debug_level;\n}\n- SYSCTL_IP6_FORWARDING: #define SYSCTL_IP6_FORWARDING CTL_NET, PF_INET6, IPPROTO_IPV6, IPV6CTL_FORWARDING /* <=== pathnames.h:45:45:SYSCTL_IP6_FORWARDING:0 */ \n- privsep_read_loop: void /* <=== privsep_read_loop */ \nprivsep_read_loop(void)\n{\n\tstruct privsep_command cmd;\n\tint ret;\n\n\twhile (1) {\n\t\tret = readn(pfd, &cmd, sizeof(cmd));\n\t\tif (ret <= 0) {\n\t\t\t/* Error or EOF, give up */\n\t\t\tif (ret < 0) {\n\t\t\t\tflog(LOG_ERR, \"Exiting, privsep_read_loop had readn error: %s\\n\",\n\t\t\t\t     strerror(errno));\n\t\t\t} else {\n\t\t\t\tflog(LOG_ERR, \"Exiting, privsep_read_loop had readn return 0 bytes\\n\");\n\t\t\t}\n\t\t\tclose(pfd);\n\t\t\t_exit(0);\n\t\t}\n\t\tif (ret != sizeof(cmd)) {\n\t\t\t/* Short read, ignore */\n\t\t\tcontinue;\n\t\t}\n\n\t\tcmd.iface[IFNAMSIZ-1] = '\\0';\n\n\t\tswitch(cmd.type) {\n\n\t\tcase SET_INTERFACE_LINKMTU:\n\t\t\tif (cmd.val < MIN_AdvLinkMTU || cmd.val > MAX_AdvLinkMTU) {\n\t\t\t\tflog(LOG_ERR, \"(privsep) %s: LinkMTU (%u) is not within the defined bounds, ignoring\", cmd.iface, cmd.val);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = set_interface_var(cmd.iface, PROC_SYS_IP6_LINKMTU, \"LinkMTU\", cmd.val);\n\t\t\tbreak;\n\n\t\tcase SET_INTERFACE_CURHLIM:\n\t\t\tif (cmd.val < MIN_AdvCurHopLimit || cmd.val > MAX_AdvCurHopLimit) {\n\t\t\t\tflog(LOG_ERR, \"(privsep) %s: CurHopLimit (%u) is not within the defined bounds, ignoring\", cmd.iface, cmd.val);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = set_interface_var(cmd.iface, PROC_SYS_IP6_CURHLIM, \"CurHopLimit\", cmd.val);\n\t\t\tbreak;\n\n\t\tcase SET_INTERFACE_REACHTIME:\n\t\t\tif (cmd.val < MIN_AdvReachableTime || cmd.val > MAX_AdvReachableTime) {\n\t\t\t\tflog(LOG_ERR, \"(privsep) %s: BaseReachableTimer (%u) is not within the defined bounds, ignoring\", cmd.iface, cmd.val);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = set_interface_var(cmd.iface, PROC_SYS_IP6_BASEREACHTIME_MS, \"BaseReachableTimer (ms)\", cmd.val);\n\t\t\tif (ret == 0)\n\t\t\t\tbreak;\n\t\t\tset_interface_var(cmd.iface, PROC_SYS_IP6_BASEREACHTIME, \"BaseReachableTimer\", cmd.val / 1000);\n\t\t\tbreak;\n\n\t\tcase SET_INTERFACE_RETRANSTIMER:\n\t\t\tif (cmd.val < MIN_AdvRetransTimer || cmd.val > MAX_AdvRetransTimer) {\n\t\t\t\tflog(LOG_ERR, \"(privsep) %s: RetransTimer (%u) is not within the defined bounds, ignoring\", cmd.iface, cmd.val);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = set_interface_var(cmd.iface, PROC_SYS_IP6_RETRANSTIMER_MS, \"RetransTimer (ms)\", cmd.val);\n\t\t\tif (ret == 0)\n\t\t\t\tbreak;\n\t\t\tset_interface_var(cmd.iface, PROC_SYS_IP6_RETRANSTIMER, \"RetransTimer\", cmd.val / 1000 * USER_HZ); /* XXX user_hz */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Bad command */\n\t\t\tbreak;\n\t\t}\n\t}\n}\n- OPTIONS_STR: #define OPTIONS_STR \"d:C:l:m:p:t:u:vhcs\" /* <=== radvd.c:125:125:OPTIONS_STR:0 */ \n- check_conffile_perm: int /* <=== check_conffile_perm */ \ncheck_conffile_perm(const char *username, const char *conf_file)\n{\n\tstruct stat stbuf;\n\tstruct passwd *pw = NULL;\n\tFILE *fp = fopen(conf_file, \"r\");\n\n\tif (fp == NULL) {\n\t\tflog(LOG_ERR, \"can't open %s: %s\", conf_file, strerror(errno));\n\t\treturn (-1);\n\t}\n\tfclose(fp);\n\n\tif (!username)\n\t\tusername = \"root\";\n\n\tpw = getpwnam(username);\n\n\tif (stat(conf_file, &stbuf) || pw == NULL)\n\t\treturn (-1);\n\n\tif (stbuf.st_mode & S_IWOTH) {\n                flog(LOG_ERR, \"Insecure file permissions (writable by others): %s\", conf_file);\n\t\treturn (-1);\n        }\n\n\t/* for non-root: must not be writable by self/own group */\n\tif (strncmp(username, \"root\", 5) != 0 &&\n\t    ((stbuf.st_mode & S_IWGRP && pw->pw_gid == stbuf.st_gid) ||\n\t     (stbuf.st_mode & S_IWUSR && pw->pw_uid == stbuf.st_uid))) {\n                flog(LOG_ERR, \"Insecure file permissions (writable by self/group): %s\", conf_file);\n\t\treturn (-1);\n        }\n\n        return 0;\n}\n- get_debuglevel: int /* <=== get_debuglevel */ \nget_debuglevel(void)\n{\n\treturn debug_level;\n}\n- check_ip6_forwarding: int /* <=== check_ip6_forwarding */ \ncheck_ip6_forwarding(void)\n{\n\tint forw_sysctl[] = { SYSCTL_IP6_FORWARDING };\n\tint value;\n\tsize_t size = sizeof(value);\n\tFILE *fp = NULL;\n\tstatic int warned = 0;\n\n#ifdef __linux__\n\tfp = fopen(PROC_SYS_IP6_FORWARDING, \"r\");\n\tif (fp) {\n\t\tint rc = fscanf(fp, \"%d\", &value);\n\t\tif(rc != 1){\n\t\t\tflog(LOG_ERR, \"cannot read value from %s: %s\", PROC_SYS_IP6_FORWARDING, strerror(errno));\n\t\t\texit(1);\n\t\t}\n\t\tfclose(fp);\n\t}\n\telse\n\t\tflog(LOG_DEBUG, \"Correct IPv6 forwarding procfs entry not found, \"\n\t                       \"perhaps the procfs is disabled, \"\n\t                        \"or the kernel interface has changed?\");\n#endif /* __linux__ */\n\n\tif (!fp && sysctl(forw_sysctl, sizeof(forw_sysctl)/sizeof(forw_sysctl[0]),\n\t    &value, &size, NULL, 0) < 0) {\n\t\tflog(LOG_DEBUG, \"Correct IPv6 forwarding sysctl branch not found, \"\n\t\t\t\"perhaps the kernel interface has changed?\");\n\t\treturn(0);\t/* this is of advisory value only */\n\t}\n\n\tif (value != 1 && !warned) {\n\t\twarned = 1;\n\t\tflog(LOG_DEBUG, \"IPv6 forwarding setting is: %u, should be 1\", value);\n\t\treturn(-1);\n\t}\n\n\treturn(0);\n}\n\nGlobal Variables:\n- char* pname\n- char* conf_file\n\nImports:\n- #include \"config.h\"\n- #include \"netlink.h\"\n- #include \"pathnames.h\"\n- #include \"radvd.h\"\n- #include \"includes.h\"\n- #include <poll.h>",
    "commit_msg": "main() must fail on privsep_init() errors, it must not run\nwithout privilege separation as privsep is expected.",
    "cve_desc": "The router advertisement daemon (radvd) before 1.8.2 does not properly handle errors in the privsep_init function, which causes the radvd daemon to run as root and has an unspecified impact.",
    "year": 2011,
    "filename": "radvd.c",
    "commit_url": "\"https://github.com/reubenhwk/radvd/commit/2c50375043186e133f15135f4c93ca964238ee60\""
  },
  {
    "repository": "reubenhwk/radvd",
    "cve_id": "CVE-2011-3603",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "7dc53cc3b792775369bf0b2f053a3f4ed5d87e3d",
    "short_hash": "7dc53cc3",
    "vulnerableMethods_before": [
      {
        "filename": "radvd.c",
        "method_name": "main",
        "raw_code": "int /* <=== main */ \nmain(int argc, char *argv[])\n{\n\tchar pidstr[16];\n\tssize_t ret;\n\tint c, log_method;\n\tchar *logfile, *pidfile;\n\tint facility, fd;\n\tchar *username = NULL;\n\tchar *chrootdir = NULL;\n\tint configtest = 0;\n\tint singleprocess = 0;\n#ifdef HAVE_GETOPT_LONG\n\tint opt_idx;\n#endif\n\n\tpname = ((pname=strrchr(argv[0],'/')) != NULL)?pname+1:argv[0];\n\n\tsrand((unsigned int)time(NULL));\n\n\tlog_method = L_STDERR_SYSLOG;\n\tlogfile = PATH_RADVD_LOG;\n\tconf_file = PATH_RADVD_CONF;\n\tfacility = LOG_FACILITY;\n\tpidfile = PATH_RADVD_PID;\n\n\t/* parse args */\n#define OPTIONS_STR \"d:C:l:m:p:t:u:vhcs\"\n#ifdef HAVE_GETOPT_LONG\n\twhile ((c = getopt_long(argc, argv, OPTIONS_STR, prog_opt, &opt_idx)) > 0)\n#else\n\twhile ((c = getopt(argc, argv, OPTIONS_STR)) > 0)\n#endif\n\t{\n\t\tswitch (c) {\n\t\tcase 'C':\n\t\t\tconf_file = optarg;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tset_debuglevel(atoi(optarg));\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tfacility = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlogfile = optarg;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tpidfile = optarg;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tif (!strcmp(optarg, \"syslog\"))\n\t\t\t{\n\t\t\t\tlog_method = L_SYSLOG;\n\t\t\t}\n\t\t\telse if (!strcmp(optarg, \"stderr_syslog\"))\n\t\t\t{\n\t\t\t\tlog_method = L_STDERR_SYSLOG;\n\t\t\t}\n\t\t\telse if (!strcmp(optarg, \"stderr\"))\n\t\t\t{\n\t\t\t\tlog_method = L_STDERR;\n\t\t\t}\n\t\t\telse if (!strcmp(optarg, \"logfile\"))\n\t\t\t{\n\t\t\t\tlog_method = L_LOGFILE;\n\t\t\t}\n\t\t\telse if (!strcmp(optarg, \"none\"))\n\t\t\t{\n\t\t\t\tlog_method = L_NONE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfprintf(stderr, \"%s: unknown log method: %s\\n\", pname, optarg);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tchrootdir = strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tusername = strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tversion();\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tconfigtest = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tsingleprocess = 1;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage();\n#ifdef HAVE_GETOPT_LONG\n\t\tcase ':':\n\t\t\tfprintf(stderr, \"%s: option %s: parameter expected\\n\", pname,\n\t\t\t\tprog_opt[opt_idx].name);\n\t\t\texit(1);\n#endif\n\t\tcase '?':\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (chrootdir) {\n\t\tif (!username) {\n\t\t\tfprintf(stderr, \"Chroot as root is not safe, exiting\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (chroot(chrootdir) == -1) {\n\t\t\tperror(\"chroot\");\n\t\t\texit (1);\n\t\t}\n\n\t\tif (chdir(\"/\") == -1) {\n\t\t\tperror(\"chdir\");\n\t\t\texit (1);\n\t\t}\n\t\t/* username will be switched later */\n\t}\n\n\tif (configtest) {\n\t\tlog_method = L_STDERR;\n\t}\n\n\tif (log_open(log_method, pname, logfile, facility) < 0) {\n\t\tperror(\"log_open\");\n\t\texit(1);\n\t}\n\n\tif (!configtest) {\n\t\tflog(LOG_INFO, \"version %s started\", VERSION);\n\t}\n\n\t/* get a raw socket for sending and receiving ICMPv6 messages */\n\tsock = open_icmpv6_socket();\n\tif (sock < 0) {\n\t\tperror(\"open_icmpv6_socket\");\n\t\texit(1);\n\t}\n\n\t/* check that 'other' cannot write the file\n         * for non-root, also that self/own group can't either\n         */\n\tif (check_conffile_perm(username, conf_file) < 0) {\n\t\tif (get_debuglevel() == 0) {\n\t\t\tflog(LOG_ERR, \"Exiting, permissions on conf_file invalid.\\n\");\n\t\t\texit(1);\n\t\t}\n\t\telse\n\t\t\tflog(LOG_WARNING, \"Insecure file permissions, but continuing anyway\");\n\t}\n\n\t/* if we know how to do it, check whether forwarding is enabled */\n\tif (check_ip6_forwarding()) {\n\t\tflog(LOG_WARNING, \"IPv6 forwarding seems to be disabled, but continuing anyway.\");\n\t}\n\n\t/* parse config file */\n\tif (readin_config(conf_file) < 0) {\n\t\tflog(LOG_ERR, \"Exiting, failed to read config file.\\n\");\n\t\texit(1);\n\t}\n\n\tif (configtest) {\n\t\tfprintf(stderr, \"Syntax OK\\n\");\n\t\texit(0);\n\t}\n\n\t/* drop root privileges if requested. */\n\tif (username) {\n\t\tif (!singleprocess) {\n\t\t \tdlog(LOG_DEBUG, 3, \"Initializing privsep\");\n\t\t \tif (privsep_init() < 0)\n\t\t\t\tperror(\"Failed to initialize privsep.\");\n\t\t}\n\n\t\tif (drop_root_privileges(username) < 0) {\n\t\t\tperror(\"drop_root_privileges\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif ((fd = open(pidfile, O_RDONLY, 0)) > 0)\n\t{\n\t\tret = read(fd, pidstr, sizeof(pidstr) - 1);\n\t\tif (ret < 0)\n\t\t{\n\t\t\tflog(LOG_ERR, \"cannot read radvd pid file, terminating: %s\", strerror(errno));\n\t\t\texit(1);\n\t\t}\n\t\tpidstr[ret] = '\\0';\n\t\tif (!kill((pid_t)atol(pidstr), 0))\n\t\t{\n\t\t\tflog(LOG_ERR, \"radvd already running, terminating.\");\n\t\t\texit(1);\n\t\t}\n\t\tclose(fd);\n\t\tfd = open(pidfile, O_CREAT|O_TRUNC|O_WRONLY, 0644);\n\t}\n\telse\t/* FIXME: not atomic if pidfile is on an NFS mounted volume */\n\t\tfd = open(pidfile, O_CREAT|O_EXCL|O_WRONLY, 0644);\n\n\tif (fd < 0)\n\t{\n\t\tflog(LOG_ERR, \"cannot create radvd pid file, terminating: %s\", strerror(errno));\n\t\texit(1);\n\t}\n\n\t/*\n\t * okay, config file is read in, socket and stuff is setup, so\n\t * lets fork now...\n\t */\n\n\tif (get_debuglevel() == 0) {\n\n\t\t/* Detach from controlling terminal */\n\t\tif (daemon(0, 0) < 0)\n\t\t\tperror(\"daemon\");\n\n\t\t/* close old logfiles, including stderr */\n\t\tlog_close();\n\n\t\t/* reopen logfiles, but don't log to stderr unless explicitly requested */\n\t\tif (log_method == L_STDERR_SYSLOG)\n\t\t\tlog_method = L_SYSLOG;\n\t\tif (log_open(log_method, pname, logfile, facility) < 0) {\n\t\t\tperror(\"log_open\");\n\t\t\texit(1);\n\t\t}\n\n\t}\n\n\t/*\n\t *\tconfig signal handlers\n\t */\n\tsignal(SIGHUP, sighup_handler);\n\tsignal(SIGTERM, sigterm_handler);\n\tsignal(SIGINT, sigint_handler);\n\tsignal(SIGUSR1, sigusr1_handler);\n\n\tsnprintf(pidstr, sizeof(pidstr), \"%ld\\n\", (long)getpid());\n\n\tret = write(fd, pidstr, strlen(pidstr));\n\tif (ret != strlen(pidstr))\n\t{\n\t\tflog(LOG_ERR, \"cannot write radvd pid file, terminating: %s\", strerror(errno));\n\t\texit(1);\n\t}\n\n\tclose(fd);\n\n\tconfig_interface();\n\tkickoff_adverts();\n\tmain_loop();\n\tstop_adverts();\n\tunlink(pidfile);\n\n\treturn 0;\n}",
        "start_line": 98
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "radvd.c",
        "method_name": "main",
        "raw_code": "int /* <=== main */ \nmain(int argc, char *argv[])\n{\n\tchar pidstr[16];\n\tssize_t ret;\n\tint c, log_method;\n\tchar *logfile, *pidfile;\n\tint facility, fd;\n\tchar *username = NULL;\n\tchar *chrootdir = NULL;\n\tint configtest = 0;\n\tint singleprocess = 0;\n#ifdef HAVE_GETOPT_LONG\n\tint opt_idx;\n#endif\n\n\tpname = ((pname=strrchr(argv[0],'/')) != NULL)?pname+1:argv[0];\n\n\tsrand((unsigned int)time(NULL));\n\n\tlog_method = L_STDERR_SYSLOG;\n\tlogfile = PATH_RADVD_LOG;\n\tconf_file = PATH_RADVD_CONF;\n\tfacility = LOG_FACILITY;\n\tpidfile = PATH_RADVD_PID;\n\n\t/* parse args */\n#define OPTIONS_STR \"d:C:l:m:p:t:u:vhcs\"\n#ifdef HAVE_GETOPT_LONG\n\twhile ((c = getopt_long(argc, argv, OPTIONS_STR, prog_opt, &opt_idx)) > 0)\n#else\n\twhile ((c = getopt(argc, argv, OPTIONS_STR)) > 0)\n#endif\n\t{\n\t\tswitch (c) {\n\t\tcase 'C':\n\t\t\tconf_file = optarg;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tset_debuglevel(atoi(optarg));\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tfacility = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tlogfile = optarg;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tpidfile = optarg;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tif (!strcmp(optarg, \"syslog\"))\n\t\t\t{\n\t\t\t\tlog_method = L_SYSLOG;\n\t\t\t}\n\t\t\telse if (!strcmp(optarg, \"stderr_syslog\"))\n\t\t\t{\n\t\t\t\tlog_method = L_STDERR_SYSLOG;\n\t\t\t}\n\t\t\telse if (!strcmp(optarg, \"stderr\"))\n\t\t\t{\n\t\t\t\tlog_method = L_STDERR;\n\t\t\t}\n\t\t\telse if (!strcmp(optarg, \"logfile\"))\n\t\t\t{\n\t\t\t\tlog_method = L_LOGFILE;\n\t\t\t}\n\t\t\telse if (!strcmp(optarg, \"none\"))\n\t\t\t{\n\t\t\t\tlog_method = L_NONE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfprintf(stderr, \"%s: unknown log method: %s\\n\", pname, optarg);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tchrootdir = strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tusername = strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tversion();\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tconfigtest = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tsingleprocess = 1;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage();\n#ifdef HAVE_GETOPT_LONG\n\t\tcase ':':\n\t\t\tfprintf(stderr, \"%s: option %s: parameter expected\\n\", pname,\n\t\t\t\tprog_opt[opt_idx].name);\n\t\t\texit(1);\n#endif\n\t\tcase '?':\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (chrootdir) {\n\t\tif (!username) {\n\t\t\tfprintf(stderr, \"Chroot as root is not safe, exiting\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (chroot(chrootdir) == -1) {\n\t\t\tperror(\"chroot\");\n\t\t\texit (1);\n\t\t}\n\n\t\tif (chdir(\"/\") == -1) {\n\t\t\tperror(\"chdir\");\n\t\t\texit (1);\n\t\t}\n\t\t/* username will be switched later */\n\t}\n\n\tif (configtest) {\n\t\tlog_method = L_STDERR;\n\t}\n\n\tif (log_open(log_method, pname, logfile, facility) < 0) {\n\t\tperror(\"log_open\");\n\t\texit(1);\n\t}\n\n\tif (!configtest) {\n\t\tflog(LOG_INFO, \"version %s started\", VERSION);\n\t}\n\n\t/* get a raw socket for sending and receiving ICMPv6 messages */\n\tsock = open_icmpv6_socket();\n\tif (sock < 0) {\n\t\tperror(\"open_icmpv6_socket\");\n\t\texit(1);\n\t}\n\n\t/* check that 'other' cannot write the file\n         * for non-root, also that self/own group can't either\n         */\n\tif (check_conffile_perm(username, conf_file) < 0) {\n\t\tif (get_debuglevel() == 0) {\n\t\t\tflog(LOG_ERR, \"Exiting, permissions on conf_file invalid.\\n\");\n\t\t\texit(1);\n\t\t}\n\t\telse\n\t\t\tflog(LOG_WARNING, \"Insecure file permissions, but continuing anyway\");\n\t}\n\n\t/* if we know how to do it, check whether forwarding is enabled */\n\tif (check_ip6_forwarding()) {\n\t\tflog(LOG_WARNING, \"IPv6 forwarding seems to be disabled, but continuing anyway.\");\n\t}\n\n\t/* parse config file */\n\tif (readin_config(conf_file) < 0) {\n\t\tflog(LOG_ERR, \"Exiting, failed to read config file.\\n\");\n\t\texit(1);\n\t}\n\n\tif (configtest) {\n\t\tfprintf(stderr, \"Syntax OK\\n\");\n\t\texit(0);\n\t}\n\n\t/* drop root privileges if requested. */\n\tif (username) {\n\t\tif (!singleprocess) {\n\t\t \tdlog(LOG_DEBUG, 3, \"Initializing privsep\");\n\t\t\tif (privsep_init() < 0) {\n\t\t\t\tperror(\"Failed to initialize privsep.\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tif (drop_root_privileges(username) < 0) {\n\t\t\tperror(\"drop_root_privileges\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif ((fd = open(pidfile, O_RDONLY, 0)) > 0)\n\t{\n\t\tret = read(fd, pidstr, sizeof(pidstr) - 1);\n\t\tif (ret < 0)\n\t\t{\n\t\t\tflog(LOG_ERR, \"cannot read radvd pid file, terminating: %s\", strerror(errno));\n\t\t\texit(1);\n\t\t}\n\t\tpidstr[ret] = '\\0';\n\t\tif (!kill((pid_t)atol(pidstr), 0))\n\t\t{\n\t\t\tflog(LOG_ERR, \"radvd already running, terminating.\");\n\t\t\texit(1);\n\t\t}\n\t\tclose(fd);\n\t\tfd = open(pidfile, O_CREAT|O_TRUNC|O_WRONLY, 0644);\n\t}\n\telse\t/* FIXME: not atomic if pidfile is on an NFS mounted volume */\n\t\tfd = open(pidfile, O_CREAT|O_EXCL|O_WRONLY, 0644);\n\n\tif (fd < 0)\n\t{\n\t\tflog(LOG_ERR, \"cannot create radvd pid file, terminating: %s\", strerror(errno));\n\t\texit(1);\n\t}\n\n\t/*\n\t * okay, config file is read in, socket and stuff is setup, so\n\t * lets fork now...\n\t */\n\n\tif (get_debuglevel() == 0) {\n\n\t\t/* Detach from controlling terminal */\n\t\tif (daemon(0, 0) < 0)\n\t\t\tperror(\"daemon\");\n\n\t\t/* close old logfiles, including stderr */\n\t\tlog_close();\n\n\t\t/* reopen logfiles, but don't log to stderr unless explicitly requested */\n\t\tif (log_method == L_STDERR_SYSLOG)\n\t\t\tlog_method = L_SYSLOG;\n\t\tif (log_open(log_method, pname, logfile, facility) < 0) {\n\t\t\tperror(\"log_open\");\n\t\t\texit(1);\n\t\t}\n\n\t}\n\n\t/*\n\t *\tconfig signal handlers\n\t */\n\tsignal(SIGHUP, sighup_handler);\n\tsignal(SIGTERM, sigterm_handler);\n\tsignal(SIGINT, sigint_handler);\n\tsignal(SIGUSR1, sigusr1_handler);\n\n\tsnprintf(pidstr, sizeof(pidstr), \"%ld\\n\", (long)getpid());\n\n\tret = write(fd, pidstr, strlen(pidstr));\n\tif (ret != strlen(pidstr))\n\t{\n\t\tflog(LOG_ERR, \"cannot write radvd pid file, terminating: %s\", strerror(errno));\n\t\texit(1);\n\t}\n\n\tclose(fd);\n\n\tconfig_interface();\n\tkickoff_adverts();\n\tmain_loop();\n\tstop_adverts();\n\tunlink(pidfile);\n\n\treturn 0;\n}",
        "start_line": 98
      }
    ],
    "code_context": "Called Methods:\n- privsep_init: int /* <=== privsep_init */ \nprivsep_init(void)\n{\n\tint pipefds[2];\n\tpid_t pid;\n\n\tif (privsep_enabled())\n\t\treturn 0;\n\n\tif (pipe(pipefds) != 0) {\n\t\tflog(LOG_ERR, \"Couldn't create privsep pipe.\");\n\t\treturn (-1);\n\t}\n\n\tpid = fork();\n\tif (pid == -1) {\n\t\tflog(LOG_ERR, \"Couldn't fork for privsep.\");\n\t\treturn (-1);\n\t}\n\n\tif (pid == 0) {\n\t\tint nullfd;\n\n\t\t/* This will be the privileged child */\n\t\tclose(pipefds[1]);\n\t\tpfd = pipefds[0];\n\n\t\t/* Detach from stdio */\n\t\tnullfd = open(\"/dev/null\", O_RDONLY);\n\t\tif (nullfd < 0) {\n\t\t\tperror(\"/dev/null\");\n\t\t\tclose(pfd);\n\t\t\t_exit(1);\n\t\t}\n\t\tdup2(nullfd, 0);\n\t\tdup2(nullfd, 1);\n\t\t/* XXX: we'll keep stderr open in debug mode for better logging */\n\t\tif (get_debuglevel() == 0)\n\t\t\tdup2(nullfd, 2);\n\n\t\tprivsep_read_loop();\n\t\tclose(pfd);\n\t\tflog(LOG_ERR, \"Exiting, privsep_read_loop is complete.\\n\");\n\t\t_exit(0);\n\t}\n\n\t/* Continue execution (will drop privileges soon) */\n\tclose(pipefds[0]);\n\tpfd = pipefds[1];\n\n\treturn 0;\n}\n- flog: void /* <=== flog */ \nflog(int prio, char *format, ...)\n{\n\tva_list ap;\n\tint res;\n\n\tva_start(ap, format);\n\tres = vlog(prio, format, ap);\n\tva_end(ap);\n\n\t/* XXX: should we do something if res < 0.. */\n}\n- privsep_read_loop: void /* <=== privsep_read_loop */ \nprivsep_read_loop(void)\n{\n\tstruct privsep_command cmd;\n\tint ret;\n\n\twhile (1) {\n\t\tret = readn(pfd, &cmd, sizeof(cmd));\n\t\tif (ret <= 0) {\n\t\t\t/* Error or EOF, give up */\n\t\t\tif (ret < 0) {\n\t\t\t\tflog(LOG_ERR, \"Exiting, privsep_read_loop had readn error: %s\\n\",\n\t\t\t\t     strerror(errno));\n\t\t\t} else {\n\t\t\t\tflog(LOG_ERR, \"Exiting, privsep_read_loop had readn return 0 bytes\\n\");\n\t\t\t}\n\t\t\tclose(pfd);\n\t\t\t_exit(0);\n\t\t}\n\t\tif (ret != sizeof(cmd)) {\n\t\t\t/* Short read, ignore */\n\t\t\treturn;\n\t\t}\n\n\t\tcmd.iface[IFNAMSIZ-1] = '\\0';\n\n\t\tswitch(cmd.type) {\n\n\t\tcase SET_INTERFACE_LINKMTU:\n\t\t\tif (cmd.val < MIN_AdvLinkMTU || cmd.val > MAX_AdvLinkMTU) {\n\t\t\t\tflog(LOG_ERR, \"(privsep) %s: LinkMTU (%u) is not within the defined bounds, ignoring\", cmd.iface, cmd.val);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = set_interface_var(cmd.iface, PROC_SYS_IP6_LINKMTU, \"LinkMTU\", cmd.val);\n\t\t\tbreak;\n\n\t\tcase SET_INTERFACE_CURHLIM:\n\t\t\tif (cmd.val < MIN_AdvCurHopLimit || cmd.val > MAX_AdvCurHopLimit) {\n\t\t\t\tflog(LOG_ERR, \"(privsep) %s: CurHopLimit (%u) is not within the defined bounds, ignoring\", cmd.iface, cmd.val);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = set_interface_var(cmd.iface, PROC_SYS_IP6_CURHLIM, \"CurHopLimit\", cmd.val);\n\t\t\tbreak;\n\n\t\tcase SET_INTERFACE_REACHTIME:\n\t\t\tif (cmd.val < MIN_AdvReachableTime || cmd.val > MAX_AdvReachableTime) {\n\t\t\t\tflog(LOG_ERR, \"(privsep) %s: BaseReachableTimer (%u) is not within the defined bounds, ignoring\", cmd.iface, cmd.val);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = set_interface_var(cmd.iface, PROC_SYS_IP6_BASEREACHTIME_MS, \"BaseReachableTimer (ms)\", cmd.val);\n\t\t\tif (ret == 0)\n\t\t\t\tbreak;\n\t\t\tset_interface_var(cmd.iface, PROC_SYS_IP6_BASEREACHTIME, \"BaseReachableTimer\", cmd.val / 1000);\n\t\t\tbreak;\n\n\t\tcase SET_INTERFACE_RETRANSTIMER:\n\t\t\tif (cmd.val < MIN_AdvRetransTimer || cmd.val > MAX_AdvRetransTimer) {\n\t\t\t\tflog(LOG_ERR, \"(privsep) %s: RetransTimer (%u) is not within the defined bounds, ignoring\", cmd.iface, cmd.val);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = set_interface_var(cmd.iface, PROC_SYS_IP6_RETRANSTIMER_MS, \"RetransTimer (ms)\", cmd.val);\n\t\t\tif (ret == 0)\n\t\t\t\tbreak;\n\t\t\tset_interface_var(cmd.iface, PROC_SYS_IP6_RETRANSTIMER, \"RetransTimer\", cmd.val / 1000 * USER_HZ); /* XXX user_hz */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Bad command */\n\t\t\tbreak;\n\t\t}\n\t}\n}\n- privsep_enabled: int /* <=== privsep_enabled */ \nprivsep_enabled(void)\n{\n\tif (pfd < 0)\n\t\treturn 0;\n\treturn 1;\n}\n- get_debuglevel: int /* <=== get_debuglevel */ \nget_debuglevel(void)\n{\n\treturn debug_level;\n}\n- OPTIONS_STR: #define OPTIONS_STR \"d:C:l:m:p:t:u:vhcs\" /* <=== radvd.c:125:125:OPTIONS_STR:0 */ \n\nGlobal Variables:\n- char* pname\n\nImports:\n- #include <poll.h>\n- #include \"netlink.h\"\n- #include \"pathnames.h\"\n- #include \"radvd.h\"\n- #include \"config.h\"\n- #include \"includes.h\"",
    "commit_msg": "Really exit on privsep init failure.",
    "cve_desc": "The router advertisement daemon (radvd) before 1.8.2 does not properly handle errors in the privsep_init function, which causes the radvd daemon to run as root and has an unspecified impact.",
    "year": 2011,
    "filename": "radvd.c",
    "commit_url": "\"https://github.com/reubenhwk/radvd/commit/7dc53cc3b792775369bf0b2f053a3f4ed5d87e3d\""
  },
  {
    "repository": "reubenhwk/radvd",
    "cve_id": "CVE-2011-3604",
    "cwe_list": [
      "CWE-119"
    ],
    "commit_hash": "7de1b9abf87b747ee2611c0d2a94dfeee79878b4",
    "short_hash": "7de1b9ab",
    "vulnerableMethods_before": [
      {
        "filename": "process.c",
        "method_name": "process_ra",
        "raw_code": "static void /* <=== process_ra */ \nprocess_ra(struct Interface *iface, unsigned char *msg, int len,\n\tstruct sockaddr_in6 *addr)\n{\n\tstruct nd_router_advert *radvert;\n\tchar addr_str[INET6_ADDRSTRLEN];\n\tuint8_t *opt_str;\n\n\tprint_addr(&addr->sin6_addr, addr_str);\n\n\tradvert = (struct nd_router_advert *) msg;\n\n\tif ((radvert->nd_ra_curhoplimit && iface->AdvCurHopLimit) &&\n\t   (radvert->nd_ra_curhoplimit != iface->AdvCurHopLimit))\n\t{\n\t\tflog(LOG_WARNING, \"our AdvCurHopLimit on %s doesn't agree with %s\",\n\t\t\tiface->Name, addr_str);\n\t}\n\n\tif ((radvert->nd_ra_flags_reserved & ND_RA_FLAG_MANAGED) && !iface->AdvManagedFlag)\n\t{\n\t\tflog(LOG_WARNING, \"our AdvManagedFlag on %s doesn't agree with %s\",\n\t\t\tiface->Name, addr_str);\n\t}\n\n\tif ((radvert->nd_ra_flags_reserved & ND_RA_FLAG_OTHER) && !iface->AdvOtherConfigFlag)\n\t{\n\t\tflog(LOG_WARNING, \"our AdvOtherConfigFlag on %s doesn't agree with %s\",\n\t\t\tiface->Name, addr_str);\n\t}\n\n\t/* note: we don't check the default router preference here, because they're likely different */\n\n\tif ((radvert->nd_ra_reachable && iface->AdvReachableTime) &&\n\t   (ntohl(radvert->nd_ra_reachable) != iface->AdvReachableTime))\n\t{\n\t\tflog(LOG_WARNING, \"our AdvReachableTime on %s doesn't agree with %s\",\n\t\t\tiface->Name, addr_str);\n\t}\n\n\tif ((radvert->nd_ra_retransmit && iface->AdvRetransTimer) &&\n\t   (ntohl(radvert->nd_ra_retransmit) != iface->AdvRetransTimer))\n\t{\n\t\tflog(LOG_WARNING, \"our AdvRetransTimer on %s doesn't agree with %s\",\n\t\t\tiface->Name, addr_str);\n\t}\n\n\tlen -= sizeof(struct nd_router_advert);\n\n\tif (len == 0)\n\t\treturn;\n\n\topt_str = (uint8_t *)(msg + sizeof(struct nd_router_advert));\n\n\twhile (len > 0)\n\t{\n\t\tint optlen;\n\t\tstruct nd_opt_prefix_info *pinfo;\n\t\tstruct nd_opt_rdnss_info_local *rdnssinfo;\n\t\tstruct nd_opt_dnssl_info_local *dnsslinfo;\n\t\tstruct nd_opt_mtu *mtu;\n\t\tstruct AdvPrefix *prefix;\n\t\tstruct AdvRDNSS *rdnss;\n\t\tchar prefix_str[INET6_ADDRSTRLEN];\n\t\tchar rdnss_str[INET6_ADDRSTRLEN];\n\t\tchar suffix[256];\n\t\tunsigned int offset, label_len;\n\t\tuint32_t preferred, valid, count;\n\n\t\tif (len < 2)\n\t\t{\n\t\t\tflog(LOG_ERR, \"trailing garbage in RA on %s from %s\",\n\t\t\t\tiface->Name, addr_str);\n\t\t\tbreak;\n\t\t}\n\n\t\toptlen = (opt_str[1] << 3);\n\n\t\tif (optlen == 0)\n\t\t{\n\t\t\tflog(LOG_ERR, \"zero length option in RA on %s from %s\",\n\t\t\t\tiface->Name, addr_str);\n\t\t\tbreak;\n\t\t}\n\t\telse if (optlen > len)\n\t\t{\n\t\t\tflog(LOG_ERR, \"option length greater than total\"\n\t\t\t\t\" length in RA on %s from %s\",\n\t\t\t\tiface->Name, addr_str);\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (*opt_str)\n\t\t{\n\t\tcase ND_OPT_MTU:\n\t\t\tmtu = (struct nd_opt_mtu *)opt_str;\n\n\t\t\tif (iface->AdvLinkMTU && (ntohl(mtu->nd_opt_mtu_mtu) != iface->AdvLinkMTU))\n\t\t\t{\n\t\t\t\tflog(LOG_WARNING, \"our AdvLinkMTU on %s doesn't agree with %s\",\n\t\t\t\t\tiface->Name, addr_str);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ND_OPT_PREFIX_INFORMATION:\n\t\t\tpinfo = (struct nd_opt_prefix_info *) opt_str;\n\t\t\tpreferred = ntohl(pinfo->nd_opt_pi_preferred_time);\n\t\t\tvalid = ntohl(pinfo->nd_opt_pi_valid_time);\n\n\t\t\tprefix = iface->AdvPrefixList;\n\t\t\twhile (prefix)\n\t\t\t{\n\t\t\t\tif (prefix->enabled &&\n\t\t\t\t    (prefix->PrefixLen == pinfo->nd_opt_pi_prefix_len) &&\n\t\t\t\t    addr_match(&prefix->Prefix, &pinfo->nd_opt_pi_prefix,\n\t\t\t\t    \t prefix->PrefixLen))\n\t\t\t\t{\n\t\t\t\t\tprint_addr(&prefix->Prefix, prefix_str);\n\n\t\t\t\t\tif (!prefix->DecrementLifetimesFlag && valid != prefix->AdvValidLifetime)\n\t\t\t\t\t{\n\t\t\t\t\t\tflog(LOG_WARNING, \"our AdvValidLifetime on\"\n\t\t\t\t\t\t \" %s for %s doesn't agree with %s\",\n\t\t\t\t\t\t iface->Name,\n\t\t\t\t\t\t prefix_str,\n\t\t\t\t\t\t addr_str\n\t\t\t\t\t\t );\n\t\t\t\t\t}\n\t\t\t\t\tif (!prefix->DecrementLifetimesFlag && preferred != prefix->AdvPreferredLifetime)\n\t\t\t\t\t{\n\t\t\t\t\t\tflog(LOG_WARNING, \"our AdvPreferredLifetime on\"\n\t\t\t\t\t\t \" %s for %s doesn't agree with %s\",\n\t\t\t\t\t\t iface->Name,\n\t\t\t\t\t\t prefix_str,\n\t\t\t\t\t\t addr_str\n\t\t\t\t\t\t );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tprefix = prefix->next;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ND_OPT_ROUTE_INFORMATION:\n\t\t\t/* not checked: these will very likely vary a lot */\n\t\t\tbreak;\n\t\tcase ND_OPT_SOURCE_LINKADDR:\n\t\t\t/* not checked */\n\t\t\tbreak;\n\t\tcase ND_OPT_TARGET_LINKADDR:\n\t\tcase ND_OPT_REDIRECTED_HEADER:\n\t\t\tflog(LOG_ERR, \"invalid option %d in RA on %s from %s\",\n\t\t\t\t(int)*opt_str, iface->Name, addr_str);\n\t\t\tbreak;\n\t\t/* Mobile IPv6 extensions */\n\t\tcase ND_OPT_RTR_ADV_INTERVAL:\n\t\tcase ND_OPT_HOME_AGENT_INFO:\n\t\t\t/* not checked */\n\t\t\tbreak;\n\t\tcase ND_OPT_RDNSS_INFORMATION:\n\t\t\trdnssinfo = (struct nd_opt_rdnss_info_local *) opt_str;\n\t\t\tcount = rdnssinfo->nd_opt_rdnssi_len;\n\n\t\t\t/* Check the RNDSS addresses received */\n\t\t\tswitch (count) {\n\t\t\t\tcase 7:\n\t\t\t\t\trdnss = iface->AdvRDNSSList;\n\t\t\t\t\tif (!check_rdnss_presence(rdnss, &rdnssinfo->nd_opt_rdnssi_addr3 )) {\n\t\t\t\t\t\t/* no match found in iface->AdvRDNSSList */\n\t\t\t\t\t\tprint_addr(&rdnssinfo->nd_opt_rdnssi_addr3, rdnss_str);\n\t\t\t\t\t\tflog(LOG_WARNING, \"RDNSS address %s received on %s from %s is not advertised by us\",\n\t\t\t\t\t\t\trdnss_str, iface->Name, addr_str);\n\t\t\t\t\t}\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase 5:\n\t\t\t\t\trdnss = iface->AdvRDNSSList;\n\t\t\t\t\tif (!check_rdnss_presence(rdnss, &rdnssinfo->nd_opt_rdnssi_addr2 )) {\n\t\t\t\t\t\t/* no match found in iface->AdvRDNSSList */\n\t\t\t\t\t\tprint_addr(&rdnssinfo->nd_opt_rdnssi_addr2, rdnss_str);\n\t\t\t\t\t\tflog(LOG_WARNING, \"RDNSS address %s received on %s from %s is not advertised by us\",\n\t\t\t\t\t\t\trdnss_str, iface->Name, addr_str);\n\t\t\t\t\t}\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase 3:\n\t\t\t\t\trdnss = iface->AdvRDNSSList;\n\t\t\t\t\tif (!check_rdnss_presence(rdnss, &rdnssinfo->nd_opt_rdnssi_addr1 )) {\n\t\t\t\t\t\t/* no match found in iface->AdvRDNSSList */\n\t\t\t\t\t\tprint_addr(&rdnssinfo->nd_opt_rdnssi_addr1, rdnss_str);\n\t\t\t\t\t\tflog(LOG_WARNING, \"RDNSS address %s received on %s from %s is not advertised by us\",\n\t\t\t\t\t\t\trdnss_str, iface->Name, addr_str);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tflog(LOG_ERR, \"invalid len %i in RDNSS option on %s from %s\",\n\t\t\t\t\t\t\tcount, iface->Name, addr_str);\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase ND_OPT_DNSSL_INFORMATION:\n\t\t\tdnsslinfo = (struct nd_opt_dnssl_info_local *) opt_str;\n\t\t\tsuffix[0] = '\\0';\n\t\t\tfor (offset = 0; offset < (dnsslinfo->nd_opt_dnssli_len-1)*8;) {\n\t\t\t\tlabel_len = dnsslinfo->nd_opt_dnssli_suffixes[offset++];\n\n\t\t\t\tif (label_len == 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Ignore empty suffixes. They're\n\t\t\t\t\t * probably just padding...\n\t\t\t\t\t */\n\t\t\t\t\tif (suffix[0] == '\\0')\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (!check_dnssl_presence(iface->AdvDNSSLList, suffix)) {\n\t\t\t\t\t\tflog(LOG_WARNING, \"DNSSL suffix %s received on %s from %s is not advertised by us\",\n\t\t\t\t\t\t\tsuffix, iface->Name, addr_str);\n\t\t\t\t\t}\n\n\t\t\t\t\tsuffix[0] = '\\0';\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * 1) must not overflow int: label + 2, offset + label_len\n\t\t\t\t * 2) last byte of dnssli_suffix must not overflow opt_str + len\n\t\t\t\t */\n\t\t\t\tif ((sizeof(suffix) - strlen(suffix)) < (label_len + 2) ||\n\t\t\t\t    label_len > label_len + 2 ||\n\t\t\t\t    &dnsslinfo->nd_opt_dnssli_suffixes[offset+label_len] - (char*)opt_str >= len ||\n\t\t\t\t    offset + label_len < offset) {\n\t\t\t\t\tflog(LOG_ERR, \"oversized suffix in DNSSL option on %s from %s\",\n\t\t\t\t\t\t\tiface->Name, addr_str);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (suffix[0] != '\\0')\n\t\t\t\t\tstrcat(suffix, \".\");\n\t\t\t\tstrncat(suffix, &dnsslinfo->nd_opt_dnssli_suffixes[offset], label_len);\n\t\t\t\toffset += label_len;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdlog(LOG_DEBUG, 1, \"unknown option %d in RA on %s from %s\",\n\t\t\t\t(int)*opt_str, iface->Name, addr_str);\n\t\t\tbreak;\n\t\t}\n\n\t\tlen -= optlen;\n\t\topt_str += optlen;\n\t}\n}",
        "start_line": 217
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "process.c",
        "method_name": "process_ra",
        "raw_code": "static void /* <=== process_ra */ \nprocess_ra(struct Interface *iface, unsigned char *msg, int len,\n\tstruct sockaddr_in6 *addr)\n{\n\tstruct nd_router_advert *radvert;\n\tchar addr_str[INET6_ADDRSTRLEN];\n\tuint8_t *opt_str;\n\n\tprint_addr(&addr->sin6_addr, addr_str);\n\n\tradvert = (struct nd_router_advert *) msg;\n\n\tif ((radvert->nd_ra_curhoplimit && iface->AdvCurHopLimit) &&\n\t   (radvert->nd_ra_curhoplimit != iface->AdvCurHopLimit))\n\t{\n\t\tflog(LOG_WARNING, \"our AdvCurHopLimit on %s doesn't agree with %s\",\n\t\t\tiface->Name, addr_str);\n\t}\n\n\tif ((radvert->nd_ra_flags_reserved & ND_RA_FLAG_MANAGED) && !iface->AdvManagedFlag)\n\t{\n\t\tflog(LOG_WARNING, \"our AdvManagedFlag on %s doesn't agree with %s\",\n\t\t\tiface->Name, addr_str);\n\t}\n\n\tif ((radvert->nd_ra_flags_reserved & ND_RA_FLAG_OTHER) && !iface->AdvOtherConfigFlag)\n\t{\n\t\tflog(LOG_WARNING, \"our AdvOtherConfigFlag on %s doesn't agree with %s\",\n\t\t\tiface->Name, addr_str);\n\t}\n\n\t/* note: we don't check the default router preference here, because they're likely different */\n\n\tif ((radvert->nd_ra_reachable && iface->AdvReachableTime) &&\n\t   (ntohl(radvert->nd_ra_reachable) != iface->AdvReachableTime))\n\t{\n\t\tflog(LOG_WARNING, \"our AdvReachableTime on %s doesn't agree with %s\",\n\t\t\tiface->Name, addr_str);\n\t}\n\n\tif ((radvert->nd_ra_retransmit && iface->AdvRetransTimer) &&\n\t   (ntohl(radvert->nd_ra_retransmit) != iface->AdvRetransTimer))\n\t{\n\t\tflog(LOG_WARNING, \"our AdvRetransTimer on %s doesn't agree with %s\",\n\t\t\tiface->Name, addr_str);\n\t}\n\n\tlen -= sizeof(struct nd_router_advert);\n\n\tif (len == 0)\n\t\treturn;\n\n\topt_str = (uint8_t *)(msg + sizeof(struct nd_router_advert));\n\n\twhile (len > 0)\n\t{\n\t\tint optlen;\n\t\tstruct nd_opt_prefix_info *pinfo;\n\t\tstruct nd_opt_rdnss_info_local *rdnssinfo;\n\t\tstruct nd_opt_dnssl_info_local *dnsslinfo;\n\t\tstruct nd_opt_mtu *mtu;\n\t\tstruct AdvPrefix *prefix;\n\t\tstruct AdvRDNSS *rdnss;\n\t\tchar prefix_str[INET6_ADDRSTRLEN];\n\t\tchar rdnss_str[INET6_ADDRSTRLEN];\n\t\tchar suffix[256];\n\t\tunsigned int offset, label_len;\n\t\tuint32_t preferred, valid, count;\n\n\t\tif (len < 2)\n\t\t{\n\t\t\tflog(LOG_ERR, \"trailing garbage in RA on %s from %s\",\n\t\t\t\tiface->Name, addr_str);\n\t\t\tbreak;\n\t\t}\n\n\t\toptlen = (opt_str[1] << 3);\n\n\t\tif (optlen == 0)\n\t\t{\n\t\t\tflog(LOG_ERR, \"zero length option in RA on %s from %s\",\n\t\t\t\tiface->Name, addr_str);\n\t\t\tbreak;\n\t\t}\n\t\telse if (optlen > len)\n\t\t{\n\t\t\tflog(LOG_ERR, \"option length greater than total\"\n\t\t\t\t\" length in RA on %s from %s\",\n\t\t\t\tiface->Name, addr_str);\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (*opt_str)\n\t\t{\n\t\tcase ND_OPT_MTU:\n\t\t\tmtu = (struct nd_opt_mtu *)opt_str;\n\t\t\tif (len < sizeof(*mtu))\n\t\t\t\treturn;\n\n\t\t\tif (iface->AdvLinkMTU && (ntohl(mtu->nd_opt_mtu_mtu) != iface->AdvLinkMTU))\n\t\t\t{\n\t\t\t\tflog(LOG_WARNING, \"our AdvLinkMTU on %s doesn't agree with %s\",\n\t\t\t\t\tiface->Name, addr_str);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ND_OPT_PREFIX_INFORMATION:\n\t\t\tpinfo = (struct nd_opt_prefix_info *) opt_str;\n\t\t\tif (len < sizeof(*pinfo))\n\t\t\t\treturn;\n\t\t\tpreferred = ntohl(pinfo->nd_opt_pi_preferred_time);\n\t\t\tvalid = ntohl(pinfo->nd_opt_pi_valid_time);\n\n\t\t\tprefix = iface->AdvPrefixList;\n\t\t\twhile (prefix)\n\t\t\t{\n\t\t\t\tif (prefix->enabled &&\n\t\t\t\t    (prefix->PrefixLen == pinfo->nd_opt_pi_prefix_len) &&\n\t\t\t\t    addr_match(&prefix->Prefix, &pinfo->nd_opt_pi_prefix,\n\t\t\t\t    \t prefix->PrefixLen))\n\t\t\t\t{\n\t\t\t\t\tprint_addr(&prefix->Prefix, prefix_str);\n\n\t\t\t\t\tif (!prefix->DecrementLifetimesFlag && valid != prefix->AdvValidLifetime)\n\t\t\t\t\t{\n\t\t\t\t\t\tflog(LOG_WARNING, \"our AdvValidLifetime on\"\n\t\t\t\t\t\t \" %s for %s doesn't agree with %s\",\n\t\t\t\t\t\t iface->Name,\n