[
  {
    "repository": "mdadams/jasper",
    "cve_id": "CVE-2016-9398",
    "cwe_list": [
      "CWE-617"
    ],
    "commit_hash": "c6f9fb6ec7fc97a5c4213f9077faf8622685d160",
    "short_hash": "c6f9fb6e",
    "vulnerableMethods_before": [
      {
        "filename": "src/libjasper/jpc/jpc_t2dec.c",
        "method_name": "jpc_dec_decodepkt",
        "raw_code": "static int jpc_dec_decodepkt(jpc_dec_t *dec, jas_stream_t *pkthdrstream, jas_stream_t *in, int compno, int rlvlno, /* <=== jpc_dec_decodepkt */ \n  int prcno, int lyrno)\n{\n\tjpc_bitstream_t *inb;\n\tjpc_dec_tcomp_t *tcomp;\n\tjpc_dec_rlvl_t *rlvl;\n\tjpc_dec_band_t *band;\n\tjpc_dec_cblk_t *cblk;\n\tint n;\n\tint m;\n\tint i;\n\tjpc_tagtreenode_t *leaf;\n\tint included;\n\tint ret;\n\tint numnewpasses;\n\tjpc_dec_seg_t *seg;\n\tint len;\n\tint present;\n\tint savenumnewpasses;\n\tint mycounter;\n\tjpc_ms_t *ms;\n\tjpc_dec_tile_t *tile;\n\tjpc_dec_ccp_t *ccp;\n\tjpc_dec_cp_t *cp;\n\tint bandno;\n\tjpc_dec_prc_t *prc;\n\tint usedcblkcnt;\n\tint cblkno;\n\tuint_fast32_t bodylen;\n\tbool discard;\n\tint passno;\n\tint maxpasses;\n\tint hdrlen;\n\tint hdroffstart;\n\tint hdroffend;\n\n\t/* Avoid compiler warning about possible use of uninitialized\n\t  variable. */\n\tbodylen = 0;\n\n\tdiscard = (lyrno >= dec->maxlyrs);\n\n\ttile = dec->curtile;\n\tcp = tile->cp;\n\tccp = &cp->ccps[compno];\n\n\t/*\n\t * Decode the packet header.\n\t */\n\n\t/* Decode the SOP marker segment if present. */\n\tif (cp->csty & JPC_COD_SOP) {\n\t\tif (jpc_dec_lookahead(in) == JPC_MS_SOP) {\n\t\t\tif (!(ms = jpc_getms(in, dec->cstate))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (jpc_ms_gettype(ms) != JPC_MS_SOP) {\n\t\t\t\tjpc_ms_destroy(ms);\n\t\t\t\tjas_eprintf(\"missing SOP marker segment\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tjpc_ms_destroy(ms);\n\t\t}\n\t}\n\nhdroffstart = jas_stream_getrwcount(pkthdrstream);\n\n\tif (!(inb = jpc_bitstream_sopen(pkthdrstream, \"r\"))) {\n\t\treturn -1;\n\t}\n\n\tif ((present = jpc_bitstream_getbit(inb)) < 0) {\n\t\tjpc_bitstream_close(inb);\n\t\treturn 1;\n\t}\n\tJAS_DBGLOG(10, (\"\\n\", present));\n\tJAS_DBGLOG(10, (\"present=%d \", present));\n\n\t/* Is the packet non-empty? */\n\tif (present) {\n\t\t/* The packet is non-empty. */\n\t\ttcomp = &tile->tcomps[compno];\n\t\trlvl = &tcomp->rlvls[rlvlno];\n\t\tbodylen = 0;\n\t\tfor (bandno = 0, band = rlvl->bands; bandno < rlvl->numbands;\n\t\t  ++bandno, ++band) {\n\t\t\tif (!band->data) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprc = &band->prcs[prcno];\n\t\t\tif (!prc->cblks) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tusedcblkcnt = 0;\n\t\t\tfor (cblkno = 0, cblk = prc->cblks; cblkno < prc->numcblks;\n\t\t\t  ++cblkno, ++cblk) {\n\t\t\t\t++usedcblkcnt;\n\t\t\t\tif (!cblk->numpasses) {\n\t\t\t\t\tleaf = jpc_tagtree_getleaf(prc->incltagtree, usedcblkcnt - 1);\n\t\t\t\t\tif ((included = jpc_tagtree_decode(prc->incltagtree, leaf, lyrno + 1, inb)) < 0) {\n\t\t\t\t\t\tjpc_bitstream_close(inb);\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ((included = jpc_bitstream_getbit(inb)) < 0) {\n\t\t\t\t\t\tjpc_bitstream_close(inb);\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tJAS_DBGLOG(10, (\"\\n\"));\n\t\t\t\tJAS_DBGLOG(10, (\"included=%d \", included));\n\t\t\t\tif (!included) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!cblk->numpasses) {\n\t\t\t\t\ti = 1;\n\t\t\t\t\tleaf = jpc_tagtree_getleaf(prc->numimsbstagtree, usedcblkcnt - 1);\n\t\t\t\t\tfor (;;) {\n\t\t\t\t\t\tif ((ret = jpc_tagtree_decode(prc->numimsbstagtree, leaf, i, inb)) < 0) {\n\t\t\t\t\t\t\tjpc_bitstream_close(inb);\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ret) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t++i;\n\t\t\t\t\t}\n\t\t\t\t\tcblk->numimsbs = i - 1;\n\t\t\t\t\tcblk->firstpassno = cblk->numimsbs * 3;\n\t\t\t\t}\n\t\t\t\tif ((numnewpasses = jpc_getnumnewpasses(inb)) < 0) {\n\t\t\t\t\tjpc_bitstream_close(inb);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tJAS_DBGLOG(10, (\"numnewpasses=%d \", numnewpasses));\n\t\t\t\tseg = cblk->curseg;\n\t\t\t\tsavenumnewpasses = numnewpasses;\n\t\t\t\tmycounter = 0;\n\t\t\t\tif (numnewpasses > 0) {\n\t\t\t\t\tif ((m = jpc_getcommacode(inb)) < 0) {\n\t\t\t\t\t\tjpc_bitstream_close(inb);\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tcblk->numlenbits += m;\n\t\t\t\t\tJAS_DBGLOG(10, (\"increment=%d \", m));\n\t\t\t\t\twhile (numnewpasses > 0) {\n\t\t\t\t\t\tpassno = cblk->firstpassno + cblk->numpasses + mycounter;\n\t/* XXX - the maxpasses is not set precisely but this doesn't matter... */\n\t\t\t\t\t\tmaxpasses = JPC_SEGPASSCNT(passno, cblk->firstpassno, 10000, (ccp->cblkctx & JPC_COX_LAZY) != 0, (ccp->cblkctx & JPC_COX_TERMALL) != 0);\n\t\t\t\t\t\tif (!discard && !seg) {\n\t\t\t\t\t\t\tif (!(seg = jpc_seg_alloc())) {\n\t\t\t\t\t\t\t\tjpc_bitstream_close(inb);\n\t\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tjpc_seglist_insert(&cblk->segs, cblk->segs.tail, seg);\n\t\t\t\t\t\t\tif (!cblk->curseg) {\n\t\t\t\t\t\t\t\tcblk->curseg = seg;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tseg->passno = passno;\n\t\t\t\t\t\t\tseg->type = JPC_SEGTYPE(seg->passno, cblk->firstpassno, (ccp->cblkctx & JPC_COX_LAZY) != 0);\n\t\t\t\t\t\t\tseg->maxpasses = maxpasses;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn = JAS_MIN(numnewpasses, maxpasses);\n\t\t\t\t\t\tmycounter += n;\n\t\t\t\t\t\tnumnewpasses -= n;\n\t\t\t\t\t\tif ((len = jpc_bitstream_getbits(inb, cblk->numlenbits + jpc_floorlog2(n))) < 0) {\n\t\t\t\t\t\t\tjpc_bitstream_close(inb);\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tJAS_DBGLOG(10, (\"len=%d \", len));\n\t\t\t\t\t\tif (!discard) {\n\t\t\t\t\t\t\tseg->lyrno = lyrno;\n\t\t\t\t\t\t\tseg->numpasses += n;\n\t\t\t\t\t\t\tseg->cnt = len;\n\t\t\t\t\t\t\tseg = seg->next;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbodylen += len;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcblk->numpasses += savenumnewpasses;\n\t\t\t}\n\t\t}\n\n\t\tjpc_bitstream_inalign(inb, 0, 0);\n\n\t} else {\n\t\tif (jpc_bitstream_inalign(inb, 0x7f, 0)) {\n\t\t\tjas_eprintf(\"alignment failed\\n\");\n\t\t\tjpc_bitstream_close(inb);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tjpc_bitstream_close(inb);\n\n\thdroffend = jas_stream_getrwcount(pkthdrstream);\n\thdrlen = hdroffend - hdroffstart;\n\tif (jas_getdbglevel() >= 5) {\n\t\tjas_eprintf(\"hdrlen=%lu bodylen=%lu \\n\", (unsigned long) hdrlen,\n\t\t  (unsigned long) bodylen);\n\t}\n\n\tif (cp->csty & JPC_COD_EPH) {\n\t\tif (jpc_dec_lookahead(pkthdrstream) == JPC_MS_EPH) {\n\t\t\tif (!(ms = jpc_getms(pkthdrstream, dec->cstate))) {\n\t\t\t\tjas_eprintf(\"cannot get (EPH) marker segment\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (jpc_ms_gettype(ms) != JPC_MS_EPH) {\n\t\t\t\tjpc_ms_destroy(ms);\n\t\t\t\tjas_eprintf(\"missing EPH marker segment\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tjpc_ms_destroy(ms);\n\t\t}\n\t}\n\n\t/* decode the packet body. */\n\n\tif (jas_getdbglevel() >= 1) {\n\t\tjas_eprintf(\"packet body offset=%06ld\\n\", (long) jas_stream_getrwcount(in));\n\t}\n\n\tif (!discard) {\n\t\ttcomp = &tile->tcomps[compno];\n\t\trlvl = &tcomp->rlvls[rlvlno];\n\t\tfor (bandno = 0, band = rlvl->bands; bandno < rlvl->numbands;\n\t\t  ++bandno, ++band) {\n\t\t\tif (!band->data) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprc = &band->prcs[prcno];\n\t\t\tif (!prc->cblks) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (cblkno = 0, cblk = prc->cblks; cblkno < prc->numcblks;\n\t\t\t  ++cblkno, ++cblk) {\n\t\t\t\tseg = cblk->curseg;\n\t\t\t\twhile (seg) {\n\t\t\t\t\tif (!seg->stream) {\n\t\t\t\t\t\tif (!(seg->stream = jas_stream_memopen(0, 0))) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#if 0\njas_eprintf(\"lyrno=%02d, compno=%02d, lvlno=%02d, prcno=%02d, bandno=%02d, cblkno=%02d, passno=%02d numpasses=%02d cnt=%d numbps=%d, numimsbs=%d\\n\", lyrno, compno, rlvlno, prcno, band - rlvl->bands, cblk - prc->cblks, seg->passno, seg->numpasses, seg->cnt, band->numbps, cblk->numimsbs);\n#endif\n\t\t\t\t\tif (seg->cnt > 0) {\n\t\t\t\t\t\tif (jpc_getdata(in, seg->stream, seg->cnt) < 0) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tseg->cnt = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (seg->numpasses >= seg->maxpasses) {\n\t\t\t\t\t\tcblk->curseg = seg->next;\n\t\t\t\t\t}\n\t\t\t\t\tseg = seg->next;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (jas_stream_gobble(in, bodylen) != JAS_CAST(int, bodylen)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}",
        "start_line": 156
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "src/libjasper/jpc/jpc_t2dec.c",
        "method_name": "jpc_dec_decodepkt",
        "raw_code": "static int jpc_dec_decodepkt(jpc_dec_t *dec, jas_stream_t *pkthdrstream, jas_stream_t *in, int compno, int rlvlno, /* <=== jpc_dec_decodepkt */ \n  int prcno, int lyrno)\n{\n\tjpc_bitstream_t *inb;\n\tjpc_dec_tcomp_t *tcomp;\n\tjpc_dec_rlvl_t *rlvl;\n\tjpc_dec_band_t *band;\n\tjpc_dec_cblk_t *cblk;\n\tint n;\n\tint m;\n\tint i;\n\tjpc_tagtreenode_t *leaf;\n\tint included;\n\tint ret;\n\tint numnewpasses;\n\tjpc_dec_seg_t *seg;\n\tint len;\n\tint present;\n\tint savenumnewpasses;\n\tint mycounter;\n\tjpc_ms_t *ms;\n\tjpc_dec_tile_t *tile;\n\tjpc_dec_ccp_t *ccp;\n\tjpc_dec_cp_t *cp;\n\tint bandno;\n\tjpc_dec_prc_t *prc;\n\tint usedcblkcnt;\n\tint cblkno;\n\tuint_fast32_t bodylen;\n\tbool discard;\n\tint passno;\n\tint maxpasses;\n\tint hdrlen;\n\tint hdroffstart;\n\tint hdroffend;\n\n\t/* Avoid compiler warning about possible use of uninitialized\n\t  variable. */\n\tbodylen = 0;\n\n\tdiscard = (lyrno >= dec->maxlyrs);\n\n\ttile = dec->curtile;\n\tcp = tile->cp;\n\tccp = &cp->ccps[compno];\n\n\t/*\n\t * Decode the packet header.\n\t */\n\n\t/* Decode the SOP marker segment if present. */\n\tif (cp->csty & JPC_COD_SOP) {\n\t\tif (jpc_dec_lookahead(in) == JPC_MS_SOP) {\n\t\t\tif (!(ms = jpc_getms(in, dec->cstate))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (jpc_ms_gettype(ms) != JPC_MS_SOP) {\n\t\t\t\tjpc_ms_destroy(ms);\n\t\t\t\tjas_eprintf(\"missing SOP marker segment\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tjpc_ms_destroy(ms);\n\t\t}\n\t}\n\nhdroffstart = jas_stream_getrwcount(pkthdrstream);\n\n\tif (!(inb = jpc_bitstream_sopen(pkthdrstream, \"r\"))) {\n\t\treturn -1;\n\t}\n\n\tif ((present = jpc_bitstream_getbit(inb)) < 0) {\n\t\tjpc_bitstream_close(inb);\n\t\treturn 1;\n\t}\n\tJAS_DBGLOG(10, (\"\\n\", present));\n\tJAS_DBGLOG(10, (\"present=%d \", present));\n\n\t/* Is the packet non-empty? */\n\tif (present) {\n\t\t/* The packet is non-empty. */\n\t\ttcomp = &tile->tcomps[compno];\n\t\trlvl = &tcomp->rlvls[rlvlno];\n\t\tbodylen = 0;\n\t\tfor (bandno = 0, band = rlvl->bands; bandno < rlvl->numbands;\n\t\t  ++bandno, ++band) {\n\t\t\tif (!band->data) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprc = &band->prcs[prcno];\n\t\t\tif (!prc->cblks) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tusedcblkcnt = 0;\n\t\t\tfor (cblkno = 0, cblk = prc->cblks; cblkno < prc->numcblks;\n\t\t\t  ++cblkno, ++cblk) {\n\t\t\t\t++usedcblkcnt;\n\t\t\t\tif (!cblk->numpasses) {\n\t\t\t\t\tleaf = jpc_tagtree_getleaf(prc->incltagtree, usedcblkcnt - 1);\n\t\t\t\t\tif ((included = jpc_tagtree_decode(prc->incltagtree, leaf, lyrno + 1, inb)) < 0) {\n\t\t\t\t\t\tjpc_bitstream_close(inb);\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ((included = jpc_bitstream_getbit(inb)) < 0) {\n\t\t\t\t\t\tjpc_bitstream_close(inb);\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tJAS_DBGLOG(10, (\"\\n\"));\n\t\t\t\tJAS_DBGLOG(10, (\"included=%d \", included));\n\t\t\t\tif (!included) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!cblk->numpasses) {\n\t\t\t\t\ti = 1;\n\t\t\t\t\tleaf = jpc_tagtree_getleaf(prc->numimsbstagtree, usedcblkcnt - 1);\n\t\t\t\t\tfor (;;) {\n\t\t\t\t\t\tif ((ret = jpc_tagtree_decode(prc->numimsbstagtree, leaf, i, inb)) < 0) {\n\t\t\t\t\t\t\tjpc_bitstream_close(inb);\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ret) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t++i;\n\t\t\t\t\t}\n\t\t\t\t\tcblk->numimsbs = i - 1;\n\t\t\t\t\tcblk->firstpassno = cblk->numimsbs * 3;\n\t\t\t\t}\n\t\t\t\tif ((numnewpasses = jpc_getnumnewpasses(inb)) < 0) {\n\t\t\t\t\tjpc_bitstream_close(inb);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tJAS_DBGLOG(10, (\"numnewpasses=%d \", numnewpasses));\n\t\t\t\tseg = cblk->curseg;\n\t\t\t\tsavenumnewpasses = numnewpasses;\n\t\t\t\tmycounter = 0;\n\t\t\t\tif (numnewpasses > 0) {\n\t\t\t\t\tif (cblk->firstpassno > 10000) {\n\t\t\t\t\t\t/* workaround for\n\t\t\t\t\t\t   CVE-2016-9398: this\n\t\t\t\t\t\t   large value would\n\t\t\t\t\t\t   make\n\t\t\t\t\t\t   JPC_SEGPASSCNT()\n\t\t\t\t\t\t   return a negative\n\t\t\t\t\t\t   value, causing an\n\t\t\t\t\t\t   assertion failure\n\t\t\t\t\t\t   in\n\t\t\t\t\t\t   jpc_floorlog2() */\n\t\t\t\t\t\tjpc_bitstream_close(inb);\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tif ((m = jpc_getcommacode(inb)) < 0) {\n\t\t\t\t\t\tjpc_bitstream_close(inb);\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tcblk->numlenbits += m;\n\t\t\t\t\tJAS_DBGLOG(10, (\"increment=%d \", m));\n\t\t\t\t\twhile (numnewpasses > 0) {\n\t\t\t\t\t\tpassno = cblk->firstpassno + cblk->numpasses + mycounter;\n\t/* XXX - the maxpasses is not set precisely but this doesn't matter... */\n\t\t\t\t\t\tmaxpasses = JPC_SEGPASSCNT(passno, cblk->firstpassno, 10000, (ccp->cblkctx & JPC_COX_LAZY) != 0, (ccp->cblkctx & JPC_COX_TERMALL) != 0);\n\t\t\t\t\t\tif (!discard && !seg) {\n\t\t\t\t\t\t\tif (!(seg = jpc_seg_alloc())) {\n\t\t\t\t\t\t\t\tjpc_bitstream_close(inb);\n\t\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tjpc_seglist_insert(&cblk->segs, cblk->segs.tail, seg);\n\t\t\t\t\t\t\tif (!cblk->curseg) {\n\t\t\t\t\t\t\t\tcblk->curseg = seg;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tseg->passno = passno;\n\t\t\t\t\t\t\tseg->type = JPC_SEGTYPE(seg->passno, cblk->firstpassno, (ccp->cblkctx & JPC_COX_LAZY) != 0);\n\t\t\t\t\t\t\tseg->maxpasses = maxpasses;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn = JAS_MIN(numnewpasses, maxpasses);\n\t\t\t\t\t\tmycounter += n;\n\t\t\t\t\t\tnumnewpasses -= n;\n\t\t\t\t\t\tif ((len = jpc_bitstream_getbits(inb, cblk->numlenbits + jpc_floorlog2(n))) < 0) {\n\t\t\t\t\t\t\tjpc_bitstream_close(inb);\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tJAS_DBGLOG(10, (\"len=%d \", len));\n\t\t\t\t\t\tif (!discard) {\n\t\t\t\t\t\t\tseg->lyrno = lyrno;\n\t\t\t\t\t\t\tseg->numpasses += n;\n\t\t\t\t\t\t\tseg->cnt = len;\n\t\t\t\t\t\t\tseg = seg->next;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbodylen += len;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcblk->numpasses += savenumnewpasses;\n\t\t\t}\n\t\t}\n\n\t\tjpc_bitstream_inalign(inb, 0, 0);\n\n\t} else {\n\t\tif (jpc_bitstream_inalign(inb, 0x7f, 0)) {\n\t\t\tjas_eprintf(\"alignment failed\\n\");\n\t\t\tjpc_bitstream_close(inb);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tjpc_bitstream_close(inb);\n\n\thdroffend = jas_stream_getrwcount(pkthdrstream);\n\thdrlen = hdroffend - hdroffstart;\n\tif (jas_getdbglevel() >= 5) {\n\t\tjas_eprintf(\"hdrlen=%lu bodylen=%lu \\n\", (unsigned long) hdrlen,\n\t\t  (unsigned long) bodylen);\n\t}\n\n\tif (cp->csty & JPC_COD_EPH) {\n\t\tif (jpc_dec_lookahead(pkthdrstream) == JPC_MS_EPH) {\n\t\t\tif (!(ms = jpc_getms(pkthdrstream, dec->cstate))) {\n\t\t\t\tjas_eprintf(\"cannot get (EPH) marker segment\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (jpc_ms_gettype(ms) != JPC_MS_EPH) {\n\t\t\t\tjpc_ms_destroy(ms);\n\t\t\t\tjas_eprintf(\"missing EPH marker segment\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tjpc_ms_destroy(ms);\n\t\t}\n\t}\n\n\t/* decode the packet body. */\n\n\tif (jas_getdbglevel() >= 1) {\n\t\tjas_eprintf(\"packet body offset=%06ld\\n\", (long) jas_stream_getrwcount(in));\n\t}\n\n\tif (!discard) {\n\t\ttcomp = &tile->tcomps[compno];\n\t\trlvl = &tcomp->rlvls[rlvlno];\n\t\tfor (bandno = 0, band = rlvl->bands; bandno < rlvl->numbands;\n\t\t  ++bandno, ++band) {\n\t\t\tif (!band->data) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprc = &band->prcs[prcno];\n\t\t\tif (!prc->cblks) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (cblkno = 0, cblk = prc->cblks; cblkno < prc->numcblks;\n\t\t\t  ++cblkno, ++cblk) {\n\t\t\t\tseg = cblk->curseg;\n\t\t\t\twhile (seg) {\n\t\t\t\t\tif (!seg->stream) {\n\t\t\t\t\t\tif (!(seg->stream = jas_stream_memopen(0, 0))) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#if 0\njas_eprintf(\"lyrno=%02d, compno=%02d, lvlno=%02d, prcno=%02d, bandno=%02d, cblkno=%02d, passno=%02d numpasses=%02d cnt=%d numbps=%d, numimsbs=%d\\n\", lyrno, compno, rlvlno, prcno, band - rlvl->bands, cblk - prc->cblks, seg->passno, seg->numpasses, seg->cnt, band->numbps, cblk->numimsbs);\n#endif\n\t\t\t\t\tif (seg->cnt > 0) {\n\t\t\t\t\t\tif (jpc_getdata(in, seg->stream, seg->cnt) < 0) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tseg->cnt = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (seg->numpasses >= seg->maxpasses) {\n\t\t\t\t\t\tcblk->curseg = seg->next;\n\t\t\t\t\t}\n\t\t\t\t\tseg = seg->next;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (jas_stream_gobble(in, bodylen) != JAS_CAST(int, bodylen)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}",
        "start_line": 156
      }
    ],
    "code_context": "Called Methods:\n- JPC_BITSTREAM_WRITE: #define\tJPC_BITSTREAM_WRITE\t0x02 /* <=== src/libjasper/jpc/jpc_bs.h:93:93:JPC_BITSTREAM_WRITE:0 */ \n- jpc_bitstream_inalign: int jpc_bitstream_inalign(jpc_bitstream_t *bitstream, int fillmask, /* <=== jpc_bitstream_inalign */ \n  int filldata)\n{\n\tint n;\n\tint v;\n\tint u;\n\tint numfill;\n\tint m;\n\n\tnumfill = 7;\n\tm = 0;\n\tv = 0;\n\tif (bitstream->cnt_ > 0) {\n\t\tn = bitstream->cnt_;\n\t} else if (!bitstream->cnt_) {\n\t\tn = ((bitstream->buf_ & 0xff) == 0xff) ? 7 : 0;\n\t} else {\n\t\tn = 0;\n\t}\n\tif (n > 0) {\n\t\tif ((u = jpc_bitstream_getbits(bitstream, n)) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tm += n;\n\t\tv = (v << n) | u;\n\t}\n\tif ((bitstream->buf_ & 0xff) == 0xff) {\n\t\tif ((u = jpc_bitstream_getbits(bitstream, 7)) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tv = (v << 7) | u;\n\t\tm += 7;\n\t}\n\tif (m > numfill) {\n\t\tv >>= m - numfill;\n\t} else {\n\t\tfilldata >>= numfill - m;\n\t\tfillmask >>= numfill - m;\n\t}\n\tif (((~(v ^ filldata)) & fillmask) != fillmask) {\n\t\t/* The actual fill pattern does not match the expected one. */\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n- jpc_bitstream_eof: #define jpc_bitstream_eof(bitstream) \\ /* <=== src/libjasper/jpc/jpc_bs.h:198:199:jpc_bitstream_eof:1 */ \n\t((bitstream)->flags_ & JPC_BITSTREAM_EOF)\n- jpc_dec_lookahead: long jpc_dec_lookahead(jas_stream_t *in) /* <=== jpc_dec_lookahead */ \n{\n\tuint_fast16_t x;\n\tif (jpc_getuint16(in, &x)) {\n\t\treturn -1;\n\t}\n\tif (jas_stream_ungetc(in, x & 0xff) == EOF ||\n\t  jas_stream_ungetc(in, x >> 8) == EOF) {\n\t\treturn -1;\n\t}\n\tif (x >= JPC_MS_INMIN && x <= JPC_MS_INMAX) {\n\t\treturn x;\n\t}\n\treturn 0;\n}\n- jas_stream_copy: int jas_stream_copy(jas_stream_t *out, jas_stream_t *in, int n) /* <=== jas_stream_copy */ \n{\n\tint all;\n\tint c;\n\tint m;\n\n\tall = (n < 0) ? 1 : 0;\n\n\tm = n;\n\twhile (all || m > 0) {\n\t\tif ((c = jas_stream_getc_macro(in)) == EOF) {\n\t\t\t/* The next character of input could not be read. */\n\t\t\t/* Return with an error if an I/O error occured\n\t\t\t  (not including EOF) or if an explicit copy count\n\t\t\t  was specified. */\n\t\t\treturn (!all || jas_stream_error(in)) ? (-1) : 0;\n\t\t}\n\t\tif (jas_stream_putc_macro(out, c) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\t--m;\n\t}\n\treturn 0;\n}\n- jpc_ms_destroy: void jpc_ms_destroy(jpc_ms_t *ms) /* <=== jpc_ms_destroy */ \n{\n\tif (ms->ops && ms->ops->destroyparms) {\n\t\t(*ms->ops->destroyparms)(ms);\n\t}\n\tjas_free(ms);\n}\n- jpc_bitstream_fillbuf: int jpc_bitstream_fillbuf(jpc_bitstream_t *bitstream) /* <=== jpc_bitstream_fillbuf */ \n{\n\tint c;\n\t/* Note: The count has already been decremented by the caller. */\n\tassert(bitstream->openmode_ & JPC_BITSTREAM_READ);\n\tassert(bitstream->cnt_ <= 0);\n\n\tif (bitstream->flags_ & JPC_BITSTREAM_ERR) {\n\t\tbitstream->cnt_ = 0;\n\t\treturn -1;\n\t}\n\n\tif (bitstream->flags_ & JPC_BITSTREAM_EOF) {\n\t\tbitstream->buf_ = 0x7f;\n\t\tbitstream->cnt_ = 7;\n\t\treturn 1;\n\t}\n\n\tbitstream->buf_ = (bitstream->buf_ << 8) & 0xffff;\n\tif ((c = jas_stream_getc((bitstream)->stream_)) == EOF) {\n\t\tbitstream->flags_ |= JPC_BITSTREAM_EOF;\n\t\treturn 1;\n\t}\n\tbitstream->cnt_ = (bitstream->buf_ == 0xff00) ? 6 : 7;\n\tbitstream->buf_ |= c & ((1 << (bitstream->cnt_ + 1)) - 1);\n\treturn (bitstream->buf_ >> bitstream->cnt_) & 1;\n}\n- JPC_SEG_INVALID: #define JPC_SEG_INVALID\t0 /* <=== src/libjasper/jpc/jpc_t1cod.h:91:91:JPC_SEG_INVALID:0 */ \n- JAS_CAST: #define\tJAS_CAST(t, e) \\ /* <=== src/libjasper/include/jasper/jas_types.h:144:145:JAS_CAST:2 */ \n\t((t) (e))\n- JPC_SEG_MQ: #define JPC_SEG_MQ\t\t1 /* <=== src/libjasper/jpc/jpc_t1cod.h:93:93:JPC_SEG_MQ:0 */ \n- JPC_MS_MIN: #define\tJPC_MS_MIN\t0xff00 /* <=== src/libjasper/jpc/jpc_cs.h:621:621:JPC_MS_MIN:0 */ \n- JPC_MS_MAX: #define\tJPC_MS_MAX\t0xffff /* <=== src/libjasper/jpc/jpc_cs.h:624:624:JPC_MS_MAX:0 */ \n- jas_getdbglevel: int jas_getdbglevel() /* <=== jas_getdbglevel */ \n{\n\treturn jas_dbglevel;\n}\n- jpc_mstab_lookup: static const jpc_mstabent_t *jpc_mstab_lookup(int id) /* <=== jpc_mstab_lookup */ \n{\n\tconst jpc_mstabent_t *mstabent;\n\tfor (mstabent = jpc_mstab;; ++mstabent) {\n\t\tif (mstabent->id == id || mstabent->id < 0) {\n\t\t\treturn mstabent;\n\t\t}\n\t}\n\tassert(0);\n\treturn 0;\n}\n- jpc_ms_gettype: #define\tjpc_ms_gettype(ms) \\ /* <=== src/libjasper/jpc/jpc_cs.h:727:728:jpc_ms_gettype:1 */ \n\t((ms)->id)\n- JPC_SIGPASS: #define\tJPC_SIGPASS\t0\t/* significance */ /* <=== src/libjasper/jpc/jpc_t1cod.h:101:101:JPC_SIGPASS:0 */ \n- jas_stream_fillbuf: int jas_stream_fillbuf(jas_stream_t *stream, int getflag) /* <=== jas_stream_fillbuf */ \n{\n\tint c;\n\n\t/* The stream must not be in an error or EOF state. */\n\tif ((stream->flags_ & (JAS_STREAM_ERRMASK)) != 0) {\n\t\treturn EOF;\n\t}\n\n\t/* The stream must be open for reading. */\n\tif ((stream->openmode_ & JAS_STREAM_READ) == 0) {\n\t\treturn EOF;\n\t}\n\n\t/* Make a half-hearted attempt to confirm that the buffer is not\n\tcurrently being used for writing.  This check is not intended\n\tto be foolproof! */\n\tassert((stream->bufmode_ & JAS_STREAM_WRBUF) == 0);\n\n\tassert(stream->ptr_ - stream->bufstart_ <= stream->bufsize_);\n\n\t/* Mark the buffer as being used for reading. */\n\tstream->bufmode_ |= JAS_STREAM_RDBUF;\n\n\t/* Read new data into the buffer. */\n\tstream->ptr_ = stream->bufstart_;\n\tif ((stream->cnt_ = (*stream->ops_->read_)(stream->obj_,\n\t  (char *) stream->bufstart_, stream->bufsize_)) <= 0) {\n\t\tif (stream->cnt_ < 0) {\n\t\t\tstream->flags_ |= JAS_STREAM_ERR;\n\t\t} else {\n\t\t\tstream->flags_ |= JAS_STREAM_EOF;\n\t\t}\n\t\tstream->cnt_ = 0;\n\t\treturn EOF;\n\t}\n\n\tassert(stream->cnt_ > 0);\n\t/* Get or peek at the first character in the buffer. */\n\tc = (getflag) ? jas_stream_getc2(stream) : (*stream->ptr_);\n\n\treturn c;\n}\n- JAS_DBGLOG: #define\tJAS_DBGLOG(n, x) \\ /* <=== src/libjasper/include/jasper/jas_debug.h:94:95:JAS_DBGLOG:2 */ \n\t((jas_getdbglevel() >= (n)) ? (jas_eprintf x) : 0)\n- JPC_SEGTYPE: int JPC_SEGTYPE(int passno, int firstpassno, int bypass) /* <=== JPC_SEGTYPE */ \n{\n\tint passtype;\n\tif (bypass) {\n\t\tpasstype = JPC_PASSTYPE(passno);\n\t\tif (passtype == JPC_CLNPASS) {\n\t\t\treturn JPC_SEG_MQ;\n\t\t}\n\t\treturn ((passno < firstpassno + 10) ? JPC_SEG_MQ : JPC_SEG_RAW);\n\t} else {\n\t\treturn JPC_SEG_MQ;\n\t}\n}\n- JPC_PASSTYPE: int JPC_PASSTYPE(int passno) /* <=== JPC_PASSTYPE */ \n{\n\tint passtype;\n\tswitch (passno % 3) {\n\tcase 0:\n\t\tpasstype = JPC_CLNPASS;\n\t\tbreak;\n\tcase 1:\n\t\tpasstype = JPC_SIGPASS;\n\t\tbreak;\n\tcase 2:\n\t\tpasstype = JPC_REFPASS;\n\t\tbreak;\n\tdefault:\n\t\tpasstype = -1;\n\t\tassert(0);\n\t\tbreak;\n\t}\n\treturn passtype;\n}\n- jpc_tagtree_decode: int jpc_tagtree_decode(jpc_tagtree_t *tree, jpc_tagtreenode_t *leaf, /* <=== jpc_tagtree_decode */ \n  int threshold, jpc_bitstream_t *in)\n{\n\tjpc_tagtreenode_t *stk[JPC_TAGTREE_MAXDEPTH - 1];\n\tjpc_tagtreenode_t **stkptr;\n\tjpc_tagtreenode_t *node;\n\tint low;\n\tint ret;\n\n\t/* Avoid compiler warnings about unused parameters. */\n\ttree = 0;\n\n\tassert(threshold >= 0);\n\n\t/* Traverse to the root of the tree, recording the path taken. */\n\tstkptr = stk;\n\tnode = leaf;\n\twhile (node->parent_) {\n\t\t*stkptr++ = node;\n\t\tnode = node->parent_;\n\t}\n\n\tlow = 0;\n\tfor (;;) {\n\t\tif (low > node->low_) {\n\t\t\tnode->low_ = low;\n\t\t} else {\n\t\t\tlow = node->low_;\n\t\t}\n\t\twhile (low < threshold && low < node->value_) {\n\t\t\tif ((ret = jpc_bitstream_getbit(in)) < 0) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (ret) {\n\t\t\t\tnode->value_ = low;\n\t\t\t} else {\n\t\t\t\t++low;\n\t\t\t}\n\t\t}\n\t\tnode->low_ = low;\n\t\tif (stkptr == stk) {\n\t\t\tbreak;\n\t\t}\n\t\tnode = *--stkptr;\n\t}\n\n\treturn (node->value_ < threshold) ? 1 : 0;\n}\n- JPC_MS_SOP: #define\tJPC_MS_SOP\t0xff91\t/* Start of packet (SOP). */ /* <=== src/libjasper/jpc/jpc_cs.h:656:656:JPC_MS_SOP:0 */ \n- JPC_PREC: #define\tJPC_PREC\t32 /* <=== src/libjasper/jpc/jpc_cod.h:76:76:JPC_PREC:0 */ \n- jas_deprecated: void jas_deprecated(const char *s) /* <=== jas_deprecated */ \n{\n\tstatic char message[] =\n\t\"WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!!\\n\"\n\t\"WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!!\\n\"\n\t\"WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!!\\n\"\n\t\"YOUR CODE IS RELYING ON DEPRECATED FUNCTIONALTIY IN THE JASPER LIBRARY.\\n\"\n\t\"THIS FUNCTIONALITY WILL BE REMOVED IN THE NEAR FUTURE.\\n\"\n\t\"PLEASE FIX THIS PROBLEM BEFORE YOUR CODE STOPS WORKING!\\n\"\n\t;\n\tjas_eprintf(\"%s\", message);\n\tjas_eprintf(\"The specific problem is as follows:\\n%s\\n\", s);\n\t//abort();\n}\n- jpc_bitstream_close: int jpc_bitstream_close(jpc_bitstream_t *bitstream) /* <=== jpc_bitstream_close */ \n{\n\tint ret = 0;\n\n\t/* Align to the next byte boundary while considering the effects of\n\t  bit stuffing. */\n\tif (jpc_bitstream_align(bitstream)) {\n\t\tret = -1;\n\t}\n\n\t/* If necessary, close the underlying (character) stream. */\n\tif (!(bitstream->flags_ & JPC_BITSTREAM_NOCLOSE) && bitstream->stream_) {\n\t\tif (jas_stream_close(bitstream->stream_)) {\n\t\t\tret = -1;\n\t\t}\n\t\tbitstream->stream_ = 0;\n\t}\n\n\tjas_free(bitstream);\n\treturn ret;\n}\n- jas_eprintf: int jas_eprintf(const char *fmt, ...) /* <=== jas_eprintf */ \n{\n\tint ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}\n- jas_stream_gobble: int jas_stream_gobble(jas_stream_t *stream, int n) /* <=== jas_stream_gobble */ \n{\n\tint m;\n\n\tJAS_DBGLOG(100, (\"jas_stream_gobble(%p, %d)\\n\", stream, n));\n\n\tif (n < 0) {\n\t\tjas_deprecated(\"negative count for jas_stream_gobble\");\n\t}\n\tm = n;\n\tfor (m = n; m > 0; --m) {\n\t\tif (jas_stream_getc(stream) == EOF) {\n\t\t\treturn n - m;\n\t\t}\n\t}\n\treturn n;\n}\n- jpc_bitstream_getbit: #define jpc_bitstream_getbit(bitstream) \\ /* <=== src/libjasper/jpc/jpc_bs.h:150:151:jpc_bitstream_getbit:1 */ \n\tjpc_bitstream_getbit_macro(bitstream)\n- jas_stream_getc: #define jas_stream_getc(stream)\tjas_stream_getc_macro(stream) /* <=== src/libjasper/include/jasper/jas_stream.h:351:351:jas_stream_getc:1 */ \n- jas_stream_getrwcount: #define\tjas_stream_getrwcount(stream) \\ /* <=== src/libjasper/include/jasper/jas_stream.h:337:338:jas_stream_getrwcount:1 */ \n\t(((const jas_stream_t *)(stream))->rwcnt_)\n- JPC_BITSTREAM_ERR: #define\tJPC_BITSTREAM_ERR\t0x04 /* <=== src/libjasper/jpc/jpc_bs.h:104:104:JPC_BITSTREAM_ERR:0 */ \n- jpc_seglist_insert: void jpc_seglist_insert(jpc_dec_seglist_t *list, jpc_dec_seg_t *ins, jpc_dec_seg_t *node) /* <=== jpc_seglist_insert */ \n{\n\tjpc_dec_seg_t *prev;\n\tjpc_dec_seg_t *next;\n\n\tprev = ins;\n\tnode->prev = prev;\n\tnext = prev ? (prev->next) : 0;\n\tnode->prev = prev;\n\tnode->next = next;\n\tif (prev) {\n\t\tprev->next = node;\n\t} else {\n\t\tlist->head = node;\n\t}\n\tif (next) {\n\t\tnext->prev = node;\n\t} else {\n\t\tlist->tail = node;\n\t}\n}\n- JPC_COX_LAZY: #define\tJPC_COX_LAZY\t0x01 /* Selective arithmetic coding bypass. */ /* <=== src/libjasper/jpc/jpc_cs.h:257:257:JPC_COX_LAZY:0 */ \n- JPC_COD_SOP: #define\tJPC_COD_SOP\t0x02 /* <=== src/libjasper/jpc/jpc_cs.h:232:232:JPC_COD_SOP:0 */ \n- JPC_MS_HASPARMS: #define\tJPC_MS_HASPARMS(x) \\ /* <=== src/libjasper/jpc/jpc_cs.h:722:724:JPC_MS_HASPARMS:1 */ \n\t(!((x) == JPC_MS_SOC || (x) == JPC_MS_SOD || (x) == JPC_MS_EOC || \\\n\t  (x) == JPC_MS_EPH || ((x) >= 0xff30 && (x) <= 0xff3f)))\n- JPC_TAGTREE_MAXDEPTH: #define JPC_TAGTREE_MAXDEPTH\t32 /* <=== src/libjasper/jpc/jpc_tagtree.h:87:87:JPC_TAGTREE_MAXDEPTH:0 */ \n- jpc_ms_dump: void jpc_ms_dump(jpc_ms_t *ms, FILE *out) /* <=== jpc_ms_dump */ \n{\n\tconst jpc_mstabent_t *mstabent;\n\tmstabent = jpc_mstab_lookup(ms->id);\n\tfprintf(out, \"type = 0x%04\"PRIxFAST16\" (%s);\", ms->id, mstabent->name);\n\tif (JPC_MS_HASPARMS(ms->id)) {\n\t\tfprintf(out, \" len = %\"PRIuFAST16\";\", ms->len + 2);\n\t\tif (ms->ops->dumpparms) {\n\t\t\t(*ms->ops->dumpparms)(ms, out);\n\t\t} else {\n\t\t\tfprintf(out, \"\\n\");\n\t\t}\n\t} else {\n\t\tfprintf(out, \"\\n\");\n\t}\n}\n- jas_stream_memopen: jas_stream_t *jas_stream_memopen(char *buf, int bufsize) /* <=== jas_stream_memopen */ \n{\n\tchar *new_buf;\n\tsize_t new_bufsize;\n\n\tJAS_DBGLOG(100, (\"jas_stream_memopen(%p, %d)\\n\", buf, bufsize));\n\tif (bufsize < 0) {\n\t\tjas_deprecated(\"negative buffer size for jas_stream_memopen\");\n\t}\n\tif (buf && bufsize <= 0) {\n\t\t// This was never a valid thing to do with the old API.\n\t\tjas_eprintf(\"Invalid use of jas_stream_memopen detected.\\n\");\n\t\tjas_deprecated(\"A user-provided buffer for \"\n\t\t  \"jas_stream_memopen cannot be growable.\\n\");\n\t}\n\tif (bufsize <= 0) {\n\t\tnew_bufsize = 0;\n\t\tnew_buf = 0;\n\t} else {\n\t\tnew_bufsize = bufsize;\n\t\tnew_buf = buf;\n\t}\n\treturn jas_stream_memopen2(new_buf, new_bufsize);\n}\n- JPC_MS_EPH: #define\tJPC_MS_EPH\t0xff92\t/* End of packet header (EPH). */ /* <=== src/libjasper/jpc/jpc_cs.h:657:657:JPC_MS_EPH:0 */ \n- JPC_SEG_RAW: #define JPC_SEG_RAW\t\t2 /* <=== src/libjasper/jpc/jpc_t1cod.h:95:95:JPC_SEG_RAW:0 */ \n- jpc_getnumnewpasses: static int jpc_getnumnewpasses(jpc_bitstream_t *in) /* <=== jpc_getnumnewpasses */ \n{\n\tint n;\n\n\tif ((n = jpc_bitstream_getbit(in)) > 0) {\n\t\tif ((n = jpc_bitstream_getbit(in)) > 0) {\n\t\t\tif ((n = jpc_bitstream_getbits(in, 2)) == 3) {\n\t\t\t\tif ((n = jpc_bitstream_getbits(in, 5)) == 31) {\n\t\t\t\t\tif ((n = jpc_bitstream_getbits(in, 7)) >= 0) {\n\t\t\t\t\t\tn += 36 + 1;\n\t\t\t\t\t}\n\t\t\t\t} else if (n >= 0) {\n\t\t\t\t\tn += 5 + 1;\n\t\t\t\t}\n\t\t\t} else if (n >= 0) {\n\t\t\t\tn += 2 + 1;\n\t\t\t}\n\t\t} else if (!n) {\n\t\t\tn += 2;\n\t\t}\n\t} else if (!n) {\n\t\t++n;\n\t}\n\n\treturn n;\n}\n- jas_stream_seek: long jas_stream_seek(jas_stream_t *stream, long offset, int origin) /* <=== jas_stream_seek */ \n{\n\tlong newpos;\n\n\tJAS_DBGLOG(100, (\"jas_stream_seek(%p, %ld, %d)\\n\", stream, offset,\n\t  origin));\n\n\t/* The buffer cannot be in use for both reading and writing. */\n\tassert(!((stream->bufmode_ & JAS_STREAM_RDBUF) && (stream->bufmode_ &\n\t  JAS_STREAM_WRBUF)));\n\n\t/* Reset the EOF indicator (since we may not be at the EOF anymore). */\n\tstream->flags_ &= ~JAS_STREAM_EOF;\n\n\tif (stream->bufmode_ & JAS_STREAM_RDBUF) {\n\t\tif (origin == SEEK_CUR) {\n\t\t\toffset -= stream->cnt_;\n\t\t}\n\t} else if (stream->bufmode_ & JAS_STREAM_WRBUF) {\n\t\tif (jas_stream_flush(stream)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tstream->cnt_ = 0;\n\tstream->ptr_ = stream->bufstart_;\n\tstream->bufmode_ &= ~(JAS_STREAM_RDBUF | JAS_STREAM_WRBUF);\n\n\tif ((newpos = (*stream->ops_->seek_)(stream->obj_, offset, origin))\n\t  < 0) {\n\t\treturn -1;\n\t}\n\n\treturn newpos;\n}\n- JPC_BITSTREAM_NOCLOSE: #define\tJPC_BITSTREAM_NOCLOSE\t0x01 /* <=== src/libjasper/jpc/jpc_bs.h:100:100:JPC_BITSTREAM_NOCLOSE:0 */ \n- jas_stream_memopen2: jas_stream_t *jas_stream_memopen2(char *buf, size_t bufsize) /* <=== jas_stream_memopen2 */ \n{\n\tjas_stream_t *stream;\n\tjas_stream_memobj_t *obj;\n\n\tJAS_DBGLOG(100, (\"jas_stream_memopen2(%p, %zu)\\n\", buf, bufsize));\n\n\tassert((buf && bufsize > 0) || (!buf));\n\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* A stream associated with a memory buffer is always opened\n\tfor both reading and writing in binary mode. */\n\tstream->openmode_ = JAS_STREAM_READ | JAS_STREAM_WRITE | JAS_STREAM_BINARY;\n\n\t/* Since the stream data is already resident in memory, buffering\n\tis not necessary. */\n\t/* But... It still may be faster to use buffering anyways. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\t/* Select the operations for a memory stream. */\n\tstream->ops_ = &jas_stream_memops;\n\n\t/* Allocate memory for the underlying memory stream object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_memobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tstream->obj_ = (void *) obj;\n\n\t/* Initialize a few important members of the memory stream object. */\n\tobj->myalloc_ = 0;\n\tobj->buf_ = 0;\n\n\t/* If the buffer size specified is nonpositive, then the buffer\n\tis allocated internally and automatically grown as needed. */\n\tif (!bufsize) {\n\t\tobj->bufsize_ = 1024;\n\t\tobj->growable_ = 1;\n\t} else {\n\t\tobj->bufsize_ = bufsize;\n\t\tobj->growable_ = 0;\n\t}\n\tif (buf) {\n\t\tobj->buf_ = JAS_CAST(unsigned char *, buf);\n\t} else {\n\t\tobj->buf_ = jas_malloc(obj->bufsize_);\n\t\tobj->myalloc_ = 1;\n\t}\n\tif (!obj->buf_) {\n\t\tjas_stream_close(stream);\n\t\treturn 0;\n\t}\n\tJAS_DBGLOG(100, (\"jas_stream_memopen2 buffer buf=%p myalloc=%d\\n\",\n\t  obj->buf_, obj->myalloc_));\n\n\tif (bufsize > 0 && buf) {\n\t\t/* If a buffer was supplied by the caller and its length is positive,\n\t\t  make the associated buffer data appear in the stream initially. */\n\t\tobj->len_ = bufsize;\n\t} else {\n\t\t/* The stream is initially empty. */\n\t\tobj->len_ = 0;\n\t}\n\tobj->pos_ = 0;\n\t\n\treturn stream;\n}\n- jpc_getuint16: int jpc_getuint16(jas_stream_t *in, uint_fast16_t *val) /* <=== jpc_getuint16 */ \n{\n\tuint_fast16_t v;\n\tint c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = (v << 8) | c;\n\tif (val) {\n\t\t*val = v;\n\t}\n\treturn 0;\n}\n- JPC_MS_INMAX: #define\tJPC_MS_INMAX\t0xffff /* <=== src/libjasper/jpc/jpc_cs.h:629:629:JPC_MS_INMAX:0 */ \n- JPC_REFPASS: #define\tJPC_REFPASS\t1\t/* refinement */ /* <=== src/libjasper/jpc/jpc_t1cod.h:102:102:JPC_REFPASS:0 */ \n- jpc_bitstream_alloc: static jpc_bitstream_t *jpc_bitstream_alloc() /* <=== jpc_bitstream_alloc */ \n{\n\tjpc_bitstream_t *bitstream;\n\n\t/* Allocate memory for the new bit stream object. */\n\tif (!(bitstream = jas_malloc(sizeof(jpc_bitstream_t)))) {\n\t\treturn 0;\n\t}\n\t/* Initialize all of the data members. */\n\tbitstream->stream_ = 0;\n\tbitstream->cnt_ = 0;\n\tbitstream->flags_ = 0;\n\tbitstream->openmode_ = 0;\n\n\treturn bitstream;\n}\n- JPC_COD_EPH: #define\tJPC_COD_EPH\t0x04 /* <=== src/libjasper/jpc/jpc_cs.h:234:234:JPC_COD_EPH:0 */ \n- jas_malloc: void *jas_malloc(size_t size) /* <=== jas_malloc */ \n{\n\tvoid *result;\n\tJAS_DBGLOG(101, (\"jas_malloc(%zu)\\n\", size));\n\tresult = malloc(size);\n\tJAS_DBGLOG(100, (\"jas_malloc(%zu) -> %p\\n\", size, result));\n\treturn result;\n}\n- JPC_CLNPASS: #define\tJPC_CLNPASS\t2\t/* cleanup */ /* <=== src/libjasper/jpc/jpc_t1cod.h:103:103:JPC_CLNPASS:0 */ \n- jpc_seg_alloc: jpc_dec_seg_t *jpc_seg_alloc() /* <=== jpc_seg_alloc */ \n{\n\tjpc_dec_seg_t *seg;\n\n\tif (!(seg = jas_malloc(sizeof(jpc_dec_seg_t)))) {\n\t\treturn 0;\n\t}\n\tseg->prev = 0;\n\tseg->next = 0;\n\tseg->passno = -1;\n\tseg->numpasses = 0;\n\tseg->maxpasses = 0;\n\tseg->type = JPC_SEG_INVALID;\n\tseg->stream = 0;\n\tseg->cnt = 0;\n\tseg->complete = 0;\n\tseg->lyrno = -1;\n\treturn seg;\n}\n- JPC_SEGPASSCNT: int JPC_SEGPASSCNT(int passno, int firstpassno, int numpasses, int bypass, int termall) /* <=== JPC_SEGPASSCNT */ \n{\n\tint ret;\n\tint passtype;\n\n\tif (termall) {\n\t\tret = 1;\n\t} else if (bypass) {\n\t\tif (passno < firstpassno + 10) {\n\t\t\tret = 10 - (passno - firstpassno);\n\t\t} else {\n\t\t\tpasstype = JPC_PASSTYPE(passno);\n\t\t\tswitch (passtype) {\n\t\t\tcase JPC_SIGPASS:\n\t\t\t\tret = 2;\n\t\t\t\tbreak;\n\t\t\tcase JPC_REFPASS:\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\tcase JPC_CLNPASS:\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tret = -1;\n\t\t\t\tassert(0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tret = JPC_PREC * 3 - 2;\n\t}\n\tret = JAS_MIN(ret, numpasses - passno);\n\treturn ret;\n}\n- JPC_MS_INMIN: #define\tJPC_MS_INMIN\t0xff80 /* <=== src/libjasper/jpc/jpc_cs.h:627:627:JPC_MS_INMIN:0 */ \n- jpc_getcommacode: static int jpc_getcommacode(jpc_bitstream_t *in) /* <=== jpc_getcommacode */ \n{\n\tint n;\n\tint v;\n\n\tn = 0;\n\tfor (;;) {\n\t\tif ((v = jpc_bitstream_getbit(in)) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jpc_bitstream_eof(in)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (!v) {\n\t\t\tbreak;\n\t\t}\n\t\t++n;\n\t}\n\n\treturn n;\n}\n- JAS_MIN: #define\tJAS_MIN(x, y) \\ /* <=== src/libjasper/include/jasper/jas_math.h:104:105:JAS_MIN:2 */ \n\t(((x) < (y)) ? (x) : (y))\n- JPC_BITSTREAM_EOF: #define\tJPC_BITSTREAM_EOF\t0x02 /* <=== src/libjasper/jpc/jpc_bs.h:102:102:JPC_BITSTREAM_EOF:0 */ \n- jas_free: void jas_free(void *ptr) /* <=== jas_free */ \n{\n\tJAS_DBGLOG(100, (\"jas_free(%p)\\n\", ptr));\n\tfree(ptr);\n}\n- jas_stream_close: int jas_stream_close(jas_stream_t *stream) /* <=== jas_stream_close */ \n{\n\tJAS_DBGLOG(100, (\"jas_stream_close(%p)\\n\", stream));\n\n\t/* Flush buffer if necessary. */\n\tjas_stream_flush(stream);\n\n\t/* Close the underlying stream object. */\n\t(*stream->ops_->close_)(stream->obj_);\n\n\tjas_stream_destroy(stream);\n\n\treturn 0;\n}\n- JPC_COX_TERMALL: #define\tJPC_COX_TERMALL\t0x04 /* Terminate all coding passes. */ /* <=== src/libjasper/jpc/jpc_cs.h:259:259:JPC_COX_TERMALL:0 */ \n- jpc_bitstream_getbits: long jpc_bitstream_getbits(jpc_bitstream_t *bitstream, int n) /* <=== jpc_bitstream_getbits */ \n{\n\tlong v;\n\tint u;\n\n\t/* We can reliably get at most 31 bits since ISO/IEC 9899 only\n\t  guarantees that a long can represent values up to 2^31-1. */\n\t//assert(n >= 0 && n < 32);\n\tif (n < 0 || n >= 32) {\n\t\treturn -1;\n\t}\n\n\t/* Get the number of bits requested from the specified bit stream. */\n\tv = 0;\n\twhile (--n >= 0) {\n\t\tif ((u = jpc_bitstream_getbit(bitstream)) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tv = (v << 1) | u;\n\t}\n\treturn v;\n}\n- jpc_getdata: int jpc_getdata(jas_stream_t *in, jas_stream_t *out, long len) /* <=== jpc_getdata */ \n{\n\treturn jas_stream_copy(out, in, len);\n}\n- jas_stream_tell: long jas_stream_tell(jas_stream_t *stream) /* <=== jas_stream_tell */ \n{\n\tint adjust;\n\tint offset;\n\n\tJAS_DBGLOG(100, (\"jas_stream_tell(%p)\\n\", stream));\n\n\tif (stream->bufmode_ & JAS_STREAM_RDBUF) {\n\t\tadjust = -stream->cnt_;\n\t} else if (stream->bufmode_ & JAS_STREAM_WRBUF) {\n\t\tadjust = stream->ptr_ - stream->bufstart_;\n\t} else {\n\t\tadjust = 0;\n\t}\n\n\tif ((offset = (*stream->ops_->seek_)(stream->obj_, 0, SEEK_CUR)) < 0) {\n\t\treturn -1;\n\t}\n\n\treturn offset + adjust;\n}\n- jpc_bitstream_align: int jpc_bitstream_align(jpc_bitstream_t *bitstream) /* <=== jpc_bitstream_align */ \n{\n\tint ret;\n\tif (bitstream->openmode_ & JPC_BITSTREAM_READ) {\n\t\tret = jpc_bitstream_inalign(bitstream, 0, 0);\n\t} else if (bitstream->openmode_ & JPC_BITSTREAM_WRITE) {\n\t\tret = jpc_bitstream_outalign(bitstream, 0);\n\t} else {\n\t\tabort();\n\t}\n\treturn ret;\n}\n- jpc_floorlog2: int jpc_floorlog2(int x) /* <=== jpc_floorlog2 */ \n{\n\tint y;\n\n\t/* The argument must be positive. */\n\tassert(x > 0);\n\n\ty = 0;\n\twhile (x > 1) {\n\t\tx >>= 1;\n\t\t++y;\n\t}\n\treturn y;\n}\n- jpc_tagtree_getleaf: jpc_tagtreenode_t *jpc_tagtree_getleaf(jpc_tagtree_t *tree, int n) /* <=== jpc_tagtree_getleaf */ \n{\n\treturn &tree->nodes_[n];\n}\n- jpc_getms: jpc_ms_t *jpc_getms(jas_stream_t *in, jpc_cstate_t *cstate) /* <=== jpc_getms */ \n{\n\tjpc_ms_t *ms;\n\tconst jpc_mstabent_t *mstabent;\n\tjas_stream_t *tmpstream;\n\n\tif (!(ms = jpc_ms_create(0))) {\n\t\treturn 0;\n\t}\n\n\t/* Get the marker type. */\n\tif (jpc_getuint16(in, &ms->id) || ms->id < JPC_MS_MIN ||\n\t  ms->id > JPC_MS_MAX) {\n\t\tjpc_ms_destroy(ms);\n\t\treturn 0;\n\t}\n\n\tmstabent = jpc_mstab_lookup(ms->id);\n\tms->ops = &mstabent->ops;\n\n\t/* Get the marker segment length and parameters if present. */\n\t/* Note: It is tacitly assumed that a marker segment cannot have\n\t  parameters unless it has a length field.  That is, there cannot\n\t  be a parameters field without a length field and vice versa. */\n\tif (JPC_MS_HASPARMS(ms->id)) {\n\t\t/* Get the length of the marker segment. */\n\t\tif (jpc_getuint16(in, &ms->len) || ms->len < 3) {\n\t\t\tjpc_ms_destroy(ms);\n\t\t\treturn 0;\n\t\t}\n\t\t/* Calculate the length of the marker segment parameters. */\n\t\tms->len -= 2;\n\t\t/* Create and prepare a temporary memory stream from which to\n\t\t  read the marker segment parameters. */\n\t\t/* Note: This approach provides a simple way of ensuring that\n\t\t  we never read beyond the end of the marker segment (even if\n\t\t  the marker segment length is errantly set too small). */\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tjpc_ms_destroy(ms);\n\t\t\treturn 0;\n\t\t}\n\t\tif (jas_stream_copy(tmpstream, in, ms->len) ||\n\t\t  jas_stream_seek(tmpstream, 0, SEEK_SET) < 0) {\n\t\t\tjas_stream_close(tmpstream);\n\t\t\tjpc_ms_destroy(ms);\n\t\t\treturn 0;\n\t\t}\n\t\t/* Get the marker segment parameters. */\n\t\tif ((*ms->ops->getparms)(ms, cstate, tmpstream)) {\n\t\t\tms->ops = 0;\n\t\t\tjpc_ms_destroy(ms);\n\t\t\tjas_stream_close(tmpstream);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (jas_getdbglevel() > 0) {\n\t\t\tjpc_ms_dump(ms, stderr);\n\t\t}\n\n\t\tif (JAS_CAST(jas_ulong, jas_stream_tell(tmpstream)) != ms->len) {\n\t\t\tjas_eprintf(\n\t\t\t  \"warning: trailing garbage in marker segment (%ld bytes)\\n\",\n\t\t\t  ms->len - jas_stream_tell(tmpstream));\n\t\t}\n\n\t\t/* Close the temporary stream. */\n\t\tjas_stream_close(tmpstream);\n\n\t} else {\n\t\t/* There are no marker segment parameters. */\n\t\tms->len = 0;\n\n\t\tif (jas_getdbglevel() > 0) {\n\t\t\tjpc_ms_dump(ms, stderr);\n\t\t}\n\t}\n\n\t/* Update the code stream state information based on the type of\n\t  marker segment read. */\n\t/* Note: This is a bit of a hack, but I'm not going to define another\n\t  type of virtual function for this one special case. */\n\tif (ms->id == JPC_MS_SIZ) {\n\t\tcstate->numcomps = ms->parms.siz.numcomps;\n\t}\n\n\treturn ms;\n}\n- jas_stream_ungetc: int jas_stream_ungetc(jas_stream_t *stream, int c) /* <=== jas_stream_ungetc */ \n{\n\tif (!stream->ptr_ || stream->ptr_ == stream->bufbase_) {\n\t\treturn -1;\n\t}\n\n\t/* Reset the EOF indicator (since we now have at least one character\n\t  to read). */\n\tstream->flags_ &= ~JAS_STREAM_EOF;\n\n\t--stream->rwcnt_;\n\t--stream->ptr_;\n\t++stream->cnt_;\n\t*stream->ptr_ = c;\n\treturn 0;\n}\n- jpc_bitstream_sopen: jpc_bitstream_t *jpc_bitstream_sopen(jas_stream_t *stream, const char *mode) /* <=== jpc_bitstream_sopen */ \n{\n\tjpc_bitstream_t *bitstream;\n\n\t/* Ensure that the open mode is valid. */\n#if 0 /* This causes a string literal too long error (with c99 pedantic mode).  Why is this so? */\n\tassert(!strcmp(mode, \"r\") || !strcmp(mode, \"w\") || !strcmp(mode, \"r+\")\n\t  || !strcmp(mode, \"w+\"));\n#endif\n\n\tif (!(bitstream = jpc_bitstream_alloc())) {\n\t\treturn 0;\n\t}\n\n\t/* By default, do not close the underlying (character) stream, upon\n\t  the close of the bit stream. */\n\tbitstream->flags_ = JPC_BITSTREAM_NOCLOSE;\n\n\tbitstream->stream_ = stream;\n\tbitstream->openmode_ = (mode[0] == 'w') ? JPC_BITSTREAM_WRITE :\n\t  JPC_BITSTREAM_READ;\n\n\t/* Mark the data buffer as empty. */\n\tbitstream->cnt_ = (bitstream->openmode_ == JPC_BITSTREAM_READ) ? 0 : 8;\n\tbitstream->buf_ = 0;\n\n\treturn bitstream;\n}\n- JPC_BITSTREAM_READ: #define\tJPC_BITSTREAM_READ\t0x01 /* <=== src/libjasper/jpc/jpc_bs.h:91:91:JPC_BITSTREAM_READ:0 */ \n- JPC_MS_SIZ: #define\tJPC_MS_SIZ\t0xff51 /* Image and tile size (SIZ). */ /* <=== src/libjasper/jpc/jpc_cs.h:638:638:JPC_MS_SIZ:0 */ \n- jpc_ms_create: jpc_ms_t *jpc_ms_create(int type) /* <=== jpc_ms_create */ \n{\n\tjpc_ms_t *ms;\n\tconst jpc_mstabent_t *mstabent;\n\n\tif (!(ms = jas_malloc(sizeof(jpc_ms_t)))) {\n\t\treturn 0;\n\t}\n\tms->id = type;\n\tms->len = 0;\n\tmstabent = jpc_mstab_lookup(ms->id);\n\tms->ops = &mstabent->ops;\n\tmemset(&ms->parms, 0, sizeof(jpc_msparms_t));\n\treturn ms;\n}\n\nType Definitions:\n- jpc_dec_band_t: typedef struct {\n\n\t/* The per-code-block-group state information. */\n\tjpc_dec_prc_t *prcs;\n\n\t/* The sample data associated with this band. */\n\tjas_matrix_t *data;\n\n\t/* The orientation of this band (i.e., LL, LH, HL, or HH). */\n\tint orient;\n\n\t/* The encoded quantizer step size. */\n\tint stepsize;\n\n\t/* The absolute quantizer step size. */\n\tjpc_fix_t absstepsize;\n\n\t/* The number of bit planes for this band. */\n\tint numbps;\n\n\t/* The analysis gain associated with this band. */\n\tint analgain;\n\n\t/* The ROI shift value for this band. */\n\tint roishift;\n\n}\n- jpc_dec_seg_s: typedef struct jpc_dec_seg_s {\n\n\t/* The next segment in the list. */\n\tstruct jpc_dec_seg_s *next;\n\n\t/* The previous segment in the list. */\n\tstruct jpc_dec_seg_s *prev;\n\n\t/* The starting pass number for this segment. */\n\tint passno;\n\n\t/* The number of passes in this segment. */\n\tint numpasses;\n\n\t/* The maximum number of passes in this segment. */\n\tint maxpasses;\n\n\t/* The type of data in this segment (i.e., MQ or raw). */\n\tint type;\n\n\t/* A stream containing the data for this segment. */\n\tjas_stream_t *stream;\n\n\t/* The number of bytes destined for this segment from the packet\n\t  currently being decoded. */\n\tint cnt;\n\n\t/* A flag indicating if this segment has been terminated. */\n\tint complete;\n\n\t/* The layer number to which this segment belongs. */\n\t/* If the segment spans multiple layers, then the largest layer number\n\t  spanned by the segment is used. */\n\tint lyrno;\n\n}\n- jpc_dec_tile_t: typedef struct {\n\n\t/* The processing state for this tile. */\n\tint state;\n\n\t/* The x-coordinate of the top-left corner of the tile on the reference\n\t  grid. */\n\tuint_fast32_t xstart;\n\n\t/* The y-coordinate of the top-left corner of the tile on the reference\n\t  grid. */\n\tuint_fast32_t ystart;\n\n\t/* The x-coordinate of the bottom-right corner of the tile on the\n\t  reference grid (plus one). */\n\tuint_fast32_t xend;\n\n\t/* The y-coordinate of the bottom-right corner of the tile on the\n\t  reference grid (plus one). */\n\tuint_fast32_t yend;\n\n\t/* The packed packet header data for this tile. */\n\tjpc_ppxstab_t *pptstab;\n\n\t/* A stream containing the packed packet header data for this tile. */\n\tjas_stream_t *pkthdrstream;\n\n\t/* The current position within the packed packet header stream. */\n\tlong pkthdrstreampos;\n\n\t/* The coding parameters for this tile. */\n\tjpc_dec_cp_t *cp;\n\n\t/* The per tile-component information. */\n\tjpc_dec_tcomp_t *tcomps;\n\n\t/* The next expected tile-part number. */\n\tint partno;\n\n\t/* The number of tile-parts. */\n\tint numparts;\n\n\t/* The coding mode. */\n\tint realmode;\n\n\t/* The packet iterator for this tile. */\n\tjpc_pi_t *pi;\n\n}\n- jpc_dec_cblk_t: typedef struct {\n\n\t/* The number of passes. */\n\tint numpasses;\n\n\t/* A list of segments that still need to be decoded. */\n\tjpc_dec_seglist_t segs;\n\n\t/* The first incomplete/partial segment. */\n\tjpc_dec_seg_t *curseg;\n\n\t/* The number of leading insignificant bit planes for this code block. */\n\tint numimsbs;\n\n\t/* The number of bits used to encode pass data lengths. */\n\tint numlenbits;\n\n\t/* The first pass number containing data for this code block. */\n\tint firstpassno;\n\n\t/* The MQ decoder. */\n\tjpc_mqdec_t *mqdec;\n\n\t/* The raw bit stream decoder. */\n\tjpc_bitstream_t *nulldec;\n\n\t/* The per-sample state information for this code block. */\n\tjas_matrix_t *flags;\n\n\t/* The sample data associated with this code block. */\n\tjas_matrix_t *data;\n\n}\n- jpc_tagtreenode_t: typedef struct jpc_tagtreenode_ {\n\n\t/* The parent of this node. */\n\tstruct jpc_tagtreenode_ *parent_;\n\n\t/* The value associated with this node. */\n\tint value_;\n\n\t/* The lower bound on the value associated with this node. */\n\tint low_;\n\n\t/* A flag indicating if the value is known exactly. */\n\tint known_;\n\n} jpc_tagtreenode_t;\n- jpc_dec_seg_t: typedef struct jpc_dec_seg_s {\n\n\t/* The next segment in the list. */\n\tstruct jpc_dec_seg_s *next;\n\n\t/* The previous segment in the list. */\n\tstruct jpc_dec_seg_s *prev;\n\n\t/* The starting pass number for this segment. */\n\tint passno;\n\n\t/* The number of passes in this segment. */\n\tint numpasses;\n\n\t/* The maximum number of passes in this segment. */\n\tint maxpasses;\n\n\t/* The type of data in this segment (i.e., MQ or raw). */\n\tint type;\n\n\t/* A stream containing the data for this segment. */\n\tjas_stream_t *stream;\n\n\t/* The number of bytes destined for this segment from the packet\n\t  currently being decoded. */\n\tint cnt;\n\n\t/* A flag indicating if this segment has been terminated. */\n\tint complete;\n\n\t/* The layer number to which this segment belongs. */\n\t/* If the segment spans multiple layers, then the largest layer number\n\t  spanned by the segment is used. */\n\tint lyrno;\n\n} jpc_dec_seg_t;\n- jpc_bitstream_t: typedef struct {\n\n\t/* Some miscellaneous flags. */\n\tint flags_;\n\n\t/* The input/output buffer. */\n\tuint_fast16_t buf_;\n\n\t/* The number of bits remaining in the byte being read/written. */\n\tint cnt_;\n\n\t/* The underlying stream associated with this bit stream. */\n\tjas_stream_t *stream_;\n\n\t/* The mode in which this bit stream was opened. */\n\tint openmode_;\n\n}\n- jas_stream_t: typedef struct {\n\n\t/* The mode in which the stream was opened. */\n\tint openmode_;\n\n\t/* The buffering mode. */\n\tint bufmode_;\n\n\t/* The stream status. */\n\tint flags_;\n\n\t/* The start of the buffer area to use for reading/writing. */\n\tjas_uchar *bufbase_;\n\n\t/* The start of the buffer area excluding the extra initial space for\n\t  character putback. */\n\tjas_uchar *bufstart_;\n\n\t/* The buffer size. */\n\tint bufsize_;\n\n\t/* The current position in the buffer. */\n\tjas_uchar *ptr_;\n\n\t/* The number of characters that must be read/written before\n\tthe buffer needs to be filled/flushed. */\n\tint cnt_;\n\n\t/* A trivial buffer to be used for unbuffered operation. */\n\tjas_uchar tinybuf_[JAS_STREAM_MAXPUTBACK + 1];\n\n\t/* The operations for the underlying stream file object. */\n\tconst jas_stream_ops_t *ops_;\n\n\t/* The underlying stream file object. */\n\tjas_stream_obj_t *obj_;\n\n\t/* The number of characters read/written. */\n\tlong rwcnt_;\n\n\t/* The maximum number of characters that may be read/written. */\n\tlong rwlimit_;\n\n}\n- jpc_dec_ccp_t: typedef struct {\n\n\t/* How were various coding parameters set? */\n\tint flags;\n\n\t/* Per-component coding style parameters (e.g., explicit precinct sizes) */\n\tuint_fast8_t csty;\n\n\t/* The number of resolution levels. */\n\tuint_fast8_t numrlvls;\n\n\t/* The code block width exponent. */\n\tuint_fast8_t cblkwidthexpn;\n\n\t/* The code block height exponent. */\n\tuint_fast8_t cblkheightexpn;\n\n\t/* The QMFB ID. */\n\tuint_fast8_t qmfbid;\n\n\t/* The quantization style. */\n\tuint_fast8_t qsty;\n\n\t/* The number of quantizer step sizes. */\n\tuint_fast16_t numstepsizes;\n\n\t/* The step sizes. */\n\tuint_fast16_t stepsizes[3 * JPC_MAXRLVLS + 1];\n\n\t/* The number of guard bits. */\n\tuint_fast8_t numguardbits;\n\n\t/* The ROI shift value. */\n\tuint_fast8_t roishift;\n\n\t/* The code block parameters. */\n\tuint_fast8_t cblkctx;\n\n\t/* The precinct width exponents. */\n\tuint_fast8_t prcwidthexpns[JPC_MAXRLVLS];\n\n\t/* The precinct height exponents. */\n\tuint_fast8_t prcheightexpns[JPC_MAXRLVLS];\n\n}\n- jpc_dec_rlvl_t: typedef struct {\n\n\t/* The number of bands associated with this resolution level. */\n\tint numbands;\n\n\t/* The per-band information. */\n\tjpc_dec_band_t *bands;\n\n\t/* The x-coordinate of the top-left corner of the tile-component\n\t  at this resolution. */\n\tuint_fast32_t xstart;\n\n\t/* The y-coordinate of the top-left corner of the tile-component\n\t  at this resolution. */\n\tuint_fast32_t ystart;\n\n\t/* The x-coordinate of the bottom-right corner of the tile-component\n\t  at this resolution (plus one). */\n\tuint_fast32_t xend;\n\n\t/* The y-coordinate of the bottom-right corner of the tile-component\n\t  at this resolution (plus one). */\n\tuint_fast32_t yend;\n\n\t/* The exponent value for the nominal precinct width measured\n\t  relative to the associated LL band. */\n\tint prcwidthexpn;\n\n\t/* The exponent value for the nominal precinct height measured\n\t  relative to the associated LL band. */\n\tint prcheightexpn;\n\n\t/* The number of precincts in the horizontal direction. */\n\tint numhprcs;\n\n\t/* The number of precincts in the vertical direction. */\n\tint numvprcs;\n\n\t/* The total number of precincts. */\n\tint numprcs;\n\n\t/* The exponent value for the nominal code block group width.\n\t  This quantity is associated with the next lower resolution level\n\t  (assuming that there is one). */\n\tint cbgwidthexpn;\n\n\t/* The exponent value for the nominal code block group height\n\t  This quantity is associated with the next lower resolution level\n\t  (assuming that there is one). */\n\tint cbgheightexpn;\n\n\t/* The exponent value for the code block width. */\n\tuint_fast16_t cblkwidthexpn;\n\n\t/* The exponent value for the code block height. */\n\tuint_fast16_t cblkheightexpn;\n\n}\n- jpc_dec_tcomp_t: typedef struct {\n\n\t/* The x-coordinate of the top-left corner of the tile-component\n\t  in the coordinate system of the tile-component. */\n\tuint_fast32_t xstart;\n\n\t/* The y-coordinate of the top-left corner of the tile-component\n\t  in the coordinate system of the tile-component. */\n\tuint_fast32_t ystart;\n\n\t/* The x-coordinate of the bottom-right corner of the tile-component\n\t  in the coordinate system of the tile-component (plus one). */\n\tuint_fast32_t xend;\n\n\t/* The y-coordinate of the bottom-right corner of the tile-component\n\t  in the coordinate system of the tile-component (plus one). */\n\tuint_fast32_t yend;\n\n\t/* The component data for the current tile. */\n\tjas_matrix_t *data;\n\n\t/* The number of resolution levels. */\n\tint numrlvls;\n\n\t/* The per resolution level information. */\n\tjpc_dec_rlvl_t *rlvls;\n\n\t/* The TSFB. */\n\tjpc_tsfb_t *tsfb;\n\n}\n- jpc_tagtreenode_: typedef struct jpc_tagtreenode_ {\n\n\t/* The parent of this node. */\n\tstruct jpc_tagtreenode_ *parent_;\n\n\t/* The value associated with this node. */\n\tint value_;\n\n\t/* The lower bound on the value associated with this node. */\n\tint low_;\n\n\t/* A flag indicating if the value is known exactly. */\n\tint known_;\n\n}\n- jpc_dec_cp_t: typedef struct {\n\n\t/* How were these coding parameters set? */\n\tint flags;\n\n\t/* Progression change list. */\n\tjpc_pchglist_t *pchglist;\n\n\t/* Progression order. */\n\tuint_fast8_t prgord;\n\n\t/* The number of layers. */\n\tuint_fast16_t numlyrs;\n\n\t/* The MCT ID. */\n\tuint_fast8_t mctid;\n\n\t/* The coding style parameters (e.g., SOP, EPH). */\n\tuint_fast8_t csty;\n\n\t/* The number of components. */\n\tint numcomps;\n\n\t/* The per-component coding parameters. */\n\tjpc_dec_ccp_t *ccps;\n\n}\n- jpc_ms_t: typedef struct {\n\n\t/* The type of marker segment. */\n\tuint_fast16_t id;\n\n\t/* The length of the marker segment. */\n\tuint_fast16_t len;\n\n\t/* The starting offset within the stream. */\n\tuint_fast32_t off;\n\n\t/* The parameters of the marker segment. */\n\tjpc_msparms_t parms;\n\n\t/* The marker segment operations. */\n\tconst struct jpc_msops_s *ops;\n\n}\n- jpc_dec_prc_t: typedef struct {\n\n\t/* The x-coordinate of the top-left corner of the precinct. */\n\tuint_fast32_t xstart;\n\n\t/* The y-coordinate of the top-left corner of the precinct. */\n\tuint_fast32_t ystart;\n\n\t/* The x-coordinate of the bottom-right corner of the precinct\n\t  (plus one). */\n\tuint_fast32_t xend;\n\n\t/* The y-coordinate of the bottom-right corner of the precinct\n\t  (plus one). */\n\tuint_fast32_t yend;\n\n\t/* The number of code blocks spanning this precinct in the horizontal\n\t  direction. */\n\tint numhcblks;\n\n\t/* The number of code blocks spanning this precinct in the vertical\n\t  direction. */\n\tint numvcblks;\n\n\t/* The total number of code blocks in this precinct. */\n\tint numcblks;\n\n\t/* The per code block information. */\n\tjpc_dec_cblk_t *cblks;\n\n\t/* The inclusion tag tree. */\n\tjpc_tagtree_t *incltagtree;\n\n\t/* The insignificant MSBs tag tree. */\n\tjpc_tagtree_t *numimsbstagtree;\n\n}\n- jpc_dec_t: typedef struct {\n\n\t/* The decoded image. */\n\tjas_image_t *image;\n\n\t/* The x-coordinate of the top-left corner of the image area on\n\t  the reference grid. */\n\tuint_fast32_t xstart;\n\n\t/* The y-coordinate of the top-left corner of the image area on\n\t  the reference grid. */\n\tuint_fast32_t ystart;\n\n\t/* The x-coordinate of the bottom-right corner of the image area on\n\t  the reference grid (plus one). */\n\tuint_fast32_t xend;\n\n\t/* The y-coordinate of the bottom-right corner of the image area on\n\t  the reference grid (plus one). */\n\tuint_fast32_t yend;\n\n\t/* The nominal tile width in units of the image reference grid. */\n\tuint_fast32_t tilewidth;\n\n\t/* The nominal tile height in units of the image reference grid. */\n\tuint_fast32_t tileheight;\n\n\t/* The horizontal offset from the origin of the reference grid to the\n\t  left side of the first tile. */\n\tuint_fast32_t tilexoff;\n\n\t/* The vertical offset from the origin of the reference grid to the\n\t  top side of the first tile. */\n\tuint_fast32_t tileyoff;\n\n\t/* The number of tiles spanning the image area in the vertical\n\t  direction. */\n\tint numhtiles;\n\n\t/* The number of tiles spanning the image area in the horizontal\n\t  direction. */\n\tint numvtiles;\n\n\t/* The total number of tiles. */\n\tint numtiles;\n\n\t/* The per-tile information. */\n\tjpc_dec_tile_t *tiles;\n\n\t/* The tile currently being processed. */\n\tjpc_dec_tile_t *curtile;\n\n\t/* The number of components. */\n\tint numcomps;\n\n\t/* The stream containing the input JPEG-2000 code stream data. */\n\tjas_stream_t *in;\n\n\t/* The default coding parameters for all tiles. */\n\tjpc_dec_cp_t *cp;\n\n\t/* The maximum number of layers that may be decoded. */\n\tint maxlyrs;\n\n\t/* The maximum number of packets that may be decoded. */\n\tint maxpkts;\n\n\t/* The number of packets decoded so far in the processing of the entire\n\t  code stream. */\n\tint numpkts;\n\n\t/* The next expected PPM marker segment sequence number. */\n\tint ppmseqno;\n\n\t/* The current state for code stream processing. */\n\tint state;\n\n\t/* The per-component information. */\n\tjpc_dec_cmpt_t *cmpts;\n\n\t/* The information from PPM marker segments. */\n\tjpc_ppxstab_t *ppmstab;\n\n\t/* A list of streams containing packet header data from PPM marker\n\t  segments. */\n\tjpc_streamlist_t *pkthdrstreams;\n\n\t/* The expected ending offset for a tile-part. */\n\tlong curtileendoff;\n\n\t/* This is required by the tier-2 decoder. */\n\tjpc_cstate_t *cstate;\n\n\tsize_t max_samples;\n\n}\n\nImports:\n- #include \"jasper/jas_math.h\"\n- #include \"jasper/jas_types.h\"\n- #include <assert.h>\n- #include \"jasper/jas_malloc.h\"\n- #include \"jpc_math.h\"\n- #include \"jasper/jas_debug.h\"\n- #include \"jpc_bs.h\"\n- #include \"jasper/jas_fix.h\"\n- #include <stdio.h>\n- #include \"jpc_t2dec.h\"\n- #include <stdlib.h>\n- #include \"jpc_dec.h\"\n- #include \"jpc_t1cod.h\"\n- #include \"jpc_cs.h\"\n- #include \"jasper/jas_stream.h\"\n- #include \"jpc_mqdec.h\"",
    "commit_msg": "jpc_t2dec: work around CVE-2016-9398 by limiting cblk->firstpassno\n\nThis replaces my commit 910c351ff5a80a373c5f0ec19f012e8d52b8b4c9 which\nwas reverted by fc03b57384225055847ec92659e50f95d9ea63f2\n\nCloses https://github.com/jasper-maint/jasper/issues/10",
    "cve_desc": "The jpc_floorlog2 function in jpc_math.c in JasPer before 1.900.17 allows remote attackers to cause a denial of service (assertion failure) via unspecified vectors.",
    "year": 2020,
    "filename": "jpc_t2dec.c",
    "commit_url": "\"https://github.com/mdadams/jasper/commit/c6f9fb6ec7fc97a5c4213f9077faf8622685d160\""
  },
  {
    "repository": "mdadams/jasper",
    "cve_id": "CVE-2016-9399",
    "cwe_list": [
      "CWE-617"
    ],
    "commit_hash": "84d00fb29a22e360c2ff91bdc2cd81c288826bfc",
    "short_hash": "84d00fb2",
    "vulnerableMethods_before": [
      {
        "filename": "src/libjasper/jpc/jpc_dec.c",
        "method_name": "calcstepsizes",
        "raw_code": "static int calcstepsizes(uint_fast16_t refstepsize, int numrlvls, /* <=== calcstepsizes */ \n  uint_fast16_t *stepsizes)\n{\n\tint bandno;\n\tint numbands;\n\tuint_fast16_t expn;\n\tuint_fast16_t mant;\n\texpn = JPC_QCX_GETEXPN(refstepsize);\n\tmant = JPC_QCX_GETMANT(refstepsize);\n\tnumbands = 3 * numrlvls - 2;\n\tfor (bandno = 0; bandno < numbands; ++bandno) {\n//jas_eprintf(\"DEBUG %d %d %d %d %d\\n\", bandno, expn, numrlvls, bandno, ((numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0)))));\n\t\tstepsizes[bandno] = JPC_QCX_MANT(mant) | JPC_QCX_EXPN(expn + (bandno + 2) / 3);\n\t}\n\treturn 0;\n}",
        "start_line": 1693
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "src/libjasper/jpc/jpc_dec.c",
        "method_name": "calcstepsizes",
        "raw_code": "static int calcstepsizes(uint_fast16_t refstepsize, int numrlvls, /* <=== calcstepsizes */ \n  uint_fast16_t *stepsizes)\n{\n\tint bandno;\n\tint numbands;\n\tuint_fast16_t expn;\n\tuint_fast16_t mant;\n\texpn = JPC_QCX_GETEXPN(refstepsize);\n\tmant = JPC_QCX_GETMANT(refstepsize);\n\tnumbands = 3 * numrlvls - 2;\n\tfor (bandno = 0; bandno < numbands; ++bandno) {\n//jas_eprintf(\"DEBUG %d %d %d %d %d\\n\", bandno, expn, numrlvls, bandno, ((numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0)))));\n\t\tuint_fast16_t e = expn + (bandno + 2) / 3;\n\t\tif (e >= 0x20)\n\t\t\treturn -1;\n\t\tstepsizes[bandno] = JPC_QCX_MANT(mant) | JPC_QCX_EXPN(e);\n\t}\n\treturn 0;\n}",
        "start_line": 1693
      }
    ],
    "code_context": "Called Methods:\n- JPC_QCX_GETEXPN: #define\tJPC_QCX_GETEXPN(x)\t((x) >> 11) /* <=== src/libjasper/jpc/jpc_cs.h:388:388:JPC_QCX_GETEXPN:1 */ \n- JPC_QCX_GETMANT: #define\tJPC_QCX_GETMANT(x)\t((x) & 0x07ff) /* <=== src/libjasper/jpc/jpc_cs.h:389:389:JPC_QCX_GETMANT:1 */ \n- JPC_QCX_EXPN: #define\tJPC_QCX_EXPN(x)\t\t(assert(!((x) & (~0x1f))), (((x) & 0x1f) << 11)) /* <=== src/libjasper/jpc/jpc_cs.h:390:390:JPC_QCX_EXPN:1 */ \n- JPC_QCX_MANT: #define\tJPC_QCX_MANT(x)\t\t(assert(!((x) & (~0x7ff))), ((x) & 0x7ff)) /* <=== src/libjasper/jpc/jpc_cs.h:391:391:JPC_QCX_MANT:1 */ \n\nImports:\n- #include \"jasper/jas_tvp.h\"\n- #include \"jpc_fix.h\"\n- #include <stdlib.h>\n- #include \"jasper/jas_malloc.h\"\n- #include \"jasper/jas_math.h\"\n- #include \"jpc_dec.h\"\n- #include \"jpc_mct.h\"\n- #include \"jpc_math.h\"\n- #include \"jpc_t2dec.h\"\n- #include <assert.h>\n- #include \"jasper/jas_types.h\"\n- #include \"jpc_t1dec.h\"\n- #include \"jpc_cs.h\"\n- #include \"jasper/jas_debug.h\"\n- #include <stdio.h>",
    "commit_msg": "jpc_dec: check for JPC_QCX_EXPN() parameter overflow\n\nAvoid the assertion failure in the JPC_QCX_EXPN() function.  While the\n\"expn\" variable cannot be bigger than 0x1f, adding something to it may\nexceed that limit.\n\nThis condition could be exploited with a malicious JP2 file, allowing\na denial of service attack on processes which parse JP2 files.\n\nFixes CVE-2016-9399 and CVE-2017-13751\n\nCloses https://github.com/jasper-maint/jasper/issues/1",
    "cve_desc": "The calcstepsizes function in jpc_dec.c in JasPer 1.900.22 allows remote attackers to cause a denial of service (assertion failure) via unspecified vectors.",
    "year": 2020,
    "filename": "jpc_dec.c",
    "commit_url": "\"https://github.com/mdadams/jasper/commit/84d00fb29a22e360c2ff91bdc2cd81c288826bfc\""
  },
  {
    "repository": "mdadams/jasper",
    "cve_id": "CVE-2017-13746",
    "cwe_list": [
      "CWE-617"
    ],
    "commit_hash": "1b1c591306817e46e1e6a3300f714992b32f972b",
    "short_hash": "1b1c5913",
    "vulnerableMethods_before": [
      {
        "filename": "src/libjasper/jpc/jpc_dec.c",
        "method_name": "jpc_dec_process_siz",
        "raw_code": "static int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms) /* <=== jpc_dec_process_siz */ \n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tint compno;\n\tint tileno;\n\tjpc_dec_tile_t *tile;\n\tjpc_dec_tcomp_t *tcomp;\n\tint htileno;\n\tint vtileno;\n\tjpc_dec_cmpt_t *cmpt;\n\tsize_t size;\n\tsize_t num_samples;\n\tsize_t num_samples_delta;\n\n\tsize_t tile_samples;\n\tif (!jas_safe_size_mul(siz->tilewidth, siz->tileheight, &tile_samples) ||\n\t    (dec->max_samples > 0 && tile_samples > dec->max_samples)) {\n\t\tjas_eprintf(\"tile too large\\n\");\n\t\treturn -1;\n\t}\n\n\tdec->xstart = siz->xoff;\n\tdec->ystart = siz->yoff;\n\tdec->xend = siz->width;\n\tdec->yend = siz->height;\n\tdec->tilewidth = siz->tilewidth;\n\tdec->tileheight = siz->tileheight;\n\tdec->tilexoff = siz->tilexoff;\n\tdec->tileyoff = siz->tileyoff;\n\tdec->numcomps = siz->numcomps;\n\n\tif (!(dec->cp = jpc_dec_cp_create(dec->numcomps))) {\n\t\treturn -1;\n\t}\n\n\tif (!(dec->cmpts = jas_alloc2(dec->numcomps, sizeof(jpc_dec_cmpt_t)))) {\n\t\treturn -1;\n\t}\n\n\tnum_samples = 0;\n\tfor (compno = 0, cmpt = dec->cmpts; compno < dec->numcomps; ++compno,\n\t  ++cmpt) {\n\t\tcmpt->prec = siz->comps[compno].prec;\n\t\tcmpt->sgnd = siz->comps[compno].sgnd;\n\t\tcmpt->hstep = siz->comps[compno].hsamp;\n\t\tcmpt->vstep = siz->comps[compno].vsamp;\n\t\tcmpt->width = JPC_CEILDIV(dec->xend, cmpt->hstep) -\n\t\t  JPC_CEILDIV(dec->xstart, cmpt->hstep);\n\t\tcmpt->height = JPC_CEILDIV(dec->yend, cmpt->vstep) -\n\t\t  JPC_CEILDIV(dec->ystart, cmpt->vstep);\n\t\tcmpt->hsubstep = 0;\n\t\tcmpt->vsubstep = 0;\n\n\t\tif (!jas_safe_size_mul(cmpt->width, cmpt->height, &num_samples_delta)) {\n\t\t\tjas_eprintf(\"image too large\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (!jas_safe_size_add(num_samples, num_samples_delta, &num_samples)) {\n\t\t\tjas_eprintf(\"image too large\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (dec->max_samples > 0 && num_samples > dec->max_samples) {\n\t\tjas_eprintf(\"maximum number of samples exceeded (%zu > %zu)\\n\",\n\t\t  num_samples, dec->max_samples);\n\t\treturn -1;\n\t}\n\n\tdec->image = 0;\n\n\tdec->numhtiles = JPC_CEILDIV(dec->xend - dec->tilexoff, dec->tilewidth);\n\tdec->numvtiles = JPC_CEILDIV(dec->yend - dec->tileyoff, dec->tileheight);\n\tassert(dec->numhtiles >= 0);\n\tassert(dec->numvtiles >= 0);\n\tif (!jas_safe_size_mul(dec->numhtiles, dec->numvtiles, &size) ||\n\t  size > INT_MAX) {\n\t\treturn -1;\n\t}\n\tif (dec->max_samples > 0 && size > dec->max_samples / 16 / 16) {\n\t\t/* avoid Denial of Service by a malicious input file\n\t\t   with millions of tiny tiles; if max_samples is\n\t\t   configured, then assume the tiles are at least\n\t\t   16x16, and don't allow more than this number of\n\t\t   tiles */\n\t\treturn -1;\n\t}\n\tif (dec->max_samples > 0 && size > dec->max_samples / dec->numcomps / 16) {\n\t\t/* another DoS check: since each tile allocates an\n\t\t   array of components, this check attempts to catch\n\t\t   excessive tile*component numbers */\n\t\treturn -1;\n\t}\n\tdec->numtiles = size;\n\tJAS_DBGLOG(10, (\"numtiles = %d; numhtiles = %d; numvtiles = %d;\\n\",\n\t  dec->numtiles, dec->numhtiles, dec->numvtiles));\n\tif (!(dec->tiles = jas_alloc2(dec->numtiles, sizeof(jpc_dec_tile_t)))) {\n\t\treturn -1;\n\t}\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n\t  ++tile) {\n\t\t/* initialize all tiles with JPC_TILE_DONE so\n\t\t   jpc_dec_destroy() knows which ones need a\n\t\t   jpc_dec_tilefini() call; they are not actually\n\t\t   \"done\", of course */\n\t\ttile->state = JPC_TILE_DONE;\n\t}\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n\t  ++tile) {\n\t\thtileno = tileno % dec->numhtiles;\n\t\tvtileno = tileno / dec->numhtiles;\n\t\ttile->realmode = 0;\n\t\ttile->state = JPC_TILE_INIT;\n\t\ttile->xstart = JAS_MAX(dec->tilexoff + htileno * dec->tilewidth,\n\t\t  dec->xstart);\n\t\ttile->ystart = JAS_MAX(dec->tileyoff + vtileno * dec->tileheight,\n\t\t  dec->ystart);\n\t\ttile->xend = JAS_MIN(dec->tilexoff + (htileno + 1) *\n\t\t  dec->tilewidth, dec->xend);\n\t\ttile->yend = JAS_MIN(dec->tileyoff + (vtileno + 1) *\n\t\t  dec->tileheight, dec->yend);\n\t\ttile->numparts = 0;\n\t\ttile->partno = 0;\n\t\ttile->pkthdrstream = 0;\n\t\ttile->pkthdrstreampos = 0;\n\t\ttile->pptstab = 0;\n\t\ttile->cp = 0;\n\t\ttile->pi = 0;\n\t\tif (!(tile->tcomps = jas_alloc2(dec->numcomps,\n\t\t  sizeof(jpc_dec_tcomp_t)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (compno = 0, cmpt = dec->cmpts, tcomp = tile->tcomps;\n\t\t  compno < dec->numcomps; ++compno, ++cmpt, ++tcomp) {\n\t\t\ttcomp->rlvls = 0;\n\t\t\ttcomp->numrlvls = 0;\n\t\t\ttcomp->data = 0;\n\t\t\ttcomp->xstart = JPC_CEILDIV(tile->xstart, cmpt->hstep);\n\t\t\ttcomp->ystart = JPC_CEILDIV(tile->ystart, cmpt->vstep);\n\t\t\ttcomp->xend = JPC_CEILDIV(tile->xend, cmpt->hstep);\n\t\t\ttcomp->yend = JPC_CEILDIV(tile->yend, cmpt->vstep);\n\t\t\ttcomp->tsfb = 0;\n\t\t}\n\t}\n\n\tdec->pkthdrstreams = 0;\n\n\t/* We should expect to encounter other main header marker segments\n\t  or an SOT marker segment next. */\n\tdec->state = JPC_MH;\n\n\treturn 0;\n}",
        "start_line": 1255
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "src/libjasper/jpc/jpc_dec.c",
        "method_name": "jpc_dec_process_siz",
        "raw_code": "static int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms) /* <=== jpc_dec_process_siz */ \n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tint compno;\n\tint tileno;\n\tjpc_dec_tile_t *tile;\n\tjpc_dec_tcomp_t *tcomp;\n\tint htileno;\n\tint vtileno;\n\tjpc_dec_cmpt_t *cmpt;\n\tsize_t size;\n\tsize_t num_samples;\n\tsize_t num_samples_delta;\n\n\tsize_t total_samples;\n\tif (!jas_safe_size_mul(siz->width, siz->height, &total_samples) ||\n\t    (dec->max_samples > 0 && total_samples > dec->max_samples)) {\n\t\tjas_eprintf(\"image too large\\n\");\n\t\treturn -1;\n\t}\n\n\tsize_t tile_samples;\n\tif (!jas_safe_size_mul(siz->tilewidth, siz->tileheight, &tile_samples) ||\n\t    (dec->max_samples > 0 && tile_samples > dec->max_samples)) {\n\t\tjas_eprintf(\"tile too large\\n\");\n\t\treturn -1;\n\t}\n\n\tdec->xstart = siz->xoff;\n\tdec->ystart = siz->yoff;\n\tdec->xend = siz->width;\n\tdec->yend = siz->height;\n\tdec->tilewidth = siz->tilewidth;\n\tdec->tileheight = siz->tileheight;\n\tdec->tilexoff = siz->tilexoff;\n\tdec->tileyoff = siz->tileyoff;\n\tdec->numcomps = siz->numcomps;\n\n\tif (!(dec->cp = jpc_dec_cp_create(dec->numcomps))) {\n\t\treturn -1;\n\t}\n\n\tif (!(dec->cmpts = jas_alloc2(dec->numcomps, sizeof(jpc_dec_cmpt_t)))) {\n\t\treturn -1;\n\t}\n\n\tnum_samples = 0;\n\tfor (compno = 0, cmpt = dec->cmpts; compno < dec->numcomps; ++compno,\n\t  ++cmpt) {\n\t\tcmpt->prec = siz->comps[compno].prec;\n\t\tcmpt->sgnd = siz->comps[compno].sgnd;\n\t\tcmpt->hstep = siz->comps[compno].hsamp;\n\t\tcmpt->vstep = siz->comps[compno].vsamp;\n\t\tcmpt->width = JPC_CEILDIV(dec->xend, cmpt->hstep) -\n\t\t  JPC_CEILDIV(dec->xstart, cmpt->hstep);\n\t\tcmpt->height = JPC_CEILDIV(dec->yend, cmpt->vstep) -\n\t\t  JPC_CEILDIV(dec->ystart, cmpt->vstep);\n\t\tcmpt->hsubstep = 0;\n\t\tcmpt->vsubstep = 0;\n\n\t\tif (!jas_safe_size_mul(cmpt->width, cmpt->height, &num_samples_delta)) {\n\t\t\tjas_eprintf(\"image too large\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (!jas_safe_size_add(num_samples, num_samples_delta, &num_samples)) {\n\t\t\tjas_eprintf(\"image too large\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (dec->max_samples > 0 && num_samples > dec->max_samples) {\n\t\tjas_eprintf(\"maximum number of samples exceeded (%zu > %zu)\\n\",\n\t\t  num_samples, dec->max_samples);\n\t\treturn -1;\n\t}\n\n\tdec->image = 0;\n\n\tdec->numhtiles = JPC_CEILDIV(dec->xend - dec->tilexoff, dec->tilewidth);\n\tdec->numvtiles = JPC_CEILDIV(dec->yend - dec->tileyoff, dec->tileheight);\n\tassert(dec->numhtiles >= 0);\n\tassert(dec->numvtiles >= 0);\n\tif (!jas_safe_size_mul(dec->numhtiles, dec->numvtiles, &size) ||\n\t  size > INT_MAX) {\n\t\treturn -1;\n\t}\n\tif (dec->max_samples > 0 && size > dec->max_samples / 16 / 16) {\n\t\t/* avoid Denial of Service by a malicious input file\n\t\t   with millions of tiny tiles; if max_samples is\n\t\t   configured, then assume the tiles are at least\n\t\t   16x16, and don't allow more than this number of\n\t\t   tiles */\n\t\treturn -1;\n\t}\n\tif (dec->max_samples > 0 && size > dec->max_samples / dec->numcomps / 16) {\n\t\t/* another DoS check: since each tile allocates an\n\t\t   array of components, this check attempts to catch\n\t\t   excessive tile*component numbers */\n\t\treturn -1;\n\t}\n\tdec->numtiles = size;\n\tJAS_DBGLOG(10, (\"numtiles = %d; numhtiles = %d; numvtiles = %d;\\n\",\n\t  dec->numtiles, dec->numhtiles, dec->numvtiles));\n\tif (!(dec->tiles = jas_alloc2(dec->numtiles, sizeof(jpc_dec_tile_t)))) {\n\t\treturn -1;\n\t}\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n\t  ++tile) {\n\t\t/* initialize all tiles with JPC_TILE_DONE so\n\t\t   jpc_dec_destroy() knows which ones need a\n\t\t   jpc_dec_tilefini() call; they are not actually\n\t\t   \"done\", of course */\n\t\ttile->state = JPC_TILE_DONE;\n\t}\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n\t  ++tile) {\n\t\thtileno = tileno % dec->numhtiles;\n\t\tvtileno = tileno / dec->numhtiles;\n\t\ttile->realmode = 0;\n\t\ttile->state = JPC_TILE_INIT;\n\t\ttile->xstart = JAS_MAX(dec->tilexoff + htileno * dec->tilewidth,\n\t\t  dec->xstart);\n\t\ttile->ystart = JAS_MAX(dec->tileyoff + vtileno * dec->tileheight,\n\t\t  dec->ystart);\n\t\ttile->xend = JAS_MIN(dec->tilexoff + (htileno + 1) *\n\t\t  dec->tilewidth, dec->xend);\n\t\ttile->yend = JAS_MIN(dec->tileyoff + (vtileno + 1) *\n\t\t  dec->tileheight, dec->yend);\n\t\ttile->numparts = 0;\n\t\ttile->partno = 0;\n\t\ttile->pkthdrstream = 0;\n\t\ttile->pkthdrstreampos = 0;\n\t\ttile->pptstab = 0;\n\t\ttile->cp = 0;\n\t\ttile->pi = 0;\n\t\tif (!(tile->tcomps = jas_alloc2(dec->numcomps,\n\t\t  sizeof(jpc_dec_tcomp_t)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (compno = 0, cmpt = dec->cmpts, tcomp = tile->tcomps;\n\t\t  compno < dec->numcomps; ++compno, ++cmpt, ++tcomp) {\n\t\t\ttcomp->rlvls = 0;\n\t\t\ttcomp->numrlvls = 0;\n\t\t\ttcomp->data = 0;\n\t\t\ttcomp->xstart = JPC_CEILDIV(tile->xstart, cmpt->hstep);\n\t\t\ttcomp->ystart = JPC_CEILDIV(tile->ystart, cmpt->vstep);\n\t\t\ttcomp->xend = JPC_CEILDIV(tile->xend, cmpt->hstep);\n\t\t\ttcomp->yend = JPC_CEILDIV(tile->yend, cmpt->vstep);\n\t\t\ttcomp->tsfb = 0;\n\t\t}\n\t}\n\n\tdec->pkthdrstreams = 0;\n\n\t/* We should expect to encounter other main header marker segments\n\t  or an SOT marker segment next. */\n\tdec->state = JPC_MH;\n\n\treturn 0;\n}",
        "start_line": 1255
      }
    ],
    "code_context": "Called Methods:\n- jas_safe_size_add: inline static bool jas_safe_size_add(size_t x, size_t y, size_t *result) /* <=== jas_safe_size_add */ \n{\n\tif (y > SIZE_MAX - x) {\n\t\treturn false;\n\t}\n\tif (result) {\n\t\t*result = x + y;\n\t}\n\treturn true;\n}\n- jas_eprintf: int jas_eprintf(const char *fmt, ...) /* <=== jas_eprintf */ \n{\n\tint ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}\n- jpc_dec_cp_create: static jpc_dec_cp_t *jpc_dec_cp_create(uint_fast16_t numcomps) /* <=== jpc_dec_cp_create */ \n{\n\tjpc_dec_cp_t *cp;\n\tjpc_dec_ccp_t *ccp;\n\tint compno;\n\n\tif (!(cp = jas_malloc(sizeof(jpc_dec_cp_t)))) {\n\t\treturn 0;\n\t}\n\tcp->flags = 0;\n\tcp->numcomps = numcomps;\n\tcp->prgord = 0;\n\tcp->numlyrs = 0;\n\tcp->mctid = 0;\n\tcp->csty = 0;\n\tif (!(cp->ccps = jas_alloc2(cp->numcomps, sizeof(jpc_dec_ccp_t)))) {\n\t\tgoto error;\n\t}\n\tif (!(cp->pchglist = jpc_pchglist_create())) {\n\t\tgoto error;\n\t}\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tccp->flags = 0;\n\t\tccp->numrlvls = 0;\n\t\tccp->cblkwidthexpn = 0;\n\t\tccp->cblkheightexpn = 0;\n\t\tccp->qmfbid = 0;\n\t\tccp->numstepsizes = 0;\n\t\tccp->numguardbits = 0;\n\t\tccp->roishift = 0;\n\t\tccp->cblkctx = 0;\n\t}\n\treturn cp;\nerror:\n\tif (cp) {\n\t\tjpc_dec_cp_destroy(cp);\n\t}\n\treturn 0;\n}\n- jas_malloc: void *jas_malloc(size_t size) /* <=== jas_malloc */ \n{\n\tvoid *result;\n\tJAS_DBGLOG(101, (\"jas_malloc(%zu)\\n\", size));\n\tresult = malloc(size);\n\tJAS_DBGLOG(100, (\"jas_malloc(%zu) -> %p\\n\", size, result));\n\treturn result;\n}\n- jas_safe_size_mul: inline static bool jas_safe_size_mul(size_t x, size_t y, size_t *result) /* <=== jas_safe_size_mul */ \n{\n\t/* Check if overflow would occur */\n\tif (x && y > SIZE_MAX / x) {\n\t\t/* Overflow would occur. */\n\t\treturn false;\n\t}\n\tif (result) {\n\t\t*result = x * y;\n\t}\n\treturn true;\n}\n- jas_getdbglevel: int jas_getdbglevel() /* <=== jas_getdbglevel */ \n{\n\treturn jas_dbglevel;\n}\n- JAS_MIN: #define\tJAS_MIN(x, y) \\ /* <=== src/libjasper/include/jasper/jas_math.h:104:105:JAS_MIN:2 */ \n\t(((x) < (y)) ? (x) : (y))\n- JPC_CEILDIV: #define\tJPC_CEILDIV(x, y)\t(((x) + (y) - 1) / (y)) /* <=== src/libjasper/jpc/jpc_math.h:79:79:JPC_CEILDIV:2 */ \n- jpc_pchglist_create: jpc_pchglist_t *jpc_pchglist_create() /* <=== jpc_pchglist_create */ \n{\n\tjpc_pchglist_t *pchglist;\n\tif (!(pchglist = jas_malloc(sizeof(jpc_pchglist_t)))) {\n\t\treturn 0;\n\t}\n\tpchglist->numpchgs = 0;\n\tpchglist->maxpchgs = 0;\n\tpchglist->pchgs = 0;\n\treturn pchglist;\n}\n- JPC_TILE_DONE: #define\tJPC_TILE_DONE\t3 /* <=== src/libjasper/jpc/jpc_dec.h:483:483:JPC_TILE_DONE:0 */ \n- jpc_dec_cp_destroy: static void jpc_dec_cp_destroy(jpc_dec_cp_t *cp) /* <=== jpc_dec_cp_destroy */ \n{\n\tif (cp->ccps) {\n\t\tjas_free(cp->ccps);\n\t}\n\tif (cp->pchglist) {\n\t\tjpc_pchglist_destroy(cp->pchglist);\n\t}\n\tjas_free(cp);\n}\n- JPC_MH: #define\tJPC_MH\t\t0x0004 /* <=== src/libjasper/jpc/jpc_dec.c:99:99:JPC_MH:0 */ \n- JAS_MAX: #define\tJAS_MAX(x, y) \\ /* <=== src/libjasper/include/jasper/jas_math.h:108:109:JAS_MAX:2 */ \n\t(((x) > (y)) ? (x) : (y))\n- JPC_TILE_INIT: #define\tJPC_TILE_INIT\t0 /* <=== src/libjasper/jpc/jpc_dec.h:480:480:JPC_TILE_INIT:0 */ \n- JAS_DBGLOG: #define\tJAS_DBGLOG(n, x) \\ /* <=== src/libjasper/include/jasper/jas_debug.h:91:92:JAS_DBGLOG:2 */ \n\t((jas_getdbglevel() >= (n)) ? (jas_eprintf x) : 0)\n- jas_alloc2: void *jas_alloc2(size_t num_elements, size_t element_size) /* <=== jas_alloc2 */ \n{\n\tsize_t size;\n\tif (!jas_safe_size_mul(num_elements, element_size, &size)) {\n\t\treturn 0;\n\t}\n\treturn jas_malloc(size);\n}\n\nType Definitions:\n- jpc_siz_t: typedef struct {\n\n\t/* The code stream capabilities. */\n\tuint_fast16_t caps;\n\n\t/* The width of the image in units of the reference grid. */\n\tuint_fast32_t width;\n\n\t/* The height of the image in units of the reference grid. */\n\tuint_fast32_t height;\n\n\t/* The horizontal offset from the origin of the reference grid to the\n\t  left side of the image area. */\n\tuint_fast32_t xoff;\n\n\t/* The vertical offset from the origin of the reference grid to the\n\t  top side of the image area. */\n\tuint_fast32_t yoff;\n\n\t/* The nominal width of a tile in units of the reference grid. */\n\tuint_fast32_t tilewidth;\n\n\t/* The nominal height of a tile in units of the reference grid. */\n\tuint_fast32_t tileheight;\n\n\t/* The horizontal offset from the origin of the reference grid to the\n\t  left side of the first tile. */\n\tuint_fast32_t tilexoff;\n\n\t/* The vertical offset from the origin of the reference grid to the\n\t  top side of the first tile. */\n\tuint_fast32_t tileyoff;\n\n\t/* The number of components. */\n\tuint_fast16_t numcomps;\n\n\t/* The per-component information. */\n\tjpc_sizcomp_t *comps;\n\n}\n- jpc_dec_tcomp_t: typedef struct {\n\n\t/* The x-coordinate of the top-left corner of the tile-component\n\t  in the coordinate system of the tile-component. */\n\tuint_fast32_t xstart;\n\n\t/* The y-coordinate of the top-left corner of the tile-component\n\t  in the coordinate system of the tile-component. */\n\tuint_fast32_t ystart;\n\n\t/* The x-coordinate of the bottom-right corner of the tile-component\n\t  in the coordinate system of the tile-component (plus one). */\n\tuint_fast32_t xend;\n\n\t/* The y-coordinate of the bottom-right corner of the tile-component\n\t  in the coordinate system of the tile-component (plus one). */\n\tuint_fast32_t yend;\n\n\t/* The component data for the current tile. */\n\tjas_matrix_t *data;\n\n\t/* The number of resolution levels. */\n\tunsigned numrlvls;\n\n\t/* The per resolution level information. */\n\tjpc_dec_rlvl_t *rlvls;\n\n\t/* The TSFB. */\n\tjpc_tsfb_t *tsfb;\n\n}\n- jpc_dec_tile_t: typedef struct {\n\n\t/* The processing state for this tile. */\n\tint state;\n\n\t/* The x-coordinate of the top-left corner of the tile on the reference\n\t  grid. */\n\tuint_fast32_t xstart;\n\n\t/* The y-coordinate of the top-left corner of the tile on the reference\n\t  grid. */\n\tuint_fast32_t ystart;\n\n\t/* The x-coordinate of the bottom-right corner of the tile on the\n\t  reference grid (plus one). */\n\tuint_fast32_t xend;\n\n\t/* The y-coordinate of the bottom-right corner of the tile on the\n\t  reference grid (plus one). */\n\tuint_fast32_t yend;\n\n\t/* The packed packet header data for this tile. */\n\tjpc_ppxstab_t *pptstab;\n\n\t/* A stream containing the packed packet header data for this tile. */\n\tjas_stream_t *pkthdrstream;\n\n\t/* The current position within the packed packet header stream. */\n\tlong pkthdrstreampos;\n\n\t/* The coding parameters for this tile. */\n\tjpc_dec_cp_t *cp;\n\n\t/* The per tile-component information. */\n\tjpc_dec_tcomp_t *tcomps;\n\n\t/* The next expected tile-part number. */\n\tint partno;\n\n\t/* The number of tile-parts. */\n\tint numparts;\n\n\t/* The coding mode. */\n\tint realmode;\n\n\t/* The packet iterator for this tile. */\n\tjpc_pi_t *pi;\n\n}\n- jpc_dec_t: typedef struct {\n\n\t/* The decoded image. */\n\tjas_image_t *image;\n\n\t/* The x-coordinate of the top-left corner of the image area on\n\t  the reference grid. */\n\tuint_fast32_t xstart;\n\n\t/* The y-coordinate of the top-left corner of the image area on\n\t  the reference grid. */\n\tuint_fast32_t ystart;\n\n\t/* The x-coordinate of the bottom-right corner of the image area on\n\t  the reference grid (plus one). */\n\tuint_fast32_t xend;\n\n\t/* The y-coordinate of the bottom-right corner of the image area on\n\t  the reference grid (plus one). */\n\tuint_fast32_t yend;\n\n\t/* The nominal tile width in units of the image reference grid. */\n\tuint_fast32_t tilewidth;\n\n\t/* The nominal tile height in units of the image reference grid. */\n\tuint_fast32_t tileheight;\n\n\t/* The horizontal offset from the origin of the reference grid to the\n\t  left side of the first tile. */\n\tuint_fast32_t tilexoff;\n\n\t/* The vertical offset from the origin of the reference grid to the\n\t  top side of the first tile. */\n\tuint_fast32_t tileyoff;\n\n\t/* The number of tiles spanning the image area in the vertical\n\t  direction. */\n\tint numhtiles;\n\n\t/* The number of tiles spanning the image area in the horizontal\n\t  direction. */\n\tint numvtiles;\n\n\t/* The total number of tiles. */\n\tint numtiles;\n\n\t/* The per-tile information. */\n\tjpc_dec_tile_t *tiles;\n\n\t/* The tile currently being processed. */\n\tjpc_dec_tile_t *curtile;\n\n\t/* The number of components. */\n\tint numcomps;\n\n\t/* The stream containing the input JPEG-2000 code stream data. */\n\tjas_stream_t *in;\n\n\t/* The default coding parameters for all tiles. */\n\tjpc_dec_cp_t *cp;\n\n\t/* The maximum number of layers that may be decoded. */\n\tint maxlyrs;\n\n\t/* The maximum number of packets that may be decoded. */\n\tint maxpkts;\n\n\t/* The number of packets decoded so far in the processing of the entire\n\t  code stream. */\n\tint numpkts;\n\n\t/* The next expected PPM marker segment sequence number. */\n\tint ppmseqno;\n\n\t/* The current state for code stream processing. */\n\tint state;\n\n\t/* The per-component information. */\n\tjpc_dec_cmpt_t *cmpts;\n\n\t/* The information from PPM marker segments. */\n\tjpc_ppxstab_t *ppmstab;\n\n\t/* A list of streams containing packet header data from PPM marker\n\t  segments. */\n\tjpc_streamlist_t *pkthdrstreams;\n\n\t/* The expected ending offset for a tile-part. */\n\tlong curtileendoff;\n\n\t/* This is required by the tier-2 decoder. */\n\tjpc_cstate_t *cstate;\n\n\tsize_t max_samples;\n\n}\n- jpc_dec_cmpt_t: typedef struct {\n\n\t/* The horizontal sampling period. */\n\tuint_fast32_t hstep;\n\n\t/* The vertical sampling period. */\n\tuint_fast32_t vstep;\n\n\t/* The number of samples in the horizontal direction. */\n\tuint_fast32_t width;\n\n\t/* The number of samples in the vertical direction. */\n\tuint_fast32_t height;\n\n\t/* The precision of the sample data. */\n\tuint_fast16_t prec;\n\n\t/* The signedness of the sample data. */\n\tbool sgnd;\n\n\t/* The sample alignment horizontal offset. */\n\tuint_fast32_t hsubstep;\n\t\n\t/* The sample alignment vertical offset. */\n\tuint_fast32_t vsubstep;\n\n}\n- jpc_ms_t: typedef struct {\n\n\t/* The type of marker segment. */\n\tuint_fast16_t id;\n\n\t/* The length of the marker segment. */\n\tuint_fast16_t len;\n\n\t/* The starting offset within the stream. */\n\tuint_fast32_t off;\n\n\t/* The parameters of the marker segment. */\n\tjpc_msparms_t parms;\n\n\t/* The marker segment operations. */\n\tconst struct jpc_msops_s *ops;\n\n}\n\nImports:\n- #include \"jasper/jas_math.h\"\n- #include \"jasper/jas_debug.h\"\n- #include \"jpc_t1dec.h\"\n- #include \"jpc_fix.h\"\n- #include \"jpc_mct.h\"\n- #include \"jasper/jas_types.h\"\n- #include \"jasper/jas_malloc.h\"\n- #include <assert.h>\n- #include \"jasper/jas_tvp.h\"\n- #include \"jpc_dec.h\"\n- #include <stdio.h>\n- #include \"jpc_math.h\"\n- #include \"jpc_cs.h\"\n- #include <stdlib.h>\n- #include \"jpc_t1cod.h\"\n- #include \"jpc_t2dec.h\"",
    "commit_msg": "jpc_dec: fix another integer overflow in SIZ\n\nValidate the width and height values first, before doing anything\nelse.  This prevents integer overflows in the `numhtiles` /\n`numvtiles` calculation below, triggering assertion failures.\n\nFixes CVE-2017-13750\n\nCloses https://github.com/mdadams/jasper/issues/165\nCloses https://github.com/mdadams/jasper/issues/174",
    "cve_desc": "There is a reachable assertion abort in the function jpc_dec_process_siz() in jpc/jpc_dec.c:1297 in JasPer 2.0.12 that will lead to a remote denial of service attack.",
    "year": 2020,
    "filename": "jpc_dec.c",
    "commit_url": "\"https://github.com/mdadams/jasper/commit/1b1c591306817e46e1e6a3300f714992b32f972b\""
  },
  {
    "repository": "mdadams/jasper",
    "cve_id": "CVE-2017-9782",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "839b1bcf0450ff036c28e8db40a7abf886e02891",
    "short_hash": "839b1bcf",
    "vulnerableMethods_before": [
      {
        "filename": "src/libjasper/jp2/jp2_dec.c",
        "method_name": "jp2_decode",
        "raw_code": "jas_image_t *jp2_decode(jas_stream_t *in, const char *optstr) /* <=== jp2_decode */ \n{\n\tjp2_box_t *box;\n\tint found;\n\tjas_image_t *image;\n\tjp2_dec_t *dec;\n\tbool samedtype;\n\tint dtype;\n\tunsigned int i;\n\tjp2_cmap_t *cmapd;\n\tjp2_pclr_t *pclrd;\n\tjp2_cdef_t *cdefd;\n\tunsigned int channo;\n\tint newcmptno;\n\tint_fast32_t *lutents;\n#if 0\n\tjp2_cdefchan_t *cdefent;\n\tint cmptno;\n#endif\n\tjp2_cmapent_t *cmapent;\n\tjas_icchdr_t icchdr;\n\tjas_iccprof_t *iccprof;\n\n\tdec = 0;\n\tbox = 0;\n\timage = 0;\n\n\tJAS_DBGLOG(100, (\"jp2_decode(%p, \\\"%s\\\")\\n\", in, optstr));\n\n\tif (!(dec = jp2_dec_create())) {\n\t\tgoto error;\n\t}\n\n\t/* Get the first box.  This should be a JP box. */\n\tif (!(box = jp2_box_get(in))) {\n\t\tjas_eprintf(\"error: cannot get box\\n\");\n\t\tgoto error;\n\t}\n\tif (box->type != JP2_BOX_JP) {\n\t\tjas_eprintf(\"error: expecting signature box\\n\");\n\t\tgoto error;\n\t}\n\tif (box->data.jp.magic != JP2_JP_MAGIC) {\n\t\tjas_eprintf(\"incorrect magic number\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Get the second box.  This should be a FTYP box. */\n\tif (!(box = jp2_box_get(in))) {\n\t\tgoto error;\n\t}\n\tif (box->type != JP2_BOX_FTYP) {\n\t\tjas_eprintf(\"expecting file type box\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Get more boxes... */\n\tfound = 0;\n\twhile ((box = jp2_box_get(in))) {\n\t\tif (jas_getdbglevel() >= 1) {\n\t\t\tjas_eprintf(\"got box type %s\\n\", box->info->name);\n\t\t}\n\t\tswitch (box->type) {\n\t\tcase JP2_BOX_JP2C:\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\tcase JP2_BOX_IHDR:\n\t\t\tif (!dec->ihdr) {\n\t\t\t\tdec->ihdr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_BPCC:\n\t\t\tif (!dec->bpcc) {\n\t\t\t\tdec->bpcc = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_CDEF:\n\t\t\tif (!dec->cdef) {\n\t\t\t\tdec->cdef = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_PCLR:\n\t\t\tif (!dec->pclr) {\n\t\t\t\tdec->pclr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_CMAP:\n\t\t\tif (!dec->cmap) {\n\t\t\t\tdec->cmap = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_COLR:\n\t\t\tif (!dec->colr) {\n\t\t\t\tdec->colr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (box) {\n\t\t\tjp2_box_destroy(box);\n\t\t\tbox = 0;\n\t\t}\n\t\tif (found) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tjas_eprintf(\"error: no code stream found\\n\");\n\t\tgoto error;\n\t}\n\n\tif (!(dec->image = jpc_decode(in, optstr))) {\n\t\tjas_eprintf(\"error: cannot decode code stream\\n\");\n\t\tgoto error;\n\t}\n\n\t/* An IHDR box must be present. */\n\tif (!dec->ihdr) {\n\t\tjas_eprintf(\"error: missing IHDR box\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Does the number of components indicated in the IHDR box match\n\t  the value specified in the code stream? */\n\tif (dec->ihdr->data.ihdr.numcmpts != JAS_CAST(jas_uint,\n\t  jas_image_numcmpts(dec->image))) {\n\t\tjas_eprintf(\"warning: number of components mismatch\\n\");\n\t}\n\n\t/* At least one component must be present. */\n\tif (!jas_image_numcmpts(dec->image)) {\n\t\tjas_eprintf(\"error: no components\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Determine if all components have the same data type. */\n\tsamedtype = true;\n\tdtype = jas_image_cmptdtype(dec->image, 0);\n\tfor (i = 1; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image)); ++i) {\n\t\tif (jas_image_cmptdtype(dec->image, i) != dtype) {\n\t\t\tsamedtype = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Is the component data type indicated in the IHDR box consistent\n\t  with the data in the code stream? */\n\tif ((samedtype && dec->ihdr->data.ihdr.bpc != JP2_DTYPETOBPC(dtype)) ||\n\t  (!samedtype && dec->ihdr->data.ihdr.bpc != JP2_IHDR_BPCNULL)) {\n\t\tjas_eprintf(\"warning: component data type mismatch\\n\");\n\t}\n\n\t/* Is the compression type supported? */\n\tif (dec->ihdr->data.ihdr.comptype != JP2_IHDR_COMPTYPE) {\n\t\tjas_eprintf(\"error: unsupported compression type\\n\");\n\t\tgoto error;\n\t}\n\n\tif (dec->bpcc) {\n\t\t/* Is the number of components indicated in the BPCC box\n\t\t  consistent with the code stream data? */\n\t\tif (dec->bpcc->data.bpcc.numcmpts != JAS_CAST(jas_uint, jas_image_numcmpts(\n\t\t  dec->image))) {\n\t\t\tjas_eprintf(\"warning: number of components mismatch\\n\");\n\t\t}\n\t\t/* Is the component data type information indicated in the BPCC\n\t\t  box consistent with the code stream data? */\n\t\tif (!samedtype) {\n\t\t\tfor (i = 0; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image));\n\t\t\t  ++i) {\n\t\t\t\tif (jas_image_cmptdtype(dec->image, i) !=\n\t\t\t\t  JP2_BPCTODTYPE(dec->bpcc->data.bpcc.bpcs[i])) {\n\t\t\t\t\tjas_eprintf(\"warning: component data type mismatch\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tjas_eprintf(\"warning: superfluous BPCC box\\n\");\n\t\t}\n\t}\n\n\t/* A COLR box must be present. */\n\tif (!dec->colr) {\n\t\tjas_eprintf(\"error: no COLR box\\n\");\n\t\tgoto error;\n\t}\n\n\tswitch (dec->colr->data.colr.method) {\n\tcase JP2_COLR_ENUM:\n\t\tjas_image_setclrspc(dec->image, jp2_getcs(&dec->colr->data.colr));\n\t\tbreak;\n\tcase JP2_COLR_ICC:\n\t\ticcprof = jas_iccprof_createfrombuf(dec->colr->data.colr.iccp,\n\t\t  dec->colr->data.colr.iccplen);\n\t\tif (!iccprof) {\n\t\t\tjas_eprintf(\"error: failed to parse ICC profile\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_iccprof_gethdr(iccprof, &icchdr);\n\t\tjas_eprintf(\"ICC Profile CS %08x\\n\", icchdr.colorspc);\n\t\tjas_image_setclrspc(dec->image, fromiccpcs(icchdr.colorspc));\n\t\tdec->image->cmprof_ = jas_cmprof_createfromiccprof(iccprof);\n\t\tassert(dec->image->cmprof_);\n\t\tjas_iccprof_destroy(iccprof);\n\t\tbreak;\n\t}\n\n\t/* If a CMAP box is present, a PCLR box must also be present. */\n\tif (dec->cmap && !dec->pclr) {\n\t\tjas_eprintf(\"warning: missing PCLR box or superfluous CMAP box\\n\");\n\t\tjp2_box_destroy(dec->cmap);\n\t\tdec->cmap = 0;\n\t}\n\n\t/* If a CMAP box is not present, a PCLR box must not be present. */\n\tif (!dec->cmap && dec->pclr) {\n\t\tjas_eprintf(\"warning: missing CMAP box or superfluous PCLR box\\n\");\n\t\tjp2_box_destroy(dec->pclr);\n\t\tdec->pclr = 0;\n\t}\n\n\t/* Determine the number of channels (which is essentially the number\n\t  of components after any palette mappings have been applied). */\n\tdec->numchans = dec->cmap ? dec->cmap->data.cmap.numchans :\n\t  JAS_CAST(jas_uint, jas_image_numcmpts(dec->image));\n\n\t/* Perform a basic sanity check on the CMAP box if present. */\n\tif (dec->cmap) {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\t/* Is the component number reasonable? */\n\t\t\tif (dec->cmap->data.cmap.ents[i].cmptno >= JAS_CAST(jas_uint,\n\t\t\t  jas_image_numcmpts(dec->image))) {\n\t\t\t\tjas_eprintf(\"error: invalid component number in CMAP box\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t/* Is the LUT index reasonable? */\n\t\t\tif (dec->cmap->data.cmap.ents[i].pcol >=\n\t\t\t  dec->pclr->data.pclr.numchans) {\n\t\t\t\tjas_eprintf(\"error: invalid CMAP LUT index\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Allocate space for the channel-number to component-number LUT. */\n\tif (!(dec->chantocmptlut = jas_alloc2(dec->numchans,\n\t  sizeof(uint_fast16_t)))) {\n\t\tjas_eprintf(\"error: no memory\\n\");\n\t\tgoto error;\n\t}\n\n\tif (!dec->cmap) {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\tdec->chantocmptlut[i] = i;\n\t\t}\n\t} else {\n\t\tcmapd = &dec->cmap->data.cmap;\n\t\tpclrd = &dec->pclr->data.pclr;\n\t\tcdefd = &dec->cdef->data.cdef;\n\t\tfor (channo = 0; channo < cmapd->numchans; ++channo) {\n\t\t\tcmapent = &cmapd->ents[channo];\n\t\t\tif (cmapent->map == JP2_CMAP_DIRECT) {\n\t\t\t\tdec->chantocmptlut[channo] = channo;\n\t\t\t} else if (cmapent->map == JP2_CMAP_PALETTE) {\n\t\t\t\tlutents = jas_alloc2(pclrd->numlutents, sizeof(int_fast32_t));\n\t\t\t\tfor (i = 0; i < pclrd->numlutents; ++i) {\n\t\t\t\t\tlutents[i] = pclrd->lutdata[cmapent->pcol + i * pclrd->numchans];\n\t\t\t\t}\n\t\t\t\tnewcmptno = jas_image_numcmpts(dec->image);\n\t\t\t\tjas_image_depalettize(dec->image, cmapent->cmptno,\n\t\t\t\t  pclrd->numlutents, lutents,\n\t\t\t\t  JP2_BPCTODTYPE(pclrd->bpc[cmapent->pcol]), newcmptno);\n\t\t\t\tdec->chantocmptlut[channo] = newcmptno;\n\t\t\t\tjas_free(lutents);\n#if 0\n\t\t\t\tif (dec->cdef) {\n\t\t\t\t\tcdefent = jp2_cdef_lookup(cdefd, channo);\n\t\t\t\t\tif (!cdefent) {\n\t\t\t\t\t\tabort();\n\t\t\t\t\t}\n\t\t\t\tjas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), cdefent->type, cdefent->assoc));\n\t\t\t\t} else {\n\t\t\t\tjas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), 0, channo + 1));\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Mark all components as being of unknown type. */\n\n\tfor (i = 0; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image)); ++i) {\n\t\tjas_image_setcmpttype(dec->image, i, JAS_IMAGE_CT_UNKNOWN);\n\t}\n\n\t/* Determine the type of each component. */\n\tif (dec->cdef) {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\t/* Is the channel number reasonable? */\n\t\t\tif (dec->cdef->data.cdef.ents[i].channo >= dec->numchans) {\n\t\t\t\tjas_eprintf(\"error: invalid channel number in CDEF box\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tjas_image_setcmpttype(dec->image,\n\t\t\t  dec->chantocmptlut[dec->cdef->data.cdef.ents[i].channo],\n\t\t\t  jp2_getct(jas_image_clrspc(dec->image),\n\t\t\t  dec->cdef->data.cdef.ents[i].type,\n\t\t\t  dec->cdef->data.cdef.ents[i].assoc));\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\tjas_image_setcmpttype(dec->image, dec->chantocmptlut[i],\n\t\t\t  jp2_getct(jas_image_clrspc(dec->image), 0, i + 1));\n\t\t}\n\t}\n\n\t/* Delete any components that are not of interest. */\n\tfor (i = jas_image_numcmpts(dec->image); i > 0; --i) {\n\t\tif (jas_image_cmpttype(dec->image, i - 1) == JAS_IMAGE_CT_UNKNOWN) {\n\t\t\tjas_image_delcmpt(dec->image, i - 1);\n\t\t}\n\t}\n\n\t/* Ensure that some components survived. */\n\tif (!jas_image_numcmpts(dec->image)) {\n\t\tjas_eprintf(\"error: no components\\n\");\n\t\tgoto error;\n\t}\n#if 0\njas_eprintf(\"no of components is %d\\n\", jas_image_numcmpts(dec->image));\n#endif\n\n\t/* Prevent the image from being destroyed later. */\n\timage = dec->image;\n\tdec->image = 0;\n\n\tjp2_dec_destroy(dec);\n\n\treturn image;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (dec) {\n\t\tjp2_dec_destroy(dec);\n\t}\n\treturn 0;\n}",
        "start_line": 97
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "src/libjasper/jp2/jp2_dec.c",
        "method_name": "jp2_decode",
        "raw_code": "jas_image_t *jp2_decode(jas_stream_t *in, const char *optstr) /* <=== jp2_decode */ \n{\n\tjp2_box_t *box;\n\tint found;\n\tjas_image_t *image;\n\tjp2_dec_t *dec;\n\tbool samedtype;\n\tint dtype;\n\tunsigned int i;\n\tjp2_cmap_t *cmapd;\n\tjp2_pclr_t *pclrd;\n\tjp2_cdef_t *cdefd;\n\tunsigned int channo;\n\tint newcmptno;\n\tint_fast32_t *lutents;\n#if 0\n\tjp2_cdefchan_t *cdefent;\n\tint cmptno;\n#endif\n\tjp2_cmapent_t *cmapent;\n\tjas_icchdr_t icchdr;\n\tjas_iccprof_t *iccprof;\n\n\tdec = 0;\n\tbox = 0;\n\timage = 0;\n\n\tJAS_DBGLOG(100, (\"jp2_decode(%p, \\\"%s\\\")\\n\", in, optstr));\n\n\tif (!(dec = jp2_dec_create())) {\n\t\tgoto error;\n\t}\n\n\t/* Get the first box.  This should be a JP box. */\n\tif (!(box = jp2_box_get(in))) {\n\t\tjas_eprintf(\"error: cannot get box\\n\");\n\t\tgoto error;\n\t}\n\tif (box->type != JP2_BOX_JP) {\n\t\tjas_eprintf(\"error: expecting signature box\\n\");\n\t\tgoto error;\n\t}\n\tif (box->data.jp.magic != JP2_JP_MAGIC) {\n\t\tjas_eprintf(\"incorrect magic number\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Get the second box.  This should be a FTYP box. */\n\tif (!(box = jp2_box_get(in))) {\n\t\tgoto error;\n\t}\n\tif (box->type != JP2_BOX_FTYP) {\n\t\tjas_eprintf(\"expecting file type box\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Get more boxes... */\n\tfound = 0;\n\twhile ((box = jp2_box_get(in))) {\n\t\tif (jas_getdbglevel() >= 1) {\n\t\t\tjas_eprintf(\"got box type %s\\n\", box->info->name);\n\t\t}\n\t\tswitch (box->type) {\n\t\tcase JP2_BOX_JP2C:\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\tcase JP2_BOX_IHDR:\n\t\t\tif (!dec->ihdr) {\n\t\t\t\tdec->ihdr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_BPCC:\n\t\t\tif (!dec->bpcc) {\n\t\t\t\tdec->bpcc = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_CDEF:\n\t\t\tif (!dec->cdef) {\n\t\t\t\tdec->cdef = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_PCLR:\n\t\t\tif (!dec->pclr) {\n\t\t\t\tdec->pclr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_CMAP:\n\t\t\tif (!dec->cmap) {\n\t\t\t\tdec->cmap = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JP2_BOX_COLR:\n\t\t\tif (!dec->colr) {\n\t\t\t\tdec->colr = box;\n\t\t\t\tbox = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (box) {\n\t\t\tjp2_box_destroy(box);\n\t\t\tbox = 0;\n\t\t}\n\t\tif (found) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tjas_eprintf(\"error: no code stream found\\n\");\n\t\tgoto error;\n\t}\n\n\tif (!(dec->image = jpc_decode(in, optstr))) {\n\t\tjas_eprintf(\"error: cannot decode code stream\\n\");\n\t\tgoto error;\n\t}\n\n\t/* An IHDR box must be present. */\n\tif (!dec->ihdr) {\n\t\tjas_eprintf(\"error: missing IHDR box\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Does the number of components indicated in the IHDR box match\n\t  the value specified in the code stream? */\n\tif (dec->ihdr->data.ihdr.numcmpts != JAS_CAST(jas_uint,\n\t  jas_image_numcmpts(dec->image))) {\n\t\tjas_eprintf(\"warning: number of components mismatch\\n\");\n\t}\n\n\t/* At least one component must be present. */\n\tif (!jas_image_numcmpts(dec->image)) {\n\t\tjas_eprintf(\"error: no components\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Determine if all components have the same data type. */\n\tsamedtype = true;\n\tdtype = jas_image_cmptdtype(dec->image, 0);\n\tfor (i = 1; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image)); ++i) {\n\t\tif (jas_image_cmptdtype(dec->image, i) != dtype) {\n\t\t\tsamedtype = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Is the component data type indicated in the IHDR box consistent\n\t  with the data in the code stream? */\n\tif ((samedtype && dec->ihdr->data.ihdr.bpc != JP2_DTYPETOBPC(dtype)) ||\n\t  (!samedtype && dec->ihdr->data.ihdr.bpc != JP2_IHDR_BPCNULL)) {\n\t\tjas_eprintf(\"warning: component data type mismatch\\n\");\n\t}\n\n\t/* Is the compression type supported? */\n\tif (dec->ihdr->data.ihdr.comptype != JP2_IHDR_COMPTYPE) {\n\t\tjas_eprintf(\"error: unsupported compression type\\n\");\n\t\tgoto error;\n\t}\n\n\tif (dec->bpcc) {\n\t\t/* Is the number of components indicated in the BPCC box\n\t\t  consistent with the code stream data? */\n\t\tif (dec->bpcc->data.bpcc.numcmpts != JAS_CAST(jas_uint, jas_image_numcmpts(\n\t\t  dec->image))) {\n\t\t\tjas_eprintf(\"warning: number of components mismatch\\n\");\n\t\t}\n\t\t/* Is the component data type information indicated in the BPCC\n\t\t  box consistent with the code stream data? */\n\t\tif (!samedtype) {\n\t\t\tfor (i = 0; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image));\n\t\t\t  ++i) {\n\t\t\t\tif (jas_image_cmptdtype(dec->image, i) !=\n\t\t\t\t  JP2_BPCTODTYPE(dec->bpcc->data.bpcc.bpcs[i])) {\n\t\t\t\t\tjas_eprintf(\"warning: component data type mismatch\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tjas_eprintf(\"warning: superfluous BPCC box\\n\");\n\t\t}\n\t}\n\n\t/* A COLR box must be present. */\n\tif (!dec->colr) {\n\t\tjas_eprintf(\"error: no COLR box\\n\");\n\t\tgoto error;\n\t}\n\n\tswitch (dec->colr->data.colr.method) {\n\tcase JP2_COLR_ENUM:\n\t\tjas_image_setclrspc(dec->image, jp2_getcs(&dec->colr->data.colr));\n\t\tbreak;\n\tcase JP2_COLR_ICC:\n\t\ticcprof = jas_iccprof_createfrombuf(dec->colr->data.colr.iccp,\n\t\t  dec->colr->data.colr.iccplen);\n\t\tif (!iccprof) {\n\t\t\tjas_eprintf(\"error: failed to parse ICC profile\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_iccprof_gethdr(iccprof, &icchdr);\n\t\tjas_eprintf(\"ICC Profile CS %08x\\n\", icchdr.colorspc);\n\t\tjas_image_setclrspc(dec->image, fromiccpcs(icchdr.colorspc));\n\t\tdec->image->cmprof_ = jas_cmprof_createfromiccprof(iccprof);\n\t\tassert(dec->image->cmprof_);\n\t\tjas_iccprof_destroy(iccprof);\n\t\tbreak;\n\t}\n\n\t/* If a CMAP box is present, a PCLR box must also be present. */\n\tif (dec->cmap && !dec->pclr) {\n\t\tjas_eprintf(\"warning: missing PCLR box or superfluous CMAP box\\n\");\n\t\tjp2_box_destroy(dec->cmap);\n\t\tdec->cmap = 0;\n\t}\n\n\t/* If a CMAP box is not present, a PCLR box must not be present. */\n\tif (!dec->cmap && dec->pclr) {\n\t\tjas_eprintf(\"warning: missing CMAP box or superfluous PCLR box\\n\");\n\t\tjp2_box_destroy(dec->pclr);\n\t\tdec->pclr = 0;\n\t}\n\n\t/* Determine the number of channels (which is essentially the number\n\t  of components after any palette mappings have been applied). */\n\tdec->numchans = dec->cmap ? dec->cmap->data.cmap.numchans :\n\t  JAS_CAST(jas_uint, jas_image_numcmpts(dec->image));\n\n\t/* Perform a basic sanity check on the CMAP box if present. */\n\tif (dec->cmap) {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\t/* Is the component number reasonable? */\n\t\t\tif (dec->cmap->data.cmap.ents[i].cmptno >= JAS_CAST(jas_uint,\n\t\t\t  jas_image_numcmpts(dec->image))) {\n\t\t\t\tjas_eprintf(\"error: invalid component number in CMAP box\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t/* Is the LUT index reasonable? */\n\t\t\tif (dec->cmap->data.cmap.ents[i].pcol >=\n\t\t\t  dec->pclr->data.pclr.numchans) {\n\t\t\t\tjas_eprintf(\"error: invalid CMAP LUT index\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Allocate space for the channel-number to component-number LUT. */\n\tif (!(dec->chantocmptlut = jas_alloc2(dec->numchans,\n\t  sizeof(uint_fast16_t)))) {\n\t\tjas_eprintf(\"error: no memory\\n\");\n\t\tgoto error;\n\t}\n\n\tif (!dec->cmap) {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\tdec->chantocmptlut[i] = i;\n\t\t}\n\t} else {\n\t\tcmapd = &dec->cmap->data.cmap;\n\t\tpclrd = &dec->pclr->data.pclr;\n\t\tcdefd = &dec->cdef->data.cdef;\n\t\tfor (channo = 0; channo < cmapd->numchans; ++channo) {\n\t\t\tcmapent = &cmapd->ents[channo];\n\t\t\tif (cmapent->map == JP2_CMAP_DIRECT) {\n\t\t\t\tdec->chantocmptlut[channo] = channo;\n\t\t\t} else if (cmapent->map == JP2_CMAP_PALETTE) {\n\t\t\t\tlutents = jas_alloc2(pclrd->numlutents, sizeof(int_fast32_t));\n\t\t\t\tfor (i = 0; i < pclrd->numlutents; ++i) {\n\t\t\t\t\tlutents[i] = pclrd->lutdata[cmapent->pcol + i * pclrd->numchans];\n\t\t\t\t}\n\t\t\t\tnewcmptno = jas_image_numcmpts(dec->image);\n\t\t\t\tjas_image_depalettize(dec->image, cmapent->cmptno,\n\t\t\t\t  pclrd->numlutents, lutents,\n\t\t\t\t  JP2_BPCTODTYPE(pclrd->bpc[cmapent->pcol]), newcmptno);\n\t\t\t\tdec->chantocmptlut[channo] = newcmptno;\n\t\t\t\tjas_free(lutents);\n#if 0\n\t\t\t\tif (dec->cdef) {\n\t\t\t\t\tcdefent = jp2_cdef_lookup(cdefd, channo);\n\t\t\t\t\tif (!cdefent) {\n\t\t\t\t\t\tabort();\n\t\t\t\t\t}\n\t\t\t\tjas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), cdefent->type, cdefent->assoc));\n\t\t\t\t} else {\n\t\t\t\tjas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), 0, channo + 1));\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Mark all components as being of unknown type. */\n\n\tfor (i = 0; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image)); ++i) {\n\t\tjas_image_setcmpttype(dec->image, i, JAS_IMAGE_CT_UNKNOWN);\n\t}\n\n\t/* Determine the type of each component. */\n\tif (dec->cdef) {\n\t\tfor (i = 0; i < dec->cdef->data.cdef.numchans; ++i) {\n\t\t\t/* Is the channel number reasonable? */\n\t\t\tif (dec->cdef->data.cdef.ents[i].channo >= dec->numchans) {\n\t\t\t\tjas_eprintf(\"error: invalid channel number in CDEF box\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tjas_image_setcmpttype(dec->image,\n\t\t\t  dec->chantocmptlut[dec->cdef->data.cdef.ents[i].channo],\n\t\t\t  jp2_getct(jas_image_clrspc(dec->image),\n\t\t\t  dec->cdef->data.cdef.ents[i].type,\n\t\t\t  dec->cdef->data.cdef.ents[i].assoc));\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\tjas_image_setcmpttype(dec->image, dec->chantocmptlut[i],\n\t\t\t  jp2_getct(jas_image_clrspc(dec->image), 0, i + 1));\n\t\t}\n\t}\n\n\t/* Delete any components that are not of interest. */\n\tfor (i = jas_image_numcmpts(dec->image); i > 0; --i) {\n\t\tif (jas_image_cmpttype(dec->image, i - 1) == JAS_IMAGE_CT_UNKNOWN) {\n\t\t\tjas_image_delcmpt(dec->image, i - 1);\n\t\t}\n\t}\n\n\t/* Ensure that some components survived. */\n\tif (!jas_image_numcmpts(dec->image)) {\n\t\tjas_eprintf(\"error: no components\\n\");\n\t\tgoto error;\n\t}\n#if 0\njas_eprintf(\"no of components is %d\\n\", jas_image_numcmpts(dec->image));\n#endif\n\n\t/* Prevent the image from being destroyed later. */\n\timage = dec->image;\n\tdec->image = 0;\n\n\tjp2_dec_destroy(dec);\n\n\treturn image;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (dec) {\n\t\tjp2_dec_destroy(dec);\n\t}\n\treturn 0;\n}",
        "start_line": 97
      }
    ],
    "code_context": "Called Methods:\n- JP2_BOX_JP: #define\tJP2_BOX_JP\t\t0x6a502020\t/* Signature */ /* <=== src/libjasper/jp2/jp2_cod.h:94:94:JP2_BOX_JP:0 */ \n- jpc_dec_opts_create: static jpc_dec_importopts_t *jpc_dec_opts_create(const char *optstr) /* <=== jpc_dec_opts_create */ \n{\n\tjpc_dec_importopts_t *opts;\n\tjas_tvparser_t *tvp;\n\n\topts = 0;\n\n\tif (!(opts = jas_malloc(sizeof(jpc_dec_importopts_t)))) {\n\t\tgoto error;\n\t}\n\n\topts->debug = 0;\n\topts->maxlyrs = JPC_MAXLYRS;\n\topts->maxpkts = -1;\n\topts->max_samples = JAS_DEC_DEFAULT_MAX_SAMPLES;\n\n\tif (!(tvp = jas_tvparser_create(optstr ? optstr : \"\"))) {\n\t\tgoto error;\n\t}\n\n\twhile (!jas_tvparser_next(tvp)) {\n\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(decopts,\n\t\t  jas_tvparser_gettag(tvp)))->id) {\n\t\tcase OPT_MAXLYRS:\n\t\t\topts->maxlyrs = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_DEBUG:\n\t\t\topts->debug = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_MAXPKTS:\n\t\t\topts->maxpkts = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_MAXSAMPLES:\n\t\t\topts->max_samples = strtoull(jas_tvparser_getval(tvp), 0, 10);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tjas_eprintf(\"warning: ignoring invalid option %s\\n\",\n\t\t\t  jas_tvparser_gettag(tvp));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tjas_tvparser_destroy(tvp);\n\n\treturn opts;\n\nerror:\n\tif (opts) {\n\t\tjpc_dec_opts_destroy(opts);\n\t}\n\treturn 0;\n}\n- jas_iccprof_load: jas_iccprof_t *jas_iccprof_load(jas_stream_t *in) /* <=== jas_iccprof_load */ \n{\n\tjas_iccprof_t *prof;\n\tint numtags;\n\tlong curoff;\n\tlong reloff;\n\tlong prevoff;\n\tjas_iccsig_t type;\n\tjas_iccattrval_t *attrval;\n\tjas_iccattrval_t *prevattrval;\n\tjas_icctagtabent_t *tagtabent;\n\tint i;\n\tint len;\n\n\tprof = 0;\n\tattrval = 0;\n\n\tif (!(prof = jas_iccprof_create())) {\n\t\tgoto error;\n\t}\n\n\tif (jas_iccprof_readhdr(in, &prof->hdr)) {\n\t\tjas_eprintf(\"cannot get header\\n\");\n\t\tgoto error;\n\t}\n\tif (jas_iccprof_gettagtab(in, &prof->tagtab)) {\n\t\tjas_eprintf(\"cannot get tab table\\n\");\n\t\tgoto error;\n\t}\n\tjas_iccprof_sorttagtab(&prof->tagtab);\n\n\tnumtags = prof->tagtab.numents;\n\tcuroff = JAS_ICC_HDRLEN + 4 + 12 * numtags;\n\tprevoff = 0;\n\tprevattrval = 0;\n\tfor (i = 0; i < numtags; ++i) {\n\t\ttagtabent = &prof->tagtab.ents[i];\n\t\tif (tagtabent->off == JAS_CAST(jas_iccuint32_t, prevoff)) {\n\t\t\tif (prevattrval) {\n\t\t\t\tif (!(attrval = jas_iccattrval_clone(prevattrval)))\n\t\t\t\t\tgoto error;\n\t\t\t\tif (jas_iccprof_setattr(prof, tagtabent->tag, attrval))\n\t\t\t\t\tgoto error;\n\t\t\t\tjas_iccattrval_destroy(attrval);\n\t\t\t\tattrval = 0;\n\t\t\t} else {\n#if 0\n\t\t\t\tjas_eprintf(\"warning: skipping unknown tag type\\n\");\n#endif\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\treloff = tagtabent->off - curoff;\n\t\tif (reloff > 0) {\n\t\t\tif (jas_stream_gobble(in, reloff) != reloff)\n\t\t\t\tgoto error;\n\t\t\tcuroff += reloff;\n\t\t} else if (reloff < 0) {\n\t\t\t/* This should never happen since we read the tagged\n\t\t\telement data in a single pass. */\n\t\t\tabort();\n\t\t}\n\t\tprevoff = curoff;\n\t\tif (jas_iccgetuint32(in, &type)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jas_stream_gobble(in, 4) != 4) {\n\t\t\tgoto error;\n\t\t}\n\t\tcuroff += 8;\n\t\tif (!jas_iccattrvalinfo_lookup(type)) {\n#if 0\n\t\t\tjas_eprintf(\"warning: skipping unknown tag type\\n\");\n#endif\n\t\t\tprevattrval = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!(attrval = jas_iccattrval_create(type))) {\n\t\t\tgoto error;\n\t\t}\n\t\tlen = tagtabent->len - 8;\n\t\tif ((*attrval->ops->input)(attrval, in, len)) {\n\t\t\tgoto error;\n\t\t}\n\t\tcuroff += len;\n\t\tif (jas_iccprof_setattr(prof, tagtabent->tag, attrval)) {\n\t\t\tgoto error;\n\t\t}\n\t\tprevattrval = attrval; /* This is correct, but slimey. */\n\t\tjas_iccattrval_destroy(attrval);\n\t\tattrval = 0;\n\t}\n\n\treturn prof;\n\nerror:\n\tif (prof)\n\t\tjas_iccprof_destroy(prof);\n\tif (attrval)\n\t\tjas_iccattrval_destroy(attrval);\n\treturn 0;\n}\n- JP2_IHDR_BPCNULL: #define\tJP2_IHDR_BPCNULL\t255 /* <=== src/libjasper/jp2/jp2_cod.h:143:143:JP2_IHDR_BPCNULL:0 */ \n- JP2_COLR_SYCC: #define\tJP2_COLR_SYCC\t18 /* <=== src/libjasper/jp2/jp2_cod.h:170:170:JP2_COLR_SYCC:0 */ \n- JP2_BOX_FTYP: #define JP2_BOX_FTYP\t0x66747970\t/* File Type */ /* <=== src/libjasper/jp2/jp2_cod.h:95:95:JP2_BOX_FTYP:0 */ \n- jp2_box_dump: void jp2_box_dump(jp2_box_t *box, FILE *out) /* <=== jp2_box_dump */ \n{\n\tconst jp2_boxinfo_t *boxinfo;\n\tboxinfo = jp2_boxinfolookup(box->type);\n\tassert(boxinfo);\n\n\tfprintf(out, \"JP2 box: \");\n\tfprintf(out, \"type=%c%s%c (0x%08\"PRIxFAST32\"); length=%\"PRIuFAST32\"\\n\", '\"',\n\t  boxinfo->name, '\"', box->type, box->len);\n\tif (box->ops->dumpdata) {\n\t\t(*box->ops->dumpdata)(box, out);\n\t}\n}\n- jas_stream_rewind: JAS_DLLEXPORT int jas_stream_rewind(jas_stream_t *stream); /* <=== jas_stream_rewind */ \n- jas_stream_copy: JAS_DLLEXPORT int jas_stream_copy(jas_stream_t *dst, jas_stream_t *src, int n); /* <=== jas_stream_copy */ \n- jas_image_setclrspc: #define jas_image_setclrspc(image, clrspc) \\ /* <=== src/libjasper/include/jasper/jas_image.h:358:359:jas_image_setclrspc:2 */ \n\t((image)->clrspc_ = (clrspc))\n- JAS_CAST: #define\tJAS_CAST(t, e) \\ /* <=== src/libjasper/include/jasper/jas_types.h:144:145:JAS_CAST:2 */ \n\t((t) (e))\n- JAS_IMAGE_CT_OPACITY: #define\tJAS_IMAGE_CT_OPACITY\t0x08000 /* <=== src/libjasper/include/jasper/jas_image.h:110:110:JAS_IMAGE_CT_OPACITY:0 */ \n- JAS_DBGLOG: #define\tJAS_DBGLOG(n, x) \\ /* <=== src/libjasper/include/jasper/jas_debug.h:94:95:JAS_DBGLOG:2 */ \n\t((jas_getdbglevel() >= (n)) ? (jas_eprintf x) : 0)\n- JP2_CMAP_DIRECT: #define\tJP2_CMAP_DIRECT\t\t0 /* <=== src/libjasper/jp2/jp2_cod.h:233:233:JP2_CMAP_DIRECT:0 */ \n- JP2_BOX_HDRLEN: #define\tJP2_BOX_HDRLEN(ext) ((ext) ? 16 : 8) /* <=== src/libjasper/jp2/jp2_cod.h:91:91:JP2_BOX_HDRLEN:1 */ \n- JP2_COLR_ENUM: #define\tJP2_COLR_ENUM\t1 /* <=== src/libjasper/jp2/jp2_cod.h:164:164:JP2_COLR_ENUM:0 */ \n- jp2_getuint32: static int jp2_getuint32(jas_stream_t *in, uint_fast32_t *val) /* <=== jp2_getuint32 */ \n{\n\tuint_fast32_t v;\n\tint c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = (v << 8) | c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = (v << 8) | c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = (v << 8) | c;\n\tif (val) {\n\t\t*val = v;\n\t}\n\treturn 0;\n}\n- jp2_getcs: static int jp2_getcs(jp2_colr_t *colr) /* <=== jp2_getcs */ \n{\n\tif (colr->method == JP2_COLR_ENUM) {\n\t\tswitch (colr->csid) {\n\t\tcase JP2_COLR_SRGB:\n\t\t\treturn JAS_CLRSPC_SRGB;\n\t\t\tbreak;\n\t\tcase JP2_COLR_SYCC:\n\t\t\treturn JAS_CLRSPC_SYCBCR;\n\t\t\tbreak;\n\t\tcase JP2_COLR_SGRAY:\n\t\t\treturn JAS_CLRSPC_SGRAY;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn JAS_CLRSPC_UNKNOWN;\n}\n- jas_alloc2: void *jas_alloc2(size_t num_elements, size_t element_size) /* <=== jas_alloc2 */ \n{\n\tsize_t size;\n\tif (!jas_safe_size_mul(num_elements, element_size, &size)) {\n\t\treturn 0;\n\t}\n\treturn jas_malloc(size);\n}\n- jas_image_setcmpttype: #define jas_image_setcmpttype(image, cmptno, type) \\ /* <=== src/libjasper/include/jasper/jas_image.h:363:364:jas_image_setcmpttype:3 */ \n\t((image)->cmpts_[(cmptno)]->type_ = (type))\n- jas_cmprof_createfromiccprof: JAS_DLLEXPORT jas_cmprof_t *jas_cmprof_createfromiccprof(jas_iccprof_t *iccprof); /* <=== jas_cmprof_createfromiccprof */ \n- jp2_getuint64: static int jp2_getuint64(jas_stream_t *in, uint_fast64_t *val) /* <=== jp2_getuint64 */ \n{\n\tuint_fast64_t tmpval;\n\tint i;\n\tint c;\n\n\ttmpval = 0;\n\tfor (i = 0; i < 8; ++i) {\n\t\ttmpval <<= 8;\n\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\ttmpval |= (c & 0xff);\n\t}\n\t*val = tmpval;\n\n\treturn 0;\n}\n- JP2_IHDR_COMPTYPE: #define\tJP2_IHDR_COMPTYPE\t7 /* <=== src/libjasper/jp2/jp2_cod.h:142:142:JP2_IHDR_COMPTYPE:0 */ \n- jp2_box_get: jp2_box_t *jp2_box_get(jas_stream_t *in) /* <=== jp2_box_get */ \n{\n\tjp2_box_t *box;\n\tconst jp2_boxinfo_t *boxinfo;\n\tjas_stream_t *tmpstream;\n\tuint_fast32_t len;\n\tuint_fast64_t extlen;\n\tbool dataflag;\n\n\tbox = 0;\n\ttmpstream = 0;\n\n\tif (!(box = jp2_box_create0())) {\n\t\tgoto error;\n\t}\n\tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n\t\tgoto error;\n\t}\n\tboxinfo = jp2_boxinfolookup(box->type);\n\tbox->info = boxinfo;\n\tbox->len = len;\n\tJAS_DBGLOG(10, (\n\t  \"preliminary processing of JP2 box: \"\n\t  \"type=%c%s%c (0x%08x); length=%\"PRIuFAST32\"\\n\",\n\t  '\"', boxinfo->name, '\"', box->type, box->len\n\t  ));\n\tif (box->len == 1) {\n\t\tJAS_DBGLOG(10, (\"big length\\n\"));\n\t\tif (jp2_getuint64(in, &extlen)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (extlen > 0xffffffffUL) {\n\t\t\tjas_eprintf(\"warning: cannot handle large 64-bit box length\\n\");\n\t\t\textlen = 0xffffffffUL;\n\t\t}\n\t\tbox->len = extlen;\n\t\tbox->datalen = extlen - JP2_BOX_HDRLEN(true);\n\t} else {\n\t\tbox->datalen = box->len - JP2_BOX_HDRLEN(false);\n\t}\n\tif (box->len != 0 && box->len < 8) {\n\t\tgoto error;\n\t}\n\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jas_stream_copy(tmpstream, in, box->datalen)) {\n\t\t\tjas_eprintf(\"cannot copy box data\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_rewind(tmpstream);\n\n\t\t// From here onwards, the box data will need to be destroyed.\n\t\t// So, initialize the box operations.\n\t\tbox->ops = &boxinfo->ops;\n\n\t\tif (box->ops->getdata) {\n\t\t\tif ((*box->ops->getdata)(box, tmpstream)) {\n\t\t\t\tjas_eprintf(\"cannot parse box data\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\tif (jas_getdbglevel() >= 1) {\n\t\tjp2_box_dump(box, stderr);\n\t}\n\n\treturn box;\n\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn 0;\n}\n- JP2_CDEF_YCBCR_CR: #define JP2_CDEF_YCBCR_CR\t3 /* <=== src/libjasper/jp2/jp2_cod.h:199:199:JP2_CDEF_YCBCR_CR:0 */ \n- JP2_DTYPETOBPC: #define JP2_DTYPETOBPC(dtype) \\ /* <=== src/libjasper/jp2/jp2_cod.h:293:294:JP2_DTYPETOBPC:1 */ \n  ((JAS_IMAGE_CDT_GETSGND(dtype) << 7) | (JAS_IMAGE_CDT_GETPREC(dtype) - 1))\n- jas_image_destroy: void jas_image_destroy(jas_image_t *image) /* <=== jas_image_destroy */ \n{\n\tint i;\n\n\tif (image->cmpts_) {\n\t\tfor (i = 0; i < image->numcmpts_; ++i) {\n\t\t\tjas_image_cmpt_destroy(image->cmpts_[i]);\n\t\t\timage->cmpts_[i] = 0;\n\t\t}\n\t\tjas_free(image->cmpts_);\n\t}\n\tif (image->cmprof_)\n\t\tjas_cmprof_destroy(image->cmprof_);\n\tjas_free(image);\n}\n- jp2_getct: static int jp2_getct(int colorspace, int type, int assoc) /* <=== jp2_getct */ \n{\n\tif (type == 1 && assoc == 0) {\n\t\treturn JAS_IMAGE_CT_OPACITY;\n\t}\n\tif (type == 0 && assoc >= 1 && assoc <= 65534) {\n\t\tswitch (colorspace) {\n\t\tcase JAS_CLRSPC_FAM_RGB:\n\t\t\tswitch (assoc) {\n\t\t\tcase JP2_CDEF_RGB_R:\n\t\t\t\treturn JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R);\n\t\t\t\tbreak;\n\t\t\tcase JP2_CDEF_RGB_G:\n\t\t\t\treturn JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G);\n\t\t\t\tbreak;\n\t\t\tcase JP2_CDEF_RGB_B:\n\t\t\t\treturn JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JAS_CLRSPC_FAM_YCBCR:\n\t\t\tswitch (assoc) {\n\t\t\tcase JP2_CDEF_YCBCR_Y:\n\t\t\t\treturn JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_Y);\n\t\t\t\tbreak;\n\t\t\tcase JP2_CDEF_YCBCR_CB:\n\t\t\t\treturn JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_CB);\n\t\t\t\tbreak;\n\t\t\tcase JP2_CDEF_YCBCR_CR:\n\t\t\t\treturn JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_CR);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JAS_CLRSPC_FAM_GRAY:\n\t\t\tswitch (assoc) {\n\t\t\tcase JP2_CDEF_GRAY_Y:\n\t\t\t\treturn JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn JAS_IMAGE_CT_COLOR(assoc - 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn JAS_IMAGE_CT_UNKNOWN;\n}\n- ICC_CS_GRAY: #define ICC_CS_GRAY\t0x47524159 /* <=== src/libjasper/jp2/jp2_cod.h:300:300:ICC_CS_GRAY:0 */ \n- JP2_CDEF_GRAY_Y: #define\tJP2_CDEF_GRAY_Y\t1 /* <=== src/libjasper/jp2/jp2_cod.h:201:201:JP2_CDEF_GRAY_Y:0 */ \n- jpc_decode: jas_image_t *jpc_decode(jas_stream_t *in, const char *optstr) /* <=== jpc_decode */ \n{\n\tjpc_dec_importopts_t *opts;\n\tjpc_dec_t *dec;\n\tjas_image_t *image;\n\n\tdec = 0;\n\topts = 0;\n\n\tJAS_DBGLOG(100, (\"jpc_decode(%p, \\\"%s\\\")\\n\", in, optstr));\n\n\tif (!(opts = jpc_dec_opts_create(optstr))) {\n\t\tgoto error;\n\t}\n\n\tjpc_initluts();\n\n\tif (!(dec = jpc_dec_create(opts, in))) {\n\t\tgoto error;\n\t}\n\tjpc_dec_opts_destroy(opts);\n\topts = 0;\n\n\t/* Do most of the work. */\n\tif (jpc_dec_decode(dec)) {\n\t\tgoto error;\n\t}\n\n\tif (jas_image_numcmpts(dec->image) >= 3) {\n\t\tjas_image_setclrspc(dec->image, JAS_CLRSPC_SRGB);\n\t\tjas_image_setcmpttype(dec->image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));\n\t\tjas_image_setcmpttype(dec->image, 1,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));\n\t\tjas_image_setcmpttype(dec->image, 2,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));\n\t} else {\n\t\tjas_image_setclrspc(dec->image, JAS_CLRSPC_SGRAY);\n\t\tjas_image_setcmpttype(dec->image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));\n\t}\n\n\t/* Save the return value. */\n\timage = dec->image;\n\n\t/* Stop the image from being discarded. */\n\tdec->image = 0;\n\n\t/* Destroy decoder. */\n\tjpc_dec_destroy(dec);\n\n\treturn image;\n\nerror:\n\tif (opts) {\n\t\tjpc_dec_opts_destroy(opts);\n\t}\n\tif (dec) {\n\t\tjpc_dec_destroy(dec);\n\t}\n\treturn 0;\n}\n- ICC_CS_YCBCR: #define ICC_CS_YCBCR\t0x59436272 /* <=== src/libjasper/jp2/jp2_cod.h:299:299:ICC_CS_YCBCR:0 */ \n- ICC_CS_RGB: #define ICC_CS_RGB\t0x52474220 /* <=== src/libjasper/jp2/jp2_cod.h:298:298:ICC_CS_RGB:0 */ \n- JP2_CDEF_RGB_B: #define JP2_CDEF_RGB_B\t3 /* <=== src/libjasper/jp2/jp2_cod.h:195:195:JP2_CDEF_RGB_B:0 */ \n- JP2_CDEF_YCBCR_CB: #define JP2_CDEF_YCBCR_CB\t2 /* <=== src/libjasper/jp2/jp2_cod.h:198:198:JP2_CDEF_YCBCR_CB:0 */ \n- JP2_CDEF_RGB_G: #define JP2_CDEF_RGB_G\t2 /* <=== src/libjasper/jp2/jp2_cod.h:194:194:JP2_CDEF_RGB_G:0 */ \n- jp2_boxinfolookup: static const jp2_boxinfo_t *jp2_boxinfolookup(int type) /* <=== jp2_boxinfolookup */ \n{\n\tconst jp2_boxinfo_t *boxinfo;\n\tfor (boxinfo = jp2_boxinfos; boxinfo->name; ++boxinfo) {\n\t\tif (boxinfo->type == type) {\n\t\t\treturn boxinfo;\n\t\t}\n\t}\n\treturn &jp2_boxinfo_unk;\n}\n- jp2_box_destroy: void jp2_box_destroy(jp2_box_t *box) /* <=== jp2_box_destroy */ \n{\n\tif (box->ops->destroy) {\n\t\t(*box->ops->destroy)(box);\n\t}\n\tjas_free(box);\n}\n- jas_image_cmpttype: #define jas_image_cmpttype(image, cmptno) \\ /* <=== src/libjasper/include/jasper/jas_image.h:361:362:jas_image_cmpttype:2 */ \n\t((image)->cmpts_[(cmptno)]->type_)\n- jp2_box_create0: static jp2_box_t *jp2_box_create0(void) /* <=== jp2_box_create0 */ \n{\n\tjp2_box_t *box;\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\treturn 0;\n\t}\n\tmemset(box, 0, sizeof(jp2_box_t));\n\tbox->type = 0;\n\tbox->len = 0;\n\t// Mark the box data as never having been constructed\n\t// so that we will not errantly attempt to destroy it later.\n\tbox->ops = &jp2_boxinfo_unk.ops;\n\treturn box;\n}\n- JP2_CDEF_RGB_R: #define JP2_CDEF_RGB_R\t1 /* <=== src/libjasper/jp2/jp2_cod.h:193:193:JP2_CDEF_RGB_R:0 */ \n- jpc_dec_decode: static int jpc_dec_decode(jpc_dec_t *dec) /* <=== jpc_dec_decode */ \n{\n\tjpc_ms_t *ms;\n\tconst jpc_dec_mstabent_t *mstabent;\n\tint ret;\n\tjpc_cstate_t *cstate;\n\n\tif (!(cstate = jpc_cstate_create())) {\n\t\treturn -1;\n\t}\n\tdec->cstate = cstate;\n\n\t/* Initially, we should expect to encounter a SOC marker segment. */\n\tdec->state = JPC_MHSOC;\n\n\tfor (;;) {\n\n\t\t/* Get the next marker segment in the code stream. */\n\t\tif (!(ms = jpc_getms(dec->in, cstate))) {\n\t\t\tjas_eprintf(\"cannot get marker segment\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tmstabent = jpc_dec_mstab_lookup(ms->id);\n\t\tassert(mstabent);\n\n\t\t/* Ensure that this type of marker segment is permitted\n\t\t  at this point in the code stream. */\n\t\tif (!(dec->state & mstabent->validstates)) {\n\t\t\tjas_eprintf(\"unexpected marker segment type\\n\");\n\t\t\tjpc_ms_destroy(ms);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Process the marker segment. */\n\t\tif (mstabent->action) {\n\t\t\tret = (*mstabent->action)(dec, ms);\n\t\t} else {\n\t\t\t/* No explicit action is required. */\n\t\t\tret = 0;\n\t\t}\n\n\t\t/* Destroy the marker segment. */\n\t\tjpc_ms_destroy(ms);\n\n\t\tif (ret < 0) {\n\t\t\treturn -1;\n\t\t} else if (ret > 0) {\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n- jpc_dec_destroy: static void jpc_dec_destroy(jpc_dec_t *dec) /* <=== jpc_dec_destroy */ \n{\n\tif (dec->cstate) {\n\t\tjpc_cstate_destroy(dec->cstate);\n\t}\n\tif (dec->pkthdrstreams) {\n\t\tjpc_streamlist_destroy(dec->pkthdrstreams);\n\t}\n\tif (dec->ppmstab) {\n\t\tjpc_ppxstab_destroy(dec->ppmstab);\n\t}\n\tif (dec->image) {\n\t\tjas_image_destroy(dec->image);\n\t}\n\n\tif (dec->cp) {\n\t\tjpc_dec_cp_destroy(dec->cp);\n\t}\n\n\tif (dec->cmpts) {\n\t\tjas_free(dec->cmpts);\n\t}\n\n\tif (dec->tiles) {\n\t\tint tileno;\n\t\tjpc_dec_tile_t *tile;\n\n\t\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n\t\t  ++tile) {\n\t\t\tif (tile->state != JPC_TILE_DONE) {\n\t\t\t\tjpc_dec_tilefini(dec, tile);\n\t\t\t}\n\t\t}\n\n\t\tjas_free(dec->tiles);\n\t}\n\n\tjas_free(dec);\n}\n- JP2_CDEF_YCBCR_Y: #define JP2_CDEF_YCBCR_Y\t1 /* <=== src/libjasper/jp2/jp2_cod.h:197:197:JP2_CDEF_YCBCR_Y:0 */ \n- jas_free: void jas_free(void *ptr) /* <=== jas_free */ \n{\n\tJAS_DBGLOG(100, (\"jas_free(%p)\\n\", ptr));\n\tfree(ptr);\n}\n- jas_stream_close: JAS_DLLEXPORT int jas_stream_close(jas_stream_t *stream); /* <=== jas_stream_close */ \n- jas_image_cmptdtype: #define\tjas_image_cmptdtype(image, cmptno) \\ /* <=== src/libjasper/include/jasper/jas_image.h:452:453:jas_image_cmptdtype:2 */ \n\t(JAS_IMAGE_CDT_SETSGND((image)->cmpts_[cmptno]->sgnd_) | JAS_IMAGE_CDT_SETPREC((image)->cmpts_[cmptno]->prec_))\n- JP2_BOX_SUPER: #define\tJP2_BOX_SUPER\t0x01 /* <=== src/libjasper/jp2/jp2_cod.h:114:114:JP2_BOX_SUPER:0 */ \n- jas_image_cmpt_destroy: static void jas_image_cmpt_destroy(jas_image_cmpt_t *cmpt) /* <=== jas_image_cmpt_destroy */ \n{\n\tif (cmpt->stream_) {\n\t\tjas_stream_close(cmpt->stream_);\n\t}\n\tjas_free(cmpt);\n}\n- JAS_IMAGE_CT_UNKNOWN: #define\tJAS_IMAGE_CT_UNKNOWN\t0x10000 /* <=== src/libjasper/include/jasper/jas_image.h:108:108:JAS_IMAGE_CT_UNKNOWN:0 */ \n- fromiccpcs: static int fromiccpcs(int cs) /* <=== fromiccpcs */ \n{\n\tswitch (cs) {\n\tcase ICC_CS_RGB:\n\t\treturn JAS_CLRSPC_GENRGB;\n\t\tbreak;\n\tcase ICC_CS_YCBCR:\n\t\treturn JAS_CLRSPC_GENYCBCR;\n\t\tbreak;\n\tcase ICC_CS_GRAY:\n\t\treturn JAS_CLRSPC_GENGRAY;\n\t\tbreak;\n\t}\n\treturn JAS_CLRSPC_UNKNOWN;\n}\n- jas_image_setbbox: static void jas_image_setbbox(jas_image_t *image) /* <=== jas_image_setbbox */ \n{\n\tjas_image_cmpt_t *cmpt;\n\tint cmptno;\n\tint_fast32_t x;\n\tint_fast32_t y;\n\n\tif (image->numcmpts_ > 0) {\n\t\t/* Determine the bounding box for all of the components on the\n\t\t  reference grid (i.e., the image area) */\n\t\tcmpt = image->cmpts_[0];\n\t\timage->tlx_ = cmpt->tlx_;\n\t\timage->tly_ = cmpt->tly_;\n\t\timage->brx_ = cmpt->tlx_ + cmpt->hstep_ * (cmpt->width_ - 1) + 1;\n\t\timage->bry_ = cmpt->tly_ + cmpt->vstep_ * (cmpt->height_ - 1) + 1;\n\t\tfor (cmptno = 1; cmptno < image->numcmpts_; ++cmptno) {\n\t\t\tcmpt = image->cmpts_[cmptno];\n\t\t\tif (image->tlx_ > cmpt->tlx_) {\n\t\t\t\timage->tlx_ = cmpt->tlx_;\n\t\t\t}\n\t\t\tif (image->tly_ > cmpt->tly_) {\n\t\t\t\timage->tly_ = cmpt->tly_;\n\t\t\t}\n\t\t\tx = cmpt->tlx_ + cmpt->hstep_ * (cmpt->width_ - 1) + 1;\n\t\t\tif (image->brx_ < x) {\n\t\t\t\timage->brx_ = x;\n\t\t\t}\n\t\t\ty = cmpt->tly_ + cmpt->vstep_ * (cmpt->height_ - 1) + 1;\n\t\t\tif (image->bry_ < y) {\n\t\t\t\timage->bry_ = y;\n\t\t\t}\n\t\t}\n\t} else {\n\t\timage->tlx_ = 0;\n\t\timage->tly_ = 0;\n\t\timage->brx_ = 0;\n\t\timage->bry_ = 0;\n\t}\n}\n- JP2_JP_MAGIC: #define\tJP2_JP_MAGIC\t0x0d0a870a /* <=== src/libjasper/jp2/jp2_cod.h:119:119:JP2_JP_MAGIC:0 */ \n- jas_image_numcmpts: #define\tjas_image_numcmpts(image) \\ /* <=== src/libjasper/include/jasper/jas_image.h:350:351:jas_image_numcmpts:1 */ \n\t((image)->numcmpts_)\n- jas_iccprof_createfrombuf: jas_iccprof_t *jas_iccprof_createfrombuf(const jas_uchar *buf, int len) /* <=== jas_iccprof_createfrombuf */ \n{\n\tjas_stream_t *in;\n\tjas_iccprof_t *prof;\n\tif (!(in = jas_stream_memopen(JAS_CAST(char *, buf), len)))\n\t\tgoto error;\n\tif (!(prof = jas_iccprof_load(in)))\n\t\tgoto error;\n\tjas_stream_close(in);\n\treturn prof;\nerror:\n\tif (in)\n\t\tjas_stream_close(in);\n\treturn 0;\n}\n- jpc_dec_create: static jpc_dec_t *jpc_dec_create(jpc_dec_importopts_t *impopts, jas_stream_t *in) /* <=== jpc_dec_create */ \n{\n\tjpc_dec_t *dec;\n\n\tif (!(dec = jas_malloc(sizeof(jpc_dec_t)))) {\n\t\treturn 0;\n\t}\n\n\tdec->image = 0;\n\tdec->xstart = 0;\n\tdec->ystart = 0;\n\tdec->xend = 0;\n\tdec->yend = 0;\n\tdec->tilewidth = 0;\n\tdec->tileheight = 0;\n\tdec->tilexoff = 0;\n\tdec->tileyoff = 0;\n\tdec->numhtiles = 0;\n\tdec->numvtiles = 0;\n\tdec->numtiles = 0;\n\tdec->tiles = 0;\n\tdec->curtile = 0;\n\tdec->numcomps = 0;\n\tdec->in = in;\n\tdec->cp = 0;\n\tdec->maxlyrs = impopts->maxlyrs;\n\tdec->maxpkts = impopts->maxpkts;\ndec->numpkts = 0;\n\tdec->ppmseqno = 0;\n\tdec->state = 0;\n\tdec->cmpts = 0;\n\tdec->pkthdrstreams = 0;\n\tdec->ppmstab = 0;\n\tdec->curtileendoff = 0;\n\tdec->max_samples = impopts->max_samples;\n\n\treturn dec;\n}\n- jp2_dec_destroy: static void jp2_dec_destroy(jp2_dec_t *dec) /* <=== jp2_dec_destroy */ \n{\n\tif (dec->ihdr) {\n\t\tjp2_box_destroy(dec->ihdr);\n\t}\n\tif (dec->bpcc) {\n\t\tjp2_box_destroy(dec->bpcc);\n\t}\n\tif (dec->cdef) {\n\t\tjp2_box_destroy(dec->cdef);\n\t}\n\tif (dec->pclr) {\n\t\tjp2_box_destroy(dec->pclr);\n\t}\n\tif (dec->image) {\n\t\tjas_image_destroy(dec->image);\n\t}\n\tif (dec->cmap) {\n\t\tjp2_box_destroy(dec->cmap);\n\t}\n\tif (dec->colr) {\n\t\tjp2_box_destroy(dec->colr);\n\t}\n\tif (dec->chantocmptlut) {\n\t\tjas_free(dec->chantocmptlut);\n\t}\n\tjas_free(dec);\n}\n- JP2_COLR_SGRAY: #define\tJP2_COLR_SGRAY\t17 /* <=== src/libjasper/jp2/jp2_cod.h:169:169:JP2_COLR_SGRAY:0 */ \n- JP2_CMAP_PALETTE: #define\tJP2_CMAP_PALETTE\t1 /* <=== src/libjasper/jp2/jp2_cod.h:234:234:JP2_CMAP_PALETTE:0 */ \n- jas_getdbglevel: int jas_getdbglevel() /* <=== jas_getdbglevel */ \n{\n\treturn jas_dbglevel;\n}\n- jpc_dec_opts_destroy: static void jpc_dec_opts_destroy(jpc_dec_importopts_t *opts) /* <=== jpc_dec_opts_destroy */ \n{\n\tjas_free(opts);\n}\n- JP2_BOX_NODATA: #define\tJP2_BOX_NODATA\t0x02 /* <=== src/libjasper/jp2/jp2_cod.h:115:115:JP2_BOX_NODATA:0 */ \n- JP2_COLR_SRGB: #define\tJP2_COLR_SRGB\t16 /* <=== src/libjasper/jp2/jp2_cod.h:168:168:JP2_COLR_SRGB:0 */ \n- JAS_IMAGE_CT_COLOR: #define\tJAS_IMAGE_CT_COLOR(n)\t((n) & 0x7fff) /* <=== src/libjasper/include/jasper/jas_image.h:109:109:JAS_IMAGE_CT_COLOR:1 */ \n- jas_eprintf: int jas_eprintf(const char *fmt, ...) /* <=== jas_eprintf */ \n{\n\tint ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}\n- jas_safe_size_mul: inline static bool jas_safe_size_mul(size_t x, size_t y, size_t *result) /* <=== jas_safe_size_mul */ \n{\n\t/* Check if overflow would occur */\n\tif (x && y > SIZE_MAX / x) {\n\t\t/* Overflow would occur. */\n\t\treturn false;\n\t}\n\tif (result) {\n\t\t*result = x * y;\n\t}\n\treturn true;\n}\n- jas_malloc: void *jas_malloc(size_t size) /* <=== jas_malloc */ \n{\n\tvoid *result;\n\tJAS_DBGLOG(101, (\"jas_malloc(%zu)\\n\", size));\n\tresult = malloc(size);\n\tJAS_DBGLOG(100, (\"jas_malloc(%zu) -> %p\\n\", size, result));\n\treturn result;\n}\n- jas_stream_memopen: JAS_DLLEXPORT jas_stream_t *jas_stream_memopen(char *buf, int bufsize); /* <=== jas_stream_memopen */ \n- jas_image_delcmpt: void jas_image_delcmpt(jas_image_t *image, int cmptno) /* <=== jas_image_delcmpt */ \n{\n\tif (cmptno >= image->numcmpts_) {\n\t\treturn;\n\t}\n\tjas_image_cmpt_destroy(image->cmpts_[cmptno]);\n\tif (cmptno < image->numcmpts_) {\n\t\tmemmove(&image->cmpts_[cmptno], &image->cmpts_[cmptno + 1],\n\t\t  (image->numcmpts_ - 1 - cmptno) * sizeof(jas_image_cmpt_t *));\n\t}\n\t--image->numcmpts_;\n\n\tjas_image_setbbox(image);\n}\n- jp2_dec_create: static jp2_dec_t *jp2_dec_create(void) /* <=== jp2_dec_create */ \n{\n\tjp2_dec_t *dec;\n\n\tif (!(dec = jas_malloc(sizeof(jp2_dec_t)))) {\n\t\treturn 0;\n\t}\n\tdec->ihdr = 0;\n\tdec->bpcc = 0;\n\tdec->cdef = 0;\n\tdec->pclr = 0;\n\tdec->image = 0;\n\tdec->chantocmptlut = 0;\n\tdec->cmap = 0;\n\tdec->colr = 0;\n\treturn dec;\n}\n\nType Definitions:\n- jp2_box_t: typedef struct {\n\n\tconst struct jp2_boxops_s *ops;\n\tconst struct jp2_boxinfo_s *info;\n\n\tuint_fast32_t type;\n\n\t/* The length of the box including the (variable-length) header. */\n\tuint_fast32_t len;\n\n\t/* The length of the box data. */\n\tuint_fast32_t datalen;\n\n\tunion {\n\t\tjp2_jp_t jp;\n\t\tjp2_ftyp_t ftyp;\n\t\tjp2_ihdr_t ihdr;\n\t\tjp2_bpcc_t bpcc;\n\t\tjp2_colr_t colr;\n\t\tjp2_pclr_t pclr;\n\t\tjp2_cdef_t cdef;\n\t\tjp2_cmap_t cmap;\n\t} data;\n\n}\n- jp2_cmap_t: typedef struct {\n\tuint_fast16_t numchans;\n\tjp2_cmapent_t *ents;\n}\n- jp2_cmapent_t: typedef struct {\n\tuint_fast16_t cmptno;\n\tuint_fast8_t map;\n\tuint_fast8_t pcol;\n}\n- jas_image_t: typedef struct {\n\n\tjas_image_coord_t tlx_;\n\t/* The x-coordinate of the top-left corner of the image bounding box. */\n\n\tjas_image_coord_t tly_;\n\t/* The y-coordinate of the top-left corner of the image bounding box. */\n\n\tjas_image_coord_t brx_;\n\t/* The x-coordinate of the bottom-right corner of the image bounding\n\t  box (plus one). */\n\n\tjas_image_coord_t bry_;\n\t/* The y-coordinate of the bottom-right corner of the image bounding\n\t  box (plus one). */\n\n\tint numcmpts_;\n\t/* The number of components. */\n\n\tint maxcmpts_;\n\t/* The maximum number of components that this image can have (i.e., the\n\t  allocated size of the components array). */\n\n\tjas_image_cmpt_t **cmpts_;\n\t/* Per-component information. */\n\n\tjas_clrspc_t clrspc_;\n\n\tjas_cmprof_t *cmprof_;\n\n//\tbool inmem_;\n\n}\n- jas_stream_t: typedef struct {\n\n\t/* The mode in which the stream was opened. */\n\tint openmode_;\n\n\t/* The buffering mode. */\n\tint bufmode_;\n\n\t/* The stream status. */\n\tint flags_;\n\n\t/* The start of the buffer area to use for reading/writing. */\n\tjas_uchar *bufbase_;\n\n\t/* The start of the buffer area excluding the extra initial space for\n\t  character putback. */\n\tjas_uchar *bufstart_;\n\n\t/* The buffer size. */\n\tint bufsize_;\n\n\t/* The current position in the buffer. */\n\tjas_uchar *ptr_;\n\n\t/* The number of characters that must be read/written before\n\tthe buffer needs to be filled/flushed. */\n\tint cnt_;\n\n\t/* A trivial buffer to be used for unbuffered operation. */\n\tjas_uchar tinybuf_[JAS_STREAM_MAXPUTBACK + 1];\n\n\t/* The operations for the underlying stream file object. */\n\tconst jas_stream_ops_t *ops_;\n\n\t/* The underlying stream file object. */\n\tjas_stream_obj_t *obj_;\n\n\t/* The number of characters read/written. */\n\tlong rwcnt_;\n\n\t/* The maximum number of characters that may be read/written. */\n\tlong rwlimit_;\n\n}\n- jp2_dec_t: typedef struct {\n\n\tjp2_box_t *pclr;\n\tjp2_box_t *cdef;\n\tjp2_box_t *ihdr;\n\tjp2_box_t *bpcc;\n\tjp2_box_t *cmap;\n\tjp2_box_t *colr;\n\tjas_image_t *image;\n\tuint_fast16_t numchans;\n\tuint_fast16_t *chantocmptlut;\n\n}\n- jp2_pclr_t: typedef struct {\n\tuint_fast16_t numlutents;\n\tuint_fast8_t numchans;\n\tint_fast32_t *lutdata;\n\tuint_fast8_t *bpc;\n}\n\nImports:\n- #include \"jasper/jas_image.h\"\n- #include \"jasper/jas_debug.h\"\n- #include \"jasper/jas_stream.h\"\n- #include \"jp2_cod.h\"\n- #include \"jp2_dec.h\"\n- #include \"jasper/jas_malloc.h\"\n- #include \"jasper/jas_math.h\"\n- #include \"jasper/jas_version.h\"\n- #include \"jasper/jas_types.h\"",
    "commit_msg": "jp2_dec: fix `numchans` mixup\n\nWhen iterating over `dec->cdef->data.cdef.ents`, we need to use its\n`numchans` variable, not the one in `jp2_dec_t`.\n\nFixes CVE-2018-19543\nFixes CVE-2017-9782\n\nCloses https://github.com/jasper-maint/jasper/issues/13\nCloses https://github.com/jasper-maint/jasper/issues/18\nCloses https://github.com/mdadams/jasper/issues/140\nCloses https://github.com/mdadams/jasper/issues/182",
    "cve_desc": "JasPer 2.0.12 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted image, related to the jp2_decode function in libjasper/jp2/jp2_dec.c.",
    "year": 2020,
    "filename": "jp2_dec.c",
    "commit_url": "\"https://github.com/mdadams/jasper/commit/839b1bcf0450ff036c28e8db40a7abf886e02891\""
  },
  {
    "repository": "transmission/transmission",
    "cve_id": "CVE-2018-10756",
    "cwe_list": [
      "CWE-416"
    ],
    "commit_hash": "2123adf8e5e1c2b48791f9d22fc8c747e974180e",
    "short_hash": "2123adf8",
    "vulnerableMethods_before": [
      {
        "filename": "libtransmission/variant.c",
        "method_name": "nodeConstruct",
        "raw_code": "static void nodeConstruct(struct SaveNode* node, tr_variant const* v, bool sort_dicts) /* <=== nodeConstruct */ \n{\n    node->isVisited = false;\n    node->childIndex = 0;\n\n    if (sort_dicts && tr_variantIsDict(v))\n    {\n        /* make node->sorted a sorted version of this dictionary */\n\n        size_t const n = v->val.l.count;\n        struct KeyIndex* tmp = tr_new(struct KeyIndex, n);\n\n        for (size_t i = 0; i < n; i++)\n        {\n            tmp[i].val = v->val.l.vals + i;\n            tmp[i].keystr = tr_quark_get_string(tmp[i].val->key, NULL);\n        }\n\n        qsort(tmp, n, sizeof(struct KeyIndex), compareKeyIndex);\n\n        tr_variantInitDict(&node->sorted, n);\n\n        for (size_t i = 0; i < n; ++i)\n        {\n            node->sorted.val.l.vals[i] = *tmp[i].val;\n        }\n\n        node->sorted.val.l.count = n;\n\n        tr_free(tmp);\n\n        node->v = &node->sorted;\n    }\n    else\n    {\n        node->v = v;\n    }\n}",
        "start_line": 766
      },
      {
        "filename": "libtransmission/variant.c",
        "method_name": "nodeDestruct",
        "raw_code": "static void nodeDestruct(struct SaveNode* node) /* <=== nodeDestruct */ \n{\n    if (node->v == &node->sorted)\n    {\n        tr_free(node->sorted.val.l.vals);\n    }\n}",
        "start_line": 805
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "libtransmission/variant.c",
        "method_name": "nodeConstruct",
        "raw_code": "static void nodeConstruct(struct SaveNode* node, tr_variant const* v, bool sort_dicts) /* <=== nodeConstruct */ \n{\n    node->isVisited = false;\n    node->childIndex = 0;\n\n    if (sort_dicts && tr_variantIsDict(v))\n    {\n        /* make node->sorted a sorted version of this dictionary */\n\n        size_t const n = v->val.l.count;\n        struct KeyIndex* tmp = tr_new(struct KeyIndex, n);\n\n        for (size_t i = 0; i < n; i++)\n        {\n            tmp[i].val = v->val.l.vals + i;\n            tmp[i].keystr = tr_quark_get_string(tmp[i].val->key, NULL);\n        }\n\n        qsort(tmp, n, sizeof(struct KeyIndex), compareKeyIndex);\n\n        node->sorted = tr_new(tr_variant, 1);\n        tr_variantInitDict(node->sorted, n);\n\n        for (size_t i = 0; i < n; ++i)\n        {\n            node->sorted->val.l.vals[i] = *tmp[i].val;\n        }\n\n        node->sorted->val.l.count = n;\n\n        tr_free(tmp);\n\n        v = node->sorted;\n    }\n    else\n    {\n        node->sorted = NULL;\n    }\n\n    node->v = v;\n}",
        "start_line": 766
      },
      {
        "filename": "libtransmission/variant.c",
        "method_name": "nodeDestruct",
        "raw_code": "static void nodeDestruct(struct SaveNode* node) /* <=== nodeDestruct */ \n{\n    TR_ASSERT(node != NULL);\n\n    if (node->sorted != NULL)\n    {\n        tr_free(node->sorted->val.l.vals);\n        tr_free(node->sorted);\n    }\n}",
        "start_line": 808
      }
    ],
    "code_context": "Called Methods:\n- tr_new: #define tr_new(struct_type, n_structs) \\ /* <=== libtransmission/utils.h:173:174:tr_new:2 */ \n    ((struct_type*)tr_malloc(sizeof(struct_type) * (size_t)(n_structs)))\n- tr_variantInit: void tr_variantInit(tr_variant* v, char type) /* <=== tr_variantInit */ \n{\n    v->type = type;\n    memset(&v->val, 0, sizeof(v->val));\n}\n- tr_variantInitDict: void tr_variantInitDict(tr_variant* v, size_t reserve_count) /* <=== tr_variantInitDict */ \n{\n    tr_variantInit(v, TR_VARIANT_TYPE_DICT);\n    tr_variantDictReserve(v, reserve_count);\n}\n- tr_variantDictReserve: void tr_variantDictReserve(tr_variant* dict, size_t reserve_count) /* <=== tr_variantDictReserve */ \n{\n    TR_ASSERT(tr_variantIsDict(dict));\n\n    containerReserve(dict, reserve_count);\n}\n- TR_ASSERT: #define TR_ASSERT(x) ((void)(TR_LIKELY(x) || tr_assert_report(__FILE__, __LINE__, \"%s\", #x))) /* <=== libtransmission/tr-assert.h:19:19:TR_ASSERT:1 */ \n- tr_variantIsDict: static inline bool tr_variantIsDict(tr_variant const* v) /* <=== tr_variantIsDict */ \n{\n    return v != NULL && v->type == TR_VARIANT_TYPE_DICT;\n}\n- tr_malloc: void* tr_malloc(size_t size) /* <=== tr_malloc */ \n{\n    return size != 0 ? malloc(size) : NULL;\n}\n- tr_free: void tr_free(void* p) /* <=== tr_free */ \n{\n    if (p != NULL)\n    {\n        free(p);\n    }\n}\n- tr_assert_report: bool tr_assert_report(char const* file, int line, char const* message_fmt, ...) /* <=== tr_assert_report */ \n{\n    va_list args;\n    va_start(args, message_fmt);\n\n    fprintf(stderr, \"assertion failed: \");\n    vfprintf(stderr, message_fmt, args);\n    fprintf(stderr, \" (%s:%d)\\n\", file, line);\n\n    va_end(args);\n\n    abort();\n}\n\nType Definitions:\n- SaveNode: struct SaveNode\n{\n    tr_variant const* v;\n    tr_variant sorted;\n    size_t childIndex;\n    bool isVisited;\n}\n- tr_variant: typedef struct tr_variant\n{\n    char type;\n\n    tr_quark key;\n\n    union\n    {\n        bool b;\n\n        double d;\n\n        int64_t i;\n\n        struct tr_variant_string s;\n\n        struct\n        {\n            size_t alloc;\n            size_t count;\n            struct tr_variant* vals;\n        } l;\n    }\n    val;\n}\ntr_variant;\n- KeyIndex: struct KeyIndex\n{\n    char const* keystr;\n    tr_variant* val;\n}\n- SaveNode: struct SaveNode\n{\n    tr_variant const* v;\n    tr_variant* sorted;\n    size_t childIndex;\n    bool isVisited;\n}\n- tr_variant: struct tr_variant\n\nImports:\n- #include \"file.h\"\n- #include \"ConvertUTF.h\"\n- #include <event2/buffer.h>\n- #include \"variant.h\"\n- #include <string.h>\n- #include <errno.h>\n- #include \"tr-assert.h\"\n- #include \"variant-common.h\"\n- #include <stdlib.h>\n- #include \"transmission.h\"\n- #include <xlocale.h>\n- #include \"log.h\"\n- #include \"utils.h\"\n- #include <locale.h>\n- #include \"error.h\"\n- #include <share.h>",
    "commit_msg": "CVE-2018-10756: Fix heap-use-after-free in tr_variantWalk\n\nIn libtransmission/variant.c, function tr_variantWalk, when the variant\nstack is reallocated, a pointer to the previously allocated memory\nregion is kept. This address is later accessed (heap use-after-free)\nwhile walking back down the stack, causing the application to crash.\nThe application can be any application which uses libtransmission, such\nas transmission-daemon, transmission-gtk, transmission-show, etc.\n\nReported-by: Tom Richards <tom@tomrichards.net>",
    "cve_desc": "[{'lang': 'en', 'value': 'Use-after-free in libtransmission/variant.c in Transmission before 3.00 allows remote attackers to cause a denial of service (crash) or possibly execute arbitrary code via a crafted torrent file.'}]",
    "year": 2020,
    "filename": "variant.c",
    "commit_url": "\"https://github.com/transmission/transmission/commit/2123adf8e5e1c2b48791f9d22fc8c747e974180e\""
  },
  {
    "repository": "logological/gpp",
    "cve_id": "CVE-2018-17076",
    "cwe_list": [
      "CWE-119"
    ],
    "commit_hash": "329aa63a70d32d1e2ae529130a792e0c6ae4ce79",
    "short_hash": "329aa63a",
    "vulnerableMethods_before": [
      {
        "filename": "src/gpp.c",
        "method_name": "ParseText",
        "raw_code": "void ParseText(void) { /* <=== ParseText */ \n    int l, cs, ce;\n    char c, *s;\n    struct COMMENT *p;\n\n    /* look for comments first */\n    if (!C->in_comment) {\n        cs = 1;\n        for (p = S->comments; p != NULL ; p = p->next)\n            if (!(p->flags[C->ambience] & FLAG_IGNORE))\n                if (matchStartSequence(p->start, &cs)) {\n                    l = ce = findCommentEnd(p->end, p->quote, p->warn, cs,\n                            p->flags[C->ambience]);\n                    matchEndSequence(p->end, &l);\n                    if (p->flags[C->ambience] & OUTPUT_DELIM)\n                        sendout(C->buf + 1, cs - 1, 0);\n                    if (!(p->flags[C->ambience] & OUTPUT_TEXT))\n                        replace_definition_with_blank_lines(C->buf + 1,\n                                C->buf + ce - 1, 0);\n                    if (p->flags[C->ambience] & PARSE_MACROS) {\n                        C->in_comment = 1;\n                        s = ProcessText(C->buf + cs, ce - cs, C->ambience);\n                        if (p->flags[C->ambience] & OUTPUT_TEXT)\n                            sendout(s, strlen(s), 0);\n                        C->in_comment = 0;\n                        free(s);\n                    } else if (p->flags[C->ambience] & OUTPUT_TEXT)\n                        sendout(C->buf + cs, ce - cs, 0);\n                    if (p->flags[C->ambience] & OUTPUT_DELIM)\n                        sendout(C->buf + ce, l - ce, 0);\n                    shiftIn(l);\n                    return;\n                }\n    }\n\n    if (ParsePossibleMeta() >= 0)\n        return;\n    if (ParsePossibleUser() >= 0)\n        return;\n\n    l = 1;\n    /* If matching numbered macro argument and inside a macro */\n    if (matchSequence(S->User.mArgRef, &l) && C->may_have_args) {\n        /* Process macro arguments referenced as #1,#2,... */\n        c = getChar(l);\n        if ((c >= '1') && (c <= '9')) {\n            c = c - '1';\n            if (c < C->argc)\n                sendout(C->argv[(int) c], strlen(C->argv[(int) c]), 0);\n            shiftIn(l + 1);\n            return;\n        }\n    }\n\n    l = identifierEnd(1);\n    if (l == 1)\n        l = 2;\n    sendout(C->buf + 1, l - 1, 1);\n    shiftIn(l);\n}",
        "start_line": 2987
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "src/gpp.c",
        "method_name": "ParseText",
        "raw_code": "void ParseText(void) { /* <=== ParseText */ \n    int l, cs, ce;\n    char c, *s;\n    struct COMMENT *p;\n\n    if (++parselevel == STACKDEPTH)\n      bug(\"Stack depth exceeded during parse\");\n\n    /* look for comments first */\n    if (!C->in_comment) {\n        cs = 1;\n        for (p = S->comments; p != NULL ; p = p->next)\n            if (!(p->flags[C->ambience] & FLAG_IGNORE))\n                if (matchStartSequence(p->start, &cs)) {\n                    l = ce = findCommentEnd(p->end, p->quote, p->warn, cs,\n                            p->flags[C->ambience]);\n                    matchEndSequence(p->end, &l);\n                    if (p->flags[C->ambience] & OUTPUT_DELIM)\n                        sendout(C->buf + 1, cs - 1, 0);\n                    if (!(p->flags[C->ambience] & OUTPUT_TEXT))\n                        replace_definition_with_blank_lines(C->buf + 1,\n                                C->buf + ce - 1, 0);\n                    if (p->flags[C->ambience] & PARSE_MACROS) {\n                        C->in_comment = 1;\n                        s = ProcessText(C->buf + cs, ce - cs, C->ambience);\n                        if (p->flags[C->ambience] & OUTPUT_TEXT)\n                            sendout(s, strlen(s), 0);\n                        C->in_comment = 0;\n                        free(s);\n                    } else if (p->flags[C->ambience] & OUTPUT_TEXT)\n                        sendout(C->buf + cs, ce - cs, 0);\n                    if (p->flags[C->ambience] & OUTPUT_DELIM)\n                        sendout(C->buf + ce, l - ce, 0);\n                    shiftIn(l);\n\t\t    parselevel--;\n                    return;\n                }\n    }\n\n    if (ParsePossibleMeta() >= 0) {\n      parselevel--;\n      return;\n    }\n    if (ParsePossibleUser() >= 0) {\n      parselevel--;\n      return;\n    }\n\n    l = 1;\n    /* If matching numbered macro argument and inside a macro */\n    if (matchSequence(S->User.mArgRef, &l) && C->may_have_args) {\n        /* Process macro arguments referenced as #1,#2,... */\n        c = getChar(l);\n        if ((c >= '1') && (c <= '9')) {\n            c = c - '1';\n            if (c < C->argc)\n                sendout(C->argv[(int) c], strlen(C->argv[(int) c]), 0);\n            shiftIn(l + 1);\n\t    parselevel--;\n            return;\n        }\n    }\n\n    l = identifierEnd(1);\n    if (l == 1)\n        l = 2;\n    sendout(C->buf + 1, l - 1, 1);\n    shiftIn(l);\n    parselevel--;\n}",
        "start_line": 2989
      }
    ],
    "code_context": "Called Methods:\n- FLAG_META: #define FLAG_META 0 /* <=== src/gpp.c:118:118:FLAG_META:0 */ \n- lookupArgRefs: void lookupArgRefs(int n) { /* <=== lookupArgRefs */ \n    int i, l;\n    char *p;\n\n    if (macros[n].argnames != NULL )\n        return; /* don't mess with those */\n    macros[n].nnamedargs = -1;\n    l = strlen(S->User.mArgRef);\n    for (i = 0, p = macros[n].macrotext; i < macros[n].macrolen; i++, p++) {\n        if ((*p != 0) && (*p == S->User.quotechar)) {\n            i++;\n            p++;\n        } else if (!strncmp(p, S->User.mArgRef, l))\n            if ((p[l] >= '1') && (p[l] <= '9')) {\n                macros[n].nnamedargs = 0;\n                return;\n            }\n    }\n}\n- replace_directive_with_blank_line: void replace_directive_with_blank_line(FILE *f) { /* <=== replace_directive_with_blank_line */ \n    if ((include_directive_marker != NULL )&& (f != NULL)\n    && (!S->preservelf) && (S->Meta.mArgE[0]=='\\n')){\n    fprintf(f,\"\\n\");\n}\n}\n- PopSpecs: void PopSpecs(void) { /* <=== PopSpecs */ \n    struct SPECS *P;\n\n    P = S;\n    S = P->stack_next;\n    FreeComments(P);\n    free(P);\n    if (S == NULL )\n        bug(\"#mode restore without #mode save\");\n}\n- my_strdup: inline char *my_strdup(const char *s) { /* <=== my_strdup */ \n    size_t len = strlen(s) + 1;\n    char *newstr = malloc(len);\n    return newstr ? (char *) memcpy(newstr, s, len) : NULL ;\n}\n- findMetaArgs: int findMetaArgs(int start, int *p1b, int *p1e, int *p2b, int *p2e, int *endm, /* <=== findMetaArgs */ \n        int *argc, int *argb, int *arge) {\n    int pos, k;\n    int hyp_end1, hyp_end2;\n\n    /* look for mEnd or mArgS */\n    pos = start;\n    if (!matchSequence(S->Meta.mArgS, &pos)) {\n        if (!matchEndSequence(S->Meta.mEnd, &pos))\n            return -1;\n        *endm = pos;\n        return 0;\n    }\n    *p1b = pos;\n\n    /* special syntax for #define : 1st arg is a macro call */\n    if ((*argc)\n            && SplicePossibleUser(&pos, p1e, &hyp_end1, &hyp_end2, argb, arge,\n                    argc, 0, NULL, FLAG_META)) {\n        *p1b = pos;\n        if (hyp_end2 >= 0)\n            pos = hyp_end2;\n        else {\n            pos = hyp_end1;\n            *argc = 0;\n        }\n        if (!matchSequence(S->Meta.mArgSep, &pos)) {\n            if (!matchEndSequence(S->Meta.mArgE, &pos))\n                bug(\n                        \"#define/#defeval requires an identifier or a single macro call\");\n            *endm = pos;\n            return 1;\n        }\n    } else {\n        *argc = 0;\n        k = 0;\n        while (1) { /* look for mArgE, mArgSep, or comment-start */\n            pos = iterIdentifierEnd(pos);\n            SkipPossibleComments(&pos, FLAG_META, 0);\n            if (getChar(pos) != 0 && strchr(S->Meta.stackchar, getChar(pos)))\n                k++;\n            if (k) {\n                if (getChar(pos) != 0\n                        && strchr(S->Meta.unstackchar, getChar(pos)))\n                    k--;\n            } else {\n                *p1e = pos;\n                if (matchSequence(S->Meta.mArgSep, &pos))\n                    break;\n                if (matchEndSequence(S->Meta.mArgE, &pos)) {\n                    *endm = pos;\n                    return 1;\n                }\n            }\n            if (getChar(pos) == 0)\n                bug(\"unfinished macro argument\");\n            pos++; /* nothing matched, go forward */\n        }\n    }\n\n    *p2b = pos;\n    k = 0;\n    while (1) { /* look for mArgE or comment-start */\n        pos = iterIdentifierEnd(pos);\n        SkipPossibleComments(&pos, FLAG_META, 0);\n        if (getChar(pos) != 0 && strchr(S->Meta.stackchar, getChar(pos)))\n            k++;\n        if (k) {\n            if (getChar(pos) != 0 && strchr(S->Meta.unstackchar, getChar(pos)))\n                k--;\n        } else {\n            *p2e = pos;\n            if (matchEndSequence(S->Meta.mArgE, &pos))\n                break;\n        }\n        if (getChar(pos) == 0)\n            bug(\"unfinished macro\");\n        pos++; /* nothing matched, go forward */\n    }\n    *endm = pos;\n    return 2;\n}\n- MAX_GPP_DATE_SIZE: #define MAX_GPP_DATE_SIZE 1024 /* <=== src/gpp.c:53:53:MAX_GPP_DATE_SIZE:0 */ \n- add_comment: void add_comment(struct SPECS *S, const char *specif, char *start, char *end, /* <=== add_comment */ \n        char quote, char warn) {\n    struct COMMENT *p;\n\n    if (*start == 0)\n        bug(\"Comment/string start delimiter must be non-empty\");\n    for (p = S->comments; p != NULL ; p = p->next)\n        if (!strcmp(p->start, start)) {\n            if (strcmp(p->end, end)) /* already exists with a different end */\n                bug(\"Conflicting comment/string delimiter specifications\");\n            free(p->start);\n            free(p->end);\n            break;\n        }\n\n    if (p == NULL ) {\n        p = malloc(sizeof *p);\n        p->next = S->comments;\n        S->comments = p;\n    }\n    p->start = start;\n    p->end = end;\n    p->quote = quote;\n    p->warn = warn;\n    if (strlen(specif) != 3)\n        bug(\"Invalid comment/string modifier\");\n    p->flags[FLAG_META] = parse_comment_specif(specif[0]);\n    p->flags[FLAG_USER] = parse_comment_specif(specif[1]);\n    p->flags[FLAG_TEXT] = parse_comment_specif(specif[2]);\n}\n- DoInclude: static void DoInclude(char *file_name) { /* <=== DoInclude */ \n    struct INPUTCONTEXT *N;\n    char *incfile_name = NULL;\n    FILE *f = NULL;\n    int j;\n    int len = strlen(file_name);\n\n    /* if absolute path name is specified */\n    if (file_name[0] == SLASH\n#ifdef WIN_NT\n    || (isalpha(file_name[0]) && file_name[1]==':')\n#endif\n    )\n        f = fopen(file_name, \"r\");\n    else /* search current dir, if this search isn't turned off */\n    if (!NoCurIncFirst) {\n        f = openInCurrentDir(file_name);\n    }\n\n    for (j = 0; (f == NULL )&&(j<nincludedirs);j++){\n    incfile_name =\n    realloc(incfile_name,len+strlen(includedir[j])+2);\n    strcpy(incfile_name,includedir[j]);\n    incfile_name[strlen(includedir[j])]=SLASH;\n    /* extract the orig include filename */\n    strcpy(incfile_name+strlen(includedir[j])+1, file_name);\n    f=fopen(incfile_name,\"r\");\n}\n    if (incfile_name != NULL )\n        free(incfile_name);\n\n    /* If didn't find the file and \".\" is said to be searched last */\n    if (f == NULL && CurDirIncLast) {\n        f = openInCurrentDir(file_name);\n    }\n\n    if (f == NULL )\n        bug(\"Requested include file not found\");\n\n    N = C;\n    C = malloc(sizeof *C);\n    C->in = f;\n    C->argc = 0;\n    C->argv = NULL;\n    C->filename = file_name;\n    C->out = N->out;\n    C->lineno = 1;\n    C->bufsize = 80;\n    C->len = 0;\n    C->buf = C->malloced_buf = malloc(C->bufsize);\n    C->eof = 0;\n    C->namedargs = NULL;\n    C->in_comment = 0;\n    C->ambience = FLAG_TEXT;\n    C->may_have_args = 0;\n    PushSpecs(S);\n    if (autoswitch) {\n        if (!strcmp(file_name + strlen(file_name) - 2, \".h\")\n                || !strcmp(file_name + strlen(file_name) - 2, \".c\"))\n            SetStandardMode(S, \"C\");\n    }\n\n    /* Include marker before the included contents */\n    write_include_marker(N->out->f, 1, C->filename, \"1\");\n    ProcessContext();\n    /* Include marker after the included contents */\n    write_include_marker(N->out->f, N->lineno, N->filename, \"2\");\n    /* Need to leave the blank line in lieu of #include, like cpp does */\n    replace_directive_with_blank_line(N->out->f);\n    free(C);\n    PopSpecs();\n    C = N;\n}\n- findNamedArg: int findNamedArg(const char *b, int l) { /* <=== findNamedArg */ \n    char *s;\n    int i;\n\n    for (i = 0;; i++) {\n        s = C->namedargs[i];\n        if (s == NULL )\n            return -1;\n        if (idequal(b, l, s))\n            return i;\n    }\n}\n- bug: void bug(const char *s) { /* <=== bug */ \n    fprintf(stderr, \"%s:%d: error: %s\\n\", C->filename, C->lineno, s);\n    exit(EXIT_FAILURE);\n}\n- PushSpecs: void PushSpecs(const struct SPECS *X) { /* <=== PushSpecs */ \n    struct SPECS *P;\n\n    P = CloneSpecs(X);\n    P->stack_next = S;\n    S = P;\n}\n- isWhite: int isWhite(char c) { /* <=== isWhite */ \n    if (c == ' ')\n        return 1;\n    if (c == '\\t')\n        return 1;\n    if (c == '\\n')\n        return 1;\n    return 0;\n}\n- isDelim: int isDelim(unsigned char c) { /* <=== isDelim */ \n    if (c >= 128)\n        return 0;\n    if ((c >= '0') && (c <= '9'))\n        return 0;\n    if ((c >= 'A') && (c <= 'Z'))\n        return 0;\n    if ((c >= 'a') && (c <= 'z'))\n        return 0;\n    if (c == '_')\n        return 0;\n    return 1;\n}\n- SplicePossibleUser: int SplicePossibleUser(int *idstart, int *idend, int *sh_end, int *lg_end, /* <=== SplicePossibleUser */ \n        int *argb, int *arge, int *argc, int idcheck, int *id, int cmtmode) {\n    int match, k, pos;\n\n    if (!matchStartSequence(S->User.mStart, idstart))\n        return 0;\n    *idend = identifierEnd(*idstart);\n    if ((*idend) && !getChar(*idend - 1))\n        return 0;\n\n    /* look for args or no args */\n    *sh_end = *idend;\n    if (!matchEndSequence(S->User.mEnd, sh_end))\n        *sh_end = -1;\n    pos = *idend;\n    match = matchSequence(S->User.mArgS, &pos);\n\n    if (idcheck) {\n        *id = findIdent(C->buf + *idstart, *idend - *idstart);\n        if (*id < 0)\n            match = 0;\n    }\n    *lg_end = -1;\n\n    if (match) {\n        *argc = 0;\n        while (1) {\n            if (*argc >= MAXARGS)\n                bug(\"too many macro parameters\");\n            argb[*argc] = pos;\n            k = 0;\n            while (1) { /* look for mArgE, mArgSep, or comment-start */\n                pos = iterIdentifierEnd(pos);\n                SkipPossibleComments(&pos, cmtmode, 0);\n                if (getChar(pos) == 0)\n                    return (*sh_end >= 0); /* EOF */\n                if (strchr(S->User.stackchar, getChar(pos)))\n                    k++;\n                if (k) {\n                    if (strchr(S->User.unstackchar, getChar(pos)))\n                        k--;\n                } else {\n                    arge[*argc] = pos;\n                    if (matchSequence(S->User.mArgSep, &pos)) {\n                        match = 0;\n                        break;\n                    }\n                    if (matchEndSequence(S->User.mArgE, &pos)) {\n                        match = 1;\n                        break;\n                    }\n                }\n                pos++; /* nothing matched, go forward */\n            }\n            (*argc)++;\n            if (match) { /* no more args */\n                *lg_end = pos;\n                break;\n            }\n        }\n    }\n    return ((*lg_end >= 0) || (*sh_end >= 0));\n}\n- whiteout: int whiteout(int *pos1, int *pos2) /* remove whitespace on both sides */ /* <=== whiteout */ \n{\n    while ((*pos1 < *pos2) && isWhite(getChar(*pos1)))\n        (*pos1)++;\n    while ((*pos1 < *pos2) && isWhite(getChar(*pos2 - 1)))\n        (*pos2)--;\n    return (*pos1 < *pos2);\n}\n- STACKDEPTH: #define STACKDEPTH 50 /* <=== src/gpp.c:48:48:STACKDEPTH:0 */ \n- replace_definition_with_blank_lines: void replace_definition_with_blank_lines(const char *start, const char *end, /* <=== replace_definition_with_blank_lines */ \n        int skip) {\n    if ((include_directive_marker != NULL )&& (C->out->f != NULL)){\n    while (start <= end) {\n        if (*start == '\\n') {\n            if (skip) skip--; else fprintf(C->out->f,\"\\n\");\n        }\n        start++;\n    }\n}\n}\n- newmacro: void newmacro(const char *s, int len, int hasspecs) { /* <=== newmacro */ \n    if (nmacros == nalloced) {\n        nalloced = 2 * nalloced + 1;\n        macros = realloc(macros, nalloced * sizeof *macros);\n        if (macros == NULL )\n            bug(\"Out of memory\");\n    }\n    macros[nmacros].username = malloc(len + 1);\n    strncpy(macros[nmacros].username, s, len);\n    macros[nmacros].username[len] = 0;\n    macros[nmacros].argnames = NULL;\n    macros[nmacros].nnamedargs = 0;\n    macros[nmacros].defined_in_comment = 0;\n    if (hasspecs)\n        macros[nmacros].define_specs = CloneSpecs(S);\n    else\n        macros[nmacros].define_specs = NULL;\n}\n- delete_comment: void delete_comment(struct SPECS *S, char *start) { /* <=== delete_comment */ \n    struct COMMENT *p, *q;\n\n    q = NULL;\n    for (p = S->comments; p != NULL ; p = p->next) {\n        if (!strcmp(p->start, start)) {\n            if (q == NULL )\n                S->comments = p->next;\n            else\n                q->next = p->next;\n            free(p->start);\n            free(p->end);\n            free(p);\n            free(start);\n            return;\n        } else\n            q = p;\n    }\n    free(start);\n}\n- ProcessText: char *ProcessText(const char *buf, int l, int ambience) { /* <=== ProcessText */ \n    char *s;\n    struct INPUTCONTEXT *T;\n\n    if (l == 0) {\n        s = malloc(1);\n        s[0] = 0;\n        return s;\n    }\n    s = malloc(l + 2);\n    s[0] = '\\n';\n    memcpy(s + 1, buf, l);\n    s[l + 1] = 0;\n    T = C;\n    C = malloc(sizeof *C);\n    C->out = malloc(sizeof *(C->out));\n    C->in = NULL;\n    C->argc = T->argc;\n    C->argv = T->argv;\n    C->filename = T->filename;\n    C->out->buf = malloc(80);\n    C->out->len = 0;\n    C->out->bufsize = 80;\n    C->out->f = NULL;\n    C->lineno = T->lineno;\n    C->bufsize = l + 2;\n    C->len = l + 1;\n    C->buf = C->malloced_buf = s;\n    C->eof = 0;\n    C->namedargs = T->namedargs;\n    C->in_comment = T->in_comment;\n    C->ambience = ambience;\n    C->may_have_args = T->may_have_args;\n\n    ProcessContext();\n    outchar(0); /* note that outchar works with the half-destroyed context ! */\n    s = C->out->buf;\n    free(C->out);\n    free(C);\n    C = T;\n    return s;\n}\n- MAXARGS: #define MAXARGS 100 /* <=== src/gpp.c:49:49:MAXARGS:0 */ \n- delete_macro: void delete_macro(int i) { /* <=== delete_macro */ \n    int j;\n    nmacros--;\n    free(macros[i].username);\n    free(macros[i].macrotext);\n    if (macros[i].argnames != NULL ) {\n        for (j = 0; j < macros[i].nnamedargs; j++)\n            free(macros[i].argnames[j]);\n        free(macros[i].argnames);\n        macros[i].argnames = NULL;\n    }\n    FreeComments(macros[i].define_specs);\n    free(macros[i].define_specs);\n    memcpy(macros + i, macros + nmacros, sizeof(struct MACRO));\n}\n- IsInCharset: int IsInCharset(CHARSET_SUBSET x, int c) { /* <=== IsInCharset */ \n    return (x[c >> LOG_LONG_BITS] & 1L << (c & ((1 << LOG_LONG_BITS) - 1))) != 0;\n}\n- remove_comments: char *remove_comments(int start, int end, int cmtmode) { /* <=== remove_comments */ \n    char *s, *t;\n\n    t = s = malloc(end - start + 1);\n    while (start < end) {\n        SkipPossibleComments(&start, cmtmode, 1);\n        if (start < end) {\n            *t = getChar(start++);\n            if ((*t == S->User.quotechar) && (start < end)) {\n                *(++t) = getChar(start++);\n            }\n            t++;\n        }\n    }\n    *t = 0;\n    return s;\n}\n- isWhitesep: int isWhitesep(const char *s) { /* <=== isWhitesep */ \n    while (isWhite(*s) || (*s == '\\001') || (*s == '\\002') || (*s == '\\003')\n            || (*s == '\\004'))\n        s++;\n    return (*s == 0);\n}\n- nowhite_strcmp: int nowhite_strcmp(char *s, char *t) { /* <=== nowhite_strcmp */ \n    char *p;\n\n    while (isWhite(*s))\n        s++;\n    while (isWhite(*t))\n        t++;\n    if ((*s == 0) || (*t == 0))\n        return strcmp(s, t);\n    p = s + strlen(s) - 1;\n    while (isWhite(*p))\n        *(p--) = 0;\n    p = t + strlen(t) - 1;\n    while (isWhite(*p))\n        *(p--) = 0;\n    return strcmp(s, t);\n}\n- bug: void bug(const char *s) { /* <=== bug */ \n    fprintf(stderr, \"%s:%d: error: %s\\n\", C->filename, C->lineno, s);\n    exit(EXIT_FAILURE);\n}\n- ProcessModeCommand: void ProcessModeCommand(int p1start, int p1end, int p2start, int p2end) { /* <=== ProcessModeCommand */ \n    struct SPECS *P;\n    char *s, *p, *opt;\n    int nargs, check_isdelim;\n    char *args[10]; /* can't have more than 10 arguments */\n\n    whiteout(&p1start, &p1end);\n    if ((p1start == p1end) || (identifierEnd(p1start) != p1end))\n        bug(\"invalid #mode syntax\");\n    if (p2start < 0)\n        s = my_strdup(\"\");\n    else\n        s = ProcessText(C->buf + p2start, p2end - p2start, FLAG_META);\n\n    /* argument parsing */\n    p = s;\n    opt = NULL;\n    while (isWhite(*p))\n        p++;\n    if ((*p != '\"') && (*p != 0)) {\n        opt = p;\n        while ((*p != 0) && !isWhite(*p))\n            p++;\n        if (*p != 0) {\n            *(p++) = 0;\n            while (isWhite(*p))\n                p++;\n        }\n    }\n    nargs = 0;\n    check_isdelim = !idequal(C->buf + p1start, p1end - p1start, \"charset\");\n    while (*p != 0) {\n        if (nargs == 10)\n            bug(\"too many arguments in #mode command\");\n        if (*(p++) != '\"')\n            bug(\"syntax error in #mode command (missing \\\" or trailing data)\");\n        args[nargs++] = p;\n        p = strNl2(p, check_isdelim);\n        while (isWhite(*p))\n            p++;\n    }\n\n    if (idequal(C->buf + p1start, p1end - p1start, \"quote\")) {\n        if (opt || (nargs > 1))\n            bug(\"syntax error in #mode quote command\");\n        if (nargs == 0)\n            args[0] = \"\";\n        S->stack_next->User.quotechar = args[0][0];\n    } else if (idequal(C->buf + p1start, p1end - p1start, \"comment\")) {\n        if ((nargs < 2) || (nargs > 4))\n            bug(\"syntax error in #mode comment command\");\n        if (!opt)\n            opt = \"ccc\";\n        if (nargs < 3)\n            args[2] = \"\";\n        if (nargs < 4)\n            args[3] = \"\";\n        add_comment(S->stack_next, opt, my_strdup(args[0]), my_strdup(args[1]),\n                args[2][0], args[3][0]);\n    } else if (idequal(C->buf + p1start, p1end - p1start, \"string\")) {\n        if ((nargs < 2) || (nargs > 4))\n            bug(\"syntax error in #mode string command\");\n        if (!opt)\n            opt = \"sss\";\n        if (nargs < 3)\n            args[2] = \"\";\n        if (nargs < 4)\n            args[3] = \"\";\n        add_comment(S->stack_next, opt, my_strdup(args[0]), my_strdup(args[1]),\n                args[2][0], args[3][0]);\n    } else if (idequal(C->buf + p1start, p1end - p1start, \"save\")\n            || idequal(C->buf + p1start, p1end - p1start, \"push\")) {\n        if ((opt != NULL )||nargs)\n            bug(\"too many arguments to #mode save\");\n        P = CloneSpecs(S->stack_next);\n        P->stack_next = S->stack_next;\n        S->stack_next = P;\n    } else if (idequal(C->buf + p1start, p1end - p1start, \"restore\")\n            || idequal(C->buf + p1start, p1end - p1start, \"pop\")) {\n        if ((opt != NULL )||nargs)\n            bug(\"too many arguments to #mode restore\");\n        P = S->stack_next->stack_next;\n        if (P == NULL )\n            bug(\"#mode restore without #mode save\");\n        FreeComments(S->stack_next);\n        free(S->stack_next);\n        S->stack_next = P;\n    } else if (idequal(C->buf + p1start, p1end - p1start, \"standard\")) {\n        if ((opt == NULL )||nargs)\n            bug(\"syntax error in #mode standard\");\n        SetStandardMode(S->stack_next, opt);\n    } else if (idequal(C->buf + p1start, p1end - p1start, \"user\")) {\n        if ((opt != NULL )||(nargs!=9))bug(\"#mode user requires 9 arguments\");\n        S->stack_next->User.mStart=my_strdup(args[0]);\n        S->stack_next->User.mEnd=my_strdup(args[1]);\n        S->stack_next->User.mArgS=my_strdup(args[2]);\n        S->stack_next->User.mArgSep=my_strdup(args[3]);\n        S->stack_next->User.mArgE=my_strdup(args[4]);\n        S->stack_next->User.stackchar=my_strdup(args[5]);\n        S->stack_next->User.unstackchar=my_strdup(args[6]);\n        S->stack_next->User.mArgRef=my_strdup(args[7]);\n        S->stack_next->User.quotechar=args[8][0];\n    }\n    else if (idequal(C->buf+p1start,p1end-p1start,\"meta\")) {\n        if ((opt!=NULL)&&!nargs&&!strcmp(opt,\"user\"))\n        S->stack_next->Meta=S->stack_next->User;\n        else {\n            if ((opt!=NULL)||(nargs!=7)) bug(\"#mode meta requires 7 arguments\");\n            S->stack_next->Meta.mStart=my_strdup(args[0]);\n            S->stack_next->Meta.mEnd=my_strdup(args[1]);\n            S->stack_next->Meta.mArgS=my_strdup(args[2]);\n            S->stack_next->Meta.mArgSep=my_strdup(args[3]);\n            S->stack_next->Meta.mArgE=my_strdup(args[4]);\n            S->stack_next->Meta.stackchar=my_strdup(args[5]);\n            S->stack_next->Meta.unstackchar=my_strdup(args[6]);\n        }\n    }\n    else if (idequal(C->buf+p1start,p1end-p1start,\"preservelf\")) {\n        if ((opt==NULL)||nargs) bug(\"syntax error in #mode preservelf\");\n        if (!strcmp(opt,\"1\")||!my_strcasecmp(opt,\"on\")) S->stack_next->preservelf=1;\n        else if (!strcmp(opt,\"0\")||!my_strcasecmp(opt,\"off\")) S->stack_next->preservelf=0;\n        else bug(\"#mode preservelf requires on/off argument\");\n    }\n    else if (idequal(C->buf+p1start,p1end-p1start,\"nocomment\")\n            ||idequal(C->buf+p1start,p1end-p1start,\"nostring\")) {\n        if ((opt!=NULL)||(nargs>1))\n        bug(\"syntax error in #mode nocomment/nostring\");\n        if (nargs==0) FreeComments(S->stack_next);\n        else delete_comment(S->stack_next,my_strdup(args[0]));\n    }\n    else if (idequal(C->buf+p1start,p1end-p1start,\"charset\")) {\n        if ((opt==NULL)||(nargs!=1)) bug(\"syntax error in #mode charset\");\n        if (!my_strcasecmp(opt,\"op\"))\n        S->stack_next->op_set=MakeCharsetSubset((unsigned char *)args[0]);\n        else if (!my_strcasecmp(opt,\"par\"))\n        S->stack_next->ext_op_set=MakeCharsetSubset((unsigned char *)args[0]);\n        else if (!my_strcasecmp(opt,\"id\"))\n        S->stack_next->id_set=MakeCharsetSubset((unsigned char *)args[0]);\n        else bug(\"unknown charset subset name in #mode charset\");\n    }\n    else bug(\"unrecognized #mode command\");\n\n    free(s);\n}\n- sendout: void sendout(const char *s, int l, int proc) /* only process the quotechar, that's all */ /* <=== sendout */ \n{\n    int i;\n\n    if (!commented[iflevel])\n        for (i = 0; i < l; i++) {\n            if (proc && (s[i] != 0) && (s[i] == S->User.quotechar)) {\n                i++;\n                if (i == l)\n                    return;\n            }\n            if (s[i] != 0)\n                outchar(s[i]);\n        }\n    else\n        replace_definition_with_blank_lines(s, s + l - 1, 0);\n}\n- shiftIn: void shiftIn(int l) { /* <=== shiftIn */ \n    int i;\n\n    if (l <= 1)\n        return;\n    l--;\n    if (l >= C->len)\n        C->len = 0;\n    else {\n        if (C->len - l > 100) { /* we want to shrink that buffer */\n            C->buf += l;\n            C->bufsize -= l;\n        } else\n            for (i = l; i < C->len; i++)\n                C->buf[i - l] = C->buf[i];\n        C->len -= l;\n        C->eof = (C->buf[0] == 0);\n    }\n    if (C->len <= 1) {\n        if (C->in == NULL )\n            C->eof = 1;\n        else\n            C->eof = feof(C->in);\n    }\n}\n- matchSequence: int matchSequence(const char *s, int *pos) { /* <=== matchSequence */ \n    int i = *pos;\n    int match;\n    char c;\n\n    while (*s != 0) {\n        if (!((*s) & 0x60)) { /* special sequences */\n            match = 1;\n            switch ((*s) & 0x1f) {\n            case '\\001':\n                c = getChar(i++);\n                if ((c != ' ') && (c != '\\t')) {\n                    match = 0;\n                    break;\n                }\n            case '\\002':\n                i--;\n                do {\n                    c = getChar(++i);\n                } while ((c == ' ') || (c == '\\t'));\n                break;\n            case '\\003':\n                c = getChar(i++);\n                if ((c != ' ') && (c != '\\t') && (c != '\\n')) {\n                    match = 0;\n                    break;\n                }\n            case '\\004':\n                i--;\n                do {\n                    c = getChar(++i);\n                } while ((c == ' ') || (c == '\\t') || (c == '\\n'));\n                break;\n            case '\\006':\n                c = getChar(i++);\n                match = ((c >= 'a') && (c <= 'z')) || ((c >= 'A') && (c <= 'Z'))\n                        || (c == ' ') || (c == '\\t') || (c == '\\n');\n                break;\n            case '\\005':\n                c = getChar(i++);\n                match = ((c >= 'a') && (c <= 'z'))\n                        || ((c >= 'A') && (c <= 'Z'));\n                break;\n            case '\\007':\n                c = getChar(i++);\n                match = ((c >= '0') && (c <= '9'));\n                break;\n            case '\\010':\n                c = getChar(i++);\n                match = IsInCharset(S->id_set, c);\n                break;\n            case '\\011':\n                c = getChar(i++);\n                match = (c == '\\t');\n                break;\n            case '\\012':\n                c = getChar(i++);\n                match = (c == '\\n');\n                break;\n            case '\\013':\n                c = getChar(i++);\n                match = IsInCharset(S->op_set, c);\n                break;\n            case '\\014':\n                c = getChar(i++);\n                match = IsInCharset(S->ext_op_set, c)\n                        || IsInCharset(S->op_set, c);\n                break;\n            }\n            if ((*s) & 0x80)\n                match = !match;\n            if (!match)\n                return 0;\n        } else if (getChar(i++) != *s)\n            return 0;\n        s++;\n    }\n    *pos = i;\n    return 1;\n}\n- matchStartSequence: int matchStartSequence(const char *s, int *pos) { /* <=== matchStartSequence */ \n    char c;\n    int match;\n\n    if (!((*s) & 0x60)) { /* special sequences from prev. context */\n        c = getChar(*pos - 1);\n        match = 1;\n        if (*s == 0)\n            return 1;\n        switch ((*s) & 0x1f) {\n        case '\\001':\n            if ((c != ' ') && (c != '\\t')) {\n                match = 0;\n                break;\n            }\n        case '\\002':\n            break;\n        case '\\003':\n            if ((c != ' ') && (c != '\\t') && (c != '\\n')) {\n                match = 0;\n                break;\n            }\n        case '\\004':\n            break;\n        case '\\006':\n            if ((c == ' ') || (c == '\\t') || (c == '\\n'))\n                break;\n        case '\\005':\n            match = ((c >= 'a') && (c <= 'z')) || ((c >= 'A') && (c <= 'Z'));\n            break;\n        case '\\007':\n            match = ((c >= '0') && (c <= '9'));\n            break;\n        case '\\010':\n            match = IsInCharset(S->id_set, c);\n            break;\n        case '\\011':\n            match = (c == '\\t');\n            break;\n        case '\\012':\n            match = (c == '\\n');\n            break;\n        case '\\013':\n            match = IsInCharset(S->op_set, c);\n            break;\n        case '\\014':\n            match = IsInCharset(S->ext_op_set, c) || IsInCharset(S->op_set, c);\n            break;\n        }\n        if ((*s) & 0x80)\n            match = !match;\n        if (!match)\n            return 0;\n        s++;\n    }\n    return matchSequence(s, pos);\n}\n- getChar: char getChar(int pos) { /* <=== getChar */ \n    static int lastchar = -666;\n    int c;\n\n    if (lastchar == -666 && !strcmp(S->Meta.mEnd, \"\\n\"))\n        lastchar = '\\n';\n\n    if (C->in == NULL ) {\n        if (pos >= C->len)\n            return 0;\n        else\n            return C->buf[pos];\n    }\n    extendBuf(pos);\n    while (pos >= C->len) {\n        do {\n            c = fgetc(C->in);\n        } while (c == 13);\n        if (lastchar == '\\n')\n            C->lineno++;\n        lastchar = c;\n        if (c == EOF)\n            c = 0;\n        C->buf[C->len++] = (char) c;\n    }\n    return C->buf[pos];\n}\n- FLAG_IGNORE: #define FLAG_IGNORE     0x40  /* <=== src/gpp.c:113:113:FLAG_IGNORE:0 */ \n- ProcessContext: void ProcessContext(void) { /* <=== ProcessContext */ \n    if (C->len == 0) {\n        C->buf[0] = '\\n';\n        C->len++;\n    }\n    while (!C->eof)\n        ParseText();\n    if (C->in != NULL )\n        fclose(C->in);\n    free(C->malloced_buf);\n}\n- outchar: void outchar(char c) { /* <=== outchar */ \n    if (C->out->bufsize) {\n        if (C->out->len + 1 == C->out->bufsize) {\n            C->out->bufsize = C->out->bufsize * 2;\n            C->out->buf = realloc(C->out->buf, C->out->bufsize);\n            if (C->out->buf == NULL )\n                bug(\"Out of memory\");\n        }\n        C->out->buf[C->out->len++] = c;\n    } else {\n        if (dosmode && (c == 10)) {\n            fputc(13, C->out->f);\n            if (file_and_stdout)\n                fputc(13, stdout);\n        }\n        if (c != 13) {\n            fputc(c, C->out->f);\n            if (file_and_stdout)\n                fputc(c, stdout);\n        }\n    }\n}\n- extendBuf: void extendBuf(int pos) { /* <=== extendBuf */ \n    char *p;\n    if (C->bufsize <= pos) {\n        C->bufsize += pos; /* approx double */\n        p = malloc(C->bufsize);\n        memcpy(p, C->buf, C->len);\n        free(C->malloced_buf);\n        C->malloced_buf = C->buf = p;\n        if (C->buf == NULL )\n            bug(\"Out of memory\");\n    }\n}\n- comment_or_white: int comment_or_white(int start, int end, int cmtmode) { /* <=== comment_or_white */ \n    char c;\n\n    while (start < end) {\n        SkipPossibleComments(&start, cmtmode, 1);\n        if (start < end) {\n            c = getChar(start++);\n            if ((c != ' ') && (c != '\\n') && (c != '\\t'))\n                return 0;\n        }\n    }\n    return 1;\n}\n- idequal: int idequal(const char *b, int l, const char *s) { /* <=== idequal */ \n    int i;\n\n    if ((int) strlen(s) != l)\n        return 0;\n    for (i = 0; i < l; i++)\n        if (b[i] != s[i])\n            return 0;\n    return 1;\n}\n- ParsePossibleUser: int ParsePossibleUser(void) { /* <=== ParsePossibleUser */ \n    int idstart, idend, sh_end, lg_end, macend;\n    int argc, id, i, l;\n    char *argv[MAXARGS];\n    int argb[MAXARGS], arge[MAXARGS];\n    struct INPUTCONTEXT *T;\n\n    idstart = 1;\n    id = 0;\n    if (!SplicePossibleUser(&idstart, &idend, &sh_end, &lg_end, argb, arge,\n            &argc, 1, &id, FLAG_USER))\n        return -1;\n    if ((sh_end >= 0) && (C->namedargs != NULL )) {\n        i = findNamedArg(C->buf + idstart, idend - idstart);\n        if (i >= 0) {\n            if (i < C->argc)\n                sendout(C->argv[i], strlen(C->argv[i]), 0);\n            shiftIn(sh_end);\n            return 0;\n        }\n    }\n\n    if (id < 0)\n        return -1;\n    if (lg_end >= 0)\n        macend = lg_end;\n    else {\n        macend = sh_end;\n        argc = 0;\n    }\n\n    if (macros[id].nnamedargs == -2) { /* defined(...) macro for arithmetic */\n        char *s, *t;\n        if (argc != 1)\n            return -1;\n        s = remove_comments(argb[0], arge[0], FLAG_USER);\n        t = s + strlen(s) - 1;\n        if (*s != 0)\n            while ((t != s) && isWhite(*t))\n                *(t--) = 0;\n        t = s;\n        while (isWhite(*t))\n            t++;\n        if (findIdent(t, strlen(t)) >= 0)\n            outchar('1');\n        else\n            outchar('0');\n        free(s);\n        shiftIn(macend);\n        return 0;\n    }\n    if (!macros[id].macrotext[0]) { /* the empty macro */\n        shiftIn(macend);\n        return 0;\n    }\n\n    for (i = 0; i < argc; i++)\n        argv[i] = ProcessText(C->buf + argb[i], arge[i] - argb[i], FLAG_USER);\n    /* process macro text */\n    T = C;\n    C = malloc(sizeof *C);\n    C->out = T->out;\n    C->in = NULL;\n    C->argc = argc;\n    C->argv = argv;\n    C->filename = T->filename;\n    C->lineno = T->lineno;\n    C->may_have_args = 1;\n    if ((macros[id].nnamedargs == -1) && (lg_end >= 0)\n            && (macros[id].define_specs->User.mEnd[0] == 0)) {\n        /* build an aliased macro call */\n        l = strlen(macros[id].macrotext) + 2\n                + strlen(macros[id].define_specs->User.mArgS)\n                + strlen(macros[id].define_specs->User.mArgE)\n                + (argc - 1) * strlen(macros[id].define_specs->User.mArgSep);\n        for (i = 0; i < argc; i++)\n            l += strlen(argv[i]);\n        C->buf = C->malloced_buf = malloc(l);\n        l = strlen(macros[id].macrotext) + 1;\n        C->buf[0] = '\\n';\n        strcpy(C->buf + 1, macros[id].macrotext);\n        while ((l > 1) && isWhite(C->buf[l - 1]))\n            l--;\n        strcpy(C->buf + l, macros[id].define_specs->User.mArgS);\n        for (i = 0; i < argc; i++) {\n            if (i > 0)\n                strcat(C->buf, macros[id].define_specs->User.mArgSep);\n            strcat(C->buf, argv[i]);\n        }\n        strcat(C->buf, macros[id].define_specs->User.mArgE);\n        C->may_have_args = 0;\n    } else {\n        C->buf = C->malloced_buf = malloc(strlen(macros[id].macrotext) + 2);\n        C->buf[0] = '\\n';\n        strcpy(C->buf + 1, macros[id].macrotext);\n    }\n    C->len = strlen(C->buf);\n    C->bufsize = C->len + 1;\n    C->eof = 0;\n    C->namedargs = macros[id].argnames;\n    C->in_comment = macros[id].defined_in_comment;\n    C->ambience = FLAG_META;\n    PushSpecs(macros[id].define_specs);\n    ProcessContext();\n    PopSpecs();\n    free(C);\n    C = T;\n\n    for (i = 0; i < argc; i++)\n        free(argv[i]);\n    shiftIn(macend);\n    return 0;\n}\n- ArithmEval: char *ArithmEval(int pos1, int pos2) { /* <=== ArithmEval */ \n    char *s, *t;\n    int i;\n\n    /* first define the defined(...) operator */\n    i = findIdent(\"defined\", strlen(\"defined\"));\n    if (i >= 0)\n        warning(\"the defined(...) macro is already defined\");\n    else {\n        newmacro(\"defined\", strlen(\"defined\"), 1);\n        macros[nmacros].macrolen = 0;\n        macros[nmacros].macrotext = malloc(1);\n        macros[nmacros].macrotext[0] = 0;\n        macros[nmacros].nnamedargs = -2; /* trademark of the defined(...) macro */\n        nmacros++;\n    }\n    /* process the text in a usual way */\n    s = ProcessText(C->buf + pos1, pos2 - pos1, FLAG_META);\n    /* undefine the defined(...) operator */\n    if (i < 0) {\n        i = findIdent(\"defined\", strlen(\"defined\"));\n        if ((i < 0) || (macros[i].nnamedargs != -2))\n            warning(\"the defined(...) macro was redefined in expression\");\n        else\n            delete_macro(i);\n    }\n\n    if (!DoArithmEval(s, 0, strlen(s), &i))\n        return s; /* couldn't compute */\n    t = malloc(MAX_GPP_NUM_SIZE);\n    sprintf(t, \"%d\", i);\n    free(s);\n    return t;\n}\n- STACKDEPTH: #define STACKDEPTH 50 /* <=== src/gpp.c:48:48:STACKDEPTH:0 */ \n- FLAG_USER: #define FLAG_USER 1 /* <=== src/gpp.c:119:119:FLAG_USER:0 */ \n- findIdent: int findIdent(const char *b, int l) { /* <=== findIdent */ \n    int i;\n\n    for (i = 0; i < nmacros; i++)\n        if (idequal(b, l, macros[i].username))\n            return i;\n    return -1;\n}\n- ParsePossibleMeta: int ParsePossibleMeta(void) { /* <=== ParsePossibleMeta */ \n    int cklen, nameend;\n    int id, expparams, nparam, i, j;\n    int p1start, p1end, p2start, p2end, macend;\n    int argc, argb[MAXARGS], arge[MAXARGS];\n    char *tmpbuf;\n\n    cklen = 1;\n    if (!matchStartSequence(S->Meta.mStart, &cklen))\n        return -1;\n    nameend = identifierEnd(cklen);\n    if (nameend && !getChar(nameend - 1))\n        return -1;\n\n    argc = 0; /* for #define with named args */\n    if (idequal(C->buf + cklen, nameend - cklen, \"define\")) /* check identifier */\n    {\n        id = 1;\n        expparams = 2;\n        argc = 1;\n    } else if (idequal(C->buf + cklen, nameend - cklen, \"undef\")) {\n        id = 2;\n        expparams = 1;\n    } else if (idequal(C->buf + cklen, nameend - cklen, \"ifdef\")) {\n        id = 3;\n        expparams = 1;\n    } else if (idequal(C->buf + cklen, nameend - cklen, \"ifndef\")) {\n        id = 4;\n        expparams = 1;\n    } else if (idequal(C->buf + cklen, nameend - cklen, \"else\")) {\n        id = 5;\n        expparams = 0;\n    } else if (idequal(C->buf + cklen, nameend - cklen, \"endif\")) {\n        id = 6;\n        expparams = 0;\n    } else if (idequal(C->buf + cklen, nameend - cklen, \"include\")) {\n        id = 7;\n        expparams = 1;\n    } else if (idequal(C->buf + cklen, nameend - cklen, \"exec\")) {\n        id = 8;\n        expparams = 1;\n    } else if (idequal(C->buf + cklen, nameend - cklen, \"defeval\")) {\n        id = 9;\n        expparams = 2;\n        argc = 1;\n    } else if (idequal(C->buf + cklen, nameend - cklen, \"ifeq\")) {\n        id = 10;\n        expparams = 2;\n    } else if (idequal(C->buf + cklen, nameend - cklen, \"ifneq\")) {\n        id = 11;\n        expparams = 2;\n    } else if (idequal(C->buf + cklen, nameend - cklen, \"eval\")) {\n        id = 12;\n        expparams = 1;\n    } else if (idequal(C->buf + cklen, nameend - cklen, \"if\")) {\n        id = 13;\n        expparams = 1;\n    } else if (idequal(C->buf + cklen, nameend - cklen, \"mode\")) {\n        id = 14;\n        expparams = 2;\n    } else if (idequal(C->buf + cklen, nameend - cklen, \"line\")) {\n        id = 15;\n        expparams = 0;\n    } else if (idequal(C->buf + cklen, nameend - cklen, \"file\")) {\n        id = 16;\n        expparams = 0;\n    } else if (idequal(C->buf + cklen, nameend - cklen, \"elif\")) {\n        id = 17;\n        expparams = 1;\n    } else if (idequal(C->buf + cklen, nameend - cklen, \"error\")) {\n        id = 18;\n        expparams = 1;\n    } else if (idequal(C->buf + cklen, nameend - cklen, \"warning\")) {\n        id = 19;\n        expparams = 1;\n    } else if (idequal(C->buf + cklen, nameend - cklen, \"date\")) {\n        id = 20;\n        expparams = 1;\n    } else\n        return -1;\n\n    /* #MODE magic : define \"...\" to be C-style strings */\n    if (id == 14) {\n        PushSpecs(S);\n        S->preservelf = 1;\n        delete_comment(S, my_strdup(\"\\\"\"));\n        add_comment(S, \"sss\", my_strdup(\"\\\"\"), my_strdup(\"\\\"\"), '\\\\', '\\n');\n    }\n\n    nparam = findMetaArgs(nameend, &p1start, &p1end, &p2start, &p2end, &macend,\n            &argc, argb, arge);\n    if (nparam == -1)\n        return -1;\n\n    if ((nparam == 2) && isWhitesep(S->Meta.mArgSep))\n        if (comment_or_white(p2start, p2end, FLAG_META))\n            nparam = 1;\n    if ((nparam == 1) && isWhitesep(S->Meta.mArgS))\n        if (comment_or_white(p1start, p1end, FLAG_META))\n            nparam = 0;\n    if (expparams && !nparam)\n        bug(\"Missing argument in meta-macro\");\n\n    switch (id) {\n    case 1: /* DEFINE */\n        if (!commented[iflevel]) {\n            whiteout(&p1start, &p1end); /* recall comments are not allowed here */\n            if ((p1start == p1end) || (identifierEnd(p1start) != p1end))\n                bug(\"#define requires an identifier (A-Z,a-z,0-9,_ only)\");\n            /* buf starts 1 char before the macro */\n            i = findIdent(C->buf + p1start, p1end - p1start);\n            if (i >= 0)\n                delete_macro(i);\n            newmacro(C->buf + p1start, p1end - p1start, 1);\n            if (nparam == 1) {\n                p2end = p2start = p1end;\n            }\n            replace_definition_with_blank_lines(C->buf + 1, C->buf + p2end,\n                    S->preservelf);\n            macros[nmacros].macrotext = remove_comments(p2start, p2end,\n                    FLAG_META);\n            macros[nmacros].macrolen = strlen(macros[nmacros].macrotext);\n            macros[nmacros].defined_in_comment = C->in_comment;\n\n            if (argc) {\n                for (j = 0; j < argc; j++)\n                    whiteout(argb + j, arge + j);\n                /* define with one empty argument */\n                if ((argc == 1) && (arge[0] == argb[0]))\n                    argc = 0;\n                macros[nmacros].argnames = malloc((argc + 1) * sizeof(char *));\n                macros[nmacros].argnames[argc] = NULL;\n            }\n            macros[nmacros].nnamedargs = argc;\n            for (j = 0; j < argc; j++) {\n                if ((argb[j] == arge[j]) || (identifierEnd(argb[j]) != arge[j]))\n                    bug(\n                            \"#define with named args needs identifiers as arg names\");\n                macros[nmacros].argnames[j] = malloc(arge[j] - argb[j] + 1);\n                memcpy(macros[nmacros].argnames[j], C->buf + argb[j],\n                        arge[j] - argb[j]);\n                macros[nmacros].argnames[j][arge[j] - argb[j]] = 0;\n            }\n            lookupArgRefs(nmacros++);\n        } else\n            replace_directive_with_blank_line(C->out->f);\n        break;\n\n    case 2: /* UNDEF */\n        replace_directive_with_blank_line(C->out->f);\n        if (!commented[iflevel]) {\n            if (nparam == 2 && WarningLevel > 0)\n                warning(\"Extra argument to #undef ignored\");\n            whiteout(&p1start, &p1end);\n            if ((p1start == p1end) || (identifierEnd(p1start) != p1end))\n                bug(\"#undef requires an identifier (A-Z,a-z,0-9,_ only)\");\n            i = findIdent(C->buf + p1start, p1end - p1start);\n            if (i >= 0)\n                delete_macro(i);\n        }\n        break;\n\n    case 3: /* IFDEF */\n        replace_directive_with_blank_line(C->out->f);\n        iflevel++;\n        if (iflevel == STACKDEPTH)\n            bug(\"Too many nested #ifdefs\");\n        commented[iflevel] = commented[iflevel - 1];\n\n        if (!commented[iflevel]) {\n            if (nparam == 2 && WarningLevel > 0)\n                warning(\"Extra argument to #ifdef ignored\");\n            whiteout(&p1start, &p1end);\n            if ((p1start == p1end) || (identifierEnd(p1start) != p1end))\n                bug(\"#ifdef requires an identifier (A-Z,a-z,0-9,_ only)\");\n            i = findIdent(C->buf + p1start, p1end - p1start);\n            commented[iflevel] = (i == -1);\n        }\n        break;\n\n    case 4: /* IFNDEF */\n        replace_directive_with_blank_line(C->out->f);\n        iflevel++;\n        if (iflevel == STACKDEPTH)\n            bug(\"Too many nested #ifdefs\");\n        commented[iflevel] = commented[iflevel - 1];\n        if (!commented[iflevel]) {\n            if (nparam == 2 && WarningLevel > 0)\n                warning(\"Extra argument to #ifndef ignored\");\n            whiteout(&p1start, &p1end);\n            if ((p1start == p1end) || (identifierEnd(p1start) != p1end))\n                bug(\"#ifndef requires an identifier (A-Z,a-z,0-9,_ only)\");\n            i = findIdent(C->buf + p1start, p1end - p1start);\n            commented[iflevel] = (i != -1);\n        }\n        break;\n\n    case 5: /* ELSE */\n        replace_directive_with_blank_line(C->out->f);\n        if (!commented[iflevel] && (nparam > 0) && WarningLevel > 0)\n            warning(\"Extra argument to #else ignored\");\n        if (iflevel == 0)\n            bug(\"#else without #if\");\n        if (!commented[iflevel - 1] && commented[iflevel] != 2)\n            commented[iflevel] = !commented[iflevel];\n        break;\n\n    case 6: /* ENDIF */\n        replace_directive_with_blank_line(C->out->f);\n        if (!commented[iflevel] && (nparam > 0) && WarningLevel > 0)\n            warning(\"Extra argument to #endif ignored\");\n        if (iflevel == 0)\n            bug(\"#endif without #if\");\n        iflevel--;\n        break;\n\n    case 7: /* INCLUDE */\n        if (!commented[iflevel]) {\n            char *incfile_name;\n\n            if (nparam == 2 && WarningLevel > 0)\n                warning(\"Extra argument to #include ignored\");\n            if (!whiteout(&p1start, &p1end))\n                bug(\"Missing file name in #include\");\n            /* user may put \"\" or <> */\n            if (((getChar(p1start) == '\\\"') && (getChar(p1end - 1) == '\\\"'))\n                    || ((getChar(p1start) == '<') && (getChar(p1end - 1) == '>'))) {\n                p1start++;\n                p1end--;\n            }\n            if (p1start >= p1end)\n                bug(\"Missing file name in #include\");\n            incfile_name = malloc(p1end - p1start + 1);\n            /* extract the orig include filename */\n            for (i = 0; i < p1end - p1start; i++)\n                incfile_name[i] = getChar(p1start + i);\n            incfile_name[p1end - p1start] = 0;\n\n            DoInclude(incfile_name);\n        } else\n            replace_directive_with_blank_line(C->out->f);\n        break;\n\n    case 8: /* EXEC */\n        if (!commented[iflevel]) {\n            if (!execallowed)\n                warning(\n                        \"Not allowed to #exec. Command output will be left blank\");\n            else {\n                char *s, *t;\n                int c;\n                FILE *f;\n                s = ProcessText(C->buf + p1start, p1end - p1start, FLAG_META);\n                if (nparam == 2) {\n                    t = ProcessText(C->buf + p2start, p2end - p2start,\n                            FLAG_META);\n                    i = strlen(s);\n                    s = realloc(s, i + strlen(t) + 2);\n                    s[i] = ' ';\n                    strcpy(s + i + 1, t);\n                    free(t);\n                }\n                f = popen(s, \"r\");\n                free(s);\n                if (f == NULL )\n                    warning(\"Cannot #exec. Command not found(?)\");\n                else {\n                    while ((c = fgetc(f)) != EOF)\n                        outchar((char) c);\n                    pclose(f);\n                }\n            }\n        }\n        break;\n\n    case 9: /* DEFEVAL */\n        if (!commented[iflevel]) {\n            whiteout(&p1start, &p1end);\n            if ((p1start == p1end) || (identifierEnd(p1start) != p1end))\n                bug(\"#defeval requires an identifier (A-Z,a-z,0-9,_ only)\");\n            tmpbuf = ProcessText(C->buf + p2start, p2end - p2start, FLAG_META);\n            i = findIdent(C->buf + p1start, p1end - p1start);\n            if (i >= 0)\n                delete_macro(i);\n            newmacro(C->buf + p1start, p1end - p1start, 1);\n            if (nparam == 1) {\n                p2end = p2start = p1end;\n            }\n            replace_definition_with_blank_lines(C->buf + 1, C->buf + p2end,\n                    S->preservelf);\n            macros[nmacros].macrotext = tmpbuf;\n            macros[nmacros].macrolen = strlen(macros[nmacros].macrotext);\n            macros[nmacros].defined_in_comment = C->in_comment;\n\n            if (argc) {\n                for (j = 0; j < argc; j++)\n                    whiteout(argb + j, arge + j);\n                /* define with one empty argument */\n                if ((argc == 1) && (arge[0] == argb[0]))\n                    argc = 0;\n                macros[nmacros].argnames = malloc((argc + 1) * sizeof(char *));\n                macros[nmacros].argnames[argc] = NULL;\n            }\n            macros[nmacros].nnamedargs = argc;\n            for (j = 0; j < argc; j++) {\n                if ((argb[j] == arge[j]) || (identifierEnd(argb[j]) != arge[j]))\n                    bug(\n                            \"#defeval with named args needs identifiers as arg names\");\n                macros[nmacros].argnames[j] = malloc(arge[j] - argb[j] + 1);\n                memcpy(macros[nmacros].argnames[j], C->buf + argb[j],\n                        arge[j] - argb[j]);\n                macros[nmacros].argnames[j][arge[j] - argb[j]] = 0;\n            }\n            lookupArgRefs(nmacros++);\n        } else\n            replace_directive_with_blank_line(C->out->f);\n        break;\n\n    case 10: /* IFEQ */\n        replace_directive_with_blank_line(C->out->f);\n        iflevel++;\n        if (iflevel == STACKDEPTH)\n            bug(\"Too many nested #ifeqs\");\n        commented[iflevel] = commented[iflevel - 1];\n        if (!commented[iflevel]) {\n            char *s, *t;\n            if (nparam != 2)\n                bug(\"#ifeq requires two arguments\");\n            s = ProcessText(C->buf + p1start, p1end - p1start, FLAG_META);\n            t = ProcessText(C->buf + p2start, p2end - p2start, FLAG_META);\n            commented[iflevel] = (nowhite_strcmp(s, t) != 0);\n            free(s);\n            free(t);\n        }\n        break;\n\n    case 11: /* IFNEQ */\n        replace_directive_with_blank_line(C->out->f);\n        iflevel++;\n        if (iflevel == STACKDEPTH)\n            bug(\"Too many nested #ifeqs\");\n        commented[iflevel] = commented[iflevel - 1];\n        if (!commented[iflevel]) {\n            char *s, *t;\n            if (nparam != 2)\n                bug(\"#ifneq requires two arguments\");\n            s = ProcessText(C->buf + p1start, p1end - p1start, FLAG_META);\n            t = ProcessText(C->buf + p2start, p2end - p2start, FLAG_META);\n            commented[iflevel] = (nowhite_strcmp(s, t) == 0);\n            free(s);\n            free(t);\n        }\n        break;\n\n    case 12: /* EVAL */\n        if (!commented[iflevel]) {\n            char *s, *t;\n            if (nparam == 2)\n                p1end = p2end; /* we really want it all ! */\n            s = ArithmEval(p1start, p1end);\n            for (t = s; *t; t++)\n                outchar(*t);\n            free(s);\n        }\n        break;\n\n    case 13: /* IF */\n        replace_directive_with_blank_line(C->out->f);\n        iflevel++;\n        if (iflevel == STACKDEPTH)\n            bug(\"Too many nested #ifs\");\n        commented[iflevel] = commented[iflevel - 1];\n        if (!commented[iflevel]) {\n            char *s;\n            if (nparam == 2)\n                p1end = p2end; /* we really want it all ! */\n            s = ArithmEval(p1start, p1end);\n            commented[iflevel] = ((s[0] == '0') && (s[1] == 0));\n            free(s);\n        }\n        break;\n\n    case 14: /* MODE */\n        replace_directive_with_blank_line(C->out->f);\n        if (nparam == 1)\n            p2start = -1;\n        if (!commented[iflevel])\n            ProcessModeCommand(p1start, p1end, p2start, p2end);\n        PopSpecs();\n        break;\n\n    case 15: { /* LINE */\n        char buf[MAX_GPP_NUM_SIZE];\n        sprintf(buf, \"%d\", C->lineno);\n        replace_directive_with_blank_line(C->out->f);\n        sendout(buf, strlen(buf), 0);\n    }\n        break;\n\n    case 16: /* FILE */\n        replace_directive_with_blank_line(C->out->f);\n        sendout(C->filename, strlen(C->filename), 0);\n        break;\n\n    case 17: /* ELIF */\n        replace_directive_with_blank_line(C->out->f);\n        if (iflevel == 0)\n            bug(\"#elif without #if\");\n        if (!commented[iflevel - 1]) {\n            if (commented[iflevel] != 1)\n                commented[iflevel] = 2;\n            else {\n                char *s;\n                commented[iflevel] = 0;\n                if (nparam == 2)\n                    p1end = p2end; /* we really want it all ! */\n                s = ArithmEval(p1start, p1end);\n                commented[iflevel] = ((s[0] == '0') && (s[1] == 0));\n                free(s);\n            }\n        }\n        break;\n\n    case 18: /* ERROR */\n        replace_directive_with_blank_line(C->out->f);\n        if (!commented[iflevel])\n            bug(\n                    ProcessText(C->buf + p1start,\n                            (nparam == 2 ? p2end : p1end) - p1start,\n                            FLAG_META));\n        break;\n\n    case 19: /* WARNING */\n        replace_directive_with_blank_line(C->out->f);\n        if (!commented[iflevel]) {\n            char *s;\n            s = ProcessText(C->buf + p1start,\n                    (nparam == 2 ? p2end : p1end) - p1start, FLAG_META);\n            warning(s);\n            free(s);\n        }\n        break;\n\n    case 20: { /* DATE */\n        char buf[MAX_GPP_DATE_SIZE];\n        char *fmt;\n        time_t now = time(NULL );\n        fmt = ProcessText(C->buf + p1start,\n                (nparam == 2 ? p2end : p1end) - p1start, FLAG_META);\n        if (!strftime(buf, MAX_GPP_DATE_SIZE, fmt, localtime(&now)))\n            bug(\"date buffer exceeded\");\n        replace_directive_with_blank_line(C->out->f);\n        sendout(buf, strlen(buf), 0);\n        free(fmt);\n    }\n        break;\n\n    default:\n        bug(\"Internal meta-macro identification error\");\n    }\n    shiftIn(macend);\n    return 0;\n}\n- warning: void warning(const char *s) { /* <=== warning */ \n    fprintf(stderr, \"%s:%d: warning: %s\\n\", C->filename, C->lineno, s);\n}\n- identifierEnd: int identifierEnd(int start) { /* <=== identifierEnd */ \n    char c;\n\n    c = getChar(start);\n    if (c == 0)\n        return start;\n    if (c == S->User.quotechar) {\n        c = getChar(start + 1);\n        if (c == 0)\n            return (start + 1);\n        if (isDelim(c))\n            return (start + 2);\n        start += 2;\n        c = getChar(start);\n    }\n    while (!isDelim(c))\n        c = getChar(++start);\n    return start;\n}\n- MAX_GPP_NUM_SIZE: #define MAX_GPP_NUM_SIZE 15 /* <=== src/gpp.c:52:52:MAX_GPP_NUM_SIZE:0 */ \n\nType Definitions:\n- SPECS: typedef struct SPECS {\n    struct MODE User, Meta;\n    struct COMMENT *comments;\n    struct SPECS *stack_next;\n    int preservelf;\n    CHARSET_SUBSET op_set, ext_op_set, id_set;\n} SPECS;\n- SPECS: typedef struct SPECS {\n    struct MODE User, Meta;\n    struct COMMENT *comments;\n    struct SPECS *stack_next;\n    int preservelf;\n    CHARSET_SUBSET op_set, ext_op_set, id_set;\n}\n- INPUTCONTEXT: typedef struct INPUTCONTEXT {\n    char *buf;\n    char *malloced_buf; /* what was actually malloc-ed (buf may have shifted) */\n    int len, bufsize;\n    int lineno;\n    char *filename;\n    FILE *in;\n    int argc;\n    char **argv;\n    char **namedargs;\n    struct OUTPUTCONTEXT *out;\n    int eof;\n    int in_comment;\n    int ambience; /* FLAG_TEXT, FLAG_USER or FLAG_META */\n    int may_have_args;\n} INPUTCONTEXT;\n- INPUTCONTEXT: typedef struct INPUTCONTEXT {\n    char *buf;\n    char *malloced_buf; /* what was actually malloc-ed (buf may have shifted) */\n    int len, bufsize;\n    int lineno;\n    char *filename;\n    FILE *in;\n    int argc;\n    char **argv;\n    char **namedargs;\n    struct OUTPUTCONTEXT *out;\n    int eof;\n    int in_comment;\n    int ambience; /* FLAG_TEXT, FLAG_USER or FLAG_META */\n    int may_have_args;\n}\n- COMMENT: typedef struct COMMENT {\n    char *start; /* how the comment/string starts */\n    char *end; /* how it ends */\n    char quote; /* how to prevent it from ending */\n    char warn; /* a character that shouldn't be in there */\n    int flags[3]; /* meta, user, text */\n    struct COMMENT *next;\n}\n\nGlobal Variables:\n- struct SPECS* S\n- struct INPUTCONTEXT* C\n- int parselevel\n\nImports:\n- #include <stdio.h>\n- # include <config.h>\n- #include <stdlib.h>\n- #include <ctype.h>\n- #include <time.h>\n- #include <string.h>\n- #  include <fnmatch.h>",
    "commit_msg": "Fixes #26 (stack overflow during parse)",
    "cve_desc": "[{'lang': 'en', 'value': 'GPP through 2.25 will try to use more memory space than is available on the stack, leading to a segmentation fault or possibly unspecified other impact via a crafted file.'}]",
    "year": 2020,
    "filename": "gpp.c",
    "commit_url": "\"https://github.com/logological/gpp/commit/329aa63a70d32d1e2ae529130a792e0c6ae4ce79\""
  },
  {
    "repository": "mdadams/jasper",
    "cve_id": "CVE-2018-20570",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "03db7c81f6a8a92d896249bc673877749987fd7a",
    "short_hash": "03db7c81",
    "vulnerableMethods_before": [
      {
        "filename": "src/libjasper/jp2/jp2_enc.c",
        "method_name": "jp2_encode",
        "raw_code": "int jp2_encode(jas_image_t *image, jas_stream_t *out, const char *optstr) /* <=== jp2_encode */ \n{\n\tjp2_box_t *box;\n\tjp2_ftyp_t *ftyp;\n\tjp2_ihdr_t *ihdr;\n\tjas_stream_t *tmpstream;\n\tint allcmptssame;\n\tjp2_bpcc_t *bpcc;\n\tlong len;\n\tuint_fast16_t cmptno;\n\tjp2_colr_t *colr;\n\tchar buf[4096];\n\tuint_fast32_t overhead;\n\tjp2_cdefchan_t *cdefchanent;\n\tjp2_cdef_t *cdef;\n\tint i;\n\tuint_fast32_t typeasoc;\n\tjas_iccprof_t *iccprof;\n\tjas_stream_t *iccstream;\n\tint pos;\n\tint needcdef;\n\tint prec;\n\tint sgnd;\n\n\tbox = 0;\n\ttmpstream = 0;\n\ticcstream = 0;\n\ticcprof = 0;\n\n\tif (jas_image_numcmpts(image) < 1) {\n\t\tjas_eprintf(\"image must have at least one component\\n\");\n\t\tgoto error;\n\t}\n\n\tallcmptssame = 1;\n\tsgnd = jas_image_cmptsgnd(image, 0);\n\tprec = jas_image_cmptprec(image, 0);\n\tfor (i = 1; i < jas_image_numcmpts(image); ++i) {\n\t\tif (jas_image_cmptsgnd(image, i) != sgnd ||\n\t\t  jas_image_cmptprec(image, i) != prec) {\n\t\t\tallcmptssame = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Output the signature box. */\n\n\tif (!(box = jp2_box_create(JP2_BOX_JP))) {\n\t\tjas_eprintf(\"cannot create JP box\\n\");\n\t\tgoto error;\n\t}\n\tbox->data.jp.magic = JP2_JP_MAGIC;\n\tif (jp2_box_put(box, out)) {\n\t\tjas_eprintf(\"cannot write JP box\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Output the file type box. */\n\n\tif (!(box = jp2_box_create(JP2_BOX_FTYP))) {\n\t\tjas_eprintf(\"cannot create FTYP box\\n\");\n\t\tgoto error;\n\t}\n\tftyp = &box->data.ftyp;\n\tftyp->majver = JP2_FTYP_MAJVER;\n\tftyp->minver = JP2_FTYP_MINVER;\n\tftyp->numcompatcodes = 1;\n\tftyp->compatcodes[0] = JP2_FTYP_COMPATCODE;\n\tif (jp2_box_put(box, out)) {\n\t\tjas_eprintf(\"cannot write FTYP box\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/*\n\t * Generate the data portion of the JP2 header box.\n\t * We cannot simply output the header for this box\n\t * since we do not yet know the correct value for the length\n\t * field.\n\t */\n\n\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\tjas_eprintf(\"cannot create temporary stream\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Generate image header box. */\n\n\tif (!(box = jp2_box_create(JP2_BOX_IHDR))) {\n\t\tjas_eprintf(\"cannot create IHDR box\\n\");\n\t\tgoto error;\n\t}\n\tihdr = &box->data.ihdr;\n\tihdr->width = jas_image_width(image);\n\tihdr->height = jas_image_height(image);\n\tihdr->numcmpts = jas_image_numcmpts(image);\n\tihdr->bpc = allcmptssame ? JP2_SPTOBPC(jas_image_cmptsgnd(image, 0),\n\t  jas_image_cmptprec(image, 0)) : JP2_IHDR_BPCNULL;\n\tihdr->comptype = JP2_IHDR_COMPTYPE;\n\tihdr->csunk = 0;\n\tihdr->ipr = 0;\n\tif (jp2_box_put(box, tmpstream)) {\n\t\tjas_eprintf(\"cannot write IHDR box\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Generate bits per component box. */\n\n\tif (!allcmptssame) {\n\t\tif (!(box = jp2_box_create(JP2_BOX_BPCC))) {\n\t\t\tjas_eprintf(\"cannot create BPCC box\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tbpcc = &box->data.bpcc;\n\t\tbpcc->numcmpts = jas_image_numcmpts(image);\n\t\tif (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts,\n\t\t  sizeof(uint_fast8_t)))) {\n\t\t\tjas_eprintf(\"memory allocation failed\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tfor (cmptno = 0; cmptno < bpcc->numcmpts; ++cmptno) {\n\t\t\tbpcc->bpcs[cmptno] = JP2_SPTOBPC(jas_image_cmptsgnd(image,\n\t\t\t  cmptno), jas_image_cmptprec(image, cmptno));\n\t\t}\n\t\tif (jp2_box_put(box, tmpstream)) {\n\t\t\tjas_eprintf(\"cannot write BPCC box\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjp2_box_destroy(box);\n\t\tbox = 0;\n\t}\n\n\t/* Generate color specification box. */\n\n\tif (!(box = jp2_box_create(JP2_BOX_COLR))) {\n\t\tjas_eprintf(\"cannot create COLR box\\n\");\n\t\tgoto error;\n\t}\n\tcolr = &box->data.colr;\n\tswitch (jas_image_clrspc(image)) {\n\tcase JAS_CLRSPC_SRGB:\n\tcase JAS_CLRSPC_SYCBCR:\n\tcase JAS_CLRSPC_SGRAY:\n\t\tcolr->method = JP2_COLR_ENUM;\n\t\tcolr->csid = clrspctojp2(jas_image_clrspc(image));\n\t\tcolr->pri = JP2_COLR_PRI;\n\t\tcolr->approx = 0;\n\t\tbreak;\n\tdefault:\n\t\tcolr->method = JP2_COLR_ICC;\n\t\tcolr->pri = JP2_COLR_PRI;\n\t\tcolr->approx = 0;\n\t\t/* Ensure that cmprof_ is not null. */\n\t\tif (!jas_image_cmprof(image)) {\n\t\t\tjas_eprintf(\"CM profile is null\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tif (!(iccprof = jas_iccprof_createfromcmprof(\n\t\t  jas_image_cmprof(image)))) {\n\t\t\tjas_eprintf(\"cannot create ICC profile\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tif (!(iccstream = jas_stream_memopen(0, 0))) {\n\t\t\tjas_eprintf(\"cannot create temporary stream\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tif (jas_iccprof_save(iccprof, iccstream)) {\n\t\t\tjas_eprintf(\"cannot write ICC profile\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tif ((pos = jas_stream_tell(iccstream)) < 0) {\n\t\t\tjas_eprintf(\"cannot get stream position\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tcolr->iccplen = pos;\n\t\tif (!(colr->iccp = jas_malloc(pos))) {\n\t\t\tjas_eprintf(\"memory allocation failed\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_rewind(iccstream);\n\t\tif (jas_stream_read(iccstream, colr->iccp, colr->iccplen) !=\n\t\t  colr->iccplen) {\n\t\t\tjas_eprintf(\"cannot read temporary stream\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_close(iccstream);\n\t\ticcstream = 0;\n\t\tjas_iccprof_destroy(iccprof);\n\t\ticcprof = 0;\n\t\tbreak;\n\t}\n\tif (jp2_box_put(box, tmpstream)) {\n\t\tjas_eprintf(\"cannot write box\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\tneedcdef = 1;\n\tswitch (jas_clrspc_fam(jas_image_clrspc(image))) {\n\tcase JAS_CLRSPC_FAM_RGB:\n\t\tif (jas_image_cmpttype(image, 0) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R) &&\n\t\t  jas_image_cmpttype(image, 1) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G) &&\n\t\t  jas_image_cmpttype(image, 2) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B))\n\t\t\tneedcdef = 0;\n\t\tbreak;\n\tcase JAS_CLRSPC_FAM_YCBCR:\n\t\tif (jas_image_cmpttype(image, 0) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_Y) &&\n\t\t  jas_image_cmpttype(image, 1) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_CB) &&\n\t\t  jas_image_cmpttype(image, 2) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_CR))\n\t\t\tneedcdef = 0;\n\t\tbreak;\n\tcase JAS_CLRSPC_FAM_GRAY:\n\t\tif (jas_image_cmpttype(image, 0) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_IMAGE_CT_GRAY_Y))\n\t\t\tneedcdef = 0;\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t\tbreak;\n\t}\n\n\tif (needcdef) {\n\t\tif (!(box = jp2_box_create(JP2_BOX_CDEF))) {\n\t\t\tjas_eprintf(\"cannot create CDEF box\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tcdef = &box->data.cdef;\n\t\tcdef->numchans = jas_image_numcmpts(image);\n\t\tcdef->ents = jas_alloc2(cdef->numchans, sizeof(jp2_cdefchan_t));\n\t\tfor (i = 0; i < jas_image_numcmpts(image); ++i) {\n\t\t\tcdefchanent = &cdef->ents[i];\n\t\t\tcdefchanent->channo = i;\n\t\t\ttypeasoc = jp2_gettypeasoc(jas_image_clrspc(image), jas_image_cmpttype(image, i));\n\t\t\tcdefchanent->type = typeasoc >> 16;\n\t\t\tcdefchanent->assoc = typeasoc & 0x7fff;\n\t\t}\n\t\tif (jp2_box_put(box, tmpstream)) {\n\t\t\tjas_eprintf(\"cannot write CDEF box\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjp2_box_destroy(box);\n\t\tbox = 0;\n\t}\n\n\t/* Determine the total length of the JP2 header box. */\n\n\tlen = jas_stream_tell(tmpstream);\n\tjas_stream_rewind(tmpstream);\n\n\t/*\n\t * Output the JP2 header box and all of the boxes which it contains.\n\t */\n\n\tif (!(box = jp2_box_create(JP2_BOX_JP2H))) {\n\t\tjas_eprintf(\"cannot create JP2H box\\n\");\n\t\tgoto error;\n\t}\n\tbox->len = len + JP2_BOX_HDRLEN(false);\n\tif (jp2_box_put(box, out)) {\n\t\tjas_eprintf(\"cannot write JP2H box\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\tif (jas_stream_copy(out, tmpstream, len)) {\n\t\tjas_eprintf(\"cannot copy stream\\n\");\n\t\tgoto error;\n\t}\n\n\tjas_stream_close(tmpstream);\n\ttmpstream = 0;\n\n\t/*\n\t * Output the contiguous code stream box.\n\t */\n\n\tif (!(box = jp2_box_create(JP2_BOX_JP2C))) {\n\t\tjas_eprintf(\"cannot create JP2C box\\n\");\n\t\tgoto error;\n\t}\n\tbox->len = 0;\n\tif (jp2_box_put(box, out)) {\n\t\tjas_eprintf(\"cannot write JP2C box\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Output the JPEG-2000 code stream. */\n\n\toverhead = jas_stream_getrwcount(out);\n\tsprintf(buf, \"%s\\n_jp2overhead=%lu\\n\", (optstr ? optstr : \"\"),\n\t  (unsigned long) overhead);\n\n\tif (jpc_encode(image, out, buf)) {\n\t\tjas_eprintf(\"jpc_encode failed\\n\");\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\n\tif (iccprof) {\n\t\tjas_iccprof_destroy(iccprof);\n\t}\n\tif (iccstream) {\n\t\tjas_stream_close(iccstream);\n\t}\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn -1;\n}",
        "start_line": 92
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "src/libjasper/jp2/jp2_enc.c",
        "method_name": "jp2_encode",
        "raw_code": "int jp2_encode(jas_image_t *image, jas_stream_t *out, const char *optstr) /* <=== jp2_encode */ \n{\n\tjp2_box_t *box;\n\tjp2_ftyp_t *ftyp;\n\tjp2_ihdr_t *ihdr;\n\tjas_stream_t *tmpstream;\n\tint allcmptssame;\n\tjp2_bpcc_t *bpcc;\n\tlong len;\n\tuint_fast16_t cmptno;\n\tjp2_colr_t *colr;\n\tchar buf[4096];\n\tuint_fast32_t overhead;\n\tjp2_cdefchan_t *cdefchanent;\n\tjp2_cdef_t *cdef;\n\tint i;\n\tuint_fast32_t typeasoc;\n\tjas_iccprof_t *iccprof;\n\tjas_stream_t *iccstream;\n\tint pos;\n\tint needcdef;\n\tint prec;\n\tint sgnd;\n\n\tbox = 0;\n\ttmpstream = 0;\n\ticcstream = 0;\n\ticcprof = 0;\n\n\tif (jas_image_numcmpts(image) < 1) {\n\t\tjas_eprintf(\"image must have at least one component\\n\");\n\t\tgoto error;\n\t}\n\n\tallcmptssame = 1;\n\tsgnd = jas_image_cmptsgnd(image, 0);\n\tprec = jas_image_cmptprec(image, 0);\n\tfor (i = 1; i < jas_image_numcmpts(image); ++i) {\n\t\tif (jas_image_cmptsgnd(image, i) != sgnd ||\n\t\t  jas_image_cmptprec(image, i) != prec) {\n\t\t\tallcmptssame = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Output the signature box. */\n\n\tif (!(box = jp2_box_create(JP2_BOX_JP))) {\n\t\tjas_eprintf(\"cannot create JP box\\n\");\n\t\tgoto error;\n\t}\n\tbox->data.jp.magic = JP2_JP_MAGIC;\n\tif (jp2_box_put(box, out)) {\n\t\tjas_eprintf(\"cannot write JP box\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Output the file type box. */\n\n\tif (!(box = jp2_box_create(JP2_BOX_FTYP))) {\n\t\tjas_eprintf(\"cannot create FTYP box\\n\");\n\t\tgoto error;\n\t}\n\tftyp = &box->data.ftyp;\n\tftyp->majver = JP2_FTYP_MAJVER;\n\tftyp->minver = JP2_FTYP_MINVER;\n\tftyp->numcompatcodes = 1;\n\tftyp->compatcodes[0] = JP2_FTYP_COMPATCODE;\n\tif (jp2_box_put(box, out)) {\n\t\tjas_eprintf(\"cannot write FTYP box\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/*\n\t * Generate the data portion of the JP2 header box.\n\t * We cannot simply output the header for this box\n\t * since we do not yet know the correct value for the length\n\t * field.\n\t */\n\n\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\tjas_eprintf(\"cannot create temporary stream\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Generate image header box. */\n\n\tif (!(box = jp2_box_create(JP2_BOX_IHDR))) {\n\t\tjas_eprintf(\"cannot create IHDR box\\n\");\n\t\tgoto error;\n\t}\n\tihdr = &box->data.ihdr;\n\tihdr->width = jas_image_width(image);\n\tihdr->height = jas_image_height(image);\n\tihdr->numcmpts = jas_image_numcmpts(image);\n\tihdr->bpc = allcmptssame ? JP2_SPTOBPC(jas_image_cmptsgnd(image, 0),\n\t  jas_image_cmptprec(image, 0)) : JP2_IHDR_BPCNULL;\n\tihdr->comptype = JP2_IHDR_COMPTYPE;\n\tihdr->csunk = 0;\n\tihdr->ipr = 0;\n\tif (jp2_box_put(box, tmpstream)) {\n\t\tjas_eprintf(\"cannot write IHDR box\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Generate bits per component box. */\n\n\tif (!allcmptssame) {\n\t\tif (!(box = jp2_box_create(JP2_BOX_BPCC))) {\n\t\t\tjas_eprintf(\"cannot create BPCC box\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tbpcc = &box->data.bpcc;\n\t\tbpcc->numcmpts = jas_image_numcmpts(image);\n\t\tif (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts,\n\t\t  sizeof(uint_fast8_t)))) {\n\t\t\tjas_eprintf(\"memory allocation failed\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tfor (cmptno = 0; cmptno < bpcc->numcmpts; ++cmptno) {\n\t\t\tbpcc->bpcs[cmptno] = JP2_SPTOBPC(jas_image_cmptsgnd(image,\n\t\t\t  cmptno), jas_image_cmptprec(image, cmptno));\n\t\t}\n\t\tif (jp2_box_put(box, tmpstream)) {\n\t\t\tjas_eprintf(\"cannot write BPCC box\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjp2_box_destroy(box);\n\t\tbox = 0;\n\t}\n\n\t/* Generate color specification box. */\n\n\tif (!(box = jp2_box_create(JP2_BOX_COLR))) {\n\t\tjas_eprintf(\"cannot create COLR box\\n\");\n\t\tgoto error;\n\t}\n\tcolr = &box->data.colr;\n\tswitch (jas_image_clrspc(image)) {\n\tcase JAS_CLRSPC_SRGB:\n\tcase JAS_CLRSPC_SYCBCR:\n\tcase JAS_CLRSPC_SGRAY:\n\t\tcolr->method = JP2_COLR_ENUM;\n\t\tcolr->csid = clrspctojp2(jas_image_clrspc(image));\n\t\tcolr->pri = JP2_COLR_PRI;\n\t\tcolr->approx = 0;\n\t\tbreak;\n\tdefault:\n\t\tcolr->method = JP2_COLR_ICC;\n\t\tcolr->pri = JP2_COLR_PRI;\n\t\tcolr->approx = 0;\n\t\t/* Ensure that cmprof_ is not null. */\n\t\tif (!jas_image_cmprof(image)) {\n\t\t\tjas_eprintf(\"CM profile is null\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tif (!(iccprof = jas_iccprof_createfromcmprof(\n\t\t  jas_image_cmprof(image)))) {\n\t\t\tjas_eprintf(\"cannot create ICC profile\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tif (!(iccstream = jas_stream_memopen(0, 0))) {\n\t\t\tjas_eprintf(\"cannot create temporary stream\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tif (jas_iccprof_save(iccprof, iccstream)) {\n\t\t\tjas_eprintf(\"cannot write ICC profile\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tif ((pos = jas_stream_tell(iccstream)) < 0) {\n\t\t\tjas_eprintf(\"cannot get stream position\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tcolr->iccplen = pos;\n\t\tif (!(colr->iccp = jas_malloc(pos))) {\n\t\t\tjas_eprintf(\"memory allocation failed\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_rewind(iccstream);\n\t\tif (jas_stream_read(iccstream, colr->iccp, colr->iccplen) !=\n\t\t  colr->iccplen) {\n\t\t\tjas_eprintf(\"cannot read temporary stream\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_close(iccstream);\n\t\ticcstream = 0;\n\t\tjas_iccprof_destroy(iccprof);\n\t\ticcprof = 0;\n\t\tbreak;\n\t}\n\tif (jp2_box_put(box, tmpstream)) {\n\t\tjas_eprintf(\"cannot write box\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\tneedcdef = 1;\n\tswitch (jas_clrspc_fam(jas_image_clrspc(image))) {\n\tcase JAS_CLRSPC_FAM_RGB:\n\t\tif (jas_image_numcmpts(image) >= 3 &&\n\t\t  jas_image_cmpttype(image, 0) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R) &&\n\t\t  jas_image_cmpttype(image, 1) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G) &&\n\t\t  jas_image_cmpttype(image, 2) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B))\n\t\t\tneedcdef = 0;\n\t\tbreak;\n\tcase JAS_CLRSPC_FAM_YCBCR:\n\t\tif (jas_image_numcmpts(image) >= 3 &&\n\t\t  jas_image_cmpttype(image, 0) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_Y) &&\n\t\t  jas_image_cmpttype(image, 1) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_CB) &&\n\t\t  jas_image_cmpttype(image, 2) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_CR))\n\t\t\tneedcdef = 0;\n\t\tbreak;\n\tcase JAS_CLRSPC_FAM_GRAY:\n\t\tif (jas_image_numcmpts(image) >= 1 &&\n\t\t  jas_image_cmpttype(image, 0) ==\n\t\t  JAS_IMAGE_CT_COLOR(JAS_IMAGE_CT_GRAY_Y))\n\t\t\tneedcdef = 0;\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t\tbreak;\n\t}\n\n\tif (needcdef) {\n\t\tif (!(box = jp2_box_create(JP2_BOX_CDEF))) {\n\t\t\tjas_eprintf(\"cannot create CDEF box\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tcdef = &box->data.cdef;\n\t\tcdef->numchans = jas_image_numcmpts(image);\n\t\tcdef->ents = jas_alloc2(cdef->numchans, sizeof(jp2_cdefchan_t));\n\t\tfor (i = 0; i < jas_image_numcmpts(image); ++i) {\n\t\t\tcdefchanent = &cdef->ents[i];\n\t\t\tcdefchanent->channo = i;\n\t\t\ttypeasoc = jp2_gettypeasoc(jas_image_clrspc(image), jas_image_cmpttype(image, i));\n\t\t\tcdefchanent->type = typeasoc >> 16;\n\t\t\tcdefchanent->assoc = typeasoc & 0x7fff;\n\t\t}\n\t\tif (jp2_box_put(box, tmpstream)) {\n\t\t\tjas_eprintf(\"cannot write CDEF box\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjp2_box_destroy(box);\n\t\tbox = 0;\n\t}\n\n\t/* Determine the total length of the JP2 header box. */\n\n\tlen = jas_stream_tell(tmpstream);\n\tjas_stream_rewind(tmpstream);\n\n\t/*\n\t * Output the JP2 header box and all of the boxes which it contains.\n\t */\n\n\tif (!(box = jp2_box_create(JP2_BOX_JP2H))) {\n\t\tjas_eprintf(\"cannot create JP2H box\\n\");\n\t\tgoto error;\n\t}\n\tbox->len = len + JP2_BOX_HDRLEN(false);\n\tif (jp2_box_put(box, out)) {\n\t\tjas_eprintf(\"cannot write JP2H box\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\tif (jas_stream_copy(out, tmpstream, len)) {\n\t\tjas_eprintf(\"cannot copy stream\\n\");\n\t\tgoto error;\n\t}\n\n\tjas_stream_close(tmpstream);\n\ttmpstream = 0;\n\n\t/*\n\t * Output the contiguous code stream box.\n\t */\n\n\tif (!(box = jp2_box_create(JP2_BOX_JP2C))) {\n\t\tjas_eprintf(\"cannot create JP2C box\\n\");\n\t\tgoto error;\n\t}\n\tbox->len = 0;\n\tif (jp2_box_put(box, out)) {\n\t\tjas_eprintf(\"cannot write JP2C box\\n\");\n\t\tgoto error;\n\t}\n\tjp2_box_destroy(box);\n\tbox = 0;\n\n\t/* Output the JPEG-2000 code stream. */\n\n\toverhead = jas_stream_getrwcount(out);\n\tsprintf(buf, \"%s\\n_jp2overhead=%lu\\n\", (optstr ? optstr : \"\"),\n\t  (unsigned long) overhead);\n\n\tif (jpc_encode(image, out, buf)) {\n\t\tjas_eprintf(\"jpc_encode failed\\n\");\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\n\tif (iccprof) {\n\t\tjas_iccprof_destroy(iccprof);\n\t}\n\tif (iccstream) {\n\t\tjas_stream_close(iccstream);\n\t}\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn -1;\n}",
        "start_line": 92
      }
    ],
    "code_context": "Called Methods:\n- jas_iccattrval_destroy: void jas_iccattrval_destroy(jas_iccattrval_t *attrval) /* <=== jas_iccattrval_destroy */ \n{\n#if 0\njas_eprintf(\"refcnt=%d\\n\", attrval->refcnt);\n#endif\n\tif (--attrval->refcnt <= 0) {\n\t\tif (attrval->ops->destroy)\n\t\t\t(*attrval->ops->destroy)(attrval);\n\t\tjas_free(attrval);\n\t}\n}\n- JP2_CDEF_ASOC_NONE: #define\tJP2_CDEF_ASOC_NONE\t65535 /* <=== src/libjasper/jp2/jp2_cod.h:207:207:JP2_CDEF_ASOC_NONE:0 */ \n- jp2_box_destroy: void jp2_box_destroy(jp2_box_t *box) /* <=== jp2_box_destroy */ \n{\n\tif (box->ops->destroy) {\n\t\t(*box->ops->destroy)(box);\n\t}\n\tjas_free(box);\n}\n- JP2_BOX_SUPER: #define\tJP2_BOX_SUPER\t0x01 /* <=== src/libjasper/jp2/jp2_cod.h:114:114:JP2_BOX_SUPER:0 */ \n- jas_stream_copy: int jas_stream_copy(jas_stream_t *out, jas_stream_t *in, int n) /* <=== jas_stream_copy */ \n{\n\tint all;\n\tint c;\n\tint m;\n\n\tall = (n < 0) ? 1 : 0;\n\n\tm = n;\n\twhile (all || m > 0) {\n\t\tif ((c = jas_stream_getc_macro(in)) == EOF) {\n\t\t\t/* The next character of input could not be read. */\n\t\t\t/* Return with an error if an I/O error occured\n\t\t\t  (not including EOF) or if an explicit copy count\n\t\t\t  was specified. */\n\t\t\treturn (!all || jas_stream_error(in)) ? (-1) : 0;\n\t\t}\n\t\tif (jas_stream_putc_macro(out, c) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\t--m;\n\t}\n\treturn 0;\n}\n- jas_iccpadtomult: static long jas_iccpadtomult(long x, long y) /* <=== jas_iccpadtomult */ \n{\n\treturn ((x + y - 1) / y) * y;\n}\n- jp2_gettypeasoc: static uint_fast32_t jp2_gettypeasoc(int colorspace, int ctype) /* <=== jp2_gettypeasoc */ \n{\n\tint type;\n\tint asoc;\n\n\tif (ctype & JAS_IMAGE_CT_OPACITY) {\n\t\ttype = JP2_CDEF_TYPE_OPACITY;\n\t\tasoc = JP2_CDEF_ASOC_ALL;\n\t\tgoto done;\n\t}\n\n\ttype = JP2_CDEF_TYPE_UNSPEC;\n\tasoc = JP2_CDEF_ASOC_NONE;\n\tswitch (jas_clrspc_fam(colorspace)) {\n\tcase JAS_CLRSPC_FAM_RGB:\n\t\tswitch (JAS_IMAGE_CT_COLOR(ctype)) {\n\t\tcase JAS_IMAGE_CT_RGB_R:\n\t\t\ttype = JP2_CDEF_TYPE_COLOR;\n\t\t\tasoc = JP2_CDEF_RGB_R;\n\t\t\tbreak;\n\t\tcase JAS_IMAGE_CT_RGB_G:\n\t\t\ttype = JP2_CDEF_TYPE_COLOR;\n\t\t\tasoc = JP2_CDEF_RGB_G;\n\t\t\tbreak;\n\t\tcase JAS_IMAGE_CT_RGB_B:\n\t\t\ttype = JP2_CDEF_TYPE_COLOR;\n\t\t\tasoc = JP2_CDEF_RGB_B;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase JAS_CLRSPC_FAM_YCBCR:\n\t\tswitch (JAS_IMAGE_CT_COLOR(ctype)) {\n\t\tcase JAS_IMAGE_CT_YCBCR_Y:\n\t\t\ttype = JP2_CDEF_TYPE_COLOR;\n\t\t\tasoc = JP2_CDEF_YCBCR_Y;\n\t\t\tbreak;\n\t\tcase JAS_IMAGE_CT_YCBCR_CB:\n\t\t\ttype = JP2_CDEF_TYPE_COLOR;\n\t\t\tasoc = JP2_CDEF_YCBCR_CB;\n\t\t\tbreak;\n\t\tcase JAS_IMAGE_CT_YCBCR_CR:\n\t\t\ttype = JP2_CDEF_TYPE_COLOR;\n\t\t\tasoc = JP2_CDEF_YCBCR_CR;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase JAS_CLRSPC_FAM_GRAY:\n\t\ttype = JP2_CDEF_TYPE_COLOR;\n\t\tasoc = JP2_CDEF_GRAY_Y;\n\t\tbreak;\n\t}\n\ndone:\n\treturn (type << 16) | asoc;\n}\n- JP2_BOX_BPCC: #define\tJP2_BOX_BPCC\t0x62706363\t/* Bits Per Component */ /* <=== src/libjasper/jp2/jp2_cod.h:98:98:JP2_BOX_BPCC:0 */ \n- jas_iccprof_copy: jas_iccprof_t *jas_iccprof_copy(jas_iccprof_t *prof) /* <=== jas_iccprof_copy */ \n{\n\tjas_iccprof_t *newprof;\n\tnewprof = 0;\n\tif (!(newprof = jas_iccprof_create()))\n\t\tgoto error;\n\tnewprof->hdr = prof->hdr;\n\tnewprof->tagtab.numents = 0;\n\tnewprof->tagtab.ents = 0;\n\tassert(newprof->attrtab);\n\tjas_iccattrtab_destroy(newprof->attrtab);\n\tif (!(newprof->attrtab = jas_iccattrtab_copy(prof->attrtab)))\n\t\tgoto error;\n\treturn newprof;\nerror:\n\tif (newprof)\n\t\tjas_iccprof_destroy(newprof);\n\treturn 0;\n}\n- JAS_IMAGE_CT_YCBCR_CB: #define\tJAS_IMAGE_CT_YCBCR_CB\t1 /* <=== src/libjasper/include/jasper/jas_image.h:117:117:JAS_IMAGE_CT_YCBCR_CB:0 */ \n- JAS_IMAGE_CT_COLOR: #define\tJAS_IMAGE_CT_COLOR(n)\t((n) & 0x7fff) /* <=== src/libjasper/include/jasper/jas_image.h:109:109:JAS_IMAGE_CT_COLOR:1 */ \n- jas_stream_fillbuf: int jas_stream_fillbuf(jas_stream_t *stream, int getflag) /* <=== jas_stream_fillbuf */ \n{\n\tint c;\n\n\t/* The stream must not be in an error or EOF state. */\n\tif ((stream->flags_ & (JAS_STREAM_ERRMASK)) != 0) {\n\t\treturn EOF;\n\t}\n\n\t/* The stream must be open for reading. */\n\tif ((stream->openmode_ & JAS_STREAM_READ) == 0) {\n\t\treturn EOF;\n\t}\n\n\t/* Make a half-hearted attempt to confirm that the buffer is not\n\tcurrently being used for writing.  This check is not intended\n\tto be foolproof! */\n\tassert((stream->bufmode_ & JAS_STREAM_WRBUF) == 0);\n\n\tassert(stream->ptr_ - stream->bufstart_ <= stream->bufsize_);\n\n\t/* Mark the buffer as being used for reading. */\n\tstream->bufmode_ |= JAS_STREAM_RDBUF;\n\n\t/* Read new data into the buffer. */\n\tstream->ptr_ = stream->bufstart_;\n\tif ((stream->cnt_ = (*stream->ops_->read_)(stream->obj_,\n\t  (char *) stream->bufstart_, stream->bufsize_)) <= 0) {\n\t\tif (stream->cnt_ < 0) {\n\t\t\tstream->flags_ |= JAS_STREAM_ERR;\n\t\t} else {\n\t\t\tstream->flags_ |= JAS_STREAM_EOF;\n\t\t}\n\t\tstream->cnt_ = 0;\n\t\treturn EOF;\n\t}\n\n\tassert(stream->cnt_ > 0);\n\t/* Get or peek at the first character in the buffer. */\n\tc = (getflag) ? jas_stream_getc2(stream) : (*stream->ptr_);\n\n\treturn c;\n}\n- jas_stream_destroy: static void jas_stream_destroy(jas_stream_t *stream) /* <=== jas_stream_destroy */ \n{\n\tJAS_DBGLOG(100, (\"jas_stream_destroy(%p)\\n\", stream));\n\n\t/* If the memory for the buffer was allocated with malloc, free\n\tthis memory. */\n\tif ((stream->bufmode_ & JAS_STREAM_FREEBUF) && stream->bufbase_) {\n\t\tJAS_DBGLOG(100, (\"jas_stream_destroy freeing buffer %p\\n\",\n\t\t  stream->bufbase_));\n\t\tjas_free(stream->bufbase_);\n\t\tstream->bufbase_ = 0;\n\t}\n\tjas_free(stream);\n}\n- JAS_CLRSPC_FAM_RGB: #define\tJAS_CLRSPC_FAM_RGB\t4 /* <=== src/libjasper/include/jasper/jas_cm.h:113:113:JAS_CLRSPC_FAM_RGB:0 */ \n- JP2_CDEF_TYPE_OPACITY: #define\tJP2_CDEF_TYPE_OPACITY\t1 /* <=== src/libjasper/jp2/jp2_cod.h:204:204:JP2_CDEF_TYPE_OPACITY:0 */ \n- jp2_boxinfolookup: static const jp2_boxinfo_t *jp2_boxinfolookup(int type) /* <=== jp2_boxinfolookup */ \n{\n\tconst jp2_boxinfo_t *boxinfo;\n\tfor (boxinfo = jp2_boxinfos; boxinfo->name; ++boxinfo) {\n\t\tif (boxinfo->type == type) {\n\t\t\treturn boxinfo;\n\t\t}\n\t}\n\treturn &jp2_boxinfo_unk;\n}\n- jas_deprecated: void jas_deprecated(const char *s) /* <=== jas_deprecated */ \n{\n\tstatic char message[] =\n\t\"WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!!\\n\"\n\t\"WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!!\\n\"\n\t\"WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!!\\n\"\n\t\"YOUR CODE IS RELYING ON DEPRECATED FUNCTIONALTIY IN THE JASPER LIBRARY.\\n\"\n\t\"THIS FUNCTIONALITY WILL BE REMOVED IN THE NEAR FUTURE.\\n\"\n\t\"PLEASE FIX THIS PROBLEM BEFORE YOUR CODE STOPS WORKING!\\n\"\n\t;\n\tjas_eprintf(\"%s\", message);\n\tjas_eprintf(\"The specific problem is as follows:\\n%s\\n\", s);\n\t//abort();\n}\n- jas_malloc: void *jas_malloc(size_t size) /* <=== jas_malloc */ \n{\n\tvoid *result;\n\tJAS_DBGLOG(101, (\"jas_malloc(%zu)\\n\", size));\n\tresult = malloc(size);\n\tJAS_DBGLOG(100, (\"jas_malloc(%zu) -> %p\\n\", size, result));\n\treturn result;\n}\n- jp2_putuint64: static int jp2_putuint64(jas_stream_t *out, uint_fast64_t val) /* <=== jp2_putuint64 */ \n{\n\tif (jp2_putuint32(out, (val >> 32) & 0xffffffffUL) ||\n\t  jp2_putuint32(out, val & 0xffffffffUL)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n- jas_alloc2: void *jas_alloc2(size_t num_elements, size_t element_size) /* <=== jas_alloc2 */ \n{\n\tsize_t size;\n\tif (!jas_safe_size_mul(num_elements, element_size, &size)) {\n\t\treturn 0;\n\t}\n\treturn jas_malloc(size);\n}\n- JP2_CDEF_RGB_R: #define JP2_CDEF_RGB_R\t1 /* <=== src/libjasper/jp2/jp2_cod.h:193:193:JP2_CDEF_RGB_R:0 */ \n- JP2_BOX_JP: #define\tJP2_BOX_JP\t\t0x6a502020\t/* Signature */ /* <=== src/libjasper/jp2/jp2_cod.h:94:94:JP2_BOX_JP:0 */ \n- JAS_CLRSPC_FAM_GRAY: #define\tJAS_CLRSPC_FAM_GRAY\t3 /* <=== src/libjasper/include/jasper/jas_cm.h:112:112:JAS_CLRSPC_FAM_GRAY:0 */ \n- JP2_CDEF_RGB_B: #define JP2_CDEF_RGB_B\t3 /* <=== src/libjasper/jp2/jp2_cod.h:195:195:JP2_CDEF_RGB_B:0 */ \n- jpc_enc_encodemainhdr: static int jpc_enc_encodemainhdr(jpc_enc_t *enc) /* <=== jpc_enc_encodemainhdr */ \n{\n\tjpc_siz_t *siz;\n\tjpc_cod_t *cod;\n\tjpc_qcd_t *qcd;\n\tint i;\nlong startoff;\nlong mainhdrlen;\n\tjpc_enc_cp_t *cp;\n\tjpc_qcc_t *qcc;\n\tjpc_enc_tccp_t *tccp;\n\tuint_fast16_t cmptno;\n\tjpc_tsfb_band_t bandinfos[JPC_MAXBANDS];\n\tjpc_fix_t mctsynweight;\n\tjpc_enc_tcp_t *tcp;\n\tjpc_tsfb_t *tsfb;\n\tjpc_tsfb_band_t *bandinfo;\n\tuint_fast16_t numbands;\n\tuint_fast16_t bandno;\n\tuint_fast16_t rlvlno;\n\tuint_fast16_t analgain;\n\tjpc_fix_t absstepsize;\n\tchar buf[1024];\n\tjpc_com_t *com;\n\n\tcp = enc->cp;\n\nstartoff = jas_stream_getrwcount(enc->out);\n\n\t/* Write SOC marker segment. */\n\tif (!(enc->mrk = jpc_ms_create(JPC_MS_SOC))) {\n\t\tjas_eprintf(\"cannot create SOC marker\\n\");\n\t\treturn -1;\n\t}\n\tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {\n\t\tjas_eprintf(\"cannot write SOC marker\\n\");\n\t\treturn -1;\n\t}\n\tjpc_ms_destroy(enc->mrk);\n\tenc->mrk = 0;\n\n\t/* Write SIZ marker segment. */\n\tif (!(enc->mrk = jpc_ms_create(JPC_MS_SIZ))) {\n\t\tjas_eprintf(\"cannot create SIZ marker\\n\");\n\t\treturn -1;\n\t}\n\tsiz = &enc->mrk->parms.siz;\n\tsiz->caps = 0;\n\tsiz->xoff = cp->imgareatlx;\n\tsiz->yoff = cp->imgareatly;\n\tsiz->width = cp->refgrdwidth;\n\tsiz->height = cp->refgrdheight;\n\tsiz->tilexoff = cp->tilegrdoffx;\n\tsiz->tileyoff = cp->tilegrdoffy;\n\tsiz->tilewidth = cp->tilewidth;\n\tsiz->tileheight = cp->tileheight;\n\tsiz->numcomps = cp->numcmpts;\n\tsiz->comps = jas_alloc2(siz->numcomps, sizeof(jpc_sizcomp_t));\n\tassert(siz->comps);\n\tfor (i = 0; i < JAS_CAST(int, cp->numcmpts); ++i) {\n\t\tsiz->comps[i].prec = cp->ccps[i].prec;\n\t\tsiz->comps[i].sgnd = cp->ccps[i].sgnd;\n\t\tsiz->comps[i].hsamp = cp->ccps[i].sampgrdstepx;\n\t\tsiz->comps[i].vsamp = cp->ccps[i].sampgrdstepy;\n\t}\n\tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {\n\t\tjas_eprintf(\"cannot write SIZ marker\\n\");\n\t\treturn -1;\n\t}\n\tjpc_ms_destroy(enc->mrk);\n\tenc->mrk = 0;\n\n\tif (!(enc->mrk = jpc_ms_create(JPC_MS_COM))) {\n\t\tjas_eprintf(\"cannot create COM marker\\n\");\n\t\treturn -1;\n\t}\n\tsprintf(buf, \"Creator: JasPer Version %s\", jas_getversion());\n\tcom = &enc->mrk->parms.com;\n\tcom->len = JAS_CAST(uint_fast16_t, strlen(buf));\n\tcom->regid = JPC_COM_LATIN;\n\tif (!(com->data = JAS_CAST(jas_uchar *, jas_strdup(buf)))) {\n\t\tabort();\n\t}\n\tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {\n\t\tjas_eprintf(\"cannot write COM marker\\n\");\n\t\treturn -1;\n\t}\n\tjpc_ms_destroy(enc->mrk);\n\tenc->mrk = 0;\n\n#if 0\n\tif (!(enc->mrk = jpc_ms_create(JPC_MS_CRG))) {\n\t\treturn -1;\n\t}\n\tcrg = &enc->mrk->parms.crg;\n\tcrg->comps = jas_alloc2(crg->numcomps, sizeof(jpc_crgcomp_t));\n\tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {\n\t\tjas_eprintf(\"cannot write CRG marker\\n\");\n\t\treturn -1;\n\t}\n\tjpc_ms_destroy(enc->mrk);\n\tenc->mrk = 0;\n#endif\n\n\ttcp = &cp->tcp;\n\ttccp = &cp->tccp;\n\tfor (cmptno = 0; cmptno < cp->numcmpts; ++cmptno) {\n\t\ttsfb = jpc_cod_gettsfb(tccp->qmfbid, tccp->maxrlvls - 1);\n\t\tjpc_tsfb_getbands(tsfb, 0, 0, 1 << tccp->maxrlvls, 1 << tccp->maxrlvls,\n\t\t  bandinfos);\n\t\tjpc_tsfb_destroy(tsfb);\n\t\tmctsynweight = jpc_mct_getsynweight(tcp->mctid, cmptno);\n\t\tnumbands = 3 * tccp->maxrlvls - 2;\n\t\tfor (bandno = 0, bandinfo = bandinfos; bandno < numbands;\n\t\t  ++bandno, ++bandinfo) {\n\t\t\trlvlno = (bandno) ? ((bandno - 1) / 3 + 1) : 0;\n\t\t\tanalgain = JPC_NOMINALGAIN(tccp->qmfbid, tccp->maxrlvls,\n\t\t\t  rlvlno, bandinfo->orient);\n\t\t\tif (!tcp->intmode) {\n\t\t\t\tabsstepsize = jpc_fix_div(jpc_inttofix(1 <<\n\t\t\t\t  (analgain + 1)), bandinfo->synenergywt);\n\t\t\t} else {\n\t\t\t\tabsstepsize = jpc_inttofix(1);\n\t\t\t}\t\n\t\t\tconst uint_fast32_t stepsize =\n\t\t\t  jpc_abstorelstepsize(absstepsize,\n\t\t\t  cp->ccps[cmptno].prec + analgain);\n\t\t\tif (stepsize == UINT_FAST32_MAX)\n\t\t\t\treturn -1;\n\t\t\tcp->ccps[cmptno].stepsizes[bandno] = stepsize;\n\t\t}\n\t\tcp->ccps[cmptno].numstepsizes = numbands;\n\t}\n\n\tif (!(enc->mrk = jpc_ms_create(JPC_MS_COD))) {\n\t\tjas_eprintf(\"cannot create COD marker\\n\");\n\t\treturn -1;\n\t}\n\tcod = &enc->mrk->parms.cod;\n\tcod->csty = cp->tccp.csty | cp->tcp.csty;\n\tcod->compparms.csty = cp->tccp.csty | cp->tcp.csty;\n\tcod->compparms.numdlvls = cp->tccp.maxrlvls - 1;\n\tcod->compparms.numrlvls = cp->tccp.maxrlvls;\n\tcod->prg = cp->tcp.prg;\n\tcod->numlyrs = cp->tcp.numlyrs;\n\tcod->compparms.cblkwidthval = JPC_COX_CBLKSIZEEXPN(cp->tccp.cblkwidthexpn);\n\tcod->compparms.cblkheightval = JPC_COX_CBLKSIZEEXPN(cp->tccp.cblkheightexpn);\n\tcod->compparms.cblksty = cp->tccp.cblksty;\n\tcod->compparms.qmfbid = cp->tccp.qmfbid;\n\tcod->mctrans = (cp->tcp.mctid != JPC_MCT_NONE);\n\tif (tccp->csty & JPC_COX_PRT) {\n\t\tfor (rlvlno = 0; rlvlno < tccp->maxrlvls; ++rlvlno) {\n\t\t\tcod->compparms.rlvls[rlvlno].parwidthval = tccp->prcwidthexpns[rlvlno];\n\t\t\tcod->compparms.rlvls[rlvlno].parheightval = tccp->prcheightexpns[rlvlno];\n\t\t}\n\t}\n\tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {\n\t\tjas_eprintf(\"cannot write COD marker\\n\");\n\t\treturn -1;\n\t}\n\tjpc_ms_destroy(enc->mrk);\n\tenc->mrk = 0;\n\n\tif (!(enc->mrk = jpc_ms_create(JPC_MS_QCD))) {\n\t\tjas_eprintf(\"cannot create QCD marker\\n\");\n\t\treturn -1;\n\t}\n\tqcd = &enc->mrk->parms.qcd;\n\tqcd->compparms.qntsty = (tccp->qmfbid == JPC_COX_INS) ?\n\t  JPC_QCX_SEQNT : JPC_QCX_NOQNT;\n\tqcd->compparms.numstepsizes = cp->ccps[0].numstepsizes;\n\tqcd->compparms.numguard = cp->tccp.numgbits;\n\tqcd->compparms.stepsizes = cp->ccps[0].stepsizes;\n\tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {\n\t\tjas_eprintf(\"cannot write marker\\n\");\n\t\treturn -1;\n\t}\n\t/* We do not want the step size array to be freed! */\n\tqcd->compparms.stepsizes = 0;\n\tjpc_ms_destroy(enc->mrk);\n\tenc->mrk = 0;\n\n\ttccp = &cp->tccp;\n\tfor (cmptno = 1; cmptno < cp->numcmpts; ++cmptno) {\n\t\tif (!(enc->mrk = jpc_ms_create(JPC_MS_QCC))) {\n\t\t\tjas_eprintf(\"cannot create QCC marker\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tqcc = &enc->mrk->parms.qcc;\n\t\tqcc->compno = cmptno;\n\t\tqcc->compparms.qntsty = (tccp->qmfbid == JPC_COX_INS) ?\n\t\t  JPC_QCX_SEQNT : JPC_QCX_NOQNT;\n\t\tqcc->compparms.numstepsizes = cp->ccps[cmptno].numstepsizes;\n\t\tqcc->compparms.numguard = cp->tccp.numgbits;\n\t\tqcc->compparms.stepsizes = cp->ccps[cmptno].stepsizes;\n\t\tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {\n\t\t\tjas_eprintf(\"cannot write marker\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\t/* We do not want the step size array to be freed! */\n\t\tqcc->compparms.stepsizes = 0;\n\t\tjpc_ms_destroy(enc->mrk);\n\t\tenc->mrk = 0;\n\t}\n\n#define MAINTLRLEN\t2\n\tmainhdrlen = jas_stream_getrwcount(enc->out) - startoff;\n\tenc->len += mainhdrlen;\n\tif (enc->cp->totalsize != UINT_FAST32_MAX) {\n\t\tuint_fast32_t overhead;\n\t\toverhead = mainhdrlen + MAINTLRLEN;\n\t\tenc->mainbodysize = (enc->cp->totalsize >= overhead) ?\n\t\t  (enc->cp->totalsize - overhead) : 0;\n\t} else {\n\t\tenc->mainbodysize = UINT_FAST32_MAX;\n\t}\n\n\treturn 0;\n}\n- JP2_BOX_NODATA: #define\tJP2_BOX_NODATA\t0x02 /* <=== src/libjasper/jp2/jp2_cod.h:115:115:JP2_BOX_NODATA:0 */ \n- JP2_COLR_PRI: #define\tJP2_COLR_PRI\t0 /* <=== src/libjasper/jp2/jp2_cod.h:166:166:JP2_COLR_PRI:0 */ \n- JP2_CDEF_TYPE_UNSPEC: #define\tJP2_CDEF_TYPE_UNSPEC\t65535 /* <=== src/libjasper/jp2/jp2_cod.h:205:205:JP2_CDEF_TYPE_UNSPEC:0 */ \n- JAS_DBGLOG: #define\tJAS_DBGLOG(n, x) \\ /* <=== src/libjasper/include/jasper/jas_debug.h:94:95:JAS_DBGLOG:2 */ \n\t((jas_getdbglevel() >= (n)) ? (jas_eprintf x) : 0)\n- jas_stream_flush: int jas_stream_flush(jas_stream_t *stream) /* <=== jas_stream_flush */ \n{\n\tif (stream->bufmode_ & JAS_STREAM_RDBUF) {\n\t\treturn 0;\n\t}\n\treturn jas_stream_flushbuf(stream, EOF);\n}\n- jas_stream_memopen: jas_stream_t *jas_stream_memopen(char *buf, int bufsize) /* <=== jas_stream_memopen */ \n{\n\tchar *new_buf;\n\tsize_t new_bufsize;\n\n\tJAS_DBGLOG(100, (\"jas_stream_memopen(%p, %d)\\n\", buf, bufsize));\n\tif (bufsize < 0) {\n\t\tjas_deprecated(\"negative buffer size for jas_stream_memopen\");\n\t}\n\tif (buf && bufsize <= 0) {\n\t\t// This was never a valid thing to do with the old API.\n\t\tjas_eprintf(\"Invalid use of jas_stream_memopen detected.\\n\");\n\t\tjas_deprecated(\"A user-provided buffer for \"\n\t\t  \"jas_stream_memopen cannot be growable.\\n\");\n\t}\n\tif (bufsize <= 0) {\n\t\tnew_bufsize = 0;\n\t\tnew_buf = 0;\n\t} else {\n\t\tnew_bufsize = bufsize;\n\t\tnew_buf = buf;\n\t}\n\treturn jas_stream_memopen2(new_buf, new_bufsize);\n}\n- jp2_box_create0: static jp2_box_t *jp2_box_create0(void) /* <=== jp2_box_create0 */ \n{\n\tjp2_box_t *box;\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\treturn 0;\n\t}\n\tmemset(box, 0, sizeof(jp2_box_t));\n\tbox->type = 0;\n\tbox->len = 0;\n\t// Mark the box data as never having been constructed\n\t// so that we will not errantly attempt to destroy it later.\n\tbox->ops = &jp2_boxinfo_unk.ops;\n\treturn box;\n}\n- JAS_CLRSPC_FAM_YCBCR: #define\tJAS_CLRSPC_FAM_YCBCR\t5 /* <=== src/libjasper/include/jasper/jas_cm.h:114:114:JAS_CLRSPC_FAM_YCBCR:0 */ \n- jas_iccprof_writehdr: static int jas_iccprof_writehdr(jas_stream_t *out, jas_icchdr_t *hdr) /* <=== jas_iccprof_writehdr */ \n{\n\tif (jas_iccputuint32(out, hdr->size) ||\n\t  jas_iccputuint32(out, hdr->cmmtype) ||\n\t  jas_iccputuint32(out, hdr->version) ||\n\t  jas_iccputuint32(out, hdr->clas) ||\n\t  jas_iccputuint32(out, hdr->colorspc) ||\n\t  jas_iccputuint32(out, hdr->refcolorspc) ||\n\t  jas_iccputtime(out, &hdr->ctime) ||\n\t  jas_iccputuint32(out, hdr->magic) ||\n\t  jas_iccputuint32(out, hdr->platform) ||\n\t  jas_iccputuint32(out, hdr->flags) ||\n\t  jas_iccputuint32(out, hdr->maker) ||\n\t  jas_iccputuint32(out, hdr->model) ||\n\t  jas_iccputuint64(out, hdr->attr) ||\n\t  jas_iccputuint32(out, hdr->intent) ||\n\t  jas_iccputxyz(out, &hdr->illum) ||\n\t  jas_iccputuint32(out, hdr->creator) ||\n\t  jas_stream_pad(out, 44, 0) != 44)\n\t\treturn -1;\n\treturn 0;\n}\n- jas_iccputuint32: #define\tjas_iccputuint32(out, val)\tjas_iccputuint(out, 4, val) /* <=== src/libjasper/base/jas_icc.c:77:77:jas_iccputuint32:2 */ \n- JP2_BOX_IHDR: #define\tJP2_BOX_IHDR\t0x69686472\t/* Image Header */ /* <=== src/libjasper/jp2/jp2_cod.h:97:97:JP2_BOX_IHDR:0 */ \n- cp_create: static jpc_enc_cp_t *cp_create(const char *optstr, jas_image_t *image) /* <=== cp_create */ \n{\n\tjpc_enc_cp_t *cp;\n\tjas_tvparser_t *tvp;\n\tint ret;\n\tint numilyrrates;\n\tdouble *ilyrrates;\n\tint i;\n\tint tagid;\n\tjpc_enc_tcp_t *tcp;\n\tjpc_enc_tccp_t *tccp;\n\tjpc_enc_ccp_t *ccp;\n\tint cmptno;\n\tuint_fast16_t rlvlno;\n\tuint_fast16_t prcwidthexpn;\n\tuint_fast16_t prcheightexpn;\n\tbool enablemct;\n\tuint_fast32_t jp2overhead;\n\tuint_fast16_t lyrno;\n\tuint_fast32_t hsteplcm;\n\tuint_fast32_t vsteplcm;\n\tbool mctvalid;\n\n\ttvp = 0;\n\tcp = 0;\n\tilyrrates = 0;\n\tnumilyrrates = 0;\n\n\tif (!(cp = jas_malloc(sizeof(jpc_enc_cp_t)))) {\n\t\tgoto error;\n\t}\n\n\tprcwidthexpn = 15;\n\tprcheightexpn = 15;\n\tenablemct = true;\n\tjp2overhead = 0;\n\n\tcp->ccps = 0;\n\tcp->debug = 0;\n\tcp->imgareatlx = UINT_FAST32_MAX;\n\tcp->imgareatly = UINT_FAST32_MAX;\n\tcp->refgrdwidth = 0;\n\tcp->refgrdheight = 0;\n\tcp->tilegrdoffx = UINT_FAST32_MAX;\n\tcp->tilegrdoffy = UINT_FAST32_MAX;\n\tcp->tilewidth = 0;\n\tcp->tileheight = 0;\n\tcp->numcmpts = jas_image_numcmpts(image);\n\n\thsteplcm = 1;\n\tvsteplcm = 1;\n\tfor (cmptno = 0; cmptno < jas_image_numcmpts(image); ++cmptno) {\n\t\tif (jas_image_cmptbrx(image, cmptno) + jas_image_cmpthstep(image, cmptno) <=\n\t\t  jas_image_brx(image) || jas_image_cmptbry(image, cmptno) +\n\t\t  jas_image_cmptvstep(image, cmptno) <= jas_image_bry(image)) {\n\t\t\tjas_eprintf(\"unsupported image type\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\t/* Note: We ought to be calculating the LCMs here.  Fix some day. */\n\t\thsteplcm *= jas_image_cmpthstep(image, cmptno);\n\t\tvsteplcm *= jas_image_cmptvstep(image, cmptno);\n\t}\n\n\tif (!(cp->ccps = jas_alloc2(cp->numcmpts, sizeof(jpc_enc_ccp_t)))) {\n\t\tgoto error;\n\t}\n\tfor (cmptno = 0, ccp = cp->ccps; cmptno < JAS_CAST(int, cp->numcmpts); ++cmptno,\n\t  ++ccp) {\n\t\tccp->sampgrdstepx = jas_image_cmpthstep(image, cmptno);\n\t\tccp->sampgrdstepy = jas_image_cmptvstep(image, cmptno);\n\t\t/* XXX - this isn't quite correct for more general image */\n\t\tccp->sampgrdsubstepx = 0;\n\t\tccp->sampgrdsubstepx = 0;\n\t\tccp->prec = jas_image_cmptprec(image, cmptno);\n\t\tccp->sgnd = jas_image_cmptsgnd(image, cmptno);\n\t\tccp->numstepsizes = 0;\n\t\tmemset(ccp->stepsizes, 0, sizeof(ccp->stepsizes));\n\t}\n\n\tcp->rawsize = jas_image_rawsize(image);\n\tcp->totalsize = UINT_FAST32_MAX;\n\n\ttcp = &cp->tcp;\n\ttcp->csty = 0;\n\ttcp->intmode = true;\n\ttcp->prg = JPC_COD_LRCPPRG;\n\ttcp->numlyrs = 1;\n\ttcp->ilyrrates = 0;\n\n\ttccp = &cp->tccp;\n\ttccp->csty = 0;\n\ttccp->maxrlvls = 6;\n\ttccp->cblkwidthexpn = 6;\n\ttccp->cblkheightexpn = 6;\n\ttccp->cblksty = 0;\n\ttccp->numgbits = 2;\n\n\tif (!(tvp = jas_tvparser_create(optstr ? optstr : \"\"))) {\n\t\tgoto error;\n\t}\n\n\twhile (!(ret = jas_tvparser_next(tvp))) {\n\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(encopts,\n\t\t  jas_tvparser_gettag(tvp)))->id) {\n\t\tcase OPT_DEBUG:\n\t\t\tcp->debug = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_IMGAREAOFFX:\n\t\t\tcp->imgareatlx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_IMGAREAOFFY:\n\t\t\tcp->imgareatly = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEGRDOFFX:\n\t\t\tcp->tilegrdoffx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEGRDOFFY:\n\t\t\tcp->tilegrdoffy = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEWIDTH:\n\t\t\tcp->tilewidth = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEHEIGHT:\n\t\t\tcp->tileheight = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_PRCWIDTH:\n\t\t\tprcwidthexpn = jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_PRCHEIGHT:\n\t\t\tprcheightexpn = jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_CBLKWIDTH:\n\t\t\ttccp->cblkwidthexpn =\n\t\t\t  jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_CBLKHEIGHT:\n\t\t\ttccp->cblkheightexpn =\n\t\t\t  jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_MODE:\n\t\t\tif ((tagid = jas_taginfo_nonull(jas_taginfos_lookup(modetab,\n\t\t\t  jas_tvparser_getval(tvp)))->id) < 0) {\n\t\t\t\tjas_eprintf(\"ignoring invalid mode %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t} else {\n\t\t\t\ttcp->intmode = (tagid == MODE_INT);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_PRG:\n\t\t\tif ((tagid = jas_taginfo_nonull(jas_taginfos_lookup(prgordtab,\n\t\t\t  jas_tvparser_getval(tvp)))->id) < 0) {\n\t\t\t\tjas_eprintf(\"ignoring invalid progression order %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t} else {\n\t\t\t\ttcp->prg = tagid;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_NOMCT:\n\t\t\tenablemct = false;\n\t\t\tbreak;\n\t\tcase OPT_MAXRLVLS:\n\t\t\ttccp->maxrlvls = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_SOP:\n\t\t\tcp->tcp.csty |= JPC_COD_SOP;\n\t\t\tbreak;\n\t\tcase OPT_EPH:\n\t\t\tcp->tcp.csty |= JPC_COD_EPH;\n\t\t\tbreak;\n\t\tcase OPT_LAZY:\n\t\t\ttccp->cblksty |= JPC_COX_LAZY;\n\t\t\tbreak;\n\t\tcase OPT_TERMALL:\n\t\t\ttccp->cblksty |= JPC_COX_TERMALL;\n\t\t\tbreak;\n\t\tcase OPT_SEGSYM:\n\t\t\ttccp->cblksty |= JPC_COX_SEGSYM;\n\t\t\tbreak;\n\t\tcase OPT_VCAUSAL:\n\t\t\ttccp->cblksty |= JPC_COX_VSC;\n\t\t\tbreak;\n\t\tcase OPT_RESET:\n\t\t\ttccp->cblksty |= JPC_COX_RESET;\n\t\t\tbreak;\n\t\tcase OPT_PTERM:\n\t\t\ttccp->cblksty |= JPC_COX_PTERM;\n\t\t\tbreak;\n\t\tcase OPT_NUMGBITS:\n\t\t\tcp->tccp.numgbits = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_RATE:\n\t\t\tif (ratestrtosize(jas_tvparser_getval(tvp), cp->rawsize,\n\t\t\t  &cp->totalsize)) {\n\t\t\t\tjas_eprintf(\"ignoring bad rate specifier %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_ILYRRATES:\n\t\t\tif (jpc_atoaf(jas_tvparser_getval(tvp), &numilyrrates,\n\t\t\t  &ilyrrates)) {\n\t\t\t\tjas_eprintf(\"warning: invalid intermediate layer rates specifier ignored (%s)\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase OPT_JP2OVERHEAD:\n\t\t\tjp2overhead = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tjas_eprintf(\"warning: ignoring invalid option %s\\n\",\n\t\t\t jas_tvparser_gettag(tvp));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tjas_tvparser_destroy(tvp);\n\ttvp = 0;\n\n\tif (cp->totalsize != UINT_FAST32_MAX) {\n\t\tcp->totalsize = (cp->totalsize > jp2overhead) ?\n\t\t  (cp->totalsize - jp2overhead) : 0;\n\t}\n\n\tif (cp->imgareatlx == UINT_FAST32_MAX) {\n\t\tcp->imgareatlx = 0;\n\t} else {\n\t\tif (hsteplcm != 1) {\n\t\t\tjas_eprintf(\"warning: overriding imgareatlx value\\n\");\n\t\t}\n\t\tcp->imgareatlx *= hsteplcm;\n\t}\n\tif (cp->imgareatly == UINT_FAST32_MAX) {\n\t\tcp->imgareatly = 0;\n\t} else {\n\t\tif (vsteplcm != 1) {\n\t\t\tjas_eprintf(\"warning: overriding imgareatly value\\n\");\n\t\t}\n\t\tcp->imgareatly *= vsteplcm;\n\t}\n\tcp->refgrdwidth = cp->imgareatlx + jas_image_width(image);\n\tcp->refgrdheight = cp->imgareatly + jas_image_height(image);\n\tif (cp->tilegrdoffx == UINT_FAST32_MAX) {\n\t\tcp->tilegrdoffx = cp->imgareatlx;\n\t}\n\tif (cp->tilegrdoffy == UINT_FAST32_MAX) {\n\t\tcp->tilegrdoffy = cp->imgareatly;\n\t}\n\tif (!cp->tilewidth) {\n\t\tcp->tilewidth = cp->refgrdwidth - cp->tilegrdoffx;\n\t}\n\tif (!cp->tileheight) {\n\t\tcp->tileheight = cp->refgrdheight - cp->tilegrdoffy;\n\t}\n\n\tif (cp->numcmpts == 3) {\n\t\tmctvalid = true;\n\t\tfor (cmptno = 0; cmptno < jas_image_numcmpts(image); ++cmptno) {\n\t\t\tif (jas_image_cmptprec(image, cmptno) != jas_image_cmptprec(image, 0) ||\n\t\t\t  jas_image_cmptsgnd(image, cmptno) != jas_image_cmptsgnd(image, 0) ||\n\t\t\t  jas_image_cmptwidth(image, cmptno) != jas_image_cmptwidth(image, 0) ||\n\t\t\t  jas_image_cmptheight(image, cmptno) != jas_image_cmptheight(image, 0)) {\n\t\t\t\tmctvalid = false;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tmctvalid = false;\n\t}\n\tif (mctvalid && enablemct && jas_clrspc_fam(jas_image_clrspc(image)) != JAS_CLRSPC_FAM_RGB) {\n\t\tjas_eprintf(\"warning: color space apparently not RGB\\n\");\n\t}\n\tif (mctvalid && enablemct && jas_clrspc_fam(jas_image_clrspc(image)) == JAS_CLRSPC_FAM_RGB) {\n\t\ttcp->mctid = (tcp->intmode) ? (JPC_MCT_RCT) : (JPC_MCT_ICT);\n\t} else {\n\t\ttcp->mctid = JPC_MCT_NONE;\n\t}\n\ttccp->qmfbid = (tcp->intmode) ? (JPC_COX_RFT) : (JPC_COX_INS);\n\n\tfor (rlvlno = 0; rlvlno < tccp->maxrlvls; ++rlvlno) {\n\t\ttccp->prcwidthexpns[rlvlno] = prcwidthexpn;\n\t\ttccp->prcheightexpns[rlvlno] = prcheightexpn;\n\t}\n\tif (prcwidthexpn != 15 || prcheightexpn != 15) {\n\t\ttccp->csty |= JPC_COX_PRT;\n\t}\n\n\t/* Ensure that the tile width and height is valid. */\n\tif (!cp->tilewidth) {\n\t\tjas_eprintf(\"invalid tile width %lu\\n\", (unsigned long)\n\t\t  cp->tilewidth);\n\t\tgoto error;\n\t}\n\tif (!cp->tileheight) {\n\t\tjas_eprintf(\"invalid tile height %lu\\n\", (unsigned long)\n\t\t  cp->tileheight);\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the tile grid offset is valid. */\n\tif (cp->tilegrdoffx > cp->imgareatlx ||\n\t  cp->tilegrdoffy > cp->imgareatly ||\n\t  cp->tilegrdoffx + cp->tilewidth < cp->imgareatlx ||\n\t  cp->tilegrdoffy + cp->tileheight < cp->imgareatly) {\n\t\tjas_eprintf(\"invalid tile grid offset (%lu, %lu)\\n\",\n\t\t  (unsigned long) cp->tilegrdoffx, (unsigned long)\n\t\t  cp->tilegrdoffy);\n\t\tgoto error;\n\t}\n\n\tcp->numhtiles = JPC_CEILDIV(cp->refgrdwidth - cp->tilegrdoffx,\n\t  cp->tilewidth);\n\tcp->numvtiles = JPC_CEILDIV(cp->refgrdheight - cp->tilegrdoffy,\n\t  cp->tileheight);\n\tcp->numtiles = cp->numhtiles * cp->numvtiles;\n\n\tif (ilyrrates && numilyrrates > 0) {\n\t\ttcp->numlyrs = numilyrrates + 1;\n\t\tif (!(tcp->ilyrrates = jas_alloc2((tcp->numlyrs - 1),\n\t\t  sizeof(jpc_fix_t)))) {\n\t\t\tgoto error;\n\t\t}\n\t\tfor (i = 0; i < JAS_CAST(int, tcp->numlyrs - 1); ++i) {\n\t\t\ttcp->ilyrrates[i] = jpc_dbltofix(ilyrrates[i]);\n\t\t}\n\t}\n\n\t/* Ensure that the integer mode is used in the case of lossless\n\t  coding. */\n\tif (cp->totalsize == UINT_FAST32_MAX && (!cp->tcp.intmode)) {\n\t\tjas_eprintf(\"cannot use real mode for lossless coding\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the precinct width is valid. */\n\tif (prcwidthexpn > 15) {\n\t\tjas_eprintf(\"invalid precinct width\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the precinct height is valid. */\n\tif (prcheightexpn > 15) {\n\t\tjas_eprintf(\"invalid precinct height\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the code block width is valid. */\n\tif (cp->tccp.cblkwidthexpn < 2 || cp->tccp.cblkwidthexpn > 12) {\n\t\tjas_eprintf(\"invalid code block width %d\\n\",\n\t\t  JPC_POW2(cp->tccp.cblkwidthexpn));\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the code block height is valid. */\n\tif (cp->tccp.cblkheightexpn < 2 || cp->tccp.cblkheightexpn > 12) {\n\t\tjas_eprintf(\"invalid code block height %d\\n\",\n\t\t  JPC_POW2(cp->tccp.cblkheightexpn));\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the code block size is not too large. */\n\tif (cp->tccp.cblkwidthexpn + cp->tccp.cblkheightexpn > 12) {\n\t\tjas_eprintf(\"code block size too large\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the number of layers is valid. */\n\tif (cp->tcp.numlyrs > 16384) {\n\t\tjas_eprintf(\"too many layers\\n\");\n\t\tgoto error;\n\t}\n\n\t/* There must be at least one resolution level. */\n\tif (cp->tccp.maxrlvls < 1) {\n\t\tjas_eprintf(\"must be at least one resolution level\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the number of guard bits is valid. */\n\tif (cp->tccp.numgbits > 8) {\n\t\tjas_eprintf(\"invalid number of guard bits\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that the rate is within the legal range. */\n\tif (cp->totalsize != UINT_FAST32_MAX && cp->totalsize > cp->rawsize) {\n\t\tjas_eprintf(\"warning: specified rate is unreasonably large (%lu > %lu)\\n\", (unsigned long) cp->totalsize, (unsigned long) cp->rawsize);\n\t}\n\n\t/* Ensure that the intermediate layer rates are valid. */\n\tif (tcp->numlyrs > 1) {\n\t\t/* The intermediate layers rates must increase monotonically. */\n\t\tfor (lyrno = 0; lyrno + 2 < tcp->numlyrs; ++lyrno) {\n\t\t\tif (tcp->ilyrrates[lyrno] >= tcp->ilyrrates[lyrno + 1]) {\n\t\t\t\tjas_eprintf(\"intermediate layer rates must increase monotonically\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\t/* The intermediate layer rates must be less than the overall rate. */\n\t\tif (cp->totalsize != UINT_FAST32_MAX) {\n\t\t\tfor (lyrno = 0; lyrno < tcp->numlyrs - 1; ++lyrno) {\n\t\t\t\tif (jpc_fixtodbl(tcp->ilyrrates[lyrno]) > ((double) cp->totalsize)\n\t\t\t\t  / cp->rawsize) {\n\t\t\t\t\tjas_eprintf(\"warning: intermediate layer rates must be less than overall rate\\n\");\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ilyrrates) {\n\t\tjas_free(ilyrrates);\n\t}\n\n\treturn cp;\n\nerror:\n\n\tif (ilyrrates) {\n\t\tjas_free(ilyrrates);\n\t}\n\tif (tvp) {\n\t\tjas_tvparser_destroy(tvp);\n\t}\n\tif (cp) {\n\t\tjpc_enc_cp_destroy(cp);\n\t}\n\treturn 0;\n}\n- JP2_CDEF_ASOC_ALL: #define\tJP2_CDEF_ASOC_ALL\t0 /* <=== src/libjasper/jp2/jp2_cod.h:206:206:JP2_CDEF_ASOC_ALL:0 */ \n- jpc_enc_destroy: void jpc_enc_destroy(jpc_enc_t *enc) /* <=== jpc_enc_destroy */ \n{\n\t/* The image object (i.e., enc->image) and output stream object\n\t(i.e., enc->out) are created outside of the encoder.\n\tTherefore, they must not be destroyed here. */\n\n\tif (enc->curtile) {\n\t\tjpc_enc_tile_destroy(enc->curtile);\n\t}\n\tif (enc->cp) {\n\t\tjpc_enc_cp_destroy(enc->cp);\n\t}\n\tif (enc->cstate) {\n\t\tjpc_cstate_destroy(enc->cstate);\n\t}\n\tif (enc->tmpstream) {\n\t\tjas_stream_close(enc->tmpstream);\n\t}\n\n\tjas_free(enc);\n}\n- jas_image_cmptsgnd: #define\tjas_image_cmptsgnd(image, cmptno) \\ /* <=== src/libjasper/include/jasper/jas_image.h:375:376:jas_image_cmptsgnd:2 */ \n\t((image)->cmpts_[cmptno]->sgnd_)\n- jas_image_width: #define jas_image_width(image) \\ /* <=== src/libjasper/include/jasper/jas_image.h:322:323:jas_image_width:1 */ \n\t((image)->brx_ - (image)->tlx_)\n- JAS_IMAGE_CT_RGB_R: #define\tJAS_IMAGE_CT_RGB_R\t0 /* <=== src/libjasper/include/jasper/jas_image.h:112:112:JAS_IMAGE_CT_RGB_R:0 */ \n- jas_stream_close: int jas_stream_close(jas_stream_t *stream) /* <=== jas_stream_close */ \n{\n\tJAS_DBGLOG(100, (\"jas_stream_close(%p)\\n\", stream));\n\n\t/* Flush buffer if necessary. */\n\tjas_stream_flush(stream);\n\n\t/* Close the underlying stream object. */\n\t(*stream->ops_->close_)(stream->obj_);\n\n\tjas_stream_destroy(stream);\n\n\treturn 0;\n}\n- jas_getdbglevel: int jas_getdbglevel() /* <=== jas_getdbglevel */ \n{\n\treturn jas_dbglevel;\n}\n- jas_iccprof_puttagtab: static int jas_iccprof_puttagtab(jas_stream_t *out, jas_icctagtab_t *tagtab) /* <=== jas_iccprof_puttagtab */ \n{\n\tint i;\n\tjas_icctagtabent_t *tagtabent;\n\tif (jas_iccputuint32(out, tagtab->numents))\n\t\tgoto error;\n\tfor (i = 0; i < JAS_CAST(int, tagtab->numents); ++i) {\n\t\ttagtabent = &tagtab->ents[i];\n\t\tif (jas_iccputuint32(out, tagtabent->tag) ||\n\t\t  jas_iccputuint32(out, tagtabent->off) ||\n\t\t  jas_iccputuint32(out, tagtabent->len))\n\t\t\tgoto error;\n\t}\n\treturn 0;\nerror:\n\treturn -1;\n}\n- JAS_STREAM_WRBUF: #define JAS_STREAM_WRBUF\t0x0020 /* <=== src/libjasper/include/jasper/jas_stream.h:138:138:JAS_STREAM_WRBUF:0 */ \n- jas_iccattrtab_destroy: static void jas_iccattrtab_destroy(jas_iccattrtab_t *tab) /* <=== jas_iccattrtab_destroy */ \n{\n\tif (tab->attrs) {\n\t\twhile (tab->numattrs > 0) {\n\t\t\tjas_iccattrtab_delete(tab, 0);\n\t\t}\n\t\tjas_free(tab->attrs);\n\t}\n\tjas_free(tab);\n}\n- jas_image_clrspc: #define\tjas_image_clrspc(image) \\ /* <=== src/libjasper/include/jasper/jas_image.h:354:355:jas_image_clrspc:1 */ \n\t((image)->clrspc_)\n- JP2_CDEF_TYPE_COLOR: #define\tJP2_CDEF_TYPE_COLOR\t0 /* <=== src/libjasper/jp2/jp2_cod.h:203:203:JP2_CDEF_TYPE_COLOR:0 */ \n- jas_iccputuint: static int jas_iccputuint(jas_stream_t *out, int n, jas_ulonglong val) /* <=== jas_iccputuint */ \n{\n\tint i;\n\tint c;\n\tfor (i = n; i > 0; --i) {\n\t\tc = (val >> (8 * (i - 1))) & 0xff;\n\t\tif (jas_stream_putc(out, c) == EOF)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n- jas_stream_memopen2: jas_stream_t *jas_stream_memopen2(char *buf, size_t bufsize) /* <=== jas_stream_memopen2 */ \n{\n\tjas_stream_t *stream;\n\tjas_stream_memobj_t *obj;\n\n\tJAS_DBGLOG(100, (\"jas_stream_memopen2(%p, %zu)\\n\", buf, bufsize));\n\n\tassert((buf && bufsize > 0) || (!buf));\n\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* A stream associated with a memory buffer is always opened\n\tfor both reading and writing in binary mode. */\n\tstream->openmode_ = JAS_STREAM_READ | JAS_STREAM_WRITE | JAS_STREAM_BINARY;\n\n\t/* Since the stream data is already resident in memory, buffering\n\tis not necessary. */\n\t/* But... It still may be faster to use buffering anyways. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\t/* Select the operations for a memory stream. */\n\tstream->ops_ = &jas_stream_memops;\n\n\t/* Allocate memory for the underlying memory stream object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_memobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tstream->obj_ = (void *) obj;\n\n\t/* Initialize a few important members of the memory stream object. */\n\tobj->myalloc_ = 0;\n\tobj->buf_ = 0;\n\n\t/* If the buffer size specified is nonpositive, then the buffer\n\tis allocated internally and automatically grown as needed. */\n\tif (!bufsize) {\n\t\tobj->bufsize_ = 1024;\n\t\tobj->growable_ = 1;\n\t} else {\n\t\tobj->bufsize_ = bufsize;\n\t\tobj->growable_ = 0;\n\t}\n\tif (buf) {\n\t\tobj->buf_ = JAS_CAST(unsigned char *, buf);\n\t} else {\n\t\tobj->buf_ = jas_malloc(obj->bufsize_);\n\t\tobj->myalloc_ = 1;\n\t}\n\tif (!obj->buf_) {\n\t\tjas_stream_close(stream);\n\t\treturn 0;\n\t}\n\tJAS_DBGLOG(100, (\"jas_stream_memopen2 buffer buf=%p myalloc=%d\\n\",\n\t  obj->buf_, obj->myalloc_));\n\n\tif (bufsize > 0 && buf) {\n\t\t/* If a buffer was supplied by the caller and its length is positive,\n\t\t  make the associated buffer data appear in the stream initially. */\n\t\tobj->len_ = bufsize;\n\t} else {\n\t\t/* The stream is initially empty. */\n\t\tobj->len_ = 0;\n\t}\n\tobj->pos_ = 0;\n\t\n\treturn stream;\n}\n- jas_image_height: #define\tjas_image_height(image) \\ /* <=== src/libjasper/include/jasper/jas_image.h:326:327:jas_image_height:1 */ \n\t((image)->bry_ - (image)->tly_)\n- jas_iccprof_save: int jas_iccprof_save(jas_iccprof_t *prof, jas_stream_t *out) /* <=== jas_iccprof_save */ \n{\n\tlong curoff;\n\tlong reloff;\n\tlong newoff;\n\tint i;\n\tint j;\n\tjas_icctagtabent_t *tagtabent;\n\tjas_icctagtabent_t *sharedtagtabent;\n\tjas_icctagtabent_t *tmptagtabent;\n\tjas_iccuint32_t attrname;\n\tjas_iccattrval_t *attrval;\n\tjas_icctagtab_t *tagtab;\n\n\ttagtab = &prof->tagtab;\n\tif (!(tagtab->ents = jas_alloc2(prof->attrtab->numattrs,\n\t  sizeof(jas_icctagtabent_t))))\n\t\tgoto error;\n\ttagtab->numents = prof->attrtab->numattrs;\n\tcuroff = JAS_ICC_HDRLEN + 4 + 12 * tagtab->numents;\n\tfor (i = 0; i < JAS_CAST(int, tagtab->numents); ++i) {\n\t\ttagtabent = &tagtab->ents[i];\n\t\tif (jas_iccattrtab_get(prof->attrtab, i, &attrname, &attrval))\n\t\t\tgoto error;\n\t\tassert(attrval->ops->output);\n\t\ttagtabent->tag = attrname;\n\t\ttagtabent->data = &attrval->data;\n\t\tsharedtagtabent = 0;\n\t\tfor (j = 0; j < i; ++j) {\n\t\t\ttmptagtabent = &tagtab->ents[j];\n\t\t\tif (tagtabent->data == tmptagtabent->data) {\n\t\t\t\tsharedtagtabent = tmptagtabent;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (sharedtagtabent) {\n\t\t\ttagtabent->off = sharedtagtabent->off;\n\t\t\ttagtabent->len = sharedtagtabent->len;\n\t\t\ttagtabent->first = sharedtagtabent;\n\t\t} else {\n\t\t\ttagtabent->off = curoff;\n\t\t\ttagtabent->len = (*attrval->ops->getsize)(attrval) + 8;\n\t\t\ttagtabent->first = 0;\n\t\t\tif (i < JAS_CAST(int, tagtab->numents - 1)) {\n\t\t\t\tcuroff = jas_iccpadtomult(curoff + tagtabent->len, 4);\n\t\t\t} else {\n\t\t\t\tcuroff += tagtabent->len;\n\t\t\t}\n\t\t}\n\t\tjas_iccattrval_destroy(attrval);\n\t}\n\tprof->hdr.size = curoff;\n\tif (jas_iccprof_writehdr(out, &prof->hdr))\n\t\tgoto error;\n\tif (jas_iccprof_puttagtab(out, &prof->tagtab))\n\t\tgoto error;\n\tcuroff = JAS_ICC_HDRLEN + 4 + 12 * tagtab->numents;\n\tfor (i = 0; i < JAS_CAST(int, tagtab->numents);) {\n\t\ttagtabent = &tagtab->ents[i];\n\t\tassert(curoff == JAS_CAST(long, tagtabent->off));\n\t\tif (jas_iccattrtab_get(prof->attrtab, i, &attrname, &attrval))\n\t\t\tgoto error;\n\t\tif (jas_iccputuint32(out, attrval->type) || jas_stream_pad(out,\n\t\t  4, 0) != 4)\n\t\t\tgoto error;\n\t\tif ((*attrval->ops->output)(attrval, out))\n\t\t\tgoto error;\n\t\tjas_iccattrval_destroy(attrval);\n\t\tcuroff += tagtabent->len;\n\t\t++i;\n\t\twhile (i < JAS_CAST(int, tagtab->numents) &&\n\t\t  tagtab->ents[i].first)\n\t\t\t++i;\n\t\tnewoff = (i < JAS_CAST(int, tagtab->numents)) ?\n\t\t  tagtab->ents[i].off : prof->hdr.size;\n\t\treloff = newoff - curoff;\n\t\tassert(reloff >= 0);\n\t\tif (reloff > 0) {\n\t\t\tif (jas_stream_pad(out, reloff, 0) != reloff)\n\t\t\t\tgoto error;\n\t\t\tcuroff += reloff;\n\t\t}\n\t}\t\n\treturn 0;\nerror:\n\t/* XXX - need to free some resources here */\n\treturn -1;\n}\n- JP2_CDEF_GRAY_Y: #define\tJP2_CDEF_GRAY_Y\t1 /* <=== src/libjasper/jp2/jp2_cod.h:201:201:JP2_CDEF_GRAY_Y:0 */ \n- JAS_IMAGE_CT_RGB_G: #define\tJAS_IMAGE_CT_RGB_G\t1 /* <=== src/libjasper/include/jasper/jas_image.h:113:113:JAS_IMAGE_CT_RGB_G:0 */ \n- jas_stream_getc: #define jas_stream_getc(stream)\tjas_stream_getc_macro(stream) /* <=== src/libjasper/include/jasper/jas_stream.h:351:351:jas_stream_getc:1 */ \n- jp2_box_put: int jp2_box_put(jp2_box_t *box, jas_stream_t *out) /* <=== jp2_box_put */ \n{\n\tjas_stream_t *tmpstream;\n\tbool extlen;\n\tbool dataflag;\n\n\ttmpstream = 0;\n\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (box->ops->putdata) {\n\t\t\tif ((*box->ops->putdata)(box, tmpstream)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tbox->len = jas_stream_tell(tmpstream) + JP2_BOX_HDRLEN(false);\n\t\tjas_stream_rewind(tmpstream);\n\t}\n\textlen = (box->len >= (((uint_fast64_t)1) << 32)) != 0;\n\tif (jp2_putuint32(out, extlen ? 1 : box->len)) {\n\t\tgoto error;\n\t}\n\tif (jp2_putuint32(out, box->type)) {\n\t\tgoto error;\n\t}\n\tif (extlen) {\n\t\tif (jp2_putuint64(out, box->len)) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (dataflag) {\n\t\tif (jas_stream_copy(out, tmpstream, box->len -\n\t\t  JP2_BOX_HDRLEN(false))) {\n\t\t\tjas_eprintf(\"cannot copy box data\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\treturn 0;\n\nerror:\n\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn -1;\n}\n- jas_free: void jas_free(void *ptr) /* <=== jas_free */ \n{\n\tJAS_DBGLOG(100, (\"jas_free(%p)\\n\", ptr));\n\tfree(ptr);\n}\n- jpc_enc_cp_destroy: void jpc_enc_cp_destroy(jpc_enc_cp_t *cp) /* <=== jpc_enc_cp_destroy */ \n{\n\tif (cp->ccps) {\n\t\tif (cp->tcp.ilyrrates) {\n\t\t\tjas_free(cp->tcp.ilyrrates);\n\t\t}\n\t\tjas_free(cp->ccps);\n\t}\n\tjas_free(cp);\n}\n- JAS_CAST: #define\tJAS_CAST(t, e) \\ /* <=== src/libjasper/include/jasper/jas_types.h:144:145:JAS_CAST:2 */ \n\t((t) (e))\n- jas_iccprof_destroy: void jas_iccprof_destroy(jas_iccprof_t *prof) /* <=== jas_iccprof_destroy */ \n{\n\tif (prof->attrtab)\n\t\tjas_iccattrtab_destroy(prof->attrtab);\n\tif (prof->tagtab.ents)\n\t\tjas_free(prof->tagtab.ents);\n\tjas_free(prof);\n}\n- JAS_STREAM_RDBUF: #define JAS_STREAM_RDBUF\t0x0010 /* <=== src/libjasper/include/jasper/jas_stream.h:136:136:JAS_STREAM_RDBUF:0 */ \n- jpc_enc_create: jpc_enc_t *jpc_enc_create(jpc_enc_cp_t *cp, jas_stream_t *out, jas_image_t *image) /* <=== jpc_enc_create */ \n{\n\tjpc_enc_t *enc;\n\n\tenc = 0;\n\n\tif (!(enc = jas_malloc(sizeof(jpc_enc_t)))) {\n\t\tgoto error;\n\t}\n\n\tenc->image = image;\n\tenc->out = out;\n\tenc->cp = cp;\n\tenc->cstate = 0;\n\tenc->tmpstream = 0;\n\tenc->mrk = 0;\n\tenc->curtile = 0;\n\n\tif (!(enc->cstate = jpc_cstate_create())) {\n\t\tgoto error;\n\t}\n\tenc->len = 0;\n\tenc->mainbodysize = 0;\n\n\treturn enc;\n\nerror:\n\n\tif (enc) {\n\t\tjpc_enc_destroy(enc);\n\t}\n\treturn 0;\n}\n- jas_image_cmpttype: #define jas_image_cmpttype(image, cmptno) \\ /* <=== src/libjasper/include/jasper/jas_image.h:361:362:jas_image_cmpttype:2 */ \n\t((image)->cmpts_[(cmptno)]->type_)\n- jas_stream_rewind: int jas_stream_rewind(jas_stream_t *stream) /* <=== jas_stream_rewind */ \n{\n\tJAS_DBGLOG(100, (\"jas_stream_rewind(%p)\\n\", stream));\n\treturn jas_stream_seek(stream, 0, SEEK_SET);\n}\n- JP2_BOX_COLR: #define\tJP2_BOX_COLR\t0x636f6c72\t/* Color Specification */ /* <=== src/libjasper/jp2/jp2_cod.h:99:99:JP2_BOX_COLR:0 */ \n- JP2_CDEF_YCBCR_Y: #define JP2_CDEF_YCBCR_Y\t1 /* <=== src/libjasper/jp2/jp2_cod.h:197:197:JP2_CDEF_YCBCR_Y:0 */ \n- jpc_encode: int jpc_encode(jas_image_t *image, jas_stream_t *out, const char *optstr) /* <=== jpc_encode */ \n{\n\tjpc_enc_t *enc;\n\tjpc_enc_cp_t *cp;\n\n\tenc = 0;\n\tcp = 0;\n\n\tjpc_initluts();\n\n\tif (!(cp = cp_create(optstr, image))) {\n\t\tjas_eprintf(\"invalid JP encoder options\\n\");\n\t\tgoto error;\n\t}\n\n\tif (!(enc = jpc_enc_create(cp, out, image))) {\n\t\tjas_eprintf(\"jpc_enc_create failed\\n\");\n\t\tgoto error;\n\t}\n\tcp = 0;\n\n\t/* Encode the main header. */\n\tif (jpc_enc_encodemainhdr(enc)) {\n\t\tjas_eprintf(\"cannot encode main header\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Encode the main body.  This constitutes most of the encoding work. */\n\tif (jpc_enc_encodemainbody(enc)) {\n\t\tjas_eprintf(\"cannot encode main body\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Write EOC marker segment. */\n\tif (!(enc->mrk = jpc_ms_create(JPC_MS_EOC))) {\n\t\tjas_eprintf(\"cannot create EOC marker\\n\");\n\t\tgoto error;\n\t}\n\tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {\n\t\tjas_eprintf(\"cannot write EOC marker\\n\");\n\t\tgoto error;\n\t}\n\tjpc_ms_destroy(enc->mrk);\n\tenc->mrk = 0;\n\n\tif (jas_stream_flush(enc->out)) {\n\t\tjas_eprintf(\"stream flush failed\\n\");\n\t\tgoto error;\n\t}\n\n\tjpc_enc_destroy(enc);\n\n\treturn 0;\n\nerror:\n\tif (cp) {\n\t\tjpc_enc_cp_destroy(cp);\n\t}\n\tif (enc) {\n\t\tjpc_enc_destroy(enc);\n\t}\n\tjas_eprintf(\"jpc_encode failed\\n\");\n\treturn -1;\n}\n- JP2_CDEF_YCBCR_CB: #define JP2_CDEF_YCBCR_CB\t2 /* <=== src/libjasper/jp2/jp2_cod.h:198:198:JP2_CDEF_YCBCR_CB:0 */ \n- jas_clrspc_fam: #define\tjas_clrspc_fam(clrspc)\t((clrspc) >> 8) /* <=== src/libjasper/include/jasper/jas_cm.h:101:101:jas_clrspc_fam:1 */ \n- jas_stream_tell: long jas_stream_tell(jas_stream_t *stream) /* <=== jas_stream_tell */ \n{\n\tint adjust;\n\tint offset;\n\n\tJAS_DBGLOG(100, (\"jas_stream_tell(%p)\\n\", stream));\n\n\tif (stream->bufmode_ & JAS_STREAM_RDBUF) {\n\t\tadjust = -stream->cnt_;\n\t} else if (stream->bufmode_ & JAS_STREAM_WRBUF) {\n\t\tadjust = stream->ptr_ - stream->bufstart_;\n\t} else {\n\t\tadjust = 0;\n\t}\n\n\tif ((offset = (*stream->ops_->seek_)(stream->obj_, 0, SEEK_CUR)) < 0) {\n\t\treturn -1;\n\t}\n\n\treturn offset + adjust;\n}\n- jas_image_cmptprec: #define\tjas_image_cmptprec(image, cmptno) \\ /* <=== src/libjasper/include/jasper/jas_image.h:379:380:jas_image_cmptprec:2 */ \n\t((image)->cmpts_[cmptno]->prec_)\n- jas_image_numcmpts: #define\tjas_image_numcmpts(image) \\ /* <=== src/libjasper/include/jasper/jas_image.h:350:351:jas_image_numcmpts:1 */ \n\t((image)->numcmpts_)\n- jp2_putuint32: static int jp2_putuint32(jas_stream_t *out, uint_fast32_t val) /* <=== jp2_putuint32 */ \n{\n\tif (jas_stream_putc(out, (val >> 24) & 0xff) == EOF ||\n\t  jas_stream_putc(out, (val >> 16) & 0xff) == EOF ||\n\t  jas_stream_putc(out, (val >> 8) & 0xff) == EOF ||\n\t  jas_stream_putc(out, val & 0xff) == EOF) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n- JAS_IMAGE_CT_YCBCR_CR: #define\tJAS_IMAGE_CT_YCBCR_CR\t2 /* <=== src/libjasper/include/jasper/jas_image.h:118:118:JAS_IMAGE_CT_YCBCR_CR:0 */ \n- jpc_enc_encodemainbody: static int jpc_enc_encodemainbody(jpc_enc_t *enc) /* <=== jpc_enc_encodemainbody */ \n{\n\tint tileno;\n\tint tilex;\n\tint tiley;\n\tint i;\n\tjpc_sot_t *sot;\n\tjpc_enc_tcmpt_t *comp;\n\tjpc_enc_tcmpt_t *endcomps;\n\tjpc_enc_band_t *band;\n\tjpc_enc_band_t *endbands;\n\tjpc_enc_rlvl_t *lvl;\n\tint rlvlno;\n\tjpc_qcc_t *qcc;\n\tjpc_cod_t *cod;\n\tint adjust;\n\tint j;\n\tint absbandno;\n\tlong numbytes;\n\tlong tilehdrlen;\n\tlong tilelen;\n\tjpc_enc_tile_t *tile;\n\tjpc_enc_cp_t *cp;\n\tdouble rho;\n\tint lyrno;\n\tint cmptno;\n\tint samestepsizes;\n\tjpc_enc_ccp_t *ccps;\n\tjpc_enc_tccp_t *tccp;\n\tint bandno;\n\tuint_fast32_t x;\n\tuint_fast32_t y;\n\tint mingbits;\n\tint actualnumbps;\n\tjpc_fix_t mxmag;\n\tjpc_fix_t mag;\n\tint numgbits;\n\n\tcp = enc->cp;\n\n\t/* Avoid compile warnings. */\n\tnumbytes = 0;\n\n\tfor (tileno = 0; tileno < JAS_CAST(int, cp->numtiles); ++tileno) {\n\t\ttilex = tileno % cp->numhtiles;\n\t\ttiley = tileno / cp->numhtiles;\n\n\t\tif (!(enc->curtile = jpc_enc_tile_create(enc->cp, enc->image,\n\t\t  tileno))) {\n\t\t\tjas_eprintf(\"cannot create tile\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\ttile = enc->curtile;\n\n\t\tif (jas_getdbglevel() >= 10) {\n\t\t\tjpc_enc_dump(enc);\n\t\t}\n\n\t\tendcomps = &tile->tcmpts[tile->numtcmpts];\n\t\tfor (cmptno = 0, comp = tile->tcmpts; cmptno < tile->numtcmpts; ++cmptno, ++comp) {\n\t\t\tif (!cp->ccps[cmptno].sgnd) {\n\t\t\t\tadjust = 1 << (cp->ccps[cmptno].prec - 1);\n\t\t\t\tfor (i = 0; i < jas_matrix_numrows(comp->data); ++i) {\n\t\t\t\t\tfor (j = 0; j < jas_matrix_numcols(comp->data); ++j) {\n\t\t\t\t\t\t*jas_matrix_getref(comp->data, i, j) -= adjust;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!tile->intmode) {\n\t\t\t\tendcomps = &tile->tcmpts[tile->numtcmpts];\n\t\t\t\tfor (comp = tile->tcmpts; comp != endcomps; ++comp) {\n\t\t\t\t\tjas_matrix_asl(comp->data, JPC_FIX_FRACBITS);\n\t\t\t\t}\n\t\t}\n\n\t\tswitch (tile->mctid) {\n\t\tcase JPC_MCT_RCT:\nassert(jas_image_numcmpts(enc->image) == 3);\n\t\t\tjpc_rct(tile->tcmpts[0].data, tile->tcmpts[1].data,\n\t\t\t  tile->tcmpts[2].data);\n\t\t\tbreak;\n\t\tcase JPC_MCT_ICT:\nassert(jas_image_numcmpts(enc->image) == 3);\n\t\t\tjpc_ict(tile->tcmpts[0].data, tile->tcmpts[1].data,\n\t\t\t  tile->tcmpts[2].data);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < jas_image_numcmpts(enc->image); ++i) {\n\t\t\tcomp = &tile->tcmpts[i];\n\t\t\tjpc_tsfb_analyze(comp->tsfb, comp->data);\n\n\t\t}\n\n\n\t\tendcomps = &tile->tcmpts[tile->numtcmpts];\n\t\tfor (cmptno = 0, comp = tile->tcmpts; comp != endcomps; ++cmptno, ++comp) {\n\t\t\tmingbits = 0;\n\t\t\tabsbandno = 0;\n\t\t\t/* All bands must have a corresponding quantizer step size,\n\t\t\t  even if they contain no samples and are never coded. */\n\t\t\t/* Some bands may not be hit by the loop below, so we must\n\t\t\t  initialize all of the step sizes to a sane value. */\n\t\t\tmemset(comp->stepsizes, 0, sizeof(comp->stepsizes));\n\t\t\tfor (rlvlno = 0, lvl = comp->rlvls; rlvlno < comp->numrlvls; ++rlvlno, ++lvl) {\n\t\t\t\tif (!lvl->bands) {\n\t\t\t\t\tabsbandno += rlvlno ? 3 : 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tendbands = &lvl->bands[lvl->numbands];\n\t\t\t\tfor (band = lvl->bands; band != endbands; ++band) {\n\t\t\t\t\tif (!band->data) {\n\t\t\t\t\t\t++absbandno;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tactualnumbps = 0;\n\t\t\t\t\tmxmag = 0;\n\t\t\t\t\tfor (y = 0; y < JAS_CAST(uint_fast32_t, jas_matrix_numrows(band->data)); ++y) {\n\t\t\t\t\t\tfor (x = 0; x < JAS_CAST(uint_fast32_t, jas_matrix_numcols(band->data)); ++x) {\n\t\t\t\t\t\t\tmag = JAS_ABS(jas_matrix_get(band->data, y, x));\n\t\t\t\t\t\t\tif (mag > mxmag) {\n\t\t\t\t\t\t\t\tmxmag = mag;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (tile->intmode) {\n\t\t\t\t\t\tactualnumbps = jpc_fix_firstone(mxmag) + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tactualnumbps = jpc_fix_firstone(mxmag) + 1 - JPC_FIX_FRACBITS;\n\t\t\t\t\t}\n\t\t\t\t\tnumgbits = actualnumbps - (cp->ccps[cmptno].prec - 1 +\n\t\t\t\t\t  band->analgain);\n#if 0\njas_eprintf(\"%d %d mag=%d actual=%d numgbits=%d\\n\", cp->ccps[cmptno].prec, band->analgain, mxmag, actualnumbps, numgbits);\n#endif\n\t\t\t\t\tif (numgbits > mingbits) {\n\t\t\t\t\t\tmingbits = numgbits;\n\t\t\t\t\t}\n\t\t\t\t\tif (!tile->intmode) {\n\t\t\t\t\t\tband->absstepsize = jpc_fix_div(jpc_inttofix(1\n\t\t\t\t\t\t  << (band->analgain + 1)),\n\t\t\t\t\t\t  band->synweight);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tband->absstepsize = jpc_inttofix(1);\n\t\t\t\t\t}\n\t\t\t\t\tconst uint_fast32_t stepsize = jpc_abstorelstepsize(\n\t\t\t\t\t  band->absstepsize, cp->ccps[cmptno].prec +\n\t\t\t\t\t  band->analgain);\n\t\t\t\t\tif (stepsize == UINT_FAST32_MAX)\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\tband->stepsize = stepsize;\n\t\t\t\t\tband->numbps = cp->tccp.numgbits +\n\t\t\t\t\t  JPC_QCX_GETEXPN(band->stepsize) - 1;\n\n\t\t\t\t\tif ((!tile->intmode) && band->data) {\n\t\t\t\t\t\tjpc_quantize(band->data, band->absstepsize);\n\t\t\t\t\t}\n\n\t\t\t\t\tcomp->stepsizes[absbandno] = band->stepsize;\n\t\t\t\t\t++absbandno;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tassert(JPC_FIX_FRACBITS >= JPC_NUMEXTRABITS);\n\t\t\tif (!tile->intmode) {\n\t\t\t\tjas_matrix_divpow2(comp->data, JPC_FIX_FRACBITS - JPC_NUMEXTRABITS);\n\t\t\t} else {\n\t\t\t\tjas_matrix_asl(comp->data, JPC_NUMEXTRABITS);\n\t\t\t}\n\n#if 0\njas_eprintf(\"mingbits %d\\n\", mingbits);\n#endif\n\t\t\tif (mingbits > cp->tccp.numgbits) {\n\t\t\t\tjas_eprintf(\"error: too few guard bits (need at least %d)\\n\",\n\t\t\t\t  mingbits);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (!(enc->tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tjas_eprintf(\"cannot open tmp file\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Write the tile header. */\n\t\tif (!(enc->mrk = jpc_ms_create(JPC_MS_SOT))) {\n\t\t\treturn -1;\n\t\t}\n\t\tsot = &enc->mrk->parms.sot;\n\t\tsot->len = 0;\n\t\tsot->tileno = tileno;\n\t\tsot->partno = 0;\n\t\tsot->numparts = 1;\n\t\tif (jpc_putms(enc->tmpstream, enc->cstate, enc->mrk)) {\n\t\t\tjas_eprintf(\"cannot write SOT marker\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_ms_destroy(enc->mrk);\n\t\tenc->mrk = 0;\n\n/************************************************************************/\n/************************************************************************/\n/************************************************************************/\n\n\t\ttccp = &cp->tccp;\n\t\tfor (cmptno = 0; cmptno < JAS_CAST(int, cp->numcmpts); ++cmptno) {\n\t\t\tcomp = &tile->tcmpts[cmptno];\n\t\t\tif (comp->numrlvls != tccp->maxrlvls) {\n\t\t\t\tif (!(enc->mrk = jpc_ms_create(JPC_MS_COD))) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n/* XXX = this is not really correct. we are using comp #0's precint sizes\nand other characteristics */\n\t\t\t\tcomp = &tile->tcmpts[0];\n\t\t\t\tcod = &enc->mrk->parms.cod;\n\t\t\t\tcod->compparms.csty = 0;\n\t\t\t\tcod->compparms.numdlvls = comp->numrlvls - 1;\n\t\t\t\tcod->prg = tile->prg;\n\t\t\t\tcod->numlyrs = tile->numlyrs;\n\t\t\t\tcod->compparms.cblkwidthval = JPC_COX_CBLKSIZEEXPN(comp->cblkwidthexpn);\n\t\t\t\tcod->compparms.cblkheightval = JPC_COX_CBLKSIZEEXPN(comp->cblkheightexpn);\n\t\t\t\tcod->compparms.cblksty = comp->cblksty;\n\t\t\t\tcod->compparms.qmfbid = comp->qmfbid;\n\t\t\t\tcod->mctrans = (tile->mctid != JPC_MCT_NONE);\n\t\t\t\tfor (i = 0; i < comp->numrlvls; ++i) {\n\t\t\t\t\tcod->compparms.rlvls[i].parwidthval = comp->rlvls[i].prcwidthexpn;\n\t\t\t\t\tcod->compparms.rlvls[i].parheightval = comp->rlvls[i].prcheightexpn;\n\t\t\t\t}\n\t\t\t\tif (jpc_putms(enc->tmpstream, enc->cstate, enc->mrk)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tjpc_ms_destroy(enc->mrk);\n\t\t\t\tenc->mrk = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor (cmptno = 0, comp = tile->tcmpts; cmptno < JAS_CAST(int,\n\t\t  cp->numcmpts); ++cmptno, ++comp) {\n\t\t\tccps = &cp->ccps[cmptno];\n\t\t\tif (JAS_CAST(int, ccps->numstepsizes) == comp->numstepsizes) {\n\t\t\t\tsamestepsizes = 1;\n\t\t\t\tfor (bandno = 0; bandno < JAS_CAST(int, ccps->numstepsizes);\n\t\t\t\t  ++bandno) {\n\t\t\t\t\tif (ccps->stepsizes[bandno] != comp->stepsizes[bandno]) {\n\t\t\t\t\t\tsamestepsizes = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsamestepsizes = 0;\n\t\t\t}\n\t\t\tif (!samestepsizes) {\n\t\t\t\tif (!(enc->mrk = jpc_ms_create(JPC_MS_QCC))) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tqcc = &enc->mrk->parms.qcc;\n\t\t\t\tqcc->compno = cmptno;\n\t\t\t\tqcc->compparms.numguard = cp->tccp.numgbits;\n\t\t\t\tqcc->compparms.qntsty = (comp->qmfbid == JPC_COX_INS) ?\n\t\t\t\t  JPC_QCX_SEQNT : JPC_QCX_NOQNT;\n\t\t\t\tqcc->compparms.numstepsizes = comp->numstepsizes;\n\t\t\t\tqcc->compparms.stepsizes = comp->stepsizes;\n\t\t\t\tif (jpc_putms(enc->tmpstream, enc->cstate, enc->mrk)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tqcc->compparms.stepsizes = 0;\n\t\t\t\tjpc_ms_destroy(enc->mrk);\n\t\t\t\tenc->mrk = 0;\n\t\t\t}\n\t\t}\n\n\t\t/* Write a SOD marker to indicate the end of the tile header. */\n\t\tif (!(enc->mrk = jpc_ms_create(JPC_MS_SOD))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jpc_putms(enc->tmpstream, enc->cstate, enc->mrk)) {\n\t\t\tjas_eprintf(\"cannot write SOD marker\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_ms_destroy(enc->mrk);\n\t\tenc->mrk = 0;\n\t\ttilehdrlen = jas_stream_getrwcount(enc->tmpstream);\n\t\tassert(tilehdrlen >= 0);\n\n/************************************************************************/\n/************************************************************************/\n/************************************************************************/\n\n\t\tif (jpc_enc_enccblks(enc)) {\n\t\t\tabort();\n\t\t\treturn -1;\n\t\t}\n\n\t\tcp = enc->cp;\n\t\trho = (double) (tile->brx - tile->tlx) * (tile->bry - tile->tly) /\n\t\t  ((cp->refgrdwidth - cp->imgareatlx) * (cp->refgrdheight -\n\t\t  cp->imgareatly));\n\t\ttile->rawsize = cp->rawsize * rho;\n\n\t\tfor (lyrno = 0; lyrno < tile->numlyrs - 1; ++lyrno) {\n\t\t\ttile->lyrsizes[lyrno] = tile->rawsize * jpc_fixtodbl(\n\t\t\t  cp->tcp.ilyrrates[lyrno]);\n\t\t}\n#if !defined(__clang__)\n\t\t// WARNING:\n\t\t// Some versions of Clang (e.g., 3.7.1 and 3.8.1) appear to generate\n\t\t// incorrect code for the following line.\n\t\ttile->lyrsizes[tile->numlyrs - 1] =\n\t\t  (cp->totalsize != UINT_FAST32_MAX) ?\n\t\t  (rho * enc->mainbodysize) : UINT_FAST32_MAX;\n#else\n\t\tif (cp->totalsize != UINT_FAST32_MAX) {\n\t\t\ttile->lyrsizes[tile->numlyrs - 1] = (rho * enc->mainbodysize);\n\t\t} else {\n\t\t\ttile->lyrsizes[tile->numlyrs - 1] = UINT_FAST32_MAX;\n\t\t}\n#endif\n//jas_eprintf(\"TESTING %ld %ld\\n\", cp->totalsize != UINT_FAST32_MAX, tile->lyrsizes[0]);\n\t\tfor (lyrno = 0; lyrno < tile->numlyrs; ++lyrno) {\n\t\t\tif (tile->lyrsizes[lyrno] != UINT_FAST32_MAX) {\n\t\t\t\tif (JAS_CAST(uint_fast32_t, tilehdrlen) <= tile->lyrsizes[lyrno]) {\n\t\t\t\t\ttile->lyrsizes[lyrno] -= tilehdrlen;\n\t\t\t\t} else {\n\t\t\t\t\ttile->lyrsizes[lyrno] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (rateallocate(enc, tile->numlyrs, tile->lyrsizes)) {\n\t\t\treturn -1;\n\t\t}\n\n#if 0\njas_eprintf(\"ENCODE TILE DATA\\n\");\n#endif\n\t\tif (jpc_enc_encodetiledata(enc)) {\n\t\t\tjas_eprintf(\"dotile failed\\n\");\n\t\t\treturn -1;\n\t\t}\n\n/************************************************************************/\n/************************************************************************/\n/************************************************************************/\n\n/************************************************************************/\n/************************************************************************/\n/************************************************************************/\n\n\t\ttilelen = jas_stream_tell(enc->tmpstream);\n\n\t\tif (jas_stream_seek(enc->tmpstream, 6, SEEK_SET) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_putuint32(enc->tmpstream, tilelen);\n\n\t\tif (jas_stream_seek(enc->tmpstream, 0, SEEK_SET) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jpc_putdata(enc->out, enc->tmpstream, -1)) {\n\t\t\treturn -1;\n\t\t}\n\t\tenc->len += tilelen;\n\n\t\tjas_stream_close(enc->tmpstream);\n\t\tenc->tmpstream = 0;\n\n\t\tjpc_enc_tile_destroy(enc->curtile);\n\t\tenc->curtile = 0;\n\n\t}\n\n\treturn 0;\n}\n- jp2_box_create: jp2_box_t *jp2_box_create(int type) /* <=== jp2_box_create */ \n{\n\tjp2_box_t *box;\n\tconst jp2_boxinfo_t *boxinfo;\n\tif (!(box = jp2_box_create0())) {\n\t\treturn 0;\n\t}\n\tbox->type = type;\n\tbox->len = 0;\n\tif (!(boxinfo = jp2_boxinfolookup(type))) {\n\t\treturn 0;\n\t}\n\tbox->info = boxinfo;\n\tbox->ops = &boxinfo->ops;\n\treturn box;\n}\n- JAS_IMAGE_CT_RGB_B: #define\tJAS_IMAGE_CT_RGB_B\t2 /* <=== src/libjasper/include/jasper/jas_image.h:114:114:JAS_IMAGE_CT_RGB_B:0 */ \n- jas_stream_pad: int jas_stream_pad(jas_stream_t *stream, int n, int c) /* <=== jas_stream_pad */ \n{\n\tint m;\n\n\tJAS_DBGLOG(100, (\"jas_stream_pad(%p, %d, %d)\\n\", stream, n, c));\n\n\tif (n < 0) {\n\t\tjas_deprecated(\"negative count for jas_stream_pad\");\n\t}\n\tm = n;\n\tfor (m = n; m > 0; --m) {\n\t\tif (jas_stream_putc(stream, c) == EOF)\n\t\t\treturn n - m;\n\t}\n\treturn n;\n}\n- jas_eprintf: int jas_eprintf(const char *fmt, ...) /* <=== jas_eprintf */ \n{\n\tint ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}\n- jas_iccattrtab_get: static int jas_iccattrtab_get(jas_iccattrtab_t *attrtab, int i, /* <=== jas_iccattrtab_get */ \n  jas_iccattrname_t *name, jas_iccattrval_t **val)\n{\n\tjas_iccattr_t *attr;\n\tif (i < 0 || i >= attrtab->numattrs)\n\t\tgoto error;\n\tattr = &attrtab->attrs[i];\n\t*name = attr->name;\n\tif (!(*val = jas_iccattrval_clone(attr->val)))\n\t\tgoto error;\n\treturn 0;\nerror:\n\treturn -1;\n}\n- JAS_IMAGE_CT_OPACITY: #define\tJAS_IMAGE_CT_OPACITY\t0x08000 /* <=== src/libjasper/include/jasper/jas_image.h:110:110:JAS_IMAGE_CT_OPACITY:0 */ \n- jas_stream_read: int jas_stream_read(jas_stream_t *stream, void *buf, int cnt) /* <=== jas_stream_read */ \n{\n\tint n;\n\tint c;\n\tchar *bufptr;\n\n\tJAS_DBGLOG(100, (\"jas_stream_read(%p, %p, %d)\\n\", stream, buf, cnt));\n\n\tif (cnt < 0) {\n\t\tjas_deprecated(\"negative count for jas_stream_read\");\n\t}\n\n\tbufptr = buf;\n\n\tn = 0;\n\twhile (n < cnt) {\n\t\tif ((c = jas_stream_getc(stream)) == EOF) {\n\t\t\treturn n;\n\t\t}\n\t\t*bufptr++ = c;\n\t\t++n;\n\t}\n\n\treturn n;\n}\n- jas_image_cmprof: #define\tjas_image_cmprof(image)\t((image)->cmprof_) /* <=== src/libjasper/include/jasper/jas_image.h:494:494:jas_image_cmprof:1 */ \n- JAS_IMAGE_CT_YCBCR_Y: #define\tJAS_IMAGE_CT_YCBCR_Y\t0 /* <=== src/libjasper/include/jasper/jas_image.h:116:116:JAS_IMAGE_CT_YCBCR_Y:0 */ \n- jas_iccprof_createfromcmprof: jas_iccprof_t *jas_iccprof_createfromcmprof(jas_cmprof_t *prof) /* <=== jas_iccprof_createfromcmprof */ \n{\n\treturn jas_iccprof_copy(prof->iccprof);\n}\n- JP2_CDEF_YCBCR_CR: #define JP2_CDEF_YCBCR_CR\t3 /* <=== src/libjasper/jp2/jp2_cod.h:199:199:JP2_CDEF_YCBCR_CR:0 */ \n- JP2_COLR_ICC: #define\tJP2_COLR_ICC\t2 /* <=== src/libjasper/jp2/jp2_cod.h:165:165:JP2_COLR_ICC:0 */ \n- JP2_BOX_FTYP: #define JP2_BOX_FTYP\t0x66747970\t/* File Type */ /* <=== src/libjasper/jp2/jp2_cod.h:95:95:JP2_BOX_FTYP:0 */ \n- JAS_ICC_HDRLEN: #define\tJAS_ICC_HDRLEN\t128 /* <=== src/libjasper/include/jasper/jas_icc.h:78:78:JAS_ICC_HDRLEN:0 */ \n- JP2_BOX_HDRLEN: #define\tJP2_BOX_HDRLEN(ext) ((ext) ? 16 : 8) /* <=== src/libjasper/jp2/jp2_cod.h:91:91:JP2_BOX_HDRLEN:1 */ \n- JPC_MS_EOC: #define\tJPC_MS_EOC\t0xffd9 /* End of code stream (EOC). */ /* <=== src/libjasper/jpc/jpc_cs.h:635:635:JPC_MS_EOC:0 */ \n- JP2_CDEF_RGB_G: #define JP2_CDEF_RGB_G\t2 /* <=== src/libjasper/jp2/jp2_cod.h:194:194:JP2_CDEF_RGB_G:0 */ \n\nType Definitions:\n- jp2_colr_t: typedef struct {\n\tuint_fast8_t method;\n\tuint_fast8_t pri;\n\tuint_fast8_t approx;\n\tuint_fast32_t csid;\n\tuint_fast8_t *iccp;\n\tint iccplen;\n\t/* XXX - Someday we ought to add ICC profile data here. */\n}\n- jas_image_t: typedef struct {\n\n\tjas_image_coord_t tlx_;\n\t/* The x-coordinate of the top-left corner of the image bounding box. */\n\n\tjas_image_coord_t tly_;\n\t/* The y-coordinate of the top-left corner of the image bounding box. */\n\n\tjas_image_coord_t brx_;\n\t/* The x-coordinate of the bottom-right corner of the image bounding\n\t  box (plus one). */\n\n\tjas_image_coord_t bry_;\n\t/* The y-coordinate of the bottom-right corner of the image bounding\n\t  box (plus one). */\n\n\tint numcmpts_;\n\t/* The number of components. */\n\n\tint maxcmpts_;\n\t/* The maximum number of components that this image can have (i.e., the\n\t  allocated size of the components array). */\n\n\tjas_image_cmpt_t **cmpts_;\n\t/* Per-component information. */\n\n\tjas_clrspc_t clrspc_;\n\n\tjas_cmprof_t *cmprof_;\n\n//\tbool inmem_;\n\n}\n- jp2_cdef_t: typedef struct {\n\tuint_fast16_t numchans;\n\tjp2_cdefchan_t *ents;\n}\n- jas_iccprof_t: typedef struct {\n\tjas_icchdr_t hdr;\n\tjas_icctagtab_t tagtab;\n\tjas_iccattrtab_t *attrtab;\n}\n- jp2_cdefchan_t: typedef struct {\n\tuint_fast16_t channo;\n\tuint_fast16_t type;\n\tuint_fast16_t assoc;\n}\n- jp2_box_t: typedef struct {\n\n\tconst struct jp2_boxops_s *ops;\n\tconst struct jp2_boxinfo_s *info;\n\n\tuint_fast32_t type;\n\n\t/* The length of the box including the (variable-length) header. */\n\tuint_fast32_t len;\n\n\t/* The length of the box data. */\n\tuint_fast32_t datalen;\n\n\tunion {\n\t\tjp2_jp_t jp;\n\t\tjp2_ftyp_t ftyp;\n\t\tjp2_ihdr_t ihdr;\n\t\tjp2_bpcc_t bpcc;\n\t\tjp2_colr_t colr;\n\t\tjp2_pclr_t pclr;\n\t\tjp2_cdef_t cdef;\n\t\tjp2_cmap_t cmap;\n\t} data;\n\n}\n- jas_stream_t: typedef struct {\n\n\t/* The mode in which the stream was opened. */\n\tint openmode_;\n\n\t/* The buffering mode. */\n\tint bufmode_;\n\n\t/* The stream status. */\n\tint flags_;\n\n\t/* The start of the buffer area to use for reading/writing. */\n\tjas_uchar *bufbase_;\n\n\t/* The start of the buffer area excluding the extra initial space for\n\t  character putback. */\n\tjas_uchar *bufstart_;\n\n\t/* The buffer size. */\n\tint bufsize_;\n\n\t/* The current position in the buffer. */\n\tjas_uchar *ptr_;\n\n\t/* The number of characters that must be read/written before\n\tthe buffer needs to be filled/flushed. */\n\tint cnt_;\n\n\t/* A trivial buffer to be used for unbuffered operation. */\n\tjas_uchar tinybuf_[JAS_STREAM_MAXPUTBACK + 1];\n\n\t/* The operations for the underlying stream file object. */\n\tconst jas_stream_ops_t *ops_;\n\n\t/* The underlying stream file object. */\n\tjas_stream_obj_t *obj_;\n\n\t/* The number of characters read/written. */\n\tlong rwcnt_;\n\n\t/* The maximum number of characters that may be read/written. */\n\tlong rwlimit_;\n\n}\n- jp2_bpcc_t: typedef struct {\n\tuint_fast16_t numcmpts;\n\tuint_fast8_t *bpcs;\n}\n\nImports:\n- #include \"jasper/jas_image.h\"\n- #include \"jasper/jas_icc.h\"\n- #include \"jasper/jas_cm.h\"\n- #include \"jasper/jas_malloc.h\"\n- #include <assert.h>\n- #include \"jasper/jas_stream.h\"\n- #include \"jp2_cod.h\"\n- #include \"jasper/jas_debug.h\"",
    "commit_msg": "jp2_enc: check number of components before dereferencing them\n\nFixes CVE-2018-20570\n\nCloses https://github.com/jasper-maint/jasper/issues/11\nCloses https://github.com/mdadams/jasper/issues/191",
    "cve_desc": "jp2_encode in jp2/jp2_enc.c in JasPer 2.0.14 has a heap-based buffer over-read.",
    "year": 2020,
    "filename": "jp2_enc.c",
    "commit_url": "\"https://github.com/mdadams/jasper/commit/03db7c81f6a8a92d896249bc673877749987fd7a\""
  },
  {
    "repository": "admesh/admesh",
    "cve_id": "CVE-2018-25033",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "e84d8353f1347e1f26f0a95770d92ba14e6ede38",
    "short_hash": "e84d8353",
    "vulnerableMethods_before": [
      {
        "filename": "src/connect.c",
        "method_name": "stl_remove_degenerate",
        "raw_code": "static void /* <=== stl_remove_degenerate */ \nstl_remove_degenerate(stl_file *stl, int facet) {\n  int edge1;\n  int edge2;\n  int edge3;\n  int neighbor1;\n  int neighbor2;\n  int neighbor3;\n  int vnot1;\n  int vnot2;\n  int vnot3;\n\n  if (stl->error) return;\n\n  if(   !memcmp(&stl->facet_start[facet].vertex[0],\n                &stl->facet_start[facet].vertex[1], sizeof(stl_vertex))\n        && !memcmp(&stl->facet_start[facet].vertex[1],\n                   &stl->facet_start[facet].vertex[2], sizeof(stl_vertex))) {\n    /* all 3 vertices are equal.  Just remove the facet.  I don't think*/\n    /* this is really possible, but just in case... */\n    printf(\"removing a facet in stl_remove_degenerate\\n\");\n\n    stl_remove_facet(stl, facet);\n    return;\n  }\n\n  if(!memcmp(&stl->facet_start[facet].vertex[0],\n             &stl->facet_start[facet].vertex[1], sizeof(stl_vertex))) {\n    edge1 = 1;\n    edge2 = 2;\n    edge3 = 0;\n  } else if(!memcmp(&stl->facet_start[facet].vertex[1],\n                    &stl->facet_start[facet].vertex[2], sizeof(stl_vertex))) {\n    edge1 = 0;\n    edge2 = 2;\n    edge3 = 1;\n  } else if(!memcmp(&stl->facet_start[facet].vertex[2],\n                    &stl->facet_start[facet].vertex[0], sizeof(stl_vertex))) {\n    edge1 = 0;\n    edge2 = 1;\n    edge3 = 2;\n  } else {\n    /* No degenerate. Function shouldn't have been called. */\n    return;\n  }\n  neighbor1 = stl->neighbors_start[facet].neighbor[edge1];\n  neighbor2 = stl->neighbors_start[facet].neighbor[edge2];\n\n  if(neighbor1 == -1) {\n    stl_update_connects_remove_1(stl, neighbor2);\n  }\n  if(neighbor2 == -1) {\n    stl_update_connects_remove_1(stl, neighbor1);\n  }\n\n\n  neighbor3 = stl->neighbors_start[facet].neighbor[edge3];\n  vnot1 = stl->neighbors_start[facet].which_vertex_not[edge1];\n  vnot2 = stl->neighbors_start[facet].which_vertex_not[edge2];\n  vnot3 = stl->neighbors_start[facet].which_vertex_not[edge3];\n\n  if(neighbor1 != -1){\n    stl->neighbors_start[neighbor1].neighbor[(vnot1 + 1) % 3] = neighbor2;\n    stl->neighbors_start[neighbor1].which_vertex_not[(vnot1 + 1) % 3] = vnot2;\n  }\n  if(neighbor2 != -1){\n    stl->neighbors_start[neighbor2].neighbor[(vnot2 + 1) % 3] = neighbor1;\n    stl->neighbors_start[neighbor2].which_vertex_not[(vnot2 + 1) % 3] = vnot1;\n  }\n\n  stl_remove_facet(stl, facet);\n\n  if(neighbor3 != -1) {\n    stl_update_connects_remove_1(stl, neighbor3);\n    stl->neighbors_start[neighbor3].neighbor[(vnot3 + 1) % 3] = -1;\n  }\n}",
        "start_line": 747
      },
      {
        "filename": "src/connect.c",
        "method_name": "stl_update_connects_remove_1",
        "raw_code": "void /* <=== stl_update_connects_remove_1 */ \nstl_update_connects_remove_1(stl_file *stl, int facet_num) {\n  int j;\n\n  if (stl->error) return;\n  /* Update list of connected edges */\n  j = ((stl->neighbors_start[facet_num].neighbor[0] == -1) +\n       (stl->neighbors_start[facet_num].neighbor[1] == -1) +\n       (stl->neighbors_start[facet_num].neighbor[2] == -1));\n  if(j == 0) {\t\t       /* Facet has 3 neighbors */\n    stl->stats.connected_facets_3_edge -= 1;\n  } else if(j == 1) {\t     /* Facet has 2 neighbors */\n    stl->stats.connected_facets_2_edge -= 1;\n  } else if(j == 2) {\t     /* Facet has 1 neighbor  */\n    stl->stats.connected_facets_1_edge -= 1;\n  }\n}",
        "start_line": 825
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "src/connect.c",
        "method_name": "stl_remove_degenerate",
        "raw_code": "static void /* <=== stl_remove_degenerate */ \nstl_remove_degenerate(stl_file *stl, int facet) {\n  int edge1;\n  int edge2;\n  int edge3;\n  int neighbor1;\n  int neighbor2;\n  int neighbor3;\n  int vnot1;\n  int vnot2;\n  int vnot3;\n\n  if (stl->error) return;\n\n  if(   !memcmp(&stl->facet_start[facet].vertex[0],\n                &stl->facet_start[facet].vertex[1], sizeof(stl_vertex))\n        && !memcmp(&stl->facet_start[facet].vertex[1],\n                   &stl->facet_start[facet].vertex[2], sizeof(stl_vertex))) {\n    /* all 3 vertices are equal.  Just remove the facet.  I don't think*/\n    /* this is really possible, but just in case... */\n    printf(\"removing a facet in stl_remove_degenerate\\n\");\n\n    stl_remove_facet(stl, facet);\n    return;\n  }\n\n  if(!memcmp(&stl->facet_start[facet].vertex[0],\n             &stl->facet_start[facet].vertex[1], sizeof(stl_vertex))) {\n    edge1 = 1;\n    edge2 = 2;\n    edge3 = 0;\n  } else if(!memcmp(&stl->facet_start[facet].vertex[1],\n                    &stl->facet_start[facet].vertex[2], sizeof(stl_vertex))) {\n    edge1 = 0;\n    edge2 = 2;\n    edge3 = 1;\n  } else if(!memcmp(&stl->facet_start[facet].vertex[2],\n                    &stl->facet_start[facet].vertex[0], sizeof(stl_vertex))) {\n    edge1 = 0;\n    edge2 = 1;\n    edge3 = 2;\n  } else {\n    /* No degenerate. Function shouldn't have been called. */\n    return;\n  }\n  neighbor1 = stl->neighbors_start[facet].neighbor[edge1];\n  neighbor2 = stl->neighbors_start[facet].neighbor[edge2];\n\n  if(neighbor1 == -1 && neighbor2 != -1) {\n    stl_update_connects_remove_1(stl, neighbor2);\n  }\n  else if (neighbor2 == -1 && neighbor1 != -1) {\n    stl_update_connects_remove_1(stl, neighbor1);\n  }\n\n  neighbor3 = stl->neighbors_start[facet].neighbor[edge3];\n  vnot1 = stl->neighbors_start[facet].which_vertex_not[edge1];\n  vnot2 = stl->neighbors_start[facet].which_vertex_not[edge2];\n  vnot3 = stl->neighbors_start[facet].which_vertex_not[edge3];\n\n  if(neighbor1 != -1){\n    stl->neighbors_start[neighbor1].neighbor[(vnot1 + 1) % 3] = neighbor2;\n    stl->neighbors_start[neighbor1].which_vertex_not[(vnot1 + 1) % 3] = vnot2;\n  }\n  if(neighbor2 != -1){\n    stl->neighbors_start[neighbor2].neighbor[(vnot2 + 1) % 3] = neighbor1;\n    stl->neighbors_start[neighbor2].which_vertex_not[(vnot2 + 1) % 3] = vnot1;\n  }\n\n  stl_remove_facet(stl, facet);\n\n  if(neighbor3 != -1) {\n    stl_update_connects_remove_1(stl, neighbor3);\n    stl->neighbors_start[neighbor3].neighbor[(vnot3 + 1) % 3] = -1;\n  }\n}",
        "start_line": 747
      },
      {
        "filename": "src/connect.c",
        "method_name": "stl_update_connects_remove_1",
        "raw_code": "void /* <=== stl_update_connects_remove_1 */ \nstl_update_connects_remove_1(stl_file *stl, int facet_num) {\n  int j;\n\n  if (\n    stl->error ||\n    facet_num < 0\n  ) return;\n\n  /* Update list of connected edges */\n  j = ((stl->neighbors_start[facet_num].neighbor[0] == -1) +\n       (stl->neighbors_start[facet_num].neighbor[1] == -1) +\n       (stl->neighbors_start[facet_num].neighbor[2] == -1));\n  if(j == 0) {\t\t       /* Facet has 3 neighbors */\n    stl->stats.connected_facets_3_edge -= 1;\n  } else if(j == 1) {\t     /* Facet has 2 neighbors */\n    stl->stats.connected_facets_2_edge -= 1;\n  } else if(j == 2) {\t     /* Facet has 1 neighbor  */\n    stl->stats.connected_facets_1_edge -= 1;\n  }\n}",
        "start_line": 824
      }
    ],
    "code_context": "Called Methods:\n- stl_remove_facet: static void /* <=== stl_remove_facet */ \nstl_remove_facet(stl_file *stl, int facet_number) {\n  int neighbor[3];\n  int vnot[3];\n  int i;\n  int j;\n\n  if (stl->error) return;\n\n  stl->stats.facets_removed += 1;\n  /* Update list of connected edges */\n  j = ((stl->neighbors_start[facet_number].neighbor[0] == -1) +\n       (stl->neighbors_start[facet_number].neighbor[1] == -1) +\n       (stl->neighbors_start[facet_number].neighbor[2] == -1));\n  if(j == 2) {\n    stl->stats.connected_facets_1_edge -= 1;\n  } else if(j == 1) {\n    stl->stats.connected_facets_2_edge -= 1;\n    stl->stats.connected_facets_1_edge -= 1;\n  } else if(j == 0) {\n    stl->stats.connected_facets_3_edge -= 1;\n    stl->stats.connected_facets_2_edge -= 1;\n    stl->stats.connected_facets_1_edge -= 1;\n  }\n\n  stl->facet_start[facet_number] =\n    stl->facet_start[stl->stats.number_of_facets - 1];\n  /* I could reallocate at this point, but it is not really necessary. */\n  stl->neighbors_start[facet_number] =\n    stl->neighbors_start[stl->stats.number_of_facets - 1];\n  stl->stats.number_of_facets -= 1;\n\n  for(i = 0; i < 3; i++) {\n    neighbor[i] = stl->neighbors_start[facet_number].neighbor[i];\n    vnot[i] = stl->neighbors_start[facet_number].which_vertex_not[i];\n  }\n\n  for(i = 0; i < 3; i++) {\n    if(neighbor[i] != -1) {\n      if(stl->neighbors_start[neighbor[i]].neighbor[(vnot[i] + 1)% 3] !=\n          stl->stats.number_of_facets) {\n        printf(\"\\\nin stl_remove_facet: neighbor = %d numfacets = %d this is wrong\\n\",\n               stl->neighbors_start[neighbor[i]].neighbor[(vnot[i] + 1)% 3],\n               stl->stats.number_of_facets);\n        return;\n      }\n      stl->neighbors_start[neighbor[i]].neighbor[(vnot[i] + 1)% 3]\n        = facet_number;\n    }\n  }\n}\n\nType Definitions:\n- stl_vertex: typedef struct {\n  float x;\n  float y;\n  float z;\n}\n- stl_file: typedef struct {\n  FILE          *fp;\n  stl_facet     *facet_start;\n  stl_edge      *edge_start;\n  stl_hash_edge **heads;\n  stl_hash_edge *tail;\n  int           M;\n  stl_neighbors *neighbors_start;\n  v_indices_struct *v_indices;\n  stl_vertex    *v_shared;\n  stl_stats     stats;\n  char          error;\n}\n\nImports:\n- #include <math.h>\n- #include <stdio.h>\n- #include <stdlib.h>\n- #include \"stl.h\"\n- #include <string.h>",
    "commit_msg": "Fix heap buffer overflow in stl_update_connects_remove_1\n\n\n- Add argument value check to the stl_update_connects_remove_1\n- Add neighbor value check in stl_remove_degenerate\n\nFixes https://github.com/admesh/admesh/issues/28\nMerges https://github.com/admesh/admesh/pull/55",
    "cve_desc": "[{'lang': 'en', 'value': 'ADMesh through 0.98.4 has a heap-based buffer over-read in stl_update_connects_remove_1 (called from stl_remove_degenerate) in connect.c in libadmesh.a.'}]",
    "year": 2022,
    "filename": "connect.c",
    "commit_url": "\"https://github.com/admesh/admesh/commit/e84d8353f1347e1f26f0a95770d92ba14e6ede38\""
  },
  {
    "repository": "mdadams/jasper",
    "cve_id": "CVE-2018-9252",
    "cwe_list": [
      "CWE-617"
    ],
    "commit_hash": "6cd1e1d8aff56d0d86d4e7d1e7e3e4dd1c64b55d",
    "short_hash": "6cd1e1d8",
    "vulnerableMethods_before": [
      {
        "filename": "src/libjasper/jpc/jpc_enc.c",
        "method_name": "jpc_abstorelstepsize",
        "raw_code": "static uint_fast32_t jpc_abstorelstepsize(jpc_fix_t absdelta, int scaleexpn) /* <=== jpc_abstorelstepsize */ \n{\n\tint p;\n\tuint_fast32_t mant;\n\tuint_fast32_t expn;\n\tint n;\n\n\tif (absdelta < 0) {\n\t\tabort();\n\t}\n\n\tp = jpc_fix_firstone(absdelta) - JPC_FIX_FRACBITS;\n\tn = 11 - jpc_fix_firstone(absdelta);\n\tmant = ((n < 0) ? (absdelta >> (-n)) : (absdelta << n)) & 0x7ff;\n\texpn = scaleexpn - p;\n\tif (scaleexpn < p) {\n\t\tabort();\n\t}\n\treturn JPC_QCX_EXPN(expn) | JPC_QCX_MANT(mant);\n}",
        "start_line": 166
      },
      {
        "filename": "src/libjasper/jpc/jpc_enc.c",
        "method_name": "jpc_enc_encodemainhdr",
        "raw_code": "static int jpc_enc_encodemainhdr(jpc_enc_t *enc) /* <=== jpc_enc_encodemainhdr */ \n{\n\tjpc_siz_t *siz;\n\tjpc_cod_t *cod;\n\tjpc_qcd_t *qcd;\n\tint i;\nlong startoff;\nlong mainhdrlen;\n\tjpc_enc_cp_t *cp;\n\tjpc_qcc_t *qcc;\n\tjpc_enc_tccp_t *tccp;\n\tuint_fast16_t cmptno;\n\tjpc_tsfb_band_t bandinfos[JPC_MAXBANDS];\n\tjpc_fix_t mctsynweight;\n\tjpc_enc_tcp_t *tcp;\n\tjpc_tsfb_t *tsfb;\n\tjpc_tsfb_band_t *bandinfo;\n\tuint_fast16_t numbands;\n\tuint_fast16_t bandno;\n\tuint_fast16_t rlvlno;\n\tuint_fast16_t analgain;\n\tjpc_fix_t absstepsize;\n\tchar buf[1024];\n\tjpc_com_t *com;\n\n\tcp = enc->cp;\n\nstartoff = jas_stream_getrwcount(enc->out);\n\n\t/* Write SOC marker segment. */\n\tif (!(enc->mrk = jpc_ms_create(JPC_MS_SOC))) {\n\t\tjas_eprintf(\"cannot create SOC marker\\n\");\n\t\treturn -1;\n\t}\n\tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {\n\t\tjas_eprintf(\"cannot write SOC marker\\n\");\n\t\treturn -1;\n\t}\n\tjpc_ms_destroy(enc->mrk);\n\tenc->mrk = 0;\n\n\t/* Write SIZ marker segment. */\n\tif (!(enc->mrk = jpc_ms_create(JPC_MS_SIZ))) {\n\t\tjas_eprintf(\"cannot create SIZ marker\\n\");\n\t\treturn -1;\n\t}\n\tsiz = &enc->mrk->parms.siz;\n\tsiz->caps = 0;\n\tsiz->xoff = cp->imgareatlx;\n\tsiz->yoff = cp->imgareatly;\n\tsiz->width = cp->refgrdwidth;\n\tsiz->height = cp->refgrdheight;\n\tsiz->tilexoff = cp->tilegrdoffx;\n\tsiz->tileyoff = cp->tilegrdoffy;\n\tsiz->tilewidth = cp->tilewidth;\n\tsiz->tileheight = cp->tileheight;\n\tsiz->numcomps = cp->numcmpts;\n\tsiz->comps = jas_alloc2(siz->numcomps, sizeof(jpc_sizcomp_t));\n\tassert(siz->comps);\n\tfor (i = 0; i < JAS_CAST(int, cp->numcmpts); ++i) {\n\t\tsiz->comps[i].prec = cp->ccps[i].prec;\n\t\tsiz->comps[i].sgnd = cp->ccps[i].sgnd;\n\t\tsiz->comps[i].hsamp = cp->ccps[i].sampgrdstepx;\n\t\tsiz->comps[i].vsamp = cp->ccps[i].sampgrdstepy;\n\t}\n\tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {\n\t\tjas_eprintf(\"cannot write SIZ marker\\n\");\n\t\treturn -1;\n\t}\n\tjpc_ms_destroy(enc->mrk);\n\tenc->mrk = 0;\n\n\tif (!(enc->mrk = jpc_ms_create(JPC_MS_COM))) {\n\t\tjas_eprintf(\"cannot create COM marker\\n\");\n\t\treturn -1;\n\t}\n\tsprintf(buf, \"Creator: JasPer Version %s\", jas_getversion());\n\tcom = &enc->mrk->parms.com;\n\tcom->len = JAS_CAST(uint_fast16_t, strlen(buf));\n\tcom->regid = JPC_COM_LATIN;\n\tif (!(com->data = JAS_CAST(jas_uchar *, jas_strdup(buf)))) {\n\t\tabort();\n\t}\n\tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {\n\t\tjas_eprintf(\"cannot write COM marker\\n\");\n\t\treturn -1;\n\t}\n\tjpc_ms_destroy(enc->mrk);\n\tenc->mrk = 0;\n\n#if 0\n\tif (!(enc->mrk = jpc_ms_create(JPC_MS_CRG))) {\n\t\treturn -1;\n\t}\n\tcrg = &enc->mrk->parms.crg;\n\tcrg->comps = jas_alloc2(crg->numcomps, sizeof(jpc_crgcomp_t));\n\tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {\n\t\tjas_eprintf(\"cannot write CRG marker\\n\");\n\t\treturn -1;\n\t}\n\tjpc_ms_destroy(enc->mrk);\n\tenc->mrk = 0;\n#endif\n\n\ttcp = &cp->tcp;\n\ttccp = &cp->tccp;\n\tfor (cmptno = 0; cmptno < cp->numcmpts; ++cmptno) {\n\t\ttsfb = jpc_cod_gettsfb(tccp->qmfbid, tccp->maxrlvls - 1);\n\t\tjpc_tsfb_getbands(tsfb, 0, 0, 1 << tccp->maxrlvls, 1 << tccp->maxrlvls,\n\t\t  bandinfos);\n\t\tjpc_tsfb_destroy(tsfb);\n\t\tmctsynweight = jpc_mct_getsynweight(tcp->mctid, cmptno);\n\t\tnumbands = 3 * tccp->maxrlvls - 2;\n\t\tfor (bandno = 0, bandinfo = bandinfos; bandno < numbands;\n\t\t  ++bandno, ++bandinfo) {\n\t\t\trlvlno = (bandno) ? ((bandno - 1) / 3 + 1) : 0;\n\t\t\tanalgain = JPC_NOMINALGAIN(tccp->qmfbid, tccp->maxrlvls,\n\t\t\t  rlvlno, bandinfo->orient);\n\t\t\tif (!tcp->intmode) {\n\t\t\t\tabsstepsize = jpc_fix_div(jpc_inttofix(1 <<\n\t\t\t\t  (analgain + 1)), bandinfo->synenergywt);\n\t\t\t} else {\n\t\t\t\tabsstepsize = jpc_inttofix(1);\n\t\t\t}\t\n\t\t\tcp->ccps[cmptno].stepsizes[bandno] =\n\t\t\t  jpc_abstorelstepsize(absstepsize,\n\t\t\t  cp->ccps[cmptno].prec + analgain);\n\t\t}\n\t\tcp->ccps[cmptno].numstepsizes = numbands;\n\t}\n\n\tif (!(enc->mrk = jpc_ms_create(JPC_MS_COD))) {\n\t\tjas_eprintf(\"cannot create COD marker\\n\");\n\t\treturn -1;\n\t}\n\tcod = &enc->mrk->parms.cod;\n\tcod->csty = cp->tccp.csty | cp->tcp.csty;\n\tcod->compparms.csty = cp->tccp.csty | cp->tcp.csty;\n\tcod->compparms.numdlvls = cp->tccp.maxrlvls - 1;\n\tcod->compparms.numrlvls = cp->tccp.maxrlvls;\n\tcod->prg = cp->tcp.prg;\n\tcod->numlyrs = cp->tcp.numlyrs;\n\tcod->compparms.cblkwidthval = JPC_COX_CBLKSIZEEXPN(cp->tccp.cblkwidthexpn);\n\tcod->compparms.cblkheightval = JPC_COX_CBLKSIZEEXPN(cp->tccp.cblkheightexpn);\n\tcod->compparms.cblksty = cp->tccp.cblksty;\n\tcod->compparms.qmfbid = cp->tccp.qmfbid;\n\tcod->mctrans = (cp->tcp.mctid != JPC_MCT_NONE);\n\tif (tccp->csty & JPC_COX_PRT) {\n\t\tfor (rlvlno = 0; rlvlno < tccp->maxrlvls; ++rlvlno) {\n\t\t\tcod->compparms.rlvls[rlvlno].parwidthval = tccp->prcwidthexpns[rlvlno];\n\t\t\tcod->compparms.rlvls[rlvlno].parheightval = tccp->prcheightexpns[rlvlno];\n\t\t}\n\t}\n\tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {\n\t\tjas_eprintf(\"cannot write COD marker\\n\");\n\t\treturn -1;\n\t}\n\tjpc_ms_destroy(enc->mrk);\n\tenc->mrk = 0;\n\n\tif (!(enc->mrk = jpc_ms_create(JPC_MS_QCD))) {\n\t\tjas_eprintf(\"cannot create QCD marker\\n\");\n\t\treturn -1;\n\t}\n\tqcd = &enc->mrk->parms.qcd;\n\tqcd->compparms.qntsty = (tccp->qmfbid == JPC_COX_INS) ?\n\t  JPC_QCX_SEQNT : JPC_QCX_NOQNT;\n\tqcd->compparms.numstepsizes = cp->ccps[0].numstepsizes;\n\tqcd->compparms.numguard = cp->tccp.numgbits;\n\tqcd->compparms.stepsizes = cp->ccps[0].stepsizes;\n\tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {\n\t\tjas_eprintf(\"cannot write marker\\n\");\n\t\treturn -1;\n\t}\n\t/* We do not want the step size array to be freed! */\n\tqcd->compparms.stepsizes = 0;\n\tjpc_ms_destroy(enc->mrk);\n\tenc->mrk = 0;\n\n\ttccp = &cp->tccp;\n\tfor (cmptno = 1; cmptno < cp->numcmpts; ++cmptno) {\n\t\tif (!(enc->mrk = jpc_ms_create(JPC_MS_QCC))) {\n\t\t\tjas_eprintf(\"cannot create QCC marker\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tqcc = &enc->mrk->parms.qcc;\n\t\tqcc->compno = cmptno;\n\t\tqcc->compparms.qntsty = (tccp->qmfbid == JPC_COX_INS) ?\n\t\t  JPC_QCX_SEQNT : JPC_QCX_NOQNT;\n\t\tqcc->compparms.numstepsizes = cp->ccps[cmptno].numstepsizes;\n\t\tqcc->compparms.numguard = cp->tccp.numgbits;\n\t\tqcc->compparms.stepsizes = cp->ccps[cmptno].stepsizes;\n\t\tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {\n\t\t\tjas_eprintf(\"cannot write marker\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\t/* We do not want the step size array to be freed! */\n\t\tqcc->compparms.stepsizes = 0;\n\t\tjpc_ms_destroy(enc->mrk);\n\t\tenc->mrk = 0;\n\t}\n\n#define MAINTLRLEN\t2\n\tmainhdrlen = jas_stream_getrwcount(enc->out) - startoff;\n\tenc->len += mainhdrlen;\n\tif (enc->cp->totalsize != UINT_FAST32_MAX) {\n\t\tuint_fast32_t overhead;\n\t\toverhead = mainhdrlen + MAINTLRLEN;\n\t\tenc->mainbodysize = (enc->cp->totalsize >= overhead) ?\n\t\t  (enc->cp->totalsize - overhead) : 0;\n\t} else {\n\t\tenc->mainbodysize = UINT_FAST32_MAX;\n\t}\n\n\treturn 0;\n}",
        "start_line": 870
      },
      {
        "filename": "src/libjasper/jpc/jpc_enc.c",
        "method_name": "jpc_enc_encodemainbody",
        "raw_code": "static int jpc_enc_encodemainbody(jpc_enc_t *enc) /* <=== jpc_enc_encodemainbody */ \n{\n\tint tileno;\n\tint tilex;\n\tint tiley;\n\tint i;\n\tjpc_sot_t *sot;\n\tjpc_enc_tcmpt_t *comp;\n\tjpc_enc_tcmpt_t *endcomps;\n\tjpc_enc_band_t *band;\n\tjpc_enc_band_t *endbands;\n\tjpc_enc_rlvl_t *lvl;\n\tint rlvlno;\n\tjpc_qcc_t *qcc;\n\tjpc_cod_t *cod;\n\tint adjust;\n\tint j;\n\tint absbandno;\n\tlong numbytes;\n\tlong tilehdrlen;\n\tlong tilelen;\n\tjpc_enc_tile_t *tile;\n\tjpc_enc_cp_t *cp;\n\tdouble rho;\n\tint lyrno;\n\tint cmptno;\n\tint samestepsizes;\n\tjpc_enc_ccp_t *ccps;\n\tjpc_enc_tccp_t *tccp;\n\tint bandno;\n\tuint_fast32_t x;\n\tuint_fast32_t y;\n\tint mingbits;\n\tint actualnumbps;\n\tjpc_fix_t mxmag;\n\tjpc_fix_t mag;\n\tint numgbits;\n\n\tcp = enc->cp;\n\n\t/* Avoid compile warnings. */\n\tnumbytes = 0;\n\n\tfor (tileno = 0; tileno < JAS_CAST(int, cp->numtiles); ++tileno) {\n\t\ttilex = tileno % cp->numhtiles;\n\t\ttiley = tileno / cp->numhtiles;\n\n\t\tif (!(enc->curtile = jpc_enc_tile_create(enc->cp, enc->image,\n\t\t  tileno))) {\n\t\t\tjas_eprintf(\"cannot create tile\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\ttile = enc->curtile;\n\n\t\tif (jas_getdbglevel() >= 10) {\n\t\t\tjpc_enc_dump(enc);\n\t\t}\n\n\t\tendcomps = &tile->tcmpts[tile->numtcmpts];\n\t\tfor (cmptno = 0, comp = tile->tcmpts; cmptno < tile->numtcmpts; ++cmptno, ++comp) {\n\t\t\tif (!cp->ccps[cmptno].sgnd) {\n\t\t\t\tadjust = 1 << (cp->ccps[cmptno].prec - 1);\n\t\t\t\tfor (i = 0; i < jas_matrix_numrows(comp->data); ++i) {\n\t\t\t\t\tfor (j = 0; j < jas_matrix_numcols(comp->data); ++j) {\n\t\t\t\t\t\t*jas_matrix_getref(comp->data, i, j) -= adjust;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!tile->intmode) {\n\t\t\t\tendcomps = &tile->tcmpts[tile->numtcmpts];\n\t\t\t\tfor (comp = tile->tcmpts; comp != endcomps; ++comp) {\n\t\t\t\t\tjas_matrix_asl(comp->data, JPC_FIX_FRACBITS);\n\t\t\t\t}\n\t\t}\n\n\t\tswitch (tile->mctid) {\n\t\tcase JPC_MCT_RCT:\nassert(jas_image_numcmpts(enc->image) == 3);\n\t\t\tjpc_rct(tile->tcmpts[0].data, tile->tcmpts[1].data,\n\t\t\t  tile->tcmpts[2].data);\n\t\t\tbreak;\n\t\tcase JPC_MCT_ICT:\nassert(jas_image_numcmpts(enc->image) == 3);\n\t\t\tjpc_ict(tile->tcmpts[0].data, tile->tcmpts[1].data,\n\t\t\t  tile->tcmpts[2].data);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < jas_image_numcmpts(enc->image); ++i) {\n\t\t\tcomp = &tile->tcmpts[i];\n\t\t\tjpc_tsfb_analyze(comp->tsfb, comp->data);\n\n\t\t}\n\n\n\t\tendcomps = &tile->tcmpts[tile->numtcmpts];\n\t\tfor (cmptno = 0, comp = tile->tcmpts; comp != endcomps; ++cmptno, ++comp) {\n\t\t\tmingbits = 0;\n\t\t\tabsbandno = 0;\n\t\t\t/* All bands must have a corresponding quantizer step size,\n\t\t\t  even if they contain no samples and are never coded. */\n\t\t\t/* Some bands may not be hit by the loop below, so we must\n\t\t\t  initialize all of the step sizes to a sane value. */\n\t\t\tmemset(comp->stepsizes, 0, sizeof(comp->stepsizes));\n\t\t\tfor (rlvlno = 0, lvl = comp->rlvls; rlvlno < comp->numrlvls; ++rlvlno, ++lvl) {\n\t\t\t\tif (!lvl->bands) {\n\t\t\t\t\tabsbandno += rlvlno ? 3 : 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tendbands = &lvl->bands[lvl->numbands];\n\t\t\t\tfor (band = lvl->bands; band != endbands; ++band) {\n\t\t\t\t\tif (!band->data) {\n\t\t\t\t\t\t++absbandno;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tactualnumbps = 0;\n\t\t\t\t\tmxmag = 0;\n\t\t\t\t\tfor (y = 0; y < JAS_CAST(uint_fast32_t, jas_matrix_numrows(band->data)); ++y) {\n\t\t\t\t\t\tfor (x = 0; x < JAS_CAST(uint_fast32_t, jas_matrix_numcols(band->data)); ++x) {\n\t\t\t\t\t\t\tmag = JAS_ABS(jas_matrix_get(band->data, y, x));\n\t\t\t\t\t\t\tif (mag > mxmag) {\n\t\t\t\t\t\t\t\tmxmag = mag;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (tile->intmode) {\n\t\t\t\t\t\tactualnumbps = jpc_fix_firstone(mxmag) + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tactualnumbps = jpc_fix_firstone(mxmag) + 1 - JPC_FIX_FRACBITS;\n\t\t\t\t\t}\n\t\t\t\t\tnumgbits = actualnumbps - (cp->ccps[cmptno].prec - 1 +\n\t\t\t\t\t  band->analgain);\n#if 0\njas_eprintf(\"%d %d mag=%d actual=%d numgbits=%d\\n\", cp->ccps[cmptno].prec, band->analgain, mxmag, actualnumbps, numgbits);\n#endif\n\t\t\t\t\tif (numgbits > mingbits) {\n\t\t\t\t\t\tmingbits = numgbits;\n\t\t\t\t\t}\n\t\t\t\t\tif (!tile->intmode) {\n\t\t\t\t\t\tband->absstepsize = jpc_fix_div(jpc_inttofix(1\n\t\t\t\t\t\t  << (band->analgain + 1)),\n\t\t\t\t\t\t  band->synweight);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tband->absstepsize = jpc_inttofix(1);\n\t\t\t\t\t}\n\t\t\t\t\tband->stepsize = jpc_abstorelstepsize(\n\t\t\t\t\t  band->absstepsize, cp->ccps[cmptno].prec +\n\t\t\t\t\t  band->analgain);\n\t\t\t\t\tband->numbps = cp->tccp.numgbits +\n\t\t\t\t\t  JPC_QCX_GETEXPN(band->stepsize) - 1;\n\n\t\t\t\t\tif ((!tile->intmode) && band->data) {\n\t\t\t\t\t\tjpc_quantize(band->data, band->absstepsize);\n\t\t\t\t\t}\n\n\t\t\t\t\tcomp->stepsizes[absbandno] = band->stepsize;\n\t\t\t\t\t++absbandno;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tassert(JPC_FIX_FRACBITS >= JPC_NUMEXTRABITS);\n\t\t\tif (!tile->intmode) {\n\t\t\t\tjas_matrix_divpow2(comp->data, JPC_FIX_FRACBITS - JPC_NUMEXTRABITS);\n\t\t\t} else {\n\t\t\t\tjas_matrix_asl(comp->data, JPC_NUMEXTRABITS);\n\t\t\t}\n\n#if 0\njas_eprintf(\"mingbits %d\\n\", mingbits);\n#endif\n\t\t\tif (mingbits > cp->tccp.numgbits) {\n\t\t\t\tjas_eprintf(\"error: too few guard bits (need at least %d)\\n\",\n\t\t\t\t  mingbits);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (!(enc->tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tjas_eprintf(\"cannot open tmp file\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Write the tile header. */\n\t\tif (!(enc->mrk = jpc_ms_create(JPC_MS_SOT))) {\n\t\t\treturn -1;\n\t\t}\n\t\tsot = &enc->mrk->parms.sot;\n\t\tsot->len = 0;\n\t\tsot->tileno = tileno;\n\t\tsot->partno = 0;\n\t\tsot->numparts = 1;\n\t\tif (jpc_putms(enc->tmpstream, enc->cstate, enc->mrk)) {\n\t\t\tjas_eprintf(\"cannot write SOT marker\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_ms_destroy(enc->mrk);\n\t\tenc->mrk = 0;\n\n/************************************************************************/\n/************************************************************************/\n/************************************************************************/\n\n\t\ttccp = &cp->tccp;\n\t\tfor (cmptno = 0; cmptno < JAS_CAST(int, cp->numcmpts); ++cmptno) {\n\t\t\tcomp = &tile->tcmpts[cmptno];\n\t\t\tif (comp->numrlvls != tccp->maxrlvls) {\n\t\t\t\tif (!(enc->mrk = jpc_ms_create(JPC_MS_COD))) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n/* XXX = this is not really correct. we are using comp #0's precint sizes\nand other characteristics */\n\t\t\t\tcomp = &tile->tcmpts[0];\n\t\t\t\tcod = &enc->mrk->parms.cod;\n\t\t\t\tcod->compparms.csty = 0;\n\t\t\t\tcod->compparms.numdlvls = comp->numrlvls - 1;\n\t\t\t\tcod->prg = tile->prg;\n\t\t\t\tcod->numlyrs = tile->numlyrs;\n\t\t\t\tcod->compparms.cblkwidthval = JPC_COX_CBLKSIZEEXPN(comp->cblkwidthexpn);\n\t\t\t\tcod->compparms.cblkheightval = JPC_COX_CBLKSIZEEXPN(comp->cblkheightexpn);\n\t\t\t\tcod->compparms.cblksty = comp->cblksty;\n\t\t\t\tcod->compparms.qmfbid = comp->qmfbid;\n\t\t\t\tcod->mctrans = (tile->mctid != JPC_MCT_NONE);\n\t\t\t\tfor (i = 0; i < comp->numrlvls; ++i) {\n\t\t\t\t\tcod->compparms.rlvls[i].parwidthval = comp->rlvls[i].prcwidthexpn;\n\t\t\t\t\tcod->compparms.rlvls[i].parheightval = comp->rlvls[i].prcheightexpn;\n\t\t\t\t}\n\t\t\t\tif (jpc_putms(enc->tmpstream, enc->cstate, enc->mrk)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tjpc_ms_destroy(enc->mrk);\n\t\t\t\tenc->mrk = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor (cmptno = 0, comp = tile->tcmpts; cmptno < JAS_CAST(int,\n\t\t  cp->numcmpts); ++cmptno, ++comp) {\n\t\t\tccps = &cp->ccps[cmptno];\n\t\t\tif (JAS_CAST(int, ccps->numstepsizes) == comp->numstepsizes) {\n\t\t\t\tsamestepsizes = 1;\n\t\t\t\tfor (bandno = 0; bandno < JAS_CAST(int, ccps->numstepsizes);\n\t\t\t\t  ++bandno) {\n\t\t\t\t\tif (ccps->stepsizes[bandno] != comp->stepsizes[bandno]) {\n\t\t\t\t\t\tsamestepsizes = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsamestepsizes = 0;\n\t\t\t}\n\t\t\tif (!samestepsizes) {\n\t\t\t\tif (!(enc->mrk = jpc_ms_create(JPC_MS_QCC))) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tqcc = &enc->mrk->parms.qcc;\n\t\t\t\tqcc->compno = cmptno;\n\t\t\t\tqcc->compparms.numguard = cp->tccp.numgbits;\n\t\t\t\tqcc->compparms.qntsty = (comp->qmfbid == JPC_COX_INS) ?\n\t\t\t\t  JPC_QCX_SEQNT : JPC_QCX_NOQNT;\n\t\t\t\tqcc->compparms.numstepsizes = comp->numstepsizes;\n\t\t\t\tqcc->compparms.stepsizes = comp->stepsizes;\n\t\t\t\tif (jpc_putms(enc->tmpstream, enc->cstate, enc->mrk)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tqcc->compparms.stepsizes = 0;\n\t\t\t\tjpc_ms_destroy(enc->mrk);\n\t\t\t\tenc->mrk = 0;\n\t\t\t}\n\t\t}\n\n\t\t/* Write a SOD marker to indicate the end of the tile header. */\n\t\tif (!(enc->mrk = jpc_ms_create(JPC_MS_SOD))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jpc_putms(enc->tmpstream, enc->cstate, enc->mrk)) {\n\t\t\tjas_eprintf(\"cannot write SOD marker\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_ms_destroy(enc->mrk);\n\t\tenc->mrk = 0;\n\t\ttilehdrlen = jas_stream_getrwcount(enc->tmpstream);\n\t\tassert(tilehdrlen >= 0);\n\n/************************************************************************/\n/************************************************************************/\n/************************************************************************/\n\n\t\tif (jpc_enc_enccblks(enc)) {\n\t\t\tabort();\n\t\t\treturn -1;\n\t\t}\n\n\t\tcp = enc->cp;\n\t\trho = (double) (tile->brx - tile->tlx) * (tile->bry - tile->tly) /\n\t\t  ((cp->refgrdwidth - cp->imgareatlx) * (cp->refgrdheight -\n\t\t  cp->imgareatly));\n\t\ttile->rawsize = cp->rawsize * rho;\n\n\t\tfor (lyrno = 0; lyrno < tile->numlyrs - 1; ++lyrno) {\n\t\t\ttile->lyrsizes[lyrno] = tile->rawsize * jpc_fixtodbl(\n\t\t\t  cp->tcp.ilyrrates[lyrno]);\n\t\t}\n#if !defined(__clang__)\n\t\t// WARNING:\n\t\t// Some versions of Clang (e.g., 3.7.1 and 3.8.1) appear to generate\n\t\t// incorrect code for the following line.\n\t\ttile->lyrsizes[tile->numlyrs - 1] =\n\t\t  (cp->totalsize != UINT_FAST32_MAX) ?\n\t\t  (rho * enc->mainbodysize) : UINT_FAST32_MAX;\n#else\n\t\tif (cp->totalsize != UINT_FAST32_MAX) {\n\t\t\ttile->lyrsizes[tile->numlyrs - 1] = (rho * enc->mainbodysize);\n\t\t} else {\n\t\t\ttile->lyrsizes[tile->numlyrs - 1] = UINT_FAST32_MAX;\n\t\t}\n#endif\n//jas_eprintf(\"TESTING %ld %ld\\n\", cp->totalsize != UINT_FAST32_MAX, tile->lyrsizes[0]);\n\t\tfor (lyrno = 0; lyrno < tile->numlyrs; ++lyrno) {\n\t\t\tif (tile->lyrsizes[lyrno] != UINT_FAST32_MAX) {\n\t\t\t\tif (JAS_CAST(uint_fast32_t, tilehdrlen) <= tile->lyrsizes[lyrno]) {\n\t\t\t\t\ttile->lyrsizes[lyrno] -= tilehdrlen;\n\t\t\t\t} else {\n\t\t\t\t\ttile->lyrsizes[lyrno] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (rateallocate(enc, tile->numlyrs, tile->lyrsizes)) {\n\t\t\treturn -1;\n\t\t}\n\n#if 0\njas_eprintf(\"ENCODE TILE DATA\\n\");\n#endif\n\t\tif (jpc_enc_encodetiledata(enc)) {\n\t\t\tjas_eprintf(\"dotile failed\\n\");\n\t\t\treturn -1;\n\t\t}\n\n/************************************************************************/\n/************************************************************************/\n/************************************************************************/\n\n/************************************************************************/\n/************************************************************************/\n/************************************************************************/\n\n\t\ttilelen = jas_stream_tell(enc->tmpstream);\n\n\t\tif (jas_stream_seek(enc->tmpstream, 6, SEEK_SET) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_putuint32(enc->tmpstream, tilelen);\n\n\t\tif (jas_stream_seek(enc->tmpstream, 0, SEEK_SET) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jpc_putdata(enc->out, enc->tmpstream, -1)) {\n\t\t\treturn -1;\n\t\t}\n\t\tenc->len += tilelen;\n\n\t\tjas_stream_close(enc->tmpstream);\n\t\tenc->tmpstream = 0;\n\n\t\tjpc_enc_tile_destroy(enc->curtile);\n\t\tenc->curtile = 0;\n\n\t}\n\n\treturn 0;\n}",
        "start_line": 1087
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "src/libjasper/jpc/jpc_enc.c",
        "method_name": "jpc_abstorelstepsize",
        "raw_code": "static uint_fast32_t jpc_abstorelstepsize(jpc_fix_t absdelta, int scaleexpn) /* <=== jpc_abstorelstepsize */ \n{\n\tint p;\n\tuint_fast32_t mant;\n\tuint_fast32_t expn;\n\tint n;\n\n\tif (absdelta < 0) {\n\t\treturn UINT_FAST32_MAX;\n\t}\n\n\tp = jpc_fix_firstone(absdelta) - JPC_FIX_FRACBITS;\n\tn = 11 - jpc_fix_firstone(absdelta);\n\tmant = ((n < 0) ? (absdelta >> (-n)) : (absdelta << n)) & 0x7ff;\n\texpn = scaleexpn - p;\n\tif (scaleexpn < p) {\n\t\treturn UINT_FAST32_MAX;\n\t}\n\tif (expn >= 0x1f)\n\t\treturn UINT_FAST32_MAX;\n\treturn JPC_QCX_EXPN(expn) | JPC_QCX_MANT(mant);\n}",
        "start_line": 169
      },
      {
        "filename": "src/libjasper/jpc/jpc_enc.c",
        "method_name": "jpc_enc_encodemainhdr",
        "raw_code": "static int jpc_enc_encodemainhdr(jpc_enc_t *enc) /* <=== jpc_enc_encodemainhdr */ \n{\n\tjpc_siz_t *siz;\n\tjpc_cod_t *cod;\n\tjpc_qcd_t *qcd;\n\tint i;\nlong startoff;\nlong mainhdrlen;\n\tjpc_enc_cp_t *cp;\n\tjpc_qcc_t *qcc;\n\tjpc_enc_tccp_t *tccp;\n\tuint_fast16_t cmptno;\n\tjpc_tsfb_band_t bandinfos[JPC_MAXBANDS];\n\tjpc_fix_t mctsynweight;\n\tjpc_enc_tcp_t *tcp;\n\tjpc_tsfb_t *tsfb;\n\tjpc_tsfb_band_t *bandinfo;\n\tuint_fast16_t numbands;\n\tuint_fast16_t bandno;\n\tuint_fast16_t rlvlno;\n\tuint_fast16_t analgain;\n\tjpc_fix_t absstepsize;\n\tchar buf[1024];\n\tjpc_com_t *com;\n\n\tcp = enc->cp;\n\nstartoff = jas_stream_getrwcount(enc->out);\n\n\t/* Write SOC marker segment. */\n\tif (!(enc->mrk = jpc_ms_create(JPC_MS_SOC))) {\n\t\tjas_eprintf(\"cannot create SOC marker\\n\");\n\t\treturn -1;\n\t}\n\tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {\n\t\tjas_eprintf(\"cannot write SOC marker\\n\");\n\t\treturn -1;\n\t}\n\tjpc_ms_destroy(enc->mrk);\n\tenc->mrk = 0;\n\n\t/* Write SIZ marker segment. */\n\tif (!(enc->mrk = jpc_ms_create(JPC_MS_SIZ))) {\n\t\tjas_eprintf(\"cannot create SIZ marker\\n\");\n\t\treturn -1;\n\t}\n\tsiz = &enc->mrk->parms.siz;\n\tsiz->caps = 0;\n\tsiz->xoff = cp->imgareatlx;\n\tsiz->yoff = cp->imgareatly;\n\tsiz->width = cp->refgrdwidth;\n\tsiz->height = cp->refgrdheight;\n\tsiz->tilexoff = cp->tilegrdoffx;\n\tsiz->tileyoff = cp->tilegrdoffy;\n\tsiz->tilewidth = cp->tilewidth;\n\tsiz->tileheight = cp->tileheight;\n\tsiz->numcomps = cp->numcmpts;\n\tsiz->comps = jas_alloc2(siz->numcomps, sizeof(jpc_sizcomp_t));\n\tassert(siz->comps);\n\tfor (i = 0; i < JAS_CAST(int, cp->numcmpts); ++i) {\n\t\tsiz->comps[i].prec = cp->ccps[i].prec;\n\t\tsiz->comps[i].sgnd = cp->ccps[i].sgnd;\n\t\tsiz->comps[i].hsamp = cp->ccps[i].sampgrdstepx;\n\t\tsiz->comps[i].vsamp = cp->ccps[i].sampgrdstepy;\n\t}\n\tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {\n\t\tjas_eprintf(\"cannot write SIZ marker\\n\");\n\t\treturn -1;\n\t}\n\tjpc_ms_destroy(enc->mrk);\n\tenc->mrk = 0;\n\n\tif (!(enc->mrk = jpc_ms_create(JPC_MS_COM))) {\n\t\tjas_eprintf(\"cannot create COM marker\\n\");\n\t\treturn -1;\n\t}\n\tsprintf(buf, \"Creator: JasPer Version %s\", jas_getversion());\n\tcom = &enc->mrk->parms.com;\n\tcom->len = JAS_CAST(uint_fast16_t, strlen(buf));\n\tcom->regid = JPC_COM_LATIN;\n\tif (!(com->data = JAS_CAST(jas_uchar *, jas_strdup(buf)))) {\n\t\tabort();\n\t}\n\tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {\n\t\tjas_eprintf(\"cannot write COM marker\\n\");\n\t\treturn -1;\n\t}\n\tjpc_ms_destroy(enc->mrk);\n\tenc->mrk = 0;\n\n#if 0\n\tif (!(enc->mrk = jpc_ms_create(JPC_MS_CRG))) {\n\t\treturn -1;\n\t}\n\tcrg = &enc->mrk->parms.crg;\n\tcrg->comps = jas_alloc2(crg->numcomps, sizeof(jpc_crgcomp_t));\n\tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {\n\t\tjas_eprintf(\"cannot write CRG marker\\n\");\n\t\treturn -1;\n\t}\n\tjpc_ms_destroy(enc->mrk);\n\tenc->mrk = 0;\n#endif\n\n\ttcp = &cp->tcp;\n\ttccp = &cp->tccp;\n\tfor (cmptno = 0; cmptno < cp->numcmpts; ++cmptno) {\n\t\ttsfb = jpc_cod_gettsfb(tccp->qmfbid, tccp->maxrlvls - 1);\n\t\tjpc_tsfb_getbands(tsfb, 0, 0, 1 << tccp->maxrlvls, 1 << tccp->maxrlvls,\n\t\t  bandinfos);\n\t\tjpc_tsfb_destroy(tsfb);\n\t\tmctsynweight = jpc_mct_getsynweight(tcp->mctid, cmptno);\n\t\tnumbands = 3 * tccp->maxrlvls - 2;\n\t\tfor (bandno = 0, bandinfo = bandinfos; bandno < numbands;\n\t\t  ++bandno, ++bandinfo) {\n\t\t\trlvlno = (bandno) ? ((bandno - 1) / 3 + 1) : 0;\n\t\t\tanalgain = JPC_NOMINALGAIN(tccp->qmfbid, tccp->maxrlvls,\n\t\t\t  rlvlno, bandinfo->orient);\n\t\t\tif (!tcp->intmode) {\n\t\t\t\tabsstepsize = jpc_fix_div(jpc_inttofix(1 <<\n\t\t\t\t  (analgain + 1)), bandinfo->synenergywt);\n\t\t\t} else {\n\t\t\t\tabsstepsize = jpc_inttofix(1);\n\t\t\t}\t\n\t\t\tconst uint_fast32_t stepsize =\n\t\t\t  jpc_abstorelstepsize(absstepsize,\n\t\t\t  cp->ccps[cmptno].prec + analgain);\n\t\t\tif (stepsize == UINT_FAST32_MAX)\n\t\t\t\treturn -1;\n\t\t\tcp->ccps[cmptno].stepsizes[bandno] = stepsize;\n\t\t}\n\t\tcp->ccps[cmptno].numstepsizes = numbands;\n\t}\n\n\tif (!(enc->mrk = jpc_ms_create(JPC_MS_COD))) {\n\t\tjas_eprintf(\"cannot create COD marker\\n\");\n\t\treturn -1;\n\t}\n\tcod = &enc->mrk->parms.cod;\n\tcod->csty = cp->tccp.csty | cp->tcp.csty;\n\tcod->compparms.csty = cp->tccp.csty | cp->tcp.csty;\n\tcod->compparms.numdlvls = cp->tccp.maxrlvls - 1;\n\tcod->compparms.numrlvls = cp->tccp.maxrlvls;\n\tcod->prg = cp->tcp.prg;\n\tcod->numlyrs = cp->tcp.numlyrs;\n\tcod->compparms.cblkwidthval = JPC_COX_CBLKSIZEEXPN(cp->tccp.cblkwidthexpn);\n\tcod->compparms.cblkheightval = JPC_COX_CBLKSIZEEXPN(cp->tccp.cblkheightexpn);\n\tcod->compparms.cblksty = cp->tccp.cblksty;\n\tcod->compparms.qmfbid = cp->tccp.qmfbid;\n\tcod->mctrans = (cp->tcp.mctid != JPC_MCT_NONE);\n\tif (tccp->csty & JPC_COX_PRT) {\n\t\tfor (rlvlno = 0; rlvlno < tccp->maxrlvls; ++rlvlno) {\n\t\t\tcod->compparms.rlvls[rlvlno].parwidthval = tccp->prcwidthexpns[rlvlno];\n\t\t\tcod->compparms.rlvls[rlvlno].parheightval = tccp->prcheightexpns[rlvlno];\n\t\t}\n\t}\n\tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {\n\t\tjas_eprintf(\"cannot write COD marker\\n\");\n\t\treturn -1;\n\t}\n\tjpc_ms_destroy(enc->mrk);\n\tenc->mrk = 0;\n\n\tif (!(enc->mrk = jpc_ms_create(JPC_MS_QCD))) {\n\t\tjas_eprintf(\"cannot create QCD marker\\n\");\n\t\treturn -1;\n\t}\n\tqcd = &enc->mrk->parms.qcd;\n\tqcd->compparms.qntsty = (tccp->qmfbid == JPC_COX_INS) ?\n\t  JPC_QCX_SEQNT : JPC_QCX_NOQNT;\n\tqcd->compparms.numstepsizes = cp->ccps[0].numstepsizes;\n\tqcd->compparms.numguard = cp->tccp.numgbits;\n\tqcd->compparms.stepsizes = cp->ccps[0].stepsizes;\n\tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {\n\t\tjas_eprintf(\"cannot write marker\\n\");\n\t\treturn -1;\n\t}\n\t/* We do not want the step size array to be freed! */\n\tqcd->compparms.stepsizes = 0;\n\tjpc_ms_destroy(enc->mrk);\n\tenc->mrk = 0;\n\n\ttccp = &cp->tccp;\n\tfor (cmptno = 1; cmptno < cp->numcmpts; ++cmptno) {\n\t\tif (!(enc->mrk = jpc_ms_create(JPC_MS_QCC))) {\n\t\t\tjas_eprintf(\"cannot create QCC marker\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tqcc = &enc->mrk->parms.qcc;\n\t\tqcc->compno = cmptno;\n\t\tqcc->compparms.qntsty = (tccp->qmfbid == JPC_COX_INS) ?\n\t\t  JPC_QCX_SEQNT : JPC_QCX_NOQNT;\n\t\tqcc->compparms.numstepsizes = cp->ccps[cmptno].numstepsizes;\n\t\tqcc->compparms.numguard = cp->tccp.numgbits;\n\t\tqcc->compparms.stepsizes = cp->ccps[cmptno].stepsizes;\n\t\tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {\n\t\t\tjas_eprintf(\"cannot write marker\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\t/* We do not want the step size array to be freed! */\n\t\tqcc->compparms.stepsizes = 0;\n\t\tjpc_ms_destroy(enc->mrk);\n\t\tenc->mrk = 0;\n\t}\n\n#define MAINTLRLEN\t2\n\tmainhdrlen = jas_stream_getrwcount(enc->out) - startoff;\n\tenc->len += mainhdrlen;\n\tif (enc->cp->totalsize != UINT_FAST32_MAX) {\n\t\tuint_fast32_t overhead;\n\t\toverhead = mainhdrlen + MAINTLRLEN;\n\t\tenc->mainbodysize = (enc->cp->totalsize >= overhead) ?\n\t\t  (enc->cp->totalsize - overhead) : 0;\n\t} else {\n\t\tenc->mainbodysize = UINT_FAST32_MAX;\n\t}\n\n\treturn 0;\n}",
        "start_line": 875
      },
      {
        "filename": "src/libjasper/jpc/jpc_enc.c",
        "method_name": "jpc_enc_encodemainbody",
        "raw_code": "static int jpc_enc_encodemainbody(jpc_enc_t *enc) /* <=== jpc_enc_encodemainbody */ \n{\n\tint tileno;\n\tint tilex;\n\tint tiley;\n\tint i;\n\tjpc_sot_t *sot;\n\tjpc_enc_tcmpt_t *comp;\n\tjpc_enc_tcmpt_t *endcomps;\n\tjpc_enc_band_t *band;\n\tjpc_enc_band_t *endbands;\n\tjpc_enc_rlvl_t *lvl;\n\tint rlvlno;\n\tjpc_qcc_t *qcc;\n\tjpc_cod_t *cod;\n\tint adjust;\n\tint j;\n\tint absbandno;\n\tlong numbytes;\n\tlong tilehdrlen;\n\tlong tilelen;\n\tjpc_enc_tile_t *tile;\n\tjpc_enc_cp_t *cp;\n\tdouble rho;\n\tint lyrno;\n\tint cmptno;\n\tint samestepsizes;\n\tjpc_enc_ccp_t *ccps;\n\tjpc_enc_tccp_t *tccp;\n\tint bandno;\n\tuint_fast32_t x;\n\tuint_fast32_t y;\n\tint mingbits;\n\tint actualnumbps;\n\tjpc_fix_t mxmag;\n\tjpc_fix_t mag;\n\tint numgbits;\n\n\tcp = enc->cp;\n\n\t/* Avoid compile warnings. */\n\tnumbytes = 0;\n\n\tfor (tileno = 0; tileno < JAS_CAST(int, cp->numtiles); ++tileno) {\n\t\ttilex = tileno % cp->numhtiles;\n\t\ttiley = tileno / cp->numhtiles;\n\n\t\tif (!(enc->curtile = jpc_enc_tile_create(enc->cp, enc->image,\n\t\t  tileno))) {\n\t\t\tjas_eprintf(\"cannot create tile\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\ttile = enc->curtile;\n\n\t\tif (jas_getdbglevel() >= 10) {\n\t\t\tjpc_enc_dump(enc);\n\t\t}\n\n\t\tendcomps = &tile->tcmpts[tile->numtcmpts];\n\t\tfor (cmptno = 0, comp = tile->tcmpts; cmptno < tile->numtcmpts; ++cmptno, ++comp) {\n\t\t\tif (!cp->ccps[cmptno].sgnd) {\n\t\t\t\tadjust = 1 << (cp->ccps[cmptno].prec - 1);\n\t\t\t\tfor (i = 0; i < jas_matrix_numrows(comp->data); ++i) {\n\t\t\t\t\tfor (j = 0; j < jas_matrix_numcols(comp->data); ++j) {\n\t\t\t\t\t\t*jas_matrix_getref(comp->data, i, j) -= adjust;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!tile->intmode) {\n\t\t\t\tendcomps = &tile->tcmpts[tile->numtcmpts];\n\t\t\t\tfor (comp = tile->tcmpts; comp != endcomps; ++comp) {\n\t\t\t\t\tjas_matrix_asl(comp->data, JPC_FIX_FRACBITS);\n\t\t\t\t}\n\t\t}\n\n\t\tswitch (tile->mctid) {\n\t\tcase JPC_MCT_RCT:\nassert(jas_image_numcmpts(enc->image) == 3);\n\t\t\tjpc_rct(tile->tcmpts[0].data, tile->tcmpts[1].data,\n\t\t\t  tile->tcmpts[2].data);\n\t\t\tbreak;\n\t\tcase JPC_MCT_ICT:\nassert(jas_image_numcmpts(enc->image) == 3);\n\t\t\tjpc_ict(tile->tcmpts[0].data, tile->tcmpts[1].data,\n\t\t\t  tile->tcmpts[2].data);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < jas_image_numcmpts(enc->image); ++i) {\n\t\t\tcomp = &tile->tcmpts[i];\n\t\t\tjpc_tsfb_analyze(comp->tsfb, comp->data);\n\n\t\t}\n\n\n\t\tendcomps = &tile->tcmpts[tile->numtcmpts];\n\t\tfor (cmptno = 0, comp = tile->tcmpts; comp != endcomps; ++cmptno, ++comp) {\n\t\t\tmingbits = 0;\n\t\t\tabsbandno = 0;\n\t\t\t/* All bands must have a corresponding quantizer step size,\n\t\t\t  even if they contain no samples and are never coded. */\n\t\t\t/* Some bands may not be hit by the loop below, so we must\n\t\t\t  initialize all of the step sizes to a sane value. */\n\t\t\tmemset(comp->stepsizes, 0, sizeof(comp->stepsizes));\n\t\t\tfor (rlvlno = 0, lvl = comp->rlvls; rlvlno < comp->numrlvls; ++rlvlno, ++lvl) {\n\t\t\t\tif (!lvl->bands) {\n\t\t\t\t\tabsbandno += rlvlno ? 3 : 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tendbands = &lvl->bands[lvl->numbands];\n\t\t\t\tfor (band = lvl->bands; band != endbands; ++band) {\n\t\t\t\t\tif (!band->data) {\n\t\t\t\t\t\t++absbandno;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tactualnumbps = 0;\n\t\t\t\t\tmxmag = 0;\n\t\t\t\t\tfor (y = 0; y < JAS_CAST(uint_fast32_t, jas_matrix_numrows(band->data)); ++y) {\n\t\t\t\t\t\tfor (x = 0; x < JAS_CAST(uint_fast32_t, jas_matrix_numcols(band->data)); ++x) {\n\t\t\t\t\t\t\tmag = JAS_ABS(jas_matrix_get(band->data, y, x));\n\t\t\t\t\t\t\tif (mag > mxmag) {\n\t\t\t\t\t\t\t\tmxmag = mag;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (tile->intmode) {\n\t\t\t\t\t\tactualnumbps = jpc_fix_firstone(mxmag) + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tactualnumbps = jpc_fix_firstone(mxmag) + 1 - JPC_FIX_FRACBITS;\n\t\t\t\t\t}\n\t\t\t\t\tnumgbits = actualnumbps - (cp->ccps[cmptno].prec - 1 +\n\t\t\t\t\t  band->analgain);\n#if 0\njas_eprintf(\"%d %d mag=%d actual=%d numgbits=%d\\n\", cp->ccps[cmptno].prec, band->analgain, mxmag, actualnumbps, numgbits);\n#endif\n\t\t\t\t\tif (numgbits > mingbits) {\n\t\t\t\t\t\tmingbits = numgbits;\n\t\t\t\t\t}\n\t\t\t\t\tif (!tile->intmode) {\n\t\t\t\t\t\tband->absstepsize = jpc_fix_div(jpc_inttofix(1\n\t\t\t\t\t\t  << (band->analgain + 1)),\n\t\t\t\t\t\t  band->synweight);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tband->absstepsize = jpc_inttofix(1);\n\t\t\t\t\t}\n\t\t\t\t\tconst uint_fast32_t stepsize = jpc_abstorelstepsize(\n\t\t\t\t\t  band->absstepsize, cp->ccps[cmptno].prec +\n\t\t\t\t\t  band->analgain);\n\t\t\t\t\tif (stepsize == UINT_FAST32_MAX)\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\tband->stepsize = stepsize;\n\t\t\t\t\tband->numbps = cp->tccp.numgbits +\n\t\t\t\t\t  JPC_QCX_GETEXPN(band->stepsize) - 1;\n\n\t\t\t\t\tif ((!tile->intmode) && band->data) {\n\t\t\t\t\t\tjpc_quantize(band->data, band->absstepsize);\n\t\t\t\t\t}\n\n\t\t\t\t\tcomp->stepsizes[absbandno] = band->stepsize;\n\t\t\t\t\t++absbandno;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tassert(JPC_FIX_FRACBITS >= JPC_NUMEXTRABITS);\n\t\t\tif (!tile->intmode) {\n\t\t\t\tjas_matrix_divpow2(comp->data, JPC_FIX_FRACBITS - JPC_NUMEXTRABITS);\n\t\t\t} else {\n\t\t\t\tjas_matrix_asl(comp->data, JPC_NUMEXTRABITS);\n\t\t\t}\n\n#if 0\njas_eprintf(\"mingbits %d\\n\", mingbits);\n#endif\n\t\t\tif (mingbits > cp->tccp.numgbits) {\n\t\t\t\tjas_eprintf(\"error: too few guard bits (need at least %d)\\n\",\n\t\t\t\t  mingbits);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (!(enc->tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tjas_eprintf(\"cannot open tmp file\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Write the tile header. */\n\t\tif (!(enc->mrk = jpc_ms_create(JPC_MS_SOT))) {\n\t\t\treturn -1;\n\t\t}\n\t\tsot = &enc->mrk->parms.sot;\n\t\tsot->len = 0;\n\t\tsot->tileno = tileno;\n\t\tsot->partno = 0;\n\t\tsot->numparts = 1;\n\t\tif (jpc_putms(enc->tmpstream, enc->cstate, enc->mrk)) {\n\t\t\tjas_eprintf(\"cannot write SOT marker\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_ms_destroy(enc->mrk);\n\t\tenc->mrk = 0;\n\n/************************************************************************/\n/************************************************************************/\n/************************************************************************/\n\n\t\ttccp = &cp->tccp;\n\t\tfor (cmptno = 0; cmptno < JAS_CAST(int, cp->numcmpts); ++cmptno) {\n\t\t\tcomp = &tile->tcmpts[cmptno];\n\t\t\tif (comp->numrlvls != tccp->maxrlvls) {\n\t\t\t\tif (!(enc->mrk = jpc_ms_create(JPC_MS_COD))) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n/* XXX = this is not really correct. we are using comp #0's precint sizes\nand other characteristics */\n\t\t\t\tcomp = &tile->tcmpts[0];\n\t\t\t\tcod = &enc->mrk->parms.cod;\n\t\t\t\tcod->compparms.csty = 0;\n\t\t\t\tcod->compparms.numdlvls = comp->numrlvls - 1;\n\t\t\t\tcod->prg = tile->prg;\n\t\t\t\tcod->numlyrs = tile->numlyrs;\n\t\t\t\tcod->compparms.cblkwidthval = JPC_COX_CBLKSIZEEXPN(comp->cblkwidthexpn);\n\t\t\t\tcod->compparms.cblkheightval = JPC_COX_CBLKSIZEEXPN(comp->cblkheightexpn);\n\t\t\t\tcod->compparms.cblksty = comp->cblksty;\n\t\t\t\tcod->compparms.qmfbid = comp->qmfbid;\n\t\t\t\tcod->mctrans = (tile->mctid != JPC_MCT_NONE);\n\t\t\t\tfor (i = 0; i < comp->numrlvls; ++i) {\n\t\t\t\t\tcod->compparms.rlvls[i].parwidthval = comp->rlvls[i].prcwidthexpn;\n\t\t\t\t\tcod->compparms.rlvls[i].parheightval = comp->rlvls[i].prcheightexpn;\n\t\t\t\t}\n\t\t\t\tif (jpc_putms(enc->tmpstream, enc->cstate, enc->mrk)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tjpc_ms_destroy(enc->mrk);\n\t\t\t\tenc->mrk = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor (cmptno = 0, comp = tile->tcmpts; cmptno < JAS_CAST(int,\n\t\t  cp->numcmpts); ++cmptno, ++comp) {\n\t\t\tccps = &cp->ccps[cmptno];\n\t\t\tif (JAS_CAST(int, ccps->numstepsizes) == comp->numstepsizes) {\n\t\t\t\tsamestepsizes = 1;\n\t\t\t\tfor (bandno = 0; bandno < JAS_CAST(int, ccps->numstepsizes);\n\t\t\t\t  ++bandno) {\n\t\t\t\t\tif (ccps->stepsizes[bandno] != comp->stepsizes[bandno]) {\n\t\t\t\t\t\tsamestepsizes = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsamestepsizes = 0;\n\t\t\t}\n\t\t\tif (!samestepsizes) {\n\t\t\t\tif (!(enc->mrk = jpc_ms_create(JPC_MS_QCC))) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tqcc = &enc->mrk->parms.qcc;\n\t\t\t\tqcc->compno = cmptno;\n\t\t\t\tqcc->compparms.numguard = cp->tccp.numgbits;\n\t\t\t\tqcc->compparms.qntsty = (comp->qmfbid == JPC_COX_INS) ?\n\t\t\t\t  JPC_QCX_SEQNT : JPC_QCX_NOQNT;\n\t\t\t\tqcc->compparms.numstepsizes = comp->numstepsizes;\n\t\t\t\tqcc->compparms.stepsizes = comp->stepsizes;\n\t\t\t\tif (jpc_putms(enc->tmpstream, enc->cstate, enc->mrk)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tqcc->compparms.stepsizes = 0;\n\t\t\t\tjpc_ms_destroy(enc->mrk);\n\t\t\t\tenc->mrk = 0;\n\t\t\t}\n\t\t}\n\n\t\t/* Write a SOD marker to indicate the end of the tile header. */\n\t\tif (!(enc->mrk = jpc_ms_create(JPC_MS_SOD))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jpc_putms(enc->tmpstream, enc->cstate, enc->mrk)) {\n\t\t\tjas_eprintf(\"cannot write SOD marker\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_ms_destroy(enc->mrk);\n\t\tenc->mrk = 0;\n\t\ttilehdrlen = jas_stream_getrwcount(enc->tmpstream);\n\t\tassert(tilehdrlen >= 0);\n\n/************************************************************************/\n/************************************************************************/\n/************************************************************************/\n\n\t\tif (jpc_enc_enccblks(enc)) {\n\t\t\tabort();\n\t\t\treturn -1;\n\t\t}\n\n\t\tcp = enc->cp;\n\t\trho = (double) (tile->brx - tile->tlx) * (tile->bry - tile->tly) /\n\t\t  ((cp->refgrdwidth - cp->imgareatlx) * (cp->refgrdheight -\n\t\t  cp->imgareatly));\n\t\ttile->rawsize = cp->rawsize * rho;\n\n\t\tfor (lyrno = 0; lyrno < tile->numlyrs - 1; ++lyrno) {\n\t\t\ttile->lyrsizes[lyrno] = tile->rawsize * jpc_fixtodbl(\n\t\t\t  cp->tcp.ilyrrates[lyrno]);\n\t\t}\n#if !defined(__clang__)\n\t\t// WARNING:\n\t\t// Some versions of Clang (e.g., 3.7.1 and 3.8.1) appear to generate\n\t\t// incorrect code for the following line.\n\t\ttile->lyrsizes[tile->numlyrs - 1] =\n\t\t  (cp->totalsize != UINT_FAST32_MAX) ?\n\t\t  (rho * enc->mainbodysize) : UINT_FAST32_MAX;\n#else\n\t\tif (cp->totalsize != UINT_FAST32_MAX) {\n\t\t\ttile->lyrsizes[tile->numlyrs - 1] = (rho * enc->mainbodysize);\n\t\t} else {\n\t\t\ttile->lyrsizes[tile->numlyrs - 1] = UINT_FAST32_MAX;\n\t\t}\n#endif\n//jas_eprintf(\"TESTING %ld %ld\\n\", cp->totalsize != UINT_FAST32_MAX, tile->lyrsizes[0]);\n\t\tfor (lyrno = 0; lyrno < tile->numlyrs; ++lyrno) {\n\t\t\tif (tile->lyrsizes[lyrno] != UINT_FAST32_MAX) {\n\t\t\t\tif (JAS_CAST(uint_fast32_t, tilehdrlen) <= tile->lyrsizes[lyrno]) {\n\t\t\t\t\ttile->lyrsizes[lyrno] -= tilehdrlen;\n\t\t\t\t} else {\n\t\t\t\t\ttile->lyrsizes[lyrno] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (rateallocate(enc, tile->numlyrs, tile->lyrsizes)) {\n\t\t\treturn -1;\n\t\t}\n\n#if 0\njas_eprintf(\"ENCODE TILE DATA\\n\");\n#endif\n\t\tif (jpc_enc_encodetiledata(enc)) {\n\t\t\tjas_eprintf(\"dotile failed\\n\");\n\t\t\treturn -1;\n\t\t}\n\n/************************************************************************/\n/************************************************************************/\n/************************************************************************/\n\n/************************************************************************/\n/************************************************************************/\n/************************************************************************/\n\n\t\ttilelen = jas_stream_tell(enc->tmpstream);\n\n\t\tif (jas_stream_seek(enc->tmpstream, 6, SEEK_SET) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_putuint32(enc->tmpstream, tilelen);\n\n\t\tif (jas_stream_seek(enc->tmpstream, 0, SEEK_SET) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jpc_putdata(enc->out, enc->tmpstream, -1)) {\n\t\t\treturn -1;\n\t\t}\n\t\tenc->len += tilelen;\n\n\t\tjas_stream_close(enc->tmpstream);\n\t\tenc->tmpstream = 0;\n\n\t\tjpc_enc_tile_destroy(enc->curtile);\n\t\tenc->curtile = 0;\n\n\t}\n\n\treturn 0;\n}",
        "start_line": 1095
      }
    ],
    "code_context": "Called Methods:\n- JAS_STREAM_EOF: #define JAS_STREAM_EOF\t0x0001 /* <=== src/libjasper/include/jasper/jas_stream.h:145:145:JAS_STREAM_EOF:0 */ \n- jpc_fix_asl: #define jpc_fix_asl jas_fast32_asl /* <=== src/libjasper/jpc/jpc_fix.h:125:125:jpc_fix_asl:0 */ \n- JAS_ABS: #define\tJAS_ABS(x) \\ /* <=== src/libjasper/include/jasper/jas_math.h:100:101:JAS_ABS:1 */ \n\t(((x) >= 0) ? (x) : (-(x)))\n- jpc_enc_encpkt: int jpc_enc_encpkt(jpc_enc_t *enc, jas_stream_t *out, int compno, int lvlno, int prcno, int lyrno) /* <=== jpc_enc_encpkt */ \n{\n\tjpc_enc_tcmpt_t *comp;\n\tjpc_enc_rlvl_t *lvl;\n\tjpc_enc_band_t *band;\n\tjpc_enc_band_t *endbands;\n\tjpc_enc_cblk_t *cblk;\n\tjpc_enc_cblk_t *endcblks;\n\tjpc_bitstream_t *outb;\n\tjpc_enc_pass_t *pass;\n\tjpc_enc_pass_t *startpass;\n\tjpc_enc_pass_t *lastpass;\n\tjpc_enc_pass_t *endpass;\n\tjpc_enc_pass_t *endpasses;\n\tint i;\n\tint included;\n\tint ret;\n\tjpc_tagtreenode_t *leaf;\n\tint n;\n\tint t1;\n\tint t2;\n\tint adjust;\n\tint maxadjust;\n\tint datalen;\n\tint numnewpasses;\n\tint passcount;\n\tjpc_enc_tile_t *tile;\n\tjpc_enc_prc_t *prc;\n\tjpc_enc_cp_t *cp;\n\tjpc_ms_t *ms;\n\n\tJAS_DBGLOG(10, (\"encoding packet begin %d %d %d %d\\n\", compno, lvlno,\n\t  prcno, lyrno));\n\n\ttile = enc->curtile;\n\tcp = enc->cp;\n\n\tif (cp->tcp.csty & JPC_COD_SOP) {\n\t\tif (!(ms = jpc_ms_create(JPC_MS_SOP))) {\n\t\t\treturn -1;\n\t\t}\n\t\tms->parms.sop.seqno = jpc_pi_getind(tile->pi);\n\t\tif (jpc_putms(out, enc->cstate, ms)) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_ms_destroy(ms);\n\t}\n\n\tif (!(outb = jpc_bitstream_sopen(out, \"w+\"))) {\n\t\tabort();\n\t}\n\n\tif (jpc_bitstream_putbit(outb, 1) == EOF) {\n\t\treturn -1;\n\t}\n\t//JAS_DBGLOG(10, (\"\\n\"));\n\tJAS_DBGLOG(10, (\"present.\\n\"));\n\n\tcomp = &tile->tcmpts[compno];\n\tlvl = &comp->rlvls[lvlno];\n\tendbands = &lvl->bands[lvl->numbands];\n\tfor (band = lvl->bands; band != endbands; ++band) {\n\t\tif (!band->data) {\n\t\t\tcontinue;\n\t\t}\n\t\tprc = &band->prcs[prcno];\n\t\tif (!prc->cblks) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tendcblks = &prc->cblks[prc->numcblks];\n\t\tfor (cblk = prc->cblks; cblk != endcblks; ++cblk) {\n\t\t\tif (!lyrno) {\n\t\t\t\tleaf = jpc_tagtree_getleaf(prc->nlibtree, cblk - prc->cblks);\n\t\t\t\tjpc_tagtree_setvalue(prc->nlibtree, leaf, cblk->numimsbs);\n\t\t\t}\n\t\t\tpass = cblk->curpass;\n\t\t\tincluded = (pass && pass->lyrno == lyrno);\n\t\t\tif (included && (!cblk->numencpasses)) {\n\t\t\t\tassert(pass->lyrno == lyrno);\n\t\t\t\tleaf = jpc_tagtree_getleaf(prc->incltree,\n\t\t\t\t  cblk - prc->cblks);\n\t\t\t\tjpc_tagtree_setvalue(prc->incltree, leaf, pass->lyrno);\n\t\t\t}\n\t\t}\n\n\t\tendcblks = &prc->cblks[prc->numcblks];\n\t\tfor (cblk = prc->cblks; cblk != endcblks; ++cblk) {\n\t\t\tpass = cblk->curpass;\n\t\t\tincluded = (pass && pass->lyrno == lyrno);\n\t\t\tif (!cblk->numencpasses) {\n\t\t\t\tleaf = jpc_tagtree_getleaf(prc->incltree,\n\t\t\t\t  cblk - prc->cblks);\n\t\t\t\tif (jpc_tagtree_encode(prc->incltree, leaf, lyrno + 1, outb) <\n\t\t\t\t  0) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (jpc_bitstream_putbit(outb, included) == EOF) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tJAS_DBGLOG(10, (\"included=%d \", included));\n\t\t\tif (!included) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!cblk->numencpasses) {\n\t\t\t\ti = 1;\n\t\t\t\tleaf = jpc_tagtree_getleaf(prc->nlibtree, cblk - prc->cblks);\n\t\t\t\tfor (;;) {\n\t\t\t\t\tif ((ret = jpc_tagtree_encode(prc->nlibtree, leaf, i,\n\t\t\t\t\t  outb)) < 0) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tif (ret) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t++i;\n\t\t\t\t}\n\t\t\t\tassert(leaf->known_ && i == leaf->value_ + 1);\n\t\t\t}\n\n\t\t\tendpasses = &cblk->passes[cblk->numpasses];\n\t\t\tstartpass = pass;\n\t\t\tendpass = startpass;\n\t\t\twhile (endpass != endpasses && endpass->lyrno == lyrno){\n\t\t\t\t++endpass;\n\t\t\t}\n\t\t\tnumnewpasses = endpass - startpass;\n\t\t\tif (jpc_putnumnewpasses(outb, numnewpasses)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tJAS_DBGLOG(10, (\"numnewpasses=%d \", numnewpasses));\n\n\t\t\tlastpass = endpass - 1;\n\t\t\tn = startpass->start;\n\t\t\tpasscount = 1;\n\t\t\tmaxadjust = 0;\n\t\t\tfor (pass = startpass; pass != endpass; ++pass) {\n\t\t\t\tif (pass->term || pass == lastpass) {\n\t\t\t\t\tdatalen = pass->end - n;\n\t\t\t\t\tt1 = jpc_int_firstone(datalen) + 1;\n\t\t\t\t\tt2 = cblk->numlenbits + jpc_floorlog2(passcount);\n\t\t\t\t\tadjust = JAS_MAX(t1 - t2, 0);\n\t\t\t\t\tmaxadjust = JAS_MAX(adjust, maxadjust);\n\t\t\t\t\tn += datalen;\n\t\t\t\t\tpasscount = 1;\n\t\t\t\t} else {\n\t\t\t\t\t++passcount;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (jpc_putcommacode(outb, maxadjust)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcblk->numlenbits += maxadjust;\n\n\t\t\tlastpass = endpass - 1;\n\t\t\tn = startpass->start;\n\t\t\tpasscount = 1;\n\t\t\tfor (pass = startpass; pass != endpass; ++pass) {\n\t\t\t\tif (pass->term || pass == lastpass) {\n\t\t\t\t\tdatalen = pass->end - n;\n\t\t\t\t\tassert(jpc_int_firstone(datalen) < cblk->numlenbits +\n\t\t\t\t\t  jpc_floorlog2(passcount));\n\t\t\t\t\tif (jpc_bitstream_putbits(outb, cblk->numlenbits +\n\t\t\t\t\t  jpc_floorlog2(passcount), datalen) == EOF) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tn += datalen;\n\t\t\t\t\tpasscount = 1;\n\t\t\t\t} else {\n\t\t\t\t\t++passcount;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tjpc_bitstream_outalign(outb, 0);\n\tjpc_bitstream_close(outb);\n\n\tif (cp->tcp.csty & JPC_COD_EPH) {\n\t\tif (!(ms = jpc_ms_create(JPC_MS_EPH))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jpc_putms(out, enc->cstate, ms)) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_ms_destroy(ms);\n\t}\n\n\tcomp = &tile->tcmpts[compno];\n\tlvl = &comp->rlvls[lvlno];\n\tendbands = &lvl->bands[lvl->numbands];\n\tfor (band = lvl->bands; band != endbands; ++band) {\n\t\tif (!band->data) {\n\t\t\tcontinue;\n\t\t}\n\t\tprc = &band->prcs[prcno];\n\t\tif (!prc->cblks) {\n\t\t\tcontinue;\n\t\t}\n\t\tendcblks = &prc->cblks[prc->numcblks];\n\t\tfor (cblk = prc->cblks; cblk != endcblks; ++cblk) {\n\t\t\tpass = cblk->curpass;\n\n\t\t\tif (!pass) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (pass->lyrno != lyrno) {\n\t\t\t\tassert(pass->lyrno < 0 || pass->lyrno > lyrno);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tendpasses = &cblk->passes[cblk->numpasses];\n\t\t\tstartpass = pass;\n\t\t\tendpass = startpass;\n\t\t\twhile (endpass != endpasses && endpass->lyrno == lyrno){\n\t\t\t\t++endpass;\n\t\t\t}\n\t\t\tlastpass = endpass - 1;\n\t\t\tnumnewpasses = endpass - startpass;\n\n\t\t\tjas_stream_seek(cblk->stream, startpass->start, SEEK_SET);\n\t\t\tassert(jas_stream_tell(cblk->stream) == startpass->start);\n\t\t\tif (jas_stream_copy(out, cblk->stream, lastpass->end -\n\t\t\t  startpass->start)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcblk->curpass = (endpass != endpasses) ? endpass : 0;\n\t\t\tcblk->numencpasses += numnewpasses;\n\n\t\t}\n\t}\n\n\tJAS_DBGLOG(10, (\"encoding packet end\\n\"));\n\n\treturn 0;\n}\n- JPC_MS_QCD: #define JPC_MS_QCD\t0xff5c /* Quantization default (QCD). */ /* <=== src/libjasper/jpc/jpc_cs.h:644:644:JPC_MS_QCD:0 */ \n- jpc_enc_enccblks: int jpc_enc_enccblks(jpc_enc_t *enc) /* <=== jpc_enc_enccblks */ \n{\n\tjpc_enc_tcmpt_t *tcmpt;\n\tjpc_enc_tcmpt_t *endcomps;\n\tjpc_enc_rlvl_t *lvl;\n\tjpc_enc_rlvl_t *endlvls;\n\tjpc_enc_band_t *band;\n\tjpc_enc_band_t *endbands;\n\tjpc_enc_cblk_t *cblk;\n\tjpc_enc_cblk_t *endcblks;\n\tint i;\n\tint j;\n\tjpc_fix_t mx;\n\tjpc_fix_t bmx;\n\tjpc_fix_t v;\n\tjpc_enc_tile_t *tile;\n\tuint_fast32_t prcno;\n\tjpc_enc_prc_t *prc;\n\n\ttile = enc->curtile;\n\n\tendcomps = &tile->tcmpts[tile->numtcmpts];\n\tfor (tcmpt = tile->tcmpts; tcmpt != endcomps; ++tcmpt) {\n\t\tendlvls = &tcmpt->rlvls[tcmpt->numrlvls];\n\t\tfor (lvl = tcmpt->rlvls; lvl != endlvls; ++lvl) {\n\t\t\tif (!lvl->bands) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tendbands = &lvl->bands[lvl->numbands];\n\t\t\tfor (band = lvl->bands; band != endbands; ++band) {\n\t\t\t\tif (!band->data) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (prcno = 0, prc = band->prcs; prcno < lvl->numprcs; ++prcno, ++prc) {\n\t\t\t\t\tif (!prc->cblks) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tbmx = 0;\n\t\t\t\t\tendcblks = &prc->cblks[prc->numcblks];\n\t\t\t\t\tfor (cblk = prc->cblks; cblk != endcblks; ++cblk) {\n\t\t\t\t\t\tmx = 0;\n\t\t\t\t\t\tfor (i = 0; i < jas_matrix_numrows(cblk->data); ++i) {\n\t\t\t\t\t\t\tfor (j = 0; j < jas_matrix_numcols(cblk->data); ++j) {\n\t\t\t\t\t\t\t\tv = JAS_ABS(jas_matrix_get(cblk->data, i, j));\n\t\t\t\t\t\t\t\tif (v > mx) {\n\t\t\t\t\t\t\t\t\tmx = v;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (mx > bmx) {\n\t\t\t\t\t\t\tbmx = mx;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcblk->numbps = JAS_MAX(jpc_fix_firstone(mx) + 1 - JPC_NUMEXTRABITS, 0);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (cblk = prc->cblks; cblk != endcblks; ++cblk) {\n\t\t\t\t\t\tcblk->numimsbs = band->numbps - cblk->numbps;\n\t\t\t\t\t\tassert(cblk->numimsbs >= 0);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (cblk = prc->cblks; cblk != endcblks; ++cblk) {\n\t\t\t\t\t\tif (jpc_enc_enccblk(tcmpt, band, cblk)) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n- jpc_enc_enccblk: int jpc_enc_enccblk(jpc_enc_tcmpt_t *tcmpt, jpc_enc_band_t *band, jpc_enc_cblk_t *cblk) /* <=== jpc_enc_enccblk */ \n{\n\tjpc_enc_pass_t *pass;\n\tjpc_enc_pass_t *endpasses;\n\tint bitpos;\n\tint n;\n\tint adjust;\n\tint ret;\n\tint passtype;\n\tint t;\n\tjpc_bitstream_t *bout;\n\tjpc_enc_pass_t *termpass;\n\tjpc_enc_rlvl_t *rlvl;\n\tint vcausal;\n\tint segsym;\n\tint termmode;\n\tint c;\n\n\tbout = 0;\n\trlvl = band->rlvl;\n\n\tcblk->stream = jas_stream_memopen(0, 0);\n\tassert(cblk->stream);\n\tcblk->mqenc = jpc_mqenc_create(JPC_NUMCTXS, cblk->stream);\n\tassert(cblk->mqenc);\n\tjpc_mqenc_setctxs(cblk->mqenc, JPC_NUMCTXS, jpc_mqctxs);\n\n\tcblk->numpasses = (cblk->numbps > 0) ? (3 * cblk->numbps - 2) : 0;\n\tif (cblk->numpasses > 0) {\n\t\tcblk->passes = jas_alloc2(cblk->numpasses, sizeof(jpc_enc_pass_t));\n\t\tassert(cblk->passes);\n\t} else {\n\t\tcblk->passes = 0;\n\t}\n\tendpasses = (cblk->passes) ? &cblk->passes[cblk->numpasses] : 0;\n\tfor (pass = cblk->passes; pass != endpasses; ++pass) {\n\t\tpass->start = 0;\n\t\tpass->end = 0;\n\t\tpass->term = JPC_ISTERMINATED(pass - cblk->passes, 0, cblk->numpasses, (tcmpt->cblksty & JPC_COX_TERMALL) != 0, (tcmpt->cblksty & JPC_COX_LAZY) != 0);\n\t\tpass->type = JPC_SEGTYPE(pass - cblk->passes, 0, (tcmpt->cblksty & JPC_COX_LAZY) != 0);\n\t\tpass->lyrno = -1;\nif (pass == endpasses - 1) {\nassert(pass->term == 1);\n\tpass->term = 1;\n}\n\t}\n\n\tcblk->flags = jas_matrix_create(jas_matrix_numrows(cblk->data) + 2,\n\t  jas_matrix_numcols(cblk->data) + 2);\n\tassert(cblk->flags);\n\n\n\tbitpos = cblk->numbps - 1;\n\tpass = cblk->passes;\n\tn = cblk->numpasses;\n\twhile (--n >= 0) {\n\n\t\tif (pass->type == JPC_SEG_MQ) {\n\t\t\t/* NOP */\n\t\t} else {\n\t\t\tassert(pass->type == JPC_SEG_RAW);\n\t\t\tif (!bout) {\n\t\t\t\tbout = jpc_bitstream_sopen(cblk->stream, \"w\");\n\t\t\t\tassert(bout);\n\t\t\t}\n\t\t}\n\n#if 1\n\t\tpasstype = (pass - cblk->passes + 2) % 3;\n#else\n\t\tpasstype = JPC_PASSTYPE(pass - cblk->passes + 2);\n#endif\n\t\tpass->start = jas_stream_tell(cblk->stream);\n#if 0\nassert(jas_stream_tell(cblk->stream) == jas_stream_getrwcount(cblk->stream));\n#endif\n\t\tassert(bitpos >= 0);\n\t\tvcausal = (tcmpt->cblksty & JPC_COX_VSC) != 0;\n\t\tsegsym = (tcmpt->cblksty & JPC_COX_SEGSYM) != 0;\n\t\tif (pass->term) {\n\t\t\ttermmode = ((tcmpt->cblksty & JPC_COX_PTERM) ?\n\t\t\t  JPC_MQENC_PTERM : JPC_MQENC_DEFTERM) + 1;\n\t\t} else {\n\t\t\ttermmode = 0;\n\t\t}\n\t\tswitch (passtype) {\n\t\tcase JPC_SIGPASS:\n\t\t\tret = (pass->type == JPC_SEG_MQ) ? jpc_encsigpass(cblk->mqenc,\n\t\t\t  bitpos, band->orient, vcausal, cblk->flags,\n\t\t\t  cblk->data, termmode, &pass->nmsedec) :\n\t\t\t  jpc_encrawsigpass(bout, bitpos, vcausal, cblk->flags,\n\t\t\t  cblk->data, termmode, &pass->nmsedec);\n\t\t\tbreak;\n\t\tcase JPC_REFPASS:\n\t\t\tret = (pass->type == JPC_SEG_MQ) ? jpc_encrefpass(cblk->mqenc,\n\t\t\t  bitpos, cblk->flags, cblk->data, termmode,\n\t\t\t  &pass->nmsedec) : jpc_encrawrefpass(bout, bitpos,\n\t\t\t  cblk->flags, cblk->data, termmode,\n\t\t\t  &pass->nmsedec);\n\t\t\tbreak;\n\t\tcase JPC_CLNPASS:\n\t\t\tassert(pass->type == JPC_SEG_MQ);\n\t\t\tret = jpc_encclnpass(cblk->mqenc, bitpos, band->orient,\n\t\t\t  vcausal, segsym, cblk->flags, cblk->data, termmode,\n\t\t\t  &pass->nmsedec);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (pass->type == JPC_SEG_MQ) {\n\t\t\tif (pass->term) {\n\t\t\t\tjpc_mqenc_init(cblk->mqenc);\n\t\t\t}\n\t\t\tjpc_mqenc_getstate(cblk->mqenc, &pass->mqencstate);\n\t\t\tpass->end = jas_stream_tell(cblk->stream);\n\t\t\tif (tcmpt->cblksty & JPC_COX_RESET) {\n\t\t\t\tjpc_mqenc_setctxs(cblk->mqenc, JPC_NUMCTXS, jpc_mqctxs);\n\t\t\t}\n\t\t} else {\n\t\t\tif (pass->term) {\n\t\t\t\tif (jpc_bitstream_pending(bout)) {\n\t\t\t\t\tjpc_bitstream_outalign(bout, 0x2a);\n\t\t\t\t}\n\t\t\t\tjpc_bitstream_close(bout);\n\t\t\t\tbout = 0;\n\t\t\t\tpass->end = jas_stream_tell(cblk->stream);\n\t\t\t} else {\n\t\t\t\tpass->end = jas_stream_tell(cblk->stream) +\n\t\t\t\t  jpc_bitstream_pending(bout);\n/* NOTE - This will not work.  need to adjust by # of pending output bytes */\n\t\t\t}\n\t\t}\n#if 0\n/* XXX - This assertion fails sometimes when various coding modes are used.\nThis seems to be harmless, but why does it happen at all? */\nassert(jas_stream_tell(cblk->stream) == jas_stream_getrwcount(cblk->stream));\n#endif\n\n\t\tpass->wmsedec = jpc_fixtodbl(band->rlvl->tcmpt->synweight) *\n\t\t  jpc_fixtodbl(band->rlvl->tcmpt->synweight) *\n\t\t  jpc_fixtodbl(band->synweight) *\n\t\t  jpc_fixtodbl(band->synweight) *\n\t\t  jpc_fixtodbl(band->absstepsize) * jpc_fixtodbl(band->absstepsize) *\n\t\t  ((double) (1 << bitpos)) * ((double)(1 << bitpos)) *\n\t\t  jpc_fixtodbl(pass->nmsedec);\n\t\tpass->cumwmsedec = pass->wmsedec;\n\t\tif (pass != cblk->passes) {\n\t\t\tpass->cumwmsedec += pass[-1].cumwmsedec;\n\t\t}\n\t\tif (passtype == JPC_CLNPASS) {\n\t\t\t--bitpos;\n\t\t}\n\t\t++pass;\n\t}\n\n#if 0\ndump_passes(cblk->passes, cblk->numpasses, cblk);\n#endif\n\n\tn = 0;\n\tendpasses = (cblk->passes) ? &cblk->passes[cblk->numpasses] : 0;\n\tfor (pass = cblk->passes; pass != endpasses; ++pass) {\n\t\tif (pass->start < n) {\n\t\t\tpass->start = n;\n\t\t}\n\t\tif (pass->end < n) {\n\t\t\tpass->end = n;\n\t\t}\n\t\tif (!pass->term) {\n\t\t\ttermpass = pass;\n\t\t\twhile (termpass - pass < cblk->numpasses &&\n\t\t\t  !termpass->term) {\n\t\t\t\t++termpass;\n\t\t\t}\n\t\t\tif (pass->type == JPC_SEG_MQ) {\n\t\t\t\tt = (pass->mqencstate.lastbyte == 0xff) ? 1 : 0;\n\t\t\t\tif (pass->mqencstate.ctreg >= 5) {\n\t\t\t\t\tadjust = 4 + t;\n\t\t\t\t} else {\n\t\t\t\t\tadjust = 5 + t;\n\t\t\t\t}\n\t\t\t\tpass->end += adjust;\n\t\t\t}\n\t\t\tif (pass->end > termpass->end) {\n\t\t\t\tpass->end = termpass->end;\n\t\t\t}\n\t\t\tif ((c = getthebyte(cblk->stream, pass->end - 1)) == EOF) {\n\t\t\t\tabort();\n\t\t\t}\n\t\t\tif (c == 0xff) {\n\t\t\t\t++pass->end;\n\t\t\t}\n\t\t\tn = JAS_MAX(n, pass->end);\n\t\t} else {\n\t\t\tn = JAS_MAX(n, pass->end);\n\t\t}\n\t}\n\n#if 0\ndump_passes(cblk->passes, cblk->numpasses, cblk);\n#endif\n\n\tif (bout) {\n\t\tjpc_bitstream_close(bout);\n\t}\n\n\treturn 0;\n}\n- jpc_cod_gettsfb: jpc_tsfb_t *jpc_cod_gettsfb(int qmfbid, int numlvls) /* <=== jpc_cod_gettsfb */ \n{\n\tjpc_tsfb_t *tsfb;\n\n\tif (!(tsfb = malloc(sizeof(jpc_tsfb_t))))\n\t\treturn 0;\n\n\tif (numlvls > 0) {\n\t\tswitch (qmfbid) {\n\t\tcase JPC_COX_INS:\n\t\t\ttsfb->qmfb = &jpc_ns_qmfb2d;\n\t\t\tbreak;\n\t\tdefault:\n\t\tcase JPC_COX_RFT:\n\t\t\ttsfb->qmfb = &jpc_ft_qmfb2d;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\ttsfb->qmfb = 0;\n\t}\n\ttsfb->numlvls = numlvls;\n\treturn tsfb;\n}\n- jas_stream_flushbuf: int jas_stream_flushbuf(jas_stream_t *stream, int c) /* <=== jas_stream_flushbuf */ \n{\n\tint len;\n\tint n;\n\n\t/* The stream should not be in an error or EOF state. */\n\tif ((stream->flags_ & (JAS_STREAM_ERRMASK)) != 0) {\n\t\treturn EOF;\n\t}\n\n\t/* The stream must be open for writing. */\n\tif ((stream->openmode_ & (JAS_STREAM_WRITE | JAS_STREAM_APPEND)) == 0) {\n\t\treturn EOF;\n\t}\n\n\t/* The buffer should not currently be in use for reading. */\n\tassert(!(stream->bufmode_ & JAS_STREAM_RDBUF));\n\n\t/* Note: Do not use the quantity stream->cnt to determine the number\n\tof characters in the buffer!  Depending on how this function was\n\tcalled, the stream->cnt value may be \"off-by-one\". */\n\tlen = stream->ptr_ - stream->bufstart_;\n\tif (len > 0) {\n\t\tn = (*stream->ops_->write_)(stream->obj_, (char *)\n\t\t  stream->bufstart_, len);\n\t\tif (n != len) {\n\t\t\tstream->flags_ |= JAS_STREAM_ERR;\n\t\t\treturn EOF;\n\t\t}\n\t}\n\tstream->cnt_ = stream->bufsize_;\n\tstream->ptr_ = stream->bufstart_;\n\n\tstream->bufmode_ |= JAS_STREAM_WRBUF;\n\n\tif (c != EOF) {\n\t\tassert(stream->cnt_ > 0);\n\t\treturn jas_stream_putc2(stream, c);\n\t}\n\n\treturn 0;\n}\n- jpc_enc_tile_create: static jpc_enc_tile_t *jpc_enc_tile_create(jpc_enc_cp_t *cp, jas_image_t *image, int tileno) /* <=== jpc_enc_tile_create */ \n{\n\tjpc_enc_tile_t *tile;\n\tuint_fast32_t htileno;\n\tuint_fast32_t vtileno;\n\tuint_fast16_t lyrno;\n\tuint_fast16_t cmptno;\n\tjpc_enc_tcmpt_t *tcmpt;\n\n\tif (!(tile = jas_malloc(sizeof(jpc_enc_tile_t)))) {\n\t\tgoto error;\n\t}\n\n\t/* Initialize a few members used in error recovery. */\n\ttile->tcmpts = 0;\n\ttile->lyrsizes = 0;\n\ttile->numtcmpts = cp->numcmpts;\n\ttile->pi = 0;\n\n\ttile->tileno = tileno;\n\thtileno = tileno % cp->numhtiles;\n\tvtileno = tileno / cp->numhtiles;\n\n\t/* Calculate the coordinates of the top-left and bottom-right\n\t  corners of the tile. */\n\ttile->tlx = JAS_MAX(cp->tilegrdoffx + htileno * cp->tilewidth,\n\t  cp->imgareatlx);\n\ttile->tly = JAS_MAX(cp->tilegrdoffy + vtileno * cp->tileheight,\n\t  cp->imgareatly);\n\ttile->brx = JAS_MIN(cp->tilegrdoffx + (htileno + 1) * cp->tilewidth,\n\t  cp->refgrdwidth);\n\ttile->bry = JAS_MIN(cp->tilegrdoffy + (vtileno + 1) * cp->tileheight,\n\t  cp->refgrdheight);\n\n\t/* Initialize some tile coding parameters. */\n\ttile->intmode = cp->tcp.intmode;\n\ttile->csty = cp->tcp.csty;\n\ttile->prg = cp->tcp.prg;\n\ttile->mctid = cp->tcp.mctid;\n\n\ttile->numlyrs = cp->tcp.numlyrs;\n\tif (!(tile->lyrsizes = jas_alloc2(tile->numlyrs,\n\t  sizeof(uint_fast32_t)))) {\n\t\tgoto error;\n\t}\n\tfor (lyrno = 0; lyrno < tile->numlyrs; ++lyrno) {\n\t\ttile->lyrsizes[lyrno] = 0;\n\t}\n\n\t/* Allocate an array for the per-tile-component information. */\n\tif (!(tile->tcmpts = jas_alloc2(cp->numcmpts, sizeof(jpc_enc_tcmpt_t)))) {\n\t\tgoto error;\n\t}\n\t/* Initialize a few members critical for error recovery. */\n\tfor (cmptno = 0, tcmpt = tile->tcmpts; cmptno < cp->numcmpts;\n\t  ++cmptno, ++tcmpt) {\n\t\ttcmpt->rlvls = 0;\n\t\ttcmpt->tsfb = 0;\n\t\ttcmpt->data = 0;\n\t}\n\t/* Initialize the per-tile-component information. */\n\tfor (cmptno = 0, tcmpt = tile->tcmpts; cmptno < cp->numcmpts;\n\t  ++cmptno, ++tcmpt) {\n\t\tif (!tcmpt_create(tcmpt, cp, image, tile)) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* Initialize the synthesis weights for the MCT. */\n\tswitch (tile->mctid) {\n\tcase JPC_MCT_RCT:\n\t\ttile->tcmpts[0].synweight = jpc_dbltofix(sqrt(3.0));\n\t\ttile->tcmpts[1].synweight = jpc_dbltofix(sqrt(0.6875));\n\t\ttile->tcmpts[2].synweight = jpc_dbltofix(sqrt(0.6875));\n\t\tbreak;\n\tcase JPC_MCT_ICT:\n\t\ttile->tcmpts[0].synweight = jpc_dbltofix(sqrt(3.0000));\n\t\ttile->tcmpts[1].synweight = jpc_dbltofix(sqrt(3.2584));\n\t\ttile->tcmpts[2].synweight = jpc_dbltofix(sqrt(2.4755));\n\t\tbreak;\n\tdefault:\n\tcase JPC_MCT_NONE:\n\t\tfor (cmptno = 0, tcmpt = tile->tcmpts; cmptno < cp->numcmpts;\n\t\t  ++cmptno, ++tcmpt) {\n\t\t\ttcmpt->synweight = JPC_FIX_ONE;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (!(tile->pi = jpc_enc_pi_create(cp, tile))) {\n\t\tgoto error;\n\t}\n\n\treturn tile;\n\nerror:\n\n\tif (tile) {\n\t\tjpc_enc_tile_destroy(tile);\n\t}\n\treturn 0;\n}\n- jas_alloc2: void *jas_alloc2(size_t num_elements, size_t element_size) /* <=== jas_alloc2 */ \n{\n\tsize_t size;\n\tif (!jas_safe_size_mul(num_elements, element_size, &size)) {\n\t\treturn 0;\n\t}\n\treturn jas_malloc(size);\n}\n- jpc_rct: void jpc_rct(jas_matrix_t *c0, jas_matrix_t *c1, jas_matrix_t *c2) /* <=== jpc_rct */ \n{\n\tint numrows;\n\tint numcols;\n\tint i;\n\tint j;\n\tjpc_fix_t *c0p;\n\tjpc_fix_t *c1p;\n\tjpc_fix_t *c2p;\n\n\tnumrows = jas_matrix_numrows(c0);\n\tnumcols = jas_matrix_numcols(c0);\n\n\t/* All three matrices must have the same dimensions. */\n\tassert(jas_matrix_numrows(c1) == numrows && jas_matrix_numcols(c1) == numcols\n\t  && jas_matrix_numrows(c2) == numrows && jas_matrix_numcols(c2) == numcols);\n\n\tfor (i = 0; i < numrows; i++) {\n\t\tc0p = jas_matrix_getref(c0, i, 0);\n\t\tc1p = jas_matrix_getref(c1, i, 0);\n\t\tc2p = jas_matrix_getref(c2, i, 0);\n\t\tfor (j = numcols; j > 0; --j) {\n\t\t\tint r;\n\t\t\tint g;\n\t\t\tint b;\n\t\t\tint y;\n\t\t\tint u;\n\t\t\tint v;\n\t\t\tr = *c0p;\n\t\t\tg = *c1p;\n\t\t\tb = *c2p;\n\t\t\t//y = (r + (g << 1) + b) >> 2;\n\t\t\ty = jpc_fix_asr(r + jpc_fix_asl(g, 1) + b, 2);\n\t\t\tu = b - g;\n\t\t\tv = r - g;\n\t\t\t*c0p++ = y;\n\t\t\t*c1p++ = u;\n\t\t\t*c2p++ = v;\n\t\t}\n\t}\n}\n- jas_stream_flush: int jas_stream_flush(jas_stream_t *stream) /* <=== jas_stream_flush */ \n{\n\tif (stream->bufmode_ & JAS_STREAM_RDBUF) {\n\t\treturn 0;\n\t}\n\treturn jas_stream_flushbuf(stream, EOF);\n}\n- jas_matrix_numcols: #define jas_matrix_numcols(matrix) \\ /* <=== src/libjasper/include/jasper/jas_seq.h:158:159:jas_matrix_numcols:1 */ \n\t((matrix)->numcols_)\n- JPC_TSFB_LL: #define JPC_TSFB_LL\t0 /* <=== src/libjasper/jpc/jpc_tsfb.h:90:90:JPC_TSFB_LL:0 */ \n- jpc_mstab_lookup: static const jpc_mstabent_t *jpc_mstab_lookup(int id) /* <=== jpc_mstab_lookup */ \n{\n\tconst jpc_mstabent_t *mstabent;\n\tfor (mstabent = jpc_mstab;; ++mstabent) {\n\t\tif (mstabent->id == id || mstabent->id < 0) {\n\t\t\treturn mstabent;\n\t\t}\n\t}\n\tassert(0);\n\treturn 0;\n}\n- jas_stream_seek: long jas_stream_seek(jas_stream_t *stream, long offset, int origin) /* <=== jas_stream_seek */ \n{\n\tlong newpos;\n\n\tJAS_DBGLOG(100, (\"jas_stream_seek(%p, %ld, %d)\\n\", stream, offset,\n\t  origin));\n\n\t/* The buffer cannot be in use for both reading and writing. */\n\tassert(!((stream->bufmode_ & JAS_STREAM_RDBUF) && (stream->bufmode_ &\n\t  JAS_STREAM_WRBUF)));\n\n\t/* Reset the EOF indicator (since we may not be at the EOF anymore). */\n\tstream->flags_ &= ~JAS_STREAM_EOF;\n\n\tif (stream->bufmode_ & JAS_STREAM_RDBUF) {\n\t\tif (origin == SEEK_CUR) {\n\t\t\toffset -= stream->cnt_;\n\t\t}\n\t} else if (stream->bufmode_ & JAS_STREAM_WRBUF) {\n\t\tif (jas_stream_flush(stream)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tstream->cnt_ = 0;\n\tstream->ptr_ = stream->bufstart_;\n\tstream->bufmode_ &= ~(JAS_STREAM_RDBUF | JAS_STREAM_WRBUF);\n\n\tif ((newpos = (*stream->ops_->seek_)(stream->obj_, offset, origin))\n\t  < 0) {\n\t\treturn -1;\n\t}\n\n\treturn newpos;\n}\n- jas_matrix_rowstep: #define\tjas_matrix_rowstep(matrix) \\ /* <=== src/libjasper/include/jasper/jas_seq.h:233:234:jas_matrix_rowstep:1 */ \n\t(((matrix)->numrows_ > 1) ? ((matrix)->rows_[1] - (matrix)->rows_[0]) : (0))\n- jas_image_numcmpts: #define\tjas_image_numcmpts(image) \\ /* <=== src/libjasper/include/jasper/jas_image.h:350:351:jas_image_numcmpts:1 */ \n\t((image)->numcmpts_)\n- JPC_NUMEXTRABITS: #define\tJPC_NUMEXTRABITS\tJPC_NMSEDEC_FRACBITS /* <=== src/libjasper/jpc/jpc_enc.h:90:90:JPC_NUMEXTRABITS:0 */ \n- JAS_STREAM_RDBUF: #define JAS_STREAM_RDBUF\t0x0010 /* <=== src/libjasper/include/jasper/jas_stream.h:136:136:JAS_STREAM_RDBUF:0 */ \n- JAS_STREAM_WRBUF: #define JAS_STREAM_WRBUF\t0x0020 /* <=== src/libjasper/include/jasper/jas_stream.h:138:138:JAS_STREAM_WRBUF:0 */ \n- jpc_save_t2state: void jpc_save_t2state(jpc_enc_t *enc) /* <=== jpc_save_t2state */ \n{\n/* stream pos in embedded T1 stream may be wrong since not saved/restored! */\n\n\tjpc_enc_tcmpt_t *comp;\n\tjpc_enc_tcmpt_t *endcomps;\n\tjpc_enc_rlvl_t *lvl;\n\tjpc_enc_rlvl_t *endlvls;\n\tjpc_enc_band_t *band;\n\tjpc_enc_band_t *endbands;\n\tjpc_enc_cblk_t *cblk;\n\tjpc_enc_cblk_t *endcblks;\n\tjpc_enc_tile_t *tile;\n\tint prcno;\n\tjpc_enc_prc_t *prc;\n\n\ttile = enc->curtile;\n\n\tendcomps = &tile->tcmpts[tile->numtcmpts];\n\tfor (comp = tile->tcmpts; comp != endcomps; ++comp) {\n\t\tendlvls = &comp->rlvls[comp->numrlvls];\n\t\tfor (lvl = comp->rlvls; lvl != endlvls; ++lvl) {\n\t\t\tif (!lvl->bands) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tendbands = &lvl->bands[lvl->numbands];\n\t\t\tfor (band = lvl->bands; band != endbands; ++band) {\n\t\t\t\tif (!band->data) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (prcno = 0, prc = band->prcs; prcno < lvl->numprcs; ++prcno, ++prc) {\n\t\t\t\t\tif (!prc->cblks) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tjpc_tagtree_copy(prc->savincltree, prc->incltree);\n\t\t\t\t\tjpc_tagtree_copy(prc->savnlibtree, prc->nlibtree);\n\t\t\t\t\tendcblks = &prc->cblks[prc->numcblks];\n\t\t\t\t\tfor (cblk = prc->cblks; cblk != endcblks; ++cblk) {\n\t\t\t\t\t\tcblk->savedcurpass = cblk->curpass;\n\t\t\t\t\t\tcblk->savednumencpasses = cblk->numencpasses;\n\t\t\t\t\t\tcblk->savednumlenbits = cblk->numlenbits;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n- JPC_QCX_EXPN: #define\tJPC_QCX_EXPN(x)\t\t(assert(!((x) & (~0x1f))), (((x) & 0x1f) << 11)) /* <=== src/libjasper/jpc/jpc_cs.h:390:390:JPC_QCX_EXPN:1 */ \n- jas_seq2d_ystart: #define\tjas_seq2d_ystart(s) \\ /* <=== src/libjasper/include/jasper/jas_seq.h:264:265:jas_seq2d_ystart:1 */ \n\t((s)->ystart_)\n- JAS_MIN: #define\tJAS_MIN(x, y) \\ /* <=== src/libjasper/include/jasper/jas_math.h:104:105:JAS_MIN:2 */ \n\t(((x) < (y)) ? (x) : (y))\n- JPC_TSFB_HH: #define JPC_TSFB_HH\t3 /* <=== src/libjasper/jpc/jpc_tsfb.h:93:93:JPC_TSFB_HH:0 */ \n- jpc_fixtodbl: #define jpc_fixtodbl(x)\tJAS_FIXTODBL(jpc_fix_t, JPC_FIX_FRACBITS, x) /* <=== src/libjasper/jpc/jpc_fix.h:111:111:jpc_fixtodbl:1 */ \n- JPC_COX_CBLKSIZEEXPN: #define\tJPC_COX_CBLKSIZEEXPN(x)\t\t((x) - 2) /* <=== src/libjasper/jpc/jpc_cs.h:273:273:JPC_COX_CBLKSIZEEXPN:1 */ \n- jpc_enc_encodetiledata: int jpc_enc_encodetiledata(jpc_enc_t *enc) /* <=== jpc_enc_encodetiledata */ \n{\nassert(enc->tmpstream);\n\tif (jpc_enc_encpkts(enc, enc->tmpstream)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n- JPC_MS_SIZ: #define\tJPC_MS_SIZ\t0xff51 /* Image and tile size (SIZ). */ /* <=== src/libjasper/jpc/jpc_cs.h:638:638:JPC_MS_SIZ:0 */ \n- jas_stream_destroy: static void jas_stream_destroy(jas_stream_t *stream) /* <=== jas_stream_destroy */ \n{\n\tJAS_DBGLOG(100, (\"jas_stream_destroy(%p)\\n\", stream));\n\n\t/* If the memory for the buffer was allocated with malloc, free\n\tthis memory. */\n\tif ((stream->bufmode_ & JAS_STREAM_FREEBUF) && stream->bufbase_) {\n\t\tJAS_DBGLOG(100, (\"jas_stream_destroy freeing buffer %p\\n\",\n\t\t  stream->bufbase_));\n\t\tjas_free(stream->bufbase_);\n\t\tstream->bufbase_ = 0;\n\t}\n\tjas_free(stream);\n}\n- JPC_MS_SOD: #define\tJPC_MS_SOD\t0xff93 /* Start of data (SOD). */ /* <=== src/libjasper/jpc/jpc_cs.h:634:634:JPC_MS_SOD:0 */ \n- JPC_QCX_GETEXPN: #define\tJPC_QCX_GETEXPN(x)\t((x) >> 11) /* <=== src/libjasper/jpc/jpc_cs.h:388:388:JPC_QCX_GETEXPN:1 */ \n- jpc_ict: void jpc_ict(jas_matrix_t *c0, jas_matrix_t *c1, jas_matrix_t *c2) /* <=== jpc_ict */ \n{\n\tint numrows;\n\tint numcols;\n\tint i;\n\tint j;\n\tjpc_fix_t r;\n\tjpc_fix_t g;\n\tjpc_fix_t b;\n\tjpc_fix_t y;\n\tjpc_fix_t u;\n\tjpc_fix_t v;\n\tjpc_fix_t *c0p;\n\tjpc_fix_t *c1p;\n\tjpc_fix_t *c2p;\n\n\tnumrows = jas_matrix_numrows(c0);\n\tassert(jas_matrix_numrows(c1) == numrows && jas_matrix_numrows(c2) == numrows);\n\tnumcols = jas_matrix_numcols(c0);\n\tassert(jas_matrix_numcols(c1) == numcols && jas_matrix_numcols(c2) == numcols);\n\tfor (i = 0; i < numrows; ++i) {\n\t\tc0p = jas_matrix_getref(c0, i, 0);\n\t\tc1p = jas_matrix_getref(c1, i, 0);\n\t\tc2p = jas_matrix_getref(c2, i, 0);\n\t\tfor (j = numcols; j > 0; --j) {\n\t\t\tr = *c0p;\n\t\t\tg = *c1p;\n\t\t\tb = *c2p;\n\t\t\ty = jpc_fix_add3(jpc_fix_mul(jpc_dbltofix(0.299), r), jpc_fix_mul(jpc_dbltofix(0.587), g),\n\t\t\t  jpc_fix_mul(jpc_dbltofix(0.114), b));\n\t\t\tu = jpc_fix_add3(jpc_fix_mul(jpc_dbltofix(-0.16875), r), jpc_fix_mul(jpc_dbltofix(-0.33126), g),\n\t\t\t  jpc_fix_mul(jpc_dbltofix(0.5), b));\n\t\t\tv = jpc_fix_add3(jpc_fix_mul(jpc_dbltofix(0.5), r), jpc_fix_mul(jpc_dbltofix(-0.41869), g),\n\t\t\t  jpc_fix_mul(jpc_dbltofix(-0.08131), b));\n\t\t\t*c0p++ = y;\n\t\t\t*c1p++ = u;\n\t\t\t*c2p++ = v;\n\t\t}\n\t}\n}\n- jpc_inttofix: #define jpc_inttofix(x)\tJAS_INTTOFIX(jpc_fix_t, JPC_FIX_FRACBITS, x) /* <=== src/libjasper/jpc/jpc_fix.h:109:109:jpc_inttofix:1 */ \n- jas_fast32_asl: inline static int jas_fast32_asl(int_fast32_t x, int n) /* <=== jas_fast32_asl */ \n{\n\t// Ensure that the shift of a negative value appears to behave as a\n\t// signed arithmetic shift.\n\tassert(((JAS_CAST(int_fast32_t, -1)) << 1) == JAS_CAST(int_fast32_t, -2));\n\tassert(n >= 0);\n\t// The behavior is undefined when x is negative. */\n\t// We tacitly assume the behavior is equivalent to a signed\n\t// arithmetic left shift.\n\treturn x << n;\n}\n- jpc_fix_div: #define\tjpc_fix_div(x, y) \\ /* <=== src/libjasper/jpc/jpc_fix.h:120:121:jpc_fix_div:2 */ \n\tJAS_FIX_DIV(jpc_fix_t, JPC_FIX_FRACBITS, jpc_fix_big_t, x, y)\n- jpc_mct_getsynweight: jpc_fix_t jpc_mct_getsynweight(int mctid, int cmptno) /* <=== jpc_mct_getsynweight */ \n{\n\tjpc_fix_t synweight;\n\n\tsynweight = JPC_FIX_ONE;\n\tswitch (mctid) {\n\tcase JPC_MCT_RCT:\n\t\tswitch (cmptno) {\n\t\tcase 0:\n\t\t\tsynweight = jpc_dbltofix(sqrt(3.0));\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tsynweight = jpc_dbltofix(sqrt(0.6875));\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tsynweight = jpc_dbltofix(sqrt(0.6875));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase JPC_MCT_ICT:\n\t\tswitch (cmptno) {\n\t\tcase 0:\n\t\t\tsynweight = jpc_dbltofix(sqrt(3.0000));\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tsynweight = jpc_dbltofix(sqrt(3.2584));\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tsynweight = jpc_dbltofix(sqrt(2.4755));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n#if 0\n\tdefault:\n\t\tsynweight = JPC_FIX_ONE;\n\t\tbreak;\n#endif\n\t}\n\n\treturn synweight;\n}\n- jas_seq2d_rowstep: #define\tjas_seq2d_rowstep(s) \\ /* <=== src/libjasper/include/jasper/jas_seq.h:274:275:jas_seq2d_rowstep:1 */ \n\tjas_matrix_rowstep(s)\n- JAS_DBGLOG: #define\tJAS_DBGLOG(n, x) \\ /* <=== src/libjasper/include/jasper/jas_debug.h:94:95:JAS_DBGLOG:2 */ \n\t((jas_getdbglevel() >= (n)) ? (jas_eprintf x) : 0)\n- jpc_tsfb_getbands: int jpc_tsfb_getbands(jpc_tsfb_t *tsfb, uint_fast32_t xstart, /* <=== jpc_tsfb_getbands */ \n  uint_fast32_t ystart, uint_fast32_t xend, uint_fast32_t yend,\n  jpc_tsfb_band_t *bands)\n{\n\tjpc_tsfb_band_t *band;\n\n\tband = bands;\n\tif (tsfb->numlvls > 0) {\n\t\tjpc_tsfb_getbands2(tsfb, xstart, ystart, xstart, ystart, xend, yend,\n\t\t  &band, tsfb->numlvls);\n\t} else {\n\n\t\tband->xstart = xstart;\n\t\tband->ystart = ystart;\n\t\tband->xend = xend;\n\t\tband->yend = yend;\n\t\tband->locxstart = xstart;\n\t\tband->locystart = ystart;\n\t\tband->locxend = band->locxstart + band->xend - band->xstart;\n\t\tband->locyend = band->locystart + band->yend - band->ystart;\n\t\tband->orient = JPC_TSFB_LL;\n\t\tband->synenergywt = JPC_FIX_ONE;\n\t\t++band;\n\t}\n\treturn band - bands;\n}\n- JPC_QCX_MANT: #define\tJPC_QCX_MANT(x)\t\t(assert(!((x) & (~0x7ff))), ((x) & 0x7ff)) /* <=== src/libjasper/jpc/jpc_cs.h:391:391:JPC_QCX_MANT:1 */ \n- jpc_restore_t2state: void jpc_restore_t2state(jpc_enc_t *enc) /* <=== jpc_restore_t2state */ \n{\n\n\tjpc_enc_tcmpt_t *comp;\n\tjpc_enc_tcmpt_t *endcomps;\n\tjpc_enc_rlvl_t *lvl;\n\tjpc_enc_rlvl_t *endlvls;\n\tjpc_enc_band_t *band;\n\tjpc_enc_band_t *endbands;\n\tjpc_enc_cblk_t *cblk;\n\tjpc_enc_cblk_t *endcblks;\n\tjpc_enc_tile_t *tile;\n\tint prcno;\n\tjpc_enc_prc_t *prc;\n\n\ttile = enc->curtile;\n\n\tendcomps = &tile->tcmpts[tile->numtcmpts];\n\tfor (comp = tile->tcmpts; comp != endcomps; ++comp) {\n\t\tendlvls = &comp->rlvls[comp->numrlvls];\n\t\tfor (lvl = comp->rlvls; lvl != endlvls; ++lvl) {\n\t\t\tif (!lvl->bands) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tendbands = &lvl->bands[lvl->numbands];\n\t\t\tfor (band = lvl->bands; band != endbands; ++band) {\n\t\t\t\tif (!band->data) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (prcno = 0, prc = band->prcs; prcno < lvl->numprcs; ++prcno, ++prc) {\n\t\t\t\t\tif (!prc->cblks) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tjpc_tagtree_copy(prc->incltree, prc->savincltree);\n\t\t\t\t\tjpc_tagtree_copy(prc->nlibtree, prc->savnlibtree);\n\t\t\t\t\tendcblks = &prc->cblks[prc->numcblks];\n\t\t\t\t\tfor (cblk = prc->cblks; cblk != endcblks; ++cblk) {\n\t\t\t\t\t\tcblk->curpass = cblk->savedcurpass;\n\t\t\t\t\t\tcblk->numencpasses = cblk->savednumencpasses;\n\t\t\t\t\t\tcblk->numlenbits = cblk->savednumlenbits;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n- jas_matrix_divpow2: void jas_matrix_divpow2(jas_matrix_t *matrix, int n) /* <=== jas_matrix_divpow2 */ \n{\n\tjas_matind_t i;\n\tjas_matind_t j;\n\tjas_seqent_t *rowstart;\n\tjas_matind_t rowstep;\n\tjas_seqent_t *data;\n\n\tif (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {\n\t\tassert(matrix->rows_);\n\t\trowstep = jas_matrix_rowstep(matrix);\n\t\tfor (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,\n\t\t  rowstart += rowstep) {\n\t\t\tfor (j = matrix->numcols_, data = rowstart; j > 0; --j,\n\t\t\t  ++data) {\n\t\t\t\t*data = (*data >= 0) ? ((*data) >> n) :\n\t\t\t\t  (-((-(*data)) >> n));\n\t\t\t}\n\t\t}\n\t}\n}\n- jas_free: void jas_free(void *ptr) /* <=== jas_free */ \n{\n\tJAS_DBGLOG(100, (\"jas_free(%p)\\n\", ptr));\n\tfree(ptr);\n}\n- JAS_MAX: #define\tJAS_MAX(x, y) \\ /* <=== src/libjasper/include/jasper/jas_math.h:108:109:JAS_MAX:2 */ \n\t(((x) > (y)) ? (x) : (y))\n- JPC_COX_RFT: #define\tJPC_COX_RFT\t0x01 /* Reversible 5/3. */ /* <=== src/libjasper/jpc/jpc_cs.h:266:266:JPC_COX_RFT:0 */ \n- jpc_ms_destroy: void jpc_ms_destroy(jpc_ms_t *ms) /* <=== jpc_ms_destroy */ \n{\n\tif (ms->ops && ms->ops->destroyparms) {\n\t\t(*ms->ops->destroyparms)(ms);\n\t}\n\tjas_free(ms);\n}\n- jpc_putuint32: int jpc_putuint32(jas_stream_t *out, uint_fast32_t val) /* <=== jpc_putuint32 */ \n{\n\tif (jas_stream_putc(out, (val >> 24) & 0xff) == EOF ||\n\t  jas_stream_putc(out, (val >> 16) & 0xff) == EOF ||\n\t  jas_stream_putc(out, (val >> 8) & 0xff) == EOF ||\n\t  jas_stream_putc(out, val & 0xff) == EOF) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n- JPC_MCT_NONE: #define JPC_MCT_NONE\t0 /* <=== src/libjasper/jpc/jpc_mct.h:90:90:JPC_MCT_NONE:0 */ \n- jas_matrix_getref: #define\tjas_matrix_getref(matrix, i, j) \\ /* <=== src/libjasper/include/jasper/jas_seq.h:183:184:jas_matrix_getref:3 */ \n\t(&(matrix)->rows_[i][j])\n- jas_deprecated: void jas_deprecated(const char *s) /* <=== jas_deprecated */ \n{\n\tstatic char message[] =\n\t\"WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!!\\n\"\n\t\"WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!!\\n\"\n\t\"WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!!\\n\"\n\t\"YOUR CODE IS RELYING ON DEPRECATED FUNCTIONALTIY IN THE JASPER LIBRARY.\\n\"\n\t\"THIS FUNCTIONALITY WILL BE REMOVED IN THE NEAR FUTURE.\\n\"\n\t\"PLEASE FIX THIS PROBLEM BEFORE YOUR CODE STOPS WORKING!\\n\"\n\t;\n\tjas_eprintf(\"%s\", message);\n\tjas_eprintf(\"The specific problem is as follows:\\n%s\\n\", s);\n\t//abort();\n}\n- jas_eprintf: int jas_eprintf(const char *fmt, ...) /* <=== jas_eprintf */ \n{\n\tint ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}\n- calcrdslopes: void calcrdslopes(jpc_enc_cblk_t *cblk) /* <=== calcrdslopes */ \n{\n\tjpc_enc_pass_t *endpasses;\n\tjpc_enc_pass_t *pass0;\n\tjpc_enc_pass_t *pass1;\n\tjpc_enc_pass_t *pass2;\n\tjpc_flt_t slope0;\n\tjpc_flt_t slope;\n\tjpc_flt_t dd;\n\tlong dr;\n\n\tendpasses = &cblk->passes[cblk->numpasses];\n\tpass2 = cblk->passes;\n\tslope0 = 0;\n\twhile (pass2 != endpasses) {\n\t\tpass0 = 0;\n\t\tfor (pass1 = cblk->passes; pass1 != endpasses; ++pass1) {\n\t\t\tdd = pass1->cumwmsedec;\n\t\t\tdr = pass1->end;\n\t\t\tif (pass0) {\n\t\t\t\tdd -= pass0->cumwmsedec;\n\t\t\t\tdr -= pass0->end;\n\t\t\t}\n\t\t\tif (dd <= 0) {\n\t\t\t\tpass1->rdslope = JPC_BADRDSLOPE;\n\t\t\t\tif (pass1 >= pass2) {\n\t\t\t\t\tpass2 = &pass1[1];\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (pass1 < pass2 && pass1->rdslope <= 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!dr) {\n\t\t\t\tassert(pass0);\n\t\t\t\tpass0->rdslope = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tslope = dd / dr;\n\t\t\tif (pass0 && slope >= slope0) {\n\t\t\t\tpass0->rdslope = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpass1->rdslope = slope;\n\t\t\tif (pass1 >= pass2) {\n\t\t\t\tpass2 = &pass1[1];\n\t\t\t}\n\t\t\tpass0 = pass1;\n\t\t\tslope0 = slope;\n\t\t}\n\t}\n\n#if 0\n\tfor (pass0 = cblk->passes; pass0 != endpasses; ++pass0) {\nif (pass0->rdslope > 0.0) {\n\t\tjas_eprintf(\"pass %02d nmsedec=%lf dec=%lf end=%d %lf\\n\", pass0 - cblk->passes,\n\t\t  fixtodbl(pass0->nmsedec), pass0->wmsedec, pass0->end, pass0->rdslope);\n}\n\t}\n#endif\n}\n- jas_seq2d_height: #define\tjas_seq2d_height(s) \\ /* <=== src/libjasper/include/jasper/jas_seq.h:278:279:jas_seq2d_height:1 */ \n\t((s)->yend_ - (s)->ystart_)\n- jas_stream_getrwcount: #define\tjas_stream_getrwcount(stream) \\ /* <=== src/libjasper/include/jasper/jas_stream.h:337:338:jas_stream_getrwcount:1 */ \n\t(((const jas_stream_t *)(stream))->rwcnt_)\n- tcmpt_destroy: static void tcmpt_destroy(jpc_enc_tcmpt_t *tcmpt) /* <=== tcmpt_destroy */ \n{\n\tjpc_enc_rlvl_t *rlvl;\n\tuint_fast16_t rlvlno;\n\n\tif (tcmpt->rlvls) {\n\t\tfor (rlvlno = 0, rlvl = tcmpt->rlvls; rlvlno < tcmpt->numrlvls;\n\t\t  ++rlvlno, ++rlvl) {\n\t\t\trlvl_destroy(rlvl);\n\t\t}\n\t\tjas_free(tcmpt->rlvls);\n\t\ttcmpt->rlvls = NULL;\n\t}\n\n\tif (tcmpt->data) {\n\t\tjas_seq2d_destroy(tcmpt->data);\n\t\ttcmpt->data = NULL;\n\t}\n\tif (tcmpt->tsfb) {\n\t\tjpc_tsfb_destroy(tcmpt->tsfb);\n\t\ttcmpt->tsfb = NULL;\n\t}\n}\n- JPC_QCX_SEQNT: #define\tJPC_QCX_SEQNT\t2 /* Scalar quantization, explicit. */ /* <=== src/libjasper/jpc/jpc_cs.h:382:382:JPC_QCX_SEQNT:0 */ \n- jpc_pi_destroy: void jpc_pi_destroy(jpc_pi_t *pi) /* <=== jpc_pi_destroy */ \n{\n\tjpc_picomp_t *picomp;\n\tint compno;\n\tif (pi->picomps) {\n\t\tfor (compno = 0, picomp = pi->picomps; compno < pi->numcomps;\n\t\t  ++compno, ++picomp) {\n\t\t\tjpc_picomp_destroy(picomp);\n\t\t}\n\t\tjas_free(pi->picomps);\n\t}\n\tif (pi->pchglist) {\n\t\tjpc_pchglist_destroy(pi->pchglist);\n\t}\n\tjas_free(pi);\n}\n- jpc_tsfb_analyze: int jpc_tsfb_analyze(jpc_tsfb_t *tsfb, jas_seq2d_t *a) /* <=== jpc_tsfb_analyze */ \n{\n\treturn (tsfb->numlvls > 0) ? jpc_tsfb_analyze2(tsfb, jas_seq2d_getref(a,\n\t  jas_seq2d_xstart(a), jas_seq2d_ystart(a)), jas_seq2d_xstart(a),\n\t  jas_seq2d_ystart(a), jas_seq2d_width(a),\n\t  jas_seq2d_height(a), jas_seq2d_rowstep(a), tsfb->numlvls - 1) : 0;\n}\n- jas_stream_memopen: jas_stream_t *jas_stream_memopen(char *buf, int bufsize) /* <=== jas_stream_memopen */ \n{\n\tchar *new_buf;\n\tsize_t new_bufsize;\n\n\tJAS_DBGLOG(100, (\"jas_stream_memopen(%p, %d)\\n\", buf, bufsize));\n\tif (bufsize < 0) {\n\t\tjas_deprecated(\"negative buffer size for jas_stream_memopen\");\n\t}\n\tif (buf && bufsize <= 0) {\n\t\t// This was never a valid thing to do with the old API.\n\t\tjas_eprintf(\"Invalid use of jas_stream_memopen detected.\\n\");\n\t\tjas_deprecated(\"A user-provided buffer for \"\n\t\t  \"jas_stream_memopen cannot be growable.\\n\");\n\t}\n\tif (bufsize <= 0) {\n\t\tnew_bufsize = 0;\n\t\tnew_buf = 0;\n\t} else {\n\t\tnew_bufsize = bufsize;\n\t\tnew_buf = buf;\n\t}\n\treturn jas_stream_memopen2(new_buf, new_bufsize);\n}\n- JPC_MS_COD: #define\tJPC_MS_COD\t0xff52 /* Coding style default (COD). */ /* <=== src/libjasper/jpc/jpc_cs.h:641:641:JPC_MS_COD:0 */ \n- JPC_FIX_FRACBITS: #define JPC_FIX_FRACBITS\t13 /* <=== src/libjasper/jpc/jpc_fix.h:96:96:JPC_FIX_FRACBITS:0 */ \n- JPC_TSFB_HL: #define JPC_TSFB_HL\t2 /* <=== src/libjasper/jpc/jpc_tsfb.h:92:92:JPC_TSFB_HL:0 */ \n- jas_seq2d_xstart: #define\tjas_seq2d_xstart(s) \\ /* <=== src/libjasper/include/jasper/jas_seq.h:262:263:jas_seq2d_xstart:1 */ \n\t((s)->xstart_)\n- jas_seq2d_getref: #define\tjas_seq2d_getref(s, x, y) \\ /* <=== src/libjasper/include/jasper/jas_seq.h:270:271:jas_seq2d_getref:3 */ \n\t(jas_matrix_getref(s, (y) - (s)->ystart_, (x) - (s)->xstart_))\n- jas_fast32_asr: inline static int jas_fast32_asr(int_fast32_t x, int n) /* <=== jas_fast32_asr */ \n{\n\t// Ensure that the shift of a negative value appears to behave as a\n\t// signed arithmetic shift.\n\tassert(((JAS_CAST(int_fast32_t, -1)) >> 1) == JAS_CAST(int_fast32_t, -1));\n\tassert(n >= 0);\n\t// The behavior is undefined when x is negative. */\n\t// We tacitly assume the behavior is equivalent to a signed\n\t// arithmetic right shift.\n\treturn x >> n;\n}\n- JPC_MAXBANDS: #define\tJPC_MAXBANDS\t(3 * JPC_MAXRLVLS + 1) /* <=== src/libjasper/jpc/jpc_cs.h:90:90:JPC_MAXBANDS:0 */ \n- jas_matrix_get: #define jas_matrix_get(matrix, i, j) \\ /* <=== src/libjasper/include/jasper/jas_seq.h:165:166:jas_matrix_get:3 */ \n\t((matrix)->rows_[i][j])\n- jpc_putuint16: int jpc_putuint16(jas_stream_t *out, uint_fast16_t val) /* <=== jpc_putuint16 */ \n{\n\tif (jas_stream_putc(out, (val >> 8) & 0xff) == EOF ||\n\t  jas_stream_putc(out, val & 0xff) == EOF) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n- JPC_QCX_NOQNT: #define\tJPC_QCX_NOQNT\t0 /* No quantization. */ /* <=== src/libjasper/jpc/jpc_cs.h:380:380:JPC_QCX_NOQNT:0 */ \n- jas_malloc: void *jas_malloc(size_t size) /* <=== jas_malloc */ \n{\n\tvoid *result;\n\tJAS_DBGLOG(101, (\"jas_malloc(%zu)\\n\", size));\n\tresult = malloc(size);\n\tJAS_DBGLOG(100, (\"jas_malloc(%zu) -> %p\\n\", size, result));\n\treturn result;\n}\n- jas_seq2d_width: #define\tjas_seq2d_width(s) \\ /* <=== src/libjasper/include/jasper/jas_seq.h:276:277:jas_seq2d_width:1 */ \n\t((s)->xend_ - (s)->xstart_)\n- JPC_MS_SOC: #define\tJPC_MS_SOC\t0xff4f /* Start of code stream (SOC). */ /* <=== src/libjasper/jpc/jpc_cs.h:632:632:JPC_MS_SOC:0 */ \n- jas_getdbglevel: int jas_getdbglevel() /* <=== jas_getdbglevel */ \n{\n\treturn jas_dbglevel;\n}\n- jas_stream_close: int jas_stream_close(jas_stream_t *stream) /* <=== jas_stream_close */ \n{\n\tJAS_DBGLOG(100, (\"jas_stream_close(%p)\\n\", stream));\n\n\t/* Flush buffer if necessary. */\n\tjas_stream_flush(stream);\n\n\t/* Close the underlying stream object. */\n\t(*stream->ops_->close_)(stream->obj_);\n\n\tjas_stream_destroy(stream);\n\n\treturn 0;\n}\n- JPC_MCT_RCT: #define JPC_MCT_RCT\t\t2 /* <=== src/libjasper/jpc/jpc_mct.h:92:92:JPC_MCT_RCT:0 */ \n- jas_stream_tell: long jas_stream_tell(jas_stream_t *stream) /* <=== jas_stream_tell */ \n{\n\tint adjust;\n\tint offset;\n\n\tJAS_DBGLOG(100, (\"jas_stream_tell(%p)\\n\", stream));\n\n\tif (stream->bufmode_ & JAS_STREAM_RDBUF) {\n\t\tadjust = -stream->cnt_;\n\t} else if (stream->bufmode_ & JAS_STREAM_WRBUF) {\n\t\tadjust = stream->ptr_ - stream->bufstart_;\n\t} else {\n\t\tadjust = 0;\n\t}\n\n\tif ((offset = (*stream->ops_->seek_)(stream->obj_, 0, SEEK_CUR)) < 0) {\n\t\treturn -1;\n\t}\n\n\treturn offset + adjust;\n}\n- JPC_MS_QCC: #define JPC_MS_QCC\t0xff5d /* Quantization component (QCC). */ /* <=== src/libjasper/jpc/jpc_cs.h:645:645:JPC_MS_QCC:0 */ \n- rateallocate: int rateallocate(jpc_enc_t *enc, int numlyrs, uint_fast32_t *cumlens) /* <=== rateallocate */ \n{\n\tjpc_flt_t lo;\n\tjpc_flt_t hi;\n\tjas_stream_t *out;\n\tuint_fast32_t cumlen;\n\tint lyrno;\n\tjpc_flt_t thresh;\n\tjpc_flt_t goodthresh;\n\tint success;\n\tlong pos;\n\tlong oldpos;\n\tint numiters;\n\n\tjpc_enc_tcmpt_t *comp;\n\tjpc_enc_tcmpt_t *endcomps;\n\tjpc_enc_rlvl_t *lvl;\n\tjpc_enc_rlvl_t *endlvls;\n\tjpc_enc_band_t *band;\n\tjpc_enc_band_t *endbands;\n\tjpc_enc_cblk_t *cblk;\n\tjpc_enc_cblk_t *endcblks;\n\tjpc_enc_pass_t *pass;\n\tjpc_enc_pass_t *endpasses;\n\tjpc_enc_pass_t *pass1;\n\tjpc_flt_t mxrdslope;\n\tjpc_flt_t mnrdslope;\n\tjpc_enc_tile_t *tile;\n\tjpc_enc_prc_t *prc;\n\tint prcno;\n\n\tJAS_DBGLOG(10, (\"starting rate allocation\\n\"));\n\n\ttile = enc->curtile;\n\n\tfor (lyrno = 1; lyrno < numlyrs - 1; ++lyrno) {\n\t\tif (cumlens[lyrno - 1] > cumlens[lyrno]) {\n\t\t\tabort();\n\t\t}\n\t}\n\n\tif (!(out = jas_stream_memopen(0, 0))) {\n\t\treturn -1;\n\t}\n\n\n\t/* Find minimum and maximum R-D slope values. */\n\tmnrdslope = DBL_MAX;\n\tmxrdslope = 0;\n\tendcomps = &tile->tcmpts[tile->numtcmpts];\n\tfor (comp = tile->tcmpts; comp != endcomps; ++comp) {\n\t\tendlvls = &comp->rlvls[comp->numrlvls];\n\t\tfor (lvl = comp->rlvls; lvl != endlvls; ++lvl) {\n\t\t\tif (!lvl->bands) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tendbands = &lvl->bands[lvl->numbands];\n\t\t\tfor (band = lvl->bands; band != endbands; ++band) {\n\t\t\t\tif (!band->data) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (prcno = 0, prc = band->prcs; prcno < lvl->numprcs;\n\t\t\t\t  ++prcno, ++prc) {\n\t\t\t\t\tif (!prc->cblks) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tendcblks = &prc->cblks[prc->numcblks];\n\t\t\t\t\tfor (cblk = prc->cblks; cblk != endcblks; ++cblk) {\n\t\t\t\t\t\tcalcrdslopes(cblk);\n\t\t\t\t\t\tendpasses = &cblk->passes[cblk->numpasses];\n\t\t\t\t\t\tfor (pass = cblk->passes; pass != endpasses; ++pass) {\n\t\t\t\t\t\t\tif (pass->rdslope > 0) {\n\t\t\t\t\t\t\t\tif (pass->rdslope < mnrdslope) {\n\t\t\t\t\t\t\t\t\tmnrdslope = pass->rdslope;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (pass->rdslope > mxrdslope) {\n\t\t\t\t\t\t\t\t\tmxrdslope = pass->rdslope;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tJAS_DBGLOG(10, (\"min rdslope = %f max rdslope = %f\\n\", mnrdslope,\n\t  mxrdslope));\n\n\tjpc_init_t2state(enc, 1);\n\n\tfor (lyrno = 0; lyrno < numlyrs; ++lyrno) {\n\n\t\tlo = mnrdslope;\n\t\thi = mxrdslope;\n\n\t\tsuccess = 0;\n\t\tgoodthresh = 0;\n\t\tnumiters = 0;\n\n\t\tdo {\n\n\t\t\tcumlen = cumlens[lyrno];\n\t\t\tif (cumlen == UINT_FAST32_MAX) {\n\t\t\t\t/* Only the last layer can be free of a rate\n\t\t\t\t  constraint (e.g., for lossless coding). */\n\t\t\t\tassert(lyrno == numlyrs - 1);\n\t\t\t\tgoodthresh = -1;\n\t\t\t\tsuccess = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tthresh = (lo + hi) / 2;\n\n\t\t\t/* Save the tier 2 coding state. */\n\t\t\tjpc_save_t2state(enc);\n\t\t\toldpos = jas_stream_tell(out);\n\t\t\tassert(oldpos >= 0);\n\n\t\t\t/* Assign all passes with R-D slopes greater than or\n\t\t\t  equal to the current threshold to this layer. */\n\t\t\tendcomps = &tile->tcmpts[tile->numtcmpts];\n\t\t\tfor (comp = tile->tcmpts; comp != endcomps; ++comp) {\n\t\t\t\tendlvls = &comp->rlvls[comp->numrlvls];\n\t\t\t\tfor (lvl = comp->rlvls; lvl != endlvls; ++lvl) {\n\t\t\t\t\tif (!lvl->bands) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tendbands = &lvl->bands[lvl->numbands];\n\t\t\t\t\tfor (band = lvl->bands; band != endbands; ++band) {\n\t\t\t\t\t\tif (!band->data) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (prcno = 0, prc = band->prcs; prcno < lvl->numprcs;\n\t\t\t\t\t\t  ++prcno, ++prc) {\n\t\t\t\t\t\t\tif (!prc->cblks) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tendcblks = &prc->cblks[prc->numcblks];\n\t\t\t\t\t\t\tfor (cblk = prc->cblks; cblk != endcblks; ++cblk) {\n\t\t\t\t\t\t\t\tif (cblk->curpass) {\n\t\t\t\t\t\t\t\t\tendpasses = &cblk->passes[cblk->numpasses];\n\t\t\t\t\t\t\t\t\tpass1 = cblk->curpass;\n\t\t\t\t\t\t\t\t\tfor (pass = cblk->curpass; pass !=\n\t\t\t\t\t\t\t\t\t  endpasses; ++pass) {\n\t\t\t\t\t\t\t\t\t\tif (pass->rdslope >= thresh) {\n\t\t\t\t\t\t\t\t\t\t\tpass1 = &pass[1];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfor (pass = cblk->curpass; pass != pass1;\n\t\t\t\t\t\t\t\t\t  ++pass) {\n\t\t\t\t\t\t\t\t\t\tpass->lyrno = lyrno;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfor (; pass != endpasses; ++pass) {\n\t\t\t\t\t\t\t\t\t\tpass->lyrno = -1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Perform tier 2 coding. */\n\t\t\tendcomps = &tile->tcmpts[tile->numtcmpts];\n\t\t\tfor (comp = tile->tcmpts; comp != endcomps; ++comp) {\n\t\t\t\tendlvls = &comp->rlvls[comp->numrlvls];\n\t\t\t\tfor (lvl = comp->rlvls; lvl != endlvls; ++lvl) {\n\t\t\t\t\tif (!lvl->bands) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (prcno = 0; prcno < lvl->numprcs; ++prcno) {\n\t\t\t\t\t\tif (jpc_enc_encpkt(enc, out, comp - tile->tcmpts,\n\t\t\t\t\t\t  lvl - comp->rlvls, prcno, lyrno)) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpos = jas_stream_tell(out);\n\n\t\t\t/* Check the rate constraint. */\n\t\t\tassert(pos >= 0);\n\t\t\tif (pos > cumlen) {\n\t\t\t\t/* The rate is too high. */\n\t\t\t\tlo = thresh;\n\t\t\t} else if (pos <= cumlen) {\n\t\t\t\t/* The rate is low enough, so try higher. */\n\t\t\t\thi = thresh;\n\t\t\t\tif (!success || thresh < goodthresh) {\n\t\t\t\t\tgoodthresh = thresh;\n\t\t\t\t\tsuccess = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Save the tier 2 coding state. */\n\t\t\tjpc_restore_t2state(enc);\n\t\t\tif (jas_stream_seek(out, oldpos, SEEK_SET) < 0) {\n\t\t\t\tabort();\n\t\t\t}\n\n\t\t\tJAS_DBGLOG(10, (\"maxlen=%08ld actuallen=%08ld thresh=%f\\n\",\n\t\t\t  cumlen, pos, thresh));\n\n\t\t\t++numiters;\n\t\t} while (lo < hi - 1e-3 && numiters < 32);\n\n\t\tif (!success) {\n\t\t\tjas_eprintf(\"warning: empty layer generated\\n\");\n\t\t}\n\n\t\tJAS_DBGLOG(10, (\"success %d goodthresh %f\\n\", success, goodthresh));\n\n\t\t/* Assign all passes with R-D slopes greater than or\n\t\t  equal to the selected threshold to this layer. */\n\t\tendcomps = &tile->tcmpts[tile->numtcmpts];\n\t\tfor (comp = tile->tcmpts; comp != endcomps; ++comp) {\n\t\t\tendlvls = &comp->rlvls[comp->numrlvls];\n\t\t\tfor (lvl = comp->rlvls; lvl != endlvls; ++lvl) {\n\t\t\t\tif (!lvl->bands) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tendbands = &lvl->bands[lvl->numbands];\n\t\t\t\tfor (band = lvl->bands; band != endbands; ++band) {\n\t\t\t\t\tif (!band->data) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (prcno = 0, prc = band->prcs; prcno < lvl->numprcs;\n\t\t\t\t\t  ++prcno, ++prc) {\n\t\t\t\t\t\tif (!prc->cblks) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tendcblks = &prc->cblks[prc->numcblks];\n\t\t\t\t\t\tfor (cblk = prc->cblks; cblk != endcblks; ++cblk) {\n\t\t\t\t\t\t\tif (cblk->curpass) {\n\t\t\t\t\t\t\t\tendpasses = &cblk->passes[cblk->numpasses];\n\t\t\t\t\t\t\t\tpass1 = cblk->curpass;\n\t\t\t\t\t\t\t\tif (success) {\n\t\t\t\t\t\t\t\t\tfor (pass = cblk->curpass; pass !=\n\t\t\t\t\t\t\t\t\t  endpasses; ++pass) {\n\t\t\t\t\t\t\t\t\t\tif (pass->rdslope >= goodthresh) {\n\t\t\t\t\t\t\t\t\t\t\tpass1 = &pass[1];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor (pass = cblk->curpass; pass != pass1;\n\t\t\t\t\t\t\t\t  ++pass) {\n\t\t\t\t\t\t\t\t\tpass->lyrno = lyrno;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor (; pass != endpasses; ++pass) {\n\t\t\t\t\t\t\t\t\tpass->lyrno = -1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Perform tier 2 coding. */\n\t\tendcomps = &tile->tcmpts[tile->numtcmpts];\n\t\tfor (comp = tile->tcmpts; comp != endcomps; ++comp) {\n\t\t\tendlvls = &comp->rlvls[comp->numrlvls];\n\t\t\tfor (lvl = comp->rlvls; lvl != endlvls; ++lvl) {\n\t\t\t\tif (!lvl->bands) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (prcno = 0; prcno < lvl->numprcs; ++prcno) {\n\t\t\t\t\tif (jpc_enc_encpkt(enc, out, comp - tile->tcmpts,\n\t\t\t\t\t  lvl - comp->rlvls, prcno, lyrno)) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (jas_getdbglevel() >= 5) {\n\t\tdump_layeringinfo(enc);\n\t}\n\n\tjas_stream_close(out);\n\n\tJAS_DBGLOG(10, (\"finished rate allocation\\n\"));\n\n\treturn 0;\n}\n- jas_stream_putc: #define jas_stream_putc(stream, c)\tjas_stream_putc_macro(stream, c) /* <=== src/libjasper/include/jasper/jas_stream.h:358:358:jas_stream_putc:2 */ \n- JPC_TSFB_LH: #define JPC_TSFB_LH\t1 /* <=== src/libjasper/jpc/jpc_tsfb.h:91:91:JPC_TSFB_LH:0 */ \n- jpc_putms: int jpc_putms(jas_stream_t *out, jpc_cstate_t *cstate, jpc_ms_t *ms) /* <=== jpc_putms */ \n{\n\tjas_stream_t *tmpstream;\n\tint len;\n\n\t/* Output the marker segment type. */\n\tif (jpc_putuint16(out, ms->id)) {\n\t\treturn -1;\n\t}\n\n\t/* Output the marker segment length and parameters if necessary. */\n\tif (ms->ops->putparms) {\n\t\t/* Create a temporary stream in which to buffer the\n\t\t  parameter data. */\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif ((*ms->ops->putparms)(ms, cstate, tmpstream)) {\n\t\t\tjas_stream_close(tmpstream);\n\t\t\treturn -1;\n\t\t}\n\t\t/* Get the number of bytes of parameter data written. */\n\t\tif ((len = jas_stream_tell(tmpstream)) < 0) {\n\t\t\tjas_stream_close(tmpstream);\n\t\t\treturn -1;\n\t\t}\n\t\tms->len = len;\n\t\t/* Write the marker segment length and parameter data to\n\t\t  the output stream. */\n\t\tif (jas_stream_seek(tmpstream, 0, SEEK_SET) < 0 ||\n\t\t  jpc_putuint16(out, ms->len + 2) ||\n\t\t  jas_stream_copy(out, tmpstream, ms->len) < 0) {\n\t\t\tjas_stream_close(tmpstream);\n\t\t\treturn -1;\n\t\t}\n\t\t/* Close the temporary stream. */\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\t/* This is a bit of a hack, but I'm not going to define another\n\t  type of virtual function for this one special case. */\n\tif (ms->id == JPC_MS_SIZ) {\n\t\tcstate->numcomps = ms->parms.siz.numcomps;\n\t}\n\n\tif (jas_getdbglevel() > 0) {\n\t\tjpc_ms_dump(ms, stderr);\n\t}\n\n\treturn 0;\n}\n- JPC_COX_PRT: #define\tJPC_COX_PRT\t0x01 /* <=== src/libjasper/jpc/jpc_cs.h:230:230:JPC_COX_PRT:0 */ \n- JPC_COX_INS: #define\tJPC_COX_INS\t0x00 /* Irreversible 9/7. */ /* <=== src/libjasper/jpc/jpc_cs.h:265:265:JPC_COX_INS:0 */ \n- jpc_enc_dump: void jpc_enc_dump(jpc_enc_t *enc) /* <=== jpc_enc_dump */ \n{\n\tjpc_enc_tile_t *tile;\n\tjpc_enc_tcmpt_t *tcmpt;\n\tjpc_enc_rlvl_t *rlvl;\n\tjpc_enc_band_t *band;\n\tjpc_enc_prc_t *prc;\n\tjpc_enc_cblk_t *cblk;\n\tuint_fast16_t cmptno;\n\tuint_fast16_t rlvlno;\n\tuint_fast16_t bandno;\n\tuint_fast32_t prcno;\n\tuint_fast32_t cblkno;\n\n\ttile = enc->curtile;\n\n\tfor (cmptno = 0, tcmpt = tile->tcmpts; cmptno < tile->numtcmpts; ++cmptno,\n\t  ++tcmpt) {\n\t\tjas_eprintf(\"  tcmpt %5d %5d %5d %5d\\n\", jas_seq2d_xstart(tcmpt->data), jas_seq2d_ystart(tcmpt->data), jas_seq2d_xend(tcmpt->data), jas_seq2d_yend(tcmpt->data));\n\t\tfor (rlvlno = 0, rlvl = tcmpt->rlvls; rlvlno < tcmpt->numrlvls;\n\t\t  ++rlvlno, ++rlvl) {\n\t\t\tjas_eprintf(\"    rlvl %5d %5d %5d %5d\\n\", rlvl->tlx, rlvl->tly, rlvl->brx, rlvl->bry);\n\t\t\tfor (bandno = 0, band = rlvl->bands; bandno < rlvl->numbands;\n\t\t\t  ++bandno, ++band) {\n\t\t\t\tif (!band->data) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tjas_eprintf(\"      band %5d %5d %5d %5d\\n\", jas_seq2d_xstart(band->data), jas_seq2d_ystart(band->data), jas_seq2d_xend(band->data), jas_seq2d_yend(band->data));\n\t\t\t\tfor (prcno = 0, prc = band->prcs; prcno < rlvl->numprcs;\n\t\t\t\t  ++prcno, ++prc) {\n\t\t\t\t\tjas_eprintf(\"        prc %5d %5d %5d %5d (%5d %5d)\\n\", prc->tlx, prc->tly, prc->brx, prc->bry, prc->brx - prc->tlx, prc->bry - prc->tly);\n\t\t\t\t\tif (!prc->cblks) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (cblkno = 0, cblk = prc->cblks; cblkno < prc->numcblks;\n\t\t\t\t\t  ++cblkno, ++cblk) {\n\t\t\t\t\t\tjas_eprintf(\"         cblk %5d %5d %5d %5d\\n\", jas_seq2d_xstart(cblk->data), jas_seq2d_ystart(cblk->data), jas_seq2d_xend(cblk->data), jas_seq2d_yend(cblk->data));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n- jas_matrix_numrows: #define jas_matrix_numrows(matrix) \\ /* <=== src/libjasper/include/jasper/jas_seq.h:154:155:jas_matrix_numrows:1 */ \n\t((matrix)->numrows_)\n- tcmpt_create: static jpc_enc_tcmpt_t *tcmpt_create(jpc_enc_tcmpt_t *tcmpt, jpc_enc_cp_t *cp, /* <=== tcmpt_create */ \n  jas_image_t *image, jpc_enc_tile_t *tile)\n{\n\tuint_fast16_t cmptno;\n\tuint_fast16_t rlvlno;\n\tjpc_enc_rlvl_t *rlvl;\n\tuint_fast32_t tlx;\n\tuint_fast32_t tly;\n\tuint_fast32_t brx;\n\tuint_fast32_t bry;\n\tuint_fast32_t cmpttlx;\n\tuint_fast32_t cmpttly;\n\tjpc_enc_ccp_t *ccp;\n\tjpc_tsfb_band_t bandinfos[JPC_MAXBANDS];\n\n\ttcmpt->tile = tile;\n\ttcmpt->tsfb = 0;\n\ttcmpt->data = 0;\n\ttcmpt->rlvls = 0;\n\n\t/* Deduce the component number. */\n\tcmptno = tcmpt - tile->tcmpts;\n\n\tccp = &cp->ccps[cmptno];\n\n\t/* Compute the coordinates of the top-left and bottom-right\n\t  corners of this tile-component. */\n\ttlx = JPC_CEILDIV(tile->tlx, ccp->sampgrdstepx);\n\ttly = JPC_CEILDIV(tile->tly, ccp->sampgrdstepy);\n\tbrx = JPC_CEILDIV(tile->brx, ccp->sampgrdstepx);\n\tbry = JPC_CEILDIV(tile->bry, ccp->sampgrdstepy);\n\n\t/* Create a sequence to hold the tile-component sample data. */\n\tif (!(tcmpt->data = jas_seq2d_create(tlx, tly, brx, bry))) {\n\t\tgoto error;\n\t}\n\n\t/* Get the image data associated with this tile-component. */\n\tcmpttlx = JPC_CEILDIV(cp->imgareatlx, ccp->sampgrdstepx);\n\tcmpttly = JPC_CEILDIV(cp->imgareatly, ccp->sampgrdstepy);\n\tif (jas_image_readcmpt(image, cmptno, tlx - cmpttlx, tly - cmpttly,\n\t  brx - tlx, bry - tly, tcmpt->data)) {\n\t\tgoto error;\n\t}\n\n\ttcmpt->synweight = 0;\n\ttcmpt->qmfbid = cp->tccp.qmfbid;\n\ttcmpt->numrlvls = cp->tccp.maxrlvls;\n\ttcmpt->numbands = 3 * tcmpt->numrlvls - 2;\n\tif (!(tcmpt->tsfb = jpc_cod_gettsfb(tcmpt->qmfbid, tcmpt->numrlvls - 1))) {\n\t\tgoto error;\n\t}\n\n\tfor (rlvlno = 0; rlvlno < tcmpt->numrlvls; ++rlvlno) {\n\t\ttcmpt->prcwidthexpns[rlvlno] = cp->tccp.prcwidthexpns[rlvlno];\n\t\ttcmpt->prcheightexpns[rlvlno] = cp->tccp.prcheightexpns[rlvlno];\n\t}\n\ttcmpt->cblkwidthexpn = cp->tccp.cblkwidthexpn;\n\ttcmpt->cblkheightexpn = cp->tccp.cblkheightexpn;\n\ttcmpt->cblksty = cp->tccp.cblksty;\n\ttcmpt->csty = cp->tccp.csty;\n\n\ttcmpt->numstepsizes = tcmpt->numbands;\n\tassert(tcmpt->numstepsizes <= JPC_MAXBANDS);\n\tmemset(tcmpt->stepsizes, 0, tcmpt->numstepsizes * sizeof(uint_fast16_t));\n\n\t/* Retrieve information about the various bands. */\n\tjpc_tsfb_getbands(tcmpt->tsfb, jas_seq2d_xstart(tcmpt->data),\n\t  jas_seq2d_ystart(tcmpt->data), jas_seq2d_xend(tcmpt->data),\n\t  jas_seq2d_yend(tcmpt->data), bandinfos);\n\n\tif (!(tcmpt->rlvls = jas_alloc2(tcmpt->numrlvls, sizeof(jpc_enc_rlvl_t)))) {\n\t\tgoto error;\n\t}\n\tfor (rlvlno = 0, rlvl = tcmpt->rlvls; rlvlno < tcmpt->numrlvls;\n\t  ++rlvlno, ++rlvl) {\n\t\trlvl->bands = 0;\n\t\trlvl->tcmpt = tcmpt;\n\t}\n\tfor (rlvlno = 0, rlvl = tcmpt->rlvls; rlvlno < tcmpt->numrlvls;\n\t  ++rlvlno, ++rlvl) {\n\t\tif (!rlvl_create(rlvl, cp, tcmpt, bandinfos)) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn tcmpt;\n\nerror:\n\n\ttcmpt_destroy(tcmpt);\n\treturn 0;\n\n}\n- jpc_ms_dump: void jpc_ms_dump(jpc_ms_t *ms, FILE *out) /* <=== jpc_ms_dump */ \n{\n\tconst jpc_mstabent_t *mstabent;\n\tmstabent = jpc_mstab_lookup(ms->id);\n\tfprintf(out, \"type = 0x%04\"PRIxFAST16\" (%s);\", ms->id, mstabent->name);\n\tif (JPC_MS_HASPARMS(ms->id)) {\n\t\tfprintf(out, \" len = %\"PRIuFAST16\";\", ms->len + 2);\n\t\tif (ms->ops->dumpparms) {\n\t\t\t(*ms->ops->dumpparms)(ms, out);\n\t\t} else {\n\t\t\tfprintf(out, \"\\n\");\n\t\t}\n\t} else {\n\t\tfprintf(out, \"\\n\");\n\t}\n}\n- jpc_fix_neg: #define\tjpc_fix_neg(x)\t\tJAS_FIX_NEG(jpc_fix_t, JPC_FIX_FRACBITS, x) /* <=== src/libjasper/jpc/jpc_fix.h:122:122:jpc_fix_neg:2 */ \n- jas_matrix_asl: void jas_matrix_asl(jas_matrix_t *matrix, int n) /* <=== jas_matrix_asl */ \n{\n\tjas_matind_t i;\n\tjas_matind_t j;\n\tjas_seqent_t *rowstart;\n\tjas_matind_t rowstep;\n\tjas_seqent_t *data;\n\n\tif (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {\n\t\tassert(matrix->rows_);\n\t\trowstep = jas_matrix_rowstep(matrix);\n\t\tfor (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,\n\t\t  rowstart += rowstep) {\n\t\t\tfor (j = matrix->numcols_, data = rowstart; j > 0; --j,\n\t\t\t  ++data) {\n\t\t\t\t//*data <<= n;\n\t\t\t\t*data = jas_seqent_asl(*data, n);\n\t\t\t}\n\t\t}\n\t}\n}\n- jpc_init_t2state: void jpc_init_t2state(jpc_enc_t *enc, int raflag) /* <=== jpc_init_t2state */ \n{\n/* It is assumed that band->numbps and cblk->numbps precomputed */\n\n\tjpc_enc_tcmpt_t *comp;\n\tjpc_enc_tcmpt_t *endcomps;\n\tjpc_enc_rlvl_t *lvl;\n\tjpc_enc_rlvl_t *endlvls;\n\tjpc_enc_band_t *band;\n\tjpc_enc_band_t *endbands;\n\tjpc_enc_cblk_t *cblk;\n\tjpc_enc_cblk_t *endcblks;\n\tjpc_enc_pass_t *pass;\n\tjpc_enc_pass_t *endpasses;\n\tjpc_tagtreenode_t *leaf;\n\tjpc_enc_tile_t *tile;\n\tint prcno;\n\tjpc_enc_prc_t *prc;\n\n\ttile = enc->curtile;\n\n\tendcomps = &tile->tcmpts[tile->numtcmpts];\n\tfor (comp = tile->tcmpts; comp != endcomps; ++comp) {\n\t\tendlvls = &comp->rlvls[comp->numrlvls];\n\t\tfor (lvl = comp->rlvls; lvl != endlvls; ++lvl) {\n\t\t\tif (!lvl->bands) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tendbands = &lvl->bands[lvl->numbands];\n\t\t\tfor (band = lvl->bands; band != endbands; ++band) {\n\t\t\t\tif (!band->data) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (prcno = 0, prc = band->prcs; prcno < lvl->numprcs; ++prcno, ++prc) {\n\t\t\t\t\tif (!prc->cblks) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tjpc_tagtree_reset(prc->incltree);\n\t\t\t\t\tjpc_tagtree_reset(prc->nlibtree);\n\t\t\t\t\tendcblks = &prc->cblks[prc->numcblks];\n\t\t\t\t\tfor (cblk = prc->cblks; cblk != endcblks; ++cblk) {\n\t\t\t\t\t\tif (jas_stream_rewind(cblk->stream)) {\n\t\t\t\t\t\t\tassert(0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcblk->curpass = (cblk->numpasses > 0) ? cblk->passes : 0;\n\t\t\t\t\t\tcblk->numencpasses = 0;\n\t\t\t\t\t\tcblk->numlenbits = 3;\n\t\t\t\t\t\tcblk->numimsbs = band->numbps - cblk->numbps;\n\t\t\t\t\t\tassert(cblk->numimsbs >= 0);\n\t\t\t\t\t\tleaf = jpc_tagtree_getleaf(prc->nlibtree, cblk - prc->cblks);\n\t\t\t\t\t\tjpc_tagtree_setvalue(prc->nlibtree, leaf, cblk->numimsbs);\n\n\t\t\t\t\t\tif (raflag) {\n\t\t\t\t\t\t\tendpasses = &cblk->passes[cblk->numpasses];\n\t\t\t\t\t\t\tfor (pass = cblk->passes; pass != endpasses; ++pass) {\n\t\t\t\t\t\t\t\tpass->lyrno = -1;\n\t\t\t\t\t\t\t\tpass->lyrno = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n- jpc_dbltofix: #define jpc_dbltofix(x)\tJAS_DBLTOFIX(jpc_fix_t, JPC_FIX_FRACBITS, x) /* <=== src/libjasper/jpc/jpc_fix.h:112:112:jpc_dbltofix:1 */ \n- jpc_enc_tile_destroy: static void jpc_enc_tile_destroy(jpc_enc_tile_t *tile) /* <=== jpc_enc_tile_destroy */ \n{\n\tjpc_enc_tcmpt_t *tcmpt;\n\tuint_fast16_t cmptno;\n\n\tif (tile->tcmpts) {\n\t\tfor (cmptno = 0, tcmpt = tile->tcmpts; cmptno <\n\t\t  tile->numtcmpts; ++cmptno, ++tcmpt) {\n\t\t\ttcmpt_destroy(tcmpt);\n\t\t}\n\t\tjas_free(tile->tcmpts);\n\t\t/* tile->tcmpts = NULL; */\n\t}\n\tif (tile->lyrsizes) {\n\t\tjas_free(tile->lyrsizes);\n\t\t/* tile->lyrsizes = NULL; */\n\t}\n\tif (tile->pi) {\n\t\tjpc_pi_destroy(tile->pi);\n\t\t/* tile->pi = NULL; */\n\t}\n\tjas_free(tile);\n\t/* tile = NULL; */\n}\n- jas_stream_copy: int jas_stream_copy(jas_stream_t *out, jas_stream_t *in, int n) /* <=== jas_stream_copy */ \n{\n\tint all;\n\tint c;\n\tint m;\n\n\tall = (n < 0) ? 1 : 0;\n\n\tm = n;\n\twhile (all || m > 0) {\n\t\tif ((c = jas_stream_getc_macro(in)) == EOF) {\n\t\t\t/* The next character of input could not be read. */\n\t\t\t/* Return with an error if an I/O error occured\n\t\t\t  (not including EOF) or if an explicit copy count\n\t\t\t  was specified. */\n\t\t\treturn (!all || jas_stream_error(in)) ? (-1) : 0;\n\t\t}\n\t\tif (jas_stream_putc_macro(out, c) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\t--m;\n\t}\n\treturn 0;\n}\n- jpc_enc_encpkts: int jpc_enc_encpkts(jpc_enc_t *enc, jas_stream_t *out) /* <=== jpc_enc_encpkts */ \n{\n\tjpc_enc_tile_t *tile;\n\tjpc_pi_t *pi;\n\n\ttile = enc->curtile;\n\n\tjpc_init_t2state(enc, 0);\n\tpi = tile->pi;\n\tjpc_pi_init(pi);\n\n\tif (!jpc_pi_next(pi)) {\n\t\tfor (;;) {\n\t\t\tif (jpc_enc_encpkt(enc, out, jpc_pi_cmptno(pi), jpc_pi_rlvlno(pi),\n\t\t\t  jpc_pi_prcno(pi), jpc_pi_lyrno(pi))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (jpc_pi_next(pi)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n- JPC_MS_COM: #define JPC_MS_COM\t0xff64 /* Comment (COM). */ /* <=== src/libjasper/jpc/jpc_cs.h:661:661:JPC_MS_COM:0 */ \n- JAS_CAST: #define\tJAS_CAST(t, e) \\ /* <=== src/libjasper/include/jasper/jas_types.h:144:145:JAS_CAST:2 */ \n\t((t) (e))\n- jpc_tsfb_getbands2: void jpc_tsfb_getbands2(jpc_tsfb_t *tsfb, int locxstart, int locystart, /* <=== jpc_tsfb_getbands2 */ \n  int xstart, int ystart, int xend, int yend, jpc_tsfb_band_t **bands,\n  int numlvls)\n{\n\tint newxstart;\n\tint newystart;\n\tint newxend;\n\tint newyend;\n\tjpc_tsfb_band_t *band;\n\n\tnewxstart = JPC_CEILDIVPOW2(xstart, 1);\n\tnewystart = JPC_CEILDIVPOW2(ystart, 1);\n\tnewxend = JPC_CEILDIVPOW2(xend, 1);\n\tnewyend = JPC_CEILDIVPOW2(yend, 1);\n\n\tif (numlvls > 0) {\n\n\t\tjpc_tsfb_getbands2(tsfb, locxstart, locystart, newxstart, newystart,\n\t\t  newxend, newyend, bands, numlvls - 1);\n\n\t\tband = *bands;\n\t\tband->xstart = JPC_FLOORDIVPOW2(xstart, 1);\n\t\tband->ystart = newystart;\n\t\tband->xend = JPC_FLOORDIVPOW2(xend, 1);\n\t\tband->yend = newyend;\n\t\tband->locxstart = locxstart + newxend - newxstart;\n\t\tband->locystart = locystart;\n\t\tband->locxend = band->locxstart + band->xend - band->xstart;\n\t\tband->locyend = band->locystart + band->yend - band->ystart;\n\t\tband->orient = JPC_TSFB_HL;\n\t\tband->synenergywt = jpc_dbltofix(tsfb->qmfb->hpenergywts[\n\t\t  tsfb->numlvls - numlvls] * tsfb->qmfb->lpenergywts[\n\t\t  tsfb->numlvls - numlvls]);\n\t\t++(*bands);\n\n\t\tband = *bands;\n\t\tband->xstart = newxstart;\n\t\tband->ystart = JPC_FLOORDIVPOW2(ystart, 1);\n\t\tband->xend = newxend;\n\t\tband->yend = JPC_FLOORDIVPOW2(yend, 1);\n\t\tband->locxstart = locxstart;\n\t\tband->locystart = locystart + newyend - newystart;\n\t\tband->locxend = band->locxstart + band->xend - band->xstart;\n\t\tband->locyend = band->locystart + band->yend - band->ystart;\n\t\tband->orient = JPC_TSFB_LH;\n\t\tband->synenergywt = jpc_dbltofix(tsfb->qmfb->lpenergywts[\n\t\t  tsfb->numlvls - numlvls] * tsfb->qmfb->hpenergywts[\n\t\t  tsfb->numlvls - numlvls]);\n\t\t++(*bands);\n\n\t\tband = *bands;\n\t\tband->xstart = JPC_FLOORDIVPOW2(xstart, 1);\n\t\tband->ystart = JPC_FLOORDIVPOW2(ystart, 1);\n\t\tband->xend = JPC_FLOORDIVPOW2(xend, 1);\n\t\tband->yend = JPC_FLOORDIVPOW2(yend, 1);\n\t\tband->locxstart = locxstart + newxend - newxstart;\n\t\tband->locystart = locystart + newyend - newystart;\n\t\tband->locxend = band->locxstart + band->xend - band->xstart;\n\t\tband->locyend = band->locystart + band->yend - band->ystart;\n\t\tband->orient = JPC_TSFB_HH;\n\t\tband->synenergywt = jpc_dbltofix(tsfb->qmfb->hpenergywts[\n\t\t  tsfb->numlvls - numlvls] * tsfb->qmfb->hpenergywts[\n\t\t  tsfb->numlvls - numlvls]);\n\t\t++(*bands);\n\n\t} else {\n\n\t\tband = *bands;\n\t\tband->xstart = xstart;\n\t\tband->ystart = ystart;\n\t\tband->xend = xend;\n\t\tband->yend = yend;\n\t\tband->locxstart = locxstart;\n\t\tband->locystart = locystart;\n\t\tband->locxend = band->locxstart + band->xend - band->xstart;\n\t\tband->locyend = band->locystart + band->yend - band->ystart;\n\t\tband->orient = JPC_TSFB_LL;\n\t\tband->synenergywt = jpc_dbltofix(tsfb->qmfb->lpenergywts[\n\t\t  tsfb->numlvls - numlvls - 1] * tsfb->qmfb->lpenergywts[\n\t\t  tsfb->numlvls - numlvls - 1]);\n\t\t++(*bands);\n\n\t}\n\n}\n- jas_seq2d_xend: #define\tjas_seq2d_xend(s) \\ /* <=== src/libjasper/include/jasper/jas_seq.h:266:267:jas_seq2d_xend:1 */ \n\t((s)->xend_)\n- jas_seq2d_yend: #define\tjas_seq2d_yend(s) \\ /* <=== src/libjasper/include/jasper/jas_seq.h:268:269:jas_seq2d_yend:1 */ \n\t((s)->yend_)\n- MAINTLRLEN: #define MAINTLRLEN\t2 /* <=== src/libjasper/jpc/jpc_enc.c:1080:1080:MAINTLRLEN:0 */ \n- jpc_putdata: int jpc_putdata(jas_stream_t *out, jas_stream_t *in, long len) /* <=== jpc_putdata */ \n{\n\treturn jas_stream_copy(out, in, len);\n}\n- JPC_QCX_EXPN: #define\tJPC_QCX_EXPN(x)\t\t(assert(!((x) & (~0x1f))), (((x) & 0x1f) << 11)) /* <=== src/libjasper/jpc/jpc_cs.h:390:390:JPC_QCX_EXPN:1 */ \n- JPC_NOMINALGAIN: int JPC_NOMINALGAIN(int qmfbid, int numlvls, int lvlno, int orient) /* <=== JPC_NOMINALGAIN */ \n{\n\t/* Avoid compiler warnings about unused parameters. */\n\tnumlvls = 0;\n\n\tif (qmfbid == JPC_COX_INS) {\n\t\treturn 0;\n\t}\n\tassert(qmfbid == JPC_COX_RFT);\n\tif (lvlno == 0) {\n\t\tassert(orient == JPC_TSFB_LL);\n\t\treturn 0;\n\t} else {\n\t\tswitch (orient) {\n\t\tcase JPC_TSFB_LH:\n\t\tcase JPC_TSFB_HL:\n\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase JPC_TSFB_HH:\n\t\t\treturn 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t\t\tbreak;\n\t\t}\n\t}\n}\n- jpc_tsfb_destroy: void jpc_tsfb_destroy(jpc_tsfb_t *tsfb) /* <=== jpc_tsfb_destroy */ \n{\n\tfree(tsfb);\n}\n- JPC_MS_SOT: #define\tJPC_MS_SOT\t0xff90 /* Start of tile-part (SOT). */ /* <=== src/libjasper/jpc/jpc_cs.h:633:633:JPC_MS_SOT:0 */ \n- jpc_quantize: void jpc_quantize(jas_matrix_t *data, jpc_fix_t stepsize) /* <=== jpc_quantize */ \n{\n\tint i;\n\tint j;\n\tjpc_fix_t t;\n\n\tif (stepsize == jpc_inttofix(1)) {\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < jas_matrix_numrows(data); ++i) {\n\t\tfor (j = 0; j < jas_matrix_numcols(data); ++j) {\n\t\t\tt = jas_matrix_get(data, i, j);\n\n{\n\tif (t < 0) {\n\t\tt = jpc_fix_neg(jpc_fix_div(jpc_fix_neg(t), stepsize));\n\t} else {\n\t\tt = jpc_fix_div(t, stepsize);\n\t}\n}\n\n\t\t\tjas_matrix_set(data, i, j, t);\n\t\t}\n\t}\n}\n- jpc_tsfb_analyze2: int jpc_tsfb_analyze2(jpc_tsfb_t *tsfb, jpc_fix_t *a, int xstart, int ystart, /* <=== jpc_tsfb_analyze2 */ \n  int width, int height, int stride, int numlvls)\n{\n\tif (width > 0 && height > 0) {\n\t\tif ((*tsfb->qmfb->analyze)(a, xstart, ystart, width, height, stride))\n\t\t\treturn -1;\n\t\tif (numlvls > 0) {\n\t\t\tif (jpc_tsfb_analyze2(tsfb, a, JPC_CEILDIVPOW2(xstart,\n\t\t\t  1), JPC_CEILDIVPOW2(ystart, 1), JPC_CEILDIVPOW2(\n\t\t\t  xstart + width, 1) - JPC_CEILDIVPOW2(xstart, 1),\n\t\t\t  JPC_CEILDIVPOW2(ystart + height, 1) -\n\t\t\t  JPC_CEILDIVPOW2(ystart, 1), stride, numlvls - 1)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n- JPC_MCT_ICT: #define JPC_MCT_ICT\t\t1 /* <=== src/libjasper/jpc/jpc_mct.h:91:91:JPC_MCT_ICT:0 */ \n- dump_layeringinfo: void dump_layeringinfo(jpc_enc_t *enc) /* <=== dump_layeringinfo */ \n{\n\n\tjpc_enc_tcmpt_t *tcmpt;\n\tint tcmptno;\n\tjpc_enc_rlvl_t *rlvl;\n\tint rlvlno;\n\tjpc_enc_band_t *band;\n\tint bandno;\n\tjpc_enc_prc_t *prc;\n\tint prcno;\n\tjpc_enc_cblk_t *cblk;\n\tint cblkno;\n\tjpc_enc_pass_t *pass;\n\tint passno;\n\tint lyrno;\n\tjpc_enc_tile_t *tile;\n\n\ttile = enc->curtile;\n\n\tfor (lyrno = 0; lyrno < tile->numlyrs; ++lyrno) {\n\t\tjas_eprintf(\"lyrno = %02d\\n\", lyrno);\n\t\tfor (tcmptno = 0, tcmpt = tile->tcmpts; tcmptno < tile->numtcmpts;\n\t\t  ++tcmptno, ++tcmpt) {\n\t\t\tfor (rlvlno = 0, rlvl = tcmpt->rlvls; rlvlno < tcmpt->numrlvls;\n\t\t\t  ++rlvlno, ++rlvl) {\n\t\t\t\tif (!rlvl->bands) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (bandno = 0, band = rlvl->bands; bandno < rlvl->numbands;\n\t\t\t\t  ++bandno, ++band) {\n\t\t\t\t\tif (!band->data) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (prcno = 0, prc = band->prcs; prcno < rlvl->numprcs;\n\t\t\t\t\t  ++prcno, ++prc) {\n\t\t\t\t\t\tif (!prc->cblks) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (cblkno = 0, cblk = prc->cblks; cblkno <\n\t\t\t\t\t\t  prc->numcblks; ++cblkno, ++cblk) {\n\t\t\t\t\t\t\tfor (passno = 0, pass = cblk->passes; passno <\n\t\t\t\t\t\t\t  cblk->numpasses && pass->lyrno == lyrno;\n\t\t\t\t\t\t\t  ++passno, ++pass) {\n\t\t\t\t\t\t\t\tjas_eprintf(\"lyrno=%02d cmptno=%02d rlvlno=%02d bandno=%02d prcno=%02d cblkno=%03d passno=%03d\\n\", lyrno, tcmptno, rlvlno, bandno, prcno, cblkno, passno);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n- jpc_fix_firstone: int jpc_fix_firstone(jpc_fix_t x) /* <=== jpc_fix_firstone */ \n{\n\tint n;\n\n\t/* The argument must be nonnegative. */\n\tassert(x >= 0);\n\n\tn = -1;\n\twhile (x > 0) {\n\t\tx >>= 1;\n\t\t++n;\n\t}\n\treturn n;\n}\n- jas_matrix_set: #define jas_matrix_set(matrix, i, j, v) \\ /* <=== src/libjasper/include/jasper/jas_seq.h:169:170:jas_matrix_set:4 */ \n\t((matrix)->rows_[i][j] = (v))\n- jpc_ms_create: jpc_ms_t *jpc_ms_create(int type) /* <=== jpc_ms_create */ \n{\n\tjpc_ms_t *ms;\n\tconst jpc_mstabent_t *mstabent;\n\n\tif (!(ms = jas_malloc(sizeof(jpc_ms_t)))) {\n\t\treturn 0;\n\t}\n\tms->id = type;\n\tms->len = 0;\n\tmstabent = jpc_mstab_lookup(ms->id);\n\tms->ops = &mstabent->ops;\n\tmemset(&ms->parms, 0, sizeof(jpc_msparms_t));\n\treturn ms;\n}\n- jas_seqent_asl: #define jas_seqent_asl jas_fast32_asl /* <=== src/libjasper/include/jasper/jas_seq.h:247:247:jas_seqent_asl:0 */ \n- jas_stream_memopen2: jas_stream_t *jas_stream_memopen2(char *buf, size_t bufsize) /* <=== jas_stream_memopen2 */ \n{\n\tjas_stream_t *stream;\n\tjas_stream_memobj_t *obj;\n\n\tJAS_DBGLOG(100, (\"jas_stream_memopen2(%p, %zu)\\n\", buf, bufsize));\n\n\tassert((buf && bufsize > 0) || (!buf));\n\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* A stream associated with a memory buffer is always opened\n\tfor both reading and writing in binary mode. */\n\tstream->openmode_ = JAS_STREAM_READ | JAS_STREAM_WRITE | JAS_STREAM_BINARY;\n\n\t/* Since the stream data is already resident in memory, buffering\n\tis not necessary. */\n\t/* But... It still may be faster to use buffering anyways. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\t/* Select the operations for a memory stream. */\n\tstream->ops_ = &jas_stream_memops;\n\n\t/* Allocate memory for the underlying memory stream object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_memobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tstream->obj_ = (void *) obj;\n\n\t/* Initialize a few important members of the memory stream object. */\n\tobj->myalloc_ = 0;\n\tobj->buf_ = 0;\n\n\t/* If the buffer size specified is nonpositive, then the buffer\n\tis allocated internally and automatically grown as needed. */\n\tif (!bufsize) {\n\t\tobj->bufsize_ = 1024;\n\t\tobj->growable_ = 1;\n\t} else {\n\t\tobj->bufsize_ = bufsize;\n\t\tobj->growable_ = 0;\n\t}\n\tif (buf) {\n\t\tobj->buf_ = JAS_CAST(unsigned char *, buf);\n\t} else {\n\t\tobj->buf_ = jas_malloc(obj->bufsize_);\n\t\tobj->myalloc_ = 1;\n\t}\n\tif (!obj->buf_) {\n\t\tjas_stream_close(stream);\n\t\treturn 0;\n\t}\n\tJAS_DBGLOG(100, (\"jas_stream_memopen2 buffer buf=%p myalloc=%d\\n\",\n\t  obj->buf_, obj->myalloc_));\n\n\tif (bufsize > 0 && buf) {\n\t\t/* If a buffer was supplied by the caller and its length is positive,\n\t\t  make the associated buffer data appear in the stream initially. */\n\t\tobj->len_ = bufsize;\n\t} else {\n\t\t/* The stream is initially empty. */\n\t\tobj->len_ = 0;\n\t}\n\tobj->pos_ = 0;\n\t\n\treturn stream;\n}\n- JPC_QCX_MANT: #define\tJPC_QCX_MANT(x)\t\t(assert(!((x) & (~0x7ff))), ((x) & 0x7ff)) /* <=== src/libjasper/jpc/jpc_cs.h:391:391:JPC_QCX_MANT:1 */ \n- jpc_enc_pi_create: jpc_pi_t *jpc_enc_pi_create(jpc_enc_cp_t *cp, jpc_enc_tile_t *tile) /* <=== jpc_enc_pi_create */ \n{\n\tjpc_pi_t *pi;\n\tint compno;\n\tjpc_picomp_t *picomp;\n\tjpc_pirlvl_t *pirlvl;\n\tjpc_enc_tcmpt_t *tcomp;\n\tint rlvlno;\n\tjpc_enc_rlvl_t *rlvl;\n\tint prcno;\n\tint *prclyrno;\n\n\tif (!(pi = jpc_pi_create0())) {\n\t\treturn 0;\n\t}\n\tpi->pktno = -1;\n\tpi->numcomps = cp->numcmpts;\n\tif (!(pi->picomps = jas_alloc2(pi->numcomps, sizeof(jpc_picomp_t)))) {\n\t\tjpc_pi_destroy(pi);\n\t\treturn 0;\n\t}\n\tfor (compno = 0, picomp = pi->picomps; compno < pi->numcomps; ++compno,\n\t  ++picomp) {\n\t\tpicomp->pirlvls = 0;\n\t}\n\n\tfor (compno = 0, tcomp = tile->tcmpts, picomp = pi->picomps;\n\t  compno < pi->numcomps; ++compno, ++tcomp, ++picomp) {\n\t\tpicomp->numrlvls = tcomp->numrlvls;\n\t\tif (!(picomp->pirlvls = jas_alloc2(picomp->numrlvls,\n\t\t  sizeof(jpc_pirlvl_t)))) {\n\t\t\tjpc_pi_destroy(pi);\n\t\t\treturn 0;\n\t\t}\n\t\tfor (rlvlno = 0, pirlvl = picomp->pirlvls; rlvlno <\n\t\t  picomp->numrlvls; ++rlvlno, ++pirlvl) {\n\t\t\tpirlvl->prclyrnos = 0;\n\t\t}\n\t\tfor (rlvlno = 0, pirlvl = picomp->pirlvls, rlvl = tcomp->rlvls;\n\t\t  rlvlno < picomp->numrlvls; ++rlvlno, ++pirlvl, ++rlvl) {\n/* XXX sizeof(long) should be sizeof different type */\n\t\t\tpirlvl->numprcs = rlvl->numprcs;\n\t\t\tif (rlvl->numprcs) {\n\t\t\t\tif (!(pirlvl->prclyrnos = jas_alloc2(pirlvl->numprcs,\n\t\t\t\t  sizeof(long)))) {\n\t\t\t\t\tjpc_pi_destroy(pi);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpirlvl->prclyrnos = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tpi->maxrlvls = 0;\n\tfor (compno = 0, tcomp = tile->tcmpts, picomp = pi->picomps;\n\t  compno < pi->numcomps; ++compno, ++tcomp, ++picomp) {\n\t\tpicomp->hsamp = cp->ccps[compno].sampgrdstepx;\n\t\tpicomp->vsamp = cp->ccps[compno].sampgrdstepy;\n\t\tfor (rlvlno = 0, pirlvl = picomp->pirlvls, rlvl = tcomp->rlvls;\n\t\t  rlvlno < picomp->numrlvls; ++rlvlno, ++pirlvl, ++rlvl) {\n\t\t\tpirlvl->prcwidthexpn = rlvl->prcwidthexpn;\n\t\t\tpirlvl->prcheightexpn = rlvl->prcheightexpn;\n\t\t\tfor (prcno = 0, prclyrno = pirlvl->prclyrnos;\n\t\t\t  prcno < pirlvl->numprcs; ++prcno, ++prclyrno) {\n\t\t\t\t*prclyrno = 0;\n\t\t\t}\n\t\t\tpirlvl->numhprcs = rlvl->numhprcs;\n\t\t}\n\t\tif (pi->maxrlvls < tcomp->numrlvls) {\n\t\t\tpi->maxrlvls = tcomp->numrlvls;\n\t\t}\n\t}\n\n\tpi->numlyrs = tile->numlyrs;\n\tpi->xstart = tile->tlx;\n\tpi->ystart = tile->tly;\n\tpi->xend = tile->brx;\n\tpi->yend = tile->bry;\n\n\tpi->picomp = 0;\n\tpi->pirlvl = 0;\n\tpi->x = 0;\n\tpi->y = 0;\n\tpi->compno = 0;\n\tpi->rlvlno = 0;\n\tpi->prcno = 0;\n\tpi->lyrno = 0;\n\tpi->xstep = 0;\n\tpi->ystep = 0;\n\n\tpi->pchgno = -1;\n\n\tpi->defaultpchg.prgord = tile->prg;\n\tpi->defaultpchg.compnostart = 0;\n\tpi->defaultpchg.compnoend = pi->numcomps;\n\tpi->defaultpchg.rlvlnostart = 0;\n\tpi->defaultpchg.rlvlnoend = pi->maxrlvls;\n\tpi->defaultpchg.lyrnoend = pi->numlyrs;\n\tpi->pchg = 0;\n\n\tpi->valid = 0;\n\n\treturn pi;\n}\n- jpc_fix_add3: #define jpc_fix_add3(x, y, z)\tjpc_fix_add(jpc_fix_add(x, y), z) /* <=== src/libjasper/jpc/jpc_fix.h:145:145:jpc_fix_add3:3 */ \n- JPC_FIX_ONE: #define\tJPC_FIX_ONE\t\tJAS_FIX_ONE(jpc_fix_t, JPC_FIX_FRACBITS) /* <=== src/libjasper/jpc/jpc_fix.h:106:106:JPC_FIX_ONE:0 */ \n\nType Definitions:\n- jpc_enc_tcp_t: typedef struct {\n\n\t/* The coding mode. */\n\tbool intmode;\n\n\t/* The coding style (i.e., SOP, EPH). */\n\tuint_fast8_t csty;\n\n\t/* The progression order. */\n\tuint_fast8_t prg;\n\n\t/* The multicomponent transform. */\n\tuint_fast8_t mctid;\n\n\t/* The number of layers. */\n\tuint_fast16_t numlyrs;\n\n\t/* The normalized bit rates associated with the various\n\t  intermediate layers. */\n\tjpc_fix_t *ilyrrates;\n\n}\n- jpc_sot_t: typedef struct {\n\n\t/* The tile number. */\n\tuint_fast16_t tileno;\n\n\t/* The combined length of the marker segment and its auxilary data\n\t  (i.e., packet data). */\n\tuint_fast32_t len;\n\n\t/* The tile-part instance. */\n\tuint_fast8_t partno;\n\n\t/* The number of tile-parts. */\n\tuint_fast8_t numparts;\n\n}\n- jpc_enc_cp_t: typedef struct {\n\n\t/* The debug level. */\n\tint debug;\n\n\t/* The horizontal offset from the origin of the reference grid to the\n\t  left edge of the image area. */\n\tuint_fast32_t imgareatlx;\n\n\t/* The vertical offset from the origin of the reference grid to the\n\t  top edge of the image area. */\n\tuint_fast32_t imgareatly;\n\n\t/* The horizontal offset from the origin of the reference grid to the\n\t  right edge of the image area (plus one). */\n\tuint_fast32_t refgrdwidth;\n\n\t/* The vertical offset from the origin of the reference grid to the\n\t  bottom edge of the image area (plus one). */\n\tuint_fast32_t refgrdheight;\n\n\t/* The horizontal offset from the origin of the tile grid to the\n\t  origin of the reference grid. */\n\tuint_fast32_t tilegrdoffx;\n\n\t/* The vertical offset from the origin of the tile grid to the\n\t  origin of the reference grid. */\n\tuint_fast32_t tilegrdoffy;\n\n\t/* The nominal tile width in units of the image reference grid. */\n\tuint_fast32_t tilewidth;\n\n\t/* The nominal tile height in units of the image reference grid. */\n\tuint_fast32_t tileheight;\n\n\t/* The number of tiles spanning the image area in the horizontal\n\t  direction. */\n\tuint_fast32_t numhtiles;\n\n\t/* The number of tiles spanning the image area in the vertical\n\t  direction. */\n\tuint_fast32_t numvtiles;\n\n\t/* The number of tiles. */\n\tuint_fast32_t numtiles;\n\n\t/* The number of components. */\n\tuint_fast16_t numcmpts;\n\n\t/* The per-component coding parameters. */\n\tjpc_enc_ccp_t *ccps;\n\n\t/* The per-tile coding parameters. */\n\tjpc_enc_tcp_t tcp;\n\n\t/* The per-tile-component coding parameters. */\n\tjpc_enc_tccp_t tccp;\n\n\t/* The target code stream length in bytes. */\n\tuint_fast32_t totalsize;\n\n\t/* The raw (i.e., uncompressed) size of the image in bytes. */\n\tuint_fast32_t rawsize;\n\n}\n- jpc_enc_tile_s: typedef struct jpc_enc_tile_s {\n\n\t/* The tile number. */\n\tuint_fast32_t tileno;\n\n\t/* The x-coordinate of the top-left corner of the tile measured with\n\t  respect to the reference grid. */\n\tuint_fast32_t tlx;\n\n\t/* The y-coordinate of the top-left corner of the tile measured with\n\t  respect to the reference grid. */\n\tuint_fast32_t tly;\n\n\t/* The x-coordinate of the bottom-right corner of the tile measured\n\t  with respect to the reference grid (plus one). */\n\tuint_fast32_t brx;\n\n\t/* The y-coordinate of the bottom-right corner of the tile measured\n\t  with respect to the reference grid (plus one). */\n\tuint_fast32_t bry;\n\n\t/* The coding style. */\n\tuint_fast8_t csty;\n\n\t/* The progression order. */\n\tuint_fast8_t prg;\n\n\t/* The number of layers. */\n\tint numlyrs;\n\n\t/* The MCT to employ (if any). */\n\tuint_fast8_t mctid;\n\n\t/* The packet iterator (used to determine the order of packet\n\t  generation). */\n\tjpc_pi_t *pi;\n\n\t/* The coding mode (i.e., integer or real). */\n\tbool intmode;\n\n\t/* The number of bytes to allocate to the various layers. */\n\tuint_fast32_t *lyrsizes;\n\n\t/* The number of tile-components. */\n\tint numtcmpts;\n\n\t/* The per tile-component information. */\n\tjpc_enc_tcmpt_t *tcmpts;\n\n\t/* The raw (i.e., uncompressed) size of this tile. */\n\tuint_fast32_t rawsize;\n\n}\n- jpc_enc_rlvl_t: typedef struct jpc_enc_rlvl_s {\n\n\t/* The x-coordinate of the top-left corner of the tile-component\n\t  at this resolution. */\n\tuint_fast32_t tlx;\n\n\t/* The y-coordinate of the top-left corner of the tile-component\n\t  at this resolution. */\n\tuint_fast32_t tly;\n\n\t/* The x-coordinate of the bottom-right corner of the tile-component\n\t  at this resolution (plus one). */\n\tuint_fast32_t brx;\n\n\t/* The y-coordinate of the bottom-right corner of the tile-component\n\t  at this resolution (plus one). */\n\tuint_fast32_t bry;\n\n\t/* The exponent value for the nominal precinct width measured\n\t  relative to the associated LL band. */\n\tint prcwidthexpn;\n\n\t/* The exponent value for the nominal precinct height measured\n\t  relative to the associated LL band. */\n\tint prcheightexpn;\n\n\t/* The number of precincts spanning the resolution level in the\n\t  horizontal direction. */\n\tint numhprcs;\n\n\t/* The number of precincts spanning the resolution level in the\n\t  vertical direction. */\n\tint numvprcs;\n\n\t/* The total number of precincts. */\n\tint numprcs;\n\n\t/* The exponent value for the nominal code block group width.\n\t  This quantity is associated with the next lower resolution level\n\t  (assuming that there is one). */\n\tint cbgwidthexpn;\n\n\t/* The exponent value for the nominal code block group height.\n\t  This quantity is associated with the next lower resolution level\n\t  (assuming that there is one). */\n\tint cbgheightexpn;\n\n\t/* The exponent value for the code block width. */\n\tuint_fast16_t cblkwidthexpn;\n\n\t/* The exponent value for the code block height. */\n\tuint_fast16_t cblkheightexpn;\n\n\t/* The number of bands associated with this resolution level. */\n\tint numbands;\n\n\t/* The per-band information. */\n\tjpc_enc_band_t *bands;\n\n\t/* The parent tile-component. */\n\tstruct jpc_enc_tcmpt_s *tcmpt;\n\n} jpc_enc_rlvl_t;\n- jpc_qcc_t: typedef struct {\n\n\t/* The component associated with this marker segment. */\n\tuint_fast16_t compno;\n\n\t/* The parameters. */\n\tjpc_qcxcp_t compparms;\n\n}\n- jpc_tsfb_band_t: typedef struct {\n\tint xstart;\n\tint ystart;\n\tint xend;\n\tint yend;\n\tint orient;\n\tint locxstart;\n\tint locystart;\n\tint locxend;\n\tint locyend;\n\tjpc_fix_t synenergywt;\n}\n- jpc_enc_t: typedef struct jpc_enc_s {\n\n\t/* The image being encoded. */\n\tjas_image_t *image;\n\n\t/* The output stream. */\n\tjas_stream_t *out;\n\n\t/* The coding parameters. */\n\tjpc_enc_cp_t *cp;\n\n\t/* The tile currently being processed. */\n\tjpc_enc_tile_t *curtile;\n\n\t/* The code stream state. */\n\tjpc_cstate_t *cstate;\n\n\t/* The number of bytes output so far. */\n\tuint_fast32_t len;\n\n\t/* The number of bytes available for the main body of the code stream. */\n\t/* This is used for rate allocation purposes. */\n\tuint_fast32_t mainbodysize;\n\n\t/* The marker segment currently being processed. */\n\t/* This member is a convenience for making cleanup easier. */\n\tjpc_ms_t *mrk;\n\n\t/* The stream used to temporarily hold tile-part data. */\n\tjas_stream_t *tmpstream;\n\n} jpc_enc_t;\n- jpc_enc_tcmpt_t: typedef struct jpc_enc_tcmpt_s {\n\n\t/* The number of resolution levels. */\n\tint numrlvls;\n\n\t/* The per-resolution-level information. */\n\tjpc_enc_rlvl_t *rlvls;\n\n\t/* The tile-component data. */\n\tjas_matrix_t *data;\n\n\t/* The QMFB. */\n\tint qmfbid;\n\n\t/* The number of bands. */\n\tint numbands;\n\n\t/* The TSFB. */\n\tjpc_tsfb_t *tsfb;\n\n\t/* The synthesis energy weight (for the MCT). */\n\tjpc_fix_t synweight;\n\n\t/* The precinct width exponents. */\n\tint prcwidthexpns[JPC_MAXRLVLS];\n\n\t/* The precinct height exponents. */\n\tint prcheightexpns[JPC_MAXRLVLS];\n\n\t/* The code block width exponent. */\n\tint cblkwidthexpn;\n\n\t/* The code block height exponent. */\n\tint cblkheightexpn;\n\n\t/* Coding style (i.e., explicit precinct sizes). */\n\tint csty;\n\n\t/* Code block style. */\n\tint cblksty;\n\n\t/* The number of quantizer step sizes. */\n\tint numstepsizes;\n\n\t/* The encoded quantizer step sizes. */\n\tuint_fast16_t stepsizes[JPC_MAXBANDS];\n\n\t/* The parent tile. */\n\tstruct jpc_enc_tile_s *tile;\n\n} jpc_enc_tcmpt_t;\n- jpc_enc_tile_s: struct jpc_enc_tile_s\n- jpc_enc_tile_t: typedef struct jpc_enc_tile_s {\n\n\t/* The tile number. */\n\tuint_fast32_t tileno;\n\n\t/* The x-coordinate of the top-left corner of the tile measured with\n\t  respect to the reference grid. */\n\tuint_fast32_t tlx;\n\n\t/* The y-coordinate of the top-left corner of the tile measured with\n\t  respect to the reference grid. */\n\tuint_fast32_t tly;\n\n\t/* The x-coordinate of the bottom-right corner of the tile measured\n\t  with respect to the reference grid (plus one). */\n\tuint_fast32_t brx;\n\n\t/* The y-coordinate of the bottom-right corner of the tile measured\n\t  with respect to the reference grid (plus one). */\n\tuint_fast32_t bry;\n\n\t/* The coding style. */\n\tuint_fast8_t csty;\n\n\t/* The progression order. */\n\tuint_fast8_t prg;\n\n\t/* The number of layers. */\n\tint numlyrs;\n\n\t/* The MCT to employ (if any). */\n\tuint_fast8_t mctid;\n\n\t/* The packet iterator (used to determine the order of packet\n\t  generation). */\n\tjpc_pi_t *pi;\n\n\t/* The coding mode (i.e., integer or real). */\n\tbool intmode;\n\n\t/* The number of bytes to allocate to the various layers. */\n\tuint_fast32_t *lyrsizes;\n\n\t/* The number of tile-components. */\n\tint numtcmpts;\n\n\t/* The per tile-component information. */\n\tjpc_enc_tcmpt_t *tcmpts;\n\n\t/* The raw (i.e., uncompressed) size of this tile. */\n\tuint_fast32_t rawsize;\n\n} jpc_enc_tile_t;\n- jpc_cod_t: typedef struct {\n\n\t/* The general coding style. */\n\tuint_fast8_t csty;\n\n\t/* The progression order. */\n\tuint_fast8_t prg;\n\n\t/* The number of layers. */\n\tuint_fast16_t numlyrs;\n\n\t/* The multicomponent transform. */\n\tuint_fast8_t mctrans;\n\n\t/* Component-related parameters. */\n\tjpc_coxcp_t compparms;\n\n}\n- jpc_enc_band_t: typedef struct jpc_enc_band_s {\n\n\t/* The per precinct information. */\n\tjpc_enc_prc_t *prcs;\n\n\t/* The coefficient data for this band. */\n\tjas_matrix_t *data;\n\n\t/* The orientation of this band (i.e., LL, LH, HL, or HH). */\n\tint orient;\n\n\t/* The number of bit planes associated with this band. */\n\tint numbps;\n\n\t/* The quantizer step size. */\n\tjpc_fix_t absstepsize;\n\n\t/* The encoded quantizer step size. */\n\tint stepsize;\n\n\t/* The L2 norm of the synthesis basis functions associated with\n\t  this band.  (The MCT is not considered in this value.) */\n\tjpc_fix_t synweight;\n\n\t/* The analysis gain for this band. */\n\tint analgain;\n\n\t/* The per-resolution-level information. */\n\tstruct jpc_enc_rlvl_s *rlvl;\n\n} jpc_enc_band_t;\n- jpc_fix_t: typedef int_fast32_t jpc_fix_t;\n- jpc_enc_ccp_t: typedef struct {\n\n\t/* The horizontal sampling period. */\n\tuint_fast8_t sampgrdstepx;\n\n\t/* The vertical sampling period. */\n\tuint_fast8_t sampgrdstepy;\n\n\t/* The sample alignment horizontal offset. */\n\tuint_fast8_t sampgrdsubstepx;\n\n\t/* The sample alignment vertical offset. */\n\tuint_fast8_t sampgrdsubstepy;\n\n\t/* The precision of the samples. */\n\tuint_fast8_t prec;\n\n\t/* The signedness of the samples. */\n\tbool sgnd;\n\n\t/* The number of step sizes. */\n\tuint_fast16_t numstepsizes;\n\n\t/* The quantizer step sizes. */\n\tuint_fast16_t stepsizes[JPC_MAXBANDS];\n\n}\n- jpc_tsfb_t: typedef struct {\n\tint numlvls;\n\tconst jpc_qmfb2d_t *qmfb;\n}\n- jpc_qcd_t: typedef struct {\n\n\t/* The parameters. */\n\tjpc_qcxcp_t compparms;\n\n}\n- jpc_enc_tccp_t: typedef struct {\n\n\t/* The coding style (i.e., explicit precinct sizes). */\n\tuint_fast8_t csty;\n\n\t/* The maximum number of resolution levels allowed. */\n\tuint_fast8_t maxrlvls;\n\n\t/* The exponent for the nominal code block width. */\n\tuint_fast16_t cblkwidthexpn;\n\n\t/* The exponent for the nominal code block height. */\n\tuint_fast16_t cblkheightexpn;\n\n\t/* The code block style parameters (e.g., lazy, terminate all,\n\t  segmentation symbols, causal, reset probability models). */\n\tuint_fast8_t cblksty;\n\n\t/* The QMFB. */\n\tuint_fast8_t qmfbid;\n\n\t/* The precinct width values. */\n\tuint_fast16_t prcwidthexpns[JPC_MAXRLVLS];\n\n\t/* The precinct height values. */\n\tuint_fast16_t prcheightexpns[JPC_MAXRLVLS];\n\n\t/* The number of guard bits. */\n\tuint_fast8_t numgbits;\n\n}\n\nImports:\n- #include \"jpc_fix.h\"\n- #include \"jasper/jas_types.h\"\n- #include <math.h>\n- #include \"jpc_qmfb.h\"\n- #include \"jasper/jas_tvp.h\"\n- #include <assert.h>\n- #include \"jpc_enc.h\"\n- #include \"jpc_cs.h\"\n- #include \"jasper/jas_string.h\"\n- #include <stdlib.h>\n- #include \"jpc_mct.h\"\n- #include \"jasper/jas_fix.h\"\n- #include \"jpc_flt.h\"\n- #include <stdio.h>\n- #include \"jpc_t1enc.h\"\n- #include \"jpc_util.h\"\n- #include \"jpc_t2enc.h\"\n- #include \"jasper/jas_malloc.h\"\n- #include \"jasper/jas_image.h\"\n- #include \"jasper/jas_version.h\"\n- #include \"jpc_math.h\"\n- #include \"jpc_tsfb.h\"\n- #include \"jpc_tagtree.h\"\n- #include \"jasper/jas_math.h\"\n- #include \"jasper/jas_debug.h\"\n- #include \"jpc_cod.h\"\n- #include <float.h>",
    "commit_msg": "jpc_enc: jpc_abstorelstepsize() returns error instead of aborting\n\nFixes CVE-2018-9252\n\nCloses https://github.com/jasper-maint/jasper/issues/16",
    "cve_desc": "JasPer 2.0.14 allows denial of service via a reachable assertion in the function jpc_abstorelstepsize in libjasper/jpc/jpc_enc.c.",
    "year": 2020,
    "filename": "jpc_enc.c",
    "commit_url": "\"https://github.com/mdadams/jasper/commit/6cd1e1d8aff56d0d86d4e7d1e7e3e4dd1c64b55d\""
  },
  {
    "repository": "sudo-project/sudo",
    "cve_id": "CVE-2019-18634",
    "cwe_list": [
      "CWE-787"
    ],
    "commit_hash": "fa8ffeb17523494f0e8bb49a25e53635f4509078",
    "short_hash": "fa8ffeb1",
    "vulnerableMethods_before": [
      {
        "filename": "src/tgetpass.c",
        "method_name": "tgetpass",
        "raw_code": "char * /* <=== tgetpass */ \ntgetpass(const char *prompt, int timeout, int flags,\n    struct sudo_conv_callback *callback)\n{\n    struct sigaction sa, savealrm, saveint, savehup, savequit, saveterm;\n    struct sigaction savetstp, savettin, savettou;\n    char *pass;\n    static const char *askpass;\n    static char buf[SUDO_CONV_REPL_MAX + 1];\n    int i, input, output, save_errno, ttyfd;\n    bool need_restart, neednl = false;\n    enum tgetpass_errval errval;\n    debug_decl(tgetpass, SUDO_DEBUG_CONV);\n\n    (void) fflush(stdout);\n\n    if (askpass == NULL) {\n\taskpass = getenv_unhooked(\"SUDO_ASKPASS\");\n\tif (askpass == NULL || *askpass == '\\0')\n\t    askpass = sudo_conf_askpass_path();\n    }\n\nrestart:\n    /* Try to open /dev/tty if we are going to be using it for I/O. */\n    ttyfd = -1;\n    if (!ISSET(flags, TGP_STDIN|TGP_ASKPASS)) {\n\tttyfd = open(_PATH_TTY, O_RDWR);\n\t/* If no tty present and we need to disable echo, try askpass. */\n\tif (ttyfd == -1 && !ISSET(flags, TGP_ECHO|TGP_NOECHO_TRY)) {\n\t    if (askpass == NULL || getenv_unhooked(\"DISPLAY\") == NULL) {\n\t\tsudo_warnx(U_(\"a terminal is required to read the password; either use the -S option to read from standard input or configure an askpass helper\"));\n\t\tdebug_return_str(NULL);\n\t    }\n\t    SET(flags, TGP_ASKPASS);\n\t}\n    }\n\n    /* If using a helper program to get the password, run it instead. */\n    if (ISSET(flags, TGP_ASKPASS)) {\n\tif (askpass == NULL || *askpass == '\\0')\n\t    sudo_fatalx(U_(\"no askpass program specified, try setting SUDO_ASKPASS\"));\n\tdebug_return_str_masked(sudo_askpass(askpass, prompt));\n    }\n\n    /* Reset state. */\n    for (i = 0; i < NSIG; i++)\n\tsigno[i] = 0;\n    pass = NULL;\n    save_errno = 0;\n    need_restart = false;\n\n    /* Use tty for reading/writing if available else use stdin/stderr. */\n    if (ttyfd == -1) {\n\tinput = STDIN_FILENO;\n\toutput = STDERR_FILENO;\n    } else {\n\tinput = ttyfd;\n\toutput = ttyfd;\n    }\n\n    /*\n     * If we are using a tty but are not the foreground pgrp this will\n     * return EINTR.  We send ourself SIGTTOU bracketed by callbacks.\n     */\n    if (!ISSET(flags, TGP_ECHO)) {\n\tfor (;;) {\n\t    if (ISSET(flags, TGP_MASK))\n\t\tneednl = sudo_term_cbreak(input);\n\t    else\n\t\tneednl = sudo_term_noecho(input);\n\t    if (neednl || errno != EINTR)\n\t\tbreak;\n\t    /* Received SIGTTOU, suspend the process. */\n\t    if (suspend(SIGTTOU, callback) == -1) {\n\t\tif (input != STDIN_FILENO)\n\t\t    (void) close(input);\n\t\tdebug_return_ptr(NULL);\n\t    }\n\t}\n    }\n\n    /*\n     * Catch signals that would otherwise cause the user to end\n     * up with echo turned off in the shell.\n     */\n    memset(&sa, 0, sizeof(sa));\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = 0;\t/* don't restart system calls */\n    sa.sa_handler = tgetpass_handler;\n    (void) sigaction(SIGALRM, &sa, &savealrm);\n    (void) sigaction(SIGINT, &sa, &saveint);\n    (void) sigaction(SIGHUP, &sa, &savehup);\n    (void) sigaction(SIGQUIT, &sa, &savequit);\n    (void) sigaction(SIGTERM, &sa, &saveterm);\n    (void) sigaction(SIGTSTP, &sa, &savetstp);\n    (void) sigaction(SIGTTIN, &sa, &savettin);\n    (void) sigaction(SIGTTOU, &sa, &savettou);\n\n    if (ISSET(flags, TGP_BELL) && output != STDERR_FILENO) {\n\t/* Ring the bell if requested and there is a tty. */\n\tif (write(output, \"\\a\", 1) == -1)\n\t    goto restore;\n    }\n    if (prompt) {\n\tif (write(output, prompt, strlen(prompt)) == -1)\n\t    goto restore;\n    }\n\n    if (timeout > 0)\n\talarm(timeout);\n    pass = getln(input, buf, sizeof(buf), ISSET(flags, TGP_MASK), &errval);\n    alarm(0);\n    save_errno = errno;\n\n    if (neednl || pass == NULL) {\n\tif (write(output, \"\\n\", 1) == -1)\n\t    goto restore;\n    }\n    tgetpass_display_error(errval);\n\nrestore:\n    /* Restore old signal handlers. */\n    (void) sigaction(SIGALRM, &savealrm, NULL);\n    (void) sigaction(SIGINT, &saveint, NULL);\n    (void) sigaction(SIGHUP, &savehup, NULL);\n    (void) sigaction(SIGQUIT, &savequit, NULL);\n    (void) sigaction(SIGTERM, &saveterm, NULL);\n    (void) sigaction(SIGTSTP, &savetstp, NULL);\n    (void) sigaction(SIGTTIN, &savettin, NULL);\n    (void) sigaction(SIGTTOU, &savettou, NULL);\n\n    /* Restore old tty settings. */\n    if (!ISSET(flags, TGP_ECHO)) {\n\t/* Restore old tty settings if possible. */\n\t(void) sudo_term_restore(input, true);\n    }\n    if (input != STDIN_FILENO)\n\t(void) close(input);\n\n    /*\n     * If we were interrupted by a signal, resend it to ourselves\n     * now that we have restored the signal handlers.\n     */\n    for (i = 0; i < NSIG; i++) {\n\tif (signo[i]) {\n\t    switch (i) {\n\t\tcase SIGALRM:\n\t\t    break;\n\t\tcase SIGTSTP:\n\t\tcase SIGTTIN:\n\t\tcase SIGTTOU:\n\t\t    if (suspend(i, callback) == 0)\n\t\t\tneed_restart = true;\n\t\t    break;\n\t\tdefault:\n\t\t    kill(getpid(), i);\n\t\t    break;\n\t    }\n\t}\n    }\n    if (need_restart)\n\tgoto restart;\n\n    if (save_errno)\n\terrno = save_errno;\n\n    debug_return_str_masked(pass);\n}",
        "start_line": 117
      },
      {
        "filename": "src/tgetpass.c",
        "method_name": "getln",
        "raw_code": "static char * /* <=== getln */ \ngetln(int fd, char *buf, size_t bufsiz, int feedback,\n    enum tgetpass_errval *errval)\n{\n    size_t left = bufsiz;\n    ssize_t nr = -1;\n    char *cp = buf;\n    char c = '\\0';\n    debug_decl(getln, SUDO_DEBUG_CONV);\n\n    *errval = TGP_ERRVAL_NOERROR;\n\n    if (left == 0) {\n\t*errval = TGP_ERRVAL_READERROR;\n\terrno = EINVAL;\n\tdebug_return_str(NULL);\t\t/* sanity */\n    }\n\n    while (--left) {\n\tnr = read(fd, &c, 1);\n\tif (nr != 1 || c == '\\n' || c == '\\r')\n\t    break;\n\tif (feedback) {\n\t    if (c == sudo_term_eof) {\n\t\tnr = 0;\n\t\tbreak;\n\t    } else if (c == sudo_term_kill) {\n\t\twhile (cp > buf) {\n\t\t    if (write(fd, \"\\b \\b\", 3) == -1)\n\t\t\tbreak;\n\t\t    --cp;\n\t\t}\n\t\tleft = bufsiz;\n\t\tcontinue;\n\t    } else if (c == sudo_term_erase) {\n\t\tif (cp > buf) {\n\t\t    if (write(fd, \"\\b \\b\", 3) == -1)\n\t\t\tbreak;\n\t\t    --cp;\n\t\t    left++;\n\t\t}\n\t\tcontinue;\n\t    }\n\t    ignore_result(write(fd, \"*\", 1));\n\t}\n\t*cp++ = c;\n    }\n    *cp = '\\0';\n    if (feedback) {\n\t/* erase stars */\n\twhile (cp > buf) {\n\t    if (write(fd, \"\\b \\b\", 3) == -1)\n\t\tbreak;\n\t    --cp;\n\t}\n    }\n\n    switch (nr) {\n    case -1:\n\t/* Read error */\n\tif (errno == EINTR) {\n\t    if (signo[SIGALRM] == 1)\n\t\t*errval = TGP_ERRVAL_TIMEOUT;\n\t} else {\n\t    *errval = TGP_ERRVAL_READERROR;\n\t}\n\tdebug_return_str(NULL);\n    case 0:\n\t/* EOF is only an error if no bytes were read. */\n\tif (left == bufsiz - 1) {\n\t    *errval = TGP_ERRVAL_NOPASSWORD;\n\t    debug_return_str(NULL);\n\t}\n\t/* FALLTHROUGH */\n    default:\n\tdebug_return_str_masked(buf);\n    }\n}",
        "start_line": 368
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "src/tgetpass.c",
        "method_name": "tgetpass",
        "raw_code": "char * /* <=== tgetpass */ \ntgetpass(const char *prompt, int timeout, int flags,\n    struct sudo_conv_callback *callback)\n{\n    struct sigaction sa, savealrm, saveint, savehup, savequit, saveterm;\n    struct sigaction savetstp, savettin, savettou;\n    char *pass;\n    static const char *askpass;\n    static char buf[SUDO_CONV_REPL_MAX + 1];\n    int i, input, output, save_errno, ttyfd;\n    bool need_restart, neednl = false;\n    bool feedback = ISSET(flags, TGP_MASK);\n    enum tgetpass_errval errval;\n    debug_decl(tgetpass, SUDO_DEBUG_CONV);\n\n    (void) fflush(stdout);\n\n    if (askpass == NULL) {\n\taskpass = getenv_unhooked(\"SUDO_ASKPASS\");\n\tif (askpass == NULL || *askpass == '\\0')\n\t    askpass = sudo_conf_askpass_path();\n    }\n\nrestart:\n    /* Try to open /dev/tty if we are going to be using it for I/O. */\n    ttyfd = -1;\n    if (!ISSET(flags, TGP_STDIN|TGP_ASKPASS)) {\n\tttyfd = open(_PATH_TTY, O_RDWR);\n\t/* If no tty present and we need to disable echo, try askpass. */\n\tif (ttyfd == -1 && !ISSET(flags, TGP_ECHO|TGP_NOECHO_TRY)) {\n\t    if (askpass == NULL || getenv_unhooked(\"DISPLAY\") == NULL) {\n\t\tsudo_warnx(U_(\"a terminal is required to read the password; either use the -S option to read from standard input or configure an askpass helper\"));\n\t\tdebug_return_str(NULL);\n\t    }\n\t    SET(flags, TGP_ASKPASS);\n\t}\n    }\n\n    /* If using a helper program to get the password, run it instead. */\n    if (ISSET(flags, TGP_ASKPASS)) {\n\tif (askpass == NULL || *askpass == '\\0')\n\t    sudo_fatalx(U_(\"no askpass program specified, try setting SUDO_ASKPASS\"));\n\tdebug_return_str_masked(sudo_askpass(askpass, prompt));\n    }\n\n    /* Reset state. */\n    for (i = 0; i < NSIG; i++)\n\tsigno[i] = 0;\n    pass = NULL;\n    save_errno = 0;\n    need_restart = false;\n\n    /* Use tty for reading/writing if available else use stdin/stderr. */\n    if (ttyfd == -1) {\n\tinput = STDIN_FILENO;\n\toutput = STDERR_FILENO;\n    } else {\n\tinput = ttyfd;\n\toutput = ttyfd;\n    }\n\n    /*\n     * If we are using a tty but are not the foreground pgrp this will\n     * return EINTR.  We send ourself SIGTTOU bracketed by callbacks.\n     */\n    if (!ISSET(flags, TGP_ECHO)) {\n\tfor (;;) {\n\t    if (feedback)\n\t\tneednl = sudo_term_cbreak(input);\n\t    else\n\t\tneednl = sudo_term_noecho(input);\n\t    if (neednl || errno != EINTR)\n\t\tbreak;\n\t    /* Received SIGTTOU, suspend the process. */\n\t    if (suspend(SIGTTOU, callback) == -1) {\n\t\tif (input != STDIN_FILENO)\n\t\t    (void) close(input);\n\t\tdebug_return_ptr(NULL);\n\t    }\n\t}\n    }\n    /* Only use feedback mode when we can disable echo. */\n    if (!neednl)\n\tfeedback = false;\n\n    /*\n     * Catch signals that would otherwise cause the user to end\n     * up with echo turned off in the shell.\n     */\n    memset(&sa, 0, sizeof(sa));\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = 0;\t/* don't restart system calls */\n    sa.sa_handler = tgetpass_handler;\n    (void) sigaction(SIGALRM, &sa, &savealrm);\n    (void) sigaction(SIGINT, &sa, &saveint);\n    (void) sigaction(SIGHUP, &sa, &savehup);\n    (void) sigaction(SIGQUIT, &sa, &savequit);\n    (void) sigaction(SIGTERM, &sa, &saveterm);\n    (void) sigaction(SIGTSTP, &sa, &savetstp);\n    (void) sigaction(SIGTTIN, &sa, &savettin);\n    (void) sigaction(SIGTTOU, &sa, &savettou);\n\n    if (ISSET(flags, TGP_BELL) && output != STDERR_FILENO) {\n\t/* Ring the bell if requested and there is a tty. */\n\tif (write(output, \"\\a\", 1) == -1)\n\t    goto restore;\n    }\n    if (prompt) {\n\tif (write(output, prompt, strlen(prompt)) == -1)\n\t    goto restore;\n    }\n\n    if (timeout > 0)\n\talarm(timeout);\n    pass = getln(input, buf, sizeof(buf), feedback, &errval);\n    alarm(0);\n    save_errno = errno;\n\n    if (neednl || pass == NULL) {\n\tif (write(output, \"\\n\", 1) == -1)\n\t    goto restore;\n    }\n    tgetpass_display_error(errval);\n\nrestore:\n    /* Restore old signal handlers. */\n    (void) sigaction(SIGALRM, &savealrm, NULL);\n    (void) sigaction(SIGINT, &saveint, NULL);\n    (void) sigaction(SIGHUP, &savehup, NULL);\n    (void) sigaction(SIGQUIT, &savequit, NULL);\n    (void) sigaction(SIGTERM, &saveterm, NULL);\n    (void) sigaction(SIGTSTP, &savetstp, NULL);\n    (void) sigaction(SIGTTIN, &savettin, NULL);\n    (void) sigaction(SIGTTOU, &savettou, NULL);\n\n    /* Restore old tty settings. */\n    if (!ISSET(flags, TGP_ECHO)) {\n\t/* Restore old tty settings if possible. */\n\t(void) sudo_term_restore(input, true);\n    }\n    if (input != STDIN_FILENO)\n\t(void) close(input);\n\n    /*\n     * If we were interrupted by a signal, resend it to ourselves\n     * now that we have restored the signal handlers.\n     */\n    for (i = 0; i < NSIG; i++) {\n\tif (signo[i]) {\n\t    switch (i) {\n\t\tcase SIGALRM:\n\t\t    break;\n\t\tcase SIGTSTP:\n\t\tcase SIGTTIN:\n\t\tcase SIGTTOU:\n\t\t    if (suspend(i, callback) == 0)\n\t\t\tneed_restart = true;\n\t\t    break;\n\t\tdefault:\n\t\t    kill(getpid(), i);\n\t\t    break;\n\t    }\n\t}\n    }\n    if (need_restart)\n\tgoto restart;\n\n    if (save_errno)\n\terrno = save_errno;\n\n    debug_return_str_masked(pass);\n}",
        "start_line": 117
      },
      {
        "filename": "src/tgetpass.c",
        "method_name": "getln",
        "raw_code": "static char * /* <=== getln */ \ngetln(int fd, char *buf, size_t bufsiz, bool feedback,\n    enum tgetpass_errval *errval)\n{\n    size_t left = bufsiz;\n    ssize_t nr = -1;\n    char *cp = buf;\n    char c = '\\0';\n    debug_decl(getln, SUDO_DEBUG_CONV);\n\n    *errval = TGP_ERRVAL_NOERROR;\n\n    if (left == 0) {\n\t*errval = TGP_ERRVAL_READERROR;\n\terrno = EINVAL;\n\tdebug_return_str(NULL);\t\t/* sanity */\n    }\n\n    while (--left) {\n\tnr = read(fd, &c, 1);\n\tif (nr != 1 || c == '\\n' || c == '\\r')\n\t    break;\n\tif (feedback) {\n\t    if (c == sudo_term_eof) {\n\t\tnr = 0;\n\t\tbreak;\n\t    } else if (c == sudo_term_kill) {\n\t\twhile (cp > buf) {\n\t\t    if (write(fd, \"\\b \\b\", 3) == -1)\n\t\t\tbreak;\n\t\t    cp--;\n\t\t}\n\t\tcp = buf;\n\t\tleft = bufsiz;\n\t\tcontinue;\n\t    } else if (c == sudo_term_erase) {\n\t\tif (cp > buf) {\n\t\t    ignore_result(write(fd, \"\\b \\b\", 3));\n\t\t    cp--;\n\t\t    left++;\n\t\t}\n\t\tcontinue;\n\t    }\n\t    ignore_result(write(fd, \"*\", 1));\n\t}\n\t*cp++ = c;\n    }\n    *cp = '\\0';\n    if (feedback) {\n\t/* erase stars */\n\twhile (cp > buf) {\n\t    if (write(fd, \"\\b \\b\", 3) == -1)\n\t\tbreak;\n\t    --cp;\n\t}\n    }\n\n    switch (nr) {\n    case -1:\n\t/* Read error */\n\tif (errno == EINTR) {\n\t    if (signo[SIGALRM] == 1)\n\t\t*errval = TGP_ERRVAL_TIMEOUT;\n\t} else {\n\t    *errval = TGP_ERRVAL_READERROR;\n\t}\n\tdebug_return_str(NULL);\n    case 0:\n\t/* EOF is only an error if no bytes were read. */\n\tif (left == bufsiz - 1) {\n\t    *errval = TGP_ERRVAL_NOPASSWORD;\n\t    debug_return_str(NULL);\n\t}\n\t/* FALLTHROUGH */\n    default:\n\tdebug_return_str_masked(buf);\n    }\n}",
        "start_line": 372
      }
    ],
    "code_context": "Called Methods:\n- restore_limits: void restore_limits(void); /* <=== restore_limits */ \n- false: #define\tfalse\tfalse /* <=== include/compat/stdbool.h:26:26:false:0 */ \n- sudo_fatalx_nodebug_v1: __dso_public void sudo_fatalx_nodebug_v1(const char *fmt, ...) __printflike(1, 2) __attribute__((__noreturn__)); /* <=== sudo_fatalx_nodebug_v1 */ \n- sudo_debug_fork_v1: __dso_public pid_t sudo_debug_fork_v1(void); /* <=== sudo_debug_fork_v1 */ \n- dup3: # define dup3(_a, _b, _c) sudo_dup3((_a), (_b), (_c)) /* <=== include/sudo_compat.h:593:593:dup3:3 */ \n- sudo_debug_exit_str_v1: __dso_public void sudo_debug_exit_str_v1(const char *func, const char *file, int line, int subsys, const char *ret); /* <=== sudo_debug_exit_str_v1 */ \n- debug_return: #define debug_return\t\t\t\t\t\t\t       \\ /* <=== include/sudo_debug.h:123:127:debug_return:0 */ \n    do {\t\t\t\t\t\t\t\t       \\\n\tsudo_debug_exit(__func__, __FILE__, __LINE__, sudo_debug_subsys);      \\\n\treturn;\t\t\t\t\t\t\t\t       \\\n    } while (0)\n- sudo_warnx: #  define sudo_warnx(...) do {\t\t\t\t\t\t       \\ /* <=== include/sudo_fatal.h:103:107:sudo_warnx:1 */ \n    sudo_debug_printf2(__func__, __FILE__, __LINE__,\t\t\t       \\\n\tSUDO_DEBUG_WARN|SUDO_DEBUG_LINENO|sudo_debug_subsys, __VA_ARGS__);     \\\n    sudo_warnx_nodebug_v1(__VA_ARGS__);\t\t\t\t\t       \\\n} while (0)\n- sudo_conf_askpass_path: #define sudo_conf_askpass_path() sudo_conf_askpass_path_v1() /* <=== include/sudo_conf.h:74:74:sudo_conf_askpass_path:0 */ \n- sudo_debug_printf: # define sudo_debug_printf(pri, ...) \\ /* <=== include/sudo_debug.h:236:238:sudo_debug_printf:2 */ \n    sudo_debug_printf2(__func__, __FILE__, __LINE__, (pri)|sudo_debug_subsys, \\\n    __VA_ARGS__)\n- sudo_debug_printf2_v1: __dso_public void sudo_debug_printf2_v1(const char *func, const char *file, int line, int level, const char *fmt, ...) __printf0like(5, 6); /* <=== sudo_debug_printf2_v1 */ \n- sudo_dup3: __dso_public int sudo_dup3(int oldd, int newd, int flags); /* <=== sudo_dup3 */ \n- debug_return_str: #define debug_return_str(ret)\t\t\t\t\t\t       \\ /* <=== include/sudo_debug.h:185:191:debug_return_str:1 */ \n    do {\t\t\t\t\t\t\t\t       \\\n\tchar *sudo_debug_ret = (ret);\t\t\t\t\t       \\\n\tsudo_debug_exit_str(__func__, __FILE__, __LINE__, sudo_debug_subsys,   \\\n\t    sudo_debug_ret);\t\t\t\t\t\t       \\\n\treturn sudo_debug_ret;\t\t\t\t\t\t       \\\n    } while (0)\n- sudo_term_restore: #define sudo_term_restore(_a, _b) sudo_term_restore_v1((_a), (_b)) /* <=== include/sudo_util.h:308:308:sudo_term_restore:2 */ \n- debug_return_ptr: #define debug_return_ptr(ret)\t\t\t\t\t\t       \\ /* <=== include/sudo_debug.h:209:215:debug_return_ptr:1 */ \n    do {\t\t\t\t\t\t\t\t       \\\n\tvoid *sudo_debug_ret = (ret);\t\t\t\t\t       \\\n\tsudo_debug_exit_ptr(__func__, __FILE__, __LINE__, sudo_debug_subsys,   \\\n\t    sudo_debug_ret);\t\t\t\t\t\t       \\\n\treturn sudo_debug_ret;\t\t\t\t\t\t       \\\n    } while (0)\n- suspend: static int /* <=== suspend */ \nsuspend(int signo, struct sudo_conv_callback *callback)\n{\n    int ret = 0;\n    debug_decl(suspend, SUDO_DEBUG_CONV);\n\n    if (callback != NULL && SUDO_API_VERSION_GET_MAJOR(callback->version) != SUDO_CONV_CALLBACK_VERSION_MAJOR) {\n\tsudo_debug_printf(SUDO_DEBUG_WARN|SUDO_DEBUG_LINENO,\n\t    \"callback major version mismatch, expected %u, got %u\",\n\t    SUDO_CONV_CALLBACK_VERSION_MAJOR,\n\t    SUDO_API_VERSION_GET_MAJOR(callback->version));\n\tcallback = NULL;\n    }\n\n    if (callback != NULL && callback->on_suspend != NULL) {\n\tif (callback->on_suspend(signo, callback->closure) == -1)\n\t    ret = -1;\n    }\n    kill(getpid(), signo);\n    if (callback != NULL && callback->on_resume != NULL) {\n\tif (callback->on_resume(signo, callback->closure) == -1)\n\t    ret = -1;\n    }\n    debug_return_int(ret);\n}\n- sudo_askpass: static char * /* <=== sudo_askpass */ \nsudo_askpass(const char *askpass, const char *prompt)\n{\n    static char buf[SUDO_CONV_REPL_MAX + 1], *pass;\n    struct sigaction sa, savechld;\n    enum tgetpass_errval errval;\n    int pfd[2], status;\n    pid_t child;\n    debug_decl(sudo_askpass, SUDO_DEBUG_CONV);\n\n    /* Set SIGCHLD handler to default since we call waitpid() below. */\n    memset(&sa, 0, sizeof(sa));\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = SA_RESTART;\n    sa.sa_handler = SIG_DFL;\n    (void) sigaction(SIGCHLD, &sa, &savechld);\n\n    if (pipe2(pfd, O_CLOEXEC) == -1)\n\tsudo_fatal(U_(\"unable to create pipe\"));\n\n    child = sudo_debug_fork();\n    if (child == -1)\n\tsudo_fatal(U_(\"unable to fork\"));\n\n    if (child == 0) {\n\t/* child, set stdout to write side of the pipe */\n\tif (dup3(pfd[1], STDOUT_FILENO, 0) == -1) {\n\t    sudo_warn(\"dup3\");\n\t    _exit(255);\n\t}\n\tif (setuid(ROOT_UID) == -1)\n\t    sudo_warn(\"setuid(%d)\", ROOT_UID);\n\t/* Close fds before uid change to prevent prlimit sabotage on Linux. */\n\tclosefrom(STDERR_FILENO + 1);\n\t/* Run the askpass program with the user's original resource limits. */\n\trestore_limits();\n\t/* But avoid a setuid() failure on Linux due to RLIMIT_NPROC. */\n\tunlimit_nproc();\n\tif (setgid(user_details.gid)) {\n\t    sudo_warn(U_(\"unable to set gid to %u\"), (unsigned int)user_details.gid);\n\t    _exit(255);\n\t}\n\tif (setuid(user_details.uid)) {\n\t    sudo_warn(U_(\"unable to set uid to %u\"), (unsigned int)user_details.uid);\n\t    _exit(255);\n\t}\n\trestore_nproc();\n\texecl(askpass, askpass, prompt, (char *)NULL);\n\tsudo_warn(U_(\"unable to run %s\"), askpass);\n\t_exit(255);\n    }\n\n    /* Get response from child (askpass). */\n    (void) close(pfd[1]);\n    pass = getln(pfd[0], buf, sizeof(buf), 0, &errval);\n    (void) close(pfd[0]);\n\n    tgetpass_display_error(errval);\n\n    /* Wait for child to exit. */\n    for (;;) {\n\tpid_t rv = waitpid(child, &status, 0);\n\tif (rv == -1 && errno != EINTR)\n\t    break;\n\tif (rv != -1 && !WIFSTOPPED(status))\n\t    break;\n    }\n\n    if (pass == NULL)\n\terrno = EINTR;\t/* make cancel button simulate ^C */\n\n    /* Restore saved SIGCHLD handler. */\n    (void) sigaction(SIGCHLD, &savechld, NULL);\n\n    debug_return_str_masked(pass);\n}\n- sudo_term_noecho: #define sudo_term_noecho(_a) sudo_term_noecho_v1((_a)) /* <=== include/sudo_util.h:304:304:sudo_term_noecho:1 */ \n- SUDO_CONV_CALLBACK_VERSION_MAJOR: #define SUDO_CONV_CALLBACK_VERSION_MAJOR\t1 /* <=== include/sudo_plugin.h:68:68:SUDO_CONV_CALLBACK_VERSION_MAJOR:0 */ \n- true: #define\ttrue\ttrue /* <=== include/compat/stdbool.h:27:27:true:0 */ \n- ROOT_UID: # define ROOT_UID\t0 /* <=== include/sudo_util.h:31:31:ROOT_UID:0 */ \n- unlimit_nproc: void unlimit_nproc(void); /* <=== unlimit_nproc */ \n- sudo_debug_exit_v1: __dso_public void sudo_debug_exit_v1(const char *func, const char *file, int line, int subsys); /* <=== sudo_debug_exit_v1 */ \n- getenv_unhooked: char *getenv_unhooked(const char *name); /* <=== getenv_unhooked */ \n- restore_nproc: void restore_nproc(void); /* <=== restore_nproc */ \n- closefrom: # define closefrom(_a) sudo_closefrom((_a)) /* <=== include/sudo_compat.h:429:429:closefrom:1 */ \n- pipe2: # define pipe2(_a, _b) sudo_pipe2((_a), (_b)) /* <=== include/sudo_compat.h:598:598:pipe2:2 */ \n- sudo_debug_exit_str_masked_v1: __dso_public void sudo_debug_exit_str_masked_v1(const char *func, const char *file, int line, int subsys, const char *ret); /* <=== sudo_debug_exit_str_masked_v1 */ \n- NSIG: #  define NSIG 64 /* <=== include/sudo_compat.h:306:306:NSIG:0 */ \n- SET: #define SET(t, f)\t((t) |= (f)) /* <=== include/sudo_compat.h:244:244:SET:2 */ \n- sudo_term_cbreak: #define sudo_term_cbreak(_a) sudo_term_cbreak_v1((_a)) /* <=== include/sudo_util.h:300:300:sudo_term_cbreak:1 */ \n- ignore_result: # define ignore_result(x)\t(void)(x) /* <=== include/sudo_util.h:176:176:ignore_result:1 */ \n- sudo_debug_fork: #define sudo_debug_fork() sudo_debug_fork_v1() /* <=== include/sudo_debug.h:289:289:sudo_debug_fork:0 */ \n- sudo_fatal: #  define sudo_fatal(...) do {\t\t\t\t\t\t       \\ /* <=== include/sudo_fatal.h:81:86:sudo_fatal:1 */ \n    sudo_debug_printf2(__func__, __FILE__, __LINE__,\t\t\t       \\\n\tSUDO_DEBUG_ERROR|SUDO_DEBUG_LINENO|SUDO_DEBUG_ERRNO|sudo_debug_subsys, \\\n\t__VA_ARGS__);\t\t\t\t\t\t\t       \\\n    sudo_fatal_nodebug_v1(__VA_ARGS__);\t\t\t\t\t       \\\n} while (0)\n- sudo_warnx_nodebug_v1: __dso_public void sudo_warnx_nodebug_v1(const char *fmt, ...) __printflike(1, 2); /* <=== sudo_warnx_nodebug_v1 */ \n- debug_return_str_masked: #define debug_return_str_masked(ret)\t\t\t\t\t       \\ /* <=== include/sudo_debug.h:201:207:debug_return_str_masked:1 */ \n    do {\t\t\t\t\t\t\t\t       \\\n\tchar *sudo_debug_ret = (ret);\t\t\t\t\t       \\\n\tsudo_debug_exit_str_masked(__func__, __FILE__, __LINE__,\t       \\\n\t    sudo_debug_subsys, sudo_debug_ret);\t\t\t       \\\n\treturn sudo_debug_ret;\t\t\t\t\t\t       \\\n    } while (0)\n- sudo_warn: #  define sudo_warn(...) do {\t\t\t\t\t\t       \\ /* <=== include/sudo_fatal.h:97:102:sudo_warn:1 */ \n    sudo_debug_printf2(__func__, __FILE__, __LINE__,\t\t\t       \\\n\tSUDO_DEBUG_WARN|SUDO_DEBUG_LINENO|SUDO_DEBUG_ERRNO|sudo_debug_subsys,  \\\n\t__VA_ARGS__);\t\t\t\t\t\t\t       \\\n    sudo_warn_nodebug_v1(__VA_ARGS__);\t\t\t\t\t       \\\n} while (0)\n- sudo_term_noecho_v1: __dso_public bool sudo_term_noecho_v1(int fd); /* <=== sudo_term_noecho_v1 */ \n- sudo_pipe2: __dso_public int sudo_pipe2(int fildes[2], int flags); /* <=== sudo_pipe2 */ \n- debug_return_int: #define debug_return_int(ret)\t\t\t\t\t\t       \\ /* <=== include/sudo_debug.h:129:135:debug_return_int:1 */ \n    do {\t\t\t\t\t\t\t\t       \\\n\tint sudo_debug_ret = (ret);\t\t\t\t\t       \\\n\tsudo_debug_exit_int(__func__, __FILE__, __LINE__, sudo_debug_subsys,   \\\n\t    sudo_debug_ret);\t\t\t\t\t\t       \\\n\treturn sudo_debug_ret;\t\t\t\t\t\t       \\\n    } while (0)\n- tgetpass_display_error: static void /* <=== tgetpass_display_error */ \ntgetpass_display_error(enum tgetpass_errval errval)\n{\n    debug_decl(tgetpass_display_error, SUDO_DEBUG_CONV);\n\n    switch (errval) {\n    case TGP_ERRVAL_NOERROR:\n\tbreak;\n    case TGP_ERRVAL_TIMEOUT:\n\tsudo_warnx(U_(\"timed out reading password\"));\n\tbreak;\n    case TGP_ERRVAL_NOPASSWORD:\n\tsudo_warnx(U_(\"no password was provided\"));\n\tbreak;\n    case TGP_ERRVAL_READERROR:\n\tsudo_warn(U_(\"unable to read password\"));\n\tbreak;\n    }\n    debug_return;\n}\n- sudo_term_restore_v1: __dso_public bool sudo_term_restore_v1(int fd, bool flush); /* <=== sudo_term_restore_v1 */ \n- sudo_fatalx: #  define sudo_fatalx(...) do {\t\t\t\t\t\t       \\ /* <=== include/sudo_fatal.h:87:91:sudo_fatalx:1 */ \n    sudo_debug_printf2(__func__, __FILE__, __LINE__,\t\t\t       \\\n\tSUDO_DEBUG_ERROR|SUDO_DEBUG_LINENO|sudo_debug_subsys, __VA_ARGS__);    \\\n    sudo_fatalx_nodebug_v1(__VA_ARGS__);\t\t\t\t       \\\n} while (0)\n- sudo_debug_enter_v1: __dso_public void sudo_debug_enter_v1(const char *func, const char *file, int line, int subsys); /* <=== sudo_debug_enter_v1 */ \n- sudo_warn_nodebug_v1: __dso_public void sudo_warn_nodebug_v1(const char *fmt, ...) __printf0like(1, 2); /* <=== sudo_warn_nodebug_v1 */ \n- SUDO_API_VERSION_GET_MAJOR: #define SUDO_API_VERSION_GET_MAJOR(v) ((v) >> 16) /* <=== include/sudo_plugin.h:29:29:SUDO_API_VERSION_GET_MAJOR:1 */ \n- sudo_term_cbreak_v1: __dso_public bool sudo_term_cbreak_v1(int fd); /* <=== sudo_term_cbreak_v1 */ \n- ISSET: #define ISSET(t, f)     ((t) & (f)) /* <=== include/sudo_compat.h:248:248:ISSET:2 */ \n- sudo_debug_exit_int_v1: __dso_public void sudo_debug_exit_int_v1(const char *func, const char *file, int line, int subsys, int ret); /* <=== sudo_debug_exit_int_v1 */ \n- SUDO_CONV_REPL_MAX: #define SUDO_CONV_REPL_MAX\t1023 /* <=== include/sudo_plugin.h:61:61:SUDO_CONV_REPL_MAX:0 */ \n- sudo_closefrom: __dso_public void sudo_closefrom(int); /* <=== sudo_closefrom */ \n- sudo_fatal_nodebug_v1: __dso_public void sudo_fatal_nodebug_v1(const char *fmt, ...) __printf0like(1, 2) __attribute__((__noreturn__)); /* <=== sudo_fatal_nodebug_v1 */ \n- debug_decl: #define debug_decl(funcname, subsys)\t\t\t\t\t       \\ /* <=== include/sudo_debug.h:116:118:debug_decl:2 */ \n    debug_decl_vars((funcname), (subsys));\t\t\t\t       \\\n    sudo_debug_enter(__func__, __FILE__, __LINE__, sudo_debug_subsys)\n- sudo_debug_exit_ptr_v1: __dso_public void sudo_debug_exit_ptr_v1(const char *func, const char *file, int line, int subsys, const void *ret); /* <=== sudo_debug_exit_ptr_v1 */ \n\nType Definitions:\n- sigaction: struct sigaction\n- tgetpass_errval: enum tgetpass_errval {\n    TGP_ERRVAL_NOERROR,\n    TGP_ERRVAL_TIMEOUT,\n    TGP_ERRVAL_NOPASSWORD,\n    TGP_ERRVAL_READERROR\n}\n- sudo_conv_callback: struct sudo_conv_callback {\n    unsigned int version;\n    void *closure;\n    sudo_conv_callback_fn_t on_suspend;\n    sudo_conv_callback_fn_t on_resume;\n}\n\nGlobal Variables:\n- static volatile sig_atomic_t[64] signo\n- extern int sudo_term_kill\n- extern int sudo_term_eof\n- extern int sudo_term_erase\n\nImports:\n- #include <sys/types.h>\n- #include <config.h>\n- #include <fcntl.h>\n- # include <string.h>\n- # include <floss.h>\n- # include <strings.h>\n- #include \"sudo_plugin.h\"\n- #include <unistd.h>\n- #include <signal.h>\n- #include \"sudo.h\"\n- #include <errno.h>\n- #include <stdlib.h>\n- #include <stdio.h>\n- #include <sys/wait.h>\n- #include <pwd.h>",
    "commit_msg": "Fix a buffer overflow when pwfeedback is enabled and input is a not a tty.\nIn getln() if the user enters ^U (erase line) and the write(2) fails,\nthe remaining buffer size is reset but the current pointer is not.\nWhile here, fix an incorrect break for erase when write(2) fails.\nAlso disable pwfeedback when input is not a tty as it cannot work.\nCVE-2019-18634\nCredit: Joe Vennix from Apple Information Security.",
    "cve_desc": "In Sudo before 1.8.26, if pwfeedback is enabled in /etc/sudoers, users can trigger a stack-based buffer overflow in the privileged sudo process. (pwfeedback is a default setting in Linux Mint and elementary OS; however, it is NOT the default for upstream and many other packages, and would exist only if enabled by an administrator.) The attacker needs to deliver a long string to the stdin of getln() in tgetpass.c.",
    "year": 2020,
    "filename": "tgetpass.c",
    "commit_url": "\"https://github.com/sudo-project/sudo/commit/fa8ffeb17523494f0e8bb49a25e53635f4509078\""
  },
  {
    "repository": "Duncaen/OpenDoas",
    "cve_id": "CVE-2019-25016",
    "cwe_list": [
      "CWE-200"
    ],
    "commit_hash": "d5acd52e2a15c36a8e06f9103d35622933aa422d",
    "short_hash": "d5acd52e",
    "vulnerableMethods_before": [
      {
        "filename": "doas.c",
        "method_name": "main",
        "raw_code": "int /* <=== main */ \nmain(int argc, char **argv)\n{\n\tconst char *safepath = \"/bin:/sbin:/usr/bin:/usr/sbin:\"\n\t    \"/usr/local/bin:/usr/local/sbin\";\n\tconst char *confpath = NULL;\n\tchar *shargv[] = { NULL, NULL };\n\tchar *sh;\n\tconst char *p;\n\tconst char *cmd;\n\tchar cmdline[LINE_MAX];\n\tstruct passwd mypwstore, targpwstore;\n\tstruct passwd *mypw, *targpw;\n\tconst struct rule *rule;\n\tuid_t uid;\n\tuid_t target = 0;\n\tgid_t groups[NGROUPS_MAX + 1];\n\tint ngroups;\n\tint i, ch, rv;\n\tint sflag = 0;\n\tint nflag = 0;\n\tchar cwdpath[PATH_MAX];\n\tconst char *cwd;\n\tchar **envp;\n\n\tsetprogname(\"doas\");\n\n\tclosefrom(STDERR_FILENO + 1);\n\n\tuid = getuid();\n\n\twhile ((ch = getopt(argc, argv, \"+C:Lnsu:\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'C':\n\t\t\tconfpath = optarg;\n\t\t\tbreak;\n\t\tcase 'L':\n#if defined(USE_TIMESTAMP)\n\t\t\texit(timestamp_clear() == -1);\n#else\n\t\t\texit(0);\n#endif\n\t\tcase 'u':\n\t\t\tif (parseuid(optarg, &target) != 0)\n\t\t\t\terrx(1, \"unknown user\");\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tnflag = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tsflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\targv += optind;\n\targc -= optind;\n\n\tif (confpath) {\n\t\tif (sflag)\n\t\t\tusage();\n\t} else if ((!sflag && !argc) || (sflag && argc))\n\t\tusage();\n\n\trv = mygetpwuid_r(uid, &mypwstore, &mypw);\n\tif (rv != 0)\n\t\terr(1, \"getpwuid_r failed\");\n\tif (mypw == NULL)\n\t\terrx(1, \"no passwd entry for self\");\n\tngroups = getgroups(NGROUPS_MAX, groups);\n\tif (ngroups == -1)\n\t\terr(1, \"can't get groups\");\n\tgroups[ngroups++] = getgid();\n\n\tif (sflag) {\n\t\tsh = getenv(\"SHELL\");\n\t\tif (sh == NULL || *sh == '\\0') {\n\t\t\tshargv[0] = mypw->pw_shell;\n\t\t} else\n\t\t\tshargv[0] = sh;\n\t\targv = shargv;\n\t\targc = 1;\n\t}\n\n\tif (confpath) {\n\t\tcheckconfig(confpath, argc, argv, uid, groups, ngroups,\n\t\t    target);\n\t\texit(1);\t/* fail safe */\n\t}\n\n\tif (geteuid())\n\t\terrx(1, \"not installed setuid\");\n\n\tparseconfig(DOAS_CONF, 1);\n\n\t/* cmdline is used only for logging, no need to abort on truncate */\n\t(void)strlcpy(cmdline, argv[0], sizeof(cmdline));\n\tfor (i = 1; i < argc; i++) {\n\t\tif (strlcat(cmdline, \" \", sizeof(cmdline)) >= sizeof(cmdline))\n\t\t\tbreak;\n\t\tif (strlcat(cmdline, argv[i], sizeof(cmdline)) >= sizeof(cmdline))\n\t\t\tbreak;\n\t}\n\n\tcmd = argv[0];\n\tif (!permit(uid, groups, ngroups, &rule, target, cmd,\n\t    (const char **)argv + 1)) {\n\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t    \"command not permitted for %s: %s\", mypw->pw_name, cmdline);\n\t\terrc(1, EPERM, NULL);\n\t}\n\n#if defined(USE_SHADOW)\n\tif (!(rule->options & NOPASS)) {\n\t\tif (nflag)\n\t\t\terrx(1, \"Authorization required\");\n\n\t\tshadowauth(mypw->pw_name, rule->options & PERSIST);\n\t}\n#elif !defined(USE_PAM)\n\t/* no authentication provider, only allow NOPASS rules */\n\t(void) nflag;\n\tif (!(rule->options & NOPASS))\n\t\terrx(1, \"Authorization required\");\n#endif\n\n\tif ((p = getenv(\"PATH\")) != NULL)\n\t\tformerpath = strdup(p);\n\tif (formerpath == NULL)\n\t\tformerpath = \"\";\n\n\tif (rule->cmd) {\n\t\tif (setenv(\"PATH\", safepath, 1) == -1)\n\t\t\terr(1, \"failed to set PATH '%s'\", safepath);\n\t}\n\n\trv = mygetpwuid_r(target, &targpwstore, &targpw);\n\tif (rv != 0)\n\t\terr(1, \"getpwuid_r failed\");\n\tif (targpw == NULL)\n\t\terrx(1, \"no passwd entry for target\");\n\n#if defined(USE_PAM)\n\tpamauth(targpw->pw_name, mypw->pw_name, !nflag, rule->options & NOPASS,\n\t    rule->options & PERSIST);\n#endif\n\n#ifdef HAVE_LOGIN_CAP_H\n\tif (setusercontext(NULL, targpw, target, LOGIN_SETGROUP |\n\t    LOGIN_SETPRIORITY | LOGIN_SETRESOURCES | LOGIN_SETUMASK |\n\t    LOGIN_SETUSER) != 0)\n\t\terrx(1, \"failed to set user context for target\");\n#else\n\tif (setresgid(targpw->pw_gid, targpw->pw_gid, targpw->pw_gid) != 0)\n\t\terr(1, \"setresgid\");\n\tif (initgroups(targpw->pw_name, targpw->pw_gid) != 0)\n\t\terr(1, \"initgroups\");\n\tif (setresuid(target, target, target) != 0)\n\t\terr(1, \"setresuid\");\n#endif\n\n\tif (getcwd(cwdpath, sizeof(cwdpath)) == NULL)\n\t\tcwd = \"(failed)\";\n\telse\n\t\tcwd = cwdpath;\n\n\tif (!(rule->options & NOLOG)) {\n\t\tsyslog(LOG_AUTHPRIV | LOG_INFO,\n\t\t    \"%s ran command %s as %s from %s\",\n\t\t    mypw->pw_name, cmdline, targpw->pw_name, cwd);\n\t}\n\n\tenvp = prepenv(rule, mypw, targpw);\n\n\t/* setusercontext set path for the next process, so reset it for us */\n\tif (rule->cmd) {\n\t\tif (setenv(\"PATH\", safepath, 1) == -1)\n\t\t\terr(1, \"failed to set PATH '%s'\", safepath);\n\t} else {\n\t\tif (setenv(\"PATH\", formerpath, 1) == -1)\n\t\t\terr(1, \"failed to set PATH '%s'\", formerpath);\n\t}\n\texecvpe(cmd, argv, envp);\n\tif (errno == ENOENT)\n\t\terrx(1, \"%s: command not found\", cmd);\n\terr(1, \"%s\", cmd);\n}",
        "start_line": 238
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "doas.c",
        "method_name": "main",
        "raw_code": "int /* <=== main */ \nmain(int argc, char **argv)\n{\n\tconst char *safepath = \"/bin:/sbin:/usr/bin:/usr/sbin:\"\n\t    \"/usr/local/bin:/usr/local/sbin\";\n\tconst char *confpath = NULL;\n\tchar *shargv[] = { NULL, NULL };\n\tchar *sh;\n\tconst char *p;\n\tconst char *cmd;\n\tchar cmdline[LINE_MAX];\n\tstruct passwd mypwstore, targpwstore;\n\tstruct passwd *mypw, *targpw;\n\tconst struct rule *rule;\n\tuid_t uid;\n\tuid_t target = 0;\n\tgid_t groups[NGROUPS_MAX + 1];\n\tint ngroups;\n\tint i, ch, rv;\n\tint sflag = 0;\n\tint nflag = 0;\n\tchar cwdpath[PATH_MAX];\n\tconst char *cwd;\n\tchar **envp;\n\n\tsetprogname(\"doas\");\n\n\tclosefrom(STDERR_FILENO + 1);\n\n\tuid = getuid();\n\n\twhile ((ch = getopt(argc, argv, \"+C:Lnsu:\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'C':\n\t\t\tconfpath = optarg;\n\t\t\tbreak;\n\t\tcase 'L':\n#if defined(USE_TIMESTAMP)\n\t\t\texit(timestamp_clear() == -1);\n#else\n\t\t\texit(0);\n#endif\n\t\tcase 'u':\n\t\t\tif (parseuid(optarg, &target) != 0)\n\t\t\t\terrx(1, \"unknown user\");\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tnflag = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tsflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\tbreak;\n\t\t}\n\t}\n\targv += optind;\n\targc -= optind;\n\n\tif (confpath) {\n\t\tif (sflag)\n\t\t\tusage();\n\t} else if ((!sflag && !argc) || (sflag && argc))\n\t\tusage();\n\n\trv = mygetpwuid_r(uid, &mypwstore, &mypw);\n\tif (rv != 0)\n\t\terr(1, \"getpwuid_r failed\");\n\tif (mypw == NULL)\n\t\terrx(1, \"no passwd entry for self\");\n\tngroups = getgroups(NGROUPS_MAX, groups);\n\tif (ngroups == -1)\n\t\terr(1, \"can't get groups\");\n\tgroups[ngroups++] = getgid();\n\n\tif (sflag) {\n\t\tsh = getenv(\"SHELL\");\n\t\tif (sh == NULL || *sh == '\\0') {\n\t\t\tshargv[0] = mypw->pw_shell;\n\t\t} else\n\t\t\tshargv[0] = sh;\n\t\targv = shargv;\n\t\targc = 1;\n\t}\n\n\tif (confpath) {\n\t\tcheckconfig(confpath, argc, argv, uid, groups, ngroups,\n\t\t    target);\n\t\texit(1);\t/* fail safe */\n\t}\n\n\tif (geteuid())\n\t\terrx(1, \"not installed setuid\");\n\n\tparseconfig(DOAS_CONF, 1);\n\n\t/* cmdline is used only for logging, no need to abort on truncate */\n\t(void)strlcpy(cmdline, argv[0], sizeof(cmdline));\n\tfor (i = 1; i < argc; i++) {\n\t\tif (strlcat(cmdline, \" \", sizeof(cmdline)) >= sizeof(cmdline))\n\t\t\tbreak;\n\t\tif (strlcat(cmdline, argv[i], sizeof(cmdline)) >= sizeof(cmdline))\n\t\t\tbreak;\n\t}\n\n\tcmd = argv[0];\n\tif (!permit(uid, groups, ngroups, &rule, target, cmd,\n\t    (const char **)argv + 1)) {\n\t\tsyslog(LOG_AUTHPRIV | LOG_NOTICE,\n\t\t    \"command not permitted for %s: %s\", mypw->pw_name, cmdline);\n\t\terrc(1, EPERM, NULL);\n\t}\n\n#if defined(USE_SHADOW)\n\tif (!(rule->options & NOPASS)) {\n\t\tif (nflag)\n\t\t\terrx(1, \"Authorization required\");\n\n\t\tshadowauth(mypw->pw_name, rule->options & PERSIST);\n\t}\n#elif !defined(USE_PAM)\n\t/* no authentication provider, only allow NOPASS rules */\n\t(void) nflag;\n\tif (!(rule->options & NOPASS))\n\t\terrx(1, \"Authorization required\");\n#endif\n\n\tif ((p = getenv(\"PATH\")) != NULL)\n\t\tformerpath = strdup(p);\n\tif (formerpath == NULL)\n\t\tformerpath = \"\";\n\n\tif (rule->cmd) {\n\t\tif (setenv(\"PATH\", safepath, 1) == -1)\n\t\t\terr(1, \"failed to set PATH '%s'\", safepath);\n\t}\n\n\trv = mygetpwuid_r(target, &targpwstore, &targpw);\n\tif (rv != 0)\n\t\terr(1, \"getpwuid_r failed\");\n\tif (targpw == NULL)\n\t\terrx(1, \"no passwd entry for target\");\n\n#if defined(USE_PAM)\n\tpamauth(targpw->pw_name, mypw->pw_name, !nflag, rule->options & NOPASS,\n\t    rule->options & PERSIST);\n#endif\n\n#ifdef HAVE_LOGIN_CAP_H\n\tif (setusercontext(NULL, targpw, target, LOGIN_SETGROUP |\n\t    LOGIN_SETPATH |\n\t    LOGIN_SETPRIORITY | LOGIN_SETRESOURCES | LOGIN_SETUMASK |\n\t    LOGIN_SETUSER) != 0)\n\t\terrx(1, \"failed to set user context for target\");\n#else\n\tif (setresgid(targpw->pw_gid, targpw->pw_gid, targpw->pw_gid) != 0)\n\t\terr(1, \"setresgid\");\n\tif (initgroups(targpw->pw_name, targpw->pw_gid) != 0)\n\t\terr(1, \"initgroups\");\n\tif (setresuid(target, target, target) != 0)\n\t\terr(1, \"setresuid\");\n\tif (setenv(\"PATH\", safepath, 1) == -1)\n\t\terr(1, \"failed to set PATH '%s'\", safepath);\n#endif\n\n\tif (getcwd(cwdpath, sizeof(cwdpath)) == NULL)\n\t\tcwd = \"(failed)\";\n\telse\n\t\tcwd = cwdpath;\n\n\tif (!(rule->options & NOLOG)) {\n\t\tsyslog(LOG_AUTHPRIV | LOG_INFO,\n\t\t    \"%s ran command %s as %s from %s\",\n\t\t    mypw->pw_name, cmdline, targpw->pw_name, cwd);\n\t}\n\n\tenvp = prepenv(rule, mypw, targpw);\n\n\t/* setusercontext set path for the next process, so reset it for us */\n\tif (rule->cmd) {\n\t\tif (setenv(\"PATH\", safepath, 1) == -1)\n\t\t\terr(1, \"failed to set PATH '%s'\", safepath);\n\t} else {\n\t\tif (setenv(\"PATH\", formerpath, 1) == -1)\n\t\t\terr(1, \"failed to set PATH '%s'\", formerpath);\n\t}\n\texecvpe(cmd, argv, envp);\n\tif (errno == ENOENT)\n\t\terrx(1, \"%s: command not found\", cmd);\n\terr(1, \"%s\", cmd);\n}",
        "start_line": 238
      }
    ],
    "code_context": "Called Methods:\n- NOPASS: #define NOPASS\t\t0x1 /* <=== doas.h:42:42:NOPASS:0 */ \n\nType Definitions:\n- rule: struct rule {\n\tint action;\n\tint options;\n\tconst char *ident;\n\tconst char *target;\n\tconst char *cmd;\n\tconst char **cmdargs;\n\tconst char **envlist;\n}\n\nImports:\n- #include <syslog.h>\n- #include <grp.h>\n- #include <fcntl.h>\n- #include <sys/stat.h>\n- #include <errno.h>\n- #include <stdio.h>\n- #include <sys/ioctl.h>\n- #include <err.h>\n- #include <login_cap.h>\n- #include <unistd.h>\n- #include \"config.h\"\n- #include <limits.h>\n- #include \"doas.h\"\n- #include \"openbsd.h\"\n- #include <stdlib.h>\n- #include <sys/types.h>\n- #include <string.h>\n- #include <pwd.h>",
    "commit_msg": "correctly reset path for rules without specific command\n\nThis is a fixup for commit 01c658f8c45cb92a343be5f32aa6da70b2032168\nwhere the behaviour was changed to not inherit the PATH variable\nby default.",
    "cve_desc": "In OpenDoas from 6.6 to 6.8 the users PATH variable was incorrectly inherited by authenticated executions if the authenticating rule allowed the user to execute any command. Rules that only allowed to authenticated user to execute specific commands were not affected by this issue.",
    "year": 2021,
    "filename": "doas.c",
    "commit_url": "\"https://github.com/Duncaen/OpenDoas/commit/d5acd52e2a15c36a8e06f9103d35622933aa422d\""
  },
  {
    "repository": "libexif/libexif",
    "cve_id": "CVE-2019-9278",
    "cwe_list": [
      "CWE-787,CWE-190"
    ],
    "commit_hash": "75aa73267fdb1e0ebfbc00369e7312bac43d0566",
    "short_hash": "75aa7326",
    "vulnerableMethods_before": [
      {
        "filename": "libexif/exif-data.c",
        "method_name": "exif_data_load_data_entry",
        "raw_code": "static int /* <=== exif_data_load_data_entry */ \nexif_data_load_data_entry (ExifData *data, ExifEntry *entry,\n\t\t\t   const unsigned char *d,\n\t\t\t   unsigned int size, unsigned int offset)\n{\n\tunsigned int s, doff;\n\n\tentry->tag        = exif_get_short (d + offset + 0, data->priv->order);\n\tentry->format     = exif_get_short (d + offset + 2, data->priv->order);\n\tentry->components = exif_get_long  (d + offset + 4, data->priv->order);\n\n\t/* FIXME: should use exif_tag_get_name_in_ifd here but entry->parent \n\t * has not been set yet\n\t */\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t  \"Loading entry 0x%x ('%s')...\", entry->tag,\n\t\t  exif_tag_get_name (entry->tag));\n\n\t/* {0,1,2,4,8} x { 0x00000000 .. 0xffffffff } \n\t *   -> { 0x000000000 .. 0x7fffffff8 } */\n\ts = exif_format_get_size(entry->format) * entry->components;\n\tif ((s < entry->components) || (s == 0)){\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Size? If bigger than 4 bytes, the actual data is not\n\t * in the entry but somewhere else (offset).\n\t */\n\tif (s > 4)\n\t\tdoff = exif_get_long (d + offset + 8, data->priv->order);\n\telse\n\t\tdoff = offset + 8;\n\n\t/* Sanity checks */\n\tif ((doff + s < doff) || (doff + s < s) || (doff + s > size)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t  \"Tag data past end of buffer (%u > %u)\", doff+s, size);\t\n\t\treturn 0;\n\t}\n\n\tentry->data = exif_data_alloc (data, s);\n\tif (entry->data) {\n\t\tentry->size = s;\n\t\tmemcpy (entry->data, d + doff, s);\n\t} else {\n\t\tEXIF_LOG_NO_MEMORY(data->priv->log, \"ExifData\", s);\n\t\treturn 0;\n\t}\n\n\t/* If this is the MakerNote, remember the offset */\n\tif (entry->tag == EXIF_TAG_MAKER_NOTE) {\n\t\tif (!entry->data) {\n\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t\t  \"MakerNote found with empty data\");\t\n\t\t} else if (entry->size > 6) {\n\t\t\texif_log (data->priv->log,\n\t\t\t\t\t       EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t\t       \"MakerNote found (%02x %02x %02x %02x \"\n\t\t\t\t\t       \"%02x %02x %02x...).\",\n\t\t\t\t\t       entry->data[0], entry->data[1], entry->data[2],\n\t\t\t\t\t       entry->data[3], entry->data[4], entry->data[5],\n\t\t\t\t\t       entry->data[6]);\n\t\t}\n\t\tdata->priv->offset_mnote = doff;\n\t}\n\treturn 1;\n}",
        "start_line": 160
      },
      {
        "filename": "libexif/exif-data.c",
        "method_name": "exif_data_load_data_thumbnail",
        "raw_code": "static void /* <=== exif_data_load_data_thumbnail */ \nexif_data_load_data_thumbnail (ExifData *data, const unsigned char *d,\n\t\t\t       unsigned int ds, ExifLong o, ExifLong s)\n{\n\t/* Sanity checks */\n\tif ((o + s < o) || (o + s < s) || (o + s > ds) || (o > ds)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t  \"Bogus thumbnail offset (%u) or size (%u).\",\n\t\t\t  o, s);\n\t\treturn;\n\t}\n\n\tif (data->data) \n\t\texif_mem_free (data->priv->mem, data->data);\n\tif (!(data->data = exif_data_alloc (data, s))) {\n\t\tEXIF_LOG_NO_MEMORY (data->priv->log, \"ExifData\", s);\n\t\tdata->size = 0;\n\t\treturn;\n\t}\n\tdata->size = s;\n\tmemcpy (data->data, d + o, s);\n}",
        "start_line": 313
      },
      {
        "filename": "libexif/exif-data.c",
        "method_name": "exif_data_load_data",
        "raw_code": "void /* <=== exif_data_load_data */ \nexif_data_load_data (ExifData *data, const unsigned char *d_orig,\n\t\t     unsigned int ds)\n{\n\tunsigned int l;\n\tExifLong offset;\n\tExifShort n;\n\tconst unsigned char *d = d_orig;\n\tunsigned int len, fullds;\n\n\tif (!data || !data->priv || !d || !ds)\n\t\treturn;\n\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t  \"Parsing %i byte(s) EXIF data...\\n\", ds);\n\n\t/*\n\t * It can be that the data starts with the EXIF header. If it does\n\t * not, search the EXIF marker.\n\t */\n\tif (ds < 6) {\n\t\tLOG_TOO_SMALL;\n\t\treturn;\n\t}\n\tif (!memcmp (d, ExifHeader, 6)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t  \"Found EXIF header at start.\");\n\t} else {\n\t\twhile (ds >= 3) {\n\t\t\twhile (ds && (d[0] == 0xff)) {\n\t\t\t\td++;\n\t\t\t\tds--;\n\t\t\t}\n\n\t\t\t/* JPEG_MARKER_SOI */\n\t\t\tif (ds && d[0] == JPEG_MARKER_SOI) {\n\t\t\t\td++;\n\t\t\t\tds--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* JPEG_MARKER_APP1 */\n\t\t\tif (ds && d[0] == JPEG_MARKER_APP1)\n\t\t\t\tbreak;\n\n\t\t\t/* Skip irrelevant APP markers. The branch for APP1 must come before this,\n\t\t\t   otherwise this code block will cause APP1 to be skipped. This code path\n\t\t\t   is only relevant for files that are nonconformant to the EXIF\n\t\t\t   specification. For conformant files, the APP1 code path above will be\n\t\t\t   taken. */\n\t\t\tif (ds >= 3 && d[0] >= 0xe0 && d[0] <= 0xef) {  /* JPEG_MARKER_APPn */\n\t\t\t\td++;\n\t\t\t\tds--;\n\t\t\t\tl = (d[0] << 8) | d[1];\n\t\t\t\tif (l > ds)\n\t\t\t\t\treturn;\n\t\t\t\td += l;\n\t\t\t\tds -= l;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Unknown marker or data. Give up. */\n\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifData\", _(\"EXIF marker not found.\"));\n\t\t\treturn;\n\t\t}\n\t\tif (ds < 3) {\n\t\t\tLOG_TOO_SMALL;\n\t\t\treturn;\n\t\t}\n\t\td++;\n\t\tds--;\n\t\tlen = (d[0] << 8) | d[1];\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t  \"We have to deal with %i byte(s) of EXIF data.\",\n\t\t\t  len);\n\t\td += 2;\n\t\tds -= 2;\n\t}\n\n\t/*\n\t * Verify the exif header\n\t * (offset 2, length 6).\n\t */\n\tif (ds < 6) {\n\t\tLOG_TOO_SMALL;\n\t\treturn;\n\t}\n\tif (memcmp (d, ExifHeader, 6)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifData\", _(\"EXIF header not found.\"));\n\t\treturn;\n\t}\n\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t  \"Found EXIF header.\");\n\n\t/* Sanity check the data length */\n\tif (ds < 14)\n\t\treturn;\n\n\t/* The JPEG APP1 section can be no longer than 64 KiB (including a\n\t   16-bit length), so cap the data length to protect against overflow\n\t   in future offset calculations */\n\tfullds = ds;\n\tif (ds > 0xfffe)\n\t\tds = 0xfffe;\n\n\t/* Byte order (offset 6, length 2) */\n\tif (!memcmp (d + 6, \"II\", 2))\n\t\tdata->priv->order = EXIF_BYTE_ORDER_INTEL;\n\telse if (!memcmp (d + 6, \"MM\", 2))\n\t\tdata->priv->order = EXIF_BYTE_ORDER_MOTOROLA;\n\telse {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifData\", _(\"Unknown encoding.\"));\n\t\treturn;\n\t}\n\n\t/* Fixed value */\n\tif (exif_get_short (d + 8, data->priv->order) != 0x002a)\n\t\treturn;\n\n\t/* IFD 0 offset */\n\toffset = exif_get_long (d + 10, data->priv->order);\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\", \n\t\t  \"IFD 0 at %i.\", (int) offset);\n\n\t/* Sanity check the offset, being careful about overflow */\n\tif (offset > ds || offset + 6 + 2 > ds)\n\t\treturn;\n\n\t/* Parse the actual exif data (usually offset 14 from start) */\n\texif_data_load_data_content (data, EXIF_IFD_0, d + 6, ds - 6, offset, 0);\n\n\t/* IFD 1 offset */\n\tn = exif_get_short (d + 6 + offset, data->priv->order);\n\tif (offset + 6 + 2 + 12 * n + 4 > ds)\n\t\treturn;\n\n\toffset = exif_get_long (d + 6 + offset + 2 + 12 * n, data->priv->order);\n\tif (offset) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t  \"IFD 1 at %i.\", (int) offset);\n\n\t\t/* Sanity check. */\n\t\tif (offset > ds || offset + 6 > ds) {\n\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifData\", \"Bogus offset of IFD1.\");\n\t\t} else {\n\t\t   exif_data_load_data_content (data, EXIF_IFD_1, d + 6, ds - 6, offset, 0);\n\t\t}\n\t}\n\n\t/*\n\t * If we got an EXIF_TAG_MAKER_NOTE, try to interpret it. Some\n\t * cameras use pointers in the maker note tag that point to the\n\t * space between IFDs. Here is the only place where we have access\n\t * to that data.\n\t */\n\tinterpret_maker_note(data, d, fullds);\n\n\t/* Fixup tags if requested */\n\tif (data->priv->options & EXIF_DATA_OPTION_FOLLOW_SPECIFICATION)\n\t\texif_data_fix (data);\n}",
        "start_line": 822
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "libexif/exif-data.c",
        "method_name": "exif_data_load_data_entry",
        "raw_code": "static int /* <=== exif_data_load_data_entry */ \nexif_data_load_data_entry (ExifData *data, ExifEntry *entry,\n\t\t\t   const unsigned char *d,\n\t\t\t   unsigned int size, unsigned int offset)\n{\n\tunsigned int s, doff;\n\n\tentry->tag        = exif_get_short (d + offset + 0, data->priv->order);\n\tentry->format     = exif_get_short (d + offset + 2, data->priv->order);\n\tentry->components = exif_get_long  (d + offset + 4, data->priv->order);\n\n\t/* FIXME: should use exif_tag_get_name_in_ifd here but entry->parent \n\t * has not been set yet\n\t */\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t  \"Loading entry 0x%x ('%s')...\", entry->tag,\n\t\t  exif_tag_get_name (entry->tag));\n\n\t/* {0,1,2,4,8} x { 0x00000000 .. 0xffffffff } \n\t *   -> { 0x000000000 .. 0x7fffffff8 } */\n\ts = exif_format_get_size(entry->format) * entry->components;\n\tif ((s < entry->components) || (s == 0)){\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Size? If bigger than 4 bytes, the actual data is not\n\t * in the entry but somewhere else (offset).\n\t */\n\tif (s > 4)\n\t\tdoff = exif_get_long (d + offset + 8, data->priv->order);\n\telse\n\t\tdoff = offset + 8;\n\n\t/* Sanity checks */\n\tif (doff >= size) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t  \"Tag starts past end of buffer (%u > %u)\", doff, size);\n\t\treturn 0;\n\t}\n\n\tif (s > size - doff) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t  \"Tag data goes past end of buffer (%u > %u)\", doff+s, size);\n\t\treturn 0;\n\t}\n\n\tentry->data = exif_data_alloc (data, s);\n\tif (entry->data) {\n\t\tentry->size = s;\n\t\tmemcpy (entry->data, d + doff, s);\n\t} else {\n\t\tEXIF_LOG_NO_MEMORY(data->priv->log, \"ExifData\", s);\n\t\treturn 0;\n\t}\n\n\t/* If this is the MakerNote, remember the offset */\n\tif (entry->tag == EXIF_TAG_MAKER_NOTE) {\n\t\tif (!entry->data) {\n\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t\t  \"MakerNote found with empty data\");\t\n\t\t} else if (entry->size > 6) {\n\t\t\texif_log (data->priv->log,\n\t\t\t\t\t       EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t\t       \"MakerNote found (%02x %02x %02x %02x \"\n\t\t\t\t\t       \"%02x %02x %02x...).\",\n\t\t\t\t\t       entry->data[0], entry->data[1], entry->data[2],\n\t\t\t\t\t       entry->data[3], entry->data[4], entry->data[5],\n\t\t\t\t\t       entry->data[6]);\n\t\t}\n\t\tdata->priv->offset_mnote = doff;\n\t}\n\treturn 1;\n}",
        "start_line": 160
      },
      {
        "filename": "libexif/exif-data.c",
        "method_name": "exif_data_load_data_thumbnail",
        "raw_code": "static void /* <=== exif_data_load_data_thumbnail */ \nexif_data_load_data_thumbnail (ExifData *data, const unsigned char *d,\n\t\t\t       unsigned int ds, ExifLong o, ExifLong s)\n{\n\t/* Sanity checks */\n\tif (o >= ds) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\", \"Bogus thumbnail offset (%u).\", o);\n\t\treturn;\n\t}\n\tif (s > ds - o) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\", \"Bogus thumbnail size (%u), max would be %u.\", s, ds-o);\n\t\treturn;\n\t}\n\tif (data->data) \n\t\texif_mem_free (data->priv->mem, data->data);\n\tif (!(data->data = exif_data_alloc (data, s))) {\n\t\tEXIF_LOG_NO_MEMORY (data->priv->log, \"ExifData\", s);\n\t\tdata->size = 0;\n\t\treturn;\n\t}\n\tdata->size = s;\n\tmemcpy (data->data, d + o, s);\n}",
        "start_line": 319
      },
      {
        "filename": "libexif/exif-data.c",
        "method_name": "exif_data_load_data",
        "raw_code": "void /* <=== exif_data_load_data */ \nexif_data_load_data (ExifData *data, const unsigned char *d_orig,\n\t\t     unsigned int ds)\n{\n\tunsigned int l;\n\tExifLong offset;\n\tExifShort n;\n\tconst unsigned char *d = d_orig;\n\tunsigned int len, fullds;\n\n\tif (!data || !data->priv || !d || !ds)\n\t\treturn;\n\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t  \"Parsing %i byte(s) EXIF data...\\n\", ds);\n\n\t/*\n\t * It can be that the data starts with the EXIF header. If it does\n\t * not, search the EXIF marker.\n\t */\n\tif (ds < 6) {\n\t\tLOG_TOO_SMALL;\n\t\treturn;\n\t}\n\tif (!memcmp (d, ExifHeader, 6)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t  \"Found EXIF header at start.\");\n\t} else {\n\t\twhile (ds >= 3) {\n\t\t\twhile (ds && (d[0] == 0xff)) {\n\t\t\t\td++;\n\t\t\t\tds--;\n\t\t\t}\n\n\t\t\t/* JPEG_MARKER_SOI */\n\t\t\tif (ds && d[0] == JPEG_MARKER_SOI) {\n\t\t\t\td++;\n\t\t\t\tds--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* JPEG_MARKER_APP1 */\n\t\t\tif (ds && d[0] == JPEG_MARKER_APP1)\n\t\t\t\tbreak;\n\n\t\t\t/* Skip irrelevant APP markers. The branch for APP1 must come before this,\n\t\t\t   otherwise this code block will cause APP1 to be skipped. This code path\n\t\t\t   is only relevant for files that are nonconformant to the EXIF\n\t\t\t   specification. For conformant files, the APP1 code path above will be\n\t\t\t   taken. */\n\t\t\tif (ds >= 3 && d[0] >= 0xe0 && d[0] <= 0xef) {  /* JPEG_MARKER_APPn */\n\t\t\t\td++;\n\t\t\t\tds--;\n\t\t\t\tl = (d[0] << 8) | d[1];\n\t\t\t\tif (l > ds)\n\t\t\t\t\treturn;\n\t\t\t\td += l;\n\t\t\t\tds -= l;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Unknown marker or data. Give up. */\n\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifData\", _(\"EXIF marker not found.\"));\n\t\t\treturn;\n\t\t}\n\t\tif (ds < 3) {\n\t\t\tLOG_TOO_SMALL;\n\t\t\treturn;\n\t\t}\n\t\td++;\n\t\tds--;\n\t\tlen = (d[0] << 8) | d[1];\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t  \"We have to deal with %i byte(s) of EXIF data.\",\n\t\t\t  len);\n\t\td += 2;\n\t\tds -= 2;\n\t}\n\n\t/*\n\t * Verify the exif header\n\t * (offset 2, length 6).\n\t */\n\tif (ds < 6) {\n\t\tLOG_TOO_SMALL;\n\t\treturn;\n\t}\n\tif (memcmp (d, ExifHeader, 6)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifData\", _(\"EXIF header not found.\"));\n\t\treturn;\n\t}\n\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t  \"Found EXIF header.\");\n\n\t/* Sanity check the data length */\n\tif (ds < 14)\n\t\treturn;\n\n\t/* The JPEG APP1 section can be no longer than 64 KiB (including a\n\t   16-bit length), so cap the data length to protect against overflow\n\t   in future offset calculations */\n\tfullds = ds;\n\tif (ds > 0xfffe)\n\t\tds = 0xfffe;\n\n\t/* Byte order (offset 6, length 2) */\n\tif (!memcmp (d + 6, \"II\", 2))\n\t\tdata->priv->order = EXIF_BYTE_ORDER_INTEL;\n\telse if (!memcmp (d + 6, \"MM\", 2))\n\t\tdata->priv->order = EXIF_BYTE_ORDER_MOTOROLA;\n\telse {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifData\", _(\"Unknown encoding.\"));\n\t\treturn;\n\t}\n\n\t/* Fixed value */\n\tif (exif_get_short (d + 8, data->priv->order) != 0x002a)\n\t\treturn;\n\n\t/* IFD 0 offset */\n\toffset = exif_get_long (d + 10, data->priv->order);\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\", \n\t\t  \"IFD 0 at %i.\", (int) offset);\n\n\t/* ds is restricted to 16 bit above, so offset is restricted too, and offset+8 should not overflow. */\n\tif (offset > ds || offset + 6 + 2 > ds)\n\t\treturn;\n\n\t/* Parse the actual exif data (usually offset 14 from start) */\n\texif_data_load_data_content (data, EXIF_IFD_0, d + 6, ds - 6, offset, 0);\n\n\t/* IFD 1 offset */\n\tn = exif_get_short (d + 6 + offset, data->priv->order);\n\t/* offset < 2<<16, n is 16 bit at most, so this op will not overflow */\n\tif (offset + 6 + 2 + 12 * n + 4 > ds)\n\t\treturn;\n\n\toffset = exif_get_long (d + 6 + offset + 2 + 12 * n, data->priv->order);\n\tif (offset) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t  \"IFD 1 at %i.\", (int) offset);\n\n\t\t/* Sanity check. ds is ensured to be above 6 above, offset is 16bit */\n\t\tif (offset > ds - 6) {\n\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifData\", \"Bogus offset of IFD1.\");\n\t\t} else {\n\t\t   exif_data_load_data_content (data, EXIF_IFD_1, d + 6, ds - 6, offset, 0);\n\t\t}\n\t}\n\n\t/*\n\t * If we got an EXIF_TAG_MAKER_NOTE, try to interpret it. Some\n\t * cameras use pointers in the maker note tag that point to the\n\t * space between IFDs. Here is the only place where we have access\n\t * to that data.\n\t */\n\tinterpret_maker_note(data, d, fullds);\n\n\t/* Fixup tags if requested */\n\tif (data->priv->options & EXIF_DATA_OPTION_FOLLOW_SPECIFICATION)\n\t\texif_data_fix (data);\n}",
        "start_line": 829
      }
    ],
    "code_context": "Called Methods:\n- exif_data_load_data_content: static void /* <=== exif_data_load_data_content */ \nexif_data_load_data_content (ExifData *data, ExifIfd ifd,\n\t\t\t     const unsigned char *d,\n\t\t\t     unsigned int ds, unsigned int offset, unsigned int recursion_cost)\n{\n\tExifLong o, thumbnail_offset = 0, thumbnail_length = 0;\n\tExifShort n;\n\tExifEntry *entry;\n\tunsigned int i;\n\tExifTag tag;\n\n\tif (!data || !data->priv) \n\t\treturn;\n\n\t/* check for valid ExifIfd enum range */\n\tif ((((int)ifd) < 0) || ( ((int)ifd) >= EXIF_IFD_COUNT))\n\t  return;\n\n\tif (recursion_cost > 170) {\n\t\t/*\n\t\t * recursion_cost is a logarithmic-scale indicator of how expensive this\n\t\t * recursive call might end up being. It is an indicator of the depth of\n\t\t * recursion as well as the potential for worst-case future recursive\n\t\t * calls. Since it's difficult to tell ahead of time how often recursion\n\t\t * will occur, this assumes the worst by assuming every tag could end up\n\t\t * causing recursion.\n\t\t * The value of 170 was chosen to limit typical EXIF structures to a\n\t\t * recursive depth of about 6, but pathological ones (those with very\n\t\t * many tags) to only 2.\n\t\t */\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA, \"ExifData\",\n\t\t\t  \"Deep/expensive recursion detected!\");\n\t\treturn;\n\t}\n\n\t/* Read the number of entries */\n\tif ((offset + 2 < offset) || (offset + 2 < 2) || (offset + 2 > ds)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA, \"ExifData\",\n\t\t\t  \"Tag data past end of buffer (%u > %u)\", offset+2, ds);\n\t\treturn;\n\t}\n\tn = exif_get_short (d + offset, data->priv->order);\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t          \"Loading %hu entries...\", n);\n\toffset += 2;\n\n\t/* Check if we have enough data. */\n\tif (offset + 12 * n > ds) {\n\t\tn = (ds - offset) / 12;\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t  \"Short data; only loading %hu entries...\", n);\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\n\t\ttag = exif_get_short (d + offset + 12 * i, data->priv->order);\n\t\tswitch (tag) {\n\t\tcase EXIF_TAG_EXIF_IFD_POINTER:\n\t\tcase EXIF_TAG_GPS_INFO_IFD_POINTER:\n\t\tcase EXIF_TAG_INTEROPERABILITY_IFD_POINTER:\n\t\tcase EXIF_TAG_JPEG_INTERCHANGE_FORMAT_LENGTH:\n\t\tcase EXIF_TAG_JPEG_INTERCHANGE_FORMAT:\n\t\t\to = exif_get_long (d + offset + 12 * i + 8,\n\t\t\t\t\t   data->priv->order);\n\t\t\t/* FIXME: IFD_POINTER tags aren't marked as being in a\n\t\t\t * specific IFD, so exif_tag_get_name_in_ifd won't work\n\t\t\t */\n\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t  \"Sub-IFD entry 0x%x ('%s') at %u.\", tag,\n\t\t\t\t  exif_tag_get_name(tag), o);\n\t\t\tswitch (tag) {\n\t\t\tcase EXIF_TAG_EXIF_IFD_POINTER:\n\t\t\t\tCHECK_REC (EXIF_IFD_EXIF);\n\t\t\t\texif_data_load_data_content (data, EXIF_IFD_EXIF, d, ds, o,\n\t\t\t\t\trecursion_cost + level_cost(n));\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_GPS_INFO_IFD_POINTER:\n\t\t\t\tCHECK_REC (EXIF_IFD_GPS);\n\t\t\t\texif_data_load_data_content (data, EXIF_IFD_GPS, d, ds, o,\n\t\t\t\t\trecursion_cost + level_cost(n));\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_INTEROPERABILITY_IFD_POINTER:\n\t\t\t\tCHECK_REC (EXIF_IFD_INTEROPERABILITY);\n\t\t\t\texif_data_load_data_content (data, EXIF_IFD_INTEROPERABILITY, d, ds, o,\n\t\t\t\t\trecursion_cost + level_cost(n));\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_JPEG_INTERCHANGE_FORMAT:\n\t\t\t\tthumbnail_offset = o;\n\t\t\t\tif (thumbnail_offset && thumbnail_length)\n\t\t\t\t\texif_data_load_data_thumbnail (data, d,\n\t\t\t\t\t\t\t\t       ds, thumbnail_offset,\n\t\t\t\t\t\t\t\t       thumbnail_length);\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_JPEG_INTERCHANGE_FORMAT_LENGTH:\n\t\t\t\tthumbnail_length = o;\n\t\t\t\tif (thumbnail_offset && thumbnail_length)\n\t\t\t\t\texif_data_load_data_thumbnail (data, d,\n\t\t\t\t\t\t\t\t       ds, thumbnail_offset,\n\t\t\t\t\t\t\t\t       thumbnail_length);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\n\t\t\t/*\n\t\t\t * If we don't know the tag, don't fail. It could be that new \n\t\t\t * versions of the standard have defined additional tags. Note that\n\t\t\t * 0 is a valid tag in the GPS IFD.\n\t\t\t */\n\t\t\tif (!exif_tag_get_name_in_ifd (tag, ifd)) {\n\n\t\t\t\t/*\n\t\t\t\t * Special case: Tag and format 0. That's against specification\n\t\t\t\t * (at least up to 2.2). But Photoshop writes it anyways.\n\t\t\t\t */\n\t\t\t\tif (!memcmp (d + offset + 12 * i, \"\\0\\0\\0\\0\", 4)) {\n\t\t\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t\t\t  \"Skipping empty entry at position %u in '%s'.\", i, \n\t\t\t\t\t\t  exif_ifd_get_name (ifd));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t\t  \"Unknown tag 0x%04x (entry %u in '%s'). Please report this tag \"\n\t\t\t\t\t  \"to <libexif-devel@lists.sourceforge.net>.\", tag, i,\n\t\t\t\t\t  exif_ifd_get_name (ifd));\n\t\t\t\tif (data->priv->options & EXIF_DATA_OPTION_IGNORE_UNKNOWN_TAGS)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tentry = exif_entry_new_mem (data->priv->mem);\n\t\t\tif (!entry) {\n\t\t\t\t  exif_log (data->priv->log, EXIF_LOG_CODE_NO_MEMORY, \"ExifData\",\n                                          \"Could not allocate memory\");\n\t\t\t\t  return;\n\t\t\t}\n\t\t\tif (exif_data_load_data_entry (data, entry, d, ds,\n\t\t\t\t\t\t   offset + 12 * i))\n\t\t\t\texif_content_add_entry (data->ifd[ifd], entry);\n\t\t\texif_entry_unref (entry);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n- exif_mnote_data_set_byte_order: void /* <=== exif_mnote_data_set_byte_order */ \nexif_mnote_data_set_byte_order (ExifMnoteData *d, ExifByteOrder o)\n{\n\tif (!d || !d->methods.set_byte_order) return;\n\td->methods.set_byte_order (d, o);\n}\n- exif_logv: void /* <=== exif_logv */ \nexif_logv (ExifLog *log, ExifLogCode code, const char *domain,\n\t   const char *format, va_list args)\n{\n\tif (!log) return;\n\tif (!log->func) return;\n\tlog->func (log, code, domain, format, args, log->data);\n}\n- exif_mnote_data_olympus_new: ExifMnoteData * /* <=== exif_mnote_data_olympus_new */ \nexif_mnote_data_olympus_new (ExifMem *mem)\n{\n\tExifMnoteData *d;\n\n\tif (!mem) return NULL;\n\t\n\td = exif_mem_alloc (mem, sizeof (ExifMnoteDataOlympus));\n\tif (!d) return NULL;\n\n\texif_mnote_data_construct (d, mem);\n\n\t/* Set up function pointers */\n\td->methods.free            = exif_mnote_data_olympus_free;\n\td->methods.set_byte_order  = exif_mnote_data_olympus_set_byte_order;\n\td->methods.set_offset      = exif_mnote_data_olympus_set_offset;\n\td->methods.load            = exif_mnote_data_olympus_load;\n\td->methods.save            = exif_mnote_data_olympus_save;\n\td->methods.count           = exif_mnote_data_olympus_count;\n\td->methods.get_id          = exif_mnote_data_olympus_get_id;\n\td->methods.get_name        = exif_mnote_data_olympus_get_name;\n\td->methods.get_title       = exif_mnote_data_olympus_get_title;\n\td->methods.get_description = exif_mnote_data_olympus_get_description;\n\td->methods.get_value       = exif_mnote_data_olympus_get_value;\n\n\treturn d;\n}\n- interpret_maker_note: static void /* <=== interpret_maker_note */ \ninterpret_maker_note(ExifData *data, const unsigned char *d, unsigned int ds)\n{\n\tint mnoteid;\n\tExifEntry* e = exif_data_get_entry (data, EXIF_TAG_MAKER_NOTE);\n\tif (!e)\n\t\treturn;\n\t\n\tif ((mnoteid = exif_mnote_data_olympus_identify (data, e)) != 0) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\"ExifData\", \"Olympus MakerNote variant type %d\", mnoteid);\n\t\tdata->priv->md = exif_mnote_data_olympus_new (data->priv->mem);\n\n\t} else if ((mnoteid = exif_mnote_data_canon_identify (data, e)) != 0) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\"ExifData\", \"Canon MakerNote variant type %d\", mnoteid);\n\t\tdata->priv->md = exif_mnote_data_canon_new (data->priv->mem, data->priv->options);\n\n\t} else if ((mnoteid = exif_mnote_data_fuji_identify (data, e)) != 0) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\"ExifData\", \"Fuji MakerNote variant type %d\", mnoteid);\n\t\tdata->priv->md = exif_mnote_data_fuji_new (data->priv->mem);\n\n\t/* NOTE: Must do Pentax detection last because some of the\n\t * heuristics are pretty general. */\n\t} else if ((mnoteid = exif_mnote_data_pentax_identify (data, e)) != 0) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\"ExifData\", \"Pentax MakerNote variant type %d\", mnoteid);\n\t\tdata->priv->md = exif_mnote_data_pentax_new (data->priv->mem);\n\t}\n\n\t/* \n\t * If we are able to interpret the maker note, do so.\n\t */\n\tif (data->priv->md) {\n\t\texif_mnote_data_log (data->priv->md, data->priv->log);\n\t\texif_mnote_data_set_byte_order (data->priv->md,\n\t\t\t\t\t\tdata->priv->order);\n\t\texif_mnote_data_set_offset (data->priv->md,\n\t\t\t\t\t    data->priv->offset_mnote);\n\t\texif_mnote_data_load (data->priv->md, d, ds);\n\t}\n}\n- JPEG_MARKER_APP1: #define JPEG_MARKER_APP1 0xe1 /* <=== libexif/exif-data.c:48:48:JPEG_MARKER_APP1:0 */ \n- exif_mnote_data_olympus_identify: int /* <=== exif_mnote_data_olympus_identify */ \nexif_mnote_data_olympus_identify (const ExifData *ed, const ExifEntry *e)\n{\n\tint variant = exif_mnote_data_olympus_identify_variant(e->data, e->size);\n\n\tif (variant == nikonV0) {\n\t\t/* This variant needs some extra checking with the Make */\n\t\tchar value[5];\n\t\tExifEntry *em = exif_data_get_entry (ed, EXIF_TAG_MAKE);\n\t\tvariant = unrecognized;\n\n\t\tif (em) {\n\t\t\tconst char *v = exif_entry_get_value (em, value, sizeof(value));\n\t\t\tif (v && (!strncmp (v, \"Nikon\", sizeof(value)) || \n\t\t\t\t\t  !strncmp (v, \"NIKON\", sizeof(value)) ))\n\t\t\t\t/* When saved, this variant will be written out like the\n\t\t\t\t * alternative nikonV2 form above instead\n\t\t\t\t */\n\t\t\t\tvariant = nikonV0;\n\t\t}\n\t}\n\n\treturn variant;\n}\n- exif_data_fix: void /* <=== exif_data_fix */ \nexif_data_fix (ExifData *d)\n{\n\texif_data_foreach_content (d, fix_func, NULL);\n}\n- exif_entry_new_mem: ExifEntry * /* <=== exif_entry_new_mem */ \nexif_entry_new_mem (ExifMem *mem)\n{\n\tExifEntry *e = NULL;\n\n\te = exif_mem_alloc (mem, sizeof (ExifEntry));\n\tif (!e) return NULL;\n\te->priv = exif_mem_alloc (mem, sizeof (ExifEntryPrivate));\n\tif (!e->priv) { exif_mem_free (mem, e); return NULL; }\n\te->priv->ref_count = 1;\n\n\te->priv->mem = mem;\n\texif_mem_ref (mem);\n\n\treturn e;\n}\n- exif_entry_unref: void /* <=== exif_entry_unref */ \nexif_entry_unref (ExifEntry *e)\n{\n\tif (!e) return;\n\n\te->priv->ref_count--;\n\tif (!e->priv->ref_count)\n\t\texif_entry_free (e);\n}\n- exif_mnote_data_log: void /* <=== exif_mnote_data_log */ \nexif_mnote_data_log (ExifMnoteData *d, ExifLog *log)\n{\n\tif (!d) return;\n\texif_log_unref (d->log);\n\td->log = log;\n\texif_log_ref (log);\n}\n- exif_tag_get_name_in_ifd: const char * /* <=== exif_tag_get_name_in_ifd */ \nexif_tag_get_name_in_ifd (ExifTag tag, ExifIfd ifd)\n{\n\tunsigned int i;\n\tint first;\n\n\tif (ifd >= EXIF_IFD_COUNT)\n\t\treturn NULL;\n\tfirst = exif_tag_table_first(tag);\n\tif (first < 0)\n\t\treturn NULL;\n\n\tfor (i = first; ExifTagTable[i].name; i++) {\n\t\tif (ExifTagTable[i].tag == tag) {\n\t\t   if (RECORDED)\n\t\t\t   break;\n\t\t} else\n\t\t\treturn NULL; /* Recorded tag not found in the table */\n\t}\n\treturn ExifTagTable[i].name;\n}\n- exif_mnote_data_pentax_identify: int /* <=== exif_mnote_data_pentax_identify */ \nexif_mnote_data_pentax_identify (const ExifData *ed, const ExifEntry *e)\n{\n\t(void) ed;  /* unused */\n\tif ((e->size >= 8) && !memcmp (e->data, \"AOC\", 4)) {\n\t\tif (((e->data[4] == 'I') && (e->data[5] == 'I')) ||\n\t\t    ((e->data[4] == 'M') && (e->data[5] == 'M')))\n\t\t\treturn pentaxV3;\n\t\telse\n\t\t\t/* Uses Casio v2 tags */\n\t\t\treturn pentaxV2;\n\t}\n\n\tif ((e->size >= 8) && !memcmp (e->data, \"QVC\", 4))\n\t\treturn casioV2;\n\n\t/* This isn't a very robust test, so make sure it's done last */\n\t/* Maybe we should additionally check for a make of Asahi or Pentax */\n\tif ((e->size >= 2) && (e->data[0] == 0x00) && (e->data[1] == 0x1b))\n\t\treturn pentaxV1;\n\n\treturn 0;\n}\n- exif_mnote_data_set_offset: void /* <=== exif_mnote_data_set_offset */ \nexif_mnote_data_set_offset (ExifMnoteData *d, unsigned int o)\n{\n\tif (!d || !d->methods.set_offset) return;\n\td->methods.set_offset (d, o);\n}\n- exif_get_short: ExifShort /* <=== exif_get_short */ \nexif_get_short (const unsigned char *buf, ExifByteOrder order)\n{\n\treturn (exif_get_sshort (buf, order) & 0xffff);\n}\n- exif_mem_free: void  exif_mem_free    (ExifMem *m, void *p); /* <=== exif_mem_free */ \n- exif_content_add_entry: void /* <=== exif_content_add_entry */ \nexif_content_add_entry (ExifContent *c, ExifEntry *entry)\n{\n\tExifEntry **entries;\n\tif (!c || !c->priv || !entry || entry->parent) return;\n\n\t/* One tag can only be added once to an IFD. */\n\tif (exif_content_get_entry (c, entry->tag)) {\n\t\texif_log (c->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifContent\",\n\t\t\t\"An attempt has been made to add \"\n\t\t\t\"the tag '%s' twice to an IFD. This is against \"\n\t\t\t\"specification.\", exif_tag_get_name (entry->tag));\n\t\treturn;\n\t}\n\n\tentries = exif_mem_realloc (c->priv->mem,\n\t\tc->entries, sizeof (ExifEntry*) * (c->count + 1));\n\tif (!entries) return;\n\tentry->parent = c;\n\tentries[c->count++] = entry;\n\tc->entries = entries;\n\texif_entry_ref (entry);\n}\n- exif_get_long: ExifLong /* <=== exif_get_long */ \nexif_get_long (const unsigned char *buf, ExifByteOrder order)\n{\n        return (exif_get_slong (buf, order) & 0xffffffff);\n}\n- exif_mnote_data_fuji_new: ExifMnoteData * /* <=== exif_mnote_data_fuji_new */ \nexif_mnote_data_fuji_new (ExifMem *mem)\n{\n\tExifMnoteData *d;\n\n\tif (!mem) return NULL;\n\n\td = exif_mem_alloc (mem, sizeof (ExifMnoteDataFuji));\n\tif (!d) return NULL;\n\n\texif_mnote_data_construct (d, mem);\n\n\t/* Set up function pointers */\n\td->methods.free            = exif_mnote_data_fuji_free;\n\td->methods.set_byte_order  = exif_mnote_data_fuji_set_byte_order;\n\td->methods.set_offset      = exif_mnote_data_fuji_set_offset;\n\td->methods.load            = exif_mnote_data_fuji_load;\n\td->methods.save            = exif_mnote_data_fuji_save;\n\td->methods.count           = exif_mnote_data_fuji_count;\n\td->methods.get_id          = exif_mnote_data_fuji_get_id;\n\td->methods.get_name        = exif_mnote_data_fuji_get_name;\n\td->methods.get_title       = exif_mnote_data_fuji_get_title;\n\td->methods.get_description = exif_mnote_data_fuji_get_description;\n\td->methods.get_value       = exif_mnote_data_fuji_get_value;\n\n\treturn d;\n}\n- exif_mnote_data_canon_identify: int /* <=== exif_mnote_data_canon_identify */ \nexif_mnote_data_canon_identify (const ExifData *ed, const ExifEntry *e)\n{\n\tchar value[8];\n\n\t(void) e;  /* unused */\n\tExifEntry *em = exif_data_get_entry (ed, EXIF_TAG_MAKE);\n\tif (!em) \n\t\treturn 0;\n\treturn !strcmp (exif_entry_get_value (em, value, sizeof (value)), \"Canon\");\n}\n- exif_mem_alloc: void *exif_mem_alloc   (ExifMem *m, ExifLong s); /* <=== exif_mem_alloc */ \n- CHECK_REC: #define CHECK_REC(i) \t\t\t\t\t\\ /* <=== libexif/exif-data.c:344:359:CHECK_REC:1 */ \nif ((i) == ifd) {\t\t\t\t\\\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \\\n\t\t\"ExifData\", \"Recursive entry in IFD \"\t\\\n\t\t\"'%s' detected. Skipping...\",\t\t\\\n\t\texif_ifd_get_name (i));\t\t\t\\\n\tbreak;\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\\\nif (data->ifd[(i)]->count) {\t\t\t\t\\\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG,\t\\\n\t\t\"ExifData\", \"Attempt to load IFD \"\t\\\n\t\t\"'%s' multiple times detected. \"\t\\\n\t\t\"Skipping...\",\t\t\t\t\\\n\t\texif_ifd_get_name (i));\t\t\t\\\n\tbreak;\t\t\t\t\t\t\\\n}\n- exif_get_slong: ExifSLong /* <=== exif_get_slong */ \nexif_get_slong (const unsigned char *b, ExifByteOrder order)\n{\n\tif (!b) return 0;\n        switch (order) {\n        case EXIF_BYTE_ORDER_MOTOROLA:\n                return ((b[0] << 24) | (b[1] << 16) | (b[2] << 8) | b[3]);\n        case EXIF_BYTE_ORDER_INTEL:\n                return ((b[3] << 24) | (b[2] << 16) | (b[1] << 8) | b[0]);\n        }\n\n\t/* Won't be reached */\n\treturn (0);\n}\n- exif_data_foreach_content: void /* <=== exif_data_foreach_content */ \nexif_data_foreach_content (ExifData *data, ExifDataForeachContentFunc func,\n\t\t\t   void *user_data)\n{\n\tunsigned int i;\n\n\tif (!data || !func)\n\t\treturn;\n\n\tfor (i = 0; i < EXIF_IFD_COUNT; i++)\n\t\tfunc (data->ifd[i], user_data);\n}\n- exif_format_get_size: unsigned char exif_format_get_size (ExifFormat format); /* <=== exif_format_get_size */ \n- exif_tag_get_name: const char * /* <=== exif_tag_get_name */ \nexif_tag_get_name (ExifTag tag)\n{\n\treturn exif_tag_get_stuff(tag, exif_tag_get_name_in_ifd);\n}\n- exif_ifd_get_name: const char * /* <=== exif_ifd_get_name */ \nexif_ifd_get_name (ExifIfd ifd)\n{\n\tunsigned int i;\n\n\tfor (i = 0; ExifIfdTable[i].name; i++)\n\t\tif (ExifIfdTable[i].ifd == ifd)\n\t\t\tbreak;\n\n\treturn (ExifIfdTable[i].name);\n}\n- exif_mnote_data_canon_new: ExifMnoteData * /* <=== exif_mnote_data_canon_new */ \nexif_mnote_data_canon_new (ExifMem *mem, ExifDataOption o)\n{\n\tExifMnoteData *d;\n\tExifMnoteDataCanon *dc;\n\n\tif (!mem) return NULL;\n\n\td = exif_mem_alloc (mem, sizeof (ExifMnoteDataCanon));\n\tif (!d)\n\t\treturn NULL;\n\n\texif_mnote_data_construct (d, mem);\n\n\t/* Set up function pointers */\n\td->methods.free            = exif_mnote_data_canon_free;\n\td->methods.set_byte_order  = exif_mnote_data_canon_set_byte_order;\n\td->methods.set_offset      = exif_mnote_data_canon_set_offset;\n\td->methods.load            = exif_mnote_data_canon_load;\n\td->methods.save            = exif_mnote_data_canon_save;\n\td->methods.count           = exif_mnote_data_canon_count;\n\td->methods.get_id          = exif_mnote_data_canon_get_id;\n\td->methods.get_name        = exif_mnote_data_canon_get_name;\n\td->methods.get_title       = exif_mnote_data_canon_get_title;\n\td->methods.get_description = exif_mnote_data_canon_get_description;\n\td->methods.get_value       = exif_mnote_data_canon_get_value;\n\n\tdc = (ExifMnoteDataCanon*)d;\n\tdc->options = o;\n\treturn d;\n}\n- exif_data_alloc: static void * /* <=== exif_data_alloc */ \nexif_data_alloc (ExifData *data, unsigned int i)\n{\n\tvoid *d;\n\n\tif (!data || !i) \n\t\treturn NULL;\n\n\td = exif_mem_alloc (data->priv->mem, i);\n\tif (d) \n\t\treturn d;\n\n\tEXIF_LOG_NO_MEMORY (data->priv->log, \"ExifData\", i);\n\treturn NULL;\n}\n- exif_get_sshort: ExifSShort /* <=== exif_get_sshort */ \nexif_get_sshort (const unsigned char *buf, ExifByteOrder order)\n{\n\tif (!buf) return 0;\n        switch (order) {\n        case EXIF_BYTE_ORDER_MOTOROLA:\n                return ((buf[0] << 8) | buf[1]);\n        case EXIF_BYTE_ORDER_INTEL:\n                return ((buf[1] << 8) | buf[0]);\n        }\n\n\t/* Won't be reached */\n\treturn (0);\n}\n- exif_mnote_data_fuji_identify: int /* <=== exif_mnote_data_fuji_identify */ \nexif_mnote_data_fuji_identify (const ExifData *ed, const ExifEntry *e)\n{\n\t(void) ed;  /* unused */\n\treturn ((e->size >= 12) && !memcmp (e->data, \"FUJIFILM\", 8));\n}\n- level_cost: static unsigned int /* <=== level_cost */ \nlevel_cost(unsigned int n)\n{\n    static const double log_1_1 = 0.09531017980432493;\n\n\t/* Adding 0.1 protects against the case where n==1 */\n\treturn ceil(log(n + 0.1)/log_1_1);\n}\n- exif_mnote_data_load: void /* <=== exif_mnote_data_load */ \nexif_mnote_data_load (ExifMnoteData *d, const unsigned char *buf,\n\t\t      unsigned int buf_size)\n{\n\tif (!d || !d->methods.load) return;\n\td->methods.load (d, buf, buf_size);\n}\n- JPEG_MARKER_SOI: #define JPEG_MARKER_SOI  0xd8 /* <=== libexif/exif-data.c:44:44:JPEG_MARKER_SOI:0 */ \n- exif_log: void /* <=== exif_log */ \nexif_log (ExifLog *log, ExifLogCode code, const char *domain,\n\t  const char *format, ...)\n{\n\tva_list args;\n\n\tva_start (args, format);\n\texif_logv (log, code, domain, format, args);\n\tva_end (args);\n}\n- CHECK_REC: #define CHECK_REC(i) \t\t\t\t\t\\ /* <=== libexif/exif-data.c:337:352:CHECK_REC:1 */ \nif ((i) == ifd) {\t\t\t\t\\\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \\\n\t\t\"ExifData\", \"Recursive entry in IFD \"\t\\\n\t\t\"'%s' detected. Skipping...\",\t\t\\\n\t\texif_ifd_get_name (i));\t\t\t\\\n\tbreak;\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\\\nif (data->ifd[(i)]->count) {\t\t\t\t\\\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG,\t\\\n\t\t\"ExifData\", \"Attempt to load IFD \"\t\\\n\t\t\"'%s' multiple times detected. \"\t\\\n\t\t\"Skipping...\",\t\t\t\t\\\n\t\texif_ifd_get_name (i));\t\t\t\\\n\tbreak;\t\t\t\t\t\t\\\n}\n- exif_mnote_data_pentax_new: ExifMnoteData * /* <=== exif_mnote_data_pentax_new */ \nexif_mnote_data_pentax_new (ExifMem *mem)\n{\n\tExifMnoteData *d;\n\n\tif (!mem) return NULL;\n\n\td = exif_mem_alloc (mem, sizeof (ExifMnoteDataPentax));\n\tif (!d) return NULL;\n\n\texif_mnote_data_construct (d, mem);\n\n\t/* Set up function pointers */\n\td->methods.free            = exif_mnote_data_pentax_free;\n\td->methods.set_byte_order  = exif_mnote_data_pentax_set_byte_order;\n\td->methods.set_offset      = exif_mnote_data_pentax_set_offset;\n\td->methods.load            = exif_mnote_data_pentax_load;\n\td->methods.save            = exif_mnote_data_pentax_save;\n\td->methods.count           = exif_mnote_data_pentax_count;\n\td->methods.get_id          = exif_mnote_data_pentax_get_id;\n\td->methods.get_name        = exif_mnote_data_pentax_get_name;\n\td->methods.get_title       = exif_mnote_data_pentax_get_title;\n\td->methods.get_description = exif_mnote_data_pentax_get_description;\n\td->methods.get_value       = exif_mnote_data_pentax_get_value;\n\n\treturn d;\n}\n\nType Definitions:\n- ExifLong: typedef uint32_t\tExifLong;\n- ExifShort: typedef uint16_t\tExifShort;\n- ExifData: typedef struct _ExifData        ExifData;\n\nGlobal Variables:\n- static const unsigned char[] ExifHeader\n\nImports:\n- #include <libexif/canon/exif-mnote-data-canon.h>\n- #include <libexif/exif-mnote-data-priv.h>\n- #include <libexif/exif-utils.h>\n- #include <libexif/fuji/exif-mnote-data-fuji.h>\n- #include <libexif/olympus/exif-mnote-data-olympus.h>\n- #include <libexif/exif-mnote-data.h>\n- #include <libexif/exif-ifd.h>\n- #include <libexif/exif-loader.h>\n- #include <libexif/exif-log.h>\n- #include <math.h>\n- #include <stdlib.h>\n- #include <config.h>\n- #include <libexif/pentax/exif-mnote-data-pentax.h>\n- #include <libexif/exif-data.h>\n- #include <libexif/exif-system.h>\n- #include <stdio.h>\n- #include <libexif/i18n.h>\n- #include <string.h>",
    "commit_msg": "fix CVE-2019-9278\n\navoid the use of unsafe integer overflow checking constructs (unsigned integer operations cannot overflow, so \"u1 + u2 > u1\" can be optimized away)\n\ncheck for the actual sizes, which should also handle the overflows\ndocument other places google patched, but do not seem relevant due to other restrictions\n\nfixes https://github.com/libexif/libexif/issues/26",
    "cve_desc": "[{'lang': 'en', 'value': 'In libexif, there is a possible out of bounds write due to an integer overflow. This could lead to remote escalation of privilege in the media content provider with no additional execution privileges needed. User interaction is needed for exploitation. Product: AndroidVersions: Android-10Android ID: A-112537774'}]",
    "year": 2020,
    "filename": "exif-data.c",
    "commit_url": "\"https://github.com/libexif/libexif/commit/75aa73267fdb1e0ebfbc00369e7312bac43d0566\""
  },
  {
    "repository": "libexif/libexif",
    "cve_id": "CVE-2020-0093",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "5ae5973bed1947f4d447dc80b76d5cefadd90133",
    "short_hash": "5ae5973b",
    "vulnerableMethods_before": [
      {
        "filename": "libexif/exif-data.c",
        "method_name": "exif_data_save_data_entry",
        "raw_code": "static void /* <=== exif_data_save_data_entry */ \nexif_data_save_data_entry (ExifData *data, ExifEntry *e,\n\t\t\t   unsigned char **d, unsigned int *ds,\n\t\t\t   unsigned int offset)\n{\n\tunsigned int doff, s;\n\tunsigned int ts;\n\n\tif (!data || !data->priv) \n\t\treturn;\n\n\t/*\n\t * Each entry is 12 bytes long. The memory for the entry has\n\t * already been allocated.\n\t */\n\texif_set_short (*d + 6 + offset + 0,\n\t\t\tdata->priv->order, (ExifShort) e->tag);\n\texif_set_short (*d + 6 + offset + 2,\n\t\t\tdata->priv->order, (ExifShort) e->format);\n\n\tif (!(data->priv->options & EXIF_DATA_OPTION_DONT_CHANGE_MAKER_NOTE)) {\n\t\t/* If this is the maker note tag, update it. */\n\t\tif ((e->tag == EXIF_TAG_MAKER_NOTE) && data->priv->md) {\n\t\t\t/* TODO: this is using the wrong ExifMem to free e->data */\n\t\t\texif_mem_free (data->priv->mem, e->data);\n\t\t\te->data = NULL;\n\t\t\te->size = 0;\n\t\t\texif_mnote_data_set_offset (data->priv->md, *ds - 6);\n\t\t\texif_mnote_data_save (data->priv->md, &e->data, &e->size);\n\t\t\te->components = e->size;\n\t\t\tif (exif_format_get_size (e->format) != 1) {\n\t\t\t\t/* e->format is taken from input code,\n\t\t\t\t * but we need to make sure it is a 1 byte\n\t\t\t\t * entity due to the multiplication below. */\n\t\t\t\te->format = EXIF_FORMAT_UNDEFINED;\n\t\t\t}\n\t\t}\n\t}\n\n\texif_set_long  (*d + 6 + offset + 4,\n\t\t\tdata->priv->order, e->components);\n\n\t/*\n\t * Size? If bigger than 4 bytes, the actual data is not in\n\t * the entry but somewhere else.\n\t */\n\ts = exif_format_get_size (e->format) * e->components;\n\tif (s > 4) {\n\t\tunsigned char *t;\n\t\tdoff = *ds - 6;\n\t\tts = *ds + s;\n\n\t\t/*\n\t\t * According to the TIFF specification,\n\t\t * the offset must be an even number. If we need to introduce\n\t\t * a padding byte, we set it to 0.\n\t\t */\n\t\tif (s & 1)\n\t\t\tts++;\n\t\tt = exif_mem_realloc (data->priv->mem, *d, ts);\n\t\tif (!t) {\n\t\t\tEXIF_LOG_NO_MEMORY (data->priv->log, \"ExifData\", ts);\n\t\t  \treturn;\n\t\t}\n\t\t*d = t;\n\t\t*ds = ts;\n\t\texif_set_long (*d + 6 + offset + 8, data->priv->order, doff);\n\t\tif (s & 1) \n\t\t\t*(*d + *ds - 1) = '\\0';\n\n\t} else\n\t\tdoff = offset + 8;\n\n\t/* Write the data. Fill unneeded bytes with 0. Do not crash with\n\t * e->data is NULL */\n\tif (e->data) {\n\t\tmemcpy (*d + 6 + doff, e->data, s);\n\t} else {\n\t\tmemset (*d + 6 + doff, 0, s);\n\t}\n\tif (s < 4) \n\t\tmemset (*d + 6 + doff + s, 0, (4 - s));\n}",
        "start_line": 235
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "libexif/exif-data.c",
        "method_name": "exif_data_save_data_entry",
        "raw_code": "static void /* <=== exif_data_save_data_entry */ \nexif_data_save_data_entry (ExifData *data, ExifEntry *e,\n\t\t\t   unsigned char **d, unsigned int *ds,\n\t\t\t   unsigned int offset)\n{\n\tunsigned int doff, s;\n\tunsigned int ts;\n\n\tif (!data || !data->priv) \n\t\treturn;\n\n\t/*\n\t * Each entry is 12 bytes long. The memory for the entry has\n\t * already been allocated.\n\t */\n\texif_set_short (*d + 6 + offset + 0,\n\t\t\tdata->priv->order, (ExifShort) e->tag);\n\texif_set_short (*d + 6 + offset + 2,\n\t\t\tdata->priv->order, (ExifShort) e->format);\n\n\tif (!(data->priv->options & EXIF_DATA_OPTION_DONT_CHANGE_MAKER_NOTE)) {\n\t\t/* If this is the maker note tag, update it. */\n\t\tif ((e->tag == EXIF_TAG_MAKER_NOTE) && data->priv->md) {\n\t\t\t/* TODO: this is using the wrong ExifMem to free e->data */\n\t\t\texif_mem_free (data->priv->mem, e->data);\n\t\t\te->data = NULL;\n\t\t\te->size = 0;\n\t\t\texif_mnote_data_set_offset (data->priv->md, *ds - 6);\n\t\t\texif_mnote_data_save (data->priv->md, &e->data, &e->size);\n\t\t\te->components = e->size;\n\t\t\tif (exif_format_get_size (e->format) != 1) {\n\t\t\t\t/* e->format is taken from input code,\n\t\t\t\t * but we need to make sure it is a 1 byte\n\t\t\t\t * entity due to the multiplication below. */\n\t\t\t\te->format = EXIF_FORMAT_UNDEFINED;\n\t\t\t}\n\t\t}\n\t}\n\n\texif_set_long  (*d + 6 + offset + 4,\n\t\t\tdata->priv->order, e->components);\n\n\t/*\n\t * Size? If bigger than 4 bytes, the actual data is not in\n\t * the entry but somewhere else.\n\t */\n\ts = exif_format_get_size (e->format) * e->components;\n\tif (s > 4) {\n\t\tunsigned char *t;\n\t\tdoff = *ds - 6;\n\t\tts = *ds + s;\n\n\t\t/*\n\t\t * According to the TIFF specification,\n\t\t * the offset must be an even number. If we need to introduce\n\t\t * a padding byte, we set it to 0.\n\t\t */\n\t\tif (s & 1)\n\t\t\tts++;\n\t\tt = exif_mem_realloc (data->priv->mem, *d, ts);\n\t\tif (!t) {\n\t\t\tEXIF_LOG_NO_MEMORY (data->priv->log, \"ExifData\", ts);\n\t\t  \treturn;\n\t\t}\n\t\t*d = t;\n\t\t*ds = ts;\n\t\texif_set_long (*d + 6 + offset + 8, data->priv->order, doff);\n\t\tif (s & 1) \n\t\t\t*(*d + *ds - 1) = '\\0';\n\n\t} else\n\t\tdoff = offset + 8;\n\n\t/* Write the data. Fill unneeded bytes with 0. Do not crash with\n\t * e->data is NULL */\n\tif (e->data) {\n\t\tunsigned int len = s;\n\t\tif (e->size < s) len = e->size;\n\t\tmemcpy (*d + 6 + doff, e->data, len);\n\t} else {\n\t\tmemset (*d + 6 + doff, 0, s);\n\t}\n\tif (s < 4) \n\t\tmemset (*d + 6 + doff + s, 0, (4 - s));\n}",
        "start_line": 235
      }
    ],
    "code_context": "Called Methods:\n- exif_format_get_size: unsigned char exif_format_get_size (ExifFormat format); /* <=== exif_format_get_size */ \n- exif_mem_realloc: void *exif_mem_realloc (ExifMem *m, void *p, ExifLong s); /* <=== exif_mem_realloc */ \n\nType Definitions:\n- ExifData: typedef struct _ExifData        ExifData;\n\nImports:\n- #include <libexif/exif-utils.h>\n- #include <libexif/exif-system.h>\n- #include <libexif/exif-data.h>\n- #include <libexif/canon/exif-mnote-data-canon.h>\n- #include <libexif/pentax/exif-mnote-data-pentax.h>\n- #include <libexif/exif-mnote-data.h>\n- #include <config.h>\n- #include <stdlib.h>\n- #include <libexif/exif-loader.h>\n- #include <math.h>\n- #include <libexif/exif-mnote-data-priv.h>\n- #include <libexif/fuji/exif-mnote-data-fuji.h>\n- #include <libexif/exif-log.h>\n- #include <stdio.h>\n- #include <libexif/i18n.h>\n- #include <string.h>\n- #include <libexif/olympus/exif-mnote-data-olympus.h>\n- #include <libexif/exif-ifd.h>",
    "commit_msg": "libexif: Fix read buffer overflow (CVE-2020-0093)\n\nMake sure the number of bytes being copied from doesn't exceed the\nsource buffer size.\n\nFrom Android repo:\nhttps://android.googlesource.com/platform/external/libexif/+/0335ffc17f9b9a4831c242bb08ea92f605fde7a6%5E%21/#F0\n\nTest: testPocBug_148705132\nBug: 148705132\n\nfixes https://github.com/libexif/libexif/issues/42",
    "cve_desc": "In exif_data_save_data_entry of exif-data.c, there is a possible out of bounds read due to a missing bounds check. This could lead to local information disclosure with no additional execution privileges needed. User interaction is needed for exploitation.Product: AndroidVersions: Android-8.0 Android-8.1 Android-9 Android-10Android ID: A-148705132",
    "year": 2020,
    "filename": "exif-data.c",
    "commit_url": "\"https://github.com/libexif/libexif/commit/5ae5973bed1947f4d447dc80b76d5cefadd90133\""
  },
  {
    "repository": "libexif/libexif",
    "cve_id": "CVE-2020-0181",
    "cwe_list": [
      "CWE-190"
    ],
    "commit_hash": "ce03ad7ef4e8aeefce79192bf5b6f69fae396f0c",
    "short_hash": "ce03ad7e",
    "vulnerableMethods_before": [
      {
        "filename": "libexif/exif-data.c",
        "method_name": "exif_data_load_data_thumbnail",
        "raw_code": "static void /* <=== exif_data_load_data_thumbnail */ \nexif_data_load_data_thumbnail (ExifData *data, const unsigned char *d,\n\t\t\t       unsigned int ds, ExifLong o, ExifLong s)\n{\n\t/* Sanity checks */\n\tif (o >= ds) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\", \"Bogus thumbnail offset (%u).\", o);\n\t\treturn;\n\t}\n\tif (s > ds - o) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\", \"Bogus thumbnail size (%u), max would be %u.\", s, ds-o);\n\t\treturn;\n\t}\n\tif (data->data) \n\t\texif_mem_free (data->priv->mem, data->data);\n\tif (!(data->data = exif_data_alloc (data, s))) {\n\t\tEXIF_LOG_NO_MEMORY (data->priv->log, \"ExifData\", s);\n\t\tdata->size = 0;\n\t\treturn;\n\t}\n\tdata->size = s;\n\tmemcpy (data->data, d + o, s);\n}",
        "start_line": 321
      },
      {
        "filename": "libexif/exif-data.c",
        "method_name": "exif_data_load_data_content",
        "raw_code": "static void /* <=== exif_data_load_data_content */ \nexif_data_load_data_content (ExifData *data, ExifIfd ifd,\n\t\t\t     const unsigned char *d,\n\t\t\t     unsigned int ds, unsigned int offset, unsigned int recursion_cost)\n{\n\tExifLong o, thumbnail_offset = 0, thumbnail_length = 0;\n\tExifShort n;\n\tExifEntry *entry;\n\tunsigned int i;\n\tExifTag tag;\n\n\tif (!data || !data->priv) \n\t\treturn;\n\n\t/* check for valid ExifIfd enum range */\n\tif ((((int)ifd) < 0) || ( ((int)ifd) >= EXIF_IFD_COUNT))\n\t  return;\n\n\tif (recursion_cost > 170) {\n\t\t/*\n\t\t * recursion_cost is a logarithmic-scale indicator of how expensive this\n\t\t * recursive call might end up being. It is an indicator of the depth of\n\t\t * recursion as well as the potential for worst-case future recursive\n\t\t * calls. Since it's difficult to tell ahead of time how often recursion\n\t\t * will occur, this assumes the worst by assuming every tag could end up\n\t\t * causing recursion.\n\t\t * The value of 170 was chosen to limit typical EXIF structures to a\n\t\t * recursive depth of about 6, but pathological ones (those with very\n\t\t * many tags) to only 2.\n\t\t */\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA, \"ExifData\",\n\t\t\t  \"Deep/expensive recursion detected!\");\n\t\treturn;\n\t}\n\n\t/* Read the number of entries */\n\tif ((offset + 2 < offset) || (offset + 2 < 2) || (offset + 2 > ds)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA, \"ExifData\",\n\t\t\t  \"Tag data past end of buffer (%u > %u)\", offset+2, ds);\n\t\treturn;\n\t}\n\tn = exif_get_short (d + offset, data->priv->order);\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t          \"Loading %hu entries...\", n);\n\toffset += 2;\n\n\t/* Check if we have enough data. */\n\tif (offset + 12 * n > ds) {\n\t\tn = (ds - offset) / 12;\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t  \"Short data; only loading %hu entries...\", n);\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\n\t\ttag = exif_get_short (d + offset + 12 * i, data->priv->order);\n\t\tswitch (tag) {\n\t\tcase EXIF_TAG_EXIF_IFD_POINTER:\n\t\tcase EXIF_TAG_GPS_INFO_IFD_POINTER:\n\t\tcase EXIF_TAG_INTEROPERABILITY_IFD_POINTER:\n\t\tcase EXIF_TAG_JPEG_INTERCHANGE_FORMAT_LENGTH:\n\t\tcase EXIF_TAG_JPEG_INTERCHANGE_FORMAT:\n\t\t\to = exif_get_long (d + offset + 12 * i + 8,\n\t\t\t\t\t   data->priv->order);\n\t\t\tif (o >= ds) {\n\t\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA, \"ExifData\",\n\t\t\t\t\t  \"Tag data past end of buffer (%u > %u)\", offset+2, ds);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/* FIXME: IFD_POINTER tags aren't marked as being in a\n\t\t\t * specific IFD, so exif_tag_get_name_in_ifd won't work\n\t\t\t */\n\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t  \"Sub-IFD entry 0x%x ('%s') at %u.\", tag,\n\t\t\t\t  exif_tag_get_name(tag), o);\n\t\t\tswitch (tag) {\n\t\t\tcase EXIF_TAG_EXIF_IFD_POINTER:\n\t\t\t\tCHECK_REC (EXIF_IFD_EXIF);\n\t\t\t\texif_data_load_data_content (data, EXIF_IFD_EXIF, d, ds, o,\n\t\t\t\t\trecursion_cost + level_cost(n));\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_GPS_INFO_IFD_POINTER:\n\t\t\t\tCHECK_REC (EXIF_IFD_GPS);\n\t\t\t\texif_data_load_data_content (data, EXIF_IFD_GPS, d, ds, o,\n\t\t\t\t\trecursion_cost + level_cost(n));\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_INTEROPERABILITY_IFD_POINTER:\n\t\t\t\tCHECK_REC (EXIF_IFD_INTEROPERABILITY);\n\t\t\t\texif_data_load_data_content (data, EXIF_IFD_INTEROPERABILITY, d, ds, o,\n\t\t\t\t\trecursion_cost + level_cost(n));\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_JPEG_INTERCHANGE_FORMAT:\n\t\t\t\tthumbnail_offset = o;\n\t\t\t\tif (thumbnail_offset && thumbnail_length)\n\t\t\t\t\texif_data_load_data_thumbnail (data, d,\n\t\t\t\t\t\t\t\t       ds, thumbnail_offset,\n\t\t\t\t\t\t\t\t       thumbnail_length);\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_JPEG_INTERCHANGE_FORMAT_LENGTH:\n\t\t\t\tthumbnail_length = o;\n\t\t\t\tif (thumbnail_offset && thumbnail_length)\n\t\t\t\t\texif_data_load_data_thumbnail (data, d,\n\t\t\t\t\t\t\t\t       ds, thumbnail_offset,\n\t\t\t\t\t\t\t\t       thumbnail_length);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\n\t\t\t/*\n\t\t\t * If we don't know the tag, don't fail. It could be that new \n\t\t\t * versions of the standard have defined additional tags. Note that\n\t\t\t * 0 is a valid tag in the GPS IFD.\n\t\t\t */\n\t\t\tif (!exif_tag_get_name_in_ifd (tag, ifd)) {\n\n\t\t\t\t/*\n\t\t\t\t * Special case: Tag and format 0. That's against specification\n\t\t\t\t * (at least up to 2.2). But Photoshop writes it anyways.\n\t\t\t\t */\n\t\t\t\tif (!memcmp (d + offset + 12 * i, \"\\0\\0\\0\\0\", 4)) {\n\t\t\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t\t\t  \"Skipping empty entry at position %u in '%s'.\", i, \n\t\t\t\t\t\t  exif_ifd_get_name (ifd));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t\t  \"Unknown tag 0x%04x (entry %u in '%s'). Please report this tag \"\n\t\t\t\t\t  \"to <libexif-devel@lists.sourceforge.net>.\", tag, i,\n\t\t\t\t\t  exif_ifd_get_name (ifd));\n\t\t\t\tif (data->priv->options & EXIF_DATA_OPTION_IGNORE_UNKNOWN_TAGS)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tentry = exif_entry_new_mem (data->priv->mem);\n\t\t\tif (!entry) {\n\t\t\t\t  exif_log (data->priv->log, EXIF_LOG_CODE_NO_MEMORY, \"ExifData\",\n                                          \"Could not allocate memory\");\n\t\t\t\t  return;\n\t\t\t}\n\t\t\tif (exif_data_load_data_entry (data, entry, d, ds,\n\t\t\t\t\t\t   offset + 12 * i))\n\t\t\t\texif_content_add_entry (data->ifd[ifd], entry);\n\t\t\texif_entry_unref (entry);\n\t\t\tbreak;\n\t\t}\n\t}\n}",
        "start_line": 387
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "libexif/exif-data.c",
        "method_name": "exif_data_load_data_thumbnail",
        "raw_code": "static void /* <=== exif_data_load_data_thumbnail */ \nexif_data_load_data_thumbnail (ExifData *data, const unsigned char *d,\n\t\t\t       unsigned int ds, ExifLong o, ExifLong s)\n{\n\t/* Sanity checks */\n\tif (o >= ds) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\", \"Bogus thumbnail offset (%u).\", o);\n\t\treturn;\n\t}\n\tif (CHECKOVERFLOW(o,ds,s)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\", \"Bogus thumbnail size (%u), max would be %u.\", s, ds-o);\n\t\treturn;\n\t}\n\tif (data->data) \n\t\texif_mem_free (data->priv->mem, data->data);\n\tif (!(data->data = exif_data_alloc (data, s))) {\n\t\tEXIF_LOG_NO_MEMORY (data->priv->log, \"ExifData\", s);\n\t\tdata->size = 0;\n\t\treturn;\n\t}\n\tdata->size = s;\n\tmemcpy (data->data, d + o, s);\n}",
        "start_line": 323
      },
      {
        "filename": "libexif/exif-data.c",
        "method_name": "exif_data_load_data_content",
        "raw_code": "static void /* <=== exif_data_load_data_content */ \nexif_data_load_data_content (ExifData *data, ExifIfd ifd,\n\t\t\t     const unsigned char *d,\n\t\t\t     unsigned int ds, unsigned int offset, unsigned int recursion_cost)\n{\n\tExifLong o, thumbnail_offset = 0, thumbnail_length = 0;\n\tExifShort n;\n\tExifEntry *entry;\n\tunsigned int i;\n\tExifTag tag;\n\n\tif (!data || !data->priv) \n\t\treturn;\n\n\t/* check for valid ExifIfd enum range */\n\tif ((((int)ifd) < 0) || ( ((int)ifd) >= EXIF_IFD_COUNT))\n\t  return;\n\n\tif (recursion_cost > 170) {\n\t\t/*\n\t\t * recursion_cost is a logarithmic-scale indicator of how expensive this\n\t\t * recursive call might end up being. It is an indicator of the depth of\n\t\t * recursion as well as the potential for worst-case future recursive\n\t\t * calls. Since it's difficult to tell ahead of time how often recursion\n\t\t * will occur, this assumes the worst by assuming every tag could end up\n\t\t * causing recursion.\n\t\t * The value of 170 was chosen to limit typical EXIF structures to a\n\t\t * recursive depth of about 6, but pathological ones (those with very\n\t\t * many tags) to only 2.\n\t\t */\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA, \"ExifData\",\n\t\t\t  \"Deep/expensive recursion detected!\");\n\t\treturn;\n\t}\n\n\t/* Read the number of entries */\n\tif (CHECKOVERFLOW(offset, ds, 2)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA, \"ExifData\",\n\t\t\t  \"Tag data past end of buffer (%u+2 > %u)\", offset, ds);\n\t\treturn;\n\t}\n\tn = exif_get_short (d + offset, data->priv->order);\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t          \"Loading %hu entries...\", n);\n\toffset += 2;\n\n\t/* Check if we have enough data. */\n\tif (CHECKOVERFLOW(offset, ds, 12*n)) {\n\t\tn = (ds - offset) / 12;\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t  \"Short data; only loading %hu entries...\", n);\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\n\t\ttag = exif_get_short (d + offset + 12 * i, data->priv->order);\n\t\tswitch (tag) {\n\t\tcase EXIF_TAG_EXIF_IFD_POINTER:\n\t\tcase EXIF_TAG_GPS_INFO_IFD_POINTER:\n\t\tcase EXIF_TAG_INTEROPERABILITY_IFD_POINTER:\n\t\tcase EXIF_TAG_JPEG_INTERCHANGE_FORMAT_LENGTH:\n\t\tcase EXIF_TAG_JPEG_INTERCHANGE_FORMAT:\n\t\t\to = exif_get_long (d + offset + 12 * i + 8,\n\t\t\t\t\t   data->priv->order);\n\t\t\tif (o >= ds) {\n\t\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA, \"ExifData\",\n\t\t\t\t\t  \"Tag data past end of buffer (%u > %u)\", offset+2, ds);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/* FIXME: IFD_POINTER tags aren't marked as being in a\n\t\t\t * specific IFD, so exif_tag_get_name_in_ifd won't work\n\t\t\t */\n\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t  \"Sub-IFD entry 0x%x ('%s') at %u.\", tag,\n\t\t\t\t  exif_tag_get_name(tag), o);\n\t\t\tswitch (tag) {\n\t\t\tcase EXIF_TAG_EXIF_IFD_POINTER:\n\t\t\t\tCHECK_REC (EXIF_IFD_EXIF);\n\t\t\t\texif_data_load_data_content (data, EXIF_IFD_EXIF, d, ds, o,\n\t\t\t\t\trecursion_cost + level_cost(n));\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_GPS_INFO_IFD_POINTER:\n\t\t\t\tCHECK_REC (EXIF_IFD_GPS);\n\t\t\t\texif_data_load_data_content (data, EXIF_IFD_GPS, d, ds, o,\n\t\t\t\t\trecursion_cost + level_cost(n));\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_INTEROPERABILITY_IFD_POINTER:\n\t\t\t\tCHECK_REC (EXIF_IFD_INTEROPERABILITY);\n\t\t\t\texif_data_load_data_content (data, EXIF_IFD_INTEROPERABILITY, d, ds, o,\n\t\t\t\t\trecursion_cost + level_cost(n));\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_JPEG_INTERCHANGE_FORMAT:\n\t\t\t\tthumbnail_offset = o;\n\t\t\t\tif (thumbnail_offset && thumbnail_length)\n\t\t\t\t\texif_data_load_data_thumbnail (data, d,\n\t\t\t\t\t\t\t\t       ds, thumbnail_offset,\n\t\t\t\t\t\t\t\t       thumbnail_length);\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_JPEG_INTERCHANGE_FORMAT_LENGTH:\n\t\t\t\tthumbnail_length = o;\n\t\t\t\tif (thumbnail_offset && thumbnail_length)\n\t\t\t\t\texif_data_load_data_thumbnail (data, d,\n\t\t\t\t\t\t\t\t       ds, thumbnail_offset,\n\t\t\t\t\t\t\t\t       thumbnail_length);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\n\t\t\t/*\n\t\t\t * If we don't know the tag, don't fail. It could be that new \n\t\t\t * versions of the standard have defined additional tags. Note that\n\t\t\t * 0 is a valid tag in the GPS IFD.\n\t\t\t */\n\t\t\tif (!exif_tag_get_name_in_ifd (tag, ifd)) {\n\n\t\t\t\t/*\n\t\t\t\t * Special case: Tag and format 0. That's against specification\n\t\t\t\t * (at least up to 2.2). But Photoshop writes it anyways.\n\t\t\t\t */\n\t\t\t\tif (!memcmp (d + offset + 12 * i, \"\\0\\0\\0\\0\", 4)) {\n\t\t\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t\t\t  \"Skipping empty entry at position %u in '%s'.\", i, \n\t\t\t\t\t\t  exif_ifd_get_name (ifd));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t\t  \"Unknown tag 0x%04x (entry %u in '%s'). Please report this tag \"\n\t\t\t\t\t  \"to <libexif-devel@lists.sourceforge.net>.\", tag, i,\n\t\t\t\t\t  exif_ifd_get_name (ifd));\n\t\t\t\tif (data->priv->options & EXIF_DATA_OPTION_IGNORE_UNKNOWN_TAGS)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tentry = exif_entry_new_mem (data->priv->mem);\n\t\t\tif (!entry) {\n\t\t\t\t  exif_log (data->priv->log, EXIF_LOG_CODE_NO_MEMORY, \"ExifData\",\n                                          \"Could not allocate memory\");\n\t\t\t\t  return;\n\t\t\t}\n\t\t\tif (exif_data_load_data_entry (data, entry, d, ds,\n\t\t\t\t\t\t   offset + 12 * i))\n\t\t\t\texif_content_add_entry (data->ifd[ifd], entry);\n\t\t\texif_entry_unref (entry);\n\t\t\tbreak;\n\t\t}\n\t}\n}",
        "start_line": 389
      }
    ],
    "code_context": "Called Methods:\n- exif_get_slong: ExifSLong /* <=== exif_get_slong */ \nexif_get_slong (const unsigned char *b, ExifByteOrder order)\n{\n\tif (!b) return 0;\n        switch (order) {\n        case EXIF_BYTE_ORDER_MOTOROLA:\n                return (((uint32_t)b[0] << 24) | ((uint32_t)b[1] << 16) | ((uint32_t)b[2] << 8) | (uint32_t)b[3]);\n        case EXIF_BYTE_ORDER_INTEL:\n                return (((uint32_t)b[3] << 24) | ((uint32_t)b[2] << 16) | ((uint32_t)b[1] << 8) | (uint32_t)b[0]);\n        }\n\n\t/* Won't be reached */\n\treturn (0);\n}\n- CHECK_REC: #define CHECK_REC(i) \t\t\t\t\t\\ /* <=== libexif/exif-data.c:348:363:CHECK_REC:1 */ \nif ((i) == ifd) {\t\t\t\t\\\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \\\n\t\t\"ExifData\", \"Recursive entry in IFD \"\t\\\n\t\t\"'%s' detected. Skipping...\",\t\t\\\n\t\texif_ifd_get_name (i));\t\t\t\\\n\tbreak;\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\\\nif (data->ifd[(i)]->count) {\t\t\t\t\\\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG,\t\\\n\t\t\"ExifData\", \"Attempt to load IFD \"\t\\\n\t\t\"'%s' multiple times detected. \"\t\\\n\t\t\"Skipping...\",\t\t\t\t\\\n\t\texif_ifd_get_name (i));\t\t\t\\\n\tbreak;\t\t\t\t\t\t\\\n}\n- exif_get_sshort: ExifSShort /* <=== exif_get_sshort */ \nexif_get_sshort (const unsigned char *buf, ExifByteOrder order)\n{\n\tif (!buf) return 0;\n        switch (order) {\n        case EXIF_BYTE_ORDER_MOTOROLA:\n                return ((buf[0] << 8) | buf[1]);\n        case EXIF_BYTE_ORDER_INTEL:\n                return ((buf[1] << 8) | buf[0]);\n        }\n\n\t/* Won't be reached */\n\treturn (0);\n}\n- exif_mem_free: void  exif_mem_free    (ExifMem *m, void *p); /* <=== exif_mem_free */ \n- exif_content_add_entry: void         exif_content_add_entry    (ExifContent *c, ExifEntry *entry); /* <=== exif_content_add_entry */ \n- CHECK_REC: #define CHECK_REC(i) \t\t\t\t\t\\ /* <=== libexif/exif-data.c:346:361:CHECK_REC:1 */ \nif ((i) == ifd) {\t\t\t\t\\\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \\\n\t\t\"ExifData\", \"Recursive entry in IFD \"\t\\\n\t\t\"'%s' detected. Skipping...\",\t\t\\\n\t\texif_ifd_get_name (i));\t\t\t\\\n\tbreak;\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\\\nif (data->ifd[(i)]->count) {\t\t\t\t\\\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG,\t\\\n\t\t\"ExifData\", \"Attempt to load IFD \"\t\\\n\t\t\"'%s' multiple times detected. \"\t\\\n\t\t\"Skipping...\",\t\t\t\t\\\n\t\texif_ifd_get_name (i));\t\t\t\\\n\tbreak;\t\t\t\t\t\t\\\n}\n- exif_format_get_size: unsigned char exif_format_get_size (ExifFormat format); /* <=== exif_format_get_size */ \n- exif_ifd_get_name: const char * /* <=== exif_ifd_get_name */ \nexif_ifd_get_name (ExifIfd ifd)\n{\n\tunsigned int i;\n\n\tfor (i = 0; ExifIfdTable[i].name; i++)\n\t\tif (ExifIfdTable[i].ifd == ifd)\n\t\t\tbreak;\n\n\treturn (ExifIfdTable[i].name);\n}\n- exif_get_long: ExifLong /* <=== exif_get_long */ \nexif_get_long (const unsigned char *buf, ExifByteOrder order)\n{\n        return (exif_get_slong (buf, order) & 0xffffffff);\n}\n- level_cost: static unsigned int /* <=== level_cost */ \nlevel_cost(unsigned int n)\n{\n    static const double log_1_1 = 0.09531017980432493;\n\n\t/* Adding 0.1 protects against the case where n==1 */\n\treturn ceil(log(n + 0.1)/log_1_1);\n}\n- exif_logv: void /* <=== exif_logv */ \nexif_logv (ExifLog *log, ExifLogCode code, const char *domain,\n\t   const char *format, va_list args)\n{\n\tif (!log) return;\n\tif (!log->func) return;\n\tlog->func (log, code, domain, format, args, log->data);\n}\n- exif_tag_get_name_in_ifd: const char      *exif_tag_get_name_in_ifd          (ExifTag tag, ExifIfd ifd); /* <=== exif_tag_get_name_in_ifd */ \n- exif_get_short: ExifShort /* <=== exif_get_short */ \nexif_get_short (const unsigned char *buf, ExifByteOrder order)\n{\n\treturn (exif_get_sshort (buf, order) & 0xffff);\n}\n- exif_log: void /* <=== exif_log */ \nexif_log (ExifLog *log, ExifLogCode code, const char *domain,\n\t  const char *format, ...)\n{\n\tva_list args;\n\n\tva_start (args, format);\n\texif_logv (log, code, domain, format, args);\n\tva_end (args);\n}\n- exif_data_load_data_entry: static int /* <=== exif_data_load_data_entry */ \nexif_data_load_data_entry (ExifData *data, ExifEntry *entry,\n\t\t\t   const unsigned char *d,\n\t\t\t   unsigned int size, unsigned int offset)\n{\n\tunsigned int s, doff;\n\n\tentry->tag        = exif_get_short (d + offset + 0, data->priv->order);\n\tentry->format     = exif_get_short (d + offset + 2, data->priv->order);\n\tentry->components = exif_get_long  (d + offset + 4, data->priv->order);\n\n\t/* FIXME: should use exif_tag_get_name_in_ifd here but entry->parent \n\t * has not been set yet\n\t */\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t  \"Loading entry 0x%x ('%s')...\", entry->tag,\n\t\t  exif_tag_get_name (entry->tag));\n\n\t/* {0,1,2,4,8} x { 0x00000000 .. 0xffffffff } \n\t *   -> { 0x000000000 .. 0x7fffffff8 } */\n\ts = exif_format_get_size(entry->format) * entry->components;\n\tif ((s < entry->components) || (s == 0)){\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Size? If bigger than 4 bytes, the actual data is not\n\t * in the entry but somewhere else (offset).\n\t */\n\tif (s > 4)\n\t\tdoff = exif_get_long (d + offset + 8, data->priv->order);\n\telse\n\t\tdoff = offset + 8;\n\n\t/* Sanity checks */\n\tif (doff >= size) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t  \"Tag starts past end of buffer (%u > %u)\", doff, size);\n\t\treturn 0;\n\t}\n\n\tif (s > size - doff) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t  \"Tag data goes past end of buffer (%u > %u)\", doff+s, size);\n\t\treturn 0;\n\t}\n\n\tentry->data = exif_data_alloc (data, s);\n\tif (entry->data) {\n\t\tentry->size = s;\n\t\tmemcpy (entry->data, d + doff, s);\n\t} else {\n\t\tEXIF_LOG_NO_MEMORY(data->priv->log, \"ExifData\", s);\n\t\treturn 0;\n\t}\n\n\t/* If this is the MakerNote, remember the offset */\n\tif (entry->tag == EXIF_TAG_MAKER_NOTE) {\n\t\tif (!entry->data) {\n\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t\t  \"MakerNote found with empty data\");\t\n\t\t} else if (entry->size > 6) {\n\t\t\texif_log (data->priv->log,\n\t\t\t\t\t       EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t\t       \"MakerNote found (%02x %02x %02x %02x \"\n\t\t\t\t\t       \"%02x %02x %02x...).\",\n\t\t\t\t\t       entry->data[0], entry->data[1], entry->data[2],\n\t\t\t\t\t       entry->data[3], entry->data[4], entry->data[5],\n\t\t\t\t\t       entry->data[6]);\n\t\t}\n\t\tdata->priv->offset_mnote = doff;\n\t}\n\treturn 1;\n}\n- exif_mem_alloc: void *exif_mem_alloc   (ExifMem *m, ExifLong s); /* <=== exif_mem_alloc */ \n- CHECKOVERFLOW: #define CHECKOVERFLOW(offset,datasize,structsize) (( offset >= datasize) || (structsize > datasize) || (offset > datasize - structsize )) /* <=== libexif/exif-data.c:50:50:CHECKOVERFLOW:3 */ \n- exif_tag_get_name: const char     *exif_tag_get_name        (ExifTag tag); /* <=== exif_tag_get_name */ \n- exif_data_alloc: static void * /* <=== exif_data_alloc */ \nexif_data_alloc (ExifData *data, unsigned int i)\n{\n\tvoid *d;\n\n\tif (!data || !i) \n\t\treturn NULL;\n\n\td = exif_mem_alloc (data->priv->mem, i);\n\tif (d) \n\t\treturn d;\n\n\tEXIF_LOG_NO_MEMORY (data->priv->log, \"ExifData\", i);\n\treturn NULL;\n}\n\nType Definitions:\n- ExifLong: typedef uint32_t\tExifLong;\n- ExifData: typedef struct _ExifData        ExifData;\n- ExifIfd: typedef enum {\n\tEXIF_IFD_0 = 0,                /*!< */\n\tEXIF_IFD_1,                    /*!< */\n\tEXIF_IFD_EXIF,                 /*!< */\n\tEXIF_IFD_GPS,                  /*!< */\n\tEXIF_IFD_INTEROPERABILITY,     /*!< */\n\tEXIF_IFD_COUNT                 /*!< Not a real value, just (max_value + 1). */\n}\n- ExifTag: typedef enum {\n\tEXIF_TAG_INTEROPERABILITY_INDEX\t\t= 0x0001,\n\tEXIF_TAG_INTEROPERABILITY_VERSION\t= 0x0002,\n\tEXIF_TAG_NEW_SUBFILE_TYPE\t\t= 0x00fe,\n\tEXIF_TAG_IMAGE_WIDTH \t\t\t= 0x0100,\n\tEXIF_TAG_IMAGE_LENGTH \t\t\t= 0x0101,\n\tEXIF_TAG_BITS_PER_SAMPLE \t\t= 0x0102,\n\tEXIF_TAG_COMPRESSION \t\t\t= 0x0103,\n\tEXIF_TAG_PHOTOMETRIC_INTERPRETATION \t= 0x0106,\n\tEXIF_TAG_FILL_ORDER \t\t\t= 0x010a,\n\tEXIF_TAG_DOCUMENT_NAME \t\t\t= 0x010d,\n\tEXIF_TAG_IMAGE_DESCRIPTION \t\t= 0x010e,\n\tEXIF_TAG_MAKE \t\t\t\t= 0x010f,\n\tEXIF_TAG_MODEL \t\t\t\t= 0x0110,\n\tEXIF_TAG_STRIP_OFFSETS \t\t\t= 0x0111,\n\tEXIF_TAG_ORIENTATION \t\t\t= 0x0112,\n\tEXIF_TAG_SAMPLES_PER_PIXEL \t\t= 0x0115,\n\tEXIF_TAG_ROWS_PER_STRIP \t\t= 0x0116,\n\tEXIF_TAG_STRIP_BYTE_COUNTS\t\t= 0x0117,\n\tEXIF_TAG_X_RESOLUTION \t\t\t= 0x011a,\n\tEXIF_TAG_Y_RESOLUTION \t\t\t= 0x011b,\n\tEXIF_TAG_PLANAR_CONFIGURATION \t\t= 0x011c,\n\tEXIF_TAG_RESOLUTION_UNIT \t\t= 0x0128,\n\tEXIF_TAG_TRANSFER_FUNCTION \t\t= 0x012d,\n\tEXIF_TAG_SOFTWARE \t\t\t= 0x0131,\n\tEXIF_TAG_DATE_TIME\t\t\t= 0x0132,\n\tEXIF_TAG_ARTIST\t\t\t\t= 0x013b,\n\tEXIF_TAG_WHITE_POINT\t\t\t= 0x013e,\n\tEXIF_TAG_PRIMARY_CHROMATICITIES\t\t= 0x013f,\n\tEXIF_TAG_SUB_IFDS\t\t\t= 0x014a,\n\tEXIF_TAG_TRANSFER_RANGE\t\t\t= 0x0156,\n\tEXIF_TAG_JPEG_PROC\t\t\t= 0x0200,\n\tEXIF_TAG_JPEG_INTERCHANGE_FORMAT\t= 0x0201,\n\tEXIF_TAG_JPEG_INTERCHANGE_FORMAT_LENGTH\t= 0x0202,\n\tEXIF_TAG_YCBCR_COEFFICIENTS\t\t= 0x0211,\n\tEXIF_TAG_YCBCR_SUB_SAMPLING\t\t= 0x0212,\n\tEXIF_TAG_YCBCR_POSITIONING\t\t= 0x0213,\n\tEXIF_TAG_REFERENCE_BLACK_WHITE\t\t= 0x0214,\n\tEXIF_TAG_XML_PACKET\t\t\t= 0x02bc,\n\tEXIF_TAG_RELATED_IMAGE_FILE_FORMAT\t= 0x1000,\n\tEXIF_TAG_RELATED_IMAGE_WIDTH\t\t= 0x1001,\n\tEXIF_TAG_RELATED_IMAGE_LENGTH\t\t= 0x1002,\n\tEXIF_TAG_CFA_REPEAT_PATTERN_DIM\t\t= 0x828d,\n\tEXIF_TAG_CFA_PATTERN\t\t\t= 0x828e,\n\tEXIF_TAG_BATTERY_LEVEL\t\t\t= 0x828f,\n\tEXIF_TAG_COPYRIGHT\t\t\t= 0x8298,\n\tEXIF_TAG_EXPOSURE_TIME\t\t\t= 0x829a,\n\tEXIF_TAG_FNUMBER\t\t\t= 0x829d,\n\tEXIF_TAG_IPTC_NAA\t\t\t= 0x83bb,\n\tEXIF_TAG_IMAGE_RESOURCES\t\t= 0x8649,\n\tEXIF_TAG_EXIF_IFD_POINTER\t\t= 0x8769,\n\tEXIF_TAG_INTER_COLOR_PROFILE\t\t= 0x8773,\n\tEXIF_TAG_EXPOSURE_PROGRAM\t\t= 0x8822,\n\tEXIF_TAG_SPECTRAL_SENSITIVITY\t\t= 0x8824,\n\tEXIF_TAG_GPS_INFO_IFD_POINTER\t\t= 0x8825,\n\tEXIF_TAG_ISO_SPEED_RATINGS\t\t= 0x8827,\n\tEXIF_TAG_OECF\t\t\t\t= 0x8828,\n\tEXIF_TAG_TIME_ZONE_OFFSET\t\t= 0x882a,\n\tEXIF_TAG_EXIF_VERSION\t\t\t= 0x9000,\n\tEXIF_TAG_DATE_TIME_ORIGINAL\t\t= 0x9003,\n\tEXIF_TAG_DATE_TIME_DIGITIZED\t\t= 0x9004,\n\tEXIF_TAG_COMPONENTS_CONFIGURATION\t= 0x9101,\n\tEXIF_TAG_COMPRESSED_BITS_PER_PIXEL\t= 0x9102,\n\tEXIF_TAG_SHUTTER_SPEED_VALUE\t\t= 0x9201,\n\tEXIF_TAG_APERTURE_VALUE\t\t\t= 0x9202,\n\tEXIF_TAG_BRIGHTNESS_VALUE\t\t= 0x9203,\n\tEXIF_TAG_EXPOSURE_BIAS_VALUE\t\t= 0x9204,\n\tEXIF_TAG_MAX_APERTURE_VALUE\t\t= 0x9205,\n\tEXIF_TAG_SUBJECT_DISTANCE\t\t= 0x9206,\n\tEXIF_TAG_METERING_MODE\t\t\t= 0x9207,\n\tEXIF_TAG_LIGHT_SOURCE\t\t\t= 0x9208,\n\tEXIF_TAG_FLASH\t\t\t\t= 0x9209,\n\tEXIF_TAG_FOCAL_LENGTH\t\t\t= 0x920a,\n\tEXIF_TAG_SUBJECT_AREA\t\t\t= 0x9214,\n\tEXIF_TAG_TIFF_EP_STANDARD_ID\t\t= 0x9216,\n\tEXIF_TAG_MAKER_NOTE\t\t\t= 0x927c,\n\tEXIF_TAG_USER_COMMENT\t\t\t= 0x9286,\n\tEXIF_TAG_SUB_SEC_TIME\t\t\t= 0x9290,\n\tEXIF_TAG_SUB_SEC_TIME_ORIGINAL\t\t= 0x9291,\n\tEXIF_TAG_SUB_SEC_TIME_DIGITIZED\t\t= 0x9292,\n\tEXIF_TAG_XP_TITLE\t\t\t= 0x9c9b,\n\tEXIF_TAG_XP_COMMENT\t\t\t= 0x9c9c,\n\tEXIF_TAG_XP_AUTHOR\t\t\t= 0x9c9d,\n\tEXIF_TAG_XP_KEYWORDS\t\t\t= 0x9c9e,\n\tEXIF_TAG_XP_SUBJECT\t\t\t= 0x9c9f,\n\tEXIF_TAG_FLASH_PIX_VERSION\t\t= 0xa000,\n\tEXIF_TAG_COLOR_SPACE\t\t\t= 0xa001,\n\tEXIF_TAG_PIXEL_X_DIMENSION\t\t= 0xa002,\n\tEXIF_TAG_PIXEL_Y_DIMENSION\t\t= 0xa003,\n\tEXIF_TAG_RELATED_SOUND_FILE\t\t= 0xa004,\n\tEXIF_TAG_INTEROPERABILITY_IFD_POINTER\t= 0xa005,\n\tEXIF_TAG_FLASH_ENERGY\t\t\t= 0xa20b,\n\tEXIF_TAG_SPATIAL_FREQUENCY_RESPONSE\t= 0xa20c,\n\tEXIF_TAG_FOCAL_PLANE_X_RESOLUTION\t= 0xa20e,\n\tEXIF_TAG_FOCAL_PLANE_Y_RESOLUTION\t= 0xa20f,\n\tEXIF_TAG_FOCAL_PLANE_RESOLUTION_UNIT\t= 0xa210,\n\tEXIF_TAG_SUBJECT_LOCATION\t\t= 0xa214,\n\tEXIF_TAG_EXPOSURE_INDEX\t\t\t= 0xa215,\n\tEXIF_TAG_SENSING_METHOD\t\t\t= 0xa217,\n\tEXIF_TAG_FILE_SOURCE\t\t\t= 0xa300,\n\tEXIF_TAG_SCENE_TYPE\t\t\t= 0xa301,\n\tEXIF_TAG_NEW_CFA_PATTERN\t\t= 0xa302,\n\tEXIF_TAG_CUSTOM_RENDERED\t\t= 0xa401,\n\tEXIF_TAG_EXPOSURE_MODE\t\t\t= 0xa402,\n\tEXIF_TAG_WHITE_BALANCE\t\t\t= 0xa403,\n\tEXIF_TAG_DIGITAL_ZOOM_RATIO\t\t= 0xa404,\n\tEXIF_TAG_FOCAL_LENGTH_IN_35MM_FILM\t= 0xa405,\n\tEXIF_TAG_SCENE_CAPTURE_TYPE\t\t= 0xa406,\n\tEXIF_TAG_GAIN_CONTROL\t\t\t= 0xa407,\n\tEXIF_TAG_CONTRAST\t\t\t= 0xa408,\n\tEXIF_TAG_SATURATION\t\t\t= 0xa409,\n\tEXIF_TAG_SHARPNESS\t\t\t= 0xa40a,\n\tEXIF_TAG_DEVICE_SETTING_DESCRIPTION\t= 0xa40b,\n\tEXIF_TAG_SUBJECT_DISTANCE_RANGE\t\t= 0xa40c,\n\tEXIF_TAG_IMAGE_UNIQUE_ID\t\t= 0xa420,\n\tEXIF_TAG_CAMERA_OWNER_NAME \t\t= 0xa430,\n\tEXIF_TAG_BODY_SERIAL_NUMBER \t\t= 0xa431,\n\tEXIF_TAG_LENS_SPECIFICATION \t\t= 0xa432,\n\tEXIF_TAG_LENS_MAKE\t \t\t= 0xa433,\n\tEXIF_TAG_LENS_MODEL\t \t\t= 0xa434,\n\tEXIF_TAG_LENS_SERIAL_NUMBER \t\t= 0xa435,\n\tEXIF_TAG_COMPOSITE_IMAGE \t\t= 0xa460,\n\tEXIF_TAG_SOURCE_IMAGE_NUMBER_OF_COMPOSITE_IMAGE \t\t= 0xa461,\n\tEXIF_TAG_SOURCE_EXPOSURE_TIMES_OF_COMPOSITE_IMAGE \t\t= 0xa462,\n\tEXIF_TAG_GAMMA\t\t\t\t= 0xa500,\n\tEXIF_TAG_PRINT_IMAGE_MATCHING\t\t= 0xc4a5,\n\tEXIF_TAG_PADDING\t\t\t= 0xea1c\n}\n- ExifShort: typedef uint16_t\tExifShort;\n\nImports:\n- #include <libexif/exif-data.h>\n- #include <libexif/canon/exif-mnote-data-canon.h>\n- #include <string.h>\n- #include <libexif/exif-system.h>\n- #include <stdio.h>\n- #include <math.h>\n- #include <libexif/exif-loader.h>\n- #include <libexif/fuji/exif-mnote-data-fuji.h>\n- #include <libexif/olympus/exif-mnote-data-olympus.h>\n- #include <libexif/exif-utils.h>\n- #include <libexif/exif-mnote-data.h>\n- #include <libexif/pentax/exif-mnote-data-pentax.h>\n- #include <libexif/exif-log.h>\n- #include <config.h>\n- #include <stdlib.h>\n- #include <libexif/exif-mnote-data-priv.h>\n- #include <libexif/i18n.h>\n- #include <libexif/exif-ifd.h>",
    "commit_msg": "fixed another unsigned integer overflow\n\nfirst fixed by google in android fork,\nhttps://android.googlesource.com/platform/external/libexif/+/1e187b62682ffab5003c702657d6d725b4278f16%5E%21/#F0\n\n(use a more generic overflow check method, also check second overflow instance.)\n\nhttps://security-tracker.debian.org/tracker/CVE-2020-0198",
    "cve_desc": "In exif_data_load_data_thumbnail of exif-data.c, there is a possible denial of service due to an integer overflow. This could lead to remote denial of service with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-10Android ID: A-145075076",
    "year": 2020,
    "filename": "exif-data.c",
    "commit_url": "\"https://github.com/libexif/libexif/commit/ce03ad7ef4e8aeefce79192bf5b6f69fae396f0c\""
  },
  {
    "repository": "libexif/libexif",
    "cve_id": "CVE-2020-0452",
    "cwe_list": [
      "CWE-787"
    ],
    "commit_hash": "9266d14b5ca4e29b970fa03272318e5f99386e06",
    "short_hash": "9266d14b",
    "vulnerableMethods_before": [
      {
        "filename": "libexif/exif-entry.c",
        "method_name": "exif_entry_get_value",
        "raw_code": "const char * /* <=== exif_entry_get_value */ \nexif_entry_get_value (ExifEntry *e, char *val, unsigned int maxlen)\n{\n\tunsigned int i, j, k;\n\tExifShort v_short, v_short2, v_short3, v_short4;\n\tExifByte v_byte;\n\tExifRational v_rat;\n\tExifSRational v_srat;\n\tchar b[64];\n\tconst char *c;\n\tExifByteOrder o;\n\tdouble d;\n\tExifEntry *entry;\n\tstatic const struct {\n\t\tchar label[5];\n\t\tchar major, minor;\n\t} versions[] = {\n\t\t{\"0110\", 1,  1},\n\t\t{\"0120\", 1,  2},\n\t\t{\"0200\", 2,  0},\n\t\t{\"0210\", 2,  1},\n\t\t{\"0220\", 2,  2},\n\t\t{\"0221\", 2, 21},\n\t\t{\"0230\", 2,  3},\n\t\t{\"\"    , 0,  0}\n\t};\n\n\t(void) bindtextdomain (GETTEXT_PACKAGE, LOCALEDIR);\n\n\tif (!e || !e->parent || !e->parent->parent || !maxlen || !val)\n\t\treturn val;\n\n\t/* make sure the returned string is zero terminated */\n\t/* FIXME: this is inefficient in the case of long buffers and should\n\t * instead be taken care of on each write instead. */\n\tmemset (val, 0, maxlen);\n\n\t/* We need the byte order */\n\to = exif_data_get_byte_order (e->parent->parent);\n\n\t/* Sanity check */\n\tif (e->size != e->components * exif_format_get_size (e->format)) {\n\t\tsnprintf (val, maxlen, _(\"Invalid size of entry (%i, \"\n\t\t\t\"expected %li x %i).\"), e->size, e->components,\n\t\t\t\texif_format_get_size (e->format));\n\t\treturn val;\n\t}\n\n\tswitch (e->tag) {\n\tcase EXIF_TAG_USER_COMMENT:\n\n\t\t/*\n\t\t * The specification says UNDEFINED, but some\n\t\t * manufacturers don't care and use ASCII. If this is the\n\t\t * case here, only refuse to read it if there is no chance\n\t\t * of finding readable data.\n\t\t */\n\t\tif ((e->format != EXIF_FORMAT_ASCII) || \n\t\t    (e->size <= 8) ||\n\t\t    ( memcmp (e->data, \"ASCII\\0\\0\\0\"  , 8) &&\n\t\t      memcmp (e->data, \"UNICODE\\0\"    , 8) &&\n\t\t      memcmp (e->data, \"JIS\\0\\0\\0\\0\\0\", 8) &&\n\t\t      memcmp (e->data, \"\\0\\0\\0\\0\\0\\0\\0\\0\", 8)))\n\t\t\tCF (e, EXIF_FORMAT_UNDEFINED, val, maxlen);\n\n\t\t/*\n\t\t * Note that, according to the specification (V2.1, p 40),\n\t\t * the user comment field does not have to be \n\t\t * NULL terminated.\n\t\t */\n\t\tif ((e->size >= 8) && !memcmp (e->data, \"ASCII\\0\\0\\0\", 8)) {\n\t\t\tstrncpy (val, (char *) e->data + 8, MIN (e->size - 8, maxlen-1));\n\t\t\tbreak;\n\t\t}\n\t\tif ((e->size >= 8) && !memcmp (e->data, \"UNICODE\\0\", 8)) {\n\t\t\tstrncpy (val, _(\"Unsupported UNICODE string\"), maxlen-1);\n\t\t/* FIXME: use iconv to convert into the locale encoding.\n\t\t * EXIF 2.2 implies (but does not say) that this encoding is\n\t\t * UCS-2.\n\t\t */\n\t\t\tbreak;\n\t\t}\n\t\tif ((e->size >= 8) && !memcmp (e->data, \"JIS\\0\\0\\0\\0\\0\", 8)) {\n\t\t\tstrncpy (val, _(\"Unsupported JIS string\"), maxlen-1);\n\t\t/* FIXME: use iconv to convert into the locale encoding */\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Check if there is really some information in the tag. */\n\t\tfor (i = 0; (i < e->size) &&\n\t\t\t    (!e->data[i] || (e->data[i] == ' ')); i++);\n\t\tif (i == e->size) break;\n\n\t\t/*\n\t\t * If we reach this point, the tag does not\n \t\t * comply with the standard but seems to contain data.\n\t\t * Print as much as possible.\n\t\t * Note: make sure we do not overwrite the final \\0 at maxlen-1\n\t\t */\n\t\texif_entry_log (e, EXIF_LOG_CODE_DEBUG,\n\t\t\t_(\"Tag UserComment contains data but is \"\n\t\t\t  \"against specification.\"));\n \t\tfor (j = 0; (i < e->size) && (j < maxlen-1); i++, j++) {\n\t\t\texif_entry_log (e, EXIF_LOG_CODE_DEBUG,\n\t\t\t\t_(\"Byte at position %i: 0x%02x\"), i, e->data[i]);\n \t\t\tval[j] = isprint (e->data[i]) ? e->data[i] : '.';\n\t\t}\n\t\tbreak;\n\n\tcase EXIF_TAG_EXIF_VERSION:\n\t\tCF (e, EXIF_FORMAT_UNDEFINED, val, maxlen);\n\t\tCC (e, 4, val, maxlen);\n\t\tstrncpy (val, _(\"Unknown Exif Version\"), maxlen-1);\n\t\tfor (i = 0; *versions[i].label; i++) {\n\t\t\tif (!memcmp (e->data, versions[i].label, 4)) {\n    \t\t\t\tsnprintf (val, maxlen,\n\t\t\t\t\t_(\"Exif Version %d.%d\"),\n\t\t\t\t\tversions[i].major,\n\t\t\t\t\tversions[i].minor);\n    \t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase EXIF_TAG_FLASH_PIX_VERSION:\n\t\tCF (e, EXIF_FORMAT_UNDEFINED, val, maxlen);\n\t\tCC (e, 4, val, maxlen);\n\t\tif (!memcmp (e->data, \"0100\", 4))\n\t\t\tstrncpy (val, _(\"FlashPix Version 1.0\"), maxlen-1);\n\t\telse if (!memcmp (e->data, \"0101\", 4))\n\t\t\tstrncpy (val, _(\"FlashPix Version 1.01\"), maxlen-1);\n\t\telse\n\t\t\tstrncpy (val, _(\"Unknown FlashPix Version\"), maxlen-1);\n\t\tbreak;\n\tcase EXIF_TAG_COPYRIGHT:\n\t\tCF (e, EXIF_FORMAT_ASCII, val, maxlen);\n\n\t\t/*\n\t\t * First part: Photographer.\n\t\t * Some cameras store a string like \"   \" here. Ignore it.\n\t\t * Remember that a corrupted tag might not be NUL-terminated\n\t\t */\n\t\tif (e->size && e->data && match_repeated_char(e->data, ' ', e->size))\n\t\t\tstrncpy (val, (char *) e->data, MIN (maxlen-1, e->size));\n\t\telse\n\t\t\tstrncpy (val, _(\"[None]\"), maxlen-1);\n\t\tstrncat (val, \" \", maxlen-1 - strlen (val));\n\t\tstrncat (val, _(\"(Photographer)\"), maxlen-1 - strlen (val));\n\n\t\t/* Second part: Editor. */\n\t\tstrncat (val, \" - \", maxlen-1 - strlen (val));\n\t\tk = 0;\n\t\tif (e->size && e->data) {\n\t\t\tconst unsigned char *tagdata = memchr(e->data, 0, e->size);\n\t\t\tif (tagdata++) {\n\t\t\t\tunsigned int editor_ofs = tagdata - e->data;\n\t\t\t\tunsigned int remaining = e->size - editor_ofs;\n\t\t\t\tif (match_repeated_char(tagdata, ' ', remaining)) {\n\t\t\t\t\tstrncat (val, (const char*)tagdata, MIN (maxlen-1 - strlen (val), remaining));\n\t\t\t\t\t++k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!k)\n\t\t\tstrncat (val, _(\"[None]\"), maxlen-1 - strlen (val));\n\t\tstrncat (val, \" \", maxlen-1 - strlen (val));\n\t\tstrncat (val, _(\"(Editor)\"), maxlen-1 - strlen (val));\n\n\t\tbreak;\n\tcase EXIF_TAG_FNUMBER:\n\t\tCF (e, EXIF_FORMAT_RATIONAL, val, maxlen);\n\t\tCC (e, 1, val, maxlen);\n\t\tv_rat = exif_get_rational (e->data, o);\n\t\tif (!v_rat.denominator) {\n\t\t\texif_entry_format_value(e, val, maxlen);\n\t\t\tbreak;\n\t\t}\n\t\td = (double) v_rat.numerator / (double) v_rat.denominator;\n\t\tsnprintf (val, maxlen, \"f/%.01f\", d);\n\t\tbreak;\n\tcase EXIF_TAG_APERTURE_VALUE:\n\tcase EXIF_TAG_MAX_APERTURE_VALUE:\n\t\tCF (e, EXIF_FORMAT_RATIONAL, val, maxlen);\n\t\tCC (e, 1, val, maxlen);\n\t\tv_rat = exif_get_rational (e->data, o);\n\t\tif (!v_rat.denominator || (0x80000000 == v_rat.numerator)) {\n\t\t\texif_entry_format_value(e, val, maxlen);\n\t\t\tbreak;\n\t\t}\n\t\td = (double) v_rat.numerator / (double) v_rat.denominator;\n\t\tsnprintf (val, maxlen, _(\"%.02f EV\"), d);\n\t\tsnprintf (b, sizeof (b), _(\" (f/%.01f)\"), pow (2, d / 2.));\n\t\tstrncat (val, b, maxlen-1 - strlen (val));\n\t\tbreak;\n\tcase EXIF_TAG_FOCAL_LENGTH:\n\t\tCF (e, EXIF_FORMAT_RATIONAL, val, maxlen);\n\t\tCC (e, 1, val, maxlen);\n\t\tv_rat = exif_get_rational (e->data, o);\n\t\tif (!v_rat.denominator) {\n\t\t\texif_entry_format_value(e, val, maxlen);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * For calculation of the 35mm equivalent,\n\t\t * Minolta cameras need a multiplier that depends on the\n\t\t * camera model.\n\t\t */\n\t\td = 0.;\n\t\tentry = exif_content_get_entry (\n\t\t\te->parent->parent->ifd[EXIF_IFD_0], EXIF_TAG_MAKE);\n\t\tif (entry && entry->data && entry->size >= 7 &&\n\t\t    !strncmp ((char *)entry->data, \"Minolta\", 7)) {\n\t\t\tentry = exif_content_get_entry (\n\t\t\t\t\te->parent->parent->ifd[EXIF_IFD_0],\n\t\t\t\t\tEXIF_TAG_MODEL);\n\t\t\tif (entry && entry->data && entry->size >= 8) {\n\t\t\t\tif (!strncmp ((char *)entry->data, \"DiMAGE 7\", 8))\n\t\t\t\t\td = 3.9;\n\t\t\t\telse if (!strncmp ((char *)entry->data, \"DiMAGE 5\", 8))\n\t\t\t\t\td = 4.9;\n\t\t\t}\n\t\t}\n\t\tif (d)\n\t\t\tsnprintf (b, sizeof (b), _(\" (35 equivalent: %.0f mm)\"),\n\t\t\t\t  (d * (double) v_rat.numerator /\n\t\t\t\t       (double) v_rat.denominator));\n\t\telse\n\t\t\tb[0] = 0;\n\n\t\td = (double) v_rat.numerator / (double) v_rat.denominator;\n\t\tsnprintf (val, maxlen, \"%.1f mm\", d);\n\t\tstrncat (val, b, maxlen-1 - strlen (val));\n\t\tbreak;\n\tcase EXIF_TAG_SUBJECT_DISTANCE:\n\t\tCF (e, EXIF_FORMAT_RATIONAL, val, maxlen);\n\t\tCC (e, 1, val, maxlen);\n\t\tv_rat = exif_get_rational (e->data, o);\n\t\tif (!v_rat.denominator) {\n\t\t\texif_entry_format_value(e, val, maxlen);\n\t\t\tbreak;\n\t\t}\n\t\td = (double) v_rat.numerator / (double) v_rat.denominator;\n\t\tsnprintf (val, maxlen, \"%.1f m\", d);\n\t\tbreak;\n\tcase EXIF_TAG_EXPOSURE_TIME:\n\t\tCF (e, EXIF_FORMAT_RATIONAL, val, maxlen);\n\t\tCC (e, 1, val, maxlen);\n\t\tv_rat = exif_get_rational (e->data, o);\n\t\tif (!v_rat.denominator) {\n\t\t\texif_entry_format_value(e, val, maxlen);\n\t\t\tbreak;\n\t\t}\n\t\td = (double) v_rat.numerator / (double) v_rat.denominator;\n\t\tif (d < 1 && d)\n\t\t\tsnprintf (val, maxlen, _(\"1/%.0f\"), 1. / d);\n\t\telse\n\t\t\tsnprintf (val, maxlen, \"%.0f\", d);\n\t\tstrncat (val, _(\" sec.\"), maxlen-1 - strlen (val));\n\t\tbreak;\n\tcase EXIF_TAG_SHUTTER_SPEED_VALUE:\n\t\tCF (e, EXIF_FORMAT_SRATIONAL, val, maxlen);\n\t\tCC (e, 1, val, maxlen);\n\t\tv_srat = exif_get_srational (e->data, o);\n\t\tif (!v_srat.denominator) {\n\t\t\texif_entry_format_value(e, val, maxlen);\n\t\t\tbreak;\n\t\t}\n\t\td = (double) v_srat.numerator / (double) v_srat.denominator;\n\t\tsnprintf (val, maxlen, _(\"%.02f EV\"), d);\n\t\tif (pow (2, d))\n\t\t\td = 1. / pow (2, d);\n\t\tif (d < 1 && d)\n\t\t  snprintf (b, sizeof (b), _(\" (1/%.0f sec.)\"), 1. / d);\n\t\telse\n\t\t  snprintf (b, sizeof (b), _(\" (%.0f sec.)\"), d);\n\t\tstrncat (val, b, maxlen-1 - strlen (val));\n\t\tbreak;\n\tcase EXIF_TAG_BRIGHTNESS_VALUE:\n\t\tCF (e, EXIF_FORMAT_SRATIONAL, val, maxlen);\n\t\tCC (e, 1, val, maxlen);\n\t\tv_srat = exif_get_srational (e->data, o);\n\t\tif (!v_srat.denominator) {\n\t\t\texif_entry_format_value(e, val, maxlen);\n\t\t\tbreak;\n\t\t}\n\t\td = (double) v_srat.numerator / (double) v_srat.denominator;\n\t\tsnprintf (val, maxlen, _(\"%.02f EV\"), d);\n\t\tsnprintf (b, sizeof (b), _(\" (%.02f cd/m^2)\"),\n\t\t\t1. / (M_PI * 0.3048 * 0.3048) * pow (2, d));\n\t\tstrncat (val, b, maxlen-1 - strlen (val));\n\t\tbreak;\n\tcase EXIF_TAG_FILE_SOURCE:\n\t\tCF (e, EXIF_FORMAT_UNDEFINED, val, maxlen);\n\t\tCC (e, 1, val, maxlen);\n\t\tv_byte = e->data[0];\n\t\tif (v_byte == 3)\n\t\t\tstrncpy (val, _(\"DSC\"), maxlen-1);\n\t\telse\n\t\t\tsnprintf (val, maxlen, _(\"Internal error (unknown \"\n\t\t\t\t  \"value %i)\"), v_byte);\n\t\tbreak;\n\tcase EXIF_TAG_COMPONENTS_CONFIGURATION:\n\t\tCF (e, EXIF_FORMAT_UNDEFINED, val, maxlen);\n\t\tCC (e, 4, val, maxlen);\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tswitch (e->data[i]) {\n\t\t\tcase 0: c = _(\"-\"); break;\n\t\t\tcase 1: c = _(\"Y\"); break;\n\t\t\tcase 2: c = _(\"Cb\"); break;\n\t\t\tcase 3: c = _(\"Cr\"); break;\n\t\t\tcase 4: c = _(\"R\"); break;\n\t\t\tcase 5: c = _(\"G\"); break;\n\t\t\tcase 6: c = _(\"B\"); break;\n\t\t\tdefault: c = _(\"Reserved\"); break;\n\t\t\t}\n\t\t\tstrncat (val, c, maxlen-1 - strlen (val));\n\t\t\tif (i < 3)\n\t\t\t\tstrncat (val, \" \", maxlen-1 - strlen (val));\n\t\t}\n\t\tbreak;\n\tcase EXIF_TAG_EXPOSURE_BIAS_VALUE:\n\t\tCF (e, EXIF_FORMAT_SRATIONAL, val, maxlen);\n\t\tCC (e, 1, val, maxlen);\n\t\tv_srat = exif_get_srational (e->data, o);\n\t\tif (!v_srat.denominator) {\n\t\t\texif_entry_format_value(e, val, maxlen);\n\t\t\tbreak;\n\t\t}\n\t\td = (double) v_srat.numerator / (double) v_srat.denominator;\n\t\tsnprintf (val, maxlen, _(\"%.02f EV\"), d);\n\t\tbreak;\n\tcase EXIF_TAG_SCENE_TYPE:\n\t\tCF (e, EXIF_FORMAT_UNDEFINED, val, maxlen);\n\t\tCC (e, 1, val, maxlen);\n\t\tv_byte = e->data[0];\n\t\tif (v_byte == 1)\n\t\t\tstrncpy (val, _(\"Directly photographed\"), maxlen-1);\n\t\telse\n\t\t\tsnprintf (val, maxlen, _(\"Internal error (unknown \"\n\t\t\t\t  \"value %i)\"), v_byte);\n\t\tbreak;\n\tcase EXIF_TAG_YCBCR_SUB_SAMPLING:\n\t\tCF (e, EXIF_FORMAT_SHORT, val, maxlen);\n\t\tCC (e, 2, val, maxlen);\n\t\tv_short  = exif_get_short (e->data, o);\n\t\tv_short2 = exif_get_short (\n\t\t\te->data + exif_format_get_size (e->format),\n\t\t\to);\n\t\tif ((v_short == 2) && (v_short2 == 1))\n\t\t\tstrncpy (val, _(\"YCbCr4:2:2\"), maxlen-1);\n\t\telse if ((v_short == 2) && (v_short2 == 2))\n\t\t\tstrncpy (val, _(\"YCbCr4:2:0\"), maxlen-1);\n\t\telse\n\t\t\tsnprintf (val, maxlen, \"%u, %u\", v_short, v_short2);\n\t\tbreak;\n\tcase EXIF_TAG_SUBJECT_AREA:\n\t\tCF (e, EXIF_FORMAT_SHORT, val, maxlen);\n\t\tswitch (e->components) {\n\t\tcase 2:\n\t\t\tv_short  = exif_get_short (e->data, o);\n\t\t\tv_short2 = exif_get_short (e->data + 2, o);\n\t\t\tsnprintf (val, maxlen, \"(x,y) = (%i,%i)\",\n\t\t\t\t  v_short, v_short2);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tv_short  = exif_get_short (e->data, o);\n\t\t\tv_short2 = exif_get_short (e->data + 2, o);\n\t\t\tv_short3 = exif_get_short (e->data + 4, o);\n\t\t\tsnprintf (val, maxlen, _(\"Within distance %i of \"\n\t\t\t\t\"(x,y) = (%i,%i)\"), v_short3, v_short,\n\t\t\t\tv_short2);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tv_short  = exif_get_short (e->data, o);\n\t\t\tv_short2 = exif_get_short (e->data + 2, o);\n\t\t\tv_short3 = exif_get_short (e->data + 4, o);\n\t\t\tv_short4 = exif_get_short (e->data + 6, o);\n\t\t\tsnprintf (val, maxlen, _(\"Within rectangle \"\n\t\t\t\t\"(width %i, height %i) around \"\n\t\t\t\t\"(x,y) = (%i,%i)\"), v_short3, v_short4,\n\t\t\t\tv_short, v_short2);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnprintf (val, maxlen, _(\"Unexpected number \"\n\t\t\t\t\"of components (%li, expected 2, 3, or 4).\"),\n\t\t\t\te->components);\t\n\t\t}\n\t\tbreak;\n\tcase EXIF_TAG_GPS_VERSION_ID:\n\t\t/* This is only valid in the GPS IFD */\n\t\tCF (e, EXIF_FORMAT_BYTE, val, maxlen);\n\t\tCC (e, 4, val, maxlen);\n\t\tv_byte = e->data[0];\n\t\tsnprintf (val, maxlen, \"%u\", v_byte);\n\t\tfor (i = 1; i < e->components; i++) {\n\t\t\tv_byte = e->data[i];\n\t\t\tsnprintf (b, sizeof (b), \".%u\", v_byte);\n\t\t\tstrncat (val, b, maxlen-1 - strlen (val));\n\t\t}\n\t\tbreak;\n\tcase EXIF_TAG_INTEROPERABILITY_VERSION:\n\t/* a.k.a. case EXIF_TAG_GPS_LATITUDE: */\n\t\t/* This tag occurs in EXIF_IFD_INTEROPERABILITY */\n\t\tif (e->format == EXIF_FORMAT_UNDEFINED) {\n\t\t\tstrncpy (val, (char *) e->data, MIN (maxlen-1, e->size));\n\t\t\tbreak;\n\t\t}\n\t\t/* EXIF_TAG_GPS_LATITUDE is the same numerically as\n\t\t * EXIF_TAG_INTEROPERABILITY_VERSION but in EXIF_IFD_GPS\n\t\t */\n\t\texif_entry_format_value(e, val, maxlen);\n\t\tbreak;\n\tcase EXIF_TAG_GPS_ALTITUDE_REF:\n\t\t/* This is only valid in the GPS IFD */\n\t\tCF (e, EXIF_FORMAT_BYTE, val, maxlen);\n\t\tCC (e, 1, val, maxlen);\n\t\tv_byte = e->data[0];\n\t\tif (v_byte == 0)\n\t\t\tstrncpy (val, _(\"Sea level\"), maxlen-1);\n\t\telse if (v_byte == 1)\n\t\t\tstrncpy (val, _(\"Sea level reference\"), maxlen-1);\n\t\telse\n\t\t\tsnprintf (val, maxlen, _(\"Internal error (unknown \"\n\t\t\t\t  \"value %i)\"), v_byte);\n\t\tbreak;\n\tcase EXIF_TAG_GPS_TIME_STAMP:\n\t\t/* This is only valid in the GPS IFD */\n\t\tCF (e, EXIF_FORMAT_RATIONAL, val, maxlen);\n\t\tCC (e, 3, val, maxlen);\n\n\t\tv_rat  = exif_get_rational (e->data, o);\n\t\tif (!v_rat.denominator) {\n\t\t\texif_entry_format_value(e, val, maxlen);\n\t\t\tbreak;\n\t\t}\n\t\ti = v_rat.numerator / v_rat.denominator;\n\n\t\tv_rat = exif_get_rational (e->data +\n\t\t\t\t\t     exif_format_get_size (e->format),\n\t\t\t\t\t   o);\n\t\tif (!v_rat.denominator) {\n\t\t\texif_entry_format_value(e, val, maxlen);\n\t\t\tbreak;\n\t\t}\n\t\tj = v_rat.numerator / v_rat.denominator;\n\n\t\tv_rat = exif_get_rational (e->data +\n\t\t\t\t\t     2*exif_format_get_size (e->format),\n\t\t\t\t\t     o);\n\t\tif (!v_rat.denominator) {\n\t\t\texif_entry_format_value(e, val, maxlen);\n\t\t\tbreak;\n\t\t}\n\t\td = (double) v_rat.numerator / (double) v_rat.denominator;\n\t\tsnprintf (val, maxlen, \"%02u:%02u:%05.2f\", i, j, d);\n\t\tbreak;\n\n\tcase EXIF_TAG_METERING_MODE:\n\tcase EXIF_TAG_COMPRESSION:\n\tcase EXIF_TAG_LIGHT_SOURCE:\n\tcase EXIF_TAG_FOCAL_PLANE_RESOLUTION_UNIT:\n\tcase EXIF_TAG_RESOLUTION_UNIT:\n\tcase EXIF_TAG_EXPOSURE_PROGRAM:\n\tcase EXIF_TAG_FLASH:\n\tcase EXIF_TAG_SUBJECT_DISTANCE_RANGE:\n\tcase EXIF_TAG_COLOR_SPACE:\n\t\tCF (e,EXIF_FORMAT_SHORT, val, maxlen);\n\t\tCC (e, 1, val, maxlen);\n\t\tv_short = exif_get_short (e->data, o);\n\n\t\t/* Search the tag */\n\t\tfor (i = 0; list2[i].tag && (list2[i].tag != e->tag); i++);\n\t\tif (!list2[i].tag) {\n\t\t\tsnprintf (val, maxlen, _(\"Internal error (unknown \"\n\t\t\t\t  \"value %i)\"), v_short);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Find the value */\n\t\tfor (j = 0; list2[i].elem[j].values[0] &&\n\t\t\t    (list2[i].elem[j].index < v_short); j++);\n\t\tif (list2[i].elem[j].index != v_short) {\n\t\t\tsnprintf (val, maxlen, _(\"Internal error (unknown \"\n\t\t\t\t  \"value %i)\"), v_short);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Find a short enough value */\n\t\tmemset (val, 0, maxlen);\n\t\tfor (k = 0; list2[i].elem[j].values[k]; k++) {\n\t\t\tsize_t l = strlen (_(list2[i].elem[j].values[k]));\n\t\t\tif ((maxlen > l) && (strlen (val) < l))\n\t\t\t\tstrncpy (val, _(list2[i].elem[j].values[k]), maxlen-1);\n\t\t}\n\t\tif (!val[0]) snprintf (val, maxlen, \"%i\", v_short);\n\n\t\tbreak;\n\n\tcase EXIF_TAG_PLANAR_CONFIGURATION:\n\tcase EXIF_TAG_SENSING_METHOD:\n\tcase EXIF_TAG_ORIENTATION:\n\tcase EXIF_TAG_YCBCR_POSITIONING:\n\tcase EXIF_TAG_PHOTOMETRIC_INTERPRETATION:\n\tcase EXIF_TAG_CUSTOM_RENDERED:\n\tcase EXIF_TAG_EXPOSURE_MODE:\n\tcase EXIF_TAG_WHITE_BALANCE:\n\tcase EXIF_TAG_SCENE_CAPTURE_TYPE:\n\tcase EXIF_TAG_GAIN_CONTROL:\n\tcase EXIF_TAG_SATURATION:\n\tcase EXIF_TAG_CONTRAST:\n\tcase EXIF_TAG_SHARPNESS:\n\t\tCF (e, EXIF_FORMAT_SHORT, val, maxlen);\n\t\tCC (e, 1, val, maxlen);\n\t\tv_short = exif_get_short (e->data, o);\n\n\t\t/* Search the tag */\n\t\tfor (i = 0; list[i].tag && (list[i].tag != e->tag); i++);\n\t\tif (!list[i].tag) {\n\t\t\tsnprintf (val, maxlen, _(\"Internal error (unknown \"\n\t\t\t\t  \"value %i)\"), v_short);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Find the value */\n\t\tfor (j = 0; list[i].strings[j] && (j < v_short); j++);\n\t\tif (!list[i].strings[j])\n\t\t\tsnprintf (val, maxlen, \"%i\", v_short);\n\t\telse if (!*list[i].strings[j])\n\t\t\tsnprintf (val, maxlen, _(\"Unknown value %i\"), v_short);\n\t\telse\n\t\t\tstrncpy (val, _(list[i].strings[j]), maxlen-1);\n\t\tbreak;\n\n\tcase EXIF_TAG_XP_TITLE:\n\tcase EXIF_TAG_XP_COMMENT:\n\tcase EXIF_TAG_XP_AUTHOR:\n\tcase EXIF_TAG_XP_KEYWORDS:\n\tcase EXIF_TAG_XP_SUBJECT:\n\t{\n\t\tunsigned char *utf16;\n\n\t\t/* Sanity check the size to prevent overflow */\n\t\tif (e->size+sizeof(uint16_t)+1 < e->size) break;\n\n\t\t/* The tag may not be U+0000-terminated , so make a local\n\t\t   U+0000-terminated copy before converting it */\n\t\tutf16 = exif_mem_alloc (e->priv->mem, e->size+sizeof(uint16_t)+1);\n\t\tif (!utf16) break;\n\t\tmemcpy(utf16, e->data, e->size);\n\n\t\t/* NUL terminate the string. If the size is odd (which isn't possible\n\t\t * for a valid UTF16 string), then this will overwrite the high byte of\n\t\t * the final half word, plus add a full zero NUL word at the end.\n\t\t */\n\t\tutf16[e->size] = 0;\n\t\tutf16[e->size+1] = 0;\n\t\tutf16[e->size+2] = 0;\n\n\t\t/* Warning! The texts are converted from UTF16 to UTF8 */\n\t\t/* FIXME: use iconv to convert into the locale encoding */\n\t\texif_convert_utf16_to_utf8(val, utf16, maxlen);\n\t\texif_mem_free(e->priv->mem, utf16);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\t/* Use a generic value formatting */\n\t\texif_entry_format_value(e, val, maxlen);\n\t}\n\n\treturn val;\n}",
        "start_line": 833
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "libexif/exif-entry.c",
        "method_name": "exif_entry_get_value",
        "raw_code": "const char * /* <=== exif_entry_get_value */ \nexif_entry_get_value (ExifEntry *e, char *val, unsigned int maxlen)\n{\n\tunsigned int i, j, k;\n\tExifShort v_short, v_short2, v_short3, v_short4;\n\tExifByte v_byte;\n\tExifRational v_rat;\n\tExifSRational v_srat;\n\tchar b[64];\n\tconst char *c;\n\tExifByteOrder o;\n\tdouble d;\n\tExifEntry *entry;\n\tstatic const struct {\n\t\tchar label[5];\n\t\tchar major, minor;\n\t} versions[] = {\n\t\t{\"0110\", 1,  1},\n\t\t{\"0120\", 1,  2},\n\t\t{\"0200\", 2,  0},\n\t\t{\"0210\", 2,  1},\n\t\t{\"0220\", 2,  2},\n\t\t{\"0221\", 2, 21},\n\t\t{\"0230\", 2,  3},\n\t\t{\"\"    , 0,  0}\n\t};\n\n\t(void) bindtextdomain (GETTEXT_PACKAGE, LOCALEDIR);\n\n\tif (!e || !e->parent || !e->parent->parent || !maxlen || !val)\n\t\treturn val;\n\n\t/* make sure the returned string is zero terminated */\n\t/* FIXME: this is inefficient in the case of long buffers and should\n\t * instead be taken care of on each write instead. */\n\tmemset (val, 0, maxlen);\n\n\t/* We need the byte order */\n\to = exif_data_get_byte_order (e->parent->parent);\n\n\t/* Sanity check */\n\tif (e->size != e->components * exif_format_get_size (e->format)) {\n\t\tsnprintf (val, maxlen, _(\"Invalid size of entry (%i, \"\n\t\t\t\"expected %li x %i).\"), e->size, e->components,\n\t\t\t\texif_format_get_size (e->format));\n\t\treturn val;\n\t}\n\n\tswitch (e->tag) {\n\tcase EXIF_TAG_USER_COMMENT:\n\n\t\t/*\n\t\t * The specification says UNDEFINED, but some\n\t\t * manufacturers don't care and use ASCII. If this is the\n\t\t * case here, only refuse to read it if there is no chance\n\t\t * of finding readable data.\n\t\t */\n\t\tif ((e->format != EXIF_FORMAT_ASCII) || \n\t\t    (e->size <= 8) ||\n\t\t    ( memcmp (e->data, \"ASCII\\0\\0\\0\"  , 8) &&\n\t\t      memcmp (e->data, \"UNICODE\\0\"    , 8) &&\n\t\t      memcmp (e->data, \"JIS\\0\\0\\0\\0\\0\", 8) &&\n\t\t      memcmp (e->data, \"\\0\\0\\0\\0\\0\\0\\0\\0\", 8)))\n\t\t\tCF (e, EXIF_FORMAT_UNDEFINED, val, maxlen);\n\n\t\t/*\n\t\t * Note that, according to the specification (V2.1, p 40),\n\t\t * the user comment field does not have to be \n\t\t * NULL terminated.\n\t\t */\n\t\tif ((e->size >= 8) && !memcmp (e->data, \"ASCII\\0\\0\\0\", 8)) {\n\t\t\tstrncpy (val, (char *) e->data + 8, MIN (e->size - 8, maxlen-1));\n\t\t\tbreak;\n\t\t}\n\t\tif ((e->size >= 8) && !memcmp (e->data, \"UNICODE\\0\", 8)) {\n\t\t\tstrncpy (val, _(\"Unsupported UNICODE string\"), maxlen-1);\n\t\t/* FIXME: use iconv to convert into the locale encoding.\n\t\t * EXIF 2.2 implies (but does not say) that this encoding is\n\t\t * UCS-2.\n\t\t */\n\t\t\tbreak;\n\t\t}\n\t\tif ((e->size >= 8) && !memcmp (e->data, \"JIS\\0\\0\\0\\0\\0\", 8)) {\n\t\t\tstrncpy (val, _(\"Unsupported JIS string\"), maxlen-1);\n\t\t/* FIXME: use iconv to convert into the locale encoding */\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Check if there is really some information in the tag. */\n\t\tfor (i = 0; (i < e->size) &&\n\t\t\t    (!e->data[i] || (e->data[i] == ' ')); i++);\n\t\tif (i == e->size) break;\n\n\t\t/*\n\t\t * If we reach this point, the tag does not\n \t\t * comply with the standard but seems to contain data.\n\t\t * Print as much as possible.\n\t\t * Note: make sure we do not overwrite the final \\0 at maxlen-1\n\t\t */\n\t\texif_entry_log (e, EXIF_LOG_CODE_DEBUG,\n\t\t\t_(\"Tag UserComment contains data but is \"\n\t\t\t  \"against specification.\"));\n \t\tfor (j = 0; (i < e->size) && (j < maxlen-1); i++, j++) {\n\t\t\texif_entry_log (e, EXIF_LOG_CODE_DEBUG,\n\t\t\t\t_(\"Byte at position %i: 0x%02x\"), i, e->data[i]);\n \t\t\tval[j] = isprint (e->data[i]) ? e->data[i] : '.';\n\t\t}\n\t\tbreak;\n\n\tcase EXIF_TAG_EXIF_VERSION:\n\t\tCF (e, EXIF_FORMAT_UNDEFINED, val, maxlen);\n\t\tCC (e, 4, val, maxlen);\n\t\tstrncpy (val, _(\"Unknown Exif Version\"), maxlen-1);\n\t\tfor (i = 0; *versions[i].label; i++) {\n\t\t\tif (!memcmp (e->data, versions[i].label, 4)) {\n    \t\t\t\tsnprintf (val, maxlen,\n\t\t\t\t\t_(\"Exif Version %d.%d\"),\n\t\t\t\t\tversions[i].major,\n\t\t\t\t\tversions[i].minor);\n    \t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase EXIF_TAG_FLASH_PIX_VERSION:\n\t\tCF (e, EXIF_FORMAT_UNDEFINED, val, maxlen);\n\t\tCC (e, 4, val, maxlen);\n\t\tif (!memcmp (e->data, \"0100\", 4))\n\t\t\tstrncpy (val, _(\"FlashPix Version 1.0\"), maxlen-1);\n\t\telse if (!memcmp (e->data, \"0101\", 4))\n\t\t\tstrncpy (val, _(\"FlashPix Version 1.01\"), maxlen-1);\n\t\telse\n\t\t\tstrncpy (val, _(\"Unknown FlashPix Version\"), maxlen-1);\n\t\tbreak;\n\tcase EXIF_TAG_COPYRIGHT:\n\t\tCF (e, EXIF_FORMAT_ASCII, val, maxlen);\n\n\t\t/*\n\t\t * First part: Photographer.\n\t\t * Some cameras store a string like \"   \" here. Ignore it.\n\t\t * Remember that a corrupted tag might not be NUL-terminated\n\t\t */\n\t\tif (e->size && e->data && match_repeated_char(e->data, ' ', e->size))\n\t\t\tstrncpy (val, (char *) e->data, MIN (maxlen-1, e->size));\n\t\telse\n\t\t\tstrncpy (val, _(\"[None]\"), maxlen-1);\n\t\tstrncat (val, \" \", maxlen-1 - strlen (val));\n\t\tstrncat (val, _(\"(Photographer)\"), maxlen-1 - strlen (val));\n\n\t\t/* Second part: Editor. */\n\t\tstrncat (val, \" - \", maxlen-1 - strlen (val));\n\t\tk = 0;\n\t\tif (e->size && e->data) {\n\t\t\tconst unsigned char *tagdata = memchr(e->data, 0, e->size);\n\t\t\tif (tagdata++) {\n\t\t\t\tunsigned int editor_ofs = tagdata - e->data;\n\t\t\t\tunsigned int remaining = e->size - editor_ofs;\n\t\t\t\tif (match_repeated_char(tagdata, ' ', remaining)) {\n\t\t\t\t\tstrncat (val, (const char*)tagdata, MIN (maxlen-1 - strlen (val), remaining));\n\t\t\t\t\t++k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!k)\n\t\t\tstrncat (val, _(\"[None]\"), maxlen-1 - strlen (val));\n\t\tstrncat (val, \" \", maxlen-1 - strlen (val));\n\t\tstrncat (val, _(\"(Editor)\"), maxlen-1 - strlen (val));\n\n\t\tbreak;\n\tcase EXIF_TAG_FNUMBER:\n\t\tCF (e, EXIF_FORMAT_RATIONAL, val, maxlen);\n\t\tCC (e, 1, val, maxlen);\n\t\tv_rat = exif_get_rational (e->data, o);\n\t\tif (!v_rat.denominator) {\n\t\t\texif_entry_format_value(e, val, maxlen);\n\t\t\tbreak;\n\t\t}\n\t\td = (double) v_rat.numerator / (double) v_rat.denominator;\n\t\tsnprintf (val, maxlen, \"f/%.01f\", d);\n\t\tbreak;\n\tcase EXIF_TAG_APERTURE_VALUE:\n\tcase EXIF_TAG_MAX_APERTURE_VALUE:\n\t\tCF (e, EXIF_FORMAT_RATIONAL, val, maxlen);\n\t\tCC (e, 1, val, maxlen);\n\t\tv_rat = exif_get_rational (e->data, o);\n\t\tif (!v_rat.denominator || (0x80000000 == v_rat.numerator)) {\n\t\t\texif_entry_format_value(e, val, maxlen);\n\t\t\tbreak;\n\t\t}\n\t\td = (double) v_rat.numerator / (double) v_rat.denominator;\n\t\tsnprintf (val, maxlen, _(\"%.02f EV\"), d);\n\t\tsnprintf (b, sizeof (b), _(\" (f/%.01f)\"), pow (2, d / 2.));\n\t\tstrncat (val, b, maxlen-1 - strlen (val));\n\t\tbreak;\n\tcase EXIF_TAG_FOCAL_LENGTH:\n\t\tCF (e, EXIF_FORMAT_RATIONAL, val, maxlen);\n\t\tCC (e, 1, val, maxlen);\n\t\tv_rat = exif_get_rational (e->data, o);\n\t\tif (!v_rat.denominator) {\n\t\t\texif_entry_format_value(e, val, maxlen);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * For calculation of the 35mm equivalent,\n\t\t * Minolta cameras need a multiplier that depends on the\n\t\t * camera model.\n\t\t */\n\t\td = 0.;\n\t\tentry = exif_content_get_entry (\n\t\t\te->parent->parent->ifd[EXIF_IFD_0], EXIF_TAG_MAKE);\n\t\tif (entry && entry->data && entry->size >= 7 &&\n\t\t    !strncmp ((char *)entry->data, \"Minolta\", 7)) {\n\t\t\tentry = exif_content_get_entry (\n\t\t\t\t\te->parent->parent->ifd[EXIF_IFD_0],\n\t\t\t\t\tEXIF_TAG_MODEL);\n\t\t\tif (entry && entry->data && entry->size >= 8) {\n\t\t\t\tif (!strncmp ((char *)entry->data, \"DiMAGE 7\", 8))\n\t\t\t\t\td = 3.9;\n\t\t\t\telse if (!strncmp ((char *)entry->data, \"DiMAGE 5\", 8))\n\t\t\t\t\td = 4.9;\n\t\t\t}\n\t\t}\n\t\tif (d)\n\t\t\tsnprintf (b, sizeof (b), _(\" (35 equivalent: %.0f mm)\"),\n\t\t\t\t  (d * (double) v_rat.numerator /\n\t\t\t\t       (double) v_rat.denominator));\n\t\telse\n\t\t\tb[0] = 0;\n\n\t\td = (double) v_rat.numerator / (double) v_rat.denominator;\n\t\tsnprintf (val, maxlen, \"%.1f mm\", d);\n\t\tstrncat (val, b, maxlen-1 - strlen (val));\n\t\tbreak;\n\tcase EXIF_TAG_SUBJECT_DISTANCE:\n\t\tCF (e, EXIF_FORMAT_RATIONAL, val, maxlen);\n\t\tCC (e, 1, val, maxlen);\n\t\tv_rat = exif_get_rational (e->data, o);\n\t\tif (!v_rat.denominator) {\n\t\t\texif_entry_format_value(e, val, maxlen);\n\t\t\tbreak;\n\t\t}\n\t\td = (double) v_rat.numerator / (double) v_rat.denominator;\n\t\tsnprintf (val, maxlen, \"%.1f m\", d);\n\t\tbreak;\n\tcase EXIF_TAG_EXPOSURE_TIME:\n\t\tCF (e, EXIF_FORMAT_RATIONAL, val, maxlen);\n\t\tCC (e, 1, val, maxlen);\n\t\tv_rat = exif_get_rational (e->data, o);\n\t\tif (!v_rat.denominator) {\n\t\t\texif_entry_format_value(e, val, maxlen);\n\t\t\tbreak;\n\t\t}\n\t\td = (double) v_rat.numerator / (double) v_rat.denominator;\n\t\tif (d < 1 && d)\n\t\t\tsnprintf (val, maxlen, _(\"1/%.0f\"), 1. / d);\n\t\telse\n\t\t\tsnprintf (val, maxlen, \"%.0f\", d);\n\t\tstrncat (val, _(\" sec.\"), maxlen-1 - strlen (val));\n\t\tbreak;\n\tcase EXIF_TAG_SHUTTER_SPEED_VALUE:\n\t\tCF (e, EXIF_FORMAT_SRATIONAL, val, maxlen);\n\t\tCC (e, 1, val, maxlen);\n\t\tv_srat = exif_get_srational (e->data, o);\n\t\tif (!v_srat.denominator) {\n\t\t\texif_entry_format_value(e, val, maxlen);\n\t\t\tbreak;\n\t\t}\n\t\td = (double) v_srat.numerator / (double) v_srat.denominator;\n\t\tsnprintf (val, maxlen, _(\"%.02f EV\"), d);\n\t\tif (pow (2, d))\n\t\t\td = 1. / pow (2, d);\n\t\tif (d < 1 && d)\n\t\t  snprintf (b, sizeof (b), _(\" (1/%.0f sec.)\"), 1. / d);\n\t\telse\n\t\t  snprintf (b, sizeof (b), _(\" (%.0f sec.)\"), d);\n\t\tstrncat (val, b, maxlen-1 - strlen (val));\n\t\tbreak;\n\tcase EXIF_TAG_BRIGHTNESS_VALUE:\n\t\tCF (e, EXIF_FORMAT_SRATIONAL, val, maxlen);\n\t\tCC (e, 1, val, maxlen);\n\t\tv_srat = exif_get_srational (e->data, o);\n\t\tif (!v_srat.denominator) {\n\t\t\texif_entry_format_value(e, val, maxlen);\n\t\t\tbreak;\n\t\t}\n\t\td = (double) v_srat.numerator / (double) v_srat.denominator;\n\t\tsnprintf (val, maxlen, _(\"%.02f EV\"), d);\n\t\tsnprintf (b, sizeof (b), _(\" (%.02f cd/m^2)\"),\n\t\t\t1. / (M_PI * 0.3048 * 0.3048) * pow (2, d));\n\t\tstrncat (val, b, maxlen-1 - strlen (val));\n\t\tbreak;\n\tcase EXIF_TAG_FILE_SOURCE:\n\t\tCF (e, EXIF_FORMAT_UNDEFINED, val, maxlen);\n\t\tCC (e, 1, val, maxlen);\n\t\tv_byte = e->data[0];\n\t\tif (v_byte == 3)\n\t\t\tstrncpy (val, _(\"DSC\"), maxlen-1);\n\t\telse\n\t\t\tsnprintf (val, maxlen, _(\"Internal error (unknown \"\n\t\t\t\t  \"value %i)\"), v_byte);\n\t\tbreak;\n\tcase EXIF_TAG_COMPONENTS_CONFIGURATION:\n\t\tCF (e, EXIF_FORMAT_UNDEFINED, val, maxlen);\n\t\tCC (e, 4, val, maxlen);\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tswitch (e->data[i]) {\n\t\t\tcase 0: c = _(\"-\"); break;\n\t\t\tcase 1: c = _(\"Y\"); break;\n\t\t\tcase 2: c = _(\"Cb\"); break;\n\t\t\tcase 3: c = _(\"Cr\"); break;\n\t\t\tcase 4: c = _(\"R\"); break;\n\t\t\tcase 5: c = _(\"G\"); break;\n\t\t\tcase 6: c = _(\"B\"); break;\n\t\t\tdefault: c = _(\"Reserved\"); break;\n\t\t\t}\n\t\t\tstrncat (val, c, maxlen-1 - strlen (val));\n\t\t\tif (i < 3)\n\t\t\t\tstrncat (val, \" \", maxlen-1 - strlen (val));\n\t\t}\n\t\tbreak;\n\tcase EXIF_TAG_EXPOSURE_BIAS_VALUE:\n\t\tCF (e, EXIF_FORMAT_SRATIONAL, val, maxlen);\n\t\tCC (e, 1, val, maxlen);\n\t\tv_srat = exif_get_srational (e->data, o);\n\t\tif (!v_srat.denominator) {\n\t\t\texif_entry_format_value(e, val, maxlen);\n\t\t\tbreak;\n\t\t}\n\t\td = (double) v_srat.numerator / (double) v_srat.denominator;\n\t\tsnprintf (val, maxlen, _(\"%.02f EV\"), d);\n\t\tbreak;\n\tcase EXIF_TAG_SCENE_TYPE:\n\t\tCF (e, EXIF_FORMAT_UNDEFINED, val, maxlen);\n\t\tCC (e, 1, val, maxlen);\n\t\tv_byte = e->data[0];\n\t\tif (v_byte == 1)\n\t\t\tstrncpy (val, _(\"Directly photographed\"), maxlen-1);\n\t\telse\n\t\t\tsnprintf (val, maxlen, _(\"Internal error (unknown \"\n\t\t\t\t  \"value %i)\"), v_byte);\n\t\tbreak;\n\tcase EXIF_TAG_YCBCR_SUB_SAMPLING:\n\t\tCF (e, EXIF_FORMAT_SHORT, val, maxlen);\n\t\tCC (e, 2, val, maxlen);\n\t\tv_short  = exif_get_short (e->data, o);\n\t\tv_short2 = exif_get_short (\n\t\t\te->data + exif_format_get_size (e->format),\n\t\t\to);\n\t\tif ((v_short == 2) && (v_short2 == 1))\n\t\t\tstrncpy (val, _(\"YCbCr4:2:2\"), maxlen-1);\n\t\telse if ((v_short == 2) && (v_short2 == 2))\n\t\t\tstrncpy (val, _(\"YCbCr4:2:0\"), maxlen-1);\n\t\telse\n\t\t\tsnprintf (val, maxlen, \"%u, %u\", v_short, v_short2);\n\t\tbreak;\n\tcase EXIF_TAG_SUBJECT_AREA:\n\t\tCF (e, EXIF_FORMAT_SHORT, val, maxlen);\n\t\tswitch (e->components) {\n\t\tcase 2:\n\t\t\tv_short  = exif_get_short (e->data, o);\n\t\t\tv_short2 = exif_get_short (e->data + 2, o);\n\t\t\tsnprintf (val, maxlen, \"(x,y) = (%i,%i)\",\n\t\t\t\t  v_short, v_short2);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tv_short  = exif_get_short (e->data, o);\n\t\t\tv_short2 = exif_get_short (e->data + 2, o);\n\t\t\tv_short3 = exif_get_short (e->data + 4, o);\n\t\t\tsnprintf (val, maxlen, _(\"Within distance %i of \"\n\t\t\t\t\"(x,y) = (%i,%i)\"), v_short3, v_short,\n\t\t\t\tv_short2);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tv_short  = exif_get_short (e->data, o);\n\t\t\tv_short2 = exif_get_short (e->data + 2, o);\n\t\t\tv_short3 = exif_get_short (e->data + 4, o);\n\t\t\tv_short4 = exif_get_short (e->data + 6, o);\n\t\t\tsnprintf (val, maxlen, _(\"Within rectangle \"\n\t\t\t\t\"(width %i, height %i) around \"\n\t\t\t\t\"(x,y) = (%i,%i)\"), v_short3, v_short4,\n\t\t\t\tv_short, v_short2);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnprintf (val, maxlen, _(\"Unexpected number \"\n\t\t\t\t\"of components (%li, expected 2, 3, or 4).\"),\n\t\t\t\te->components);\t\n\t\t}\n\t\tbreak;\n\tcase EXIF_TAG_GPS_VERSION_ID:\n\t\t/* This is only valid in the GPS IFD */\n\t\tCF (e, EXIF_FORMAT_BYTE, val, maxlen);\n\t\tCC (e, 4, val, maxlen);\n\t\tv_byte = e->data[0];\n\t\tsnprintf (val, maxlen, \"%u\", v_byte);\n\t\tfor (i = 1; i < e->components; i++) {\n\t\t\tv_byte = e->data[i];\n\t\t\tsnprintf (b, sizeof (b), \".%u\", v_byte);\n\t\t\tstrncat (val, b, maxlen-1 - strlen (val));\n\t\t}\n\t\tbreak;\n\tcase EXIF_TAG_INTEROPERABILITY_VERSION:\n\t/* a.k.a. case EXIF_TAG_GPS_LATITUDE: */\n\t\t/* This tag occurs in EXIF_IFD_INTEROPERABILITY */\n\t\tif (e->format == EXIF_FORMAT_UNDEFINED) {\n\t\t\tstrncpy (val, (char *) e->data, MIN (maxlen-1, e->size));\n\t\t\tbreak;\n\t\t}\n\t\t/* EXIF_TAG_GPS_LATITUDE is the same numerically as\n\t\t * EXIF_TAG_INTEROPERABILITY_VERSION but in EXIF_IFD_GPS\n\t\t */\n\t\texif_entry_format_value(e, val, maxlen);\n\t\tbreak;\n\tcase EXIF_TAG_GPS_ALTITUDE_REF:\n\t\t/* This is only valid in the GPS IFD */\n\t\tCF (e, EXIF_FORMAT_BYTE, val, maxlen);\n\t\tCC (e, 1, val, maxlen);\n\t\tv_byte = e->data[0];\n\t\tif (v_byte == 0)\n\t\t\tstrncpy (val, _(\"Sea level\"), maxlen-1);\n\t\telse if (v_byte == 1)\n\t\t\tstrncpy (val, _(\"Sea level reference\"), maxlen-1);\n\t\telse\n\t\t\tsnprintf (val, maxlen, _(\"Internal error (unknown \"\n\t\t\t\t  \"value %i)\"), v_byte);\n\t\tbreak;\n\tcase EXIF_TAG_GPS_TIME_STAMP:\n\t\t/* This is only valid in the GPS IFD */\n\t\tCF (e, EXIF_FORMAT_RATIONAL, val, maxlen);\n\t\tCC (e, 3, val, maxlen);\n\n\t\tv_rat  = exif_get_rational (e->data, o);\n\t\tif (!v_rat.denominator) {\n\t\t\texif_entry_format_value(e, val, maxlen);\n\t\t\tbreak;\n\t\t}\n\t\ti = v_rat.numerator / v_rat.denominator;\n\n\t\tv_rat = exif_get_rational (e->data +\n\t\t\t\t\t     exif_format_get_size (e->format),\n\t\t\t\t\t   o);\n\t\tif (!v_rat.denominator) {\n\t\t\texif_entry_format_value(e, val, maxlen);\n\t\t\tbreak;\n\t\t}\n\t\tj = v_rat.numerator / v_rat.denominator;\n\n\t\tv_rat = exif_get_rational (e->data +\n\t\t\t\t\t     2*exif_format_get_size (e->format),\n\t\t\t\t\t     o);\n\t\tif (!v_rat.denominator) {\n\t\t\texif_entry_format_value(e, val, maxlen);\n\t\t\tbreak;\n\t\t}\n\t\td = (double) v_rat.numerator / (double) v_rat.denominator;\n\t\tsnprintf (val, maxlen, \"%02u:%02u:%05.2f\", i, j, d);\n\t\tbreak;\n\n\tcase EXIF_TAG_METERING_MODE:\n\tcase EXIF_TAG_COMPRESSION:\n\tcase EXIF_TAG_LIGHT_SOURCE:\n\tcase EXIF_TAG_FOCAL_PLANE_RESOLUTION_UNIT:\n\tcase EXIF_TAG_RESOLUTION_UNIT:\n\tcase EXIF_TAG_EXPOSURE_PROGRAM:\n\tcase EXIF_TAG_FLASH:\n\tcase EXIF_TAG_SUBJECT_DISTANCE_RANGE:\n\tcase EXIF_TAG_COLOR_SPACE:\n\t\tCF (e,EXIF_FORMAT_SHORT, val, maxlen);\n\t\tCC (e, 1, val, maxlen);\n\t\tv_short = exif_get_short (e->data, o);\n\n\t\t/* Search the tag */\n\t\tfor (i = 0; list2[i].tag && (list2[i].tag != e->tag); i++);\n\t\tif (!list2[i].tag) {\n\t\t\tsnprintf (val, maxlen, _(\"Internal error (unknown \"\n\t\t\t\t  \"value %i)\"), v_short);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Find the value */\n\t\tfor (j = 0; list2[i].elem[j].values[0] &&\n\t\t\t    (list2[i].elem[j].index < v_short); j++);\n\t\tif (list2[i].elem[j].index != v_short) {\n\t\t\tsnprintf (val, maxlen, _(\"Internal error (unknown \"\n\t\t\t\t  \"value %i)\"), v_short);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Find a short enough value */\n\t\tmemset (val, 0, maxlen);\n\t\tfor (k = 0; list2[i].elem[j].values[k]; k++) {\n\t\t\tsize_t l = strlen (_(list2[i].elem[j].values[k]));\n\t\t\tif ((maxlen > l) && (strlen (val) < l))\n\t\t\t\tstrncpy (val, _(list2[i].elem[j].values[k]), maxlen-1);\n\t\t}\n\t\tif (!val[0]) snprintf (val, maxlen, \"%i\", v_short);\n\n\t\tbreak;\n\n\tcase EXIF_TAG_PLANAR_CONFIGURATION:\n\tcase EXIF_TAG_SENSING_METHOD:\n\tcase EXIF_TAG_ORIENTATION:\n\tcase EXIF_TAG_YCBCR_POSITIONING:\n\tcase EXIF_TAG_PHOTOMETRIC_INTERPRETATION:\n\tcase EXIF_TAG_CUSTOM_RENDERED:\n\tcase EXIF_TAG_EXPOSURE_MODE:\n\tcase EXIF_TAG_WHITE_BALANCE:\n\tcase EXIF_TAG_SCENE_CAPTURE_TYPE:\n\tcase EXIF_TAG_GAIN_CONTROL:\n\tcase EXIF_TAG_SATURATION:\n\tcase EXIF_TAG_CONTRAST:\n\tcase EXIF_TAG_SHARPNESS:\n\t\tCF (e, EXIF_FORMAT_SHORT, val, maxlen);\n\t\tCC (e, 1, val, maxlen);\n\t\tv_short = exif_get_short (e->data, o);\n\n\t\t/* Search the tag */\n\t\tfor (i = 0; list[i].tag && (list[i].tag != e->tag); i++);\n\t\tif (!list[i].tag) {\n\t\t\tsnprintf (val, maxlen, _(\"Internal error (unknown \"\n\t\t\t\t  \"value %i)\"), v_short);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Find the value */\n\t\tfor (j = 0; list[i].strings[j] && (j < v_short); j++);\n\t\tif (!list[i].strings[j])\n\t\t\tsnprintf (val, maxlen, \"%i\", v_short);\n\t\telse if (!*list[i].strings[j])\n\t\t\tsnprintf (val, maxlen, _(\"Unknown value %i\"), v_short);\n\t\telse\n\t\t\tstrncpy (val, _(list[i].strings[j]), maxlen-1);\n\t\tbreak;\n\n\tcase EXIF_TAG_XP_TITLE:\n\tcase EXIF_TAG_XP_COMMENT:\n\tcase EXIF_TAG_XP_AUTHOR:\n\tcase EXIF_TAG_XP_KEYWORDS:\n\tcase EXIF_TAG_XP_SUBJECT:\n\t{\n\t\tunsigned char *utf16;\n\n\t\t/* Sanity check the size to prevent overflow. Note EXIF files are 64kb at most. */\n\t\tif (e->size >= 65536 - sizeof(uint16_t)*2) break;\n\n\t\t/* The tag may not be U+0000-terminated , so make a local\n\t\t   U+0000-terminated copy before converting it */\n\t\tutf16 = exif_mem_alloc (e->priv->mem, e->size+sizeof(uint16_t)+1);\n\t\tif (!utf16) break;\n\t\tmemcpy(utf16, e->data, e->size);\n\n\t\t/* NUL terminate the string. If the size is odd (which isn't possible\n\t\t * for a valid UTF16 string), then this will overwrite the high byte of\n\t\t * the final half word, plus add a full zero NUL word at the end.\n\t\t */\n\t\tutf16[e->size] = 0;\n\t\tutf16[e->size+1] = 0;\n\t\tutf16[e->size+2] = 0;\n\n\t\t/* Warning! The texts are converted from UTF16 to UTF8 */\n\t\t/* FIXME: use iconv to convert into the locale encoding */\n\t\texif_convert_utf16_to_utf8(val, utf16, maxlen);\n\t\texif_mem_free(e->priv->mem, utf16);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\t/* Use a generic value formatting */\n\t\texif_entry_format_value(e, val, maxlen);\n\t}\n\n\treturn val;\n}",
        "start_line": 833
      }
    ],
    "code_context": "Called Methods:\n- exif_convert_utf16_to_utf8: void /* <=== exif_convert_utf16_to_utf8 */ \nexif_convert_utf16_to_utf8 (char *out, const unsigned char *in, int maxlen)\n{\n\tif (maxlen <= 0) {\n\t\treturn;\n\t}\n\tfor (;;) {\n\t\tExifShort v = exif_get_short(in, EXIF_BYTE_ORDER_INTEL);\n\t\tif (!v)\n\t\t\tbreak;\n\t\tif (v < 0x80) {\n\t\t\tif (maxlen > 1) {\n\t\t\t\t*out++ = (char)v;\n\t\t\t\tmaxlen--;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (v < 0x800) {\n\t\t\tif (maxlen > 2) {\n\t\t\t\t*out++ = ((v >> 6) & 0x1F) | 0xC0;\n\t\t\t\t*out++ = (v & 0x3F) | 0x80;\n\t\t\t\tmaxlen -= 2;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (maxlen > 3) {\n\t\t\t\t*out++ = ((v >> 12) & 0x0F) | 0xE0;\n\t\t\t\t*out++ = ((v >> 6) & 0x3F) | 0x80;\n\t\t\t\t*out++ = (v & 0x3F) | 0x80;\n\t\t\t\tmaxlen -= 3;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tin += 2;\n\t}\n\t*out = 0;\n}\n- exif_mem_free: void  exif_mem_free    (ExifMem *m, void *p); /* <=== exif_mem_free */ \n- exif_mem_alloc: void *exif_mem_alloc   (ExifMem *m, ExifLong s); /* <=== exif_mem_alloc */ \n- exif_get_short: ExifShort /* <=== exif_get_short */ \nexif_get_short (const unsigned char *buf, ExifByteOrder order)\n{\n\treturn (exif_get_sshort (buf, order) & 0xffff);\n}\n- exif_format_get_size: unsigned char exif_format_get_size (ExifFormat format); /* <=== exif_format_get_size */ \n\nType Definitions:\n- ExifEntry: typedef struct _ExifEntry        ExifEntry;\n\nImports:\n- #include <math.h>\n- #include <stdlib.h>\n- #include <config.h>\n- #include <stdio.h>\n- #include <time.h>\n- #include <libexif/exif-utils.h>\n- #include <ctype.h>\n- #include <libexif/exif-ifd.h>\n- #include <libexif/exif-entry.h>\n- #include <string.h>\n- #include <libexif/i18n.h>",
    "commit_msg": "fixed a incorrect overflow check that could be optimized away.\n\ninspired by:\nhttps://android.googlesource.com/platform/external/libexif/+/8e7345f3bc0bad06ac369d6cbc1124c8ceaf7d4b\n\nhttps://source.android.com/security/bulletin/2020-11-01\n\nCVE-2020-0452",
    "cve_desc": "In exif_entry_get_value of exif-entry.c, there is a possible out of bounds write due to an integer overflow. This could lead to remote code execution if a third party app used this library to process remote image data with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-8.1 Android-9 Android-10 Android-11 Android-8.0Android ID: A-159625731",
    "year": 2020,
    "filename": "exif-entry.c",
    "commit_url": "\"https://github.com/libexif/libexif/commit/9266d14b5ca4e29b970fa03272318e5f99386e06\""
  },
  {
    "repository": "python-pillow/Pillow",
    "cve_id": "CVE-2020-10378",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "6a83e4324738bb0452fbe8074a995b1c73f08de7",
    "short_hash": "6a83e432",
    "vulnerableMethods_before": [
      {
        "filename": "src/libImaging/PcxDecode.c",
        "method_name": "ImagingPcxDecode",
        "raw_code": "int /* <=== ImagingPcxDecode */ \nImagingPcxDecode(Imaging im, ImagingCodecState state, UINT8* buf, Py_ssize_t bytes)\n{\n    UINT8 n;\n    UINT8* ptr;\n\n    if (strcmp(im->mode, \"1\") == 0 && state->xsize > state->bytes * 8) {\n        state->errcode = IMAGING_CODEC_OVERRUN;\n        return -1;\n    } else if (strcmp(im->mode, \"P\") == 0 && state->xsize > state->bytes) {\n        state->errcode = IMAGING_CODEC_OVERRUN;\n        return -1;\n    }\n\n    ptr = buf;\n\n    for (;;) {\n\n\tif (bytes < 1)\n\t    return ptr - buf;\n\n\tif ((*ptr & 0xC0) == 0xC0) {\n\n\t    /* Run */\n\t    if (bytes < 2)\n\t\treturn ptr - buf;\n\n\t    n = ptr[0] & 0x3F;\n\n\t    while (n > 0) {\n\t\tif (state->x >= state->bytes) {\n\t\t    state->errcode = IMAGING_CODEC_OVERRUN;\n\t\t    break;\n\t\t}\n\t\tstate->buffer[state->x++] = ptr[1];\n\t\tn--;\n\t    }\n\n\t    ptr += 2; bytes -= 2;\n\n\t} else {\n\n\t    /* Literal */\n\t    state->buffer[state->x++] = ptr[0];\n\t    ptr++; bytes--;\n\n\t}\n\n\tif (state->x >= state->bytes) {\n        if (state->bytes % state->xsize && state->bytes > state->xsize) {\n            int bands = state->bytes / state->xsize;\n            int stride = state->bytes / bands;\n            int i;\n            for (i=1; i< bands; i++) {  // note -- skipping first band\n                memmove(&state->buffer[i*state->xsize],\n                        &state->buffer[i*stride],\n                        state->xsize);\n            }\n        }\n\t    /* Got a full line, unpack it */\n\t    state->shuffle((UINT8*) im->image[state->y + state->yoff] +\n\t\t\t   state->xoff * im->pixelsize, state->buffer,\n\t\t\t   state->xsize);\n\n\t    state->x = 0;\n\n\t    if (++state->y >= state->ysize) {\n\t\t/* End of file (errcode = 0) */\n\t\treturn -1;\n\t    }\n\t}\n\n    }\n}",
        "start_line": 19
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "src/libImaging/PcxDecode.c",
        "method_name": "ImagingPcxDecode",
        "raw_code": "int /* <=== ImagingPcxDecode */ \nImagingPcxDecode(Imaging im, ImagingCodecState state, UINT8* buf, Py_ssize_t bytes)\n{\n    UINT8 n;\n    UINT8* ptr;\n\n    if ((state->xsize * state->bits + 7) / 8 > state->bytes) {\n        state->errcode = IMAGING_CODEC_OVERRUN;\n        return -1;\n    }\n\n    ptr = buf;\n\n    for (;;) {\n\n\tif (bytes < 1)\n\t    return ptr - buf;\n\n\tif ((*ptr & 0xC0) == 0xC0) {\n\n\t    /* Run */\n\t    if (bytes < 2)\n\t\treturn ptr - buf;\n\n\t    n = ptr[0] & 0x3F;\n\n\t    while (n > 0) {\n\t\tif (state->x >= state->bytes) {\n\t\t    state->errcode = IMAGING_CODEC_OVERRUN;\n\t\t    break;\n\t\t}\n\t\tstate->buffer[state->x++] = ptr[1];\n\t\tn--;\n\t    }\n\n\t    ptr += 2; bytes -= 2;\n\n\t} else {\n\n\t    /* Literal */\n\t    state->buffer[state->x++] = ptr[0];\n\t    ptr++; bytes--;\n\n\t}\n\n\tif (state->x >= state->bytes) {\n        if (state->bytes % state->xsize && state->bytes > state->xsize) {\n            int bands = state->bytes / state->xsize;\n            int stride = state->bytes / bands;\n            int i;\n            for (i=1; i< bands; i++) {  // note -- skipping first band\n                memmove(&state->buffer[i*state->xsize],\n                        &state->buffer[i*stride],\n                        state->xsize);\n            }\n        }\n\t    /* Got a full line, unpack it */\n\t    state->shuffle((UINT8*) im->image[state->y + state->yoff] +\n\t\t\t   state->xoff * im->pixelsize, state->buffer,\n\t\t\t   state->xsize);\n\n\t    state->x = 0;\n\n\t    if (++state->y >= state->ysize) {\n\t\t/* End of file (errcode = 0) */\n\t\treturn -1;\n\t    }\n\t}\n\n    }\n}",
        "start_line": 19
      }
    ],
    "code_context": "Called Methods:\n- IMAGING_CODEC_OVERRUN: #define IMAGING_CODEC_OVERRUN   -1 /* <=== src/libImaging/Imaging.h:537:537:IMAGING_CODEC_OVERRUN:0 */ \n\nType Definitions:\n- ImagingCodecState: typedef struct ImagingCodecStateInstance *ImagingCodecState;\n- Imaging: typedef struct ImagingMemoryInstance* Imaging;\n\nImports:\n- #include \"Imaging.h\"",
    "commit_msg": "Fix OOB Access on PcxDecode.c",
    "cve_desc": "In libImaging/PcxDecode.c in Pillow before 7.1.0, an out-of-bounds read can occur when reading PCX files where state->shuffle is instructed to read beyond state->buffer.",
    "year": 2020,
    "filename": "PcxDecode.c",
    "commit_url": "\"https://github.com/python-pillow/Pillow/commit/6a83e4324738bb0452fbe8074a995b1c73f08de7\""
  },
  {
    "repository": "perl/perl5",
    "cve_id": "CVE-2020-10543",
    "cwe_list": [
      "CWE-190"
    ],
    "commit_hash": "897d1f7fd515b828e4b198d8b8bef76c6faf03ed",
    "short_hash": "897d1f7f",
    "vulnerableMethods_before": [
      {
        "filename": "regcomp.c",
        "method_name": "S_study_chunk",
        "raw_code": "STATIC SSize_t /* <=== S_study_chunk */ \nS_study_chunk(pTHX_ RExC_state_t *pRExC_state, regnode **scanp,\n                        SSize_t *minlenp, SSize_t *deltap,\n\t\t\tregnode *last,\n\t\t\tscan_data_t *data,\n\t\t\tI32 stopparen,\n                        U32 recursed_depth,\n\t\t\tregnode_ssc *and_withp,\n\t\t\tU32 flags, U32 depth)\n\t\t\t/* scanp: Start here (read-write). */\n\t\t\t/* deltap: Write maxlen-minlen here. */\n\t\t\t/* last: Stop before this one. */\n\t\t\t/* data: string data about the pattern */\n\t\t\t/* stopparen: treat close N as END */\n\t\t\t/* recursed: which subroutines have we recursed into */\n\t\t\t/* and_withp: Valid if flags & SCF_DO_STCLASS_OR */\n{\n    dVAR;\n    /* There must be at least this number of characters to match */\n    SSize_t min = 0;\n    I32 pars = 0, code;\n    regnode *scan = *scanp, *next;\n    SSize_t delta = 0;\n    int is_inf = (flags & SCF_DO_SUBSTR) && (data->flags & SF_IS_INF);\n    int is_inf_internal = 0;\t\t/* The studied chunk is infinite */\n    I32 is_par = OP(scan) == OPEN ? ARG(scan) : 0;\n    scan_data_t data_fake;\n    SV *re_trie_maxbuff = NULL;\n    regnode *first_non_open = scan;\n    SSize_t stopmin = SSize_t_MAX;\n    scan_frame *frame = NULL;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_STUDY_CHUNK;\n    RExC_study_started= 1;\n\n    Zero(&data_fake, 1, scan_data_t);\n\n    if ( depth == 0 ) {\n        while (first_non_open && OP(first_non_open) == OPEN)\n            first_non_open=regnext(first_non_open);\n    }\n\n\n  fake_study_recurse:\n    DEBUG_r(\n        RExC_study_chunk_recursed_count++;\n    );\n    DEBUG_OPTIMISE_MORE_r(\n    {\n        Perl_re_indentf( aTHX_  \"study_chunk stopparen=%ld recursed_count=%lu depth=%lu recursed_depth=%lu scan=%p last=%p\",\n            depth, (long)stopparen,\n            (unsigned long)RExC_study_chunk_recursed_count,\n            (unsigned long)depth, (unsigned long)recursed_depth,\n            scan,\n            last);\n        if (recursed_depth) {\n            U32 i;\n            U32 j;\n            for ( j = 0 ; j < recursed_depth ; j++ ) {\n                for ( i = 0 ; i < (U32)RExC_total_parens ; i++ ) {\n                    if (\n                        PAREN_TEST(RExC_study_chunk_recursed +\n                                   ( j * RExC_study_chunk_recursed_bytes), i )\n                        && (\n                            !j ||\n                            !PAREN_TEST(RExC_study_chunk_recursed +\n                                   (( j - 1 ) * RExC_study_chunk_recursed_bytes), i)\n                        )\n                    ) {\n                        Perl_re_printf( aTHX_ \" %d\",(int)i);\n                        break;\n                    }\n                }\n                if ( j + 1 < recursed_depth ) {\n                    Perl_re_printf( aTHX_  \",\");\n                }\n            }\n        }\n        Perl_re_printf( aTHX_ \"\\n\");\n    }\n    );\n    while ( scan && OP(scan) != END && scan < last ){\n        UV min_subtract = 0;    /* How mmany chars to subtract from the minimum\n                                   node length to get a real minimum (because\n                                   the folded version may be shorter) */\n\tbool unfolded_multi_char = FALSE;\n\t/* Peephole optimizer: */\n        DEBUG_STUDYDATA(\"Peep\", data, depth, is_inf);\n        DEBUG_PEEP(\"Peep\", scan, depth, flags);\n\n\n        /* The reason we do this here is that we need to deal with things like\n         * /(?:f)(?:o)(?:o)/ which cant be dealt with by the normal EXACT\n         * parsing code, as each (?:..) is handled by a different invocation of\n         * reg() -- Yves\n         */\n        JOIN_EXACT(scan,&min_subtract, &unfolded_multi_char, 0);\n\n\t/* Follow the next-chain of the current node and optimize\n\t   away all the NOTHINGs from it.  */\n\tif (OP(scan) != CURLYX) {\n\t    const int max = (reg_off_by_arg[OP(scan)]\n\t\t       ? I32_MAX\n\t\t       /* I32 may be smaller than U16 on CRAYs! */\n\t\t       : (I32_MAX < U16_MAX ? I32_MAX : U16_MAX));\n\t    int off = (reg_off_by_arg[OP(scan)] ? ARG(scan) : NEXT_OFF(scan));\n\t    int noff;\n\t    regnode *n = scan;\n\n\t    /* Skip NOTHING and LONGJMP. */\n\t    while ((n = regnext(n))\n\t\t   && ((PL_regkind[OP(n)] == NOTHING && (noff = NEXT_OFF(n)))\n\t\t       || ((OP(n) == LONGJMP) && (noff = ARG(n))))\n\t\t   && off + noff < max)\n\t\toff += noff;\n\t    if (reg_off_by_arg[OP(scan)])\n\t\tARG(scan) = off;\n\t    else\n\t\tNEXT_OFF(scan) = off;\n\t}\n\n\t/* The principal pseudo-switch.  Cannot be a switch, since we\n\t   look into several different things.  */\n        if ( OP(scan) == DEFINEP ) {\n            SSize_t minlen = 0;\n            SSize_t deltanext = 0;\n            SSize_t fake_last_close = 0;\n            I32 f = SCF_IN_DEFINE;\n\n            StructCopy(&zero_scan_data, &data_fake, scan_data_t);\n            scan = regnext(scan);\n            assert( OP(scan) == IFTHEN );\n            DEBUG_PEEP(\"expect IFTHEN\", scan, depth, flags);\n\n            data_fake.last_closep= &fake_last_close;\n            minlen = *minlenp;\n            next = regnext(scan);\n            scan = NEXTOPER(NEXTOPER(scan));\n            DEBUG_PEEP(\"scan\", scan, depth, flags);\n            DEBUG_PEEP(\"next\", next, depth, flags);\n\n            /* we suppose the run is continuous, last=next...\n             * NOTE we dont use the return here! */\n            /* DEFINEP study_chunk() recursion */\n            (void)study_chunk(pRExC_state, &scan, &minlen,\n                              &deltanext, next, &data_fake, stopparen,\n                              recursed_depth, NULL, f, depth+1);\n\n            scan = next;\n        } else\n        if (\n            OP(scan) == BRANCH  ||\n            OP(scan) == BRANCHJ ||\n            OP(scan) == IFTHEN\n        ) {\n\t    next = regnext(scan);\n\t    code = OP(scan);\n\n            /* The op(next)==code check below is to see if we\n             * have \"BRANCH-BRANCH\", \"BRANCHJ-BRANCHJ\", \"IFTHEN-IFTHEN\"\n             * IFTHEN is special as it might not appear in pairs.\n             * Not sure whether BRANCH-BRANCHJ is possible, regardless\n             * we dont handle it cleanly. */\n\t    if (OP(next) == code || code == IFTHEN) {\n                /* NOTE - There is similar code to this block below for\n                 * handling TRIE nodes on a re-study.  If you change stuff here\n                 * check there too. */\n\t\tSSize_t max1 = 0, min1 = SSize_t_MAX, num = 0;\n\t\tregnode_ssc accum;\n\t\tregnode * const startbranch=scan;\n\n                if (flags & SCF_DO_SUBSTR) {\n                    /* Cannot merge strings after this. */\n                    scan_commit(pRExC_state, data, minlenp, is_inf);\n                }\n\n                if (flags & SCF_DO_STCLASS)\n\t\t    ssc_init_zero(pRExC_state, &accum);\n\n\t\twhile (OP(scan) == code) {\n\t\t    SSize_t deltanext, minnext, fake;\n\t\t    I32 f = 0;\n\t\t    regnode_ssc this_class;\n\n                    DEBUG_PEEP(\"Branch\", scan, depth, flags);\n\n\t\t    num++;\n                    StructCopy(&zero_scan_data, &data_fake, scan_data_t);\n\t\t    if (data) {\n\t\t\tdata_fake.whilem_c = data->whilem_c;\n\t\t\tdata_fake.last_closep = data->last_closep;\n\t\t    }\n\t\t    else\n\t\t\tdata_fake.last_closep = &fake;\n\n\t\t    data_fake.pos_delta = delta;\n\t\t    next = regnext(scan);\n\n                    scan = NEXTOPER(scan); /* everything */\n                    if (code != BRANCH)    /* everything but BRANCH */\n\t\t\tscan = NEXTOPER(scan);\n\n\t\t    if (flags & SCF_DO_STCLASS) {\n\t\t\tssc_init(pRExC_state, &this_class);\n\t\t\tdata_fake.start_class = &this_class;\n\t\t\tf = SCF_DO_STCLASS_AND;\n\t\t    }\n\t\t    if (flags & SCF_WHILEM_VISITED_POS)\n\t\t\tf |= SCF_WHILEM_VISITED_POS;\n\n\t\t    /* we suppose the run is continuous, last=next...*/\n                    /* recurse study_chunk() for each BRANCH in an alternation */\n\t\t    minnext = study_chunk(pRExC_state, &scan, minlenp,\n                                      &deltanext, next, &data_fake, stopparen,\n                                      recursed_depth, NULL, f, depth+1);\n\n\t\t    if (min1 > minnext)\n\t\t\tmin1 = minnext;\n\t\t    if (deltanext == SSize_t_MAX) {\n\t\t\tis_inf = is_inf_internal = 1;\n\t\t\tmax1 = SSize_t_MAX;\n\t\t    } else if (max1 < minnext + deltanext)\n\t\t\tmax1 = minnext + deltanext;\n\t\t    scan = next;\n\t\t    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))\n\t\t\tpars++;\n\t            if (data_fake.flags & SCF_SEEN_ACCEPT) {\n\t                if ( stopmin > minnext)\n\t                    stopmin = min + min1;\n\t                flags &= ~SCF_DO_SUBSTR;\n\t                if (data)\n\t                    data->flags |= SCF_SEEN_ACCEPT;\n\t            }\n\t\t    if (data) {\n\t\t\tif (data_fake.flags & SF_HAS_EVAL)\n\t\t\t    data->flags |= SF_HAS_EVAL;\n\t\t\tdata->whilem_c = data_fake.whilem_c;\n\t\t    }\n\t\t    if (flags & SCF_DO_STCLASS)\n\t\t\tssc_or(pRExC_state, &accum, (regnode_charclass*)&this_class);\n\t\t}\n\t\tif (code == IFTHEN && num < 2) /* Empty ELSE branch */\n\t\t    min1 = 0;\n\t\tif (flags & SCF_DO_SUBSTR) {\n\t\t    data->pos_min += min1;\n\t\t    if (data->pos_delta >= SSize_t_MAX - (max1 - min1))\n\t\t        data->pos_delta = SSize_t_MAX;\n\t\t    else\n\t\t        data->pos_delta += max1 - min1;\n\t\t    if (max1 != min1 || is_inf)\n\t\t\tdata->cur_is_floating = 1;\n\t\t}\n\t\tmin += min1;\n\t\tif (delta == SSize_t_MAX\n\t\t || SSize_t_MAX - delta - (max1 - min1) < 0)\n\t\t    delta = SSize_t_MAX;\n\t\telse\n\t\t    delta += max1 - min1;\n\t\tif (flags & SCF_DO_STCLASS_OR) {\n\t\t    ssc_or(pRExC_state, data->start_class, (regnode_charclass*) &accum);\n\t\t    if (min1) {\n\t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\t\t\tflags &= ~SCF_DO_STCLASS;\n\t\t    }\n\t\t}\n\t\telse if (flags & SCF_DO_STCLASS_AND) {\n\t\t    if (min1) {\n\t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) &accum);\n\t\t\tflags &= ~SCF_DO_STCLASS;\n\t\t    }\n\t\t    else {\n\t\t\t/* Switch to OR mode: cache the old value of\n\t\t\t * data->start_class */\n\t\t\tINIT_AND_WITHP;\n\t\t\tStructCopy(data->start_class, and_withp, regnode_ssc);\n\t\t\tflags &= ~SCF_DO_STCLASS_AND;\n\t\t\tStructCopy(&accum, data->start_class, regnode_ssc);\n\t\t\tflags |= SCF_DO_STCLASS_OR;\n\t\t    }\n\t\t}\n\n                if (PERL_ENABLE_TRIE_OPTIMISATION &&\n                        OP( startbranch ) == BRANCH )\n                {\n\t\t/* demq.\n\n                   Assuming this was/is a branch we are dealing with: 'scan'\n                   now points at the item that follows the branch sequence,\n                   whatever it is. We now start at the beginning of the\n                   sequence and look for subsequences of\n\n\t\t   BRANCH->EXACT=>x1\n\t\t   BRANCH->EXACT=>x2\n\t\t   tail\n\n                   which would be constructed from a pattern like\n                   /A|LIST|OF|WORDS/\n\n\t\t   If we can find such a subsequence we need to turn the first\n\t\t   element into a trie and then add the subsequent branch exact\n\t\t   strings to the trie.\n\n\t\t   We have two cases\n\n                     1. patterns where the whole set of branches can be\n                        converted.\n\n\t\t     2. patterns where only a subset can be converted.\n\n\t\t   In case 1 we can replace the whole set with a single regop\n\t\t   for the trie. In case 2 we need to keep the start and end\n\t\t   branches so\n\n\t\t     'BRANCH EXACT; BRANCH EXACT; BRANCH X'\n\t\t     becomes BRANCH TRIE; BRANCH X;\n\n\t\t  There is an additional case, that being where there is a\n\t\t  common prefix, which gets split out into an EXACT like node\n\t\t  preceding the TRIE node.\n\n\t\t  If x(1..n)==tail then we can do a simple trie, if not we make\n\t\t  a \"jump\" trie, such that when we match the appropriate word\n\t\t  we \"jump\" to the appropriate tail node. Essentially we turn\n\t\t  a nested if into a case structure of sorts.\n\n\t\t*/\n\n\t\t    int made=0;\n\t\t    if (!re_trie_maxbuff) {\n\t\t\tre_trie_maxbuff = get_sv(RE_TRIE_MAXBUF_NAME, 1);\n\t\t\tif (!SvIOK(re_trie_maxbuff))\n\t\t\t    sv_setiv(re_trie_maxbuff, RE_TRIE_MAXBUF_INIT);\n\t\t    }\n                    if ( SvIV(re_trie_maxbuff)>=0  ) {\n                        regnode *cur;\n                        regnode *first = (regnode *)NULL;\n                        regnode *last = (regnode *)NULL;\n                        regnode *tail = scan;\n                        U8 trietype = 0;\n                        U32 count=0;\n\n                        /* var tail is used because there may be a TAIL\n                           regop in the way. Ie, the exacts will point to the\n                           thing following the TAIL, but the last branch will\n                           point at the TAIL. So we advance tail. If we\n                           have nested (?:) we may have to move through several\n                           tails.\n                         */\n\n                        while ( OP( tail ) == TAIL ) {\n                            /* this is the TAIL generated by (?:) */\n                            tail = regnext( tail );\n                        }\n\n\n                        DEBUG_TRIE_COMPILE_r({\n                            regprop(RExC_rx, RExC_mysv, tail, NULL, pRExC_state);\n                            Perl_re_indentf( aTHX_  \"%s %\" UVuf \":%s\\n\",\n                              depth+1,\n                              \"Looking for TRIE'able sequences. Tail node is \",\n                              (UV) REGNODE_OFFSET(tail),\n                              SvPV_nolen_const( RExC_mysv )\n                            );\n                        });\n\n                        /*\n\n                            Step through the branches\n                                cur represents each branch,\n                                noper is the first thing to be matched as part\n                                      of that branch\n                                noper_next is the regnext() of that node.\n\n                            We normally handle a case like this\n                            /FOO[xyz]|BAR[pqr]/ via a \"jump trie\" but we also\n                            support building with NOJUMPTRIE, which restricts\n                            the trie logic to structures like /FOO|BAR/.\n\n                            If noper is a trieable nodetype then the branch is\n                            a possible optimization target. If we are building\n                            under NOJUMPTRIE then we require that noper_next is\n                            the same as scan (our current position in the regex\n                            program).\n\n                            Once we have two or more consecutive such branches\n                            we can create a trie of the EXACT's contents and\n                            stitch it in place into the program.\n\n                            If the sequence represents all of the branches in\n                            the alternation we replace the entire thing with a\n                            single TRIE node.\n\n                            Otherwise when it is a subsequence we need to\n                            stitch it in place and replace only the relevant\n                            branches. This means the first branch has to remain\n                            as it is used by the alternation logic, and its\n                            next pointer, and needs to be repointed at the item\n                            on the branch chain following the last branch we\n                            have optimized away.\n\n                            This could be either a BRANCH, in which case the\n                            subsequence is internal, or it could be the item\n                            following the branch sequence in which case the\n                            subsequence is at the end (which does not\n                            necessarily mean the first node is the start of the\n                            alternation).\n\n                            TRIE_TYPE(X) is a define which maps the optype to a\n                            trietype.\n\n                                optype          |  trietype\n                                ----------------+-----------\n                                NOTHING         | NOTHING\n                                EXACT           | EXACT\n                                EXACT_ONLY8     | EXACT\n                                EXACTFU         | EXACTFU\n                                EXACTFU_ONLY8   | EXACTFU\n                                EXACTFUP        | EXACTFU\n                                EXACTFAA        | EXACTFAA\n                                EXACTL          | EXACTL\n                                EXACTFLU8       | EXACTFLU8\n\n\n                        */\n#define TRIE_TYPE(X) ( ( NOTHING == (X) )                                   \\\n                       ? NOTHING                                            \\\n                       : ( EXACT == (X) || EXACT_ONLY8 == (X) )             \\\n                         ? EXACT                                            \\\n                         : (     EXACTFU == (X)                             \\\n                              || EXACTFU_ONLY8 == (X)                       \\\n                              || EXACTFUP == (X) )                          \\\n                           ? EXACTFU                                        \\\n                           : ( EXACTFAA == (X) )                            \\\n                             ? EXACTFAA                                     \\\n                             : ( EXACTL == (X) )                            \\\n                               ? EXACTL                                     \\\n                               : ( EXACTFLU8 == (X) )                       \\\n                                 ? EXACTFLU8                                \\\n                                 : 0 )\n\n                        /* dont use tail as the end marker for this traverse */\n                        for ( cur = startbranch ; cur != scan ; cur = regnext( cur ) ) {\n                            regnode * const noper = NEXTOPER( cur );\n                            U8 noper_type = OP( noper );\n                            U8 noper_trietype = TRIE_TYPE( noper_type );\n#if defined(DEBUGGING) || defined(NOJUMPTRIE)\n                            regnode * const noper_next = regnext( noper );\n                            U8 noper_next_type = (noper_next && noper_next < tail) ? OP(noper_next) : 0;\n                            U8 noper_next_trietype = (noper_next && noper_next < tail) ? TRIE_TYPE( noper_next_type ) :0;\n#endif\n\n                            DEBUG_TRIE_COMPILE_r({\n                                regprop(RExC_rx, RExC_mysv, cur, NULL, pRExC_state);\n                                Perl_re_indentf( aTHX_  \"- %d:%s (%d)\",\n                                   depth+1,\n                                   REG_NODE_NUM(cur), SvPV_nolen_const( RExC_mysv ), REG_NODE_NUM(cur) );\n\n                                regprop(RExC_rx, RExC_mysv, noper, NULL, pRExC_state);\n                                Perl_re_printf( aTHX_  \" -> %d:%s\",\n                                    REG_NODE_NUM(noper), SvPV_nolen_const(RExC_mysv));\n\n                                if ( noper_next ) {\n                                  regprop(RExC_rx, RExC_mysv, noper_next, NULL, pRExC_state);\n                                  Perl_re_printf( aTHX_ \"\\t=> %d:%s\\t\",\n                                    REG_NODE_NUM(noper_next), SvPV_nolen_const(RExC_mysv));\n                                }\n                                Perl_re_printf( aTHX_  \"(First==%d,Last==%d,Cur==%d,tt==%s,ntt==%s,nntt==%s)\\n\",\n                                   REG_NODE_NUM(first), REG_NODE_NUM(last), REG_NODE_NUM(cur),\n\t\t\t\t   PL_reg_name[trietype], PL_reg_name[noper_trietype], PL_reg_name[noper_next_trietype]\n\t\t\t\t);\n                            });\n\n                            /* Is noper a trieable nodetype that can be merged\n                             * with the current trie (if there is one)? */\n                            if ( noper_trietype\n                                  &&\n                                  (\n                                        ( noper_trietype == NOTHING )\n                                        || ( trietype == NOTHING )\n                                        || ( trietype == noper_trietype )\n                                  )\n#ifdef NOJUMPTRIE\n                                  && noper_next >= tail\n#endif\n                                  && count < U16_MAX)\n                            {\n                                /* Handle mergable triable node Either we are\n                                 * the first node in a new trieable sequence,\n                                 * in which case we do some bookkeeping,\n                                 * otherwise we update the end pointer. */\n                                if ( !first ) {\n                                    first = cur;\n\t\t\t\t    if ( noper_trietype == NOTHING ) {\n#if !defined(DEBUGGING) && !defined(NOJUMPTRIE)\n\t\t\t\t\tregnode * const noper_next = regnext( noper );\n                                        U8 noper_next_type = (noper_next && noper_next < tail) ? OP(noper_next) : 0;\n\t\t\t\t\tU8 noper_next_trietype = noper_next_type ? TRIE_TYPE( noper_next_type ) :0;\n#endif\n\n                                        if ( noper_next_trietype ) {\n\t\t\t\t\t    trietype = noper_next_trietype;\n                                        } else if (noper_next_type)  {\n                                            /* a NOTHING regop is 1 regop wide.\n                                             * We need at least two for a trie\n                                             * so we can't merge this in */\n                                            first = NULL;\n                                        }\n                                    } else {\n                                        trietype = noper_trietype;\n                                    }\n                                } else {\n                                    if ( trietype == NOTHING )\n                                        trietype = noper_trietype;\n                                    last = cur;\n                                }\n\t\t\t\tif (first)\n\t\t\t\t    count++;\n                            } /* end handle mergable triable node */\n                            else {\n                                /* handle unmergable node -\n                                 * noper may either be a triable node which can\n                                 * not be tried together with the current trie,\n                                 * or a non triable node */\n                                if ( last ) {\n                                    /* If last is set and trietype is not\n                                     * NOTHING then we have found at least two\n                                     * triable branch sequences in a row of a\n                                     * similar trietype so we can turn them\n                                     * into a trie. If/when we allow NOTHING to\n                                     * start a trie sequence this condition\n                                     * will be required, and it isn't expensive\n                                     * so we leave it in for now. */\n                                    if ( trietype && trietype != NOTHING )\n                                        make_trie( pRExC_state,\n                                                startbranch, first, cur, tail,\n                                                count, trietype, depth+1 );\n                                    last = NULL; /* note: we clear/update\n                                                    first, trietype etc below,\n                                                    so we dont do it here */\n                                }\n                                if ( noper_trietype\n#ifdef NOJUMPTRIE\n                                     && noper_next >= tail\n#endif\n                                ){\n                                    /* noper is triable, so we can start a new\n                                     * trie sequence */\n                                    count = 1;\n                                    first = cur;\n                                    trietype = noper_trietype;\n                                } else if (first) {\n                                    /* if we already saw a first but the\n                                     * current node is not triable then we have\n                                     * to reset the first information. */\n                                    count = 0;\n                                    first = NULL;\n                                    trietype = 0;\n                                }\n                            } /* end handle unmergable node */\n                        } /* loop over branches */\n                        DEBUG_TRIE_COMPILE_r({\n                            regprop(RExC_rx, RExC_mysv, cur, NULL, pRExC_state);\n                            Perl_re_indentf( aTHX_  \"- %s (%d) <SCAN FINISHED> \",\n                              depth+1, SvPV_nolen_const( RExC_mysv ), REG_NODE_NUM(cur));\n                            Perl_re_printf( aTHX_  \"(First==%d, Last==%d, Cur==%d, tt==%s)\\n\",\n                               REG_NODE_NUM(first), REG_NODE_NUM(last), REG_NODE_NUM(cur),\n                               PL_reg_name[trietype]\n                            );\n\n                        });\n                        if ( last && trietype ) {\n                            if ( trietype != NOTHING ) {\n                                /* the last branch of the sequence was part of\n                                 * a trie, so we have to construct it here\n                                 * outside of the loop */\n                                made= make_trie( pRExC_state, startbranch,\n                                                 first, scan, tail, count,\n                                                 trietype, depth+1 );\n#ifdef TRIE_STUDY_OPT\n                                if ( ((made == MADE_EXACT_TRIE &&\n                                     startbranch == first)\n                                     || ( first_non_open == first )) &&\n                                     depth==0 ) {\n                                    flags |= SCF_TRIE_RESTUDY;\n                                    if ( startbranch == first\n                                         && scan >= tail )\n                                    {\n                                        RExC_seen &=~REG_TOP_LEVEL_BRANCHES_SEEN;\n                                    }\n                                }\n#endif\n                            } else {\n                                /* at this point we know whatever we have is a\n                                 * NOTHING sequence/branch AND if 'startbranch'\n                                 * is 'first' then we can turn the whole thing\n                                 * into a NOTHING\n                                 */\n                                if ( startbranch == first ) {\n                                    regnode *opt;\n                                    /* the entire thing is a NOTHING sequence,\n                                     * something like this: (?:|) So we can\n                                     * turn it into a plain NOTHING op. */\n                                    DEBUG_TRIE_COMPILE_r({\n                                        regprop(RExC_rx, RExC_mysv, cur, NULL, pRExC_state);\n                                        Perl_re_indentf( aTHX_  \"- %s (%d) <NOTHING BRANCH SEQUENCE>\\n\",\n                                          depth+1,\n                                          SvPV_nolen_const( RExC_mysv ), REG_NODE_NUM(cur));\n\n                                    });\n                                    OP(startbranch)= NOTHING;\n                                    NEXT_OFF(startbranch)= tail - startbranch;\n                                    for ( opt= startbranch + 1; opt < tail ; opt++ )\n                                        OP(opt)= OPTIMIZED;\n                                }\n                            }\n                        } /* end if ( last) */\n                    } /* TRIE_MAXBUF is non zero */\n\n                } /* do trie */\n\n\t    }\n\t    else if ( code == BRANCHJ ) {  /* single branch is optimized. */\n\t\tscan = NEXTOPER(NEXTOPER(scan));\n\t    } else\t\t\t/* single branch is optimized. */\n\t\tscan = NEXTOPER(scan);\n\t    continue;\n        } else if (OP(scan) == SUSPEND || OP(scan) == GOSUB) {\n            I32 paren = 0;\n            regnode *start = NULL;\n            regnode *end = NULL;\n            U32 my_recursed_depth= recursed_depth;\n\n            if (OP(scan) != SUSPEND) { /* GOSUB */\n                /* Do setup, note this code has side effects beyond\n                 * the rest of this block. Specifically setting\n                 * RExC_recurse[] must happen at least once during\n                 * study_chunk(). */\n                paren = ARG(scan);\n                RExC_recurse[ARG2L(scan)] = scan;\n                start = REGNODE_p(RExC_open_parens[paren]);\n                end   = REGNODE_p(RExC_close_parens[paren]);\n\n                /* NOTE we MUST always execute the above code, even\n                 * if we do nothing with a GOSUB */\n                if (\n                    ( flags & SCF_IN_DEFINE )\n                    ||\n                    (\n                        (is_inf_internal || is_inf || (data && data->flags & SF_IS_INF))\n                        &&\n                        ( (flags & (SCF_DO_STCLASS | SCF_DO_SUBSTR)) == 0 )\n                    )\n                ) {\n                    /* no need to do anything here if we are in a define. */\n                    /* or we are after some kind of infinite construct\n                     * so we can skip recursing into this item.\n                     * Since it is infinite we will not change the maxlen\n                     * or delta, and if we miss something that might raise\n                     * the minlen it will merely pessimise a little.\n                     *\n                     * Iow /(?(DEFINE)(?<foo>foo|food))a+(?&foo)/\n                     * might result in a minlen of 1 and not of 4,\n                     * but this doesn't make us mismatch, just try a bit\n                     * harder than we should.\n                     * */\n                    scan= regnext(scan);\n                    continue;\n                }\n\n                if (\n                    !recursed_depth\n                    ||\n                    !PAREN_TEST(RExC_study_chunk_recursed + ((recursed_depth-1) * RExC_study_chunk_recursed_bytes), paren)\n                ) {\n                    /* it is quite possible that there are more efficient ways\n                     * to do this. We maintain a bitmap per level of recursion\n                     * of which patterns we have entered so we can detect if a\n                     * pattern creates a possible infinite loop. When we\n                     * recurse down a level we copy the previous levels bitmap\n                     * down. When we are at recursion level 0 we zero the top\n                     * level bitmap. It would be nice to implement a different\n                     * more efficient way of doing this. In particular the top\n                     * level bitmap may be unnecessary.\n                     */\n                    if (!recursed_depth) {\n                        Zero(RExC_study_chunk_recursed, RExC_study_chunk_recursed_bytes, U8);\n                    } else {\n                        Copy(RExC_study_chunk_recursed + ((recursed_depth-1) * RExC_study_chunk_recursed_bytes),\n                             RExC_study_chunk_recursed + (recursed_depth * RExC_study_chunk_recursed_bytes),\n                             RExC_study_chunk_recursed_bytes, U8);\n                    }\n                    /* we havent recursed into this paren yet, so recurse into it */\n                    DEBUG_STUDYDATA(\"gosub-set\", data, depth, is_inf);\n                    PAREN_SET(RExC_study_chunk_recursed + (recursed_depth * RExC_study_chunk_recursed_bytes), paren);\n                    my_recursed_depth= recursed_depth + 1;\n                } else {\n                    DEBUG_STUDYDATA(\"gosub-inf\", data, depth, is_inf);\n                    /* some form of infinite recursion, assume infinite length\n                     * */\n                    if (flags & SCF_DO_SUBSTR) {\n                        scan_commit(pRExC_state, data, minlenp, is_inf);\n                        data->cur_is_floating = 1;\n                    }\n                    is_inf = is_inf_internal = 1;\n                    if (flags & SCF_DO_STCLASS_OR) /* Allow everything */\n                        ssc_anything(data->start_class);\n                    flags &= ~SCF_DO_STCLASS;\n\n                    start= NULL; /* reset start so we dont recurse later on. */\n\t        }\n            } else {\n\t        paren = stopparen;\n                start = scan + 2;\n\t        end = regnext(scan);\n\t    }\n            if (start) {\n                scan_frame *newframe;\n                assert(end);\n                if (!RExC_frame_last) {\n                    Newxz(newframe, 1, scan_frame);\n                    SAVEDESTRUCTOR_X(S_unwind_scan_frames, newframe);\n                    RExC_frame_head= newframe;\n                    RExC_frame_count++;\n                } else if (!RExC_frame_last->next_frame) {\n                    Newxz(newframe, 1, scan_frame);\n                    RExC_frame_last->next_frame= newframe;\n                    newframe->prev_frame= RExC_frame_last;\n                    RExC_frame_count++;\n                } else {\n                    newframe= RExC_frame_last->next_frame;\n                }\n                RExC_frame_last= newframe;\n\n                newframe->next_regnode = regnext(scan);\n                newframe->last_regnode = last;\n                newframe->stopparen = stopparen;\n                newframe->prev_recursed_depth = recursed_depth;\n                newframe->this_prev_frame= frame;\n\n                DEBUG_STUDYDATA(\"frame-new\", data, depth, is_inf);\n                DEBUG_PEEP(\"fnew\", scan, depth, flags);\n\n\t        frame = newframe;\n\t        scan =  start;\n\t        stopparen = paren;\n\t        last = end;\n                depth = depth + 1;\n                recursed_depth= my_recursed_depth;\n\n\t        continue;\n\t    }\n\t}\n\telse if (   OP(scan) == EXACT\n                 || OP(scan) == EXACT_ONLY8\n                 || OP(scan) == EXACTL)\n        {\n\t    SSize_t l = STR_LEN(scan);\n\t    UV uc;\n            assert(l);\n\t    if (UTF) {\n\t\tconst U8 * const s = (U8*)STRING(scan);\n\t\tuc = utf8_to_uvchr_buf(s, s + l, NULL);\n\t\tl = utf8_length(s, s + l);\n\t    } else {\n\t\tuc = *((U8*)STRING(scan));\n\t    }\n\t    min += l;\n\t    if (flags & SCF_DO_SUBSTR) { /* Update longest substr. */\n\t\t/* The code below prefers earlier match for fixed\n\t\t   offset, later match for variable offset.  */\n\t\tif (data->last_end == -1) { /* Update the start info. */\n\t\t    data->last_start_min = data->pos_min;\n \t\t    data->last_start_max = is_inf\n \t\t\t? SSize_t_MAX : data->pos_min + data->pos_delta;\n\t\t}\n\t\tsv_catpvn(data->last_found, STRING(scan), STR_LEN(scan));\n\t\tif (UTF)\n\t\t    SvUTF8_on(data->last_found);\n\t\t{\n\t\t    SV * const sv = data->last_found;\n\t\t    MAGIC * const mg = SvUTF8(sv) && SvMAGICAL(sv) ?\n\t\t\tmg_find(sv, PERL_MAGIC_utf8) : NULL;\n\t\t    if (mg && mg->mg_len >= 0)\n\t\t\tmg->mg_len += utf8_length((U8*)STRING(scan),\n                                              (U8*)STRING(scan)+STR_LEN(scan));\n\t\t}\n\t\tdata->last_end = data->pos_min + l;\n\t\tdata->pos_min += l; /* As in the first entry. */\n\t\tdata->flags &= ~SF_BEFORE_EOL;\n\t    }\n\n            /* ANDing the code point leaves at most it, and not in locale, and\n             * can't match null string */\n\t    if (flags & SCF_DO_STCLASS_AND) {\n                ssc_cp_and(data->start_class, uc);\n                ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n                ssc_clear_locale(data->start_class);\n\t    }\n\t    else if (flags & SCF_DO_STCLASS_OR) {\n                ssc_add_cp(data->start_class, uc);\n\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\n                /* See commit msg 749e076fceedeb708a624933726e7989f2302f6a */\n                ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n\t    }\n\t    flags &= ~SCF_DO_STCLASS;\n\t}\n        else if (PL_regkind[OP(scan)] == EXACT) {\n            /* But OP != EXACT!, so is EXACTFish */\n\t    SSize_t l = STR_LEN(scan);\n            const U8 * s = (U8*)STRING(scan);\n\n\t    /* Search for fixed substrings supports EXACT only. */\n\t    if (flags & SCF_DO_SUBSTR) {\n\t\tassert(data);\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n\t    }\n\t    if (UTF) {\n\t\tl = utf8_length(s, s + l);\n\t    }\n\t    if (unfolded_multi_char) {\n                RExC_seen |= REG_UNFOLDED_MULTI_SEEN;\n\t    }\n\t    min += l - min_subtract;\n            assert (min >= 0);\n            delta += min_subtract;\n\t    if (flags & SCF_DO_SUBSTR) {\n\t\tdata->pos_min += l - min_subtract;\n\t\tif (data->pos_min < 0) {\n                    data->pos_min = 0;\n                }\n                data->pos_delta += min_subtract;\n\t\tif (min_subtract) {\n\t\t    data->cur_is_floating = 1; /* float */\n\t\t}\n\t    }\n\n            if (flags & SCF_DO_STCLASS) {\n                SV* EXACTF_invlist = _make_exactf_invlist(pRExC_state, scan);\n\n                assert(EXACTF_invlist);\n                if (flags & SCF_DO_STCLASS_AND) {\n                    if (OP(scan) != EXACTFL)\n                        ssc_clear_locale(data->start_class);\n                    ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n                    ANYOF_POSIXL_ZERO(data->start_class);\n                    ssc_intersection(data->start_class, EXACTF_invlist, FALSE);\n                }\n                else {  /* SCF_DO_STCLASS_OR */\n                    ssc_union(data->start_class, EXACTF_invlist, FALSE);\n                    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\n                    /* See commit msg 749e076fceedeb708a624933726e7989f2302f6a */\n                    ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n                }\n                flags &= ~SCF_DO_STCLASS;\n                SvREFCNT_dec(EXACTF_invlist);\n            }\n\t}\n\telse if (REGNODE_VARIES(OP(scan))) {\n\t    SSize_t mincount, maxcount, minnext, deltanext, pos_before = 0;\n\t    I32 fl = 0, f = flags;\n\t    regnode * const oscan = scan;\n\t    regnode_ssc this_class;\n\t    regnode_ssc *oclass = NULL;\n\t    I32 next_is_eval = 0;\n\n\t    switch (PL_regkind[OP(scan)]) {\n\t    case WHILEM:\t\t/* End of (?:...)* . */\n\t\tscan = NEXTOPER(scan);\n\t\tgoto finish;\n\t    case PLUS:\n\t\tif (flags & (SCF_DO_SUBSTR | SCF_DO_STCLASS)) {\n\t\t    next = NEXTOPER(scan);\n\t\t    if (   OP(next) == EXACT\n                        || OP(next) == EXACT_ONLY8\n                        || OP(next) == EXACTL\n                        || (flags & SCF_DO_STCLASS))\n                    {\n\t\t\tmincount = 1;\n\t\t\tmaxcount = REG_INFTY;\n\t\t\tnext = regnext(scan);\n\t\t\tscan = NEXTOPER(scan);\n\t\t\tgoto do_curly;\n\t\t    }\n\t\t}\n\t\tif (flags & SCF_DO_SUBSTR)\n\t\t    data->pos_min++;\n\t\tmin++;\n\t\t/* FALLTHROUGH */\n\t    case STAR:\n                next = NEXTOPER(scan);\n\n                /* This temporary node can now be turned into EXACTFU, and\n                 * must, as regexec.c doesn't handle it */\n                if (OP(next) == EXACTFU_S_EDGE) {\n                    OP(next) = EXACTFU;\n                }\n\n                if (     STR_LEN(next) == 1\n                    &&   isALPHA_A(* STRING(next))\n                    && (         OP(next) == EXACTFAA\n                        || (     OP(next) == EXACTFU\n                            && ! HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE(* STRING(next)))))\n                {\n                    /* These differ in just one bit */\n                    U8 mask = ~ ('A' ^ 'a');\n\n                    assert(isALPHA_A(* STRING(next)));\n\n                    /* Then replace it by an ANYOFM node, with\n                    * the mask set to the complement of the\n                    * bit that differs between upper and lower\n                    * case, and the lowest code point of the\n                    * pair (which the '&' forces) */\n                    OP(next) = ANYOFM;\n                    ARG_SET(next, *STRING(next) & mask);\n                    FLAGS(next) = mask;\n                }\n\n\t\tif (flags & SCF_DO_STCLASS) {\n\t\t    mincount = 0;\n\t\t    maxcount = REG_INFTY;\n\t\t    next = regnext(scan);\n\t\t    scan = NEXTOPER(scan);\n\t\t    goto do_curly;\n\t\t}\n\t\tif (flags & SCF_DO_SUBSTR) {\n                    scan_commit(pRExC_state, data, minlenp, is_inf);\n                    /* Cannot extend fixed substrings */\n\t\t    data->cur_is_floating = 1; /* float */\n\t\t}\n                is_inf = is_inf_internal = 1;\n                scan = regnext(scan);\n\t\tgoto optimize_curly_tail;\n\t    case CURLY:\n\t        if (stopparen>0 && (OP(scan)==CURLYN || OP(scan)==CURLYM)\n\t            && (scan->flags == stopparen))\n\t\t{\n\t\t    mincount = 1;\n\t\t    maxcount = 1;\n\t\t} else {\n\t\t    mincount = ARG1(scan);\n\t\t    maxcount = ARG2(scan);\n\t\t}\n\t\tnext = regnext(scan);\n\t\tif (OP(scan) == CURLYX) {\n\t\t    I32 lp = (data ? *(data->last_closep) : 0);\n\t\t    scan->flags = ((lp <= (I32)U8_MAX) ? (U8)lp : U8_MAX);\n\t\t}\n\t\tscan = NEXTOPER(scan) + EXTRA_STEP_2ARGS;\n\t\tnext_is_eval = (OP(scan) == EVAL);\n\t      do_curly:\n\t\tif (flags & SCF_DO_SUBSTR) {\n                    if (mincount == 0)\n                        scan_commit(pRExC_state, data, minlenp, is_inf);\n                    /* Cannot extend fixed substrings */\n\t\t    pos_before = data->pos_min;\n\t\t}\n\t\tif (data) {\n\t\t    fl = data->flags;\n\t\t    data->flags &= ~(SF_HAS_PAR|SF_IN_PAR|SF_HAS_EVAL);\n\t\t    if (is_inf)\n\t\t\tdata->flags |= SF_IS_INF;\n\t\t}\n\t\tif (flags & SCF_DO_STCLASS) {\n\t\t    ssc_init(pRExC_state, &this_class);\n\t\t    oclass = data->start_class;\n\t\t    data->start_class = &this_class;\n\t\t    f |= SCF_DO_STCLASS_AND;\n\t\t    f &= ~SCF_DO_STCLASS_OR;\n\t\t}\n\t        /* Exclude from super-linear cache processing any {n,m}\n\t\t   regops for which the combination of input pos and regex\n\t\t   pos is not enough information to determine if a match\n\t\t   will be possible.\n\n\t\t   For example, in the regex /foo(bar\\s*){4,8}baz/ with the\n\t\t   regex pos at the \\s*, the prospects for a match depend not\n\t\t   only on the input position but also on how many (bar\\s*)\n\t\t   repeats into the {4,8} we are. */\n               if ((mincount > 1) || (maxcount > 1 && maxcount != REG_INFTY))\n\t\t    f &= ~SCF_WHILEM_VISITED_POS;\n\n\t\t/* This will finish on WHILEM, setting scan, or on NULL: */\n                /* recurse study_chunk() on loop bodies */\n\t\tminnext = study_chunk(pRExC_state, &scan, minlenp, &deltanext,\n                                  last, data, stopparen, recursed_depth, NULL,\n                                  (mincount == 0\n                                   ? (f & ~SCF_DO_SUBSTR)\n                                   : f)\n                                  ,depth+1);\n\n\t\tif (flags & SCF_DO_STCLASS)\n\t\t    data->start_class = oclass;\n\t\tif (mincount == 0 || minnext == 0) {\n\t\t    if (flags & SCF_DO_STCLASS_OR) {\n\t\t\tssc_or(pRExC_state, data->start_class, (regnode_charclass *) &this_class);\n\t\t    }\n\t\t    else if (flags & SCF_DO_STCLASS_AND) {\n\t\t\t/* Switch to OR mode: cache the old value of\n\t\t\t * data->start_class */\n\t\t\tINIT_AND_WITHP;\n\t\t\tStructCopy(data->start_class, and_withp, regnode_ssc);\n\t\t\tflags &= ~SCF_DO_STCLASS_AND;\n\t\t\tStructCopy(&this_class, data->start_class, regnode_ssc);\n\t\t\tflags |= SCF_DO_STCLASS_OR;\n                        ANYOF_FLAGS(data->start_class)\n                                                |= SSC_MATCHES_EMPTY_STRING;\n\t\t    }\n\t\t} else {\t\t/* Non-zero len */\n\t\t    if (flags & SCF_DO_STCLASS_OR) {\n\t\t\tssc_or(pRExC_state, data->start_class, (regnode_charclass *) &this_class);\n\t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\t\t    }\n\t\t    else if (flags & SCF_DO_STCLASS_AND)\n\t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) &this_class);\n\t\t    flags &= ~SCF_DO_STCLASS;\n\t\t}\n\t\tif (!scan) \t\t/* It was not CURLYX, but CURLY. */\n\t\t    scan = next;\n\t\tif (((flags & (SCF_TRIE_DOING_RESTUDY|SCF_DO_SUBSTR))==SCF_DO_SUBSTR)\n\t\t    /* ? quantifier ok, except for (?{ ... }) */\n\t\t    && (next_is_eval || !(mincount == 0 && maxcount == 1))\n\t\t    && (minnext == 0) && (deltanext == 0)\n\t\t    && data && !(data->flags & (SF_HAS_PAR|SF_IN_PAR))\n                    && maxcount <= REG_INFTY/3) /* Complement check for big\n                                                   count */\n\t\t{\n\t\t    _WARN_HELPER(RExC_precomp_end, packWARN(WARN_REGEXP),\n                        Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP),\n                            \"Quantifier unexpected on zero-length expression \"\n                            \"in regex m/%\" UTF8f \"/\",\n\t\t\t     UTF8fARG(UTF, RExC_precomp_end - RExC_precomp,\n\t\t\t\t  RExC_precomp)));\n                }\n\n\t\tmin += minnext * mincount;\n\t\tis_inf_internal |= deltanext == SSize_t_MAX\n                         || (maxcount == REG_INFTY && minnext + deltanext > 0);\n\t\tis_inf |= is_inf_internal;\n                if (is_inf) {\n\t\t    delta = SSize_t_MAX;\n                } else {\n\t\t    delta += (minnext + deltanext) * maxcount\n                             - minnext * mincount;\n                }\n\t\t/* Try powerful optimization CURLYX => CURLYN. */\n\t\tif (  OP(oscan) == CURLYX && data\n\t\t      && data->flags & SF_IN_PAR\n\t\t      && !(data->flags & SF_HAS_EVAL)\n\t\t      && !deltanext && minnext == 1 ) {\n\t\t    /* Try to optimize to CURLYN.  */\n\t\t    regnode *nxt = NEXTOPER(oscan) + EXTRA_STEP_2ARGS;\n\t\t    regnode * const nxt1 = nxt;\n#ifdef DEBUGGING\n\t\t    regnode *nxt2;\n#endif\n\n\t\t    /* Skip open. */\n\t\t    nxt = regnext(nxt);\n\t\t    if (!REGNODE_SIMPLE(OP(nxt))\n\t\t\t&& !(PL_regkind[OP(nxt)] == EXACT\n\t\t\t     && STR_LEN(nxt) == 1))\n\t\t\tgoto nogo;\n#ifdef DEBUGGING\n\t\t    nxt2 = nxt;\n#endif\n\t\t    nxt = regnext(nxt);\n\t\t    if (OP(nxt) != CLOSE)\n\t\t\tgoto nogo;\n\t\t    if (RExC_open_parens) {\n\n                        /*open->CURLYM*/\n                        RExC_open_parens[ARG(nxt1)] = REGNODE_OFFSET(oscan);\n\n                        /*close->while*/\n                        RExC_close_parens[ARG(nxt1)] = REGNODE_OFFSET(nxt) + 2;\n\t\t    }\n\t\t    /* Now we know that nxt2 is the only contents: */\n\t\t    oscan->flags = (U8)ARG(nxt);\n\t\t    OP(oscan) = CURLYN;\n\t\t    OP(nxt1) = NOTHING;\t/* was OPEN. */\n\n#ifdef DEBUGGING\n\t\t    OP(nxt1 + 1) = OPTIMIZED; /* was count. */\n\t\t    NEXT_OFF(nxt1+ 1) = 0; /* just for consistency. */\n\t\t    NEXT_OFF(nxt2) = 0;\t/* just for consistency with CURLY. */\n\t\t    OP(nxt) = OPTIMIZED;\t/* was CLOSE. */\n\t\t    OP(nxt + 1) = OPTIMIZED; /* was count. */\n\t\t    NEXT_OFF(nxt+ 1) = 0; /* just for consistency. */\n#endif\n\t\t}\n\t      nogo:\n\n\t\t/* Try optimization CURLYX => CURLYM. */\n\t\tif (  OP(oscan) == CURLYX && data\n\t\t      && !(data->flags & SF_HAS_PAR)\n\t\t      && !(data->flags & SF_HAS_EVAL)\n\t\t      && !deltanext\t/* atom is fixed width */\n\t\t      && minnext != 0\t/* CURLYM can't handle zero width */\n\n                         /* Nor characters whose fold at run-time may be\n                          * multi-character */\n                      && ! (RExC_seen & REG_UNFOLDED_MULTI_SEEN)\n\t\t) {\n\t\t    /* XXXX How to optimize if data == 0? */\n\t\t    /* Optimize to a simpler form.  */\n\t\t    regnode *nxt = NEXTOPER(oscan) + EXTRA_STEP_2ARGS; /* OPEN */\n\t\t    regnode *nxt2;\n\n\t\t    OP(oscan) = CURLYM;\n\t\t    while ( (nxt2 = regnext(nxt)) /* skip over embedded stuff*/\n\t\t\t    && (OP(nxt2) != WHILEM))\n\t\t\tnxt = nxt2;\n\t\t    OP(nxt2)  = SUCCEED; /* Whas WHILEM */\n\t\t    /* Need to optimize away parenths. */\n\t\t    if ((data->flags & SF_IN_PAR) && OP(nxt) == CLOSE) {\n\t\t\t/* Set the parenth number.  */\n\t\t\tregnode *nxt1 = NEXTOPER(oscan) + EXTRA_STEP_2ARGS; /* OPEN*/\n\n\t\t\toscan->flags = (U8)ARG(nxt);\n\t\t\tif (RExC_open_parens) {\n                             /*open->CURLYM*/\n                            RExC_open_parens[ARG(nxt1)] = REGNODE_OFFSET(oscan);\n\n                            /*close->NOTHING*/\n                            RExC_close_parens[ARG(nxt1)] = REGNODE_OFFSET(nxt2)\n                                                         + 1;\n\t\t\t}\n\t\t\tOP(nxt1) = OPTIMIZED;\t/* was OPEN. */\n\t\t\tOP(nxt) = OPTIMIZED;\t/* was CLOSE. */\n\n#ifdef DEBUGGING\n\t\t\tOP(nxt1 + 1) = OPTIMIZED; /* was count. */\n\t\t\tOP(nxt + 1) = OPTIMIZED; /* was count. */\n\t\t\tNEXT_OFF(nxt1 + 1) = 0; /* just for consistency. */\n\t\t\tNEXT_OFF(nxt + 1) = 0; /* just for consistency. */\n#endif\n#if 0\n\t\t\twhile ( nxt1 && (OP(nxt1) != WHILEM)) {\n\t\t\t    regnode *nnxt = regnext(nxt1);\n\t\t\t    if (nnxt == nxt) {\n\t\t\t\tif (reg_off_by_arg[OP(nxt1)])\n\t\t\t\t    ARG_SET(nxt1, nxt2 - nxt1);\n\t\t\t\telse if (nxt2 - nxt1 < U16_MAX)\n\t\t\t\t    NEXT_OFF(nxt1) = nxt2 - nxt1;\n\t\t\t\telse\n\t\t\t\t    OP(nxt) = NOTHING;\t/* Cannot beautify */\n\t\t\t    }\n\t\t\t    nxt1 = nnxt;\n\t\t\t}\n#endif\n\t\t\t/* Optimize again: */\n                        /* recurse study_chunk() on optimised CURLYX => CURLYM */\n\t\t\tstudy_chunk(pRExC_state, &nxt1, minlenp, &deltanext, nxt,\n                                    NULL, stopparen, recursed_depth, NULL, 0,\n                                    depth+1);\n\t\t    }\n\t\t    else\n\t\t\toscan->flags = 0;\n\t\t}\n\t\telse if ((OP(oscan) == CURLYX)\n\t\t\t && (flags & SCF_WHILEM_VISITED_POS)\n\t\t\t /* See the comment on a similar expression above.\n\t\t\t    However, this time it's not a subexpression\n\t\t\t    we care about, but the expression itself. */\n\t\t\t && (maxcount == REG_INFTY)\n\t\t\t && data) {\n\t\t    /* This stays as CURLYX, we can put the count/of pair. */\n\t\t    /* Find WHILEM (as in regexec.c) */\n\t\t    regnode *nxt = oscan + NEXT_OFF(oscan);\n\n\t\t    if (OP(PREVOPER(nxt)) == NOTHING) /* LONGJMP */\n\t\t\tnxt += ARG(nxt);\n                    nxt = PREVOPER(nxt);\n                    if (nxt->flags & 0xf) {\n                        /* we've already set whilem count on this node */\n                    } else if (++data->whilem_c < 16) {\n                        assert(data->whilem_c <= RExC_whilem_seen);\n                        nxt->flags = (U8)(data->whilem_c\n                            | (RExC_whilem_seen << 4)); /* On WHILEM */\n                    }\n\t\t}\n\t\tif (data && fl & (SF_HAS_PAR|SF_IN_PAR))\n\t\t    pars++;\n\t\tif (flags & SCF_DO_SUBSTR) {\n\t\t    SV *last_str = NULL;\n                    STRLEN last_chrs = 0;\n\t\t    int counted = mincount != 0;\n\n                    if (data->last_end > 0 && mincount != 0) { /* Ends with a\n                                                                  string. */\n\t\t\tSSize_t b = pos_before >= data->last_start_min\n\t\t\t    ? pos_before : data->last_start_min;\n\t\t\tSTRLEN l;\n\t\t\tconst char * const s = SvPV_const(data->last_found, l);\n\t\t\tSSize_t old = b - data->last_start_min;\n                        assert(old >= 0);\n\n\t\t\tif (UTF)\n\t\t\t    old = utf8_hop_forward((U8*)s, old,\n                                               (U8 *) SvEND(data->last_found))\n                                - (U8*)s;\n\t\t\tl -= old;\n\t\t\t/* Get the added string: */\n\t\t\tlast_str = newSVpvn_utf8(s  + old, l, UTF);\n                        last_chrs = UTF ? utf8_length((U8*)(s + old),\n                                            (U8*)(s + old + l)) : l;\n\t\t\tif (deltanext == 0 && pos_before == b) {\n\t\t\t    /* What was added is a constant string */\n\t\t\t    if (mincount > 1) {\n\n\t\t\t\tSvGROW(last_str, (mincount * l) + 1);\n\t\t\t\trepeatcpy(SvPVX(last_str) + l,\n\t\t\t\t\t  SvPVX_const(last_str), l,\n                                          mincount - 1);\n\t\t\t\tSvCUR_set(last_str, SvCUR(last_str) * mincount);\n\t\t\t\t/* Add additional parts. */\n\t\t\t\tSvCUR_set(data->last_found,\n\t\t\t\t\t  SvCUR(data->last_found) - l);\n\t\t\t\tsv_catsv(data->last_found, last_str);\n\t\t\t\t{\n\t\t\t\t    SV * sv = data->last_found;\n\t\t\t\t    MAGIC *mg =\n\t\t\t\t\tSvUTF8(sv) && SvMAGICAL(sv) ?\n\t\t\t\t\tmg_find(sv, PERL_MAGIC_utf8) : NULL;\n\t\t\t\t    if (mg && mg->mg_len >= 0)\n\t\t\t\t\tmg->mg_len += last_chrs * (mincount-1);\n\t\t\t\t}\n                                last_chrs *= mincount;\n\t\t\t\tdata->last_end += l * (mincount - 1);\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    /* start offset must point into the last copy */\n\t\t\t    data->last_start_min += minnext * (mincount - 1);\n\t\t\t    data->last_start_max =\n                              is_inf\n                               ? SSize_t_MAX\n\t\t\t       : data->last_start_max +\n                                 (maxcount - 1) * (minnext + data->pos_delta);\n\t\t\t}\n\t\t    }\n\t\t    /* It is counted once already... */\n\t\t    data->pos_min += minnext * (mincount - counted);\n#if 0\nPerl_re_printf( aTHX_  \"counted=%\" UVuf \" deltanext=%\" UVuf\n                              \" SSize_t_MAX=%\" UVuf \" minnext=%\" UVuf\n                              \" maxcount=%\" UVuf \" mincount=%\" UVuf \"\\n\",\n    (UV)counted, (UV)deltanext, (UV)SSize_t_MAX, (UV)minnext, (UV)maxcount,\n    (UV)mincount);\nif (deltanext != SSize_t_MAX)\nPerl_re_printf( aTHX_  \"LHS=%\" UVuf \" RHS=%\" UVuf \"\\n\",\n    (UV)(-counted * deltanext + (minnext + deltanext) * maxcount\n          - minnext * mincount), (UV)(SSize_t_MAX - data->pos_delta));\n#endif\n\t\t    if (deltanext == SSize_t_MAX\n                        || -counted * deltanext + (minnext + deltanext) * maxcount - minnext * mincount >= SSize_t_MAX - data->pos_delta)\n\t\t        data->pos_delta = SSize_t_MAX;\n\t\t    else\n\t\t        data->pos_delta += - counted * deltanext +\n\t\t\t(minnext + deltanext) * maxcount - minnext * mincount;\n\t\t    if (mincount != maxcount) {\n\t\t\t /* Cannot extend fixed substrings found inside\n\t\t\t    the group.  */\n                        scan_commit(pRExC_state, data, minlenp, is_inf);\n\t\t\tif (mincount && last_str) {\n\t\t\t    SV * const sv = data->last_found;\n\t\t\t    MAGIC * const mg = SvUTF8(sv) && SvMAGICAL(sv) ?\n\t\t\t\tmg_find(sv, PERL_MAGIC_utf8) : NULL;\n\n\t\t\t    if (mg)\n\t\t\t\tmg->mg_len = -1;\n\t\t\t    sv_setsv(sv, last_str);\n\t\t\t    data->last_end = data->pos_min;\n\t\t\t    data->last_start_min = data->pos_min - last_chrs;\n\t\t\t    data->last_start_max = is_inf\n\t\t\t\t? SSize_t_MAX\n\t\t\t\t: data->pos_min + data->pos_delta - last_chrs;\n\t\t\t}\n\t\t\tdata->cur_is_floating = 1; /* float */\n\t\t    }\n\t\t    SvREFCNT_dec(last_str);\n\t\t}\n\t\tif (data && (fl & SF_HAS_EVAL))\n\t\t    data->flags |= SF_HAS_EVAL;\n\t      optimize_curly_tail:\n\t\tif (OP(oscan) != CURLYX) {\n\t\t    while (PL_regkind[OP(next = regnext(oscan))] == NOTHING\n\t\t\t   && NEXT_OFF(next))\n\t\t\tNEXT_OFF(oscan) += NEXT_OFF(next);\n\t\t}\n\t\tcontinue;\n\n\t    default:\n#ifdef DEBUGGING\n                Perl_croak(aTHX_ \"panic: unexpected varying REx opcode %d\",\n                                                                    OP(scan));\n#endif\n            case REF:\n            case CLUMP:\n\t\tif (flags & SCF_DO_SUBSTR) {\n                    /* Cannot expect anything... */\n                    scan_commit(pRExC_state, data, minlenp, is_inf);\n\t\t    data->cur_is_floating = 1; /* float */\n\t\t}\n\t\tis_inf = is_inf_internal = 1;\n\t\tif (flags & SCF_DO_STCLASS_OR) {\n                    if (OP(scan) == CLUMP) {\n                        /* Actually is any start char, but very few code points\n                         * aren't start characters */\n                        ssc_match_all_cp(data->start_class);\n                    }\n                    else {\n                        ssc_anything(data->start_class);\n                    }\n                }\n\t\tflags &= ~SCF_DO_STCLASS;\n\t\tbreak;\n\t    }\n\t}\n\telse if (OP(scan) == LNBREAK) {\n\t    if (flags & SCF_DO_STCLASS) {\n    \t        if (flags & SCF_DO_STCLASS_AND) {\n                    ssc_intersection(data->start_class,\n                                    PL_XPosix_ptrs[_CC_VERTSPACE], FALSE);\n                    ssc_clear_locale(data->start_class);\n                    ANYOF_FLAGS(data->start_class)\n                                                &= ~SSC_MATCHES_EMPTY_STRING;\n                }\n                else if (flags & SCF_DO_STCLASS_OR) {\n                    ssc_union(data->start_class,\n                              PL_XPosix_ptrs[_CC_VERTSPACE],\n                              FALSE);\n\t\t    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\n                    /* See commit msg for\n                     * 749e076fceedeb708a624933726e7989f2302f6a */\n                    ANYOF_FLAGS(data->start_class)\n                                                &= ~SSC_MATCHES_EMPTY_STRING;\n                }\n\t\tflags &= ~SCF_DO_STCLASS;\n            }\n\t    min++;\n            if (delta != SSize_t_MAX)\n                delta++;    /* Because of the 2 char string cr-lf */\n            if (flags & SCF_DO_SUBSTR) {\n                /* Cannot expect anything... */\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n    \t        data->pos_min += 1;\n                if (data->pos_delta != SSize_t_MAX) {\n                    data->pos_delta += 1;\n                }\n\t\tdata->cur_is_floating = 1; /* float */\n    \t    }\n\t}\n\telse if (REGNODE_SIMPLE(OP(scan))) {\n\n\t    if (flags & SCF_DO_SUBSTR) {\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n\t\tdata->pos_min++;\n\t    }\n\t    min++;\n\t    if (flags & SCF_DO_STCLASS) {\n                bool invert = 0;\n                SV* my_invlist = NULL;\n                U8 namedclass;\n\n                /* See commit msg 749e076fceedeb708a624933726e7989f2302f6a */\n                ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n\n\t\t/* Some of the logic below assumes that switching\n\t\t   locale on will only add false positives. */\n\t\tswitch (OP(scan)) {\n\n\t\tdefault:\n#ifdef DEBUGGING\n                   Perl_croak(aTHX_ \"panic: unexpected simple REx opcode %d\",\n                                                                     OP(scan));\n#endif\n\t\tcase SANY:\n\t\t    if (flags & SCF_DO_STCLASS_OR) /* Allow everything */\n\t\t\tssc_match_all_cp(data->start_class);\n\t\t    break;\n\n\t\tcase REG_ANY:\n                    {\n                        SV* REG_ANY_invlist = _new_invlist(2);\n                        REG_ANY_invlist = add_cp_to_invlist(REG_ANY_invlist,\n                                                            '\\n');\n                        if (flags & SCF_DO_STCLASS_OR) {\n                            ssc_union(data->start_class,\n                                      REG_ANY_invlist,\n                                      TRUE /* TRUE => invert, hence all but \\n\n                                            */\n                                      );\n                        }\n                        else if (flags & SCF_DO_STCLASS_AND) {\n                            ssc_intersection(data->start_class,\n                                             REG_ANY_invlist,\n                                             TRUE  /* TRUE => invert */\n                                             );\n                            ssc_clear_locale(data->start_class);\n                        }\n                        SvREFCNT_dec_NN(REG_ANY_invlist);\n\t\t    }\n\t\t    break;\n\n                case ANYOFD:\n                case ANYOFL:\n                case ANYOFPOSIXL:\n                case ANYOFH:\n                case ANYOF:\n\t\t    if (flags & SCF_DO_STCLASS_AND)\n\t\t\tssc_and(pRExC_state, data->start_class,\n                                (regnode_charclass *) scan);\n\t\t    else\n\t\t\tssc_or(pRExC_state, data->start_class,\n                                                          (regnode_charclass *) scan);\n\t\t    break;\n\n                case NANYOFM:\n                case ANYOFM:\n                  {\n                    SV* cp_list = get_ANYOFM_contents(scan);\n\n                    if (flags & SCF_DO_STCLASS_OR) {\n                        ssc_union(data->start_class, cp_list, invert);\n                    }\n                    else if (flags & SCF_DO_STCLASS_AND) {\n                        ssc_intersection(data->start_class, cp_list, invert);\n                    }\n\n                    SvREFCNT_dec_NN(cp_list);\n                    break;\n                  }\n\n\t\tcase NPOSIXL:\n                    invert = 1;\n                    /* FALLTHROUGH */\n\n\t\tcase POSIXL:\n                    namedclass = classnum_to_namedclass(FLAGS(scan)) + invert;\n                    if (flags & SCF_DO_STCLASS_AND) {\n                        bool was_there = cBOOL(\n                                          ANYOF_POSIXL_TEST(data->start_class,\n                                                                 namedclass));\n                        ANYOF_POSIXL_ZERO(data->start_class);\n                        if (was_there) {    /* Do an AND */\n                            ANYOF_POSIXL_SET(data->start_class, namedclass);\n                        }\n                        /* No individual code points can now match */\n                        data->start_class->invlist\n                                                = sv_2mortal(_new_invlist(0));\n                    }\n                    else {\n                        int complement = namedclass + ((invert) ? -1 : 1);\n\n                        assert(flags & SCF_DO_STCLASS_OR);\n\n                        /* If the complement of this class was already there,\n                         * the result is that they match all code points,\n                         * (\\d + \\D == everything).  Remove the classes from\n                         * future consideration.  Locale is not relevant in\n                         * this case */\n                        if (ANYOF_POSIXL_TEST(data->start_class, complement)) {\n                            ssc_match_all_cp(data->start_class);\n                            ANYOF_POSIXL_CLEAR(data->start_class, namedclass);\n                            ANYOF_POSIXL_CLEAR(data->start_class, complement);\n                        }\n                        else {  /* The usual case; just add this class to the\n                                   existing set */\n                            ANYOF_POSIXL_SET(data->start_class, namedclass);\n                        }\n                    }\n                    break;\n\n                case NPOSIXA:   /* For these, we always know the exact set of\n                                   what's matched */\n                    invert = 1;\n                    /* FALLTHROUGH */\n\t\tcase POSIXA:\n                    my_invlist = invlist_clone(PL_Posix_ptrs[FLAGS(scan)], NULL);\n                    goto join_posix_and_ascii;\n\n\t\tcase NPOSIXD:\n\t\tcase NPOSIXU:\n                    invert = 1;\n                    /* FALLTHROUGH */\n\t\tcase POSIXD:\n\t\tcase POSIXU:\n                    my_invlist = invlist_clone(PL_XPosix_ptrs[FLAGS(scan)], NULL);\n\n                    /* NPOSIXD matches all upper Latin1 code points unless the\n                     * target string being matched is UTF-8, which is\n                     * unknowable until match time.  Since we are going to\n                     * invert, we want to get rid of all of them so that the\n                     * inversion will match all */\n                    if (OP(scan) == NPOSIXD) {\n                        _invlist_subtract(my_invlist, PL_UpperLatin1,\n                                          &my_invlist);\n                    }\n\n                  join_posix_and_ascii:\n\n                    if (flags & SCF_DO_STCLASS_AND) {\n                        ssc_intersection(data->start_class, my_invlist, invert);\n                        ssc_clear_locale(data->start_class);\n                    }\n                    else {\n                        assert(flags & SCF_DO_STCLASS_OR);\n                        ssc_union(data->start_class, my_invlist, invert);\n                    }\n                    SvREFCNT_dec(my_invlist);\n\t\t}\n\t\tif (flags & SCF_DO_STCLASS_OR)\n\t\t    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\t\tflags &= ~SCF_DO_STCLASS;\n\t    }\n\t}\n\telse if (PL_regkind[OP(scan)] == EOL && flags & SCF_DO_SUBSTR) {\n\t    data->flags |= (OP(scan) == MEOL\n\t\t\t    ? SF_BEFORE_MEOL\n\t\t\t    : SF_BEFORE_SEOL);\n            scan_commit(pRExC_state, data, minlenp, is_inf);\n\n\t}\n\telse if (  PL_regkind[OP(scan)] == BRANCHJ\n\t\t /* Lookbehind, or need to calculate parens/evals/stclass: */\n\t\t   && (scan->flags || data || (flags & SCF_DO_STCLASS))\n\t\t   && (OP(scan) == IFMATCH || OP(scan) == UNLESSM))\n        {\n            if ( !PERL_ENABLE_POSITIVE_ASSERTION_STUDY\n                || OP(scan) == UNLESSM )\n            {\n                /* Negative Lookahead/lookbehind\n                   In this case we can't do fixed string optimisation.\n                */\n\n                SSize_t deltanext, minnext, fake = 0;\n                regnode *nscan;\n                regnode_ssc intrnl;\n                int f = 0;\n\n                StructCopy(&zero_scan_data, &data_fake, scan_data_t);\n                if (data) {\n                    data_fake.whilem_c = data->whilem_c;\n                    data_fake.last_closep = data->last_closep;\n\t\t}\n                else\n                    data_fake.last_closep = &fake;\n\t\tdata_fake.pos_delta = delta;\n                if ( flags & SCF_DO_STCLASS && !scan->flags\n                     && OP(scan) == IFMATCH ) { /* Lookahead */\n                    ssc_init(pRExC_state, &intrnl);\n                    data_fake.start_class = &intrnl;\n                    f |= SCF_DO_STCLASS_AND;\n\t\t}\n                if (flags & SCF_WHILEM_VISITED_POS)\n                    f |= SCF_WHILEM_VISITED_POS;\n                next = regnext(scan);\n                nscan = NEXTOPER(NEXTOPER(scan));\n\n                /* recurse study_chunk() for lookahead body */\n                minnext = study_chunk(pRExC_state, &nscan, minlenp, &deltanext,\n                                      last, &data_fake, stopparen,\n                                      recursed_depth, NULL, f, depth+1);\n                if (scan->flags) {\n                    if (   deltanext < 0\n                        || deltanext > (I32) U8_MAX\n                        || minnext > (I32)U8_MAX\n                        || minnext + deltanext > (I32)U8_MAX)\n                    {\n\t\t\tFAIL2(\"Lookbehind longer than %\" UVuf \" not implemented\",\n                              (UV)U8_MAX);\n                    }\n\n                    /* The 'next_off' field has been repurposed to count the\n                     * additional starting positions to try beyond the initial\n                     * one.  (This leaves it at 0 for non-variable length\n                     * matches to avoid breakage for those not using this\n                     * extension) */\n                    if (deltanext) {\n                        scan->next_off = deltanext;\n                        ckWARNexperimental(RExC_parse,\n                            WARN_EXPERIMENTAL__VLB,\n                            \"Variable length lookbehind is experimental\");\n                    }\n                    scan->flags = (U8)minnext + deltanext;\n                }\n                if (data) {\n                    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))\n                        pars++;\n                    if (data_fake.flags & SF_HAS_EVAL)\n                        data->flags |= SF_HAS_EVAL;\n                    data->whilem_c = data_fake.whilem_c;\n                }\n                if (f & SCF_DO_STCLASS_AND) {\n\t\t    if (flags & SCF_DO_STCLASS_OR) {\n\t\t\t/* OR before, AND after: ideally we would recurse with\n\t\t\t * data_fake to get the AND applied by study of the\n\t\t\t * remainder of the pattern, and then derecurse;\n\t\t\t * *** HACK *** for now just treat as \"no information\".\n\t\t\t * See [perl #56690].\n\t\t\t */\n\t\t\tssc_init(pRExC_state, data->start_class);\n\t\t    }  else {\n                        /* AND before and after: combine and continue.  These\n                         * assertions are zero-length, so can match an EMPTY\n                         * string */\n\t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) &intrnl);\n                        ANYOF_FLAGS(data->start_class)\n                                                   |= SSC_MATCHES_EMPTY_STRING;\n\t\t    }\n                }\n\t    }\n#if PERL_ENABLE_POSITIVE_ASSERTION_STUDY\n            else {\n                /* Positive Lookahead/lookbehind\n                   In this case we can do fixed string optimisation,\n                   but we must be careful about it. Note in the case of\n                   lookbehind the positions will be offset by the minimum\n                   length of the pattern, something we won't know about\n                   until after the recurse.\n                */\n                SSize_t deltanext, fake = 0;\n                regnode *nscan;\n                regnode_ssc intrnl;\n                int f = 0;\n                /* We use SAVEFREEPV so that when the full compile\n                    is finished perl will clean up the allocated\n                    minlens when it's all done. This way we don't\n                    have to worry about freeing them when we know\n                    they wont be used, which would be a pain.\n                 */\n                SSize_t *minnextp;\n                Newx( minnextp, 1, SSize_t );\n                SAVEFREEPV(minnextp);\n\n                if (data) {\n                    StructCopy(data, &data_fake, scan_data_t);\n                    if ((flags & SCF_DO_SUBSTR) && data->last_found) {\n                        f |= SCF_DO_SUBSTR;\n                        if (scan->flags)\n                            scan_commit(pRExC_state, &data_fake, minlenp, is_inf);\n                        data_fake.last_found=newSVsv(data->last_found);\n                    }\n                }\n                else\n                    data_fake.last_closep = &fake;\n                data_fake.flags = 0;\n                data_fake.substrs[0].flags = 0;\n                data_fake.substrs[1].flags = 0;\n\t\tdata_fake.pos_delta = delta;\n                if (is_inf)\n\t            data_fake.flags |= SF_IS_INF;\n                if ( flags & SCF_DO_STCLASS && !scan->flags\n                     && OP(scan) == IFMATCH ) { /* Lookahead */\n                    ssc_init(pRExC_state, &intrnl);\n                    data_fake.start_class = &intrnl;\n                    f |= SCF_DO_STCLASS_AND;\n                }\n                if (flags & SCF_WHILEM_VISITED_POS)\n                    f |= SCF_WHILEM_VISITED_POS;\n                next = regnext(scan);\n                nscan = NEXTOPER(NEXTOPER(scan));\n\n                /* positive lookahead study_chunk() recursion */\n                *minnextp = study_chunk(pRExC_state, &nscan, minnextp,\n                                        &deltanext, last, &data_fake,\n                                        stopparen, recursed_depth, NULL,\n                                        f, depth+1);\n                if (scan->flags) {\n                    assert(0);  /* This code has never been tested since this\n                                   is normally not compiled */\n                    if (   deltanext < 0\n                        || deltanext > (I32) U8_MAX\n                        || *minnextp > (I32)U8_MAX\n                        || *minnextp + deltanext > (I32)U8_MAX)\n                    {\n\t\t\tFAIL2(\"Lookbehind longer than %\" UVuf \" not implemented\",\n                              (UV)U8_MAX);\n                    }\n\n                    if (deltanext) {\n                        scan->next_off = deltanext;\n                    }\n                    scan->flags = (U8)*minnextp + deltanext;\n                }\n\n                *minnextp += min;\n\n                if (f & SCF_DO_STCLASS_AND) {\n                    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) &intrnl);\n                    ANYOF_FLAGS(data->start_class) |= SSC_MATCHES_EMPTY_STRING;\n                }\n                if (data) {\n                    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))\n                        pars++;\n                    if (data_fake.flags & SF_HAS_EVAL)\n                        data->flags |= SF_HAS_EVAL;\n                    data->whilem_c = data_fake.whilem_c;\n                    if ((flags & SCF_DO_SUBSTR) && data_fake.last_found) {\n                        int i;\n                        if (RExC_rx->minlen<*minnextp)\n                            RExC_rx->minlen=*minnextp;\n                        scan_commit(pRExC_state, &data_fake, minnextp, is_inf);\n                        SvREFCNT_dec_NN(data_fake.last_found);\n\n                        for (i = 0; i < 2; i++) {\n                            if (data_fake.substrs[i].minlenp != minlenp) {\n                                data->substrs[i].min_offset =\n                                            data_fake.substrs[i].min_offset;\n                                data->substrs[i].max_offset =\n                                            data_fake.substrs[i].max_offset;\n                                data->substrs[i].minlenp =\n                                            data_fake.substrs[i].minlenp;\n                                data->substrs[i].lookbehind += scan->flags;\n                            }\n                        }\n                    }\n                }\n\t    }\n#endif\n\t}\n\n\telse if (OP(scan) == OPEN) {\n\t    if (stopparen != (I32)ARG(scan))\n\t        pars++;\n\t}\n\telse if (OP(scan) == CLOSE) {\n\t    if (stopparen == (I32)ARG(scan)) {\n\t        break;\n\t    }\n\t    if ((I32)ARG(scan) == is_par) {\n\t\tnext = regnext(scan);\n\n\t\tif ( next && (OP(next) != WHILEM) && next < last)\n\t\t    is_par = 0;\t\t/* Disable optimization */\n\t    }\n\t    if (data)\n\t\t*(data->last_closep) = ARG(scan);\n\t}\n\telse if (OP(scan) == EVAL) {\n\t\tif (data)\n\t\t    data->flags |= SF_HAS_EVAL;\n\t}\n\telse if ( PL_regkind[OP(scan)] == ENDLIKE ) {\n\t    if (flags & SCF_DO_SUBSTR) {\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n\t\tflags &= ~SCF_DO_SUBSTR;\n\t    }\n\t    if (data && OP(scan)==ACCEPT) {\n\t        data->flags |= SCF_SEEN_ACCEPT;\n\t        if (stopmin > min)\n\t            stopmin = min;\n\t    }\n\t}\n\telse if (OP(scan) == LOGICAL && scan->flags == 2) /* Embedded follows */\n\t{\n\t\tif (flags & SCF_DO_SUBSTR) {\n                    scan_commit(pRExC_state, data, minlenp, is_inf);\n\t\t    data->cur_is_floating = 1; /* float */\n\t\t}\n\t\tis_inf = is_inf_internal = 1;\n\t\tif (flags & SCF_DO_STCLASS_OR) /* Allow everything */\n\t\t    ssc_anything(data->start_class);\n\t\tflags &= ~SCF_DO_STCLASS;\n\t}\n\telse if (OP(scan) == GPOS) {\n            if (!(RExC_rx->intflags & PREGf_GPOS_FLOAT) &&\n\t        !(delta || is_inf || (data && data->pos_delta)))\n\t    {\n                if (!(RExC_rx->intflags & PREGf_ANCH) && (flags & SCF_DO_SUBSTR))\n                    RExC_rx->intflags |= PREGf_ANCH_GPOS;\n\t        if (RExC_rx->gofs < (STRLEN)min)\n\t\t    RExC_rx->gofs = min;\n            } else {\n                RExC_rx->intflags |= PREGf_GPOS_FLOAT;\n                RExC_rx->gofs = 0;\n            }\n\t}\n#ifdef TRIE_STUDY_OPT\n#ifdef FULL_TRIE_STUDY\n        else if (PL_regkind[OP(scan)] == TRIE) {\n            /* NOTE - There is similar code to this block above for handling\n               BRANCH nodes on the initial study.  If you change stuff here\n               check there too. */\n            regnode *trie_node= scan;\n            regnode *tail= regnext(scan);\n            reg_trie_data *trie = (reg_trie_data*)RExC_rxi->data->data[ ARG(scan) ];\n            SSize_t max1 = 0, min1 = SSize_t_MAX;\n            regnode_ssc accum;\n\n            if (flags & SCF_DO_SUBSTR) { /* XXXX Add !SUSPEND? */\n                /* Cannot merge strings after this. */\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n            }\n            if (flags & SCF_DO_STCLASS)\n                ssc_init_zero(pRExC_state, &accum);\n\n            if (!trie->jump) {\n                min1= trie->minlen;\n                max1= trie->maxlen;\n            } else {\n                const regnode *nextbranch= NULL;\n                U32 word;\n\n                for ( word=1 ; word <= trie->wordcount ; word++)\n                {\n                    SSize_t deltanext=0, minnext=0, f = 0, fake;\n                    regnode_ssc this_class;\n\n                    StructCopy(&zero_scan_data, &data_fake, scan_data_t);\n                    if (data) {\n                        data_fake.whilem_c = data->whilem_c;\n                        data_fake.last_closep = data->last_closep;\n                    }\n                    else\n                        data_fake.last_closep = &fake;\n\t\t    data_fake.pos_delta = delta;\n                    if (flags & SCF_DO_STCLASS) {\n                        ssc_init(pRExC_state, &this_class);\n                        data_fake.start_class = &this_class;\n                        f = SCF_DO_STCLASS_AND;\n                    }\n                    if (flags & SCF_WHILEM_VISITED_POS)\n                        f |= SCF_WHILEM_VISITED_POS;\n\n                    if (trie->jump[word]) {\n                        if (!nextbranch)\n                            nextbranch = trie_node + trie->jump[0];\n                        scan= trie_node + trie->jump[word];\n                        /* We go from the jump point to the branch that follows\n                           it. Note this means we need the vestigal unused\n                           branches even though they arent otherwise used. */\n                        /* optimise study_chunk() for TRIE */\n                        minnext = study_chunk(pRExC_state, &scan, minlenp,\n                            &deltanext, (regnode *)nextbranch, &data_fake,\n                            stopparen, recursed_depth, NULL, f, depth+1);\n                    }\n                    if (nextbranch && PL_regkind[OP(nextbranch)]==BRANCH)\n                        nextbranch= regnext((regnode*)nextbranch);\n\n                    if (min1 > (SSize_t)(minnext + trie->minlen))\n                        min1 = minnext + trie->minlen;\n                    if (deltanext == SSize_t_MAX) {\n                        is_inf = is_inf_internal = 1;\n                        max1 = SSize_t_MAX;\n                    } else if (max1 < (SSize_t)(minnext + deltanext + trie->maxlen))\n                        max1 = minnext + deltanext + trie->maxlen;\n\n                    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))\n                        pars++;\n                    if (data_fake.flags & SCF_SEEN_ACCEPT) {\n                        if ( stopmin > min + min1)\n\t                    stopmin = min + min1;\n\t                flags &= ~SCF_DO_SUBSTR;\n\t                if (data)\n\t                    data->flags |= SCF_SEEN_ACCEPT;\n\t            }\n                    if (data) {\n                        if (data_fake.flags & SF_HAS_EVAL)\n                            data->flags |= SF_HAS_EVAL;\n                        data->whilem_c = data_fake.whilem_c;\n                    }\n                    if (flags & SCF_DO_STCLASS)\n                        ssc_or(pRExC_state, &accum, (regnode_charclass *) &this_class);\n                }\n            }\n            if (flags & SCF_DO_SUBSTR) {\n                data->pos_min += min1;\n                data->pos_delta += max1 - min1;\n                if (max1 != min1 || is_inf)\n                    data->cur_is_floating = 1; /* float */\n            }\n            min += min1;\n            if (delta != SSize_t_MAX) {\n                if (SSize_t_MAX - (max1 - min1) >= delta)\n                    delta += max1 - min1;\n                else\n                    delta = SSize_t_MAX;\n            }\n            if (flags & SCF_DO_STCLASS_OR) {\n                ssc_or(pRExC_state, data->start_class, (regnode_charclass *) &accum);\n                if (min1) {\n                    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n                    flags &= ~SCF_DO_STCLASS;\n                }\n            }\n            else if (flags & SCF_DO_STCLASS_AND) {\n                if (min1) {\n                    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) &accum);\n                    flags &= ~SCF_DO_STCLASS;\n                }\n                else {\n                    /* Switch to OR mode: cache the old value of\n                     * data->start_class */\n\t\t    INIT_AND_WITHP;\n                    StructCopy(data->start_class, and_withp, regnode_ssc);\n                    flags &= ~SCF_DO_STCLASS_AND;\n                    StructCopy(&accum, data->start_class, regnode_ssc);\n                    flags |= SCF_DO_STCLASS_OR;\n                }\n            }\n            scan= tail;\n            continue;\n        }\n#else\n\telse if (PL_regkind[OP(scan)] == TRIE) {\n\t    reg_trie_data *trie = (reg_trie_data*)RExC_rxi->data->data[ ARG(scan) ];\n\t    U8*bang=NULL;\n\n\t    min += trie->minlen;\n\t    delta += (trie->maxlen - trie->minlen);\n\t    flags &= ~SCF_DO_STCLASS; /* xxx */\n            if (flags & SCF_DO_SUBSTR) {\n                /* Cannot expect anything... */\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n    \t        data->pos_min += trie->minlen;\n    \t        data->pos_delta += (trie->maxlen - trie->minlen);\n\t\tif (trie->maxlen != trie->minlen)\n\t\t    data->cur_is_floating = 1; /* float */\n    \t    }\n    \t    if (trie->jump) /* no more substrings -- for now /grr*/\n               flags &= ~SCF_DO_SUBSTR;\n\t}\n#endif /* old or new */\n#endif /* TRIE_STUDY_OPT */\n\n\t/* Else: zero-length, ignore. */\n\tscan = regnext(scan);\n    }\n\n  finish:\n    if (frame) {\n        /* we need to unwind recursion. */\n        depth = depth - 1;\n\n        DEBUG_STUDYDATA(\"frame-end\", data, depth, is_inf);\n        DEBUG_PEEP(\"fend\", scan, depth, flags);\n\n        /* restore previous context */\n        last = frame->last_regnode;\n        scan = frame->next_regnode;\n        stopparen = frame->stopparen;\n        recursed_depth = frame->prev_recursed_depth;\n\n        RExC_frame_last = frame->prev_frame;\n        frame = frame->this_prev_frame;\n        goto fake_study_recurse;\n    }\n\n    assert(!frame);\n    DEBUG_STUDYDATA(\"pre-fin\", data, depth, is_inf);\n\n    *scanp = scan;\n    *deltap = is_inf_internal ? SSize_t_MAX : delta;\n\n    if (flags & SCF_DO_SUBSTR && is_inf)\n\tdata->pos_delta = SSize_t_MAX - data->pos_min;\n    if (is_par > (I32)U8_MAX)\n\tis_par = 0;\n    if (is_par && pars==1 && data) {\n\tdata->flags |= SF_IN_PAR;\n\tdata->flags &= ~SF_HAS_PAR;\n    }\n    else if (pars && data) {\n\tdata->flags |= SF_HAS_PAR;\n\tdata->flags &= ~SF_IN_PAR;\n    }\n    if (flags & SCF_DO_STCLASS_OR)\n\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n    if (flags & SCF_TRIE_RESTUDY)\n        data->flags |= \tSCF_TRIE_RESTUDY;\n\n    DEBUG_STUDYDATA(\"post-fin\", data, depth, is_inf);\n\n    {\n        SSize_t final_minlen= min < stopmin ? min : stopmin;\n\n        if (!(RExC_seen & REG_UNBOUNDED_QUANTIFIER_SEEN)) {\n            if (final_minlen > SSize_t_MAX - delta)\n                RExC_maxlen = SSize_t_MAX;\n            else if (RExC_maxlen < final_minlen + delta)\n                RExC_maxlen = final_minlen + delta;\n        }\n        return final_minlen;\n    }\n    NOT_REACHED; /* NOTREACHED */\n}",
        "start_line": 4454
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "regcomp.c",
        "method_name": "S_study_chunk",
        "raw_code": "STATIC SSize_t /* <=== S_study_chunk */ \nS_study_chunk(pTHX_ RExC_state_t *pRExC_state, regnode **scanp,\n                        SSize_t *minlenp, SSize_t *deltap,\n\t\t\tregnode *last,\n\t\t\tscan_data_t *data,\n\t\t\tI32 stopparen,\n                        U32 recursed_depth,\n\t\t\tregnode_ssc *and_withp,\n\t\t\tU32 flags, U32 depth)\n\t\t\t/* scanp: Start here (read-write). */\n\t\t\t/* deltap: Write maxlen-minlen here. */\n\t\t\t/* last: Stop before this one. */\n\t\t\t/* data: string data about the pattern */\n\t\t\t/* stopparen: treat close N as END */\n\t\t\t/* recursed: which subroutines have we recursed into */\n\t\t\t/* and_withp: Valid if flags & SCF_DO_STCLASS_OR */\n{\n    dVAR;\n    /* There must be at least this number of characters to match */\n    SSize_t min = 0;\n    I32 pars = 0, code;\n    regnode *scan = *scanp, *next;\n    SSize_t delta = 0;\n    int is_inf = (flags & SCF_DO_SUBSTR) && (data->flags & SF_IS_INF);\n    int is_inf_internal = 0;\t\t/* The studied chunk is infinite */\n    I32 is_par = OP(scan) == OPEN ? ARG(scan) : 0;\n    scan_data_t data_fake;\n    SV *re_trie_maxbuff = NULL;\n    regnode *first_non_open = scan;\n    SSize_t stopmin = SSize_t_MAX;\n    scan_frame *frame = NULL;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_STUDY_CHUNK;\n    RExC_study_started= 1;\n\n    Zero(&data_fake, 1, scan_data_t);\n\n    if ( depth == 0 ) {\n        while (first_non_open && OP(first_non_open) == OPEN)\n            first_non_open=regnext(first_non_open);\n    }\n\n\n  fake_study_recurse:\n    DEBUG_r(\n        RExC_study_chunk_recursed_count++;\n    );\n    DEBUG_OPTIMISE_MORE_r(\n    {\n        Perl_re_indentf( aTHX_  \"study_chunk stopparen=%ld recursed_count=%lu depth=%lu recursed_depth=%lu scan=%p last=%p\",\n            depth, (long)stopparen,\n            (unsigned long)RExC_study_chunk_recursed_count,\n            (unsigned long)depth, (unsigned long)recursed_depth,\n            scan,\n            last);\n        if (recursed_depth) {\n            U32 i;\n            U32 j;\n            for ( j = 0 ; j < recursed_depth ; j++ ) {\n                for ( i = 0 ; i < (U32)RExC_total_parens ; i++ ) {\n                    if (\n                        PAREN_TEST(RExC_study_chunk_recursed +\n                                   ( j * RExC_study_chunk_recursed_bytes), i )\n                        && (\n                            !j ||\n                            !PAREN_TEST(RExC_study_chunk_recursed +\n                                   (( j - 1 ) * RExC_study_chunk_recursed_bytes), i)\n                        )\n                    ) {\n                        Perl_re_printf( aTHX_ \" %d\",(int)i);\n                        break;\n                    }\n                }\n                if ( j + 1 < recursed_depth ) {\n                    Perl_re_printf( aTHX_  \",\");\n                }\n            }\n        }\n        Perl_re_printf( aTHX_ \"\\n\");\n    }\n    );\n    while ( scan && OP(scan) != END && scan < last ){\n        UV min_subtract = 0;    /* How mmany chars to subtract from the minimum\n                                   node length to get a real minimum (because\n                                   the folded version may be shorter) */\n\tbool unfolded_multi_char = FALSE;\n\t/* Peephole optimizer: */\n        DEBUG_STUDYDATA(\"Peep\", data, depth, is_inf);\n        DEBUG_PEEP(\"Peep\", scan, depth, flags);\n\n\n        /* The reason we do this here is that we need to deal with things like\n         * /(?:f)(?:o)(?:o)/ which cant be dealt with by the normal EXACT\n         * parsing code, as each (?:..) is handled by a different invocation of\n         * reg() -- Yves\n         */\n        JOIN_EXACT(scan,&min_subtract, &unfolded_multi_char, 0);\n\n\t/* Follow the next-chain of the current node and optimize\n\t   away all the NOTHINGs from it.  */\n\tif (OP(scan) != CURLYX) {\n\t    const int max = (reg_off_by_arg[OP(scan)]\n\t\t       ? I32_MAX\n\t\t       /* I32 may be smaller than U16 on CRAYs! */\n\t\t       : (I32_MAX < U16_MAX ? I32_MAX : U16_MAX));\n\t    int off = (reg_off_by_arg[OP(scan)] ? ARG(scan) : NEXT_OFF(scan));\n\t    int noff;\n\t    regnode *n = scan;\n\n\t    /* Skip NOTHING and LONGJMP. */\n\t    while ((n = regnext(n))\n\t\t   && ((PL_regkind[OP(n)] == NOTHING && (noff = NEXT_OFF(n)))\n\t\t       || ((OP(n) == LONGJMP) && (noff = ARG(n))))\n\t\t   && off + noff < max)\n\t\toff += noff;\n\t    if (reg_off_by_arg[OP(scan)])\n\t\tARG(scan) = off;\n\t    else\n\t\tNEXT_OFF(scan) = off;\n\t}\n\n\t/* The principal pseudo-switch.  Cannot be a switch, since we\n\t   look into several different things.  */\n        if ( OP(scan) == DEFINEP ) {\n            SSize_t minlen = 0;\n            SSize_t deltanext = 0;\n            SSize_t fake_last_close = 0;\n            I32 f = SCF_IN_DEFINE;\n\n            StructCopy(&zero_scan_data, &data_fake, scan_data_t);\n            scan = regnext(scan);\n            assert( OP(scan) == IFTHEN );\n            DEBUG_PEEP(\"expect IFTHEN\", scan, depth, flags);\n\n            data_fake.last_closep= &fake_last_close;\n            minlen = *minlenp;\n            next = regnext(scan);\n            scan = NEXTOPER(NEXTOPER(scan));\n            DEBUG_PEEP(\"scan\", scan, depth, flags);\n            DEBUG_PEEP(\"next\", next, depth, flags);\n\n            /* we suppose the run is continuous, last=next...\n             * NOTE we dont use the return here! */\n            /* DEFINEP study_chunk() recursion */\n            (void)study_chunk(pRExC_state, &scan, &minlen,\n                              &deltanext, next, &data_fake, stopparen,\n                              recursed_depth, NULL, f, depth+1);\n\n            scan = next;\n        } else\n        if (\n            OP(scan) == BRANCH  ||\n            OP(scan) == BRANCHJ ||\n            OP(scan) == IFTHEN\n        ) {\n\t    next = regnext(scan);\n\t    code = OP(scan);\n\n            /* The op(next)==code check below is to see if we\n             * have \"BRANCH-BRANCH\", \"BRANCHJ-BRANCHJ\", \"IFTHEN-IFTHEN\"\n             * IFTHEN is special as it might not appear in pairs.\n             * Not sure whether BRANCH-BRANCHJ is possible, regardless\n             * we dont handle it cleanly. */\n\t    if (OP(next) == code || code == IFTHEN) {\n                /* NOTE - There is similar code to this block below for\n                 * handling TRIE nodes on a re-study.  If you change stuff here\n                 * check there too. */\n\t\tSSize_t max1 = 0, min1 = SSize_t_MAX, num = 0;\n\t\tregnode_ssc accum;\n\t\tregnode * const startbranch=scan;\n\n                if (flags & SCF_DO_SUBSTR) {\n                    /* Cannot merge strings after this. */\n                    scan_commit(pRExC_state, data, minlenp, is_inf);\n                }\n\n                if (flags & SCF_DO_STCLASS)\n\t\t    ssc_init_zero(pRExC_state, &accum);\n\n\t\twhile (OP(scan) == code) {\n\t\t    SSize_t deltanext, minnext, fake;\n\t\t    I32 f = 0;\n\t\t    regnode_ssc this_class;\n\n                    DEBUG_PEEP(\"Branch\", scan, depth, flags);\n\n\t\t    num++;\n                    StructCopy(&zero_scan_data, &data_fake, scan_data_t);\n\t\t    if (data) {\n\t\t\tdata_fake.whilem_c = data->whilem_c;\n\t\t\tdata_fake.last_closep = data->last_closep;\n\t\t    }\n\t\t    else\n\t\t\tdata_fake.last_closep = &fake;\n\n\t\t    data_fake.pos_delta = delta;\n\t\t    next = regnext(scan);\n\n                    scan = NEXTOPER(scan); /* everything */\n                    if (code != BRANCH)    /* everything but BRANCH */\n\t\t\tscan = NEXTOPER(scan);\n\n\t\t    if (flags & SCF_DO_STCLASS) {\n\t\t\tssc_init(pRExC_state, &this_class);\n\t\t\tdata_fake.start_class = &this_class;\n\t\t\tf = SCF_DO_STCLASS_AND;\n\t\t    }\n\t\t    if (flags & SCF_WHILEM_VISITED_POS)\n\t\t\tf |= SCF_WHILEM_VISITED_POS;\n\n\t\t    /* we suppose the run is continuous, last=next...*/\n                    /* recurse study_chunk() for each BRANCH in an alternation */\n\t\t    minnext = study_chunk(pRExC_state, &scan, minlenp,\n                                      &deltanext, next, &data_fake, stopparen,\n                                      recursed_depth, NULL, f, depth+1);\n\n\t\t    if (min1 > minnext)\n\t\t\tmin1 = minnext;\n\t\t    if (deltanext == SSize_t_MAX) {\n\t\t\tis_inf = is_inf_internal = 1;\n\t\t\tmax1 = SSize_t_MAX;\n\t\t    } else if (max1 < minnext + deltanext)\n\t\t\tmax1 = minnext + deltanext;\n\t\t    scan = next;\n\t\t    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))\n\t\t\tpars++;\n\t            if (data_fake.flags & SCF_SEEN_ACCEPT) {\n\t                if ( stopmin > minnext)\n\t                    stopmin = min + min1;\n\t                flags &= ~SCF_DO_SUBSTR;\n\t                if (data)\n\t                    data->flags |= SCF_SEEN_ACCEPT;\n\t            }\n\t\t    if (data) {\n\t\t\tif (data_fake.flags & SF_HAS_EVAL)\n\t\t\t    data->flags |= SF_HAS_EVAL;\n\t\t\tdata->whilem_c = data_fake.whilem_c;\n\t\t    }\n\t\t    if (flags & SCF_DO_STCLASS)\n\t\t\tssc_or(pRExC_state, &accum, (regnode_charclass*)&this_class);\n\t\t}\n\t\tif (code == IFTHEN && num < 2) /* Empty ELSE branch */\n\t\t    min1 = 0;\n\t\tif (flags & SCF_DO_SUBSTR) {\n\t\t    data->pos_min += min1;\n\t\t    if (data->pos_delta >= SSize_t_MAX - (max1 - min1))\n\t\t        data->pos_delta = SSize_t_MAX;\n\t\t    else\n\t\t        data->pos_delta += max1 - min1;\n\t\t    if (max1 != min1 || is_inf)\n\t\t\tdata->cur_is_floating = 1;\n\t\t}\n\t\tmin += min1;\n\t\tif (delta == SSize_t_MAX\n\t\t || SSize_t_MAX - delta - (max1 - min1) < 0)\n\t\t    delta = SSize_t_MAX;\n\t\telse\n\t\t    delta += max1 - min1;\n\t\tif (flags & SCF_DO_STCLASS_OR) {\n\t\t    ssc_or(pRExC_state, data->start_class, (regnode_charclass*) &accum);\n\t\t    if (min1) {\n\t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\t\t\tflags &= ~SCF_DO_STCLASS;\n\t\t    }\n\t\t}\n\t\telse if (flags & SCF_DO_STCLASS_AND) {\n\t\t    if (min1) {\n\t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) &accum);\n\t\t\tflags &= ~SCF_DO_STCLASS;\n\t\t    }\n\t\t    else {\n\t\t\t/* Switch to OR mode: cache the old value of\n\t\t\t * data->start_class */\n\t\t\tINIT_AND_WITHP;\n\t\t\tStructCopy(data->start_class, and_withp, regnode_ssc);\n\t\t\tflags &= ~SCF_DO_STCLASS_AND;\n\t\t\tStructCopy(&accum, data->start_class, regnode_ssc);\n\t\t\tflags |= SCF_DO_STCLASS_OR;\n\t\t    }\n\t\t}\n\n                if (PERL_ENABLE_TRIE_OPTIMISATION &&\n                        OP( startbranch ) == BRANCH )\n                {\n\t\t/* demq.\n\n                   Assuming this was/is a branch we are dealing with: 'scan'\n                   now points at the item that follows the branch sequence,\n                   whatever it is. We now start at the beginning of the\n                   sequence and look for subsequences of\n\n\t\t   BRANCH->EXACT=>x1\n\t\t   BRANCH->EXACT=>x2\n\t\t   tail\n\n                   which would be constructed from a pattern like\n                   /A|LIST|OF|WORDS/\n\n\t\t   If we can find such a subsequence we need to turn the first\n\t\t   element into a trie and then add the subsequent branch exact\n\t\t   strings to the trie.\n\n\t\t   We have two cases\n\n                     1. patterns where the whole set of branches can be\n                        converted.\n\n\t\t     2. patterns where only a subset can be converted.\n\n\t\t   In case 1 we can replace the whole set with a single regop\n\t\t   for the trie. In case 2 we need to keep the start and end\n\t\t   branches so\n\n\t\t     'BRANCH EXACT; BRANCH EXACT; BRANCH X'\n\t\t     becomes BRANCH TRIE; BRANCH X;\n\n\t\t  There is an additional case, that being where there is a\n\t\t  common prefix, which gets split out into an EXACT like node\n\t\t  preceding the TRIE node.\n\n\t\t  If x(1..n)==tail then we can do a simple trie, if not we make\n\t\t  a \"jump\" trie, such that when we match the appropriate word\n\t\t  we \"jump\" to the appropriate tail node. Essentially we turn\n\t\t  a nested if into a case structure of sorts.\n\n\t\t*/\n\n\t\t    int made=0;\n\t\t    if (!re_trie_maxbuff) {\n\t\t\tre_trie_maxbuff = get_sv(RE_TRIE_MAXBUF_NAME, 1);\n\t\t\tif (!SvIOK(re_trie_maxbuff))\n\t\t\t    sv_setiv(re_trie_maxbuff, RE_TRIE_MAXBUF_INIT);\n\t\t    }\n                    if ( SvIV(re_trie_maxbuff)>=0  ) {\n                        regnode *cur;\n                        regnode *first = (regnode *)NULL;\n                        regnode *last = (regnode *)NULL;\n                        regnode *tail = scan;\n                        U8 trietype = 0;\n                        U32 count=0;\n\n                        /* var tail is used because there may be a TAIL\n                           regop in the way. Ie, the exacts will point to the\n                           thing following the TAIL, but the last branch will\n                           point at the TAIL. So we advance tail. If we\n                           have nested (?:) we may have to move through several\n                           tails.\n                         */\n\n                        while ( OP( tail ) == TAIL ) {\n                            /* this is the TAIL generated by (?:) */\n                            tail = regnext( tail );\n                        }\n\n\n                        DEBUG_TRIE_COMPILE_r({\n                            regprop(RExC_rx, RExC_mysv, tail, NULL, pRExC_state);\n                            Perl_re_indentf( aTHX_  \"%s %\" UVuf \":%s\\n\",\n                              depth+1,\n                              \"Looking for TRIE'able sequences. Tail node is \",\n                              (UV) REGNODE_OFFSET(tail),\n                              SvPV_nolen_const( RExC_mysv )\n                            );\n                        });\n\n                        /*\n\n                            Step through the branches\n                                cur represents each branch,\n                                noper is the first thing to be matched as part\n                                      of that branch\n                                noper_next is the regnext() of that node.\n\n                            We normally handle a case like this\n                            /FOO[xyz]|BAR[pqr]/ via a \"jump trie\" but we also\n                            support building with NOJUMPTRIE, which restricts\n                            the trie logic to structures like /FOO|BAR/.\n\n                            If noper is a trieable nodetype then the branch is\n                            a possible optimization target. If we are building\n                            under NOJUMPTRIE then we require that noper_next is\n                            the same as scan (our current position in the regex\n                            program).\n\n                            Once we have two or more consecutive such branches\n                            we can create a trie of the EXACT's contents and\n                            stitch it in place into the program.\n\n                            If the sequence represents all of the branches in\n                            the alternation we replace the entire thing with a\n                            single TRIE node.\n\n                            Otherwise when it is a subsequence we need to\n                            stitch it in place and replace only the relevant\n                            branches. This means the first branch has to remain\n                            as it is used by the alternation logic, and its\n                            next pointer, and needs to be repointed at the item\n                            on the branch chain following the last branch we\n                            have optimized away.\n\n                            This could be either a BRANCH, in which case the\n                            subsequence is internal, or it could be the item\n                            following the branch sequence in which case the\n                            subsequence is at the end (which does not\n                            necessarily mean the first node is the start of the\n                            alternation).\n\n                            TRIE_TYPE(X) is a define which maps the optype to a\n                            trietype.\n\n                                optype          |  trietype\n                                ----------------+-----------\n                                NOTHING         | NOTHING\n                                EXACT           | EXACT\n                                EXACT_ONLY8     | EXACT\n                                EXACTFU         | EXACTFU\n                                EXACTFU_ONLY8   | EXACTFU\n                                EXACTFUP        | EXACTFU\n                                EXACTFAA        | EXACTFAA\n                                EXACTL          | EXACTL\n                                EXACTFLU8       | EXACTFLU8\n\n\n                        */\n#define TRIE_TYPE(X) ( ( NOTHING == (X) )                                   \\\n                       ? NOTHING                                            \\\n                       : ( EXACT == (X) || EXACT_ONLY8 == (X) )             \\\n                         ? EXACT                                            \\\n                         : (     EXACTFU == (X)                             \\\n                              || EXACTFU_ONLY8 == (X)                       \\\n                              || EXACTFUP == (X) )                          \\\n                           ? EXACTFU                                        \\\n                           : ( EXACTFAA == (X) )                            \\\n                             ? EXACTFAA                                     \\\n                             : ( EXACTL == (X) )                            \\\n                               ? EXACTL                                     \\\n                               : ( EXACTFLU8 == (X) )                       \\\n                                 ? EXACTFLU8                                \\\n                                 : 0 )\n\n                        /* dont use tail as the end marker for this traverse */\n                        for ( cur = startbranch ; cur != scan ; cur = regnext( cur ) ) {\n                            regnode * const noper = NEXTOPER( cur );\n                            U8 noper_type = OP( noper );\n                            U8 noper_trietype = TRIE_TYPE( noper_type );\n#if defined(DEBUGGING) || defined(NOJUMPTRIE)\n                            regnode * const noper_next = regnext( noper );\n                            U8 noper_next_type = (noper_next && noper_next < tail) ? OP(noper_next) : 0;\n                            U8 noper_next_trietype = (noper_next && noper_next < tail) ? TRIE_TYPE( noper_next_type ) :0;\n#endif\n\n                            DEBUG_TRIE_COMPILE_r({\n                                regprop(RExC_rx, RExC_mysv, cur, NULL, pRExC_state);\n                                Perl_re_indentf( aTHX_  \"- %d:%s (%d)\",\n                                   depth+1,\n                                   REG_NODE_NUM(cur), SvPV_nolen_const( RExC_mysv ), REG_NODE_NUM(cur) );\n\n                                regprop(RExC_rx, RExC_mysv, noper, NULL, pRExC_state);\n                                Perl_re_printf( aTHX_  \" -> %d:%s\",\n                                    REG_NODE_NUM(noper), SvPV_nolen_const(RExC_mysv));\n\n                                if ( noper_next ) {\n                                  regprop(RExC_rx, RExC_mysv, noper_next, NULL, pRExC_state);\n                                  Perl_re_printf( aTHX_ \"\\t=> %d:%s\\t\",\n                                    REG_NODE_NUM(noper_next), SvPV_nolen_const(RExC_mysv));\n                                }\n                                Perl_re_printf( aTHX_  \"(First==%d,Last==%d,Cur==%d,tt==%s,ntt==%s,nntt==%s)\\n\",\n                                   REG_NODE_NUM(first), REG_NODE_NUM(last), REG_NODE_NUM(cur),\n\t\t\t\t   PL_reg_name[trietype], PL_reg_name[noper_trietype], PL_reg_name[noper_next_trietype]\n\t\t\t\t);\n                            });\n\n                            /* Is noper a trieable nodetype that can be merged\n                             * with the current trie (if there is one)? */\n                            if ( noper_trietype\n                                  &&\n                                  (\n                                        ( noper_trietype == NOTHING )\n                                        || ( trietype == NOTHING )\n                                        || ( trietype == noper_trietype )\n                                  )\n#ifdef NOJUMPTRIE\n                                  && noper_next >= tail\n#endif\n                                  && count < U16_MAX)\n                            {\n                                /* Handle mergable triable node Either we are\n                                 * the first node in a new trieable sequence,\n                                 * in which case we do some bookkeeping,\n                                 * otherwise we update the end pointer. */\n                                if ( !first ) {\n                                    first = cur;\n\t\t\t\t    if ( noper_trietype == NOTHING ) {\n#if !defined(DEBUGGING) && !defined(NOJUMPTRIE)\n\t\t\t\t\tregnode * const noper_next = regnext( noper );\n                                        U8 noper_next_type = (noper_next && noper_next < tail) ? OP(noper_next) : 0;\n\t\t\t\t\tU8 noper_next_trietype = noper_next_type ? TRIE_TYPE( noper_next_type ) :0;\n#endif\n\n                                        if ( noper_next_trietype ) {\n\t\t\t\t\t    trietype = noper_next_trietype;\n                                        } else if (noper_next_type)  {\n                                            /* a NOTHING regop is 1 regop wide.\n                                             * We need at least two for a trie\n                                             * so we can't merge this in */\n                                            first = NULL;\n                                        }\n                                    } else {\n                                        trietype = noper_trietype;\n                                    }\n                                } else {\n                                    if ( trietype == NOTHING )\n                                        trietype = noper_trietype;\n                                    last = cur;\n                                }\n\t\t\t\tif (first)\n\t\t\t\t    count++;\n                            } /* end handle mergable triable node */\n                            else {\n                                /* handle unmergable node -\n                                 * noper may either be a triable node which can\n                                 * not be tried together with the current trie,\n                                 * or a non triable node */\n                                if ( last ) {\n                                    /* If last is set and trietype is not\n                                     * NOTHING then we have found at least two\n                                     * triable branch sequences in a row of a\n                                     * similar trietype so we can turn them\n                                     * into a trie. If/when we allow NOTHING to\n                                     * start a trie sequence this condition\n                                     * will be required, and it isn't expensive\n                                     * so we leave it in for now. */\n                                    if ( trietype && trietype != NOTHING )\n                                        make_trie( pRExC_state,\n                                                startbranch, first, cur, tail,\n                                                count, trietype, depth+1 );\n                                    last = NULL; /* note: we clear/update\n                                                    first, trietype etc below,\n                                                    so we dont do it here */\n                                }\n                                if ( noper_trietype\n#ifdef NOJUMPTRIE\n                                     && noper_next >= tail\n#endif\n                                ){\n                                    /* noper is triable, so we can start a new\n                                     * trie sequence */\n                                    count = 1;\n                                    first = cur;\n                                    trietype = noper_trietype;\n                                } else if (first) {\n                                    /* if we already saw a first but the\n                                     * current node is not triable then we have\n                                     * to reset the first information. */\n                                    count = 0;\n                                    first = NULL;\n                                    trietype = 0;\n                                }\n                            } /* end handle unmergable node */\n                        } /* loop over branches */\n                        DEBUG_TRIE_COMPILE_r({\n                            regprop(RExC_rx, RExC_mysv, cur, NULL, pRExC_state);\n                            Perl_re_indentf( aTHX_  \"- %s (%d) <SCAN FINISHED> \",\n                              depth+1, SvPV_nolen_const( RExC_mysv ), REG_NODE_NUM(cur));\n                            Perl_re_printf( aTHX_  \"(First==%d, Last==%d, Cur==%d, tt==%s)\\n\",\n                               REG_NODE_NUM(first), REG_NODE_NUM(last), REG_NODE_NUM(cur),\n                               PL_reg_name[trietype]\n                            );\n\n                        });\n                        if ( last && trietype ) {\n                            if ( trietype != NOTHING ) {\n                                /* the last branch of the sequence was part of\n                                 * a trie, so we have to construct it here\n                                 * outside of the loop */\n                                made= make_trie( pRExC_state, startbranch,\n                                                 first, scan, tail, count,\n                                                 trietype, depth+1 );\n#ifdef TRIE_STUDY_OPT\n                                if ( ((made == MADE_EXACT_TRIE &&\n                                     startbranch == first)\n                                     || ( first_non_open == first )) &&\n                                     depth==0 ) {\n                                    flags |= SCF_TRIE_RESTUDY;\n                                    if ( startbranch == first\n                                         && scan >= tail )\n                                    {\n                                        RExC_seen &=~REG_TOP_LEVEL_BRANCHES_SEEN;\n                                    }\n                                }\n#endif\n                            } else {\n                                /* at this point we know whatever we have is a\n                                 * NOTHING sequence/branch AND if 'startbranch'\n                                 * is 'first' then we can turn the whole thing\n                                 * into a NOTHING\n                                 */\n                                if ( startbranch == first ) {\n                                    regnode *opt;\n                                    /* the entire thing is a NOTHING sequence,\n                                     * something like this: (?:|) So we can\n                                     * turn it into a plain NOTHING op. */\n                                    DEBUG_TRIE_COMPILE_r({\n                                        regprop(RExC_rx, RExC_mysv, cur, NULL, pRExC_state);\n                                        Perl_re_indentf( aTHX_  \"- %s (%d) <NOTHING BRANCH SEQUENCE>\\n\",\n                                          depth+1,\n                                          SvPV_nolen_const( RExC_mysv ), REG_NODE_NUM(cur));\n\n                                    });\n                                    OP(startbranch)= NOTHING;\n                                    NEXT_OFF(startbranch)= tail - startbranch;\n                                    for ( opt= startbranch + 1; opt < tail ; opt++ )\n                                        OP(opt)= OPTIMIZED;\n                                }\n                            }\n                        } /* end if ( last) */\n                    } /* TRIE_MAXBUF is non zero */\n\n                } /* do trie */\n\n\t    }\n\t    else if ( code == BRANCHJ ) {  /* single branch is optimized. */\n\t\tscan = NEXTOPER(NEXTOPER(scan));\n\t    } else\t\t\t/* single branch is optimized. */\n\t\tscan = NEXTOPER(scan);\n\t    continue;\n        } else if (OP(scan) == SUSPEND || OP(scan) == GOSUB) {\n            I32 paren = 0;\n            regnode *start = NULL;\n            regnode *end = NULL;\n            U32 my_recursed_depth= recursed_depth;\n\n            if (OP(scan) != SUSPEND) { /* GOSUB */\n                /* Do setup, note this code has side effects beyond\n                 * the rest of this block. Specifically setting\n                 * RExC_recurse[] must happen at least once during\n                 * study_chunk(). */\n                paren = ARG(scan);\n                RExC_recurse[ARG2L(scan)] = scan;\n                start = REGNODE_p(RExC_open_parens[paren]);\n                end   = REGNODE_p(RExC_close_parens[paren]);\n\n                /* NOTE we MUST always execute the above code, even\n                 * if we do nothing with a GOSUB */\n                if (\n                    ( flags & SCF_IN_DEFINE )\n                    ||\n                    (\n                        (is_inf_internal || is_inf || (data && data->flags & SF_IS_INF))\n                        &&\n                        ( (flags & (SCF_DO_STCLASS | SCF_DO_SUBSTR)) == 0 )\n                    )\n                ) {\n                    /* no need to do anything here if we are in a define. */\n                    /* or we are after some kind of infinite construct\n                     * so we can skip recursing into this item.\n                     * Since it is infinite we will not change the maxlen\n                     * or delta, and if we miss something that might raise\n                     * the minlen it will merely pessimise a little.\n                     *\n                     * Iow /(?(DEFINE)(?<foo>foo|food))a+(?&foo)/\n                     * might result in a minlen of 1 and not of 4,\n                     * but this doesn't make us mismatch, just try a bit\n                     * harder than we should.\n                     * */\n                    scan= regnext(scan);\n                    continue;\n                }\n\n                if (\n                    !recursed_depth\n                    ||\n                    !PAREN_TEST(RExC_study_chunk_recursed + ((recursed_depth-1) * RExC_study_chunk_recursed_bytes), paren)\n                ) {\n                    /* it is quite possible that there are more efficient ways\n                     * to do this. We maintain a bitmap per level of recursion\n                     * of which patterns we have entered so we can detect if a\n                     * pattern creates a possible infinite loop. When we\n                     * recurse down a level we copy the previous levels bitmap\n                     * down. When we are at recursion level 0 we zero the top\n                     * level bitmap. It would be nice to implement a different\n                     * more efficient way of doing this. In particular the top\n                     * level bitmap may be unnecessary.\n                     */\n                    if (!recursed_depth) {\n                        Zero(RExC_study_chunk_recursed, RExC_study_chunk_recursed_bytes, U8);\n                    } else {\n                        Copy(RExC_study_chunk_recursed + ((recursed_depth-1) * RExC_study_chunk_recursed_bytes),\n                             RExC_study_chunk_recursed + (recursed_depth * RExC_study_chunk_recursed_bytes),\n                             RExC_study_chunk_recursed_bytes, U8);\n                    }\n                    /* we havent recursed into this paren yet, so recurse into it */\n                    DEBUG_STUDYDATA(\"gosub-set\", data, depth, is_inf);\n                    PAREN_SET(RExC_study_chunk_recursed + (recursed_depth * RExC_study_chunk_recursed_bytes), paren);\n                    my_recursed_depth= recursed_depth + 1;\n                } else {\n                    DEBUG_STUDYDATA(\"gosub-inf\", data, depth, is_inf);\n                    /* some form of infinite recursion, assume infinite length\n                     * */\n                    if (flags & SCF_DO_SUBSTR) {\n                        scan_commit(pRExC_state, data, minlenp, is_inf);\n                        data->cur_is_floating = 1;\n                    }\n                    is_inf = is_inf_internal = 1;\n                    if (flags & SCF_DO_STCLASS_OR) /* Allow everything */\n                        ssc_anything(data->start_class);\n                    flags &= ~SCF_DO_STCLASS;\n\n                    start= NULL; /* reset start so we dont recurse later on. */\n\t        }\n            } else {\n\t        paren = stopparen;\n                start = scan + 2;\n\t        end = regnext(scan);\n\t    }\n            if (start) {\n                scan_frame *newframe;\n                assert(end);\n                if (!RExC_frame_last) {\n                    Newxz(newframe, 1, scan_frame);\n                    SAVEDESTRUCTOR_X(S_unwind_scan_frames, newframe);\n                    RExC_frame_head= newframe;\n                    RExC_frame_count++;\n                } else if (!RExC_frame_last->next_frame) {\n                    Newxz(newframe, 1, scan_frame);\n                    RExC_frame_last->next_frame= newframe;\n                    newframe->prev_frame= RExC_frame_last;\n                    RExC_frame_count++;\n                } else {\n                    newframe= RExC_frame_last->next_frame;\n                }\n                RExC_frame_last= newframe;\n\n                newframe->next_regnode = regnext(scan);\n                newframe->last_regnode = last;\n                newframe->stopparen = stopparen;\n                newframe->prev_recursed_depth = recursed_depth;\n                newframe->this_prev_frame= frame;\n\n                DEBUG_STUDYDATA(\"frame-new\", data, depth, is_inf);\n                DEBUG_PEEP(\"fnew\", scan, depth, flags);\n\n\t        frame = newframe;\n\t        scan =  start;\n\t        stopparen = paren;\n\t        last = end;\n                depth = depth + 1;\n                recursed_depth= my_recursed_depth;\n\n\t        continue;\n\t    }\n\t}\n\telse if (   OP(scan) == EXACT\n                 || OP(scan) == EXACT_ONLY8\n                 || OP(scan) == EXACTL)\n        {\n\t    SSize_t l = STR_LEN(scan);\n\t    UV uc;\n            assert(l);\n\t    if (UTF) {\n\t\tconst U8 * const s = (U8*)STRING(scan);\n\t\tuc = utf8_to_uvchr_buf(s, s + l, NULL);\n\t\tl = utf8_length(s, s + l);\n\t    } else {\n\t\tuc = *((U8*)STRING(scan));\n\t    }\n\t    min += l;\n\t    if (flags & SCF_DO_SUBSTR) { /* Update longest substr. */\n\t\t/* The code below prefers earlier match for fixed\n\t\t   offset, later match for variable offset.  */\n\t\tif (data->last_end == -1) { /* Update the start info. */\n\t\t    data->last_start_min = data->pos_min;\n \t\t    data->last_start_max = is_inf\n \t\t\t? SSize_t_MAX : data->pos_min + data->pos_delta;\n\t\t}\n\t\tsv_catpvn(data->last_found, STRING(scan), STR_LEN(scan));\n\t\tif (UTF)\n\t\t    SvUTF8_on(data->last_found);\n\t\t{\n\t\t    SV * const sv = data->last_found;\n\t\t    MAGIC * const mg = SvUTF8(sv) && SvMAGICAL(sv) ?\n\t\t\tmg_find(sv, PERL_MAGIC_utf8) : NULL;\n\t\t    if (mg && mg->mg_len >= 0)\n\t\t\tmg->mg_len += utf8_length((U8*)STRING(scan),\n                                              (U8*)STRING(scan)+STR_LEN(scan));\n\t\t}\n\t\tdata->last_end = data->pos_min + l;\n\t\tdata->pos_min += l; /* As in the first entry. */\n\t\tdata->flags &= ~SF_BEFORE_EOL;\n\t    }\n\n            /* ANDing the code point leaves at most it, and not in locale, and\n             * can't match null string */\n\t    if (flags & SCF_DO_STCLASS_AND) {\n                ssc_cp_and(data->start_class, uc);\n                ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n                ssc_clear_locale(data->start_class);\n\t    }\n\t    else if (flags & SCF_DO_STCLASS_OR) {\n                ssc_add_cp(data->start_class, uc);\n\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\n                /* See commit msg 749e076fceedeb708a624933726e7989f2302f6a */\n                ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n\t    }\n\t    flags &= ~SCF_DO_STCLASS;\n\t}\n        else if (PL_regkind[OP(scan)] == EXACT) {\n            /* But OP != EXACT!, so is EXACTFish */\n\t    SSize_t l = STR_LEN(scan);\n            const U8 * s = (U8*)STRING(scan);\n\n\t    /* Search for fixed substrings supports EXACT only. */\n\t    if (flags & SCF_DO_SUBSTR) {\n\t\tassert(data);\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n\t    }\n\t    if (UTF) {\n\t\tl = utf8_length(s, s + l);\n\t    }\n\t    if (unfolded_multi_char) {\n                RExC_seen |= REG_UNFOLDED_MULTI_SEEN;\n\t    }\n\t    min += l - min_subtract;\n            assert (min >= 0);\n            delta += min_subtract;\n\t    if (flags & SCF_DO_SUBSTR) {\n\t\tdata->pos_min += l - min_subtract;\n\t\tif (data->pos_min < 0) {\n                    data->pos_min = 0;\n                }\n                data->pos_delta += min_subtract;\n\t\tif (min_subtract) {\n\t\t    data->cur_is_floating = 1; /* float */\n\t\t}\n\t    }\n\n            if (flags & SCF_DO_STCLASS) {\n                SV* EXACTF_invlist = _make_exactf_invlist(pRExC_state, scan);\n\n                assert(EXACTF_invlist);\n                if (flags & SCF_DO_STCLASS_AND) {\n                    if (OP(scan) != EXACTFL)\n                        ssc_clear_locale(data->start_class);\n                    ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n                    ANYOF_POSIXL_ZERO(data->start_class);\n                    ssc_intersection(data->start_class, EXACTF_invlist, FALSE);\n                }\n                else {  /* SCF_DO_STCLASS_OR */\n                    ssc_union(data->start_class, EXACTF_invlist, FALSE);\n                    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\n                    /* See commit msg 749e076fceedeb708a624933726e7989f2302f6a */\n                    ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n                }\n                flags &= ~SCF_DO_STCLASS;\n                SvREFCNT_dec(EXACTF_invlist);\n            }\n\t}\n\telse if (REGNODE_VARIES(OP(scan))) {\n\t    SSize_t mincount, maxcount, minnext, deltanext, pos_before = 0;\n\t    I32 fl = 0, f = flags;\n\t    regnode * const oscan = scan;\n\t    regnode_ssc this_class;\n\t    regnode_ssc *oclass = NULL;\n\t    I32 next_is_eval = 0;\n\n\t    switch (PL_regkind[OP(scan)]) {\n\t    case WHILEM:\t\t/* End of (?:...)* . */\n\t\tscan = NEXTOPER(scan);\n\t\tgoto finish;\n\t    case PLUS:\n\t\tif (flags & (SCF_DO_SUBSTR | SCF_DO_STCLASS)) {\n\t\t    next = NEXTOPER(scan);\n\t\t    if (   OP(next) == EXACT\n                        || OP(next) == EXACT_ONLY8\n                        || OP(next) == EXACTL\n                        || (flags & SCF_DO_STCLASS))\n                    {\n\t\t\tmincount = 1;\n\t\t\tmaxcount = REG_INFTY;\n\t\t\tnext = regnext(scan);\n\t\t\tscan = NEXTOPER(scan);\n\t\t\tgoto do_curly;\n\t\t    }\n\t\t}\n\t\tif (flags & SCF_DO_SUBSTR)\n\t\t    data->pos_min++;\n\t\tmin++;\n\t\t/* FALLTHROUGH */\n\t    case STAR:\n                next = NEXTOPER(scan);\n\n                /* This temporary node can now be turned into EXACTFU, and\n                 * must, as regexec.c doesn't handle it */\n                if (OP(next) == EXACTFU_S_EDGE) {\n                    OP(next) = EXACTFU;\n                }\n\n                if (     STR_LEN(next) == 1\n                    &&   isALPHA_A(* STRING(next))\n                    && (         OP(next) == EXACTFAA\n                        || (     OP(next) == EXACTFU\n                            && ! HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE(* STRING(next)))))\n                {\n                    /* These differ in just one bit */\n                    U8 mask = ~ ('A' ^ 'a');\n\n                    assert(isALPHA_A(* STRING(next)));\n\n                    /* Then replace it by an ANYOFM node, with\n                    * the mask set to the complement of the\n                    * bit that differs between upper and lower\n                    * case, and the lowest code point of the\n                    * pair (which the '&' forces) */\n                    OP(next) = ANYOFM;\n                    ARG_SET(next, *STRING(next) & mask);\n                    FLAGS(next) = mask;\n                }\n\n\t\tif (flags & SCF_DO_STCLASS) {\n\t\t    mincount = 0;\n\t\t    maxcount = REG_INFTY;\n\t\t    next = regnext(scan);\n\t\t    scan = NEXTOPER(scan);\n\t\t    goto do_curly;\n\t\t}\n\t\tif (flags & SCF_DO_SUBSTR) {\n                    scan_commit(pRExC_state, data, minlenp, is_inf);\n                    /* Cannot extend fixed substrings */\n\t\t    data->cur_is_floating = 1; /* float */\n\t\t}\n                is_inf = is_inf_internal = 1;\n                scan = regnext(scan);\n\t\tgoto optimize_curly_tail;\n\t    case CURLY:\n\t        if (stopparen>0 && (OP(scan)==CURLYN || OP(scan)==CURLYM)\n\t            && (scan->flags == stopparen))\n\t\t{\n\t\t    mincount = 1;\n\t\t    maxcount = 1;\n\t\t} else {\n\t\t    mincount = ARG1(scan);\n\t\t    maxcount = ARG2(scan);\n\t\t}\n\t\tnext = regnext(scan);\n\t\tif (OP(scan) == CURLYX) {\n\t\t    I32 lp = (data ? *(data->last_closep) : 0);\n\t\t    scan->flags = ((lp <= (I32)U8_MAX) ? (U8)lp : U8_MAX);\n\t\t}\n\t\tscan = NEXTOPER(scan) + EXTRA_STEP_2ARGS;\n\t\tnext_is_eval = (OP(scan) == EVAL);\n\t      do_curly:\n\t\tif (flags & SCF_DO_SUBSTR) {\n                    if (mincount == 0)\n                        scan_commit(pRExC_state, data, minlenp, is_inf);\n                    /* Cannot extend fixed substrings */\n\t\t    pos_before = data->pos_min;\n\t\t}\n\t\tif (data) {\n\t\t    fl = data->flags;\n\t\t    data->flags &= ~(SF_HAS_PAR|SF_IN_PAR|SF_HAS_EVAL);\n\t\t    if (is_inf)\n\t\t\tdata->flags |= SF_IS_INF;\n\t\t}\n\t\tif (flags & SCF_DO_STCLASS) {\n\t\t    ssc_init(pRExC_state, &this_class);\n\t\t    oclass = data->start_class;\n\t\t    data->start_class = &this_class;\n\t\t    f |= SCF_DO_STCLASS_AND;\n\t\t    f &= ~SCF_DO_STCLASS_OR;\n\t\t}\n\t        /* Exclude from super-linear cache processing any {n,m}\n\t\t   regops for which the combination of input pos and regex\n\t\t   pos is not enough information to determine if a match\n\t\t   will be possible.\n\n\t\t   For example, in the regex /foo(bar\\s*){4,8}baz/ with the\n\t\t   regex pos at the \\s*, the prospects for a match depend not\n\t\t   only on the input position but also on how many (bar\\s*)\n\t\t   repeats into the {4,8} we are. */\n               if ((mincount > 1) || (maxcount > 1 && maxcount != REG_INFTY))\n\t\t    f &= ~SCF_WHILEM_VISITED_POS;\n\n\t\t/* This will finish on WHILEM, setting scan, or on NULL: */\n                /* recurse study_chunk() on loop bodies */\n\t\tminnext = study_chunk(pRExC_state, &scan, minlenp, &deltanext,\n                                  last, data, stopparen, recursed_depth, NULL,\n                                  (mincount == 0\n                                   ? (f & ~SCF_DO_SUBSTR)\n                                   : f)\n                                  ,depth+1);\n\n\t\tif (flags & SCF_DO_STCLASS)\n\t\t    data->start_class = oclass;\n\t\tif (mincount == 0 || minnext == 0) {\n\t\t    if (flags & SCF_DO_STCLASS_OR) {\n\t\t\tssc_or(pRExC_state, data->start_class, (regnode_charclass *) &this_class);\n\t\t    }\n\t\t    else if (flags & SCF_DO_STCLASS_AND) {\n\t\t\t/* Switch to OR mode: cache the old value of\n\t\t\t * data->start_class */\n\t\t\tINIT_AND_WITHP;\n\t\t\tStructCopy(data->start_class, and_withp, regnode_ssc);\n\t\t\tflags &= ~SCF_DO_STCLASS_AND;\n\t\t\tStructCopy(&this_class, data->start_class, regnode_ssc);\n\t\t\tflags |= SCF_DO_STCLASS_OR;\n                        ANYOF_FLAGS(data->start_class)\n                                                |= SSC_MATCHES_EMPTY_STRING;\n\t\t    }\n\t\t} else {\t\t/* Non-zero len */\n\t\t    if (flags & SCF_DO_STCLASS_OR) {\n\t\t\tssc_or(pRExC_state, data->start_class, (regnode_charclass *) &this_class);\n\t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\t\t    }\n\t\t    else if (flags & SCF_DO_STCLASS_AND)\n\t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) &this_class);\n\t\t    flags &= ~SCF_DO_STCLASS;\n\t\t}\n\t\tif (!scan) \t\t/* It was not CURLYX, but CURLY. */\n\t\t    scan = next;\n\t\tif (((flags & (SCF_TRIE_DOING_RESTUDY|SCF_DO_SUBSTR))==SCF_DO_SUBSTR)\n\t\t    /* ? quantifier ok, except for (?{ ... }) */\n\t\t    && (next_is_eval || !(mincount == 0 && maxcount == 1))\n\t\t    && (minnext == 0) && (deltanext == 0)\n\t\t    && data && !(data->flags & (SF_HAS_PAR|SF_IN_PAR))\n                    && maxcount <= REG_INFTY/3) /* Complement check for big\n                                                   count */\n\t\t{\n\t\t    _WARN_HELPER(RExC_precomp_end, packWARN(WARN_REGEXP),\n                        Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP),\n                            \"Quantifier unexpected on zero-length expression \"\n                            \"in regex m/%\" UTF8f \"/\",\n\t\t\t     UTF8fARG(UTF, RExC_precomp_end - RExC_precomp,\n\t\t\t\t  RExC_precomp)));\n                }\n\n                if ( ( minnext > 0 && mincount >= SSize_t_MAX / minnext )\n                    || min >= SSize_t_MAX - minnext * mincount )\n                {\n                    FAIL(\"Regexp out of space\");\n                }\n\n\t\tmin += minnext * mincount;\n\t\tis_inf_internal |= deltanext == SSize_t_MAX\n                         || (maxcount == REG_INFTY && minnext + deltanext > 0);\n\t\tis_inf |= is_inf_internal;\n                if (is_inf) {\n\t\t    delta = SSize_t_MAX;\n                } else {\n\t\t    delta += (minnext + deltanext) * maxcount\n                             - minnext * mincount;\n                }\n\t\t/* Try powerful optimization CURLYX => CURLYN. */\n\t\tif (  OP(oscan) == CURLYX && data\n\t\t      && data->flags & SF_IN_PAR\n\t\t      && !(data->flags & SF_HAS_EVAL)\n\t\t      && !deltanext && minnext == 1 ) {\n\t\t    /* Try to optimize to CURLYN.  */\n\t\t    regnode *nxt = NEXTOPER(oscan) + EXTRA_STEP_2ARGS;\n\t\t    regnode * const nxt1 = nxt;\n#ifdef DEBUGGING\n\t\t    regnode *nxt2;\n#endif\n\n\t\t    /* Skip open. */\n\t\t    nxt = regnext(nxt);\n\t\t    if (!REGNODE_SIMPLE(OP(nxt))\n\t\t\t&& !(PL_regkind[OP(nxt)] == EXACT\n\t\t\t     && STR_LEN(nxt) == 1))\n\t\t\tgoto nogo;\n#ifdef DEBUGGING\n\t\t    nxt2 = nxt;\n#endif\n\t\t    nxt = regnext(nxt);\n\t\t    if (OP(nxt) != CLOSE)\n\t\t\tgoto nogo;\n\t\t    if (RExC_open_parens) {\n\n                        /*open->CURLYM*/\n                        RExC_open_parens[ARG(nxt1)] = REGNODE_OFFSET(oscan);\n\n                        /*close->while*/\n                        RExC_close_parens[ARG(nxt1)] = REGNODE_OFFSET(nxt) + 2;\n\t\t    }\n\t\t    /* Now we know that nxt2 is the only contents: */\n\t\t    oscan->flags = (U8)ARG(nxt);\n\t\t    OP(oscan) = CURLYN;\n\t\t    OP(nxt1) = NOTHING;\t/* was OPEN. */\n\n#ifdef DEBUGGING\n\t\t    OP(nxt1 + 1) = OPTIMIZED; /* was count. */\n\t\t    NEXT_OFF(nxt1+ 1) = 0; /* just for consistency. */\n\t\t    NEXT_OFF(nxt2) = 0;\t/* just for consistency with CURLY. */\n\t\t    OP(nxt) = OPTIMIZED;\t/* was CLOSE. */\n\t\t    OP(nxt + 1) = OPTIMIZED; /* was count. */\n\t\t    NEXT_OFF(nxt+ 1) = 0; /* just for consistency. */\n#endif\n\t\t}\n\t      nogo:\n\n\t\t/* Try optimization CURLYX => CURLYM. */\n\t\tif (  OP(oscan) == CURLYX && data\n\t\t      && !(data->flags & SF_HAS_PAR)\n\t\t      && !(data->flags & SF_HAS_EVAL)\n\t\t      && !deltanext\t/* atom is fixed width */\n\t\t      && minnext != 0\t/* CURLYM can't handle zero width */\n\n                         /* Nor characters whose fold at run-time may be\n                          * multi-character */\n                      && ! (RExC_seen & REG_UNFOLDED_MULTI_SEEN)\n\t\t) {\n\t\t    /* XXXX How to optimize if data == 0? */\n\t\t    /* Optimize to a simpler form.  */\n\t\t    regnode *nxt = NEXTOPER(oscan) + EXTRA_STEP_2ARGS; /* OPEN */\n\t\t    regnode *nxt2;\n\n\t\t    OP(oscan) = CURLYM;\n\t\t    while ( (nxt2 = regnext(nxt)) /* skip over embedded stuff*/\n\t\t\t    && (OP(nxt2) != WHILEM))\n\t\t\tnxt = nxt2;\n\t\t    OP(nxt2)  = SUCCEED; /* Whas WHILEM */\n\t\t    /* Need to optimize away parenths. */\n\t\t    if ((data->flags & SF_IN_PAR) && OP(nxt) == CLOSE) {\n\t\t\t/* Set the parenth number.  */\n\t\t\tregnode *nxt1 = NEXTOPER(oscan) + EXTRA_STEP_2ARGS; /* OPEN*/\n\n\t\t\toscan->flags = (U8)ARG(nxt);\n\t\t\tif (RExC_open_parens) {\n                             /*open->CURLYM*/\n                            RExC_open_parens[ARG(nxt1)] = REGNODE_OFFSET(oscan);\n\n                            /*close->NOTHING*/\n                            RExC_close_parens[ARG(nxt1)] = REGNODE_OFFSET(nxt2)\n                                                         + 1;\n\t\t\t}\n\t\t\tOP(nxt1) = OPTIMIZED;\t/* was OPEN. */\n\t\t\tOP(nxt) = OPTIMIZED;\t/* was CLOSE. */\n\n#ifdef DEBUGGING\n\t\t\tOP(nxt1 + 1) = OPTIMIZED; /* was count. */\n\t\t\tOP(nxt + 1) = OPTIMIZED; /* was count. */\n\t\t\tNEXT_OFF(nxt1 + 1) = 0; /* just for consistency. */\n\t\t\tNEXT_OFF(nxt + 1) = 0; /* just for consistency. */\n#endif\n#if 0\n\t\t\twhile ( nxt1 && (OP(nxt1) != WHILEM)) {\n\t\t\t    regnode *nnxt = regnext(nxt1);\n\t\t\t    if (nnxt == nxt) {\n\t\t\t\tif (reg_off_by_arg[OP(nxt1)])\n\t\t\t\t    ARG_SET(nxt1, nxt2 - nxt1);\n\t\t\t\telse if (nxt2 - nxt1 < U16_MAX)\n\t\t\t\t    NEXT_OFF(nxt1) = nxt2 - nxt1;\n\t\t\t\telse\n\t\t\t\t    OP(nxt) = NOTHING;\t/* Cannot beautify */\n\t\t\t    }\n\t\t\t    nxt1 = nnxt;\n\t\t\t}\n#endif\n\t\t\t/* Optimize again: */\n                        /* recurse study_chunk() on optimised CURLYX => CURLYM */\n\t\t\tstudy_chunk(pRExC_state, &nxt1, minlenp, &deltanext, nxt,\n                                    NULL, stopparen, recursed_depth, NULL, 0,\n                                    depth+1);\n\t\t    }\n\t\t    else\n\t\t\toscan->flags = 0;\n\t\t}\n\t\telse if ((OP(oscan) == CURLYX)\n\t\t\t && (flags & SCF_WHILEM_VISITED_POS)\n\t\t\t /* See the comment on a similar expression above.\n\t\t\t    However, this time it's not a subexpression\n\t\t\t    we care about, but the expression itself. */\n\t\t\t && (maxcount == REG_INFTY)\n\t\t\t && data) {\n\t\t    /* This stays as CURLYX, we can put the count/of pair. */\n\t\t    /* Find WHILEM (as in regexec.c) */\n\t\t    regnode *nxt = oscan + NEXT_OFF(oscan);\n\n\t\t    if (OP(PREVOPER(nxt)) == NOTHING) /* LONGJMP */\n\t\t\tnxt += ARG(nxt);\n                    nxt = PREVOPER(nxt);\n                    if (nxt->flags & 0xf) {\n                        /* we've already set whilem count on this node */\n                    } else if (++data->whilem_c < 16) {\n                        assert(data->whilem_c <= RExC_whilem_seen);\n                        nxt->flags = (U8)(data->whilem_c\n                            | (RExC_whilem_seen << 4)); /* On WHILEM */\n                    }\n\t\t}\n\t\tif (data && fl & (SF_HAS_PAR|SF_IN_PAR))\n\t\t    pars++;\n\t\tif (flags & SCF_DO_SUBSTR) {\n\t\t    SV *last_str = NULL;\n                    STRLEN last_chrs = 0;\n\t\t    int counted = mincount != 0;\n\n                    if (data->last_end > 0 && mincount != 0) { /* Ends with a\n                                                                  string. */\n\t\t\tSSize_t b = pos_before >= data->last_start_min\n\t\t\t    ? pos_before : data->last_start_min;\n\t\t\tSTRLEN l;\n\t\t\tconst char * const s = SvPV_const(data->last_found, l);\n\t\t\tSSize_t old = b - data->last_start_min;\n                        assert(old >= 0);\n\n\t\t\tif (UTF)\n\t\t\t    old = utf8_hop_forward((U8*)s, old,\n                                               (U8 *) SvEND(data->last_found))\n                                - (U8*)s;\n\t\t\tl -= old;\n\t\t\t/* Get the added string: */\n\t\t\tlast_str = newSVpvn_utf8(s  + old, l, UTF);\n                        last_chrs = UTF ? utf8_length((U8*)(s + old),\n                                            (U8*)(s + old + l)) : l;\n\t\t\tif (deltanext == 0 && pos_before == b) {\n\t\t\t    /* What was added is a constant string */\n\t\t\t    if (mincount > 1) {\n\n\t\t\t\tSvGROW(last_str, (mincount * l) + 1);\n\t\t\t\trepeatcpy(SvPVX(last_str) + l,\n\t\t\t\t\t  SvPVX_const(last_str), l,\n                                          mincount - 1);\n\t\t\t\tSvCUR_set(last_str, SvCUR(last_str) * mincount);\n\t\t\t\t/* Add additional parts. */\n\t\t\t\tSvCUR_set(data->last_found,\n\t\t\t\t\t  SvCUR(data->last_found) - l);\n\t\t\t\tsv_catsv(data->last_found, last_str);\n\t\t\t\t{\n\t\t\t\t    SV * sv = data->last_found;\n\t\t\t\t    MAGIC *mg =\n\t\t\t\t\tSvUTF8(sv) && SvMAGICAL(sv) ?\n\t\t\t\t\tmg_find(sv, PERL_MAGIC_utf8) : NULL;\n\t\t\t\t    if (mg && mg->mg_len >= 0)\n\t\t\t\t\tmg->mg_len += last_chrs * (mincount-1);\n\t\t\t\t}\n                                last_chrs *= mincount;\n\t\t\t\tdata->last_end += l * (mincount - 1);\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    /* start offset must point into the last copy */\n\t\t\t    data->last_start_min += minnext * (mincount - 1);\n\t\t\t    data->last_start_max =\n                              is_inf\n                               ? SSize_t_MAX\n\t\t\t       : data->last_start_max +\n                                 (maxcount - 1) * (minnext + data->pos_delta);\n\t\t\t}\n\t\t    }\n\t\t    /* It is counted once already... */\n\t\t    data->pos_min += minnext * (mincount - counted);\n#if 0\nPerl_re_printf( aTHX_  \"counted=%\" UVuf \" deltanext=%\" UVuf\n                              \" SSize_t_MAX=%\" UVuf \" minnext=%\" UVuf\n                              \" maxcount=%\" UVuf \" mincount=%\" UVuf \"\\n\",\n    (UV)counted, (UV)deltanext, (UV)SSize_t_MAX, (UV)minnext, (UV)maxcount,\n    (UV)mincount);\nif (deltanext != SSize_t_MAX)\nPerl_re_printf( aTHX_  \"LHS=%\" UVuf \" RHS=%\" UVuf \"\\n\",\n    (UV)(-counted * deltanext + (minnext + deltanext) * maxcount\n          - minnext * mincount), (UV)(SSize_t_MAX - data->pos_delta));\n#endif\n\t\t    if (deltanext == SSize_t_MAX\n                        || -counted * deltanext + (minnext + deltanext) * maxcount - minnext * mincount >= SSize_t_MAX - data->pos_delta)\n\t\t        data->pos_delta = SSize_t_MAX;\n\t\t    else\n\t\t        data->pos_delta += - counted * deltanext +\n\t\t\t(minnext + deltanext) * maxcount - minnext * mincount;\n\t\t    if (mincount != maxcount) {\n\t\t\t /* Cannot extend fixed substrings found inside\n\t\t\t    the group.  */\n                        scan_commit(pRExC_state, data, minlenp, is_inf);\n\t\t\tif (mincount && last_str) {\n\t\t\t    SV * const sv = data->last_found;\n\t\t\t    MAGIC * const mg = SvUTF8(sv) && SvMAGICAL(sv) ?\n\t\t\t\tmg_find(sv, PERL_MAGIC_utf8) : NULL;\n\n\t\t\t    if (mg)\n\t\t\t\tmg->mg_len = -1;\n\t\t\t    sv_setsv(sv, last_str);\n\t\t\t    data->last_end = data->pos_min;\n\t\t\t    data->last_start_min = data->pos_min - last_chrs;\n\t\t\t    data->last_start_max = is_inf\n\t\t\t\t? SSize_t_MAX\n\t\t\t\t: data->pos_min + data->pos_delta - last_chrs;\n\t\t\t}\n\t\t\tdata->cur_is_floating = 1; /* float */\n\t\t    }\n\t\t    SvREFCNT_dec(last_str);\n\t\t}\n\t\tif (data && (fl & SF_HAS_EVAL))\n\t\t    data->flags |= SF_HAS_EVAL;\n\t      optimize_curly_tail:\n\t\tif (OP(oscan) != CURLYX) {\n\t\t    while (PL_regkind[OP(next = regnext(oscan))] == NOTHING\n\t\t\t   && NEXT_OFF(next))\n\t\t\tNEXT_OFF(oscan) += NEXT_OFF(next);\n\t\t}\n\t\tcontinue;\n\n\t    default:\n#ifdef DEBUGGING\n                Perl_croak(aTHX_ \"panic: unexpected varying REx opcode %d\",\n                                                                    OP(scan));\n#endif\n            case REF:\n            case CLUMP:\n\t\tif (flags & SCF_DO_SUBSTR) {\n                    /* Cannot expect anything... */\n                    scan_commit(pRExC_state, data, minlenp, is_inf);\n\t\t    data->cur_is_floating = 1; /* float */\n\t\t}\n\t\tis_inf = is_inf_internal = 1;\n\t\tif (flags & SCF_DO_STCLASS_OR) {\n                    if (OP(scan) == CLUMP) {\n                        /* Actually is any start char, but very few code points\n                         * aren't start characters */\n                        ssc_match_all_cp(data->start_class);\n                    }\n                    else {\n                        ssc_anything(data->start_class);\n                    }\n                }\n\t\tflags &= ~SCF_DO_STCLASS;\n\t\tbreak;\n\t    }\n\t}\n\telse if (OP(scan) == LNBREAK) {\n\t    if (flags & SCF_DO_STCLASS) {\n    \t        if (flags & SCF_DO_STCLASS_AND) {\n                    ssc_intersection(data->start_class,\n                                    PL_XPosix_ptrs[_CC_VERTSPACE], FALSE);\n                    ssc_clear_locale(data->start_class);\n                    ANYOF_FLAGS(data->start_class)\n                                                &= ~SSC_MATCHES_EMPTY_STRING;\n                }\n                else if (flags & SCF_DO_STCLASS_OR) {\n                    ssc_union(data->start_class,\n                              PL_XPosix_ptrs[_CC_VERTSPACE],\n                              FALSE);\n\t\t    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\n                    /* See commit msg for\n                     * 749e076fceedeb708a624933726e7989f2302f6a */\n                    ANYOF_FLAGS(data->start_class)\n                                                &= ~SSC_MATCHES_EMPTY_STRING;\n                }\n\t\tflags &= ~SCF_DO_STCLASS;\n            }\n\t    min++;\n            if (delta != SSize_t_MAX)\n                delta++;    /* Because of the 2 char string cr-lf */\n            if (flags & SCF_DO_SUBSTR) {\n                /* Cannot expect anything... */\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n    \t        data->pos_min += 1;\n                if (data->pos_delta != SSize_t_MAX) {\n                    data->pos_delta += 1;\n                }\n\t\tdata->cur_is_floating = 1; /* float */\n    \t    }\n\t}\n\telse if (REGNODE_SIMPLE(OP(scan))) {\n\n\t    if (flags & SCF_DO_SUBSTR) {\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n\t\tdata->pos_min++;\n\t    }\n\t    min++;\n\t    if (flags & SCF_DO_STCLASS) {\n                bool invert = 0;\n                SV* my_invlist = NULL;\n                U8 namedclass;\n\n                /* See commit msg 749e076fceedeb708a624933726e7989f2302f6a */\n                ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n\n\t\t/* Some of the logic below assumes that switching\n\t\t   locale on will only add false positives. */\n\t\tswitch (OP(scan)) {\n\n\t\tdefault:\n#ifdef DEBUGGING\n                   Perl_croak(aTHX_ \"panic: unexpected simple REx opcode %d\",\n                                                                     OP(scan));\n#endif\n\t\tcase SANY:\n\t\t    if (flags & SCF_DO_STCLASS_OR) /* Allow everything */\n\t\t\tssc_match_all_cp(data->start_class);\n\t\t    break;\n\n\t\tcase REG_ANY:\n                    {\n                        SV* REG_ANY_invlist = _new_invlist(2);\n                        REG_ANY_invlist = add_cp_to_invlist(REG_ANY_invlist,\n                                                            '\\n');\n                        if (flags & SCF_DO_STCLASS_OR) {\n                            ssc_union(data->start_class,\n                                      REG_ANY_invlist,\n                                      TRUE /* TRUE => invert, hence all but \\n\n                                            */\n                                      );\n                        }\n                        else if (flags & SCF_DO_STCLASS_AND) {\n                            ssc_intersection(data->start_class,\n                                             REG_ANY_invlist,\n                                             TRUE  /* TRUE => invert */\n                                             );\n                            ssc_clear_locale(data->start_class);\n                        }\n                        SvREFCNT_dec_NN(REG_ANY_invlist);\n\t\t    }\n\t\t    break;\n\n                case ANYOFD:\n                case ANYOFL:\n                case ANYOFPOSIXL:\n                case ANYOFH:\n                case ANYOF:\n\t\t    if (flags & SCF_DO_STCLASS_AND)\n\t\t\tssc_and(pRExC_state, data->start_class,\n                                (regnode_charclass *) scan);\n\t\t    else\n\t\t\tssc_or(pRExC_state, data->start_class,\n                                                          (regnode_charclass *) scan);\n\t\t    break;\n\n                case NANYOFM:\n                case ANYOFM:\n                  {\n                    SV* cp_list = get_ANYOFM_contents(scan);\n\n                    if (flags & SCF_DO_STCLASS_OR) {\n                        ssc_union(data->start_class, cp_list, invert);\n                    }\n                    else if (flags & SCF_DO_STCLASS_AND) {\n                        ssc_intersection(data->start_class, cp_list, invert);\n                    }\n\n                    SvREFCNT_dec_NN(cp_list);\n                    break;\n                  }\n\n\t\tcase NPOSIXL:\n                    invert = 1;\n                    /* FALLTHROUGH */\n\n\t\tcase POSIXL:\n                    namedclass = classnum_to_namedclass(FLAGS(scan)) + invert;\n                    if (flags & SCF_DO_STCLASS_AND) {\n                        bool was_there = cBOOL(\n                                          ANYOF_POSIXL_TEST(data->start_class,\n                                                                 namedclass));\n                        ANYOF_POSIXL_ZERO(data->start_class);\n                        if (was_there) {    /* Do an AND */\n                            ANYOF_POSIXL_SET(data->start_class, namedclass);\n                        }\n                        /* No individual code points can now match */\n                        data->start_class->invlist\n                                                = sv_2mortal(_new_invlist(0));\n                    }\n                    else {\n                        int complement = namedclass + ((invert) ? -1 : 1);\n\n                        assert(flags & SCF_DO_STCLASS_OR);\n\n                        /* If the complement of this class was already there,\n                         * the result is that they match all code points,\n                         * (\\d + \\D == everything).  Remove the classes from\n                         * future consideration.  Locale is not relevant in\n                         * this case */\n                        if (ANYOF_POSIXL_TEST(data->start_class, complement)) {\n                            ssc_match_all_cp(data->start_class);\n                            ANYOF_POSIXL_CLEAR(data->start_class, namedclass);\n                            ANYOF_POSIXL_CLEAR(data->start_class, complement);\n                        }\n                        else {  /* The usual case; just add this class to the\n                                   existing set */\n                            ANYOF_POSIXL_SET(data->start_class, namedclass);\n                        }\n                    }\n                    break;\n\n                case NPOSIXA:   /* For these, we always know the exact set of\n                                   what's matched */\n                    invert = 1;\n                    /* FALLTHROUGH */\n\t\tcase POSIXA:\n                    my_invlist = invlist_clone(PL_Posix_ptrs[FLAGS(scan)], NULL);\n                    goto join_posix_and_ascii;\n\n\t\tcase NPOSIXD:\n\t\tcase NPOSIXU:\n                    invert = 1;\n                    /* FALLTHROUGH */\n\t\tcase POSIXD:\n\t\tcase POSIXU:\n                    my_invlist = invlist_clone(PL_XPosix_ptrs[FLAGS(scan)], NULL);\n\n                    /* NPOSIXD matches all upper Latin1 code points unless the\n                     * target string being matched is UTF-8, which is\n                     * unknowable until match time.  Since we are going to\n                     * invert, we want to get rid of all of them so that the\n                     * inversion will match all */\n                    if (OP(scan) == NPOSIXD) {\n                        _invlist_subtract(my_invlist, PL_UpperLatin1,\n                                          &my_invlist);\n                    }\n\n                  join_posix_and_ascii:\n\n                    if (flags & SCF_DO_STCLASS_AND) {\n                        ssc_intersection(data->start_class, my_invlist, invert);\n                        ssc_clear_locale(data->start_class);\n                    }\n                    else {\n                        assert(flags & SCF_DO_STCLASS_OR);\n                        ssc_union(data->start_class, my_invlist, invert);\n                    }\n                    SvREFCNT_dec(my_invlist);\n\t\t}\n\t\tif (flags & SCF_DO_STCLASS_OR)\n\t\t    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\t\tflags &= ~SCF_DO_STCLASS;\n\t    }\n\t}\n\telse if (PL_regkind[OP(scan)] == EOL && flags & SCF_DO_SUBSTR) {\n\t    data->flags |= (OP(scan) == MEOL\n\t\t\t    ? SF_BEFORE_MEOL\n\t\t\t    : SF_BEFORE_SEOL);\n            scan_commit(pRExC_state, data, minlenp, is_inf);\n\n\t}\n\telse if (  PL_regkind[OP(scan)] == BRANCHJ\n\t\t /* Lookbehind, or need to calculate parens/evals/stclass: */\n\t\t   && (scan->flags || data || (flags & SCF_DO_STCLASS))\n\t\t   && (OP(scan) == IFMATCH || OP(scan) == UNLESSM))\n        {\n            if ( !PERL_ENABLE_POSITIVE_ASSERTION_STUDY\n                || OP(scan) == UNLESSM )\n            {\n                /* Negative Lookahead/lookbehind\n                   In this case we can't do fixed string optimisation.\n                */\n\n                SSize_t deltanext, minnext, fake = 0;\n                regnode *nscan;\n                regnode_ssc intrnl;\n                int f = 0;\n\n                StructCopy(&zero_scan_data, &data_fake, scan_data_t);\n                if (data) {\n                    data_fake.whilem_c = data->whilem_c;\n                    data_fake.last_closep = data->last_closep;\n\t\t}\n                else\n                    data_fake.last_closep = &fake;\n\t\tdata_fake.pos_delta = delta;\n                if ( flags & SCF_DO_STCLASS && !scan->flags\n                     && OP(scan) == IFMATCH ) { /* Lookahead */\n                    ssc_init(pRExC_state, &intrnl);\n                    data_fake.start_class = &intrnl;\n                    f |= SCF_DO_STCLASS_AND;\n\t\t}\n                if (flags & SCF_WHILEM_VISITED_POS)\n                    f |= SCF_WHILEM_VISITED_POS;\n                next = regnext(scan);\n                nscan = NEXTOPER(NEXTOPER(scan));\n\n                /* recurse study_chunk() for lookahead body */\n                minnext = study_chunk(pRExC_state, &nscan, minlenp, &deltanext,\n                                      last, &data_fake, stopparen,\n                                      recursed_depth, NULL, f, depth+1);\n                if (scan->flags) {\n                    if (   deltanext < 0\n                        || deltanext > (I32) U8_MAX\n                        || minnext > (I32)U8_MAX\n                        || minnext + deltanext > (I32)U8_MAX)\n                    {\n\t\t\tFAIL2(\"Lookbehind longer than %\" UVuf \" not implemented\",\n                              (UV)U8_MAX);\n                    }\n\n                    /* The 'next_off' field has been repurposed to count the\n                     * additional starting positions to try beyond the initial\n                     * one.  (This leaves it at 0 for non-variable length\n                     * matches to avoid breakage for those not using this\n                     * extension) */\n                    if (deltanext) {\n                        scan->next_off = deltanext;\n                        ckWARNexperimental(RExC_parse,\n                            WARN_EXPERIMENTAL__VLB,\n                            \"Variable length lookbehind is experimental\");\n                    }\n                    scan->flags = (U8)minnext + deltanext;\n                }\n                if (data) {\n                    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))\n                        pars++;\n                    if (data_fake.flags & SF_HAS_EVAL)\n                        data->flags |= SF_HAS_EVAL;\n                    data->whilem_c = data_fake.whilem_c;\n                }\n                if (f & SCF_DO_STCLASS_AND) {\n\t\t    if (flags & SCF_DO_STCLASS_OR) {\n\t\t\t/* OR before, AND after: ideally we would recurse with\n\t\t\t * data_fake to get the AND applied by study of the\n\t\t\t * remainder of the pattern, and then derecurse;\n\t\t\t * *** HACK *** for now just treat as \"no information\".\n\t\t\t * See [perl #56690].\n\t\t\t */\n\t\t\tssc_init(pRExC_state, data->start_class);\n\t\t    }  else {\n                        /* AND before and after: combine and continue.  These\n                         * assertions are zero-length, so can match an EMPTY\n                         * string */\n\t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) &intrnl);\n                        ANYOF_FLAGS(data->start_class)\n                                                   |= SSC_MATCHES_EMPTY_STRING;\n\t\t    }\n                }\n\t    }\n#if PERL_ENABLE_POSITIVE_ASSERTION_STUDY\n            else {\n                /* Positive Lookahead/lookbehind\n                   In this case we can do fixed string optimisation,\n                   but we must be careful about it. Note in the case of\n                   lookbehind the positions will be offset by the minimum\n                   length of the pattern, something we won't know about\n                   until after the recurse.\n                */\n                SSize_t deltanext, fake = 0;\n                regnode *nscan;\n                regnode_ssc intrnl;\n                int f = 0;\n                /* We use SAVEFREEPV so that when the full compile\n                    is finished perl will clean up the allocated\n                    minlens when it's all done. This way we don't\n                    have to worry about freeing them when we know\n                    they wont be used, which would be a pain.\n                 */\n                SSize_t *minnextp;\n                Newx( minnextp, 1, SSize_t );\n                SAVEFREEPV(minnextp);\n\n                if (data) {\n                    StructCopy(data, &data_fake, scan_data_t);\n                    if ((flags & SCF_DO_SUBSTR) && data->last_found) {\n                        f |= SCF_DO_SUBSTR;\n                        if (scan->flags)\n                            scan_commit(pRExC_state, &data_fake, minlenp, is_inf);\n                        data_fake.last_found=newSVsv(data->last_found);\n                    }\n                }\n                else\n                    data_fake.last_closep = &fake;\n                data_fake.flags = 0;\n                data_fake.substrs[0].flags = 0;\n                data_fake.substrs[1].flags = 0;\n\t\tdata_fake.pos_delta = delta;\n                if (is_inf)\n\t            data_fake.flags |= SF_IS_INF;\n                if ( flags & SCF_DO_STCLASS && !scan->flags\n                     && OP(scan) == IFMATCH ) { /* Lookahead */\n                    ssc_init(pRExC_state, &intrnl);\n                    data_fake.start_class = &intrnl;\n                    f |= SCF_DO_STCLASS_AND;\n                }\n                if (flags & SCF_WHILEM_VISITED_POS)\n                    f |= SCF_WHILEM_VISITED_POS;\n                next = regnext(scan);\n                nscan = NEXTOPER(NEXTOPER(scan));\n\n                /* positive lookahead study_chunk() recursion */\n                *minnextp = study_chunk(pRExC_state, &nscan, minnextp,\n                                        &deltanext, last, &data_fake,\n                                        stopparen, recursed_depth, NULL,\n                                        f, depth+1);\n                if (scan->flags) {\n                    assert(0);  /* This code has never been tested since this\n                                   is normally not compiled */\n                    if (   deltanext < 0\n                        || deltanext > (I32) U8_MAX\n                        || *minnextp > (I32)U8_MAX\n                        || *minnextp + deltanext > (I32)U8_MAX)\n                    {\n\t\t\tFAIL2(\"Lookbehind longer than %\" UVuf \" not implemented\",\n                              (UV)U8_MAX);\n                    }\n\n                    if (deltanext) {\n                        scan->next_off = deltanext;\n                    }\n                    scan->flags = (U8)*minnextp + deltanext;\n                }\n\n                *minnextp += min;\n\n                if (f & SCF_DO_STCLASS_AND) {\n                    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) &intrnl);\n                    ANYOF_FLAGS(data->start_class) |= SSC_MATCHES_EMPTY_STRING;\n                }\n                if (data) {\n                    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))\n                        pars++;\n                    if (data_fake.flags & SF_HAS_EVAL)\n                        data->flags |= SF_HAS_EVAL;\n                    data->whilem_c = data_fake.whilem_c;\n                    if ((flags & SCF_DO_SUBSTR) && data_fake.last_found) {\n                        int i;\n                        if (RExC_rx->minlen<*minnextp)\n                            RExC_rx->minlen=*minnextp;\n                        scan_commit(pRExC_state, &data_fake, minnextp, is_inf);\n                        SvREFCNT_dec_NN(data_fake.last_found);\n\n                        for (i = 0; i < 2; i++) {\n                            if (data_fake.substrs[i].minlenp != minlenp) {\n                                data->substrs[i].min_offset =\n                                            data_fake.substrs[i].min_offset;\n                                data->substrs[i].max_offset =\n                                            data_fake.substrs[i].max_offset;\n                                data->substrs[i].minlenp =\n                                            data_fake.substrs[i].minlenp;\n                                data->substrs[i].lookbehind += scan->flags;\n                            }\n                        }\n                    }\n                }\n\t    }\n#endif\n\t}\n\n\telse if (OP(scan) == OPEN) {\n\t    if (stopparen != (I32)ARG(scan))\n\t        pars++;\n\t}\n\telse if (OP(scan) == CLOSE) {\n\t    if (stopparen == (I32)ARG(scan)) {\n\t        break;\n\t    }\n\t    if ((I32)ARG(scan) == is_par) {\n\t\tnext = regnext(scan);\n\n\t\tif ( next && (OP(next) != WHILEM) && next < last)\n\t\t    is_par = 0;\t\t/* Disable optimization */\n\t    }\n\t    if (data)\n\t\t*(data->last_closep) = ARG(scan);\n\t}\n\telse if (OP(scan) == EVAL) {\n\t\tif (data)\n\t\t    data->flags |= SF_HAS_EVAL;\n\t}\n\telse if ( PL_regkind[OP(scan)] == ENDLIKE ) {\n\t    if (flags & SCF_DO_SUBSTR) {\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n\t\tflags &= ~SCF_DO_SUBSTR;\n\t    }\n\t    if (data && OP(scan)==ACCEPT) {\n\t        data->flags |= SCF_SEEN_ACCEPT;\n\t        if (stopmin > min)\n\t            stopmin = min;\n\t    }\n\t}\n\telse if (OP(scan) == LOGICAL && scan->flags == 2) /* Embedded follows */\n\t{\n\t\tif (flags & SCF_DO_SUBSTR) {\n                    scan_commit(pRExC_state, data, minlenp, is_inf);\n\t\t    data->cur_is_floating = 1; /* float */\n\t\t}\n\t\tis_inf = is_inf_internal = 1;\n\t\tif (flags & SCF_DO_STCLASS_OR) /* Allow everything */\n\t\t    ssc_anything(data->start_class);\n\t\tflags &= ~SCF_DO_STCLASS;\n\t}\n\telse if (OP(scan) == GPOS) {\n            if (!(RExC_rx->intflags & PREGf_GPOS_FLOAT) &&\n\t        !(delta || is_inf || (data && data->pos_delta)))\n\t    {\n                if (!(RExC_rx->intflags & PREGf_ANCH) && (flags & SCF_DO_SUBSTR))\n                    RExC_rx->intflags |= PREGf_ANCH_GPOS;\n\t        if (RExC_rx->gofs < (STRLEN)min)\n\t\t    RExC_rx->gofs = min;\n            } else {\n                RExC_rx->intflags |= PREGf_GPOS_FLOAT;\n                RExC_rx->gofs = 0;\n            }\n\t}\n#ifdef TRIE_STUDY_OPT\n#ifdef FULL_TRIE_STUDY\n        else if (PL_regkind[OP(scan)] == TRIE) {\n            /* NOTE - There is similar code to this block above for handling\n               BRANCH nodes on the initial study.  If you change stuff here\n               check there too. */\n            regnode *trie_node= scan;\n            regnode *tail= regnext(scan);\n            reg_trie_data *trie = (reg_trie_data*)RExC_rxi->data->data[ ARG(scan) ];\n            SSize_t max1 = 0, min1 = SSize_t_MAX;\n            regnode_ssc accum;\n\n            if (flags & SCF_DO_SUBSTR) { /* XXXX Add !SUSPEND? */\n                /* Cannot merge strings after this. */\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n            }\n            if (flags & SCF_DO_STCLASS)\n                ssc_init_zero(pRExC_state, &accum);\n\n            if (!trie->jump) {\n                min1= trie->minlen;\n                max1= trie->maxlen;\n            } else {\n                const regnode *nextbranch= NULL;\n                U32 word;\n\n                for ( word=1 ; word <= trie->wordcount ; word++)\n                {\n                    SSize_t deltanext=0, minnext=0, f = 0, fake;\n                    regnode_ssc this_class;\n\n                    StructCopy(&zero_scan_data, &data_fake, scan_data_t);\n                    if (data) {\n                        data_fake.whilem_c = data->whilem_c;\n                        data_fake.last_closep = data->last_closep;\n                    }\n                    else\n                        data_fake.last_closep = &fake;\n\t\t    data_fake.pos_delta = delta;\n                    if (flags & SCF_DO_STCLASS) {\n                        ssc_init(pRExC_state, &this_class);\n                        data_fake.start_class = &this_class;\n                        f = SCF_DO_STCLASS_AND;\n                    }\n                    if (flags & SCF_WHILEM_VISITED_POS)\n                        f |= SCF_WHILEM_VISITED_POS;\n\n                    if (trie->jump[word]) {\n                        if (!nextbranch)\n                            nextbranch = trie_node + trie->jump[0];\n                        scan= trie_node + trie->jump[word];\n                        /* We go from the jump point to the branch that follows\n                           it. Note this means we need the vestigal unused\n                           branches even though they arent otherwise used. */\n                        /* optimise study_chunk() for TRIE */\n                        minnext = study_chunk(pRExC_state, &scan, minlenp,\n                            &deltanext, (regnode *)nextbranch, &data_fake,\n                            stopparen, recursed_depth, NULL, f, depth+1);\n                    }\n                    if (nextbranch && PL_regkind[OP(nextbranch)]==BRANCH)\n                        nextbranch= regnext((regnode*)nextbranch);\n\n                    if (min1 > (SSize_t)(minnext + trie->minlen))\n                        min1 = minnext + trie->minlen;\n                    if (deltanext == SSize_t_MAX) {\n                        is_inf = is_inf_internal = 1;\n                        max1 = SSize_t_MAX;\n                    } else if (max1 < (SSize_t)(minnext + deltanext + trie->maxlen))\n                        max1 = minnext + deltanext + trie->maxlen;\n\n                    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))\n                        pars++;\n                    if (data_fake.flags & SCF_SEEN_ACCEPT) {\n                        if ( stopmin > min + min1)\n\t                    stopmin = min + min1;\n\t                flags &= ~SCF_DO_SUBSTR;\n\t                if (data)\n\t                    data->flags |= SCF_SEEN_ACCEPT;\n\t            }\n                    if (data) {\n                        if (data_fake.flags & SF_HAS_EVAL)\n                            data->flags |= SF_HAS_EVAL;\n                        data->whilem_c = data_fake.whilem_c;\n                    }\n                    if (flags & SCF_DO_STCLASS)\n                        ssc_or(pRExC_state, &accum, (regnode_charclass *) &this_class);\n                }\n            }\n            if (flags & SCF_DO_SUBSTR) {\n                data->pos_min += min1;\n                data->pos_delta += max1 - min1;\n                if (max1 != min1 || is_inf)\n                    data->cur_is_floating = 1; /* float */\n            }\n            min += min1;\n            if (delta != SSize_t_MAX) {\n                if (SSize_t_MAX - (max1 - min1) >= delta)\n                    delta += max1 - min1;\n                else\n                    delta = SSize_t_MAX;\n            }\n            if (flags & SCF_DO_STCLASS_OR) {\n                ssc_or(pRExC_state, data->start_class, (regnode_charclass *) &accum);\n                if (min1) {\n                    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n                    flags &= ~SCF_DO_STCLASS;\n                }\n            }\n            else if (flags & SCF_DO_STCLASS_AND) {\n                if (min1) {\n                    ssc_and(pRExC_state, data->start_class, (regnode_charclass *) &accum);\n                    flags &= ~SCF_DO_STCLASS;\n                }\n                else {\n                    /* Switch to OR mode: cache the old value of\n                     * data->start_class */\n\t\t    INIT_AND_WITHP;\n                    StructCopy(data->start_class, and_withp, regnode_ssc);\n                    flags &= ~SCF_DO_STCLASS_AND;\n                    StructCopy(&accum, data->start_class, regnode_ssc);\n                    flags |= SCF_DO_STCLASS_OR;\n                }\n            }\n            scan= tail;\n            continue;\n        }\n#else\n\telse if (PL_regkind[OP(scan)] == TRIE) {\n\t    reg_trie_data *trie = (reg_trie_data*)RExC_rxi->data->data[ ARG(scan) ];\n\t    U8*bang=NULL;\n\n\t    min += trie->minlen;\n\t    delta += (trie->maxlen - trie->minlen);\n\t    flags &= ~SCF_DO_STCLASS; /* xxx */\n            if (flags & SCF_DO_SUBSTR) {\n                /* Cannot expect anything... */\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n    \t        data->pos_min += trie->minlen;\n    \t        data->pos_delta += (trie->maxlen - trie->minlen);\n\t\tif (trie->maxlen != trie->minlen)\n\t\t    data->cur_is_floating = 1; /* float */\n    \t    }\n    \t    if (trie->jump) /* no more substrings -- for now /grr*/\n               flags &= ~SCF_DO_SUBSTR;\n\t}\n#endif /* old or new */\n#endif /* TRIE_STUDY_OPT */\n\n\t/* Else: zero-length, ignore. */\n\tscan = regnext(scan);\n    }\n\n  finish:\n    if (frame) {\n        /* we need to unwind recursion. */\n        depth = depth - 1;\n\n        DEBUG_STUDYDATA(\"frame-end\", data, depth, is_inf);\n        DEBUG_PEEP(\"fend\", scan, depth, flags);\n\n        /* restore previous context */\n        last = frame->last_regnode;\n        scan = frame->next_regnode;\n        stopparen = frame->stopparen;\n        recursed_depth = frame->prev_recursed_depth;\n\n        RExC_frame_last = frame->prev_frame;\n        frame = frame->this_prev_frame;\n        goto fake_study_recurse;\n    }\n\n    assert(!frame);\n    DEBUG_STUDYDATA(\"pre-fin\", data, depth, is_inf);\n\n    *scanp = scan;\n    *deltap = is_inf_internal ? SSize_t_MAX : delta;\n\n    if (flags & SCF_DO_SUBSTR && is_inf)\n\tdata->pos_delta = SSize_t_MAX - data->pos_min;\n    if (is_par > (I32)U8_MAX)\n\tis_par = 0;\n    if (is_par && pars==1 && data) {\n\tdata->flags |= SF_IN_PAR;\n\tdata->flags &= ~SF_HAS_PAR;\n    }\n    else if (pars && data) {\n\tdata->flags |= SF_HAS_PAR;\n\tdata->flags &= ~SF_IN_PAR;\n    }\n    if (flags & SCF_DO_STCLASS_OR)\n\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n    if (flags & SCF_TRIE_RESTUDY)\n        data->flags |= \tSCF_TRIE_RESTUDY;\n\n    DEBUG_STUDYDATA(\"post-fin\", data, depth, is_inf);\n\n    {\n        SSize_t final_minlen= min < stopmin ? min : stopmin;\n\n        if (!(RExC_seen & REG_UNBOUNDED_QUANTIFIER_SEEN)) {\n            if (final_minlen > SSize_t_MAX - delta)\n                RExC_maxlen = SSize_t_MAX;\n            else if (RExC_maxlen < final_minlen + delta)\n                RExC_maxlen = final_minlen + delta;\n        }\n        return final_minlen;\n    }\n    NOT_REACHED; /* NOTREACHED */\n}",
        "start_line": 4454
      }
    ],
    "code_context": "Called Methods:\n- Perl_save_pushptr: void /* <=== Perl_save_pushptr */ \nPerl_save_pushptr(pTHX_ void *const ptr, const int type)\n{\n    dSS_ADD;\n    SS_ADD_PTR(ptr);\n    SS_ADD_UV(type);\n    SS_ADD_END(2);\n}\n- IFTHEN: #define\tIFTHEN                \t75\t/* 0x4b Switch, should be preceded by switcher. */ /* <=== regnodes.h:89:89:IFTHEN:0 */ \n- EOL: #define\tEOL                   \t4\t/* 0x04 type alias */ /* <=== regnodes.h:18:18:EOL:0 */ \n- CLOSE: #define\tCLOSE                 \t57\t/* 0x39 Close corresponding OPEN of #n. */ /* <=== regnodes.h:71:71:CLOSE:0 */ \n- dSS_ADD: #define dSS_ADD \\ /* <=== scope.h:122:124:dSS_ADD:0 */ \n    I32 ix = PL_savestack_ix;     \\\n    ANY *ssp = &PL_savestack[ix]\n- OP: #define\tOP(p)\t\t((p)->type) /* <=== regcomp.h:330:330:OP:1 */ \n- ARG: #define ARG(p) ARG_VALUE(ARG_LOC(p)) /* <=== regcomp.h:297:297:ARG:1 */ \n- BRANCHJ: #define\tBRANCHJ               \t71\t/* 0x47 BRANCH with long offset. */ /* <=== regnodes.h:85:85:BRANCHJ:0 */ \n- SUSPEND: #define\tSUSPEND               \t74\t/* 0x4a \"Independent\" sub-RE. */ /* <=== regnodes.h:88:88:SUSPEND:0 */ \n- DEFINEP: #define\tDEFINEP               \t88\t/* 0x58 Never execute directly. */ /* <=== regnodes.h:102:102:DEFINEP:0 */ \n- SS_ADD_UV: #define SS_ADD_UV(u)    ((ssp++)->any_uv = (UV)(u)) /* <=== scope.h:138:138:SS_ADD_UV:1 */ \n- LNBREAK: #define\tLNBREAK               \t99\t/* 0x63 generic newline pattern */ /* <=== regnodes.h:113:113:LNBREAK:0 */ \n- EXACTL: #define\tEXACTL                \t36\t/* 0x24 Like EXACT, but /l is in effect (used so locale-related warnings can be checked for). */ /* <=== regnodes.h:50:50:EXACTL:0 */ \n- GOSUB: #define\tGOSUB                 \t85\t/* 0x55 recurse to paren arg1 at (signed) ofs arg2 */ /* <=== regnodes.h:99:99:GOSUB:0 */ \n- IFMATCH: #define\tIFMATCH               \t72\t/* 0x48 Succeeds if the following matches; non-zero flags \"f\", next_off \"o\" means lookbehind assertion starting \"f..(f-o)\" characters before current */ /* <=== regnodes.h:86:86:IFMATCH:0 */ \n- Perl_savestack_grow: void /* <=== Perl_savestack_grow */ \nPerl_savestack_grow(pTHX)\n{\n    IV new_max;\n#ifdef STRESS_REALLOC\n    new_max = PL_savestack_max + SS_MAXPUSH;\n#else\n    new_max = GROW(PL_savestack_max);\n#endif\n    /* Note that we allocate SS_MAXPUSH slots higher than ss_max\n     * so that SS_ADD_END(), SSGROW() etc can do a simper check */\n    Renew(PL_savestack, new_max + SS_MAXPUSH, ANY);\n    PL_savestack_max = new_max;\n}\n- SSize_t_MAX: #define SSize_t_MAX (SSize_t)(~(Size_t)0 >> 1) /* <=== perl.h:1759:1759:SSize_t_MAX:0 */ \n- OPEN: #define\tOPEN                  \t56\t/* 0x38 Mark this point in input as start of #n. */ /* <=== regnodes.h:70:70:OPEN:0 */ \n- REGNODE_SIMPLE: #define REGNODE_SIMPLE(node) (PL_simple_bitmask[(node) >> 3] & (1 << ((node) & 7))) /* <=== regnodes.h:777:777:REGNODE_SIMPLE:1 */ \n- EXACT_ONLY8: #define\tEXACT_ONLY8           \t44\t/* 0x2c Like EXACT, but only UTF-8 encoded targets can match */ /* <=== regnodes.h:58:58:EXACT_ONLY8:0 */ \n- UNLESSM: #define\tUNLESSM               \t73\t/* 0x49 Fails if the following matches; non-zero flags \"f\", next_off \"o\" means lookbehind assertion starting \"f..(f-o)\" characters before current */ /* <=== regnodes.h:87:87:UNLESSM:0 */ \n- EXACT: #define\tEXACT                 \t35\t/* 0x23 Match this string (preceded by length). */ /* <=== regnodes.h:49:49:EXACT:0 */ \n- SCF_DO_STCLASS: #define SCF_DO_STCLASS\t\t(SCF_DO_STCLASS_AND|SCF_DO_STCLASS_OR) /* <=== regcomp.c:570:570:SCF_DO_STCLASS:0 */ \n- BRANCH: #define\tBRANCH                \t34\t/* 0x22 Match this alternative, or the next... */ /* <=== regnodes.h:48:48:BRANCH:0 */ \n- END: #define\tEND                   \t0\t/* 0000 End of program. */ /* <=== regnodes.h:12:12:END:0 */ \n- SCF_DO_SUBSTR: #define SCF_DO_SUBSTR\t\t0x0400 /* <=== regcomp.c:566:566:SCF_DO_SUBSTR:0 */ \n- FAIL: #define\tFAIL(msg) _FAIL(\t\t\t    \\ /* <=== regcomp.c:739:741:FAIL:1 */ \n    Perl_croak(aTHX_ \"%s in regex m/%\" UTF8f \"%s/\",\t    \\\n\t    msg, UTF8fARG(UTF, len, RExC_precomp), ellipses))\n- SS_ADD_END: #define SS_ADD_END(need) \\ /* <=== scope.h:126:132:SS_ADD_END:1 */ \n    assert((need) <= SS_MAXPUSH);                               \\\n    ix += (need);                                               \\\n    PL_savestack_ix = ix;                                       \\\n    assert(ix <= PL_savestack_max + SS_MAXPUSH);                \\\n    if (UNLIKELY(ix > PL_savestack_max)) savestack_grow();      \\\n    assert(PL_savestack_ix <= PL_savestack_max);\n- SS_ADD_PTR: #define SS_ADD_PTR(p)   ((ssp++)->any_ptr = (void*)(p)) /* <=== scope.h:139:139:SS_ADD_PTR:1 */ \n- REGNODE_VARIES: #define REGNODE_VARIES(node) (PL_varies_bitmask[(node) >> 3] & (1 << ((node) & 7))) /* <=== regnodes.h:754:754:REGNODE_VARIES:1 */ \n\nType Definitions:\n- I32: typedef I32TYPE I32;\n- U32: typedef U32TYPE U32;\n- scan_data_t: typedef struct scan_data_t {\n    /*I32 len_min;      unused */\n    /*I32 len_delta;    unused */\n    SSize_t pos_min;\n    SSize_t pos_delta;\n    SV *last_found;\n    SSize_t last_end;\t    /* min value, <0 unless valid. */\n    SSize_t last_start_min;\n    SSize_t last_start_max;\n    U8      cur_is_floating; /* whether the last_* values should be set as\n                              * the next fixed (0) or floating (1)\n                              * substring */\n\n    /* [0] is longest fixed substring so far, [1] is longest float so far */\n    struct scan_data_substrs  substrs[2];\n\n    I32 flags;             /* common SF_* and SCF_* flags */\n    I32 whilem_c;\n    SSize_t *last_closep;\n    regnode_ssc *start_class;\n} scan_data_t;\n- RExC_state_t: struct RExC_state_t {\n    U32\t\tflags;\t\t\t/* RXf_* are we folding, multilining? */\n    U32\t\tpm_flags;\t\t/* PMf_* stuff from the calling PMOP */\n    char\t*precomp;\t\t/* uncompiled string. */\n    char\t*precomp_end;\t\t/* pointer to end of uncompiled string. */\n    REGEXP\t*rx_sv;\t\t\t/* The SV that is the regexp. */\n    regexp\t*rx;                    /* perl core regexp structure */\n    regexp_internal\t*rxi;           /* internal data for regexp object\n                                           pprivate field */\n    char\t*start;\t\t\t/* Start of input for compile */\n    char\t*end;\t\t\t/* End of input for compile */\n    char\t*parse;\t\t\t/* Input-scan pointer. */\n    char        *copy_start;            /* start of copy of input within\n                                           constructed parse string */\n    char        *save_copy_start;       /* Provides one level of saving\n                                           and restoring 'copy_start' */\n    char        *copy_start_in_input;   /* Position in input string\n                                           corresponding to copy_start */\n    SSize_t\twhilem_seen;\t\t/* number of WHILEM in this expr */\n    regnode\t*emit_start;\t\t/* Start of emitted-code area */\n    regnode_offset emit;\t\t/* Code-emit pointer */\n    I32\t\tnaughty;\t\t/* How bad is this pattern? */\n    I32\t\tsawback;\t\t/* Did we see \\1, ...? */\n    U32\t\tseen;\n    SSize_t\tsize;\t\t\t/* Number of regnode equivalents in\n                                           pattern */\n\n    /* position beyond 'precomp' of the warning message furthest away from\n     * 'precomp'.  During the parse, no warnings are raised for any problems\n     * earlier in the parse than this position.  This works if warnings are\n     * raised the first time a given spot is parsed, and if only one\n     * independent warning is raised for any given spot */\n    Size_t\tlatest_warn_offset;\n\n    I32         npar;                   /* Capture buffer count so far in the\n                                           parse, (OPEN) plus one. (\"par\" 0 is\n                                           the whole pattern)*/\n    I32         total_par;              /* During initial parse, is either 0,\n                                           or -1; the latter indicating a\n                                           reparse is needed.  After that pass,\n                                           it is what 'npar' became after the\n                                           pass.  Hence, it being > 0 indicates\n                                           we are in a reparse situation */\n    I32\t\tnestroot;\t\t/* root parens we are in - used by\n                                           accept */\n    I32\t\tseen_zerolen;\n    regnode_offset *open_parens;\t/* offsets to open parens */\n    regnode_offset *close_parens;\t/* offsets to close parens */\n    I32      parens_buf_size;           /* #slots malloced open/close_parens */\n    regnode     *end_op;                /* END node in program */\n    I32\t\tutf8;\t\t/* whether the pattern is utf8 or not */\n    I32\t\torig_utf8;\t/* whether the pattern was originally in utf8 */\n\t\t\t\t/* XXX use this for future optimisation of case\n\t\t\t\t * where pattern must be upgraded to utf8. */\n    I32\t\tuni_semantics;\t/* If a d charset modifier should use unicode\n\t\t\t\t   rules, even if the pattern is not in\n\t\t\t\t   utf8 */\n    HV\t\t*paren_names;\t\t/* Paren names */\n\n    regnode\t**recurse;\t\t/* Recurse regops */\n    I32         recurse_count;          /* Number of recurse regops we have generated */\n    U8          *study_chunk_recursed;  /* bitmap of which subs we have moved\n                                           through */\n    U32         study_chunk_recursed_bytes;  /* bytes in bitmap */\n    I32\t\tin_lookbehind;\n    I32\t\tcontains_locale;\n    I32\t\toverride_recoding;\n#ifdef EBCDIC\n    I32\t\trecode_x_to_native;\n#endif\n    I32\t\tin_multi_char_class;\n    struct reg_code_blocks *code_blocks;/* positions of literal (?{})\n\t\t\t\t\t    within pattern */\n    int\t\tcode_index;\t\t/* next code_blocks[] slot */\n    SSize_t     maxlen;                        /* mininum possible number of chars in string to match */\n    scan_frame *frame_head;\n    scan_frame *frame_last;\n    U32         frame_count;\n    AV         *warn_text;\n    HV         *unlexed_names;\n#ifdef ADD_TO_REGEXEC\n    char \t*starttry;\t\t/* -Dr: where regtry was called. */\n#define RExC_starttry\t(pRExC_state->starttry)\n#endif\n    SV\t\t*runtime_code_qr;\t/* qr with the runtime code blocks */\n#ifdef DEBUGGING\n    const char  *lastparse;\n    I32         lastnum;\n    AV          *paren_name_list;       /* idx -> name */\n    U32         study_chunk_recursed_count;\n    SV          *mysv1;\n    SV          *mysv2;\n\n#define RExC_lastparse\t(pRExC_state->lastparse)\n#define RExC_lastnum\t(pRExC_state->lastnum)\n#define RExC_paren_name_list    (pRExC_state->paren_name_list)\n#define RExC_study_chunk_recursed_count    (pRExC_state->study_chunk_recursed_count)\n#define RExC_mysv\t(pRExC_state->mysv1)\n#define RExC_mysv1\t(pRExC_state->mysv1)\n#define RExC_mysv2\t(pRExC_state->mysv2)\n\n#endif\n    bool        seen_d_op;\n    bool        strict;\n    bool        study_started;\n    bool        in_script_run;\n    bool        use_BRANCHJ;\n}\n- IV: typedef IVTYPE IV;\n- ANY: typedef union any ANY;\n- regnode: struct regnode {\n    U8\tflags;\n    U8  type;\n    U16 next_off;\n}\n- scan_frame: typedef struct scan_frame {\n    regnode *last_regnode;      /* last node to process in this frame */\n    regnode *next_regnode;      /* next node to process when last is reached */\n    U32 prev_recursed_depth;\n    I32 stopparen;              /* what stopparen do we use */\n\n    struct scan_frame *this_prev_frame; /* this previous frame */\n    struct scan_frame *prev_frame;      /* previous frame */\n    struct scan_frame *next_frame;      /* next frame */\n} scan_frame;\n\nImports:\n- #include \"unicode_constants.h\"\n- #include \"invlist_inline.h\"\n- #include \"re_top.h\"\n- #include \"uni_keywords.h\"\n- #  include \"re_comp.h\"\n- #include \"EXTERN.h\"\n- #include \"dquote_inline.h\"\n- #include \"perl.h\"\n- #  include \"regcomp.h\"",
    "commit_msg": "regcomp.c: Prevent integer overflow from nested regex quantifiers.\n\n(CVE-2020-10543) On 32bit systems the size calculations for nested regular\nexpression quantifiers could overflow causing heap memory corruption.\n\nFixes: Perl/perl5-security#125\n(cherry picked from commit bfd31397db5dc1a5c5d3e0a1f753a4f89a736e71)",
    "cve_desc": "Perl before 5.30.3 on 32-bit platforms allows a heap-based buffer overflow because nested regular expression quantifiers have an integer overflow.",
    "year": 2020,
    "filename": "regcomp.c",
    "commit_url": "\"https://github.com/perl/perl5/commit/897d1f7fd515b828e4b198d8b8bef76c6faf03ed\""
  },
  {
    "repository": "libvirt/libvirt",
    "cve_id": "CVE-2020-10701",
    "cwe_list": [
      "CWE-862"
    ],
    "commit_hash": "4cc90c2e62df653e909ad31fd810224bf8bcf913",
    "short_hash": "4cc90c2e",
    "vulnerableMethods_before": [
      {
        "filename": "src/libvirt-domain.c",
        "method_name": "virDomainAgentSetResponseTimeout",
        "raw_code": "int /* <=== virDomainAgentSetResponseTimeout */ \nvirDomainAgentSetResponseTimeout(virDomainPtr domain,\n                                 int timeout,\n                                 unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"timeout=%i, flags=0x%x\",\n                     timeout, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    if (conn->driver->domainAgentSetResponseTimeout) {\n        if (conn->driver->domainAgentSetResponseTimeout(domain, timeout, flags) < 0)\n            goto error;\n        return 0;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}",
        "start_line": 12564
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "src/libvirt-domain.c",
        "method_name": "virDomainAgentSetResponseTimeout",
        "raw_code": "int /* <=== virDomainAgentSetResponseTimeout */ \nvirDomainAgentSetResponseTimeout(virDomainPtr domain,\n                                 int timeout,\n                                 unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"timeout=%i, flags=0x%x\",\n                     timeout, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainAgentSetResponseTimeout) {\n        if (conn->driver->domainAgentSetResponseTimeout(domain, timeout, flags) < 0)\n            goto error;\n        return 0;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}",
        "start_line": 12564
      }
    ],
    "code_context": "Called Methods:\n- virErrorGenericFailure: static void /* <=== virErrorGenericFailure */ \nvirErrorGenericFailure(virErrorPtr err)\n{\n    err->code = VIR_ERR_INTERNAL_ERROR;\n    err->domain = VIR_FROM_NONE;\n    err->level = VIR_ERR_ERROR;\n    err->message = g_strdup(_(\"An error occurred, but the cause is unknown\"));\n}\n- virObjectUnlock: void /* <=== virObjectUnlock */ \nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}\n- virClassIsDerivedFrom: bool /* <=== virClassIsDerivedFrom */ \nvirClassIsDerivedFrom(virClassPtr klass,\n                      virClassPtr parent)\n{\n    while (klass) {\n        if (klass->magic == parent->magic)\n            return true;\n        klass = klass->parent;\n    }\n    return false;\n}\n- virDefaultErrorFunc: void /* <=== virDefaultErrorFunc */ \nvirDefaultErrorFunc(virErrorPtr err)\n{\n    const char *lvl = \"\", *dom = \"\", *domain = \"\", *network = \"\";\n    int len;\n\n    if ((err == NULL) || (err->code == VIR_ERR_OK))\n        return;\n    switch (err->level) {\n        case VIR_ERR_NONE:\n            lvl = \"\";\n            break;\n        case VIR_ERR_WARNING:\n            lvl = _(\"warning\");\n            break;\n        case VIR_ERR_ERROR:\n            lvl = _(\"error\");\n            break;\n    }\n    dom = virErrorDomainTypeToString(err->domain);\n    if (!dom)\n        dom = \"Unknown\";\n    if ((err->dom != NULL) && (err->code != VIR_ERR_INVALID_DOMAIN)) {\n        domain = err->dom->name;\n    } else if ((err->net != NULL) && (err->code != VIR_ERR_INVALID_NETWORK)) {\n        network = err->net->name;\n    }\n    len = strlen(err->message);\n    if ((err->domain == VIR_FROM_XML) && (err->code == VIR_ERR_XML_DETAIL) &&\n        (err->int1 != 0))\n        fprintf(stderr, \"libvirt: %s %s %s%s: line %d: %s\",\n                dom, lvl, domain, network, err->int1, err->message);\n    else if ((len == 0) || (err->message[len - 1] != '\\n'))\n        fprintf(stderr, \"libvirt: %s %s %s%s: %s\\n\",\n                dom, lvl, domain, network, err->message);\n    else\n        fprintf(stderr, \"libvirt: %s %s %s%s: %s\",\n                dom, lvl, domain, network, err->message);\n}\n- virReportUnsupportedError: #define virReportUnsupportedError() \\ /* <=== src/util/virerror.h:160:162:virReportUnsupportedError:0 */ \n    virReportErrorHelper(VIR_FROM_THIS, VIR_ERR_NO_SUPPORT, \\\n                         __FILE__, __FUNCTION__, __LINE__, __FUNCTION__)\n- virCheckDomainReturn: #define virCheckDomainReturn(obj, retval) \\ /* <=== src/datatypes.h:70:81:virCheckDomainReturn:2 */ \n    do { \\\n        virDomainPtr _dom = (obj); \\\n        if (!virObjectIsClass(_dom, virDomainClass) || \\\n            !virObjectIsClass(_dom->conn, virConnectClass)) { \\\n            virReportErrorHelper(VIR_FROM_DOM, VIR_ERR_INVALID_DOMAIN, \\\n                                 __FILE__, __FUNCTION__, __LINE__, \\\n                                 __FUNCTION__); \\\n            virDispatchError(NULL); \\\n            return retval; \\\n        } \\\n    } while (0)\n- virReportErrorHelper: void virReportErrorHelper(int domcode, /* <=== virReportErrorHelper */ \n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}\n- virObjectIsClass: bool /* <=== virObjectIsClass */ \nvirObjectIsClass(void *anyobj,\n                 virClassPtr klass)\n{\n    virObjectPtr obj = anyobj;\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    return virClassIsDerivedFrom(obj->klass, klass);\n}\n- VIR_OBJECT_NOTVALID: #define VIR_OBJECT_NOTVALID(obj) (!obj || ((obj->u.s.magic & 0xFFFF0000) != 0xCAFE0000)) /* <=== src/util/virobject.c:49:49:VIR_OBJECT_NOTVALID:1 */ \n- virErrorMsg: const char * /* <=== virErrorMsg */ \nvirErrorMsg(virErrorNumber error, const char *info)\n{\n    if (error >= VIR_ERR_NUMBER_LAST)\n        return NULL;\n\n    if (info)\n        return _(virErrorMsgStrings[error].msginfo);\n    else\n        return _(virErrorMsgStrings[error].msg);\n}\n- virRaiseErrorFull: void /* <=== virRaiseErrorFull */ \nvirRaiseErrorFull(const char *filename,\n                  const char *funcname,\n                  size_t linenr,\n                  int domain,\n                  int code,\n                  virErrorLevel level,\n                  const char *str1,\n                  const char *str2,\n                  const char *str3,\n                  int int1,\n                  int int2,\n                  const char *fmt, ...)\n{\n    int save_errno = errno;\n    virErrorPtr to;\n    char *str;\n    virLogMetadata meta[] = {\n        { .key = \"LIBVIRT_DOMAIN\", .s = NULL, .iv = domain },\n        { .key = \"LIBVIRT_CODE\", .s = NULL, .iv = code },\n        { .key = NULL },\n    };\n\n    /*\n     * All errors are recorded in thread local storage\n     * For compatibility, public API calls will copy them\n     * to the per-connection error object when necessary\n     */\n    to = virLastErrorObject();\n    if (!to) {\n        errno = save_errno;\n        return; /* Hit OOM allocating thread error object, sod all we can do now */\n    }\n\n    virResetError(to);\n\n    if (code == VIR_ERR_OK) {\n        errno = save_errno;\n        return;\n    }\n\n    /*\n     * formats the message; drop message on OOM situations\n     */\n    if (fmt == NULL) {\n        str = g_strdup(_(\"No error message provided\"));\n    } else {\n        va_list ap;\n        va_start(ap, fmt);\n        str = g_strdup_vprintf(fmt, ap);\n        va_end(ap);\n    }\n\n    /*\n     * Save the information about the error\n     */\n    /*\n     * Deliberately not setting conn, dom & net fields since\n     * they're utterly unsafe\n     */\n    to->domain = domain;\n    to->code = code;\n    to->message = str;\n    to->level = level;\n    to->str1 = g_strdup(str1);\n    to->str2 = g_strdup(str2);\n    to->str3 = g_strdup(str3);\n    to->int1 = int1;\n    to->int2 = int2;\n\n    virRaiseErrorLog(filename, funcname, linenr,\n                     to, meta);\n\n    errno = save_errno;\n}\n- virLastErrorObject: static virErrorPtr /* <=== virLastErrorObject */ \nvirLastErrorObject(void)\n{\n    virErrorPtr err;\n    err = virThreadLocalGet(&virLastErr);\n    if (!err) {\n        if (VIR_ALLOC_QUIET(err) < 0)\n            return NULL;\n        if (virThreadLocalSet(&virLastErr, err) < 0)\n            VIR_FREE(err);\n    }\n    return err;\n}\n- VIR_ERROR_MAX_LENGTH: #define VIR_ERROR_MAX_LENGTH 1024 /* <=== src/util/virerror.h:26:26:VIR_ERROR_MAX_LENGTH:0 */ \n- virCopyError: static int /* <=== virCopyError */ \nvirCopyError(virErrorPtr from,\n             virErrorPtr to)\n{\n    int ret = 0;\n    if (!to)\n        return 0;\n    virResetError(to);\n    if (!from)\n        return 0;\n    to->code = from->code;\n    to->domain = from->domain;\n    to->level = from->level;\n    to->message = g_strdup(from->message);\n    to->str1 = g_strdup(from->str1);\n    to->str2 = g_strdup(from->str2);\n    to->str3 = g_strdup(from->str3);\n    to->int1 = from->int1;\n    to->int2 = from->int2;\n    /*\n     * Deliberately not setting 'conn', 'dom', 'net' references\n     */\n    return ret;\n}\n- virDispatchError: void /* <=== virDispatchError */ \nvirDispatchError(virConnectPtr conn)\n{\n    virErrorPtr err = virLastErrorObject();\n    virErrorFunc handler = virErrorHandler;\n    void *userData = virUserData;\n\n    /* Can only happen on OOM.  */\n    if (!err)\n        return;\n\n    /* Set a generic error message if none is already set */\n    if (err->code == VIR_ERR_OK)\n        virErrorGenericFailure(err);\n\n    /* Copy the global error to per-connection error if needed */\n    if (conn) {\n        virObjectLock(conn);\n        virCopyError(err, &conn->err);\n\n        if (conn->handler != NULL) {\n            handler = conn->handler;\n            userData = conn->userData;\n        }\n        virObjectUnlock(conn);\n    }\n\n    /* Invoke the error callback functions */\n    if (handler != NULL) {\n        (handler)(userData, err);\n    } else {\n        virDefaultErrorFunc(err);\n    }\n}\n- virObjectLock: void /* <=== virObjectLock */ \nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}\n- virCheckReadOnlyGoto: #define virCheckReadOnlyGoto(flags, label) \\ /* <=== src/internal.h:431:438:virCheckReadOnlyGoto:2 */ \n    do { \\\n        if ((flags) & VIR_CONNECT_RO) { \\\n            virReportRestrictedError(_(\"read only access prevents %s\"), \\\n                                     __FUNCTION__); \\\n            goto label; \\\n        } \\\n    } while (0)\n- VIR_DOMAIN_DEBUG: #define VIR_DOMAIN_DEBUG(...) \\ /* <=== src/datatypes.h:476:479:VIR_DOMAIN_DEBUG:1 */ \n    VIR_DOMAIN_DEBUG_EXPAND(VIR_DOMAIN_DEBUG_, \\\n                            VIR_HAS_COMMA(__VA_ARGS__), \\\n                            __VA_ARGS__)\n\nImports:\n- #include <config.h>\n- #include \"datatypes.h\"\n- #include \"viralloc.h\"\n- #include \"virfile.h\"\n- #include \"virlog.h\"\n- #include <sys/stat.h>\n- #include \"virtypedparam.h\"\n- #include \"virutil.h\"",
    "commit_msg": "api: disallow virDomainAgentSetResponseTimeout() on read-only connections\n\nThis function changes the amount of time that libvirt waits for a\nresponse from the guest agent for all guest agent commands. Since this\nis a configuration change, it should not be allowed on read-only\nconnections.\n\nSigned-off-by: Jonathon Jongsma <jjongsma@redhat.com>\nReviewed-by: Daniel Henrique Barboza <danielhb413@gmail.com>\nReviewed-by: Michal Privoznik <mprivozn@redhat.com>",
    "cve_desc": "A missing authorization flaw was found in the libvirt API responsible for changing the QEMU agent response timeout. This flaw allows read-only connections to adjust the time that libvirt waits for the QEMU guest agent to respond to agent commands. Depending on the timeout value that is set, this flaw can make guest agent commands fail because the agent cannot respond in time. Unprivileged users with a read-only connection could abuse this flaw to set the response timeout for all guest agent messages to zero, potentially leading to a denial of service. This flaw affects libvirt versions before 6.2.0.",
    "year": 2020,
    "filename": "",
    "commit_url": "https://github.com/libvirt/libvirt/commit/4cc90c2e62df653e909ad31fd810224bf8bcf913"
  },
  {
    "repository": "DPDK/dpdk",
    "cve_id": "CVE-2020-10726",
    "cwe_list": [
      "CWE-190"
    ],
    "commit_hash": "e7debf602633feb26227cdc8cc7fdd1b1b40946a",
    "short_hash": "e7debf60",
    "vulnerableMethods_before": [
      {
        "filename": "lib/librte_vhost/vhost_user.c",
        "method_name": "vhost_backend_cleanup",
        "raw_code": "void /* <=== vhost_backend_cleanup */ \nvhost_backend_cleanup(struct virtio_net *dev)\n{\n\tif (dev->mem) {\n\t\tfree_mem_region(dev);\n\t\trte_free(dev->mem);\n\t\tdev->mem = NULL;\n\t}\n\n\trte_free(dev->guest_pages);\n\tdev->guest_pages = NULL;\n\n\tif (dev->log_addr) {\n\t\tmunmap((void *)(uintptr_t)dev->log_addr, dev->log_size);\n\t\tdev->log_addr = 0;\n\t}\n\n\tif (dev->inflight_info) {\n\t\tif (dev->inflight_info->addr) {\n\t\t\tmunmap(dev->inflight_info->addr,\n\t\t\t       dev->inflight_info->size);\n\t\t\tdev->inflight_info->addr = NULL;\n\t\t}\n\n\t\tif (dev->inflight_info->fd > 0) {\n\t\t\tclose(dev->inflight_info->fd);\n\t\t\tdev->inflight_info->fd = -1;\n\t\t}\n\n\t\tfree(dev->inflight_info);\n\t\tdev->inflight_info = NULL;\n\t}\n\n\tif (dev->slave_req_fd >= 0) {\n\t\tclose(dev->slave_req_fd);\n\t\tdev->slave_req_fd = -1;\n\t}\n\n\tif (dev->postcopy_ufd >= 0) {\n\t\tclose(dev->postcopy_ufd);\n\t\tdev->postcopy_ufd = -1;\n\t}\n\n\tdev->postcopy_listening = 0;\n}",
        "start_line": 185
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "lib/librte_vhost/vhost_user.c",
        "method_name": "vhost_backend_cleanup",
        "raw_code": "void /* <=== vhost_backend_cleanup */ \nvhost_backend_cleanup(struct virtio_net *dev)\n{\n\tif (dev->mem) {\n\t\tfree_mem_region(dev);\n\t\trte_free(dev->mem);\n\t\tdev->mem = NULL;\n\t}\n\n\trte_free(dev->guest_pages);\n\tdev->guest_pages = NULL;\n\n\tif (dev->log_addr) {\n\t\tmunmap((void *)(uintptr_t)dev->log_addr, dev->log_size);\n\t\tdev->log_addr = 0;\n\t}\n\n\tif (dev->inflight_info) {\n\t\tif (dev->inflight_info->addr) {\n\t\t\tmunmap(dev->inflight_info->addr,\n\t\t\t       dev->inflight_info->size);\n\t\t\tdev->inflight_info->addr = NULL;\n\t\t}\n\n\t\tif (dev->inflight_info->fd >= 0) {\n\t\t\tclose(dev->inflight_info->fd);\n\t\t\tdev->inflight_info->fd = -1;\n\t\t}\n\n\t\tfree(dev->inflight_info);\n\t\tdev->inflight_info = NULL;\n\t}\n\n\tif (dev->slave_req_fd >= 0) {\n\t\tclose(dev->slave_req_fd);\n\t\tdev->slave_req_fd = -1;\n\t}\n\n\tif (dev->postcopy_ufd >= 0) {\n\t\tclose(dev->postcopy_ufd);\n\t\tdev->postcopy_ufd = -1;\n\t}\n\n\tdev->postcopy_listening = 0;\n}",
        "start_line": 185
      }
    ],
    "code_context": "Type Definitions:\n- virtio_net: struct virtio_net {\n\t/* Frontend (QEMU) memory and memory region information */\n\tstruct rte_vhost_memory\t*mem;\n\tuint64_t\t\tfeatures;\n\tuint64_t\t\tprotocol_features;\n\tint\t\t\tvid;\n\tuint32_t\t\tflags;\n\tuint16_t\t\tvhost_hlen;\n\t/* to tell if we need broadcast rarp packet */\n\tint16_t\t\t\tbroadcast_rarp;\n\tuint32_t\t\tnr_vring;\n\tint\t\t\tdequeue_zero_copy;\n\tint\t\t\textbuf;\n\tint\t\t\tlinearbuf;\n\tstruct vhost_virtqueue\t*virtqueue[VHOST_MAX_QUEUE_PAIRS * 2];\n\tstruct inflight_mem_info *inflight_info;\n#define IF_NAME_SZ (PATH_MAX > IFNAMSIZ ? PATH_MAX : IFNAMSIZ)\n\tchar\t\t\tifname[IF_NAME_SZ];\n\tuint64_t\t\tlog_size;\n\tuint64_t\t\tlog_base;\n\tuint64_t\t\tlog_addr;\n\tstruct rte_ether_addr\tmac;\n\tuint16_t\t\tmtu;\n\n\tstruct vhost_device_ops const *notify_ops;\n\n\tuint32_t\t\tnr_guest_pages;\n\tuint32_t\t\tmax_guest_pages;\n\tstruct guest_page       *guest_pages;\n\n\tint\t\t\tslave_req_fd;\n\trte_spinlock_t\t\tslave_req_lock;\n\n\tint\t\t\tpostcopy_ufd;\n\tint\t\t\tpostcopy_listening;\n\n\t/*\n\t * Device id to identify a specific backend device.\n\t * It's set to -1 for the default software implementation.\n\t */\n\tint\t\t\tvdpa_dev_id;\n\n\t/* context data for the external message handlers */\n\tvoid\t\t\t*extern_data;\n\t/* pre and post vhost user message handlers for the device */\n\tstruct rte_vhost_user_extern_ops extern_ops;\n}\n- virtio_net: struct virtio_net\n\nImports:\n- #include <linux/memfd.h>\n- #include <sys/mman.h>\n- #include <string.h>\n- #include \"vhost.h\"\n- #include \"iotlb.h\"\n- #include <rte_common.h>\n- #include <linux/userfaultfd.h>\n- #include \"vhost_user.h\"\n- #include <rte_log.h>\n- #include <stdio.h>\n- #include <sys/syscall.h>\n- #include <stdlib.h>\n- #include <rte_malloc.h>\n- #include <sys/ioctl.h>\n- #include <unistd.h>\n- #include <numaif.h>\n- #include <fcntl.h>\n- #include <sys/stat.h>\n- #include <sys/types.h>\n- #include <stdint.h>\n- #include <assert.h>",
    "commit_msg": "vhost: fix potential fd leak\n\nVhost will create temporary file when receiving VHOST_USER_GET_INFLIGHT_FD\nmessage. Malicious guest can send endless this message to drain out the\nresource of host.\n\nWhen receiving VHOST_USER_GET_INFLIGHT_FD message repeatedly, closing the\nfile created during the last handling of this message.\n\nCVE-2020-10726\nFixes: d87f1a1cb7b666550 (\"vhost: support inflight info sharing\")\nCc: stable@dpdk.org\n\nSigned-off-by: Xuan Ding <xuan.ding@intel.com>\nSigned-off-by: Xiaolong Ye <xiaolong.ye@intel.com>\nReviewed-by: Maxime Coquelin <maxime.coquelin@redhat.com>",
    "cve_desc": "A vulnerability was found in DPDK versions 19.11 and above. A malicious container that has direct access to the vhost-user socket can keep sending VHOST_USER_GET_INFLIGHT_FD messages, causing a resource leak (file descriptors and virtual memory), which may result in a denial of service.",
    "year": 2020,
    "filename": "vhost_user.c",
    "commit_url": "\"https://github.com/DPDK/dpdk/commit/e7debf602633feb26227cdc8cc7fdd1b1b40946a\""
  },
  {
    "repository": "samba-team/samba",
    "cve_id": "CVE-2020-10730",
    "cwe_list": [
      "CWE-476"
    ],
    "commit_hash": "d8b9bb274b7e7a390cf3bda9cd732cb2227bdbde",
    "short_hash": "d8b9bb27",
    "vulnerableMethods_before": [
      {
        "filename": "lib/ldb/common/ldb.c",
        "method_name": "ldb_lock_backend_callback",
        "raw_code": "static int ldb_lock_backend_callback(struct ldb_request *req, /* <=== ldb_lock_backend_callback */ \n\t\t\t\t     struct ldb_reply *ares)\n{\n\tstruct ldb_db_lock_context *lock_context;\n\tint ret;\n\n\tlock_context = talloc_get_type(req->context,\n\t\t\t\t       struct ldb_db_lock_context);\n\n\tif (!ares) {\n\t\treturn ldb_module_done(lock_context->req, NULL, NULL,\n\t\t\t\t\tLDB_ERR_OPERATIONS_ERROR);\n\t}\n\tif (ares->error != LDB_SUCCESS || ares->type == LDB_REPLY_DONE) {\n\t\tret = ldb_module_done(lock_context->req, ares->controls,\n\t\t\t\t      ares->response, ares->error);\n\t\t/*\n\t\t * If this is a LDB_REPLY_DONE or an error, unlock the\n\t\t * DB by calling the destructor on this context\n\t\t */\n\t\ttalloc_free(lock_context);\n\t\treturn ret;\n\t}\n\n\t/* Otherwise pass on the callback */\n\tswitch (ares->type) {\n\tcase LDB_REPLY_ENTRY:\n\t\treturn ldb_module_send_entry(lock_context->req, ares->message,\n\t\t\t\t\t     ares->controls);\n\n\tcase LDB_REPLY_REFERRAL:\n\t\treturn ldb_module_send_referral(lock_context->req,\n\t\t\t\t\t\tares->referral);\n\tdefault:\n\t\t/* Can't happen */\n\t\treturn LDB_ERR_OPERATIONS_ERROR;\n\t}\n}",
        "start_line": 1015
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "lib/ldb/common/ldb.c",
        "method_name": "ldb_lock_backend_callback",
        "raw_code": "static int ldb_lock_backend_callback(struct ldb_request *req, /* <=== ldb_lock_backend_callback */ \n\t\t\t\t     struct ldb_reply *ares)\n{\n\tstruct ldb_db_lock_context *lock_context;\n\tint ret;\n\n\tif (req->context == NULL) {\n\t\t/*\n\t\t * The usual way to get here is to ignore the return codes\n\t\t * and continuing processing after an error.\n\t\t */\n\t\tabort();\n\t}\n\tlock_context = talloc_get_type(req->context,\n\t\t\t\t       struct ldb_db_lock_context);\n\n\tif (!ares) {\n\t\treturn ldb_module_done(lock_context->req, NULL, NULL,\n\t\t\t\t\tLDB_ERR_OPERATIONS_ERROR);\n\t}\n\tif (ares->error != LDB_SUCCESS || ares->type == LDB_REPLY_DONE) {\n\t\tret = ldb_module_done(lock_context->req, ares->controls,\n\t\t\t\t      ares->response, ares->error);\n\t\t/*\n\t\t * If this is a LDB_REPLY_DONE or an error, unlock the\n\t\t * DB by calling the destructor on this context\n\t\t */\n\t\tTALLOC_FREE(req->context);\n\t\treturn ret;\n\t}\n\n\t/* Otherwise pass on the callback */\n\tswitch (ares->type) {\n\tcase LDB_REPLY_ENTRY:\n\t\treturn ldb_module_send_entry(lock_context->req, ares->message,\n\t\t\t\t\t     ares->controls);\n\n\tcase LDB_REPLY_REFERRAL:\n\t\treturn ldb_module_send_referral(lock_context->req,\n\t\t\t\t\t\tares->referral);\n\tdefault:\n\t\t/* Can't happen */\n\t\treturn LDB_ERR_OPERATIONS_ERROR;\n\t}\n}",
        "start_line": 1015
      }
    ],
    "code_context": "Called Methods:\n- ldb_errstring: const char *ldb_errstring(struct ldb_context *ldb) /* <=== ldb_errstring */ \n{\n\tif (ldb->err_string) {\n\t\treturn ldb->err_string;\n\t}\n\n\treturn NULL;\n}\n- LDB_HANDLE_FLAG_DONE_CALLED: #define LDB_HANDLE_FLAG_DONE_CALLED 1 /* <=== lib/ldb/include/ldb_private.h:52:52:LDB_HANDLE_FLAG_DONE_CALLED:0 */ \n- LDB_FLG_ENABLE_TRACING: #define LDB_FLG_ENABLE_TRACING 32 /* <=== lib/ldb/include/ldb.h:285:285:LDB_FLG_ENABLE_TRACING:0 */ \n- ldb_oom: #define ldb_oom(ldb) ldb_error(ldb, LDB_ERR_OPERATIONS_ERROR, \"ldb out of memory\") /* <=== lib/ldb/include/ldb_module.h:146:146:ldb_oom:1 */ \n- talloc_free: int talloc_free(void *ptr) /* <=== talloc_free */ \n{\n\treturn talloc_unlink(talloc_parent(ptr), ptr);\n}\n- ldb_error_at: int ldb_error_at(struct ldb_context *ldb, int ecode, /* <=== ldb_error_at */ \n\t\t const char *reason, const char *file, int line)\n{\n\tif (reason == NULL) {\n\t\treason = ldb_strerror(ecode);\n\t}\n\tldb_asprintf_errstring(ldb, \"%s at %s:%d\", reason, file, line);\n\treturn ecode;\n}\n- ldb_module_done: int ldb_module_done(struct ldb_request *req, /* <=== ldb_module_done */ \n\t\t    struct ldb_control **ctrls,\n\t\t    struct ldb_extended *response,\n\t\t    int error)\n{\n\tstruct ldb_reply *ares;\n\n\tares = talloc_zero(req, struct ldb_reply);\n\tif (!ares) {\n\t\tldb_oom(req->handle->ldb);\n\t\treq->callback(req, NULL);\n\t\treturn LDB_ERR_OPERATIONS_ERROR;\n\t}\n\tares->type = LDB_REPLY_DONE;\n\tares->controls = talloc_steal(ares, ctrls);\n\tares->response = talloc_steal(ares, response);\n\tares->error = error;\n\n\treq->handle->flags |= LDB_HANDLE_FLAG_DONE_CALLED;\n\n\tif ((req->handle->ldb->flags & LDB_FLG_ENABLE_TRACING) &&\n\t    req->handle->nesting == 0) {\n\t\tldb_debug_add(req->handle->ldb, \"ldb_trace_response: DONE\\n\");\n\t\tldb_debug_add(req->handle->ldb, \"error: %d\\n\", error);\n\t\tif (ldb_errstring(req->handle->ldb)) {\n\t\t\tldb_debug_add(req->handle->ldb, \"msg: %s\\n\",\n\t\t\t\t  ldb_errstring(req->handle->ldb));\n\t\t}\n\t\tldb_debug_end(req->handle->ldb, LDB_DEBUG_TRACE);\n\t}\n\n\treturn req->callback(req, ares);\n}\n- ldb_debug_end: void ldb_debug_end(struct ldb_context *ldb, enum ldb_debug_level level); /* <=== ldb_debug_end */ \n- ldb_debug_add: void ldb_debug_add(struct ldb_context *ldb, const char *fmt, ...) PRINTF_ATTRIBUTE(2, 3); /* <=== ldb_debug_add */ \n- talloc_parent: void *talloc_parent(const void *ptr); /* <=== talloc_parent */ \n- talloc_unlink: int talloc_unlink(const void *context, void *ptr); /* <=== talloc_unlink */ \n\nType Definitions:\n- ldb_reply: struct ldb_reply {\n\tint error;\n\tenum ldb_reply_type type;\n\tstruct ldb_message *message;\n\tstruct ldb_extended *response;\n\tstruct ldb_control **controls;\n\tchar *referral;\n}\n- ldb_request: struct ldb_request\n- ldb_db_lock_context: struct ldb_db_lock_context {\n\tstruct ldb_request *req;\n\tstruct ldb_context *ldb;\n}\n- ldb_request: struct ldb_request {\n\n\tenum ldb_request_type operation;\n\n\tunion {\n\t\tstruct ldb_search search;\n\t\tstruct ldb_add    add;\n\t\tstruct ldb_modify mod;\n\t\tstruct ldb_delete del;\n\t\tstruct ldb_rename rename;\n\t\tstruct ldb_extended extended;\n\t\tstruct ldb_register_control reg_control;\n\t\tstruct ldb_register_partition reg_partition;\n\t} op;\n\n\tstruct ldb_control **controls;\n\n\tvoid *context;\n\tldb_request_callback_t callback;\n\n\tint timeout;\n\ttime_t starttime;\n\tstruct ldb_handle *handle;\n}\n\nImports:\n- #include \"ldb.h\"\n- #include \"ldb_private.h\"",
    "commit_msg": "CVE-2020-10730: lib ldb: Check if ldb_lock_backend_callback called twice\n\nPrevent use after free issues if ldb_lock_backend_callback is called\ntwice, usually due to ldb_module_done being called twice. This can happen if a\nmodule ignores the return value from function a function that calls\nldb_module_done as part of it's error handling.\n\nBUG: https://bugzilla.samba.org/show_bug.cgi?id=14364\n\nSigned-off-by: Gary Lockyer <gary@catalyst.net.nz>\nReviewed-by: Andrew Bartlett <abartlet@samba.org>",
    "cve_desc": "A NULL pointer dereference, or possible use-after-free flaw was found in Samba AD LDAP server in versions before 4.10.17, before 4.11.11 and before 4.12.4. Although some versions of Samba shipped with Red Hat Enterprise Linux do not support Samba in AD mode, the affected code is shipped with the libldb package. This flaw allows an authenticated user to possibly trigger a use-after-free or NULL pointer dereference. The highest threat from this vulnerability is to system availability.",
    "year": 2020,
    "filename": "ldb.c",
    "commit_url": "\"https://github.com/samba-team/samba/commit/d8b9bb274b7e7a390cf3bda9cd732cb2227bdbde\""
  },
  {
    "repository": "perl/perl5",
    "cve_id": "CVE-2020-10878",
    "cwe_list": [
      "CWE-190"
    ],
    "commit_hash": "3295b48defa0f8570114877b063fe546dd348b3c",
    "short_hash": "3295b48d",
    "vulnerableMethods_before": [
      {
        "filename": "regcomp.c",
        "method_name": "Perl_re_op_compile",
        "raw_code": "REGEXP * /* <=== Perl_re_op_compile */ \nPerl_re_op_compile(pTHX_ SV ** const patternp, int pat_count,\n\t\t    OP *expr, const regexp_engine* eng, REGEXP *old_re,\n\t\t     bool *is_bare_re, const U32 orig_rx_flags, const U32 pm_flags)\n{\n    dVAR;\n    REGEXP *Rx;         /* Capital 'R' means points to a REGEXP */\n    STRLEN plen;\n    char *exp;\n    regnode *scan;\n    I32 flags;\n    SSize_t minlen = 0;\n    U32 rx_flags;\n    SV *pat;\n    SV** new_patternp = patternp;\n\n    /* these are all flags - maybe they should be turned\n     * into a single int with different bit masks */\n    I32 sawlookahead = 0;\n    I32 sawplus = 0;\n    I32 sawopen = 0;\n    I32 sawminmod = 0;\n\n    regex_charset initial_charset = get_regex_charset(orig_rx_flags);\n    bool recompile = 0;\n    bool runtime_code = 0;\n    scan_data_t data;\n    RExC_state_t RExC_state;\n    RExC_state_t * const pRExC_state = &RExC_state;\n#ifdef TRIE_STUDY_OPT\n    int restudied = 0;\n    RExC_state_t copyRExC_state;\n#endif\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_RE_OP_COMPILE;\n\n    DEBUG_r(if (!PL_colorset) reginitcolors());\n\n    /* Initialize these here instead of as-needed, as is quick and avoids\n     * having to test them each time otherwise */\n    if (! PL_InBitmap) {\n#ifdef DEBUGGING\n        char * dump_len_string;\n#endif\n\n        /* This is calculated here, because the Perl program that generates the\n         * static global ones doesn't currently have access to\n         * NUM_ANYOF_CODE_POINTS */\n\tPL_InBitmap = _new_invlist(2);\n\tPL_InBitmap = _add_range_to_invlist(PL_InBitmap, 0,\n                                                    NUM_ANYOF_CODE_POINTS - 1);\n#ifdef DEBUGGING\n        dump_len_string = PerlEnv_getenv(\"PERL_DUMP_RE_MAX_LEN\");\n        if (   ! dump_len_string\n            || ! grok_atoUV(dump_len_string, (UV *)&PL_dump_re_max_len, NULL))\n        {\n            PL_dump_re_max_len = 60;    /* A reasonable default */\n        }\n#endif\n    }\n\n    pRExC_state->warn_text = NULL;\n    pRExC_state->unlexed_names = NULL;\n    pRExC_state->code_blocks = NULL;\n\n    if (is_bare_re)\n\t*is_bare_re = FALSE;\n\n    if (expr && (expr->op_type == OP_LIST ||\n\t\t(expr->op_type == OP_NULL && expr->op_targ == OP_LIST))) {\n\t/* allocate code_blocks if needed */\n\tOP *o;\n\tint ncode = 0;\n\n\tfor (o = cLISTOPx(expr)->op_first; o; o = OpSIBLING(o))\n\t    if (o->op_type == OP_NULL && (o->op_flags & OPf_SPECIAL))\n\t\tncode++; /* count of DO blocks */\n\n\tif (ncode)\n            pRExC_state->code_blocks = S_alloc_code_blocks(aTHX_ ncode);\n    }\n\n    if (!pat_count) {\n        /* compile-time pattern with just OP_CONSTs and DO blocks */\n\n        int n;\n        OP *o;\n\n        /* find how many CONSTs there are */\n        assert(expr);\n        n = 0;\n        if (expr->op_type == OP_CONST)\n            n = 1;\n        else\n            for (o = cLISTOPx(expr)->op_first; o; o = OpSIBLING(o)) {\n                if (o->op_type == OP_CONST)\n                    n++;\n            }\n\n        /* fake up an SV array */\n\n        assert(!new_patternp);\n        Newx(new_patternp, n, SV*);\n        SAVEFREEPV(new_patternp);\n        pat_count = n;\n\n        n = 0;\n        if (expr->op_type == OP_CONST)\n            new_patternp[n] = cSVOPx_sv(expr);\n        else\n            for (o = cLISTOPx(expr)->op_first; o; o = OpSIBLING(o)) {\n                if (o->op_type == OP_CONST)\n                    new_patternp[n++] = cSVOPo_sv;\n            }\n\n    }\n\n    DEBUG_PARSE_r(Perl_re_printf( aTHX_\n        \"Assembling pattern from %d elements%s\\n\", pat_count,\n            orig_rx_flags & RXf_SPLIT ? \" for split\" : \"\"));\n\n    /* set expr to the first arg op */\n\n    if (pRExC_state->code_blocks && pRExC_state->code_blocks->count\n         && expr->op_type != OP_CONST)\n    {\n            expr = cLISTOPx(expr)->op_first;\n            assert(   expr->op_type == OP_PUSHMARK\n                   || (expr->op_type == OP_NULL && expr->op_targ == OP_PUSHMARK)\n                   || expr->op_type == OP_PADRANGE);\n            expr = OpSIBLING(expr);\n    }\n\n    pat = S_concat_pat(aTHX_ pRExC_state, NULL, new_patternp, pat_count,\n                        expr, &recompile, NULL);\n\n    /* handle bare (possibly after overloading) regex: foo =~ $re */\n    {\n        SV *re = pat;\n        if (SvROK(re))\n            re = SvRV(re);\n        if (SvTYPE(re) == SVt_REGEXP) {\n            if (is_bare_re)\n                *is_bare_re = TRUE;\n            SvREFCNT_inc(re);\n            DEBUG_PARSE_r(Perl_re_printf( aTHX_\n                \"Precompiled pattern%s\\n\",\n                    orig_rx_flags & RXf_SPLIT ? \" for split\" : \"\"));\n\n            return (REGEXP*)re;\n        }\n    }\n\n    exp = SvPV_nomg(pat, plen);\n\n    if (!eng->op_comp) {\n\tif ((SvUTF8(pat) && IN_BYTES)\n\t\t|| SvGMAGICAL(pat) || SvAMAGIC(pat))\n\t{\n\t    /* make a temporary copy; either to convert to bytes,\n\t     * or to avoid repeating get-magic / overloaded stringify */\n\t    pat = newSVpvn_flags(exp, plen, SVs_TEMP |\n\t\t\t\t\t(IN_BYTES ? 0 : SvUTF8(pat)));\n\t}\n\treturn CALLREGCOMP_ENG(eng, pat, orig_rx_flags);\n    }\n\n    /* ignore the utf8ness if the pattern is 0 length */\n    RExC_utf8 = RExC_orig_utf8 = (plen == 0 || IN_BYTES) ? 0 : SvUTF8(pat);\n    RExC_uni_semantics = 0;\n    RExC_contains_locale = 0;\n    RExC_strict = cBOOL(pm_flags & RXf_PMf_STRICT);\n    RExC_in_script_run = 0;\n    RExC_study_started = 0;\n    pRExC_state->runtime_code_qr = NULL;\n    RExC_frame_head= NULL;\n    RExC_frame_last= NULL;\n    RExC_frame_count= 0;\n    RExC_latest_warn_offset = 0;\n    RExC_use_BRANCHJ = 0;\n    RExC_total_parens = 0;\n    RExC_open_parens = NULL;\n    RExC_close_parens = NULL;\n    RExC_paren_names = NULL;\n    RExC_size = 0;\n    RExC_seen_d_op = FALSE;\n#ifdef DEBUGGING\n    RExC_paren_name_list = NULL;\n#endif\n\n    DEBUG_r({\n        RExC_mysv1= sv_newmortal();\n        RExC_mysv2= sv_newmortal();\n    });\n\n    DEBUG_COMPILE_r({\n            SV *dsv= sv_newmortal();\n            RE_PV_QUOTED_DECL(s, RExC_utf8, dsv, exp, plen, PL_dump_re_max_len);\n            Perl_re_printf( aTHX_  \"%sCompiling REx%s %s\\n\",\n                          PL_colors[4], PL_colors[5], s);\n        });\n\n    /* we jump here if we have to recompile, e.g., from upgrading the pattern\n     * to utf8 */\n\n    if ((pm_flags & PMf_USE_RE_EVAL)\n\t\t/* this second condition covers the non-regex literal case,\n\t\t * i.e.  $foo =~ '(?{})'. */\n\t\t|| (IN_PERL_COMPILETIME && (PL_hints & HINT_RE_EVAL))\n    )\n\truntime_code = S_has_runtime_code(aTHX_ pRExC_state, exp, plen);\n\n  redo_parse:\n    /* return old regex if pattern hasn't changed */\n    /* XXX: note in the below we have to check the flags as well as the\n     * pattern.\n     *\n     * Things get a touch tricky as we have to compare the utf8 flag\n     * independently from the compile flags.  */\n\n    if (   old_re\n        && !recompile\n        && !!RX_UTF8(old_re) == !!RExC_utf8\n        && ( RX_COMPFLAGS(old_re) == ( orig_rx_flags & RXf_PMf_FLAGCOPYMASK ) )\n\t&& RX_PRECOMP(old_re)\n\t&& RX_PRELEN(old_re) == plen\n        && memEQ(RX_PRECOMP(old_re), exp, plen)\n\t&& !runtime_code /* with runtime code, always recompile */ )\n    {\n        return old_re;\n    }\n\n    /* Allocate the pattern's SV */\n    RExC_rx_sv = Rx = (REGEXP*) newSV_type(SVt_REGEXP);\n    RExC_rx = ReANY(Rx);\n    if ( RExC_rx == NULL )\n        FAIL(\"Regexp out of space\");\n\n    rx_flags = orig_rx_flags;\n\n    if (   (UTF || RExC_uni_semantics)\n        && initial_charset == REGEX_DEPENDS_CHARSET)\n    {\n\n\t/* Set to use unicode semantics if the pattern is in utf8 and has the\n\t * 'depends' charset specified, as it means unicode when utf8  */\n\tset_regex_charset(&rx_flags, REGEX_UNICODE_CHARSET);\n        RExC_uni_semantics = 1;\n    }\n\n    RExC_pm_flags = pm_flags;\n\n    if (runtime_code) {\n        assert(TAINTING_get || !TAINT_get);\n\tif (TAINT_get)\n\t    Perl_croak(aTHX_ \"Eval-group in insecure regular expression\");\n\n\tif (!S_compile_runtime_code(aTHX_ pRExC_state, exp, plen)) {\n\t    /* whoops, we have a non-utf8 pattern, whilst run-time code\n\t     * got compiled as utf8. Try again with a utf8 pattern */\n            S_pat_upgrade_to_utf8(aTHX_ pRExC_state, &exp, &plen,\n                pRExC_state->code_blocks ? pRExC_state->code_blocks->count : 0);\n            goto redo_parse;\n\t}\n    }\n    assert(!pRExC_state->runtime_code_qr);\n\n    RExC_sawback = 0;\n\n    RExC_seen = 0;\n    RExC_maxlen = 0;\n    RExC_in_lookbehind = 0;\n    RExC_seen_zerolen = *exp == '^' ? -1 : 0;\n#ifdef EBCDIC\n    RExC_recode_x_to_native = 0;\n#endif\n    RExC_in_multi_char_class = 0;\n\n    RExC_start = RExC_copy_start_in_constructed = RExC_copy_start_in_input = RExC_precomp = exp;\n    RExC_precomp_end = RExC_end = exp + plen;\n    RExC_nestroot = 0;\n    RExC_whilem_seen = 0;\n    RExC_end_op = NULL;\n    RExC_recurse = NULL;\n    RExC_study_chunk_recursed = NULL;\n    RExC_study_chunk_recursed_bytes= 0;\n    RExC_recurse_count = 0;\n    pRExC_state->code_index = 0;\n\n    /* Initialize the string in the compiled pattern.  This is so that there is\n     * something to output if necessary */\n    set_regex_pv(pRExC_state, Rx);\n\n    DEBUG_PARSE_r({\n        Perl_re_printf( aTHX_\n            \"Starting parse and generation\\n\");\n        RExC_lastnum=0;\n        RExC_lastparse=NULL;\n    });\n\n    /* Allocate space and zero-initialize. Note, the two step process\n       of zeroing when in debug mode, thus anything assigned has to\n       happen after that */\n    if (!  RExC_size) {\n\n        /* On the first pass of the parse, we guess how big this will be.  Then\n         * we grow in one operation to that amount and then give it back.  As\n         * we go along, we re-allocate what we need.\n         *\n         * XXX Currently the guess is essentially that the pattern will be an\n         * EXACT node with one byte input, one byte output.  This is crude, and\n         * better heuristics are welcome.\n         *\n         * On any subsequent passes, we guess what we actually computed in the\n         * latest earlier pass.  Such a pass probably didn't complete so is\n         * missing stuff.  We could improve those guesses by knowing where the\n         * parse stopped, and use the length so far plus apply the above\n         * assumption to what's left. */\n        RExC_size = STR_SZ(RExC_end - RExC_start);\n    }\n\n    Newxc(RExC_rxi, sizeof(regexp_internal) + RExC_size, char, regexp_internal);\n    if ( RExC_rxi == NULL )\n        FAIL(\"Regexp out of space\");\n\n    Zero(RExC_rxi, sizeof(regexp_internal) + RExC_size, char);\n    RXi_SET( RExC_rx, RExC_rxi );\n\n    /* We start from 0 (over from 0 in the case this is a reparse.  The first\n     * node parsed will give back any excess memory we have allocated so far).\n     * */\n    RExC_size = 0;\n\n    /* non-zero initialization begins here */\n    RExC_rx->engine= eng;\n    RExC_rx->extflags = rx_flags;\n    RXp_COMPFLAGS(RExC_rx) = orig_rx_flags & RXf_PMf_FLAGCOPYMASK;\n\n    if (pm_flags & PMf_IS_QR) {\n\tRExC_rxi->code_blocks = pRExC_state->code_blocks;\n        if (RExC_rxi->code_blocks) {\n            RExC_rxi->code_blocks->refcnt++;\n        }\n    }\n\n    RExC_rx->intflags = 0;\n\n    RExC_flags = rx_flags;\t/* don't let top level (?i) bleed */\n    RExC_parse = exp;\n\n    /* This NUL is guaranteed because the pattern comes from an SV*, and the sv\n     * code makes sure the final byte is an uncounted NUL.  But should this\n     * ever not be the case, lots of things could read beyond the end of the\n     * buffer: loops like\n     *      while(isFOO(*RExC_parse)) RExC_parse++;\n     *      strchr(RExC_parse, \"foo\");\n     * etc.  So it is worth noting. */\n    assert(*RExC_end == '\\0');\n\n    RExC_naughty = 0;\n    RExC_npar = 1;\n    RExC_parens_buf_size = 0;\n    RExC_emit_start = RExC_rxi->program;\n    pRExC_state->code_index = 0;\n\n    *((char*) RExC_emit_start) = (char) REG_MAGIC;\n    RExC_emit = 1;\n\n    /* Do the parse */\n    if (reg(pRExC_state, 0, &flags, 1)) {\n\n        /* Success!, But we may need to redo the parse knowing how many parens\n         * there actually are */\n        if (IN_PARENS_PASS) {\n            flags |= RESTART_PARSE;\n        }\n\n        /* We have that number in RExC_npar */\n        RExC_total_parens = RExC_npar;\n    }\n    else if (! MUST_RESTART(flags)) {\n\tReREFCNT_dec(Rx);\n        Perl_croak(aTHX_ \"panic: reg returned failure to re_op_compile, flags=%#\" UVxf, (UV) flags);\n    }\n\n    /* Here, we either have success, or we have to redo the parse for some reason */\n    if (MUST_RESTART(flags)) {\n\n        /* It's possible to write a regexp in ascii that represents Unicode\n        codepoints outside of the byte range, such as via \\x{100}. If we\n        detect such a sequence we have to convert the entire pattern to utf8\n        and then recompile, as our sizing calculation will have been based\n        on 1 byte == 1 character, but we will need to use utf8 to encode\n        at least some part of the pattern, and therefore must convert the whole\n        thing.\n        -- dmq */\n        if (flags & NEED_UTF8) {\n\n            /* We have stored the offset of the final warning output so far.\n             * That must be adjusted.  Any variant characters between the start\n             * of the pattern and this warning count for 2 bytes in the final,\n             * so just add them again */\n            if (UNLIKELY(RExC_latest_warn_offset > 0)) {\n                RExC_latest_warn_offset +=\n                            variant_under_utf8_count((U8 *) exp, (U8 *) exp\n                                                + RExC_latest_warn_offset);\n            }\n            S_pat_upgrade_to_utf8(aTHX_ pRExC_state, &exp, &plen,\n            pRExC_state->code_blocks ? pRExC_state->code_blocks->count : 0);\n            DEBUG_PARSE_r(Perl_re_printf( aTHX_ \"Need to redo parse after upgrade\\n\"));\n        }\n        else {\n            DEBUG_PARSE_r(Perl_re_printf( aTHX_ \"Need to redo parse\\n\"));\n        }\n\n        if (ALL_PARENS_COUNTED) {\n            /* Make enough room for all the known parens, and zero it */\n            Renew(RExC_open_parens, RExC_total_parens, regnode_offset);\n            Zero(RExC_open_parens, RExC_total_parens, regnode_offset);\n            RExC_open_parens[0] = 1;    /* +1 for REG_MAGIC */\n\n            Renew(RExC_close_parens, RExC_total_parens, regnode_offset);\n            Zero(RExC_close_parens, RExC_total_parens, regnode_offset);\n        }\n        else { /* Parse did not complete.  Reinitialize the parentheses\n                  structures */\n            RExC_total_parens = 0;\n            if (RExC_open_parens) {\n                Safefree(RExC_open_parens);\n                RExC_open_parens = NULL;\n            }\n            if (RExC_close_parens) {\n                Safefree(RExC_close_parens);\n                RExC_close_parens = NULL;\n            }\n        }\n\n        /* Clean up what we did in this parse */\n        SvREFCNT_dec_NN(RExC_rx_sv);\n\n        goto redo_parse;\n    }\n\n    /* Here, we have successfully parsed and generated the pattern's program\n     * for the regex engine.  We are ready to finish things up and look for\n     * optimizations. */\n\n    /* Update the string to compile, with correct modifiers, etc */\n    set_regex_pv(pRExC_state, Rx);\n\n    RExC_rx->nparens = RExC_total_parens - 1;\n\n    /* Uses the upper 4 bits of the FLAGS field, so keep within that size */\n    if (RExC_whilem_seen > 15)\n        RExC_whilem_seen = 15;\n\n    DEBUG_PARSE_r({\n        Perl_re_printf( aTHX_\n            \"Required size %\" IVdf \" nodes\\n\", (IV)RExC_size);\n        RExC_lastnum=0;\n        RExC_lastparse=NULL;\n    });\n\n#ifdef RE_TRACK_PATTERN_OFFSETS\n    DEBUG_OFFSETS_r(Perl_re_printf( aTHX_\n                          \"%s %\" UVuf \" bytes for offset annotations.\\n\",\n                          RExC_offsets ? \"Got\" : \"Couldn't get\",\n                          (UV)((RExC_offsets[0] * 2 + 1))));\n    DEBUG_OFFSETS_r(if (RExC_offsets) {\n        const STRLEN len = RExC_offsets[0];\n        STRLEN i;\n        GET_RE_DEBUG_FLAGS_DECL;\n        Perl_re_printf( aTHX_\n                      \"Offsets: [%\" UVuf \"]\\n\\t\", (UV)RExC_offsets[0]);\n        for (i = 1; i <= len; i++) {\n            if (RExC_offsets[i*2-1] || RExC_offsets[i*2])\n                Perl_re_printf( aTHX_  \"%\" UVuf \":%\" UVuf \"[%\" UVuf \"] \",\n                (UV)i, (UV)RExC_offsets[i*2-1], (UV)RExC_offsets[i*2]);\n        }\n        Perl_re_printf( aTHX_  \"\\n\");\n    });\n\n#else\n    SetProgLen(RExC_rxi,RExC_size);\n#endif\n\n    DEBUG_OPTIMISE_r(\n        Perl_re_printf( aTHX_  \"Starting post parse optimization\\n\");\n    );\n\n    /* XXXX To minimize changes to RE engine we always allocate\n       3-units-long substrs field. */\n    Newx(RExC_rx->substrs, 1, struct reg_substr_data);\n    if (RExC_recurse_count) {\n        Newx(RExC_recurse, RExC_recurse_count, regnode *);\n        SAVEFREEPV(RExC_recurse);\n    }\n\n    if (RExC_seen & REG_RECURSE_SEEN) {\n        /* Note, RExC_total_parens is 1 + the number of parens in a pattern.\n         * So its 1 if there are no parens. */\n        RExC_study_chunk_recursed_bytes= (RExC_total_parens >> 3) +\n                                         ((RExC_total_parens & 0x07) != 0);\n        Newx(RExC_study_chunk_recursed,\n             RExC_study_chunk_recursed_bytes * RExC_total_parens, U8);\n        SAVEFREEPV(RExC_study_chunk_recursed);\n    }\n\n  reStudy:\n    RExC_rx->minlen = minlen = sawlookahead = sawplus = sawopen = sawminmod = 0;\n    DEBUG_r(\n        RExC_study_chunk_recursed_count= 0;\n    );\n    Zero(RExC_rx->substrs, 1, struct reg_substr_data);\n    if (RExC_study_chunk_recursed) {\n        Zero(RExC_study_chunk_recursed,\n             RExC_study_chunk_recursed_bytes * RExC_total_parens, U8);\n    }\n\n\n#ifdef TRIE_STUDY_OPT\n    if (!restudied) {\n        StructCopy(&zero_scan_data, &data, scan_data_t);\n        copyRExC_state = RExC_state;\n    } else {\n        U32 seen=RExC_seen;\n        DEBUG_OPTIMISE_r(Perl_re_printf( aTHX_ \"Restudying\\n\"));\n\n        RExC_state = copyRExC_state;\n        if (seen & REG_TOP_LEVEL_BRANCHES_SEEN)\n            RExC_seen |= REG_TOP_LEVEL_BRANCHES_SEEN;\n        else\n            RExC_seen &= ~REG_TOP_LEVEL_BRANCHES_SEEN;\n\tStructCopy(&zero_scan_data, &data, scan_data_t);\n    }\n#else\n    StructCopy(&zero_scan_data, &data, scan_data_t);\n#endif\n\n    /* Dig out information for optimizations. */\n    RExC_rx->extflags = RExC_flags; /* was pm_op */\n    /*dmq: removed as part of de-PMOP: pm->op_pmflags = RExC_flags; */\n\n    if (UTF)\n\tSvUTF8_on(Rx);\t/* Unicode in it? */\n    RExC_rxi->regstclass = NULL;\n    if (RExC_naughty >= TOO_NAUGHTY)\t/* Probably an expensive pattern. */\n\tRExC_rx->intflags |= PREGf_NAUGHTY;\n    scan = RExC_rxi->program + 1;\t\t/* First BRANCH. */\n\n    /* testing for BRANCH here tells us whether there is \"must appear\"\n       data in the pattern. If there is then we can use it for optimisations */\n    if (!(RExC_seen & REG_TOP_LEVEL_BRANCHES_SEEN)) { /*  Only one top-level choice.\n                                                  */\n\tSSize_t fake;\n\tSTRLEN longest_length[2];\n\tregnode_ssc ch_class; /* pointed to by data */\n\tint stclass_flag;\n\tSSize_t last_close = 0; /* pointed to by data */\n        regnode *first= scan;\n        regnode *first_next= regnext(first);\n        int i;\n\n\t/*\n\t * Skip introductions and multiplicators >= 1\n\t * so that we can extract the 'meat' of the pattern that must\n\t * match in the large if() sequence following.\n\t * NOTE that EXACT is NOT covered here, as it is normally\n\t * picked up by the optimiser separately.\n\t *\n\t * This is unfortunate as the optimiser isnt handling lookahead\n\t * properly currently.\n\t *\n\t */\n\twhile ((OP(first) == OPEN && (sawopen = 1)) ||\n\t       /* An OR of *one* alternative - should not happen now. */\n\t    (OP(first) == BRANCH && OP(first_next) != BRANCH) ||\n\t    /* for now we can't handle lookbehind IFMATCH*/\n\t    (OP(first) == IFMATCH && !first->flags && (sawlookahead = 1)) ||\n\t    (OP(first) == PLUS) ||\n\t    (OP(first) == MINMOD) ||\n\t       /* An {n,m} with n>0 */\n\t    (PL_regkind[OP(first)] == CURLY && ARG1(first) > 0) ||\n\t    (OP(first) == NOTHING && PL_regkind[OP(first_next)] != END ))\n\t{\n\t\t/*\n\t\t * the only op that could be a regnode is PLUS, all the rest\n\t\t * will be regnode_1 or regnode_2.\n\t\t *\n                 * (yves doesn't think this is true)\n\t\t */\n\t\tif (OP(first) == PLUS)\n\t\t    sawplus = 1;\n                else {\n                    if (OP(first) == MINMOD)\n                        sawminmod = 1;\n\t\t    first += regarglen[OP(first)];\n                }\n\t\tfirst = NEXTOPER(first);\n\t\tfirst_next= regnext(first);\n\t}\n\n\t/* Starting-point info. */\n      again:\n        DEBUG_PEEP(\"first:\", first, 0, 0);\n        /* Ignore EXACT as we deal with it later. */\n\tif (PL_regkind[OP(first)] == EXACT) {\n\t    if (   OP(first) == EXACT\n                || OP(first) == EXACT_ONLY8\n                || OP(first) == EXACTL)\n            {\n\t\tNOOP;\t/* Empty, get anchored substr later. */\n            }\n\t    else\n\t\tRExC_rxi->regstclass = first;\n\t}\n#ifdef TRIE_STCLASS\n\telse if (PL_regkind[OP(first)] == TRIE &&\n\t        ((reg_trie_data *)RExC_rxi->data->data[ ARG(first) ])->minlen>0)\n\t{\n            /* this can happen only on restudy */\n            RExC_rxi->regstclass = construct_ahocorasick_from_trie(pRExC_state, (regnode *)first, 0);\n\t}\n#endif\n\telse if (REGNODE_SIMPLE(OP(first)))\n\t    RExC_rxi->regstclass = first;\n\telse if (PL_regkind[OP(first)] == BOUND ||\n\t\t PL_regkind[OP(first)] == NBOUND)\n\t    RExC_rxi->regstclass = first;\n\telse if (PL_regkind[OP(first)] == BOL) {\n            RExC_rx->intflags |= (OP(first) == MBOL\n                           ? PREGf_ANCH_MBOL\n                           : PREGf_ANCH_SBOL);\n\t    first = NEXTOPER(first);\n\t    goto again;\n\t}\n\telse if (OP(first) == GPOS) {\n            RExC_rx->intflags |= PREGf_ANCH_GPOS;\n\t    first = NEXTOPER(first);\n\t    goto again;\n\t}\n\telse if ((!sawopen || !RExC_sawback) &&\n            !sawlookahead &&\n\t    (OP(first) == STAR &&\n\t    PL_regkind[OP(NEXTOPER(first))] == REG_ANY) &&\n            !(RExC_rx->intflags & PREGf_ANCH) && !pRExC_state->code_blocks)\n\t{\n\t    /* turn .* into ^.* with an implied $*=1 */\n\t    const int type =\n\t\t(OP(NEXTOPER(first)) == REG_ANY)\n                    ? PREGf_ANCH_MBOL\n                    : PREGf_ANCH_SBOL;\n            RExC_rx->intflags |= (type | PREGf_IMPLICIT);\n\t    first = NEXTOPER(first);\n\t    goto again;\n\t}\n        if (sawplus && !sawminmod && !sawlookahead\n            && (!sawopen || !RExC_sawback)\n\t    && !pRExC_state->code_blocks) /* May examine pos and $& */\n\t    /* x+ must match at the 1st pos of run of x's */\n\t    RExC_rx->intflags |= PREGf_SKIP;\n\n\t/* Scan is after the zeroth branch, first is atomic matcher. */\n#ifdef TRIE_STUDY_OPT\n\tDEBUG_PARSE_r(\n\t    if (!restudied)\n                Perl_re_printf( aTHX_  \"first at %\" IVdf \"\\n\",\n\t\t\t      (IV)(first - scan + 1))\n        );\n#else\n\tDEBUG_PARSE_r(\n            Perl_re_printf( aTHX_  \"first at %\" IVdf \"\\n\",\n\t        (IV)(first - scan + 1))\n        );\n#endif\n\n\n\t/*\n\t* If there's something expensive in the r.e., find the\n\t* longest literal string that must appear and make it the\n\t* regmust.  Resolve ties in favor of later strings, since\n\t* the regstart check works with the beginning of the r.e.\n\t* and avoiding duplication strengthens checking.  Not a\n\t* strong reason, but sufficient in the absence of others.\n\t* [Now we resolve ties in favor of the earlier string if\n\t* it happens that c_offset_min has been invalidated, since the\n\t* earlier string may buy us something the later one won't.]\n\t*/\n\n\tdata.substrs[0].str = newSVpvs(\"\");\n\tdata.substrs[1].str = newSVpvs(\"\");\n\tdata.last_found = newSVpvs(\"\");\n\tdata.cur_is_floating = 0; /* initially any found substring is fixed */\n\tENTER_with_name(\"study_chunk\");\n\tSAVEFREESV(data.substrs[0].str);\n\tSAVEFREESV(data.substrs[1].str);\n\tSAVEFREESV(data.last_found);\n\tfirst = scan;\n\tif (!RExC_rxi->regstclass) {\n\t    ssc_init(pRExC_state, &ch_class);\n\t    data.start_class = &ch_class;\n\t    stclass_flag = SCF_DO_STCLASS_AND;\n\t} else\t\t\t\t/* XXXX Check for BOUND? */\n\t    stclass_flag = 0;\n\tdata.last_closep = &last_close;\n\n        DEBUG_RExC_seen();\n        /*\n         * MAIN ENTRY FOR study_chunk() FOR m/PATTERN/\n         * (NO top level branches)\n         */\n\tminlen = study_chunk(pRExC_state, &first, &minlen, &fake,\n                             scan + RExC_size, /* Up to end */\n            &data, -1, 0, NULL,\n            SCF_DO_SUBSTR | SCF_WHILEM_VISITED_POS | stclass_flag\n                          | (restudied ? SCF_TRIE_DOING_RESTUDY : 0),\n            0);\n\n\n        CHECK_RESTUDY_GOTO_butfirst(LEAVE_with_name(\"study_chunk\"));\n\n\n\tif ( RExC_total_parens == 1 && !data.cur_is_floating\n\t     && data.last_start_min == 0 && data.last_end > 0\n\t     && !RExC_seen_zerolen\n             && !(RExC_seen & REG_VERBARG_SEEN)\n             && !(RExC_seen & REG_GPOS_SEEN)\n        ){\n\t    RExC_rx->extflags |= RXf_CHECK_ALL;\n        }\n\tscan_commit(pRExC_state, &data,&minlen, 0);\n\n\n        /* XXX this is done in reverse order because that's the way the\n         * code was before it was parameterised. Don't know whether it\n         * actually needs doing in reverse order. DAPM */\n        for (i = 1; i >= 0; i--) {\n            longest_length[i] = CHR_SVLEN(data.substrs[i].str);\n\n            if (   !(   i\n                     && SvCUR(data.substrs[0].str)  /* ok to leave SvCUR */\n                     &&    data.substrs[0].min_offset\n                        == data.substrs[1].min_offset\n                     &&    SvCUR(data.substrs[0].str)\n                        == SvCUR(data.substrs[1].str)\n                    )\n                && S_setup_longest (aTHX_ pRExC_state,\n                                        &(RExC_rx->substrs->data[i]),\n                                        &(data.substrs[i]),\n                                        longest_length[i]))\n            {\n                RExC_rx->substrs->data[i].min_offset =\n                        data.substrs[i].min_offset - data.substrs[i].lookbehind;\n\n                RExC_rx->substrs->data[i].max_offset = data.substrs[i].max_offset;\n                /* Don't offset infinity */\n                if (data.substrs[i].max_offset < SSize_t_MAX)\n                    RExC_rx->substrs->data[i].max_offset -= data.substrs[i].lookbehind;\n                SvREFCNT_inc_simple_void_NN(data.substrs[i].str);\n            }\n            else {\n                RExC_rx->substrs->data[i].substr      = NULL;\n                RExC_rx->substrs->data[i].utf8_substr = NULL;\n                longest_length[i] = 0;\n            }\n        }\n\n\tLEAVE_with_name(\"study_chunk\");\n\n\tif (RExC_rxi->regstclass\n\t    && (OP(RExC_rxi->regstclass) == REG_ANY || OP(RExC_rxi->regstclass) == SANY))\n\t    RExC_rxi->regstclass = NULL;\n\n\tif ((!(RExC_rx->substrs->data[0].substr || RExC_rx->substrs->data[0].utf8_substr)\n              || RExC_rx->substrs->data[0].min_offset)\n\t    && stclass_flag\n            && ! (ANYOF_FLAGS(data.start_class) & SSC_MATCHES_EMPTY_STRING)\n\t    && is_ssc_worth_it(pRExC_state, data.start_class))\n\t{\n\t    const U32 n = add_data(pRExC_state, STR_WITH_LEN(\"f\"));\n\n            ssc_finalize(pRExC_state, data.start_class);\n\n\t    Newx(RExC_rxi->data->data[n], 1, regnode_ssc);\n\t    StructCopy(data.start_class,\n\t\t       (regnode_ssc*)RExC_rxi->data->data[n],\n\t\t       regnode_ssc);\n\t    RExC_rxi->regstclass = (regnode*)RExC_rxi->data->data[n];\n\t    RExC_rx->intflags &= ~PREGf_SKIP;\t/* Used in find_byclass(). */\n\t    DEBUG_COMPILE_r({ SV *sv = sv_newmortal();\n                      regprop(RExC_rx, sv, (regnode*)data.start_class, NULL, pRExC_state);\n                      Perl_re_printf( aTHX_\n\t\t\t\t    \"synthetic stclass \\\"%s\\\".\\n\",\n\t\t\t\t    SvPVX_const(sv));});\n            data.start_class = NULL;\n\t}\n\n        /* A temporary algorithm prefers floated substr to fixed one of\n         * same length to dig more info. */\n\ti = (longest_length[0] <= longest_length[1]);\n        RExC_rx->substrs->check_ix = i;\n        RExC_rx->check_end_shift  = RExC_rx->substrs->data[i].end_shift;\n        RExC_rx->check_substr     = RExC_rx->substrs->data[i].substr;\n        RExC_rx->check_utf8       = RExC_rx->substrs->data[i].utf8_substr;\n        RExC_rx->check_offset_min = RExC_rx->substrs->data[i].min_offset;\n        RExC_rx->check_offset_max = RExC_rx->substrs->data[i].max_offset;\n        if (!i && (RExC_rx->intflags & (PREGf_ANCH_SBOL|PREGf_ANCH_GPOS)))\n            RExC_rx->intflags |= PREGf_NOSCAN;\n\n\tif ((RExC_rx->check_substr || RExC_rx->check_utf8) ) {\n\t    RExC_rx->extflags |= RXf_USE_INTUIT;\n\t    if (SvTAIL(RExC_rx->check_substr ? RExC_rx->check_substr : RExC_rx->check_utf8))\n\t\tRExC_rx->extflags |= RXf_INTUIT_TAIL;\n\t}\n\n\t/* XXX Unneeded? dmq (shouldn't as this is handled elsewhere)\n\tif ( (STRLEN)minlen < longest_length[1] )\n            minlen= longest_length[1];\n        if ( (STRLEN)minlen < longest_length[0] )\n            minlen= longest_length[0];\n        */\n    }\n    else {\n\t/* Several toplevels. Best we can is to set minlen. */\n\tSSize_t fake;\n\tregnode_ssc ch_class;\n\tSSize_t last_close = 0;\n\n        DEBUG_PARSE_r(Perl_re_printf( aTHX_  \"\\nMulti Top Level\\n\"));\n\n\tscan = RExC_rxi->program + 1;\n\tssc_init(pRExC_state, &ch_class);\n\tdata.start_class = &ch_class;\n\tdata.last_closep = &last_close;\n\n        DEBUG_RExC_seen();\n        /*\n         * MAIN ENTRY FOR study_chunk() FOR m/P1|P2|.../\n         * (patterns WITH top level branches)\n         */\n\tminlen = study_chunk(pRExC_state,\n            &scan, &minlen, &fake, scan + RExC_size, &data, -1, 0, NULL,\n            SCF_DO_STCLASS_AND|SCF_WHILEM_VISITED_POS|(restudied\n                                                      ? SCF_TRIE_DOING_RESTUDY\n                                                      : 0),\n            0);\n\n        CHECK_RESTUDY_GOTO_butfirst(NOOP);\n\n\tRExC_rx->check_substr = NULL;\n        RExC_rx->check_utf8 = NULL;\n        RExC_rx->substrs->data[0].substr      = NULL;\n        RExC_rx->substrs->data[0].utf8_substr = NULL;\n        RExC_rx->substrs->data[1].substr      = NULL;\n        RExC_rx->substrs->data[1].utf8_substr = NULL;\n\n        if (! (ANYOF_FLAGS(data.start_class) & SSC_MATCHES_EMPTY_STRING)\n\t    && is_ssc_worth_it(pRExC_state, data.start_class))\n        {\n\t    const U32 n = add_data(pRExC_state, STR_WITH_LEN(\"f\"));\n\n            ssc_finalize(pRExC_state, data.start_class);\n\n\t    Newx(RExC_rxi->data->data[n], 1, regnode_ssc);\n\t    StructCopy(data.start_class,\n\t\t       (regnode_ssc*)RExC_rxi->data->data[n],\n\t\t       regnode_ssc);\n\t    RExC_rxi->regstclass = (regnode*)RExC_rxi->data->data[n];\n\t    RExC_rx->intflags &= ~PREGf_SKIP;\t/* Used in find_byclass(). */\n\t    DEBUG_COMPILE_r({ SV* sv = sv_newmortal();\n                      regprop(RExC_rx, sv, (regnode*)data.start_class, NULL, pRExC_state);\n                      Perl_re_printf( aTHX_\n\t\t\t\t    \"synthetic stclass \\\"%s\\\".\\n\",\n\t\t\t\t    SvPVX_const(sv));});\n            data.start_class = NULL;\n\t}\n    }\n\n    if (RExC_seen & REG_UNBOUNDED_QUANTIFIER_SEEN) {\n        RExC_rx->extflags |= RXf_UNBOUNDED_QUANTIFIER_SEEN;\n        RExC_rx->maxlen = REG_INFTY;\n    }\n    else {\n        RExC_rx->maxlen = RExC_maxlen;\n    }\n\n    /* Guard against an embedded (?=) or (?<=) with a longer minlen than\n       the \"real\" pattern. */\n    DEBUG_OPTIMISE_r({\n        Perl_re_printf( aTHX_ \"minlen: %\" IVdf \" RExC_rx->minlen:%\" IVdf \" maxlen:%\" IVdf \"\\n\",\n                      (IV)minlen, (IV)RExC_rx->minlen, (IV)RExC_maxlen);\n    });\n    RExC_rx->minlenret = minlen;\n    if (RExC_rx->minlen < minlen)\n        RExC_rx->minlen = minlen;\n\n    if (RExC_seen & REG_RECURSE_SEEN ) {\n        RExC_rx->intflags |= PREGf_RECURSE_SEEN;\n        Newx(RExC_rx->recurse_locinput, RExC_rx->nparens + 1, char *);\n    }\n    if (RExC_seen & REG_GPOS_SEEN)\n        RExC_rx->intflags |= PREGf_GPOS_SEEN;\n    if (RExC_seen & REG_LOOKBEHIND_SEEN)\n        RExC_rx->extflags |= RXf_NO_INPLACE_SUBST; /* inplace might break the\n                                                lookbehind */\n    if (pRExC_state->code_blocks)\n\tRExC_rx->extflags |= RXf_EVAL_SEEN;\n    if (RExC_seen & REG_VERBARG_SEEN)\n    {\n\tRExC_rx->intflags |= PREGf_VERBARG_SEEN;\n        RExC_rx->extflags |= RXf_NO_INPLACE_SUBST; /* don't understand this! Yves */\n    }\n    if (RExC_seen & REG_CUTGROUP_SEEN)\n\tRExC_rx->intflags |= PREGf_CUTGROUP_SEEN;\n    if (pm_flags & PMf_USE_RE_EVAL)\n\tRExC_rx->intflags |= PREGf_USE_RE_EVAL;\n    if (RExC_paren_names)\n        RXp_PAREN_NAMES(RExC_rx) = MUTABLE_HV(SvREFCNT_inc(RExC_paren_names));\n    else\n        RXp_PAREN_NAMES(RExC_rx) = NULL;\n\n    /* If we have seen an anchor in our pattern then we set the extflag RXf_IS_ANCHORED\n     * so it can be used in pp.c */\n    if (RExC_rx->intflags & PREGf_ANCH)\n        RExC_rx->extflags |= RXf_IS_ANCHORED;\n\n\n    {\n        /* this is used to identify \"special\" patterns that might result\n         * in Perl NOT calling the regex engine and instead doing the match \"itself\",\n         * particularly special cases in split//. By having the regex compiler\n         * do this pattern matching at a regop level (instead of by inspecting the pattern)\n         * we avoid weird issues with equivalent patterns resulting in different behavior,\n         * AND we allow non Perl engines to get the same optimizations by the setting the\n         * flags appropriately - Yves */\n        regnode *first = RExC_rxi->program + 1;\n        U8 fop = OP(first);\n        regnode *next = regnext(first);\n        U8 nop = OP(next);\n\n        if (PL_regkind[fop] == NOTHING && nop == END)\n            RExC_rx->extflags |= RXf_NULL;\n        else if ((fop == MBOL || (fop == SBOL && !first->flags)) && nop == END)\n            /* when fop is SBOL first->flags will be true only when it was\n             * produced by parsing /\\A/, and not when parsing /^/. This is\n             * very important for the split code as there we want to\n             * treat /^/ as /^/m, but we do not want to treat /\\A/ as /^/m.\n             * See rt #122761 for more details. -- Yves */\n            RExC_rx->extflags |= RXf_START_ONLY;\n        else if (fop == PLUS\n                 && PL_regkind[nop] == POSIXD && FLAGS(next) == _CC_SPACE\n                 && nop == END)\n            RExC_rx->extflags |= RXf_WHITE;\n        else if ( RExC_rx->extflags & RXf_SPLIT\n                  && (fop == EXACT || fop == EXACT_ONLY8 || fop == EXACTL)\n                  && STR_LEN(first) == 1\n                  && *(STRING(first)) == ' '\n                  && nop == END )\n            RExC_rx->extflags |= (RXf_SKIPWHITE|RXf_WHITE);\n\n    }\n\n    if (RExC_contains_locale) {\n        RXp_EXTFLAGS(RExC_rx) |= RXf_TAINTED;\n    }\n\n#ifdef DEBUGGING\n    if (RExC_paren_names) {\n        RExC_rxi->name_list_idx = add_data( pRExC_state, STR_WITH_LEN(\"a\"));\n        RExC_rxi->data->data[RExC_rxi->name_list_idx]\n                                   = (void*)SvREFCNT_inc(RExC_paren_name_list);\n    } else\n#endif\n    RExC_rxi->name_list_idx = 0;\n\n    while ( RExC_recurse_count > 0 ) {\n        const regnode *scan = RExC_recurse[ --RExC_recurse_count ];\n        /*\n         * This data structure is set up in study_chunk() and is used\n         * to calculate the distance between a GOSUB regopcode and\n         * the OPEN/CURLYM (CURLYM's are special and can act like OPEN's)\n         * it refers to.\n         *\n         * If for some reason someone writes code that optimises\n         * away a GOSUB opcode then the assert should be changed to\n         * an if(scan) to guard the ARG2L_SET() - Yves\n         *\n         */\n        assert(scan && OP(scan) == GOSUB);\n        ARG2L_SET( scan, RExC_open_parens[ARG(scan)] - REGNODE_OFFSET(scan));\n    }\n\n    Newxz(RExC_rx->offs, RExC_total_parens, regexp_paren_pair);\n    /* assume we don't need to swap parens around before we match */\n    DEBUG_TEST_r({\n        Perl_re_printf( aTHX_ \"study_chunk_recursed_count: %lu\\n\",\n            (unsigned long)RExC_study_chunk_recursed_count);\n    });\n    DEBUG_DUMP_r({\n        DEBUG_RExC_seen();\n        Perl_re_printf( aTHX_ \"Final program:\\n\");\n        regdump(RExC_rx);\n    });\n\n    if (RExC_open_parens) {\n        Safefree(RExC_open_parens);\n        RExC_open_parens = NULL;\n    }\n    if (RExC_close_parens) {\n        Safefree(RExC_close_parens);\n        RExC_close_parens = NULL;\n    }\n\n#ifdef USE_ITHREADS\n    /* under ithreads the ?pat? PMf_USED flag on the pmop is simulated\n     * by setting the regexp SV to readonly-only instead. If the\n     * pattern's been recompiled, the USEDness should remain. */\n    if (old_re && SvREADONLY(old_re))\n        SvREADONLY_on(Rx);\n#endif\n    return Rx;\n}",
        "start_line": 7385
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "regcomp.c",
        "method_name": "Perl_re_op_compile",
        "raw_code": "REGEXP * /* <=== Perl_re_op_compile */ \nPerl_re_op_compile(pTHX_ SV ** const patternp, int pat_count,\n\t\t    OP *expr, const regexp_engine* eng, REGEXP *old_re,\n\t\t     bool *is_bare_re, const U32 orig_rx_flags, const U32 pm_flags)\n{\n    dVAR;\n    REGEXP *Rx;         /* Capital 'R' means points to a REGEXP */\n    STRLEN plen;\n    char *exp;\n    regnode *scan;\n    I32 flags;\n    SSize_t minlen = 0;\n    U32 rx_flags;\n    SV *pat;\n    SV** new_patternp = patternp;\n\n    /* these are all flags - maybe they should be turned\n     * into a single int with different bit masks */\n    I32 sawlookahead = 0;\n    I32 sawplus = 0;\n    I32 sawopen = 0;\n    I32 sawminmod = 0;\n\n    regex_charset initial_charset = get_regex_charset(orig_rx_flags);\n    bool recompile = 0;\n    bool runtime_code = 0;\n    scan_data_t data;\n    RExC_state_t RExC_state;\n    RExC_state_t * const pRExC_state = &RExC_state;\n#ifdef TRIE_STUDY_OPT\n    int restudied = 0;\n    RExC_state_t copyRExC_state;\n#endif\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_RE_OP_COMPILE;\n\n    DEBUG_r(if (!PL_colorset) reginitcolors());\n\n    /* Initialize these here instead of as-needed, as is quick and avoids\n     * having to test them each time otherwise */\n    if (! PL_InBitmap) {\n#ifdef DEBUGGING\n        char * dump_len_string;\n#endif\n\n        /* This is calculated here, because the Perl program that generates the\n         * static global ones doesn't currently have access to\n         * NUM_ANYOF_CODE_POINTS */\n\tPL_InBitmap = _new_invlist(2);\n\tPL_InBitmap = _add_range_to_invlist(PL_InBitmap, 0,\n                                                    NUM_ANYOF_CODE_POINTS - 1);\n#ifdef DEBUGGING\n        dump_len_string = PerlEnv_getenv(\"PERL_DUMP_RE_MAX_LEN\");\n        if (   ! dump_len_string\n            || ! grok_atoUV(dump_len_string, (UV *)&PL_dump_re_max_len, NULL))\n        {\n            PL_dump_re_max_len = 60;    /* A reasonable default */\n        }\n#endif\n    }\n\n    pRExC_state->warn_text = NULL;\n    pRExC_state->unlexed_names = NULL;\n    pRExC_state->code_blocks = NULL;\n\n    if (is_bare_re)\n\t*is_bare_re = FALSE;\n\n    if (expr && (expr->op_type == OP_LIST ||\n\t\t(expr->op_type == OP_NULL && expr->op_targ == OP_LIST))) {\n\t/* allocate code_blocks if needed */\n\tOP *o;\n\tint ncode = 0;\n\n\tfor (o = cLISTOPx(expr)->op_first; o; o = OpSIBLING(o))\n\t    if (o->op_type == OP_NULL && (o->op_flags & OPf_SPECIAL))\n\t\tncode++; /* count of DO blocks */\n\n\tif (ncode)\n            pRExC_state->code_blocks = S_alloc_code_blocks(aTHX_ ncode);\n    }\n\n    if (!pat_count) {\n        /* compile-time pattern with just OP_CONSTs and DO blocks */\n\n        int n;\n        OP *o;\n\n        /* find how many CONSTs there are */\n        assert(expr);\n        n = 0;\n        if (expr->op_type == OP_CONST)\n            n = 1;\n        else\n            for (o = cLISTOPx(expr)->op_first; o; o = OpSIBLING(o)) {\n                if (o->op_type == OP_CONST)\n                    n++;\n            }\n\n        /* fake up an SV array */\n\n        assert(!new_patternp);\n        Newx(new_patternp, n, SV*);\n        SAVEFREEPV(new_patternp);\n        pat_count = n;\n\n        n = 0;\n        if (expr->op_type == OP_CONST)\n            new_patternp[n] = cSVOPx_sv(expr);\n        else\n            for (o = cLISTOPx(expr)->op_first; o; o = OpSIBLING(o)) {\n                if (o->op_type == OP_CONST)\n                    new_patternp[n++] = cSVOPo_sv;\n            }\n\n    }\n\n    DEBUG_PARSE_r(Perl_re_printf( aTHX_\n        \"Assembling pattern from %d elements%s\\n\", pat_count,\n            orig_rx_flags & RXf_SPLIT ? \" for split\" : \"\"));\n\n    /* set expr to the first arg op */\n\n    if (pRExC_state->code_blocks && pRExC_state->code_blocks->count\n         && expr->op_type != OP_CONST)\n    {\n            expr = cLISTOPx(expr)->op_first;\n            assert(   expr->op_type == OP_PUSHMARK\n                   || (expr->op_type == OP_NULL && expr->op_targ == OP_PUSHMARK)\n                   || expr->op_type == OP_PADRANGE);\n            expr = OpSIBLING(expr);\n    }\n\n    pat = S_concat_pat(aTHX_ pRExC_state, NULL, new_patternp, pat_count,\n                        expr, &recompile, NULL);\n\n    /* handle bare (possibly after overloading) regex: foo =~ $re */\n    {\n        SV *re = pat;\n        if (SvROK(re))\n            re = SvRV(re);\n        if (SvTYPE(re) == SVt_REGEXP) {\n            if (is_bare_re)\n                *is_bare_re = TRUE;\n            SvREFCNT_inc(re);\n            DEBUG_PARSE_r(Perl_re_printf( aTHX_\n                \"Precompiled pattern%s\\n\",\n                    orig_rx_flags & RXf_SPLIT ? \" for split\" : \"\"));\n\n            return (REGEXP*)re;\n        }\n    }\n\n    exp = SvPV_nomg(pat, plen);\n\n    if (!eng->op_comp) {\n\tif ((SvUTF8(pat) && IN_BYTES)\n\t\t|| SvGMAGICAL(pat) || SvAMAGIC(pat))\n\t{\n\t    /* make a temporary copy; either to convert to bytes,\n\t     * or to avoid repeating get-magic / overloaded stringify */\n\t    pat = newSVpvn_flags(exp, plen, SVs_TEMP |\n\t\t\t\t\t(IN_BYTES ? 0 : SvUTF8(pat)));\n\t}\n\treturn CALLREGCOMP_ENG(eng, pat, orig_rx_flags);\n    }\n\n    /* ignore the utf8ness if the pattern is 0 length */\n    RExC_utf8 = RExC_orig_utf8 = (plen == 0 || IN_BYTES) ? 0 : SvUTF8(pat);\n    RExC_uni_semantics = 0;\n    RExC_contains_locale = 0;\n    RExC_strict = cBOOL(pm_flags & RXf_PMf_STRICT);\n    RExC_in_script_run = 0;\n    RExC_study_started = 0;\n    pRExC_state->runtime_code_qr = NULL;\n    RExC_frame_head= NULL;\n    RExC_frame_last= NULL;\n    RExC_frame_count= 0;\n    RExC_latest_warn_offset = 0;\n    RExC_use_BRANCHJ = 0;\n    RExC_total_parens = 0;\n    RExC_open_parens = NULL;\n    RExC_close_parens = NULL;\n    RExC_paren_names = NULL;\n    RExC_size = 0;\n    RExC_seen_d_op = FALSE;\n#ifdef DEBUGGING\n    RExC_paren_name_list = NULL;\n#endif\n\n    DEBUG_r({\n        RExC_mysv1= sv_newmortal();\n        RExC_mysv2= sv_newmortal();\n    });\n\n    DEBUG_COMPILE_r({\n            SV *dsv= sv_newmortal();\n            RE_PV_QUOTED_DECL(s, RExC_utf8, dsv, exp, plen, PL_dump_re_max_len);\n            Perl_re_printf( aTHX_  \"%sCompiling REx%s %s\\n\",\n                          PL_colors[4], PL_colors[5], s);\n        });\n\n    /* we jump here if we have to recompile, e.g., from upgrading the pattern\n     * to utf8 */\n\n    if ((pm_flags & PMf_USE_RE_EVAL)\n\t\t/* this second condition covers the non-regex literal case,\n\t\t * i.e.  $foo =~ '(?{})'. */\n\t\t|| (IN_PERL_COMPILETIME && (PL_hints & HINT_RE_EVAL))\n    )\n\truntime_code = S_has_runtime_code(aTHX_ pRExC_state, exp, plen);\n\n  redo_parse:\n    /* return old regex if pattern hasn't changed */\n    /* XXX: note in the below we have to check the flags as well as the\n     * pattern.\n     *\n     * Things get a touch tricky as we have to compare the utf8 flag\n     * independently from the compile flags.  */\n\n    if (   old_re\n        && !recompile\n        && !!RX_UTF8(old_re) == !!RExC_utf8\n        && ( RX_COMPFLAGS(old_re) == ( orig_rx_flags & RXf_PMf_FLAGCOPYMASK ) )\n\t&& RX_PRECOMP(old_re)\n\t&& RX_PRELEN(old_re) == plen\n        && memEQ(RX_PRECOMP(old_re), exp, plen)\n\t&& !runtime_code /* with runtime code, always recompile */ )\n    {\n        return old_re;\n    }\n\n    /* Allocate the pattern's SV */\n    RExC_rx_sv = Rx = (REGEXP*) newSV_type(SVt_REGEXP);\n    RExC_rx = ReANY(Rx);\n    if ( RExC_rx == NULL )\n        FAIL(\"Regexp out of space\");\n\n    rx_flags = orig_rx_flags;\n\n    if (   (UTF || RExC_uni_semantics)\n        && initial_charset == REGEX_DEPENDS_CHARSET)\n    {\n\n\t/* Set to use unicode semantics if the pattern is in utf8 and has the\n\t * 'depends' charset specified, as it means unicode when utf8  */\n\tset_regex_charset(&rx_flags, REGEX_UNICODE_CHARSET);\n        RExC_uni_semantics = 1;\n    }\n\n    RExC_pm_flags = pm_flags;\n\n    if (runtime_code) {\n        assert(TAINTING_get || !TAINT_get);\n\tif (TAINT_get)\n\t    Perl_croak(aTHX_ \"Eval-group in insecure regular expression\");\n\n\tif (!S_compile_runtime_code(aTHX_ pRExC_state, exp, plen)) {\n\t    /* whoops, we have a non-utf8 pattern, whilst run-time code\n\t     * got compiled as utf8. Try again with a utf8 pattern */\n            S_pat_upgrade_to_utf8(aTHX_ pRExC_state, &exp, &plen,\n                pRExC_state->code_blocks ? pRExC_state->code_blocks->count : 0);\n            goto redo_parse;\n\t}\n    }\n    assert(!pRExC_state->runtime_code_qr);\n\n    RExC_sawback = 0;\n\n    RExC_seen = 0;\n    RExC_maxlen = 0;\n    RExC_in_lookbehind = 0;\n    RExC_seen_zerolen = *exp == '^' ? -1 : 0;\n#ifdef EBCDIC\n    RExC_recode_x_to_native = 0;\n#endif\n    RExC_in_multi_char_class = 0;\n\n    RExC_start = RExC_copy_start_in_constructed = RExC_copy_start_in_input = RExC_precomp = exp;\n    RExC_precomp_end = RExC_end = exp + plen;\n    RExC_nestroot = 0;\n    RExC_whilem_seen = 0;\n    RExC_end_op = NULL;\n    RExC_recurse = NULL;\n    RExC_study_chunk_recursed = NULL;\n    RExC_study_chunk_recursed_bytes= 0;\n    RExC_recurse_count = 0;\n    pRExC_state->code_index = 0;\n\n    /* Initialize the string in the compiled pattern.  This is so that there is\n     * something to output if necessary */\n    set_regex_pv(pRExC_state, Rx);\n\n    DEBUG_PARSE_r({\n        Perl_re_printf( aTHX_\n            \"Starting parse and generation\\n\");\n        RExC_lastnum=0;\n        RExC_lastparse=NULL;\n    });\n\n    /* Allocate space and zero-initialize. Note, the two step process\n       of zeroing when in debug mode, thus anything assigned has to\n       happen after that */\n    if (!  RExC_size) {\n\n        /* On the first pass of the parse, we guess how big this will be.  Then\n         * we grow in one operation to that amount and then give it back.  As\n         * we go along, we re-allocate what we need.\n         *\n         * XXX Currently the guess is essentially that the pattern will be an\n         * EXACT node with one byte input, one byte output.  This is crude, and\n         * better heuristics are welcome.\n         *\n         * On any subsequent passes, we guess what we actually computed in the\n         * latest earlier pass.  Such a pass probably didn't complete so is\n         * missing stuff.  We could improve those guesses by knowing where the\n         * parse stopped, and use the length so far plus apply the above\n         * assumption to what's left. */\n        RExC_size = STR_SZ(RExC_end - RExC_start);\n    }\n\n    Newxc(RExC_rxi, sizeof(regexp_internal) + RExC_size, char, regexp_internal);\n    if ( RExC_rxi == NULL )\n        FAIL(\"Regexp out of space\");\n\n    Zero(RExC_rxi, sizeof(regexp_internal) + RExC_size, char);\n    RXi_SET( RExC_rx, RExC_rxi );\n\n    /* We start from 0 (over from 0 in the case this is a reparse.  The first\n     * node parsed will give back any excess memory we have allocated so far).\n     * */\n    RExC_size = 0;\n\n    /* non-zero initialization begins here */\n    RExC_rx->engine= eng;\n    RExC_rx->extflags = rx_flags;\n    RXp_COMPFLAGS(RExC_rx) = orig_rx_flags & RXf_PMf_FLAGCOPYMASK;\n\n    if (pm_flags & PMf_IS_QR) {\n\tRExC_rxi->code_blocks = pRExC_state->code_blocks;\n        if (RExC_rxi->code_blocks) {\n            RExC_rxi->code_blocks->refcnt++;\n        }\n    }\n\n    RExC_rx->intflags = 0;\n\n    RExC_flags = rx_flags;\t/* don't let top level (?i) bleed */\n    RExC_parse = exp;\n\n    /* This NUL is guaranteed because the pattern comes from an SV*, and the sv\n     * code makes sure the final byte is an uncounted NUL.  But should this\n     * ever not be the case, lots of things could read beyond the end of the\n     * buffer: loops like\n     *      while(isFOO(*RExC_parse)) RExC_parse++;\n     *      strchr(RExC_parse, \"foo\");\n     * etc.  So it is worth noting. */\n    assert(*RExC_end == '\\0');\n\n    RExC_naughty = 0;\n    RExC_npar = 1;\n    RExC_parens_buf_size = 0;\n    RExC_emit_start = RExC_rxi->program;\n    pRExC_state->code_index = 0;\n\n    *((char*) RExC_emit_start) = (char) REG_MAGIC;\n    RExC_emit = 1;\n\n    /* Do the parse */\n    if (reg(pRExC_state, 0, &flags, 1)) {\n\n        /* Success!, But we may need to redo the parse knowing how many parens\n         * there actually are */\n        if (IN_PARENS_PASS) {\n            flags |= RESTART_PARSE;\n        }\n\n        /* We have that number in RExC_npar */\n        RExC_total_parens = RExC_npar;\n\n        /* XXX For backporting, use long jumps if there is any possibility of\n         * overflow */\n        if (RExC_size > U16_MAX && ! RExC_use_BRANCHJ) {\n            RExC_use_BRANCHJ = TRUE;\n            flags |= RESTART_PARSE;\n        }\n    }\n    else if (! MUST_RESTART(flags)) {\n\tReREFCNT_dec(Rx);\n        Perl_croak(aTHX_ \"panic: reg returned failure to re_op_compile, flags=%#\" UVxf, (UV) flags);\n    }\n\n    /* Here, we either have success, or we have to redo the parse for some reason */\n    if (MUST_RESTART(flags)) {\n\n        /* It's possible to write a regexp in ascii that represents Unicode\n        codepoints outside of the byte range, such as via \\x{100}. If we\n        detect such a sequence we have to convert the entire pattern to utf8\n        and then recompile, as our sizing calculation will have been based\n        on 1 byte == 1 character, but we will need to use utf8 to encode\n        at least some part of the pattern, and therefore must convert the whole\n        thing.\n        -- dmq */\n        if (flags & NEED_UTF8) {\n\n            /* We have stored the offset of the final warning output so far.\n             * That must be adjusted.  Any variant characters between the start\n             * of the pattern and this warning count for 2 bytes in the final,\n             * so just add them again */\n            if (UNLIKELY(RExC_latest_warn_offset > 0)) {\n                RExC_latest_warn_offset +=\n                            variant_under_utf8_count((U8 *) exp, (U8 *) exp\n                                                + RExC_latest_warn_offset);\n            }\n            S_pat_upgrade_to_utf8(aTHX_ pRExC_state, &exp, &plen,\n            pRExC_state->code_blocks ? pRExC_state->code_blocks->count : 0);\n            DEBUG_PARSE_r(Perl_re_printf( aTHX_ \"Need to redo parse after upgrade\\n\"));\n        }\n        else {\n            DEBUG_PARSE_r(Perl_re_printf( aTHX_ \"Need to redo parse\\n\"));\n        }\n\n        if (ALL_PARENS_COUNTED) {\n            /* Make enough room for all the known parens, and zero it */\n            Renew(RExC_open_parens, RExC_total_parens, regnode_offset);\n            Zero(RExC_open_parens, RExC_total_parens, regnode_offset);\n            RExC_open_parens[0] = 1;    /* +1 for REG_MAGIC */\n\n            Renew(RExC_close_parens, RExC_total_parens, regnode_offset);\n            Zero(RExC_close_parens, RExC_total_parens, regnode_offset);\n        }\n        else { /* Parse did not complete.  Reinitialize the parentheses\n                  structures */\n            RExC_total_parens = 0;\n            if (RExC_open_parens) {\n                Safefree(RExC_open_parens);\n                RExC_open_parens = NULL;\n            }\n            if (RExC_close_parens) {\n                Safefree(RExC_close_parens);\n                RExC_close_parens = NULL;\n            }\n        }\n\n        /* Clean up what we did in this parse */\n        SvREFCNT_dec_NN(RExC_rx_sv);\n\n        goto redo_parse;\n    }\n\n    /* Here, we have successfully parsed and generated the pattern's program\n     * for the regex engine.  We are ready to finish things up and look for\n     * optimizations. */\n\n    /* Update the string to compile, with correct modifiers, etc */\n    set_regex_pv(pRExC_state, Rx);\n\n    RExC_rx->nparens = RExC_total_parens - 1;\n\n    /* Uses the upper 4 bits of the FLAGS field, so keep within that size */\n    if (RExC_whilem_seen > 15)\n        RExC_whilem_seen = 15;\n\n    DEBUG_PARSE_r({\n        Perl_re_printf( aTHX_\n            \"Required size %\" IVdf \" nodes\\n\", (IV)RExC_size);\n        RExC_lastnum=0;\n        RExC_lastparse=NULL;\n    });\n\n#ifdef RE_TRACK_PATTERN_OFFSETS\n    DEBUG_OFFSETS_r(Perl_re_printf( aTHX_\n                          \"%s %\" UVuf \" bytes for offset annotations.\\n\",\n                          RExC_offsets ? \"Got\" : \"Couldn't get\",\n                          (UV)((RExC_offsets[0] * 2 + 1))));\n    DEBUG_OFFSETS_r(if (RExC_offsets) {\n        const STRLEN len = RExC_offsets[0];\n        STRLEN i;\n        GET_RE_DEBUG_FLAGS_DECL;\n        Perl_re_printf( aTHX_\n                      \"Offsets: [%\" UVuf \"]\\n\\t\", (UV)RExC_offsets[0]);\n        for (i = 1; i <= len; i++) {\n            if (RExC_offsets[i*2-1] || RExC_offsets[i*2])\n                Perl_re_printf( aTHX_  \"%\" UVuf \":%\" UVuf \"[%\" UVuf \"] \",\n                (UV)i, (UV)RExC_offsets[i*2-1], (UV)RExC_offsets[i*2]);\n        }\n        Perl_re_printf( aTHX_  \"\\n\");\n    });\n\n#else\n    SetProgLen(RExC_rxi,RExC_size);\n#endif\n\n    DEBUG_OPTIMISE_r(\n        Perl_re_printf( aTHX_  \"Starting post parse optimization\\n\");\n    );\n\n    /* XXXX To minimize changes to RE engine we always allocate\n       3-units-long substrs field. */\n    Newx(RExC_rx->substrs, 1, struct reg_substr_data);\n    if (RExC_recurse_count) {\n        Newx(RExC_recurse, RExC_recurse_count, regnode *);\n        SAVEFREEPV(RExC_recurse);\n    }\n\n    if (RExC_seen & REG_RECURSE_SEEN) {\n        /* Note, RExC_total_parens is 1 + the number of parens in a pattern.\n         * So its 1 if there are no parens. */\n        RExC_study_chunk_recursed_bytes= (RExC_total_parens >> 3) +\n                                         ((RExC_total_parens & 0x07) != 0);\n        Newx(RExC_study_chunk_recursed,\n             RExC_study_chunk_recursed_bytes * RExC_total_parens, U8);\n        SAVEFREEPV(RExC_study_chunk_recursed);\n    }\n\n  reStudy:\n    RExC_rx->minlen = minlen = sawlookahead = sawplus = sawopen = sawminmod = 0;\n    DEBUG_r(\n        RExC_study_chunk_recursed_count= 0;\n    );\n    Zero(RExC_rx->substrs, 1, struct reg_substr_data);\n    if (RExC_study_chunk_recursed) {\n        Zero(RExC_study_chunk_recursed,\n             RExC_study_chunk_recursed_bytes * RExC_total_parens, U8);\n    }\n\n\n#ifdef TRIE_STUDY_OPT\n    if (!restudied) {\n        StructCopy(&zero_scan_data, &data, scan_data_t);\n        copyRExC_state = RExC_state;\n    } else {\n        U32 seen=RExC_seen;\n        DEBUG_OPTIMISE_r(Perl_re_printf( aTHX_ \"Restudying\\n\"));\n\n        RExC_state = copyRExC_state;\n        if (seen & REG_TOP_LEVEL_BRANCHES_SEEN)\n            RExC_seen |= REG_TOP_LEVEL_BRANCHES_SEEN;\n        else\n            RExC_seen &= ~REG_TOP_LEVEL_BRANCHES_SEEN;\n\tStructCopy(&zero_scan_data, &data, scan_data_t);\n    }\n#else\n    StructCopy(&zero_scan_data, &data, scan_data_t);\n#endif\n\n    /* Dig out information for optimizations. */\n    RExC_rx->extflags = RExC_flags; /* was pm_op */\n    /*dmq: removed as part of de-PMOP: pm->op_pmflags = RExC_flags; */\n\n    if (UTF)\n\tSvUTF8_on(Rx);\t/* Unicode in it? */\n    RExC_rxi->regstclass = NULL;\n    if (RExC_naughty >= TOO_NAUGHTY)\t/* Probably an expensive pattern. */\n\tRExC_rx->intflags |= PREGf_NAUGHTY;\n    scan = RExC_rxi->program + 1;\t\t/* First BRANCH. */\n\n    /* testing for BRANCH here tells us whether there is \"must appear\"\n       data in the pattern. If there is then we can use it for optimisations */\n    if (!(RExC_seen & REG_TOP_LEVEL_BRANCHES_SEEN)) { /*  Only one top-level choice.\n                                                  */\n\tSSize_t fake;\n\tSTRLEN longest_length[2];\n\tregnode_ssc ch_class; /* pointed to by data */\n\tint stclass_flag;\n\tSSize_t last_close = 0; /* pointed to by data */\n        regnode *first= scan;\n        regnode *first_next= regnext(first);\n        int i;\n\n\t/*\n\t * Skip introductions and multiplicators >= 1\n\t * so that we can extract the 'meat' of the pattern that must\n\t * match in the large if() sequence following.\n\t * NOTE that EXACT is NOT covered here, as it is normally\n\t * picked up by the optimiser separately.\n\t *\n\t * This is unfortunate as the optimiser isnt handling lookahead\n\t * properly currently.\n\t *\n\t */\n\twhile ((OP(first) == OPEN && (sawopen = 1)) ||\n\t       /* An OR of *one* alternative - should not happen now. */\n\t    (OP(first) == BRANCH && OP(first_next) != BRANCH) ||\n\t    /* for now we can't handle lookbehind IFMATCH*/\n\t    (OP(first) == IFMATCH && !first->flags && (sawlookahead = 1)) ||\n\t    (OP(first) == PLUS) ||\n\t    (OP(first) == MINMOD) ||\n\t       /* An {n,m} with n>0 */\n\t    (PL_regkind[OP(first)] == CURLY && ARG1(first) > 0) ||\n\t    (OP(first) == NOTHING && PL_regkind[OP(first_next)] != END ))\n\t{\n\t\t/*\n\t\t * the only op that could be a regnode is PLUS, all the rest\n\t\t * will be regnode_1 or regnode_2.\n\t\t *\n                 * (yves doesn't think this is true)\n\t\t */\n\t\tif (OP(first) == PLUS)\n\t\t    sawplus = 1;\n                else {\n                    if (OP(first) == MINMOD)\n                        sawminmod = 1;\n\t\t    first += regarglen[OP(first)];\n                }\n\t\tfirst = NEXTOPER(first);\n\t\tfirst_next= regnext(first);\n\t}\n\n\t/* Starting-point info. */\n      again:\n        DEBUG_PEEP(\"first:\", first, 0, 0);\n        /* Ignore EXACT as we deal with it later. */\n\tif (PL_regkind[OP(first)] == EXACT) {\n\t    if (   OP(first) == EXACT\n                || OP(first) == EXACT_ONLY8\n                || OP(first) == EXACTL)\n            {\n\t\tNOOP;\t/* Empty, get anchored substr later. */\n            }\n\t    else\n\t\tRExC_rxi->regstclass = first;\n\t}\n#ifdef TRIE_STCLASS\n\telse if (PL_regkind[OP(first)] == TRIE &&\n\t        ((reg_trie_data *)RExC_rxi->data->data[ ARG(first) ])->minlen>0)\n\t{\n            /* this can happen only on restudy */\n            RExC_rxi->regstclass = construct_ahocorasick_from_trie(pRExC_state, (regnode *)first, 0);\n\t}\n#endif\n\telse if (REGNODE_SIMPLE(OP(first)))\n\t    RExC_rxi->regstclass = first;\n\telse if (PL_regkind[OP(first)] == BOUND ||\n\t\t PL_regkind[OP(first)] == NBOUND)\n\t    RExC_rxi->regstclass = first;\n\telse if (PL_regkind[OP(first)] == BOL) {\n            RExC_rx->intflags |= (OP(first) == MBOL\n                           ? PREGf_ANCH_MBOL\n                           : PREGf_ANCH_SBOL);\n\t    first = NEXTOPER(first);\n\t    goto again;\n\t}\n\telse if (OP(first) == GPOS) {\n            RExC_rx->intflags |= PREGf_ANCH_GPOS;\n\t    first = NEXTOPER(first);\n\t    goto again;\n\t}\n\telse if ((!sawopen || !RExC_sawback) &&\n            !sawlookahead &&\n\t    (OP(first) == STAR &&\n\t    PL_regkind[OP(NEXTOPER(first))] == REG_ANY) &&\n            !(RExC_rx->intflags & PREGf_ANCH) && !pRExC_state->code_blocks)\n\t{\n\t    /* turn .* into ^.* with an implied $*=1 */\n\t    const int type =\n\t\t(OP(NEXTOPER(first)) == REG_ANY)\n                    ? PREGf_ANCH_MBOL\n                    : PREGf_ANCH_SBOL;\n            RExC_rx->intflags |= (type | PREGf_IMPLICIT);\n\t    first = NEXTOPER(first);\n\t    goto again;\n\t}\n        if (sawplus && !sawminmod && !sawlookahead\n            && (!sawopen || !RExC_sawback)\n\t    && !pRExC_state->code_blocks) /* May examine pos and $& */\n\t    /* x+ must match at the 1st pos of run of x's */\n\t    RExC_rx->intflags |= PREGf_SKIP;\n\n\t/* Scan is after the zeroth branch, first is atomic matcher. */\n#ifdef TRIE_STUDY_OPT\n\tDEBUG_PARSE_r(\n\t    if (!restudied)\n                Perl_re_printf( aTHX_  \"first at %\" IVdf \"\\n\",\n\t\t\t      (IV)(first - scan + 1))\n        );\n#else\n\tDEBUG_PARSE_r(\n            Perl_re_printf( aTHX_  \"first at %\" IVdf \"\\n\",\n\t        (IV)(first - scan + 1))\n        );\n#endif\n\n\n\t/*\n\t* If there's something expensive in the r.e., find the\n\t* longest literal string that must appear and make it the\n\t* regmust.  Resolve ties in favor of later strings, since\n\t* the regstart check works with the beginning of the r.e.\n\t* and avoiding duplication strengthens checking.  Not a\n\t* strong reason, but sufficient in the absence of others.\n\t* [Now we resolve ties in favor of the earlier string if\n\t* it happens that c_offset_min has been invalidated, since the\n\t* earlier string may buy us something the later one won't.]\n\t*/\n\n\tdata.substrs[0].str = newSVpvs(\"\");\n\tdata.substrs[1].str = newSVpvs(\"\");\n\tdata.last_found = newSVpvs(\"\");\n\tdata.cur_is_floating = 0; /* initially any found substring is fixed */\n\tENTER_with_name(\"study_chunk\");\n\tSAVEFREESV(data.substrs[0].str);\n\tSAVEFREESV(data.substrs[1].str);\n\tSAVEFREESV(data.last_found);\n\tfirst = scan;\n\tif (!RExC_rxi->regstclass) {\n\t    ssc_init(pRExC_state, &ch_class);\n\t    data.start_class = &ch_class;\n\t    stclass_flag = SCF_DO_STCLASS_AND;\n\t} else\t\t\t\t/* XXXX Check for BOUND? */\n\t    stclass_flag = 0;\n\tdata.last_closep = &last_close;\n\n        DEBUG_RExC_seen();\n        /*\n         * MAIN ENTRY FOR study_chunk() FOR m/PATTERN/\n         * (NO top level branches)\n         */\n\tminlen = study_chunk(pRExC_state, &first, &minlen, &fake,\n                             scan + RExC_size, /* Up to end */\n            &data, -1, 0, NULL,\n            SCF_DO_SUBSTR | SCF_WHILEM_VISITED_POS | stclass_flag\n                          | (restudied ? SCF_TRIE_DOING_RESTUDY : 0),\n            0);\n\n\n        CHECK_RESTUDY_GOTO_butfirst(LEAVE_with_name(\"study_chunk\"));\n\n\n\tif ( RExC_total_parens == 1 && !data.cur_is_floating\n\t     && data.last_start_min == 0 && data.last_end > 0\n\t     && !RExC_seen_zerolen\n             && !(RExC_seen & REG_VERBARG_SEEN)\n             && !(RExC_seen & REG_GPOS_SEEN)\n        ){\n\t    RExC_rx->extflags |= RXf_CHECK_ALL;\n        }\n\tscan_commit(pRExC_state, &data,&minlen, 0);\n\n\n        /* XXX this is done in reverse order because that's the way the\n         * code was before it was parameterised. Don't know whether it\n         * actually needs doing in reverse order. DAPM */\n        for (i = 1; i >= 0; i--) {\n            longest_length[i] = CHR_SVLEN(data.substrs[i].str);\n\n            if (   !(   i\n                     && SvCUR(data.substrs[0].str)  /* ok to leave SvCUR */\n                     &&    data.substrs[0].min_offset\n                        == data.substrs[1].min_offset\n                     &&    SvCUR(data.substrs[0].str)\n                        == SvCUR(data.substrs[1].str)\n                    )\n                && S_setup_longest (aTHX_ pRExC_state,\n                                        &(RExC_rx->substrs->data[i]),\n                                        &(data.substrs[i]),\n                                        longest_length[i]))\n            {\n                RExC_rx->substrs->data[i].min_offset =\n                        data.substrs[i].min_offset - data.substrs[i].lookbehind;\n\n                RExC_rx->substrs->data[i].max_offset = data.substrs[i].max_offset;\n                /* Don't offset infinity */\n                if (data.substrs[i].max_offset < SSize_t_MAX)\n                    RExC_rx->substrs->data[i].max_offset -= data.substrs[i].lookbehind;\n                SvREFCNT_inc_simple_void_NN(data.substrs[i].str);\n            }\n            else {\n                RExC_rx->substrs->data[i].substr      = NULL;\n                RExC_rx->substrs->data[i].utf8_substr = NULL;\n                longest_length[i] = 0;\n            }\n        }\n\n\tLEAVE_with_name(\"study_chunk\");\n\n\tif (RExC_rxi->regstclass\n\t    && (OP(RExC_rxi->regstclass) == REG_ANY || OP(RExC_rxi->regstclass) == SANY))\n\t    RExC_rxi->regstclass = NULL;\n\n\tif ((!(RExC_rx->substrs->data[0].substr || RExC_rx->substrs->data[0].utf8_substr)\n              || RExC_rx->substrs->data[0].min_offset)\n\t    && stclass_flag\n            && ! (ANYOF_FLAGS(data.start_class) & SSC_MATCHES_EMPTY_STRING)\n\t    && is_ssc_worth_it(pRExC_state, data.start_class))\n\t{\n\t    const U32 n = add_data(pRExC_state, STR_WITH_LEN(\"f\"));\n\n            ssc_finalize(pRExC_state, data.start_class);\n\n\t    Newx(RExC_rxi->data->data[n], 1, regnode_ssc);\n\t    StructCopy(data.start_class,\n\t\t       (regnode_ssc*)RExC_rxi->data->data[n],\n\t\t       regnode_ssc);\n\t    RExC_rxi->regstclass = (regnode*)RExC_rxi->data->data[n];\n\t    RExC_rx->intflags &= ~PREGf_SKIP;\t/* Used in find_byclass(). */\n\t    DEBUG_COMPILE_r({ SV *sv = sv_newmortal();\n                      regprop(RExC_rx, sv, (regnode*)data.start_class, NULL, pRExC_state);\n                      Perl_re_printf( aTHX_\n\t\t\t\t    \"synthetic stclass \\\"%s\\\".\\n\",\n\t\t\t\t    SvPVX_const(sv));});\n            data.start_class = NULL;\n\t}\n\n        /* A temporary algorithm prefers floated substr to fixed one of\n         * same length to dig more info. */\n\ti = (longest_length[0] <= longest_length[1]);\n        RExC_rx->substrs->check_ix = i;\n        RExC_rx->check_end_shift  = RExC_rx->substrs->data[i].end_shift;\n        RExC_rx->check_substr     = RExC_rx->substrs->data[i].substr;\n        RExC_rx->check_utf8       = RExC_rx->substrs->data[i].utf8_substr;\n        RExC_rx->check_offset_min = RExC_rx->substrs->data[i].min_offset;\n        RExC_rx->check_offset_max = RExC_rx->substrs->data[i].max_offset;\n        if (!i && (RExC_rx->intflags & (PREGf_ANCH_SBOL|PREGf_ANCH_GPOS)))\n            RExC_rx->intflags |= PREGf_NOSCAN;\n\n\tif ((RExC_rx->check_substr || RExC_rx->check_utf8) ) {\n\t    RExC_rx->extflags |= RXf_USE_INTUIT;\n\t    if (SvTAIL(RExC_rx->check_substr ? RExC_rx->check_substr : RExC_rx->check_utf8))\n\t\tRExC_rx->extflags |= RXf_INTUIT_TAIL;\n\t}\n\n\t/* XXX Unneeded? dmq (shouldn't as this is handled elsewhere)\n\tif ( (STRLEN)minlen < longest_length[1] )\n            minlen= longest_length[1];\n        if ( (STRLEN)minlen < longest_length[0] )\n            minlen= longest_length[0];\n        */\n    }\n    else {\n\t/* Several toplevels. Best we can is to set minlen. */\n\tSSize_t fake;\n\tregnode_ssc ch_class;\n\tSSize_t last_close = 0;\n\n        DEBUG_PARSE_r(Perl_re_printf( aTHX_  \"\\nMulti Top Level\\n\"));\n\n\tscan = RExC_rxi->program + 1;\n\tssc_init(pRExC_state, &ch_class);\n\tdata.start_class = &ch_class;\n\tdata.last_closep = &last_close;\n\n        DEBUG_RExC_seen();\n        /*\n         * MAIN ENTRY FOR study_chunk() FOR m/P1|P2|.../\n         * (patterns WITH top level branches)\n         */\n\tminlen = study_chunk(pRExC_state,\n            &scan, &minlen, &fake, scan + RExC_size, &data, -1, 0, NULL,\n            SCF_DO_STCLASS_AND|SCF_WHILEM_VISITED_POS|(restudied\n                                                      ? SCF_TRIE_DOING_RESTUDY\n                                                      : 0),\n            0);\n\n        CHECK_RESTUDY_GOTO_butfirst(NOOP);\n\n\tRExC_rx->check_substr = NULL;\n        RExC_rx->check_utf8 = NULL;\n        RExC_rx->substrs->data[0].substr      = NULL;\n        RExC_rx->substrs->data[0].utf8_substr = NULL;\n        RExC_rx->substrs->data[1].substr      = NULL;\n        RExC_rx->substrs->data[1].utf8_substr = NULL;\n\n        if (! (ANYOF_FLAGS(data.start_class) & SSC_MATCHES_EMPTY_STRING)\n\t    && is_ssc_worth_it(pRExC_state, data.start_class))\n        {\n\t    const U32 n = add_data(pRExC_state, STR_WITH_LEN(\"f\"));\n\n            ssc_finalize(pRExC_state, data.start_class);\n\n\t    Newx(RExC_rxi->data->data[n], 1, regnode_ssc);\n\t    StructCopy(data.start_class,\n\t\t       (regnode_ssc*)RExC_rxi->data->data[n],\n\t\t       regnode_ssc);\n\t    RExC_rxi->regstclass = (regnode*)RExC_rxi->data->data[n];\n\t    RExC_rx->intflags &= ~PREGf_SKIP;\t/* Used in find_byclass(). */\n\t    DEBUG_COMPILE_r({ SV* sv = sv_newmortal();\n                      regprop(RExC_rx, sv, (regnode*)data.start_class, NULL, pRExC_state);\n                      Perl_re_printf( aTHX_\n\t\t\t\t    \"synthetic stclass \\\"%s\\\".\\n\",\n\t\t\t\t    SvPVX_const(sv));});\n            data.start_class = NULL;\n\t}\n    }\n\n    if (RExC_seen & REG_UNBOUNDED_QUANTIFIER_SEEN) {\n        RExC_rx->extflags |= RXf_UNBOUNDED_QUANTIFIER_SEEN;\n        RExC_rx->maxlen = REG_INFTY;\n    }\n    else {\n        RExC_rx->maxlen = RExC_maxlen;\n    }\n\n    /* Guard against an embedded (?=) or (?<=) with a longer minlen than\n       the \"real\" pattern. */\n    DEBUG_OPTIMISE_r({\n        Perl_re_printf( aTHX_ \"minlen: %\" IVdf \" RExC_rx->minlen:%\" IVdf \" maxlen:%\" IVdf \"\\n\",\n                      (IV)minlen, (IV)RExC_rx->minlen, (IV)RExC_maxlen);\n    });\n    RExC_rx->minlenret = minlen;\n    if (RExC_rx->minlen < minlen)\n        RExC_rx->minlen = minlen;\n\n    if (RExC_seen & REG_RECURSE_SEEN ) {\n        RExC_rx->intflags |= PREGf_RECURSE_SEEN;\n        Newx(RExC_rx->recurse_locinput, RExC_rx->nparens + 1, char *);\n    }\n    if (RExC_seen & REG_GPOS_SEEN)\n        RExC_rx->intflags |= PREGf_GPOS_SEEN;\n    if (RExC_seen & REG_LOOKBEHIND_SEEN)\n        RExC_rx->extflags |= RXf_NO_INPLACE_SUBST; /* inplace might break the\n                                                lookbehind */\n    if (pRExC_state->code_blocks)\n\tRExC_rx->extflags |= RXf_EVAL_SEEN;\n    if (RExC_seen & REG_VERBARG_SEEN)\n    {\n\tRExC_rx->intflags |= PREGf_VERBARG_SEEN;\n        RExC_rx->extflags |= RXf_NO_INPLACE_SUBST; /* don't understand this! Yves */\n    }\n    if (RExC_seen & REG_CUTGROUP_SEEN)\n\tRExC_rx->intflags |= PREGf_CUTGROUP_SEEN;\n    if (pm_flags & PMf_USE_RE_EVAL)\n\tRExC_rx->intflags |= PREGf_USE_RE_EVAL;\n    if (RExC_paren_names)\n        RXp_PAREN_NAMES(RExC_rx) = MUTABLE_HV(SvREFCNT_inc(RExC_paren_names));\n    else\n        RXp_PAREN_NAMES(RExC_rx) = NULL;\n\n    /* If we have seen an anchor in our pattern then we set the extflag RXf_IS_ANCHORED\n     * so it can be used in pp.c */\n    if (RExC_rx->intflags & PREGf_ANCH)\n        RExC_rx->extflags |= RXf_IS_ANCHORED;\n\n\n    {\n        /* this is used to identify \"special\" patterns that might result\n         * in Perl NOT calling the regex engine and instead doing the match \"itself\",\n         * particularly special cases in split//. By having the regex compiler\n         * do this pattern matching at a regop level (instead of by inspecting the pattern)\n         * we avoid weird issues with equivalent patterns resulting in different behavior,\n         * AND we allow non Perl engines to get the same optimizations by the setting the\n         * flags appropriately - Yves */\n        regnode *first = RExC_rxi->program + 1;\n        U8 fop = OP(first);\n        regnode *next = regnext(first);\n        U8 nop = OP(next);\n\n        if (PL_regkind[fop] == NOTHING && nop == END)\n            RExC_rx->extflags |= RXf_NULL;\n        else if ((fop == MBOL || (fop == SBOL && !first->flags)) && nop == END)\n            /* when fop is SBOL first->flags will be true only when it was\n             * produced by parsing /\\A/, and not when parsing /^/. This is\n             * very important for the split code as there we want to\n             * treat /^/ as /^/m, but we do not want to treat /\\A/ as /^/m.\n             * See rt #122761 for more details. -- Yves */\n            RExC_rx->extflags |= RXf_START_ONLY;\n        else if (fop == PLUS\n                 && PL_regkind[nop] == POSIXD && FLAGS(next) == _CC_SPACE\n                 && nop == END)\n            RExC_rx->extflags |= RXf_WHITE;\n        else if ( RExC_rx->extflags & RXf_SPLIT\n                  && (fop == EXACT || fop == EXACT_ONLY8 || fop == EXACTL)\n                  && STR_LEN(first) == 1\n                  && *(STRING(first)) == ' '\n                  && nop == END )\n            RExC_rx->extflags |= (RXf_SKIPWHITE|RXf_WHITE);\n\n    }\n\n    if (RExC_contains_locale) {\n        RXp_EXTFLAGS(RExC_rx) |= RXf_TAINTED;\n    }\n\n#ifdef DEBUGGING\n    if (RExC_paren_names) {\n        RExC_rxi->name_list_idx = add_data( pRExC_state, STR_WITH_LEN(\"a\"));\n        RExC_rxi->data->data[RExC_rxi->name_list_idx]\n                                   = (void*)SvREFCNT_inc(RExC_paren_name_list);\n    } else\n#endif\n    RExC_rxi->name_list_idx = 0;\n\n    while ( RExC_recurse_count > 0 ) {\n        const regnode *scan = RExC_recurse[ --RExC_recurse_count ];\n        /*\n         * This data structure is set up in study_chunk() and is used\n         * to calculate the distance between a GOSUB regopcode and\n         * the OPEN/CURLYM (CURLYM's are special and can act like OPEN's)\n         * it refers to.\n         *\n         * If for some reason someone writes code that optimises\n         * away a GOSUB opcode then the assert should be changed to\n         * an if(scan) to guard the ARG2L_SET() - Yves\n         *\n         */\n        assert(scan && OP(scan) == GOSUB);\n        ARG2L_SET( scan, RExC_open_parens[ARG(scan)] - REGNODE_OFFSET(scan));\n    }\n\n    Newxz(RExC_rx->offs, RExC_total_parens, regexp_paren_pair);\n    /* assume we don't need to swap parens around before we match */\n    DEBUG_TEST_r({\n        Perl_re_printf( aTHX_ \"study_chunk_recursed_count: %lu\\n\",\n            (unsigned long)RExC_study_chunk_recursed_count);\n    });\n    DEBUG_DUMP_r({\n        DEBUG_RExC_seen();\n        Perl_re_printf( aTHX_ \"Final program:\\n\");\n        regdump(RExC_rx);\n    });\n\n    if (RExC_open_parens) {\n        Safefree(RExC_open_parens);\n        RExC_open_parens = NULL;\n    }\n    if (RExC_close_parens) {\n        Safefree(RExC_close_parens);\n        RExC_close_parens = NULL;\n    }\n\n#ifdef USE_ITHREADS\n    /* under ithreads the ?pat? PMf_USED flag on the pmop is simulated\n     * by setting the regexp SV to readonly-only instead. If the\n     * pattern's been recompiled, the USEDness should remain. */\n    if (old_re && SvREADONLY(old_re))\n        SvREADONLY_on(Rx);\n#endif\n    return Rx;\n}",
        "start_line": 7385
      }
    ],
    "code_context": "Called Methods:\n- Perl_croak: void /* <=== Perl_croak */ \nPerl_croak(pTHX_ const char *pat, ...)\n{\n    va_list args;\n    va_start(args, pat);\n    vcroak(pat, &args);\n    NOT_REACHED; /* NOTREACHED */\n    va_end(args);\n}\n- Safefree: #define Safefree(d)\tsafefree(MEM_LOG_FREE((Malloc_t)(d))) /* <=== handy.h:2436:2436:Safefree:1 */ \n- SAVE_ERRNO: #   define SAVE_ERRNO     (saved_errno = errno) /* <=== perl.h:1336:1336:SAVE_ERRNO:0 */ \n- PREGf_IMPLICIT: #define PREGf_IMPLICIT\t\t0x00000002 /* Converted .* to ^.* */ /* <=== regcomp.h:131:131:PREGf_IMPLICIT:0 */ \n- SAVETMPS: #define SAVETMPS Perl_savetmps(aTHX) /* <=== scope.h:183:183:SAVETMPS:0 */ \n- Perl_eval_sv: I32 /* <=== Perl_eval_sv */ \nPerl_eval_sv(pTHX_ SV *sv, I32 flags)\n\n          \t\t/* See G_* flags in cop.h */\n{\n    dVAR;\n    UNOP myop;\t\t/* fake syntax tree node */\n    volatile I32 oldmark;\n    volatile I32 retval = 0;\n    int ret;\n    OP* const oldop = PL_op;\n    dJMPENV;\n\n    PERL_ARGS_ASSERT_EVAL_SV;\n\n    if (flags & G_DISCARD) {\n\tENTER;\n\tSAVETMPS;\n    }\n\n    SAVEOP();\n    PL_op = (OP*)&myop;\n    Zero(&myop, 1, UNOP);\n    {\n\tdSP;\n\toldmark = SP - PL_stack_base;\n\tEXTEND(SP, 1);\n\tPUSHs(sv);\n\tPUTBACK;\n    }\n\n    if (!(flags & G_NOARGS))\n\tmyop.op_flags = OPf_STACKED;\n    myop.op_type = OP_ENTEREVAL;\n    myop.op_flags |= OP_GIMME_REVERSE(flags);\n    if (flags & G_KEEPERR)\n\tmyop.op_flags |= OPf_SPECIAL;\n\n    if (flags & G_RE_REPARSING)\n\tmyop.op_private = (OPpEVAL_COPHH | OPpEVAL_RE_REPARSING);\n\n    /* fail now; otherwise we could fail after the JMPENV_PUSH but\n     * before a cx_pusheval(), which corrupts the stack after a croak */\n    TAINT_PROPER(\"eval_sv()\");\n\n    JMPENV_PUSH(ret);\n    switch (ret) {\n    case 0:\n redo_body:\n\tif (PL_op == (OP*)(&myop)) {\n\t    PL_op = PL_ppaddr[OP_ENTEREVAL](aTHX);\n\t    if (!PL_op)\n\t\tgoto fail; /* failed in compilation */\n\t}\n\tCALLRUNOPS(aTHX);\n\tretval = PL_stack_sp - (PL_stack_base + oldmark);\n\tif (!(flags & G_KEEPERR)) {\n\t    CLEAR_ERRSV();\n\t}\n\tbreak;\n    case 1:\n\tSTATUS_ALL_FAILURE;\n\t/* FALLTHROUGH */\n    case 2:\n\t/* my_exit() was called */\n\tSET_CURSTASH(PL_defstash);\n\tFREETMPS;\n\tJMPENV_POP;\n\tmy_exit_jump();\n\tNOT_REACHED; /* NOTREACHED */\n    case 3:\n\tif (PL_restartop) {\n\t    PL_restartjmpenv = NULL;\n\t    PL_op = PL_restartop;\n\t    PL_restartop = 0;\n\t    goto redo_body;\n\t}\n      fail:\n\tPL_stack_sp = PL_stack_base + oldmark;\n\tif ((flags & G_WANT) == G_ARRAY)\n\t    retval = 0;\n\telse {\n\t    retval = 1;\n\t    *++PL_stack_sp = &PL_sv_undef;\n\t}\n\tbreak;\n    }\n\n    JMPENV_POP;\n    if (flags & G_DISCARD) {\n\tPL_stack_sp = PL_stack_base + oldmark;\n\tretval = 0;\n\tFREETMPS;\n\tLEAVE;\n    }\n    PL_op = oldop;\n    return retval;\n}\n- cLISTOPx: #define cLISTOPx(o)\t((LISTOP*)(o)) /* <=== op.h:433:433:cLISTOPx:1 */ \n- sv_catsv_nomg: #define sv_catsv_nomg(dsv, ssv) sv_catsv_flags(dsv, ssv, 0) /* <=== sv.h:1924:1924:sv_catsv_nomg:2 */ \n- RXf_PMf_MULTILINE: #define RXf_PMf_MULTILINE      (1U << (RXf_PMf_STD_PMMOD_SHIFT+0))    /* /m */ /* <=== op_reg_common.h:31:31:RXf_PMf_MULTILINE:0 */ \n- SvEND: #  define SvEND(sv) ((sv)->sv_u.svu_pv + ((XPV*)SvANY(sv))->xpv_cur) /* <=== sv.h:1174:1174:SvEND:1 */ \n- CHR_SVLEN: #define CHR_SVLEN(sv) (UTF ? sv_len_utf8(sv) : SvCUR(sv)) /* <=== regcomp.c:611:611:CHR_SVLEN:1 */ \n- RExC_end: #define RExC_end\t(pRExC_state->end) /* <=== regcomp.c:240:240:RExC_end:0 */ \n- EXACT_ONLY8: #define\tEXACT_ONLY8           \t44\t/* 0x2c Like EXACT, but only UTF-8 encoded targets can match */ /* <=== regnodes.h:58:58:EXACT_ONLY8:0 */ \n- FALSE: #define FALSE (0) /* <=== handy.h:45:45:FALSE:0 */ \n- PREGf_RECURSE_SEEN: #define PREGf_RECURSE_SEEN      0x00002000 /* <=== regcomp.h:145:145:PREGf_RECURSE_SEEN:0 */ \n- REG_LOOKBEHIND_SEEN: #define REG_LOOKBEHIND_SEEN                 0x00000002 /* <=== regcomp.h:721:721:REG_LOOKBEHIND_SEEN:0 */ \n- SANY: #define\tSANY                  \t17\t/* 0x11 Match any one character. */ /* <=== regnodes.h:31:31:SANY:0 */ \n- Perl_mg_size: I32 /* <=== Perl_mg_size */ \nPerl_mg_size(pTHX_ SV *sv)\n{\n    MAGIC* mg;\n\n    PERL_ARGS_ASSERT_MG_SIZE;\n\n    for (mg = SvMAGIC(sv); mg; mg = mg->mg_moremagic) {\n        const MGVTBL* const vtbl = mg->mg_virtual;\n\tif (vtbl && vtbl->svt_len) {\n            const I32 mgs_ix = SSNEW(sizeof(MGS));\n            I32 len;\n\t    save_magic(mgs_ix, sv);\n\t    /* omit MGf_GSKIP -- not changed here */\n\t    len = vtbl->svt_len(aTHX_ sv, mg);\n\t    restore_magic(INT2PTR(void*, (IV)mgs_ix));\n\t    return len;\n\t}\n    }\n\n    switch(SvTYPE(sv)) {\n\tcase SVt_PVAV:\n\t    return AvFILLp((const AV *) sv); /* Fallback to non-tied array */\n\tcase SVt_PVHV:\n\t    /* FIXME */\n\tdefault:\n\t    Perl_croak(aTHX_ \"Size magic not implemented\");\n\n    }\n    NOT_REACHED; /* NOTREACHED */\n}\n- Perl_sv_2mortal: SV * /* <=== Perl_sv_2mortal */ \nPerl_sv_2mortal(pTHX_ SV *const sv)\n{\n    dVAR;\n    if (!sv)\n\treturn sv;\n    if (SvIMMORTAL(sv))\n\treturn sv;\n    PUSH_EXTEND_MORTAL__SV_C(sv);\n    SvTEMP_on(sv);\n    return sv;\n}\n- SetProgLen: #define SetProgLen(ri,x) ri->u.proglen = x /* <=== regcomp.c:977:977:SetProgLen:2 */ \n- SBOL: #define\tSBOL                  \t2\t/* 0x02 Match \"\" at beginning of line: /^/, /\\A/ */ /* <=== regnodes.h:14:14:SBOL:0 */ \n- sv_setsv: #define sv_setsv(dsv, ssv) \\ /* <=== sv.h:1920:1921:sv_setsv:2 */ \n\tsv_setsv_flags(dsv, ssv, SV_GMAGIC|SV_DO_COW_SVSETSV)\n- Perl_sv_pvn_force_flags: char * /* <=== Perl_sv_pvn_force_flags */ \nPerl_sv_pvn_force_flags(pTHX_ SV *const sv, STRLEN *const lp, const I32 flags)\n{\n    PERL_ARGS_ASSERT_SV_PVN_FORCE_FLAGS;\n\n    if (flags & SV_GMAGIC) SvGETMAGIC(sv);\n    if (SvTHINKFIRST(sv) && (!SvROK(sv) || SvREADONLY(sv)))\n        sv_force_normal_flags(sv, 0);\n\n    if (SvPOK(sv)) {\n\tif (lp)\n\t    *lp = SvCUR(sv);\n    }\n    else {\n\tchar *s;\n\tSTRLEN len;\n \n\tif (SvTYPE(sv) > SVt_PVLV\n\t    || isGV_with_GP(sv))\n\t    /* diag_listed_as: Can't coerce %s to %s in %s */\n\t    Perl_croak(aTHX_ \"Can't coerce %s to string in %s\", sv_reftype(sv,0),\n\t\tOP_DESC(PL_op));\n\ts = sv_2pv_flags(sv, &len, flags &~ SV_GMAGIC);\n\tif (!s) {\n\t  s = (char *)\"\";\n\t}\n\tif (lp)\n\t    *lp = len;\n\n        if (SvTYPE(sv) < SVt_PV ||\n            s != SvPVX_const(sv)) {\t/* Almost, but not quite, sv_setpvn() */\n\t    if (SvROK(sv))\n\t\tsv_unref(sv);\n\t    SvUPGRADE(sv, SVt_PV);\t\t/* Never FALSE */\n\t    SvGROW(sv, len + 1);\n\t    Move(s,SvPVX(sv),len,char);\n\t    SvCUR_set(sv, len);\n\t    SvPVX(sv)[len] = '\\0';\n\t}\n\tif (!SvPOK(sv)) {\n\t    SvPOK_on(sv);\t\t/* validate pointer */\n\t    SvTAINT(sv);\n\t    DEBUG_c(PerlIO_printf(Perl_debug_log, \"0x%\" UVxf \" 2pv(%s)\\n\",\n\t\t\t\t  PTR2UV(sv),SvPVX_const(sv)));\n\t}\n    }\n    (void)SvPOK_only_UTF8(sv);\n    return SvPVX_mutable(sv);\n}\n- Perl_save_re_context: void /* <=== Perl_save_re_context */ \nPerl_save_re_context(pTHX)\n{\n    I32 nparens = -1;\n    I32 i;\n\n    /* Save $1..$n (#18107: UTF-8 s/(\\w+)/uc($1)/e); AMS 20021106. */\n\n    if (PL_curpm) {\n\tconst REGEXP * const rx = PM_GETRE(PL_curpm);\n\tif (rx)\n            nparens = RX_NPARENS(rx);\n    }\n\n    /* RT #124109. This is a complete hack; in the SWASHNEW case we know\n     * that PL_curpm will be null, but that utf8.pm and the modules it\n     * loads will only use $1..$3.\n     * The t/porting/re_context.t test file checks this assumption.\n     */\n    if (nparens == -1)\n        nparens = 3;\n\n    for (i = 1; i <= nparens; i++) {\n        char digits[TYPE_CHARS(long)];\n        const STRLEN len = my_snprintf(digits, sizeof(digits),\n                                       \"%lu\", (long)i);\n        GV *const *const gvp\n            = (GV**)hv_fetch(PL_defstash, digits, len, 0);\n\n        if (gvp) {\n            GV * const gv = *gvp;\n            if (SvTYPE(gv) == SVt_PVGV && GvSV(gv))\n                save_scalar(gv);\n        }\n    }\n}\n- TRIE: #define\tTRIE                  \t81\t/* 0x51 Match many EXACT(F[ALU]?)? at once. flags==type */ /* <=== regnodes.h:95:95:TRIE:0 */ \n- Newxc: #define Newxc(v,n,t,c)\t(v = (MEM_WRAP_CHECK_(n,t) (c*)MEM_LOG_ALLOC(n,t,safemalloc((MEM_SIZE)((n)*sizeof(t)))))) /* <=== handy.h:2417:2417:Newxc:4 */ \n- STRING: #define\tSTRING(p)\t(((struct regnode_string *)p)->string) /* <=== regcomp.h:337:337:STRING:1 */ \n- cBOOL: #define cBOOL(cbool) ((cbool) ? (bool)1 : (bool)0) /* <=== handy.h:104:104:cBOOL:1 */ \n- S_more_sv: STATIC SV* /* <=== S_more_sv */ \nS_more_sv(pTHX)\n{\n    SV* sv;\n    char *chunk;                /* must use New here to match call to */\n    Newx(chunk,PERL_ARENA_SIZE,char);  /* Safefree() in sv_free_arenas() */\n    sv_add_arena(chunk, PERL_ARENA_SIZE, 0);\n    uproot_SV(sv);\n    return sv;\n}\n- AMG_CALLunary: #define AMG_CALLunary(sv,meth) \\ /* <=== pp.h:577:578:AMG_CALLunary:2 */ \n    amagic_call(sv,&PL_sv_undef, meth, AMGf_noright | AMGf_unary)\n- S_has_runtime_code: static bool /* <=== S_has_runtime_code */ \nS_has_runtime_code(pTHX_ RExC_state_t * const pRExC_state,\n\t\t    char *pat, STRLEN plen)\n{\n    int n = 0;\n    STRLEN s;\n\n    PERL_UNUSED_CONTEXT;\n\n    for (s = 0; s < plen; s++) {\n\tif (   pRExC_state->code_blocks\n            && n < pRExC_state->code_blocks->count\n\t    && s == pRExC_state->code_blocks->cb[n].start)\n\t{\n\t    s = pRExC_state->code_blocks->cb[n].end;\n\t    n++;\n\t    continue;\n\t}\n\t/* TODO ideally should handle [..], (#..), /#.../x to reduce false\n\t * positives here */\n\tif (pat[s] == '(' && s+2 <= plen && pat[s+1] == '?' &&\n\t    (pat[s+2] == '{'\n                || (s + 2 <= plen && pat[s+2] == '?' && pat[s+3] == '{'))\n\t)\n\t    return 1;\n    }\n    return 0;\n}\n- PREGf_NOSCAN: #define PREGf_NOSCAN            0x00000040 /* <=== regcomp.h:137:137:PREGf_NOSCAN:0 */ \n- SVfARG: #define SVfARG(p) ((void*)(p)) /* <=== perl.h:3342:3342:SVfARG:1 */ \n- Perl_mg_set: int /* <=== Perl_mg_set */ \nPerl_mg_set(pTHX_ SV *sv)\n{\n    const I32 mgs_ix = SSNEW(sizeof(MGS));\n    MAGIC* mg;\n    MAGIC* nextmg;\n\n    PERL_ARGS_ASSERT_MG_SET;\n\n    if (PL_localizing == 2 && sv == DEFSV) return 0;\n\n    save_magic_flags(mgs_ix, sv, SVs_GMG|SVs_SMG); /* leave SVs_RMG on */\n\n    for (mg = SvMAGIC(sv); mg; mg = nextmg) {\n        const MGVTBL* vtbl = mg->mg_virtual;\n\tnextmg = mg->mg_moremagic;\t/* it may delete itself */\n\tif (mg->mg_flags & MGf_GSKIP) {\n\t    mg->mg_flags &= ~MGf_GSKIP;\t/* setting requires another read */\n\t    (SSPTR(mgs_ix, MGS*))->mgs_flags &= ~(SVs_GMG|SVs_SMG|SVs_RMG);\n\t}\n\tif (PL_localizing == 2\n\t    && PERL_MAGIC_TYPE_IS_VALUE_MAGIC(mg->mg_type))\n\t    continue;\n\tif (vtbl && vtbl->svt_set)\n\t    vtbl->svt_set(aTHX_ sv, mg);\n    }\n\n    restore_magic(INT2PTR(void*, (IV)mgs_ix));\n    return 0;\n}\n- BRANCH: #define\tBRANCH                \t34\t/* 0x22 Match this alternative, or the next... */ /* <=== regnodes.h:48:48:BRANCH:0 */ \n- SAVEDESTRUCTOR_X: #define SAVEDESTRUCTOR_X(f,p) \\ /* <=== scope.h:256:257:SAVEDESTRUCTOR_X:2 */ \n\t  save_destructor_x((DESTRUCTORFUNC_t)(f), (void*)(p))\n- REG_INFTY: #  define REG_INFTY U16_MAX /* <=== regcomp.h:287:287:REG_INFTY:0 */ \n- MUTABLE_HV: #define MUTABLE_HV(p)\t((HV *)MUTABLE_PTR(p)) /* <=== handy.h:65:65:MUTABLE_HV:1 */ \n- PREGf_ANCH_SBOL: #define PREGf_ANCH_SBOL         0x00000800 /* <=== regcomp.h:143:143:PREGf_ANCH_SBOL:0 */ \n- SvIsCOW_shared_hash: #define SvIsCOW_shared_hash(sv)\t(SvIsCOW(sv) && SvLEN(sv) == 0) /* <=== sv.h:1828:1828:SvIsCOW_shared_hash:1 */ \n- NOTHING: #define\tNOTHING               \t47\t/* 0x2f Match empty string. */ /* <=== regnodes.h:61:61:NOTHING:0 */ \n- ARG1: #define ARG1(p) ARG_VALUE(ARG1_LOC(p)) /* <=== regcomp.h:298:298:ARG1:1 */ \n- Perl_safesysmalloc: Malloc_t /* <=== Perl_safesysmalloc */ \nPerl_safesysmalloc(MEM_SIZE size)\n{\n#ifdef ALWAYS_NEED_THX\n    dTHX;\n#endif\n    Malloc_t ptr;\n    dSAVEDERRNO;\n\n#ifdef USE_MDH\n    if (size + PERL_MEMORY_DEBUG_HEADER_SIZE < size)\n        goto out_of_memory;\n    size += PERL_MEMORY_DEBUG_HEADER_SIZE;\n#endif\n#ifdef DEBUGGING\n    if ((SSize_t)size < 0)\n\tPerl_croak_nocontext(\"panic: malloc, size=%\" UVuf, (UV) size);\n#endif\n    if (!size) size = 1;\t/* malloc(0) is NASTY on our system */\n    SAVE_ERRNO;\n#ifdef PERL_DEBUG_READONLY_COW\n    if ((ptr = mmap(0, size, PROT_READ|PROT_WRITE,\n\t\t    MAP_ANON|MAP_PRIVATE, -1, 0)) == MAP_FAILED) {\n\tperror(\"mmap failed\");\n\tabort();\n    }\n#else\n    ptr = (Malloc_t)PerlMem_malloc(size?size:1);\n#endif\n    PERL_ALLOC_CHECK(ptr);\n    if (ptr != NULL) {\n#ifdef USE_MDH\n\tstruct perl_memory_debug_header *const header\n\t    = (struct perl_memory_debug_header *)ptr;\n#endif\n\n#ifdef PERL_POISON\n\tPoisonNew(((char *)ptr), size, char);\n#endif\n\n#ifdef PERL_TRACK_MEMPOOL\n\theader->interpreter = aTHX;\n\t/* Link us into the list.  */\n\theader->prev = &PL_memory_debug_header;\n\theader->next = PL_memory_debug_header.next;\n\tPL_memory_debug_header.next = header;\n\tmaybe_protect_rw(header->next);\n\theader->next->prev = header;\n\tmaybe_protect_ro(header->next);\n#  ifdef PERL_DEBUG_READONLY_COW\n\theader->readonly = 0;\n#  endif\n#endif\n#ifdef MDH_HAS_SIZE\n\theader->size = size;\n#endif\n\tptr = (Malloc_t)((char*)ptr+PERL_MEMORY_DEBUG_HEADER_SIZE);\n\tDEBUG_m(PerlIO_printf(Perl_debug_log, \"0x%\" UVxf \": (%05ld) malloc %ld bytes\\n\",PTR2UV(ptr),(long)PL_an++,(long)size));\n\n        /* malloc() can modify errno() even on success, but since someone\n\t   writing perl code doesn't have any control over when perl calls\n\t   malloc() we need to hide that.\n\t*/\n        RESTORE_ERRNO;\n    }\n    else {\n#ifdef USE_MDH\n      out_of_memory:\n#endif\n        {\n#ifndef ALWAYS_NEED_THX\n            dTHX;\n#endif\n            if (PL_nomemok)\n                ptr =  NULL;\n            else\n                croak_no_mem();\n        }\n    }\n    return ptr;\n}\n- Perl_gv_fetchpvn_flags: GV * /* <=== Perl_gv_fetchpvn_flags */ \nPerl_gv_fetchpvn_flags(pTHX_ const char *nambeg, STRLEN full_len, I32 flags,\n\t\t       const svtype sv_type)\n{\n    const char *name = nambeg;\n    GV *gv = NULL;\n    GV**gvp;\n    STRLEN len;\n    HV *stash = NULL;\n    const I32 no_init = flags & (GV_NOADD_NOINIT | GV_NOINIT);\n    const I32 no_expand = flags & GV_NOEXPAND;\n    const I32 add = flags & ~GV_NOADD_MASK;\n    const U32 is_utf8 = flags & SVf_UTF8;\n    bool addmg = cBOOL(flags & GV_ADDMG);\n    const char *const name_end = nambeg + full_len;\n    U32 faking_it;\n\n    PERL_ARGS_ASSERT_GV_FETCHPVN_FLAGS;\n\n     /* If we have GV_NOTQUAL, the caller promised that\n      * there is no stash, so we can skip the check.\n      * Similarly if full_len is 0, since then we're\n      * dealing with something like *{\"\"} or \"\"->foo()\n      */\n    if ((flags & GV_NOTQUAL) || !full_len) {\n        len = full_len;\n    }\n    else if (parse_gv_stash_name(&stash, &gv, &name, &len, nambeg, full_len, is_utf8, add)) {\n        if (name == name_end) return gv;\n    }\n    else {\n        return NULL;\n    }\n\n    if (!stash && !find_default_stash(&stash, name, len, is_utf8, add, sv_type)) {\n        return NULL;\n    }\n    \n    /* By this point we should have a stash and a name */\n    gvp = (GV**)hv_fetch(stash,name,is_utf8 ? -(I32)len : (I32)len,add);\n    if (!gvp || *gvp == (const GV *)&PL_sv_undef) {\n\tif (addmg) gv = (GV *)newSV(0);\n\telse return NULL;\n    }\n    else gv = *gvp, addmg = 0;\n    /* From this point on, addmg means gv has not been inserted in the\n       symtab yet. */\n\n    if (SvTYPE(gv) == SVt_PVGV) {\n        /* The GV already exists, so return it, but check if we need to do\n         * anything else with it before that.\n         */\n\tif (add) {\n            /* This is the heuristic that handles if a variable triggers the\n             * 'used only once' warning.  If there's already a GV in the stash\n             * with this name, then we assume that the variable has been used\n             * before and turn its MULTI flag on.\n             * It's a heuristic because it can easily be \"tricked\", like with\n             * BEGIN { $a = 1; $::{foo} = *a }; () = $foo\n             * not warning about $main::foo being used just once\n             */\n\t    GvMULTI_on(gv);\n\t    gv_init_svtype(gv, sv_type);\n            /* You reach this path once the typeglob has already been created,\n               either by the same or a different sigil.  If this path didn't\n               exist, then (say) referencing $! first, and %! second would\n               mean that %! was not handled correctly.  */\n\t    if (len == 1 && stash == PL_defstash) {\n                maybe_multimagic_gv(gv, name, sv_type);\n\t    }\n            else if (sv_type == SVt_PVAV\n\t          && memEQs(name, len, \"ISA\")\n\t          && (!GvAV(gv) || !SvSMAGICAL(GvAV(gv))))\n\t\tgv_magicalize_isa(gv);\n\t}\n\treturn gv;\n    } else if (no_init) {\n\tassert(!addmg);\n\treturn gv;\n    }\n    /* If GV_NOEXPAND is true and what we got off the stash is a ref,\n     * don't expand it to a glob. This is an optimization so that things\n     * copying constants over, like Exporter, don't have to be rewritten\n     * to take into account that you can store more than just globs in\n     * stashes.\n     */\n    else if (no_expand && SvROK(gv)) {\n\tassert(!addmg);\n\treturn gv;\n    }\n\n    /* Adding a new symbol.\n       Unless of course there was already something non-GV here, in which case\n       we want to behave as if there was always a GV here, containing some sort\n       of subroutine.\n       Otherwise we run the risk of creating things like GvIO, which can cause\n       subtle bugs. eg the one that tripped up SQL::Translator  */\n\n    faking_it = SvOK(gv);\n\n    if (add & GV_ADDWARN)\n\tPerl_ck_warner_d(aTHX_ packWARN(WARN_INTERNAL),\n\t\t\"Had to create %\" UTF8f \" unexpectedly\",\n\t\t UTF8fARG(is_utf8, name_end-nambeg, nambeg));\n    gv_init_pvn(gv, stash, name, len, (add & GV_ADDMULTI)|is_utf8);\n\n    if (   full_len != 0\n        && isIDFIRST_lazy_if_safe(name, name + full_len, is_utf8)\n        && !ckWARN(WARN_ONCE) )\n    {\n        GvMULTI_on(gv) ;\n    }\n\n    /* set up magic where warranted */\n    if ( gv_magicalize(gv, stash, name, len, sv_type) ) {\n        /* See 23496c6 */\n        if (addmg) {\n                /* gv_magicalize magicalised this gv, so we want it\n                 * stored in the symtab.\n                 * Effectively the caller is asking, Does this gv exist? \n                 * And we respond, Er, *now* it does!\n                 */\n                (void)hv_store(stash,name,len,(SV *)gv,0);\n        }\n    }\n    else if (addmg) {\n                /* The temporary GV created above */\n                SvREFCNT_dec_NN(gv);\n                gv = NULL;\n    }\n    \n    if (gv) gv_init_svtype(gv, faking_it ? SVt_PVCV : sv_type);\n    return gv;\n}\n- SvREFCNT_inc_simple_void_NN: #define SvREFCNT_inc_simple_void_NN(sv)\t(void)(++SvREFCNT(MUTABLE_SV(sv))) /* <=== sv.h:346:346:SvREFCNT_inc_simple_void_NN:1 */ \n- UTF: #define UTF cBOOL(RExC_utf8) /* <=== regcomp.c:581:581:UTF:0 */ \n- S_alloc_code_blocks: static struct reg_code_blocks * /* <=== S_alloc_code_blocks */ \nS_alloc_code_blocks(pTHX_  int ncode)\n{\n     struct reg_code_blocks *cbs;\n    Newx(cbs, 1, struct reg_code_blocks);\n    cbs->count = ncode;\n    cbs->refcnt = 1;\n    SAVEDESTRUCTOR_X(S_free_codeblocks, cbs);\n    if (ncode)\n        Newx(cbs->cb, ncode, struct reg_code_block);\n    else\n        cbs->cb = NULL;\n    return cbs;\n}\n- SPAGAIN: #define SPAGAIN\t\tsp = PL_stack_sp /* <=== pp.h:87:87:SPAGAIN:0 */ \n- PERL_MEMORY_DEBUG_HEADER_SIZE: #  define PERL_MEMORY_DEBUG_HEADER_SIZE\t0 /* <=== perl.h:4350:4350:PERL_MEMORY_DEBUG_HEADER_SIZE:0 */ \n- Perl_sv_upgrade: void /* <=== Perl_sv_upgrade */ \nPerl_sv_upgrade(pTHX_ SV *const sv, svtype new_type)\n{\n    void*\told_body;\n    void*\tnew_body;\n    const svtype old_type = SvTYPE(sv);\n    const struct body_details *new_type_details;\n    const struct body_details *old_type_details\n\t= bodies_by_type + old_type;\n    SV *referent = NULL;\n\n    PERL_ARGS_ASSERT_SV_UPGRADE;\n\n    if (old_type == new_type)\n\treturn;\n\n    /* This clause was purposefully added ahead of the early return above to\n       the shared string hackery for (sort {$a <=> $b} keys %hash), with the\n       inference by Nick I-S that it would fix other troublesome cases. See\n       changes 7162, 7163 (f130fd4589cf5fbb24149cd4db4137c8326f49c1 and parent)\n\n       Given that shared hash key scalars are no longer PVIV, but PV, there is\n       no longer need to unshare so as to free up the IVX slot for its proper\n       purpose. So it's safe to move the early return earlier.  */\n\n    if (new_type > SVt_PVMG && SvIsCOW(sv)) {\n\tsv_force_normal_flags(sv, 0);\n    }\n\n    old_body = SvANY(sv);\n\n    /* Copying structures onto other structures that have been neatly zeroed\n       has a subtle gotcha. Consider XPVMG\n\n       +------+------+------+------+------+-------+-------+\n       |     NV      | CUR  | LEN  |  IV  | MAGIC | STASH |\n       +------+------+------+------+------+-------+-------+\n       0      4      8     12     16     20      24      28\n\n       where NVs are aligned to 8 bytes, so that sizeof that structure is\n       actually 32 bytes long, with 4 bytes of padding at the end:\n\n       +------+------+------+------+------+-------+-------+------+\n       |     NV      | CUR  | LEN  |  IV  | MAGIC | STASH | ???  |\n       +------+------+------+------+------+-------+-------+------+\n       0      4      8     12     16     20      24      28     32\n\n       so what happens if you allocate memory for this structure:\n\n       +------+------+------+------+------+-------+-------+------+------+...\n       |     NV      | CUR  | LEN  |  IV  | MAGIC | STASH |  GP  | NAME |\n       +------+------+------+------+------+-------+-------+------+------+...\n       0      4      8     12     16     20      24      28     32     36\n\n       zero it, then copy sizeof(XPVMG) bytes on top of it? Not quite what you\n       expect, because you copy the area marked ??? onto GP. Now, ??? may have\n       started out as zero once, but it's quite possible that it isn't. So now,\n       rather than a nicely zeroed GP, you have it pointing somewhere random.\n       Bugs ensue.\n\n       (In fact, GP ends up pointing at a previous GP structure, because the\n       principle cause of the padding in XPVMG getting garbage is a copy of\n       sizeof(XPVMG) bytes from a XPVGV structure in sv_unglob. Right now\n       this happens to be moot because XPVGV has been re-ordered, with GP\n       no longer after STASH)\n\n       So we are careful and work out the size of used parts of all the\n       structures.  */\n\n    switch (old_type) {\n    case SVt_NULL:\n\tbreak;\n    case SVt_IV:\n\tif (SvROK(sv)) {\n\t    referent = SvRV(sv);\n\t    old_type_details = &fake_rv;\n\t    if (new_type == SVt_NV)\n\t\tnew_type = SVt_PVNV;\n\t} else {\n\t    if (new_type < SVt_PVIV) {\n\t\tnew_type = (new_type == SVt_NV)\n\t\t    ? SVt_PVNV : SVt_PVIV;\n\t    }\n\t}\n\tbreak;\n    case SVt_NV:\n\tif (new_type < SVt_PVNV) {\n\t    new_type = SVt_PVNV;\n\t}\n\tbreak;\n    case SVt_PV:\n\tassert(new_type > SVt_PV);\n\tSTATIC_ASSERT_STMT(SVt_IV < SVt_PV);\n\tSTATIC_ASSERT_STMT(SVt_NV < SVt_PV);\n\tbreak;\n    case SVt_PVIV:\n\tbreak;\n    case SVt_PVNV:\n\tbreak;\n    case SVt_PVMG:\n\t/* Because the XPVMG of PL_mess_sv isn't allocated from the arena,\n\t   there's no way that it can be safely upgraded, because perl.c\n\t   expects to Safefree(SvANY(PL_mess_sv))  */\n\tassert(sv != PL_mess_sv);\n\tbreak;\n    default:\n\tif (UNLIKELY(old_type_details->cant_upgrade))\n\t    Perl_croak(aTHX_ \"Can't upgrade %s (%\" UVuf \") to %\" UVuf,\n\t\t       sv_reftype(sv, 0), (UV) old_type, (UV) new_type);\n    }\n\n    if (UNLIKELY(old_type > new_type))\n\tPerl_croak(aTHX_ \"sv_upgrade from type %d down to type %d\",\n\t\t(int)old_type, (int)new_type);\n\n    new_type_details = bodies_by_type + new_type;\n\n    SvFLAGS(sv) &= ~SVTYPEMASK;\n    SvFLAGS(sv) |= new_type;\n\n    /* This can't happen, as SVt_NULL is <= all values of new_type, so one of\n       the return statements above will have triggered.  */\n    assert (new_type != SVt_NULL);\n    switch (new_type) {\n    case SVt_IV:\n\tassert(old_type == SVt_NULL);\n\tSET_SVANY_FOR_BODYLESS_IV(sv);\n\tSvIV_set(sv, 0);\n\treturn;\n    case SVt_NV:\n\tassert(old_type == SVt_NULL);\n#if NVSIZE <= IVSIZE\n\tSET_SVANY_FOR_BODYLESS_NV(sv);\n#else\n\tSvANY(sv) = new_XNV();\n#endif\n\tSvNV_set(sv, 0);\n\treturn;\n    case SVt_PVHV:\n    case SVt_PVAV:\n\tassert(new_type_details->body_size);\n\n#ifndef PURIFY\t\n\tassert(new_type_details->arena);\n\tassert(new_type_details->arena_size);\n\t/* This points to the start of the allocated area.  */\n\tnew_body_inline(new_body, new_type);\n\tZero(new_body, new_type_details->body_size, char);\n\tnew_body = ((char *)new_body) - new_type_details->offset;\n#else\n\t/* We always allocated the full length item with PURIFY. To do this\n\t   we fake things so that arena is false for all 16 types..  */\n\tnew_body = new_NOARENAZ(new_type_details);\n#endif\n\tSvANY(sv) = new_body;\n\tif (new_type == SVt_PVAV) {\n\t    AvMAX(sv)\t= -1;\n\t    AvFILLp(sv)\t= -1;\n\t    AvREAL_only(sv);\n\t    if (old_type_details->body_size) {\n\t\tAvALLOC(sv) = 0;\n\t    } else {\n\t\t/* It will have been zeroed when the new body was allocated.\n\t\t   Lets not write to it, in case it confuses a write-back\n\t\t   cache.  */\n\t    }\n\t} else {\n\t    assert(!SvOK(sv));\n\t    SvOK_off(sv);\n#ifndef NODEFAULT_SHAREKEYS\n\t    HvSHAREKEYS_on(sv);         /* key-sharing on by default */\n#endif\n            /* start with PERL_HASH_DEFAULT_HvMAX+1 buckets: */\n\t    HvMAX(sv) = PERL_HASH_DEFAULT_HvMAX;\n\t}\n\n\t/* SVt_NULL isn't the only thing upgraded to AV or HV.\n\t   The target created by newSVrv also is, and it can have magic.\n\t   However, it never has SvPVX set.\n\t*/\n\tif (old_type == SVt_IV) {\n\t    assert(!SvROK(sv));\n\t} else if (old_type >= SVt_PV) {\n\t    assert(SvPVX_const(sv) == 0);\n\t}\n\n\tif (old_type >= SVt_PVMG) {\n\t    SvMAGIC_set(sv, ((XPVMG*)old_body)->xmg_u.xmg_magic);\n\t    SvSTASH_set(sv, ((XPVMG*)old_body)->xmg_stash);\n\t} else {\n\t    sv->sv_u.svu_array = NULL; /* or svu_hash  */\n\t}\n\tbreak;\n\n    case SVt_PVIV:\n\t/* XXX Is this still needed?  Was it ever needed?   Surely as there is\n\t   no route from NV to PVIV, NOK can never be true  */\n\tassert(!SvNOKp(sv));\n\tassert(!SvNOK(sv));\n        /* FALLTHROUGH */\n    case SVt_PVIO:\n    case SVt_PVFM:\n    case SVt_PVGV:\n    case SVt_PVCV:\n    case SVt_PVLV:\n    case SVt_INVLIST:\n    case SVt_REGEXP:\n    case SVt_PVMG:\n    case SVt_PVNV:\n    case SVt_PV:\n\n\tassert(new_type_details->body_size);\n\t/* We always allocated the full length item with PURIFY. To do this\n\t   we fake things so that arena is false for all 16 types..  */\n\tif(new_type_details->arena) {\n\t    /* This points to the start of the allocated area.  */\n\t    new_body_inline(new_body, new_type);\n\t    Zero(new_body, new_type_details->body_size, char);\n\t    new_body = ((char *)new_body) - new_type_details->offset;\n\t} else {\n\t    new_body = new_NOARENAZ(new_type_details);\n\t}\n\tSvANY(sv) = new_body;\n\n\tif (old_type_details->copy) {\n\t    /* There is now the potential for an upgrade from something without\n\t       an offset (PVNV or PVMG) to something with one (PVCV, PVFM)  */\n\t    int offset = old_type_details->offset;\n\t    int length = old_type_details->copy;\n\n\t    if (new_type_details->offset > old_type_details->offset) {\n\t\tconst int difference\n\t\t    = new_type_details->offset - old_type_details->offset;\n\t\toffset += difference;\n\t\tlength -= difference;\n\t    }\n\t    assert (length >= 0);\n\t\t\n\t    Copy((char *)old_body + offset, (char *)new_body + offset, length,\n\t\t char);\n\t}\n\n#ifndef NV_ZERO_IS_ALLBITS_ZERO\n\t/* If NV 0.0 is stores as all bits 0 then Zero() already creates a\n\t * correct 0.0 for us.  Otherwise, if the old body didn't have an\n\t * NV slot, but the new one does, then we need to initialise the\n\t * freshly created NV slot with whatever the correct bit pattern is\n\t * for 0.0  */\n\tif (old_type_details->zero_nv && !new_type_details->zero_nv\n\t    && !isGV_with_GP(sv))\n\t    SvNV_set(sv, 0);\n#endif\n\n\tif (UNLIKELY(new_type == SVt_PVIO)) {\n\t    IO * const io = MUTABLE_IO(sv);\n\t    GV *iogv = gv_fetchpvs(\"IO::File::\", GV_ADD, SVt_PVHV);\n\n\t    SvOBJECT_on(io);\n\t    /* Clear the stashcache because a new IO could overrule a package\n\t       name */\n            DEBUG_o(Perl_deb(aTHX_ \"sv_upgrade clearing PL_stashcache\\n\"));\n\t    hv_clear(PL_stashcache);\n\n\t    SvSTASH_set(io, MUTABLE_HV(SvREFCNT_inc(GvHV(iogv))));\n\t    IoPAGE_LEN(sv) = 60;\n\t}\n\tif (old_type < SVt_PV) {\n\t    /* referent will be NULL unless the old type was SVt_IV emulating\n\t       SVt_RV */\n\t    sv->sv_u.svu_rv = referent;\n\t}\n\tbreak;\n    default:\n\tPerl_croak(aTHX_ \"panic: sv_upgrade to unknown type %lu\",\n\t\t   (unsigned long)new_type);\n    }\n\n    /* if this is zero, this is a body-less SVt_NULL, SVt_IV/SVt_RV,\n       and sometimes SVt_NV */\n    if (old_type_details->body_size) {\n#ifdef PURIFY\n\tsafefree(old_body);\n#else\n\t/* Note that there is an assumption that all bodies of types that\n\t   can be upgraded came from arenas. Only the more complex non-\n\t   upgradable types are allowed to be directly malloc()ed.  */\n\tassert(old_type_details->arena);\n\tdel_body((void*)((char*)old_body + old_type_details->offset),\n\t\t &PL_body_roots[old_type]);\n#endif\n    }\n}\n- RExC_copy_start_in_constructed: #define RExC_copy_start_in_constructed  (pRExC_state->copy_start) /* <=== regcomp.c:233:233:RExC_copy_start_in_constructed:0 */ \n- DEBUG_PEEP: #  define DEBUG_PEEP(str, scan, depth, flags)         NOOP /* <=== regcomp.c:1213:1213:DEBUG_PEEP:4 */ \n- RXf_TAINTED: #define RXf_TAINTED\t\t(1U<<(RXf_BASE_SHIFT+13)) /* <=== regexp.h:448:448:RXf_TAINTED:0 */ \n- GvSV: #define GvSV(gv)\t(GvGP(gv)->gp_sv) /* <=== gv.h:96:96:GvSV:1 */ \n- RExC_flags: #define RExC_flags\t(pRExC_state->flags) /* <=== regcomp.c:229:229:RExC_flags:0 */ \n- RExC_naughty: #define RExC_naughty\t(pRExC_state->naughty) /* <=== regcomp.c:296:296:RExC_naughty:0 */ \n- RExC_parse: #define RExC_parse\t(pRExC_state->parse) /* <=== regcomp.c:241:241:RExC_parse:0 */ \n- RExC_total_parens: #define RExC_total_parens\t(pRExC_state->total_par) /* <=== regcomp.c:259:259:RExC_total_parens:0 */ \n- cSVOPx_sv: #  define\tcSVOPx_sv(v)\t(cSVOPx(v)->op_sv) /* <=== op.h:516:516:cSVOPx_sv:1 */ \n- FLAGS: #define FLAGS(p)\t((p)->flags)\t/* Caution: Doesn't apply to all      \\ /* <=== regcomp.h:331:331:FLAGS:1 */ \n- PREGf_NAUGHTY: #define PREGf_NAUGHTY\t\t0x00000004 /* how exponential is this pattern? */ /* <=== regcomp.h:132:132:PREGf_NAUGHTY:0 */ \n- TAINT_get: #   define TAINT_get\t\t(PL_tainted) /* <=== perl.h:632:632:TAINT_get:0 */ \n- Perl_av_fetch: SV** /* <=== Perl_av_fetch */ \nPerl_av_fetch(pTHX_ AV *av, SSize_t key, I32 lval)\n{\n    SSize_t neg;\n    SSize_t size;\n\n    PERL_ARGS_ASSERT_AV_FETCH;\n    assert(SvTYPE(av) == SVt_PVAV);\n\n    if (UNLIKELY(SvRMAGICAL(av))) {\n        const MAGIC * const tied_magic\n\t    = mg_find((const SV *)av, PERL_MAGIC_tied);\n        if (tied_magic || mg_find((const SV *)av, PERL_MAGIC_regdata)) {\n\t    SV *sv;\n\t    if (key < 0) {\n\t\tif (!S_adjust_index(aTHX_ av, tied_magic, &key))\n\t\t\treturn NULL;\n\t    }\n\n            sv = sv_newmortal();\n\t    sv_upgrade(sv, SVt_PVLV);\n\t    mg_copy(MUTABLE_SV(av), sv, 0, key);\n\t    if (!tied_magic) /* for regdata, force leavesub to make copies */\n\t\tSvTEMP_off(sv);\n\t    LvTYPE(sv) = 't';\n\t    LvTARG(sv) = sv; /* fake (SV**) */\n\t    return &(LvTARG(sv));\n        }\n    }\n\n    neg  = (key < 0);\n    size = AvFILLp(av) + 1;\n    key += neg * size; /* handle negative index without using branch */\n\n    /* the cast from SSize_t to Size_t allows both (key < 0) and (key >= size)\n     * to be tested as a single condition */\n    if ((Size_t)key >= (Size_t)size) {\n\tif (UNLIKELY(neg))\n\t    return NULL;\n        goto emptyness;\n    }\n\n    if (!AvARRAY(av)[key]) {\n      emptyness:\n\treturn lval ? av_store(av,key,newSV(0)) : NULL;\n    }\n\n    return &AvARRAY(av)[key];\n}\n- RXf_SKIPWHITE: #define RXf_SKIPWHITE           (1U<<(RXf_BASE_SHIFT+15)) /* Pattern is for a */ /* <=== regexp.h:452:452:RXf_SKIPWHITE:0 */ \n- RExC_close_parens: #define RExC_close_parens\t(pRExC_state->close_parens) /* <=== regcomp.c:267:267:RExC_close_parens:0 */ \n- PerlMem_free: #define PerlMem_free(buf)\t\tfree((buf)) /* <=== iperlsys.h:885:885:PerlMem_free:1 */ \n- GPOS: #define\tGPOS                  \t7\t/* 0x07 Matches where last m//g left off. */ /* <=== regnodes.h:21:21:GPOS:0 */ \n- save_re_context: #define save_re_context()\tPerl_save_re_context(aTHX) /* <=== embed.h:690:690:save_re_context:0 */ \n- new_SV: #  define new_SV(p) \\ /* <=== sv.c:352:362:new_SV:1 */ \n    STMT_START {\t\t\t\t\t\\\n\tif (PL_sv_root)\t\t\t\t\t\\\n\t    uproot_SV(p);\t\t\t\t\\\n\telse\t\t\t\t\t\t\\\n\t    (p) = S_more_sv(aTHX);\t\t\t\\\n\tSvANY(p) = 0;\t\t\t\t\t\\\n\tSvREFCNT(p) = 1;\t\t\t\t\\\n\tSvFLAGS(p) = 0;\t\t\t\t\t\\\n\tMEM_LOG_NEW_SV(p, __FILE__, __LINE__, FUNCTION__);  \\\n    } STMT_END\n- REG_ANY: #define\tREG_ANY               \t16\t/* 0x10 Match any one character (except newline). */ /* <=== regnodes.h:30:30:REG_ANY:0 */ \n- SAVEFREESV: #define SAVEFREESV(s)\tsave_freesv(MUTABLE_SV(s)) /* <=== scope.h:236:236:SAVEFREESV:1 */ \n- check_substr: #define check_substr substrs->data[2].substr /* <=== regcomp.h:807:807:check_substr:0 */ \n- REG_CUTGROUP_SEEN: #define REG_CUTGROUP_SEEN                   0x00000100 /* <=== regcomp.h:727:727:REG_CUTGROUP_SEEN:0 */ \n- SvCUR: #    define SvCUR(sv) ((XPV*) SvANY(sv))->xpv_cur /* <=== sv.h:1240:1240:SvCUR:1 */ \n- RXf_EVAL_SEEN: #define RXf_EVAL_SEEN   \t(1U<<(RXf_BASE_SHIFT+3)) /* <=== regexp.h:424:424:RXf_EVAL_SEEN:0 */ \n- check_offset_min: #define check_offset_min substrs->data[2].min_offset /* <=== regcomp.h:809:809:check_offset_min:0 */ \n- Newxz: #define Newxz(v,n,t)\t(v = (MEM_WRAP_CHECK_(n,t) (t*)MEM_LOG_ALLOC(n,t,safecalloc((n),sizeof(t))))) /* <=== handy.h:2418:2418:Newxz:3 */ \n- HINT_RE_EVAL: #define HINT_RE_EVAL\t\t0x00200000 /* re pragma */ /* <=== perl.h:5105:5105:HINT_RE_EVAL:0 */ \n- RXp_EXTFLAGS: #define RXp_EXTFLAGS(rx)                ((rx)->extflags) /* <=== regexp.h:509:509:RXp_EXTFLAGS:1 */ \n- RXf_PMf_EXTENDED_MORE: #define RXf_PMf_EXTENDED_MORE  (1U << (RXf_PMf_STD_PMMOD_SHIFT+4))    /* /xx */ /* <=== op_reg_common.h:35:35:RXf_PMf_EXTENDED_MORE:0 */ \n- SvROK: #define SvROK(sv)\t\t(SvFLAGS(sv) & SVf_ROK) /* <=== sv.h:958:958:SvROK:1 */ \n- Perl_savetmps: void /* <=== Perl_savetmps */ \nPerl_savetmps(pTHX)\n{\n    dSS_ADD;\n    SS_ADD_IV(PL_tmps_floor);\n    PL_tmps_floor = PL_tmps_ix;\n    SS_ADD_UV(SAVEt_TMPSFLOOR);\n    SS_ADD_END(2);\n}\n- S_concat_pat: static SV* /* <=== S_concat_pat */ \nS_concat_pat(pTHX_ RExC_state_t * const pRExC_state,\n                SV *pat, SV ** const patternp, int pat_count,\n                OP *oplist, bool *recompile_p, SV *delim)\n{\n    SV **svp;\n    int n = 0;\n    bool use_delim = FALSE;\n    bool alloced = FALSE;\n\n    /* if we know we have at least two args, create an empty string,\n     * then concatenate args to that. For no args, return an empty string */\n    if (!pat && pat_count != 1) {\n        pat = newSVpvs(\"\");\n        SAVEFREESV(pat);\n        alloced = TRUE;\n    }\n\n    for (svp = patternp; svp < patternp + pat_count; svp++) {\n        SV *sv;\n        SV *rx  = NULL;\n        STRLEN orig_patlen = 0;\n        bool code = 0;\n        SV *msv = use_delim ? delim : *svp;\n        if (!msv) msv = &PL_sv_undef;\n\n        /* if we've got a delimiter, we go round the loop twice for each\n         * svp slot (except the last), using the delimiter the second\n         * time round */\n        if (use_delim) {\n            svp--;\n            use_delim = FALSE;\n        }\n        else if (delim)\n            use_delim = TRUE;\n\n        if (SvTYPE(msv) == SVt_PVAV) {\n            /* we've encountered an interpolated array within\n             * the pattern, e.g. /...@a..../. Expand the list of elements,\n             * then recursively append elements.\n             * The code in this block is based on S_pushav() */\n\n            AV *const av = (AV*)msv;\n            const SSize_t maxarg = AvFILL(av) + 1;\n            SV **array;\n\n            if (oplist) {\n                assert(oplist->op_type == OP_PADAV\n                    || oplist->op_type == OP_RV2AV);\n                oplist = OpSIBLING(oplist);\n            }\n\n            if (SvRMAGICAL(av)) {\n                SSize_t i;\n\n                Newx(array, maxarg, SV*);\n                SAVEFREEPV(array);\n                for (i=0; i < maxarg; i++) {\n                    SV ** const svp = av_fetch(av, i, FALSE);\n                    array[i] = svp ? *svp : &PL_sv_undef;\n                }\n            }\n            else\n                array = AvARRAY(av);\n\n            pat = S_concat_pat(aTHX_ pRExC_state, pat,\n                                array, maxarg, NULL, recompile_p,\n                                /* $\" */\n                                GvSV((gv_fetchpvs(\"\\\"\", GV_ADDMULTI, SVt_PV))));\n\n            continue;\n        }\n\n\n        /* we make the assumption here that each op in the list of\n         * op_siblings maps to one SV pushed onto the stack,\n         * except for code blocks, with have both an OP_NULL and\n         * and OP_CONST.\n         * This allows us to match up the list of SVs against the\n         * list of OPs to find the next code block.\n         *\n         * Note that       PUSHMARK PADSV PADSV ..\n         * is optimised to\n         *                 PADRANGE PADSV  PADSV  ..\n         * so the alignment still works. */\n\n        if (oplist) {\n            if (oplist->op_type == OP_NULL\n                && (oplist->op_flags & OPf_SPECIAL))\n            {\n                assert(n < pRExC_state->code_blocks->count);\n                pRExC_state->code_blocks->cb[n].start = pat ? SvCUR(pat) : 0;\n                pRExC_state->code_blocks->cb[n].block = oplist;\n                pRExC_state->code_blocks->cb[n].src_regex = NULL;\n                n++;\n                code = 1;\n                oplist = OpSIBLING(oplist); /* skip CONST */\n                assert(oplist);\n            }\n            oplist = OpSIBLING(oplist);;\n        }\n\n\t/* apply magic and QR overloading to arg */\n\n        SvGETMAGIC(msv);\n        if (SvROK(msv) && SvAMAGIC(msv)) {\n            SV *sv = AMG_CALLunary(msv, regexp_amg);\n            if (sv) {\n                if (SvROK(sv))\n                    sv = SvRV(sv);\n                if (SvTYPE(sv) != SVt_REGEXP)\n                    Perl_croak(aTHX_ \"Overloaded qr did not return a REGEXP\");\n                msv = sv;\n            }\n        }\n\n        /* try concatenation overload ... */\n        if (pat && (SvAMAGIC(pat) || SvAMAGIC(msv)) &&\n                (sv = amagic_call(pat, msv, concat_amg, AMGf_assign)))\n        {\n            sv_setsv(pat, sv);\n            /* overloading involved: all bets are off over literal\n             * code. Pretend we haven't seen it */\n            if (n)\n                pRExC_state->code_blocks->count -= n;\n            n = 0;\n        }\n        else  {\n            /* ... or failing that, try \"\" overload */\n            while (SvAMAGIC(msv)\n                    && (sv = AMG_CALLunary(msv, string_amg))\n                    && sv != msv\n                    &&  !(   SvROK(msv)\n                          && SvROK(sv)\n                          && SvRV(msv) == SvRV(sv))\n            ) {\n                msv = sv;\n                SvGETMAGIC(msv);\n            }\n            if (SvROK(msv) && SvTYPE(SvRV(msv)) == SVt_REGEXP)\n                msv = SvRV(msv);\n\n            if (pat) {\n                /* this is a partially unrolled\n                 *     sv_catsv_nomg(pat, msv);\n                 * that allows us to adjust code block indices if\n                 * needed */\n                STRLEN dlen;\n                char *dst = SvPV_force_nomg(pat, dlen);\n                orig_patlen = dlen;\n                if (SvUTF8(msv) && !SvUTF8(pat)) {\n                    S_pat_upgrade_to_utf8(aTHX_ pRExC_state, &dst, &dlen, n);\n                    sv_setpvn(pat, dst, dlen);\n                    SvUTF8_on(pat);\n                }\n                sv_catsv_nomg(pat, msv);\n                rx = msv;\n            }\n            else {\n                /* We have only one SV to process, but we need to verify\n                 * it is properly null terminated or we will fail asserts\n                 * later. In theory we probably shouldn't get such SV's,\n                 * but if we do we should handle it gracefully. */\n                if ( SvTYPE(msv) != SVt_PV || (SvLEN(msv) > SvCUR(msv) && *(SvEND(msv)) == 0) || SvIsCOW_shared_hash(msv) ) {\n                    /* not a string, or a string with a trailing null */\n                    pat = msv;\n                } else {\n                    /* a string with no trailing null, we need to copy it\n                     * so it has a trailing null */\n                    pat = sv_2mortal(newSVsv(msv));\n                }\n            }\n\n            if (code)\n                pRExC_state->code_blocks->cb[n-1].end = SvCUR(pat)-1;\n        }\n\n        /* extract any code blocks within any embedded qr//'s */\n        if (rx && SvTYPE(rx) == SVt_REGEXP\n            && RX_ENGINE((REGEXP*)rx)->op_comp)\n        {\n\n            RXi_GET_DECL(ReANY((REGEXP *)rx), ri);\n            if (ri->code_blocks && ri->code_blocks->count) {\n                int i;\n                /* the presence of an embedded qr// with code means\n                 * we should always recompile: the text of the\n                 * qr// may not have changed, but it may be a\n                 * different closure than last time */\n                *recompile_p = 1;\n                if (pRExC_state->code_blocks) {\n                    int new_count = pRExC_state->code_blocks->count\n                            + ri->code_blocks->count;\n                    Renew(pRExC_state->code_blocks->cb,\n                            new_count, struct reg_code_block);\n                    pRExC_state->code_blocks->count = new_count;\n                }\n                else\n                    pRExC_state->code_blocks = S_alloc_code_blocks(aTHX_\n                                                    ri->code_blocks->count);\n\n                for (i=0; i < ri->code_blocks->count; i++) {\n                    struct reg_code_block *src, *dst;\n                    STRLEN offset =  orig_patlen\n                        + ReANY((REGEXP *)rx)->pre_prefix;\n                    assert(n < pRExC_state->code_blocks->count);\n                    src = &ri->code_blocks->cb[i];\n                    dst = &pRExC_state->code_blocks->cb[n];\n                    dst->start\t    = src->start + offset;\n                    dst->end\t    = src->end   + offset;\n                    dst->block\t    = src->block;\n                    dst->src_regex  = (REGEXP*) SvREFCNT_inc( (SV*)\n                                            src->src_regex\n                                                ? src->src_regex\n                                                : (REGEXP*)rx);\n                    n++;\n                }\n            }\n        }\n    }\n    /* avoid calling magic multiple times on a single element e.g. =~ $qr */\n    if (alloced)\n        SvSETMAGIC(pat);\n\n    return pat;\n}\n- CURLY: #define\tCURLY                 \t51\t/* 0x33 Match this simple thing {n,m} times. */ /* <=== regnodes.h:65:65:CURLY:0 */ \n- RExC_whilem_seen: #define RExC_whilem_seen\t(pRExC_state->whilem_seen) /* <=== regcomp.c:243:243:RExC_whilem_seen:0 */ \n- SCF_DO_SUBSTR: #define SCF_DO_SUBSTR\t\t0x0400 /* <=== regcomp.c:566:566:SCF_DO_SUBSTR:0 */ \n- SvRMAGICAL: #define SvRMAGICAL(sv)\t\t(SvFLAGS(sv) & SVs_RMG) /* <=== sv.h:974:974:SvRMAGICAL:1 */ \n- MEM_SIZE_MAX: #define MEM_SIZE_MAX ((MEM_SIZE)-1) /* <=== handy.h:2281:2281:MEM_SIZE_MAX:0 */ \n- ASSUME: #    define ASSUME(x) assert(x) /* <=== perl.h:3514:3514:ASSUME:1 */ \n- S_setup_longest: STATIC bool /* <=== S_setup_longest */ \nS_setup_longest(pTHX_ RExC_state_t *pRExC_state,\n                      struct reg_substr_datum  *rsd,\n                      struct scan_data_substrs *sub,\n                      STRLEN longest_length)\n{\n    /* This is the common code for setting up the floating and fixed length\n     * string data extracted from Perl_re_op_compile() below.  Returns a boolean\n     * as to whether succeeded or not */\n\n    I32 t;\n    SSize_t ml;\n    bool eol  = cBOOL(sub->flags & SF_BEFORE_EOL);\n    bool meol = cBOOL(sub->flags & SF_BEFORE_MEOL);\n\n    if (! (longest_length\n           || (eol /* Can't have SEOL and MULTI */\n               && (! meol || (RExC_flags & RXf_PMf_MULTILINE)))\n          )\n            /* See comments for join_exact for why REG_UNFOLDED_MULTI_SEEN */\n        || (RExC_seen & REG_UNFOLDED_MULTI_SEEN))\n    {\n        return FALSE;\n    }\n\n    /* copy the information about the longest from the reg_scan_data\n        over to the program. */\n    if (SvUTF8(sub->str)) {\n        rsd->substr      = NULL;\n        rsd->utf8_substr = sub->str;\n    } else {\n        rsd->substr      = sub->str;\n        rsd->utf8_substr = NULL;\n    }\n    /* end_shift is how many chars that must be matched that\n        follow this item. We calculate it ahead of time as once the\n        lookbehind offset is added in we lose the ability to correctly\n        calculate it.*/\n    ml = sub->minlenp ? *(sub->minlenp) : (SSize_t)longest_length;\n    rsd->end_shift = ml - sub->min_offset\n        - longest_length\n            /* XXX SvTAIL is always false here - did you mean FBMcf_TAIL\n             * intead? - DAPM\n            + (SvTAIL(sub->str) != 0)\n            */\n        + sub->lookbehind;\n\n    t = (eol/* Can't have SEOL and MULTI */\n         && (! meol || (RExC_flags & RXf_PMf_MULTILINE)));\n    fbm_compile(sub->str, t ? FBMcf_TAIL : 0);\n\n    return TRUE;\n}\n- Perl_newSVpvn_flags: SV * /* <=== Perl_newSVpvn_flags */ \nPerl_newSVpvn_flags(pTHX_ const char *const s, const STRLEN len, const U32 flags)\n{\n    SV *sv;\n\n    /* All the flags we don't support must be zero.\n       And we're new code so I'm going to assert this from the start.  */\n    assert(!(flags & ~(SVf_UTF8|SVs_TEMP)));\n    new_SV(sv);\n    sv_setpvn(sv,s,len);\n\n    /* This code used to do a sv_2mortal(), however we now unroll the call to\n     * sv_2mortal() and do what it does ourselves here.  Since we have asserted\n     * that flags can only have the SVf_UTF8 and/or SVs_TEMP flags set above we\n     * can use it to enable the sv flags directly (bypassing SvTEMP_on), which\n     * in turn means we dont need to mask out the SVf_UTF8 flag below, which\n     * means that we eliminate quite a few steps than it looks - Yves\n     * (explaining patch by gfx) */\n\n    SvFLAGS(sv) |= flags;\n\n    if(flags & SVs_TEMP){\n\tPUSH_EXTEND_MORTAL__SV_C(sv);\n    }\n\n    return sv;\n}\n- Perl_fbm_compile: void /* <=== Perl_fbm_compile */ \nPerl_fbm_compile(pTHX_ SV *sv, U32 flags)\n{\n    const U8 *s;\n    STRLEN i;\n    STRLEN len;\n    U32 frequency = 256;\n    MAGIC *mg;\n    PERL_DEB( STRLEN rarest = 0 );\n\n    PERL_ARGS_ASSERT_FBM_COMPILE;\n\n    if (isGV_with_GP(sv) || SvROK(sv))\n\treturn;\n\n    if (SvVALID(sv))\n\treturn;\n\n    if (flags & FBMcf_TAIL) {\n\tMAGIC * const mg = SvUTF8(sv) && SvMAGICAL(sv) ? mg_find(sv, PERL_MAGIC_utf8) : NULL;\n\tsv_catpvs(sv, \"\\n\");\t\t/* Taken into account in fbm_instr() */\n\tif (mg && mg->mg_len >= 0)\n\t    mg->mg_len++;\n    }\n    if (!SvPOK(sv) || SvNIOKp(sv))\n\ts = (U8*)SvPV_force_mutable(sv, len);\n    else s = (U8 *)SvPV_mutable(sv, len);\n    if (len == 0)\t\t/* TAIL might be on a zero-length string. */\n\treturn;\n    SvUPGRADE(sv, SVt_PVMG);\n    SvIOK_off(sv);\n    SvNOK_off(sv);\n\n    /* add PERL_MAGIC_bm magic holding the FBM lookup table */\n\n    assert(!mg_find(sv, PERL_MAGIC_bm));\n    mg = sv_magicext(sv, NULL, PERL_MAGIC_bm, &PL_vtbl_bm, NULL, 0);\n    assert(mg);\n\n    if (len > 2) {\n\t/* Shorter strings are special-cased in Perl_fbm_instr(), and don't use\n\t   the BM table.  */\n\tconst U8 mlen = (len>255) ? 255 : (U8)len;\n\tconst unsigned char *const sb = s + len - mlen; /* first char (maybe) */\n\tU8 *table;\n\n\tNewx(table, 256, U8);\n\tmemset((void*)table, mlen, 256);\n\tmg->mg_ptr = (char *)table;\n\tmg->mg_len = 256;\n\n\ts += len - 1; /* last char */\n\ti = 0;\n\twhile (s >= sb) {\n\t    if (table[*s] == mlen)\n\t\ttable[*s] = (U8)i;\n\t    s--, i++;\n\t}\n    }\n\n    s = (const unsigned char*)(SvPVX_const(sv));\t/* deeper magic */\n    for (i = 0; i < len; i++) {\n\tif (PL_freq[s[i]] < frequency) {\n\t    PERL_DEB( rarest = i );\n\t    frequency = PL_freq[s[i]];\n\t}\n    }\n    BmUSEFUL(sv) = 100;\t\t\t/* Initial value */\n    ((XPVNV*)SvANY(sv))->xnv_u.xnv_bm_tail = cBOOL(flags & FBMcf_TAIL);\n    DEBUG_r(PerlIO_printf(Perl_debug_log, \"rarest char %c at %\" UVuf \"\\n\",\n\t\t\t  s[rarest], (UV)rarest));\n}\n- RExC_size: #define RExC_size\t(pRExC_state->size) /* <=== regcomp.c:256:256:RExC_size:0 */ \n- dSAVE_ERRNO: #   define dSAVE_ERRNO    int saved_errno = errno /* <=== perl.h:1335:1335:dSAVE_ERRNO:0 */ \n- EXACTL: #define\tEXACTL                \t36\t/* 0x24 Like EXACT, but /l is in effect (used so locale-related warnings can be checked for). */ /* <=== regnodes.h:50:50:EXACTL:0 */ \n- NEED_UTF8: #define NEED_UTF8       0x40    /* In conjunction with RESTART_PARSE, need to /* <=== regcomp.c:325:325:NEED_UTF8:0 */ \n- regnext: #define regnext(a)\t\tPerl_regnext(aTHX_ a) /* <=== embed.h:639:639:regnext:1 */ \n- AvFILL: #define AvFILL(av)\t((SvRMAGICAL((const SV *) (av))) \\ /* <=== av.h:80:81:AvFILL:1 */ \n\t\t\t ? mg_size(MUTABLE_SV(av)) : AvFILLp(av))\n- Perl_sv_2bool_flags: bool /* <=== Perl_sv_2bool_flags */ \nPerl_sv_2bool_flags(pTHX_ SV *sv, I32 flags)\n{\n    PERL_ARGS_ASSERT_SV_2BOOL_FLAGS;\n\n    restart:\n    if(flags & SV_GMAGIC) SvGETMAGIC(sv);\n\n    if (!SvOK(sv))\n\treturn 0;\n    if (SvROK(sv)) {\n\tif (SvAMAGIC(sv)) {\n\t    SV * const tmpsv = AMG_CALLunary(sv, bool__amg);\n\t    if (tmpsv && (!SvROK(tmpsv) || (SvRV(tmpsv) != SvRV(sv)))) {\n                bool svb;\n                sv = tmpsv;\n                if(SvGMAGICAL(sv)) {\n                    flags = SV_GMAGIC;\n                    goto restart; /* call sv_2bool */\n                }\n                /* expanded SvTRUE_common(sv, (flags = 0, goto restart)) */\n                else if(!SvOK(sv)) {\n                    svb = 0;\n                }\n                else if(SvPOK(sv)) {\n                    svb = SvPVXtrue(sv);\n                }\n                else if((SvFLAGS(sv) & (SVf_IOK|SVf_NOK))) {\n                    svb = (SvIOK(sv) && SvIVX(sv) != 0)\n                        || (SvNOK(sv) && SvNVX(sv) != 0.0);\n                }\n                else {\n                    flags = 0;\n                    goto restart; /* call sv_2bool_nomg */\n                }\n                return cBOOL(svb);\n            }\n\t}\n\tassert(SvRV(sv));\n\treturn TRUE;\n    }\n    if (isREGEXP(sv))\n\treturn\n\t  RX_WRAPLEN(sv) > 1 || (RX_WRAPLEN(sv) && *RX_WRAPPED(sv) != '0');\n\n    if (SvNOK(sv) && !SvPOK(sv))\n        return SvNVX(sv) != 0.0;\n\n    return SvTRUE_common(sv, isGV_with_GP(sv) ? 1 : 0);\n}\n- RExC_in_lookbehind: #define RExC_in_lookbehind\t(pRExC_state->in_lookbehind) /* <=== regcomp.c:275:275:RExC_in_lookbehind:0 */ \n- SSC_MATCHES_EMPTY_STRING: #define SSC_MATCHES_EMPTY_STRING                ANYOF_INVERT /* <=== regcomp.h:497:497:SSC_MATCHES_EMPTY_STRING:0 */ \n- PREGf_SKIP: #define PREGf_SKIP\t\t0x00000001 /* <=== regcomp.h:130:130:PREGf_SKIP:0 */ \n- PerlMem_calloc: #define PerlMem_calloc(num, size)\tcalloc((num), (size)) /* <=== iperlsys.h:886:886:PerlMem_calloc:2 */ \n- RXf_INTUIT_TAIL: #define RXf_INTUIT_TAIL \t(1U<<(RXf_BASE_SHIFT+9)) /* <=== regexp.h:436:436:RXf_INTUIT_TAIL:0 */ \n- RExC_npar: #define RExC_npar\t(pRExC_state->npar) /* <=== regcomp.c:258:258:RExC_npar:0 */ \n- S_SvREFCNT_inc: PERL_STATIC_INLINE SV * /* <=== S_SvREFCNT_inc */ \nS_SvREFCNT_inc(SV *sv)\n{\n    if (LIKELY(sv != NULL))\n\tSvREFCNT(sv)++;\n    return sv;\n}\n- check_utf8: #define check_utf8 substrs->data[2].utf8_substr /* <=== regcomp.h:808:808:check_utf8:0 */ \n- RExC_utf8: #define RExC_utf8\t(pRExC_state->utf8) /* <=== regcomp.c:263:263:RExC_utf8:0 */ \n- RX_UTF8: #define RX_UTF8(rx_sv)                  SvUTF8(rx_sv) /* <=== regexp.h:592:592:RX_UTF8:1 */ \n- RExC_open_parens: #define RExC_open_parens\t(pRExC_state->open_parens) /* <=== regcomp.c:266:266:RExC_open_parens:0 */ \n- RXi_GET_DECL: #define RXi_GET_DECL(r,ri) regexp_internal *ri = RXi_GET(r) /* <=== regcomp.h:120:120:RXi_GET_DECL:2 */ \n- UNLIKELY: #define UNLIKELY(cond)                      EXPECT(cBOOL(cond),FALSE) /* <=== perl.h:3450:3450:UNLIKELY:1 */ \n- Perl_free_tmps: void /* <=== Perl_free_tmps */ \nPerl_free_tmps(pTHX)\n{\n    /* XXX should tmps_floor live in cxstack? */\n    const SSize_t myfloor = PL_tmps_floor;\n    while (PL_tmps_ix > myfloor) {      /* clean up after last statement */\n\tSV* const sv = PL_tmps_stack[PL_tmps_ix--];\n#ifdef PERL_POISON\n\tPoisonWith(PL_tmps_stack + PL_tmps_ix + 1, 1, SV *, 0xAB);\n#endif\n\tif (LIKELY(sv)) {\n\t    SvTEMP_off(sv);\n\t    SvREFCNT_dec_NN(sv);\t\t/* note, can modify tmps_ix!!! */\n\t}\n    }\n}\n- Perl_save_pushptr: void /* <=== Perl_save_pushptr */ \nPerl_save_pushptr(pTHX_ void *const ptr, const int type)\n{\n    dSS_ADD;\n    SS_ADD_PTR(ptr);\n    SS_ADD_UV(type);\n    SS_ADD_END(2);\n}\n- REG_GPOS_SEEN: #define REG_GPOS_SEEN                       0x00000004 /* <=== regcomp.h:722:722:REG_GPOS_SEEN:0 */ \n- PREGf_USE_RE_EVAL: #define PREGf_USE_RE_EVAL\t0x00000020 /* compiled with \"use re 'eval'\" */ /* <=== regcomp.h:135:135:PREGf_USE_RE_EVAL:0 */ \n- RExC_seen: #define RExC_seen\t(pRExC_state->seen) /* <=== regcomp.c:255:255:RExC_seen:0 */ \n- PMf_IS_QR: #define PMf_IS_QR\t(1U<<(PMf_BASE_SHIFT+16)) /* <=== op.h:370:370:PMf_IS_QR:0 */ \n- vcroak: #define vcroak(a,b)\t\tPerl_vcroak(aTHX_ a,b) /* <=== embed.h:913:913:vcroak:2 */ \n- RX_PRECOMP: #define RX_PRECOMP(rx_sv)              (RX_WRAPPED(rx_sv) \\ /* <=== regexp.h:513:514:RX_PRECOMP:1 */ \n                                            + ReANY(rx_sv)->pre_prefix)\n- RExC_paren_names: #define RExC_paren_names\t(pRExC_state->paren_names) /* <=== regcomp.c:269:269:RExC_paren_names:0 */ \n- RExC_copy_start_in_input: #define RExC_copy_start_in_input (pRExC_state->copy_start_in_input) /* <=== regcomp.c:232:232:RExC_copy_start_in_input:0 */ \n- PREGf_ANCH_MBOL: #define PREGf_ANCH_MBOL         0x00000400 /* <=== regcomp.h:142:142:PREGf_ANCH_MBOL:0 */ \n- Perl_safesyscalloc: Malloc_t /* <=== Perl_safesyscalloc */ \nPerl_safesyscalloc(MEM_SIZE count, MEM_SIZE size)\n{\n#ifdef ALWAYS_NEED_THX\n    dTHX;\n#endif\n    Malloc_t ptr;\n#if defined(USE_MDH) || defined(DEBUGGING)\n    MEM_SIZE total_size = 0;\n#endif\n\n    /* Even though calloc() for zero bytes is strange, be robust. */\n    if (size && (count <= MEM_SIZE_MAX / size)) {\n#if defined(USE_MDH) || defined(DEBUGGING)\n\ttotal_size = size * count;\n#endif\n    }\n    else\n\tcroak_memory_wrap();\n#ifdef USE_MDH\n    if (PERL_MEMORY_DEBUG_HEADER_SIZE <= MEM_SIZE_MAX - (MEM_SIZE)total_size)\n\ttotal_size += PERL_MEMORY_DEBUG_HEADER_SIZE;\n    else\n\tcroak_memory_wrap();\n#endif\n#ifdef DEBUGGING\n    if ((SSize_t)size < 0 || (SSize_t)count < 0)\n\tPerl_croak_nocontext(\"panic: calloc, size=%\" UVuf \", count=%\" UVuf,\n\t\t\t     (UV)size, (UV)count);\n#endif\n#ifdef PERL_DEBUG_READONLY_COW\n    if ((ptr = mmap(0, total_size ? total_size : 1, PROT_READ|PROT_WRITE,\n\t\t    MAP_ANON|MAP_PRIVATE, -1, 0)) == MAP_FAILED) {\n\tperror(\"mmap failed\");\n\tabort();\n    }\n#elif defined(PERL_TRACK_MEMPOOL)\n    /* Have to use malloc() because we've added some space for our tracking\n       header.  */\n    /* malloc(0) is non-portable. */\n    ptr = (Malloc_t)PerlMem_malloc(total_size ? total_size : 1);\n#else\n    /* Use calloc() because it might save a memset() if the memory is fresh\n       and clean from the OS.  */\n    if (count && size)\n\tptr = (Malloc_t)PerlMem_calloc(count, size);\n    else /* calloc(0) is non-portable. */\n\tptr = (Malloc_t)PerlMem_calloc(count ? count : 1, size ? size : 1);\n#endif\n    PERL_ALLOC_CHECK(ptr);\n    DEBUG_m(PerlIO_printf(Perl_debug_log, \"0x%\" UVxf \": (%05ld) calloc %zu x %zu = %zu bytes\\n\",PTR2UV(ptr),(long)PL_an++, count, size, total_size));\n    if (ptr != NULL) {\n#ifdef USE_MDH\n\t{\n\t    struct perl_memory_debug_header *const header\n\t\t= (struct perl_memory_debug_header *)ptr;\n\n#  ifndef PERL_DEBUG_READONLY_COW\n\t    memset((void*)ptr, 0, total_size);\n#  endif\n#  ifdef PERL_TRACK_MEMPOOL\n\t    header->interpreter = aTHX;\n\t    /* Link us into the list.  */\n\t    header->prev = &PL_memory_debug_header;\n\t    header->next = PL_memory_debug_header.next;\n\t    PL_memory_debug_header.next = header;\n\t    maybe_protect_rw(header->next);\n\t    header->next->prev = header;\n\t    maybe_protect_ro(header->next);\n#    ifdef PERL_DEBUG_READONLY_COW\n\t    header->readonly = 0;\n#    endif\n#  endif\n#  ifdef MDH_HAS_SIZE\n\t    header->size = total_size;\n#  endif\n\t    ptr = (Malloc_t)((char*)ptr+PERL_MEMORY_DEBUG_HEADER_SIZE);\n\t}\n#endif\n\treturn ptr;\n    }\n    else {\n#ifndef ALWAYS_NEED_THX\n\tdTHX;\n#endif\n\tif (PL_nomemok)\n\t    return NULL;\n\tcroak_no_mem();\n    }\n}\n- Perl_vcroak: void /* <=== Perl_vcroak */ \nPerl_vcroak(pTHX_ const char* pat, va_list *args)\n{\n    SV *ex = with_queued_errors(pat ? vmess(pat, args) : mess_sv(ERRSV, 0));\n    invoke_exception_hook(ex, FALSE);\n    die_unwind(ex);\n}\n- S_ReANY: PERL_STATIC_INLINE struct regexp * /* <=== S_ReANY */ \nS_ReANY(const REGEXP * const re)\n{\n    XPV* const p = (XPV*)SvANY(re);\n    assert(isREGEXP(re));\n    return SvTYPE(re) == SVt_PVLV ? p->xpv_len_u.xpvlenu_rx\n                                   : (struct regexp *)p;\n}\n- RXf_UNBOUNDED_QUANTIFIER_SEEN: #define RXf_UNBOUNDED_QUANTIFIER_SEEN   (1U<<(RXf_BASE_SHIFT+4)) /* <=== regexp.h:427:427:RXf_UNBOUNDED_QUANTIFIER_SEEN:0 */ \n- ERRSV: #define ERRSV GvSVn(PL_errgv) /* <=== perl.h:1340:1340:ERRSV:0 */ \n- StructCopy: #define StructCopy(s,d,t) (*((t*)(d)) = *((t*)(s))) /* <=== handy.h:2465:2465:StructCopy:3 */ \n- ENTER: #define ENTER push_scope() /* <=== scope.h:216:216:ENTER:0 */ \n- TRUE: #define TRUE (1) /* <=== handy.h:44:44:TRUE:0 */ \n- eval_sv: #define eval_sv(a,b)\t\tPerl_eval_sv(aTHX_ a,b) /* <=== embed.h:162:162:eval_sv:2 */ \n- S_croak_memory_wrap: static void /* <=== S_croak_memory_wrap */ \nS_croak_memory_wrap(void)\n{\n    Perl_croak_nocontext(\"%s\",PL_memory_wrap);\n}\n- Perl_gv_add_by_type: GV * /* <=== Perl_gv_add_by_type */ \nPerl_gv_add_by_type(pTHX_ GV *gv, svtype type)\n{\n    SV **where;\n\n    if (\n        !gv\n     || (\n            SvTYPE((const SV *)gv) != SVt_PVGV\n         && SvTYPE((const SV *)gv) != SVt_PVLV\n        )\n    ) {\n\tconst char *what;\n\tif (type == SVt_PVIO) {\n\t    /*\n\t     * if it walks like a dirhandle, then let's assume that\n\t     * this is a dirhandle.\n\t     */\n\t    what = OP_IS_DIRHOP(PL_op->op_type) ?\n\t\t\"dirhandle\" : \"filehandle\";\n\t} else if (type == SVt_PVHV) {\n\t    what = \"hash\";\n\t} else {\n\t    what = type == SVt_PVAV ? \"array\" : \"scalar\";\n\t}\n\t/* diag_listed_as: Bad symbol for filehandle */\n\tPerl_croak(aTHX_ \"Bad symbol for %s\", what);\n    }\n\n    if (type == SVt_PVHV) {\n\twhere = (SV **)&GvHV(gv);\n    } else if (type == SVt_PVAV) {\n\twhere = (SV **)&GvAV(gv);\n    } else if (type == SVt_PVIO) {\n\twhere = (SV **)&GvIOp(gv);\n    } else {\n\twhere = &GvSV(gv);\n    }\n\n    if (!*where)\n    {\n\t*where = newSV_type(type);\n\t    if (type == SVt_PVAV\n\t     && memEQs(GvNAME(gv), GvNAMELEN(gv), \"ISA\"))\n\t    sv_magic(*where, (SV *)gv, PERL_MAGIC_isa, NULL, 0);\n    }\n    return gv;\n}\n- LEAVE_with_name: #define LEAVE_with_name(name) LEAVE /* <=== scope.h:219:219:LEAVE_with_name:1 */ \n- RExC_recurse: #define RExC_recurse\t(pRExC_state->recurse) /* <=== regcomp.c:270:270:RExC_recurse:0 */ \n- LEAVE: #define LEAVE pop_scope() /* <=== scope.h:217:217:LEAVE:0 */ \n- IN_BYTES: #define IN_BYTES UNLIKELY(CopHINTS_get(PL_curcop) & HINT_BYTES) /* <=== utf8.h:632:632:IN_BYTES:0 */ \n- RXf_PMf_FLAGCOPYMASK: #define RXf_PMf_FLAGCOPYMASK   (RXf_PMf_COMPILETIME|RXf_PMf_SPLIT) /* <=== op_reg_common.h:105:105:RXf_PMf_FLAGCOPYMASK:0 */ \n- RXf_SPLIT: #define RXf_SPLIT   RXf_PMf_SPLIT /* <=== regexp.h:385:385:RXf_SPLIT:0 */ \n- Perl_mg_get: int /* <=== Perl_mg_get */ \nPerl_mg_get(pTHX_ SV *sv)\n{\n    const I32 mgs_ix = SSNEW(sizeof(MGS));\n    bool saved = FALSE;\n    bool have_new = 0;\n    bool taint_only = TRUE; /* the only get method seen is taint */\n    MAGIC *newmg, *head, *cur, *mg;\n\n    PERL_ARGS_ASSERT_MG_GET;\n\n    if (PL_localizing == 1 && sv == DEFSV) return 0;\n\n    /* We must call svt_get(sv, mg) for each valid entry in the linked\n       list of magic. svt_get() may delete the current entry, add new\n       magic to the head of the list, or upgrade the SV. AMS 20010810 */\n\n    newmg = cur = head = mg = SvMAGIC(sv);\n    while (mg) {\n\tconst MGVTBL * const vtbl = mg->mg_virtual;\n\tMAGIC * const nextmg = mg->mg_moremagic;\t/* it may delete itself */\n\n\tif (!(mg->mg_flags & MGf_GSKIP) && vtbl && vtbl->svt_get) {\n\n\t    /* taint's mg get is so dumb it doesn't need flag saving */\n\t    if (mg->mg_type != PERL_MAGIC_taint) {\n                taint_only = FALSE;\n                if (!saved) {\n                    save_magic(mgs_ix, sv);\n                    saved = TRUE;\n                }\n            }\n\n\t    vtbl->svt_get(aTHX_ sv, mg);\n\n\t    /* guard against magic having been deleted - eg FETCH calling\n\t     * untie */\n\t    if (!SvMAGIC(sv)) {\n\t\t/* recalculate flags */\n\t\t(SSPTR(mgs_ix, MGS *))->mgs_flags &= ~(SVs_GMG|SVs_SMG|SVs_RMG);\n\t\tbreak;\n\t    }\n\n\t    /* recalculate flags if this entry was deleted. */\n\t    if (mg->mg_flags & MGf_GSKIP)\n\t\t(SSPTR(mgs_ix, MGS *))->mgs_flags &=\n\t\t     ~(SVs_GMG|SVs_SMG|SVs_RMG);\n\t}\n\telse if (vtbl == &PL_vtbl_utf8) {\n\t    /* get-magic can reallocate the PV, unless there's only taint\n             * magic */\n            if (taint_only) {\n                MAGIC *mg2;\n                for (mg2 = nextmg; mg2; mg2 = mg2->mg_moremagic) {\n                    if (   mg2->mg_type != PERL_MAGIC_taint\n                        && !(mg2->mg_flags & MGf_GSKIP)\n                        && mg2->mg_virtual\n                        && mg2->mg_virtual->svt_get\n                    ) {\n                        taint_only = FALSE;\n                        break;\n                    }\n                }\n            }\n            if (!taint_only)\n                magic_setutf8(sv, mg);\n\t}\n\n\tmg = nextmg;\n\n\tif (have_new) {\n\t    /* Have we finished with the new entries we saw? Start again\n\t       where we left off (unless there are more new entries). */\n\t    if (mg == head) {\n\t\thave_new = 0;\n\t\tmg   = cur;\n\t\thead = newmg;\n\t    }\n\t}\n\n\t/* Were any new entries added? */\n\tif (!have_new && (newmg = SvMAGIC(sv)) != head) {\n\t    have_new = 1;\n\t    cur = mg;\n\t    mg  = newmg;\n\t    /* recalculate flags */\n\t    (SSPTR(mgs_ix, MGS *))->mgs_flags &= ~(SVs_GMG|SVs_SMG|SVs_RMG);\n\t}\n    }\n\n    if (saved)\n\trestore_magic(INT2PTR(void *, (IV)mgs_ix));\n\n    return 0;\n}\n- SvTAIL: #  define SvTAIL(_svtail)  (((XPVNV*)SvANY(_svtail))->xnv_u.xnv_bm_tail) /* <=== sv.h:1137:1137:SvTAIL:1 */ \n- U16_MAX: #define U16_MAX PERL_USHORT_MAX /* <=== handy.h:203:203:U16_MAX:0 */ \n- OPEN: #define\tOPEN                  \t56\t/* 0x38 Mark this point in input as start of #n. */ /* <=== regnodes.h:70:70:OPEN:0 */ \n- REG_UNBOUNDED_QUANTIFIER_SEEN: #define REG_UNBOUNDED_QUANTIFIER_SEEN       0x00001000 /* <=== regcomp.h:731:731:REG_UNBOUNDED_QUANTIFIER_SEEN:0 */ \n- amagic_call: #define amagic_call(a,b,c,d)\tPerl_amagic_call(aTHX_ a,b,c,d) /* <=== embed.h:50:50:amagic_call:4 */ \n- SCF_DO_STCLASS_AND: #define SCF_DO_STCLASS_AND\t0x0800 /* <=== regcomp.c:568:568:SCF_DO_STCLASS_AND:0 */ \n- sv_setpvn: #define sv_setpvn(a,b,c)\tPerl_sv_setpvn(aTHX_ a,b,c) /* <=== embed.h:832:832:sv_setpvn:3 */ \n- NEXTOPER: #define\tNEXTOPER(p)\t((p) + NODE_STEP_REGNODE) /* <=== regcomp.h:357:357:NEXTOPER:1 */ \n- STR_LEN: #define\tSTR_LEN(p)\t(((struct regnode_string *)p)->str_len) /* <=== regcomp.h:336:336:STR_LEN:1 */ \n- RESTART_PARSE: #define RESTART_PARSE   0x20    /* Need to redo the parse */ /* <=== regcomp.c:324:324:RESTART_PARSE:0 */ \n- Perl_save_destructor_x: void /* <=== Perl_save_destructor_x */ \nPerl_save_destructor_x(pTHX_ DESTRUCTORFUNC_t f, void* p)\n{\n    dSS_ADD;\n\n    SS_ADD_DXPTR(f);\n    SS_ADD_PTR(p);\n    SS_ADD_UV(SAVEt_DESTRUCTOR_X);\n    SS_ADD_END(3);\n}\n- REGNODE_SIMPLE: #define REGNODE_SIMPLE(node) (PL_simple_bitmask[(node) >> 3] & (1 << ((node) & 7))) /* <=== regnodes.h:777:777:REGNODE_SIMPLE:1 */ \n- SS_ADD_UV: #define SS_ADD_UV(u)    ((ssp++)->any_uv = (UV)(u)) /* <=== scope.h:138:138:SS_ADD_UV:1 */ \n- _CC_SPACE: #  define _CC_SPACE             10      /* \\s, [:space:] */ /* <=== handy.h:1175:1175:_CC_SPACE:0 */ \n- SCF_WHILEM_VISITED_POS: #define SCF_WHILEM_VISITED_POS\t0x2000 /* <=== regcomp.c:571:571:SCF_WHILEM_VISITED_POS:0 */ \n- sv_2mortal: #define sv_2mortal(a)\t\tPerl_sv_2mortal(aTHX_ a) /* <=== embed.h:724:724:sv_2mortal:1 */ \n- dSP: #define dSP\t\tSV **sp = PL_stack_sp /* <=== pp.h:81:81:dSP:0 */ \n- SAVEFREEPV: #define SAVEFREEPV(p)\tsave_freepv((char*)(p)) /* <=== scope.h:240:240:SAVEFREEPV:1 */ \n- FAIL: #define\tFAIL(msg) _FAIL(\t\t\t    \\ /* <=== regcomp.c:739:741:FAIL:1 */ \n    Perl_croak(aTHX_ \"%s in regex m/%\" UTF8f \"%s/\",\t    \\\n\t    msg, UTF8fARG(UTF, len, RExC_precomp), ellipses))\n- check_offset_max: #define check_offset_max substrs->data[2].max_offset /* <=== regcomp.h:810:810:check_offset_max:0 */ \n- RExC_maxlen: #define RExC_maxlen        (pRExC_state->maxlen) /* <=== regcomp.c:257:257:RExC_maxlen:0 */ \n- RExC_pm_flags: #define RExC_pm_flags\t(pRExC_state->pm_flags) /* <=== regcomp.c:230:230:RExC_pm_flags:0 */ \n- SvAMAGIC: #define SvAMAGIC(sv)\t\t(SvROK(sv) && SvOBJECT(SvRV(sv)) &&\t\\ /* <=== sv.h:978:979:SvAMAGIC:1 */ \n\t\t\t\t HvAMAGIC(SvSTASH(SvRV(sv))))\n- ALL_PARENS_COUNTED: #define ALL_PARENS_COUNTED (RExC_total_parens > 0) /* <=== regcomp.c:385:385:ALL_PARENS_COUNTED:0 */ \n- newSVpvn_flags: #define newSVpvn_flags(a,b,c)\tPerl_newSVpvn_flags(aTHX_ a,b,c) /* <=== embed.h:547:547:newSVpvn_flags:3 */ \n- PREGf_ANCH_GPOS: #define PREGf_ANCH_GPOS         0x00001000 /* <=== regcomp.h:144:144:PREGf_ANCH_GPOS:0 */ \n- RExC_parens_buf_size: #define RExC_parens_buf_size\t(pRExC_state->parens_buf_size) /* <=== regcomp.c:260:260:RExC_parens_buf_size:0 */ \n- ReANY: #define ReANY(re)\t\tS_ReANY((const REGEXP *)(re)) /* <=== regexp.h:632:632:ReANY:1 */ \n- Perl_amagic_call: SV* /* <=== Perl_amagic_call */ \nPerl_amagic_call(pTHX_ SV *left, SV *right, int method, int flags)\n{\n  dVAR;\n  MAGIC *mg;\n  CV *cv=NULL;\n  CV **cvp=NULL, **ocvp=NULL;\n  AMT *amtp=NULL, *oamtp=NULL;\n  int off = 0, off1, lr = 0, notfound = 0;\n  int postpr = 0, force_cpy = 0;\n  int assign = AMGf_assign & flags;\n  const int assignshift = assign ? 1 : 0;\n  int use_default_op = 0;\n  int force_scalar = 0;\n#ifdef DEBUGGING\n  int fl=0;\n#endif\n  HV* stash=NULL;\n\n  PERL_ARGS_ASSERT_AMAGIC_CALL;\n\n  if ( PL_curcop->cop_hints & HINT_NO_AMAGIC ) {\n      if (!amagic_is_enabled(method)) return NULL;\n  }\n\n  if (!(AMGf_noleft & flags) && SvAMAGIC(left)\n      && (stash = SvSTASH(SvRV(left))) && Gv_AMG(stash)\n      && (mg = mg_find((const SV *)stash, PERL_MAGIC_overload_table))\n      && (ocvp = cvp = (AMT_AMAGIC((AMT*)mg->mg_ptr)\n\t\t\t? (oamtp = amtp = (AMT*)mg->mg_ptr)->table\n\t\t\t: NULL))\n      && ((cv = cvp[off=method+assignshift])\n\t  || (assign && amtp->fallback > AMGfallNEVER && /* fallback to\n\t\t\t\t\t\t          * usual method */\n\t\t  (\n#ifdef DEBUGGING\n\t\t   fl = 1,\n#endif\n\t\t   cv = cvp[off=method])))) {\n    lr = -1;\t\t\t/* Call method for left argument */\n  } else {\n    if (cvp && amtp->fallback > AMGfallNEVER && flags & AMGf_unary) {\n      int logic;\n\n      /* look for substituted methods */\n      /* In all the covered cases we should be called with assign==0. */\n\t switch (method) {\n\t case inc_amg:\n\t   force_cpy = 1;\n\t   if ((cv = cvp[off=add_ass_amg])\n\t       || ((cv = cvp[off = add_amg]) && (force_cpy = 0, postpr = 1))) {\n\t     right = &PL_sv_yes; lr = -1; assign = 1;\n\t   }\n\t   break;\n\t case dec_amg:\n\t   force_cpy = 1;\n\t   if ((cv = cvp[off = subtr_ass_amg])\n\t       || ((cv = cvp[off = subtr_amg]) && (force_cpy = 0, postpr=1))) {\n\t     right = &PL_sv_yes; lr = -1; assign = 1;\n\t   }\n\t   break;\n\t case bool__amg:\n\t   (void)((cv = cvp[off=numer_amg]) || (cv = cvp[off=string_amg]));\n\t   break;\n\t case numer_amg:\n\t   (void)((cv = cvp[off=string_amg]) || (cv = cvp[off=bool__amg]));\n\t   break;\n\t case string_amg:\n\t   (void)((cv = cvp[off=numer_amg]) || (cv = cvp[off=bool__amg]));\n\t   break;\n         case not_amg:\n           (void)((cv = cvp[off=bool__amg])\n                  || (cv = cvp[off=numer_amg])\n                  || (cv = cvp[off=string_amg]));\n           if (cv)\n               postpr = 1;\n           break;\n\t case copy_amg:\n\t   {\n\t     /*\n\t\t  * SV* ref causes confusion with the interpreter variable of\n\t\t  * the same name\n\t\t  */\n\t     SV* const tmpRef=SvRV(left);\n\t     if (!SvROK(tmpRef) && SvTYPE(tmpRef) <= SVt_PVMG) {\n\t\t/*\n\t\t * Just to be extra cautious.  Maybe in some\n\t\t * additional cases sv_setsv is safe, too.\n\t\t */\n\t\tSV* const newref = newSVsv(tmpRef);\n\t\tSvOBJECT_on(newref);\n\t\t/* No need to do SvAMAGIC_on here, as SvAMAGIC macros\n\t\t   delegate to the stash. */\n\t\tSvSTASH_set(newref, MUTABLE_HV(SvREFCNT_inc(SvSTASH(tmpRef))));\n\t\treturn newref;\n\t     }\n\t   }\n\t   break;\n\t case abs_amg:\n\t   if ((cvp[off1=lt_amg] || cvp[off1=ncmp_amg])\n\t       && ((cv = cvp[off=neg_amg]) || (cv = cvp[off=subtr_amg]))) {\n\t     SV* const nullsv=&PL_sv_zero;\n\t     if (off1==lt_amg) {\n\t       SV* const lessp = amagic_call(left,nullsv,\n\t\t\t\t       lt_amg,AMGf_noright);\n\t       logic = SvTRUE_NN(lessp);\n\t     } else {\n\t       SV* const lessp = amagic_call(left,nullsv,\n\t\t\t\t       ncmp_amg,AMGf_noright);\n\t       logic = (SvNV(lessp) < 0);\n\t     }\n\t     if (logic) {\n\t       if (off==subtr_amg) {\n\t\t right = left;\n\t\t left = nullsv;\n\t\t lr = 1;\n\t       }\n\t     } else {\n\t       return left;\n\t     }\n\t   }\n\t   break;\n\t case neg_amg:\n\t   if ((cv = cvp[off=subtr_amg])) {\n\t     right = left;\n\t     left = &PL_sv_zero;\n\t     lr = 1;\n\t   }\n\t   break;\n\t case int_amg:\n\t case iter_amg:\t\t\t/* XXXX Eventually should do to_gv. */\n\t case ftest_amg:\t\t/* XXXX Eventually should do to_gv. */\n\t case regexp_amg:\n\t     /* FAIL safe */\n\t     return NULL;\t/* Delegate operation to standard mechanisms. */\n\n\t case to_sv_amg:\n\t case to_av_amg:\n\t case to_hv_amg:\n\t case to_gv_amg:\n\t case to_cv_amg:\n\t     /* FAIL safe */\n\t     return left;\t/* Delegate operation to standard mechanisms. */\n\n\t default:\n\t   goto not_found;\n\t }\n\t if (!cv) goto not_found;\n    } else if (!(AMGf_noright & flags) && SvAMAGIC(right)\n\t       && (stash = SvSTASH(SvRV(right))) && Gv_AMG(stash)\n\t       && (mg = mg_find((const SV *)stash, PERL_MAGIC_overload_table))\n\t       && (cvp = (AMT_AMAGIC((AMT*)mg->mg_ptr)\n\t\t\t  ? (amtp = (AMT*)mg->mg_ptr)->table\n\t\t\t  : NULL))\n\t       && (cv = cvp[off=method])) { /* Method for right\n\t\t\t\t\t     * argument found */\n      lr=1;\n    } else if (((cvp && amtp->fallback > AMGfallNEVER)\n                || (ocvp && oamtp->fallback > AMGfallNEVER))\n\t       && !(flags & AMGf_unary)) {\n\t\t\t\t/* We look for substitution for\n\t\t\t\t * comparison operations and\n\t\t\t\t * concatenation */\n      if (method==concat_amg || method==concat_ass_amg\n\t  || method==repeat_amg || method==repeat_ass_amg) {\n\treturn NULL;\t\t/* Delegate operation to string conversion */\n      }\n      off = -1;\n      switch (method) {\n\t case lt_amg:\n\t case le_amg:\n\t case gt_amg:\n\t case ge_amg:\n\t case eq_amg:\n\t case ne_amg:\n             off = ncmp_amg;\n             break;\n\t case slt_amg:\n\t case sle_amg:\n\t case sgt_amg:\n\t case sge_amg:\n\t case seq_amg:\n\t case sne_amg:\n             off = scmp_amg;\n             break;\n\t }\n      if (off != -1) {\n          if (ocvp && (oamtp->fallback > AMGfallNEVER)) {\n              cv = ocvp[off];\n              lr = -1;\n          }\n          if (!cv && (cvp && amtp->fallback > AMGfallNEVER)) {\n              cv = cvp[off];\n              lr = 1;\n          }\n      }\n      if (cv)\n          postpr = 1;\n      else\n          goto not_found;\n    } else {\n    not_found:\t\t\t/* No method found, either report or croak */\n      switch (method) {\n\t case to_sv_amg:\n\t case to_av_amg:\n\t case to_hv_amg:\n\t case to_gv_amg:\n\t case to_cv_amg:\n\t     /* FAIL safe */\n\t     return left;\t/* Delegate operation to standard mechanisms. */\n      }\n      if (ocvp && (cv=ocvp[nomethod_amg])) { /* Call report method */\n\tnotfound = 1; lr = -1;\n      } else if (cvp && (cv=cvp[nomethod_amg])) {\n\tnotfound = 1; lr = 1;\n      } else if ((use_default_op =\n                  (!ocvp || oamtp->fallback >= AMGfallYES)\n                  && (!cvp || amtp->fallback >= AMGfallYES))\n                 && !DEBUG_o_TEST) {\n\t/* Skip generating the \"no method found\" message.  */\n\treturn NULL;\n      } else {\n\tSV *msg;\n\tif (off==-1) off=method;\n\tmsg = sv_2mortal(Perl_newSVpvf(aTHX_\n\t\t      \"Operation \\\"%s\\\": no method found,%sargument %s%\" SVf \"%s%\" SVf,\n \t\t      AMG_id2name(method + assignshift),\n \t\t      (flags & AMGf_unary ? \" \" : \"\\n\\tleft \"),\n \t\t      SvAMAGIC(left)?\n \t\t        \"in overloaded package \":\n \t\t        \"has no overloaded magic\",\n \t\t      SvAMAGIC(left)?\n\t\t        SVfARG(sv_2mortal(newSVhek(HvNAME_HEK(SvSTASH(SvRV(left)))))):\n\t\t        SVfARG(&PL_sv_no),\n \t\t      SvAMAGIC(right)?\n \t\t        \",\\n\\tright argument in overloaded package \":\n \t\t        (flags & AMGf_unary\n \t\t\t ? \"\"\n \t\t\t : \",\\n\\tright argument has no overloaded magic\"),\n \t\t      SvAMAGIC(right)?\n\t\t        SVfARG(sv_2mortal(newSVhek(HvNAME_HEK(SvSTASH(SvRV(right)))))):\n\t\t        SVfARG(&PL_sv_no)));\n        if (use_default_op) {\n\t  DEBUG_o( Perl_deb(aTHX_ \"%\" SVf, SVfARG(msg)) );\n\t} else {\n\t  Perl_croak(aTHX_ \"%\" SVf, SVfARG(msg));\n\t}\n\treturn NULL;\n      }\n      force_cpy = force_cpy || assign;\n    }\n  }\n\n  switch (method) {\n    /* in these cases, we're calling '+' or '-' as a fallback for a ++ or --\n     * operation. we need this to return a value, so that it can be assigned\n     * later on, in the postpr block (case inc_amg/dec_amg), even if the\n     * increment or decrement was itself called in void context */\n    case inc_amg:\n      if (off == add_amg)\n        force_scalar = 1;\n      break;\n    case dec_amg:\n      if (off == subtr_amg)\n        force_scalar = 1;\n      break;\n    /* in these cases, we're calling an assignment variant of an operator\n     * (+= rather than +, for instance). regardless of whether it's a\n     * fallback or not, it always has to return a value, which will be\n     * assigned to the proper variable later */\n    case add_amg:\n    case subtr_amg:\n    case mult_amg:\n    case div_amg:\n    case modulo_amg:\n    case pow_amg:\n    case lshift_amg:\n    case rshift_amg:\n    case repeat_amg:\n    case concat_amg:\n    case band_amg:\n    case bor_amg:\n    case bxor_amg:\n    case sband_amg:\n    case sbor_amg:\n    case sbxor_amg:\n      if (assign)\n        force_scalar = 1;\n      break;\n    /* the copy constructor always needs to return a value */\n    case copy_amg:\n      force_scalar = 1;\n      break;\n    /* because of the way these are implemented (they don't perform the\n     * dereferencing themselves, they return a reference that perl then\n     * dereferences later), they always have to be in scalar context */\n    case to_sv_amg:\n    case to_av_amg:\n    case to_hv_amg:\n    case to_gv_amg:\n    case to_cv_amg:\n      force_scalar = 1;\n      break;\n    /* these don't have an op of their own; they're triggered by their parent\n     * op, so the context there isn't meaningful ('$a and foo()' in void\n     * context still needs to pass scalar context on to $a's bool overload) */\n    case bool__amg:\n    case numer_amg:\n    case string_amg:\n      force_scalar = 1;\n      break;\n  }\n\n#ifdef DEBUGGING\n  if (!notfound) {\n    DEBUG_o(Perl_deb(aTHX_\n\t\t     \"Overloaded operator \\\"%s\\\"%s%s%s:\\n\\tmethod%s found%s in package %\" SVf \"%s\\n\",\n\t\t     AMG_id2name(off),\n\t\t     method+assignshift==off? \"\" :\n\t\t     \" (initially \\\"\",\n\t\t     method+assignshift==off? \"\" :\n\t\t     AMG_id2name(method+assignshift),\n\t\t     method+assignshift==off? \"\" : \"\\\")\",\n\t\t     flags & AMGf_unary? \"\" :\n\t\t     lr==1 ? \" for right argument\": \" for left argument\",\n\t\t     flags & AMGf_unary? \" for argument\" : \"\",\n\t\t     stash ? SVfARG(sv_2mortal(newSVhek(HvNAME_HEK(stash)))) : SVfARG(newSVpvs_flags(\"null\", SVs_TEMP)),\n\t\t     fl? \",\\n\\tassignment variant used\": \"\") );\n  }\n#endif\n    /* Since we use shallow copy during assignment, we need\n     * to dublicate the contents, probably calling user-supplied\n     * version of copy operator\n     */\n    /* We need to copy in following cases:\n     * a) Assignment form was called.\n     * \t\tassignshift==1,  assign==T, method + 1 == off\n     * b) Increment or decrement, called directly.\n     * \t\tassignshift==0,  assign==0, method + 0 == off\n     * c) Increment or decrement, translated to assignment add/subtr.\n     * \t\tassignshift==0,  assign==T,\n     *\t\tforce_cpy == T\n     * d) Increment or decrement, translated to nomethod.\n     * \t\tassignshift==0,  assign==0,\n     *\t\tforce_cpy == T\n     * e) Assignment form translated to nomethod.\n     * \t\tassignshift==1,  assign==T, method + 1 != off\n     *\t\tforce_cpy == T\n     */\n    /*\toff is method, method+assignshift, or a result of opcode substitution.\n     *\tIn the latter case assignshift==0, so only notfound case is important.\n     */\n  if ( (lr == -1) && ( ( (method + assignshift == off)\n\t&& (assign || (method == inc_amg) || (method == dec_amg)))\n      || force_cpy) )\n  {\n      /* newSVsv does not behave as advertised, so we copy missing\n       * information by hand */\n      SV *tmpRef = SvRV(left);\n      SV *rv_copy;\n      if (SvREFCNT(tmpRef) > 1 && (rv_copy = AMG_CALLunary(left,copy_amg))) {\n\t  SvRV_set(left, rv_copy);\n\t  SvSETMAGIC(left);\n\t  SvREFCNT_dec_NN(tmpRef);  \n      }\n  }\n\n  {\n    dSP;\n    BINOP myop;\n    SV* res;\n    const bool oldcatch = CATCH_GET;\n    I32 oldmark, nret;\n                /* for multiconcat, we may call overload several times,\n                 * with the context of individual concats being scalar,\n                 * regardless of the overall context of the multiconcat op\n                 */\n    U8 gimme = (force_scalar || PL_op->op_type == OP_MULTICONCAT)\n                    ? G_SCALAR : GIMME_V;\n\n    CATCH_SET(TRUE);\n    Zero(&myop, 1, BINOP);\n    myop.op_last = (OP *) &myop;\n    myop.op_next = NULL;\n    myop.op_flags = OPf_STACKED;\n\n    switch (gimme) {\n        case G_VOID:\n            myop.op_flags |= OPf_WANT_VOID;\n            break;\n        case G_ARRAY:\n            if (flags & AMGf_want_list) {\n                myop.op_flags |= OPf_WANT_LIST;\n                break;\n            }\n            /* FALLTHROUGH */\n        default:\n            myop.op_flags |= OPf_WANT_SCALAR;\n            break;\n    }\n\n    PUSHSTACKi(PERLSI_OVERLOAD);\n    ENTER;\n    SAVEOP();\n    PL_op = (OP *) &myop;\n    if (PERLDB_SUB && PL_curstash != PL_debstash)\n\tPL_op->op_private |= OPpENTERSUB_DB;\n    Perl_pp_pushmark(aTHX);\n\n    EXTEND(SP, notfound + 5);\n    PUSHs(lr>0? right: left);\n    PUSHs(lr>0? left: right);\n    PUSHs( lr > 0 ? &PL_sv_yes : ( assign ? &PL_sv_undef : &PL_sv_no ));\n    if (notfound) {\n      PUSHs(newSVpvn_flags(AMG_id2name(method + assignshift),\n\t\t\t   AMG_id2namelen(method + assignshift), SVs_TEMP));\n    }\n    else if (flags & AMGf_numarg)\n      PUSHs(&PL_sv_undef);\n    if (flags & AMGf_numarg)\n      PUSHs(&PL_sv_yes);\n    PUSHs(MUTABLE_SV(cv));\n    PUTBACK;\n    oldmark = TOPMARK;\n\n    if ((PL_op = PL_ppaddr[OP_ENTERSUB](aTHX)))\n      CALLRUNOPS(aTHX);\n    LEAVE;\n    SPAGAIN;\n    nret = SP - (PL_stack_base + oldmark);\n\n    switch (gimme) {\n        case G_VOID:\n            /* returning NULL has another meaning, and we check the context\n             * at the call site too, so this can be differentiated from the\n             * scalar case */\n            res = &PL_sv_undef;\n            SP = PL_stack_base + oldmark;\n            break;\n        case G_ARRAY:\n            if (flags & AMGf_want_list) {\n                res = sv_2mortal((SV *)newAV());\n                av_extend((AV *)res, nret);\n                while (nret--)\n                    av_store((AV *)res, nret, POPs);\n                break;\n            }\n            /* FALLTHROUGH */\n        default:\n            res = POPs;\n            break;\n    }\n\n    PUTBACK;\n    POPSTACK;\n    CATCH_SET(oldcatch);\n\n    if (postpr) {\n      int ans;\n      switch (method) {\n      case le_amg:\n      case sle_amg:\n\tans=SvIV(res)<=0; break;\n      case lt_amg:\n      case slt_amg:\n\tans=SvIV(res)<0; break;\n      case ge_amg:\n      case sge_amg:\n\tans=SvIV(res)>=0; break;\n      case gt_amg:\n      case sgt_amg:\n\tans=SvIV(res)>0; break;\n      case eq_amg:\n      case seq_amg:\n\tans=SvIV(res)==0; break;\n      case ne_amg:\n      case sne_amg:\n\tans=SvIV(res)!=0; break;\n      case inc_amg:\n      case dec_amg:\n\tSvSetSV(left,res); return left;\n      case not_amg:\n\tans=!SvTRUE_NN(res); break;\n      default:\n        ans=0; break;\n      }\n      return boolSV(ans);\n    } else if (method==copy_amg) {\n      if (!SvROK(res)) {\n\tPerl_croak(aTHX_ \"Copy method did not return a reference\");\n      }\n      return SvREFCNT_inc(SvRV(res));\n    } else {\n      return res;\n    }\n  }\n}\n- sv_upgrade: #define sv_upgrade(a,b)\t\tPerl_sv_upgrade(aTHX_ a,b) /* <=== embed.h:851:851:sv_upgrade:2 */ \n- S_pat_upgrade_to_utf8: static void /* <=== S_pat_upgrade_to_utf8 */ \nS_pat_upgrade_to_utf8(pTHX_ RExC_state_t * const pRExC_state,\n\t\t    char **pat_p, STRLEN *plen_p, int num_code_blocks)\n{\n    U8 *const src = (U8*)*pat_p;\n    U8 *dst, *d;\n    int n=0;\n    STRLEN s = 0;\n    bool do_end = 0;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    DEBUG_PARSE_r(Perl_re_printf( aTHX_\n        \"UTF8 mismatch! Converting to utf8 for resizing and compile\\n\"));\n\n    /* 1 for each byte + 1 for each byte that expands to two, + trailing NUL */\n    Newx(dst, *plen_p + variant_under_utf8_count(src, src + *plen_p) + 1, U8);\n    d = dst;\n\n    while (s < *plen_p) {\n        append_utf8_from_native_byte(src[s], &d);\n\n        if (n < num_code_blocks) {\n            assert(pRExC_state->code_blocks);\n            if (!do_end && pRExC_state->code_blocks->cb[n].start == s) {\n                pRExC_state->code_blocks->cb[n].start = d - dst - 1;\n                assert(*(d - 1) == '(');\n                do_end = 1;\n            }\n            else if (do_end && pRExC_state->code_blocks->cb[n].end == s) {\n                pRExC_state->code_blocks->cb[n].end = d - dst - 1;\n                assert(*(d - 1) == ')');\n                do_end = 0;\n                n++;\n            }\n        }\n        s++;\n    }\n    *d = '\\0';\n    *plen_p = d - dst;\n    *pat_p = (char*) dst;\n    SAVEFREEPV(*pat_p);\n    RExC_orig_utf8 = RExC_utf8 = 1;\n}\n- Perl_safesysrealloc: Malloc_t /* <=== Perl_safesysrealloc */ \nPerl_safesysrealloc(Malloc_t where,MEM_SIZE size)\n{\n#ifdef ALWAYS_NEED_THX\n    dTHX;\n#endif\n    Malloc_t ptr;\n#ifdef PERL_DEBUG_READONLY_COW\n    const MEM_SIZE oldsize = where\n\t? ((struct perl_memory_debug_header *)((char *)where - PERL_MEMORY_DEBUG_HEADER_SIZE))->size\n\t: 0;\n#endif\n\n    if (!size) {\n\tsafesysfree(where);\n\tptr = NULL;\n    }\n    else if (!where) {\n\tptr = safesysmalloc(size);\n    }\n    else {\n        dSAVE_ERRNO;\n#ifdef USE_MDH\n\twhere = (Malloc_t)((char*)where-PERL_MEMORY_DEBUG_HEADER_SIZE);\n        if (size + PERL_MEMORY_DEBUG_HEADER_SIZE < size)\n            goto out_of_memory;\n\tsize += PERL_MEMORY_DEBUG_HEADER_SIZE;\n\t{\n\t    struct perl_memory_debug_header *const header\n\t\t= (struct perl_memory_debug_header *)where;\n\n# ifdef PERL_TRACK_MEMPOOL\n\t    if (header->interpreter != aTHX) {\n\t\tPerl_croak_nocontext(\"panic: realloc from wrong pool, %p!=%p\",\n\t\t\t\t     header->interpreter, aTHX);\n\t    }\n\t    assert(header->next->prev == header);\n\t    assert(header->prev->next == header);\n#  ifdef PERL_POISON\n\t    if (header->size > size) {\n\t\tconst MEM_SIZE freed_up = header->size - size;\n\t\tchar *start_of_freed = ((char *)where) + size;\n\t\tPoisonFree(start_of_freed, freed_up, char);\n\t    }\n#  endif\n# endif\n# ifdef MDH_HAS_SIZE\n\t    header->size = size;\n# endif\n\t}\n#endif\n#ifdef DEBUGGING\n\tif ((SSize_t)size < 0)\n\t    Perl_croak_nocontext(\"panic: realloc, size=%\" UVuf, (UV)size);\n#endif\n#ifdef PERL_DEBUG_READONLY_COW\n\tif ((ptr = mmap(0, size, PROT_READ|PROT_WRITE,\n\t\t\tMAP_ANON|MAP_PRIVATE, -1, 0)) == MAP_FAILED) {\n\t    perror(\"mmap failed\");\n\t    abort();\n\t}\n\tCopy(where,ptr,oldsize < size ? oldsize : size,char);\n\tif (munmap(where, oldsize)) {\n\t    perror(\"munmap failed\");\n\t    abort();\n\t}\n#else\n\tptr = (Malloc_t)PerlMem_realloc(where,size);\n#endif\n\tPERL_ALLOC_CHECK(ptr);\n\n    /* MUST do this fixup first, before doing ANYTHING else, as anything else\n       might allocate memory/free/move memory, and until we do the fixup, it\n       may well be chasing (and writing to) free memory.  */\n\tif (ptr != NULL) {\n#ifdef PERL_TRACK_MEMPOOL\n\t    struct perl_memory_debug_header *const header\n\t\t= (struct perl_memory_debug_header *)ptr;\n\n#  ifdef PERL_POISON\n\t    if (header->size < size) {\n\t\tconst MEM_SIZE fresh = size - header->size;\n\t\tchar *start_of_fresh = ((char *)ptr) + size;\n\t\tPoisonNew(start_of_fresh, fresh, char);\n\t    }\n#  endif\n\n\t    maybe_protect_rw(header->next);\n\t    header->next->prev = header;\n\t    maybe_protect_ro(header->next);\n\t    maybe_protect_rw(header->prev);\n\t    header->prev->next = header;\n\t    maybe_protect_ro(header->prev);\n#endif\n\t    ptr = (Malloc_t)((char*)ptr+PERL_MEMORY_DEBUG_HEADER_SIZE);\n\n\t    /* realloc() can modify errno() even on success, but since someone\n\t       writing perl code doesn't have any control over when perl calls\n\t       realloc() we need to hide that.\n\t    */\n\t    RESTORE_ERRNO;\n\t}\n\n    /* In particular, must do that fixup above before logging anything via\n     *printf(), as it can reallocate memory, which can cause SEGVs.  */\n\n\tDEBUG_m(PerlIO_printf(Perl_debug_log, \"0x%\" UVxf \": (%05ld) rfree\\n\",PTR2UV(where),(long)PL_an++));\n\tDEBUG_m(PerlIO_printf(Perl_debug_log, \"0x%\" UVxf \": (%05ld) realloc %ld bytes\\n\",PTR2UV(ptr),(long)PL_an++,(long)size));\n\n\tif (ptr == NULL) {\n#ifdef USE_MDH\n          out_of_memory:\n#endif\n            {\n#ifndef ALWAYS_NEED_THX\n                dTHX;\n#endif\n                if (PL_nomemok)\n                    ptr = NULL;\n                else\n                    croak_no_mem();\n            }\n\t}\n    }\n    return ptr;\n}\n- RExC_end_op: #define RExC_end_op\t(pRExC_state->end_op) /* <=== regcomp.c:268:268:RExC_end_op:0 */ \n- RESTORE_ERRNO: #   define RESTORE_ERRNO  (errno = saved_errno) /* <=== perl.h:1337:1337:RESTORE_ERRNO:0 */ \n- Perl_new_stackinfo: PERL_SI * /* <=== Perl_new_stackinfo */ \nPerl_new_stackinfo(pTHX_ I32 stitems, I32 cxitems)\n{\n    PERL_SI *si;\n    Newx(si, 1, PERL_SI);\n    si->si_stack = newAV();\n    AvREAL_off(si->si_stack);\n    av_extend(si->si_stack, stitems > 0 ? stitems-1 : 0);\n    AvALLOC(si->si_stack)[0] = &PL_sv_undef;\n    AvFILLp(si->si_stack) = 0;\n    si->si_prev = 0;\n    si->si_next = 0;\n    si->si_cxmax = cxitems - 1;\n    si->si_cxix = -1;\n    si->si_type = PERLSI_UNDEF;\n    Newx(si->si_cxstack, cxitems, PERL_CONTEXT);\n    /* Without any kind of initialising CX_PUSHSUBST()\n     * in pp_subst() will read uninitialised heap. */\n    PoisonNew(si->si_cxstack, cxitems, PERL_CONTEXT);\n    return si;\n}\n- PerlMem_malloc: #define PerlMem_malloc(size)\t\tmalloc((size)) /* <=== iperlsys.h:883:883:PerlMem_malloc:1 */ \n- RXf_USE_INTUIT: #define RXf_USE_INTUIT\t\t(RXf_USE_INTUIT_NOML|RXf_USE_INTUIT_ML) /* <=== regexp.h:437:437:RXf_USE_INTUIT:0 */ \n- REG_MAGIC: #define REG_MAGIC 0234 /* <=== regcomp.h:386:386:REG_MAGIC:0 */ \n- SvUTF8_on: #define SvUTF8_on(sv)\t\t(SvFLAGS(sv) |= (SVf_UTF8)) /* <=== sv.h:928:928:SvUTF8_on:1 */ \n- RExC_rxi: #define RExC_rxi\t(pRExC_state->rxi) /* <=== regcomp.c:238:238:RExC_rxi:0 */ \n- TOO_NAUGHTY: #define TOO_NAUGHTY (10) /* <=== regcomp.c:297:297:TOO_NAUGHTY:0 */ \n- IN_PARENS_PASS: #define IN_PARENS_PASS (RExC_total_parens < 0) /* <=== regcomp.c:390:390:IN_PARENS_PASS:0 */ \n- SvSETMAGIC: #define SvSETMAGIC(x) STMT_START { if (UNLIKELY(SvSMAGICAL(x))) mg_set(x); } STMT_END /* <=== sv.h:2059:2059:SvSETMAGIC:1 */ \n- SvRV: #    define SvRV(sv) ((sv)->sv_u.svu_rv) /* <=== sv.h:1244:1244:SvRV:1 */ \n- POSIXD: #define\tPOSIXD                \t25\t/* 0x19 Some [[:class:]] under /d; the FLAGS field gives which one */ /* <=== regnodes.h:39:39:POSIXD:0 */ \n- PREGf_GPOS_SEEN: #define PREGf_GPOS_SEEN         0x00000100 /* <=== regcomp.h:139:139:PREGf_GPOS_SEEN:0 */ \n- Perl_leave_scope: void /* <=== Perl_leave_scope */ \nPerl_leave_scope(pTHX_ I32 base)\n{\n    /* Localise the effects of the TAINT_NOT inside the loop.  */\n    bool was = TAINT_get;\n\n    if (UNLIKELY(base < -1))\n\tPerl_croak(aTHX_ \"panic: corrupt saved stack index %ld\", (long) base);\n    DEBUG_l(Perl_deb(aTHX_ \"savestack: releasing items %ld -> %ld\\n\",\n\t\t\t(long)PL_savestack_ix, (long)base));\n    while (PL_savestack_ix > base) {\n\tUV uv;\n\tU8 type;\n        ANY *ap; /* arg pointer */\n        ANY a0, a1, a2; /* up to 3 args */\n\n\tTAINT_NOT;\n\n        {\n            U8  argcount;\n            I32 ix = PL_savestack_ix - 1;\n\n            ap = &PL_savestack[ix];\n            uv = ap->any_uv;\n            type = (U8)uv & SAVE_MASK;\n            argcount = arg_counts[type];\n            PL_savestack_ix = ix - argcount;\n            ap -= argcount;\n        }\n\n\tswitch (type) {\n\tcase SAVEt_ITEM:\t\t\t/* normal string */\n            a0 = ap[0]; a1 = ap[1];\n\t    sv_replace(a0.any_sv, a1.any_sv);\n            if (UNLIKELY(SvSMAGICAL(a0.any_sv))) {\n                PL_localizing = 2;\n                mg_set(a0.any_sv);\n                PL_localizing = 0;\n            }\n\t    break;\n\n\t    /* This would be a mathom, but Perl_save_svref() calls a static\n\t       function, S_save_scalar_at(), so has to stay in this file.  */\n\tcase SAVEt_SVREF:\t\t\t/* scalar reference */\n            a0 = ap[0]; a1 = ap[1];\n\t    a2.any_svp = a0.any_svp;\n\t    a0.any_sv = NULL; /* what to refcnt_dec */\n\t    goto restore_sv;\n\n\tcase SAVEt_SV:\t\t\t\t/* scalar reference */\n            a0 = ap[0]; a1 = ap[1];\n\t    a2.any_svp = &GvSV(a0.any_gv);\n\trestore_sv:\n        {\n            /* do *a2.any_svp = a1 and free a0 */\n\t    SV * const sv = *a2.any_svp;\n\t    *a2.any_svp = a1.any_sv;\n\t    SvREFCNT_dec(sv);\n            if (UNLIKELY(SvSMAGICAL(a1.any_sv))) {\n                /* mg_set could die, skipping the freeing of a0 and\n                 * a1; Ensure that they're always freed in that case */\n                dSS_ADD;\n                SS_ADD_PTR(a1.any_sv);\n                SS_ADD_UV(SAVEt_FREESV);\n                SS_ADD_PTR(a0.any_sv);\n                SS_ADD_UV(SAVEt_FREESV);\n                SS_ADD_END(4);\n                PL_localizing = 2;\n                mg_set(a1.any_sv);\n                PL_localizing = 0;\n                break;\n            }\n\t    SvREFCNT_dec_NN(a1.any_sv);\n\t    SvREFCNT_dec(a0.any_sv);\n\t    break;\n        }\n\n\tcase SAVEt_GENERIC_PVREF:\t\t/* generic pv */\n            a0 = ap[0]; a1 = ap[1];\n\t    if (*a1.any_pvp != a0.any_pv) {\n\t\tSafefree(*a1.any_pvp);\n\t\t*a1.any_pvp = a0.any_pv;\n\t    }\n\t    break;\n\n\tcase SAVEt_SHARED_PVREF:\t\t/* shared pv */\n            a0 = ap[0]; a1 = ap[1];\n\t    if (*a0.any_pvp != a1.any_pv) {\n#ifdef NETWARE\n\t\tPerlMem_free(*a0.any_pvp);\n#else\n\t\tPerlMemShared_free(*a0.any_pvp);\n#endif\n\t\t*a0.any_pvp = a1.any_pv;\n\t    }\n\t    break;\n\n\tcase SAVEt_GVSV:\t\t\t/* scalar slot in GV */\n            a0 = ap[0]; a1 = ap[1];\n\t    a0.any_svp = &GvSV(a0.any_gv);\n\t    goto restore_svp;\n\n\tcase SAVEt_GENERIC_SVREF:\t\t/* generic sv */\n            a0 = ap[0]; a1 = ap[1];\n\trestore_svp:\n        {\n            /* do *a0.any_svp = a1 */\n\t    SV * const sv = *a0.any_svp;\n\t    *a0.any_svp = a1.any_sv;\n\t    SvREFCNT_dec(sv);\n\t    SvREFCNT_dec(a1.any_sv);\n\t    break;\n        }\n\n\tcase SAVEt_GVSLOT:\t\t\t/* any slot in GV */\n        {\n            HV * hv;\n            a0 = ap[0]; a1 = ap[1]; a2 = ap[2];\n            hv = GvSTASH(a0.any_gv);\n\t    if (hv && HvENAME(hv) && (\n\t\t    (a2.any_sv && SvTYPE(a2.any_sv) == SVt_PVCV)\n\t\t || (*a1.any_svp && SvTYPE(*a1.any_svp) == SVt_PVCV)\n\t       ))\n\t    {\n\t\tif ((char *)a1.any_svp < (char *)GvGP(a0.any_gv)\n\t\t || (char *)a1.any_svp > (char *)GvGP(a0.any_gv) + sizeof(struct gp)\n\t\t || GvREFCNT(a0.any_gv) > 2) /* \"> 2\" to ignore savestack's ref */\n\t\t    PL_sub_generation++;\n\t\telse mro_method_changed_in(hv);\n\t    }\n            a0.any_svp = a1.any_svp;\n            a1.any_sv  = a2.any_sv;\n\t    goto restore_svp;\n        }\n\n\tcase SAVEt_AV:\t\t\t\t/* array reference */\n            a0 = ap[0]; a1 = ap[1];\n\t    SvREFCNT_dec(GvAV(a0.any_gv));\n\t    GvAV(a0.any_gv) = a1.any_av;\n          avhv_common:\n            if (UNLIKELY(SvSMAGICAL(a1.any_sv))) {\n                /* mg_set might die, so make sure a0 isn't leaked */\n                dSS_ADD;\n                SS_ADD_PTR(a0.any_sv);\n                SS_ADD_UV(SAVEt_FREESV);\n                SS_ADD_END(2);\n                PL_localizing = 2;\n                mg_set(a1.any_sv);\n                PL_localizing = 0;\n                break;\n            }\n\t    SvREFCNT_dec_NN(a0.any_sv);\n\t    break;\n\n\tcase SAVEt_HV:\t\t\t\t/* hash reference */\n            a0 = ap[0]; a1 = ap[1];\n\t    SvREFCNT_dec(GvHV(a0.any_gv));\n\t    GvHV(a0.any_gv) = a1.any_hv;\n            goto avhv_common;\n\n\tcase SAVEt_INT_SMALL:\n            a0 = ap[0];\n\t    *(int*)a0.any_ptr = (int)(uv >> SAVE_TIGHT_SHIFT);\n\t    break;\n\n\tcase SAVEt_INT:\t\t\t\t/* int reference */\n            a0 = ap[0]; a1 = ap[1];\n\t    *(int*)a1.any_ptr = (int)a0.any_i32;\n\t    break;\n\n\tcase SAVEt_STRLEN:\t\t\t/* STRLEN/size_t ref */\n            a0 = ap[0]; a1 = ap[1];\n\t    *(STRLEN*)a1.any_ptr = (STRLEN)a0.any_iv;\n\t    break;\n\n\tcase SAVEt_TMPSFLOOR:\t\t\t/* restore PL_tmps_floor */\n            a0 = ap[0];\n\t    PL_tmps_floor = (SSize_t)a0.any_iv;\n\t    break;\n\n\tcase SAVEt_BOOL:\t\t\t/* bool reference */\n            a0 = ap[0];\n\t    *(bool*)a0.any_ptr = cBOOL(uv >> 8);\n#ifdef NO_TAINT_SUPPORT\n            PERL_UNUSED_VAR(was);\n#else\n\t    if (UNLIKELY(a0.any_ptr == &(TAINT_get))) {\n\t\t/* If we don't update <was>, to reflect what was saved on the\n\t\t * stack for PL_tainted, then we will overwrite this attempt to\n\t\t * restore it when we exit this routine.  Note that this won't\n\t\t * work if this value was saved in a wider-than necessary type,\n\t\t * such as I32 */\n\t\twas = *(bool*)a0.any_ptr;\n\t    }\n#endif\n\t    break;\n\n\tcase SAVEt_I32_SMALL:\n            a0 = ap[0];\n\t    *(I32*)a0.any_ptr = (I32)(uv >> SAVE_TIGHT_SHIFT);\n\t    break;\n\n\tcase SAVEt_I32:\t\t\t\t/* I32 reference */\n            a0 = ap[0]; a1 = ap[1];\n#ifdef PERL_DEBUG_READONLY_OPS\n            if (*(I32*)a1.any_ptr != a0.any_i32)\n#endif\n                *(I32*)a1.any_ptr = a0.any_i32;\n\t    break;\n\n\tcase SAVEt_SPTR:\t\t\t/* SV* reference */\n\tcase SAVEt_VPTR:\t\t\t/* random* reference */\n\tcase SAVEt_PPTR:\t\t\t/* char* reference */\n\tcase SAVEt_HPTR:\t\t\t/* HV* reference */\n\tcase SAVEt_APTR:\t\t\t/* AV* reference */\n            a0 = ap[0]; a1 = ap[1];\n\t    *a1.any_svp= a0.any_sv;\n\t    break;\n\n\tcase SAVEt_GP:\t\t\t\t/* scalar reference */\n        {\n            HV *hv;\n\t    bool had_method;\n\n            a0 = ap[0]; a1 = ap[1];\n            /* possibly taking a method out of circulation */\t\n\t    had_method = !!GvCVu(a0.any_gv);\n\t    gp_free(a0.any_gv);\n\t    GvGP_set(a0.any_gv, (GP*)a1.any_ptr);\n\t    if ((hv=GvSTASH(a0.any_gv)) && HvENAME_get(hv)) {\n\t        if (memEQs(GvNAME(a0.any_gv), GvNAMELEN(a0.any_gv), \"ISA\"))\n\t            mro_isa_changed_in(hv);\n                else if (had_method || GvCVu(a0.any_gv))\n                    /* putting a method back into circulation (\"local\")*/\t\n                    gv_method_changed(a0.any_gv);\n\t    }\n\t    SvREFCNT_dec_NN(a0.any_gv);\n\t    break;\n        }\n\n\tcase SAVEt_FREESV:\n            a0 = ap[0];\n\t    SvREFCNT_dec(a0.any_sv);\n\t    break;\n\n\tcase SAVEt_FREEPADNAME:\n            a0 = ap[0];\n\t    PadnameREFCNT_dec((PADNAME *)a0.any_ptr);\n\t    break;\n\n\tcase SAVEt_FREECOPHH:\n            a0 = ap[0];\n\t    cophh_free((COPHH *)a0.any_ptr);\n\t    break;\n\n\tcase SAVEt_MORTALIZESV:\n            a0 = ap[0];\n\t    sv_2mortal(a0.any_sv);\n\t    break;\n\n\tcase SAVEt_FREEOP:\n            a0 = ap[0];\n\t    ASSERT_CURPAD_LEGAL(\"SAVEt_FREEOP\");\n\t    op_free(a0.any_op);\n\t    break;\n\n\tcase SAVEt_FREEPV:\n            a0 = ap[0];\n\t    Safefree(a0.any_ptr);\n\t    break;\n\n        case SAVEt_CLEARPADRANGE:\n        {\n            I32 i;\n\t    SV **svp;\n            i = (I32)((uv >> SAVE_TIGHT_SHIFT) & OPpPADRANGE_COUNTMASK);\n            svp = &PL_curpad[uv >>\n                    (OPpPADRANGE_COUNTSHIFT + SAVE_TIGHT_SHIFT)] + i - 1;\n            goto clearsv;\n\tcase SAVEt_CLEARSV:\n\t    svp = &PL_curpad[uv >> SAVE_TIGHT_SHIFT];\n            i = 1;\n          clearsv:\n            for (; i; i--, svp--) {\n                SV *sv = *svp;\n\n                DEBUG_Xv(PerlIO_printf(Perl_debug_log,\n             \"Pad 0x%\" UVxf \"[0x%\" UVxf \"] clearsv: %ld sv=0x%\" UVxf \"<%\" IVdf \"> %s\\n\",\n                    PTR2UV(PL_comppad), PTR2UV(PL_curpad),\n                    (long)(svp-PL_curpad), PTR2UV(sv), (IV)SvREFCNT(sv),\n                    (SvREFCNT(sv) <= 1 && !SvOBJECT(sv)) ? \"clear\" : \"abandon\"\n                ));\n\n                /* Can clear pad variable in place? */\n                if (SvREFCNT(sv) == 1 && !SvOBJECT(sv)) {\n\n                    /* these flags are the union of all the relevant flags\n                     * in the individual conditions within */\n                    if (UNLIKELY(SvFLAGS(sv) & (\n                            SVf_READONLY|SVf_PROTECT /*for SvREADONLY_off*/\n                          | (SVs_GMG|SVs_SMG|SVs_RMG) /* SvMAGICAL() */\n                          | SVf_OOK\n                          | SVf_THINKFIRST)))\n                    {\n                        /* if a my variable that was made readonly is\n                         * going out of scope, we want to remove the\n                         * readonlyness so that it can go out of scope\n                         * quietly\n                         */\n                        if (SvREADONLY(sv))\n                            SvREADONLY_off(sv);\n\n                        if (SvOOK(sv)) { /* OOK or HvAUX */\n                            if (SvTYPE(sv) == SVt_PVHV)\n                                Perl_hv_kill_backrefs(aTHX_ MUTABLE_HV(sv));\n                            else\n                                sv_backoff(sv);\n                        }\n\n                        if (SvMAGICAL(sv)) {\n                            /* note that backrefs (either in HvAUX or magic)\n                             * must be removed before other magic */\n                            sv_unmagic(sv, PERL_MAGIC_backref);\n                            if (SvTYPE(sv) != SVt_PVCV)\n                                mg_free(sv);\n                        }\n                        if (SvTHINKFIRST(sv))\n                            sv_force_normal_flags(sv, SV_IMMEDIATE_UNREF\n                                                     |SV_COW_DROP_PV);\n\n                    }\n                    switch (SvTYPE(sv)) {\n                    case SVt_NULL:\n                        break;\n                    case SVt_PVAV:\n                        av_clear(MUTABLE_AV(sv));\n                        break;\n                    case SVt_PVHV:\n                        hv_clear(MUTABLE_HV(sv));\n                        break;\n                    case SVt_PVCV:\n                    {\n                        HEK *hek = CvGvNAME_HEK(sv);\n                        assert(hek);\n                        (void)share_hek_hek(hek);\n                        cv_undef((CV *)sv);\n                        CvNAME_HEK_set(sv, hek);\n                        CvLEXICAL_on(sv);\n                        break;\n                    }\n                    default:\n                        /* This looks odd, but these two macros are for use in\n                           expressions and finish with a trailing comma, so\n                           adding a ; after them would be wrong. */\n                        assert_not_ROK(sv)\n                        assert_not_glob(sv)\n                        SvFLAGS(sv) &=~ (SVf_OK|SVf_IVisUV|SVf_UTF8);\n                        break;\n                    }\n                    SvPADTMP_off(sv);\n                    SvPADSTALE_on(sv); /* mark as no longer live */\n                }\n                else {\t/* Someone has a claim on this, so abandon it. */\n                    switch (SvTYPE(sv)) {\t/* Console ourselves with a new value */\n                    case SVt_PVAV:\t*svp = MUTABLE_SV(newAV());\tbreak;\n                    case SVt_PVHV:\t*svp = MUTABLE_SV(newHV());\tbreak;\n                    case SVt_PVCV:\n                    {\n                        HEK * const hek = CvGvNAME_HEK(sv);\n\n                        /* Create a stub */\n                        *svp = newSV_type(SVt_PVCV);\n\n                        /* Share name */\n                        CvNAME_HEK_set(*svp,\n                                       share_hek_hek(hek));\n                        CvLEXICAL_on(*svp);\n                        break;\n                    }\n                    default:\t*svp = newSV(0);\t\tbreak;\n                    }\n                    SvREFCNT_dec_NN(sv); /* Cast current value to the winds. */\n                    /* preserve pad nature, but also mark as not live\n                     * for any closure capturing */\n                    SvFLAGS(*svp) |= SVs_PADSTALE;\n                }\n            }\n\t    break;\n        }\n\n\tcase SAVEt_DELETE:\n            a0 = ap[0]; a1 = ap[1]; a2 = ap[2];\n            /* hv_delete could die, so free the key and SvREFCNT_dec the\n             * hv by pushing new save actions\n             */\n            /* ap[0] is the key */\n            ap[1].any_uv = SAVEt_FREEPV; /* was len */\n            /* ap[2] is the hv */\n            ap[3].any_uv = SAVEt_FREESV; /* was SAVEt_DELETE */\n            PL_savestack_ix += 4;\n\t    (void)hv_delete(a2.any_hv, a0.any_pv, a1.any_i32, G_DISCARD);\n\t    break;\n\n\tcase SAVEt_ADELETE:\n            a0 = ap[0]; a1 = ap[1];\n            /* av_delete could die, so SvREFCNT_dec the av by pushing a\n             * new save action\n             */\n            ap[0].any_av = a1.any_av;\n            ap[1].any_uv = SAVEt_FREESV;\n            PL_savestack_ix += 2;\n\t    (void)av_delete(a1.any_av, a0.any_iv, G_DISCARD);\n\t    break;\n\n\tcase SAVEt_DESTRUCTOR_X:\n            a0 = ap[0]; a1 = ap[1];\n\t    (*a0.any_dxptr)(aTHX_ a1.any_ptr);\n\t    break;\n\n\tcase SAVEt_REGCONTEXT:\n\t    /* regexp must have croaked */\n\tcase SAVEt_ALLOC:\n\t    PL_savestack_ix -= uv >> SAVE_TIGHT_SHIFT;\n\t    break;\n\n\tcase SAVEt_STACK_POS:\t\t/* Position on Perl stack */\n            a0 = ap[0];\n\t    PL_stack_sp = PL_stack_base + a0.any_i32;\n\t    break;\n\n\tcase SAVEt_AELEM:\t\t/* array element */\n        {\n            SV **svp;\n            a0 = ap[0]; a1 = ap[1]; a2 = ap[2];\n\t    svp = av_fetch(a0.any_av, a1.any_iv, 1);\n\t    if (UNLIKELY(!AvREAL(a0.any_av) && AvREIFY(a0.any_av))) /* undo reify guard */\n\t\tSvREFCNT_dec(a2.any_sv);\n\t    if (LIKELY(svp)) {\n\t\tSV * const sv = *svp;\n\t\tif (LIKELY(sv && sv != &PL_sv_undef)) {\n\t\t    if (UNLIKELY(SvTIED_mg((const SV *)a0.any_av, PERL_MAGIC_tied)))\n\t\t\tSvREFCNT_inc_void_NN(sv);\n                    a1.any_sv  = a2.any_sv;\n                    a2.any_svp = svp;\n\t\t    goto restore_sv;\n\t\t}\n\t    }\n\t    SvREFCNT_dec(a0.any_av);\n\t    SvREFCNT_dec(a2.any_sv);\n\t    break;\n        }\n\n\tcase SAVEt_HELEM:\t\t/* hash element */\n        {\n\t    HE *he;\n\n            a0 = ap[0]; a1 = ap[1]; a2 = ap[2];\n\t    he = hv_fetch_ent(a0.any_hv, a1.any_sv, 1, 0);\n\t    SvREFCNT_dec(a1.any_sv);\n\t    if (LIKELY(he)) {\n\t\tconst SV * const oval = HeVAL(he);\n\t\tif (LIKELY(oval && oval != &PL_sv_undef)) {\n                    SV **svp = &HeVAL(he);\n\t\t    if (UNLIKELY(SvTIED_mg((const SV *)a0.any_hv, PERL_MAGIC_tied)))\n\t\t\tSvREFCNT_inc_void(*svp);\n                    a1.any_sv  = a2.any_sv;\n                    a2.any_svp = svp;\n\t\t    goto restore_sv;\n\t\t}\n\t    }\n\t    SvREFCNT_dec(a0.any_hv);\n\t    SvREFCNT_dec(a2.any_sv);\n\t    break;\n        }\n\n\tcase SAVEt_OP:\n            a0 = ap[0];\n\t    PL_op = (OP*)a0.any_ptr;\n\t    break;\n\n\tcase SAVEt_HINTS:\n            a0 = ap[0]; a1 = ap[1];\n\t    if ((PL_hints & HINT_LOCALIZE_HH)) {\n\t      while (GvHV(PL_hintgv)) {\n\t\tHV *hv = GvHV(PL_hintgv);\n\t\tGvHV(PL_hintgv) = NULL;\n\t\tSvREFCNT_dec(MUTABLE_SV(hv));\n\t      }\n\t    }\n\t    cophh_free(CopHINTHASH_get(&PL_compiling));\n\t    CopHINTHASH_set(&PL_compiling, (COPHH*)a1.any_ptr);\n\t    *(I32*)&PL_hints = a0.any_i32;\n\t    if (PL_hints & HINT_LOCALIZE_HH) {\n\t\tSvREFCNT_dec(MUTABLE_SV(GvHV(PL_hintgv)));\n\t\tGvHV(PL_hintgv) = MUTABLE_HV(SSPOPPTR);\n\t    }\n\t    if (!GvHV(PL_hintgv)) {\n\t\t/* Need to add a new one manually, else rv2hv can\n\t\t   add one via GvHVn and it won't have the magic set.  */\n\t\tHV *const hv = newHV();\n\t\thv_magic(hv, NULL, PERL_MAGIC_hints);\n\t\tGvHV(PL_hintgv) = hv;\n\t    }\n\t    assert(GvHV(PL_hintgv));\n\t    break;\n\n\tcase SAVEt_COMPPAD:\n            a0 = ap[0];\n\t    PL_comppad = (PAD*)a0.any_ptr;\n\t    if (LIKELY(PL_comppad))\n\t\tPL_curpad = AvARRAY(PL_comppad);\n\t    else\n\t\tPL_curpad = NULL;\n\t    break;\n\n\tcase SAVEt_PADSV_AND_MORTALIZE:\n\t    {\n\t\tSV **svp;\n\n                a0 = ap[0]; a1 = ap[1]; a2 = ap[2];\n\t\tassert (a1.any_ptr);\n\t\tsvp = AvARRAY((PAD*)a1.any_ptr) + (PADOFFSET)a2.any_uv;\n                /* This mortalizing used to be done by CX_POOPLOOP() via\n                   itersave.  But as we have all the information here, we\n                   can do it here, save even having to have itersave in\n                   the struct.\n                   */\n\t\tsv_2mortal(*svp);\n\t\t*svp = a0.any_sv;\n\t    }\n\t    break;\n\n\tcase SAVEt_SAVESWITCHSTACK:\n\t    {\n\t\tdSP;\n\n                a0 = ap[0]; a1 = ap[1];\n\t\tSWITCHSTACK(a1.any_av, a0.any_av);\n\t\tPL_curstackinfo->si_stack = a0.any_av;\n\t    }\n\t    break;\n\n\tcase SAVEt_SET_SVFLAGS:\n            a0 = ap[0]; a1 = ap[1]; a2 = ap[2];\n            SvFLAGS(a0.any_sv) &= ~(a1.any_u32);\n            SvFLAGS(a0.any_sv) |= a2.any_u32;\n\t    break;\n\n\t    /* These are only saved in mathoms.c */\n\tcase SAVEt_NSTAB:\n            a0 = ap[0];\n\t    (void)sv_clear(a0.any_sv);\n\t    break;\n\n\tcase SAVEt_LONG:\t\t\t/* long reference */\n            a0 = ap[0]; a1 = ap[1];\n\t    *(long*)a1.any_ptr = a0.any_long;\n\t    break;\n\n\tcase SAVEt_IV:\t\t\t\t/* IV reference */\n            a0 = ap[0]; a1 = ap[1];\n\t    *(IV*)a1.any_ptr = a0.any_iv;\n\t    break;\n\n\tcase SAVEt_I16:\t\t\t\t/* I16 reference */\n            a0 = ap[0];\n\t    *(I16*)a0.any_ptr = (I16)(uv >> 8);\n\t    break;\n\n\tcase SAVEt_I8:\t\t\t\t/* I8 reference */\n            a0 = ap[0];\n\t    *(I8*)a0.any_ptr = (I8)(uv >> 8);\n\t    break;\n\n\tcase SAVEt_DESTRUCTOR:\n            a0 = ap[0]; a1 = ap[1];\n\t    (*a0.any_dptr)(a1.any_ptr);\n\t    break;\n\n\tcase SAVEt_COMPILE_WARNINGS:\n            a0 = ap[0];\n\t    if (!specialWARN(PL_compiling.cop_warnings))\n\t\tPerlMemShared_free(PL_compiling.cop_warnings);\n\t    PL_compiling.cop_warnings = (STRLEN*)a0.any_ptr;\n\t    break;\n\n\tcase SAVEt_PARSER:\n            a0 = ap[0];\n\t    parser_free((yy_parser *)a0.any_ptr);\n\t    break;\n\n\tcase SAVEt_READONLY_OFF:\n            a0 = ap[0];\n\t    SvREADONLY_off(a0.any_sv);\n\t    break;\n\n\tdefault:\n\t    Perl_croak(aTHX_ \"panic: leave_scope inconsistency %u\",\n                    (U8)uv & SAVE_MASK);\n\t}\n    }\n\n    TAINT_set(was);\n}\n- RXp_COMPFLAGS: #define RXp_COMPFLAGS(rx)               ((rx)->compflags) /* <=== regexp.h:510:510:RXp_COMPFLAGS:1 */ \n- ARG: #define ARG(p) ARG_VALUE(ARG_LOC(p)) /* <=== regcomp.h:297:297:ARG:1 */ \n- SvTRUE_NN: #define SvTRUE_NN(sv)      (SvGETMAGIC(sv), SvTRUE_nomg_NN(sv)) /* <=== sv.h:1763:1763:SvTRUE_NN:1 */ \n- bool: # define bool char /* <=== handy.h:96:96:bool:0 */ \n- Zero: #define Zero(d,n,t)\t(MEM_WRAP_CHECK_(n,t) perl_assert_ptr(d), (void)memzero((char*)(d), (n) * sizeof(t))) /* <=== handy.h:2447:2447:Zero:3 */ \n- RX_ENGINE: #define RX_ENGINE(rx_sv)                (RXp_ENGINE(ReANY(rx_sv))) /* <=== regexp.h:531:531:RX_ENGINE:1 */ \n- EXACT: #define\tEXACT                 \t35\t/* 0x23 Match this string (preceded by length). */ /* <=== regnodes.h:49:49:EXACT:0 */ \n- CHECK_RESTUDY_GOTO_butfirst: #define CHECK_RESTUDY_GOTO_butfirst(dOsomething)            \\ /* <=== regcomp.c:6519:6528:CHECK_RESTUDY_GOTO_butfirst:1 */ \n    STMT_START {                                            \\\n        if (                                                \\\n              (data.flags & SCF_TRIE_RESTUDY)               \\\n              && ! restudied++                              \\\n        ) {                                                 \\\n            dOsomething;                                    \\\n            goto reStudy;                                   \\\n        }                                                   \\\n    } STMT_END\n- SS_ADD_END: #define SS_ADD_END(need) \\ /* <=== scope.h:126:132:SS_ADD_END:1 */ \n    assert((need) <= SS_MAXPUSH);                               \\\n    ix += (need);                                               \\\n    PL_savestack_ix = ix;                                       \\\n    assert(ix <= PL_savestack_max + SS_MAXPUSH);                \\\n    if (UNLIKELY(ix > PL_savestack_max)) savestack_grow();      \\\n    assert(PL_savestack_ix <= PL_savestack_max);\n- OpSIBLING: #  define OpSIBLING(o)\t\t(0 + (o)->op_moresib ? (o)->op_sibparent : NULL) /* <=== op.h:1026:1026:OpSIBLING:1 */ \n- SVt_FIRST: #  define SVt_FIRST SVt_NULL\t/* the type of SV that new_SV() in sv.c returns */ /* <=== sv.h:181:181:SVt_FIRST:0 */ \n- Perl_safesysfree: Free_t /* <=== Perl_safesysfree */ \nPerl_safesysfree(Malloc_t where)\n{\n#ifdef ALWAYS_NEED_THX\n    dTHX;\n#endif\n    DEBUG_m( PerlIO_printf(Perl_debug_log, \"0x%\" UVxf \": (%05ld) free\\n\",PTR2UV(where),(long)PL_an++));\n    if (where) {\n#ifdef USE_MDH\n\tMalloc_t where_intrn = (Malloc_t)((char*)where-PERL_MEMORY_DEBUG_HEADER_SIZE);\n\t{\n\t    struct perl_memory_debug_header *const header\n\t\t= (struct perl_memory_debug_header *)where_intrn;\n\n# ifdef MDH_HAS_SIZE\n\t    const MEM_SIZE size = header->size;\n# endif\n# ifdef PERL_TRACK_MEMPOOL\n\t    if (header->interpreter != aTHX) {\n\t\tPerl_croak_nocontext(\"panic: free from wrong pool, %p!=%p\",\n\t\t\t\t     header->interpreter, aTHX);\n\t    }\n\t    if (!header->prev) {\n\t\tPerl_croak_nocontext(\"panic: duplicate free\");\n\t    }\n\t    if (!(header->next))\n\t\tPerl_croak_nocontext(\"panic: bad free, header->next==NULL\");\n\t    if (header->next->prev != header || header->prev->next != header) {\n\t\tPerl_croak_nocontext(\"panic: bad free, ->next->prev=%p, \"\n\t\t\t\t     \"header=%p, ->prev->next=%p\",\n\t\t\t\t     header->next->prev, header,\n\t\t\t\t     header->prev->next);\n\t    }\n\t    /* Unlink us from the chain.  */\n\t    maybe_protect_rw(header->next);\n\t    header->next->prev = header->prev;\n\t    maybe_protect_ro(header->next);\n\t    maybe_protect_rw(header->prev);\n\t    header->prev->next = header->next;\n\t    maybe_protect_ro(header->prev);\n\t    maybe_protect_rw(header);\n#  ifdef PERL_POISON\n\t    PoisonNew(where_intrn, size, char);\n#  endif\n\t    /* Trigger the duplicate free warning.  */\n\t    header->next = NULL;\n# endif\n# ifdef PERL_DEBUG_READONLY_COW\n\t    if (munmap(where_intrn, size)) {\n\t\tperror(\"munmap failed\");\n\t\tabort();\n\t    }\t\n# endif\n\t}\n#else\n\tMalloc_t where_intrn = where;\n#endif /* USE_MDH */\n#ifndef PERL_DEBUG_READONLY_COW\n\tPerlMem_free(where_intrn);\n#endif\n    }\n}\n- RExC_latest_warn_offset: #define RExC_latest_warn_offset (pRExC_state->latest_warn_offset ) /* <=== regcomp.c:242:242:RExC_latest_warn_offset:0 */ \n- RXf_START_ONLY: #define RXf_START_ONLY\t\t(1U<<(RXf_BASE_SHIFT+14)) /* Pattern is /^/ */ /* <=== regexp.h:451:451:RXf_START_ONLY:0 */ \n- SvLEN: #  define SvLEN(sv) ((XPV*) SvANY(sv))->xpv_len /* <=== sv.h:1173:1173:SvLEN:1 */ \n- Perl_croak_popstack: void /* <=== Perl_croak_popstack */ \nPerl_croak_popstack(void)\n{\n    dTHX;\n    PerlIO_printf(Perl_error_log, \"panic: POPSTACK\\n\");\n    my_exit(1);\n}\n- BOL: #define\tBOL                   \t2\t/* 0x02 type alias */ /* <=== regnodes.h:15:15:BOL:0 */ \n- assert: #  define assert(what)\tPerl_assert(what) /* <=== perl.h:4171:4171:assert:1 */ \n- REG_UNFOLDED_MULTI_SEEN: #define REG_UNFOLDED_MULTI_SEEN             0x00000400 /* <=== regcomp.h:729:729:REG_UNFOLDED_MULTI_SEEN:0 */ \n- av_fetch: #define av_fetch(a,b,c)\t\tPerl_av_fetch(aTHX_ a,b,c) /* <=== embed.h:59:59:av_fetch:3 */ \n- Perl_sv_catsv_flags: void /* <=== Perl_sv_catsv_flags */ \nPerl_sv_catsv_flags(pTHX_ SV *const dsv, SV *const ssv, const I32 flags)\n{\n    PERL_ARGS_ASSERT_SV_CATSV_FLAGS;\n\n    if (ssv) {\n\tSTRLEN slen;\n\tconst char *spv = SvPV_flags_const(ssv, slen, flags);\n        if (flags & SV_GMAGIC)\n                SvGETMAGIC(dsv);\n        sv_catpvn_flags(dsv, spv, slen,\n\t\t\t    DO_UTF8(ssv) ? SV_CATUTF8 : SV_CATBYTES);\n        if (flags & SV_SMAGIC)\n                SvSETMAGIC(dsv);\n    }\n}\n- AvARRAY: #define AvARRAY(av)\t((av)->sv_u.svu_array) /* <=== av.h:62:62:AvARRAY:1 */ \n- SvREFCNT_dec_NN: #define SvREFCNT_dec_NN(sv)\tS_SvREFCNT_dec_NN(aTHX_ MUTABLE_SV(sv)) /* <=== sv.h:349:349:SvREFCNT_dec_NN:1 */ \n- Perl_newSVpvn: SV * /* <=== Perl_newSVpvn */ \nPerl_newSVpvn(pTHX_ const char *const buffer, const STRLEN len)\n{\n    SV *sv;\n    new_SV(sv);\n    sv_setpvn(sv,buffer,len);\n    return sv;\n}\n- safesysfree: #define safesysfree\t\tPerl_safesysfree /* <=== embed.h:649:649:safesysfree:0 */ \n- END: #define\tEND                   \t0\t/* 0000 End of program. */ /* <=== regnodes.h:12:12:END:0 */ \n- OPf_SPECIAL: #define OPf_SPECIAL\t128\t/* Do something weird for this op: */ /* <=== op.h:108:108:OPf_SPECIAL:0 */ \n- PerlMem_realloc: #define PerlMem_realloc(buf, size)\trealloc((buf), (size)) /* <=== iperlsys.h:884:884:PerlMem_realloc:2 */ \n- SvGETMAGIC: #define SvGETMAGIC(x) ((void)(UNLIKELY(SvGMAGICAL(x)) && mg_get(x))) /* <=== sv.h:2058:2058:SvGETMAGIC:1 */ \n- REG_TOP_LEVEL_BRANCHES_SEEN: #define REG_TOP_LEVEL_BRANCHES_SEEN         0x00000040 /* <=== regcomp.h:725:725:REG_TOP_LEVEL_BRANCHES_SEEN:0 */ \n- SvPV_force_nomg: #define SvPV_force_nomg(sv, lp) SvPV_force_flags(sv, lp, 0) /* <=== sv.h:1690:1690:SvPV_force_nomg:2 */ \n- RExC_sawback: #define RExC_sawback\t(pRExC_state->sawback) /* <=== regcomp.c:254:254:RExC_sawback:0 */ \n- REG_RECURSE_SEEN: #define REG_RECURSE_SEEN                    0x00000020 /* <=== regcomp.h:724:724:REG_RECURSE_SEEN:0 */ \n- cSVOPo_sv: #define cSVOPo_sv\t\tcSVOPx_sv(o) /* <=== op.h:527:527:cSVOPo_sv:0 */ \n- PREGf_ANCH: #define PREGf_ANCH              \\ /* <=== regcomp.h:147:148:PREGf_ANCH:0 */ \n    ( PREGf_ANCH_SBOL | PREGf_ANCH_GPOS | PREGf_ANCH_MBOL )\n- MUST_RESTART: #define MUST_RESTART(flags) ((flags) & (RESTART_PARSE)) /* <=== regcomp.c:407:407:MUST_RESTART:1 */ \n- Perl_sv_len_utf8: STRLEN /* <=== Perl_sv_len_utf8 */ \nPerl_sv_len_utf8(pTHX_ SV *const sv)\n{\n    if (!sv)\n\treturn 0;\n\n    SvGETMAGIC(sv);\n    return sv_len_utf8_nomg(sv);\n}\n- SvTYPE: #define SvTYPE(sv)\t((svtype)((sv)->sv_flags & SVTYPEMASK)) /* <=== sv.h:352:352:SvTYPE:1 */ \n- S_compile_runtime_code: static bool /* <=== S_compile_runtime_code */ \nS_compile_runtime_code(pTHX_ RExC_state_t * const pRExC_state,\n    char *pat, STRLEN plen)\n{\n    SV *qr;\n\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    if (pRExC_state->runtime_code_qr) {\n\t/* this is the second time we've been called; this should\n\t * only happen if the main pattern got upgraded to utf8\n\t * during compilation; re-use the qr we compiled first time\n\t * round (which should be utf8 too)\n\t */\n\tqr = pRExC_state->runtime_code_qr;\n\tpRExC_state->runtime_code_qr = NULL;\n\tassert(RExC_utf8 && SvUTF8(qr));\n    }\n    else {\n\tint n = 0;\n\tSTRLEN s;\n\tchar *p, *newpat;\n\tint newlen = plen + 7; /* allow for \"qr''xx\\0\" extra chars */\n\tSV *sv, *qr_ref;\n\tdSP;\n\n\t/* determine how many extra chars we need for ' and \\ escaping */\n\tfor (s = 0; s < plen; s++) {\n\t    if (pat[s] == '\\'' || pat[s] == '\\\\')\n\t\tnewlen++;\n\t}\n\n\tNewx(newpat, newlen, char);\n\tp = newpat;\n\t*p++ = 'q'; *p++ = 'r'; *p++ = '\\'';\n\n\tfor (s = 0; s < plen; s++) {\n\t    if (   pRExC_state->code_blocks\n\t        && n < pRExC_state->code_blocks->count\n\t\t&& s == pRExC_state->code_blocks->cb[n].start)\n\t    {\n\t\t/* blank out literal code block so that they aren't\n                 * recompiled: eg change from/to:\n                 *     /(?{xyz})/\n                 *     /(?=====)/\n                 * and\n                 *     /(??{xyz})/\n                 *     /(?======)/\n                 * and\n                 *     /(?(?{xyz}))/\n                 *     /(?(?=====))/\n                */\n\t\tassert(pat[s]   == '(');\n\t\tassert(pat[s+1] == '?');\n                *p++ = '(';\n                *p++ = '?';\n                s += 2;\n\t\twhile (s < pRExC_state->code_blocks->cb[n].end) {\n\t\t    *p++ = '=';\n\t\t    s++;\n\t\t}\n                *p++ = ')';\n\t\tn++;\n\t\tcontinue;\n\t    }\n\t    if (pat[s] == '\\'' || pat[s] == '\\\\')\n\t\t*p++ = '\\\\';\n\t    *p++ = pat[s];\n\t}\n\t*p++ = '\\'';\n\tif (pRExC_state->pm_flags & RXf_PMf_EXTENDED) {\n\t    *p++ = 'x';\n            if (pRExC_state->pm_flags & RXf_PMf_EXTENDED_MORE) {\n                *p++ = 'x';\n            }\n        }\n\t*p++ = '\\0';\n\tDEBUG_COMPILE_r({\n            Perl_re_printf( aTHX_\n\t\t\"%sre-parsing pattern for runtime code:%s %s\\n\",\n\t\tPL_colors[4], PL_colors[5], newpat);\n\t});\n\n\tsv = newSVpvn_flags(newpat, p-newpat-1, RExC_utf8 ? SVf_UTF8 : 0);\n\tSafefree(newpat);\n\n\tENTER;\n\tSAVETMPS;\n\tsave_re_context();\n\tPUSHSTACKi(PERLSI_REQUIRE);\n        /* G_RE_REPARSING causes the toker to collapse \\\\ into \\ when\n         * parsing qr''; normally only q'' does this. It also alters\n         * hints handling */\n\teval_sv(sv, G_SCALAR|G_RE_REPARSING);\n\tSvREFCNT_dec_NN(sv);\n\tSPAGAIN;\n\tqr_ref = POPs;\n\tPUTBACK;\n\t{\n\t    SV * const errsv = ERRSV;\n\t    if (SvTRUE_NN(errsv))\n                /* use croak_sv ? */\n\t\tPerl_croak_nocontext(\"%\" SVf, SVfARG(errsv));\n\t}\n\tassert(SvROK(qr_ref));\n\tqr = SvRV(qr_ref);\n\tassert(SvTYPE(qr) == SVt_REGEXP && RX_ENGINE((REGEXP*)qr)->op_comp);\n\t/* the leaving below frees the tmp qr_ref.\n\t * Give qr a life of its own */\n\tSvREFCNT_inc(qr);\n\tPOPSTACK;\n\tFREETMPS;\n\tLEAVE;\n\n    }\n\n    if (!RExC_utf8 && SvUTF8(qr)) {\n\t/* first time through; the pattern got upgraded; save the\n\t * qr for the next time through */\n\tassert(!pRExC_state->runtime_code_qr);\n\tpRExC_state->runtime_code_qr = qr;\n\treturn 0;\n    }\n\n\n    /* extract any code blocks within the returned qr//  */\n\n\n    /* merge the main (r1) and run-time (r2) code blocks into one */\n    {\n\tRXi_GET_DECL(ReANY((REGEXP *)qr), r2);\n\tstruct reg_code_block *new_block, *dst;\n\tRExC_state_t * const r1 = pRExC_state; /* convenient alias */\n\tint i1 = 0, i2 = 0;\n        int r1c, r2c;\n\n\tif (!r2->code_blocks || !r2->code_blocks->count) /* we guessed wrong */\n\t{\n\t    SvREFCNT_dec_NN(qr);\n\t    return 1;\n\t}\n\n        if (!r1->code_blocks)\n            r1->code_blocks = S_alloc_code_blocks(aTHX_ 0);\n\n        r1c = r1->code_blocks->count;\n        r2c = r2->code_blocks->count;\n\n\tNewx(new_block, r1c + r2c, struct reg_code_block);\n\n\tdst = new_block;\n\n\twhile (i1 < r1c || i2 < r2c) {\n\t    struct reg_code_block *src;\n\t    bool is_qr = 0;\n\n\t    if (i1 == r1c) {\n\t\tsrc = &r2->code_blocks->cb[i2++];\n\t\tis_qr = 1;\n\t    }\n\t    else if (i2 == r2c)\n\t\tsrc = &r1->code_blocks->cb[i1++];\n\t    else if (  r1->code_blocks->cb[i1].start\n\t             < r2->code_blocks->cb[i2].start)\n\t    {\n\t\tsrc = &r1->code_blocks->cb[i1++];\n\t\tassert(src->end < r2->code_blocks->cb[i2].start);\n\t    }\n\t    else {\n\t\tassert(  r1->code_blocks->cb[i1].start\n\t\t       > r2->code_blocks->cb[i2].start);\n\t\tsrc = &r2->code_blocks->cb[i2++];\n\t\tis_qr = 1;\n\t\tassert(src->end < r1->code_blocks->cb[i1].start);\n\t    }\n\n\t    assert(pat[src->start] == '(');\n\t    assert(pat[src->end]   == ')');\n\t    dst->start\t    = src->start;\n\t    dst->end\t    = src->end;\n\t    dst->block\t    = src->block;\n\t    dst->src_regex  = is_qr ? (REGEXP*) SvREFCNT_inc( (SV*) qr)\n\t\t\t\t    : src->src_regex;\n\t    dst++;\n\t}\n\tr1->code_blocks->count += r2c;\n\tSafefree(r1->code_blocks->cb);\n\tr1->code_blocks->cb = new_block;\n    }\n\n    SvREFCNT_dec_NN(qr);\n    return 1;\n}\n- RExC_emit: #define RExC_emit\t(pRExC_state->emit) /* <=== regcomp.c:252:252:RExC_emit:0 */ \n- fbm_compile: #define fbm_compile(a,b)\tPerl_fbm_compile(aTHX_ a,b) /* <=== embed.h:163:163:fbm_compile:2 */ \n- ANYOF_FLAGS: #define ANYOF_FLAGS(p)\t\t((p)->flags) /* <=== regcomp.h:649:649:ANYOF_FLAGS:1 */ \n- RXf_PMf_EXTENDED: #define RXf_PMf_EXTENDED       (1U << (RXf_PMf_STD_PMMOD_SHIFT+3))    /* /x */ /* <=== op_reg_common.h:34:34:RXf_PMf_EXTENDED:0 */ \n- Renew: #define Renew(v,n,t) \\ /* <=== handy.h:2427:2428:Renew:3 */ \n\t  (v = (MEM_WRAP_CHECK_(n,t) (t*)MEM_LOG_REALLOC(n,t,v,saferealloc((Malloc_t)(v),(MEM_SIZE)((n)*sizeof(t))))))\n- NOT_REACHED: #  define NOT_REACHED ASSUME(0) /* <=== perl.h:3526:3526:NOT_REACHED:0 */ \n- memEQ: #define memEQ(s1,s2,l) (memcmp(((const void *) (s1)), ((const void *) (s2)), l) == 0) /* <=== handy.h:510:510:memEQ:3 */ \n- GROW: #define GROW(old) ((old) * 3 / 2) /* <=== scope.c:66:66:GROW:1 */ \n- PERL_ALLOC_CHECK: #define PERL_ALLOC_CHECK(p)  NOOP /* <=== perl.h:6631:6631:PERL_ALLOC_CHECK:1 */ \n- RExC_study_chunk_recursed_bytes: #define RExC_study_chunk_recursed_bytes  \\ /* <=== regcomp.c:273:274:RExC_study_chunk_recursed_bytes:0 */ \n                                   (pRExC_state->study_chunk_recursed_bytes)\n- PLUS: #define\tPLUS                  \t50\t/* 0x32 Match this (simple) thing 1 or more times. */ /* <=== regnodes.h:64:64:PLUS:0 */ \n- REGNODE_MAX: #define REGNODE_MAX           \t101 /* <=== regnodes.h:9:9:REGNODE_MAX:0 */ \n- RExC_contains_locale: #define RExC_contains_locale\t(pRExC_state->contains_locale) /* <=== regcomp.c:276:276:RExC_contains_locale:0 */ \n- SCF_TRIE_DOING_RESTUDY: #define SCF_TRIE_DOING_RESTUDY 0x10000 /* <=== regcomp.c:575:575:SCF_TRIE_DOING_RESTUDY:0 */ \n- RExC_start: #define RExC_start\t(pRExC_state->start) /* <=== regcomp.c:239:239:RExC_start:0 */ \n- MBOL: #define\tMBOL                  \t3\t/* 0x03 Same, assuming multiline: /^/m */ /* <=== regnodes.h:16:16:MBOL:0 */ \n- SS_ADD_PTR: #define SS_ADD_PTR(p)   ((ssp++)->any_ptr = (void*)(p)) /* <=== scope.h:139:139:SS_ADD_PTR:1 */ \n- Perl_regnext: regnode * /* <=== Perl_regnext */ \nPerl_regnext(pTHX_ regnode *p)\n{\n    I32 offset;\n\n    if (!p)\n\treturn(NULL);\n\n    if (OP(p) > REGNODE_MAX) {\t\t/* regnode.type is unsigned */\n\tPerl_croak(aTHX_ \"Corrupted regexp opcode %d > %d\",\n                                                (int)OP(p), (int)REGNODE_MAX);\n    }\n\n    offset = (reg_off_by_arg[OP(p)] ? ARG(p) : NEXT_OFF(p));\n    if (offset == 0)\n\treturn(NULL);\n\n    return(p+offset);\n}\n- Perl_sv_setsv_flags: void /* <=== Perl_sv_setsv_flags */ \nPerl_sv_setsv_flags(pTHX_ SV *dstr, SV* sstr, const I32 flags)\n{\n    U32 sflags;\n    int dtype;\n    svtype stype;\n    unsigned int both_type;\n\n    PERL_ARGS_ASSERT_SV_SETSV_FLAGS;\n\n    if (UNLIKELY( sstr == dstr ))\n\treturn;\n\n    if (UNLIKELY( !sstr ))\n\tsstr = &PL_sv_undef;\n\n    stype = SvTYPE(sstr);\n    dtype = SvTYPE(dstr);\n    both_type = (stype | dtype);\n\n    /* with these values, we can check that both SVs are NULL/IV (and not\n     * freed) just by testing the or'ed types */\n    STATIC_ASSERT_STMT(SVt_NULL == 0);\n    STATIC_ASSERT_STMT(SVt_IV   == 1);\n    if (both_type <= 1) {\n        /* both src and dst are UNDEF/IV/RV, so we can do a lot of\n         * special-casing */\n        U32 sflags;\n        U32 new_dflags;\n        SV *old_rv = NULL;\n\n        /* minimal subset of SV_CHECK_THINKFIRST_COW_DROP(dstr) */\n        if (SvREADONLY(dstr))\n            Perl_croak_no_modify();\n        if (SvROK(dstr)) {\n            if (SvWEAKREF(dstr))\n                sv_unref_flags(dstr, 0);\n            else\n                old_rv = SvRV(dstr);\n        }\n\n        assert(!SvGMAGICAL(sstr));\n        assert(!SvGMAGICAL(dstr));\n\n        sflags = SvFLAGS(sstr);\n        if (sflags & (SVf_IOK|SVf_ROK)) {\n            SET_SVANY_FOR_BODYLESS_IV(dstr);\n            new_dflags = SVt_IV;\n\n            if (sflags & SVf_ROK) {\n                dstr->sv_u.svu_rv = SvREFCNT_inc(SvRV(sstr));\n                new_dflags |= SVf_ROK;\n            }\n            else {\n                /* both src and dst are <= SVt_IV, so sv_any points to the\n                 * head; so access the head directly\n                 */\n                assert(    &(sstr->sv_u.svu_iv)\n                        == &(((XPVIV*) SvANY(sstr))->xiv_iv));\n                assert(    &(dstr->sv_u.svu_iv)\n                        == &(((XPVIV*) SvANY(dstr))->xiv_iv));\n                dstr->sv_u.svu_iv = sstr->sv_u.svu_iv;\n                new_dflags |= (SVf_IOK|SVp_IOK|(sflags & SVf_IVisUV));\n            }\n        }\n        else {\n            new_dflags = dtype; /* turn off everything except the type */\n        }\n        SvFLAGS(dstr) = new_dflags;\n        SvREFCNT_dec(old_rv);\n\n        return;\n    }\n\n    if (UNLIKELY(both_type == SVTYPEMASK)) {\n        if (SvIS_FREED(dstr)) {\n            Perl_croak(aTHX_ \"panic: attempt to copy value %\" SVf\n                       \" to a freed scalar %p\", SVfARG(sstr), (void *)dstr);\n        }\n        if (SvIS_FREED(sstr)) {\n            Perl_croak(aTHX_ \"panic: attempt to copy freed scalar %p to %p\",\n                       (void*)sstr, (void*)dstr);\n        }\n    }\n\n\n\n    SV_CHECK_THINKFIRST_COW_DROP(dstr);\n    dtype = SvTYPE(dstr); /* THINKFIRST may have changed type */\n\n    /* There's a lot of redundancy below but we're going for speed here */\n\n    switch (stype) {\n    case SVt_NULL:\n      undef_sstr:\n\tif (LIKELY( dtype != SVt_PVGV && dtype != SVt_PVLV )) {\n\t    (void)SvOK_off(dstr);\n\t    return;\n\t}\n\tbreak;\n    case SVt_IV:\n\tif (SvIOK(sstr)) {\n\t    switch (dtype) {\n\t    case SVt_NULL:\n\t\t/* For performance, we inline promoting to type SVt_IV. */\n\t\t/* We're starting from SVt_NULL, so provided that define is\n\t\t * actual 0, we don't have to unset any SV type flags\n\t\t * to promote to SVt_IV. */\n\t\tSTATIC_ASSERT_STMT(SVt_NULL == 0);\n\t\tSET_SVANY_FOR_BODYLESS_IV(dstr);\n\t\tSvFLAGS(dstr) |= SVt_IV;\n\t\tbreak;\n\t    case SVt_NV:\n\t    case SVt_PV:\n\t\tsv_upgrade(dstr, SVt_PVIV);\n\t\tbreak;\n\t    case SVt_PVGV:\n\t    case SVt_PVLV:\n\t\tgoto end_of_first_switch;\n\t    }\n\t    (void)SvIOK_only(dstr);\n\t    SvIV_set(dstr,  SvIVX(sstr));\n\t    if (SvIsUV(sstr))\n\t\tSvIsUV_on(dstr);\n\t    /* SvTAINTED can only be true if the SV has taint magic, which in\n\t       turn means that the SV type is PVMG (or greater). This is the\n\t       case statement for SVt_IV, so this cannot be true (whatever gcov\n\t       may say).  */\n\t    assert(!SvTAINTED(sstr));\n\t    return;\n\t}\n\tif (!SvROK(sstr))\n\t    goto undef_sstr;\n\tif (dtype < SVt_PV && dtype != SVt_IV)\n\t    sv_upgrade(dstr, SVt_IV);\n\tbreak;\n\n    case SVt_NV:\n\tif (LIKELY( SvNOK(sstr) )) {\n\t    switch (dtype) {\n\t    case SVt_NULL:\n\t    case SVt_IV:\n\t\tsv_upgrade(dstr, SVt_NV);\n\t\tbreak;\n\t    case SVt_PV:\n\t    case SVt_PVIV:\n\t\tsv_upgrade(dstr, SVt_PVNV);\n\t\tbreak;\n\t    case SVt_PVGV:\n\t    case SVt_PVLV:\n\t\tgoto end_of_first_switch;\n\t    }\n\t    SvNV_set(dstr, SvNVX(sstr));\n\t    (void)SvNOK_only(dstr);\n\t    /* SvTAINTED can only be true if the SV has taint magic, which in\n\t       turn means that the SV type is PVMG (or greater). This is the\n\t       case statement for SVt_NV, so this cannot be true (whatever gcov\n\t       may say).  */\n\t    assert(!SvTAINTED(sstr));\n\t    return;\n\t}\n\tgoto undef_sstr;\n\n    case SVt_PV:\n\tif (dtype < SVt_PV)\n\t    sv_upgrade(dstr, SVt_PV);\n\tbreak;\n    case SVt_PVIV:\n\tif (dtype < SVt_PVIV)\n\t    sv_upgrade(dstr, SVt_PVIV);\n\tbreak;\n    case SVt_PVNV:\n\tif (dtype < SVt_PVNV)\n\t    sv_upgrade(dstr, SVt_PVNV);\n\tbreak;\n\n    case SVt_INVLIST:\n        invlist_clone(sstr, dstr);\n        break;\n    default:\n\t{\n\tconst char * const type = sv_reftype(sstr,0);\n\tif (PL_op)\n\t    /* diag_listed_as: Bizarre copy of %s */\n\t    Perl_croak(aTHX_ \"Bizarre copy of %s in %s\", type, OP_DESC(PL_op));\n\telse\n\t    Perl_croak(aTHX_ \"Bizarre copy of %s\", type);\n\t}\n\tNOT_REACHED; /* NOTREACHED */\n\n    case SVt_REGEXP:\n      upgregexp:\n\tif (dtype < SVt_REGEXP)\n\t    sv_upgrade(dstr, SVt_REGEXP);\n\tbreak;\n\n    case SVt_PVLV:\n    case SVt_PVGV:\n    case SVt_PVMG:\n\tif (SvGMAGICAL(sstr) && (flags & SV_GMAGIC)) {\n\t    mg_get(sstr);\n\t    if (SvTYPE(sstr) != stype)\n\t\tstype = SvTYPE(sstr);\n\t}\n\tif (isGV_with_GP(sstr) && dtype <= SVt_PVLV) {\n\t\t    glob_assign_glob(dstr, sstr, dtype);\n\t\t    return;\n\t}\n\tif (stype == SVt_PVLV)\n\t{\n\t    if (isREGEXP(sstr)) goto upgregexp;\n\t    SvUPGRADE(dstr, SVt_PVNV);\n\t}\n\telse\n\t    SvUPGRADE(dstr, (svtype)stype);\n    }\n end_of_first_switch:\n\n    /* dstr may have been upgraded.  */\n    dtype = SvTYPE(dstr);\n    sflags = SvFLAGS(sstr);\n\n    if (UNLIKELY( dtype == SVt_PVCV )) {\n\t/* Assigning to a subroutine sets the prototype.  */\n\tif (SvOK(sstr)) {\n\t    STRLEN len;\n\t    const char *const ptr = SvPV_const(sstr, len);\n\n            SvGROW(dstr, len + 1);\n            Copy(ptr, SvPVX(dstr), len + 1, char);\n            SvCUR_set(dstr, len);\n\t    SvPOK_only(dstr);\n\t    SvFLAGS(dstr) |= sflags & SVf_UTF8;\n\t    CvAUTOLOAD_off(dstr);\n\t} else {\n\t    SvOK_off(dstr);\n\t}\n    }\n    else if (UNLIKELY(dtype == SVt_PVAV || dtype == SVt_PVHV\n             || dtype == SVt_PVFM))\n    {\n\tconst char * const type = sv_reftype(dstr,0);\n\tif (PL_op)\n\t    /* diag_listed_as: Cannot copy to %s */\n\t    Perl_croak(aTHX_ \"Cannot copy to %s in %s\", type, OP_DESC(PL_op));\n\telse\n\t    Perl_croak(aTHX_ \"Cannot copy to %s\", type);\n    } else if (sflags & SVf_ROK) {\n\tif (isGV_with_GP(dstr)\n\t    && SvTYPE(SvRV(sstr)) == SVt_PVGV && isGV_with_GP(SvRV(sstr))) {\n\t    sstr = SvRV(sstr);\n\t    if (sstr == dstr) {\n\t\tif (GvIMPORTED(dstr) != GVf_IMPORTED\n\t\t    && CopSTASH_ne(PL_curcop, GvSTASH(dstr)))\n\t\t{\n\t\t    GvIMPORTED_on(dstr);\n\t\t}\n\t\tGvMULTI_on(dstr);\n\t\treturn;\n\t    }\n\t    glob_assign_glob(dstr, sstr, dtype);\n\t    return;\n\t}\n\n\tif (dtype >= SVt_PV) {\n\t    if (isGV_with_GP(dstr)) {\n\t\tgv_setref(dstr, sstr);\n\t\treturn;\n\t    }\n\t    if (SvPVX_const(dstr)) {\n\t\tSvPV_free(dstr);\n\t\tSvLEN_set(dstr, 0);\n                SvCUR_set(dstr, 0);\n\t    }\n\t}\n\t(void)SvOK_off(dstr);\n\tSvRV_set(dstr, SvREFCNT_inc(SvRV(sstr)));\n\tSvFLAGS(dstr) |= sflags & SVf_ROK;\n\tassert(!(sflags & SVp_NOK));\n\tassert(!(sflags & SVp_IOK));\n\tassert(!(sflags & SVf_NOK));\n\tassert(!(sflags & SVf_IOK));\n    }\n    else if (isGV_with_GP(dstr)) {\n\tif (!(sflags & SVf_OK)) {\n\t    Perl_ck_warner(aTHX_ packWARN(WARN_MISC),\n\t\t\t   \"Undefined value assigned to typeglob\");\n\t}\n\telse {\n\t    GV *gv = gv_fetchsv_nomg(sstr, GV_ADD, SVt_PVGV);\n\t    if (dstr != (const SV *)gv) {\n\t\tconst char * const name = GvNAME((const GV *)dstr);\n\t\tconst STRLEN len = GvNAMELEN(dstr);\n\t\tHV *old_stash = NULL;\n\t\tbool reset_isa = FALSE;\n\t\tif ((len > 1 && name[len-2] == ':' && name[len-1] == ':')\n\t\t || (len == 1 && name[0] == ':')) {\n\t\t    /* Set aside the old stash, so we can reset isa caches\n\t\t       on its subclasses. */\n\t\t    if((old_stash = GvHV(dstr))) {\n\t\t\t/* Make sure we do not lose it early. */\n\t\t\tSvREFCNT_inc_simple_void_NN(\n\t\t\t sv_2mortal((SV *)old_stash)\n\t\t\t);\n\t\t    }\n\t\t    reset_isa = TRUE;\n\t\t}\n\n\t\tif (GvGP(dstr)) {\n\t\t    SvREFCNT_inc_simple_void_NN(sv_2mortal(dstr));\n\t\t    gp_free(MUTABLE_GV(dstr));\n\t\t}\n\t\tGvGP_set(dstr, gp_ref(GvGP(gv)));\n\n\t\tif (reset_isa) {\n\t\t    HV * const stash = GvHV(dstr);\n\t\t    if(\n\t\t        old_stash ? (HV *)HvENAME_get(old_stash) : stash\n\t\t    )\n\t\t\tmro_package_moved(\n\t\t\t stash, old_stash,\n\t\t\t (GV *)dstr, 0\n\t\t\t);\n\t\t}\n\t    }\n\t}\n    }\n    else if ((dtype == SVt_REGEXP || dtype == SVt_PVLV)\n\t  && (stype == SVt_REGEXP || isREGEXP(sstr))) {\n\treg_temp_copy((REGEXP*)dstr, (REGEXP*)sstr);\n    }\n    else if (sflags & SVp_POK) {\n\tconst STRLEN cur = SvCUR(sstr);\n\tconst STRLEN len = SvLEN(sstr);\n\n\t/*\n\t * We have three basic ways to copy the string:\n\t *\n\t *  1. Swipe\n\t *  2. Copy-on-write\n\t *  3. Actual copy\n\t * \n\t * Which we choose is based on various factors.  The following\n\t * things are listed in order of speed, fastest to slowest:\n\t *  - Swipe\n\t *  - Copying a short string\n\t *  - Copy-on-write bookkeeping\n\t *  - malloc\n\t *  - Copying a long string\n\t * \n\t * We swipe the string (steal the string buffer) if the SV on the\n\t * rhs is about to be freed anyway (TEMP and refcnt==1).  This is a\n\t * big win on long strings.  It should be a win on short strings if\n\t * SvPVX_const(dstr) has to be allocated.  If not, it should not \n\t * slow things down, as SvPVX_const(sstr) would have been freed\n\t * soon anyway.\n\t * \n\t * We also steal the buffer from a PADTMP (operator target) if it\n\t * is long enough.  For short strings, a swipe does not help\n\t * here, as it causes more malloc calls the next time the target\n\t * is used.  Benchmarks show that even if SvPVX_const(dstr) has to\n\t * be allocated it is still not worth swiping PADTMPs for short\n\t * strings, as the savings here are small.\n\t * \n\t * If swiping is not an option, then we see whether it is\n\t * worth using copy-on-write.  If the lhs already has a buf-\n\t * fer big enough and the string is short, we skip it and fall back\n\t * to method 3, since memcpy is faster for short strings than the\n\t * later bookkeeping overhead that copy-on-write entails.\n\n\t * If the rhs is not a copy-on-write string yet, then we also\n\t * consider whether the buffer is too large relative to the string\n\t * it holds.  Some operations such as readline allocate a large\n\t * buffer in the expectation of reusing it.  But turning such into\n\t * a COW buffer is counter-productive because it increases memory\n\t * usage by making readline allocate a new large buffer the sec-\n\t * ond time round.  So, if the buffer is too large, again, we use\n\t * method 3 (copy).\n\t * \n\t * Finally, if there is no buffer on the left, or the buffer is too \n\t * small, then we use copy-on-write and make both SVs share the\n\t * string buffer.\n\t *\n\t */\n\n\t/* Whichever path we take through the next code, we want this true,\n\t   and doing it now facilitates the COW check.  */\n\t(void)SvPOK_only(dstr);\n\n\tif (\n                 (              /* Either ... */\n\t\t\t\t/* slated for free anyway (and not COW)? */\n                    (sflags & (SVs_TEMP|SVf_IsCOW)) == SVs_TEMP\n                                /* or a swipable TARG */\n                 || ((sflags &\n                           (SVs_PADTMP|SVf_READONLY|SVf_PROTECT|SVf_IsCOW))\n                       == SVs_PADTMP\n                                /* whose buffer is worth stealing */\n                     && CHECK_COWBUF_THRESHOLD(cur,len)\n                    )\n                 ) &&\n                 !(sflags & SVf_OOK) &&   /* and not involved in OOK hack? */\n\t         (!(flags & SV_NOSTEAL)) &&\n\t\t\t\t\t/* and we're allowed to steal temps */\n                 SvREFCNT(sstr) == 1 &&   /* and no other references to it? */\n                 len)             /* and really is a string */\n\t{\t/* Passes the swipe test.  */\n\t    if (SvPVX_const(dstr))\t/* we know that dtype >= SVt_PV */\n\t\tSvPV_free(dstr);\n\t    SvPV_set(dstr, SvPVX_mutable(sstr));\n\t    SvLEN_set(dstr, SvLEN(sstr));\n\t    SvCUR_set(dstr, SvCUR(sstr));\n\n\t    SvTEMP_off(dstr);\n\t    (void)SvOK_off(sstr);\t/* NOTE: nukes most SvFLAGS on sstr */\n\t    SvPV_set(sstr, NULL);\n\t    SvLEN_set(sstr, 0);\n\t    SvCUR_set(sstr, 0);\n\t    SvTEMP_off(sstr);\n        }\n\telse if (flags & SV_COW_SHARED_HASH_KEYS\n\t      &&\n#ifdef PERL_COPY_ON_WRITE\n\t\t (sflags & SVf_IsCOW\n\t\t   ? (!len ||\n                       (  (CHECK_COWBUF_THRESHOLD(cur,len) || SvLEN(dstr) < cur+1)\n\t\t\t  /* If this is a regular (non-hek) COW, only so\n\t\t\t     many COW \"copies\" are possible. */\n\t\t       && CowREFCNT(sstr) != SV_COW_REFCNT_MAX  ))\n\t\t   : (  (sflags & CAN_COW_MASK) == CAN_COW_FLAGS\n\t\t     && !(SvFLAGS(dstr) & SVf_BREAK)\n                     && CHECK_COW_THRESHOLD(cur,len) && cur+1 < len\n                     && (CHECK_COWBUF_THRESHOLD(cur,len) || SvLEN(dstr) < cur+1)\n\t\t    ))\n#else\n\t\t sflags & SVf_IsCOW\n\t      && !(SvFLAGS(dstr) & SVf_BREAK)\n#endif\n            ) {\n            /* Either it's a shared hash key, or it's suitable for\n               copy-on-write.  */\n#ifdef DEBUGGING\n            if (DEBUG_C_TEST) {\n                PerlIO_printf(Perl_debug_log, \"Copy on write: sstr --> dstr\\n\");\n                sv_dump(sstr);\n                sv_dump(dstr);\n            }\n#endif\n#ifdef PERL_ANY_COW\n            if (!(sflags & SVf_IsCOW)) {\n                    SvIsCOW_on(sstr);\n\t\t    CowREFCNT(sstr) = 0;\n            }\n#endif\n\t    if (SvPVX_const(dstr)) {\t/* we know that dtype >= SVt_PV */\n\t\tSvPV_free(dstr);\n\t    }\n\n#ifdef PERL_ANY_COW\n\t    if (len) {\n\t\t    if (sflags & SVf_IsCOW) {\n\t\t\tsv_buf_to_rw(sstr);\n\t\t    }\n\t\t    CowREFCNT(sstr)++;\n                    SvPV_set(dstr, SvPVX_mutable(sstr));\n                    sv_buf_to_ro(sstr);\n            } else\n#endif\n            {\n                    /* SvIsCOW_shared_hash */\n                    DEBUG_C(PerlIO_printf(Perl_debug_log,\n                                          \"Copy on write: Sharing hash\\n\"));\n\n\t\t    assert (SvTYPE(dstr) >= SVt_PV);\n                    SvPV_set(dstr,\n\t\t\t     HEK_KEY(share_hek_hek(SvSHARED_HEK_FROM_PV(SvPVX_const(sstr)))));\n\t    }\n\t    SvLEN_set(dstr, len);\n\t    SvCUR_set(dstr, cur);\n\t    SvIsCOW_on(dstr);\n\t} else {\n\t    /* Failed the swipe test, and we cannot do copy-on-write either.\n\t       Have to copy the string.  */\n\t    SvGROW(dstr, cur + 1);\t/* inlined from sv_setpvn */\n\t    Move(SvPVX_const(sstr),SvPVX(dstr),cur,char);\n\t    SvCUR_set(dstr, cur);\n\t    *SvEND(dstr) = '\\0';\n        }\n\tif (sflags & SVp_NOK) {\n\t    SvNV_set(dstr, SvNVX(sstr));\n\t}\n\tif (sflags & SVp_IOK) {\n\t    SvIV_set(dstr, SvIVX(sstr));\n\t    if (sflags & SVf_IVisUV)\n\t\tSvIsUV_on(dstr);\n\t}\n\tSvFLAGS(dstr) |= sflags & (SVf_IOK|SVp_IOK|SVf_NOK|SVp_NOK|SVf_UTF8);\n\t{\n\t    const MAGIC * const smg = SvVSTRING_mg(sstr);\n\t    if (smg) {\n\t\tsv_magic(dstr, NULL, PERL_MAGIC_vstring,\n\t\t\t smg->mg_ptr, smg->mg_len);\n\t\tSvRMAGICAL_on(dstr);\n\t    }\n\t}\n    }\n    else if (sflags & (SVp_IOK|SVp_NOK)) {\n\t(void)SvOK_off(dstr);\n\tSvFLAGS(dstr) |= sflags & (SVf_IOK|SVp_IOK|SVf_IVisUV|SVf_NOK|SVp_NOK);\n\tif (sflags & SVp_IOK) {\n\t    /* XXXX Do we want to set IsUV for IV(ROK)?  Be extra safe... */\n\t    SvIV_set(dstr, SvIVX(sstr));\n\t}\n\tif (sflags & SVp_NOK) {\n\t    SvNV_set(dstr, SvNVX(sstr));\n\t}\n    }\n    else {\n\tif (isGV_with_GP(sstr)) {\n\t    gv_efullname3(dstr, MUTABLE_GV(sstr), \"*\");\n\t}\n\telse\n\t    (void)SvOK_off(dstr);\n    }\n    if (SvTAINTED(sstr))\n\tSvTAINT(dstr);\n}\n- RExC_rx: #define RExC_rx\t\t(pRExC_state->rx) /* <=== regcomp.c:237:237:RExC_rx:0 */ \n- RExC_orig_utf8: #define RExC_orig_utf8\t(pRExC_state->orig_utf8) /* <=== regcomp.c:265:265:RExC_orig_utf8:0 */ \n- Perl_savestack_grow: void /* <=== Perl_savestack_grow */ \nPerl_savestack_grow(pTHX)\n{\n    IV new_max;\n#ifdef STRESS_REALLOC\n    new_max = PL_savestack_max + SS_MAXPUSH;\n#else\n    new_max = GROW(PL_savestack_max);\n#endif\n    /* Note that we allocate SS_MAXPUSH slots higher than ss_max\n     * so that SS_ADD_END(), SSGROW() etc can do a simper check */\n    Renew(PL_savestack, new_max + SS_MAXPUSH, ANY);\n    PL_savestack_max = new_max;\n}\n- STAR: #define\tSTAR                  \t49\t/* 0x31 Match this (simple) thing 0 or more times. */ /* <=== regnodes.h:63:63:STAR:0 */ \n- BOUND: #define\tBOUND                 \t8\t/* 0x08 Like BOUNDA for non-utf8, otherwise match \"\" between any Unicode \\w\\W or \\W\\w */ /* <=== regnodes.h:22:22:BOUND:0 */ \n- STR_WITH_LEN: #define STR_WITH_LEN(s)  (\"\" s \"\"), (sizeof(s)-1) /* <=== handy.h:363:363:STR_WITH_LEN:1 */ \n- newSVpvs: #define newSVpvs(str) Perl_newSVpvn(aTHX_ STR_WITH_LEN(str)) /* <=== handy.h:371:371:newSVpvs:1 */ \n- RExC_recurse_count: #define RExC_recurse_count\t(pRExC_state->recurse_count) /* <=== regcomp.c:271:271:RExC_recurse_count:0 */ \n- Newx: #define Newx(v,n,t)\t(v = (MEM_WRAP_CHECK_(n,t) (t*)MEM_LOG_ALLOC(n,t,safemalloc((MEM_SIZE)((n)*sizeof(t)))))) /* <=== handy.h:2416:2416:Newx:3 */ \n- PREGf_CUTGROUP_SEEN: #define PREGf_CUTGROUP_SEEN\t0x00000010 /* <=== regcomp.h:134:134:PREGf_CUTGROUP_SEEN:0 */ \n- RExC_use_BRANCHJ: #define RExC_use_BRANCHJ        (pRExC_state->use_BRANCHJ) /* <=== regcomp.c:288:288:RExC_use_BRANCHJ:0 */ \n- Perl_newSV_type: SV * /* <=== Perl_newSV_type */ \nPerl_newSV_type(pTHX_ const svtype type)\n{\n    SV *sv;\n\n    new_SV(sv);\n    ASSUME(SvTYPE(sv) == SVt_FIRST);\n    if(type != SVt_FIRST)\n\tsv_upgrade(sv, type);\n    return sv;\n}\n- RExC_rx_sv: #define RExC_rx_sv\t(pRExC_state->rx_sv) /* <=== regcomp.c:236:236:RExC_rx_sv:0 */ \n- SvPV_nomg: #define SvPV_nomg(sv, lp) SvPV_flags(sv, lp, 0) /* <=== sv.h:1719:1719:SvPV_nomg:2 */ \n- RExC_uni_semantics: #define RExC_uni_semantics\t(pRExC_state->uni_semantics) /* <=== regcomp.c:264:264:RExC_uni_semantics:0 */ \n- ReREFCNT_dec: #  define ReREFCNT_dec(re)\tSvREFCNT_dec(re) /* <=== regexp.h:629:629:ReREFCNT_dec:1 */ \n- ARG2L_SET: #define ARG2L_SET(p, val) ARG__SET(ARG2L_LOC(p), (val)) /* <=== regcomp.h:305:305:ARG2L_SET:2 */ \n- MINMOD: #define\tMINMOD                \t78\t/* 0x4e Next operator is not greedy. */ /* <=== regnodes.h:92:92:MINMOD:0 */ \n- PUSHSTACKi: #define PUSHSTACKi(type) \\ /* <=== cop.h:1041:1061:PUSHSTACKi:1 */ \n    STMT_START {\t\t\t\t\t\t\t\\\n\tPERL_SI *next = PL_curstackinfo->si_next;\t\t\t\\\n\tDEBUG_l({\t\t\t\t\t\t\t\\\n\t    int i = 0; PERL_SI *p = PL_curstackinfo;\t\t\t\\\n\t    while (p) { i++; p = p->si_prev; }\t\t\t\t\\\n\t    Perl_deb(aTHX_ \"push STACKINFO %d at %s:%d\\n\",\t\t\\\n\t\t         i, __FILE__, __LINE__);})\t\t\t\\\n\tif (!next) {\t\t\t\t\t\t\t\\\n\t    next = new_stackinfo(32, 2048/sizeof(PERL_CONTEXT) - 1);\t\\\n\t    next->si_prev = PL_curstackinfo;\t\t\t\t\\\n\t    PL_curstackinfo->si_next = next;\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tnext->si_type = type;\t\t\t\t\t\t\\\n\tnext->si_cxix = -1;\t\t\t\t\t\t\\\n        PUSHSTACK_INIT_HWM(next);                                       \\\n\tAvFILLp(next->si_stack) = 0;\t\t\t\t\t\\\n\tSWITCHSTACK(PL_curstack,next->si_stack);\t\t\t\\\n\tPL_curstackinfo = next;\t\t\t\t\t\t\\\n\tSET_MARK_OFFSET;\t\t\t\t\t\t\\\n    } STMT_END\n- RXf_CHECK_ALL: #define RXf_CHECK_ALL   \t(1U<<(RXf_BASE_SHIFT+5)) /* <=== regexp.h:428:428:RXf_CHECK_ALL:0 */ \n- RX_PRELEN: #define RX_PRELEN(rx_sv)                (RX_WRAPLEN(rx_sv) \\ /* <=== regexp.h:520:521:RX_PRELEN:1 */ \n                                            - ReANY(rx_sv)->pre_prefix - 1)\n- OP: #define\tOP(p)\t\t((p)->type) /* <=== regcomp.h:330:330:OP:1 */ \n- NOOP: #define NOOP /*EMPTY*/(void)0 /* <=== perl.h:464:464:NOOP:0 */ \n- Perl_newSVsv_flags: SV * /* <=== Perl_newSVsv_flags */ \nPerl_newSVsv_flags(pTHX_ SV *const old, I32 flags)\n{\n    SV *sv;\n\n    if (!old)\n\treturn NULL;\n    if (SvTYPE(old) == (svtype)SVTYPEMASK) {\n\tPerl_ck_warner_d(aTHX_ packWARN(WARN_INTERNAL), \"semi-panic: attempt to dup freed string\");\n\treturn NULL;\n    }\n    /* Do this here, otherwise we leak the new SV if this croaks. */\n    if (flags & SV_GMAGIC)\n        SvGETMAGIC(old);\n    new_SV(sv);\n    sv_setsv_flags(sv, old, flags & ~SV_GMAGIC);\n    return sv;\n}\n- RExC_precomp: #define RExC_precomp\t(pRExC_state->precomp) /* <=== regcomp.c:231:231:RExC_precomp:0 */ \n- PUTBACK: #define PUTBACK\t\tPL_stack_sp = sp /* <=== pp.h:140:140:PUTBACK:0 */ \n- SvUTF8: #define SvUTF8(sv)\t\t(SvFLAGS(sv) & SVf_UTF8) /* <=== sv.h:927:927:SvUTF8:1 */ \n- LEAVE_SCOPE: #define LEAVE_SCOPE(old) STMT_START { \\ /* <=== scope.h:221:223:LEAVE_SCOPE:1 */ \n\tif (PL_savestack_ix > old) leave_scope(old); \\\n    } STMT_END\n- SvREFCNT_inc: #define SvREFCNT_inc(sv)\t\tS_SvREFCNT_inc(MUTABLE_SV(sv)) /* <=== sv.h:337:337:SvREFCNT_inc:1 */ \n- NBOUND: #define\tNBOUND                \t12\t/* 0x0c Like NBOUNDA for non-utf8, otherwise match \"\" between any Unicode \\w\\w or \\W\\W */ /* <=== regnodes.h:26:26:NBOUND:0 */ \n- PL_sv_undef: #  define PL_sv_undef (PL_sv_immortals[1]) /* <=== perl.h:5346:5346:PL_sv_undef:0 */ \n- Perl_pop_scope: void /* <=== Perl_pop_scope */ \nPerl_pop_scope(pTHX)\n{\n    const I32 oldsave = PL_scopestack[--PL_scopestack_ix];\n    LEAVE_SCOPE(oldsave);\n}\n- SSize_t_MAX: #define SSize_t_MAX (SSize_t)(~(Size_t)0 >> 1) /* <=== perl.h:1759:1759:SSize_t_MAX:0 */ \n- RExC_seen_zerolen: #define RExC_seen_zerolen\t(pRExC_state->seen_zerolen) /* <=== regcomp.c:262:262:RExC_seen_zerolen:0 */ \n- RExC_precomp_end: #define RExC_precomp_end (pRExC_state->precomp_end) /* <=== regcomp.c:235:235:RExC_precomp_end:0 */ \n- IFMATCH: #define\tIFMATCH               \t72\t/* 0x48 Succeeds if the following matches; non-zero flags \"f\", next_off \"o\" means lookbehind assertion starting \"f..(f-o)\" characters before current */ /* <=== regnodes.h:86:86:IFMATCH:0 */ \n- STR_SZ: #define STR_SZ(l)\t((l + sizeof(regnode) - 1) / sizeof(regnode)) /* <=== regcomp.h:338:338:STR_SZ:1 */ \n- POPs: #define POPs\t\t(*sp--) /* <=== pp.h:145:145:POPs:0 */ \n- ENTER_with_name: #define ENTER_with_name(name) ENTER /* <=== scope.h:218:218:ENTER_with_name:1 */ \n- safesysmalloc: #define safesysmalloc\t\tPerl_safesysmalloc /* <=== embed.h:650:650:safesysmalloc:0 */ \n- RXf_IS_ANCHORED: #define RXf_IS_ANCHORED         (1U<<(RXf_BASE_SHIFT+10)) /* <=== regexp.h:440:440:RXf_IS_ANCHORED:0 */ \n- check_end_shift: #define check_end_shift substrs->data[2].end_shift /* <=== regcomp.h:811:811:check_end_shift:0 */ \n- croak_memory_wrap: #define croak_memory_wrap\tS_croak_memory_wrap /* <=== embed.h:98:98:croak_memory_wrap:0 */ \n- RExC_nestroot: #define RExC_nestroot   (pRExC_state->nestroot) /* <=== regcomp.c:261:261:RExC_nestroot:0 */ \n- dSS_ADD: #define dSS_ADD \\ /* <=== scope.h:122:124:dSS_ADD:0 */ \n    I32 ix = PL_savestack_ix;     \\\n    ANY *ssp = &PL_savestack[ix]\n- Perl_push_scope: void /* <=== Perl_push_scope */ \nPerl_push_scope(pTHX)\n{\n    if (UNLIKELY(PL_scopestack_ix == PL_scopestack_max)) {\n        const IV new_max = GROW(PL_scopestack_max);\n\tRenew(PL_scopestack, new_max, I32);\n#ifdef DEBUGGING\n\tRenew(PL_scopestack_name, new_max, const char*);\n#endif\n\tPL_scopestack_max = new_max;\n    }\n#ifdef DEBUGGING\n    PL_scopestack_name[PL_scopestack_ix] = \"unknown\";\n#endif\n    PL_scopestack[PL_scopestack_ix++] = PL_savestack_ix;\n\n}\n- RXp_PAREN_NAMES: #define RXp_PAREN_NAMES(rx)\t((rx)->paren_names) /* <=== regexp.h:171:171:RXp_PAREN_NAMES:1 */ \n- RExC_study_chunk_recursed: #define RExC_study_chunk_recursed        (pRExC_state->study_chunk_recursed) /* <=== regcomp.c:272:272:RExC_study_chunk_recursed:0 */ \n- RX_COMPFLAGS: #define RX_COMPFLAGS(rx_sv)             RXp_COMPFLAGS(ReANY(rx_sv)) /* <=== regexp.h:529:529:RX_COMPFLAGS:1 */ \n- RXf_WHITE: #define RXf_WHITE\t\t(1U<<(RXf_BASE_SHIFT+16)) /* Pattern is /\\s+/ */ /* <=== regexp.h:454:454:RXf_WHITE:0 */ \n- RXf_NULL: #define RXf_NULL\t\t(1U<<(RXf_BASE_SHIFT+17)) /* Pattern is // */ /* <=== regexp.h:455:455:RXf_NULL:0 */ \n- IN_PERL_COMPILETIME: #define IN_PERL_COMPILETIME\tcBOOL(PL_curcop == &PL_compiling) /* <=== cop.h:1092:1092:IN_PERL_COMPILETIME:0 */ \n- RExC_in_multi_char_class: #define RExC_in_multi_char_class (pRExC_state->in_multi_char_class) /* <=== regcomp.c:280:280:RExC_in_multi_char_class:0 */ \n- RXf_NO_INPLACE_SUBST: #define RXf_NO_INPLACE_SUBST    (1U<<(RXf_BASE_SHIFT+2)) /* <=== regexp.h:423:423:RXf_NO_INPLACE_SUBST:0 */ \n- RExC_emit_start: #define RExC_emit_start\t(pRExC_state->emit_start) /* <=== regcomp.c:253:253:RExC_emit_start:0 */ \n- PREGf_VERBARG_SEEN: #define PREGf_VERBARG_SEEN\t0x00000008 /* <=== regcomp.h:133:133:PREGf_VERBARG_SEEN:0 */ \n- RXi_SET: #define RXi_SET(x,y) (x)->pprivate = (void*)(y)    /* <=== regcomp.h:118:118:RXi_SET:2 */ \n- NEXT_OFF: #define NEXT_OFF(p) ((p)->next_off) /* <=== regcomp.h:310:310:NEXT_OFF:1 */ \n- POPSTACK: #define POPSTACK \\ /* <=== cop.h:1067:1082:POPSTACK:0 */ \n    STMT_START {\t\t\t\t\t\t\t\\\n\tdSP;\t\t\t\t\t\t\t\t\\\n\tPERL_SI * const prev = PL_curstackinfo->si_prev;\t\t\\\n\tDEBUG_l({\t\t\t\t\t\t\t\\\n\t    int i = -1; PERL_SI *p = PL_curstackinfo;\t\t\t\\\n\t    while (p) { i++; p = p->si_prev; }\t\t\t\t\\\n\t    Perl_deb(aTHX_ \"pop  STACKINFO %d at %s:%d\\n\",\t\t\\\n\t\t         i, __FILE__, __LINE__);})\t\t\t\\\n\tif (!prev) {\t\t\t\t\t\t\t\\\n\t    Perl_croak_popstack();\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tSWITCHSTACK(PL_curstack,prev->si_stack);\t\t\t\\\n\t/* don't free prev here, free them all at the END{} */\t\t\\\n\tPL_curstackinfo = prev;\t\t\t\t\t\t\\\n    } STMT_END\n- PL_hints: #define PL_hints PL_compiling.cop_hints /* <=== perl.h:5028:5028:PL_hints:0 */ \n- Perl_sv_setpvn: void /* <=== Perl_sv_setpvn */ \nPerl_sv_setpvn(pTHX_ SV *const sv, const char *const ptr, const STRLEN len)\n{\n    char *dptr;\n\n    PERL_ARGS_ASSERT_SV_SETPVN;\n\n    SV_CHECK_THINKFIRST_COW_DROP(sv);\n    if (isGV_with_GP(sv))\n\tPerl_croak_no_modify();\n    if (!ptr) {\n\t(void)SvOK_off(sv);\n\treturn;\n    }\n    else {\n        /* len is STRLEN which is unsigned, need to copy to signed */\n\tconst IV iv = len;\n\tif (iv < 0)\n\t    Perl_croak(aTHX_ \"panic: sv_setpvn called with negative strlen %\"\n\t\t       IVdf, iv);\n    }\n    SvUPGRADE(sv, SVt_PV);\n\n    dptr = SvGROW(sv, len + 1);\n    Move(ptr,dptr,len,char);\n    dptr[len] = '\\0';\n    SvCUR_set(sv, len);\n    (void)SvPOK_only_UTF8(sv);\t\t/* validate pointer */\n    SvTAINT(sv);\n    if (SvTYPE(sv) == SVt_PVCV) CvAUTOLOAD_off(sv);\n}\n- FREETMPS: #define FREETMPS if (PL_tmps_ix > PL_tmps_floor) free_tmps() /* <=== scope.h:185:185:FREETMPS:0 */ \n- PMf_USE_RE_EVAL: #define PMf_USE_RE_EVAL\t(1U<<(PMf_BASE_SHIFT+17)) /* use re'eval' in scope */ /* <=== op.h:371:371:PMf_USE_RE_EVAL:0 */ \n- newSV_type: #define newSV_type(a)\t\tPerl_newSV_type(aTHX_ a) /* <=== embed.h:537:537:newSV_type:1 */ \n- REG_VERBARG_SEEN: #define REG_VERBARG_SEEN                    0x00000080 /* <=== regcomp.h:726:726:REG_VERBARG_SEEN:0 */ \n\nType Definitions:\n- RExC_state_t: struct RExC_state_t {\n    U32\t\tflags;\t\t\t/* RXf_* are we folding, multilining? */\n    U32\t\tpm_flags;\t\t/* PMf_* stuff from the calling PMOP */\n    char\t*precomp;\t\t/* uncompiled string. */\n    char\t*precomp_end;\t\t/* pointer to end of uncompiled string. */\n    REGEXP\t*rx_sv;\t\t\t/* The SV that is the regexp. */\n    regexp\t*rx;                    /* perl core regexp structure */\n    regexp_internal\t*rxi;           /* internal data for regexp object\n                                           pprivate field */\n    char\t*start;\t\t\t/* Start of input for compile */\n    char\t*end;\t\t\t/* End of input for compile */\n    char\t*parse;\t\t\t/* Input-scan pointer. */\n    char        *copy_start;            /* start of copy of input within\n                                           constructed parse string */\n    char        *save_copy_start;       /* Provides one level of saving\n                                           and restoring 'copy_start' */\n    char        *copy_start_in_input;   /* Position in input string\n                                           corresponding to copy_start */\n    SSize_t\twhilem_seen;\t\t/* number of WHILEM in this expr */\n    regnode\t*emit_start;\t\t/* Start of emitted-code area */\n    regnode_offset emit;\t\t/* Code-emit pointer */\n    I32\t\tnaughty;\t\t/* How bad is this pattern? */\n    I32\t\tsawback;\t\t/* Did we see \\1, ...? */\n    U32\t\tseen;\n    SSize_t\tsize;\t\t\t/* Number of regnode equivalents in\n                                           pattern */\n\n    /* position beyond 'precomp' of the warning message furthest away from\n     * 'precomp'.  During the parse, no warnings are raised for any problems\n     * earlier in the parse than this position.  This works if warnings are\n     * raised the first time a given spot is parsed, and if only one\n     * independent warning is raised for any given spot */\n    Size_t\tlatest_warn_offset;\n\n    I32         npar;                   /* Capture buffer count so far in the\n                                           parse, (OPEN) plus one. (\"par\" 0 is\n                                           the whole pattern)*/\n    I32         total_par;              /* During initial parse, is either 0,\n                                           or -1; the latter indicating a\n                                           reparse is needed.  After that pass,\n                                           it is what 'npar' became after the\n                                           pass.  Hence, it being > 0 indicates\n                                           we are in a reparse situation */\n    I32\t\tnestroot;\t\t/* root parens we are in - used by\n                                           accept */\n    I32\t\tseen_zerolen;\n    regnode_offset *open_parens;\t/* offsets to open parens */\n    regnode_offset *close_parens;\t/* offsets to close parens */\n    I32      parens_buf_size;           /* #slots malloced open/close_parens */\n    regnode     *end_op;                /* END node in program */\n    I32\t\tutf8;\t\t/* whether the pattern is utf8 or not */\n    I32\t\torig_utf8;\t/* whether the pattern was originally in utf8 */\n\t\t\t\t/* XXX use this for future optimisation of case\n\t\t\t\t * where pattern must be upgraded to utf8. */\n    I32\t\tuni_semantics;\t/* If a d charset modifier should use unicode\n\t\t\t\t   rules, even if the pattern is not in\n\t\t\t\t   utf8 */\n    HV\t\t*paren_names;\t\t/* Paren names */\n\n    regnode\t**recurse;\t\t/* Recurse regops */\n    I32         recurse_count;          /* Number of recurse regops we have generated */\n    U8          *study_chunk_recursed;  /* bitmap of which subs we have moved\n                                           through */\n    U32         study_chunk_recursed_bytes;  /* bytes in bitmap */\n    I32\t\tin_lookbehind;\n    I32\t\tcontains_locale;\n    I32\t\toverride_recoding;\n#ifdef EBCDIC\n    I32\t\trecode_x_to_native;\n#endif\n    I32\t\tin_multi_char_class;\n    struct reg_code_blocks *code_blocks;/* positions of literal (?{})\n\t\t\t\t\t    within pattern */\n    int\t\tcode_index;\t\t/* next code_blocks[] slot */\n    SSize_t     maxlen;                        /* mininum possible number of chars in string to match */\n    scan_frame *frame_head;\n    scan_frame *frame_last;\n    U32         frame_count;\n    AV         *warn_text;\n    HV         *unlexed_names;\n#ifdef ADD_TO_REGEXEC\n    char \t*starttry;\t\t/* -Dr: where regtry was called. */\n#define RExC_starttry\t(pRExC_state->starttry)\n#endif\n    SV\t\t*runtime_code_qr;\t/* qr with the runtime code blocks */\n#ifdef DEBUGGING\n    const char  *lastparse;\n    I32         lastnum;\n    AV          *paren_name_list;       /* idx -> name */\n    U32         study_chunk_recursed_count;\n    SV          *mysv1;\n    SV          *mysv2;\n\n#define RExC_lastparse\t(pRExC_state->lastparse)\n#define RExC_lastnum\t(pRExC_state->lastnum)\n#define RExC_paren_name_list    (pRExC_state->paren_name_list)\n#define RExC_study_chunk_recursed_count    (pRExC_state->study_chunk_recursed_count)\n#define RExC_mysv\t(pRExC_state->mysv1)\n#define RExC_mysv1\t(pRExC_state->mysv1)\n#define RExC_mysv2\t(pRExC_state->mysv2)\n\n#endif\n    bool        seen_d_op;\n    bool        strict;\n    bool        study_started;\n    bool        in_script_run;\n    bool        use_BRANCHJ;\n}\n- cop: struct cop {\n    BASEOP\n    /* On LP64 putting this here takes advantage of the fact that BASEOP isn't\n       an exact multiple of 8 bytes to save structure padding.  */\n    line_t      cop_line;       /* line # of this command */\n    /* label for this construct is now stored in cop_hints_hash */\n#ifdef USE_ITHREADS\n    PADOFFSET\tcop_stashoff;\t/* offset into PL_stashpad, for the\n\t\t\t\t   package the line was compiled in */\n    char *\tcop_file;\t/* file name the following line # is from */\n#else\n    HV *\tcop_stash;\t/* package line was compiled in */\n    GV *\tcop_filegv;\t/* file the following line # is from */\n#endif\n    U32\t\tcop_hints;\t/* hints bits from pragmata */\n    U32\t\tcop_seq;\t/* parse sequence number */\n    /* Beware. mg.c and warnings.pl assume the type of this is STRLEN *:  */\n    STRLEN *\tcop_warnings;\t/* lexical warnings bitmask */\n    /* compile time state of %^H.  See the comment in op.c for how this is\n       used to recreate a hash to return from caller.  */\n    COPHH *\tcop_hints_hash;\n}\n- regexp_paren_pair: typedef struct regexp_paren_pair {\n    SSize_t start;\n    SSize_t end;\n    /* 'start_tmp' records a new opening position before the matching end\n     * has been found, so that the old start and end values are still\n     * valid, e.g.\n     *\t  \"abc\" =~ /(.(?{print \"[$1]\"}))+/\n     *outputs [][a][b]\n     * This field is not part of the API.  */\n    SSize_t start_tmp;\n} regexp_paren_pair;\n- reg_code_blocks: struct reg_code_blocks {\n    int refcnt; /* we may be pointed to from a regex and from the savestack */\n    int  count;    /* how many code blocks */\n    struct reg_code_block *cb; /* array of reg_code_block's */\n}\n- regexp_engine: typedef struct regexp_engine {\n    REGEXP* (*comp) (pTHX_ SV * const pattern, U32 flags);\n    I32     (*exec) (pTHX_ REGEXP * const rx, char* stringarg, char* strend,\n                     char* strbeg, SSize_t minend, SV* sv,\n                     void* data, U32 flags);\n    char*   (*intuit) (pTHX_\n                        REGEXP * const rx,\n                        SV *sv,\n                        const char * const strbeg,\n                        char *strpos,\n                        char *strend,\n                        const U32 flags,\n                       re_scream_pos_data *data);\n    SV*     (*checkstr) (pTHX_ REGEXP * const rx);\n    void    (*rxfree) (pTHX_ REGEXP * const rx);\n    void    (*numbered_buff_FETCH) (pTHX_ REGEXP * const rx, const I32 paren,\n                                    SV * const sv);\n    void    (*numbered_buff_STORE) (pTHX_ REGEXP * const rx, const I32 paren,\n                                   SV const * const value);\n    I32     (*numbered_buff_LENGTH) (pTHX_ REGEXP * const rx, const SV * const sv,\n                                    const I32 paren);\n    SV*     (*named_buff) (pTHX_ REGEXP * const rx, SV * const key,\n                           SV * const value, const U32 flags);\n    SV*     (*named_buff_iter) (pTHX_ REGEXP * const rx, const SV * const lastkey,\n                                const U32 flags);\n    SV*     (*qr_package)(pTHX_ REGEXP * const rx);\n#ifdef USE_ITHREADS\n    void*   (*dupe) (pTHX_ REGEXP * const rx, CLONE_PARAMS *param);\n#endif\n    REGEXP* (*op_comp) (pTHX_ SV ** const patternp, int pat_count,\n\t\t    OP *expr, const struct regexp_engine* eng,\n\t\t    REGEXP *old_re,\n\t\t    bool *is_bare_re, U32 orig_rx_flags, U32 pm_flags);\n}\n- IV: typedef IVTYPE IV;\n- ANY: typedef union any ANY;\n- SV: typedef struct STRUCT_SV SV;\n- REGEXP: typedef struct p5rx REGEXP;\n- U8: typedef U8TYPE U8;\n- regexp: typedef struct regexp {\n    _XPV_HEAD;\n    const struct regexp_engine* engine; /* what engine created this regexp? */\n    REGEXP *mother_re; /* what re is this a lightweight copy of? */\n    HV *paren_names;   /* Optional hash of paren names */\n\n    /*----------------------------------------------------------------------\n     * Information about the match that the perl core uses to manage things\n     */\n\n    U32 extflags;      /* Flags used both externally and internally */\n    SSize_t minlen;    /* minimum possible number of chars in string to match */\n    SSize_t minlenret; /* mininum possible number of chars in $& */\n    STRLEN gofs;       /* chars left of pos that we search from */\n                       /* substring data about strings that must appear in\n                        * the final match, used for optimisations */\n    struct reg_substr_data *substrs;\n    U32 nparens;       /* number of capture buffers */\n\n    /* private engine specific data */\n\n    U32 intflags;      /* Engine Specific Internal flags */\n    void *pprivate;    /* Data private to the regex engine which\n                        * created this object. */\n\n    /*----------------------------------------------------------------------\n     * Data about the last/current match. These are modified during matching\n     */\n\n    U32 lastparen;           /* highest close paren matched ($+) */\n    U32 lastcloseparen;      /* last close paren matched ($^N) */\n    regexp_paren_pair *offs; /* Array of offsets for (@-) and (@+) */\n    char **recurse_locinput; /* used to detect infinite recursion, XXX: move to internal */\n\n    /*---------------------------------------------------------------------- */\n\n    char *subbeg;       /* saved or original string so \\digit works forever. */\n    SV_SAVED_COPY       /* If non-NULL, SV which is COW from original */\n    SSize_t sublen;     /* Length of string pointed by subbeg */\n    SSize_t suboffset;  /* byte offset of subbeg from logical start of str */\n    SSize_t subcoffset; /* suboffset equiv, but in chars (for @-/@+) */\n\n    /* Information about the match that isn't often used */\n\n    SSize_t maxlen;  /* minimum possible number of chars in string to match */\n\n    /*---------------------------------------------------------------------- */\n\n    /* offset from wrapped to the start of precomp */\n    PERL_BITFIELD32 pre_prefix:4;\n\n    /* original flags used to compile the pattern, may differ from\n     * extflags in various ways */\n    PERL_BITFIELD32 compflags:9;\n\n    /*---------------------------------------------------------------------- */\n\n    CV *qr_anoncv;      /* the anon sub wrapped round qr/(?{..})/ */\n}\n- U32: typedef U32TYPE U32;\n- regnode_offset: typedef SSize_t regnode_offset;\n- xpv: struct xpv {\n    _XPV_HEAD;\n}\n- sv: typedef struct STRUCT_SV\n- reg_substr_datum: struct reg_substr_datum {\n    SSize_t min_offset; /* min pos (in chars) that substr must appear */\n    SSize_t max_offset  /* max pos (in chars) that substr must appear */;\n    SV *substr;\t\t/* non-utf8 variant */\n    SV *utf8_substr;\t/* utf8 variant */\n    SSize_t end_shift;  /* how many fixed chars must end the string */\n}\n- OP: typedef struct op OP;\n- STRLEN: typedef MEM_SIZE STRLEN;\n- listop: struct listop {\n    BASEOP\n    OP *\top_first;\n    OP *\top_last;\n}\n- scan_data_t: typedef struct scan_data_t {\n    /*I32 len_min;      unused */\n    /*I32 len_delta;    unused */\n    SSize_t pos_min;\n    SSize_t pos_delta;\n    SV *last_found;\n    SSize_t last_end;\t    /* min value, <0 unless valid. */\n    SSize_t last_start_min;\n    SSize_t last_start_max;\n    U8      cur_is_floating; /* whether the last_* values should be set as\n                              * the next fixed (0) or floating (1)\n                              * substring */\n\n    /* [0] is longest fixed substring so far, [1] is longest float so far */\n    struct scan_data_substrs  substrs[2];\n\n    I32 flags;             /* common SF_* and SCF_* flags */\n    I32 whilem_c;\n    SSize_t *last_closep;\n    regnode_ssc *start_class;\n} scan_data_t;\n- regnode: struct regnode {\n    U8\tflags;\n    U8  type;\n    U16 next_off;\n}\n- I32: typedef I32TYPE I32;\n- reg_substr_data: struct reg_substr_data {\n    U8      check_ix;   /* index into data[] of check substr */\n    struct reg_substr_datum data[3];\t/* Actual array */\n}\n\nGlobal Variables:\n- const scan_data_t zero_scan_data\n\nImports:\n- #include \"perl.h\"\n- #include \"dquote_inline.h\"\n- #  include \"regcomp.h\"\n- #include \"EXTERN.h\"\n- #include \"re_top.h\"\n- #include \"unicode_constants.h\"\n- #include \"invlist_inline.h\"\n- #  include \"re_comp.h\"\n- #include \"uni_keywords.h\"",
    "commit_msg": "regcomp: use long jumps if there is any possibility of overflow\n\n(CVE-2020-10878) Be conservative for backporting, we'll aim to do\nsomething more aggressive for bleadperl.\n\n(cherry picked from commit 9d7759db46f3b31b1d3f79c44266b6ba42a47fc6)",
    "cve_desc": "Perl before 5.30.3 has an integer overflow related to mishandling of a \"PL_regkind[OP(n)] == NOTHING\" situation. A crafted regular expression could lead to malformed bytecode with a possibility of instruction injection.",
    "year": 2020,
    "filename": "regcomp.c",
    "commit_url": "\"https://github.com/perl/perl5/commit/3295b48defa0f8570114877b063fe546dd348b3c\""
  },
  {
    "repository": "git/git",
    "cve_id": "CVE-2020-11008",
    "cwe_list": [
      "CWE-522"
    ],
    "commit_hash": "c44088ecc4b0722636e0a305f9608d3047197282",
    "short_hash": "c44088ec",
    "vulnerableMethods_before": [
      {
        "filename": "credential.c",
        "method_name": "credential_from_url_gently",
        "raw_code": "int credential_from_url_gently(struct credential *c, const char *url, /* <=== credential_from_url_gently */ \n\t\t\t       int quiet)\n{\n\tconst char *at, *colon, *cp, *slash, *host, *proto_end;\n\n\tcredential_clear(c);\n\n\t/*\n\t * Match one of:\n\t *   (1) proto://<host>/...\n\t *   (2) proto://<user>@<host>/...\n\t *   (3) proto://<user>:<pass>@<host>/...\n\t */\n\tproto_end = strstr(url, \"://\");\n\tif (!proto_end)\n\t\treturn 0;\n\tcp = proto_end + 3;\n\tat = strchr(cp, '@');\n\tcolon = strchr(cp, ':');\n\tslash = strchrnul(cp, '/');\n\n\tif (!at || slash <= at) {\n\t\t/* Case (1) */\n\t\thost = cp;\n\t}\n\telse if (!colon || at <= colon) {\n\t\t/* Case (2) */\n\t\tc->username = url_decode_mem(cp, at - cp);\n\t\thost = at + 1;\n\t} else {\n\t\t/* Case (3) */\n\t\tc->username = url_decode_mem(cp, colon - cp);\n\t\tc->password = url_decode_mem(colon + 1, at - (colon + 1));\n\t\thost = at + 1;\n\t}\n\n\tif (proto_end - url > 0)\n\t\tc->protocol = xmemdupz(url, proto_end - url);\n\tc->host = url_decode_mem(host, slash - host);\n\t/* Trim leading and trailing slashes from path */\n\twhile (*slash == '/')\n\t\tslash++;\n\tif (*slash) {\n\t\tchar *p;\n\t\tc->path = url_decode(slash);\n\t\tp = c->path + strlen(c->path) - 1;\n\t\twhile (p > c->path && *p == '/')\n\t\t\t*p-- = '\\0';\n\t}\n\n\tif (check_url_component(url, quiet, \"username\", c->username) < 0 ||\n\t    check_url_component(url, quiet, \"password\", c->password) < 0 ||\n\t    check_url_component(url, quiet, \"protocol\", c->protocol) < 0 ||\n\t    check_url_component(url, quiet, \"host\", c->host) < 0 ||\n\t    check_url_component(url, quiet, \"path\", c->path) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}",
        "start_line": 346
      },
      {
        "filename": "fsck.c",
        "method_name": "check_submodule_url",
        "raw_code": "static int check_submodule_url(const char *url) /* <=== check_submodule_url */ \n{\n\tconst char *curl_url;\n\n\tif (looks_like_command_line_option(url))\n\t\treturn -1;\n\n\tif (submodule_url_is_relative(url)) {\n\t\t/*\n\t\t * This could be appended to an http URL and url-decoded;\n\t\t * check for malicious characters.\n\t\t */\n\t\tchar *decoded = url_decode(url);\n\t\tint has_nl = !!strchr(decoded, '\\n');\n\t\tfree(decoded);\n\t\tif (has_nl)\n\t\t\treturn -1;\n\t}\n\n\telse if (url_to_curl_url(url, &curl_url)) {\n\t\tstruct credential c = CREDENTIAL_INIT;\n\t\tint ret = credential_from_url_gently(&c, curl_url, 1);\n\t\tcredential_clear(&c);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
        "start_line": 1013
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "credential.c",
        "method_name": "credential_from_url_gently",
        "raw_code": "int credential_from_url_gently(struct credential *c, const char *url, /* <=== credential_from_url_gently */ \n\t\t\t       int quiet)\n{\n\tconst char *at, *colon, *cp, *slash, *host, *proto_end;\n\n\tcredential_clear(c);\n\n\t/*\n\t * Match one of:\n\t *   (1) proto://<host>/...\n\t *   (2) proto://<user>@<host>/...\n\t *   (3) proto://<user>:<pass>@<host>/...\n\t */\n\tproto_end = strstr(url, \"://\");\n\tif (!proto_end) {\n\t\tif (!quiet)\n\t\t\twarning(_(\"url has no scheme: %s\"), url);\n\t\treturn -1;\n\t}\n\tcp = proto_end + 3;\n\tat = strchr(cp, '@');\n\tcolon = strchr(cp, ':');\n\tslash = strchrnul(cp, '/');\n\n\tif (!at || slash <= at) {\n\t\t/* Case (1) */\n\t\thost = cp;\n\t}\n\telse if (!colon || at <= colon) {\n\t\t/* Case (2) */\n\t\tc->username = url_decode_mem(cp, at - cp);\n\t\thost = at + 1;\n\t} else {\n\t\t/* Case (3) */\n\t\tc->username = url_decode_mem(cp, colon - cp);\n\t\tc->password = url_decode_mem(colon + 1, at - (colon + 1));\n\t\thost = at + 1;\n\t}\n\n\tif (proto_end - url > 0)\n\t\tc->protocol = xmemdupz(url, proto_end - url);\n\tc->host = url_decode_mem(host, slash - host);\n\t/* Trim leading and trailing slashes from path */\n\twhile (*slash == '/')\n\t\tslash++;\n\tif (*slash) {\n\t\tchar *p;\n\t\tc->path = url_decode(slash);\n\t\tp = c->path + strlen(c->path) - 1;\n\t\twhile (p > c->path && *p == '/')\n\t\t\t*p-- = '\\0';\n\t}\n\n\tif (check_url_component(url, quiet, \"username\", c->username) < 0 ||\n\t    check_url_component(url, quiet, \"password\", c->password) < 0 ||\n\t    check_url_component(url, quiet, \"protocol\", c->protocol) < 0 ||\n\t    check_url_component(url, quiet, \"host\", c->host) < 0 ||\n\t    check_url_component(url, quiet, \"path\", c->path) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}",
        "start_line": 346
      },
      {
        "filename": "fsck.c",
        "method_name": "count_leading_dotdots",
        "raw_code": "static int count_leading_dotdots(const char *url, const char **out) /* <=== count_leading_dotdots */ \n{\n\tint result = 0;\n\twhile (1) {\n\t\tif (starts_with_dot_dot_slash(url)) {\n\t\t\tresult++;\n\t\t\turl += strlen(\"../\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (starts_with_dot_slash(url)) {\n\t\t\turl += strlen(\"./\");\n\t\t\tcontinue;\n\t\t}\n\t\t*out = url;\n\t\treturn result;\n\t}\n}",
        "start_line": 985
      },
      {
        "filename": "fsck.c",
        "method_name": "check_submodule_url",
        "raw_code": "static int check_submodule_url(const char *url) /* <=== check_submodule_url */ \n{\n\tconst char *curl_url;\n\n\tif (looks_like_command_line_option(url))\n\t\treturn -1;\n\n\tif (submodule_url_is_relative(url)) {\n\t\tchar *decoded;\n\t\tconst char *next;\n\t\tint has_nl;\n\n\t\t/*\n\t\t * This could be appended to an http URL and url-decoded;\n\t\t * check for malicious characters.\n\t\t */\n\t\tdecoded = url_decode(url);\n\t\thas_nl = !!strchr(decoded, '\\n');\n\n\t\tfree(decoded);\n\t\tif (has_nl)\n\t\t\treturn -1;\n\n\t\t/*\n\t\t * URLs which escape their root via \"../\" can overwrite\n\t\t * the host field and previous components, resolving to\n\t\t * URLs like https::example.com/submodule.git that were\n\t\t * susceptible to CVE-2020-11008.\n\t\t */\n\t\tif (count_leading_dotdots(url, &next) > 0 &&\n\t\t    *next == ':')\n\t\t\treturn -1;\n\t}\n\n\telse if (url_to_curl_url(url, &curl_url)) {\n\t\tstruct credential c = CREDENTIAL_INIT;\n\t\tint ret = credential_from_url_gently(&c, curl_url, 1);\n\t\tcredential_clear(&c);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
        "start_line": 1041
      }
    ],
    "code_context": "Called Methods:\n- starts_with_dot_dot_slash: static int starts_with_dot_dot_slash(const char *str) /* <=== starts_with_dot_dot_slash */ \n{\n\treturn str[0] == '.' && str[1] == '.' && is_dir_sep(str[2]);\n}\n- url_decode: char *url_decode(const char *url) /* <=== url_decode */ \n{\n\treturn url_decode_mem(url, strlen(url));\n}\n- warning: extern void warning(const char *err, ...) __attribute__((format (printf, 1, 2))); /* <=== warning */ \n- url_decode_mem: char *url_decode_mem(const char *url, int len) /* <=== url_decode_mem */ \n{\n\tstruct strbuf out = STRBUF_INIT;\n\tconst char *colon = memchr(url, ':', len);\n\n\t/* Skip protocol part if present */\n\tif (colon && url < colon) {\n\t\tstrbuf_add(&out, url, colon - url);\n\t\tlen -= colon - url;\n\t\turl = colon;\n\t}\n\treturn url_decode_internal(&url, len, NULL, &out, 0);\n}\n- _: static inline FORMAT_PRESERVING(1) const char *_(const char *msgid) /* <=== _ */ \n{\n\tif (!*msgid)\n\t\treturn \"\";\n\treturn use_gettext_poison() ? \"# GETTEXT POISON #\" : gettext(msgid);\n}\n- submodule_url_is_relative: static int submodule_url_is_relative(const char *url) /* <=== submodule_url_is_relative */ \n{\n\treturn starts_with_dot_slash(url) || starts_with_dot_dot_slash(url);\n}\n- warning: extern void warning(const char *err, ...) __attribute__((format (printf, 1, 2))); /* <=== warning */ \n- check_url_component: static int check_url_component(const char *url, int quiet, /* <=== check_url_component */ \n\t\t\t       const char *name, const char *value)\n{\n\tif (!value)\n\t\treturn 0;\n\tif (!strchr(value, '\\n'))\n\t\treturn 0;\n\n\tif (!quiet)\n\t\twarning(_(\"url contains a newline in its %s component: %s\"),\n\t\t\tname, url);\n\treturn -1;\n}\n- strbuf_add: void strbuf_add(struct strbuf *sb, const void *data, size_t len) /* <=== strbuf_add */ \n{\n\tstrbuf_grow(sb, len);\n\tmemcpy(sb->buf + sb->len, data, len);\n\tstrbuf_setlen(sb, sb->len + len);\n}\n- strchrnul: #define strchrnul gitstrchrnul /* <=== git-compat-util.h:757:757:strchrnul:0 */ \n- xmemdupz: extern void *xmemdupz(const void *data, size_t len); /* <=== xmemdupz */ \n- starts_with_dot_dot_slash: static int starts_with_dot_dot_slash(const char *str) /* <=== starts_with_dot_dot_slash */ \n{\n\treturn str[0] == '.' && starts_with_dot_slash(str + 1);\n}\n- starts_with_dot_dot_slash: static int starts_with_dot_dot_slash(const char *str) /* <=== starts_with_dot_dot_slash */ \n{\n\treturn str[0] == '.' && starts_with_dot_slash(str + 1);\n}\n- starts_with_dot_slash: static int starts_with_dot_slash(const char *str) /* <=== starts_with_dot_slash */ \n{\n\treturn str[0] == '.' && is_dir_sep(str[1]);\n}\n- starts_with_dot_slash: static int starts_with_dot_slash(const char *str) /* <=== starts_with_dot_slash */ \n{\n\treturn str[0] == '.' && (str[1] == '/' || str[1] == '\\\\');\n}\n- looks_like_command_line_option: int looks_like_command_line_option(const char *str) /* <=== looks_like_command_line_option */ \n{\n\treturn str && str[0] == '-';\n}\n- url_decode_mem: char *url_decode_mem(const char *url, int len) /* <=== url_decode_mem */ \n{\n\tstruct strbuf out = STRBUF_INIT;\n\tconst char *colon = memchr(url, ':', len);\n\n\t/* Skip protocol part if present */\n\tif (colon && url < colon) {\n\t\tstrbuf_add(&out, url, colon - url);\n\t\tlen -= colon - url;\n\t\turl = colon;\n\t}\n\treturn url_decode_internal(&url, len, NULL, &out, 0);\n}\n- _: static inline FORMAT_PRESERVING(1) const char *_(const char *msgid) /* <=== _ */ \n{\n\tif (!*msgid)\n\t\treturn \"\";\n\treturn use_gettext_poison() ? \"# GETTEXT POISON #\" : gettext(msgid);\n}\n- use_gettext_poison: #define use_gettext_poison() 0 /* <=== gettext.h:47:47:use_gettext_poison:0 */ \n- is_dir_sep: #define is_dir_sep git_is_dir_sep /* <=== git-compat-util.h:362:362:is_dir_sep:0 */ \n- gitstrchrnul: static inline char *gitstrchrnul(const char *s, int c) /* <=== gitstrchrnul */ \n{\n\twhile (*s && *s != c)\n\t\ts++;\n\treturn (char *)s;\n}\n- url_decode_internal: static char *url_decode_internal(const char **query, int len, /* <=== url_decode_internal */ \n\t\t\t\t const char *stop_at, struct strbuf *out,\n\t\t\t\t int decode_plus)\n{\n\tconst char *q = *query;\n\n\twhile (len) {\n\t\tunsigned char c = *q;\n\n\t\tif (!c)\n\t\t\tbreak;\n\t\tif (stop_at && strchr(stop_at, c)) {\n\t\t\tq++;\n\t\t\tlen--;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (c == '%') {\n\t\t\tint val = hex2chr(q + 1);\n\t\t\tif (0 <= val) {\n\t\t\t\tstrbuf_addch(out, val);\n\t\t\t\tq += 3;\n\t\t\t\tlen -= 3;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (decode_plus && c == '+')\n\t\t\tstrbuf_addch(out, ' ');\n\t\telse\n\t\t\tstrbuf_addch(out, c);\n\t\tq++;\n\t\tlen--;\n\t}\n\t*query = q;\n\treturn strbuf_detach(out, NULL);\n}\n- git_is_dir_sep: static inline int git_is_dir_sep(int c) /* <=== git_is_dir_sep */ \n{\n\treturn c == '/';\n}\n- starts_with_dot_slash: static int starts_with_dot_slash(const char *str) /* <=== starts_with_dot_slash */ \n{\n\treturn str[0] == '.' && (str[1] == '/' || str[1] == '\\\\');\n}\n\nType Definitions:\n- credential: struct credential {\n\tstruct string_list helpers;\n\tunsigned approved:1,\n\t\t configured:1,\n\t\t quit:1,\n\t\t use_http_path:1;\n\n\tchar *username;\n\tchar *password;\n\tchar *protocol;\n\tchar *host;\n\tchar *path;\n}\n\nImports:\n- #include \"refs.h\"\n- #include \"cache.h\"\n- #include \"sha1-array.h\"\n- #include \"config.h\"\n- #include \"tag.h\"\n- #include \"url.h\"\n- #include \"credential.h\"\n- #include \"prompt.h\"\n- #include \"string-list.h\"\n- #include \"commit.h\"\n- #include \"blob.h\"\n- #include \"tree.h\"\n- #include \"run-command.h\"\n- #include \"utf8.h\"\n- #include \"object.h\"\n- #include \"decorate.h\"\n- #include \"packfile.h\"\n- #include \"submodule-config.h\"\n- #include \"oidset.h\"\n- #include \"tree-walk.h\"\n- #include \"fsck.h\"",
    "commit_msg": "credential: treat URL without scheme as invalid\n\nlibcurl permits making requests without a URL scheme specified.  In\nthis case, it guesses the URL from the hostname, so I can run\n\n\tgit ls-remote http::ftp.example.com/path/to/repo\n\nand it would make an FTP request.\n\nAny user intentionally using such a URL is likely to have made a typo.\nUnfortunately, credential_from_url is not able to determine the host and\nprotocol in order to determine appropriate credentials to send, and\nuntil \"credential: refuse to operate when missing host or protocol\",\nthis resulted in another host's credentials being leaked to the named\nhost.\n\nTeach credential_from_url_gently to consider such a URL to be invalid\nso that fsck can detect and block gitmodules files with such URLs,\nallowing server operators to avoid serving them to downstream users\nrunning older versions of Git.\n\nThis also means that when such URLs are passed on the command line, Git\nwill print a clearer error so affected users can switch to the simpler\nURL that explicitly specifies the host and protocol they intend.\n\nOne subtlety: .gitmodules files can contain relative URLs, representing\na URL relative to the URL they were cloned from.  The relative URL\nresolver used for .gitmodules can follow \"..\" components out of the path\npart and past the host part of a URL, meaning that such a relative URL\ncan be used to traverse from a https://foo.example.com/innocent\nsuperproject to a https::attacker.example.com/exploit submodule.\nFortunately a leading ':' in the first path component after a series of\nleading './' and '../' components is unlikely to show up in other\ncontexts, so we can catch this by detecting that pattern.\n\nReported-by: Jeff King <peff@peff.net>\nSigned-off-by: Jonathan Nieder <jrnieder@gmail.com>\nReviewed-by: Jeff King <peff@peff.net>",
    "cve_desc": "Affected versions of Git have a vulnerability whereby Git can be tricked into sending private credentials to a host controlled by an attacker. This bug is similar to CVE-2020-5260(GHSA-qm7j-c969-7j4q). The fix for that bug still left the door open for an exploit where _some_ credential is leaked (but the attacker cannot control which one). Git uses external \"credential helper\" programs to store and retrieve passwords or other credentials from secure storage provided by the operating system. Specially-crafted URLs that are considered illegal as of the recently published Git versions can cause Git to send a \"blank\" pattern to helpers, missing hostname and protocol fields. Many helpers will interpret this as matching _any_ URL, and will return some unspecified stored password, leaking the password to an attacker's server. The vulnerability can be triggered by feeding a malicious URL to `git clone`. However, the affected URLs look rather suspicious; the likely vector would be through systems which automatically clone URLs not visible to the user, such as Git submodules, or package systems built around Git. The root of the problem is in Git itself, which should not be feeding blank input to helpers. However, the ability to exploit the vulnerability in practice depends on which helpers are in use. Credential helpers which are known to trigger the vulnerability: - Git's \"store\" helper - Git's \"cache\" helper - the \"osxkeychain\" helper that ships in Git's \"contrib\" directory Credential helpers which are known to be safe even with vulnerable versions of Git: - Git Credential Manager for Windows Any helper not in this list should be assumed to trigger the vulnerability.",
    "year": 2020,
    "filename": "",
    "commit_url": "https://github.com/git/git/commit/c44088ecc4b0722636e0a305f9608d3047197282"
  },
  {
    "repository": "FreeRDP/FreeRDP",
    "cve_id": "CVE-2020-11019",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "0332cad015fdf7fac7e5c6863484f18a554e0fcf",
    "short_hash": "0332cad0",
    "vulnerableMethods_before": [
      {
        "filename": "libfreerdp/core/update.c",
        "method_name": "update_recv",
        "raw_code": "BOOL update_recv(rdpUpdate* update, wStream* s) /* <=== update_recv */ \n{\n\tBOOL rc = FALSE;\n\tUINT16 updateType;\n\trdpContext* context = update->context;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 2\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, updateType); /* updateType (2 bytes) */\n\tWLog_Print(update->log, WLOG_TRACE, \"%s Update Data PDU\", UPDATE_TYPE_STRINGS[updateType]);\n\n\tif (!update_begin_paint(update))\n\t\tgoto fail;\n\n\tswitch (updateType)\n\t{\n\t\tcase UPDATE_TYPE_ORDERS:\n\t\t\trc = update_recv_orders(update, s);\n\t\t\tbreak;\n\n\t\tcase UPDATE_TYPE_BITMAP:\n\t\t{\n\t\t\tBITMAP_UPDATE* bitmap_update = update_read_bitmap_update(update, s);\n\n\t\t\tif (!bitmap_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_BITMAP - update_read_bitmap_update() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\trc = IFCALLRESULT(FALSE, update->BitmapUpdate, context, bitmap_update);\n\t\t\tfree_bitmap_update(update->context, bitmap_update);\n\t\t}\n\t\tbreak;\n\n\t\tcase UPDATE_TYPE_PALETTE:\n\t\t{\n\t\t\tPALETTE_UPDATE* palette_update = update_read_palette(update, s);\n\n\t\t\tif (!palette_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_PALETTE - update_read_palette() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\trc = IFCALLRESULT(FALSE, update->Palette, context, palette_update);\n\t\t\tfree_palette_update(context, palette_update);\n\t\t}\n\t\tbreak;\n\n\t\tcase UPDATE_TYPE_SYNCHRONIZE:\n\t\t\tif (!update_read_synchronize(update, s))\n\t\t\t\tgoto fail;\n\t\t\trc = IFCALLRESULT(TRUE, update->Synchronize, context);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\nfail:\n\n\tif (!update_end_paint(update))\n\t\trc = FALSE;\n\n\tif (!rc)\n\t{\n\t\tWLog_ERR(TAG, \"UPDATE_TYPE %s [%\" PRIu16 \"] failed\", update_type_to_string(updateType),\n\t\t         updateType);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}",
        "start_line": 764
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "libfreerdp/core/update.c",
        "method_name": "update_recv",
        "raw_code": "BOOL update_recv(rdpUpdate* update, wStream* s) /* <=== update_recv */ \n{\n\tBOOL rc = FALSE;\n\tUINT16 updateType;\n\trdpContext* context = update->context;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 2\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, updateType); /* updateType (2 bytes) */\n\tWLog_Print(update->log, WLOG_TRACE, \"%s Update Data PDU\", update_type_to_string(updateType));\n\n\tif (!update_begin_paint(update))\n\t\tgoto fail;\n\n\tswitch (updateType)\n\t{\n\t\tcase UPDATE_TYPE_ORDERS:\n\t\t\trc = update_recv_orders(update, s);\n\t\t\tbreak;\n\n\t\tcase UPDATE_TYPE_BITMAP:\n\t\t{\n\t\t\tBITMAP_UPDATE* bitmap_update = update_read_bitmap_update(update, s);\n\n\t\t\tif (!bitmap_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_BITMAP - update_read_bitmap_update() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\trc = IFCALLRESULT(FALSE, update->BitmapUpdate, context, bitmap_update);\n\t\t\tfree_bitmap_update(update->context, bitmap_update);\n\t\t}\n\t\tbreak;\n\n\t\tcase UPDATE_TYPE_PALETTE:\n\t\t{\n\t\t\tPALETTE_UPDATE* palette_update = update_read_palette(update, s);\n\n\t\t\tif (!palette_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_PALETTE - update_read_palette() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\trc = IFCALLRESULT(FALSE, update->Palette, context, palette_update);\n\t\t\tfree_palette_update(context, palette_update);\n\t\t}\n\t\tbreak;\n\n\t\tcase UPDATE_TYPE_SYNCHRONIZE:\n\t\t\tif (!update_read_synchronize(update, s))\n\t\t\t\tgoto fail;\n\t\t\trc = IFCALLRESULT(TRUE, update->Synchronize, context);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\nfail:\n\n\tif (!update_end_paint(update))\n\t\trc = FALSE;\n\n\tif (!rc)\n\t{\n\t\tWLog_ERR(TAG, \"UPDATE_TYPE %s [%\" PRIu16 \"] failed\", update_type_to_string(updateType),\n\t\t         updateType);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}",
        "start_line": 764
      }
    ],
    "code_context": "Called Methods:\n- update_read_synchronize: static BOOL update_read_synchronize(rdpUpdate* update, wStream* s) /* <=== update_read_synchronize */ \n{\n\tWINPR_UNUSED(update);\n\treturn Stream_SafeSeek(s, 2); /* pad2Octets (2 bytes) */\n\t                              /**\n\t                               * The Synchronize Update is an artifact from the\n\t                               * T.128 protocol and should be ignored.\n\t                               */\n}\n- update_read_bitmap_data: static BOOL update_read_bitmap_data(rdpUpdate* update, wStream* s, BITMAP_DATA* bitmapData) /* <=== update_read_bitmap_data */ \n{\n\tWINPR_UNUSED(update);\n\tif (Stream_GetRemainingLength(s) < 18)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, bitmapData->destLeft);\n\tStream_Read_UINT16(s, bitmapData->destTop);\n\tStream_Read_UINT16(s, bitmapData->destRight);\n\tStream_Read_UINT16(s, bitmapData->destBottom);\n\tStream_Read_UINT16(s, bitmapData->width);\n\tStream_Read_UINT16(s, bitmapData->height);\n\tStream_Read_UINT16(s, bitmapData->bitsPerPixel);\n\tStream_Read_UINT16(s, bitmapData->flags);\n\tStream_Read_UINT16(s, bitmapData->bitmapLength);\n\n\tif (bitmapData->flags & BITMAP_COMPRESSION)\n\t{\n\t\tif (!(bitmapData->flags & NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\t\treturn FALSE;\n\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbCompFirstRowSize); /* cbCompFirstRowSize (2 bytes) */\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbCompMainBodySize); /* cbCompMainBodySize (2 bytes) */\n\t\t\tStream_Read_UINT16(s, bitmapData->cbScanWidth);     /* cbScanWidth (2 bytes) */\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbUncompressedSize); /* cbUncompressedSize (2 bytes) */\n\t\t\tbitmapData->bitmapLength = bitmapData->cbCompMainBodySize;\n\t\t}\n\n\t\tbitmapData->compressed = TRUE;\n\t}\n\telse\n\t\tbitmapData->compressed = FALSE;\n\n\tif (Stream_GetRemainingLength(s) < bitmapData->bitmapLength)\n\t\treturn FALSE;\n\n\tif (bitmapData->bitmapLength > 0)\n\t{\n\t\tbitmapData->bitmapDataStream = malloc(bitmapData->bitmapLength);\n\n\t\tif (!bitmapData->bitmapDataStream)\n\t\t\treturn FALSE;\n\n\t\tmemcpy(bitmapData->bitmapDataStream, Stream_Pointer(s), bitmapData->bitmapLength);\n\t\tStream_Seek(s, bitmapData->bitmapLength);\n\t}\n\n\treturn TRUE;\n}\n- free_bitmap_data: static void free_bitmap_data(BITMAP_DATA* data, size_t count) /* <=== free_bitmap_data */ \n{\n\tsize_t x;\n\n\tif (!data)\n\t\treturn;\n\n\tfor (x = 0; x < count; x++)\n\t\tfree(data[x].bitmapDataStream);\n\n\tfree(data);\n}\n- free_bitmap_update: void free_bitmap_update(rdpContext* context, BITMAP_UPDATE* pointer) /* <=== free_bitmap_update */ \n{\n\tif (!pointer)\n\t\treturn;\n\n\tfree_bitmap_data(pointer->rectangles, pointer->number);\n\tfree(pointer);\n}\n- update_type_to_string: static const char* update_type_to_string(UINT16 updateType) /* <=== update_type_to_string */ \n{\n\tif (updateType >= ARRAYSIZE(UPDATE_TYPE_STRINGS))\n\t\treturn \"UNKNOWN\";\n\n\treturn UPDATE_TYPE_STRINGS[updateType];\n}\n- free_palette_update: void free_palette_update(rdpContext* context, PALETTE_UPDATE* pointer) /* <=== free_palette_update */ \n{\n\tfree(pointer);\n}\n- LeaveCriticalSection: \tWINPR_API VOID LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection); /* <=== LeaveCriticalSection */ \n- TAG: #define TAG FREERDP_TAG(\"core.update\") /* <=== libfreerdp/core/update.c:46:46:TAG:0 */ \n- update_end_paint: BOOL update_end_paint(rdpUpdate* update) /* <=== update_end_paint */ \n{\n\tBOOL rc = FALSE;\n\n\tif (!update)\n\t\treturn FALSE;\n\n\tif (update->EndPaint)\n\t\trc = update->EndPaint(update->context);\n\n\tLeaveCriticalSection(&update->mux);\n\treturn rc;\n}\n- update_read_palette: PALETTE_UPDATE* update_read_palette(rdpUpdate* update, wStream* s) /* <=== update_read_palette */ \n{\n\tint i;\n\tPALETTE_ENTRY* entry;\n\tPALETTE_UPDATE* palette_update = calloc(1, sizeof(PALETTE_UPDATE));\n\n\tif (!palette_update)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 6)\n\t\tgoto fail;\n\n\tStream_Seek_UINT16(s);                         /* pad2Octets (2 bytes) */\n\tStream_Read_UINT32(s, palette_update->number); /* numberColors (4 bytes), must be set to 256 */\n\n\tif (palette_update->number > 256)\n\t\tpalette_update->number = 256;\n\n\tif (Stream_GetRemainingLength(s) < palette_update->number * 3)\n\t\tgoto fail;\n\n\t/* paletteEntries */\n\tfor (i = 0; i < (int)palette_update->number; i++)\n\t{\n\t\tentry = &palette_update->entries[i];\n\t\tStream_Read_UINT8(s, entry->red);\n\t\tStream_Read_UINT8(s, entry->green);\n\t\tStream_Read_UINT8(s, entry->blue);\n\t}\n\n\treturn palette_update;\nfail:\n\tfree_palette_update(update->context, palette_update);\n\treturn NULL;\n}\n- EnterCriticalSection: \tWINPR_API VOID EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection); /* <=== EnterCriticalSection */ \n- UPDATE_TYPE_BITMAP: #define UPDATE_TYPE_BITMAP 0x0001 /* <=== libfreerdp/core/update.h:34:34:UPDATE_TYPE_BITMAP:0 */ \n- update_read_bitmap_update: BITMAP_UPDATE* update_read_bitmap_update(rdpUpdate* update, wStream* s) /* <=== update_read_bitmap_update */ \n{\n\tUINT32 i;\n\tBITMAP_UPDATE* bitmapUpdate = calloc(1, sizeof(BITMAP_UPDATE));\n\n\tif (!bitmapUpdate)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, bitmapUpdate->number); /* numberRectangles (2 bytes) */\n\tWLog_Print(update->log, WLOG_TRACE, \"BitmapUpdate: %\" PRIu32 \"\", bitmapUpdate->number);\n\n\tif (bitmapUpdate->number > bitmapUpdate->count)\n\t{\n\t\tUINT32 count = bitmapUpdate->number * 2;\n\t\tBITMAP_DATA* newdata =\n\t\t    (BITMAP_DATA*)realloc(bitmapUpdate->rectangles, sizeof(BITMAP_DATA) * count);\n\n\t\tif (!newdata)\n\t\t\tgoto fail;\n\n\t\tbitmapUpdate->rectangles = newdata;\n\t\tZeroMemory(&bitmapUpdate->rectangles[bitmapUpdate->count],\n\t\t           sizeof(BITMAP_DATA) * (count - bitmapUpdate->count));\n\t\tbitmapUpdate->count = count;\n\t}\n\n\t/* rectangles */\n\tfor (i = 0; i < bitmapUpdate->number; i++)\n\t{\n\t\tif (!update_read_bitmap_data(update, s, &bitmapUpdate->rectangles[i]))\n\t\t\tgoto fail;\n\t}\n\n\treturn bitmapUpdate;\nfail:\n\tfree_bitmap_update(update->context, bitmapUpdate);\n\treturn NULL;\n}\n- update_recv_orders: static BOOL update_recv_orders(rdpUpdate* update, wStream* s) /* <=== update_recv_orders */ \n{\n\tUINT16 numberOrders;\n\n\tif (Stream_GetRemainingLength(s) < 6)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 6\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Seek_UINT16(s);               /* pad2OctetsA (2 bytes) */\n\tStream_Read_UINT16(s, numberOrders); /* numberOrders (2 bytes) */\n\tStream_Seek_UINT16(s);               /* pad2OctetsB (2 bytes) */\n\n\twhile (numberOrders > 0)\n\t{\n\t\tif (!update_recv_order(update, s))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"update_recv_order() failed\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tnumberOrders--;\n\t}\n\n\treturn TRUE;\n}\n- UPDATE_TYPE_ORDERS: #define UPDATE_TYPE_ORDERS 0x0000 /* <=== libfreerdp/core/update.h:33:33:UPDATE_TYPE_ORDERS:0 */ \n- update_recv_order: BOOL update_recv_order(rdpUpdate* update, wStream* s) /* <=== update_recv_order */ \n{\n\tBOOL rc;\n\tBYTE controlFlags;\n\n\tif (Stream_GetRemainingLength(s) < 1)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream_GetRemainingLength(s) < 1\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT8(s, controlFlags); /* controlFlags (1 byte) */\n\n\tif (!(controlFlags & ORDER_STANDARD))\n\t\trc = update_recv_altsec_order(update, s, controlFlags);\n\telse if (controlFlags & ORDER_SECONDARY)\n\t\trc = update_recv_secondary_order(update, s, controlFlags);\n\telse\n\t\trc = update_recv_primary_order(update, s, controlFlags);\n\n\tif (!rc)\n\t\tWLog_Print(update->log, WLOG_ERROR, \"order flags %02\" PRIx8 \" failed\", controlFlags);\n\n\treturn rc;\n}\n- UPDATE_TYPE_PALETTE: #define UPDATE_TYPE_PALETTE 0x0002 /* <=== libfreerdp/core/update.h:35:35:UPDATE_TYPE_PALETTE:0 */ \n- update_begin_paint: BOOL update_begin_paint(rdpUpdate* update) /* <=== update_begin_paint */ \n{\n\tif (!update)\n\t\treturn FALSE;\n\n\tEnterCriticalSection(&update->mux);\n\n\tif (!update->BeginPaint)\n\t\treturn TRUE;\n\n\treturn update->BeginPaint(update->context);\n}\n- UPDATE_TYPE_SYNCHRONIZE: #define UPDATE_TYPE_SYNCHRONIZE 0x0003 /* <=== libfreerdp/core/update.h:36:36:UPDATE_TYPE_SYNCHRONIZE:0 */ \n\nType Definitions:\n- rdpContext: typedef struct rdp_context rdpContext;\n- PALETTE_UPDATE: typedef struct _PALETTE_UPDATE PALETTE_UPDATE;\n- wStream: typedef struct _wStream wStream;\n- BITMAP_UPDATE: typedef struct _BITMAP_UPDATE BITMAP_UPDATE;\n- rdpUpdate: typedef struct rdp_update rdpUpdate;\n\nGlobal Variables:\n- static const char * const[] UPDATE_TYPE_STRINGS\n\nImports:\n- #include \"message.h\"\n- #include \"window.h\"\n- #include <winpr/collections.h>\n- #include <winpr/print.h>\n- #include <winpr/synch.h>\n- #include \"surface.h\"\n- #include <winpr/thread.h>\n- #include <freerdp/codec/bitmap.h>\n- #include <freerdp/peer.h>\n- #include \"../cache/pointer.h\"\n- #include \"update.h\"\n- #include \"config.h\"\n- #include <freerdp/log.h>\n- #include \"info.h\"\n- #include \"../cache/palette.h\"\n- #include \"../cache/bitmap.h\"\n- #include <winpr/crt.h>",
    "commit_msg": "Fixed oob read in update_recv\n\nproperly use update_type_to_string to print update type.\nThanks to hac425 CVE-2020-11019",
    "cve_desc": "In FreeRDP less than or equal to 2.0.0, when running with logger set to \"WLOG_TRACE\", a possible crash of application could occur due to a read of an invalid array index. Data could be printed as string to local terminal. This has been fixed in 2.1.0.",
    "year": 2020,
    "filename": "update.c",
    "commit_url": "\"https://github.com/FreeRDP/FreeRDP/commit/0332cad015fdf7fac7e5c6863484f18a554e0fcf\""
  },
  {
    "repository": "FreeRDP/FreeRDP",
    "cve_id": "CVE-2020-11038",
    "cwe_list": [
      "CWE-190"
    ],
    "commit_hash": "06c32f170093a6ecde93e3bc07fed6a706bfbeb3",
    "short_hash": "06c32f17",
    "vulnerableMethods_before": [
      {
        "filename": "channels/video/client/video_main.c",
        "method_name": "PresentationContext_new",
        "raw_code": "static PresentationContext* PresentationContext_new(VideoClientContext* video, BYTE PresentationId, /* <=== PresentationContext_new */ \n                                                    UINT32 x, UINT32 y, UINT32 width, UINT32 height)\n{\n\tVideoClientContextPriv* priv = video->priv;\n\tPresentationContext* ret = calloc(1, sizeof(*ret));\n\tif (!ret)\n\t\treturn NULL;\n\n\tret->video = video;\n\tret->PresentationId = PresentationId;\n\n\tret->h264 = h264_context_new(FALSE);\n\tif (!ret->h264)\n\t{\n\t\tWLog_ERR(TAG, \"unable to create a h264 context\");\n\t\tgoto error_h264;\n\t}\n\th264_context_reset(ret->h264, width, height);\n\n\tret->currentSample = Stream_New(NULL, 4096);\n\tif (!ret->currentSample)\n\t{\n\t\tWLog_ERR(TAG, \"unable to create current packet stream\");\n\t\tgoto error_currentSample;\n\t}\n\n\tret->surfaceData = BufferPool_Take(priv->surfacePool, width * height * 4);\n\tif (!ret->surfaceData)\n\t{\n\t\tWLog_ERR(TAG, \"unable to allocate surfaceData\");\n\t\tgoto error_surfaceData;\n\t}\n\n\tret->surface = video->createSurface(video, ret->surfaceData, x, y, width, height);\n\tif (!ret->surface)\n\t{\n\t\tWLog_ERR(TAG, \"unable to create surface\");\n\t\tgoto error_surface;\n\t}\n\n\tret->yuv = yuv_context_new(FALSE);\n\tif (!ret->yuv)\n\t{\n\t\tWLog_ERR(TAG, \"unable to create YUV decoder\");\n\t\tgoto error_yuv;\n\t}\n\n\tyuv_context_reset(ret->yuv, width, height);\n\tret->refCounter = 1;\n\treturn ret;\n\nerror_yuv:\n\tvideo->deleteSurface(video, ret->surface);\nerror_surface:\n\tBufferPool_Return(priv->surfacePool, ret->surfaceData);\nerror_surfaceData:\n\tStream_Free(ret->currentSample, TRUE);\nerror_currentSample:\n\th264_context_free(ret->h264);\nerror_h264:\n\tfree(ret);\n\treturn NULL;\n}",
        "start_line": 220
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "channels/video/client/video_main.c",
        "method_name": "PresentationContext_new",
        "raw_code": "static PresentationContext* PresentationContext_new(VideoClientContext* video, BYTE PresentationId, /* <=== PresentationContext_new */ \n                                                    UINT32 x, UINT32 y, UINT32 width, UINT32 height)\n{\n\tsize_t s;\n\tVideoClientContextPriv* priv = video->priv;\n\tPresentationContext* ret;\n\ts = width * height * 4ULL;\n\tif (s > INT32_MAX)\n\t\treturn NULL;\n\n\tret = calloc(1, sizeof(*ret));\n\tif (!ret)\n\t\treturn NULL;\n\n\tret->video = video;\n\tret->PresentationId = PresentationId;\n\n\tret->h264 = h264_context_new(FALSE);\n\tif (!ret->h264)\n\t{\n\t\tWLog_ERR(TAG, \"unable to create a h264 context\");\n\t\tgoto error_h264;\n\t}\n\th264_context_reset(ret->h264, width, height);\n\n\tret->currentSample = Stream_New(NULL, 4096);\n\tif (!ret->currentSample)\n\t{\n\t\tWLog_ERR(TAG, \"unable to create current packet stream\");\n\t\tgoto error_currentSample;\n\t}\n\n\tret->surfaceData = BufferPool_Take(priv->surfacePool, s);\n\tif (!ret->surfaceData)\n\t{\n\t\tWLog_ERR(TAG, \"unable to allocate surfaceData\");\n\t\tgoto error_surfaceData;\n\t}\n\n\tret->surface = video->createSurface(video, ret->surfaceData, x, y, width, height);\n\tif (!ret->surface)\n\t{\n\t\tWLog_ERR(TAG, \"unable to create surface\");\n\t\tgoto error_surface;\n\t}\n\n\tret->yuv = yuv_context_new(FALSE);\n\tif (!ret->yuv)\n\t{\n\t\tWLog_ERR(TAG, \"unable to create YUV decoder\");\n\t\tgoto error_yuv;\n\t}\n\n\tyuv_context_reset(ret->yuv, width, height);\n\tret->refCounter = 1;\n\treturn ret;\n\nerror_yuv:\n\tvideo->deleteSurface(video, ret->surface);\nerror_surface:\n\tBufferPool_Return(priv->surfacePool, ret->surfaceData);\nerror_surfaceData:\n\tStream_Free(ret->currentSample, TRUE);\nerror_currentSample:\n\th264_context_free(ret->h264);\nerror_h264:\n\tfree(ret);\n\treturn NULL;\n}",
        "start_line": 220
      }
    ],
    "code_context": "Called Methods:\n- BufferPool_Return: BOOL BufferPool_Return(wBufferPool* pool, void* buffer) /* <=== BufferPool_Return */ \n{\n\tint size = 0;\n\tint index = 0;\n\tBOOL found = FALSE;\n\n\tif (pool->synchronized)\n\t\tEnterCriticalSection(&pool->lock);\n\n\tif (pool->fixedSize)\n\t{\n\t\t/* fixed size buffers */\n\n\t\tif ((pool->size + 1) >= pool->capacity)\n\t\t{\n\t\t\tint newCapacity = pool->capacity * 2;\n\t\t\tvoid** newArray = (void**)realloc(pool->array, sizeof(void*) * newCapacity);\n\t\t\tif (!newArray)\n\t\t\t\tgoto out_error;\n\n\t\t\tpool->capacity = newCapacity;\n\t\t\tpool->array = newArray;\n\t\t}\n\n\t\tpool->array[(pool->size)++] = buffer;\n\t}\n\telse\n\t{\n\t\t/* variable size buffers */\n\n\t\tfor (index = 0; index < pool->uSize; index++)\n\t\t{\n\t\t\tif (pool->uArray[index].buffer == buffer)\n\t\t\t{\n\t\t\t\tfound = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (found)\n\t\t{\n\t\t\tsize = pool->uArray[index].size;\n\t\t\tif (!BufferPool_ShiftUsed(pool, index, -1))\n\t\t\t\tgoto out_error;\n\t\t}\n\n\t\tif (size)\n\t\t{\n\t\t\tif ((pool->aSize + 1) >= pool->aCapacity)\n\t\t\t{\n\t\t\t\tint newCapacity = pool->aCapacity * 2;\n\t\t\t\twBufferPoolItem* newArray =\n\t\t\t\t    (wBufferPoolItem*)realloc(pool->aArray, sizeof(wBufferPoolItem) * newCapacity);\n\t\t\t\tif (!newArray)\n\t\t\t\t\tgoto out_error;\n\n\t\t\t\tpool->aCapacity = newCapacity;\n\t\t\t\tpool->aArray = newArray;\n\t\t\t}\n\n\t\t\tpool->aArray[pool->aSize].buffer = buffer;\n\t\t\tpool->aArray[pool->aSize].size = size;\n\t\t\t(pool->aSize)++;\n\t\t}\n\t}\n\n\tif (pool->synchronized)\n\t\tLeaveCriticalSection(&pool->lock);\n\treturn TRUE;\n\nout_error:\n\tif (pool->synchronized)\n\t\tLeaveCriticalSection(&pool->lock);\n\treturn FALSE;\n}\n- h264_context_new: H264_CONTEXT* h264_context_new(BOOL Compressor) /* <=== h264_context_new */ \n{\n\tH264_CONTEXT* h264;\n\th264 = (H264_CONTEXT*)calloc(1, sizeof(H264_CONTEXT));\n\n\tif (h264)\n\t{\n\t\th264->Compressor = Compressor;\n\n\t\tif (Compressor)\n\t\t{\n\t\t\t/* Default compressor settings, may be changed by caller */\n\t\t\th264->BitRate = 1000000;\n\t\t\th264->FrameRate = 30;\n\t\t}\n\n\t\tif (!h264_context_init(h264))\n\t\t{\n\t\t\tfree(h264);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn h264;\n}\n- yuv_context_new: YUV_CONTEXT* yuv_context_new(BOOL encoder) /* <=== yuv_context_new */ \n{\n\tSYSTEM_INFO sysInfos;\n\tYUV_CONTEXT* ret = calloc(1, sizeof(*ret));\n\tif (!ret)\n\t\treturn NULL;\n\n\t/** do it here to avoid a race condition between threads */\n\tprimitives_get();\n\n\tGetNativeSystemInfo(&sysInfos);\n\tret->useThreads = (sysInfos.dwNumberOfProcessors > 1);\n\tif (ret->useThreads)\n\t{\n\t\tret->nthreads = sysInfos.dwNumberOfProcessors;\n\t\tret->threadPool = CreateThreadpool(NULL);\n\t\tif (!ret->threadPool)\n\t\t{\n\t\t\tgoto error_threadpool;\n\t\t}\n\n\t\tInitializeThreadpoolEnvironment(&ret->ThreadPoolEnv);\n\t\tSetThreadpoolCallbackPool(&ret->ThreadPoolEnv, ret->threadPool);\n\t}\n\telse\n\t{\n\t\tret->nthreads = 1;\n\t}\n\n\treturn ret;\n\nerror_threadpool:\n\tfree(ret);\n\treturn NULL;\n}\n- yuv_context_reset: void yuv_context_reset(YUV_CONTEXT* context, UINT32 width, UINT32 height) /* <=== yuv_context_reset */ \n{\n\tcontext->width = width;\n\tcontext->height = height;\n\tcontext->heightStep = (height / context->nthreads);\n}\n- EnterCriticalSection: \tWINPR_API VOID EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection); /* <=== EnterCriticalSection */ \n- h264_context_init: static BOOL h264_context_init(H264_CONTEXT* h264) /* <=== h264_context_init */ \n{\n\tint i;\n\n\tif (!h264)\n\t\treturn FALSE;\n\n\th264->log = WLog_Get(TAG);\n\n\tif (!h264->log)\n\t\treturn FALSE;\n\n\th264->subsystem = NULL;\n\tInitOnceExecuteOnce(&subsystems_once, h264_register_subsystems, NULL, NULL);\n\n\tfor (i = 0; i < MAX_SUBSYSTEMS; i++)\n\t{\n\t\tH264_CONTEXT_SUBSYSTEM* subsystem = subSystems[i];\n\n\t\tif (!subsystem || !subsystem->Init)\n\t\t\tbreak;\n\n\t\tif (subsystem->Init(h264))\n\t\t{\n\t\t\th264->subsystem = subsystem;\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\n\treturn FALSE;\n}\n- Stream_Free: void Stream_Free(wStream* s, BOOL bFreeBuffer) /* <=== Stream_Free */ \n{\n\tif (s)\n\t{\n\t\tif (bFreeBuffer && s->isOwner)\n\t\t\tfree(s->buffer);\n\n\t\tif (s->isAllocatedStream)\n\t\t\tfree(s);\n\t}\n}\n- _aligned_realloc: \tWINPR_API void* _aligned_realloc(void* memblock, size_t size, size_t alignment); /* <=== _aligned_realloc */ \n- TAG: #define TAG CHANNELS_TAG(\"video\") /* <=== channels/video/client/video_main.c:45:45:TAG:0 */ \n- LeaveCriticalSection: \tWINPR_API VOID LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection); /* <=== LeaveCriticalSection */ \n- GetNativeSystemInfo: \tWINPR_API void GetNativeSystemInfo(LPSYSTEM_INFO lpSystemInfo); /* <=== GetNativeSystemInfo */ \n- primitives_get: \tFREERDP_API primitives_t* primitives_get(void); /* <=== primitives_get */ \n- _aligned_free: \tWINPR_API void _aligned_free(void* memblock); /* <=== _aligned_free */ \n- _aligned_malloc: \tWINPR_API void* _aligned_malloc(size_t size, size_t alignment); /* <=== _aligned_malloc */ \n- BufferPool_Take: void* BufferPool_Take(wBufferPool* pool, int size) /* <=== BufferPool_Take */ \n{\n\tint index;\n\tint maxSize;\n\tint maxIndex;\n\tint foundIndex;\n\tBOOL found = FALSE;\n\tvoid* buffer = NULL;\n\n\tif (pool->synchronized)\n\t\tEnterCriticalSection(&pool->lock);\n\n\tif (pool->fixedSize)\n\t{\n\t\t/* fixed size buffers */\n\n\t\tif (pool->size > 0)\n\t\t\tbuffer = pool->array[--(pool->size)];\n\n\t\tif (!buffer)\n\t\t{\n\t\t\tif (pool->alignment)\n\t\t\t\tbuffer = _aligned_malloc(pool->fixedSize, pool->alignment);\n\t\t\telse\n\t\t\t\tbuffer = malloc(pool->fixedSize);\n\t\t}\n\n\t\tif (!buffer)\n\t\t\tgoto out_error;\n\t}\n\telse\n\t{\n\t\t/* variable size buffers */\n\n\t\tmaxSize = 0;\n\t\tmaxIndex = 0;\n\n\t\tif (size < 1)\n\t\t\tsize = pool->fixedSize;\n\n\t\tfor (index = 0; index < pool->aSize; index++)\n\t\t{\n\t\t\tif (pool->aArray[index].size > maxSize)\n\t\t\t{\n\t\t\t\tmaxIndex = index;\n\t\t\t\tmaxSize = pool->aArray[index].size;\n\t\t\t}\n\n\t\t\tif (pool->aArray[index].size >= size)\n\t\t\t{\n\t\t\t\tfoundIndex = index;\n\t\t\t\tfound = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found && maxSize)\n\t\t{\n\t\t\tfoundIndex = maxIndex;\n\t\t\tfound = TRUE;\n\t\t}\n\n\t\tif (!found)\n\t\t{\n\t\t\tif (!size)\n\t\t\t\tbuffer = NULL;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (pool->alignment)\n\t\t\t\t\tbuffer = _aligned_malloc(size, pool->alignment);\n\t\t\t\telse\n\t\t\t\t\tbuffer = malloc(size);\n\n\t\t\t\tif (!buffer)\n\t\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbuffer = pool->aArray[foundIndex].buffer;\n\n\t\t\tif (maxSize < size)\n\t\t\t{\n\t\t\t\tvoid* newBuffer;\n\t\t\t\tif (pool->alignment)\n\t\t\t\t\tnewBuffer = _aligned_realloc(buffer, size, pool->alignment);\n\t\t\t\telse\n\t\t\t\t\tnewBuffer = realloc(buffer, size);\n\n\t\t\t\tif (!newBuffer)\n\t\t\t\t\tgoto out_error_no_free;\n\n\t\t\t\tbuffer = newBuffer;\n\t\t\t}\n\n\t\t\tif (!BufferPool_ShiftAvailable(pool, foundIndex, -1))\n\t\t\t\tgoto out_error;\n\t\t}\n\n\t\tif (!buffer)\n\t\t\tgoto out_error;\n\n\t\tif (pool->uSize + 1 > pool->uCapacity)\n\t\t{\n\t\t\tint newUCapacity = pool->uCapacity * 2;\n\t\t\twBufferPoolItem* newUArray =\n\t\t\t    (wBufferPoolItem*)realloc(pool->uArray, sizeof(wBufferPoolItem) * newUCapacity);\n\t\t\tif (!newUArray)\n\t\t\t\tgoto out_error;\n\n\t\t\tpool->uCapacity = newUCapacity;\n\t\t\tpool->uArray = newUArray;\n\t\t}\n\n\t\tpool->uArray[pool->uSize].buffer = buffer;\n\t\tpool->uArray[pool->uSize].size = size;\n\t\t(pool->uSize)++;\n\t}\n\n\tif (pool->synchronized)\n\t\tLeaveCriticalSection(&pool->lock);\n\n\treturn buffer;\n\nout_error:\n\tif (pool->alignment)\n\t\t_aligned_free(buffer);\n\telse\n\t\tfree(buffer);\nout_error_no_free:\n\tif (pool->synchronized)\n\t\tLeaveCriticalSection(&pool->lock);\n\treturn NULL;\n}\n- Stream_New: wStream* Stream_New(BYTE* buffer, size_t size) /* <=== Stream_New */ \n{\n\twStream* s;\n\n\tif (!buffer && !size)\n\t\treturn NULL;\n\n\ts = malloc(sizeof(wStream));\n\tif (!s)\n\t\treturn NULL;\n\n\tif (buffer)\n\t\ts->buffer = buffer;\n\telse\n\t\ts->buffer = (BYTE*)malloc(size);\n\n\tif (!s->buffer)\n\t{\n\t\tfree(s);\n\t\treturn NULL;\n\t}\n\n\ts->pointer = s->buffer;\n\ts->capacity = size;\n\ts->length = size;\n\n\ts->pool = NULL;\n\ts->count = 0;\n\ts->isAllocatedStream = TRUE;\n\ts->isOwner = TRUE;\n\treturn s;\n}\n- BufferPool_ShiftUsed: static BOOL BufferPool_ShiftUsed(wBufferPool* pool, int index, int count) /* <=== BufferPool_ShiftUsed */ \n{\n\tif (count > 0)\n\t{\n\t\tif (pool->uSize + count > pool->uCapacity)\n\t\t{\n\t\t\tint newUCapacity = pool->uCapacity * 2;\n\t\t\twBufferPoolItem* newUArray =\n\t\t\t    (wBufferPoolItem*)realloc(pool->uArray, sizeof(wBufferPoolItem) * newUCapacity);\n\t\t\tif (!newUArray)\n\t\t\t\treturn FALSE;\n\t\t\tpool->uCapacity = newUCapacity;\n\t\t\tpool->uArray = newUArray;\n\t\t}\n\n\t\tMoveMemory(&pool->uArray[index + count], &pool->uArray[index],\n\t\t           (pool->uSize - index) * sizeof(wBufferPoolItem));\n\t\tpool->uSize += count;\n\t}\n\telse if (count < 0)\n\t{\n\t\tMoveMemory(&pool->uArray[index], &pool->uArray[index - count],\n\t\t           (pool->uSize - index) * sizeof(wBufferPoolItem));\n\t\tpool->uSize += count;\n\t}\n\treturn TRUE;\n}\n- BufferPool_ShiftAvailable: static BOOL BufferPool_ShiftAvailable(wBufferPool* pool, int index, int count) /* <=== BufferPool_ShiftAvailable */ \n{\n\tif (count > 0)\n\t{\n\t\tif (pool->aSize + count > pool->aCapacity)\n\t\t{\n\t\t\twBufferPoolItem* newArray;\n\t\t\tint newCapacity = pool->aCapacity * 2;\n\n\t\t\tnewArray =\n\t\t\t    (wBufferPoolItem*)realloc(pool->aArray, sizeof(wBufferPoolItem) * newCapacity);\n\t\t\tif (!newArray)\n\t\t\t\treturn FALSE;\n\t\t\tpool->aArray = newArray;\n\t\t\tpool->aCapacity = newCapacity;\n\t\t}\n\n\t\tMoveMemory(&pool->aArray[index + count], &pool->aArray[index],\n\t\t           (pool->aSize - index) * sizeof(wBufferPoolItem));\n\t\tpool->aSize += count;\n\t}\n\telse if (count < 0)\n\t{\n\t\tMoveMemory(&pool->aArray[index], &pool->aArray[index - count],\n\t\t           (pool->aSize - index) * sizeof(wBufferPoolItem));\n\t\tpool->aSize += count;\n\t}\n\treturn TRUE;\n}\n- h264_context_free: void h264_context_free(H264_CONTEXT* h264) /* <=== h264_context_free */ \n{\n\tif (h264)\n\t{\n\t\th264->subsystem->Uninit(h264);\n\t\t_aligned_free(h264->pYUV444Data[0]);\n\t\t_aligned_free(h264->pYUV444Data[1]);\n\t\t_aligned_free(h264->pYUV444Data[2]);\n\t\t_aligned_free(h264->lumaData);\n\t\tfree(h264);\n\t}\n}\n\nType Definitions:\n- VideoClientContext: typedef struct _VideoClientContext VideoClientContext;\n- VideoClientContextPriv: typedef struct _VideoClientContextPriv VideoClientContextPriv;\n- PresentationContext: typedef struct _PresentationContext PresentationContext;\n\nImports:\n- #include <winpr/synch.h>\n- #include <winpr/collections.h>\n- #include <stdlib.h>\n- #include <winpr/stream.h>\n- #include <winpr/print.h>\n- #include \"config.h\"\n- #include <freerdp/client/geometry.h>\n- #include <stdio.h>\n- #include <freerdp/channels/log.h>\n- #include <freerdp/codec/h264.h>\n- #include <freerdp/codec/yuv.h>\n- #include <freerdp/client/video.h>\n- #include <freerdp/primitives.h>\n- #include \"video_main.h\"\n- #include <winpr/sysinfo.h>\n- #include <winpr/interlocked.h>\n- #include <winpr/cmdline.h>\n- #include <winpr/crt.h>\n- #include <freerdp/addin.h>\n- #include <string.h>",
    "commit_msg": "Fixed int overflow in PresentationContext_new\n\nThanks to hac425 CVE-2020-11038",
    "cve_desc": "In FreeRDP less than or equal to 2.0.0, an Integer Overflow to Buffer Overflow exists. When using /video redirection, a manipulated server can instruct the client to allocate a buffer with a smaller size than requested due to an integer overflow in size calculation. With later messages, the server can manipulate the client to write data out of bound to the previously allocated buffer. This has been patched in 2.1.0.",
    "year": 2020,
    "filename": "video_main.c",
    "commit_url": "\"https://github.com/FreeRDP/FreeRDP/commit/06c32f170093a6ecde93e3bc07fed6a706bfbeb3\""
  },
  {
    "repository": "FreeRDP/FreeRDP",
    "cve_id": "CVE-2020-11039",
    "cwe_list": [
      "CWE-190"
    ],
    "commit_hash": "9f77fc3dd2394373e1be753952b00dafa1a9b7da",
    "short_hash": "9f77fc3d",
    "vulnerableMethods_before": [
      {
        "filename": "channels/urbdrc/common/msusb.c",
        "method_name": "msusb_mspipes_read",
        "raw_code": "static MSUSB_PIPE_DESCRIPTOR** msusb_mspipes_read(wStream* s, UINT32 NumberOfPipes) /* <=== msusb_mspipes_read */ \n{\n\tUINT32 pnum;\n\tMSUSB_PIPE_DESCRIPTOR** MsPipes;\n\n\tif (Stream_GetRemainingCapacity(s) < 12 * NumberOfPipes)\n\t\treturn NULL;\n\n\tMsPipes = (MSUSB_PIPE_DESCRIPTOR**)calloc(NumberOfPipes, sizeof(MSUSB_PIPE_DESCRIPTOR*));\n\n\tif (!MsPipes)\n\t\treturn NULL;\n\n\tfor (pnum = 0; pnum < NumberOfPipes; pnum++)\n\t{\n\t\tMSUSB_PIPE_DESCRIPTOR* MsPipe = msusb_mspipe_new();\n\n\t\tif (!MsPipe)\n\t\t\tgoto out_error;\n\n\t\tStream_Read_UINT16(s, MsPipe->MaximumPacketSize);\n\t\tStream_Seek(s, 2);\n\t\tStream_Read_UINT32(s, MsPipe->MaximumTransferSize);\n\t\tStream_Read_UINT32(s, MsPipe->PipeFlags);\n\t\t/* Already set to zero by memset\n\t\t        MsPipe->PipeHandle\t   = 0;\n\t\t        MsPipe->bEndpointAddress = 0;\n\t\t        MsPipe->bInterval\t\t= 0;\n\t\t        MsPipe->PipeType\t\t = 0;\n\t\t        MsPipe->InitCompleted\t= 0;\n\t\t*/\n\t\tMsPipes[pnum] = MsPipe;\n\t}\n\n\treturn MsPipes;\nout_error:\n\n\tfor (pnum = 0; pnum < NumberOfPipes; pnum++)\n\t\tfree(MsPipes[pnum]);\n\n\tfree(MsPipes);\n\treturn NULL;\n}",
        "start_line": 62
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "channels/urbdrc/common/msusb.c",
        "method_name": "msusb_mspipes_read",
        "raw_code": "static MSUSB_PIPE_DESCRIPTOR** msusb_mspipes_read(wStream* s, UINT32 NumberOfPipes) /* <=== msusb_mspipes_read */ \n{\n\tUINT32 pnum;\n\tMSUSB_PIPE_DESCRIPTOR** MsPipes;\n\n\tif (Stream_GetRemainingCapacity(s) / 12 < NumberOfPipes)\n\t\treturn NULL;\n\n\tMsPipes = (MSUSB_PIPE_DESCRIPTOR**)calloc(NumberOfPipes, sizeof(MSUSB_PIPE_DESCRIPTOR*));\n\n\tif (!MsPipes)\n\t\treturn NULL;\n\n\tfor (pnum = 0; pnum < NumberOfPipes; pnum++)\n\t{\n\t\tMSUSB_PIPE_DESCRIPTOR* MsPipe = msusb_mspipe_new();\n\n\t\tif (!MsPipe)\n\t\t\tgoto out_error;\n\n\t\tStream_Read_UINT16(s, MsPipe->MaximumPacketSize);\n\t\tStream_Seek(s, 2);\n\t\tStream_Read_UINT32(s, MsPipe->MaximumTransferSize);\n\t\tStream_Read_UINT32(s, MsPipe->PipeFlags);\n\t\t/* Already set to zero by memset\n\t\t        MsPipe->PipeHandle\t   = 0;\n\t\t        MsPipe->bEndpointAddress = 0;\n\t\t        MsPipe->bInterval\t\t= 0;\n\t\t        MsPipe->PipeType\t\t = 0;\n\t\t        MsPipe->InitCompleted\t= 0;\n\t\t*/\n\t\tMsPipes[pnum] = MsPipe;\n\t}\n\n\treturn MsPipes;\nout_error:\n\n\tfor (pnum = 0; pnum < NumberOfPipes; pnum++)\n\t\tfree(MsPipes[pnum]);\n\n\tfree(MsPipes);\n\treturn NULL;\n}",
        "start_line": 62
      }
    ],
    "code_context": "Called Methods:\n- msusb_mspipe_new: static MSUSB_PIPE_DESCRIPTOR* msusb_mspipe_new() /* <=== msusb_mspipe_new */ \n{\n\treturn (MSUSB_PIPE_DESCRIPTOR*)calloc(1, sizeof(MSUSB_PIPE_DESCRIPTOR));\n}\n\nType Definitions:\n- wStream: typedef struct _wStream wStream;\n- MSUSB_PIPE_DESCRIPTOR: typedef struct _MSUSB_PIPE_DESCRIPTOR MSUSB_PIPE_DESCRIPTOR;\n\nImports:\n- #include <stdlib.h>\n- #include <stdio.h>\n- #include <freerdp/log.h>\n- #include <msusb.h>\n- #include <string.h>",
    "commit_msg": "Fixed int overflow in msusb_mspipes_read\n\nThanks to hac425",
    "cve_desc": "In FreeRDP less than or equal to 2.0.0, when using a manipulated server with USB redirection enabled (nearly) arbitrary memory can be read and written due to integer overflows in length checks. This has been patched in 2.1.0.",
    "year": 2020,
    "filename": "msusb.c",
    "commit_url": "\"https://github.com/FreeRDP/FreeRDP/commit/9f77fc3dd2394373e1be753952b00dafa1a9b7da\""
  },
  {
    "repository": "FreeRDP/FreeRDP",
    "cve_id": "CVE-2020-11040",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "363d7046dfec4003b91aecf7867e3b05905f3843",
    "short_hash": "363d7046",
    "vulnerableMethods_before": [
      {
        "filename": "libfreerdp/codec/clear.c",
        "method_name": "clear_decompress_subcode_rlex",
        "raw_code": "static BOOL clear_decompress_subcode_rlex(wStream* s, UINT32 bitmapDataByteCount, UINT32 width, /* <=== clear_decompress_subcode_rlex */ \n                                          UINT32 height, BYTE* pDstData, UINT32 DstFormat,\n                                          UINT32 nDstStep, UINT32 nXDstRel, UINT32 nYDstRel,\n                                          UINT32 nDstWidth, UINT32 nDstHeight)\n{\n\tUINT32 x = 0, y = 0;\n\tUINT32 i;\n\tUINT32 pixelCount;\n\tUINT32 bitmapDataOffset;\n\tUINT32 pixelIndex;\n\tUINT32 numBits;\n\tBYTE startIndex;\n\tBYTE stopIndex;\n\tBYTE suiteIndex;\n\tBYTE suiteDepth;\n\tBYTE paletteCount;\n\tUINT32 palette[128] = { 0 };\n\n\tif (Stream_GetRemainingLength(s) < bitmapDataByteCount)\n\t{\n\t\tWLog_ERR(TAG, \"stream short %\" PRIuz \" [%\" PRIu32 \" expected]\",\n\t\t         Stream_GetRemainingLength(s), bitmapDataByteCount);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT8(s, paletteCount);\n\tbitmapDataOffset = 1 + (paletteCount * 3);\n\n\tif ((paletteCount > 127) || (paletteCount < 1))\n\t{\n\t\tWLog_ERR(TAG, \"paletteCount %\" PRIu8 \"\", paletteCount);\n\t\treturn FALSE;\n\t}\n\n\tfor (i = 0; i < paletteCount; i++)\n\t{\n\t\tBYTE r, g, b;\n\t\tStream_Read_UINT8(s, b);\n\t\tStream_Read_UINT8(s, g);\n\t\tStream_Read_UINT8(s, r);\n\t\tpalette[i] = FreeRDPGetColor(DstFormat, r, g, b, 0xFF);\n\t}\n\n\tpixelIndex = 0;\n\tpixelCount = width * height;\n\tnumBits = CLEAR_LOG2_FLOOR[paletteCount - 1] + 1;\n\n\twhile (bitmapDataOffset < bitmapDataByteCount)\n\t{\n\t\tUINT32 tmp;\n\t\tUINT32 color;\n\t\tUINT32 runLengthFactor;\n\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"stream short %\" PRIuz \" [2 expected]\", Stream_GetRemainingLength(s));\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tStream_Read_UINT8(s, tmp);\n\t\tStream_Read_UINT8(s, runLengthFactor);\n\t\tbitmapDataOffset += 2;\n\t\tsuiteDepth = (tmp >> numBits) & CLEAR_8BIT_MASKS[(8 - numBits)];\n\t\tstopIndex = tmp & CLEAR_8BIT_MASKS[numBits];\n\t\tstartIndex = stopIndex - suiteDepth;\n\n\t\tif (runLengthFactor >= 0xFF)\n\t\t{\n\t\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"stream short %\" PRIuz \" [2 expected]\", Stream_GetRemainingLength(s));\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tStream_Read_UINT16(s, runLengthFactor);\n\t\t\tbitmapDataOffset += 2;\n\n\t\t\tif (runLengthFactor >= 0xFFFF)\n\t\t\t{\n\t\t\t\tif (Stream_GetRemainingLength(s) < 4)\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG, \"stream short %\" PRIuz \" [4 expected]\",\n\t\t\t\t\t         Stream_GetRemainingLength(s));\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\n\t\t\t\tStream_Read_UINT32(s, runLengthFactor);\n\t\t\t\tbitmapDataOffset += 4;\n\t\t\t}\n\t\t}\n\n\t\tif (startIndex >= paletteCount)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"startIndex %\" PRIu8 \" > paletteCount %\" PRIu8 \"]\", startIndex,\n\t\t\t         paletteCount);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tif (stopIndex >= paletteCount)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"stopIndex %\" PRIu8 \" > paletteCount %\" PRIu8 \"]\", stopIndex,\n\t\t\t         paletteCount);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tsuiteIndex = startIndex;\n\n\t\tif (suiteIndex > 127)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"suiteIndex %\" PRIu8 \" > 127]\", suiteIndex);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tcolor = palette[suiteIndex];\n\n\t\tif ((pixelIndex + runLengthFactor) > pixelCount)\n\t\t{\n\t\t\tWLog_ERR(TAG,\n\t\t\t         \"pixelIndex %\" PRIu32 \" + runLengthFactor %\" PRIu32 \" > pixelCount %\" PRIu32\n\t\t\t         \"\",\n\t\t\t         pixelIndex, runLengthFactor, pixelCount);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tfor (i = 0; i < runLengthFactor; i++)\n\t\t{\n\t\t\tBYTE* pTmpData =\n\t\t\t    &pDstData[(nXDstRel + x) * GetBytesPerPixel(DstFormat) + (nYDstRel + y) * nDstStep];\n\n\t\t\tif ((nXDstRel + x < nDstWidth) && (nYDstRel + y < nDstHeight))\n\t\t\t\tWriteColor(pTmpData, DstFormat, color);\n\n\t\t\tif (++x >= width)\n\t\t\t{\n\t\t\t\ty++;\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t}\n\n\t\tpixelIndex += runLengthFactor;\n\n\t\tif ((pixelIndex + (suiteDepth + 1)) > pixelCount)\n\t\t{\n\t\t\tWLog_ERR(TAG,\n\t\t\t         \"pixelIndex %\" PRIu32 \" + suiteDepth %\" PRIu8 \" + 1 > pixelCount %\" PRIu32 \"\",\n\t\t\t         pixelIndex, suiteDepth, pixelCount);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tfor (i = 0; i <= suiteDepth; i++)\n\t\t{\n\t\t\tBYTE* pTmpData =\n\t\t\t    &pDstData[(nXDstRel + x) * GetBytesPerPixel(DstFormat) + (nYDstRel + y) * nDstStep];\n\t\t\tUINT32 color = palette[suiteIndex];\n\n\t\t\tif (suiteIndex > 127)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"suiteIndex %\" PRIu8 \" > 127\", suiteIndex);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tsuiteIndex++;\n\n\t\t\tif ((nXDstRel + x < nDstWidth) && (nYDstRel + y < nDstHeight))\n\t\t\t\tWriteColor(pTmpData, DstFormat, color);\n\n\t\t\tif (++x >= width)\n\t\t\t{\n\t\t\t\ty++;\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t}\n\n\t\tpixelIndex += (suiteDepth + 1);\n\t}\n\n\tif (pixelIndex != pixelCount)\n\t{\n\t\tWLog_ERR(TAG, \"pixelIndex %\" PRIu32 \" != pixelCount %\" PRIu32 \"\", pixelIndex, pixelCount);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}",
        "start_line": 124
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "libfreerdp/codec/clear.c",
        "method_name": "clear_decompress_subcode_rlex",
        "raw_code": "static BOOL clear_decompress_subcode_rlex(wStream* s, UINT32 bitmapDataByteCount, UINT32 width, /* <=== clear_decompress_subcode_rlex */ \n                                          UINT32 height, BYTE* pDstData, UINT32 DstFormat,\n                                          UINT32 nDstStep, UINT32 nXDstRel, UINT32 nYDstRel,\n                                          UINT32 nDstWidth, UINT32 nDstHeight)\n{\n\tUINT32 x = 0, y = 0;\n\tUINT32 i;\n\tUINT32 pixelCount;\n\tUINT32 bitmapDataOffset;\n\tsize_t pixelIndex;\n\tUINT32 numBits;\n\tBYTE startIndex;\n\tBYTE stopIndex;\n\tBYTE suiteIndex;\n\tBYTE suiteDepth;\n\tBYTE paletteCount;\n\tUINT32 palette[128] = { 0 };\n\n\tif (Stream_GetRemainingLength(s) < bitmapDataByteCount)\n\t{\n\t\tWLog_ERR(TAG, \"stream short %\" PRIuz \" [%\" PRIu32 \" expected]\",\n\t\t         Stream_GetRemainingLength(s), bitmapDataByteCount);\n\t\treturn FALSE;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < 1)\n\t\treturn FALSE;\n\tStream_Read_UINT8(s, paletteCount);\n\tbitmapDataOffset = 1 + (paletteCount * 3);\n\n\tif ((paletteCount > 127) || (paletteCount < 1))\n\t{\n\t\tWLog_ERR(TAG, \"paletteCount %\" PRIu8 \"\", paletteCount);\n\t\treturn FALSE;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < 3ULL * paletteCount)\n\t\treturn FALSE;\n\n\tfor (i = 0; i < paletteCount; i++)\n\t{\n\t\tBYTE r, g, b;\n\t\tStream_Read_UINT8(s, b);\n\t\tStream_Read_UINT8(s, g);\n\t\tStream_Read_UINT8(s, r);\n\t\tpalette[i] = FreeRDPGetColor(DstFormat, r, g, b, 0xFF);\n\t}\n\n\tpixelIndex = 0;\n\tpixelCount = width * height;\n\tnumBits = CLEAR_LOG2_FLOOR[paletteCount - 1] + 1;\n\n\twhile (bitmapDataOffset < bitmapDataByteCount)\n\t{\n\t\tUINT32 tmp;\n\t\tUINT32 color;\n\t\tUINT32 runLengthFactor;\n\n\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"stream short %\" PRIuz \" [2 expected]\", Stream_GetRemainingLength(s));\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tStream_Read_UINT8(s, tmp);\n\t\tStream_Read_UINT8(s, runLengthFactor);\n\t\tbitmapDataOffset += 2;\n\t\tsuiteDepth = (tmp >> numBits) & CLEAR_8BIT_MASKS[(8 - numBits)];\n\t\tstopIndex = tmp & CLEAR_8BIT_MASKS[numBits];\n\t\tstartIndex = stopIndex - suiteDepth;\n\n\t\tif (runLengthFactor >= 0xFF)\n\t\t{\n\t\t\tif (Stream_GetRemainingLength(s) < 2)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"stream short %\" PRIuz \" [2 expected]\", Stream_GetRemainingLength(s));\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tStream_Read_UINT16(s, runLengthFactor);\n\t\t\tbitmapDataOffset += 2;\n\n\t\t\tif (runLengthFactor >= 0xFFFF)\n\t\t\t{\n\t\t\t\tif (Stream_GetRemainingLength(s) < 4)\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG, \"stream short %\" PRIuz \" [4 expected]\",\n\t\t\t\t\t         Stream_GetRemainingLength(s));\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\n\t\t\t\tStream_Read_UINT32(s, runLengthFactor);\n\t\t\t\tbitmapDataOffset += 4;\n\t\t\t}\n\t\t}\n\n\t\tif (startIndex >= paletteCount)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"startIndex %\" PRIu8 \" > paletteCount %\" PRIu8 \"]\", startIndex,\n\t\t\t         paletteCount);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tif (stopIndex >= paletteCount)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"stopIndex %\" PRIu8 \" > paletteCount %\" PRIu8 \"]\", stopIndex,\n\t\t\t         paletteCount);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tsuiteIndex = startIndex;\n\n\t\tif (suiteIndex > 127)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"suiteIndex %\" PRIu8 \" > 127]\", suiteIndex);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tcolor = palette[suiteIndex];\n\n\t\tif ((pixelIndex + runLengthFactor) > pixelCount)\n\t\t{\n\t\t\tWLog_ERR(TAG,\n\t\t\t         \"pixelIndex %\" PRIu32 \" + runLengthFactor %\" PRIu32 \" > pixelCount %\" PRIu32\n\t\t\t         \"\",\n\t\t\t         pixelIndex, runLengthFactor, pixelCount);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tfor (i = 0; i < runLengthFactor; i++)\n\t\t{\n\t\t\tBYTE* pTmpData =\n\t\t\t    &pDstData[(nXDstRel + x) * GetBytesPerPixel(DstFormat) + (nYDstRel + y) * nDstStep];\n\n\t\t\tif ((nXDstRel + x < nDstWidth) && (nYDstRel + y < nDstHeight))\n\t\t\t\tWriteColor(pTmpData, DstFormat, color);\n\n\t\t\tif (++x >= width)\n\t\t\t{\n\t\t\t\ty++;\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t}\n\n\t\tpixelIndex += runLengthFactor;\n\n\t\tif ((pixelIndex + (suiteDepth + 1)) > pixelCount)\n\t\t{\n\t\t\tWLog_ERR(TAG,\n\t\t\t         \"pixelIndex %\" PRIu32 \" + suiteDepth %\" PRIu8 \" + 1 > pixelCount %\" PRIu32 \"\",\n\t\t\t         pixelIndex, suiteDepth, pixelCount);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tfor (i = 0; i <= suiteDepth; i++)\n\t\t{\n\t\t\tBYTE* pTmpData =\n\t\t\t    &pDstData[(nXDstRel + x) * GetBytesPerPixel(DstFormat) + (nYDstRel + y) * nDstStep];\n\t\t\tUINT32 color = palette[suiteIndex];\n\n\t\t\tif (suiteIndex > 127)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"suiteIndex %\" PRIu8 \" > 127\", suiteIndex);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tsuiteIndex++;\n\n\t\t\tif ((nXDstRel + x < nDstWidth) && (nYDstRel + y < nDstHeight))\n\t\t\t\tWriteColor(pTmpData, DstFormat, color);\n\n\t\t\tif (++x >= width)\n\t\t\t{\n\t\t\t\ty++;\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t}\n\n\t\tpixelIndex += (suiteDepth + 1);\n\t}\n\n\tif (pixelIndex != pixelCount)\n\t{\n\t\tWLog_ERR(TAG, \"pixelIndex %\" PRIdz \" != pixelCount %\" PRIu32 \"\", pixelIndex, pixelCount);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}",
        "start_line": 124
      }
    ],
    "code_context": "Global Variables:\n- static const UINT32[256] CLEAR_LOG2_FLOOR\n- static const BYTE[9] CLEAR_8BIT_MASKS\n\nImports:\n- #include <freerdp/codec/color.h>\n- #include \"config.h\"\n- #include <winpr/print.h>\n- #include <winpr/crt.h>\n- #include <winpr/bitstream.h>\n- #include <freerdp/codec/clear.h>\n- #include <freerdp/log.h>",
    "commit_msg": "Fixed oob read in clear_decompress_subcode_rlex\n\nFixed length checks before stream read.\nThanks to hac425 CVE-2020-11040",
    "cve_desc": "In FreeRDP less than or equal to 2.0.0, there is an out-of-bound data read from memory in clear_decompress_subcode_rlex, visualized on screen as color. This has been patched in 2.1.0.",
    "year": 2020,
    "filename": "clear.c",
    "commit_url": "\"https://github.com/FreeRDP/FreeRDP/commit/363d7046dfec4003b91aecf7867e3b05905f3843\""
  },
  {
    "repository": "FreeRDP/FreeRDP",
    "cve_id": "CVE-2020-11044",
    "cwe_list": [
      "CWE-415"
    ],
    "commit_hash": "67c2aa52b2ae0341d469071d1bc8aab91f8d2ed8",
    "short_hash": "67c2aa52",
    "vulnerableMethods_before": [
      {
        "filename": "libfreerdp/core/orders.c",
        "method_name": "update_read_cache_bitmap_v3_order",
        "raw_code": "static CACHE_BITMAP_V3_ORDER* update_read_cache_bitmap_v3_order(rdpUpdate* update, wStream* s, /* <=== update_read_cache_bitmap_v3_order */ \n                                                                UINT16 flags)\n{\n\tBYTE bitsPerPixelId;\n\tBITMAP_DATA_EX* bitmapData;\n\tUINT32 new_len;\n\tBYTE* new_data;\n\tCACHE_BITMAP_V3_ORDER* cache_bitmap_v3;\n\n\tif (!update || !s)\n\t\treturn NULL;\n\n\tcache_bitmap_v3 = calloc(1, sizeof(CACHE_BITMAP_V3_ORDER));\n\n\tif (!cache_bitmap_v3)\n\t\tgoto fail;\n\n\tcache_bitmap_v3->cacheId = flags & 0x00000003;\n\tcache_bitmap_v3->flags = (flags & 0x0000FF80) >> 7;\n\tbitsPerPixelId = (flags & 0x00000078) >> 3;\n\tcache_bitmap_v3->bpp = CBR23_BPP[bitsPerPixelId];\n\n\tif (Stream_GetRemainingLength(s) < 21)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, cache_bitmap_v3->cacheIndex); /* cacheIndex (2 bytes) */\n\tStream_Read_UINT32(s, cache_bitmap_v3->key1);       /* key1 (4 bytes) */\n\tStream_Read_UINT32(s, cache_bitmap_v3->key2);       /* key2 (4 bytes) */\n\tbitmapData = &cache_bitmap_v3->bitmapData;\n\tStream_Read_UINT8(s, bitmapData->bpp);\n\n\tif ((bitmapData->bpp < 1) || (bitmapData->bpp > 32))\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"invalid bpp value %\" PRIu32 \"\", bitmapData->bpp);\n\t\tgoto fail;\n\t}\n\n\tStream_Seek_UINT8(s);                      /* reserved1 (1 byte) */\n\tStream_Seek_UINT8(s);                      /* reserved2 (1 byte) */\n\tStream_Read_UINT8(s, bitmapData->codecID); /* codecID (1 byte) */\n\tStream_Read_UINT16(s, bitmapData->width);  /* width (2 bytes) */\n\tStream_Read_UINT16(s, bitmapData->height); /* height (2 bytes) */\n\tStream_Read_UINT32(s, new_len);            /* length (4 bytes) */\n\n\tif (Stream_GetRemainingLength(s) < new_len)\n\t\tgoto fail;\n\n\tnew_data = (BYTE*)realloc(bitmapData->data, new_len);\n\n\tif (!new_data)\n\t\tgoto fail;\n\n\tbitmapData->data = new_data;\n\tbitmapData->length = new_len;\n\tStream_Read(s, bitmapData->data, bitmapData->length);\n\treturn cache_bitmap_v3;\nfail:\n\tfree_cache_bitmap_v3_order(update->context, cache_bitmap_v3);\n\treturn NULL;\n}",
        "start_line": 2120
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "libfreerdp/core/orders.c",
        "method_name": "update_read_cache_bitmap_v3_order",
        "raw_code": "static CACHE_BITMAP_V3_ORDER* update_read_cache_bitmap_v3_order(rdpUpdate* update, wStream* s, /* <=== update_read_cache_bitmap_v3_order */ \n                                                                UINT16 flags)\n{\n\tBYTE bitsPerPixelId;\n\tBITMAP_DATA_EX* bitmapData;\n\tUINT32 new_len;\n\tBYTE* new_data;\n\tCACHE_BITMAP_V3_ORDER* cache_bitmap_v3;\n\n\tif (!update || !s)\n\t\treturn NULL;\n\n\tcache_bitmap_v3 = calloc(1, sizeof(CACHE_BITMAP_V3_ORDER));\n\n\tif (!cache_bitmap_v3)\n\t\tgoto fail;\n\n\tcache_bitmap_v3->cacheId = flags & 0x00000003;\n\tcache_bitmap_v3->flags = (flags & 0x0000FF80) >> 7;\n\tbitsPerPixelId = (flags & 0x00000078) >> 3;\n\tcache_bitmap_v3->bpp = CBR23_BPP[bitsPerPixelId];\n\n\tif (Stream_GetRemainingLength(s) < 21)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, cache_bitmap_v3->cacheIndex); /* cacheIndex (2 bytes) */\n\tStream_Read_UINT32(s, cache_bitmap_v3->key1);       /* key1 (4 bytes) */\n\tStream_Read_UINT32(s, cache_bitmap_v3->key2);       /* key2 (4 bytes) */\n\tbitmapData = &cache_bitmap_v3->bitmapData;\n\tStream_Read_UINT8(s, bitmapData->bpp);\n\n\tif ((bitmapData->bpp < 1) || (bitmapData->bpp > 32))\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"invalid bpp value %\" PRIu32 \"\", bitmapData->bpp);\n\t\tgoto fail;\n\t}\n\n\tStream_Seek_UINT8(s);                      /* reserved1 (1 byte) */\n\tStream_Seek_UINT8(s);                      /* reserved2 (1 byte) */\n\tStream_Read_UINT8(s, bitmapData->codecID); /* codecID (1 byte) */\n\tStream_Read_UINT16(s, bitmapData->width);  /* width (2 bytes) */\n\tStream_Read_UINT16(s, bitmapData->height); /* height (2 bytes) */\n\tStream_Read_UINT32(s, new_len);            /* length (4 bytes) */\n\n\tif ((new_len == 0) || (Stream_GetRemainingLength(s) < new_len))\n\t\tgoto fail;\n\n\tnew_data = (BYTE*)realloc(bitmapData->data, new_len);\n\n\tif (!new_data)\n\t\tgoto fail;\n\n\tbitmapData->data = new_data;\n\tbitmapData->length = new_len;\n\tStream_Read(s, bitmapData->data, bitmapData->length);\n\treturn cache_bitmap_v3;\nfail:\n\tfree_cache_bitmap_v3_order(update->context, cache_bitmap_v3);\n\treturn NULL;\n}",
        "start_line": 2120
      }
    ],
    "code_context": "Called Methods:\n- free_cache_bitmap_v3_order: void free_cache_bitmap_v3_order(rdpContext* context, CACHE_BITMAP_V3_ORDER* order) /* <=== free_cache_bitmap_v3_order */ \n{\n\tif (order)\n\t\tfree(order->bitmapData.data);\n\n\tfree(order);\n}\n\nType Definitions:\n- rdpUpdate: typedef struct rdp_update rdpUpdate;\n- wStream: typedef struct _wStream wStream;\n\nGlobal Variables:\n- static const BYTE[] CBR23_BPP\n\nImports:\n- #include <freerdp/codec/bitmap.h>\n- #include \"../cache/brush.h\"\n- #include \"../cache/cache.h\"\n- #include <freerdp/gdi/gdi.h>\n- #include \"orders.h\"\n- #include \"../cache/bitmap.h\"\n- #include \"../cache/glyph.h\"\n- #include <freerdp/api.h>\n- #include <freerdp/log.h>\n- #include <winpr/wtypes.h>\n- #include <winpr/crt.h>\n- #include <freerdp/graphics.h>\n- #include \"config.h\"\n- #include \"window.h\"",
    "commit_msg": "Fixed #6013: Check new length is > 0",
    "cve_desc": "In FreeRDP greater than 1.2 and before 2.0.0, a double free in update_read_cache_bitmap_v3_order crashes the client application if corrupted data from a manipulated server is parsed. This has been patched in 2.0.0.",
    "year": 2020,
    "filename": "orders.c",
    "commit_url": "\"https://github.com/FreeRDP/FreeRDP/commit/67c2aa52b2ae0341d469071d1bc8aab91f8d2ed8\""
  },
  {
    "repository": "FreeRDP/FreeRDP",
    "cve_id": "CVE-2020-11045",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "f8890a645c221823ac133dbf991f8a65ae50d637",
    "short_hash": "f8890a64",
    "vulnerableMethods_before": [
      {
        "filename": "libfreerdp/core/update.c",
        "method_name": "update_read_bitmap_data",
        "raw_code": "static BOOL update_read_bitmap_data(rdpUpdate* update, wStream* s, BITMAP_DATA* bitmapData) /* <=== update_read_bitmap_data */ \n{\n\tWINPR_UNUSED(update);\n\tif (Stream_GetRemainingLength(s) < 18)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, bitmapData->destLeft);\n\tStream_Read_UINT16(s, bitmapData->destTop);\n\tStream_Read_UINT16(s, bitmapData->destRight);\n\tStream_Read_UINT16(s, bitmapData->destBottom);\n\tStream_Read_UINT16(s, bitmapData->width);\n\tStream_Read_UINT16(s, bitmapData->height);\n\tStream_Read_UINT16(s, bitmapData->bitsPerPixel);\n\tStream_Read_UINT16(s, bitmapData->flags);\n\tStream_Read_UINT16(s, bitmapData->bitmapLength);\n\n\tif (bitmapData->flags & BITMAP_COMPRESSION)\n\t{\n\t\tif (!(bitmapData->flags & NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbCompFirstRowSize); /* cbCompFirstRowSize (2 bytes) */\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbCompMainBodySize); /* cbCompMainBodySize (2 bytes) */\n\t\t\tStream_Read_UINT16(s, bitmapData->cbScanWidth);     /* cbScanWidth (2 bytes) */\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbUncompressedSize); /* cbUncompressedSize (2 bytes) */\n\t\t\tbitmapData->bitmapLength = bitmapData->cbCompMainBodySize;\n\t\t}\n\n\t\tbitmapData->compressed = TRUE;\n\t}\n\telse\n\t\tbitmapData->compressed = FALSE;\n\n\tif (Stream_GetRemainingLength(s) < bitmapData->bitmapLength)\n\t\treturn FALSE;\n\n\tif (bitmapData->bitmapLength > 0)\n\t{\n\t\tbitmapData->bitmapDataStream = malloc(bitmapData->bitmapLength);\n\n\t\tif (!bitmapData->bitmapDataStream)\n\t\t\treturn FALSE;\n\n\t\tmemcpy(bitmapData->bitmapDataStream, Stream_Pointer(s), bitmapData->bitmapLength);\n\t\tStream_Seek(s, bitmapData->bitmapLength);\n\t}\n\n\treturn TRUE;\n}",
        "start_line": 86
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "libfreerdp/core/update.c",
        "method_name": "update_read_bitmap_data",
        "raw_code": "static BOOL update_read_bitmap_data(rdpUpdate* update, wStream* s, BITMAP_DATA* bitmapData) /* <=== update_read_bitmap_data */ \n{\n\tWINPR_UNUSED(update);\n\tif (Stream_GetRemainingLength(s) < 18)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, bitmapData->destLeft);\n\tStream_Read_UINT16(s, bitmapData->destTop);\n\tStream_Read_UINT16(s, bitmapData->destRight);\n\tStream_Read_UINT16(s, bitmapData->destBottom);\n\tStream_Read_UINT16(s, bitmapData->width);\n\tStream_Read_UINT16(s, bitmapData->height);\n\tStream_Read_UINT16(s, bitmapData->bitsPerPixel);\n\tStream_Read_UINT16(s, bitmapData->flags);\n\tStream_Read_UINT16(s, bitmapData->bitmapLength);\n\n\tif (bitmapData->flags & BITMAP_COMPRESSION)\n\t{\n\t\tif (!(bitmapData->flags & NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\t\treturn FALSE;\n\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbCompFirstRowSize); /* cbCompFirstRowSize (2 bytes) */\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbCompMainBodySize); /* cbCompMainBodySize (2 bytes) */\n\t\t\tStream_Read_UINT16(s, bitmapData->cbScanWidth);     /* cbScanWidth (2 bytes) */\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbUncompressedSize); /* cbUncompressedSize (2 bytes) */\n\t\t\tbitmapData->bitmapLength = bitmapData->cbCompMainBodySize;\n\t\t}\n\n\t\tbitmapData->compressed = TRUE;\n\t}\n\telse\n\t\tbitmapData->compressed = FALSE;\n\n\tif (Stream_GetRemainingLength(s) < bitmapData->bitmapLength)\n\t\treturn FALSE;\n\n\tif (bitmapData->bitmapLength > 0)\n\t{\n\t\tbitmapData->bitmapDataStream = malloc(bitmapData->bitmapLength);\n\n\t\tif (!bitmapData->bitmapDataStream)\n\t\t\treturn FALSE;\n\n\t\tmemcpy(bitmapData->bitmapDataStream, Stream_Pointer(s), bitmapData->bitmapLength);\n\t\tStream_Seek(s, bitmapData->bitmapLength);\n\t}\n\n\treturn TRUE;\n}",
        "start_line": 86
      }
    ],
    "code_context": "Called Methods:\n- BITMAP_COMPRESSION: #define BITMAP_COMPRESSION 0x0001 /* <=== libfreerdp/core/update.h:38:38:BITMAP_COMPRESSION:0 */ \n- NO_BITMAP_COMPRESSION_HDR: #define NO_BITMAP_COMPRESSION_HDR 0x0400 /* <=== libfreerdp/core/update.h:39:39:NO_BITMAP_COMPRESSION_HDR:0 */ \n\nType Definitions:\n- BITMAP_DATA: typedef struct _BITMAP_DATA BITMAP_DATA;\n- wStream: typedef struct _wStream wStream;\n\nImports:\n- #include \"message.h\"\n- #include <freerdp/log.h>\n- #include <winpr/synch.h>\n- #include \"update.h\"\n- #include <freerdp/codec/bitmap.h>\n- #include \"../cache/palette.h\"\n- #include \"window.h\"\n- #include <winpr/crt.h>\n- #include <winpr/collections.h>\n- #include \"../cache/bitmap.h\"\n- #include \"info.h\"\n- #include \"surface.h\"\n- #include <freerdp/peer.h>\n- #include \"../cache/pointer.h\"\n- #include <winpr/thread.h>\n- #include \"config.h\"\n- #include <winpr/print.h>",
    "commit_msg": "Fixed #6005: Bounds checks in update_read_bitmap_data",
    "cve_desc": "In FreeRDP after 1.0 and before 2.0.0, there is an out-of-bound read in in update_read_bitmap_data that allows client memory to be read to an image buffer. The result displayed on screen as colour.",
    "year": 2020,
    "filename": "update.c",
    "commit_url": "\"https://github.com/FreeRDP/FreeRDP/commit/f8890a645c221823ac133dbf991f8a65ae50d637\""
  },
  {
    "repository": "FreeRDP/FreeRDP",
    "cve_id": "CVE-2020-11046",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "ed53cd148f43cbab905eaa0f5308c2bf3c48cc37",
    "short_hash": "ed53cd14",
    "vulnerableMethods_before": [
      {
        "filename": "libfreerdp/core/update.c",
        "method_name": "update_recv",
        "raw_code": "BOOL update_recv(rdpUpdate* update, wStream* s) /* <=== update_recv */ \n{\n\tBOOL rc = FALSE;\n\tUINT16 updateType;\n\trdpContext* context = update->context;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 2\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, updateType); /* updateType (2 bytes) */\n\tWLog_Print(update->log, WLOG_TRACE, \"%s Update Data PDU\", UPDATE_TYPE_STRINGS[updateType]);\n\n\tif (!update_begin_paint(update))\n\t\tgoto fail;\n\n\tswitch (updateType)\n\t{\n\t\tcase UPDATE_TYPE_ORDERS:\n\t\t\trc = update_recv_orders(update, s);\n\t\t\tbreak;\n\n\t\tcase UPDATE_TYPE_BITMAP:\n\t\t{\n\t\t\tBITMAP_UPDATE* bitmap_update = update_read_bitmap_update(update, s);\n\n\t\t\tif (!bitmap_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_BITMAP - update_read_bitmap_update() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\trc = IFCALLRESULT(FALSE, update->BitmapUpdate, context, bitmap_update);\n\t\t\tfree_bitmap_update(update->context, bitmap_update);\n\t\t}\n\t\tbreak;\n\n\t\tcase UPDATE_TYPE_PALETTE:\n\t\t{\n\t\t\tPALETTE_UPDATE* palette_update = update_read_palette(update, s);\n\n\t\t\tif (!palette_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_PALETTE - update_read_palette() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\trc = IFCALLRESULT(FALSE, update->Palette, context, palette_update);\n\t\t\tfree_palette_update(context, palette_update);\n\t\t}\n\t\tbreak;\n\n\t\tcase UPDATE_TYPE_SYNCHRONIZE:\n\t\t\tupdate_read_synchronize(update, s);\n\t\t\trc = IFCALLRESULT(TRUE, update->Synchronize, context);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\nfail:\n\n\tif (!update_end_paint(update))\n\t\trc = FALSE;\n\n\tif (!rc)\n\t{\n\t\tWLog_ERR(TAG, \"UPDATE_TYPE %s [%\" PRIu16 \"] failed\", update_type_to_string(updateType),\n\t\t         updateType);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}",
        "start_line": 755
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "libfreerdp/core/update.c",
        "method_name": "update_recv",
        "raw_code": "BOOL update_recv(rdpUpdate* update, wStream* s) /* <=== update_recv */ \n{\n\tBOOL rc = FALSE;\n\tUINT16 updateType;\n\trdpContext* context = update->context;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 2\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, updateType); /* updateType (2 bytes) */\n\tWLog_Print(update->log, WLOG_TRACE, \"%s Update Data PDU\", UPDATE_TYPE_STRINGS[updateType]);\n\n\tif (!update_begin_paint(update))\n\t\tgoto fail;\n\n\tswitch (updateType)\n\t{\n\t\tcase UPDATE_TYPE_ORDERS:\n\t\t\trc = update_recv_orders(update, s);\n\t\t\tbreak;\n\n\t\tcase UPDATE_TYPE_BITMAP:\n\t\t{\n\t\t\tBITMAP_UPDATE* bitmap_update = update_read_bitmap_update(update, s);\n\n\t\t\tif (!bitmap_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_BITMAP - update_read_bitmap_update() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\trc = IFCALLRESULT(FALSE, update->BitmapUpdate, context, bitmap_update);\n\t\t\tfree_bitmap_update(update->context, bitmap_update);\n\t\t}\n\t\tbreak;\n\n\t\tcase UPDATE_TYPE_PALETTE:\n\t\t{\n\t\t\tPALETTE_UPDATE* palette_update = update_read_palette(update, s);\n\n\t\t\tif (!palette_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_PALETTE - update_read_palette() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\trc = IFCALLRESULT(FALSE, update->Palette, context, palette_update);\n\t\t\tfree_palette_update(context, palette_update);\n\t\t}\n\t\tbreak;\n\n\t\tcase UPDATE_TYPE_SYNCHRONIZE:\n\t\t\tif (!update_read_synchronize(update, s))\n\t\t\t\tgoto fail;\n\t\t\trc = IFCALLRESULT(TRUE, update->Synchronize, context);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\nfail:\n\n\tif (!update_end_paint(update))\n\t\trc = FALSE;\n\n\tif (!rc)\n\t{\n\t\tWLog_ERR(TAG, \"UPDATE_TYPE %s [%\" PRIu16 \"] failed\", update_type_to_string(updateType),\n\t\t         updateType);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}",
        "start_line": 755
      }
    ],
    "code_context": "Called Methods:\n- update_end_paint: BOOL update_end_paint(rdpUpdate* update) /* <=== update_end_paint */ \n{\n\tBOOL rc = FALSE;\n\n\tif (!update)\n\t\treturn FALSE;\n\n\tif (update->EndPaint)\n\t\trc = update->EndPaint(update->context);\n\n\tLeaveCriticalSection(&update->mux);\n\treturn rc;\n}\n- update_read_synchronize: static void update_read_synchronize(rdpUpdate* update, wStream* s) /* <=== update_read_synchronize */ \n{\n\tWINPR_UNUSED(update);\n\tStream_Seek_UINT16(s); /* pad2Octets (2 bytes) */\n\t                       /**\n\t                        * The Synchronize Update is an artifact from the\n\t                        * T.128 protocol and should be ignored.\n\t                        */\n}\n- update_begin_paint: BOOL update_begin_paint(rdpUpdate* update) /* <=== update_begin_paint */ \n{\n\tif (!update)\n\t\treturn FALSE;\n\n\tEnterCriticalSection(&update->mux);\n\n\tif (!update->BeginPaint)\n\t\treturn TRUE;\n\n\treturn update->BeginPaint(update->context);\n}\n- LeaveCriticalSection: \tWINPR_API VOID LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection); /* <=== LeaveCriticalSection */ \n- update_read_synchronize: static BOOL update_read_synchronize(rdpUpdate* update, wStream* s) /* <=== update_read_synchronize */ \n{\n\tWINPR_UNUSED(update);\n\treturn Stream_SafeSeek(s, 2); /* pad2Octets (2 bytes) */\n\t                              /**\n\t                               * The Synchronize Update is an artifact from the\n\t                               * T.128 protocol and should be ignored.\n\t                               */\n}\n- EnterCriticalSection: \tWINPR_API VOID EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection); /* <=== EnterCriticalSection */ \n\nType Definitions:\n- rdpUpdate: typedef struct rdp_update rdpUpdate;\n- wStream: typedef struct _wStream wStream;\n- rdpContext: typedef struct rdp_context rdpContext;\n\nGlobal Variables:\n- static const char * const[] UPDATE_TYPE_STRINGS\n\nImports:\n- #include \"window.h\"\n- #include \"surface.h\"\n- #include \"../cache/palette.h\"\n- #include <winpr/crt.h>\n- #include <winpr/print.h>\n- #include \"update.h\"\n- #include \"info.h\"\n- #include \"../cache/pointer.h\"\n- #include <freerdp/codec/bitmap.h>\n- #include \"../cache/bitmap.h\"\n- #include \"message.h\"\n- #include <freerdp/peer.h>\n- #include <winpr/collections.h>\n- #include <winpr/thread.h>\n- #include \"config.h\"\n- #include <winpr/synch.h>\n- #include <freerdp/log.h>",
    "commit_msg": "Fixed #6006: bounds checks in update_read_synchronize",
    "cve_desc": "In FreeRDP after 1.0 and before 2.0.0, there is a stream out-of-bounds seek in update_read_synchronize that could lead to a later out-of-bounds read.",
    "year": 2020,
    "filename": "update.c",
    "commit_url": "\"https://github.com/FreeRDP/FreeRDP/commit/ed53cd148f43cbab905eaa0f5308c2bf3c48cc37\""
  },
  {
    "repository": "FreeRDP/FreeRDP",
    "cve_id": "CVE-2020-11047",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "f5e73cc7c9cd973b516a618da877c87b80950b65",
    "short_hash": "f5e73cc7",
    "vulnerableMethods_before": [
      {
        "filename": "libfreerdp/core/autodetect.c",
        "method_name": "autodetect_recv_bandwidth_measure_results",
        "raw_code": "static BOOL autodetect_recv_bandwidth_measure_results(rdpRdp* rdp, wStream* s, /* <=== autodetect_recv_bandwidth_measure_results */ \n                                                      AUTODETECT_RSP_PDU* autodetectRspPdu)\n{\n\tBOOL success = TRUE;\n\n\tif (autodetectRspPdu->headerLength != 0x0E)\n\t\treturn FALSE;\n\n\tWLog_VRB(AUTODETECT_TAG, \"received Bandwidth Measure Results PDU\");\n\tStream_Read_UINT32(s, rdp->autodetect->bandwidthMeasureTimeDelta); /* timeDelta (4 bytes) */\n\tStream_Read_UINT32(s, rdp->autodetect->bandwidthMeasureByteCount); /* byteCount (4 bytes) */\n\n\tif (rdp->autodetect->bandwidthMeasureTimeDelta > 0)\n\t\trdp->autodetect->netCharBandwidth = rdp->autodetect->bandwidthMeasureByteCount * 8 /\n\t\t                                    rdp->autodetect->bandwidthMeasureTimeDelta;\n\telse\n\t\trdp->autodetect->netCharBandwidth = 0;\n\n\tIFCALLRET(rdp->autodetect->BandwidthMeasureResults, success, rdp->context,\n\t          autodetectRspPdu->sequenceNumber);\n\treturn success;\n}",
        "start_line": 459
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "libfreerdp/core/autodetect.c",
        "method_name": "autodetect_recv_bandwidth_measure_results",
        "raw_code": "static BOOL autodetect_recv_bandwidth_measure_results(rdpRdp* rdp, wStream* s, /* <=== autodetect_recv_bandwidth_measure_results */ \n                                                      AUTODETECT_RSP_PDU* autodetectRspPdu)\n{\n\tBOOL success = TRUE;\n\n\tif (autodetectRspPdu->headerLength != 0x0E)\n\t\treturn FALSE;\n\n\tWLog_VRB(AUTODETECT_TAG, \"received Bandwidth Measure Results PDU\");\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn -1;\n\tStream_Read_UINT32(s, rdp->autodetect->bandwidthMeasureTimeDelta); /* timeDelta (4 bytes) */\n\tStream_Read_UINT32(s, rdp->autodetect->bandwidthMeasureByteCount); /* byteCount (4 bytes) */\n\n\tif (rdp->autodetect->bandwidthMeasureTimeDelta > 0)\n\t\trdp->autodetect->netCharBandwidth = rdp->autodetect->bandwidthMeasureByteCount * 8 /\n\t\t                                    rdp->autodetect->bandwidthMeasureTimeDelta;\n\telse\n\t\trdp->autodetect->netCharBandwidth = 0;\n\n\tIFCALLRET(rdp->autodetect->BandwidthMeasureResults, success, rdp->context,\n\t          autodetectRspPdu->sequenceNumber);\n\treturn success;\n}",
        "start_line": 459
      }
    ],
    "code_context": "Type Definitions:\n- wStream: typedef struct _wStream wStream;\n- AUTODETECT_RSP_PDU: typedef struct\n{\n\tUINT8 headerLength;\n\tUINT8 headerTypeId;\n\tUINT16 sequenceNumber;\n\tUINT16 responseType;\n}\n- rdpRdp: typedef struct rdp_rdp rdpRdp;\n\nImports:\n- #include \"autodetect.h\"\n- #include \"config.h\"\n- #include <winpr/crypto.h>",
    "commit_msg": "Fixed #6009: Bounds checks in autodetect_recv_bandwidth_measure_results",
    "cve_desc": "In FreeRDP after 1.1 and before 2.0.0, there is an out-of-bounds read in autodetect_recv_bandwidth_measure_results. A malicious server can extract up to 8 bytes of client memory with a manipulated message by providing a short input and reading the measurement result data. This has been patched in 2.0.0.",
    "year": 2020,
    "filename": "autodetect.c",
    "commit_url": "\"https://github.com/FreeRDP/FreeRDP/commit/f5e73cc7c9cd973b516a618da877c87b80950b65\""
  },
  {
    "repository": "FreeRDP/FreeRDP",
    "cve_id": "CVE-2020-11048",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "9301bfe730c66180263248b74353daa99f5a969b",
    "short_hash": "9301bfe7",
    "vulnerableMethods_before": [
      {
        "filename": "libfreerdp/core/rdp.c",
        "method_name": "rdp_read_share_control_header",
        "raw_code": "BOOL rdp_read_share_control_header(wStream* s, UINT16* length, UINT16* type, UINT16* channel_id) /* <=== rdp_read_share_control_header */ \n{\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\treturn FALSE;\n\n\t/* Share Control Header */\n\tStream_Read_UINT16(s, *length); /* totalLength */\n\n\t/* If length is 0x8000 then we actually got a flow control PDU that we should ignore\n\t http://msdn.microsoft.com/en-us/library/cc240576.aspx */\n\tif (*length == 0x8000)\n\t{\n\t\trdp_read_flow_control_pdu(s, type);\n\t\t*channel_id = 0;\n\t\t*length = 8; /* Flow control PDU is 8 bytes */\n\t\treturn TRUE;\n\t}\n\n\tif (((size_t)*length - 2) > Stream_GetRemainingLength(s))\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, *type); /* pduType */\n\t*type &= 0x0F;                /* type is in the 4 least significant bits */\n\n\tif (*length > 4)\n\t\tStream_Read_UINT16(s, *channel_id); /* pduSource */\n\telse\n\t\t*channel_id = 0; /* Windows XP can send such short DEACTIVATE_ALL PDUs. */\n\n\treturn TRUE;\n}",
        "start_line": 146
      },
      {
        "filename": "libfreerdp/core/rdp.c",
        "method_name": "rdp_read_flow_control_pdu",
        "raw_code": "void rdp_read_flow_control_pdu(wStream* s, UINT16* type) /* <=== rdp_read_flow_control_pdu */ \n{\n\t/*\n\t * Read flow control PDU - documented in FlowPDU section in T.128\n\t * http://www.itu.int/rec/T-REC-T.128-199802-S/en\n\t * The specification for the PDU has pad8bits listed BEFORE pduTypeFlow.\n\t * However, so far pad8bits has always been observed to arrive AFTER pduTypeFlow.\n\t * Switched the order of these two fields to match this observation.\n\t */\n\tUINT8 pduType;\n\tStream_Read_UINT8(s, pduType); /* pduTypeFlow */\n\t*type = pduType;\n\tStream_Seek_UINT8(s);  /* pad8bits */\n\tStream_Seek_UINT8(s);  /* flowIdentifier */\n\tStream_Seek_UINT8(s);  /* flowNumber */\n\tStream_Seek_UINT16(s); /* pduSource */\n}",
        "start_line": 1119
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "libfreerdp/core/rdp.c",
        "method_name": "rdp_read_share_control_header",
        "raw_code": "BOOL rdp_read_share_control_header(wStream* s, UINT16* length, UINT16* type, UINT16* channel_id) /* <=== rdp_read_share_control_header */ \n{\n\tUINT16 len;\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\treturn FALSE;\n\n\t/* Share Control Header */\n\tStream_Read_UINT16(s, len); /* totalLength */\n\n\t*length = len;\n\n\t/* If length is 0x8000 then we actually got a flow control PDU that we should ignore\n\t http://msdn.microsoft.com/en-us/library/cc240576.aspx */\n\tif (len == 0x8000)\n\t{\n\t\tif (!rdp_read_flow_control_pdu(s, type))\n\t\t\treturn FALSE;\n\t\t*channel_id = 0;\n\t\t*length = 8; /* Flow control PDU is 8 bytes */\n\t\treturn TRUE;\n\t}\n\n\tif ((len < 4) || ((len - 2) > Stream_GetRemainingLength(s)))\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, *type); /* pduType */\n\t*type &= 0x0F;                /* type is in the 4 least significant bits */\n\n\tif (len > 4)\n\t\tStream_Read_UINT16(s, *channel_id); /* pduSource */\n\telse\n\t\t*channel_id = 0; /* Windows XP can send such short DEACTIVATE_ALL PDUs. */\n\n\treturn TRUE;\n}",
        "start_line": 146
      },
      {
        "filename": "libfreerdp/core/rdp.c",
        "method_name": "rdp_read_flow_control_pdu",
        "raw_code": "BOOL rdp_read_flow_control_pdu(wStream* s, UINT16* type) /* <=== rdp_read_flow_control_pdu */ \n{\n\t/*\n\t * Read flow control PDU - documented in FlowPDU section in T.128\n\t * http://www.itu.int/rec/T-REC-T.128-199802-S/en\n\t * The specification for the PDU has pad8bits listed BEFORE pduTypeFlow.\n\t * However, so far pad8bits has always been observed to arrive AFTER pduTypeFlow.\n\t * Switched the order of these two fields to match this observation.\n\t */\n\tUINT8 pduType;\n\tif (!type)\n\t\treturn FALSE;\n\tif (Stream_GetRemainingLength(s) < 6)\n\t\treturn FALSE;\n\tStream_Read_UINT8(s, pduType); /* pduTypeFlow */\n\t*type = pduType;\n\tStream_Seek_UINT8(s);  /* pad8bits */\n\tStream_Seek_UINT8(s);  /* flowIdentifier */\n\tStream_Seek_UINT8(s);  /* flowNumber */\n\tStream_Seek_UINT16(s); /* pduSource */\n\treturn TRUE;\n}",
        "start_line": 1123
      }
    ],
    "code_context": "Type Definitions:\n- wStream: typedef struct _wStream wStream;\n\nImports:\n- #include <freerdp/crypto/per.h>\n- #include \"rdp.h\"\n- #include \"config.h\"\n- #include \"redirection.h\"\n- #include <winpr/crt.h>\n- #include <freerdp/log.h>\n- #include \"info.h\"",
    "commit_msg": "Fixed #6007: Boundary checks in rdp_read_flow_control_pdu",
    "cve_desc": "[{'lang': 'en', 'value': 'In FreeRDP after 1.0 and before 2.0.0, there is an out-of-bounds read. It only allows to abort a session. No data extraction is possible. This has been fixed in 2.0.0.'}]",
    "year": 2020,
    "filename": "rdp.c",
    "commit_url": "\"https://github.com/FreeRDP/FreeRDP/commit/9301bfe730c66180263248b74353daa99f5a969b\""
  },
  {
    "repository": "FreeRDP/FreeRDP",
    "cve_id": "CVE-2020-11058",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "3627aaf7d289315b614a584afb388f04abfb5bbf",
    "short_hash": "3627aaf7",
    "vulnerableMethods_before": [
      {
        "filename": "libfreerdp/core/capabilities.c",
        "method_name": "rdp_read_font_capability_set",
        "raw_code": "static BOOL rdp_read_font_capability_set(wStream* s, UINT16 length, rdpSettings* settings) /* <=== rdp_read_font_capability_set */ \n{\n\tWINPR_UNUSED(settings);\n\tif (length > 4)\n\t\tStream_Seek_UINT16(s); /* fontSupportFlags (2 bytes) */\n\n\tif (length > 6)\n\t\tStream_Seek_UINT16(s); /* pad2Octets (2 bytes) */\n\n\treturn TRUE;\n}",
        "start_line": 1397
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "libfreerdp/core/capabilities.c",
        "method_name": "rdp_read_font_capability_set",
        "raw_code": "static BOOL rdp_read_font_capability_set(wStream* s, UINT16 length, rdpSettings* settings) /* <=== rdp_read_font_capability_set */ \n{\n\tWINPR_UNUSED(settings);\n\tif (length > 5)\n\t\tStream_Seek_UINT16(s); /* fontSupportFlags (2 bytes) */\n\n\tif (length > 7)\n\t\tStream_Seek_UINT16(s); /* pad2Octets (2 bytes) */\n\n\treturn TRUE;\n}",
        "start_line": 1397
      }
    ],
    "code_context": "Type Definitions:\n- wStream: typedef struct _wStream wStream;\n\nImports:\n- #include \"fastpath.h\"\n- #include <freerdp/log.h>\n- #include \"capabilities.h\"\n- #include \"config.h\"\n- #include <winpr/rpc.h>\n- #include <winpr/crt.h>",
    "commit_msg": "Fixed #6011: Bounds check in rdp_read_font_capability_set",
    "cve_desc": "In FreeRDP after 1.1 and before 2.0.0, a stream out-of-bounds seek in rdp_read_font_capability_set could lead to a later out-of-bounds read. As a result, a manipulated client or server might force a disconnect due to an invalid data read. This has been fixed in 2.0.0.",
    "year": 2020,
    "filename": "capabilities.c",
    "commit_url": "\"https://github.com/FreeRDP/FreeRDP/commit/3627aaf7d289315b614a584afb388f04abfb5bbf\""
  },
  {
    "repository": "FreeRDP/FreeRDP",
    "cve_id": "CVE-2020-11085",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "b73143cf7ee5fe4cdabcbf56908aa15d8a883821",
    "short_hash": "b73143cf",
    "vulnerableMethods_before": [
      {
        "filename": "channels/cliprdr/cliprdr_common.c",
        "method_name": "cliprdr_read_format_list",
        "raw_code": "UINT cliprdr_read_format_list(wStream* s, CLIPRDR_FORMAT_LIST* formatList, BOOL useLongFormatNames) /* <=== cliprdr_read_format_list */ \n{\n\tUINT32 index;\n\tsize_t position;\n\tBOOL asciiNames;\n\tint formatNameLength;\n\tchar* szFormatName;\n\tWCHAR* wszFormatName;\n\tUINT32 dataLen = formatList->dataLen;\n\tCLIPRDR_FORMAT* formats = NULL;\n\tUINT error = CHANNEL_RC_OK;\n\n\tasciiNames = (formatList->msgFlags & CB_ASCII_NAMES) ? TRUE : FALSE;\n\n\tindex = 0;\n\tformatList->numFormats = 0;\n\tposition = Stream_GetPosition(s);\n\n\tif (!formatList->dataLen)\n\t{\n\t\t/* empty format list */\n\t\tformatList->formats = NULL;\n\t\tformatList->numFormats = 0;\n\t}\n\telse if (!useLongFormatNames)\n\t{\n\t\tformatList->numFormats = (dataLen / 36);\n\n\t\tif ((formatList->numFormats * 36) != dataLen)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Invalid short format list length: %\" PRIu32 \"\", dataLen);\n\t\t\treturn ERROR_INTERNAL_ERROR;\n\t\t}\n\n\t\tif (formatList->numFormats)\n\t\t\tformats = (CLIPRDR_FORMAT*)calloc(formatList->numFormats, sizeof(CLIPRDR_FORMAT));\n\n\t\tif (!formats)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\n\t\tformatList->formats = formats;\n\n\t\twhile (dataLen)\n\t\t{\n\t\t\tStream_Read_UINT32(s, formats[index].formatId); /* formatId (4 bytes) */\n\t\t\tdataLen -= 4;\n\n\t\t\tformats[index].formatName = NULL;\n\n\t\t\t/* According to MS-RDPECLIP 2.2.3.1.1.1 formatName is \"a 32-byte block containing\n\t\t\t * the *null-terminated* name assigned to the Clipboard Format: (32 ASCII 8 characters\n\t\t\t * or 16 Unicode characters)\"\n\t\t\t * However, both Windows RDSH and mstsc violate this specs as seen in the following\n\t\t\t * example of a transferred short format name string: [R.i.c.h. .T.e.x.t. .F.o.r.m.a.t.]\n\t\t\t * These are 16 unicode charaters - *without* terminating null !\n\t\t\t */\n\n\t\t\tif (asciiNames)\n\t\t\t{\n\t\t\t\tszFormatName = (char*)Stream_Pointer(s);\n\n\t\t\t\tif (szFormatName[0])\n\t\t\t\t{\n\t\t\t\t\t/* ensure null termination */\n\t\t\t\t\tformats[index].formatName = (char*)malloc(32 + 1);\n\t\t\t\t\tif (!formats[index].formatName)\n\t\t\t\t\t{\n\t\t\t\t\t\tWLog_ERR(TAG, \"malloc failed!\");\n\t\t\t\t\t\terror = CHANNEL_RC_NO_MEMORY;\n\t\t\t\t\t\tgoto error_out;\n\t\t\t\t\t}\n\t\t\t\t\tCopyMemory(formats[index].formatName, szFormatName, 32);\n\t\t\t\t\tformats[index].formatName[32] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twszFormatName = (WCHAR*)Stream_Pointer(s);\n\n\t\t\t\tif (wszFormatName[0])\n\t\t\t\t{\n\t\t\t\t\t/* ConvertFromUnicode always returns a null-terminated\n\t\t\t\t\t * string on success, even if the source string isn't.\n\t\t\t\t\t */\n\t\t\t\t\tif (ConvertFromUnicode(CP_UTF8, 0, wszFormatName, 16,\n\t\t\t\t\t                       &(formats[index].formatName), 0, NULL, NULL) < 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tWLog_ERR(TAG, \"failed to convert short clipboard format name\");\n\t\t\t\t\t\terror = ERROR_INTERNAL_ERROR;\n\t\t\t\t\t\tgoto error_out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tStream_Seek(s, 32);\n\t\t\tdataLen -= 32;\n\t\t\tindex++;\n\t\t}\n\t}\n\telse\n\t{\n\t\twhile (dataLen)\n\t\t{\n\t\t\tStream_Seek(s, 4); /* formatId (4 bytes) */\n\t\t\tdataLen -= 4;\n\n\t\t\twszFormatName = (WCHAR*)Stream_Pointer(s);\n\n\t\t\tif (!wszFormatName[0])\n\t\t\t\tformatNameLength = 0;\n\t\t\telse\n\t\t\t\tformatNameLength = _wcslen(wszFormatName);\n\n\t\t\tStream_Seek(s, (formatNameLength + 1) * 2);\n\t\t\tdataLen -= ((formatNameLength + 1) * 2);\n\n\t\t\tformatList->numFormats++;\n\t\t}\n\n\t\tdataLen = formatList->dataLen;\n\t\tStream_SetPosition(s, position);\n\n\t\tif (formatList->numFormats)\n\t\t\tformats = (CLIPRDR_FORMAT*)calloc(formatList->numFormats, sizeof(CLIPRDR_FORMAT));\n\n\t\tif (!formats)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\n\t\tformatList->formats = formats;\n\n\t\twhile (dataLen)\n\t\t{\n\t\t\tStream_Read_UINT32(s, formats[index].formatId); /* formatId (4 bytes) */\n\t\t\tdataLen -= 4;\n\n\t\t\tformats[index].formatName = NULL;\n\n\t\t\twszFormatName = (WCHAR*)Stream_Pointer(s);\n\n\t\t\tif (!wszFormatName[0])\n\t\t\t\tformatNameLength = 0;\n\t\t\telse\n\t\t\t\tformatNameLength = _wcslen(wszFormatName);\n\n\t\t\tif (formatNameLength)\n\t\t\t{\n\t\t\t\tif (ConvertFromUnicode(CP_UTF8, 0, wszFormatName, -1, &(formats[index].formatName),\n\t\t\t\t                       0, NULL, NULL) < 1)\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG, \"failed to convert long clipboard format name\");\n\t\t\t\t\terror = ERROR_INTERNAL_ERROR;\n\t\t\t\t\tgoto error_out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tStream_Seek(s, (formatNameLength + 1) * 2);\n\t\t\tdataLen -= ((formatNameLength + 1) * 2);\n\n\t\t\tindex++;\n\t\t}\n\t}\n\n\treturn error;\n\nerror_out:\n\tcliprdr_free_format_list(formatList);\n\treturn error;\n}",
        "start_line": 395
      },
      {
        "filename": "channels/cliprdr/cliprdr_common.c",
        "method_name": "cliprdr_free_format_list",
        "raw_code": "void cliprdr_free_format_list(CLIPRDR_FORMAT_LIST* formatList) /* <=== cliprdr_free_format_list */ \n{\n\tUINT index = 0;\n\n\tif (formatList == NULL)\n\t\treturn;\n\n\tif (formatList->formats)\n\t{\n\t\tfor (index = 0; index < formatList->numFormats; index++)\n\t\t{\n\t\t\tfree(formatList->formats[index].formatName);\n\t\t}\n\n\t\tfree(formatList->formats);\n\t}\n}",
        "start_line": 570
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "channels/cliprdr/cliprdr_common.c",
        "method_name": "cliprdr_read_format_list",
        "raw_code": "UINT cliprdr_read_format_list(wStream* s, CLIPRDR_FORMAT_LIST* formatList, BOOL useLongFormatNames) /* <=== cliprdr_read_format_list */ \n{\n\tUINT32 index;\n\tsize_t position;\n\tBOOL asciiNames;\n\tint formatNameLength;\n\tchar* szFormatName;\n\tWCHAR* wszFormatName;\n\twStream sub1, sub2;\n\tCLIPRDR_FORMAT* formats = NULL;\n\tUINT error = CHANNEL_RC_OK;\n\n\tasciiNames = (formatList->msgFlags & CB_ASCII_NAMES) ? TRUE : FALSE;\n\n\tindex = 0;\n\t/* empty format list */\n\tformatList->formats = NULL;\n\tformatList->numFormats = 0;\n\n\tStream_StaticInit(&sub1, Stream_Pointer(s), formatList->dataLen);\n\tif (!Stream_SafeSeek(s, formatList->dataLen))\n\t\treturn ERROR_INVALID_DATA;\n\n\tif (!formatList->dataLen)\n\t{\n\t}\n\telse if (!useLongFormatNames)\n\t{\n\t\tconst size_t cap = Stream_Capacity(&sub1);\n\t\tformatList->numFormats = (cap / 36);\n\n\t\tif ((formatList->numFormats * 36) != cap)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Invalid short format list length: %\" PRIuz \"\", cap);\n\t\t\treturn ERROR_INTERNAL_ERROR;\n\t\t}\n\n\t\tif (formatList->numFormats)\n\t\t\tformats = (CLIPRDR_FORMAT*)calloc(formatList->numFormats, sizeof(CLIPRDR_FORMAT));\n\n\t\tif (!formats)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\n\t\tformatList->formats = formats;\n\n\t\twhile (Stream_GetRemainingLength(&sub1) >= 4)\n\t\t{\n\t\t\tStream_Read_UINT32(&sub1, formats[index].formatId); /* formatId (4 bytes) */\n\n\t\t\tformats[index].formatName = NULL;\n\n\t\t\t/* According to MS-RDPECLIP 2.2.3.1.1.1 formatName is \"a 32-byte block containing\n\t\t\t * the *null-terminated* name assigned to the Clipboard Format: (32 ASCII 8 characters\n\t\t\t * or 16 Unicode characters)\"\n\t\t\t * However, both Windows RDSH and mstsc violate this specs as seen in the following\n\t\t\t * example of a transferred short format name string: [R.i.c.h. .T.e.x.t. .F.o.r.m.a.t.]\n\t\t\t * These are 16 unicode charaters - *without* terminating null !\n\t\t\t */\n\n\t\t\tszFormatName = (char*)Stream_Pointer(&sub1);\n\t\t\twszFormatName = (WCHAR*)Stream_Pointer(&sub1);\n\t\t\tif (!Stream_SafeSeek(&sub1, 32))\n\t\t\t\tgoto error_out;\n\t\t\tif (asciiNames)\n\t\t\t{\n\t\t\t\tif (szFormatName[0])\n\t\t\t\t{\n\t\t\t\t\t/* ensure null termination */\n\t\t\t\t\tformats[index].formatName = (char*)malloc(32 + 1);\n\t\t\t\t\tif (!formats[index].formatName)\n\t\t\t\t\t{\n\t\t\t\t\t\tWLog_ERR(TAG, \"malloc failed!\");\n\t\t\t\t\t\terror = CHANNEL_RC_NO_MEMORY;\n\t\t\t\t\t\tgoto error_out;\n\t\t\t\t\t}\n\t\t\t\t\tCopyMemory(formats[index].formatName, szFormatName, 32);\n\t\t\t\t\tformats[index].formatName[32] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (wszFormatName[0])\n\t\t\t\t{\n\t\t\t\t\t/* ConvertFromUnicode always returns a null-terminated\n\t\t\t\t\t * string on success, even if the source string isn't.\n\t\t\t\t\t */\n\t\t\t\t\tif (ConvertFromUnicode(CP_UTF8, 0, wszFormatName, 16,\n\t\t\t\t\t                       &(formats[index].formatName), 0, NULL, NULL) < 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tWLog_ERR(TAG, \"failed to convert short clipboard format name\");\n\t\t\t\t\t\terror = ERROR_INTERNAL_ERROR;\n\t\t\t\t\t\tgoto error_out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tindex++;\n\t\t}\n\t}\n\telse\n\t{\n\t\tsub2 = sub1;\n\t\twhile (Stream_GetRemainingLength(&sub1) > 0)\n\t\t{\n\t\t\tsize_t rest;\n\t\t\tif (!Stream_SafeSeek(&sub1, 4)) /* formatId (4 bytes) */\n\t\t\t\tgoto error_out;\n\n\t\t\twszFormatName = (WCHAR*)Stream_Pointer(&sub1);\n\t\t\trest = Stream_GetRemainingLength(&sub1);\n\t\t\tformatNameLength = _wcsnlen(wszFormatName, rest / sizeof(WCHAR));\n\n\t\t\tif (!Stream_SafeSeek(&sub1, (formatNameLength + 1) * sizeof(WCHAR)))\n\t\t\t\tgoto error_out;\n\t\t\tformatList->numFormats++;\n\t\t}\n\n\t\tif (formatList->numFormats)\n\t\t\tformats = (CLIPRDR_FORMAT*)calloc(formatList->numFormats, sizeof(CLIPRDR_FORMAT));\n\n\t\tif (!formats)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\n\t\tformatList->formats = formats;\n\n\t\twhile (Stream_GetRemainingLength(&sub2) >= 4)\n\t\t{\n\t\t\tsize_t rest;\n\t\t\tStream_Read_UINT32(&sub2, formats[index].formatId); /* formatId (4 bytes) */\n\n\t\t\tformats[index].formatName = NULL;\n\n\t\t\twszFormatName = (WCHAR*)Stream_Pointer(&sub2);\n\t\t\trest = Stream_GetRemainingLength(&sub2);\n\t\t\tformatNameLength = _wcsnlen(wszFormatName, rest / sizeof(WCHAR));\n\t\t\tif (!Stream_SafeSeek(&sub2, (formatNameLength + 1) * sizeof(WCHAR)))\n\t\t\t\tgoto error_out;\n\n\t\t\tif (formatNameLength)\n\t\t\t{\n\t\t\t\tif (ConvertFromUnicode(CP_UTF8, 0, wszFormatName, formatNameLength,\n\t\t\t\t                       &(formats[index].formatName), 0, NULL, NULL) < 1)\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG, \"failed to convert long clipboard format name\");\n\t\t\t\t\terror = ERROR_INTERNAL_ERROR;\n\t\t\t\t\tgoto error_out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tindex++;\n\t\t}\n\t}\n\n\treturn error;\n\nerror_out:\n\tcliprdr_free_format_list(formatList);\n\treturn error;\n}",
        "start_line": 395
      },
      {
        "filename": "channels/cliprdr/cliprdr_common.c",
        "method_name": "cliprdr_free_format_list",
        "raw_code": "void cliprdr_free_format_list(CLIPRDR_FORMAT_LIST* formatList) /* <=== cliprdr_free_format_list */ \n{\n\tUINT index = 0;\n\n\tif (formatList == NULL)\n\t\treturn;\n\n\tif (formatList->formats)\n\t{\n\t\tfor (index = 0; index < formatList->numFormats; index++)\n\t\t{\n\t\t\tfree(formatList->formats[index].formatName);\n\t\t}\n\n\t\tfree(formatList->formats);\n\t\tformatList->formats = NULL;\n\t\tformatList->numFormats = 0;\n\t}\n}",
        "start_line": 561
      }
    ],
    "code_context": "Called Methods:\n- WideCharToMultiByte: int WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, /* <=== WideCharToMultiByte */ \n                        LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar,\n                        LPBOOL lpUsedDefaultChar)\n{\n#if !defined(WITH_ICU)\n\tint length;\n\tconst WCHAR* sourceStart;\n\tConversionResult result;\n\tBYTE* targetStart;\n#else\n\tchar* targetStart;\n#endif\n\n\t/* If cchWideChar is 0, the function fails */\n\n\tif ((cchWideChar == 0) || (cchWideChar < -1))\n\t\treturn 0;\n\n\t/* If cchWideChar is -1, the string is null-terminated */\n\n\tif (cchWideChar == -1)\n\t{\n\t\tsize_t len = _wcslen(lpWideCharStr);\n\t\tif (len >= INT32_MAX)\n\t\t\treturn 0;\n\t\tcchWideChar = (int)len + 1;\n\t}\n\n\t/*\n\t * if cbMultiByte is 0, the function returns the required buffer size\n\t * in bytes for lpMultiByteStr and makes no use of the output parameter itself.\n\t */\n#if defined(WITH_ICU)\n\t{\n\t\tUErrorCode error;\n\t\tint32_t targetLength;\n\t\tint32_t targetCapacity;\n\n\t\tswitch (CodePage)\n\t\t{\n\t\t\tcase CP_ACP:\n\t\t\tcase CP_UTF8:\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tWLog_ERR(TAG, \"Unsupported encoding %u\", CodePage);\n\t\t\t\treturn 0;\n\t\t}\n\n\t\ttargetStart = lpMultiByteStr;\n\t\ttargetCapacity = cbMultiByte;\n\t\terror = U_ZERO_ERROR;\n\n\t\tif (cbMultiByte == 0)\n\t\t{\n\t\t\tu_strToUTF8(NULL, 0, &targetLength, lpWideCharStr, cchWideChar, &error);\n\t\t\tcbMultiByte = targetLength;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tu_strToUTF8(targetStart, targetCapacity, &targetLength, lpWideCharStr, cchWideChar,\n\t\t\t            &error);\n\t\t\tcbMultiByte = U_SUCCESS(error) ? targetLength : 0;\n\t\t}\n\t}\n#else\n\n\tif (cbMultiByte == 0)\n\t{\n\t\tsourceStart = (WCHAR*)lpWideCharStr;\n\t\ttargetStart = (BYTE*)NULL;\n\t\tresult = ConvertUTF16toUTF8(&sourceStart, &sourceStart[cchWideChar], &targetStart, NULL,\n\t\t                            strictConversion);\n\t\tlength = targetStart - ((BYTE*)NULL);\n\t}\n\telse\n\t{\n\t\tsourceStart = (WCHAR*)lpWideCharStr;\n\t\ttargetStart = (BYTE*)lpMultiByteStr;\n\t\tresult = ConvertUTF16toUTF8(&sourceStart, &sourceStart[cchWideChar], &targetStart,\n\t\t                            &targetStart[cbMultiByte], strictConversion);\n\t\tlength = targetStart - ((BYTE*)lpMultiByteStr);\n\t}\n\n\tcbMultiByte = (result == conversionOK) ? length : 0;\n#endif\n\treturn cbMultiByte;\n}\n- _wcsnlen: \tWINPR_API size_t _wcsnlen(const WCHAR* str, size_t maxNumberOfElements); /* <=== _wcsnlen */ \n- _wcslen: \tWINPR_API size_t _wcslen(const WCHAR* str); /* <=== _wcslen */ \n- TAG: #define TAG CHANNELS_TAG(\"cliprdr.common\") /* <=== channels/cliprdr/cliprdr_common.c:27:27:TAG:0 */ \n- Stream_StaticInit: void Stream_StaticInit(wStream* s, BYTE* buffer, size_t size) /* <=== Stream_StaticInit */ \n{\n\tassert(s);\n\tassert(buffer);\n\n\ts->buffer = s->pointer = buffer;\n\ts->capacity = s->length = size;\n\ts->pool = NULL;\n\ts->count = 0;\n\ts->isAllocatedStream = FALSE;\n\ts->isOwner = FALSE;\n}\n- _wcslen: \tWINPR_API size_t _wcslen(const WCHAR* str); /* <=== _wcslen */ \n- ConvertFromUnicode: int ConvertFromUnicode(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, /* <=== ConvertFromUnicode */ \n                       LPSTR* lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar,\n                       LPBOOL lpUsedDefaultChar)\n{\n\tint status;\n\tBOOL allocate = FALSE;\n\n\tif (!lpWideCharStr)\n\t\treturn 0;\n\n\tif (!lpMultiByteStr)\n\t\treturn 0;\n\n\tif (cchWideChar == -1)\n\t\tcchWideChar = (int)(_wcslen(lpWideCharStr) + 1);\n\n\tif (cbMultiByte == 0)\n\t{\n\t\tcbMultiByte =\n\t\t    WideCharToMultiByte(CodePage, dwFlags, lpWideCharStr, cchWideChar, NULL, 0, NULL, NULL);\n\t\tallocate = TRUE;\n\t}\n\n\tif (cbMultiByte < 1)\n\t\treturn 0;\n\n\tif (!(*lpMultiByteStr))\n\t\tallocate = TRUE;\n\n\tif (allocate)\n\t{\n\t\t*lpMultiByteStr = (LPSTR)calloc(1, cbMultiByte + 1);\n\n\t\tif (!(*lpMultiByteStr))\n\t\t{\n\t\t\t// SetLastError(ERROR_INSUFFICIENT_BUFFER);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tstatus = WideCharToMultiByte(CodePage, dwFlags, lpWideCharStr, cchWideChar, *lpMultiByteStr,\n\t                             cbMultiByte, lpDefaultChar, lpUsedDefaultChar);\n\n\tif ((status != cbMultiByte) && allocate)\n\t{\n\t\tstatus = 0;\n\t}\n\n\tif ((status <= 0) && allocate)\n\t{\n\t\tfree(*lpMultiByteStr);\n\t\t*lpMultiByteStr = NULL;\n\t}\n\n\treturn status;\n}\n\nType Definitions:\n- wStream: typedef struct _wStream wStream;\n- CLIPRDR_FORMAT_LIST: typedef struct _CLIPRDR_FORMAT_LIST CLIPRDR_FORMAT_LIST;\n- CLIPRDR_FORMAT: typedef struct _CLIPRDR_FORMAT CLIPRDR_FORMAT;\n\nImports:\n- #include <winpr/stream.h>\n- #include <winpr/crt.h>\n- #include \"cliprdr_common.h\"\n- #include <freerdp/channels/log.h>",
    "commit_msg": "Fixed oob read in cliprdr_read_format_list",
    "cve_desc": "In FreeRDP before 2.1.0, there is an out-of-bounds read in cliprdr_read_format_list. Clipboard format data read (by client or server) might read data out-of-bounds. This has been fixed in 2.1.0.",
    "year": 2020,
    "filename": "cliprdr_common.c",
    "commit_url": "\"https://github.com/FreeRDP/FreeRDP/commit/b73143cf7ee5fe4cdabcbf56908aa15d8a883821\""
  },
  {
    "repository": "FreeRDP/FreeRDP",
    "cve_id": "CVE-2020-11086",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "c098f21fdaadca57ff649eee1674f6cc321a2ec4",
    "short_hash": "c098f21f",
    "vulnerableMethods_before": [
      {
        "filename": "winpr/libwinpr/sspi/NTLM/ntlm_compute.c",
        "method_name": "ntlm_read_ntlm_v2_client_challenge",
        "raw_code": "static int ntlm_read_ntlm_v2_client_challenge(wStream* s, NTLMv2_CLIENT_CHALLENGE* challenge) /* <=== ntlm_read_ntlm_v2_client_challenge */ \n{\n\tsize_t size;\n\tStream_Read_UINT8(s, challenge->RespType);\n\tStream_Read_UINT8(s, challenge->HiRespType);\n\tStream_Read_UINT16(s, challenge->Reserved1);\n\tStream_Read_UINT32(s, challenge->Reserved2);\n\tStream_Read(s, challenge->Timestamp, 8);\n\tStream_Read(s, challenge->ClientChallenge, 8);\n\tStream_Read_UINT32(s, challenge->Reserved3);\n\tsize = Stream_Length(s) - Stream_GetPosition(s);\n\n\tif (size > UINT32_MAX)\n\t\treturn -1;\n\n\tchallenge->cbAvPairs = size;\n\tchallenge->AvPairs = (NTLM_AV_PAIR*)malloc(challenge->cbAvPairs);\n\n\tif (!challenge->AvPairs)\n\t\treturn -1;\n\n\tStream_Read(s, challenge->AvPairs, size);\n\treturn 1;\n}",
        "start_line": 124
      },
      {
        "filename": "winpr/libwinpr/sspi/NTLM/ntlm_compute.c",
        "method_name": "ntlm_read_ntlm_v2_response",
        "raw_code": "int ntlm_read_ntlm_v2_response(wStream* s, NTLMv2_RESPONSE* response) /* <=== ntlm_read_ntlm_v2_response */ \n{\n\tStream_Read(s, response->Response, 16);\n\treturn ntlm_read_ntlm_v2_client_challenge(s, &(response->Challenge));\n}",
        "start_line": 164
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "winpr/libwinpr/sspi/NTLM/ntlm_compute.c",
        "method_name": "ntlm_read_ntlm_v2_client_challenge",
        "raw_code": "static int ntlm_read_ntlm_v2_client_challenge(wStream* s, NTLMv2_CLIENT_CHALLENGE* challenge) /* <=== ntlm_read_ntlm_v2_client_challenge */ \n{\n\tsize_t size;\n\tif (Stream_GetRemainingLength(s) < 28)\n\t\treturn -1;\n\n\tStream_Read_UINT8(s, challenge->RespType);\n\tStream_Read_UINT8(s, challenge->HiRespType);\n\tStream_Read_UINT16(s, challenge->Reserved1);\n\tStream_Read_UINT32(s, challenge->Reserved2);\n\tStream_Read(s, challenge->Timestamp, 8);\n\tStream_Read(s, challenge->ClientChallenge, 8);\n\tStream_Read_UINT32(s, challenge->Reserved3);\n\tsize = Stream_Length(s) - Stream_GetPosition(s);\n\n\tif (size > UINT32_MAX)\n\t\treturn -1;\n\n\tchallenge->cbAvPairs = size;\n\tchallenge->AvPairs = (NTLM_AV_PAIR*)malloc(challenge->cbAvPairs);\n\n\tif (!challenge->AvPairs)\n\t\treturn -1;\n\n\tStream_Read(s, challenge->AvPairs, size);\n\treturn 1;\n}",
        "start_line": 124
      },
      {
        "filename": "winpr/libwinpr/sspi/NTLM/ntlm_compute.c",
        "method_name": "ntlm_read_ntlm_v2_response",
        "raw_code": "int ntlm_read_ntlm_v2_response(wStream* s, NTLMv2_RESPONSE* response) /* <=== ntlm_read_ntlm_v2_response */ \n{\n\tif (Stream_GetRemainingLength(s) < 16)\n\t\treturn -1;\n\tStream_Read(s, response->Response, 16);\n\treturn ntlm_read_ntlm_v2_client_challenge(s, &(response->Challenge));\n}",
        "start_line": 167
      }
    ],
    "code_context": "Type Definitions:\n- NTLMv2_RESPONSE: typedef struct _NTLMv2_RESPONSE NTLMv2_RESPONSE;\n- NTLMv2_CLIENT_CHALLENGE: typedef struct _NTLMv2_CLIENT_CHALLENGE NTLMv2_CLIENT_CHALLENGE;\n- wStream: typedef struct _wStream wStream;\n\nImports:\n- #include <winpr/crypto.h>\n- #include <winpr/sysinfo.h>\n- #include \"ntlm_compute.h\"\n- #include \"ntlm.h\"\n- #include <winpr/sam.h>\n- #include \"../../log.h\"\n- #include \"../sspi.h\"\n- #include <winpr/ntlm.h>\n- #include <winpr/crt.h>\n- #include \"config.h\"\n- #include <winpr/print.h>\n- #include <assert.h>",
    "commit_msg": "Fixed oob read in ntlm_read_ntlm_v2_response",
    "cve_desc": "In FreeRDP less than or equal to 2.0.0, there is an out-of-bound read in ntlm_read_ntlm_v2_client_challenge that reads up to 28 bytes out-of-bound to an internal structure. This has been fixed in 2.1.0.",
    "year": 2020,
    "filename": "ntlm_compute.c",
    "commit_url": "\"https://github.com/FreeRDP/FreeRDP/commit/c098f21fdaadca57ff649eee1674f6cc321a2ec4\""
  },
  {
    "repository": "FreeRDP/FreeRDP",
    "cve_id": "CVE-2020-11087",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "8241ab42fdf0cc89cf69fc574bf6360c9977a0d4",
    "short_hash": "8241ab42",
    "vulnerableMethods_before": [
      {
        "filename": "winpr/libwinpr/sspi/NTLM/ntlm_message.c",
        "method_name": "ntlm_read_AuthenticateMessage",
        "raw_code": "SECURITY_STATUS ntlm_read_AuthenticateMessage(NTLM_CONTEXT* context, PSecBuffer buffer) /* <=== ntlm_read_AuthenticateMessage */ \n{\n\twStream* s;\n\tsize_t length;\n\tUINT32 flags;\n\tNTLM_AV_PAIR* AvFlags;\n\tUINT32 PayloadBufferOffset;\n\tNTLM_AUTHENTICATE_MESSAGE* message;\n\tSSPI_CREDENTIALS* credentials = context->credentials;\n\tflags = 0;\n\tAvFlags = NULL;\n\tmessage = &context->AUTHENTICATE_MESSAGE;\n\tZeroMemory(message, sizeof(NTLM_AUTHENTICATE_MESSAGE));\n\ts = Stream_New((BYTE*)buffer->pvBuffer, buffer->cbBuffer);\n\n\tif (!s)\n\t\treturn SEC_E_INTERNAL_ERROR;\n\n\tif (ntlm_read_message_header(s, (NTLM_MESSAGE_HEADER*)message) < 0)\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tif (message->MessageType != MESSAGE_TYPE_AUTHENTICATE)\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tif (ntlm_read_message_fields(s, &(message->LmChallengeResponse)) <\n\t    0) /* LmChallengeResponseFields (8 bytes) */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tif (ntlm_read_message_fields(s, &(message->NtChallengeResponse)) <\n\t    0) /* NtChallengeResponseFields (8 bytes) */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tif (ntlm_read_message_fields(s, &(message->DomainName)) < 0) /* DomainNameFields (8 bytes) */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tif (ntlm_read_message_fields(s, &(message->UserName)) < 0) /* UserNameFields (8 bytes) */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tif (ntlm_read_message_fields(s, &(message->Workstation)) < 0) /* WorkstationFields (8 bytes) */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tif (ntlm_read_message_fields(s, &(message->EncryptedRandomSessionKey)) <\n\t    0) /* EncryptedRandomSessionKeyFields (8 bytes) */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tStream_Read_UINT32(s, message->NegotiateFlags); /* NegotiateFlags (4 bytes) */\n\tcontext->NegotiateKeyExchange =\n\t    (message->NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH) ? TRUE : FALSE;\n\n\tif ((context->NegotiateKeyExchange && !message->EncryptedRandomSessionKey.Len) ||\n\t    (!context->NegotiateKeyExchange && message->EncryptedRandomSessionKey.Len))\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t{\n\t\tif (ntlm_read_version_info(s, &(message->Version)) < 0) /* Version (8 bytes) */\n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\treturn SEC_E_INVALID_TOKEN;\n\t\t}\n\t}\n\n\tPayloadBufferOffset = Stream_GetPosition(s);\n\n\tif (ntlm_read_message_fields_buffer(s, &(message->DomainName)) < 0) /* DomainName */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\n\tif (ntlm_read_message_fields_buffer(s, &(message->UserName)) < 0) /* UserName */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\n\tif (ntlm_read_message_fields_buffer(s, &(message->Workstation)) < 0) /* Workstation */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\n\tif (ntlm_read_message_fields_buffer(s, &(message->LmChallengeResponse)) <\n\t    0) /* LmChallengeResponse */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\n\tif (ntlm_read_message_fields_buffer(s, &(message->NtChallengeResponse)) <\n\t    0) /* NtChallengeResponse */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\n\tif (message->NtChallengeResponse.Len > 0)\n\t{\n\t\tsize_t cbAvFlags;\n\t\twStream* snt =\n\t\t    Stream_New(message->NtChallengeResponse.Buffer, message->NtChallengeResponse.Len);\n\n\t\tif (!snt)\n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\treturn SEC_E_INTERNAL_ERROR;\n\t\t}\n\n\t\tif (ntlm_read_ntlm_v2_response(snt, &(context->NTLMv2Response)) < 0)\n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\tStream_Free(snt, FALSE);\n\t\t\treturn SEC_E_INVALID_TOKEN;\n\t\t}\n\n\t\tStream_Free(snt, FALSE);\n\t\tcontext->NtChallengeResponse.pvBuffer = message->NtChallengeResponse.Buffer;\n\t\tcontext->NtChallengeResponse.cbBuffer = message->NtChallengeResponse.Len;\n\t\tsspi_SecBufferFree(&(context->ChallengeTargetInfo));\n\t\tcontext->ChallengeTargetInfo.pvBuffer = (void*)context->NTLMv2Response.Challenge.AvPairs;\n\t\tcontext->ChallengeTargetInfo.cbBuffer = message->NtChallengeResponse.Len - (28 + 16);\n\t\tCopyMemory(context->ClientChallenge, context->NTLMv2Response.Challenge.ClientChallenge, 8);\n\t\tAvFlags =\n\t\t    ntlm_av_pair_get(context->NTLMv2Response.Challenge.AvPairs,\n\t\t                     context->NTLMv2Response.Challenge.cbAvPairs, MsvAvFlags, &cbAvFlags);\n\n\t\tif (AvFlags)\n\t\t\tData_Read_UINT32(ntlm_av_pair_get_value_pointer(AvFlags), flags);\n\t}\n\n\tif (ntlm_read_message_fields_buffer(s, &(message->EncryptedRandomSessionKey)) <\n\t    0) /* EncryptedRandomSessionKey */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\n\tif (message->EncryptedRandomSessionKey.Len > 0)\n\t{\n\t\tif (message->EncryptedRandomSessionKey.Len != 16)\n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\treturn SEC_E_INVALID_TOKEN;\n\t\t}\n\n\t\tCopyMemory(context->EncryptedRandomSessionKey, message->EncryptedRandomSessionKey.Buffer,\n\t\t           16);\n\t}\n\n\tlength = Stream_GetPosition(s);\n\n\tif (!sspi_SecBufferAlloc(&context->AuthenticateMessage, length))\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\n\tCopyMemory(context->AuthenticateMessage.pvBuffer, Stream_Buffer(s), length);\n\tbuffer->cbBuffer = length;\n\tStream_SetPosition(s, PayloadBufferOffset);\n\n\tif (flags & MSV_AV_FLAGS_MESSAGE_INTEGRITY_CHECK)\n\t{\n\t\tcontext->MessageIntegrityCheckOffset = (UINT32)Stream_GetPosition(s);\n\n\t\tif (Stream_GetRemainingLength(s) < 16)\n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\treturn SEC_E_INVALID_TOKEN;\n\t\t}\n\n\t\tStream_Read(s, message->MessageIntegrityCheck, 16);\n\t}\n\n#ifdef WITH_DEBUG_NTLM\n\tWLog_DBG(TAG, \"AUTHENTICATE_MESSAGE (length = %\" PRIu32 \")\",\n\t         context->AuthenticateMessage.cbBuffer);\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->AuthenticateMessage.pvBuffer,\n\t              context->AuthenticateMessage.cbBuffer);\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t\tntlm_print_version_info(&(message->Version));\n\n\tntlm_print_message_fields(&(message->DomainName), \"DomainName\");\n\tntlm_print_message_fields(&(message->UserName), \"UserName\");\n\tntlm_print_message_fields(&(message->Workstation), \"Workstation\");\n\tntlm_print_message_fields(&(message->LmChallengeResponse), \"LmChallengeResponse\");\n\tntlm_print_message_fields(&(message->NtChallengeResponse), \"NtChallengeResponse\");\n\tntlm_print_message_fields(&(message->EncryptedRandomSessionKey), \"EncryptedRandomSessionKey\");\n\tntlm_print_av_pair_list(context->NTLMv2Response.Challenge.AvPairs,\n\t                        context->NTLMv2Response.Challenge.cbAvPairs);\n\n\tif (flags & MSV_AV_FLAGS_MESSAGE_INTEGRITY_CHECK)\n\t{\n\t\tWLog_DBG(TAG, \"MessageIntegrityCheck:\");\n\t\twinpr_HexDump(TAG, WLOG_DEBUG, message->MessageIntegrityCheck, 16);\n\t}\n\n#endif\n\n\tif (message->UserName.Len > 0)\n\t{\n\t\tcredentials->identity.User = (UINT16*)malloc(message->UserName.Len);\n\n\t\tif (!credentials->identity.User)\n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\treturn SEC_E_INTERNAL_ERROR;\n\t\t}\n\n\t\tCopyMemory(credentials->identity.User, message->UserName.Buffer, message->UserName.Len);\n\t\tcredentials->identity.UserLength = message->UserName.Len / 2;\n\t}\n\n\tif (message->DomainName.Len > 0)\n\t{\n\t\tcredentials->identity.Domain = (UINT16*)malloc(message->DomainName.Len);\n\n\t\tif (!credentials->identity.Domain)\n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\treturn SEC_E_INTERNAL_ERROR;\n\t\t}\n\n\t\tCopyMemory(credentials->identity.Domain, message->DomainName.Buffer,\n\t\t           message->DomainName.Len);\n\t\tcredentials->identity.DomainLength = message->DomainName.Len / 2;\n\t}\n\n\tStream_Free(s, FALSE);\n\t/* Computations beyond this point require the NTLM hash of the password */\n\tcontext->state = NTLM_STATE_COMPLETION;\n\treturn SEC_I_COMPLETE_NEEDED;\n}",
        "start_line": 682
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "winpr/libwinpr/sspi/NTLM/ntlm_message.c",
        "method_name": "ntlm_read_AuthenticateMessage",
        "raw_code": "SECURITY_STATUS ntlm_read_AuthenticateMessage(NTLM_CONTEXT* context, PSecBuffer buffer) /* <=== ntlm_read_AuthenticateMessage */ \n{\n\tSECURITY_STATUS status = SEC_E_INVALID_TOKEN;\n\twStream* s;\n\tsize_t length;\n\tUINT32 flags = 0;\n\tNTLM_AV_PAIR* AvFlags = NULL;\n\tUINT32 PayloadBufferOffset;\n\tNTLM_AUTHENTICATE_MESSAGE* message;\n\tSSPI_CREDENTIALS* credentials = context->credentials;\n\n\tmessage = &context->AUTHENTICATE_MESSAGE;\n\tZeroMemory(message, sizeof(NTLM_AUTHENTICATE_MESSAGE));\n\ts = Stream_New((BYTE*)buffer->pvBuffer, buffer->cbBuffer);\n\n\tif (!s)\n\t\treturn SEC_E_INTERNAL_ERROR;\n\n\tif (ntlm_read_message_header(s, (NTLM_MESSAGE_HEADER*)message) < 0)\n\t\tgoto fail;\n\n\tif (message->MessageType != MESSAGE_TYPE_AUTHENTICATE)\n\t\tgoto fail;\n\n\tif (ntlm_read_message_fields(s, &(message->LmChallengeResponse)) <\n\t    0) /* LmChallengeResponseFields (8 bytes) */\n\t\tgoto fail;\n\n\tif (ntlm_read_message_fields(s, &(message->NtChallengeResponse)) <\n\t    0) /* NtChallengeResponseFields (8 bytes) */\n\t\tgoto fail;\n\n\tif (ntlm_read_message_fields(s, &(message->DomainName)) < 0) /* DomainNameFields (8 bytes) */\n\t\tgoto fail;\n\n\tif (ntlm_read_message_fields(s, &(message->UserName)) < 0) /* UserNameFields (8 bytes) */\n\t\tgoto fail;\n\n\tif (ntlm_read_message_fields(s, &(message->Workstation)) < 0) /* WorkstationFields (8 bytes) */\n\t\tgoto fail;\n\n\tif (ntlm_read_message_fields(s, &(message->EncryptedRandomSessionKey)) <\n\t    0) /* EncryptedRandomSessionKeyFields (8 bytes) */\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\tgoto fail;\n\tStream_Read_UINT32(s, message->NegotiateFlags); /* NegotiateFlags (4 bytes) */\n\tcontext->NegotiateKeyExchange =\n\t    (message->NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH) ? TRUE : FALSE;\n\n\tif ((context->NegotiateKeyExchange && !message->EncryptedRandomSessionKey.Len) ||\n\t    (!context->NegotiateKeyExchange && message->EncryptedRandomSessionKey.Len))\n\t\tgoto fail;\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t{\n\t\tif (ntlm_read_version_info(s, &(message->Version)) < 0) /* Version (8 bytes) */\n\t\t\tgoto fail;\n\t}\n\n\tPayloadBufferOffset = Stream_GetPosition(s);\n\n\tstatus = SEC_E_INTERNAL_ERROR;\n\tif (ntlm_read_message_fields_buffer(s, &(message->DomainName)) < 0) /* DomainName */\n\t\tgoto fail;\n\n\tif (ntlm_read_message_fields_buffer(s, &(message->UserName)) < 0) /* UserName */\n\t\tgoto fail;\n\n\tif (ntlm_read_message_fields_buffer(s, &(message->Workstation)) < 0) /* Workstation */\n\t\tgoto fail;\n\n\tif (ntlm_read_message_fields_buffer(s, &(message->LmChallengeResponse)) <\n\t    0) /* LmChallengeResponse */\n\t\tgoto fail;\n\n\tif (ntlm_read_message_fields_buffer(s, &(message->NtChallengeResponse)) <\n\t    0) /* NtChallengeResponse */\n\t\tgoto fail;\n\n\tif (message->NtChallengeResponse.Len > 0)\n\t{\n\t\tint rc;\n\t\tsize_t cbAvFlags;\n\t\twStream* snt =\n\t\t    Stream_New(message->NtChallengeResponse.Buffer, message->NtChallengeResponse.Len);\n\n\t\tif (!snt)\n\t\t\tgoto fail;\n\n\t\tstatus = SEC_E_INVALID_TOKEN;\n\t\trc = ntlm_read_ntlm_v2_response(snt, &(context->NTLMv2Response));\n\t\tStream_Free(snt, FALSE);\n\t\tif (rc < 0)\n\t\t\tgoto fail;\n\t\tstatus = SEC_E_INTERNAL_ERROR;\n\n\t\tcontext->NtChallengeResponse.pvBuffer = message->NtChallengeResponse.Buffer;\n\t\tcontext->NtChallengeResponse.cbBuffer = message->NtChallengeResponse.Len;\n\t\tsspi_SecBufferFree(&(context->ChallengeTargetInfo));\n\t\tcontext->ChallengeTargetInfo.pvBuffer = (void*)context->NTLMv2Response.Challenge.AvPairs;\n\t\tcontext->ChallengeTargetInfo.cbBuffer = message->NtChallengeResponse.Len - (28 + 16);\n\t\tCopyMemory(context->ClientChallenge, context->NTLMv2Response.Challenge.ClientChallenge, 8);\n\t\tAvFlags =\n\t\t    ntlm_av_pair_get(context->NTLMv2Response.Challenge.AvPairs,\n\t\t                     context->NTLMv2Response.Challenge.cbAvPairs, MsvAvFlags, &cbAvFlags);\n\n\t\tif (AvFlags)\n\t\t\tData_Read_UINT32(ntlm_av_pair_get_value_pointer(AvFlags), flags);\n\t}\n\n\tif (ntlm_read_message_fields_buffer(s, &(message->EncryptedRandomSessionKey)) <\n\t    0) /* EncryptedRandomSessionKey */\n\t\tgoto fail;\n\n\tif (message->EncryptedRandomSessionKey.Len > 0)\n\t{\n\t\tif (message->EncryptedRandomSessionKey.Len != 16)\n\t\t\tgoto fail;\n\n\t\tCopyMemory(context->EncryptedRandomSessionKey, message->EncryptedRandomSessionKey.Buffer,\n\t\t           16);\n\t}\n\n\tlength = Stream_GetPosition(s);\n\n\tif (!sspi_SecBufferAlloc(&context->AuthenticateMessage, length))\n\t\tgoto fail;\n\n\tCopyMemory(context->AuthenticateMessage.pvBuffer, Stream_Buffer(s), length);\n\tbuffer->cbBuffer = length;\n\tStream_SetPosition(s, PayloadBufferOffset);\n\n\tif (flags & MSV_AV_FLAGS_MESSAGE_INTEGRITY_CHECK)\n\t{\n\t\tcontext->MessageIntegrityCheckOffset = (UINT32)Stream_GetPosition(s);\n\n\t\tstatus = SEC_E_INVALID_TOKEN;\n\t\tif (Stream_GetRemainingLength(s) < 16)\n\t\t\tgoto fail;\n\n\t\tStream_Read(s, message->MessageIntegrityCheck, 16);\n\t}\n\n\tstatus = SEC_E_INTERNAL_ERROR;\n\n#ifdef WITH_DEBUG_NTLM\n\tWLog_DBG(TAG, \"AUTHENTICATE_MESSAGE (length = %\" PRIu32 \")\",\n\t         context->AuthenticateMessage.cbBuffer);\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->AuthenticateMessage.pvBuffer,\n\t              context->AuthenticateMessage.cbBuffer);\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t\tntlm_print_version_info(&(message->Version));\n\n\tntlm_print_message_fields(&(message->DomainName), \"DomainName\");\n\tntlm_print_message_fields(&(message->UserName), \"UserName\");\n\tntlm_print_message_fields(&(message->Workstation), \"Workstation\");\n\tntlm_print_message_fields(&(message->LmChallengeResponse), \"LmChallengeResponse\");\n\tntlm_print_message_fields(&(message->NtChallengeResponse), \"NtChallengeResponse\");\n\tntlm_print_message_fields(&(message->EncryptedRandomSessionKey), \"EncryptedRandomSessionKey\");\n\tntlm_print_av_pair_list(context->NTLMv2Response.Challenge.AvPairs,\n\t                        context->NTLMv2Response.Challenge.cbAvPairs);\n\n\tif (flags & MSV_AV_FLAGS_MESSAGE_INTEGRITY_CHECK)\n\t{\n\t\tWLog_DBG(TAG, \"MessageIntegrityCheck:\");\n\t\twinpr_HexDump(TAG, WLOG_DEBUG, message->MessageIntegrityCheck, 16);\n\t}\n\n#endif\n\n\tif (message->UserName.Len > 0)\n\t{\n\t\tcredentials->identity.User = (UINT16*)malloc(message->UserName.Len);\n\n\t\tif (!credentials->identity.User)\n\t\t\tgoto fail;\n\n\t\tCopyMemory(credentials->identity.User, message->UserName.Buffer, message->UserName.Len);\n\t\tcredentials->identity.UserLength = message->UserName.Len / 2;\n\t}\n\n\tif (message->DomainName.Len > 0)\n\t{\n\t\tcredentials->identity.Domain = (UINT16*)malloc(message->DomainName.Len);\n\n\t\tif (!credentials->identity.Domain)\n\t\t\tgoto fail;\n\n\t\tCopyMemory(credentials->identity.Domain, message->DomainName.Buffer,\n\t\t           message->DomainName.Len);\n\t\tcredentials->identity.DomainLength = message->DomainName.Len / 2;\n\t}\n\n\tStream_Free(s, FALSE);\n\t/* Computations beyond this point require the NTLM hash of the password */\n\tcontext->state = NTLM_STATE_COMPLETION;\n\treturn SEC_I_COMPLETE_NEEDED;\n\nfail:\n\tStream_Free(s, FALSE);\n\treturn status;\n}",
        "start_line": 682
      }
    ],
    "code_context": "Called Methods:\n- ntlm_read_ntlm_v2_client_challenge: static int ntlm_read_ntlm_v2_client_challenge(wStream* s, NTLMv2_CLIENT_CHALLENGE* challenge) /* <=== ntlm_read_ntlm_v2_client_challenge */ \n{\n\tsize_t size;\n\tif (Stream_GetRemainingLength(s) < 28)\n\t\treturn -1;\n\n\tStream_Read_UINT8(s, challenge->RespType);\n\tStream_Read_UINT8(s, challenge->HiRespType);\n\tStream_Read_UINT16(s, challenge->Reserved1);\n\tStream_Read_UINT32(s, challenge->Reserved2);\n\tStream_Read(s, challenge->Timestamp, 8);\n\tStream_Read(s, challenge->ClientChallenge, 8);\n\tStream_Read_UINT32(s, challenge->Reserved3);\n\tsize = Stream_Length(s) - Stream_GetPosition(s);\n\n\tif (size > UINT32_MAX)\n\t\treturn -1;\n\n\tchallenge->cbAvPairs = size;\n\tchallenge->AvPairs = (NTLM_AV_PAIR*)malloc(challenge->cbAvPairs);\n\n\tif (!challenge->AvPairs)\n\t\treturn -1;\n\n\tStream_Read(s, challenge->AvPairs, size);\n\treturn 1;\n}\n- sspi_SecBufferAlloc: void* sspi_SecBufferAlloc(PSecBuffer SecBuffer, ULONG size) /* <=== sspi_SecBufferAlloc */ \n{\n\tif (!SecBuffer)\n\t\treturn NULL;\n\n\tSecBuffer->pvBuffer = calloc(1, size);\n\n\tif (!SecBuffer->pvBuffer)\n\t\treturn NULL;\n\n\tSecBuffer->cbBuffer = size;\n\treturn SecBuffer->pvBuffer;\n}\n- ntlm_av_pair_check: static BOOL ntlm_av_pair_check(NTLM_AV_PAIR* pAvPair, size_t cbAvPair) /* <=== ntlm_av_pair_check */ \n{\n\tif (!pAvPair || cbAvPair < sizeof(NTLM_AV_PAIR))\n\t\treturn FALSE;\n\treturn cbAvPair >= ntlm_av_pair_get_next_offset(pAvPair);\n}\n- NTLMSSP_NEGOTIATE_VERSION: #define NTLMSSP_NEGOTIATE_VERSION 0x02000000                   /* T   (6) */ /* <=== winpr/libwinpr/sspi/NTLM/ntlm.h:42:42:NTLMSSP_NEGOTIATE_VERSION:0 */ \n- ntlm_read_message_header: static int ntlm_read_message_header(wStream* s, NTLM_MESSAGE_HEADER* header) /* <=== ntlm_read_message_header */ \n{\n\tif (Stream_GetRemainingLength(s) < 12)\n\t\treturn -1;\n\n\tStream_Read(s, header->Signature, 8);\n\tStream_Read_UINT32(s, header->MessageType);\n\n\tif (strncmp((char*)header->Signature, NTLM_SIGNATURE, 8) != 0)\n\t\treturn -1;\n\n\treturn 1;\n}\n- NTLMSSP_NEGOTIATE_KEY_EXCH: #define NTLMSSP_NEGOTIATE_KEY_EXCH 0x40000000                  /* V   (1) */ /* <=== winpr/libwinpr/sspi/NTLM/ntlm.h:37:37:NTLMSSP_NEGOTIATE_KEY_EXCH:0 */ \n- Stream_Free: void Stream_Free(wStream* s, BOOL bFreeBuffer) /* <=== Stream_Free */ \n{\n\tif (s)\n\t{\n\t\tif (bFreeBuffer && s->isOwner)\n\t\t\tfree(s->buffer);\n\n\t\tif (s->isAllocatedStream)\n\t\t\tfree(s);\n\t}\n}\n- ntlm_av_pair_get: NTLM_AV_PAIR* ntlm_av_pair_get(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList, NTLM_AV_ID AvId, /* <=== ntlm_av_pair_get */ \n                               size_t* pcbAvPairListRemaining)\n{\n\tsize_t cbAvPair = cbAvPairList;\n\tNTLM_AV_PAIR* pAvPair = pAvPairList;\n\n\tif (!ntlm_av_pair_check(pAvPair, cbAvPair))\n\t\tpAvPair = NULL;\n\n\twhile (pAvPair)\n\t{\n\t\tUINT16 id = ntlm_av_pair_get_id(pAvPair);\n\n\t\tif (id == AvId)\n\t\t\tbreak;\n\t\tif (id == MsvAvEOL)\n\t\t{\n\t\t\tpAvPair = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tpAvPair = ntlm_av_pair_next(pAvPair, &cbAvPair);\n\t}\n\n\tif (!pAvPair)\n\t\tcbAvPair = 0;\n\tif (pcbAvPairListRemaining)\n\t\t*pcbAvPairListRemaining = cbAvPair;\n\n\treturn pAvPair;\n}\n- sspi_SecBufferFree: void sspi_SecBufferFree(PSecBuffer SecBuffer) /* <=== sspi_SecBufferFree */ \n{\n\tif (!SecBuffer)\n\t\treturn;\n\n\tif (SecBuffer->pvBuffer)\n\t\tmemset(SecBuffer->pvBuffer, 0, SecBuffer->cbBuffer);\n\n\tfree(SecBuffer->pvBuffer);\n\tSecBuffer->pvBuffer = NULL;\n\tSecBuffer->cbBuffer = 0;\n}\n- ntlm_av_pair_next: static NTLM_AV_PAIR* ntlm_av_pair_next(NTLM_AV_PAIR* pAvPair, size_t* pcbAvPair) /* <=== ntlm_av_pair_next */ \n{\n\tsize_t offset;\n\n\tif (!pcbAvPair)\n\t\treturn NULL;\n\tif (!ntlm_av_pair_check(pAvPair, *pcbAvPair))\n\t\treturn NULL;\n\n\toffset = ntlm_av_pair_get_next_offset(pAvPair);\n\t*pcbAvPair -= offset;\n\treturn (NTLM_AV_PAIR*)((PBYTE)pAvPair + offset);\n}\n- ntlm_read_version_info: int ntlm_read_version_info(wStream* s, NTLM_VERSION_INFO* versionInfo) /* <=== ntlm_read_version_info */ \n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn -1;\n\n\tStream_Read_UINT8(s, versionInfo->ProductMajorVersion); /* ProductMajorVersion (1 byte) */\n\tStream_Read_UINT8(s, versionInfo->ProductMinorVersion); /* ProductMinorVersion (1 byte) */\n\tStream_Read_UINT16(s, versionInfo->ProductBuild);       /* ProductBuild (2 bytes) */\n\tStream_Read(s, versionInfo->Reserved, sizeof(versionInfo->Reserved)); /* Reserved (3 bytes) */\n\tStream_Read_UINT8(s, versionInfo->NTLMRevisionCurrent); /* NTLMRevisionCurrent (1 byte) */\n\treturn 1;\n}\n- ntlm_read_message_fields: static int ntlm_read_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields) /* <=== ntlm_read_message_fields */ \n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn -1;\n\n\tStream_Read_UINT16(s, fields->Len);          /* Len (2 bytes) */\n\tStream_Read_UINT16(s, fields->MaxLen);       /* MaxLen (2 bytes) */\n\tStream_Read_UINT32(s, fields->BufferOffset); /* BufferOffset (4 bytes) */\n\treturn 1;\n}\n- MESSAGE_TYPE_AUTHENTICATE: #define MESSAGE_TYPE_AUTHENTICATE 3 /* <=== winpr/libwinpr/sspi/NTLM/ntlm.h:34:34:MESSAGE_TYPE_AUTHENTICATE:0 */ \n- Stream_New: wStream* Stream_New(BYTE* buffer, size_t size) /* <=== Stream_New */ \n{\n\twStream* s;\n\n\tif (!buffer && !size)\n\t\treturn NULL;\n\n\ts = malloc(sizeof(wStream));\n\tif (!s)\n\t\treturn NULL;\n\n\tif (buffer)\n\t\ts->buffer = buffer;\n\telse\n\t\ts->buffer = (BYTE*)malloc(size);\n\n\tif (!s->buffer)\n\t{\n\t\tfree(s);\n\t\treturn NULL;\n\t}\n\n\ts->pointer = s->buffer;\n\ts->capacity = size;\n\ts->length = size;\n\n\ts->pool = NULL;\n\ts->count = 0;\n\ts->isAllocatedStream = TRUE;\n\ts->isOwner = TRUE;\n\treturn s;\n}\n- ntlm_read_ntlm_v2_response: int ntlm_read_ntlm_v2_response(wStream* s, NTLMv2_RESPONSE* response) /* <=== ntlm_read_ntlm_v2_response */ \n{\n\tif (Stream_GetRemainingLength(s) < 16)\n\t\treturn -1;\n\tStream_Read(s, response->Response, 16);\n\treturn ntlm_read_ntlm_v2_client_challenge(s, &(response->Challenge));\n}\n- ntlm_read_message_fields_buffer: static int ntlm_read_message_fields_buffer(wStream* s, NTLM_MESSAGE_FIELDS* fields) /* <=== ntlm_read_message_fields_buffer */ \n{\n\tif (fields->Len > 0)\n\t{\n\t\tconst UINT32 offset = fields->BufferOffset + fields->Len;\n\n\t\tif (fields->BufferOffset > UINT32_MAX - fields->Len)\n\t\t\treturn -1;\n\n\t\tif (offset > Stream_Length(s))\n\t\t\treturn -1;\n\n\t\tfields->Buffer = (PBYTE)malloc(fields->Len);\n\n\t\tif (!fields->Buffer)\n\t\t\treturn -1;\n\n\t\tStream_SetPosition(s, fields->BufferOffset);\n\t\tStream_Read(s, fields->Buffer, fields->Len);\n\t}\n\n\treturn 1;\n}\n- ntlm_av_pair_get_value_pointer: PBYTE ntlm_av_pair_get_value_pointer(NTLM_AV_PAIR* pAvPair) /* <=== ntlm_av_pair_get_value_pointer */ \n{\n\treturn (PBYTE)pAvPair + sizeof(NTLM_AV_PAIR);\n}\n- MSV_AV_FLAGS_MESSAGE_INTEGRITY_CHECK: #define MSV_AV_FLAGS_MESSAGE_INTEGRITY_CHECK 0x00000002 /* <=== winpr/libwinpr/sspi/NTLM/ntlm.h:104:104:MSV_AV_FLAGS_MESSAGE_INTEGRITY_CHECK:0 */ \n\nType Definitions:\n- NTLM_AV_PAIR: typedef struct _NTLM_AV_PAIR NTLM_AV_PAIR;\n- NTLM_CONTEXT: typedef struct _NTLM_CONTEXT NTLM_CONTEXT;\n- SECURITY_STATUS: typedef LONG SECURITY_STATUS;\n- SSPI_CREDENTIALS: typedef struct _SSPI_CREDENTIALS SSPI_CREDENTIALS;\n- PSecBuffer: typedef SecBuffer* PSecBuffer;\n- _NTLM_AV_PAIR: struct _NTLM_AV_PAIR\n{\n\tUINT16 AvId;\n\tUINT16 AvLen;\n}\n- wStream: typedef struct _wStream wStream;\n- NTLM_AUTHENTICATE_MESSAGE: typedef struct _NTLM_AUTHENTICATE_MESSAGE NTLM_AUTHENTICATE_MESSAGE;\n\nImports:\n- #include <winpr/print.h>\n- #include \"ntlm_compute.h\"\n- #include <winpr/stream.h>\n- #include <winpr/sysinfo.h>\n- #include <winpr/crt.h>\n- #include \"ntlm.h\"\n- #include \"ntlm_message.h\"\n- #include \"../sspi.h\"\n- #include \"config.h\"\n- #include \"../log.h\"",
    "commit_msg": "Fixed oob read in ntlm_read_AuthenticateMessage",
    "cve_desc": "In FreeRDP less than or equal to 2.0.0, there is an out-of-bound read in ntlm_read_AuthenticateMessage. This has been fixed in 2.1.0.",
    "year": 2020,
    "filename": "ntlm_message.c",
    "commit_url": "\"https://github.com/FreeRDP/FreeRDP/commit/8241ab42fdf0cc89cf69fc574bf6360c9977a0d4\""
  },
  {
    "repository": "FreeRDP/FreeRDP",
    "cve_id": "CVE-2020-11089",
    "cwe_list": [
      "CWE-415"
    ],
    "commit_hash": "795842f4096501fcefc1a7f535ccc8132feb31d7",
    "short_hash": "795842f4",
    "vulnerableMethods_before": [
      {
        "filename": "channels/parallel/client/parallel_main.c",
        "method_name": "parallel_process_irp_create",
        "raw_code": "static UINT parallel_process_irp_create(PARALLEL_DEVICE* parallel, IRP* irp) /* <=== parallel_process_irp_create */ \n{\n\tchar* path = NULL;\n\tint status;\n\tUINT32 PathLength;\n\tStream_Seek(irp->input, 28);\n\t/* DesiredAccess(4) AllocationSize(8), FileAttributes(4) */\n\t/* SharedAccess(4) CreateDisposition(4), CreateOptions(4) */\n\tStream_Read_UINT32(irp->input, PathLength);\n\tstatus = ConvertFromUnicode(CP_UTF8, 0, (WCHAR*)Stream_Pointer(irp->input), PathLength / 2,\n\t                            &path, 0, NULL, NULL);\n\n\tif (status < 1)\n\t\tif (!(path = (char*)calloc(1, 1)))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\n\tparallel->id = irp->devman->id_sequence++;\n\tparallel->file = open(parallel->path, O_RDWR);\n\n\tif (parallel->file < 0)\n\t{\n\t\tirp->IoStatus = STATUS_ACCESS_DENIED;\n\t\tparallel->id = 0;\n\t}\n\telse\n\t{\n\t\t/* all read and write operations should be non-blocking */\n\t\tif (fcntl(parallel->file, F_SETFL, O_NONBLOCK) == -1)\n\t\t{\n\t\t}\n\t}\n\n\tStream_Write_UINT32(irp->output, parallel->id);\n\tStream_Write_UINT8(irp->output, 0);\n\tfree(path);\n\treturn irp->Complete(irp);\n}",
        "start_line": 82
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "channels/parallel/client/parallel_main.c",
        "method_name": "parallel_process_irp_create",
        "raw_code": "static UINT parallel_process_irp_create(PARALLEL_DEVICE* parallel, IRP* irp) /* <=== parallel_process_irp_create */ \n{\n\tchar* path = NULL;\n\tint status;\n\tWCHAR* ptr;\n\tUINT32 PathLength;\n\tif (!Stream_SafeSeek(irp->input, 28))\n\t\treturn ERROR_INVALID_DATA;\n\t/* DesiredAccess(4) AllocationSize(8), FileAttributes(4) */\n\t/* SharedAccess(4) CreateDisposition(4), CreateOptions(4) */\n\tif (Stream_GetRemainingLength(irp->input) < 4)\n\t\treturn ERROR_INVALID_DATA;\n\tStream_Read_UINT32(irp->input, PathLength);\n\tptr = (WCHAR*)Stream_Pointer(irp->input);\n\tif (!Stream_SafeSeek(irp->input, PathLength))\n\t\treturn ERROR_INVALID_DATA;\n\tstatus = ConvertFromUnicode(CP_UTF8, 0, ptr, PathLength / 2, &path, 0, NULL, NULL);\n\n\tif (status < 1)\n\t\tif (!(path = (char*)calloc(1, 1)))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\n\tparallel->id = irp->devman->id_sequence++;\n\tparallel->file = open(parallel->path, O_RDWR);\n\n\tif (parallel->file < 0)\n\t{\n\t\tirp->IoStatus = STATUS_ACCESS_DENIED;\n\t\tparallel->id = 0;\n\t}\n\telse\n\t{\n\t\t/* all read and write operations should be non-blocking */\n\t\tif (fcntl(parallel->file, F_SETFL, O_NONBLOCK) == -1)\n\t\t{\n\t\t}\n\t}\n\n\tStream_Write_UINT32(irp->output, parallel->id);\n\tStream_Write_UINT8(irp->output, 0);\n\tfree(path);\n\treturn irp->Complete(irp);\n}",
        "start_line": 82
      }
    ],
    "code_context": "Called Methods:\n- TAG: #define TAG CHANNELS_TAG(\"drive.client\") /* <=== channels/parallel/client/parallel_main.c:61:61:TAG:0 */ \n- WideCharToMultiByte: int WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, /* <=== WideCharToMultiByte */ \n                        LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar,\n                        LPBOOL lpUsedDefaultChar)\n{\n#if !defined(WITH_ICU)\n\tint length;\n\tconst WCHAR* sourceStart;\n\tConversionResult result;\n\tBYTE* targetStart;\n#else\n\tchar* targetStart;\n#endif\n\n\t/* If cchWideChar is 0, the function fails */\n\n\tif ((cchWideChar == 0) || (cchWideChar < -1))\n\t\treturn 0;\n\n\t/* If cchWideChar is -1, the string is null-terminated */\n\n\tif (cchWideChar == -1)\n\t{\n\t\tsize_t len = _wcslen(lpWideCharStr);\n\t\tif (len >= INT32_MAX)\n\t\t\treturn 0;\n\t\tcchWideChar = (int)len + 1;\n\t}\n\n\t/*\n\t * if cbMultiByte is 0, the function returns the required buffer size\n\t * in bytes for lpMultiByteStr and makes no use of the output parameter itself.\n\t */\n#if defined(WITH_ICU)\n\t{\n\t\tUErrorCode error;\n\t\tint32_t targetLength;\n\t\tint32_t targetCapacity;\n\n\t\tswitch (CodePage)\n\t\t{\n\t\t\tcase CP_ACP:\n\t\t\tcase CP_UTF8:\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tWLog_ERR(TAG, \"Unsupported encoding %u\", CodePage);\n\t\t\t\treturn 0;\n\t\t}\n\n\t\ttargetStart = lpMultiByteStr;\n\t\ttargetCapacity = cbMultiByte;\n\t\terror = U_ZERO_ERROR;\n\n\t\tif (cbMultiByte == 0)\n\t\t{\n\t\t\tu_strToUTF8(NULL, 0, &targetLength, lpWideCharStr, cchWideChar, &error);\n\t\t\tcbMultiByte = targetLength;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tu_strToUTF8(targetStart, targetCapacity, &targetLength, lpWideCharStr, cchWideChar,\n\t\t\t            &error);\n\t\t\tcbMultiByte = U_SUCCESS(error) ? targetLength : 0;\n\t\t}\n\t}\n#else\n\n\tif (cbMultiByte == 0)\n\t{\n\t\tsourceStart = (WCHAR*)lpWideCharStr;\n\t\ttargetStart = (BYTE*)NULL;\n\t\tresult = ConvertUTF16toUTF8(&sourceStart, &sourceStart[cchWideChar], &targetStart, NULL,\n\t\t                            strictConversion);\n\t\tlength = targetStart - ((BYTE*)NULL);\n\t}\n\telse\n\t{\n\t\tsourceStart = (WCHAR*)lpWideCharStr;\n\t\ttargetStart = (BYTE*)lpMultiByteStr;\n\t\tresult = ConvertUTF16toUTF8(&sourceStart, &sourceStart[cchWideChar], &targetStart,\n\t\t                            &targetStart[cbMultiByte], strictConversion);\n\t\tlength = targetStart - ((BYTE*)lpMultiByteStr);\n\t}\n\n\tcbMultiByte = (result == conversionOK) ? length : 0;\n#endif\n\treturn cbMultiByte;\n}\n- ConvertFromUnicode: int ConvertFromUnicode(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, /* <=== ConvertFromUnicode */ \n                       LPSTR* lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar,\n                       LPBOOL lpUsedDefaultChar)\n{\n\tint status;\n\tBOOL allocate = FALSE;\n\n\tif (!lpWideCharStr)\n\t\treturn 0;\n\n\tif (!lpMultiByteStr)\n\t\treturn 0;\n\n\tif (cchWideChar == -1)\n\t\tcchWideChar = (int)(_wcslen(lpWideCharStr) + 1);\n\n\tif (cbMultiByte == 0)\n\t{\n\t\tcbMultiByte =\n\t\t    WideCharToMultiByte(CodePage, dwFlags, lpWideCharStr, cchWideChar, NULL, 0, NULL, NULL);\n\t\tallocate = TRUE;\n\t}\n\n\tif (cbMultiByte < 1)\n\t\treturn 0;\n\n\tif (!(*lpMultiByteStr))\n\t\tallocate = TRUE;\n\n\tif (allocate)\n\t{\n\t\t*lpMultiByteStr = (LPSTR)calloc(1, cbMultiByte + 1);\n\n\t\tif (!(*lpMultiByteStr))\n\t\t{\n\t\t\t// SetLastError(ERROR_INSUFFICIENT_BUFFER);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tstatus = WideCharToMultiByte(CodePage, dwFlags, lpWideCharStr, cchWideChar, *lpMultiByteStr,\n\t                             cbMultiByte, lpDefaultChar, lpUsedDefaultChar);\n\n\tif ((status != cbMultiByte) && allocate)\n\t{\n\t\tstatus = 0;\n\t}\n\n\tif ((status <= 0) && allocate)\n\t{\n\t\tfree(*lpMultiByteStr);\n\t\t*lpMultiByteStr = NULL;\n\t}\n\n\treturn status;\n}\n- _wcslen: \tWINPR_API size_t _wcslen(const WCHAR* str); /* <=== _wcslen */ \n\nType Definitions:\n- IRP: typedef struct _IRP IRP;\n- PARALLEL_DEVICE: typedef struct _PARALLEL_DEVICE PARALLEL_DEVICE;\n\nImports:\n- #include <freerdp/types.h>\n- #include <sys/ioctl.h>\n- #include <stdlib.h>\n- #include <winpr/synch.h>\n- #include <string.h>\n- #include <winpr/collections.h>\n- #include <winpr/stream.h>\n- #include <unistd.h>\n- #include <strings.h>\n- #include <winpr/thread.h>\n- #include <stdio.h>\n- #include <freerdp/constants.h>\n- #include <fcntl.h>\n- #include <freerdp/channels/log.h>\n- #include <winpr/interlocked.h>\n- #include \"config.h\"\n- #include <linux/parport.h>\n- #include <winpr/crt.h>\n- #include <errno.h>\n- #include <termios.h>\n- #include <freerdp/channels/rdpdr.h>\n- #include <linux/ppdev.h>",
    "commit_msg": "Fixed oob read in parallel_process_irp_create",
    "cve_desc": "In FreeRDP before 2.1.0, there is an out-of-bound read in irp functions (parallel_process_irp_create, serial_process_irp_create, drive_process_irp_write, printer_process_irp_write, rdpei_recv_pdu, serial_process_irp_write). This has been fixed in 2.1.0.",
    "year": 2020,
    "filename": "parallel_main.c",
    "commit_url": "\"https://github.com/FreeRDP/FreeRDP/commit/795842f4096501fcefc1a7f535ccc8132feb31d7\""
  },
  {
    "repository": "FreeRDP/FreeRDP",
    "cve_id": "CVE-2020-11096",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "b8beb55913471952f92770c90c372139d78c16c0",
    "short_hash": "b8beb559",
    "vulnerableMethods_before": [
      {
        "filename": "libfreerdp/core/orders.c",
        "method_name": "check_order_activated",
        "raw_code": "static BOOL check_order_activated(wLog* log, rdpSettings* settings, const char* orderName, /* <=== check_order_activated */ \n                                  BOOL condition)\n{\n\tif (!condition)\n\t{\n\t\tif (settings->AllowUnanouncedOrdersFromServer)\n\t\t{\n\t\t\tWLog_Print(log, WLOG_WARN,\n\t\t\t           \"%s - SERVER BUG: The support for this feature was not announced!\",\n\t\t\t           orderName);\n\t\t\treturn TRUE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tWLog_Print(log, WLOG_ERROR,\n\t\t\t           \"%s - SERVER BUG: The support for this feature was not announced! Use \"\n\t\t\t           \"/relax-order-checks to ignore\",\n\t\t\t           orderName);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\treturn TRUE;\n}",
        "start_line": 131
      },
      {
        "filename": "libfreerdp/core/orders.c",
        "method_name": "update_read_cache_bitmap_v2_order",
        "raw_code": "static CACHE_BITMAP_V2_ORDER* update_read_cache_bitmap_v2_order(rdpUpdate* update, wStream* s, /* <=== update_read_cache_bitmap_v2_order */ \n                                                                BOOL compressed, UINT16 flags)\n{\n\tBYTE bitsPerPixelId;\n\tCACHE_BITMAP_V2_ORDER* cache_bitmap_v2;\n\n\tif (!update || !s)\n\t\treturn NULL;\n\n\tcache_bitmap_v2 = calloc(1, sizeof(CACHE_BITMAP_V2_ORDER));\n\n\tif (!cache_bitmap_v2)\n\t\tgoto fail;\n\n\tcache_bitmap_v2->cacheId = flags & 0x0003;\n\tcache_bitmap_v2->flags = (flags & 0xFF80) >> 7;\n\tbitsPerPixelId = (flags & 0x0078) >> 3;\n\tcache_bitmap_v2->bitmapBpp = CBR2_BPP[bitsPerPixelId];\n\n\tif (cache_bitmap_v2->flags & CBR2_PERSISTENT_KEY_PRESENT)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\tgoto fail;\n\n\t\tStream_Read_UINT32(s, cache_bitmap_v2->key1); /* key1 (4 bytes) */\n\t\tStream_Read_UINT32(s, cache_bitmap_v2->key2); /* key2 (4 bytes) */\n\t}\n\n\tif (cache_bitmap_v2->flags & CBR2_HEIGHT_SAME_AS_WIDTH)\n\t{\n\t\tif (!update_read_2byte_unsigned(s, &cache_bitmap_v2->bitmapWidth)) /* bitmapWidth */\n\t\t\tgoto fail;\n\n\t\tcache_bitmap_v2->bitmapHeight = cache_bitmap_v2->bitmapWidth;\n\t}\n\telse\n\t{\n\t\tif (!update_read_2byte_unsigned(s, &cache_bitmap_v2->bitmapWidth) || /* bitmapWidth */\n\t\t    !update_read_2byte_unsigned(s, &cache_bitmap_v2->bitmapHeight))  /* bitmapHeight */\n\t\t\tgoto fail;\n\t}\n\n\tif (!update_read_4byte_unsigned(s, &cache_bitmap_v2->bitmapLength) || /* bitmapLength */\n\t    !update_read_2byte_unsigned(s, &cache_bitmap_v2->cacheIndex))     /* cacheIndex */\n\t\tgoto fail;\n\n\tif (cache_bitmap_v2->flags & CBR2_DO_NOT_CACHE)\n\t\tcache_bitmap_v2->cacheIndex = BITMAP_CACHE_WAITING_LIST_INDEX;\n\n\tif (compressed)\n\t{\n\t\tif (!(cache_bitmap_v2->flags & CBR2_NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\t\tgoto fail;\n\n\t\t\tStream_Read_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbCompFirstRowSize); /* cbCompFirstRowSize (2 bytes) */\n\t\t\tStream_Read_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbCompMainBodySize);         /* cbCompMainBodySize (2 bytes) */\n\t\t\tStream_Read_UINT16(s, cache_bitmap_v2->cbScanWidth); /* cbScanWidth (2 bytes) */\n\t\t\tStream_Read_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbUncompressedSize); /* cbUncompressedSize (2 bytes) */\n\t\t\tcache_bitmap_v2->bitmapLength = cache_bitmap_v2->cbCompMainBodySize;\n\t\t}\n\t}\n\n\tif (cache_bitmap_v2->bitmapLength == 0)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < cache_bitmap_v2->bitmapLength)\n\t\tgoto fail;\n\n\tif (cache_bitmap_v2->bitmapLength == 0)\n\t\tgoto fail;\n\n\tcache_bitmap_v2->bitmapDataStream = malloc(cache_bitmap_v2->bitmapLength);\n\n\tif (!cache_bitmap_v2->bitmapDataStream)\n\t\tgoto fail;\n\n\tStream_Read(s, cache_bitmap_v2->bitmapDataStream, cache_bitmap_v2->bitmapLength);\n\tcache_bitmap_v2->compressed = compressed;\n\treturn cache_bitmap_v2;\nfail:\n\tfree_cache_bitmap_v2_order(update->context, cache_bitmap_v2);\n\treturn NULL;\n}",
        "start_line": 2016
      },
      {
        "filename": "libfreerdp/core/orders.c",
        "method_name": "update_write_cache_bitmap_v2_order",
        "raw_code": "BOOL update_write_cache_bitmap_v2_order(wStream* s, CACHE_BITMAP_V2_ORDER* cache_bitmap_v2, /* <=== update_write_cache_bitmap_v2_order */ \n                                        BOOL compressed, UINT16* flags)\n{\n\tBYTE bitsPerPixelId;\n\n\tif (!Stream_EnsureRemainingCapacity(\n\t        s, update_approximate_cache_bitmap_v2_order(cache_bitmap_v2, compressed, flags)))\n\t\treturn FALSE;\n\n\tbitsPerPixelId = BPP_CBR2[cache_bitmap_v2->bitmapBpp];\n\t*flags = (cache_bitmap_v2->cacheId & 0x0003) | (bitsPerPixelId << 3) |\n\t         ((cache_bitmap_v2->flags << 7) & 0xFF80);\n\n\tif (cache_bitmap_v2->flags & CBR2_PERSISTENT_KEY_PRESENT)\n\t{\n\t\tStream_Write_UINT32(s, cache_bitmap_v2->key1); /* key1 (4 bytes) */\n\t\tStream_Write_UINT32(s, cache_bitmap_v2->key2); /* key2 (4 bytes) */\n\t}\n\n\tif (cache_bitmap_v2->flags & CBR2_HEIGHT_SAME_AS_WIDTH)\n\t{\n\t\tif (!update_write_2byte_unsigned(s, cache_bitmap_v2->bitmapWidth)) /* bitmapWidth */\n\t\t\treturn FALSE;\n\t}\n\telse\n\t{\n\t\tif (!update_write_2byte_unsigned(s, cache_bitmap_v2->bitmapWidth) || /* bitmapWidth */\n\t\t    !update_write_2byte_unsigned(s, cache_bitmap_v2->bitmapHeight))  /* bitmapHeight */\n\t\t\treturn FALSE;\n\t}\n\n\tif (cache_bitmap_v2->flags & CBR2_DO_NOT_CACHE)\n\t\tcache_bitmap_v2->cacheIndex = BITMAP_CACHE_WAITING_LIST_INDEX;\n\n\tif (!update_write_4byte_unsigned(s, cache_bitmap_v2->bitmapLength) || /* bitmapLength */\n\t    !update_write_2byte_unsigned(s, cache_bitmap_v2->cacheIndex))     /* cacheIndex */\n\t\treturn FALSE;\n\n\tif (compressed)\n\t{\n\t\tif (!(cache_bitmap_v2->flags & CBR2_NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tStream_Write_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbCompFirstRowSize); /* cbCompFirstRowSize (2 bytes) */\n\t\t\tStream_Write_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbCompMainBodySize);          /* cbCompMainBodySize (2 bytes) */\n\t\t\tStream_Write_UINT16(s, cache_bitmap_v2->cbScanWidth); /* cbScanWidth (2 bytes) */\n\t\t\tStream_Write_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbUncompressedSize); /* cbUncompressedSize (2 bytes) */\n\t\t\tcache_bitmap_v2->bitmapLength = cache_bitmap_v2->cbCompMainBodySize;\n\t\t}\n\n\t\tif (!Stream_EnsureRemainingCapacity(s, cache_bitmap_v2->bitmapLength))\n\t\t\treturn FALSE;\n\n\t\tStream_Write(s, cache_bitmap_v2->bitmapDataStream, cache_bitmap_v2->bitmapLength);\n\t}\n\telse\n\t{\n\t\tif (!Stream_EnsureRemainingCapacity(s, cache_bitmap_v2->bitmapLength))\n\t\t\treturn FALSE;\n\n\t\tStream_Write(s, cache_bitmap_v2->bitmapDataStream, cache_bitmap_v2->bitmapLength);\n\t}\n\n\tcache_bitmap_v2->compressed = compressed;\n\treturn TRUE;\n}",
        "start_line": 2109
      },
      {
        "filename": "libfreerdp/core/orders.c",
        "method_name": "update_read_cache_bitmap_v3_order",
        "raw_code": "static CACHE_BITMAP_V3_ORDER* update_read_cache_bitmap_v3_order(rdpUpdate* update, wStream* s, /* <=== update_read_cache_bitmap_v3_order */ \n                                                                UINT16 flags)\n{\n\tBYTE bitsPerPixelId;\n\tBITMAP_DATA_EX* bitmapData;\n\tUINT32 new_len;\n\tBYTE* new_data;\n\tCACHE_BITMAP_V3_ORDER* cache_bitmap_v3;\n\n\tif (!update || !s)\n\t\treturn NULL;\n\n\tcache_bitmap_v3 = calloc(1, sizeof(CACHE_BITMAP_V3_ORDER));\n\n\tif (!cache_bitmap_v3)\n\t\tgoto fail;\n\n\tcache_bitmap_v3->cacheId = flags & 0x00000003;\n\tcache_bitmap_v3->flags = (flags & 0x0000FF80) >> 7;\n\tbitsPerPixelId = (flags & 0x00000078) >> 3;\n\tcache_bitmap_v3->bpp = CBR23_BPP[bitsPerPixelId];\n\n\tif (Stream_GetRemainingLength(s) < 21)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, cache_bitmap_v3->cacheIndex); /* cacheIndex (2 bytes) */\n\tStream_Read_UINT32(s, cache_bitmap_v3->key1);       /* key1 (4 bytes) */\n\tStream_Read_UINT32(s, cache_bitmap_v3->key2);       /* key2 (4 bytes) */\n\tbitmapData = &cache_bitmap_v3->bitmapData;\n\tStream_Read_UINT8(s, bitmapData->bpp);\n\n\tif ((bitmapData->bpp < 1) || (bitmapData->bpp > 32))\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"invalid bpp value %\" PRIu32 \"\", bitmapData->bpp);\n\t\tgoto fail;\n\t}\n\n\tStream_Seek_UINT8(s);                      /* reserved1 (1 byte) */\n\tStream_Seek_UINT8(s);                      /* reserved2 (1 byte) */\n\tStream_Read_UINT8(s, bitmapData->codecID); /* codecID (1 byte) */\n\tStream_Read_UINT16(s, bitmapData->width);  /* width (2 bytes) */\n\tStream_Read_UINT16(s, bitmapData->height); /* height (2 bytes) */\n\tStream_Read_UINT32(s, new_len);            /* length (4 bytes) */\n\n\tif ((new_len == 0) || (Stream_GetRemainingLength(s) < new_len))\n\t\tgoto fail;\n\n\tnew_data = (BYTE*)realloc(bitmapData->data, new_len);\n\n\tif (!new_data)\n\t\tgoto fail;\n\n\tbitmapData->data = new_data;\n\tbitmapData->length = new_len;\n\tStream_Read(s, bitmapData->data, bitmapData->length);\n\treturn cache_bitmap_v3;\nfail:\n\tfree_cache_bitmap_v3_order(update->context, cache_bitmap_v3);\n\treturn NULL;\n}",
        "start_line": 2177
      },
      {
        "filename": "libfreerdp/core/orders.c",
        "method_name": "update_write_cache_bitmap_v3_order",
        "raw_code": "BOOL update_write_cache_bitmap_v3_order(wStream* s, CACHE_BITMAP_V3_ORDER* cache_bitmap_v3, /* <=== update_write_cache_bitmap_v3_order */ \n                                        UINT16* flags)\n{\n\tBYTE bitsPerPixelId;\n\tBITMAP_DATA_EX* bitmapData;\n\n\tif (!Stream_EnsureRemainingCapacity(\n\t        s, update_approximate_cache_bitmap_v3_order(cache_bitmap_v3, flags)))\n\t\treturn FALSE;\n\n\tbitmapData = &cache_bitmap_v3->bitmapData;\n\tbitsPerPixelId = BPP_CBR23[cache_bitmap_v3->bpp];\n\t*flags = (cache_bitmap_v3->cacheId & 0x00000003) |\n\t         ((cache_bitmap_v3->flags << 7) & 0x0000FF80) | ((bitsPerPixelId << 3) & 0x00000078);\n\tStream_Write_UINT16(s, cache_bitmap_v3->cacheIndex); /* cacheIndex (2 bytes) */\n\tStream_Write_UINT32(s, cache_bitmap_v3->key1);       /* key1 (4 bytes) */\n\tStream_Write_UINT32(s, cache_bitmap_v3->key2);       /* key2 (4 bytes) */\n\tStream_Write_UINT8(s, bitmapData->bpp);\n\tStream_Write_UINT8(s, 0);                   /* reserved1 (1 byte) */\n\tStream_Write_UINT8(s, 0);                   /* reserved2 (1 byte) */\n\tStream_Write_UINT8(s, bitmapData->codecID); /* codecID (1 byte) */\n\tStream_Write_UINT16(s, bitmapData->width);  /* width (2 bytes) */\n\tStream_Write_UINT16(s, bitmapData->height); /* height (2 bytes) */\n\tStream_Write_UINT32(s, bitmapData->length); /* length (4 bytes) */\n\tStream_Write(s, bitmapData->data, bitmapData->length);\n\treturn TRUE;\n}",
        "start_line": 2242
      },
      {
        "filename": "libfreerdp/core/orders.c",
        "method_name": "update_read_cache_brush_order",
        "raw_code": "static CACHE_BRUSH_ORDER* update_read_cache_brush_order(rdpUpdate* update, wStream* s, UINT16 flags) /* <=== update_read_cache_brush_order */ \n{\n\tint i;\n\tBYTE iBitmapFormat;\n\tBOOL compressed = FALSE;\n\tCACHE_BRUSH_ORDER* cache_brush = calloc(1, sizeof(CACHE_BRUSH_ORDER));\n\n\tif (!cache_brush)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 6)\n\t\tgoto fail;\n\n\tStream_Read_UINT8(s, cache_brush->index); /* cacheEntry (1 byte) */\n\tStream_Read_UINT8(s, iBitmapFormat);      /* iBitmapFormat (1 byte) */\n\n\tif (iBitmapFormat >= ARRAYSIZE(BMF_BPP))\n\t\tgoto fail;\n\n\tcache_brush->bpp = BMF_BPP[iBitmapFormat];\n\tStream_Read_UINT8(s, cache_brush->cx);     /* cx (1 byte) */\n\tStream_Read_UINT8(s, cache_brush->cy);     /* cy (1 byte) */\n\tStream_Read_UINT8(s, cache_brush->style);  /* style (1 byte) */\n\tStream_Read_UINT8(s, cache_brush->length); /* iBytes (1 byte) */\n\n\tif ((cache_brush->cx == 8) && (cache_brush->cy == 8))\n\t{\n\t\tif (cache_brush->bpp == 1)\n\t\t{\n\t\t\tif (cache_brush->length != 8)\n\t\t\t{\n\t\t\t\tWLog_Print(update->log, WLOG_ERROR, \"incompatible 1bpp brush of length:%\" PRIu32 \"\",\n\t\t\t\t           cache_brush->length);\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\t/* rows are encoded in reverse order */\n\t\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\t\tgoto fail;\n\n\t\t\tfor (i = 7; i >= 0; i--)\n\t\t\t{\n\t\t\t\tStream_Read_UINT8(s, cache_brush->data[i]);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((iBitmapFormat == BMF_8BPP) && (cache_brush->length == 20))\n\t\t\t\tcompressed = TRUE;\n\t\t\telse if ((iBitmapFormat == BMF_16BPP) && (cache_brush->length == 24))\n\t\t\t\tcompressed = TRUE;\n\t\t\telse if ((iBitmapFormat == BMF_32BPP) && (cache_brush->length == 32))\n\t\t\t\tcompressed = TRUE;\n\n\t\t\tif (compressed != FALSE)\n\t\t\t{\n\t\t\t\t/* compressed brush */\n\t\t\t\tif (!update_decompress_brush(s, cache_brush->data, sizeof(cache_brush->data),\n\t\t\t\t                             cache_brush->bpp))\n\t\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* uncompressed brush */\n\t\t\t\tUINT32 scanline = (cache_brush->bpp / 8) * 8;\n\n\t\t\t\tif (Stream_GetRemainingLength(s) < scanline * 8)\n\t\t\t\t\tgoto fail;\n\n\t\t\t\tfor (i = 7; i >= 0; i--)\n\t\t\t\t{\n\t\t\t\t\tStream_Read(s, &cache_brush->data[i * scanline], scanline);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cache_brush;\nfail:\n\tfree_cache_brush_order(update->context, cache_brush);\n\treturn NULL;\n}",
        "start_line": 2574
      },
      {
        "filename": "libfreerdp/core/orders.c",
        "method_name": "update_write_cache_brush_order",
        "raw_code": "BOOL update_write_cache_brush_order(wStream* s, const CACHE_BRUSH_ORDER* cache_brush, UINT16* flags) /* <=== update_write_cache_brush_order */ \n{\n\tint i;\n\tBYTE iBitmapFormat;\n\tBOOL compressed = FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s,\n\t                                    update_approximate_cache_brush_order(cache_brush, flags)))\n\t\treturn FALSE;\n\n\tiBitmapFormat = BPP_BMF[cache_brush->bpp];\n\tStream_Write_UINT8(s, cache_brush->index);  /* cacheEntry (1 byte) */\n\tStream_Write_UINT8(s, iBitmapFormat);       /* iBitmapFormat (1 byte) */\n\tStream_Write_UINT8(s, cache_brush->cx);     /* cx (1 byte) */\n\tStream_Write_UINT8(s, cache_brush->cy);     /* cy (1 byte) */\n\tStream_Write_UINT8(s, cache_brush->style);  /* style (1 byte) */\n\tStream_Write_UINT8(s, cache_brush->length); /* iBytes (1 byte) */\n\n\tif ((cache_brush->cx == 8) && (cache_brush->cy == 8))\n\t{\n\t\tif (cache_brush->bpp == 1)\n\t\t{\n\t\t\tif (cache_brush->length != 8)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"incompatible 1bpp brush of length:%\" PRIu32 \"\", cache_brush->length);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tfor (i = 7; i >= 0; i--)\n\t\t\t{\n\t\t\t\tStream_Write_UINT8(s, cache_brush->data[i]);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((iBitmapFormat == BMF_8BPP) && (cache_brush->length == 20))\n\t\t\t\tcompressed = TRUE;\n\t\t\telse if ((iBitmapFormat == BMF_16BPP) && (cache_brush->length == 24))\n\t\t\t\tcompressed = TRUE;\n\t\t\telse if ((iBitmapFormat == BMF_32BPP) && (cache_brush->length == 32))\n\t\t\t\tcompressed = TRUE;\n\n\t\t\tif (compressed != FALSE)\n\t\t\t{\n\t\t\t\t/* compressed brush */\n\t\t\t\tif (!update_compress_brush(s, cache_brush->data, cache_brush->bpp))\n\t\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* uncompressed brush */\n\t\t\t\tint scanline = (cache_brush->bpp / 8) * 8;\n\n\t\t\t\tfor (i = 7; i >= 0; i--)\n\t\t\t\t{\n\t\t\t\t\tStream_Write(s, &cache_brush->data[i * scanline], scanline);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn TRUE;\n}",
        "start_line": 2660
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "libfreerdp/core/orders.c",
        "method_name": "get_cbr2_bpp",
        "raw_code": "static BYTE get_cbr2_bpp(UINT32 bpp, BOOL* pValid) /* <=== get_cbr2_bpp */ \n{\n\tif (pValid)\n\t\t*pValid = TRUE;\n\tswitch (bpp)\n\t{\n\t\tcase 3:\n\t\t\treturn 8;\n\t\tcase 4:\n\t\t\treturn 16;\n\t\tcase 5:\n\t\t\treturn 24;\n\t\tcase 6:\n\t\t\treturn 32;\n\t\tdefault:\n\t\t\tWLog_WARN(TAG, \"Invalid bpp %\" PRIu32, bpp);\n\t\t\tif (pValid)\n\t\t\t\t*pValid = FALSE;\n\t\t\treturn 0;\n\t}\n}",
        "start_line": 116
      },
      {
        "filename": "libfreerdp/core/orders.c",
        "method_name": "get_bmf_bpp",
        "raw_code": "static BYTE get_bmf_bpp(UINT32 bmf, BOOL* pValid) /* <=== get_bmf_bpp */ \n{\n\tif (pValid)\n\t\t*pValid = TRUE;\n\tswitch (bmf)\n\t{\n\t\tcase 1:\n\t\t\treturn 1;\n\t\tcase 3:\n\t\t\treturn 8;\n\t\tcase 4:\n\t\t\treturn 16;\n\t\tcase 5:\n\t\t\treturn 24;\n\t\tcase 6:\n\t\t\treturn 32;\n\t\tdefault:\n\t\t\tWLog_WARN(TAG, \"Invalid bmf %\" PRIu32, bmf);\n\t\t\tif (pValid)\n\t\t\t\t*pValid = FALSE;\n\t\t\treturn 0;\n\t}\n}",
        "start_line": 138
      },
      {
        "filename": "libfreerdp/core/orders.c",
        "method_name": "get_bpp_bmf",
        "raw_code": "static BYTE get_bpp_bmf(UINT32 bpp, BOOL* pValid) /* <=== get_bpp_bmf */ \n{\n\tif (pValid)\n\t\t*pValid = TRUE;\n\tswitch (bpp)\n\t{\n\t\tcase 1:\n\t\t\treturn 1;\n\t\tcase 8:\n\t\t\treturn 3;\n\t\tcase 16:\n\t\t\treturn 4;\n\t\tcase 24:\n\t\t\treturn 5;\n\t\tcase 32:\n\t\t\treturn 6;\n\t\tdefault:\n\t\t\tWLog_WARN(TAG, \"Invalid color depth %\" PRIu32, bpp);\n\t\t\tif (pValid)\n\t\t\t\t*pValid = FALSE;\n\t\t\treturn 0;\n\t}\n}",
        "start_line": 161
      },
      {
        "filename": "libfreerdp/core/orders.c",
        "method_name": "check_order_activated",
        "raw_code": "static BOOL check_order_activated(wLog* log, rdpSettings* settings, const char* orderName, /* <=== check_order_activated */ \n                                  BOOL condition)\n{\n\tif (!condition)\n\t{\n\t\tif (settings->AllowUnanouncedOrdersFromServer)\n\t\t{\n\t\t\tWLog_Print(log, WLOG_WARN,\n\t\t\t           \"%s - SERVER BUG: The support for this feature was not announced!\",\n\t\t\t           orderName);\n\t\t\treturn TRUE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tWLog_Print(log, WLOG_ERROR,\n\t\t\t           \"%s - SERVER BUG: The support for this feature was not announced! Use \"\n\t\t\t           \"/relax-order-checks to ignore\",\n\t\t\t           orderName);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\treturn TRUE;\n}",
        "start_line": 185
      },
      {
        "filename": "libfreerdp/core/orders.c",
        "method_name": "update_read_cache_bitmap_v2_order",
        "raw_code": "static CACHE_BITMAP_V2_ORDER* update_read_cache_bitmap_v2_order(rdpUpdate* update, wStream* s, /* <=== update_read_cache_bitmap_v2_order */ \n                                                                BOOL compressed, UINT16 flags)\n{\n\tBOOL rc;\n\tBYTE bitsPerPixelId;\n\tCACHE_BITMAP_V2_ORDER* cache_bitmap_v2;\n\n\tif (!update || !s)\n\t\treturn NULL;\n\n\tcache_bitmap_v2 = calloc(1, sizeof(CACHE_BITMAP_V2_ORDER));\n\n\tif (!cache_bitmap_v2)\n\t\tgoto fail;\n\n\tcache_bitmap_v2->cacheId = flags & 0x0003;\n\tcache_bitmap_v2->flags = (flags & 0xFF80) >> 7;\n\tbitsPerPixelId = (flags & 0x0078) >> 3;\n\tcache_bitmap_v2->bitmapBpp = get_cbr2_bpp(bitsPerPixelId, &rc);\n\tif (!rc)\n\t\tgoto fail;\n\n\tif (cache_bitmap_v2->flags & CBR2_PERSISTENT_KEY_PRESENT)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\tgoto fail;\n\n\t\tStream_Read_UINT32(s, cache_bitmap_v2->key1); /* key1 (4 bytes) */\n\t\tStream_Read_UINT32(s, cache_bitmap_v2->key2); /* key2 (4 bytes) */\n\t}\n\n\tif (cache_bitmap_v2->flags & CBR2_HEIGHT_SAME_AS_WIDTH)\n\t{\n\t\tif (!update_read_2byte_unsigned(s, &cache_bitmap_v2->bitmapWidth)) /* bitmapWidth */\n\t\t\tgoto fail;\n\n\t\tcache_bitmap_v2->bitmapHeight = cache_bitmap_v2->bitmapWidth;\n\t}\n\telse\n\t{\n\t\tif (!update_read_2byte_unsigned(s, &cache_bitmap_v2->bitmapWidth) || /* bitmapWidth */\n\t\t    !update_read_2byte_unsigned(s, &cache_bitmap_v2->bitmapHeight))  /* bitmapHeight */\n\t\t\tgoto fail;\n\t}\n\n\tif (!update_read_4byte_unsigned(s, &cache_bitmap_v2->bitmapLength) || /* bitmapLength */\n\t    !update_read_2byte_unsigned(s, &cache_bitmap_v2->cacheIndex))     /* cacheIndex */\n\t\tgoto fail;\n\n\tif (cache_bitmap_v2->flags & CBR2_DO_NOT_CACHE)\n\t\tcache_bitmap_v2->cacheIndex = BITMAP_CACHE_WAITING_LIST_INDEX;\n\n\tif (compressed)\n\t{\n\t\tif (!(cache_bitmap_v2->flags & CBR2_NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\t\tgoto fail;\n\n\t\t\tStream_Read_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbCompFirstRowSize); /* cbCompFirstRowSize (2 bytes) */\n\t\t\tStream_Read_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbCompMainBodySize);         /* cbCompMainBodySize (2 bytes) */\n\t\t\tStream_Read_UINT16(s, cache_bitmap_v2->cbScanWidth); /* cbScanWidth (2 bytes) */\n\t\t\tStream_Read_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbUncompressedSize); /* cbUncompressedSize (2 bytes) */\n\t\t\tcache_bitmap_v2->bitmapLength = cache_bitmap_v2->cbCompMainBodySize;\n\t\t}\n\t}\n\n\tif (cache_bitmap_v2->bitmapLength == 0)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < cache_bitmap_v2->bitmapLength)\n\t\tgoto fail;\n\n\tif (cache_bitmap_v2->bitmapLength == 0)\n\t\tgoto fail;\n\n\tcache_bitmap_v2->bitmapDataStream = malloc(cache_bitmap_v2->bitmapLength);\n\n\tif (!cache_bitmap_v2->bitmapDataStream)\n\t\tgoto fail;\n\n\tStream_Read(s, cache_bitmap_v2->bitmapDataStream, cache_bitmap_v2->bitmapLength);\n\tcache_bitmap_v2->compressed = compressed;\n\treturn cache_bitmap_v2;\nfail:\n\tfree_cache_bitmap_v2_order(update->context, cache_bitmap_v2);\n\treturn NULL;\n}",
        "start_line": 2074
      },
      {
        "filename": "libfreerdp/core/orders.c",
        "method_name": "update_write_cache_bitmap_v2_order",
        "raw_code": "BOOL update_write_cache_bitmap_v2_order(wStream* s, CACHE_BITMAP_V2_ORDER* cache_bitmap_v2, /* <=== update_write_cache_bitmap_v2_order */ \n                                        BOOL compressed, UINT16* flags)\n{\n\tBOOL rc;\n\tBYTE bitsPerPixelId;\n\n\tif (!Stream_EnsureRemainingCapacity(\n\t        s, update_approximate_cache_bitmap_v2_order(cache_bitmap_v2, compressed, flags)))\n\t\treturn FALSE;\n\n\tbitsPerPixelId = get_bpp_bmf(cache_bitmap_v2->bitmapBpp, &rc);\n\tif (!rc)\n\t\treturn FALSE;\n\t*flags = (cache_bitmap_v2->cacheId & 0x0003) | (bitsPerPixelId << 3) |\n\t         ((cache_bitmap_v2->flags << 7) & 0xFF80);\n\n\tif (cache_bitmap_v2->flags & CBR2_PERSISTENT_KEY_PRESENT)\n\t{\n\t\tStream_Write_UINT32(s, cache_bitmap_v2->key1); /* key1 (4 bytes) */\n\t\tStream_Write_UINT32(s, cache_bitmap_v2->key2); /* key2 (4 bytes) */\n\t}\n\n\tif (cache_bitmap_v2->flags & CBR2_HEIGHT_SAME_AS_WIDTH)\n\t{\n\t\tif (!update_write_2byte_unsigned(s, cache_bitmap_v2->bitmapWidth)) /* bitmapWidth */\n\t\t\treturn FALSE;\n\t}\n\telse\n\t{\n\t\tif (!update_write_2byte_unsigned(s, cache_bitmap_v2->bitmapWidth) || /* bitmapWidth */\n\t\t    !update_write_2byte_unsigned(s, cache_bitmap_v2->bitmapHeight))  /* bitmapHeight */\n\t\t\treturn FALSE;\n\t}\n\n\tif (cache_bitmap_v2->flags & CBR2_DO_NOT_CACHE)\n\t\tcache_bitmap_v2->cacheIndex = BITMAP_CACHE_WAITING_LIST_INDEX;\n\n\tif (!update_write_4byte_unsigned(s, cache_bitmap_v2->bitmapLength) || /* bitmapLength */\n\t    !update_write_2byte_unsigned(s, cache_bitmap_v2->cacheIndex))     /* cacheIndex */\n\t\treturn FALSE;\n\n\tif (compressed)\n\t{\n\t\tif (!(cache_bitmap_v2->flags & CBR2_NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tStream_Write_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbCompFirstRowSize); /* cbCompFirstRowSize (2 bytes) */\n\t\t\tStream_Write_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbCompMainBodySize);          /* cbCompMainBodySize (2 bytes) */\n\t\t\tStream_Write_UINT16(s, cache_bitmap_v2->cbScanWidth); /* cbScanWidth (2 bytes) */\n\t\t\tStream_Write_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbUncompressedSize); /* cbUncompressedSize (2 bytes) */\n\t\t\tcache_bitmap_v2->bitmapLength = cache_bitmap_v2->cbCompMainBodySize;\n\t\t}\n\n\t\tif (!Stream_EnsureRemainingCapacity(s, cache_bitmap_v2->bitmapLength))\n\t\t\treturn FALSE;\n\n\t\tStream_Write(s, cache_bitmap_v2->bitmapDataStream, cache_bitmap_v2->bitmapLength);\n\t}\n\telse\n\t{\n\t\tif (!Stream_EnsureRemainingCapacity(s, cache_bitmap_v2->bitmapLength))\n\t\t\treturn FALSE;\n\n\t\tStream_Write(s, cache_bitmap_v2->bitmapDataStream, cache_bitmap_v2->bitmapLength);\n\t}\n\n\tcache_bitmap_v2->compressed = compressed;\n\treturn TRUE;\n}",
        "start_line": 2170
      },
      {
        "filename": "libfreerdp/core/orders.c",
        "method_name": "update_read_cache_bitmap_v3_order",
        "raw_code": "static CACHE_BITMAP_V3_ORDER* update_read_cache_bitmap_v3_order(rdpUpdate* update, wStream* s, /* <=== update_read_cache_bitmap_v3_order */ \n                                                                UINT16 flags)\n{\n\tBOOL rc;\n\tBYTE bitsPerPixelId;\n\tBITMAP_DATA_EX* bitmapData;\n\tUINT32 new_len;\n\tBYTE* new_data;\n\tCACHE_BITMAP_V3_ORDER* cache_bitmap_v3;\n\n\tif (!update || !s)\n\t\treturn NULL;\n\n\tcache_bitmap_v3 = calloc(1, sizeof(CACHE_BITMAP_V3_ORDER));\n\n\tif (!cache_bitmap_v3)\n\t\tgoto fail;\n\n\tcache_bitmap_v3->cacheId = flags & 0x00000003;\n\tcache_bitmap_v3->flags = (flags & 0x0000FF80) >> 7;\n\tbitsPerPixelId = (flags & 0x00000078) >> 3;\n\tcache_bitmap_v3->bpp = get_cbr2_bpp(bitsPerPixelId, &rc);\n\tif (!rc)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 21)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, cache_bitmap_v3->cacheIndex); /* cacheIndex (2 bytes) */\n\tStream_Read_UINT32(s, cache_bitmap_v3->key1);       /* key1 (4 bytes) */\n\tStream_Read_UINT32(s, cache_bitmap_v3->key2);       /* key2 (4 bytes) */\n\tbitmapData = &cache_bitmap_v3->bitmapData;\n\tStream_Read_UINT8(s, bitmapData->bpp);\n\n\tif ((bitmapData->bpp < 1) || (bitmapData->bpp > 32))\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"invalid bpp value %\" PRIu32 \"\", bitmapData->bpp);\n\t\tgoto fail;\n\t}\n\n\tStream_Seek_UINT8(s);                      /* reserved1 (1 byte) */\n\tStream_Seek_UINT8(s);                      /* reserved2 (1 byte) */\n\tStream_Read_UINT8(s, bitmapData->codecID); /* codecID (1 byte) */\n\tStream_Read_UINT16(s, bitmapData->width);  /* width (2 bytes) */\n\tStream_Read_UINT16(s, bitmapData->height); /* height (2 bytes) */\n\tStream_Read_UINT32(s, new_len);            /* length (4 bytes) */\n\n\tif ((new_len == 0) || (Stream_GetRemainingLength(s) < new_len))\n\t\tgoto fail;\n\n\tnew_data = (BYTE*)realloc(bitmapData->data, new_len);\n\n\tif (!new_data)\n\t\tgoto fail;\n\n\tbitmapData->data = new_data;\n\tbitmapData->length = new_len;\n\tStream_Read(s, bitmapData->data, bitmapData->length);\n\treturn cache_bitmap_v3;\nfail:\n\tfree_cache_bitmap_v3_order(update->context, cache_bitmap_v3);\n\treturn NULL;\n}",
        "start_line": 2241
      },
      {
        "filename": "libfreerdp/core/orders.c",
        "method_name": "update_write_cache_bitmap_v3_order",
        "raw_code": "BOOL update_write_cache_bitmap_v3_order(wStream* s, CACHE_BITMAP_V3_ORDER* cache_bitmap_v3, /* <=== update_write_cache_bitmap_v3_order */ \n                                        UINT16* flags)\n{\n\tBOOL rc;\n\tBYTE bitsPerPixelId;\n\tBITMAP_DATA_EX* bitmapData;\n\n\tif (!Stream_EnsureRemainingCapacity(\n\t        s, update_approximate_cache_bitmap_v3_order(cache_bitmap_v3, flags)))\n\t\treturn FALSE;\n\n\tbitmapData = &cache_bitmap_v3->bitmapData;\n\tbitsPerPixelId = get_bpp_bmf(cache_bitmap_v3->bpp, &rc);\n\tif (!rc)\n\t\treturn FALSE;\n\t*flags = (cache_bitmap_v3->cacheId & 0x00000003) |\n\t         ((cache_bitmap_v3->flags << 7) & 0x0000FF80) | ((bitsPerPixelId << 3) & 0x00000078);\n\tStream_Write_UINT16(s, cache_bitmap_v3->cacheIndex); /* cacheIndex (2 bytes) */\n\tStream_Write_UINT32(s, cache_bitmap_v3->key1);       /* key1 (4 bytes) */\n\tStream_Write_UINT32(s, cache_bitmap_v3->key2);       /* key2 (4 bytes) */\n\tStream_Write_UINT8(s, bitmapData->bpp);\n\tStream_Write_UINT8(s, 0);                   /* reserved1 (1 byte) */\n\tStream_Write_UINT8(s, 0);                   /* reserved2 (1 byte) */\n\tStream_Write_UINT8(s, bitmapData->codecID); /* codecID (1 byte) */\n\tStream_Write_UINT16(s, bitmapData->width);  /* width (2 bytes) */\n\tStream_Write_UINT16(s, bitmapData->height); /* height (2 bytes) */\n\tStream_Write_UINT32(s, bitmapData->length); /* length (4 bytes) */\n\tStream_Write(s, bitmapData->data, bitmapData->length);\n\treturn TRUE;\n}",
        "start_line": 2309
      },
      {
        "filename": "libfreerdp/core/orders.c",
        "method_name": "update_read_cache_brush_order",
        "raw_code": "static CACHE_BRUSH_ORDER* update_read_cache_brush_order(rdpUpdate* update, wStream* s, UINT16 flags) /* <=== update_read_cache_brush_order */ \n{\n\tint i;\n\tBOOL rc;\n\tBYTE iBitmapFormat;\n\tBOOL compressed = FALSE;\n\tCACHE_BRUSH_ORDER* cache_brush = calloc(1, sizeof(CACHE_BRUSH_ORDER));\n\n\tif (!cache_brush)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 6)\n\t\tgoto fail;\n\n\tStream_Read_UINT8(s, cache_brush->index); /* cacheEntry (1 byte) */\n\tStream_Read_UINT8(s, iBitmapFormat);      /* iBitmapFormat (1 byte) */\n\n\tcache_brush->bpp = get_bmf_bpp(iBitmapFormat, &rc);\n\tif (!rc)\n\t\tgoto fail;\n\n\tStream_Read_UINT8(s, cache_brush->cx);     /* cx (1 byte) */\n\tStream_Read_UINT8(s, cache_brush->cy);     /* cy (1 byte) */\n\tStream_Read_UINT8(s, cache_brush->style);  /* style (1 byte) */\n\tStream_Read_UINT8(s, cache_brush->length); /* iBytes (1 byte) */\n\n\tif ((cache_brush->cx == 8) && (cache_brush->cy == 8))\n\t{\n\t\tif (cache_brush->bpp == 1)\n\t\t{\n\t\t\tif (cache_brush->length != 8)\n\t\t\t{\n\t\t\t\tWLog_Print(update->log, WLOG_ERROR, \"incompatible 1bpp brush of length:%\" PRIu32 \"\",\n\t\t\t\t           cache_brush->length);\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\t/* rows are encoded in reverse order */\n\t\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\t\tgoto fail;\n\n\t\t\tfor (i = 7; i >= 0; i--)\n\t\t\t{\n\t\t\t\tStream_Read_UINT8(s, cache_brush->data[i]);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((iBitmapFormat == BMF_8BPP) && (cache_brush->length == 20))\n\t\t\t\tcompressed = TRUE;\n\t\t\telse if ((iBitmapFormat == BMF_16BPP) && (cache_brush->length == 24))\n\t\t\t\tcompressed = TRUE;\n\t\t\telse if ((iBitmapFormat == BMF_32BPP) && (cache_brush->length == 32))\n\t\t\t\tcompressed = TRUE;\n\n\t\t\tif (compressed != FALSE)\n\t\t\t{\n\t\t\t\t/* compressed brush */\n\t\t\t\tif (!update_decompress_brush(s, cache_brush->data, sizeof(cache_brush->data),\n\t\t\t\t                             cache_brush->bpp))\n\t\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* uncompressed brush */\n\t\t\t\tUINT32 scanline = (cache_brush->bpp / 8) * 8;\n\n\t\t\t\tif (Stream_GetRemainingLength(s) < scanline * 8)\n\t\t\t\t\tgoto fail;\n\n\t\t\t\tfor (i = 7; i >= 0; i--)\n\t\t\t\t{\n\t\t\t\t\tStream_Read(s, &cache_brush->data[i * scanline], scanline);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cache_brush;\nfail:\n\tfree_cache_brush_order(update->context, cache_brush);\n\treturn NULL;\n}",
        "start_line": 2644
      },
      {
        "filename": "libfreerdp/core/orders.c",
        "method_name": "update_write_cache_brush_order",
        "raw_code": "BOOL update_write_cache_brush_order(wStream* s, const CACHE_BRUSH_ORDER* cache_brush, UINT16* flags) /* <=== update_write_cache_brush_order */ \n{\n\tint i;\n\tBYTE iBitmapFormat;\n\tBOOL rc;\n\tBOOL compressed = FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s,\n\t                                    update_approximate_cache_brush_order(cache_brush, flags)))\n\t\treturn FALSE;\n\n\tiBitmapFormat = get_bpp_bmf(cache_brush->bpp, &rc);\n\tif (!rc)\n\t\treturn FALSE;\n\tStream_Write_UINT8(s, cache_brush->index);  /* cacheEntry (1 byte) */\n\tStream_Write_UINT8(s, iBitmapFormat);       /* iBitmapFormat (1 byte) */\n\tStream_Write_UINT8(s, cache_brush->cx);     /* cx (1 byte) */\n\tStream_Write_UINT8(s, cache_brush->cy);     /* cy (1 byte) */\n\tStream_Write_UINT8(s, cache_brush->style);  /* style (1 byte) */\n\tStream_Write_UINT8(s, cache_brush->length); /* iBytes (1 byte) */\n\n\tif ((cache_brush->cx == 8) && (cache_brush->cy == 8))\n\t{\n\t\tif (cache_brush->bpp == 1)\n\t\t{\n\t\t\tif (cache_brush->length != 8)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"incompatible 1bpp brush of length:%\" PRIu32 \"\", cache_brush->length);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tfor (i = 7; i >= 0; i--)\n\t\t\t{\n\t\t\t\tStream_Write_UINT8(s, cache_brush->data[i]);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((iBitmapFormat == BMF_8BPP) && (cache_brush->length == 20))\n\t\t\t\tcompressed = TRUE;\n\t\t\telse if ((iBitmapFormat == BMF_16BPP) && (cache_brush->length == 24))\n\t\t\t\tcompressed = TRUE;\n\t\t\telse if ((iBitmapFormat == BMF_32BPP) && (cache_brush->length == 32))\n\t\t\t\tcompressed = TRUE;\n\n\t\t\tif (compressed != FALSE)\n\t\t\t{\n\t\t\t\t/* compressed brush */\n\t\t\t\tif (!update_compress_brush(s, cache_brush->data, cache_brush->bpp))\n\t\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* uncompressed brush */\n\t\t\t\tint scanline = (cache_brush->bpp / 8) * 8;\n\n\t\t\t\tfor (i = 7; i >= 0; i--)\n\t\t\t\t{\n\t\t\t\t\tStream_Write(s, &cache_brush->data[i * scanline], scanline);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn TRUE;\n}",
        "start_line": 2731
      }
    ],
    "code_context": "Called Methods:\n- update_approximate_cache_brush_order: int update_approximate_cache_brush_order(const CACHE_BRUSH_ORDER* cache_brush, UINT16* flags) /* <=== update_approximate_cache_brush_order */ \n{\n\treturn 64;\n}\n- free_cache_bitmap_v3_order: void free_cache_bitmap_v3_order(rdpContext* context, CACHE_BITMAP_V3_ORDER* order) /* <=== free_cache_bitmap_v3_order */ \n{\n\tif (order)\n\t\tfree(order->bitmapData.data);\n\n\tfree(order);\n}\n- Stream_EnsureCapacity: BOOL Stream_EnsureCapacity(wStream* s, size_t size) /* <=== Stream_EnsureCapacity */ \n{\n\tif (s->capacity < size)\n\t{\n\t\tsize_t position;\n\t\tsize_t old_capacity;\n\t\tsize_t new_capacity;\n\t\tBYTE* new_buf;\n\n\t\told_capacity = s->capacity;\n\t\tnew_capacity = old_capacity;\n\n\t\tdo\n\t\t{\n\t\t\tnew_capacity *= 2;\n\t\t} while (new_capacity < size);\n\n\t\tposition = Stream_GetPosition(s);\n\n\t\tif (!s->isOwner)\n\t\t{\n\t\t\tnew_buf = (BYTE*)malloc(new_capacity);\n\t\t\tCopyMemory(new_buf, s->buffer, s->capacity);\n\t\t\ts->isOwner = TRUE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnew_buf = (BYTE*)realloc(s->buffer, new_capacity);\n\t\t}\n\n\t\tif (!new_buf)\n\t\t\treturn FALSE;\n\t\ts->buffer = new_buf;\n\t\ts->capacity = new_capacity;\n\t\ts->length = new_capacity;\n\t\tZeroMemory(&s->buffer[old_capacity], s->capacity - old_capacity);\n\n\t\tStream_SetPosition(s, position);\n\t}\n\treturn TRUE;\n}\n- update_compress_brush: static BOOL update_compress_brush(wStream* s, const BYTE* input, BYTE bpp) /* <=== update_compress_brush */ \n{\n\treturn FALSE;\n}\n- free_cache_brush_order: void free_cache_brush_order(rdpContext* context, CACHE_BRUSH_ORDER* order) /* <=== free_cache_brush_order */ \n{\n\tfree(order);\n}\n- update_decompress_brush: static BOOL update_decompress_brush(wStream* s, BYTE* output, size_t outSize, BYTE bpp) /* <=== update_decompress_brush */ \n{\n\tINT32 x, y, k;\n\tBYTE byte = 0;\n\tconst BYTE* palette = Stream_Pointer(s) + 16;\n\tconst INT32 bytesPerPixel = ((bpp + 1) / 8);\n\n\tif (!Stream_SafeSeek(s, 16ULL + 7ULL * bytesPerPixel)) // 64 / 4\n\t\treturn FALSE;\n\n\tfor (y = 7; y >= 0; y--)\n\t{\n\t\tfor (x = 0; x < 8; x++)\n\t\t{\n\t\t\tUINT32 index;\n\t\t\tif ((x % 4) == 0)\n\t\t\t\tStream_Read_UINT8(s, byte);\n\n\t\t\tindex = ((byte >> ((3 - (x % 4)) * 2)) & 0x03);\n\n\t\t\tfor (k = 0; k < bytesPerPixel; k++)\n\t\t\t{\n\t\t\t\tconst size_t dstIndex = ((y * 8 + x) * bytesPerPixel) + k;\n\t\t\t\tconst size_t srcIndex = (index * bytesPerPixel) + k;\n\t\t\t\tif (dstIndex >= outSize)\n\t\t\t\t\treturn FALSE;\n\t\t\t\toutput[dstIndex] = palette[srcIndex];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n- update_approximate_cache_bitmap_v2_order: int update_approximate_cache_bitmap_v2_order(CACHE_BITMAP_V2_ORDER* cache_bitmap_v2, /* <=== update_approximate_cache_bitmap_v2_order */ \n                                             BOOL compressed, UINT16* flags)\n{\n\treturn 64 + cache_bitmap_v2->bitmapLength;\n}\n- free_cache_bitmap_v2_order: void free_cache_bitmap_v2_order(rdpContext* context, CACHE_BITMAP_V2_ORDER* order) /* <=== free_cache_bitmap_v2_order */ \n{\n\tif (order)\n\t\tfree(order->bitmapDataStream);\n\n\tfree(order);\n}\n- Stream_EnsureRemainingCapacity: BOOL Stream_EnsureRemainingCapacity(wStream* s, size_t size) /* <=== Stream_EnsureRemainingCapacity */ \n{\n\tif (Stream_GetPosition(s) + size > Stream_Capacity(s))\n\t\treturn Stream_EnsureCapacity(s, Stream_Capacity(s) + size);\n\treturn TRUE;\n}\n- update_approximate_cache_bitmap_v3_order: int update_approximate_cache_bitmap_v3_order(CACHE_BITMAP_V3_ORDER* cache_bitmap_v3, UINT16* flags) /* <=== update_approximate_cache_bitmap_v3_order */ \n{\n\tBITMAP_DATA_EX* bitmapData = &cache_bitmap_v3->bitmapData;\n\treturn 64 + bitmapData->length;\n}\n\nType Definitions:\n- wStream: typedef struct _wStream wStream;\n- rdpUpdate: typedef struct rdp_update rdpUpdate;\n- wLog: typedef struct _wLog wLog;\n\nGlobal Variables:\n- static const BYTE[] BMF_BPP\n- static const BYTE[] CBR23_BPP\n- static const BYTE[] BPP_BMF\n- static const BYTE[] BPP_CBR23\n- static const BYTE[] CBR2_BPP\n- static const BYTE[] BPP_CBR2\n\nImports:\n- #include \"orders.h\"\n- #include \"../cache/brush.h\"\n- #include <freerdp/log.h>\n- #include <freerdp/gdi/gdi.h>\n- #include <freerdp/graphics.h>\n- #include \"../cache/glyph.h\"\n- #include \"config.h\"\n- #include \"../cache/cache.h\"\n- #include <winpr/crt.h>\n- #include <freerdp/api.h>\n- #include <freerdp/codec/bitmap.h>\n- #include \"../cache/bitmap.h\"\n- #include \"window.h\"\n- #include <winpr/wtypes.h>",
    "commit_msg": "Fixed OOB read in update_read_cache_bitmap_v3_order\n\nCVE-2020-11096 thanks @antonio-morales for finding this.",
    "cve_desc": "In FreeRDP before version 2.1.2, there is a global OOB read in update_read_cache_bitmap_v3_order. As a workaround, one can disable bitmap cache with -bitmap-cache (default). This is fixed in version 2.1.2.",
    "year": 2020,
    "filename": "orders.c",
    "commit_url": "\"https://github.com/FreeRDP/FreeRDP/commit/b8beb55913471952f92770c90c372139d78c16c0\""
  },
  {
    "repository": "FreeRDP/FreeRDP",
    "cve_id": "CVE-2020-11098",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "c0fd449ec0870b050d350d6d844b1ea6dad4bc7d",
    "short_hash": "c0fd449e",
    "vulnerableMethods_before": [
      {
        "filename": "libfreerdp/cache/glyph.c",
        "method_name": "glyph_cache_put",
        "raw_code": "BOOL glyph_cache_put(rdpGlyphCache* glyphCache, UINT32 id, UINT32 index, rdpGlyph* glyph) /* <=== glyph_cache_put */ \n{\n\trdpGlyph* prevGlyph;\n\n\tif (id > 9)\n\t{\n\t\tWLog_ERR(TAG, \"invalid glyph cache id: %\" PRIu32 \"\", id);\n\t\treturn FALSE;\n\t}\n\n\tif (index > glyphCache->glyphCache[id].number)\n\t{\n\t\tWLog_ERR(TAG, \"invalid glyph cache index: %\" PRIu32 \" in cache id: %\" PRIu32 \"\", index, id);\n\t\treturn FALSE;\n\t}\n\n\tWLog_Print(glyphCache->log, WLOG_DEBUG, \"GlyphCachePut: id: %\" PRIu32 \" index: %\" PRIu32 \"\", id,\n\t           index);\n\tprevGlyph = glyphCache->glyphCache[id].entries[index];\n\n\tif (prevGlyph)\n\t\tprevGlyph->Free(glyphCache->context, prevGlyph);\n\n\tglyphCache->glyphCache[id].entries[index] = glyph;\n\treturn TRUE;\n}",
        "start_line": 572
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "libfreerdp/cache/glyph.c",
        "method_name": "glyph_cache_put",
        "raw_code": "BOOL glyph_cache_put(rdpGlyphCache* glyphCache, UINT32 id, UINT32 index, rdpGlyph* glyph) /* <=== glyph_cache_put */ \n{\n\trdpGlyph* prevGlyph;\n\n\tif (id > 9)\n\t{\n\t\tWLog_ERR(TAG, \"invalid glyph cache id: %\" PRIu32 \"\", id);\n\t\treturn FALSE;\n\t}\n\n\tif (index >= glyphCache->glyphCache[id].number)\n\t{\n\t\tWLog_ERR(TAG, \"invalid glyph cache index: %\" PRIu32 \" in cache id: %\" PRIu32 \"\", index, id);\n\t\treturn FALSE;\n\t}\n\n\tWLog_Print(glyphCache->log, WLOG_DEBUG, \"GlyphCachePut: id: %\" PRIu32 \" index: %\" PRIu32 \"\", id,\n\t           index);\n\tprevGlyph = glyphCache->glyphCache[id].entries[index];\n\n\tif (prevGlyph)\n\t\tprevGlyph->Free(glyphCache->context, prevGlyph);\n\n\tglyphCache->glyphCache[id].entries[index] = glyph;\n\treturn TRUE;\n}",
        "start_line": 572
      }
    ],
    "code_context": "Type Definitions:\n- rdpGlyphCache: typedef struct rdp_glyph_cache rdpGlyphCache;\n\nImports:\n- #include <freerdp/freerdp.h>\n- #include \"glyph.h\"\n- #include <stdio.h>\n- #include \"config.h\"\n- #include <freerdp/log.h>\n- #include <winpr/crt.h>\n- #include <freerdp/cache/glyph.h>\n- #include <winpr/stream.h>",
    "commit_msg": "Fixed Out-of-bound read in glyph_cache_put\n\nCVE-2020-11098 thanks to @antonio-morales for finding this.",
    "cve_desc": "[{'lang': 'en', 'value': 'In FreeRDP before version 2.1.2, there is an out-of-bound read in glyph_cache_put. This affects all FreeRDP clients with `+glyph-cache` option enabled This is fixed in version 2.1.2.'}]",
    "year": 2020,
    "filename": "glyph.c",
    "commit_url": "\"https://github.com/FreeRDP/FreeRDP/commit/c0fd449ec0870b050d350d6d844b1ea6dad4bc7d\""
  },
  {
    "repository": "FreeRDP/FreeRDP",
    "cve_id": "CVE-2020-11099",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "6ade7b4cbfd71c54b3d724e8f2d6ac76a58e879a",
    "short_hash": "6ade7b4c",
    "vulnerableMethods_before": [
      {
        "filename": "libfreerdp/core/license.c",
        "method_name": "license_read_new_or_upgrade_license_packet",
        "raw_code": "BOOL license_read_new_or_upgrade_license_packet(rdpLicense* license, wStream* s) /* <=== license_read_new_or_upgrade_license_packet */ \n{\n\tUINT32 os_major;\n\tUINT32 os_minor;\n\tUINT32 cbScope, cbCompanyName, cbProductId, cbLicenseInfo;\n\twStream* licenseStream = NULL;\n\tBOOL ret = FALSE;\n\tBYTE computedMac[16];\n\tLICENSE_BLOB* calBlob;\n\n\tDEBUG_LICENSE(\"Receiving Server New/Upgrade License Packet\");\n\n\tcalBlob = license_new_binary_blob(BB_DATA_BLOB);\n\tif (!calBlob)\n\t\treturn FALSE;\n\n\t/* EncryptedLicenseInfo */\n\tif (!license_read_encrypted_blob(license, s, calBlob))\n\t\tgoto out_free_blob;\n\n\t/* compute MAC and check it */\n\tif (Stream_GetRemainingLength(s) < 16)\n\t\tgoto out_free_blob;\n\n\tif (!security_mac_data(license->MacSaltKey, calBlob->data, calBlob->length, computedMac))\n\t\tgoto out_free_blob;\n\n\tif (memcmp(computedMac, Stream_Pointer(s), sizeof(computedMac)) != 0)\n\t{\n\t\tWLog_ERR(TAG, \"new or upgrade license MAC mismatch\");\n\t\tgoto out_free_blob;\n\t}\n\n\tif (!Stream_SafeSeek(s, 16))\n\t\tgoto out_free_blob;\n\n\tlicenseStream = Stream_New(calBlob->data, calBlob->length);\n\tif (!licenseStream)\n\t\tgoto out_free_blob;\n\n\tStream_Read_UINT16(licenseStream, os_minor);\n\tStream_Read_UINT16(licenseStream, os_major);\n\n\t/* Scope */\n\tStream_Read_UINT32(licenseStream, cbScope);\n\tif (Stream_GetRemainingLength(licenseStream) < cbScope)\n\t\tgoto out_free_stream;\n#ifdef WITH_DEBUG_LICENSE\n\tWLog_DBG(TAG, \"Scope:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, Stream_Pointer(licenseStream), cbScope);\n#endif\n\tStream_Seek(licenseStream, cbScope);\n\n\t/* CompanyName */\n\tStream_Read_UINT32(licenseStream, cbCompanyName);\n\tif (Stream_GetRemainingLength(licenseStream) < cbCompanyName)\n\t\tgoto out_free_stream;\n#ifdef WITH_DEBUG_LICENSE\n\tWLog_DBG(TAG, \"Company name:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, Stream_Pointer(licenseStream), cbCompanyName);\n#endif\n\tStream_Seek(licenseStream, cbCompanyName);\n\n\t/* productId */\n\tStream_Read_UINT32(licenseStream, cbProductId);\n\tif (Stream_GetRemainingLength(licenseStream) < cbProductId)\n\t\tgoto out_free_stream;\n#ifdef WITH_DEBUG_LICENSE\n\tWLog_DBG(TAG, \"Product id:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, Stream_Pointer(licenseStream), cbProductId);\n#endif\n\tStream_Seek(licenseStream, cbProductId);\n\n\t/* licenseInfo */\n\tStream_Read_UINT32(licenseStream, cbLicenseInfo);\n\tif (Stream_GetRemainingLength(licenseStream) < cbLicenseInfo)\n\t\tgoto out_free_stream;\n\n\tlicense->state = LICENSE_STATE_COMPLETED;\n\n\tret = TRUE;\n\tif (!license->rdp->settings->OldLicenseBehaviour)\n\t\tret = saveCal(license->rdp->settings, Stream_Pointer(licenseStream), cbLicenseInfo,\n\t\t              license->rdp->settings->ClientHostname);\n\nout_free_stream:\n\tStream_Free(licenseStream, FALSE);\nout_free_blob:\n\tlicense_free_binary_blob(calBlob);\n\treturn ret;\n}",
        "start_line": 1215
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "libfreerdp/core/license.c",
        "method_name": "license_read_new_or_upgrade_license_packet",
        "raw_code": "BOOL license_read_new_or_upgrade_license_packet(rdpLicense* license, wStream* s) /* <=== license_read_new_or_upgrade_license_packet */ \n{\n\tUINT32 os_major;\n\tUINT32 os_minor;\n\tUINT32 cbScope, cbCompanyName, cbProductId, cbLicenseInfo;\n\twStream* licenseStream = NULL;\n\tBOOL ret = FALSE;\n\tBYTE computedMac[16];\n\tLICENSE_BLOB* calBlob;\n\n\tDEBUG_LICENSE(\"Receiving Server New/Upgrade License Packet\");\n\n\tcalBlob = license_new_binary_blob(BB_DATA_BLOB);\n\tif (!calBlob)\n\t\treturn FALSE;\n\n\t/* EncryptedLicenseInfo */\n\tif (!license_read_encrypted_blob(license, s, calBlob))\n\t\tgoto out_free_blob;\n\n\t/* compute MAC and check it */\n\tif (Stream_GetRemainingLength(s) < 16)\n\t\tgoto out_free_blob;\n\n\tif (!security_mac_data(license->MacSaltKey, calBlob->data, calBlob->length, computedMac))\n\t\tgoto out_free_blob;\n\n\tif (memcmp(computedMac, Stream_Pointer(s), sizeof(computedMac)) != 0)\n\t{\n\t\tWLog_ERR(TAG, \"new or upgrade license MAC mismatch\");\n\t\tgoto out_free_blob;\n\t}\n\n\tif (!Stream_SafeSeek(s, 16))\n\t\tgoto out_free_blob;\n\n\tlicenseStream = Stream_New(calBlob->data, calBlob->length);\n\tif (!licenseStream)\n\t\tgoto out_free_blob;\n\n\tif (Stream_GetRemainingLength(licenseStream) < 8)\n\t\tgoto out_free_stream;\n\n\tStream_Read_UINT16(licenseStream, os_minor);\n\tStream_Read_UINT16(licenseStream, os_major);\n\n\t/* Scope */\n\tStream_Read_UINT32(licenseStream, cbScope);\n\tif (Stream_GetRemainingLength(licenseStream) < cbScope)\n\t\tgoto out_free_stream;\n#ifdef WITH_DEBUG_LICENSE\n\tWLog_DBG(TAG, \"Scope:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, Stream_Pointer(licenseStream), cbScope);\n#endif\n\tStream_Seek(licenseStream, cbScope);\n\n\t/* CompanyName */\n\tif (Stream_GetRemainingLength(licenseStream) < 4)\n\t\tgoto out_free_stream;\n\tStream_Read_UINT32(licenseStream, cbCompanyName);\n\tif (Stream_GetRemainingLength(licenseStream) < cbCompanyName)\n\t\tgoto out_free_stream;\n#ifdef WITH_DEBUG_LICENSE\n\tWLog_DBG(TAG, \"Company name:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, Stream_Pointer(licenseStream), cbCompanyName);\n#endif\n\tStream_Seek(licenseStream, cbCompanyName);\n\n\t/* productId */\n\tif (Stream_GetRemainingLength(licenseStream) < 4)\n\t\tgoto out_free_stream;\n\tStream_Read_UINT32(licenseStream, cbProductId);\n\tif (Stream_GetRemainingLength(licenseStream) < cbProductId)\n\t\tgoto out_free_stream;\n#ifdef WITH_DEBUG_LICENSE\n\tWLog_DBG(TAG, \"Product id:\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, Stream_Pointer(licenseStream), cbProductId);\n#endif\n\tStream_Seek(licenseStream, cbProductId);\n\n\t/* licenseInfo */\n\tif (Stream_GetRemainingLength(licenseStream) < 4)\n\t\tgoto out_free_stream;\n\tStream_Read_UINT32(licenseStream, cbLicenseInfo);\n\tif (Stream_GetRemainingLength(licenseStream) < cbLicenseInfo)\n\t\tgoto out_free_stream;\n\n\tlicense->state = LICENSE_STATE_COMPLETED;\n\n\tret = TRUE;\n\tif (!license->rdp->settings->OldLicenseBehaviour)\n\t\tret = saveCal(license->rdp->settings, Stream_Pointer(licenseStream), cbLicenseInfo,\n\t\t              license->rdp->settings->ClientHostname);\n\nout_free_stream:\n\tStream_Free(licenseStream, FALSE);\nout_free_blob:\n\tlicense_free_binary_blob(calBlob);\n\treturn ret;\n}",
        "start_line": 1215
      }
    ],
    "code_context": "Called Methods:\n- winpr_Digest_Update: BOOL winpr_Digest_Update(WINPR_DIGEST_CTX* ctx, const BYTE* input, size_t ilen) /* <=== winpr_Digest_Update */ \n{\n#if defined(WITH_OPENSSL)\n\tEVP_MD_CTX* mdctx = (EVP_MD_CTX*)ctx;\n\n\tif (EVP_DigestUpdate(mdctx, input, ilen) != 1)\n\t\treturn FALSE;\n\n#elif defined(WITH_MBEDTLS)\n\tmbedtls_md_context_t* mdctx = (mbedtls_md_context_t*)ctx;\n\n\tif (mbedtls_md_update(mdctx, input, ilen) != 0)\n\t\treturn FALSE;\n\n#endif\n\treturn TRUE;\n}\n- computeCalHash: static BOOL computeCalHash(const char* hostname, char* hashStr) /* <=== computeCalHash */ \n{\n\tWINPR_DIGEST_CTX* sha1 = NULL;\n\tBOOL ret = FALSE;\n\tBYTE hash[20];\n\tsize_t i;\n\n\tif (!(sha1 = winpr_Digest_New()))\n\t\tgoto out;\n\tif (!winpr_Digest_Init(sha1, WINPR_MD_SHA1))\n\t\tgoto out;\n\tif (!winpr_Digest_Update(sha1, (const BYTE*)hostname, strlen(hostname)))\n\t\tgoto out;\n\tif (!winpr_Digest_Final(sha1, hash, sizeof(hash)))\n\t\tgoto out;\n\n\tfor (i = 0; i < sizeof(hash); i++, hashStr += 2)\n\t\tsprintf_s(hashStr, 3, \"%.2x\", hash[i]);\n\n\tret = TRUE;\nout:\n\twinpr_Digest_Free(sha1);\n\treturn ret;\n}\n- PathFileExistsA: BOOL PathFileExistsA(LPCSTR pszPath) /* <=== PathFileExistsA */ \n{\n\tstruct stat stat_info;\n\n\tif (stat(pszPath, &stat_info) != 0)\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n- PathMakePathA: BOOL PathMakePathA(LPCSTR path, LPSECURITY_ATTRIBUTES lpAttributes) /* <=== PathMakePathA */ \n{\n#if defined(_UWP)\n\treturn FALSE;\n#elif defined(_WIN32)\n\treturn (SHCreateDirectoryExA(NULL, path, lpAttributes) == ERROR_SUCCESS);\n#else\n\tconst char delim = PathGetSeparatorA(PATH_STYLE_NATIVE);\n\tchar* dup;\n\tchar* p;\n\tBOOL result = TRUE;\n\t/* we only operate on a non-null, absolute path */\n#if defined(__OS2__)\n\n\tif (!path)\n\t\treturn FALSE;\n\n#else\n\n\tif (!path || *path != delim)\n\t\treturn FALSE;\n\n#endif\n\n\tif (!(dup = _strdup(path)))\n\t\treturn FALSE;\n\n#ifdef __OS2__\n\tp = (strlen(dup) > 3) && (dup[1] == ':') && (dup[2] == delim)) ? &dup[3] : dup;\n\n\twhile (p)\n#else\n\tfor (p = dup; p;)\n#endif\n\t{\n\t\tif ((p = strchr(p + 1, delim)))\n\t\t\t*p = '\\0';\n\n\t\tif (mkdir(dup, 0777) != 0)\n\t\t\tif (errno != EEXIST)\n\t\t\t{\n\t\t\t\tresult = FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tif (p)\n\t\t\t*p = delim;\n\t}\n\n\tfree(dup);\n\treturn (result);\n#endif\n}\n- winpr_Digest_New: WINPR_DIGEST_CTX* winpr_Digest_New(void) /* <=== winpr_Digest_New */ \n{\n\tWINPR_DIGEST_CTX* ctx = NULL;\n#if defined(WITH_OPENSSL)\n\tEVP_MD_CTX* mdctx;\n#if (OPENSSL_VERSION_NUMBER < 0x10100000L) || defined(LIBRESSL_VERSION_NUMBER)\n\tmdctx = EVP_MD_CTX_create();\n#else\n\tmdctx = EVP_MD_CTX_new();\n#endif\n\tctx = (WINPR_DIGEST_CTX*)mdctx;\n#elif defined(WITH_MBEDTLS)\n\tmbedtls_md_context_t* mdctx;\n\tmdctx = (mbedtls_md_context_t*)calloc(1, sizeof(mbedtls_md_context_t));\n\n\tif (mdctx)\n\t\tmbedtls_md_init(mdctx);\n\n\tctx = (WINPR_DIGEST_CTX*)mdctx;\n#endif\n\treturn ctx;\n}\n- winpr_Digest_Final: BOOL winpr_Digest_Final(WINPR_DIGEST_CTX* ctx, BYTE* output, size_t olen) /* <=== winpr_Digest_Final */ \n{\n#if defined(WITH_OPENSSL)\n\tEVP_MD_CTX* mdctx = (EVP_MD_CTX*)ctx;\n\n\tif (EVP_DigestFinal_ex(mdctx, output, NULL) == 1)\n\t\treturn TRUE;\n\n#elif defined(WITH_MBEDTLS)\n\tmbedtls_md_context_t* mdctx = (mbedtls_md_context_t*)ctx;\n\n\tif (mbedtls_md_finish(mdctx, output) == 0)\n\t\treturn TRUE;\n\n#endif\n\treturn FALSE;\n}\n- security_UINT32_le: static void security_UINT32_le(BYTE* output, UINT32 value) /* <=== security_UINT32_le */ \n{\n\toutput[0] = (value)&0xFF;\n\toutput[1] = (value >> 8) & 0xFF;\n\toutput[2] = (value >> 16) & 0xFF;\n\toutput[3] = (value >> 24) & 0xFF;\n}\n- saveCal: static BOOL saveCal(rdpSettings* settings, const BYTE* data, int length, char* hostname) /* <=== saveCal */ \n{\n\tchar hash[41];\n\tFILE* fp;\n\tchar* licenseStorePath = NULL;\n\tchar filename[MAX_PATH], filenameNew[MAX_PATH];\n\tchar *filepath = NULL, *filepathNew = NULL;\n\tsize_t written;\n\tBOOL ret = FALSE;\n\n\tif (!PathFileExistsA(settings->ConfigPath))\n\t{\n\t\tif (!PathMakePathA(settings->ConfigPath, 0))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"error creating directory '%s'\", settings->ConfigPath);\n\t\t\tgoto out;\n\t\t}\n\t\tWLog_INFO(TAG, \"creating directory %s\", settings->ConfigPath);\n\t}\n\n\tif (!(licenseStorePath = GetCombinedPath(settings->ConfigPath, licenseStore)))\n\t\tgoto out;\n\n\tif (!PathFileExistsA(licenseStorePath))\n\t{\n\t\tif (!PathMakePathA(licenseStorePath, 0))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"error creating directory '%s'\", licenseStorePath);\n\t\t\tgoto out;\n\t\t}\n\t\tWLog_INFO(TAG, \"creating directory %s\", licenseStorePath);\n\t}\n\n\tif (!computeCalHash(hostname, hash))\n\t\tgoto out;\n\tsprintf_s(filename, sizeof(filename) - 1, \"%s.cal\", hash);\n\tsprintf_s(filenameNew, sizeof(filenameNew) - 1, \"%s.cal.new\", hash);\n\n\tif (!(filepath = GetCombinedPath(licenseStorePath, filename)))\n\t\tgoto out;\n\n\tif (!(filepathNew = GetCombinedPath(licenseStorePath, filenameNew)))\n\t\tgoto out;\n\n\tfp = fopen(filepathNew, \"wb\");\n\tif (!fp)\n\t\tgoto out;\n\n\twritten = fwrite(data, length, 1, fp);\n\tfclose(fp);\n\n\tif (written != 1)\n\t{\n\t\tDeleteFile(filepathNew);\n\t\tgoto out;\n\t}\n\n\tret = MoveFileEx(filepathNew, filepath, MOVEFILE_REPLACE_EXISTING);\n\nout:\n\tfree(filepathNew);\n\tfree(filepath);\n\tfree(licenseStorePath);\n\treturn ret;\n}\n- GetCombinedPath: char* GetCombinedPath(const char* basePath, const char* subPath) /* <=== GetCombinedPath */ \n{\n\tint length;\n\tHRESULT status;\n\tchar* path = NULL;\n\tchar* subPathCpy;\n\tint basePathLength = 0;\n\tint subPathLength = 0;\n\n\tif (basePath)\n\t\tbasePathLength = (int)strlen(basePath);\n\n\tif (subPath)\n\t\tsubPathLength = (int)strlen(subPath);\n\n\tlength = basePathLength + subPathLength + 1;\n\tpath = (char*)malloc(length + 1);\n\n\tif (!path)\n\t\treturn NULL;\n\n\tif (basePath)\n\t\tCopyMemory(path, basePath, basePathLength);\n\n\tpath[basePathLength] = '\\0';\n\n\tif (FAILED(PathCchConvertStyleA(path, basePathLength, PATH_STYLE_NATIVE)))\n\t{\n\t\tfree(path);\n\t\treturn NULL;\n\t}\n\n\tif (!subPath)\n\t\treturn path;\n\n\tsubPathCpy = _strdup(subPath);\n\n\tif (!subPathCpy)\n\t{\n\t\tfree(path);\n\t\treturn NULL;\n\t}\n\n\tif (FAILED(PathCchConvertStyleA(subPathCpy, subPathLength, PATH_STYLE_NATIVE)))\n\t{\n\t\tfree(path);\n\t\tfree(subPathCpy);\n\t\treturn NULL;\n\t}\n\n\tstatus = NativePathCchAppendA(path, length + 1, subPathCpy);\n\tfree(subPathCpy);\n\n\tif (FAILED(status))\n\t{\n\t\tfree(path);\n\t\treturn NULL;\n\t}\n\telse\n\t\treturn path;\n}\n- security_mac_data: BOOL security_mac_data(const BYTE* mac_salt_key, const BYTE* data, UINT32 length, BYTE* output) /* <=== security_mac_data */ \n{\n\tWINPR_DIGEST_CTX* sha1 = NULL;\n\tWINPR_DIGEST_CTX* md5 = NULL;\n\tBYTE length_le[4];\n\tBYTE sha1_digest[WINPR_SHA1_DIGEST_LENGTH];\n\tBOOL result = FALSE;\n\t/* MacData = MD5(MacSaltKey + pad2 + SHA1(MacSaltKey + pad1 + length + data)) */\n\tsecurity_UINT32_le(length_le, length); /* length must be little-endian */\n\n\t/* SHA1_Digest = SHA1(MacSaltKey + pad1 + length + data) */\n\tif (!(sha1 = winpr_Digest_New()))\n\t\tgoto out;\n\n\tif (!winpr_Digest_Init(sha1, WINPR_MD_SHA1))\n\t\tgoto out;\n\n\tif (!winpr_Digest_Update(sha1, mac_salt_key, 16)) /* MacSaltKey */\n\t\tgoto out;\n\n\tif (!winpr_Digest_Update(sha1, pad1, sizeof(pad1))) /* pad1 */\n\t\tgoto out;\n\n\tif (!winpr_Digest_Update(sha1, length_le, sizeof(length_le))) /* length */\n\t\tgoto out;\n\n\tif (!winpr_Digest_Update(sha1, data, length)) /* data */\n\t\tgoto out;\n\n\tif (!winpr_Digest_Final(sha1, sha1_digest, sizeof(sha1_digest)))\n\t\tgoto out;\n\n\t/* MacData = MD5(MacSaltKey + pad2 + SHA1_Digest) */\n\tif (!(md5 = winpr_Digest_New()))\n\t\tgoto out;\n\n\t/* Allow FIPS override for use of MD5 here, this is only used for creating the MACData field of\n\t * the */\n\t/* Client Platform Challenge Response packet (from MS-RDPELE section 2.2.2.5). This is for RDP\n\t * licensing packets */\n\t/* which will already be encrypted under FIPS, so the use of MD5 here is not for sensitive data\n\t * protection. */\n\tif (!winpr_Digest_Init_Allow_FIPS(md5, WINPR_MD_MD5))\n\t\tgoto out;\n\n\tif (!winpr_Digest_Update(md5, mac_salt_key, 16)) /* MacSaltKey */\n\t\tgoto out;\n\n\tif (!winpr_Digest_Update(md5, pad2, sizeof(pad2))) /* pad2 */\n\t\tgoto out;\n\n\tif (!winpr_Digest_Update(md5, sha1_digest, sizeof(sha1_digest))) /* SHA1_Digest */\n\t\tgoto out;\n\n\tif (!winpr_Digest_Final(md5, output, WINPR_MD5_DIGEST_LENGTH))\n\t\tgoto out;\n\n\tresult = TRUE;\nout:\n\twinpr_Digest_Free(sha1);\n\twinpr_Digest_Free(md5);\n\treturn result;\n}\n- Stream_Free: void Stream_Free(wStream* s, BOOL bFreeBuffer) /* <=== Stream_Free */ \n{\n\tif (s)\n\t{\n\t\tif (bFreeBuffer && s->isOwner)\n\t\t\tfree(s->buffer);\n\n\t\tif (s->isAllocatedStream)\n\t\t\tfree(s);\n\t}\n}\n- Stream_New: wStream* Stream_New(BYTE* buffer, size_t size) /* <=== Stream_New */ \n{\n\twStream* s;\n\n\tif (!buffer && !size)\n\t\treturn NULL;\n\n\ts = malloc(sizeof(wStream));\n\tif (!s)\n\t\treturn NULL;\n\n\tif (buffer)\n\t\ts->buffer = buffer;\n\telse\n\t\ts->buffer = (BYTE*)malloc(size);\n\n\tif (!s->buffer)\n\t{\n\t\tfree(s);\n\t\treturn NULL;\n\t}\n\n\ts->pointer = s->buffer;\n\ts->capacity = size;\n\ts->length = size;\n\n\ts->pool = NULL;\n\ts->count = 0;\n\ts->isAllocatedStream = TRUE;\n\ts->isOwner = TRUE;\n\treturn s;\n}\n- TAG: #define TAG FREERDP_TAG(\"core.license\") /* <=== libfreerdp/core/license.c:38:38:TAG:0 */ \n- license_new_binary_blob: LICENSE_BLOB* license_new_binary_blob(UINT16 type) /* <=== license_new_binary_blob */ \n{\n\tLICENSE_BLOB* blob;\n\tblob = (LICENSE_BLOB*)calloc(1, sizeof(LICENSE_BLOB));\n\tif (blob)\n\t\tblob->type = type;\n\treturn blob;\n}\n- license_read_encrypted_blob: static BOOL license_read_encrypted_blob(const rdpLicense* license, wStream* s, LICENSE_BLOB* target) /* <=== license_read_encrypted_blob */ \n{\n\tUINT16 wBlobType, wBlobLen;\n\tBYTE* encryptedData;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, wBlobType);\n\tif (wBlobType != BB_ENCRYPTED_DATA_BLOB)\n\t{\n\t\tWLog_DBG(\n\t\t    TAG,\n\t\t    \"expecting BB_ENCRYPTED_DATA_BLOB blob, probably a windows 2003 server, continuing...\");\n\t}\n\n\tStream_Read_UINT16(s, wBlobLen);\n\n\tif (Stream_GetRemainingLength(s) < wBlobLen)\n\t\treturn FALSE;\n\n\tencryptedData = Stream_Pointer(s);\n\tStream_Seek(s, wBlobLen);\n\treturn license_rc4_with_licenseKey(license, encryptedData, wBlobLen, target);\n}\n- license_rc4_with_licenseKey: static BOOL license_rc4_with_licenseKey(const rdpLicense* license, const BYTE* input, size_t len, /* <=== license_rc4_with_licenseKey */ \n                                        LICENSE_BLOB* target)\n{\n\tWINPR_RC4_CTX* rc4;\n\tBYTE* buffer = NULL;\n\n\trc4 =\n\t    winpr_RC4_New_Allow_FIPS(license->LicensingEncryptionKey, LICENSING_ENCRYPTION_KEY_LENGTH);\n\tif (!rc4)\n\t\treturn FALSE;\n\n\tbuffer = (BYTE*)realloc(target->data, len);\n\tif (!buffer)\n\t\tgoto error_buffer;\n\n\ttarget->data = buffer;\n\ttarget->length = len;\n\n\tif (!winpr_RC4_Update(rc4, len, input, buffer))\n\t\tgoto error_buffer;\n\n\twinpr_RC4_Free(rc4);\n\treturn TRUE;\n\nerror_buffer:\n\twinpr_RC4_Free(rc4);\n\treturn FALSE;\n}\n- winpr_Digest_Init: BOOL winpr_Digest_Init(WINPR_DIGEST_CTX* ctx, WINPR_MD_TYPE md) /* <=== winpr_Digest_Init */ \n{\n#if defined(WITH_OPENSSL)\n\tconst EVP_MD* evp = winpr_openssl_get_evp_md(md);\n\treturn winpr_Digest_Init_Internal(ctx, evp);\n#else\n\treturn winpr_Digest_Init_Internal(ctx, md);\n#endif\n}\n- winpr_Digest_Init_Allow_FIPS: BOOL winpr_Digest_Init_Allow_FIPS(WINPR_DIGEST_CTX* ctx, WINPR_MD_TYPE md) /* <=== winpr_Digest_Init_Allow_FIPS */ \n{\n#if defined(WITH_OPENSSL)\n\tEVP_MD_CTX* mdctx = (EVP_MD_CTX*)ctx;\n\tconst EVP_MD* evp = winpr_openssl_get_evp_md(md);\n\n\t/* Only MD5 is supported for FIPS allow override */\n\tif (md != WINPR_MD_MD5)\n\t\treturn FALSE;\n\n\tEVP_MD_CTX_set_flags(mdctx, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);\n\treturn winpr_Digest_Init_Internal(ctx, evp);\n#elif defined(WITH_MBEDTLS)\n\n\t/* Only MD5 is supported for FIPS allow override */\n\tif (md != WINPR_MD_MD5)\n\t\treturn FALSE;\n\n\treturn winpr_Digest_Init_Internal(ctx, md);\n#endif\n}\n- winpr_Digest_Free: void winpr_Digest_Free(WINPR_DIGEST_CTX* ctx) /* <=== winpr_Digest_Free */ \n{\n#if defined(WITH_OPENSSL)\n\tEVP_MD_CTX* mdctx = (EVP_MD_CTX*)ctx;\n\n\tif (mdctx)\n\t{\n#if (OPENSSL_VERSION_NUMBER < 0x10100000L) || defined(LIBRESSL_VERSION_NUMBER)\n\t\tEVP_MD_CTX_destroy(mdctx);\n#else\n\t\tEVP_MD_CTX_free(mdctx);\n#endif\n\t}\n\n#elif defined(WITH_MBEDTLS)\n\tmbedtls_md_context_t* mdctx = (mbedtls_md_context_t*)ctx;\n\n\tif (mdctx)\n\t{\n\t\tmbedtls_md_free(mdctx);\n\t\tfree(mdctx);\n\t}\n\n#endif\n}\n\nType Definitions:\n- rdpLicense: typedef struct rdp_license rdpLicense;\n- wStream: typedef struct _wStream wStream;\n- LICENSE_BLOB: typedef struct\n{\n\tUINT16 type;\n\tUINT16 length;\n\tBYTE* data;\n}\n\nImports:\n- #include \"certificate.h\"\n- #include <winpr/crt.h>\n- #include \"redirection.h\"\n- #include <winpr/crypto.h>\n- #include <winpr/shell.h>\n- #include <freerdp/log.h>\n- #include \"license.h\"\n- #include <winpr/path.h>\n- #include \"config.h\"",
    "commit_msg": "Fixed OOB Read in license_read_new_or_upgrade_license_packet\n\nCVE-2020-11099 thanks to @antonio-morales for finding this.",
    "cve_desc": "[{'lang': 'en', 'value': 'In FreeRDP before version 2.1.2, there is an out of bounds read in license_read_new_or_upgrade_license_packet. A manipulated license packet can lead to out of bound reads to an internal buffer. This is fixed in version 2.1.2.'}]",
    "year": 2020,
    "filename": "license.c",
    "commit_url": "\"https://github.com/FreeRDP/FreeRDP/commit/6ade7b4cbfd71c54b3d724e8f2d6ac76a58e879a\""
  },
  {
    "repository": "haproxy/haproxy",
    "cve_id": "CVE-2020-11100",
    "cwe_list": [
      "CWE-787"
    ],
    "commit_hash": "5dfc5d5cd0d2128d77253ead3acf03a421ab5b88",
    "short_hash": "5dfc5d5c",
    "vulnerableMethods_before": [
      {
        "filename": "src/hpack-tbl.c",
        "method_name": "hpack_dht_insert",
        "raw_code": "int hpack_dht_insert(struct hpack_dht *dht, struct ist name, struct ist value) /* <=== hpack_dht_insert */ \n{\n\tunsigned int used;\n\tunsigned int head;\n\tunsigned int prev;\n\tunsigned int wrap;\n\tunsigned int tail;\n\tuint32_t headroom, tailroom;\n\n\tif (!hpack_dht_make_room(dht, name.len + value.len))\n\t\treturn 0;\n\n\t/* Now there is enough room in the table, that's guaranteed by the\n\t * protocol, but not necessarily where we need it.\n\t */\n\n\tused = dht->used;\n\tif (!used) {\n\t\t/* easy, the table was empty */\n\t\tdht->front = dht->head = 0;\n\t\tdht->wrap  = dht->used = 1;\n\t\tdht->total = 0;\n\t\thead = 0;\n\t\tdht->dte[head].addr = dht->size - (name.len + value.len);\n\t\tgoto copy;\n\t}\n\n\t/* compute the new head, used and wrap position */\n\tprev = head = dht->head;\n\twrap = dht->wrap;\n\ttail = hpack_dht_get_tail(dht);\n\n\tused++;\n\thead++;\n\n\tif (head >= wrap) {\n\t\t/* head is leading the entries, we either need to push the\n\t\t * table further or to loop back to released entries. We could\n\t\t * force to loop back when at least half of the allocatable\n\t\t * entries are free but in practice it never happens.\n\t\t */\n\t\tif ((sizeof(*dht) + (wrap + 1) * sizeof(dht->dte[0]) <= dht->dte[dht->front].addr))\n\t\t\twrap++;\n\t\telse if (head >= used) /* there's a hole at the beginning */\n\t\t\thead = 0;\n\t\telse {\n\t\t\t/* no more room, head hits tail and the index cannot be\n\t\t\t * extended, we have to realign the whole table.\n\t\t\t */\n\t\t\tif (!hpack_dht_defrag(dht))\n\t\t\t\treturn -1;\n\n\t\t\twrap = dht->wrap + 1;\n\t\t\thead = dht->head + 1;\n\t\t\tprev = head - 1;\n\t\t\ttail = 0;\n\t\t}\n\t}\n\telse if (used >= wrap) {\n\t\t/* we've hit the tail, we need to reorganize the index so that\n\t\t * the head is at the end (but not necessarily move the data).\n\t\t */\n\t\tif (!hpack_dht_defrag(dht))\n\t\t\treturn -1;\n\n\t\twrap = dht->wrap + 1;\n\t\thead = dht->head + 1;\n\t\tprev = head - 1;\n\t\ttail = 0;\n\t}\n\n\t/* Now we have updated head, used and wrap, we know that there is some\n\t * available room at least from the protocol's perspective. This space\n\t * is split in two areas :\n\t *\n\t *   1: if the previous head was the front cell, the space between the\n\t *      end of the index table and the front cell's address.\n\t *   2: if the previous head was the front cell, the space between the\n\t *      end of the tail and the end of the table ; or if the previous\n\t *      head was not the front cell, the space between the end of the\n\t *      tail and the head's address.\n\t */\n\tif (prev == dht->front) {\n\t\t/* the area was contiguous */\n\t\theadroom = dht->dte[dht->front].addr - (sizeof(*dht) + wrap * sizeof(dht->dte[0]));\n\t\ttailroom = dht->size - dht->dte[tail].addr - dht->dte[tail].nlen - dht->dte[tail].vlen;\n\t}\n\telse {\n\t\t/* it's already wrapped so we can't store anything in the headroom */\n\t\theadroom = 0;\n\t\ttailroom = dht->dte[prev].addr - dht->dte[tail].addr - dht->dte[tail].nlen - dht->dte[tail].vlen;\n\t}\n\n\t/* We can decide to stop filling the headroom as soon as there's enough\n\t * room left in the tail to suit the protocol, but tests show that in\n\t * practice it almost never happens in other situations so the extra\n\t * test is useless and we simply fill the headroom as long as it's\n\t * available.\n\t */\n\tif (headroom >= name.len + value.len) {\n\t\t/* install upfront and update ->front */\n\t\tdht->dte[head].addr = dht->dte[dht->front].addr - (name.len + value.len);\n\t\tdht->front = head;\n\t}\n\telse if (tailroom >= name.len + value.len) {\n\t\tdht->dte[head].addr = dht->dte[tail].addr + dht->dte[tail].nlen + dht->dte[tail].vlen + tailroom - (name.len + value.len);\n\t}\n\telse {\n\t\t/* need to defragment the table before inserting upfront */\n\t\tdht = hpack_dht_defrag(dht);\n\t\twrap = dht->wrap + 1;\n\t\thead = dht->head + 1;\n\t\tdht->dte[head].addr = dht->dte[dht->front].addr - (name.len + value.len);\n\t\tdht->front = head;\n\t}\n\n\tdht->wrap = wrap;\n\tdht->head = head;\n\tdht->used = used;\n\n copy:\n\tdht->total         += name.len + value.len;\n\tdht->dte[head].nlen = name.len;\n\tdht->dte[head].vlen = value.len;\n\n\tmemcpy((void *)dht + dht->dte[head].addr, name.ptr, name.len);\n\tmemcpy((void *)dht + dht->dte[head].addr + name.len, value.ptr, value.len);\n\treturn 0;\n}",
        "start_line": 252
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "src/hpack-tbl.c",
        "method_name": "hpack_dht_insert",
        "raw_code": "int hpack_dht_insert(struct hpack_dht *dht, struct ist name, struct ist value) /* <=== hpack_dht_insert */ \n{\n\tunsigned int used;\n\tunsigned int head;\n\tunsigned int prev;\n\tunsigned int wrap;\n\tunsigned int tail;\n\tuint32_t headroom, tailroom;\n\n\tif (!hpack_dht_make_room(dht, name.len + value.len))\n\t\treturn 0;\n\n\t/* Now there is enough room in the table, that's guaranteed by the\n\t * protocol, but not necessarily where we need it.\n\t */\n\n\tused = dht->used;\n\tif (!used) {\n\t\t/* easy, the table was empty */\n\t\tdht->front = dht->head = 0;\n\t\tdht->wrap  = dht->used = 1;\n\t\tdht->total = 0;\n\t\thead = 0;\n\t\tdht->dte[head].addr = dht->size - (name.len + value.len);\n\t\tgoto copy;\n\t}\n\n\t/* compute the new head, used and wrap position */\n\tprev = head = dht->head;\n\twrap = dht->wrap;\n\ttail = hpack_dht_get_tail(dht);\n\n\tused++;\n\thead++;\n\n\tif (head >= wrap) {\n\t\t/* head is leading the entries, we either need to push the\n\t\t * table further or to loop back to released entries. We could\n\t\t * force to loop back when at least half of the allocatable\n\t\t * entries are free but in practice it never happens.\n\t\t */\n\t\tif ((sizeof(*dht) + (wrap + 1) * sizeof(dht->dte[0]) <= dht->dte[dht->front].addr))\n\t\t\twrap++;\n\t\telse if (head >= used) /* there's a hole at the beginning */\n\t\t\thead = 0;\n\t\telse {\n\t\t\t/* no more room, head hits tail and the index cannot be\n\t\t\t * extended, we have to realign the whole table.\n\t\t\t */\n\t\t\tif (!hpack_dht_defrag(dht))\n\t\t\t\treturn -1;\n\n\t\t\twrap = dht->wrap + 1;\n\t\t\thead = dht->head + 1;\n\t\t\tprev = head - 1;\n\t\t\ttail = 0;\n\t\t}\n\t}\n\telse if (used >= wrap) {\n\t\t/* we've hit the tail, we need to reorganize the index so that\n\t\t * the head is at the end (but not necessarily move the data).\n\t\t */\n\t\tif (!hpack_dht_defrag(dht))\n\t\t\treturn -1;\n\n\t\twrap = dht->wrap + 1;\n\t\thead = dht->head + 1;\n\t\tprev = head - 1;\n\t\ttail = 0;\n\t}\n\n\t/* Now we have updated head, used and wrap, we know that there is some\n\t * available room at least from the protocol's perspective. This space\n\t * is split in two areas :\n\t *\n\t *   1: if the previous head was the front cell, the space between the\n\t *      end of the index table and the front cell's address.\n\t *   2: if the previous head was the front cell, the space between the\n\t *      end of the tail and the end of the table ; or if the previous\n\t *      head was not the front cell, the space between the end of the\n\t *      tail and the head's address.\n\t */\n\tif (prev == dht->front) {\n\t\t/* the area was contiguous */\n\t\theadroom = dht->dte[dht->front].addr - (sizeof(*dht) + wrap * sizeof(dht->dte[0]));\n\t\ttailroom = dht->size - dht->dte[tail].addr - dht->dte[tail].nlen - dht->dte[tail].vlen;\n\t}\n\telse {\n\t\t/* it's already wrapped so we can't store anything in the headroom */\n\t\theadroom = 0;\n\t\ttailroom = dht->dte[prev].addr - dht->dte[tail].addr - dht->dte[tail].nlen - dht->dte[tail].vlen;\n\t}\n\n\t/* We can decide to stop filling the headroom as soon as there's enough\n\t * room left in the tail to suit the protocol, but tests show that in\n\t * practice it almost never happens in other situations so the extra\n\t * test is useless and we simply fill the headroom as long as it's\n\t * available and we don't wrap.\n\t */\n\tif (prev == dht->front && headroom >= name.len + value.len) {\n\t\t/* install upfront and update ->front */\n\t\tdht->dte[head].addr = dht->dte[dht->front].addr - (name.len + value.len);\n\t\tdht->front = head;\n\t}\n\telse if (tailroom >= name.len + value.len) {\n\t\tdht->dte[head].addr = dht->dte[tail].addr + dht->dte[tail].nlen + dht->dte[tail].vlen + tailroom - (name.len + value.len);\n\t}\n\telse {\n\t\t/* need to defragment the table before inserting upfront */\n\t\tdht = hpack_dht_defrag(dht);\n\t\twrap = dht->wrap + 1;\n\t\thead = dht->head + 1;\n\t\tdht->dte[head].addr = dht->dte[dht->front].addr - (name.len + value.len);\n\t\tdht->front = head;\n\t}\n\n\tdht->wrap = wrap;\n\tdht->head = head;\n\tdht->used = used;\n\n copy:\n\tdht->total         += name.len + value.len;\n\tdht->dte[head].nlen = name.len;\n\tdht->dte[head].vlen = value.len;\n\n\tmemcpy((void *)dht + dht->dte[head].addr, name.ptr, name.len);\n\tmemcpy((void *)dht + dht->dte[head].addr + name.len, value.ptr, value.len);\n\treturn 0;\n}",
        "start_line": 252
      }
    ],
    "code_context": "Called Methods:\n- __hpack_dht_make_room: int __hpack_dht_make_room(struct hpack_dht *dht, unsigned int needed) /* <=== __hpack_dht_make_room */ \n{\n\tunsigned int used = dht->used;\n\tunsigned int wrap = dht->wrap;\n\tunsigned int tail;\n\n\tdo {\n\t\ttail = ((dht->head + 1U < used) ? wrap : 0) + dht->head + 1U - used;\n\t\tdht->total -= dht->dte[tail].nlen + dht->dte[tail].vlen;\n\t\tif (tail == dht->front)\n\t\t\tdht->front = dht->head;\n\t\tused--;\n\t} while (used && used * 32 + dht->total + needed + 32 > dht->size);\n\n\tdht->used = used;\n\n\t/* realign if empty */\n\tif (!used)\n\t\tdht->front = dht->head = 0;\n\n\t/* pack the table if it doesn't wrap anymore */\n\tif (dht->head + 1U >= used)\n\t\tdht->wrap = dht->head + 1;\n\n\t/* no need to check for 'used' here as if it doesn't fit, used==0 */\n\treturn needed + 32 <= dht->size;\n}\n- hpack_dht_get_tail: static inline unsigned int hpack_dht_get_tail(const struct hpack_dht *dht) /* <=== hpack_dht_get_tail */ \n{\n\treturn ((dht->head + 1U < dht->used) ? dht->wrap : 0) + dht->head + 1U - dht->used;\n}\n- hpack_dht_alloc: static inline struct hpack_dht *hpack_dht_alloc(uint32_t size) /* <=== hpack_dht_alloc */ \n{\n\tstruct hpack_dht *dht;\n\n\tdht = malloc(size);\n\tif (!dht)\n\t\treturn dht;\n\n\thpack_dht_init(dht, size);\n\treturn dht;\n}\n- hpack_dht_make_room: static inline int hpack_dht_make_room(struct hpack_dht *dht, unsigned int needed) /* <=== hpack_dht_make_room */ \n{\n\tif (dht->used * 32 + dht->total + needed + 32 <= dht->size)\n\t\treturn 1;\n\telse if (!dht->used)\n\t\treturn 0;\n\n\treturn __hpack_dht_make_room(dht, needed);\n}\n- hpack_dht_defrag: static struct hpack_dht *hpack_dht_defrag(struct hpack_dht *dht) /* <=== hpack_dht_defrag */ \n{\n\tstruct hpack_dht *alt_dht;\n\tuint16_t old, new;\n\tuint32_t addr;\n\n\t/* Note: for small tables we could use alloca() instead but\n\t * portability especially for large tables can be problematic.\n\t */\n\talt_dht = hpack_dht_alloc(dht->size);\n\tif (!alt_dht)\n\t\treturn NULL;\n\n\talt_dht->total = dht->total;\n\talt_dht->used = dht->used;\n\talt_dht->wrap = dht->used;\n\n\tnew = 0;\n\taddr = alt_dht->size;\n\n\tif (dht->used) {\n\t\t/* start from the tail */\n\t\told = hpack_dht_get_tail(dht);\n\t\tdo {\n\t\t\talt_dht->dte[new].nlen = dht->dte[old].nlen;\n\t\t\talt_dht->dte[new].vlen = dht->dte[old].vlen;\n\t\t\taddr -= dht->dte[old].nlen + dht->dte[old].vlen;\n\t\t\talt_dht->dte[new].addr = addr;\n\n\t\t\tmemcpy((void *)alt_dht + alt_dht->dte[new].addr,\n\t\t\t       (void *)dht + dht->dte[old].addr,\n\t\t\t       dht->dte[old].nlen + dht->dte[old].vlen);\n\n\t\t\told++;\n\t\t\tif (old >= dht->wrap)\n\t\t\t\told = 0;\n\t\t\tnew++;\n\t\t} while (new < dht->used);\n\t}\n\n\talt_dht->front = alt_dht->head = new - 1;\n\n\tmemcpy(dht, alt_dht, dht->size);\n\thpack_dht_free(alt_dht);\n\n\treturn dht;\n}\n- hpack_dht_get_tail: static inline unsigned int hpack_dht_get_tail(const struct hpack_dht *dht) /* <=== hpack_dht_get_tail */ \n{\n\treturn ((dht->head + 1U < dht->used) ? dht->wrap : 0) + dht->head + 1U - dht->used;\n}\n- hpack_dht_free: static inline void hpack_dht_free(struct hpack_dht *dht) /* <=== hpack_dht_free */ \n{\n\tfree(dht);\n}\n\nType Definitions:\n- ist: struct ist\n- ist: struct ist {\n\tchar  *ptr;\n\tsize_t len;\n}\n- hpack_dht: struct hpack_dht {\n\tuint32_t size;  /* allocated table size in bytes */\n\tuint32_t total; /* sum of nlen + vlen in bytes */\n\tuint16_t front; /* slot number of the first node after the idx table */\n\tuint16_t wrap;  /* number of allocated slots, wraps here */\n\tuint16_t head;  /* last inserted slot number */\n\tuint16_t used;  /* number of slots in use */\n\tstruct hpack_dte dte[0]; /* dynamic table entries */\n}\n\nImports:\n- #include <string.h>\n- #include <common/ist.h>\n- #include <common/hpack-tbl.h>\n- #include <inttypes.h>\n- #include <stdio.h>\n- #include <common/hpack-huff.h>\n- #include <types/global.h>\n- #include <stdlib.h>",
    "commit_msg": "BUG/CRITICAL: hpack: never index a header into the headroom after wrapping\n\nThe HPACK header table is implemented as a wrapping list inside a contigous\narea. Headers names and values are stored from right to left while indexes\nare stored from left to right. When there's no more room to store a new one,\nwe wrap to the right again, or possibly defragment it if needed. The condition\ndo use the right part (called tailroom) or the left part (called headroom)\ndepends on the location of the last inserted header. After wrapping happens,\nthe code forces to stick to tailroom by pretending there's no more headroom,\nso that the size fit test always fails. The problem is that nothing prevents\nfrom storing a header with an empty name and empty value, resulting in a\ntotal size of zero bytes, which satisfies the condition to use the headroom.\nDoing this in a wrapped buffer results in changing the \"front\" header index\nand causing miscalculations on the available size and the addresses of the\nnext headers. This may even allow to overwrite some parts of the index,\nopening the possibility to perform arbitrary writes into a 32-bit relative\naddress space.\n\nThis patch fixes the issue by making sure the headroom is considered only\nwhen the buffer does not wrap, instead of relying on the zero size. This\nmust be backported to all versions supporting H2, which is as far as 1.8.\n\nMany thanks to Felix Wilhelm of Google Project Zero for responsibly\nreporting this problem with a reproducer and a detailed analysis.\nCVE-2020-11100 was assigned to this issue.",
    "cve_desc": "In hpack_dht_insert in hpack-tbl.c in the HPACK decoder in HAProxy 1.8 through 2.x before 2.1.4, a remote attacker can write arbitrary bytes around a certain location on the heap via a crafted HTTP/2 request, possibly causing remote code execution.",
    "year": 2020,
    "filename": "hpack-tbl.c",
    "commit_url": "\"https://github.com/haproxy/haproxy/commit/5dfc5d5cd0d2128d77253ead3acf03a421ab5b88\""
  },
  {
    "repository": "FreeRDP/FreeRDP",
    "cve_id": "CVE-2020-11523",
    "cwe_list": [
      "CWE-190"
    ],
    "commit_hash": "ce21b9d7ecd967e0bc98ed31a6b3757848aa6c9e",
    "short_hash": "ce21b9d7",
    "vulnerableMethods_before": [
      {
        "filename": "libfreerdp/gdi/region.c",
        "method_name": "gdi_RectToCRgn",
        "raw_code": "INLINE void gdi_RectToCRgn(const HGDI_RECT rect, INT32* x, INT32* y, INT32* w, INT32* h) /* <=== gdi_RectToCRgn */ \n{\n\t*x = rect->left;\n\t*y = rect->top;\n\t*w = rect->right - rect->left + 1;\n\t*h = rect->bottom - rect->top + 1;\n}",
        "start_line": 130
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "libfreerdp/gdi/region.c",
        "method_name": "gdi_RectToCRgn",
        "raw_code": "INLINE void gdi_RectToCRgn(const HGDI_RECT rect, INT32* x, INT32* y, INT32* w, INT32* h) /* <=== gdi_RectToCRgn */ \n{\n\tINT64 tmp;\n\t*x = rect->left;\n\t*y = rect->top;\n\ttmp = rect->right - rect->left + 1;\n\tif ((tmp < 0) || (tmp > INT32_MAX))\n\t{\n\t\tchar buffer[256];\n\t\tWLog_ERR(TAG, \"[%s] rectangle invalid %s\", __FUNCTION__,\n\t\t         gdi_rect_str(buffer, sizeof(buffer), rect));\n\t\t*w = 0;\n\t}\n\telse\n\t\t*w = tmp;\n\ttmp = rect->bottom - rect->top + 1;\n\tif ((tmp < 0) || (tmp > INT32_MAX))\n\t{\n\t\tchar buffer[256];\n\t\tWLog_ERR(TAG, \"[%s] rectangle invalid %s\", __FUNCTION__,\n\t\t         gdi_rect_str(buffer, sizeof(buffer), rect));\n\t\t*h = 0;\n\t}\n\telse\n\t\t*h = tmp;\n}",
        "start_line": 141
      }
    ],
    "code_context": "Called Methods:\n- TAG: #define TAG FREERDP_TAG(\"gdi.region\") /* <=== libfreerdp/gdi/region.c:38:38:TAG:0 */ \n- gdi_rect_str: static char* gdi_rect_str(char* buffer, size_t size, const HGDI_RECT rect) /* <=== gdi_rect_str */ \n{\n\t_snprintf(buffer, size - 1,\n\t          \"[top/left=%\" PRId32 \"x%\" PRId32 \"-bottom/right%\" PRId32 \"x%\" PRId32 \"]\", rect->top,\n\t          rect->left, rect->bottom, rect->right);\n\tif (size > 1)\n\t\tbuffer[size - 1] = '\\0'\n\n\t\t    return buffer;\n}\n\nType Definitions:\n- HGDI_RECT: typedef GDI_RECT* HGDI_RECT;\n\nImports:\n- #include <freerdp/freerdp.h>\n- #include <stdio.h>\n- #include <freerdp/api.h>\n- #include <freerdp/gdi/gdi.h>\n- #include <stdlib.h>\n- #include <freerdp/log.h>\n- #include \"config.h\"\n- #include <freerdp/gdi/region.h>\n- #include <string.h>",
    "commit_msg": "Fix CVE-2020-11523: clamp invalid rectangles to size 0\n\nThanks to Sunglin and HuanGMz from Knownsec 404",
    "cve_desc": "libfreerdp/gdi/region.c in FreeRDP versions > 1.0 through 2.0.0-rc4 has an Integer Overflow.",
    "year": 2020,
    "filename": "region.c",
    "commit_url": "\"https://github.com/FreeRDP/FreeRDP/commit/ce21b9d7ecd967e0bc98ed31a6b3757848aa6c9e\""
  },
  {
    "repository": "FreeRDP/FreeRDP",
    "cve_id": "CVE-2020-11525",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "58dc36b3c883fd460199cedb6d30e58eba58298c",
    "short_hash": "58dc36b3",
    "vulnerableMethods_before": [
      {
        "filename": "libfreerdp/cache/bitmap.c",
        "method_name": "bitmap_cache_new",
        "raw_code": "rdpBitmapCache* bitmap_cache_new(rdpSettings* settings) /* <=== bitmap_cache_new */ \n{\n\tint i;\n\trdpBitmapCache* bitmapCache;\n\tbitmapCache = (rdpBitmapCache*)calloc(1, sizeof(rdpBitmapCache));\n\n\tif (!bitmapCache)\n\t\treturn NULL;\n\n\tbitmapCache->settings = settings;\n\tbitmapCache->update = ((freerdp*)settings->instance)->update;\n\tbitmapCache->context = bitmapCache->update->context;\n\tbitmapCache->maxCells = settings->BitmapCacheV2NumCells;\n\tbitmapCache->cells = (BITMAP_V2_CELL*)calloc(bitmapCache->maxCells, sizeof(BITMAP_V2_CELL));\n\n\tif (!bitmapCache->cells)\n\t\tgoto fail;\n\n\tfor (i = 0; i < (int)bitmapCache->maxCells; i++)\n\t{\n\t\tbitmapCache->cells[i].number = settings->BitmapCacheV2CellInfo[i].numEntries;\n\t\t/* allocate an extra entry for BITMAP_CACHE_WAITING_LIST_INDEX */\n\t\tbitmapCache->cells[i].entries =\n\t\t    (rdpBitmap**)calloc((bitmapCache->cells[i].number + 1), sizeof(rdpBitmap*));\n\n\t\tif (!bitmapCache->cells[i].entries)\n\t\t\tgoto fail;\n\t}\n\n\treturn bitmapCache;\nfail:\n\n\tif (bitmapCache->cells)\n\t{\n\t\tfor (i = 0; i < (int)bitmapCache->maxCells; i++)\n\t\t\tfree(bitmapCache->cells[i].entries);\n\t}\n\n\tfree(bitmapCache);\n\treturn NULL;\n}",
        "start_line": 272
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "libfreerdp/cache/bitmap.c",
        "method_name": "bitmap_cache_new",
        "raw_code": "rdpBitmapCache* bitmap_cache_new(rdpSettings* settings) /* <=== bitmap_cache_new */ \n{\n\tint i;\n\trdpBitmapCache* bitmapCache;\n\tbitmapCache = (rdpBitmapCache*)calloc(1, sizeof(rdpBitmapCache));\n\n\tif (!bitmapCache)\n\t\treturn NULL;\n\n\tbitmapCache->settings = settings;\n\tbitmapCache->update = ((freerdp*)settings->instance)->update;\n\tbitmapCache->context = bitmapCache->update->context;\n\tbitmapCache->cells =\n\t    (BITMAP_V2_CELL*)calloc(settings->BitmapCacheV2NumCells, sizeof(BITMAP_V2_CELL));\n\n\tif (!bitmapCache->cells)\n\t\tgoto fail;\n\tbitmapCache->maxCells = settings->BitmapCacheV2NumCells;\n\n\tfor (i = 0; i < (int)bitmapCache->maxCells; i++)\n\t{\n\t\tbitmapCache->cells[i].number = settings->BitmapCacheV2CellInfo[i].numEntries;\n\t\t/* allocate an extra entry for BITMAP_CACHE_WAITING_LIST_INDEX */\n\t\tbitmapCache->cells[i].entries =\n\t\t    (rdpBitmap**)calloc((bitmapCache->cells[i].number + 1), sizeof(rdpBitmap*));\n\n\t\tif (!bitmapCache->cells[i].entries)\n\t\t\tgoto fail;\n\t}\n\n\treturn bitmapCache;\nfail:\n\n\tif (bitmapCache->cells)\n\t{\n\t\tfor (i = 0; i < (int)bitmapCache->maxCells; i++)\n\t\t\tfree(bitmapCache->cells[i].entries);\n\t}\n\n\tfree(bitmapCache);\n\treturn NULL;\n}",
        "start_line": 272
      }
    ],
    "code_context": "Type Definitions:\n- rdpBitmap: typedef struct rdp_bitmap rdpBitmap;\n- BITMAP_V2_CELL: typedef struct _BITMAP_V2_CELL BITMAP_V2_CELL;\n- rdpSettings: typedef struct rdp_settings rdpSettings;\n- rdpBitmapCache: typedef struct rdp_bitmap_cache rdpBitmapCache;\n\nImports:\n- #include <winpr/stream.h>\n- #include <freerdp/cache/bitmap.h>\n- #include \"../core/graphics.h\"\n- #include <stdio.h>\n- #include <winpr/crt.h>\n- #include <freerdp/log.h>\n- #include \"bitmap.h\"\n- #include \"config.h\"\n- #include <freerdp/freerdp.h>\n- #include <freerdp/gdi/bitmap.h>\n- #include \"../gdi/gdi.h\"\n- #include <freerdp/constants.h>",
    "commit_msg": "Fixed possible NULL dereference",
    "cve_desc": "libfreerdp/cache/bitmap.c in FreeRDP versions > 1.0 through 2.0.0-rc4 has an Out of bounds read.",
    "year": 2020,
    "filename": "bitmap.c",
    "commit_url": "\"https://github.com/FreeRDP/FreeRDP/commit/58dc36b3c883fd460199cedb6d30e58eba58298c\""
  },
  {
    "repository": "FreeRDP/FreeRDP",
    "cve_id": "CVE-2020-11526",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "192856cb59974ee4d7d3e72cbeafa676aa7565cf",
    "short_hash": "192856cb",
    "vulnerableMethods_before": [
      {
        "filename": "libfreerdp/core/orders.c",
        "method_name": "update_recv_secondary_order",
        "raw_code": "static BOOL update_recv_secondary_order(rdpUpdate* update, wStream* s, BYTE flags) /* <=== update_recv_secondary_order */ \n{\n\tBOOL rc = FALSE;\n\tBYTE* next;\n\tBYTE orderType;\n\tUINT16 extraFlags;\n\tUINT16 orderLength;\n\trdpContext* context = update->context;\n\trdpSettings* settings = context->settings;\n\trdpSecondaryUpdate* secondary = update->secondary;\n\tconst char* name;\n\n\tif (Stream_GetRemainingLength(s) < 5)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream_GetRemainingLength(s) < 5\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, orderLength); /* orderLength (2 bytes) */\n\tStream_Read_UINT16(s, extraFlags);  /* extraFlags (2 bytes) */\n\tStream_Read_UINT8(s, orderType);    /* orderType (1 byte) */\n\tnext = Stream_Pointer(s) + ((INT16)orderLength) + 7;\n\tname = secondary_order_string(orderType);\n\tWLog_Print(update->log, WLOG_DEBUG, \"Secondary Drawing Order %s\", name);\n\n\tif (!check_secondary_order_supported(update->log, settings, orderType, name))\n\t\treturn FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED:\n\t\tcase ORDER_TYPE_CACHE_BITMAP_COMPRESSED:\n\t\t{\n\t\t\tconst BOOL compressed = (orderType == ORDER_TYPE_CACHE_BITMAP_COMPRESSED);\n\t\t\tCACHE_BITMAP_ORDER* order =\n\t\t\t    update_read_cache_bitmap_order(update, s, compressed, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmap, context, order);\n\t\t\t\tfree_cache_bitmap_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED_V2:\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V2:\n\t\t{\n\t\t\tconst BOOL compressed = (orderType == ORDER_TYPE_BITMAP_COMPRESSED_V2);\n\t\t\tCACHE_BITMAP_V2_ORDER* order =\n\t\t\t    update_read_cache_bitmap_v2_order(update, s, compressed, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmapV2, context, order);\n\t\t\t\tfree_cache_bitmap_v2_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V3:\n\t\t{\n\t\t\tCACHE_BITMAP_V3_ORDER* order = update_read_cache_bitmap_v3_order(update, s, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmapV3, context, order);\n\t\t\t\tfree_cache_bitmap_v3_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_COLOR_TABLE:\n\t\t{\n\t\t\tCACHE_COLOR_TABLE_ORDER* order =\n\t\t\t    update_read_cache_color_table_order(update, s, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheColorTable, context, order);\n\t\t\t\tfree_cache_color_table_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_GLYPH:\n\t\t{\n\t\t\tswitch (settings->GlyphSupportLevel)\n\t\t\t{\n\t\t\t\tcase GLYPH_SUPPORT_PARTIAL:\n\t\t\t\tcase GLYPH_SUPPORT_FULL:\n\t\t\t\t{\n\t\t\t\t\tCACHE_GLYPH_ORDER* order = update_read_cache_glyph_order(update, s, extraFlags);\n\n\t\t\t\t\tif (order)\n\t\t\t\t\t{\n\t\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheGlyph, context, order);\n\t\t\t\t\t\tfree_cache_glyph_order(context, order);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tcase GLYPH_SUPPORT_ENCODE:\n\t\t\t\t{\n\t\t\t\t\tCACHE_GLYPH_V2_ORDER* order =\n\t\t\t\t\t    update_read_cache_glyph_v2_order(update, s, extraFlags);\n\n\t\t\t\t\tif (order)\n\t\t\t\t\t{\n\t\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheGlyphV2, context, order);\n\t\t\t\t\t\tfree_cache_glyph_v2_order(context, order);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tcase GLYPH_SUPPORT_NONE:\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_BRUSH:\n\t\t\t/* [MS-RDPEGDI] 2.2.2.2.1.2.7 Cache Brush (CACHE_BRUSH_ORDER) */\n\t\t\t{\n\t\t\t\tCACHE_BRUSH_ORDER* order = update_read_cache_brush_order(update, s, extraFlags);\n\n\t\t\t\tif (order)\n\t\t\t\t{\n\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBrush, context, order);\n\t\t\t\t\tfree_cache_brush_order(context, order);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(update->log, WLOG_WARN, \"SECONDARY ORDER %s not supported\", name);\n\t\t\tbreak;\n\t}\n\n\tif (!rc)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"SECONDARY ORDER %s failed\", name);\n\t}\n\n\tStream_SetPointer(s, next);\n\treturn rc;\n}",
        "start_line": 3467
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "libfreerdp/core/orders.c",
        "method_name": "update_recv_secondary_order",
        "raw_code": "static BOOL update_recv_secondary_order(rdpUpdate* update, wStream* s, BYTE flags) /* <=== update_recv_secondary_order */ \n{\n\tBOOL rc = FALSE;\n\tBYTE* next;\n\tBYTE orderType;\n\tUINT16 extraFlags;\n\tUINT16 orderLength;\n\trdpContext* context = update->context;\n\trdpSettings* settings = context->settings;\n\trdpSecondaryUpdate* secondary = update->secondary;\n\tconst char* name;\n\n\tif (Stream_GetRemainingLength(s) < 5)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream_GetRemainingLength(s) < 5\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, orderLength); /* orderLength (2 bytes) */\n\tStream_Read_UINT16(s, extraFlags);  /* extraFlags (2 bytes) */\n\tStream_Read_UINT8(s, orderType);    /* orderType (1 byte) */\n\tif (Stream_GetRemainingLength(s) < orderLength + 7)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"Stream_GetRemainingLength(s) %\" PRIuz \" < %\" PRIu16,\n\t\t           Stream_GetRemainingLength(s), orderLength + 7);\n\t\treturn FALSE;\n\t}\n\n\tnext = Stream_Pointer(s) + orderLength + 7;\n\tname = secondary_order_string(orderType);\n\tWLog_Print(update->log, WLOG_DEBUG, \"Secondary Drawing Order %s\", name);\n\n\tif (!check_secondary_order_supported(update->log, settings, orderType, name))\n\t\treturn FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED:\n\t\tcase ORDER_TYPE_CACHE_BITMAP_COMPRESSED:\n\t\t{\n\t\t\tconst BOOL compressed = (orderType == ORDER_TYPE_CACHE_BITMAP_COMPRESSED);\n\t\t\tCACHE_BITMAP_ORDER* order =\n\t\t\t    update_read_cache_bitmap_order(update, s, compressed, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmap, context, order);\n\t\t\t\tfree_cache_bitmap_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED_V2:\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V2:\n\t\t{\n\t\t\tconst BOOL compressed = (orderType == ORDER_TYPE_BITMAP_COMPRESSED_V2);\n\t\t\tCACHE_BITMAP_V2_ORDER* order =\n\t\t\t    update_read_cache_bitmap_v2_order(update, s, compressed, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmapV2, context, order);\n\t\t\t\tfree_cache_bitmap_v2_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V3:\n\t\t{\n\t\t\tCACHE_BITMAP_V3_ORDER* order = update_read_cache_bitmap_v3_order(update, s, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBitmapV3, context, order);\n\t\t\t\tfree_cache_bitmap_v3_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_COLOR_TABLE:\n\t\t{\n\t\t\tCACHE_COLOR_TABLE_ORDER* order =\n\t\t\t    update_read_cache_color_table_order(update, s, extraFlags);\n\n\t\t\tif (order)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheColorTable, context, order);\n\t\t\t\tfree_cache_color_table_order(context, order);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_GLYPH:\n\t\t{\n\t\t\tswitch (settings->GlyphSupportLevel)\n\t\t\t{\n\t\t\t\tcase GLYPH_SUPPORT_PARTIAL:\n\t\t\t\tcase GLYPH_SUPPORT_FULL:\n\t\t\t\t{\n\t\t\t\t\tCACHE_GLYPH_ORDER* order = update_read_cache_glyph_order(update, s, extraFlags);\n\n\t\t\t\t\tif (order)\n\t\t\t\t\t{\n\t\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheGlyph, context, order);\n\t\t\t\t\t\tfree_cache_glyph_order(context, order);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tcase GLYPH_SUPPORT_ENCODE:\n\t\t\t\t{\n\t\t\t\t\tCACHE_GLYPH_V2_ORDER* order =\n\t\t\t\t\t    update_read_cache_glyph_v2_order(update, s, extraFlags);\n\n\t\t\t\t\tif (order)\n\t\t\t\t\t{\n\t\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheGlyphV2, context, order);\n\t\t\t\t\t\tfree_cache_glyph_v2_order(context, order);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tcase GLYPH_SUPPORT_NONE:\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_BRUSH:\n\t\t\t/* [MS-RDPEGDI] 2.2.2.2.1.2.7 Cache Brush (CACHE_BRUSH_ORDER) */\n\t\t\t{\n\t\t\t\tCACHE_BRUSH_ORDER* order = update_read_cache_brush_order(update, s, extraFlags);\n\n\t\t\t\tif (order)\n\t\t\t\t{\n\t\t\t\t\trc = IFCALLRESULT(FALSE, secondary->CacheBrush, context, order);\n\t\t\t\t\tfree_cache_brush_order(context, order);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(update->log, WLOG_WARN, \"SECONDARY ORDER %s not supported\", name);\n\t\t\tbreak;\n\t}\n\n\tif (!rc)\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"SECONDARY ORDER %s failed\", name);\n\t}\n\n\tStream_SetPointer(s, next);\n\treturn rc;\n}",
        "start_line": 3467
      }
    ],
    "code_context": "Called Methods:\n- free_cache_glyph_order: void free_cache_glyph_order(rdpContext* context, CACHE_GLYPH_ORDER* glyph) /* <=== free_cache_glyph_order */ \n{\n\tif (glyph)\n\t{\n\t\tsize_t x;\n\n\t\tfor (x = 0; x < ARRAYSIZE(glyph->glyphData); x++)\n\t\t\tfree(glyph->glyphData[x].aj);\n\n\t\tfree(glyph->unicodeCharacters);\n\t}\n\n\tfree(glyph);\n}\n- free_cache_brush_order: void free_cache_brush_order(rdpContext* context, CACHE_BRUSH_ORDER* order) /* <=== free_cache_brush_order */ \n{\n\tfree(order);\n}\n- ORDER_TYPE_CACHE_BITMAP_COMPRESSED: #define ORDER_TYPE_CACHE_BITMAP_COMPRESSED 0x02 /* <=== libfreerdp/core/orders.h:167:167:ORDER_TYPE_CACHE_BITMAP_COMPRESSED:0 */ \n- update_read_cache_color_table_order: static CACHE_COLOR_TABLE_ORDER* update_read_cache_color_table_order(rdpUpdate* update, wStream* s, /* <=== update_read_cache_color_table_order */ \n                                                                    UINT16 flags)\n{\n\tint i;\n\tUINT32* colorTable;\n\tCACHE_COLOR_TABLE_ORDER* cache_color_table = calloc(1, sizeof(CACHE_COLOR_TABLE_ORDER));\n\n\tif (!cache_color_table)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 3)\n\t\tgoto fail;\n\n\tStream_Read_UINT8(s, cache_color_table->cacheIndex);    /* cacheIndex (1 byte) */\n\tStream_Read_UINT16(s, cache_color_table->numberColors); /* numberColors (2 bytes) */\n\n\tif (cache_color_table->numberColors != 256)\n\t{\n\t\t/* This field MUST be set to 256 */\n\t\tgoto fail;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < cache_color_table->numberColors * 4)\n\t\tgoto fail;\n\n\tcolorTable = (UINT32*)&cache_color_table->colorTable;\n\n\tfor (i = 0; i < (int)cache_color_table->numberColors; i++)\n\t\tupdate_read_color_quad(s, &colorTable[i]);\n\n\treturn cache_color_table;\nfail:\n\tfree_cache_color_table_order(update->context, cache_color_table);\n\treturn NULL;\n}\n- ORDER_TYPE_CACHE_GLYPH: #define ORDER_TYPE_CACHE_GLYPH 0x03 /* <=== libfreerdp/core/orders.h:168:168:ORDER_TYPE_CACHE_GLYPH:0 */ \n- free_cache_color_table_order: void free_cache_color_table_order(rdpContext* context, CACHE_COLOR_TABLE_ORDER* order) /* <=== free_cache_color_table_order */ \n{\n\tfree(order);\n}\n- check_order_activated: static BOOL check_order_activated(wLog* log, rdpSettings* settings, const char* orderName, /* <=== check_order_activated */ \n                                  BOOL condition)\n{\n\tif (!condition)\n\t{\n\t\tif (settings->AllowUnanouncedOrdersFromServer)\n\t\t{\n\t\t\tWLog_Print(log, WLOG_WARN,\n\t\t\t           \"%s - SERVER BUG: The support for this feature was not announced!\",\n\t\t\t           orderName);\n\t\t\treturn TRUE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tWLog_Print(log, WLOG_ERROR,\n\t\t\t           \"%s - SERVER BUG: The support for this feature was not announced! Use \"\n\t\t\t           \"/relax-order-checks to ignore\",\n\t\t\t           orderName);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n- CG_GLYPH_UNICODE_PRESENT: #define CG_GLYPH_UNICODE_PRESENT 0x0010 /* <=== libfreerdp/core/orders.h:190:190:CG_GLYPH_UNICODE_PRESENT:0 */ \n- update_read_cache_glyph_order: static CACHE_GLYPH_ORDER* update_read_cache_glyph_order(rdpUpdate* update, wStream* s, UINT16 flags) /* <=== update_read_cache_glyph_order */ \n{\n\tUINT32 i;\n\tCACHE_GLYPH_ORDER* cache_glyph_order = calloc(1, sizeof(CACHE_GLYPH_ORDER));\n\n\tif (!cache_glyph_order || !update || !s)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\tgoto fail;\n\n\tStream_Read_UINT8(s, cache_glyph_order->cacheId); /* cacheId (1 byte) */\n\tStream_Read_UINT8(s, cache_glyph_order->cGlyphs); /* cGlyphs (1 byte) */\n\n\tfor (i = 0; i < cache_glyph_order->cGlyphs; i++)\n\t{\n\t\tGLYPH_DATA* glyph = &cache_glyph_order->glyphData[i];\n\n\t\tif (Stream_GetRemainingLength(s) < 10)\n\t\t\tgoto fail;\n\n\t\tStream_Read_UINT16(s, glyph->cacheIndex);\n\t\tStream_Read_INT16(s, glyph->x);\n\t\tStream_Read_INT16(s, glyph->y);\n\t\tStream_Read_UINT16(s, glyph->cx);\n\t\tStream_Read_UINT16(s, glyph->cy);\n\t\tglyph->cb = ((glyph->cx + 7) / 8) * glyph->cy;\n\t\tglyph->cb += ((glyph->cb % 4) > 0) ? 4 - (glyph->cb % 4) : 0;\n\n\t\tif (Stream_GetRemainingLength(s) < glyph->cb)\n\t\t\tgoto fail;\n\n\t\tglyph->aj = (BYTE*)malloc(glyph->cb);\n\n\t\tif (!glyph->aj)\n\t\t\tgoto fail;\n\n\t\tStream_Read(s, glyph->aj, glyph->cb);\n\t}\n\n\tif ((flags & CG_GLYPH_UNICODE_PRESENT) && (cache_glyph_order->cGlyphs > 0))\n\t{\n\t\tcache_glyph_order->unicodeCharacters = calloc(cache_glyph_order->cGlyphs, sizeof(WCHAR));\n\n\t\tif (!cache_glyph_order->unicodeCharacters)\n\t\t\tgoto fail;\n\n\t\tif (Stream_GetRemainingLength(s) < sizeof(WCHAR) * cache_glyph_order->cGlyphs)\n\t\t\tgoto fail;\n\n\t\tStream_Read_UTF16_String(s, cache_glyph_order->unicodeCharacters,\n\t\t                         cache_glyph_order->cGlyphs);\n\t}\n\n\treturn cache_glyph_order;\nfail:\n\tfree_cache_glyph_order(update->context, cache_glyph_order);\n\treturn NULL;\n}\n- secondary_order_string: static const char* secondary_order_string(UINT32 orderType) /* <=== secondary_order_string */ \n{\n\tconst char* orders[] = { \"[0x%02\" PRIx8 \"] Cache Bitmap\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Color Table\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Bitmap (Compressed)\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Glyph\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Bitmap V2\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Bitmap V2 (Compressed)\",\n\t\t                     \"[0x%02\" PRIx8 \"] UNUSED\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Brush\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Bitmap V3\" };\n- ORDER_TYPE_BITMAP_UNCOMPRESSED_V2: #define ORDER_TYPE_BITMAP_UNCOMPRESSED_V2 0x04 /* <=== libfreerdp/core/orders.h:169:169:ORDER_TYPE_BITMAP_UNCOMPRESSED_V2:0 */ \n- NO_BITMAP_COMPRESSION_HDR: #define NO_BITMAP_COMPRESSION_HDR 0x0400 /* <=== libfreerdp/core/update.h:39:39:NO_BITMAP_COMPRESSION_HDR:0 */ \n- free_cache_bitmap_v2_order: void free_cache_bitmap_v2_order(rdpContext* context, CACHE_BITMAP_V2_ORDER* order) /* <=== free_cache_bitmap_v2_order */ \n{\n\tif (order)\n\t\tfree(order->bitmapDataStream);\n\n\tfree(order);\n}\n- update_read_cache_bitmap_v3_order: static CACHE_BITMAP_V3_ORDER* update_read_cache_bitmap_v3_order(rdpUpdate* update, wStream* s, /* <=== update_read_cache_bitmap_v3_order */ \n                                                                UINT16 flags)\n{\n\tBYTE bitsPerPixelId;\n\tBITMAP_DATA_EX* bitmapData;\n\tUINT32 new_len;\n\tBYTE* new_data;\n\tCACHE_BITMAP_V3_ORDER* cache_bitmap_v3;\n\n\tif (!update || !s)\n\t\treturn NULL;\n\n\tcache_bitmap_v3 = calloc(1, sizeof(CACHE_BITMAP_V3_ORDER));\n\n\tif (!cache_bitmap_v3)\n\t\tgoto fail;\n\n\tcache_bitmap_v3->cacheId = flags & 0x00000003;\n\tcache_bitmap_v3->flags = (flags & 0x0000FF80) >> 7;\n\tbitsPerPixelId = (flags & 0x00000078) >> 3;\n\tcache_bitmap_v3->bpp = CBR23_BPP[bitsPerPixelId];\n\n\tif (Stream_GetRemainingLength(s) < 21)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, cache_bitmap_v3->cacheIndex); /* cacheIndex (2 bytes) */\n\tStream_Read_UINT32(s, cache_bitmap_v3->key1);       /* key1 (4 bytes) */\n\tStream_Read_UINT32(s, cache_bitmap_v3->key2);       /* key2 (4 bytes) */\n\tbitmapData = &cache_bitmap_v3->bitmapData;\n\tStream_Read_UINT8(s, bitmapData->bpp);\n\n\tif ((bitmapData->bpp < 1) || (bitmapData->bpp > 32))\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"invalid bpp value %\" PRIu32 \"\", bitmapData->bpp);\n\t\tgoto fail;\n\t}\n\n\tStream_Seek_UINT8(s);                      /* reserved1 (1 byte) */\n\tStream_Seek_UINT8(s);                      /* reserved2 (1 byte) */\n\tStream_Read_UINT8(s, bitmapData->codecID); /* codecID (1 byte) */\n\tStream_Read_UINT16(s, bitmapData->width);  /* width (2 bytes) */\n\tStream_Read_UINT16(s, bitmapData->height); /* height (2 bytes) */\n\tStream_Read_UINT32(s, new_len);            /* length (4 bytes) */\n\n\tif ((new_len == 0) || (Stream_GetRemainingLength(s) < new_len))\n\t\tgoto fail;\n\n\tnew_data = (BYTE*)realloc(bitmapData->data, new_len);\n\n\tif (!new_data)\n\t\tgoto fail;\n\n\tbitmapData->data = new_data;\n\tbitmapData->length = new_len;\n\tStream_Read(s, bitmapData->data, bitmapData->length);\n\treturn cache_bitmap_v3;\nfail:\n\tfree_cache_bitmap_v3_order(update->context, cache_bitmap_v3);\n\treturn NULL;\n}\n- ORDER_TYPE_CACHE_BRUSH: #define ORDER_TYPE_CACHE_BRUSH 0x07 /* <=== libfreerdp/core/orders.h:171:171:ORDER_TYPE_CACHE_BRUSH:0 */ \n- update_read_cache_bitmap_order: static CACHE_BITMAP_ORDER* update_read_cache_bitmap_order(rdpUpdate* update, wStream* s, /* <=== update_read_cache_bitmap_order */ \n                                                          BOOL compressed, UINT16 flags)\n{\n\tCACHE_BITMAP_ORDER* cache_bitmap;\n\n\tif (!update || !s)\n\t\treturn NULL;\n\n\tcache_bitmap = calloc(1, sizeof(CACHE_BITMAP_ORDER));\n\n\tif (!cache_bitmap)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 9)\n\t\tgoto fail;\n\n\tStream_Read_UINT8(s, cache_bitmap->cacheId);      /* cacheId (1 byte) */\n\tStream_Seek_UINT8(s);                             /* pad1Octet (1 byte) */\n\tStream_Read_UINT8(s, cache_bitmap->bitmapWidth);  /* bitmapWidth (1 byte) */\n\tStream_Read_UINT8(s, cache_bitmap->bitmapHeight); /* bitmapHeight (1 byte) */\n\tStream_Read_UINT8(s, cache_bitmap->bitmapBpp);    /* bitmapBpp (1 byte) */\n\n\tif ((cache_bitmap->bitmapBpp < 1) || (cache_bitmap->bitmapBpp > 32))\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"invalid bitmap bpp %\" PRIu32 \"\",\n\t\t           cache_bitmap->bitmapBpp);\n\t\tgoto fail;\n\t}\n\n\tStream_Read_UINT16(s, cache_bitmap->bitmapLength); /* bitmapLength (2 bytes) */\n\tStream_Read_UINT16(s, cache_bitmap->cacheIndex);   /* cacheIndex (2 bytes) */\n\n\tif (compressed)\n\t{\n\t\tif ((flags & NO_BITMAP_COMPRESSION_HDR) == 0)\n\t\t{\n\t\t\tBYTE* bitmapComprHdr = (BYTE*)&(cache_bitmap->bitmapComprHdr);\n\n\t\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\t\tgoto fail;\n\n\t\t\tStream_Read(s, bitmapComprHdr, 8); /* bitmapComprHdr (8 bytes) */\n\t\t\tcache_bitmap->bitmapLength -= 8;\n\t\t}\n\t}\n\n\tif (Stream_GetRemainingLength(s) < cache_bitmap->bitmapLength)\n\t\tgoto fail;\n\n\tcache_bitmap->bitmapDataStream = malloc(cache_bitmap->bitmapLength);\n\n\tif (!cache_bitmap->bitmapDataStream)\n\t\tgoto fail;\n\n\tStream_Read(s, cache_bitmap->bitmapDataStream, cache_bitmap->bitmapLength);\n\tcache_bitmap->compressed = compressed;\n\treturn cache_bitmap;\nfail:\n\tfree_cache_bitmap_order(update->context, cache_bitmap);\n\treturn NULL;\n}\n- update_decompress_brush: static BOOL update_decompress_brush(wStream* s, BYTE* output, BYTE bpp) /* <=== update_decompress_brush */ \n{\n\tint index;\n\tint x, y, k;\n\tBYTE byte = 0;\n\tBYTE* palette;\n\tint bytesPerPixel;\n\tpalette = Stream_Pointer(s) + 16;\n\tbytesPerPixel = ((bpp + 1) / 8);\n\n\tif (Stream_GetRemainingLength(s) < 16) // 64 / 4\n\t\treturn FALSE;\n\n\tfor (y = 7; y >= 0; y--)\n\t{\n\t\tfor (x = 0; x < 8; x++)\n\t\t{\n\t\t\tif ((x % 4) == 0)\n\t\t\t\tStream_Read_UINT8(s, byte);\n\n\t\t\tindex = ((byte >> ((3 - (x % 4)) * 2)) & 0x03);\n\n\t\t\tfor (k = 0; k < bytesPerPixel; k++)\n\t\t\t{\n\t\t\t\toutput[((y * 8 + x) * bytesPerPixel) + k] = palette[(index * bytesPerPixel) + k];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n- update_read_cache_bitmap_v2_order: static CACHE_BITMAP_V2_ORDER* update_read_cache_bitmap_v2_order(rdpUpdate* update, wStream* s, /* <=== update_read_cache_bitmap_v2_order */ \n                                                                BOOL compressed, UINT16 flags)\n{\n\tBYTE bitsPerPixelId;\n\tCACHE_BITMAP_V2_ORDER* cache_bitmap_v2;\n\n\tif (!update || !s)\n\t\treturn NULL;\n\n\tcache_bitmap_v2 = calloc(1, sizeof(CACHE_BITMAP_V2_ORDER));\n\n\tif (!cache_bitmap_v2)\n\t\tgoto fail;\n\n\tcache_bitmap_v2->cacheId = flags & 0x0003;\n\tcache_bitmap_v2->flags = (flags & 0xFF80) >> 7;\n\tbitsPerPixelId = (flags & 0x0078) >> 3;\n\tcache_bitmap_v2->bitmapBpp = CBR2_BPP[bitsPerPixelId];\n\n\tif (cache_bitmap_v2->flags & CBR2_PERSISTENT_KEY_PRESENT)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\tgoto fail;\n\n\t\tStream_Read_UINT32(s, cache_bitmap_v2->key1); /* key1 (4 bytes) */\n\t\tStream_Read_UINT32(s, cache_bitmap_v2->key2); /* key2 (4 bytes) */\n\t}\n\n\tif (cache_bitmap_v2->flags & CBR2_HEIGHT_SAME_AS_WIDTH)\n\t{\n\t\tif (!update_read_2byte_unsigned(s, &cache_bitmap_v2->bitmapWidth)) /* bitmapWidth */\n\t\t\tgoto fail;\n\n\t\tcache_bitmap_v2->bitmapHeight = cache_bitmap_v2->bitmapWidth;\n\t}\n\telse\n\t{\n\t\tif (!update_read_2byte_unsigned(s, &cache_bitmap_v2->bitmapWidth) || /* bitmapWidth */\n\t\t    !update_read_2byte_unsigned(s, &cache_bitmap_v2->bitmapHeight))  /* bitmapHeight */\n\t\t\tgoto fail;\n\t}\n\n\tif (!update_read_4byte_unsigned(s, &cache_bitmap_v2->bitmapLength) || /* bitmapLength */\n\t    !update_read_2byte_unsigned(s, &cache_bitmap_v2->cacheIndex))     /* cacheIndex */\n\t\tgoto fail;\n\n\tif (cache_bitmap_v2->flags & CBR2_DO_NOT_CACHE)\n\t\tcache_bitmap_v2->cacheIndex = BITMAP_CACHE_WAITING_LIST_INDEX;\n\n\tif (compressed)\n\t{\n\t\tif (!(cache_bitmap_v2->flags & CBR2_NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\t\tgoto fail;\n\n\t\t\tStream_Read_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbCompFirstRowSize); /* cbCompFirstRowSize (2 bytes) */\n\t\t\tStream_Read_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbCompMainBodySize);         /* cbCompMainBodySize (2 bytes) */\n\t\t\tStream_Read_UINT16(s, cache_bitmap_v2->cbScanWidth); /* cbScanWidth (2 bytes) */\n\t\t\tStream_Read_UINT16(\n\t\t\t    s, cache_bitmap_v2->cbUncompressedSize); /* cbUncompressedSize (2 bytes) */\n\t\t\tcache_bitmap_v2->bitmapLength = cache_bitmap_v2->cbCompMainBodySize;\n\t\t}\n\t}\n\n\tif (Stream_GetRemainingLength(s) < cache_bitmap_v2->bitmapLength)\n\t\tgoto fail;\n\n\tif (cache_bitmap_v2->bitmapLength == 0)\n\t\tgoto fail;\n\n\tcache_bitmap_v2->bitmapDataStream = malloc(cache_bitmap_v2->bitmapLength);\n\n\tif (!cache_bitmap_v2->bitmapDataStream)\n\t\tgoto fail;\n\n\tStream_Read(s, cache_bitmap_v2->bitmapDataStream, cache_bitmap_v2->bitmapLength);\n\tcache_bitmap_v2->compressed = compressed;\n\treturn cache_bitmap_v2;\nfail:\n\tfree_cache_bitmap_v2_order(update->context, cache_bitmap_v2);\n\treturn NULL;\n}\n- free_cache_bitmap_v3_order: void free_cache_bitmap_v3_order(rdpContext* context, CACHE_BITMAP_V3_ORDER* order) /* <=== free_cache_bitmap_v3_order */ \n{\n\tif (order)\n\t\tfree(order->bitmapData.data);\n\n\tfree(order);\n}\n- check_secondary_order_supported: static BOOL check_secondary_order_supported(wLog* log, rdpSettings* settings, BYTE orderType, /* <=== check_secondary_order_supported */ \n                                            const char* orderName)\n{\n\tBOOL condition = FALSE;\n\n\tswitch (orderType)\n\t{\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED:\n\t\tcase ORDER_TYPE_CACHE_BITMAP_COMPRESSED:\n\t\t\tcondition = settings->BitmapCacheEnabled;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_UNCOMPRESSED_V2:\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V2:\n\t\t\tcondition = settings->BitmapCacheEnabled;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_BITMAP_COMPRESSED_V3:\n\t\t\tcondition = settings->BitmapCacheV3Enabled;\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_COLOR_TABLE:\n\t\t\tcondition = (settings->OrderSupport[NEG_MEMBLT_INDEX] ||\n\t\t\t             settings->OrderSupport[NEG_MEM3BLT_INDEX]);\n\t\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_GLYPH:\n\t\t{\n\t\t\tswitch (settings->GlyphSupportLevel)\n\t\t\t{\n\t\t\t\tcase GLYPH_SUPPORT_PARTIAL:\n\t\t\t\tcase GLYPH_SUPPORT_FULL:\n\t\t\t\tcase GLYPH_SUPPORT_ENCODE:\n\t\t\t\t\tcondition = TRUE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase GLYPH_SUPPORT_NONE:\n\t\t\t\tdefault:\n\t\t\t\t\tcondition = FALSE;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase ORDER_TYPE_CACHE_BRUSH:\n\t\t\tcondition = TRUE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(log, WLOG_WARN, \"SECONDARY ORDER %s not supported\", orderName);\n\t\t\tbreak;\n\t}\n\n\treturn check_order_activated(log, settings, orderName, condition);\n}\n- ORDER_TYPE_BITMAP_UNCOMPRESSED: #define ORDER_TYPE_BITMAP_UNCOMPRESSED 0x00 /* <=== libfreerdp/core/orders.h:165:165:ORDER_TYPE_BITMAP_UNCOMPRESSED:0 */ \n- ORDER_TYPE_BITMAP_COMPRESSED_V3: #define ORDER_TYPE_BITMAP_COMPRESSED_V3 0x08 /* <=== libfreerdp/core/orders.h:172:172:ORDER_TYPE_BITMAP_COMPRESSED_V3:0 */ \n- free_cache_glyph_v2_order: void free_cache_glyph_v2_order(rdpContext* context, CACHE_GLYPH_V2_ORDER* glyph) /* <=== free_cache_glyph_v2_order */ \n{\n\tif (glyph)\n\t{\n\t\tsize_t x;\n\n\t\tfor (x = 0; x < ARRAYSIZE(glyph->glyphData); x++)\n\t\t\tfree(glyph->glyphData[x].aj);\n\n\t\tfree(glyph->unicodeCharacters);\n\t}\n\n\tfree(glyph);\n}\n- update_read_cache_brush_order: static CACHE_BRUSH_ORDER* update_read_cache_brush_order(rdpUpdate* update, wStream* s, UINT16 flags) /* <=== update_read_cache_brush_order */ \n{\n\tint i;\n\tBYTE iBitmapFormat;\n\tBOOL compressed = FALSE;\n\tCACHE_BRUSH_ORDER* cache_brush = calloc(1, sizeof(CACHE_BRUSH_ORDER));\n\n\tif (!cache_brush)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 6)\n\t\tgoto fail;\n\n\tStream_Read_UINT8(s, cache_brush->index); /* cacheEntry (1 byte) */\n\tStream_Read_UINT8(s, iBitmapFormat);      /* iBitmapFormat (1 byte) */\n\n\tif (iBitmapFormat > ARRAYSIZE(BMF_BPP))\n\t\tgoto fail;\n\n\tcache_brush->bpp = BMF_BPP[iBitmapFormat];\n\tStream_Read_UINT8(s, cache_brush->cx);     /* cx (1 byte) */\n\tStream_Read_UINT8(s, cache_brush->cy);     /* cy (1 byte) */\n\tStream_Read_UINT8(s, cache_brush->style);  /* style (1 byte) */\n\tStream_Read_UINT8(s, cache_brush->length); /* iBytes (1 byte) */\n\n\tif ((cache_brush->cx == 8) && (cache_brush->cy == 8))\n\t{\n\t\tif (cache_brush->bpp == 1)\n\t\t{\n\t\t\tif (cache_brush->length != 8)\n\t\t\t{\n\t\t\t\tWLog_Print(update->log, WLOG_ERROR, \"incompatible 1bpp brush of length:%\" PRIu32 \"\",\n\t\t\t\t           cache_brush->length);\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\t/* rows are encoded in reverse order */\n\t\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\t\tgoto fail;\n\n\t\t\tfor (i = 7; i >= 0; i--)\n\t\t\t{\n\t\t\t\tStream_Read_UINT8(s, cache_brush->data[i]);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((iBitmapFormat == BMF_8BPP) && (cache_brush->length == 20))\n\t\t\t\tcompressed = TRUE;\n\t\t\telse if ((iBitmapFormat == BMF_16BPP) && (cache_brush->length == 24))\n\t\t\t\tcompressed = TRUE;\n\t\t\telse if ((iBitmapFormat == BMF_32BPP) && (cache_brush->length == 32))\n\t\t\t\tcompressed = TRUE;\n\n\t\t\tif (compressed != FALSE)\n\t\t\t{\n\t\t\t\t/* compressed brush */\n\t\t\t\tif (!update_decompress_brush(s, cache_brush->data, cache_brush->bpp))\n\t\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* uncompressed brush */\n\t\t\t\tUINT32 scanline = (cache_brush->bpp / 8) * 8;\n\n\t\t\t\tif (Stream_GetRemainingLength(s) < scanline * 8)\n\t\t\t\t\tgoto fail;\n\n\t\t\t\tfor (i = 7; i >= 0; i--)\n\t\t\t\t{\n\t\t\t\t\tStream_Read(s, &cache_brush->data[i * scanline], scanline);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cache_brush;\nfail:\n\tfree_cache_brush_order(update->context, cache_brush);\n\treturn NULL;\n}\n- ORDER_TYPE_BITMAP_COMPRESSED_V2: #define ORDER_TYPE_BITMAP_COMPRESSED_V2 0x05 /* <=== libfreerdp/core/orders.h:170:170:ORDER_TYPE_BITMAP_COMPRESSED_V2:0 */ \n- free_cache_bitmap_order: void free_cache_bitmap_order(rdpContext* context, CACHE_BITMAP_ORDER* order) /* <=== free_cache_bitmap_order */ \n{\n\tif (order)\n\t\tfree(order->bitmapDataStream);\n\n\tfree(order);\n}\n- ORDER_TYPE_CACHE_COLOR_TABLE: #define ORDER_TYPE_CACHE_COLOR_TABLE 0x01 /* <=== libfreerdp/core/orders.h:166:166:ORDER_TYPE_CACHE_COLOR_TABLE:0 */ \n- update_read_cache_glyph_v2_order: static CACHE_GLYPH_V2_ORDER* update_read_cache_glyph_v2_order(rdpUpdate* update, wStream* s, /* <=== update_read_cache_glyph_v2_order */ \n                                                              UINT16 flags)\n{\n\tUINT32 i;\n\tCACHE_GLYPH_V2_ORDER* cache_glyph_v2 = calloc(1, sizeof(CACHE_GLYPH_V2_ORDER));\n\n\tif (!cache_glyph_v2)\n\t\tgoto fail;\n\n\tcache_glyph_v2->cacheId = (flags & 0x000F);\n\tcache_glyph_v2->flags = (flags & 0x00F0) >> 4;\n\tcache_glyph_v2->cGlyphs = (flags & 0xFF00) >> 8;\n\n\tfor (i = 0; i < cache_glyph_v2->cGlyphs; i++)\n\t{\n\t\tGLYPH_DATA_V2* glyph = &cache_glyph_v2->glyphData[i];\n\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\tgoto fail;\n\n\t\tStream_Read_UINT8(s, glyph->cacheIndex);\n\n\t\tif (!update_read_2byte_signed(s, &glyph->x) || !update_read_2byte_signed(s, &glyph->y) ||\n\t\t    !update_read_2byte_unsigned(s, &glyph->cx) ||\n\t\t    !update_read_2byte_unsigned(s, &glyph->cy))\n\t\t{\n\t\t\tgoto fail;\n\t\t}\n\n\t\tglyph->cb = ((glyph->cx + 7) / 8) * glyph->cy;\n\t\tglyph->cb += ((glyph->cb % 4) > 0) ? 4 - (glyph->cb % 4) : 0;\n\n\t\tif (Stream_GetRemainingLength(s) < glyph->cb)\n\t\t\tgoto fail;\n\n\t\tglyph->aj = (BYTE*)malloc(glyph->cb);\n\n\t\tif (!glyph->aj)\n\t\t\tgoto fail;\n\n\t\tStream_Read(s, glyph->aj, glyph->cb);\n\t}\n\n\tif ((flags & CG_GLYPH_UNICODE_PRESENT) && (cache_glyph_v2->cGlyphs > 0))\n\t{\n\t\tcache_glyph_v2->unicodeCharacters = calloc(cache_glyph_v2->cGlyphs, sizeof(WCHAR));\n\n\t\tif (!cache_glyph_v2->unicodeCharacters)\n\t\t\tgoto fail;\n\n\t\tif (Stream_GetRemainingLength(s) < sizeof(WCHAR) * cache_glyph_v2->cGlyphs)\n\t\t\tgoto fail;\n\n\t\tStream_Read_UTF16_String(s, cache_glyph_v2->unicodeCharacters, cache_glyph_v2->cGlyphs);\n\t}\n\n\treturn cache_glyph_v2;\nfail:\n\tfree_cache_glyph_v2_order(update->context, cache_glyph_v2);\n\treturn NULL;\n}\n\nType Definitions:\n- wStream: typedef struct _wStream wStream;\n- rdpContext: typedef struct rdp_context rdpContext;\n- rdpUpdate: typedef struct rdp_update rdpUpdate;\n\nImports:\n- #include \"../cache/brush.h\"\n- #include <winpr/wtypes.h>\n- #include \"../cache/cache.h\"\n- #include <freerdp/graphics.h>\n- #include <freerdp/codec/bitmap.h>\n- #include \"config.h\"\n- #include \"../cache/glyph.h\"\n- #include \"orders.h\"\n- #include <winpr/crt.h>\n- #include \"../cache/bitmap.h\"\n- #include \"window.h\"\n- #include <freerdp/log.h>\n- #include <freerdp/api.h>\n- #include <freerdp/gdi/gdi.h>",
    "commit_msg": "Fixed #6012: CVE-2020-11526: Out of bounds read in update_recv_orders\n\nThanks to @hac425xxx and Sunglin and HuanGMz from Knownsec 404",
    "cve_desc": "libfreerdp/core/update.c in FreeRDP versions > 1.1 through 2.0.0-rc4 has an Out-of-bounds Read.",
    "year": 2020,
    "filename": "orders.c",
    "commit_url": "\"https://github.com/FreeRDP/FreeRDP/commit/192856cb59974ee4d7d3e72cbeafa676aa7565cf\""
  },
  {
    "repository": "gpac/gpac",
    "cve_id": "CVE-2020-11558",
    "cwe_list": [
      "CWE-416"
    ],
    "commit_hash": "6063b1a011c3f80cee25daade18154e15e4c058c",
    "short_hash": "6063b1a0",
    "vulnerableMethods_before": [
      {
        "filename": "src/isomedia/box_code_base.c",
        "method_name": "audio_sample_entry_Read",
        "raw_code": "GF_Err audio_sample_entry_Read(GF_Box *s, GF_BitStream *bs) /* <=== audio_sample_entry_Read */ \n{\n\tGF_MPEGAudioSampleEntryBox *ptr;\n\tchar *data;\n\tu8 a, b, c, d;\n\tu32 i, size, v, nb_alnum;\n\tGF_Err e;\n\tu64 pos, start;\n\n\tptr = (GF_MPEGAudioSampleEntryBox *)s;\n\n\tstart = gf_bs_get_position(bs);\n\tgf_bs_seek(bs, start + 8);\n\tv = gf_bs_read_u16(bs);\n\tif (v)\n\t\tptr->is_qtff = 1;\n\n\t//try to disambiguate QTFF v1 and MP4 v1 audio sample entries ...\n\tif (v==1) {\n\t\t//go to end of ISOM audio sample entry, skip 4 byte (box size field), read 4 bytes (box type) and check if this looks like a box\n\t\tgf_bs_seek(bs, start + 8 + 20  + 4);\n\t\ta = gf_bs_read_u8(bs);\n\t\tb = gf_bs_read_u8(bs);\n\t\tc = gf_bs_read_u8(bs);\n\t\td = gf_bs_read_u8(bs);\n\t\tnb_alnum = 0;\n\t\tif (isalnum(a)) nb_alnum++;\n\t\tif (isalnum(b)) nb_alnum++;\n\t\tif (isalnum(c)) nb_alnum++;\n\t\tif (isalnum(d)) nb_alnum++;\n\t\tif (nb_alnum>2) ptr->is_qtff = 0;\n\t}\n\n\tgf_bs_seek(bs, start);\n\te = gf_isom_audio_sample_entry_read((GF_AudioSampleEntryBox*)s, bs);\n\tif (e) return e;\n\tpos = gf_bs_get_position(bs);\n\tsize = (u32) s->size;\n\n\t//when cookie is set on bs, always convert qtff-style mp4a to isobmff-style\n\t//since the conversion is done in addBox and we don't have the bitstream there (arg...), flag the box\n \tif (gf_bs_get_cookie(bs)) {\n \t\tptr->is_qtff |= 1<<16;\n \t}\n\n\te = gf_isom_box_array_read(s, bs, audio_sample_entry_AddBox);\n\tif (!e) return GF_OK;\n\tif (size<8) return GF_ISOM_INVALID_FILE;\n\n\t/*hack for some weird files (possibly recorded with live.com tools, needs further investigations)*/\n\tgf_bs_seek(bs, pos);\n\tdata = (char*)gf_malloc(sizeof(char) * size);\n\tgf_bs_read_data(bs, data, size);\n\tfor (i=0; i<size-8; i++) {\n\t\tif (GF_4CC((u32)data[i+4], (u8)data[i+5], (u8)data[i+6], (u8)data[i+7]) == GF_ISOM_BOX_TYPE_ESDS) {\n\t\t\tGF_BitStream *mybs = gf_bs_new(data + i, size - i, GF_BITSTREAM_READ);\n\t\t\tif (ptr->esd) {\n\t\t\t\tgf_isom_box_del((GF_Box *)ptr->esd);\n\t\t\t\tptr->esd=NULL;\n\t\t\t}\n\n\t\t\te = gf_isom_box_parse((GF_Box **)&ptr->esd, mybs);\n\n\t\t\tif (e==GF_OK) {\n\t\t\t\tgf_isom_box_add_for_dump_mode((GF_Box*)ptr, (GF_Box*)ptr->esd);\n\t\t\t} else if (ptr->esd) {\n\t\t\t\tgf_isom_box_del((GF_Box *)ptr->esd);\n\t\t\t\tptr->esd=NULL;\n\t\t\t}\n\n\t\t\tgf_bs_del(mybs);\n\t\t\tbreak;\n\t\t}\n\t}\n\tgf_free(data);\n\treturn e;\n}",
        "start_line": 4017
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "src/isomedia/box_code_base.c",
        "method_name": "audio_sample_entry_Read",
        "raw_code": "GF_Err audio_sample_entry_Read(GF_Box *s, GF_BitStream *bs) /* <=== audio_sample_entry_Read */ \n{\n\tGF_MPEGAudioSampleEntryBox *ptr;\n\tchar *data;\n\tu8 a, b, c, d;\n\tu32 i, size, v, nb_alnum;\n\tGF_Err e;\n\tu64 pos, start;\n\n\tptr = (GF_MPEGAudioSampleEntryBox *)s;\n\n\tstart = gf_bs_get_position(bs);\n\tgf_bs_seek(bs, start + 8);\n\tv = gf_bs_read_u16(bs);\n\tif (v)\n\t\tptr->is_qtff = 1;\n\n\t//try to disambiguate QTFF v1 and MP4 v1 audio sample entries ...\n\tif (v==1) {\n\t\t//go to end of ISOM audio sample entry, skip 4 byte (box size field), read 4 bytes (box type) and check if this looks like a box\n\t\tgf_bs_seek(bs, start + 8 + 20  + 4);\n\t\ta = gf_bs_read_u8(bs);\n\t\tb = gf_bs_read_u8(bs);\n\t\tc = gf_bs_read_u8(bs);\n\t\td = gf_bs_read_u8(bs);\n\t\tnb_alnum = 0;\n\t\tif (isalnum(a)) nb_alnum++;\n\t\tif (isalnum(b)) nb_alnum++;\n\t\tif (isalnum(c)) nb_alnum++;\n\t\tif (isalnum(d)) nb_alnum++;\n\t\tif (nb_alnum>2) ptr->is_qtff = 0;\n\t}\n\n\tgf_bs_seek(bs, start);\n\te = gf_isom_audio_sample_entry_read((GF_AudioSampleEntryBox*)s, bs);\n\tif (e) return e;\n\tpos = gf_bs_get_position(bs);\n\tsize = (u32) s->size;\n\n\t//when cookie is set on bs, always convert qtff-style mp4a to isobmff-style\n\t//since the conversion is done in addBox and we don't have the bitstream there (arg...), flag the box\n \tif (gf_bs_get_cookie(bs)) {\n \t\tptr->is_qtff |= 1<<16;\n \t}\n\n\te = gf_isom_box_array_read(s, bs, audio_sample_entry_AddBox);\n\tif (!e) return GF_OK;\n\tif (size<8) return GF_ISOM_INVALID_FILE;\n\n\t/*hack for some weird files (possibly recorded with live.com tools, needs further investigations)*/\n\tgf_bs_seek(bs, pos);\n\tdata = (char*)gf_malloc(sizeof(char) * size);\n\tgf_bs_read_data(bs, data, size);\n\tfor (i=0; i<size-8; i++) {\n\t\tif (GF_4CC((u32)data[i+4], (u8)data[i+5], (u8)data[i+6], (u8)data[i+7]) == GF_ISOM_BOX_TYPE_ESDS) {\n\t\t\textern Bool use_dump_mode;\n\t\t\tGF_BitStream *mybs = gf_bs_new(data + i, size - i, GF_BITSTREAM_READ);\n\t\t\tif (ptr->esd) {\n\t\t\t\tif (!use_dump_mode) gf_isom_box_del((GF_Box *)ptr->esd);\n\t\t\t\tptr->esd=NULL;\n\t\t\t}\n\n\t\t\te = gf_isom_box_parse((GF_Box **)&ptr->esd, mybs);\n\n\t\t\tif (e==GF_OK) {\n\t\t\t\tgf_isom_box_add_for_dump_mode((GF_Box*)ptr, (GF_Box*)ptr->esd);\n\t\t\t} else if (ptr->esd) {\n\t\t\t\tgf_isom_box_del((GF_Box *)ptr->esd);\n\t\t\t\tptr->esd=NULL;\n\t\t\t}\n\n\t\t\tgf_bs_del(mybs);\n\t\t\tbreak;\n\t\t}\n\t}\n\tgf_free(data);\n\treturn e;\n}",
        "start_line": 4017
      }
    ],
    "code_context": "Called Methods:\n- gf_isom_box_array_read_ex: GF_Err gf_isom_box_array_read_ex(GF_Box *parent, GF_BitStream *bs, GF_Err (*add_box)(GF_Box *par, GF_Box *b), u32 parent_type) /* <=== gf_isom_box_array_read_ex */ \n{\n\tGF_Err e;\n\tGF_Box *a = NULL;\n\tBool skip_logs = gf_bs_get_cookie(bs) ? GF_TRUE : GF_FALSE;\n\n\t//we may have terminators in some QT files (4 bytes set to 0 ...)\n\twhile (parent->size>=8) {\n\t\te = gf_isom_box_parse_ex(&a, bs, parent_type, GF_FALSE);\n\t\tif (e) {\n\t\t\tif (a) gf_isom_box_del(a);\n\t\t\treturn e;\n\t\t}\n\t\t//sub box parsing aborted with no error\n\t\tif (!a) return GF_OK;\n\n\t\tif (parent->size < a->size) {\n\t\t\tif (!skip_logs) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" is larger than container box\\n\", gf_4cc_to_str(a->type)));\n\t\t\t}\n\t\t\tparent->size = 0;\n\t\t} else {\n\t\t\tparent->size -= a->size;\n\t\t}\n\n\t\t//check container validity\n\t\tif (strlen(a->registry->parents_4cc)) {\n\t\t\tBool parent_OK = GF_FALSE;\n\t\t\tconst char *parent_code = gf_4cc_to_str(parent->type);\n\t\t\tif (parent->type == GF_ISOM_BOX_TYPE_UNKNOWN)\n\t\t\t\tparent_code = gf_4cc_to_str( ((GF_UnknownBox*)parent)->original_4cc );\n\t\t\tif (strstr(a->registry->parents_4cc, parent_code) != NULL) {\n\t\t\t\tparent_OK = GF_TRUE;\n\t\t\t} else if (!strcmp(a->registry->parents_4cc, \"*\") || strstr(a->registry->parents_4cc, \"* \") || strstr(a->registry->parents_4cc, \" *\")) {\n\t\t\t\tparent_OK = GF_TRUE;\n\t\t\t} else {\n\t\t\t\t//parent must be a sample entry\n\t\t\t\tif (strstr(a->registry->parents_4cc, \"sample_entry\") !=\tNULL) {\n\t\t\t\t\t//parent is in an stsd\n\t\t\t\t\tif (strstr(parent->registry->parents_4cc, \"stsd\") != NULL) {\n\t\t\t\t\t\tif (strstr(a->registry->parents_4cc, \"video_sample_entry\") !=\tNULL) {\n\t\t\t\t\t\t\tif (((GF_SampleEntryBox*)parent)->internal_type==GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\t\t\t\t\t\t\tparent_OK = GF_TRUE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tparent_OK = GF_TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//other types are sample formats, eg a 3GPP text sample, RTP hint sample or VTT cue. Not handled at this level\n\t\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_UNKNOWN) parent_OK = GF_TRUE;\n\t\t\t\telse if (a->type==GF_ISOM_BOX_TYPE_UUID) parent_OK = GF_TRUE;\n\t\t\t}\n\t\t\tif (! parent_OK && !skip_logs) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box \\\"%s\\\" is invalid in container %s\\n\", gf_4cc_to_str(a->type), parent_code));\n\t\t\t}\n\t\t}\n\n\t\te = add_box(parent, a);\n\t\tif (e) {\n\t\t\tif (e == GF_ISOM_INVALID_MEDIA) return GF_OK;\n\t\t\tgf_isom_box_del(a);\n\t\t\treturn e;\n\t\t}\n\t\t//in dump mode store all boxes in other_boxes if not done, so that we can dump the original order\n\t\tgf_isom_box_add_for_dump_mode(parent, a);\n\t}\n\treturn GF_OK;\n}\n- BS_ReadByte: static u8 BS_ReadByte(GF_BitStream *bs) /* <=== BS_ReadByte */ \n{\n\tif (bs->bsmode == GF_BITSTREAM_READ) {\n\t\tu8 res;\n\t\tif (bs->position >= bs->size) {\n\t\t\tif (bs->EndOfStream) bs->EndOfStream(bs->par);\n\t\t\treturn 0;\n\t\t}\n\t\tres = bs->original[bs->position++];\n\t\treturn res;\n\t}\n\tif (bs->buffer_io)\n\t\tbs_flush_cache(bs);\n\n\t/*we are in FILE mode, test for end of file*/\n\tif (!feof(bs->stream)) {\n\t\tu8 res;\n\t\tassert(bs->position<=bs->size);\n\t\tbs->position++;\n\t\tres = fgetc(bs->stream);\n\t\treturn res;\n\t}\n\tif (bs->EndOfStream) {\n\t\tbs->EndOfStream(bs->par);\n\t} else {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[BS] Attempt to overread bitstream\\n\"));\n\t}\n\tassert(bs->position <= 1+bs->size);\n\treturn 0;\n}\n- gf_bs_read_u16: u32 gf_bs_read_u16(GF_BitStream *bs) /* <=== gf_bs_read_u16 */ \n{\n\tu32 ret;\n\tassert(bs->nbBits==8);\n\tret = BS_ReadByte(bs);\n\tret<<=8;\n\tret |= BS_ReadByte(bs);\n\treturn ret;\n}\n- gf_isom_box_array_del: void gf_isom_box_array_del(GF_List *other_boxes) /* <=== gf_isom_box_array_del */ \n{\n\tu32 count, i;\n\tGF_Box *a;\n\tif (!other_boxes) return;\n\tcount = gf_list_count(other_boxes);\n\tfor (i = 0; i < count; i++) {\n\t\ta = (GF_Box *)gf_list_get(other_boxes, i);\n\t\tif (a) gf_isom_box_del(a);\n\t}\n\tgf_list_del(other_boxes);\n}\n- gf_malloc: void *gf_malloc(size_t size) /* <=== gf_malloc */ \n{\n\treturn MALLOC(size);\n}\n- gf_bs_get_cookie: u64 gf_bs_get_cookie(GF_BitStream *bs) /* <=== gf_bs_get_cookie */ \n{\n\tif (!bs) return 0;\n\treturn bs->cookie;\n}\n- gf_bs_read_u8: u32 gf_bs_read_u8(GF_BitStream *bs) /* <=== gf_bs_read_u8 */ \n{\n\tassert(bs->nbBits==8);\n\treturn (u32) BS_ReadByte(bs);\n}\n- MALLOC: #define MALLOC\tmalloc /* <=== src/utils/alloc.c:121:121:MALLOC:0 */ \n- gf_isom_box_del: void gf_isom_box_del(GF_Box *a) /* <=== gf_isom_box_del */ \n{\n\tGF_List *other_boxes;\n\tif (!a) return;\n\tif (skip_box_dump_del) return;\n\n\tother_boxes\t= a->other_boxes;\n\ta->other_boxes = NULL;\n\n\tif (!a->registry) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Delete invalid box type %s without registry\\n\", gf_4cc_to_str(a->type) ));\n\t} else {\n\t\tif (use_dump_mode) {\n\t\t\tskip_box_dump_del = GF_TRUE;\n\t\t\ta->registry->del_fn(a);\n\t\t\tskip_box_dump_del = GF_FALSE;\n\t\t} else {\n\t\t\ta->registry->del_fn(a);\n\t\t}\n\t}\n\t//delet the other boxes after deleting the box for dumper case where all child boxes are stored in otherbox\n\tif (other_boxes) {\n\t\tgf_isom_box_array_del(other_boxes);\n\t}\n}\n- gf_isom_box_array_read: GF_Err gf_isom_box_array_read(GF_Box *parent, GF_BitStream *bs, GF_Err (*add_box)(GF_Box *par, GF_Box *b)) /* <=== gf_isom_box_array_read */ \n{\n\treturn gf_isom_box_array_read_ex(parent, bs, add_box, parent->type);\n}\n\nType Definitions:\n- GF_Box: typedef struct\n{\n\tGF_ISOM_BOX\n}\n- ANY: typedef struct\n{\n\tunsigned char *pixels_YUV_source;\n\n\tu32 width, height;\n\tDtMxProcess *m_Matrix;\n\n\tDtDevice *dvc;\n\tBool is_sending, is_configured, is_10b, clip_sdi;\n\n\tDtCbkCtx audio_cbk_ctx, video_cbk_ctx;\n\n\ts64 frameNum;\n\tFILE *pFile;\n\tBool is_in_flush;\n\tBool frame_transfered;\n\t\n\ts64 lastFrameNum;\n\tu64 init_clock, last_frame_time;\n\n\tu32 frame_dur, frame_scale;\n\tBool needs_reconfigure;\n\tu32 force_width, force_height;\n}\n- GF_MPEGAudioSampleEntryBox: typedef struct\n{\n\tGF_ISOM_AUDIO_SAMPLE_ENTRY\n\t//for MPEG4 audio\n\tGF_ESDBox *esd;\n\tGF_SLConfig *slc;\n\t//for 3GPP audio\n\tGF_3GPPConfigBox *cfg_3gpp;\n\n\t//for AC3/EC3 audio\n\tGF_AC3ConfigBox *cfg_ac3;\n\n\t//for Opus\n\tGF_OpusSpecificBox *cfg_opus;\n\n\t//for MPEG-H audio\n\tGF_MHAConfigBox *cfg_mha;\n}\n- ANY: typedef struct\n{\n\t/*the service we're responsible for*/\n\tGF_ClientService *service;\n\tu32 state;\n\n\tDeviceDescriptor *device_desc;\n\tCaptureDevice* device;\n\n\tGPACCaptureHandler *video_handler;\n\tGPACCaptureHandler *audio_handler;\n\n\tu32 width, height, pixel_format, stride, out_size, fps;\n\tu32 default_4cc;\n\tBool flip_video;\n}\n\nImports:\n- #include <gpac/internal/isomedia_dev.h>",
    "commit_msg": "fix UAF in audio_sample_entry_Read (#1440)",
    "cve_desc": "[{'lang': 'en', 'value': 'An issue was discovered in libgpac.a in GPAC 0.8.0, as demonstrated by MP4Box. audio_sample_entry_Read in isomedia/box_code_base.c does not properly decide when to make gf_isom_box_del calls. This leads to various use-after-free outcomes involving mdia_Read, gf_isom_delete_movie, and gf_isom_parse_movie_boxes.'}]",
    "year": 2020,
    "filename": "box_code_base.c",
    "commit_url": "\"https://github.com/gpac/gpac/commit/6063b1a011c3f80cee25daade18154e15e4c058c\""
  },
  {
    "repository": "linux4sam/at91bootstrap",
    "cve_id": "CVE-2020-11683",
    "cwe_list": [
      "CWE-203"
    ],
    "commit_hash": "7753914c9a622c245f3a3cf2af5e24b6a9904213",
    "short_hash": "7753914c",
    "vulnerableMethods_before": [
      {
        "filename": "driver/secure.c",
        "method_name": "secure_decrypt",
        "raw_code": "int secure_decrypt(void *data, unsigned int data_length, int is_signed) /* <=== secure_decrypt */ \n{\n\tat91_aes_key_size_t key_size;\n\tunsigned int cmac_key[8], cipher_key[8];\n\tunsigned int iv[AT91_AES_IV_SIZE_WORD];\n\tunsigned int computed_cmac[AT91_AES_BLOCK_SIZE_WORD];\n\tunsigned int fixed_length;\n\tconst unsigned int *cmac;\n\tint rc = -1;\n\n\t/* Init keys */\n\tinit_keys(&key_size, cipher_key, cmac_key, iv);\n\n\t/* Init periph */\n\tat91_aes_init();\n\n\t/* Check signature if required */\n\tif (is_signed) {\n\t\t/* Compute the CMAC */\n\t\tif (at91_aes_cmac(data_length, data, computed_cmac,\n\t\t\t\t  key_size, cmac_key))\n\t\t\tgoto exit;\n\n\t\t/* Check the CMAC */\n\t\tfixed_length = at91_aes_roundup(data_length);\n\t\tcmac = (const unsigned int *)((char *)data + fixed_length);\n\t\tif (memcmp(cmac, computed_cmac, AT91_AES_BLOCK_SIZE_BYTE))\n\t\t\tgoto exit;\n\t}\n\n\t/* Decrypt the whole file */\n\tif (at91_aes_cbc(data_length, data, data, 0,\n\t\t\t key_size, cipher_key, iv))\n\t\tgoto exit;\n\n\trc = 0;\nexit:\n\t/* Reset periph */\n\tat91_aes_cleanup();\n\n\t/* Reset keys */\n\tmemset(cmac_key, 0, sizeof(cmac_key));\n\tmemset(cipher_key, 0, sizeof(cipher_key));\n\tmemset(iv, 0, sizeof(iv));\n\n\treturn rc;\n}",
        "start_line": 80
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "driver/secure.c",
        "method_name": "secure_decrypt",
        "raw_code": "int secure_decrypt(void *data, unsigned int data_length, int is_signed) /* <=== secure_decrypt */ \n{\n\tat91_aes_key_size_t key_size;\n\tunsigned int cmac_key[8], cipher_key[8];\n\tunsigned int iv[AT91_AES_IV_SIZE_WORD];\n\tunsigned int computed_cmac[AT91_AES_BLOCK_SIZE_WORD];\n\tunsigned int fixed_length;\n\tconst unsigned int *cmac;\n\tint rc = -1;\n\n\t/* Init keys */\n\tinit_keys(&key_size, cipher_key, cmac_key, iv);\n\n\t/* Init periph */\n\tat91_aes_init();\n\n\t/* Check signature if required */\n\tif (is_signed) {\n\t\t/* Compute the CMAC */\n\t\tif (at91_aes_cmac(data_length, data, computed_cmac,\n\t\t\t\t  key_size, cmac_key))\n\t\t\tgoto exit;\n\n\t\t/* Check the CMAC */\n\t\tfixed_length = at91_aes_roundup(data_length);\n\t\tcmac = (const unsigned int *)((char *)data + fixed_length);\n\t\tif (!consttime_memequal(cmac, computed_cmac, AT91_AES_BLOCK_SIZE_BYTE))\n\t\t\tgoto exit;\n\t}\n\n\t/* Decrypt the whole file */\n\tif (at91_aes_cbc(data_length, data, data, 0,\n\t\t\t key_size, cipher_key, iv))\n\t\tgoto exit;\n\n\trc = 0;\nexit:\n\t/* Reset periph */\n\tat91_aes_cleanup();\n\n\t/* Reset keys */\n\tmemset(cmac_key, 0, sizeof(cmac_key));\n\tmemset(cipher_key, 0, sizeof(cipher_key));\n\tmemset(iv, 0, sizeof(iv));\n\n\treturn rc;\n}",
        "start_line": 80
      }
    ],
    "code_context": "Called Methods:\n- AT91_AES_BLOCK_SIZE_BYTE: #define AT91_AES_BLOCK_SIZE_BYTE\t16 /* <=== include/aes.h:31:31:AT91_AES_BLOCK_SIZE_BYTE:0 */ \n- memset: extern void *memset(void *dst, int val, int cnt); /* <=== memset */ \n- at91_aes_length2blocks: static inline unsigned int at91_aes_length2blocks(unsigned int data_length, /* <=== at91_aes_length2blocks */ \n\t\t\t\t\t\t  unsigned int block_size)\n{\n\tunsigned int mask = 0;\n\tunsigned int shift = 0;\n\n\tswitch (block_size) {\n\tdefault:\n\tcase 1:\n\t\tbreak;\n\n\tcase 2:\n\t\tmask = 0x1;\n\t\tshift = 1;\n\t\tbreak;\n\n\tcase 4:\n\t\tmask = 0x3;\n\t\tshift = 2;\n\t\tbreak;\n\n\tcase 8:\n\t\tmask = 0x7;\n\t\tshift = 3;\n\t\tbreak;\n\n\tcase 16:\n\t\tmask = 0xf;\n\t\tshift = 4;\n\t\tbreak;\n\t}\n\n\treturn (data_length >> shift) + ((data_length & mask) ? 1 : 0);\n}\n- at91_aes_cbc: int at91_aes_cbc(unsigned int data_length, /* <=== at91_aes_cbc */ \n\t\t const void *input,\n\t\t void *output,\n\t\t int encrypt,\n\t\t at91_aes_key_size_t key_size,\n\t\t const unsigned int *key,\n\t\t const unsigned int *iv)\n{\n\tat91_aes_params_t params;\n\n\tif (!data_length || !input || !output || !key || !iv)\n\t\treturn -1;\n\n\tmemset(&params, 0, sizeof(params));\n\tparams.operation = (encrypt) ? AT91_AES_OP_ENCRYPT : AT91_AES_OP_DECRYPT;\n\tparams.mode = AT91_AES_MODE_CBC;\n\tparams.data_length = data_length;\n\tparams.input = input;\n\tparams.output = output;\n\tparams.key_size = key_size;\n\tparams.key = key;\n\tparams.iv = iv;\n\n\treturn at91_aes_process(&params);\n}\n- at91_aes_roundup: static inline unsigned int at91_aes_roundup(unsigned int data_length) /* <=== at91_aes_roundup */ \n{\n\tunsigned int fixed_length;\n\n\tfixed_length = data_length >> 4;\n\tif (data_length & 0xf)\n\t\tfixed_length++;\n\n\treturn fixed_length << 4;\n}\n- AT91_AES_IV_SIZE_WORD: #define AT91_AES_IV_SIZE_WORD\t\t4 /* <=== include/aes.h:35:35:AT91_AES_IV_SIZE_WORD:0 */ \n- consttime_memequal: extern int consttime_memequal(const void *b1, const void *b2, size_t len); /* <=== consttime_memequal */ \n- at91_aes_cmac: int at91_aes_cmac(unsigned int data_length, /* <=== at91_aes_cmac */ \n\t\t  const void *data,\n\t\t  unsigned int *cmac,\n\t\t  at91_aes_key_size_t key_size,\n\t\t  const unsigned int *key)\n{\n\tstatic const unsigned int null_block[AT91_AES_BLOCK_SIZE_WORD];\n\tstatic const unsigned int null_iv[AT91_AES_IV_SIZE_WORD];\n\tunsigned int last_input[AT91_AES_BLOCK_SIZE_WORD];\n\tunsigned int subkey[AT91_AES_BLOCK_SIZE_WORD];\n\tconst unsigned int *input = (const unsigned int *)data;\n\tunsigned int num_blocks, offset;\n\tat91_aes_params_t params;\n\tunsigned char carry;\n\tint i; /* MUST be signed for the subkey loop */\n\n\tif (!data_length || !data || !cmac || !key)\n\t\treturn -1;\n\n\t/* Set common parameters once for all */\n\tmemset(&params, 0, sizeof(params));\n\tparams.key_size = key_size;\n\tparams.key = key;\n\n\t/* Generate the subkey */\n\tparams.operation = AT91_AES_OP_ENCRYPT;\n\tparams.mode = AT91_AES_MODE_ECB;\n\tparams.data_length = AT91_AES_BLOCK_SIZE_BYTE;\n\tparams.input = null_block;\n\tparams.output = subkey;\n\tif (at91_aes_process(&params))\n\t\treturn -1;\n\n\tcarry = 0;\n\tfor (i = AT91_AES_BLOCK_SIZE_BYTE-1; i >= 0; --i) {\n\t\tunsigned char tmp, next_carry;\n\n\t\ttmp = ((unsigned char *)subkey)[i];\n\t\tnext_carry = ((tmp & 0x80) != 0);\n\t\t((unsigned char *)subkey)[i] = (tmp << 1) | carry;\n\t\tcarry = next_carry;\n\t}\n\tcarry = (0 - carry) & 0x87;\n\t((unsigned char *)subkey)[AT91_AES_BLOCK_SIZE_BYTE-1] ^= carry;\n\n\t/* Process the n-1 first blocks */\n\tnum_blocks = at91_aes_length2blocks(data_length,\n\t\t\t\t\t    AT91_AES_BLOCK_SIZE_BYTE);\n\tif (num_blocks > 1) {\n\t\tparams.operation = AT91_AES_OP_MAC;\n\t\tparams.mode = AT91_AES_MODE_CBC;\n\t\tparams.iv = null_iv;\n\t\tparams.data_length = data_length - AT91_AES_BLOCK_SIZE_BYTE;\n\t\tparams.input = data;\n\t\tparams.output = cmac;\n\t\tif (at91_aes_process(&params))\n\t\t\treturn -1;\n\t} else {\n\t\tmemset(cmac, 0, AT91_AES_BLOCK_SIZE_BYTE);\n\t}\n\n\t/* Process the last block */\n\toffset = (num_blocks-1) * AT91_AES_BLOCK_SIZE_WORD;\n\tfor (i = 0; i < AT91_AES_BLOCK_SIZE_WORD; ++i)\n\t\tlast_input[i] = input[offset + i] ^ cmac[i] ^ subkey[i];\n\n\tparams.operation = AT91_AES_OP_ENCRYPT;\n\tparams.mode = AT91_AES_MODE_ECB;\n\tparams.data_length = AT91_AES_BLOCK_SIZE_BYTE;\n\tparams.input = last_input;\n\tparams.output = cmac;\n\treturn at91_aes_process(&params);\n}\n- AT91_AES_BLOCK_SIZE_WORD: #define AT91_AES_BLOCK_SIZE_WORD\t4 /* <=== include/aes.h:32:32:AT91_AES_BLOCK_SIZE_WORD:0 */ \n- at91_aes_process: static int at91_aes_process(const at91_aes_params_t *params) /* <=== at91_aes_process */ \n{\n\tunsigned int data_width, chunk_size;\n\tunsigned int block_size, num_blocks;\n\tunsigned int is_mac = (params->operation == AT91_AES_OP_MAC);\n\n\t/* Reset AES */\n\taes_writel(AES_CR, AES_CR_SWRST);\n\n\tif (at91_aes_set_opmode(params->operation, params->mode,\n\t\t\t\tparams->key_size, &data_width, &chunk_size))\n\t\treturn -1;\n\n\tif (at91_aes_set_key(params->key_size, params->key))\n\t\treturn -1;\n\n\tif (params->mode != AT91_AES_MODE_ECB)\n\t\tat91_aes_set_iv(params->iv);\n\n\n\taes_writel(AES_IER, AES_INT_DATRDY);\n\n\tblock_size = data_width * chunk_size;\n\tnum_blocks = at91_aes_length2blocks(params->data_length, block_size);\n\tat91_aes_compute_pio(data_width, chunk_size, num_blocks,\n\t\t\t     is_mac, params->input, params->output);\n\n\tif (is_mac) {\n\t\tunsigned int reg, i;\n\n\t\treg = AES_ODATAR0;\n\t\tfor (i = 0; i < AT91_AES_BLOCK_SIZE_WORD; ++i, reg += 4)\n\t\t\t((unsigned int *)params->output)[i] = aes_readl(reg);\n\t}\n\n\treturn 0;\n}\n- memcmp: extern int memcmp(const void *dst, const void *src, unsigned int cnt); /* <=== memcmp */ \n\nType Definitions:\n- at91_aes_key_size_t: typedef enum at91_aes_key_size {\n\tAT91_AES_KEY_SIZE_128,\n\tAT91_AES_KEY_SIZE_192,\n\tAT91_AES_KEY_SIZE_256\n} at91_aes_key_size_t;\n\nImports:\n- #include \"aes.h\"\n- #include \"debug.h\"\n- #include \"secure.h\"\n- #include \"autoconf.h\"\n- #include \"common.h\"\n- #include \"string.h\"",
    "commit_msg": "driver: secure: use consttime_memequal for memory comparison\n\nDo  not  use memcmp() to compare security critical data, such as\ncryptographic secrets, because the required CPU time depends on the\nnumber of equal bytes.\nInstead, a function that performs comparisons in constant time is required.\nWarning: consttime_memequal returns 0 if data are NOT equal, and 1 if they are\nequal.\n\nSigned-off-by: Eugen Hristev <eugen.hristev@microchip.com>\nReviewed-by: Nicolas Ferre <nicolas.ferre@microchip.com>",
    "cve_desc": "[{'lang': 'en', 'value': 'A timing side channel was discovered in AT91bootstrap before 3.9.2. It can be exploited by attackers with physical access to forge CMAC values and subsequently boot arbitrary code on an affected system.'}]",
    "year": 2020,
    "filename": "secure.c",
    "commit_url": "\"https://github.com/linux4sam/at91bootstrap/commit/7753914c9a622c245f3a3cf2af5e24b6a9904213\""
  },
  {
    "repository": "openresty/lua-nginx-module",
    "cve_id": "CVE-2020-11724",
    "cwe_list": [
      "CWE-444"
    ],
    "commit_hash": "9ab38e8ee35fc08a57636b1b6190dca70b0076fa",
    "short_hash": "9ab38e8e",
    "vulnerableMethods_before": [
      {
        "filename": "src/ngx_http_lua_subrequest.c",
        "method_name": "ngx_http_lua_adjust_subrequest",
        "raw_code": "static ngx_int_t /* <=== ngx_http_lua_adjust_subrequest */ \nngx_http_lua_adjust_subrequest(ngx_http_request_t *sr, ngx_uint_t method,\n    int always_forward_body, ngx_http_request_body_t *body,\n    unsigned vars_action, ngx_array_t *extra_vars)\n{\n    ngx_http_request_t          *r;\n    ngx_int_t                    rc;\n    ngx_http_core_main_conf_t   *cmcf;\n    size_t                       size;\n\n    r = sr->parent;\n\n    sr->header_in = r->header_in;\n\n    if (body) {\n        sr->request_body = body;\n\n        rc = ngx_http_lua_set_content_length_header(sr,\n                                                    body->buf\n                                                    ? ngx_buf_size(body->buf)\n                                                    : 0);\n\n        if (rc != NGX_OK) {\n            return NGX_ERROR;\n        }\n\n    } else if (!always_forward_body\n               && method != NGX_HTTP_PUT\n               && method != NGX_HTTP_POST\n               && r->headers_in.content_length_n > 0)\n    {\n        rc = ngx_http_lua_set_content_length_header(sr, 0);\n        if (rc != NGX_OK) {\n            return NGX_ERROR;\n        }\n\n#if 1\n        sr->request_body = NULL;\n#endif\n\n    } else {\n        if (ngx_http_lua_copy_request_headers(sr, r) != NGX_OK) {\n            return NGX_ERROR;\n        }\n\n        if (sr->request_body) {\n\n            /* deep-copy the request body */\n\n            if (sr->request_body->temp_file) {\n                if (ngx_http_lua_copy_in_file_request_body(sr) != NGX_OK) {\n                    return NGX_ERROR;\n                }\n            }\n        }\n    }\n\n    sr->method = method;\n\n    switch (method) {\n        case NGX_HTTP_GET:\n            sr->method_name = ngx_http_lua_get_method;\n            break;\n\n        case NGX_HTTP_POST:\n            sr->method_name = ngx_http_lua_post_method;\n            break;\n\n        case NGX_HTTP_PUT:\n            sr->method_name = ngx_http_lua_put_method;\n            break;\n\n        case NGX_HTTP_HEAD:\n            sr->method_name = ngx_http_lua_head_method;\n            break;\n\n        case NGX_HTTP_DELETE:\n            sr->method_name = ngx_http_lua_delete_method;\n            break;\n\n        case NGX_HTTP_OPTIONS:\n            sr->method_name = ngx_http_lua_options_method;\n            break;\n\n        case NGX_HTTP_MKCOL:\n            sr->method_name = ngx_http_lua_mkcol_method;\n            break;\n\n        case NGX_HTTP_COPY:\n            sr->method_name = ngx_http_lua_copy_method;\n            break;\n\n        case NGX_HTTP_MOVE:\n            sr->method_name = ngx_http_lua_move_method;\n            break;\n\n        case NGX_HTTP_PROPFIND:\n            sr->method_name = ngx_http_lua_propfind_method;\n            break;\n\n        case NGX_HTTP_PROPPATCH:\n            sr->method_name = ngx_http_lua_proppatch_method;\n            break;\n\n        case NGX_HTTP_LOCK:\n            sr->method_name = ngx_http_lua_lock_method;\n            break;\n\n        case NGX_HTTP_UNLOCK:\n            sr->method_name = ngx_http_lua_unlock_method;\n            break;\n\n        case NGX_HTTP_PATCH:\n            sr->method_name = ngx_http_lua_patch_method;\n            break;\n\n        case NGX_HTTP_TRACE:\n            sr->method_name = ngx_http_lua_trace_method;\n            break;\n\n        default:\n            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                          \"unsupported HTTP method: %u\", (unsigned) method);\n\n            return NGX_ERROR;\n    }\n\n    if (!(vars_action & NGX_HTTP_LUA_SHARE_ALL_VARS)) {\n        /* we do not inherit the parent request's variables */\n        cmcf = ngx_http_get_module_main_conf(sr, ngx_http_core_module);\n\n        size = cmcf->variables.nelts * sizeof(ngx_http_variable_value_t);\n\n        if (vars_action & NGX_HTTP_LUA_COPY_ALL_VARS) {\n\n            sr->variables = ngx_palloc(sr->pool, size);\n            if (sr->variables == NULL) {\n                return NGX_ERROR;\n            }\n\n            ngx_memcpy(sr->variables, r->variables, size);\n\n        } else {\n\n            /* we do not inherit the parent request's variables */\n\n            sr->variables = ngx_pcalloc(sr->pool, size);\n            if (sr->variables == NULL) {\n                return NGX_ERROR;\n            }\n        }\n    }\n\n    return ngx_http_lua_subrequest_add_extra_vars(sr, extra_vars);\n}",
        "start_line": 631
      },
      {
        "filename": "src/ngx_http_lua_subrequest.c",
        "method_name": "ngx_http_lua_set_content_length_header",
        "raw_code": "static ngx_int_t /* <=== ngx_http_lua_set_content_length_header */ \nngx_http_lua_set_content_length_header(ngx_http_request_t *r, off_t len)\n{\n    ngx_table_elt_t                 *h, *header;\n    u_char                          *p;\n    ngx_list_part_t                 *part;\n    ngx_http_request_t              *pr;\n    ngx_uint_t                       i;\n\n    r->headers_in.content_length_n = len;\n\n    if (ngx_list_init(&r->headers_in.headers, r->pool, 20,\n                      sizeof(ngx_table_elt_t)) != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n\n    h = ngx_list_push(&r->headers_in.headers);\n    if (h == NULL) {\n        return NGX_ERROR;\n    }\n\n    h->key = ngx_http_lua_content_length_header_key;\n    h->lowcase_key = ngx_pnalloc(r->pool, h->key.len);\n    if (h->lowcase_key == NULL) {\n        return NGX_ERROR;\n    }\n\n    ngx_strlow(h->lowcase_key, h->key.data, h->key.len);\n\n    r->headers_in.content_length = h;\n\n    p = ngx_palloc(r->pool, NGX_OFF_T_LEN);\n    if (p == NULL) {\n        return NGX_ERROR;\n    }\n\n    h->value.data = p;\n\n    h->value.len = ngx_sprintf(h->value.data, \"%O\", len) - h->value.data;\n\n    h->hash = ngx_http_lua_content_length_hash;\n\n#if 0\n    dd(\"content length hash: %lu == %lu\", (unsigned long) h->hash,\n       ngx_hash_key_lc((u_char *) \"Content-Length\",\n                       sizeof(\"Content-Length\") - 1));\n#endif\n\n    dd(\"r content length: %.*s\",\n       (int) r->headers_in.content_length->value.len,\n       r->headers_in.content_length->value.data);\n\n    pr = r->parent;\n\n    if (pr == NULL) {\n        return NGX_OK;\n    }\n\n    /* forward the parent request's all other request headers */\n\n    part = &pr->headers_in.headers.part;\n    header = part->elts;\n\n    for (i = 0; /* void */; i++) {\n\n        if (i >= part->nelts) {\n            if (part->next == NULL) {\n                break;\n            }\n\n            part = part->next;\n            header = part->elts;\n            i = 0;\n        }\n\n        if (header[i].key.len == sizeof(\"Content-Length\") - 1\n            && ngx_strncasecmp(header[i].key.data, (u_char *) \"Content-Length\",\n                               sizeof(\"Content-Length\") - 1) == 0)\n        {\n            continue;\n        }\n\n        if (ngx_http_lua_set_input_header(r, header[i].key,\n                                          header[i].value, 0) == NGX_ERROR)\n        {\n            return NGX_ERROR;\n        }\n    }\n\n    return NGX_OK;\n}",
        "start_line": 1137
      },
      {
        "filename": "src/ngx_http_lua_subrequest.c",
        "method_name": "ngx_http_lua_copy_request_headers",
        "raw_code": "static ngx_int_t /* <=== ngx_http_lua_copy_request_headers */ \nngx_http_lua_copy_request_headers(ngx_http_request_t *sr, ngx_http_request_t *r)\n{\n    ngx_table_elt_t                 *header;\n    ngx_list_part_t                 *part;\n    ngx_uint_t                       i;\n\n    if (ngx_list_init(&sr->headers_in.headers, sr->pool, 20,\n                      sizeof(ngx_table_elt_t)) != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n\n    dd(\"before: parent req headers count: %d\",\n       (int) r->headers_in.headers.part.nelts);\n\n    part = &r->headers_in.headers.part;\n    header = part->elts;\n\n    for (i = 0; /* void */; i++) {\n\n        if (i >= part->nelts) {\n            if (part->next == NULL) {\n                break;\n            }\n\n            part = part->next;\n            header = part->elts;\n            i = 0;\n        }\n\n        dd(\"setting request header %.*s: %.*s\", (int) header[i].key.len,\n           header[i].key.data, (int) header[i].value.len,\n           header[i].value.data);\n\n        if (ngx_http_lua_set_input_header(sr, header[i].key,\n                                          header[i].value, 0) == NGX_ERROR)\n        {\n            return NGX_ERROR;\n        }\n    }\n\n    dd(\"after: parent req headers count: %d\",\n       (int) r->headers_in.headers.part.nelts);\n\n    return NGX_OK;\n}",
        "start_line": 1744
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "src/ngx_http_lua_subrequest.c",
        "method_name": "ngx_http_lua_adjust_subrequest",
        "raw_code": "static ngx_int_t /* <=== ngx_http_lua_adjust_subrequest */ \nngx_http_lua_adjust_subrequest(ngx_http_request_t *sr, ngx_uint_t method,\n    int always_forward_body, ngx_http_request_body_t *body,\n    unsigned vars_action, ngx_array_t *extra_vars)\n{\n    ngx_http_request_t          *r;\n    ngx_http_core_main_conf_t   *cmcf;\n    int                          pr_not_chunked = 0;\n    size_t                       size;\n\n    r = sr->parent;\n\n    sr->header_in = r->header_in;\n\n    if (body) {\n        sr->request_body = body;\n\n    } else if (!always_forward_body\n               && method != NGX_HTTP_PUT\n               && method != NGX_HTTP_POST\n               && r->headers_in.content_length_n > 0)\n    {\n        sr->request_body = NULL;\n\n    } else {\n        if (!r->headers_in.chunked) {\n            pr_not_chunked = 1;\n        }\n\n        if (sr->request_body && sr->request_body->temp_file) {\n\n            /* deep-copy the request body */\n\n            if (ngx_http_lua_copy_in_file_request_body(sr) != NGX_OK) {\n                return NGX_ERROR;\n            }\n        }\n    }\n\n    if (ngx_http_lua_copy_request_headers(sr, r, pr_not_chunked) != NGX_OK) {\n        return NGX_ERROR;\n    }\n\n    sr->method = method;\n\n    switch (method) {\n        case NGX_HTTP_GET:\n            sr->method_name = ngx_http_lua_get_method;\n            break;\n\n        case NGX_HTTP_POST:\n            sr->method_name = ngx_http_lua_post_method;\n            break;\n\n        case NGX_HTTP_PUT:\n            sr->method_name = ngx_http_lua_put_method;\n            break;\n\n        case NGX_HTTP_HEAD:\n            sr->method_name = ngx_http_lua_head_method;\n            break;\n\n        case NGX_HTTP_DELETE:\n            sr->method_name = ngx_http_lua_delete_method;\n            break;\n\n        case NGX_HTTP_OPTIONS:\n            sr->method_name = ngx_http_lua_options_method;\n            break;\n\n        case NGX_HTTP_MKCOL:\n            sr->method_name = ngx_http_lua_mkcol_method;\n            break;\n\n        case NGX_HTTP_COPY:\n            sr->method_name = ngx_http_lua_copy_method;\n            break;\n\n        case NGX_HTTP_MOVE:\n            sr->method_name = ngx_http_lua_move_method;\n            break;\n\n        case NGX_HTTP_PROPFIND:\n            sr->method_name = ngx_http_lua_propfind_method;\n            break;\n\n        case NGX_HTTP_PROPPATCH:\n            sr->method_name = ngx_http_lua_proppatch_method;\n            break;\n\n        case NGX_HTTP_LOCK:\n            sr->method_name = ngx_http_lua_lock_method;\n            break;\n\n        case NGX_HTTP_UNLOCK:\n            sr->method_name = ngx_http_lua_unlock_method;\n            break;\n\n        case NGX_HTTP_PATCH:\n            sr->method_name = ngx_http_lua_patch_method;\n            break;\n\n        case NGX_HTTP_TRACE:\n            sr->method_name = ngx_http_lua_trace_method;\n            break;\n\n        default:\n            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                          \"unsupported HTTP method: %u\", (unsigned) method);\n\n            return NGX_ERROR;\n    }\n\n    if (!(vars_action & NGX_HTTP_LUA_SHARE_ALL_VARS)) {\n        /* we do not inherit the parent request's variables */\n        cmcf = ngx_http_get_module_main_conf(sr, ngx_http_core_module);\n\n        size = cmcf->variables.nelts * sizeof(ngx_http_variable_value_t);\n\n        if (vars_action & NGX_HTTP_LUA_COPY_ALL_VARS) {\n\n            sr->variables = ngx_palloc(sr->pool, size);\n            if (sr->variables == NULL) {\n                return NGX_ERROR;\n            }\n\n            ngx_memcpy(sr->variables, r->variables, size);\n\n        } else {\n\n            /* we do not inherit the parent request's variables */\n\n            sr->variables = ngx_pcalloc(sr->pool, size);\n            if (sr->variables == NULL) {\n                return NGX_ERROR;\n            }\n        }\n    }\n\n    return ngx_http_lua_subrequest_add_extra_vars(sr, extra_vars);\n}",
        "start_line": 629
      },
      {
        "filename": "src/ngx_http_lua_subrequest.c",
        "method_name": "ngx_http_lua_copy_request_headers",
        "raw_code": "static ngx_int_t /* <=== ngx_http_lua_copy_request_headers */ \nngx_http_lua_copy_request_headers(ngx_http_request_t *sr,\n    ngx_http_request_t *pr, int pr_not_chunked)\n{\n    ngx_table_elt_t                 *clh, *header;\n    ngx_list_part_t                 *part;\n    ngx_uint_t                       i;\n    u_char                          *p;\n    off_t                            len;\n\n    dd(\"before: parent req headers count: %d\",\n       (int) pr->headers_in.headers.part.nelts);\n\n    if (ngx_list_init(&sr->headers_in.headers, sr->pool, 20,\n                      sizeof(ngx_table_elt_t)) != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n\n    if (sr->request_body && !pr_not_chunked) {\n\n        /* craft our own Content-Length */\n\n        len = sr->request_body->buf ? ngx_buf_size(sr->request_body->buf) : 0;\n\n        clh = ngx_list_push(&sr->headers_in.headers);\n        if (clh == NULL) {\n            return NGX_ERROR;\n        }\n\n        clh->hash = ngx_http_lua_content_length_hash;\n        clh->key = ngx_http_lua_content_length_header_key;\n        clh->lowcase_key = ngx_pnalloc(sr->pool, clh->key.len);\n        if (clh->lowcase_key == NULL) {\n            return NGX_ERROR;\n        }\n\n        ngx_strlow(clh->lowcase_key, clh->key.data, clh->key.len);\n\n        p = ngx_palloc(sr->pool, NGX_OFF_T_LEN);\n        if (p == NULL) {\n            return NGX_ERROR;\n        }\n\n        clh->value.data = p;\n        clh->value.len = ngx_sprintf(clh->value.data, \"%O\", len)\n                         - clh->value.data;\n\n        sr->headers_in.content_length = clh;\n        sr->headers_in.content_length_n = len;\n\n        dd(\"sr crafted content-length: %.*s\",\n           (int) sr->headers_in.content_length->value.len,\n           sr->headers_in.content_length->value.data);\n    }\n\n    /* copy the parent request's headers */\n\n    part = &pr->headers_in.headers.part;\n    header = part->elts;\n\n    for (i = 0; /* void */; i++) {\n\n        if (i >= part->nelts) {\n            if (part->next == NULL) {\n                break;\n            }\n\n            part = part->next;\n            header = part->elts;\n            i = 0;\n        }\n\n        if (!pr_not_chunked && header[i].key.len == sizeof(\"Content-Length\") - 1\n            && ngx_strncasecmp(header[i].key.data, (u_char *) \"Content-Length\",\n                               sizeof(\"Content-Length\") - 1) == 0)\n        {\n            continue;\n        }\n\n        dd(\"sr copied req header %.*s: %.*s\", (int) header[i].key.len,\n           header[i].key.data, (int) header[i].value.len,\n           header[i].value.data);\n\n        if (ngx_http_lua_set_input_header(sr, header[i].key,\n                                          header[i].value, 0) == NGX_ERROR)\n        {\n            return NGX_ERROR;\n        }\n    }\n\n    dd(\"after: parent req headers count: %d\",\n       (int) pr->headers_in.headers.part.nelts);\n\n    return NGX_OK;\n}",
        "start_line": 1634
      }
    ],
    "code_context": "Called Methods:\n- ngx_http_lua_set_input_header: ngx_int_t /* <=== ngx_http_lua_set_input_header */ \nngx_http_lua_set_input_header(ngx_http_request_t *r, ngx_str_t key,\n    ngx_str_t value, unsigned override)\n{\n    ngx_http_lua_header_val_t         hv;\n    ngx_http_lua_set_header_t        *handlers = ngx_http_lua_set_handlers;\n    ngx_int_t                         rc;\n    ngx_uint_t                        i;\n\n    dd(\"set header value: %.*s\", (int) value.len, value.data);\n\n    rc = ngx_http_lua_copy_escaped_header(r, &key, 1);\n    if (rc != NGX_OK) {\n        return NGX_ERROR;\n    }\n\n    rc = ngx_http_lua_copy_escaped_header(r, &value, 0);\n    if (rc != NGX_OK) {\n        return NGX_ERROR;\n    }\n\n    hv.hash = ngx_hash_key_lc(key.data, key.len);\n    hv.key = key;\n\n    hv.offset = 0;\n    hv.no_override = !override;\n    hv.handler = NULL;\n\n    for (i = 0; handlers[i].name.len; i++) {\n        if (hv.key.len != handlers[i].name.len\n            || ngx_strncasecmp(hv.key.data, handlers[i].name.data,\n                               handlers[i].name.len) != 0)\n        {\n            dd(\"hv key comparison: %s <> %s\", handlers[i].name.data,\n               hv.key.data);\n\n            continue;\n        }\n\n        dd(\"Matched handler: %s %s\", handlers[i].name.data, hv.key.data);\n\n        hv.offset = handlers[i].offset;\n        hv.handler = handlers[i].handler;\n\n        break;\n    }\n\n    if (handlers[i].name.len == 0 && handlers[i].handler) {\n        hv.offset = handlers[i].offset;\n        hv.handler = handlers[i].handler;\n    }\n\n#if 1\n    if (hv.handler == NULL) {\n        return NGX_ERROR;\n    }\n#endif\n\n    if (r->headers_out.status == 400 || r->headers_in.headers.last == NULL) {\n        /* must be a 400 Bad Request */\n        return NGX_OK;\n    }\n\n    return hv.handler(r, &hv, &value);\n}\n- ngx_http_lua_subrequest_add_extra_vars: static ngx_int_t /* <=== ngx_http_lua_subrequest_add_extra_vars */ \nngx_http_lua_subrequest_add_extra_vars(ngx_http_request_t *sr,\n    ngx_array_t *extra_vars)\n{\n    ngx_http_core_main_conf_t   *cmcf;\n    ngx_http_variable_t         *v;\n    ngx_http_variable_value_t   *vv;\n    u_char                      *val;\n    u_char                      *p;\n    ngx_uint_t                   i, hash;\n    ngx_str_t                    name;\n    size_t                       len;\n    ngx_hash_t                  *variables_hash;\n    ngx_keyval_t                *var;\n\n    /* set any extra variables that were passed to the subrequest */\n\n    if (extra_vars == NULL || extra_vars->nelts == 0) {\n        return NGX_OK;\n    }\n\n    cmcf = ngx_http_get_module_main_conf(sr, ngx_http_core_module);\n\n    variables_hash = &cmcf->variables_hash;\n\n    var = extra_vars->elts;\n\n    for (i = 0; i < extra_vars->nelts; i++, var++) {\n        /* copy the variable's name and value because they are allocated\n         * by the lua VM */\n\n        len = var->key.len + var->value.len;\n\n        p = ngx_pnalloc(sr->pool, len);\n        if (p == NULL) {\n            return NGX_ERROR;\n        }\n\n        name.data = p;\n        name.len = var->key.len;\n\n        p = ngx_copy(p, var->key.data, var->key.len);\n\n        hash = ngx_hash_strlow(name.data, name.data, name.len);\n\n        val = p;\n        len = var->value.len;\n\n        ngx_memcpy(p, var->value.data, len);\n\n        v = ngx_hash_find(variables_hash, hash, name.data, name.len);\n\n        if (v) {\n            if (!(v->flags & NGX_HTTP_VAR_CHANGEABLE)) {\n                ngx_log_error(NGX_LOG_ERR, sr->connection->log, 0,\n                              \"variable \\\"%V\\\" not changeable\", &name);\n                return NGX_HTTP_INTERNAL_SERVER_ERROR;\n            }\n\n            if (v->set_handler) {\n                vv = ngx_palloc(sr->pool, sizeof(ngx_http_variable_value_t));\n                if (vv == NULL) {\n                    return NGX_ERROR;\n                }\n\n                vv->valid = 1;\n                vv->not_found = 0;\n                vv->no_cacheable = 0;\n\n                vv->data = val;\n                vv->len = len;\n\n                v->set_handler(sr, vv, v->data);\n\n                ngx_log_debug2(NGX_LOG_DEBUG_HTTP, sr->connection->log, 0,\n                               \"variable \\\"%V\\\" set to value \\\"%v\\\"\", &name,\n                               vv);\n\n                continue;\n            }\n\n            if (v->flags & NGX_HTTP_VAR_INDEXED) {\n                vv = &sr->variables[v->index];\n\n                vv->valid = 1;\n                vv->not_found = 0;\n                vv->no_cacheable = 0;\n\n                vv->data = val;\n                vv->len = len;\n\n                ngx_log_debug2(NGX_LOG_DEBUG_HTTP, sr->connection->log, 0,\n                               \"variable \\\"%V\\\" set to value \\\"%v\\\"\",\n                               &name, vv);\n\n                continue;\n            }\n        }\n\n        ngx_log_error(NGX_LOG_ERR, sr->connection->log, 0,\n                      \"variable \\\"%V\\\" cannot be assigned a value (maybe you \"\n                      \"forgot to define it first?) \", &name);\n\n        return NGX_ERROR;\n    }\n\n    return NGX_OK;\n}\n- ngx_http_lua_copy_escaped_header: ngx_int_t /* <=== ngx_http_lua_copy_escaped_header */ \nngx_http_lua_copy_escaped_header(ngx_http_request_t *r,\n    ngx_str_t *dst, int is_name)\n{\n    size_t       escape;\n    size_t       len;\n    u_char      *data;\n    int          type;\n\n    type = is_name\n        ? NGX_HTTP_LUA_ESCAPE_HEADER_NAME : NGX_HTTP_LUA_ESCAPE_HEADER_VALUE;\n\n    data = dst->data;\n    len = dst->len;\n\n    escape = ngx_http_lua_escape_uri(NULL, data, len, type);\n    if (escape > 0) {\n        /*\n         * we allocate space for the trailling '\\0' char here because nginx\n         * header values must be null-terminated\n         */\n        dst->data = ngx_palloc(r->pool, len + 2 * escape + 1);\n        if (dst->data == NULL) {\n            return NGX_ERROR;\n        }\n\n        ngx_http_lua_escape_uri(dst->data, data, len, type);\n        dst->len = len + 2 * escape;\n        dst->data[dst->len] = '\\0';\n    }\n\n    return NGX_OK;\n}\n- ngx_http_lua_copy_in_file_request_body: static ngx_int_t /* <=== ngx_http_lua_copy_in_file_request_body */ \nngx_http_lua_copy_in_file_request_body(ngx_http_request_t *r)\n{\n    ngx_temp_file_t     *tf;\n\n    ngx_http_request_body_t   *body;\n\n    tf = r->request_body->temp_file;\n\n    if (!tf->persistent || !tf->clean) {\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                      \"the request body was not read by ngx_lua\");\n\n        return NGX_ERROR;\n    }\n\n    body = ngx_palloc(r->pool, sizeof(ngx_http_request_body_t));\n    if (body == NULL) {\n        return NGX_ERROR;\n    }\n\n    ngx_memcpy(body, r->request_body, sizeof(ngx_http_request_body_t));\n\n    body->temp_file = ngx_palloc(r->pool, sizeof(ngx_temp_file_t));\n    if (body->temp_file == NULL) {\n        return NGX_ERROR;\n    }\n\n    ngx_memcpy(body->temp_file, tf, sizeof(ngx_temp_file_t));\n    dd(\"file fd: %d\", body->temp_file->file.fd);\n\n    r->request_body = body;\n\n    return NGX_OK;\n}\n- NGX_HTTP_LUA_COPY_ALL_VARS: #define NGX_HTTP_LUA_COPY_ALL_VARS      0x02 /* <=== src/ngx_http_lua_subrequest.c:25:25:NGX_HTTP_LUA_COPY_ALL_VARS:0 */ \n- NGX_HTTP_LUA_SHARE_ALL_VARS: #define NGX_HTTP_LUA_SHARE_ALL_VARS     0x01 /* <=== src/ngx_http_lua_subrequest.c:24:24:NGX_HTTP_LUA_SHARE_ALL_VARS:0 */ \n\nGlobal Variables:\n- ngx_str_t ngx_http_lua_trace_method\n- ngx_str_t ngx_http_lua_unlock_method\n- ngx_str_t ngx_http_lua_head_method\n- ngx_str_t ngx_http_lua_get_method\n- ngx_str_t ngx_http_lua_proppatch_method\n- ngx_str_t ngx_http_lua_copy_method\n- ngx_str_t ngx_http_lua_mkcol_method\n- ngx_str_t ngx_http_lua_options_method\n- ngx_str_t ngx_http_lua_delete_method\n- ngx_str_t ngx_http_lua_content_length_header_key\n- ngx_str_t ngx_http_lua_patch_method\n- ngx_str_t ngx_http_lua_post_method\n- ngx_str_t ngx_http_lua_put_method\n- ngx_str_t ngx_http_lua_move_method\n- ngx_str_t ngx_http_lua_propfind_method\n- ngx_str_t ngx_http_lua_lock_method\n\nImports:\n- #include \"ngx_http_lua_subrequest.h\"\n- #include \"ngx_http_lua_util.h\"\n- #include \"ngx_http_lua_contentby.h\"\n- #include \"ngx_http_lua_ctx.h\"\n- #include \"ngx_http_lua_headers_in.h\"\n- #include \"ngx_http_probe.h\"\n- #include \"ddebug.h\"",
    "commit_msg": "bugfix: prevented request smuggling in the ngx.location.capture API.\n\nSigned-off-by: Yichun Zhang (agentzh) <yichun@openresty.com>",
    "cve_desc": "An issue was discovered in OpenResty before 1.15.8.4. ngx_http_lua_subrequest.c allows HTTP request smuggling, as demonstrated by the ngx.location.capture API.",
    "year": 2020,
    "filename": "",
    "commit_url": "https://github.com/openresty/lua-nginx-module/commit/9ab38e8ee35fc08a57636b1b6190dca70b0076fa"
  },
  {
    "repository": "ArtifexSoftware/jbig2dec",
    "cve_id": "CVE-2020-12268",
    "cwe_list": [
      "CWE-787"
    ],
    "commit_hash": "0726320a4b55078e9d8deb590e477d598b3da66e",
    "short_hash": "0726320a",
    "vulnerableMethods_before": [
      {
        "filename": "jbig2_image.c",
        "method_name": "jbig2_image_compose",
        "raw_code": "int /* <=== jbig2_image_compose */ \njbig2_image_compose(Jbig2Ctx *ctx, Jbig2Image *dst, Jbig2Image *src, int x, int y, Jbig2ComposeOp op)\n{\n    uint32_t w, h;\n    uint32_t shift;\n    uint32_t leftbyte;\n    uint8_t *ss;\n    uint8_t *dd;\n    uint8_t leftmask, rightmask;\n    int early = x >= 0;\n    int late;\n    uint32_t bytewidth;\n    uint32_t syoffset = 0;\n\n    if (src == NULL)\n        return 0;\n\n    /* This code takes a src image and combines it onto dst at offset (x,y), with operation op. */\n\n    /* Data is packed msb first within a byte, so with bits numbered: 01234567.\n     * Second byte is: 89abcdef. So to combine into a run, we use:\n     *       (s[0]<<8) | s[1] == 0123456789abcdef.\n     * To read from src into dst at offset 3, we need to read:\n     *    read:      0123456789abcdef...\n     *    write:  0123456798abcdef...\n     * In general, to read from src and write into dst at offset x, we need to shift\n     * down by (x&7) bits to allow for bit alignment. So shift = x&7.\n     * So the 'central' part of our runs will see us doing:\n     *   *d++ op= ((s[0]<<8)|s[1])>>shift;\n     * with special cases on the left and right edges of the run to mask.\n     * With the left hand edge, we have to be careful not to 'underread' the start of\n     * the src image; this is what the early flag is about. Similarly we have to be\n     * careful not to read off the right hand edge; this is what the late flag is for.\n     */\n\n    /* clip */\n    w = src->width;\n    h = src->height;\n    shift = (x & 7);\n    ss = src->data - early;\n\n    if (x < 0) {\n        if (w < (uint32_t) -x)\n            w = 0;\n        else\n            w += x;\n        ss += (-x-1)>>3;\n        x = 0;\n    }\n    if (y < 0) {\n        if (h < (uint32_t) -y)\n            h = 0;\n        else\n            h += y;\n        syoffset = -y * src->stride;\n        y = 0;\n    }\n    if ((uint32_t)x + w > dst->width)\n    {\n        if (dst->width < (uint32_t)x)\n            w = 0;\n        else\n            w = dst->width - x;\n    }\n    if ((uint32_t)y + h > dst->height)\n    {\n        if (dst->height < (uint32_t)y)\n            h = 0;\n        else\n            h = dst->height - y;\n    }\n#ifdef JBIG2_DEBUG\n    jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, \"compositing %dx%d at (%d, %d) after clipping\", w, h, x, y);\n#endif\n\n    /* check for zero clipping region */\n    if ((w <= 0) || (h <= 0)) {\n#ifdef JBIG2_DEBUG\n        jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, \"zero clipping region\");\n#endif\n        return 0;\n    }\n\n    leftbyte = (uint32_t) x >> 3;\n    dd = dst->data + y * dst->stride + leftbyte;\n    bytewidth = (((uint32_t) x + w - 1) >> 3) - leftbyte + 1;\n    leftmask = 255>>(x&7);\n    rightmask = (((x+w)&7) == 0) ? 255 : ~(255>>((x+w)&7));\n    if (bytewidth == 1)\n        leftmask &= rightmask;\n    late = (ss + bytewidth >= src->data + ((src->width+7)>>3));\n    ss += syoffset;\n\n    switch(op)\n    {\n    case JBIG2_COMPOSE_OR:\n        jbig2_image_compose_opt_OR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    case JBIG2_COMPOSE_AND:\n        jbig2_image_compose_opt_AND(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    case JBIG2_COMPOSE_XOR:\n        jbig2_image_compose_opt_XOR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    case JBIG2_COMPOSE_XNOR:\n        jbig2_image_compose_opt_XNOR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    case JBIG2_COMPOSE_REPLACE:\n        jbig2_image_compose_opt_REPLACE(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    }\n\n    return 0;\n}",
        "start_line": 337
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "jbig2_image.c",
        "method_name": "jbig2_image_compose",
        "raw_code": "int /* <=== jbig2_image_compose */ \njbig2_image_compose(Jbig2Ctx *ctx, Jbig2Image *dst, Jbig2Image *src, int x, int y, Jbig2ComposeOp op)\n{\n    uint32_t w, h;\n    uint32_t shift;\n    uint32_t leftbyte;\n    uint8_t *ss;\n    uint8_t *dd;\n    uint8_t leftmask, rightmask;\n    int early = x >= 0;\n    int late;\n    uint32_t bytewidth;\n    uint32_t syoffset = 0;\n\n    if (src == NULL)\n        return 0;\n\n    if ((UINT32_MAX - src->width  < (x > 0 ? x : -x)) ||\n        (UINT32_MAX - src->height < (y > 0 ? y : -y)))\n    {\n#ifdef JBIG2_DEBUG\n        jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, \"overflow in compose_image\");\n#endif\n        return 0;\n    }\n\n    /* This code takes a src image and combines it onto dst at offset (x,y), with operation op. */\n\n    /* Data is packed msb first within a byte, so with bits numbered: 01234567.\n     * Second byte is: 89abcdef. So to combine into a run, we use:\n     *       (s[0]<<8) | s[1] == 0123456789abcdef.\n     * To read from src into dst at offset 3, we need to read:\n     *    read:      0123456789abcdef...\n     *    write:  0123456798abcdef...\n     * In general, to read from src and write into dst at offset x, we need to shift\n     * down by (x&7) bits to allow for bit alignment. So shift = x&7.\n     * So the 'central' part of our runs will see us doing:\n     *   *d++ op= ((s[0]<<8)|s[1])>>shift;\n     * with special cases on the left and right edges of the run to mask.\n     * With the left hand edge, we have to be careful not to 'underread' the start of\n     * the src image; this is what the early flag is about. Similarly we have to be\n     * careful not to read off the right hand edge; this is what the late flag is for.\n     */\n\n    /* clip */\n    w = src->width;\n    h = src->height;\n    shift = (x & 7);\n    ss = src->data - early;\n\n    if (x < 0) {\n        if (w < (uint32_t) -x)\n            w = 0;\n        else\n            w += x;\n        ss += (-x-1)>>3;\n        x = 0;\n    }\n    if (y < 0) {\n        if (h < (uint32_t) -y)\n            h = 0;\n        else\n            h += y;\n        syoffset = -y * src->stride;\n        y = 0;\n    }\n    if ((uint32_t)x + w > dst->width)\n    {\n        if (dst->width < (uint32_t)x)\n            w = 0;\n        else\n            w = dst->width - x;\n    }\n    if ((uint32_t)y + h > dst->height)\n    {\n        if (dst->height < (uint32_t)y)\n            h = 0;\n        else\n            h = dst->height - y;\n    }\n#ifdef JBIG2_DEBUG\n    jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, \"compositing %dx%d at (%d, %d) after clipping\", w, h, x, y);\n#endif\n\n    /* check for zero clipping region */\n    if ((w <= 0) || (h <= 0)) {\n#ifdef JBIG2_DEBUG\n        jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, \"zero clipping region\");\n#endif\n        return 0;\n    }\n\n    leftbyte = (uint32_t) x >> 3;\n    dd = dst->data + y * dst->stride + leftbyte;\n    bytewidth = (((uint32_t) x + w - 1) >> 3) - leftbyte + 1;\n    leftmask = 255>>(x&7);\n    rightmask = (((x+w)&7) == 0) ? 255 : ~(255>>((x+w)&7));\n    if (bytewidth == 1)\n        leftmask &= rightmask;\n    late = (ss + bytewidth >= src->data + ((src->width+7)>>3));\n    ss += syoffset;\n\n    switch(op)\n    {\n    case JBIG2_COMPOSE_OR:\n        jbig2_image_compose_opt_OR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    case JBIG2_COMPOSE_AND:\n        jbig2_image_compose_opt_AND(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    case JBIG2_COMPOSE_XOR:\n        jbig2_image_compose_opt_XOR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    case JBIG2_COMPOSE_XNOR:\n        jbig2_image_compose_opt_XNOR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    case JBIG2_COMPOSE_REPLACE:\n        jbig2_image_compose_opt_REPLACE(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    }\n\n    return 0;\n}",
        "start_line": 340
      }
    ],
    "code_context": "Called Methods:\n- jbig2_image_compose_opt_XNOR: static void /* <=== jbig2_image_compose_opt_XNOR */ \njbig2_image_compose_opt_XNOR(const uint8_t *s, uint8_t *d, int early, int late, uint8_t mask, uint8_t rightmask, uint32_t bytewidth, uint32_t h, uint32_t shift, uint32_t dstride, uint32_t sstride)\n{\n    if (early || late)\n        template_image_compose_opt(s, d, early, late, mask, rightmask, bytewidth, h, shift, dstride, sstride, JBIG2_COMPOSE_XNOR);\n    else\n        template_image_compose_opt(s, d, 0, 0, mask, rightmask, bytewidth, h, shift, dstride, sstride, JBIG2_COMPOSE_XNOR);\n}\n- jbig2_image_compose_opt_XOR: static void /* <=== jbig2_image_compose_opt_XOR */ \njbig2_image_compose_opt_XOR(const uint8_t *s, uint8_t *d, int early, int late, uint8_t mask, uint8_t rightmask, uint32_t bytewidth, uint32_t h, uint32_t shift, uint32_t dstride, uint32_t sstride)\n{\n    if (early || late)\n        template_image_compose_opt(s, d, early, late, mask, rightmask, bytewidth, h, shift, dstride, sstride, JBIG2_COMPOSE_XOR);\n    else\n        template_image_compose_opt(s, d, 0, 0, mask, rightmask, bytewidth, h, shift, dstride, sstride, JBIG2_COMPOSE_XOR);\n}\n- template_image_compose_opt: static inline void /* <=== template_image_compose_opt */ \ntemplate_image_compose_opt(const uint8_t * JBIG2_RESTRICT ss, uint8_t * JBIG2_RESTRICT dd, int early, int late, uint8_t leftmask, uint8_t rightmask, uint32_t bytewidth_, uint32_t h, uint32_t shift, uint32_t dstride, uint32_t sstride, Jbig2ComposeOp op)\n{\n    int i;\n    uint32_t j;\n    int bytewidth = (int)bytewidth_;\n\n    if (bytewidth == 1) {\n        for (j = 0; j < h; j++) {\n            /* Only 1 byte! */\n            uint8_t v = (((early ? 0 : ss[0]<<8) | (late ? 0 : ss[1]))>>shift);\n            if (op == JBIG2_COMPOSE_OR)\n                *dd |= v & leftmask;\n            else if (op == JBIG2_COMPOSE_AND)\n                *dd &= (v & leftmask) | ~leftmask;\n            else if (op == JBIG2_COMPOSE_XOR)\n                *dd ^= v & leftmask;\n            else if (op == JBIG2_COMPOSE_XNOR)\n                *dd ^= (~v) & leftmask;\n            else /* Replace */\n                *dd = (v & leftmask) | (*dd & ~leftmask);\n            dd += dstride;\n            ss += sstride;\n        }\n        return;\n    }\n    bytewidth -= 2;\n    if (shift == 0) {\n        ss++;\n        for (j = 0; j < h; j++) {\n            /* Left byte */\n            const uint8_t * JBIG2_RESTRICT s = ss;\n            uint8_t * JBIG2_RESTRICT d = dd;\n            if (op == JBIG2_COMPOSE_OR)\n                *d++ |= *s++ & leftmask;\n            else if (op == JBIG2_COMPOSE_AND)\n                *d++ &= (*s++ & leftmask) | ~leftmask;\n            else if (op == JBIG2_COMPOSE_XOR)\n                *d++ ^= *s++ & leftmask;\n            else if (op == JBIG2_COMPOSE_XNOR)\n                *d++ ^= (~*s++) & leftmask;\n            else /* Replace */\n                *d = (*s++ & leftmask) | (*d & ~leftmask), d++;\n            /* Central run */\n            for (i = bytewidth; i != 0; i--) {\n                if (op == JBIG2_COMPOSE_OR)\n                    *d++ |= *s++;\n                else if (op == JBIG2_COMPOSE_AND)\n                    *d++ &= *s++;\n                else if (op == JBIG2_COMPOSE_XOR)\n                    *d++ ^= *s++;\n                else if (op == JBIG2_COMPOSE_XNOR)\n                    *d++ ^= ~*s++;\n                else /* Replace */\n                    *d++ = *s++;\n            }\n            /* Right byte */\n            if (op == JBIG2_COMPOSE_OR)\n                *d |= *s & rightmask;\n            else if (op == JBIG2_COMPOSE_AND)\n                *d &= (*s & rightmask) | ~rightmask;\n            else if (op == JBIG2_COMPOSE_XOR)\n                *d ^= *s & rightmask;\n            else if (op == JBIG2_COMPOSE_XNOR)\n                *d ^= (~*s) & rightmask;\n            else /* Replace */\n                *d = (*s & rightmask) | (*d & ~rightmask);\n            dd += dstride;\n            ss += sstride;\n        }\n    } else {\n        for (j = 0; j < h; j++) {\n            /* Left byte */\n            const uint8_t * JBIG2_RESTRICT s = ss;\n            uint8_t * JBIG2_RESTRICT d = dd;\n            uint8_t s0, s1, v;\n            s0 = early ? 0 : *s;\n            s++;\n            s1 = *s++;\n            v = ((s0<<8) | s1)>>shift;\n            if (op == JBIG2_COMPOSE_OR)\n                *d++ |= v & leftmask;\n            else if (op == JBIG2_COMPOSE_AND)\n                *d++ &= (v & leftmask) | ~leftmask;\n            else if (op == JBIG2_COMPOSE_XOR)\n                *d++ ^= v & leftmask;\n            else if (op == JBIG2_COMPOSE_XNOR)\n                *d++ ^= (~v) & leftmask;\n            else /* Replace */\n                *d = (v & leftmask) | (*d & ~leftmask), d++;\n            /* Central run */\n            for (i = bytewidth; i > 0; i--) {\n                s0 = s1; s1 = *s++;\n                v = ((s0<<8) | s1)>>shift;\n                if (op == JBIG2_COMPOSE_OR)\n                    *d++ |= v;\n                else if (op == JBIG2_COMPOSE_AND)\n                    *d++ &= v;\n                else if (op == JBIG2_COMPOSE_XOR)\n                    *d++ ^= v;\n                else if (op == JBIG2_COMPOSE_XNOR)\n                    *d++ ^= ~v;\n                else /* Replace */\n                    *d++ = v;\n            }\n            /* Right byte */\n            s0 = s1; s1 = (late ? 0 : *s);\n            v = (((s0<<8) | s1)>>shift);\n            if (op == JBIG2_COMPOSE_OR)\n                *d |= v & rightmask;\n            else if (op == JBIG2_COMPOSE_AND)\n                *d &= (v & rightmask) | ~rightmask;\n            else if (op == JBIG2_COMPOSE_XOR)\n                *d ^= v & rightmask;\n            else if (op == JBIG2_COMPOSE_XNOR)\n                *d ^= ~v & rightmask;\n            else /* Replace */\n                *d = (v & rightmask) | (*d & ~rightmask);\n            dd += dstride;\n            ss += sstride;\n        }\n    }\n}\n- jbig2_image_compose_opt_OR: static void /* <=== jbig2_image_compose_opt_OR */ \njbig2_image_compose_opt_OR(const uint8_t *s, uint8_t *d, int early, int late, uint8_t mask, uint8_t rightmask, uint32_t bytewidth, uint32_t h, uint32_t shift, uint32_t dstride, uint32_t sstride)\n{\n    if (early || late)\n        template_image_compose_opt(s, d, early, late, mask, rightmask, bytewidth, h, shift, dstride, sstride, JBIG2_COMPOSE_OR);\n    else\n        template_image_compose_opt(s, d, 0, 0, mask, rightmask, bytewidth, h, shift, dstride, sstride, JBIG2_COMPOSE_OR);\n}\n- jbig2_image_compose_opt_REPLACE: static void /* <=== jbig2_image_compose_opt_REPLACE */ \njbig2_image_compose_opt_REPLACE(const uint8_t *s, uint8_t *d, int early, int late, uint8_t mask, uint8_t rightmask, uint32_t bytewidth, uint32_t h, uint32_t shift, uint32_t dstride, uint32_t sstride)\n{\n    if (early || late)\n        template_image_compose_opt(s, d, early, late, mask, rightmask, bytewidth, h, shift, dstride, sstride, JBIG2_COMPOSE_REPLACE);\n    else\n        template_image_compose_opt(s, d, 0, 0, mask, rightmask, bytewidth, h, shift, dstride, sstride, JBIG2_COMPOSE_REPLACE);\n}\n- NULL: #define NULL ((void*)0) /* <=== jbig2_priv.h:56:56:NULL:0 */ \n- UINT32_MAX: #define UINT32_MAX  0xffffffffu /* <=== jbig2_image.c:37:37:UINT32_MAX:0 */ \n- jbig2_image_compose_opt_AND: static void /* <=== jbig2_image_compose_opt_AND */ \njbig2_image_compose_opt_AND(const uint8_t *s, uint8_t *d, int early, int late, uint8_t mask, uint8_t rightmask, uint32_t bytewidth, uint32_t h, uint32_t shift, uint32_t dstride, uint32_t sstride)\n{\n    if (early || late)\n        template_image_compose_opt(s, d, early, late, mask, rightmask, bytewidth, h, shift, dstride, sstride, JBIG2_COMPOSE_AND);\n    else\n        template_image_compose_opt(s, d, 0, 0, mask, rightmask, bytewidth, h, shift, dstride, sstride, JBIG2_COMPOSE_AND);\n}\n\nType Definitions:\n- Jbig2Image: typedef struct _Jbig2Image Jbig2Image;\n- Jbig2ComposeOp: typedef enum {\n    JBIG2_COMPOSE_OR = 0,\n    JBIG2_COMPOSE_AND = 1,\n    JBIG2_COMPOSE_XOR = 2,\n    JBIG2_COMPOSE_XNOR = 3,\n    JBIG2_COMPOSE_REPLACE = 4\n}\n\nImports:\n- #include \"jbig2.h\"\n- #include \"jbig2_image.h\"\n- #include \"os_types.h\"\n- #include <string.h>\n- #include \"jbig2_priv.h\"\n- #include <stdio.h>\n- #include \"config.h\"\n- #include <stdlib.h>",
    "commit_msg": "Fix OSS-Fuzz issue 20332: buffer overflow in jbig2_image_compose.\n\nWith extreme values of x/y/w/h we can get overflow. Test for this\nand exit safely.\n\nThanks for OSS-Fuzz for reporting.",
    "cve_desc": "[{'lang': 'en', 'value': 'jbig2_image_compose in jbig2_image.c in Artifex jbig2dec before 0.18 has a heap-based buffer overflow.'}]",
    "year": 2020,
    "filename": "jbig2_image.c",
    "commit_url": "\"https://github.com/ArtifexSoftware/jbig2dec/commit/0726320a4b55078e9d8deb590e477d598b3da66e\""
  },
  {
    "repository": "FFmpeg/FFmpeg",
    "cve_id": "CVE-2020-12284",
    "cwe_list": [
      "CWE-787"
    ],
    "commit_hash": "1812352d767ccf5431aa440123e2e260a4db2726",
    "short_hash": "1812352d",
    "vulnerableMethods_before": [
      {
        "filename": "libavcodec/cbs_jpeg.c",
        "method_name": "cbs_jpeg_split_fragment",
        "raw_code": "static int cbs_jpeg_split_fragment(CodedBitstreamContext *ctx, /* <=== cbs_jpeg_split_fragment */ \n                                   CodedBitstreamFragment *frag,\n                                   int header)\n{\n    AVBufferRef *data_ref;\n    uint8_t *data;\n    size_t data_size;\n    int unit, start, end, marker, next_start, next_marker;\n    int err, i, j, length;\n\n    if (frag->data_size < 4) {\n        // Definitely too short to be meaningful.\n        return AVERROR_INVALIDDATA;\n    }\n\n    for (i = 0; i + 1 < frag->data_size && frag->data[i] != 0xff; i++);\n    if (i > 0) {\n        av_log(ctx->log_ctx, AV_LOG_WARNING, \"Discarding %d bytes at \"\n               \"beginning of image.\\n\", i);\n    }\n    for (++i; i + 1 < frag->data_size && frag->data[i] == 0xff; i++);\n    if (i + 1 >= frag->data_size && frag->data[i]) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n               \"no SOI marker found.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    marker = frag->data[i];\n    if (marker != JPEG_MARKER_SOI) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: first \"\n               \"marker is %02x, should be SOI.\\n\", marker);\n        return AVERROR_INVALIDDATA;\n    }\n    for (++i; i + 1 < frag->data_size && frag->data[i] == 0xff; i++);\n    if (i + 1 >= frag->data_size) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n               \"no image content found.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    marker = frag->data[i];\n    start  = i + 1;\n\n    for (unit = 0;; unit++) {\n        if (marker == JPEG_MARKER_EOI) {\n            break;\n        } else if (marker == JPEG_MARKER_SOS) {\n            for (i = start; i + 1 < frag->data_size; i++) {\n                if (frag->data[i] != 0xff)\n                    continue;\n                end = i;\n                for (++i; i + 1 < frag->data_size &&\n                          frag->data[i] == 0xff; i++);\n                if (i + 1 >= frag->data_size) {\n                    next_marker = -1;\n                } else {\n                    if (frag->data[i] == 0x00)\n                        continue;\n                    next_marker = frag->data[i];\n                    next_start  = i + 1;\n                }\n                break;\n            }\n        } else {\n            i = start;\n            if (i + 2 > frag->data_size) {\n                av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n                       \"truncated at %02x marker.\\n\", marker);\n                return AVERROR_INVALIDDATA;\n            }\n            length = AV_RB16(frag->data + i);\n            if (i + length > frag->data_size) {\n                av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n                       \"truncated at %02x marker segment.\\n\", marker);\n                return AVERROR_INVALIDDATA;\n            }\n            end = start + length;\n\n            i = end;\n            if (frag->data[i] != 0xff) {\n                next_marker = -1;\n            } else {\n                for (++i; i + 1 < frag->data_size &&\n                          frag->data[i] == 0xff; i++);\n                if (i + 1 >= frag->data_size) {\n                    next_marker = -1;\n                } else {\n                    next_marker = frag->data[i];\n                    next_start  = i + 1;\n                }\n            }\n        }\n\n        if (marker == JPEG_MARKER_SOS) {\n            length = AV_RB16(frag->data + start);\n\n            data_ref = NULL;\n            data     = av_malloc(end - start +\n                                 AV_INPUT_BUFFER_PADDING_SIZE);\n            if (!data)\n                return AVERROR(ENOMEM);\n\n            memcpy(data, frag->data + start, length);\n            for (i = start + length, j = length; i < end; i++, j++) {\n                if (frag->data[i] == 0xff) {\n                    while (frag->data[i] == 0xff)\n                        ++i;\n                    data[j] = 0xff;\n                } else {\n                    data[j] = frag->data[i];\n                }\n            }\n            data_size = j;\n\n            memset(data + data_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n\n        } else {\n            data      = frag->data + start;\n            data_size = end - start;\n            data_ref  = frag->data_ref;\n        }\n\n        err = ff_cbs_insert_unit_data(ctx, frag, unit, marker,\n                                      data, data_size, data_ref);\n        if (err < 0)\n            return err;\n\n        if (next_marker == -1)\n            break;\n        marker = next_marker;\n        start  = next_start;\n    }\n\n    return 0;\n}",
        "start_line": 106
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "libavcodec/cbs_jpeg.c",
        "method_name": "cbs_jpeg_split_fragment",
        "raw_code": "static int cbs_jpeg_split_fragment(CodedBitstreamContext *ctx, /* <=== cbs_jpeg_split_fragment */ \n                                   CodedBitstreamFragment *frag,\n                                   int header)\n{\n    AVBufferRef *data_ref;\n    uint8_t *data;\n    size_t data_size;\n    int unit, start, end, marker, next_start, next_marker;\n    int err, i, j, length;\n\n    if (frag->data_size < 4) {\n        // Definitely too short to be meaningful.\n        return AVERROR_INVALIDDATA;\n    }\n\n    for (i = 0; i + 1 < frag->data_size && frag->data[i] != 0xff; i++);\n    if (i > 0) {\n        av_log(ctx->log_ctx, AV_LOG_WARNING, \"Discarding %d bytes at \"\n               \"beginning of image.\\n\", i);\n    }\n    for (++i; i + 1 < frag->data_size && frag->data[i] == 0xff; i++);\n    if (i + 1 >= frag->data_size && frag->data[i]) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n               \"no SOI marker found.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    marker = frag->data[i];\n    if (marker != JPEG_MARKER_SOI) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: first \"\n               \"marker is %02x, should be SOI.\\n\", marker);\n        return AVERROR_INVALIDDATA;\n    }\n    for (++i; i + 1 < frag->data_size && frag->data[i] == 0xff; i++);\n    if (i + 1 >= frag->data_size) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n               \"no image content found.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    marker = frag->data[i];\n    start  = i + 1;\n\n    for (unit = 0;; unit++) {\n        if (marker == JPEG_MARKER_EOI) {\n            break;\n        } else if (marker == JPEG_MARKER_SOS) {\n            for (i = start; i + 1 < frag->data_size; i++) {\n                if (frag->data[i] != 0xff)\n                    continue;\n                end = i;\n                for (++i; i + 1 < frag->data_size &&\n                          frag->data[i] == 0xff; i++);\n                if (i + 1 >= frag->data_size) {\n                    next_marker = -1;\n                } else {\n                    if (frag->data[i] == 0x00)\n                        continue;\n                    next_marker = frag->data[i];\n                    next_start  = i + 1;\n                }\n                break;\n            }\n        } else {\n            i = start;\n            if (i + 2 > frag->data_size) {\n                av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n                       \"truncated at %02x marker.\\n\", marker);\n                return AVERROR_INVALIDDATA;\n            }\n            length = AV_RB16(frag->data + i);\n            if (i + length > frag->data_size) {\n                av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n                       \"truncated at %02x marker segment.\\n\", marker);\n                return AVERROR_INVALIDDATA;\n            }\n            end = start + length;\n\n            i = end;\n            if (frag->data[i] != 0xff) {\n                next_marker = -1;\n            } else {\n                for (++i; i + 1 < frag->data_size &&\n                          frag->data[i] == 0xff; i++);\n                if (i + 1 >= frag->data_size) {\n                    next_marker = -1;\n                } else {\n                    next_marker = frag->data[i];\n                    next_start  = i + 1;\n                }\n            }\n        }\n\n        if (marker == JPEG_MARKER_SOS) {\n            length = AV_RB16(frag->data + start);\n\n            if (length > end - start)\n                return AVERROR_INVALIDDATA;\n\n            data_ref = NULL;\n            data     = av_malloc(end - start +\n                                 AV_INPUT_BUFFER_PADDING_SIZE);\n            if (!data)\n                return AVERROR(ENOMEM);\n\n            memcpy(data, frag->data + start, length);\n            for (i = start + length, j = length; i < end; i++, j++) {\n                if (frag->data[i] == 0xff) {\n                    while (frag->data[i] == 0xff)\n                        ++i;\n                    data[j] = 0xff;\n                } else {\n                    data[j] = frag->data[i];\n                }\n            }\n            data_size = j;\n\n            memset(data + data_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n\n        } else {\n            data      = frag->data + start;\n            data_size = end - start;\n            data_ref  = frag->data_ref;\n        }\n\n        err = ff_cbs_insert_unit_data(ctx, frag, unit, marker,\n                                      data, data_size, data_ref);\n        if (err < 0)\n            return err;\n\n        if (next_marker == -1)\n            break;\n        marker = next_marker;\n        start  = next_start;\n    }\n\n    return 0;\n}",
        "start_line": 106
      }
    ],
    "code_context": "Called Methods:\n- av_assert0: #define av_assert0(cond) do {                                           \\ /* <=== libavutil/avassert.h:37:43:av_assert0:1 */ \n    if (!(cond)) {                                                      \\\n        av_log(NULL, AV_LOG_PANIC, \"Assertion %s failed at %s:%d\\n\",    \\\n               AV_STRINGIFY(cond), __FILE__, __LINE__);                 \\\n        abort();                                                        \\\n    }                                                                   \\\n} while (0)\n- AV_LOG_ERROR: #define AV_LOG_ERROR    16 /* <=== libavutil/log.h:176:176:AV_LOG_ERROR:0 */ \n- AV_RB16: #   define AV_RB16(x)                           \\ /* <=== libavutil/intreadwrite.h:240:242:AV_RB16:1 */ \n    ((((const uint8_t*)(x))[0] << 8) |          \\\n      ((const uint8_t*)(x))[1])\n- av_log: void av_log(void* avcl, int level, const char *fmt, ...) /* <=== av_log */ \n{\n    va_list vl;\n    va_start(vl, fmt);\n    av_vlog(avcl, level, fmt, vl);\n    va_end(vl);\n}\n- av_buffer_ref: AVBufferRef *av_buffer_ref(AVBufferRef *buf) /* <=== av_buffer_ref */ \n{\n    AVBufferRef *ret = av_mallocz(sizeof(*ret));\n\n    if (!ret)\n        return NULL;\n\n    *ret = *buf;\n\n    atomic_fetch_add_explicit(&buf->buffer->refcount, 1, memory_order_relaxed);\n\n    return ret;\n}\n- av_free: void av_free(void *ptr) /* <=== av_free */ \n{\n#if HAVE_ALIGNED_MALLOC\n    _aligned_free(ptr);\n#else\n    free(ptr);\n#endif\n}\n- AV_INPUT_BUFFER_PADDING_SIZE: #define AV_INPUT_BUFFER_PADDING_SIZE 64 /* <=== libavcodec/avcodec.h:805:805:AV_INPUT_BUFFER_PADDING_SIZE:0 */ \n- AVERROR: #define AVERROR(e) (e) /* <=== libavutil/error.h:43:43:AVERROR:1 */ \n- cbs_insert_unit: static int cbs_insert_unit(CodedBitstreamContext *ctx, /* <=== cbs_insert_unit */ \n                           CodedBitstreamFragment *frag,\n                           int position)\n{\n    CodedBitstreamUnit *units;\n\n    if (frag->nb_units < frag->nb_units_allocated) {\n        units = frag->units;\n\n        if (position < frag->nb_units)\n            memmove(units + position + 1, units + position,\n                    (frag->nb_units - position) * sizeof(*units));\n    } else {\n        units = av_malloc_array(frag->nb_units + 1, sizeof(*units));\n        if (!units)\n            return AVERROR(ENOMEM);\n\n        ++frag->nb_units_allocated;\n\n        if (position > 0)\n            memcpy(units, frag->units, position * sizeof(*units));\n\n        if (position < frag->nb_units)\n            memcpy(units + position + 1, frag->units + position,\n                   (frag->nb_units - position) * sizeof(*units));\n    }\n\n    memset(units + position, 0, sizeof(*units));\n\n    if (units != frag->units) {\n        av_free(frag->units);\n        frag->units = units;\n    }\n\n    ++frag->nb_units;\n\n    return 0;\n}\n- av_buffer_create: AVBufferRef *av_buffer_create(uint8_t *data, int size, /* <=== av_buffer_create */ \n                              void (*free)(void *opaque, uint8_t *data),\n                              void *opaque, int flags)\n{\n    AVBufferRef *ref = NULL;\n    AVBuffer    *buf = NULL;\n\n    buf = av_mallocz(sizeof(*buf));\n    if (!buf)\n        return NULL;\n\n    buf->data     = data;\n    buf->size     = size;\n    buf->free     = free ? free : av_buffer_default_free;\n    buf->opaque   = opaque;\n\n    atomic_init(&buf->refcount, 1);\n\n    if (flags & AV_BUFFER_FLAG_READONLY)\n        buf->flags |= BUFFER_FLAG_READONLY;\n\n    ref = av_mallocz(sizeof(*ref));\n    if (!ref) {\n        av_freep(&buf);\n        return NULL;\n    }\n\n    ref->buffer = buf;\n    ref->data   = data;\n    ref->size   = size;\n\n    return ref;\n}\n- av_vlog: void av_vlog(void* avcl, int level, const char *fmt, va_list vl) /* <=== av_vlog */ \n{\n    AVClass* avc = avcl ? *(AVClass **) avcl : NULL;\n    void (*log_callback)(void*, int, const char*, va_list) = av_log_callback;\n    if (avc && avc->version >= (50 << 16 | 15 << 8 | 2) &&\n        avc->log_level_offset_offset && level >= AV_LOG_FATAL)\n        level += *(int *) (((uint8_t *) avcl) + avc->log_level_offset_offset);\n    if (log_callback)\n        log_callback(avcl, level, fmt, vl);\n}\n- av_malloc: void *av_malloc(size_t size) /* <=== av_malloc */ \n{\n    void *ptr = NULL;\n\n    /* let's disallow possibly ambiguous cases */\n    if (size > (max_alloc_size - 32))\n        return NULL;\n\n#if HAVE_POSIX_MEMALIGN\n    if (size) //OS X on SDK 10.6 has a broken posix_memalign implementation\n    if (posix_memalign(&ptr, ALIGN, size))\n        ptr = NULL;\n#elif HAVE_ALIGNED_MALLOC\n    ptr = _aligned_malloc(size, ALIGN);\n#elif HAVE_MEMALIGN\n#ifndef __DJGPP__\n    ptr = memalign(ALIGN, size);\n#else\n    ptr = memalign(size, ALIGN);\n#endif\n    /* Why 64?\n     * Indeed, we should align it:\n     *   on  4 for 386\n     *   on 16 for 486\n     *   on 32 for 586, PPro - K6-III\n     *   on 64 for K7 (maybe for P3 too).\n     * Because L1 and L2 caches are aligned on those values.\n     * But I don't want to code such logic here!\n     */\n    /* Why 32?\n     * For AVX ASM. SSE / NEON needs only 16.\n     * Why not larger? Because I did not see a difference in benchmarks ...\n     */\n    /* benchmarks with P3\n     * memalign(64) + 1          3071, 3051, 3032\n     * memalign(64) + 2          3051, 3032, 3041\n     * memalign(64) + 4          2911, 2896, 2915\n     * memalign(64) + 8          2545, 2554, 2550\n     * memalign(64) + 16         2543, 2572, 2563\n     * memalign(64) + 32         2546, 2545, 2571\n     * memalign(64) + 64         2570, 2533, 2558\n     *\n     * BTW, malloc seems to do 8-byte alignment by default here.\n     */\n#else\n    ptr = malloc(size);\n#endif\n    if(!ptr && !size) {\n        size = 1;\n        ptr= av_malloc(1);\n    }\n#if CONFIG_MEMORY_POISONING\n    if (ptr)\n        memset(ptr, FF_MEMORY_POISON, size);\n#endif\n    return ptr;\n}\n- ff_cbs_insert_unit_data: int ff_cbs_insert_unit_data(CodedBitstreamContext *ctx, /* <=== ff_cbs_insert_unit_data */ \n                            CodedBitstreamFragment *frag,\n                            int position,\n                            CodedBitstreamUnitType type,\n                            uint8_t *data, size_t data_size,\n                            AVBufferRef *data_buf)\n{\n    CodedBitstreamUnit *unit;\n    AVBufferRef *data_ref;\n    int err;\n\n    if (position == -1)\n        position = frag->nb_units;\n    av_assert0(position >= 0 && position <= frag->nb_units);\n\n    if (data_buf)\n        data_ref = av_buffer_ref(data_buf);\n    else\n        data_ref = av_buffer_create(data, data_size, NULL, NULL, 0);\n    if (!data_ref) {\n        if (!data_buf)\n            av_free(data);\n        return AVERROR(ENOMEM);\n    }\n\n    err = cbs_insert_unit(ctx, frag, position);\n    if (err < 0) {\n        av_buffer_unref(&data_ref);\n        return err;\n    }\n\n    unit = &frag->units[position];\n    unit->type      = type;\n    unit->data      = data;\n    unit->data_size = data_size;\n    unit->data_ref  = data_ref;\n\n    return 0;\n}\n- AVERROR_INVALIDDATA: #define AVERROR_INVALIDDATA        FFERRTAG( 'I','N','D','A') ///< Invalid data found when processing input /* <=== libavutil/error.h:59:59:AVERROR_INVALIDDATA:0 */ \n- av_buffer_unref: void av_buffer_unref(AVBufferRef **buf) /* <=== av_buffer_unref */ \n{\n    if (!buf || !*buf)\n        return;\n\n    buffer_replace(buf, NULL);\n}\n\nType Definitions:\n- CodedBitstreamFragment: typedef struct CodedBitstreamFragment {\n    /**\n     * Pointer to the bitstream form of this fragment.\n     *\n     * May be NULL if the fragment only exists as component units.\n     */\n    uint8_t *data;\n    /**\n     * The number of bytes in the bitstream.\n     *\n     * The number of bytes in the bitstream (including any padding bits\n     * in the final byte).\n     */\n    size_t   data_size;\n    /**\n     * The number of bits which should be ignored in the final byte.\n     */\n    size_t data_bit_padding;\n    /**\n     * A reference to the buffer containing data.\n     *\n     * Must be set if data is not NULL.\n     */\n    AVBufferRef *data_ref;\n\n    /**\n     * Number of units in this fragment.\n     *\n     * This may be zero if the fragment only exists in bitstream form\n     * and has not been decomposed.\n     */\n    int              nb_units;\n\n    /**\n     * Number of allocated units.\n     *\n     * Must always be >= nb_units; designed for internal use by cbs.\n     */\n     int             nb_units_allocated;\n\n    /**\n     * Pointer to an array of units of length nb_units_allocated.\n     * Only the first nb_units are valid.\n     *\n     * Must be NULL if nb_units_allocated is zero.\n     */\n    CodedBitstreamUnit *units;\n}\n- AVBufferRef: typedef struct AVBufferRef {\n    AVBuffer *buffer;\n\n    /**\n     * The data buffer. It is considered writable if and only if\n     * this is the only reference to the buffer, in which case\n     * av_buffer_is_writable() returns 1.\n     */\n    uint8_t *data;\n    /**\n     * Size of data in bytes.\n     */\n    int      size;\n} AVBufferRef;\n- CodedBitstreamContext: typedef struct CodedBitstreamContext {\n    /**\n     * Logging context to be passed to all av_log() calls associated\n     * with this context.\n     */\n    void *log_ctx;\n\n    /**\n     * Internal codec-specific hooks.\n     */\n    const struct CodedBitstreamType *codec;\n\n    /**\n     * Internal codec-specific data.\n     *\n     * This contains any information needed when reading/writing\n     * bitsteams which will not necessarily be present in a fragment.\n     * For example, for H.264 it contains all currently visible\n     * parameter sets - they are required to determine the bitstream\n     * syntax but need not be present in every access unit.\n     */\n    void *priv_data;\n\n    /**\n     * Array of unit types which should be decomposed when reading.\n     *\n     * Types not in this list will be available in bitstream form only.\n     * If NULL, all supported types will be decomposed.\n     */\n    CodedBitstreamUnitType *decompose_unit_types;\n    /**\n     * Length of the decompose_unit_types array.\n     */\n    int nb_decompose_unit_types;\n\n    /**\n     * Enable trace output during read/write operations.\n     */\n    int trace_enable;\n    /**\n     * Log level to use for trace output.\n     *\n     * From AV_LOG_*; defaults to AV_LOG_TRACE.\n     */\n    int trace_level;\n\n    /**\n     * Write buffer. Used as intermediate buffer when writing units.\n     * For internal use of cbs only.\n     */\n    uint8_t *write_buffer;\n    size_t   write_buffer_size;\n}\n\nImports:\n- #include \"cbs.h\"\n- #include \"cbs_jpeg.h\"\n- #include \"cbs_internal.h\"\n- #include \"cbs_jpeg_syntax_template.c\"",
    "commit_msg": "avcodec/cbs_jpeg: Check length for SOS\n\nFixes: out of array access\nFixes: 19734/clusterfuzz-testcase-minimized-ffmpeg_BSF_TRACE_HEADERS_fuzzer-5673507031875584\nFixes: 19353/clusterfuzz-testcase-minimized-ffmpeg_BSF_TRACE_HEADERS_fuzzer-5703944462663680\n\nFound-by: continuous fuzzing process https://github.com/google/oss-fuzz/tree/master/projects/ffmpeg\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",
    "cve_desc": "cbs_jpeg_split_fragment in libavcodec/cbs_jpeg.c in FFmpeg 4.1 and 4.2.2 has a heap-based buffer overflow during JPEG_MARKER_SOS handling because of a missing length check.",
    "year": 2020,
    "filename": "cbs_jpeg.c",
    "commit_url": "\"https://github.com/FFmpeg/FFmpeg/commit/1812352d767ccf5431aa440123e2e260a4db2726\""
  },
  {
    "repository": "antonkueltz/fastecdsa",
    "cve_id": "CVE-2020-12607",
    "cwe_list": [
      "CWE-347"
    ],
    "commit_hash": "e592f106edd5acf6dacedfab2ad16fe6c735c9d1",
    "short_hash": "e592f106",
    "vulnerableMethods_before": [
      {
        "filename": "src/curveMath.c",
        "method_name": "pointZZ_pDouble",
        "raw_code": "void pointZZ_pDouble(PointZZ_p * rop, const PointZZ_p * op, const CurveZZ_p * curve) { /* <=== pointZZ_pDouble */ \n    mpz_t numer, denom, lambda;\n    mpz_inits(numer, denom, lambda, NULL);\n\n    // calculate lambda\n    mpz_mul(numer, op->x, op->x);\n    mpz_mul_ui(numer, numer, 3);\n    mpz_add(numer, numer, curve->a);\n    mpz_mul_ui(denom, op->y, 2);\n    mpz_invert(denom, denom, curve->p);  // TODO check status\n    mpz_mul(lambda, numer, denom);\n    mpz_mod(lambda, lambda, curve->p);\n\n    // calculate resulting x coord\n    mpz_mul(rop->x, lambda, lambda);\n    mpz_sub(rop->x, rop->x, op->x);\n    mpz_sub(rop->x, rop->x, op->x);\n    mpz_mod(rop->x, rop->x, curve->p);\n\n    //calculate resulting y coord\n    mpz_sub(rop->y, op->x, rop->x);\n    mpz_mul(rop->y, lambda, rop->y);\n    mpz_sub(rop->y, rop->y, op->y);\n    mpz_mod(rop->y, rop->y, curve->p);\n\n    mpz_clears(numer, denom, lambda, NULL);\n}",
        "start_line": 18
      },
      {
        "filename": "src/curveMath.c",
        "method_name": "pointZZ_pAdd",
        "raw_code": "void pointZZ_pAdd(PointZZ_p * rop, const PointZZ_p * op1, const PointZZ_p * op2, const CurveZZ_p * curve) { /* <=== pointZZ_pAdd */ \n    mpz_t xdiff, ydiff, lambda;\n    mpz_inits(xdiff, ydiff, lambda, NULL);\n\n    // calculate lambda\n    mpz_sub(ydiff, op2->y, op1->y);\n    mpz_sub(xdiff, op2->x, op1->x);\n    mpz_invert(xdiff, xdiff, curve->p);  // TODO check status\n    mpz_mul(lambda, ydiff, xdiff);\n    mpz_mod(lambda, lambda, curve->p);\n\n    // calculate resulting x coord\n    mpz_mul(rop->x, lambda, lambda);\n    mpz_sub(rop->x, rop->x, op1->x);\n    mpz_sub(rop->x, rop->x, op2->x);\n    mpz_mod(rop->x, rop->x, curve->p);\n\n    //calculate resulting y coord\n    mpz_sub(rop->y, op1->x, rop->x);\n    mpz_mul(rop->y, lambda, rop->y);\n    mpz_sub(rop->y, rop->y, op1->y);\n    mpz_mod(rop->y, rop->y, curve->p);\n\n    mpz_clears(xdiff, ydiff, lambda, NULL);\n}",
        "start_line": 47
      },
      {
        "filename": "src/curveMath.c",
        "method_name": "pointZZ_pMul",
        "raw_code": "void pointZZ_pMul(PointZZ_p * rop, const PointZZ_p * point, const mpz_t scalar, const CurveZZ_p * curve) { /* <=== pointZZ_pMul */ \n    PointZZ_p R0, R1, tmp;\n    mpz_inits(R1.x, R1.y, tmp.x, tmp.y, NULL);\n    mpz_init_set(R0.x, point->x);\n    mpz_init_set(R0.y, point->y);\n    pointZZ_pDouble(&R1, point, curve);\n\n    int dbits = mpz_sizeinbase(scalar, 2), i;\n\n    for(i = dbits - 2; i >= 0; i--) {\n        if(mpz_tstbit(scalar, i)) {\n            mpz_set(tmp.x, R0.x);\n            mpz_set(tmp.y, R0.y);\n            pointZZ_pAdd(&R0, &R1, &tmp, curve);\n            mpz_set(tmp.x, R1.x);\n            mpz_set(tmp.y, R1.y);\n            pointZZ_pDouble(&R1, &tmp, curve);\n        }\n        else {\n            mpz_set(tmp.x, R1.x);\n            mpz_set(tmp.y, R1.y);\n            pointZZ_pAdd(&R1, &R0, &tmp, curve);\n            mpz_set(tmp.x, R0.x);\n            mpz_set(tmp.y, R0.y);\n            pointZZ_pDouble(&R0, &tmp, curve);\n        }\n    }\n\n    mpz_init_set(rop->x, R0.x);\n    mpz_init_set(rop->y, R0.y);\n    mpz_clears(R0.x, R0.y, R1.x, R1.y, tmp.x, tmp.y, NULL);\n}",
        "start_line": 74
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "src/curveMath.c",
        "method_name": "pointZZ_pIsIdentityElement",
        "raw_code": "int pointZZ_pIsIdentityElement(const PointZZ_p * op) { /* <=== pointZZ_pIsIdentityElement */ \n    return mpz_cmp_ui(op->x, 0) == 0 && mpz_cmp_ui(op->y, 0) == 0 ? 1 : 0;\n}",
        "start_line": 18
      },
      {
        "filename": "src/curveMath.c",
        "method_name": "pointZZ_pSetToIdentityElement",
        "raw_code": "void pointZZ_pSetToIdentityElement(PointZZ_p * op) { /* <=== pointZZ_pSetToIdentityElement */ \n    mpz_set_ui(op->x, 0);\n    mpz_set_ui(op->y, 0);\n}",
        "start_line": 23
      },
      {
        "filename": "src/curveMath.c",
        "method_name": "pointZZ_pDouble",
        "raw_code": "void pointZZ_pDouble(PointZZ_p * rop, const PointZZ_p * op, const CurveZZ_p * curve) { /* <=== pointZZ_pDouble */ \n    if(pointZZ_pIsIdentityElement(op)) {\n        return pointZZ_pSetToIdentityElement(rop);\n    }\n\n    mpz_t numer, denom, lambda;\n    mpz_inits(numer, denom, lambda, NULL);\n\n    // calculate lambda\n    mpz_mul(numer, op->x, op->x);\n    mpz_mul_ui(numer, numer, 3);\n    mpz_add(numer, numer, curve->a);\n    mpz_mul_ui(denom, op->y, 2);\n    mpz_invert(denom, denom, curve->p);  // TODO check status\n    mpz_mul(lambda, numer, denom);\n    mpz_mod(lambda, lambda, curve->p);\n\n    // calculate resulting x coord\n    mpz_mul(rop->x, lambda, lambda);\n    mpz_sub(rop->x, rop->x, op->x);\n    mpz_sub(rop->x, rop->x, op->x);\n    mpz_mod(rop->x, rop->x, curve->p);\n\n    //calculate resulting y coord\n    mpz_sub(rop->y, op->x, rop->x);\n    mpz_mul(rop->y, lambda, rop->y);\n    mpz_sub(rop->y, rop->y, op->y);\n    mpz_mod(rop->y, rop->y, curve->p);\n\n    mpz_clears(numer, denom, lambda, NULL);\n}",
        "start_line": 29
      },
      {
        "filename": "src/curveMath.c",
        "method_name": "pointZZ_pAdd",
        "raw_code": "void pointZZ_pAdd(PointZZ_p * rop, const PointZZ_p * op1, const PointZZ_p * op2, const CurveZZ_p * curve) { /* <=== pointZZ_pAdd */ \n    // handle identity element cases\n    if(pointZZ_pIsIdentityElement(op1) && pointZZ_pIsIdentityElement(op2)) {\n        return pointZZ_pSetToIdentityElement(rop);\n    } else if(pointZZ_pIsIdentityElement(op1)) {\n        mpz_set(rop->x, op2->x);\n        mpz_set(rop->y, op2->y);\n        return;\n    } else if(pointZZ_pIsIdentityElement(op2)) {\n        mpz_set(rop->x, op1->x);\n        mpz_set(rop->y, op1->y);\n        return;\n    }\n\n    // use doubling algorithm if points are equal\n    if(pointZZ_pEqual(op1, op2)) {\n        pointZZ_pDouble(rop, op1, curve);\n        return;\n    }\n\n    // check if points sum to identity element\n    mpz_t negy;\n    mpz_init(negy);\n    mpz_sub(negy, curve->p, op2->y);\n    if(mpz_cmp(op1->x, op2->x) == 0 && mpz_cmp(op1->y, negy) == 0) {\n        mpz_clear(negy);\n        return pointZZ_pSetToIdentityElement(rop);\n    }\n\n\n    mpz_t xdiff, ydiff, lambda;\n    mpz_inits(xdiff, ydiff, lambda, NULL);\n\n    // calculate lambda\n    mpz_sub(ydiff, op2->y, op1->y);\n    mpz_sub(xdiff, op2->x, op1->x);\n    mpz_invert(xdiff, xdiff, curve->p);  // TODO check status\n    mpz_mul(lambda, ydiff, xdiff);\n    mpz_mod(lambda, lambda, curve->p);\n\n    // calculate resulting x coord\n    mpz_mul(rop->x, lambda, lambda);\n    mpz_sub(rop->x, rop->x, op1->x);\n    mpz_sub(rop->x, rop->x, op2->x);\n    mpz_mod(rop->x, rop->x, curve->p);\n\n    //calculate resulting y coord\n    mpz_sub(rop->y, op1->x, rop->x);\n    mpz_mul(rop->y, lambda, rop->y);\n    mpz_sub(rop->y, rop->y, op1->y);\n    mpz_mod(rop->y, rop->y, curve->p);\n\n    mpz_clears(negy, xdiff, ydiff, lambda, NULL);\n}",
        "start_line": 62
      },
      {
        "filename": "src/curveMath.c",
        "method_name": "pointZZ_pMul",
        "raw_code": "void pointZZ_pMul(PointZZ_p * rop, const PointZZ_p * point, const mpz_t scalar, const CurveZZ_p * curve) { /* <=== pointZZ_pMul */ \n    // handle the identity element\n    if(pointZZ_pIsIdentityElement(point)) {\n        return pointZZ_pSetToIdentityElement(rop);\n    }\n\n    PointZZ_p R0, R1, tmp;\n    mpz_inits(R1.x, R1.y, tmp.x, tmp.y, NULL);\n    mpz_init_set(R0.x, point->x);\n    mpz_init_set(R0.y, point->y);\n    pointZZ_pDouble(&R1, point, curve);\n\n    int dbits = mpz_sizeinbase(scalar, 2), i;\n\n    for(i = dbits - 2; i >= 0; i--) {\n        if(mpz_tstbit(scalar, i)) {\n            mpz_set(tmp.x, R0.x);\n            mpz_set(tmp.y, R0.y);\n            pointZZ_pAdd(&R0, &R1, &tmp, curve);\n            mpz_set(tmp.x, R1.x);\n            mpz_set(tmp.y, R1.y);\n            pointZZ_pDouble(&R1, &tmp, curve);\n        }\n        else {\n            mpz_set(tmp.x, R1.x);\n            mpz_set(tmp.y, R1.y);\n            pointZZ_pAdd(&R1, &R0, &tmp, curve);\n            mpz_set(tmp.x, R0.x);\n            mpz_set(tmp.y, R0.y);\n            pointZZ_pDouble(&R0, &tmp, curve);\n        }\n    }\n\n    mpz_init_set(rop->x, R0.x);\n    mpz_init_set(rop->y, R0.y);\n    mpz_clears(R0.x, R0.y, R1.x, R1.y, tmp.x, tmp.y, NULL);\n}",
        "start_line": 118
      }
    ],
    "code_context": "Called Methods:\n- pointZZ_pEqual: int pointZZ_pEqual(const PointZZ_p * op1, const PointZZ_p * op2) { /* <=== pointZZ_pEqual */ \n    // check x coords\n    if(mpz_cmp(op1->x, op2->x) != 0) {\n        return 0;\n    }\n    // check y coords\n    if(mpz_cmp(op1->y, op2->y) != 0) {\n        return 0;\n    }\n\n    return 1;\n}\n\nType Definitions:\n- PointZZ_p: typedef struct {\n    mpz_t x, y;\n}\n- CurveZZ_p: typedef struct {\n    mpz_t p, a, b, q;\n    PointZZ_p * g;\n}\n\nImports:\n- #include \"curveMath.h\"\n- #include <string.h>",
    "commit_msg": "Properly handle the point at infinity",
    "cve_desc": "An issue was discovered in fastecdsa before 2.1.2. When using the NIST P-256 curve in the ECDSA implementation, the point at infinity is mishandled. This means that for an extreme value in k and s^-1, the signature verification fails even if the signature is correct. This behavior is not solely a usability problem. There are some threat models where an attacker can benefit by successfully guessing users for whom signature verification will fail.",
    "year": 2020,
    "filename": "",
    "commit_url": "https://github.com/antonkueltz/fastecdsa/commit/e592f106edd5acf6dacedfab2ad16fe6c735c9d1"
  },
  {
    "repository": "gssapi/gssproxy",
    "cve_id": "CVE-2020-12658",
    "cwe_list": [
      "CWE-667"
    ],
    "commit_hash": "cb761412e299ef907f22cd7c4146d50c8a792003",
    "short_hash": "cb761412",
    "vulnerableMethods_before": [
      {
        "filename": "src/gp_workers.c",
        "method_name": "gp_worker_main",
        "raw_code": "static void *gp_worker_main(void *pvt) /* <=== gp_worker_main */ \n{\n    struct gp_thread *t = (struct gp_thread *)pvt;\n    struct gp_query *q = NULL;\n    char dummy = 0;\n    int ret;\n\n    while (!t->pool->shutdown) {\n\n        /* initialize debug client id to 0 until work is scheduled */\n        gp_debug_set_conn_id(0);\n\n        /* ======> COND_MUTEX */\n        pthread_mutex_lock(&t->cond_mutex);\n        while (t->query == NULL) {\n            /* wait for next query */\n            pthread_cond_wait(&t->cond_wakeup, &t->cond_mutex);\n            if (t->pool->shutdown) {\n                pthread_exit(NULL);\n            }\n        }\n\n        /* grab the query off the shared pointer */\n        q = t->query;\n        t->query = NULL;\n\n        /* <====== COND_MUTEX */\n        pthread_mutex_unlock(&t->cond_mutex);\n\n        /* set client id before hndling requests */\n        gp_debug_set_conn_id(gp_conn_get_cid(q->conn));\n\n        /* handle the client request */\n        GPDEBUGN(3, \"[status] Handling query input: %p (%zu)\\n\", q->buffer,\n                 q->buflen);\n        gp_handle_query(t->pool, q);\n        GPDEBUGN(3 ,\"[status] Handling query output: %p (%zu)\\n\", q->buffer,\n                 q->buflen);\n\n        /* now get lock on main queue, to play with the reply list */\n        /* ======> POOL LOCK */\n        pthread_mutex_lock(&t->pool->lock);\n\n        /* put back query so that dispatcher can send reply */\n        q->next = t->pool->reply_list;\n        t->pool->reply_list = q;\n\n        /* add us back to the free list but only if we are not\n         * shutting down */\n        if (!t->pool->shutdown) {\n            LIST_DEL(t->pool->busy_list, t);\n            LIST_ADD(t->pool->free_list, t);\n        }\n\n        /* <====== POOL LOCK */\n        pthread_mutex_unlock(&t->pool->lock);\n\n        /* and wake up dispatcher so it will handle it */\n        ret = write(t->pool->sig_pipe[1], &dummy, 1);\n        if (ret == -1) {\n            GPERROR(\"Failed to signal dispatcher!\");\n        }\n    }\n\n    pthread_exit(NULL);\n}",
        "start_line": 354
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "src/gp_workers.c",
        "method_name": "gp_worker_main",
        "raw_code": "static void *gp_worker_main(void *pvt) /* <=== gp_worker_main */ \n{\n    struct gp_thread *t = (struct gp_thread *)pvt;\n    struct gp_query *q = NULL;\n    char dummy = 0;\n    int ret;\n\n    while (!t->pool->shutdown) {\n\n        /* initialize debug client id to 0 until work is scheduled */\n        gp_debug_set_conn_id(0);\n\n        /* ======> COND_MUTEX */\n        pthread_mutex_lock(&t->cond_mutex);\n        while (t->query == NULL) {\n            /* wait for next query */\n            pthread_cond_wait(&t->cond_wakeup, &t->cond_mutex);\n            if (t->pool->shutdown) {\n                pthread_mutex_unlock(&t->cond_mutex);\n                pthread_exit(NULL);\n            }\n        }\n\n        /* grab the query off the shared pointer */\n        q = t->query;\n        t->query = NULL;\n\n        /* <====== COND_MUTEX */\n        pthread_mutex_unlock(&t->cond_mutex);\n\n        /* set client id before hndling requests */\n        gp_debug_set_conn_id(gp_conn_get_cid(q->conn));\n\n        /* handle the client request */\n        GPDEBUGN(3, \"[status] Handling query input: %p (%zu)\\n\", q->buffer,\n                 q->buflen);\n        gp_handle_query(t->pool, q);\n        GPDEBUGN(3 ,\"[status] Handling query output: %p (%zu)\\n\", q->buffer,\n                 q->buflen);\n\n        /* now get lock on main queue, to play with the reply list */\n        /* ======> POOL LOCK */\n        pthread_mutex_lock(&t->pool->lock);\n\n        /* put back query so that dispatcher can send reply */\n        q->next = t->pool->reply_list;\n        t->pool->reply_list = q;\n\n        /* add us back to the free list but only if we are not\n         * shutting down */\n        if (!t->pool->shutdown) {\n            LIST_DEL(t->pool->busy_list, t);\n            LIST_ADD(t->pool->free_list, t);\n        }\n\n        /* <====== POOL LOCK */\n        pthread_mutex_unlock(&t->pool->lock);\n\n        /* and wake up dispatcher so it will handle it */\n        ret = write(t->pool->sig_pipe[1], &dummy, 1);\n        if (ret == -1) {\n            GPERROR(\"Failed to signal dispatcher!\");\n        }\n    }\n\n    pthread_exit(NULL);\n}",
        "start_line": 354
      }
    ],
    "code_context": "Called Methods:\n- LIST_ADD: #define LIST_ADD(list, elem) do { \\ /* <=== src/gp_common.h:14:21:LIST_ADD:2 */ \n    elem->prev = NULL; \\\n    elem->next = list; \\\n    if (list) { \\\n        list->prev = elem; \\\n    } \\\n    list = elem; \\\n} while (0)\n- gp_debug_time_printf: void gp_debug_time_printf(const char *format, ...) /* <=== gp_debug_time_printf */ \n{\n    va_list varargs;\n\n    fprintf(stderr, \"%s%s\", gp_debug_conn_id(), gp_debug_timestamp());\n\n    va_start(varargs, format);\n    vfprintf(stderr, format, varargs);\n    va_end(varargs);\n}\n- LIST_DEL: #define LIST_DEL(list, elem) do { \\ /* <=== src/gp_common.h:24:36:LIST_DEL:2 */ \n    if (elem->next) { \\\n        elem->next->prev = elem->prev; \\\n    } \\\n    if (elem->prev) { \\\n        elem->prev->next = elem->next; \\\n    } \\\n    if (list == elem) { \\\n        list = elem->next; \\\n    } \\\n    elem->prev = NULL; \\\n    elem->next = NULL; \\\n} while (0)\n- gp_debug_set_conn_id: void gp_debug_set_conn_id(int id) /* <=== gp_debug_set_conn_id */ \n{\n    cid = id;\n}\n- gp_conn_get_cid: int gp_conn_get_cid(struct gp_conn *conn) /* <=== gp_conn_get_cid */ \n{\n    return conn->us.sd;\n}\n- GP_QUERY_OUT: #define GP_QUERY_OUT 1 /* <=== src/gp_workers.c:16:16:GP_QUERY_OUT:0 */ \n- GP_QUERY_ERR: #define GP_QUERY_ERR 2 /* <=== src/gp_workers.c:17:17:GP_QUERY_ERR:0 */ \n- gp_rpc_process_call: int gp_rpc_process_call(struct gp_call_ctx *gpcall, /* <=== gp_rpc_process_call */ \n                        uint8_t *inbuf, size_t inlen,\n                        uint8_t **outbuf, size_t *outlen)\n{\n    XDR xdr_call_ctx;\n    XDR xdr_reply_ctx;\n    gp_rpc_accept_status acc = GP_RPC_SUCCESS;\n    gp_rpc_reject_status rej = GP_RPC_RPC_MISMATCH;\n    char reply_buffer[MAX_RPC_SIZE];\n    union gp_rpc_arg arg;\n    union gp_rpc_res res;\n    uint32_t xid = 0;\n    uint32_t proc;\n    int ret;\n\n    memset(&arg, 0, sizeof(union gp_rpc_arg));\n    memset(&res, 0, sizeof(union gp_rpc_res));\n    proc = 0;\n\n    xdrmem_create(&xdr_call_ctx, (caddr_t)inbuf, inlen, XDR_DECODE);\n    xdrmem_create(&xdr_reply_ctx, reply_buffer, MAX_RPC_SIZE, XDR_ENCODE);\n\n    /* decode request */\n    GPDEBUGN(3, \"[status] Processing request [%p (%zu)]\\n\", inbuf, inlen);\n    ret = gp_rpc_decode_call(&xdr_call_ctx, &xid, &proc, &arg, &acc, &rej);\n    if (!ret) {\n        /* execute request */\n        GPDEBUGN(3, \"[status] Executing request %d (%s) from [%p (%zu)]\\n\",\n                 proc, gp_rpc_procname(proc), inbuf, inlen);\n        ret = gp_rpc_execute(gpcall, proc, &arg, &res);\n        if (ret) {\n            acc = GP_RPC_SYSTEM_ERR;\n            ret = EINVAL;\n        }\n    }\n\n    /* encode reply */\n    ret = gp_rpc_encode_reply(&xdr_reply_ctx, xid, proc, &res, ret, acc, rej);\n    if (ret == 0) {\n        /* return encoded buffer */\n        ret = gp_rpc_return_buffer(&xdr_reply_ctx,\n                                   reply_buffer, outbuf, outlen);\n        GPDEBUGN(3, \"[status] Returned buffer %d (%s) from [%p (%zu)]: \"\n                 \"[%p (%zu)]\\n\", proc, gp_rpc_procname(proc), inbuf, inlen,\n                 *outbuf, *outlen);\n    }\n    /* free resources */\n    gp_rpc_free_xdrs(proc, &arg, &res);\n    xdr_destroy(&xdr_call_ctx);\n    xdr_destroy(&xdr_reply_ctx);\n    return ret;\n}\n- gp_debug_conn_id: static const char*gp_debug_conn_id(void) /* <=== gp_debug_conn_id */ \n{\n    static __thread char buffer[18];\n    static __thread int last_cid = 0;\n\n    if (cid == 0) {\n        buffer[0] = '\\0';\n        return buffer;\n    }\n\n    if (last_cid == cid) return buffer;\n\n    (void)snprintf(buffer, 17, \"[CID %d]\", cid);\n    buffer[17] = '\\0';\n    last_cid = cid;\n    return buffer;\n}\n- GPDEBUGN: #define GPDEBUGN(lvl, ...) do { \\ /* <=== src/gp_debug.h:24:28:GPDEBUGN:2 */ \n    if (lvl <= gp_debug) { \\\n        gp_debug_time_printf(__VA_ARGS__); \\\n    } \\\n} while(0)\n- gp_handle_query: static void gp_handle_query(struct gp_workers *w, struct gp_query *q) /* <=== gp_handle_query */ \n{\n    struct gp_call_ctx gpcall = { 0 };\n    uint8_t *buffer;\n    size_t buflen;\n    int ret;\n\n    /* find service */\n    gpcall.gpctx = w->gpctx;\n    gpcall.service = gp_creds_match_conn(w->gpctx, q->conn);\n    if (!gpcall.service) {\n        q->status = GP_QUERY_ERR;\n        return;\n    }\n    gpcall.connection = q->conn;\n\n    ret = gp_rpc_process_call(&gpcall,\n                              q->buffer, q->buflen,\n                              &buffer, &buflen);\n    if (ret) {\n        q->status = GP_QUERY_ERR;\n    } else {\n        q->status = GP_QUERY_OUT;\n        free(q->buffer);\n        q->buffer = buffer;\n        q->buflen = buflen;\n    }\n\n    if (gpcall.destroy_callback) {\n        gpcall.destroy_callback(gpcall.destroy_callback_data);\n    }\n}\n- gp_debug_timestamp: const char *gp_debug_timestamp(void) /* <=== gp_debug_timestamp */ \n{\n    static __thread char buffer[24];\n    static __thread time_t timestamp = 0;\n    struct tm tm_info;\n    time_t now;\n\n    time(&now);\n    if (now == timestamp) return buffer;\n\n    gmtime_r(&now, &tm_info);\n    strftime(buffer, 24, \"[%Y/%m/%d %H:%M:%S]: \", &tm_info);\n    timestamp = now;\n    return buffer;\n}\n- gp_creds_match_conn: struct gp_service *gp_creds_match_conn(struct gssproxy_ctx *gpctx, /* <=== gp_creds_match_conn */ \n                                       struct gp_conn *conn)\n{\n    struct gp_creds *gcs;\n    const char *socket;\n    const char *program;\n\n    gcs = gp_conn_get_creds(conn);\n    socket = gp_conn_get_socket(conn);\n    program = gp_conn_get_program(conn);\n\n    for (int i = 0; i < gpctx->config->num_svcs; i++) {\n        struct gp_service *svc = gpctx->config->svcs[i];\n\n        if ((!svc->any_uid && svc->euid != gcs->ucred.uid) ||\n            !gp_conn_check_selinux(conn, svc->selinux_ctx) ||\n            (svc->program && !gp_same(program, svc->program)) ||\n            (svc->socket && !gp_same(socket, svc->socket)) ||\n            (!svc->socket && !gp_same(socket, gpctx->config->socket_name))) {\n            continue;\n        }\n\n        GPDEBUGN(2, \"Connection matched service %s\\n\", svc->name);\n        return svc;\n    }\n\n    GPDEBUGN(2, \"No matching service found\\n\");\n    return NULL;\n}\n\nType Definitions:\n- gp_query: struct gp_query {\n    struct gp_query *next;\n\n    struct gp_conn *conn;\n    uint8_t *buffer;\n    size_t buflen;\n\n    int status;\n}\n- gp_thread: struct gp_thread {\n    struct gp_thread *prev;\n    struct gp_thread *next;\n    struct gp_workers *pool;\n    pthread_t tid;\n\n    struct gp_query *query;\n    pthread_mutex_t cond_mutex;\n    pthread_cond_t cond_wakeup;\n}\n\nImports:\n- #include <stdlib.h>\n- #include <pthread.h>\n- #include <stdint.h>\n- #include <errno.h>\n- #include \"gp_proxy.h\"\n- #include <string.h>\n- #include <fcntl.h>\n- #include \"config.h\"\n- #include <unistd.h>",
    "commit_msg": "Unlock cond_mutex before pthread exit in gp_worker_main()\n\nSigned-off-by: GuiYao <guiyao@huawei.com>\n[rharwood@redhat.com: whitespace, tweak commit message]\nReviewed-by: Robbie Harwood <rharwood@redhat.com>",
    "cve_desc": "[{'lang': 'en', 'value': 'gssproxy (aka gss-proxy) before 0.8.3 does not unlock cond_mutex before pthread exit in gp_worker_main() in gp_workers.c. NOTE: An upstream comment states \"We are already on a shutdown path when running the code in question, so a DoS there doesn\\'t make any sense, and there has been no additional information provided us (as upstream) to indicate why this would be a problem.'}]",
    "year": 2020,
    "filename": "gp_workers.c",
    "commit_url": "\"https://github.com/gssapi/gssproxy/commit/cb761412e299ef907f22cd7c4146d50c8a792003\""
  },
  {
    "repository": "Exim/exim",
    "cve_id": "CVE-2020-12783",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "a04174dc2a84ae1008c23b6a7109e7fa3fb7b8b0",
    "short_hash": "a04174dc",
    "vulnerableMethods_before": [
      {
        "filename": "src/src/auths/spa.c",
        "method_name": "auth_spa_server",
        "raw_code": "int /* <=== auth_spa_server */ \nauth_spa_server(auth_instance *ablock, uschar *data)\n{\nauth_spa_options_block *ob = (auth_spa_options_block *)(ablock->options_block);\nuint8x lmRespData[24];\nuint8x ntRespData[24];\nSPAAuthRequest request;\nSPAAuthChallenge challenge;\nSPAAuthResponse  response;\nSPAAuthResponse  *responseptr = &response;\nuschar msgbuf[2048];\nuschar *clearpass, *s;\n\n/* send a 334, MS Exchange style, and grab the client's request,\nunless we already have it via an initial response. */\n\nif (!*data && auth_get_no64_data(&data, US\"NTLM supported\") != OK)\n  return FAIL;\n\nif (spa_base64_to_bits(CS &request, sizeof(request), CCS data) < 0)\n  {\n  DEBUG(D_auth) debug_printf(\"auth_spa_server(): bad base64 data in \"\n    \"request: %s\\n\", data);\n  return FAIL;\n  }\n\n/* create a challenge and send it back */\n\nspa_build_auth_challenge(&request, &challenge);\nspa_bits_to_base64(msgbuf, US &challenge, spa_request_length(&challenge));\n\nif (auth_get_no64_data(&data, msgbuf) != OK)\n  return FAIL;\n\n/* dump client response */\nif (spa_base64_to_bits(CS &response, sizeof(response), CCS data) < 0)\n  {\n  DEBUG(D_auth) debug_printf(\"auth_spa_server(): bad base64 data in \"\n    \"response: %s\\n\", data);\n  return FAIL;\n  }\n\n/***************************************************************\nPH 07-Aug-2003: The original code here was this:\n\nUstrcpy(msgbuf, unicodeToString(((char*)responseptr) +\n  IVAL(&responseptr->uUser.offset,0),\n  SVAL(&responseptr->uUser.len,0)/2) );\n\nHowever, if the response data is too long, unicodeToString bombs out on\nan assertion failure. It uses a 1024 fixed buffer. Bombing out is not a good\nidea. It's too messy to try to rework that function to return an error because\nit is called from a number of other places in the auth-spa.c module. Instead,\nsince it is a very small function, I reproduce its code here, with a size check\nthat causes failure if the size of msgbuf is exceeded. ****/\n\n  {\n  int i;\n  char * p = (CS responseptr) + IVAL(&responseptr->uUser.offset,0);\n  int len = SVAL(&responseptr->uUser.len,0)/2;\n\n  if (p + len*2 >= CS (responseptr+1))\n    {\n    DEBUG(D_auth)\n      debug_printf(\"auth_spa_server(): bad uUser spec in response\\n\");\n    return FAIL;\n    }\n\n  if (len + 1 >= sizeof(msgbuf)) return FAIL;\n  for (i = 0; i < len; ++i)\n    {\n    msgbuf[i] = *p & 0x7f;\n    p += 2;\n    }\n  msgbuf[i] = 0;\n  }\n\n/***************************************************************/\n\n/* Put the username in $auth1 and $1. The former is now the preferred variable;\nthe latter is the original variable. These have to be out of stack memory, and\nneed to be available once known even if not authenticated, for error messages\n(server_set_id, which only makes it to authenticated_id if we return OK) */\n\nauth_vars[0] = expand_nstring[1] = string_copy(msgbuf);\nexpand_nlength[1] = Ustrlen(msgbuf);\nexpand_nmax = 1;\n\ndebug_print_string(ablock->server_debug_string);    /* customized debug */\n\n/* look up password */\n\nif (!(clearpass = expand_string(ob->spa_serverpassword)))\n  if (f.expand_string_forcedfail)\n    {\n    DEBUG(D_auth) debug_printf(\"auth_spa_server(): forced failure while \"\n      \"expanding spa_serverpassword\\n\");\n    return FAIL;\n    }\n  else\n    {\n    DEBUG(D_auth) debug_printf(\"auth_spa_server(): error while expanding \"\n      \"spa_serverpassword: %s\\n\", expand_string_message);\n    return DEFER;\n    }\n\n/* create local hash copy */\n\nspa_smb_encrypt(clearpass, challenge.challengeData, lmRespData);\nspa_smb_nt_encrypt(clearpass, challenge.challengeData, ntRespData);\n\n/* compare NT hash (LM may not be available) */\n\ns = (US responseptr) + IVAL(&responseptr->ntResponse.offset,0);\nif (s + 24 >= US (responseptr+1))\n  {\n  DEBUG(D_auth)\n    debug_printf(\"auth_spa_server(): bad ntRespData spec in response\\n\");\n  return FAIL;\n  }\n\nif (memcmp(ntRespData, s, 24) == 0)\n  return auth_check_serv_cond(ablock);\t/* success. we have a winner. */\n\n  /* Expand server_condition as an authorization check (PH) */\n\nreturn FAIL;\n}",
        "start_line": 132
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "src/src/auths/spa.c",
        "method_name": "auth_spa_server",
        "raw_code": "int /* <=== auth_spa_server */ \nauth_spa_server(auth_instance *ablock, uschar *data)\n{\nauth_spa_options_block *ob = (auth_spa_options_block *)(ablock->options_block);\nuint8x lmRespData[24];\nuint8x ntRespData[24];\nSPAAuthRequest request;\nSPAAuthChallenge challenge;\nSPAAuthResponse  response;\nSPAAuthResponse  *responseptr = &response;\nuschar msgbuf[2048];\nuschar *clearpass, *s;\nunsigned off;\n\n/* send a 334, MS Exchange style, and grab the client's request,\nunless we already have it via an initial response. */\n\nif (!*data && auth_get_no64_data(&data, US\"NTLM supported\") != OK)\n  return FAIL;\n\nif (spa_base64_to_bits(CS &request, sizeof(request), CCS data) < 0)\n  {\n  DEBUG(D_auth) debug_printf(\"auth_spa_server(): bad base64 data in \"\n    \"request: %s\\n\", data);\n  return FAIL;\n  }\n\n/* create a challenge and send it back */\n\nspa_build_auth_challenge(&request, &challenge);\nspa_bits_to_base64(msgbuf, US &challenge, spa_request_length(&challenge));\n\nif (auth_get_no64_data(&data, msgbuf) != OK)\n  return FAIL;\n\n/* dump client response */\nif (spa_base64_to_bits(CS &response, sizeof(response), CCS data) < 0)\n  {\n  DEBUG(D_auth) debug_printf(\"auth_spa_server(): bad base64 data in \"\n    \"response: %s\\n\", data);\n  return FAIL;\n  }\n\n/***************************************************************\nPH 07-Aug-2003: The original code here was this:\n\nUstrcpy(msgbuf, unicodeToString(((char*)responseptr) +\n  IVAL(&responseptr->uUser.offset,0),\n  SVAL(&responseptr->uUser.len,0)/2) );\n\nHowever, if the response data is too long, unicodeToString bombs out on\nan assertion failure. It uses a 1024 fixed buffer. Bombing out is not a good\nidea. It's too messy to try to rework that function to return an error because\nit is called from a number of other places in the auth-spa.c module. Instead,\nsince it is a very small function, I reproduce its code here, with a size check\nthat causes failure if the size of msgbuf is exceeded. ****/\n\n  {\n  int i;\n  char * p;\n  int len = SVAL(&responseptr->uUser.len,0)/2;\n\n  if (  (off = IVAL(&responseptr->uUser.offset,0)) >= sizeof(SPAAuthResponse)\n     || len >= sizeof(responseptr->buffer)/2\n     || (p = (CS responseptr) + off) + len*2 >= CS (responseptr+1)\n     )\n    {\n    DEBUG(D_auth)\n      debug_printf(\"auth_spa_server(): bad uUser spec in response\\n\");\n    return FAIL;\n    }\n\n  if (len + 1 >= sizeof(msgbuf)) return FAIL;\n  for (i = 0; i < len; ++i)\n    {\n    msgbuf[i] = *p & 0x7f;\n    p += 2;\n    }\n  msgbuf[i] = 0;\n  }\n\n/***************************************************************/\n\n/* Put the username in $auth1 and $1. The former is now the preferred variable;\nthe latter is the original variable. These have to be out of stack memory, and\nneed to be available once known even if not authenticated, for error messages\n(server_set_id, which only makes it to authenticated_id if we return OK) */\n\nauth_vars[0] = expand_nstring[1] = string_copy(msgbuf);\nexpand_nlength[1] = Ustrlen(msgbuf);\nexpand_nmax = 1;\n\ndebug_print_string(ablock->server_debug_string);    /* customized debug */\n\n/* look up password */\n\nif (!(clearpass = expand_string(ob->spa_serverpassword)))\n  if (f.expand_string_forcedfail)\n    {\n    DEBUG(D_auth) debug_printf(\"auth_spa_server(): forced failure while \"\n      \"expanding spa_serverpassword\\n\");\n    return FAIL;\n    }\n  else\n    {\n    DEBUG(D_auth) debug_printf(\"auth_spa_server(): error while expanding \"\n      \"spa_serverpassword: %s\\n\", expand_string_message);\n    return DEFER;\n    }\n\n/* create local hash copy */\n\nspa_smb_encrypt(clearpass, challenge.challengeData, lmRespData);\nspa_smb_nt_encrypt(clearpass, challenge.challengeData, ntRespData);\n\n/* compare NT hash (LM may not be available) */\n\noff = IVAL(&responseptr->ntResponse.offset,0);\nif (off >= sizeof(SPAAuthResponse) - 24)\n  {\n  DEBUG(D_auth)\n    debug_printf(\"auth_spa_server(): bad ntRespData spec in response\\n\");\n  return FAIL;\n  }\ns = (US responseptr) + off;\n\nif (memcmp(ntRespData, s, 24) == 0)\n  return auth_check_serv_cond(ablock);\t/* success. we have a winner. */\n\n  /* Expand server_condition as an authorization check (PH) */\n\nreturn FAIL;\n}",
        "start_line": 132
      }
    ],
    "code_context": "Called Methods:\n- DEBUG: #define DEBUG(x)      if (debug_selector & (x)) /* <=== src/src/macros.h:111:111:DEBUG:1 */ \n- debug_vprintf: void /* <=== debug_vprintf */ \ndebug_vprintf(int indent, const char *format, va_list ap)\n{\nint save_errno = errno;\n\nif (!debug_file) return;\n\n/* Various things can be inserted at the start of a line. Don't use the\ntod_stamp() function for the timestamp, because that will overwrite the\ntimestamp buffer, which may contain something useful. (This was a bug fix: the\n+memory debugging with +timestamp did cause a problem.) */\n\nif (debug_ptr == debug_buffer)\n  {\n  DEBUG(D_timestamp)\n    {\n    struct timeval now;\n    time_t tmp;\n    struct tm * t;\n\n    gettimeofday(&now, NULL);\n    tmp = now.tv_sec;\n    t = f.timestamps_utc ? gmtime(&tmp) : localtime(&tmp);\n    debug_ptr += sprintf(CS debug_ptr,\n      LOGGING(millisec) ? \"%02d:%02d:%02d.%03d \" : \"%02d:%02d:%02d \",\n      t->tm_hour, t->tm_min, t->tm_sec, (int)(now.tv_usec/1000));\n    }\n\n  DEBUG(D_pid)\n    debug_ptr += sprintf(CS debug_ptr, \"%5d \", (int)getpid());\n\n  /* Set up prefix if outputting for host checking and not debugging */\n\n  if (host_checking && debug_selector == 0)\n    {\n    Ustrcpy(debug_ptr, US\">>> \");\n    debug_ptr += 4;\n    }\n\n  debug_prefix_length = debug_ptr - debug_buffer;\n  }\n\nif (indent > 0)\n  {\n  for (int i = indent >> 2; i > 0; i--)\n    DEBUG(D_noutf8)\n      {\n      Ustrcpy(debug_ptr, US\"   !\");\n      debug_ptr += 4;\t/* 3 spaces + shriek */\n      debug_prefix_length += 4;\n      }\n    else\n      {\n      Ustrcpy(debug_ptr, US\"   \" UTF8_VERT_2DASH);\n      debug_ptr += 6;\t/* 3 spaces + 3 UTF-8 octets */\n      debug_prefix_length += 6;\n      }\n\n  Ustrncpy(debug_ptr, US\"   \", indent &= 3);\n  debug_ptr += indent;\n  debug_prefix_length += indent;\n  }\n\n/* Use the lengthchecked formatting routine to ensure that the buffer\ndoes not overflow. Ensure there's space for a newline at the end.\nHowever, use taint-unchecked routines for writing into the buffer\nso that we can write tainted info into the static debug_buffer -\nwe trust that we will never expand the results. */\n\n  {\n  gstring gs = { .size = (int)sizeof(debug_buffer) - 1,\n\t\t.ptr = debug_ptr - debug_buffer,\n\t\t.s = debug_buffer };\n  if (!string_vformat(&gs, SVFMT_TAINT_NOCHK, format, ap))\n    {\n    uschar * s = US\"**** debug string too long - truncated ****\\n\";\n    uschar * p = gs.s + gs.ptr;\n    int maxlen = gs.size - Ustrlen(s) - 2;\n    if (p > gs.s + maxlen) p = gs.s + maxlen;\n    if (p > gs.s && p[-1] != '\\n') *p++ = '\\n';\n    Ustrcpy(p, s);\n    while(*debug_ptr) debug_ptr++;\n    }\n  else\n    {\n    string_from_gstring(&gs);\n    debug_ptr = gs.s + gs.ptr;\n    }\n  }\n\n/* Output the line if it is complete. If we added any prefix data and there\nare internal newlines, make sure the prefix is on the continuation lines,\nas long as there is room in the buffer. We want to do just a single fprintf()\nso as to avoid interleaving. */\n\nif (debug_ptr[-1] == '\\n')\n  {\n  if (debug_prefix_length > 0)\n    {\n    uschar *p = debug_buffer;\n    int left = sizeof(debug_buffer) - (debug_ptr - debug_buffer) - 1;\n    while ((p = Ustrchr(p, '\\n') + 1) != debug_ptr &&\n           left >= debug_prefix_length)\n      {\n      int len = debug_ptr - p;\n      memmove(p + debug_prefix_length, p, len + 1);\n      memmove(p, debug_buffer, debug_prefix_length);\n      debug_ptr += debug_prefix_length;\n      left -= debug_prefix_length;\n      }\n    }\n\n  fprintf(debug_file, \"%s\", CS debug_buffer);\n  fflush(debug_file);\n  debug_ptr = debug_buffer;\n  debug_prefix_length = 0;\n  }\nerrno = save_errno;\n}\n- spa_base64_to_bits: int /* <=== spa_base64_to_bits */ \nspa_base64_to_bits (char *out, int outlength, const char *in)\n/* base 64 to raw bytes in quasi-big-endian order, returning count of bytes */\n{\nint len = 0;\nuschar digit1, digit2, digit3, digit4;\n\nif (in[0] == '+' && in[1] == ' ')\n  in += 2;\nif (*in == '\\r')\n  return (0);\n\ndo\n  {\n  if (len >= outlength)                   /* Added by PH */\n    return -1;                          /* Added by PH */\n  digit1 = in[0];\n  if (DECODE64 (digit1) == BAD)\n    return -1;\n  digit2 = in[1];\n  if (DECODE64 (digit2) == BAD)\n    return -1;\n  digit3 = in[2];\n  if (digit3 != '=' && DECODE64 (digit3) == BAD)\n    return -1;\n  digit4 = in[3];\n  if (digit4 != '=' && DECODE64 (digit4) == BAD)\n    return -1;\n  in += 4;\n  *out++ = (DECODE64 (digit1) << 2) | (DECODE64 (digit2) >> 4);\n  ++len;\n  if (digit3 != '=')\n    {\n    if (len >= outlength)                   /* Added by PH */\n      return -1;                          /* Added by PH */\n    *out++ =\n      ((DECODE64 (digit2) << 4) & 0xf0) | (DECODE64 (digit3) >> 2);\n    ++len;\n    if (digit4 != '=')\n      {\n      if (len >= outlength)                   /* Added by PH */\n\treturn -1;                          /* Added by PH */\n      *out++ = ((DECODE64 (digit3) << 6) & 0xc0) | DECODE64 (digit4);\n      ++len;\n      }\n    }\n  }\nwhile (*in && *in != '\\r' && digit4 != '=');\n\nreturn len;\n}\n- FALSE: # define FALSE         0 /* <=== src/src/mytypes.h:20:20:FALSE:0 */ \n- expand_string: extern uschar *expand_string(uschar *); /* <=== expand_string */ \n- string_vformat: extern gstring * string_vformat(gstring *, unsigned, const char *, va_list); /* <=== string_vformat */ \n- auth_get_no64_data: int /* <=== auth_get_no64_data */ \nauth_get_no64_data(uschar **aptr, uschar *challenge)\n{\nint c;\nint p = 0;\nsmtp_printf(\"334 %s\\r\\n\", FALSE, challenge);\nwhile ((c = receive_getc(GETC_BUFFER_UNLIMITED)) != '\\n' && c != EOF)\n  {\n  if (p >= big_buffer_size - 1) return BAD64;\n  big_buffer[p++] = c;\n  }\nif (p > 0 && big_buffer[p-1] == '\\r') p--;\nbig_buffer[p] = 0;\nif (Ustrcmp(big_buffer, \"*\") == 0) return CANCELLED;\n*aptr = big_buffer;\nreturn OK;\n}\n- SVAL: #define SVAL(buf,pos) (PVAL(buf,pos)|PVAL(buf,(pos)+1)<<8) /* <=== src/src/auths/spa.c:129:129:SVAL:2 */ \n- BAD: #define BAD    (char) -1 /* <=== src/src/auths/auth-spa.c:357:357:BAD:0 */ \n- debug_printf: void /* <=== debug_printf */ \ndebug_printf(const char *format, ...)\n{\nva_list ap;\nva_start(ap, format);\ndebug_vprintf(0, format, ap);\nva_end(ap);\n}\n- FAIL: #define  FAIL          2    /* Matching failed */ /* <=== src/src/macros.h:288:288:FAIL:0 */ \n- US: #define US   (unsigned char *) /* <=== src/src/mytypes.h:77:77:US:0 */ \n- auth_check_serv_cond: int /* <=== auth_check_serv_cond */ \nauth_check_serv_cond(auth_instance *ablock)\n{\n  return auth_check_some_cond(ablock,\n      US\"server_condition\", ablock->server_condition, OK);\n}\n- CCS: #define CCS  (const char *) /* <=== src/src/mytypes.h:75:75:CCS:0 */ \n- Ustrcmp: #define Ustrcmp(s,t)       strcmp(CCS(s),CCS(t)) /* <=== src/src/mytypes.h:110:110:Ustrcmp:2 */ \n- OK: #define  OK            0    /* Successful match */ /* <=== src/src/macros.h:286:286:OK:0 */ \n- auth_check_some_cond: int /* <=== auth_check_some_cond */ \nauth_check_some_cond(auth_instance *ablock,\n    uschar *label, uschar *condition, int unset)\n{\nuschar *cond;\n\nHDEBUG(D_auth)\n  {\n  debug_printf(\"%s authenticator %s:\\n\", ablock->name, label);\n  for (int i = 0; i < AUTH_VARS; i++) if (auth_vars[i])\n    debug_printf(\"  $auth%d = %s\\n\", i + 1, auth_vars[i]);\n  for (int i = 1; i <= expand_nmax; i++)\n    debug_printf(\"  $%d = %.*s\\n\", i, expand_nlength[i], expand_nstring[i]);\n  debug_print_string(ablock->server_debug_string);    /* customized debug */\n  }\n\n/* For the plaintext authenticator, server_condition is never NULL. For the\nrest, an unset condition lets everything through. */\n\n/* For server_condition, an unset condition lets everything through.\nFor plaintext/gsasl authenticators, it will have been pre-checked to prevent\nthis.  We return the unset scenario value given to us, which for\nserver_condition will be OK and otherwise will typically be FAIL. */\n\nif (!condition) return unset;\ncond = expand_string(condition);\n\nHDEBUG(D_auth)\n  if (!cond)\n    debug_printf(\"expansion failed: %s\\n\", expand_string_message);\n  else\n    debug_printf(\"expanded string: %s\\n\", cond);\n\n/* A forced expansion failure causes authentication to fail. Other expansion\nfailures yield DEFER, which will cause a temporary error code to be returned to\nthe AUTH command. The problem is at the server end, so the client should try\nagain later. */\n\nif (!cond)\n  {\n  if (f.expand_string_forcedfail) return FAIL;\n  auth_defer_msg = expand_string_message;\n  return DEFER;\n  }\n\n/* Return FAIL for empty string, \"0\", \"no\", and \"false\"; return OK for\n\"1\", \"yes\", and \"true\"; return DEFER for anything else, with the string\navailable as an error text for the user. */\n\nif (*cond == 0 ||\n    Ustrcmp(cond, \"0\") == 0 ||\n    strcmpic(cond, US\"no\") == 0 ||\n    strcmpic(cond, US\"false\") == 0)\n  return FAIL;\n\nif (Ustrcmp(cond, \"1\") == 0 ||\n    strcmpic(cond, US\"yes\") == 0 ||\n    strcmpic(cond, US\"true\") == 0)\n  return OK;\n\nauth_defer_msg = cond;\nauth_defer_user_msg = string_sprintf(\": %s\", cond);\nreturn DEFER;\n}\n- string_from_gstring: static inline uschar * /* <=== string_from_gstring */ \nstring_from_gstring(gstring * g)\n{\nif (!g) return NULL;\ng->s[g->ptr] = '\\0';\nreturn g->s;\n}\n- CS: #define CS   (char *) /* <=== src/src/mytypes.h:74:74:CS:0 */ \n- BAD64: #define BAD64         11    /* Bad base64 data (auth) */ /* <=== src/src/macros.h:300:300:BAD64:0 */ \n- smtp_printf: extern void    smtp_printf(const char *, BOOL, ...) PRINTF_FUNCTION(1,3); /* <=== smtp_printf */ \n- debug_printf: void /* <=== debug_printf */ \ndebug_printf(char *format, ...)\n{\nva_list ap;\nrmark reset_point = store_mark();\ngstring * g = string_get_tainted(1024, TRUE);\n\nva_start(ap, format);\n\nif (!string_vformat(g, 0, format, ap))\n  {\n  char * s = \"**** debug string overflowed buffer ****\\n\";\n  char * p = CS g->s + g->ptr;\n  int maxlen = g->size - (int)strlen(s) - 3;\n  if (p > g->s + maxlen) p = g->s + maxlen;\n  if (p > g->s && p[-1] != '\\n') *p++ = '\\n';\n  strcpy(p, s);\n  }\n\nfprintf(stderr, \"%s\", string_from_gstring(g));\nfflush(stderr);\nstore_reset(reset_point);\nva_end(ap);\n}\n- IVAL: #define IVAL(buf,pos) (SVAL(buf,pos)|SVAL(buf,(pos)+2)<<16) /* <=== src/src/auths/spa.c:130:130:IVAL:2 */ \n- DECODE64: #define DECODE64(c)  (isascii(c) ? base64val[c] : BAD) /* <=== src/src/auths/auth-spa.c:371:371:DECODE64:1 */ \n- GETC_BUFFER_UNLIMITED: #define GETC_BUFFER_UNLIMITED\tUINT_MAX /* <=== src/src/macros.h:1034:1034:GETC_BUFFER_UNLIMITED:0 */ \n- CANCELLED: #define CANCELLED     13    /* Authentication cancelled */ /* <=== src/src/macros.h:302:302:CANCELLED:0 */ \n\nType Definitions:\n- SPAAuthRequest: typedef struct\n{\n       char         ident[8];\n       uint32x         msgType;\n       uint32x         flags;\n       SPAStrHeader    user;\n       SPAStrHeader    domain;\n       uint8x         buffer[1024];\n       uint32x         bufIndex;\n}\n- auth_spa_options_block: typedef struct {\n  uschar *spa_username;\n  uschar *spa_password;\n  uschar *spa_domain;\n  uschar *spa_serverpassword;\n}\n- auth_instance: typedef struct auth_instance {\n  struct auth_instance *next;\n  uschar *name;                   /* Exim instance name */\n  struct auth_info *info;         /* Pointer to driver info block */\n  void   *options_block;          /* Pointer to private options */\n  uschar *driver_name;            /* Must be first */\n  uschar *advertise_condition;    /* Are we going to advertise this?*/\n  uschar *client_condition;       /* Should the client try this? */\n  uschar *public_name;            /* Advertised name */\n  uschar *set_id;                 /* String to set when server as authenticated id */\n  uschar *set_client_id;          /* String to set when client as client_authenticated id */\n  uschar *mail_auth_condition;    /* Condition for AUTH on MAIL command */\n  uschar *server_debug_string;    /* Debugging output */\n  uschar *server_condition;       /* Authorization condition */\n  BOOL    client;                 /* TRUE if client option(s) set */\n  BOOL    server;                 /* TRUE if server options(s) set */\n  BOOL    advertised;             /* Set TRUE when advertised */\n}\n- SPAAuthResponse: typedef struct\n{\n       char         ident[8];\n       uint32x         msgType;\n       SPAStrHeader    lmResponse;\n       SPAStrHeader    ntResponse;\n       SPAStrHeader    uDomain;\n       SPAStrHeader    uUser;\n       SPAStrHeader    uWks;\n       SPAStrHeader    sessionKey;\n       uint32x         flags;\n       uint8x         buffer[1024];\n       uint32x         bufIndex;\n}\n\nImports:\n- #include \"../exim.h\"\n- #include \"spa.h\"",
    "commit_msg": "Rework SPA fix to avoid overflows.  Bug 2571\n\nAmends: 57aa14b216",
    "cve_desc": "Exim through 4.93 has an out-of-bounds read in the SPA authenticator that could result in SPA/NTLM authentication bypass in auths/spa.c and auths/auth-spa.c.",
    "year": 2020,
    "filename": "spa.c",
    "commit_url": "\"https://github.com/Exim/exim/commit/a04174dc2a84ae1008c23b6a7109e7fa3fb7b8b0\""
  },
  {
    "repository": "bonzini/qemu",
    "cve_id": "CVE-2020-12829",
    "cwe_list": [
      "CWE-190"
    ],
    "commit_hash": "b15a22bbcbe6a78dc3d88fe3134985e4cdd87de4",
    "short_hash": "b15a22bb",
    "vulnerableMethods_before": [
      {
        "filename": "hw/display/sm501.c",
        "method_name": "sm501_2d_operation",
        "raw_code": "static void sm501_2d_operation(SM501State *s) /* <=== sm501_2d_operation */ \n{\n    int cmd = (s->twoD_control >> 16) & 0x1F;\n    int rtl = s->twoD_control & BIT(27);\n    int format = (s->twoD_stretch >> 20) & 0x3;\n    int rop_mode = (s->twoD_control >> 15) & 0x1; /* 1 for rop2, else rop3 */\n    /* 1 if rop2 source is the pattern, otherwise the source is the bitmap */\n    int rop2_source_is_pattern = (s->twoD_control >> 14) & 0x1;\n    int rop = s->twoD_control & 0xFF;\n    int dst_x = (s->twoD_destination >> 16) & 0x01FFF;\n    int dst_y = s->twoD_destination & 0xFFFF;\n    int width = (s->twoD_dimension >> 16) & 0x1FFF;\n    int height = s->twoD_dimension & 0xFFFF;\n    uint32_t dst_base = s->twoD_destination_base & 0x03FFFFFF;\n    uint8_t *dst = s->local_mem + dst_base;\n    int dst_pitch = (s->twoD_pitch >> 16) & 0x1FFF;\n    int crt = (s->dc_crt_control & SM501_DC_CRT_CONTROL_SEL) ? 1 : 0;\n    int fb_len = get_width(s, crt) * get_height(s, crt) * get_bpp(s, crt);\n\n    if ((s->twoD_stretch >> 16) & 0xF) {\n        qemu_log_mask(LOG_UNIMP, \"sm501: only XY addressing is supported.\\n\");\n        return;\n    }\n\n    if (rop_mode == 0) {\n        if (rop != 0xcc) {\n            /* Anything other than plain copies are not supported */\n            qemu_log_mask(LOG_UNIMP, \"sm501: rop3 mode with rop %x is not \"\n                          \"supported.\\n\", rop);\n        }\n    } else {\n        if (rop2_source_is_pattern && rop != 0x5) {\n            /* For pattern source, we support only inverse dest */\n            qemu_log_mask(LOG_UNIMP, \"sm501: rop2 source being the pattern and \"\n                          \"rop %x is not supported.\\n\", rop);\n        } else {\n            if (rop != 0x5 && rop != 0xc) {\n                /* Anything other than plain copies or inverse dest is not\n                 * supported */\n                qemu_log_mask(LOG_UNIMP, \"sm501: rop mode %x is not \"\n                              \"supported.\\n\", rop);\n            }\n        }\n    }\n\n    if (s->twoD_source_base & BIT(27) || s->twoD_destination_base & BIT(27)) {\n        qemu_log_mask(LOG_UNIMP, \"sm501: only local memory is supported.\\n\");\n        return;\n    }\n\n    switch (cmd) {\n    case 0x00: /* copy area */\n    {\n        int src_x = (s->twoD_source >> 16) & 0x01FFF;\n        int src_y = s->twoD_source & 0xFFFF;\n        uint32_t src_base = s->twoD_source_base & 0x03FFFFFF;\n        uint8_t *src = s->local_mem + src_base;\n        int src_pitch = s->twoD_pitch & 0x1FFF;\n\n#define COPY_AREA(_bpp, _pixel_type, rtl) {                                   \\\n        int y, x, index_d, index_s;                                           \\\n        for (y = 0; y < height; y++) {                              \\\n            for (x = 0; x < width; x++) {                           \\\n                _pixel_type val;                                              \\\n                                                                              \\\n                if (rtl) {                                                    \\\n                    index_s = ((src_y - y) * src_pitch + src_x - x) * _bpp;   \\\n                    index_d = ((dst_y - y) * dst_pitch + dst_x - x) * _bpp;   \\\n                } else {                                                      \\\n                    index_s = ((src_y + y) * src_pitch + src_x + x) * _bpp;   \\\n                    index_d = ((dst_y + y) * dst_pitch + dst_x + x) * _bpp;   \\\n                }                                                             \\\n                if (rop_mode == 1 && rop == 5) {                              \\\n                    /* Invert dest */                                         \\\n                    val = ~*(_pixel_type *)&dst[index_d];                     \\\n                } else {                                                      \\\n                    val = *(_pixel_type *)&src[index_s];                      \\\n                }                                                             \\\n                *(_pixel_type *)&dst[index_d] = val;                          \\\n            }                                                                 \\\n        }                                                                     \\\n    }\n        switch (format) {\n        case 0:\n            COPY_AREA(1, uint8_t, rtl);\n            break;\n        case 1:\n            COPY_AREA(2, uint16_t, rtl);\n            break;\n        case 2:\n            COPY_AREA(4, uint32_t, rtl);\n            break;\n        }\n        break;\n    }\n    case 0x01: /* fill rectangle */\n    {\n        uint32_t color = s->twoD_foreground;\n\n#define FILL_RECT(_bpp, _pixel_type) {                                      \\\n        int y, x;                                                           \\\n        for (y = 0; y < height; y++) {                            \\\n            for (x = 0; x < width; x++) {                         \\\n                int index = ((dst_y + y) * dst_pitch + dst_x + x) * _bpp;   \\\n                *(_pixel_type *)&dst[index] = (_pixel_type)color;           \\\n            }                                                               \\\n        }                                                                   \\\n    }\n\n        switch (format) {\n        case 0:\n            FILL_RECT(1, uint8_t);\n            break;\n        case 1:\n            color = cpu_to_le16(color);\n            FILL_RECT(2, uint16_t);\n            break;\n        case 2:\n            color = cpu_to_le32(color);\n            FILL_RECT(4, uint32_t);\n            break;\n        }\n        break;\n    }\n    default:\n        qemu_log_mask(LOG_UNIMP, \"sm501: not implemented 2D operation: %d\\n\",\n                      cmd);\n        return;\n    }\n\n    if (dst_base >= get_fb_addr(s, crt) &&\n        dst_base <= get_fb_addr(s, crt) + fb_len) {\n        int dst_len = MIN(fb_len, ((dst_y + height - 1) * dst_pitch +\n                          dst_x + width) * (1 << format));\n        if (dst_len) {\n            memory_region_set_dirty(&s->local_mem_region, dst_base, dst_len);\n        }\n    }\n}",
        "start_line": 700
      },
      {
        "filename": "hw/display/sm501.c",
        "method_name": "COPY_AREA",
        "raw_code": "#define COPY_AREA(_bpp, _pixel_type, rtl) {                                   \\ /* <=== hw/display/sm501.c:759:781:COPY_AREA:3 */ \n        int y, x, index_d, index_s;                                           \\\n        for (y = 0; y < height; y++) {                              \\\n            for (x = 0; x < width; x++) {                           \\\n                _pixel_type val;                                              \\\n                                                                              \\\n                if (rtl) {                                                    \\\n                    index_s = ((src_y - y) * src_pitch + src_x - x) * _bpp;   \\\n                    index_d = ((dst_y - y) * dst_pitch + dst_x - x) * _bpp;   \\\n                } else {                                                      \\\n                    index_s = ((src_y + y) * src_pitch + src_x + x) * _bpp;   \\\n                    index_d = ((dst_y + y) * dst_pitch + dst_x + x) * _bpp;   \\\n                }                                                             \\\n                if (rop_mode == 1 && rop == 5) {                              \\\n                    /* Invert dest */                                         \\\n                    val = ~*(_pixel_type *)&dst[index_d];                     \\\n                } else {                                                      \\\n                    val = *(_pixel_type *)&src[index_s];                      \\\n                }                                                             \\\n                *(_pixel_type *)&dst[index_d] = val;                          \\\n            }                                                                 \\\n        }                                                                     \\\n    }",
        "start_line": 759
      },
      {
        "filename": "hw/display/sm501.c",
        "method_name": "FILL_RECT",
        "raw_code": "#define FILL_RECT(_bpp, _pixel_type) {                                      \\ /* <=== hw/display/sm501.c:799:807:FILL_RECT:2 */ \n        int y, x;                                                           \\\n        for (y = 0; y < height; y++) {                            \\\n            for (x = 0; x < width; x++) {                         \\\n                int index = ((dst_y + y) * dst_pitch + dst_x + x) * _bpp;   \\\n                *(_pixel_type *)&dst[index] = (_pixel_type)color;           \\\n            }                                                               \\\n        }                                                                   \\\n    }",
        "start_line": 799
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "hw/display/sm501.c",
        "method_name": "sm501_2d_operation",
        "raw_code": "static void sm501_2d_operation(SM501State *s) /* <=== sm501_2d_operation */ \n{\n    int cmd = (s->twoD_control >> 16) & 0x1F;\n    int rtl = s->twoD_control & BIT(27);\n    int format = (s->twoD_stretch >> 20) & 0x3;\n    int rop_mode = (s->twoD_control >> 15) & 0x1; /* 1 for rop2, else rop3 */\n    /* 1 if rop2 source is the pattern, otherwise the source is the bitmap */\n    int rop2_source_is_pattern = (s->twoD_control >> 14) & 0x1;\n    int rop = s->twoD_control & 0xFF;\n    unsigned int dst_x = (s->twoD_destination >> 16) & 0x01FFF;\n    unsigned int dst_y = s->twoD_destination & 0xFFFF;\n    unsigned int width = (s->twoD_dimension >> 16) & 0x1FFF;\n    unsigned int height = s->twoD_dimension & 0xFFFF;\n    uint32_t dst_base = s->twoD_destination_base & 0x03FFFFFF;\n    unsigned int dst_pitch = (s->twoD_pitch >> 16) & 0x1FFF;\n    int crt = (s->dc_crt_control & SM501_DC_CRT_CONTROL_SEL) ? 1 : 0;\n    int fb_len = get_width(s, crt) * get_height(s, crt) * get_bpp(s, crt);\n\n    if ((s->twoD_stretch >> 16) & 0xF) {\n        qemu_log_mask(LOG_UNIMP, \"sm501: only XY addressing is supported.\\n\");\n        return;\n    }\n\n    if (s->twoD_source_base & BIT(27) || s->twoD_destination_base & BIT(27)) {\n        qemu_log_mask(LOG_UNIMP, \"sm501: only local memory is supported.\\n\");\n        return;\n    }\n\n    if (!dst_pitch) {\n        qemu_log_mask(LOG_GUEST_ERROR, \"sm501: Zero dest pitch.\\n\");\n        return;\n    }\n\n    if (!width || !height) {\n        qemu_log_mask(LOG_GUEST_ERROR, \"sm501: Zero size 2D op.\\n\");\n        return;\n    }\n\n    if (rtl) {\n        dst_x -= width - 1;\n        dst_y -= height - 1;\n    }\n\n    if (dst_base >= get_local_mem_size(s) || dst_base +\n        (dst_x + width + (dst_y + height) * (dst_pitch + width)) *\n        (1 << format) >= get_local_mem_size(s)) {\n        qemu_log_mask(LOG_GUEST_ERROR, \"sm501: 2D op dest is outside vram.\\n\");\n        return;\n    }\n\n    switch (cmd) {\n    case 0: /* BitBlt */\n    {\n        unsigned int src_x = (s->twoD_source >> 16) & 0x01FFF;\n        unsigned int src_y = s->twoD_source & 0xFFFF;\n        uint32_t src_base = s->twoD_source_base & 0x03FFFFFF;\n        unsigned int src_pitch = s->twoD_pitch & 0x1FFF;\n\n        if (!src_pitch) {\n            qemu_log_mask(LOG_GUEST_ERROR, \"sm501: Zero src pitch.\\n\");\n            return;\n        }\n\n        if (rtl) {\n            src_x -= width - 1;\n            src_y -= height - 1;\n        }\n\n        if (src_base >= get_local_mem_size(s) || src_base +\n            (src_x + width + (src_y + height) * (src_pitch + width)) *\n            (1 << format) >= get_local_mem_size(s)) {\n            qemu_log_mask(LOG_GUEST_ERROR,\n                          \"sm501: 2D op src is outside vram.\\n\");\n            return;\n        }\n\n        if ((rop_mode && rop == 0x5) || (!rop_mode && rop == 0x55)) {\n            /* Invert dest, is there a way to do this with pixman? */\n            unsigned int x, y, i;\n            uint8_t *d = s->local_mem + dst_base;\n\n            for (y = 0; y < height; y++) {\n                i = (dst_x + (dst_y + y) * dst_pitch) * (1 << format);\n                for (x = 0; x < width; x++, i += (1 << format)) {\n                    switch (format) {\n                    case 0:\n                        d[i] = ~d[i];\n                        break;\n                    case 1:\n                        *(uint16_t *)&d[i] = ~*(uint16_t *)&d[i];\n                        break;\n                    case 2:\n                        *(uint32_t *)&d[i] = ~*(uint32_t *)&d[i];\n                        break;\n                    }\n                }\n            }\n        } else {\n            /* Do copy src for unimplemented ops, better than unpainted area */\n            if ((rop_mode && (rop != 0xc || rop2_source_is_pattern)) ||\n                (!rop_mode && rop != 0xcc)) {\n                qemu_log_mask(LOG_UNIMP,\n                              \"sm501: rop%d op %x%s not implemented\\n\",\n                              (rop_mode ? 2 : 3), rop,\n                              (rop2_source_is_pattern ?\n                                  \" with pattern source\" : \"\"));\n            }\n            /* Check for overlaps, this could be made more exact */\n            uint32_t sb, se, db, de;\n            sb = src_base + src_x + src_y * (width + src_pitch);\n            se = sb + width + height * (width + src_pitch);\n            db = dst_base + dst_x + dst_y * (width + dst_pitch);\n            de = db + width + height * (width + dst_pitch);\n            if (rtl && ((db >= sb && db <= se) || (de >= sb && de <= se))) {\n                /* regions may overlap: copy via temporary */\n                int llb = width * (1 << format);\n                int tmp_stride = DIV_ROUND_UP(llb, sizeof(uint32_t));\n                uint32_t *tmp = g_malloc(tmp_stride * sizeof(uint32_t) *\n                                         height);\n                pixman_blt((uint32_t *)&s->local_mem[src_base], tmp,\n                           src_pitch * (1 << format) / sizeof(uint32_t),\n                           tmp_stride, 8 * (1 << format), 8 * (1 << format),\n                           src_x, src_y, 0, 0, width, height);\n                pixman_blt(tmp, (uint32_t *)&s->local_mem[dst_base],\n                           tmp_stride,\n                           dst_pitch * (1 << format) / sizeof(uint32_t),\n                           8 * (1 << format), 8 * (1 << format),\n                           0, 0, dst_x, dst_y, width, height);\n                g_free(tmp);\n            } else {\n                pixman_blt((uint32_t *)&s->local_mem[src_base],\n                           (uint32_t *)&s->local_mem[dst_base],\n                           src_pitch * (1 << format) / sizeof(uint32_t),\n                           dst_pitch * (1 << format) / sizeof(uint32_t),\n                           8 * (1 << format), 8 * (1 << format),\n                           src_x, src_y, dst_x, dst_y, width, height);\n            }\n        }\n        break;\n    }\n    case 1: /* Rectangle Fill */\n    {\n        uint32_t color = s->twoD_foreground;\n\n        if (format == 2) {\n            color = cpu_to_le32(color);\n        } else if (format == 1) {\n            color = cpu_to_le16(color);\n        }\n\n        pixman_fill((uint32_t *)&s->local_mem[dst_base],\n                    dst_pitch * (1 << format) / sizeof(uint32_t),\n                    8 * (1 << format), dst_x, dst_y, width, height, color);\n        break;\n    }\n    default:\n        qemu_log_mask(LOG_UNIMP, \"sm501: not implemented 2D operation: %d\\n\",\n                      cmd);\n        return;\n    }\n\n    if (dst_base >= get_fb_addr(s, crt) &&\n        dst_base <= get_fb_addr(s, crt) + fb_len) {\n        int dst_len = MIN(fb_len, ((dst_y + height - 1) * dst_pitch +\n                          dst_x + width) * (1 << format));\n        if (dst_len) {\n            memory_region_set_dirty(&s->local_mem_region, dst_base, dst_len);\n        }\n    }\n}",
        "start_line": 700
      }
    ],
    "code_context": "Called Methods:\n- memory_region_set_dirty: void memory_region_set_dirty(MemoryRegion *mr, hwaddr addr, /* <=== memory_region_set_dirty */ \n                             hwaddr size)\n{\n    assert(mr->ram_block);\n    cpu_physical_memory_set_dirty_range(memory_region_get_ram_addr(mr) + addr,\n                                        size,\n                                        memory_region_get_dirty_log_mask(mr));\n}\n- DIV_ROUND_UP: #define DIV_ROUND_UP(n, d) (((n) + (d) - 1) / (d)) /* <=== include/qemu/osdep.h:282:282:DIV_ROUND_UP:2 */ \n- g_malloc_n: void *g_malloc_n(size_t nmemb, size_t size) /* <=== g_malloc_n */ \n{\n    size_t sz;\n    void *ptr;\n\n    __coverity_negative_sink__(nmemb);\n    __coverity_negative_sink__(size);\n    sz = nmemb * size;\n    ptr = __coverity_alloc__(sz);\n    __coverity_mark_as_uninitialized_buffer__(ptr);\n    __coverity_mark_as_afm_allocated__(ptr, \"g_free\");\n    return ptr;\n}\n- memory_region_get_dirty_log_mask: uint8_t memory_region_get_dirty_log_mask(MemoryRegion *mr) /* <=== memory_region_get_dirty_log_mask */ \n{\n    uint8_t mask = mr->dirty_log_mask;\n    if (global_dirty_log && mr->ram_block) {\n        mask |= (1 << DIRTY_MEMORY_MIGRATION);\n    }\n    return mask;\n}\n- get_bpp: static inline int get_bpp(SM501State *s, int crt) /* <=== get_bpp */ \n{\n    int bpp = crt ? s->dc_crt_control : s->dc_panel_control;\n    return 1 << (bpp & 3);\n}\n- g_free: void g_free(void *ptr) /* <=== g_free */ \n{\n    __coverity_free__(ptr);\n    __coverity_mark_as_afm_freed__(ptr, \"g_free\");\n}\n- MIN: #define MIN(a, b) (((a) < (b)) ? (a) : (b)) /* <=== include/qemu/osdep.h:240:240:MIN:2 */ \n- memory_region_get_ram_addr: ram_addr_t memory_region_get_ram_addr(MemoryRegion *mr) /* <=== memory_region_get_ram_addr */ \n{\n    return mr->ram_block ? mr->ram_block->offset : RAM_ADDR_INVALID;\n}\n- qemu_log_mask: #define qemu_log_mask(MASK, FMT, ...)                   \\ /* <=== include/qemu/log.h:117:122:qemu_log_mask:3 */ \n    do {                                                \\\n        if (unlikely(qemu_loglevel_mask(MASK))) {       \\\n            qemu_log(FMT, ## __VA_ARGS__);              \\\n        }                                               \\\n    } while (0)\n- g_malloc: void *g_malloc(size_t size) /* <=== g_malloc */ \n{\n    return g_malloc_n(1, size);\n}\n- get_height: static inline int get_height(SM501State *s, int crt) /* <=== get_height */ \n{\n    int height = crt ? s->dc_crt_v_total : s->dc_panel_v_total;\n    return (height & 0x00000FFF) + 1;\n}\n- SM501_DC_CRT_CONTROL_SEL: #define SM501_DC_CRT_CONTROL_SEL        (1 << 9) /* <=== hw/display/sm501.c:370:370:SM501_DC_CRT_CONTROL_SEL:0 */ \n- get_local_mem_size: #define get_local_mem_size(s) sm501_mem_local_size[(s)->local_mem_size_index] /* <=== hw/display/sm501.c:473:473:get_local_mem_size:1 */ \n- get_width: static inline int get_width(SM501State *s, int crt) /* <=== get_width */ \n{\n    int width = crt ? s->dc_crt_h_total : s->dc_panel_h_total;\n    return (width & 0x00000FFF) + 1;\n}\n- glue: static void glue(draw_line8_, PIXEL_NAME)( /* <=== glue */ \n- qemu_loglevel_mask: static inline bool qemu_loglevel_mask(int mask) /* <=== qemu_loglevel_mask */ \n{\n    return (qemu_loglevel & mask) != 0;\n}\n- get_fb_addr: static ram_addr_t get_fb_addr(SM501State *s, int crt) /* <=== get_fb_addr */ \n{\n    return (crt ? s->dc_crt_fb_addr : s->dc_panel_fb_addr) & 0x3FFFFF0;\n}\n- cpu_to_le32: CPU_CONVERT(le, 32, uint32_t) /* <=== cpu_to_le32 */ \n- cpu_to_le16: CPU_CONVERT(le, 16, uint16_t) /* <=== cpu_to_le16 */ \n- BIT: #define BIT(nr)                 (1UL << (nr)) /* <=== include/qemu/bitops.h:22:22:BIT:1 */ \n\nType Definitions:\n- uint8_t: typedef unsigned char uint8_t;\n- SM501State: typedef struct SM501State {\n    /* graphic console status */\n    QemuConsole *con;\n\n    /* status & internal resources */\n    uint32_t local_mem_size_index;\n    uint8_t *local_mem;\n    MemoryRegion local_mem_region;\n    MemoryRegion mmio_region;\n    MemoryRegion system_config_region;\n    MemoryRegion i2c_region;\n    MemoryRegion disp_ctrl_region;\n    MemoryRegion twoD_engine_region;\n    uint32_t last_width;\n    uint32_t last_height;\n    bool do_full_update; /* perform a full update next time */\n    I2CBus *i2c_bus;\n\n    /* mmio registers */\n    uint32_t system_control;\n    uint32_t misc_control;\n    uint32_t gpio_31_0_control;\n    uint32_t gpio_63_32_control;\n    uint32_t dram_control;\n    uint32_t arbitration_control;\n    uint32_t irq_mask;\n    uint32_t misc_timing;\n    uint32_t power_mode_control;\n\n    uint8_t i2c_byte_count;\n    uint8_t i2c_status;\n    uint8_t i2c_addr;\n    uint8_t i2c_data[16];\n\n    uint32_t uart0_ier;\n    uint32_t uart0_lcr;\n    uint32_t uart0_mcr;\n    uint32_t uart0_scr;\n\n    uint8_t dc_palette[DC_PALETTE_ENTRIES];\n\n    uint32_t dc_panel_control;\n    uint32_t dc_panel_panning_control;\n    uint32_t dc_panel_fb_addr;\n    uint32_t dc_panel_fb_offset;\n    uint32_t dc_panel_fb_width;\n    uint32_t dc_panel_fb_height;\n    uint32_t dc_panel_tl_location;\n    uint32_t dc_panel_br_location;\n    uint32_t dc_panel_h_total;\n    uint32_t dc_panel_h_sync;\n    uint32_t dc_panel_v_total;\n    uint32_t dc_panel_v_sync;\n\n    uint32_t dc_panel_hwc_addr;\n    uint32_t dc_panel_hwc_location;\n    uint32_t dc_panel_hwc_color_1_2;\n    uint32_t dc_panel_hwc_color_3;\n\n    uint32_t dc_video_control;\n\n    uint32_t dc_crt_control;\n    uint32_t dc_crt_fb_addr;\n    uint32_t dc_crt_fb_offset;\n    uint32_t dc_crt_h_total;\n    uint32_t dc_crt_h_sync;\n    uint32_t dc_crt_v_total;\n    uint32_t dc_crt_v_sync;\n\n    uint32_t dc_crt_hwc_addr;\n    uint32_t dc_crt_hwc_location;\n    uint32_t dc_crt_hwc_color_1_2;\n    uint32_t dc_crt_hwc_color_3;\n\n    uint32_t twoD_source;\n    uint32_t twoD_destination;\n    uint32_t twoD_dimension;\n    uint32_t twoD_control;\n    uint32_t twoD_pitch;\n    uint32_t twoD_foreground;\n    uint32_t twoD_background;\n    uint32_t twoD_stretch;\n    uint32_t twoD_color_compare;\n    uint32_t twoD_color_compare_mask;\n    uint32_t twoD_mask;\n    uint32_t twoD_clip_tl;\n    uint32_t twoD_clip_br;\n    uint32_t twoD_mono_pattern_low;\n    uint32_t twoD_mono_pattern_high;\n    uint32_t twoD_window_width;\n    uint32_t twoD_source_base;\n    uint32_t twoD_destination_base;\n    uint32_t twoD_alpha;\n    uint32_t twoD_wrap;\n}\n- uint32_t: typedef unsigned int uint32_t;\n\nGlobal Variables:\n- static const uint32_t[] sm501_mem_local_size\n\nImports:\n- #include \"qemu/osdep.h\"\n- #include \"qemu/log.h\"\n- #include \"qapi/error.h\"\n- #include \"hw/char/serial.h\"\n- #include \"ui/pixel_ops.h\"\n- #include \"hw/display/i2c-ddc.h\"\n- #include \"hw/sysbus.h\"\n- #include \"qemu/bswap.h\"\n- #include \"ui/console.h\"\n- #include \"migration/vmstate.h\"\n- #include \"qemu/range.h\"\n- #include \"hw/qdev-properties.h\"\n- #include \"sm501_template.h\"\n- #include \"qemu/module.h\"\n- #include \"hw/i2c/i2c.h\"\n- #include \"hw/pci/pci.h\"\n- #include \"qemu/units.h\"",
    "commit_msg": "sm501: Replace hand written implementation with pixman where possible\n\nBesides being faster this should also prevent malicious guests to\nabuse 2D engine to overwrite data or cause a crash.\n\nSigned-off-by: BALATON Zoltan <balaton@eik.bme.hu>\nMessage-id: 58666389b6cae256e4e972a32c05cf8aa51bffc0.1590089984.git.balaton@eik.bme.hu\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>",
    "cve_desc": "In QEMU through 5.0.0, an integer overflow was found in the SM501 display driver implementation. This flaw occurs in the COPY_AREA macro while handling MMIO write operations through the sm501_2d_engine_write() callback. A local attacker could abuse this flaw to crash the QEMU process in sm501_2d_operation() in hw/display/sm501.c on the host, resulting in a denial of service.",
    "year": 2020,
    "filename": "sm501.c",
    "commit_url": "\"https://github.com/bonzini/qemu/commit/b15a22bbcbe6a78dc3d88fe3134985e4cdd87de4\""
  },
  {
    "repository": "libexif/libexif",
    "cve_id": "CVE-2020-13114",
    "cwe_list": [
      "CWE-703"
    ],
    "commit_hash": "e6a38a1a23ba94d139b1fa2cd4519fdcfe3c9bab",
    "short_hash": "e6a38a1a",
    "vulnerableMethods_before": [
      {
        "filename": "libexif/canon/exif-mnote-data-canon.c",
        "method_name": "exif_mnote_data_canon_load",
        "raw_code": "static void /* <=== exif_mnote_data_canon_load */ \nexif_mnote_data_canon_load (ExifMnoteData *ne,\n\tconst unsigned char *buf, unsigned int buf_size)\n{\n\tExifMnoteDataCanon *n = (ExifMnoteDataCanon *) ne;\n\tExifShort c;\n\tsize_t i, tcount, o, datao;\n\n\tif (!n || !buf || !buf_size) {\n\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteCanon\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\tdatao = 6 + n->offset;\n\tif (CHECKOVERFLOW(datao, buf_size, 2)) {\n\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteCanon\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\n\t/* Read the number of tags */\n\tc = exif_get_short (buf + datao, n->order);\n\tdatao += 2;\n\n\t/* Remove any old entries */\n\texif_mnote_data_canon_clear (n);\n\n\t/* Reserve enough space for all the possible MakerNote tags */\n\tn->entries = exif_mem_alloc (ne->mem, sizeof (MnoteCanonEntry) * c);\n\tif (!n->entries) {\n\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteCanon\", sizeof (MnoteCanonEntry) * c);\n\t\treturn;\n\t}\n\n\t/* Parse the entries */\n\ttcount = 0;\n\tfor (i = c, o = datao; i; --i, o += 12) {\n\t\tsize_t s;\n\n\t\tmemset(&n->entries[tcount], 0, sizeof(MnoteCanonEntry));\n\t\tif (CHECKOVERFLOW(o,buf_size,12)) {\n\t\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t\"ExifMnoteCanon\", \"Short MakerNote\");\n\t\t\tbreak;\n\t\t}\n\n\t\tn->entries[tcount].tag        = exif_get_short (buf + o, n->order);\n\t\tn->entries[tcount].format     = exif_get_short (buf + o + 2, n->order);\n\t\tn->entries[tcount].components = exif_get_long (buf + o + 4, n->order);\n\t\tn->entries[tcount].order      = n->order;\n\n\t\texif_log (ne->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteCanon\",\n\t\t\t\"Loading entry 0x%x ('%s')...\", n->entries[tcount].tag,\n\t\t\t mnote_canon_tag_get_name (n->entries[tcount].tag));\n\n\t\t/* Check if we overflow the multiplication. Use buf_size as the max size for integer overflow detection,\n\t\t * we will check the buffer sizes closer later. */\n\t\tif (\texif_format_get_size (n->entries[tcount].format) &&\n\t\t\tbuf_size / exif_format_get_size (n->entries[tcount].format) < n->entries[tcount].components\n\t\t) {\n\t\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifMnoteCanon\", \"Tag size overflow detected (%u * %lu)\", exif_format_get_size (n->entries[tcount].format), n->entries[tcount].components);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Size? If bigger than 4 bytes, the actual data is not\n\t\t * in the entry but somewhere else (offset).\n\t\t */\n\t\ts = exif_format_get_size (n->entries[tcount].format) * \n\t\t\t\t\t\t\t\t  n->entries[tcount].components;\n\t\tn->entries[tcount].size = s;\n\t\tif (!s) {\n\t\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifMnoteCanon\",\n\t\t\t\t  \"Invalid zero-length tag size\");\n\t\t\tcontinue;\n\n\t\t} else {\n\t\t\tsize_t dataofs = o + 8;\n\t\t\tif (s > 4) dataofs = exif_get_long (buf + dataofs, n->order) + 6;\n\n\t\t\tif (CHECKOVERFLOW(dataofs, buf_size, s)) {\n\t\t\t\texif_log (ne->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\t\t\"ExifMnoteCanon\",\n\t\t\t\t\t\"Tag data past end of buffer (%u > %u)\",\n\t\t\t\t\t(unsigned)(dataofs + s), buf_size);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tn->entries[tcount].data = exif_mem_alloc (ne->mem, s);\n\t\t\tif (!n->entries[tcount].data) {\n\t\t\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteCanon\", s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmemcpy (n->entries[tcount].data, buf + dataofs, s);\n\t\t}\n\n\t\t/* Tag was successfully parsed */\n\t\t++tcount;\n\t}\n\t/* Store the count of successfully parsed tags */\n\tn->count = tcount;\n}",
        "start_line": 200
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "libexif/canon/exif-mnote-data-canon.c",
        "method_name": "exif_mnote_data_canon_load",
        "raw_code": "static void /* <=== exif_mnote_data_canon_load */ \nexif_mnote_data_canon_load (ExifMnoteData *ne,\n\tconst unsigned char *buf, unsigned int buf_size)\n{\n\tExifMnoteDataCanon *n = (ExifMnoteDataCanon *) ne;\n\tExifShort c;\n\tsize_t i, tcount, o, datao;\n\tlong failsafe_size = 0;\n\n\tif (!n || !buf || !buf_size) {\n\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteCanon\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\tdatao = 6 + n->offset;\n\tif (CHECKOVERFLOW(datao, buf_size, 2)) {\n\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteCanon\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\n\t/* Read the number of tags */\n\tc = exif_get_short (buf + datao, n->order);\n\tdatao += 2;\n\n\t/* Remove any old entries */\n\texif_mnote_data_canon_clear (n);\n\n\t/* Reserve enough space for all the possible MakerNote tags */\n\tn->entries = exif_mem_alloc (ne->mem, sizeof (MnoteCanonEntry) * c);\n\tif (!n->entries) {\n\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteCanon\", sizeof (MnoteCanonEntry) * c);\n\t\treturn;\n\t}\n\n\t/* Parse the entries */\n\ttcount = 0;\n\tfor (i = c, o = datao; i; --i, o += 12) {\n\t\tsize_t s;\n\n\t\tmemset(&n->entries[tcount], 0, sizeof(MnoteCanonEntry));\n\t\tif (CHECKOVERFLOW(o,buf_size,12)) {\n\t\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t\"ExifMnoteCanon\", \"Short MakerNote\");\n\t\t\tbreak;\n\t\t}\n\n\t\tn->entries[tcount].tag        = exif_get_short (buf + o, n->order);\n\t\tn->entries[tcount].format     = exif_get_short (buf + o + 2, n->order);\n\t\tn->entries[tcount].components = exif_get_long (buf + o + 4, n->order);\n\t\tn->entries[tcount].order      = n->order;\n\n\t\texif_log (ne->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteCanon\",\n\t\t\t\"Loading entry 0x%x ('%s')...\", n->entries[tcount].tag,\n\t\t\t mnote_canon_tag_get_name (n->entries[tcount].tag));\n\n\t\t/* Check if we overflow the multiplication. Use buf_size as the max size for integer overflow detection,\n\t\t * we will check the buffer sizes closer later. */\n\t\tif (\texif_format_get_size (n->entries[tcount].format) &&\n\t\t\tbuf_size / exif_format_get_size (n->entries[tcount].format) < n->entries[tcount].components\n\t\t) {\n\t\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifMnoteCanon\", \"Tag size overflow detected (%u * %lu)\", exif_format_get_size (n->entries[tcount].format), n->entries[tcount].components);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Size? If bigger than 4 bytes, the actual data is not\n\t\t * in the entry but somewhere else (offset).\n\t\t */\n\t\ts = exif_format_get_size (n->entries[tcount].format) * \n\t\t\t\t\t\t\t\t  n->entries[tcount].components;\n\t\tn->entries[tcount].size = s;\n\t\tif (!s) {\n\t\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifMnoteCanon\",\n\t\t\t\t  \"Invalid zero-length tag size\");\n\t\t\tcontinue;\n\n\t\t} else {\n\t\t\tsize_t dataofs = o + 8;\n\t\t\tif (s > 4) dataofs = exif_get_long (buf + dataofs, n->order) + 6;\n\n\t\t\tif (CHECKOVERFLOW(dataofs, buf_size, s)) {\n\t\t\t\texif_log (ne->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\t\t\"ExifMnoteCanon\",\n\t\t\t\t\t\"Tag data past end of buffer (%u > %u)\",\n\t\t\t\t\t(unsigned)(dataofs + s), buf_size);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tn->entries[tcount].data = exif_mem_alloc (ne->mem, s);\n\t\t\tif (!n->entries[tcount].data) {\n\t\t\t\tEXIF_LOG_NO_MEMORY(ne->log, \"ExifMnoteCanon\", s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmemcpy (n->entries[tcount].data, buf + dataofs, s);\n\t\t}\n\n\t\t/* Track the size of decoded tag data. A malicious file could\n\t\t * be crafted to cause extremely large values here without\n\t\t * tripping any buffer range checks.  This is especially bad\n\t\t * with the libexif representation of Canon MakerNotes because\n\t\t * some arrays are turned into individual tags that the\n\t\t * application must loop around. */\n\t\tfailsafe_size += mnote_canon_entry_count_values(&n->entries[tcount]);\n\n\t\tif (failsafe_size > FAILSAFE_SIZE_MAX) {\n\t\t\t/* Abort if the total size of the data in the tags extraordinarily large, */\n\t\t\texif_mem_free (ne->mem, n->entries[tcount].data);\n\t\t\texif_log (ne->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t\t  \"ExifMnoteCanon\", \"Failsafe tag size overflow (%lu > %ld)\",\n\t\t\t\t\t  failsafe_size, FAILSAFE_SIZE_MAX);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Tag was successfully parsed */\n\t\t++tcount;\n\t}\n\t/* Store the count of successfully parsed tags */\n\tn->count = tcount;\n}",
        "start_line": 203
      }
    ],
    "code_context": "Called Methods:\n- exif_get_sshort: ExifSShort /* <=== exif_get_sshort */ \nexif_get_sshort (const unsigned char *buf, ExifByteOrder order)\n{\n\tif (!buf) return 0;\n        switch (order) {\n        case EXIF_BYTE_ORDER_MOTOROLA:\n                return ((buf[0] << 8) | buf[1]);\n        case EXIF_BYTE_ORDER_INTEL:\n                return ((buf[1] << 8) | buf[0]);\n        }\n\n\t/* Won't be reached */\n\treturn (0);\n}\n- mnote_canon_entry_count_values: unsigned int /* <=== mnote_canon_entry_count_values */ \nmnote_canon_entry_count_values (const MnoteCanonEntry *entry)\n{\n\tunsigned int  val;\n\n\tif (!entry) return 0;\n\n\tswitch (entry->tag) {\n\tcase MNOTE_CANON_TAG_FOCAL_LENGTH:\n\tcase MNOTE_CANON_TAG_PANORAMA:\n\t\treturn entry->components;\n\tcase MNOTE_CANON_TAG_SETTINGS_1:\n\tcase MNOTE_CANON_TAG_SETTINGS_2:\n\tcase MNOTE_CANON_TAG_CUSTOM_FUNCS:\n\tcase MNOTE_CANON_TAG_COLOR_INFORMATION:\n\t\tif (entry->format != EXIF_FORMAT_SHORT) return 0;\n\n\t\tval = exif_get_short (entry->data, entry->order);\n\t\t/* val is buffer size, i.e. # of values plus 1 */\n\t\treturn MIN (entry->size - 2, val) / 2;\n\tdefault:\n\t\treturn 1;\n\t}\n}\n- exif_get_slong: ExifSLong /* <=== exif_get_slong */ \nexif_get_slong (const unsigned char *b, ExifByteOrder order)\n{\n\tif (!b) return 0;\n        switch (order) {\n        case EXIF_BYTE_ORDER_MOTOROLA:\n                return (((uint32_t)b[0] << 24) | ((uint32_t)b[1] << 16) | ((uint32_t)b[2] << 8) | (uint32_t)b[3]);\n        case EXIF_BYTE_ORDER_INTEL:\n                return (((uint32_t)b[3] << 24) | ((uint32_t)b[2] << 16) | ((uint32_t)b[1] << 8) | (uint32_t)b[0]);\n        }\n\n\t/* Won't be reached */\n\treturn (0);\n}\n- exif_log: void /* <=== exif_log */ \nexif_log (ExifLog *log, ExifLogCode code, const char *domain,\n\t  const char *format, ...)\n{\n\tva_list args;\n\n\tva_start (args, format);\n\texif_logv (log, code, domain, format, args);\n\tva_end (args);\n}\n- CHECKOVERFLOW: #define CHECKOVERFLOW(offset,datasize,structsize) (( offset >= datasize) || (structsize > datasize) || (offset > datasize - structsize )) /* <=== libexif/canon/exif-mnote-data-canon.c:33:33:CHECKOVERFLOW:3 */ \n- FAILSAFE_SIZE_MAX: #define FAILSAFE_SIZE_MAX 1000000L /* <=== libexif/canon/exif-mnote-data-canon.c:36:36:FAILSAFE_SIZE_MAX:0 */ \n- exif_mem_alloc: void *exif_mem_alloc   (ExifMem *m, ExifLong s); /* <=== exif_mem_alloc */ \n- exif_mem_free: void  exif_mem_free    (ExifMem *m, void *p); /* <=== exif_mem_free */ \n- exif_get_long: ExifLong /* <=== exif_get_long */ \nexif_get_long (const unsigned char *buf, ExifByteOrder order)\n{\n        return (exif_get_slong (buf, order) & 0xffffffff);\n}\n- exif_get_short: ExifShort /* <=== exif_get_short */ \nexif_get_short (const unsigned char *buf, ExifByteOrder order)\n{\n\treturn (exif_get_sshort (buf, order) & 0xffff);\n}\n- mnote_canon_tag_get_name: const char * /* <=== mnote_canon_tag_get_name */ \nmnote_canon_tag_get_name (MnoteCanonTag t)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < sizeof (table) / sizeof (table[0]); i++)\n\t\tif (table[i].tag == t) return table[i].name; /* do not translate */\n\treturn NULL;\n}\n- exif_logv: void /* <=== exif_logv */ \nexif_logv (ExifLog *log, ExifLogCode code, const char *domain,\n\t   const char *format, va_list args)\n{\n\tif (!log) return;\n\tif (!log->func) return;\n\tlog->func (log, code, domain, format, args, log->data);\n}\n- exif_format_get_size: unsigned char exif_format_get_size (ExifFormat format); /* <=== exif_format_get_size */ \n\nType Definitions:\n- ExifMnoteData: typedef struct _ExifMnoteData ExifMnoteData;\n- ExifShort: typedef uint16_t\tExifShort;\n- ExifMnoteDataCanon: typedef struct _ExifMnoteDataCanon ExifMnoteDataCanon;\n- MnoteCanonEntry: typedef struct _MnoteCanonEntry        MnoteCanonEntry;\n\nImports:\n- #include <libexif/exif-data.h>\n- #include <config.h>\n- #include <stdio.h>\n- #include <stdlib.h>\n- #include <libexif/exif-utils.h>\n- #include \"exif-mnote-data-canon.h\"\n- #include <string.h>\n- #include <libexif/exif-byte-order.h>",
    "commit_msg": "Add a failsafe on the maximum number of Canon MakerNote subtags.\n\nA malicious file could be crafted to cause extremely large values in some\ntags without tripping any buffer range checks.  This is bad with the libexif\nrepresentation of Canon MakerNotes because some arrays are turned into\nindividual tags that the application must loop around.\n\nThe largest value I've seen for failsafe_size in a (very small) sample of valid\nCanon files is <5000.  The limit is set two orders of magnitude larger to avoid\ntripping up falsely in case some models use much larger values.\n\nPatch from Google.\n\nCVE-2020-13114",
    "cve_desc": "An issue was discovered in libexif before 0.6.22. An unrestricted size in handling Canon EXIF MakerNote data could lead to consumption of large amounts of compute time for decoding EXIF data.",
    "year": 2020,
    "filename": "exif-mnote-data-canon.c",
    "commit_url": "\"https://github.com/libexif/libexif/commit/e6a38a1a23ba94d139b1fa2cd4519fdcfe3c9bab\""
  },
  {
    "repository": "mariadb-corporation/mariadb-connector-c",
    "cve_id": "CVE-2020-13249",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "2759b87d72926b7c9b5426437a7c8dd15ff57945",
    "short_hash": "2759b87d",
    "vulnerableMethods_before": [
      {
        "filename": "libmariadb/mariadb_lib.c",
        "method_name": "ma_read_ok_packet",
        "raw_code": "int ma_read_ok_packet(MYSQL *mysql, uchar *pos, ulong length) /* <=== ma_read_ok_packet */ \n{\n  size_t item_len;\n  mysql->affected_rows= net_field_length_ll(&pos);\n  mysql->insert_id=\t  net_field_length_ll(&pos);\n  mysql->server_status=uint2korr(pos);\n  pos+=2;\n  mysql->warning_count=uint2korr(pos);\n  pos+=2;\n  if (pos < mysql->net.read_pos+length)\n  {\n    if ((item_len= net_field_length(&pos)))\n      mysql->info=(char*) pos;\n\n    /* check if server supports session tracking */\n    if (mysql->server_capabilities & CLIENT_SESSION_TRACKING)\n    {\n      ma_clear_session_state(mysql);\n      pos+= item_len;\n\n      if (mysql->server_status & SERVER_SESSION_STATE_CHANGED)\n      {\n        int i;\n        if (pos < mysql->net.read_pos + length)\n        {\n          LIST *session_item;\n          MYSQL_LEX_STRING *str= NULL;\n          enum enum_session_state_type si_type;\n          uchar *old_pos= pos;\n          size_t item_len= net_field_length(&pos);  /* length for all items */\n\n          /* length was already set, so make sure that info will be zero terminated */\n          if (mysql->info)\n            *old_pos= 0;\n\n          while (item_len > 0)\n          {\n            size_t plen;\n            char *data;\n            old_pos= pos;\n            si_type= (enum enum_session_state_type)net_field_length(&pos);\n            switch(si_type) {\n            case SESSION_TRACK_SCHEMA:\n            case SESSION_TRACK_STATE_CHANGE:\n            case SESSION_TRACK_TRANSACTION_CHARACTERISTICS:\n            case SESSION_TRACK_SYSTEM_VARIABLES:\n              if (si_type != SESSION_TRACK_STATE_CHANGE)\n                net_field_length(&pos); /* ignore total length, item length will follow next */\n              plen= net_field_length(&pos);\n              if (!(session_item= ma_multi_malloc(0,\n                                  &session_item, sizeof(LIST),\n                                  &str, sizeof(MYSQL_LEX_STRING),\n                                  &data, plen,\n                                  NULL)))\n              {\n                ma_clear_session_state(mysql);\n                SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);\n                return -1;\n              }\n              str->length= plen;\n              str->str= data;\n              memcpy(str->str, (char *)pos, plen);\n              pos+= plen;\n              session_item->data= str;\n              mysql->extension->session_state[si_type].list= list_add(mysql->extension->session_state[si_type].list, session_item);\n\n              /* in case schema has changed, we have to update mysql->db */\n              if (si_type == SESSION_TRACK_SCHEMA)\n              {\n                free(mysql->db);\n                mysql->db= malloc(plen + 1);\n                memcpy(mysql->db, str->str, plen);\n                mysql->db[plen]= 0;\n              }\n              else if (si_type == SESSION_TRACK_SYSTEM_VARIABLES)\n              {\n                my_bool set_charset= 0;\n                /* make sure that we update charset in case it has changed */\n                if (!strncmp(str->str, \"character_set_client\", str->length))\n                  set_charset= 1;\n                plen= net_field_length(&pos);\n                if (!(session_item= ma_multi_malloc(0,\n                                    &session_item, sizeof(LIST),\n                                    &str, sizeof(MYSQL_LEX_STRING),\n                                    &data, plen,\n                                    NULL)))\n                {\n                  ma_clear_session_state(mysql);\n                  SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);\n                  return -1;\n                }\n                str->length= plen;\n                str->str= data;\n                memcpy(str->str, (char *)pos, plen);\n                pos+= plen;\n                session_item->data= str;\n                mysql->extension->session_state[si_type].list= list_add(mysql->extension->session_state[si_type].list, session_item);\n                if (set_charset &&\n                    strncmp(mysql->charset->csname, str->str, str->length) != 0)\n                {\n                  char cs_name[64];\n                  MARIADB_CHARSET_INFO *cs_info;\n                  memcpy(cs_name, str->str, str->length);\n                  cs_name[str->length]= 0;\n                  if ((cs_info = (MARIADB_CHARSET_INFO *)mysql_find_charset_name(cs_name)))\n                    mysql->charset= cs_info;\n                }\n              }\n              break;\n            default:\n              /* not supported yet */\n              plen= net_field_length(&pos);\n              pos+= plen;\n              break;\n            }\n            item_len-= (pos - old_pos);\n          }\n        }\n        for (i= SESSION_TRACK_BEGIN; i <= SESSION_TRACK_END; i++)\n        {\n          mysql->extension->session_state[i].list= list_reverse(mysql->extension->session_state[i].list);\n          mysql->extension->session_state[i].current= mysql->extension->session_state[i].list;\n        }\n      }\n    }\n  }\n  /* CONC-351: clear session state information */\n  else if (mysql->server_capabilities & CLIENT_SESSION_TRACKING)\n    ma_clear_session_state(mysql);\n  return(0);\n}",
        "start_line": 2140
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "libmariadb/mariadb_lib.c",
        "method_name": "ma_read_ok_packet",
        "raw_code": "int ma_read_ok_packet(MYSQL *mysql, uchar *pos, ulong length) /* <=== ma_read_ok_packet */ \n{\n  uchar *end= mysql->net.read_pos+length;\n  size_t item_len;\n  mysql->affected_rows= net_field_length_ll(&pos);\n  mysql->insert_id=\t  net_field_length_ll(&pos);\n  mysql->server_status=uint2korr(pos);\n  pos+=2;\n  mysql->warning_count=uint2korr(pos);\n  pos+=2;\n  if (pos > end)\n    goto corrupted;\n  if (pos < end)\n  {\n    if ((item_len= net_field_length(&pos)))\n      mysql->info=(char*) pos;\n    if (pos + item_len > end)\n      goto corrupted;\n\n    /* check if server supports session tracking */\n    if (mysql->server_capabilities & CLIENT_SESSION_TRACKING)\n    {\n      ma_clear_session_state(mysql);\n      pos+= item_len;\n\n      if (mysql->server_status & SERVER_SESSION_STATE_CHANGED)\n      {\n        int i;\n        if (pos < end)\n        {\n          LIST *session_item;\n          MYSQL_LEX_STRING *str= NULL;\n          enum enum_session_state_type si_type;\n          uchar *old_pos= pos;\n\n          item_len= net_field_length(&pos);  /* length for all items */\n          if (pos + item_len > end)\n            goto corrupted;\n          end= pos + item_len;\n\n          /* length was already set, so make sure that info will be zero terminated */\n          if (mysql->info)\n            *old_pos= 0;\n\n          while (pos < end)\n          {\n            size_t plen;\n            char *data;\n            si_type= (enum enum_session_state_type)net_field_length(&pos);\n            switch(si_type) {\n            case SESSION_TRACK_SCHEMA:\n            case SESSION_TRACK_STATE_CHANGE:\n            case SESSION_TRACK_TRANSACTION_CHARACTERISTICS:\n            case SESSION_TRACK_SYSTEM_VARIABLES:\n              if (si_type != SESSION_TRACK_STATE_CHANGE)\n                net_field_length(&pos); /* ignore total length, item length will follow next */\n              plen= net_field_length(&pos);\n              if (pos + plen > end)\n                goto corrupted;\n              if (!(session_item= ma_multi_malloc(0,\n                                  &session_item, sizeof(LIST),\n                                  &str, sizeof(MYSQL_LEX_STRING),\n                                  &data, plen,\n                                  NULL)))\n                  goto oom;\n              str->length= plen;\n              str->str= data;\n              memcpy(str->str, (char *)pos, plen);\n              pos+= plen;\n              session_item->data= str;\n              mysql->extension->session_state[si_type].list= list_add(mysql->extension->session_state[si_type].list, session_item);\n\n              /* in case schema has changed, we have to update mysql->db */\n              if (si_type == SESSION_TRACK_SCHEMA)\n              {\n                free(mysql->db);\n                mysql->db= malloc(plen + 1);\n                memcpy(mysql->db, str->str, plen);\n                mysql->db[plen]= 0;\n              }\n              else if (si_type == SESSION_TRACK_SYSTEM_VARIABLES)\n              {\n                my_bool set_charset= 0;\n                /* make sure that we update charset in case it has changed */\n                if (!strncmp(str->str, \"character_set_client\", str->length))\n                  set_charset= 1;\n                plen= net_field_length(&pos);\n                if (pos + plen > end)\n                  goto corrupted;\n                if (!(session_item= ma_multi_malloc(0,\n                                    &session_item, sizeof(LIST),\n                                    &str, sizeof(MYSQL_LEX_STRING),\n                                    &data, plen,\n                                    NULL)))\n                  goto oom;\n                str->length= plen;\n                str->str= data;\n                memcpy(str->str, (char *)pos, plen);\n                pos+= plen;\n                session_item->data= str;\n                mysql->extension->session_state[si_type].list= list_add(mysql->extension->session_state[si_type].list, session_item);\n                if (set_charset && str->length < CHARSET_NAME_LEN &&\n                    strncmp(mysql->charset->csname, str->str, str->length) != 0)\n                {\n                  char cs_name[CHARSET_NAME_LEN];\n                  const MARIADB_CHARSET_INFO *cs_info;\n                  memcpy(cs_name, str->str, str->length);\n                  cs_name[str->length]= 0;\n                  if ((cs_info = mysql_find_charset_name(cs_name)))\n                    mysql->charset= cs_info;\n                }\n              }\n              break;\n            default:\n              /* not supported yet */\n              plen= net_field_length(&pos);\n              if (pos + plen > end)\n                goto corrupted;\n              pos+= plen;\n              break;\n            }\n          }\n        }\n        for (i= SESSION_TRACK_BEGIN; i <= SESSION_TRACK_END; i++)\n        {\n          mysql->extension->session_state[i].list= list_reverse(mysql->extension->session_state[i].list);\n          mysql->extension->session_state[i].current= mysql->extension->session_state[i].list;\n        }\n      }\n    }\n  }\n  /* CONC-351: clear session state information */\n  else if (mysql->server_capabilities & CLIENT_SESSION_TRACKING)\n    ma_clear_session_state(mysql);\n  return(0);\n\noom:\n  ma_clear_session_state(mysql);\n  SET_CLIENT_ERROR(mysql, CR_OUT_OF_MEMORY, SQLSTATE_UNKNOWN, 0);\n  return -1;\n\ncorrupted:\n  ma_clear_session_state(mysql);\n  SET_CLIENT_ERROR(mysql, CR_MALFORMED_PACKET, SQLSTATE_UNKNOWN, 0);\n  return -1;\n}",
        "start_line": 2142
      }
    ],
    "code_context": "Called Methods:\n- NULL_LENGTH: #define NULL_LENGTH ((unsigned long) ~0) /* For net_store_length */ /* <=== include/mariadb_com.h:458:458:NULL_LENGTH:0 */ \n- SESSION_TRACK_TYPES: #define SESSION_TRACK_TYPES SESSION_TRACK_END + 1 /* <=== include/mariadb_com.h:319:319:SESSION_TRACK_TYPES:0 */ \n- list_reverse: extern LIST *list_reverse(LIST *root); /* <=== list_reverse */ \n- SESSION_TRACK_BEGIN: #define SESSION_TRACK_BEGIN 0 /* <=== include/mariadb_com.h:317:317:SESSION_TRACK_BEGIN:0 */ \n- net_field_length: ulong /* <=== net_field_length */ \nnet_field_length(uchar **packet)\n{\n  reg1 uchar *pos= *packet;\n  if (*pos < 251)\n  {\n    (*packet)++;\n    return (ulong) *pos;\n  }\n  if (*pos == 251)\n  {\n    (*packet)++;\n    return NULL_LENGTH;\n  }\n  if (*pos == 252)\n  {\n    (*packet)+=3;\n    return (ulong) uint2korr(pos+1);\n  }\n  if (*pos == 253)\n  {\n    (*packet)+=4;\n    return (ulong) uint3korr(pos+1);\n  }\n  (*packet)+=9;\t\t\t\t\t/* Must be 254 when here */\n  return (ulong) uint4korr(pos+1);\n}\n- SERVER_SESSION_STATE_CHANGED: #define SERVER_SESSION_STATE_CHANGED     16384 /* <=== include/mariadb_com.h:236:236:SERVER_SESSION_STATE_CHANGED:0 */ \n- list_add: extern LIST *list_add(LIST *root,LIST *element); /* <=== list_add */ \n- ma_clear_session_state: static void ma_clear_session_state(MYSQL *mysql) /* <=== ma_clear_session_state */ \n{\n  uint i;\n\n  if (!mysql || !mysql->extension)\n    return;\n\n  for (i= SESSION_TRACK_BEGIN; i <= SESSION_TRACK_END; i++)\n  {\n    list_free(mysql->extension->session_state[i].list, 0);\n  }\n  memset(mysql->extension->session_state, 0, sizeof(struct st_mariadb_session_state) * SESSION_TRACK_TYPES);\n}\n- net_field_length_ll: static unsigned long long /* <=== net_field_length_ll */ \nnet_field_length_ll(uchar **packet)\n{\n  reg1 uchar *pos= *packet;\n  if (*pos < 251)\n  {\n    (*packet)++;\n    return (unsigned long long) *pos;\n  }\n  if (*pos == 251)\n  {\n    (*packet)++;\n    return (unsigned long long) NULL_LENGTH;\n  }\n  if (*pos == 252)\n  {\n    (*packet)+=3;\n    return (unsigned long long) uint2korr(pos+1);\n  }\n  if (*pos == 253)\n  {\n    (*packet)+=4;\n    return (unsigned long long) uint3korr(pos+1);\n  }\n  (*packet)+=9;\t\t\t\t\t/* Must be 254 when here */\n#ifdef NO_CLIENT_LONGLONG\n  return (unsigned long long) uint4korr(pos+1);\n#else\n  return (unsigned long long) uint8korr(pos+1);\n#endif\n}\n- mysql_find_charset_name: MARIADB_CHARSET_INFO * mysql_find_charset_name(const char *name) /* <=== mysql_find_charset_name */ \n{\n  MARIADB_CHARSET_INFO *c = (MARIADB_CHARSET_INFO *)mariadb_compiled_charsets;\n  const char *csname;\n\n  if (!strcasecmp(name, MADB_AUTODETECT_CHARSET_NAME))\n    csname= madb_get_os_character_set();\n  else\n    csname= (char *)name;\n\n  do {\n    if (!strcasecmp(c->csname, csname)) {\n      return(c);\n    }\n    ++c;\n  } while (c[0].nr != 0);\n  return(NULL);\n}\n- madb_get_os_character_set: const char *madb_get_os_character_set() /* <=== madb_get_os_character_set */ \n{\n  unsigned int i= 0;\n  char *p= NULL;\n#ifdef _WIN32\n  char codepage[FN_REFLEN];\n  snprintf(codepage, FN_REFLEN, \"%u\", GetACP());\n  p= codepage;\n#elif defined(HAVE_NL_LANGINFO) && defined(HAVE_SETLOCALE)\n  if (setlocale(LC_CTYPE, \"\"))\n    p= nl_langinfo(CODESET);\n#endif\n  if (!p)\n    return MADB_DEFAULT_CHARSET_NAME;\n  while (MADB_OS_CHARSET[i].identifier)\n  {\n    if (MADB_OS_CHARSET[i].supported > MADB_CS_UNSUPPORTED &&\n        strcasecmp(MADB_OS_CHARSET[i].identifier, p) == 0)\n      return MADB_OS_CHARSET[i].charset;\n    i++;\n  }\n  return MADB_DEFAULT_CHARSET_NAME;\n}\n- SESSION_TRACK_END: #define SESSION_TRACK_END SESSION_TRACK_TRANSACTION_TYPE /* <=== include/mariadb_com.h:318:318:SESSION_TRACK_END:0 */ \n- CHARSET_NAME_LEN: #define CHARSET_NAME_LEN 64 /* <=== libmariadb/mariadb_lib.c:84:84:CHARSET_NAME_LEN:0 */ \n- list_free: extern void list_free(LIST *root,unsigned int free_data); /* <=== list_free */ \n- SET_CLIENT_ERROR: #define SET_CLIENT_ERROR(a, b, c, d) \\ /* <=== include/mysql.h:132:139:SET_CLIENT_ERROR:4 */ \n  { \\\n    (a)->net.last_errno= (b);\\\n    strncpy((a)->net.sqlstate, (c), SQLSTATE_LENGTH);\\\n    (a)->net.sqlstate[SQLSTATE_LENGTH]= 0;\\\n    strncpy((a)->net.last_error, (d) ? (d) : ER((b)), MYSQL_ERRMSG_SIZE - 1);\\\n    (a)->net.last_error[MYSQL_ERRMSG_SIZE - 1]= 0;\\\n  }\n- CLIENT_SESSION_TRACKING: #define CLIENT_SESSION_TRACKING  (1UL << 23) /* <=== include/mariadb_com.h:162:162:CLIENT_SESSION_TRACKING:0 */ \n- ma_multi_malloc: void *ma_multi_malloc(myf myFlags, ...) /* <=== ma_multi_malloc */ \n{\n  va_list args;\n  char **ptr,*start,*res;\n  size_t tot_length,length;\n\n  va_start(args,myFlags);\n  tot_length=0;\n  while ((ptr=va_arg(args, char **)))\n  {\n    length=va_arg(args, size_t);\n    tot_length+=ALIGN_SIZE(length);\n  }\n  va_end(args);\n\n  if (!(start=(char *)malloc(tot_length)))\n    return 0;\n\n  va_start(args,myFlags);\n  res=start;\n  while ((ptr=va_arg(args, char **)))\n  {\n    *ptr=res;\n    length=va_arg(args,size_t);\n    res+=ALIGN_SIZE(length);\n  }\n  va_end(args);\n  return start;\n}\n\nType Definitions:\n- st_list: typedef struct st_list {\n  struct st_list *prev,*next;\n  void *data;\n}\n- ulong: typedef unsigned long\tulong;\n- LIST: typedef struct st_list {\n  struct st_list *prev,*next;\n  void *data;\n} LIST;\n- uchar: typedef unsigned char\tuchar;\n- MARIADB_CHARSET_INFO: typedef struct ma_charset_info_st\n{\n  unsigned int\tnr; /* so far only 1 byte for charset */\n  unsigned int  state;\n  const char\t*csname;\n  const char\t*name;\n  const char  *dir;\n  unsigned int codepage;\n  const char  *encoding;\n  unsigned int\tchar_minlen;\n  unsigned int\tchar_maxlen;\n  unsigned int \t(*mb_charlen)(unsigned int c);\n  unsigned int \t(*mb_valid)(const char *start, const char *end);\n} MARIADB_CHARSET_INFO;\n- my_bool: typedef char\t\tmy_bool;\n- enum_session_state_type: enum enum_session_state_type\n{\n  SESSION_TRACK_SYSTEM_VARIABLES= 0,\n  SESSION_TRACK_SCHEMA,\n  SESSION_TRACK_STATE_CHANGE,\n  /* currently not supported by MariaDB Server */\n  SESSION_TRACK_GTIDS,\n  SESSION_TRACK_TRANSACTION_CHARACTERISTICS,\n  SESSION_TRACK_TRANSACTION_TYPE /* make sure that SESSION_TRACK_END always points\n                                    to last element of enum !! */\n}\n- MYSQL: typedef struct st_mysql {\n    NET\t\tnet;\t\t\t/* Communication parameters */\n    void  *unused_0;\n    char *host,*user,*passwd,*unix_socket,*server_version,*host_info;\n    char *info,*db;\n    const struct ma_charset_info_st *charset;      /* character set */\n    MYSQL_FIELD *fields;\n    MA_MEM_ROOT field_alloc;\n    unsigned long long affected_rows;\n    unsigned long long insert_id;\t\t/* id if insert on table with NEXTNR */\n    unsigned long long extra_info;\t\t/* Used by mysqlshow */\n    unsigned long thread_id;\t\t/* Id for connection in server */\n    unsigned long packet_length;\n    unsigned int port;\n    unsigned long client_flag;\n    unsigned long server_capabilities;\n    unsigned int protocol_version;\n    unsigned int field_count;\n    unsigned int server_status;\n    unsigned int server_language;\n    unsigned int warning_count;          /* warning count, added in 4.1 protocol */\n    struct st_mysql_options options;\n    enum mysql_status status;\n    my_bool\tfree_me;\t\t/* If free in mysql_close */\n    my_bool\tunused_1;\n    char\t        scramble_buff[20+ 1];\n    /* madded after 3.23.58 */\n    my_bool       unused_2;\n    void          *unused_3, *unused_4, *unused_5, *unused_6;\n    LIST          *stmts;\n    const struct  st_mariadb_methods *methods;\n    void          *thd;\n    my_bool       *unbuffered_fetch_owner;\n    char          *info_buffer;\n    struct st_mariadb_extension *extension;\n} MYSQL;\n- ma_charset_info_st: typedef struct ma_charset_info_st\n{\n  unsigned int\tnr; /* so far only 1 byte for charset */\n  unsigned int  state;\n  const char\t*csname;\n  const char\t*name;\n  const char  *dir;\n  unsigned int codepage;\n  const char  *encoding;\n  unsigned int\tchar_minlen;\n  unsigned int\tchar_maxlen;\n  unsigned int \t(*mb_charlen)(unsigned int c);\n  unsigned int \t(*mb_valid)(const char *start, const char *end);\n}\n- MYSQL_LEX_STRING: typedef struct st_mysql_lex_string MYSQL_LEX_STRING;\n\nImports:\n- #include <signal.h>\n- #include <netinet/in.h>\n- #include \"mariadb_version.h\"\n- #include <arpa/inet.h>\n- #include <mariadb/ma_io.h>\n- #include <sys/socket.h>\n- #  include <sys/un.h>\n- #include \"ma_server_error.h\"\n- #  include <select.h>\n- #include <netdb.h>\n- #include \"mysql.h\"\n- #include \"ma_context.h\"\n- #include <sys/select.h>\n- #include \"Shlwapi.h\"\n- #include <pwd.h>\n- #include <ma_pvio.h>\n- #include <ma_sha1.h>\n- #include <poll.h>\n- #include \"ma_priv.h\"\n- #include <ma_global.h>\n- #include <time.h>\n- #include <ma_tls.h>\n- #include <mariadb_dyncol.h>\n- #include <sys/stat.h>\n- #include <ma_string.h>\n- #include <mysql/client_plugin.h>\n- #include <ma_sys.h>\n- #include <errno.h>\n- #include <mariadb_ctype.h>\n- #include \"errmsg.h\"\n- #include <ma_common.h>",
    "commit_msg": "sanity checks for client-supplied OK packet content\n\nreported by Matthias Kaiser, Apple Information Security",
    "cve_desc": "libmariadb/mariadb_lib.c in MariaDB Connector/C before 3.1.8 does not properly validate the content of an OK packet received from a server. NOTE: although mariadb_lib.c was originally based on code shipped for MySQL, this issue does not affect any MySQL components supported by Oracle.",
    "year": 2020,
    "filename": "mariadb_lib.c",
    "commit_url": "\"https://github.com/mariadb-corporation/mariadb-connector-c/commit/2759b87d72926b7c9b5426437a7c8dd15ff57945\""
  },
  {
    "repository": "FreeRDP/FreeRDP",
    "cve_id": "CVE-2020-13396",
    "cwe_list": [
      "CWE-125"
    ],
    "commit_hash": "48361c411e50826cb602c7aab773a8a20e1da6bc",
    "short_hash": "48361c41",
    "vulnerableMethods_before": [
      {
        "filename": "winpr/libwinpr/sspi/NTLM/ntlm_message.c",
        "method_name": "ntlm_read_ChallengeMessage",
        "raw_code": "SECURITY_STATUS ntlm_read_ChallengeMessage(NTLM_CONTEXT* context, PSecBuffer buffer) /* <=== ntlm_read_ChallengeMessage */ \n{\n\twStream* s;\n\tint length;\n\tPBYTE StartOffset;\n\tPBYTE PayloadOffset;\n\tNTLM_AV_PAIR* AvTimestamp;\n\tNTLM_CHALLENGE_MESSAGE* message;\n\tntlm_generate_client_challenge(context);\n\tmessage = &context->CHALLENGE_MESSAGE;\n\tZeroMemory(message, sizeof(NTLM_CHALLENGE_MESSAGE));\n\ts = Stream_New((BYTE*)buffer->pvBuffer, buffer->cbBuffer);\n\n\tif (!s)\n\t\treturn SEC_E_INTERNAL_ERROR;\n\n\tStartOffset = Stream_Pointer(s);\n\n\tif (ntlm_read_message_header(s, (NTLM_MESSAGE_HEADER*)message) < 0)\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tif (message->MessageType != MESSAGE_TYPE_CHALLENGE)\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tif (ntlm_read_message_fields(s, &(message->TargetName)) < 0) /* TargetNameFields (8 bytes) */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tStream_Read_UINT32(s, message->NegotiateFlags); /* NegotiateFlags (4 bytes) */\n\tcontext->NegotiateFlags = message->NegotiateFlags;\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tStream_Read(s, message->ServerChallenge, 8); /* ServerChallenge (8 bytes) */\n\tCopyMemory(context->ServerChallenge, message->ServerChallenge, 8);\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tStream_Read(s, message->Reserved, 8); /* Reserved (8 bytes), should be ignored */\n\n\tif (ntlm_read_message_fields(s, &(message->TargetInfo)) < 0) /* TargetInfoFields (8 bytes) */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tif (context->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t{\n\t\tif (ntlm_read_version_info(s, &(message->Version)) < 0) /* Version (8 bytes) */\n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\treturn SEC_E_INVALID_TOKEN;\n\t\t}\n\t}\n\n\t/* Payload (variable) */\n\tPayloadOffset = Stream_Pointer(s);\n\n\tif (message->TargetName.Len > 0)\n\t{\n\t\tif (ntlm_read_message_fields_buffer(s, &(message->TargetName)) < 0)\n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\treturn SEC_E_INTERNAL_ERROR;\n\t\t}\n\t}\n\n\tif (message->TargetInfo.Len > 0)\n\t{\n\t\tsize_t cbAvTimestamp;\n\n\t\tif (ntlm_read_message_fields_buffer(s, &(message->TargetInfo)) < 0)\n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\treturn SEC_E_INTERNAL_ERROR;\n\t\t}\n\n\t\tcontext->ChallengeTargetInfo.pvBuffer = message->TargetInfo.Buffer;\n\t\tcontext->ChallengeTargetInfo.cbBuffer = message->TargetInfo.Len;\n\t\tAvTimestamp = ntlm_av_pair_get((NTLM_AV_PAIR*)message->TargetInfo.Buffer,\n\t\t                               message->TargetInfo.Len, MsvAvTimestamp, &cbAvTimestamp);\n\n\t\tif (AvTimestamp)\n\t\t{\n\t\t\tPBYTE ptr = ntlm_av_pair_get_value_pointer(AvTimestamp);\n\n\t\t\tif (!ptr)\n\t\t\t\treturn SEC_E_INTERNAL_ERROR;\n\n\t\t\tif (context->NTLMv2)\n\t\t\t\tcontext->UseMIC = TRUE;\n\n\t\t\tCopyMemory(context->ChallengeTimestamp, ptr, 8);\n\t\t}\n\t}\n\n\tlength = (PayloadOffset - StartOffset) + message->TargetName.Len + message->TargetInfo.Len;\n\n\tif (!sspi_SecBufferAlloc(&context->ChallengeMessage, length))\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\n\tCopyMemory(context->ChallengeMessage.pvBuffer, StartOffset, length);\n#ifdef WITH_DEBUG_NTLM\n\tWLog_DBG(TAG, \"CHALLENGE_MESSAGE (length = %d)\", length);\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ChallengeMessage.pvBuffer,\n\t              context->ChallengeMessage.cbBuffer);\n\tntlm_print_negotiate_flags(context->NegotiateFlags);\n\n\tif (context->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t\tntlm_print_version_info(&(message->Version));\n\n\tntlm_print_message_fields(&(message->TargetName), \"TargetName\");\n\tntlm_print_message_fields(&(message->TargetInfo), \"TargetInfo\");\n\n\tif (context->ChallengeTargetInfo.cbBuffer > 0)\n\t{\n\t\tWLog_DBG(TAG, \"ChallengeTargetInfo (%\" PRIu32 \"):\", context->ChallengeTargetInfo.cbBuffer);\n\t\tntlm_print_av_pair_list(context->ChallengeTargetInfo.pvBuffer,\n\t\t                        context->ChallengeTargetInfo.cbBuffer);\n\t}\n\n#endif\n\t/* AV_PAIRs */\n\n\tif (context->NTLMv2)\n\t{\n\t\tif (ntlm_construct_authenticate_target_info(context) < 0)\n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\treturn SEC_E_INTERNAL_ERROR;\n\t\t}\n\n\t\tsspi_SecBufferFree(&context->ChallengeTargetInfo);\n\t\tcontext->ChallengeTargetInfo.pvBuffer = context->AuthenticateTargetInfo.pvBuffer;\n\t\tcontext->ChallengeTargetInfo.cbBuffer = context->AuthenticateTargetInfo.cbBuffer;\n\t}\n\n\tntlm_generate_timestamp(context); /* Timestamp */\n\n\tif (ntlm_compute_lm_v2_response(context) < 0) /* LmChallengeResponse */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\n\tif (ntlm_compute_ntlm_v2_response(context) < 0) /* NtChallengeResponse */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\n\tntlm_generate_key_exchange_key(context);     /* KeyExchangeKey */\n\tntlm_generate_random_session_key(context);   /* RandomSessionKey */\n\tntlm_generate_exported_session_key(context); /* ExportedSessionKey */\n\tntlm_encrypt_random_session_key(context);    /* EncryptedRandomSessionKey */\n\t/* Generate signing keys */\n\tntlm_generate_client_signing_key(context);\n\tntlm_generate_server_signing_key(context);\n\t/* Generate sealing keys */\n\tntlm_generate_client_sealing_key(context);\n\tntlm_generate_server_sealing_key(context);\n\t/* Initialize RC4 seal state using client sealing key */\n\tntlm_init_rc4_seal_states(context);\n#ifdef WITH_DEBUG_NTLM\n\tWLog_DBG(TAG, \"ClientChallenge\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ClientChallenge, 8);\n\tWLog_DBG(TAG, \"ServerChallenge\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ServerChallenge, 8);\n\tWLog_DBG(TAG, \"SessionBaseKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->SessionBaseKey, 16);\n\tWLog_DBG(TAG, \"KeyExchangeKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->KeyExchangeKey, 16);\n\tWLog_DBG(TAG, \"ExportedSessionKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ExportedSessionKey, 16);\n\tWLog_DBG(TAG, \"RandomSessionKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->RandomSessionKey, 16);\n\tWLog_DBG(TAG, \"ClientSigningKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ClientSigningKey, 16);\n\tWLog_DBG(TAG, \"ClientSealingKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ClientSealingKey, 16);\n\tWLog_DBG(TAG, \"ServerSigningKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ServerSigningKey, 16);\n\tWLog_DBG(TAG, \"ServerSealingKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ServerSealingKey, 16);\n\tWLog_DBG(TAG, \"Timestamp\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->Timestamp, 8);\n#endif\n\tcontext->state = NTLM_STATE_AUTHENTICATE;\n\tntlm_free_message_fields_buffer(&(message->TargetName));\n\tStream_Free(s, FALSE);\n\treturn SEC_I_CONTINUE_NEEDED;\n}",
        "start_line": 368
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "winpr/libwinpr/sspi/NTLM/ntlm_message.c",
        "method_name": "ntlm_read_ChallengeMessage",
        "raw_code": "SECURITY_STATUS ntlm_read_ChallengeMessage(NTLM_CONTEXT* context, PSecBuffer buffer) /* <=== ntlm_read_ChallengeMessage */ \n{\n\tSECURITY_STATUS status = SEC_E_INVALID_TOKEN;\n\twStream* s;\n\tsize_t length;\n\tsize_t StartOffset;\n\tsize_t PayloadOffset;\n\tNTLM_AV_PAIR* AvTimestamp;\n\tNTLM_CHALLENGE_MESSAGE* message;\n\tif (!context || !buffer)\n\t\treturn SEC_E_INTERNAL_ERROR;\n\n\tntlm_generate_client_challenge(context);\n\tmessage = &context->CHALLENGE_MESSAGE;\n\tZeroMemory(message, sizeof(NTLM_CHALLENGE_MESSAGE));\n\ts = Stream_New((BYTE*)buffer->pvBuffer, buffer->cbBuffer);\n\n\tif (!s)\n\t\treturn SEC_E_INTERNAL_ERROR;\n\n\tStartOffset = Stream_GetPosition(s);\n\n\tif (ntlm_read_message_header(s, (NTLM_MESSAGE_HEADER*)message) < 0)\n\t\tgoto fail;\n\n\tif (message->MessageType != MESSAGE_TYPE_CHALLENGE)\n\t\tgoto fail;\n\n\tif (ntlm_read_message_fields(s, &(message->TargetName)) < 0) /* TargetNameFields (8 bytes) */\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\tgoto fail;\n\n\tStream_Read_UINT32(s, message->NegotiateFlags); /* NegotiateFlags (4 bytes) */\n\tcontext->NegotiateFlags = message->NegotiateFlags;\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\tgoto fail;\n\n\tStream_Read(s, message->ServerChallenge, 8); /* ServerChallenge (8 bytes) */\n\tCopyMemory(context->ServerChallenge, message->ServerChallenge, 8);\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\tgoto fail;\n\n\tStream_Read(s, message->Reserved, 8); /* Reserved (8 bytes), should be ignored */\n\n\tif (ntlm_read_message_fields(s, &(message->TargetInfo)) < 0) /* TargetInfoFields (8 bytes) */\n\t\tgoto fail;\n\n\tif (context->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t{\n\t\tif (ntlm_read_version_info(s, &(message->Version)) < 0) /* Version (8 bytes) */\n\t\t\tgoto fail;\n\t}\n\n\t/* Payload (variable) */\n\tPayloadOffset = Stream_GetPosition(s);\n\n\tstatus = SEC_E_INTERNAL_ERROR;\n\tif (message->TargetName.Len > 0)\n\t{\n\t\tif (ntlm_read_message_fields_buffer(s, &(message->TargetName)) < 0)\n\t\t\tgoto fail;\n\t}\n\n\tif (message->TargetInfo.Len > 0)\n\t{\n\t\tsize_t cbAvTimestamp;\n\n\t\tif (ntlm_read_message_fields_buffer(s, &(message->TargetInfo)) < 0)\n\t\t\tgoto fail;\n\n\t\tcontext->ChallengeTargetInfo.pvBuffer = message->TargetInfo.Buffer;\n\t\tcontext->ChallengeTargetInfo.cbBuffer = message->TargetInfo.Len;\n\t\tAvTimestamp = ntlm_av_pair_get((NTLM_AV_PAIR*)message->TargetInfo.Buffer,\n\t\t                               message->TargetInfo.Len, MsvAvTimestamp, &cbAvTimestamp);\n\n\t\tif (AvTimestamp)\n\t\t{\n\t\t\tPBYTE ptr = ntlm_av_pair_get_value_pointer(AvTimestamp);\n\n\t\t\tif (!ptr)\n\t\t\t\tgoto fail;\n\n\t\t\tif (context->NTLMv2)\n\t\t\t\tcontext->UseMIC = TRUE;\n\n\t\t\tCopyMemory(context->ChallengeTimestamp, ptr, 8);\n\t\t}\n\t}\n\n\tlength = (PayloadOffset - StartOffset) + message->TargetName.Len + message->TargetInfo.Len;\n\tif (length > buffer->cbBuffer)\n\t\tgoto fail;\n\n\tif (!sspi_SecBufferAlloc(&context->ChallengeMessage, length))\n\t\tgoto fail;\n\n\tif (context->ChallengeMessage.pvBuffer)\n\t\tCopyMemory(context->ChallengeMessage.pvBuffer, Stream_Buffer(s) + StartOffset, length);\n#ifdef WITH_DEBUG_NTLM\n\tWLog_DBG(TAG, \"CHALLENGE_MESSAGE (length = %d)\", length);\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ChallengeMessage.pvBuffer,\n\t              context->ChallengeMessage.cbBuffer);\n\tntlm_print_negotiate_flags(context->NegotiateFlags);\n\n\tif (context->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t\tntlm_print_version_info(&(message->Version));\n\n\tntlm_print_message_fields(&(message->TargetName), \"TargetName\");\n\tntlm_print_message_fields(&(message->TargetInfo), \"TargetInfo\");\n\n\tif (context->ChallengeTargetInfo.cbBuffer > 0)\n\t{\n\t\tWLog_DBG(TAG, \"ChallengeTargetInfo (%\" PRIu32 \"):\", context->ChallengeTargetInfo.cbBuffer);\n\t\tntlm_print_av_pair_list(context->ChallengeTargetInfo.pvBuffer,\n\t\t                        context->ChallengeTargetInfo.cbBuffer);\n\t}\n\n#endif\n\t/* AV_PAIRs */\n\n\tif (context->NTLMv2)\n\t{\n\t\tif (ntlm_construct_authenticate_target_info(context) < 0)\n\t\t\tgoto fail;\n\n\t\tsspi_SecBufferFree(&context->ChallengeTargetInfo);\n\t\tcontext->ChallengeTargetInfo.pvBuffer = context->AuthenticateTargetInfo.pvBuffer;\n\t\tcontext->ChallengeTargetInfo.cbBuffer = context->AuthenticateTargetInfo.cbBuffer;\n\t}\n\n\tntlm_generate_timestamp(context); /* Timestamp */\n\n\tif (ntlm_compute_lm_v2_response(context) < 0) /* LmChallengeResponse */\n\t\tgoto fail;\n\n\tif (ntlm_compute_ntlm_v2_response(context) < 0) /* NtChallengeResponse */\n\t\tgoto fail;\n\n\tntlm_generate_key_exchange_key(context);     /* KeyExchangeKey */\n\tntlm_generate_random_session_key(context);   /* RandomSessionKey */\n\tntlm_generate_exported_session_key(context); /* ExportedSessionKey */\n\tntlm_encrypt_random_session_key(context);    /* EncryptedRandomSessionKey */\n\t/* Generate signing keys */\n\tntlm_generate_client_signing_key(context);\n\tntlm_generate_server_signing_key(context);\n\t/* Generate sealing keys */\n\tntlm_generate_client_sealing_key(context);\n\tntlm_generate_server_sealing_key(context);\n\t/* Initialize RC4 seal state using client sealing key */\n\tntlm_init_rc4_seal_states(context);\n#ifdef WITH_DEBUG_NTLM\n\tWLog_DBG(TAG, \"ClientChallenge\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ClientChallenge, 8);\n\tWLog_DBG(TAG, \"ServerChallenge\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ServerChallenge, 8);\n\tWLog_DBG(TAG, \"SessionBaseKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->SessionBaseKey, 16);\n\tWLog_DBG(TAG, \"KeyExchangeKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->KeyExchangeKey, 16);\n\tWLog_DBG(TAG, \"ExportedSessionKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ExportedSessionKey, 16);\n\tWLog_DBG(TAG, \"RandomSessionKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->RandomSessionKey, 16);\n\tWLog_DBG(TAG, \"ClientSigningKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ClientSigningKey, 16);\n\tWLog_DBG(TAG, \"ClientSealingKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ClientSealingKey, 16);\n\tWLog_DBG(TAG, \"ServerSigningKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ServerSigningKey, 16);\n\tWLog_DBG(TAG, \"ServerSealingKey\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->ServerSealingKey, 16);\n\tWLog_DBG(TAG, \"Timestamp\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->Timestamp, 8);\n#endif\n\tcontext->state = NTLM_STATE_AUTHENTICATE;\n\tntlm_free_message_fields_buffer(&(message->TargetName));\n\tstatus = SEC_I_CONTINUE_NEEDED;\nfail:\n\tStream_Free(s, FALSE);\n\treturn status;\n}",
        "start_line": 368
      }
    ],
    "code_context": "Called Methods:\n- MSV_AV_FLAGS_MESSAGE_INTEGRITY_CHECK: #define MSV_AV_FLAGS_MESSAGE_INTEGRITY_CHECK 0x00000002 /* <=== winpr/libwinpr/sspi/NTLM/ntlm.h:104:104:MSV_AV_FLAGS_MESSAGE_INTEGRITY_CHECK:0 */ \n- sspi_SecBufferFree: void sspi_SecBufferFree(PSecBuffer SecBuffer) /* <=== sspi_SecBufferFree */ \n{\n\tif (!SecBuffer)\n\t\treturn;\n\n\tif (SecBuffer->pvBuffer)\n\t\tmemset(SecBuffer->pvBuffer, 0, SecBuffer->cbBuffer);\n\n\tfree(SecBuffer->pvBuffer);\n\tSecBuffer->pvBuffer = NULL;\n\tSecBuffer->cbBuffer = 0;\n}\n- ntlm_generate_signing_key: static int ntlm_generate_signing_key(BYTE* exported_session_key, PSecBuffer sign_magic, /* <=== ntlm_generate_signing_key */ \n                                     BYTE* signing_key)\n{\n\tint length;\n\tBYTE* value;\n\tlength = WINPR_MD5_DIGEST_LENGTH + sign_magic->cbBuffer;\n\tvalue = (BYTE*)malloc(length);\n\n\tif (!value)\n\t\treturn -1;\n\n\t/* Concatenate ExportedSessionKey with sign magic */\n\tCopyMemory(value, exported_session_key, WINPR_MD5_DIGEST_LENGTH);\n\tCopyMemory(&value[WINPR_MD5_DIGEST_LENGTH], sign_magic->pvBuffer, sign_magic->cbBuffer);\n\n\tif (!winpr_Digest(WINPR_MD_MD5, value, length, signing_key, WINPR_MD5_DIGEST_LENGTH))\n\t{\n\t\tfree(value);\n\t\treturn -1;\n\t}\n\n\tfree(value);\n\treturn 1;\n}\n- ntlm_encrypt_random_session_key: void ntlm_encrypt_random_session_key(NTLM_CONTEXT* context) /* <=== ntlm_encrypt_random_session_key */ \n{\n\t/* In NTLMv2, EncryptedRandomSessionKey is the ExportedSessionKey RC4-encrypted with the\n\t * KeyExchangeKey */\n\tntlm_rc4k(context->KeyExchangeKey, 16, context->RandomSessionKey,\n\t          context->EncryptedRandomSessionKey);\n}\n- ntlm_generate_timestamp: void ntlm_generate_timestamp(NTLM_CONTEXT* context) /* <=== ntlm_generate_timestamp */ \n{\n\tif (memcmp(context->ChallengeTimestamp, NTLM_NULL_BUFFER, 8) != 0)\n\t\tCopyMemory(context->Timestamp, context->ChallengeTimestamp, 8);\n\telse\n\t\tntlm_current_time(context->Timestamp);\n}\n- Stream_New: wStream* Stream_New(BYTE* buffer, size_t size) /* <=== Stream_New */ \n{\n\twStream* s;\n\n\tif (!buffer && !size)\n\t\treturn NULL;\n\n\ts = malloc(sizeof(wStream));\n\tif (!s)\n\t\treturn NULL;\n\n\tif (buffer)\n\t\ts->buffer = buffer;\n\telse\n\t\ts->buffer = (BYTE*)malloc(size);\n\n\tif (!s->buffer)\n\t{\n\t\tfree(s);\n\t\treturn NULL;\n\t}\n\n\ts->pointer = s->buffer;\n\ts->capacity = size;\n\ts->length = size;\n\n\ts->pool = NULL;\n\ts->count = 0;\n\ts->isAllocatedStream = TRUE;\n\ts->isOwner = TRUE;\n\treturn s;\n}\n- winpr_RAND: \tWINPR_API int winpr_RAND(BYTE* output, size_t len); /* <=== winpr_RAND */ \n- ntlm_av_pair_next: static NTLM_AV_PAIR* ntlm_av_pair_next(NTLM_AV_PAIR* pAvPair, size_t* pcbAvPair) /* <=== ntlm_av_pair_next */ \n{\n\tsize_t offset;\n\n\tif (!pcbAvPair)\n\t\treturn NULL;\n\tif (!ntlm_av_pair_check(pAvPair, *pcbAvPair))\n\t\treturn NULL;\n\n\toffset = ntlm_av_pair_get_next_offset(pAvPair);\n\t*pcbAvPair -= offset;\n\treturn (NTLM_AV_PAIR*)((PBYTE)pAvPair + offset);\n}\n- ntlm_read_version_info: int ntlm_read_version_info(wStream* s, NTLM_VERSION_INFO* versionInfo) /* <=== ntlm_read_version_info */ \n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn -1;\n\n\tStream_Read_UINT8(s, versionInfo->ProductMajorVersion); /* ProductMajorVersion (1 byte) */\n\tStream_Read_UINT8(s, versionInfo->ProductMinorVersion); /* ProductMinorVersion (1 byte) */\n\tStream_Read_UINT16(s, versionInfo->ProductBuild);       /* ProductBuild (2 bytes) */\n\tStream_Read(s, versionInfo->Reserved, sizeof(versionInfo->Reserved)); /* Reserved (3 bytes) */\n\tStream_Read_UINT8(s, versionInfo->NTLMRevisionCurrent); /* NTLMRevisionCurrent (1 byte) */\n\treturn 1;\n}\n- winpr_HMAC: \tWINPR_API BOOL winpr_HMAC(WINPR_MD_TYPE md, const BYTE* key, size_t keylen, const BYTE* input, /* <=== winpr_HMAC */ \n\t                          size_t ilen, BYTE* output, size_t olen);\n- ntlm_generate_client_signing_key: void ntlm_generate_client_signing_key(NTLM_CONTEXT* context) /* <=== ntlm_generate_client_signing_key */ \n{\n\tSecBuffer signMagic;\n\tsignMagic.pvBuffer = (void*)NTLM_CLIENT_SIGN_MAGIC;\n\tsignMagic.cbBuffer = sizeof(NTLM_CLIENT_SIGN_MAGIC);\n\tntlm_generate_signing_key(context->ExportedSessionKey, &signMagic, context->ClientSigningKey);\n}\n- ntlm_generate_server_sealing_key: void ntlm_generate_server_sealing_key(NTLM_CONTEXT* context) /* <=== ntlm_generate_server_sealing_key */ \n{\n\tSecBuffer sealMagic;\n\tsealMagic.pvBuffer = (void*)NTLM_SERVER_SEAL_MAGIC;\n\tsealMagic.cbBuffer = sizeof(NTLM_SERVER_SEAL_MAGIC);\n\tntlm_generate_signing_key(context->ExportedSessionKey, &sealMagic, context->ServerSealingKey);\n}\n- ntlm_av_pair_list_init: static BOOL ntlm_av_pair_list_init(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList) /* <=== ntlm_av_pair_list_init */ \n{\n\tNTLM_AV_PAIR* pAvPair = pAvPairList;\n\n\tif (!pAvPair || (cbAvPairList < sizeof(NTLM_AV_PAIR)))\n\t\treturn FALSE;\n\n\tntlm_av_pair_set_id(pAvPair, MsvAvEOL);\n\tntlm_av_pair_set_len(pAvPair, 0);\n\treturn TRUE;\n}\n- ntlm_av_pair_check: static BOOL ntlm_av_pair_check(NTLM_AV_PAIR* pAvPair, size_t cbAvPair) /* <=== ntlm_av_pair_check */ \n{\n\tif (!pAvPair || cbAvPair < sizeof(NTLM_AV_PAIR))\n\t\treturn FALSE;\n\treturn cbAvPair >= ntlm_av_pair_get_next_offset(pAvPair);\n}\n- ntlm_av_pair_add: static BOOL ntlm_av_pair_add(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList, NTLM_AV_ID AvId, /* <=== ntlm_av_pair_add */ \n                             PBYTE Value, UINT16 AvLen)\n{\n\tsize_t cbAvPair;\n\tNTLM_AV_PAIR* pAvPair;\n\n\tpAvPair = ntlm_av_pair_get(pAvPairList, cbAvPairList, MsvAvEOL, &cbAvPair);\n\n\t/* size of header + value length + terminating MsvAvEOL AV_PAIR */\n\tif (!pAvPair || cbAvPair < 2 * sizeof(NTLM_AV_PAIR) + AvLen)\n\t\treturn FALSE;\n\n\tntlm_av_pair_set_id(pAvPair, AvId);\n\tntlm_av_pair_set_len(pAvPair, AvLen);\n\tif (AvLen)\n\t{\n\t\tassert(Value != NULL);\n\t\tCopyMemory(ntlm_av_pair_get_value_pointer(pAvPair), Value, AvLen);\n\t}\n\n\tpAvPair = ntlm_av_pair_next(pAvPair, &cbAvPair);\n\treturn ntlm_av_pair_list_init(pAvPair, cbAvPair);\n}\n- ntlm_generate_random_session_key: void ntlm_generate_random_session_key(NTLM_CONTEXT* context) /* <=== ntlm_generate_random_session_key */ \n{\n\twinpr_RAND(context->RandomSessionKey, 16);\n}\n- ntlm_compute_ntlm_v2_response: int ntlm_compute_ntlm_v2_response(NTLM_CONTEXT* context) /* <=== ntlm_compute_ntlm_v2_response */ \n{\n\tBYTE* blob;\n\tSecBuffer ntlm_v2_temp = { 0 };\n\tSecBuffer ntlm_v2_temp_chal = { 0 };\n\tPSecBuffer TargetInfo = &context->ChallengeTargetInfo;\n\tint ret = -1;\n\n\tif (!sspi_SecBufferAlloc(&ntlm_v2_temp, TargetInfo->cbBuffer + 28))\n\t\tgoto exit;\n\n\tZeroMemory(ntlm_v2_temp.pvBuffer, ntlm_v2_temp.cbBuffer);\n\tblob = (BYTE*)ntlm_v2_temp.pvBuffer;\n\n\t/* Compute the NTLMv2 hash */\n\tif (ntlm_compute_ntlm_v2_hash(context, (BYTE*)context->NtlmV2Hash) < 0)\n\t\tgoto exit;\n\n\t/* Construct temp */\n\tblob[0] = 1; /* RespType (1 byte) */\n\tblob[1] = 1; /* HighRespType (1 byte) */\n\t/* Reserved1 (2 bytes) */\n\t/* Reserved2 (4 bytes) */\n\tCopyMemory(&blob[8], context->Timestamp, 8);        /* Timestamp (8 bytes) */\n\tCopyMemory(&blob[16], context->ClientChallenge, 8); /* ClientChallenge (8 bytes) */\n\t/* Reserved3 (4 bytes) */\n\tCopyMemory(&blob[28], TargetInfo->pvBuffer, TargetInfo->cbBuffer);\n#ifdef WITH_DEBUG_NTLM\n\tWLog_DBG(TAG, \"NTLMv2 Response Temp Blob\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, ntlm_v2_temp.pvBuffer, ntlm_v2_temp.cbBuffer);\n#endif\n\n\t/* Concatenate server challenge with temp */\n\n\tif (!sspi_SecBufferAlloc(&ntlm_v2_temp_chal, ntlm_v2_temp.cbBuffer + 8))\n\t\tgoto exit;\n\n\tblob = (BYTE*)ntlm_v2_temp_chal.pvBuffer;\n\tCopyMemory(blob, context->ServerChallenge, 8);\n\tCopyMemory(&blob[8], ntlm_v2_temp.pvBuffer, ntlm_v2_temp.cbBuffer);\n\twinpr_HMAC(WINPR_MD_MD5, (BYTE*)context->NtlmV2Hash, WINPR_MD5_DIGEST_LENGTH,\n\t           (BYTE*)ntlm_v2_temp_chal.pvBuffer, ntlm_v2_temp_chal.cbBuffer,\n\t           context->NtProofString, WINPR_MD5_DIGEST_LENGTH);\n\n\t/* NtChallengeResponse, Concatenate NTProofStr with temp */\n\n\tif (!sspi_SecBufferAlloc(&context->NtChallengeResponse, ntlm_v2_temp.cbBuffer + 16))\n\t\tgoto exit;\n\n\tblob = (BYTE*)context->NtChallengeResponse.pvBuffer;\n\tCopyMemory(blob, context->NtProofString, WINPR_MD5_DIGEST_LENGTH);\n\tCopyMemory(&blob[16], ntlm_v2_temp.pvBuffer, ntlm_v2_temp.cbBuffer);\n\t/* Compute SessionBaseKey, the HMAC-MD5 hash of NTProofStr using the NTLMv2 hash as the key */\n\twinpr_HMAC(WINPR_MD_MD5, (BYTE*)context->NtlmV2Hash, WINPR_MD5_DIGEST_LENGTH,\n\t           context->NtProofString, WINPR_MD5_DIGEST_LENGTH, context->SessionBaseKey,\n\t           WINPR_MD5_DIGEST_LENGTH);\n\tret = 1;\nexit:\n\tsspi_SecBufferFree(&ntlm_v2_temp);\n\tsspi_SecBufferFree(&ntlm_v2_temp_chal);\n\treturn ret;\n}\n- ntlm_construct_authenticate_target_info: int ntlm_construct_authenticate_target_info(NTLM_CONTEXT* context) /* <=== ntlm_construct_authenticate_target_info */ \n{\n\tULONG size;\n\tULONG AvPairsCount;\n\tULONG AvPairsValueLength;\n\tNTLM_AV_PAIR* AvTimestamp;\n\tNTLM_AV_PAIR* AvNbDomainName;\n\tNTLM_AV_PAIR* AvNbComputerName;\n\tNTLM_AV_PAIR* AvDnsDomainName;\n\tNTLM_AV_PAIR* AvDnsComputerName;\n\tNTLM_AV_PAIR* AvDnsTreeName;\n\tNTLM_AV_PAIR* ChallengeTargetInfo;\n\tNTLM_AV_PAIR* AuthenticateTargetInfo;\n\tsize_t cbAvTimestamp;\n\tsize_t cbAvNbDomainName;\n\tsize_t cbAvNbComputerName;\n\tsize_t cbAvDnsDomainName;\n\tsize_t cbAvDnsComputerName;\n\tsize_t cbAvDnsTreeName;\n\tsize_t cbChallengeTargetInfo;\n\tsize_t cbAuthenticateTargetInfo;\n\tAvPairsCount = 1;\n\tAvPairsValueLength = 0;\n\tChallengeTargetInfo = (NTLM_AV_PAIR*)context->ChallengeTargetInfo.pvBuffer;\n\tcbChallengeTargetInfo = context->ChallengeTargetInfo.cbBuffer;\n\tAvNbDomainName = ntlm_av_pair_get(ChallengeTargetInfo, cbChallengeTargetInfo, MsvAvNbDomainName,\n\t                                  &cbAvNbDomainName);\n\tAvNbComputerName = ntlm_av_pair_get(ChallengeTargetInfo, cbChallengeTargetInfo,\n\t                                    MsvAvNbComputerName, &cbAvNbComputerName);\n\tAvDnsDomainName = ntlm_av_pair_get(ChallengeTargetInfo, cbChallengeTargetInfo,\n\t                                   MsvAvDnsDomainName, &cbAvDnsDomainName);\n\tAvDnsComputerName = ntlm_av_pair_get(ChallengeTargetInfo, cbChallengeTargetInfo,\n\t                                     MsvAvDnsComputerName, &cbAvDnsComputerName);\n\tAvDnsTreeName = ntlm_av_pair_get(ChallengeTargetInfo, cbChallengeTargetInfo, MsvAvDnsTreeName,\n\t                                 &cbAvDnsTreeName);\n\tAvTimestamp = ntlm_av_pair_get(ChallengeTargetInfo, cbChallengeTargetInfo, MsvAvTimestamp,\n\t                               &cbAvTimestamp);\n\n\tif (AvNbDomainName)\n\t{\n\t\tAvPairsCount++; /* MsvAvNbDomainName */\n\t\tAvPairsValueLength += ntlm_av_pair_get_len(AvNbDomainName);\n\t}\n\n\tif (AvNbComputerName)\n\t{\n\t\tAvPairsCount++; /* MsvAvNbComputerName */\n\t\tAvPairsValueLength += ntlm_av_pair_get_len(AvNbComputerName);\n\t}\n\n\tif (AvDnsDomainName)\n\t{\n\t\tAvPairsCount++; /* MsvAvDnsDomainName */\n\t\tAvPairsValueLength += ntlm_av_pair_get_len(AvDnsDomainName);\n\t}\n\n\tif (AvDnsComputerName)\n\t{\n\t\tAvPairsCount++; /* MsvAvDnsComputerName */\n\t\tAvPairsValueLength += ntlm_av_pair_get_len(AvDnsComputerName);\n\t}\n\n\tif (AvDnsTreeName)\n\t{\n\t\tAvPairsCount++; /* MsvAvDnsTreeName */\n\t\tAvPairsValueLength += ntlm_av_pair_get_len(AvDnsTreeName);\n\t}\n\n\tAvPairsCount++; /* MsvAvTimestamp */\n\tAvPairsValueLength += 8;\n\n\tif (context->UseMIC)\n\t{\n\t\tAvPairsCount++; /* MsvAvFlags */\n\t\tAvPairsValueLength += 4;\n\t}\n\n\tif (context->SendSingleHostData)\n\t{\n\t\tAvPairsCount++; /* MsvAvSingleHost */\n\t\tntlm_compute_single_host_data(context);\n\t\tAvPairsValueLength += context->SingleHostData.Size;\n\t}\n\n\t/**\n\t * Extended Protection for Authentication:\n\t * http://blogs.technet.com/b/srd/archive/2009/12/08/extended-protection-for-authentication.aspx\n\t */\n\n\tif (!context->SuppressExtendedProtection)\n\t{\n\t\t/**\n\t\t * SEC_CHANNEL_BINDINGS structure\n\t\t * http://msdn.microsoft.com/en-us/library/windows/desktop/dd919963/\n\t\t */\n\t\tAvPairsCount++; /* MsvChannelBindings */\n\t\tAvPairsValueLength += 16;\n\t\tntlm_compute_channel_bindings(context);\n\n\t\tif (context->ServicePrincipalName.Length > 0)\n\t\t{\n\t\t\tAvPairsCount++; /* MsvAvTargetName */\n\t\t\tAvPairsValueLength += context->ServicePrincipalName.Length;\n\t\t}\n\t}\n\n\tsize = ntlm_av_pair_list_size(AvPairsCount, AvPairsValueLength);\n\n\tif (context->NTLMv2)\n\t\tsize += 8; /* unknown 8-byte padding */\n\n\tif (!sspi_SecBufferAlloc(&context->AuthenticateTargetInfo, size))\n\t\treturn -1;\n\n\tAuthenticateTargetInfo = (NTLM_AV_PAIR*)context->AuthenticateTargetInfo.pvBuffer;\n\tcbAuthenticateTargetInfo = context->AuthenticateTargetInfo.cbBuffer;\n\n\tif (!ntlm_av_pair_list_init(AuthenticateTargetInfo, cbAuthenticateTargetInfo))\n\t\treturn -1;\n\n\tif (AvNbDomainName)\n\t{\n\t\tif (!ntlm_av_pair_add_copy(AuthenticateTargetInfo, cbAuthenticateTargetInfo, AvNbDomainName,\n\t\t                           cbAvNbDomainName))\n\t\t\treturn -1;\n\t}\n\n\tif (AvNbComputerName)\n\t{\n\t\tif (!ntlm_av_pair_add_copy(AuthenticateTargetInfo, cbAuthenticateTargetInfo,\n\t\t                           AvNbComputerName, cbAvNbComputerName))\n\t\t\treturn -1;\n\t}\n\n\tif (AvDnsDomainName)\n\t{\n\t\tif (!ntlm_av_pair_add_copy(AuthenticateTargetInfo, cbAuthenticateTargetInfo,\n\t\t                           AvDnsDomainName, cbAvDnsDomainName))\n\t\t\treturn -1;\n\t}\n\n\tif (AvDnsComputerName)\n\t{\n\t\tif (!ntlm_av_pair_add_copy(AuthenticateTargetInfo, cbAuthenticateTargetInfo,\n\t\t                           AvDnsComputerName, cbAvDnsComputerName))\n\t\t\treturn -1;\n\t}\n\n\tif (AvDnsTreeName)\n\t{\n\t\tif (!ntlm_av_pair_add_copy(AuthenticateTargetInfo, cbAuthenticateTargetInfo, AvDnsTreeName,\n\t\t                           cbAvDnsTreeName))\n\t\t\treturn -1;\n\t}\n\n\tif (AvTimestamp)\n\t{\n\t\tif (!ntlm_av_pair_add_copy(AuthenticateTargetInfo, cbAuthenticateTargetInfo, AvTimestamp,\n\t\t                           cbAvTimestamp))\n\t\t\treturn -1;\n\t}\n\n\tif (context->UseMIC)\n\t{\n\t\tUINT32 flags;\n\t\tData_Write_UINT32(&flags, MSV_AV_FLAGS_MESSAGE_INTEGRITY_CHECK);\n\n\t\tif (!ntlm_av_pair_add(AuthenticateTargetInfo, cbAuthenticateTargetInfo, MsvAvFlags,\n\t\t                      (PBYTE)&flags, 4))\n\t\t\treturn -1;\n\t}\n\n\tif (context->SendSingleHostData)\n\t{\n\t\tif (!ntlm_av_pair_add(AuthenticateTargetInfo, cbAuthenticateTargetInfo, MsvAvSingleHost,\n\t\t                      (PBYTE)&context->SingleHostData, context->SingleHostData.Size))\n\t\t\treturn -1;\n\t}\n\n\tif (!context->SuppressExtendedProtection)\n\t{\n\t\tif (!ntlm_av_pair_add(AuthenticateTargetInfo, cbAuthenticateTargetInfo, MsvChannelBindings,\n\t\t                      context->ChannelBindingsHash, 16))\n\t\t\treturn -1;\n\n\t\tif (context->ServicePrincipalName.Length > 0)\n\t\t{\n\t\t\tif (!ntlm_av_pair_add(AuthenticateTargetInfo, cbAuthenticateTargetInfo, MsvAvTargetName,\n\t\t\t                      (PBYTE)context->ServicePrincipalName.Buffer,\n\t\t\t                      context->ServicePrincipalName.Length))\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (context->NTLMv2)\n\t{\n\t\tNTLM_AV_PAIR* AvEOL;\n\t\tAvEOL = ntlm_av_pair_get(ChallengeTargetInfo, cbChallengeTargetInfo, MsvAvEOL, NULL);\n\n\t\tif (!AvEOL)\n\t\t\treturn -1;\n\n\t\tZeroMemory(AvEOL, sizeof(NTLM_AV_PAIR));\n\t}\n\n\treturn 1;\n}\n- ntlm_generate_key_exchange_key: void ntlm_generate_key_exchange_key(NTLM_CONTEXT* context) /* <=== ntlm_generate_key_exchange_key */ \n{\n\t/* In NTLMv2, KeyExchangeKey is the 128-bit SessionBaseKey */\n\tCopyMemory(context->KeyExchangeKey, context->SessionBaseKey, 16);\n}\n- Stream_Free: void Stream_Free(wStream* s, BOOL bFreeBuffer) /* <=== Stream_Free */ \n{\n\tif (s)\n\t{\n\t\tif (bFreeBuffer && s->isOwner)\n\t\t\tfree(s->buffer);\n\n\t\tif (s->isAllocatedStream)\n\t\t\tfree(s);\n\t}\n}\n- sspi_SecBufferAlloc: void* sspi_SecBufferAlloc(PSecBuffer SecBuffer, ULONG size) /* <=== sspi_SecBufferAlloc */ \n{\n\tif (!SecBuffer)\n\t\treturn NULL;\n\n\tSecBuffer->pvBuffer = calloc(1, size);\n\n\tif (!SecBuffer->pvBuffer)\n\t\treturn NULL;\n\n\tSecBuffer->cbBuffer = size;\n\treturn SecBuffer->pvBuffer;\n}\n- ntlm_init_rc4_seal_states: void ntlm_init_rc4_seal_states(NTLM_CONTEXT* context) /* <=== ntlm_init_rc4_seal_states */ \n{\n\tif (context->server)\n\t{\n\t\tcontext->SendSigningKey = context->ServerSigningKey;\n\t\tcontext->RecvSigningKey = context->ClientSigningKey;\n\t\tcontext->SendSealingKey = context->ClientSealingKey;\n\t\tcontext->RecvSealingKey = context->ServerSealingKey;\n\t\tcontext->SendRc4Seal = winpr_RC4_New(context->ServerSealingKey, 16);\n\t\tcontext->RecvRc4Seal = winpr_RC4_New(context->ClientSealingKey, 16);\n\t}\n\telse\n\t{\n\t\tcontext->SendSigningKey = context->ClientSigningKey;\n\t\tcontext->RecvSigningKey = context->ServerSigningKey;\n\t\tcontext->SendSealingKey = context->ServerSealingKey;\n\t\tcontext->RecvSealingKey = context->ClientSealingKey;\n\t\tcontext->SendRc4Seal = winpr_RC4_New(context->ClientSealingKey, 16);\n\t\tcontext->RecvRc4Seal = winpr_RC4_New(context->ServerSealingKey, 16);\n\t}\n}\n- ntlm_av_pair_get_value_pointer: PBYTE ntlm_av_pair_get_value_pointer(NTLM_AV_PAIR* pAvPair) /* <=== ntlm_av_pair_get_value_pointer */ \n{\n\treturn (PBYTE)pAvPair + sizeof(NTLM_AV_PAIR);\n}\n- ntlm_current_time: void ntlm_current_time(BYTE* timestamp) /* <=== ntlm_current_time */ \n{\n\tFILETIME filetime;\n\tULARGE_INTEGER time64;\n\tGetSystemTimeAsFileTime(&filetime);\n\ttime64.u.LowPart = filetime.dwLowDateTime;\n\ttime64.u.HighPart = filetime.dwHighDateTime;\n\tCopyMemory(timestamp, &(time64.QuadPart), 8);\n}\n- ntlm_read_message_fields: static int ntlm_read_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields) /* <=== ntlm_read_message_fields */ \n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn -1;\n\n\tStream_Read_UINT16(s, fields->Len);          /* Len (2 bytes) */\n\tStream_Read_UINT16(s, fields->MaxLen);       /* MaxLen (2 bytes) */\n\tStream_Read_UINT32(s, fields->BufferOffset); /* BufferOffset (4 bytes) */\n\treturn 1;\n}\n- ntlm_rc4k: void ntlm_rc4k(BYTE* key, int length, BYTE* plaintext, BYTE* ciphertext) /* <=== ntlm_rc4k */ \n{\n\tWINPR_RC4_CTX* rc4 = winpr_RC4_New(key, 16);\n\n\tif (rc4)\n\t{\n\t\twinpr_RC4_Update(rc4, length, plaintext, ciphertext);\n\t\twinpr_RC4_Free(rc4);\n\t}\n}\n- ntlm_generate_client_sealing_key: void ntlm_generate_client_sealing_key(NTLM_CONTEXT* context) /* <=== ntlm_generate_client_sealing_key */ \n{\n\tSecBuffer sealMagic;\n\tsealMagic.pvBuffer = (void*)NTLM_CLIENT_SEAL_MAGIC;\n\tsealMagic.cbBuffer = sizeof(NTLM_CLIENT_SEAL_MAGIC);\n\tntlm_generate_signing_key(context->ExportedSessionKey, &sealMagic, context->ClientSealingKey);\n}\n- ntlm_read_message_header: static int ntlm_read_message_header(wStream* s, NTLM_MESSAGE_HEADER* header) /* <=== ntlm_read_message_header */ \n{\n\tif (Stream_GetRemainingLength(s) < 12)\n\t\treturn -1;\n\n\tStream_Read(s, header->Signature, 8);\n\tStream_Read_UINT32(s, header->MessageType);\n\n\tif (strncmp((char*)header->Signature, NTLM_SIGNATURE, 8) != 0)\n\t\treturn -1;\n\n\treturn 1;\n}\n- ntlm_generate_server_signing_key: void ntlm_generate_server_signing_key(NTLM_CONTEXT* context) /* <=== ntlm_generate_server_signing_key */ \n{\n\tSecBuffer signMagic;\n\tsignMagic.pvBuffer = (void*)NTLM_SERVER_SIGN_MAGIC;\n\tsignMagic.cbBuffer = sizeof(NTLM_SERVER_SIGN_MAGIC);\n\tntlm_generate_signing_key(context->ExportedSessionKey, &signMagic, context->ServerSigningKey);\n}\n- NTLMSSP_NEGOTIATE_VERSION: #define NTLMSSP_NEGOTIATE_VERSION 0x02000000                   /* T   (6) */ /* <=== winpr/libwinpr/sspi/NTLM/ntlm.h:42:42:NTLMSSP_NEGOTIATE_VERSION:0 */ \n- ntlm_generate_client_challenge: void ntlm_generate_client_challenge(NTLM_CONTEXT* context) /* <=== ntlm_generate_client_challenge */ \n{\n\t/* ClientChallenge is used in computation of LMv2 and NTLMv2 responses */\n\tif (memcmp(context->ClientChallenge, NTLM_NULL_BUFFER, 8) == 0)\n\t\twinpr_RAND(context->ClientChallenge, 8);\n}\n- ntlm_compute_lm_v2_response: int ntlm_compute_lm_v2_response(NTLM_CONTEXT* context) /* <=== ntlm_compute_lm_v2_response */ \n{\n\tBYTE* response;\n\tBYTE value[WINPR_MD5_DIGEST_LENGTH];\n\n\tif (context->LmCompatibilityLevel < 2)\n\t{\n\t\tif (!sspi_SecBufferAlloc(&context->LmChallengeResponse, 24))\n\t\t\treturn -1;\n\n\t\tZeroMemory(context->LmChallengeResponse.pvBuffer, 24);\n\t\treturn 1;\n\t}\n\n\t/* Compute the NTLMv2 hash */\n\n\tif (ntlm_compute_ntlm_v2_hash(context, context->NtlmV2Hash) < 0)\n\t\treturn -1;\n\n\t/* Concatenate the server and client challenges */\n\tCopyMemory(value, context->ServerChallenge, 8);\n\tCopyMemory(&value[8], context->ClientChallenge, 8);\n\n\tif (!sspi_SecBufferAlloc(&context->LmChallengeResponse, 24))\n\t\treturn -1;\n\n\tresponse = (BYTE*)context->LmChallengeResponse.pvBuffer;\n\t/* Compute the HMAC-MD5 hash of the resulting value using the NTLMv2 hash as the key */\n\twinpr_HMAC(WINPR_MD_MD5, (void*)context->NtlmV2Hash, WINPR_MD5_DIGEST_LENGTH, (BYTE*)value,\n\t           WINPR_MD5_DIGEST_LENGTH, (BYTE*)response, WINPR_MD5_DIGEST_LENGTH);\n\t/* Concatenate the resulting HMAC-MD5 hash and the client challenge, giving us the LMv2 response\n\t * (24 bytes) */\n\tCopyMemory(&response[16], context->ClientChallenge, 8);\n\treturn 1;\n}\n- ntlm_av_pair_add_copy: static BOOL ntlm_av_pair_add_copy(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList, /* <=== ntlm_av_pair_add_copy */ \n                                  NTLM_AV_PAIR* pAvPair, size_t cbAvPair)\n{\n\tif (!ntlm_av_pair_check(pAvPair, cbAvPair))\n\t\treturn FALSE;\n\n\treturn ntlm_av_pair_add(pAvPairList, cbAvPairList, ntlm_av_pair_get_id(pAvPair),\n\t                        ntlm_av_pair_get_value_pointer(pAvPair), ntlm_av_pair_get_len(pAvPair));\n}\n- ntlm_generate_exported_session_key: void ntlm_generate_exported_session_key(NTLM_CONTEXT* context) /* <=== ntlm_generate_exported_session_key */ \n{\n\tCopyMemory(context->ExportedSessionKey, context->RandomSessionKey, 16);\n}\n- winpr_RC4_New: \tWINPR_API WINPR_RC4_CTX* winpr_RC4_New(const BYTE* key, size_t keylen); /* <=== winpr_RC4_New */ \n- ntlm_free_message_fields_buffer: static void ntlm_free_message_fields_buffer(NTLM_MESSAGE_FIELDS* fields) /* <=== ntlm_free_message_fields_buffer */ \n{\n\tif (fields)\n\t{\n\t\tif (fields->Buffer)\n\t\t{\n\t\t\tfree(fields->Buffer);\n\t\t\tfields->Len = 0;\n\t\t\tfields->MaxLen = 0;\n\t\t\tfields->Buffer = NULL;\n\t\t\tfields->BufferOffset = 0;\n\t\t}\n\t}\n}\n- ntlm_read_message_fields_buffer: static int ntlm_read_message_fields_buffer(wStream* s, NTLM_MESSAGE_FIELDS* fields) /* <=== ntlm_read_message_fields_buffer */ \n{\n\tif (fields->Len > 0)\n\t{\n\t\tconst UINT32 offset = fields->BufferOffset + fields->Len;\n\n\t\tif (fields->BufferOffset > UINT32_MAX - fields->Len)\n\t\t\treturn -1;\n\n\t\tif (offset > Stream_Length(s))\n\t\t\treturn -1;\n\n\t\tfields->Buffer = (PBYTE)malloc(fields->Len);\n\n\t\tif (!fields->Buffer)\n\t\t\treturn -1;\n\n\t\tStream_SetPosition(s, fields->BufferOffset);\n\t\tStream_Read(s, fields->Buffer, fields->Len);\n\t}\n\n\treturn 1;\n}\n- MESSAGE_TYPE_CHALLENGE: #define MESSAGE_TYPE_CHALLENGE 2 /* <=== winpr/libwinpr/sspi/NTLM/ntlm.h:33:33:MESSAGE_TYPE_CHALLENGE:0 */ \n- ntlm_compute_single_host_data: static void ntlm_compute_single_host_data(NTLM_CONTEXT* context) /* <=== ntlm_compute_single_host_data */ \n{\n\t/**\n\t * The Single_Host_Data structure allows a client to send machine-specific information\n\t * within an authentication exchange to services on the same machine. The client can\n\t * produce additional information to be processed in an implementation-specific way when\n\t * the client and server are on the same host. If the server and client platforms are\n\t * different or if they are on different hosts, then the information MUST be ignored.\n\t * Any fields after the MachineID field MUST be ignored on receipt.\n\t */\n\tData_Write_UINT32(&context->SingleHostData.Size, 48);\n\tData_Write_UINT32(&context->SingleHostData.Z4, 0);\n\tData_Write_UINT32(&context->SingleHostData.DataPresent, 1);\n\tData_Write_UINT32(&context->SingleHostData.CustomData, SECURITY_MANDATORY_MEDIUM_RID);\n\tFillMemory(context->SingleHostData.MachineID, 32, 0xAA);\n}\n- ntlm_av_pair_list_size: static ULONG ntlm_av_pair_list_size(ULONG AvPairsCount, ULONG AvPairsValueLength) /* <=== ntlm_av_pair_list_size */ \n{\n\t/* size of headers + value lengths + terminating MsvAvEOL AV_PAIR */\n\treturn ((AvPairsCount + 1) * 4) + AvPairsValueLength;\n}\n- ntlm_compute_channel_bindings: static void ntlm_compute_channel_bindings(NTLM_CONTEXT* context) /* <=== ntlm_compute_channel_bindings */ \n{\n\tWINPR_DIGEST_CTX* md5;\n\tBYTE* ChannelBindingToken;\n\tUINT32 ChannelBindingTokenLength;\n\tSEC_CHANNEL_BINDINGS* ChannelBindings;\n\tZeroMemory(context->ChannelBindingsHash, WINPR_MD5_DIGEST_LENGTH);\n\tChannelBindings = context->Bindings.Bindings;\n\n\tif (!ChannelBindings)\n\t\treturn;\n\n\tif (!(md5 = winpr_Digest_New()))\n\t\treturn;\n\n\tif (!winpr_Digest_Init(md5, WINPR_MD_MD5))\n\t\tgoto out;\n\n\tChannelBindingTokenLength = context->Bindings.BindingsLength - sizeof(SEC_CHANNEL_BINDINGS);\n\tChannelBindingToken = &((BYTE*)ChannelBindings)[ChannelBindings->dwApplicationDataOffset];\n\n\tif (!ntlm_md5_update_uint32_be(md5, ChannelBindings->dwInitiatorAddrType))\n\t\tgoto out;\n\n\tif (!ntlm_md5_update_uint32_be(md5, ChannelBindings->cbInitiatorLength))\n\t\tgoto out;\n\n\tif (!ntlm_md5_update_uint32_be(md5, ChannelBindings->dwAcceptorAddrType))\n\t\tgoto out;\n\n\tif (!ntlm_md5_update_uint32_be(md5, ChannelBindings->cbAcceptorLength))\n\t\tgoto out;\n\n\tif (!ntlm_md5_update_uint32_be(md5, ChannelBindings->cbApplicationDataLength))\n\t\tgoto out;\n\n\tif (!winpr_Digest_Update(md5, (void*)ChannelBindingToken, ChannelBindingTokenLength))\n\t\tgoto out;\n\n\tif (!winpr_Digest_Final(md5, context->ChannelBindingsHash, WINPR_MD5_DIGEST_LENGTH))\n\t\tgoto out;\n\nout:\n\twinpr_Digest_Free(md5);\n}\n- ntlm_av_pair_get: NTLM_AV_PAIR* ntlm_av_pair_get(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList, NTLM_AV_ID AvId, /* <=== ntlm_av_pair_get */ \n                               size_t* pcbAvPairListRemaining)\n{\n\tsize_t cbAvPair = cbAvPairList;\n\tNTLM_AV_PAIR* pAvPair = pAvPairList;\n\n\tif (!ntlm_av_pair_check(pAvPair, cbAvPair))\n\t\tpAvPair = NULL;\n\n\twhile (pAvPair)\n\t{\n\t\tUINT16 id = ntlm_av_pair_get_id(pAvPair);\n\n\t\tif (id == AvId)\n\t\t\tbreak;\n\t\tif (id == MsvAvEOL)\n\t\t{\n\t\t\tpAvPair = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tpAvPair = ntlm_av_pair_next(pAvPair, &cbAvPair);\n\t}\n\n\tif (!pAvPair)\n\t\tcbAvPair = 0;\n\tif (pcbAvPairListRemaining)\n\t\t*pcbAvPairListRemaining = cbAvPair;\n\n\treturn pAvPair;\n}\n- ntlm_compute_ntlm_v2_hash: static int ntlm_compute_ntlm_v2_hash(NTLM_CONTEXT* context, BYTE* hash) /* <=== ntlm_compute_ntlm_v2_hash */ \n{\n\tSSPI_CREDENTIALS* credentials = context->credentials;\n#ifdef WITH_DEBUG_NTLM\n\n\tif (credentials)\n\t{\n\t\tWLog_DBG(TAG, \"Password (length = %\" PRIu32 \")\", credentials->identity.PasswordLength * 2);\n\t\twinpr_HexDump(TAG, WLOG_DEBUG, (BYTE*)credentials->identity.Password,\n\t\t              credentials->identity.PasswordLength * 2);\n\t\tWLog_DBG(TAG, \"Username (length = %\" PRIu32 \")\", credentials->identity.UserLength * 2);\n\t\twinpr_HexDump(TAG, WLOG_DEBUG, (BYTE*)credentials->identity.User,\n\t\t              credentials->identity.UserLength * 2);\n\t\tWLog_DBG(TAG, \"Domain (length = %\" PRIu32 \")\", credentials->identity.DomainLength * 2);\n\t\twinpr_HexDump(TAG, WLOG_DEBUG, (BYTE*)credentials->identity.Domain,\n\t\t              credentials->identity.DomainLength * 2);\n\t}\n\telse\n\t\tWLog_DBG(TAG, \"Strange, NTLM_CONTEXT is missing valid credentials...\");\n\n\tWLog_DBG(TAG, \"Workstation (length = %\" PRIu16 \")\", context->Workstation.Length);\n\twinpr_HexDump(TAG, WLOG_DEBUG, (BYTE*)context->Workstation.Buffer, context->Workstation.Length);\n\tWLog_DBG(TAG, \"NTOWFv2, NTLMv2 Hash\");\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->NtlmV2Hash, WINPR_MD5_DIGEST_LENGTH);\n#endif\n\n\tif (memcmp(context->NtlmV2Hash, NTLM_NULL_BUFFER, 16) != 0)\n\t\treturn 1;\n\n\tif (!credentials)\n\t\treturn -1;\n\telse if (memcmp(context->NtlmHash, NTLM_NULL_BUFFER, 16) != 0)\n\t{\n\t\tNTOWFv2FromHashW(context->NtlmHash, (LPWSTR)credentials->identity.User,\n\t\t                 credentials->identity.UserLength * 2, (LPWSTR)credentials->identity.Domain,\n\t\t                 credentials->identity.DomainLength * 2, (BYTE*)hash);\n\t}\n\telse if (credentials->identity.PasswordLength > SSPI_CREDENTIALS_HASH_LENGTH_OFFSET)\n\t{\n\t\t/* Special case for WinPR: password hash */\n\t\tif (ntlm_convert_password_hash(context, context->NtlmHash) < 0)\n\t\t\treturn -1;\n\n\t\tNTOWFv2FromHashW(context->NtlmHash, (LPWSTR)credentials->identity.User,\n\t\t                 credentials->identity.UserLength * 2, (LPWSTR)credentials->identity.Domain,\n\t\t                 credentials->identity.DomainLength * 2, (BYTE*)hash);\n\t}\n\telse if (credentials->identity.Password)\n\t{\n\t\tNTOWFv2W((LPWSTR)credentials->identity.Password, credentials->identity.PasswordLength * 2,\n\t\t         (LPWSTR)credentials->identity.User, credentials->identity.UserLength * 2,\n\t\t         (LPWSTR)credentials->identity.Domain, credentials->identity.DomainLength * 2,\n\t\t         (BYTE*)hash);\n\t}\n\telse if (context->HashCallback)\n\t{\n\t\tint ret;\n\t\tSecBuffer proofValue, micValue;\n\n\t\tif (ntlm_computeProofValue(context, &proofValue) != SEC_E_OK)\n\t\t\treturn -1;\n\n\t\tif (ntlm_computeMicValue(context, &micValue) != SEC_E_OK)\n\t\t{\n\t\t\tsspi_SecBufferFree(&proofValue);\n\t\t\treturn -1;\n\t\t}\n\n\t\tret = context->HashCallback(context->HashCallbackArg, &credentials->identity, &proofValue,\n\t\t                            context->EncryptedRandomSessionKey,\n\t\t                            (&context->AUTHENTICATE_MESSAGE)->MessageIntegrityCheck,\n\t\t                            &micValue, hash);\n\t\tsspi_SecBufferFree(&proofValue);\n\t\tsspi_SecBufferFree(&micValue);\n\t\treturn ret ? 1 : -1;\n\t}\n\telse if (context->UseSamFileDatabase)\n\t{\n\t\treturn ntlm_fetch_ntlm_v2_hash(context, hash);\n\t}\n\n\treturn 1;\n}\n\nType Definitions:\n- SECURITY_STATUS: typedef LONG SECURITY_STATUS;\n- wStream: typedef struct _wStream wStream;\n- NTLM_CHALLENGE_MESSAGE: typedef struct _NTLM_CHALLENGE_MESSAGE NTLM_CHALLENGE_MESSAGE;\n- _NTLM_AV_PAIR: struct _NTLM_AV_PAIR\n{\n\tUINT16 AvId;\n\tUINT16 AvLen;\n}\n- PSecBuffer: typedef SecBuffer* PSecBuffer;\n- NTLM_CONTEXT: typedef struct _NTLM_CONTEXT NTLM_CONTEXT;\n- NTLM_AV_PAIR: typedef struct _NTLM_AV_PAIR NTLM_AV_PAIR;\n\nImports:\n- #include \"ntlm.h\"\n- #include \"ntlm_message.h\"\n- #include \"ntlm_compute.h\"\n- #include <winpr/stream.h>\n- #include \"../sspi.h\"\n- #include <winpr/sysinfo.h>\n- #include <winpr/print.h>\n- #include <winpr/crt.h>\n- #include \"../log.h\"\n- #include \"config.h\"",
    "commit_msg": "Fixed GHSL-2020-100: oob read in ntlm_read_ChallengeMessage\n\n* Added length checks for data read from stream\n* Unified function resource cleanup\n\n(cherry picked from commit 8357dedbbf7213b7d0d18f1026145b9a5b92235a)",
    "cve_desc": "An issue was discovered in FreeRDP before 2.1.1. An out-of-bounds (OOB) read vulnerability has been detected in ntlm_read_ChallengeMessage in winpr/libwinpr/sspi/NTLM/ntlm_message.c.",
    "year": 2020,
    "filename": "ntlm_message.c",
    "commit_url": "\"https://github.com/FreeRDP/FreeRDP/commit/48361c411e50826cb602c7aab773a8a20e1da6bc\""
  },
  {
    "repository": "FreeRDP/FreeRDP",
    "cve_id": "CVE-2020-13397",
    "cwe_list": [
      "CWE-787"
    ],
    "commit_hash": "d6cd14059b257318f176c0ba3ee0a348826a9ef8",
    "short_hash": "d6cd1405",
    "vulnerableMethods_before": [
      {
        "filename": "libfreerdp/core/security.c",
        "method_name": "security_fips_decrypt",
        "raw_code": "BOOL security_fips_decrypt(BYTE* data, size_t length, rdpRdp* rdp) /* <=== security_fips_decrypt */ \n{\n\tsize_t olen;\n\n\tif (!winpr_Cipher_Update(rdp->fips_decrypt, data, length, data, &olen))\n\t\treturn FALSE;\n\n\treturn TRUE;\n}",
        "start_line": 815
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "libfreerdp/core/security.c",
        "method_name": "security_fips_decrypt",
        "raw_code": "BOOL security_fips_decrypt(BYTE* data, size_t length, rdpRdp* rdp) /* <=== security_fips_decrypt */ \n{\n\tsize_t olen;\n\n\tif (!rdp || !rdp->fips_decrypt)\n\t\treturn FALSE;\n\n\tif (!winpr_Cipher_Update(rdp->fips_decrypt, data, length, data, &olen))\n\t\treturn FALSE;\n\n\treturn TRUE;\n}",
        "start_line": 815
      }
    ],
    "code_context": "Called Methods:\n- winpr_Cipher_Update: BOOL winpr_Cipher_Update(WINPR_CIPHER_CTX* ctx, const BYTE* input, size_t ilen, BYTE* output, /* <=== winpr_Cipher_Update */ \n                         size_t* olen)\n{\n#if defined(WITH_OPENSSL)\n\tint outl = (int)*olen;\n\n\tif (EVP_CipherUpdate((EVP_CIPHER_CTX*)ctx, output, &outl, input, ilen) == 1)\n\t{\n\t\t*olen = (size_t)outl;\n\t\treturn TRUE;\n\t}\n\n#elif defined(WITH_MBEDTLS)\n\n\tif (mbedtls_cipher_update((mbedtls_cipher_context_t*)ctx, input, ilen, output, olen) == 0)\n\t\treturn TRUE;\n\n#endif\n\treturn FALSE;\n}\n\nType Definitions:\n- rdpRdp: typedef struct rdp_rdp rdpRdp;\n\nImports:\n- #include \"security.h\"\n- #include <freerdp/log.h>\n- #include <winpr/crypto.h>\n- #include \"config.h\"",
    "commit_msg": "Fixed GHSL-2020-101 missing NULL check\n\n(cherry picked from commit b207dbba35c505bbc3ad5aadc10b34980c6b7e8e)",
    "cve_desc": "An issue was discovered in FreeRDP before 2.1.1. An out-of-bounds (OOB) read vulnerability has been detected in security_fips_decrypt in libfreerdp/core/security.c due to an uninitialized value.",
    "year": 2020,
    "filename": "security.c",
    "commit_url": "\"https://github.com/FreeRDP/FreeRDP/commit/d6cd14059b257318f176c0ba3ee0a348826a9ef8\""
  },
  {
    "repository": "FreeRDP/FreeRDP",
    "cve_id": "CVE-2020-13398",
    "cwe_list": [
      "CWE-787"
    ],
    "commit_hash": "8305349a943c68b1bc8c158f431dc607655aadea",
    "short_hash": "8305349a",
    "vulnerableMethods_before": [
      {
        "filename": "libfreerdp/crypto/crypto.c",
        "method_name": "crypto_rsa_common",
        "raw_code": "static int crypto_rsa_common(const BYTE* input, int length, UINT32 key_length, const BYTE* modulus, /* <=== crypto_rsa_common */ \n                             const BYTE* exponent, int exponent_size, BYTE* output)\n{\n\tBN_CTX* ctx;\n\tint output_length = -1;\n\tBYTE* input_reverse;\n\tBYTE* modulus_reverse;\n\tBYTE* exponent_reverse;\n\tBIGNUM *mod, *exp, *x, *y;\n\tinput_reverse = (BYTE*)malloc(2 * key_length + exponent_size);\n\n\tif (!input_reverse)\n\t\treturn -1;\n\n\tmodulus_reverse = input_reverse + key_length;\n\texponent_reverse = modulus_reverse + key_length;\n\tmemcpy(modulus_reverse, modulus, key_length);\n\tcrypto_reverse(modulus_reverse, key_length);\n\tmemcpy(exponent_reverse, exponent, exponent_size);\n\tcrypto_reverse(exponent_reverse, exponent_size);\n\tmemcpy(input_reverse, input, length);\n\tcrypto_reverse(input_reverse, length);\n\n\tif (!(ctx = BN_CTX_new()))\n\t\tgoto fail_bn_ctx;\n\n\tif (!(mod = BN_new()))\n\t\tgoto fail_bn_mod;\n\n\tif (!(exp = BN_new()))\n\t\tgoto fail_bn_exp;\n\n\tif (!(x = BN_new()))\n\t\tgoto fail_bn_x;\n\n\tif (!(y = BN_new()))\n\t\tgoto fail_bn_y;\n\n\tBN_bin2bn(modulus_reverse, key_length, mod);\n\tBN_bin2bn(exponent_reverse, exponent_size, exp);\n\tBN_bin2bn(input_reverse, length, x);\n\tBN_mod_exp(y, x, exp, mod, ctx);\n\toutput_length = BN_bn2bin(y, output);\n\tcrypto_reverse(output, output_length);\n\n\tif (output_length < (int)key_length)\n\t\tmemset(output + output_length, 0, key_length - output_length);\n\n\tBN_free(y);\nfail_bn_y:\n\tBN_clear_free(x);\nfail_bn_x:\n\tBN_free(exp);\nfail_bn_exp:\n\tBN_free(mod);\nfail_bn_mod:\n\tBN_CTX_free(ctx);\nfail_bn_ctx:\n\tfree(input_reverse);\n\treturn output_length;\n}",
        "start_line": 96
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "libfreerdp/crypto/crypto.c",
        "method_name": "crypto_rsa_common",
        "raw_code": "static int crypto_rsa_common(const BYTE* input, int length, UINT32 key_length, const BYTE* modulus, /* <=== crypto_rsa_common */ \n                             const BYTE* exponent, int exponent_size, BYTE* output)\n{\n\tBN_CTX* ctx = NULL;\n\tint output_length = -1;\n\tBYTE* input_reverse = NULL;\n\tBYTE* modulus_reverse = NULL;\n\tBYTE* exponent_reverse = NULL;\n\tBIGNUM* mod = NULL;\n\tBIGNUM* exp = NULL;\n\tBIGNUM* x = NULL;\n\tBIGNUM* y = NULL;\n\tsize_t bufferSize = 2 * key_length + exponent_size;\n\n\tif (!input || (length < 0) || (exponent_size < 0) || !modulus || !exponent || !output)\n\t\treturn -1;\n\n\tif (length > bufferSize)\n\t\tbufferSize = length;\n\n\tinput_reverse = (BYTE*)calloc(bufferSize, 1);\n\n\tif (!input_reverse)\n\t\treturn -1;\n\n\tmodulus_reverse = input_reverse + key_length;\n\texponent_reverse = modulus_reverse + key_length;\n\tmemcpy(modulus_reverse, modulus, key_length);\n\tcrypto_reverse(modulus_reverse, key_length);\n\tmemcpy(exponent_reverse, exponent, exponent_size);\n\tcrypto_reverse(exponent_reverse, exponent_size);\n\tmemcpy(input_reverse, input, length);\n\tcrypto_reverse(input_reverse, length);\n\n\tif (!(ctx = BN_CTX_new()))\n\t\tgoto fail_bn_ctx;\n\n\tif (!(mod = BN_new()))\n\t\tgoto fail_bn_mod;\n\n\tif (!(exp = BN_new()))\n\t\tgoto fail_bn_exp;\n\n\tif (!(x = BN_new()))\n\t\tgoto fail_bn_x;\n\n\tif (!(y = BN_new()))\n\t\tgoto fail_bn_y;\n\n\tif (!BN_bin2bn(modulus_reverse, key_length, mod))\n\t\tgoto fail;\n\n\tif (!BN_bin2bn(exponent_reverse, exponent_size, exp))\n\t\tgoto fail;\n\tif (!BN_bin2bn(input_reverse, length, x))\n\t\tgoto fail;\n\tif (BN_mod_exp(y, x, exp, mod, ctx) != 1)\n\t\tgoto fail;\n\toutput_length = BN_bn2bin(y, output);\n\tif (output_length < 0)\n\t\tgoto fail;\n\tcrypto_reverse(output, output_length);\n\n\tif (output_length < key_length)\n\t\tmemset(output + output_length, 0, key_length - output_length);\n\nfail:\n\tBN_free(y);\nfail_bn_y:\n\tBN_clear_free(x);\nfail_bn_x:\n\tBN_free(exp);\nfail_bn_exp:\n\tBN_free(mod);\nfail_bn_mod:\n\tBN_CTX_free(ctx);\nfail_bn_ctx:\n\tfree(input_reverse);\n\treturn output_length;\n}",
        "start_line": 96
      }
    ],
    "code_context": "Called Methods:\n- crypto_reverse: void crypto_reverse(BYTE* data, int length) /* <=== crypto_reverse */ \n{\n\tint i, j;\n\tBYTE temp;\n\n\tfor (i = 0, j = length - 1; i < j; i++, j--)\n\t{\n\t\ttemp = data[i];\n\t\tdata[i] = data[j];\n\t\tdata[j] = temp;\n\t}\n}\n\nImports:\n- #include <freerdp/crypto/crypto.h>\n- #include <freerdp/log.h>\n- #include \"config.h\"\n- #include <winpr/crypto.h>\n- #include <winpr/crt.h>",
    "commit_msg": "Fixed  GHSL-2020-102 heap overflow\n\n(cherry picked from commit 197b16cc15a12813c2e4fa2d6ae9cd9c4a57e581)",
    "cve_desc": "An issue was discovered in FreeRDP before 2.1.1. An out-of-bounds (OOB) write vulnerability has been detected in crypto_rsa_common in libfreerdp/crypto/crypto.c.",
    "year": 2020,
    "filename": "crypto.c",
    "commit_url": "\"https://github.com/FreeRDP/FreeRDP/commit/8305349a943c68b1bc8c158f431dc607655aadea\""
  },
  {
    "repository": "kravietz/pam_tacplus",
    "cve_id": "CVE-2020-13881",
    "cwe_list": [
      "CWE-532"
    ],
    "commit_hash": "4a9852c31c2fd0c0e72fbb689a586aabcfb11cb0",
    "short_hash": "4a9852c3",
    "vulnerableMethods_before": [
      {
        "filename": "support.c",
        "method_name": "_pam_parse",
        "raw_code": "int _pam_parse(int argc, const char **argv) { /* <=== _pam_parse */ \n    int ctrl = 0;\n    const char *current_secret = NULL;\n\n    /* otherwise the list will grow with each call */\n    memset(tac_srv, 0, sizeof(tacplus_server_t) * TAC_PLUS_MAXSERVERS);\n    memset(&tac_srv_addr, 0, sizeof(struct addrinfo) * TAC_PLUS_MAXSERVERS);\n    memset(&tac_sock_addr, 0, sizeof(struct sockaddr) * TAC_PLUS_MAXSERVERS);\n    memset(&tac_sock6_addr, 0, sizeof(struct sockaddr_in6) * TAC_PLUS_MAXSERVERS);\n    tac_srv_no = 0;\n\n    tac_service[0] = 0;\n    tac_protocol[0] = 0;\n    tac_prompt[0] = 0;\n    tac_login[0] = 0;\n\n    for (ctrl = 0; argc-- > 0; ++argv) {\n        if (!strcmp(*argv, \"debug\")) { /* all */\n            ctrl |= PAM_TAC_DEBUG;\n        } else if (!strcmp(*argv, \"use_first_pass\")) {\n            ctrl |= PAM_TAC_USE_FIRST_PASS;\n        } else if (!strcmp(*argv, \"try_first_pass\")) {\n            ctrl |= PAM_TAC_TRY_FIRST_PASS;\n        } else if (!strncmp(*argv, \"service=\", 8)) { /* author & acct */\n            xstrcpy(tac_service, *argv + 8, sizeof(tac_service));\n        } else if (!strncmp(*argv, \"protocol=\", 9)) { /* author & acct */\n            xstrcpy(tac_protocol, *argv + 9, sizeof(tac_protocol));\n        } else if (!strncmp(*argv, \"prompt=\", 7)) { /* authentication */\n            xstrcpy(tac_prompt, *argv + 7, sizeof(tac_prompt));\n            /* Replace _ with space */\n            unsigned long chr;\n            for (chr = 0; chr < strlen(tac_prompt); chr++) {\n                if (tac_prompt[chr] == '_') {\n                    tac_prompt[chr] = ' ';\n                }\n            }\n        } else if (!strncmp(*argv, \"login=\", 6)) {\n            xstrcpy(tac_login, *argv + 6, sizeof(tac_login));\n        } else if (!strcmp(*argv, \"acct_all\")) {\n            ctrl |= PAM_TAC_ACCT;\n        } else if (!strncmp(*argv, \"server=\", 7)) { /* authen & acct */\n            if (tac_srv_no < TAC_PLUS_MAXSERVERS) {\n                struct addrinfo hints, *servers, *server;\n                int rv;\n                char *close_bracket, *server_name, *port, server_buf[256];\n\n                memset(&hints, 0, sizeof hints);\n                memset(&server_buf, 0, sizeof(server_buf));\n                hints.ai_family = AF_UNSPEC;  /* use IPv4 or IPv6, whichever */\n                hints.ai_socktype = SOCK_STREAM;\n\n                if (strlen(*argv + 7) >= sizeof(server_buf)) {\n                    _pam_log(LOG_ERR, \"server address too long, sorry\");\n                    continue;\n                }\n                strcpy(server_buf, *argv + 7);\n\n                if (*server_buf == '[' &&\n                    (close_bracket = strchr(server_buf, ']')) != NULL) { /* Check for URI syntax */\n                    server_name = server_buf + 1;\n                    _pam_log (LOG_ERR,\n                        \"reading server address as: %s \",\n                        server_name);\n                    port = strchr(close_bracket, ':');\n                    *close_bracket = '\\0';\n                } else { /* Fall back to traditional syntax */\n                    server_name = server_buf;\n                    port = strchr(server_buf, ':');\n                }\n                if (port != NULL) {\n                    *port = '\\0';\n                    port++;\n                }\n                _pam_log (LOG_DEBUG,\n                        \"sending server address to getaddrinfo as: %s \",\n                        server_name);\n                if ((rv = getaddrinfo(server_name, (port == NULL) ? \"49\" : port, &hints, &servers)) == 0) {\n                    for (server = servers;\n                         server != NULL && tac_srv_no < TAC_PLUS_MAXSERVERS; server = server->ai_next) {\n                        set_tac_srv_addr(tac_srv_no, server);\n                        set_tac_srv_key(tac_srv_no, current_secret);\n                        tac_srv_no++;\n                    }\n                    _pam_log(LOG_DEBUG, \"%s: server index %d \", __FUNCTION__, tac_srv_no);\n                    freeaddrinfo (servers);\n                } else {\n                    _pam_log(LOG_ERR,\n                             \"skip invalid server: %s (getaddrinfo: %s)\",\n                             server_name, gai_strerror(rv));\n                }\n            } else {\n                _pam_log(LOG_ERR, \"maximum number of servers (%d) exceeded, skipping\",\n                         TAC_PLUS_MAXSERVERS);\n            }\n        } else if (!strncmp(*argv, \"secret=\", 7)) {\n            current_secret = *argv + 7;     /* points right into argv (which is const) */\n\n            // this is possible because server structure is initialized only on the server= occurence\n            if (tac_srv_no == 0) {\n                _pam_log(LOG_ERR, \"secret set but no servers configured yet\");\n            } else {\n                // set secret for the last server configured\n                set_tac_srv_key(tac_srv_no - 1, current_secret);\n            }\n        } else if (!strncmp(*argv, \"timeout=\", 8)) {\n\n#ifdef HAVE_STRTOL\n            tac_timeout = strtol(*argv + 8, NULL, 10);\n\n#else\n            tac_timeout = atoi(*argv + 8);\n#endif\n            if (tac_timeout == LONG_MAX) {\n                _pam_log(LOG_ERR, \"timeout parameter cannot be parsed as integer: %s\", *argv);\n                tac_timeout = 0;\n            } else {\n                tac_readtimeout_enable = 1;\n            }\n        } else {\n            _pam_log(LOG_WARNING, \"unrecognized option: %s\", *argv);\n        }\n    }\n\n    if (ctrl & PAM_TAC_DEBUG) {\n        unsigned long n;\n\n        _pam_log(LOG_DEBUG, \"%d servers defined\", tac_srv_no);\n\n        for (n = 0; n < tac_srv_no; n++) {\n            _pam_log(LOG_DEBUG, \"server[%lu] { addr=%s, key='%s' }\", n, tac_ntop(tac_srv[n].addr->ai_addr),\n                     tac_srv[n].key);\n        }\n\n        _pam_log(LOG_DEBUG, \"tac_service='%s'\", tac_service);\n        _pam_log(LOG_DEBUG, \"tac_protocol='%s'\", tac_protocol);\n        _pam_log(LOG_DEBUG, \"tac_prompt='%s'\", tac_prompt);\n        _pam_log(LOG_DEBUG, \"tac_login='%s'\", tac_login);\n    }\n\n    return ctrl;\n}    /* _pam_parse */",
        "start_line": 248
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "support.c",
        "method_name": "_pam_parse",
        "raw_code": "int _pam_parse(int argc, const char **argv) { /* <=== _pam_parse */ \n    int ctrl = 0;\n    const char *current_secret = NULL;\n\n    /* otherwise the list will grow with each call */\n    memset(tac_srv, 0, sizeof(tacplus_server_t) * TAC_PLUS_MAXSERVERS);\n    memset(&tac_srv_addr, 0, sizeof(struct addrinfo) * TAC_PLUS_MAXSERVERS);\n    memset(&tac_sock_addr, 0, sizeof(struct sockaddr) * TAC_PLUS_MAXSERVERS);\n    memset(&tac_sock6_addr, 0, sizeof(struct sockaddr_in6) * TAC_PLUS_MAXSERVERS);\n    tac_srv_no = 0;\n\n    tac_service[0] = 0;\n    tac_protocol[0] = 0;\n    tac_prompt[0] = 0;\n    tac_login[0] = 0;\n\n    for (ctrl = 0; argc-- > 0; ++argv) {\n        if (!strcmp(*argv, \"debug\")) { /* all */\n            ctrl |= PAM_TAC_DEBUG;\n        } else if (!strcmp(*argv, \"use_first_pass\")) {\n            ctrl |= PAM_TAC_USE_FIRST_PASS;\n        } else if (!strcmp(*argv, \"try_first_pass\")) {\n            ctrl |= PAM_TAC_TRY_FIRST_PASS;\n        } else if (!strncmp(*argv, \"service=\", 8)) { /* author & acct */\n            xstrcpy(tac_service, *argv + 8, sizeof(tac_service));\n        } else if (!strncmp(*argv, \"protocol=\", 9)) { /* author & acct */\n            xstrcpy(tac_protocol, *argv + 9, sizeof(tac_protocol));\n        } else if (!strncmp(*argv, \"prompt=\", 7)) { /* authentication */\n            xstrcpy(tac_prompt, *argv + 7, sizeof(tac_prompt));\n            /* Replace _ with space */\n            unsigned long chr;\n            for (chr = 0; chr < strlen(tac_prompt); chr++) {\n                if (tac_prompt[chr] == '_') {\n                    tac_prompt[chr] = ' ';\n                }\n            }\n        } else if (!strncmp(*argv, \"login=\", 6)) {\n            xstrcpy(tac_login, *argv + 6, sizeof(tac_login));\n        } else if (!strcmp(*argv, \"acct_all\")) {\n            ctrl |= PAM_TAC_ACCT;\n        } else if (!strncmp(*argv, \"server=\", 7)) { /* authen & acct */\n            if (tac_srv_no < TAC_PLUS_MAXSERVERS) {\n                struct addrinfo hints, *servers, *server;\n                int rv;\n                char *close_bracket, *server_name, *port, server_buf[256];\n\n                memset(&hints, 0, sizeof hints);\n                memset(&server_buf, 0, sizeof(server_buf));\n                hints.ai_family = AF_UNSPEC;  /* use IPv4 or IPv6, whichever */\n                hints.ai_socktype = SOCK_STREAM;\n\n                if (strlen(*argv + 7) >= sizeof(server_buf)) {\n                    _pam_log(LOG_ERR, \"server address too long, sorry\");\n                    continue;\n                }\n                strcpy(server_buf, *argv + 7);\n\n                if (*server_buf == '[' &&\n                    (close_bracket = strchr(server_buf, ']')) != NULL) { /* Check for URI syntax */\n                    server_name = server_buf + 1;\n                    _pam_log (LOG_ERR,\n                        \"reading server address as: %s \",\n                        server_name);\n                    port = strchr(close_bracket, ':');\n                    *close_bracket = '\\0';\n                } else { /* Fall back to traditional syntax */\n                    server_name = server_buf;\n                    port = strchr(server_buf, ':');\n                }\n                if (port != NULL) {\n                    *port = '\\0';\n                    port++;\n                }\n                _pam_log (LOG_DEBUG,\n                        \"sending server address to getaddrinfo as: %s \",\n                        server_name);\n                if ((rv = getaddrinfo(server_name, (port == NULL) ? \"49\" : port, &hints, &servers)) == 0) {\n                    for (server = servers;\n                         server != NULL && tac_srv_no < TAC_PLUS_MAXSERVERS; server = server->ai_next) {\n                        set_tac_srv_addr(tac_srv_no, server);\n                        set_tac_srv_key(tac_srv_no, current_secret);\n                        tac_srv_no++;\n                    }\n                    _pam_log(LOG_DEBUG, \"%s: server index %d \", __FUNCTION__, tac_srv_no);\n                    freeaddrinfo (servers);\n                } else {\n                    _pam_log(LOG_ERR,\n                             \"skip invalid server: %s (getaddrinfo: %s)\",\n                             server_name, gai_strerror(rv));\n                }\n            } else {\n                _pam_log(LOG_ERR, \"maximum number of servers (%d) exceeded, skipping\",\n                         TAC_PLUS_MAXSERVERS);\n            }\n        } else if (!strncmp(*argv, \"secret=\", 7)) {\n            current_secret = *argv + 7;     /* points right into argv (which is const) */\n\n            // this is possible because server structure is initialized only on the server= occurence\n            if (tac_srv_no == 0) {\n                _pam_log(LOG_ERR, \"secret set but no servers configured yet\");\n            } else {\n                // set secret for the last server configured\n                set_tac_srv_key(tac_srv_no - 1, current_secret);\n            }\n        } else if (!strncmp(*argv, \"timeout=\", 8)) {\n\n#ifdef HAVE_STRTOL\n            tac_timeout = strtol(*argv + 8, NULL, 10);\n\n#else\n            tac_timeout = atoi(*argv + 8);\n#endif\n            if (tac_timeout == LONG_MAX) {\n                _pam_log(LOG_ERR, \"timeout parameter cannot be parsed as integer: %s\", *argv);\n                tac_timeout = 0;\n            } else {\n                tac_readtimeout_enable = 1;\n            }\n        } else {\n            _pam_log(LOG_WARNING, \"unrecognized option: %s\", *argv);\n        }\n    }\n\n    if (ctrl & PAM_TAC_DEBUG) {\n        unsigned long n;\n\n        _pam_log(LOG_DEBUG, \"%d servers defined\", tac_srv_no);\n\n        for (n = 0; n < tac_srv_no; n++) {\n            _pam_log(LOG_DEBUG, \"server[%lu] { addr=%s, key='********' }\", n,\n\t\t\t    tac_ntop(tac_srv[n].addr->ai_addr));\n        }\n\n        _pam_log(LOG_DEBUG, \"tac_service='%s'\", tac_service);\n        _pam_log(LOG_DEBUG, \"tac_protocol='%s'\", tac_protocol);\n        _pam_log(LOG_DEBUG, \"tac_prompt='%s'\", tac_prompt);\n        _pam_log(LOG_DEBUG, \"tac_login='%s'\", tac_login);\n    }\n\n    return ctrl;\n}    /* _pam_parse */",
        "start_line": 248
      }
    ],
    "code_context": "Called Methods:\n- _pam_log: void _pam_log(int err, const char *format, ...) { /* <=== _pam_log */ \n    char msg[256];\n    va_list args;\n\n    va_start(args, format);\n    vsnprintf(msg, sizeof(msg), format, args);\n    syslog(err, \"PAM-tacplus: %s\", msg);\n    va_end(args);\n}\n- PAM_TAC_USE_FIRST_PASS: #define PAM_TAC_USE_FIRST_PASS 0x04 /* <=== pam_tacplus.h:37:37:PAM_TAC_USE_FIRST_PASS:0 */ \n- TAC_PLUS_MAXSERVERS: #define TAC_PLUS_MAXSERVERS 8 /* <=== libtac/include/libtac.h:112:112:TAC_PLUS_MAXSERVERS:0 */ \n- tac_ntop: char *tac_ntop(const struct sockaddr *); /* <=== tac_ntop */ \n- PAM_TAC_DEBUG: #define PAM_TAC_DEBUG 0x01 /* <=== pam_tacplus.h:35:35:PAM_TAC_DEBUG:0 */ \n- PAM_TAC_ACCT: #define PAM_TAC_ACCT  0x02 /* account on all specified servers */ /* <=== pam_tacplus.h:36:36:PAM_TAC_ACCT:0 */ \n- PAM_TAC_TRY_FIRST_PASS: #define PAM_TAC_TRY_FIRST_PASS 0x08 /* <=== pam_tacplus.h:38:38:PAM_TAC_TRY_FIRST_PASS:0 */ \n\nType Definitions:\n- tacplus_server_t: typedef struct {\n    struct addrinfo *addr;\n    const char *key;\n}\n- addrinfo: struct addrinfo\n\nGlobal Variables:\n- char[64] tac_service\n- char[64] tac_prompt\n- unsigned int tac_srv_no\n- tacplus_server_t[8] tac_srv\n- char[64] tac_protocol\n\nImports:\n- #include \"config.h\"\n- #include <limits.h>\n- #include \"support.h\"\n- #include \"pam_tacplus.h\"",
    "commit_msg": "pam: don't leak TACACS+ secret to journald\n\nIf journald for syslog is used, the journal is going to store everything,\neven DEBUG loglevel messages. Pre-journald logging of system-wide DEBUG\nloglevel could be avoided and is not affected in all cases.\n\nWith journald presence it's probably safe to no longer log sensitive\ndetails at DEBUG level.\n\nFix #149\n\nSigned-off-by: Daniel Gollub <dgollub@att.com>",
    "cve_desc": "[{'lang': 'en', 'value': 'In support.c in pam_tacplus 1.3.8 through 1.5.1, the TACACS+ shared secret gets logged via syslog if the DEBUG loglevel and journald are used.'}]",
    "year": 2020,
    "filename": "support.c",
    "commit_url": "\"https://github.com/kravietz/pam_tacplus/commit/4a9852c31c2fd0c0e72fbb689a586aabcfb11cb0\""
  },
  {
    "repository": "FFmpeg/FFmpeg",
    "cve_id": "CVE-2020-13904",
    "cwe_list": [
      "CWE-416"
    ],
    "commit_hash": "6959358683c7533f586c07a766acc5fe9544d8b2",
    "short_hash": "69593586",
    "vulnerableMethods_before": [
      {
        "filename": "libavformat/hls.c",
        "method_name": "parse_playlist",
        "raw_code": "static int parse_playlist(HLSContext *c, const char *url, /* <=== parse_playlist */ \n                          struct playlist *pls, AVIOContext *in)\n{\n    int ret = 0, is_segment = 0, is_variant = 0;\n    int64_t duration = 0;\n    enum KeyType key_type = KEY_NONE;\n    uint8_t iv[16] = \"\";\n    int has_iv = 0;\n    char key[MAX_URL_SIZE] = \"\";\n    char line[MAX_URL_SIZE];\n    const char *ptr;\n    int close_in = 0;\n    int64_t seg_offset = 0;\n    int64_t seg_size = -1;\n    uint8_t *new_url = NULL;\n    struct variant_info variant_info;\n    char tmp_str[MAX_URL_SIZE];\n    struct segment *cur_init_section = NULL;\n\n    if (!in) {\n#if 1\n        AVDictionary *opts = NULL;\n        close_in = 1;\n        /* Some HLS servers don't like being sent the range header */\n        av_dict_set(&opts, \"seekable\", \"0\", 0);\n\n        // broker prior HTTP options that should be consistent across requests\n        av_dict_set(&opts, \"user-agent\", c->user_agent, 0);\n        av_dict_set(&opts, \"cookies\", c->cookies, 0);\n        av_dict_set(&opts, \"headers\", c->headers, 0);\n\n        ret = avio_open2(&in, url, AVIO_FLAG_READ,\n                         c->interrupt_callback, &opts);\n        av_dict_free(&opts);\n        if (ret < 0)\n            return ret;\n#else\n        ret = open_in(c, &in, url);\n        if (ret < 0)\n            return ret;\n        close_in = 1;\n#endif\n    }\n\n    if (av_opt_get(in, \"location\", AV_OPT_SEARCH_CHILDREN, &new_url) >= 0)\n        url = new_url;\n\n    read_chomp_line(in, line, sizeof(line));\n    if (strcmp(line, \"#EXTM3U\")) {\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n\n    if (pls) {\n        free_segment_list(pls);\n        pls->finished = 0;\n        pls->type = PLS_TYPE_UNSPECIFIED;\n    }\n    while (!avio_feof(in)) {\n        read_chomp_line(in, line, sizeof(line));\n        if (av_strstart(line, \"#EXT-X-STREAM-INF:\", &ptr)) {\n            is_variant = 1;\n            memset(&variant_info, 0, sizeof(variant_info));\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_variant_args,\n                               &variant_info);\n        } else if (av_strstart(line, \"#EXT-X-KEY:\", &ptr)) {\n            struct key_info info = {{0}};\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_key_args,\n                               &info);\n            key_type = KEY_NONE;\n            has_iv = 0;\n            if (!strcmp(info.method, \"AES-128\"))\n                key_type = KEY_AES_128;\n            if (!strcmp(info.method, \"SAMPLE-AES\"))\n                key_type = KEY_SAMPLE_AES;\n            if (!strncmp(info.iv, \"0x\", 2) || !strncmp(info.iv, \"0X\", 2)) {\n                ff_hex_to_data(iv, info.iv + 2);\n                has_iv = 1;\n            }\n            av_strlcpy(key, info.uri, sizeof(key));\n        } else if (av_strstart(line, \"#EXT-X-MEDIA:\", &ptr)) {\n            struct rendition_info info = {{0}};\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_rendition_args,\n                               &info);\n            new_rendition(c, &info, url);\n        } else if (av_strstart(line, \"#EXT-X-TARGETDURATION:\", &ptr)) {\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            pls->target_duration = atoi(ptr) * AV_TIME_BASE;\n        } else if (av_strstart(line, \"#EXT-X-MEDIA-SEQUENCE:\", &ptr)) {\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            pls->start_seq_no = atoi(ptr);\n        } else if (av_strstart(line, \"#EXT-X-PLAYLIST-TYPE:\", &ptr)) {\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            if (!strcmp(ptr, \"EVENT\"))\n                pls->type = PLS_TYPE_EVENT;\n            else if (!strcmp(ptr, \"VOD\"))\n                pls->type = PLS_TYPE_VOD;\n        } else if (av_strstart(line, \"#EXT-X-MAP:\", &ptr)) {\n            struct init_section_info info = {{0}};\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_init_section_args,\n                               &info);\n            cur_init_section = new_init_section(pls, &info, url);\n        } else if (av_strstart(line, \"#EXT-X-ENDLIST\", &ptr)) {\n            if (pls)\n                pls->finished = 1;\n        } else if (av_strstart(line, \"#EXTINF:\", &ptr)) {\n            is_segment = 1;\n            duration   = atof(ptr) * AV_TIME_BASE;\n        } else if (av_strstart(line, \"#EXT-X-BYTERANGE:\", &ptr)) {\n            seg_size = atoi(ptr);\n            ptr = strchr(ptr, '@');\n            if (ptr)\n                seg_offset = atoi(ptr+1);\n        } else if (av_strstart(line, \"#\", NULL)) {\n            continue;\n        } else if (line[0]) {\n            if (is_variant) {\n                if (!new_variant(c, &variant_info, line, url)) {\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n                is_variant = 0;\n            }\n            if (is_segment) {\n                struct segment *seg;\n                if (!pls) {\n                    if (!new_variant(c, 0, url, NULL)) {\n                        ret = AVERROR(ENOMEM);\n                        goto fail;\n                    }\n                    pls = c->playlists[c->n_playlists - 1];\n                }\n                seg = av_malloc(sizeof(struct segment));\n                if (!seg) {\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n                seg->duration = duration;\n                seg->key_type = key_type;\n                if (has_iv) {\n                    memcpy(seg->iv, iv, sizeof(iv));\n                } else {\n                    int seq = pls->start_seq_no + pls->n_segments;\n                    memset(seg->iv, 0, sizeof(seg->iv));\n                    AV_WB32(seg->iv + 12, seq);\n                }\n\n                if (key_type != KEY_NONE) {\n                    ff_make_absolute_url(tmp_str, sizeof(tmp_str), url, key);\n                    seg->key = av_strdup(tmp_str);\n                    if (!seg->key) {\n                        av_free(seg);\n                        ret = AVERROR(ENOMEM);\n                        goto fail;\n                    }\n                } else {\n                    seg->key = NULL;\n                }\n\n                ff_make_absolute_url(tmp_str, sizeof(tmp_str), url, line);\n                seg->url = av_strdup(tmp_str);\n                if (!seg->url) {\n                    av_free(seg->key);\n                    av_free(seg);\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n\n                dynarray_add(&pls->segments, &pls->n_segments, seg);\n                is_segment = 0;\n\n                seg->size = seg_size;\n                if (seg_size >= 0) {\n                    seg->url_offset = seg_offset;\n                    seg_offset += seg_size;\n                    seg_size = -1;\n                } else {\n                    seg->url_offset = 0;\n                    seg_offset = 0;\n                }\n\n                seg->init_section = cur_init_section;\n            }\n        }\n    }\n    if (pls)\n        pls->last_load_time = av_gettime_relative();\n\nfail:\n    av_free(new_url);\n    if (close_in)\n        avio_close(in);\n    return ret;\n}",
        "start_line": 663
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "libavformat/hls.c",
        "method_name": "parse_playlist",
        "raw_code": "static int parse_playlist(HLSContext *c, const char *url, /* <=== parse_playlist */ \n                          struct playlist *pls, AVIOContext *in)\n{\n    int ret = 0, is_segment = 0, is_variant = 0;\n    int64_t duration = 0;\n    enum KeyType key_type = KEY_NONE;\n    uint8_t iv[16] = \"\";\n    int has_iv = 0;\n    char key[MAX_URL_SIZE] = \"\";\n    char line[MAX_URL_SIZE];\n    const char *ptr;\n    int close_in = 0;\n    int64_t seg_offset = 0;\n    int64_t seg_size = -1;\n    uint8_t *new_url = NULL;\n    struct variant_info variant_info;\n    char tmp_str[MAX_URL_SIZE];\n    struct segment *cur_init_section = NULL;\n\n    if (!in) {\n#if 1\n        AVDictionary *opts = NULL;\n        close_in = 1;\n        /* Some HLS servers don't like being sent the range header */\n        av_dict_set(&opts, \"seekable\", \"0\", 0);\n\n        // broker prior HTTP options that should be consistent across requests\n        av_dict_set(&opts, \"user-agent\", c->user_agent, 0);\n        av_dict_set(&opts, \"cookies\", c->cookies, 0);\n        av_dict_set(&opts, \"headers\", c->headers, 0);\n\n        ret = avio_open2(&in, url, AVIO_FLAG_READ,\n                         c->interrupt_callback, &opts);\n        av_dict_free(&opts);\n        if (ret < 0)\n            return ret;\n#else\n        ret = open_in(c, &in, url);\n        if (ret < 0)\n            return ret;\n        close_in = 1;\n#endif\n    }\n\n    if (av_opt_get(in, \"location\", AV_OPT_SEARCH_CHILDREN, &new_url) >= 0)\n        url = new_url;\n\n    read_chomp_line(in, line, sizeof(line));\n    if (strcmp(line, \"#EXTM3U\")) {\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n\n    if (pls) {\n        free_segment_list(pls);\n        pls->finished = 0;\n        pls->type = PLS_TYPE_UNSPECIFIED;\n    }\n    while (!avio_feof(in)) {\n        read_chomp_line(in, line, sizeof(line));\n        if (av_strstart(line, \"#EXT-X-STREAM-INF:\", &ptr)) {\n            is_variant = 1;\n            memset(&variant_info, 0, sizeof(variant_info));\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_variant_args,\n                               &variant_info);\n        } else if (av_strstart(line, \"#EXT-X-KEY:\", &ptr)) {\n            struct key_info info = {{0}};\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_key_args,\n                               &info);\n            key_type = KEY_NONE;\n            has_iv = 0;\n            if (!strcmp(info.method, \"AES-128\"))\n                key_type = KEY_AES_128;\n            if (!strcmp(info.method, \"SAMPLE-AES\"))\n                key_type = KEY_SAMPLE_AES;\n            if (!strncmp(info.iv, \"0x\", 2) || !strncmp(info.iv, \"0X\", 2)) {\n                ff_hex_to_data(iv, info.iv + 2);\n                has_iv = 1;\n            }\n            av_strlcpy(key, info.uri, sizeof(key));\n        } else if (av_strstart(line, \"#EXT-X-MEDIA:\", &ptr)) {\n            struct rendition_info info = {{0}};\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_rendition_args,\n                               &info);\n            new_rendition(c, &info, url);\n        } else if (av_strstart(line, \"#EXT-X-TARGETDURATION:\", &ptr)) {\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            pls->target_duration = atoi(ptr) * AV_TIME_BASE;\n        } else if (av_strstart(line, \"#EXT-X-MEDIA-SEQUENCE:\", &ptr)) {\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            pls->start_seq_no = atoi(ptr);\n        } else if (av_strstart(line, \"#EXT-X-PLAYLIST-TYPE:\", &ptr)) {\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            if (!strcmp(ptr, \"EVENT\"))\n                pls->type = PLS_TYPE_EVENT;\n            else if (!strcmp(ptr, \"VOD\"))\n                pls->type = PLS_TYPE_VOD;\n        } else if (av_strstart(line, \"#EXT-X-MAP:\", &ptr)) {\n            struct init_section_info info = {{0}};\n            ret = ensure_playlist(c, &pls, url);\n            if (ret < 0)\n                goto fail;\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_init_section_args,\n                               &info);\n            cur_init_section = new_init_section(pls, &info, url);\n        } else if (av_strstart(line, \"#EXT-X-ENDLIST\", &ptr)) {\n            if (pls)\n                pls->finished = 1;\n        } else if (av_strstart(line, \"#EXTINF:\", &ptr)) {\n            is_segment = 1;\n            duration   = atof(ptr) * AV_TIME_BASE;\n        } else if (av_strstart(line, \"#EXT-X-BYTERANGE:\", &ptr)) {\n            seg_size = atoi(ptr);\n            ptr = strchr(ptr, '@');\n            if (ptr)\n                seg_offset = atoi(ptr+1);\n        } else if (av_strstart(line, \"#\", NULL)) {\n            continue;\n        } else if (line[0]) {\n            if (is_variant) {\n                if (!new_variant(c, &variant_info, line, url)) {\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n                is_variant = 0;\n            }\n            if (is_segment) {\n                struct segment *seg;\n                if (!pls) {\n                    if (!new_variant(c, 0, url, NULL)) {\n                        ret = AVERROR(ENOMEM);\n                        goto fail;\n                    }\n                    pls = c->playlists[c->n_playlists - 1];\n                }\n                seg = av_malloc(sizeof(struct segment));\n                if (!seg) {\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n                if (has_iv) {\n                    memcpy(seg->iv, iv, sizeof(iv));\n                } else {\n                    int seq = pls->start_seq_no + pls->n_segments;\n                    memset(seg->iv, 0, sizeof(seg->iv));\n                    AV_WB32(seg->iv + 12, seq);\n                }\n\n                if (key_type != KEY_NONE) {\n                    ff_make_absolute_url(tmp_str, sizeof(tmp_str), url, key);\n                    seg->key = av_strdup(tmp_str);\n                    if (!seg->key) {\n                        av_free(seg);\n                        ret = AVERROR(ENOMEM);\n                        goto fail;\n                    }\n                } else {\n                    seg->key = NULL;\n                }\n\n                ff_make_absolute_url(tmp_str, sizeof(tmp_str), url, line);\n                seg->url = av_strdup(tmp_str);\n                if (!seg->url) {\n                    av_free(seg->key);\n                    av_free(seg);\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n\n                if (duration < 0.001 * AV_TIME_BASE) {\n                    duration = 0.001 * AV_TIME_BASE;\n                }\n                seg->duration = duration;\n                seg->key_type = key_type;\n                dynarray_add(&pls->segments, &pls->n_segments, seg);\n                is_segment = 0;\n\n                seg->size = seg_size;\n                if (seg_size >= 0) {\n                    seg->url_offset = seg_offset;\n                    seg_offset += seg_size;\n                    seg_size = -1;\n                } else {\n                    seg->url_offset = 0;\n                    seg_offset = 0;\n                }\n\n                seg->init_section = cur_init_section;\n            }\n        }\n    }\n    if (pls)\n        pls->last_load_time = av_gettime_relative();\n\nfail:\n    av_free(new_url);\n    if (close_in)\n        avio_close(in);\n    return ret;\n}",
        "start_line": 663
      }
    ],
    "code_context": "Called Methods:\n- AVIO_FLAG_READ: #define AVIO_FLAG_READ  1                                      /**< read-only */ /* <=== libavformat/avio.h:485:485:AVIO_FLAG_READ:0 */ \n- av_strtok: char *av_strtok(char *s, const char *delim, char **saveptr) /* <=== av_strtok */ \n{\n    char *tok;\n\n    if (!s && !(s = *saveptr))\n        return NULL;\n\n    /* skip leading delimiters */\n    s += strspn(s, delim);\n\n    /* s now points to the first non delimiter char, or to the end of the string */\n    if (!*s) {\n        *saveptr = NULL;\n        return NULL;\n    }\n    tok = s++;\n\n    /* skip non delimiters */\n    s += strcspn(s, delim);\n    if (*s) {\n        *s = 0;\n        *saveptr = s+1;\n    } else {\n        *saveptr = NULL;\n    }\n\n    return tok;\n}\n- av_get_sample_fmt_name: const char *av_get_sample_fmt_name(enum AVSampleFormat sample_fmt) /* <=== av_get_sample_fmt_name */ \n{\n    if (sample_fmt < 0 || sample_fmt >= AV_SAMPLE_FMT_NB)\n        return NULL;\n    return sample_fmt_info[sample_fmt].name;\n}\n- av_gettime_relative: int64_t av_gettime_relative(void) /* <=== av_gettime_relative */ \n{\n#if HAVE_CLOCK_GETTIME && defined(CLOCK_MONOTONIC)\n    struct timespec ts;\n    clock_gettime(CLOCK_MONOTONIC, &ts);\n    return (int64_t)ts.tv_sec * 1000000 + ts.tv_nsec / 1000;\n#else\n    return av_gettime() + 42 * 60 * 60 * INT64_C(1000000);\n#endif\n}\n- av_malloc: void *av_malloc(size_t size) /* <=== av_malloc */ \n{\n    void *ptr = NULL;\n#if CONFIG_MEMALIGN_HACK\n    long diff;\n#endif\n\n    /* let's disallow possibly ambiguous cases */\n    if (size > (max_alloc_size - 32))\n        return NULL;\n\n#if CONFIG_MEMALIGN_HACK\n    ptr = malloc(size + ALIGN);\n    if (!ptr)\n        return ptr;\n    diff              = ((~(long)ptr)&(ALIGN - 1)) + 1;\n    ptr               = (char *)ptr + diff;\n    ((char *)ptr)[-1] = diff;\n#elif HAVE_POSIX_MEMALIGN\n    if (size) //OS X on SDK 10.6 has a broken posix_memalign implementation\n    if (posix_memalign(&ptr, ALIGN, size))\n        ptr = NULL;\n#elif HAVE_ALIGNED_MALLOC\n    ptr = _aligned_malloc(size, ALIGN);\n#elif HAVE_MEMALIGN\n#ifndef __DJGPP__\n    ptr = memalign(ALIGN, size);\n#else\n    ptr = memalign(size, ALIGN);\n#endif\n    /* Why 64?\n     * Indeed, we should align it:\n     *   on  4 for 386\n     *   on 16 for 486\n     *   on 32 for 586, PPro - K6-III\n     *   on 64 for K7 (maybe for P3 too).\n     * Because L1 and L2 caches are aligned on those values.\n     * But I don't want to code such logic here!\n     */\n    /* Why 32?\n     * For AVX ASM. SSE / NEON needs only 16.\n     * Why not larger? Because I did not see a difference in benchmarks ...\n     */\n    /* benchmarks with P3\n     * memalign(64) + 1          3071, 3051, 3032\n     * memalign(64) + 2          3051, 3032, 3041\n     * memalign(64) + 4          2911, 2896, 2915\n     * memalign(64) + 8          2545, 2554, 2550\n     * memalign(64) + 16         2543, 2572, 2563\n     * memalign(64) + 32         2546, 2545, 2571\n     * memalign(64) + 64         2570, 2533, 2558\n     *\n     * BTW, malloc seems to do 8-byte alignment by default here.\n     */\n#else\n    ptr = malloc(size);\n#endif\n    if(!ptr && !size) {\n        size = 1;\n        ptr= av_malloc(1);\n    }\n#if CONFIG_MEMORY_POISONING\n    if (ptr)\n        memset(ptr, FF_MEMORY_POISON, size);\n#endif\n    return ptr;\n}\n- avio_flush: void avio_flush(AVIOContext *s) /* <=== avio_flush */ \n{\n    flush_buffer(s);\n    s->must_flush = 0;\n}\n- av_toupper: static inline av_const int av_toupper(int c) /* <=== av_toupper */ \n{\n    if (c >= 'a' && c <= 'z')\n        c ^= 0x20;\n    return c;\n}\n- av_get_pix_fmt_name: const char *av_get_pix_fmt_name(enum AVPixelFormat pix_fmt) /* <=== av_get_pix_fmt_name */ \n{\n    return (unsigned)pix_fmt < AV_PIX_FMT_NB ?\n        av_pix_fmt_descriptors[pix_fmt].name : NULL;\n}\n- AVERROR_OPTION_NOT_FOUND: #define AVERROR_OPTION_NOT_FOUND   FFERRTAG(0xF8,'O','P','T') ///< Option not found /* <=== libavutil/error.h:61:61:AVERROR_OPTION_NOT_FOUND:0 */ \n- av_strlcpy: size_t av_strlcpy(char *dst, const char *src, size_t size) /* <=== av_strlcpy */ \n{\n    size_t len = 0;\n    while (++len < size && *src)\n        *dst++ = *src++;\n    if (len <= size)\n        *dst = 0;\n    return len + strlen(src) - 1;\n}\n- new_init_section: static struct segment *new_init_section(struct playlist *pls, /* <=== new_init_section */ \n                                        struct init_section_info *info,\n                                        const char *url_base)\n{\n    struct segment *sec;\n    char *ptr;\n    char tmp_str[MAX_URL_SIZE];\n\n    if (!info->uri[0])\n        return NULL;\n\n    sec = av_mallocz(sizeof(*sec));\n    if (!sec)\n        return NULL;\n\n    ff_make_absolute_url(tmp_str, sizeof(tmp_str), url_base, info->uri);\n    sec->url = av_strdup(tmp_str);\n    if (!sec->url) {\n        av_free(sec);\n        return NULL;\n    }\n\n    if (info->byterange[0]) {\n        sec->size = atoi(info->byterange);\n        ptr = strchr(info->byterange, '@');\n        if (ptr)\n            sec->url_offset = atoi(ptr+1);\n    } else {\n        /* the entire file is the init section */\n        sec->size = -1;\n    }\n\n    dynarray_add(&pls->init_sections, &pls->n_init_sections, sec);\n\n    return sec;\n}\n- read_chomp_line: static int read_chomp_line(AVIOContext *s, char *buf, int maxlen) /* <=== read_chomp_line */ \n{\n    int len = ff_get_line(s, buf, maxlen);\n    while (len > 0 && av_isspace(buf[len - 1]))\n        buf[--len] = '\\0';\n    return len;\n}\n- av_opt_get: int av_opt_get(void *obj, const char *name, int search_flags, uint8_t **out_val) /* <=== av_opt_get */ \n{\n    void *dst, *target_obj;\n    const AVOption *o = av_opt_find2(obj, name, NULL, 0, search_flags, &target_obj);\n    uint8_t *bin, buf[128];\n    int len, i, ret;\n    int64_t i64;\n\n    if (!o || !target_obj || (o->offset<=0 && o->type != AV_OPT_TYPE_CONST))\n        return AVERROR_OPTION_NOT_FOUND;\n\n    dst = (uint8_t*)target_obj + o->offset;\n\n    buf[0] = 0;\n    switch (o->type) {\n    case AV_OPT_TYPE_FLAGS:     ret = snprintf(buf, sizeof(buf), \"0x%08X\",  *(int    *)dst);break;\n    case AV_OPT_TYPE_INT:       ret = snprintf(buf, sizeof(buf), \"%d\" ,     *(int    *)dst);break;\n    case AV_OPT_TYPE_INT64:     ret = snprintf(buf, sizeof(buf), \"%\"PRId64, *(int64_t*)dst);break;\n    case AV_OPT_TYPE_FLOAT:     ret = snprintf(buf, sizeof(buf), \"%f\" ,     *(float  *)dst);break;\n    case AV_OPT_TYPE_DOUBLE:    ret = snprintf(buf, sizeof(buf), \"%f\" ,     *(double *)dst);break;\n    case AV_OPT_TYPE_VIDEO_RATE:\n    case AV_OPT_TYPE_RATIONAL:  ret = snprintf(buf, sizeof(buf), \"%d/%d\",   ((AVRational*)dst)->num, ((AVRational*)dst)->den);break;\n    case AV_OPT_TYPE_CONST:     ret = snprintf(buf, sizeof(buf), \"%f\" ,     o->default_val.dbl);break;\n    case AV_OPT_TYPE_STRING:\n        if (*(uint8_t**)dst)\n            *out_val = av_strdup(*(uint8_t**)dst);\n        else\n            *out_val = av_strdup(\"\");\n        return *out_val ? 0 : AVERROR(ENOMEM);\n    case AV_OPT_TYPE_BINARY:\n        len = *(int*)(((uint8_t *)dst) + sizeof(uint8_t *));\n        if ((uint64_t)len*2 + 1 > INT_MAX)\n            return AVERROR(EINVAL);\n        if (!(*out_val = av_malloc(len*2 + 1)))\n            return AVERROR(ENOMEM);\n        if (!len) {\n            *out_val[0] = '\\0';\n            return 0;\n        }\n        bin = *(uint8_t**)dst;\n        for (i = 0; i < len; i++)\n            snprintf(*out_val + i*2, 3, \"%02X\", bin[i]);\n        return 0;\n    case AV_OPT_TYPE_IMAGE_SIZE:\n        ret = snprintf(buf, sizeof(buf), \"%dx%d\", ((int *)dst)[0], ((int *)dst)[1]);\n        break;\n    case AV_OPT_TYPE_PIXEL_FMT:\n        ret = snprintf(buf, sizeof(buf), \"%s\", (char *)av_x_if_null(av_get_pix_fmt_name(*(enum AVPixelFormat *)dst), \"none\"));\n        break;\n    case AV_OPT_TYPE_SAMPLE_FMT:\n        ret = snprintf(buf, sizeof(buf), \"%s\", (char *)av_x_if_null(av_get_sample_fmt_name(*(enum AVSampleFormat *)dst), \"none\"));\n        break;\n    case AV_OPT_TYPE_DURATION:\n        i64 = *(int64_t *)dst;\n        ret = snprintf(buf, sizeof(buf), \"%\"PRIi64\":%02d:%02d.%06d\",\n                       i64 / 3600000000, (int)((i64 / 60000000) % 60),\n                       (int)((i64 / 1000000) % 60), (int)(i64 % 1000000));\n        break;\n    case AV_OPT_TYPE_COLOR:\n        ret = snprintf(buf, sizeof(buf), \"0x%02x%02x%02x%02x\",\n                       (int)((uint8_t *)dst)[0], (int)((uint8_t *)dst)[1],\n                       (int)((uint8_t *)dst)[2], (int)((uint8_t *)dst)[3]);\n        break;\n    case AV_OPT_TYPE_CHANNEL_LAYOUT:\n        i64 = *(int64_t *)dst;\n        ret = snprintf(buf, sizeof(buf), \"0x%\"PRIx64, i64);\n        break;\n    default:\n        return AVERROR(EINVAL);\n    }\n\n    if (ret >= sizeof(buf))\n        return AVERROR(EINVAL);\n    *out_val = av_strdup(buf);\n    return *out_val ? 0 : AVERROR(ENOMEM);\n}\n- av_free: void av_free(void *ptr) /* <=== av_free */ \n{\n#if CONFIG_MEMALIGN_HACK\n    if (ptr) {\n        int v= ((char *)ptr)[-1];\n        av_assert0(v>0 && v<=ALIGN);\n        free((char *)ptr - v);\n    }\n#elif HAVE_ALIGNED_MALLOC\n    _aligned_free(ptr);\n#else\n    free(ptr);\n#endif\n}\n- new_playlist: static struct playlist *new_playlist(HLSContext *c, const char *url, /* <=== new_playlist */ \n                                     const char *base)\n{\n    struct playlist *pls = av_mallocz(sizeof(struct playlist));\n    if (!pls)\n        return NULL;\n    reset_packet(&pls->pkt);\n    ff_make_absolute_url(pls->url, sizeof(pls->url), base, url);\n    pls->seek_timestamp = AV_NOPTS_VALUE;\n\n    pls->is_id3_timestamped = -1;\n    pls->id3_mpegts_timestamp = AV_NOPTS_VALUE;\n\n    dynarray_add(&c->playlists, &c->n_playlists, pls);\n    return pls;\n}\n- avio_feof: int avio_feof(AVIOContext *s) /* <=== avio_feof */ \n{\n    if(!s)\n        return 0;\n    if(s->eof_reached){\n        s->eof_reached=0;\n        fill_buffer(s);\n    }\n    return s->eof_reached;\n}\n- AVERROR: #define AVERROR(e) (e) /* <=== libavutil/error.h:43:43:AVERROR:1 */ \n- ff_parse_key_value: void ff_parse_key_value(const char *str, ff_parse_key_val_cb callback_get_buf, /* <=== ff_parse_key_value */ \n                        void *context)\n{\n    const char *ptr = str;\n\n    /* Parse key=value pairs. */\n    for (;;) {\n        const char *key;\n        char *dest = NULL, *dest_end;\n        int key_len, dest_len = 0;\n\n        /* Skip whitespace and potential commas. */\n        while (*ptr && (av_isspace(*ptr) || *ptr == ','))\n            ptr++;\n        if (!*ptr)\n            break;\n\n        key = ptr;\n\n        if (!(ptr = strchr(key, '=')))\n            break;\n        ptr++;\n        key_len = ptr - key;\n\n        callback_get_buf(context, key, key_len, &dest, &dest_len);\n        dest_end = dest + dest_len - 1;\n\n        if (*ptr == '\\\"') {\n            ptr++;\n            while (*ptr && *ptr != '\\\"') {\n                if (*ptr == '\\\\') {\n                    if (!ptr[1])\n                        break;\n                    if (dest && dest < dest_end)\n                        *dest++ = ptr[1];\n                    ptr += 2;\n                } else {\n                    if (dest && dest < dest_end)\n                        *dest++ = *ptr;\n                    ptr++;\n                }\n            }\n            if (*ptr == '\\\"')\n                ptr++;\n        } else {\n            for (; *ptr && !(av_isspace(*ptr) || *ptr == ','); ptr++)\n                if (dest && dest < dest_end)\n                    *dest++ = *ptr;\n        }\n        if (dest)\n            *dest = 0;\n    }\n}\n- av_strstart: int av_strstart(const char *str, const char *pfx, const char **ptr) /* <=== av_strstart */ \n{\n    while (*pfx && *pfx == *str) {\n        pfx++;\n        str++;\n    }\n    if (!*pfx && ptr)\n        *ptr = str;\n    return !*pfx;\n}\n- av_realloc: void *av_realloc(void *ptr, size_t size) /* <=== av_realloc */ \n{\n#if CONFIG_MEMALIGN_HACK\n    int diff;\n#endif\n\n    /* let's disallow possibly ambiguous cases */\n    if (size > (max_alloc_size - 32))\n        return NULL;\n\n#if CONFIG_MEMALIGN_HACK\n    //FIXME this isn't aligned correctly, though it probably isn't needed\n    if (!ptr)\n        return av_malloc(size);\n    diff = ((char *)ptr)[-1];\n    av_assert0(diff>0 && diff<=ALIGN);\n    ptr = realloc((char *)ptr - diff, size + diff);\n    if (ptr)\n        ptr = (char *)ptr + diff;\n    return ptr;\n#elif HAVE_ALIGNED_MALLOC\n    return _aligned_realloc(ptr, size + !size, ALIGN);\n#else\n    return realloc(ptr, size + !size);\n#endif\n}\n- AV_DISPOSITION_FORCED: #define AV_DISPOSITION_FORCED    0x0040 /* <=== libavformat/avformat.h:813:813:AV_DISPOSITION_FORCED:0 */ \n- av_mallocz: void *av_mallocz(size_t size) /* <=== av_mallocz */ \n{\n    void *ptr = av_malloc(size);\n    if (ptr)\n        memset(ptr, 0, size);\n    return ptr;\n}\n- ensure_playlist: static int ensure_playlist(HLSContext *c, struct playlist **pls, const char *url) /* <=== ensure_playlist */ \n{\n    if (*pls)\n        return 0;\n    if (!new_variant(c, NULL, url, NULL))\n        return AVERROR(ENOMEM);\n    *pls = c->playlists[c->n_playlists - 1];\n    return 0;\n}\n- av_freep: void av_freep(void *arg) /* <=== av_freep */ \n{\n    void *val;\n\n    memcpy(&val, arg, sizeof(val));\n    memcpy(arg, &(void *){ NULL }, sizeof(val));\n    av_free(val);\n}\n- av_isspace: int av_isspace(int c) /* <=== av_isspace */ \n{\n    return c == ' ' || c == '\\f' || c == '\\n' || c == '\\r' || c == '\\t' ||\n           c == '\\v';\n}\n- av_opt_find2: const AVOption *av_opt_find2(void *obj, const char *name, const char *unit, /* <=== av_opt_find2 */ \n                             int opt_flags, int search_flags, void **target_obj)\n{\n    const AVClass  *c;\n    const AVOption *o = NULL;\n\n    if(!obj)\n        return NULL;\n\n    c= *(AVClass**)obj;\n\n    if (!c)\n        return NULL;\n\n    if (search_flags & AV_OPT_SEARCH_CHILDREN) {\n        if (search_flags & AV_OPT_SEARCH_FAKE_OBJ) {\n            const AVClass *child = NULL;\n            while (child = av_opt_child_class_next(c, child))\n                if (o = av_opt_find2(&child, name, unit, opt_flags, search_flags, NULL))\n                    return o;\n        } else {\n            void *child = NULL;\n            while (child = av_opt_child_next(obj, child))\n                if (o = av_opt_find2(child, name, unit, opt_flags, search_flags, target_obj))\n                    return o;\n        }\n    }\n\n    while (o = av_opt_next(obj, o)) {\n        if (!strcmp(o->name, name) && (o->flags & opt_flags) == opt_flags &&\n            ((!unit && o->type != AV_OPT_TYPE_CONST) ||\n             (unit  && o->type == AV_OPT_TYPE_CONST && o->unit && !strcmp(o->unit, unit)))) {\n            if (target_obj) {\n                if (!(search_flags & AV_OPT_SEARCH_FAKE_OBJ))\n                    *target_obj = obj;\n                else\n                    *target_obj = NULL;\n            }\n            return o;\n        }\n    }\n    return NULL;\n}\n- ffurl_open: int ffurl_open(URLContext **puc, const char *filename, int flags, /* <=== ffurl_open */ \n               const AVIOInterruptCB *int_cb, AVDictionary **options)\n{\n    int ret = ffurl_alloc(puc, filename, flags, int_cb);\n    if (ret < 0)\n        return ret;\n    if (options && (*puc)->prot->priv_data_class &&\n        (ret = av_opt_set_dict((*puc)->priv_data, options)) < 0)\n        goto fail;\n    if ((ret = av_opt_set_dict(*puc, options)) < 0)\n        goto fail;\n    ret = ffurl_connect(*puc, options);\n    if (!ret)\n        return 0;\nfail:\n    ffurl_close(*puc);\n    *puc = NULL;\n    return ret;\n}\n- MAX_URL_SIZE: #define MAX_URL_SIZE 4096 /* <=== libavformat/internal.h:28:28:MAX_URL_SIZE:0 */ \n- new_rendition: static struct rendition *new_rendition(HLSContext *c, struct rendition_info *info, /* <=== new_rendition */ \n                                      const char *url_base)\n{\n    struct rendition *rend;\n    enum AVMediaType type = AVMEDIA_TYPE_UNKNOWN;\n    char *characteristic;\n    char *chr_ptr;\n    char *saveptr;\n\n    if (!strcmp(info->type, \"AUDIO\"))\n        type = AVMEDIA_TYPE_AUDIO;\n    else if (!strcmp(info->type, \"VIDEO\"))\n        type = AVMEDIA_TYPE_VIDEO;\n    else if (!strcmp(info->type, \"SUBTITLES\"))\n        type = AVMEDIA_TYPE_SUBTITLE;\n    else if (!strcmp(info->type, \"CLOSED-CAPTIONS\"))\n        /* CLOSED-CAPTIONS is ignored since we do not support CEA-608 CC in\n         * AVC SEI RBSP anyway */\n        return NULL;\n\n    if (type == AVMEDIA_TYPE_UNKNOWN)\n        return NULL;\n\n    /* URI is mandatory for subtitles as per spec */\n    if (type == AVMEDIA_TYPE_SUBTITLE && !info->uri[0])\n        return NULL;\n\n    /* TODO: handle subtitles (each segment has to parsed separately) */\n    if (type == AVMEDIA_TYPE_SUBTITLE)\n        return NULL;\n\n    rend = av_mallocz(sizeof(struct rendition));\n    if (!rend)\n        return NULL;\n\n    dynarray_add(&c->renditions, &c->n_renditions, rend);\n\n    rend->type = type;\n    strcpy(rend->group_id, info->group_id);\n    strcpy(rend->language, info->language);\n    strcpy(rend->name, info->name);\n\n    /* add the playlist if this is an external rendition */\n    if (info->uri[0]) {\n        rend->playlist = new_playlist(c, info->uri, url_base);\n        if (rend->playlist)\n            dynarray_add(&rend->playlist->renditions,\n                         &rend->playlist->n_renditions, rend);\n    }\n\n    if (info->assoc_language[0]) {\n        int langlen = strlen(rend->language);\n        if (langlen < sizeof(rend->language) - 3) {\n            rend->language[langlen] = ',';\n            strncpy(rend->language + langlen + 1, info->assoc_language,\n                    sizeof(rend->language) - langlen - 2);\n        }\n    }\n\n    if (!strcmp(info->defaultr, \"YES\"))\n        rend->disposition |= AV_DISPOSITION_DEFAULT;\n    if (!strcmp(info->forced, \"YES\"))\n        rend->disposition |= AV_DISPOSITION_FORCED;\n\n    chr_ptr = info->characteristics;\n    while ((characteristic = av_strtok(chr_ptr, \",\", &saveptr))) {\n        if (!strcmp(characteristic, \"public.accessibility.describes-music-and-sound\"))\n            rend->disposition |= AV_DISPOSITION_HEARING_IMPAIRED;\n        else if (!strcmp(characteristic, \"public.accessibility.describes-video\"))\n            rend->disposition |= AV_DISPOSITION_VISUAL_IMPAIRED;\n\n        chr_ptr = NULL;\n    }\n\n    return rend;\n}\n- AV_OPT_SEARCH_CHILDREN: #define AV_OPT_SEARCH_CHILDREN   0x0001 /**< Search in possible children of the /* <=== libavutil/opt.h:611:611:AV_OPT_SEARCH_CHILDREN:0 */ \n- AV_DYNARRAY_ADD: #define AV_DYNARRAY_ADD(av_size_max, av_elt_size, av_array, av_size, \\ /* <=== libavutil/dynarray.h:45:68:AV_DYNARRAY_ADD:6 */ \n                        av_success, av_failure) \\\n    do { \\\n        size_t av_size_new = (av_size); \\\n        if (!((av_size) & ((av_size) - 1))) { \\\n            av_size_new = (av_size) ? (av_size) << 1 : 1; \\\n            if (av_size_new > (av_size_max) / (av_elt_size)) { \\\n                av_size_new = 0; \\\n            } else { \\\n                void *av_array_new = \\\n                    av_realloc((av_array), av_size_new * (av_elt_size)); \\\n                if (!av_array_new) \\\n                    av_size_new = 0; \\\n                else \\\n                    (av_array) = av_array_new; \\\n            } \\\n        } \\\n        if (av_size_new) { \\\n            { av_success } \\\n            (av_size)++; \\\n        } else { \\\n            av_failure \\\n        } \\\n    } while (0)\n- ff_hex_to_data: int ff_hex_to_data(uint8_t *data, const char *p) /* <=== ff_hex_to_data */ \n{\n    int c, len, v;\n\n    len = 0;\n    v   = 1;\n    for (;;) {\n        p += strspn(p, SPACE_CHARS);\n        if (*p == '\\0')\n            break;\n        c = av_toupper((unsigned char) *p++);\n        if (c >= '0' && c <= '9')\n            c = c - '0';\n        else if (c >= 'A' && c <= 'F')\n            c = c - 'A' + 10;\n        else\n            break;\n        v = (v << 4) | c;\n        if (v & 0x100) {\n            if (data)\n                data[len] = v;\n            len++;\n            v = 1;\n        }\n    }\n    return len;\n}\n- av_x_if_null: static inline void *av_x_if_null(const void *p, const void *x) /* <=== av_x_if_null */ \n{\n    return (void *)(intptr_t)(p ? p : x);\n}\n- avio_close: int avio_close(AVIOContext *s) /* <=== avio_close */ \n{\n    URLContext *h;\n\n    if (!s)\n        return 0;\n\n    avio_flush(s);\n    h = s->opaque;\n    av_freep(&s->buffer);\n    if (s->write_flag)\n        av_log(s, AV_LOG_DEBUG, \"Statistics: %d seeks, %d writeouts\\n\", s->seek_count, s->writeout_count);\n    else\n        av_log(s, AV_LOG_DEBUG, \"Statistics: %\"PRId64\" bytes read, %d seeks\\n\", s->bytes_read, s->seek_count);\n    av_free(s);\n    return ffurl_close(h);\n}\n- AV_DISPOSITION_HEARING_IMPAIRED: #define AV_DISPOSITION_HEARING_IMPAIRED  0x0080  /**< stream for hearing impaired audiences */ /* <=== libavformat/avformat.h:814:814:AV_DISPOSITION_HEARING_IMPAIRED:0 */ \n- ffio_fdopen: int ffio_fdopen(AVIOContext **s, URLContext *h) /* <=== ffio_fdopen */ \n{\n    uint8_t *buffer;\n    int buffer_size, max_packet_size;\n\n    max_packet_size = h->max_packet_size;\n    if (max_packet_size) {\n        buffer_size = max_packet_size; /* no need to bufferize more than one packet */\n    } else {\n        buffer_size = IO_BUFFER_SIZE;\n    }\n    buffer = av_malloc(buffer_size);\n    if (!buffer)\n        return AVERROR(ENOMEM);\n\n    *s = avio_alloc_context(buffer, buffer_size, h->flags & AVIO_FLAG_WRITE, h,\n                            (int (*)(void *, uint8_t *, int)) ffurl_read,\n                            (int (*)(void *, uint8_t *, int)) ffurl_write,\n                            (int64_t (*)(void *, int64_t, int)) ffurl_seek);\n    if (!*s) {\n        av_free(buffer);\n        return AVERROR(ENOMEM);\n    }\n    (*s)->direct = h->flags & AVIO_FLAG_DIRECT;\n    (*s)->seekable = h->is_streamed ? 0 : AVIO_SEEKABLE_NORMAL;\n    (*s)->max_packet_size = max_packet_size;\n    if(h->prot) {\n        (*s)->read_pause = (int (*)(void *, int))h->prot->url_read_pause;\n        (*s)->read_seek  = (int64_t (*)(void *, int, int64_t, int))h->prot->url_read_seek;\n    }\n    (*s)->av_class = &ff_avio_class;\n    return 0;\n}\n- AV_DISPOSITION_DEFAULT: #define AV_DISPOSITION_DEFAULT   0x0001 /* <=== libavformat/avformat.h:801:801:AV_DISPOSITION_DEFAULT:0 */ \n- fill_buffer: static void fill_buffer(AVIOContext *s) /* <=== fill_buffer */ \n{\n    int max_buffer_size = s->max_packet_size ?\n                          s->max_packet_size : IO_BUFFER_SIZE;\n    uint8_t *dst        = s->buf_end - s->buffer + max_buffer_size < s->buffer_size ?\n                          s->buf_end : s->buffer;\n    int len             = s->buffer_size - (dst - s->buffer);\n\n    /* can't fill the buffer without read_packet, just set EOF if appropriate */\n    if (!s->read_packet && s->buf_ptr >= s->buf_end)\n        s->eof_reached = 1;\n\n    /* no need to do anything if EOF already reached */\n    if (s->eof_reached)\n        return;\n\n    if (s->update_checksum && dst == s->buffer) {\n        if (s->buf_end > s->checksum_ptr)\n            s->checksum = s->update_checksum(s->checksum, s->checksum_ptr,\n                                             s->buf_end - s->checksum_ptr);\n        s->checksum_ptr = s->buffer;\n    }\n\n    /* make buffer smaller in case it ended up large after probing */\n    if (s->read_packet && s->orig_buffer_size && s->buffer_size > s->orig_buffer_size) {\n        if (dst == s->buffer) {\n            int ret = ffio_set_buf_size(s, s->orig_buffer_size);\n            if (ret < 0)\n                av_log(s, AV_LOG_WARNING, \"Failed to decrease buffer size\\n\");\n\n            s->checksum_ptr = dst = s->buffer;\n        }\n        av_assert0(len >= s->orig_buffer_size);\n        len = s->orig_buffer_size;\n    }\n\n    if (s->read_packet)\n        len = s->read_packet(s->opaque, dst, len);\n    else\n        len = 0;\n    if (len <= 0) {\n        /* do not modify buffer if EOF reached so that a seek back can\n           be done without rereading data */\n        s->eof_reached = 1;\n        if (len < 0)\n            s->error = len;\n    } else {\n        s->pos += len;\n        s->buf_ptr = dst;\n        s->buf_end = dst + len;\n        s->bytes_read += len;\n    }\n}\n- ff_get_line: int ff_get_line(AVIOContext *s, char *buf, int maxlen) /* <=== ff_get_line */ \n{\n    int i = 0;\n    char c;\n\n    do {\n        c = avio_r8(s);\n        if (c && i < maxlen-1)\n            buf[i++] = c;\n    } while (c != '\\n' && c != '\\r' && c);\n    if (c == '\\r' && avio_r8(s) != '\\n' && !avio_feof(s))\n        avio_skip(s, -1);\n\n    buf[i] = 0;\n    return i;\n}\n- ff_make_absolute_url: void ff_make_absolute_url(char *buf, int size, const char *base, /* <=== ff_make_absolute_url */ \n                          const char *rel)\n{\n    char *sep, *path_query;\n    /* Absolute path, relative to the current server */\n    if (base && strstr(base, \"://\") && rel[0] == '/') {\n        if (base != buf)\n            av_strlcpy(buf, base, size);\n        sep = strstr(buf, \"://\");\n        if (sep) {\n            /* Take scheme from base url */\n            if (rel[1] == '/') {\n                sep[1] = '\\0';\n            } else {\n                /* Take scheme and host from base url */\n                sep += 3;\n                sep = strchr(sep, '/');\n                if (sep)\n                    *sep = '\\0';\n            }\n        }\n        av_strlcat(buf, rel, size);\n        return;\n    }\n    /* If rel actually is an absolute url, just copy it */\n    if (!base || strstr(rel, \"://\") || rel[0] == '/') {\n        av_strlcpy(buf, rel, size);\n        return;\n    }\n    if (base != buf)\n        av_strlcpy(buf, base, size);\n\n    /* Strip off any query string from base */\n    path_query = strchr(buf, '?');\n    if (path_query)\n        *path_query = '\\0';\n\n    /* Is relative path just a new query part? */\n    if (rel[0] == '?') {\n        av_strlcat(buf, rel, size);\n        return;\n    }\n\n    /* Remove the file name from the base url */\n    sep = strrchr(buf, '/');\n    if (sep)\n        sep[1] = '\\0';\n    else\n        buf[0] = '\\0';\n    while (av_strstart(rel, \"../\", NULL) && sep) {\n        /* Remove the path delimiter at the end */\n        sep[0] = '\\0';\n        sep = strrchr(buf, '/');\n        /* If the next directory name to pop off is \"..\", break here */\n        if (!strcmp(sep ? &sep[1] : buf, \"..\")) {\n            /* Readd the slash we just removed */\n            av_strlcat(buf, \"/\", size);\n            break;\n        }\n        /* Cut off the directory name */\n        if (sep)\n            sep[1] = '\\0';\n        else\n            buf[0] = '\\0';\n        rel += 3;\n    }\n    av_strlcat(buf, rel, size);\n}\n- new_variant: static struct variant *new_variant(HLSContext *c, struct variant_info *info, /* <=== new_variant */ \n                                   const char *url, const char *base)\n{\n    struct variant *var;\n    struct playlist *pls;\n\n    pls = new_playlist(c, url, base);\n    if (!pls)\n        return NULL;\n\n    var = av_mallocz(sizeof(struct variant));\n    if (!var)\n        return NULL;\n\n    if (info) {\n        var->bandwidth = atoi(info->bandwidth);\n        strcpy(var->audio_group, info->audio);\n        strcpy(var->video_group, info->video);\n        strcpy(var->subtitles_group, info->subtitles);\n    }\n\n    dynarray_add(&c->variants, &c->n_variants, var);\n    dynarray_add(&var->playlists, &var->n_playlists, pls);\n    return var;\n}\n- dynarray_add: #define dynarray_add(tab, nb_ptr, elem)\\ /* <=== libavformat/internal.h:127:130:dynarray_add:3 */ \ndo {\\\n    av_dynarray_add((tab), nb_ptr, (elem));\\\n} while(0)\n- ffurl_close: int ffurl_close(URLContext *h) /* <=== ffurl_close */ \n{\n    return ffurl_closep(&h);\n}\n- AV_DISPOSITION_VISUAL_IMPAIRED: #define AV_DISPOSITION_VISUAL_IMPAIRED   0x0100  /**< stream for visual impaired audiences */ /* <=== libavformat/avformat.h:815:815:AV_DISPOSITION_VISUAL_IMPAIRED:0 */ \n- SPACE_CHARS: #define SPACE_CHARS \" \\t\\r\\n\" /* <=== libavformat/internal.h:225:225:SPACE_CHARS:0 */ \n- av_strlcat: size_t av_strlcat(char *dst, const char *src, size_t size) /* <=== av_strlcat */ \n{\n    size_t len = strlen(dst);\n    if (size <= len + 1)\n        return len + strlen(src);\n    return len + av_strlcpy(dst + len, src, size - len);\n}\n- avio_open2: int avio_open2(AVIOContext **s, const char *filename, int flags, /* <=== avio_open2 */ \n               const AVIOInterruptCB *int_cb, AVDictionary **options)\n{\n    URLContext *h;\n    int err;\n\n    err = ffurl_open(&h, filename, flags, int_cb, options);\n    if (err < 0)\n        return err;\n    err = ffio_fdopen(s, h);\n    if (err < 0) {\n        ffurl_close(h);\n        return err;\n    }\n    return 0;\n}\n- av_gettime: int64_t av_gettime(void) /* <=== av_gettime */ \n{\n#if HAVE_GETTIMEOFDAY\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    return (int64_t)tv.tv_sec * 1000000 + tv.tv_usec;\n#elif HAVE_GETSYSTEMTIMEASFILETIME\n    FILETIME ft;\n    int64_t t;\n    GetSystemTimeAsFileTime(&ft);\n    t = (int64_t)ft.dwHighDateTime << 32 | ft.dwLowDateTime;\n    return t / 10 - 11644473600000000; /* Jan 1, 1601 */\n#else\n    return -1;\n#endif\n}\n- AV_TIME_BASE: #define AV_TIME_BASE            1000000 /* <=== libavutil/avutil.h:246:246:AV_TIME_BASE:0 */ \n- read_chomp_line: static int read_chomp_line(AVIOContext *s, char *buf, int maxlen) /* <=== read_chomp_line */ \n{\n    int len = ff_get_line(s, buf, maxlen);\n    while (len > 0 && av_isspace(buf[len - 1]))\n        buf[--len] = '\\0';\n    return len;\n}\n- av_strdup: char *av_strdup(const char *s) /* <=== av_strdup */ \n{\n    char *ptr = NULL;\n    if (s) {\n        size_t len = strlen(s) + 1;\n        ptr = av_realloc(NULL, len);\n        if (ptr)\n            memcpy(ptr, s, len);\n    }\n    return ptr;\n}\n- av_dynarray_add: void av_dynarray_add(void *tab_ptr, int *nb_ptr, void *elem) /* <=== av_dynarray_add */ \n{\n    void **tab;\n    memcpy(&tab, tab_ptr, sizeof(tab));\n\n    AV_DYNARRAY_ADD(INT_MAX, sizeof(*tab), tab, *nb_ptr, {\n        tab[*nb_ptr] = elem;\n        memcpy(tab_ptr, &tab, sizeof(tab));\n    }, {\n        *nb_ptr = 0;\n        av_freep(tab_ptr);\n    });\n}\n\nType Definitions:\n- rendition: struct rendition {\n    enum AVMediaType type;\n    struct playlist *playlist;\n    char group_id[MAX_FIELD_LEN];\n    char language[MAX_FIELD_LEN];\n    char name[MAX_FIELD_LEN];\n    int disposition;\n}\n- HLSContext: typedef struct HLSContext {\n    AVClass *class;\n    int n_variants;\n    struct variant **variants;\n    int n_playlists;\n    struct playlist **playlists;\n    int n_renditions;\n    struct rendition **renditions;\n\n    int cur_seq_no;\n    int live_start_index;\n    int first_packet;\n    int64_t first_timestamp;\n    int64_t cur_timestamp;\n    AVIOInterruptCB *interrupt_callback;\n    char *user_agent;                    ///< holds HTTP user agent set as an AVOption to the HTTP protocol context\n    char *cookies;                       ///< holds HTTP cookie values set in either the initial response or as an AVOption to the HTTP protocol context\n    char *headers;                       ///< holds HTTP headers set as an AVOption to the HTTP protocol context\n    AVDictionary *avio_opts;\n    char *allowed_extensions;\n    int max_reload;\n} HLSContext;\n- rendition_info: struct rendition_info {\n    char type[16];\n    char uri[MAX_URL_SIZE];\n    char group_id[MAX_FIELD_LEN];\n    char language[MAX_FIELD_LEN];\n    char assoc_language[MAX_FIELD_LEN];\n    char name[MAX_FIELD_LEN];\n    char defaultr[4];\n    char forced[4];\n    char characteristics[MAX_CHARACTERISTICS_LEN];\n}\n- variant_info: struct variant_info {\n    char bandwidth[20];\n    /* variant group ids: */\n    char audio[MAX_FIELD_LEN];\n    char video[MAX_FIELD_LEN];\n    char subtitles[MAX_FIELD_LEN];\n}\n- AVIOContext: typedef struct AVIOContext {\n    /**\n     * A class for private options.\n     *\n     * If this AVIOContext is created by avio_open2(), av_class is set and\n     * passes the options down to protocols.\n     *\n     * If this AVIOContext is manually allocated, then av_class may be set by\n     * the caller.\n     *\n     * warning -- this field can be NULL, be sure to not pass this AVIOContext\n     * to any av_opt_* functions in that case.\n     */\n    const AVClass *av_class;\n    unsigned char *buffer;  /**< Start of the buffer. */\n    int buffer_size;        /**< Maximum buffer size */\n    unsigned char *buf_ptr; /**< Current position in the buffer */\n    unsigned char *buf_end; /**< End of the data, may be less than\n                                 buffer+buffer_size if the read function returned\n                                 less data than requested, e.g. for streams where\n                                 no more data has been received yet. */\n    void *opaque;           /**< A private pointer, passed to the read/write/seek/...\n                                 functions. */\n    int (*read_packet)(void *opaque, uint8_t *buf, int buf_size);\n    int (*write_packet)(void *opaque, uint8_t *buf, int buf_size);\n    int64_t (*seek)(void *opaque, int64_t offset, int whence);\n    int64_t pos;            /**< position in the file of the current buffer */\n    int must_flush;         /**< true if the next seek should flush */\n    int eof_reached;        /**< true if eof reached */\n    int write_flag;         /**< true if open for writing */\n    int max_packet_size;\n    unsigned long checksum;\n    unsigned char *checksum_ptr;\n    unsigned long (*update_checksum)(unsigned long checksum, const uint8_t *buf, unsigned int size);\n    int error;              /**< contains the error code or 0 if no error happened */\n    /**\n     * Pause or resume playback for network streaming protocols - e.g. MMS.\n     */\n    int (*read_pause)(void *opaque, int pause);\n    /**\n     * Seek to a given timestamp in stream with the specified stream_index.\n     * Needed for some network streaming protocols which don't support seeking\n     * to byte position.\n     */\n    int64_t (*read_seek)(void *opaque, int stream_index,\n                         int64_t timestamp, int flags);\n    /**\n     * A combination of AVIO_SEEKABLE_ flags or 0 when the stream is not seekable.\n     */\n    int seekable;\n\n    /**\n     * max filesize, used to limit allocations\n     * This field is internal to libavformat and access from outside is not allowed.\n     */\n    int64_t maxsize;\n\n    /**\n     * avio_read and avio_write should if possible be satisfied directly\n     * instead of going through a buffer, and avio_seek will always\n     * call the underlying seek function directly.\n     */\n    int direct;\n\n    /**\n     * Bytes read statistic\n     * This field is internal to libavformat and access from outside is not allowed.\n     */\n    int64_t bytes_read;\n\n    /**\n     * seek statistic\n     * This field is internal to libavformat and access from outside is not allowed.\n     */\n    int seek_count;\n\n    /**\n     * writeout statistic\n     * This field is internal to libavformat and access from outside is not allowed.\n     */\n    int writeout_count;\n\n    /**\n     * Original buffer size\n     * used internally after probing and ensure seekback to reset the buffer size\n     * This field is internal to libavformat and access from outside is not allowed.\n     */\n    int orig_buffer_size;\n\n    /**\n     * Threshold to favor readahead over seek.\n     * This is current internal only, do not use from outside.\n     */\n    int short_seek_threshold;\n}\n- AVDictionary: typedef struct AVDictionary\n- HLSContext: typedef struct HLSContext {\n    AVClass *class;\n    int n_variants;\n    struct variant **variants;\n    int n_playlists;\n    struct playlist **playlists;\n    int n_renditions;\n    struct rendition **renditions;\n\n    int cur_seq_no;\n    int live_start_index;\n    int first_packet;\n    int64_t first_timestamp;\n    int64_t cur_timestamp;\n    AVIOInterruptCB *interrupt_callback;\n    char *user_agent;                    ///< holds HTTP user agent set as an AVOption to the HTTP protocol context\n    char *cookies;                       ///< holds HTTP cookie values set in either the initial response or as an AVOption to the HTTP protocol context\n    char *headers;                       ///< holds HTTP headers set as an AVOption to the HTTP protocol context\n    AVDictionary *avio_opts;\n    char *allowed_extensions;\n    int max_reload;\n}\n- key_info: struct key_info {\n     char uri[MAX_URL_SIZE];\n     char method[11];\n     char iv[35];\n}\n- KeyType: enum KeyType {\n    KEY_NONE,\n    KEY_AES_128,\n    KEY_SAMPLE_AES\n}\n- segment: struct segment {\n    int64_t duration;\n    int64_t url_offset;\n    int64_t size;\n    char *url;\n    char *key;\n    enum KeyType key_type;\n    uint8_t iv[16];\n    /* associated Media Initialization Section, treated as a segment */\n    struct segment *init_section;\n}\n- init_section_info: struct init_section_info {\n    char uri[MAX_URL_SIZE];\n    char byterange[32];\n}\n- variant: struct variant {\n    int bandwidth;\n\n    /* every variant contains at least the main Media Playlist in index 0 */\n    int n_playlists;\n    struct playlist **playlists;\n\n    char audio_group[MAX_FIELD_LEN];\n    char video_group[MAX_FIELD_LEN];\n    char subtitles_group[MAX_FIELD_LEN];\n}\n- playlist: struct playlist {\n    char url[MAX_URL_SIZE];\n    AVIOContext pb;\n    uint8_t* read_buffer;\n    URLContext *input;\n    AVFormatContext *parent;\n    int index;\n    AVFormatContext *ctx;\n    AVPacket pkt;\n    int stream_offset;\n\n    int finished;\n    enum PlaylistType type;\n    int64_t target_duration;\n    int start_seq_no;\n    int n_segments;\n    struct segment **segments;\n    int needed, cur_needed;\n    int cur_seq_no;\n    int64_t cur_seg_offset;\n    int64_t last_load_time;\n\n    /* Currently active Media Initialization Section */\n    struct segment *cur_init_section;\n    uint8_t *init_sec_buf;\n    unsigned int init_sec_buf_size;\n    unsigned int init_sec_data_len;\n    unsigned int init_sec_buf_read_offset;\n\n    char key_url[MAX_URL_SIZE];\n    uint8_t key[16];\n\n    /* ID3 timestamp handling (elementary audio streams have ID3 timestamps\n     * (and possibly other ID3 tags) in the beginning of each segment) */\n    int is_id3_timestamped; /* -1: not yet known */\n    int64_t id3_mpegts_timestamp; /* in mpegts tb */\n    int64_t id3_offset; /* in stream original tb */\n    uint8_t* id3_buf; /* temp buffer for id3 parsing */\n    unsigned int id3_buf_size;\n    AVDictionary *id3_initial; /* data from first id3 tag */\n    int id3_found; /* ID3 tag found at some point */\n    int id3_changed; /* ID3 tag data has changed at some point */\n    ID3v2ExtraMeta *id3_deferred_extra; /* stored here until subdemuxer is opened */\n\n    int64_t seek_timestamp;\n    int seek_flags;\n    int seek_stream_index; /* into subdemuxer stream array */\n\n    /* Renditions associated with this playlist, if any.\n     * Alternative rendition playlists have a single rendition associated\n     * with them, and variant main Media Playlists may have\n     * multiple (playlist-less) renditions associated with them. */\n    int n_renditions;\n    struct rendition **renditions;\n\n    /* Media Initialization Sections (EXT-X-MAP) associated with this\n     * playlist, if any. */\n    int n_init_sections;\n    struct segment **init_sections;\n}\n\nImports:\n- #include \"avformat.h\"\n- #include \"avio_internal.h\"\n- #include \"libavutil/intreadwrite.h\"\n- #include \"url.h\"\n- #include \"libavutil/dict.h\"\n- #include \"libavutil/avassert.h\"\n- #include \"id3v2.h\"\n- #include \"libavutil/avstring.h\"\n- #include \"libavutil/opt.h\"\n- #include \"libavutil/time.h\"\n- #include \"libavutil/mathematics.h\"\n- #include \"internal.h\"",
    "commit_msg": "avformat/hls: check segment duration value of EXTINF\n\nfix ticket: 8673\nset the default EXTINF duration to 1ms if duration is smaller than 1ms\n\nSigned-off-by: Steven Liu <lq@chinaffmpeg.org>\n(cherry picked from commit 9dfb19baeb86a8bb02c53a441682c6e9a6e104cc)",
    "cve_desc": "[{'lang': 'en', 'value': 'FFmpeg 2.8 and 4.2.3 has a use-after-free via a crafted EXTINF duration in an m3u8 file because parse_playlist in libavformat/hls.c frees a pointer, and later that pointer is accessed in av_probe_input_format3 in libavformat/format.c.'}]",
    "year": 2020,
    "filename": "hls.c",
    "commit_url": "\"https://github.com/FFmpeg/FFmpeg/commit/6959358683c7533f586c07a766acc5fe9544d8b2\""
  },
  {
    "repository": "rpm-software-management/librepo",
    "cve_id": "CVE-2020-14352",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "7daea2a2429a54dad68b1de9b37a5f65c5cf2600",
    "short_hash": "7daea2a2",
    "vulnerableMethods_before": [
      {
        "filename": "librepo/yum.c",
        "method_name": "prepare_repo_download_targets",
        "raw_code": "gboolean /* <=== prepare_repo_download_targets */ \nprepare_repo_download_targets(LrHandle *handle,\n                              LrYumRepo *repo,\n                              LrYumRepoMd *repomd,\n                              LrMetadataTarget *mdtarget,\n                              GSList **targets,\n                              GSList **cbdata_list,\n                              GError **err)\n{\n    char *destdir;  /* Destination dir */\n\n    destdir = handle->destdir;\n    assert(destdir);\n    assert(strlen(destdir));\n    assert(!err || *err == NULL);\n\n    if(handle->cachedir) {\n        lr_yum_switch_to_zchunk(handle, repomd);\n        repo->use_zchunk = TRUE;\n    } else {\n        g_debug(\"%s: Cache directory not set, disabling zchunk\", __func__);\n        repo->use_zchunk = FALSE;\n    }\n\n    for (GSList *elem = repomd->records; elem; elem = g_slist_next(elem)) {\n        int fd;\n        char *path;\n        LrDownloadTarget *target;\n        LrYumRepoMdRecord *record = elem->data;\n        CbData *cbdata = NULL;\n        void *user_cbdata = NULL;\n        LrEndCb endcb = NULL;\n\n        if (mdtarget != NULL) {\n            user_cbdata = mdtarget->cbdata;\n            endcb = mdtarget->endcb;\n        }\n\n        assert(record);\n\n        if (!lr_yum_repomd_record_enabled(handle, record->type, repomd->records))\n            continue;\n\n        char *location_href = record->location_href;\n        gboolean is_zchunk = FALSE;\n        #ifdef WITH_ZCHUNK\n        if (handle->cachedir && record->header_checksum)\n            is_zchunk = TRUE;\n        #endif /* WITH_ZCHUNK */\n\n        GSList *checksums = NULL;\n        if (is_zchunk) {\n            #ifdef WITH_ZCHUNK\n            if(!prepare_repo_download_zck_target(handle, record, &path, &fd,\n                                                 &checksums, targets, err))\n                return FALSE;\n            #endif /* WITH_ZCHUNK */\n        } else {\n            if(!prepare_repo_download_std_target(handle, record, &path, &fd,\n                                                 &checksums, targets, err))\n                return FALSE;\n        }\n\n        if (handle->user_cb || handle->hmfcb) {\n            cbdata = cbdata_new(handle->user_data,\n                                user_cbdata,\n                                handle->user_cb,\n                                handle->hmfcb,\n                                record->type);\n            *cbdata_list = g_slist_append(*cbdata_list, cbdata);\n        }\n\n        target = lr_downloadtarget_new(handle,\n                                       location_href,\n                                       record->location_base,\n                                       fd,\n                                       NULL,\n                                       checksums,\n                                       0,\n                                       0,\n                                       NULL,\n                                       cbdata,\n                                       endcb,\n                                       NULL,\n                                       NULL,\n                                       0,\n                                       0,\n                                       NULL,\n                                       FALSE,\n                                       is_zchunk);\n\n        if(is_zchunk) {\n            #ifdef WITH_ZCHUNK\n            target->expectedsize = record->size_header;\n            target->zck_header_size = record->size_header;\n            #endif /* WITH_ZCHUNK */\n        }\n\n        if (mdtarget != NULL)\n            mdtarget->repomd_records_to_download++;\n        *targets = g_slist_append(*targets, target);\n\n        /* Because path may already exists in repo (while update) */\n        lr_yum_repo_update(repo, record->type, path);\n        lr_free(path);\n    }\n\n    return TRUE;\n}",
        "start_line": 729
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "librepo/yum.c",
        "method_name": "prepare_repo_download_targets",
        "raw_code": "gboolean /* <=== prepare_repo_download_targets */ \nprepare_repo_download_targets(LrHandle *handle,\n                              LrYumRepo *repo,\n                              LrYumRepoMd *repomd,\n                              LrMetadataTarget *mdtarget,\n                              GSList **targets,\n                              GSList **cbdata_list,\n                              GError **err)\n{\n    char *destdir;  /* Destination dir */\n\n    destdir = handle->destdir;\n    assert(destdir);\n    assert(strlen(destdir));\n    assert(!err || *err == NULL);\n\n    if(handle->cachedir) {\n        lr_yum_switch_to_zchunk(handle, repomd);\n        repo->use_zchunk = TRUE;\n    } else {\n        g_debug(\"%s: Cache directory not set, disabling zchunk\", __func__);\n        repo->use_zchunk = FALSE;\n    }\n\n    for (GSList *elem = repomd->records; elem; elem = g_slist_next(elem)) {\n        int fd;\n        char *path;\n        LrDownloadTarget *target;\n        LrYumRepoMdRecord *record = elem->data;\n        CbData *cbdata = NULL;\n        void *user_cbdata = NULL;\n        LrEndCb endcb = NULL;\n\n        if (mdtarget != NULL) {\n            user_cbdata = mdtarget->cbdata;\n            endcb = mdtarget->endcb;\n        }\n\n        assert(record);\n\n        if (!lr_yum_repomd_record_enabled(handle, record->type, repomd->records))\n            continue;\n\n        char *location_href = record->location_href;\n\n        char *dest_dir = realpath(handle->destdir, NULL);\n        path = lr_pathconcat(handle->destdir, record->location_href, NULL);\n        char *requested_dir = realpath(dirname(path), NULL);\n        lr_free(path);\n        if (!g_str_has_prefix(requested_dir, dest_dir)) {\n            g_debug(\"%s: Invalid path: %s\", __func__, location_href);\n            g_set_error(err, LR_YUM_ERROR, LRE_IO, \"Invalid path: %s\", location_href);\n            g_slist_free_full(*targets, (GDestroyNotify) lr_downloadtarget_free);\n            free(requested_dir);\n            free(dest_dir);\n            return FALSE;\n        }\n        free(requested_dir);\n        free(dest_dir);\n\n        gboolean is_zchunk = FALSE;\n        #ifdef WITH_ZCHUNK\n        if (handle->cachedir && record->header_checksum)\n            is_zchunk = TRUE;\n        #endif /* WITH_ZCHUNK */\n\n        GSList *checksums = NULL;\n        if (is_zchunk) {\n            #ifdef WITH_ZCHUNK\n            if(!prepare_repo_download_zck_target(handle, record, &path, &fd,\n                                                 &checksums, targets, err))\n                return FALSE;\n            #endif /* WITH_ZCHUNK */\n        } else {\n            if(!prepare_repo_download_std_target(handle, record, &path, &fd,\n                                                 &checksums, targets, err))\n                return FALSE;\n        }\n\n        if (handle->user_cb || handle->hmfcb) {\n            cbdata = cbdata_new(handle->user_data,\n                                user_cbdata,\n                                handle->user_cb,\n                                handle->hmfcb,\n                                record->type);\n            *cbdata_list = g_slist_append(*cbdata_list, cbdata);\n        }\n\n        target = lr_downloadtarget_new(handle,\n                                       location_href,\n                                       record->location_base,\n                                       fd,\n                                       NULL,\n                                       checksums,\n                                       0,\n                                       0,\n                                       NULL,\n                                       cbdata,\n                                       endcb,\n                                       NULL,\n                                       NULL,\n                                       0,\n                                       0,\n                                       NULL,\n                                       FALSE,\n                                       is_zchunk);\n\n        if(is_zchunk) {\n            #ifdef WITH_ZCHUNK\n            target->expectedsize = record->size_header;\n            target->zck_header_size = record->size_header;\n            #endif /* WITH_ZCHUNK */\n        }\n\n        if (mdtarget != NULL)\n            mdtarget->repomd_records_to_download++;\n        *targets = g_slist_append(*targets, target);\n\n        /* Because path may already exists in repo (while update) */\n        lr_yum_repo_update(repo, record->type, path);\n        lr_free(path);\n    }\n\n    return TRUE;\n}",
        "start_line": 730
      }
    ],
    "code_context": "Called Methods:\n- lr_string_chunk_insert: gchar * /* <=== lr_string_chunk_insert */ \nlr_string_chunk_insert(GStringChunk *chunk, const gchar *string)\n{\n    assert(chunk);\n\n    if (!string)\n        return NULL;\n\n    return g_string_chunk_insert(chunk, string);\n}\n- lr_malloc0: void * /* <=== lr_malloc0 */ \nlr_malloc0(size_t len)\n{\n    void *m = calloc(1, len);\n    if (!m) lr_out_of_memory();\n    return m;\n}\n- prepare_repo_download_std_target: gboolean /* <=== prepare_repo_download_std_target */ \nprepare_repo_download_std_target(LrHandle *handle,\n                                 LrYumRepoMdRecord *record,\n                                 char **path,\n                                 int *fd,\n                                 GSList **checksums,\n                                 GSList **targets,\n                                 GError **err)\n{\n    *path = lr_pathconcat(handle->destdir, record->location_href, NULL);\n    *fd = open(*path, O_CREAT|O_TRUNC|O_RDWR, 0666);\n    if (*fd < 0) {\n        g_debug(\"%s: Cannot create/open %s (%s)\",\n                __func__, *path, g_strerror(errno));\n        g_set_error(err, LR_YUM_ERROR, LRE_IO,\n                    \"Cannot create/open %s: %s\", *path, g_strerror(errno));\n        lr_free(*path);\n        g_slist_free_full(*targets, (GDestroyNotify) lr_downloadtarget_free);\n        return FALSE;\n    }\n\n    if (handle->checks & LR_CHECK_CHECKSUM) {\n        // Select proper checksum type only if checksum check is enabled\n        LrDownloadTargetChecksum *checksum;\n        checksum = lr_downloadtargetchecksum_new(\n                       lr_checksum_type(record->checksum_type),\n                       record->checksum);\n        *checksums = g_slist_prepend(*checksums, checksum);\n    }\n    return TRUE;\n}\n- lr_pathconcat: char * /* <=== lr_pathconcat */ \nlr_pathconcat(const char *first, ...)\n{\n    va_list args;\n    const char *next;\n    char *separator = DIR_SEPARATOR;\n    char *chunk, *res = NULL;\n    size_t separator_len = strlen(DIR_SEPARATOR);\n    size_t total_len;  // Maximal len of result\n    size_t offset = 0;\n    int is_first = 1;\n    char *qmark_section;\n    int previous_was_empty = 0; // If last chunk was \"\" then separator will be\n                                // appended to the result\n\n    if (!first)\n        return NULL;\n\n    total_len = strlen(first);\n\n    va_start(args, first);\n    while ((chunk = va_arg(args, char *)))\n        total_len += (strlen(chunk) + separator_len);\n    va_end(args);\n\n    if (total_len == 0)\n        return g_strdup(\"\");\n\n    qmark_section = strchr(first, '?');\n\n    res = lr_malloc(total_len + separator_len + 1);\n\n    next = first;\n    va_start(args, first);\n    while (1) {\n        const char *current, *start, *end;\n        size_t current_len;\n\n        if (next) {\n            current = next;\n            next = va_arg(args, char *);\n        } else\n            break;\n\n        current_len = strlen(current);\n\n        if (!current_len) {\n            previous_was_empty = 1;\n            continue;   /* Skip empty element */\n        } else\n            previous_was_empty = 0;\n\n        start = current;\n        end = start + current_len;\n         if (is_first && qmark_section)\n             end -= strlen(qmark_section);\n\n        /* Skip leading separators - except first element */\n        if (separator_len && is_first == 0) {\n            while (!strncmp(start, separator, separator_len))\n                start += separator_len;\n        }\n\n        /* Skip trailing separators */\n        if (separator_len) {\n            while (start + separator_len <= end &&\n                   !strncmp(end-separator_len, separator, separator_len))\n                end -= separator_len;\n        }\n\n        if (start >= end) {\n            /* Element is filled only by separators */\n            if (is_first)\n                is_first = 0;\n            continue;\n        }\n\n        /* Prepend separator - except first element */\n        if (is_first == 0) {\n            strncpy(res + offset, separator, separator_len);\n            offset += separator_len;\n        } else\n            is_first = 0;\n\n        strncpy(res + offset, start, end - start);\n        offset += end - start;\n    }\n    va_end(args);\n\n    if (qmark_section) {\n        strcpy(res + offset, qmark_section);\n        offset += strlen(qmark_section);\n    }\n\n    assert(offset <= total_len);\n\n    if (offset == 0) {\n        lr_free(res);\n        return g_strdup(first);\n    }\n\n    /* If last element was emtpy string, append separator to the end */\n    if (previous_was_empty && is_first == 0) {\n        strncpy(res + offset, separator, separator_len);\n        offset += separator_len;\n    }\n\n    assert(offset <= total_len);\n\n    res[offset] = '\\0';\n\n    return res;\n}\n- lr_yum_error_quark: GQuark /* <=== lr_yum_error_quark */ \nlr_yum_error_quark(void)\n{\n    return g_quark_from_static_string(\"lr_yum_error\");\n}\n- lr_yum_repomd_record_enabled: static gboolean /* <=== lr_yum_repomd_record_enabled */ \nlr_yum_repomd_record_enabled(LrHandle *handle, const char *type, GSList* records)\n{\n    // Blacklist check\n    if (handle->yumblist) {\n        int x = 0;\n        while (handle->yumblist[x]) {\n            if (!strcmp(handle->yumblist[x], type))\n                return FALSE;\n            x++;\n        }\n    }\n\n    // Whitelist check\n    if (handle->yumdlist) {\n        int x = 0;\n        while (handle->yumdlist[x]) {\n            if (!strcmp(handle->yumdlist[x], type))\n                return TRUE;\n            x++;\n        }\n        // Substitution check\n        if (handle->yumslist) {\n            for (GSList *elem = handle->yumslist; elem; elem = g_slist_next(elem)) {\n                LrVar* subs = elem->data;\n                if (!g_strcmp0(subs->val, type)) {\n                    char *orig = subs->var;\n                    for (guint i = 0; handle->yumdlist[i]; i++) {\n                        if (!g_strcmp0(orig, handle->yumdlist[i]) &&\n                            !g_slist_find_custom(records, orig, (GCompareFunc) compare_records))\n                            return TRUE;\n                    }\n                    return FALSE;\n                }\n            }\n        }\n        return FALSE;\n    }\n    return TRUE;\n}\n- lr_url_substitute: char * /* <=== lr_url_substitute */ \nlr_url_substitute(const char *url, LrUrlVars *list)\n{\n    const char *cur = url;\n    const char *p = url;\n\n    if (!url)\n        return NULL;\n\n    if (!list)\n        return g_strdup(url);\n\n    char *res = g_strdup(\"\");\n\n    while (*cur != '\\0') {\n        if (*cur == '$') {\n            // Adds unprocessed text before the variable to the \"res\".\n            if (cur-p) {\n                char *tmp = g_strndup(p, cur-p);\n                char *tmp_res = g_strconcat(res, tmp, NULL);\n                g_free(tmp);\n                g_free(res);\n                res = tmp_res;\n                p = cur;\n            }\n\n            // Tries to substitute the variable and store result to the \"res\".\n            gboolean bracket;\n            if (*++cur == '{') {\n                bracket = TRUE;\n                ++cur;\n            } else {\n                bracket = FALSE;\n            }\n            const char *varname = cur;\n            for (; isalnum(*cur) || *cur == '_'; ++cur);\n            if (cur != varname && (!bracket || *cur == '}')) {\n                for (LrUrlVars *elem = list; elem; elem = g_slist_next(elem)) {\n                    LrVar *var_val = elem->data;\n                    size_t var_len = strlen(var_val->var);\n                    if (var_len == cur - varname && strncmp(var_val->var, varname, var_len) == 0) {\n                        if (bracket)\n                            ++cur;\n                        p = cur;\n                        char *tmp_res = g_strconcat(res, var_val->val, NULL);\n                        g_free(res);\n                        res = tmp_res;\n                        break;\n                    }\n                }\n            }\n        } else {\n            ++cur;\n        }\n    }\n\n    // Adds remaining text to the \"res\".\n    if (*p != '\\0') {\n        char *tmp_res = g_strconcat(res, p, NULL);\n        g_free(res);\n        res = tmp_res;\n    }\n\n    return res;\n}\n- lr_yum_repo_update: static void /* <=== lr_yum_repo_update */ \nlr_yum_repo_update(LrYumRepo *repo, const char *type, const char *path)\n{\n    assert(repo);\n    assert(type);\n    assert(path);\n\n    for (GSList *elem = repo->paths; elem; elem = g_slist_next(elem)) {\n        LrYumRepoPath *yumrepopath = elem->data;\n        assert(yumrepopath);\n\n        if (!strcmp(yumrepopath->type, type)) {\n            lr_free(yumrepopath->path);\n            yumrepopath->path = g_strdup(path);\n            return;\n        }\n    }\n\n    lr_yum_repo_append(repo, type, path);\n}\n- lr_yum_repo_append: static void /* <=== lr_yum_repo_append */ \nlr_yum_repo_append(LrYumRepo *repo, const char *type, const char *path)\n{\n    assert(repo);\n    assert(type);\n    assert(path);\n\n    LrYumRepoPath *yumrepopath = lr_malloc(sizeof(LrYumRepoPath));\n    yumrepopath->type = g_strdup(type);\n    yumrepopath->path = g_strdup(path);\n    repo->paths = g_slist_append(repo->paths, yumrepopath);\n}\n- cbdata_new: static CbData *cbdata_new(void *userdata, /* <=== cbdata_new */ \n                          void *cbdata,\n                          LrProgressCb progresscb,\n                          LrHandleMirrorFailureCb hmfcb,\n                          const char *metadata)\n{\n    CbData *data = calloc(1, sizeof(*data));\n    data->userdata = userdata;\n    data->cbdata = cbdata;\n    data->progresscb = progresscb;\n    data->hmfcb = hmfcb;\n    data->metadata = g_strdup(metadata);\n    return data;\n}\n- DIR_SEPARATOR: #define DIR_SEPARATOR   \"/\" /* <=== librepo/util.c:42:42:DIR_SEPARATOR:0 */ \n- lr_downloadtargetchecksum_new: LrDownloadTargetChecksum * /* <=== lr_downloadtargetchecksum_new */ \nlr_downloadtargetchecksum_new(LrChecksumType type, const gchar *value)\n{\n    LrDownloadTargetChecksum *dtch = lr_malloc0(sizeof(*dtch));\n    dtch->type = type;\n    dtch->value = g_strdup(value);\n    return dtch;\n}\n- lr_malloc: void * /* <=== lr_malloc */ \nlr_malloc(size_t len)\n{\n    void *m = malloc(len);\n    if (!m) lr_out_of_memory();\n    return m;\n}\n- _cleanup_free_: #define _cleanup_free_ __attribute__ ((cleanup(lr_local_free))) /* <=== librepo/cleanup.h:95:95:_cleanup_free_:0 */ \n- LR_YUM_ERROR: #define LR_YUM_ERROR                lr_yum_error_quark() /* <=== librepo/rcodes.h:152:152:LR_YUM_ERROR:0 */ \n- lr_checksum_type: LrChecksumType /* <=== lr_checksum_type */ \nlr_checksum_type(const char *type)\n{\n    size_t len;\n    char type_lower[MAX_CHECKSUM_NAME_LEN+1];\n\n    if (!type)\n        return LR_CHECKSUM_UNKNOWN;\n\n    len = strlen(type);\n    if (len > MAX_CHECKSUM_NAME_LEN)\n        return LR_CHECKSUM_UNKNOWN;\n\n    for (size_t x = 0; x <= len; x++)\n        type_lower[x] = tolower(type[x]);\n\n    if (!strncmp(type_lower, \"md\", 2)) {\n        // MD* family\n        char *md_type = type_lower + 2;\n        if (!strcmp(md_type, \"5\"))\n            return LR_CHECKSUM_MD5;\n    } else if (!strncmp(type_lower, \"sha\", 3)) {\n        // SHA* family\n        char *sha_type = type_lower + 3;\n        if (!strcmp(sha_type, \"\"))\n            return LR_CHECKSUM_SHA1;\n        else if (!strcmp(sha_type, \"1\"))\n            return LR_CHECKSUM_SHA1;\n        else if (!strcmp(sha_type, \"224\"))\n            return LR_CHECKSUM_SHA224;\n        else if (!strcmp(sha_type, \"256\"))\n            return LR_CHECKSUM_SHA256;\n        else if (!strcmp(sha_type, \"384\"))\n            return LR_CHECKSUM_SHA384;\n        else if (!strcmp(sha_type, \"512\"))\n            return LR_CHECKSUM_SHA512;\n    }\n\n    return LR_CHECKSUM_UNKNOWN;\n}\n- lr_free: void /* <=== lr_free */ \nlr_free(void *m)\n{\n    if (m) free(m);\n}\n- lr_downloadtarget_new: LrDownloadTarget * /* <=== lr_downloadtarget_new */ \nlr_downloadtarget_new(LrHandle *handle,\n                      const char *path,\n                      const char *baseurl,\n                      int fd,\n                      const char *fn,\n                      GSList *possiblechecksums,\n                      gint64 expectedsize,\n                      gboolean resume,\n                      LrProgressCb progresscb,\n                      void *cbdata,\n                      LrEndCb endcb,\n                      LrMirrorFailureCb mirrorfailurecb,\n                      void *userdata,\n                      gint64 byterangestart,\n                      gint64 byterangeend,\n                      char *range,\n                      gboolean no_cache,\n                      gboolean is_zchunk)\n{\n    LrDownloadTarget *target;\n    _cleanup_free_ gchar *final_path = NULL;\n    _cleanup_free_ gchar *final_baseurl = NULL;\n\n    assert(path);\n    assert((fd >= 0 && !fn) || (fd < 0 && fn));\n\n    if (byterangestart && resume) {\n        g_warning(\"Cannot specify byterangestart and set resume to TRUE at the same time\");\n        return NULL;\n    }\n\n    // Substitute variables in URLs\n    if (handle && handle->urlvars) {\n        final_path      = lr_url_substitute(path, handle->urlvars);\n        final_baseurl   = lr_url_substitute(baseurl, handle->urlvars);\n    } else {\n        final_path      = g_strdup(path);\n        final_baseurl   = g_strdup(baseurl);\n    }\n\n\n    target = lr_malloc0(sizeof(*target));\n\n    target->handle          = handle;\n    target->chunk           = g_string_chunk_new(0);\n    target->path            = g_string_chunk_insert(target->chunk, final_path);\n    target->baseurl         = lr_string_chunk_insert(target->chunk, final_baseurl);\n    target->fd              = fd;\n    target->fn              = lr_string_chunk_insert(target->chunk, fn);\n    target->checksums       = possiblechecksums;\n    target->expectedsize    = expectedsize;\n    target->origsize        = expectedsize;\n    target->resume          = resume;\n    target->progresscb      = progresscb;\n    target->cbdata          = cbdata;\n    target->endcb           = endcb;\n    target->mirrorfailurecb = mirrorfailurecb;\n    target->rcode           = LRE_UNFINISHED;\n    target->userdata        = userdata;\n    target->byterangestart  = byterangestart;\n    target->byterangeend    = byterangeend;\n    target->range           = range;\n    target->no_cache        = no_cache;\n    target->is_zchunk       = is_zchunk;\n\n    return target;\n}\n\nType Definitions:\n- LrMetadataTarget: typedef struct {\n\n    LrHandle *handle; /*!<\n        Related handle */\n\n    LrYumRepo *repo; /*!<\n        Related repo */\n\n    LrYumRepoMd *repomd; /*!<\n        Related repomd */\n\n    int repomd_records_to_download;\n    int repomd_records_downloaded;/*!<\n        Necessary for endcb, which would be otherwise called prematurely */\n\n    void *cbdata; /*!<\n        Callback data */\n\n    LrProgressCb progresscb; /*!<\n        Progress callback */\n\n    LrMirrorFailureCb mirrorfailurecb;\n\n    LrEndCb endcb; /*!<\n        Callback called when target transfer is done.\n        (Use status to check if successfully or unsuccessfully) */\n\n    GList *err; /*!<\n        Array of error messages or NULL. NULL means no error. */\n\n    GStringChunk *chunk; /*!<\n        String chunk */\n\n    LrDownloadTarget *download_target; /*!<\n        Download target for repomd.xml */\n\n    gchar *gnupghomedir; /*!<\n        GNUPG home dir. */\n\n}\n- CbData_s: typedef struct CbData_s {\n    void *userdata;                 /*!< User data */\n    void *cbdata;                   /*!< User's callback data */\n    LrProgressCb progresscb;        /*!< Progress callback */\n    LrHandleMirrorFailureCb hmfcb;  /*!< Handle mirror failure callback */\n    char *metadata;                 /*!< \"primary\", \"filelists\", ... */\n}\n- LrYumRepoMdRecord: typedef struct {\n    char *type;                 /*!< Type of record (e.g. \"primary\") */\n    char *location_href;        /*!< Location href attribute */\n    char *location_base;        /*!< Location base attribute */\n    char *checksum;             /*!< Checksum value */\n    char *checksum_type;        /*!< Type of checksum */\n    char *checksum_open;        /*!< Checksum of uncompressed file */\n    char *checksum_open_type;   /*!< Type of checksum of uncompressed file */\n    char *header_checksum;      /*!< Checksum of zchunk header */\n    char *header_checksum_type; /*!< Type of checksum of zchunk header */\n    gint64 timestamp;           /*!< File timestamp */\n    gint64 size;                /*!< File size */\n    gint64 size_open;           /*!< Size of uncompressed file */\n    gint64 size_header;         /*!< Size of zchunk header */\n    int db_version;             /*!< Version of database */\n\n    GStringChunk *chunk;        /*!< String chunk */\n}\n- CbData: typedef struct CbData_s {\n    void *userdata;                 /*!< User data */\n    void *cbdata;                   /*!< User's callback data */\n    LrProgressCb progresscb;        /*!< Progress callback */\n    LrHandleMirrorFailureCb hmfcb;  /*!< Handle mirror failure callback */\n    char *metadata;                 /*!< \"primary\", \"filelists\", ... */\n} CbData;\n- LrDownloadTarget: typedef struct {\n\n    LrHandle *handle; /*!<\n        Handle */\n\n    char *path; /*!<\n        Relative path for URL (URL: \"http://foo.bar/stuff\",\n        path: \"somestuff.xml\") */\n\n    char *baseurl; /*!<\n        Base URL for this target. If used, then mirrorlist will be ignored. */\n\n    int fd; /*!<\n        Opened file descriptor where data will be written or -1.\n        Note: Only one, fd or fn, is set simultaneously. */\n\n    char *fn; /*!<\n        Filename where data will be written or NULL.\n        Note: Only one, fd or fn, is set simultaneously. */\n\n    GSList *checksums; /*!<\n        NULL or GSList with pointers to LrDownloadTargetChecksum\n        structures. With possible checksums of the file.\n        Checksum check is stopped right after first match.\n        Useful in situation when the file could has one from set\n        of available checksums.\n        E.g. <mm0:alternates> element in metalink could contain alternate\n        checksums for the repomd.xml, because metalink and mirrors\n        could be out of sync for a while. */\n\n    gint64 expectedsize; /*!<\n        Expected size of the target */\n\n    gint64 origsize; /*!<\n        Original expected size of the target.  Sometimes expectedsize will\n        change, especially if zchunk is in use, but this will never change */\n\n    gboolean resume; /*!<\n        Resume:\n         0  - no resume, download whole file,\n         otherwise - autodetect offset for resume */\n\n    LrProgressCb progresscb; /*!<\n        Progression callback for the target */\n\n    void *cbdata; /*!<\n        Callback user data */\n\n    LrEndCb endcb; /*!<\n        Callback called when target transfer is done.\n        (Use status to check if successfully or unsuccessfully) */\n\n    LrMirrorFailureCb mirrorfailurecb; /*!<\n        Called when download from a mirror failed. */\n\n    GStringChunk *chunk; /*!<\n        Chunk for strings used in this structure. */\n\n    gint64 byterangestart; /*!<\n        Download only specified range of bytes. */\n\n    gint64 byterangeend; /*!<\n        Download only specified range of bytes. */\n\n    gboolean no_cache; /*!<\n        Add headers that tell proxy server to provide a fresh data\n        instead of cached one. */\n\n    // Items filled by downloader\n\n    char *usedmirror; /*!<\n        Used mirror. Filled only if transfer was successful. */\n\n    char *effectiveurl; /*!<\n        Effective url. Filled only if transfer was successful. */\n\n    LrRc rcode; /*!<\n        Return code */\n\n    char *err; /*!<\n        NULL or error message */\n\n    // Other items\n\n    void *userdata; /*!<\n        User data - This data are not used by lr_downloader or touched\n        by lr_downloadtarget_free. */\n\n    // New options for zchunk - put at end to maintain API stability\n    gboolean is_zchunk; /*!<\n        Whether record is a zchunk file or not */\n\n    char *range; /*!<\n        Range string to download, overrides byterangestart and end */\n\n    #ifdef WITH_ZCHUNK\n    zckDL *zck_dl; /*!<\n        Zchunk download context */\n\n    gint64 zck_header_size; /*!<\n        Zchunk header size */\n\n    double total_to_download; /*!<\n        Total to download in zchunk file */\n\n    double downloaded; /*!<\n        Amount already downloaded in zchunk file */\n    #endif /* WITH_ZCHUNK */\n\n}\n- LrYumRepo: typedef struct {\n    GSList *paths;      /*!< Paths to repo files. List of ::LrYumRepoPath*s */\n    char *repomd;       /*!< Path to repomd.xml */\n    char *url;          /*!< URL from where repo was downloaded */\n    char *destdir;      /*!< Local path to the repo */\n    char *signature;    /*!< Path to signature if available and\n                             signature was downloaded (GPG check\n                             was enabled during repo downloading) */\n    char *mirrorlist;   /*!< Mirrolist filename */\n    char *metalink;     /*!< Metalink filename */\n    gboolean use_zchunk; /*!< Use zchunk in this repo */\n}\n- LrYumRepoMd: typedef struct {\n    char *revision;         /*!< Revision string*/\n    char *repoid;           /*!< RepoId */\n    char *repoid_type;      /*!< RepoId type (\"sha256\", ...) */\n    GSList *repo_tags;      /*!< List of strings */\n    GSList *content_tags;   /*!< List of strings */\n    GSList *distro_tags;    /*!< List of LrYumDistroTag* */\n    GSList *records;        /*!< List with LrYumRepoMdRecords */\n\n    GStringChunk *chunk;    /*!< String chunk for repomd strings\n                                 (Note: LrYumRepomdRecord strings are stored\n                                 in LrYumRepomdRecord->chunk) */\n}\n- LrHandle: typedef struct _LrHandle LrHandle;\n\nImports:\n- #include <zck.h>\n- #include <fcntl.h>\n- #include \"librepo.h\"\n- #include \"metalink.h\"\n- #include \"yum_internal.h\"\n- #include <libgen.h>\n- #include \"result_internal.h\"\n- #include <assert.h>\n- #include <stdlib.h>\n- #include \"gpg.h\"\n- #include <errno.h>\n- #include <unistd.h>\n- #include \"cleanup.h\"\n- #include <sys/stat.h>\n- #include \"downloader.h\"\n- #include <stdio.h>\n- #include \"handle_internal.h\"\n- #include \"util.h\"\n- #include \"repomd.h\"\n- #include <string.h>",
    "commit_msg": "Validate path read from repomd.xml (RhBug:1868639)\n\n= changelog =\nmsg: Validate path read from repomd.xml\ntype: security\nresolves: https://bugzilla.redhat.com/show_bug.cgi?id=1868639",
    "cve_desc": "A flaw was found in librepo in versions before 1.12.1. A directory traversal vulnerability was found where it failed to sanitize paths in remote repository metadata. An attacker controlling a remote repository may be able to copy files outside of the destination directory on the targeted system via path traversal. This flaw could potentially result in system compromise via the overwriting of critical system files. The highest threat from this flaw is to users that make use of untrusted third-party repositories.",
    "year": 2020,
    "filename": "yum.c",
    "commit_url": "\"https://github.com/rpm-software-management/librepo/commit/7daea2a2429a54dad68b1de9b37a5f65c5cf2600\""
  },
  {
    "repository": "LibVNC/libvncserver",
    "cve_id": "CVE-2020-14396",
    "cwe_list": [
      "CWE-476"
    ],
    "commit_hash": "33441d90a506d5f3ae9388f2752901227e430553",
    "short_hash": "33441d90",
    "vulnerableMethods_before": [
      {
        "filename": "libvncclient/tls_openssl.c",
        "method_name": "open_ssl_connection",
        "raw_code": "static SSL * /* <=== open_ssl_connection */ \nopen_ssl_connection (rfbClient *client, int sockfd, rfbBool anonTLS, rfbCredential *cred)\n{\n  SSL_CTX *ssl_ctx = NULL;\n  SSL *ssl = NULL;\n  int n, finished = 0;\n  X509_VERIFY_PARAM *param;\n  uint8_t verify_crls = cred->x509Credential.x509CrlVerifyMode;\n\n  if (!(ssl_ctx = SSL_CTX_new(SSLv23_client_method())))\n  {\n    rfbClientLog(\"Could not create new SSL context.\\n\");\n    return NULL;\n  }\n\n  param = X509_VERIFY_PARAM_new();\n\n  /* Setup verification if not anonymous */\n  if (!anonTLS)\n  {\n    if (cred->x509Credential.x509CACertFile)\n    {\n      if (!SSL_CTX_load_verify_locations(ssl_ctx, cred->x509Credential.x509CACertFile, NULL))\n      {\n        rfbClientLog(\"Failed to load CA certificate from %s.\\n\",\n                     cred->x509Credential.x509CACertFile);\n        goto error_free_ctx;\n      }\n    } else {\n      rfbClientLog(\"Using default paths for certificate verification.\\n\");\n      SSL_CTX_set_default_verify_paths (ssl_ctx);\n    }\n\n    if (cred->x509Credential.x509CACrlFile)\n    {\n      if (!load_crls_from_file(cred->x509Credential.x509CACrlFile, ssl_ctx))\n      {\n        rfbClientLog(\"CRLs could not be loaded.\\n\");\n        goto error_free_ctx;\n      }\n      if (verify_crls == rfbX509CrlVerifyNone) verify_crls = rfbX509CrlVerifyAll;\n    }\n\n    if (cred->x509Credential.x509ClientCertFile && cred->x509Credential.x509ClientKeyFile)\n    {\n      if (SSL_CTX_use_certificate_chain_file(ssl_ctx, cred->x509Credential.x509ClientCertFile) != 1)\n      {\n        rfbClientLog(\"Client certificate could not be loaded.\\n\");\n        goto error_free_ctx;\n      }\n\n      if (SSL_CTX_use_PrivateKey_file(ssl_ctx, cred->x509Credential.x509ClientKeyFile,\n                                      SSL_FILETYPE_PEM) != 1)\n      {\n        rfbClientLog(\"Client private key could not be loaded.\\n\");\n        goto error_free_ctx;\n      }\n\n      if (SSL_CTX_check_private_key(ssl_ctx) == 0) {\n        rfbClientLog(\"Client certificate and private key do not match.\\n\");\n        goto error_free_ctx;\n      }\n    }\n\n    SSL_CTX_set_verify(ssl_ctx, SSL_VERIFY_PEER, NULL);\n\n    if (verify_crls == rfbX509CrlVerifyClient) \n      X509_VERIFY_PARAM_set_flags(param, X509_V_FLAG_CRL_CHECK);\n    else if (verify_crls == rfbX509CrlVerifyAll)\n      X509_VERIFY_PARAM_set_flags(param, X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);\n\n    if(!X509_VERIFY_PARAM_set1_host(param, client->serverHost, strlen(client->serverHost)))\n    {\n      rfbClientLog(\"Could not set server name for verification.\\n\");\n      goto error_free_ctx;\n    }\n    SSL_CTX_set1_param(ssl_ctx, param);\n  }\n\n  if (!(ssl = SSL_new (ssl_ctx)))\n  {\n    rfbClientLog(\"Could not create a new SSL session.\\n\");\n    goto error_free_ctx;\n  }\n\n  /* TODO: finetune this list, take into account anonTLS bool */\n  SSL_set_cipher_list(ssl, \"ALL\");\n\n  SSL_set_fd (ssl, sockfd);\n  SSL_CTX_set_app_data (ssl_ctx, client);\n\n  do\n  {\n    n = SSL_connect(ssl);\n\t\t\n    if (n != 1) \n    {\n      if (wait_for_data(ssl, n, 1) != 1) \n      {\n        finished = 1;\n        SSL_shutdown(ssl);\n\n        goto error_free_ssl;\n      }\n    }\n  } while( n != 1 && finished != 1 );\n\n  X509_VERIFY_PARAM_free(param);\n  return ssl;\n\nerror_free_ssl:\n  SSL_free(ssl);\n\nerror_free_ctx:\n  X509_VERIFY_PARAM_free(param);\n  SSL_CTX_free(ssl_ctx);\n\n  return NULL;\n}",
        "start_line": 264
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "libvncclient/tls_openssl.c",
        "method_name": "open_ssl_connection",
        "raw_code": "static SSL * /* <=== open_ssl_connection */ \nopen_ssl_connection (rfbClient *client, int sockfd, rfbBool anonTLS, rfbCredential *cred)\n{\n  SSL_CTX *ssl_ctx = NULL;\n  SSL *ssl = NULL;\n  int n, finished = 0;\n  X509_VERIFY_PARAM *param;\n  uint8_t verify_crls;\n\n  if (!(ssl_ctx = SSL_CTX_new(SSLv23_client_method())))\n  {\n    rfbClientLog(\"Could not create new SSL context.\\n\");\n    return NULL;\n  }\n\n  param = X509_VERIFY_PARAM_new();\n\n  /* Setup verification if not anonymous */\n  if (!anonTLS)\n  {\n    verify_crls = cred->x509Credential.x509CrlVerifyMode;\n    if (cred->x509Credential.x509CACertFile)\n    {\n      if (!SSL_CTX_load_verify_locations(ssl_ctx, cred->x509Credential.x509CACertFile, NULL))\n      {\n        rfbClientLog(\"Failed to load CA certificate from %s.\\n\",\n                     cred->x509Credential.x509CACertFile);\n        goto error_free_ctx;\n      }\n    } else {\n      rfbClientLog(\"Using default paths for certificate verification.\\n\");\n      SSL_CTX_set_default_verify_paths (ssl_ctx);\n    }\n\n    if (cred->x509Credential.x509CACrlFile)\n    {\n      if (!load_crls_from_file(cred->x509Credential.x509CACrlFile, ssl_ctx))\n      {\n        rfbClientLog(\"CRLs could not be loaded.\\n\");\n        goto error_free_ctx;\n      }\n      if (verify_crls == rfbX509CrlVerifyNone) verify_crls = rfbX509CrlVerifyAll;\n    }\n\n    if (cred->x509Credential.x509ClientCertFile && cred->x509Credential.x509ClientKeyFile)\n    {\n      if (SSL_CTX_use_certificate_chain_file(ssl_ctx, cred->x509Credential.x509ClientCertFile) != 1)\n      {\n        rfbClientLog(\"Client certificate could not be loaded.\\n\");\n        goto error_free_ctx;\n      }\n\n      if (SSL_CTX_use_PrivateKey_file(ssl_ctx, cred->x509Credential.x509ClientKeyFile,\n                                      SSL_FILETYPE_PEM) != 1)\n      {\n        rfbClientLog(\"Client private key could not be loaded.\\n\");\n        goto error_free_ctx;\n      }\n\n      if (SSL_CTX_check_private_key(ssl_ctx) == 0) {\n        rfbClientLog(\"Client certificate and private key do not match.\\n\");\n        goto error_free_ctx;\n      }\n    }\n\n    SSL_CTX_set_verify(ssl_ctx, SSL_VERIFY_PEER, NULL);\n\n    if (verify_crls == rfbX509CrlVerifyClient) \n      X509_VERIFY_PARAM_set_flags(param, X509_V_FLAG_CRL_CHECK);\n    else if (verify_crls == rfbX509CrlVerifyAll)\n      X509_VERIFY_PARAM_set_flags(param, X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);\n\n    if(!X509_VERIFY_PARAM_set1_host(param, client->serverHost, strlen(client->serverHost)))\n    {\n      rfbClientLog(\"Could not set server name for verification.\\n\");\n      goto error_free_ctx;\n    }\n    SSL_CTX_set1_param(ssl_ctx, param);\n  }\n\n  if (!(ssl = SSL_new (ssl_ctx)))\n  {\n    rfbClientLog(\"Could not create a new SSL session.\\n\");\n    goto error_free_ctx;\n  }\n\n  /* TODO: finetune this list, take into account anonTLS bool */\n  SSL_set_cipher_list(ssl, \"ALL\");\n\n  SSL_set_fd (ssl, sockfd);\n  SSL_CTX_set_app_data (ssl_ctx, client);\n\n  do\n  {\n    n = SSL_connect(ssl);\n\t\t\n    if (n != 1) \n    {\n      if (wait_for_data(ssl, n, 1) != 1) \n      {\n        finished = 1;\n        SSL_shutdown(ssl);\n\n        goto error_free_ssl;\n      }\n    }\n  } while( n != 1 && finished != 1 );\n\n  X509_VERIFY_PARAM_free(param);\n  return ssl;\n\nerror_free_ssl:\n  SSL_free(ssl);\n\nerror_free_ctx:\n  X509_VERIFY_PARAM_free(param);\n  SSL_CTX_free(ssl_ctx);\n\n  return NULL;\n}",
        "start_line": 264
      }
    ],
    "code_context": "Called Methods:\n- wait_for_data: static int wait_for_data(SSL *ssl, int ret, int timeout) /* <=== wait_for_data */ \n{\n  int err;\n  int retval = 1;\n\n  err = SSL_get_error(ssl, ret);\n\t\n  switch(err)\n  {\n    case SSL_ERROR_WANT_READ:\n    case SSL_ERROR_WANT_WRITE:\n      ret = sock_read_ready(ssl, timeout*1000);\n\t\t\t\n      if (ret == -1) {\n        retval = 2;\n      }\n\t\t\t\t\n      break;\n    default:\n      retval = 3;\n      long verify_res = SSL_get_verify_result(ssl);\n      if (verify_res != X509_V_OK)\n        rfbClientLog(\"Could not verify server certificate: %s.\\n\",\n                     X509_verify_cert_error_string(verify_res));\n      break;\n   }\n\t\n  ERR_clear_error();\n\t\t\t\t\n  return retval;\n}\n- sock_read_ready: static int sock_read_ready(SSL *ssl, uint32_t ms) /* <=== sock_read_ready */ \n{\n\tint r = 0;\n\tfd_set fds;\n\tstruct timeval tv;\n\n\tFD_ZERO(&fds);\n\n\tFD_SET(SSL_get_fd(ssl), &fds);\n\n\ttv.tv_sec = ms / 1000;\n\ttv.tv_usec = (ms % 1000) * 1000;\n\t\n\tr = select (SSL_get_fd(ssl) + 1, &fds, NULL, NULL, &tv); \n\n\treturn r;\n}\n\nType Definitions:\n- rfbCredential: typedef union _rfbCredential\n{\n  /** X509 (VeNCrypt) */\n  struct\n  {\n    char *x509CACertFile;\n    char *x509CACrlFile;\n    char *x509ClientCertFile;\n    char *x509ClientKeyFile;\n    uint8_t x509CrlVerifyMode; /* Only required for OpenSSL - see meanings below */\n  } x509Credential;\n  /** Plain (VeNCrypt), MSLogon (UltraVNC) */\n  struct\n  {\n    char *username;\n    char *password;\n  } userCredential;\n} rfbCredential;\n- rfbBool: typedef int8_t rfbBool;\n- rfbClient: typedef struct _rfbClient {\n\tuint8_t* frameBuffer;\n\tint width, height;\n\n\tint endianTest;\n\n\tAppData appData;\n\n\tconst char* programName;\n\tchar* serverHost;\n\tint serverPort; /**< if -1, then use file recorded by vncrec */\n\trfbBool listenSpecified;\n\tint listenPort, flashPort;\n\n\tstruct {\n\t\tint x, y, w, h;\n\t} updateRect;\n\n\t/** Note that the CoRRE encoding uses this buffer and assumes it is big enough\n\t   to hold 255 * 255 * 32 bits -> 260100 bytes.  640*480 = 307200 bytes.\n\t   Hextile also assumes it is big enough to hold 16 * 16 * 32 bits.\n\t   Tight encoding assumes BUFFER_SIZE is at least 16384 bytes. */\n\n#define RFB_BUFFER_SIZE (640*480)\n\tchar buffer[RFB_BUFFER_SIZE];\n\n\t/* rfbproto.c */\n\n\trfbSocket sock;\n\trfbBool canUseCoRRE;\n\trfbBool canUseHextile;\n\tchar *desktopName;\n\trfbPixelFormat format;\n\trfbServerInitMsg si;\n\n\t/* sockets.c */\n#define RFB_BUF_SIZE 8192\n\tchar buf[RFB_BUF_SIZE];\n\tchar *bufoutptr;\n\tunsigned int buffered;\n\n\t/* The zlib encoding requires expansion/decompression/deflation of the\n\t   compressed data in the \"buffer\" above into another, result buffer.\n\t   However, the size of the result buffer can be determined precisely\n\t   based on the bitsPerPixel, height and width of the rectangle.  We\n\t   allocate this buffer one time to be the full size of the buffer. */\n\n\t/* Ultra Encoding uses this buffer too */\n\t\n\tint ultra_buffer_size;\n\tchar *ultra_buffer;\n\n\tint raw_buffer_size;\n\tchar *raw_buffer;\n\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n\tz_stream decompStream;\n\trfbBool decompStreamInited;\n#endif\n\n\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n\t/*\n\t * Variables for the ``tight'' encoding implementation.\n\t */\n\n\t/** Separate buffer for compressed data. */\n#define ZLIB_BUFFER_SIZE 30000\n\tchar zlib_buffer[ZLIB_BUFFER_SIZE];\n\n\t/* Four independent compression streams for zlib library. */\n\tz_stream zlibStream[4];\n\trfbBool zlibStreamActive[4];\n\n\t/* Filter stuff. Should be initialized by filter initialization code. */\n\trfbBool cutZeros;\n\tint rectWidth, rectColors;\n\tchar tightPalette[256*4];\n\tuint8_t tightPrevRow[2048*3*sizeof(uint16_t)];\n\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n\t/** JPEG decoder state (obsolete-- do not use). */\n\trfbBool jpegError;\n\n\tstruct jpeg_source_mgr* jpegSrcManager;\n\tvoid* jpegBufferPtr;\n\tsize_t jpegBufferLen;\n\n#endif\n#endif\n\n\n\t/* cursor.c */\n\t/** Holds cursor shape data when received from server. */\n\tuint8_t *rcSource, *rcMask;\n\n\t/** private data pointer */\n\trfbClientData* clientData;\n\n\trfbVNCRec* vncRec;\n\n\t/* Keyboard State support (is 'Caps Lock' set on the remote display???) */\n\tint KeyboardLedStateEnabled;\n\tint CurrentKeyboardLedState;\n\n\tint canHandleNewFBSize;\n\n\t/* hooks */\n\tHandleTextChatProc         HandleTextChat;\n\tHandleKeyboardLedStateProc HandleKeyboardLedState;\n\tHandleCursorPosProc HandleCursorPos;\n\tSoftCursorLockAreaProc SoftCursorLockArea;\n\tSoftCursorUnlockScreenProc SoftCursorUnlockScreen;\n\tGotFrameBufferUpdateProc GotFrameBufferUpdate;\n\t/** the pointer returned by GetPassword will be freed after use! */\n\tGetPasswordProc GetPassword;\n\tMallocFrameBufferProc MallocFrameBuffer;\n\tGotXCutTextProc GotXCutText;\n\tBellProc Bell;\n\n\tGotCursorShapeProc GotCursorShape;\n\tGotCopyRectProc GotCopyRect;\n\n\t/** Which messages are supported by the server\n\t * This is a *guess* for most servers.\n\t * (If we can even detect the type of server)\n\t *\n\t * If the server supports the \"rfbEncodingSupportedMessages\"\n\t * then this will be updated when the encoding is received to\n\t * accurately reflect the servers capabilities.\n\t */\n\trfbSupportedMessages supportedMessages;\n\n\t/** negotiated protocol version */\n\tint major, minor;\n\n\t/** The selected security types */\n\tuint32_t authScheme, subAuthScheme;\n\n\t/** The TLS session for Anonymous TLS and VeNCrypt */\n\tvoid* tlsSession;\n\n\t/** To support security types that requires user input (except VNC password\n\t * authentication), for example VeNCrypt and MSLogon, this callback function\n\t * must be set before the authentication. Otherwise, it implicates that the\n\t * caller application does not support it and related security types should\n\t * be bypassed.\n\t */\n\tGetCredentialProc GetCredential;\n\n\t/** The 0-terminated security types supported by the client.\n\t * Set by function SetClientAuthSchemes() */\n\tuint32_t *clientAuthSchemes;\n\n\t/** When the server is a repeater, this specifies the final destination */\n\tchar *destHost;\n\tint destPort;\n\n        /** the QoS IP DSCP for this client */\n        int QoS_DSCP;\n\n        /** hook to handle xvp server messages */\n\tHandleXvpMsgProc           HandleXvpMsg;\n\n\t/* listen.c */\n        rfbSocket listenSock;\n\n\tFinishedFrameBufferUpdateProc FinishedFrameBufferUpdate;\n\n\tchar *listenAddress;\n        /* IPv6 listen socket, address and port*/\n        rfbSocket listen6Sock;\n        char* listen6Address;\n        int listen6Port;\n\n        /* Output Window ID. When set, client application enables libvncclient to perform direct rendering in its window */\n        unsigned long outputWindow;\n\n\t/** Hooks for optional protection WriteToTLS() by mutex */\n\tLockWriteToTLSProc LockWriteToTLS;\n\tUnlockWriteToTLSProc UnlockWriteToTLS;\n\n        /** Hooks for custom rendering\n         *\n         * VNC rendering boils down to 3 activities:\n         * - GotCopyRect: copy an area of the framebuffer\n         * - GotFillRect: fill an area of the framebuffer with a solid color\n         * - GotBitmap: copy the bitmap in the buffer into the framebuffer\n         * The client application should either set all three of these or none!\n         */\n        GotFillRectProc GotFillRect;\n        GotBitmapProc GotBitmap;\n        /** Hook for custom JPEG decoding and rendering */\n        GotJpegProc GotJpeg;\n\n#ifdef LIBVNCSERVER_HAVE_SASL\n        sasl_conn_t *saslconn;\n        const char *saslDecoded;\n        unsigned int saslDecodedLength;\n        unsigned int saslDecodedOffset;\n        sasl_secret_t *saslSecret;\n\n        /* Callback to allow the client to choose a preferred mechanism. The string returned will\n           be freed once no longer required. */\n        GetSASLMechanismProc GetSASLMechanism;\n        GetUserProc GetUser;\n\n#endif /* LIBVNCSERVER_HAVE_SASL */\n\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n\t/** JPEG decoder state. */\n\tvoid *tjhnd;\n\n#endif\n#endif\n} rfbClient;\n\nImports:\n- #include <openssl/rand.h>\n- #include <openssl/x509.h>\n- #include <rfb/rfbclient.h>\n- #include <openssl/ssl.h>\n- #include <pthread.h>\n- #include \"tls.h\"\n- #include <BaseTsd.h>\n- #include <errno.h>\n- #include <openssl/err.h>",
    "commit_msg": "libvncclient/tls_openssl: do not deref a NULL pointer\n\nHappens in anonTLS mode where cred is NULL.\n\nre #347",
    "cve_desc": "[{'lang': 'en', 'value': 'An issue was discovered in LibVNCServer before 0.9.13. libvncclient/tls_openssl.c has a NULL pointer dereference.'}]",
    "year": 2020,
    "filename": "tls_openssl.c",
    "commit_url": "\"https://github.com/LibVNC/libvncserver/commit/33441d90a506d5f3ae9388f2752901227e430553\""
  },
  {
    "repository": "LibVNC/libvncserver",
    "cve_id": "CVE-2020-14401",
    "cwe_list": [
      "CWE-190"
    ],
    "commit_hash": "a6788d1da719ae006605b78d22f5a9f170b423af",
    "short_hash": "a6788d1d",
    "vulnerableMethods_before": [
      {
        "filename": "libvncserver/scale.c",
        "method_name": "rfbScaledScreenUpdateRect",
        "raw_code": "void rfbScaledScreenUpdateRect(rfbScreenInfoPtr screen, rfbScreenInfoPtr ptr, int x0, int y0, int w0, int h0) /* <=== rfbScaledScreenUpdateRect */ \n{\n    int x,y,w,v,z;\n    int x1, y1, w1, h1;\n    int bitsPerPixel, bytesPerPixel, bytesPerLine, areaX, areaY, area2;\n    unsigned char *srcptr, *dstptr;\n\n    /* Nothing to do!!! */\n    if (screen==ptr) return;\n\n    x1 = x0;\n    y1 = y0;\n    w1 = w0;\n    h1 = h0;\n\n    rfbScaledCorrection(screen, ptr, &x1, &y1, &w1, &h1, \"rfbScaledScreenUpdateRect\");\n    x0 = ScaleX(ptr, screen, x1);\n    y0 = ScaleY(ptr, screen, y1);\n    w0 = ScaleX(ptr, screen, w1);\n    h0 = ScaleY(ptr, screen, h1);\n\n    bitsPerPixel = screen->bitsPerPixel;\n    bytesPerPixel = bitsPerPixel / 8;\n    bytesPerLine = w1 * bytesPerPixel;\n    srcptr = (unsigned char *)(screen->frameBuffer +\n     (y0 * screen->paddedWidthInBytes + x0 * bytesPerPixel));\n    dstptr = (unsigned char *)(ptr->frameBuffer +\n     ( y1 * ptr->paddedWidthInBytes + x1 * bytesPerPixel));\n    /* The area of the source framebuffer for each destination pixel */\n    areaX = ScaleX(ptr,screen,1);\n    areaY = ScaleY(ptr,screen,1);\n    area2 = areaX*areaY;\n\n\n    /* Ensure that we do not go out of bounds */\n    if ((x1+w1) > (ptr->width))\n    {\n      if (x1==0) w1=ptr->width; else x1 = ptr->width - w1;\n    }\n    if ((y1+h1) > (ptr->height))\n    {\n      if (y1==0) h1=ptr->height; else y1 = ptr->height - h1;\n    }\n    /*\n     * rfbLog(\"rfbScaledScreenUpdateRect(%dXx%dY-%dWx%dH  ->  %dXx%dY-%dWx%dH <%dx%d>) {%dWx%dH -> %dWx%dH} 0x%p\\n\",\n     *    x0, y0, w0, h0, x1, y1, w1, h1, areaX, areaY,\n     *    screen->width, screen->height, ptr->width, ptr->height, ptr->frameBuffer);\n     */\n\n    if (screen->serverFormat.trueColour) { /* Blend neighbouring pixels together */\n      unsigned char *srcptr2;\n      unsigned long pixel_value, red, green, blue;\n      unsigned int redShift = screen->serverFormat.redShift;\n      unsigned int greenShift = screen->serverFormat.greenShift;\n      unsigned int blueShift = screen->serverFormat.blueShift;\n      unsigned long redMax = screen->serverFormat.redMax;\n      unsigned long greenMax = screen->serverFormat.greenMax;\n      unsigned long blueMax = screen->serverFormat.blueMax;\n\n     /* for each *destination* pixel... */\n     for (y = 0; y < h1; y++) {\n       for (x = 0; x < w1; x++) {\n         red = green = blue = 0;\n         /* Get the totals for rgb from the source grid... */\n         for (w = 0; w < areaX; w++) {\n           for (v = 0; v < areaY; v++) {\n             srcptr2 = &srcptr[(((x * areaX) + w) * bytesPerPixel) +\n                               (v * screen->paddedWidthInBytes)];\n             pixel_value = 0;\n\n\n             switch (bytesPerPixel) {\n             case 4: pixel_value = *((unsigned int *)srcptr2);   break;\n             case 2: pixel_value = *((unsigned short *)srcptr2); break;\n             case 1: pixel_value = *((unsigned char *)srcptr2);  break;\n             default:\n               /* fixme: endianness problem? */\n               for (z = 0; z < bytesPerPixel; z++)\n                 pixel_value += (srcptr2[z] << (8 * z));\n                break;\n              }\n              /*\n              srcptr2 += bytesPerPixel;\n              */\n\n            red += ((pixel_value >> redShift) & redMax);\n            green += ((pixel_value >> greenShift) & greenMax);\n            blue += ((pixel_value >> blueShift) & blueMax);\n\n           }\n         }\n         /* We now have a total for all of the colors, find the average! */\n         red /= area2;\n         green /= area2;\n         blue /= area2;\n          /* Stuff the new value back into memory */\n         pixel_value = ((red & redMax) << redShift) | ((green & greenMax) << greenShift) | ((blue & blueMax) << blueShift);\n\n         switch (bytesPerPixel) {\n         case 4: *((unsigned int *)dstptr)   = (unsigned int)   pixel_value; break;\n         case 2: *((unsigned short *)dstptr) = (unsigned short) pixel_value; break;\n         case 1: *((unsigned char *)dstptr)  = (unsigned char)  pixel_value; break;\n         default:\n           /* fixme: endianness problem? */\n           for (z = 0; z < bytesPerPixel; z++)\n             dstptr[z]=(pixel_value >> (8 * z)) & 0xff;\n            break;\n          }\n          dstptr += bytesPerPixel;\n       }\n       srcptr += (screen->paddedWidthInBytes * areaY);\n       dstptr += (ptr->paddedWidthInBytes - bytesPerLine);\n     }\n   } else\n   { /* Not truecolour, so we can't blend. Just use the top-left pixel instead */\n     for (y = y1; y < (y1+h1); y++) {\n       for (x = x1; x < (x1+w1); x++)\n         memcpy (&ptr->frameBuffer[(y *ptr->paddedWidthInBytes) + (x * bytesPerPixel)],\n                 &screen->frameBuffer[(y * areaY * screen->paddedWidthInBytes) + (x *areaX * bytesPerPixel)], bytesPerPixel);\n     }\n  }\n}",
        "start_line": 135
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "libvncserver/scale.c",
        "method_name": "rfbScaledScreenUpdateRect",
        "raw_code": "void rfbScaledScreenUpdateRect(rfbScreenInfoPtr screen, rfbScreenInfoPtr ptr, int x0, int y0, int w0, int h0) /* <=== rfbScaledScreenUpdateRect */ \n{\n    int x,y,w,v,z;\n    int x1, y1, w1, h1;\n    int bitsPerPixel, bytesPerPixel, bytesPerLine, areaX, areaY, area2;\n    unsigned char *srcptr, *dstptr;\n\n    /* Nothing to do!!! */\n    if (screen==ptr) return;\n\n    x1 = x0;\n    y1 = y0;\n    w1 = w0;\n    h1 = h0;\n\n    rfbScaledCorrection(screen, ptr, &x1, &y1, &w1, &h1, \"rfbScaledScreenUpdateRect\");\n    x0 = ScaleX(ptr, screen, x1);\n    y0 = ScaleY(ptr, screen, y1);\n    w0 = ScaleX(ptr, screen, w1);\n    h0 = ScaleY(ptr, screen, h1);\n\n    bitsPerPixel = screen->bitsPerPixel;\n    bytesPerPixel = bitsPerPixel / 8;\n    bytesPerLine = w1 * bytesPerPixel;\n    srcptr = (unsigned char *)(screen->frameBuffer +\n     (y0 * screen->paddedWidthInBytes + x0 * bytesPerPixel));\n    dstptr = (unsigned char *)(ptr->frameBuffer +\n     ( y1 * ptr->paddedWidthInBytes + x1 * bytesPerPixel));\n    /* The area of the source framebuffer for each destination pixel */\n    areaX = ScaleX(ptr,screen,1);\n    areaY = ScaleY(ptr,screen,1);\n    area2 = areaX*areaY;\n\n\n    /* Ensure that we do not go out of bounds */\n    if ((x1+w1) > (ptr->width))\n    {\n      if (x1==0) w1=ptr->width; else x1 = ptr->width - w1;\n    }\n    if ((y1+h1) > (ptr->height))\n    {\n      if (y1==0) h1=ptr->height; else y1 = ptr->height - h1;\n    }\n    /*\n     * rfbLog(\"rfbScaledScreenUpdateRect(%dXx%dY-%dWx%dH  ->  %dXx%dY-%dWx%dH <%dx%d>) {%dWx%dH -> %dWx%dH} 0x%p\\n\",\n     *    x0, y0, w0, h0, x1, y1, w1, h1, areaX, areaY,\n     *    screen->width, screen->height, ptr->width, ptr->height, ptr->frameBuffer);\n     */\n\n    if (screen->serverFormat.trueColour) { /* Blend neighbouring pixels together */\n      unsigned char *srcptr2;\n      unsigned long pixel_value, red, green, blue;\n      unsigned int redShift = screen->serverFormat.redShift;\n      unsigned int greenShift = screen->serverFormat.greenShift;\n      unsigned int blueShift = screen->serverFormat.blueShift;\n      unsigned long redMax = screen->serverFormat.redMax;\n      unsigned long greenMax = screen->serverFormat.greenMax;\n      unsigned long blueMax = screen->serverFormat.blueMax;\n\n     /* for each *destination* pixel... */\n     for (y = 0; y < h1; y++) {\n       for (x = 0; x < w1; x++) {\n         red = green = blue = 0;\n         /* Get the totals for rgb from the source grid... */\n         for (w = 0; w < areaX; w++) {\n           for (v = 0; v < areaY; v++) {\n             srcptr2 = &srcptr[(((x * areaX) + w) * bytesPerPixel) +\n                               (v * screen->paddedWidthInBytes)];\n             pixel_value = 0;\n\n\n             switch (bytesPerPixel) {\n             case 4: pixel_value = *((unsigned int *)srcptr2);   break;\n             case 2: pixel_value = *((unsigned short *)srcptr2); break;\n             case 1: pixel_value = *((unsigned char *)srcptr2);  break;\n             default:\n               /* fixme: endianness problem? */\n               for (z = 0; z < bytesPerPixel; z++)\n                 pixel_value += ((unsigned long)srcptr2[z] << (8 * z));\n                break;\n              }\n              /*\n              srcptr2 += bytesPerPixel;\n              */\n\n            red += ((pixel_value >> redShift) & redMax);\n            green += ((pixel_value >> greenShift) & greenMax);\n            blue += ((pixel_value >> blueShift) & blueMax);\n\n           }\n         }\n         /* We now have a total for all of the colors, find the average! */\n         red /= area2;\n         green /= area2;\n         blue /= area2;\n          /* Stuff the new value back into memory */\n         pixel_value = ((red & redMax) << redShift) | ((green & greenMax) << greenShift) | ((blue & blueMax) << blueShift);\n\n         switch (bytesPerPixel) {\n         case 4: *((unsigned int *)dstptr)   = (unsigned int)   pixel_value; break;\n         case 2: *((unsigned short *)dstptr) = (unsigned short) pixel_value; break;\n         case 1: *((unsigned char *)dstptr)  = (unsigned char)  pixel_value; break;\n         default:\n           /* fixme: endianness problem? */\n           for (z = 0; z < bytesPerPixel; z++)\n             dstptr[z]=(pixel_value >> (8 * z)) & 0xff;\n            break;\n          }\n          dstptr += bytesPerPixel;\n       }\n       srcptr += (screen->paddedWidthInBytes * areaY);\n       dstptr += (ptr->paddedWidthInBytes - bytesPerLine);\n     }\n   } else\n   { /* Not truecolour, so we can't blend. Just use the top-left pixel instead */\n     for (y = y1; y < (y1+h1); y++) {\n       for (x = x1; x < (x1+w1); x++)\n         memcpy (&ptr->frameBuffer[(y *ptr->paddedWidthInBytes) + (x * bytesPerPixel)],\n                 &screen->frameBuffer[(y * areaY * screen->paddedWidthInBytes) + (x *areaX * bytesPerPixel)], bytesPerPixel);\n     }\n  }\n}",
        "start_line": 135
      }
    ],
    "code_context": "Called Methods:\n- ScaleY: int ScaleY(rfbScreenInfoPtr from, rfbScreenInfoPtr to, int y) /* <=== ScaleY */ \n{\n    if ((from==to) || (from==NULL) || (to==NULL)) return y;\n    return ((int)(((double) y / (double)from->height) * (double)to->height ));\n}\n- ScaleX: int ScaleX(rfbScreenInfoPtr from, rfbScreenInfoPtr to, int x) /* <=== ScaleX */ \n{\n    if ((from==to) || (from==NULL) || (to==NULL)) return x;\n    return ((int)(((double) x / (double)from->width) * (double)to->width ));\n}\n\nType Definitions:\n- rfbScreenInfoPtr: typedef struct _rfbScreenInfo\n{\n    /** this structure has children that are scaled versions of this screen */\n    struct _rfbScreenInfo *scaledScreenNext;\n    int scaledScreenRefCount;\n\n    int width;\n    int paddedWidthInBytes;\n    int height;\n    int depth;\n    int bitsPerPixel;\n    int sizeInBytes;\n\n    rfbPixel blackPixel;\n    rfbPixel whitePixel;\n\n    /**\n     * some screen specific data can be put into a struct where screenData\n     * points to. You need this if you have more than one screen at the\n     * same time while using the same functions.\n     */\n    void* screenData;\n\n    /* additions by libvncserver */\n\n    rfbPixelFormat serverFormat;\n    rfbColourMap colourMap; /**< set this if rfbServerFormat.trueColour==FALSE */\n    const char* desktopName;\n    char thisHost[255];\n\n    rfbBool autoPort;\n    int port;\n    rfbSocket listenSock;\n    int maxSock;\n    int maxFd;\n#ifdef WIN32\n    struct fd_set allFds;\n#else\n    fd_set allFds;\n#endif\n\n    enum rfbSocketState socketState;\n    rfbSocket inetdSock;\n    rfbBool inetdInitDone;\n\n    int udpPort;\n    rfbSocket udpSock;\n    struct _rfbClientRec* udpClient;\n    rfbBool udpSockConnected;\n    struct sockaddr_in udpRemoteAddr;\n\n    int maxClientWait;\n\n    /* http stuff */\n    rfbBool httpInitDone;\n    rfbBool httpEnableProxyConnect;\n    int httpPort;\n    char* httpDir;\n    rfbSocket httpListenSock;\n    rfbSocket httpSock;\n\n    rfbPasswordCheckProcPtr passwordCheck;\n    void* authPasswdData;\n    /** If rfbAuthPasswdData is given a list, this is the first\n        view only password. */\n    int authPasswdFirstViewOnly;\n\n    /** send only this many rectangles in one update */\n    int maxRectsPerUpdate;\n    /** this is the amount of milliseconds to wait at least before sending\n     * an update. */\n    int deferUpdateTime;\n#ifdef TODELETE\n    char* screen;\n#endif\n    rfbBool alwaysShared;\n    rfbBool neverShared;\n    rfbBool dontDisconnect;\n    struct _rfbClientRec* clientHead;\n    struct _rfbClientRec* pointerClient;  /**< \"Mutex\" for pointer events */\n\n\n    /* cursor */\n    int cursorX, cursorY,underCursorBufferLen;\n    char* underCursorBuffer;\n    rfbBool dontConvertRichCursorToXCursor;\n    struct rfbCursor* cursor;\n\n    /**\n     * the frameBuffer has to be supplied by the serving process.\n     * The buffer will not be freed by\n     */\n    char* frameBuffer;\n    rfbKbdAddEventProcPtr kbdAddEvent;\n    rfbKbdReleaseAllKeysProcPtr kbdReleaseAllKeys;\n    rfbPtrAddEventProcPtr ptrAddEvent;\n    rfbSetXCutTextProcPtr setXCutText;\n    rfbGetCursorProcPtr getCursorPtr;\n    rfbSetTranslateFunctionProcPtr setTranslateFunction;\n    rfbSetSingleWindowProcPtr setSingleWindow;\n    rfbSetServerInputProcPtr  setServerInput;\n    rfbFileTransferPermitted  getFileTransferPermission;\n    rfbSetTextChat            setTextChat;\n\n    /** newClientHook is called just after a new client is created */\n    rfbNewClientHookPtr newClientHook;\n    /** displayHook is called just before a frame buffer update */\n    rfbDisplayHookPtr displayHook;\n\n    /** These hooks are called to pass keyboard state back to the client */\n    rfbGetKeyboardLedStateHookPtr getKeyboardLedStateHook;\n\n#if defined(LIBVNCSERVER_HAVE_LIBPTHREAD) || defined(LIBVNCSERVER_HAVE_WIN32THREADS)\n    MUTEX(cursorMutex);\n    rfbBool backgroundLoop;\n#endif\n\n    /** if TRUE, an ignoring signal handler is installed for SIGPIPE */\n    rfbBool ignoreSIGPIPE;\n\n    /** if not zero, only a slice of this height is processed every time\n     * an update should be sent. This should make working on a slow\n     * link more interactive. */\n    int progressiveSliceHeight;\n\n    in_addr_t listenInterface;\n    int deferPtrUpdateTime;\n\n    /** handle as many input events as possible (default off) */\n    rfbBool handleEventsEagerly;\n\n    /** rfbEncodingServerIdentity */\n    char *versionString;\n\n    /** What does the server tell the new clients which version it supports */\n    int protocolMajorVersion;\n    int protocolMinorVersion;\n\n    /** command line authorization of file transfers */\n    rfbBool permitFileTransfer;\n\n    /** displayFinishedHook is called just after a frame buffer update */\n    rfbDisplayFinishedHookPtr displayFinishedHook;\n    /** xvpHook is called to handle an xvp client message */\n    rfbXvpHookPtr xvpHook;\n    char *sslkeyfile;\n    char *sslcertfile;\n    int ipv6port; /**< The port to listen on when using IPv6.  */\n    char* listen6Interface;\n    /* We have an additional IPv6 listen socket since there are systems that\n       don't support dual binding sockets under *any* circumstances, for\n       instance OpenBSD */\n    rfbSocket listen6Sock;\n    int http6Port;\n    rfbSocket httpListen6Sock;\n    /** hook to let client set resolution */\n    rfbSetDesktopSizeHookPtr setDesktopSizeHook;\n    /** Optional hooks to query ExtendedDesktopSize screen information.\n     * If not set it is assumed only one screen is present spanning entire fb */\n    rfbNumberOfExtDesktopScreensPtr numberOfExtDesktopScreensHook;\n    rfbGetExtDesktopScreenPtr getExtDesktopScreenHook;\n    /** This value between 0 and 1.0 defines which fraction of the maximum number\n\tof file descriptors LibVNCServer uses before denying new client connections.\n\tIt is set to 0.5 per default. */\n    float fdQuota;\n\n} rfbScreenInfo, *rfbScreenInfoPtr;\n\nImports:\n- #include <string.h>\n- #include <rfb/rfb.h>\n- #include <fcntl.h>\n- #include <rfb/rfbregion.h>\n- #include \"private.h\"",
    "commit_msg": "libvncserver: scale: cast to 64 bit before shifting\n\nSince pixel_value is 64 bit the data type of the shift operand should\nbe 64 bit too to prevent integer overflows.",
    "cve_desc": "[{'lang': 'en', 'value': 'An issue was discovered in LibVNCServer before 0.9.13. libvncserver/scale.c has a pixel_value integer overflow.'}]",
    "year": 2020,
    "filename": "scale.c",
    "commit_url": "\"https://github.com/LibVNC/libvncserver/commit/a6788d1da719ae006605b78d22f5a9f170b423af\""
  },
  {
    "repository": "LibVNC/libvncserver",
    "cve_id": "CVE-2020-14405",
    "cwe_list": [
      "CWE-703"
    ],
    "commit_hash": "8937203441ee241c4ace85da687b7d6633a12365",
    "short_hash": "89372034",
    "vulnerableMethods_before": [
      {
        "filename": "libvncclient/rfbproto.c",
        "method_name": "HandleRFBServerMessage",
        "raw_code": "rfbBool /* <=== HandleRFBServerMessage */ \nHandleRFBServerMessage(rfbClient* client)\n{\n  rfbServerToClientMsg msg;\n\n  if (client->serverPort==-1)\n    client->vncRec->readTimestamp = TRUE;\n  if (!ReadFromRFBServer(client, (char *)&msg, 1))\n    return FALSE;\n\n  switch (msg.type) {\n\n  case rfbSetColourMapEntries:\n  {\n    /* TODO:\n    int i;\n    uint16_t rgb[3];\n    XColor xc;\n\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n\t\t\t   sz_rfbSetColourMapEntriesMsg - 1))\n      return FALSE;\n\n    msg.scme.firstColour = rfbClientSwap16IfLE(msg.scme.firstColour);\n    msg.scme.nColours = rfbClientSwap16IfLE(msg.scme.nColours);\n\n    for (i = 0; i < msg.scme.nColours; i++) {\n      if (!ReadFromRFBServer(client, (char *)rgb, 6))\n\treturn FALSE;\n      xc.pixel = msg.scme.firstColour + i;\n      xc.red = rfbClientSwap16IfLE(rgb[0]);\n      xc.green = rfbClientSwap16IfLE(rgb[1]);\n      xc.blue = rfbClientSwap16IfLE(rgb[2]);\n      xc.flags = DoRed|DoGreen|DoBlue;\n      XStoreColor(dpy, cmap, &xc);\n    }\n    */\n\n    break;\n  }\n\n  case rfbFramebufferUpdate:\n  {\n    rfbFramebufferUpdateRectHeader rect;\n    int linesToRead;\n    int bytesPerLine;\n    int i;\n\n    if (!ReadFromRFBServer(client, ((char *)&msg.fu) + 1,\n\t\t\t   sz_rfbFramebufferUpdateMsg - 1))\n      return FALSE;\n\n    msg.fu.nRects = rfbClientSwap16IfLE(msg.fu.nRects);\n\n    for (i = 0; i < msg.fu.nRects; i++) {\n      if (!ReadFromRFBServer(client, (char *)&rect, sz_rfbFramebufferUpdateRectHeader))\n\treturn FALSE;\n\n      rect.encoding = rfbClientSwap32IfLE(rect.encoding);\n      if (rect.encoding == rfbEncodingLastRect)\n\tbreak;\n\n      rect.r.x = rfbClientSwap16IfLE(rect.r.x);\n      rect.r.y = rfbClientSwap16IfLE(rect.r.y);\n      rect.r.w = rfbClientSwap16IfLE(rect.r.w);\n      rect.r.h = rfbClientSwap16IfLE(rect.r.h);\n\n\n      if (rect.encoding == rfbEncodingXCursor ||\n\t  rect.encoding == rfbEncodingRichCursor) {\n\n\tif (!HandleCursorShape(client,\n\t\t\t       rect.r.x, rect.r.y, rect.r.w, rect.r.h,\n\t\t\t       rect.encoding)) {\n\t  return FALSE;\n\t}\n\tcontinue;\n      }\n\n      if (rect.encoding == rfbEncodingPointerPos) {\n\tif (!client->HandleCursorPos(client,rect.r.x, rect.r.y)) {\n\t  return FALSE;\n\t}\n\tcontinue;\n      }\n      \n      if (rect.encoding == rfbEncodingKeyboardLedState) {\n          /* OK! We have received a keyboard state message!!! */\n          client->KeyboardLedStateEnabled = 1;\n          if (client->HandleKeyboardLedState!=NULL)\n              client->HandleKeyboardLedState(client, rect.r.x, 0);\n          /* stash it for the future */\n          client->CurrentKeyboardLedState = rect.r.x;\n          continue;\n      }\n\n      if (rect.encoding == rfbEncodingNewFBSize) {\n\tclient->width = rect.r.w;\n\tclient->height = rect.r.h;\n\tclient->updateRect.x = client->updateRect.y = 0;\n\tclient->updateRect.w = client->width;\n\tclient->updateRect.h = client->height;\n\tif (!client->MallocFrameBuffer(client))\n\t  return FALSE;\n\tSendFramebufferUpdateRequest(client, 0, 0, rect.r.w, rect.r.h, FALSE);\n\trfbClientLog(\"Got new framebuffer size: %dx%d\\n\", rect.r.w, rect.r.h);\n\tcontinue;\n      }\n\n      /* rect.r.w=byte count */\n      if (rect.encoding == rfbEncodingSupportedMessages) {\n          int loop;\n          if (!ReadFromRFBServer(client, (char *)&client->supportedMessages, sz_rfbSupportedMessages))\n              return FALSE;\n\n          /* msgs is two sets of bit flags of supported messages client2server[] and server2client[] */\n          /* currently ignored by this library */\n\n          rfbClientLog(\"client2server supported messages (bit flags)\\n\");\n          for (loop=0;loop<32;loop+=8)\n            rfbClientLog(\"%02X: %04x %04x %04x %04x - %04x %04x %04x %04x\\n\", loop,\n                client->supportedMessages.client2server[loop],   client->supportedMessages.client2server[loop+1],\n                client->supportedMessages.client2server[loop+2], client->supportedMessages.client2server[loop+3],\n                client->supportedMessages.client2server[loop+4], client->supportedMessages.client2server[loop+5],\n                client->supportedMessages.client2server[loop+6], client->supportedMessages.client2server[loop+7]);\n\n          rfbClientLog(\"server2client supported messages (bit flags)\\n\");\n          for (loop=0;loop<32;loop+=8)\n            rfbClientLog(\"%02X: %04x %04x %04x %04x - %04x %04x %04x %04x\\n\", loop,\n                client->supportedMessages.server2client[loop],   client->supportedMessages.server2client[loop+1],\n                client->supportedMessages.server2client[loop+2], client->supportedMessages.server2client[loop+3],\n                client->supportedMessages.server2client[loop+4], client->supportedMessages.server2client[loop+5],\n                client->supportedMessages.server2client[loop+6], client->supportedMessages.server2client[loop+7]);\n          continue;\n      }\n\n      /* rect.r.w=byte count, rect.r.h=# of encodings */\n      if (rect.encoding == rfbEncodingSupportedEncodings) {\n          char *buffer;\n          buffer = malloc(rect.r.w);\n          if (!ReadFromRFBServer(client, buffer, rect.r.w))\n          {\n              free(buffer);\n              return FALSE;\n          }\n\n          /* buffer now contains rect.r.h # of uint32_t encodings that the server supports */\n          /* currently ignored by this library */\n          free(buffer);\n          continue;\n      }\n\n      /* rect.r.w=byte count */\n      if (rect.encoding == rfbEncodingServerIdentity) {\n          char *buffer;\n          buffer = malloc(rect.r.w+1);\n          if (!ReadFromRFBServer(client, buffer, rect.r.w))\n          {\n              free(buffer);\n              return FALSE;\n          }\n          buffer[rect.r.w]=0; /* null terminate, just in case */\n          rfbClientLog(\"Connected to Server \\\"%s\\\"\\n\", buffer);\n          free(buffer);\n          continue;\n      }\n\n      /* rfbEncodingUltraZip is a collection of subrects.   x = # of subrects, and h is always 0 */\n      if (rect.encoding != rfbEncodingUltraZip)\n      {\n        if ((rect.r.x + rect.r.w > client->width) ||\n\t    (rect.r.y + rect.r.h > client->height))\n\t    {\n\t      rfbClientLog(\"Rect too large: %dx%d at (%d, %d)\\n\",\n\t  \t  rect.r.w, rect.r.h, rect.r.x, rect.r.y);\n\t      return FALSE;\n            }\n\n        /* UltraVNC with scaling, will send rectangles with a zero W or H\n         *\n        if ((rect.encoding != rfbEncodingTight) && \n            (rect.r.h * rect.r.w == 0))\n        {\n\t  rfbClientLog(\"Zero size rect - ignoring (encoding=%d (0x%08x) %dx, %dy, %dw, %dh)\\n\", rect.encoding, rect.encoding, rect.r.x, rect.r.y, rect.r.w, rect.r.h);\n\t  continue;\n        }\n        */\n        \n        /* If RichCursor encoding is used, we should prevent collisions\n\t   between framebuffer updates and cursor drawing operations. */\n        client->SoftCursorLockArea(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h);\n      }\n\n      switch (rect.encoding) {\n\n      case rfbEncodingRaw: {\n\tint y=rect.r.y, h=rect.r.h;\n\n\tbytesPerLine = rect.r.w * client->format.bitsPerPixel / 8;\n\t/* RealVNC 4.x-5.x on OSX can induce bytesPerLine==0, \n\t   usually during GPU accel. */\n\t/* Regardless of cause, do not divide by zero. */\n\tlinesToRead = bytesPerLine ? (RFB_BUFFER_SIZE / bytesPerLine) : 0;\n\n\twhile (linesToRead && h > 0) {\n\t  if (linesToRead > h)\n\t    linesToRead = h;\n\n\t  if (!ReadFromRFBServer(client, client->buffer,bytesPerLine * linesToRead))\n\t    return FALSE;\n\n\t  client->GotBitmap(client, (uint8_t *)client->buffer,\n\t\t\t   rect.r.x, y, rect.r.w,linesToRead);\n\n\t  h -= linesToRead;\n\t  y += linesToRead;\n\n\t}\n\tbreak;\n      } \n\n      case rfbEncodingCopyRect:\n      {\n\trfbCopyRect cr;\n\n\tif (!ReadFromRFBServer(client, (char *)&cr, sz_rfbCopyRect))\n\t  return FALSE;\n\n\tcr.srcX = rfbClientSwap16IfLE(cr.srcX);\n\tcr.srcY = rfbClientSwap16IfLE(cr.srcY);\n\n\t/* If RichCursor encoding is used, we should extend our\n\t   \"cursor lock area\" (previously set to destination\n\t   rectangle) to the source rectangle as well. */\n\tclient->SoftCursorLockArea(client,\n\t\t\t\t   cr.srcX, cr.srcY, rect.r.w, rect.r.h);\n\n        client->GotCopyRect(client, cr.srcX, cr.srcY, rect.r.w, rect.r.h,\n                            rect.r.x, rect.r.y);\n\n\tbreak;\n      }\n\n      case rfbEncodingRRE:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleRRE8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleRRE16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleRRE32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n      }\n\n      case rfbEncodingCoRRE:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleCoRRE8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleCoRRE16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleCoRRE32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n      }\n\n      case rfbEncodingHextile:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleHextile8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleHextile16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleHextile32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n      }\n\n      case rfbEncodingUltra:\n      {\n        switch (client->format.bitsPerPixel) {\n        case 8:\n          if (!HandleUltra8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        case 16:\n          if (!HandleUltra16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        case 32:\n          if (!HandleUltra32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        }\n        break;\n      }\n      case rfbEncodingUltraZip:\n      {\n        switch (client->format.bitsPerPixel) {\n        case 8:\n          if (!HandleUltraZip8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        case 16:\n          if (!HandleUltraZip16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        case 32:\n          if (!HandleUltraZip32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        }\n        break;\n      }\n\n      case rfbEncodingTRLE:\n\t  {\n        switch (client->format.bitsPerPixel) {\n        case 8:\n          if (!HandleTRLE8(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n            return FALSE;\n          break;\n        case 16:\n          if (client->si.format.greenMax > 0x1F) {\n            if (!HandleTRLE16(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n              return FALSE;\n          } else {\n            if (!HandleTRLE15(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n              return FALSE;\n          }\n          break;\n        case 32: {\n          uint32_t maxColor =\n              (client->format.redMax << client->format.redShift) |\n              (client->format.greenMax << client->format.greenShift) |\n              (client->format.blueMax << client->format.blueShift);\n          if ((client->format.bigEndian && (maxColor & 0xff) == 0) ||\n              (!client->format.bigEndian && (maxColor & 0xff000000) == 0)) {\n            if (!HandleTRLE24(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n              return FALSE;\n          } else if (!client->format.bigEndian && (maxColor & 0xff) == 0) {\n            if (!HandleTRLE24Up(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n              return FALSE;\n          } else if (client->format.bigEndian && (maxColor & 0xff000000) == 0) {\n            if (!HandleTRLE24Down(client, rect.r.x, rect.r.y, rect.r.w,\n                                  rect.r.h))\n              return FALSE;\n          } else if (!HandleTRLE32(client, rect.r.x, rect.r.y, rect.r.w,\n                                   rect.r.h))\n            return FALSE;\n          break;\n        }\n        }\n        break;\n      }\n\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n      case rfbEncodingZlib:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleZlib8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleZlib16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleZlib32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n     }\n\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n      case rfbEncodingTight:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleTight8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleTight16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleTight32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n      }\n#endif\n      case rfbEncodingZRLE:\n\t/* Fail safe for ZYWRLE unsupport VNC server. */\n\tclient->appData.qualityLevel = 9;\n\t/* fall through */\n      case rfbEncodingZYWRLE:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleZRLE8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (client->si.format.greenMax > 0x1F) {\n\t    if (!HandleZRLE16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  } else {\n\t    if (!HandleZRLE15(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  }\n\t  break;\n\tcase 32:\n\t{\n\t  uint32_t maxColor=(client->format.redMax<<client->format.redShift)|\n\t\t(client->format.greenMax<<client->format.greenShift)|\n\t\t(client->format.blueMax<<client->format.blueShift);\n\t  if ((client->format.bigEndian && (maxColor&0xff)==0) ||\n\t      (!client->format.bigEndian && (maxColor&0xff000000)==0)) {\n\t    if (!HandleZRLE24(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  } else if (!client->format.bigEndian && (maxColor&0xff)==0) {\n\t    if (!HandleZRLE24Up(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  } else if (client->format.bigEndian && (maxColor&0xff000000)==0) {\n\t    if (!HandleZRLE24Down(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  } else if (!HandleZRLE32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\t}\n\tbreak;\n     }\n\n#endif\n\n      default:\n\t {\n\t   rfbBool handled = FALSE;\n\t   rfbClientProtocolExtension* e;\n\n\t   for(e = rfbClientExtensions; !handled && e; e = e->next)\n\t     if(e->handleEncoding && e->handleEncoding(client, &rect))\n\t       handled = TRUE;\n\n\t   if(!handled) {\n\t     rfbClientLog(\"Unknown rect encoding %d\\n\",\n\t\t (int)rect.encoding);\n\t     return FALSE;\n\t   }\n\t }\n      }\n\n      /* Now we may discard \"soft cursor locks\". */\n      client->SoftCursorUnlockScreen(client);\n\n      client->GotFrameBufferUpdate(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h);\n    }\n\n    if (!SendIncrementalFramebufferUpdateRequest(client))\n      return FALSE;\n\n    if (client->FinishedFrameBufferUpdate)\n      client->FinishedFrameBufferUpdate(client);\n\n    break;\n  }\n\n  case rfbBell:\n  {\n    client->Bell(client);\n\n    break;\n  }\n\n  case rfbServerCutText:\n  {\n    char *buffer;\n\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n\t\t\t   sz_rfbServerCutTextMsg - 1))\n      return FALSE;\n\n    msg.sct.length = rfbClientSwap32IfLE(msg.sct.length);\n\n    if (msg.sct.length > 1<<20) {\n\t    rfbClientErr(\"Ignoring too big cut text length sent by server: %u B > 1 MB\\n\", (unsigned int)msg.sct.length);\n\t    return FALSE;\n    }  \n\n    buffer = malloc(msg.sct.length+1);\n\n    if (!ReadFromRFBServer(client, buffer, msg.sct.length)) {\n      free(buffer);\n      return FALSE;\n    }\n\n    buffer[msg.sct.length] = 0;\n\n    if (client->GotXCutText)\n      client->GotXCutText(client, buffer, msg.sct.length);\n\n    free(buffer);\n\n    break;\n  }\n\n  case rfbTextChat:\n  {\n      char *buffer=NULL;\n      if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n                             sz_rfbTextChatMsg- 1))\n        return FALSE;\n      msg.tc.length = rfbClientSwap32IfLE(msg.sct.length);\n      switch(msg.tc.length) {\n      case rfbTextChatOpen:\n          rfbClientLog(\"Received TextChat Open\\n\");\n          if (client->HandleTextChat!=NULL)\n              client->HandleTextChat(client, (int)rfbTextChatOpen, NULL);\n          break;\n      case rfbTextChatClose:\n          rfbClientLog(\"Received TextChat Close\\n\");\n         if (client->HandleTextChat!=NULL)\n              client->HandleTextChat(client, (int)rfbTextChatClose, NULL);\n          break;\n      case rfbTextChatFinished:\n          rfbClientLog(\"Received TextChat Finished\\n\");\n         if (client->HandleTextChat!=NULL)\n              client->HandleTextChat(client, (int)rfbTextChatFinished, NULL);\n          break;\n      default:\n          buffer=malloc(msg.tc.length+1);\n          if (!ReadFromRFBServer(client, buffer, msg.tc.length))\n          {\n              free(buffer);\n              return FALSE;\n          }\n          /* Null Terminate <just in case> */\n          buffer[msg.tc.length]=0;\n          rfbClientLog(\"Received TextChat \\\"%s\\\"\\n\", buffer);\n          if (client->HandleTextChat!=NULL)\n              client->HandleTextChat(client, (int)msg.tc.length, buffer);\n          free(buffer);\n          break;\n      }\n      break;\n  }\n\n  case rfbXvp:\n  {\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n                           sz_rfbXvpMsg -1))\n      return FALSE;\n\n    SetClient2Server(client, rfbXvp);\n    /* technically, we only care what we can *send* to the server\n     * but, we set Server2Client Just in case it ever becomes useful\n     */\n    SetServer2Client(client, rfbXvp);\n\n    if(client->HandleXvpMsg)\n      client->HandleXvpMsg(client, msg.xvp.version, msg.xvp.code);\n\n    break;\n  }\n\n  case rfbResizeFrameBuffer:\n  {\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n                           sz_rfbResizeFrameBufferMsg -1))\n      return FALSE;\n    client->width = rfbClientSwap16IfLE(msg.rsfb.framebufferWidth);\n    client->height = rfbClientSwap16IfLE(msg.rsfb.framebufferHeigth);\n    client->updateRect.x = client->updateRect.y = 0;\n    client->updateRect.w = client->width;\n    client->updateRect.h = client->height;\n    if (!client->MallocFrameBuffer(client))\n      return FALSE;\n\n    SendFramebufferUpdateRequest(client, 0, 0, client->width, client->height, FALSE);\n    rfbClientLog(\"Got new framebuffer size: %dx%d\\n\", client->width, client->height);\n    break;\n  }\n\n  case rfbPalmVNCReSizeFrameBuffer:\n  {\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n                           sz_rfbPalmVNCReSizeFrameBufferMsg -1))\n      return FALSE;\n    client->width = rfbClientSwap16IfLE(msg.prsfb.buffer_w);\n    client->height = rfbClientSwap16IfLE(msg.prsfb.buffer_h);\n    client->updateRect.x = client->updateRect.y = 0;\n    client->updateRect.w = client->width;\n    client->updateRect.h = client->height;\n    if (!client->MallocFrameBuffer(client))\n      return FALSE;\n    SendFramebufferUpdateRequest(client, 0, 0, client->width, client->height, FALSE);\n    rfbClientLog(\"Got new framebuffer size: %dx%d\\n\", client->width, client->height);\n    break;\n  }\n\n  default:\n    {\n      rfbBool handled = FALSE;\n      rfbClientProtocolExtension* e;\n\n      for(e = rfbClientExtensions; !handled && e; e = e->next)\n\tif(e->handleMessage && e->handleMessage(client, &msg))\n\t  handled = TRUE;\n\n      if(!handled) {\n\tchar buffer[256];\n\trfbClientLog(\"Unknown message type %d from VNC server\\n\",msg.type);\n\tReadFromRFBServer(client, buffer, 256);\n\treturn FALSE;\n      }\n    }\n  }\n\n  return TRUE;\n}",
        "start_line": 1604
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "libvncclient/rfbproto.c",
        "method_name": "HandleRFBServerMessage",
        "raw_code": "rfbBool /* <=== HandleRFBServerMessage */ \nHandleRFBServerMessage(rfbClient* client)\n{\n  rfbServerToClientMsg msg;\n\n  if (client->serverPort==-1)\n    client->vncRec->readTimestamp = TRUE;\n  if (!ReadFromRFBServer(client, (char *)&msg, 1))\n    return FALSE;\n\n  switch (msg.type) {\n\n  case rfbSetColourMapEntries:\n  {\n    /* TODO:\n    int i;\n    uint16_t rgb[3];\n    XColor xc;\n\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n\t\t\t   sz_rfbSetColourMapEntriesMsg - 1))\n      return FALSE;\n\n    msg.scme.firstColour = rfbClientSwap16IfLE(msg.scme.firstColour);\n    msg.scme.nColours = rfbClientSwap16IfLE(msg.scme.nColours);\n\n    for (i = 0; i < msg.scme.nColours; i++) {\n      if (!ReadFromRFBServer(client, (char *)rgb, 6))\n\treturn FALSE;\n      xc.pixel = msg.scme.firstColour + i;\n      xc.red = rfbClientSwap16IfLE(rgb[0]);\n      xc.green = rfbClientSwap16IfLE(rgb[1]);\n      xc.blue = rfbClientSwap16IfLE(rgb[2]);\n      xc.flags = DoRed|DoGreen|DoBlue;\n      XStoreColor(dpy, cmap, &xc);\n    }\n    */\n\n    break;\n  }\n\n  case rfbFramebufferUpdate:\n  {\n    rfbFramebufferUpdateRectHeader rect;\n    int linesToRead;\n    int bytesPerLine;\n    int i;\n\n    if (!ReadFromRFBServer(client, ((char *)&msg.fu) + 1,\n\t\t\t   sz_rfbFramebufferUpdateMsg - 1))\n      return FALSE;\n\n    msg.fu.nRects = rfbClientSwap16IfLE(msg.fu.nRects);\n\n    for (i = 0; i < msg.fu.nRects; i++) {\n      if (!ReadFromRFBServer(client, (char *)&rect, sz_rfbFramebufferUpdateRectHeader))\n\treturn FALSE;\n\n      rect.encoding = rfbClientSwap32IfLE(rect.encoding);\n      if (rect.encoding == rfbEncodingLastRect)\n\tbreak;\n\n      rect.r.x = rfbClientSwap16IfLE(rect.r.x);\n      rect.r.y = rfbClientSwap16IfLE(rect.r.y);\n      rect.r.w = rfbClientSwap16IfLE(rect.r.w);\n      rect.r.h = rfbClientSwap16IfLE(rect.r.h);\n\n\n      if (rect.encoding == rfbEncodingXCursor ||\n\t  rect.encoding == rfbEncodingRichCursor) {\n\n\tif (!HandleCursorShape(client,\n\t\t\t       rect.r.x, rect.r.y, rect.r.w, rect.r.h,\n\t\t\t       rect.encoding)) {\n\t  return FALSE;\n\t}\n\tcontinue;\n      }\n\n      if (rect.encoding == rfbEncodingPointerPos) {\n\tif (!client->HandleCursorPos(client,rect.r.x, rect.r.y)) {\n\t  return FALSE;\n\t}\n\tcontinue;\n      }\n      \n      if (rect.encoding == rfbEncodingKeyboardLedState) {\n          /* OK! We have received a keyboard state message!!! */\n          client->KeyboardLedStateEnabled = 1;\n          if (client->HandleKeyboardLedState!=NULL)\n              client->HandleKeyboardLedState(client, rect.r.x, 0);\n          /* stash it for the future */\n          client->CurrentKeyboardLedState = rect.r.x;\n          continue;\n      }\n\n      if (rect.encoding == rfbEncodingNewFBSize) {\n\tclient->width = rect.r.w;\n\tclient->height = rect.r.h;\n\tclient->updateRect.x = client->updateRect.y = 0;\n\tclient->updateRect.w = client->width;\n\tclient->updateRect.h = client->height;\n\tif (!client->MallocFrameBuffer(client))\n\t  return FALSE;\n\tSendFramebufferUpdateRequest(client, 0, 0, rect.r.w, rect.r.h, FALSE);\n\trfbClientLog(\"Got new framebuffer size: %dx%d\\n\", rect.r.w, rect.r.h);\n\tcontinue;\n      }\n\n      /* rect.r.w=byte count */\n      if (rect.encoding == rfbEncodingSupportedMessages) {\n          int loop;\n          if (!ReadFromRFBServer(client, (char *)&client->supportedMessages, sz_rfbSupportedMessages))\n              return FALSE;\n\n          /* msgs is two sets of bit flags of supported messages client2server[] and server2client[] */\n          /* currently ignored by this library */\n\n          rfbClientLog(\"client2server supported messages (bit flags)\\n\");\n          for (loop=0;loop<32;loop+=8)\n            rfbClientLog(\"%02X: %04x %04x %04x %04x - %04x %04x %04x %04x\\n\", loop,\n                client->supportedMessages.client2server[loop],   client->supportedMessages.client2server[loop+1],\n                client->supportedMessages.client2server[loop+2], client->supportedMessages.client2server[loop+3],\n                client->supportedMessages.client2server[loop+4], client->supportedMessages.client2server[loop+5],\n                client->supportedMessages.client2server[loop+6], client->supportedMessages.client2server[loop+7]);\n\n          rfbClientLog(\"server2client supported messages (bit flags)\\n\");\n          for (loop=0;loop<32;loop+=8)\n            rfbClientLog(\"%02X: %04x %04x %04x %04x - %04x %04x %04x %04x\\n\", loop,\n                client->supportedMessages.server2client[loop],   client->supportedMessages.server2client[loop+1],\n                client->supportedMessages.server2client[loop+2], client->supportedMessages.server2client[loop+3],\n                client->supportedMessages.server2client[loop+4], client->supportedMessages.server2client[loop+5],\n                client->supportedMessages.server2client[loop+6], client->supportedMessages.server2client[loop+7]);\n          continue;\n      }\n\n      /* rect.r.w=byte count, rect.r.h=# of encodings */\n      if (rect.encoding == rfbEncodingSupportedEncodings) {\n          char *buffer;\n          buffer = malloc(rect.r.w);\n          if (!ReadFromRFBServer(client, buffer, rect.r.w))\n          {\n              free(buffer);\n              return FALSE;\n          }\n\n          /* buffer now contains rect.r.h # of uint32_t encodings that the server supports */\n          /* currently ignored by this library */\n          free(buffer);\n          continue;\n      }\n\n      /* rect.r.w=byte count */\n      if (rect.encoding == rfbEncodingServerIdentity) {\n          char *buffer;\n          buffer = malloc(rect.r.w+1);\n          if (!ReadFromRFBServer(client, buffer, rect.r.w))\n          {\n              free(buffer);\n              return FALSE;\n          }\n          buffer[rect.r.w]=0; /* null terminate, just in case */\n          rfbClientLog(\"Connected to Server \\\"%s\\\"\\n\", buffer);\n          free(buffer);\n          continue;\n      }\n\n      /* rfbEncodingUltraZip is a collection of subrects.   x = # of subrects, and h is always 0 */\n      if (rect.encoding != rfbEncodingUltraZip)\n      {\n        if ((rect.r.x + rect.r.w > client->width) ||\n\t    (rect.r.y + rect.r.h > client->height))\n\t    {\n\t      rfbClientLog(\"Rect too large: %dx%d at (%d, %d)\\n\",\n\t  \t  rect.r.w, rect.r.h, rect.r.x, rect.r.y);\n\t      return FALSE;\n            }\n\n        /* UltraVNC with scaling, will send rectangles with a zero W or H\n         *\n        if ((rect.encoding != rfbEncodingTight) && \n            (rect.r.h * rect.r.w == 0))\n        {\n\t  rfbClientLog(\"Zero size rect - ignoring (encoding=%d (0x%08x) %dx, %dy, %dw, %dh)\\n\", rect.encoding, rect.encoding, rect.r.x, rect.r.y, rect.r.w, rect.r.h);\n\t  continue;\n        }\n        */\n        \n        /* If RichCursor encoding is used, we should prevent collisions\n\t   between framebuffer updates and cursor drawing operations. */\n        client->SoftCursorLockArea(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h);\n      }\n\n      switch (rect.encoding) {\n\n      case rfbEncodingRaw: {\n\tint y=rect.r.y, h=rect.r.h;\n\n\tbytesPerLine = rect.r.w * client->format.bitsPerPixel / 8;\n\t/* RealVNC 4.x-5.x on OSX can induce bytesPerLine==0, \n\t   usually during GPU accel. */\n\t/* Regardless of cause, do not divide by zero. */\n\tlinesToRead = bytesPerLine ? (RFB_BUFFER_SIZE / bytesPerLine) : 0;\n\n\twhile (linesToRead && h > 0) {\n\t  if (linesToRead > h)\n\t    linesToRead = h;\n\n\t  if (!ReadFromRFBServer(client, client->buffer,bytesPerLine * linesToRead))\n\t    return FALSE;\n\n\t  client->GotBitmap(client, (uint8_t *)client->buffer,\n\t\t\t   rect.r.x, y, rect.r.w,linesToRead);\n\n\t  h -= linesToRead;\n\t  y += linesToRead;\n\n\t}\n\tbreak;\n      } \n\n      case rfbEncodingCopyRect:\n      {\n\trfbCopyRect cr;\n\n\tif (!ReadFromRFBServer(client, (char *)&cr, sz_rfbCopyRect))\n\t  return FALSE;\n\n\tcr.srcX = rfbClientSwap16IfLE(cr.srcX);\n\tcr.srcY = rfbClientSwap16IfLE(cr.srcY);\n\n\t/* If RichCursor encoding is used, we should extend our\n\t   \"cursor lock area\" (previously set to destination\n\t   rectangle) to the source rectangle as well. */\n\tclient->SoftCursorLockArea(client,\n\t\t\t\t   cr.srcX, cr.srcY, rect.r.w, rect.r.h);\n\n        client->GotCopyRect(client, cr.srcX, cr.srcY, rect.r.w, rect.r.h,\n                            rect.r.x, rect.r.y);\n\n\tbreak;\n      }\n\n      case rfbEncodingRRE:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleRRE8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleRRE16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleRRE32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n      }\n\n      case rfbEncodingCoRRE:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleCoRRE8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleCoRRE16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleCoRRE32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n      }\n\n      case rfbEncodingHextile:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleHextile8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleHextile16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleHextile32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n      }\n\n      case rfbEncodingUltra:\n      {\n        switch (client->format.bitsPerPixel) {\n        case 8:\n          if (!HandleUltra8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        case 16:\n          if (!HandleUltra16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        case 32:\n          if (!HandleUltra32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        }\n        break;\n      }\n      case rfbEncodingUltraZip:\n      {\n        switch (client->format.bitsPerPixel) {\n        case 8:\n          if (!HandleUltraZip8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        case 16:\n          if (!HandleUltraZip16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        case 32:\n          if (!HandleUltraZip32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n            return FALSE;\n          break;\n        }\n        break;\n      }\n\n      case rfbEncodingTRLE:\n\t  {\n        switch (client->format.bitsPerPixel) {\n        case 8:\n          if (!HandleTRLE8(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n            return FALSE;\n          break;\n        case 16:\n          if (client->si.format.greenMax > 0x1F) {\n            if (!HandleTRLE16(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n              return FALSE;\n          } else {\n            if (!HandleTRLE15(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n              return FALSE;\n          }\n          break;\n        case 32: {\n          uint32_t maxColor =\n              (client->format.redMax << client->format.redShift) |\n              (client->format.greenMax << client->format.greenShift) |\n              (client->format.blueMax << client->format.blueShift);\n          if ((client->format.bigEndian && (maxColor & 0xff) == 0) ||\n              (!client->format.bigEndian && (maxColor & 0xff000000) == 0)) {\n            if (!HandleTRLE24(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n              return FALSE;\n          } else if (!client->format.bigEndian && (maxColor & 0xff) == 0) {\n            if (!HandleTRLE24Up(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h))\n              return FALSE;\n          } else if (client->format.bigEndian && (maxColor & 0xff000000) == 0) {\n            if (!HandleTRLE24Down(client, rect.r.x, rect.r.y, rect.r.w,\n                                  rect.r.h))\n              return FALSE;\n          } else if (!HandleTRLE32(client, rect.r.x, rect.r.y, rect.r.w,\n                                   rect.r.h))\n            return FALSE;\n          break;\n        }\n        }\n        break;\n      }\n\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n      case rfbEncodingZlib:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleZlib8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleZlib16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleZlib32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n     }\n\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n      case rfbEncodingTight:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleTight8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (!HandleTight16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 32:\n\t  if (!HandleTight32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\tbreak;\n      }\n#endif\n      case rfbEncodingZRLE:\n\t/* Fail safe for ZYWRLE unsupport VNC server. */\n\tclient->appData.qualityLevel = 9;\n\t/* fall through */\n      case rfbEncodingZYWRLE:\n      {\n\tswitch (client->format.bitsPerPixel) {\n\tcase 8:\n\t  if (!HandleZRLE8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\tcase 16:\n\t  if (client->si.format.greenMax > 0x1F) {\n\t    if (!HandleZRLE16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  } else {\n\t    if (!HandleZRLE15(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  }\n\t  break;\n\tcase 32:\n\t{\n\t  uint32_t maxColor=(client->format.redMax<<client->format.redShift)|\n\t\t(client->format.greenMax<<client->format.greenShift)|\n\t\t(client->format.blueMax<<client->format.blueShift);\n\t  if ((client->format.bigEndian && (maxColor&0xff)==0) ||\n\t      (!client->format.bigEndian && (maxColor&0xff000000)==0)) {\n\t    if (!HandleZRLE24(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  } else if (!client->format.bigEndian && (maxColor&0xff)==0) {\n\t    if (!HandleZRLE24Up(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  } else if (client->format.bigEndian && (maxColor&0xff000000)==0) {\n\t    if (!HandleZRLE24Down(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t      return FALSE;\n\t  } else if (!HandleZRLE32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))\n\t    return FALSE;\n\t  break;\n\t}\n\t}\n\tbreak;\n     }\n\n#endif\n\n      default:\n\t {\n\t   rfbBool handled = FALSE;\n\t   rfbClientProtocolExtension* e;\n\n\t   for(e = rfbClientExtensions; !handled && e; e = e->next)\n\t     if(e->handleEncoding && e->handleEncoding(client, &rect))\n\t       handled = TRUE;\n\n\t   if(!handled) {\n\t     rfbClientLog(\"Unknown rect encoding %d\\n\",\n\t\t (int)rect.encoding);\n\t     return FALSE;\n\t   }\n\t }\n      }\n\n      /* Now we may discard \"soft cursor locks\". */\n      client->SoftCursorUnlockScreen(client);\n\n      client->GotFrameBufferUpdate(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h);\n    }\n\n    if (!SendIncrementalFramebufferUpdateRequest(client))\n      return FALSE;\n\n    if (client->FinishedFrameBufferUpdate)\n      client->FinishedFrameBufferUpdate(client);\n\n    break;\n  }\n\n  case rfbBell:\n  {\n    client->Bell(client);\n\n    break;\n  }\n\n  case rfbServerCutText:\n  {\n    char *buffer;\n\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n\t\t\t   sz_rfbServerCutTextMsg - 1))\n      return FALSE;\n\n    msg.sct.length = rfbClientSwap32IfLE(msg.sct.length);\n\n    if (msg.sct.length > 1<<20) {\n\t    rfbClientErr(\"Ignoring too big cut text length sent by server: %u B > 1 MB\\n\", (unsigned int)msg.sct.length);\n\t    return FALSE;\n    }  \n\n    buffer = malloc(msg.sct.length+1);\n\n    if (!ReadFromRFBServer(client, buffer, msg.sct.length)) {\n      free(buffer);\n      return FALSE;\n    }\n\n    buffer[msg.sct.length] = 0;\n\n    if (client->GotXCutText)\n      client->GotXCutText(client, buffer, msg.sct.length);\n\n    free(buffer);\n\n    break;\n  }\n\n  case rfbTextChat:\n  {\n      char *buffer=NULL;\n      if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n                             sz_rfbTextChatMsg- 1))\n        return FALSE;\n      msg.tc.length = rfbClientSwap32IfLE(msg.sct.length);\n      switch(msg.tc.length) {\n      case rfbTextChatOpen:\n          rfbClientLog(\"Received TextChat Open\\n\");\n          if (client->HandleTextChat!=NULL)\n              client->HandleTextChat(client, (int)rfbTextChatOpen, NULL);\n          break;\n      case rfbTextChatClose:\n          rfbClientLog(\"Received TextChat Close\\n\");\n         if (client->HandleTextChat!=NULL)\n              client->HandleTextChat(client, (int)rfbTextChatClose, NULL);\n          break;\n      case rfbTextChatFinished:\n          rfbClientLog(\"Received TextChat Finished\\n\");\n         if (client->HandleTextChat!=NULL)\n              client->HandleTextChat(client, (int)rfbTextChatFinished, NULL);\n          break;\n      default:\n\t  if(msg.tc.length > MAX_TEXTCHAT_SIZE)\n\t      return FALSE;\n          buffer=malloc(msg.tc.length+1);\n          if (!ReadFromRFBServer(client, buffer, msg.tc.length))\n          {\n              free(buffer);\n              return FALSE;\n          }\n          /* Null Terminate <just in case> */\n          buffer[msg.tc.length]=0;\n          rfbClientLog(\"Received TextChat \\\"%s\\\"\\n\", buffer);\n          if (client->HandleTextChat!=NULL)\n              client->HandleTextChat(client, (int)msg.tc.length, buffer);\n          free(buffer);\n          break;\n      }\n      break;\n  }\n\n  case rfbXvp:\n  {\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n                           sz_rfbXvpMsg -1))\n      return FALSE;\n\n    SetClient2Server(client, rfbXvp);\n    /* technically, we only care what we can *send* to the server\n     * but, we set Server2Client Just in case it ever becomes useful\n     */\n    SetServer2Client(client, rfbXvp);\n\n    if(client->HandleXvpMsg)\n      client->HandleXvpMsg(client, msg.xvp.version, msg.xvp.code);\n\n    break;\n  }\n\n  case rfbResizeFrameBuffer:\n  {\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n                           sz_rfbResizeFrameBufferMsg -1))\n      return FALSE;\n    client->width = rfbClientSwap16IfLE(msg.rsfb.framebufferWidth);\n    client->height = rfbClientSwap16IfLE(msg.rsfb.framebufferHeigth);\n    client->updateRect.x = client->updateRect.y = 0;\n    client->updateRect.w = client->width;\n    client->updateRect.h = client->height;\n    if (!client->MallocFrameBuffer(client))\n      return FALSE;\n\n    SendFramebufferUpdateRequest(client, 0, 0, client->width, client->height, FALSE);\n    rfbClientLog(\"Got new framebuffer size: %dx%d\\n\", client->width, client->height);\n    break;\n  }\n\n  case rfbPalmVNCReSizeFrameBuffer:\n  {\n    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,\n                           sz_rfbPalmVNCReSizeFrameBufferMsg -1))\n      return FALSE;\n    client->width = rfbClientSwap16IfLE(msg.prsfb.buffer_w);\n    client->height = rfbClientSwap16IfLE(msg.prsfb.buffer_h);\n    client->updateRect.x = client->updateRect.y = 0;\n    client->updateRect.w = client->width;\n    client->updateRect.h = client->height;\n    if (!client->MallocFrameBuffer(client))\n      return FALSE;\n    SendFramebufferUpdateRequest(client, 0, 0, client->width, client->height, FALSE);\n    rfbClientLog(\"Got new framebuffer size: %dx%d\\n\", client->width, client->height);\n    break;\n  }\n\n  default:\n    {\n      rfbBool handled = FALSE;\n      rfbClientProtocolExtension* e;\n\n      for(e = rfbClientExtensions; !handled && e; e = e->next)\n\tif(e->handleMessage && e->handleMessage(client, &msg))\n\t  handled = TRUE;\n\n      if(!handled) {\n\tchar buffer[256];\n\trfbClientLog(\"Unknown message type %d from VNC server\\n\",msg.type);\n\tReadFromRFBServer(client, buffer, 256);\n\treturn FALSE;\n      }\n    }\n  }\n\n  return TRUE;\n}",
        "start_line": 1605
      }
    ],
    "code_context": "Called Methods:\n- MAX_TEXTCHAT_SIZE: #define MAX_TEXTCHAT_SIZE 10485760 /* 10MB */ /* <=== libvncclient/rfbproto.c:68:68:MAX_TEXTCHAT_SIZE:0 */ \n- ReadFromRFBServer: rfbBool /* <=== ReadFromRFBServer */ \nReadFromRFBServer(rfbClient* client, char *out, unsigned int n)\n{\n#undef DEBUG_READ_EXACT\n#ifdef DEBUG_READ_EXACT\n\tchar* oout=out;\n\tunsigned int nn=n;\n\trfbClientLog(\"ReadFromRFBServer %d bytes\\n\",n);\n#endif\n\n  /* Handle attempts to write to NULL out buffer that might occur\n     when an outside malloc() fails. For instance, memcpy() to NULL\n     results in undefined behaviour and probably memory corruption.*/\n  if(!out)\n    return FALSE;\n\n  if (client->serverPort==-1) {\n    /* vncrec playing */\n    rfbVNCRec* rec = client->vncRec;\n    struct timeval tv;\n\n    if (rec->readTimestamp) {\n      rec->readTimestamp = FALSE;\n      if (!fread(&tv,sizeof(struct timeval),1,rec->file))\n        return FALSE;\n\n      tv.tv_sec = rfbClientSwap32IfLE (tv.tv_sec);\n      tv.tv_usec = rfbClientSwap32IfLE (tv.tv_usec);\n\n      if (rec->tv.tv_sec!=0 && !rec->doNotSleep) {\n        struct timeval diff;\n        diff.tv_sec = tv.tv_sec - rec->tv.tv_sec;\n        diff.tv_usec = tv.tv_usec - rec->tv.tv_usec;\n        if(diff.tv_usec<0) {\n\t  diff.tv_sec--;\n\t  diff.tv_usec+=1000000;\n        }\n#ifndef WIN32\n        sleep (diff.tv_sec);\n        usleep (diff.tv_usec);\n#else\n\tSleep (diff.tv_sec * 1000 + diff.tv_usec/1000);\n#endif\n      }\n\n      rec->tv=tv;\n    }\n    \n    return (fread(out,1,n,rec->file) != n ? FALSE : TRUE);\n  }\n  \n  if (n <= client->buffered) {\n    memcpy(out, client->bufoutptr, n);\n    client->bufoutptr += n;\n    client->buffered -= n;\n#ifdef DEBUG_READ_EXACT\n    goto hexdump;\n#endif\n    return TRUE;\n  }\n\n  memcpy(out, client->bufoutptr, client->buffered);\n\n  out += client->buffered;\n  n -= client->buffered;\n\n  client->bufoutptr = client->buf;\n  client->buffered = 0;\n\n  if (n <= RFB_BUF_SIZE) {\n\n    while (client->buffered < n) {\n      int i;\n      if (client->tlsSession)\n        i = ReadFromTLS(client, client->buf + client->buffered, RFB_BUF_SIZE - client->buffered);\n      else\n#ifdef LIBVNCSERVER_HAVE_SASL\n      if (client->saslconn)\n        i = ReadFromSASL(client, client->buf + client->buffered, RFB_BUF_SIZE - client->buffered);\n      else {\n#endif /* LIBVNCSERVER_HAVE_SASL */\n        i = read(client->sock, client->buf + client->buffered, RFB_BUF_SIZE - client->buffered);\n#ifdef WIN32\n\tif (i < 0) errno=WSAGetLastError();\n#endif\n#ifdef LIBVNCSERVER_HAVE_SASL\n      }\n#endif\n  \n      if (i <= 0) {\n\tif (i < 0) {\n\t  if (errno == EWOULDBLOCK || errno == EAGAIN) {\n\t    /* TODO:\n\t       ProcessXtEvents();\n\t    */\n\t    WaitForMessage(client, 100000);\n\t    i = 0;\n\t  } else {\n\t    rfbClientErr(\"read (%d: %s)\\n\",errno,strerror(errno));\n\t    return FALSE;\n\t  }\n\t} else {\n\t  if (errorMessageOnReadFailure) {\n\t    rfbClientLog(\"VNC server closed connection\\n\");\n\t  }\n\t  return FALSE;\n\t}\n      }\n      client->buffered += i;\n    }\n\n    memcpy(out, client->bufoutptr, n);\n    client->bufoutptr += n;\n    client->buffered -= n;\n\n  } else {\n\n    while (n > 0) {\n      int i;\n      if (client->tlsSession)\n        i = ReadFromTLS(client, out, n);\n      else\n#ifdef LIBVNCSERVER_HAVE_SASL\n      if (client->saslconn)\n        i = ReadFromSASL(client, out, n);\n      else\n#endif\n        i = read(client->sock, out, n);\n\n      if (i <= 0) {\n\tif (i < 0) {\n#ifdef WIN32\n\t  errno=WSAGetLastError();\n#endif\n\t  if (errno == EWOULDBLOCK || errno == EAGAIN) {\n\t    /* TODO:\n\t       ProcessXtEvents();\n\t    */\n\t    WaitForMessage(client, 100000);\n\t    i = 0;\n\t  } else {\n\t    rfbClientErr(\"read (%s)\\n\",strerror(errno));\n\t    return FALSE;\n\t  }\n\t} else {\n\t  if (errorMessageOnReadFailure) {\n\t    rfbClientLog(\"VNC server closed connection\\n\");\n\t  }\n\t  return FALSE;\n\t}\n      }\n      out += i;\n      n -= i;\n    }\n  }\n\n#ifdef DEBUG_READ_EXACT\nhexdump:\n  { unsigned int ii;\n    for(ii=0;ii<nn;ii++)\n      fprintf(stderr,\"%02x \",(unsigned char)oout[ii]);\n    fprintf(stderr,\"\\n\");\n  }\n#endif\n\n  return TRUE;\n}\n- ReadFromTLS: int ReadFromTLS(rfbClient* client, char *out, unsigned int n) /* <=== ReadFromTLS */ \n{\n  rfbClientLog(\"TLS is not supported.\\n\");\n  errno = EINTR;\n  return -1;\n}\n- ReadFromTLS: int /* <=== ReadFromTLS */ \nReadFromTLS(rfbClient* client, char *out, unsigned int n)\n{\n  ssize_t ret;\n  int ssl_error = SSL_ERROR_NONE;\n\n  MUTEX_LOCK(mutex_rw);\n  ret = SSL_read (client->tlsSession, out, n);\n\n  if (ret < 0)\n      ssl_error = SSL_get_error(client->tlsSession, ret);\n  MUTEX_UNLOCK(mutex_rw);\n\n  if (ret >= 0)\n    return ret;\n  else {\n    errno = ssl_error_to_errno(ssl_error);\n    if (errno != EAGAIN) {\n      rfbClientLog(\"Error reading from TLS: -.\\n\");\n    }\n  }\n\n  return -1;\n}\n- ReadFromTLS: int /* <=== ReadFromTLS */ \nReadFromTLS(rfbClient* client, char *out, unsigned int n)\n{\n  ssize_t ret;\n\n  ret = gnutls_record_recv((gnutls_session_t)client->tlsSession, out, n);\n  if (ret >= 0) return ret;\n  if (ret == GNUTLS_E_REHANDSHAKE || ret == GNUTLS_E_AGAIN)\n  {\n    errno = EAGAIN;\n  } else\n  {\n    rfbClientLog(\"Error reading from TLS: %s.\\n\", gnutls_strerror(ret));\n    errno = EINTR;\n  }\n  return -1;\n}\n- WaitForMessage: int WaitForMessage(rfbClient* client,unsigned int usecs) /* <=== WaitForMessage */ \n{\n  fd_set fds;\n  struct timeval timeout;\n  int num;\n\n  if (client->serverPort==-1)\n    /* playing back vncrec file */\n    return 1;\n  \n  timeout.tv_sec=(usecs/1000000);\n  timeout.tv_usec=(usecs%1000000);\n\n  FD_ZERO(&fds);\n  FD_SET(client->sock,&fds);\n\n  num=select(client->sock+1, &fds, NULL, NULL, &timeout);\n  if(num<0) {\n#ifdef WIN32\n    errno=WSAGetLastError();\n#endif\n    rfbClientLog(\"Waiting for message failed: %d (%s)\\n\",errno,strerror(errno));\n  }\n\n  return num;\n}\n\nType Definitions:\n- rfbClient: typedef struct _rfbClient {\n\tuint8_t* frameBuffer;\n\tint width, height;\n\n\tint endianTest;\n\n\tAppData appData;\n\n\tconst char* programName;\n\tchar* serverHost;\n\tint serverPort; /**< if -1, then use file recorded by vncrec */\n\trfbBool listenSpecified;\n\tint listenPort, flashPort;\n\n\tstruct {\n\t\tint x, y, w, h;\n\t} updateRect;\n\n\t/** Note that the CoRRE encoding uses this buffer and assumes it is big enough\n\t   to hold 255 * 255 * 32 bits -> 260100 bytes.  640*480 = 307200 bytes.\n\t   Hextile also assumes it is big enough to hold 16 * 16 * 32 bits.\n\t   Tight encoding assumes BUFFER_SIZE is at least 16384 bytes. */\n\n#define RFB_BUFFER_SIZE (640*480)\n\tchar buffer[RFB_BUFFER_SIZE];\n\n\t/* rfbproto.c */\n\n\trfbSocket sock;\n\trfbBool canUseCoRRE;\n\trfbBool canUseHextile;\n\tchar *desktopName;\n\trfbPixelFormat format;\n\trfbServerInitMsg si;\n\n\t/* sockets.c */\n#define RFB_BUF_SIZE 8192\n\tchar buf[RFB_BUF_SIZE];\n\tchar *bufoutptr;\n\tunsigned int buffered;\n\n\t/* The zlib encoding requires expansion/decompression/deflation of the\n\t   compressed data in the \"buffer\" above into another, result buffer.\n\t   However, the size of the result buffer can be determined precisely\n\t   based on the bitsPerPixel, height and width of the rectangle.  We\n\t   allocate this buffer one time to be the full size of the buffer. */\n\n\t/* Ultra Encoding uses this buffer too */\n\t\n\tint ultra_buffer_size;\n\tchar *ultra_buffer;\n\n\tint raw_buffer_size;\n\tchar *raw_buffer;\n\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n\tz_stream decompStream;\n\trfbBool decompStreamInited;\n#endif\n\n\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n\t/*\n\t * Variables for the ``tight'' encoding implementation.\n\t */\n\n\t/** Separate buffer for compressed data. */\n#define ZLIB_BUFFER_SIZE 30000\n\tchar zlib_buffer[ZLIB_BUFFER_SIZE];\n\n\t/* Four independent compression streams for zlib library. */\n\tz_stream zlibStream[4];\n\trfbBool zlibStreamActive[4];\n\n\t/* Filter stuff. Should be initialized by filter initialization code. */\n\trfbBool cutZeros;\n\tint rectWidth, rectColors;\n\tchar tightPalette[256*4];\n\tuint8_t tightPrevRow[2048*3*sizeof(uint16_t)];\n\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n\t/** JPEG decoder state (obsolete-- do not use). */\n\trfbBool jpegError;\n\n\tstruct jpeg_source_mgr* jpegSrcManager;\n\tvoid* jpegBufferPtr;\n\tsize_t jpegBufferLen;\n\n#endif\n#endif\n\n\n\t/* cursor.c */\n\t/** Holds cursor shape data when received from server. */\n\tuint8_t *rcSource, *rcMask;\n\n\t/** private data pointer */\n\trfbClientData* clientData;\n\n\trfbVNCRec* vncRec;\n\n\t/* Keyboard State support (is 'Caps Lock' set on the remote display???) */\n\tint KeyboardLedStateEnabled;\n\tint CurrentKeyboardLedState;\n\n\tint canHandleNewFBSize;\n\n\t/* hooks */\n\tHandleTextChatProc         HandleTextChat;\n\tHandleKeyboardLedStateProc HandleKeyboardLedState;\n\tHandleCursorPosProc HandleCursorPos;\n\tSoftCursorLockAreaProc SoftCursorLockArea;\n\tSoftCursorUnlockScreenProc SoftCursorUnlockScreen;\n\tGotFrameBufferUpdateProc GotFrameBufferUpdate;\n\t/** the pointer returned by GetPassword will be freed after use! */\n\tGetPasswordProc GetPassword;\n\tMallocFrameBufferProc MallocFrameBuffer;\n\tGotXCutTextProc GotXCutText;\n\tBellProc Bell;\n\n\tGotCursorShapeProc GotCursorShape;\n\tGotCopyRectProc GotCopyRect;\n\n\t/** Which messages are supported by the server\n\t * This is a *guess* for most servers.\n\t * (If we can even detect the type of server)\n\t *\n\t * If the server supports the \"rfbEncodingSupportedMessages\"\n\t * then this will be updated when the encoding is received to\n\t * accurately reflect the servers capabilities.\n\t */\n\trfbSupportedMessages supportedMessages;\n\n\t/** negotiated protocol version */\n\tint major, minor;\n\n\t/** The selected security types */\n\tuint32_t authScheme, subAuthScheme;\n\n\t/** The TLS session for Anonymous TLS and VeNCrypt */\n\tvoid* tlsSession;\n\n\t/** To support security types that requires user input (except VNC password\n\t * authentication), for example VeNCrypt and MSLogon, this callback function\n\t * must be set before the authentication. Otherwise, it implicates that the\n\t * caller application does not support it and related security types should\n\t * be bypassed.\n\t */\n\tGetCredentialProc GetCredential;\n\n\t/** The 0-terminated security types supported by the client.\n\t * Set by function SetClientAuthSchemes() */\n\tuint32_t *clientAuthSchemes;\n\n\t/** When the server is a repeater, this specifies the final destination */\n\tchar *destHost;\n\tint destPort;\n\n        /** the QoS IP DSCP for this client */\n        int QoS_DSCP;\n\n        /** hook to handle xvp server messages */\n\tHandleXvpMsgProc           HandleXvpMsg;\n\n\t/* listen.c */\n        rfbSocket listenSock;\n\n\tFinishedFrameBufferUpdateProc FinishedFrameBufferUpdate;\n\n\tchar *listenAddress;\n        /* IPv6 listen socket, address and port*/\n        rfbSocket listen6Sock;\n        char* listen6Address;\n        int listen6Port;\n\n        /* Output Window ID. When set, client application enables libvncclient to perform direct rendering in its window */\n        unsigned long outputWindow;\n\n\t/** Hooks for optional protection WriteToTLS() by mutex */\n\tLockWriteToTLSProc LockWriteToTLS;\n\tUnlockWriteToTLSProc UnlockWriteToTLS;\n\n        /** Hooks for custom rendering\n         *\n         * VNC rendering boils down to 3 activities:\n         * - GotCopyRect: copy an area of the framebuffer\n         * - GotFillRect: fill an area of the framebuffer with a solid color\n         * - GotBitmap: copy the bitmap in the buffer into the framebuffer\n         * The client application should either set all three of these or none!\n         */\n        GotFillRectProc GotFillRect;\n        GotBitmapProc GotBitmap;\n        /** Hook for custom JPEG decoding and rendering */\n        GotJpegProc GotJpeg;\n\n#ifdef LIBVNCSERVER_HAVE_SASL\n        sasl_conn_t *saslconn;\n        const char *saslDecoded;\n        unsigned int saslDecodedLength;\n        unsigned int saslDecodedOffset;\n        sasl_secret_t *saslSecret;\n\n        /* Callback to allow the client to choose a preferred mechanism. The string returned will\n           be freed once no longer required. */\n        GetSASLMechanismProc GetSASLMechanism;\n        GetUserProc GetUser;\n\n#endif /* LIBVNCSERVER_HAVE_SASL */\n\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n\t/** JPEG decoder state. */\n\tvoid *tjhnd;\n\n#endif\n#endif\n\t/* timeout in seconds for select() after connect() */\n\tunsigned int connectTimeout;\n} rfbClient;\n- rfbServerToClientMsg: typedef union {\n    uint8_t type;\n    rfbFramebufferUpdateMsg fu;\n    rfbSetColourMapEntriesMsg scme;\n    rfbBellMsg b;\n    rfbServerCutTextMsg sct;\n\trfbResizeFrameBufferMsg rsfb;\n\trfbPalmVNCReSizeFrameBufferMsg prsfb; \n\trfbFileTransferMsg ft;\n\trfbTextChatMsg tc;\n\trfbXvpMsg xvp;\n\trfbExtDesktopSizeMsg eds;\n}\n\nImports:\n- #include <sys/types.h>\n- #include <rfb/rfbclient.h>\n- #include \"corre.c\"\n- #include \"zlib.c\"\n- #include \"minilzo.h\"\n- #include \"tls.h\"\n- #include \"trle.c\"\n- #include <lzo/lzo1x.h>\n- #include \"zrle.c\"\n- #include <pwd.h>\n- #include <time.h>\n- #include \"hextile.c\"\n- #include <unistd.h>\n- #include \"sasl.h\"\n- #include \"rre.c\"\n- #include <sys/stat.h>\n- #include <strings.h>\n- #include <zlib.h>\n- #include <errno.h>\n- #include \"vncauth.c\"\n- #include <stdarg.h>\n- #include \"ultra.c\"\n- #include \"tight.c\"\n- #include \"crypto.h\"",
    "commit_msg": "libvncclient/rfbproto: limit max textchat size\n\nAddresses GitHub Security Lab (GHSL) Vulnerability Report\n`GHSL-2020-063`.\n\nRe #275",
    "cve_desc": "An issue was discovered in LibVNCServer before 0.9.13. libvncclient/rfbproto.c does not limit TextChat size.",
    "year": 2020,
    "filename": "rfbproto.c",
    "commit_url": "\"https://github.com/LibVNC/libvncserver/commit/8937203441ee241c4ace85da687b7d6633a12365\""
  },
  {
    "repository": "bonzini/qemu",
    "cve_id": "CVE-2020-14415",
    "cwe_list": [
      "CWE-369"
    ],
    "commit_hash": "7a4ede0047a8613b0e3b72c9d351038f013dd357",
    "short_hash": "7a4ede00",
    "vulnerableMethods_before": [
      {
        "filename": "audio/ossaudio.c",
        "method_name": "oss_write",
        "raw_code": "static size_t oss_write(HWVoiceOut *hw, void *buf, size_t len) /* <=== oss_write */ \n{\n    OSSVoiceOut *oss = (OSSVoiceOut *) hw;\n    size_t pos;\n\n    if (oss->mmapped) {\n        size_t total_len;\n        len = MIN(len, oss_get_available_bytes(oss));\n\n        total_len = len;\n        while (len) {\n            size_t to_copy = MIN(len, hw->size_emul - hw->pos_emul);\n            memcpy(hw->buf_emul + hw->pos_emul, buf, to_copy);\n\n            hw->pos_emul = (hw->pos_emul + to_copy) % hw->pos_emul;\n            buf += to_copy;\n            len -= to_copy;\n        }\n        return total_len;\n    }\n\n    pos = 0;\n    while (len) {\n        ssize_t bytes_written;\n        void *pcm = advance(buf, pos);\n\n        bytes_written = write(oss->fd, pcm, len);\n        if (bytes_written < 0) {\n            if (errno != EAGAIN) {\n                oss_logerr(errno, \"failed to write %zu bytes\\n\",\n                           len);\n            }\n            return pos;\n        }\n\n        pos += bytes_written;\n        if (bytes_written < len) {\n            break;\n        }\n        len -= bytes_written;\n    }\n    return pos;\n}",
        "start_line": 409
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "audio/ossaudio.c",
        "method_name": "oss_write",
        "raw_code": "static size_t oss_write(HWVoiceOut *hw, void *buf, size_t len) /* <=== oss_write */ \n{\n    OSSVoiceOut *oss = (OSSVoiceOut *) hw;\n    size_t pos;\n\n    if (oss->mmapped) {\n        size_t total_len;\n        len = MIN(len, oss_get_available_bytes(oss));\n\n        total_len = len;\n        while (len) {\n            size_t to_copy = MIN(len, hw->size_emul - hw->pos_emul);\n            memcpy(hw->buf_emul + hw->pos_emul, buf, to_copy);\n\n            hw->pos_emul = (hw->pos_emul + to_copy) % hw->size_emul;\n            buf += to_copy;\n            len -= to_copy;\n        }\n        return total_len;\n    }\n\n    pos = 0;\n    while (len) {\n        ssize_t bytes_written;\n        void *pcm = advance(buf, pos);\n\n        bytes_written = write(oss->fd, pcm, len);\n        if (bytes_written < 0) {\n            if (errno != EAGAIN) {\n                oss_logerr(errno, \"failed to write %zu bytes\\n\",\n                           len);\n            }\n            return pos;\n        }\n\n        pos += bytes_written;\n        if (bytes_written < len) {\n            break;\n        }\n        len -= bytes_written;\n    }\n    return pos;\n}",
        "start_line": 409
      }
    ],
    "code_context": "Called Methods:\n- MIN: #define MIN(a, b) (((a) < (b)) ? (a) : (b)) /* <=== include/qemu/osdep.h:254:254:MIN:2 */ \n- oss_logerr: static void GCC_FMT_ATTR (2, 3) oss_logerr (int err, const char *fmt, ...) /* <=== oss_logerr */ \n{\n    va_list ap;\n\n    va_start (ap, fmt);\n    AUD_vlog (AUDIO_CAP, fmt, ap);\n    va_end (ap);\n\n    AUD_log (AUDIO_CAP, \"Reason: %s\\n\", strerror (err));\n}\n- oss_get_available_bytes: static size_t oss_get_available_bytes(OSSVoiceOut *oss) /* <=== oss_get_available_bytes */ \n{\n    int err;\n    struct count_info cntinfo;\n    assert(oss->mmapped);\n\n    err = ioctl(oss->fd, SNDCTL_DSP_GETOPTR, &cntinfo);\n    if (err < 0) {\n        oss_logerr(errno, \"SNDCTL_DSP_GETOPTR failed\\n\");\n        return 0;\n    }\n\n    return audio_ring_dist(cntinfo.ptr, oss->hw.pos_emul, oss->hw.size_emul);\n}\n- audio_ring_dist: static inline size_t audio_ring_dist(size_t dst, size_t src, size_t len) /* <=== audio_ring_dist */ \n{\n    return (dst >= src) ? (dst - src) : (len - src + dst);\n}\n\nType Definitions:\n- HWVoiceOut: typedef struct HWVoiceOut {\n    AudioState *s;\n    int enabled;\n    int poll_mode;\n    int pending_disable;\n    struct audio_pcm_info info;\n\n    f_sample *clip;\n    uint64_t ts_helper;\n\n    STSampleBuffer *mix_buf;\n    void *buf_emul;\n    size_t pos_emul, pending_emul, size_emul;\n\n    size_t samples;\n    QLIST_HEAD (sw_out_listhead, SWVoiceOut) sw_head;\n    QLIST_HEAD (sw_cap_listhead, SWVoiceCap) cap_head;\n    struct audio_pcm_ops *pcm_ops;\n    QLIST_ENTRY (HWVoiceOut) entries;\n}\n- OSSVoiceOut: typedef struct OSSVoiceOut {\n    HWVoiceOut hw;\n    int fd;\n    int nfrags;\n    int fragsize;\n    int mmapped;\n    Audiodev *dev;\n}\n- HWVoiceOut: typedef struct HWVoiceOut {\n    AudioState *s;\n    int enabled;\n    int poll_mode;\n    int pending_disable;\n    struct audio_pcm_info info;\n\n    f_sample *clip;\n    uint64_t ts_helper;\n\n    STSampleBuffer *mix_buf;\n    void *buf_emul;\n    size_t pos_emul, pending_emul, size_emul;\n\n    size_t samples;\n    QLIST_HEAD (sw_out_listhead, SWVoiceOut) sw_head;\n    QLIST_HEAD (sw_cap_listhead, SWVoiceCap) cap_head;\n    struct audio_pcm_ops *pcm_ops;\n    QLIST_ENTRY (HWVoiceOut) entries;\n} HWVoiceOut;\n\nImports:\n- #include \"qemu/osdep.h\"\n- #include \"audio.h\"\n- #include <sys/soundcard.h>\n- #include \"audio_int.h\"\n- #include \"qemu/module.h\"\n- #include \"qemu/main-loop.h\"\n- #include <sys/ioctl.h>\n- #include \"trace.h\"\n- #include \"qemu/host-utils.h\"",
    "commit_msg": "audio/oss: fix buffer pos calculation\n\nFixes: 3ba4066d085f (\"ossaudio: port to the new audio backend api\")\nReported-by: ziming zhang <ezrakiez@gmail.com>\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>\nMessage-Id: <20200120101804.29578-1-kraxel@redhat.com>\nReviewed-by: Philippe Mathieu-Daud <philmd@redhat.com>",
    "cve_desc": "oss_write in audio/ossaudio.c in QEMU before 5.0.0 mishandles a buffer position.",
    "year": 2020,
    "filename": "ossaudio.c",
    "commit_url": "\"https://github.com/bonzini/qemu/commit/7a4ede0047a8613b0e3b72c9d351038f013dd357\""
  },
  {
    "repository": "AXDOOMER/doom-vanille",
    "cve_id": "CVE-2020-15007",
    "cwe_list": [
      "CWE-120"
    ],
    "commit_hash": "8a6d9a02fa991a91ff90ccdc73b5ceabaa6cb9ec",
    "short_hash": "8a6d9a02",
    "vulnerableMethods_before": [
      {
        "filename": "m_misc.c",
        "method_name": "M_LoadDefaults",
        "raw_code": "void M_LoadDefaults (void) /* <=== M_LoadDefaults */ \n{\n    int\t\ti;\n    int\t\tlen;\n    FILE*\tf;\n    char\tdef[80];\n    char\tstrparm[100];\n    char*\tnewstring;\n    int\t\tparm;\n    boolean\tisstring;\n    \n    // set everything to base values\n    numdefaults = sizeof(defaults)/sizeof(defaults[0]);\n    for (i=0 ; i<numdefaults ; i++)\n\t*defaults[i].location = defaults[i].defaultvalue;\n    \n    // check for a custom default file\n    i = M_CheckParm (\"-config\");\n    if (i && i<myargc-1)\n    {\n\tdefaultfile = myargv[i+1];\n\tprintf (\"\tdefault file: %s\\n\",defaultfile);\n    }\n    else\n\tdefaultfile = basedefault;\n    \n    // read the file in, overriding any set defaults\n    f = fopen (defaultfile, \"r\");\n    if (f)\n    {\n\twhile (!feof(f))\n\t{\n\t    isstring = false;\n\t    if (fscanf (f, \"%79s %[^\\n]\\n\", def, strparm) == 2)\n\t    {\n\t\tif (strparm[0] == '\"')\n\t\t{\n\t\t    // get a string default\n\t\t    isstring = true;\n\t\t    len = strlen(strparm);\n\t\t    newstring = (char *) malloc(len);\n\t\t    strparm[len-1] = 0;\n\t\t    strcpy(newstring, strparm+1);\n\t\t}\n\t\telse if (strparm[0] == '0' && strparm[1] == 'x')\n\t\t    sscanf(strparm+2, \"%x\", &parm);\n\t\telse\n\t\t    sscanf(strparm, \"%i\", &parm);\n\t\tfor (i=0 ; i<numdefaults ; i++)\n\t\t    if (!strcmp(def, defaults[i].name))\n\t\t    {\n\t\t\tif (!isstring)\n\t\t\t    *defaults[i].location = parm;\n\t\t\telse\n\t\t\t    *defaults[i].location =\n\t\t\t\t(int) newstring;\n\t\t\tbreak;\n\t\t    }\n\t    }\n\t}\n\t\t\n\tfclose (f);\n    }\n\n    for (i = 0; i < numdefaults; i++)\n    {\n        if (defaults[i].scantranslate)\n        {\n            parm = *defaults[i].location;\n            defaults[i].untranslated = parm;\n            *defaults[i].location = scantokey[parm];\n        }\n    }\n}",
        "start_line": 449
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "m_misc.c",
        "method_name": "M_LoadDefaults",
        "raw_code": "void M_LoadDefaults (void) /* <=== M_LoadDefaults */ \n{\n    int\t\ti;\n    int\t\tlen;\n    FILE*\tf;\n    char\tdef[80];\n    char\tstrparm[100];\n    char*\tnewstring;\n    int\t\tparm;\n    boolean\tisstring;\n    \n    // set everything to base values\n    numdefaults = sizeof(defaults)/sizeof(defaults[0]);\n    for (i=0 ; i<numdefaults ; i++)\n\t*defaults[i].location = defaults[i].defaultvalue;\n    \n    // check for a custom default file\n    i = M_CheckParm (\"-config\");\n    if (i && i<myargc-1)\n    {\n\tdefaultfile = myargv[i+1];\n\tprintf (\"\tdefault file: %s\\n\",defaultfile);\n    }\n    else\n\tdefaultfile = basedefault;\n    \n    // read the file in, overriding any set defaults\n    f = fopen (defaultfile, \"r\");\n    if (f)\n    {\n\twhile (!feof(f))\n\t{\n\t    isstring = false;\n\t    if (fscanf (f, \"%79s %99[^\\n]\\n\", def, strparm) == 2)\n\t    {\n\t\tif (strparm[0] == '\"')\n\t\t{\n\t\t    // get a string default\n\t\t    isstring = true;\n\t\t    len = strlen(strparm);\n\t\t    newstring = (char *) malloc(len);\n\t\t    strparm[len-1] = 0;\n\t\t    strcpy(newstring, strparm+1);\n\t\t}\n\t\telse if (strparm[0] == '0' && strparm[1] == 'x')\n\t\t    sscanf(strparm+2, \"%x\", &parm);\n\t\telse\n\t\t    sscanf(strparm, \"%i\", &parm);\n\t\tfor (i=0 ; i<numdefaults ; i++)\n\t\t    if (!strcmp(def, defaults[i].name))\n\t\t    {\n\t\t\tif (!isstring)\n\t\t\t    *defaults[i].location = parm;\n\t\t\telse\n\t\t\t    *defaults[i].location =\n\t\t\t\t(int) newstring;\n\t\t\tbreak;\n\t\t    }\n\t    }\n\t}\n\t\t\n\tfclose (f);\n    }\n\n    for (i = 0; i < numdefaults; i++)\n    {\n        if (defaults[i].scantranslate)\n        {\n            parm = *defaults[i].location;\n            defaults[i].untranslated = parm;\n            *defaults[i].location = scantokey[parm];\n        }\n    }\n}",
        "start_line": 449
      }
    ],
    "code_context": "Called Methods:\n- M_CheckParm: int M_CheckParm (char *check) /* <=== M_CheckParm */ \n{\n    int\t\ti;\n\n    for (i = 1;i<myargc;i++)\n    {\n\tif ( !strcasecmp(check, myargv[i]) )\n\t    return i;\n    }\n\n    return 0;\n}\n\nGlobal Variables:\n- default_t[] defaults\n- extern byte[128] scantokey\n- char* defaultfile\n- int myargc\n- int numdefaults\n- char** myargv\n\nImports:\n- #include \"z_zone.h\"\n- #include \"m_misc.h\"\n- #include <stdlib.h>\n- #include \"v_video.h\"\n- #include <fcntl.h>\n- #include <ctype.h>\n- #include \"doomstat.h\"\n- #include \"doomdef.h\"\n- #include <sys/stat.h>\n- #include \"dstrings.h\"\n- #include \"i_system.h\"\n- #include \"hu_stuff.h\"\n- #include \"w_wad.h\"\n- #include <unistd.h>\n- #include <sys/types.h>",
    "commit_msg": "Fix buffer overflow in M_LoadDefaults\n\nToo much data will most likely result in a crash or freeze, but you can overwrite the stack which can be used to do an arbitrary code execution. (https://twitter.com/notrevenant/status/1268654123903340544)",
    "cve_desc": "[{'lang': 'en', 'value': 'A buffer overflow in the M_LoadDefaults function in m_misc.c in id Tech 1 (aka Doom engine) allows arbitrary code execution via an unsafe usage of fscanf, because it does not limit the number of characters to be read in a format argument.'}]",
    "year": 2020,
    "filename": "m_misc.c",
    "commit_url": "\"https://github.com/AXDOOMER/doom-vanille/commit/8a6d9a02fa991a91ff90ccdc73b5ceabaa6cb9ec\""
  },
  {
    "repository": "openvpn/openvpn",
    "cve_id": "CVE-2020-15078",
    "cwe_list": [
      "CWE-306,CWE-287"
    ],
    "commit_hash": "3aca477a1b58714754fea3a26d0892fffc51db6b",
    "short_hash": "3aca477a",
    "vulnerableMethods_before": [
      {
        "filename": "src/openvpn/auth_token.c",
        "method_name": "add_session_token_env",
        "raw_code": "void /* <=== add_session_token_env */ \nadd_session_token_env(struct tls_session *session, struct tls_multi *multi,\n                      const struct user_pass *up)\n{\n    if (!multi->opt.auth_token_generate)\n    {\n        return;\n    }\n\n\n    const char *state;\n\n    if (!is_auth_token(up->password))\n    {\n        state = \"Initial\";\n    }\n    else if (multi->auth_token_state_flags & AUTH_TOKEN_HMAC_OK)\n    {\n        switch (multi->auth_token_state_flags & (AUTH_TOKEN_VALID_EMPTYUSER|AUTH_TOKEN_EXPIRED))\n        {\n            case 0:\n                state = \"Authenticated\";\n                break;\n\n            case AUTH_TOKEN_EXPIRED:\n                state = \"Expired\";\n                break;\n\n            case AUTH_TOKEN_VALID_EMPTYUSER:\n                state = \"AuthenticatedEmptyUser\";\n                break;\n\n            case AUTH_TOKEN_VALID_EMPTYUSER | AUTH_TOKEN_EXPIRED:\n                state = \"ExpiredEmptyUser\";\n                break;\n\n            default:\n                /* Silence compiler warning, all four possible combinations are covered */\n                ASSERT(0);\n        }\n    }\n    else\n    {\n        state = \"Invalid\";\n    }\n\n    setenv_str(session->opt->es, \"session_state\", state);\n\n    /* We had a valid session id before */\n    const char *session_id_source;\n    if (multi->auth_token_state_flags & AUTH_TOKEN_HMAC_OK\n        &!(multi->auth_token_state_flags & AUTH_TOKEN_EXPIRED))\n    {\n        session_id_source = up->password;\n    }\n    else\n    {\n        /*\n         * No session before, generate a new session token for the new session\n         */\n        if (!multi->auth_token)\n        {\n            generate_auth_token(up, multi);\n        }\n        session_id_source = multi->auth_token;\n    }\n    /*\n     * In the auth-token the auth token is already base64 encoded\n     * and being a multiple of 4 ensure that it a multiple of bytes\n     * in the encoding\n     */\n\n    char session_id[AUTH_TOKEN_SESSION_ID_LEN*2] = {0};\n    memcpy(session_id, session_id_source + strlen(SESSION_ID_PREFIX),\n           AUTH_TOKEN_SESSION_ID_LEN*8/6);\n\n    setenv_str(session->opt->es, \"session_id\", session_id);\n}",
        "start_line": 51
      },
      {
        "filename": "src/openvpn/auth_token.c",
        "method_name": "generate_auth_token",
        "raw_code": "void /* <=== generate_auth_token */ \ngenerate_auth_token(const struct user_pass *up, struct tls_multi *multi)\n{\n    struct gc_arena gc = gc_new();\n\n    int64_t timestamp = htonll((uint64_t)now);\n    int64_t initial_timestamp = timestamp;\n\n    hmac_ctx_t *ctx = multi->opt.auth_token_key.hmac;\n    ASSERT(hmac_ctx_size(ctx) == 256/8);\n\n    uint8_t sessid[AUTH_TOKEN_SESSION_ID_LEN];\n\n    if (multi->auth_token)\n    {\n        /* Just enough space to fit 8 bytes+ 1 extra to decode a non padded\n         * base64 string (multiple of 3 bytes). 9 bytes => 12 bytes base64\n         * bytes\n         */\n        char old_tstamp_decode[9];\n\n        /*\n         * reuse the same session id and timestamp and null terminate it at\n         * for base64 decode it only decodes the session id part of it\n         */\n        char *old_sessid = multi->auth_token + strlen(SESSION_ID_PREFIX);\n        char *old_tsamp_initial = old_sessid + AUTH_TOKEN_SESSION_ID_LEN*8/6;\n\n        old_tsamp_initial[12] = '\\0';\n        ASSERT(openvpn_base64_decode(old_tsamp_initial, old_tstamp_decode, 9) == 9);\n\n        /*\n         * Avoid old gcc (4.8.x) complaining about strict aliasing\n         * by using a temporary variable instead of doing it in one\n         * line\n         */\n        uint64_t *tstamp_ptr = (uint64_t *) old_tstamp_decode;\n        initial_timestamp = *tstamp_ptr;\n\n        old_tsamp_initial[0] = '\\0';\n        ASSERT(openvpn_base64_decode(old_sessid, sessid, AUTH_TOKEN_SESSION_ID_LEN)==AUTH_TOKEN_SESSION_ID_LEN);\n\n\n        /* free the auth-token, we will replace it with a new one */\n        free(multi->auth_token);\n    }\n    else if (!rand_bytes(sessid, AUTH_TOKEN_SESSION_ID_LEN))\n    {\n        msg( M_FATAL, \"Failed to get enough randomness for \"\n             \"authentication token\");\n    }\n\n    /* Calculate the HMAC */\n    /* We enforce up->username to be \\0 terminated in ssl.c.. Allowing username\n     * with \\0 in them is asking for troubles in so many ways anyway that we\n     * ignore that corner case here\n     */\n    uint8_t hmac_output[256/8];\n\n    hmac_ctx_reset(ctx);\n\n    /*\n     * If the token was only valid for the empty user, also generate\n     * a new token with the empty username since we do not want to loose\n     * the information that the username cannot be trusted\n     */\n    if (multi->auth_token_state_flags & AUTH_TOKEN_VALID_EMPTYUSER)\n    {\n        hmac_ctx_update(ctx, (const uint8_t *) \"\", 0);\n    }\n    else\n    {\n        hmac_ctx_update(ctx, (uint8_t *) up->username, (int) strlen(up->username));\n    }\n    hmac_ctx_update(ctx, sessid, AUTH_TOKEN_SESSION_ID_LEN);\n    hmac_ctx_update(ctx, (uint8_t *) &initial_timestamp, sizeof(initial_timestamp));\n    hmac_ctx_update(ctx, (uint8_t *) &timestamp, sizeof(timestamp));\n    hmac_ctx_final(ctx, hmac_output);\n\n    /* Construct the unencoded session token */\n    struct buffer token = alloc_buf_gc(\n        2*sizeof(uint64_t) + AUTH_TOKEN_SESSION_ID_LEN + 256/8, &gc);\n\n    ASSERT(buf_write(&token, sessid, sizeof(sessid)));\n    ASSERT(buf_write(&token, &initial_timestamp, sizeof(initial_timestamp)));\n    ASSERT(buf_write(&token, &timestamp, sizeof(timestamp)));\n    ASSERT(buf_write(&token, hmac_output, sizeof(hmac_output)));\n\n    char *b64output;\n    openvpn_base64_encode(BPTR(&token), BLEN(&token), &b64output);\n\n    struct buffer session_token = alloc_buf_gc(\n        strlen(SESSION_ID_PREFIX) + strlen(b64output) + 1, &gc);\n\n    ASSERT(buf_write(&session_token, SESSION_ID_PREFIX, strlen(SESSION_ID_PREFIX)));\n    ASSERT(buf_write(&session_token, b64output, (int)strlen(b64output)));\n    ASSERT(buf_write_u8(&session_token, 0));\n\n    free(b64output);\n\n    multi->auth_token = strdup((char *)BPTR(&session_token));\n\n    dmsg(D_SHOW_KEYS, \"Generated token for client: %s (%s)\",\n         multi->auth_token, up->username);\n\n    gc_free(&gc);\n}",
        "start_line": 173
      },
      {
        "filename": "src/openvpn/ssl_verify.c",
        "method_name": "verify_user_pass",
        "raw_code": "void /* <=== verify_user_pass */ \nverify_user_pass(struct user_pass *up, struct tls_multi *multi,\n                 struct tls_session *session)\n{\n    int s1 = OPENVPN_PLUGIN_FUNC_SUCCESS;\n    bool s2 = true;\n    struct key_state *ks = &session->key[KS_PRIMARY];      /* primary key */\n\n#ifdef MANAGEMENT_DEF_AUTH\n    int man_def_auth = KMDA_UNDEF;\n\n    if (management_enable_def_auth(management))\n    {\n        man_def_auth = KMDA_DEF;\n    }\n#endif\n\n    /* enforce character class restrictions in username/password */\n    string_mod_remap_name(up->username);\n    string_mod(up->password, CC_PRINT, CC_CRLF, '_');\n\n    /*\n     * If auth token succeeds we skip the auth\n     * methods unless otherwise specified\n     */\n    bool skip_auth = false;\n\n    /*\n     * If server is configured with --auth-gen-token and the client sends\n     * something that looks like an authentication token, this\n     * round will be done internally using the token instead of\n     * calling any external authentication modules.\n     */\n    if (session->opt->auth_token_generate && is_auth_token(up->password))\n    {\n        multi->auth_token_state_flags = verify_auth_token(up, multi, session);\n        if (session->opt->auth_token_call_auth)\n        {\n            /*\n             * we do not care about the result here because it is\n             * the responsibility of the external authentication to\n             * decide what to do with the result\n             */\n        }\n        else if (multi->auth_token_state_flags == AUTH_TOKEN_HMAC_OK)\n        {\n            /*\n             * We do not want the EXPIRED or EMPTY USER flags here so check\n             * for equality with AUTH_TOKEN_HMAC_OK\n             */\n            msg(M_WARN, \"TLS: Username/auth-token authentication \"\n                \"succeeded for username '%s'\",\n                up->username);\n            skip_auth = true;\n        }\n        else\n        {\n            wipe_auth_token(multi);\n            ks->authenticated = KS_AUTH_FALSE;\n            msg(M_WARN, \"TLS: Username/auth-token authentication \"\n                \"failed for username '%s'\", up->username);\n            return;\n        }\n    }\n\n    /* Set the environment variables used by all auth variants */\n    if (!set_verify_user_pass_env(up, multi, session))\n    {\n        skip_auth = true;\n        s1 = OPENVPN_PLUGIN_FUNC_ERROR;\n    }\n\n    /* call plugin(s) and/or script */\n    if (!skip_auth)\n    {\n#ifdef MANAGEMENT_DEF_AUTH\n        if (man_def_auth==KMDA_DEF)\n        {\n            man_def_auth = verify_user_pass_management(session, multi, up);\n        }\n#endif\n        if (plugin_defined(session->opt->plugins, OPENVPN_PLUGIN_AUTH_USER_PASS_VERIFY))\n        {\n            s1 = verify_user_pass_plugin(session, multi, up);\n        }\n\n        if (session->opt->auth_user_pass_verify_script)\n        {\n            s2 = verify_user_pass_script(session, multi, up);\n        }\n    }\n\n    /* check sizing of username if it will become our common name */\n    if ((session->opt->ssl_flags & SSLF_USERNAME_AS_COMMON_NAME)\n        && strlen(up->username)>TLS_USERNAME_LEN)\n    {\n        msg(D_TLS_ERRORS,\n            \"TLS Auth Error: --username-as-common name specified and username is longer than the maximum permitted Common Name length of %d characters\",\n            TLS_USERNAME_LEN);\n        s1 = OPENVPN_PLUGIN_FUNC_ERROR;\n    }\n    /* auth succeeded? */\n    if ((s1 == OPENVPN_PLUGIN_FUNC_SUCCESS\n#ifdef PLUGIN_DEF_AUTH\n         || s1 == OPENVPN_PLUGIN_FUNC_DEFERRED\n#endif\n         ) && s2\n#ifdef MANAGEMENT_DEF_AUTH\n        && man_def_auth != KMDA_ERROR\n#endif\n        && tls_lock_username(multi, up->username))\n    {\n        ks->authenticated = KS_AUTH_TRUE;\n#ifdef PLUGIN_DEF_AUTH\n        if (s1 == OPENVPN_PLUGIN_FUNC_DEFERRED)\n        {\n            ks->authenticated = KS_AUTH_DEFERRED;\n        }\n#endif\n#ifdef MANAGEMENT_DEF_AUTH\n        if (man_def_auth != KMDA_UNDEF)\n        {\n            ks->authenticated = KS_AUTH_DEFERRED;\n        }\n#endif\n        if ((session->opt->ssl_flags & SSLF_USERNAME_AS_COMMON_NAME))\n        {\n            set_common_name(session, up->username);\n        }\n\n        if ((session->opt->auth_token_generate))\n        {\n            /*\n             * If we accepted a (not expired) token, i.e.\n             * initial auth via token on new connection, we need\n             * to store the auth-token in multi->auth_token, so\n             * the initial timestamp and session id can be extracted from it\n             */\n            if (!multi->auth_token\n                && (multi->auth_token_state_flags & AUTH_TOKEN_HMAC_OK)\n                && !(multi->auth_token_state_flags & AUTH_TOKEN_EXPIRED))\n            {\n                multi->auth_token = strdup(up->password);\n            }\n\n            /*\n             * Server is configured with --auth-gen-token. Generate or renew\n             * the token.\n             */\n            generate_auth_token(up, multi);\n        }\n        /*\n         * Auth token already sent to client, update auth-token on client.\n         * The initial auth-token is sent as part of the push message, for this\n         * update we need to schedule an extra push message.\n         *\n         * Otherwise the auth-token get pushed out as part of the \"normal\"\n         * push-reply\n         */\n        if (multi->auth_token_initial)\n        {\n            /*\n             * We do not explicitly schedule the sending of the\n             * control message here but control message are only\n             * postponed when the control channel  is not yet fully\n             * established and furthermore since this is called in\n             * the middle of authentication, there are other messages\n             * (new data channel keys) that are sent anyway and will\n             * trigger schedueling\n             */\n            send_push_reply_auth_token(multi);\n        }\n        msg(D_HANDSHAKE, \"TLS: Username/Password authentication %s for username '%s' %s\",\n            (ks->authenticated == KS_AUTH_DEFERRED) ? \"deferred\" : \"succeeded\",\n            up->username,\n            (session->opt->ssl_flags & SSLF_USERNAME_AS_COMMON_NAME) ? \"[CN SET]\" : \"\");\n    }\n    else\n    {\n        ks->authenticated = KS_AUTH_FALSE;\n        msg(D_TLS_ERRORS, \"TLS Auth Error: Auth Username/Password verification failed for peer\");\n    }\n}",
        "start_line": 1237
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "src/openvpn/auth_token.c",
        "method_name": "add_session_token_env",
        "raw_code": "void /* <=== add_session_token_env */ \nadd_session_token_env(struct tls_session *session, struct tls_multi *multi,\n                      const struct user_pass *up)\n{\n    if (!multi->opt.auth_token_generate)\n    {\n        return;\n    }\n\n    int auth_token_state_flags = session->key[KS_PRIMARY].auth_token_state_flags;\n\n    const char *state;\n\n    if (!is_auth_token(up->password))\n    {\n        state = \"Initial\";\n    }\n    else if (auth_token_state_flags & AUTH_TOKEN_HMAC_OK)\n    {\n        switch (auth_token_state_flags & (AUTH_TOKEN_VALID_EMPTYUSER|AUTH_TOKEN_EXPIRED))\n        {\n            case 0:\n                state = \"Authenticated\";\n                break;\n\n            case AUTH_TOKEN_EXPIRED:\n                state = \"Expired\";\n                break;\n\n            case AUTH_TOKEN_VALID_EMPTYUSER:\n                state = \"AuthenticatedEmptyUser\";\n                break;\n\n            case AUTH_TOKEN_VALID_EMPTYUSER | AUTH_TOKEN_EXPIRED:\n                state = \"ExpiredEmptyUser\";\n                break;\n\n            default:\n                /* Silence compiler warning, all four possible combinations are covered */\n                ASSERT(0);\n        }\n    }\n    else\n    {\n        state = \"Invalid\";\n    }\n\n    setenv_str(session->opt->es, \"session_state\", state);\n\n    /* We had a valid session id before */\n    const char *session_id_source;\n    if (auth_token_state_flags & AUTH_TOKEN_HMAC_OK\n        && !(auth_token_state_flags & AUTH_TOKEN_EXPIRED))\n    {\n        session_id_source = up->password;\n    }\n    else\n    {\n        /*\n         * No session before, generate a new session token for the new session\n         */\n        if (!multi->auth_token)\n        {\n            generate_auth_token(up, multi);\n        }\n        session_id_source = multi->auth_token;\n    }\n    /*\n     * In the auth-token the auth token is already base64 encoded\n     * and being a multiple of 4 ensure that it a multiple of bytes\n     * in the encoding\n     */\n\n    char session_id[AUTH_TOKEN_SESSION_ID_LEN*2] = {0};\n    memcpy(session_id, session_id_source + strlen(SESSION_ID_PREFIX),\n           AUTH_TOKEN_SESSION_ID_LEN*8/6);\n\n    setenv_str(session->opt->es, \"session_id\", session_id);\n}",
        "start_line": 51
      },
      {
        "filename": "src/openvpn/auth_token.c",
        "method_name": "generate_auth_token",
        "raw_code": "void /* <=== generate_auth_token */ \ngenerate_auth_token(const struct user_pass *up, struct tls_multi *multi)\n{\n    struct gc_arena gc = gc_new();\n\n    int64_t timestamp = htonll((uint64_t)now);\n    int64_t initial_timestamp = timestamp;\n\n    hmac_ctx_t *ctx = multi->opt.auth_token_key.hmac;\n    ASSERT(hmac_ctx_size(ctx) == 256/8);\n\n    uint8_t sessid[AUTH_TOKEN_SESSION_ID_LEN];\n\n    if (multi->auth_token)\n    {\n        /* Just enough space to fit 8 bytes+ 1 extra to decode a non padded\n         * base64 string (multiple of 3 bytes). 9 bytes => 12 bytes base64\n         * bytes\n         */\n        char old_tstamp_decode[9];\n\n        /*\n         * reuse the same session id and timestamp and null terminate it at\n         * for base64 decode it only decodes the session id part of it\n         */\n        char *old_sessid = multi->auth_token + strlen(SESSION_ID_PREFIX);\n        char *old_tsamp_initial = old_sessid + AUTH_TOKEN_SESSION_ID_LEN*8/6;\n\n        old_tsamp_initial[12] = '\\0';\n        ASSERT(openvpn_base64_decode(old_tsamp_initial, old_tstamp_decode, 9) == 9);\n\n        /*\n         * Avoid old gcc (4.8.x) complaining about strict aliasing\n         * by using a temporary variable instead of doing it in one\n         * line\n         */\n        uint64_t *tstamp_ptr = (uint64_t *) old_tstamp_decode;\n        initial_timestamp = *tstamp_ptr;\n\n        old_tsamp_initial[0] = '\\0';\n        ASSERT(openvpn_base64_decode(old_sessid, sessid, AUTH_TOKEN_SESSION_ID_LEN)==AUTH_TOKEN_SESSION_ID_LEN);\n\n\n        /* free the auth-token, we will replace it with a new one */\n        free(multi->auth_token);\n    }\n    else if (!rand_bytes(sessid, AUTH_TOKEN_SESSION_ID_LEN))\n    {\n        msg( M_FATAL, \"Failed to get enough randomness for \"\n             \"authentication token\");\n    }\n\n    /* Calculate the HMAC */\n    /* We enforce up->username to be \\0 terminated in ssl.c.. Allowing username\n     * with \\0 in them is asking for troubles in so many ways anyway that we\n     * ignore that corner case here\n     */\n    uint8_t hmac_output[256/8];\n\n    hmac_ctx_reset(ctx);\n\n    /*\n     * If the token was only valid for the empty user, also generate\n     * a new token with the empty username since we do not want to loose\n     * the information that the username cannot be trusted\n     */\n    struct key_state *ks = &multi->session[TM_ACTIVE].key[KS_PRIMARY];\n    if (ks->auth_token_state_flags & AUTH_TOKEN_VALID_EMPTYUSER)\n    {\n        hmac_ctx_update(ctx, (const uint8_t *) \"\", 0);\n    }\n    else\n    {\n        hmac_ctx_update(ctx, (uint8_t *) up->username, (int) strlen(up->username));\n    }\n    hmac_ctx_update(ctx, sessid, AUTH_TOKEN_SESSION_ID_LEN);\n    hmac_ctx_update(ctx, (uint8_t *) &initial_timestamp, sizeof(initial_timestamp));\n    hmac_ctx_update(ctx, (uint8_t *) &timestamp, sizeof(timestamp));\n    hmac_ctx_final(ctx, hmac_output);\n\n    /* Construct the unencoded session token */\n    struct buffer token = alloc_buf_gc(\n        2*sizeof(uint64_t) + AUTH_TOKEN_SESSION_ID_LEN + 256/8, &gc);\n\n    ASSERT(buf_write(&token, sessid, sizeof(sessid)));\n    ASSERT(buf_write(&token, &initial_timestamp, sizeof(initial_timestamp)));\n    ASSERT(buf_write(&token, &timestamp, sizeof(timestamp)));\n    ASSERT(buf_write(&token, hmac_output, sizeof(hmac_output)));\n\n    char *b64output;\n    openvpn_base64_encode(BPTR(&token), BLEN(&token), &b64output);\n\n    struct buffer session_token = alloc_buf_gc(\n        strlen(SESSION_ID_PREFIX) + strlen(b64output) + 1, &gc);\n\n    ASSERT(buf_write(&session_token, SESSION_ID_PREFIX, strlen(SESSION_ID_PREFIX)));\n    ASSERT(buf_write(&session_token, b64output, (int)strlen(b64output)));\n    ASSERT(buf_write_u8(&session_token, 0));\n\n    free(b64output);\n\n    multi->auth_token = strdup((char *)BPTR(&session_token));\n\n    dmsg(D_SHOW_KEYS, \"Generated token for client: %s (%s)\",\n         multi->auth_token, up->username);\n\n    gc_free(&gc);\n}",
        "start_line": 174
      },
      {
        "filename": "src/openvpn/ssl_verify.c",
        "method_name": "verify_user_pass",
        "raw_code": "void /* <=== verify_user_pass */ \nverify_user_pass(struct user_pass *up, struct tls_multi *multi,\n                 struct tls_session *session)\n{\n    int s1 = OPENVPN_PLUGIN_FUNC_SUCCESS;\n    bool s2 = true;\n    struct key_state *ks = &session->key[KS_PRIMARY];      /* primary key */\n\n#ifdef MANAGEMENT_DEF_AUTH\n    int man_def_auth = KMDA_UNDEF;\n\n    if (management_enable_def_auth(management))\n    {\n        man_def_auth = KMDA_DEF;\n    }\n#endif\n\n    /* enforce character class restrictions in username/password */\n    string_mod_remap_name(up->username);\n    string_mod(up->password, CC_PRINT, CC_CRLF, '_');\n\n    /*\n     * If auth token succeeds we skip the auth\n     * methods unless otherwise specified\n     */\n    bool skip_auth = false;\n\n    /*\n     * If server is configured with --auth-gen-token and the client sends\n     * something that looks like an authentication token, this\n     * round will be done internally using the token instead of\n     * calling any external authentication modules.\n     */\n    if (session->opt->auth_token_generate && is_auth_token(up->password))\n    {\n        ks->auth_token_state_flags = verify_auth_token(up, multi, session);\n        if (session->opt->auth_token_call_auth)\n        {\n            /*\n             * we do not care about the result here because it is\n             * the responsibility of the external authentication to\n             * decide what to do with the result\n             */\n        }\n        else if (ks->auth_token_state_flags == AUTH_TOKEN_HMAC_OK)\n        {\n            /*\n             * We do not want the EXPIRED or EMPTY USER flags here so check\n             * for equality with AUTH_TOKEN_HMAC_OK\n             */\n            msg(M_WARN, \"TLS: Username/auth-token authentication \"\n                \"succeeded for username '%s'\",\n                up->username);\n            skip_auth = true;\n        }\n        else\n        {\n            wipe_auth_token(multi);\n            ks->authenticated = KS_AUTH_FALSE;\n            msg(M_WARN, \"TLS: Username/auth-token authentication \"\n                \"failed for username '%s'\", up->username);\n            return;\n        }\n    }\n\n    /* Set the environment variables used by all auth variants */\n    if (!set_verify_user_pass_env(up, multi, session))\n    {\n        skip_auth = true;\n        s1 = OPENVPN_PLUGIN_FUNC_ERROR;\n    }\n\n    /* call plugin(s) and/or script */\n    if (!skip_auth)\n    {\n#ifdef MANAGEMENT_DEF_AUTH\n        if (man_def_auth==KMDA_DEF)\n        {\n            man_def_auth = verify_user_pass_management(session, multi, up);\n        }\n#endif\n        if (plugin_defined(session->opt->plugins, OPENVPN_PLUGIN_AUTH_USER_PASS_VERIFY))\n        {\n            s1 = verify_user_pass_plugin(session, multi, up);\n        }\n\n        if (session->opt->auth_user_pass_verify_script)\n        {\n            s2 = verify_user_pass_script(session, multi, up);\n        }\n    }\n\n    /* check sizing of username if it will become our common name */\n    if ((session->opt->ssl_flags & SSLF_USERNAME_AS_COMMON_NAME)\n        && strlen(up->username)>TLS_USERNAME_LEN)\n    {\n        msg(D_TLS_ERRORS,\n            \"TLS Auth Error: --username-as-common name specified and username is longer than the maximum permitted Common Name length of %d characters\",\n            TLS_USERNAME_LEN);\n        s1 = OPENVPN_PLUGIN_FUNC_ERROR;\n    }\n    /* auth succeeded? */\n    if ((s1 == OPENVPN_PLUGIN_FUNC_SUCCESS\n#ifdef PLUGIN_DEF_AUTH\n         || s1 == OPENVPN_PLUGIN_FUNC_DEFERRED\n#endif\n         ) && s2\n#ifdef MANAGEMENT_DEF_AUTH\n        && man_def_auth != KMDA_ERROR\n#endif\n        && tls_lock_username(multi, up->username))\n    {\n        ks->authenticated = KS_AUTH_TRUE;\n#ifdef PLUGIN_DEF_AUTH\n        if (s1 == OPENVPN_PLUGIN_FUNC_DEFERRED)\n        {\n            ks->authenticated = KS_AUTH_DEFERRED;\n        }\n#endif\n#ifdef MANAGEMENT_DEF_AUTH\n        if (man_def_auth != KMDA_UNDEF)\n        {\n            ks->authenticated = KS_AUTH_DEFERRED;\n        }\n#endif\n        if ((session->opt->ssl_flags & SSLF_USERNAME_AS_COMMON_NAME))\n        {\n            set_common_name(session, up->username);\n        }\n\n        if ((session->opt->auth_token_generate))\n        {\n            /*\n             * If we accepted a (not expired) token, i.e.\n             * initial auth via token on new connection, we need\n             * to store the auth-token in multi->auth_token, so\n             * the initial timestamp and session id can be extracted from it\n             */\n            if (!multi->auth_token\n                && (ks->auth_token_state_flags & AUTH_TOKEN_HMAC_OK)\n                && !(ks->auth_token_state_flags & AUTH_TOKEN_EXPIRED))\n            {\n                multi->auth_token = strdup(up->password);\n            }\n\n            /*\n             * Server is configured with --auth-gen-token. Generate or renew\n             * the token.\n             */\n            generate_auth_token(up, multi);\n        }\n        /*\n         * Auth token already sent to client, update auth-token on client.\n         * The initial auth-token is sent as part of the push message, for this\n         * update we need to schedule an extra push message.\n         *\n         * Otherwise the auth-token get pushed out as part of the \"normal\"\n         * push-reply\n         */\n        if (multi->auth_token_initial)\n        {\n            /*\n             * We do not explicitly schedule the sending of the\n             * control message here but control message are only\n             * postponed when the control channel  is not yet fully\n             * established and furthermore since this is called in\n             * the middle of authentication, there are other messages\n             * (new data channel keys) that are sent anyway and will\n             * trigger schedueling\n             */\n            send_push_reply_auth_token(multi);\n        }\n        msg(D_HANDSHAKE, \"TLS: Username/Password authentication %s for username '%s' %s\",\n            (ks->authenticated == KS_AUTH_DEFERRED) ? \"deferred\" : \"succeeded\",\n            up->username,\n            (session->opt->ssl_flags & SSLF_USERNAME_AS_COMMON_NAME) ? \"[CN SET]\" : \"\");\n    }\n    else\n    {\n        ks->authenticated = KS_AUTH_FALSE;\n        msg(D_TLS_ERRORS, \"TLS Auth Error: Auth Username/Password verification failed for peer\");\n    }\n}",
        "start_line": 1237
      }
    ],
    "code_context": "Called Methods:\n- M_INFO: #define M_INFO               LOGLEV(1, 0, 0)         /* default informational messages */ /* <=== src/openvpn/errlevel.h:55:55:M_INFO:0 */ \n- AUTH_TOKEN_HMAC_OK: #define  AUTH_TOKEN_HMAC_OK              (1<<0) /* <=== src/openvpn/ssl_common.h:575:575:AUTH_TOKEN_HMAC_OK:0 */ \n- AUTH_TOKEN_HMAC_OK: #define  AUTH_TOKEN_HMAC_OK              (1<<0) /* <=== src/openvpn/ssl_common.h:573:573:AUTH_TOKEN_HMAC_OK:0 */ \n- gc_free: static inline void /* <=== gc_free */ \ngc_free(struct gc_arena *a)\n{\n    if (a->list)\n    {\n        x_gc_free(a);\n    }\n    if (a->list_special)\n    {\n        x_gc_freespecial(a);\n    }\n}\n- x_msg: void x_msg(const unsigned int flags, const char *format, ...);     /* should be called via msg above */ /* <=== x_msg */ \n- msg: #define msg x_msg /* <=== src/openvpn/error.h:173:173:msg:0 */ \n- AUTH_TOKEN_VALID_EMPTYUSER: #define  AUTH_TOKEN_VALID_EMPTYUSER      (1<<2) /* <=== src/openvpn/ssl_common.h:579:579:AUTH_TOKEN_VALID_EMPTYUSER:0 */ \n- SESSION_ID_PREFIX: #define SESSION_ID_PREFIX \"SESS_ID_AT_\" /* <=== src/openvpn/auth_token.h:115:115:SESSION_ID_PREFIX:0 */ \n- BPTR: #define BPTR(buf)  (buf_bptr(buf)) /* <=== src/openvpn/buffer.h:124:124:BPTR:1 */ \n- gc_new: static inline struct gc_arena /* <=== gc_new */ \ngc_new(void)\n{\n    struct gc_arena ret;\n    gc_init(&ret);\n    return ret;\n}\n- verify_user_pass_plugin: static int /* <=== verify_user_pass_plugin */ \nverify_user_pass_plugin(struct tls_session *session, struct tls_multi *multi,\n                        const struct user_pass *up)\n{\n    int retval = OPENVPN_PLUGIN_FUNC_ERROR;\n#ifdef PLUGIN_DEF_AUTH\n    struct key_state *ks = &session->key[KS_PRIMARY];      /* primary key */\n#endif\n\n    /* set password in private env space */\n    setenv_str(session->opt->es, \"password\", up->password);\n\n#ifdef PLUGIN_DEF_AUTH\n    /* generate filename for deferred auth control file */\n    if (!key_state_gen_auth_control_file(ks, session->opt))\n    {\n        msg(D_TLS_ERRORS, \"TLS Auth Error (%s): \"\n            \"could not create deferred auth control file\", __func__);\n        return retval;\n    }\n#endif\n\n    /* call command */\n    retval = plugin_call(session->opt->plugins, OPENVPN_PLUGIN_AUTH_USER_PASS_VERIFY, NULL, NULL, session->opt->es);\n\n#ifdef PLUGIN_DEF_AUTH\n    /* purge auth control filename (and file itself) for non-deferred returns */\n    if (retval != OPENVPN_PLUGIN_FUNC_DEFERRED)\n    {\n        key_state_rm_auth_control_file(ks);\n    }\n#endif\n\n    setenv_del(session->opt->es, \"password\");\n\n    return retval;\n}\n- wipe_auth_token: void /* <=== wipe_auth_token */ \nwipe_auth_token(struct tls_multi *multi)\n{\n    if (multi)\n    {\n        if (multi->auth_token)\n        {\n            secure_memzero(multi->auth_token, strlen(multi->auth_token));\n            free(multi->auth_token);\n        }\n        if (multi->auth_token_initial)\n        {\n            secure_memzero(multi->auth_token_initial,\n                           strlen(multi->auth_token_initial));\n            free(multi->auth_token_initial);\n        }\n        multi->auth_token = NULL;\n        multi->auth_token_initial = NULL;\n    }\n}\n- BLEN: #define BLEN(buf)  (buf_len(buf)) /* <=== src/openvpn/buffer.h:127:127:BLEN:1 */ \n- AUTH_TOKEN_VALID_EMPTYUSER: #define  AUTH_TOKEN_VALID_EMPTYUSER      (1<<2) /* <=== src/openvpn/ssl_common.h:577:577:AUTH_TOKEN_VALID_EMPTYUSER:0 */ \n- verify_auth_token: unsigned int /* <=== verify_auth_token */ \nverify_auth_token(struct user_pass *up, struct tls_multi *multi,\n                  struct tls_session *session)\n{\n    /*\n     * Base64 is <= input and input is < USER_PASS_LEN, so using USER_PASS_LEN\n     * is safe here but a bit overkill\n     */\n    uint8_t b64decoded[USER_PASS_LEN];\n    int decoded_len = openvpn_base64_decode(up->password + strlen(SESSION_ID_PREFIX),\n                                            b64decoded, USER_PASS_LEN);\n\n    /*\n     * Ensure that the decoded data is the size of the\n     * timestamp + hmac + session id\n     */\n    if (decoded_len != TOKEN_DATA_LEN)\n    {\n        msg(M_WARN, \"ERROR: --auth-token wrong size (%d!=%d)\",\n            decoded_len, (int) TOKEN_DATA_LEN);\n        return 0;\n    }\n\n    unsigned int ret = 0;\n\n    const uint8_t *sessid = b64decoded;\n    const uint8_t *tstamp_initial = sessid + AUTH_TOKEN_SESSION_ID_LEN;\n    const uint8_t *tstamp = tstamp_initial + sizeof(int64_t);\n\n    uint64_t timestamp = ntohll(*((uint64_t *) (tstamp)));\n    uint64_t timestamp_initial = ntohll(*((uint64_t *) (tstamp_initial)));\n\n    hmac_ctx_t *ctx = multi->opt.auth_token_key.hmac;\n    if (check_hmac_token(ctx, b64decoded, up->username))\n    {\n        ret |= AUTH_TOKEN_HMAC_OK;\n    }\n    else if (check_hmac_token(ctx, b64decoded, \"\"))\n    {\n        ret |= AUTH_TOKEN_HMAC_OK;\n        ret |= AUTH_TOKEN_VALID_EMPTYUSER;\n        /* overwrite the username of the client with the empty one */\n        strcpy(up->username, \"\");\n    }\n    else\n    {\n        msg(M_WARN, \"--auth-token-gen: HMAC on token from client failed (%s)\",\n            up->username);\n        return 0;\n    }\n\n    /* Accept session tokens that not expired are in the acceptable range\n     * for renogiations */\n    bool in_renog_time = now >= timestamp\n                         && now < timestamp + 2 * session->opt->renegotiate_seconds;\n\n    /* We could still have a client that does not update\n     * its auth-token, so also allow the initial auth-token */\n    bool initialtoken = multi->auth_token_initial\n                        && memcmp_constant_time(up->password, multi->auth_token_initial,\n                                                strlen(multi->auth_token_initial)) == 0;\n\n    if (!in_renog_time && !initialtoken)\n    {\n        ret |= AUTH_TOKEN_EXPIRED;\n    }\n\n    /* Sanity check the initial timestamp */\n    if (timestamp < timestamp_initial)\n    {\n        msg(M_WARN, \"Initial timestamp (%\" PRIu64 \" in token from client earlier than \"\n            \"current timestamp %\" PRIu64 \". Broken/unsynchronised clock?\",\n            timestamp_initial, timestamp);\n        ret |= AUTH_TOKEN_EXPIRED;\n    }\n\n    if (multi->opt.auth_token_lifetime\n        && now > timestamp_initial + multi->opt.auth_token_lifetime)\n    {\n        ret |= AUTH_TOKEN_EXPIRED;\n    }\n\n    if (ret & AUTH_TOKEN_EXPIRED)\n    {\n        /* Tell client that the session token is expired */\n        auth_set_client_reason(multi, \"SESSION: token expired\");\n        msg(M_INFO, \"--auth-token-gen: auth-token from client expired\");\n    }\n    return ret;\n}\n- M_FATAL: #define M_FATAL           (1<<4)         /* exit program */ /* <=== src/openvpn/error.h:94:94:M_FATAL:0 */ \n- SSLF_AUTH_USER_PASS_OPTIONAL: #define SSLF_AUTH_USER_PASS_OPTIONAL  (1<<3) /* <=== src/openvpn/ssl_common.h:345:345:SSLF_AUTH_USER_PASS_OPTIONAL:0 */ \n- AUTH_TOKEN_EXPIRED: #define  AUTH_TOKEN_EXPIRED              (1<<1) /* <=== src/openvpn/ssl_common.h:575:575:AUTH_TOKEN_EXPIRED:0 */ \n- KS_PRIMARY: #define KS_PRIMARY    0         /**< Primary %key state index. */ /* <=== src/openvpn/ssl_common.h:381:381:KS_PRIMARY:0 */ \n- assert_failed: void assert_failed(const char *filename, int line, const char *condition) /* <=== assert_failed */ \n- AUTH_TOKEN_SESSION_ID_LEN: #define AUTH_TOKEN_SESSION_ID_LEN 12 /* <=== src/openvpn/auth_token.c:23:23:AUTH_TOKEN_SESSION_ID_LEN:0 */ \n- SSLF_AUTH_USER_PASS_OPTIONAL: #define SSLF_AUTH_USER_PASS_OPTIONAL  (1<<3) /* <=== src/openvpn/ssl_common.h:343:343:SSLF_AUTH_USER_PASS_OPTIONAL:0 */ \n- alloc_buf_gc: struct buffer /* <=== alloc_buf_gc */ \n#ifdef DMALLOC\nalloc_buf_gc_debug(size_t size, struct gc_arena *gc, const char *file, int line)\n#else\nalloc_buf_gc(size_t size, struct gc_arena *gc)\n#endif\n{\n    struct buffer buf;\n    if (!buf_size_valid(size))\n    {\n        buf_size_error(size);\n    }\n    buf.capacity = (int)size;\n    buf.offset = 0;\n    buf.len = 0;\n#ifdef DMALLOC\n    buf.data = (uint8_t *) gc_malloc_debug(size, false, gc, file, line);\n#else\n    buf.data = (uint8_t *) gc_malloc(size, false, gc);\n#endif\n    if (size)\n    {\n        *buf.data = 0;\n    }\n    return buf;\n}\n- buf_write: static inline bool /* <=== buf_write */ \nbuf_write(struct buffer *dest, const void *src, int size)\n{\n    uint8_t *cp = buf_write_alloc(dest, size);\n    if (!cp)\n    {\n        return false;\n    }\n    memcpy(cp, src, size);\n    return true;\n}\n- buf_len: static int /* <=== buf_len */ \nbuf_len(const struct buffer *buf)\n{\n    if (buf_valid(buf))\n    {\n        return buf->len;\n    }\n    else\n    {\n        return 0;\n    }\n}\n- ASSERT: #define ASSERT(x) do { if (!(x)) {assert_failed(__FILE__, __LINE__, #x);}} while (false) /* <=== src/openvpn/error.h:221:221:ASSERT:1 */ \n- AUTH_TOKEN_EXPIRED: #define  AUTH_TOKEN_EXPIRED              (1<<1) /* <=== src/openvpn/ssl_common.h:577:577:AUTH_TOKEN_EXPIRED:0 */ \n- buf_bptr: static inline uint8_t * /* <=== buf_bptr */ \nbuf_bptr(const struct buffer *buf)\n{\n    if (buf_valid(buf))\n    {\n        return buf->data + buf->offset;\n    }\n    else\n    {\n        return NULL;\n    }\n}\n- x_gc_freespecial: void /* <=== x_gc_freespecial */ \nx_gc_freespecial(struct gc_arena *a)\n{\n    struct gc_entry_special *e;\n    e = a->list_special;\n    a->list_special = NULL;\n\n    while (e != NULL)\n    {\n        struct gc_entry_special *next = e->next;\n        e->free_fnc(e->addr);\n        free(e);\n        e = next;\n    }\n}\n- tls_lock_username: static bool /* <=== tls_lock_username */ \ntls_lock_username(struct tls_multi *multi, const char *username)\n{\n    if (multi->locked_username)\n    {\n        if (!username || strcmp(username, multi->locked_username))\n        {\n            msg(D_TLS_ERRORS, \"TLS Auth Error: username attempted to change from '%s' to '%s' -- tunnel disabled\",\n                multi->locked_username,\n                np(username));\n\n            /* disable the tunnel */\n            tls_deauthenticate(multi);\n            return false;\n        }\n    }\n    else\n    {\n        if (username)\n        {\n            multi->locked_username = string_alloc(username, NULL);\n        }\n    }\n    return true;\n}\n- set_verify_user_pass_env: static bool /* <=== set_verify_user_pass_env */ \nset_verify_user_pass_env(struct user_pass *up, struct tls_multi *multi,\n                         struct tls_session *session)\n{\n    /* Is username defined? */\n    if ((session->opt->ssl_flags & SSLF_AUTH_USER_PASS_OPTIONAL) || strlen(up->username))\n    {\n        setenv_str(session->opt->es, \"username\", up->username);\n\n        /* setenv incoming cert common name for script */\n        setenv_str(session->opt->es, \"common_name\", session->common_name);\n\n        /* setenv client real IP address */\n        setenv_untrusted(session);\n\n        /*\n         * if we are using auth-gen-token, send also the session id of auth gen token to\n         * allow the management to figure out if it is a new session or a continued one\n         */\n        add_session_token_env(session, multi, up);\n        return true;\n    }\n    else\n    {\n        msg(D_TLS_ERRORS, \"TLS Auth Error: peer provided a blank username\");\n        return false;\n    }\n}\n- is_auth_token: static inline bool /* <=== is_auth_token */ \nis_auth_token(const char *password)\n{\n    return (memcmp_constant_time(SESSION_ID_PREFIX, password,\n                                 strlen(SESSION_ID_PREFIX)) == 0);\n}\n- buf_write_u8: static inline bool /* <=== buf_write_u8 */ \nbuf_write_u8(struct buffer *dest, int data)\n{\n    uint8_t u8 = (uint8_t) data;\n    return buf_write(dest, &u8, sizeof(uint8_t));\n}\n- D_SHOW_KEYS: #define D_SHOW_KEYS          LOGLEV(7, 70, M_DEBUG)  /* show data channel encryption keys */ /* <=== src/openvpn/errlevel.h:119:119:D_SHOW_KEYS:0 */ \n- BPTR: #define BPTR(buf)  (buf_bptr(buf)) /* <=== src/openvpn/buffer.h:124:124:BPTR:1 */ \n- BLEN: #define BLEN(buf)  (buf_len(buf)) /* <=== src/openvpn/buffer.h:127:127:BLEN:1 */ \n- openvpn_base64_decode: int /* <=== openvpn_base64_decode */ \nopenvpn_base64_decode(const char *str, void *data, int size)\n{\n    const char *p;\n    unsigned char *q;\n    unsigned char *e = NULL;\n\n    q = data;\n    if (size >= 0)\n    {\n        e = q + size;\n    }\n    for (p = str; *p && (*p == '=' || strchr(base64_chars, *p)); p += 4)\n    {\n        unsigned int val = token_decode(p);\n        unsigned int marker = (val >> 24) & 0xff;\n        if (val == DECODE_ERROR)\n        {\n            return -1;\n        }\n        if (e && q >= e)\n        {\n            return -1;\n        }\n        *q++ = (val >> 16) & 0xff;\n        if (marker < 2)\n        {\n            if (e && q >= e)\n            {\n                return -1;\n            }\n            *q++ = (val >> 8) & 0xff;\n        }\n        if (marker < 1)\n        {\n            if (e && q >= e)\n            {\n                return -1;\n            }\n            *q++ = val & 0xff;\n        }\n    }\n    return q - (unsigned char *) data;\n}\n- TM_ACTIVE: #define TM_ACTIVE    0          /**< Active \\c tls_session. */ /* <=== src/openvpn/ssl_common.h:462:462:TM_ACTIVE:0 */ \n- htonll: #define htonll(x) ((1==htonl(1)) ? (x) : \\ /* <=== src/openvpn/integer.h:30:31:htonll:1 */ \n                   ((uint64_t)htonl((x) & 0xFFFFFFFF) << 32) | htonl((x) >> 32))\n- buf_write_alloc: static inline uint8_t * /* <=== buf_write_alloc */ \nbuf_write_alloc(struct buffer *buf, int size)\n{\n    uint8_t *ret;\n    if (!buf_safe(buf, size))\n    {\n        return NULL;\n    }\n    ret = BPTR(buf) + buf->len;\n    buf->len += size;\n    return ret;\n}\n- SSLF_USERNAME_AS_COMMON_NAME: #define SSLF_USERNAME_AS_COMMON_NAME  (1<<2) /* <=== src/openvpn/ssl_common.h:344:344:SSLF_USERNAME_AS_COMMON_NAME:0 */ \n- memcmp_constant_time: int memcmp_constant_time(const void *a, const void *b, size_t size); /* <=== memcmp_constant_time */ \n- D_HANDSHAKE: #define D_HANDSHAKE          LOGLEV(2, 20, 0)        /* show data & control channel handshakes */ /* <=== src/openvpn/errlevel.h:72:72:D_HANDSHAKE:0 */ \n- USER_PASS_LEN: #define USER_PASS_LEN 128 /* <=== src/openvpn/misc.h:72:72:USER_PASS_LEN:0 */ \n- openvpn_base64_encode: int /* <=== openvpn_base64_encode */ \nopenvpn_base64_encode(const void *data, int size, char **str)\n{\n    char *s, *p;\n    int i;\n    int c;\n    const unsigned char *q;\n\n    if (size < 0)\n    {\n        return -1;\n    }\n    p = s = (char *) malloc(size * 4 / 3 + 4);\n    if (p == NULL)\n    {\n        return -1;\n    }\n    q = (const unsigned char *) data;\n    i = 0;\n    for (i = 0; i < size; )\n    {\n        c = q[i++];\n        c *= 256;\n        if (i < size)\n        {\n            c += q[i];\n        }\n        i++;\n        c *= 256;\n        if (i < size)\n        {\n            c += q[i];\n        }\n        i++;\n        p[0] = base64_chars[(c & 0x00fc0000) >> 18];\n        p[1] = base64_chars[(c & 0x0003f000) >> 12];\n        p[2] = base64_chars[(c & 0x00000fc0) >> 6];\n        p[3] = base64_chars[(c & 0x0000003f) >> 0];\n        if (i > size)\n        {\n            p[3] = '=';\n        }\n        if (i > size + 1)\n        {\n            p[2] = '=';\n        }\n        p += 4;\n    }\n    *p = 0;\n    *str = s;\n    return strlen(s);\n}\n- AUTH_TOKEN_SESSION_ID_LEN: #define AUTH_TOKEN_SESSION_ID_LEN 12 /* <=== src/openvpn/auth_token.c:23:23:AUTH_TOKEN_SESSION_ID_LEN:0 */ \n- M_WARN: #define M_WARN            (1<<6)         /* call syslog with LOG_WARNING */ /* <=== src/openvpn/error.h:96:96:M_WARN:0 */ \n- AUTH_TOKEN_VALID_EMPTYUSER: #define  AUTH_TOKEN_VALID_EMPTYUSER      (1<<2) /* <=== src/openvpn/ssl_common.h:577:577:AUTH_TOKEN_VALID_EMPTYUSER:0 */ \n- buf_size_valid: static inline bool /* <=== buf_size_valid */ \nbuf_size_valid(const size_t size)\n{\n    return likely(size < BUF_SIZE_MAX);\n}\n- gc_free: static inline void /* <=== gc_free */ \ngc_free(struct gc_arena *a)\n{\n    if (a->list)\n    {\n        x_gc_free(a);\n    }\n    if (a->list_special)\n    {\n        x_gc_freespecial(a);\n    }\n}\n- assert_failed: void assert_failed(const char *filename, int line, const char *condition) /* <=== assert_failed */ \n- TLS_USERNAME_LEN: #define TLS_USERNAME_LEN 64 /* <=== src/openvpn/ssl_verify.c:51:51:TLS_USERNAME_LEN:0 */ \n- SESSION_ID_PREFIX: #define SESSION_ID_PREFIX \"SESS_ID_AT_\" /* <=== src/openvpn/auth_token.h:115:115:SESSION_ID_PREFIX:0 */ \n- string_alloc: char * /* <=== string_alloc */ \n#ifdef DMALLOC\nstring_alloc_debug(const char *str, struct gc_arena *gc, const char *file, int line)\n#else\nstring_alloc(const char *str, struct gc_arena *gc)\n#endif\n{\n    if (str)\n    {\n        const int n = strlen(str) + 1;\n        char *ret;\n\n        if (gc)\n        {\n#ifdef DMALLOC\n            ret = (char *) gc_malloc_debug(n, false, gc, file, line);\n#else\n            ret = (char *) gc_malloc(n, false, gc);\n#endif\n        }\n        else\n        {\n            /* If there are no garbage collector available, it's expected\n             * that the caller cleans up afterwards.  This is coherent with the\n             * earlier behaviour when gc_malloc() would be called with gc == NULL\n             */\n#ifdef DMALLOC\n            ret = openvpn_dmalloc(file, line, n);\n#else\n            ret = calloc(1, n);\n#endif\n            check_malloc_return(ret);\n        }\n        memcpy(ret, str, n);\n        return ret;\n    }\n    else\n    {\n        return NULL;\n    }\n}\n- ntohll: #define ntohll(x) ((1==ntohl(1)) ? (x) : \\ /* <=== src/openvpn/integer.h:35:36:ntohll:1 */ \n                   ((uint64_t)ntohl((x) & 0xFFFFFFFF) << 32) | ntohl((x) >> 32))\n- SSLF_USERNAME_AS_COMMON_NAME: #define SSLF_USERNAME_AS_COMMON_NAME  (1<<2) /* <=== src/openvpn/ssl_common.h:342:342:SSLF_USERNAME_AS_COMMON_NAME:0 */ \n- check_hmac_token: static bool /* <=== check_hmac_token */ \ncheck_hmac_token(hmac_ctx_t *ctx, const uint8_t *b64decoded, const char *username)\n{\n    ASSERT(hmac_ctx_size(ctx) == 256/8);\n\n    uint8_t hmac_output[256/8];\n\n    hmac_ctx_reset(ctx);\n    hmac_ctx_update(ctx, (uint8_t *) username, (int)strlen(username));\n    hmac_ctx_update(ctx, b64decoded, TOKEN_DATA_LEN - 256/8);\n    hmac_ctx_final(ctx, hmac_output);\n\n    const uint8_t *hmac = b64decoded + TOKEN_DATA_LEN - 256/8;\n    return memcmp_constant_time(&hmac_output, hmac, 32) == 0;\n}\n- buf_bptr: static inline uint8_t * /* <=== buf_bptr */ \nbuf_bptr(const struct buffer *buf)\n{\n    if (buf_valid(buf))\n    {\n        return buf->data + buf->offset;\n    }\n    else\n    {\n        return NULL;\n    }\n}\n- verify_user_pass_script: static bool /* <=== verify_user_pass_script */ \nverify_user_pass_script(struct tls_session *session, struct tls_multi *multi,\n                        const struct user_pass *up)\n{\n    struct gc_arena gc = gc_new();\n    struct argv argv = argv_new();\n    const char *tmp_file = \"\";\n    bool ret = false;\n\n    /* Set environmental variables prior to calling script */\n    setenv_str(session->opt->es, \"script_type\", \"user-pass-verify\");\n\n    /* format command line */\n    argv_parse_cmd(&argv, session->opt->auth_user_pass_verify_script);\n\n    if (session->opt->auth_user_pass_verify_script_via_file)\n    {\n        struct status_output *so;\n\n        tmp_file = platform_create_temp_file(session->opt->tmp_dir, \"up\",\n                                             &gc);\n        if (tmp_file)\n        {\n            so = status_open(tmp_file, 0, -1, NULL, STATUS_OUTPUT_WRITE);\n            status_printf(so, \"%s\", up->username);\n            status_printf(so, \"%s\", up->password);\n            if (!status_close(so))\n            {\n                msg(D_TLS_ERRORS, \"TLS Auth Error: could not write username/password to file: %s\",\n                    tmp_file);\n                goto done;\n            }\n            /* pass temp file name to script */\n            argv_printf_cat(&argv, \"%s\", tmp_file);\n        }\n        else\n        {\n            msg(D_TLS_ERRORS, \"TLS Auth Error: could not create write \"\n                \"username/password to temp file\");\n        }\n    }\n    else\n    {\n        setenv_str(session->opt->es, \"password\", up->password);\n    }\n\n    /* call command */\n    ret = openvpn_run_script(&argv, session->opt->es, 0,\n                             \"--auth-user-pass-verify\");\n\n    if (!session->opt->auth_user_pass_verify_script_via_file)\n    {\n        setenv_del(session->opt->es, \"password\");\n    }\ndone:\n    if (tmp_file && strlen(tmp_file) > 0)\n    {\n        platform_unlink(tmp_file);\n    }\n\n    argv_free(&argv);\n    gc_free(&gc);\n    return ret;\n}\n- AUTH_TOKEN_VALID_EMPTYUSER: #define  AUTH_TOKEN_VALID_EMPTYUSER      (1<<2) /* <=== src/openvpn/ssl_common.h:579:579:AUTH_TOKEN_VALID_EMPTYUSER:0 */ \n- setenv_untrusted: static void /* <=== setenv_untrusted */ \nsetenv_untrusted(struct tls_session *session)\n{\n    setenv_link_socket_actual(session->opt->es, \"untrusted\", &session->untrusted_addr, SA_IP_PORT);\n}\n- TOKEN_DATA_LEN: #define TOKEN_DATA_LEN (2 * sizeof(int64_t) + AUTH_TOKEN_SESSION_ID_LEN + 32) /* <=== src/openvpn/auth_token.c:29:29:TOKEN_DATA_LEN:0 */ \n- D_TLS_ERRORS: #define D_TLS_ERRORS         LOGLEV(1, 3, M_NONFATAL)   /* show TLS control channel errors */ /* <=== src/openvpn/errlevel.h:59:59:D_TLS_ERRORS:0 */ \n- gc_malloc: void * /* <=== gc_malloc */ \n#ifdef DMALLOC\ngc_malloc_debug(size_t size, bool clear, struct gc_arena *a, const char *file, int line)\n#else\ngc_malloc(size_t size, bool clear, struct gc_arena *a)\n#endif\n{\n    void *ret;\n    if (a)\n    {\n        struct gc_entry *e;\n#ifdef DMALLOC\n        e = (struct gc_entry *) openvpn_dmalloc(file, line, size + sizeof(struct gc_entry));\n#else\n        e = (struct gc_entry *) malloc(size + sizeof(struct gc_entry));\n#endif\n        check_malloc_return(e);\n        ret = (char *) e + sizeof(struct gc_entry);\n        e->next = a->list;\n        a->list = e;\n    }\n    else\n    {\n#ifdef DMALLOC\n        ret = openvpn_dmalloc(file, line, size);\n#else\n        ret = malloc(size);\n#endif\n        check_malloc_return(ret);\n    }\n#ifndef ZERO_BUFFER_ON_ALLOC\n    if (clear)\n#endif\n    memset(ret, 0, size);\n    return ret;\n}\n- D_SHOW_KEYS: #define D_SHOW_KEYS          LOGLEV(7, 70, M_DEBUG)  /* show data channel encryption keys */ /* <=== src/openvpn/errlevel.h:119:119:D_SHOW_KEYS:0 */ \n- auth_set_client_reason: void /* <=== auth_set_client_reason */ \nauth_set_client_reason(struct tls_multi *multi, const char *client_reason)\n{\n    if (multi->client_reason)\n    {\n        free(multi->client_reason);\n        multi->client_reason = NULL;\n    }\n    if (client_reason && strlen(client_reason))\n    {\n        multi->client_reason = string_alloc(client_reason, NULL);\n    }\n}\n- TM_ACTIVE: #define TM_ACTIVE    0          /**< Active \\c tls_session. */ /* <=== src/openvpn/ssl_common.h:462:462:TM_ACTIVE:0 */ \n- buf_write_u8: static inline bool /* <=== buf_write_u8 */ \nbuf_write_u8(struct buffer *dest, int data)\n{\n    uint8_t u8 = (uint8_t) data;\n    return buf_write(dest, &u8, sizeof(uint8_t));\n}\n- x_gc_free: void /* <=== x_gc_free */ \nx_gc_free(struct gc_arena *a)\n{\n    struct gc_entry *e;\n    e = a->list;\n    a->list = NULL;\n\n    while (e != NULL)\n    {\n        struct gc_entry *next = e->next;\n        free(e);\n        e = next;\n    }\n}\n- alloc_buf_gc: struct buffer /* <=== alloc_buf_gc */ \n#ifdef DMALLOC\nalloc_buf_gc_debug(size_t size, struct gc_arena *gc, const char *file, int line)\n#else\nalloc_buf_gc(size_t size, struct gc_arena *gc)\n#endif\n{\n    struct buffer buf;\n    if (!buf_size_valid(size))\n    {\n        buf_size_error(size);\n    }\n    buf.capacity = (int)size;\n    buf.offset = 0;\n    buf.len = 0;\n#ifdef DMALLOC\n    buf.data = (uint8_t *) gc_malloc_debug(size, false, gc, file, line);\n#else\n    buf.data = (uint8_t *) gc_malloc(size, false, gc);\n#endif\n    if (size)\n    {\n        *buf.data = 0;\n    }\n    return buf;\n}\n- buf_size_error: void /* <=== buf_size_error */ \nbuf_size_error(const size_t size)\n{\n    msg(M_FATAL, \"fatal buffer size error, size=%lu\", (unsigned long)size);\n}\n- STATUS_OUTPUT_WRITE: #define STATUS_OUTPUT_WRITE (1<<1) /* <=== src/openvpn/status.h:51:51:STATUS_OUTPUT_WRITE:0 */ \n- buf_len: static int /* <=== buf_len */ \nbuf_len(const struct buffer *buf)\n{\n    if (buf_valid(buf))\n    {\n        return buf->len;\n    }\n    else\n    {\n        return 0;\n    }\n}\n- set_common_name: static void /* <=== set_common_name */ \nset_common_name(struct tls_session *session, const char *common_name)\n{\n    if (session->common_name)\n    {\n        free(session->common_name);\n        session->common_name = NULL;\n#ifdef ENABLE_PF\n        session->common_name_hashval = 0;\n#endif\n    }\n    if (common_name)\n    {\n        /* FIXME: Last alloc will never be freed */\n        session->common_name = string_alloc(common_name, NULL);\n#ifdef ENABLE_PF\n        {\n            const uint32_t len = (uint32_t) strlen(common_name);\n            if (len)\n            {\n                session->common_name_hashval = hash_func((const uint8_t *)common_name, len+1, 0);\n            }\n            else\n            {\n                session->common_name_hashval = 0;\n            }\n        }\n#endif\n    }\n}\n- secure_memzero: static inline void /* <=== secure_memzero */ \nsecure_memzero(void *data, size_t len)\n{\n#if defined(_WIN32)\n    SecureZeroMemory(data, len);\n#elif defined(__GNUC__) || defined(__clang__)\n    memset(data, 0, len);\n    __asm__ __volatile__ (\"\" : : \"r\" (data) : \"memory\");\n#else\n    volatile char *p = (volatile char *) data;\n    while (len--)\n    {\n        *p++ = 0;\n    }\n#endif\n}\n- np: const char * /* <=== np */ \nnp(const char *str)\n{\n    if (str)\n    {\n        return str;\n    }\n    else\n    {\n        return \"[NULL]\";\n    }\n}\n- buf_write: static inline bool /* <=== buf_write */ \nbuf_write(struct buffer *dest, const void *src, int size)\n{\n    uint8_t *cp = buf_write_alloc(dest, size);\n    if (!cp)\n    {\n        return false;\n    }\n    memcpy(cp, src, size);\n    return true;\n}\n- buf_valid: static inline bool /* <=== buf_valid */ \nbuf_valid(const struct buffer *buf)\n{\n    return likely(buf->data != NULL) && likely(buf->len >= 0);\n}\n- ASSERT: #define ASSERT(x) do { if (!(x)) {assert_failed(__FILE__, __LINE__, #x);}} while (false) /* <=== src/openvpn/error.h:221:221:ASSERT:1 */ \n- tls_deauthenticate: static void /* <=== tls_deauthenticate */ \ntls_deauthenticate(struct tls_multi *multi)\n{\n    if (multi)\n    {\n        wipe_auth_token(multi);\n        for (int i = 0; i < TM_SIZE; ++i)\n        {\n            for (int j = 0; j < KS_SIZE; ++j)\n            {\n                multi->session[i].key[j].authenticated = KS_AUTH_FALSE;\n            }\n        }\n    }\n}\n- openvpn_base64_encode: int /* <=== openvpn_base64_encode */ \nopenvpn_base64_encode(const void *data, int size, char **str)\n{\n    char *s, *p;\n    int i;\n    int c;\n    const unsigned char *q;\n\n    if (size < 0)\n    {\n        return -1;\n    }\n    p = s = (char *) malloc(size * 4 / 3 + 4);\n    if (p == NULL)\n    {\n        return -1;\n    }\n    q = (const unsigned char *) data;\n    i = 0;\n    for (i = 0; i < size; )\n    {\n        c = q[i++];\n        c *= 256;\n        if (i < size)\n        {\n            c += q[i];\n        }\n        i++;\n        c *= 256;\n        if (i < size)\n        {\n            c += q[i];\n        }\n        i++;\n        p[0] = base64_chars[(c & 0x00fc0000) >> 18];\n        p[1] = base64_chars[(c & 0x0003f000) >> 12];\n        p[2] = base64_chars[(c & 0x00000fc0) >> 6];\n        p[3] = base64_chars[(c & 0x0000003f) >> 0];\n        if (i > size)\n        {\n            p[3] = '=';\n        }\n        if (i > size + 1)\n        {\n            p[2] = '=';\n        }\n        p += 4;\n    }\n    *p = 0;\n    *str = s;\n    return strlen(s);\n}\n\nType Definitions:\n- int64_t: typedef __int64 int64_t;\n- buffer: struct buffer\n{\n    int capacity;               /**< Size in bytes of memory allocated by\n                                 *   \\c malloc(). */\n    int offset;                 /**< Offset in bytes of the actual content\n                                 *   within the allocated memory. */\n    int len;                    /**< Length in bytes of the actual content\n                                 *   within the allocated memory. */\n    uint8_t *data;              /**< Pointer to the allocated memory. */\n\n#ifdef BUF_INIT_TRACKING\n    const char *debug_file;\n    int debug_line;\n#endif\n}\n- tls_multi: struct tls_multi\n{\n    /* used to coordinate access between main thread and TLS thread */\n    /*MUTEX_PTR_DEFINE (mutex);*/\n\n    /* const options and config info */\n    struct tls_options opt;\n\n    struct key_state *key_scan[KEY_SCAN_SIZE];\n    /**< List of \\c key_state objects in the\n     *   order they should be scanned by data\n     *   channel modules. */\n\n    /*\n     * used by tls_pre_encrypt to communicate the encrypt key\n     * to tls_post_encrypt()\n     */\n    struct key_state *save_ks;  /* temporary pointer used between pre/post routines */\n\n    /*\n     * Used to return outgoing address from\n     * tls_multi_process.\n     */\n    struct link_socket_actual to_link_addr;\n\n    int n_sessions;             /**< Number of sessions negotiated thus\n                                 *   far. */\n    enum client_connect_status multi_state;\n\n    /*\n     * Number of errors.\n     */\n    int n_hard_errors; /* errors due to TLS negotiation failure */\n    int n_soft_errors; /* errors due to unrecognized or failed-to-authenticate incoming packets */\n\n    /*\n     * Our locked common name, username, and cert hashes (cannot change during the life of this tls_multi object)\n     */\n    char *locked_cn;\n    char *locked_username;\n    struct cert_hash_set *locked_cert_hash_set;\n\n#ifdef ENABLE_DEF_AUTH\n    /* Time of last call to tls_authentication_status */\n    time_t tas_last;\n#endif\n\n    /*\n     * An error message to send to client on AUTH_FAILED\n     */\n    char *client_reason;\n\n    /*\n     * A multi-line string of general-purpose info received from peer\n     * over control channel.\n     */\n    char *peer_info;\n    char *auth_token;    /**< If server sends a generated auth-token,\n                          *   this is the token to use for future\n                          *   user/pass authentications in this session.\n                          */\n    char *auth_token_initial;\n    /**< The first auth-token we sent to a client, for clients that do\n     * not update their auth-token (older OpenVPN3 core versions)\n     */\n#define  AUTH_TOKEN_HMAC_OK              (1<<0)\n    /**< Auth-token sent from client has valid hmac */\n#define  AUTH_TOKEN_EXPIRED              (1<<1)\n    /**< Auth-token sent from client has expired */\n#define  AUTH_TOKEN_VALID_EMPTYUSER      (1<<2)\n    /**<\n     * Auth-token is only valid for an empty username\n     * and not the username actually supplied from the client\n     *\n     * OpenVPN 3 clients sometimes wipes or replaces the username with a\n     * username hint from their config.\n     */\n\n    /* For P_DATA_V2 */\n    uint32_t peer_id;\n    bool use_peer_id;\n\n    char *remote_ciphername;    /**< cipher specified in peer's config file */\n\n    /*\n     * Our session objects.\n     */\n    struct tls_session session[TM_SIZE];\n    /**< Array of \\c tls_session objects\n     *   representing control channel\n     *   sessions with the remote peer. */\n}\n- gc_arena: struct gc_arena\n{\n    struct gc_entry *list;      /**< First element of the linked list of\n                                 *   \\c gc_entry structures. */\n    struct gc_entry_special *list_special;\n}\n- tls_multi: struct tls_multi\n- user_pass: static struct user_pass\n- user_pass: struct user_pass\n- tls_session: struct tls_session\n{\n    /* const options and config info */\n    struct tls_options *opt;\n\n    /* during hard reset used to control burst retransmit */\n    bool burst;\n\n    /* authenticate control packets */\n    struct tls_wrap_ctx tls_wrap;\n\n    int initial_opcode;         /* our initial P_ opcode */\n    struct session_id session_id; /* our random session ID */\n\n    /**\n     * The current active key id, used to keep track of renegotiations.\n     * key_id increments with each soft reset to KEY_ID_MASK then recycles back\n     * to 1.  This way you know that if key_id is 0, it is the first key.\n     */\n    int key_id;\n\n    int limit_next;             /* used for traffic shaping on the control channel */\n\n    int verify_maxlevel;\n\n    char *common_name;\n\n    struct cert_hash_set *cert_hash_set;\n\n#ifdef ENABLE_PF\n    uint32_t common_name_hashval;\n#endif\n\n    bool verified;              /* true if peer certificate was verified against CA */\n\n    /* not-yet-authenticated incoming client */\n    struct link_socket_actual untrusted_addr;\n\n    struct key_state key[KS_SIZE];\n}\n- key_state: struct key_state\n{\n    int state;\n\n    /**\n     * Key id for this key_state,  inherited from struct tls_session.\n     * @see tls_session::key_id.\n     */\n    int key_id;\n\n    struct key_state_ssl ks_ssl; /* contains S