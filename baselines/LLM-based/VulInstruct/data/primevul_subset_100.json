[
  {
    "repository": "cdt",
    "cve_id": "CVE-2023-4218",
    "cwe_list": [
      "CWE-611"
    ],
    "commit_hash": "c7169b3186d2fef20f97467c3e2ad78e2943ed1b",
    "short_hash": "c7169b31",
    "vulnerableMethods_before": [
      {
        "filename": "AutoconfTextHover.java",
        "method_name": "build/org.eclipse.cdt.autotools.ui/src/org/eclipse/cdt/internal/autotools/ui/text/hover/AutoconfTextHover.java#getAMDoc",
        "raw_code": "protected static Document getAMDoc(String amDocVer) {\n\t\tDocument amDocument = null;\n\t\tif (amHoverDocs == null) {\n\t\t\tamHoverDocs = new HashMap<>();\n\t\t}\n\t\tamDocument = amHoverDocs.get(amDocVer);\n\t\tif (amDocument == null) {\n\t\t\tDocument doc = null;\n\t\t\ttry {\n\t\t\t\t// see comment in initialize()\n\t\t\t\ttry {\n\t\t\t\t\tInputStream docStream = null;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tURI uri = new URI(getLocalAutomakeMacrosDocName(amDocVer));\n\t\t\t\t\t\tIPath p = URIUtil.toPath(uri);\n\t\t\t\t\t\t// Try to open the file as local to this plug-in.\n\t\t\t\t\t\tdocStream = FileLocator.openStream(AutotoolsUIPlugin.getDefault().getBundle(), p, false);\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t// Local open failed.  Try normal external location.\n\t\t\t\t\t\tURI acDoc = new URI(getAutomakeMacrosDocName(amDocVer));\n\t\t\t\t\t\tIPath p = URIUtil.toPath(acDoc);\n\t\t\t\t\t\tif (p == null) {\n\t\t\t\t\t\t\tURL url = acDoc.toURL();\n\t\t\t\t\t\t\tdocStream = url.openStream();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdocStream = new FileInputStream(p.toFile());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tDocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n\t\t\t\t\tfactory.setValidating(false);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tDocumentBuilder builder = factory.newDocumentBuilder();\n\t\t\t\t\t\tdoc = builder.parse(docStream);\n\t\t\t\t\t} catch (SAXException | ParserConfigurationException | IOException ex) {\n\t\t\t\t\t\tdoc = null;\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif (docStream != null)\n\t\t\t\t\t\t\tdocStream.close();\n\t\t\t\t\t}\n\t\t\t\t} catch (FileNotFoundException | MalformedURLException | URISyntaxException e) {\n\t\t\t\t\tAutotoolsPlugin.log(e);\n\t\t\t\t}\n\t\t\t\tamDocument = doc;\n\t\t\t} catch (IOException ioe) {\n\t\t\t}\n\t\t}\n\t\tamHoverDocs.put(amDocVer, amDocument);\n\t\treturn amDocument;\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AutoconfTextHover.java",
        "method_name": "build/org.eclipse.cdt.autotools.ui/src/org/eclipse/cdt/internal/autotools/ui/text/hover/AutoconfTextHover.java#getAMDoc",
        "raw_code": "protected static Document getAMDoc(String amDocVer) {\n\t\tDocument amDocument = null;\n\t\tif (amHoverDocs == null) {\n\t\t\tamHoverDocs = new HashMap<>();\n\t\t}\n\t\tamDocument = amHoverDocs.get(amDocVer);\n\t\tif (amDocument == null) {\n\t\t\tDocument doc = null;\n\t\t\ttry {\n\t\t\t\t// see comment in initialize()\n\t\t\t\ttry {\n\t\t\t\t\tInputStream docStream = null;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tURI uri = new URI(getLocalAutomakeMacrosDocName(amDocVer));\n\t\t\t\t\t\tIPath p = URIUtil.toPath(uri);\n\t\t\t\t\t\t// Try to open the file as local to this plug-in.\n\t\t\t\t\t\tdocStream = FileLocator.openStream(AutotoolsUIPlugin.getDefault().getBundle(), p, false);\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t// Local open failed.  Try normal external location.\n\t\t\t\t\t\tURI acDoc = new URI(getAutomakeMacrosDocName(amDocVer));\n\t\t\t\t\t\tIPath p = URIUtil.toPath(acDoc);\n\t\t\t\t\t\tif (p == null) {\n\t\t\t\t\t\t\tURL url = acDoc.toURL();\n\t\t\t\t\t\t\tdocStream = url.openStream();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdocStream = new FileInputStream(p.toFile());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tDocumentBuilderFactory factory = XmlProcessorFactoryCdt\n\t\t\t\t\t\t\t.createDocumentBuilderFactoryIgnoringDOCTYPE();\n\t\t\t\t\tfactory.setValidating(false);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tDocumentBuilder builder = factory.newDocumentBuilder();\n\t\t\t\t\t\tdoc = builder.parse(docStream);\n\t\t\t\t\t} catch (SAXException | ParserConfigurationException | IOException ex) {\n\t\t\t\t\t\tdoc = null;\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif (docStream != null)\n\t\t\t\t\t\t\tdocStream.close();\n\t\t\t\t\t}\n\t\t\t\t} catch (FileNotFoundException | MalformedURLException | URISyntaxException e) {\n\t\t\t\t\tAutotoolsPlugin.log(e);\n\t\t\t\t}\n\t\t\t\tamDocument = doc;\n\t\t\t} catch (IOException ioe) {\n\t\t\t}\n\t\t}\n\t\tamHoverDocs.put(amDocVer, amDocument);\n\t\treturn amDocument;\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "RoughlyEnoughItems",
    "cve_id": "CVE-2024-42698",
    "cwe_list": [
      "CWE-129"
    ],
    "commit_hash": "e80ca84f1affb91d2388ddb298bfc6b141828cad",
    "short_hash": "e80ca84f",
    "vulnerableMethods_before": [],
    "vulnerableMethods_after": [
      {
        "filename": "InputCleanHandler.java",
        "method_name": "api/src/main/java/me/shedaniel/rei/api/common/transfer/info/clean/InputCleanHandler.java#returnSlotsToPlayerInventory",
        "raw_code": "static <T extends AbstractContainerMenu> void returnSlotsToPlayerInventory(MenuInfoContext<T, ?, ?> context, DumpHandler<T, ?> dumpHandler, SlotAccessor slotAccessor) {\n        ItemStack stackToReturn = slotAccessor.getItemStack();\n        if (!stackToReturn.isEmpty()) {\n            if (!slotAccessor.allowModification(context.getPlayerEntity())) {\n                error(\"rei.rei.no.slot.in.inv\");\n            }\n            \n            for (; !(stackToReturn = slotAccessor.getItemStack()).isEmpty(); slotAccessor.takeStack(1)) {\n                ItemStack stackToInsert = stackToReturn.copy();\n                stackToInsert.setCount(1);\n                if (!dumpGenericsFtw(context, dumpHandler, stackToInsert)) {\n                    error(\"rei.rei.no.slot.in.inv\");\n                }\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2024-31981",
    "cwe_list": [
      "CWE-862"
    ],
    "commit_hash": "a4ad14d9c1605a5ab957237e505ebbb29f5b9d73",
    "short_hash": "a4ad14d9",
    "vulnerableMethods_before": [
      {
        "filename": "PdfExportImpl.java",
        "method_name": "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/pdf/impl/PdfExportImpl.java#getPDFTemplateProperty",
        "raw_code": "private String getPDFTemplateProperty(String propertyName, XWikiContext context)\n    {\n        String pdftemplate = context.getRequest().getParameter(\"pdftemplate\");\n\n        DocumentReference templateReference;\n        DocumentReference classReference;\n        if (StringUtils.isNotEmpty(pdftemplate)) {\n            templateReference = referenceResolver.resolve(pdftemplate);\n            classReference = new DocumentReference(templateReference.getWikiReference().getName(), \"XWiki\", \"PDFClass\");\n        } else {\n            templateReference = dab.getCurrentDocumentReference();\n            String currentWiki = dab.getCurrentDocumentReference().getRoot().getName();\n            classReference = new DocumentReference(currentWiki, \"XWiki\", \"PDFClass\");\n        }\n\n        String result = (String) dab.getProperty(templateReference, classReference, propertyName);\n        if (StringUtils.isBlank(result)) {\n            return \"\";\n        }\n        String templateName = referenceSerializer.serialize(templateReference);\n        try {\n            StringWriter writer = new StringWriter();\n            VelocityContext vcontext = velocityManager.getVelocityContext();\n            velocityManager.getVelocityEngine().evaluate(vcontext, writer, templateName, result);\n            result = writer.toString();\n        } catch (XWikiVelocityException e) {\n            LOGGER.warn(\"Error applying Velocity to the [{}] property of the [{}] document. Using the property's value \"\n                + \"without applying Velocity.\", propertyName, templateName, ExceptionUtils.getRootCauseMessage(e));\n        }\n        return result;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "PdfExportImpl.java",
        "method_name": "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/pdf/impl/PdfExportImpl.java#getPDFTemplateProperty",
        "raw_code": "private String getPDFTemplateProperty(String propertyName, XWikiContext context)\n    {\n        String pdftemplate = context.getRequest().getParameter(\"pdftemplate\");\n\n        DocumentReference templateReference;\n        DocumentReference classReference;\n        if (StringUtils.isNotEmpty(pdftemplate)) {\n            templateReference = this.referenceResolver.resolve(pdftemplate);\n            classReference = new DocumentReference(templateReference.getWikiReference().getName(), \"XWiki\", \"PDFClass\");\n        } else {\n            templateReference = this.dab.getCurrentDocumentReference();\n            String currentWiki = this.dab.getCurrentDocumentReference().getRoot().getName();\n            classReference = new DocumentReference(currentWiki, \"XWiki\", \"PDFClass\");\n        }\n\n        String templateContent = (String) this.dab.getProperty(templateReference, classReference, propertyName);\n        if (StringUtils.isBlank(templateContent)) {\n            return \"\";\n        }\n\n        String templateName = this.referenceSerializer.serialize(templateReference);\n        DocumentReference templateAuthorReference;\n        String result = templateContent;\n        try {\n             templateAuthorReference = this.userReferenceSerializer.serialize(\n                 this.dab.getDocumentInstance(templateReference).getAuthors().getEffectiveMetadataAuthor());\n        } catch (Exception e) {\n            LOGGER.warn(\"Error fetching the author of template [{}] during PDF conversion. Using the [{}] property of \"\n                + \"the document's value without applying Velocity.\", templateName, propertyName);\n            return result;\n        }\n\n        if (this.authorizationManager.hasAccess(Right.SCRIPT, templateAuthorReference, templateReference)) {\n            try {\n                result = this.authorExecutor.call(() -> {\n                    StringWriter writer = new StringWriter();\n                    VelocityContext vcontext = this.velocityManager.getVelocityContext();\n                    this.velocityManager.getVelocityEngine().evaluate(vcontext, writer, templateName,\n                        templateContent);\n                    return writer.toString();\n                }, templateAuthorReference, templateReference);\n            } catch (Exception e) {\n                LOGGER.warn(\"Failed to run Velocity engine in author executor. Using the [{}] property of the [{}] \"\n                    + \"document's value without applying Velocity. Reason: [{}]\",\n                    propertyName, templateName, ExceptionUtils.getRootCauseMessage(e));\n            }\n        }\n\n        return result;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "cdt",
    "cve_id": "CVE-2023-4218",
    "cwe_list": [
      "CWE-611"
    ],
    "commit_hash": "c7169b3186d2fef20f97467c3e2ad78e2943ed1b",
    "short_hash": "c7169b31",
    "vulnerableMethods_before": [
      {
        "filename": "UpdateManagedProject12.java",
        "method_name": "build/org.eclipse.cdt.managedbuilder.core/src/org/eclipse/cdt/managedbuilder/projectconverter/UpdateManagedProject12.java#doProjectUpdate",
        "raw_code": "public static void doProjectUpdate(IProgressMonitor monitor, final IProject project) throws CoreException {\n\t\tString[] projectName = new String[] { project.getName() };\n\t\tIFile file = project.getFile(ManagedBuildManager.SETTINGS_FILE_NAME);\n\t\tFile settingsFile = file.getLocation().toFile();\n\n\t\tif (!settingsFile.exists()) {\n\t\t\tmonitor.done();\n\t\t\treturn;\n\t\t}\n\n\t\t// Backup the file\n\t\tmonitor.beginTask(ConverterMessages.getFormattedString(\"UpdateManagedProject12.0\", projectName), 1); //$NON-NLS-1$\n\t\tIManagedBuildInfo info = ManagedBuildManager.getBuildInfo(project);\n\t\tUpdateManagedProjectManager.backupFile(file, \"_12backup\", monitor, project); //$NON-NLS-1$\n\n\t\tIManagedProject newProject = null;\n\n\t\t//Now convert each target to the new format\n\t\ttry {\n\t\t\t// Load the old build file\n\t\t\tInputStream stream = new FileInputStream(settingsFile);\n\t\t\tDocumentBuilder parser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n\t\t\tDocument document = parser.parse(stream);\n\n\t\t\t// Clone the target based on the proper target definition\n\t\t\tNodeList targetNodes = document.getElementsByTagName(ITarget.TARGET_ELEMENT_NAME);\n\t\t\t// This is a guess, but typically the project has 1 target, 2 configs, and 6 tool defs\n\t\t\tint listSize = targetNodes.getLength();\n\t\t\tmonitor.beginTask(ConverterMessages.getFormattedString(\"UpdateManagedProject12.1\", projectName), //$NON-NLS-1$\n\t\t\t\t\tlistSize * 9);\n\t\t\tfor (int targIndex = 0; targIndex < listSize; ++targIndex) {\n\t\t\t\tElement oldTarget = (Element) targetNodes.item(targIndex);\n\t\t\t\tString oldTargetId = oldTarget.getAttribute(ITarget.ID);\n\t\t\t\tnewProject = convertTarget(project, oldTarget, monitor);\n\t\t\t\t// Remove the old target\n\t\t\t\tif (newProject != null) {\n\t\t\t\t\tinfo.removeTarget(oldTargetId);\n\t\t\t\t\tmonitor.worked(1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set the default configuration\n\t\t\tNodeList defaultConfiguration = document.getElementsByTagName(IManagedBuildInfo.DEFAULT_CONFIGURATION);\n\t\t\ttry {\n\t\t\t\tElement defaultConfig = (Element) defaultConfiguration.item(0);\n\t\t\t\tString oldDefaultConfigId = defaultConfig.getAttribute(IBuildObject.ID);\n\t\t\t\tIConfiguration newDefaultConfig = getConfigIdMap().get(oldDefaultConfigId);\n\t\t\t\tif (newDefaultConfig != null) {\n\t\t\t\t\tinfo.setDefaultConfiguration(newDefaultConfig);\n\t\t\t\t\tinfo.setSelectedConfiguration(newDefaultConfig);\n\t\t\t\t} else {\n\t\t\t\t\t// The only safe thing to do if there wasn't a default configuration for a built-in\n\t\t\t\t\t// target is to set the first defined configuration as the default\n\t\t\t\t\tIConfiguration[] newConfigs = newProject.getConfigurations();\n\t\t\t\t\tif (newConfigs.length > 0) {\n\t\t\t\t\t\tinfo.setDefaultConfiguration(newConfigs[0]);\n\t\t\t\t\t\tinfo.setSelectedConfiguration(newConfigs[0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (IndexOutOfBoundsException e) {\n\t\t\t\tthrow new CoreException(new Status(IStatus.ERROR, ManagedBuilderCorePlugin.getUniqueIdentifier(), -1,\n\t\t\t\t\t\tConverterMessages.getFormattedString(\"UpdateManagedProject12.7\", newProject.getName()), null)); //$NON-NLS-1$\n\t\t\t}\n\n\t\t\t// Upgrade the version\n\t\t\t((ManagedBuildInfo) info).setVersion(\"2.1.0\"); //$NON-NLS-1$\n\t\t\tinfo.setValid(true);\n\t\t} catch (CoreException e) {\n\t\t\tthrow e;\n\t\t} catch (Exception e) {\n\t\t\tthrow new CoreException(\n\t\t\t\t\tnew Status(IStatus.ERROR, ManagedBuilderCorePlugin.getUniqueIdentifier(), -1, e.getMessage(), e));\n\t\t} finally {\n\t\t\t// If the tree is locked spawn a job to this.\n\t\t\tIWorkspace workspace = project.getWorkspace();\n\t\t\t//\t\t\tboolean treeLock = workspace.isTreeLocked();\n\t\t\tISchedulingRule rule = workspace.getRuleFactory().createRule(project);\n\t\t\t//since the java synchronized mechanism is now used for the build info loadding,\n\t\t\t//initiate the job in all cases\n\t\t\t//\t\t\tif (treeLock) {\n\t\t\tWorkspaceJob job = new WorkspaceJob(ConverterMessages.getResourceString(\"UpdateManagedProject.notice\")) { //$NON-NLS-1$\n\t\t\t\t@Override\n\t\t\t\tpublic IStatus runInWorkspace(IProgressMonitor monitor) throws CoreException {\n\t\t\t\t\tManagedBuildManager.saveBuildInfoLegacy(project, false);\n\t\t\t\t\treturn Status.OK_STATUS;\n\t\t\t\t}\n\t\t\t};\n\t\t\tjob.setRule(rule);\n\t\t\tjob.schedule();\n\t\t\t//\t\t\t} else {\n\t\t\t//\t\t\t\tManagedBuildManager.saveBuildInfo(project, false);\n\t\t\t//\t\t\t}\n\t\t\tmonitor.done();\n\t\t}\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "UpdateManagedProject12.java",
        "method_name": "build/org.eclipse.cdt.managedbuilder.core/src/org/eclipse/cdt/managedbuilder/projectconverter/UpdateManagedProject12.java#doProjectUpdate",
        "raw_code": "public static void doProjectUpdate(IProgressMonitor monitor, final IProject project) throws CoreException {\n\t\tString[] projectName = new String[] { project.getName() };\n\t\tIFile file = project.getFile(ManagedBuildManager.SETTINGS_FILE_NAME);\n\t\tFile settingsFile = file.getLocation().toFile();\n\n\t\tif (!settingsFile.exists()) {\n\t\t\tmonitor.done();\n\t\t\treturn;\n\t\t}\n\n\t\t// Backup the file\n\t\tmonitor.beginTask(ConverterMessages.getFormattedString(\"UpdateManagedProject12.0\", projectName), 1); //$NON-NLS-1$\n\t\tIManagedBuildInfo info = ManagedBuildManager.getBuildInfo(project);\n\t\tUpdateManagedProjectManager.backupFile(file, \"_12backup\", monitor, project); //$NON-NLS-1$\n\n\t\tIManagedProject newProject = null;\n\n\t\t//Now convert each target to the new format\n\t\ttry {\n\t\t\t// Load the old build file\n\t\t\tInputStream stream = new FileInputStream(settingsFile);\n\t\t\tDocumentBuilder parser = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tDocument document = parser.parse(stream);\n\n\t\t\t// Clone the target based on the proper target definition\n\t\t\tNodeList targetNodes = document.getElementsByTagName(ITarget.TARGET_ELEMENT_NAME);\n\t\t\t// This is a guess, but typically the project has 1 target, 2 configs, and 6 tool defs\n\t\t\tint listSize = targetNodes.getLength();\n\t\t\tmonitor.beginTask(ConverterMessages.getFormattedString(\"UpdateManagedProject12.1\", projectName), //$NON-NLS-1$\n\t\t\t\t\tlistSize * 9);\n\t\t\tfor (int targIndex = 0; targIndex < listSize; ++targIndex) {\n\t\t\t\tElement oldTarget = (Element) targetNodes.item(targIndex);\n\t\t\t\tString oldTargetId = oldTarget.getAttribute(ITarget.ID);\n\t\t\t\tnewProject = convertTarget(project, oldTarget, monitor);\n\t\t\t\t// Remove the old target\n\t\t\t\tif (newProject != null) {\n\t\t\t\t\tinfo.removeTarget(oldTargetId);\n\t\t\t\t\tmonitor.worked(1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set the default configuration\n\t\t\tNodeList defaultConfiguration = document.getElementsByTagName(IManagedBuildInfo.DEFAULT_CONFIGURATION);\n\t\t\ttry {\n\t\t\t\tElement defaultConfig = (Element) defaultConfiguration.item(0);\n\t\t\t\tString oldDefaultConfigId = defaultConfig.getAttribute(IBuildObject.ID);\n\t\t\t\tIConfiguration newDefaultConfig = getConfigIdMap().get(oldDefaultConfigId);\n\t\t\t\tif (newDefaultConfig != null) {\n\t\t\t\t\tinfo.setDefaultConfiguration(newDefaultConfig);\n\t\t\t\t\tinfo.setSelectedConfiguration(newDefaultConfig);\n\t\t\t\t} else {\n\t\t\t\t\t// The only safe thing to do if there wasn't a default configuration for a built-in\n\t\t\t\t\t// target is to set the first defined configuration as the default\n\t\t\t\t\tIConfiguration[] newConfigs = newProject.getConfigurations();\n\t\t\t\t\tif (newConfigs.length > 0) {\n\t\t\t\t\t\tinfo.setDefaultConfiguration(newConfigs[0]);\n\t\t\t\t\t\tinfo.setSelectedConfiguration(newConfigs[0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (IndexOutOfBoundsException e) {\n\t\t\t\tthrow new CoreException(new Status(IStatus.ERROR, ManagedBuilderCorePlugin.getUniqueIdentifier(), -1,\n\t\t\t\t\t\tConverterMessages.getFormattedString(\"UpdateManagedProject12.7\", newProject.getName()), null)); //$NON-NLS-1$\n\t\t\t}\n\n\t\t\t// Upgrade the version\n\t\t\t((ManagedBuildInfo) info).setVersion(\"2.1.0\"); //$NON-NLS-1$\n\t\t\tinfo.setValid(true);\n\t\t} catch (CoreException e) {\n\t\t\tthrow e;\n\t\t} catch (Exception e) {\n\t\t\tthrow new CoreException(\n\t\t\t\t\tnew Status(IStatus.ERROR, ManagedBuilderCorePlugin.getUniqueIdentifier(), -1, e.getMessage(), e));\n\t\t} finally {\n\t\t\t// If the tree is locked spawn a job to this.\n\t\t\tIWorkspace workspace = project.getWorkspace();\n\t\t\t//\t\t\tboolean treeLock = workspace.isTreeLocked();\n\t\t\tISchedulingRule rule = workspace.getRuleFactory().createRule(project);\n\t\t\t//since the java synchronized mechanism is now used for the build info loadding,\n\t\t\t//initiate the job in all cases\n\t\t\t//\t\t\tif (treeLock) {\n\t\t\tWorkspaceJob job = new WorkspaceJob(ConverterMessages.getResourceString(\"UpdateManagedProject.notice\")) { //$NON-NLS-1$\n\t\t\t\t@Override\n\t\t\t\tpublic IStatus runInWorkspace(IProgressMonitor monitor) throws CoreException {\n\t\t\t\t\tManagedBuildManager.saveBuildInfoLegacy(project, false);\n\t\t\t\t\treturn Status.OK_STATUS;\n\t\t\t\t}\n\t\t\t};\n\t\t\tjob.setRule(rule);\n\t\t\tjob.schedule();\n\t\t\t//\t\t\t} else {\n\t\t\t//\t\t\t\tManagedBuildManager.saveBuildInfo(project, false);\n\t\t\t//\t\t\t}\n\t\t\tmonitor.done();\n\t\t}\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "web-feature-service",
    "cve_id": "CVE-2022-4607",
    "cwe_list": [
      "CWE-611"
    ],
    "commit_hash": "246f4e2a97ad81491c00a7ed72ce5e7c7f75050a",
    "short_hash": "246f4e2a",
    "vulnerableMethods_before": [
      {
        "filename": "CityGMLWriterBuilder.java",
        "method_name": "src/main/java/vcs/citydb/wfs/operation/getfeature/citygml/CityGMLWriterBuilder.java#initializeContext",
        "raw_code": "@Override\n\tpublic void initializeContext(\n\t\t\tGetFeatureType wfsRequest,\n\t\t\tList<QueryExpression> queryExpressions,\n\t\t\tMap<String, String> formatOptions,\n\t\t\tGeometryStripper geometryStripper,\n\t\t\tIdCacheManager idCacheManager,\n\t\t\tObject eventChannel,\n\t\t\tInternalConfig internalConfig,\n\t\t\tWFSConfig wfsConfig,\n\t\t\tConfig config) throws FeatureWriteException {\n\t\tthis.geometryStripper = geometryStripper;\n\t\tthis.idCacheManager = idCacheManager;\n\t\tthis.eventChannel = eventChannel;\n\t\tthis.internalConfig = internalConfig;\n\t\tthis.config = config;\n\n\t\tversion = queryExpressions.get(0).getTargetVersion();\n\n\t\tsaxWriter = new SAXWriter();\n\t\tsaxWriter.setWriteEncoding(true);\n\n\t\tif (\"true\".equals(formatOptions.get(PRETTY_PRINT)))\n\t\t\tsaxWriter.setIndentString(\" \");\n\n\t\t// set WFS prefix and schema location in case we do not have to return the bare feature\n\t\tif (queryExpressions.size() > 1 || !queryExpressions.get(0).isGetFeatureById()) {\n\t\t\tsaxWriter.setPrefix(Constants.WFS_NAMESPACE_PREFIX, Constants.WFS_NAMESPACE_URI);\n\t\t\tsaxWriter.setSchemaLocation(Constants.WFS_NAMESPACE_URI, Constants.WFS_SCHEMA_LOCATION);\n\t\t}\n\n\t\t// set CityGML prefixes and schema locations if we have to return feature instances\n\t\tif (wfsRequest.getResultType() == ResultTypeType.RESULTS) {\n\t\t\t// add default prefixes and schema locations\n\t\t\tModuleContext moduleContext = new ModuleContext(version);\n\n\t\t\tModule core = moduleContext.getModule(CityGMLModuleType.CORE);\n\t\t\tModule generics = moduleContext.getModule(CityGMLModuleType.GENERICS);\n\t\t\tsaxWriter.setPrefix(core.getNamespacePrefix(), core.getNamespaceURI());\n\t\t\tsaxWriter.setPrefix(generics.getNamespacePrefix(), generics.getNamespaceURI());\n\t\t\tsaxWriter.setSchemaLocation(generics.getNamespaceURI(), generics.getSchemaLocation());\n\t\t\tif (wfsConfig.getConstraints().isExportAppearance()) {\n\t\t\t\tModule appearance = moduleContext.getModule(CityGMLModuleType.APPEARANCE);\n\t\t\t\tsaxWriter.setPrefix(appearance.getNamespacePrefix(), appearance.getNamespaceURI());\n\t\t\t\tsaxWriter.setSchemaLocation(appearance.getNamespaceURI(), appearance.getSchemaLocation());\n\t\t\t}\n\n\t\t\t// add XML prefixes and schema locations for non-CityGML modules\n\t\t\tfor (Module module : moduleContext.getModules()) {\n\t\t\t\tif (!(module instanceof CityGMLModule)) {\n\t\t\t\t\t// skip 3DCityDB ADE prefix and namespace if metadata shall not be exported\n\t\t\t\t\tif ((module == CityDBADE200Module.v3_0 || module == CityDBADE100Module.v3_0)\n\t\t\t\t\t\t\t&& !wfsConfig.getConstraints().isExportCityDBMetadata())\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tsaxWriter.setPrefix(module.getNamespacePrefix(), module.getNamespaceURI());\n\t\t\t\t\tif (module instanceof ADEModule)\n\t\t\t\t\t\tsaxWriter.setSchemaLocation(module.getNamespaceURI(), module.getSchemaLocation());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// set XML prefixes and schema locations for selected feature types\n\t\t\tfor (QueryExpression queryExpression : queryExpressions) {\n\t\t\t\tfor (FeatureType featureType : queryExpression.getFeatureTypeFilter().getFeatureTypes()) {\n\t\t\t\t\tif (featureType.isAvailableForCityGML(version)) {\n\t\t\t\t\t\tCityGMLModule module = Modules.getCityGMLModule(featureType.getSchema().getNamespace(version).getURI());\n\t\t\t\t\t\tif (module != null) {\n\t\t\t\t\t\t\tsaxWriter.setPrefix(module.getNamespacePrefix(), module.getNamespaceURI());\n\t\t\t\t\t\t\tsaxWriter.setSchemaLocation(module.getNamespaceURI(), module.getSchemaLocation());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// build XSLT transformer chain\n\t\t\tif (wfsConfig.getPostProcessing().getXSLTransformation().isEnabled()\n\t\t\t\t\t&& wfsConfig.getPostProcessing().getXSLTransformation().isSetStylesheets()) {\n\t\t\t\ttry {\n\t\t\t\t\tList<String> stylesheets = wfsConfig.getPostProcessing().getXSLTransformation().getStylesheets();\n\t\t\t\t\tSAXTransformerFactory factory = (SAXTransformerFactory) TransformerFactory.newInstance();\n\t\t\t\t\tTemplates[] templates = new Templates[stylesheets.size()];\n\n\t\t\t\t\tfor (int i = 0; i < stylesheets.size(); i++) {\n\t\t\t\t\t\tTemplates template = factory.newTemplates(new StreamSource(new File(stylesheets.get(i))));\n\t\t\t\t\t\ttemplates[i] = template;\n\t\t\t\t\t}\n\n\t\t\t\t\ttransformerChainFactory = new TransformerChainFactory(templates);\n\t\t\t\t} catch (TransformerConfigurationException e) {\n\t\t\t\t\tlog.error(\"Failed to compile XSLT stylesheets.\");\n\t\t\t\t\tlog.error(\"Cause: \" + e.getMessage());\n\t\t\t\t\tthrow new FeatureWriteException(\"Failed to configure the XSL transformation.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "CityGMLWriterBuilder.java",
        "method_name": "src/main/java/vcs/citydb/wfs/operation/getfeature/citygml/CityGMLWriterBuilder.java#initializeContext",
        "raw_code": "@Override\n\tpublic void initializeContext(\n\t\t\tGetFeatureType wfsRequest,\n\t\t\tList<QueryExpression> queryExpressions,\n\t\t\tMap<String, String> formatOptions,\n\t\t\tGeometryStripper geometryStripper,\n\t\t\tIdCacheManager idCacheManager,\n\t\t\tObject eventChannel,\n\t\t\tInternalConfig internalConfig,\n\t\t\tWFSConfig wfsConfig,\n\t\t\tConfig config) throws FeatureWriteException {\n\t\tthis.geometryStripper = geometryStripper;\n\t\tthis.idCacheManager = idCacheManager;\n\t\tthis.eventChannel = eventChannel;\n\t\tthis.internalConfig = internalConfig;\n\t\tthis.config = config;\n\n\t\tversion = queryExpressions.get(0).getTargetVersion();\n\n\t\tsaxWriter = new SAXWriter();\n\t\tsaxWriter.setWriteEncoding(true);\n\n\t\tif (\"true\".equals(formatOptions.get(PRETTY_PRINT)))\n\t\t\tsaxWriter.setIndentString(\" \");\n\n\t\t// set WFS prefix and schema location in case we do not have to return the bare feature\n\t\tif (queryExpressions.size() > 1 || !queryExpressions.get(0).isGetFeatureById()) {\n\t\t\tsaxWriter.setPrefix(Constants.WFS_NAMESPACE_PREFIX, Constants.WFS_NAMESPACE_URI);\n\t\t\tsaxWriter.setSchemaLocation(Constants.WFS_NAMESPACE_URI, Constants.WFS_SCHEMA_LOCATION);\n\t\t}\n\n\t\t// set CityGML prefixes and schema locations if we have to return feature instances\n\t\tif (wfsRequest.getResultType() == ResultTypeType.RESULTS) {\n\t\t\t// add default prefixes and schema locations\n\t\t\tModuleContext moduleContext = new ModuleContext(version);\n\n\t\t\tModule core = moduleContext.getModule(CityGMLModuleType.CORE);\n\t\t\tModule generics = moduleContext.getModule(CityGMLModuleType.GENERICS);\n\t\t\tsaxWriter.setPrefix(core.getNamespacePrefix(), core.getNamespaceURI());\n\t\t\tsaxWriter.setPrefix(generics.getNamespacePrefix(), generics.getNamespaceURI());\n\t\t\tsaxWriter.setSchemaLocation(generics.getNamespaceURI(), generics.getSchemaLocation());\n\t\t\tif (wfsConfig.getConstraints().isExportAppearance()) {\n\t\t\t\tModule appearance = moduleContext.getModule(CityGMLModuleType.APPEARANCE);\n\t\t\t\tsaxWriter.setPrefix(appearance.getNamespacePrefix(), appearance.getNamespaceURI());\n\t\t\t\tsaxWriter.setSchemaLocation(appearance.getNamespaceURI(), appearance.getSchemaLocation());\n\t\t\t}\n\n\t\t\t// add XML prefixes and schema locations for non-CityGML modules\n\t\t\tfor (Module module : moduleContext.getModules()) {\n\t\t\t\tif (!(module instanceof CityGMLModule)) {\n\t\t\t\t\t// skip 3DCityDB ADE prefix and namespace if metadata shall not be exported\n\t\t\t\t\tif ((module == CityDBADE200Module.v3_0 || module == CityDBADE100Module.v3_0)\n\t\t\t\t\t\t\t&& !wfsConfig.getConstraints().isExportCityDBMetadata())\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tsaxWriter.setPrefix(module.getNamespacePrefix(), module.getNamespaceURI());\n\t\t\t\t\tif (module instanceof ADEModule)\n\t\t\t\t\t\tsaxWriter.setSchemaLocation(module.getNamespaceURI(), module.getSchemaLocation());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// set XML prefixes and schema locations for selected feature types\n\t\t\tfor (QueryExpression queryExpression : queryExpressions) {\n\t\t\t\tfor (FeatureType featureType : queryExpression.getFeatureTypeFilter().getFeatureTypes()) {\n\t\t\t\t\tif (featureType.isAvailableForCityGML(version)) {\n\t\t\t\t\t\tCityGMLModule module = Modules.getCityGMLModule(featureType.getSchema().getNamespace(version).getURI());\n\t\t\t\t\t\tif (module != null) {\n\t\t\t\t\t\t\tsaxWriter.setPrefix(module.getNamespacePrefix(), module.getNamespaceURI());\n\t\t\t\t\t\t\tsaxWriter.setSchemaLocation(module.getNamespaceURI(), module.getSchemaLocation());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// build XSLT transformer chain\n\t\t\tif (wfsConfig.getPostProcessing().getXSLTransformation().isEnabled()\n\t\t\t\t\t&& wfsConfig.getPostProcessing().getXSLTransformation().isSetStylesheets()) {\n\t\t\t\ttry {\n\t\t\t\t\tList<String> stylesheets = wfsConfig.getPostProcessing().getXSLTransformation().getStylesheets();\n\t\t\t\t\tSAXTransformerFactory factory = (SAXTransformerFactory) SecureXMLProcessors.newTransformerFactory();\n\t\t\t\t\tTemplates[] templates = new Templates[stylesheets.size()];\n\n\t\t\t\t\tfor (int i = 0; i < stylesheets.size(); i++) {\n\t\t\t\t\t\tTemplates template = factory.newTemplates(new StreamSource(new File(stylesheets.get(i))));\n\t\t\t\t\t\ttemplates[i] = template;\n\t\t\t\t\t}\n\n\t\t\t\t\ttransformerChainFactory = new TransformerChainFactory(templates);\n\t\t\t\t} catch (TransformerConfigurationException e) {\n\t\t\t\t\tlog.error(\"Failed to compile XSLT stylesheets.\");\n\t\t\t\t\tlog.error(\"Cause: \" + e.getMessage());\n\t\t\t\t\tthrow new FeatureWriteException(\"Failed to configure the XSL transformation.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "netty",
    "cve_id": "CVE-2021-21290",
    "cwe_list": [
      "CWE-379"
    ],
    "commit_hash": "c735357bf29d07856ad171c6611a2e1a0e0000ec",
    "short_hash": "c735357b",
    "vulnerableMethods_before": [
      {
        "filename": "SelfSignedCertificate.java",
        "method_name": "handler/src/main/java/io/netty/handler/ssl/util/SelfSignedCertificate.java#newSelfSignedCertificate",
        "raw_code": "static String[] newSelfSignedCertificate(\n            String fqdn, PrivateKey key, X509Certificate cert) throws IOException, CertificateEncodingException {\n        // Encode the private key into a file.\n        ByteBuf wrappedBuf = Unpooled.wrappedBuffer(key.getEncoded());\n        ByteBuf encodedBuf;\n        final String keyText;\n        try {\n            encodedBuf = Base64.encode(wrappedBuf, true);\n            try {\n                keyText = \"-----BEGIN PRIVATE KEY-----\\n\" +\n                        encodedBuf.toString(CharsetUtil.US_ASCII) +\n                        \"\\n-----END PRIVATE KEY-----\\n\";\n            } finally {\n                encodedBuf.release();\n            }\n        } finally {\n            wrappedBuf.release();\n        }\n\n        File keyFile = File.createTempFile(\"keyutil_\" + fqdn + '_', \".key\");\n        keyFile.deleteOnExit();\n\n        OutputStream keyOut = new FileOutputStream(keyFile);\n        try {\n            keyOut.write(keyText.getBytes(CharsetUtil.US_ASCII));\n            keyOut.close();\n            keyOut = null;\n        } finally {\n            if (keyOut != null) {\n                safeClose(keyFile, keyOut);\n                safeDelete(keyFile);\n            }\n        }\n\n        wrappedBuf = Unpooled.wrappedBuffer(cert.getEncoded());\n        final String certText;\n        try {\n            encodedBuf = Base64.encode(wrappedBuf, true);\n            try {\n                // Encode the certificate into a CRT file.\n                certText = \"-----BEGIN CERTIFICATE-----\\n\" +\n                        encodedBuf.toString(CharsetUtil.US_ASCII) +\n                        \"\\n-----END CERTIFICATE-----\\n\";\n            } finally {\n                encodedBuf.release();\n            }\n        } finally {\n            wrappedBuf.release();\n        }\n\n        File certFile = File.createTempFile(\"keyutil_\" + fqdn + '_', \".crt\");\n        certFile.deleteOnExit();\n\n        OutputStream certOut = new FileOutputStream(certFile);\n        try {\n            certOut.write(certText.getBytes(CharsetUtil.US_ASCII));\n            certOut.close();\n            certOut = null;\n        } finally {\n            if (certOut != null) {\n                safeClose(certFile, certOut);\n                safeDelete(certFile);\n                safeDelete(keyFile);\n            }\n        }\n\n        return new String[] { certFile.getPath(), keyFile.getPath() };\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SelfSignedCertificate.java",
        "method_name": "handler/src/main/java/io/netty/handler/ssl/util/SelfSignedCertificate.java#newSelfSignedCertificate",
        "raw_code": "static String[] newSelfSignedCertificate(\n            String fqdn, PrivateKey key, X509Certificate cert) throws IOException, CertificateEncodingException {\n        // Encode the private key into a file.\n        ByteBuf wrappedBuf = Unpooled.wrappedBuffer(key.getEncoded());\n        ByteBuf encodedBuf;\n        final String keyText;\n        try {\n            encodedBuf = Base64.encode(wrappedBuf, true);\n            try {\n                keyText = \"-----BEGIN PRIVATE KEY-----\\n\" +\n                        encodedBuf.toString(CharsetUtil.US_ASCII) +\n                        \"\\n-----END PRIVATE KEY-----\\n\";\n            } finally {\n                encodedBuf.release();\n            }\n        } finally {\n            wrappedBuf.release();\n        }\n\n        File keyFile = PlatformDependent.createTempFile(\"keyutil_\" + fqdn + '_', \".key\", null);\n        keyFile.deleteOnExit();\n\n        OutputStream keyOut = new FileOutputStream(keyFile);\n        try {\n            keyOut.write(keyText.getBytes(CharsetUtil.US_ASCII));\n            keyOut.close();\n            keyOut = null;\n        } finally {\n            if (keyOut != null) {\n                safeClose(keyFile, keyOut);\n                safeDelete(keyFile);\n            }\n        }\n\n        wrappedBuf = Unpooled.wrappedBuffer(cert.getEncoded());\n        final String certText;\n        try {\n            encodedBuf = Base64.encode(wrappedBuf, true);\n            try {\n                // Encode the certificate into a CRT file.\n                certText = \"-----BEGIN CERTIFICATE-----\\n\" +\n                        encodedBuf.toString(CharsetUtil.US_ASCII) +\n                        \"\\n-----END CERTIFICATE-----\\n\";\n            } finally {\n                encodedBuf.release();\n            }\n        } finally {\n            wrappedBuf.release();\n        }\n\n        File certFile = PlatformDependent.createTempFile(\"keyutil_\" + fqdn + '_', \".crt\", null);\n        certFile.deleteOnExit();\n\n        OutputStream certOut = new FileOutputStream(certFile);\n        try {\n            certOut.write(certText.getBytes(CharsetUtil.US_ASCII));\n            certOut.close();\n            certOut = null;\n        } finally {\n            if (certOut != null) {\n                safeClose(certFile, certOut);\n                safeDelete(certFile);\n                safeDelete(keyFile);\n            }\n        }\n\n        return new String[] { certFile.getPath(), keyFile.getPath() };\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "geoserver",
    "cve_id": "CVE-2025-21621",
    "cwe_list": [
      "CWE-79"
    ],
    "commit_hash": "dc9ff1c726dd73c884437a123b4ad72b19383c7d",
    "short_hash": "dc9ff1c7",
    "vulnerableMethods_before": [
      {
        "filename": "FreeMarkerTemplateManager.java",
        "method_name": "getTemplate",
        "raw_code": "private Template getTemplate(ResourceInfo ri, String templateFileName, Charset charset)\n            throws IOException {\n\n        synchronized (templateConfig) {\n            // setup template subsystem\n            if (templateLoader == null) {\n                templateLoader = new GeoServerTemplateLoader(getClass(), resourceLoader);\n            }\n            templateLoader.setResource(ri);\n            templateConfig.setTemplateLoader(templateLoader);\n            templateConfig.unsetOutputFormat();\n            if (format.equals(OutputFormat.HTML) && wms.isAutoEscapeTemplateValues()) {\n                templateConfig.setOutputFormat(HTMLOutputFormat.INSTANCE);\n            }\n            Template t = null;\n            try {\n                t = templateConfig.getTemplate(templateFileName);\n            } catch (FileNotFoundException ex) {\n                // throws exception just for text/html that completely rely on templates\n                if (format.equals(OutputFormat.HTML)) throw ex;\n            }\n\n            return t;\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FreeMarkerTemplateManager.java",
        "method_name": "getTemplate",
        "raw_code": "private Template getTemplate(ResourceInfo ri, String templateFileName, Charset charset)\n            throws IOException {\n\n        synchronized (templateConfig) {\n            // setup template subsystem\n            if (templateLoader == null) {\n                templateLoader = new GeoServerTemplateLoader(getClass(), resourceLoader);\n            }\n            templateLoader.setResource(ri);\n            templateConfig.setTemplateLoader(templateLoader);\n            templateConfig.unsetOutputFormat();\n            if (format.equals(OutputFormat.HTML)) {\n                String prop = GeoServerExtensions.getProperty(FORCE_FREEMARKER_ESCAPING);\n                if (!\"false\".equalsIgnoreCase(prop) || wms.isAutoEscapeTemplateValues()) {\n                    templateConfig.setOutputFormat(HTMLOutputFormat.INSTANCE);\n                }\n            }\n            Template t = null;\n            try {\n                t = templateConfig.getTemplate(templateFileName);\n            } catch (FileNotFoundException ex) {\n                // throws exception just for text/html that completely rely on templates\n                if (format.equals(OutputFormat.HTML)) throw ex;\n            }\n\n            return t;\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "snyk-eclipse-plugin",
    "cve_id": "CVE-2022-24441",
    "cwe_list": [
      "CWE-78"
    ],
    "commit_hash": "b5a8bce25a359ced75f83a729fc6b2393fc9a495",
    "short_hash": "b5a8bce2",
    "vulnerableMethods_before": [],
    "vulnerableMethods_after": [
      {
        "filename": "SnykWizard.java",
        "method_name": "plugin/src/main/java/io/snyk/eclipse/plugin/wizards/SnykWizard.java#performFinish",
        "raw_code": "public boolean performFinish() {\n    new LsConfigurationUpdater().configurationChanged();\n    SnykExtendedLanguageClient.getInstance().triggerAuthentication();\n    SnykExtendedLanguageClient.getInstance().trustWorkspaceFolders();\n    return true;\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "jai-ext",
    "cve_id": "CVE-2022-24816",
    "cwe_list": [
      "CWE-94"
    ],
    "commit_hash": "cb1d6565d38954676b0a366da4f965fef38da1cb",
    "short_hash": "cb1d6565",
    "vulnerableMethods_before": [
      {
        "filename": "Jiffle.java",
        "method_name": "jt-jiffle/jt-jiffle-language/src/main/java/it/geosolutions/jaiext/jiffle/Jiffle.java#getRuntimeInstance",
        "raw_code": "public <T extends JiffleRuntime> T getRuntimeInstance(Class<T> baseClass) throws\n            it.geosolutions.jaiext.jiffle.JiffleException {\n        RuntimeModel model = RuntimeModel.get(baseClass);\n        if (model == null) {\n            throw new it.geosolutions.jaiext.jiffle.JiffleException(baseClass.getName() +\n                    \" does not implement a required Jiffle runtime interface\");\n        }\n\n        return (T) createRuntimeInstance(model, baseClass, false);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "Jiffle.java",
        "method_name": "jt-jiffle/jt-jiffle-language/src/main/java/it/geosolutions/jaiext/jiffle/Jiffle.java#getRuntimeInstance",
        "raw_code": "public <T extends JiffleRuntime> T getRuntimeInstance(Class<T> baseClass) throws\n            it.geosolutions.jaiext.jiffle.JiffleException {\n        RuntimeModel model = RuntimeModel.get(baseClass);\n        if (model == null) {\n            throw new it.geosolutions.jaiext.jiffle.JiffleException(baseClass.getName() +\n                    \" does not implement a required Jiffle runtime interface\");\n        }\n\n        return (T) createRuntimeInstance(model, baseClass, includeScript);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2024-31981",
    "cwe_list": [
      "CWE-862"
    ],
    "commit_hash": "480186f9d2fca880513da8bc5a609674d106cbd3",
    "short_hash": "480186f9",
    "vulnerableMethods_before": [
      {
        "filename": "PdfExportImpl.java",
        "method_name": "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/pdf/impl/PdfExportImpl.java#getPDFTemplateProperty",
        "raw_code": "private String getPDFTemplateProperty(String propertyName, XWikiContext context)\n    {\n        String pdftemplate = context.getRequest().getParameter(\"pdftemplate\");\n\n        DocumentReference templateReference;\n        DocumentReference classReference;\n        if (StringUtils.isNotEmpty(pdftemplate)) {\n            templateReference = referenceResolver.resolve(pdftemplate);\n            classReference = new DocumentReference(templateReference.getWikiReference().getName(), \"XWiki\", \"PDFClass\");\n        } else {\n            templateReference = dab.getCurrentDocumentReference();\n            String currentWiki = dab.getCurrentDocumentReference().getRoot().getName();\n            classReference = new DocumentReference(currentWiki, \"XWiki\", \"PDFClass\");\n        }\n\n        String result = (String) dab.getProperty(templateReference, classReference, propertyName);\n        if (StringUtils.isBlank(result)) {\n            return \"\";\n        }\n        String templateName = referenceSerializer.serialize(templateReference);\n        try {\n            StringWriter writer = new StringWriter();\n            VelocityContext vcontext = velocityManager.getVelocityContext();\n            velocityManager.getVelocityEngine().evaluate(vcontext, writer, templateName, result);\n            result = writer.toString();\n        } catch (XWikiVelocityException e) {\n            LOGGER.warn(\"Error applying Velocity to the [{}] property of the [{}] document. Using the property's value \"\n                + \"without applying Velocity.\", propertyName, templateName, ExceptionUtils.getRootCauseMessage(e));\n        }\n        return result;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "PdfExportImpl.java",
        "method_name": "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/pdf/impl/PdfExportImpl.java#getPDFTemplateProperty",
        "raw_code": "private String getPDFTemplateProperty(String propertyName, XWikiContext context)\n    {\n        String pdftemplate = context.getRequest().getParameter(\"pdftemplate\");\n\n        DocumentReference templateReference;\n        DocumentReference classReference;\n        if (StringUtils.isNotEmpty(pdftemplate)) {\n            templateReference = this.referenceResolver.resolve(pdftemplate);\n            classReference = new DocumentReference(templateReference.getWikiReference().getName(), \"XWiki\", \"PDFClass\");\n        } else {\n            templateReference = this.dab.getCurrentDocumentReference();\n            String currentWiki = this.dab.getCurrentDocumentReference().getRoot().getName();\n            classReference = new DocumentReference(currentWiki, \"XWiki\", \"PDFClass\");\n        }\n\n        String templateContent = (String) this.dab.getProperty(templateReference, classReference, propertyName);\n        if (StringUtils.isBlank(templateContent)) {\n            return \"\";\n        }\n\n        String templateName = this.referenceSerializer.serialize(templateReference);\n        DocumentReference templateAuthorReference;\n        String result = templateContent;\n        try {\n             templateAuthorReference = this.userReferenceSerializer.serialize(\n                 this.dab.getDocumentInstance(templateReference).getAuthors().getEffectiveMetadataAuthor());\n        } catch (Exception e) {\n            LOGGER.warn(\"Error fetching the author of template [{}] during PDF conversion. Using the [{}] property of \"\n                + \"the document's value without applying Velocity.\", templateName, propertyName);\n            return result;\n        }\n\n        if (this.authorizationManager.hasAccess(Right.SCRIPT, templateAuthorReference, templateReference)) {\n            try {\n                result = this.authorExecutor.call(() -> {\n                    StringWriter writer = new StringWriter();\n                    VelocityContext vcontext = this.velocityManager.getVelocityContext();\n                    this.velocityManager.getVelocityEngine().evaluate(vcontext, writer, templateName,\n                        templateContent);\n                    return writer.toString();\n                }, templateAuthorReference, templateReference);\n            } catch (Exception e) {\n                LOGGER.warn(\"Failed to run Velocity engine in author executor. Using the [{}] property of the [{}] \"\n                    + \"document's value without applying Velocity. Reason: [{}]\",\n                    propertyName, templateName, ExceptionUtils.getRootCauseMessage(e));\n            }\n        }\n\n        return result;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "geotools",
    "cve_id": "CVE-2023-25158",
    "cwe_list": [
      "CWE-89"
    ],
    "commit_hash": "64fb4c47f43ca818c2fe96a94651bff1b3b3ed2b",
    "short_hash": "64fb4c47",
    "vulnerableMethods_before": [
      {
        "filename": "LikeFilterImpl.java",
        "method_name": "modules/library/main/src/main/java/org/geotools/filter/LikeFilterImpl.java#getSQL92LikePattern",
        "raw_code": "public String getSQL92LikePattern() throws IllegalArgumentException {\n        if (escape.length() != 1) {\n            throw new IllegalArgumentException(\n                    \"Like Pattern --> escape char should be of length exactly 1\");\n        }\n        if (wildcardSingle.length() != 1) {\n            throw new IllegalArgumentException(\n                    \"Like Pattern --> wildcardSingle char should be of length exactly 1\");\n        }\n        if (wildcardMulti.length() != 1) {\n            throw new IllegalArgumentException(\n                    \"Like Pattern --> wildcardMulti char should be of length exactly 1\");\n        }\n        return LikeFilterImpl.convertToSQL92(\n                escape.charAt(0),\n                wildcardMulti.charAt(0),\n                wildcardSingle.charAt(0),\n                matchingCase,\n                pattern);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "LikeFilterImpl.java",
        "method_name": "modules/library/main/src/main/java/org/geotools/filter/LikeFilterImpl.java#getSQL92LikePattern",
        "raw_code": "@Deprecated\n    public String getSQL92LikePattern() throws IllegalArgumentException {\n        if (escape.length() != 1) {\n            throw new IllegalArgumentException(\n                    \"Like Pattern --> escape char should be of length exactly 1\");\n        }\n        if (wildcardSingle.length() != 1) {\n            throw new IllegalArgumentException(\n                    \"Like Pattern --> wildcardSingle char should be of length exactly 1\");\n        }\n        if (wildcardMulti.length() != 1) {\n            throw new IllegalArgumentException(\n                    \"Like Pattern --> wildcardMulti char should be of length exactly 1\");\n        }\n        return LikeFilterImpl.convertToSQL92(\n                escape.charAt(0),\n                wildcardMulti.charAt(0),\n                wildcardSingle.charAt(0),\n                matchingCase,\n                pattern,\n                true);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2023-29523",
    "cwe_list": [
      "CWE-74"
    ],
    "commit_hash": "0d547181389f7941e53291af940966413823f61c",
    "short_hash": "0d547181",
    "vulnerableMethods_before": [
      {
        "filename": "XWikiDocument.java",
        "method_name": "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/doc/XWikiDocument.java#display",
        "raw_code": "public String display(String fieldname, String type, String pref, BaseObject obj, String wrappingSyntaxId,\n        boolean isolated, XWikiContext context)\n    {\n        if (obj == null) {\n            return \"\";\n        }\n\n        boolean isInRenderingEngine = BooleanUtils.toBoolean((Boolean) context.get(\"isInRenderingEngine\"));\n        HashMap<String, Object> backup = new HashMap<String, Object>();\n        XWikiDocument currentSDoc = (XWikiDocument )context.get(CKEY_SDOC);\n        try {\n            if (isolated) {\n                backupContext(backup, context);\n                setAsContextDoc(context);\n            }\n\n            // Make sure to execute with the right of the document author instead of the content author\n            // (because modifying object property does not modify content author)\n            XWikiDocument sdoc = obj.getOwnerDocument();\n            if (sdoc != null && !Objects.equals(sdoc.getContentAuthorReference(), sdoc.getAuthorReference())) {\n                // Hack the sdoc to make test module believe the content author is the author\n                sdoc = sdoc.clone();\n                sdoc.setContentAuthorReference(sdoc.getAuthorReference());\n                context.put(CKEY_SDOC, sdoc);\n            }\n\n            type = type.toLowerCase();\n            StringBuffer result = new StringBuffer();\n            PropertyClass pclass = (PropertyClass) obj.getXClass(context).get(fieldname);\n            String prefix = pref + LOCAL_REFERENCE_SERIALIZER.serialize(obj.getXClass(context).getDocumentReference())\n                + \"_\" + obj.getNumber() + \"_\";\n\n            if (pclass == null) {\n                return \"\";\n            } else if (pclass.isCustomDisplayed(context)) {\n                pclass.displayCustom(result, fieldname, prefix, type, obj, context);\n            } else if (type.equals(\"view\")) {\n                pclass.displayView(result, fieldname, prefix, obj, isolated, context);\n            } else if (type.equals(\"rendered\")) {\n                String fcontent = pclass.displayView(fieldname, prefix, obj, context);\n                // This mode is deprecated for the new rendering and should also be removed for the old rendering\n                // since the way to implement this now is to choose the type of rendering to do in the class itself.\n                // Thus for the new rendering we simply make this mode work like the \"view\" mode.\n                if (is10Syntax(wrappingSyntaxId)) {\n                    result.append(getRenderedContent(fcontent, getSyntaxId(), context));\n                } else {\n                    result.append(fcontent);\n                }\n            } else if (type.equals(\"edit\")) {\n                context.addDisplayedField(fieldname);\n                // If the Syntax id is \"xwiki/1.0\" then use the old rendering subsystem and prevent wiki syntax\n                // rendering using the pre macro. In the new rendering system it's the XWiki Class itself that does the\n                // escaping. For example for a textarea check the TextAreaClass class.\n                if (is10Syntax(wrappingSyntaxId)) {\n                    // Don't use pre when not in the rendernig engine since for template we don't evaluate wiki syntax.\n                    if (isInRenderingEngine) {\n                        result.append(\"{pre}\");\n                    }\n                }\n                pclass.displayEdit(result, fieldname, prefix, obj, context);\n                if (is10Syntax(wrappingSyntaxId)) {\n                    if (isInRenderingEngine) {\n                        result.append(\"{/pre}\");\n                    }\n                }\n            } else if (type.equals(\"hidden\")) {\n                // If the Syntax id is \"xwiki/1.0\" then use the old rendering subsystem and prevent wiki syntax\n                // rendering using the pre macro. In the new rendering system it's the XWiki Class itself that does the\n                // escaping. For example for a textarea check the TextAreaClass class.\n                if (is10Syntax(wrappingSyntaxId) && isInRenderingEngine) {\n                    result.append(\"{pre}\");\n                }\n                pclass.displayHidden(result, fieldname, prefix, obj, context);\n                if (is10Syntax(wrappingSyntaxId) && isInRenderingEngine) {\n                    result.append(\"{/pre}\");\n                }\n            } else if (type.equals(\"search\")) {\n                // Backward compatibility\n\n                // Check if the method has been injected using aspects\n                Method searchMethod = null;\n                for (Method method : pclass.getClass().getMethods()) {\n                    if (method.getName().equals(\"displaySearch\") && method.getParameterTypes().length == 5) {\n                        searchMethod = method;\n                        break;\n                    }\n                }\n\n                if (searchMethod != null) {\n                    // If the Syntax id is \"xwiki/1.0\" then use the old rendering subsystem and prevent wiki syntax\n                    // rendering using the pre macro. In the new rendering system it's the XWiki Class itself that does\n                    // the\n                    // escaping. For example for a textarea check the TextAreaClass class.\n                    if (is10Syntax(wrappingSyntaxId) && isInRenderingEngine) {\n                        result.append(\"{pre}\");\n                    }\n                    prefix = LOCAL_REFERENCE_SERIALIZER.serialize(obj.getXClass(context).getDocumentReference()) + \"_\";\n                    searchMethod.invoke(pclass, result, fieldname, prefix, context.get(\"query\"), context);\n                    if (is10Syntax(wrappingSyntaxId) && isInRenderingEngine) {\n                        result.append(\"{/pre}\");\n                    }\n                } else {\n                    pclass.displayView(result, fieldname, prefix, obj, context);\n                }\n            } else {\n                pclass.displayView(result, fieldname, prefix, obj, context);\n            }\n\n            // If we're in new rendering engine we want to wrap the HTML returned by displayView() in\n            // a {{html/}} macro so that the user doesn't have to do it.\n            // We test if we're inside the rendering engine since it's also possible that this display() method is\n            // called directly from a template and in this case we only want HTML as a result and not wiki syntax.\n            // TODO: find a more generic way to handle html macro because this works only for XWiki 1.0 and XWiki 2.0\n            // Add the {{html}}{{/html}} only when result really contains html since it's not needed for pure text\n            if (isInRenderingEngine && !is10Syntax(wrappingSyntaxId) && HTMLUtils.containsElementText(result)) {\n                result.insert(0, \"{{html clean=\\\"false\\\" wiki=\\\"false\\\"}}\");\n                result.append(\"{{/html}}\");\n            }\n\n            return result.toString();\n        } catch (Exception ex) {\n            // TODO: It would better to check if the field exists rather than catching an exception\n            // raised by a NPE as this is currently the case here...\n            LOGGER.warn(\"Failed to display field [\" + fieldname + \"] in [\" + type + \"] mode for Object of Class [\"\n                + getDefaultEntityReferenceSerializer().serialize(obj.getDocumentReference()) + \"]\", ex);\n            return \"\";\n        } finally {\n            if (!backup.isEmpty()) {\n                restoreContext(backup, context);\n            }\n            context.put(CKEY_SDOC, currentSDoc);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XWikiDocument.java",
        "method_name": "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/doc/XWikiDocument.java#display",
        "raw_code": "public String display(String fieldname, String type, String pref, BaseObject obj, String wrappingSyntaxId,\n        boolean isolated, XWikiContext context)\n    {\n        if (obj == null) {\n            return \"\";\n        }\n\n        boolean isInRenderingEngine = BooleanUtils.toBoolean((Boolean) context.get(\"isInRenderingEngine\"));\n        HashMap<String, Object> backup = new HashMap<String, Object>();\n        XWikiDocument currentSDoc = (XWikiDocument )context.get(CKEY_SDOC);\n        try {\n            if (isolated) {\n                backupContext(backup, context);\n                setAsContextDoc(context);\n            }\n\n            // Make sure to execute with the right of the document author instead of the content author\n            // (because modifying object property does not modify content author)\n            XWikiDocument sdoc = obj.getOwnerDocument();\n            if (sdoc != null && !Objects.equals(sdoc.getContentAuthorReference(), sdoc.getAuthorReference())) {\n                // Hack the sdoc to make test module believe the content author is the author\n                sdoc = sdoc.clone();\n                sdoc.setContentAuthorReference(sdoc.getAuthorReference());\n                context.put(CKEY_SDOC, sdoc);\n            }\n\n            type = type.toLowerCase();\n            StringBuffer result = new StringBuffer();\n            PropertyClass pclass = (PropertyClass) obj.getXClass(context).get(fieldname);\n            String prefix = pref + LOCAL_REFERENCE_SERIALIZER.serialize(obj.getXClass(context).getDocumentReference())\n                + \"_\" + obj.getNumber() + \"_\";\n\n            if (pclass == null) {\n                return \"\";\n            } else if (pclass.isCustomDisplayed(context)) {\n                pclass.displayCustom(result, fieldname, prefix, type, obj, context);\n            } else if (type.equals(\"view\")) {\n                pclass.displayView(result, fieldname, prefix, obj, isolated, context);\n            } else if (type.equals(\"rendered\")) {\n                String fcontent = pclass.displayView(fieldname, prefix, obj, context);\n                // This mode is deprecated for the new rendering and should also be removed for the old rendering\n                // since the way to implement this now is to choose the type of rendering to do in the class itself.\n                // Thus for the new rendering we simply make this mode work like the \"view\" mode.\n                if (is10Syntax(wrappingSyntaxId)) {\n                    result.append(getRenderedContent(fcontent, getSyntaxId(), context));\n                } else {\n                    result.append(fcontent);\n                }\n            } else if (type.equals(\"edit\")) {\n                context.addDisplayedField(fieldname);\n                // If the Syntax id is \"xwiki/1.0\" then use the old rendering subsystem and prevent wiki syntax\n                // rendering using the pre macro. In the new rendering system it's the XWiki Class itself that does the\n                // escaping. For example for a textarea check the TextAreaClass class.\n                if (is10Syntax(wrappingSyntaxId)) {\n                    // Don't use pre when not in the rendernig engine since for template we don't evaluate wiki syntax.\n                    if (isInRenderingEngine) {\n                        result.append(\"{pre}\");\n                    }\n                }\n                pclass.displayEdit(result, fieldname, prefix, obj, context);\n                if (is10Syntax(wrappingSyntaxId)) {\n                    if (isInRenderingEngine) {\n                        result.append(\"{/pre}\");\n                    }\n                }\n            } else if (type.equals(\"hidden\")) {\n                // If the Syntax id is \"xwiki/1.0\" then use the old rendering subsystem and prevent wiki syntax\n                // rendering using the pre macro. In the new rendering system it's the XWiki Class itself that does the\n                // escaping. For example for a textarea check the TextAreaClass class.\n                if (is10Syntax(wrappingSyntaxId) && isInRenderingEngine) {\n                    result.append(\"{pre}\");\n                }\n                pclass.displayHidden(result, fieldname, prefix, obj, context);\n                if (is10Syntax(wrappingSyntaxId) && isInRenderingEngine) {\n                    result.append(\"{/pre}\");\n                }\n            } else if (type.equals(\"search\")) {\n                // Backward compatibility\n\n                // Check if the method has been injected using aspects\n                Method searchMethod = null;\n                for (Method method : pclass.getClass().getMethods()) {\n                    if (method.getName().equals(\"displaySearch\") && method.getParameterTypes().length == 5) {\n                        searchMethod = method;\n                        break;\n                    }\n                }\n\n                if (searchMethod != null) {\n                    // If the Syntax id is \"xwiki/1.0\" then use the old rendering subsystem and prevent wiki syntax\n                    // rendering using the pre macro. In the new rendering system it's the XWiki Class itself that does\n                    // the\n                    // escaping. For example for a textarea check the TextAreaClass class.\n                    if (is10Syntax(wrappingSyntaxId) && isInRenderingEngine) {\n                        result.append(\"{pre}\");\n                    }\n                    prefix = LOCAL_REFERENCE_SERIALIZER.serialize(obj.getXClass(context).getDocumentReference()) + \"_\";\n                    searchMethod.invoke(pclass, result, fieldname, prefix, context.get(\"query\"), context);\n                    if (is10Syntax(wrappingSyntaxId) && isInRenderingEngine) {\n                        result.append(\"{/pre}\");\n                    }\n                } else {\n                    pclass.displayView(result, fieldname, prefix, obj, context);\n                }\n            } else {\n                pclass.displayView(result, fieldname, prefix, obj, context);\n            }\n\n            // If we're in new rendering engine we want to wrap the HTML returned by displayView() in\n            // a {{html/}} macro so that the user doesn't have to do it.\n            // We test if we're inside the rendering engine since it's also possible that this display() method is\n            // called directly from a template and in this case we only want HTML as a result and not wiki syntax.\n            // TODO: find a more generic way to handle html macro because this works only for XWiki 1.0 and XWiki 2.0\n            // Add the {{html}}{{/html}} only when result really contains html or { which could be part of an XWiki\n            // macro syntax since it's not needed for pure text\n            if (isInRenderingEngine && !is10Syntax(wrappingSyntaxId)\n                && (HTMLUtils.containsElementText(result) || result.indexOf(\"{\") != -1))\n            {\n                result.insert(0, \"{{html clean=\\\"false\\\" wiki=\\\"false\\\"}}\");\n                // Escape closing HTML macro syntax.\n                int startIndex = 0;\n                // Start searching at the last match to avoid scanning the whole string again.\n                while ((startIndex = result.indexOf(CLOSE_HTML_MACRO, startIndex)) != -1) {\n                    result.replace(startIndex, startIndex + 2, \"&#123;&#123;\");\n                }\n                result.append(CLOSE_HTML_MACRO);\n            }\n\n            return result.toString();\n        } catch (Exception ex) {\n            // TODO: It would better to check if the field exists rather than catching an exception\n            // raised by a NPE as this is currently the case here...\n            LOGGER.warn(\"Failed to display field [\" + fieldname + \"] in [\" + type + \"] mode for Object of Class [\"\n                + getDefaultEntityReferenceSerializer().serialize(obj.getDocumentReference()) + \"]\", ex);\n            return \"\";\n        } finally {\n            if (!backup.isEmpty()) {\n                restoreContext(backup, context);\n            }\n            context.put(CKEY_SDOC, currentSDoc);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "hibernate-validator",
    "cve_id": "CVE-2025-35036",
    "cwe_list": [
      "CWE-94"
    ],
    "commit_hash": "05f795bb7cf18856004f40e5042709e550ed0d6e",
    "short_hash": "05f795bb",
    "vulnerableMethods_before": [
      {
        "filename": "ParameterExecutableValidationContext.java",
        "method_name": "createConstraintValidatorContextFor",
        "raw_code": "@Override\n\tpublic ConstraintValidatorContextImpl createConstraintValidatorContextFor(ConstraintDescriptorImpl<?> constraintDescriptor, PathImpl path) {\n\t\tif ( ConstraintType.CROSS_PARAMETER.equals( constraintDescriptor.getConstraintType() ) ) {\n\t\t\treturn new CrossParameterConstraintValidatorContextImpl(\n\t\t\t\t\tgetParameterNames(),\n\t\t\t\t\tvalidatorScopedContext.getClockProvider(),\n\t\t\t\t\tpath,\n\t\t\t\t\tconstraintDescriptor,\n\t\t\t\t\tvalidatorScopedContext.getConstraintValidatorPayload()\n\t\t\t);\n\t\t}\n\n\t\treturn new ConstraintValidatorContextImpl(\n\t\t\t\tvalidatorScopedContext.getClockProvider(),\n\t\t\t\tpath,\n\t\t\t\tconstraintDescriptor,\n\t\t\t\tvalidatorScopedContext.getConstraintValidatorPayload()\n\t\t);\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ParameterExecutableValidationContext.java",
        "method_name": "createConstraintValidatorContextFor",
        "raw_code": "@Override\n\tpublic ConstraintValidatorContextImpl createConstraintValidatorContextFor(ConstraintDescriptorImpl<?> constraintDescriptor, PathImpl path) {\n\t\tif ( ConstraintType.CROSS_PARAMETER.equals( constraintDescriptor.getConstraintType() ) ) {\n\t\t\treturn new CrossParameterConstraintValidatorContextImpl(\n\t\t\t\t\tgetParameterNames(),\n\t\t\t\t\tvalidatorScopedContext.getClockProvider(),\n\t\t\t\t\tpath,\n\t\t\t\t\tconstraintDescriptor,\n\t\t\t\t\tvalidatorScopedContext.getConstraintValidatorPayload(),\n\t\t\t\t\tvalidatorScopedContext.getConstraintExpressionLanguageFeatureLevel(),\n\t\t\t\t\tvalidatorScopedContext.getCustomViolationExpressionLanguageFeatureLevel()\n\t\t\t);\n\t\t}\n\n\t\treturn new ConstraintValidatorContextImpl(\n\t\t\t\tvalidatorScopedContext.getClockProvider(),\n\t\t\t\tpath,\n\t\t\t\tconstraintDescriptor,\n\t\t\t\tvalidatorScopedContext.getConstraintValidatorPayload(),\n\t\t\t\tvalidatorScopedContext.getConstraintExpressionLanguageFeatureLevel(),\n\t\t\t\tvalidatorScopedContext.getCustomViolationExpressionLanguageFeatureLevel()\n\t\t);\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "bc-java",
    "cve_id": "CVE-2016-1000339",
    "cwe_list": [
      "CWE-310"
    ],
    "commit_hash": "8a73f08931450c17c749af067b6a8185abdfd2c0#diff-494fb066bed02aeb76b6c005632943f2",
    "short_hash": "8a73f089",
    "vulnerableMethods_before": [
      {
        "filename": "DRBG.java",
        "method_name": "generateDefaultPersonalizationString",
        "raw_code": "private static byte[] generateDefaultPersonalizationString()\n    {\n        return Arrays.concatenate(Strings.toByteArray(\"Default\"), Strings.toUTF8ByteArray(getVIMID()),\n            Pack.longToBigEndian(Thread.currentThread().getId()), Pack.longToBigEndian(System.currentTimeMillis()));\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DRBG.java",
        "method_name": "generateDefaultPersonalizationString",
        "raw_code": "private static byte[] generateDefaultPersonalizationString(SecureRandom random)\n    {\n        return Arrays.concatenate(Strings.toByteArray(\"Default\"), random.generateSeed(16),\n            Pack.longToBigEndian(Thread.currentThread().getId()), Pack.longToBigEndian(System.currentTimeMillis()));\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "dataease",
    "cve_id": "CVE-2024-47074",
    "cwe_list": [
      "CWE-502"
    ],
    "commit_hash": "86eafc4d77f0bbc0eaa7fc58e5076a085257f259",
    "short_hash": "86eafc4d",
    "vulnerableMethods_before": [],
    "vulnerableMethods_after": [
      {
        "filename": "PgConfiguration.java",
        "method_name": "core/backend/src/main/java/io/dataease/dto/datasource/PgConfiguration.java#getJdbc",
        "raw_code": "public String getJdbc() {\n        if (StringUtils.isEmpty(extraParams.trim())) {\n            if (StringUtils.isEmpty(getSchema())) {\n                return \"jdbc:postgresql://HOSTNAME:PORT/DATABASE\"\n                        .replace(\"HOSTNAME\", getHost().trim())\n                        .replace(\"PORT\", getPort().toString().trim())\n                        .replace(\"DATABASE\", getDataBase().trim());\n            } else {\n                return \"jdbc:postgresql://HOSTNAME:PORT/DATABASE?currentSchema=SCHEMA\"\n                        .replace(\"HOSTNAME\", getHost().trim())\n                        .replace(\"PORT\", getPort().toString().trim())\n                        .replace(\"DATABASE\", getDataBase().trim())\n                        .replace(\"SCHEMA\", getSchema().trim());\n            }\n        } else {\n            for (String illegalParameter : illegalParameters) {\n                if (getExtraParams().toLowerCase().contains(illegalParameter.toLowerCase()) || URLDecoder.decode(getExtraParams()).contains(illegalParameter.toLowerCase())) {\n                    throw new RuntimeException(\"Illegal parameter: \" + illegalParameter);\n                }\n            }\n            return \"jdbc:postgresql://HOSTNAME:PORT/DATABASE?EXTRA_PARAMS\"\n                    .replace(\"HOSTNAME\", getHost().trim())\n                    .replace(\"PORT\", getPort().toString().trim())\n                    .replace(\"DATABASE\", getDataBase().trim())\n                    .replace(\"EXTRA_PARAMS\", getExtraParams().trim());\n\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "shopizer",
    "cve_id": "CVE-2022-23061",
    "cwe_list": [
      "CWE-639"
    ],
    "commit_hash": "6b9f1ecd303b3b724d96bd08095c1a751dcc287e",
    "short_hash": "6b9f1ecd",
    "vulnerableMethods_before": [],
    "vulnerableMethods_after": [
      {
        "filename": "PersistableProductOptionValueMapper.java",
        "method_name": "sm-shop/src/main/java/com/salesmanager/shop/mapper/catalog/PersistableProductOptionValueMapper.java#description",
        "raw_code": "ProductOptionValueDescription description(\n\t\t\tcom.salesmanager.shop.model.catalog.product.attribute.ProductOptionValueDescription description)\n\t\t\tthrows Exception {\n\t\tValidate.notNull(description.getLanguage(), \"description.language should not be null\");\n\t\tProductOptionValueDescription desc = new ProductOptionValueDescription();\n\t\tdesc.setId(null);\n\t\tdesc.setDescription(description.getDescription());\n\t\tdesc.setName(description.getName());\n\t\tif(StringUtils.isBlank(desc.getName())) {\n\t\t\tdesc.setName(description.getDescription());\n\t\t}\n\t\tif (description.getId() != null && description.getId().longValue() > 0) {\n\t\t\tdesc.setId(description.getId());\n\t\t}\n\t\tLanguage lang = languageService.getByCode(description.getLanguage());\n\t\tdesc.setLanguage(lang);\n\t\treturn desc;\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "geotools",
    "cve_id": "CVE-2022-24818",
    "cwe_list": [
      "CWE-917"
    ],
    "commit_hash": "4f70fa3234391dd0cda883a20ab0ec75688cba49",
    "short_hash": "4f70fa32",
    "vulnerableMethods_before": [
      {
        "filename": "AbstractEpsgMediator.java",
        "method_name": "modules/library/referencing/src/main/java/org/geotools/referencing/factory/AbstractEpsgMediator.java#lookupDataSource",
        "raw_code": "static DataSource lookupDataSource(Hints hints) throws FactoryException {\n        Object hint = hints.get(Hints.EPSG_DATA_SOURCE);\n        if (hint instanceof DataSource) {\n            return (DataSource) hint;\n        } else if (hint instanceof String) {\n            String name = (String) hint;\n            InitialContext context;\n            try {\n                context = GeoTools.getInitialContext();\n                // name = GeoTools.fixName( context, name );\n                return (DataSource) context.lookup(name);\n            } catch (Exception e) {\n                throw new FactoryException(\"EPSG_DATA_SOURCE '\" + name + \"' not found:\" + e, e);\n            }\n        }\n        throw new FactoryException(\"EPSG_DATA_SOURCE must be provided\");\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AbstractEpsgMediator.java",
        "method_name": "modules/library/referencing/src/main/java/org/geotools/referencing/factory/AbstractEpsgMediator.java#lookupDataSource",
        "raw_code": "static DataSource lookupDataSource(Hints hints) throws FactoryException {\n        Object hint = hints.get(Hints.EPSG_DATA_SOURCE);\n        if (hint instanceof DataSource) {\n            return (DataSource) hint;\n        } else if (hint instanceof String) {\n            String name = (String) hint;\n            try {\n                return (DataSource) GeoTools.jndiLookup(name);\n            } catch (Exception e) {\n                throw new FactoryException(\"EPSG_DATA_SOURCE '\" + name + \"' not found:\" + e, e);\n            }\n        }\n        throw new FactoryException(\"EPSG_DATA_SOURCE must be provided\");\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "geotools",
    "cve_id": "CVE-2022-24818",
    "cwe_list": [
      "CWE-917"
    ],
    "commit_hash": "4f70fa3234391dd0cda883a20ab0ec75688cba49",
    "short_hash": "4f70fa32",
    "vulnerableMethods_before": [
      {
        "filename": "GeoTools.java",
        "method_name": "modules/library/metadata/src/main/java/org/geotools/util/factory/GeoTools.java#init",
        "raw_code": "public static void init(final Hints hints) {\n        init();\n        if (hints != null) {\n            // This will trigger fireConfigurationChanged()\n            Hints.putSystemDefault(hints);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "GeoTools.java",
        "method_name": "modules/library/metadata/src/main/java/org/geotools/util/factory/GeoTools.java#init",
        "raw_code": "public static void init(final InitialContext initialContext) {\n        synchronized (GeoTools.class) {\n            context = initialContext;\n        }\n        fireConfigurationChanged();\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "hibernate-validator",
    "cve_id": "CVE-2025-35036",
    "cwe_list": [
      "CWE-94"
    ],
    "commit_hash": "05f795bb7cf18856004f40e5042709e550ed0d6e",
    "short_hash": "05f795bb",
    "vulnerableMethods_before": [
      {
        "filename": "AbstractMessageInterpolator.java",
        "method_name": "interpolate",
        "raw_code": "public abstract String interpolate(Context context, Locale locale, String term);",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AbstractMessageInterpolator.java",
        "method_name": "interpolate",
        "raw_code": "protected abstract String interpolate(Context context, Locale locale, String term);",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "hibernate-validator",
    "cve_id": "CVE-2025-35036",
    "cwe_list": [
      "CWE-94"
    ],
    "commit_hash": "d2db40b9e7d22c7a0b44d7665242dfc7b4d14d78",
    "short_hash": "d2db40b9",
    "vulnerableMethods_before": [
      {
        "filename": "AbstractValidationContext.java",
        "method_name": "createConstraintValidatorContextFor",
        "raw_code": "@Override\n\tpublic ConstraintValidatorContextImpl createConstraintValidatorContextFor(ConstraintDescriptorImpl<?> constraintDescriptor, PathImpl path) {\n\t\treturn new ConstraintValidatorContextImpl(\n\t\t\t\tvalidatorScopedContext.getClockProvider(),\n\t\t\t\tpath,\n\t\t\t\tconstraintDescriptor,\n\t\t\t\tvalidatorScopedContext.getConstraintValidatorPayload()\n\t\t);\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AbstractValidationContext.java",
        "method_name": "createConstraintValidatorContextFor",
        "raw_code": "@Override\n\tpublic ConstraintValidatorContextImpl createConstraintValidatorContextFor(ConstraintDescriptorImpl<?> constraintDescriptor, PathImpl path) {\n\t\treturn new ConstraintValidatorContextImpl(\n\t\t\t\tvalidatorScopedContext.getClockProvider(),\n\t\t\t\tpath,\n\t\t\t\tconstraintDescriptor,\n\t\t\t\tvalidatorScopedContext.getConstraintValidatorPayload(),\n\t\t\t\tvalidatorScopedContext.getConstraintExpressionLanguageFeatureLevel(),\n\t\t\t\tvalidatorScopedContext.getCustomViolationExpressionLanguageFeatureLevel()\n\t\t);\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "plantuml",
    "cve_id": "CVE-2022-1231",
    "cwe_list": [
      "CWE-79"
    ],
    "commit_hash": "c9137be051ce98b3e3e27f65f54ec7d9f8886903",
    "short_hash": "c9137be0",
    "vulnerableMethods_before": [
      {
        "filename": "UImageSvg.java",
        "method_name": "src/net/sourceforge/plantuml/ugraphic/UImageSvg.java#clean",
        "raw_code": "private String clean(String svg) {\n\t\tsvg = svg.toLowerCase().replaceAll(\"\\\\s\", \"\");\n\t\tif (svg.contains(\"<script>\"))\n\t\t\treturn EMPTY_SVG;\n\t\tif (svg.contains(\"</script>\"))\n\t\t\treturn EMPTY_SVG;\n\t\tif (svg.contains(\"<foreignobject\"))\n\t\t\treturn EMPTY_SVG;\n\t\tif (svg.contains(\"</foreignobject>\"))\n\t\t\treturn EMPTY_SVG;\n\t\treturn svg;\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "UImageSvg.java",
        "method_name": "src/net/sourceforge/plantuml/ugraphic/UImageSvg.java#clean",
        "raw_code": "private String clean(final String svg) {\n\t\tfinal String svg2 = svg.toLowerCase().replaceAll(\"\\\\s\", \"\");\n\t\tif (svg2.contains(\"<script>\"))\n\t\t\treturn EMPTY_SVG;\n\t\tif (svg2.contains(\"</script>\"))\n\t\t\treturn EMPTY_SVG;\n\t\tif (svg2.contains(\"<foreignobject\"))\n\t\t\treturn EMPTY_SVG;\n\t\tif (svg2.contains(\"</foreignobject>\"))\n\t\t\treturn EMPTY_SVG;\n\t\treturn svg;\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "onedev",
    "cve_id": "CVE-2021-21242",
    "cwe_list": [
      "CWE-502"
    ],
    "commit_hash": "f864053176c08f59ef2d97fea192ceca46a4d9be",
    "short_hash": "f8640531",
    "vulnerableMethods_before": [
      {
        "filename": "MarkdownEditor.java",
        "method_name": "server-core/src/main/java/io/onedev/server/web/component/markdown/MarkdownEditor.java#onInitialize",
        "raw_code": "@Override\n\tprotected void onInitialize() {\n\t\tsuper.onInitialize();\n\n\t\tcontainer = new WebMarkupContainer(\"container\");\n\t\tcontainer.setOutputMarkupId(true);\n\t\t\n\t\tadd(container);\n\t\t\n\t\tWebMarkupContainer editLink = new WebMarkupContainer(\"editLink\");\n\t\tWebMarkupContainer splitLink = new WebMarkupContainer(\"splitLink\");\n\t\tWebMarkupContainer preview = new WebMarkupContainer(\"preview\");\n\t\tWebMarkupContainer edit = new WebMarkupContainer(\"edit\");\n\t\tcontainer.add(editLink);\n\t\tcontainer.add(splitLink);\n\t\tcontainer.add(preview);\n\t\tcontainer.add(edit);\n\t\t\n\t\tcontainer.add(AttributeAppender.append(\"class\", compactMode?\"compact-mode\":\"normal-mode\"));\n\t\t\n\t\tcontainer.add(new DropdownLink(\"doReference\") {\n\n\n\t\t\t@Override\n\t\t\tprotected Component newContent(String id, FloatingPanel dropdown) {\n\t\t\t\treturn new Fragment(id, \"referenceMenuFrag\", MarkdownEditor.this) {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void renderHead(IHeaderResponse response) {\n\t\t\t\t\t\tsuper.renderHead(response);\n\t\t\t\t\t\tString script = String.format(\"onedev.server.markdown.setupActionMenu($('#%s'), $('#%s'));\", \n\t\t\t\t\t\t\t\tcontainer.getMarkupId(), getMarkupId());\n\t\t\t\t\t\tresponse.render(OnDomReadyHeaderItem.forScript(script));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}.setOutputMarkupId(true);\n\t\t\t}\n\t\t\t\n\t\t}.setVisible(getReferenceSupport() != null));\n\t\t\n\t\tcontainer.add(new DropdownLink(\"actionMenuTrigger\") {\n\n\n\t\t\t@Override\n\t\t\tprotected Component newContent(String id, FloatingPanel dropdown) {\n\t\t\t\treturn new Fragment(id, \"actionMenuFrag\", MarkdownEditor.this) {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected void onInitialize() {\n\t\t\t\t\t\tsuper.onInitialize();\n\t\t\t\t\t\tadd(new WebMarkupContainer(\"doMention\").setVisible(getUserMentionSupport() != null));\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (getReferenceSupport() != null) \n\t\t\t\t\t\t\tadd(new Fragment(\"doReference\", \"referenceMenuFrag\", MarkdownEditor.this));\n\t\t\t\t\t\telse \n\t\t\t\t\t\t\tadd(new WebMarkupContainer(\"doReference\").setVisible(false));\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void renderHead(IHeaderResponse response) {\n\t\t\t\t\t\tsuper.renderHead(response);\n\t\t\t\t\t\tString script = String.format(\"onedev.server.markdown.setupActionMenu($('#%s'), $('#%s'));\", \n\t\t\t\t\t\t\t\tcontainer.getMarkupId(), getMarkupId());\n\t\t\t\t\t\tresponse.render(OnDomReadyHeaderItem.forScript(script));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}.setOutputMarkupId(true);\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\t\tcontainer.add(new WebMarkupContainer(\"doMention\").setVisible(getUserMentionSupport() != null));\n\t\t\t\n\t\tedit.add(input = new TextArea<String>(\"input\", Model.of(getModelObject())));\n\t\tfor (AttributeModifier modifier: getInputModifiers()) \n\t\t\tinput.add(modifier);\n\n\t\tif (initialSplit) {\n\t\t\tcontainer.add(AttributeAppender.append(\"class\", \"split-mode\"));\n\t\t\tpreview.add(new Label(\"rendered\", new LoadableDetachableModel<String>() {\n\n\t\t\t\t@Override\n\t\t\t\tprotected String load() {\n\t\t\t\t\treturn renderInput(input.getConvertedInput());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}) {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void renderHead(IHeaderResponse response) {\n\t\t\t\t\tsuper.renderHead(response);\n\t\t\t\t\tString script = String.format(\n\t\t\t\t\t\t\t\"onedev.server.markdown.initRendered($('#%s>.body>.preview>.markdown-rendered'));\", \n\t\t\t\t\t\t\tcontainer.getMarkupId());\n\t\t\t\t\tresponse.render(OnDomReadyHeaderItem.forScript(script));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}.setEscapeModelStrings(false));\n\t\t\tsplitLink.add(AttributeAppender.append(\"class\", \"active\"));\n\t\t} else {\n\t\t\tcontainer.add(AttributeAppender.append(\"class\", \"edit-mode\"));\n\t\t\tpreview.add(new WebMarkupContainer(\"rendered\"));\n\t\t\teditLink.add(AttributeAppender.append(\"class\", \"active\"));\n\t\t}\n\t\t\n\t\tcontainer.add(new WebMarkupContainer(\"canAttachFile\").setVisible(getAttachmentSupport()!=null));\n\t\t\n\t\tcontainer.add(ajaxBehavior = new AbstractPostAjaxBehavior() {\n\n\t\t\t@Override\n\t\t\tprotected void updateAjaxAttributes(AjaxRequestAttributes attributes) {\n\t\t\t\tsuper.updateAjaxAttributes(attributes);\n\t\t\t\tattributes.setChannel(new AjaxChannel(\"markdown-preview\", AjaxChannel.Type.DROP));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void respond(AjaxRequestTarget target) {\n\t\t\t\tIRequestParameters params = RequestCycle.get().getRequest().getPostParameters();\n\t\t\t\tString action = params.getParameterValue(\"action\").toString(\"\");\n\t\t\t\tswitch (action) {\n\t\t\t\tcase \"render\":\n\t\t\t\t\tString markdown = params.getParameterValue(\"param1\").toString();\n\t\t\t\t\tString rendered = renderInput(markdown);\n\t\t\t\t\tString script = String.format(\"onedev.server.markdown.onRendered('%s', '%s');\", \n\t\t\t\t\t\t\tcontainer.getMarkupId(), JavaScriptEscape.escapeJavaScript(rendered));\n\t\t\t\t\ttarget.appendJavaScript(script);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"emojiQuery\":\n\t\t\t\t\tList<String> emojiNames = new ArrayList<>();\n\t\t\t\t\tString emojiQuery = params.getParameterValue(\"param1\").toOptionalString();\n\t\t\t\t\tif (StringUtils.isNotBlank(emojiQuery)) {\n\t\t\t\t\t\temojiQuery = emojiQuery.toLowerCase();\n\t\t\t\t\t\tfor (String emojiName: EmojiOnes.getInstance().all().keySet()) {\n\t\t\t\t\t\t\tif (emojiName.toLowerCase().contains(emojiQuery))\n\t\t\t\t\t\t\t\temojiNames.add(emojiName);\n\t\t\t\t\t\t}\n\t\t\t\t\t\temojiNames.sort((name1, name2) -> name1.length() - name2.length());\n\t\t\t\t\t} else {\n\t\t\t\t\t\temojiNames.add(\"smile\");\n\t\t\t\t\t\temojiNames.add(\"worried\");\n\t\t\t\t\t\temojiNames.add(\"blush\");\n\t\t\t\t\t\temojiNames.add(\"+1\");\n\t\t\t\t\t\temojiNames.add(\"-1\");\n\t\t\t\t\t}\n\n\t\t\t\t\tList<Map<String, String>> emojis = new ArrayList<>();\n\t\t\t\t\tfor (String emojiName: emojiNames) {\n\t\t\t\t\t\tif (emojis.size() < ATWHO_LIMIT) {\n\t\t\t\t\t\t\tString emojiCode = EmojiOnes.getInstance().all().get(emojiName);\n\t\t\t\t\t\t\tCharSequence url = RequestCycle.get().urlFor(new PackageResourceReference(\n\t\t\t\t\t\t\t\t\tEmojiOnes.class, \"icon/\" + emojiCode + \".png\"), new PageParameters());\n\t\t\t\t\t\t\tMap<String, String> emoji = new HashMap<>();\n\t\t\t\t\t\t\temoji.put(\"name\", emojiName);\n\t\t\t\t\t\t\temoji.put(\"url\", url.toString());\n\t\t\t\t\t\t\temojis.add(emoji);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString json;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tjson = AppLoader.getInstance(ObjectMapper.class).writeValueAsString(emojis);\n\t\t\t\t\t} catch (JsonProcessingException e) {\n\t\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t\t}\n\t\t\t\t\tscript = String.format(\"$('#%s').data('atWhoEmojiRenderCallback')(%s);\", container.getMarkupId(), json);\n\t\t\t\t\ttarget.appendJavaScript(script);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"loadEmojis\":\n\t\t\t\t\temojis = new ArrayList<>();\n\t\t\t\t\tString urlPattern =  RequestCycle.get().urlFor(new PackageResourceReference(EmojiOnes.class,\n\t\t\t\t\t        \"icon/FILENAME.png\"), new PageParameters()).toString();\n\t\t\t\t\t\n\t\t\t\t\tfor (Map.Entry<String, String> entry: EmojiOnes.getInstance().all().entrySet()) {\n\t\t\t\t\t\tMap<String, String> emoji = new HashMap<>();\n\t\t\t\t\t\temoji.put(\"name\", entry.getKey());\n\t\t\t\t\t\temoji.put(\"url\", urlPattern.replace(\"FILENAME\", entry.getValue()));\n\t\t\t\t\t\temojis.add(emoji);\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tjson = AppLoader.getInstance(ObjectMapper.class).writeValueAsString(emojis);\n\t\t\t\t\t} catch (JsonProcessingException e) {\n\t\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t\t}\n\n\t\t\t\t\tscript = String.format(\"onedev.server.markdown.onEmojisLoaded('%s', %s);\", container.getMarkupId(), json);\n\t\t\t\t\ttarget.appendJavaScript(script);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"userQuery\":\n\t\t\t\t\tString userQuery = params.getParameterValue(\"param1\").toOptionalString();\n\n\t\t\t\t\tAvatarManager avatarManager = OneDev.getInstance(AvatarManager.class);\n\t\t\t\t\tList<Map<String, String>> userList = new ArrayList<>();\n\t\t\t\t\tfor (User user: getUserMentionSupport().findUsers(userQuery, ATWHO_LIMIT)) {\n\t\t\t\t\t\tMap<String, String> userMap = new HashMap<>();\n\t\t\t\t\t\tuserMap.put(\"name\", user.getName());\n\t\t\t\t\t\tif (user.getFullName() != null)\n\t\t\t\t\t\t\tuserMap.put(\"fullName\", user.getFullName());\n\t\t\t\t\t\tString noSpaceName = StringUtils.deleteWhitespace(user.getName());\n\t\t\t\t\t\tif (user.getFullName() != null) {\n\t\t\t\t\t\t\tString noSpaceFullName = StringUtils.deleteWhitespace(user.getFullName());\n\t\t\t\t\t\t\tuserMap.put(\"searchKey\", noSpaceName + \" \" + noSpaceFullName);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tuserMap.put(\"searchKey\", noSpaceName);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tString avatarUrl = avatarManager.getAvatarUrl(user);\n\t\t\t\t\t\tuserMap.put(\"avatarUrl\", avatarUrl);\n\t\t\t\t\t\tuserList.add(userMap);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\tjson = OneDev.getInstance(ObjectMapper.class).writeValueAsString(userList);\n\t\t\t\t\t} catch (JsonProcessingException e) {\n\t\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t\t}\n\t\t\t\t\tscript = String.format(\"$('#%s').data('atWhoUserRenderCallback')(%s);\", container.getMarkupId(), json);\n\t\t\t\t\ttarget.appendJavaScript(script);\t\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"referenceQuery\":\n\t\t\t\t\tString referenceQuery = params.getParameterValue(\"param1\").toOptionalString();\n\t\t\t\t\tString referenceQueryType = params.getParameterValue(\"param2\").toOptionalString();\n\t\t\t\t\tString referenceProjectName = params.getParameterValue(\"param3\").toOptionalString();\n\t\t\t\t\tList<Map<String, String>> referenceList = new ArrayList<>();\n\t\t\t\t\tProject referenceProject;\n\t\t\t\t\tif (StringUtils.isNotBlank(referenceProjectName)) \n\t\t\t\t\t\treferenceProject = OneDev.getInstance(ProjectManager.class).find(referenceProjectName);\n\t\t\t\t\telse\n\t\t\t\t\t\treferenceProject = null;\n\t\t\t\t\tif (referenceProject != null || StringUtils.isBlank(referenceProjectName)) {\n\t\t\t\t\t\tif (\"issue\".equals(referenceQueryType)) {\n\t\t\t\t\t\t\tfor (Issue issue: getReferenceSupport().findIssues(referenceProject, referenceQuery, ATWHO_LIMIT)) {\n\t\t\t\t\t\t\t\tMap<String, String> referenceMap = new HashMap<>();\n\t\t\t\t\t\t\t\treferenceMap.put(\"referenceType\", \"issue\");\n\t\t\t\t\t\t\t\treferenceMap.put(\"referenceNumber\", String.valueOf(issue.getNumber()));\n\t\t\t\t\t\t\t\treferenceMap.put(\"referenceTitle\", issue.getTitle());\n\t\t\t\t\t\t\t\treferenceMap.put(\"searchKey\", issue.getNumber() + \" \" + StringUtils.deleteWhitespace(issue.getTitle()));\n\t\t\t\t\t\t\t\treferenceList.add(referenceMap);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (\"pullrequest\".equals(referenceQueryType)) {\n\t\t\t\t\t\t\tfor (PullRequest request: getReferenceSupport().findPullRequests(referenceProject, referenceQuery, ATWHO_LIMIT)) {\n\t\t\t\t\t\t\t\tMap<String, String> referenceMap = new HashMap<>();\n\t\t\t\t\t\t\t\treferenceMap.put(\"referenceType\", \"pull request\");\n\t\t\t\t\t\t\t\treferenceMap.put(\"referenceNumber\", String.valueOf(request.getNumber()));\n\t\t\t\t\t\t\t\treferenceMap.put(\"referenceTitle\", request.getTitle());\n\t\t\t\t\t\t\t\treferenceMap.put(\"searchKey\", request.getNumber() + \" \" + StringUtils.deleteWhitespace(request.getTitle()));\n\t\t\t\t\t\t\t\treferenceList.add(referenceMap);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (\"build\".equals(referenceQueryType)) {\n\t\t\t\t\t\t\tfor (Build build: getReferenceSupport().findBuilds(referenceProject, referenceQuery, ATWHO_LIMIT)) {\n\t\t\t\t\t\t\t\tMap<String, String> referenceMap = new HashMap<>();\n\t\t\t\t\t\t\t\treferenceMap.put(\"referenceType\", \"build\");\n\t\t\t\t\t\t\t\treferenceMap.put(\"referenceNumber\", String.valueOf(build.getNumber()));\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tString title;\n\t\t\t\t\t\t\t\tif (build.getVersion() != null) \n\t\t\t\t\t\t\t\t\ttitle = \"(\" + build.getVersion() + \") \" + build.getJobName();\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\ttitle = build.getJobName();\n\t\t\t\t\t\t\t\treferenceMap.put(\"referenceTitle\", title);\n\t\t\t\t\t\t\t\treferenceMap.put(\"searchKey\", build.getNumber() + \" \" + StringUtils.deleteWhitespace(title));\n\t\t\t\t\t\t\t\treferenceList.add(referenceMap);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\tjson = OneDev.getInstance(ObjectMapper.class).writeValueAsString(referenceList);\n\t\t\t\t\t} catch (JsonProcessingException e) {\n\t\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t\t}\n\t\t\t\t\tscript = String.format(\"$('#%s').data('atWhoReferenceRenderCallback')(%s);\", container.getMarkupId(), json);\n\t\t\t\t\ttarget.appendJavaScript(script);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"selectImage\":\n\t\t\t\tcase \"selectLink\":\n\t\t\t\t\tnew ModalPanel(target) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected Component newContent(String id) {\n\t\t\t\t\t\t\treturn new InsertUrlPanel(id, MarkdownEditor.this, action.equals(\"selectImage\")) {\n\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tprotected void onClose(AjaxRequestTarget target) {\n\t\t\t\t\t\t\t\t\tclose();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onClosed() {\n\t\t\t\t\t\t\tsuper.onClosed();\n\t\t\t\t\t\t\tAjaxRequestTarget target = \n\t\t\t\t\t\t\t\t\tPreconditions.checkNotNull(RequestCycle.get().find(AjaxRequestTarget.class));\n\t\t\t\t\t\t\ttarget.appendJavaScript(String.format(\"$('#%s textarea').focus();\", container.getMarkupId()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"insertUrl\":\n\t\t\t\t\tString name;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tname = URLDecoder.decode(params.getParameterValue(\"param1\").toString(), StandardCharsets.UTF_8.name());\n\t\t\t\t\t} catch (UnsupportedEncodingException e) {\n\t\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t\t}\n\t\t\t\t\tString replaceMessage = params.getParameterValue(\"param2\").toString();\n\t\t\t\t\tString url = getAttachmentSupport().getAttachmentUrl(name);\n\t\t\t\t\tinsertUrl(target, isWebSafeImage(name), url, name, replaceMessage);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new IllegalStateException(\"Unknown action: \" + action);\n\t\t\t\t}\t\t\n\t\t\t}\n\t\t\t\n\t\t});\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "MarkdownEditor.java",
        "method_name": "server-core/src/main/java/io/onedev/server/web/component/markdown/MarkdownEditor.java#onInitialize",
        "raw_code": "@Override\n\tprotected void onInitialize() {\n\t\tsuper.onInitialize();\n\n\t\tcontainer = new WebMarkupContainer(\"container\");\n\t\tcontainer.setOutputMarkupId(true);\n\t\t\n\t\tadd(container);\n\t\t\n\t\tWebMarkupContainer editLink = new WebMarkupContainer(\"editLink\");\n\t\tWebMarkupContainer splitLink = new WebMarkupContainer(\"splitLink\");\n\t\tWebMarkupContainer preview = new WebMarkupContainer(\"preview\");\n\t\tWebMarkupContainer edit = new WebMarkupContainer(\"edit\");\n\t\tcontainer.add(editLink);\n\t\tcontainer.add(splitLink);\n\t\tcontainer.add(preview);\n\t\tcontainer.add(edit);\n\t\t\n\t\tcontainer.add(AttributeAppender.append(\"class\", compactMode?\"compact-mode\":\"normal-mode\"));\n\t\t\n\t\tcontainer.add(new DropdownLink(\"doReference\") {\n\n\n\t\t\t@Override\n\t\t\tprotected Component newContent(String id, FloatingPanel dropdown) {\n\t\t\t\treturn new Fragment(id, \"referenceMenuFrag\", MarkdownEditor.this) {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void renderHead(IHeaderResponse response) {\n\t\t\t\t\t\tsuper.renderHead(response);\n\t\t\t\t\t\tString script = String.format(\"onedev.server.markdown.setupActionMenu($('#%s'), $('#%s'));\", \n\t\t\t\t\t\t\t\tcontainer.getMarkupId(), getMarkupId());\n\t\t\t\t\t\tresponse.render(OnDomReadyHeaderItem.forScript(script));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}.setOutputMarkupId(true);\n\t\t\t}\n\t\t\t\n\t\t}.setVisible(getReferenceSupport() != null));\n\t\t\n\t\tcontainer.add(new DropdownLink(\"actionMenuTrigger\") {\n\n\n\t\t\t@Override\n\t\t\tprotected Component newContent(String id, FloatingPanel dropdown) {\n\t\t\t\treturn new Fragment(id, \"actionMenuFrag\", MarkdownEditor.this) {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected void onInitialize() {\n\t\t\t\t\t\tsuper.onInitialize();\n\t\t\t\t\t\tadd(new WebMarkupContainer(\"doMention\").setVisible(getUserMentionSupport() != null));\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (getReferenceSupport() != null) \n\t\t\t\t\t\t\tadd(new Fragment(\"doReference\", \"referenceMenuFrag\", MarkdownEditor.this));\n\t\t\t\t\t\telse \n\t\t\t\t\t\t\tadd(new WebMarkupContainer(\"doReference\").setVisible(false));\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void renderHead(IHeaderResponse response) {\n\t\t\t\t\t\tsuper.renderHead(response);\n\t\t\t\t\t\tString script = String.format(\"onedev.server.markdown.setupActionMenu($('#%s'), $('#%s'));\", \n\t\t\t\t\t\t\t\tcontainer.getMarkupId(), getMarkupId());\n\t\t\t\t\t\tresponse.render(OnDomReadyHeaderItem.forScript(script));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}.setOutputMarkupId(true);\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\t\tcontainer.add(new WebMarkupContainer(\"doMention\").setVisible(getUserMentionSupport() != null));\n\t\t\t\n\t\tedit.add(input = new TextArea<String>(\"input\", Model.of(getModelObject())));\n\t\tfor (AttributeModifier modifier: getInputModifiers()) \n\t\t\tinput.add(modifier);\n\n\t\tif (initialSplit) {\n\t\t\tcontainer.add(AttributeAppender.append(\"class\", \"split-mode\"));\n\t\t\tpreview.add(new Label(\"rendered\", new LoadableDetachableModel<String>() {\n\n\t\t\t\t@Override\n\t\t\t\tprotected String load() {\n\t\t\t\t\treturn renderInput(input.getConvertedInput());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}) {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void renderHead(IHeaderResponse response) {\n\t\t\t\t\tsuper.renderHead(response);\n\t\t\t\t\tString script = String.format(\n\t\t\t\t\t\t\t\"onedev.server.markdown.initRendered($('#%s>.body>.preview>.markdown-rendered'));\", \n\t\t\t\t\t\t\tcontainer.getMarkupId());\n\t\t\t\t\tresponse.render(OnDomReadyHeaderItem.forScript(script));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}.setEscapeModelStrings(false));\n\t\t\tsplitLink.add(AttributeAppender.append(\"class\", \"active\"));\n\t\t} else {\n\t\t\tcontainer.add(AttributeAppender.append(\"class\", \"edit-mode\"));\n\t\t\tpreview.add(new WebMarkupContainer(\"rendered\"));\n\t\t\teditLink.add(AttributeAppender.append(\"class\", \"active\"));\n\t\t}\n\t\t\n\t\tcontainer.add(new WebMarkupContainer(\"canAttachFile\").setVisible(getAttachmentSupport()!=null));\n\t\t\n\t\tcontainer.add(actionBehavior = new AbstractPostAjaxBehavior() {\n\n\t\t\t@Override\n\t\t\tprotected void updateAjaxAttributes(AjaxRequestAttributes attributes) {\n\t\t\t\tsuper.updateAjaxAttributes(attributes);\n\t\t\t\tattributes.setChannel(new AjaxChannel(\"markdown-preview\", AjaxChannel.Type.DROP));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void respond(AjaxRequestTarget target) {\n\t\t\t\tIRequestParameters params = RequestCycle.get().getRequest().getPostParameters();\n\t\t\t\tString action = params.getParameterValue(\"action\").toString(\"\");\n\t\t\t\tswitch (action) {\n\t\t\t\tcase \"render\":\n\t\t\t\t\tString markdown = params.getParameterValue(\"param1\").toString();\n\t\t\t\t\tString rendered = renderInput(markdown);\n\t\t\t\t\tString script = String.format(\"onedev.server.markdown.onRendered('%s', '%s');\", \n\t\t\t\t\t\t\tcontainer.getMarkupId(), JavaScriptEscape.escapeJavaScript(rendered));\n\t\t\t\t\ttarget.appendJavaScript(script);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"emojiQuery\":\n\t\t\t\t\tList<String> emojiNames = new ArrayList<>();\n\t\t\t\t\tString emojiQuery = params.getParameterValue(\"param1\").toOptionalString();\n\t\t\t\t\tif (StringUtils.isNotBlank(emojiQuery)) {\n\t\t\t\t\t\temojiQuery = emojiQuery.toLowerCase();\n\t\t\t\t\t\tfor (String emojiName: EmojiOnes.getInstance().all().keySet()) {\n\t\t\t\t\t\t\tif (emojiName.toLowerCase().contains(emojiQuery))\n\t\t\t\t\t\t\t\temojiNames.add(emojiName);\n\t\t\t\t\t\t}\n\t\t\t\t\t\temojiNames.sort((name1, name2) -> name1.length() - name2.length());\n\t\t\t\t\t} else {\n\t\t\t\t\t\temojiNames.add(\"smile\");\n\t\t\t\t\t\temojiNames.add(\"worried\");\n\t\t\t\t\t\temojiNames.add(\"blush\");\n\t\t\t\t\t\temojiNames.add(\"+1\");\n\t\t\t\t\t\temojiNames.add(\"-1\");\n\t\t\t\t\t}\n\n\t\t\t\t\tList<Map<String, String>> emojis = new ArrayList<>();\n\t\t\t\t\tfor (String emojiName: emojiNames) {\n\t\t\t\t\t\tif (emojis.size() < ATWHO_LIMIT) {\n\t\t\t\t\t\t\tString emojiCode = EmojiOnes.getInstance().all().get(emojiName);\n\t\t\t\t\t\t\tCharSequence url = RequestCycle.get().urlFor(new PackageResourceReference(\n\t\t\t\t\t\t\t\t\tEmojiOnes.class, \"icon/\" + emojiCode + \".png\"), new PageParameters());\n\t\t\t\t\t\t\tMap<String, String> emoji = new HashMap<>();\n\t\t\t\t\t\t\temoji.put(\"name\", emojiName);\n\t\t\t\t\t\t\temoji.put(\"url\", url.toString());\n\t\t\t\t\t\t\temojis.add(emoji);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tString json;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tjson = AppLoader.getInstance(ObjectMapper.class).writeValueAsString(emojis);\n\t\t\t\t\t} catch (JsonProcessingException e) {\n\t\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t\t}\n\t\t\t\t\tscript = String.format(\"$('#%s').data('atWhoEmojiRenderCallback')(%s);\", container.getMarkupId(), json);\n\t\t\t\t\ttarget.appendJavaScript(script);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"loadEmojis\":\n\t\t\t\t\temojis = new ArrayList<>();\n\t\t\t\t\tString urlPattern =  RequestCycle.get().urlFor(new PackageResourceReference(EmojiOnes.class,\n\t\t\t\t\t        \"icon/FILENAME.png\"), new PageParameters()).toString();\n\t\t\t\t\t\n\t\t\t\t\tfor (Map.Entry<String, String> entry: EmojiOnes.getInstance().all().entrySet()) {\n\t\t\t\t\t\tMap<String, String> emoji = new HashMap<>();\n\t\t\t\t\t\temoji.put(\"name\", entry.getKey());\n\t\t\t\t\t\temoji.put(\"url\", urlPattern.replace(\"FILENAME\", entry.getValue()));\n\t\t\t\t\t\temojis.add(emoji);\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tjson = AppLoader.getInstance(ObjectMapper.class).writeValueAsString(emojis);\n\t\t\t\t\t} catch (JsonProcessingException e) {\n\t\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t\t}\n\n\t\t\t\t\tscript = String.format(\"onedev.server.markdown.onEmojisLoaded('%s', %s);\", container.getMarkupId(), json);\n\t\t\t\t\ttarget.appendJavaScript(script);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"userQuery\":\n\t\t\t\t\tString userQuery = params.getParameterValue(\"param1\").toOptionalString();\n\n\t\t\t\t\tAvatarManager avatarManager = OneDev.getInstance(AvatarManager.class);\n\t\t\t\t\tList<Map<String, String>> userList = new ArrayList<>();\n\t\t\t\t\tfor (User user: getUserMentionSupport().findUsers(userQuery, ATWHO_LIMIT)) {\n\t\t\t\t\t\tMap<String, String> userMap = new HashMap<>();\n\t\t\t\t\t\tuserMap.put(\"name\", user.getName());\n\t\t\t\t\t\tif (user.getFullName() != null)\n\t\t\t\t\t\t\tuserMap.put(\"fullName\", user.getFullName());\n\t\t\t\t\t\tString noSpaceName = StringUtils.deleteWhitespace(user.getName());\n\t\t\t\t\t\tif (user.getFullName() != null) {\n\t\t\t\t\t\t\tString noSpaceFullName = StringUtils.deleteWhitespace(user.getFullName());\n\t\t\t\t\t\t\tuserMap.put(\"searchKey\", noSpaceName + \" \" + noSpaceFullName);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tuserMap.put(\"searchKey\", noSpaceName);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tString avatarUrl = avatarManager.getAvatarUrl(user);\n\t\t\t\t\t\tuserMap.put(\"avatarUrl\", avatarUrl);\n\t\t\t\t\t\tuserList.add(userMap);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\tjson = OneDev.getInstance(ObjectMapper.class).writeValueAsString(userList);\n\t\t\t\t\t} catch (JsonProcessingException e) {\n\t\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t\t}\n\t\t\t\t\tscript = String.format(\"$('#%s').data('atWhoUserRenderCallback')(%s);\", container.getMarkupId(), json);\n\t\t\t\t\ttarget.appendJavaScript(script);\t\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"referenceQuery\":\n\t\t\t\t\tString referenceQuery = params.getParameterValue(\"param1\").toOptionalString();\n\t\t\t\t\tString referenceQueryType = params.getParameterValue(\"param2\").toOptionalString();\n\t\t\t\t\tString referenceProjectName = params.getParameterValue(\"param3\").toOptionalString();\n\t\t\t\t\tList<Map<String, String>> referenceList = new ArrayList<>();\n\t\t\t\t\tProject referenceProject;\n\t\t\t\t\tif (StringUtils.isNotBlank(referenceProjectName)) \n\t\t\t\t\t\treferenceProject = OneDev.getInstance(ProjectManager.class).find(referenceProjectName);\n\t\t\t\t\telse\n\t\t\t\t\t\treferenceProject = null;\n\t\t\t\t\tif (referenceProject != null || StringUtils.isBlank(referenceProjectName)) {\n\t\t\t\t\t\tif (\"issue\".equals(referenceQueryType)) {\n\t\t\t\t\t\t\tfor (Issue issue: getReferenceSupport().findIssues(referenceProject, referenceQuery, ATWHO_LIMIT)) {\n\t\t\t\t\t\t\t\tMap<String, String> referenceMap = new HashMap<>();\n\t\t\t\t\t\t\t\treferenceMap.put(\"referenceType\", \"issue\");\n\t\t\t\t\t\t\t\treferenceMap.put(\"referenceNumber\", String.valueOf(issue.getNumber()));\n\t\t\t\t\t\t\t\treferenceMap.put(\"referenceTitle\", issue.getTitle());\n\t\t\t\t\t\t\t\treferenceMap.put(\"searchKey\", issue.getNumber() + \" \" + StringUtils.deleteWhitespace(issue.getTitle()));\n\t\t\t\t\t\t\t\treferenceList.add(referenceMap);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (\"pullrequest\".equals(referenceQueryType)) {\n\t\t\t\t\t\t\tfor (PullRequest request: getReferenceSupport().findPullRequests(referenceProject, referenceQuery, ATWHO_LIMIT)) {\n\t\t\t\t\t\t\t\tMap<String, String> referenceMap = new HashMap<>();\n\t\t\t\t\t\t\t\treferenceMap.put(\"referenceType\", \"pull request\");\n\t\t\t\t\t\t\t\treferenceMap.put(\"referenceNumber\", String.valueOf(request.getNumber()));\n\t\t\t\t\t\t\t\treferenceMap.put(\"referenceTitle\", request.getTitle());\n\t\t\t\t\t\t\t\treferenceMap.put(\"searchKey\", request.getNumber() + \" \" + StringUtils.deleteWhitespace(request.getTitle()));\n\t\t\t\t\t\t\t\treferenceList.add(referenceMap);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (\"build\".equals(referenceQueryType)) {\n\t\t\t\t\t\t\tfor (Build build: getReferenceSupport().findBuilds(referenceProject, referenceQuery, ATWHO_LIMIT)) {\n\t\t\t\t\t\t\t\tMap<String, String> referenceMap = new HashMap<>();\n\t\t\t\t\t\t\t\treferenceMap.put(\"referenceType\", \"build\");\n\t\t\t\t\t\t\t\treferenceMap.put(\"referenceNumber\", String.valueOf(build.getNumber()));\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tString title;\n\t\t\t\t\t\t\t\tif (build.getVersion() != null) \n\t\t\t\t\t\t\t\t\ttitle = \"(\" + build.getVersion() + \") \" + build.getJobName();\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\ttitle = build.getJobName();\n\t\t\t\t\t\t\t\treferenceMap.put(\"referenceTitle\", title);\n\t\t\t\t\t\t\t\treferenceMap.put(\"searchKey\", build.getNumber() + \" \" + StringUtils.deleteWhitespace(title));\n\t\t\t\t\t\t\t\treferenceList.add(referenceMap);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\tjson = OneDev.getInstance(ObjectMapper.class).writeValueAsString(referenceList);\n\t\t\t\t\t} catch (JsonProcessingException e) {\n\t\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t\t}\n\t\t\t\t\tscript = String.format(\"$('#%s').data('atWhoReferenceRenderCallback')(%s);\", container.getMarkupId(), json);\n\t\t\t\t\ttarget.appendJavaScript(script);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"selectImage\":\n\t\t\t\tcase \"selectLink\":\n\t\t\t\t\tnew ModalPanel(target) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected Component newContent(String id) {\n\t\t\t\t\t\t\treturn new InsertUrlPanel(id, MarkdownEditor.this, action.equals(\"selectImage\")) {\n\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tprotected void onClose(AjaxRequestTarget target) {\n\t\t\t\t\t\t\t\t\tclose();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onClosed() {\n\t\t\t\t\t\t\tsuper.onClosed();\n\t\t\t\t\t\t\tAjaxRequestTarget target = \n\t\t\t\t\t\t\t\t\tPreconditions.checkNotNull(RequestCycle.get().find(AjaxRequestTarget.class));\n\t\t\t\t\t\t\ttarget.appendJavaScript(String.format(\"$('#%s textarea').focus();\", container.getMarkupId()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"insertUrl\":\n\t\t\t\t\tString name;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tname = URLDecoder.decode(params.getParameterValue(\"param1\").toString(), StandardCharsets.UTF_8.name());\n\t\t\t\t\t} catch (UnsupportedEncodingException e) {\n\t\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t\t}\n\t\t\t\t\tString replaceMessage = params.getParameterValue(\"param2\").toString();\n\t\t\t\t\tString url = getAttachmentSupport().getAttachmentUrl(name);\n\t\t\t\t\tinsertUrl(target, isWebSafeImage(name), url, name, replaceMessage);\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new IllegalStateException(\"Unknown action: \" + action);\n\t\t\t\t}\t\t\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\t\tcontainer.add(attachmentUploadBehavior = new AbstractPostAjaxBehavior() {\n\t\t\t\n\t\t\t@Override\n\t\t\tprotected void respond(AjaxRequestTarget target) {\n\t\t\t\tPreconditions.checkNotNull(getAttachmentSupport(), \"Unexpected attachment upload request\");\n\t\t\t\tHttpServletRequest request = (HttpServletRequest) RequestCycle.get().getRequest().getContainerRequest();\n\t\t\t\tHttpServletResponse response = (HttpServletResponse) RequestCycle.get().getResponse().getContainerResponse();\n\t\t\t\ttry {\n\t\t\t\t\tString fileName = URLDecoder.decode(request.getHeader(\"File-Name\"), StandardCharsets.UTF_8.name());\n\t\t\t\t\tString attachmentName = getAttachmentSupport().saveAttachment(fileName, request.getInputStream());\n\t\t\t\t\tresponse.getWriter().print(URLEncoder.encode(attachmentName, StandardCharsets.UTF_8.name()));\n\t\t\t\t\tresponse.setStatus(HttpServletResponse.SC_OK);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tlogger.error(\"Error uploading attachment.\", e);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (e.getMessage() != null)\n\t\t\t\t\t\t\tresponse.getWriter().print(e.getMessage());\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tresponse.getWriter().print(\"Internal server error\");\n\t\t\t\t\t} catch (IOException e2) {\n\t\t\t\t\t\tthrow new RuntimeException(e2);\n\t\t\t\t\t}\n\t\t\t\t\tresponse.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t});\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "shopizer",
    "cve_id": "CVE-2022-23061",
    "cwe_list": [
      "CWE-639"
    ],
    "commit_hash": "6b9f1ecd303b3b724d96bd08095c1a751dcc287e",
    "short_hash": "6b9f1ecd",
    "vulnerableMethods_before": [],
    "vulnerableMethods_after": [
      {
        "filename": "PersistableProductOptionValueMapper.java",
        "method_name": "sm-shop/src/main/java/com/salesmanager/shop/mapper/catalog/PersistableProductOptionValueMapper.java#merge",
        "raw_code": "@Override\n\tpublic ProductOptionValue merge(PersistableProductOptionValue source, ProductOptionValue destination,\n\t\t\t\t\t\t\t\t\tMerchantStore store, Language language) {\n\t\tif (destination == null) {\n\t\t\tdestination = new ProductOptionValue();\n\t\t}\n\n\t\ttry {\n\t\t\t\n\t\t\tif(StringUtils.isBlank(source.getCode())) {\n\t\t\t\tif(!StringUtils.isBlank(destination.getCode())) {\n\t\t\t\t\tsource.setCode(destination.getCode());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!CollectionUtils.isEmpty(source.getDescriptions())) {\n\t\t\t\tfor (com.salesmanager.shop.model.catalog.product.attribute.ProductOptionValueDescription desc : source\n\t\t\t\t\t\t.getDescriptions()) {\n\t\t\t\t\tProductOptionValueDescription description = null;\n\t\t\t\t\tif (!CollectionUtils.isEmpty(destination.getDescriptions())) {\n\t\t\t\t\t\tfor (ProductOptionValueDescription d : destination.getDescriptions()) {\n\t\t\t\t\t\t\tif (!StringUtils.isBlank(desc.getLanguage())\n\t\t\t\t\t\t\t\t\t&& desc.getLanguage().equals(d.getLanguage().getCode())) {\n\t\t\t\t\t\t\t\t\n\t\t\t\t            \t  d.setDescription(desc.getDescription());\n\t\t\t\t            \t  d.setName(desc.getName());\n\t\t\t\t            \t  d.setTitle(desc.getTitle());\n\t\t\t\t            \t  if(StringUtils.isBlank(d.getName())) {\n\t\t\t\t            \t\t  d.setName(d.getDescription());\n\t\t\t\t            \t  }\n\t\t\t\t            \t  description = d;\n\t\t\t\t            \t  break;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} //else {\n\t\t\t          if(description == null) {\n\t\t\t\t          description = description(desc);\n\t\t\t\t          description.setProductOptionValue(destination);\n\t\t\t\t          destination.getDescriptions().add(description);\n\t\t\t          }\n\t\t\t\t\t\t//description = description(desc);\n\t\t\t\t\t\t//description.setProductOptionValue(destination);\n\t\t\t\t\t//}\n\t\t\t\t\t//destination.getDescriptions().add(description);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdestination.setCode(source.getCode());\n\t\t\tdestination.setMerchantStore(store);\n\t\t\tdestination.setProductOptionValueSortOrder(source.getSortOrder());\n\n\n\t\t\treturn destination;\n\t\t} catch (Exception e) {\n\t\t\tthrow new ServiceRuntimeException(\"Error while converting product option\", e);\n\t\t}\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "CodenameOne",
    "cve_id": "CVE-2022-4903",
    "cwe_list": [
      "CWE-668"
    ],
    "commit_hash": "dad49c9ef26a598619fc48d2697151a02987d478",
    "short_hash": "dad49c9e",
    "vulnerableMethods_before": [
      {
        "filename": "AndroidLocationPlayServiceManager.java",
        "method_name": "Ports/Android/src/com/codename1/location/AndroidLocationPlayServiceManager.java#createBackgroundPendingIntent",
        "raw_code": "private PendingIntent createBackgroundPendingIntent(boolean forceService) {\n        Context context = AndroidNativeUtil.getContext().getApplicationContext();\n        final Class bgListenerClass = getBackgroundLocationListener();\n        if (bgListenerClass == null) {\n            return null;\n        }\n        if (!forceService && Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            Intent intent = new Intent(context, BackgroundLocationBroadcastReceiver.class);\n            intent.setData(Uri.parse(\"http://codenameone.com/a?\" + bgListenerClass.getName()));\n            intent.setAction(BackgroundLocationBroadcastReceiver.ACTION_PROCESS_UPDATES);\n            PendingIntent pendingIntent = PendingIntent.getBroadcast(context, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);\n            return pendingIntent;\n        } else {\n\n\n            Intent intent = new Intent(context, BackgroundLocationHandler.class);\n            intent.setData(Uri.parse(\"http://codenameone.com/a?\" + bgListenerClass.getName()));\n            PendingIntent pendingIntent = PendingIntent.getService(context, 0,\n                    intent,\n                    PendingIntent.FLAG_UPDATE_CURRENT);\n            return pendingIntent;\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AndroidLocationPlayServiceManager.java",
        "method_name": "Ports/Android/src/com/codename1/location/AndroidLocationPlayServiceManager.java#createBackgroundPendingIntent",
        "raw_code": "private PendingIntent createBackgroundPendingIntent(boolean forceService) {\n        Context context = AndroidNativeUtil.getContext().getApplicationContext();\n        final Class bgListenerClass = getBackgroundLocationListener();\n        if (bgListenerClass == null) {\n            return null;\n        }\n        if (!forceService && Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            Intent intent = new Intent(context, BackgroundLocationBroadcastReceiver.class);\n            intent.setData(Uri.parse(\"http://codenameone.com/a?\" + bgListenerClass.getName()));\n            intent.setAction(BackgroundLocationBroadcastReceiver.ACTION_PROCESS_UPDATES);\n            PendingIntent pendingIntent = AndroidImplementation.getBroadcastPendingIntent(context, 0, intent);\n            return pendingIntent;\n        } else {\n\n\n            Intent intent = new Intent(context, BackgroundLocationHandler.class);\n            intent.setData(Uri.parse(\"http://codenameone.com/a?\" + bgListenerClass.getName()));\n            PendingIntent pendingIntent = AndroidImplementation.getPendingIntent(context, 0,\n                    intent);\n            return pendingIntent;\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "onedev",
    "cve_id": "CVE-2021-21245",
    "cwe_list": [
      "CWE-434"
    ],
    "commit_hash": "0c060153fb97c0288a1917efdb17cc426934dacb",
    "short_hash": "0c060153",
    "vulnerableMethods_before": [
      {
        "filename": "InsertUrlPanel.java",
        "method_name": "server-core/src/main/java/io/onedev/server/web/component/markdown/InsertUrlPanel.java#newUploadPanel",
        "raw_code": "private Component newUploadPanel() {\n\t\tFragment fragment;\n\n\t\tIModel<Collection<FileUpload>> model = new PropertyModel<Collection<FileUpload>>(this, \"uploads\");\n\t\tString acceptedFiles;\n\t\tif (isImage)\n\t\t\tacceptedFiles = \"image/*\";\n\t\telse\n\t\t\tacceptedFiles = null;\n\t\t\n\t\tAttachmentSupport attachmentSupport = markdownEditor.getAttachmentSupport();\n\t\tif (attachmentSupport != null) {\n\t\t\tfragment = new Fragment(CONTENT_ID, \"uploadAttachmentFrag\", this);\n\t\t\t\n\t\t\tForm<?> form = new Form<Void>(\"form\") {\n\n\t\t\t\t@Override\n\t\t\t\tprotected void onSubmit() {\n\t\t\t\t\tsuper.onSubmit();\n\t\t\t\t\t\n\t\t\t\t\tAjaxRequestTarget target = RequestCycle.get().find(AjaxRequestTarget.class);\n\t\t\t\t\tString attachmentName;\n\t\t\t\t\tFileUpload upload = uploads.iterator().next();\n\t\t\t\t\ttry (InputStream is = upload.getInputStream()) {\n\t\t\t\t\t\tattachmentName = attachmentSupport.saveAttachment(upload.getClientFileName(), is);\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t\t}\n\t\t\t\t\tmarkdownEditor.insertUrl(target, isImage, \n\t\t\t\t\t\t\tattachmentSupport.getAttachmentUrl(attachmentName), UrlUtils.describe(attachmentName), null);\n\t\t\t\t\tonClose(target);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tprotected void onFileUploadException(FileUploadException e, Map<String, Object> model) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t};\n\t\t\tform.setMaxSize(Bytes.bytes(attachmentSupport.getAttachmentMaxSize()));\n\t\t\tform.setMultiPart(true);\n\t\t\tform.add(new FencedFeedbackPanel(\"feedback\", form));\n\t\t\t\n\t\t\tint maxFilesize = (int) (attachmentSupport.getAttachmentMaxSize()/1024/1024);\n\t\t\tif (maxFilesize <= 0)\n\t\t\t\tmaxFilesize = 1;\n\t\t\tform.add(new DropzoneField(\"file\", model, acceptedFiles, 1, maxFilesize)\n\t\t\t\t\t.setRequired(true).setLabel(Model.of(\"Attachment\")));\n\t\t\t\n\t\t\tform.add(new AjaxButton(\"insert\"){});\n\t\t\t\n\t\t\tfragment.add(form);\n\t\t} else {\n\t\t\tfragment = new Fragment(CONTENT_ID, \"uploadBlobFrag\", this);\n\t\t\tForm<?> form = new Form<Void>(\"form\");\n\t\t\tform.setMultiPart(true);\n\t\t\tform.setFileMaxSize(Bytes.megabytes(Project.MAX_UPLOAD_SIZE));\n\t\t\tadd(form);\n\t\t\t\n\t\t\tFencedFeedbackPanel feedback = new FencedFeedbackPanel(\"feedback\", form);\n\t\t\tfeedback.setOutputMarkupPlaceholderTag(true);\n\t\t\tform.add(feedback);\n\t\t\t\n\t\t\tform.add(new DropzoneField(\"file\", model, acceptedFiles, 1, Project.MAX_UPLOAD_SIZE)\n\t\t\t\t\t.setRequired(true).setLabel(Model.of(\"Attachment\")));\n\n\t\t\tform.add(new TextField<String>(\"directory\", new IModel<String>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void detach() {\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic String getObject() {\n\t\t\t\t\treturn WebSession.get().getMetaData(UPLOAD_DIRECTORY);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void setObject(String object) {\n\t\t\t\t\tWebSession.get().setMetaData(UPLOAD_DIRECTORY, object);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t})); \n\n\t\t\tBlobRenderContext context = Preconditions.checkNotNull(markdownEditor.getBlobRenderContext());\n\t\t\tObjectId commitId = resolveCommitId(context);\n\t\t\tSet<BlobIdent> folderPickerState = getPickerState(commitId, context.getBlobIdent(), \n\t\t\t\t\tWebSession.get().getMetaData(FOLDER_PICKER_STATE));\n\t\t\t\n\t\t\tform.add(new DropdownLink(\"select\") {\n\n\t\t\t\t@Override\n\t\t\t\tprotected Component newContent(String id, FloatingPanel dropdown) {\n\t\t\t\t\treturn new BlobFolderPicker(id, commitId) {\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onSelect(AjaxRequestTarget target, BlobIdent blobIdent) {\n\t\t\t\t\t\t\tdropdown.close();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tString relativePath = PathUtils.relativize(context.getDirectory(), blobIdent.path);\n\t\t\t\t\t\t\tString script = String.format(\"$('form.upload-blob .directory input').val('%s');\", \n\t\t\t\t\t\t\t\t\tJavaScriptEscape.escapeJavaScript(relativePath));\n\t\t\t\t\t\t\ttarget.appendJavaScript(script);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected Project getProject() {\n\t\t\t\t\t\t\treturn markdownEditor.getBlobRenderContext().getProject();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onStateChange() {\n\t\t\t\t\t\t\tHashSet<String> expandedPaths = new HashSet<>();\n\t\t\t\t\t\t\tfor (BlobIdent blobIdent: folderPickerState)\n\t\t\t\t\t\t\t\texpandedPaths.add(blobIdent.path);\n\t\t\t\t\t\t\tWebSession.get().setMetaData(FOLDER_PICKER_STATE, expandedPaths);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected Set<BlobIdent> getState() {\n\t\t\t\t\t\t\treturn folderPickerState;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t\n\t\t\t});\n\t\t\t\n\t\t\tReferenceInputBehavior behavior = new ReferenceInputBehavior(true) {\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tprotected Project getProject() {\n\t\t\t\t\treturn markdownEditor.getBlobRenderContext().getProject();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t};\n\t\t\tform.add(new TextField<String>(\"summaryCommitMessage\", \n\t\t\t\t\tnew PropertyModel<String>(this, \"summaryCommitMessage\")).add(behavior));\n\t\t\t\n\t\t\tbehavior = new ReferenceInputBehavior(true) {\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tprotected Project getProject() {\n\t\t\t\t\treturn markdownEditor.getBlobRenderContext().getProject();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t};\n\t\t\tform.add(new TextArea<String>(\"detailCommitMessage\", \n\t\t\t\t\tnew PropertyModel<String>(this, \"detailCommitMessage\")).add(behavior));\n\t\t\t\n\t\t\tform.add(new AjaxButton(\"insert\") {\n\n\t\t\t\t@Override\n\t\t\t\tprotected void onSubmit(AjaxRequestTarget target, Form<?> form) {\n\t\t\t\t\tsuper.onSubmit(target, form);\n\n\t\t\t\t\tBlobRenderContext context = Preconditions.checkNotNull(markdownEditor.getBlobRenderContext());\n\t\t\t\t\tString commitMessage = summaryCommitMessage;\n\t\t\t\t\tif (StringUtils.isBlank(commitMessage))\n\t\t\t\t\t\tcommitMessage = \"Add files via upload\";\n\t\t\t\t\t\n\t\t\t\t\tif (StringUtils.isNotBlank(detailCommitMessage))\n\t\t\t\t\t\tcommitMessage += \"\\n\\n\" + detailCommitMessage;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tString directory = WebSession.get().getMetaData(UPLOAD_DIRECTORY);\n\t\t\t\t\t\tcontext.onCommitted(null, context.uploadFiles(uploads, directory, commitMessage), null);\n\t\t\t\t\t\t\n\t\t\t\t\t\tString fileName = uploads.iterator().next().getClientFileName();\n\t\t\t\t\t\tString url;\n\t\t\t\t\t\tif (directory != null) \n\t\t\t\t\t\t\turl = directory + \"/\" + UrlUtils.encodePath(fileName);\n\t\t\t\t\t\telse \n\t\t\t\t\t\t\turl = UrlUtils.encodePath(fileName);\n\t\t\t\t\t\tmarkdownEditor.insertUrl(target, isImage, url, UrlUtils.describe(fileName), null);\n\t\t\t\t\t\tonClose(target);\n\t\t\t\t\t} catch (GitException e) {\n\t\t\t\t\t\tform.error(e.getMessage());\n\t\t\t\t\t\ttarget.add(feedback);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tprotected void onError(AjaxRequestTarget target, Form<?> form) {\n\t\t\t\t\tsuper.onError(target, form);\n\t\t\t\t\ttarget.add(feedback);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t});\n\t\t\t\n\t\t\tfragment.add(form);\n\t\t}\n\t\t\n\t\tfragment.setOutputMarkupId(true);\n\t\treturn fragment;\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "InsertUrlPanel.java",
        "method_name": "server-core/src/main/java/io/onedev/server/web/component/markdown/InsertUrlPanel.java#newUploadPanel",
        "raw_code": "private Component newUploadPanel() {\n\t\tFragment fragment;\n\n\t\tIModel<Collection<FileUpload>> model = new PropertyModel<Collection<FileUpload>>(this, \"uploads\");\n\t\tString acceptedFiles;\n\t\tif (isImage)\n\t\t\tacceptedFiles = \"image/*\";\n\t\telse\n\t\t\tacceptedFiles = null;\n\t\t\n\t\tAttachmentSupport attachmentSupport = markdownEditor.getAttachmentSupport();\n\t\tif (attachmentSupport != null) {\n\t\t\tfragment = new Fragment(CONTENT_ID, \"uploadAttachmentFrag\", this);\n\t\t\t\n\t\t\tForm<?> form = new Form<Void>(\"form\") {\n\n\t\t\t\t@Override\n\t\t\t\tprotected void onSubmit() {\n\t\t\t\t\tsuper.onSubmit();\n\t\t\t\t\t\n\t\t\t\t\tAjaxRequestTarget target = RequestCycle.get().find(AjaxRequestTarget.class);\n\t\t\t\t\tString attachmentName;\n\t\t\t\t\tFileUpload upload = uploads.iterator().next();\n\t\t\t\t\ttry (InputStream is = upload.getInputStream()) {\n\t\t\t\t\t\tattachmentName = attachmentSupport.saveAttachment(\n\t\t\t\t\t\t\t\tFilenameUtils.sanitizeFilename(upload.getClientFileName()), is);\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t\t}\n\t\t\t\t\tmarkdownEditor.insertUrl(target, isImage, \n\t\t\t\t\t\t\tattachmentSupport.getAttachmentUrl(attachmentName), UrlUtils.describe(attachmentName), null);\n\t\t\t\t\tonClose(target);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tprotected void onFileUploadException(FileUploadException e, Map<String, Object> model) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t};\n\t\t\tform.setMaxSize(Bytes.bytes(attachmentSupport.getAttachmentMaxSize()));\n\t\t\tform.setMultiPart(true);\n\t\t\tform.add(new FencedFeedbackPanel(\"feedback\", form));\n\t\t\t\n\t\t\tint maxFilesize = (int) (attachmentSupport.getAttachmentMaxSize()/1024/1024);\n\t\t\tif (maxFilesize <= 0)\n\t\t\t\tmaxFilesize = 1;\n\t\t\tform.add(new DropzoneField(\"file\", model, acceptedFiles, 1, maxFilesize)\n\t\t\t\t\t.setRequired(true).setLabel(Model.of(\"Attachment\")));\n\t\t\t\n\t\t\tform.add(new AjaxButton(\"insert\"){});\n\t\t\t\n\t\t\tfragment.add(form);\n\t\t} else {\n\t\t\tfragment = new Fragment(CONTENT_ID, \"uploadBlobFrag\", this);\n\t\t\tForm<?> form = new Form<Void>(\"form\");\n\t\t\tform.setMultiPart(true);\n\t\t\tform.setFileMaxSize(Bytes.megabytes(Project.MAX_UPLOAD_SIZE));\n\t\t\tadd(form);\n\t\t\t\n\t\t\tFencedFeedbackPanel feedback = new FencedFeedbackPanel(\"feedback\", form);\n\t\t\tfeedback.setOutputMarkupPlaceholderTag(true);\n\t\t\tform.add(feedback);\n\t\t\t\n\t\t\tform.add(new DropzoneField(\"file\", model, acceptedFiles, 1, Project.MAX_UPLOAD_SIZE)\n\t\t\t\t\t.setRequired(true).setLabel(Model.of(\"Attachment\")));\n\n\t\t\tform.add(new TextField<String>(\"directory\", new IModel<String>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void detach() {\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic String getObject() {\n\t\t\t\t\treturn WebSession.get().getMetaData(UPLOAD_DIRECTORY);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void setObject(String object) {\n\t\t\t\t\tWebSession.get().setMetaData(UPLOAD_DIRECTORY, object);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t})); \n\n\t\t\tBlobRenderContext context = Preconditions.checkNotNull(markdownEditor.getBlobRenderContext());\n\t\t\tObjectId commitId = resolveCommitId(context);\n\t\t\tSet<BlobIdent> folderPickerState = getPickerState(commitId, context.getBlobIdent(), \n\t\t\t\t\tWebSession.get().getMetaData(FOLDER_PICKER_STATE));\n\t\t\t\n\t\t\tform.add(new DropdownLink(\"select\") {\n\n\t\t\t\t@Override\n\t\t\t\tprotected Component newContent(String id, FloatingPanel dropdown) {\n\t\t\t\t\treturn new BlobFolderPicker(id, commitId) {\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onSelect(AjaxRequestTarget target, BlobIdent blobIdent) {\n\t\t\t\t\t\t\tdropdown.close();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tString relativePath = PathUtils.relativize(context.getDirectory(), blobIdent.path);\n\t\t\t\t\t\t\tString script = String.format(\"$('form.upload-blob .directory input').val('%s');\", \n\t\t\t\t\t\t\t\t\tJavaScriptEscape.escapeJavaScript(relativePath));\n\t\t\t\t\t\t\ttarget.appendJavaScript(script);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected Project getProject() {\n\t\t\t\t\t\t\treturn markdownEditor.getBlobRenderContext().getProject();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onStateChange() {\n\t\t\t\t\t\t\tHashSet<String> expandedPaths = new HashSet<>();\n\t\t\t\t\t\t\tfor (BlobIdent blobIdent: folderPickerState)\n\t\t\t\t\t\t\t\texpandedPaths.add(blobIdent.path);\n\t\t\t\t\t\t\tWebSession.get().setMetaData(FOLDER_PICKER_STATE, expandedPaths);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected Set<BlobIdent> getState() {\n\t\t\t\t\t\t\treturn folderPickerState;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t\n\t\t\t});\n\t\t\t\n\t\t\tReferenceInputBehavior behavior = new ReferenceInputBehavior(true) {\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tprotected Project getProject() {\n\t\t\t\t\treturn markdownEditor.getBlobRenderContext().getProject();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t};\n\t\t\tform.add(new TextField<String>(\"summaryCommitMessage\", \n\t\t\t\t\tnew PropertyModel<String>(this, \"summaryCommitMessage\")).add(behavior));\n\t\t\t\n\t\t\tbehavior = new ReferenceInputBehavior(true) {\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tprotected Project getProject() {\n\t\t\t\t\treturn markdownEditor.getBlobRenderContext().getProject();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t};\n\t\t\tform.add(new TextArea<String>(\"detailCommitMessage\", \n\t\t\t\t\tnew PropertyModel<String>(this, \"detailCommitMessage\")).add(behavior));\n\t\t\t\n\t\t\tform.add(new AjaxButton(\"insert\") {\n\n\t\t\t\t@Override\n\t\t\t\tprotected void onSubmit(AjaxRequestTarget target, Form<?> form) {\n\t\t\t\t\tsuper.onSubmit(target, form);\n\n\t\t\t\t\tBlobRenderContext context = Preconditions.checkNotNull(markdownEditor.getBlobRenderContext());\n\t\t\t\t\tString commitMessage = summaryCommitMessage;\n\t\t\t\t\tif (StringUtils.isBlank(commitMessage))\n\t\t\t\t\t\tcommitMessage = \"Add files via upload\";\n\t\t\t\t\t\n\t\t\t\t\tif (StringUtils.isNotBlank(detailCommitMessage))\n\t\t\t\t\t\tcommitMessage += \"\\n\\n\" + detailCommitMessage;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tString directory = WebSession.get().getMetaData(UPLOAD_DIRECTORY);\n\t\t\t\t\t\tcontext.onCommitted(null, context.uploadFiles(uploads, directory, commitMessage), null);\n\t\t\t\t\t\t\n\t\t\t\t\t\tString fileName = uploads.iterator().next().getClientFileName();\n\t\t\t\t\t\tString url;\n\t\t\t\t\t\tif (directory != null) \n\t\t\t\t\t\t\turl = directory + \"/\" + UrlUtils.encodePath(fileName);\n\t\t\t\t\t\telse \n\t\t\t\t\t\t\turl = UrlUtils.encodePath(fileName);\n\t\t\t\t\t\tmarkdownEditor.insertUrl(target, isImage, url, UrlUtils.describe(fileName), null);\n\t\t\t\t\t\tonClose(target);\n\t\t\t\t\t} catch (GitException e) {\n\t\t\t\t\t\tform.error(e.getMessage());\n\t\t\t\t\t\ttarget.add(feedback);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tprotected void onError(AjaxRequestTarget target, Form<?> form) {\n\t\t\t\t\tsuper.onError(target, form);\n\t\t\t\t\ttarget.add(feedback);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t});\n\t\t\t\n\t\t\tfragment.add(form);\n\t\t}\n\t\t\n\t\tfragment.setOutputMarkupId(true);\n\t\treturn fragment;\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "jclouds",
    "cve_id": "CVE-2025-24961",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "b0819e0ef5e08c792a4d1724b938714ce9503aa3",
    "short_hash": "b0819e0e",
    "vulnerableMethods_before": [
      {
        "filename": "FilesystemStorageStrategyImpl.java",
        "method_name": "getBlob",
        "raw_code": "@Override\n   public Blob getBlob(final String container, final String key) {\n      BlobBuilder builder = blobBuilders.get();\n      builder.name(key);\n      File file = getFileForBlobKey(container, key);\n      ByteSource byteSource;\n      boolean isDirectory = false;\n\n      if (getDirectoryBlobSuffix(key) != null) {\n         if (!file.isDirectory()) {\n            // filesystem blobstore does not allow the existence of \"file\" and\n            // \"file/\" and getDirectoryBlobSuffix normalizes \"file/\" to \"file\".\n            // Therefore we need to return null when the normalized file is not\n            // a directory.\n            return null;\n         }\n         logger.debug(\"%s - %s is a directory\", container, key);\n         byteSource = ByteSource.empty();\n         isDirectory = true;\n      } else {\n         byteSource = Files.asByteSource(file);\n      }\n      try {\n         String cacheControl = null;\n         String contentDisposition = null;\n         String contentEncoding = null;\n         String contentLanguage = null;\n         String contentType = isDirectory ? \"application/x-directory\" : null;\n         HashCode hashCode = null;\n         String eTag = null;\n         Date expires = null;\n         Tier tier = Tier.STANDARD;\n         ImmutableMap.Builder<String, String> userMetadata = ImmutableMap.builder();\n\n         UserDefinedFileAttributeView view = getUserDefinedFileAttributeView(file.toPath());\n         if (view != null) {\n            try {\n               Set<String> attributes = ImmutableSet.copyOf(view.list());\n\n               cacheControl = readStringAttributeIfPresent(view, attributes, XATTR_CACHE_CONTROL);\n               contentDisposition = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_DISPOSITION);\n               contentEncoding = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_ENCODING);\n               contentLanguage = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_LANGUAGE);\n               if (!isDirectory) {\n                  contentType = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_TYPE);\n                  if (contentType == null && autoDetectContentType) {\n                     contentType = probeContentType(file.toPath());\n                  }\n               }\n               if (attributes.contains(XATTR_CONTENT_MD5)) {\n                  ByteBuffer buf = ByteBuffer.allocate(view.size(XATTR_CONTENT_MD5));\n                  view.read(XATTR_CONTENT_MD5, buf);\n                  byte [] etagBytes = buf.array();\n                  if (etagBytes.length == 16) {\n                     // regular object\n                     hashCode = HashCode.fromBytes(buf.array());\n                     eTag = \"\\\"\" + hashCode + \"\\\"\";\n                  } else {\n                     // multi-part object\n                     eTag = new String(etagBytes, US_ASCII);\n                  }\n               }\n               if (attributes.contains(XATTR_EXPIRES)) {\n                  ByteBuffer buf = ByteBuffer.allocate(view.size(XATTR_EXPIRES));\n                  view.read(XATTR_EXPIRES, buf);\n                  buf.flip();\n                  expires = new Date(buf.asLongBuffer().get());\n               }\n               String tierString = readStringAttributeIfPresent(view, attributes, XATTR_STORAGE_TIER);\n               if (tierString != null) {\n                  tier = Tier.valueOf(tierString);\n               }\n               for (String attribute : attributes) {\n                  if (!attribute.startsWith(XATTR_USER_METADATA_PREFIX)) {\n                     continue;\n                  }\n                  String value = readStringAttributeIfPresent(view, attributes, attribute);\n                  userMetadata.put(attribute.substring(XATTR_USER_METADATA_PREFIX.length()), value);\n               }\n            } catch (IOException e) {\n               logger.debug(\"xattrs not supported on %s\", file.toPath());\n            }\n\n            builder.payload(byteSource)\n               .cacheControl(cacheControl)\n               .contentDisposition(contentDisposition)\n               .contentEncoding(contentEncoding)\n               .contentLanguage(contentLanguage)\n               .contentLength(byteSource.size())\n               .contentMD5(hashCode)\n               .eTag(eTag)\n               .contentType(contentType)\n               .expires(expires)\n               .tier(tier)\n               .userMetadata(userMetadata.build());\n         } else {\n            builder.payload(byteSource)\n               .contentLength(byteSource.size())\n               .contentMD5(byteSource.hash(Hashing.md5()).asBytes());\n         }\n      } catch (FileNotFoundException fnfe) {\n         return null;\n      } catch (IOException e) {\n         throw Throwables.propagate(e);\n      }\n      Blob blob = builder.type(isDirectory ? StorageType.FOLDER : StorageType.BLOB).build();\n      blob.getMetadata().setContainer(container);\n      blob.getMetadata().setLastModified(new Date(file.lastModified()));\n      blob.getMetadata().setSize(file.length());\n      if (blob.getPayload().getContentMetadata().getContentMD5() != null)\n         blob.getMetadata().setETag(base16().lowerCase().encode(blob.getPayload().getContentMetadata().getContentMD5()));\n      return blob;\n   }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FilesystemStorageStrategyImpl.java",
        "method_name": "getBlob",
        "raw_code": "@Override\n   public Blob getBlob(final String container, final String key) {\n      filesystemContainerNameValidator.validate(container);\n      filesystemBlobKeyValidator.validate(key);\n      BlobBuilder builder = blobBuilders.get();\n      builder.name(key);\n      File file = getFileForBlobKey(container, key);\n      ByteSource byteSource;\n      boolean isDirectory = false;\n\n      if (getDirectoryBlobSuffix(key) != null) {\n         if (!file.isDirectory()) {\n            // filesystem blobstore does not allow the existence of \"file\" and\n            // \"file/\" and getDirectoryBlobSuffix normalizes \"file/\" to \"file\".\n            // Therefore we need to return null when the normalized file is not\n            // a directory.\n            return null;\n         }\n         logger.debug(\"%s - %s is a directory\", container, key);\n         byteSource = ByteSource.empty();\n         isDirectory = true;\n      } else {\n         byteSource = Files.asByteSource(file);\n      }\n      try {\n         String cacheControl = null;\n         String contentDisposition = null;\n         String contentEncoding = null;\n         String contentLanguage = null;\n         String contentType = isDirectory ? \"application/x-directory\" : null;\n         HashCode hashCode = null;\n         String eTag = null;\n         Date expires = null;\n         Tier tier = Tier.STANDARD;\n         ImmutableMap.Builder<String, String> userMetadata = ImmutableMap.builder();\n\n         UserDefinedFileAttributeView view = getUserDefinedFileAttributeView(file.toPath());\n         if (view != null) {\n            try {\n               Set<String> attributes = ImmutableSet.copyOf(view.list());\n\n               cacheControl = readStringAttributeIfPresent(view, attributes, XATTR_CACHE_CONTROL);\n               contentDisposition = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_DISPOSITION);\n               contentEncoding = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_ENCODING);\n               contentLanguage = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_LANGUAGE);\n               if (!isDirectory) {\n                  contentType = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_TYPE);\n                  if (contentType == null && autoDetectContentType) {\n                     contentType = probeContentType(file.toPath());\n                  }\n               }\n               if (attributes.contains(XATTR_CONTENT_MD5)) {\n                  ByteBuffer buf = ByteBuffer.allocate(view.size(XATTR_CONTENT_MD5));\n                  view.read(XATTR_CONTENT_MD5, buf);\n                  byte [] etagBytes = buf.array();\n                  if (etagBytes.length == 16) {\n                     // regular object\n                     hashCode = HashCode.fromBytes(buf.array());\n                     eTag = \"\\\"\" + hashCode + \"\\\"\";\n                  } else {\n                     // multi-part object\n                     eTag = new String(etagBytes, US_ASCII);\n                  }\n               }\n               if (attributes.contains(XATTR_EXPIRES)) {\n                  ByteBuffer buf = ByteBuffer.allocate(view.size(XATTR_EXPIRES));\n                  view.read(XATTR_EXPIRES, buf);\n                  buf.flip();\n                  expires = new Date(buf.asLongBuffer().get());\n               }\n               String tierString = readStringAttributeIfPresent(view, attributes, XATTR_STORAGE_TIER);\n               if (tierString != null) {\n                  tier = Tier.valueOf(tierString);\n               }\n               for (String attribute : attributes) {\n                  if (!attribute.startsWith(XATTR_USER_METADATA_PREFIX)) {\n                     continue;\n                  }\n                  String value = readStringAttributeIfPresent(view, attributes, attribute);\n                  userMetadata.put(attribute.substring(XATTR_USER_METADATA_PREFIX.length()), value);\n               }\n            } catch (IOException e) {\n               logger.debug(\"xattrs not supported on %s\", file.toPath());\n            }\n\n            builder.payload(byteSource)\n               .cacheControl(cacheControl)\n               .contentDisposition(contentDisposition)\n               .contentEncoding(contentEncoding)\n               .contentLanguage(contentLanguage)\n               .contentLength(byteSource.size())\n               .contentMD5(hashCode)\n               .eTag(eTag)\n               .contentType(contentType)\n               .expires(expires)\n               .tier(tier)\n               .userMetadata(userMetadata.build());\n         } else {\n            builder.payload(byteSource)\n               .contentLength(byteSource.size())\n               .contentMD5(byteSource.hash(Hashing.md5()).asBytes());\n         }\n      } catch (FileNotFoundException fnfe) {\n         return null;\n      } catch (IOException e) {\n         throw Throwables.propagate(e);\n      }\n      Blob blob = builder.type(isDirectory ? StorageType.FOLDER : StorageType.BLOB).build();\n      blob.getMetadata().setContainer(container);\n      blob.getMetadata().setLastModified(new Date(file.lastModified()));\n      blob.getMetadata().setSize(file.length());\n      if (blob.getPayload().getContentMetadata().getContentMD5() != null)\n         blob.getMetadata().setETag(base16().lowerCase().encode(blob.getPayload().getContentMetadata().getContentMD5()));\n      return blob;\n   }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "eclipse.jdt.ui",
    "cve_id": "CVE-2023-4218",
    "cwe_list": [
      "CWE-611"
    ],
    "commit_hash": "13675b1f8a74f47de4da89ed0ded6af7c21dfbec",
    "short_hash": "13675b1f",
    "vulnerableMethods_before": [
      {
        "filename": "JavadocWriter.java",
        "method_name": "org.eclipse.jdt.ui/ui/org/eclipse/jdt/internal/ui/javadocexport/JavadocWriter.java#writeDocument",
        "raw_code": "public static void writeDocument(Element javadocElement, String encoding, OutputStream outputStream) throws TransformerException {\n\n\t\t// Write the document to the stream\n\t\tTransformer transformer=TransformerFactory.newInstance().newTransformer();\n\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\ttransformer.setOutputProperty(OutputKeys.ENCODING, encoding);\n\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\t\ttransformer.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\",\"4\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t\tDOMSource source = new DOMSource(javadocElement.getOwnerDocument());\n\t\tStreamResult result = new StreamResult(new BufferedOutputStream(outputStream));\n\t\ttransformer.transform(source, result);\n\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "JavadocWriter.java",
        "method_name": "org.eclipse.jdt.ui/ui/org/eclipse/jdt/internal/ui/javadocexport/JavadocWriter.java#writeDocument",
        "raw_code": "public static void writeDocument(Element javadocElement, String encoding, OutputStream outputStream) throws TransformerException {\n\n\t\t// Write the document to the stream\n\t\tTransformer transformer= XmlProcessorFactoryJdtUi.createTransformerFactoryWithErrorOnDOCTYPE().newTransformer();\n\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\ttransformer.setOutputProperty(OutputKeys.ENCODING, encoding);\n\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\t\ttransformer.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\",\"4\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t\tDOMSource source = new DOMSource(javadocElement.getOwnerDocument());\n\t\tStreamResult result = new StreamResult(new BufferedOutputStream(outputStream));\n\t\ttransformer.transform(source, result);\n\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "Connector",
    "cve_id": "CVE-2024-8642",
    "cwe_list": [
      "CWE-287"
    ],
    "commit_hash": "04899e91dcdb4a407db4eb7af3e7b6ff9a9e9ad6",
    "short_hash": "04899e91",
    "vulnerableMethods_before": [
      {
        "filename": "JsonObjectToContractAgreementVerificationMessageTransformer.java",
        "method_name": "data-protocols/dsp/dsp-negotiation/dsp-negotiation-transform/src/main/java/org/eclipse/edc/protocol/dsp/negotiation/transform/to/JsonObjectToContractAgreementVerificationMessageTransformer.java#transform",
        "raw_code": "@Override\n    public @Nullable ContractAgreementVerificationMessage transform(@NotNull JsonObject object, @NotNull TransformerContext context) {\n        var builder = ContractAgreementVerificationMessage.Builder.newInstance();\n        var processId = object.get(DSPACE_PROPERTY_PROCESS_ID);\n        if (!transformMandatoryString(object.get(DSPACE_PROPERTY_CONSUMER_PID), builder::consumerPid, context)) {\n            if (processId == null) {\n                context.problem()\n                        .missingProperty()\n                        .type(DSPACE_TYPE_CONTRACT_AGREEMENT_VERIFICATION_MESSAGE)\n                        .property(DSPACE_PROPERTY_CONSUMER_PID)\n                        .report();\n                return null;\n            } else {\n                builder.consumerPid(transformString(processId, context));\n            }\n        }\n        if (!transformMandatoryString(object.get(DSPACE_PROPERTY_PROVIDER_PID), builder::providerPid, context)) {\n            if (processId == null) {\n                context.problem()\n                        .missingProperty()\n                        .type(DSPACE_TYPE_CONTRACT_AGREEMENT_VERIFICATION_MESSAGE)\n                        .property(DSPACE_PROPERTY_PROVIDER_PID)\n                        .report();\n                return null;\n            } else {\n                builder.providerPid(transformString(processId, context));\n            }\n        }\n\n        return builder.build();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "JsonObjectToContractAgreementVerificationMessageTransformer.java",
        "method_name": "data-protocols/dsp/dsp-negotiation/dsp-negotiation-transform/src/main/java/org/eclipse/edc/protocol/dsp/negotiation/transform/to/JsonObjectToContractAgreementVerificationMessageTransformer.java#transform",
        "raw_code": "@Override\n    public @Nullable ContractAgreementVerificationMessage transform(@NotNull JsonObject object, @NotNull TransformerContext context) {\n        var builder = ContractAgreementVerificationMessage.Builder.newInstance();\n        if (!transformMandatoryString(object.get(DSPACE_PROPERTY_CONSUMER_PID), builder::consumerPid, context)) {\n            context.problem()\n                    .missingProperty()\n                    .type(DSPACE_TYPE_CONTRACT_AGREEMENT_VERIFICATION_MESSAGE)\n                    .property(DSPACE_PROPERTY_CONSUMER_PID)\n                    .report();\n            return null;\n        }\n        if (!transformMandatoryString(object.get(DSPACE_PROPERTY_PROVIDER_PID), builder::providerPid, context)) {\n            context.problem()\n                    .missingProperty()\n                    .type(DSPACE_TYPE_CONTRACT_AGREEMENT_VERIFICATION_MESSAGE)\n                    .property(DSPACE_PROPERTY_PROVIDER_PID)\n                    .report();\n            return null;\n        }\n\n        return builder.build();\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "californium",
    "cve_id": "CVE-2022-39368",
    "cwe_list": [
      "CWE-459"
    ],
    "commit_hash": "5648a0c27c2c2667c98419254557a14bac2b1f3f",
    "short_hash": "5648a0c2",
    "vulnerableMethods_before": [
      {
        "filename": "DTLSConnector.java",
        "method_name": "scandium-core/src/main/java/org/eclipse/californium/scandium/DTLSConnector.java#processNewClientHello",
        "raw_code": "private void processNewClientHello(final Record record) {\n\t\tInetSocketAddress peerAddress = record.getPeerAddress();\n\t\tif (LOGGER.isTraceEnabled()) {\n\t\t\tStringBuilder msg = new StringBuilder(\"Processing new CLIENT_HELLO from peer [\")\n\t\t\t\t\t.append(peerAddress).append(\"]\").append(\":\").append(StringUtil.lineSeparator()).append(record);\n\t\t\tLOGGER.trace(msg.toString());\n\t\t}\n\t\ttry {\n\t\t\t// CLIENT_HELLO with epoch 0 is not encrypted, so use DTLSConnectionState.NULL \n\t\t\trecord.applySession(null);\n\t\t\tDTLSMessage message = record.getFragment();\n\t\t\tif (message instanceof FragmentedHandshakeMessage) {\n\t\t\t\tLOGGER.debug(\"Received unsupported fragmented CLIENT_HELLO from peer [{}].\", peerAddress);\n\t\t\t\tdiscardRecord(record, new DtlsException(\"Fragmented CLIENT_HELLO is not supported!\", peerAddress));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfinal ClientHello clientHello = (ClientHello) message;\n\n\t\t\t// before starting a new handshake or resuming an established\n\t\t\t// session we need to make sure that the peer is in possession of\n\t\t\t// the IP address indicated in the client hello message\n\t\t\tfinal AvailableConnections connections = new AvailableConnections();\n\t\t\tif (isClientInControlOfSourceIpAddress(clientHello, record, connections)) {\n\t\t\t\tboolean verify = false;\n\t\t\t\tExecutorService executorService = getExecutorService();\n\t\t\t\tConnection connection;\n\t\t\t\tsynchronized (connectionStore) {\n\t\t\t\t\tconnection = connectionStore.get(peerAddress);\n\t\t\t\t\tif (connection != null && !connection.isStartedByClientHello(clientHello)) {\n\t\t\t\t\t\tConnection sessionConnection = connections.getConnectionBySessionId();\n\t\t\t\t\t\tif (sessionConnection != null && sessionConnection != connection) {\n\t\t\t\t\t\t\t// don't overwrite\n\t\t\t\t\t\t\tverify = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (sessionConnection != null && sessionConnection == connection) {\n\t\t\t\t\t\t\t\tconnections.setRemoveConnectionBySessionId(true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfinal Handshaker handshaker = connection.getOngoingHandshake();\n\t\t\t\t\t\t\tif (handshaker != null) {\n\t\t\t\t\t\t\t\tDTLSSession establishedSession = connection.getEstablishedSession();\n\t\t\t\t\t\t\t\tif (establishedSession == null || handshaker.getSession() != establishedSession) {\n\t\t\t\t\t\t\t\t\tfinal DtlsException cause = new DtlsException(\n\t\t\t\t\t\t\t\t\t\t\t\"Received new CLIENT_HELLO from \" + StringUtil.toDisplayString(peerAddress),\n\t\t\t\t\t\t\t\t\t\t\tpeerAddress);\n\t\t\t\t\t\t\t\t\thandshaker.setFailureCause(cause);\n\t\t\t\t\t\t\t\t\tconnection.getExecutor().execute(new Runnable() {\n\n\t\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\t\t\t\t\tif (running.get()) {\n\t\t\t\t\t\t\t\t\t\t\t\thandshaker.handshakeFailed(cause);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconnection = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (connection == null) {\n\t\t\t\t\t\tconnection = new Connection(peerAddress, new SerialExecutor(executorService));\n\t\t\t\t\t\tconnection.setExecutionListener(connectionExecutionListener);\n\t\t\t\t\t\tconnection.startByClientHello(clientHello);\n\t\t\t\t\t\tif (!connectionStore.put(connection)) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (verify) {\n\t\t\t\t\tsendHelloVerify(clientHello, record, null);\n\t\t\t\t} else {\n\t\t\t\t\tconnections.setConnectionByAddress(connection);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconnection.getExecutor().execute(new Runnable() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\t\tif (running.get()) {\n\t\t\t\t\t\t\t\t\tprocessClientHello(clientHello, record, connections);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t} catch (RejectedExecutionException e) {\n\t\t\t\t\t\t// dont't terminate connection on shutdown!\n\t\t\t\t\t\tLOGGER.debug(\"Execution rejected while processing record [type: {}, peer: {}]\",\n\t\t\t\t\t\t\t\trecord.getType(), peerAddress, e);\n\t\t\t\t\t} catch (RuntimeException e) {\n\t\t\t\t\t\tLOGGER.warn(\"Unexpected error occurred while processing record [type: {}, peer: {}]\",\n\t\t\t\t\t\t\t\trecord.getType(), peerAddress, e);\n\t\t\t\t\t\tterminateConnection(connections.getConnectionByAddress(), e, AlertLevel.FATAL, AlertDescription.INTERNAL_ERROR);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (HandshakeException e) {\n\t\t\tLOGGER.debug(\"Processing new CLIENT_HELLO from peer [{}] failed!\", record.getPeerAddress(), e);\n\t\t} catch (GeneralSecurityException e) {\n\t\t\tDROP_LOGGER.debug(\"Processing new CLIENT_HELLO from peer [{}] failed!\", record.getPeerAddress(), e);\n\t\t} catch (RuntimeException e) {\n\t\t\tLOGGER.warn(\"Processing new CLIENT_HELLO from peer [{}] failed!\", record.getPeerAddress(), e);\n\t\t}\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DTLSConnector.java",
        "method_name": "scandium-core/src/main/java/org/eclipse/californium/scandium/DTLSConnector.java#processNewClientHello",
        "raw_code": "private void processNewClientHello(final Record record) {\n\t\tInetSocketAddress peerAddress = record.getPeerAddress();\n\t\tif (LOGGER.isTraceEnabled()) {\n\t\t\tStringBuilder msg = new StringBuilder(\"Processing new CLIENT_HELLO from peer [\")\n\t\t\t\t\t.append(peerAddress).append(\"]\").append(\":\").append(StringUtil.lineSeparator()).append(record);\n\t\t\tLOGGER.trace(msg.toString());\n\t\t}\n\t\ttry {\n\t\t\t// CLIENT_HELLO with epoch 0 is not encrypted, so use DTLSConnectionState.NULL \n\t\t\trecord.applySession(null);\n\t\t\tDTLSMessage message = record.getFragment();\n\t\t\tif (message instanceof FragmentedHandshakeMessage) {\n\t\t\t\tLOGGER.debug(\"Received unsupported fragmented CLIENT_HELLO from peer [{}].\", peerAddress);\n\t\t\t\tdiscardRecord(record, new DtlsException(\"Fragmented CLIENT_HELLO is not supported!\", peerAddress));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfinal ClientHello clientHello = (ClientHello) message;\n\n\t\t\t// before starting a new handshake or resuming an established\n\t\t\t// session we need to make sure that the peer is in possession of\n\t\t\t// the IP address indicated in the client hello message\n\t\t\tfinal AvailableConnections connections = new AvailableConnections();\n\t\t\tif (isClientInControlOfSourceIpAddress(clientHello, record, connections)) {\n\t\t\t\tboolean verify = false;\n\t\t\t\tExecutorService executorService = getExecutorService();\n\t\t\t\tConnection connection;\n\t\t\t\tsynchronized (connectionStore) {\n\t\t\t\t\tconnection = connectionStore.get(peerAddress);\n\t\t\t\t\tif (connection != null && !connection.isStartedByClientHello(clientHello)) {\n\t\t\t\t\t\tConnection sessionConnection = connections.getConnectionBySessionId();\n\t\t\t\t\t\tif (sessionConnection != null && sessionConnection != connection) {\n\t\t\t\t\t\t\t// don't overwrite\n\t\t\t\t\t\t\tverify = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (sessionConnection != null && sessionConnection == connection) {\n\t\t\t\t\t\t\t\tconnections.setRemoveConnectionBySessionId(true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfinal Handshaker handshaker = connection.getOngoingHandshake();\n\t\t\t\t\t\t\tif (handshaker != null) {\n\t\t\t\t\t\t\t\tDTLSSession establishedSession = connection.getEstablishedSession();\n\t\t\t\t\t\t\t\tif (establishedSession == null || handshaker.getSession() != establishedSession) {\n\t\t\t\t\t\t\t\t\tfinal DtlsException cause = new DtlsException(\n\t\t\t\t\t\t\t\t\t\t\t\"Received new CLIENT_HELLO from \" + StringUtil.toDisplayString(peerAddress),\n\t\t\t\t\t\t\t\t\t\t\tpeerAddress);\n\t\t\t\t\t\t\t\t\thandshaker.setFailureCause(cause);\n\t\t\t\t\t\t\t\t\tconnection.getExecutor().execute(new Runnable() {\n\n\t\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\t\t\t\t\tif (running.get()) {\n\t\t\t\t\t\t\t\t\t\t\t\thandshaker.handshakeFailed(cause);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconnection = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (connection == null) {\n\t\t\t\t\t\tconnection = new Connection(peerAddress, new SerialExecutor(executorService));\n\t\t\t\t\t\tconnection.setExecutionListener(connectionExecutionListener);\n\t\t\t\t\t\tconnection.startByClientHello(clientHello);\n\t\t\t\t\t\tif (!connectionStore.put(connection)) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (verify) {\n\t\t\t\t\tsendHelloVerify(clientHello, record, null);\n\t\t\t\t} else {\n\t\t\t\t\tconnections.setConnectionByAddress(connection);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconnection.getExecutor().execute(new Runnable() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\t\tif (running.get() && connections.getConnectionByAddress().isExecuting()) {\n\t\t\t\t\t\t\t\t\tprocessClientHello(clientHello, record, connections);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t} catch (RejectedExecutionException e) {\n\t\t\t\t\t\t// dont't terminate connection on shutdown!\n\t\t\t\t\t\tLOGGER.debug(\"Execution rejected while processing record [type: {}, peer: {}]\",\n\t\t\t\t\t\t\t\trecord.getType(), peerAddress, e);\n\t\t\t\t\t} catch (RuntimeException e) {\n\t\t\t\t\t\tLOGGER.warn(\"Unexpected error occurred while processing record [type: {}, peer: {}]\",\n\t\t\t\t\t\t\t\trecord.getType(), peerAddress, e);\n\t\t\t\t\t\tterminateConnection(connections.getConnectionByAddress(), e, AlertLevel.FATAL, AlertDescription.INTERNAL_ERROR);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (HandshakeException e) {\n\t\t\tLOGGER.debug(\"Processing new CLIENT_HELLO from peer [{}] failed!\", record.getPeerAddress(), e);\n\t\t} catch (GeneralSecurityException e) {\n\t\t\tDROP_LOGGER.debug(\"Processing new CLIENT_HELLO from peer [{}] failed!\", record.getPeerAddress(), e);\n\t\t} catch (RuntimeException e) {\n\t\t\tLOGGER.warn(\"Processing new CLIENT_HELLO from peer [{}] failed!\", record.getPeerAddress(), e);\n\t\t}\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "opencrx",
    "cve_id": "CVE-2023-46502",
    "cwe_list": [
      "CWE-611"
    ],
    "commit_hash": "ce7a71db0bb34ecbcb0e822d40598e410a48b399",
    "short_hash": "ce7a71db",
    "vulnerableMethods_before": [
      {
        "filename": "WebDavMethod.java",
        "method_name": "core/src/main/java/org/opencrx/application/uses/net/sf/webdav/methods/WebDavMethod.java#getDocumentBuilder",
        "raw_code": "protected DocumentBuilder getDocumentBuilder(\n    ) throws ServiceException {\n        DocumentBuilder documentBuilder = null;\n        DocumentBuilderFactory documentBuilderFactory = null;\n        try {\n            documentBuilderFactory = DocumentBuilderFactory.newInstance();\n            documentBuilderFactory.setNamespaceAware(true);\n            documentBuilder = documentBuilderFactory.newDocumentBuilder();\n        } catch (ParserConfigurationException e) {\n            throw new ServiceException(e);\n        }\n        return documentBuilder;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "WebDavMethod.java",
        "method_name": "core/src/main/java/org/opencrx/application/uses/net/sf/webdav/methods/WebDavMethod.java#getDocumentBuilder",
        "raw_code": "protected DocumentBuilder getDocumentBuilder(\n    ) throws ServiceException {\n        DocumentBuilder documentBuilder = null;\n        DocumentBuilderFactory documentBuilderFactory = null;\n        documentBuilderFactory = DocumentBuilderFactory.newInstance();\n        documentBuilderFactory.setNamespaceAware(true);\n        // Flags required to prevent XML eXternal Entity injection (XXE)\n        try {\n        \tdocumentBuilderFactory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n        } catch (ParserConfigurationException e) {\n            throw new ServiceException(e);\n        }\n        try {\n        \tdocumentBuilderFactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n        } catch (ParserConfigurationException e) {\n            throw new ServiceException(e);\n        }\n        try {\n        \tdocumentBuilderFactory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n        } catch (ParserConfigurationException e) {\n            throw new ServiceException(e);\n        }\n        try {\n        \tdocumentBuilderFactory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n        } catch (ParserConfigurationException e) {\n            throw new ServiceException(e);\n        }\n        try {\n        \tdocumentBuilder = documentBuilderFactory.newDocumentBuilder();\n        } catch (ParserConfigurationException e) {\n            throw new ServiceException(e);\n        }\n        return documentBuilder;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xp",
    "cve_id": "CVE-2024-23679",
    "cwe_list": [
      "CWE-384"
    ],
    "commit_hash": "1f44674eb9ab3fbab7103e8d08067846e88bace4",
    "short_hash": "1f44674e",
    "vulnerableMethods_before": [
      {
        "filename": "LoginHandler.java",
        "method_name": "modules/lib/lib-auth/src/main/java/com/enonic/xp/lib/auth/LoginHandler.java#getSortedIdProviders",
        "raw_code": "private IdProviders getSortedIdProviders()\n    {\n        IdProviders idProviders = securityService.get().getIdProviders();\n        return IdProviders.from( idProviders.stream().\n            sorted( Comparator.comparing( u -> u.getKey().toString() ) ).\n            collect( Collectors.toList() ) );\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "LoginHandler.java",
        "method_name": "modules/lib/lib-auth/src/main/java/com/enonic/xp/lib/auth/LoginHandler.java#getSortedIdProviders",
        "raw_code": "private IdProviders getSortedIdProviders()\n    {\n        IdProviders idProviders = securityService.get().getIdProviders();\n        return IdProviders.from(\n            idProviders.stream().sorted( Comparator.comparing( u -> u.getKey().toString() ) ).collect( Collectors.toList() ) );\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "jw-community",
    "cve_id": "CVE-2022-4560",
    "cwe_list": [
      "CWE-79"
    ],
    "commit_hash": "ecf8be8f6f0cb725c18536ddc726d42a11bdaa1b",
    "short_hash": "ecf8be8f",
    "vulnerableMethods_before": [
      {
        "filename": "UniversalTheme.java",
        "method_name": "wflow-core/src/main/java/org/joget/plugin/enterprise/UniversalTheme.java#getInternalJsCssLib",
        "raw_code": "protected String getInternalJsCssLib(Map<String, Object> data) {\n        String jsCssLink = \"\";\n               \n        // PWA: register service worker\n        if (!\"true\".equals(getPropertyString(\"disablePwa\"))) {\n            WorkflowUserManager workflowUserManager = (WorkflowUserManager)AppUtil.getApplicationContext().getBean(\"workflowUserManager\");\n            boolean pushEnabled = !\"true\".equals(getPropertyString(\"disablePush\")) && !workflowUserManager.isCurrentUserAnonymous();\n            String appId = userview.getParamString(\"appId\");\n            if (appId != null && !appId.isEmpty()) {\n                String userviewId = userview.getPropertyString(\"id\");\n                String key = userview.getParamString(\"key\");\n                if (key.isEmpty()) {\n                    key = Userview.USERVIEW_KEY_EMPTY_VALUE;\n                }\n                \n                boolean isEmbedded = false;\n                if(data.get(\"embed\") != null){\n                    isEmbedded = (Boolean) data.get(\"embed\");\n                };\n                \n                String pwaOnlineNotificationMessage = ResourceBundleUtil.getMessage(\"pwa.onlineNow\");\n                String pwaOfflineNotificationMessage = ResourceBundleUtil.getMessage(\"pwa.offlineNow\");\n                String pwaLoginPromptMessage = ResourceBundleUtil.getMessage(\"pwa.loginPrompt\");\n                String pwaSyncingMessage = ResourceBundleUtil.getMessage(\"pwa.syncing\");\n                String pwaSyncFailedMessage = ResourceBundleUtil.getMessage(\"pwa.syncFailed\");\n                String pwaSyncSuccessMessage = ResourceBundleUtil.getMessage(\"pwa.syncSuccess\");\n                String buildNumber = ResourceBundleUtil.getMessage(\"build.number\");\n                \n                String serviceWorkerUrl = data.get(\"context_path\") + \"/web/userview/\" + appId + \"/\" + userviewId + \"/\"+key+\"/serviceworker\";\n                jsCssLink += \"<script>$(function() {\"\n                        + \"var initPwaUtil = function(){\"\n                        + \"PwaUtil.contextPath = '\" + data.get(\"context_path\") + \"';\"\n                        + \"PwaUtil.userviewKey = '\" + key + \"';\"\n                        + \"PwaUtil.homePageLink = '\" + data.get(\"home_page_link\") + \"';\"\n                        + \"PwaUtil.serviceWorkerPath = '\" + serviceWorkerUrl + \"';\"\n                        + \"PwaUtil.subscriptionApiPath = '\" + data.get(\"context_path\") + \"/web/console/profile/subscription';\"\n                        + \"PwaUtil.pushEnabled = \" + pushEnabled + \";\"\n                        + \"PwaUtil.currentUsername = '\" + workflowUserManager.getCurrentUsername() + \"';\"\n                        + \"PwaUtil.onlineNotificationMessage = '\" + pwaOnlineNotificationMessage + \"';\"\n                        + \"PwaUtil.offlineNotificationMessage = '\" + pwaOfflineNotificationMessage + \"';\"\n                        + \"PwaUtil.loginPromptMessage = '\" + pwaLoginPromptMessage + \"';\"\n                        + \"PwaUtil.syncingMessage = '\" + pwaSyncingMessage + \"';\"\n                        + \"PwaUtil.syncFailedMessage = '\" + pwaSyncFailedMessage + \"';\"\n                        + \"PwaUtil.syncSuccessMessage = '\" + pwaSyncSuccessMessage + \"';\"\n                        + \"PwaUtil.isEmbedded = \" + isEmbedded + \";\"\n                        + \"PwaUtil.register();\"\n                        + \"PwaUtil.init();\"\n                        + \"};\"\n                        + \"if (typeof PwaUtil !== \\\"undefined\\\") {initPwaUtil();} else { $(document).on(\\\"PwaUtil.ready\\\", function(){ initPwaUtil(); });}\"\n                        + \"});</script>\";\n            }\n        }\n        return jsCssLink;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "UniversalTheme.java",
        "method_name": "wflow-core/src/main/java/org/joget/plugin/enterprise/UniversalTheme.java#getInternalJsCssLib",
        "raw_code": "protected String getInternalJsCssLib(Map<String, Object> data) {\n        String jsCssLink = \"\";\n               \n        // PWA: register service worker\n        if (!\"true\".equals(getPropertyString(\"disablePwa\"))) {\n            WorkflowUserManager workflowUserManager = (WorkflowUserManager)AppUtil.getApplicationContext().getBean(\"workflowUserManager\");\n            boolean pushEnabled = !\"true\".equals(getPropertyString(\"disablePush\")) && !workflowUserManager.isCurrentUserAnonymous();\n            String appId = userview.getParamString(\"appId\");\n            if (appId != null && !appId.isEmpty()) {\n                String userviewId = userview.getPropertyString(\"id\");\n                String key = userview.getParamString(\"key\");\n                if (key.isEmpty()) {\n                    key = Userview.USERVIEW_KEY_EMPTY_VALUE;\n                }\n                \n                boolean isEmbedded = false;\n                if(data.get(\"embed\") != null){\n                    isEmbedded = (Boolean) data.get(\"embed\");\n                };\n                \n                String pwaOnlineNotificationMessage = ResourceBundleUtil.getMessage(\"pwa.onlineNow\");\n                String pwaOfflineNotificationMessage = ResourceBundleUtil.getMessage(\"pwa.offlineNow\");\n                String pwaLoginPromptMessage = ResourceBundleUtil.getMessage(\"pwa.loginPrompt\");\n                String pwaSyncingMessage = ResourceBundleUtil.getMessage(\"pwa.syncing\");\n                String pwaSyncFailedMessage = ResourceBundleUtil.getMessage(\"pwa.syncFailed\");\n                String pwaSyncSuccessMessage = ResourceBundleUtil.getMessage(\"pwa.syncSuccess\");\n                String buildNumber = ResourceBundleUtil.getMessage(\"build.number\");\n                \n                String serviceWorkerUrl = data.get(\"context_path\") + \"/web/userview/\" + appId + \"/\" + userviewId + \"/\"+key+\"/serviceworker\";\n                jsCssLink += \"<script>$(function() {\"\n                        + \"var initPwaUtil = function(){\"\n                        + \"PwaUtil.contextPath = '\" + StringUtil.escapeString(data.get(\"context_path\").toString(), StringUtil.TYPE_JAVASCIPT, null) + \"';\"\n                        + \"PwaUtil.userviewKey = '\" + StringUtil.escapeString(key, StringUtil.TYPE_JAVASCIPT, null) + \"';\"\n                        + \"PwaUtil.homePageLink = '\" + StringUtil.escapeString(data.get(\"home_page_link\").toString(), StringUtil.TYPE_JAVASCIPT, null) + \"';\"\n                        + \"PwaUtil.serviceWorkerPath = '\" + StringUtil.escapeString(serviceWorkerUrl, StringUtil.TYPE_JAVASCIPT, null) + \"';\"\n                        + \"PwaUtil.subscriptionApiPath = '\" + StringUtil.escapeString(data.get(\"context_path\").toString(), StringUtil.TYPE_JAVASCIPT, null) + \"/web/console/profile/subscription';\"\n                        + \"PwaUtil.pushEnabled = \" + pushEnabled + \";\"\n                        + \"PwaUtil.currentUsername = '\" + StringUtil.escapeString(workflowUserManager.getCurrentUsername(), StringUtil.TYPE_JAVASCIPT, null) + \"';\"\n                        + \"PwaUtil.onlineNotificationMessage = '\" + StringUtil.escapeString(pwaOnlineNotificationMessage, StringUtil.TYPE_JAVASCIPT, null) + \"';\"\n                        + \"PwaUtil.offlineNotificationMessage = '\" + StringUtil.escapeString(pwaOfflineNotificationMessage, StringUtil.TYPE_JAVASCIPT, null) + \"';\"\n                        + \"PwaUtil.loginPromptMessage = '\" + StringUtil.escapeString(pwaLoginPromptMessage, StringUtil.TYPE_JAVASCIPT, null) + \"';\"\n                        + \"PwaUtil.syncingMessage = '\" + StringUtil.escapeString(pwaSyncingMessage, StringUtil.TYPE_JAVASCIPT, null) + \"';\"\n                        + \"PwaUtil.syncFailedMessage = '\" + StringUtil.escapeString(pwaSyncFailedMessage, StringUtil.TYPE_JAVA, null) + \"';\"\n                        + \"PwaUtil.syncSuccessMessage = '\" + StringUtil.escapeString(pwaSyncSuccessMessage, StringUtil.TYPE_JAVASCIPT, null) + \"';\"\n                        + \"PwaUtil.isEmbedded = \" + isEmbedded + \";\"\n                        + \"PwaUtil.register();\"\n                        + \"PwaUtil.init();\"\n                        + \"};\"\n                        + \"if (typeof PwaUtil !== \\\"undefined\\\") {initPwaUtil();} else { $(document).on(\\\"PwaUtil.ready\\\", function(){ initPwaUtil(); });}\"\n                        + \"});</script>\";\n            }\n        }\n        return jsCssLink;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "snowflake-jdbc",
    "cve_id": "CVE-2025-24790",
    "cwe_list": [
      "CWE-276"
    ],
    "commit_hash": "9e1a5acf12406b16c4780ca013f4c4db48b74b59",
    "short_hash": "9e1a5acf",
    "vulnerableMethods_before": [
      {
        "filename": "FileCacheManager.java",
        "method_name": "overrideCacheFile",
        "raw_code": "void overrideCacheFile(File newCacheFile) {\n    this.cacheFile = newCacheFile;\n    this.cacheDir = newCacheFile.getParentFile();\n    this.baseCacheFileName = newCacheFile.getName();\n    FileUtil.logFileUsage(cacheFile, \"Override cache file\", true);\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FileCacheManager.java",
        "method_name": "overrideCacheFile",
        "raw_code": "void overrideCacheFile(File newCacheFile) {\n    if (!newCacheFile.exists()) {\n      logger.debug(\"Cache file doesn't exists. File: {}\", newCacheFile);\n    }\n    if (onlyOwnerPermissions) {\n      FileUtil.throwWhenPermiossionDifferentThanReadWriteForOwner(\n          newCacheFile, \"Override cache file\");\n    } else {\n      FileUtil.logFileUsage(cacheFile, \"Override cache file\", false);\n    }\n    this.cacheFile = newCacheFile;\n    this.cacheDir = newCacheFile.getParentFile();\n    this.baseCacheFileName = newCacheFile.getName();\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "fastjson",
    "cve_id": "CVE-2022-25845",
    "cwe_list": [
      "CWE-502"
    ],
    "commit_hash": "8f3410f81cbd437f7c459f8868445d50ad301f15",
    "short_hash": "8f3410f8",
    "vulnerableMethods_before": [
      {
        "filename": "ParserConfig.java",
        "method_name": "src/main/java/com/alibaba/fastjson/parser/ParserConfig.java#checkAutoType",
        "raw_code": "public Class<?> checkAutoType(String typeName, Class<?> expectClass, int features) {\n        if (typeName == null) {\n            return null;\n        }\n\n        if (autoTypeCheckHandlers != null) {\n            for (AutoTypeCheckHandler h : autoTypeCheckHandlers) {\n                Class<?> type = h.handler(typeName, expectClass, features);\n                if (type != null) {\n                    return type;\n                }\n            }\n        }\n\n        final int safeModeMask = Feature.SafeMode.mask;\n        boolean safeMode = this.safeMode\n                || (features & safeModeMask) != 0\n                || (JSON.DEFAULT_PARSER_FEATURE & safeModeMask) != 0;\n        if (safeMode) {\n            throw new JSONException(\"safeMode not support autoType : \" + typeName);\n        }\n\n        if (typeName.length() >= 192 || typeName.length() < 3) {\n            throw new JSONException(\"autoType is not support. \" + typeName);\n        }\n\n        final boolean expectClassFlag;\n        if (expectClass == null) {\n            expectClassFlag = false;\n        } else {\n            long expectHash = TypeUtils.fnv1a_64(expectClass.getName());\n            if (expectHash == 0x90a25f5baa21529eL\n                    || expectHash == 0x2d10a5801b9d6136L\n                    || expectHash == 0xaf586a571e302c6bL\n                    || expectHash == 0xed007300a7b227c6L\n                    || expectHash == 0x295c4605fd1eaa95L\n                    || expectHash == 0x47ef269aadc650b4L\n                    || expectHash == 0x6439c4dff712ae8bL\n                    || expectHash == 0xe3dd9875a2dc5283L\n                    || expectHash == 0xe2a8ddba03e69e0dL\n                    || expectHash == 0xd734ceb4c3e9d1daL\n            ) {\n                expectClassFlag = false;\n            } else {\n                expectClassFlag = true;\n            }\n        }\n\n        String className = typeName.replace('$', '.');\n        Class<?> clazz;\n\n        final long h1 = (fnv1a_64_magic_hashcode ^ className.charAt(0)) * fnv1a_64_magic_prime;\n        if (h1 == 0xaf64164c86024f1aL) { // [\n            throw new JSONException(\"autoType is not support. \" + typeName);\n        }\n\n        if ((h1 ^ className.charAt(className.length() - 1)) * fnv1a_64_magic_prime == 0x9198507b5af98f0L) {\n            throw new JSONException(\"autoType is not support. \" + typeName);\n        }\n\n        final long h3 = (((((fnv1a_64_magic_hashcode ^ className.charAt(0))\n                * fnv1a_64_magic_prime)\n                ^ className.charAt(1))\n                * fnv1a_64_magic_prime)\n                ^ className.charAt(2))\n                * fnv1a_64_magic_prime;\n\n        long fullHash = TypeUtils.fnv1a_64(className);\n        boolean internalWhite = Arrays.binarySearch(INTERNAL_WHITELIST_HASHCODES,  fullHash) >= 0;\n\n        if (internalDenyHashCodes != null) {\n            long hash = h3;\n            for (int i = 3; i < className.length(); ++i) {\n                hash ^= className.charAt(i);\n                hash *= fnv1a_64_magic_prime;\n                if (Arrays.binarySearch(internalDenyHashCodes, hash) >= 0) {\n                    throw new JSONException(\"autoType is not support. \" + typeName);\n                }\n            }\n        }\n\n        if ((!internalWhite) && (autoTypeSupport || expectClassFlag)) {\n            long hash = h3;\n            for (int i = 3; i < className.length(); ++i) {\n                hash ^= className.charAt(i);\n                hash *= fnv1a_64_magic_prime;\n                if (Arrays.binarySearch(acceptHashCodes, hash) >= 0) {\n                    clazz = TypeUtils.loadClass(typeName, defaultClassLoader, true);\n                    if (clazz != null) {\n                        return clazz;\n                    }\n                }\n                if (Arrays.binarySearch(denyHashCodes, hash) >= 0 && TypeUtils.getClassFromMapping(typeName) == null) {\n                    if (Arrays.binarySearch(acceptHashCodes, fullHash) >= 0) {\n                        continue;\n                    }\n\n                    throw new JSONException(\"autoType is not support. \" + typeName);\n                }\n            }\n        }\n\n        clazz = TypeUtils.getClassFromMapping(typeName);\n\n        if (clazz == null) {\n            clazz = deserializers.findClass(typeName);\n        }\n\n        if (expectClass == null && clazz != null && Throwable.class.isAssignableFrom(clazz) && !autoTypeSupport) {\n            clazz = null;\n        }\n\n        if (clazz == null) {\n            clazz = typeMapping.get(typeName);\n        }\n\n        if (internalWhite) {\n            clazz = TypeUtils.loadClass(typeName, defaultClassLoader, true);\n        }\n\n        if (clazz != null) {\n            if (expectClass != null\n                    && clazz != java.util.HashMap.class\n                    && clazz != java.util.LinkedHashMap.class\n                    && !expectClass.isAssignableFrom(clazz)) {\n                throw new JSONException(\"type not match. \" + typeName + \" -> \" + expectClass.getName());\n            }\n\n            return clazz;\n        }\n\n        if (!autoTypeSupport) {\n            long hash = h3;\n            for (int i = 3; i < className.length(); ++i) {\n                char c = className.charAt(i);\n                hash ^= c;\n                hash *= fnv1a_64_magic_prime;\n\n                if (Arrays.binarySearch(denyHashCodes, hash) >= 0) {\n                    throw new JSONException(\"autoType is not support. \" + typeName);\n                }\n\n                // white list\n                if (Arrays.binarySearch(acceptHashCodes, hash) >= 0) {\n                    clazz = TypeUtils.loadClass(typeName, defaultClassLoader, true);\n\n                    if (clazz == null) {\n                        return expectClass;\n                    }\n\n                    if (expectClass != null && expectClass.isAssignableFrom(clazz)) {\n                        throw new JSONException(\"type not match. \" + typeName + \" -> \" + expectClass.getName());\n                    }\n\n                    return clazz;\n                }\n            }\n        }\n\n        boolean jsonType = false;\n        InputStream is = null;\n        try {\n            String resource = typeName.replace('.', '/') + \".class\";\n            if (defaultClassLoader != null) {\n                is = defaultClassLoader.getResourceAsStream(resource);\n            } else {\n                is = ParserConfig.class.getClassLoader().getResourceAsStream(resource);\n            }\n            if (is != null) {\n                ClassReader classReader = new ClassReader(is, true);\n                TypeCollector visitor = new TypeCollector(\"<clinit>\", new Class[0]);\n                classReader.accept(visitor);\n                jsonType = visitor.hasJsonType();\n            }\n        } catch (Exception e) {\n            // skip\n        } finally {\n            IOUtils.close(is);\n        }\n\n        final int mask = Feature.SupportAutoType.mask;\n        boolean autoTypeSupport = this.autoTypeSupport\n                || (features & mask) != 0\n                || (JSON.DEFAULT_PARSER_FEATURE & mask) != 0;\n\n        if (autoTypeSupport || jsonType || expectClassFlag) {\n            boolean cacheClass = autoTypeSupport || jsonType;\n            clazz = TypeUtils.loadClass(typeName, defaultClassLoader, cacheClass);\n        }\n\n        if (clazz != null) {\n            if (jsonType) {\n                TypeUtils.addMapping(typeName, clazz);\n                return clazz;\n            }\n\n            if (ClassLoader.class.isAssignableFrom(clazz) // classloader is danger\n                    || javax.sql.DataSource.class.isAssignableFrom(clazz) // dataSource can load jdbc driver\n                    || javax.sql.RowSet.class.isAssignableFrom(clazz) //\n                    ) {\n                throw new JSONException(\"autoType is not support. \" + typeName);\n            }\n\n            if (expectClass != null) {\n                if (expectClass.isAssignableFrom(clazz)) {\n                    TypeUtils.addMapping(typeName, clazz);\n                    return clazz;\n                } else {\n                    throw new JSONException(\"type not match. \" + typeName + \" -> \" + expectClass.getName());\n                }\n            }\n\n            JavaBeanInfo beanInfo = JavaBeanInfo.build(clazz, clazz, propertyNamingStrategy);\n            if (beanInfo.creatorConstructor != null && autoTypeSupport) {\n                throw new JSONException(\"autoType is not support. \" + typeName);\n            }\n        }\n\n        if (!autoTypeSupport) {\n            if (typeName.endsWith(\"Exception\")) {\n                return null;\n            }\n\n            throw new JSONException(\"autoType is not support. \" + typeName);\n        }\n\n        if (clazz != null) {\n            TypeUtils.addMapping(typeName, clazz);\n        }\n\n        return clazz;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ParserConfig.java",
        "method_name": "src/main/java/com/alibaba/fastjson/parser/ParserConfig.java#checkAutoType",
        "raw_code": "public Class<?> checkAutoType(String typeName, Class<?> expectClass, int features) {\n        if (typeName == null) {\n            return null;\n        }\n\n        if (autoTypeCheckHandlers != null) {\n            for (AutoTypeCheckHandler h : autoTypeCheckHandlers) {\n                Class<?> type = h.handler(typeName, expectClass, features);\n                if (type != null) {\n                    return type;\n                }\n            }\n        }\n\n        final int safeModeMask = Feature.SafeMode.mask;\n        boolean safeMode = this.safeMode\n                || (features & safeModeMask) != 0\n                || (JSON.DEFAULT_PARSER_FEATURE & safeModeMask) != 0;\n        if (safeMode) {\n            throw new JSONException(\"safeMode not support autoType : \" + typeName);\n        }\n\n        final int mask = Feature.SupportAutoType.mask;\n        boolean autoTypeSupport = this.autoTypeSupport\n                || (features & mask) != 0\n                || (JSON.DEFAULT_PARSER_FEATURE & mask) != 0;\n\n        if (typeName.length() >= 192 || typeName.length() < 3) {\n            throw new JSONException(\"autoType is not support. \" + typeName);\n        }\n\n        final boolean expectClassFlag;\n        if (expectClass == null) {\n            expectClassFlag = false;\n        } else {\n            long expectHash = TypeUtils.fnv1a_64(expectClass.getName());\n            if (expectHash == 0x90a25f5baa21529eL\n                    || expectHash == 0x2d10a5801b9d6136L\n                    || expectHash == 0xaf586a571e302c6bL\n                    || expectHash == 0xed007300a7b227c6L\n                    || expectHash == 0x295c4605fd1eaa95L\n                    || expectHash == 0x47ef269aadc650b4L\n                    || expectHash == 0x6439c4dff712ae8bL\n                    || expectHash == 0xe3dd9875a2dc5283L\n                    || expectHash == 0xe2a8ddba03e69e0dL\n                    || expectHash == 0xd734ceb4c3e9d1daL\n            ) {\n                expectClassFlag = false;\n            } else {\n                expectClassFlag = true;\n            }\n        }\n\n        String className = typeName.replace('$', '.');\n        Class<?> clazz;\n\n        final long h1 = (fnv1a_64_magic_hashcode ^ className.charAt(0)) * fnv1a_64_magic_prime;\n        if (h1 == 0xaf64164c86024f1aL) { // [\n            throw new JSONException(\"autoType is not support. \" + typeName);\n        }\n\n        if ((h1 ^ className.charAt(className.length() - 1)) * fnv1a_64_magic_prime == 0x9198507b5af98f0L) {\n            throw new JSONException(\"autoType is not support. \" + typeName);\n        }\n\n        final long h3 = (((((fnv1a_64_magic_hashcode ^ className.charAt(0))\n                * fnv1a_64_magic_prime)\n                ^ className.charAt(1))\n                * fnv1a_64_magic_prime)\n                ^ className.charAt(2))\n                * fnv1a_64_magic_prime;\n\n        long fullHash = TypeUtils.fnv1a_64(className);\n        boolean internalWhite = Arrays.binarySearch(INTERNAL_WHITELIST_HASHCODES,  fullHash) >= 0;\n\n        if (internalDenyHashCodes != null) {\n            long hash = h3;\n            for (int i = 3; i < className.length(); ++i) {\n                hash ^= className.charAt(i);\n                hash *= fnv1a_64_magic_prime;\n                if (Arrays.binarySearch(internalDenyHashCodes, hash) >= 0) {\n                    throw new JSONException(\"autoType is not support. \" + typeName);\n                }\n            }\n        }\n\n        if ((!internalWhite) && (autoTypeSupport || expectClassFlag)) {\n            long hash = h3;\n            for (int i = 3; i < className.length(); ++i) {\n                hash ^= className.charAt(i);\n                hash *= fnv1a_64_magic_prime;\n                if (Arrays.binarySearch(acceptHashCodes, hash) >= 0) {\n                    clazz = TypeUtils.loadClass(typeName, defaultClassLoader, true);\n                    if (clazz != null) {\n                        return clazz;\n                    }\n                }\n                if (Arrays.binarySearch(denyHashCodes, hash) >= 0 && TypeUtils.getClassFromMapping(typeName) == null) {\n                    if (Arrays.binarySearch(acceptHashCodes, fullHash) >= 0) {\n                        continue;\n                    }\n\n                    throw new JSONException(\"autoType is not support. \" + typeName);\n                }\n            }\n        }\n\n        clazz = TypeUtils.getClassFromMapping(typeName);\n\n        if (clazz == null) {\n            clazz = deserializers.findClass(typeName);\n        }\n\n        if (expectClass == null && clazz != null && Throwable.class.isAssignableFrom(clazz) && !autoTypeSupport) {\n            clazz = null;\n        }\n\n        if (clazz == null) {\n            clazz = typeMapping.get(typeName);\n        }\n\n        if (internalWhite) {\n            clazz = TypeUtils.loadClass(typeName, defaultClassLoader, true);\n        }\n\n        if (clazz != null) {\n            if (expectClass != null\n                    && clazz != java.util.HashMap.class\n                    && clazz != java.util.LinkedHashMap.class\n                    && !expectClass.isAssignableFrom(clazz)) {\n                throw new JSONException(\"type not match. \" + typeName + \" -> \" + expectClass.getName());\n            }\n\n            return clazz;\n        }\n\n        if (!autoTypeSupport) {\n            long hash = h3;\n            for (int i = 3; i < className.length(); ++i) {\n                char c = className.charAt(i);\n                hash ^= c;\n                hash *= fnv1a_64_magic_prime;\n\n                if (Arrays.binarySearch(denyHashCodes, hash) >= 0) {\n                    if (typeName.endsWith(\"Exception\") || typeName.endsWith(\"Error\")) {\n                        return null;\n                    }\n\n                    throw new JSONException(\"autoType is not support. \" + typeName);\n                }\n\n                // white list\n                if (Arrays.binarySearch(acceptHashCodes, hash) >= 0) {\n                    clazz = TypeUtils.loadClass(typeName, defaultClassLoader, true);\n\n                    if (clazz == null) {\n                        return expectClass;\n                    }\n\n                    if (expectClass != null && expectClass.isAssignableFrom(clazz)) {\n                        throw new JSONException(\"type not match. \" + typeName + \" -> \" + expectClass.getName());\n                    }\n\n                    return clazz;\n                }\n            }\n        }\n\n        boolean jsonType = false;\n        InputStream is = null;\n        try {\n            String resource = typeName.replace('.', '/') + \".class\";\n            if (defaultClassLoader != null) {\n                is = defaultClassLoader.getResourceAsStream(resource);\n            } else {\n                is = ParserConfig.class.getClassLoader().getResourceAsStream(resource);\n            }\n            if (is != null) {\n                ClassReader classReader = new ClassReader(is, true);\n                TypeCollector visitor = new TypeCollector(\"<clinit>\", new Class[0]);\n                classReader.accept(visitor);\n                jsonType = visitor.hasJsonType();\n            }\n        } catch (Exception e) {\n            // skip\n        } finally {\n            IOUtils.close(is);\n        }\n\n        if (autoTypeSupport || jsonType || expectClassFlag) {\n            boolean cacheClass = autoTypeSupport || jsonType;\n            clazz = TypeUtils.loadClass(typeName, defaultClassLoader, cacheClass);\n        }\n\n        if (clazz != null) {\n            if (jsonType) {\n                if (autoTypeSupport) {\n                    TypeUtils.addMapping(typeName, clazz);\n                }\n                return clazz;\n            }\n\n            if (ClassLoader.class.isAssignableFrom(clazz) // classloader is danger\n                    || javax.sql.DataSource.class.isAssignableFrom(clazz) // dataSource can load jdbc driver\n                    || javax.sql.RowSet.class.isAssignableFrom(clazz) //\n                    ) {\n                throw new JSONException(\"autoType is not support. \" + typeName);\n            }\n\n            if (expectClass != null) {\n                if (expectClass.isAssignableFrom(clazz)) {\n                    if (autoTypeSupport) {\n                        TypeUtils.addMapping(typeName, clazz);\n                    }\n                    return clazz;\n                } else {\n                    throw new JSONException(\"type not match. \" + typeName + \" -> \" + expectClass.getName());\n                }\n            }\n\n            JavaBeanInfo beanInfo = JavaBeanInfo.build(clazz, clazz, propertyNamingStrategy);\n            if (beanInfo.creatorConstructor != null && autoTypeSupport) {\n                throw new JSONException(\"autoType is not support. \" + typeName);\n            }\n        }\n\n        if (!autoTypeSupport) {\n            if (typeName.endsWith(\"Exception\") || typeName.endsWith(\"Error\")) {\n                return null;\n            }\n\n            throw new JSONException(\"autoType is not support. \" + typeName);\n        }\n\n        if (clazz != null) {\n            if (autoTypeSupport) {\n                TypeUtils.addMapping(typeName, clazz);\n            }\n        }\n\n        return clazz;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "syntax-markdown",
    "cve_id": "CVE-2025-46558",
    "cwe_list": [
      "CWE-79"
    ],
    "commit_hash": "d136472d6e8a47981a0ede420a9096f88ffa5035",
    "short_hash": "d136472d",
    "vulnerableMethods_before": [
      {
        "filename": "AbstractMarkdownConfiguration.java",
        "method_name": "getDefaultOptions",
        "raw_code": "protected MutableDataHolder getDefaultOptions(ParserEmulationProfile parserEmulationProfile,\n        List<Class<?>> additionalExtensionClasses)\n    {\n        // Configure Parser Family\n        MutableDataHolder options = new MutableDataSet();\n        options.setFrom(parserEmulationProfile);\n\n        // Configure extensions\n        List<Extension> extensions = new ArrayList<>();\n        List<Class<?>> resolvedExensionClasses = new ArrayList<>();\n        resolvedExensionClasses.addAll(DEFAULT_EXTENSIONS);\n        resolvedExensionClasses.addAll(additionalExtensionClasses);\n        for (Class<?> extensionClass : resolvedExensionClasses) {\n            try {\n                Method method = extensionClass.getMethod(\"create\");\n                Extension extension = (Extension) method.invoke(null);\n                extensions.add(extension);\n            } catch (Exception e) {\n                // Invalid extension, skip it\n                getLogger().warn(\"Invalid extension: [{}]. Root cause: [{}]\", extensionClass.getName(),\n                    ExceptionUtils.getRootCauseMessage(e));\n            }\n            options.set(Parser.EXTENSIONS, extensions);\n        }\n\n        return options;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AbstractMarkdownConfiguration.java",
        "method_name": "getDefaultOptions",
        "raw_code": "protected MutableDataHolder getDefaultOptions(ParserEmulationProfile parserEmulationProfile,\n        List<Class<?>> additionalExtensionClasses)\n    {\n        // Configure Parser Family\n        MutableDataHolder options = new MutableDataSet();\n        options.setFrom(parserEmulationProfile);\n\n        // Configure extensions\n        List<Extension> extensions = new ArrayList<>();\n        List<Class<?>> resolvedExensionClasses = new ArrayList<>();\n        resolvedExensionClasses.addAll(DEFAULT_EXTENSIONS);\n        resolvedExensionClasses.addAll(additionalExtensionClasses);\n        for (Class<?> extensionClass : resolvedExensionClasses) {\n            try {\n                Method method = extensionClass.getMethod(\"create\");\n                Extension extension = (Extension) method.invoke(null);\n                extensions.add(extension);\n            } catch (Exception e) {\n                // Invalid extension, skip it\n                getLogger().warn(\"Invalid extension: [{}]. Root cause: [{}]\", extensionClass.getName(),\n                    ExceptionUtils.getRootCauseMessage(e));\n            }\n        }\n        options.set(Parser.EXTENSIONS, extensions);\n\n        return options;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "rabbitmq-java-client",
    "cve_id": "CVE-2023-46120",
    "cwe_list": [
      "CWE-400"
    ],
    "commit_hash": "714aae602dcae6cb4b53cadf009323ebac313cc8",
    "short_hash": "714aae60",
    "vulnerableMethods_before": [
      {
        "filename": "CommandAssembler.java",
        "method_name": "src/main/java/com/rabbitmq/client/impl/CommandAssembler.java#consumeHeaderFrame",
        "raw_code": "private void consumeHeaderFrame(Frame f) throws IOException {\n        if (f.type == AMQP.FRAME_HEADER) {\n            this.contentHeader = AMQImpl.readContentHeaderFrom(f.getInputStream());\n            this.remainingBodyBytes = this.contentHeader.getBodySize();\n            updateContentBodyState();\n        } else {\n            throw new UnexpectedFrameError(f, AMQP.FRAME_HEADER);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "CommandAssembler.java",
        "method_name": "src/main/java/com/rabbitmq/client/impl/CommandAssembler.java#consumeHeaderFrame",
        "raw_code": "private void consumeHeaderFrame(Frame f) throws IOException {\n        if (f.type == AMQP.FRAME_HEADER) {\n            this.contentHeader = AMQImpl.readContentHeaderFrom(f.getInputStream());\n            long bodySize = this.contentHeader.getBodySize();\n            if (bodySize >= this.maxBodyLength) {\n                throw new IllegalStateException(format(\n                    \"Message body is too large (%d), maximum size is %d\",\n                    bodySize, this.maxBodyLength\n                ));\n            }\n            this.remainingBodyBytes = bodySize;\n            updateContentBodyState();\n        } else {\n            throw new UnexpectedFrameError(f, AMQP.FRAME_HEADER);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2023-37913",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "45d182a4141ff22f3ff289cf71e4669bdc714544",
    "short_hash": "45d182a4",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultXHTMLOfficeDocumentBuilder.java",
        "method_name": "xwiki-platform-core/xwiki-platform-office/xwiki-platform-office-importer/src/main/java/org/xwiki/officeimporter/internal/builder/DefaultXHTMLOfficeDocumentBuilder.java#handleArtifacts",
        "raw_code": "private Set<File> handleArtifacts(Document xhtmlDoc, OfficeConverterResult officeConverterResult)\n        throws OfficeImporterException\n    {\n        Set<File> artifacts = new HashSet<>(officeConverterResult.getAllFiles());\n        artifacts.remove(officeConverterResult.getOutputFile());\n\n        @SuppressWarnings(\"unchecked\")\n        Map<String, byte[]> embeddedImages = (Map<String, byte[]>) xhtmlDoc.getUserData(\"embeddedImages\");\n        if (embeddedImages != null) {\n            File outputDirectory = officeConverterResult.getOutputDirectory();\n            for (Map.Entry<String, byte[]> embeddedImage : embeddedImages.entrySet()) {\n                File outputFile = new File(outputDirectory, embeddedImage.getKey());\n                try (FileOutputStream fos = new FileOutputStream(outputFile)) {\n                    IOUtils.write(embeddedImage.getValue(), fos);\n                } catch (IOException e) {\n                    throw new OfficeImporterException(\n                        String.format(\"Error when writing embedded image file [%s]\", outputFile.getAbsolutePath()), e);\n                }\n                artifacts.add(outputFile);\n            }\n        }\n        return artifacts;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultXHTMLOfficeDocumentBuilder.java",
        "method_name": "xwiki-platform-core/xwiki-platform-office/xwiki-platform-office-importer/src/main/java/org/xwiki/officeimporter/internal/builder/DefaultXHTMLOfficeDocumentBuilder.java#handleArtifacts",
        "raw_code": "private Map<String, OfficeDocumentArtifact> handleArtifacts(Document xhtmlDoc,\n        OfficeConverterResult officeConverterResult, String replacePrefix, String replacementPrefix)\n    {\n        Map<String, OfficeDocumentArtifact> artifacts = new HashMap<>();\n        for (File file : officeConverterResult.getAllFiles()) {\n            // Rename the file if it starts with the static prefix similar to the image filter.\n            String filename = file.getName();\n            if (StringUtils.startsWith(filename, replacePrefix)) {\n                filename = replacementPrefix + StringUtils.removeStart(filename, replacePrefix);\n            }\n            artifacts.put(filename, new FileOfficeDocumentArtifact(file.getName(), file));\n        }\n        // Remove the output file from the artifacts\n        artifacts.remove(officeConverterResult.getOutputFile().getName());\n\n        @SuppressWarnings(\"unchecked\")\n        Map<String, byte[]> embeddedImages = (Map<String, byte[]>) xhtmlDoc.getUserData(\"embeddedImages\");\n        if (embeddedImages != null) {\n            for (Map.Entry<String, byte[]> embeddedImage : embeddedImages.entrySet()) {\n                String fileName = embeddedImage.getKey();\n                artifacts.put(fileName, new ByteArrayOfficeDocumentArtifact(fileName, embeddedImage.getValue()));\n            }\n        }\n        return artifacts;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "drawio",
    "cve_id": "CVE-2022-1767",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "c63f3a04450f30798df47f9badbc74eb8a69fbdf",
    "short_hash": "c63f3a04",
    "vulnerableMethods_before": [
      {
        "filename": "ProxyServlet.java",
        "method_name": "src/main/java/com/mxgraph/online/ExportProxyServlet.java#doGet",
        "raw_code": "protected void doGet(HttpServletRequest request,\n\t\t\tHttpServletResponse response) throws ServletException, IOException\n\t{\n\t\tString urlParam = request.getParameter(\"url\");\n\n\t\tif (Utils.sanitizeUrl(urlParam))\n\t\t{\n\t\t\t// build the UML source from the compressed request parameter\n\t\t\tString ref = request.getHeader(\"referer\");\n\t\t\tString ua = request.getHeader(\"User-Agent\");\n\t\t\tString auth = request.getHeader(\"Authorization\");\n\t\t\tString dom = getCorsDomain(ref, ua);\n\n\t\t\ttry(OutputStream out = response.getOutputStream())\n\t\t\t{\n\t\t\t\trequest.setCharacterEncoding(\"UTF-8\");\n\t\t\t\tresponse.setCharacterEncoding(\"UTF-8\");\n\n\t\t\t\tURL url = new URL(urlParam);\n\t\t\t\tURLConnection connection = url.openConnection();\n\t\t\t\tconnection.setConnectTimeout(TIMEOUT);\n\t\t\t\tconnection.setReadTimeout(TIMEOUT);\n\t\t\t\t\n\t\t\t\tresponse.setHeader(\"Cache-Control\", \"private, max-age=86400\");\n\n\t\t\t\t// Workaround for 451 response from Iconfinder CDN\n\t\t\t\tconnection.setRequestProperty(\"User-Agent\", \"draw.io\");\n\t\t\t\t\n\t\t\t\t//Forward auth header\n\t\t\t\tif (auth  !=  null)\n\t\t\t\t{\n\t\t\t\t\tconnection.setRequestProperty(\"Authorization\", auth);\n\t\t\t\t}\n\n\t\t\t\tif (dom != null && dom.length() > 0)\n\t\t\t\t{\n\t\t\t\t\tresponse.addHeader(\"Access-Control-Allow-Origin\", dom);\n\t\t\t\t}\n\n\t\t\t\t// Status code pass-through and follow redirects\n\t\t\t\tif (connection instanceof HttpURLConnection)\n\t\t\t\t{\n\t\t\t\t\t((HttpURLConnection) connection)\n\t\t\t\t\t\t\t.setInstanceFollowRedirects(true);\n\t\t\t\t\tint status = ((HttpURLConnection) connection)\n\t\t\t\t\t\t\t.getResponseCode();\n\t\t\t\t\tint counter = 0;\n\n\t\t\t\t\t// Follows a maximum of 6 redirects \n\t\t\t\t\twhile (counter++ <= 6\n\t\t\t\t\t\t\t&& (status == HttpURLConnection.HTTP_MOVED_PERM\n\t\t\t\t\t\t\t\t\t|| status == HttpURLConnection.HTTP_MOVED_TEMP))\n\t\t\t\t\t{\n\t\t\t\t\t\tString redirectUrl = connection.getHeaderField(\"Location\");\n\n\t\t\t\t\t\tif (!Utils.sanitizeUrl(redirectUrl))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\turl = new URL(redirectUrl);\n\t\t\t\t\t\tconnection = url.openConnection();\n\t\t\t\t\t\t((HttpURLConnection) connection)\n\t\t\t\t\t\t\t\t.setInstanceFollowRedirects(true);\n\t\t\t\t\t\tconnection.setConnectTimeout(TIMEOUT);\n\t\t\t\t\t\tconnection.setReadTimeout(TIMEOUT);\n\n\t\t\t\t\t\t// Workaround for 451 response from Iconfinder CDN\n\t\t\t\t\t\tconnection.setRequestProperty(\"User-Agent\", \"draw.io\");\n\t\t\t\t\t\tstatus = ((HttpURLConnection) connection)\n\t\t\t\t\t\t\t\t.getResponseCode();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (status >= 200 && status <= 299)\n\t\t\t\t\t{\n\t\t\t\t\t\tresponse.setStatus(status);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Copies input stream to output stream\n\t\t\t\t\t\tInputStream is = connection.getInputStream();\n\t\t\t\t\t\tbyte[] head = (contentAlwaysAllowed(urlParam)) ? emptyBytes\n\t\t\t\t\t\t\t\t: Utils.checkStreamContent(is);\n\t\t\t\t\t\tresponse.setContentType(\"application/octet-stream\");\n\t\t\t\t\t\tString base64 = request.getParameter(\"base64\");\n\t\t\t\t\t\tcopyResponse(is, out, head,\n\t\t\t\t\t\t\t\tbase64 != null && base64.equals(\"1\"));\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tresponse.setStatus(HttpURLConnection.HTTP_PRECON_FAILED);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tresponse.setStatus(HttpURLConnection.HTTP_UNSUPPORTED_TYPE);\n\t\t\t\t}\n\n\t\t\t\tout.flush();\n\n\t\t\t\tlog.log(Level.FINEST, \"processed proxy request: url=\"\n\t\t\t\t\t\t+ ((urlParam != null) ? urlParam : \"[null]\")\n\t\t\t\t\t\t+ \", referer=\" + ((ref != null) ? ref : \"[null]\")\n\t\t\t\t\t\t+ \", user agent=\" + ((ua != null) ? ua : \"[null]\"));\n\t\t\t}\n\t\t\tcatch (DeadlineExceededException e)\n\t\t\t{\n\t\t\t\tresponse.setStatus(HttpServletResponse.SC_REQUEST_TIMEOUT);\n\t\t\t}\n\t\t\tcatch (UnknownHostException | FileNotFoundException e)\n\t\t\t{\n\t\t\t\t// do not log 404 and DNS errors\n\t\t\t\tresponse.setStatus(HttpServletResponse.SC_NOT_FOUND);\n\t\t\t}\n\t\t\tcatch (UnsupportedContentException e)\n\t\t\t{\n\t\t\t\tresponse.setStatus(HttpServletResponse.SC_FORBIDDEN);\n\t\t\t\tlog.log(Level.SEVERE, \"proxy request with invalid content: url=\"\n\t\t\t\t\t\t+ ((urlParam != null) ? urlParam : \"[null]\")\n\t\t\t\t\t\t+ \", referer=\" + ((ref != null) ? ref : \"[null]\")\n\t\t\t\t\t\t+ \", user agent=\" + ((ua != null) ? ua : \"[null]\"));\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tresponse.setStatus(\n\t\t\t\t\t\tHttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n\t\t\t\tlog.log(Level.FINE, \"proxy request failed: url=\"\n\t\t\t\t\t\t+ ((urlParam != null) ? urlParam : \"[null]\")\n\t\t\t\t\t\t+ \", referer=\" + ((ref != null) ? ref : \"[null]\")\n\t\t\t\t\t\t+ \", user agent=\" + ((ua != null) ? ua : \"[null]\"));\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresponse.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n\t\t\tlog.log(Level.SEVERE,\n\t\t\t\t\t\"proxy request with invalid URL parameter: url=\"\n\t\t\t\t\t\t\t+ ((urlParam != null) ? urlParam : \"[null]\"));\n\t\t}\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ProxyServlet.java",
        "method_name": "src/main/java/com/mxgraph/online/ExportProxyServlet.java#doGet",
        "raw_code": "protected void doGet(HttpServletRequest request,\n\t\t\tHttpServletResponse response) throws ServletException, IOException\n\t{\n\t\tString urlParam = request.getParameter(\"url\");\n\n\t\tif (Utils.sanitizeUrl(urlParam))\n\t\t{\n\t\t\t// build the UML source from the compressed request parameter\n\t\t\tString ref = request.getHeader(\"referer\");\n\t\t\tString ua = request.getHeader(\"User-Agent\");\n\t\t\tString auth = request.getHeader(\"Authorization\");\n\t\t\tString dom = getCorsDomain(ref, ua);\n\n\t\t\ttry(OutputStream out = response.getOutputStream())\n\t\t\t{\n\t\t\t\trequest.setCharacterEncoding(\"UTF-8\");\n\t\t\t\tresponse.setCharacterEncoding(\"UTF-8\");\n\n\t\t\t\tURL url = new URL(urlParam);\n\t\t\t\tURLConnection connection = url.openConnection();\n\t\t\t\tconnection.setConnectTimeout(TIMEOUT);\n\t\t\t\tconnection.setReadTimeout(TIMEOUT);\n\t\t\t\t\n\t\t\t\tresponse.setHeader(\"Cache-Control\", \"private, max-age=86400\");\n\n\t\t\t\t// Workaround for 451 response from Iconfinder CDN\n\t\t\t\tconnection.setRequestProperty(\"User-Agent\", \"draw.io\");\n\t\t\t\t\n\t\t\t\t//Forward auth header\n\t\t\t\tif (auth  !=  null)\n\t\t\t\t{\n\t\t\t\t\tconnection.setRequestProperty(\"Authorization\", auth);\n\t\t\t\t}\n\n\t\t\t\tif (dom != null && dom.length() > 0)\n\t\t\t\t{\n\t\t\t\t\tresponse.addHeader(\"Access-Control-Allow-Origin\", dom);\n\t\t\t\t}\n\n\t\t\t\t// Status code pass-through and follow redirects\n\t\t\t\tif (connection instanceof HttpURLConnection)\n\t\t\t\t{\n\t\t\t\t\t((HttpURLConnection) connection)\n\t\t\t\t\t\t\t.setInstanceFollowRedirects(false);\n\t\t\t\t\tint status = ((HttpURLConnection) connection)\n\t\t\t\t\t\t\t.getResponseCode();\n\t\t\t\t\tint counter = 0;\n\n\t\t\t\t\t// Follows a maximum of 6 redirects \n\t\t\t\t\twhile (counter++ <= 6 && (int)(status / 10) == 30) //Any redirect status 30x\n\t\t\t\t\t{\n\t\t\t\t\t\tString redirectUrl = connection.getHeaderField(\"Location\");\n\n\t\t\t\t\t\tif (!Utils.sanitizeUrl(redirectUrl))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\turl = new URL(redirectUrl);\n\t\t\t\t\t\tconnection = url.openConnection();\n\t\t\t\t\t\t((HttpURLConnection) connection)\n\t\t\t\t\t\t\t\t.setInstanceFollowRedirects(false);\n\t\t\t\t\t\tconnection.setConnectTimeout(TIMEOUT);\n\t\t\t\t\t\tconnection.setReadTimeout(TIMEOUT);\n\n\t\t\t\t\t\t// Workaround for 451 response from Iconfinder CDN\n\t\t\t\t\t\tconnection.setRequestProperty(\"User-Agent\", \"draw.io\");\n\t\t\t\t\t\tstatus = ((HttpURLConnection) connection)\n\t\t\t\t\t\t\t\t.getResponseCode();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (status >= 200 && status <= 299)\n\t\t\t\t\t{\n\t\t\t\t\t\tresponse.setStatus(status);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Copies input stream to output stream\n\t\t\t\t\t\tInputStream is = connection.getInputStream();\n\t\t\t\t\t\tbyte[] head = (contentAlwaysAllowed(urlParam)) ? emptyBytes\n\t\t\t\t\t\t\t\t: Utils.checkStreamContent(is);\n\t\t\t\t\t\tresponse.setContentType(\"application/octet-stream\");\n\t\t\t\t\t\tString base64 = request.getParameter(\"base64\");\n\t\t\t\t\t\tcopyResponse(is, out, head,\n\t\t\t\t\t\t\t\tbase64 != null && base64.equals(\"1\"));\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tresponse.setStatus(HttpURLConnection.HTTP_PRECON_FAILED);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tresponse.setStatus(HttpURLConnection.HTTP_UNSUPPORTED_TYPE);\n\t\t\t\t}\n\n\t\t\t\tout.flush();\n\n\t\t\t\tlog.log(Level.FINEST, \"processed proxy request: url=\"\n\t\t\t\t\t\t+ ((urlParam != null) ? urlParam : \"[null]\")\n\t\t\t\t\t\t+ \", referer=\" + ((ref != null) ? ref : \"[null]\")\n\t\t\t\t\t\t+ \", user agent=\" + ((ua != null) ? ua : \"[null]\"));\n\t\t\t}\n\t\t\tcatch (DeadlineExceededException e)\n\t\t\t{\n\t\t\t\tresponse.setStatus(HttpServletResponse.SC_REQUEST_TIMEOUT);\n\t\t\t}\n\t\t\tcatch (UnknownHostException | FileNotFoundException e)\n\t\t\t{\n\t\t\t\t// do not log 404 and DNS errors\n\t\t\t\tresponse.setStatus(HttpServletResponse.SC_NOT_FOUND);\n\t\t\t}\n\t\t\tcatch (UnsupportedContentException e)\n\t\t\t{\n\t\t\t\tresponse.setStatus(HttpServletResponse.SC_FORBIDDEN);\n\t\t\t\tlog.log(Level.SEVERE, \"proxy request with invalid content: url=\"\n\t\t\t\t\t\t+ ((urlParam != null) ? urlParam : \"[null]\")\n\t\t\t\t\t\t+ \", referer=\" + ((ref != null) ? ref : \"[null]\")\n\t\t\t\t\t\t+ \", user agent=\" + ((ua != null) ? ua : \"[null]\"));\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tresponse.setStatus(\n\t\t\t\t\t\tHttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n\t\t\t\tlog.log(Level.FINE, \"proxy request failed: url=\"\n\t\t\t\t\t\t+ ((urlParam != null) ? urlParam : \"[null]\")\n\t\t\t\t\t\t+ \", referer=\" + ((ref != null) ? ref : \"[null]\")\n\t\t\t\t\t\t+ \", user agent=\" + ((ua != null) ? ua : \"[null]\"));\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresponse.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n\t\t\tlog.log(Level.SEVERE,\n\t\t\t\t\t\"proxy request with invalid URL parameter: url=\"\n\t\t\t\t\t\t\t+ ((urlParam != null) ? urlParam : \"[null]\"));\n\t\t}\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "jmix",
    "cve_id": "CVE-2025-32950",
    "cwe_list": [
      "CWE-35"
    ],
    "commit_hash": "cc97e6ff974b9e7af8160fab39cc5866169daa37",
    "short_hash": "cc97e6ff",
    "vulnerableMethods_before": [
      {
        "filename": "FileDownloadController.java",
        "method_name": "downloadFile",
        "raw_code": "@GetMapping\n    public void downloadFile(@RequestParam String fileRef,\n                             @RequestParam(required = false) Boolean attachment,\n                             HttpServletResponse response) {\n\n        checkFileDownloadPermission();\n        try {\n            FileRef fileReference;\n            fileReference = FileRef.fromString(fileRef);\n            fileTransferService.downloadAndWriteResponse(fileReference, fileReference.getStorageName(), attachment, response);\n        } catch (IllegalArgumentException e) {\n            throw new RestAPIException(\"Invalid file reference\",\n                    String.format(\"Cannot convert '%s' into valid file reference\", fileRef),\n                    HttpStatus.BAD_REQUEST,\n                    e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FileDownloadController.java",
        "method_name": "downloadFile",
        "raw_code": "@GetMapping\n    public void downloadFile(@RequestParam String fileRef,\n                             @RequestParam(required = false) Boolean attachment,\n                             HttpServletResponse response) {\n\n        checkFileDownloadPermission();\n        try {\n            FileRef fileReference;\n            fileReference = FileRef.fromString(fileRef);\n            attachment = resolveAttachmentValue(attachment, fileReference);\n            fileTransferService.downloadAndWriteResponse(fileReference, fileReference.getStorageName(), attachment, response);\n        } catch (IllegalArgumentException e) {\n            throw new RestAPIException(\"Invalid file reference\",\n                    String.format(\"Cannot convert '%s' into valid file reference\", fileRef),\n                    HttpStatus.BAD_REQUEST,\n                    e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "dhis2-core",
    "cve_id": "CVE-2022-24848",
    "cwe_list": [
      "CWE-89"
    ],
    "commit_hash": "ef04483a9b177d62e48dcf4e498b302a11f95e7d",
    "short_hash": "ef04483a",
    "vulnerableMethods_before": [],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultProgramService.java",
        "method_name": "dhis-2/dhis-services/dhis-service-core/src/main/java/org/hisp/dhis/program/DefaultProgramService.java#getProgramOrganisationUnitsAssociationsForCurrentUser",
        "raw_code": "@Override\n    public SetValuedMap<String, String> getProgramOrganisationUnitsAssociationsForCurrentUser( Set<String> programUids )\n    {\n        idObjectManager.getAndValidateByUid( Program.class, programUids );\n\n        return jdbcOrgUnitAssociationsStore.getOrganisationUnitsAssociationsForCurrentUser( programUids );\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2023-29208",
    "cwe_list": [
      "CWE-668"
    ],
    "commit_hash": "d9e947559077e947315bf700c5703dfc7dd8a8d7",
    "short_hash": "d9e94755",
    "vulnerableMethods_before": [
      {
        "filename": "DeletedDocument.java",
        "method_name": "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/api/DeletedDocument.java#canUndelete",
        "raw_code": "public boolean canUndelete()\n    {\n        try {\n            return hasAccessLevel(ADMIN_RIGHT, getFullName()) || hasAccessLevel(\"undelete\", getFullName())\n                || (Objects.equals(this.context.getUserReference(), getDeleterReference())\n                    && hasAccess(Right.EDIT, getDocumentReference()));\n        } catch (XWikiException ex) {\n            // Public APIs should not throw exceptions\n            LOGGER.warn(\"Exception while checking if entry [{}] can be restored from the recycle bin\", getId(), ex);\n            return false;\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DeletedDocument.java",
        "method_name": "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/api/DeletedDocument.java#canUndelete",
        "raw_code": "public boolean canUndelete()\n    {\n        return hasAccess(Right.EDIT);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "bc-java",
    "cve_id": "CVE-2016-1000339",
    "cwe_list": [
      "CWE-310"
    ],
    "commit_hash": "413b42f4d770456508585c830cfcde95f9b0e93b#diff-54656f860db94b867ba7542430cd2ef0",
    "short_hash": "413b42f4",
    "vulnerableMethods_before": [],
    "vulnerableMethods_after": [
      {
        "filename": "KeyFactorySpi.java",
        "method_name": "engineGeneratePublic",
        "raw_code": "protected PublicKey engineGeneratePublic(\n        KeySpec keySpec)\n        throws InvalidKeySpecException\n    {\n        if (keySpec instanceof DHPublicKeySpec)\n        {\n            try\n            {\n                return new BCDHPublicKey((DHPublicKeySpec)keySpec);\n            }\n            catch (IllegalArgumentException e)\n            {\n                throw new InvalidKeySpecException(e.getMessage(), e);\n            }\n        }\n\n        return super.engineGeneratePublic(keySpec);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "cxf",
    "cve_id": "CVE-2018-8039",
    "cwe_list": [
      "CWE-755"
    ],
    "commit_hash": "fae6fabf9bd7647f5e9cb68897a7d72b545b741b",
    "short_hash": "fae6fabf",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultHostnameVerifier.java",
        "method_name": "rt/transports/http/src/main/java/org/apache/cxf/transport/https/httpclient/DefaultHostnameVerifier.java#verify",
        "raw_code": "@Override\n    public boolean verify(final String host, final SSLSession session) {\n        try {\n            final Certificate[] certs = session.getPeerCertificates();\n            final X509Certificate x509 = (X509Certificate) certs[0];\n            verify(host, x509);\n            return true;\n        } catch (final SSLException ex) {\n            if (LOG.isLoggable(Level.FINE)) {\n                LOG.log(Level.FINE, ex.getMessage(), ex);\n            }\n            return false;\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultHostnameVerifier.java",
        "method_name": "rt/transports/http/src/main/java/org/apache/cxf/transport/https/httpclient/DefaultHostnameVerifier.java#verify",
        "raw_code": "public boolean verify(final String host, final String certHostname) {\n        try {\n            matchCN(host, certHostname, this.publicSuffixMatcher);\n            return true;\n        } catch (SSLException ex) {\n            if (LOG.isLoggable(Level.FINE)) {\n                LOG.log(Level.FINE, ex.getMessage(), ex);\n            }\n            return false;\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "hibernate-validator",
    "cve_id": "CVE-2025-35036",
    "cwe_list": [
      "CWE-94"
    ],
    "commit_hash": "05f795bb7cf18856004f40e5042709e550ed0d6e",
    "short_hash": "05f795bb",
    "vulnerableMethods_before": [
      {
        "filename": "HibernateConstraintViolationBuilder.java",
        "method_name": "enableExpressionLanguage",
        "raw_code": "@Incubating\n\tHibernateConstraintViolationBuilder enableExpressionLanguage();",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "HibernateConstraintViolationBuilder.java",
        "method_name": "enableExpressionLanguage",
        "raw_code": "@Incubating\n\tHibernateConstraintViolationBuilder enableExpressionLanguage(ExpressionLanguageFeatureLevel level);",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "shopizer",
    "cve_id": "CVE-2022-23061",
    "cwe_list": [
      "CWE-639"
    ],
    "commit_hash": "6b9f1ecd303b3b724d96bd08095c1a751dcc287e",
    "short_hash": "6b9f1ecd",
    "vulnerableMethods_before": [],
    "vulnerableMethods_after": [
      {
        "filename": "ProductPriceUtils.java",
        "method_name": "sm-core/src/main/java/com/salesmanager/core/business/utils/ProductPriceUtils.java#getFinalPrice",
        "raw_code": "public FinalPrice getFinalPrice(Product product) {\n\n\n\n\t\tFinalPrice finalPrice = calculateFinalPrice(product);\n\t\t\n\t\t//attributes\n\t\tBigDecimal attributePrice = null;\n\t\tif(product.getAttributes()!=null && product.getAttributes().size()>0) {\n\t\t\tfor(ProductAttribute attribute : product.getAttributes()) {\n\t\t\t\t\tif(attribute.getAttributeDefault()) {\n\t\t\t\t\t\tif(attribute.getProductAttributePrice()!=null && attribute.getProductAttributePrice().doubleValue()>0) {\n\t\t\t\t\t\t\tif(attributePrice==null) {\n\t\t\t\t\t\t\t\tattributePrice = new BigDecimal(0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tattributePrice = attributePrice.add(attribute.getProductAttributePrice());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(attributePrice!=null && attributePrice.doubleValue()>0) {\n\t\t\t\tBigDecimal fp = finalPrice.getFinalPrice();\n\t\t\t\tfp = fp.add(attributePrice);\n\t\t\t\tfinalPrice.setFinalPrice(fp);\n\t\t\t\t\n\t\t\t\tBigDecimal op = finalPrice.getOriginalPrice();\n\t\t\t\top = op.add(attributePrice);\n\t\t\t\tfinalPrice.setOriginalPrice(op);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfinalPrice.setStringPrice(this.getStringAmount(finalPrice.getFinalPrice()));\n\n\t\treturn finalPrice;\n\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49584",
    "cwe_list": [
      "CWE-201"
    ],
    "commit_hash": "ee642f973a7c95d2d146fe03c81bcdee1871f4ec",
    "short_hash": "ee642f97",
    "vulnerableMethods_before": [
      {
        "filename": "GroupsClassPropertyValuesProvider.java",
        "method_name": "getIcon",
        "raw_code": "@Override\n    protected Map<String, Object> getIcon(DocumentReference groupReference)\n    {\n        Map<String, Object> icon = new HashMap<>();\n        XWikiContext xcontext = this.xcontextProvider.get();\n        try {\n            XWikiDocument groupProfileDocument = xcontext.getWiki().getDocument(groupReference, xcontext);\n            XWikiAttachment avatarAttachment = getFirstImageAttachment(groupProfileDocument, xcontext);\n            if (avatarAttachment != null) {\n                icon.put(IconManager.META_DATA_URL, xcontext.getWiki().getURL(avatarAttachment.getReference(),\n                    \"download\", \"width=30&height=30&keepAspectRatio=true\", null, xcontext));\n                icon.put(IconManager.META_DATA_ICON_SET_TYPE, IconType.IMAGE.name());\n            }\n        } catch (XWikiException e) {\n            this.logger.warn(\n                \"Failed to read the avatar of group [{}]. Root cause is [{}]. Using the default avatar instead.\",\n                groupReference.getName(), ExceptionUtils.getRootCauseMessage(e));\n        }\n        if (!icon.containsKey(IconManager.META_DATA_URL)) {\n            try {\n                icon = this.iconManager.getMetaData(DEFAULT_ICON_NAME);\n            } catch (IconException e) {\n                this.logger.warn(\"Error getting the icon [{}]. Root cause is [{}].\", DEFAULT_ICON_NAME,\n                    ExceptionUtils.getRootCause(e));\n            }\n        }\n\n        return icon;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "GroupsClassPropertyValuesProvider.java",
        "method_name": "getIcon",
        "raw_code": "@Override\n    protected Map<String, Object> getIcon(DocumentReference groupReference)\n    {\n        Map<String, Object> icon = new HashMap<>();\n        XWikiContext xcontext = this.xcontextProvider.get();\n        if (this.contextualAuthorizationManager.hasAccess(Right.VIEW, groupReference)) {\n            try {\n                XWikiDocument groupProfileDocument = xcontext.getWiki().getDocument(groupReference, xcontext);\n                XWikiAttachment avatarAttachment = getFirstImageAttachment(groupProfileDocument, xcontext);\n                if (avatarAttachment != null) {\n                    icon.put(IconManager.META_DATA_URL, xcontext.getWiki().getURL(avatarAttachment.getReference(),\n                        \"download\", \"width=30&height=30&keepAspectRatio=true\", null, xcontext));\n                    icon.put(IconManager.META_DATA_ICON_SET_TYPE, IconType.IMAGE.name());\n                }\n            } catch (XWikiException e) {\n                this.logger.warn(\n                    \"Failed to read the avatar of group [{}]. Root cause is [{}]. Using the default avatar instead.\",\n                    groupReference.getName(), ExceptionUtils.getRootCauseMessage(e));\n            }\n        }\n\n        if (!icon.containsKey(IconManager.META_DATA_URL)) {\n            try {\n                icon = this.iconManager.getMetaData(DEFAULT_ICON_NAME);\n            } catch (IconException e) {\n                this.logger.warn(\"Error getting the icon [{}]. Root cause is [{}].\", DEFAULT_ICON_NAME,\n                    ExceptionUtils.getRootCause(e));\n            }\n        }\n\n        return icon;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "hibernate-validator",
    "cve_id": "CVE-2025-35036",
    "cwe_list": [
      "CWE-94"
    ],
    "commit_hash": "d2db40b9e7d22c7a0b44d7665242dfc7b4d14d78",
    "short_hash": "d2db40b9",
    "vulnerableMethods_before": [
      {
        "filename": "AbstractMessageInterpolator.java",
        "method_name": "interpolateMessage",
        "raw_code": "private String interpolateMessage(String message, Context context, Locale locale) throws MessageDescriptorFormatException {\n\t\t// if the message does not contain any message parameter, we can ignore the next steps and just return\n\t\t// the unescaped message. It avoids storing the message in the cache and a cache lookup.\n\t\tif ( message.indexOf( '{' ) < 0 ) {\n\t\t\treturn replaceEscapedLiterals( message );\n\t\t}\n\n\t\tString resolvedMessage = null;\n\n\t\t// either retrieve message from cache, or if message is not yet there or caching is disabled,\n\t\t// perform message resolution algorithm (step 1)\n\t\tif ( cachingEnabled ) {\n\t\t\tresolvedMessage = resolvedMessages.computeIfAbsent( new LocalizedMessage( message, locale ), lm -> resolveMessage( message, locale ) );\n\t\t}\n\t\telse {\n\t\t\tresolvedMessage = resolveMessage( message, locale );\n\t\t}\n\n\t\t// there's no need for steps 2-3 unless there's `{param}`/`${expr}` in the message\n\t\tif ( resolvedMessage.indexOf( '{' ) > -1 ) {\n\t\t\t// resolve parameter expressions (step 2)\n\t\t\tresolvedMessage = interpolateExpression(\n\t\t\t\t\tnew TokenIterator( getParameterTokens( resolvedMessage, tokenizedParameterMessages, InterpolationTermType.PARAMETER ) ),\n\t\t\t\t\tcontext,\n\t\t\t\t\tlocale\n\t\t\t);\n\n\t\t\t// resolve EL expressions (step 3)\n\t\t\t// in the standard Hibernate Validator execution flow, the context is always an instance of\n\t\t\t// HibernateMessageInterpolatorContext\n\t\t\t// but it can be a spec Context in the Jakarta Bean Validation TCK.\n\t\t\tif ( !( context instanceof HibernateMessageInterpolatorContext )\n\t\t\t\t\t|| ( (HibernateMessageInterpolatorContext) context ).isExpressionLanguageEnabled() ) {\n\t\t\t\tresolvedMessage = interpolateExpression(\n\t\t\t\t\t\tnew TokenIterator( getParameterTokens( resolvedMessage, tokenizedELMessages, InterpolationTermType.EL ) ),\n\t\t\t\t\t\tcontext,\n\t\t\t\t\t\tlocale );\n\t\t\t}\n\t\t}\n\n\t\t// last but not least we have to take care of escaped literals\n\t\tresolvedMessage = replaceEscapedLiterals( resolvedMessage );\n\n\t\treturn resolvedMessage;\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AbstractMessageInterpolator.java",
        "method_name": "interpolateMessage",
        "raw_code": "private String interpolateMessage(String message, Context context, Locale locale) throws MessageDescriptorFormatException {\n\t\t// if the message does not contain any message parameter, we can ignore the next steps and just return\n\t\t// the unescaped message. It avoids storing the message in the cache and a cache lookup.\n\t\tif ( message.indexOf( '{' ) < 0 ) {\n\t\t\treturn replaceEscapedLiterals( message );\n\t\t}\n\n\t\tString resolvedMessage = null;\n\n\t\t// either retrieve message from cache, or if message is not yet there or caching is disabled,\n\t\t// perform message resolution algorithm (step 1)\n\t\tif ( cachingEnabled ) {\n\t\t\tresolvedMessage = resolvedMessages.computeIfAbsent( new LocalizedMessage( message, locale ), lm -> resolveMessage( message, locale ) );\n\t\t}\n\t\telse {\n\t\t\tresolvedMessage = resolveMessage( message, locale );\n\t\t}\n\n\t\t// there's no need for steps 2-3 unless there's `{param}`/`${expr}` in the message\n\t\tif ( resolvedMessage.indexOf( '{' ) > -1 ) {\n\t\t\t// resolve parameter expressions (step 2)\n\t\t\tresolvedMessage = interpolateExpression(\n\t\t\t\t\tnew TokenIterator( getParameterTokens( resolvedMessage, tokenizedParameterMessages, InterpolationTermType.PARAMETER ) ),\n\t\t\t\t\tcontext,\n\t\t\t\t\tlocale\n\t\t\t);\n\n\t\t\t// resolve EL expressions (step 3)\n\t\t\t// in the standard Hibernate Validator execution flow, the context is always an instance of\n\t\t\t// HibernateMessageInterpolatorContext\n\t\t\t// but it can be a spec Context in the Jakarta Bean Validation TCK.\n\t\t\tif ( !( context instanceof HibernateMessageInterpolatorContext )\n\t\t\t\t\t|| ( (HibernateMessageInterpolatorContext) context ).getExpressionLanguageFeatureLevel() != ExpressionLanguageFeatureLevel.NONE ) {\n\t\t\t\tresolvedMessage = interpolateExpression(\n\t\t\t\t\t\tnew TokenIterator( getParameterTokens( resolvedMessage, tokenizedELMessages, InterpolationTermType.EL ) ),\n\t\t\t\t\t\tcontext,\n\t\t\t\t\t\tlocale );\n\t\t\t}\n\t\t}\n\n\t\t// last but not least we have to take care of escaped literals\n\t\tresolvedMessage = replaceEscapedLiterals( resolvedMessage );\n\n\t\treturn resolvedMessage;\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "hertzbeat",
    "cve_id": "CVE-2023-51388",
    "cwe_list": [
      "CWE-74"
    ],
    "commit_hash": "8dcf050e27ca95d15460a7ba98a3df8a9cd1d3d2",
    "short_hash": "8dcf050e",
    "vulnerableMethods_before": [
      {
        "filename": "AviatorConfiguration.java",
        "method_name": "configAviatorEvaluator",
        "raw_code": "@Bean\n    public void configAviatorEvaluator() {\n        // AviatorEvaluatorLRU\n        AviatorEvaluator.getInstance()\n                .useLRUExpressionCache(AVIATOR_LRU_CACHE_SIZE)\n                .addFunction(new StrEqualFunction());\n\n        // aviator\n        AviatorEvaluator.getInstance().addOpFunction(OperatorType.BIT_OR, new AbstractFunction() {\n            @Override\n            public AviatorObject call(final Map<String, Object> env, final AviatorObject arg1,\n                                      final AviatorObject arg2) {\n                try {\n                    Object value1 = arg1.getValue(env);\n                    Object value2 = arg2.getValue(env);\n                    Object currentValue = value1 == null ? value2 : value1;\n                    if (arg1.getAviatorType() == AviatorType.String) {\n                        return new AviatorString(String.valueOf(currentValue));\n                    } else {\n                        return AviatorDouble.valueOf(currentValue);\n                    }\n                } catch (Exception e) {\n                    log.error(e.getMessage());\n                }\n                return arg1.bitOr(arg2, env);\n            }\n            @Override\n            public String getName() {\n                return OperatorType.BIT_OR.getToken();\n            }\n        });\n\n        AviatorEvaluator.getInstance().addFunction(new StrContainsFunction());\n        AviatorEvaluator.getInstance().addFunction(new ObjectExistsFunction());\n        AviatorEvaluator.getInstance().addFunction(new StrMatchesFunction());\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AviatorConfiguration.java",
        "method_name": "configAviatorEvaluator",
        "raw_code": "@Bean\n    public void configAviatorEvaluator() {\n        AviatorEvaluatorInstance instance = AviatorEvaluator.getInstance();\n\n        // AviatorEvaluatorLRU\n        instance\n                .useLRUExpressionCache(AVIATOR_LRU_CACHE_SIZE)\n                .addFunction(new StrEqualFunction());\n\n        // Aviator\n        instance.setOption(Options.FEATURE_SET,\n                Feature.asSet(Feature.If,\n                        Feature.Assignment,\n                        Feature.Let,\n                        Feature.StringInterpolation));\n\n        // aviator\n        instance.addOpFunction(OperatorType.BIT_OR, new AbstractFunction() {\n            @Override\n            public AviatorObject call(final Map<String, Object> env, final AviatorObject arg1,\n                                      final AviatorObject arg2) {\n                try {\n                    Object value1 = arg1.getValue(env);\n                    Object value2 = arg2.getValue(env);\n                    Object currentValue = value1 == null ? value2 : value1;\n                    if (arg1.getAviatorType() == AviatorType.String) {\n                        return new AviatorString(String.valueOf(currentValue));\n                    } else {\n                        return AviatorDouble.valueOf(currentValue);\n                    }\n                } catch (Exception e) {\n                    log.error(e.getMessage());\n                }\n                return arg1.bitOr(arg2, env);\n            }\n            @Override\n            public String getName() {\n                return OperatorType.BIT_OR.getToken();\n            }\n        });\n\n        instance.addFunction(new StrContainsFunction());\n        instance.addFunction(new ObjectExistsFunction());\n        instance.addFunction(new StrMatchesFunction());\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "jenkins",
    "cve_id": "CVE-2017-2600",
    "cwe_list": [
      "CWE-200"
    ],
    "commit_hash": "0f92cd08a19207de2cceb6a2f4e3e9f92fdc0899",
    "short_hash": "0f92cd08",
    "vulnerableMethods_before": [
      {
        "filename": "Computer.java",
        "method_name": "core/src/main/java/hudson/model/Computer.java#getMonitorData",
        "raw_code": "@Exported(inline=true)\n    public Map<String/*monitor name*/,Object> getMonitorData() {\n        Map<String,Object> r = new HashMap<String, Object>();\n        for (NodeMonitor monitor : NodeMonitor.getAll())\n            r.put(monitor.getClass().getName(),monitor.data(this));\n        return r;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "Computer.java",
        "method_name": "core/src/main/java/hudson/model/Computer.java#getMonitorData",
        "raw_code": "@Exported(inline=true)\n    public Map<String/*monitor name*/,Object> getMonitorData() {\n        Map<String,Object> r = new HashMap<String, Object>();\n        if (hasPermission(CONNECT)) {\n            for (NodeMonitor monitor : NodeMonitor.getAll())\n                r.put(monitor.getClass().getName(), monitor.data(this));\n        }\n        return r;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "californium",
    "cve_id": "CVE-2022-39368",
    "cwe_list": [
      "CWE-459"
    ],
    "commit_hash": "726bac57659410da463dcf404b3e79a7312ac0b9",
    "short_hash": "726bac57",
    "vulnerableMethods_before": [
      {
        "filename": "DTLSConnector.java",
        "method_name": "scandium-core/src/main/java/org/eclipse/californium/scandium/DTLSConnector.java#stop",
        "raw_code": "@Override\n\tpublic void stop() {\n\t\tExecutorService shutdownTimer = null;\n\t\tExecutorService shutdown = null;\n\t\tList<Runnable> pending = new ArrayList<>();\n\t\tboolean stop;\n\t\tsynchronized (this) {\n\t\t\tstop = running.compareAndSet(true, false);\n\t\t\tif (stop) {\n\t\t\t\tLOGGER.debug(\"DTLS connector on [{}] stopping ...\", lastBindAddress);\n\t\t\t\tif (statusLogger != null) {\n\t\t\t\t\tstatusLogger.cancel(false);\n\t\t\t\t\tstatusLogger = null;\n\t\t\t\t}\n\t\t\t\tif (recentHandshakeCleaner != null) {\n\t\t\t\t\trecentHandshakeCleaner.cancel(false);\n\t\t\t\t\trecentHandshakeCleaner = null;\n\t\t\t\t}\n\t\t\t\t// recent handshakes will be restored from connection store,\n\t\t\t\tclearRecentHandshakes();\n\t\t\t\tfor (Thread t : receiverThreads) {\n\t\t\t\t\tt.interrupt();\n\t\t\t\t}\n\t\t\t\tif (socket != null) {\n\t\t\t\t\tsocket.close();\n\t\t\t\t\tsocket = null;\n\t\t\t\t}\n\t\t\t\tmaximumTransmissionUnit = null;\n\t\t\t\tipv4Mtu = DEFAULT_IPV4_MTU;\n\t\t\t\tipv6Mtu = DEFAULT_IPV6_MTU;\n\t\t\t\tconnectionStore.stop(pending);\n\t\t\t\tif (executorService != timer) {\n\t\t\t\t\tpending.addAll(timer.shutdownNow());\n\t\t\t\t\tshutdownTimer = timer;\n\t\t\t\t\ttimer = null;\n\t\t\t\t}\n\t\t\t\tif (hasInternalExecutor) {\n\t\t\t\t\tpending.addAll(executorService.shutdownNow());\n\t\t\t\t\tshutdown = executorService;\n\t\t\t\t\texecutorService = null;\n\t\t\t\t\thasInternalExecutor = false;\n\t\t\t\t\tif (connectionStore instanceof ReadWriteLockConnectionStore) {\n\t\t\t\t\t\t((ReadWriteLockConnectionStore)connectionStore).setExecutor(null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (Thread t : receiverThreads) {\n\t\t\t\t\tt.interrupt();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tt.join(500);\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treceiverThreads.clear();\n\t\t\t}\n\t\t}\n\t\tif (shutdownTimer != null) {\n\t\t\ttry {\n\t\t\t\tif (!shutdownTimer.awaitTermination(500, TimeUnit.MILLISECONDS)) {\n\t\t\t\t\tLOGGER.warn(\"Shutdown DTLS connector on [{}] timer not terminated in time!\", lastBindAddress);\n\t\t\t\t}\n\t\t\t} catch (InterruptedException e) {\n\t\t\t}\n\t\t}\n\t\tif (shutdown != null) {\n\t\t\ttry {\n\t\t\t\tif (!shutdown.awaitTermination(500, TimeUnit.MILLISECONDS)) {\n\t\t\t\t\tLOGGER.warn(\"Shutdown DTLS connector on [{}] executor not terminated in time!\", lastBindAddress);\n\t\t\t\t}\n\t\t\t} catch (InterruptedException e) {\n\t\t\t}\n\t\t}\n\t\tfor (Runnable job : pending) {\n\t\t\ttry {\n\t\t\t\tjob.run();\n\t\t\t} catch (Exception e) {\n\t\t\t\tLOGGER.warn(\"Shutdown DTLS connector:\", e);\n\t\t\t}\n\t\t}\n\t\tif (stop) {\n\t\t\tLOGGER.debug(\"DTLS connector on [{}] stopped.\", lastBindAddress);\n\t\t}\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DTLSConnector.java",
        "method_name": "scandium-core/src/main/java/org/eclipse/californium/scandium/DTLSConnector.java#stop",
        "raw_code": "@Override\n\tpublic void stop() {\n\t\tExecutorService shutdownTimer = null;\n\t\tExecutorService shutdown = null;\n\t\tList<Runnable> pending = new ArrayList<>();\n\t\tboolean stop;\n\t\tsynchronized (this) {\n\t\t\tstop = running.compareAndSet(true, false);\n\t\t\tif (stop) {\n\t\t\t\tLOGGER.debug(\"DTLS connector on [{}] stopping ...\", lastBindAddress);\n\t\t\t\tif (statusLogger != null) {\n\t\t\t\t\tstatusLogger.cancel(false);\n\t\t\t\t\tstatusLogger = null;\n\t\t\t\t}\n\t\t\t\tif (recentHandshakeCleaner != null) {\n\t\t\t\t\trecentHandshakeCleaner.cancel(false);\n\t\t\t\t\trecentHandshakeCleaner = null;\n\t\t\t\t}\n\t\t\t\t// recent handshakes will be restored from connection store,\n\t\t\t\tclearRecentHandshakes();\n\t\t\t\tfor (Thread t : receiverThreads) {\n\t\t\t\t\tt.interrupt();\n\t\t\t\t}\n\t\t\t\tif (socket != null) {\n\t\t\t\t\tsocket.close();\n\t\t\t\t\tsocket = null;\n\t\t\t\t}\n\t\t\t\tmaximumTransmissionUnit = null;\n\t\t\t\tipv4Mtu = DEFAULT_IPV4_MTU;\n\t\t\t\tipv6Mtu = DEFAULT_IPV6_MTU;\n\t\t\t\tconnectionStore.stop(pending);\n\t\t\t\tif (executorService != timer) {\n\t\t\t\t\tpending.addAll(timer.shutdownNow());\n\t\t\t\t\tshutdownTimer = timer;\n\t\t\t\t\ttimer = null;\n\t\t\t\t}\n\t\t\t\tif (hasInternalExecutor) {\n\t\t\t\t\tpending.addAll(executorService.shutdownNow());\n\t\t\t\t\tshutdown = executorService;\n\t\t\t\t\texecutorService = null;\n\t\t\t\t\thasInternalExecutor = false;\n\t\t\t\t\tif (connectionStore instanceof ReadWriteLockConnectionStore) {\n\t\t\t\t\t\t((ReadWriteLockConnectionStore)connectionStore).setExecutor(null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (Thread t : receiverThreads) {\n\t\t\t\t\tt.interrupt();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tt.join(500);\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treceiverThreads.clear();\n\t\t\t}\n\t\t}\n\t\tif (shutdownTimer != null) {\n\t\t\ttry {\n\t\t\t\tif (!shutdownTimer.awaitTermination(500, TimeUnit.MILLISECONDS)) {\n\t\t\t\t\tLOGGER.warn(\"Shutdown DTLS connector on [{}] timer not terminated in time!\", lastBindAddress);\n\t\t\t\t}\n\t\t\t} catch (InterruptedException e) {\n\t\t\t}\n\t\t}\n\t\tif (shutdown != null) {\n\t\t\ttry {\n\t\t\t\tif (!shutdown.awaitTermination(500, TimeUnit.MILLISECONDS)) {\n\t\t\t\t\tLOGGER.warn(\"Shutdown DTLS connector on [{}] executor not terminated in time!\", lastBindAddress);\n\t\t\t\t}\n\t\t\t} catch (InterruptedException e) {\n\t\t\t}\n\t\t}\n\t\tExecutorsUtil.runAll(pending);\n\t\tif (stop) {\n\t\t\tLOGGER.debug(\"DTLS connector on [{}] stopped.\", lastBindAddress);\n\t\t}\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "plantuml",
    "cve_id": "CVE-2022-1379",
    "cwe_list": [
      "CWE-918"
    ],
    "commit_hash": "93e5964e5f35914f3f7b89de620c596795550083",
    "short_hash": "93e5964e",
    "vulnerableMethods_before": [
      {
        "filename": "CommandBinary.java",
        "method_name": "src/net/sourceforge/plantuml/timingdiagram/command/CommandBinary.java#executeArg",
        "raw_code": "@Override\n\tfinal protected CommandExecutionResult executeArg(TimingDiagram diagram, LineLocation location, RegexResult arg) {\n\t\tfinal String compact = arg.get(\"COMPACT\", 0);\n\t\tfinal String code = arg.get(\"CODE\", 0);\n\t\tfinal String full = arg.get(\"FULL\", 0);\n\t\treturn diagram.createBinary(code, full, compact != null);\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "CommandBinary.java",
        "method_name": "src/net/sourceforge/plantuml/timingdiagram/command/CommandBinary.java#executeArg",
        "raw_code": "@Override\n\tfinal protected CommandExecutionResult executeArg(TimingDiagram diagram, LineLocation location, RegexResult arg) {\n\t\tfinal String compact = arg.get(\"COMPACT\", 0);\n\t\tfinal String code = arg.get(\"CODE\", 0);\n\t\tfinal String full = arg.get(\"FULL\", 0);\n\n\t\tStereotype stereotype = null;\n\t\tif (arg.get(\"STEREOTYPE\", 0) != null)\n\t\t\tstereotype = Stereotype.build(arg.get(\"STEREOTYPE\", 0));\n\t\telse if (arg.get(\"STEREOTYPE2\", 0) != null)\n\t\t\tstereotype = Stereotype.build(arg.get(\"STEREOTYPE2\", 0));\n\n\t\treturn diagram.createBinary(code, full, compact != null, stereotype);\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2023-37913",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "45d182a4141ff22f3ff289cf71e4669bdc714544",
    "short_hash": "45d182a4",
    "vulnerableMethods_before": [
      {
        "filename": "ImageFilter.java",
        "method_name": "xwiki-platform-core/xwiki-platform-office/xwiki-platform-office-importer/src/main/java/org/xwiki/officeimporter/internal/filter/ImageFilter.java#filter",
        "raw_code": "@Override\n    public void filter(Document htmlDocument, Map<String, String> cleaningParams)\n    {\n        String targetDocumentName = cleaningParams.get(\"targetDocument\");\n        DocumentReference targetDocumentReference =\n            targetDocumentName == null ? null : this.stringDocumentReferenceResolver.resolve(targetDocumentName);\n\n        boolean attachEmbeddedImages = Boolean.valueOf(cleaningParams.get(\"attachEmbeddedImages\"));\n        if (attachEmbeddedImages) {\n            htmlDocument.setUserData(EMBEDDED_IMAGES, new HashMap<String, byte[]>(), null);\n        }\n\n        List<Element> images = filterDescendants(htmlDocument.getDocumentElement(), new String[] {TAG_IMG});\n        for (Element image : images) {\n            Attr source = image.getAttributeNode(ATTRIBUTE_SRC);\n            if (source != null && targetDocumentReference != null) {\n                filterImageSource(source, targetDocumentReference);\n            }\n\n            // The 'align' attribute of images creates a lot of problems. First,the office server has a problem with\n            // center aligning images (it aligns them to left). Next, the office server uses <br clear\"xxx\"> for\n            // avoiding content wrapping around images which is not valid XHTML. There for, to be consistent and simple\n            // we will remove the 'align' attribute of all the images so that they are all left aligned.\n            image.removeAttribute(ATTRIBUTE_ALIGN);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ImageFilter.java",
        "method_name": "xwiki-platform-core/xwiki-platform-office/xwiki-platform-office-importer/src/main/java/org/xwiki/officeimporter/internal/filter/ImageFilter.java#filter",
        "raw_code": "@Override\n    public void filter(Document htmlDocument, Map<String, String> cleaningParams)\n    {\n        String targetDocumentName = cleaningParams.get(\"targetDocument\");\n        DocumentReference targetDocumentReference =\n            targetDocumentName == null ? null : this.stringDocumentReferenceResolver.resolve(targetDocumentName);\n\n        boolean attachEmbeddedImages = Boolean.valueOf(cleaningParams.get(\"attachEmbeddedImages\"));\n        if (attachEmbeddedImages) {\n            htmlDocument.setUserData(EMBEDDED_IMAGES, new HashMap<String, byte[]>(), null);\n        }\n\n        String replaceAttachmentPrefix = cleaningParams.get(\"replaceImagePrefix\");\n        String replacementAttachmentPrefix = cleaningParams.get(\"replacementImagePrefix\");\n\n        List<Element> images = filterDescendants(htmlDocument.getDocumentElement(), new String[] {TAG_IMG});\n        for (Element image : images) {\n            Attr source = image.getAttributeNode(ATTRIBUTE_SRC);\n            if (source != null && targetDocumentReference != null) {\n                filterImageSource(source, targetDocumentReference, replaceAttachmentPrefix,\n                    replacementAttachmentPrefix);\n            }\n\n            // The 'align' attribute of images creates a lot of problems. First,the office server has a problem with\n            // center aligning images (it aligns them to left). Next, the office server uses <br clear\"xxx\"> for\n            // avoiding content wrapping around images which is not valid XHTML. There for, to be consistent and simple\n            // we will remove the 'align' attribute of all the images so that they are all left aligned.\n            image.removeAttribute(ATTRIBUTE_ALIGN);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "jenkins",
    "cve_id": "CVE-2013-7330",
    "cwe_list": [
      "CWE-264"
    ],
    "commit_hash": "36342d71e29e0620f803a7470ce96c61761648d8",
    "short_hash": "36342d71",
    "vulnerableMethods_before": [],
    "vulnerableMethods_after": [
      {
        "filename": "BuildTrigger.java",
        "method_name": "core/src/main/java/hudson/tasks/BuildTrigger.java#doCheck",
        "raw_code": "public FormValidation doCheck(@AncestorInPath Item project, @QueryParameter String value, @QueryParameter boolean upstream) {\n            // Require CONFIGURE permission on this project\n            if(!project.hasPermission(Item.CONFIGURE))      return FormValidation.ok();\n\n            StringTokenizer tokens = new StringTokenizer(Util.fixNull(value),\",\");\n            boolean hasProjects = false;\n            while(tokens.hasMoreTokens()) {\n                String projectName = tokens.nextToken().trim();\n                if (StringUtils.isNotBlank(projectName)) {\n                    Item item = Jenkins.getInstance().getItem(projectName,project,Item.class);\n                    if(item==null)\n                        return FormValidation.error(Messages.BuildTrigger_NoSuchProject(projectName,\n                                AbstractProject.findNearest(projectName,project.getParent()).getRelativeNameFrom(project)));\n                    if(!(item instanceof AbstractProject))\n                        return FormValidation.error(Messages.BuildTrigger_NotBuildable(projectName));\n                    if (!upstream && !item.hasPermission(Item.BUILD)) {\n                        return FormValidation.error(Messages.BuildTrigger_you_have_no_permission_to_build_(projectName));\n                    }\n                    hasProjects = true;\n                }\n            }\n            if (!hasProjects) {\n                return FormValidation.error(Messages.BuildTrigger_NoProjectSpecified());\n            }\n\n            return FormValidation.ok();\n        }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2022-36092",
    "cwe_list": [
      "CWE-287"
    ],
    "commit_hash": "71a6d0bb6f8ab718fcfaae0e9b8c16c2d69cd4bb",
    "short_hash": "71a6d0bb",
    "vulnerableMethods_before": [
      {
        "filename": "XWiki.java",
        "method_name": "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/XWiki.java#prepareDocuments",
        "raw_code": "public boolean prepareDocuments(XWikiRequest request, XWikiContext context, VelocityContext vcontext)\n        throws XWikiException\n    {\n        XWikiDocument doc;\n        context.getWiki().prepareResources(context);\n        DocumentReference reference = getDocumentReference(request, context);\n        if (context.getAction().equals(\"register\")) {\n            setPhonyDocument(reference, context, vcontext);\n            doc = context.getDoc();\n        } else {\n            try {\n                doc = getDocument(reference, context);\n            } catch (XWikiException e) {\n                doc = context.getDoc();\n                if (context.getAction().equals(\"delete\")) {\n                    if (doc == null) {\n                        setPhonyDocument(reference, context, vcontext);\n                        doc = context.getDoc();\n                    }\n                    if (!checkAccess(\"admin\", doc, context)) {\n                        throw e;\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        // the user is set after the access is checked.\n        boolean hasAccess = checkAccess(context.getAction(), doc, context);\n\n        XWikiUser user;\n        if (context.getUserReference() != null) {\n            user = new XWikiUser(context.getUserReference());\n        } else {\n            user = new XWikiUser(context.getUser());\n        }\n\n        // We need to check rights before we look for translations\n        // Otherwise we don't have the user language\n        if (!hasAccess) {\n            Object[] args = { doc.getFullName(), user.getUser() };\n            setPhonyDocument(reference, context, vcontext);\n            throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS, XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                \"Access to document {0} has been denied to user {1}\", null, args);\n        // User is disabled: the mail address is marked as checked\n        } else if (user.isDisabled(context) && user.isEmailChecked(context)) {\n            String action = context.getAction();\n            /*\n             * Allow inactive users to see skins, ressources, SSX, JSX and downloads they could have seen as guest. The\n             * rational behind this behaviour is that inactive users should be able to access the same UI that guests\n             * are used to see, including custom icons, panels, and so on...\n             */\n            if (!((action.equals(\"skin\") && (doc.getSpace().equals(\"skins\") || doc.getSpace().equals(\"resources\")))\n                || ((action.equals(\"skin\") || action.equals(\"download\") || action.equals(\"ssx\") || action.equals(\"jsx\"))\n                    && getRightService().hasAccessLevel(\"view\", XWikiRightService.GUEST_USER_FULLNAME,\n                        doc.getPrefixedFullName(), context))\n                || ((action.equals(\"view\") && doc.getFullName().equals(\"XWiki.AccountValidation\"))))) {\n                Object[] args = { user.getUser() };\n                setPhonyDocument(reference, context, vcontext);\n                throw new XWikiException(XWikiException.MODULE_XWIKI_USER, XWikiException.ERROR_XWIKI_USER_DISABLED,\n                    \"User {0} account is disabled\", null, args);\n            }\n        // User actually needs to activate his mail address.\n        } else if (user.isDisabled(context) && !user.isEmailChecked(context)) {\n            boolean allow = false;\n            String action = context.getAction();\n            /*\n             * Allow inactive users to see skins, ressources, SSX, JSX and downloads they could have seen as guest. The\n             * rational behind this behaviour is that inactive users should be able to access the same UI that guests\n             * are used to see, including custom icons, panels, and so on...\n             */\n            if ((action.equals(\"skin\") && (doc.getSpace().equals(\"skins\") || doc.getSpace().equals(\"resources\")))\n                || ((action.equals(\"skin\") || action.equals(\"download\") || action.equals(\"ssx\") || action.equals(\"jsx\"))\n                    && getRightService().hasAccessLevel(\"view\", XWikiRightService.GUEST_USER_FULLNAME,\n                        doc.getPrefixedFullName(), context))\n                || ((action.equals(\"view\") && doc.getFullName().equals(\"XWiki.AccountValidation\")))) {\n                allow = true;\n            } else {\n                String allowed = getConfiguration().getProperty(\"xwiki.inactiveuser.allowedpages\", \"\");\n                if (context.getAction().equals(\"view\") && !allowed.equals(\"\")) {\n                    String[] allowedList = StringUtils.split(allowed, \" ,\");\n                    for (String element : allowedList) {\n                        if (element.equals(doc.getFullName())) {\n                            allow = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            if (!allow) {\n                Object[] args = { context.getUser() };\n                setPhonyDocument(reference, context, vcontext);\n                throw new XWikiException(XWikiException.MODULE_XWIKI_USER, XWikiException.ERROR_XWIKI_USER_INACTIVE,\n                    \"User {0} account is inactive\", null, args);\n            }\n        }\n\n        context.put(\"doc\", doc);\n        context.put(\"cdoc\", doc);\n        vcontext.put(\"doc\", doc.newDocument(context));\n        vcontext.put(\"cdoc\", vcontext.get(\"doc\"));\n        XWikiDocument tdoc;\n\n        // If the parameter language exists and is empty, it means we want to force loading the regular document\n        // not a translation. This should be handled later by doing a better separation between locale used in the UI\n        // and for loading the documents.\n        if (\"\".equals(context.getRequest().getParameter(\"language\"))) {\n            tdoc = doc;\n        } else {\n            tdoc = doc.getTranslatedDocument(context);\n        }\n\n        try {\n            String rev = (String) context.get(\"rev\");\n            if (StringUtils.isNotEmpty(rev)) {\n                tdoc = getDocument(tdoc, rev, context);\n            }\n        } catch (Exception ex) {\n            // Invalid version, just use the most recent one\n        }\n        context.put(\"tdoc\", tdoc);\n        vcontext.put(\"tdoc\", tdoc.newDocument(context));\n\n        return true;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "XWiki.java",
        "method_name": "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/XWiki.java#prepareDocuments",
        "raw_code": "public boolean prepareDocuments(XWikiRequest request, XWikiContext context, VelocityContext vcontext)\n        throws XWikiException\n    {\n        XWikiDocument doc;\n        context.getWiki().prepareResources(context);\n        DocumentReference reference = getDocumentReference(request, context);\n        if (context.getAction().equals(\"register\")) {\n            setPhonyDocument(reference, context, vcontext);\n            doc = context.getDoc();\n        } else {\n            try {\n                doc = getDocument(reference, context);\n            } catch (XWikiException e) {\n                doc = context.getDoc();\n                if (context.getAction().equals(\"delete\")) {\n                    if (doc == null) {\n                        setPhonyDocument(reference, context, vcontext);\n                        doc = context.getDoc();\n                    }\n                    if (!checkAccess(\"admin\", doc, context)) {\n                        throw e;\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        // the user is set after the access is checked.\n        boolean hasAccess = checkAccess(context.getAction(), doc, context);\n\n        XWikiUser user;\n        if (context.getUserReference() != null) {\n            user = new XWikiUser(context.getUserReference());\n        } else {\n            user = new XWikiUser(context.getUser());\n        }\n\n        // We need to check rights before we look for translations\n        // Otherwise we don't have the user language\n        if (!hasAccess) {\n            Object[] args = { doc.getFullName(), user.getUser() };\n            setPhonyDocument(reference, context, vcontext);\n            throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS, XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                \"Access to document {0} has been denied to user {1}\", null, args);\n        // User is disabled: the mail address is marked as checked\n        } else if (user.isDisabled(context) && user.isEmailChecked(context)) {\n            String action = context.getAction();\n            /*\n             * Allow inactive users to see skins, ressources, SSX, JSX and downloads they could have seen as guest. The\n             * rational behind this behaviour is that inactive users should be able to access the same UI that guests\n             * are used to see, including custom icons, panels, and so on...\n             */\n            if (!((action.equals(\"skin\") && (doc.getSpace().equals(\"skins\") || doc.getSpace().equals(\"resources\")))\n                || ((action.equals(\"skin\") || action.equals(\"download\") || action.equals(\"ssx\") || action.equals(\"jsx\"))\n                    && getRightService().hasAccessLevel(\"view\", XWikiRightService.GUEST_USER_FULLNAME,\n                        doc.getPrefixedFullName(), context))\n                || ((action.equals(\"view\") && doc.getFullName().equals(\"XWiki.AccountValidation\"))))) {\n                Object[] args = { user.getUser() };\n                setPhonyDocument(reference, context, vcontext);\n                throw new XWikiException(XWikiException.MODULE_XWIKI_USER, XWikiException.ERROR_XWIKI_USER_DISABLED,\n                    \"User {0} account is disabled\", null, args);\n            }\n        // User actually needs to activate his mail address.\n        } else if (user.isDisabled(context) && !user.isEmailChecked(context)) {\n            boolean allow = false;\n            String action = context.getAction();\n            /*\n             * Allow inactive users to see skins, ressources, SSX, JSX and downloads they could have seen as guest. The\n             * rational behind this behaviour is that inactive users should be able to access the same UI that guests\n             * are used to see, including custom icons, panels, and so on...\n             */\n            if ((action.equals(\"skin\") && (doc.getSpace().equals(\"skins\") || doc.getSpace().equals(\"resources\")))\n                || ((action.equals(\"skin\") || action.equals(\"download\") || action.equals(\"ssx\") || action.equals(\"jsx\"))\n                    && getRightService().hasAccessLevel(\"view\", XWikiRightService.GUEST_USER_FULLNAME,\n                        doc.getPrefixedFullName(), context))\n                || ((action.equals(\"view\") && doc.getFullName().equals(\"XWiki.AccountValidation\")))) {\n                allow = true;\n            } else {\n                String allowed = getConfiguration().getProperty(\"xwiki.inactiveuser.allowedpages\", \"\");\n                if (context.getAction().equals(\"view\") && !allowed.equals(\"\")) {\n                    String[] allowedList = StringUtils.split(allowed, \" ,\");\n                    for (String element : allowedList) {\n                        if (element.equals(doc.getFullName())) {\n                            allow = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            if (!allow) {\n                Object[] args = { context.getUser() };\n                setPhonyDocument(reference, context, vcontext);\n                throw new XWikiException(XWikiException.MODULE_XWIKI_USER, XWikiException.ERROR_XWIKI_USER_INACTIVE,\n                    \"User {0} account is inactive\", null, args);\n            }\n        }\n\n        if (!\"skin\".equals(context.getAction()) && !this.getRightService().hasAccessLevel(\"view\",\n            user.getFullName(), doc.getFullName(), context)) {\n            // If for some reason (e.g., login action) the user has rights for the action but no view right on the\n            // document, do not load the document into the context.\n            setPhonyDocument(reference, context, vcontext);\n            doc = context.getDoc();\n            context.put(\"tdoc\", doc);\n            context.put(\"cdoc\", doc);\n        } else {\n            context.put(\"doc\", doc);\n            context.put(\"cdoc\", doc);\n            vcontext.put(\"doc\", doc.newDocument(context));\n            vcontext.put(\"cdoc\", vcontext.get(\"doc\"));\n            XWikiDocument tdoc;\n\n            // If the parameter language exists and is empty, it means we want to force loading the regular document\n            // not a translation. This should be handled later by doing a better separation between locale used in the UI\n            // and for loading the documents.\n            if (\"\".equals(context.getRequest().getParameter(\"language\"))) {\n                tdoc = doc;\n            } else {\n                tdoc = doc.getTranslatedDocument(context);\n            }\n\n            try {\n                String rev = (String) context.get(\"rev\");\n                if (StringUtils.isNotEmpty(rev)) {\n                    tdoc = getDocument(tdoc, rev, context);\n                }\n            } catch (Exception ex) {\n                // Invalid version, just use the most recent one\n            }\n            context.put(\"tdoc\", tdoc);\n            vcontext.put(\"tdoc\", tdoc.newDocument(context));\n        }\n\n        return true;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "bc-java",
    "cve_id": "CVE-2016-1000339",
    "cwe_list": [
      "CWE-310"
    ],
    "commit_hash": "413b42f4d770456508585c830cfcde95f9b0e93b#diff-54656f860db94b867ba7542430cd2ef0",
    "short_hash": "413b42f4",
    "vulnerableMethods_before": [
      {
        "filename": "DHPublicKeyParameters.java",
        "method_name": "validate",
        "raw_code": "private BigInteger validate(BigInteger y, DHParameters dhParams)\n    {\n        if (y == null)\n        {\n            throw new NullPointerException(\"y value cannot be null\");\n        }\n\n        if (dhParams.getQ() != null)\n        {\n            if (ONE.equals(y.modPow(dhParams.getQ(), dhParams.getP())))\n            {\n                return y;\n            }\n\n            throw new IllegalArgumentException(\"Y value does not appear to be in correct group\");\n        }\n        else\n        {\n            // TLS check\n            if (y.compareTo(TWO) < 0 || y.compareTo(dhParams.getP().subtract(TWO)) > 0)\n            {\n                throw new IllegalArgumentException(\"invalid DH public key\");\n            }\n\n            return y;         // we can't validate without Q.\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DHPublicKeyParameters.java",
        "method_name": "validate",
        "raw_code": "private BigInteger validate(BigInteger y, DHParameters dhParams)\n    {\n        if (y == null)\n        {\n            throw new NullPointerException(\"y value cannot be null\");\n        }\n\n        // TLS check\n        if (y.compareTo(TWO) < 0 || y.compareTo(dhParams.getP().subtract(TWO)) > 0)\n        {\n            throw new IllegalArgumentException(\"invalid DH public key\");\n        }\n\n        if (dhParams.getQ() != null)\n        {\n            if (ONE.equals(y.modPow(dhParams.getQ(), dhParams.getP())))\n            {\n                return y;\n            }\n\n            throw new IllegalArgumentException(\"Y value does not appear to be in correct group\");\n        }\n        else\n        {\n            return y;         // we can't validate without Q.\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "RuoYi",
    "cve_id": "CVE-2022-32065",
    "cwe_list": [
      "CWE-79"
    ],
    "commit_hash": "d8b2a9a905fb750fa60e2400238cf4750a77c5e6",
    "short_hash": "d8b2a9a9",
    "vulnerableMethods_before": [
      {
        "filename": "SysProfileController.java",
        "method_name": "ruoyi-admin/src/main/java/com/ruoyi/web/controller/system/SysProfileController.java#updateAvatar",
        "raw_code": "@Log(title = \"\", businessType = BusinessType.UPDATE)\n    @PostMapping(\"/updateAvatar\")\n    @ResponseBody\n    public AjaxResult updateAvatar(@RequestParam(\"avatarfile\") MultipartFile file)\n    {\n        SysUser currentUser = getSysUser();\n        try\n        {\n            if (!file.isEmpty())\n            {\n                String avatar = FileUploadUtils.upload(RuoYiConfig.getAvatarPath(), file);\n                currentUser.setAvatar(avatar);\n                if (userService.updateUserInfo(currentUser) > 0)\n                {\n                    setSysUser(userService.selectUserById(currentUser.getUserId()));\n                    return success();\n                }\n            }\n            return error();\n        }\n        catch (Exception e)\n        {\n            log.error(\"\", e);\n            return error(e.getMessage());\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SysProfileController.java",
        "method_name": "ruoyi-admin/src/main/java/com/ruoyi/web/controller/system/SysProfileController.java#updateAvatar",
        "raw_code": "@Log(title = \"\", businessType = BusinessType.UPDATE)\n    @PostMapping(\"/updateAvatar\")\n    @ResponseBody\n    public AjaxResult updateAvatar(@RequestParam(\"avatarfile\") MultipartFile file)\n    {\n        SysUser currentUser = getSysUser();\n        try\n        {\n            if (!file.isEmpty())\n            {\n                String avatar = FileUploadUtils.upload(RuoYiConfig.getAvatarPath(), file, MimeTypeUtils.IMAGE_EXTENSION);\n                currentUser.setAvatar(avatar);\n                if (userService.updateUserInfo(currentUser) > 0)\n                {\n                    setSysUser(userService.selectUserById(currentUser.getUserId()));\n                    return success();\n                }\n            }\n            return error();\n        }\n        catch (Exception e)\n        {\n            log.error(\"\", e);\n            return error(e.getMessage());\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "geowebcache",
    "cve_id": "CVE-2024-23643",
    "cwe_list": [
      "CWE-79"
    ],
    "commit_hash": "9d010e09c784690ada8af43f594461a2553a62f0",
    "short_hash": "9d010e09",
    "vulnerableMethods_before": [
      {
        "filename": "FormService.java",
        "method_name": "geowebcache/rest/src/main/java/org/geowebcache/rest/service/FormService.java#makeModifiableParameters",
        "raw_code": "private void makeModifiableParameters(StringBuilder doc, TileLayer tl) {\n        List<ParameterFilter> parameterFilters = tl.getParameterFilters();\n        if (parameterFilters == null || parameterFilters.isEmpty()) {\n            return;\n        }\n        doc.append(\"<tr><td>Modifiable Parameters:</td><td>\\n\");\n        doc.append(\"<table>\");\n        for (ParameterFilter pf : parameterFilters) {\n            Assert.notNull(pf, \"Parameter filter must be non null\");\n            String key = pf.getKey();\n            String defaultValue = pf.getDefaultValue();\n            List<String> legalValues = pf.getLegalValues();\n            doc.append(\"<tr><td>\").append(key.toUpperCase()).append(\": \").append(\"</td><td>\");\n            String parameterId = \"parameter_\" + key;\n            if (pf instanceof StringParameterFilter) {\n                Map<String, String> keysValues = makeParametersMap(defaultValue, legalValues);\n                makePullDown(doc, parameterId, keysValues, defaultValue);\n            } else if (pf instanceof RegexParameterFilter) {\n                makeTextInput(doc, parameterId, 25);\n            } else if (pf instanceof FloatParameterFilter) {\n                FloatParameterFilter floatFilter = (FloatParameterFilter) pf;\n                if (floatFilter.getValues().isEmpty()) {\n                    // accepts any value\n                    makeTextInput(doc, parameterId, 25);\n                } else {\n                    Map<String, String> keysValues = makeParametersMap(defaultValue, legalValues);\n                    makePullDown(doc, parameterId, keysValues, defaultValue);\n                }\n            } else if (\"org.geowebcache.filter.parameters.NaiveWMSDimensionFilter\"\n                    .equals(pf.getClass().getName())) {\n                makeTextInput(doc, parameterId, 25);\n            } else {\n                // Unknown filter type\n                if (legalValues == null) {\n                    // Doesn't have a defined set of values, just provide a text field\n                    makeTextInput(doc, parameterId, 25);\n                } else {\n                    // Does have a defined set of values, so provide a drop down\n                    Map<String, String> keysValues = makeParametersMap(defaultValue, legalValues);\n                    makePullDown(doc, parameterId, keysValues, defaultValue);\n                }\n            }\n            doc.append(\"</td></tr>\");\n        }\n        doc.append(\"</table>\");\n        doc.append(\"</td></tr>\\n\");\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FormService.java",
        "method_name": "geowebcache/rest/src/main/java/org/geowebcache/rest/service/FormService.java#makeModifiableParameters",
        "raw_code": "private void makeModifiableParameters(StringBuilder doc, TileLayer tl) {\n        List<ParameterFilter> parameterFilters = tl.getParameterFilters();\n        if (parameterFilters == null || parameterFilters.isEmpty()) {\n            return;\n        }\n        doc.append(\"<tr><td>Modifiable Parameters:</td><td>\\n\");\n        doc.append(\"<table>\");\n        for (ParameterFilter pf : parameterFilters) {\n            Assert.notNull(pf, \"Parameter filter must be non null\");\n            String key = pf.getKey();\n            String defaultValue = pf.getDefaultValue();\n            List<String> legalValues = pf.getLegalValues();\n            doc.append(\"<tr><td>\")\n                    .append(escapeHtml4(key.toUpperCase()))\n                    .append(\": \")\n                    .append(\"</td><td>\");\n            String parameterId = \"parameter_\" + key;\n            if (pf instanceof StringParameterFilter) {\n                Map<String, String> keysValues = makeParametersMap(defaultValue, legalValues);\n                makePullDown(doc, parameterId, keysValues, defaultValue);\n            } else if (pf instanceof RegexParameterFilter) {\n                makeTextInput(doc, parameterId, 25);\n            } else if (pf instanceof FloatParameterFilter) {\n                FloatParameterFilter floatFilter = (FloatParameterFilter) pf;\n                if (floatFilter.getValues().isEmpty()) {\n                    // accepts any value\n                    makeTextInput(doc, parameterId, 25);\n                } else {\n                    Map<String, String> keysValues = makeParametersMap(defaultValue, legalValues);\n                    makePullDown(doc, parameterId, keysValues, defaultValue);\n                }\n            } else if (\"org.geowebcache.filter.parameters.NaiveWMSDimensionFilter\"\n                    .equals(pf.getClass().getName())) {\n                makeTextInput(doc, parameterId, 25);\n            } else {\n                // Unknown filter type\n                if (legalValues == null) {\n                    // Doesn't have a defined set of values, just provide a text field\n                    makeTextInput(doc, parameterId, 25);\n                } else {\n                    // Does have a defined set of values, so provide a drop down\n                    Map<String, String> keysValues = makeParametersMap(defaultValue, legalValues);\n                    makePullDown(doc, parameterId, keysValues, defaultValue);\n                }\n            }\n            doc.append(\"</td></tr>\");\n        }\n        doc.append(\"</table>\");\n        doc.append(\"</td></tr>\\n\");\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2024-31464",
    "cwe_list": [
      "CWE-916"
    ],
    "commit_hash": "955fb097e02a2a7153f527522ee9eef42447e5d7",
    "short_hash": "955fb097",
    "vulnerableMethods_before": [],
    "vulnerableMethods_after": [
      {
        "filename": "BaseObject.java",
        "method_name": "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/objects/BaseObject.java#getDiff",
        "raw_code": "@Override\n    public List<ObjectDiff> getDiff(Object oldEntity, XWikiContext context)\n    {\n        ArrayList<ObjectDiff> difflist = new ArrayList<ObjectDiff>();\n        BaseObject oldObject = (BaseObject) oldEntity;\n        // Iterate over the new properties first, to handle changed and added objects\n        for (String propertyName : this.getPropertyList()) {\n            BaseProperty newProperty = (BaseProperty) this.getField(propertyName);\n            BaseProperty oldProperty = (BaseProperty) oldObject.getField(propertyName);\n            BaseClass bclass = getXClass(context);\n            PropertyClass pclass = (PropertyClass) ((bclass == null) ? null : bclass.getField(propertyName));\n            String propertyType = (pclass == null) ? \"\" : pclass.getClassType();\n\n            if (oldProperty == null) {\n                // The property exist in the new object, but not in the old one\n                if ((newProperty != null) && (!newProperty.toText().equals(\"\"))) {\n                    String newPropertyValue = (newProperty.getValue() instanceof String || pclass == null)\n                        ? newProperty.toText() : pclass.displayView(propertyName, this, context);\n                    difflist.add(new ObjectDiff(getXClassReference(), getNumber(), getGuid(),\n                        ObjectDiff.ACTION_PROPERTYADDED, propertyName, propertyType, \"\", newPropertyValue));\n                }\n            } else if (!oldProperty.toText().equals(((newProperty == null) ? \"\" : newProperty.toText()))) {\n                // The property exists in both objects and is different\n                if (pclass != null) {\n                    // Put the values as they would be displayed in the interface\n                    String newPropertyValue = (newProperty.getValue() instanceof String) ? newProperty.toText()\n                        : pclass.displayView(propertyName, this, context);\n                    String oldPropertyValue = (oldProperty.getValue() instanceof String) ? oldProperty.toText()\n                        : pclass.displayView(propertyName, oldObject, context);\n                    difflist.add(\n                        new ObjectDiff(getXClassReference(), getNumber(), getGuid(), ObjectDiff.ACTION_PROPERTYCHANGED,\n                            propertyName, propertyType, oldPropertyValue, newPropertyValue));\n                } else {\n                    // Cannot get property definition, so use the plain value\n                    difflist.add(\n                        new ObjectDiff(getXClassReference(), getNumber(), getGuid(), ObjectDiff.ACTION_PROPERTYCHANGED,\n                            propertyName, propertyType, oldProperty.toText(), newProperty.toText()));\n                }\n            }\n        }\n\n        // Iterate over the old properties, in case there are some removed properties\n        for (String propertyName : oldObject.getPropertyList()) {\n            BaseProperty newProperty = (BaseProperty) this.getField(propertyName);\n            BaseProperty oldProperty = (BaseProperty) oldObject.getField(propertyName);\n            BaseClass bclass = getXClass(context);\n            // Bulletproofing: in theory the BaseObject is defined with a xclass reference allowing to resolve it\n            // however, it's possible that the reference is not set, in which case we might still find the info\n            // in the old object.\n            if (bclass == null) {\n                bclass = oldObject.getXClass(context);\n            }\n            PropertyClass pclass = (PropertyClass) ((bclass == null) ? null : bclass.getField(propertyName));\n            String propertyType = (pclass == null) ? \"\" : pclass.getClassType();\n\n            if (newProperty == null) {\n                // The property exists in the old object, but not in the new one\n                if ((oldProperty != null) && (!oldProperty.toText().equals(\"\"))) {\n                    if (pclass != null) {\n                        // Put the values as they would be displayed in the interface\n                        String oldPropertyValue = (oldProperty.getValue() instanceof String) ? oldProperty.toText()\n                            : pclass.displayView(propertyName, oldObject, context);\n                        difflist.add(\n                            new ObjectDiff(oldObject.getXClassReference(), oldObject.getNumber(), oldObject.getGuid(),\n                                ObjectDiff.ACTION_PROPERTYREMOVED, propertyName, propertyType, oldPropertyValue, \"\"));\n                    } else {\n                        // Cannot get property definition, so use the plain value\n                        difflist.add(new ObjectDiff(oldObject.getXClassReference(), oldObject.getNumber(),\n                            oldObject.getGuid(), ObjectDiff.ACTION_PROPERTYREMOVED, propertyName, propertyType,\n                            oldProperty.toText(), \"\"));\n                    }\n                }\n            }\n        }\n\n        return difflist;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "graylog2-server",
    "cve_id": "CVE-2024-24824",
    "cwe_list": [
      "CWE-863"
    ],
    "commit_hash": "7f8ef7fa8edf493106d5ef6f777d4da02c5194d9",
    "short_hash": "7f8ef7fa",
    "vulnerableMethods_before": [
      {
        "filename": "ClusterConfigServiceImpl.java",
        "method_name": "graylog2-server/src/main/java/org/graylog2/cluster/ClusterConfigServiceImpl.java#list",
        "raw_code": "@Override\n    public Set<Class<?>> list() {\n        final ImmutableSet.Builder<Class<?>> classes = ImmutableSet.builder();\n\n        try (DBCursor<ClusterConfig> clusterConfigs = dbCollection.find()) {\n            for (ClusterConfig clusterConfig : clusterConfigs) {\n                final String type = clusterConfig.type();\n                try {\n                    final Class<?> cls = chainingClassLoader.loadClass(type);\n                    classes.add(cls);\n                } catch (ClassNotFoundException e) {\n                    LOG.debug(\"Couldn't find configuration class \\\"{}\\\"\", type, e);\n                }\n            }\n        }\n\n        return classes.build();\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ClusterConfigServiceImpl.java",
        "method_name": "graylog2-server/src/main/java/org/graylog2/cluster/ClusterConfigServiceImpl.java#list",
        "raw_code": "@Override\n    public Set<Class<?>> list() {\n        final ImmutableSet.Builder<Class<?>> classes = ImmutableSet.builder();\n\n        try (DBCursor<ClusterConfig> clusterConfigs = dbCollection.find()) {\n            for (ClusterConfig clusterConfig : clusterConfigs) {\n                final String type = clusterConfig.type();\n                try {\n                    final Class<?> cls = chainingClassLoader.loadClassSafely(type);\n                    classes.add(cls);\n                } catch (ClassNotFoundException e) {\n                    LOG.debug(\"Couldn't find configuration class \\\"{}\\\"\", type, e);\n                } catch (UnsafeClassLoadingAttemptException e) {\n                    LOG.warn(\"Couldn't load class <{}>.\", type, e);\n                }\n            }\n        }\n\n        return classes.build();\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "cdt",
    "cve_id": "CVE-2023-4218",
    "cwe_list": [
      "CWE-611"
    ],
    "commit_hash": "c7169b3186d2fef20f97467c3e2ad78e2943ed1b",
    "short_hash": "c7169b31",
    "vulnerableMethods_before": [
      {
        "filename": "SharedDefaults.java",
        "method_name": "core/org.eclipse.cdt.core/templateengine/org/eclipse/cdt/core/templateengine/SharedDefaults.java#deleteBackEndStorage",
        "raw_code": "public void deleteBackEndStorage(String[] deleteName) {\n\t\ttry {\n\t\t\tdocument = DocumentBuilderFactory.newInstance().newDocumentBuilder()\n\t\t\t\t\t.parse(parsedXML.toURI().toURL().openStream());\n\t\t} catch (Exception exp) {\n\t\t\tTemplateEngineUtil.log(exp);\n\t\t}\n\n\t\tList<Element> sharedElementList = TemplateEngine.getChildrenOfElement(document.getDocumentElement());\n\t\tint elementListSize = sharedElementList.size();\n\t\tfor (int i = 0; i < elementListSize; i++) {\n\n\t\t\tElement xmlElement = sharedElementList.get(i);\n\t\t\tString name = xmlElement.getAttribute(TemplateEngineHelper.ID);\n\n\t\t\tfor (int k = 0; k < deleteName.length; k++) {\n\t\t\t\tif (deleteName[k].equals(name)) {\n\t\t\t\t\txmlElement.removeAttribute(name);\n\t\t\t\t\tsharedDefaultsMap.remove(name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tupdateShareDefaultsMap(sharedDefaultsMap);\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SharedDefaults.java",
        "method_name": "core/org.eclipse.cdt.core/templateengine/org/eclipse/cdt/core/templateengine/SharedDefaults.java#deleteBackEndStorage",
        "raw_code": "public void deleteBackEndStorage(String[] deleteName) {\n\t\ttry {\n\t\t\tdocument = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE()\n\t\t\t\t\t.parse(parsedXML.toURI().toURL().openStream());\n\t\t} catch (Exception exp) {\n\t\t\tTemplateEngineUtil.log(exp);\n\t\t}\n\n\t\tList<Element> sharedElementList = TemplateEngine.getChildrenOfElement(document.getDocumentElement());\n\t\tint elementListSize = sharedElementList.size();\n\t\tfor (int i = 0; i < elementListSize; i++) {\n\n\t\t\tElement xmlElement = sharedElementList.get(i);\n\t\t\tString name = xmlElement.getAttribute(TemplateEngineHelper.ID);\n\n\t\t\tfor (int k = 0; k < deleteName.length; k++) {\n\t\t\t\tif (deleteName[k].equals(name)) {\n\t\t\t\t\txmlElement.removeAttribute(name);\n\t\t\t\t\tsharedDefaultsMap.remove(name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tupdateShareDefaultsMap(sharedDefaultsMap);\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "elasticsearch",
    "cve_id": "CVE-2015-5377",
    "cwe_list": [
      "CWE-74"
    ],
    "commit_hash": "bf3052d14c874aead7da8855c5fcadf5428a43f2",
    "short_hash": "bf3052d1",
    "vulnerableMethods_before": [
      {
        "filename": "ThrowableObjectInputStream.java",
        "method_name": "src/main/java/org/elasticsearch/common/io/ThrowableObjectInputStream.java#readClassDescriptor",
        "raw_code": "@Override\n    protected ObjectStreamClass readClassDescriptor()\n            throws IOException, ClassNotFoundException {\n        int type = read();\n        if (type < 0) {\n            throw new EOFException();\n        }\n        switch (type) {\n            case ThrowableObjectOutputStream.TYPE_EXCEPTION:\n                return ObjectStreamClass.lookup(Exception.class);\n            case ThrowableObjectOutputStream.TYPE_STACKTRACEELEMENT:\n                return ObjectStreamClass.lookup(StackTraceElement.class);\n            case ThrowableObjectOutputStream.TYPE_FAT_DESCRIPTOR:\n                return super.readClassDescriptor();\n            case ThrowableObjectOutputStream.TYPE_THIN_DESCRIPTOR:\n                String className = readUTF();\n                Class<?> clazz = loadClass(className);\n                return ObjectStreamClass.lookup(clazz);\n            default:\n                throw new StreamCorruptedException(\n                        \"Unexpected class descriptor type: \" + type);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ThrowableObjectInputStream.java",
        "method_name": "src/main/java/org/elasticsearch/common/io/ThrowableObjectInputStream.java#readClassDescriptor",
        "raw_code": "@Override\n    protected ObjectStreamClass readClassDescriptor()\n            throws IOException, ClassNotFoundException {\n        int type = read();\n        if (type < 0) {\n            throw new EOFException();\n        }\n        switch (type) {\n            case ThrowableObjectOutputStream.TYPE_EXCEPTION:\n                return ObjectStreamClass.lookup(Exception.class);\n            case ThrowableObjectOutputStream.TYPE_STACKTRACEELEMENT:\n                return ObjectStreamClass.lookup(StackTraceElement.class);\n            case ThrowableObjectOutputStream.TYPE_FAT_DESCRIPTOR:\n                return verify(super.readClassDescriptor());\n            case ThrowableObjectOutputStream.TYPE_THIN_DESCRIPTOR:\n                String className = readUTF();\n                Class<?> clazz = loadClass(className);\n                return verify(ObjectStreamClass.lookup(clazz));\n            default:\n                throw new StreamCorruptedException(\n                        \"Unexpected class descriptor type: \" + type);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "jai-ext",
    "cve_id": "CVE-2022-24816",
    "cwe_list": [
      "CWE-94"
    ],
    "commit_hash": "cb1d6565d38954676b0a366da4f965fef38da1cb",
    "short_hash": "cb1d6565",
    "vulnerableMethods_before": [],
    "vulnerableMethods_after": [
      {
        "filename": "Jiffle.java",
        "method_name": "jt-jiffle/jt-jiffle-language/src/main/java/it/geosolutions/jaiext/jiffle/Jiffle.java#createRuntimeInstance",
        "raw_code": "private JiffleRuntime createRuntimeInstance(RuntimeModel model, Class<? extends JiffleRuntime> runtimeClass, boolean scriptInDocs) throws\n            \n            it.geosolutions.jaiext.jiffle.JiffleException {\n        if (!isCompiled()) {\n            throw new it.geosolutions.jaiext.jiffle.JiffleException(\"The script has not been compiled\");\n        }\n\n        String runtimeSource = createRuntimeSource(model, runtimeClass.getName(), scriptInDocs);\n        if (LOGGER.isLoggable(Level.FINE)) {\n            LOGGER.log(Level.FINE, \"Jiffle script compiled to:\\n\\n\" + runtimeSource);    \n        }\n        try {\n            SimpleCompiler compiler = new SimpleCompiler();\n            compiler.cook(runtimeSource);\n\n            StringBuilder sb = new StringBuilder();\n            sb.append(it.geosolutions.jaiext.jiffle.JiffleProperties.get(\n                    it.geosolutions.jaiext.jiffle.JiffleProperties.RUNTIME_PACKAGE_KEY)).append(\".\");\n\n            switch (model) {\n                case DIRECT:\n                    sb.append(it.geosolutions.jaiext.jiffle.JiffleProperties.get(\n                            it.geosolutions.jaiext.jiffle.JiffleProperties.DIRECT_CLASS_KEY));\n                    break;\n\n                case INDIRECT:\n                    sb.append(it.geosolutions.jaiext.jiffle.JiffleProperties.get(\n                            it.geosolutions.jaiext.jiffle.JiffleProperties.INDIRECT_CLASS_KEY));\n                    break;\n\n                default:\n                    throw new IllegalArgumentException(\"Internal compiler error\");\n            }\n\n            Class<?> clazz = compiler.getClassLoader().loadClass(sb.toString());\n            JiffleRuntime runtime = (JiffleRuntime) clazz.newInstance();\n            runtime.setImageParams(imageParams);\n            if (runtime instanceof JiffleIndirectRuntime) {\n                ((JiffleIndirectRuntime) runtime).setDestinationBands(destinationBands);\n            }\n            return runtime;\n\n        } catch (Exception ex) {\n            // do not display the source code in indirect runtime exception messages\n            if (model == RuntimeModel.INDIRECT) {\n                if (LOGGER.isLoggable(Level.FINE)) {\n                    LOGGER.fine(\"Runtime source error for source: \" + runtimeSource);\n                }\n                throw new JiffleException(\"Runtime source error\", ex);\n            }\n            throw new JiffleException(\"Runtime source error for source: \" + runtimeSource, ex);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "liferay-portal",
    "cve_id": "CVE-2010-5327",
    "cwe_list": [
      "CWE-264"
    ],
    "commit_hash": "90c4e85a8f8135f069f3f05e4d54a77704769f91",
    "short_hash": "90c4e85a",
    "vulnerableMethods_before": [
      {
        "filename": "FreeMarkerManager.java",
        "method_name": "portal-impl/src/com/liferay/portal/freemarker/FreeMarkerManager.java#destroy",
        "raw_code": "public void destroy() {\n\t\tif (_configuration == null) {\n\t\t\treturn;\n\t\t}\n\n\t\t_configuration.clearEncodingMap();\n\t\t_configuration.clearSharedVariables();\n\t\t_configuration.clearTemplateCache();\n\n\t\t_configuration = null;\n\n\t\t_restrictedHelperUtilities.clear();\n\n\t\t_restrictedHelperUtilities = null;\n\n\t\t_standardHelperUtilities.clear();\n\n\t\t_standardHelperUtilities = null;\n\n\t\t_stringTemplateLoader.removeTemplates();\n\n\t\t_stringTemplateLoader = null;\n\n\t\t_templateContextHelper = null;\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FreeMarkerManager.java",
        "method_name": "portal-impl/src/com/liferay/portal/freemarker/FreeMarkerManager.java#destroy",
        "raw_code": "public void destroy(ClassLoader classLoader) {\n\t\t_classLoaderHelperUtilities.remove(classLoader);\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xp",
    "cve_id": "CVE-2024-23679",
    "cwe_list": [
      "CWE-384"
    ],
    "commit_hash": "0189975691e9e6407a9fee87006f730e84f734ff",
    "short_hash": "01899756",
    "vulnerableMethods_before": [
      {
        "filename": "LoginHandler.java",
        "method_name": "modules/lib/lib-auth/src/main/java/com/enonic/xp/lib/auth/LoginHandler.java#createSession",
        "raw_code": "private void createSession( final AuthenticationInfo authInfo )\n    {\n        final Session session = this.context.get().getLocalScope().getSession();\n        if ( session != null )\n        {\n            session.setAttribute( authInfo );\n        }\n\n        if ( this.sessionTimeout != null )\n        {\n            setSessionTimeout();\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "LoginHandler.java",
        "method_name": "modules/lib/lib-auth/src/main/java/com/enonic/xp/lib/auth/LoginHandler.java#createSession",
        "raw_code": "private void createSession( final AuthenticationInfo authInfo )\n    {\n        final LocalScope localScope = this.context.get().getLocalScope();\n        final Session session = localScope.getSession();\n\n        if ( session != null )\n        {\n            final var attributes = session.getAttributes();\n            session.invalidate();\n\n            final Session newSession = localScope.getSession();\n\n            if ( newSession != null )\n            {\n                attributes.forEach( newSession::setAttribute );\n                session.setAttribute( authInfo );\n\n                if ( this.sessionTimeout != null )\n                {\n                    setSessionTimeout();\n                }\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "eclipse.platform.ui",
    "cve_id": "CVE-2023-4218",
    "cwe_list": [
      "CWE-611"
    ],
    "commit_hash": "f243cf0a28785b89b7c50bf4e1cce48a917d89bd",
    "short_hash": "f243cf0a",
    "vulnerableMethods_before": [
      {
        "filename": "TemplateReaderWriter.java",
        "method_name": "bundles/org.eclipse.jface.text/src/org/eclipse/jface/text/templates/persistence/TemplateReaderWriter.java#read",
        "raw_code": "private TemplatePersistenceData[] read(InputSource source, ResourceBundle bundle, String singleId) throws IOException {\n\t\ttry {\n\t\t\tCollection<TemplatePersistenceData> templates= new ArrayList<>();\n\t\t\tSet<String> ids= new HashSet<>();\n\n\t\t\tDocumentBuilderFactory factory= DocumentBuilderFactory.newInstance();\n\t\t\tDocumentBuilder parser= factory.newDocumentBuilder();\n\t\t\tparser.setErrorHandler(new DefaultHandler());\n\t\t\tDocument document= parser.parse(source);\n\n\t\t\tNodeList elements= document.getElementsByTagName(TEMPLATE_ELEMENT);\n\n\t\t\tint count= elements.getLength();\n\t\t\tfor (int i= 0; i != count; i++) {\n\t\t\t\tNode node= elements.item(i);\n\t\t\t\tNamedNodeMap attributes= node.getAttributes();\n\n\t\t\t\tif (attributes == null)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tString id= getStringValue(attributes, ID_ATTRIBUTE, null);\n\t\t\t\tif (id != null && ids.contains(id)) {\n\t\t\t\t\tString PLUGIN_ID= \"org.eclipse.jface.text\"; //$NON-NLS-1$\n\t\t\t\t\tILog log= ILog.of(Platform.getBundle(PLUGIN_ID));\n\t\t\t\t\tString message= NLS.bind(TextTemplateMessages.getString(\"TemplateReaderWriter.duplicate.id\"), id); //$NON-NLS-1$\n\t\t\t\t\tlog.log(new Status(IStatus.WARNING, PLUGIN_ID, IStatus.OK, message, null));\n\t\t\t\t} else {\n\t\t\t\t\tids.add(id);\n\t\t\t\t}\n\n\t\t\t\tif (singleId != null && !singleId.equals(id))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tboolean deleted = getBooleanValue(attributes, DELETED_ATTRIBUTE, false);\n\n\t\t\t\tString name= getStringValue(attributes, NAME_ATTRIBUTE);\n\t\t\t\tname= translateString(name, bundle);\n\n\t\t\t\tString description= getStringValue(attributes, DESCRIPTION_ATTRIBUTE, \"\"); //$NON-NLS-1$\n\t\t\t\tdescription= translateString(description, bundle);\n\n\t\t\t\tString context= getStringValue(attributes, CONTEXT_ATTRIBUTE);\n\n\t\t\t\tif (name == null || context == null)\n\t\t\t\t\tthrow new IOException(TextTemplateMessages.getString(\"TemplateReaderWriter.error.missing_attribute\")); //$NON-NLS-1$\n\n\t\t\t\tboolean enabled = getBooleanValue(attributes, ENABLED_ATTRIBUTE, true);\n\t\t\t\tboolean autoInsertable= getBooleanValue(attributes, AUTO_INSERTABLE_ATTRIBUTE, true);\n\n\t\t\t\tStringBuilder buffer= new StringBuilder();\n\t\t\t\tNodeList children= node.getChildNodes();\n\t\t\t\tfor (int j= 0; j != children.getLength(); j++) {\n\t\t\t\t\tString value= children.item(j).getNodeValue();\n\t\t\t\t\tif (value != null)\n\t\t\t\t\t\tbuffer.append(value);\n\t\t\t\t}\n\t\t\t\tString pattern= buffer.toString();\n\t\t\t\tpattern= translateString(pattern, bundle);\n\n\t\t\t\tTemplate template= new Template(name, description, context, pattern, autoInsertable);\n\t\t\t\tTemplatePersistenceData data= new TemplatePersistenceData(template, enabled, id);\n\t\t\t\tdata.setDeleted(deleted);\n\n\t\t\t\ttemplates.add(data);\n\n\t\t\t\tif (singleId != null && singleId.equals(id))\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn templates.toArray(new TemplatePersistenceData[templates.size()]);\n\n\t\t} catch (ParserConfigurationException e) {\n\t\t\tAssert.isTrue(false);\n\t\t} catch (SAXException e) {\n\t\t\tthrow (IOException)new IOException(\"Could not read template file\").initCause(e); //$NON-NLS-1$\n\t\t}\n\n\t\treturn null; // dummy\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "TemplateReaderWriter.java",
        "method_name": "bundles/org.eclipse.jface.text/src/org/eclipse/jface/text/templates/persistence/TemplateReaderWriter.java#read",
        "raw_code": "private TemplatePersistenceData[] read(InputSource source, ResourceBundle bundle, String singleId) throws IOException {\n\t\ttry {\n\t\t\tCollection<TemplatePersistenceData> templates= new ArrayList<>();\n\t\t\tSet<String> ids= new HashSet<>();\n\n\t\t\t@SuppressWarnings(\"restriction\")\n\t\t\tDocumentBuilder parser= org.eclipse.core.internal.runtime.XmlProcessorFactory.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tparser.setErrorHandler(new DefaultHandler());\n\t\t\tDocument document= parser.parse(source);\n\n\t\t\tNodeList elements= document.getElementsByTagName(TEMPLATE_ELEMENT);\n\n\t\t\tint count= elements.getLength();\n\t\t\tfor (int i= 0; i != count; i++) {\n\t\t\t\tNode node= elements.item(i);\n\t\t\t\tNamedNodeMap attributes= node.getAttributes();\n\n\t\t\t\tif (attributes == null)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tString id= getStringValue(attributes, ID_ATTRIBUTE, null);\n\t\t\t\tif (id != null && ids.contains(id)) {\n\t\t\t\t\tString PLUGIN_ID= \"org.eclipse.jface.text\"; //$NON-NLS-1$\n\t\t\t\t\tILog log= ILog.of(Platform.getBundle(PLUGIN_ID));\n\t\t\t\t\tString message= NLS.bind(TextTemplateMessages.getString(\"TemplateReaderWriter.duplicate.id\"), id); //$NON-NLS-1$\n\t\t\t\t\tlog.log(new Status(IStatus.WARNING, PLUGIN_ID, IStatus.OK, message, null));\n\t\t\t\t} else {\n\t\t\t\t\tids.add(id);\n\t\t\t\t}\n\n\t\t\t\tif (singleId != null && !singleId.equals(id))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tboolean deleted = getBooleanValue(attributes, DELETED_ATTRIBUTE, false);\n\n\t\t\t\tString name= getStringValue(attributes, NAME_ATTRIBUTE);\n\t\t\t\tname= translateString(name, bundle);\n\n\t\t\t\tString description= getStringValue(attributes, DESCRIPTION_ATTRIBUTE, \"\"); //$NON-NLS-1$\n\t\t\t\tdescription= translateString(description, bundle);\n\n\t\t\t\tString context= getStringValue(attributes, CONTEXT_ATTRIBUTE);\n\n\t\t\t\tif (name == null || context == null)\n\t\t\t\t\tthrow new IOException(TextTemplateMessages.getString(\"TemplateReaderWriter.error.missing_attribute\")); //$NON-NLS-1$\n\n\t\t\t\tboolean enabled = getBooleanValue(attributes, ENABLED_ATTRIBUTE, true);\n\t\t\t\tboolean autoInsertable= getBooleanValue(attributes, AUTO_INSERTABLE_ATTRIBUTE, true);\n\n\t\t\t\tStringBuilder buffer= new StringBuilder();\n\t\t\t\tNodeList children= node.getChildNodes();\n\t\t\t\tfor (int j= 0; j != children.getLength(); j++) {\n\t\t\t\t\tString value= children.item(j).getNodeValue();\n\t\t\t\t\tif (value != null)\n\t\t\t\t\t\tbuffer.append(value);\n\t\t\t\t}\n\t\t\t\tString pattern= buffer.toString();\n\t\t\t\tpattern= translateString(pattern, bundle);\n\n\t\t\t\tTemplate template= new Template(name, description, context, pattern, autoInsertable);\n\t\t\t\tTemplatePersistenceData data= new TemplatePersistenceData(template, enabled, id);\n\t\t\t\tdata.setDeleted(deleted);\n\n\t\t\t\ttemplates.add(data);\n\n\t\t\t\tif (singleId != null && singleId.equals(id))\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn templates.toArray(new TemplatePersistenceData[templates.size()]);\n\n\t\t} catch (ParserConfigurationException e) {\n\t\t\tAssert.isTrue(false);\n\t\t} catch (SAXException e) {\n\t\t\tthrow (IOException)new IOException(\"Could not read template file\").initCause(e); //$NON-NLS-1$\n\t\t}\n\n\t\treturn null; // dummy\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "shopizer",
    "cve_id": "CVE-2022-23061",
    "cwe_list": [
      "CWE-639"
    ],
    "commit_hash": "6b9f1ecd303b3b724d96bd08095c1a751dcc287e",
    "short_hash": "6b9f1ecd",
    "vulnerableMethods_before": [
      {
        "filename": "CustomerFacadeImpl.java",
        "method_name": "sm-shop/src/main/java/com/salesmanager/shop/store/controller/customer/facade/CustomerFacadeImpl.java#setCustomerModelDefaultProperties",
        "raw_code": "@Override\n  public void setCustomerModelDefaultProperties(Customer customer, MerchantStore store)\n      throws Exception {\n    Validate.notNull(customer, \"Customer object cannot be null\");\n    if (customer.getId() == null || customer.getId() == 0) {\n      if (StringUtils.isBlank(customer.getNick())) {\n        String userName = UserReset.generateRandomString(USERNAME_LENGTH);\n        customer.setNick(userName);\n      }\n      if (StringUtils.isBlank(customer.getPassword())) {\n        String password = UserReset.generateRandomString();\n        String encodedPassword = passwordEncoder.encode(password);\n        customer.setPassword(encodedPassword);\n      }\n    }\n\n    if (CollectionUtils.isEmpty(customer.getGroups())) {\n      List<Group> groups = getListOfGroups(GroupType.CUSTOMER);\n      for (Group group : groups) {\n        if (group.getGroupName().equals(Constants.GROUP_CUSTOMER)) {\n          customer.getGroups().add(group);\n        }\n      }\n\n    }\n\n  }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "CustomerFacadeImpl.java",
        "method_name": "sm-shop/src/main/java/com/salesmanager/shop/store/controller/customer/facade/CustomerFacadeImpl.java#setCustomerModelDefaultProperties",
        "raw_code": "@Override\n  public void setCustomerModelDefaultProperties(Customer customer, MerchantStore store)\n      throws Exception {\n    Validate.notNull(customer, \"Customer object cannot be null\");\n    if (customer.getId() == null || customer.getId() == 0) {\n      if (StringUtils.isBlank(customer.getNick())) {\n        String userName = \"test@shopizer.com\";\n        customer.setNick(userName);\n      }\n      if (StringUtils.isBlank(customer.getPassword())) {\n        String password = new String(UUID.generateRandomBytes());\n        String encodedPassword = passwordEncoder.encode(password);\n        customer.setPassword(encodedPassword);\n      }\n    }\n\n    if (CollectionUtils.isEmpty(customer.getGroups())) {\n      List<Group> groups = getListOfGroups(GroupType.CUSTOMER);\n      for (Group group : groups) {\n        if (group.getGroupName().equals(Constants.GROUP_CUSTOMER)) {\n          customer.getGroups().add(group);\n        }\n      }\n\n    }\n\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "eclipse.jdt.core",
    "cve_id": "CVE-2023-4218",
    "cwe_list": [
      "CWE-611"
    ],
    "commit_hash": "38dd2a878f45cdb3d8d52090f1d6d1b532fd4c4d",
    "short_hash": "38dd2a87",
    "vulnerableMethods_before": [
      {
        "filename": "JavaProject.java",
        "method_name": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/IJavaProject.java#decodeClasspathEntry",
        "raw_code": "@Override\n\tpublic IClasspathEntry decodeClasspathEntry(String encodedEntry) {\n\n\t\ttry {\n\t\t\tif (encodedEntry == null) return null;\n\t\t\tStringReader reader = new StringReader(encodedEntry);\n\t\t\tElement node;\n\n\t\t\ttry {\n\t\t\t\tDocumentBuilder parser =\n\t\t\t\t\tDocumentBuilderFactory.newInstance().newDocumentBuilder();\n\t\t\t\tnode = parser.parse(new InputSource(reader)).getDocumentElement();\n\t\t\t} catch (SAXException | ParserConfigurationException e) {\n\t\t\t\treturn null;\n\t\t\t} finally {\n\t\t\t\treader.close();\n\t\t\t}\n\n\t\t\tif (!node.getNodeName().equalsIgnoreCase(ClasspathEntry.TAG_CLASSPATHENTRY)\n\t\t\t\t\t|| node.getNodeType() != Node.ELEMENT_NODE) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn ClasspathEntry.elementDecode(node, this, null/*not interested in unknown elements*/);\n\t\t} catch (IOException e) {\n\t\t\t// bad format\n\t\t\treturn null;\n\t\t}\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "JavaProject.java",
        "method_name": "org.eclipse.jdt.core/model/org/eclipse/jdt/core/IJavaProject.java#decodeClasspathEntry",
        "raw_code": "@Override\n\tpublic IClasspathEntry decodeClasspathEntry(String encodedEntry) {\n\n\t\ttry {\n\t\t\tif (encodedEntry == null) return null;\n\t\t\tStringReader reader = new StringReader(encodedEntry);\n\t\t\tElement node;\n\n\t\t\ttry {\n\t\t\t\t@SuppressWarnings(\"restriction\")\n\t\t\t\tDocumentBuilder parser =\n\t\t\t\t\t\torg.eclipse.core.internal.runtime.XmlProcessorFactory.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\t\tnode = parser.parse(new InputSource(reader)).getDocumentElement();\n\t\t\t} catch (SAXException | ParserConfigurationException e) {\n\t\t\t\treturn null;\n\t\t\t} finally {\n\t\t\t\treader.close();\n\t\t\t}\n\n\t\t\tif (!node.getNodeName().equalsIgnoreCase(ClasspathEntry.TAG_CLASSPATHENTRY)\n\t\t\t\t\t|| node.getNodeType() != Node.ELEMENT_NODE) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn ClasspathEntry.elementDecode(node, this, null/*not interested in unknown elements*/);\n\t\t} catch (IOException e) {\n\t\t\t// bad format\n\t\t\treturn null;\n\t\t}\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "pf4j",
    "cve_id": "CVE-2023-40828",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "8e0aa198c4e652cfc1eb9e05ca9b64397f67cc72",
    "short_hash": "8e0aa198",
    "vulnerableMethods_before": [],
    "vulnerableMethods_after": [
      {
        "filename": "Unzip.java",
        "method_name": "pf4j/src/main/java/org/pf4j/util/Unzip.java#extract",
        "raw_code": "public void extract() throws IOException {\n        log.debug(\"Extract content of '{}' to '{}'\", source, destination);\n\n        // delete destination directory if exists\n        if (destination.exists() && destination.isDirectory()) {\n            FileUtils.delete(destination.toPath());\n        }\n\n        String destinationCanonicalPath = destination.getCanonicalPath();\n        try (ZipInputStream zipInputStream = new ZipInputStream(new FileInputStream(source))) {\n            ZipEntry zipEntry;\n            while ((zipEntry = zipInputStream.getNextEntry()) != null) {\n                File file = new File(destination, zipEntry.getName());\n\n                String fileCanonicalPath = file.getCanonicalPath();\n                if (!fileCanonicalPath.startsWith(destinationCanonicalPath)) {\n                    throw new ZipException(\"The file \"+ zipEntry.getName() + \" is trying to leave the target output directory of \"+ destination);\n                }\n\n                // create intermediary directories - sometimes zip don't add them\n                File dir = new File(file.getParent());\n\n                mkdirsOrThrow(dir);\n\n                if (zipEntry.isDirectory()) {\n                    mkdirsOrThrow(file);\n                } else {\n                    byte[] buffer = new byte[1024];\n                    int length;\n                    try (FileOutputStream fos = new FileOutputStream(file)) {\n                        while ((length = zipInputStream.read(buffer)) >= 0) {\n                            fos.write(buffer, 0, length);\n                        }\n                    }\n                }\n            }\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "snappy-java",
    "cve_id": "CVE-2023-34455",
    "cwe_list": [
      "CWE-770"
    ],
    "commit_hash": "3bf67857fcf70d9eea56eed4af7c925671e8eaea",
    "short_hash": "3bf67857",
    "vulnerableMethods_before": [],
    "vulnerableMethods_after": [
      {
        "filename": "SnappyInputStream.java",
        "method_name": "src/main/java/org/xerial/snappy/SnappyInputStream.java#hasNextChunk",
        "raw_code": "protected boolean hasNextChunk()\n            throws IOException\n    {\n        if (finishedReading) {\n            return false;\n        }\n\n        uncompressedCursor = 0;\n        uncompressedLimit = 0;\n\n        int readBytes = readNext(header, 0, 4);\n        if (readBytes < 4) {\n            return false;\n        }\n\n        int chunkSize = SnappyOutputStream.readInt(header, 0);\n        if (chunkSize == SnappyCodec.MAGIC_HEADER_HEAD) {\n            // Concatenated data\n            int remainingHeaderSize = SnappyCodec.headerSize() - 4;\n            readBytes = readNext(header, 4, remainingHeaderSize);\n            if(readBytes < remainingHeaderSize) {\n                throw new SnappyIOException(SnappyErrorCode.FAILED_TO_UNCOMPRESS, String.format(\"Insufficient header size in a concatenated block\"));\n            }\n\n            if (isValidHeader(header)) {\n                return hasNextChunk();\n            }\n            else {\n                return false;\n            }\n        }\n\n        // chunkSize is negative\n        if (chunkSize < 0) {\n            throw new SnappyError(SnappyErrorCode.INVALID_CHUNK_SIZE, \"chunkSize is too big or negative : \" + chunkSize);\n        }\n\n        // extend the compressed data buffer size\n        if (compressed == null || chunkSize > compressed.length) {\n            // chunkSize exceeds limit\n            try {\n                compressed = new byte[chunkSize];\n            }\n            catch (java.lang.OutOfMemoryError e) {\n                throw new SnappyError(SnappyErrorCode.INVALID_CHUNK_SIZE, e.getMessage());\n            }\n        }\n        readBytes = 0;\n        while (readBytes < chunkSize) {\n            int ret = in.read(compressed, readBytes, chunkSize - readBytes);\n            if (ret == -1) {\n                break;\n            }\n            readBytes += ret;\n        }\n        if (readBytes < chunkSize) {\n            throw new IOException(\"failed to read chunk\");\n        }\n        int uncompressedLength = Snappy.uncompressedLength(compressed, 0, chunkSize);\n        if (uncompressed == null || uncompressedLength > uncompressed.length) {\n            uncompressed = new byte[uncompressedLength];\n        }\n        int actualUncompressedLength = Snappy.uncompress(compressed, 0, chunkSize, uncompressed, 0);\n        if (uncompressedLength != actualUncompressedLength) {\n            throw new SnappyIOException(SnappyErrorCode.INVALID_CHUNK_SIZE, String.format(\"expected %,d bytes, but decompressed chunk has %,d bytes\", uncompressedLength, actualUncompressedLength));\n        }\n        uncompressedLimit = actualUncompressedLength;\n\n        return true;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "junrar",
    "cve_id": "CVE-2022-23596",
    "cwe_list": [
      "CWE-835"
    ],
    "commit_hash": "7b16b3d90b91445fd6af0adfed22c07413d4fab7",
    "short_hash": "7b16b3d9",
    "vulnerableMethods_before": [
      {
        "filename": "Archive.java",
        "method_name": "src/main/java/com/github/junrar/Archive.java#readHeaders",
        "raw_code": "private void readHeaders(final long fileLength) throws IOException, RarException {\n        this.markHead = null;\n        this.newMhd = null;\n        this.headers.clear();\n        this.currentHeaderIndex = 0;\n        int toRead = 0;\n\n        //keep track of positions already processed for\n        //more robustness against corrupt files\n        final Set<Long> processedPositions = new HashSet<>();\n        while (true) {\n            int size = 0;\n            long newpos = 0;\n            RawDataIo rawData = new RawDataIo(channel);\n            final byte[] baseBlockBuffer = safelyAllocate(BaseBlock.BaseBlockSize, MAX_HEADER_SIZE);\n\n            // if header is encrypted,there is a 8-byte salt before each header\n            if (newMhd != null && newMhd.isEncrypted()) {\n                byte[] salt = new byte[8];\n                rawData.readFully(salt, 8);\n                try {\n                    Cipher cipher = Rijndael.buildDecipherer(password, salt);\n                    rawData.setCipher(cipher);\n                } catch (Exception e) {\n                    throw new InitDeciphererFailedException(e);\n                }\n            }\n\n            final long position = this.channel.getPosition();\n\n            // Weird, but is trying to read beyond the end of the file\n            if (position >= fileLength) {\n                break;\n            }\n\n            // logger.info(\"\\n--------reading header--------\");\n            size = rawData.readFully(baseBlockBuffer, baseBlockBuffer.length);\n\n            if (size == 0) {\n                break;\n            }\n            final BaseBlock block = new BaseBlock(baseBlockBuffer);\n\n            block.setPositionInFile(position);\n\n            UnrarHeadertype headerType = block.getHeaderType();\n            if (headerType == null) {\n                logger.warn(\"unknown block header!\");\n                throw new CorruptHeaderException();\n            }\n            switch (headerType) {\n\n                case MarkHeader:\n                    this.markHead = new MarkHeader(block);\n                    if (!this.markHead.isSignature()) {\n                        if (markHead.getVersion() == RARVersion.V5) {\n                            logger.warn(\"Support for rar version 5 is not yet implemented!\");\n                            throw new UnsupportedRarV5Exception();\n                        } else {\n                            throw new BadRarArchiveException();\n                        }\n                    }\n                    this.headers.add(this.markHead);\n                    // markHead.print();\n                    break;\n\n                case MainHeader:\n                    toRead = block.hasEncryptVersion() ? MainHeader.mainHeaderSizeWithEnc\n                        : MainHeader.mainHeaderSize;\n                    final byte[] mainbuff = safelyAllocate(toRead, MAX_HEADER_SIZE);\n                    rawData.readFully(mainbuff, mainbuff.length);\n                    final MainHeader mainhead = new MainHeader(block, mainbuff);\n                    this.headers.add(mainhead);\n                    this.newMhd = mainhead;\n                    break;\n\n                case SignHeader:\n                    toRead = SignHeader.signHeaderSize;\n                    final byte[] signBuff = safelyAllocate(toRead, MAX_HEADER_SIZE);\n                    rawData.readFully(signBuff, signBuff.length);\n                    final SignHeader signHead = new SignHeader(block, signBuff);\n                    this.headers.add(signHead);\n                    break;\n\n                case AvHeader:\n                    toRead = AVHeader.avHeaderSize;\n                    final byte[] avBuff = safelyAllocate(toRead, MAX_HEADER_SIZE);\n                    rawData.readFully(avBuff, avBuff.length);\n                    final AVHeader avHead = new AVHeader(block, avBuff);\n                    this.headers.add(avHead);\n                    break;\n\n                case CommHeader:\n                    toRead = CommentHeader.commentHeaderSize;\n                    final byte[] commBuff = safelyAllocate(toRead, MAX_HEADER_SIZE);\n                    rawData.readFully(commBuff, commBuff.length);\n                    final CommentHeader commHead = new CommentHeader(block, commBuff);\n                    this.headers.add(commHead);\n\n                    newpos = commHead.getPositionInFile() + commHead.getHeaderSize(isEncrypted());\n                    this.channel.setPosition(newpos);\n\n                    if (processedPositions.contains(newpos)) {\n                        throw new BadRarArchiveException();\n                    }\n                    processedPositions.add(newpos);\n\n                    break;\n                case EndArcHeader:\n\n                    toRead = 0;\n                    if (block.hasArchiveDataCRC()) {\n                        toRead += EndArcHeader.endArcArchiveDataCrcSize;\n                    }\n                    if (block.hasVolumeNumber()) {\n                        toRead += EndArcHeader.endArcVolumeNumberSize;\n                    }\n                    EndArcHeader endArcHead;\n                    if (toRead > 0) {\n                        final byte[] endArchBuff = safelyAllocate(toRead, MAX_HEADER_SIZE);\n                        rawData.readFully(endArchBuff, endArchBuff.length);\n                        endArcHead = new EndArcHeader(block, endArchBuff);\n                    } else {\n                        endArcHead = new EndArcHeader(block, null);\n                    }\n                    this.headers.add(endArcHead);\n                    return;\n\n                default:\n                    final byte[] blockHeaderBuffer = safelyAllocate(BlockHeader.blockHeaderSize, MAX_HEADER_SIZE);\n                    rawData.readFully(blockHeaderBuffer, blockHeaderBuffer.length);\n                    final BlockHeader blockHead = new BlockHeader(block,\n                        blockHeaderBuffer);\n\n                    switch (blockHead.getHeaderType()) {\n                        case NewSubHeader:\n                        case FileHeader:\n                            toRead = blockHead.getHeaderSize(false)\n                                - BlockHeader.BaseBlockSize\n                                - BlockHeader.blockHeaderSize;\n                            final byte[] fileHeaderBuffer = safelyAllocate(toRead, MAX_HEADER_SIZE);\n                            rawData.readFully(fileHeaderBuffer, fileHeaderBuffer.length);\n\n                            final FileHeader fh = new FileHeader(blockHead, fileHeaderBuffer);\n                            this.headers.add(fh);\n                            newpos = fh.getPositionInFile() + fh.getHeaderSize(isEncrypted()) + fh.getFullPackSize();\n                            this.channel.setPosition(newpos);\n\n                            if (processedPositions.contains(newpos)) {\n                                throw new BadRarArchiveException();\n                            }\n                            processedPositions.add(newpos);\n                            break;\n\n                        case ProtectHeader:\n                            toRead = blockHead.getHeaderSize(false)\n                                - BlockHeader.BaseBlockSize\n                                - BlockHeader.blockHeaderSize;\n                            final byte[] protectHeaderBuffer = safelyAllocate(toRead, MAX_HEADER_SIZE);\n                            rawData.readFully(protectHeaderBuffer, protectHeaderBuffer.length);\n                            final ProtectHeader ph = new ProtectHeader(blockHead, protectHeaderBuffer);\n                            newpos = ph.getPositionInFile() + ph.getHeaderSize(isEncrypted()) + ph.getDataSize();\n                            this.channel.setPosition(newpos);\n\n                            if (processedPositions.contains(newpos)) {\n                                throw new BadRarArchiveException();\n                            }\n                            processedPositions.add(newpos);\n                            break;\n\n                        case SubHeader: {\n                            final byte[] subHeadbuffer = safelyAllocate(SubBlockHeader.SubBlockHeaderSize, MAX_HEADER_SIZE);\n                            rawData.readFully(subHeadbuffer, subHeadbuffer.length);\n                            final SubBlockHeader subHead = new SubBlockHeader(blockHead,\n                                subHeadbuffer);\n                            subHead.print();\n                            switch (subHead.getSubType()) {\n                                case MAC_HEAD: {\n                                    final byte[] macHeaderbuffer = safelyAllocate(MacInfoHeader.MacInfoHeaderSize, MAX_HEADER_SIZE);\n                                    rawData.readFully(macHeaderbuffer, macHeaderbuffer.length);\n                                    final MacInfoHeader macHeader = new MacInfoHeader(subHead,\n                                        macHeaderbuffer);\n                                    macHeader.print();\n                                    this.headers.add(macHeader);\n\n                                    break;\n                                }\n                                // TODO implement other subheaders\n                                case BEEA_HEAD:\n                                    break;\n                                case EA_HEAD: {\n                                    final byte[] eaHeaderBuffer = safelyAllocate(EAHeader.EAHeaderSize, MAX_HEADER_SIZE);\n                                    rawData.readFully(eaHeaderBuffer, eaHeaderBuffer.length);\n                                    final EAHeader eaHeader = new EAHeader(subHead,\n                                        eaHeaderBuffer);\n                                    eaHeader.print();\n                                    this.headers.add(eaHeader);\n\n                                    break;\n                                }\n                                case NTACL_HEAD:\n                                    break;\n                                case STREAM_HEAD:\n                                    break;\n                                case UO_HEAD:\n                                    toRead = subHead.getHeaderSize(false);\n                                    toRead -= BaseBlock.BaseBlockSize;\n                                    toRead -= BlockHeader.blockHeaderSize;\n                                    toRead -= SubBlockHeader.SubBlockHeaderSize;\n                                    final byte[] uoHeaderBuffer = safelyAllocate(toRead, MAX_HEADER_SIZE);\n                                    rawData.readFully(uoHeaderBuffer, uoHeaderBuffer.length);\n                                    final UnixOwnersHeader uoHeader = new UnixOwnersHeader(\n                                        subHead, uoHeaderBuffer);\n                                    uoHeader.print();\n                                    this.headers.add(uoHeader);\n                                    break;\n                                default:\n                                    break;\n                            }\n\n                            break;\n                        }\n                        default:\n                            logger.warn(\"Unknown Header\");\n                            throw new NotRarArchiveException();\n\n                    }\n            }\n            // logger.info(\"\\n--------end header--------\");\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "Archive.java",
        "method_name": "src/main/java/com/github/junrar/Archive.java#readHeaders",
        "raw_code": "private void readHeaders(final long fileLength) throws IOException, RarException {\n        this.markHead = null;\n        this.newMhd = null;\n        this.headers.clear();\n        this.currentHeaderIndex = 0;\n        int toRead = 0;\n\n        //keep track of positions already processed for\n        //more robustness against corrupt files\n        final Set<Long> processedPositions = new HashSet<>();\n        while (true) {\n            int size = 0;\n            long newpos = 0;\n            RawDataIo rawData = new RawDataIo(channel);\n            final byte[] baseBlockBuffer = safelyAllocate(BaseBlock.BaseBlockSize, MAX_HEADER_SIZE);\n\n            // if header is encrypted,there is a 8-byte salt before each header\n            if (newMhd != null && newMhd.isEncrypted()) {\n                byte[] salt = new byte[8];\n                rawData.readFully(salt, 8);\n                try {\n                    Cipher cipher = Rijndael.buildDecipherer(password, salt);\n                    rawData.setCipher(cipher);\n                } catch (Exception e) {\n                    throw new InitDeciphererFailedException(e);\n                }\n            }\n\n            final long position = this.channel.getPosition();\n\n            // Weird, but is trying to read beyond the end of the file\n            if (position >= fileLength) {\n                break;\n            }\n\n            // logger.info(\"\\n--------reading header--------\");\n            size = rawData.readFully(baseBlockBuffer, baseBlockBuffer.length);\n\n            if (size == 0) {\n                break;\n            }\n            final BaseBlock block = new BaseBlock(baseBlockBuffer);\n\n            block.setPositionInFile(position);\n\n            UnrarHeadertype headerType = block.getHeaderType();\n            if (headerType == null) {\n                logger.warn(\"unknown block header!\");\n                throw new CorruptHeaderException();\n            }\n            switch (headerType) {\n\n                case MarkHeader:\n                    this.markHead = new MarkHeader(block);\n                    if (!this.markHead.isSignature()) {\n                        if (markHead.getVersion() == RARVersion.V5) {\n                            logger.warn(\"Support for rar version 5 is not yet implemented!\");\n                            throw new UnsupportedRarV5Exception();\n                        } else {\n                            throw new BadRarArchiveException();\n                        }\n                    }\n                    this.headers.add(this.markHead);\n                    // markHead.print();\n                    break;\n\n                case MainHeader:\n                    toRead = block.hasEncryptVersion() ? MainHeader.mainHeaderSizeWithEnc\n                        : MainHeader.mainHeaderSize;\n                    final byte[] mainbuff = safelyAllocate(toRead, MAX_HEADER_SIZE);\n                    rawData.readFully(mainbuff, mainbuff.length);\n                    final MainHeader mainhead = new MainHeader(block, mainbuff);\n                    this.headers.add(mainhead);\n                    this.newMhd = mainhead;\n                    break;\n\n                case SignHeader:\n                    toRead = SignHeader.signHeaderSize;\n                    final byte[] signBuff = safelyAllocate(toRead, MAX_HEADER_SIZE);\n                    rawData.readFully(signBuff, signBuff.length);\n                    final SignHeader signHead = new SignHeader(block, signBuff);\n                    this.headers.add(signHead);\n                    break;\n\n                case AvHeader:\n                    toRead = AVHeader.avHeaderSize;\n                    final byte[] avBuff = safelyAllocate(toRead, MAX_HEADER_SIZE);\n                    rawData.readFully(avBuff, avBuff.length);\n                    final AVHeader avHead = new AVHeader(block, avBuff);\n                    this.headers.add(avHead);\n                    break;\n\n                case CommHeader:\n                    toRead = CommentHeader.commentHeaderSize;\n                    final byte[] commBuff = safelyAllocate(toRead, MAX_HEADER_SIZE);\n                    rawData.readFully(commBuff, commBuff.length);\n                    final CommentHeader commHead = new CommentHeader(block, commBuff);\n                    this.headers.add(commHead);\n\n                    newpos = commHead.getPositionInFile() + commHead.getHeaderSize(isEncrypted());\n                    this.channel.setPosition(newpos);\n\n                    if (processedPositions.contains(newpos)) {\n                        throw new BadRarArchiveException();\n                    }\n                    processedPositions.add(newpos);\n\n                    break;\n                case EndArcHeader:\n\n                    toRead = 0;\n                    if (block.hasArchiveDataCRC()) {\n                        toRead += EndArcHeader.endArcArchiveDataCrcSize;\n                    }\n                    if (block.hasVolumeNumber()) {\n                        toRead += EndArcHeader.endArcVolumeNumberSize;\n                    }\n                    EndArcHeader endArcHead;\n                    if (toRead > 0) {\n                        final byte[] endArchBuff = safelyAllocate(toRead, MAX_HEADER_SIZE);\n                        rawData.readFully(endArchBuff, endArchBuff.length);\n                        endArcHead = new EndArcHeader(block, endArchBuff);\n                    } else {\n                        endArcHead = new EndArcHeader(block, null);\n                    }\n                    this.headers.add(endArcHead);\n                    return;\n\n                default:\n                    final byte[] blockHeaderBuffer = safelyAllocate(BlockHeader.blockHeaderSize, MAX_HEADER_SIZE);\n                    rawData.readFully(blockHeaderBuffer, blockHeaderBuffer.length);\n                    final BlockHeader blockHead = new BlockHeader(block,\n                        blockHeaderBuffer);\n\n                    switch (blockHead.getHeaderType()) {\n                        case NewSubHeader:\n                        case FileHeader:\n                            toRead = blockHead.getHeaderSize(false)\n                                - BlockHeader.BaseBlockSize\n                                - BlockHeader.blockHeaderSize;\n                            final byte[] fileHeaderBuffer = safelyAllocate(toRead, MAX_HEADER_SIZE);\n                            rawData.readFully(fileHeaderBuffer, fileHeaderBuffer.length);\n\n                            final FileHeader fh = new FileHeader(blockHead, fileHeaderBuffer);\n                            this.headers.add(fh);\n                            newpos = fh.getPositionInFile() + fh.getHeaderSize(isEncrypted()) + fh.getFullPackSize();\n                            this.channel.setPosition(newpos);\n\n                            if (processedPositions.contains(newpos)) {\n                                throw new BadRarArchiveException();\n                            }\n                            processedPositions.add(newpos);\n                            break;\n\n                        case ProtectHeader:\n                            toRead = blockHead.getHeaderSize(false)\n                                - BlockHeader.BaseBlockSize\n                                - BlockHeader.blockHeaderSize;\n                            final byte[] protectHeaderBuffer = safelyAllocate(toRead, MAX_HEADER_SIZE);\n                            rawData.readFully(protectHeaderBuffer, protectHeaderBuffer.length);\n                            final ProtectHeader ph = new ProtectHeader(blockHead, protectHeaderBuffer);\n                            newpos = ph.getPositionInFile() + ph.getHeaderSize(isEncrypted()) + ph.getDataSize();\n                            this.channel.setPosition(newpos);\n\n                            if (processedPositions.contains(newpos)) {\n                                throw new BadRarArchiveException();\n                            }\n                            processedPositions.add(newpos);\n                            break;\n\n                        case SubHeader: {\n                            final byte[] subHeadbuffer = safelyAllocate(SubBlockHeader.SubBlockHeaderSize, MAX_HEADER_SIZE);\n                            rawData.readFully(subHeadbuffer, subHeadbuffer.length);\n                            final SubBlockHeader subHead = new SubBlockHeader(blockHead,\n                                subHeadbuffer);\n                            subHead.print();\n                            SubBlockHeaderType subType = subHead.getSubType();\n                            if (subType == null) break;\n                            switch (subType) {\n                                case MAC_HEAD: {\n                                    final byte[] macHeaderbuffer = safelyAllocate(MacInfoHeader.MacInfoHeaderSize, MAX_HEADER_SIZE);\n                                    rawData.readFully(macHeaderbuffer, macHeaderbuffer.length);\n                                    final MacInfoHeader macHeader = new MacInfoHeader(subHead,\n                                        macHeaderbuffer);\n                                    macHeader.print();\n                                    this.headers.add(macHeader);\n\n                                    break;\n                                }\n                                // TODO implement other subheaders\n                                case BEEA_HEAD:\n                                    break;\n                                case EA_HEAD: {\n                                    final byte[] eaHeaderBuffer = safelyAllocate(EAHeader.EAHeaderSize, MAX_HEADER_SIZE);\n                                    rawData.readFully(eaHeaderBuffer, eaHeaderBuffer.length);\n                                    final EAHeader eaHeader = new EAHeader(subHead,\n                                        eaHeaderBuffer);\n                                    eaHeader.print();\n                                    this.headers.add(eaHeader);\n\n                                    break;\n                                }\n                                case NTACL_HEAD:\n                                    break;\n                                case STREAM_HEAD:\n                                    break;\n                                case UO_HEAD:\n                                    toRead = subHead.getHeaderSize(false);\n                                    toRead -= BaseBlock.BaseBlockSize;\n                                    toRead -= BlockHeader.blockHeaderSize;\n                                    toRead -= SubBlockHeader.SubBlockHeaderSize;\n                                    final byte[] uoHeaderBuffer = safelyAllocate(toRead, MAX_HEADER_SIZE);\n                                    rawData.readFully(uoHeaderBuffer, uoHeaderBuffer.length);\n                                    final UnixOwnersHeader uoHeader = new UnixOwnersHeader(\n                                        subHead, uoHeaderBuffer);\n                                    uoHeader.print();\n                                    this.headers.add(uoHeader);\n                                    break;\n                                default:\n                                    break;\n                            }\n\n                            break;\n                        }\n                        default:\n                            logger.warn(\"Unknown Header\");\n                            throw new NotRarArchiveException();\n\n                    }\n            }\n            // logger.info(\"\\n--------end header--------\");\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "orientdb",
    "cve_id": "CVE-2015-2913",
    "cwe_list": [
      "CWE-200"
    ],
    "commit_hash": "668ece96be210e742a4e2820a3085b215cf55104",
    "short_hash": "668ece96",
    "vulnerableMethods_before": [
      {
        "filename": "OHttpSessionManager.java",
        "method_name": "server/src/main/java/com/orientechnologies/orient/server/network/protocol/http/OHttpSessionManager.java#removeSession",
        "raw_code": "public OHttpSession removeSession(final String iSessionId) {\n     acquireExclusiveLock();\n     try {\n       return sessions.remove(iSessionId);\n\n     } finally {\n       releaseExclusiveLock();\n     }\n   }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "OHttpSessionManager.java",
        "method_name": "server/src/main/java/com/orientechnologies/orient/server/network/protocol/http/OHttpSessionManager.java#removeSession",
        "raw_code": "public OHttpSession removeSession(final String iSessionId) {\n    acquireExclusiveLock();\n    try {\n      return sessions.remove(iSessionId);\n\n    } finally {\n      releaseExclusiveLock();\n    }\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "jw-community",
    "cve_id": "CVE-2022-4859",
    "cwe_list": [
      "CWE-79"
    ],
    "commit_hash": "9a77f508a2bf8cf661d588f37a4cc29ecaea4fc8",
    "short_hash": "9a77f508",
    "vulnerableMethods_before": [
      {
        "filename": "UserProfileMenu.java",
        "method_name": "wflow-core/src/main/java/org/joget/plugin/enterprise/UserProfileMenu.java#submitForm",
        "raw_code": "private void submitForm() {\n        ApplicationContext ac = AppUtil.getApplicationContext();\n        WorkflowUserManager workflowUserManager = (WorkflowUserManager) ac.getBean(\"workflowUserManager\");\n        UserDao userDao = (UserDao) ac.getBean(\"userDao\");\n        User userObject = userDao.getUser(workflowUserManager.getCurrentUsername());\n        User currentUser = null;\n        if (userObject != null) {\n            currentUser = new User();\n            BeanUtils.copyProperties(userObject, currentUser);\n        }\n        ExtDirectoryManager directoryManager = (ExtDirectoryManager) AppUtil.getApplicationContext().getBean(\"directoryManager\");\n           \n        Collection<String> errors = new ArrayList<String>();\n        Collection<String> passwordErrors = new ArrayList<String>();\n        \n        boolean authenticated = false;\n        if (currentUser != null) {\n            if (!currentUser.getUsername().equals(getRequestParameterString(\"username\"))) {\n                HttpServletRequest request = WorkflowUtil.getHttpServletRequest();\n                if (request != null) {\n                    HttpSession session = request.getSession(false);\n                    if (session != null) {\n                        session.invalidate();\n                        authenticated = false;\n                    }\n                }\n            } else {\n                try {\n                    if (directoryManager.authenticate(currentUser.getUsername(), getRequestParameterString(\"oldPassword\"))) {\n                        authenticated = true;\n                    }\n                } catch (Exception e) { }\n            }\n        }\n        UserSecurity us = DirectoryUtil.getUserSecurity();\n        \n        if (\"\".equals(getPropertyString(\"f_firstName\"))) {\n            currentUser.setFirstName(getRequestParameterString(\"firstName\"));\n        }\n\n        if (\"\".equals(getPropertyString(\"f_lastName\"))) {\n            currentUser.setLastName(getRequestParameterString(\"lastName\"));\n        }\n\n        if (\"\".equals(getPropertyString(\"f_email\"))) {\n            currentUser.setEmail(getRequestParameterString(\"email\"));\n        }\n\n        if (\"\".equals(getPropertyString(\"f_timeZone\"))) {\n            currentUser.setTimeZone(getRequestParameterString(\"timeZone\"));\n        }\n\n        if (\"\".equals(getPropertyString(\"f_locale\"))) {\n            currentUser.setLocale(getRequestParameterString(\"locale\"));\n        }\n\n        if (!authenticated) {\n            if (errors == null) {\n                errors = new ArrayList<String>();\n            }\n            errors.add(ResourceBundleUtil.getMessage(\"console.directory.user.error.label.authenticationFailed\"));\n        } else {\n            if (us != null) {\n                errors = us.validateUserOnProfileUpdate(currentUser);\n            }\n\n            if (getRequestParameterString(\"password\") != null && !getRequestParameterString(\"password\").isEmpty() && us != null) {\n                passwordErrors = us.validatePassword(getRequestParameterString(\"username\"),  getRequestParameterString(\"oldPassword\"), getRequestParameterString(\"password\"), getRequestParameterString(\"confirmPassword\")); \n            }\n        }\n\n        setProperty(\"errors\", errors);\n        if (passwordErrors != null && !passwordErrors.isEmpty()) {\n            setProperty(\"passwordErrors\", passwordErrors);\n        }\n        \n        if (authenticated && (passwordErrors != null && passwordErrors.isEmpty()) && (errors != null && errors.isEmpty())) {\n            if (\"\".equals(getPropertyString(\"f_password\"))) {\n                if (getRequestParameterString(\"password\") != null && getRequestParameterString(\"confirmPassword\") != null && getRequestParameterString(\"password\").length() > 0 && getRequestParameterString(\"password\").equals(getRequestParameterString(\"confirmPassword\"))) {\n                    if (us != null) {\n                        currentUser.setPassword(us.encryptPassword(getRequestParameterString(\"username\"), getRequestParameterString(\"password\")));\n                    } else {\n                        currentUser.setPassword(StringUtil.md5Base16(getRequestParameterString(\"password\")));\n                    }\n                    currentUser.setConfirmPassword(getRequestParameterString(\"password\"));\n                }\n            }\n\n            if (currentUser.getUsername().equals(getRequestParameterString(\"username\"))) {\n                userDao.updateUser(currentUser);\n                if (us != null) {\n                    us.updateUserProfilePostProcessing(currentUser);\n                }\n                \n                setAlertMessage(getPropertyString(\"message\"));\n                setProperty(\"headerTitle\", getPropertyString(\"label\"));\n                if (getPropertyString(\"redirectURL\") != null && !getPropertyString(\"redirectURL\").isEmpty()) {\n                    setProperty(\"view\", \"redirect\");\n                    boolean redirectToParent = \"Yes\".equals(getPropertyString(\"showInPopupDialog\"));\n                    setRedirectUrl(getPropertyString(\"redirectURL\"), redirectToParent);\n                } else {\n                    setProperty(\"saved\", \"true\");\n                    viewForm(null);\n                }\n            }\n        } else {\n            viewForm(currentUser);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "UserProfileMenu.java",
        "method_name": "wflow-core/src/main/java/org/joget/plugin/enterprise/UserProfileMenu.java#submitForm",
        "raw_code": "private void submitForm() {\n        ApplicationContext ac = AppUtil.getApplicationContext();\n        WorkflowUserManager workflowUserManager = (WorkflowUserManager) ac.getBean(\"workflowUserManager\");\n        UserDao userDao = (UserDao) ac.getBean(\"userDao\");\n        User userObject = userDao.getUser(workflowUserManager.getCurrentUsername());\n        User currentUser = null;\n        if (userObject != null) {\n            currentUser = new User();\n            BeanUtils.copyProperties(userObject, currentUser);\n        }\n        ExtDirectoryManager directoryManager = (ExtDirectoryManager) AppUtil.getApplicationContext().getBean(\"directoryManager\");\n           \n        Collection<String> errors = new ArrayList<String>();\n        Collection<String> passwordErrors = new ArrayList<String>();\n        \n        boolean authenticated = false;\n        if (currentUser != null) {\n            if (!currentUser.getUsername().equals(getRequestParameterString(\"username\"))) {\n                HttpServletRequest request = WorkflowUtil.getHttpServletRequest();\n                if (request != null) {\n                    HttpSession session = request.getSession(false);\n                    if (session != null) {\n                        session.invalidate();\n                        authenticated = false;\n                    }\n                }\n            } else {\n                try {\n                    if (directoryManager.authenticate(currentUser.getUsername(), getRequestParameterString(\"oldPassword\"))) {\n                        authenticated = true;\n                    }\n                } catch (Exception e) { }\n            }\n        }\n        UserSecurity us = DirectoryUtil.getUserSecurity();\n        \n        if (\"\".equals(getPropertyString(\"f_firstName\")) && !StringUtil.stripAllHtmlTag(getRequestParameterString(\"firstName\")).isEmpty()) {\n            currentUser.setFirstName(StringUtil.stripAllHtmlTag(getRequestParameterString(\"firstName\")));\n        }\n\n        if (\"\".equals(getPropertyString(\"f_lastName\"))) {\n            currentUser.setLastName(StringUtil.stripAllHtmlTag(getRequestParameterString(\"lastName\")));\n        }\n\n        if (\"\".equals(getPropertyString(\"f_email\"))) {\n            currentUser.setEmail(getRequestParameterString(\"email\"));\n        }\n\n        if (\"\".equals(getPropertyString(\"f_timeZone\"))) {\n            currentUser.setTimeZone(getRequestParameterString(\"timeZone\"));\n        }\n\n        if (\"\".equals(getPropertyString(\"f_locale\"))) {\n            currentUser.setLocale(getRequestParameterString(\"locale\"));\n        }\n\n        if (!authenticated) {\n            if (errors == null) {\n                errors = new ArrayList<String>();\n            }\n            errors.add(ResourceBundleUtil.getMessage(\"console.directory.user.error.label.authenticationFailed\"));\n        } else {\n            if (us != null) {\n                errors = us.validateUserOnProfileUpdate(currentUser);\n            }\n\n            if (getRequestParameterString(\"password\") != null && !getRequestParameterString(\"password\").isEmpty() && us != null) {\n                passwordErrors = us.validatePassword(getRequestParameterString(\"username\"),  getRequestParameterString(\"oldPassword\"), getRequestParameterString(\"password\"), getRequestParameterString(\"confirmPassword\")); \n            }\n        }\n\n        setProperty(\"errors\", errors);\n        if (passwordErrors != null && !passwordErrors.isEmpty()) {\n            setProperty(\"passwordErrors\", passwordErrors);\n        }\n        \n        if (authenticated && (passwordErrors != null && passwordErrors.isEmpty()) && (errors != null && errors.isEmpty())) {\n            if (\"\".equals(getPropertyString(\"f_password\"))) {\n                if (getRequestParameterString(\"password\") != null && getRequestParameterString(\"confirmPassword\") != null && getRequestParameterString(\"password\").length() > 0 && getRequestParameterString(\"password\").equals(getRequestParameterString(\"confirmPassword\"))) {\n                    if (us != null) {\n                        currentUser.setPassword(us.encryptPassword(getRequestParameterString(\"username\"), getRequestParameterString(\"password\")));\n                    } else {\n                        currentUser.setPassword(StringUtil.md5Base16(getRequestParameterString(\"password\")));\n                    }\n                    currentUser.setConfirmPassword(getRequestParameterString(\"password\"));\n                }\n            }\n\n            if (currentUser.getUsername().equals(getRequestParameterString(\"username\"))) {\n                userDao.updateUser(currentUser);\n                if (us != null) {\n                    us.updateUserProfilePostProcessing(currentUser);\n                }\n                \n                setAlertMessage(getPropertyString(\"message\"));\n                setProperty(\"headerTitle\", getPropertyString(\"label\"));\n                if (getPropertyString(\"redirectURL\") != null && !getPropertyString(\"redirectURL\").isEmpty()) {\n                    setProperty(\"view\", \"redirect\");\n                    boolean redirectToParent = \"Yes\".equals(getPropertyString(\"showInPopupDialog\"));\n                    setRedirectUrl(getPropertyString(\"redirectURL\"), redirectToParent);\n                } else {\n                    setProperty(\"saved\", \"true\");\n                    viewForm(null);\n                }\n            }\n        } else {\n            viewForm(currentUser);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "eclipse.jdt.ui",
    "cve_id": "CVE-2023-4218",
    "cwe_list": [
      "CWE-611"
    ],
    "commit_hash": "13675b1f8a74f47de4da89ed0ded6af7c21dfbec",
    "short_hash": "13675b1f",
    "vulnerableMethods_before": [
      {
        "filename": "ProfileStore.java",
        "method_name": "org.eclipse.jdt.ui/ui/org/eclipse/jdt/internal/ui/preferences/formatter/ProfileStore.java#writeProfilesToStream",
        "raw_code": "public static void writeProfilesToStream(Collection<Profile> profiles, OutputStream stream, String encoding, IProfileVersioner profileVersioner) throws CoreException {\n\n\t\ttry {\n\t\t\tfinal DocumentBuilderFactory factory= DocumentBuilderFactory.newInstance();\n\t\t\tfinal DocumentBuilder builder= factory.newDocumentBuilder();\n\t\t\tfinal Document document= builder.newDocument();\n\n\t\t\tfinal Element rootElement = document.createElement(XML_NODE_ROOT);\n\t\t\trootElement.setAttribute(XML_ATTRIBUTE_VERSION, Integer.toString(profileVersioner.getCurrentVersion()));\n\n\t\t\tdocument.appendChild(rootElement);\n\n\t\t\tfor (Profile profile : profiles) {\n\t\t\t\tif (profile.isProfileToSave()) {\n\t\t\t\t\tfinal Element profileElement= createProfileElement(profile, document, profileVersioner);\n\t\t\t\t\trootElement.appendChild(profileElement);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tTransformer transformer=TransformerFactory.newInstance().newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.ENCODING, encoding);\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\t\t\ttransformer.transform(new DOMSource(document), new StreamResult(stream));\n\t\t} catch (TransformerException | ParserConfigurationException e) {\n\t\t\tthrow createException(e, FormatterMessages.CodingStyleConfigurationBlock_error_serializing_xml_message);\n\t\t}\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ProfileStore.java",
        "method_name": "org.eclipse.jdt.ui/ui/org/eclipse/jdt/internal/ui/preferences/formatter/ProfileStore.java#writeProfilesToStream",
        "raw_code": "public static void writeProfilesToStream(Collection<Profile> profiles, OutputStream stream, String encoding, IProfileVersioner profileVersioner) throws CoreException {\n\n\t\ttry {\n\t\t\tfinal DocumentBuilderFactory factory= XmlProcessorFactoryJdtUi.createDocumentBuilderFactoryWithErrorOnDOCTYPE();\n\t\t\tfinal DocumentBuilder builder= factory.newDocumentBuilder();\n\t\t\tfinal Document document= builder.newDocument();\n\n\t\t\tfinal Element rootElement = document.createElement(XML_NODE_ROOT);\n\t\t\trootElement.setAttribute(XML_ATTRIBUTE_VERSION, Integer.toString(profileVersioner.getCurrentVersion()));\n\n\t\t\tdocument.appendChild(rootElement);\n\n\t\t\tfor (Profile profile : profiles) {\n\t\t\t\tif (profile.isProfileToSave()) {\n\t\t\t\t\tfinal Element profileElement= createProfileElement(profile, document, profileVersioner);\n\t\t\t\t\trootElement.appendChild(profileElement);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tTransformer transformer= XmlProcessorFactoryJdtUi.createTransformerFactoryWithErrorOnDOCTYPE().newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys.METHOD, \"xml\"); //$NON-NLS-1$\n\t\t\ttransformer.setOutputProperty(OutputKeys.ENCODING, encoding);\n\t\t\ttransformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); //$NON-NLS-1$\n\t\t\ttransformer.transform(new DOMSource(document), new StreamResult(stream));\n\t\t} catch (TransformerException | ParserConfigurationException e) {\n\t\t\tthrow createException(e, FormatterMessages.CodingStyleConfigurationBlock_error_serializing_xml_message);\n\t\t}\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-46554",
    "cwe_list": [
      "CWE-862"
    ],
    "commit_hash": "37ecea84fdd053c33733c2ae9a0778bf98eae608",
    "short_hash": "37ecea84",
    "vulnerableMethods_before": [
      {
        "filename": "ComponentAnnotationLoader.java",
        "method_name": "initialize",
        "raw_code": "public void initialize(ComponentManager manager, ClassLoader classLoader)\n    {\n        try {\n            // 1) Find all components by retrieving the list defined in COMPONENT_LIST. Also find all component\n            // overrides (i.e. the list of components that should take precedence when several are registered\n            // with the same role/hint.\n            List<String> componentClassNames = getDeclaredComponents(classLoader, COMPONENT_LIST);\n            List<String> componentOverrideClassNames = getDeclaredComponents(classLoader, COMPONENT_OVERRIDE_LIST);\n\n            // 2) For each component class name found, load its class and use introspection to find the necessary\n            // annotations required to create a Component Descriptor.\n            Map<RoleHint, ComponentDescriptor> descriptorMap = new HashMap<RoleHint, ComponentDescriptor>();\n            for (String componentClassName : componentClassNames) {\n                Class< ? > componentClass = classLoader.loadClass(componentClassName);\n\n                // Look for ComponentRole annotations and register one component per ComponentRole found\n                for (Class< ? > componentRoleClass : findComponentRoleClasses(componentClass)) {\n                    for (ComponentDescriptor descriptor : factory.createComponentDescriptors(componentClass,\n                        componentRoleClass)) {\n                        // If there's already a existing role/hint in the list of descriptors then decide which one\n                        // to keep by looking at the override list. Use those in the override list in priority.\n                        // Otherwise use the last registered component.\n                        RoleHint roleHint = new RoleHint(componentRoleClass, descriptor.getRoleHint());\n                        if (descriptorMap.containsKey(roleHint)) {\n                            // Is the component in the override list?\n                            ComponentDescriptor existingDescriptor = descriptorMap.get(roleHint);\n                            if (!componentOverrideClassNames.contains(existingDescriptor.getImplementation())) {\n                                descriptorMap.put(new RoleHint(componentRoleClass, descriptor.getRoleHint()),\n                                    descriptor);\n\n                                if (!componentOverrideClassNames.contains(descriptor.getImplementation())) {\n                                    getLogger().warn(\n                                        \"Component [\" + existingDescriptor.getImplementation().getName()\n                                            + \"] is being overwritten by component [\"\n                                            + descriptor.getImplementation().getName()\n                                            + \"]. It will not be possible to look it up.\");\n                                }\n                            }\n                        } else {\n                            descriptorMap.put(new RoleHint(componentRoleClass, descriptor.getRoleHint()), descriptor);\n                        }\n                    }\n                }\n            }\n\n            // 3) Activate all component descriptors\n            for (ComponentDescriptor descriptor : descriptorMap.values()) {\n                manager.registerComponent(descriptor);\n            }\n\n        } catch (Exception e) {\n            // Make sure we make the calling code fail in order to fail fast and prevent the application to start\n            // if something is amiss.\n            throw new RuntimeException(\"Failed to dynamically load components with annotations\", e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ComponentAnnotationLoader.java",
        "method_name": "initialize",
        "raw_code": "public void initialize(ComponentManager manager, ClassLoader classLoader)\n    {\n        try {\n            // 1) Find all components by retrieving the list defined in COMPONENT_LIST. Also find all component\n            // overrides (i.e. the list of components that should take precedence when several are registered\n            // with the same role/hint.\n            List<String> componentClassNames = getDeclaredComponents(classLoader, COMPONENT_LIST);\n            List<String> componentOverrideClassNames = getDeclaredComponents(classLoader, COMPONENT_OVERRIDE_LIST);\n\n            // 2) For each component class name found, load its class and use introspection to find the necessary\n            // annotations required to create a Component Descriptor.\n            Map<RoleHint, ComponentDescriptor> descriptorMap = new HashMap<RoleHint, ComponentDescriptor>();\n            for (String componentClassName : componentClassNames) {\n                Class< ? > componentClass = classLoader.loadClass(componentClassName);\n\n                // Look for ComponentRole annotations and register one component per ComponentRole found\n                for (Class< ? > componentRoleClass : findComponentRoleClasses(componentClass)) {\n                    for (ComponentDescriptor descriptor : factory.createComponentDescriptors(componentClass,\n                        componentRoleClass)) {\n                        // If there's already a existing role/hint in the list of descriptors then decide which one\n                        // to keep by looking at the override list. Use those in the override list in priority.\n                        // Otherwise use the last registered component.\n                        RoleHint roleHint = new RoleHint(componentRoleClass, descriptor.getRoleHint());\n                        if (descriptorMap.containsKey(roleHint)) {\n                            // Is the component in the override list?\n                            ComponentDescriptor existingDescriptor = descriptorMap.get(roleHint);\n                            if (!componentOverrideClassNames.contains(existingDescriptor.getImplementation().getName())) {\n                                descriptorMap.put(new RoleHint(componentRoleClass, descriptor.getRoleHint()),\n                                    descriptor);\n\n                                if (!componentOverrideClassNames.contains(descriptor.getImplementation().getName())) {\n                                    getLogger().warn(\n                                        \"Component [\" + existingDescriptor.getImplementation().getName()\n                                            + \"] is being overwritten by component [\"\n                                            + descriptor.getImplementation().getName()\n                                            + \"]. It will not be possible to look it up.\");\n                                }\n                            }\n                        } else {\n                            descriptorMap.put(new RoleHint(componentRoleClass, descriptor.getRoleHint()), descriptor);\n                        }\n                    }\n                }\n            }\n\n            // 3) Activate all component descriptors\n            for (ComponentDescriptor descriptor : descriptorMap.values()) {\n                manager.registerComponent(descriptor);\n            }\n\n        } catch (Exception e) {\n            // Make sure we make the calling code fail in order to fail fast and prevent the application to start\n            // if something is amiss.\n            throw new RuntimeException(\"Failed to dynamically load components with annotations\", e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "cdt",
    "cve_id": "CVE-2023-4218",
    "cwe_list": [
      "CWE-611"
    ],
    "commit_hash": "c7169b3186d2fef20f97467c3e2ad78e2943ed1b",
    "short_hash": "c7169b31",
    "vulnerableMethods_before": [
      {
        "filename": "SourceUtils.java",
        "method_name": "debug/org.eclipse.cdt.debug.core/src/org/eclipse/cdt/debug/internal/core/sourcelookup/SourceUtils.java#getCommonSourceLocationsMemento",
        "raw_code": "public static String getCommonSourceLocationsMemento(ICSourceLocation[] locations) {\n\t\tDocument document = null;\n\t\tThrowable ex = null;\n\t\ttry {\n\t\t\tdocument = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n\t\t\tElement element = document.createElement(NAME_COMMON_SOURCE_LOCATIONS);\n\t\t\tdocument.appendChild(element);\n\t\t\tsaveSourceLocations(document, element, locations);\n\t\t\treturn CDebugUtils.serializeDocument(document);\n\t\t} catch (ParserConfigurationException e) {\n\t\t\tex = e;\n\t\t} catch (IOException e) {\n\t\t\tex = e;\n\t\t} catch (TransformerException e) {\n\t\t\tex = e;\n\t\t}\n\t\tCDebugCorePlugin.log(new Status(IStatus.ERROR, CDebugCorePlugin.getUniqueIdentifier(), 0,\n\t\t\t\t\"Error saving common source settings.\", ex)); //$NON-NLS-1$\n\t\treturn null;\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SourceUtils.java",
        "method_name": "debug/org.eclipse.cdt.debug.core/src/org/eclipse/cdt/debug/internal/core/sourcelookup/SourceUtils.java#getCommonSourceLocationsMemento",
        "raw_code": "public static String getCommonSourceLocationsMemento(ICSourceLocation[] locations) {\n\t\tDocument document = null;\n\t\tThrowable ex = null;\n\t\ttry {\n\t\t\tdocument = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE().newDocument();\n\t\t\tElement element = document.createElement(NAME_COMMON_SOURCE_LOCATIONS);\n\t\t\tdocument.appendChild(element);\n\t\t\tsaveSourceLocations(document, element, locations);\n\t\t\treturn CDebugUtils.serializeDocument(document);\n\t\t} catch (ParserConfigurationException e) {\n\t\t\tex = e;\n\t\t} catch (IOException e) {\n\t\t\tex = e;\n\t\t} catch (TransformerException e) {\n\t\t\tex = e;\n\t\t}\n\t\tCDebugCorePlugin.log(new Status(IStatus.ERROR, CDebugCorePlugin.getUniqueIdentifier(), 0,\n\t\t\t\t\"Error saving common source settings.\", ex)); //$NON-NLS-1$\n\t\treturn null;\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "nokogiri",
    "cve_id": "CVE-2022-29181",
    "cwe_list": [
      "CWE-843"
    ],
    "commit_hash": "db05ba9a1bd4b90aa6c76742cf6102a7c7297267",
    "short_hash": "db05ba9a",
    "vulnerableMethods_before": [],
    "vulnerableMethods_after": [
      {
        "filename": "ParserContext.java",
        "method_name": "ext/java/nokogiri/Html4SaxParserContext.java#setIOInputSource",
        "raw_code": "public void\n  setIOInputSource(ThreadContext context, IRubyObject data, IRubyObject url)\n  {\n    source = new InputSource();\n    ParserContext.setUrl(context, source, url);\n\n    Ruby ruby = context.getRuntime();\n\n    if (!(data.respondsTo(\"read\"))) {\n      throw ruby.newTypeError(\"must respond to :read\");\n    }\n\n    source.setByteStream(new IOInputStream(data));\n    if (java_encoding != null) {\n      source.setEncoding(java_encoding);\n    }\n  }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "databasir",
    "cve_id": "CVE-2022-24861",
    "cwe_list": [
      "CWE-20"
    ],
    "commit_hash": "ca22a8fef7a31c0235b0b2951260a7819b89993b",
    "short_hash": "ca22a8fe",
    "vulnerableMethods_before": [
      {
        "filename": "CustomDatabaseConnectionFactory.java",
        "method_name": "core/src/main/java/com/databasir/core/infrastructure/connection/CustomDatabaseConnectionFactory.java#getConnection",
        "raw_code": "@Override\n    public Connection getConnection(Context context) throws SQLException {\n        DatabaseTypePojo type = databaseTypeDao.selectByDatabaseType(context.getDatabaseType());\n        File driverFile = driverResources.loadOrDownload(context.getDatabaseType(), type.getJdbcDriverFileUrl());\n        URLClassLoader loader = null;\n        try {\n            loader = new URLClassLoader(\n                    new URL[]{\n                            driverFile.toURI().toURL()\n                    },\n                    this.getClass().getClassLoader()\n            );\n        } catch (MalformedURLException e) {\n            log.error(\"load driver error \" + context, e);\n            throw DomainErrors.CONNECT_DATABASE_FAILED.exception(e.getMessage());\n        }\n        // retrieve the driver class\n\n        Class<?> clazz = null;\n        Driver driver = null;\n        try {\n            clazz = Class.forName(type.getJdbcDriverClassName(), true, loader);\n            driver = (Driver) clazz.getConstructor().newInstance();\n        } catch (ClassNotFoundException e) {\n            log.error(\"init driver error\", e);\n            throw DomainErrors.CONNECT_DATABASE_FAILED.exception(\",  Driver name\" + e.getMessage());\n        } catch (InvocationTargetException\n                 | InstantiationException\n                 | IllegalAccessException\n                 | NoSuchMethodException e) {\n            log.error(\"init driver error\", e);\n            throw DomainErrors.CONNECT_DATABASE_FAILED.exception(\"\" + e.getMessage());\n        }\n\n        String urlPattern = type.getUrlPattern();\n        String jdbcUrl = urlPattern.replace(\"{{jdbc.protocol}}\", type.getJdbcProtocol())\n                .replace(\"{{db.url}}\", context.getUrl())\n                .replace(\"{{db.name}}\", context.getDatabaseName())\n                .replace(\"{{db.schema}}\", context.getSchemaName());\n        Properties info = new Properties();\n        info.put(\"user\", context.getUsername());\n        info.put(\"password\", context.getPassword());\n        return driver.connect(jdbcUrl, info);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "CustomDatabaseConnectionFactory.java",
        "method_name": "core/src/main/java/com/databasir/core/infrastructure/connection/CustomDatabaseConnectionFactory.java#getConnection",
        "raw_code": "@Override\n    public Connection getConnection(Context context) throws SQLException {\n        String databaseType = context.getDatabaseType();\n        DatabaseTypePojo type = databaseTypeDao.selectByDatabaseType(databaseType);\n        File driverFile = driverResources.loadOrDownloadByDatabaseType(databaseType, type.getJdbcDriverFileUrl());\n\n        URLClassLoader loader = null;\n        try {\n            loader = new URLClassLoader(\n                    new URL[]{\n                            driverFile.toURI().toURL()\n                    },\n                    this.getClass().getClassLoader()\n            );\n        } catch (MalformedURLException e) {\n            log.error(\"load driver error \" + context, e);\n            throw DomainErrors.CONNECT_DATABASE_FAILED.exception(e.getMessage());\n        }\n        // retrieve the driver class\n\n        Class<?> clazz = null;\n        Driver driver = null;\n        try {\n            clazz = Class.forName(type.getJdbcDriverClassName(), false, loader);\n            driver = (Driver) clazz.getConstructor().newInstance();\n        } catch (ClassNotFoundException e) {\n            log.error(\"init driver error\", e);\n            throw DomainErrors.CONNECT_DATABASE_FAILED.exception(\", \" + e.getMessage());\n        } catch (InvocationTargetException\n                 | InstantiationException\n                 | IllegalAccessException\n                 | NoSuchMethodException e) {\n            log.error(\"init driver error\", e);\n            throw DomainErrors.CONNECT_DATABASE_FAILED.exception(\"\" + e.getMessage());\n        }\n\n        String urlPattern = type.getUrlPattern();\n        String jdbcUrl = urlPattern.replace(\"{{jdbc.protocol}}\", type.getJdbcProtocol())\n                .replace(\"{{db.url}}\", context.getUrl())\n                .replace(\"{{db.name}}\", context.getDatabaseName())\n                .replace(\"{{db.schema}}\", context.getSchemaName());\n        Properties info = new Properties();\n        info.put(\"user\", context.getUsername());\n        info.put(\"password\", context.getPassword());\n        return driver.connect(jdbcUrl, info);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2023-36470",
    "cwe_list": [
      "CWE-74"
    ],
    "commit_hash": "b0cdfd893912baaa053d106a92e39fa1858843c7",
    "short_hash": "b0cdfd89",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultIconSetLoader.java",
        "method_name": "xwiki-platform-core/xwiki-platform-icon/xwiki-platform-icon-default/src/main/java/org/xwiki/icon/internal/DefaultIconSetLoader.java#loadIconSet",
        "raw_code": "@Override\n    public IconSet loadIconSet(DocumentReference iconSetReference) throws IconException\n    {\n        try {\n            // Get the document\n            DocumentModelBridge doc = documentAccessBridge.getDocumentInstance(iconSetReference);\n            String content = doc.getContent();\n            // The name of the icon set is stored in the IconThemesCode.IconThemeClass XObject of the document\n            DocumentReference iconClassRef = new DocumentReference(wikiDescriptorManager.getCurrentWikiId(),\n                \"IconThemesCode\", \"IconThemeClass\");\n            String name = (String) documentAccessBridge.getProperty(iconSetReference, iconClassRef, \"name\");\n            // Load the icon set\n            return loadIconSet(new StringReader(content), name);\n        } catch (Exception e) {\n            throw new IconException(String.format(ERROR_MSG, iconSetReference), e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultIconSetLoader.java",
        "method_name": "xwiki-platform-core/xwiki-platform-icon/xwiki-platform-icon-default/src/main/java/org/xwiki/icon/internal/DefaultIconSetLoader.java#loadIconSet",
        "raw_code": "@Override\n    public IconSet loadIconSet(DocumentReference iconSetReference) throws IconException\n    {\n        try {\n            // Get the document\n            DocumentModelBridge doc = this.documentAccessBridge.getDocumentInstance(iconSetReference);\n\n            // Check that both the content (actual icon theme content) and the metadata author (icon theme object)\n            // have script right.\n            DocumentReference contentAuthor =\n                this.documentUserSerializer.serialize(doc.getAuthors().getContentAuthor());\n            this.authorizationManager.checkAccess(Right.SCRIPT, contentAuthor, iconSetReference);\n            DocumentReference metadataAuthor =\n                this.documentUserSerializer.serialize(doc.getAuthors().getEffectiveMetadataAuthor());\n            this.authorizationManager.checkAccess(Right.SCRIPT, metadataAuthor, iconSetReference);\n\n            String content = doc.getContent();\n            // The name of the icon set is stored in the IconThemesCode.IconThemeClass XObject of the document\n            DocumentReference iconClassRef = new DocumentReference(this.wikiDescriptorManager.getCurrentWikiId(),\n                \"IconThemesCode\", \"IconThemeClass\");\n            String name = (String) this.documentAccessBridge.getProperty(iconSetReference, iconClassRef, \"name\");\n            // Load the icon set\n            IconSet result = loadIconSet(new StringReader(content), name);\n            result.setSourceDocumentReference(iconSetReference);\n            return result;\n        } catch (Exception e) {\n            throw new IconException(String.format(ERROR_MSG, iconSetReference), e);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "projectforge-webapp",
    "cve_id": "CVE-2013-7251",
    "cwe_list": [
      "CWE-352"
    ],
    "commit_hash": "422de35e3c3141e418a73bfb39b430d5fd74077e",
    "short_hash": "422de35e",
    "vulnerableMethods_before": [
      {
        "filename": "RechnungCostEditTablePanel.java",
        "method_name": "src/main/java/org/projectforge/web/fibu/RechnungCostEditTablePanel.java#onSubmit",
        "raw_code": "@Override\n      protected void onSubmit(final AjaxRequestTarget target, final Form< ? > form)\n      {\n        final KostZuweisungDO zuweisung = addZuweisung(position);\n        final WebMarkupContainer newRow = createRow(rows.newChildId(), position, zuweisung);\n        newRow.setOutputMarkupId(true);\n        final StringBuffer prependJavascriptBuf = new StringBuffer();\n        prependJavascriptBuf.append(WicketAjaxUtils.appendChild(\"costAssignmentBody\", \"tr\", newRow.getMarkupId()));\n        rows.add(newRow);\n        target.add(newRow);\n        ajaxComponents.addTargetComponents(target);\n        target.prependJavaScript(prependJavascriptBuf.toString());\n      }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "RechnungCostEditTablePanel.java",
        "method_name": "src/main/java/org/projectforge/web/fibu/RechnungCostEditTablePanel.java#onSubmit",
        "raw_code": "@Override\n      protected void onSubmit()\n      {\n        super.onSubmit();\n        csrfTokenHandler.onSubmit();\n      }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "s3proxy",
    "cve_id": "CVE-2025-24961",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "86b6ee4749aa163a78e7898efc063617ed171980",
    "short_hash": "86b6ee47",
    "vulnerableMethods_before": [
      {
        "filename": "AbstractNio2BlobStore.java",
        "method_name": "getBlob",
        "raw_code": "@Override\n    public final Blob getBlob(String container, String key, GetOptions options) {\n        if (!containerExists(container)) {\n            throw new ContainerNotFoundException(container, \"\");\n        }\n\n        var path = root.resolve(container).resolve(key);\n        logger.debug(\"Getting blob at: {}\", path);\n\n        try {\n            var isDirectory = Files.isDirectory(path);\n            var attr = Files.readAttributes(path, BasicFileAttributes.class);\n            var view = Files.getFileAttributeView(path, UserDefinedFileAttributeView.class);\n            var attributes = Set.copyOf(view.list());\n            var cacheControl = readStringAttributeIfPresent(view, attributes, XATTR_CACHE_CONTROL);\n            var contentDisposition = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_DISPOSITION);\n            var contentEncoding = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_ENCODING);\n            var contentLanguage = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_LANGUAGE);\n            var contentType = isDirectory ? \"application/x-directory\" :\n                    readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_TYPE);\n            Date expires = null;\n            HashCode hashCode = null;\n            String eTag = null;\n            var tier = Tier.STANDARD;\n            var userMetadata = ImmutableMap.<String, String>builder();\n            var lastModifiedTime = new Date(attr.lastModifiedTime().toMillis());\n            var creationTime = new Date(attr.creationTime().toMillis());\n\n            if (isDirectory) {\n                if (!attributes.contains(XATTR_CONTENT_MD5)) {\n                    // Lacks directory marker -- implicit directory.\n                    return null;\n                }\n            } else if (attributes.contains(XATTR_CONTENT_MD5)) {\n                var buf = ByteBuffer.allocate(view.size(XATTR_CONTENT_MD5));\n                view.read(XATTR_CONTENT_MD5, buf);\n                var etagBytes = buf.array();\n                if (etagBytes.length == 16) {\n                    // regular object\n                    hashCode = HashCode.fromBytes(buf.array());\n                    eTag = \"\\\"\" + hashCode + \"\\\"\";\n                } else {\n                    // multi-part object\n                    eTag = new String(etagBytes, StandardCharsets.US_ASCII);\n                }\n            }\n            if (attributes.contains(XATTR_EXPIRES)) {\n                ByteBuffer buf = ByteBuffer.allocate(view.size(XATTR_EXPIRES));\n                view.read(XATTR_EXPIRES, buf);\n                buf.flip();\n                expires = new Date(buf.asLongBuffer().get());\n            }\n            var tierString = readStringAttributeIfPresent(view, attributes, XATTR_STORAGE_TIER);\n            if (tierString != null) {\n                tier = Tier.valueOf(tierString);\n            }\n            for (String attribute : attributes) {\n                if (!attribute.startsWith(XATTR_USER_METADATA_PREFIX)) {\n                    continue;\n                }\n                var value = readStringAttributeIfPresent(view, attributes, attribute);\n                userMetadata.put(attribute.substring(XATTR_USER_METADATA_PREFIX.length()), value);\n            }\n\n            // Handle range.\n            String contentRange = null;\n            InputStream inputStream;\n            long size;\n            if (isDirectory) {\n                inputStream = ByteSource.empty().openStream();\n                size = 0;\n            } else {\n                inputStream = Files.newInputStream(path);  // TODO: leaky on exception\n                size = attr.size();\n                if (options.getRanges().size() > 0) {\n                    var range = options.getRanges().get(0);\n                    // HTTP uses a closed interval while Java array indexing uses a\n                    // half-open interval.\n                    long offset = 0;\n                    long last = size;\n                    if (range.startsWith(\"-\")) {\n                        offset = last - Long.parseLong(range.substring(1));\n                        if (offset < 0) {\n                            offset = 0;\n                        }\n                    } else if (range.endsWith(\"-\")) {\n                        offset = Long.parseLong(range.substring(0, range.length() - 1));\n                    } else if (range.contains(\"-\")) {\n                        String[] firstLast = range.split(\"\\\\-\", 2);\n                        offset = Long.parseLong(firstLast[0]);\n                        last = Long.parseLong(firstLast[1]);\n                    } else {\n                        throw new HttpResponseException(\"illegal range: \" + range, null, HttpResponse.builder().statusCode(416).build());\n                    }\n\n                    if (offset >= size) {\n                        throw new HttpResponseException(\"illegal range: \" + range, null, HttpResponse.builder().statusCode(416).build());\n                    }\n                    if (last + 1 > size) {\n                        last = size - 1;\n                    }\n                    ByteStreams.skipFully(inputStream, offset);\n                    size = last - offset + 1;\n                    inputStream = ByteStreams.limit(inputStream, size);\n                    contentRange = \"bytes \" + offset + \"-\" + last + \"/\" + attr.size();\n                }\n            }\n\n            if (eTag != null) {\n                eTag = maybeQuoteETag(eTag);\n                if (options.getIfMatch() != null) {\n                    if (!eTag.equals(maybeQuoteETag(options.getIfMatch()))) {\n                        HttpResponse response = HttpResponse.builder().statusCode(Status.PRECONDITION_FAILED.getStatusCode()).addHeader(HttpHeaders.ETAG, eTag).build();\n                        throw new HttpResponseException(new HttpCommand(HttpRequest.builder().method(\"GET\").endpoint(\"http://stub\").build()), response);\n                    }\n                }\n                if (options.getIfNoneMatch() != null) {\n                    if (eTag.equals(maybeQuoteETag(options.getIfNoneMatch()))) {\n                        HttpResponse response = HttpResponse.builder().statusCode(Status.NOT_MODIFIED.getStatusCode()).addHeader(HttpHeaders.ETAG, eTag).build();\n                        throw new HttpResponseException(new HttpCommand(HttpRequest.builder().method(\"GET\").endpoint(\"http://stub\").build()), response);\n                    }\n                }\n            }\n            if (options.getIfModifiedSince() != null) {\n                Date modifiedSince = options.getIfModifiedSince();\n                if (lastModifiedTime.before(modifiedSince)) {\n                    HttpResponse.Builder response = HttpResponse.builder().statusCode(Status.NOT_MODIFIED.getStatusCode());\n                    if (eTag != null) {\n                        response.addHeader(HttpHeaders.ETAG, eTag);\n                    }\n                    throw new HttpResponseException(String.format(\"%1$s is before %2$s\", lastModifiedTime, modifiedSince), null, response.build());\n                }\n\n            }\n            if (options.getIfUnmodifiedSince() != null) {\n                Date unmodifiedSince = options.getIfUnmodifiedSince();\n                if (lastModifiedTime.after(unmodifiedSince)) {\n                    HttpResponse.Builder response = HttpResponse.builder().statusCode(Status.PRECONDITION_FAILED.getStatusCode());\n                    if (eTag != null) {\n                        response.addHeader(HttpHeaders.ETAG, eTag);\n                    }\n                    throw new HttpResponseException(String.format(\"%1$s is after %2$s\", lastModifiedTime, unmodifiedSince), null, response.build());\n                }\n            }\n\n            Blob blob = new BlobBuilderImpl()\n                    .type(isDirectory ? StorageType.FOLDER : StorageType.BLOB)\n                    .name(key)\n                    .userMetadata(userMetadata.build())\n                    .payload(inputStream)\n                    .cacheControl(cacheControl)\n                    .contentDisposition(contentDisposition)\n                    .contentEncoding(contentEncoding)\n                    .contentLanguage(contentLanguage)\n                    .contentLength(size)\n                    .contentMD5(hashCode)\n                    .contentType(contentType)\n                    .eTag(eTag)\n                    .expires(expires)\n                    .tier(tier)\n                    .build();\n            blob.getMetadata().setContainer(container);\n            blob.getMetadata().setCreationDate(creationTime);\n            blob.getMetadata().setLastModified(lastModifiedTime);\n            blob.getMetadata().setSize(size);\n            if (contentRange != null) {\n                blob.getAllHeaders().put(HttpHeaders.CONTENT_RANGE, contentRange);\n            }\n            if (hashCode != null) {\n                blob.getMetadata().setETag(BaseEncoding.base16().lowerCase().encode(hashCode.asBytes()));\n            }\n            return blob;\n        } catch (NoSuchFileException nsfe) {\n            return null;\n        } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AbstractNio2BlobStore.java",
        "method_name": "getBlob",
        "raw_code": "@Override\n    public final Blob getBlob(String container, String key, GetOptions options) {\n        if (!containerExists(container)) {\n            throw new ContainerNotFoundException(container, \"\");\n        }\n\n        var containerPath = root.resolve(container);\n        var path = containerPath.resolve(key);\n        checkValidPath(containerPath, path);\n        logger.debug(\"Getting blob at: {}\", path);\n\n        try {\n            var isDirectory = Files.isDirectory(path);\n            var attr = Files.readAttributes(path, BasicFileAttributes.class);\n            var view = Files.getFileAttributeView(path, UserDefinedFileAttributeView.class);\n            var attributes = Set.copyOf(view.list());\n            var cacheControl = readStringAttributeIfPresent(view, attributes, XATTR_CACHE_CONTROL);\n            var contentDisposition = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_DISPOSITION);\n            var contentEncoding = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_ENCODING);\n            var contentLanguage = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_LANGUAGE);\n            var contentType = isDirectory ? \"application/x-directory\" :\n                    readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_TYPE);\n            Date expires = null;\n            HashCode hashCode = null;\n            String eTag = null;\n            var tier = Tier.STANDARD;\n            var userMetadata = ImmutableMap.<String, String>builder();\n            var lastModifiedTime = new Date(attr.lastModifiedTime().toMillis());\n            var creationTime = new Date(attr.creationTime().toMillis());\n\n            if (isDirectory) {\n                if (!attributes.contains(XATTR_CONTENT_MD5)) {\n                    // Lacks directory marker -- implicit directory.\n                    return null;\n                }\n            } else if (attributes.contains(XATTR_CONTENT_MD5)) {\n                var buf = ByteBuffer.allocate(view.size(XATTR_CONTENT_MD5));\n                view.read(XATTR_CONTENT_MD5, buf);\n                var etagBytes = buf.array();\n                if (etagBytes.length == 16) {\n                    // regular object\n                    hashCode = HashCode.fromBytes(buf.array());\n                    eTag = \"\\\"\" + hashCode + \"\\\"\";\n                } else {\n                    // multi-part object\n                    eTag = new String(etagBytes, StandardCharsets.US_ASCII);\n                }\n            }\n            if (attributes.contains(XATTR_EXPIRES)) {\n                ByteBuffer buf = ByteBuffer.allocate(view.size(XATTR_EXPIRES));\n                view.read(XATTR_EXPIRES, buf);\n                buf.flip();\n                expires = new Date(buf.asLongBuffer().get());\n            }\n            var tierString = readStringAttributeIfPresent(view, attributes, XATTR_STORAGE_TIER);\n            if (tierString != null) {\n                tier = Tier.valueOf(tierString);\n            }\n            for (String attribute : attributes) {\n                if (!attribute.startsWith(XATTR_USER_METADATA_PREFIX)) {\n                    continue;\n                }\n                var value = readStringAttributeIfPresent(view, attributes, attribute);\n                userMetadata.put(attribute.substring(XATTR_USER_METADATA_PREFIX.length()), value);\n            }\n\n            // Handle range.\n            String contentRange = null;\n            InputStream inputStream;\n            long size;\n            if (isDirectory) {\n                inputStream = ByteSource.empty().openStream();\n                size = 0;\n            } else {\n                inputStream = Files.newInputStream(path);  // TODO: leaky on exception\n                size = attr.size();\n                if (options.getRanges().size() > 0) {\n                    var range = options.getRanges().get(0);\n                    // HTTP uses a closed interval while Java array indexing uses a\n                    // half-open interval.\n                    long offset = 0;\n                    long last = size;\n                    if (range.startsWith(\"-\")) {\n                        offset = last - Long.parseLong(range.substring(1));\n                        if (offset < 0) {\n                            offset = 0;\n                        }\n                    } else if (range.endsWith(\"-\")) {\n                        offset = Long.parseLong(range.substring(0, range.length() - 1));\n                    } else if (range.contains(\"-\")) {\n                        String[] firstLast = range.split(\"\\\\-\", 2);\n                        offset = Long.parseLong(firstLast[0]);\n                        last = Long.parseLong(firstLast[1]);\n                    } else {\n                        throw new HttpResponseException(\"illegal range: \" + range, null, HttpResponse.builder().statusCode(416).build());\n                    }\n\n                    if (offset >= size) {\n                        throw new HttpResponseException(\"illegal range: \" + range, null, HttpResponse.builder().statusCode(416).build());\n                    }\n                    if (last + 1 > size) {\n                        last = size - 1;\n                    }\n                    ByteStreams.skipFully(inputStream, offset);\n                    size = last - offset + 1;\n                    inputStream = ByteStreams.limit(inputStream, size);\n                    contentRange = \"bytes \" + offset + \"-\" + last + \"/\" + attr.size();\n                }\n            }\n\n            if (eTag != null) {\n                eTag = maybeQuoteETag(eTag);\n                if (options.getIfMatch() != null) {\n                    if (!eTag.equals(maybeQuoteETag(options.getIfMatch()))) {\n                        HttpResponse response = HttpResponse.builder().statusCode(Status.PRECONDITION_FAILED.getStatusCode()).addHeader(HttpHeaders.ETAG, eTag).build();\n                        throw new HttpResponseException(new HttpCommand(HttpRequest.builder().method(\"GET\").endpoint(\"http://stub\").build()), response);\n                    }\n                }\n                if (options.getIfNoneMatch() != null) {\n                    if (eTag.equals(maybeQuoteETag(options.getIfNoneMatch()))) {\n                        HttpResponse response = HttpResponse.builder().statusCode(Status.NOT_MODIFIED.getStatusCode()).addHeader(HttpHeaders.ETAG, eTag).build();\n                        throw new HttpResponseException(new HttpCommand(HttpRequest.builder().method(\"GET\").endpoint(\"http://stub\").build()), response);\n                    }\n                }\n            }\n            if (options.getIfModifiedSince() != null) {\n                Date modifiedSince = options.getIfModifiedSince();\n                if (lastModifiedTime.before(modifiedSince)) {\n                    HttpResponse.Builder response = HttpResponse.builder().statusCode(Status.NOT_MODIFIED.getStatusCode());\n                    if (eTag != null) {\n                        response.addHeader(HttpHeaders.ETAG, eTag);\n                    }\n                    throw new HttpResponseException(String.format(\"%1$s is before %2$s\", lastModifiedTime, modifiedSince), null, response.build());\n                }\n\n            }\n            if (options.getIfUnmodifiedSince() != null) {\n                Date unmodifiedSince = options.getIfUnmodifiedSince();\n                if (lastModifiedTime.after(unmodifiedSince)) {\n                    HttpResponse.Builder response = HttpResponse.builder().statusCode(Status.PRECONDITION_FAILED.getStatusCode());\n                    if (eTag != null) {\n                        response.addHeader(HttpHeaders.ETAG, eTag);\n                    }\n                    throw new HttpResponseException(String.format(\"%1$s is after %2$s\", lastModifiedTime, unmodifiedSince), null, response.build());\n                }\n            }\n\n            Blob blob = new BlobBuilderImpl()\n                    .type(isDirectory ? StorageType.FOLDER : StorageType.BLOB)\n                    .name(key)\n                    .userMetadata(userMetadata.build())\n                    .payload(inputStream)\n                    .cacheControl(cacheControl)\n                    .contentDisposition(contentDisposition)\n                    .contentEncoding(contentEncoding)\n                    .contentLanguage(contentLanguage)\n                    .contentLength(size)\n                    .contentMD5(hashCode)\n                    .contentType(contentType)\n                    .eTag(eTag)\n                    .expires(expires)\n                    .tier(tier)\n                    .build();\n            blob.getMetadata().setContainer(container);\n            blob.getMetadata().setCreationDate(creationTime);\n            blob.getMetadata().setLastModified(lastModifiedTime);\n            blob.getMetadata().setSize(size);\n            if (contentRange != null) {\n                blob.getAllHeaders().put(HttpHeaders.CONTENT_RANGE, contentRange);\n            }\n            if (hashCode != null) {\n                blob.getMetadata().setETag(BaseEncoding.base16().lowerCase().encode(hashCode.asBytes()));\n            }\n            return blob;\n        } catch (NoSuchFileException nsfe) {\n            return null;\n        } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2024-31981",
    "cwe_list": [
      "CWE-862"
    ],
    "commit_hash": "a4ad14d9c1605a5ab957237e505ebbb29f5b9d73",
    "short_hash": "a4ad14d9",
    "vulnerableMethods_before": [
      {
        "filename": "PdfExportImpl.java",
        "method_name": "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/pdf/impl/PdfExportImpl.java#renderXSLFO",
        "raw_code": "private void renderXSLFO(String xmlfo, OutputStream out, ExportType type, final XWikiContext context)\n        throws XWikiException\n    {\n        try {\n            this.xslFORenderer.render(new ByteArrayInputStream(xmlfo.getBytes(\"UTF-8\")), out, type.getMimeType());\n        } catch (IllegalStateException e) {\n            throw createException(e, type, XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION);\n        } catch (Exception e) {\n            throw createException(e, type, XWikiException.ERROR_XWIKI_EXPORT_PDF_FOP_FAILED);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "PdfExportImpl.java",
        "method_name": "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/pdf/impl/PdfExportImpl.java#renderXSLFO",
        "raw_code": "private void renderXSLFO(String xmlfo, OutputStream out, ExportType type, final XWikiContext context)\n        throws XWikiException\n    {\n        try {\n            this.xslFORenderer.render(new ByteArrayInputStream(xmlfo.getBytes(StandardCharsets.UTF_8)), out, type.getMimeType());\n        } catch (IllegalStateException e) {\n            throw createException(e, type, XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION);\n        } catch (Exception e) {\n            throw createException(e, type, XWikiException.ERROR_XWIKI_EXPORT_PDF_FOP_FAILED);\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2022-23617",
    "cwe_list": [
      "CWE-862"
    ],
    "commit_hash": "30c52b01559b8ef5ed1035dac7c34aaf805764d5",
    "short_hash": "30c52b01",
    "vulnerableMethods_before": [
      {
        "filename": "AdminAction.java",
        "method_name": "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/web/AdminAction.java#render",
        "raw_code": "@Override\n    public String render(XWikiContext context) throws XWikiException\n    {\n        XWikiRequest request = context.getRequest();\n        String content = request.getParameter(\"content\");\n        XWikiDocument doc = context.getDoc();\n        XWikiForm form = context.getForm();\n\n        synchronized (doc) {\n            XWikiDocument tdoc = (XWikiDocument) context.get(\"tdoc\");\n            EditForm peform = (EditForm) form;\n            String parent = peform.getParent();\n            if (parent != null) {\n                doc.setParent(parent);\n            }\n            String creator = peform.getCreator();\n            if (creator != null) {\n                doc.setCreator(creator);\n            }\n            String defaultTemplate = peform.getDefaultTemplate();\n            if (defaultTemplate != null) {\n                doc.setDefaultTemplate(defaultTemplate);\n            }\n            String defaultLanguage = peform.getDefaultLanguage();\n            if ((defaultLanguage != null) && !defaultLanguage.equals(\"\")) {\n                doc.setDefaultLanguage(defaultLanguage);\n            }\n            if (doc.getDefaultLanguage().equals(\"\")) {\n                doc.setDefaultLanguage(context.getWiki().getLanguagePreference(context));\n            }\n\n            String language = context.getWiki().getLanguagePreference(context);\n            String languagefromrequest = context.getRequest().getParameter(\"language\");\n            String languagetoedit =\n                ((languagefromrequest == null) || (languagefromrequest.equals(\"\"))) ? language : languagefromrequest;\n\n            if ((languagetoedit == null) || (languagetoedit.equals(\"default\"))) {\n                languagetoedit = \"\";\n            }\n            if (doc.isNew() || (doc.getDefaultLanguage().equals(languagetoedit))) {\n                languagetoedit = \"\";\n            }\n\n            if (languagetoedit.equals(\"\")) {\n                // In this case the created document is going to be the default document\n                tdoc = doc;\n                context.put(\"tdoc\", doc);\n                if (doc.isNew()) {\n                    doc.setDefaultLanguage(language);\n                    doc.setLanguage(\"\");\n                }\n            } else {\n                // If the translated doc object is the same as the doc object\n                // this means the translated doc did not exists so we need to create it\n                if ((tdoc == doc)) {\n                    tdoc = new XWikiDocument(doc.getDocumentReference());\n                    tdoc.setLanguage(languagetoedit);\n                    tdoc.setContent(doc.getContent());\n                    tdoc.setSyntax(doc.getSyntax());\n                    tdoc.setAuthor(context.getUser());\n                    tdoc.setStore(doc.getStore());\n                    context.put(\"tdoc\", tdoc);\n                }\n            }\n\n            XWikiDocument tdoc2 = tdoc.clone();\n            if (content != null && !content.isEmpty()) {\n                tdoc2.setContent(content);\n            }\n            context.put(\"tdoc\", tdoc2);\n            try {\n                tdoc2.readFromTemplate(peform, context);\n            } catch (XWikiException e) {\n                if (e.getCode() == XWikiException.ERROR_XWIKI_APP_DOCUMENT_NOT_EMPTY) {\n                    context.put(\"exception\", e);\n                    return \"docalreadyexists\";\n                }\n            }\n\n            /* Setup a lock */\n            try {\n                XWikiLock lock = tdoc.getLock(context);\n                if ((lock == null) || (lock.getUserName().equals(context.getUser())) || (peform.isLockForce())) {\n                    tdoc.setLock(context.getUser(), context);\n                }\n            } catch (Exception e) {\n                // Lock should never make XWiki fail\n                // But we should log any related information\n                LOGGER.error(\"Exception while setting up lock\", e);\n            }\n        }\n\n        return \"admin\";\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "AdminAction.java",
        "method_name": "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/web/AdminAction.java#render",
        "raw_code": "@Override\n    public String render(XWikiContext context) throws XWikiException\n    {\n        XWikiRequest request = context.getRequest();\n        String content = request.getParameter(\"content\");\n        XWikiDocument doc = context.getDoc();\n        XWikiForm form = context.getForm();\n\n        synchronized (doc) {\n            XWikiDocument tdoc = (XWikiDocument) context.get(\"tdoc\");\n            EditForm peform = (EditForm) form;\n            String parent = peform.getParent();\n            if (parent != null) {\n                doc.setParent(parent);\n            }\n            String creator = peform.getCreator();\n            if (creator != null) {\n                doc.setCreator(creator);\n            }\n            String defaultTemplate = peform.getDefaultTemplate();\n            if (defaultTemplate != null) {\n                doc.setDefaultTemplate(defaultTemplate);\n            }\n            String defaultLanguage = peform.getDefaultLanguage();\n            if ((defaultLanguage != null) && !defaultLanguage.equals(\"\")) {\n                doc.setDefaultLanguage(defaultLanguage);\n            }\n            if (doc.getDefaultLanguage().equals(\"\")) {\n                doc.setDefaultLanguage(context.getWiki().getLanguagePreference(context));\n            }\n\n            String language = context.getWiki().getLanguagePreference(context);\n            String languagefromrequest = context.getRequest().getParameter(\"language\");\n            String languagetoedit =\n                ((languagefromrequest == null) || (languagefromrequest.equals(\"\"))) ? language : languagefromrequest;\n\n            if ((languagetoedit == null) || (languagetoedit.equals(\"default\"))) {\n                languagetoedit = \"\";\n            }\n            if (doc.isNew() || (doc.getDefaultLanguage().equals(languagetoedit))) {\n                languagetoedit = \"\";\n            }\n\n            if (languagetoedit.equals(\"\")) {\n                // In this case the created document is going to be the default document\n                tdoc = doc;\n                context.put(\"tdoc\", doc);\n                if (doc.isNew()) {\n                    doc.setDefaultLanguage(language);\n                    doc.setLanguage(\"\");\n                }\n            } else {\n                // If the translated doc object is the same as the doc object\n                // this means the translated doc did not exists so we need to create it\n                if ((tdoc == doc)) {\n                    tdoc = new XWikiDocument(doc.getDocumentReference());\n                    tdoc.setLanguage(languagetoedit);\n                    tdoc.setContent(doc.getContent());\n                    tdoc.setSyntax(doc.getSyntax());\n                    tdoc.setAuthor(context.getUser());\n                    tdoc.setStore(doc.getStore());\n                    context.put(\"tdoc\", tdoc);\n                }\n            }\n\n            XWikiDocument tdoc2 = tdoc.clone();\n            if (content != null && !content.isEmpty()) {\n                tdoc2.setContent(content);\n            }\n            context.put(\"tdoc\", tdoc2);\n            try {\n                readFromTemplate(tdoc2, peform.getTemplate(), context);\n            } catch (XWikiException e) {\n                if (e.getCode() == XWikiException.ERROR_XWIKI_APP_DOCUMENT_NOT_EMPTY) {\n                    context.put(\"exception\", e);\n                    return \"docalreadyexists\";\n                }\n            }\n\n            /* Setup a lock */\n            try {\n                XWikiLock lock = tdoc.getLock(context);\n                if ((lock == null) || (lock.getUserName().equals(context.getUser())) || (peform.isLockForce())) {\n                    tdoc.setLock(context.getUser(), context);\n                }\n            } catch (Exception e) {\n                // Lock should never make XWiki fail\n                // But we should log any related information\n                LOGGER.error(\"Exception while setting up lock\", e);\n            }\n        }\n\n        return \"admin\";\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2025-49584",
    "cwe_list": [
      "CWE-201"
    ],
    "commit_hash": "ee642f973a7c95d2d146fe03c81bcdee1871f4ec",
    "short_hash": "ee642f97",
    "vulnerableMethods_before": [
      {
        "filename": "GroupsClassPropertyValuesProvider.java",
        "method_name": "getLabel",
        "raw_code": "@Override\n    protected String getLabel(DocumentReference groupReference, Object currentLabel)\n    {\n        try {\n            XWikiContext xcontext = this.xcontextProvider.get();\n            return xcontext.getWiki().getDocument(groupReference, xcontext).getRenderedTitle(Syntax.PLAIN_1_0,\n                xcontext);\n        } catch (XWikiException e) {\n            this.logger.warn(\"Failed to get the title of group [{}]. Root cause is [{}].\",\n                this.entityReferenceSerializer.serialize(groupReference), ExceptionUtils.getRootCauseMessage(e));\n            return super.getLabel(groupReference, currentLabel);\n        }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "GroupsClassPropertyValuesProvider.java",
        "method_name": "getLabel",
        "raw_code": "@Override\n    protected String getLabel(DocumentReference groupReference, Object currentLabel)\n    {\n        if (this.contextualAuthorizationManager.hasAccess(Right.VIEW, groupReference)) {\n            try {\n                XWikiContext xcontext = this.xcontextProvider.get();\n                return xcontext.getWiki().getDocument(groupReference, xcontext).getRenderedTitle(Syntax.PLAIN_1_0,\n                    xcontext);\n            } catch (XWikiException e) {\n                this.logger.warn(\"Failed to get the title of group [{}]. Root cause is [{}].\",\n                    this.entityReferenceSerializer.serialize(groupReference), ExceptionUtils.getRootCauseMessage(e));\n            }\n        }\n\n        return super.getLabel(groupReference, currentLabel);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "eclipse.platform.ui",
    "cve_id": "CVE-2023-4218",
    "cwe_list": [
      "CWE-611"
    ],
    "commit_hash": "f243cf0a28785b89b7c50bf4e1cce48a917d89bd",
    "short_hash": "f243cf0a",
    "vulnerableMethods_before": [
      {
        "filename": "ListTab.java",
        "method_name": "tools/bundles/org.eclipse.e4.tools.emf.ui/src/org/eclipse/e4/tools/emf/ui/internal/common/component/tabs/ListTab.java#docToString",
        "raw_code": "static private String docToString(Document doc) throws TransformerException {\n\t\tfinal TransformerFactory tf = TransformerFactory.newInstance();\n\t\tfinal Transformer transformer = tf.newTransformer();\n\t\ttransformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, \"yes\"); //$NON-NLS-1$\n\t\tfinal StringWriter writer = new StringWriter();\n\t\ttransformer.transform(new DOMSource(doc), new StreamResult(writer));\n\t\tfinal String output = writer.getBuffer().toString().replaceAll(\"\\n|\\r\", \"\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t\treturn output;\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ListTab.java",
        "method_name": "tools/bundles/org.eclipse.e4.tools.emf.ui/src/org/eclipse/e4/tools/emf/ui/internal/common/component/tabs/ListTab.java#docToString",
        "raw_code": "static private String docToString(Document doc) throws TransformerException {\n\t\t@SuppressWarnings(\"restriction\")\n\t\tfinal TransformerFactory tf = org.eclipse.core.internal.runtime.XmlProcessorFactory\n\t\t\t\t.createTransformerFactoryWithErrorOnDOCTYPE();\n\t\tfinal Transformer transformer = tf.newTransformer();\n\t\ttransformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, \"yes\"); //$NON-NLS-1$\n\t\tfinal StringWriter writer = new StringWriter();\n\t\ttransformer.transform(new DOMSource(doc), new StreamResult(writer));\n\t\tfinal String output = writer.getBuffer().toString().replaceAll(\"\\n|\\r\", \"\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t\treturn output;\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "jmix",
    "cve_id": "CVE-2025-32950",
    "cwe_list": [
      "CWE-35"
    ],
    "commit_hash": "cc97e6ff974b9e7af8160fab39cc5866169daa37",
    "short_hash": "cc97e6ff",
    "vulnerableMethods_before": [
      {
        "filename": "LocalFileStorage.java",
        "method_name": "saveStream",
        "raw_code": "public long saveStream(FileRef fileRef, InputStream inputStream) {\n        Path relativePath = getRelativePath(fileRef.getPath());\n\n        Path[] roots = getStorageRoots();\n\n        // Store to primary storage\n        checkStorageDefined(roots, fileRef.getFileName());\n        checkPrimaryStorageAccessible(roots, fileRef.getFileName());\n\n        Path path = roots[0].resolve(relativePath);\n        Path parentPath = path.getParent();\n        if (parentPath == null) {\n            throw new FileStorageException(FileStorageException.Type.IO_EXCEPTION,\n                    \"Invalid storage root: \" + path);\n        }\n        if (!parentPath.toFile().exists() && !parentPath.toFile().mkdirs()) {\n            throw new FileStorageException(FileStorageException.Type.IO_EXCEPTION,\n                    \"Cannot create directory: \" + parentPath.toAbsolutePath());\n        }\n\n        checkFileExists(path);\n\n        long size;\n        try (OutputStream outputStream = Files.newOutputStream(path, CREATE_NEW)) {\n            size = IOUtils.copyLarge(inputStream, outputStream);\n            outputStream.flush();\n//            writeLog(path, false);\n        } catch (IOException e) {\n            FileUtils.deleteQuietly(path.toFile());\n            throw new FileStorageException(FileStorageException.Type.IO_EXCEPTION, path.toAbsolutePath().toString(), e);\n        }\n\n        // Copy file to secondary storages asynchronously\n        for (int i = 1; i < roots.length; i++) {\n            if (!roots[i].toFile().exists()) {\n                log.error(\"Error saving {} into {} : directory doesn't exist\", fileRef.getFileName(), roots[i]);\n                continue;\n            }\n\n            Path pathCopy = roots[i].resolve(relativePath);\n\n            writeExecutor.submit(() -> {\n                try {\n                    FileUtils.copyFile(path.toFile(), pathCopy.toFile(), true);\n                } catch (Exception e) {\n                    log.error(\"Error saving {} into {} : {}\", fileRef.getFileName(), pathCopy, e.getMessage());\n                }\n            });\n        }\n\n        return size;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "LocalFileStorage.java",
        "method_name": "saveStream",
        "raw_code": "public long saveStream(FileRef fileRef, InputStream inputStream) {\n        Path relativePath = getRelativePath(fileRef.getPath());\n\n        Path[] roots = getStorageRoots();\n\n        // Store to primary storage\n        checkStorageDefined(roots, fileRef.getFileName());\n        checkPrimaryStorageAccessible(roots, fileRef.getFileName());\n\n        Path path = roots[0].resolve(relativePath);\n        Path parentPath = path.getParent();\n        if (parentPath == null) {\n            throw new FileStorageException(FileStorageException.Type.IO_EXCEPTION,\n                    \"Invalid storage root: \" + path);\n        }\n        if (!parentPath.toFile().exists() && !parentPath.toFile().mkdirs()) {\n            throw new FileStorageException(FileStorageException.Type.IO_EXCEPTION,\n                    \"Cannot create directory: \" + parentPath.toAbsolutePath());\n        }\n\n        checkFileExists(path);\n\n        long size;\n        long maxAllowedSize = properties.getMaxFileSize().toBytes();\n        try (OutputStream outputStream = Files.newOutputStream(path, CREATE_NEW)) {\n            size = IOUtils.copyLarge(inputStream, outputStream, 0, maxAllowedSize);\n\n            if (size >= maxAllowedSize) {\n                if (inputStream.read() != IOUtils.EOF) {\n                    outputStream.close();\n                    if (path.toFile().exists()) path.toFile().delete();\n\n                    throw new FileStorageException(FileStorageException.Type.IO_EXCEPTION,\n                            String.format(\"File is too large: '%s'. Max file size = %s MB is exceeded but there are unread bytes left.\",\n                                    path.toAbsolutePath(),\n                                    properties.getMaxFileSize().toMegabytes()));\n                }\n            }\n            outputStream.flush();\n//            writeLog(path, false);\n        } catch (IOException e) {\n            FileUtils.deleteQuietly(path.toFile());\n            throw new FileStorageException(FileStorageException.Type.IO_EXCEPTION, path.toAbsolutePath().toString(), e);\n        }\n\n        // Copy file to secondary storages asynchronously\n        for (int i = 1; i < roots.length; i++) {\n            if (!roots[i].toFile().exists()) {\n                log.error(\"Error saving {} into {} : directory doesn't exist\", fileRef.getFileName(), roots[i]);\n                continue;\n            }\n\n            Path pathCopy = roots[i].resolve(relativePath);\n\n            writeExecutor.submit(() -> {\n                try {\n                    FileUtils.copyFile(path.toFile(), pathCopy.toFile(), true);\n                } catch (Exception e) {\n                    log.error(\"Error saving {} into {} : {}\", fileRef.getFileName(), pathCopy, e.getMessage());\n                }\n            });\n        }\n\n        return size;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "milo",
    "cve_id": "CVE-2022-25897",
    "cwe_list": [
      "CWE-770"
    ],
    "commit_hash": "4534381760d7d9f0bf00cbf6a8449bb0d13c6ce5",
    "short_hash": "45343817",
    "vulnerableMethods_before": [],
    "vulnerableMethods_after": [
      {
        "filename": "SubscriptionManager.java",
        "method_name": "opc-ua-sdk/sdk-server/src/main/java/org/eclipse/milo/opcua/sdk/server/subscriptions/SubscriptionManager.java#deleteMonitoredItems",
        "raw_code": "public void deleteMonitoredItems(ServiceRequest service) throws UaException {\n        DeleteMonitoredItemsRequest request = (DeleteMonitoredItemsRequest) service.getRequest();\n\n        UInteger subscriptionId = request.getSubscriptionId();\n        Subscription subscription = subscriptions.get(subscriptionId);\n        List<UInteger> itemsToDelete = l(request.getMonitoredItemIds());\n\n        if (subscription == null) {\n            throw new UaException(StatusCodes.Bad_SubscriptionIdInvalid);\n        }\n        if (itemsToDelete.isEmpty()) {\n            throw new UaException(StatusCodes.Bad_NothingToDo);\n        }\n\n        StatusCode[] deleteResults = new StatusCode[itemsToDelete.size()];\n        List<BaseMonitoredItem<?>> deletedItems = newArrayListWithCapacity(itemsToDelete.size());\n\n        synchronized (subscription) {\n            for (int i = 0; i < itemsToDelete.size(); i++) {\n                UInteger itemId = itemsToDelete.get(i);\n                BaseMonitoredItem<?> item = subscription.getMonitoredItems().get(itemId);\n\n                if (item == null) {\n                    deleteResults[i] = new StatusCode(StatusCodes.Bad_MonitoredItemIdInvalid);\n                } else {\n                    deletedItems.add(item);\n\n                    deleteResults[i] = StatusCode.GOOD;\n\n                    monitoredItemCount.decrementAndGet();\n                    server.getMonitoredItemCount().decrementAndGet();\n                }\n            }\n\n            subscription.removeMonitoredItems(deletedItems);\n        }\n\n        /*\n         * Notify AddressSpaces of the items that have been deleted.\n         */\n\n        byMonitoredItemType(\n            deletedItems,\n            dataItems -> server.getAddressSpaceManager().onDataItemsDeleted(dataItems),\n            eventItems -> server.getAddressSpaceManager().onEventItemsDeleted(eventItems)\n        );\n\n        /*\n         * Build and return results.\n         */\n        ResponseHeader header = service.createResponseHeader();\n\n        DeleteMonitoredItemsResponse response = new DeleteMonitoredItemsResponse(\n            header,\n            deleteResults,\n            new DiagnosticInfo[0]\n        );\n\n        service.setResponse(response);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "cdt",
    "cve_id": "CVE-2023-4218",
    "cwe_list": [
      "CWE-611"
    ],
    "commit_hash": "c7169b3186d2fef20f97467c3e2ad78e2943ed1b",
    "short_hash": "c7169b31",
    "vulnerableMethods_before": [
      {
        "filename": "SharedDefaults.java",
        "method_name": "core/org.eclipse.cdt.core/templateengine/org/eclipse/cdt/core/templateengine/SharedDefaults.java#generateSharedXML",
        "raw_code": "private void generateSharedXML(File xmlFile) {\n\t\tDocument d;\n\t\ttry {\n\t\t\td = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n\t\t} catch (ParserConfigurationException e) {\n\t\t\tTemplateEngineUtil.log(e);\n\t\t\treturn;\n\t\t}\n\t\tNode rootElement = d.appendChild(d.createElement(\"SharedRoot\")); //$NON-NLS-1$\n\n\t\tfor (String key : sharedDefaultsMap.keySet()) {\n\t\t\tElement element = (Element) rootElement.appendChild(d.createElement(\"SharedProperty\")); //$NON-NLS-1$\n\t\t\telement.setAttribute(TemplateEngineHelper.ID, key);\n\t\t\telement.setAttribute(TemplateEngineHelper.VALUE, sharedDefaultsMap.get(key));\n\t\t}\n\n\t\tDOMSource domSource = new DOMSource(d);\n\t\tTransformerFactory transFactory = TransformerFactory.newInstance();\n\t\tResult fileResult = new StreamResult(xmlFile);\n\t\ttry {\n\t\t\ttransFactory.newTransformer().transform(domSource, fileResult);\n\t\t} catch (Throwable t) {\n\t\t\tTemplateEngineUtil.log(t);\n\t\t}\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "SharedDefaults.java",
        "method_name": "core/org.eclipse.cdt.core/templateengine/org/eclipse/cdt/core/templateengine/SharedDefaults.java#generateSharedXML",
        "raw_code": "private void generateSharedXML(File xmlFile) {\n\t\tDocument d;\n\t\ttry {\n\t\t\td = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE().newDocument();\n\t\t} catch (ParserConfigurationException e) {\n\t\t\tTemplateEngineUtil.log(e);\n\t\t\treturn;\n\t\t}\n\t\tNode rootElement = d.appendChild(d.createElement(\"SharedRoot\")); //$NON-NLS-1$\n\n\t\tfor (String key : sharedDefaultsMap.keySet()) {\n\t\t\tElement element = (Element) rootElement.appendChild(d.createElement(\"SharedProperty\")); //$NON-NLS-1$\n\t\t\telement.setAttribute(TemplateEngineHelper.ID, key);\n\t\t\telement.setAttribute(TemplateEngineHelper.VALUE, sharedDefaultsMap.get(key));\n\t\t}\n\n\t\tDOMSource domSource = new DOMSource(d);\n\t\tTransformerFactory transFactory = XmlProcessorFactoryCdt.createTransformerFactoryWithErrorOnDOCTYPE();\n\t\tResult fileResult = new StreamResult(xmlFile);\n\t\ttry {\n\t\t\ttransFactory.newTransformer().transform(domSource, fileResult);\n\t\t} catch (Throwable t) {\n\t\t\tTemplateEngineUtil.log(t);\n\t\t}\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "rebuild",
    "cve_id": "CVE-2023-1495",
    "cwe_list": [
      "CWE-89"
    ],
    "commit_hash": "c9474f84e5f376dd2ade2078e3039961a9425da7",
    "short_hash": "c9474f84",
    "vulnerableMethods_before": [
      {
        "filename": "ReferenceSearchController.java",
        "method_name": "buildResultSearch",
        "raw_code": "private JSON buildResultSearch(Entity searchEntity, String quickFields, String q, String appendWhere, int maxResults) {\n        String searchWhere = \"(1=1)\";\n\n        if (StringUtils.isNotBlank(q)) {\n            // \n            Set<String> searchFields = ParseHelper.buildQuickFields(searchEntity, quickFields);\n            if (searchFields.isEmpty()) {\n                return JSONUtils.EMPTY_ARRAY;\n            }\n\n            String like = \" like '%\" + StringEscapeUtils.escapeSql(q) + \"%'\";\n            searchWhere = StringUtils.join(searchFields.iterator(), like + \" or \") + like;\n        }\n\n        if (appendWhere != null) {\n            searchWhere = String.format(\"(%s) and (%s)\", appendWhere, searchWhere);\n        } else {\n            searchWhere = String.format(\"(%s)\", searchWhere);\n        }\n\n        List<Object> result = resultSearch(searchWhere, searchEntity, maxResults);\n        return (JSON) JSON.toJSON(result);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ReferenceSearchController.java",
        "method_name": "buildResultSearch",
        "raw_code": "private JSON buildResultSearch(Entity searchEntity, String quickFields, String q, String appendWhere, int maxResults) {\n        String searchWhere = \"(1=1)\";\n\n        if (StringUtils.isNotBlank(q)) {\n            // \n            Set<String> searchFields = ParseHelper.buildQuickFields(searchEntity, quickFields);\n            if (searchFields.isEmpty()) {\n                return JSONUtils.EMPTY_ARRAY;\n            }\n\n            String like = \" like '%\" + CommonsUtils.escapeSql(q) + \"%'\";\n            searchWhere = StringUtils.join(searchFields.iterator(), like + \" or \") + like;\n        }\n\n        if (appendWhere != null) {\n            searchWhere = String.format(\"(%s) and (%s)\", appendWhere, searchWhere);\n        } else {\n            searchWhere = String.format(\"(%s)\", searchWhere);\n        }\n\n        List<Object> result = resultSearch(searchWhere, searchEntity, maxResults);\n        return (JSON) JSON.toJSON(result);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "UnsafeAccessor",
    "cve_id": "CVE-2022-31139",
    "cwe_list": [
      "CWE-863"
    ],
    "commit_hash": "4ef83000184e8f13239a1ea2847ee401d81585fd",
    "short_hash": "4ef83000",
    "vulnerableMethods_before": [
      {
        "filename": "UnsafeAccess.java",
        "method_name": "api/src/main/java/io/github/karlatemp/unsafeaccessor/UnsafeAccess.java#getInstance",
        "raw_code": "public static UnsafeAccess getInstance() {\n        SecurityCheck.getInstance();\n        return INSTANCE;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "UnsafeAccess.java",
        "method_name": "api/src/main/java/io/github/karlatemp/unsafeaccessor/UnsafeAccess.java#getInstance",
        "raw_code": "public static UnsafeAccess getInstance() {\n        SecurityCheck.AccessLimiter accessLimiter = SecurityCheck.getInstance().getLimiter();\n        if (accessLimiter != null) accessLimiter.preGetUnsafeAccess();\n        return INSTANCE;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "cdt",
    "cve_id": "CVE-2023-4218",
    "cwe_list": [
      "CWE-611"
    ],
    "commit_hash": "c7169b3186d2fef20f97467c3e2ad78e2943ed1b",
    "short_hash": "c7169b31",
    "vulnerableMethods_before": [
      {
        "filename": "CHelpProvider.java",
        "method_name": "core/org.eclipse.cdt.ui/src/org/eclipse/cdt/internal/ui/help/CHelpProvider.java#loadFile",
        "raw_code": "private void loadFile(IConfigurationElement el, ArrayList<ICHelpBook> chbl, String pluginId) {\n\t\tString fname = el.getAttribute(ATTRIB_FILE);\n\t\tif (fname == null || fname.trim().length() == 0)\n\t\t\treturn;\n\t\tURL x = FileLocator.find(Platform.getBundle(pluginId), new Path(fname), null);\n\t\tif (x == null)\n\t\t\treturn;\n\t\ttry {\n\t\t\tx = FileLocator.toFileURL(x);\n\t\t} catch (IOException e) {\n\t\t\treturn;\n\t\t}\n\t\tfname = x.getPath();\n\t\tif (fname == null || fname.trim().length() == 0)\n\t\t\treturn;\n\n\t\t// format is not supported for now\n\t\t// String format = el.getAttribute(ATTRIB_FORMAT);\n\n\t\tDocument doc = null;\n\t\ttry {\n\t\t\tInputStream stream = new FileInputStream(fname);\n\t\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(stream));\n\t\t\tInputSource src = new InputSource(reader);\n\t\t\tDocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n\t\t\tdoc = builder.parse(src);\n\t\t\tElement e = doc.getDocumentElement();\n\t\t\tif (NODE_HEAD.equals(e.getNodeName())) {\n\t\t\t\tNodeList list = e.getChildNodes();\n\t\t\t\tfor (int j = 0; j < list.getLength(); j++) {\n\t\t\t\t\tNode node = list.item(j);\n\t\t\t\t\tif (node.getNodeType() != Node.ELEMENT_NODE)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (NODE_BOOK.equals(node.getNodeName())) {\n\t\t\t\t\t\tchbl.add(new CHelpBook((Element) node));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (ParserConfigurationException e) {\n\t\t} catch (SAXException e) {\n\t\t} catch (IOException e) {\n\t\t}\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "CHelpProvider.java",
        "method_name": "core/org.eclipse.cdt.ui/src/org/eclipse/cdt/internal/ui/help/CHelpProvider.java#loadFile",
        "raw_code": "private void loadFile(IConfigurationElement el, ArrayList<ICHelpBook> chbl, String pluginId) {\n\t\tString fname = el.getAttribute(ATTRIB_FILE);\n\t\tif (fname == null || fname.trim().length() == 0)\n\t\t\treturn;\n\t\tURL x = FileLocator.find(Platform.getBundle(pluginId), new Path(fname), null);\n\t\tif (x == null)\n\t\t\treturn;\n\t\ttry {\n\t\t\tx = FileLocator.toFileURL(x);\n\t\t} catch (IOException e) {\n\t\t\treturn;\n\t\t}\n\t\tfname = x.getPath();\n\t\tif (fname == null || fname.trim().length() == 0)\n\t\t\treturn;\n\n\t\t// format is not supported for now\n\t\t// String format = el.getAttribute(ATTRIB_FORMAT);\n\n\t\tDocument doc = null;\n\t\ttry {\n\t\t\tInputStream stream = new FileInputStream(fname);\n\t\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(stream));\n\t\t\tInputSource src = new InputSource(reader);\n\t\t\tDocumentBuilder builder = XmlProcessorFactoryCdt.createDocumentBuilderWithErrorOnDOCTYPE();\n\t\t\tdoc = builder.parse(src);\n\t\t\tElement e = doc.getDocumentElement();\n\t\t\tif (NODE_HEAD.equals(e.getNodeName())) {\n\t\t\t\tNodeList list = e.getChildNodes();\n\t\t\t\tfor (int j = 0; j < list.getLength(); j++) {\n\t\t\t\t\tNode node = list.item(j);\n\t\t\t\t\tif (node.getNodeType() != Node.ELEMENT_NODE)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (NODE_BOOK.equals(node.getNodeName())) {\n\t\t\t\t\t\tchbl.add(new CHelpBook((Element) node));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tCUIPlugin.log(\"Failed to load helpbook in \" + pluginId, e); //$NON-NLS-1$\n\t\t}\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "langchain4j-aideepin",
    "cve_id": "CVE-2025-21604",
    "cwe_list": [
      "CWE-328"
    ],
    "commit_hash": "3cf625c5044a151a8cbcbdf98e10b4b46b8a975a",
    "short_hash": "3cf625c5",
    "vulnerableMethods_before": [
      {
        "filename": "FileService.java",
        "method_name": "removeFileAndSoftDel",
        "raw_code": "public void removeFileAndSoftDel(String uuid) {\n        AdiFile adiFile = this.lambdaQuery()\n                .eq(AdiFile::getUserId, ThreadContext.getCurrentUserId())\n                .eq(AdiFile::getUuid, uuid)\n                .oneOpt()\n                .orElse(null);\n        if (null == adiFile) {\n            return;\n        }\n        if (StringUtils.isNotBlank(adiFile.getPath())) {\n            File file = new File(adiFile.getPath());\n            if (!file.delete()) {\n                log.warn(\"Delete file error,uuid:{}\", uuid);\n            }\n        }\n        this.softDel(uuid);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "FileService.java",
        "method_name": "removeFileAndSoftDel",
        "raw_code": "public void removeFileAndSoftDel(String uuid) {\n        AdiFile adiFile = this.lambdaQuery()\n                .eq(AdiFile::getUserId, ThreadContext.getCurrentUserId())\n                .eq(AdiFile::getUuid, uuid)\n                .oneOpt()\n                .orElse(null);\n        if (null == adiFile) {\n            return;\n        }\n        if (StringUtils.isNotBlank(adiFile.getPath())) {\n            try {\n                if (!Files.deleteIfExists(Paths.get(adiFile.getPath()))) {\n                    log.warn(\"Delete file fail,uuid:{}\", uuid);\n                }\n            } catch (IOException e) {\n                throw new BaseException(B_DELETE_FILE_ERROR);\n            }\n        }\n        this.softDel(uuid);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "dataease",
    "cve_id": "CVE-2023-40183",
    "cwe_list": [
      "CWE-434"
    ],
    "commit_hash": "826513053146721a2b3e09a9c9d3ea41f8f10569",
    "short_hash": "82651305",
    "vulnerableMethods_before": [
      {
        "filename": "StaticResourceService.java",
        "method_name": "core/backend/src/main/java/io/dataease/service/staticResource/StaticResourceService.java#isImage",
        "raw_code": "private boolean isImage(MultipartFile file) {\n        BufferedImage image = null;\n        try (InputStream input = file.getInputStream()) {\n            image = ImageIO.read(input);\n        } catch (IOException e) {\n            LogUtil.error(e.getMessage(), e);\n            return false;\n        }\n        if (image == null || image.getWidth() <= 0 || image.getHeight() <= 0) {\n            return false;\n        }\n        return true;\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "StaticResourceService.java",
        "method_name": "core/backend/src/main/java/io/dataease/service/staticResource/StaticResourceService.java#isImage",
        "raw_code": "private boolean isImage(MultipartFile file) {\n        BufferedImage image = null;\n        try (InputStream input = file.getInputStream()) {\n            image = ImageIO.read(input);\n        } catch (IOException e) {\n            LogUtil.error(e.getMessage(), e);\n            return false;\n        }\n        Pattern pattern = Pattern.compile(\"\\\\.(png|jpg|jpeg|gif)$\");\n        Matcher matcher = pattern.matcher(file.getOriginalFilename().toLowerCase());\n        if (image == null || image.getWidth() <= 0 || image.getHeight() <= 0 || !matcher.find()) {\n            return false;\n        }\n\n        return true;\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xp",
    "cve_id": "CVE-2024-23679",
    "cwe_list": [
      "CWE-384"
    ],
    "commit_hash": "2abac31cec8679074debc4f1fb69c25930e40842",
    "short_hash": "2abac31c",
    "vulnerableMethods_before": [
      {
        "filename": "LoginHandler.java",
        "method_name": "modules/lib/lib-auth/src/main/java/com/enonic/xp/lib/auth/LoginHandler.java#getSortedIdProviders",
        "raw_code": "private IdProviders getSortedIdProviders()\n    {\n        IdProviders idProviders = securityService.get().getIdProviders();\n        return IdProviders.from( idProviders.stream().\n            sorted( Comparator.comparing( u -> u.getKey().toString() ) ).\n            collect( Collectors.toList() ) );\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "LoginHandler.java",
        "method_name": "modules/lib/lib-auth/src/main/java/com/enonic/xp/lib/auth/LoginHandler.java#getSortedIdProviders",
        "raw_code": "private IdProviders getSortedIdProviders()\n    {\n        IdProviders idProviders = securityService.get().getIdProviders();\n        return IdProviders.from(\n            idProviders.stream().sorted( Comparator.comparing( u -> u.getKey().toString() ) ).collect( Collectors.toList() ) );\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "OpenSearch",
    "cve_id": "CVE-2022-41917",
    "cwe_list": [
      "CWE-755"
    ],
    "commit_hash": "6d20423f5920745463b1abc5f1daf6a786c41aa0",
    "short_hash": "6d20423f",
    "vulnerableMethods_before": [
      {
        "filename": "Analysis.java",
        "method_name": "server/src/main/java/org/opensearch/index/analysis/Analysis.java#getWordSet",
        "raw_code": "public static CharArraySet getWordSet(Environment env, Settings settings, String settingsPrefix) {\n        List<String> wordList = getWordList(env, settings, settingsPrefix);\n        if (wordList == null) {\n            return null;\n        }\n        boolean ignoreCase = settings.getAsBoolean(settingsPrefix + \"_case\", false);\n        return new CharArraySet(wordList, ignoreCase);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "Analysis.java",
        "method_name": "server/src/main/java/org/opensearch/index/analysis/Analysis.java#getWordSet",
        "raw_code": "public static CharArraySet getWordSet(Environment env, Settings settings, String settingsPrefix) {\n        List<String> wordList = parseWordList(env, settings, settingsPrefix, s -> s);\n        if (wordList == null) {\n            return null;\n        }\n        boolean ignoreCase = settings.getAsBoolean(settingsPrefix + \"_case\", false);\n        return new CharArraySet(wordList, ignoreCase);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "xwiki-platform",
    "cve_id": "CVE-2023-37913",
    "cwe_list": [
      "CWE-22"
    ],
    "commit_hash": "45d182a4141ff22f3ff289cf71e4669bdc714544",
    "short_hash": "45d182a4",
    "vulnerableMethods_before": [
      {
        "filename": "DefaultPresentationBuilder.java",
        "method_name": "xwiki-platform-core/xwiki-platform-office/xwiki-platform-office-importer/src/main/java/org/xwiki/officeimporter/internal/builder/DefaultPresentationBuilder.java#build",
        "raw_code": "@Override\n    public XDOMOfficeDocument build(InputStream officeFileStream, String officeFileName,\n        DocumentReference documentReference) throws OfficeImporterException\n    {\n        // Accents seems to cause issues in some conditions\n        // See https://jira.xwiki.org/browse/XWIKI-14692\n        String cleanedOfficeFileName = StringUtils.stripAccents(officeFileName);\n\n        // Invoke the office document converter.\n        OfficeConverterResult officeConverterResult = importPresentation(officeFileStream, cleanedOfficeFileName);\n\n        Pair<String, Set<File>> htmlPresentationResult = null;\n        // Create presentation HTML.\n        try {\n            htmlPresentationResult = buildPresentationHTML(officeConverterResult,\n                StringUtils.substringBeforeLast(cleanedOfficeFileName, \".\"));\n        } catch (IOException e) {\n            throw new OfficeImporterException(\"Error while preparing the presentation artifacts.\", e);\n        }\n\n        // Clear and adjust presentation HTML (slide image URLs are updated to point to the corresponding attachments).\n        String html = cleanPresentationHTML(htmlPresentationResult.getLeft(), documentReference);\n\n        // Create the XDOM.\n        XDOM xdom = buildPresentationXDOM(html, documentReference);\n\n        return new XDOMOfficeDocument(xdom, htmlPresentationResult.getRight(),\n            this.contextComponentManagerProvider.get(), officeConverterResult);\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "DefaultPresentationBuilder.java",
        "method_name": "xwiki-platform-core/xwiki-platform-office/xwiki-platform-office-importer/src/main/java/org/xwiki/officeimporter/internal/builder/DefaultPresentationBuilder.java#build",
        "raw_code": "@Override\n    public XDOMOfficeDocument build(InputStream officeFileStream, String officeFileName,\n        DocumentReference documentReference) throws OfficeImporterException\n    {\n        // Invoke the office document converter.\n        OfficeConverterResult officeConverterResult = importPresentation(officeFileStream, officeFileName);\n\n        Pair<String, Map<String, OfficeDocumentArtifact>> htmlPresentationResult;\n        // Create presentation HTML.\n        try {\n            htmlPresentationResult = buildPresentationHTML(officeConverterResult,\n                StringUtils.substringBeforeLast(officeFileName, \".\"));\n        } catch (IOException e) {\n            throw new OfficeImporterException(\"Error while preparing the presentation artifacts.\", e);\n        }\n\n        // Clear and adjust presentation HTML (slide image URLs are updated to point to the corresponding attachments).\n        String html = cleanPresentationHTML(htmlPresentationResult.getLeft(), documentReference);\n\n        // Create the XDOM.\n        XDOM xdom = buildPresentationXDOM(html, documentReference);\n\n        return new XDOMOfficeDocument(xdom, htmlPresentationResult.getRight(),\n            this.contextComponentManagerProvider.get(), officeConverterResult);\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "Java-springboot-codebase",
    "cve_id": "CVE-2024-52302",
    "cwe_list": [
      "CWE-434"
    ],
    "commit_hash": "204402bb8b68030c14911379ddc82cfff00b8538",
    "short_hash": "204402bb",
    "vulnerableMethods_before": [],
    "vulnerableMethods_after": [
      {
        "filename": "FileSystemStorageService.java",
        "method_name": "spring boot/common-user-management/src/main/java/common/management/common/service/impl/FileSystemStorageService.java#store",
        "raw_code": "@Override\n    public int store(MultipartFile file, String nameAndExt) {\n        Path location = Paths.get(rootLocation+\"/\");\n\n        try {\n            Files.createDirectories(location);\n            if (file.isEmpty()) {\n                return OP_STATUS_FILE_EMPTY;\n            }\n            if (nameAndExt.contains(\"..\")) {\n                // This is a security check\n               return OP_STATUS_INVALID_FILE_NAME;\n            }\n\n            if(!isAllowedFileType(file)) return OP_STATUS_FILE_TYPE_NOT_ALLOWED;\n\n            try (InputStream inputStream = file.getInputStream()) {\n\n                Files.copy(inputStream, location.resolve(nameAndExt),\n                        StandardCopyOption.REPLACE_EXISTING);\n\n                if(isImage(FilenameUtils.getExtension(file.getOriginalFilename()))){\n                    createThumbnail(file,thumbWidth,nameAndExt);\n                }\n            }\n            return OP_STATUS_SUCCESS;\n        }\n        catch (IOException e) {\n            log.error(\"[EXCEPTION] store : {},{}\",e.getMessage(),e.getCause());\n            return OP_STATUS_FAILED;\n        }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "tigervnc",
    "cve_id": "CVE-2020-26117",
    "cwe_list": [
      "CWE-295"
    ],
    "commit_hash": "f029745f63ac7d22fb91639b2cb5b3ab56134d6e",
    "short_hash": "f029745f",
    "vulnerableMethods_before": [
      {
        "filename": "CSecurityTLS.java",
        "method_name": "java/com/tigervnc/rfb/CSecurityTLS.java#checkServerTrusted",
        "raw_code": "public void checkServerTrusted(X509Certificate[] chain, String authType)\n      throws CertificateException\n    {\n      Collection<? extends Certificate> certs = null;\n      X509Certificate cert = chain[0];\n      try {\n        cert.checkValidity();\n      } catch(CertificateNotYetValidException e) {\n        throw new AuthFailureException(\"server certificate has not been activated\");\n      } catch(CertificateExpiredException e) {\n        if (!msg.showMsgBox(YES_NO_OPTION, \"certificate has expired\",\n\t\t\t      \"The certificate of the server has expired, \"+\n\t\t\t      \"do you want to continue?\"))\n          throw new AuthFailureException(\"server certificate has expired\");\n      }\n      String thumbprint = getThumbprint(cert);\n      File vncDir = new File(FileUtils.getVncHomeDir());\n      File certFile = new File(vncDir, \"x509_savedcerts.pem\");\n      CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n      if (vncDir.exists() && certFile.exists() && certFile.canRead()) {\n        InputStream certStream = new MyFileInputStream(certFile);\n        certs = cf.generateCertificates(certStream);\n        for (Certificate c : certs)\n          if (thumbprint.equals(getThumbprint((X509Certificate)c)))\n            return;\n      }\n      try {\n        verifyHostname(cert);\n        tm.checkServerTrusted(chain, authType);\n      } catch (java.lang.Exception e) {\n        if (e.getCause() instanceof CertPathBuilderException) {\n          String certinfo =\n            \"This certificate has been signed by an unknown authority\\n\"+\n            \"\\n\"+\n            \"  Subject: \"+cert.getSubjectX500Principal().getName()+\"\\n\"+\n            \"  Issuer: \"+cert.getIssuerX500Principal().getName()+\"\\n\"+\n            \"  Serial Number: \"+cert.getSerialNumber()+\"\\n\"+\n            \"  Version: \"+cert.getVersion()+\"\\n\"+\n            \"  Signature Algorithm: \"+cert.getPublicKey().getAlgorithm()+\"\\n\"+\n            \"  Not Valid Before: \"+cert.getNotBefore()+\"\\n\"+\n            \"  Not Valid After: \"+cert.getNotAfter()+\"\\n\"+\n            \"  SHA1 Fingerprint: \"+getThumbprint(cert)+\"\\n\"+\n            \"\\n\"+\n            \"Do you want to save it and continue?\";\n          if (!msg.showMsgBox(YES_NO_OPTION, \"certificate issuer unknown\",\n                certinfo)) {\n            throw new AuthFailureException(\"certificate issuer unknown\");\n          }\n          if (certs == null || !certs.contains(cert)) {\n            byte[] der = cert.getEncoded();\n            String pem = Base64.getEncoder().encodeToString(der);\n            pem = pem.replaceAll(\"(.{64})\", \"$1\\n\");\n            FileWriter fw = null;\n            try {\n              if (!vncDir.exists())\n                vncDir.mkdir();\n              if (!certFile.exists() && !certFile.createNewFile()) {\n                vlog.error(\"Certificate save failed.\");\n              } else {\n                fw = new FileWriter(certFile.getAbsolutePath(), true);\n                fw.write(\"-----BEGIN CERTIFICATE-----\\n\");\n                fw.write(pem+\"\\n\");\n                fw.write(\"-----END CERTIFICATE-----\\n\");\n              }\n            } catch (IOException ioe) {\n              msg.showMsgBox(OK_OPTION, \"certificate save failed\",\n                             \"Could not save the certificate\");\n            } finally {\n              try {\n                if (fw != null)\n                  fw.close();\n              } catch(IOException ioe2) {\n                throw new Exception(ioe2.getMessage());\n              }\n            }\n          }\n        } else {\n          throw new SystemException(e.getMessage());\n        }\n      }\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "CSecurityTLS.java",
        "method_name": "java/com/tigervnc/rfb/CSecurityTLS.java#checkServerTrusted",
        "raw_code": "public void checkServerTrusted(X509Certificate[] chain, String authType)\n      throws CertificateException\n    {\n      Collection<? extends Certificate> certs = null;\n      X509Certificate cert = chain[0];\n      String pk =\n        Base64.getEncoder().encodeToString(cert.getPublicKey().getEncoded());\n      try {\n        cert.checkValidity();\n        verifyHostname(cert);\n      } catch(CertificateParsingException e) {\n        throw new SystemException(e.getMessage());\n      } catch(CertificateNotYetValidException e) {\n        throw new AuthFailureException(\"server certificate has not been activated\");\n      } catch(CertificateExpiredException e) {\n        if (!msg.showMsgBox(YES_NO_OPTION, \"certificate has expired\",\n\t\t\t      \"The certificate of the server has expired, \"+\n\t\t\t      \"do you want to continue?\"))\n          throw new AuthFailureException(\"server certificate has expired\");\n      }\n      File vncDir = new File(FileUtils.getVncHomeDir());\n      if (!vncDir.exists())\n        throw new AuthFailureException(\"Could not obtain VNC home directory \"+\n                                       \"path for known hosts storage\");\n      File dbPath = new File(vncDir, \"x509_known_hosts\");\n      String info =\n        \"  Subject: \"+cert.getSubjectX500Principal().getName()+\"\\n\"+\n        \"  Issuer: \"+cert.getIssuerX500Principal().getName()+\"\\n\"+\n        \"  Serial Number: \"+cert.getSerialNumber()+\"\\n\"+\n        \"  Version: \"+cert.getVersion()+\"\\n\"+\n        \"  Signature Algorithm: \"+cert.getPublicKey().getAlgorithm()+\"\\n\"+\n        \"  Not Valid Before: \"+cert.getNotBefore()+\"\\n\"+\n        \"  Not Valid After: \"+cert.getNotAfter()+\"\\n\"+\n        \"  SHA-1 Fingerprint: \"+getThumbprint(cert)+\"\\n\";\n      try {\n        if (dbPath.exists()) {\n          FileReader db = new FileReader(dbPath);\n          BufferedReader dbBuf = new BufferedReader(db);\n          String line;\n          String server = client.getServerName().toLowerCase();\n          while ((line = dbBuf.readLine())!=null) {\n            String fields[] = line.split(\"\\\\|\");\n            if (fields.length==6) {\n              if (server.equals(fields[2]) && pk.equals(fields[5])) {\n                vlog.debug(\"Server certificate found in known hosts file\");\n                dbBuf.close();\n                return;\n              } else if (server.equals(fields[2]) && !pk.equals(fields[5]) ||\n                         !server.equals(fields[2]) && pk.equals(fields[5])) {\n                throw new CertStoreException();\n              }\n            }\n          }\n          dbBuf.close();\n        }\n        tm.checkServerTrusted(chain, authType);\n      } catch (IOException e) {\n        throw new AuthFailureException(\"Could not load known hosts database\");\n      } catch (CertStoreException e) {\n        vlog.debug(\"Server host key mismatch\");\n        vlog.debug(info);\n        String text =\n          \"This host is previously known with a different \"+\n          \"certificate, and the new certificate has been \"+\n          \"signed by an unknown authority\\n\"+\n          \"\\n\"+info+\"\\n\"+\n          \"Someone could be trying to impersonate the site and you should not continue.\\n\"+\n          \"\\n\"+\n          \"Do you want to make an exception for this server?\";\n        if (!msg.showMsgBox(YES_NO_OPTION, \"Unexpected certificate issuer\", text))\n          throw new AuthFailureException(\"Unexpected certificate issuer\");\n        store_pubkey(dbPath, client.getServerName().toLowerCase(), pk);\n      } catch (java.lang.Exception e) {\n        if (e.getCause() instanceof CertPathBuilderException) {\n          vlog.debug(\"Server host not previously known\");\n          vlog.debug(info);\n          String text =\n            \"This certificate has been signed by an unknown authority\\n\"+\n            \"\\n\"+info+\"\\n\"+\n            \"Someone could be trying to impersonate the site and you should not continue.\\n\"+\n            \"\\n\"+\n            \"Do you want to make an exception for this server?\";\n          if (!msg.showMsgBox(YES_NO_OPTION, \"Unknown certificate issuer\", text))\n            throw new AuthFailureException(\"Unknown certificate issuer\");\n          store_pubkey(dbPath, client.getServerName().toLowerCase(), pk);\n        } else {\n          throw new SystemException(e.getMessage());\n        }\n      }\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "socket.io-client-java",
    "cve_id": "CVE-2022-25867",
    "cwe_list": [
      "CWE-476"
    ],
    "commit_hash": "e8ffe9d1383736f6a21090ab959a2f4fa5a41284",
    "short_hash": "e8ffe9d1",
    "vulnerableMethods_before": [
      {
        "filename": "Manager.java",
        "method_name": "src/main/java/io/socket/client/Manager.java#onopen",
        "raw_code": "private void onopen() {\n        logger.fine(\"open\");\n\n        this.cleanup();\n\n        this.readyState = ReadyState.OPEN;\n        this.emit(EVENT_OPEN);\n\n        final io.socket.engineio.client.Socket socket = this.engine;\n        this.subs.add(On.on(socket, Engine.EVENT_DATA, new Listener() {\n            @Override\n            public void call(Object... objects) {\n                Object data = objects[0];\n                if (data instanceof String) {\n                    Manager.this.ondata((String)data);\n                } else if (data instanceof byte[]) {\n                    Manager.this.ondata((byte[])data);\n                }\n            }\n        }));\n        this.subs.add(On.on(socket, Engine.EVENT_ERROR, new Listener() {\n            @Override\n            public void call(Object... objects) {\n                Manager.this.onerror((Exception)objects[0]);\n            }\n        }));\n        this.subs.add(On.on(socket, Engine.EVENT_CLOSE, new Listener() {\n            @Override\n            public void call(Object... objects) {\n                Manager.this.onclose((String)objects[0]);\n            }\n        }));\n        this.decoder.onDecoded(new Parser.Decoder.Callback() {\n            @Override\n            public void call (Packet packet) {\n                Manager.this.ondecoded(packet);\n            }\n        });\n    }",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "Manager.java",
        "method_name": "src/main/java/io/socket/client/Manager.java#onopen",
        "raw_code": "private void onopen() {\n        logger.fine(\"open\");\n\n        this.cleanup();\n\n        this.readyState = ReadyState.OPEN;\n        this.emit(EVENT_OPEN);\n\n        final io.socket.engineio.client.Socket socket = this.engine;\n        this.subs.add(On.on(socket, Engine.EVENT_DATA, new Listener() {\n            @Override\n            public void call(Object... objects) {\n                Object data = objects[0];\n                try {\n                    if (data instanceof String) {\n                        Manager.this.decoder.add((String) data);\n                    } else if (data instanceof byte[]) {\n                        Manager.this.decoder.add((byte[]) data);\n                    }\n                } catch (DecodingException e) {\n                    logger.fine(\"error while decoding the packet: \" + e.getMessage());\n                }\n            }\n        }));\n        this.subs.add(On.on(socket, Engine.EVENT_ERROR, new Listener() {\n            @Override\n            public void call(Object... objects) {\n                Manager.this.onerror((Exception)objects[0]);\n            }\n        }));\n        this.subs.add(On.on(socket, Engine.EVENT_CLOSE, new Listener() {\n            @Override\n            public void call(Object... objects) {\n                Manager.this.onclose((String)objects[0]);\n            }\n        }));\n        this.decoder.onDecoded(new Parser.Decoder.Callback() {\n            @Override\n            public void call (Packet packet) {\n                Manager.this.ondecoded(packet);\n            }\n        });\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "hibernate-validator",
    "cve_id": "CVE-2025-35036",
    "cwe_list": [
      "CWE-94"
    ],
    "commit_hash": "d2db40b9e7d22c7a0b44d7665242dfc7b4d14d78",
    "short_hash": "d2db40b9",
    "vulnerableMethods_before": [
      {
        "filename": "ConstraintViolationCreationContext.java",
        "method_name": "toString",
        "raw_code": "@Override\n\tpublic String toString() {\n\t\tfinal StringBuilder sb = new StringBuilder( \"ConstraintViolationCreationContext{\" );\n\t\tsb.append( \"message='\" ).append( message ).append( '\\'' );\n\t\tsb.append( \", expressionLanguageEnabled=\" ).append( expressionLanguageEnabled );\n\t\tsb.append( \", propertyPath=\" ).append( propertyPath );\n\t\tsb.append( \", messageParameters=\" ).append( messageParameters );\n\t\tsb.append( \", expressionVariables=\" ).append( expressionVariables );\n\t\tsb.append( \", dynamicPayload=\" ).append( dynamicPayload );\n\t\tsb.append( '}' );\n\t\treturn sb.toString();\n\t}",
        "start_line": 1
      }
    ],
    "vulnerableMethods_after": [
      {
        "filename": "ConstraintViolationCreationContext.java",
        "method_name": "toString",
        "raw_code": "@Override\n\tpublic String toString() {\n\t\tfinal StringBuilder sb = new StringBuilder( \"ConstraintViolationCreationContext{\" );\n\t\tsb.append( \"message='\" ).append( message ).append( '\\'' );\n\t\tsb.append( \", expressionLanguageFeatureLevel=\" ).append( expressionLanguageFeatureLevel );\n\t\tsb.append( \", customViolation=\" ).append( customViolation );\n\t\tsb.append( \", propertyPath=\" ).append( propertyPath );\n\t\tsb.append( \", messageParameters=\" ).append( messageParameters );\n\t\tsb.append( \", expressionVariables=\" ).append( expressionVariables );\n\t\tsb.append( \", dynamicPayload=\" ).append( dynamicPayload );\n\t\tsb.append( '}' );\n\t\treturn sb.toString();\n\t}",
        "start_line": 1
      }
    ],
    "code_context": ""
  },
  {
    "repository": "core",
    "cve_id": "CVE-2014-8122",
    "cwe_list": [
      "CWE-362"
    ],
    "commit_hash": "6808b11cd6d97c71a2eed754ed4f955acd789086",
    "short_hash": "6808b11c",
    "vulnerableMethods_before": [],
    "vulnerableMethods_after": [
      {
        "filename": "RequestScopedCache.java",
        "method_name": "impl/src/main/java/org/jboss/weld/context/cache/RequestScopedCache.java#beginRequest",
        "raw_code": "public static void beginRequest() {\n        // if the previous request was not ended properly for some reason, make sure it is ended now\n        endRequest();\n        CACHE.set(new LinkedList<RequestScopedItem>());\n    }",
        "start_line": 1
      }
    ],
    "code_context": ""
  }
]